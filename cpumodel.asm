; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	elf64_fmtopt
PUBLIC	coff64_fmtopt
PUBLIC	ModelToken
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	sym_Cpu:QWORD
COMM	ZEROLOCALS:BYTE
COMM	sym_Interface:QWORD
COMM	evex:BYTE
$SG5758	DB	'TINY', 00H
	ORG $+3
$SG5759	DB	'SMALL', 00H
	ORG $+2
$SG5760	DB	'COMPACT', 00H
$SG5761	DB	'MEDIUM', 00H
	ORG $+1
$SG5762	DB	'LARGE', 00H
	ORG $+2
$SG5763	DB	'HUGE', 00H
	ORG $+3
$SG5764	DB	'FLAT', 00H
_DATA	ENDS
CONST	SEGMENT
ModelToken DQ	FLAT:$SG5758
	DQ	FLAT:$SG5759
	DQ	FLAT:$SG5760
	DQ	FLAT:$SG5761
	DQ	FLAT:$SG5762
	DQ	FLAT:$SG5763
	DQ	FLAT:$SG5764
CONST	ENDS
_DATA	SEGMENT
	ORG $+3
$SG5769	DB	'NEARSTACK', 00H
	ORG $+6
$SG5770	DB	'FARSTACK', 00H
	ORG $+3
$SG5771	DB	'OS_OS2', 00H
	ORG $+1
$SG5772	DB	'OS_DOS', 00H
_DATA	ENDS
CONST	SEGMENT
ModelAttr DQ	FLAT:$SG5769
	DQ	FLAT:$SG5770
	DQ	FLAT:$SG5771
	DQ	FLAT:$SG5772
ModelAttrValue DB 00H
	DB	02H
	DB	01H
	DB	02H
	DB	00H
	DB	04H
	DB	01H
	DB	04H
coff64_fmtopt DQ 0000000000000000H
	DW	0e12H
	DB	'PE32+', 00H
elf64_fmtopt DQ	0000000000000000H
	DW	0f00H
	DB	'ELF64', 00H
CONST	ENDS
_DATA	SEGMENT
	ORG $+5
$SG5822	DB	'@CodeSize', 00H
	ORG $+2
$SG5823	DB	'@code', 00H
	ORG $+6
$SG5831	DB	'@DataSize', 00H
	ORG $+2
$SG5832	DB	'FLAT', 00H
	ORG $+3
$SG5833	DB	'@data', 00H
	ORG $+2
$SG5835	DB	'STACK', 00H
	ORG $+2
$SG5836	DB	'@stack', 00H
	ORG $+1
$SG5837	DB	'@Model', 00H
	ORG $+5
$SG5838	DB	'@Interface', 00H
	ORG $+5
$SG5840	DB	'@ReservedStack', 00H
	ORG $+1
$SG5924	DB	'@Cpu', 00H
_DATA	ENDS
EXTRN	_stricmp:NEAR
xdata	SEGMENT
$unwind$FindToken DD 091d01H
	DD	09741dH
	DD	086413H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$FindToken DD @imagerel(FindToken#)
	DD	@imagerel(FindToken#+107)
	DD	@imagerel($unwind$FindToken#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cpumodel.c
pdata	ENDS
_TEXT	SEGMENT
token$ = 48
table$ = 56
size$ = 64
FindToken PROC NEAR

; 88   : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi

; 89   :     int i;
; 90   :     for( i = 0; i < size; i++, table++ ) {

	xor	ebx, ebx
	test	r8d, r8d
	mov	QWORD PTR [rsp+72], rdi
	mov	esi, r8d
	mov	rbp, rcx
	mov	rdi, rdx
	jle	SHORT $LN2@FindToken
	npad	8
$LL4@FindToken:

; 91   :         if( _stricmp( *table, token ) == 0 ) {

	mov	rcx, QWORD PTR [rdi]
	mov	rdx, rbp
	call	_stricmp
	test	eax, eax
	je	SHORT $LN8@FindToken
	inc	ebx
	add	rdi, 8
	cmp	ebx, esi
	jl	SHORT $LL4@FindToken
$LN2@FindToken:

; 93   :         }
; 94   :     }
; 95   :     return( -1 );  /* Not found */

	mov	eax, -1
$LN5@FindToken:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 96   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@FindToken:

; 92   :             return( i );

	mov	eax, ebx
	jmp	SHORT $LN5@FindToken
FindToken ENDP
_TEXT	ENDS
EXTRN	CreateVariable:NEAR
xdata	SEGMENT
$unwind$AddPredefinedConstant DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$AddPredefinedConstant DD @imagerel(AddPredefinedConstant#)
	DD	@imagerel(AddPredefinedConstant#+23)
	DD	@imagerel($unwind$AddPredefinedConstant#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
value$ = 56
AddPredefinedConstant PROC NEAR

; 100  : {

	sub	rsp, 40					; 00000028H

; 101  :     struct asym *sym = CreateVariable( name, value );

	call	CreateVariable

; 102  :     if (sym)

	test	rax, rax
	je	SHORT $LN4@AddPredefi

; 103  :         sym->predefined = TRUE;

	or	BYTE PTR [rax+48], 32			; 00000020H
$LN4@AddPredefi:

; 104  :     return(sym);
; 105  : }

	add	rsp, 40					; 00000028H
	ret	0
AddPredefinedConstant ENDP
_TEXT	ENDS
EXTRN	SetOfssize:NEAR
EXTRN	ModuleInfo:BYTE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
size$ = 8
SetDefaultOfssize PROC NEAR

; 112  :     /* outside any segments? */
; 113  :     if( CurrSeg == NULL ) {

	movzx	edx, BYTE PTR ModuleInfo+405
	cmp	QWORD PTR ModuleInfo+432, 0
	movzx	eax, cl
	cmove	edx, eax
	mov	BYTE PTR ModuleInfo+405, dl

; 114  :         ModuleInfo.defOfssize = size;
; 115  :     }
; 116  :     return( SetOfssize() );
; 117  : }

	jmp	SetOfssize
SetDefaultOfssize ENDP
_TEXT	ENDS
EXTRN	pe_create_PE_header:NEAR
EXTRN	sym_ReservedStack:QWORD
EXTRN	szDgroup:BYTE
EXTRN	AddPredefinedText:NEAR
EXTRN	SimGetSegName:NEAR
EXTRN	Parse_Pass:DWORD
EXTRN	RunLineQueue:NEAR
EXTRN	LstWriteSrcLine:NEAR
EXTRN	ModelAssumeInit:NEAR
EXTRN	ModelSimSegmInit:NEAR
EXTRN	DefineFlatGroup:NEAR
EXTRN	Options:BYTE
_BSS	SEGMENT
sym_Model DQ	01H DUP (?)
sym_DataSize DQ	01H DUP (?)
sym_CodeSize DQ	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$SetModel DD 051901H
	DD	097419H
	DD	08340fH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetModel DD @imagerel(SetModel#)
	DD	@imagerel(SetModel#+536)
	DD	@imagerel($unwind$SetModel#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
SetModel PROC NEAR

; 136  : {

	sub	rsp, 40					; 00000028H

; 137  :     int         value;
; 138  :     const char  *textvalue;
; 139  :     //struct asym     *sym;
; 140  : 
; 141  :     DebugMsg1(("SetModel() enter (model=%u)\n", ModuleInfo.model ));
; 142  :     /* if model is set, it disables OT_SEGMENT of -Zm switch */
; 143  :     if ( ModuleInfo.model == MODEL_FLAT ) {

	mov	ecx, DWORD PTR ModuleInfo+360
	mov	QWORD PTR [rsp+64], rbx
	xor	ebx, ebx
	cmp	ecx, 7
	mov	QWORD PTR [rsp+72], rdi
	lea	edi, QWORD PTR [rbx+2]
	jne	SHORT $LN17@SetModel

; 144  :         ModuleInfo.offsettype = OT_FLAT;
; 145  : #if AMD64_SUPPORT
; 146  :         SetDefaultOfssize( ((ModuleInfo.curr_cpu & P_CPU_MASK) >= P_64 ) ? USE64 : USE32 );

	cmp	QWORD PTR ModuleInfo+432, rbx
	mov	DWORD PTR ModuleInfo+384, 1
	jne	SHORT $LN20@SetModel
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 112				; 00000070H
	setge	al
	inc	al
	mov	BYTE PTR ModuleInfo+405, al
$LN20@SetModel:
	call	SetOfssize

; 147  :         /* v2.03: if cpu is x64 and language is fastcall,
; 148  :          * set fastcall type to win64.
; 149  :          * This is rather hackish, but currently there's no other possibility
; 150  :          * to enable the win64 ABI from the source.
; 151  :          */
; 152  :         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) == P_64 )

	mov	r11d, DWORD PTR ModuleInfo+392
	and	r11d, 240				; 000000f0H
	cmp	r11b, 112				; 00000070H
	jne	SHORT $LN14@SetModel

; 153  :             if ( ModuleInfo.langtype == LANG_FASTCALL ) {

	cmp	DWORD PTR ModuleInfo+364, 7
	jne	SHORT $LN14@SetModel

; 154  :                 if ( Options.output_format != OFORMAT_ELF ) {

	mov	eax, DWORD PTR ModuleInfo+376
	cmp	DWORD PTR Options+156, 3
	cmovne	eax, edi
	mov	DWORD PTR ModuleInfo+376, eax
$LN14@SetModel:

; 155  :                     DebugMsg(("SetModel: FASTCALL type set to WIN64\n"));
; 156  :                     ModuleInfo.fctype = FCT_WIN64;
; 157  :                 }
; 158  :             }
; 159  : #else
; 160  :         SetDefaultOfssize( USE32 );
; 161  : #endif
; 162  :         /* v2.11: define symbol FLAT - after default offset size has been set! */
; 163  :         DefineFlatGroup();

	call	DefineFlatGroup

; 164  :     } else

	mov	ecx, DWORD PTR ModuleInfo+360
	jmp	SHORT $LN13@SetModel
$LN17@SetModel:

; 165  :         ModuleInfo.offsettype = OT_GROUP;

	mov	DWORD PTR ModuleInfo+384, ebx
$LN13@SetModel:

; 166  : 
; 167  :     ModelSimSegmInit( ModuleInfo.model ); /* create segments in first pass */

	call	ModelSimSegmInit

; 168  :     ModelAssumeInit();

	call	ModelAssumeInit

; 169  : 
; 170  :     if ( ModuleInfo.list )

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN12@SetModel

; 171  :         LstWriteSrcLine();

	call	LstWriteSrcLine
$LN12@SetModel:

; 172  : 
; 173  :     RunLineQueue();

	call	RunLineQueue

; 174  : 
; 175  :     if ( Parse_Pass != PASS_1 )

	cmp	DWORD PTR Parse_Pass, ebx
	jne	$LN1@SetModel

; 176  :         return;
; 177  : 
; 178  :     /* Set @CodeSize */
; 179  :     if ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) {

	mov	ecx, DWORD PTR ModuleInfo+360
	mov	eax, 1
	mov	edx, ebx
	shl	al, cl

; 180  :         value = 1;
; 181  :         /* v2.06: SimpleType[] is obsolete */
; 182  :         //SimpleType[ST_PROC].mem_type = MT_FAR;
; 183  :     } else {
; 184  :         value = 0;
; 185  :         // SimpleType[ST_PROC].mem_type = MT_NEAR; /* this is default */
; 186  :     }
; 187  :     sym_CodeSize = AddPredefinedConstant( "@CodeSize", value );

	lea	rcx, OFFSET FLAT:$SG5822
	test	al, 112					; 00000070H
	setne	dl
	call	CreateVariable
	test	rax, rax
	je	SHORT $LN23@SetModel
	or	BYTE PTR [rax+48], 32			; 00000020H
$LN23@SetModel:

; 188  :     AddPredefinedText( "@code", SimGetSegName( SIM_CODE ) );

	xor	ecx, ecx
	mov	QWORD PTR sym_CodeSize, rax
	call	SimGetSegName
	lea	rcx, OFFSET FLAT:$SG5823
	mov	rdx, rax
	call	AddPredefinedText

; 189  : 
; 190  :     /* Set @DataSize */
; 191  :     switch( ModuleInfo.model ) {

	mov	r11d, DWORD PTR ModuleInfo+360
	sub	r11d, 3
	je	SHORT $LN6@SetModel
	sub	r11d, edi
	je	SHORT $LN6@SetModel
	dec	r11d
	jne	SHORT $LN7@SetModel

; 195  :         break;
; 196  :     case MODEL_HUGE:
; 197  :         value = 2;

	mov	ebx, edi

; 198  :         break;

	jmp	SHORT $LN7@SetModel
$LN6@SetModel:

; 192  :     case MODEL_COMPACT:
; 193  :     case MODEL_LARGE:
; 194  :         value = 1;

	mov	ebx, 1
$LN7@SetModel:

; 199  :     default:
; 200  :         value = 0;
; 201  :         break;
; 202  :     }
; 203  :     sym_DataSize = AddPredefinedConstant( "@DataSize", value );

	lea	rcx, OFFSET FLAT:$SG5831
	mov	edx, ebx
	call	CreateVariable
	test	rax, rax
	je	SHORT $LN26@SetModel
	or	BYTE PTR [rax+48], 32			; 00000020H
$LN26@SetModel:

; 204  : 
; 205  :     textvalue = ( ModuleInfo.model == MODEL_FLAT ? "FLAT" : szDgroup );

	cmp	DWORD PTR ModuleInfo+360, 7
	mov	QWORD PTR sym_DataSize, rax
	lea	rax, OFFSET FLAT:$SG5832
	lea	rbx, OFFSET FLAT:szDgroup

; 206  :     AddPredefinedText( "@data", textvalue );

	lea	rcx, OFFSET FLAT:$SG5833
	cmove	rbx, rax
	mov	rdx, rbx
	call	AddPredefinedText

; 207  : 
; 208  :     if ( ModuleInfo.distance == STACK_FAR )

	cmp	DWORD PTR ModuleInfo+356, 1
	lea	rdx, OFFSET FLAT:$SG5835

; 209  :         textvalue = "STACK";
; 210  :     AddPredefinedText( "@stack", textvalue );

	lea	rcx, OFFSET FLAT:$SG5836
	cmovne	rdx, rbx
	call	AddPredefinedText

; 211  : 
; 212  : #if 0
; 213  :     AddPredefinedText( "@fardata", ( ModuleInfo.model == MODEL_FLAT ? "FLAT" : SimGetSegName( SIM_FARDATA ) ) );
; 214  :     AddPredefinedText( "@fardata?", ( ModuleInfo.model == MODEL_FLAT ? "FLAT" : SimGetSegName( SIM_FARDATA_UN ) ) );
; 215  : #endif
; 216  : 
; 217  :     /* Set @Model and @Interface */
; 218  : 
; 219  :     sym_Model     = AddPredefinedConstant( "@Model", ModuleInfo.model );

	mov	edx, DWORD PTR ModuleInfo+360
	lea	rcx, OFFSET FLAT:$SG5837
	call	CreateVariable
	test	rax, rax
	je	SHORT $LN29@SetModel
	or	BYTE PTR [rax+48], 32			; 00000020H
$LN29@SetModel:

; 220  :     sym_Interface = AddPredefinedConstant( "@Interface", ModuleInfo.langtype );

	mov	edx, DWORD PTR ModuleInfo+364
	lea	rcx, OFFSET FLAT:$SG5838
	mov	QWORD PTR sym_Model, rax
	call	CreateVariable
	test	rax, rax
	je	SHORT $LN32@SetModel
	or	BYTE PTR [rax+48], 32			; 00000020H
$LN32@SetModel:

; 221  : 
; 222  : #if AMD64_SUPPORT
; 223  :     if ( ModuleInfo.defOfssize == USE64 && ModuleInfo.fctype == FCT_WIN64 ) {

	cmp	BYTE PTR ModuleInfo+405, dil
	mov	QWORD PTR sym_Interface, rax
	jne	SHORT $LN2@SetModel
	cmp	DWORD PTR ModuleInfo+376, edi
	jne	SHORT $LN2@SetModel

; 224  :         sym_ReservedStack = AddPredefinedConstant( "@ReservedStack", 0 );

	lea	rcx, OFFSET FLAT:$SG5840
	xor	edx, edx
	call	CreateVariable
	test	rax, rax
	je	SHORT $LN35@SetModel
	or	BYTE PTR [rax+48], 32			; 00000020H
$LN35@SetModel:
	mov	QWORD PTR sym_ReservedStack, rax
$LN2@SetModel:

; 225  :     }
; 226  : #endif
; 227  : #if PE_SUPPORT
; 228  :     if ( ModuleInfo.sub_format == SFORMAT_PE )

	cmp	DWORD PTR ModuleInfo+372, edi
	jne	SHORT $LN1@SetModel

; 229  :         pe_create_PE_header();

	call	pe_create_PE_header
$LN1@SetModel:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 230  : #endif
; 231  : 
; 232  : #ifdef DEBUG_OUT
; 233  :     if ( Options.dump_reswords )
; 234  :         DumpResWords();
; 235  : #endif
; 236  : 
; 237  : }

	add	rsp, 40					; 00000028H
	ret	0
SetModel ENDP
_TEXT	ENDS
PUBLIC	ModelDirective
EXTRN	SetModelDefaultSegNames:NEAR
EXTRN	GetLangType:NEAR
EXTRN	EmitWarn:NEAR
EXTRN	EmitErr:NEAR
EXTRN	EmitError:NEAR
xdata	SEGMENT
$unwind$ModelDirective DD 031701H
	DD	0115417H
	DD	0c208H
xdata	ENDS
pdata	SEGMENT
$pdata$ModelDirective DD @imagerel($LN66#)
	DD	@imagerel($LN66#+99)
	DD	@imagerel($unwind$ModelDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$3$ModelDirective DD 061721H
	DD	0b7417H
	DD	0c640dH
	DD	0103408H
	DD	@imagerel($LN66#)
	DD	@imagerel($LN66#+99)
	DD	@imagerel($unwind$ModelDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$ModelDirective DD @imagerel($LN66#+99)
	DD	@imagerel($LN66#+222)
	DD	@imagerel($chain$3$ModelDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$7$ModelDirective DD 082221H
	DD	07f422H
	DD	08e418H
	DD	09d410H
	DD	0ac405H
	DD	@imagerel($LN66#+99)
	DD	@imagerel($LN66#+222)
	DD	@imagerel($chain$3$ModelDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$ModelDirective DD @imagerel($LN66#+222)
	DD	@imagerel($LN66#+542)
	DD	@imagerel($chain$7$ModelDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$8$ModelDirective DD 021H
	DD	@imagerel($LN66#+99)
	DD	@imagerel($LN66#+222)
	DD	@imagerel($chain$3$ModelDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$ModelDirective DD @imagerel($LN66#+542)
	DD	@imagerel($LN66#+573)
	DD	@imagerel($chain$8$ModelDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$10$ModelDirective DD 0e0021H
	DD	07f400H
	DD	08e400H
	DD	09d400H
	DD	0ac400H
	DD	0b7400H
	DD	0c6400H
	DD	0103400H
	DD	@imagerel($LN66#)
	DD	@imagerel($LN66#+99)
	DD	@imagerel($unwind$ModelDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$ModelDirective DD @imagerel($LN66#+573)
	DD	@imagerel($LN66#+804)
	DD	@imagerel($chain$10$ModelDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
model$1$ = 32
ostype$ = 32
distance$ = 32
language$ = 36
i$ = 112
tokenarray$ = 120
ModelDirective PROC NEAR

; 251  : {

$LN66:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H

; 252  :     enum model_type model;
; 253  :     enum lang_type language;
; 254  :     enum dist_type distance;
; 255  :     enum os_type ostype;
; 256  :     int index;
; 257  :     uint_8 init;
; 258  :     uint_8 initv;
; 259  : 
; 260  :     DebugMsg1(("ModelDirective enter\n"));
; 261  :     /* v2.03: it may occur that "code" is defined BEFORE the MODEL
; 262  :      * directive (i.e. DB directives in AT-segments). For FASTPASS,
; 263  :      * this may have caused errors because contents of the ModuleInfo
; 264  :      * structure was saved before the .MODEL directive.
; 265  :      */
; 266  :     //if( Parse_Pass != PASS_1 ) {
; 267  :     if( Parse_Pass != PASS_1 && ModuleInfo.model != MODEL_NONE ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	QWORD PTR [rsp+136], rbp
	mov	rbp, rdx
	je	SHORT $LN28@ModelDirec
	cmp	DWORD PTR ModuleInfo+360, 0
	je	SHORT $LN28@ModelDirec

; 268  :         /* just set the model with SetModel() if pass is != 1.
; 269  :          * This won't set the language ( which can be modified by
; 270  :          * OPTION LANGUAGE directive ), but the language in ModuleInfo
; 271  :          * isn't needed anymore once pass one is done.
; 272  :          */
; 273  :         SetModel();

	call	SetModel

; 274  :         return( NOT_ERROR );

	xor	eax, eax
	mov	rbp, QWORD PTR [rsp+136]

; 359  : }

	add	rsp, 104				; 00000068H
	ret	0
$LN28@ModelDirec:

; 275  :     }
; 276  : 
; 277  :     i++;

	inc	ecx

; 278  :     if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rax, ecx
	mov	DWORD PTR i$[rsp], ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 0
	jne	SHORT $LN27@ModelDirec

; 279  :         return( EmitError( EXPECTED_MEMORY_MODEL ) );

	mov	ecx, 246				; 000000f6H
	call	EmitError
	mov	rbp, QWORD PTR [rsp+136]

; 359  : }

	add	rsp, 104				; 00000068H
	ret	0
$LN27@ModelDirec:
	mov	QWORD PTR [rsp+128], rbx
	mov	QWORD PTR [rsp+96], rsi

; 280  :     }
; 281  :     /* get the model argument */
; 282  :     index = FindToken( tokenarray[i].string_ptr, ModelToken, sizeof( ModelToken )/sizeof( ModelToken[0] ) );

	mov	rsi, QWORD PTR [rax+rdx+8]
	mov	QWORD PTR [rsp+88], rdi
	xor	ebx, ebx
	lea	rdi, OFFSET FLAT:ModelToken
$LL34@ModelDirec:
	mov	rcx, QWORD PTR [rdi]
	mov	rdx, rsi
	call	_stricmp
	test	eax, eax
	je	SHORT $LN35@ModelDirec
	inc	ebx
	add	rdi, 8
	cmp	ebx, 7
	jl	SHORT $LL34@ModelDirec
$LN26@ModelDirec:

; 290  :     } else {
; 291  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbp+8]
	call	EmitErr
	jmp	$LN61@ModelDirec

; 280  :     }
; 281  :     /* get the model argument */
; 282  :     index = FindToken( tokenarray[i].string_ptr, ModelToken, sizeof( ModelToken )/sizeof( ModelToken[0] ) );

$LN35@ModelDirec:

; 283  :     if( index >= 0 ) {

	test	ebx, ebx
	js	SHORT $LN26@ModelDirec

; 284  :         if( ModuleInfo.model != MODEL_NONE ) {

	cmp	DWORD PTR ModuleInfo+360, 0
	je	SHORT $LN25@ModelDirec

; 285  :             //if ( Parse_Pass == PASS_1 ) /* not needed, this code runs in pass one only */
; 286  :             EmitWarn( 2, MODEL_DECLARED_ALREADY );

	mov	edx, 95					; 0000005fH
	lea	ecx, QWORD PTR [rdx-93]
	call	EmitWarn
$LN25@ModelDirec:

; 287  :         }
; 288  :         model = index + 1; /* model is one-base ( 0 is MODEL_NONE ) */
; 289  :         i++;

	mov	ecx, DWORD PTR i$[rsp]

; 292  :     }
; 293  : 
; 294  :     /* get the optional arguments: language, stack distance, os */
; 295  :     init = 0;
; 296  :     while ( i < ( Token_Count - 1 ) && tokenarray[i].token == T_COMMA ) {

	mov	edx, DWORD PTR ModuleInfo+496
	mov	QWORD PTR [rsp+80], r12
	lea	r8d, DWORD PTR [rbx+1]
	inc	ecx
	mov	QWORD PTR [rsp+72], r13
	lea	eax, DWORD PTR [rdx-1]
	mov	QWORD PTR [rsp+64], r14
	xor	r12b, r12b
	cmp	ecx, eax
	mov	QWORD PTR [rsp+56], r15
	mov	DWORD PTR model$1$[rsp], r8d
	mov	DWORD PTR i$[rsp], ecx

; 307  :                 case INIT_STACK:
; 308  :                     if ( model == MODEL_FLAT ) {

	movsxd	r15, r8d
	jge	$LN55@ModelDirec
	mov	r13d, DWORD PTR distance$[rsp]
	mov	r14d, DWORD PTR ostype$[rsp]
	npad	4
$LL23@ModelDirec:
	movsxd	rax, ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+rbp], 44			; 0000002cH
	jne	$LN58@ModelDirec
	inc	ecx
	movsxd	rax, ecx
	mov	DWORD PTR i$[rsp], ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+rbp], 44			; 0000002cH
	je	$LN21@ModelDirec
	lea	r8, QWORD PTR language$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rbp
	call	GetLangType
	test	eax, eax
	jne	SHORT $LN20@ModelDirec
	mov	ecx, DWORD PTR i$[rsp]
	mov	al, 1
	jmp	SHORT $LN19@ModelDirec
$LN20@ModelDirec:

; 297  :         i++;
; 298  :         if ( tokenarray[i].token != T_COMMA ) {
; 299  :             if ( GetLangType( &i, tokenarray, &language ) == NOT_ERROR ) {
; 300  :                 initv = INIT_LANG;
; 301  :             } else {
; 302  :                 index = FindToken( tokenarray[i].string_ptr, ModelAttr, sizeof( ModelAttr )/sizeof( ModelAttr[0] ) );

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rdi, OFFSET FLAT:ModelAttr
	shl	rax, 5
	xor	ebx, ebx
	mov	rsi, QWORD PTR [rax+rbp+8]
	npad	3
$LL40@ModelDirec:
	mov	rcx, QWORD PTR [rdi]
	mov	rdx, rsi
	call	_stricmp
	test	eax, eax
	je	SHORT $LN47@ModelDirec
	inc	rbx
	add	rdi, 8
	cmp	rbx, 4
	jl	SHORT $LL40@ModelDirec
$LN56@ModelDirec:

; 321  :                 i--;

	mov	ecx, DWORD PTR i$[rsp]
	mov	r8d, DWORD PTR model$1$[rsp]
	jmp	$LN22@ModelDirec
$LN47@ModelDirec:

; 303  :                 if ( index < 0 )

	test	rbx, rbx
	js	SHORT $LN56@ModelDirec

; 304  :                     break;
; 305  :                 initv = ModelAttrValue[index].init;

	lea	r8, OFFSET FLAT:ModelAttrValue
	movzx	eax, BYTE PTR [r8+rbx*2+1]

; 306  :                 switch ( initv ) {

	cmp	al, 2
	je	SHORT $LN15@ModelDirec
	cmp	al, 4
	jne	SHORT $LN16@ModelDirec

; 312  :                     break;
; 313  :                 case INIT_OS:
; 314  :                     ostype = ModelAttrValue[index].value;

	movzx	r14d, BYTE PTR [r8+rbx*2]

; 315  :                     break;

	jmp	SHORT $LN16@ModelDirec
$LN15@ModelDirec:

; 307  :                 case INIT_STACK:
; 308  :                     if ( model == MODEL_FLAT ) {

	cmp	r15, 7
	je	SHORT $LN49@ModelDirec

; 310  :                     }
; 311  :                     distance = ModelAttrValue[index].value;

	movzx	r13d, BYTE PTR [r8+rbx*2]
$LN16@ModelDirec:

; 316  :                 }
; 317  :                 i++;

	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx
	mov	DWORD PTR i$[rsp], ecx
$LN19@ModelDirec:

; 318  :             }
; 319  :             /* attribute set already? */
; 320  :             if ( initv & init ) {

	test	al, r12b
	jne	SHORT $LN50@ModelDirec

; 322  :                 break;
; 323  :             }
; 324  :             init |= initv;

	mov	edx, DWORD PTR ModuleInfo+496
	or	r12b, al
$LN21@ModelDirec:
	lea	eax, DWORD PTR [rdx-1]
	cmp	ecx, eax
	jl	$LL23@ModelDirec

; 321  :                 i--;

	mov	r8d, DWORD PTR model$1$[rsp]
	jmp	SHORT $LN22@ModelDirec
$LN49@ModelDirec:

; 309  :                         return( EmitError( INVALID_MODEL_PARAM_FOR_FLAT ) );

	mov	ecx, 200				; 000000c8H
	call	EmitError
$LN65@ModelDirec:
	mov	r14, QWORD PTR [rsp+64]
	mov	r13, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+80]
	mov	r15, QWORD PTR [rsp+56]
$LN61@ModelDirec:
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+128]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+136]

; 359  : }

	add	rsp, 104				; 00000068H
	ret	0
$LN50@ModelDirec:

; 321  :                 i--;

	mov	r8d, DWORD PTR model$1$[rsp]
	dec	ecx
	mov	DWORD PTR i$[rsp], ecx
	jmp	SHORT $LN22@ModelDirec
$LN55@ModelDirec:
	mov	r13d, DWORD PTR distance$[rsp]
	mov	r14d, DWORD PTR ostype$[rsp]
	jmp	SHORT $LN22@ModelDirec
$LN58@ModelDirec:
	mov	r8d, DWORD PTR model$1$[rsp]
$LN22@ModelDirec:

; 325  :         }
; 326  :     }
; 327  :     /* everything parsed successfully? */
; 328  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, ecx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbp], 0
	je	SHORT $LN11@ModelDirec

; 329  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rbp+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN65@ModelDirec
$LN11@ModelDirec:

; 330  :     }
; 331  : 
; 332  :     if ( model == MODEL_FLAT ) {

	cmp	r8d, 7
	jne	SHORT $LN6@ModelDirec

; 333  :         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK) < P_386 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jge	SHORT $LN9@ModelDirec

; 334  :             return( EmitError( INSTRUCTION_OR_REGISTER_NOT_ACCEPTED_IN_CURRENT_CPU_MODE ) );

	lea	ecx, QWORD PTR [r8+23]
	call	EmitError
	jmp	$LN65@ModelDirec
$LN9@ModelDirec:

; 335  :         }
; 336  : #if AMD64_SUPPORT
; 337  :         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_64 ) /* cpu 64-bit? */

	cmp	eax, 112				; 00000070H
	jl	SHORT $LN6@ModelDirec

; 338  :             switch ( Options.output_format ) {

	mov	ecx, DWORD PTR Options+156
	sub	ecx, 2
	je	SHORT $LN5@ModelDirec
	dec	ecx
	jne	SHORT $LN6@ModelDirec

; 340  :             case OFORMAT_ELF:  ModuleInfo.fmtopt = &elf64_fmtopt;  break;

	lea	rax, OFFSET FLAT:elf64_fmtopt
	mov	QWORD PTR ModuleInfo+344, rax
	jmp	SHORT $LN6@ModelDirec
$LN5@ModelDirec:

; 339  :             case OFORMAT_COFF: ModuleInfo.fmtopt = &coff64_fmtopt; break;

	lea	rax, OFFSET FLAT:coff64_fmtopt
	mov	QWORD PTR ModuleInfo+344, rax
$LN6@ModelDirec:

; 341  :             };
; 342  : #endif
; 343  :         /* v2.11: define FLAT symbol is to early here, because defOfssize isn't set yet */
; 344  :         //DefineFlatGroup();
; 345  :     }
; 346  : 
; 347  :     ModuleInfo.model = model;
; 348  :     if ( init & INIT_LANG )

	mov	eax, DWORD PTR ModuleInfo+364
	test	r12b, 1
	mov	DWORD PTR ModuleInfo+360, r8d
	cmovne	eax, DWORD PTR language$[rsp]

; 349  :         ModuleInfo.langtype = language;
; 350  :     if ( init & INIT_STACK )

	test	r12b, 2
	mov	DWORD PTR ModuleInfo+364, eax
	mov	eax, DWORD PTR ModuleInfo+356
	cmovne	eax, r13d

; 351  :         ModuleInfo.distance = distance;
; 352  :     if ( init & INIT_OS )

	test	r12b, 4
	mov	DWORD PTR ModuleInfo+356, eax
	mov	eax, DWORD PTR ModuleInfo+368
	cmovne	eax, r14d
	mov	DWORD PTR ModuleInfo+368, eax

; 353  :         ModuleInfo.ostype = ostype;
; 354  : 
; 355  :     SetModelDefaultSegNames();

	call	SetModelDefaultSegNames

; 356  :     SetModel();

	call	SetModel

; 357  : 
; 358  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN65@ModelDirec
ModelDirective ENDP
_TEXT	ENDS
PUBLIC	SetCPU
EXTRN	__ImageBase:BYTE
xdata	SEGMENT
$unwind$SetCPU DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetCPU DD @imagerel($LN42#)
	DD	@imagerel($LN42#+573)
	DD	@imagerel($unwind$SetCPU#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
newcpu$ = 48
SetCPU	PROC NEAR

; 371  : {

$LN42:
	sub	rsp, 40					; 00000028H

; 372  :     int temp;
; 373  : 
; 374  :     DebugMsg1(("SetCPU(%X) enter\n", newcpu ));
; 375  :     if ( newcpu == P_86 || ( newcpu & P_CPU_MASK ) ) {

	test	ecx, ecx
	je	SHORT $LN27@SetCPU
	test	cl, -16
	je	SHORT $LN39@SetCPU
$LN27@SetCPU:

; 376  :         /* reset CPU and EXT bits */
; 377  :         ModuleInfo.curr_cpu &= ~( P_CPU_MASK | P_EXT_MASK | P_PM );

	mov	edx, DWORD PTR ModuleInfo+392

; 378  : 
; 379  :         /* set CPU bits */
; 380  :         ModuleInfo.curr_cpu |= newcpu & ( P_CPU_MASK | P_PM );

	mov	eax, ecx
	and	eax, 248				; 000000f8H
	and	edx, -65529				; ffffffffffff0007H
	or	edx, eax

; 381  : 
; 382  :         /* set default FPU bits if nothing is given and .NO87 not active */
; 383  :         if ( (ModuleInfo.curr_cpu & P_FPU_MASK) != P_NO87 &&
; 384  :             ( newcpu & P_FPU_MASK ) == 0 ) {

	mov	eax, edx
	mov	DWORD PTR ModuleInfo+392, edx
	and	al, 7
	cmp	al, 1
	je	SHORT $LN22@SetCPU
	test	cl, 7
	jne	SHORT $LN22@SetCPU

; 385  :             ModuleInfo.curr_cpu &= ~P_FPU_MASK;

	and	edx, -8

; 386  :             if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < P_286 )

	mov	eax, edx
	and	eax, 240				; 000000f0H
	cmp	eax, 32					; 00000020H
	jge	SHORT $LN25@SetCPU

; 387  :                 ModuleInfo.curr_cpu |= P_87;

	or	edx, 2
	mov	DWORD PTR ModuleInfo+392, edx
	jmp	SHORT $LN22@SetCPU
$LN25@SetCPU:

; 388  :             else if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < P_386 )

	cmp	eax, 48					; 00000030H
	jge	SHORT $LN23@SetCPU

; 389  :                 ModuleInfo.curr_cpu |= P_287;

	or	edx, 3
	mov	DWORD PTR ModuleInfo+392, edx

; 390  :             else

	jmp	SHORT $LN22@SetCPU
$LN23@SetCPU:

; 391  :                 ModuleInfo.curr_cpu |= P_387;

	or	edx, 4
	mov	DWORD PTR ModuleInfo+392, edx
	jmp	SHORT $LN22@SetCPU
$LN39@SetCPU:
	mov	edx, DWORD PTR ModuleInfo+392
$LN22@SetCPU:

; 392  :         }
; 393  : 
; 394  :     }
; 395  :     if( newcpu & P_FPU_MASK ) {

	mov	eax, ecx
	and	eax, 7
	je	SHORT $LN21@SetCPU

; 396  :         ModuleInfo.curr_cpu &= ~P_FPU_MASK;

	and	edx, -8

; 397  :         ModuleInfo.curr_cpu |= (newcpu & P_FPU_MASK);

	or	edx, eax
	mov	DWORD PTR ModuleInfo+392, edx
$LN21@SetCPU:

; 398  :     }
; 399  : #if AMD64_SUPPORT
; 400  :     /* enable MMX, K3D, SSEx for 64bit cpus */
; 401  :     if ( ( newcpu & P_CPU_MASK ) == P_64 )

	mov	eax, ecx
	and	eax, 240				; 000000f0H
	cmp	al, 112					; 00000070H
	jne	SHORT $LN20@SetCPU

; 402  :         ModuleInfo.curr_cpu |= P_EXT_ALL;

	or	edx, 65280				; 0000ff00H
	mov	DWORD PTR ModuleInfo+392, edx
$LN20@SetCPU:

; 403  : #endif
; 404  :     if( newcpu & P_EXT_MASK ) {

	and	ecx, 65280				; 0000ff00H
	je	SHORT $LN19@SetCPU

; 405  :         ModuleInfo.curr_cpu &= ~P_EXT_MASK;

	mov	BYTE PTR ModuleInfo+393, 0

; 406  :         ModuleInfo.curr_cpu |= (newcpu & P_EXT_MASK);

	mov	edx, DWORD PTR ModuleInfo+392
	or	edx, ecx
	mov	DWORD PTR ModuleInfo+392, edx
$LN19@SetCPU:

; 407  :     }
; 408  : 
; 409  :     /* set the Masm compatible @Cpu value */
; 410  : 
; 411  :     temp = ModuleInfo.curr_cpu & P_CPU_MASK;

	mov	r8d, edx
	and	r8d, 240				; 000000f0H

; 412  :     switch ( temp ) {

	lea	eax, DWORD PTR [r8-16]
	cmp	eax, 96					; 00000060H
	ja	SHORT $LN10@SetCPU
	lea	r9, OFFSET FLAT:__ImageBase
	cdqe
	movzx	eax, BYTE PTR $LN37@SetCPU[r9+rax]
	mov	ecx, DWORD PTR $LN38@SetCPU[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN16@SetCPU:

; 413  :     case P_186: ModuleInfo.cpu = M_8086 | M_186; break;

	mov	cx, 3
	jmp	SHORT $LN40@SetCPU
$LN15@SetCPU:

; 414  :     case P_286: ModuleInfo.cpu = M_8086 | M_186 | M_286; break;

	mov	cx, 7
	jmp	SHORT $LN40@SetCPU
$LN14@SetCPU:

; 415  :     case P_386: ModuleInfo.cpu = M_8086 | M_186 | M_286 | M_386; break;

	mov	cx, 15
	jmp	SHORT $LN40@SetCPU
$LN13@SetCPU:

; 416  :     case P_486: ModuleInfo.cpu = M_8086 | M_186 | M_286 | M_386 | M_486; break;

	mov	cx, 31
	jmp	SHORT $LN40@SetCPU
$LN12@SetCPU:

; 417  :     case P_586: ModuleInfo.cpu = M_8086 | M_186 | M_286 | M_386 | M_486 | M_586; break;

	mov	cx, 63					; 0000003fH
	jmp	SHORT $LN40@SetCPU
$LN11@SetCPU:

; 418  :     /* Masm's .686 directive doesn't set the Pentium flag! A bug? */
; 419  :     //case P_686: ModuleInfo.cpu = M_8086 | M_186 | M_286 | M_386 | M_486 | M_586 | M_686; break;
; 420  : #if AMD64_SUPPORT
; 421  :     case P_64:
; 422  : #endif
; 423  :     case P_686: ModuleInfo.cpu = M_8086 | M_186 | M_286 | M_386 | M_486 | M_686; break;

	mov	cx, 95					; 0000005fH
	jmp	SHORT $LN40@SetCPU
$LN10@SetCPU:

; 424  :     default: ModuleInfo.cpu = M_8086; break;

	mov	cx, 1
$LN40@SetCPU:

; 425  :     }
; 426  :     if ( ModuleInfo.curr_cpu & P_PM )

	test	dl, 8
	mov	WORD PTR ModuleInfo+388, cx
	je	SHORT $LN9@SetCPU

; 427  :         ModuleInfo.cpu = ModuleInfo.cpu | M_PROT;

	or	cx, 128					; 00000080H
	mov	WORD PTR ModuleInfo+388, cx
$LN9@SetCPU:

; 428  : 
; 429  :     temp = ModuleInfo.curr_cpu & P_FPU_MASK;

	and	edx, 7

; 430  :     switch (temp) {

	sub	edx, 2
	je	SHORT $LN6@SetCPU
	dec	edx
	je	SHORT $LN5@SetCPU
	dec	edx
	jne	SHORT $LN7@SetCPU

; 433  :     case P_387: ModuleInfo.cpu = ModuleInfo.cpu | M_8087 | M_287 | M_387; break;

	or	cx, 3328				; 00000d00H
	jmp	SHORT $LN41@SetCPU
$LN5@SetCPU:

; 432  :     case P_287: ModuleInfo.cpu = ModuleInfo.cpu | M_8087 | M_287; break;

	or	cx, 1280				; 00000500H
	jmp	SHORT $LN41@SetCPU
$LN6@SetCPU:

; 431  :     case P_87:  ModuleInfo.cpu = ModuleInfo.cpu | M_8087;     break;

	or	cx, 256					; 00000100H
$LN41@SetCPU:
	mov	WORD PTR ModuleInfo+388, cx
$LN7@SetCPU:

; 434  :     }
; 435  : 
; 436  :     DebugMsg1(("SetCPU: ModuleInfo.curr_cpu=%X, @Cpu=%X\n", ModuleInfo.curr_cpu, ModuleInfo.cpu ));
; 437  : 
; 438  :     //MakeCPUConstant( newcpu );
; 439  :     if ( ModuleInfo.model == MODEL_NONE )

	cmp	DWORD PTR ModuleInfo+360, 0
	jne	SHORT $LN35@SetCPU

; 440  : #if AMD64_SUPPORT
; 441  :         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK) >= P_64 ) {

	cmp	r8d, 112				; 00000070H
	jl	SHORT $LN2@SetCPU

; 442  :             SetDefaultOfssize( USE64 );

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	QWORD PTR ModuleInfo+432, 0
	mov	ecx, 2
	cmove	eax, ecx
	mov	BYTE PTR ModuleInfo+405, al

; 443  :         } else

	jmp	SHORT $LN34@SetCPU
$LN2@SetCPU:

; 444  : #endif
; 445  :             SetDefaultOfssize( ((ModuleInfo.curr_cpu & P_CPU_MASK) >= P_386) ? USE32 : USE16 );

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN34@SetCPU
	cmp	r8d, 48					; 00000030H
	setge	BYTE PTR ModuleInfo+405
$LN34@SetCPU:
	call	SetOfssize
	movzx	ecx, WORD PTR ModuleInfo+388
$LN35@SetCPU:

; 446  : 
; 447  :     /* Set @Cpu */
; 448  :     /* differs from Codeinfo cpu setting */
; 449  : 
; 450  :     sym_Cpu = CreateVariable( "@Cpu", ModuleInfo.cpu );

	movsx	edx, cx
	lea	rcx, OFFSET FLAT:$SG5924
	call	CreateVariable
	mov	QWORD PTR sym_Cpu, rax

; 451  : 
; 452  :     return( NOT_ERROR );

	xor	eax, eax

; 453  : }

	add	rsp, 40					; 00000028H
	ret	0
	npad	2
$LN38@SetCPU:
	DD	$LN16@SetCPU
	DD	$LN15@SetCPU
	DD	$LN14@SetCPU
	DD	$LN13@SetCPU
	DD	$LN12@SetCPU
	DD	$LN11@SetCPU
	DD	$LN10@SetCPU
$LN37@SetCPU:
	DB	0
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
SetCPU	ENDP
_TEXT	ENDS
PUBLIC	CpuDirective
EXTRN	SpecialTable:BYTE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
i$ = 8
tokenarray$ = 16
CpuDirective PROC NEAR

; 464  : {

	mov	r9, rdx

; 465  :     enum cpu_info newcpu;
; 466  : 
; 467  :     //newcpu = comp_opt( tokenarray[i].tokval );
; 468  :     newcpu = GetSflagsSp( tokenarray[i].tokval );

	movsxd	rax, ecx

; 469  : 
; 470  : #if DOT_XMMARG
; 471  :     .if ( tokenarray[i].tokval == T_DOT_XMM && tokenarray[i+1].token != T_FINAL ) {
; 472  :         struct expr opndx;
; 473  :         i++;
; 474  :         if ( EvalOperand( &i, Token_Count, &opndx, 0 ) == ERROR )
; 475  :             return( ERROR );
; 476  :         if ( opndx.kind != EXPR_CONST || opndx.value < 1 || opndx.value > 4 ) {
; 477  :             return( EmitConstError( &opndx ) );
; 478  :         }
; 479  :         newcpy &= ~P_SSEALL; 
; 480  :         switch ( opndx.value ) {
; 481  :         case 4: newcpy |= P_SSE4;
; 482  :         case 3: newcpy |= P_SSE3|P_SSSE3;
; 483  :         case 2: newcpy |= P_SSE2;
; 484  :         case 1: newcpy |= P_SSE1; break;
; 485  :         }
; 486  :     } else
; 487  : #endif
; 488  :     i++;

	inc	ecx
	shl	rax, 5
	mov	eax, DWORD PTR [rax+rdx+16]

; 489  : 
; 490  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, ecx
	lea	r8, QWORD PTR [rax+rax*2]
	lea	rax, OFFSET FLAT:SpecialTable+4
	shl	rdx, 5
	cmp	BYTE PTR [rdx+r9], 0
	mov	eax, DWORD PTR [rax+r8*4]
	je	SHORT $LN1@CpuDirecti

; 491  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+r9+24]
	mov	ecx, 209				; 000000d1H

; 495  : }

	jmp	EmitErr
$LN1@CpuDirecti:

; 492  :     }
; 493  : 
; 494  :     return( SetCPU( newcpu ) );

	mov	ecx, eax

; 495  : }

	jmp	SetCPU
CpuDirective ENDP
_TEXT	ENDS
END
