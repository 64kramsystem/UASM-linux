; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	szDgroup
_DATA	SEGMENT
COMM	SegAssumeTable:BYTE:060H
COMM	StdAssumeTable:BYTE:0100H
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG11141 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG11067 DB	'%r %r:%r,%r:%r,%r:%r,%r:%r,%r:%s,%r:%s', 00H
	ORG $+1
$SG11075 DB	'%r %r:%s,%r:%s,%r:%s', 00H
	ORG $+3
$SG11076 DB	'%r %r:%s,%r:%s', 00H
_DATA	ENDS
CONST	SEGMENT
szError	DB	'ERROR', 00H
	ORG $+2
szNothing DB	'NOTHING', 00H
szDgroup DB	'DGROUP', 00H
CONST	ENDS
PUBLIC	AssumeInit
PUBLIC	search_assume
PUBLIC	GetAssume
PUBLIC	GetOverrideAssume
PUBLIC	GetStdAssume
PUBLIC	GetStdAssumeEx
PUBLIC	ModelAssumeInit
PUBLIC	SetSegAssumeTable
PUBLIC	GetSegAssumeTable
PUBLIC	SetStdAssumeTable
PUBLIC	GetStdAssumeTable
PUBLIC	AssumeSaveState
PUBLIC	AssumeDirective
EXTRN	_stricmp:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	OperandSize:PROC
EXTRN	GetGroup:PROC
EXTRN	SimGetSegName:PROC
EXTRN	CreateTypeSymbol:PROC
EXTRN	GetQualifiedType:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	EvalOperand:PROC
EXTRN	StoreLine:PROC
EXTRN	memset:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SpecialTable:BYTE
EXTRN	UseSavedState:BYTE
EXTRN	__ImageBase:BYTE
_BSS	SEGMENT
	ALIGN	8

stdsym	DQ	010H DUP (?)
saved_SegAssumeTable DB 060H DUP (?)
saved_StdAssumeTable DB 0100H DUP (?)
saved_StdTypeInfo DB 0180H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$search_assume DD imagerel $LN33
	DD	imagerel $LN33+271
	DD	imagerel $unwind$search_assume
$pdata$GetAssume DD imagerel $LN43
	DD	imagerel $LN43+269
	DD	imagerel $unwind$GetAssume
$pdata$ModelAssumeInit DD imagerel $LN16
	DD	imagerel $LN16+181
	DD	imagerel $unwind$ModelAssumeInit
$pdata$0$ModelAssumeInit DD imagerel $LN16+181
	DD	imagerel $LN16+285
	DD	imagerel $chain$0$ModelAssumeInit
$pdata$1$ModelAssumeInit DD imagerel $LN16+285
	DD	imagerel $LN16+290
	DD	imagerel $chain$1$ModelAssumeInit
$pdata$AssumeDirective DD imagerel $LN114
	DD	imagerel $LN114+1476
	DD	imagerel $unwind$AssumeDirective
pdata	ENDS
CONST	SEGMENT
	ORG $+1
searchtab DD	03H
	DD	02H
	DD	00H
	DD	04H
	DD	05H
	DD	01H
CONST	ENDS
xdata	SEGMENT
$unwind$search_assume DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$GetAssume DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
$unwind$ModelAssumeInit DD 010401H
	DD	0e204H
$chain$0$ModelAssumeInit DD 020521H
	DD	0e3405H
	DD	imagerel $LN16
	DD	imagerel $LN16+181
	DD	imagerel $unwind$ModelAssumeInit
$chain$1$ModelAssumeInit DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+181
	DD	imagerel $unwind$ModelAssumeInit
$unwind$AssumeDirective DD 0d2401H
	DD	0217424H
	DD	0206424H
	DD	01f3424H
	DD	0180124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
ti$ = 48
opnd$1 = 80
i$ = 240
tokenarray$ = 248
AssumeDirective PROC

; 287  : {

$LN114:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-55]
	sub	rsp, 192				; 000000c0H

; 288  :     int             reg;
; 289  :     int             j;
; 290  :     int             size;
; 291  :     uint_32         flags;
; 292  :     struct assume_info *info;
; 293  :     bool            segtable;
; 294  :     struct qualified_type ti;
; 295  : 
; 296  :     DebugMsg1(( "AssumeDirective enter, pass=%u\n", Parse_Pass+1 ));
; 297  : 
; 298  :     for( i++; i < Token_Count; i++ ) {

	lea	r8d, DWORD PTR [rcx+1]
	mov	r12, rdx
	cmp	r8d, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rbp-137], r8d
	jge	$LN51@AssumeDire
	lea	rdi, OFFSET FLAT:__ImageBase
	xor	r13d, r13d
$LN112@AssumeDire:

; 299  : 
; 300  :         if( ( tokenarray[i].token == T_ID )
; 301  :             && (0 == _stricmp( tokenarray[i].string_ptr, szNothing )) ) {

	movsxd	rax, r8d
	lea	r9, OFFSET FLAT:StdAssumeTable
	shl	rax, 5
	lea	rdx, OFFSET FLAT:SegAssumeTable
	cmp	BYTE PTR [rax+r12], 8
	jne	SHORT $LN7@AssumeDire
	mov	rcx, QWORD PTR [rax+r12+8]
	lea	rdx, OFFSET FLAT:szNothing
	call	_stricmp
	test	eax, eax
	je	$LN81@AssumeDire
	mov	r8d, DWORD PTR i$[rbp-137]
	lea	rdx, OFFSET FLAT:SegAssumeTable
	lea	r9, OFFSET FLAT:StdAssumeTable
$LN7@AssumeDire:

; 305  :         }
; 306  : 
; 307  :         /*---- get the info ptr for the register ----*/
; 308  : 
; 309  :         info = NULL;
; 310  :         if ( tokenarray[i].token == T_REG ) {

	movsxd	rax, r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 2
	jne	$LN82@AssumeDire

; 311  :             reg = tokenarray[i].tokval;

	movsxd	r14, DWORD PTR [rax+r12+16]

; 312  :             j = GetRegNo( reg );

	lea	rcx, QWORD PTR [r14+r14*2]
	movzx	eax, BYTE PTR SpecialTable[rdi+rcx*4+10]

; 313  :             flags = GetValueSp( reg );

	mov	edi, DWORD PTR SpecialTable[rdi+rcx*4]

; 314  :             if ( flags & OP_SR ) {

	test	edi, 24576				; 00006000H
	je	SHORT $LN9@AssumeDire

; 315  :                 info = &SegAssumeTable[j];

	movsxd	r15, eax

; 316  :                 segtable = TRUE;

	mov	sil, 1
	mov	rbx, r15
	shl	rbx, 4
	add	rbx, rdx
	jmp	SHORT $LN11@AssumeDire
$LN9@AssumeDire:

; 317  :             } else if ( flags & OP_R ) {

	test	dil, 15
	je	$LN82@AssumeDire

; 318  :                 info = &StdAssumeTable[j];

	mov	rbx, rax
	mov	r15, rax
	shl	rbx, 4
	add	rbx, r9

; 319  :                 segtable = FALSE;

	xor	sil, sil
$LN11@AssumeDire:

; 320  :             }
; 321  :         }
; 322  :         if ( info == NULL ) {

	test	rbx, rbx
	je	$LN82@AssumeDire

; 324  :         }
; 325  : 
; 326  :         if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < GetCpuSp( reg ) ) {

	lea	rax, OFFSET FLAT:__ImageBase
	movzx	ecx, WORD PTR SpecialTable[rax+rcx*4+8]
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, ecx
	jl	$LN83@AssumeDire

; 328  :         }
; 329  : 
; 330  :         i++; /* go past register */

	inc	r8d

; 331  : 
; 332  :         if( tokenarray[i].token != T_COLON ) {

	movsxd	rax, r8d
	shl	rax, 5
	mov	DWORD PTR i$[rbp-137], r8d
	cmp	BYTE PTR [rax+r12], 58			; 0000003aH
	jne	$LN84@AssumeDire

; 334  :         }
; 335  :         i++;

	inc	r8d

; 336  : 
; 337  :         if( tokenarray[i].token == T_FINAL ) {

	movsxd	rax, r8d
	shl	rax, 5
	mov	DWORD PTR i$[rbp-137], r8d
	cmp	BYTE PTR [rax+r12], r13b
	je	$LN85@AssumeDire

; 339  :         }
; 340  : 
; 341  :         /* check for ERROR and NOTHING */
; 342  : 
; 343  :         if( 0 == _stricmp( tokenarray[i].string_ptr, szError )) {

	mov	rcx, QWORD PTR [rax+r12+8]
	lea	rdx, OFFSET FLAT:szError
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN16@AssumeDire

; 344  :             if ( segtable ) {

	test	sil, sil
	je	SHORT $LN18@AssumeDire

; 345  :                 info->is_flat = FALSE;
; 346  :                 info->error = TRUE;

	mov	WORD PTR [rbx+8], 1

; 347  :             } else

	jmp	SHORT $LN23@AssumeDire
$LN18@AssumeDire:

; 348  :                 info->error |= (( reg >= T_AH && reg <= T_BH ) ? RH_ERROR : ( flags & OP_R ));

	lea	eax, DWORD PTR [r14-5]
	cmp	eax, 3
	ja	SHORT $LN53@AssumeDire
	mov	edi, 16
	or	BYTE PTR [rbx+8], dil

; 349  :             info->symbol = NULL;
; 350  :             i++;

	jmp	SHORT $LN23@AssumeDire
$LN53@AssumeDire:

; 348  :                 info->error |= (( reg >= T_AH && reg <= T_BH ) ? RH_ERROR : ( flags & OP_R ));

	and	edi, 15
	or	BYTE PTR [rbx+8], dil

; 349  :             info->symbol = NULL;
; 350  :             i++;

	jmp	SHORT $LN23@AssumeDire
$LN16@AssumeDire:

; 351  :         } else if( 0 == _stricmp( tokenarray[i].string_ptr, szNothing )) {

	movsxd	rcx, DWORD PTR i$[rbp-137]
	lea	rdx, OFFSET FLAT:szNothing
	shl	rcx, 5
	mov	rcx, QWORD PTR [rcx+r12+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN20@AssumeDire

; 352  :             if ( segtable ) {

	test	sil, sil
	je	SHORT $LN22@AssumeDire

; 353  :                 info->is_flat = FALSE;
; 354  :                 info->error = FALSE;

	mov	WORD PTR [rbx+8], r13w

; 355  :             } else

	jmp	SHORT $LN23@AssumeDire
$LN22@AssumeDire:

; 356  :                 info->error &= ~(( reg >= T_AH && reg <= T_BH ) ? RH_ERROR : ( flags & OP_R ));

	lea	eax, DWORD PTR [r14-5]
	cmp	eax, 3
	ja	SHORT $LN55@AssumeDire
	mov	edi, 16
	jmp	SHORT $LN56@AssumeDire
$LN55@AssumeDire:
	and	edi, 15
$LN56@AssumeDire:
	not	dil
	and	BYTE PTR [rbx+8], dil
$LN23@AssumeDire:

; 357  :             info->symbol = NULL;
; 358  :             i++;

	mov	r8d, DWORD PTR i$[rbp-137]
	lea	rdi, OFFSET FLAT:__ImageBase
	inc	r8d
	mov	QWORD PTR [rbx], r13
	mov	DWORD PTR i$[rbp-137], r8d
	jmp	$LN25@AssumeDire
$LN20@AssumeDire:

; 359  :         } else if ( segtable == FALSE ) {
; 360  : 
; 361  :             /* v2.05: changed to use new GetQualifiedType() function */
; 362  :             ti.size = 0;
; 363  :             ti.is_ptr = 0;
; 364  :             ti.is_far = FALSE;
; 365  :             ti.mem_type = MT_EMPTY;
; 366  :             ti.ptr_memtype = MT_EMPTY;
; 367  :             ti.symtype = NULL;
; 368  :             ti.Ofssize = ModuleInfo.Ofssize;
; 369  :             if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	rcx, QWORD PTR i$[rbp-137]
	mov	rdx, r12
	test	sil, sil
	jne	$LN24@AssumeDire
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	r8, QWORD PTR ti$[rbp-137]
	mov	BYTE PTR ti$[rbp-115], al
	mov	DWORD PTR ti$[rbp-137], r13d
	mov	WORD PTR ti$[rbp-117], r13w
	mov	DWORD PTR ti$[rbp-121], 192		; 000000c0H
	mov	DWORD PTR ti$[rbp-113], 192		; 000000c0H
	mov	QWORD PTR ti$[rbp-129], r13
	call	GetQualifiedType
	cmp	eax, -1
	je	$LN86@AssumeDire

; 371  : 
; 372  :             /* v2.04: check size of argument! */
; 373  :             size = OperandSize( flags, NULL );

	xor	edx, edx
	mov	ecx, edi
	call	OperandSize

; 374  :             if ( ( ti.is_ptr == 0 && size != ti.size ) ||

	mov	edx, DWORD PTR ti$[rbp-137]
	mov	ecx, eax
	movzx	eax, BYTE PTR ti$[rbp-117]
	test	al, al
	jne	SHORT $LN109@AssumeDire
	cmp	ecx, edx
	je	SHORT $LN27@AssumeDire
$LN28@AssumeDire:

; 375  :                 ( ti.is_ptr > 0 && size < CurrWordSize ) ) {
; 376  :                 return( EmitError( TYPE_IS_WRONG_SIZE_FOR_REGISTER ) );

	mov	ecx, 247				; 000000f7H
	call	EmitError
	jmp	$LN1@AssumeDire
$LN109@AssumeDire:

; 374  :             if ( ( ti.is_ptr == 0 && size != ti.size ) ||

	movzx	eax, BYTE PTR ModuleInfo+406
	cmp	ecx, eax
	jl	SHORT $LN28@AssumeDire
$LN27@AssumeDire:

; 377  :             }
; 378  :             info->error &= ~(( reg >= T_AH && reg <= T_BH ) ? RH_ERROR : ( flags & OP_R ));

	lea	eax, DWORD PTR [r14-5]
	cmp	eax, 3
	ja	SHORT $LN57@AssumeDire
	mov	edi, 16
	jmp	SHORT $LN58@AssumeDire
$LN57@AssumeDire:
	and	edi, 15
$LN58@AssumeDire:
	not	dil
	and	BYTE PTR [rbx+8], dil

; 379  :             if ( stdsym[j] == NULL ) {

	lea	rdi, OFFSET FLAT:__ImageBase
	cmp	QWORD PTR stdsym[rdi+r15*8], r13
	jne	SHORT $LN30@AssumeDire

; 380  :                 stdsym[j] = CreateTypeSymbol( NULL, "", FALSE );

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:$SG11141
	xor	ecx, ecx
	call	CreateTypeSymbol
	mov	QWORD PTR stdsym[rdi+r15*8], rax

; 381  :                 stdsym[j]->typekind = TYPE_TYPEDEF;

	mov	BYTE PTR [rax+66], 3
	mov	edx, DWORD PTR ti$[rbp-137]
$LN30@AssumeDire:

; 382  :             }
; 383  : 
; 384  :             stdsym[j]->total_size = ti.size;

	mov	rax, QWORD PTR stdsym[rdi+r15*8]
	mov	DWORD PTR [rax+56], edx

; 385  :             stdsym[j]->mem_type   = ti.mem_type;

	mov	eax, DWORD PTR ti$[rbp-121]
	mov	rcx, QWORD PTR stdsym[rdi+r15*8]
	mov	DWORD PTR [rcx+36], eax

; 386  :             stdsym[j]->is_ptr     = ti.is_ptr;

	movzx	eax, BYTE PTR ti$[rbp-117]
	mov	rcx, QWORD PTR stdsym[rdi+r15*8]
	mov	BYTE PTR [rcx+45], al

; 387  :             stdsym[j]->isfar      = ti.is_far;

	mov	rcx, QWORD PTR stdsym[rdi+r15*8]
	movzx	eax, BYTE PTR ti$[rbp-116]
	shl	al, 4
	xor	al, BYTE PTR [rcx+47]
	and	al, 16
	xor	BYTE PTR [rcx+47], al

; 388  :             stdsym[j]->Ofssize    = ti.Ofssize;

	movzx	eax, BYTE PTR ti$[rbp-115]
	mov	rcx, QWORD PTR stdsym[rdi+r15*8]
	mov	BYTE PTR [rcx+44], al

; 389  :             stdsym[j]->ptr_memtype = ti.ptr_memtype; /* added v2.05 rc13 */

	mov	rcx, QWORD PTR stdsym[rdi+r15*8]
	movzx	eax, BYTE PTR ti$[rbp-113]
	mov	BYTE PTR [rcx+46], al

; 390  :             if ( ti.mem_type == MT_TYPE )

	cmp	DWORD PTR ti$[rbp-121], 196		; 000000c4H

; 391  :                 stdsym[j]->type = ti.symtype;

	mov	rcx, QWORD PTR stdsym[rdi+r15*8]
	mov	rax, QWORD PTR ti$[rbp-129]
	jne	SHORT $LN31@AssumeDire
	mov	QWORD PTR [rcx+80], rax

; 394  : 
; 395  :             info->symbol = stdsym[j];

	mov	rax, QWORD PTR stdsym[rdi+r15*8]
	mov	QWORD PTR [rbx], rax

; 396  : 
; 397  :         } else { /* segment register */

	jmp	$LN110@AssumeDire
$LN31@AssumeDire:

; 392  :             else
; 393  :                 stdsym[j]->target_type = ti.symtype;

	mov	QWORD PTR [rcx+48], rax

; 394  : 
; 395  :             info->symbol = stdsym[j];

	mov	rax, QWORD PTR stdsym[rdi+r15*8]
	mov	QWORD PTR [rbx], rax

; 396  : 
; 397  :         } else { /* segment register */

	jmp	$LN110@AssumeDire
$LN24@AssumeDire:

; 398  :             struct expr opnd;
; 399  : 
; 400  :             /* v2.08: read expression with standard evaluator */
; 401  :             if( EvalOperand( &i, tokenarray, Token_Count, &opnd, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opnd$1[rbp-137]
	mov	BYTE PTR [rsp+32], r13b
	call	EvalOperand
	cmp	eax, -1
	je	$LN86@AssumeDire

; 402  :                 return( ERROR );
; 403  :             switch ( opnd.kind ) {

	mov	ecx, DWORD PTR opnd$1[rbp-77]
	sub	ecx, 1
	je	SHORT $LN34@AssumeDire
	cmp	ecx, 1
	jne	$LN37@AssumeDire

; 421  :                 break;
; 422  :             case EXPR_REG:
; 423  :                 if ( GetValueSp( opnd.base_reg->tokval ) & OP_SR ) {

	mov	rdx, QWORD PTR opnd$1[rbp-113]
	lea	rdi, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR [rdx+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	test	DWORD PTR SpecialTable[rdi+rcx*4], 24576 ; 00006000H
	je	$LN37@AssumeDire

; 424  :                     info->symbol = SegAssumeTable[ GetRegNo( opnd.base_reg->tokval ) ].symbol;

	movzx	eax, BYTE PTR SpecialTable[rdi+rcx*4+10]
	lea	r8, OFFSET FLAT:SegAssumeTable
	add	rax, rax
	mov	rax, QWORD PTR [r8+rax*8]
	mov	QWORD PTR [rbx], rax

; 425  :                     info->is_flat = SegAssumeTable[ GetRegNo( opnd.base_reg->tokval ) ].is_flat;

	mov	eax, DWORD PTR [rdx+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR SpecialTable[rdi+rcx*4+10]
	add	rax, rax
	movzx	eax, BYTE PTR [r8+rax*8+9]

; 426  :                     break;

	jmp	$LN111@AssumeDire
$LN34@AssumeDire:

; 404  :             case EXPR_ADDR:
; 405  :                 if ( opnd.sym == NULL || opnd.indirect == TRUE || opnd.value ) {

	mov	rcx, QWORD PTR opnd$1[rbp-57]
	test	rcx, rcx
	je	$LN37@AssumeDire
	test	BYTE PTR opnd$1[rbp-65], 1
	jne	$LN37@AssumeDire
	cmp	DWORD PTR opnd$1[rbp-137], r13d
	jne	$LN37@AssumeDire

; 407  :                 } else if ( opnd.sym->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [rcx+32]
	test	eax, eax
	jne	SHORT $LN38@AssumeDire

; 408  :                     /* ensure that directive is rerun in pass 2
; 409  :                      * so an error msg can be emitted.
; 410  :                      */
; 411  :                     FStoreLine( 0 );

	cmp	DWORD PTR Parse_Pass, r13d
	jne	SHORT $LN40@AssumeDire
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
	mov	rcx, QWORD PTR opnd$1[rbp-57]
$LN40@AssumeDire:

; 412  :                     info->symbol = opnd.sym;

	mov	QWORD PTR [rbx], rcx
	jmp	SHORT $LN46@AssumeDire
$LN38@AssumeDire:
	mov	edx, DWORD PTR opnd$1[rbp-81]
	add	eax, -3					; fffffffdH
	cmp	eax, 1
	ja	SHORT $LN42@AssumeDire

; 413  :                 } else if ( ( opnd.sym->state == SYM_SEG || opnd.sym->state == SYM_GRP ) && opnd.instr == EMPTY ) {

	cmp	edx, -2
	jne	SHORT $LN42@AssumeDire

; 414  :                     info->symbol = opnd.sym;

	mov	QWORD PTR [rbx], rcx
	jmp	SHORT $LN46@AssumeDire
$LN42@AssumeDire:

; 415  :                 } else if ( opnd.instr == T_SEG ) {

	cmp	edx, 244				; 000000f4H
	jne	$LN37@AssumeDire

; 416  :                     info->symbol = opnd.sym->segment;

	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rbx], rax
$LN46@AssumeDire:

; 417  :                 } else {
; 418  :                     return( EmitError( SEGMENT_GROUP_OR_SEGREG_EXPECTED ) );
; 419  :                 }
; 420  :                 info->is_flat = ( info->symbol == &ModuleInfo.flat_grp->sym );

	mov	rax, QWORD PTR ModuleInfo+440
	lea	rdi, OFFSET FLAT:__ImageBase
	cmp	QWORD PTR [rbx], rax
	sete	al
$LN111@AssumeDire:
	mov	BYTE PTR [rbx+9], al

; 427  :                 }
; 428  :             default:
; 429  :                 return( EmitError( SEGMENT_GROUP_OR_SEGREG_EXPECTED ) );
; 430  :             }
; 431  :             info->error = FALSE;

	mov	BYTE PTR [rbx+8], r13b
$LN110@AssumeDire:
	mov	r8d, DWORD PTR i$[rbp-137]
$LN25@AssumeDire:

; 432  :         }
; 433  : 
; 434  :         /* comma expected */
; 435  :         if( i < Token_Count && tokenarray[i].token != T_COMMA )

	mov	ecx, DWORD PTR ModuleInfo+496
	cmp	r8d, ecx
	jge	SHORT $LN2@AssumeDire
	movsxd	rax, r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 44			; 0000002cH
	jne	$LN3@AssumeDire
$LN2@AssumeDire:

; 288  :     int             reg;
; 289  :     int             j;
; 290  :     int             size;
; 291  :     uint_32         flags;
; 292  :     struct assume_info *info;
; 293  :     bool            segtable;
; 294  :     struct qualified_type ti;
; 295  : 
; 296  :     DebugMsg1(( "AssumeDirective enter, pass=%u\n", Parse_Pass+1 ));
; 297  : 
; 298  :     for( i++; i < Token_Count; i++ ) {

	inc	r8d
	mov	DWORD PTR i$[rbp-137], r8d
	cmp	r8d, ecx
	jl	$LN112@AssumeDire
$LN51@AssumeDire:

; 440  :     }
; 441  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@AssumeDire:

; 442  : }

	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN81@AssumeDire:

; 302  :             AssumeInit( -1 );

	mov	QWORD PTR SegAssumeTable, r13
	lea	rax, OFFSET FLAT:StdAssumeTable+8
	mov	WORD PTR SegAssumeTable+8, r13w
	lea	rcx, OFFSET FLAT:StdAssumeTable+264
	mov	QWORD PTR SegAssumeTable+16, r13
	mov	WORD PTR SegAssumeTable+24, r13w
	mov	QWORD PTR SegAssumeTable+32, r13
	mov	WORD PTR SegAssumeTable+40, r13w
	mov	QWORD PTR SegAssumeTable+48, r13
	mov	WORD PTR SegAssumeTable+56, r13w
	mov	QWORD PTR SegAssumeTable+64, r13
	mov	WORD PTR SegAssumeTable+72, r13w
	mov	QWORD PTR SegAssumeTable+80, r13
	mov	WORD PTR SegAssumeTable+88, r13w
	npad	11
$LL65@AssumeDire:
	mov	QWORD PTR [rax-8], r13
	mov	BYTE PTR [rax], r13b
	add	rax, 16
	cmp	rax, rcx
	jl	SHORT $LL65@AssumeDire

; 303  :             i++;

	mov	r8d, DWORD PTR i$[rbp-137]

; 304  :             break;

	mov	ecx, DWORD PTR ModuleInfo+496
	inc	r8d
	mov	DWORD PTR i$[rbp-137], r8d
$LN3@AssumeDire:

; 436  :             break;
; 437  :     }
; 438  :     if ( i < Token_Count ) {

	cmp	r8d, ecx
	jge	$LN51@AssumeDire

; 439  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rdx, r8d
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r12+24]
	call	EmitErr
	jmp	$LN1@AssumeDire
$LN86@AssumeDire:

; 370  :                 return( ERROR );

	or	eax, -1
	jmp	$LN1@AssumeDire
$LN37@AssumeDire:

; 406  :                     return( EmitError( SEGMENT_GROUP_OR_SEGREG_EXPECTED ) );

	mov	ecx, 69					; 00000045H
	call	EmitError
	jmp	$LN1@AssumeDire
$LN85@AssumeDire:

; 338  :             return( EmitError( SYNTAX_ERROR ) );

	mov	ecx, 45					; 0000002dH
	call	EmitError
	jmp	$LN1@AssumeDire
$LN84@AssumeDire:

; 333  :             return( EmitError( COLON_EXPECTED ) );

	mov	ecx, 84					; 00000054H
	call	EmitError
	jmp	$LN1@AssumeDire
$LN83@AssumeDire:

; 327  :             return( EmitError( INSTRUCTION_OR_REGISTER_NOT_ACCEPTED_IN_CURRENT_CPU_MODE ) );

	mov	ecx, 30
	call	EmitError
	jmp	$LN1@AssumeDire
$LN82@AssumeDire:

; 323  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, r8d
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r12+8]
	call	EmitErr
	jmp	$LN1@AssumeDire
AssumeDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
AssumeSaveState PROC

; 146  :     GetSegAssumeTable( &saved_SegAssumeTable );

	movups	xmm0, XMMWORD PTR SegAssumeTable

; 147  :     GetStdAssumeTable( &saved_StdAssumeTable, saved_StdTypeInfo );

	lea	r8, OFFSET FLAT:StdAssumeTable
	mov	edx, 2
	movups	xmm1, XMMWORD PTR SegAssumeTable+16
	lea	rax, OFFSET FLAT:saved_StdAssumeTable
	mov	rcx, r8
	movaps	XMMWORD PTR saved_SegAssumeTable, xmm0
	movups	xmm0, XMMWORD PTR SegAssumeTable+32
	movaps	XMMWORD PTR saved_SegAssumeTable+16, xmm1
	movups	xmm1, XMMWORD PTR SegAssumeTable+48
	movaps	XMMWORD PTR saved_SegAssumeTable+32, xmm0
	movups	xmm0, XMMWORD PTR SegAssumeTable+64
	movaps	XMMWORD PTR saved_SegAssumeTable+48, xmm1
	movups	xmm1, XMMWORD PTR SegAssumeTable+80
	movaps	XMMWORD PTR saved_SegAssumeTable+64, xmm0
	movaps	XMMWORD PTR saved_SegAssumeTable+80, xmm1
	npad	6
$LL15@AssumeSave:
	lea	rax, QWORD PTR [rax+128]
	movups	xmm0, XMMWORD PTR [rcx]
	movups	xmm1, XMMWORD PTR [rcx+16]
	lea	rcx, QWORD PTR [rcx+128]
	movups	XMMWORD PTR [rax-128], xmm0
	movups	xmm0, XMMWORD PTR [rcx-96]
	movups	XMMWORD PTR [rax-112], xmm1
	movups	xmm1, XMMWORD PTR [rcx-80]
	movups	XMMWORD PTR [rax-96], xmm0
	movups	xmm0, XMMWORD PTR [rcx-64]
	movups	XMMWORD PTR [rax-80], xmm1
	movups	xmm1, XMMWORD PTR [rcx-48]
	movups	XMMWORD PTR [rax-64], xmm0
	movups	xmm0, XMMWORD PTR [rcx-32]
	movups	XMMWORD PTR [rax-48], xmm1
	movups	xmm1, XMMWORD PTR [rcx-16]
	movups	XMMWORD PTR [rax-32], xmm0
	movups	XMMWORD PTR [rax-16], xmm1
	sub	rdx, 1
	jne	SHORT $LL15@AssumeSave

; 146  :     GetSegAssumeTable( &saved_SegAssumeTable );

	lea	rax, OFFSET FLAT:saved_StdTypeInfo+16
	lea	r9d, QWORD PTR [rdx+16]
	npad	2

; 147  :     GetStdAssumeTable( &saved_StdAssumeTable, saved_StdTypeInfo );

$LL8@AssumeSave:
	mov	rdx, QWORD PTR [r8]
	test	rdx, rdx
	je	SHORT $LN6@AssumeSave
	mov	rcx, QWORD PTR [rdx+80]
	mov	QWORD PTR [rax-16], rcx
	mov	rcx, QWORD PTR [rdx+48]
	mov	QWORD PTR [rax-8], rcx
	mov	ecx, DWORD PTR [rdx+36]
	mov	DWORD PTR [rax], ecx
	movzx	ecx, BYTE PTR [rdx+46]
	mov	BYTE PTR [rax+4], cl
	movzx	ecx, BYTE PTR [rdx+45]
	mov	BYTE PTR [rax+5], cl
$LN6@AssumeSave:
	add	r8, 16
	add	rax, 24
	sub	r9, 1
	jne	SHORT $LL8@AssumeSave

; 148  : }

	ret	0
AssumeSaveState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
savedstate$ = 8
ti$ = 16
GetStdAssumeTable PROC

; 128  :     int i;
; 129  :     DebugMsg(("GetStdAssumeTable\n" ));
; 130  :     memcpy( savedstate, &StdAssumeTable, sizeof(StdAssumeTable) );

	lea	rax, OFFSET FLAT:StdAssumeTable
	mov	r9d, 2
	mov	r8, rax
$LL11@GetStdAssu:
	lea	rcx, QWORD PTR [rcx+128]
	movups	xmm0, XMMWORD PTR [r8]
	lea	r8, QWORD PTR [r8+128]
	movups	XMMWORD PTR [rcx-128], xmm0
	movups	xmm1, XMMWORD PTR [r8-112]
	movups	XMMWORD PTR [rcx-112], xmm1
	movups	xmm0, XMMWORD PTR [r8-96]
	movups	XMMWORD PTR [rcx-96], xmm0
	movups	xmm1, XMMWORD PTR [r8-80]
	movups	XMMWORD PTR [rcx-80], xmm1
	movups	xmm0, XMMWORD PTR [r8-64]
	movups	XMMWORD PTR [rcx-64], xmm0
	movups	xmm1, XMMWORD PTR [r8-48]
	movups	XMMWORD PTR [rcx-48], xmm1
	movups	xmm0, XMMWORD PTR [r8-32]
	movups	XMMWORD PTR [rcx-32], xmm0
	movups	xmm1, XMMWORD PTR [r8-16]
	movups	XMMWORD PTR [rcx-16], xmm1
	sub	r9, 1
	jne	SHORT $LL11@GetStdAssu
	lea	r8, QWORD PTR [rdx+16]
	mov	r9d, 16
$LL4@GetStdAssu:

; 132  :         if ( StdAssumeTable[i].symbol ) {

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN2@GetStdAssu

; 133  :             ti->type        = StdAssumeTable[i].symbol->type;

	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [r8-16], rcx

; 134  :             ti->target_type = StdAssumeTable[i].symbol->target_type;

	mov	rcx, QWORD PTR [rax]
	mov	rdx, QWORD PTR [rcx+48]
	mov	QWORD PTR [r8-8], rdx

; 135  :             ti->mem_type    = StdAssumeTable[i].symbol->mem_type;

	mov	rcx, QWORD PTR [rax]
	mov	edx, DWORD PTR [rcx+36]
	mov	DWORD PTR [r8], edx

; 136  :             ti->ptr_memtype = StdAssumeTable[i].symbol->ptr_memtype;

	mov	rcx, QWORD PTR [rax]
	movzx	edx, BYTE PTR [rcx+46]
	mov	BYTE PTR [r8+4], dl

; 137  :             ti->is_ptr      = StdAssumeTable[i].symbol->is_ptr;

	mov	rcx, QWORD PTR [rax]
	movzx	edx, BYTE PTR [rcx+45]
	mov	BYTE PTR [r8+5], dl
$LN2@GetStdAssu:

; 131  :     for ( i = 0; i < NUM_STDREGS; i++, ti++ ) {

	add	rax, 16
	add	r8, 24
	sub	r9, 1
	jne	SHORT $LL4@GetStdAssu

; 138  :         }
; 139  :     }
; 140  : }

	ret	0
GetStdAssumeTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
savedstate$ = 8
ti$ = 16
SetStdAssumeTable PROC

; 110  :     int i;
; 111  : 
; 112  :     DebugMsg(("SetStdAssumeTable enter\n" ));
; 113  :     memcpy( &StdAssumeTable, savedstate, sizeof(StdAssumeTable) );

	lea	rax, OFFSET FLAT:StdAssumeTable
	mov	r9d, 2
	mov	r8, rax
$LL11@SetStdAssu:
	lea	r8, QWORD PTR [r8+128]
	movups	xmm0, XMMWORD PTR [rcx]
	lea	rcx, QWORD PTR [rcx+128]
	movups	XMMWORD PTR [r8-128], xmm0
	movups	xmm1, XMMWORD PTR [rcx-112]
	movups	XMMWORD PTR [r8-112], xmm1
	movups	xmm0, XMMWORD PTR [rcx-96]
	movups	XMMWORD PTR [r8-96], xmm0
	movups	xmm1, XMMWORD PTR [rcx-80]
	movups	XMMWORD PTR [r8-80], xmm1
	movups	xmm0, XMMWORD PTR [rcx-64]
	movups	XMMWORD PTR [r8-64], xmm0
	movups	xmm1, XMMWORD PTR [rcx-48]
	movups	XMMWORD PTR [r8-48], xmm1
	movups	xmm0, XMMWORD PTR [rcx-32]
	movups	XMMWORD PTR [r8-32], xmm0
	movups	xmm1, XMMWORD PTR [rcx-16]
	movups	XMMWORD PTR [r8-16], xmm1
	sub	r9, 1
	jne	SHORT $LL11@SetStdAssu
	lea	r8, QWORD PTR [rdx+16]
	mov	r9d, 16
$LL4@SetStdAssu:

; 115  :         if ( StdAssumeTable[i].symbol ) {

	mov	rdx, QWORD PTR [rax]
	test	rdx, rdx
	je	SHORT $LN2@SetStdAssu

; 116  :             StdAssumeTable[i].symbol->type        = ti->type;

	mov	rcx, QWORD PTR [r8-16]
	mov	QWORD PTR [rdx+80], rcx

; 117  :             StdAssumeTable[i].symbol->target_type = ti->target_type;

	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR [r8-8]
	mov	QWORD PTR [rdx+48], rcx

; 118  :             StdAssumeTable[i].symbol->mem_type    = ti->mem_type;

	mov	rdx, QWORD PTR [rax]
	mov	ecx, DWORD PTR [r8]
	mov	DWORD PTR [rdx+36], ecx

; 119  :             StdAssumeTable[i].symbol->ptr_memtype = ti->ptr_memtype;

	mov	rdx, QWORD PTR [rax]
	movzx	ecx, BYTE PTR [r8+4]
	mov	BYTE PTR [rdx+46], cl

; 120  :             StdAssumeTable[i].symbol->is_ptr      = ti->is_ptr;

	mov	rdx, QWORD PTR [rax]
	movzx	ecx, BYTE PTR [r8+5]
	mov	BYTE PTR [rdx+45], cl
$LN2@SetStdAssu:

; 114  :     for ( i = 0; i < NUM_STDREGS; i++, ti++ ) {

	add	rax, 16
	add	r8, 24
	sub	r9, 1
	jne	SHORT $LL4@SetStdAssu

; 121  :         }
; 122  :     }
; 123  : }

	ret	0
SetStdAssumeTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
savedstate$ = 8
GetSegAssumeTable PROC

; 96   :     DebugMsg(("GetSegAssumeTable\n" ));
; 97   :     memcpy( savedstate, &SegAssumeTable, sizeof(SegAssumeTable) );

	movups	xmm0, XMMWORD PTR SegAssumeTable
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR SegAssumeTable+16
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR SegAssumeTable+32
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR SegAssumeTable+48
	movups	XMMWORD PTR [rcx+48], xmm1
	movups	xmm0, XMMWORD PTR SegAssumeTable+64
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	xmm1, XMMWORD PTR SegAssumeTable+80
	movups	XMMWORD PTR [rcx+80], xmm1

; 98   : }

	ret	0
GetSegAssumeTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
savedstate$ = 8
SetSegAssumeTable PROC

; 90   :     DebugMsg(("SetSegAssumeTable\n" ));
; 91   :     memcpy( &SegAssumeTable, savedstate, sizeof(SegAssumeTable) );

	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR SegAssumeTable, xmm0
	movups	xmm1, XMMWORD PTR [rcx+16]
	movups	XMMWORD PTR SegAssumeTable+16, xmm1
	movups	xmm0, XMMWORD PTR [rcx+32]
	movups	XMMWORD PTR SegAssumeTable+32, xmm0
	movups	xmm1, XMMWORD PTR [rcx+48]
	movups	XMMWORD PTR SegAssumeTable+48, xmm1
	movups	xmm0, XMMWORD PTR [rcx+64]
	movups	XMMWORD PTR SegAssumeTable+64, xmm0
	movups	xmm1, XMMWORD PTR [rcx+80]
	movups	XMMWORD PTR SegAssumeTable+80, xmm1

; 92   : }

	ret	0
SetSegAssumeTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
ModelAssumeInit PROC

; 208  : {

$LN16:
	sub	rsp, 120				; 00000078H

; 209  :     const char *pCS;
; 210  :     const char *pFSassume = szError;
; 211  :     const char *pGSassume = szError;
; 212  :     const char *pFmt;
; 213  : 
; 214  :     /* Generates codes for assume */
; 215  :     switch( ModuleInfo.model ) {

	mov	ecx, DWORD PTR ModuleInfo+360
	lea	rdx, OFFSET FLAT:szError
	test	ecx, ecx
	jle	$LN8@ModelAssum
	cmp	ecx, 6
	jle	$LN6@ModelAssum
	cmp	ecx, 7
	jne	$LN8@ModelAssum

; 216  :     case MODEL_FLAT:
; 217  : #if AMD64_SUPPORT
; 218  :         if ( ModuleInfo.fctype == FCT_WIN64 )

	cmp	DWORD PTR ModuleInfo+376, 2

; 219  :             pGSassume = szNothing;
; 220  : #endif
; 221  :         AddLineQueueX( "%r %r:%r,%r:%r,%r:%r,%r:%r,%r:%s,%r:%s",

	lea	r8d, QWORD PTR [rcx+19]
	lea	rax, OFFSET FLAT:szNothing
	mov	r9d, 261				; 00000105H
	cmovne	rax, rdx
	lea	rcx, OFFSET FLAT:$SG11067
	mov	QWORD PTR [rsp+104], rax
	mov	DWORD PTR [rsp+96], 30
	mov	QWORD PTR [rsp+88], rdx
	mov	edx, 444				; 000001bcH
	mov	DWORD PTR [rsp+80], 29
	mov	DWORD PTR [rsp+72], 261			; 00000105H
	mov	DWORD PTR [rsp+64], 25
	mov	DWORD PTR [rsp+56], 261			; 00000105H
	mov	DWORD PTR [rsp+48], 27
	mov	DWORD PTR [rsp+40], 261			; 00000105H
	mov	DWORD PTR [rsp+32], 28
	call	AddLineQueueX

; 249  :         break;
; 250  :     }
; 251  : }

	add	rsp, 120				; 00000078H
	ret	0
$LN6@ModelAssum:
	mov	eax, DWORD PTR Options+144
	add	eax, -2					; fffffffeH
	cmp	eax, 1
	jbe	SHORT $LN8@ModelAssum
	mov	QWORD PTR [rsp+112], rbx

; 222  :                   T_ASSUME, T_CS, T_FLAT, T_DS, T_FLAT, T_SS, T_FLAT, T_ES, T_FLAT, T_FS, pFSassume, T_GS, pGSassume );
; 223  :         break;
; 224  :     case MODEL_TINY:
; 225  :     case MODEL_SMALL:
; 226  :     case MODEL_COMPACT:
; 227  :     case MODEL_MEDIUM:
; 228  :     case MODEL_LARGE:
; 229  :     case MODEL_HUGE:
; 230  :         /* v2.03: no DGROUP for COFF/ELF */
; 231  : #if COFF_SUPPORT || ELF_SUPPORT
; 232  :         if( Options.output_format == OFORMAT_COFF
; 233  : #if ELF_SUPPORT
; 234  :            || Options.output_format == OFORMAT_ELF
; 235  : #endif
; 236  :           )
; 237  :             break;
; 238  : #endif
; 239  :         if ( ModuleInfo.model == MODEL_TINY )

	lea	rbx, OFFSET FLAT:szDgroup
	cmp	ecx, 1
	jne	SHORT $LN9@ModelAssum

; 240  :             pCS = szDgroup;

	mov	rax, rbx
	jmp	SHORT $LN10@ModelAssum
$LN9@ModelAssum:

; 241  :         else
; 242  :             pCS = SimGetSegName( SIM_CODE );

	xor	ecx, ecx
	call	SimGetSegName
$LN10@ModelAssum:

; 243  : 
; 244  :         if ( ModuleInfo.distance != STACK_FAR )

	cmp	DWORD PTR ModuleInfo+356, 1
	lea	rdx, OFFSET FLAT:$SG11076

; 245  :             pFmt = "%r %r:%s,%r:%s,%r:%s";
; 246  :         else
; 247  :             pFmt = "%r %r:%s,%r:%s";
; 248  :         AddLineQueueX( pFmt, T_ASSUME, T_CS, pCS, T_DS, szDgroup, T_SS, szDgroup );

	mov	QWORD PTR [rsp+56], rbx
	lea	rcx, OFFSET FLAT:$SG11075
	cmove	rcx, rdx
	mov	DWORD PTR [rsp+48], 27
	mov	edx, 444				; 000001bcH
	mov	QWORD PTR [rsp+40], rbx
	mov	r9, rax
	mov	DWORD PTR [rsp+32], 28
	mov	r8d, 26
	call	AddLineQueueX
	mov	rbx, QWORD PTR [rsp+112]
$LN8@ModelAssum:

; 249  :         break;
; 250  :     }
; 251  : }

	add	rsp, 120				; 00000078H
	ret	0
ModelAssumeInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
reg$ = 8
GetStdAssumeEx PROC

; 273  :   if (reg >= NUM_STDREGS)

	cmp	ecx, 16
	jl	SHORT $LN2@GetStdAssu

; 274  :     return NULL;

	xor	eax, eax

; 276  : }

	ret	0
$LN2@GetStdAssu:

; 275  :   return(StdAssumeTable[reg].symbol);

	movsxd	rax, ecx
	lea	rcx, OFFSET FLAT:StdAssumeTable
	add	rax, rax
	mov	rax, QWORD PTR [rcx+rax*8]

; 276  : }

	ret	0
GetStdAssumeEx ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
reg$ = 8
GetStdAssume PROC

; 258  :     if ( StdAssumeTable[reg].symbol )

	movsxd	rax, ecx
	lea	rcx, OFFSET FLAT:StdAssumeTable
	add	rax, rax
	mov	rax, QWORD PTR [rcx+rax*8]
	test	rax, rax
	je	SHORT $LN4@GetStdAssu

; 259  :         if ( StdAssumeTable[reg].symbol->mem_type == MT_TYPE )

	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN3@GetStdAssu

; 260  :             return( StdAssumeTable[reg].symbol->type );

	mov	rax, QWORD PTR [rax+80]

; 263  :     return ( NULL );
; 264  : }

	ret	0
$LN3@GetStdAssu:

; 261  :         else
; 262  :             return( StdAssumeTable[reg].symbol->target_type );

	mov	rax, QWORD PTR [rax+48]

; 263  :     return ( NULL );
; 264  : }

	ret	0
$LN4@GetStdAssu:
	ret	0
GetStdAssume ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
override$ = 8
GetOverrideAssume PROC

; 508  :     if( SegAssumeTable[override].is_flat ) {

	movsxd	rax, ecx
	lea	rcx, OFFSET FLAT:SegAssumeTable
	add	rax, rax
	cmp	BYTE PTR [rcx+rax*8+9], 0
	je	SHORT $LN2@GetOverrid

; 509  :         return( (struct asym *)ModuleInfo.flat_grp );

	mov	rax, QWORD PTR ModuleInfo+440

; 512  : 
; 513  : }

	ret	0
$LN2@GetOverrid:

; 510  :     }
; 511  :     return( SegAssumeTable[override].symbol);

	mov	rax, QWORD PTR [rcx+rax*8]

; 512  : 
; 513  : }

	ret	0
GetOverrideAssume ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
override$ = 48
sym$ = 56
def$ = 64
passume$ = 72
GetAssume PROC

; 527  : {

$LN43:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	movsxd	rbx, r8d

; 528  :     enum assume_segreg  reg;
; 529  : 
; 530  :     if( ( def != ASSUME_NOTHING ) && SegAssumeTable[def].is_flat ) {

	lea	rbp, OFFSET FLAT:SegAssumeTable
	mov	r14, r9
	mov	rsi, rdx
	mov	rdi, rcx
	cmp	ebx, -2
	je	SHORT $LN2@GetAssume
	mov	rax, rbx
	add	rax, rax
	cmp	BYTE PTR [rbp+rax*8+9], 0
	je	SHORT $LN2@GetAssume

; 531  :         *passume = (struct asym *)ModuleInfo.flat_grp;

	mov	rax, QWORD PTR ModuleInfo+440
	mov	QWORD PTR [r9], rax

; 532  :         return( def );

	mov	eax, ebx
	jmp	SHORT $LN1@GetAssume
$LN2@GetAssume:

; 533  :     }
; 534  :     if( override != NULL ) {

	test	rcx, rcx
	je	SHORT $LN3@GetAssume

; 535  :         reg = search_assume( override, def, FALSE );

	call	GetGroup
	cmp	ebx, -2
	je	SHORT $LN20@GetAssume
	mov	rax, rbx
	add	rax, rax
	cmp	QWORD PTR [rbp+rax*8], rdi
	jne	SHORT $LN20@GetAssume
	mov	edx, ebx
	jmp	SHORT $LN6@GetAssume
$LN20@GetAssume:
	lea	rcx, OFFSET FLAT:searchtab
	lea	r8, OFFSET FLAT:searchtab+24
	npad	5
$LL14@GetAssume:
	movsxd	rdx, DWORD PTR [rcx]
	mov	rax, rdx
	add	rax, rax
	cmp	QWORD PTR [rbp+rax*8], rdi
	je	SHORT $LN6@GetAssume
	add	rcx, 4
	cmp	rcx, r8
	jl	SHORT $LL14@GetAssume
	jmp	SHORT $LN41@GetAssume
$LN3@GetAssume:

; 536  : #if 1 /* v2.10: added */
; 537  :     } else if ( sym->state == SYM_STACK ) {

	cmp	DWORD PTR [rdx+32], 5
	jne	SHORT $LN5@GetAssume

; 538  :         /* stack symbols don't have a segment part.
; 539  :          * In case [R|E]BP is used as base, it doesn't matter.
; 540  :          * However, if option -Zg is set, this isn't true.
; 541  :          */
; 542  :         reg = ASSUME_SS;

	mov	edx, 2
$LN40@GetAssume:

; 553  :         *passume = SegAssumeTable[reg].symbol;

	movsxd	rax, edx
	add	rax, rax
	mov	rax, QWORD PTR [rbp+rax*8]
	mov	QWORD PTR [r14], rax

; 554  :         return( reg );

	mov	eax, edx
$LN1@GetAssume:

; 558  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN5@GetAssume:

; 543  : #endif
; 544  :     } else {
; 545  :         reg = search_assume( sym->segment, def, TRUE );

	mov	rcx, QWORD PTR [rsi+24]
	mov	r8b, 1
	mov	edx, ebx
	call	search_assume
	mov	edx, eax
$LN6@GetAssume:

; 546  :     }
; 547  :     if( reg == ASSUME_NOTHING ) {

	cmp	edx, -2
	jne	SHORT $LN40@GetAssume
$LN41@GetAssume:

; 548  :         if( sym && sym->state == SYM_EXTERNAL && sym->segment == NULL ) {

	test	rsi, rsi
	je	SHORT $LN9@GetAssume
	cmp	DWORD PTR [rsi+32], 2
	jne	SHORT $LN9@GetAssume
	cmp	QWORD PTR [rsi+24], 0
	jne	SHORT $LN9@GetAssume

; 549  :             reg = def;

	mov	edx, ebx

; 550  :         }
; 551  :     }
; 552  :     if( reg != ASSUME_NOTHING ) {

	cmp	ebx, -2
	jne	SHORT $LN40@GetAssume
$LN9@GetAssume:

; 555  :     }
; 556  :     *passume = NULL;

	mov	QWORD PTR [r14], 0

; 557  :     return( ASSUME_NOTHING );

	mov	eax, -2
	jmp	SHORT $LN1@GetAssume
GetAssume ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
sym$ = 48
def$ = 56
search_grps$ = 64
search_assume PROC

; 457  : {

$LN33:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rbx, edx
	movzx	esi, r8b
	mov	rdi, rcx

; 458  :     struct asym *grp;
; 459  : 
; 460  :     if( sym == NULL )

	test	rcx, rcx
	je	$LN6@search_ass

; 461  :         return( ASSUME_NOTHING );
; 462  : 
; 463  :     grp = GetGroup( sym );

	call	GetGroup

; 464  : 
; 465  :     /* first check the default segment register */
; 466  : 
; 467  :     if( def != ASSUME_NOTHING ) {

	mov	r10, QWORD PTR ModuleInfo+440
	mov	r8, rax
	lea	r11, OFFSET FLAT:SegAssumeTable
	cmp	ebx, -2
	je	SHORT $LN13@search_ass

; 468  :         if( SegAssumeTable[def].symbol == sym )

	mov	rax, rbx
	add	rax, rax
	mov	rcx, QWORD PTR [r11+rax*8]
	cmp	rcx, rdi
	jne	SHORT $LN10@search_ass
$LN31@search_ass:

; 469  :             return( def );

	mov	eax, ebx

; 497  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN10@search_ass:

; 470  :         if( search_grps && grp ) {

	test	sil, sil
	je	SHORT $LN13@search_ass
	test	r8, r8
	je	SHORT $LN13@search_ass

; 471  :             if( SegAssumeTable[def].is_flat && grp == &ModuleInfo.flat_grp->sym )

	cmp	BYTE PTR [r11+rax*8+9], 0
	je	SHORT $LN12@search_ass
	cmp	r8, r10
	je	SHORT $LN31@search_ass
$LN12@search_ass:

; 472  :                 return( def );
; 473  :             if( SegAssumeTable[def].symbol == grp )

	cmp	rcx, r8
	je	SHORT $LN31@search_ass
$LN13@search_ass:

; 474  :                 return( def );
; 475  :         }
; 476  :     }
; 477  : 
; 478  :     /* now check all segment registers */
; 479  : 
; 480  :     for( def = 0; def < NUM_SEGREGS; def++ ) {

	lea	rdx, OFFSET FLAT:searchtab
	mov	rcx, rdx
	lea	rbx, OFFSET FLAT:searchtab+24
	npad	5
$LL4@search_ass:

; 481  :         if( SegAssumeTable[searchtab[def]].symbol == sym ) {

	movsxd	r9, DWORD PTR [rcx]
	mov	rax, r9
	add	rax, rax
	cmp	QWORD PTR [r11+rax*8], rdi
	je	SHORT $LN21@search_ass

; 474  :                 return( def );
; 475  :         }
; 476  :     }
; 477  : 
; 478  :     /* now check all segment registers */
; 479  : 
; 480  :     for( def = 0; def < NUM_SEGREGS; def++ ) {

	add	rcx, 4
	cmp	rcx, rbx
	jl	SHORT $LL4@search_ass

; 482  :             return( searchtab[def] );
; 483  :         }
; 484  :     }
; 485  : 
; 486  :     /* now check the groups */
; 487  :     if( search_grps && grp )

	test	sil, sil
	je	SHORT $LN6@search_ass
	test	r8, r8
	je	SHORT $LN6@search_ass

; 488  :         for( def = 0; def < NUM_SEGREGS; def++ ) {

	xor	eax, eax
	npad	12
$LL7@search_ass:
	movsxd	r9, DWORD PTR [rdx]

; 489  :             if( SegAssumeTable[searchtab[def]].is_flat && grp == &ModuleInfo.flat_grp->sym )

	mov	rcx, r9
	add	rcx, rcx
	cmp	BYTE PTR [r11+rcx*8+9], 0
	je	SHORT $LN16@search_ass
	cmp	r8, r10
	je	SHORT $LN21@search_ass
$LN16@search_ass:

; 490  :                 return( searchtab[def] );
; 491  :             if( SegAssumeTable[searchtab[def]].symbol == grp ) {

	cmp	QWORD PTR [r11+rcx*8], r8
	je	SHORT $LN21@search_ass

; 488  :         for( def = 0; def < NUM_SEGREGS; def++ ) {

	inc	eax
	add	rdx, 4
	cmp	eax, 6
	jl	SHORT $LL7@search_ass
$LN6@search_ass:

; 492  :                 return( searchtab[def] );
; 493  :             }
; 494  :         }
; 495  : 
; 496  :     return( ASSUME_NOTHING );

	mov	eax, -2

; 497  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN21@search_ass:
	mov	rbx, QWORD PTR [rsp+48]
	mov	eax, r9d
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
search_assume ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
pass$ = 8
AssumeInit PROC

; 154  :     int reg;
; 155  : 
; 156  :     for( reg = 0; reg < NUM_SEGREGS; reg++ ) {
; 157  :         SegAssumeTable[reg].symbol = NULL;

	xor	edx, edx
	mov	QWORD PTR SegAssumeTable, rdx

; 158  :         SegAssumeTable[reg].error = FALSE;

	mov	WORD PTR SegAssumeTable+8, dx
	mov	QWORD PTR SegAssumeTable+16, rdx
	mov	WORD PTR SegAssumeTable+24, dx
	mov	QWORD PTR SegAssumeTable+32, rdx
	mov	WORD PTR SegAssumeTable+40, dx
	mov	QWORD PTR SegAssumeTable+48, rdx
	mov	WORD PTR SegAssumeTable+56, dx
	mov	QWORD PTR SegAssumeTable+64, rdx
	mov	WORD PTR SegAssumeTable+72, dx
	mov	QWORD PTR SegAssumeTable+80, rdx
	mov	WORD PTR SegAssumeTable+88, dx

; 159  :         SegAssumeTable[reg].is_flat = FALSE;
; 160  :     }
; 161  : 
; 162  :     /* the GPR assumes are handled somewhat special by masm.
; 163  :      * they aren't reset for each pass - instead they keep their value.
; 164  :      */
; 165  : 
; 166  :     if ( pass <= PASS_1 ) { /* v2.10: just reset assumes in pass one */

	test	ecx, ecx
	jg	SHORT $LN38@AssumeInit

; 167  : 
; 168  :         for( reg = 0; reg < NUM_STDREGS; reg++ ) {

	lea	rax, OFFSET FLAT:StdAssumeTable+8
	lea	r8, OFFSET FLAT:StdAssumeTable+264
	npad	8
$LL7@AssumeInit:

; 169  :             StdAssumeTable[reg].symbol = NULL;

	mov	QWORD PTR [rax-8], rdx

; 170  :             StdAssumeTable[reg].error = 0;

	mov	BYTE PTR [rax], dl
	add	rax, 16
	cmp	rax, r8
	jl	SHORT $LL7@AssumeInit

; 171  :         }
; 172  :         if ( pass == PASS_1 )

	test	ecx, ecx
	jne	$LN16@AssumeInit

; 173  :             memset( &stdsym, 0, sizeof( stdsym ) );

	mov	r8d, 128				; 00000080H
	lea	rcx, OFFSET FLAT:stdsym
	jmp	memset
$LN38@AssumeInit:

; 174  :     }
; 175  : #if FASTPASS
; 176  :     if ( pass > PASS_1 && UseSavedState ) {

	cmp	BYTE PTR UseSavedState, dl
	je	$LN16@AssumeInit

; 177  :         SetSegAssumeTable( &saved_SegAssumeTable );

	movaps	xmm0, XMMWORD PTR saved_SegAssumeTable

; 178  : #if 0
; 179  :         /* v2.10: this is a weird Masm feature:
; 180  :          * if a GPR is assumed to be a pointer to a struct,
; 181  :          * it isn't reset when a new pass starts.
; 182  :          * see assume11.asm and assume12.asm
; 183  :          */
; 184  :         if ( pass == PASS_2 ) {
; 185  :             struct assume_info *psaved = &saved_StdAssumeTable;
; 186  :             struct stdassume_typeinfo *ptype = &saved_StdTypeInfo;
; 187  :             for ( reg = 0; reg < NUM_STDREGS; reg++, psaved++, ptype++ )
; 188  :                 if ( psaved->symbol == NULL && StdAssumeTable[reg].symbol && StdAssumeTable[reg].symbol->target_type ) {
; 189  :                     psaved->symbol = StdAssumeTable[reg].symbol;
; 190  :                     ptype->type        = psaved->symbol->type;
; 191  :                     ptype->target_type = psaved->symbol->target_type;
; 192  :                     ptype->mem_type    = psaved->symbol->mem_type;
; 193  :                     ptype->ptr_memtype = psaved->symbol->ptr_memtype;
; 194  :                     ptype->is_ptr      = psaved->symbol->is_ptr;
; 195  :                 }
; 196  :         }
; 197  : #endif
; 198  :         SetStdAssumeTable( &saved_StdAssumeTable, saved_StdTypeInfo );

	lea	rdx, OFFSET FLAT:StdAssumeTable
	movaps	xmm1, XMMWORD PTR saved_SegAssumeTable+16
	lea	rcx, OFFSET FLAT:saved_StdAssumeTable
	movups	XMMWORD PTR SegAssumeTable, xmm0
	mov	rax, rdx
	mov	r8d, 2
	movaps	xmm0, XMMWORD PTR saved_SegAssumeTable+32
	movups	XMMWORD PTR SegAssumeTable+16, xmm1
	movaps	xmm1, XMMWORD PTR saved_SegAssumeTable+48
	movups	XMMWORD PTR SegAssumeTable+32, xmm0
	movaps	xmm0, XMMWORD PTR saved_SegAssumeTable+64
	movups	XMMWORD PTR SegAssumeTable+48, xmm1
	movaps	xmm1, XMMWORD PTR saved_SegAssumeTable+80
	movups	XMMWORD PTR SegAssumeTable+64, xmm0
	movups	XMMWORD PTR SegAssumeTable+80, xmm1
$LL39@AssumeInit:
	lea	rax, QWORD PTR [rax+128]
	movups	xmm0, XMMWORD PTR [rcx]
	movups	xmm1, XMMWORD PTR [rcx+16]
	lea	rcx, QWORD PTR [rcx+128]
	movups	XMMWORD PTR [rax-128], xmm0
	movups	xmm0, XMMWORD PTR [rcx-96]
	movups	XMMWORD PTR [rax-112], xmm1
	movups	xmm1, XMMWORD PTR [rcx-80]
	movups	XMMWORD PTR [rax-96], xmm0
	movups	xmm0, XMMWORD PTR [rcx-64]
	movups	XMMWORD PTR [rax-80], xmm1
	movups	xmm1, XMMWORD PTR [rcx-48]
	movups	XMMWORD PTR [rax-64], xmm0
	movups	xmm0, XMMWORD PTR [rcx-32]
	movups	XMMWORD PTR [rax-48], xmm1
	movups	xmm1, XMMWORD PTR [rcx-16]
	movups	XMMWORD PTR [rax-32], xmm0
	movups	XMMWORD PTR [rax-16], xmm1
	sub	r8, 1
	jne	SHORT $LL39@AssumeInit

; 177  :         SetSegAssumeTable( &saved_SegAssumeTable );

	lea	r8, OFFSET FLAT:saved_StdTypeInfo+16
	mov	r9d, 16

; 178  : #if 0
; 179  :         /* v2.10: this is a weird Masm feature:
; 180  :          * if a GPR is assumed to be a pointer to a struct,
; 181  :          * it isn't reset when a new pass starts.
; 182  :          * see assume11.asm and assume12.asm
; 183  :          */
; 184  :         if ( pass == PASS_2 ) {
; 185  :             struct assume_info *psaved = &saved_StdAssumeTable;
; 186  :             struct stdassume_typeinfo *ptype = &saved_StdTypeInfo;
; 187  :             for ( reg = 0; reg < NUM_STDREGS; reg++, psaved++, ptype++ )
; 188  :                 if ( psaved->symbol == NULL && StdAssumeTable[reg].symbol && StdAssumeTable[reg].symbol->target_type ) {
; 189  :                     psaved->symbol = StdAssumeTable[reg].symbol;
; 190  :                     ptype->type        = psaved->symbol->type;
; 191  :                     ptype->target_type = psaved->symbol->target_type;
; 192  :                     ptype->mem_type    = psaved->symbol->mem_type;
; 193  :                     ptype->ptr_memtype = psaved->symbol->ptr_memtype;
; 194  :                     ptype->is_ptr      = psaved->symbol->is_ptr;
; 195  :                 }
; 196  :         }
; 197  : #endif
; 198  :         SetStdAssumeTable( &saved_StdAssumeTable, saved_StdTypeInfo );

$LL17@AssumeInit:
	mov	rcx, QWORD PTR [rdx]
	test	rcx, rcx
	je	SHORT $LN15@AssumeInit
	mov	rax, QWORD PTR [r8-16]
	mov	QWORD PTR [rcx+80], rax
	mov	rcx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [r8-8]
	mov	QWORD PTR [rcx+48], rax
	mov	rcx, QWORD PTR [rdx]
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx+36], eax
	mov	rcx, QWORD PTR [rdx]
	movzx	eax, BYTE PTR [r8+4]
	mov	BYTE PTR [rcx+46], al
	mov	rcx, QWORD PTR [rdx]
	movzx	eax, BYTE PTR [r8+5]
	mov	BYTE PTR [rcx+45], al
$LN15@AssumeInit:
	add	rdx, 16
	add	r8, 24
	sub	r9, 1
	jne	SHORT $LL17@AssumeInit
$LN16@AssumeInit:

; 199  :     }
; 200  : #endif
; 201  : }

	ret	0
AssumeInit ENDP
_TEXT	ENDS
END
