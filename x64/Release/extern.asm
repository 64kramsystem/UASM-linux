; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG10859 DB	'ABS', 00H
$SG10975 DB	')', 00H
	ORG $+2
$SG10979 DB	'ABS', 00H
_DATA	ENDS
CONST	SEGMENT
szCOMM	DB	'COMM', 00H
CONST	ENDS
PUBLIC	MakeExtern
PUBLIC	AddPublicData
PUBLIC	FreePubQueue
PUBLIC	ExterndefDirective
PUBLIC	ProtoDirective
PUBLIC	ExternDirective
PUBLIC	CommDirective
PUBLIC	PublicDirective
EXTRN	_stricmp:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	QAddItem:PROC
EXTRN	SymCreate:PROC
EXTRN	SymFind:PROC
EXTRN	MemtypeFromSize:PROC
EXTRN	GetLangType:PROC
EXTRN	sym_add_table:PROC
EXTRN	sym_remove_table:PROC
EXTRN	SetMangler:PROC
EXTRN	EvalOperand:PROC
EXTRN	EmitConstError:PROC
EXTRN	GetQualifiedType:PROC
EXTRN	ParseProc:PROC
EXTRN	CreateProc:PROC
EXTRN	CopyPrototype:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SymTables:BYTE
EXTRN	__ImageBase:BYTE
pdata	SEGMENT
$pdata$MakeExtern DD imagerel $LN9
	DD	imagerel $LN9+123
	DD	imagerel $unwind$MakeExtern
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateExternal DD imagerel CreateExternal
	DD	imagerel CreateExternal+124
	DD	imagerel $unwind$CreateExternal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateComm DD imagerel CreateComm
	DD	imagerel CreateComm+102
	DD	imagerel $unwind$CreateComm
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateProto DD imagerel CreateProto
	DD	imagerel CreateProto+307
	DD	imagerel $unwind$CreateProto
pdata	ENDS
pdata	SEGMENT
$pdata$ExterndefDirective DD imagerel $LN74
	DD	imagerel $LN74+1069
	DD	imagerel $unwind$ExterndefDirective
$pdata$ProtoDirective DD imagerel $LN7
	DD	imagerel $LN7+113
	DD	imagerel $unwind$ProtoDirective
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HandleAltname DD imagerel HandleAltname
	DD	imagerel HandleAltname+329
	DD	imagerel $unwind$HandleAltname
pdata	ENDS
pdata	SEGMENT
$pdata$ExternDirective DD imagerel $LN72
	DD	imagerel $LN72+1214
	DD	imagerel $unwind$ExternDirective
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MakeComm DD imagerel MakeComm
	DD	imagerel MakeComm+247
	DD	imagerel $unwind$MakeComm
pdata	ENDS
pdata	SEGMENT
$pdata$CommDirective DD imagerel $LN68
	DD	imagerel $LN68+780
	DD	imagerel $unwind$CommDirective
$pdata$PublicDirective DD imagerel $LN41
	DD	imagerel $LN41+464
	DD	imagerel $unwind$PublicDirective
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MakeComm DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HandleAltname DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateProto DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0e016521aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateComm DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateExternal DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
xdata	SEGMENT
$unwind$MakeExtern DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$ExterndefDirective DD 0a2a01H
	DD	08742aH
	DD	09641cH
	DD	0103417H
	DD	0f006920dH
	DD	05002e004H
$unwind$ProtoDirective DD 010401H
	DD	04204H
$unwind$ExternDirective DD 0e2701H
	DD	08f427H
	DD	09e423H
	DD	0ad41fH
	DD	0b6418H
	DD	0133412H
	DD	0c007b20eH
	DD	050047005H
$unwind$CommDirective DD 0b1e01H
	DD	01d641eH
	DD	01b341eH
	DD	014011eH
	DD	0e010f012H
	DD	0700cc00eH
	DD	0500bH
$unwind$PublicDirective DD 071f01H
	DD	04641fH
	DD	0a340eH
	DD	070034207H
	DD	05002H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
skipitem$ = 64
i$ = 64
langtype$ = 72
tokenarray$ = 72
PublicDirective PROC

; 888  : {

$LN41:
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H

; 889  : #if MANGLERSUPP
; 890  :     char                *mangle_type = NULL;
; 891  : #endif
; 892  :     char                *token;
; 893  :     struct asym         *sym;
; 894  :     //struct dsym       *dir;
; 895  :     char                skipitem;
; 896  :     enum lang_type      langtype;
; 897  : 
; 898  :     DebugMsg1(("PublicDirective(%u) enter\n", i));
; 899  :     i++; /* skip PUBLIC directive */

	inc	ecx
	mov	QWORD PTR [rsp+80], rbx
	mov	DWORD PTR i$[rsp], ecx
	mov	rbp, rdx
	movzx	edi, BYTE PTR skipitem$[rsp]
	mov	QWORD PTR [rsp+32], rsi
	npad	1
$LL4@PublicDire:

; 900  : #if MANGLERSUPP
; 901  :     mangle_type = Check4Mangler( &i, tokenarray );
; 902  : #endif
; 903  :     do {
; 904  : 
; 905  :         /* read the optional language type */
; 906  :         langtype = ModuleInfo.langtype;

	mov	eax, DWORD PTR ModuleInfo+364

; 907  :         GetLangType( &i, tokenarray, &langtype );

	lea	r8, QWORD PTR langtype$[rsp]
	mov	rdx, rbp
	mov	DWORD PTR langtype$[rsp], eax
	lea	rcx, QWORD PTR i$[rsp]
	call	GetLangType

; 908  : 
; 909  :         if ( tokenarray[i].token != T_ID ) {

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	rax, rdx
	shl	rax, 5
	cmp	BYTE PTR [rax+rbp], 8
	jne	$LN34@PublicDire

; 911  :         }
; 912  :         /* get the symbol name */
; 913  :         token = tokenarray[i++].string_ptr;

	mov	rsi, QWORD PTR [rax+rbp+8]
	inc	edx

; 914  : 
; 915  :         DebugMsg1(("PublicDirective: sym=%s\n", token ));
; 916  : 
; 917  :         /* Add the public name */
; 918  :         sym = SymSearch( token );

	mov	rcx, rsi
	mov	DWORD PTR i$[rsp], edx
	call	SymFind

; 919  :         if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	rbx, rax
	jne	SHORT $LN8@PublicDire

; 920  :             if ( sym == NULL ) {

	test	rax, rax
	jne	SHORT $LN12@PublicDire

; 921  :                 if ( sym = SymCreate( token ) ) {

	mov	rcx, rsi
	call	SymCreate
	mov	rbx, rax
	test	rax, rax
	je	$LN11@PublicDire

; 922  :                     sym_add_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	rdx, rax
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_add_table
$LN12@PublicDire:

; 926  :             }
; 927  :             skipitem = FALSE;

	xor	dil, dil

; 928  :         } else {

	jmp	SHORT $LN13@PublicDire
$LN8@PublicDire:

; 929  :             if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rax, rax
	je	SHORT $LN14@PublicDire
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN13@PublicDire
$LN14@PublicDire:

; 930  :                 EmitErr( SYMBOL_NOT_DEFINED, token );

	mov	rdx, rsi
	mov	ecx, 103				; 00000067H
	call	EmitErr
$LN13@PublicDire:

; 931  :                 //return( ERROR ); /* v2.04: dont exit */
; 932  :             }
; 933  :         }
; 934  :         if ( sym ) {

	test	rbx, rbx
	je	$LN24@PublicDire

; 935  :             switch ( sym->state ) {

	mov	ecx, DWORD PTR [rbx+32]
	test	ecx, ecx
	je	SHORT $LN18@PublicDire
	sub	ecx, 1
	je	SHORT $LN17@PublicDire
	cmp	ecx, 1
	je	SHORT $LN19@PublicDire

; 957  :             default:
; 958  :                 EmitErr( CANNOT_DEFINE_AS_PUBLIC_OR_EXTERNAL, sym->name );

	mov	ecx, 175				; 000000afH

; 959  :                 skipitem = TRUE;

	jmp	SHORT $LN38@PublicDire
$LN19@PublicDire:

; 942  :                     //return( ERROR );
; 943  :                 }
; 944  :                 break;
; 945  :             case SYM_EXTERNAL:
; 946  :                 if ( sym->iscomm == TRUE ) {

	movzx	eax, BYTE PTR [rbx+47]
	test	al, 4
	je	SHORT $LN20@PublicDire

; 947  :                     EmitErr( CANNOT_DEFINE_AS_PUBLIC_OR_EXTERNAL, sym->name );

	mov	ecx, 175				; 000000afH

; 948  :                     skipitem = TRUE;

	jmp	SHORT $LN38@PublicDire
$LN20@PublicDire:

; 949  :                     //return( ERROR );
; 950  :                 } else if ( sym->weak == FALSE ) {

	test	al, 8
	jne	SHORT $LN18@PublicDire

; 951  :                     /* for EXTERNs, emit a different error msg */
; 952  :                     EmitErr( SYMBOL_REDEFINITION, sym->name );

	mov	ecx, 144				; 00000090H

; 953  :                     skipitem = TRUE;
; 954  :                     //return( ERROR );
; 955  :                 }
; 956  :                 break;

	jmp	SHORT $LN38@PublicDire
$LN17@PublicDire:

; 936  :             case SYM_UNDEFINED:
; 937  :                 break;
; 938  :             case SYM_INTERNAL:
; 939  :                 if ( sym->scoped == TRUE ) {

	test	BYTE PTR [rbx+40], 4
	je	SHORT $LN18@PublicDire

; 940  :                     EmitErr( CANNOT_DECLARE_SCOPED_CODE_LABEL_AS_PUBLIC, sym->name );

	mov	ecx, 181				; 000000b5H
$LN38@PublicDire:
	mov	rdx, QWORD PTR [rbx+8]
	call	EmitErr

; 941  :                     skipitem = TRUE;

	mov	dil, 1
$LN18@PublicDire:

; 960  :                 //return( ERROR );
; 961  :             }
; 962  :             if( Parse_Pass == PASS_1 && skipitem == FALSE ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN24@PublicDire
	test	dil, dil
	jne	SHORT $LN24@PublicDire

; 963  :                 if ( sym->ispublic == FALSE ) {

	movzx	eax, BYTE PTR [rbx+40]
	test	al, al
	js	SHORT $LN31@PublicDire

; 964  :                     sym->ispublic = TRUE;

	or	al, 128					; 00000080H

; 965  :                     AddPublicData( sym ); /* put it into the public table */

	lea	rcx, OFFSET FLAT:ModuleInfo+16
	mov	rdx, rbx
	mov	BYTE PTR [rbx+40], al
	call	QAddItem
$LN31@PublicDire:

; 966  :                 }
; 967  :                 SetMangler( sym, langtype, mangle_type );

	mov	edx, DWORD PTR langtype$[rsp]
	xor	r8d, r8d
	mov	rcx, rbx
	call	SetMangler
$LN24@PublicDire:

; 968  :             }
; 969  :         }
; 970  : 
; 971  :         if ( tokenarray[i].token != T_FINAL )

	movsxd	rcx, DWORD PTR i$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rax, rcx
	shl	rax, 5
	movzx	edx, BYTE PTR [rax+rbp]
	test	dl, dl
	je	SHORT $LN2@PublicDire

; 972  :             if ( tokenarray[i].token == T_COMMA ) {

	cmp	dl, 44					; 0000002cH
	jne	SHORT $LN27@PublicDire

; 973  :                 if ( (i + 1) < Token_Count )

	lea	eax, DWORD PTR [rcx+1]
	cmp	eax, r8d
	cmovl	ecx, eax
	mov	DWORD PTR i$[rsp], ecx
$LN2@PublicDire:

; 977  :             }
; 978  : 
; 979  :     } while ( i < Token_Count );

	cmp	ecx, r8d
	jl	$LL4@PublicDire

; 980  : 
; 981  :     return( NOT_ERROR );

	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+80]

; 982  : }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
$LN11@PublicDire:

; 923  :                     DebugMsg1(("PublicDirective(%s): new symbol\n", sym->name ));
; 924  :                 } else
; 925  :                     return( ERROR ); /* name was too long */

	or	eax, -1
	mov	rsi, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+80]

; 982  : }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
$LN27@PublicDire:

; 974  :                     i++;
; 975  :             } else {
; 976  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, rcx
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbp+24]
	jmp	SHORT $LN39@PublicDire
$LN34@PublicDire:

; 910  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbp+8]
$LN39@PublicDire:
	mov	ecx, 210				; 000000d2H
	call	EmitErr
	mov	rsi, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+80]

; 982  : }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
PublicDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
opndx$ = 48
i$ = 208
tokenarray$ = 216
langtype$ = 224
CommDirective PROC

; 707  : {

$LN68:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-55]
	sub	rsp, 160				; 000000a0H

; 708  :     char            *token;
; 709  : #if MANGLERSUPP
; 710  :     char            *mangle_type = NULL;
; 711  : #endif
; 712  :     bool            isfar;
; 713  :     //int             distance;
; 714  :     int             tmp;
; 715  :     uint_32         size;  /* v2.12: changed from 'int' to 'uint_32' */
; 716  :     uint_32         count; /* v2.12: changed from 'int' to 'uint_32' */
; 717  :     struct asym     *sym;
; 718  :     struct expr     opndx;
; 719  :     enum lang_type  langtype;
; 720  : 
; 721  :     DebugMsg1(("CommDirective(%u) enter\n", i));
; 722  :     i++; /* skip COMM token */

	inc	ecx
	mov	rdi, rdx

; 723  :     for( ; i < Token_Count; i++ ) {

	cmp	ecx, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rbp-105], ecx
	jge	$LN3@CommDirect
	lea	r12, OFFSET FLAT:__ImageBase
	npad	7
$LL4@CommDirect:

; 724  : #if MANGLERSUPP
; 725  :         mangle_type = Check4Mangler( &i, tokenarray );
; 726  : #endif
; 727  :         /* get the symbol language type if present */
; 728  :         langtype = ModuleInfo.langtype;

	mov	eax, DWORD PTR ModuleInfo+364

; 729  :         GetLangType( &i, tokenarray, &langtype );

	lea	r8, QWORD PTR langtype$[rbp-105]
	mov	rdx, rdi
	mov	DWORD PTR langtype$[rbp-105], eax
	lea	rcx, QWORD PTR i$[rbp-105]
	call	GetLangType

; 730  : 
; 731  :         /* get the -optional- distance ( near or far ) */
; 732  :         isfar = FALSE;
; 733  :         if ( tokenarray[i].token == T_STYPE )

	movsxd	rax, DWORD PTR i$[rbp-105]
	xor	r15b, r15b
	mov	rcx, rax
	shl	rcx, 5
	cmp	BYTE PTR [rcx+rdi], 6
	jne	SHORT $LN5@CommDirect

; 734  :             switch ( tokenarray[i].tokval ) {

	mov	ecx, DWORD PTR [rcx+rdi+16]
	add	ecx, -221				; ffffff23H
	cmp	ecx, 5
	ja	SHORT $LN5@CommDirect
	mov	edx, DWORD PTR $LN63@CommDirect[r12+rcx*4]
	add	rdx, r12
	jmp	rdx
$LN11@CommDirect:

; 735  :             case T_FAR:
; 736  :             case T_FAR16:
; 737  :             case T_FAR32:
; 738  :                 if ( ModuleInfo.model == MODEL_FLAT ) {

	cmp	DWORD PTR ModuleInfo+360, 7
	jne	SHORT $LN12@CommDirect

; 739  :                     EmitError( FAR_NOT_ALLOWED_IN_FLAT_MODEL_COMM_VARIABLES );

	mov	ecx, 177				; 000000b1H
	call	EmitError

; 740  :                 } else

	mov	eax, DWORD PTR i$[rbp-105]
	jmp	SHORT $LN13@CommDirect
$LN12@CommDirect:

; 741  :                     isfar = TRUE;

	mov	r15b, 1
$LN13@CommDirect:

; 742  :                 /* no break */
; 743  :             case T_NEAR:
; 744  :             case T_NEAR16:
; 745  :             case T_NEAR32:
; 746  :                 i++;

	inc	eax
	mov	DWORD PTR i$[rbp-105], eax
$LN5@CommDirect:

; 747  :             }
; 748  : 
; 749  :         /* v2.08: ensure token is a valid id */
; 750  :         if( tokenarray[i].token != T_ID ) {

	movsxd	rcx, eax
	shl	rcx, 5
	cmp	BYTE PTR [rcx+rdi], 8
	jne	$LN47@CommDirect

; 752  :         }
; 753  :         /* get the symbol name */
; 754  :         token = tokenarray[i++].string_ptr;

	mov	r14, QWORD PTR [rcx+rdi+8]
	inc	eax

; 755  : 
; 756  :         /* go past the colon */
; 757  :         if( tokenarray[i].token != T_COLON ) {

	movsxd	rcx, eax
	shl	rcx, 5
	mov	DWORD PTR i$[rbp-105], eax
	cmp	BYTE PTR [rcx+rdi], 58			; 0000003aH
	jne	$LN47@CommDirect

; 758  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );
; 759  :         }
; 760  :         i++;
; 761  :         /* the evaluator cannot handle a ':' so scan for one first */
; 762  :         for ( tmp = i; tmp < Token_Count;tmp++ )

	mov	edx, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR i$[rbp-105], eax
	cmp	eax, edx
	jge	SHORT $LN64@CommDirect
	movsxd	rcx, eax
	shl	rcx, 5
	add	rcx, rdi
	npad	2
$LL9@CommDirect:

; 763  :             if ( tokenarray[tmp].token == T_COLON )

	cmp	BYTE PTR [rcx], 58			; 0000003aH
	je	SHORT $LN64@CommDirect

; 758  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );
; 759  :         }
; 760  :         i++;
; 761  :         /* the evaluator cannot handle a ':' so scan for one first */
; 762  :         for ( tmp = i; tmp < Token_Count;tmp++ )

	inc	eax
	add	rcx, 32					; 00000020H
	cmp	eax, edx
	jl	SHORT $LL9@CommDirect
$LN64@CommDirect:

; 764  :                 break;
; 765  :         /* v2.10: expression evaluator isn't to accept forward references */
; 766  :         //if ( EvalOperand( &i, tokenarray, tmp, &opndx, 0 ) == ERROR )
; 767  :         if ( EvalOperand( &i, tokenarray, tmp, &opndx, EXPF_NOUNDEF ) == ERROR )

	lea	r9, QWORD PTR opndx$[rbp-105]
	mov	BYTE PTR [rsp+32], 2
	mov	r8d, eax
	lea	rcx, QWORD PTR i$[rbp-105]
	mov	rdx, rdi
	call	EvalOperand
	cmp	eax, -1
	je	$LN49@CommDirect

; 769  : 
; 770  :         /* v2.03: a string constant is accepted by Masm */
; 771  :         /* v2.11: don't accept NEAR or FAR */
; 772  :         /* v2.12: check for too large value added */
; 773  :         //if ( opndx.kind != EXPR_CONST || opndx.string != NULL ) {
; 774  :         if ( opndx.kind != EXPR_CONST )

	cmp	DWORD PTR opndx$[rbp-45], 0
	je	SHORT $LN19@CommDirect

; 775  :             EmitError( CONSTANT_EXPECTED );

	mov	ecx, 66					; 00000042H
	jmp	SHORT $LN65@CommDirect
$LN19@CommDirect:

; 776  :         else if ( ( opndx.mem_type & MT_SPECIAL_MASK) == MT_ADDRESS )

	mov	eax, DWORD PTR opndx$[rbp-41]
	and	eax, 192				; 000000c0H
	cmp	al, -128				; ffffffffffffff80H
	jne	SHORT $LN21@CommDirect

; 777  :             EmitErr( INVALID_TYPE_FOR_DATA_DECLARATION, token );

	mov	rdx, r14
	mov	ecx, 161				; 000000a1H
	call	EmitErr
	jmp	SHORT $LN25@CommDirect
$LN21@CommDirect:
	mov	eax, DWORD PTR opndx$[rbp-101]
	inc	eax
	cmp	eax, 1
	jbe	SHORT $LN23@CommDirect

; 778  :         else if ( opndx.hvalue != 0 && opndx.hvalue != -1 )
; 779  :             EmitConstError( &opndx );

	lea	rcx, QWORD PTR opndx$[rbp-105]
	call	EmitConstError
	jmp	SHORT $LN25@CommDirect
$LN23@CommDirect:

; 780  :         else if ( opndx.uvalue == 0 )

	cmp	DWORD PTR opndx$[rbp-105], 0
	jne	SHORT $LN25@CommDirect

; 781  :             EmitError( POSITIVE_VALUE_EXPECTED );

	mov	ecx, 176				; 000000b0H
$LN65@CommDirect:
	call	EmitError
$LN25@CommDirect:

; 782  : 
; 783  :         size = opndx.uvalue;
; 784  : 
; 785  :         count = 1;
; 786  :         if( tokenarray[i].token == T_COLON ) {

	movsxd	rcx, DWORD PTR i$[rbp-105]
	mov	ebx, 1
	mov	esi, DWORD PTR opndx$[rbp-105]
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 58			; 0000003aH
	jne	SHORT $LN26@CommDirect

; 787  :             i++;
; 788  :             /* get optional count argument */
; 789  :             /* v2.10: expression evaluator isn't to accept forward references */
; 790  :             //if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )
; 791  :             if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rbp-105]
	inc	ecx
	mov	BYTE PTR [rsp+32], 2
	mov	DWORD PTR i$[rbp-105], ecx
	mov	rdx, rdi
	lea	rcx, QWORD PTR i$[rbp-105]
	call	EvalOperand
	cmp	eax, -1
	je	$LN49@CommDirect

; 792  :                 return( ERROR );
; 793  : 
; 794  :             /* v2.03: a string constant is acceptable! */
; 795  :             /* v2.12: check for too large value added */
; 796  :             //if ( opndx.kind != EXPR_CONST || opndx.string != NULL ) {
; 797  :             if ( opndx.kind != EXPR_CONST )

	cmp	DWORD PTR opndx$[rbp-45], 0
	je	SHORT $LN28@CommDirect

; 798  :                 EmitError( CONSTANT_EXPECTED );

	lea	ecx, QWORD PTR [rbx+65]
	jmp	SHORT $LN66@CommDirect
$LN28@CommDirect:
	mov	eax, DWORD PTR opndx$[rbp-101]
	inc	eax
	cmp	eax, ebx
	jbe	SHORT $LN30@CommDirect

; 799  :             else if ( opndx.hvalue != 0 && opndx.hvalue != -1 )
; 800  :                 EmitConstError( &opndx );

	lea	rcx, QWORD PTR opndx$[rbp-105]
	call	EmitConstError
	jmp	SHORT $LN32@CommDirect
$LN30@CommDirect:

; 801  :             else if ( opndx.uvalue == 0 )

	cmp	DWORD PTR opndx$[rbp-105], 0
	jne	SHORT $LN32@CommDirect

; 802  :                 EmitError( POSITIVE_VALUE_EXPECTED );

	mov	ecx, 176				; 000000b0H
$LN66@CommDirect:
	call	EmitError
$LN32@CommDirect:

; 803  : 
; 804  :             count = opndx.uvalue;

	mov	ebx, DWORD PTR opndx$[rbp-105]
$LN26@CommDirect:

; 805  :         }
; 806  : 
; 807  :         sym = SymSearch( token );

	mov	rcx, r14
	call	SymFind
	mov	rcx, rax

; 808  :         if( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rax, rax
	je	SHORT $LN35@CommDirect
	mov	eax, DWORD PTR [rax+32]
	test	eax, eax
	je	SHORT $LN35@CommDirect

; 811  :                 return( ERROR );
; 812  :         } else if ( sym->state != SYM_EXTERNAL || sym->iscomm != TRUE ) {

	cmp	eax, 2
	jne	$LN39@CommDirect
	test	BYTE PTR [rcx+47], 4
	je	$LN39@CommDirect

; 816  :             if( count != sym->total_length || size != tmp ) {

	mov	r8d, DWORD PTR [rcx+64]
	cmp	ebx, r8d
	jne	SHORT $LN41@CommDirect

; 814  :         } else {
; 815  :             tmp = sym->total_size / sym->total_length;

	mov	eax, DWORD PTR [rcx+56]
	xor	edx, edx
	div	r8d

; 816  :             if( count != sym->total_length || size != tmp ) {

	cmp	esi, eax
	je	SHORT $LN36@CommDirect
$LN41@CommDirect:

; 817  :                 return( EmitErr( NON_BENIGN_XXX_REDEFINITION, szCOMM, sym->name ) );

	mov	r8, QWORD PTR [rcx+8]
	lea	rdx, OFFSET FLAT:szCOMM
	mov	ecx, 140				; 0000008cH
	call	EmitErr
	jmp	SHORT $LN1@CommDirect
$LN35@CommDirect:

; 809  :             sym = MakeComm( token, sym, size, count, isfar );

	mov	rdx, rcx
	mov	BYTE PTR [rsp+32], r15b
	mov	rcx, r14
	mov	r9d, ebx
	mov	r8d, esi
	call	MakeComm
	mov	rcx, rax

; 810  :             if ( sym == NULL )

	test	rax, rax
	je	SHORT $LN49@CommDirect
$LN36@CommDirect:

; 818  :             }
; 819  :         }
; 820  :         sym->isdefined = TRUE;

	or	BYTE PTR [rcx+40], 2

; 821  :         SetMangler( sym, langtype, mangle_type );

	xor	r8d, r8d
	mov	edx, DWORD PTR langtype$[rbp-105]
	call	SetMangler

; 822  : 
; 823  :         if ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA ) {

	movsxd	rcx, DWORD PTR i$[rbp-105]
	mov	rax, rcx
	shl	rax, 5
	movzx	edx, BYTE PTR [rax+rdi]
	test	dl, dl
	je	SHORT $LN2@CommDirect
	cmp	dl, 44					; 0000002cH
	jne	SHORT $LN53@CommDirect
$LN2@CommDirect:

; 723  :     for( ; i < Token_Count; i++ ) {

	inc	ecx
	cmp	ecx, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rbp-105], ecx
	jl	$LL4@CommDirect
$LN3@CommDirect:

; 825  :         }
; 826  :     }
; 827  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@CommDirect:

; 828  : }

	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
$LN39@CommDirect:

; 813  :             return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rcx+8]
	mov	ecx, 144				; 00000090H
	call	EmitErr
	jmp	SHORT $LN1@CommDirect
$LN53@CommDirect:

; 824  :             return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, rcx
	mov	ecx, 40					; 00000028H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+24]
	call	EmitErr
	jmp	SHORT $LN1@CommDirect
$LN49@CommDirect:

; 768  :             return( ERROR );

	or	eax, -1
	jmp	SHORT $LN1@CommDirect
$LN47@CommDirect:

; 751  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, eax
	mov	ecx, 210				; 000000d2H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+8]
	call	EmitErr
	jmp	SHORT $LN1@CommDirect
	npad	3
$LN63@CommDirect:

; 828  : }

	DD	$LN13@CommDirect
	DD	$LN11@CommDirect
	DD	$LN13@CommDirect
	DD	$LN13@CommDirect
	DD	$LN11@CommDirect
	DD	$LN11@CommDirect
CommDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
;	COMDAT MakeComm
_TEXT	SEGMENT
name$ = 48
sym$ = 56
size$ = 64
count$ = 72
isfar$ = 80
MakeComm PROC						; COMDAT

; 674  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	esi, r9d
	mov	edi, r8d
	mov	rbx, rdx

; 675  :     sym = CreateComm( sym, name );

	test	rdx, rdx
	jne	SHORT $LN9@MakeComm
	call	SymCreate
	mov	rbx, rax
	jmp	SHORT $LN10@MakeComm
$LN9@MakeComm:
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table
$LN10@MakeComm:
	test	rbx, rbx
	je	$LN13@MakeComm
	movzx	eax, BYTE PTR [rbx+47]
	mov	rdx, rbx
	mov	DWORD PTR [rbx+32], 2
	and	al, 228					; 000000e4H
	movzx	ecx, BYTE PTR ModuleInfo+404
	and	cl, 3
	or	cl, al
	or	cl, 4
	mov	BYTE PTR [rbx+47], cl
	lea	rcx, OFFSET FLAT:SymTables+16
	call	sym_add_table

; 676  :     if( sym == NULL )
; 677  :         return( NULL );
; 678  : 
; 679  :     sym->total_length = count;
; 680  :     sym->isfar = isfar;

	and	BYTE PTR [rbx+47], 239			; 000000efH
	movzx	ecx, BYTE PTR isfar$[rsp]
	movzx	eax, cl
	mov	DWORD PTR [rbx+64], esi
	and	al, 1
	shl	al, 4
	or	BYTE PTR [rbx+47], al

; 681  : 
; 682  :     /* v2.04: don't set segment if communal is far and -Zg is set */
; 683  :     if ( Options.masm_compat_gencode == FALSE || isfar == FALSE )

	cmp	BYTE PTR Options+128, 0
	je	SHORT $LN4@MakeComm
	test	cl, cl
	jne	SHORT $LN3@MakeComm
$LN4@MakeComm:

; 684  :         sym->segment = &CurrSeg->sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rbx+24], rax
$LN3@MakeComm:

; 685  : 
; 686  :     MemtypeFromSize( size, &sym->mem_type );

	lea	rdx, QWORD PTR [rbx+36]
	mov	ecx, edi
	call	MemtypeFromSize

; 687  : 
; 688  :     /* v2.04: warning added ( Masm emits an error ) */
; 689  :     /* v2.05: code active for 16-bit only */
; 690  :     if ( ModuleInfo.Ofssize == USE16 )

	cmp	BYTE PTR ModuleInfo+404, 0
	jne	SHORT $LN6@MakeComm

; 691  :         if ( ( count * size ) > 0x10000UL )

	mov	eax, edi
	imul	eax, esi
	cmp	eax, 65536				; 00010000H
	jbe	SHORT $LN6@MakeComm

; 692  :             EmitWarn( 2, COMM_VAR_EXCEEDS_64K, sym->name );

	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 268				; 0000010cH
	mov	ecx, 2
	call	EmitWarn
$LN6@MakeComm:

; 693  : 
; 694  :     sym->total_size = count * size;

	imul	edi, esi

; 695  : 
; 696  :     return( sym );

	mov	rax, rbx
	mov	DWORD PTR [rbx+56], edi

; 697  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN13@MakeComm:
	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
MakeComm ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
ti$ = 32
i$ = 128
langtype$ = 136
tokenarray$ = 136
altname$1$ = 144
ExternDirective PROC

; 499  : {

$LN72:
	mov	rax, rsp
	push	rbp
	push	rdi
	push	r12
	mov	rbp, rsp
	sub	rsp, 96					; 00000060H
	mov	QWORD PTR [rax+32], rbx

; 500  :     char                *token;
; 501  : #if MANGLERSUPP
; 502  :     char                *mangle_type = NULL;
; 503  : #endif
; 504  :     char                *altname;
; 505  :     struct asym         *sym;
; 506  :     enum lang_type      langtype;
; 507  :     struct qualified_type ti;
; 508  : 
; 509  :     DebugMsg1(("ExternDirective(%u) enter\n", i));
; 510  :     i++; /* skip EXT[E]RN token */

	inc	ecx
	mov	QWORD PTR [rax-32], rsi
	mov	r12, rdx
	mov	QWORD PTR [rax-40], r13
	mov	QWORD PTR [rax-48], r14
	mov	QWORD PTR [rax-56], r15
	mov	DWORD PTR i$[rbp-96], ecx
	npad	6
$LL4@ExternDire:

; 511  : #if MANGLERSUPP
; 512  :     mangle_type = Check4Mangler( &i, tokenarray );
; 513  : #endif
; 514  :     do {
; 515  : 
; 516  :         altname = NULL;
; 517  : 
; 518  :         /* get the symbol language type if present */
; 519  :         langtype = ModuleInfo.langtype;

	mov	eax, DWORD PTR ModuleInfo+364

; 520  :         GetLangType( &i, tokenarray, &langtype );

	lea	r8, QWORD PTR langtype$[rbp-96]
	xor	edi, edi
	mov	DWORD PTR langtype$[rbp-96], eax
	mov	rdx, r12
	mov	QWORD PTR altname$1$[rbp-96], rdi
	lea	rcx, QWORD PTR i$[rbp-96]
	call	GetLangType

; 521  : 
; 522  :         /* get the symbol name */
; 523  :         if( tokenarray[i].token != T_ID ) {

	movsxd	rcx, DWORD PTR i$[rbp-96]
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 8
	jne	$LN56@ExternDire

; 525  :         }
; 526  :         token = tokenarray[i++].string_ptr;

	mov	r13, QWORD PTR [rax+r12+8]
	inc	ecx

; 527  : 
; 528  :         /* go past the optional alternative name (weak ext, default resolution) */
; 529  :         if( tokenarray[i].token == T_OP_BRACKET ) {

	movsxd	rax, ecx
	shl	rax, 5
	mov	DWORD PTR i$[rbp-96], ecx
	cmp	BYTE PTR [rax+r12], 40			; 00000028H
	jne	SHORT $LN6@ExternDire

; 530  :             i++;

	inc	ecx

; 531  :             if ( tokenarray[i].token != T_ID ) {

	movsxd	rax, ecx
	shl	rax, 5
	mov	DWORD PTR i$[rbp-96], ecx
	cmp	BYTE PTR [rax+r12], 8
	jne	$LN58@ExternDire

; 533  :             }
; 534  :             altname = tokenarray[i].string_ptr;

	mov	rdi, QWORD PTR [rax+r12+8]

; 535  :             i++;

	inc	ecx

; 536  :             if( tokenarray[i].token != T_CL_BRACKET ) {

	movsxd	rax, ecx
	shl	rax, 5
	mov	DWORD PTR i$[rbp-96], ecx
	mov	QWORD PTR altname$1$[rbp-96], rdi
	cmp	BYTE PTR [rax+r12], 41			; 00000029H
	jne	$LN59@ExternDire

; 538  :             }
; 539  :             i++;

	inc	ecx
	mov	DWORD PTR i$[rbp-96], ecx
$LN6@ExternDire:

; 540  :         }
; 541  : 
; 542  :         /* go past the colon */
; 543  :         if( tokenarray[i].token != T_COLON ) {

	movsxd	rax, ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 58			; 0000003aH
	jne	$LN60@ExternDire

; 545  :         }
; 546  :         i++;

	inc	ecx
	mov	DWORD PTR i$[rbp-96], ecx

; 547  :         sym = SymSearch( token );

	mov	rcx, r13
	call	SymFind

; 548  : 
; 549  :         ti.mem_type = MT_EMPTY;
; 550  :         ti.size = 0;
; 551  :         ti.is_ptr = 0;
; 552  :         ti.is_far = FALSE;
; 553  :         ti.ptr_memtype = MT_EMPTY;
; 554  :         ti.symtype = NULL;
; 555  :         ti.Ofssize = ModuleInfo.Ofssize;

	movzx	ecx, BYTE PTR ModuleInfo+404
	mov	esi, 192				; 000000c0H

; 556  : 
; 557  :         if ( tokenarray[i].token == T_ID && ( 0 == _stricmp( tokenarray[i].string_ptr, "ABS" ) ) ) {

	movsxd	r9, DWORD PTR i$[rbp-96]
	xor	edx, edx
	mov	BYTE PTR ti$[rbp-74], cl
	xor	r8b, r8b
	mov	rcx, r9
	mov	DWORD PTR ti$[rbp-80], esi
	shl	rcx, 5
	mov	rbx, rax
	mov	DWORD PTR ti$[rbp-96], 0
	mov	WORD PTR ti$[rbp-76], 0
	mov	DWORD PTR ti$[rbp-72], esi
	mov	QWORD PTR ti$[rbp-88], rdx
	cmp	BYTE PTR [rcx+r12], 8
	jne	SHORT $LN10@ExternDire
	mov	rcx, QWORD PTR [rcx+r12+8]
	lea	rdx, OFFSET FLAT:$SG10979
	call	_stricmp

; 558  :             //ti.mem_type = MT_ABS;
; 559  :             i++;

	movzx	r8d, BYTE PTR ti$[rbp-76]
	mov	esi, DWORD PTR ti$[rbp-80]
	mov	rdx, QWORD PTR ti$[rbp-88]
	test	eax, eax
	jne	SHORT $LN68@ExternDire
	inc	DWORD PTR i$[rbp-96]
	jmp	SHORT $LN18@ExternDire
$LN68@ExternDire:
	mov	r9d, DWORD PTR i$[rbp-96]
$LN10@ExternDire:

; 560  :         } else if ( tokenarray[i].token == T_DIRECTIVE && tokenarray[i].tokval == T_PROTO ) {

	movsxd	rax, r9d
	shl	rax, 5
	lea	rcx, QWORD PTR [rax+r12]
	movzx	eax, BYTE PTR [rax+r12]
	cmp	al, 3
	jne	SHORT $LN12@ExternDire
	cmp	DWORD PTR [rcx+16], 427			; 000001abH
	je	$LN61@ExternDire
$LN12@ExternDire:

; 573  :             }
; 574  :         } else if ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA ) {

	test	al, al
	je	SHORT $LN18@ExternDire
	cmp	al, 44					; 0000002cH
	je	SHORT $LN18@ExternDire

; 575  :             if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rbp-96]
	mov	rdx, r12
	lea	rcx, QWORD PTR i$[rbp-96]
	call	GetQualifiedType
	cmp	eax, -1
	je	$LN62@ExternDire
	movzx	r8d, BYTE PTR ti$[rbp-76]
	mov	esi, DWORD PTR ti$[rbp-80]
	mov	rdx, QWORD PTR ti$[rbp-88]
$LN18@ExternDire:

; 576  :                 return( ERROR );
; 577  :         }
; 578  : 
; 579  :         DebugMsg1(("ExternDirective(%s): mem_type=%Xh\n", token, ti.mem_type ));
; 580  : 
; 581  :         if( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rbx, rbx
	je	$LN21@ExternDire
	mov	eax, DWORD PTR [rbx+32]
	test	eax, eax
	je	$LN21@ExternDire

; 599  :                 DebugMsg1(("ExternDirective(%s): prototype copied, memtype=%X\n", token, ti.mem_type ));
; 600  :             }
; 601  : 
; 602  :         } else {
; 603  : #if MASM_EXTCOND
; 604  :             /* allow internal AND external definitions for equates */
; 605  :             //if ( sym->state == SYM_INTERNAL && sym->mem_type == MT_ABS )
; 606  :             if ( sym->state == SYM_INTERNAL && sym->mem_type == MT_EMPTY )

	cmp	eax, 1
	jne	SHORT $LN24@ExternDire
	cmp	DWORD PTR [rbx+36], 192			; 000000c0H
	je	SHORT $LN26@ExternDire
$LN24@ExternDire:

; 607  :                 ;
; 608  :             else
; 609  : #endif
; 610  :             if ( sym->state != SYM_EXTERNAL ) {

	cmp	eax, 2
	jne	$LN63@ExternDire
$LN26@ExternDire:

; 613  :             }
; 614  :             /* v2.05: added to accept type prototypes */
; 615  :             if ( ti.is_ptr == 0 && ti.symtype && ti.symtype->isproc ) {

	test	r8b, r8b
	jne	SHORT $LN27@ExternDire
	test	rdx, rdx
	je	SHORT $LN27@ExternDire
	test	BYTE PTR [rdx+41], 8
	je	SHORT $LN27@ExternDire

; 616  :                 ti.mem_type = ti.symtype->mem_type;

	mov	esi, DWORD PTR [rdx+36]

; 617  :                 ti.symtype = NULL;

	xor	edx, edx
	mov	QWORD PTR ti$[rbp-88], rdx
	mov	DWORD PTR ti$[rbp-80], esi
$LN27@ExternDire:

; 618  :             }
; 619  : 
; 620  :             if( sym->mem_type != ti.mem_type ||
; 621  :                sym->is_ptr != ti.is_ptr ||
; 622  :                sym->isfar != ti.is_far ||
; 623  :                ( sym->is_ptr && sym->ptr_memtype != ti.ptr_memtype ) ||
; 624  :                ((sym->mem_type == MT_TYPE) ? sym->type : sym->target_type) != ti.symtype ||

	mov	r9d, DWORD PTR [rbx+36]
	cmp	r9d, esi
	jne	SHORT $LN29@ExternDire
	movzx	ecx, BYTE PTR [rbx+45]
	cmp	cl, r8b
	jne	SHORT $LN29@ExternDire
	movzx	eax, BYTE PTR [rbx+47]
	shr	al, 4
	and	al, 1
	cmp	al, BYTE PTR ti$[rbp-75]
	jne	SHORT $LN29@ExternDire
	test	cl, cl
	je	SHORT $LN30@ExternDire
	movzx	eax, BYTE PTR [rbx+46]
	cmp	eax, DWORD PTR ti$[rbp-72]
	jne	SHORT $LN29@ExternDire
$LN30@ExternDire:
	cmp	r9d, 196				; 000000c4H
	jne	SHORT $LN41@ExternDire
	mov	rax, QWORD PTR [rbx+80]
	jmp	SHORT $LN42@ExternDire
$LN41@ExternDire:
	mov	rax, QWORD PTR [rbx+48]
$LN42@ExternDire:
	cmp	rax, rdx
	jne	SHORT $LN29@ExternDire
	mov	eax, DWORD PTR langtype$[rbp-96]
	test	eax, eax
	je	$LN23@ExternDire
	mov	ecx, DWORD PTR [rbx+76]
	test	ecx, ecx
	je	$LN23@ExternDire
	cmp	ecx, eax
	je	$LN23@ExternDire
$LN29@ExternDire:

; 625  :                ( langtype != LANG_NONE && sym->langtype != LANG_NONE && sym->langtype != langtype )) {
; 626  :                 DebugMsg(("ExternDirective: memtype:%X-%X ptr=%X-%X far=%X-%X ptr_memtype=%X-%X lang=%u-%u\n",
; 627  :                           sym->mem_type, ti.mem_type,
; 628  :                           sym->is_ptr, ti.is_ptr,
; 629  :                           sym->isfar, ti.is_far,
; 630  :                           sym->ptr_memtype, ti.ptr_memtype,
; 631  :                           sym->langtype, langtype
; 632  :                          ));
; 633  :                 return( EmitErr( SYMBOL_TYPE_CONFLICT, token ) );

	mov	rdx, r13
	mov	ecx, 137				; 00000089H
	jmp	$LN69@ExternDire
$LN21@ExternDire:

; 582  :             /* v2.04: emit the error at the PUBLIC directive */
; 583  :             //if ( sym && sym->public == TRUE ) {
; 584  :             //    EmitErr( CANNOT_DEFINE_AS_PUBLIC_OR_EXTERNAL, sym->name );
; 585  :             //    return( ERROR );
; 586  :             //}
; 587  :             if(( sym = MakeExtern( token, ti.mem_type,
; 588  :                                   ti.mem_type == MT_TYPE ? ti.symtype : NULL, sym,
; 589  :                                   ti.is_ptr ? ModuleInfo.Ofssize : ti.Ofssize )) == NULL )

	movzx	r14d, BYTE PTR ModuleInfo+404
	test	r8b, r8b
	jne	SHORT $LN40@ExternDire
	movzx	r14d, BYTE PTR ti$[rbp-74]
$LN40@ExternDire:
	xor	r15d, r15d
	mov	rdi, rbx
	cmp	esi, 196				; 000000c4H
	cmove	r15, rdx
	test	rbx, rbx
	jne	SHORT $LN51@ExternDire
	mov	rcx, r13
	call	SymCreate
	mov	rdi, rax
	jmp	SHORT $LN52@ExternDire
$LN51@ExternDire:
	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table
$LN52@ExternDire:
	test	rdi, rdi
	je	$LN62@ExternDire
	movzx	ecx, BYTE PTR [rdi+47]
	mov	rdx, rdi
	and	cl, 240					; 000000f0H
	mov	DWORD PTR [rdi+32], 2
	movzx	eax, BYTE PTR ModuleInfo+404
	and	al, 3
	or	cl, al
	mov	BYTE PTR [rdi+47], cl
	lea	rcx, OFFSET FLAT:SymTables+16
	call	sym_add_table
	cmp	esi, 192				; 000000c0H
	je	SHORT $LN47@ExternDire
	cmp	BYTE PTR Options+128, 0
	je	SHORT $LN48@ExternDire
	cmp	esi, 130				; 00000082H
	je	SHORT $LN47@ExternDire
$LN48@ExternDire:
	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rdi+24], rax
$LN47@ExternDire:
	and	BYTE PTR [rdi+47], 252			; 000000fcH
	and	r14b, 3
	or	BYTE PTR [rdi+47], r14b
	mov	rbx, rdi
	or	BYTE PTR [rdi+40], 2
	mov	DWORD PTR [rdi+36], esi
	mov	QWORD PTR [rdi+80], r15

; 590  :                 return( ERROR );
; 591  : 
; 592  :             /* v2.05: added to accept type prototypes */
; 593  :             if ( ti.is_ptr == 0 && ti.symtype && ti.symtype->isproc ) {

	cmp	BYTE PTR ti$[rbp-76], 0
	jne	SHORT $LN23@ExternDire
	mov	rax, QWORD PTR ti$[rbp-88]
	test	rax, rax
	je	SHORT $LN23@ExternDire
	test	BYTE PTR [rax+41], 8
	je	SHORT $LN23@ExternDire

; 594  :                 CreateProc( sym, NULL, SYM_EXTERNAL );

	xor	edx, edx
	mov	rcx, rdi
	lea	r8d, QWORD PTR [rdx+2]
	call	CreateProc

; 595  :                 sym->weak = FALSE; /* v2.09: reset the weak bit that has been set inside CreateProc() */

	and	BYTE PTR [rdi+47], 247			; 000000f7H

; 596  :                 CopyPrototype( (struct dsym *)sym, (struct dsym *)ti.symtype );

	mov	rcx, rdi
	mov	rdx, QWORD PTR ti$[rbp-88]
	call	CopyPrototype

; 597  :                 ti.mem_type = ti.symtype->mem_type;

	mov	rax, QWORD PTR ti$[rbp-88]
	mov	ecx, DWORD PTR [rax+36]
	mov	DWORD PTR ti$[rbp-80], ecx

; 598  :                 ti.symtype = NULL;

	mov	QWORD PTR ti$[rbp-88], 0
$LN23@ExternDire:

; 634  :             }
; 635  :         }
; 636  : 
; 637  :         sym->isdefined = TRUE;

	or	BYTE PTR [rbx+40], 2

; 638  :         sym->Ofssize = ti.Ofssize;

	movzx	eax, BYTE PTR ti$[rbp-74]
	mov	BYTE PTR [rbx+44], al

; 639  : 
; 640  :         if ( ti.is_ptr == 0 && ti.Ofssize != ModuleInfo.Ofssize ) {

	cmp	BYTE PTR ti$[rbp-76], 0
	jne	SHORT $LN32@ExternDire
	movzx	ecx, BYTE PTR ti$[rbp-74]
	cmp	cl, BYTE PTR ModuleInfo+404
	je	SHORT $LN32@ExternDire

; 641  :             sym->seg_ofssize = ti.Ofssize;

	movzx	eax, BYTE PTR [rbx+47]
	xor	al, cl
	and	al, 3
	xor	BYTE PTR [rbx+47], al

; 642  :             if ( sym->segment && ((struct dsym *)sym->segment)->e.seginfo->Ofssize != sym->seg_ofssize )

	mov	rax, QWORD PTR [rbx+24]
	movzx	ecx, BYTE PTR [rbx+47]
	test	rax, rax
	je	SHORT $LN32@ExternDire
	mov	rax, QWORD PTR [rax+96]
	and	cl, 3
	cmp	BYTE PTR [rax+104], cl
	je	SHORT $LN32@ExternDire

; 643  :                 sym->segment = NULL;

	mov	QWORD PTR [rbx+24], 0
$LN32@ExternDire:

; 644  :         }
; 645  : 
; 646  :         sym->mem_type = ti.mem_type;

	mov	eax, DWORD PTR ti$[rbp-80]
	mov	DWORD PTR [rbx+36], eax

; 647  :         sym->is_ptr = ti.is_ptr;

	movzx	eax, BYTE PTR ti$[rbp-76]
	mov	BYTE PTR [rbx+45], al

; 648  :         sym->isfar = ti.is_far;

	movzx	eax, BYTE PTR ti$[rbp-75]
	shl	al, 4
	xor	al, BYTE PTR [rbx+47]
	and	al, 16
	xor	BYTE PTR [rbx+47], al

; 649  :         sym->ptr_memtype = ti.ptr_memtype;

	movzx	eax, BYTE PTR ti$[rbp-72]
	mov	BYTE PTR [rbx+46], al

; 650  :         if ( ti.mem_type == MT_TYPE )

	cmp	DWORD PTR ti$[rbp-80], 196		; 000000c4H

; 651  :             sym->type = ti.symtype;

	mov	rax, QWORD PTR ti$[rbp-88]
	jne	SHORT $LN33@ExternDire
	mov	QWORD PTR [rbx+80], rax
	jmp	SHORT $LN34@ExternDire
$LN33@ExternDire:

; 652  :         else
; 653  :             sym->target_type = ti.symtype;

	mov	QWORD PTR [rbx+48], rax
$LN34@ExternDire:

; 654  : 
; 655  :         HandleAltname( altname, sym );

	mov	rcx, QWORD PTR altname$1$[rbp-96]
	mov	rdx, rbx
	call	HandleAltname

; 656  : 
; 657  :         SetMangler( sym, langtype, mangle_type );

	mov	edx, DWORD PTR langtype$[rbp-96]
	xor	r8d, r8d
	mov	rcx, rbx
	call	SetMangler

; 658  : 
; 659  :         if ( tokenarray[i].token != T_FINAL )

	movsxd	rcx, DWORD PTR i$[rbp-96]
	mov	edx, DWORD PTR ModuleInfo+496
	mov	rax, rcx
	shl	rax, 5
	movzx	r8d, BYTE PTR [rax+r12]
	test	r8b, r8b
	je	SHORT $LN2@ExternDire

; 660  :             if ( tokenarray[i].token == T_COMMA &&  ( (i + 1) < Token_Count ) ) {

	cmp	r8b, 44					; 0000002cH
	jne	$LN56@ExternDire
	lea	eax, DWORD PTR [rcx+1]
	cmp	eax, edx
	jge	SHORT $LN56@ExternDire

; 661  :                 i++;

	mov	ecx, eax
	mov	DWORD PTR i$[rbp-96], eax
$LN2@ExternDire:

; 662  :             } else {
; 663  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );
; 664  :             }
; 665  :     }  while ( i < Token_Count );

	cmp	ecx, edx
	jl	$LL4@ExternDire

; 666  : 
; 667  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@ExternDire
$LN59@ExternDire:

; 537  :                 return( EmitErr( EXPECTED, ")" ) );

	lea	rdx, OFFSET FLAT:$SG10975
	mov	ecx, 231				; 000000e7H
	jmp	SHORT $LN69@ExternDire
$LN58@ExternDire:

; 532  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	jmp	SHORT $LN70@ExternDire
$LN61@ExternDire:

; 561  :             /* dont scan this line further */
; 562  :             /* CreateProto() will define a SYM_EXTERNAL */
; 563  :             sym = CreateProto( i + 1, tokenarray, token, langtype );

	lea	ecx, DWORD PTR [r9+1]
	mov	r8, r13
	mov	r9d, DWORD PTR langtype$[rbp-96]
	mov	rdx, r12
	call	CreateProto

; 564  :             DebugMsg1(("ExternDirective(%s): CreateProto()=%X\n", token, sym));
; 565  :             if ( sym == NULL )

	test	rax, rax
	jne	SHORT $LN14@ExternDire
$LN62@ExternDire:

; 566  :                 return( ERROR );

	or	eax, -1
	jmp	SHORT $LN1@ExternDire
$LN14@ExternDire:

; 567  :             if ( sym->state == SYM_EXTERNAL ) {

	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN15@ExternDire

; 568  :                 sym->weak = FALSE;

	and	BYTE PTR [rax+47], 247			; 000000f7H

; 569  :                 return( HandleAltname( altname, sym ) );

	mov	rdx, rax
	mov	rcx, rdi
	call	HandleAltname
	jmp	SHORT $LN1@ExternDire
$LN15@ExternDire:

; 570  :             } else {
; 571  :                 /* unlike EXTERNDEF, EXTERN doesn't allow a PROC for the same name */
; 572  :                 return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 144				; 00000090H
	jmp	SHORT $LN69@ExternDire
$LN63@ExternDire:

; 611  :                 DebugMsg(("ExternDirective: symbol %s redefinition, state=%u\n", token, sym->state ));
; 612  :                 return( EmitErr( SYMBOL_REDEFINITION, token ) );

	mov	rdx, r13
	mov	ecx, 144				; 00000090H
	jmp	SHORT $LN69@ExternDire
$LN60@ExternDire:

; 544  :             return( EmitError( COLON_EXPECTED ) );

	mov	ecx, 85					; 00000055H
	call	EmitError
	jmp	SHORT $LN1@ExternDire
$LN56@ExternDire:

; 524  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, rcx
$LN70@ExternDire:
	shl	rdx, 5
	mov	ecx, 210				; 000000d2H
	mov	rdx, QWORD PTR [rdx+r12+8]
$LN69@ExternDire:
	call	EmitErr
$LN1@ExternDire:
	mov	r15, QWORD PTR [rsp+64]
	mov	r14, QWORD PTR [rsp+72]
	mov	r13, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+152]

; 668  : }

	add	rsp, 96					; 00000060H
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
ExternDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
;	COMDAT HandleAltname
_TEXT	SEGMENT
altname$ = 48
sym$ = 56
HandleAltname PROC					; COMDAT

; 425  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rdi, rcx

; 426  :     struct asym *symalt;
; 427  : 
; 428  :     if ( altname && sym->state == SYM_EXTERNAL ) {

	test	rcx, rcx
	je	$LN18@HandleAltn
	cmp	DWORD PTR [rdx+32], 2
	jne	$LN18@HandleAltn

; 429  : 
; 430  :         symalt = SymSearch( altname );

	call	SymFind
	mov	rbx, rax

; 431  : 
; 432  :         /* altname symbol changed? */
; 433  :         if ( sym->altname && sym->altname != symalt ) {

	mov	rax, QWORD PTR [rsi+64]
	test	rax, rax
	je	SHORT $LN3@HandleAltn
	cmp	rax, rbx
	je	SHORT $LN3@HandleAltn

; 434  :             return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rsi+8]
	mov	ecx, 144				; 00000090H

; 493  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 434  :             return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	jmp	EmitErr
$LN3@HandleAltn:

; 435  :         }
; 436  : 
; 437  :         if ( Parse_Pass > PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN4@HandleAltn

; 438  :             if ( symalt->state == SYM_UNDEFINED ) {

	mov	ecx, DWORD PTR [rbx+32]
	test	ecx, ecx
	jne	SHORT $LN6@HandleAltn

; 439  :                 EmitErr( SYMBOL_NOT_DEFINED, altname );

	mov	rdx, rdi
	mov	ecx, 103				; 00000067H
	call	EmitErr

; 479  : #if 0 /* v2.11: removed. Member nextext wasn't free to use */
; 480  :                 DebugMsg1(("HandleAltname: symbol '%s' added to AltQueue\n", sym->name ));
; 481  :                 ((struct dsym *)sym)->nextext = NULL;
; 482  :                 if ( ModuleInfo.g.AltQueue.head == NULL )
; 483  :                     ModuleInfo.g.AltQueue.head = ModuleInfo.g.AltQueue.tail = (struct dsym *)sym;
; 484  :                 else {
; 485  :                     ((struct dsym *)ModuleInfo.g.AltQueue.tail)->nextext = (struct dsym *)sym;
; 486  :                     ModuleInfo.g.AltQueue.tail = (struct dsym *)sym;
; 487  :                 }
; 488  : #endif
; 489  :             }
; 490  :         }
; 491  :     }
; 492  :     return( NOT_ERROR );

	xor	eax, eax

; 493  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@HandleAltn:
	lea	eax, DWORD PTR [rcx-1]
	cmp	eax, 1

; 440  :             } else if (symalt->state != SYM_INTERNAL && symalt->state != SYM_EXTERNAL ) {
; 441  :                 EmitErr( SYMBOL_TYPE_CONFLICT, altname );
; 442  :             } else {

	ja	SHORT $LN23@HandleAltn

; 443  : #if COFF_SUPPORT || ELF_SUPPORT
; 444  :                 if ( symalt->state == SYM_INTERNAL && symalt->ispublic == FALSE )

	cmp	ecx, 1
	jne	SHORT $LN11@HandleAltn
	test	BYTE PTR [rbx+40], 128			; 00000080H
	jne	SHORT $LN11@HandleAltn
	mov	eax, DWORD PTR Options+144
	add	eax, -2					; fffffffeH
	cmp	eax, ecx
	ja	SHORT $LN11@HandleAltn

; 445  :                     if ( Options.output_format == OFORMAT_COFF
; 446  : #if ELF_SUPPORT
; 447  :                         || Options.output_format == OFORMAT_ELF
; 448  : #endif
; 449  :                        ) {
; 450  :                         EmitErr( MUST_BE_PUBLIC_OR_EXTERNAL, altname );

	mov	rdx, rdi
	mov	ecx, 269				; 0000010dH
	call	EmitErr
$LN11@HandleAltn:

; 451  :                     }
; 452  : #endif
; 453  :                 if ( sym->mem_type != symalt->mem_type )

	mov	eax, DWORD PTR [rbx+36]
	cmp	DWORD PTR [rsi+36], eax
	je	SHORT $LN18@HandleAltn
$LN23@HandleAltn:

; 454  :                     EmitErr( SYMBOL_TYPE_CONFLICT, altname );

	mov	rdx, rdi
	mov	ecx, 137				; 00000089H
	call	EmitErr

; 479  : #if 0 /* v2.11: removed. Member nextext wasn't free to use */
; 480  :                 DebugMsg1(("HandleAltname: symbol '%s' added to AltQueue\n", sym->name ));
; 481  :                 ((struct dsym *)sym)->nextext = NULL;
; 482  :                 if ( ModuleInfo.g.AltQueue.head == NULL )
; 483  :                     ModuleInfo.g.AltQueue.head = ModuleInfo.g.AltQueue.tail = (struct dsym *)sym;
; 484  :                 else {
; 485  :                     ((struct dsym *)ModuleInfo.g.AltQueue.tail)->nextext = (struct dsym *)sym;
; 486  :                     ModuleInfo.g.AltQueue.tail = (struct dsym *)sym;
; 487  :                 }
; 488  : #endif
; 489  :             }
; 490  :         }
; 491  :     }
; 492  :     return( NOT_ERROR );

	xor	eax, eax

; 493  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@HandleAltn:

; 455  :             }
; 456  :         } else {
; 457  : 
; 458  :             if ( symalt ) {

	test	rbx, rbx
	je	SHORT $LN14@HandleAltn
	cmp	DWORD PTR [rbx+32], 2
	jbe	SHORT $LN15@HandleAltn

; 459  :                 DebugMsg(("HandleAltname: symbol '%s' found, state=%u\n", altname, symalt->state ));
; 460  :                 if ( symalt->state != SYM_INTERNAL &&
; 461  :                     symalt->state != SYM_EXTERNAL &&
; 462  :                     symalt->state != SYM_UNDEFINED ) {
; 463  :                     return( EmitErr( SYMBOL_TYPE_CONFLICT, altname ) );

	mov	rdx, rdi
	mov	ecx, 137				; 00000089H

; 493  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 459  :                 DebugMsg(("HandleAltname: symbol '%s' found, state=%u\n", altname, symalt->state ));
; 460  :                 if ( symalt->state != SYM_INTERNAL &&
; 461  :                     symalt->state != SYM_EXTERNAL &&
; 462  :                     symalt->state != SYM_UNDEFINED ) {
; 463  :                     return( EmitErr( SYMBOL_TYPE_CONFLICT, altname ) );

	jmp	EmitErr
$LN14@HandleAltn:

; 464  :                 }
; 465  :             } else {
; 466  :                 symalt = SymCreate( altname );

	mov	rcx, rdi
	call	SymCreate

; 467  :                 sym_add_table( &SymTables[TAB_UNDEF], (struct dsym *)symalt );

	mov	rdx, rax
	lea	rcx, OFFSET FLAT:SymTables
	mov	rbx, rax
	call	sym_add_table
$LN15@HandleAltn:

; 468  :             }
; 469  :             /* make sure the alt symbol becomes strong if it is an external
; 470  :              * v2.11: don't do this for OMF ( maybe neither for COFF/ELF? )
; 471  :              */
; 472  :             if ( Options.output_format != OFORMAT_OMF )

	cmp	DWORD PTR Options+144, 1
	je	SHORT $LN17@HandleAltn

; 473  :                 symalt->used = TRUE;

	or	BYTE PTR [rbx+40], 1
$LN17@HandleAltn:

; 474  :             /* symbol inserted in the "weak external" queue?
; 475  :              * currently needed for OMF only.
; 476  :              */
; 477  :             if ( sym->altname == NULL ) {

	cmp	QWORD PTR [rsi+64], 0
	jne	SHORT $LN18@HandleAltn

; 478  :                 sym->altname = symalt;

	mov	QWORD PTR [rsi+64], rbx
$LN18@HandleAltn:

; 493  : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
HandleAltname ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
ProtoDirective PROC

; 380  : {

$LN7:
	sub	rsp, 40					; 00000028H

; 381  :     if( Parse_Pass != PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	rax, rdx
	je	SHORT $LN2@ProtoDirec

; 382  :         struct asym *sym;
; 383  :         /* v2.04: set the "defined" flag */
; 384  :         if ( ( sym = SymSearch( tokenarray[0].string_ptr ) ) && sym->isproc == TRUE )

	mov	rcx, QWORD PTR [rdx+8]
	call	SymFind
	test	rax, rax
	je	SHORT $LN3@ProtoDirec
	test	BYTE PTR [rax+41], 8
	je	SHORT $LN3@ProtoDirec

; 385  :             sym->isdefined = TRUE;

	or	BYTE PTR [rax+40], 2
$LN3@ProtoDirec:

; 386  :         return( NOT_ERROR );

	xor	eax, eax

; 393  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@ProtoDirec:

; 387  :     }
; 388  :     if( i != 1 ) {

	cmp	ecx, 1
	je	SHORT $LN4@ProtoDirec

; 389  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 210				; 000000d2H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rax+8]

; 393  : }

	add	rsp, 40					; 00000028H

; 389  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jmp	EmitErr
$LN4@ProtoDirec:

; 390  :     }
; 391  : 
; 392  :     return( CreateProto( 2, tokenarray, tokenarray[0].string_ptr, ModuleInfo.langtype ) ? NOT_ERROR : ERROR );

	mov	r9d, DWORD PTR ModuleInfo+364
	mov	ecx, 2
	mov	r8, QWORD PTR [rdx+8]
	call	CreateProto
	neg	rax
	sbb	eax, eax
	neg	eax
	dec	eax

; 393  : }

	add	rsp, 40					; 00000028H
	ret	0
ProtoDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
ti$ = 32
i$ = 112
langtype$ = 120
tokenarray$ = 120
ExterndefDirective PROC

; 183  : {

$LN74:
	push	rbp
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 80					; 00000050H

; 184  :     char                *token;
; 185  : #if MANGLERSUPP
; 186  :     char                *mangle_type = NULL;
; 187  : #endif
; 188  :     struct asym         *sym;
; 189  :     enum lang_type      langtype;
; 190  :     char isnew;
; 191  :     struct qualified_type ti;
; 192  : 
; 193  :     DebugMsg1(("ExterndefDirective(%u) enter\n", i));
; 194  : 
; 195  :     i++; /* skip EXTERNDEF token */

	inc	ecx
	mov	QWORD PTR [rsp+128], rbx
	mov	QWORD PTR [rsp+72], rsi
	xor	r15d, r15d
	mov	DWORD PTR i$[rbp-80], ecx
	mov	r14, rdx
	mov	QWORD PTR [rsp+64], rdi
	npad	6
$LL4@ExterndefD:

; 196  : #if MANGLERSUPP
; 197  :     mangle_type = Check4Mangler( &i, tokenarray );
; 198  : #endif
; 199  :     do {
; 200  : 
; 201  :         ti.Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404

; 202  : 
; 203  :         /* get the symbol language type if present */
; 204  :         langtype = ModuleInfo.langtype;
; 205  :         GetLangType( &i, tokenarray, &langtype );

	lea	r8, QWORD PTR langtype$[rbp-80]
	mov	BYTE PTR ti$[rbp-58], al
	lea	rcx, QWORD PTR i$[rbp-80]
	mov	eax, DWORD PTR ModuleInfo+364
	mov	rdx, r14
	mov	DWORD PTR langtype$[rbp-80], eax
	call	GetLangType

; 206  : 
; 207  :         /* get the symbol name */
; 208  :         if( tokenarray[i].token != T_ID ) {

	movsxd	rcx, DWORD PTR i$[rbp-80]
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+r14], 8
	jne	$LN55@ExterndefD

; 210  :         }
; 211  :         token = tokenarray[i++].string_ptr;

	mov	rsi, QWORD PTR [rax+r14+8]
	inc	ecx

; 212  : 
; 213  :         /* go past the colon */
; 214  :         if( tokenarray[i].token != T_COLON ) {

	movsxd	rax, ecx
	shl	rax, 5
	mov	DWORD PTR i$[rbp-80], ecx
	cmp	BYTE PTR [rax+r14], 58			; 0000003aH
	jne	$LN57@ExterndefD

; 216  :         }
; 217  :         i++;

	inc	ecx
	mov	DWORD PTR i$[rbp-80], ecx

; 218  :         sym = SymSearch( token );

	mov	rcx, rsi
	call	SymFind

; 219  : 
; 220  :         //typetoken = tokenarray[i].string_ptr;
; 221  :         ti.mem_type = MT_EMPTY;
; 222  :         ti.size = 0;
; 223  :         ti.is_ptr = 0;
; 224  :         ti.is_far = FALSE;
; 225  :         ti.ptr_memtype = MT_EMPTY;
; 226  :         ti.symtype = NULL;
; 227  :         ti.Ofssize = ModuleInfo.Ofssize;

	movzx	ecx, BYTE PTR ModuleInfo+404
	mov	rdx, r15

; 228  : 
; 229  :         if ( tokenarray[i].token == T_ID && ( 0 == _stricmp( tokenarray[i].string_ptr, "ABS" ) ) ) {

	movsxd	r8, DWORD PTR i$[rbp-80]
	mov	rdi, rax
	mov	BYTE PTR ti$[rbp-58], cl
	mov	rcx, r8
	shl	rcx, 5
	mov	DWORD PTR ti$[rbp-64], 192		; 000000c0H
	mov	DWORD PTR ti$[rbp-80], r15d
	mov	WORD PTR ti$[rbp-60], r15w
	mov	DWORD PTR ti$[rbp-56], 192		; 000000c0H
	mov	QWORD PTR ti$[rbp-72], rdx
	cmp	BYTE PTR [rcx+r14], 8
	jne	SHORT $LN13@ExterndefD
	mov	rcx, QWORD PTR [rcx+r14+8]
	lea	rdx, OFFSET FLAT:$SG10859
	call	_stricmp

; 230  :             /* v2.07: MT_ABS is obsolete */
; 231  :             //ti.mem_type = MT_ABS;
; 232  :             i++;

	mov	rdx, QWORD PTR ti$[rbp-72]
	test	eax, eax
	jne	SHORT $LN69@ExterndefD
	inc	DWORD PTR i$[rbp-80]
	jmp	SHORT $LN18@ExterndefD
$LN69@ExterndefD:
	mov	r8d, DWORD PTR i$[rbp-80]
$LN13@ExterndefD:

; 233  :         } else if ( tokenarray[i].token == T_DIRECTIVE && tokenarray[i].tokval == T_PROTO ) {

	movsxd	rax, r8d
	shl	rax, 5
	lea	rcx, QWORD PTR [rax+r14]
	movzx	eax, BYTE PTR [rax+r14]
	cmp	al, 3
	jne	SHORT $LN15@ExterndefD
	cmp	DWORD PTR [rcx+16], 427			; 000001abH
	je	$LN58@ExterndefD
$LN15@ExterndefD:

; 246  :         } else if ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA ) {

	test	al, al
	je	SHORT $LN18@ExterndefD
	cmp	al, 44					; 0000002cH
	je	SHORT $LN18@ExterndefD

; 247  :             if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rbp-80]
	mov	rdx, r14
	lea	rcx, QWORD PTR i$[rbp-80]
	call	GetQualifiedType
	cmp	eax, -1
	je	$LN59@ExterndefD
	mov	rdx, QWORD PTR ti$[rbp-72]
$LN18@ExterndefD:

; 249  :         }
; 250  : 
; 251  :         isnew = FALSE;
; 252  :         if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rdi, rdi
	je	$LN20@ExterndefD
	cmp	DWORD PTR [rdi+32], r15d
	je	$LN20@ExterndefD

; 306  : 
; 307  :         } else if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, r15d
	jne	$LN38@ExterndefD

; 308  : 
; 309  :             /* v2.05: added to accept type prototypes */
; 310  :             if ( ti.is_ptr == 0 && ti.symtype && ti.symtype->isproc ) {

	cmp	BYTE PTR ti$[rbp-60], r15b
	jne	SHORT $LN33@ExterndefD
	test	rdx, rdx
	je	SHORT $LN33@ExterndefD
	test	BYTE PTR [rdx+41], 8
	je	SHORT $LN33@ExterndefD

; 311  :                 ti.mem_type = ti.symtype->mem_type;

	mov	eax, DWORD PTR [rdx+36]

; 312  :                 ti.symtype = NULL;

	mov	rdx, r15
	mov	QWORD PTR ti$[rbp-72], rdx
	mov	DWORD PTR ti$[rbp-64], eax
$LN33@ExterndefD:

; 313  :             }
; 314  :             /* ensure that the type of the symbol won't change */
; 315  : 
; 316  :             if ( sym->mem_type != ti.mem_type ) {

	mov	eax, DWORD PTR [rdi+36]
	cmp	eax, DWORD PTR ti$[rbp-64]
	jne	SHORT $LN71@ExterndefD

; 317  :                 /* if the symbol is already defined (as SYM_INTERNAL), Masm
; 318  :                  won't display an error. The other way, first externdef and
; 319  :                  then the definition, will make Masm complain, however */
; 320  :                 DebugMsg(("ExterndefDirective: type conflict for %s. mem_types old-new: %X-%X\n", sym->name, sym->mem_type, ti.mem_type));
; 321  :                 EmitWarn( 1, SYMBOL_TYPE_CONFLICT, sym->name );
; 322  :             } else if ( sym->mem_type == MT_TYPE && sym->type != ti.symtype ) {

	cmp	eax, 196				; 000000c4H
	jne	SHORT $LN37@ExterndefD
	mov	rax, QWORD PTR [rdi+80]
	cmp	rax, rdx
	je	SHORT $LN37@ExterndefD

; 323  :                 struct asym *sym2 = sym;

	mov	rcx, rdi

; 324  :                 /* skip alias types and compare the base types */
; 325  :                 DebugMsg(("ExterndefDirective(%s): types differ: %X (%s) - %X (%s)\n", sym->name, sym->type, sym->type->name, ti.symtype, ti.symtype->name));
; 326  :                 while ( sym2->type )

	test	rax, rax
	je	SHORT $LN54@ExterndefD
	npad	11
$LL7@ExterndefD:

; 327  :                     sym2 = sym2->type;

	mov	rcx, rax
	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	jne	SHORT $LL7@ExterndefD
$LN54@ExterndefD:

; 328  :                 while ( ti.symtype->type )

	mov	rax, QWORD PTR [rdx+80]
	test	rax, rax
	je	SHORT $LN10@ExterndefD
	npad	11
$LL9@ExterndefD:

; 329  :                     ti.symtype = ti.symtype->type;

	mov	rdx, rax
	mov	QWORD PTR ti$[rbp-72], rax
	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	jne	SHORT $LL9@ExterndefD
$LN10@ExterndefD:

; 330  :                 if ( sym2 != ti.symtype ) {

	cmp	rcx, rdx
	je	SHORT $LN37@ExterndefD
$LN71@ExterndefD:

; 331  :                     DebugMsg(("ExterndefDirective(%s): type conflict old-new: %X (%s) - %X (%s)\n", sym->name, sym2, sym2->name, ti.symtype, ti.symtype->name));
; 332  :                     EmitWarn( 1, SYMBOL_TYPE_CONFLICT, sym->name );

	mov	r8, QWORD PTR [rdi+8]
	mov	edx, 137				; 00000089H
	mov	ecx, 1
	call	EmitWarn
$LN37@ExterndefD:

; 333  :                 }
; 334  :             }
; 335  : 
; 336  :             /* v2.04: emit a - weak - warning if language differs.
; 337  :              * Masm doesn't warn.
; 338  :              */
; 339  :             if ( langtype != LANG_NONE && sym->langtype != langtype )

	mov	eax, DWORD PTR langtype$[rbp-80]
	test	eax, eax
	je	$LN38@ExterndefD
	cmp	DWORD PTR [rdi+76], eax
	je	$LN38@ExterndefD

; 340  :                 EmitWarn( 3, LANGUAGE_ATTRIBUTE_CONFLICT, sym->name );

	mov	r8, QWORD PTR [rdi+8]
	mov	edx, 104				; 00000068H
	lea	ecx, QWORD PTR [rdx-101]
	call	EmitWarn
	jmp	$LN38@ExterndefD
$LN20@ExterndefD:

; 253  :             sym = CreateExternal( sym, token, TRUE );

	mov	rbx, rdi
	test	rdi, rdi
	jne	SHORT $LN46@ExterndefD
	mov	rcx, rsi
	call	SymCreate
	mov	rbx, rax
	jmp	SHORT $LN47@ExterndefD
$LN46@ExterndefD:
	mov	rdx, rdi
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table
$LN47@ExterndefD:
	test	rbx, rbx
	je	SHORT $LN48@ExterndefD
	movzx	ecx, BYTE PTR [rbx+47]
	mov	rdx, rbx
	and	cl, 248					; 000000f8H
	mov	DWORD PTR [rbx+32], 2
	movzx	eax, BYTE PTR ModuleInfo+404
	and	al, 3
	or	cl, al
	or	cl, 8
	mov	BYTE PTR [rbx+47], cl
	lea	rcx, OFFSET FLAT:SymTables+16
	call	sym_add_table
$LN48@ExterndefD:
	mov	rdi, rbx

; 254  :             isnew = TRUE;
; 255  :         }
; 256  : 
; 257  :         /* new symbol? */
; 258  : 
; 259  :         if ( isnew ) {
; 260  :             DebugMsg1(("ExterndefDirective(%s): memtype=%X set, ofssize=%X\n", token, ti.mem_type, ti.Ofssize ));
; 261  : 
; 262  :             /* v2.05: added to accept type prototypes */
; 263  :             if ( ti.is_ptr == 0 && ti.symtype && ti.symtype->isproc ) {

	cmp	BYTE PTR ti$[rbp-60], r15b
	jne	SHORT $LN70@ExterndefD
	mov	rax, QWORD PTR ti$[rbp-72]
	test	rax, rax
	je	SHORT $LN70@ExterndefD
	test	BYTE PTR [rax+41], 8
	je	SHORT $LN70@ExterndefD

; 264  :                 CreateProc( sym, NULL, SYM_EXTERNAL );

	xor	edx, edx
	mov	rcx, rbx
	lea	r8d, QWORD PTR [rdx+2]
	call	CreateProc

; 265  :                 CopyPrototype( (struct dsym *)sym, (struct dsym *)ti.symtype );

	mov	rdx, QWORD PTR ti$[rbp-72]
	mov	rcx, rbx
	call	CopyPrototype

; 266  :                 ti.mem_type = ti.symtype->mem_type;

	mov	rax, QWORD PTR ti$[rbp-72]
	mov	ecx, DWORD PTR [rax+36]
	mov	DWORD PTR ti$[rbp-64], ecx

; 267  :                 ti.symtype = NULL;

	mov	QWORD PTR ti$[rbp-72], r15
	jmp	SHORT $LN23@ExterndefD
$LN70@ExterndefD:
	mov	ecx, DWORD PTR ti$[rbp-64]
$LN23@ExterndefD:

; 268  :             }
; 269  :             switch ( ti.mem_type ) {

	sub	ecx, 130				; 00000082H
	je	SHORT $LN25@ExterndefD
	sub	ecx, 62					; 0000003eH
	je	SHORT $LN5@ExterndefD
	jmp	SHORT $LN26@ExterndefD
$LN25@ExterndefD:

; 270  :             //case MT_ABS:
; 271  :             case MT_EMPTY:
; 272  :                 /* v2.04: hack no longer necessary */
; 273  :                 //if ( sym->weak == TRUE )
; 274  :                 //    sym->equate = TRUE; /* allow redefinition by EQU, = */
; 275  :                 break;
; 276  :             case MT_FAR:
; 277  :                 /* v2.04: don't inherit current segment for FAR externals
; 278  :                  * if -Zg is set.
; 279  :                  */
; 280  :                 if ( Options.masm_compat_gencode )

	cmp	BYTE PTR Options+128, r15b
	jne	SHORT $LN5@ExterndefD
$LN26@ExterndefD:

; 281  :                     break; 
; 282  :                 /* fall through */
; 283  :             default:
; 284  :                 //SetSymSegOfs( sym );
; 285  :                 sym->segment = &CurrSeg->sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rbx+24], rax
$LN5@ExterndefD:

; 286  :             }
; 287  :             sym->Ofssize = ti.Ofssize;

	movzx	eax, BYTE PTR ti$[rbp-58]
	mov	BYTE PTR [rbx+44], al

; 288  : 
; 289  :             if ( ti.is_ptr == 0 && ti.Ofssize != ModuleInfo.Ofssize ) {

	cmp	BYTE PTR ti$[rbp-60], r15b
	jne	SHORT $LN29@ExterndefD
	movzx	ecx, BYTE PTR ti$[rbp-58]
	cmp	cl, BYTE PTR ModuleInfo+404
	je	SHORT $LN29@ExterndefD

; 290  :                 sym->seg_ofssize = ti.Ofssize;

	movzx	eax, BYTE PTR [rbx+47]
	xor	al, cl
	and	al, 3
	xor	BYTE PTR [rbx+47], al

; 291  :                 if ( sym->segment && ((struct dsym *)sym->segment)->e.seginfo->Ofssize != sym->seg_ofssize )

	mov	rax, QWORD PTR [rbx+24]
	movzx	ecx, BYTE PTR [rbx+47]
	test	rax, rax
	je	SHORT $LN29@ExterndefD
	mov	rax, QWORD PTR [rax+96]
	and	cl, 3
	cmp	BYTE PTR [rax+104], cl
	je	SHORT $LN29@ExterndefD

; 292  :                     sym->segment = NULL;

	mov	QWORD PTR [rbx+24], r15
$LN29@ExterndefD:

; 293  :             }
; 294  : 
; 295  :             sym->mem_type = ti.mem_type;

	mov	eax, DWORD PTR ti$[rbp-64]
	mov	DWORD PTR [rbx+36], eax

; 296  :             sym->is_ptr = ti.is_ptr;

	movzx	eax, BYTE PTR ti$[rbp-60]
	mov	BYTE PTR [rbx+45], al

; 297  :             sym->isfar = ti.is_far;

	movzx	eax, BYTE PTR ti$[rbp-59]
	shl	al, 4
	xor	al, BYTE PTR [rbx+47]
	and	al, 16
	xor	BYTE PTR [rbx+47], al

; 298  :             sym->ptr_memtype = ti.ptr_memtype;

	movzx	eax, BYTE PTR ti$[rbp-56]
	mov	BYTE PTR [rbx+46], al

; 299  :             if ( ti.mem_type == MT_TYPE )

	cmp	DWORD PTR ti$[rbp-64], 196		; 000000c4H

; 300  :                 sym->type = ti.symtype;

	mov	rax, QWORD PTR ti$[rbp-72]
	jne	SHORT $LN30@ExterndefD
	mov	QWORD PTR [rbx+80], rax
	jmp	SHORT $LN31@ExterndefD
$LN30@ExterndefD:

; 301  :             else
; 302  :                 sym->target_type = ti.symtype;

	mov	QWORD PTR [rbx+48], rax
$LN31@ExterndefD:

; 303  : 
; 304  :             /* v2.04: only set language if there was no previous definition */
; 305  :             SetMangler( sym, langtype, mangle_type );

	mov	edx, DWORD PTR langtype$[rbp-80]
	xor	r8d, r8d
	mov	rcx, rbx
	call	SetMangler
$LN38@ExterndefD:

; 341  :         }
; 342  :         sym->isdefined = TRUE;

	or	BYTE PTR [rdi+40], 2

; 343  : 
; 344  : #if 0
; 345  :         /* write a global entry if none has been written yet */
; 346  :         if ( sym->state == SYM_EXTERNAL && sym->weak == FALSE )
; 347  :             ;/* skip EXTERNDEF if a real EXTERN/COMM was done */
; 348  :         else if ( sym->isglobal == FALSE ) {
; 349  :             sym->isglobal = TRUE;
; 350  :             DebugMsg1(("ExterndefDirective(%s): writing a global entry\n", sym->name));
; 351  :             QAddItem( &ModuleInfo.g.GlobalQueue, sym );
; 352  :         }
; 353  : #else
; 354  :         if ( sym->state == SYM_INTERNAL && sym->ispublic == FALSE ) {

	cmp	DWORD PTR [rdi+32], 1
	movzx	eax, BYTE PTR [rdi+40]
	jne	SHORT $LN50@ExterndefD
	test	al, al
	js	SHORT $LN50@ExterndefD

; 355  :             sym->ispublic = TRUE;

	or	al, 128					; 00000080H

; 356  :             AddPublicData( sym );

	lea	rcx, OFFSET FLAT:ModuleInfo+16
	mov	rdx, rdi
	mov	BYTE PTR [rdi+40], al
	call	QAddItem
$LN50@ExterndefD:

; 357  :         }
; 358  : #endif
; 359  : 
; 360  :         if ( tokenarray[i].token != T_FINAL )

	movsxd	rcx, DWORD PTR i$[rbp-80]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rax, rcx
	shl	rax, 5
	movzx	edx, BYTE PTR [rax+r14]
	test	dl, dl
	je	SHORT $LN2@ExterndefD

; 361  :             if ( tokenarray[i].token == T_COMMA ) {

	cmp	dl, 44					; 0000002cH
	jne	SHORT $LN41@ExterndefD

; 362  :                 if ( (i + 1) < Token_Count )

	lea	eax, DWORD PTR [rcx+1]
	cmp	eax, r8d
	cmovl	ecx, eax
	mov	DWORD PTR i$[rbp-80], ecx
$LN2@ExterndefD:

; 366  :             }
; 367  : 
; 368  :     } while ( i < Token_Count );

	cmp	ecx, r8d
	jl	$LL4@ExterndefD

; 369  : 
; 370  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@ExterndefD
$LN58@ExterndefD:

; 234  :             /* dont scan this line further!
; 235  :              * CreateProto() will either define a SYM_EXTERNAL or fail
; 236  :              * if there's a syntax error or symbol redefinition.
; 237  :              */
; 238  :             sym = CreateProto( i + 1, tokenarray, token, langtype );

	mov	r9d, DWORD PTR langtype$[rbp-80]
	lea	ecx, DWORD PTR [r8+1]
	mov	r8, rsi
	mov	rdx, r14
	call	CreateProto

; 239  : #if 0 /* global queue is obsolete */
; 240  :             if ( sym && sym->isglobal == FALSE ) {
; 241  :                 sym->isglobal = TRUE;
; 242  :                 QAddItem( &ModuleInfo.g.GlobalQueue, sym );
; 243  :             }
; 244  : #endif
; 245  :             return( sym ? NOT_ERROR : ERROR );

	neg	rax
	sbb	eax, eax
	neg	eax
	dec	eax
	jmp	SHORT $LN1@ExterndefD
$LN59@ExterndefD:

; 248  :                 return( ERROR );

	or	eax, -1
	jmp	SHORT $LN1@ExterndefD
$LN41@ExterndefD:

; 363  :                     i++;
; 364  :             } else {
; 365  :                 return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, rcx
	mov	ecx, 40					; 00000028H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r14+24]
	jmp	SHORT $LN72@ExterndefD
$LN57@ExterndefD:

; 215  :             return( EmitError( COLON_EXPECTED ) );

	mov	ecx, 85					; 00000055H
	call	EmitError
	jmp	SHORT $LN1@ExterndefD
$LN55@ExterndefD:

; 209  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, rcx
	mov	ecx, 210				; 000000d2H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r14+8]
$LN72@ExterndefD:
	call	EmitErr
$LN1@ExterndefD:
	mov	rdi, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+128]

; 371  : }

	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rbp
	ret	0
ExterndefDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
;	COMDAT CreateProto
_TEXT	SEGMENT
i$ = 64
tokenarray$ = 72
name$ = 80
langtype$ = 88
CreateProto PROC					; COMDAT

; 126  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 48					; 00000030H
	movsxd	rdi, ecx
	mov	r14d, r9d

; 127  :     struct asym      *sym;
; 128  :     struct dsym      *dir;
; 129  : 
; 130  :     DebugMsg1(("CreateProto( i=%u, name=%s, lang=%u )\n", i, name ? name : "NULL", langtype ));
; 131  :     sym = SymSearch( name );

	mov	rcx, r8
	mov	rbp, r8
	mov	rsi, rdx
	call	SymFind
	mov	rbx, rax

; 132  : 
; 133  :     /* the symbol must be either NULL or state
; 134  :      * - SYM_UNDEFINED
; 135  :      * - SYM_EXTERNAL + isproc == FALSE ( previous EXTERNDEF )
; 136  :      * - SYM_EXTERNAL + isproc == TRUE ( previous PROTO )
; 137  :      * - SYM_INTERNAL + isproc == TRUE ( previous PROC )
; 138  :      */
; 139  :     if( sym == NULL ||
; 140  :        sym->state == SYM_UNDEFINED ||

	test	rax, rax
	je	SHORT $LN4@CreateProt
	mov	eax, DWORD PTR [rax+32]
	test	eax, eax
	je	SHORT $LN4@CreateProt
	cmp	eax, 2
	jne	SHORT $LN2@CreateProt
	test	BYTE PTR [rbx+47], 8
	je	SHORT $LN2@CreateProt
	test	BYTE PTR [rbx+41], 8
	je	SHORT $LN4@CreateProt
$LN2@CreateProt:

; 143  :             return( NULL ); /* name was probably invalid */
; 144  :     } else if ( sym->isproc == FALSE ) {

	test	BYTE PTR [rbx+41], 8
	jne	SHORT $LN5@CreateProt

; 145  :         EmitErr( SYMBOL_REDEFINITION, sym->name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 144				; 00000090H
	call	EmitErr
$LN14@CreateProt:

; 146  :         return( NULL );

	xor	eax, eax
	jmp	$LN1@CreateProt
$LN4@CreateProt:

; 141  :        ( sym->state == SYM_EXTERNAL && sym->weak == TRUE && sym->isproc == FALSE )) {
; 142  :         if ( NULL == ( sym = CreateProc( sym, name, SYM_EXTERNAL ) ) )

	mov	r8d, 2
	mov	rdx, rbp
	mov	rcx, rbx
	call	CreateProc
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN14@CreateProt
$LN5@CreateProt:

; 147  :     }
; 148  :     dir = (struct dsym *)sym;
; 149  : 
; 150  :     /* a PROTO typedef may be used */
; 151  :     if ( tokenarray[i].token == T_ID ) {

	mov	rax, rdi
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 8
	jne	SHORT $LN8@CreateProt

; 152  :         struct asym * sym2;
; 153  :         sym2 = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rax+rsi+8]
	call	SymFind

; 154  :         if ( sym2 && sym2->state == SYM_TYPE && sym2->mem_type == MT_PROC ) {

	test	rax, rax
	je	SHORT $LN8@CreateProt
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN8@CreateProt
	cmp	DWORD PTR [rax+36], 128			; 00000080H
	jne	SHORT $LN8@CreateProt

; 155  :             i++;

	inc	edi

; 156  :             if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rcx, edi
	shl	rcx, 5
	cmp	BYTE PTR [rcx+rsi], 0
	je	SHORT $LN9@CreateProt

; 157  :                 EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rcx+rsi+8]
	mov	ecx, 210				; 000000d2H
	call	EmitErr

; 158  :                 return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@CreateProt
$LN9@CreateProt:

; 159  :             }
; 160  :             CopyPrototype( dir, (struct dsym *)sym2->target_type );

	mov	rdx, QWORD PTR [rax+48]
	mov	rcx, rbx
	call	CopyPrototype

; 161  :             return( sym );

	jmp	SHORT $LN11@CreateProt
$LN8@CreateProt:

; 162  :         }
; 163  :     }
; 164  :     /* sym->isproc is set inside ParseProc() */
; 165  :     //sym->isproc = TRUE;
; 166  : 
; 167  :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN10@CreateProt

; 168  :         if ( ParseProc( dir, i, tokenarray, FALSE, langtype ) == ERROR )

	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], r14d
	mov	r8, rsi
	mov	edx, edi
	mov	rcx, rbx
	call	ParseProc
	cmp	eax, -1
	je	$LN14@CreateProt

; 169  :             return( NULL );
; 170  : #if DLLIMPORT
; 171  :         sym->dll = ModuleInfo.CurrDll;

	mov	rax, QWORD PTR ModuleInfo+336
	mov	QWORD PTR [rbx+56], rax

; 172  : #endif
; 173  :     } else {

	jmp	SHORT $LN11@CreateProt
$LN10@CreateProt:

; 174  :         sym->isdefined = TRUE;

	or	BYTE PTR [rbx+40], 2
$LN11@CreateProt:

; 175  :     }
; 176  :     return( sym );

	mov	rax, rbx
$LN1@CreateProt:

; 177  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
CreateProto ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
;	COMDAT CreateComm
_TEXT	SEGMENT
sym$ = 48
name$ = 56
CreateComm PROC						; COMDAT

; 103  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 104  :     if ( sym == NULL )

	test	rcx, rcx
	jne	SHORT $LN2@CreateComm

; 105  :         sym = SymCreate( name );

	mov	rcx, rdx
	call	SymCreate
	mov	rbx, rax
	jmp	SHORT $LN3@CreateComm
$LN2@CreateComm:

; 106  :     else
; 107  :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table
$LN3@CreateComm:

; 108  : 
; 109  :     if ( sym ) {

	test	rbx, rbx
	je	SHORT $LN6@CreateComm

; 110  :         sym->state = SYM_EXTERNAL;
; 111  :         sym->seg_ofssize = ModuleInfo.Ofssize;
; 112  :         sym->iscomm = TRUE;
; 113  :         sym->weak = FALSE;
; 114  :         sym->isfar = FALSE;

	movzx	eax, BYTE PTR [rbx+47]

; 115  :         sym_add_table( &SymTables[TAB_EXT], (struct dsym *)sym ); /* add EXTERNAL */

	mov	rdx, rbx
	mov	DWORD PTR [rbx+32], 2
	and	al, 228					; 000000e4H
	movzx	ecx, BYTE PTR ModuleInfo+404
	and	cl, 3
	or	cl, al
	or	cl, 4
	mov	BYTE PTR [rbx+47], cl
	lea	rcx, OFFSET FLAT:SymTables+16
	call	sym_add_table
$LN6@CreateComm:

; 116  :     }
; 117  :     return( sym );

	mov	rax, rbx

; 118  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
CreateComm ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
;	COMDAT CreateExternal
_TEXT	SEGMENT
sym$ = 48
name$ = 56
weak$ = 64
CreateExternal PROC					; COMDAT

; 82   : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movzx	edi, r8b
	mov	rbx, rcx

; 83   :     if ( sym == NULL )

	test	rcx, rcx
	jne	SHORT $LN2@CreateExte

; 84   :         sym = SymCreate( name );

	mov	rcx, rdx
	call	SymCreate
	mov	rbx, rax
	jmp	SHORT $LN3@CreateExte
$LN2@CreateExte:

; 85   :     else
; 86   :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table
$LN3@CreateExte:

; 87   : 
; 88   :     if ( sym ) {

	test	rbx, rbx
	je	SHORT $LN6@CreateExte

; 89   :         sym->state = SYM_EXTERNAL;
; 90   :         sym->seg_ofssize = ModuleInfo.Ofssize;
; 91   :         sym->iscomm = FALSE;
; 92   :         sym->weak = weak;

	and	dil, 1
	mov	DWORD PTR [rbx+32], 2
	movzx	eax, BYTE PTR ModuleInfo+404

; 93   :         sym_add_table( &SymTables[TAB_EXT], (struct dsym *)sym ); /* add EXTERNAL */

	lea	rcx, OFFSET FLAT:SymTables+16
	and	al, 3
	shl	dil, 3
	or	dil, al
	mov	rdx, rbx
	movzx	eax, BYTE PTR [rbx+47]
	and	al, 240					; 000000f0H
	or	dil, al
	mov	BYTE PTR [rbx+47], dil
	call	sym_add_table
$LN6@CreateExte:

; 94   :     }
; 95   :     return( sym );

	mov	rax, rbx

; 96   : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CreateExternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
FreePubQueue PROC

; 873  : #if FASTMEM==0
; 874  :     struct qnode *curr;
; 875  :     struct qnode *next;
; 876  :     for( curr = ModuleInfo.g.PubQueue.head; curr; curr = next ) {
; 877  :         next = curr->next;
; 878  :         LclFree( curr );
; 879  :     }
; 880  : #endif
; 881  :     ModuleInfo.g.PubQueue.head = NULL;

	mov	QWORD PTR ModuleInfo+16, 0

; 882  : }

	ret	0
FreePubQueue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
sym$ = 8
AddPublicData PROC

; 833  :     DebugMsg1(("AddPublicData(%s)\n", sym->name ));
; 834  :     QAddItem( &ModuleInfo.g.PubQueue, sym );

	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:ModuleInfo+16
	jmp	QAddItem
AddPublicData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
name$ = 48
mem_type$ = 56
vartype$ = 64
sym$ = 72
Ofssize$ = 80
MakeExtern PROC

; 402  : {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, edx
	mov	rdi, r8

; 403  :     sym = CreateExternal( sym, name, FALSE );

	mov	rdx, rcx
	xor	r8d, r8d
	mov	rcx, r9
	call	CreateExternal
	mov	rcx, rax

; 404  :     if ( sym == NULL )

	test	rax, rax
	jne	SHORT $LN2@MakeExtern

; 418  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@MakeExtern:

; 405  :         return( NULL );
; 406  : 
; 407  :     //if ( mem_type == MT_ABS )
; 408  :     if ( mem_type == MT_EMPTY )

	cmp	ebx, 192				; 000000c0H
	je	SHORT $LN5@MakeExtern

; 409  :         ;
; 410  :     else if ( Options.masm_compat_gencode == FALSE || mem_type != MT_FAR )

	cmp	BYTE PTR Options+128, 0
	je	SHORT $LN6@MakeExtern
	cmp	ebx, 130				; 00000082H
	je	SHORT $LN5@MakeExtern
$LN6@MakeExtern:

; 411  :         sym->segment = &CurrSeg->sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rcx+24], rax
$LN5@MakeExtern:

; 412  : 
; 413  :     sym->isdefined = TRUE;
; 414  :     sym->mem_type = mem_type;
; 415  :     sym->seg_ofssize = Ofssize;

	movzx	eax, BYTE PTR Ofssize$[rsp]
	or	BYTE PTR [rcx+40], 2
	and	al, 3
	and	BYTE PTR [rcx+47], 252			; 000000fcH
	or	BYTE PTR [rcx+47], al

; 416  :     sym->type = vartype;
; 417  :     return( sym );

	mov	rax, rcx
	mov	DWORD PTR [rcx+36], ebx

; 418  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rcx+80], rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
MakeExtern ENDP
_TEXT	ENDS
END
