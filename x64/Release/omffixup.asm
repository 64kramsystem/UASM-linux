; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
PUBLIC	OmfFixGenFix
PUBLIC	OmfFixGenFixModend
EXTRN	EmitErr:PROC
EXTRN	GetSegIdx:PROC
EXTRN	omf_GetGrpIdx:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	szNull:BYTE
EXTRN	__ImageBase:BYTE
pdata	SEGMENT
$pdata$OmfFixGenFix DD imagerel $LN22
	DD	imagerel $LN22+340
	DD	imagerel $unwind$OmfFixGenFix
$pdata$OmfFixGenFixModend DD imagerel $LN32
	DD	imagerel $LN32+288
	DD	imagerel $unwind$OmfFixGenFixModend
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_fill_logref DD imagerel omf_fill_logref
	DD	imagerel omf_fill_logref+443
	DD	imagerel $unwind$omf_fill_logref
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_fill_logref DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
xdata	SEGMENT
$unwind$OmfFixGenFix DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0f0145218H
	DD	07010e012H
$unwind$OmfFixGenFixModend DD 0c1e01H
	DD	0d741eH
	DD	0c641eH
	DD	0b541eH
	DD	0a341eH
	DD	0f01a521eH
	DD	0c016e018H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
;	COMDAT omf_fill_logref
_TEXT	SEGMENT
fixup$ = 48
lr$ = 56
omf_fill_logref PROC					; COMDAT

; 238  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	rbx, rdx

; 239  :     struct asym      *sym;
; 240  : 
; 241  :     sym = fixup->sym; /* may be NULL! */

	mov	rcx, QWORD PTR [rcx+56]

; 242  : 
; 243  :     DebugMsg1(("omf_fill_logref: sym=%s, state=%d, fixup->type=%u\n",
; 244  :                sym ? sym->name : "NULL", sym ? sym->state : -1, fixup->type ));
; 245  : 
; 246  :     /*------------------------------------*/
; 247  :     /* Determine the Target and the Frame */
; 248  :     /*------------------------------------*/
; 249  : 
; 250  :     if( sym == NULL ) {

	mov	esi, 5
	test	rcx, rcx
	jne	SHORT $LN2@omf_fill_l

; 251  : 
; 252  :         DebugMsg(("omf_fill_logref: sym is NULL, frame_type=%u\n", fixup->frame_type ));
; 253  :         if ( fixup->frame_type == FRAME_NONE ) /* v1.96: nothing to do without a frame */

	movzx	eax, BYTE PTR [rdi+40]
	cmp	al, 6
	je	SHORT $LN29@omf_fill_l

; 254  :             return( 0 );
; 255  :         lr->target = fixup->frame_type;

	mov	BYTE PTR [rdx+5], al

; 256  :         lr->target_datum = fixup->frame_datum;

	movzx	eax, WORD PTR [rdi+42]
	mov	WORD PTR [rdx+6], ax

; 257  :         lr->frame = FRAME_TARG;

	mov	BYTE PTR [rdx], sil
	jmp	$LN24@omf_fill_l
$LN2@omf_fill_l:

; 258  : 
; 259  :     } else if( sym->state == SYM_UNDEFINED ) { /* shouldn't happen */

	mov	eax, DWORD PTR [rcx+32]
	test	eax, eax
	jne	SHORT $LN5@omf_fill_l

; 260  : 
; 261  :         DebugMsg(("omf_fill_logref: sym->state is SYM_UNDEFINED\n" ));
; 262  :         EmitErr( SYMBOL_NOT_DEFINED, sym->name );

	mov	rdx, QWORD PTR [rcx+8]
	lea	ecx, QWORD PTR [rax+102]
	call	EmitErr
$LN29@omf_fill_l:

; 263  :         return( 0 );

	xor	eax, eax

; 343  :         lr->frame = FRAME_TARG;
; 344  :     }
; 345  : 
; 346  :     return( 1 );
; 347  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN5@omf_fill_l:

; 264  : 
; 265  :     } else if( sym->state == SYM_GRP ) {

	cmp	eax, 4
	jne	SHORT $LN7@omf_fill_l

; 266  : 
; 267  :         DebugMsg1(("omf_fill_logref: sym->state is SYM_GRP\n" ));
; 268  :         lr->target = TARGET_GRP;

	mov	BYTE PTR [rdx+5], sil

; 269  :         lr->target_datum = ((struct dsym *)sym)->e.grpinfo->grp_idx;

	mov	rax, QWORD PTR [rcx+96]
	movzx	ecx, WORD PTR [rax+8]
	mov	WORD PTR [rdx+6], cx

; 270  :         if( fixup->frame_type != FRAME_NONE ) {

	movzx	eax, BYTE PTR [rdi+40]
	cmp	al, 6
	je	SHORT $LN9@omf_fill_l

; 271  :             lr->frame = fixup->frame_type;

	mov	BYTE PTR [rdx], al

; 272  :             lr->frame_datum = fixup->frame_datum;

	movzx	eax, WORD PTR [rdi+42]
	mov	WORD PTR [rdx+2], ax

; 273  :         } else {

	jmp	$LN24@omf_fill_l
$LN9@omf_fill_l:

; 274  :             lr->frame = FRAME_GRP;

	mov	BYTE PTR [rdx], 1

; 275  :             lr->frame_datum = lr->target_datum;

	mov	WORD PTR [rdx+2], cx

; 276  :         }

	jmp	$LN24@omf_fill_l
$LN7@omf_fill_l:

; 277  : 
; 278  :     } else if( sym->state == SYM_SEG ) {

	cmp	eax, 3
	jne	SHORT $LN11@omf_fill_l

; 279  : 
; 280  :         DebugMsg1(("omf_fill_logref: sym->state is SYM_SEG %s\n" ));
; 281  :         lr->target = TARGET_SEG;

	mov	BYTE PTR [rdx+5], 4

; 282  :         lr->target_datum = GetSegIdx( sym );

	call	GetSegIdx
	mov	WORD PTR [rbx+6], ax

; 283  :         if( fixup->frame_type != FRAME_NONE ) {

	movzx	ecx, BYTE PTR [rdi+40]
	cmp	cl, 6
	je	SHORT $LN13@omf_fill_l

; 284  :             lr->frame = fixup->frame_type;

	mov	BYTE PTR [rbx], cl

; 285  :             lr->frame_datum = fixup->frame_datum;

	movzx	eax, WORD PTR [rdi+42]
	mov	WORD PTR [rbx+2], ax

; 286  :         } else {

	jmp	$LN24@omf_fill_l
$LN13@omf_fill_l:

; 287  :             lr->frame = FRAME_SEG;

	mov	BYTE PTR [rbx], 0

; 288  :             lr->frame_datum = lr->target_datum;

	mov	WORD PTR [rbx+2], ax

; 289  :         }
; 290  : 
; 291  :     } else {

	jmp	$LN24@omf_fill_l
$LN11@omf_fill_l:

; 292  : 
; 293  :         /* symbol is a label */
; 294  : 
; 295  :         lr->frame_datum = fixup->frame_datum;

	movzx	eax, WORD PTR [rdi+42]
	mov	WORD PTR [rdx+2], ax

; 296  :         if( sym->state == SYM_EXTERNAL ) {

	cmp	DWORD PTR [rcx+32], 2
	jne	SHORT $LN15@omf_fill_l

; 297  :             DebugMsg1(("omf_fill_logref: sym->state is SYM_EXTERNAL, fixup->frame_type/datum=%u/%u\n",
; 298  :                       fixup->frame_type, fixup->frame_datum ));
; 299  :             lr->target = TARGET_EXT;

	mov	BYTE PTR [rdx+5], 6

; 300  :             lr->target_datum = sym->ext_idx1;

	movzx	eax, WORD PTR [rcx+88]
	mov	WORD PTR [rdx+6], ax

; 301  : 
; 302  :             if( fixup->frame_type == FRAME_GRP && fixup->frame_datum == 0 ) {

	cmp	BYTE PTR [rdi+40], 1
	jne	$LN23@omf_fill_l
	cmp	WORD PTR [rdi+42], 0
	jne	$LN23@omf_fill_l

; 303  :                 /* set the frame to the frame of the corresponding segment */
; 304  :                 lr->frame_datum = omf_GetGrpIdx( sym );

	call	omf_GetGrpIdx
	mov	WORD PTR [rbx+2], ax

; 305  :             }
; 306  :         } else {

	jmp	SHORT $LN23@omf_fill_l
$LN15@omf_fill_l:

; 307  :             /* must be SYM_INTERNAL */
; 308  :             /**/myassert( sym->state == SYM_INTERNAL );
; 309  :             DebugMsg1(("omf_fill_logref: sym->state is SYM_INTERNAL, sym->segment=%s, fixup->frame/datum=%u/%u\n",
; 310  :                        sym->segment ? sym->segment->name : "NULL", fixup->frame_type, fixup->frame_datum ));
; 311  :             /* v2.08: don't use info from assembly-time variables */
; 312  :             if ( sym->variable ) {

	test	BYTE PTR [rcx+40], 64			; 00000040H
	je	SHORT $LN18@omf_fill_l

; 313  :                 lr->target = ( fixup->frame_type == FRAME_GRP ? TARGET_GRP : TARGET_SEG );

	cmp	BYTE PTR [rdi+40], 1
	sete	al
	add	al, 4
	mov	BYTE PTR [rdx+5], al

; 314  :                 lr->target_datum = fixup->frame_datum;

	movzx	eax, WORD PTR [rdi+42]
	mov	WORD PTR [rdx+6], ax
	jmp	SHORT $LN23@omf_fill_l
$LN18@omf_fill_l:

; 315  :             } else if ( sym->segment == NULL ) { /* shouldn't happen */

	mov	rax, QWORD PTR [rcx+24]
	test	rax, rax
	jne	SHORT $LN20@omf_fill_l

; 316  :                 EmitErr( SEGMENT_MISSING_FOR_FIXUP, sym->name );

	mov	rdx, QWORD PTR [rcx+8]
	mov	ecx, 164				; 000000a4H
	call	EmitErr

; 317  :                 return ( 0 );

	xor	eax, eax

; 343  :         lr->frame = FRAME_TARG;
; 344  :     }
; 345  : 
; 346  :     return( 1 );
; 347  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN20@omf_fill_l:

; 318  : #if COMDATSUPP
; 319  :             } else if ( ( (struct dsym *)sym->segment)->e.seginfo->comdat_selection ) {

	mov	rax, QWORD PTR [rax+96]
	test	BYTE PTR [rax+108], 56			; 00000038H
	je	SHORT $LN22@omf_fill_l

; 320  :                 lr->target = TARGET_EXT;

	mov	BYTE PTR [rdx+5], 6

; 321  :                 lr->target_datum = ((struct dsym *)sym->segment)->e.seginfo->seg_idx;

	mov	rax, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR [rax+96]
	movzx	eax, WORD PTR [rcx+68]
	mov	WORD PTR [rdx+6], ax

; 322  :                 lr->frame = FRAME_TARG;

	mov	BYTE PTR [rdx], sil

; 323  :                 return( 1 );

	jmp	SHORT $LN28@omf_fill_l
$LN22@omf_fill_l:

; 324  : #endif
; 325  :             } else {
; 326  :                 lr->target = TARGET_SEG;

	mov	BYTE PTR [rdx+5], 4

; 327  :                 lr->target_datum = GetSegIdx( sym->segment );

	mov	rcx, QWORD PTR [rcx+24]
	call	GetSegIdx
	mov	WORD PTR [rbx+6], ax
$LN23@omf_fill_l:

; 328  :             }
; 329  :         }
; 330  : 
; 331  :         if( fixup->frame_type != FRAME_NONE ) {

	movzx	ecx, BYTE PTR [rdi+40]
	mov	eax, esi
	cmp	cl, 6
	cmovne	eax, ecx
	mov	BYTE PTR [rbx], al
$LN24@omf_fill_l:

; 332  :             lr->frame = (uint_8)fixup->frame_type;
; 333  :         } else {
; 334  :             lr->frame = FRAME_TARG;
; 335  :         }
; 336  :     }
; 337  : 
; 338  :     /*--------------------*/
; 339  :     /* Optimize the fixup */
; 340  :     /*--------------------*/
; 341  : 
; 342  :     if( lr->frame == ( lr->target - TARGET_SEG ) ) {

	movzx	eax, BYTE PTR [rbx]
	movzx	ecx, BYTE PTR [rbx]
	movzx	edx, BYTE PTR [rbx+5]
	sub	edx, 4
	cmp	eax, edx
	cmove	ecx, esi
	mov	BYTE PTR [rbx], cl
$LN28@omf_fill_l:

; 343  :         lr->frame = FRAME_TARG;
; 344  :     }
; 345  : 
; 346  :     return( 1 );
; 347  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	eax, 1
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
omf_fill_logref ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
;	COMDAT TranslateLogref
_TEXT	SEGMENT
lr$ = 8
buf$ = 16
type$ = 24
TranslateLogref PROC					; COMDAT

; 121  :     uint_8  *p;
; 122  :     uint_8  target;
; 123  : 
; 124  :     /**/myassert( lr != NULL );
; 125  :     /**/myassert( buf != NULL );
; 126  :     /**/myassert( type == FIX_GEN_INTEL || type == FIX_GEN_MS386 );
; 127  : 
; 128  :     /*
; 129  :      * According to the discussion on p102 of the Intel OMF document, we
; 130  :      * cannot just arbitrarily write fixups without a displacment if their
; 131  :      * displacement field is 0.  So we use the is_secondary field.
; 132  :      */
; 133  :     target = lr->target;
; 134  :     if( lr->target_offset == 0 && lr->is_secondary ) {

	cmp	DWORD PTR [rcx+8], 0
	mov	r11d, r8d
	movzx	r9d, BYTE PTR [rcx+5]
	mov	r10, rdx
	jne	SHORT $LN2@TranslateL
	cmp	BYTE PTR [rcx+4], 0
	je	SHORT $LN2@TranslateL

; 135  :         target |= 0x04; /* P=1 -> no displacement field */

	or	r9b, 4
$LN2@TranslateL:

; 136  :     }
; 137  :     p = buf;
; 138  :     /* write the "Fix Data" field, FfffTPtt:
; 139  :      * F  : 0 = frame method is defined in fff field ( F0-F5)
; 140  :      *      1 = frame is defined by a thread ( won't occur here )
; 141  :      * fff: frame method
; 142  :      * T  : 0 = target is defined by tt
; 143  :      *      1 = target is defined by thread# in tt, P is used as bit 2 for method
; 144  :      * P  : 0 = target displacement field is present
; 145  :      *      1 = no displacement field
; 146  :      * tt : target method
; 147  :      */
; 148  :     *p++ = ( lr->frame << 4 ) | ( target );

	movzx	eax, BYTE PTR [rcx]
	shl	al, 4
	or	al, r9b
	mov	BYTE PTR [rdx], al
	inc	rdx

; 149  :     p = putFrameDatum( p, lr->frame, lr->frame_datum );

	cmp	BYTE PTR [rcx], 2
	movzx	r8d, WORD PTR [rcx+2]
	ja	SHORT $LN8@TranslateL
	cmp	r8w, 127				; 0000007fH
	jbe	SHORT $LN13@TranslateL
	movzx	eax, r8w
	shr	ax, 8
	or	al, 128					; 00000080H
	mov	BYTE PTR [rdx], al
	inc	rdx
$LN13@TranslateL:
	mov	BYTE PTR [rdx], r8b
	inc	rdx
$LN8@TranslateL:

; 150  :     p = putTargetDatum( p, target, lr->target_datum );

	movzx	r8d, WORD PTR [rcx+6]
	cmp	r8w, 127				; 0000007fH
	jbe	SHORT $LN18@TranslateL
	movzx	eax, r8w
	shr	ax, 8
	or	al, 128					; 00000080H
	mov	BYTE PTR [rdx], al
	inc	rdx
$LN18@TranslateL:
	mov	BYTE PTR [rdx], r8b
	inc	rdx

; 151  :     if( ( target & 0x04 ) == 0 ) {

	test	r9b, 4
	jne	SHORT $LN5@TranslateL

; 152  :         if( type == FIX_GEN_MS386 ) {

	cmp	r11d, 1
	jne	SHORT $LN4@TranslateL

; 153  :             p = put32( p, (uint_32)lr->target_offset );

	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rdx], eax
	add	rdx, 4

; 156  :         }
; 157  :     }
; 158  :     return( p - buf );

	sub	rdx, r10
	mov	eax, edx

; 159  : }

	ret	0
$LN4@TranslateL:

; 154  :         } else {
; 155  :             p = put16( p, (uint_16)lr->target_offset );

	movzx	ecx, WORD PTR [rcx+8]
	mov	WORD PTR [rdx], cx
	add	rdx, 2
$LN5@TranslateL:

; 156  :         }
; 157  :     }
; 158  :     return( p - buf );

	sub	rdx, r10
	mov	eax, edx

; 159  : }

	ret	0
TranslateLogref ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
;	COMDAT putTargetDatum
_TEXT	SEGMENT
p$ = 8
method$ = 16
datum$ = 24
putTargetDatum PROC					; COMDAT

; 98   : #if 0 /* v2.12: HJWasm won't use TARGE_ABSxx; also, it's not defined for FIXUP sub-records */
; 99   :     if( ( method & 0x03 ) == TARGET_ABSWD ) {
; 100  :         return( put16( p, datum ) );
; 101  :     }
; 102  : #endif
; 103  :     return( putIndex( p, datum ) );

	cmp	r8w, 127				; 0000007fH
	jbe	SHORT $LN4@putTargetD
	movzx	eax, r8w
	shr	ax, 8
	or	al, 128					; 00000080H
	mov	BYTE PTR [rcx], al
	inc	rcx
$LN4@putTargetD:
	mov	BYTE PTR [rcx], r8b
	lea	rax, QWORD PTR [rcx+1]

; 104  : }

	ret	0
putTargetDatum ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
;	COMDAT putFrameDatum
_TEXT	SEGMENT
p$ = 8
method$ = 16
datum$ = 24
putFrameDatum PROC					; COMDAT

; 81   :     switch( method ) {

	cmp	dl, 2
	ja	SHORT $LN2@putFrameDa

; 82   :     case FRAME_SEG:
; 83   :     case FRAME_GRP:
; 84   :     case FRAME_EXT:
; 85   :         return( putIndex( p, datum ) );

	cmp	r8w, 127				; 0000007fH
	jbe	SHORT $LN7@putFrameDa
	movzx	eax, r8w
	shr	ax, 8
	or	al, 128					; 00000080H
	mov	BYTE PTR [rcx], al
	inc	rcx
$LN7@putFrameDa:
	mov	BYTE PTR [rcx], r8b
	lea	rax, QWORD PTR [rcx+1]

; 93   : }

	ret	0
$LN2@putFrameDa:

; 86   : #if 0  /* v2.12: FRAME_ABS is invalid according to TIS OMF docs. */
; 87   :     case FRAME_ABS:
; 88   :         return( put16( p, datum ) );
; 89   : #endif
; 90   :     }
; 91   :     /* for FRAME_LOC & FRAME_TARG ( & FRAME_NONE ) there's no datum to write. */
; 92   :     return( p );

	mov	rax, rcx

; 93   : }

	ret	0
putFrameDatum ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
;	COMDAT put32
_TEXT	SEGMENT
p$ = 8
value$ = 16
put32	PROC						; COMDAT

; 74   :     WriteU32( p, value );

	mov	DWORD PTR [rcx], edx

; 75   :     return( p + sizeof( uint_32 ) );

	lea	rax, QWORD PTR [rcx+4]

; 76   : }

	ret	0
put32	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
;	COMDAT put16
_TEXT	SEGMENT
p$ = 8
value$ = 16
put16	PROC						; COMDAT

; 67   :     WriteU16( p, value );

	mov	WORD PTR [rcx], dx

; 68   :     return( p + sizeof( uint_16 ) );

	lea	rax, QWORD PTR [rcx+2]

; 69   : }

	ret	0
put16	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
;	COMDAT putIndex
_TEXT	SEGMENT
p$ = 8
index$ = 16
putIndex PROC						; COMDAT

; 57   :     if( index > 0x7f ) {

	cmp	dx, 127					; 0000007fH
	jbe	SHORT $LN2@putIndex

; 58   :         *p++ = 0x80 | ( index >> 8 );

	movzx	eax, dx
	shr	ax, 8
	or	al, 128					; 00000080H
	mov	BYTE PTR [rcx], al
	inc	rcx
$LN2@putIndex:

; 59   :     }
; 60   :     *p++ = index;

	mov	BYTE PTR [rcx], dl
	lea	rax, QWORD PTR [rcx+1]

; 61   :     return( p );
; 62   : }

	ret	0
putIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
_TEXT	SEGMENT
lr$ = 32
fixup$ = 80
buf$ = 88
displ$ = 96
type$ = 104
OmfFixGenFixModend PROC

; 194  : {

$LN32:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	rsi, rcx
	mov	r12d, r9d

; 195  :     struct asym *sym = fixup->sym;

	mov	rcx, QWORD PTR [rcx+56]
	mov	r14, rdx

; 196  :     struct logref lr;
; 197  : 
; 198  :     lr.is_secondary = FALSE;
; 199  :     lr.target_offset = sym->offset + displ;
; 200  : 
; 201  :     lr.frame_datum = fixup->frame_datum;

	movzx	edi, WORD PTR [rsi+42]
	mov	r15d, DWORD PTR [rcx+16]
	add	r15d, r8d
	mov	WORD PTR lr$[rsp+2], di

; 202  : 
; 203  :     /* symbol is always a code label (near or far), internal or external */
; 204  :     /* now set Target and Frame */
; 205  : 
; 206  :     if( sym->state == SYM_EXTERNAL ) {

	cmp	DWORD PTR [rcx+32], 2
	mov	DWORD PTR lr$[rsp+8], r15d
	jne	SHORT $LN2@OmfFixGenF

; 207  :         DebugMsg(("omf_write_modend(%p): fixup->frame_type/datum=%u/%u, EXTERNAL sym=%s\n",
; 208  :                   fixup, fixup->frame_type, fixup->frame_datum, sym->name));
; 209  : 
; 210  :         lr.target = TARGET_EXT & TARGET_WITH_DISPL;
; 211  :         lr.target_datum = sym->ext_idx1;
; 212  : 
; 213  :         if( fixup->frame_type == FRAME_GRP && fixup->frame_datum == 0 ) {

	cmp	BYTE PTR [rsi+40], 1
	mov	bpl, 2
	movzx	ebx, WORD PTR [rcx+88]
	mov	WORD PTR lr$[rsp+6], bx
	jne	SHORT $LN3@OmfFixGenF
	test	di, di
	jne	SHORT $LN3@OmfFixGenF

; 214  :             /* set the frame to the frame of the corresponding segment */
; 215  :             lr.frame_datum = omf_GetGrpIdx( sym );

	call	omf_GetGrpIdx
	mov	edi, eax
	mov	WORD PTR lr$[rsp+2], ax

; 216  :         }
; 217  :     } else { /* SYM_INTERNAL */

	jmp	SHORT $LN3@OmfFixGenF
$LN2@OmfFixGenF:

; 218  :         DebugMsg(("OmfFixGenFixModend(%p): fixup->frame_type/datum=%u/%u sym->name=%s state=%X segm=%s\n",
; 219  :                   fixup, fixup->frame_type, fixup->frame_datum, sym->name, sym->state, sym->segment ? sym->segment->name : "NULL" ));
; 220  :         /**/myassert( sym->state == SYM_INTERNAL );
; 221  : 
; 222  :         lr.target = TARGET_SEG & TARGET_WITH_DISPL;
; 223  :         lr.target_datum = GetSegIdx( sym->segment );

	mov	rcx, QWORD PTR [rcx+24]
	xor	bpl, bpl
	call	GetSegIdx
	mov	ebx, eax
	mov	WORD PTR lr$[rsp+6], ax
$LN3@OmfFixGenF:

; 224  :     }
; 225  : 
; 226  :     if( fixup->frame_type != FRAME_NONE && fixup->frame_type != FRAME_SEG ) {

	movzx	edx, BYTE PTR [rsi+40]
	cmp	dl, 6
	je	SHORT $LN5@OmfFixGenF
	test	dl, dl
	jne	SHORT $LN6@OmfFixGenF
$LN5@OmfFixGenF:

; 227  :         lr.frame = (uint_8)fixup->frame_type;
; 228  :     } else {
; 229  :         lr.frame = FRAME_TARG;

	mov	dl, 5
$LN6@OmfFixGenF:

; 230  :     }
; 231  :     return( TranslateLogref( &lr, buf, type ) );

	movzx	eax, dl
	lea	rcx, QWORD PTR [r14+1]
	shl	al, 4
	or	al, bpl
	mov	BYTE PTR [r14], al
	cmp	dl, 2
	ja	SHORT $LN15@OmfFixGenF
	cmp	di, 127					; 0000007fH
	jbe	SHORT $LN20@OmfFixGenF
	shr	di, 8
	or	dil, 128				; 00000080H
	mov	BYTE PTR [rcx], dil
	inc	rcx
$LN20@OmfFixGenF:
	movzx	eax, BYTE PTR lr$[rsp+2]
	mov	BYTE PTR [rcx], al
	inc	rcx
$LN15@OmfFixGenF:
	cmp	bx, 127					; 0000007fH
	jbe	SHORT $LN25@OmfFixGenF
	shr	bx, 8
	or	bl, 128					; 00000080H
	mov	BYTE PTR [rcx], bl
	inc	rcx
$LN25@OmfFixGenF:
	movzx	eax, BYTE PTR lr$[rsp+6]
	mov	BYTE PTR [rcx], al
	lea	rax, QWORD PTR [rcx+1]
	test	bpl, 4
	jne	SHORT $LN12@OmfFixGenF
	cmp	r12d, 1
	jne	SHORT $LN11@OmfFixGenF
	mov	DWORD PTR [rax], r15d
	add	rax, 4
	jmp	SHORT $LN12@OmfFixGenF
$LN11@OmfFixGenF:
	movzx	ecx, WORD PTR lr$[rsp+8]
	mov	WORD PTR [rax], cx
	add	rax, 2
$LN12@OmfFixGenF:

; 232  : }

	mov	rbx, QWORD PTR [rsp+80]
	sub	rax, r14
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	ret	0
OmfFixGenFixModend ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
_TEXT	SEGMENT
lr$ = 32
fixup$ = 80
start_loc$ = 88
buf$ = 96
type$ = 104
OmfFixGenFix PROC

; 370  : {

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 371  :     uint_8  locat1;
; 372  :     uint_8  self_relative = FALSE;
; 373  :     unsigned data_rec_offset;
; 374  :     struct logref lr;
; 375  : 
; 376  :     /**/myassert( fixup != NULL );
; 377  :     /**/myassert( buf != NULL );
; 378  :     /**/myassert( type == FIX_GEN_INTEL || type == FIX_GEN_MS386 );
; 379  : 
; 380  :     lr.is_secondary = TRUE;
; 381  :     lr.target_offset = 0;
; 382  : 
; 383  :     switch( fixup->type ) {

	mov	eax, DWORD PTR [rcx+24]
	xor	sil, sil
	dec	eax
	mov	BYTE PTR lr$[rsp+4], 1
	mov	DWORD PTR lr$[rsp+8], 0
	mov	ebp, r9d
	mov	r14, r8
	mov	r15d, edx
	mov	rdi, rcx
	cmp	eax, 10
	ja	$LN14@OmfFixGenF
	lea	rcx, OFFSET FLAT:__ImageBase
	cdqe
	mov	r9d, DWORD PTR $LN19@OmfFixGenF[rcx+rax*4]
	add	r9, rcx
	jmp	r9
$LN4@OmfFixGenF:

; 384  :     case FIX_RELOFF8:
; 385  :         self_relative = TRUE;

	mov	sil, 1
$LN5@OmfFixGenF:

; 386  :         /* no break */
; 387  :     case FIX_OFF8:
; 388  :         locat1 = ( LOC_OFFSET_LO << 2 );

	xor	bl, bl

; 389  :         break;

	jmp	SHORT $LN2@OmfFixGenF
$LN6@OmfFixGenF:

; 390  :     case FIX_RELOFF16:
; 391  :         self_relative = TRUE;

	mov	sil, 1
$LN7@OmfFixGenF:

; 392  :         /* no break */
; 393  :     case FIX_OFF16:
; 394  :         locat1 = ( fixup->loader_resolved ? LOC_MS_LINK_OFFSET << 2 : LOC_OFFSET << 2 );

	movzx	ebx, BYTE PTR [rdi+33]
	and	bl, 1
	shl	bl, 4
	or	bl, 4

; 395  :         break;

	jmp	SHORT $LN2@OmfFixGenF
$LN8@OmfFixGenF:

; 396  :     case FIX_RELOFF32:
; 397  :         self_relative = TRUE;

	mov	sil, 1
$LN9@OmfFixGenF:

; 398  :         /* no break */
; 399  :     case FIX_OFF32:
; 400  :         locat1 = ( fixup->loader_resolved ? LOC_MS_LINK_OFFSET_32 << 2 : LOC_MS_OFFSET_32 << 2 );

	movzx	ebx, BYTE PTR [rdi+33]
	and	bl, 1
	shl	bl, 4
	or	bl, 36					; 00000024H

; 401  :         break;

	jmp	SHORT $LN2@OmfFixGenF
$LN10@OmfFixGenF:

; 402  :     case FIX_HIBYTE:
; 403  :         locat1 = ( LOC_OFFSET_HI << 2 );

	mov	bl, 16

; 404  :         break;

	jmp	SHORT $LN2@OmfFixGenF
$LN11@OmfFixGenF:

; 405  :     case FIX_SEG:
; 406  :         locat1 = ( LOC_BASE << 2 );

	mov	bl, 8

; 407  :         break;

	jmp	SHORT $LN2@OmfFixGenF
$LN12@OmfFixGenF:

; 408  :     case FIX_PTR16:
; 409  :         locat1 = ( LOC_BASE_OFFSET << 2 );

	mov	bl, 12

; 410  :         break;

	jmp	SHORT $LN2@OmfFixGenF
$LN13@OmfFixGenF:

; 411  :     case FIX_PTR32:
; 412  :         locat1 = ( LOC_MS_BASE_OFFSET_32 << 2 );

	mov	bl, 44					; 0000002cH
$LN2@OmfFixGenF:

; 419  :     }
; 420  :     locat1 |= self_relative ? 0x80 : 0xc0; /* bit 7: 1=is a fixup subrecord */
; 421  : 
; 422  :     if ( omf_fill_logref( fixup, &lr ) == 0 )

	lea	rdx, QWORD PTR lr$[rsp]
	mov	rcx, rdi
	call	omf_fill_logref
	test	eax, eax
	je	SHORT $LN20@OmfFixGenF

; 423  :         return( 0 );
; 424  : 
; 425  :     /* magnitude of fixup's position is 10! */
; 426  :     /**/myassert( fixup->locofs - start_loc < 1024 );
; 427  : 
; 428  :     /* calculate the fixup's position in current LEDATA */
; 429  :     data_rec_offset = fixup->locofs - start_loc;

	mov	edx, DWORD PTR [rdi+20]
	mov	eax, 128				; 00000080H
	sub	edx, r15d
	mov	ecx, 192				; 000000c0H

; 430  : 
; 431  :     locat1 |= data_rec_offset >> 8;
; 432  :     *buf = locat1;
; 433  :     *(buf+1) = (uint_8)data_rec_offset;

	mov	BYTE PTR [r14+1], dl
	test	sil, sil

; 434  :     return( 2 + TranslateLogref( &lr, buf+2, type ) );

	mov	r8d, ebp
	cmovne	ecx, eax
	mov	eax, edx
	shr	eax, 8
	lea	rdx, QWORD PTR [r14+2]
	or	cl, al
	or	cl, bl
	mov	BYTE PTR [r14], cl
	lea	rcx, QWORD PTR lr$[rsp]
	call	TranslateLogref
	add	eax, 2
	jmp	SHORT $LN1@OmfFixGenF
$LN14@OmfFixGenF:

; 413  :         break;
; 414  :     default: /* shouldn't happen. Check for valid fixup has already happened */
; 415  :         EmitErr( UNSUPPORTED_FIXUP_TYPE,

	mov	rax, QWORD PTR [rdi+56]
	test	rax, rax
	je	SHORT $LN17@OmfFixGenF
	mov	r8, QWORD PTR [rax+8]
	jmp	SHORT $LN18@OmfFixGenF
$LN17@OmfFixGenF:
	lea	r8, OFFSET FLAT:szNull
$LN18@OmfFixGenF:
	mov	rdx, QWORD PTR ModuleInfo+344
	mov	ecx, 197				; 000000c5H
	add	rdx, 10
	call	EmitErr
$LN20@OmfFixGenF:

; 416  :                ModuleInfo.fmtopt->formatname,
; 417  :                fixup->sym ? fixup->sym->name : szNull );
; 418  :         return( 0 );

	xor	eax, eax
$LN1@OmfFixGenF:

; 435  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
	npad	3
$LN19@OmfFixGenF:
	DD	$LN4@OmfFixGenF
	DD	$LN6@OmfFixGenF
	DD	$LN8@OmfFixGenF
	DD	$LN5@OmfFixGenF
	DD	$LN7@OmfFixGenF
	DD	$LN9@OmfFixGenF
	DD	$LN14@OmfFixGenF
	DD	$LN11@OmfFixGenF
	DD	$LN12@OmfFixGenF
	DD	$LN13@OmfFixGenF
	DD	$LN10@OmfFixGenF
OmfFixGenFix ENDP
_TEXT	ENDS
END
