; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG10626 DB	'F__RQQ', 00H
_DATA	ENDS
PUBLIC	AddFloatingPointEmulationFixup
EXTRN	SymFind:PROC
EXTRN	MakeExtern:PROC
EXTRN	CreateFixup:PROC
EXTRN	store_fixup:PROC
EXTRN	omf_FlushCurrSeg:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	write_to_file:BYTE
pdata	SEGMENT
$pdata$AddFloatingPointEmulationFixup DD imagerel $LN28
	DD	imagerel $LN28+355
	DD	imagerel $unwind$AddFloatingPointEmulationFixup
pdata	ENDS
CONST	SEGMENT
patchchr2 DB	057H
	DB	044H
	DB	045H
	DB	043H
	DB	053H
	DB	041H
	DB	046H
	DB	047H
CONST	ENDS
xdata	SEGMENT
$unwind$AddFloatingPointEmulationFixup DD 081001H
	DD	0103410H
	DD	0f00c7210H
	DD	07008e00aH
	DD	050066007H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\fpfixup.c
_TEXT	SEGMENT
sym$ = 48
data$ = 112
CodeInfo$ = 112
name$ = 120
AddFloatingPointEmulationFixup PROC

; 68   : {

$LN28:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H

; 69   :     int i;
; 70   :     enum fp_patches patch;
; 71   :     struct asym *sym[2];
; 72   :     struct fixup *fixup;
; 73   :     int_32 data;
; 74   :     char name[8] = "F__RQQ";

	mov	eax, DWORD PTR $SG10626

; 75   : 
; 76   :     DebugMsg(("AddFloatingPointEmulationFixup enter, token=%u, regoverride=%d\n", CodeInfo->token, CodeInfo->prefix.RegOverride ));
; 77   : 
; 78   :     if( CodeInfo->token == T_FWAIT ) {

	xor	ebp, ebp
	mov	DWORD PTR name$[rsp], eax
	movzx	eax, WORD PTR $SG10626+4
	mov	WORD PTR name$[rsp+4], ax
	movzx	eax, BYTE PTR $SG10626+6
	mov	BYTE PTR name$[rsp+6], al
	xor	eax, eax
	cmp	DWORD PTR [rcx+24], 833			; 00000341H
	mov	BYTE PTR name$[rsp+7], al
	jne	SHORT $LN8@AddFloatin

; 79   :         patch = FPP_WAIT;

	mov	edi, ebp
	jmp	SHORT $LN11@AddFloatin
$LN8@AddFloatin:

; 80   :     } else if ( CodeInfo->prefix.RegOverride == EMPTY ) {

	mov	edi, DWORD PTR [rcx+4]
	cmp	edi, -2
	jne	SHORT $LN10@AddFloatin

; 81   :         patch = FPP_NORMAL;

	mov	edi, 1

; 82   :     } else {

	jmp	SHORT $LN11@AddFloatin
$LN10@AddFloatin:

; 83   :         patch = CodeInfo->prefix.RegOverride + 2;

	add	edi, 2
$LN11@AddFloatin:

; 84   :     }
; 85   : 
; 86   :     /* emit 1-2 externals for the patch if not done already */
; 87   :     for ( i = 0; i < 2; i++ ) {

	mov	esi, ebp
	movsxd	r14, edi
	lea	rbx, QWORD PTR sym$[rsp]
	lea	r15, OFFSET FLAT:patchchr2
	npad	7
$LL4@AddFloatin:

; 88   :         sym[i] = NULL;
; 89   :         if ( patchmask & ( 1 << ( i*8+patch ) ) ) {

	mov	ecx, edi
	mov	QWORD PTR [rbx], rbp
	mov	eax, 1
	shl	eax, cl
	test	eax, 63743				; 0000f8ffH
	je	SHORT $LN2@AddFloatin

; 90   :             name[1] = 'I' + i;

	lea	eax, DWORD PTR [rsi+73]
	mov	BYTE PTR name$[rsp+1], al

; 91   :             name[2] = patchchr2[patch];
; 92   :             sym[i] = SymSearch( name );

	lea	rcx, QWORD PTR name$[rsp]
	movzx	eax, BYTE PTR [r14+r15]
	mov	BYTE PTR name$[rsp+2], al
	call	SymFind
	mov	QWORD PTR [rbx], rax

; 93   :             if( sym[i] == NULL || sym[i]->state == SYM_UNDEFINED ) {

	test	rax, rax
	je	SHORT $LN14@AddFloatin
	cmp	DWORD PTR [rax+32], ebp
	jne	SHORT $LN2@AddFloatin
$LN14@AddFloatin:

; 94   :                 sym[i] = MakeExtern( name, MT_FAR, NULL, sym[i], USE16 );

	mov	r9, rax
	mov	BYTE PTR [rsp+32], bpl
	xor	r8d, r8d
	lea	rcx, QWORD PTR name$[rsp]
	mov	edx, 130				; 00000082H
	call	MakeExtern
	mov	QWORD PTR [rbx], rax

; 95   :                 sym[i]->langtype = LANG_NONE;

	mov	DWORD PTR [rax+76], ebp
$LN2@AddFloatin:

; 84   :     }
; 85   : 
; 86   :     /* emit 1-2 externals for the patch if not done already */
; 87   :     for ( i = 0; i < 2; i++ ) {

	inc	esi
	add	edi, 8
	add	rbx, 8
	cmp	esi, 2
	jl	SHORT $LL4@AddFloatin

; 96   :             }
; 97   :         }
; 98   :     }
; 99   : 
; 100  :     /* no need for fixups if no object file is written */
; 101  :     if ( write_to_file == FALSE )

	cmp	BYTE PTR write_to_file, bpl
	je	SHORT $LN6@AddFloatin

; 102  :         return;
; 103  : 
; 104  :     /* make sure the next 3 bytes in code stream aren't separated.
; 105  :      * The first fixup covers bytes $+0 and $+1, the (possible) second
; 106  :      * fixup covers bytes $+1 and $+2.
; 107  :      */
; 108  :     if( Options.output_format == OFORMAT_OMF &&

	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN16@AddFloatin
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rcx+12]
	sub	eax, DWORD PTR [rcx+8]
	add	eax, 3
	cmp	eax, 1014				; 000003f6H
	jbe	SHORT $LN16@AddFloatin

; 109  :        ( CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc + 3 ) > MAX_LEDATA_THRESHOLD )
; 110  :         omf_FlushCurrSeg();

	call	omf_FlushCurrSeg
$LN16@AddFloatin:

; 111  : 
; 112  :     for ( i = 0; i < 2 ; i++ ) {

	mov	ebx, ebp
	npad	4
$LL7@AddFloatin:

; 113  :         if ( sym[i] ) {

	movsxd	rax, ebx
	mov	rcx, QWORD PTR sym$[rsp+rax*8]
	test	rcx, rcx
	je	SHORT $LN5@AddFloatin

; 114  :             fixup = CreateFixup( sym[i], FIX_OFF16, OPTJ_NONE );

	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+5]
	call	CreateFixup

; 115  :             fixup->frame_type = FRAME_TARG;
; 116  :             /* assume locofs has been set inside CreateFixup() */
; 117  :             //fixup->locofs = CurrSeg->e.seginfo->current_loc + i;
; 118  :             fixup->locofs += i;
; 119  :             data = 0;
; 120  :             store_fixup( fixup, CurrSeg, &data );

	lea	r8, QWORD PTR data$[rsp]
	mov	rcx, rax
	add	DWORD PTR [rax+20], ebx
	mov	BYTE PTR [rax+40], 5
	mov	rdx, QWORD PTR ModuleInfo+432
	mov	DWORD PTR data$[rsp], ebp
	call	store_fixup
$LN5@AddFloatin:

; 111  : 
; 112  :     for ( i = 0; i < 2 ; i++ ) {

	inc	ebx
	cmp	ebx, 2
	jl	SHORT $LL7@AddFloatin
$LN6@AddFloatin:

; 121  :         }
; 122  :     }
; 123  :     return;
; 124  : }

	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
AddFloatingPointEmulationFixup ENDP
_TEXT	ENDS
END
