; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11306 DB	'.shstrtab', 00H
	ORG $+6
$SG11307 DB	'.symtab', 00H
$SG11308 DB	'.strtab', 00H
$SG11331 DB	'_TEXT', 00H
	ORG $+2
$SG11332 DB	'.text', 00H
	ORG $+2
$SG11333 DB	'_DATA', 00H
	ORG $+2
$SG11334 DB	'.data', 00H
	ORG $+2
$SG11335 DB	'CONST', 00H
	ORG $+2
$SG11336 DB	'.rodata', 00H
$SG11337 DB	'_BSS', 00H
	ORG $+3
$SG11338 DB	'.bss', 00H
	ORG $+3
$SG11540 DB	'.rela', 00H
	ORG $+2
$SG11541 DB	'.rel', 00H
	ORG $+3
$SG11597 DB	'CONST', 00H
	ORG $+2
$SG11646 DB	'CONST', 00H
	ORG $+2
$SG11747 DB	07fH, 'ELF', 00H
	ORG $+3
$SG11750 DB	07fH, 'ELF', 00H
_DATA	ENDS
CONST	SEGMENT
internal_segparms DQ FLAT:$SG11306
	DD	03H
	ORG $+4
	DQ	FLAT:$SG11307
	DD	02H
	ORG $+4
	DQ	FLAT:$SG11308
	DD	03H
	ORG $+4
cst	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11331
	DQ	FLAT:$SG11332
	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11333
	DQ	FLAT:$SG11334
	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11335
	DQ	FLAT:$SG11336
	DB	04H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG11337
	DQ	FLAT:$SG11338
CONST	ENDS
PUBLIC	elf_init
EXTRN	fseek:PROC
EXTRN	fwrite:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	WriteError:PROC
EXTRN	LclAlloc:PROC
EXTRN	Mangle:PROC
EXTRN	GetSegIdx:PROC
EXTRN	memcmp:PROC
EXTRN	memset:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	SymTables:BYTE
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$ElfConvertSectionName DD imagerel ElfConvertSectionName
	DD	imagerel ElfConvertSectionName+272
	DD	imagerel $unwind$ElfConvertSectionName
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_symtab32 DD imagerel set_symtab32
	DD	imagerel set_symtab32+300
	DD	imagerel $unwind$set_symtab32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$set_symtab32 DD imagerel set_symtab32+300
	DD	imagerel set_symtab32+585
	DD	imagerel $chain$0$set_symtab32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_symtab64 DD imagerel set_symtab64
	DD	imagerel set_symtab64+302
	DD	imagerel $unwind$set_symtab64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$set_symtab64 DD imagerel set_symtab64+302
	DD	imagerel set_symtab64+591
	DD	imagerel $chain$0$set_symtab64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_symtab_values DD imagerel set_symtab_values
	DD	imagerel set_symtab_values+7
	DD	imagerel $unwind$set_symtab_values
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$set_symtab_values DD imagerel set_symtab_values+7
	DD	imagerel set_symtab_values+101
	DD	imagerel $chain$1$set_symtab_values
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$set_symtab_values DD imagerel set_symtab_values+101
	DD	imagerel set_symtab_values+277
	DD	imagerel $chain$3$set_symtab_values
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$set_symtab_values DD imagerel set_symtab_values+277
	DD	imagerel set_symtab_values+304
	DD	imagerel $chain$4$set_symtab_values
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$set_symtab_values DD imagerel set_symtab_values+304
	DD	imagerel set_symtab_values+544
	DD	imagerel $chain$5$set_symtab_values
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$set_symtab_values DD imagerel set_symtab_values+544
	DD	imagerel set_symtab_values+629
	DD	imagerel $chain$6$set_symtab_values
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_shstrtab_values DD imagerel set_shstrtab_values
	DD	imagerel set_shstrtab_values+605
	DD	imagerel $unwind$set_shstrtab_values
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$elf_write_section_table32 DD imagerel elf_write_section_table32
	DD	imagerel elf_write_section_table32+915
	DD	imagerel $unwind$elf_write_section_table32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$elf_write_section_table64 DD imagerel elf_write_section_table64
	DD	imagerel elf_write_section_table64+1008
	DD	imagerel $unwind$elf_write_section_table64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$write_relocs32 DD imagerel write_relocs32
	DD	imagerel write_relocs32+31
	DD	imagerel $unwind$write_relocs32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$write_relocs32 DD imagerel write_relocs32+31
	DD	imagerel write_relocs32+281
	DD	imagerel $chain$1$write_relocs32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$write_relocs32 DD imagerel write_relocs32+281
	DD	imagerel write_relocs32+340
	DD	imagerel $chain$2$write_relocs32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$write_relocs64 DD imagerel write_relocs64
	DD	imagerel write_relocs64+30
	DD	imagerel $unwind$write_relocs64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$write_relocs64 DD imagerel write_relocs64+30
	DD	imagerel write_relocs64+311
	DD	imagerel $chain$2$write_relocs64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$write_relocs64 DD imagerel write_relocs64+311
	DD	imagerel write_relocs64+372
	DD	imagerel $chain$3$write_relocs64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$elf_write_data DD imagerel elf_write_data
	DD	imagerel elf_write_data+351
	DD	imagerel $unwind$elf_write_data
pdata	ENDS
pdata	SEGMENT
$pdata$elf_write_module DD imagerel elf_write_module
	DD	imagerel elf_write_module+552
	DD	imagerel $unwind$elf_write_module
pdata	ENDS
xdata	SEGMENT
$unwind$elf_write_module DD 051201H
	DD	0183412H
	DD	0160112H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$elf_write_data DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$write_relocs64 DD 021H
	DD	imagerel write_relocs64
	DD	imagerel write_relocs64+30
	DD	imagerel $unwind$write_relocs64
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$write_relocs64 DD 060f21H
	DD	0ee40fH
	DD	0d740aH
	DD	0c5405H
	DD	imagerel write_relocs64
	DD	imagerel write_relocs64+30
	DD	imagerel $unwind$write_relocs64
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$write_relocs64 DD 040a01H
	DD	0f340aH
	DD	06006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$write_relocs32 DD 021H
	DD	imagerel write_relocs32
	DD	imagerel write_relocs32+31
	DD	imagerel $unwind$write_relocs32
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$write_relocs32 DD 040a21H
	DD	0ce40aH
	DD	0a7405H
	DD	imagerel write_relocs32
	DD	imagerel write_relocs32+31
	DD	imagerel $unwind$write_relocs32
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$write_relocs32 DD 040801H
	DD	060045208H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$elf_write_section_table64 DD 0c1f01H
	DD	014741fH
	DD	013641fH
	DD	012341fH
	DD	0f018b21fH
	DD	0d014e016H
	DD	05010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$elf_write_section_table32 DD 0c1f01H
	DD	012741fH
	DD	011641fH
	DD	010341fH
	DD	0f018921fH
	DD	0d014e016H
	DD	05010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_shstrtab_values DD 0b1d01H
	DD	029741dH
	DD	028641dH
	DD	027541dH
	DD	026341dH
	DD	024011dH
	DD	0e016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$set_symtab_values DD 021H
	DD	imagerel set_symtab_values
	DD	imagerel set_symtab_values+7
	DD	imagerel $unwind$set_symtab_values
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$set_symtab_values DD 020021H
	DD	0ce400H
	DD	imagerel set_symtab_values
	DD	imagerel set_symtab_values+7
	DD	imagerel $unwind$set_symtab_values
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$set_symtab_values DD 021H
	DD	imagerel set_symtab_values+7
	DD	imagerel set_symtab_values+101
	DD	imagerel $chain$1$set_symtab_values
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$set_symtab_values DD 040f21H
	DD	06f40fH
	DD	0b6405H
	DD	imagerel set_symtab_values+7
	DD	imagerel set_symtab_values+101
	DD	imagerel $chain$1$set_symtab_values
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$set_symtab_values DD 041d21H
	DD	0ce41dH
	DD	0a5405H
	DD	imagerel set_symtab_values
	DD	imagerel set_symtab_values+7
	DD	imagerel $unwind$set_symtab_values
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_symtab_values DD 030701H
	DD	070036207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$set_symtab64 DD 020821H
	DD	028e408H
	DD	imagerel set_symtab64
	DD	imagerel set_symtab64+302
	DD	imagerel $unwind$set_symtab64
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_symtab64 DD 0b1b01H
	DD	02b641bH
	DD	02a541bH
	DD	029341bH
	DD	024011bH
	DD	0c012f014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$set_symtab32 DD 020821H
	DD	028e408H
	DD	imagerel set_symtab32
	DD	imagerel set_symtab32+300
	DD	imagerel $unwind$set_symtab32
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_symtab32 DD 0b1b01H
	DD	02b641bH
	DD	02a541bH
	DD	029341bH
	DD	024011bH
	DD	0c012f014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ElfConvertSectionName DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
em$ = 32
modinfo$ = 192
elf_write_module PROC

; 1278 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	lea	rbp, QWORD PTR [rsp-87]
	sub	rsp, 176				; 000000b0H
	mov	rbx, rcx

; 1279 :     //struct dsym  *dir;
; 1280 :     struct elfmod em;
; 1281 : 
; 1282 :     DebugMsg(("elf_write_module: enter\n"));
; 1283 : 
; 1284 :     memset( &em, 0, sizeof( em ) );

	xor	edx, edx
	lea	rcx, QWORD PTR em$[rbp-89]
	mov	r8d, 136				; 00000088H
	call	memset

; 1285 :     em.srcname = CurrFName[ASM];

	mov	r8, QWORD PTR ModuleInfo+128

; 1286 : #if 1
; 1287 :     /* the path part is stripped. todo: check if this is ok to do */
; 1288 :     em.srcname += strlen( em.srcname );

	or	rdx, -1
	mov	rax, r8
	mov	QWORD PTR em$[rbp-81], rax
	npad	8
$LL35@elf_write_:
	inc	rdx
	cmp	BYTE PTR [r8+rdx], 0
	jne	SHORT $LL35@elf_write_
	add	rax, rdx
	mov	QWORD PTR em$[rbp-81], rax

; 1289 :     while ( em.srcname > CurrFName[ASM] &&
; 1290 :            *(em.srcname-1) != '/' &&

	cmp	rax, r8
	jbe	SHORT $LN36@elf_write_
	npad	10
$LL2@elf_write_:
	movzx	ecx, BYTE PTR [rax-1]
	dec	rax
	cmp	cl, 47					; 0000002fH
	je	SHORT $LN36@elf_write_
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN36@elf_write_

; 1291 :            *(em.srcname-1) != '\\') em.srcname--;

	mov	QWORD PTR em$[rbp-81], rax
	cmp	rax, r8
	ja	SHORT $LL2@elf_write_
$LN36@elf_write_:

; 1292 : #endif
; 1293 :     /* position at 0 ( probably unnecessary, since there were no writes yet ) */
; 1294 :     fseek( CurrFile[OBJ], 0, SEEK_SET );

	mov	rcx, QWORD PTR ModuleInfo+104
	xor	r8d, r8d
	xor	edx, edx
	call	fseek

; 1352 :         em.ehdr32.e_shentsize = sizeof( Elf32_Shdr );
; 1353 :         /* calculate # of sections. Add the following internal sections:
; 1354 :          - 1 NULL entry
; 1355 :          - 1 .shstrtab
; 1356 :          - 1 .symtab
; 1357 :          - 1 .strtab
; 1358 :          - n .rel<xxx> entries
; 1359 :          */
; 1360 :         em.ehdr32.e_shnum = 1 + modinfo->g.num_segs + 3 + get_num_reloc_sections();

	mov	rcx, QWORD PTR SymTables+32
	xor	r9d, r9d
	cmp	BYTE PTR [rbx+405], 2
	mov	edx, 1
	mov	BYTE PTR em$[rbp-11], 1
	mov	BYTE PTR em$[rbp-9], 0
	je	$LN6@elf_write_

; 1330 :                                   sizeof( Elf64_Ehdr ) + em.ehdr64.e_shnum * em.ehdr64.e_shentsize );
; 1331 :         break;
; 1332 : #endif
; 1333 :     default:
; 1334 :         memcpy( &em.ehdr32.e_ident, ELF_SIGNATURE, ELF_SIGNATURE_LEN );
; 1335 :         em.ehdr32.e_ident[EI_CLASS] = ELFCLASS32;
; 1336 :         em.ehdr32.e_ident[EI_DATA] = ELFDATA2LSB;
; 1337 :         em.ehdr32.e_ident[EI_VERSION] = EV_CURRENT;
; 1338 :         em.ehdr32.e_ident[EI_OSABI] = modinfo->elf_osabi;
; 1339 :         /* v2.07: set abiversion to 0 */
; 1340 :         //ehdr32.e_ident[EI_ABIVERSION] = EV_CURRENT;
; 1341 :         em.ehdr32.e_ident[EI_ABIVERSION] = 0;
; 1342 :         em.ehdr32.e_type = ET_REL; /* file type */
; 1343 :         em.ehdr32.e_machine = EM_386;
; 1344 :         em.ehdr32.e_version = EV_CURRENT;
; 1345 :         em.ehdr32.e_entry = 0; /* no entry for relocatable objects */
; 1346 :         em.ehdr32.e_phoff = 0; /* no progheaders for relocatable objects */
; 1347 :         em.ehdr32.e_shoff = sizeof( em.ehdr32 );

	mov	eax, DWORD PTR $SG11750
	mov	r8d, 52					; 00000034H
	mov	DWORD PTR em$[rbp-17], eax
	movzx	eax, BYTE PTR [rbx+412]
	mov	BYTE PTR em$[rbp-10], al
	mov	WORD PTR em$[rbp-13], 257		; 00000101H
	mov	DWORD PTR em$[rbp-1], 196609		; 00030001H
	mov	QWORD PTR em$[rbp+3], rdx
	mov	DWORD PTR em$[rbp+11], r9d
	mov	QWORD PTR em$[rbp+15], r8

; 1348 :         em.ehdr32.e_flags = 0;
; 1349 :         em.ehdr32.e_ehsize = sizeof( em.ehdr32 );

	mov	DWORD PTR em$[rbp+23], r8d

; 1350 :         em.ehdr32.e_phentsize = 0; /* no progheaders for relocatable objects */
; 1351 :         em.ehdr32.e_phnum = 0;

	mov	DWORD PTR em$[rbp+27], 2621440		; 00280000H

; 1352 :         em.ehdr32.e_shentsize = sizeof( Elf32_Shdr );
; 1353 :         /* calculate # of sections. Add the following internal sections:
; 1354 :          - 1 NULL entry
; 1355 :          - 1 .shstrtab
; 1356 :          - 1 .symtab
; 1357 :          - 1 .strtab
; 1358 :          - n .rel<xxx> entries
; 1359 :          */
; 1360 :         em.ehdr32.e_shnum = 1 + modinfo->g.num_segs + 3 + get_num_reloc_sections();

	test	rcx, rcx
	je	SHORT $LN19@elf_write_
$LL20@elf_write_:
	mov	rax, QWORD PTR [rcx+96]
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN18@elf_write_
	inc	r9d
$LN18@elf_write_:
	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL20@elf_write_
$LN19@elf_write_:
	movzx	ecx, WORD PTR [rbx+8]
	lea	eax, DWORD PTR [rcx+4]

; 1361 :         em.ehdr32.e_shstrndx = 1 + modinfo->g.num_segs + SHSTRTAB_IDX; /* set index of .shstrtab section */

	inc	cx
	add	ax, r9w
	mov	WORD PTR em$[rbp+33], cx

; 1362 :         if ( fwrite( &em.ehdr32, 1, sizeof( em.ehdr32 ), CurrFile[OBJ] ) != sizeof( em.ehdr32 ) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR em$[rbp-17]
	mov	WORD PTR em$[rbp+31], ax
	call	fwrite
	cmp	rax, 52					; 00000034H
	je	SHORT $LN9@elf_write_

; 1363 :             WriteError();

	call	WriteError
$LN9@elf_write_:

; 1364 :         elf_write_section_table32( modinfo, &em,

	movzx	r8d, WORD PTR em$[rbp+31]
	lea	rdx, QWORD PTR em$[rbp-89]
	movzx	eax, WORD PTR em$[rbp+29]
	mov	rcx, rbx
	imul	r8d, eax
	add	r8d, 52					; 00000034H
	call	elf_write_section_table32
	jmp	$LN4@elf_write_
$LN6@elf_write_:

; 1295 : 
; 1296 :     switch ( modinfo->defOfssize ) {
; 1297 : #if AMD64_SUPPORT
; 1298 :     case USE64:
; 1299 :         memcpy( &em.ehdr64.e_ident, ELF_SIGNATURE, ELF_SIGNATURE_LEN );

	mov	eax, DWORD PTR $SG11747

; 1300 :         em.ehdr64.e_ident[EI_CLASS] = ELFCLASS64;
; 1301 :         em.ehdr64.e_ident[EI_DATA] = ELFDATA2LSB;
; 1302 :         em.ehdr64.e_ident[EI_VERSION] = EV_CURRENT;
; 1303 :         em.ehdr64.e_ident[EI_OSABI] = modinfo->elf_osabi;
; 1304 :         /* v2.07: set abiversion to 0 */
; 1305 :         //ehdr64.e_ident[EI_ABIVERSION] = EV_CURRENT;
; 1306 :         em.ehdr64.e_ident[EI_ABIVERSION] = 0;
; 1307 :         em.ehdr64.e_type = ET_REL; /* file type */
; 1308 :         em.ehdr64.e_machine = EM_X86_64;
; 1309 :         em.ehdr64.e_version = EV_CURRENT;
; 1310 :         em.ehdr64.e_entry = 0; /* no entry for relocatable objects */
; 1311 :         em.ehdr64.e_phoff = 0; /* no progheaders for relocatable objects */
; 1312 :         em.ehdr64.e_shoff = sizeof( em.ehdr64 );

	mov	r8d, 64					; 00000040H
	mov	DWORD PTR em$[rbp-17], eax
	movzx	eax, BYTE PTR [rbx+412]
	mov	BYTE PTR em$[rbp-10], al
	mov	WORD PTR em$[rbp-13], 258		; 00000102H
	mov	DWORD PTR em$[rbp-1], 4063233		; 003e0001H
	mov	DWORD PTR em$[rbp+3], edx
	mov	QWORD PTR em$[rbp+7], r9
	mov	QWORD PTR em$[rbp+15], r9
	mov	QWORD PTR em$[rbp+23], r8

; 1313 :         em.ehdr64.e_flags = 0;

	mov	DWORD PTR em$[rbp+31], r9d

; 1314 :         em.ehdr64.e_ehsize = sizeof( em.ehdr64 );

	mov	DWORD PTR em$[rbp+35], r8d

; 1315 :         em.ehdr64.e_phentsize = 0; /* no progheaders for relocatable objects */
; 1316 :         em.ehdr64.e_phnum = 0;

	mov	DWORD PTR em$[rbp+39], 4194304		; 00400000H

; 1317 :         em.ehdr64.e_shentsize = sizeof( Elf64_Shdr );
; 1318 :         /* calculate # of sections. Add the following internal sections:
; 1319 :          - 1 NULL entry
; 1320 :          - 1 .shstrtab
; 1321 :          - 1 .symtab
; 1322 :          - 1 .strtab
; 1323 :          - n .rela<xxx> sections
; 1324 :          */
; 1325 :         em.ehdr64.e_shnum = 1 + modinfo->g.num_segs + 3 + get_num_reloc_sections();

	test	rcx, rcx
	je	SHORT $LN13@elf_write_
$LL14@elf_write_:
	mov	rax, QWORD PTR [rcx+96]
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN12@elf_write_
	inc	r9d
$LN12@elf_write_:
	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL14@elf_write_
$LN13@elf_write_:
	movzx	ecx, WORD PTR [rbx+8]
	lea	eax, DWORD PTR [rcx+4]

; 1326 :         em.ehdr64.e_shstrndx = 1 + modinfo->g.num_segs + SHSTRTAB_IDX; /* set index of .shstrtab section */

	inc	cx
	add	ax, r9w
	mov	WORD PTR em$[rbp+45], cx

; 1327 :         if ( fwrite( &em.ehdr64, 1, sizeof( em.ehdr64 ), CurrFile[OBJ] ) != sizeof( em.ehdr64 ) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR em$[rbp-17]
	mov	WORD PTR em$[rbp+43], ax
	call	fwrite
	cmp	rax, 64					; 00000040H
	je	SHORT $LN7@elf_write_

; 1328 :             WriteError();

	call	WriteError
$LN7@elf_write_:

; 1329 :         elf_write_section_table64( modinfo, &em,

	movzx	r8d, WORD PTR em$[rbp+43]
	lea	rdx, QWORD PTR em$[rbp-89]
	movzx	eax, WORD PTR em$[rbp+41]
	mov	rcx, rbx
	imul	r8d, eax
	add	r8d, 64					; 00000040H
	call	elf_write_section_table64
$LN4@elf_write_:

; 1365 :                                   sizeof( Elf32_Ehdr ) + em.ehdr32.e_shnum * em.ehdr32.e_shentsize );
; 1366 :     };
; 1367 :     elf_write_data( modinfo, &em );

	lea	rdx, QWORD PTR em$[rbp-89]
	mov	rcx, rbx
	call	elf_write_data

; 1368 :     DebugMsg(("elf_write_module: exit\n"));
; 1369 :     return( NOT_ERROR );
; 1370 : }

	mov	rbx, QWORD PTR [rsp+192]
	xor	eax, eax
	add	rsp, 176				; 000000b0H
	pop	rbp
	ret	0
elf_write_module ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
;	COMDAT elf_write_data
_TEXT	SEGMENT
modinfo$ = 48
em$ = 56
elf_write_data PROC					; COMDAT

; 1220 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1221 :     struct dsym *curr;
; 1222 :     //int seg_index;
; 1223 :     //uint_32 offset = 0;
; 1224 :     uint_32     size;
; 1225 :     int         i;
; 1226 : 
; 1227 :     DebugMsg(("elf_write_data: enter\n"));
; 1228 : 
; 1229 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdi, QWORD PTR SymTables+32
	mov	rsi, rdx
	mov	rbp, rcx
	test	rdi, rdi
	je	SHORT $LN3@elf_write_
	npad	10
$LL4@elf_write_:

; 1230 :         size = curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR [rdi+96]
	mov	ebx, DWORD PTR [rdi+56]
	mov	r8d, DWORD PTR [rax+8]
	sub	ebx, r8d

; 1231 :         DebugMsg(("elf_write_data(%s): program data at ofs=%X, size=%X\n", curr->sym.name, curr->e.seginfo->fileoffset, size ));
; 1232 :         if ( curr->e.seginfo->segtype != SEGTYPE_BSS && size != 0 ) {

	cmp	DWORD PTR [rax+72], 3
	je	SHORT $LN2@elf_write_
	test	ebx, ebx
	je	SHORT $LN2@elf_write_

; 1233 :             fseek( CurrFile[OBJ], curr->e.seginfo->fileoffset + curr->e.seginfo->start_loc, SEEK_SET );

	mov	edx, DWORD PTR [rax+56]
	mov	rcx, QWORD PTR ModuleInfo+104
	add	edx, r8d
	xor	r8d, r8d
	call	fseek

; 1234 :             /**/myassert( curr->e.seginfo->CodeBuffer );
; 1235 :             if ( fwrite( curr->e.seginfo->CodeBuffer, 1, size, CurrFile[OBJ] ) != size )

	mov	rcx, QWORD PTR [rdi+96]
	mov	r8d, ebx
	mov	r9, QWORD PTR ModuleInfo+104
	mov	edx, 1
	mov	rcx, QWORD PTR [rcx+16]
	call	fwrite
	cmp	rax, rbx
	je	SHORT $LN2@elf_write_

; 1236 :                 WriteError();

	call	WriteError
$LN2@elf_write_:

; 1221 :     struct dsym *curr;
; 1222 :     //int seg_index;
; 1223 :     //uint_32 offset = 0;
; 1224 :     uint_32     size;
; 1225 :     int         i;
; 1226 : 
; 1227 :     DebugMsg(("elf_write_data: enter\n"));
; 1228 : 
; 1229 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdi, QWORD PTR [rdi+104]
	test	rdi, rdi
	jne	SHORT $LL4@elf_write_
$LN3@elf_write_:

; 1237 :         }
; 1238 :     }
; 1239 : 
; 1240 :     /* write internal sections */
; 1241 :     for ( i = 0; i < NUM_INTSEGS; i++ ) {

	lea	rbx, QWORD PTR [rsi+32]
	mov	edi, 3
$LL7@elf_write_:

; 1242 :         if ( em->internal_segs[i].data ) {

	cmp	QWORD PTR [rbx], 0
	je	SHORT $LN5@elf_write_

; 1243 :             DebugMsg(("elf_write_data(%s): internal at ofs=%X, size=%X\n", internal_segparms[i].name, em->internal_segs[i].fileoffset, em->internal_segs[i].size));
; 1244 :             fseek( CurrFile[OBJ], em->internal_segs[i].fileoffset, SEEK_SET );

	mov	edx, DWORD PTR [rbx-4]
	xor	r8d, r8d
	mov	rcx, QWORD PTR ModuleInfo+104
	call	fseek

; 1245 :             if ( fwrite( em->internal_segs[i].data, 1, em->internal_segs[i].size, CurrFile[OBJ] ) != em->internal_segs[i].size )

	mov	r8d, DWORD PTR [rbx-8]
	mov	edx, 1
	mov	r9, QWORD PTR ModuleInfo+104
	mov	rcx, QWORD PTR [rbx]
	call	fwrite
	mov	ecx, DWORD PTR [rbx-8]
	cmp	rax, rcx
	je	SHORT $LN5@elf_write_

; 1246 :                 WriteError();

	call	WriteError
$LN5@elf_write_:

; 1237 :         }
; 1238 :     }
; 1239 : 
; 1240 :     /* write internal sections */
; 1241 :     for ( i = 0; i < NUM_INTSEGS; i++ ) {

	add	rbx, 16
	sub	rdi, 1
	jne	SHORT $LL7@elf_write_

; 1247 :         }
; 1248 :     }
; 1249 : 
; 1250 :     /* write reloc sections content */
; 1251 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	test	rbx, rbx
	je	SHORT $LN9@elf_write_
	npad	8
$LL10@elf_write_:

; 1252 :         if ( curr->e.seginfo->num_relocs ) {

	mov	rax, QWORD PTR [rbx+96]
	cmp	DWORD PTR [rax+64], 0
	je	SHORT $LN8@elf_write_

; 1253 :             DebugMsg(("elf_write_data(%s): relocs at ofs=%X, size=%X\n", curr->sym.name, curr->e.seginfo->reloc_offset, curr->e.seginfo->num_relocs * sizeof(Elf32_Rel)));
; 1254 :             fseek( CurrFile[OBJ], curr->e.seginfo->reloc_offset, SEEK_SET );

	mov	edx, DWORD PTR [rax+12]
	xor	r8d, r8d
	mov	rcx, QWORD PTR ModuleInfo+104
	call	fseek

; 1255 : #if AMD64_SUPPORT
; 1256 :             if ( modinfo->defOfssize == USE64 )

	cmp	BYTE PTR [rbp+405], 2
	jne	SHORT $LN16@elf_write_

; 1257 :                 write_relocs64( curr );

	mov	rcx, rbx
	call	write_relocs64
	jmp	SHORT $LN8@elf_write_
$LN16@elf_write_:

; 1258 :             else
; 1259 : #endif
; 1260 :                 write_relocs32( em, curr );

	mov	rdx, rbx
	mov	rcx, rsi
	call	write_relocs32
$LN8@elf_write_:

; 1247 :         }
; 1248 :     }
; 1249 : 
; 1250 :     /* write reloc sections content */
; 1251 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	SHORT $LL10@elf_write_
$LN9@elf_write_:

; 1261 :         }
; 1262 :     }
; 1263 : #if GNURELOCS
; 1264 :     if ( em->extused ) {

	cmp	BYTE PTR [rsi+16], 0
	je	SHORT $LN32@elf_write_

; 1265 :         EmitWarn( 2, ELF_GNU_EXTENSIONS_USED );

	mov	edx, 262				; 00000106H
	mov	ecx, 2
	call	EmitWarn
$LN32@elf_write_:

; 1266 :     }
; 1267 : #endif
; 1268 : 
; 1269 :     DebugMsg(("elf_write_data: exit\n"));
; 1270 : 
; 1271 :     return( NOT_ERROR );
; 1272 : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
elf_write_data ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
;	COMDAT write_relocs64
_TEXT	SEGMENT
reloc64$ = 48
curr$ = 96
write_relocs64 PROC					; COMDAT

; 1132 : {

	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 80					; 00000050H

; 1133 :     uint_8 elftype;
; 1134 :     struct fixup *fixup;
; 1135 :     Elf64_Rela reloc64; /* v2.05: changed to Rela */
; 1136 : 
; 1137 :     DebugMsg(("write_relocs64: enter\n"));
; 1138 :     for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rbx, QWORD PTR [rcx+96]
	mov	rsi, rcx
	mov	rbx, QWORD PTR [rbx+40]
	test	rbx, rbx
	je	$LN3@write_relo
	mov	QWORD PTR [rsp+96], rbp
	mov	QWORD PTR [rsp+104], rdi
	mov	QWORD PTR [rsp+112], r14
	lea	r14, OFFSET FLAT:__ImageBase
	npad	12
$LL4@write_relo:

; 1139 :         unsigned symidx = fixup->sym->ext_idx;

	mov	rax, QWORD PTR [rbx+56]
	mov	ebp, DWORD PTR [rax+88]

; 1140 :         reloc64.r_offset = fixup->locofs;

	mov	eax, DWORD PTR [rbx+20]
	mov	QWORD PTR reloc64$[rsp], rax

; 1141 :         /* v2.07: addend wasn't handled correctly.
; 1142 :          * Also note the type cast for fixup.offset -
; 1143 :          * r_addend has type int_64, while fixup.offset has type uint_32!
; 1144 :          */
; 1145 :         //reloc64.r_addend = fixup->offset;
; 1146 :         /* the following line depends on what's done in store_fixup().
; 1147 :          * if the inline addend is set to 0 there, the fixup->offset
; 1148 :          * must be used in the calculation ( it's 32-bit only!!! ).
; 1149 :          */
; 1150 :         //reloc64.r_addend = (int_32)fixup->offset - fixup->addbytes;
; 1151 :         /*
; 1152 :          * if the inline addend is not touched in store_fixup(),
; 1153 :          * we just have to use the addbytes field.
; 1154 :          */
; 1155 :         reloc64.r_addend = - fixup->addbytes;

	movzx	eax, BYTE PTR [rbx+32]
	neg	eax
	cdqe
	mov	QWORD PTR reloc64$[rsp+16], rax

; 1156 :         DebugMsg(("write_relocs64(): reloc loc=%X type=%u idx=%u sym=%s ofs=%X addbyt=%u\n",
; 1157 :                   fixup->locofs, fixup->type, fixup->sym->ext_idx, fixup->sym->name, fixup->offset, fixup->addbytes ));
; 1158 :         switch ( fixup->type ) {

	mov	r10d, DWORD PTR [rbx+24]
	lea	eax, DWORD PTR [r10-1]
	cmp	eax, 11
	ja	SHORT $LN15@write_relo
	cdqe
	mov	ecx, DWORD PTR $LN24@write_relo[r14+rax*4]
	add	rcx, r14
	jmp	rcx
$LN7@write_relo:

; 1159 :         case FIX_RELOFF32:
; 1160 : #if 0  /* v2.07: activate if the section's index is to be used as symtab ref */
; 1161 :             if ( fixup->sym->segment != &curr->sym ) {
; 1162 :                 //printf("PC-relative fixup to another section: %s\n", fixup->sym->name );
; 1163 :                 reloc64.r_addend += fixup->sym->offset;
; 1164 :                 symidx = fixup->sym->segment->ext_idx;
; 1165 :             }
; 1166 : #endif
; 1167 :             elftype = R_X86_64_PC32;

	mov	dil, 2

; 1168 :             break;

	jmp	SHORT $LN17@write_relo
$LN8@write_relo:

; 1169 :         case FIX_OFF64:        elftype = R_X86_64_64;          break;

	mov	dil, 1
	jmp	SHORT $LN17@write_relo
$LN9@write_relo:

; 1170 :         //case FIX_???:        elftype = R_X86_64_GOT32;       break;
; 1171 :         //case FIX_???:        elftype = R_X86_64_PLT32;       break;
; 1172 :         //case FIX_???:        elftype = R_X86_64_COPY;        break;
; 1173 :         //case FIX_???:        elftype = R_X86_64_GLOB_DAT;    break;
; 1174 :         //case FIX_???:        elftype = R_X86_64_JMP_SLOT;    break;
; 1175 :         case FIX_OFF32_IMGREL: elftype = R_X86_64_RELATIVE;    break;

	mov	dil, 8
	jmp	SHORT $LN17@write_relo
$LN10@write_relo:

; 1176 :         //case FIX_???:        elftype = R_X86_64_GOTPCREL;    break;
; 1177 :         case FIX_OFF32:        elftype = R_X86_64_32;          break;

	mov	dil, 10
	jmp	SHORT $LN17@write_relo
$LN11@write_relo:

; 1178 :         //case FIX_???:        elftype = R_X86_64_32S;         break;
; 1179 :         case FIX_OFF16:        elftype = R_X86_64_16;          break;

	mov	dil, 12
	jmp	SHORT $LN17@write_relo
$LN12@write_relo:

; 1180 :         case FIX_RELOFF16:     elftype = R_X86_64_PC16;        break;

	mov	dil, 13
	jmp	SHORT $LN17@write_relo
$LN13@write_relo:

; 1181 :         case FIX_OFF8:         elftype = R_X86_64_8;           break;

	mov	dil, 14
	jmp	SHORT $LN17@write_relo
$LN14@write_relo:

; 1182 :         case FIX_RELOFF8:      elftype = R_X86_64_PC8;         break;

	mov	dil, 15
	jmp	SHORT $LN17@write_relo
$LN15@write_relo:

; 1183 :         //case FIX_???:        elftype = R_X86_64_DPTMOD64;    break;
; 1184 :         //case FIX_???:        elftype = R_X86_64_DPTOFF64;    break;
; 1185 :         //case FIX_???:        elftype = R_X86_64_TPOFF64;     break;
; 1186 :         //case FIX_???:        elftype = R_X86_64_TLSGD;       break;
; 1187 :         //case FIX_???:        elftype = R_X86_64_TLSLD;       break;
; 1188 :         //case FIX_???:        elftype = R_X86_64_DPTOFF32;    break;
; 1189 :         //case FIX_???:        elftype = R_X86_64_GOTTPOFF;    break;
; 1190 :         //case FIX_???:        elftype = R_X86_64_TPOFF32;     break;
; 1191 :         //case FIX_???:        elftype = R_X86_64_PC64;        break;
; 1192 :         //case FIX_???:        elftype = R_X86_64_GOTOFF64;    break;
; 1193 :         //case FIX_???:        elftype = R_X86_64_GOTPC32;     break;
; 1194 :         //case FIX_???:        elftype = R_X86_64_SIZE32;      break;
; 1195 :         //case FIX_???:        elftype = R_X86_64_SIZE64;      break;
; 1196 :         default:
; 1197 :             DebugMsg(("write_relocs64(): unhandled reloc loc=%X type=%u idx=%u sym=%s\n",
; 1198 :                       fixup->locofs, fixup->type, fixup->sym->ext_idx, fixup->sym->name));
; 1199 :             elftype = R_X86_64_NONE;

	xor	dil, dil

; 1200 :             if ( fixup->type < FIX_LAST ) {

	cmp	r10d, 14
	jge	SHORT $LN16@write_relo

; 1201 :                 EmitErr( INVALID_FIXUP_TYPE, ModuleInfo.fmtopt->formatname, fixup->type, curr->sym.name, fixup->locofs );

	mov	rdx, QWORD PTR ModuleInfo+344
	mov	r8d, r10d
	mov	eax, DWORD PTR [rbx+20]
	add	rdx, 10
	mov	r9, QWORD PTR [rsi+8]
	mov	ecx, 198				; 000000c6H
	mov	DWORD PTR [rsp+32], eax
	call	EmitErr

; 1202 :             } else

	jmp	SHORT $LN17@write_relo
$LN16@write_relo:

; 1203 :                 EmitErr( UNKNOWN_FIXUP_TYPE, fixup->type, curr->sym.name, fixup->locofs );

	mov	r9d, DWORD PTR [rbx+20]
	mov	edx, r10d
	mov	r8, QWORD PTR [rsi+8]
	mov	ecx, 196				; 000000c4H
	call	EmitErr
$LN17@write_relo:

; 1204 :         }
; 1205 :         /* the low 8 bits of info are type */
; 1206 :         /* the high 24 bits are symbol table index */
; 1207 :         reloc64.r_info = ELF64_R_INFO( symidx, elftype );
; 1208 :         if ( fwrite( &reloc64, 1, sizeof( reloc64 ), CurrFile[OBJ] ) != sizeof(reloc64) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	edx, 1
	movzx	eax, dil
	mov	rcx, rbp
	shl	rcx, 32					; 00000020H
	add	rcx, rax
	mov	QWORD PTR reloc64$[rsp+8], rcx
	lea	r8d, QWORD PTR [rdx+23]
	lea	rcx, QWORD PTR reloc64$[rsp]
	call	fwrite
	cmp	rax, 24
	je	SHORT $LN2@write_relo

; 1209 :             WriteError();

	call	WriteError
$LN2@write_relo:

; 1133 :     uint_8 elftype;
; 1134 :     struct fixup *fixup;
; 1135 :     Elf64_Rela reloc64; /* v2.05: changed to Rela */
; 1136 : 
; 1137 :     DebugMsg(("write_relocs64: enter\n"));
; 1138 :     for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rbx, QWORD PTR [rbx+8]
	test	rbx, rbx
	jne	$LL4@write_relo
	mov	r14, QWORD PTR [rsp+112]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+96]
$LN3@write_relo:

; 1210 :     }
; 1211 :     DebugMsg(("write_relocs64: exit\n"));
; 1212 :     return;
; 1213 : }

	mov	rbx, QWORD PTR [rsp+120]
	add	rsp, 80					; 00000050H
	pop	rsi
	ret	0
	npad	2
$LN24@write_relo:
	DD	$LN14@write_relo
	DD	$LN12@write_relo
	DD	$LN7@write_relo
	DD	$LN13@write_relo
	DD	$LN11@write_relo
	DD	$LN10@write_relo
	DD	$LN8@write_relo
	DD	$LN15@write_relo
	DD	$LN15@write_relo
	DD	$LN15@write_relo
	DD	$LN15@write_relo
	DD	$LN9@write_relo
write_relocs64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
;	COMDAT write_relocs32
_TEXT	SEGMENT
em$ = 80
reloc32$ = 88
curr$ = 88
write_relocs32 PROC					; COMDAT

; 1082 : {

	push	rbx
	push	rbp
	push	rsi
	sub	rsp, 48					; 00000030H

; 1083 :     uint_8 elftype;
; 1084 :     struct fixup *fixup;
; 1085 :     Elf32_Rel reloc32;
; 1086 : 
; 1087 :     DebugMsg(("write_relocs32: enter\n"));
; 1088 :     for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rbx, QWORD PTR [rdx+96]
	mov	rsi, rdx
	mov	rbp, rcx
	mov	rbx, QWORD PTR [rbx+40]
	test	rbx, rbx
	je	$LN3@write_relo
	mov	QWORD PTR [rsp+80], rdi
	mov	QWORD PTR [rsp+96], r14
	lea	r14, OFFSET FLAT:__ImageBase
$LL4@write_relo:

; 1089 :         reloc32.r_offset = fixup->locofs;

	mov	eax, DWORD PTR [rbx+20]
	mov	DWORD PTR reloc32$[rsp], eax

; 1090 :         switch ( fixup->type ) {

	mov	r10d, DWORD PTR [rbx+24]
	lea	eax, DWORD PTR [r10-1]
	cmp	eax, 11
	ja	SHORT $LN14@write_relo
	cdqe
	mov	ecx, DWORD PTR $LN23@write_relo[r14+rax*4]
	add	rcx, r14
	jmp	rcx
$LN7@write_relo:

; 1091 :         case FIX_OFF32:         elftype = R_386_32;             break;

	mov	dil, 1
	jmp	SHORT $LN16@write_relo
$LN8@write_relo:

; 1092 :         case FIX_RELOFF32:      elftype = R_386_PC32;           break;

	mov	dil, 2
	jmp	SHORT $LN16@write_relo
$LN9@write_relo:

; 1093 :         //case FIX_???:         elftype = R_386_GOT32;          break;
; 1094 :         //case FIX_???:         elftype = R_386_PLT32;          break;
; 1095 :         //case FIX_???:         elftype = R_386_COPY;           break;
; 1096 :         //case FIX_???:         elftype = R_386_GLOB_DAT;       break;
; 1097 :         //case FIX_???:         elftype = R_386_JMP_SLOT;       break;
; 1098 :         case FIX_OFF32_IMGREL:  elftype = R_386_RELATIVE;       break;

	mov	dil, 8
	jmp	SHORT $LN16@write_relo
$LN10@write_relo:

; 1099 :         //case FIX_???:         elftype = R_386_GOTOFF;         break;
; 1100 :         //case FIX_???:         elftype = R_386_GOTPC;          break;
; 1101 : #if GNURELOCS
; 1102 :         case FIX_OFF16:    em->extused = TRUE; elftype = R_386_16;   break;

	mov	BYTE PTR [rbp+16], 1
	mov	dil, 20
	jmp	SHORT $LN16@write_relo
$LN11@write_relo:

; 1103 :         case FIX_RELOFF16: em->extused = TRUE; elftype = R_386_PC16; break;

	mov	BYTE PTR [rbp+16], 1
	mov	dil, 21
	jmp	SHORT $LN16@write_relo
$LN12@write_relo:

; 1104 :         case FIX_OFF8:     em->extused = TRUE; elftype = R_386_8;    break;

	mov	BYTE PTR [rbp+16], 1
	mov	dil, 22
	jmp	SHORT $LN16@write_relo
$LN13@write_relo:

; 1105 :         case FIX_RELOFF8:  em->extused = TRUE; elftype = R_386_PC8;  break;

	mov	BYTE PTR [rbp+16], 1
	mov	dil, 23
	jmp	SHORT $LN16@write_relo
$LN14@write_relo:

; 1106 : #endif
; 1107 :         default:
; 1108 :             DebugMsg(("write_relocs32(): unhandled reloc loc=%X type=%u idx=%u sym=%s\n",
; 1109 :                       fixup->locofs, fixup->type, fixup->sym->ext_idx, fixup->sym->name));
; 1110 :             elftype = R_386_NONE;

	xor	dil, dil

; 1111 :             if ( fixup->type < FIX_LAST ) {

	cmp	r10d, 14
	jge	SHORT $LN15@write_relo

; 1112 :                 EmitErr( INVALID_FIXUP_TYPE, ModuleInfo.fmtopt->formatname, fixup->type, curr->sym.name, fixup->locofs );

	mov	rdx, QWORD PTR ModuleInfo+344
	mov	r8d, r10d
	mov	eax, DWORD PTR [rbx+20]
	add	rdx, 10
	mov	r9, QWORD PTR [rsi+8]
	mov	ecx, 198				; 000000c6H
	mov	DWORD PTR [rsp+32], eax
	call	EmitErr

; 1113 :             } else

	jmp	SHORT $LN16@write_relo
$LN15@write_relo:

; 1114 :                 EmitErr( UNKNOWN_FIXUP_TYPE, fixup->type, curr->sym.name, fixup->locofs );

	mov	r9d, DWORD PTR [rbx+20]
	mov	edx, r10d
	mov	r8, QWORD PTR [rsi+8]
	mov	ecx, 196				; 000000c4H
	call	EmitErr
$LN16@write_relo:

; 1115 :         }
; 1116 :         /* the low 8 bits of info are type */
; 1117 :         /* the high 24 bits are symbol table index */
; 1118 :         reloc32.r_info = ELF32_R_INFO( fixup->sym->ext_idx, elftype );

	mov	rax, QWORD PTR [rbx+56]

; 1119 :         if ( fwrite( &reloc32, 1, sizeof(reloc32), CurrFile[OBJ] ) != sizeof(reloc32) )

	mov	edx, 1
	mov	r9, QWORD PTR ModuleInfo+104
	mov	ecx, DWORD PTR [rax+88]
	lea	r8d, QWORD PTR [rdx+7]
	shl	ecx, 8
	movzx	eax, dil
	add	ecx, eax
	mov	DWORD PTR reloc32$[rsp+4], ecx
	lea	rcx, QWORD PTR reloc32$[rsp]
	call	fwrite
	cmp	rax, 8
	je	SHORT $LN2@write_relo

; 1120 :             WriteError();

	call	WriteError
$LN2@write_relo:

; 1083 :     uint_8 elftype;
; 1084 :     struct fixup *fixup;
; 1085 :     Elf32_Rel reloc32;
; 1086 : 
; 1087 :     DebugMsg(("write_relocs32: enter\n"));
; 1088 :     for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rbx, QWORD PTR [rbx+8]
	test	rbx, rbx
	jne	$LL4@write_relo
	mov	r14, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+80]
$LN3@write_relo:

; 1121 :     }
; 1122 :     DebugMsg(("write_relocs32: exit\n"));
; 1123 :     return;
; 1124 : }

	add	rsp, 48					; 00000030H
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
	npad	3
$LN23@write_relo:
	DD	$LN13@write_relo
	DD	$LN11@write_relo
	DD	$LN8@write_relo
	DD	$LN12@write_relo
	DD	$LN10@write_relo
	DD	$LN7@write_relo
	DD	$LN14@write_relo
	DD	$LN14@write_relo
	DD	$LN14@write_relo
	DD	$LN14@write_relo
	DD	$LN14@write_relo
	DD	$LN9@write_relo
write_relocs32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
;	COMDAT elf_write_section_table64
_TEXT	SEGMENT
shdr64$ = 32
modinfo$ = 144
em$ = 152
fileoffset$ = 160
elf_write_section_table64 PROC				; COMDAT

; 931  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 96					; 00000060H
	mov	r15, rcx

; 932  :     int         i;
; 933  :     struct dsym *curr;
; 934  :     uint_8      *p;
; 935  :     //uint_32     fileoffset;
; 936  :     Elf64_Shdr  shdr64;
; 937  : 
; 938  :     DebugMsg(("elf_write_section_table64( fileofs=%X ): enter\n", fileoffset ));
; 939  : 
; 940  :     //fileoffset = sizeof(Elf64_Ehdr) + ehdr->e_shnum * ehdr->e_shentsize;
; 941  :     fileoffset = (fileoffset + 0xF) & ~0xF;

	lea	edi, DWORD PTR [r8+15]

; 942  : 
; 943  :     /* set contents and size of internal .shstrtab section */
; 944  :     set_shstrtab_values( em );

	mov	rcx, rdx
	and	edi, -16				; fffffff0H
	mov	r14, rdx
	call	set_shstrtab_values

; 945  : 
; 946  :     /* write the NULL entry */
; 947  :     memset( &shdr64, 0, sizeof( shdr64) );
; 948  :     if ( fwrite( &shdr64, 1, sizeof(shdr64), CurrFile[OBJ] ) != sizeof(shdr64) ) /* write the empty NULL entry */

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR shdr64$[rbp-96]
	xor	eax, eax
	mov	r13d, 1
	mov	edx, r13d
	mov	QWORD PTR shdr64$[rbp-96], rax
	mov	QWORD PTR shdr64$[rbp-88], rax
	mov	QWORD PTR shdr64$[rbp-80], rax
	lea	r8d, QWORD PTR [rax+64]
	mov	QWORD PTR shdr64$[rbp-72], rax
	mov	QWORD PTR shdr64$[rbp-64], rax
	mov	QWORD PTR shdr64$[rbp-56], rax
	mov	QWORD PTR shdr64$[rbp-48], rax
	mov	QWORD PTR shdr64$[rbp-40], rax
	call	fwrite
	cmp	rax, 64					; 00000040H
	je	SHORT $LN11@elf_write_

; 949  :         WriteError();

	call	WriteError
$LN11@elf_write_:

; 950  : 
; 951  :     /* use p to scan strings (=section names) of .shstrtab */
; 952  :     p = (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;
; 953  :     p++; /* skip 'name' of NULL entry */

	mov	rbx, QWORD PTR [r14+32]

; 954  : 
; 955  :     /* write the section headers defined in the module */
; 956  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	xor	r12d, r12d
	mov	rsi, QWORD PTR SymTables+32
	inc	rbx
	test	rsi, rsi
	je	$LN3@elf_write_
	npad	8
$LL4@elf_write_:

; 957  : 
; 958  :         memset( &shdr64, 0, sizeof(shdr64) );

	xor	eax, eax
	mov	QWORD PTR shdr64$[rbp-96], rax
	mov	QWORD PTR shdr64$[rbp-88], rax
	mov	QWORD PTR shdr64$[rbp-80], rax
	mov	QWORD PTR shdr64$[rbp-72], rax
	mov	QWORD PTR shdr64$[rbp-64], rax
	mov	QWORD PTR shdr64$[rbp-56], rax
	mov	QWORD PTR shdr64$[rbp-48], rax
	mov	QWORD PTR shdr64$[rbp-40], rax

; 959  : 
; 960  :         shdr64.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, ebx
	sub	eax, DWORD PTR [r14+32]
	mov	DWORD PTR shdr64$[rbp-96], eax

; 961  :         p += strlen( (char *)p ) + 1;

	or	rax, -1
	npad	1
$LL56@elf_write_:
	inc	rax
	cmp	BYTE PTR [rbx+rax], r12b
	jne	SHORT $LL56@elf_write_

; 962  :         if ( curr->e.seginfo->info == TRUE ) { /* v2.07:added; v2.12: highest priority */

	mov	rcx, QWORD PTR [rsi+96]
	inc	rbx
	add	rbx, rax
	test	BYTE PTR [rcx+107], 2
	je	SHORT $LN12@elf_write_

; 963  :             shdr64.sh_type = SHT_NOTE;

	mov	DWORD PTR shdr64$[rbp-92], 7

; 964  :             shdr64.sh_flags = 0;

	mov	QWORD PTR shdr64$[rbp-88], r12

; 965  :         } else {

	jmp	SHORT $LN19@elf_write_
$LN12@elf_write_:

; 966  :             shdr64.sh_type = ( curr->e.seginfo->segtype != SEGTYPE_BSS ? SHT_PROGBITS : SHT_NOBITS );

	cmp	DWORD PTR [rcx+72], 3
	mov	eax, 8
	cmovne	eax, r13d
	mov	DWORD PTR shdr64$[rbp-92], eax

; 967  :             if ( curr->e.seginfo->segtype == SEGTYPE_CODE ) {

	mov	rax, QWORD PTR [rsi+96]
	cmp	DWORD PTR [rax+72], r13d
	jne	SHORT $LN14@elf_write_

; 968  :                 shdr64.sh_flags = SHF_EXECINSTR | SHF_ALLOC;

	mov	QWORD PTR shdr64$[rbp-88], 6
	jmp	SHORT $LN19@elf_write_
$LN14@elf_write_:

; 969  :             } else if ( curr->e.seginfo->readonly == TRUE ) {

	test	BYTE PTR [rax+107], r13b
	je	SHORT $LN16@elf_write_

; 970  :                 shdr64.sh_flags = SHF_ALLOC;

	mov	QWORD PTR shdr64$[rbp-88], 2
	jmp	SHORT $LN19@elf_write_
$LN16@elf_write_:

; 971  :             } else if ( curr->e.seginfo->clsym && strcmp( curr->e.seginfo->clsym->name, "CONST" ) == 0 ) {

	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	je	SHORT $LN18@elf_write_
	mov	rax, QWORD PTR [rax+8]
	lea	r8, OFFSET FLAT:$SG11646
	sub	r8, rax
$LL54@elf_write_:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN55@elf_write_
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL54@elf_write_
$LN55@elf_write_:

; 972  :                 shdr64.sh_flags = SHF_ALLOC; /* v2.07: added */

	mov	QWORD PTR shdr64$[rbp-88], 2
	test	edx, edx
	je	SHORT $LN19@elf_write_
$LN18@elf_write_:

; 973  :             } else {
; 974  :                 shdr64.sh_flags = SHF_WRITE | SHF_ALLOC;

	mov	QWORD PTR shdr64$[rbp-88], 3
$LN19@elf_write_:

; 975  :             }
; 976  :         }
; 977  : #if 0
; 978  :         /* todo: translate values in field <characteristics> to
; 979  :          * elf section flags.
; 980  :          */
; 981  :         if ( curr->e.seginfo->characteristics == ??? ) {
; 982  :         }
; 983  : #endif
; 984  :         shdr64.sh_addr = 0;

	mov	QWORD PTR shdr64$[rbp-80], r12

; 985  :         /* v2.12: the sh_offset field holds the file position, even for SHT_NOBITS */
; 986  :         //if ( shdr64.sh_type != SHT_NOBITS ) {
; 987  :             shdr64.sh_offset = fileoffset; /* start of section in file */

	mov	eax, edi
	mov	QWORD PTR shdr64$[rbp-72], rax

; 988  :             curr->e.seginfo->fileoffset = fileoffset; /* save the offset in the segment */

	mov	rax, QWORD PTR [rsi+96]
	mov	DWORD PTR [rax+56], edi

; 989  :         //}
; 990  :         /* v2.07: set size for all sections, including .bss */
; 991  :         shdr64.sh_size = curr->sym.max_offset;

	movsxd	rax, DWORD PTR [rsi+56]
	mov	QWORD PTR shdr64$[rbp-64], rax

; 992  :         shdr64.sh_link = 0;

	mov	QWORD PTR shdr64$[rbp-56], r12

; 993  :         shdr64.sh_info = 0;
; 994  :         shdr64.sh_addralign = Get_Alignment( curr );

	mov	rax, QWORD PTR [rsi+96]
	movzx	ecx, BYTE PTR [rax+106]
	cmp	cl, 255					; 000000ffH
	jne	SHORT $LN29@elf_write_
	mov	eax, r12d
	jmp	SHORT $LN28@elf_write_
$LN29@elf_write_:
	mov	eax, r13d
	shl	eax, cl
$LN28@elf_write_:

; 995  :         shdr64.sh_entsize = 0;
; 996  : 
; 997  :         if ( fwrite( &shdr64, 1, sizeof(shdr64), CurrFile[OBJ] ) != sizeof(shdr64) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR shdr64$[rbp-96]
	mov	r8d, 64					; 00000040H
	mov	QWORD PTR shdr64$[rbp-48], rax
	mov	rdx, r13
	mov	QWORD PTR shdr64$[rbp-40], r12
	call	fwrite
	cmp	rax, 64					; 00000040H
	je	SHORT $LN20@elf_write_

; 998  :             WriteError();

	call	WriteError
$LN20@elf_write_:

; 999  :         curr->e.seginfo->num_relocs = get_relocation_count( curr );

	mov	rdx, QWORD PTR [rsi+96]
	mov	ecx, r12d
	mov	rax, QWORD PTR [rdx+40]
	test	rax, rax
	je	SHORT $LN33@elf_write_
	npad	8
$LL34@elf_write_:
	mov	rax, QWORD PTR [rax+8]
	inc	ecx
	test	rax, rax
	jne	SHORT $LL34@elf_write_
$LN33@elf_write_:
	mov	DWORD PTR [rdx+64], ecx

; 1000 : 
; 1001 :         /* v2.12: don't adjust fileoffset for SHT_NOBITS sections */
; 1002 :         if ( shdr64.sh_type != SHT_NOBITS ) {

	cmp	DWORD PTR shdr64$[rbp-92], 8
	je	SHORT $LN2@elf_write_

; 1003 :             fileoffset += shdr64.sh_size;
; 1004 :             fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR shdr64$[rbp-64]
	add	eax, 15
	add	edi, eax
	and	edi, -16				; fffffff0H
$LN2@elf_write_:

; 954  : 
; 955  :     /* write the section headers defined in the module */
; 956  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rsi, QWORD PTR [rsi+104]
	test	rsi, rsi
	jne	$LL4@elf_write_
$LN3@elf_write_:

; 1005 :         }
; 1006 : 
; 1007 :         DebugMsg(("elf_write_section_table64(%s): ofs=%" I64_SPEC "X size=%" I64_SPEC "X numrelocs=%u\n", curr->sym.name, shdr64.sh_offset, shdr64.sh_size, curr->e.seginfo->num_relocs));
; 1008 :     }
; 1009 : 
; 1010 :     /* set size and contents of .symtab and .strtab sections */
; 1011 :     set_symtab_values( em );

	mov	rcx, r14
	call	set_symtab_values

; 1012 : 
; 1013 :     /* write headers of internal sections */
; 1014 :     for ( i = 0; i < NUM_INTSEGS; i++ ) {

	mov	rsi, r12
	lea	r13, OFFSET FLAT:internal_segparms+8
	npad	2
$LL7@elf_write_:

; 1015 : 
; 1016 :         shdr64.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, ebx
	sub	eax, DWORD PTR [r14+32]
	mov	DWORD PTR shdr64$[rbp-96], eax

; 1017 :         p += strlen( (char *)p ) + 1;

	or	rax, -1
	npad	3
$LL53@elf_write_:
	inc	rax
	cmp	BYTE PTR [rbx+rax], r12b
	jne	SHORT $LL53@elf_write_
	inc	rbx

; 1018 :         shdr64.sh_type = internal_segparms[i].type;
; 1019 :         shdr64.sh_flags = 0;

	mov	QWORD PTR shdr64$[rbp-88], r12
	add	rbx, rax
	mov	rcx, rsi
	add	rcx, rcx
	mov	eax, DWORD PTR [r13+rcx*8]
	mov	DWORD PTR shdr64$[rbp-92], eax

; 1020 :         shdr64.sh_offset = fileoffset; /* start of section in file */

	mov	eax, edi
	mov	QWORD PTR shdr64$[rbp-72], rax

; 1021 :         em->internal_segs[i].fileoffset = fileoffset;
; 1022 :         shdr64.sh_size = em->internal_segs[i].size;

	mov	eax, DWORD PTR [r14+rcx*8+24]
	mov	QWORD PTR shdr64$[rbp-64], rax
	mov	DWORD PTR [r14+rcx*8+28], edi

; 1023 :         /* section .symtab is special */
; 1024 :         if ( i == SYMTAB_IDX ) {

	cmp	rsi, 1
	jne	SHORT $LN22@elf_write_

; 1025 :             shdr64.sh_link = 1 + modinfo->g.num_segs + STRTAB_IDX;

	mov	eax, DWORD PTR [r15+8]
	add	eax, 3

; 1026 :             shdr64.sh_info = em->start_globals;
; 1027 :             shdr64.sh_addralign = 4;

	mov	QWORD PTR shdr64$[rbp-48], 4
	mov	DWORD PTR shdr64$[rbp-56], eax
	mov	eax, DWORD PTR [r14+4]
	mov	DWORD PTR shdr64$[rbp-52], eax

; 1028 :             shdr64.sh_entsize = sizeof( Elf64_Sym );

	mov	QWORD PTR shdr64$[rbp-40], 24

; 1029 :         } else {

	jmp	SHORT $LN23@elf_write_
$LN22@elf_write_:

; 1030 :             shdr64.sh_link = 0;

	mov	QWORD PTR shdr64$[rbp-56], r12

; 1031 :             shdr64.sh_info = 0;
; 1032 :             shdr64.sh_addralign = 1;

	mov	QWORD PTR shdr64$[rbp-48], 1

; 1033 :             shdr64.sh_entsize = 0;

	mov	QWORD PTR shdr64$[rbp-40], r12
$LN23@elf_write_:

; 1034 :         }
; 1035 :         if ( fwrite( &shdr64, 1, sizeof( shdr64 ), CurrFile[OBJ] ) != sizeof( shdr64 ) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR shdr64$[rbp-96]
	mov	edx, 1
	lea	r8d, QWORD PTR [rdx+63]
	call	fwrite
	cmp	rax, 64					; 00000040H
	je	SHORT $LN24@elf_write_

; 1036 :             WriteError();

	call	WriteError
$LN24@elf_write_:

; 1037 : 
; 1038 :         fileoffset += shdr64.sh_size;
; 1039 :         fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR shdr64$[rbp-64]
	inc	rsi
	add	eax, 15
	add	edi, eax
	and	edi, -16				; fffffff0H
	cmp	rsi, 3
	jl	$LL7@elf_write_

; 1040 :         DebugMsg(("elf_write_section_table64(%s): ofs=%" I64_SPEC "X size=%" I64_SPEC "X\n", internal_segparms[i].name, shdr64.sh_offset, shdr64.sh_size));
; 1041 :     }
; 1042 : 
; 1043 :     /* write headers of reloc sections */
; 1044 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rsi, QWORD PTR SymTables+32
	test	rsi, rsi
	je	$LN57@elf_write_
	npad	6
$LL10@elf_write_:

; 1045 :         if ( curr->e.seginfo->FixupList.head == NULL )

	mov	rax, QWORD PTR [rsi+96]
	cmp	QWORD PTR [rax+40], r12
	je	$LN8@elf_write_

; 1046 :             continue;
; 1047 : 
; 1048 :         memset( &shdr64, 0, sizeof(shdr64) );

	xor	eax, eax
	mov	QWORD PTR shdr64$[rbp-96], rax
	mov	QWORD PTR shdr64$[rbp-88], rax
	mov	QWORD PTR shdr64$[rbp-80], rax
	mov	QWORD PTR shdr64$[rbp-72], rax
	mov	QWORD PTR shdr64$[rbp-64], rax
	mov	QWORD PTR shdr64$[rbp-56], rax
	mov	QWORD PTR shdr64$[rbp-48], rax
	mov	QWORD PTR shdr64$[rbp-40], rax

; 1049 : 
; 1050 :         shdr64.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, ebx
	sub	eax, DWORD PTR [r14+32]
	mov	DWORD PTR shdr64$[rbp-96], eax

; 1051 :         p += strlen( (char *)p ) + 1;

	or	rax, -1
	npad	3
$LL52@elf_write_:
	inc	rax
	cmp	BYTE PTR [rbx+rax], r12b
	jne	SHORT $LL52@elf_write_
	inc	rax

; 1052 :         shdr64.sh_type = SHT_RELA; /* v2.05: changed REL to RELA */

	mov	DWORD PTR shdr64$[rbp-92], 4
	add	rbx, rax

; 1053 :         shdr64.sh_flags = 0;

	mov	QWORD PTR shdr64$[rbp-88], r12

; 1054 :         shdr64.sh_addr = 0;

	mov	QWORD PTR shdr64$[rbp-80], r12

; 1055 :         shdr64.sh_offset = fileoffset; /* start of section in file */

	mov	eax, edi
	mov	QWORD PTR shdr64$[rbp-72], rax

; 1056 :         /* save the file offset in the slot reserved for ELF relocs */
; 1057 :         curr->e.seginfo->reloc_offset = fileoffset;

	mov	rax, QWORD PTR [rsi+96]
	mov	DWORD PTR [rax+12], edi

; 1058 :         /* size of section in file */
; 1059 :         shdr64.sh_size = curr->e.seginfo->num_relocs * sizeof( Elf64_Rela );

	mov	rax, QWORD PTR [rsi+96]
	mov	ecx, DWORD PTR [rax+64]
	lea	rax, QWORD PTR [rcx+rcx*2]
	shl	rax, 3
	mov	QWORD PTR shdr64$[rbp-64], rax

; 1060 :         shdr64.sh_link = 1 + modinfo->g.num_segs + SYMTAB_IDX;

	mov	eax, DWORD PTR [r15+8]
	add	eax, 2
	mov	DWORD PTR shdr64$[rbp-56], eax

; 1061 :         /* set info to the src section index */
; 1062 :         shdr64.sh_info = GetSegIdx( curr->sym.segment );

	mov	rcx, QWORD PTR [rsi+24]
	call	GetSegIdx

; 1063 :         shdr64.sh_addralign = 4;
; 1064 :         shdr64.sh_entsize = sizeof( Elf64_Rela );
; 1065 : 
; 1066 :         if ( fwrite( &shdr64, 1, sizeof( shdr64 ), CurrFile[OBJ] ) != sizeof( shdr64 ) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR shdr64$[rbp-96]
	mov	edx, 1
	mov	DWORD PTR shdr64$[rbp-52], eax
	mov	QWORD PTR shdr64$[rbp-48], 4
	mov	QWORD PTR shdr64$[rbp-40], 24
	lea	r8d, QWORD PTR [rdx+63]
	call	fwrite
	cmp	rax, 64					; 00000040H
	je	SHORT $LN26@elf_write_

; 1067 :             WriteError();

	call	WriteError
$LN26@elf_write_:

; 1068 : 
; 1069 :         fileoffset += shdr64.sh_size;
; 1070 :         fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR shdr64$[rbp-64]
	add	eax, 15
	add	edi, eax
	and	edi, -16				; fffffff0H
$LN8@elf_write_:

; 1040 :         DebugMsg(("elf_write_section_table64(%s): ofs=%" I64_SPEC "X size=%" I64_SPEC "X\n", internal_segparms[i].name, shdr64.sh_offset, shdr64.sh_size));
; 1041 :     }
; 1042 : 
; 1043 :     /* write headers of reloc sections */
; 1044 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rsi, QWORD PTR [rsi+104]
	test	rsi, rsi
	jne	$LL10@elf_write_
$LN57@elf_write_:

; 1071 :         DebugMsg(("elf_write_section_table64(%s): relocs, ofs=%" I64_SPEC "X size=%" I64_SPEC "X\n", curr->sym.name, shdr64.sh_offset, shdr64.sh_size));
; 1072 :     }
; 1073 :     DebugMsg(("elf_write_section_table64: exit, final fileofs=%X\n", fileoffset ));
; 1074 :     return( NOT_ERROR );
; 1075 : }

	lea	r11, QWORD PTR [rsp+96]
	xor	eax, eax
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
elf_write_section_table64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
;	COMDAT elf_write_section_table32
_TEXT	SEGMENT
shdr32$ = 32
modinfo$ = 128
em$ = 136
fileoffset$ = 144
elf_write_section_table32 PROC				; COMDAT

; 776  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 80					; 00000050H
	mov	r15, rcx

; 777  :     int         i;
; 778  :     struct dsym *curr;
; 779  :     uint_8      *p;
; 780  :     //uint_32     fileoffset;
; 781  :     Elf32_Shdr  shdr32;
; 782  : 
; 783  :     DebugMsg(("elf_write_section_table32( fileofs=%X ): enter\n", fileoffset ));
; 784  : 
; 785  :     //fileoffset = sizeof(Elf64_Ehdr) + ehdr->e_shnum * ehdr->e_shentsize;
; 786  :     fileoffset = (fileoffset + 0xF) & ~0xF;

	lea	edi, DWORD PTR [r8+15]

; 787  : 
; 788  :     /* set contents and size of internal .shstrtab section */
; 789  :     set_shstrtab_values( em );

	mov	rcx, rdx
	and	edi, -16				; fffffff0H
	mov	r14, rdx
	call	set_shstrtab_values

; 790  : 
; 791  :     /* write the NULL entry */
; 792  :     memset( &shdr32, 0, sizeof( shdr32) );
; 793  :     if ( fwrite( &shdr32, 1, sizeof(shdr32), CurrFile[OBJ] ) != sizeof(shdr32) ) /* write the empty NULL entry */

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR shdr32$[rbp-80]
	xor	eax, eax
	mov	r13d, 1
	mov	edx, r13d
	mov	QWORD PTR shdr32$[rbp-80], rax
	mov	QWORD PTR shdr32$[rbp-72], rax
	mov	QWORD PTR shdr32$[rbp-64], rax
	lea	r8d, QWORD PTR [rax+40]
	mov	QWORD PTR shdr32$[rbp-56], rax
	mov	QWORD PTR shdr32$[rbp-48], rax
	call	fwrite
	cmp	rax, 40					; 00000028H
	je	SHORT $LN11@elf_write_

; 794  :         WriteError();

	call	WriteError
$LN11@elf_write_:

; 795  : 
; 796  :     /* use p to scan strings (=section names) of .shstrtab */
; 797  :     p = (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;
; 798  :     p++; /* skip 'name' of NULL entry */

	mov	rbx, QWORD PTR [r14+32]

; 799  : 
; 800  :     /* write the section headers defined in the module, */
; 801  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	xor	r12d, r12d
	mov	rsi, QWORD PTR SymTables+32
	inc	rbx
	test	rsi, rsi
	je	$LN3@elf_write_
	npad	4
$LL4@elf_write_:

; 802  : 
; 803  :         memset( &shdr32, 0, sizeof(shdr32) );

	xor	eax, eax
	mov	QWORD PTR shdr32$[rbp-80], rax
	mov	QWORD PTR shdr32$[rbp-72], rax
	mov	QWORD PTR shdr32$[rbp-64], rax
	mov	QWORD PTR shdr32$[rbp-56], rax
	mov	QWORD PTR shdr32$[rbp-48], rax

; 804  : 
; 805  :         shdr32.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, ebx
	sub	eax, DWORD PTR [r14+32]
	mov	DWORD PTR shdr32$[rbp-80], eax

; 806  :         p += strlen( (char *)p ) + 1;

	or	rax, -1
$LL56@elf_write_:
	inc	rax
	cmp	BYTE PTR [rbx+rax], r12b
	jne	SHORT $LL56@elf_write_

; 807  :         if ( curr->e.seginfo->info == TRUE ) { /* v2.07:added; v2.12: highest priority */

	mov	rcx, QWORD PTR [rsi+96]
	inc	rbx
	add	rbx, rax
	test	BYTE PTR [rcx+107], 2
	je	SHORT $LN12@elf_write_

; 808  :             shdr32.sh_type = SHT_NOTE;

	mov	QWORD PTR shdr32$[rbp-76], 7

; 809  :             shdr32.sh_flags = 0;
; 810  :         } else {

	jmp	SHORT $LN19@elf_write_
$LN12@elf_write_:

; 811  :             shdr32.sh_type = ( curr->e.seginfo->segtype != SEGTYPE_BSS ? SHT_PROGBITS : SHT_NOBITS );

	cmp	DWORD PTR [rcx+72], 3
	mov	eax, 8
	cmovne	eax, r13d
	mov	DWORD PTR shdr32$[rbp-76], eax

; 812  :             if ( curr->e.seginfo->segtype == SEGTYPE_CODE ) {

	mov	rax, QWORD PTR [rsi+96]
	cmp	DWORD PTR [rax+72], r13d
	jne	SHORT $LN14@elf_write_

; 813  :                 shdr32.sh_flags = SHF_EXECINSTR | SHF_ALLOC;

	mov	DWORD PTR shdr32$[rbp-72], 6
	jmp	SHORT $LN19@elf_write_
$LN14@elf_write_:

; 814  :             } else if ( curr->e.seginfo->readonly == TRUE ) {

	test	BYTE PTR [rax+107], r13b
	je	SHORT $LN16@elf_write_

; 815  :                 shdr32.sh_flags = SHF_ALLOC;

	mov	DWORD PTR shdr32$[rbp-72], 2
	jmp	SHORT $LN19@elf_write_
$LN16@elf_write_:

; 816  :             } else if ( curr->e.seginfo->clsym && strcmp( curr->e.seginfo->clsym->name, "CONST" ) == 0 ) {

	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	je	SHORT $LN18@elf_write_
	mov	rax, QWORD PTR [rax+8]
	lea	r8, OFFSET FLAT:$SG11597
	sub	r8, rax
	npad	1
$LL54@elf_write_:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN55@elf_write_
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL54@elf_write_
$LN55@elf_write_:

; 817  :                 shdr32.sh_flags = SHF_ALLOC; /* v2.07: added */

	mov	DWORD PTR shdr32$[rbp-72], 2
	test	edx, edx
	je	SHORT $LN19@elf_write_
$LN18@elf_write_:

; 818  :             } else {
; 819  :                 shdr32.sh_flags = SHF_WRITE | SHF_ALLOC;

	mov	DWORD PTR shdr32$[rbp-72], 3
$LN19@elf_write_:

; 820  :             }
; 821  :         }
; 822  : #if 0
; 823  :         /* todo: translate values in field <characteristics> to
; 824  :          * elf section flags.
; 825  :          */
; 826  :         if ( curr->e.seginfo->characteristics == ??? ) {
; 827  :         }
; 828  : #endif
; 829  :         shdr32.sh_addr = 0;

	mov	DWORD PTR shdr32$[rbp-68], r12d

; 830  :         /* v2.12: the sh_offset field holds the file position, even for SHT_NOBITS */
; 831  :         //if ( shdr32.sh_type != SHT_NOBITS ) {
; 832  :             shdr32.sh_offset = fileoffset; /* start of section in file */

	mov	DWORD PTR shdr32$[rbp-64], edi

; 833  :             curr->e.seginfo->fileoffset = fileoffset; /* save the offset in the segment */

	mov	rax, QWORD PTR [rsi+96]
	mov	DWORD PTR [rax+56], edi

; 834  :         //}
; 835  :         /* v2.07: set size for all sections, including .bss */
; 836  :         shdr32.sh_size = curr->sym.max_offset;

	mov	eax, DWORD PTR [rsi+56]
	mov	DWORD PTR shdr32$[rbp-60], eax

; 837  :         shdr32.sh_link = 0;

	mov	QWORD PTR shdr32$[rbp-56], r12

; 838  :         shdr32.sh_info = 0;
; 839  :         shdr32.sh_addralign = Get_Alignment( curr );

	mov	rax, QWORD PTR [rsi+96]
	movzx	ecx, BYTE PTR [rax+106]
	cmp	cl, 255					; 000000ffH
	jne	SHORT $LN29@elf_write_
	mov	eax, r12d
	jmp	SHORT $LN28@elf_write_
$LN29@elf_write_:
	mov	eax, r13d
	shl	eax, cl
$LN28@elf_write_:

; 840  :         shdr32.sh_entsize = 0;
; 841  : 
; 842  :         if ( fwrite( &shdr32, 1, sizeof(shdr32), CurrFile[OBJ] ) != sizeof(shdr32) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR shdr32$[rbp-80]
	mov	r8d, 40					; 00000028H
	mov	DWORD PTR shdr32$[rbp-48], eax
	mov	rdx, r13
	mov	DWORD PTR shdr32$[rbp-44], r12d
	call	fwrite
	cmp	rax, 40					; 00000028H
	je	SHORT $LN20@elf_write_

; 843  :             WriteError();

	call	WriteError
$LN20@elf_write_:

; 844  :         curr->e.seginfo->num_relocs = get_relocation_count( curr );

	mov	rdx, QWORD PTR [rsi+96]
	mov	ecx, r12d
	mov	rax, QWORD PTR [rdx+40]
	test	rax, rax
	je	SHORT $LN33@elf_write_
	npad	1
$LL34@elf_write_:
	mov	rax, QWORD PTR [rax+8]
	inc	ecx
	test	rax, rax
	jne	SHORT $LL34@elf_write_
$LN33@elf_write_:
	mov	DWORD PTR [rdx+64], ecx

; 845  : 
; 846  :         /* v2.12: don't adjust fileoffset for SHT_NOBITS sections.
; 847  :          * it didn't cause fatal damage previously, but made the
; 848  :          * object module unnecessary large.
; 849  :          */
; 850  :         if ( shdr32.sh_type != SHT_NOBITS ) {

	cmp	DWORD PTR shdr32$[rbp-76], 8
	je	SHORT $LN2@elf_write_

; 851  :             fileoffset += shdr32.sh_size;
; 852  :             fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR shdr32$[rbp-60]
	add	eax, 15
	add	edi, eax
	and	edi, -16				; fffffff0H
$LN2@elf_write_:

; 799  : 
; 800  :     /* write the section headers defined in the module, */
; 801  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rsi, QWORD PTR [rsi+104]
	test	rsi, rsi
	jne	$LL4@elf_write_
$LN3@elf_write_:

; 853  :         }
; 854  : 
; 855  :         DebugMsg(("elf_write_section_table32(%s): ofs=%X size=%X numrelocs=%u\n", curr->sym.name, shdr32.sh_offset, shdr32.sh_size, curr->e.seginfo->num_relocs));
; 856  :     }
; 857  : 
; 858  :     /* set size and contents of .symtab and .strtab sections */
; 859  :     set_symtab_values( em );

	mov	rcx, r14
	call	set_symtab_values

; 860  : 
; 861  :     /* write headers of internal sections */
; 862  :     for ( i = 0; i < NUM_INTSEGS; i++ ) {

	mov	rsi, r12
	lea	r13, OFFSET FLAT:internal_segparms+8
	npad	2
$LL7@elf_write_:

; 863  :         shdr32.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, ebx
	sub	eax, DWORD PTR [r14+32]
	mov	DWORD PTR shdr32$[rbp-80], eax

; 864  :         p += strlen( (char *)p ) + 1;

	or	rax, -1
	npad	3
$LL53@elf_write_:
	inc	rax
	cmp	BYTE PTR [rbx+rax], r12b
	jne	SHORT $LL53@elf_write_
	inc	rbx

; 865  :         shdr32.sh_type = internal_segparms[i].type;
; 866  :         shdr32.sh_flags = 0;

	mov	DWORD PTR shdr32$[rbp-72], r12d
	add	rbx, rax

; 867  :         shdr32.sh_offset = fileoffset; /* start of section in file */

	mov	DWORD PTR shdr32$[rbp-64], edi
	mov	rcx, rsi
	add	rcx, rcx
	mov	eax, DWORD PTR [r13+rcx*8]
	mov	DWORD PTR shdr32$[rbp-76], eax

; 868  :         em->internal_segs[i].fileoffset = fileoffset;
; 869  :         shdr32.sh_size = em->internal_segs[i].size;

	mov	eax, DWORD PTR [r14+rcx*8+24]
	mov	DWORD PTR shdr32$[rbp-60], eax
	mov	DWORD PTR [r14+rcx*8+28], edi

; 870  :         /* section .symtab is special */
; 871  :         if ( i == SYMTAB_IDX ) {

	cmp	rsi, 1
	jne	SHORT $LN22@elf_write_

; 872  :             shdr32.sh_link = 1 + modinfo->g.num_segs + STRTAB_IDX;

	mov	eax, DWORD PTR [r15+8]
	add	eax, 3

; 873  :             shdr32.sh_info = em->start_globals;
; 874  :             shdr32.sh_addralign = 4;

	mov	DWORD PTR shdr32$[rbp-48], 4
	mov	DWORD PTR shdr32$[rbp-56], eax
	mov	eax, DWORD PTR [r14+4]
	mov	DWORD PTR shdr32$[rbp-52], eax

; 875  :             shdr32.sh_entsize = sizeof( Elf32_Sym );

	mov	DWORD PTR shdr32$[rbp-44], 16

; 876  :         } else {

	jmp	SHORT $LN23@elf_write_
$LN22@elf_write_:

; 877  :             shdr32.sh_link = 0;

	mov	QWORD PTR shdr32$[rbp-56], r12

; 878  :             shdr32.sh_info = 0;
; 879  :             shdr32.sh_addralign = 1;

	mov	QWORD PTR shdr32$[rbp-48], 1
$LN23@elf_write_:

; 880  :             shdr32.sh_entsize = 0;
; 881  :         }
; 882  :         if ( fwrite( &shdr32, 1, sizeof( shdr32 ), CurrFile[OBJ] ) != sizeof( shdr32 ) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR shdr32$[rbp-80]
	mov	edx, 1
	lea	r8d, QWORD PTR [rdx+39]
	call	fwrite
	cmp	rax, 40					; 00000028H
	je	SHORT $LN24@elf_write_

; 883  :             WriteError();

	call	WriteError
$LN24@elf_write_:

; 884  : 
; 885  :         fileoffset += shdr32.sh_size;
; 886  :         fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR shdr32$[rbp-60]
	inc	rsi
	add	eax, 15
	add	edi, eax
	and	edi, -16				; fffffff0H
	cmp	rsi, 3
	jl	$LL7@elf_write_

; 887  :         DebugMsg(("elf_write_section_table32(%s): ofs=%X size=%X\n", internal_segparms[i].name, shdr32.sh_offset, shdr32.sh_size));
; 888  :     }
; 889  : 
; 890  :     /* write headers of reloc sections */
; 891  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rsi, QWORD PTR SymTables+32
	test	rsi, rsi
	je	$LN57@elf_write_
$LL10@elf_write_:

; 892  :         if ( curr->e.seginfo->FixupList.head == NULL )

	mov	rax, QWORD PTR [rsi+96]
	cmp	QWORD PTR [rax+40], r12
	je	$LN8@elf_write_

; 893  :             continue;
; 894  : 
; 895  :         memset( &shdr32, 0, sizeof( shdr32 ) );

	xor	eax, eax
	mov	QWORD PTR shdr32$[rbp-80], rax
	mov	QWORD PTR shdr32$[rbp-72], rax
	mov	QWORD PTR shdr32$[rbp-64], rax
	mov	QWORD PTR shdr32$[rbp-56], rax
	mov	QWORD PTR shdr32$[rbp-48], rax

; 896  : 
; 897  :         shdr32.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, ebx
	sub	eax, DWORD PTR [r14+32]
	mov	DWORD PTR shdr32$[rbp-80], eax

; 898  :         p += strlen( (char *)p ) + 1;

	or	rax, -1
$LL52@elf_write_:
	inc	rax
	cmp	BYTE PTR [rbx+rax], r12b
	jne	SHORT $LL52@elf_write_
	inc	rax

; 899  :         shdr32.sh_type = SHT_REL;

	mov	QWORD PTR shdr32$[rbp-76], 9

; 900  :         shdr32.sh_flags = 0;
; 901  :         shdr32.sh_addr = 0;

	mov	DWORD PTR shdr32$[rbp-68], r12d
	add	rbx, rax

; 902  :         shdr32.sh_offset = fileoffset; /* start of section in file */

	mov	DWORD PTR shdr32$[rbp-64], edi

; 903  :         /* save the file offset in the slot reserved for ELF relocs */
; 904  :         curr->e.seginfo->reloc_offset = fileoffset;

	mov	rax, QWORD PTR [rsi+96]
	mov	DWORD PTR [rax+12], edi

; 905  :         /* size of section in file */
; 906  :         shdr32.sh_size = curr->e.seginfo->num_relocs * sizeof( Elf32_Rel );

	mov	rax, QWORD PTR [rsi+96]
	mov	ecx, DWORD PTR [rax+64]

; 907  :         shdr32.sh_link = 1 + modinfo->g.num_segs + SYMTAB_IDX;

	mov	eax, DWORD PTR [r15+8]
	shl	ecx, 3
	add	eax, 2
	mov	DWORD PTR shdr32$[rbp-56], eax
	mov	DWORD PTR shdr32$[rbp-60], ecx

; 908  :         /* set info to the src section index */
; 909  :         shdr32.sh_info = GetSegIdx( curr->sym.segment );

	mov	rcx, QWORD PTR [rsi+24]
	call	GetSegIdx

; 910  :         shdr32.sh_addralign = 4;
; 911  :         shdr32.sh_entsize = sizeof( Elf32_Rel );
; 912  : 
; 913  :         if ( fwrite( &shdr32, 1, sizeof( shdr32 ), CurrFile[OBJ] ) != sizeof( shdr32 ) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR shdr32$[rbp-80]
	mov	edx, 1
	mov	DWORD PTR shdr32$[rbp-52], eax
	mov	DWORD PTR shdr32$[rbp-48], 4
	mov	DWORD PTR shdr32$[rbp-44], 8
	lea	r8d, QWORD PTR [rdx+39]
	call	fwrite
	cmp	rax, 40					; 00000028H
	je	SHORT $LN26@elf_write_

; 914  :             WriteError();

	call	WriteError
$LN26@elf_write_:

; 915  : 
; 916  :         fileoffset += shdr32.sh_size;
; 917  :         fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR shdr32$[rbp-60]
	add	eax, 15
	add	edi, eax
	and	edi, -16				; fffffff0H
$LN8@elf_write_:

; 887  :         DebugMsg(("elf_write_section_table32(%s): ofs=%X size=%X\n", internal_segparms[i].name, shdr32.sh_offset, shdr32.sh_size));
; 888  :     }
; 889  : 
; 890  :     /* write headers of reloc sections */
; 891  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rsi, QWORD PTR [rsi+104]
	test	rsi, rsi
	jne	$LL10@elf_write_
$LN57@elf_write_:

; 918  :         DebugMsg(("elf_write_section_table32(%s): relocs, ofs=%X size=%X\n", curr->sym.name, shdr32.sh_offset, shdr32.sh_size));
; 919  : 
; 920  :     }
; 921  :     DebugMsg(("elf_write_section_table32: exit, final fileofs=%X\n", fileoffset ));
; 922  :     return( NOT_ERROR );
; 923  : }

	lea	r11, QWORD PTR [rsp+80]
	xor	eax, eax
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
elf_write_section_table32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
;	COMDAT Get_Alignment
_TEXT	SEGMENT
curr$ = 8
Get_Alignment PROC					; COMDAT

; 761  :     if ( curr->e.seginfo->alignment == MAX_SEGALIGNMENT )

	mov	rax, QWORD PTR [rcx+96]
	movzx	ecx, BYTE PTR [rax+106]
	cmp	cl, 255					; 000000ffH
	jne	SHORT $LN2@Get_Alignm

; 762  :         return( 0 );

	xor	eax, eax

; 764  : }

	ret	0
$LN2@Get_Alignm:

; 763  :     return( 1 << curr->e.seginfo->alignment );

	mov	eax, 1
	shl	eax, cl

; 764  : }

	ret	0
Get_Alignment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
;	COMDAT get_relocation_count
_TEXT	SEGMENT
curr$ = 8
get_relocation_count PROC				; COMDAT

; 750  :     unsigned relocs;
; 751  :     struct fixup *fix;
; 752  : 
; 753  :     for ( relocs = 0, fix = curr->e.seginfo->FixupList.head; fix ; fix = fix->nextrlc, relocs++ );

	mov	rcx, QWORD PTR [rcx+96]
	xor	eax, eax
	mov	rcx, QWORD PTR [rcx+40]
	test	rcx, rcx
	je	SHORT $LN10@get_reloca
	npad	1
$LL4@get_reloca:
	mov	rcx, QWORD PTR [rcx+8]
	inc	eax
	test	rcx, rcx
	jne	SHORT $LL4@get_reloca
$LN10@get_reloca:

; 754  : 
; 755  :     return( relocs );
; 756  : }

	ret	0
get_relocation_count ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
;	COMDAT set_shstrtab_values
_TEXT	SEGMENT
buffer$ = 32
em$ = 304
set_shstrtab_values PROC				; COMDAT

; 686  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 288				; 00000120H

; 687  :     int         i;
; 688  :     struct dsym *curr;
; 689  :     char        *p;
; 690  :     unsigned int size = 1; /* the first byte at offset 0 is the NULL section name */
; 691  :     char buffer[MAX_ID_LEN+1];
; 692  : 
; 693  :     /* get size of section names defined in the program & relocation sections ) */
; 694  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	mov	rbp, rcx
	mov	edi, 1
	test	rbx, rbx
	je	SHORT $LN3@set_shstrt
$LL4@set_shstrt:

; 695  :         /* v2.07: ALIAS name defined? */
; 696  :         p = ( curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ElfConvertSectionName( &curr->sym, buffer ) );

	mov	rax, QWORD PTR [rbx+96]
	mov	rdx, QWORD PTR [rax+96]
	test	rdx, rdx
	jne	SHORT $LN21@set_shstrt
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbx
	call	ElfConvertSectionName
	mov	rdx, rax
$LN21@set_shstrt:

; 697  :         size += strlen( p ) + 1;

	or	rcx, -1
$LL68@set_shstrt:
	inc	rcx
	cmp	BYTE PTR [rdx+rcx], 0
	jne	SHORT $LL68@set_shstrt

; 698  :         if ( curr->e.seginfo->FixupList.head )

	mov	rax, QWORD PTR [rbx+96]
	inc	edi
	add	edi, ecx
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN2@set_shstrt

; 699  :             size += strlen( p ) +

	or	rcx, -1
	npad	2
$LL67@set_shstrt:
	inc	rcx
	cmp	BYTE PTR [rdx+rcx], 0
	jne	SHORT $LL67@set_shstrt
	xor	eax, eax
	cmp	BYTE PTR ModuleInfo+405, 2
	sete	al
	add	eax, 5
	add	edi, eax
	add	edi, ecx
$LN2@set_shstrt:

; 687  :     int         i;
; 688  :     struct dsym *curr;
; 689  :     char        *p;
; 690  :     unsigned int size = 1; /* the first byte at offset 0 is the NULL section name */
; 691  :     char buffer[MAX_ID_LEN+1];
; 692  : 
; 693  :     /* get size of section names defined in the program & relocation sections ) */
; 694  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	SHORT $LL4@set_shstrt
$LN3@set_shstrt:

; 700  : #if AMD64_SUPPORT
; 701  :                 (( ModuleInfo.defOfssize == USE64 ) ? sizeof(".rela") : sizeof(".rel"));
; 702  : #else
; 703  :                 sizeof(".rel");
; 704  : #endif
; 705  :     }
; 706  :     /* get internal section name sizes */
; 707  :     for ( i = 0; i < NUM_INTSEGS; i++ ) {

	lea	rsi, OFFSET FLAT:internal_segparms
	mov	rdx, rsi
	lea	r14, OFFSET FLAT:internal_segparms+48
	npad	10
$LL7@set_shstrt:

; 708  :         size += strlen( internal_segparms[i].name ) + 1;

	mov	rcx, QWORD PTR [rdx]
	or	rax, -1
$LL66@set_shstrt:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL66@set_shstrt
	inc	edi
	add	rdx, 16
	add	edi, eax
	cmp	rdx, r14
	jl	SHORT $LL7@set_shstrt

; 709  :     }
; 710  : 
; 711  :     em->internal_segs[SHSTRTAB_IDX].size = size;
; 712  : 
; 713  :     /* size is known, now alloc .shstrtab data buffer and fill it */
; 714  : 
; 715  :     em->internal_segs[SHSTRTAB_IDX].data = LclAlloc( size );

	mov	ecx, edi
	mov	DWORD PTR [rbp+24], edi
	call	LclAlloc
	mov	QWORD PTR [rbp+32], rax

; 716  :     p = (char *)em->internal_segs[SHSTRTAB_IDX].data;
; 717  :     *p++ = NULLC; /* NULL section name */

	mov	BYTE PTR [rax], 0
	lea	rbx, QWORD PTR [rax+1]

; 718  : 
; 719  :     /* 1. names of program sections */
; 720  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdi, QWORD PTR SymTables+32
	test	rdi, rdi
	je	SHORT $LL9@set_shstrt
	npad	2
$LL10@set_shstrt:

; 721  :         strcpy( p, curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ElfConvertSectionName( &curr->sym, buffer ) );

	mov	rcx, QWORD PTR [rdi+96]
	mov	rax, QWORD PTR [rcx+96]
	test	rax, rax
	jne	SHORT $LN23@set_shstrt
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rdi
	call	ElfConvertSectionName
$LN23@set_shstrt:
	mov	rdx, rbx
	sub	rdx, rax
$LL24@set_shstrt:
	movzx	ecx, BYTE PTR [rax]
	mov	BYTE PTR [rdx+rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL24@set_shstrt

; 722  :         p += strlen( p ) + 1;

	or	rax, -1
$LL65@set_shstrt:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL65@set_shstrt
	mov	rdi, QWORD PTR [rdi+104]
	inc	rbx
	add	rbx, rax
	test	rdi, rdi
	jne	SHORT $LL10@set_shstrt
	npad	6
$LL9@set_shstrt:

; 723  :     }
; 724  :     /* 2. names of internal sections */
; 725  :     for ( i = 0; i < NUM_INTSEGS; i++ ) {
; 726  :         strcpy( p, internal_segparms[i].name );

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, rbx
	npad	10
$LL25@set_shstrt:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL25@set_shstrt

; 727  :         p += strlen( p ) + 1;

	or	rax, -1
$LL64@set_shstrt:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL64@set_shstrt
	inc	rbx
	add	rsi, 16
	add	rbx, rax
	cmp	rsi, r14
	jl	SHORT $LL9@set_shstrt

; 728  :     }
; 729  :     /* 3. names of "relocation" sections */
; 730  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdi, QWORD PTR SymTables+32
	test	rdi, rdi
	je	$LN15@set_shstrt
	lea	rsi, OFFSET FLAT:$SG11540
	npad	12
$LL16@set_shstrt:

; 731  :         if ( curr->e.seginfo->FixupList.head ) {

	mov	rax, QWORD PTR [rdi+96]
	cmp	QWORD PTR [rax+40], 0
	je	$LN14@set_shstrt

; 732  : #if AMD64_SUPPORT
; 733  :             strcpy( p, (( ModuleInfo.defOfssize == USE64 ) ? ".rela": ".rel") );

	cmp	BYTE PTR ModuleInfo+405, 2
	lea	rcx, OFFSET FLAT:$SG11541
	mov	rdx, rbx
	cmove	rcx, rsi
	npad	12
$LL26@set_shstrt:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL26@set_shstrt

; 734  : #else
; 735  :             strcpy( p, ".rel" );
; 736  : #endif
; 737  :             p += strlen( p );

	or	rax, -1
$LL63@set_shstrt:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL63@set_shstrt
	add	rbx, rax

; 738  :             strcpy( p, curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ElfConvertSectionName( &curr->sym, buffer ) );

	mov	rax, QWORD PTR [rdi+96]
	mov	rax, QWORD PTR [rax+96]
	test	rax, rax
	jne	SHORT $LN28@set_shstrt
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rdi
	call	ElfConvertSectionName
$LN28@set_shstrt:
	mov	rdx, rbx
	sub	rdx, rax
$LL29@set_shstrt:
	movzx	ecx, BYTE PTR [rax]
	mov	BYTE PTR [rdx+rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL29@set_shstrt

; 739  :             p += strlen( p ) + 1;

	or	rax, -1
$LL62@set_shstrt:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL62@set_shstrt
	inc	rbx
	add	rbx, rax
$LN14@set_shstrt:

; 728  :     }
; 729  :     /* 3. names of "relocation" sections */
; 730  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdi, QWORD PTR [rdi+104]
	test	rdi, rdi
	jne	$LL16@set_shstrt
$LN15@set_shstrt:

; 740  :         }
; 741  :     }
; 742  :     /**/myassert( size == p - (char *)em->internal_segs[SHSTRTAB_IDX].data );
; 743  :     DebugMsg(("set_shstrtab_values: size=%X\n", size));
; 744  :     return;
; 745  : }

	lea	r11, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	r14
	ret	0
set_shstrtab_values ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
;	COMDAT set_symtab_values
_TEXT	SEGMENT
locals$ = 32
em$ = 80
set_symtab_values PROC					; COMDAT

; 540  : {

	push	rbx
	push	rdi
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+80], rbp
	xorps	xmm0, xmm0

; 541  :     uint_32 strsize;
; 542  :     uint_32 entries;
; 543  :     struct dsym *curr;
; 544  :     //struct asym *sym;
; 545  :     struct qnode *q;
; 546  :     char *p2;
; 547  :     struct {
; 548  :         struct localname *head;
; 549  :         struct localname *tail;
; 550  :     } locals = { NULL, NULL };
; 551  :     struct localname *localscurr;
; 552  : 
; 553  :     /* symbol table. there is
; 554  :      - 1 NULL entry,
; 555  :      - 1 entry for the module/file,
; 556  :      - 1 entry for each section and
; 557  :      - n entries for local symbols
; 558  :      - m entries for global symbols
; 559  :      */
; 560  : 
; 561  :     /* symbol table starts with 1 NULL entry + 1 file entry */
; 562  :     em->symindex = 1 + 1;

	mov	DWORD PTR [rcx], 2
	mov	rdi, rcx

; 563  : 
; 564  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next )

	mov	rbp, QWORD PTR SymTables+32
	mov	QWORD PTR [rsp+96], r14
	movdqu	XMMWORD PTR locals$[rsp], xmm0
	test	rbp, rbp
	je	$LN74@set_symtab
	npad	13
$LL4@set_symtab:

; 565  :         curr->sym.ext_idx = em->symindex++;

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rbp+88], eax
	inc	DWORD PTR [rcx]
	mov	rbp, QWORD PTR [rbp+104]
	test	rbp, rbp
	jne	SHORT $LL4@set_symtab

; 566  : 
; 567  :     /* add local symbols to symbol table */
; 568  : 
; 569  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbp, QWORD PTR SymTables+32
	test	rbp, rbp
	je	$LN74@set_symtab
	mov	r14, QWORD PTR locals$[rsp]
	mov	QWORD PTR [rsp+88], rsi
	mov	rsi, QWORD PTR locals$[rsp+8]
	mov	QWORD PTR [rsp+48], r15
	xor	r15d, r15d
	npad	9
$LL7@set_symtab:

; 570  :         if ( curr->e.seginfo->num_relocs ) {

	mov	rbx, QWORD PTR [rbp+96]
	cmp	DWORD PTR [rbx+64], r15d
	je	SHORT $LN5@set_symtab

; 571  :             struct fixup *fix = curr->e.seginfo->FixupList.head;

	mov	rbx, QWORD PTR [rbx+40]

; 572  :             for ( ; fix; fix = fix->nextrlc ) {

	test	rbx, rbx
	je	SHORT $LN5@set_symtab
$LL10@set_symtab:

; 573  :                 /* if it's not EXTERNAL/PUBLIC, add symbol. */
; 574  :                 /* however, if it's an assembly time variable */
; 575  :                 /* use a raw section reference */
; 576  :                 if ( fix->sym->variable ) {

	mov	rax, QWORD PTR [rbx+56]
	movzx	edx, BYTE PTR [rax+40]
	test	dl, 64					; 00000040H
	je	SHORT $LN27@set_symtab

; 577  :                     fix->sym = fix->segment_var;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR [rbx+56], rax

; 578  :                 } else if ( ( fix->sym->state == SYM_INTERNAL ) &&

	jmp	SHORT $LN8@set_symtab
$LN27@set_symtab:

; 579  :                     fix->sym->included == FALSE &&

	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN8@set_symtab
	movzx	ecx, BYTE PTR [rax+41]
	test	cl, 64					; 00000040H
	jne	SHORT $LN8@set_symtab
	test	dl, dl
	js	SHORT $LN8@set_symtab

; 580  :                     fix->sym->ispublic == FALSE ) {
; 581  :                     fix->sym->included = TRUE;

	or	cl, 64					; 00000040H
	mov	BYTE PTR [rax+41], cl

; 582  :                     localscurr = LclAlloc( sizeof( struct localname ) );

	mov	ecx, 16
	call	LclAlloc

; 583  :                     localscurr->next = NULL;

	mov	QWORD PTR [rax], r15

; 584  :                     localscurr->sym = fix->sym;

	mov	rcx, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax+8], rcx

; 585  :                     if (locals.tail) {

	test	rsi, rsi
	je	SHORT $LN30@set_symtab

; 586  :                         locals.tail->next = localscurr;

	mov	QWORD PTR [rsi], rax

; 587  :                         locals.tail = localscurr;
; 588  :                     } else {

	jmp	SHORT $LN76@set_symtab
$LN30@set_symtab:

; 589  :                         locals.head = locals.tail = localscurr;

	mov	r14, rax
$LN76@set_symtab:

; 590  :                     }
; 591  :                     fix->sym->ext_idx = em->symindex++;

	mov	rcx, QWORD PTR [rbx+56]
	mov	rsi, rax
	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rcx+88], eax
	inc	DWORD PTR [rdi]
$LN8@set_symtab:

; 572  :             for ( ; fix; fix = fix->nextrlc ) {

	mov	rbx, QWORD PTR [rbx+8]
	test	rbx, rbx
	jne	SHORT $LL10@set_symtab
$LN5@set_symtab:

; 566  : 
; 567  :     /* add local symbols to symbol table */
; 568  : 
; 569  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbp, QWORD PTR [rbp+104]
	test	rbp, rbp
	jne	$LL7@set_symtab
	mov	r15, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+88]
	jmp	SHORT $LN6@set_symtab
$LN74@set_symtab:
	mov	r14, QWORD PTR locals$[rsp]
$LN6@set_symtab:

; 592  :                 }
; 593  :             }
; 594  :         }
; 595  :     }
; 596  :     DebugMsg(("set_symtab_values: index after sections: %u\n", em->symindex));
; 597  :     em->start_globals = em->symindex;

	mov	eax, DWORD PTR [rdi]
	mov	rbp, QWORD PTR [rsp+80]
	mov	DWORD PTR [rdi+4], eax

; 598  : 
; 599  :     /* count EXTERNs and used EXTERNDEFs (and PROTOs [since v2.01]) */
; 600  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	rcx, QWORD PTR SymTables+16
	test	rcx, rcx
	je	SHORT $LN12@set_symtab
$LL13@set_symtab:

; 601  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE )

	movzx	eax, BYTE PTR [rcx+47]
	test	al, 4
	jne	SHORT $LN32@set_symtab
	test	al, 8
	jne	SHORT $LN11@set_symtab
$LN32@set_symtab:

; 602  :             continue;
; 603  :         curr->sym.ext_idx = em->symindex++;

	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rcx+88], eax
	inc	DWORD PTR [rdi]
$LN11@set_symtab:

; 598  : 
; 599  :     /* count EXTERNs and used EXTERNDEFs (and PROTOs [since v2.01]) */
; 600  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL13@set_symtab
$LN12@set_symtab:

; 604  :     }
; 605  :     DebugMsg(("set_symtab_values: index after EXTERNALs: %u\n", em->symindex));
; 606  : 
; 607  : #if ELFALIAS
; 608  :     /* count aliases */
; 609  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {
; 610  :         curr->sym.idx = em->symindex++;
; 611  :     }
; 612  :     DebugMsg(("set_symtab_values: index after ALIASES: %u\n", em->symindex));
; 613  : #endif
; 614  : 
; 615  :     /* count publics */
; 616  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rdx, QWORD PTR ModuleInfo+16
	test	rdx, rdx
	je	SHORT $LN15@set_symtab
	npad	8
$LL16@set_symtab:

; 617  :         q->sym->ext_idx = em->symindex++;

	mov	rcx, QWORD PTR [rdx+8]
	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rcx+88], eax
	inc	DWORD PTR [rdi]
	mov	rdx, QWORD PTR [rdx]
	test	rdx, rdx
	jne	SHORT $LL16@set_symtab
$LN15@set_symtab:

; 618  :     }
; 619  :     DebugMsg(("set_symtab_values: index after PUBLICs: %u\n", em->symindex));
; 620  : 
; 621  :     /* size of symbol table is defined */
; 622  :     entries = em->symindex;
; 623  : 
; 624  : #if ADDSTARTLABEL
; 625  :     if ( ModuleInfo.g.start_label )
; 626  :         entries++;
; 627  : #endif
; 628  : 
; 629  : #if AMD64_SUPPORT
; 630  :     if ( ModuleInfo.defOfssize == USE64 )

	cmp	BYTE PTR ModuleInfo+405, 2

; 631  :         strsize = set_symtab64( em, entries, locals.head );

	mov	r8, r14
	mov	edx, DWORD PTR [rdi]
	mov	rcx, rdi
	jne	SHORT $LN33@set_symtab
	call	set_symtab64
	jmp	SHORT $LN34@set_symtab
$LN33@set_symtab:

; 632  :     else
; 633  : #endif
; 634  :         strsize = set_symtab32( em, entries, locals.head );

	call	set_symtab32
$LN34@set_symtab:

; 635  : 
; 636  :     /* generate the string table */
; 637  :     DebugMsg(("set_symtab_values: creating string table, size=%X\n", strsize));
; 638  : 
; 639  :     em->internal_segs[STRTAB_IDX].size = strsize;
; 640  :     em->internal_segs[STRTAB_IDX].data = LclAlloc( strsize );

	mov	ecx, eax
	mov	DWORD PTR [rdi+56], eax
	mov	ebx, eax
	call	LclAlloc

; 641  :     memset( em->internal_segs[STRTAB_IDX].data, 0, strsize );

	mov	r8d, ebx
	mov	QWORD PTR [rdi+64], rax
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 642  :     p2 = em->internal_segs[STRTAB_IDX].data;

	mov	r8, QWORD PTR [rdi+64]

; 643  :     *p2++ = NULLC;

	mov	BYTE PTR [r8], 0

; 644  : 
; 645  :     strcpy( p2, em->srcname );

	lea	rdx, QWORD PTR [r8+1]
	mov	rcx, QWORD PTR [rdi+8]
	npad	3
$LL37@set_symtab:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL37@set_symtab

; 646  :     p2 += strlen( p2 ) + 1;

	or	rax, -1
$LL73@set_symtab:
	inc	rax
	cmp	BYTE PTR [r8+rax+1], 0
	jne	SHORT $LL73@set_symtab
	lea	rbx, QWORD PTR [r8+2]
	add	rbx, rax

; 647  : 
; 648  :     for ( localscurr = locals.head ; localscurr ; localscurr = localscurr->next ) {

	test	r14, r14
	je	SHORT $LN18@set_symtab
	npad	4
$LL19@set_symtab:

; 649  :         p2 += Mangle( localscurr->sym, p2 ) + 1;

	mov	rcx, QWORD PTR [r14+8]
	mov	rdx, rbx
	call	Mangle
	mov	r14, QWORD PTR [r14]
	inc	eax
	cdqe
	add	rbx, rax
	test	r14, r14
	jne	SHORT $LL19@set_symtab
$LN18@set_symtab:

; 650  :     }
; 651  : 
; 652  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	rdi, QWORD PTR SymTables+16
	mov	r14, QWORD PTR [rsp+96]
	test	rdi, rdi
	je	SHORT $LN21@set_symtab
	npad	4
$LL22@set_symtab:

; 653  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE )

	movzx	eax, BYTE PTR [rdi+47]
	test	al, 4
	jne	SHORT $LN35@set_symtab
	test	al, 8
	jne	SHORT $LN20@set_symtab
$LN35@set_symtab:

; 654  :             continue;
; 655  :         p2 += Mangle( &curr->sym, p2 ) + 1;

	mov	rdx, rbx
	mov	rcx, rdi
	call	Mangle
	inc	eax
	cdqe
	add	rbx, rax
$LN20@set_symtab:

; 650  :     }
; 651  : 
; 652  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	rdi, QWORD PTR [rdi+104]
	test	rdi, rdi
	jne	SHORT $LL22@set_symtab
$LN21@set_symtab:

; 656  :     }
; 657  : 
; 658  : #if ELFALIAS
; 659  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {
; 660  :         p2 += Mangle( &curr->sym, p2 ) + 1;
; 661  :     }
; 662  : #endif
; 663  : 
; 664  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rdi, QWORD PTR ModuleInfo+16
	test	rdi, rdi
	je	SHORT $LN24@set_symtab
$LL25@set_symtab:

; 665  :         p2 += Mangle( q->sym, p2 ) + 1;

	mov	rcx, QWORD PTR [rdi+8]
	mov	rdx, rbx
	call	Mangle
	mov	rdi, QWORD PTR [rdi]
	inc	eax
	cdqe
	add	rbx, rax
	test	rdi, rdi
	jne	SHORT $LL25@set_symtab
$LN24@set_symtab:

; 666  :     }
; 667  : #if ADDSTARTLABEL
; 668  :     if ( ModuleInfo.g.start_label ) {
; 669  :         Mangle( ModuleInfo.g.start_label, p2 );
; 670  :     }
; 671  : #endif
; 672  :     DebugMsg(("set_symtab_values: exit, symindex=%u\n", em->symindex ));
; 673  :     return;
; 674  : }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rbx
	ret	0
set_symtab_values ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
;	COMDAT set_symtab64
_TEXT	SEGMENT
buffer$ = 32
em$ = 320
entries$ = 328
localshead$ = 336
set_symtab64 PROC					; COMDAT

; 366  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r15
	sub	rsp, 288				; 00000120H
	mov	rdi, rcx
	mov	rsi, r8

; 367  :     uint_32   strsize = 1;
; 368  :     uint_32   len;
; 369  :     uint_8    stt;
; 370  :     struct dsym   *curr;
; 371  :     struct asym   *sym;
; 372  :     struct localname *localscurr;
; 373  :     struct qnode  *q;
; 374  :     Elf64_Sym *p64;
; 375  :     char      buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 376  : 
; 377  :     em->internal_segs[SYMTAB_IDX].size = entries * sizeof( Elf64_Sym );

	lea	ecx, DWORD PTR [rdx+rdx*2]
	shl	ecx, 3
	mov	DWORD PTR [rdi+40], ecx

; 378  :     em->internal_segs[SYMTAB_IDX].data = LclAlloc( em->internal_segs[SYMTAB_IDX].size );

	call	LclAlloc

; 379  :     memset( em->internal_segs[SYMTAB_IDX].data, 0, em->internal_segs[SYMTAB_IDX].size );

	mov	r8d, DWORD PTR [rdi+40]
	xor	edx, edx
	mov	rcx, rax
	mov	QWORD PTR [rdi+48], rax
	call	memset

; 380  : 
; 381  :     p64 = (Elf64_Sym *)em->internal_segs[SYMTAB_IDX].data;
; 382  : 
; 383  :     p64++; /* skip NULL entry */

	mov	rbx, QWORD PTR [rdi+48]

; 384  : 
; 385  :     /* 1. make file entry */
; 386  :     p64->st_name = strsize;  /* symbol's name in string table */

	mov	DWORD PTR [rbx+24], 1

; 387  :     strsize += strlen( em->srcname ) + 1;

	mov	rax, QWORD PTR [rdi+8]
	or	rdi, -1
$LL46@set_symtab:
	inc	rdi
	cmp	BYTE PTR [rax+rdi], 0
	jne	SHORT $LL46@set_symtab

; 388  :     p64->st_value = 0;

	xor	r12d, r12d

; 389  :     p64->st_size = 0;
; 390  :     p64->st_info = ELF64_ST_INFO( STB_LOCAL, STT_FILE ); /* symbol's type and binding info */

	mov	BYTE PTR [rbx+28], 4
	mov	QWORD PTR [rbx+32], r12

; 391  :     p64->st_shndx = SHN_ABS; /* section index */

	mov	r15d, 65521				; 0000fff1H
	mov	QWORD PTR [rbx+40], r12
	add	edi, 2
	mov	WORD PTR [rbx+30], r15w

; 392  :     p64++;

	add	rbx, 48					; 00000030H

; 393  : 
; 394  :     /* 2. make section entries */
; 395  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbp, QWORD PTR SymTables+32
	test	rbp, rbp
	je	SHORT $LN3@set_symtab
	npad	6
$LL4@set_symtab:

; 396  :         //p64->st_name = ?;  /* name isn't set */
; 397  :         p64->st_info = ELF64_ST_INFO( STB_LOCAL, STT_SECTION );

	mov	BYTE PTR [rbx+4], 3

; 398  :         p64->st_shndx = GetSegIdx( curr->sym.segment );

	mov	rcx, QWORD PTR [rbp+24]
	call	GetSegIdx
	mov	WORD PTR [rbx+6], ax

; 399  :         p64++;

	add	rbx, 24
	mov	rbp, QWORD PTR [rbp+104]
	test	rbp, rbp
	jne	SHORT $LL4@set_symtab
$LN3@set_symtab:

; 400  :     }
; 401  : 
; 402  :     /* 3. locals */
; 403  : 
; 404  :     for ( localscurr = localshead ; localscurr ; localscurr = localscurr->next ) {

	test	rsi, rsi
	je	SHORT $LN6@set_symtab
	npad	13
$LL7@set_symtab:

; 405  :         len = Mangle( localscurr->sym, buffer );

	mov	rcx, QWORD PTR [rsi+8]
	lea	rdx, QWORD PTR buffer$[rsp]
	call	Mangle

; 406  :         p64->st_name = strsize;

	mov	DWORD PTR [rbx], edi
	mov	ebp, eax

; 407  :         curr = (struct dsym *)localscurr->sym->segment;

	mov	rcx, QWORD PTR [rsi+8]
	mov	r8, QWORD PTR [rcx+24]

; 408  :         if ( curr && curr->e.seginfo->segtype != SEGTYPE_CODE )

	test	r8, r8
	je	SHORT $LN14@set_symtab
	mov	rcx, QWORD PTR [r8+96]
	cmp	DWORD PTR [rcx+72], 1

; 409  :             stt = STT_OBJECT;

	mov	cl, 1
	jne	SHORT $LN15@set_symtab
$LN14@set_symtab:

; 410  :         else
; 411  :             stt = STT_FUNC;

	mov	cl, 2
$LN15@set_symtab:

; 412  :         p64->st_info = ELF64_ST_INFO( STB_LOCAL, stt );

	and	cl, 15
	mov	BYTE PTR [rbx+4], cl

; 413  :         p64->st_value = localscurr->sym->offset;

	mov	rax, QWORD PTR [rsi+8]
	movsxd	rdx, DWORD PTR [rax+16]
	mov	QWORD PTR [rbx+8], rdx

; 414  : #if 1 /* v2.07: changed - to make MT_ABS obsolete */
; 415  :         if ( curr )

	test	r8, r8
	je	SHORT $LN16@set_symtab

; 416  :             p64->st_shndx = GetSegIdx( &curr->sym );

	mov	rcx, r8
	call	GetSegIdx
	mov	WORD PTR [rbx+6], ax
	jmp	SHORT $LN17@set_symtab
$LN16@set_symtab:

; 417  :         else
; 418  :             p64->st_shndx = SHN_ABS;

	mov	WORD PTR [rbx+6], r15w
$LN17@set_symtab:

; 400  :     }
; 401  : 
; 402  :     /* 3. locals */
; 403  : 
; 404  :     for ( localscurr = localshead ; localscurr ; localscurr = localscurr->next ) {

	mov	rsi, QWORD PTR [rsi]

; 419  : #else
; 420  :         if ( localscurr->sym->mem_type == MT_ABS )
; 421  :             p64->st_shndx = SHN_ABS;
; 422  :         else
; 423  :             p64->st_shndx = GetSegIdx( &curr->sym );
; 424  : #endif
; 425  :         strsize += len + 1;

	inc	edi
	add	edi, ebp

; 426  :         DebugMsg(("set_symtab64, LOCAL: symbol %s, value=%" I64_SPEC "X\n", buffer, p64->st_value));
; 427  :         p64++;

	add	rbx, 24
	test	rsi, rsi
	jne	SHORT $LL7@set_symtab
$LN6@set_symtab:

; 428  :     }
; 429  : 
; 430  :     /* 4. externals + communals ( + protos [since v2.01]) */
; 431  : 
; 432  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	rsi, QWORD PTR SymTables+16
	mov	QWORD PTR [rsp+320], r14
	test	rsi, rsi
	je	SHORT $LN9@set_symtab
	mov	ebp, 65522				; 0000fff2H
	mov	r14d, 32				; 00000020H
$LL10@set_symtab:

; 433  :         /* skip "weak" (=unused) externdefs */
; 434  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE )

	movzx	eax, BYTE PTR [rsi+47]
	test	al, 4
	jne	SHORT $LN18@set_symtab
	test	al, 8
	jne	SHORT $LN8@set_symtab
$LN18@set_symtab:

; 435  :             continue;
; 436  :         len = Mangle( &curr->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rsi
	call	Mangle

; 437  : 
; 438  :         p64->st_name = strsize;

	mov	DWORD PTR [rbx], edi
	mov	edx, eax

; 439  : 
; 440  :         /* for COMMUNALs, store their size in the Value field */
; 441  :         if ( curr->sym.iscomm == TRUE ) {

	test	BYTE PTR [rsi+47], 4
	je	SHORT $LN19@set_symtab

; 442  :             p64->st_info = ELF64_ST_INFO( STB_GLOBAL, STT_COMMON );

	mov	BYTE PTR [rbx+4], 21

; 443  :             p64->st_value = curr->sym.total_size;

	mov	ecx, DWORD PTR [rsi+56]
	mov	QWORD PTR [rbx+8], rcx

; 444  :             p64->st_shndx = SHN_COMMON;

	mov	WORD PTR [rbx+6], bp

; 445  :         } else {

	jmp	SHORT $LN20@set_symtab
$LN19@set_symtab:

; 446  : #if OWELFIMPORT
; 447  :             p64->st_info = ( IsWeak( curr->sym ) ? ELF64_ST_INFO( STB_WEAK, STT_IMPORT ) : ELF64_ST_INFO( STB_GLOBAL, STT_IMPORT ) );
; 448  : #else
; 449  :             /* todo: set STT_FUNC for prototypes??? */
; 450  :             p64->st_info = ( IsWeak( curr->sym ) ? ELF64_ST_INFO( STB_WEAK, STT_NOTYPE ) : ELF64_ST_INFO( STB_GLOBAL, STT_NOTYPE ) );

	cmp	QWORD PTR [rsi+64], r12
	mov	eax, 16
	cmovne	eax, r14d
	mov	BYTE PTR [rbx+4], al

; 451  : #endif
; 452  :             p64->st_value = curr->sym.offset; /* is always 0 */

	movsxd	rax, DWORD PTR [rsi+16]
	mov	QWORD PTR [rbx+8], rax

; 453  :             p64->st_shndx = SHN_UNDEF;

	mov	WORD PTR [rbx+6], r12w
$LN20@set_symtab:

; 454  :         }
; 455  : 
; 456  :         strsize += len + 1;

	inc	edi
	add	edi, edx

; 457  :         DebugMsg(("set_symtab64, EXTERNAL: symbol %s, info=%X, shndx=%X, value=%" I64_SPEC "X\n", buffer, p64->st_info, p64->st_shndx, p64->st_value));
; 458  :         p64++;

	add	rbx, 24
$LN8@set_symtab:

; 428  :     }
; 429  : 
; 430  :     /* 4. externals + communals ( + protos [since v2.01]) */
; 431  : 
; 432  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	rsi, QWORD PTR [rsi+104]
	test	rsi, rsi
	jne	SHORT $LL10@set_symtab
$LN9@set_symtab:

; 459  :     }
; 460  : 
; 461  : #if ELFALIAS
; 462  :     /* 5. aliases */
; 463  : 
; 464  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {
; 465  :         len = Mangle( &curr->sym, buffer );
; 466  : 
; 467  :         p64->st_name = strsize;
; 468  : 
; 469  : #if OWELFIMPORT
; 470  :         p64->st_info = ELF64_ST_INFO( STB_WEAK, STT_IMPORT );
; 471  : #else
; 472  :         p64->st_info = ELF64_ST_INFO( STB_WEAK, STT_NOTYPE );
; 473  : #endif
; 474  :         p64->st_value = 0; /* is always 0 */
; 475  :         p64->st_shndx = SHN_UNDEF;
; 476  : 
; 477  :         strsize += len + 1;
; 478  :         DebugMsg(("set_symtab64, ALIASES: symbol %s, value=%" I64_SPEC "X\n", buffer, p64->st_value));
; 479  :         p64++;
; 480  :     }
; 481  : #endif
; 482  : 
; 483  :     /* 6. PUBLIC entries */
; 484  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rsi, QWORD PTR ModuleInfo+16
	test	rsi, rsi
	je	SHORT $LN47@set_symtab
$LL13@set_symtab:

; 485  :         sym = q->sym;

	mov	rbp, QWORD PTR [rsi+8]

; 486  :         len = Mangle( sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbp
	call	Mangle

; 487  : 
; 488  :         curr = (struct dsym *)sym->segment;

	mov	rdx, QWORD PTR [rbp+24]
	mov	r14d, eax

; 489  :         if ( curr && curr->e.seginfo->segtype != SEGTYPE_CODE )

	test	rdx, rdx
	je	SHORT $LN21@set_symtab
	mov	rcx, QWORD PTR [rdx+96]
	cmp	DWORD PTR [rcx+72], 1

; 490  :             stt = STT_OBJECT;

	mov	cl, 1
	jne	SHORT $LN22@set_symtab
$LN21@set_symtab:

; 491  :         else
; 492  :             stt = STT_FUNC;

	mov	cl, 2
$LN22@set_symtab:

; 493  : 
; 494  :         p64->st_name = strsize;
; 495  :         p64->st_info = ELF64_ST_INFO( STB_GLOBAL, stt );

	and	cl, 15
	mov	DWORD PTR [rbx], edi
	add	cl, 16
	mov	BYTE PTR [rbx+4], cl

; 496  :         p64->st_value = sym->offset;

	movsxd	rax, DWORD PTR [rbp+16]
	mov	QWORD PTR [rbx+8], rax

; 497  : #if 1 /* v2.07: changed - to make MT_ABS obsolete */
; 498  :         if ( sym->state == SYM_INTERNAL )

	cmp	DWORD PTR [rbp+32], 1
	jne	SHORT $LN23@set_symtab

; 499  :             if ( curr )

	test	rdx, rdx
	je	SHORT $LN25@set_symtab

; 500  :                 p64->st_shndx = GetSegIdx( &curr->sym );

	mov	rcx, rdx
	call	GetSegIdx
	mov	WORD PTR [rbx+6], ax
	jmp	SHORT $LN24@set_symtab
$LN25@set_symtab:

; 501  :             else
; 502  :                 p64->st_shndx = SHN_ABS;

	mov	WORD PTR [rbx+6], r15w
	jmp	SHORT $LN24@set_symtab
$LN23@set_symtab:

; 503  :         else
; 504  :             p64->st_shndx = SHN_UNDEF;

	mov	WORD PTR [rbx+6], r12w
$LN24@set_symtab:

; 459  :     }
; 460  : 
; 461  : #if ELFALIAS
; 462  :     /* 5. aliases */
; 463  : 
; 464  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {
; 465  :         len = Mangle( &curr->sym, buffer );
; 466  : 
; 467  :         p64->st_name = strsize;
; 468  : 
; 469  : #if OWELFIMPORT
; 470  :         p64->st_info = ELF64_ST_INFO( STB_WEAK, STT_IMPORT );
; 471  : #else
; 472  :         p64->st_info = ELF64_ST_INFO( STB_WEAK, STT_NOTYPE );
; 473  : #endif
; 474  :         p64->st_value = 0; /* is always 0 */
; 475  :         p64->st_shndx = SHN_UNDEF;
; 476  : 
; 477  :         strsize += len + 1;
; 478  :         DebugMsg(("set_symtab64, ALIASES: symbol %s, value=%" I64_SPEC "X\n", buffer, p64->st_value));
; 479  :         p64++;
; 480  :     }
; 481  : #endif
; 482  : 
; 483  :     /* 6. PUBLIC entries */
; 484  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rsi, QWORD PTR [rsi]

; 505  : #else
; 506  :         if ( sym->mem_type == MT_ABS )
; 507  :             p64->st_shndx = SHN_ABS;
; 508  :         else if ( curr )
; 509  :             p64->st_shndx = GetSegIdx( &curr->sym );
; 510  :         else
; 511  :             p64->st_shndx = SHN_UNDEF;
; 512  : #endif
; 513  :         strsize += len + 1;

	inc	edi
	add	edi, r14d

; 514  : 
; 515  :         DebugMsg(("set_symtab64, PUBLIC+LOCAL: symbol %s, info=%X, shndx=%X, value=%" I64_SPEC "X\n", buffer, p64->st_info, p64->st_shndx, p64->st_value));
; 516  : 
; 517  :         p64++;

	add	rbx, 24
	test	rsi, rsi
	jne	SHORT $LL13@set_symtab
$LN47@set_symtab:
	mov	r14, QWORD PTR [rsp+320]

; 518  :     }
; 519  : #if ADDSTARTLABEL
; 520  :     if ( ModuleInfo.g.start_label ) {
; 521  :         len = Mangle( ModuleInfo.g.start_label, buffer );
; 522  :         p64->st_name = strsize;
; 523  :         p64->st_info = ELF64_ST_INFO( STB_ENTRY, STT_FUNC );
; 524  :         p64->st_value = ModuleInfo.g.start_label->offset;
; 525  :         p64->st_shndx = GetSegIdx( ModuleInfo.g.start_label->segment );
; 526  :         strsize += len + 1;
; 527  :         DebugMsg(("set_symtab64, ENTRY: symbol %s, value=%" I64_SPEC "X\n", buffer, p64->st_value));
; 528  :         p64++;
; 529  :     }
; 530  : #endif
; 531  :     return( strsize );
; 532  : }

	lea	r11, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [r11+40]
	mov	eax, edi
	mov	rbp, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r15
	pop	r12
	pop	rdi
	ret	0
set_symtab64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
;	COMDAT set_symtab32
_TEXT	SEGMENT
buffer$ = 32
em$ = 320
entries$ = 328
localshead$ = 336
set_symtab32 PROC					; COMDAT

; 184  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r15
	sub	rsp, 288				; 00000120H
	mov	rdi, rcx

; 185  :     uint_32   strsize = 1;
; 186  :     uint_32   len;
; 187  :     uint_8    stt;
; 188  :     struct dsym   *curr;
; 189  :     struct asym   *sym;
; 190  :     struct localname *localscurr;
; 191  :     struct qnode  *q;
; 192  :     Elf32_Sym *p32;
; 193  :     char      buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 194  : 
; 195  :     em->internal_segs[SYMTAB_IDX].size = entries * sizeof( Elf32_Sym );

	shl	edx, 4
	mov	ecx, edx
	mov	rsi, r8
	mov	DWORD PTR [rdi+40], ecx

; 196  :     em->internal_segs[SYMTAB_IDX].data = LclAlloc( em->internal_segs[SYMTAB_IDX].size );

	call	LclAlloc

; 197  :     memset( em->internal_segs[SYMTAB_IDX].data, 0, em->internal_segs[SYMTAB_IDX].size );

	mov	r8d, DWORD PTR [rdi+40]
	xor	edx, edx
	mov	rcx, rax
	mov	QWORD PTR [rdi+48], rax
	call	memset

; 198  : 
; 199  :     p32 = (Elf32_Sym *)em->internal_segs[SYMTAB_IDX].data;
; 200  : 
; 201  :     p32++; /* skip NULL entry */

	mov	rbx, QWORD PTR [rdi+48]

; 202  : 
; 203  :     /* 1. make file entry */
; 204  :     p32->st_name = strsize;  /* symbol's name in string table */

	mov	DWORD PTR [rbx+16], 1

; 205  :     strsize += strlen( em->srcname ) + 1;

	mov	rax, QWORD PTR [rdi+8]
	or	rdi, -1
$LL46@set_symtab:
	inc	rdi
	cmp	BYTE PTR [rax+rdi], 0
	jne	SHORT $LL46@set_symtab

; 206  :     p32->st_value = 0;

	xor	r12d, r12d

; 207  :     p32->st_size = 0;
; 208  :     p32->st_info = ELF32_ST_INFO( STB_LOCAL, STT_FILE ); /* symbol's type and binding info */

	mov	BYTE PTR [rbx+28], 4
	mov	QWORD PTR [rbx+20], r12

; 209  :     p32->st_shndx = SHN_ABS; /* section index */

	mov	r15d, 65521				; 0000fff1H
	mov	WORD PTR [rbx+30], r15w
	add	edi, 2

; 210  :     p32++;
; 211  : 
; 212  :     /* 2. make section entries */
; 213  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbp, QWORD PTR SymTables+32
	add	rbx, 32					; 00000020H
	test	rbp, rbp
	je	SHORT $LN3@set_symtab
	npad	11
$LL4@set_symtab:

; 214  :         //p32->st_name = ?;  /* name isn't set */
; 215  :         p32->st_info = ELF32_ST_INFO( STB_LOCAL, STT_SECTION );

	mov	BYTE PTR [rbx+12], 3

; 216  :         p32->st_shndx = GetSegIdx( curr->sym.segment );

	mov	rcx, QWORD PTR [rbp+24]
	call	GetSegIdx
	mov	WORD PTR [rbx+14], ax

; 217  :         p32++;

	add	rbx, 16
	mov	rbp, QWORD PTR [rbp+104]
	test	rbp, rbp
	jne	SHORT $LL4@set_symtab
$LN3@set_symtab:

; 218  :     }
; 219  : 
; 220  :     /* 3. locals */
; 221  : 
; 222  :     for ( localscurr = localshead ; localscurr ; localscurr = localscurr->next ) {

	test	rsi, rsi
	je	SHORT $LN6@set_symtab
	npad	13
$LL7@set_symtab:

; 223  :         len = Mangle( localscurr->sym, buffer );

	mov	rcx, QWORD PTR [rsi+8]
	lea	rdx, QWORD PTR buffer$[rsp]
	call	Mangle

; 224  :         p32->st_name = strsize;

	mov	DWORD PTR [rbx], edi
	mov	ebp, eax

; 225  :         curr = (struct dsym *)localscurr->sym->segment;

	mov	rcx, QWORD PTR [rsi+8]
	mov	r8, QWORD PTR [rcx+24]

; 226  :         if ( curr && curr->e.seginfo->segtype != SEGTYPE_CODE )

	test	r8, r8
	je	SHORT $LN14@set_symtab
	mov	rcx, QWORD PTR [r8+96]
	cmp	DWORD PTR [rcx+72], 1

; 227  :             stt = STT_OBJECT;

	mov	cl, 1
	jne	SHORT $LN15@set_symtab
$LN14@set_symtab:

; 228  :         else
; 229  :             stt = STT_FUNC;

	mov	cl, 2
$LN15@set_symtab:

; 230  :         p32->st_info = ELF32_ST_INFO( STB_LOCAL, stt );

	and	cl, 15
	mov	BYTE PTR [rbx+12], cl

; 231  :         p32->st_value = localscurr->sym->offset;

	mov	rax, QWORD PTR [rsi+8]
	mov	edx, DWORD PTR [rax+16]
	mov	DWORD PTR [rbx+4], edx

; 232  : #if 1 /* v2.07: changed - to make MT_ABS obsolete */
; 233  :         if ( curr )

	test	r8, r8
	je	SHORT $LN16@set_symtab

; 234  :             p32->st_shndx = GetSegIdx( &curr->sym );

	mov	rcx, r8
	call	GetSegIdx
	mov	WORD PTR [rbx+14], ax
	jmp	SHORT $LN17@set_symtab
$LN16@set_symtab:

; 235  :         else
; 236  :             p32->st_shndx = SHN_ABS;

	mov	WORD PTR [rbx+14], r15w
$LN17@set_symtab:

; 218  :     }
; 219  : 
; 220  :     /* 3. locals */
; 221  : 
; 222  :     for ( localscurr = localshead ; localscurr ; localscurr = localscurr->next ) {

	mov	rsi, QWORD PTR [rsi]

; 237  : #else
; 238  :         if ( localscurr->sym->mem_type == MT_ABS )
; 239  :             p32->st_shndx = SHN_ABS;
; 240  :         else
; 241  :             p32->st_shndx = GetSegIdx( &curr->sym );
; 242  : #endif
; 243  :         strsize += len + 1;

	inc	edi
	add	edi, ebp

; 244  :         DebugMsg(("set_symtab32, LOCAL: symbol %s, value=%X\n", buffer, p32->st_value));
; 245  :         p32++;

	add	rbx, 16
	test	rsi, rsi
	jne	SHORT $LL7@set_symtab
$LN6@set_symtab:

; 246  :     }
; 247  : 
; 248  :     /* 4. externals + communals (+ protos [since v2.01]) */
; 249  : 
; 250  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	rsi, QWORD PTR SymTables+16
	mov	QWORD PTR [rsp+320], r14
	test	rsi, rsi
	je	SHORT $LN9@set_symtab
	mov	ebp, 65522				; 0000fff2H
	mov	r14d, 32				; 00000020H
$LL10@set_symtab:

; 251  :         /* skip "weak" (=unused) externdefs */
; 252  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE )

	movzx	eax, BYTE PTR [rsi+47]
	test	al, 4
	jne	SHORT $LN18@set_symtab
	test	al, 8
	jne	SHORT $LN8@set_symtab
$LN18@set_symtab:

; 253  :             continue;
; 254  :         len = Mangle( &curr->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rsi
	call	Mangle

; 255  : 
; 256  :         p32->st_name = strsize;

	mov	DWORD PTR [rbx], edi
	mov	edx, eax

; 257  : 
; 258  :         /* for COMMUNALs, store their size in the Value field */
; 259  :         if ( curr->sym.iscomm == TRUE ) {

	test	BYTE PTR [rsi+47], 4
	je	SHORT $LN19@set_symtab

; 260  :             p32->st_info = ELF32_ST_INFO( STB_GLOBAL, STT_COMMON );

	mov	BYTE PTR [rbx+12], 21

; 261  :             p32->st_value = curr->sym.total_size;

	mov	ecx, DWORD PTR [rsi+56]
	mov	DWORD PTR [rbx+4], ecx

; 262  :             p32->st_shndx = SHN_COMMON;

	mov	WORD PTR [rbx+14], bp

; 263  :         } else {

	jmp	SHORT $LN20@set_symtab
$LN19@set_symtab:

; 264  : #if OWELFIMPORT
; 265  :             p32->st_info = ( IsWeak( curr->sym ) ? ELF32_ST_INFO( STB_WEAK, STT_IMPORT ) : ELF32_ST_INFO( STB_GLOBAL, STT_IMPORT ) );
; 266  : #else
; 267  :             /* todo: set STT_FUNC for prototypes/code labels??? */
; 268  :             p32->st_info = ( IsWeak( curr->sym ) ? ELF32_ST_INFO( STB_WEAK, STT_NOTYPE ) : ELF32_ST_INFO( STB_GLOBAL, STT_NOTYPE ) );

	cmp	QWORD PTR [rsi+64], r12
	mov	eax, 16
	cmovne	eax, r14d
	mov	BYTE PTR [rbx+12], al

; 269  : #endif
; 270  :             p32->st_value = curr->sym.offset; /* is always 0 */

	mov	eax, DWORD PTR [rsi+16]
	mov	DWORD PTR [rbx+4], eax

; 271  :             p32->st_shndx = SHN_UNDEF;

	mov	WORD PTR [rbx+14], r12w
$LN20@set_symtab:

; 272  :         }
; 273  : 
; 274  :         strsize += len + 1;

	inc	edi
	add	edi, edx

; 275  :         DebugMsg(("set_symtab32, EXTERNAL: symbol %s, info=%X, shndx=%X, value=%X\n", buffer, p32->st_info, p32->st_shndx, p32->st_value));
; 276  :         p32++;

	add	rbx, 16
$LN8@set_symtab:

; 246  :     }
; 247  : 
; 248  :     /* 4. externals + communals (+ protos [since v2.01]) */
; 249  : 
; 250  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	rsi, QWORD PTR [rsi+104]
	test	rsi, rsi
	jne	SHORT $LL10@set_symtab
$LN9@set_symtab:

; 277  :     }
; 278  : 
; 279  : #if ELFALIAS
; 280  :     /* 5. aliases */
; 281  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {
; 282  :         len = Mangle( &curr->sym, buffer );
; 283  : 
; 284  :         p32->st_name = strsize;
; 285  : 
; 286  : #if OWELFIMPORT
; 287  :         p32->st_info = ELF32_ST_INFO( STB_WEAK, STT_IMPORT );
; 288  : #else
; 289  :         p32->st_info = ELF32_ST_INFO( STB_WEAK, STT_NOTYPE );
; 290  : #endif
; 291  :         p32->st_value = 0; /* is always 0 */
; 292  :         p32->st_shndx = SHN_UNDEF;
; 293  : 
; 294  :         strsize += len + 1;
; 295  :         DebugMsg(("set_symtab32, ALIAS: symbol %s, value=%X\n", buffer, p32->st_value));
; 296  :         p32++;
; 297  :     }
; 298  : #endif
; 299  : 
; 300  :     /* 6. PUBLIC entries */
; 301  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rsi, QWORD PTR ModuleInfo+16
	test	rsi, rsi
	je	SHORT $LN47@set_symtab
	npad	1
$LL13@set_symtab:

; 302  :         sym = q->sym;

	mov	rbp, QWORD PTR [rsi+8]

; 303  :         len = Mangle( sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbp
	call	Mangle

; 304  : 
; 305  :         curr = (struct dsym *)sym->segment;

	mov	rdx, QWORD PTR [rbp+24]
	mov	r14d, eax

; 306  :         if ( curr && curr->e.seginfo->segtype != SEGTYPE_CODE )

	test	rdx, rdx
	je	SHORT $LN21@set_symtab
	mov	rcx, QWORD PTR [rdx+96]
	cmp	DWORD PTR [rcx+72], 1

; 307  :             stt = STT_OBJECT;

	mov	cl, 1
	jne	SHORT $LN22@set_symtab
$LN21@set_symtab:

; 308  :         else
; 309  :             stt = STT_FUNC;

	mov	cl, 2
$LN22@set_symtab:

; 310  : 
; 311  :         p32->st_name = strsize;
; 312  :         p32->st_info = ELF32_ST_INFO( STB_GLOBAL, stt );

	and	cl, 15
	mov	DWORD PTR [rbx], edi
	add	cl, 16
	mov	BYTE PTR [rbx+12], cl

; 313  :         p32->st_value = sym->offset;

	mov	eax, DWORD PTR [rbp+16]
	mov	DWORD PTR [rbx+4], eax

; 314  : #if 1 /* v2.07: changed - to make MT_ABS obsolete */
; 315  :         if ( sym->state == SYM_INTERNAL )

	cmp	DWORD PTR [rbp+32], 1
	jne	SHORT $LN23@set_symtab

; 316  :             if ( curr )

	test	rdx, rdx
	je	SHORT $LN25@set_symtab

; 317  :                 p32->st_shndx = GetSegIdx( &curr->sym );

	mov	rcx, rdx
	call	GetSegIdx
	mov	WORD PTR [rbx+14], ax
	jmp	SHORT $LN24@set_symtab
$LN25@set_symtab:

; 318  :             else
; 319  :                 p32->st_shndx = SHN_ABS;

	mov	WORD PTR [rbx+14], r15w
	jmp	SHORT $LN24@set_symtab
$LN23@set_symtab:

; 320  :         else
; 321  :             p32->st_shndx = SHN_UNDEF;

	mov	WORD PTR [rbx+14], r12w
$LN24@set_symtab:

; 277  :     }
; 278  : 
; 279  : #if ELFALIAS
; 280  :     /* 5. aliases */
; 281  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {
; 282  :         len = Mangle( &curr->sym, buffer );
; 283  : 
; 284  :         p32->st_name = strsize;
; 285  : 
; 286  : #if OWELFIMPORT
; 287  :         p32->st_info = ELF32_ST_INFO( STB_WEAK, STT_IMPORT );
; 288  : #else
; 289  :         p32->st_info = ELF32_ST_INFO( STB_WEAK, STT_NOTYPE );
; 290  : #endif
; 291  :         p32->st_value = 0; /* is always 0 */
; 292  :         p32->st_shndx = SHN_UNDEF;
; 293  : 
; 294  :         strsize += len + 1;
; 295  :         DebugMsg(("set_symtab32, ALIAS: symbol %s, value=%X\n", buffer, p32->st_value));
; 296  :         p32++;
; 297  :     }
; 298  : #endif
; 299  : 
; 300  :     /* 6. PUBLIC entries */
; 301  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rsi, QWORD PTR [rsi]

; 322  : #else
; 323  :         if ( sym->mem_type == MT_ABS )
; 324  :             p32->st_shndx = SHN_ABS;
; 325  :         else if ( curr )
; 326  :             p32->st_shndx = GetSegIdx( &curr->sym );
; 327  :         else
; 328  :             p32->st_shndx = SHN_UNDEF;
; 329  : #endif
; 330  :         strsize += len + 1;

	inc	edi
	add	edi, r14d

; 331  : 
; 332  :         DebugMsg(("set_symtab32, PUBLIC+LOCAL: symbol %s, value=%X\n", buffer, p32->st_value));
; 333  : 
; 334  :         p32++;

	add	rbx, 16
	test	rsi, rsi
	jne	SHORT $LL13@set_symtab
$LN47@set_symtab:
	mov	r14, QWORD PTR [rsp+320]

; 335  :     }
; 336  : #if ADDSTARTLABEL
; 337  :     if ( ModuleInfo.g.start_label ) {
; 338  :         len = Mangle( ModuleInfo.g.start_label, buffer );
; 339  :         p32->st_name = strsize;
; 340  :         p32->st_info = ELF32_ST_INFO( STB_ENTRY, STT_FUNC );
; 341  :         p32->st_value = ModuleInfo.g.start_label->offset;
; 342  :         p32->st_shndx = GetSegIdx( ModuleInfo.g.start_label->segment );
; 343  :         strsize += len + 1;
; 344  :         DebugMsg(("set_symtab32, ENTRY: symbol %s, value=%X\n", buffer, p32->st_value));
; 345  :         p32++;
; 346  :     }
; 347  : #endif
; 348  :     return( strsize );
; 349  : }

	lea	r11, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [r11+40]
	mov	eax, edi
	mov	rbp, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r15
	pop	r12
	pop	rdi
	ret	0
set_symtab32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
;	COMDAT get_num_reloc_sections
_TEXT	SEGMENT
get_num_reloc_sections PROC				; COMDAT

; 170  :     struct dsym    *curr;
; 171  :     int num = 0;
; 172  : 
; 173  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rcx, QWORD PTR SymTables+32
	xor	eax, eax
	test	rcx, rcx
	je	SHORT $LN11@get_num_re
	npad	2
$LL4@get_num_re:

; 174  :         if ( curr->e.seginfo->FixupList.head )

	mov	rdx, QWORD PTR [rcx+96]
	cmp	QWORD PTR [rdx+40], 0
	je	SHORT $LN2@get_num_re

; 175  :             num++;

	inc	eax
$LN2@get_num_re:

; 170  :     struct dsym    *curr;
; 171  :     int num = 0;
; 172  : 
; 173  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL4@get_num_re
$LN11@get_num_re:

; 176  :     }
; 177  :     return( num );
; 178  : }

	ret	0
get_num_reloc_sections ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
;	COMDAT ElfConvertSectionName
_TEXT	SEGMENT
sym$ = 64
buffer$ = 72
ElfConvertSectionName PROC				; COMDAT

; 148  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 152  :         if ( memcmp( sym->name, cst[i].src, cst[i].len ) == 0 ) {

	mov	rbp, QWORD PTR [rcx+8]
	lea	rbx, OFFSET FLAT:cst+8
	mov	r14, rdx
	mov	r15, rcx
	xor	edi, edi
	npad	5
$LL4@ElfConvert:
	movzx	esi, BYTE PTR [rbx-8]
	mov	rcx, rbp
	mov	rdx, QWORD PTR [rbx]
	mov	r8d, esi
	call	memcmp
	test	eax, eax
	jne	SHORT $LN2@ElfConvert

; 153  :             if ( sym->name[cst[i].len] == NULLC )

	movzx	eax, BYTE PTR [rsi+rbp]
	test	al, al
	je	$LN13@ElfConvert

; 155  :             else if ( ( cst[i].flags & CSF_GRPCHK )  && sym->name[cst[i].len] == '$' ) {

	test	BYTE PTR [rbx-7], 1
	je	SHORT $LN2@ElfConvert
	cmp	al, 36					; 00000024H
	je	SHORT $LN14@ElfConvert
$LN2@ElfConvert:

; 149  :     int i;
; 150  : 
; 151  :     for ( i = 0; i < sizeof( cst ) / sizeof( cst[0] ); i++ ) {

	inc	edi
	add	rbx, 24
	movsxd	rax, edi
	cmp	rax, 4
	jb	SHORT $LL4@ElfConvert

; 159  :             }
; 160  :         }
; 161  :     }
; 162  :     return( sym->name );

	mov	rax, rbp
$LN1@ElfConvert:

; 163  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN14@ElfConvert:

; 156  :                 strcpy( buffer, cst[i].dst );

	movsxd	rax, edi
	lea	r8, OFFSET FLAT:cst
	mov	rdx, r14
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	r9, QWORD PTR [rcx*8]
	mov	rcx, QWORD PTR [r9+r8+16]
	npad	11
$LL10@ElfConvert:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL10@ElfConvert

; 157  :                 strcat( buffer, sym->name+cst[i].len );

	movzx	r8d, BYTE PTR [r9+r8]
	lea	rcx, QWORD PTR [r14-1]
	add	r8, QWORD PTR [r15+8]
	npad	2
$LL21@ElfConvert:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL21@ElfConvert
	xor	edx, edx
	npad	4
$LL22@ElfConvert:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL22@ElfConvert

; 158  :                 return( buffer );

	mov	rax, r14
	jmp	$LN1@ElfConvert
$LN13@ElfConvert:

; 154  :                 return( (char *)cst[i].dst );

	movsxd	rax, edi
	lea	r8, OFFSET FLAT:cst
	lea	rax, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [r8+rax*8+16]
	jmp	$LN1@ElfConvert
ElfConvertSectionName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
modinfo$ = 8
elf_init PROC

; 1379 :     modinfo->elf_osabi = ELFOSABI_LINUX;
; 1380 :     modinfo->g.WriteModule = elf_write_module;

	lea	rax, OFFSET FLAT:elf_write_module
	mov	BYTE PTR [rcx+412], 3
	mov	QWORD PTR [rcx+288], rax

; 1381 : #if 0
; 1382 :     printf("size Elf_Ehdr: %2u - %2u\n", sizeof(Elf32_Ehdr), sizeof(Elf64_Ehdr));
; 1383 :     printf("size Elf_Shdr: %2u - %2u\n", sizeof(Elf32_Shdr), sizeof(Elf64_Shdr));
; 1384 :     printf("size Elf_Sym : %2u - %2u\n", sizeof(Elf32_Sym ), sizeof(Elf64_Sym ));
; 1385 :     printf("size Elf_Rel : %2u - %2u\n", sizeof(Elf32_Rel ), sizeof(Elf64_Rel ));
; 1386 :     printf("size Elf_Rela: %2u - %2u\n", sizeof(Elf32_Rela), sizeof(Elf64_Rela));
; 1387 : #endif
; 1388 :     return;
; 1389 : }

	ret	0
elf_init ENDP
_TEXT	ENDS
END
