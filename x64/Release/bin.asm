; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
CONST	SEGMENT
mzdata	DW	01eH
	DW	010H
	DW	00H
	DW	0ffffH
szCaption DB	'Binary Map:', 00H
edataname DB	'.edata', 00H
	ORG $+5
szCaption2 DB	'Segment                  Pos(file)     RVA  Size(fil) Si'
	DB	'ze(mem)', 00H
szSep	DB	'--------------------------------------------------------'
	DB	'-------', 00H
szHeader DB	'<header>', 00H
	ORG $+7
szSegLine DB	'%-24s %8X %8X %9X %9X', 00H
	ORG $+2
szTotal	DB	'%-42s %9X %9X', 00H
	ORG $+2
hdrattr	DB	'read public ''HDR''', 00H
	ORG $+6
edataattr DB	'FLAT read public alias(''.rdata'') ''DATA''', 00H
idataname DB	'.idata$', 00H
idataattr DB	'FLAT read public alias(''.rdata'') ''DATA''', 00H
	ORG $+8
mzcode	DB	'db ''MZ''', 00H, 'dw 80h, 1, 0, 4', 00H, 'dw 0, -1, 0, 0'
	DB	'B8h', 00H, 'dw 0, 0, 0, 40h', 00H, 'org 40h', 00H, 'push cs', 00H
	DB	'pop ds', 00H, 'mov dx,@F - 40h', 00H, 'mov ah,9', 00H, 'int 2'
	DB	'1h', 00H, 'mov ax,4C01h', 00H, 'int 21h', 00H, '@@:', 00H, 'd'
	DB	'b ''This is a PE executable'',0Dh,0Ah,''$''', 00H
	ORG $+12
pe32def	DD	04550H
	DW	014cH
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DW	0e0H
	DW	010fH
	DW	010bH
	DB	05H
	DB	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0400000H
	DD	01000H
	DD	0200H
	DW	04H
	DW	00H
	DW	00H
	DW	00H
	DW	04H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	03H
	DW	00H
	DD	0100000H
	DD	01000H
	DD	0100000H
	DD	01000H
	DD	00H
	DD	010H
	ORG $+128
	ORG $+8
pe64def	DD	04550H
	DW	08664H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DW	0f0H
	DW	012fH
	DW	020bH
	DB	05H
	DB	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DQ	0000000000400000H
	DD	01000H
	DD	0200H
	DW	04H
	DW	00H
	DW	00H
	DW	00H
	DW	04H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	03H
	DW	00H
	DQ	0000000000100000H
	DQ	0000000000001000H
	DQ	0000000000100000H
	DQ	0000000000001000H
	DD	00H
	DD	010H
	ORG $+128
CONST	ENDS
_DATA	SEGMENT
$SG12381 DB	' ', 00H
	ORG $+2
$SG11862 DB	'.hdr$1', 00H
	ORG $+1
$SG11909 DB	'HDR', 00H
$SG11864 DB	'%r DOTNAME', 00H
	ORG $+1
$SG11865 DB	'.hdr$', 00H
	ORG $+2
$SG11868 DB	'%s1 %r', 00H
	ORG $+1
$SG11938 DB	'HDR', 00H
$SG11866 DB	'%s1 %r USE16 %r %s', 00H
	ORG $+1
$SG11867 DB	'.hdr$', 00H
	ORG $+2
$SG11870 DB	'.hdr$1', 00H
	ORG $+1
$SG11881 DB	'.hdr$2', 00H
	ORG $+1
$SG11906 DB	'.hdr$2', 00H
	ORG $+1
$SG11910 DB	'.hdr$2', 00H
	ORG $+5
$SG11912 DB	'@pe_file_flags', 00H
	ORG $+1
$SG11936 DB	'.hdr$3', 00H
	ORG $+1
$SG11939 DB	'.hdr$3', 00H
	ORG $+1
$SG11947 DB	'CONST', 00H
	ORG $+2
$SG11951 DB	'.rsrc', 00H
	ORG $+2
$SG11954 DB	'.reloc', 00H
	ORG $+1
$SG12007 DB	'%r DOTNAME', 00H
	ORG $+5
$SG12008 DB	'%s %r %r %s', 00H
$SG12017 DB	'DW %u', 00H
	ORG $+6
$SG12009 DB	'DD 0, 0%xh, 0, %r @%s_name, %u, %u, %u, %r @%s_func, %r '
	DB	'@%s_names, %r @%s_nameord', 00H
	ORG $+6
$SG12011 DB	'@%s_func %r DWORD', 00H
	ORG $+6
$SG12013 DB	'DD %r %s', 00H
	ORG $+7
$SG12014 DB	'@%s_names %r DWORD', 00H
	ORG $+5
$SG12015 DB	'DD %r @%s', 00H
	ORG $+6
$SG12016 DB	'@%s_nameord %r WORD', 00H
	ORG $+4
$SG12020 DB	'@%s_name DB ''%s'',0', 00H
	ORG $+5
$SG12022 DB	'@%s DB ''%s'',0', 00H
	ORG $+2
$SG12023 DB	'%s %r', 00H
	ORG $+2
$SG12048 DB	'ALIGN(8)', 00H
	ORG $+7
$SG12049 DB	'ALIGN(4)', 00H
	ORG $+7
$SG12052 DB	'@LPPROC %r %r %r', 00H
	ORG $+7
$SG12053 DB	'%r DOTNAME', 00H
	ORG $+5
$SG12055 DB	'%s2 %r %r %s', 00H
	ORG $+3
$SG12056 DB	'DD %r @%s_ilt, 0, 0, %r @%s_name, %r @%s_iat', 00H
	ORG $+3
$SG12057 DB	'%s2 %r', 00H
	ORG $+1
$SG12058 DB	'%s4 %r %s %s', 00H
	ORG $+3
$SG12059 DB	'@%s_ilt label %r', 00H
	ORG $+7
$SG12061 DB	'@LPPROC %r @%s_name', 00H
	ORG $+4
$SG12062 DB	'@LPPROC 0', 00H
	ORG $+2
$SG12063 DB	'%s4 %r', 00H
	ORG $+5
$SG12064 DB	'%s5 %r %s %s', 00H
	ORG $+3
$SG12065 DB	'@%s_iat label %r', 00H
	ORG $+7
$SG12067 DB	'%s%s @LPPROC %r @%s_name', 00H
	ORG $+7
$SG12068 DB	'@LPPROC 0', 00H
	ORG $+2
$SG12069 DB	'%s5 %r', 00H
	ORG $+5
$SG12070 DB	'%s6 %r %r %s', 00H
	ORG $+3
$SG12072 DB	'@%s_name dw 0', 00H
	ORG $+2
$SG12073 DB	'db ''%s'',0', 00H
	ORG $+2
$SG12074 DB	'even', 00H
	ORG $+7
$SG12077 DB	'@%s_%s_name db ''%s.%s'',0', 00H
	ORG $+7
$SG12078 DB	'@%s_name db ''%s'',0', 00H
	ORG $+1
$SG12079 DB	'even', 00H
	ORG $+3
$SG12080 DB	'%s6 %r', 00H
	ORG $+5
$SG12082 DB	'%s3 %r %r %s', 00H
	ORG $+3
$SG12083 DB	'DD 0, 0, 0, 0, 0', 00H
	ORG $+3
$SG12084 DB	'%s3 %r', 00H
	ORG $+1
$SG12108 DB	'CONST', 00H
	ORG $+2
$SG12231 DB	'.hdr$1', 00H
	ORG $+1
$SG12232 DB	'.hdr$2', 00H
	ORG $+1
$SG12233 DB	'.hdr$3', 00H
	ORG $+1
$SG12237 DB	'RELOC', 00H
	ORG $+2
$SG12238 DB	'.reloc', 00H
	ORG $+5
$SG12267 DB	'.idata$2', 00H
	ORG $+7
$SG12268 DB	'.idata$3', 00H
	ORG $+7
$SG12269 DB	'.idata$5', 00H
	ORG $+3
$SG12271 DB	'.rsrc', 00H
	ORG $+2
$SG12273 DB	'.reloc', 00H
	ORG $+1
$SG12275 DB	'.tls', 00H
	ORG $+3
$SG12279 DB	'.pdata', 00H
_DATA	ENDS
PUBLIC	bin_init
PUBLIC	pe_create_PE_header
EXTRN	_time64:PROC
EXTRN	fseek:PROC
EXTRN	ftell:PROC
EXTRN	fwrite:PROC
EXTRN	qsort:PROC
EXTRN	strchr:PROC
EXTRN	strncpy:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	WriteError:PROC
EXTRN	ConvertSectionName:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymFind:PROC
EXTRN	LstPrintf:PROC
EXTRN	LstNL:PROC
EXTRN	AddLineQueue:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	RunLineQueue:PROC
EXTRN	Mangle:PROC
EXTRN	CreateIntSegment:PROC
EXTRN	CreateVariable:PROC
EXTRN	SortSegments:PROC
EXTRN	__chkstk:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SymTables:BYTE
EXTRN	__ImageBase:BYTE
pdata	SEGMENT
$pdata$pe_create_PE_header DD imagerel $LN14
	DD	imagerel $LN14+24
	DD	imagerel $unwind$pe_create_PE_header
$pdata$2$pe_create_PE_header DD imagerel $LN14+24
	DD	imagerel $LN14+329
	DD	imagerel $chain$2$pe_create_PE_header
$pdata$3$pe_create_PE_header DD imagerel $LN14+329
	DD	imagerel $LN14+349
	DD	imagerel $chain$3$pe_create_PE_header
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CalcOffset DD imagerel CalcOffset
	DD	imagerel CalcOffset+66
	DD	imagerel $unwind$CalcOffset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$CalcOffset DD imagerel CalcOffset+66
	DD	imagerel CalcOffset+355
	DD	imagerel $chain$1$CalcOffset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$CalcOffset DD imagerel CalcOffset+355
	DD	imagerel CalcOffset+366
	DD	imagerel $chain$2$CalcOffset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetSegRelocs DD imagerel GetSegRelocs
	DD	imagerel GetSegRelocs+269
	DD	imagerel $unwind$GetSegRelocs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetImageSize DD imagerel GetImageSize
	DD	imagerel GetImageSize+163
	DD	imagerel $unwind$GetImageSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DoFixup DD imagerel DoFixup
	DD	imagerel DoFixup+47
	DD	imagerel $unwind$DoFixup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$DoFixup DD imagerel DoFixup+47
	DD	imagerel DoFixup+1115
	DD	imagerel $chain$5$DoFixup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$DoFixup DD imagerel DoFixup+1115
	DD	imagerel DoFixup+1180
	DD	imagerel $chain$6$DoFixup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pe_create_MZ_header DD imagerel pe_create_MZ_header
	DD	imagerel pe_create_MZ_header+60
	DD	imagerel $unwind$pe_create_MZ_header
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pe_create_MZ_header DD imagerel pe_create_MZ_header+60
	DD	imagerel pe_create_MZ_header+218
	DD	imagerel $chain$0$pe_create_MZ_header
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$pe_create_MZ_header DD imagerel pe_create_MZ_header+218
	DD	imagerel pe_create_MZ_header+241
	DD	imagerel $chain$1$pe_create_MZ_header
pdata	ENDS
pdata	SEGMENT
$pdata$set_file_flags DD imagerel set_file_flags
	DD	imagerel set_file_flags+73
	DD	imagerel $unwind$set_file_flags
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pe_create_section_table DD imagerel pe_create_section_table
	DD	imagerel pe_create_section_table+26
	DD	imagerel $unwind$pe_create_section_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$pe_create_section_table DD imagerel pe_create_section_table+26
	DD	imagerel pe_create_section_table+502
	DD	imagerel $chain$1$pe_create_section_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pe_create_section_table DD imagerel pe_create_section_table+502
	DD	imagerel pe_create_section_table+513
	DD	imagerel $chain$2$pe_create_section_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pe_emit_export_data DD imagerel pe_emit_export_data
	DD	imagerel pe_emit_export_data+795
	DD	imagerel $unwind$pe_emit_export_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pe_emit_import_data DD imagerel pe_emit_import_data
	DD	imagerel pe_emit_import_data+9
	DD	imagerel $unwind$pe_emit_import_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$pe_emit_import_data DD imagerel pe_emit_import_data+9
	DD	imagerel pe_emit_import_data+90
	DD	imagerel $chain$3$pe_emit_import_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$pe_emit_import_data DD imagerel pe_emit_import_data+90
	DD	imagerel pe_emit_import_data+852
	DD	imagerel $chain$6$pe_emit_import_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$pe_emit_import_data DD imagerel pe_emit_import_data+852
	DD	imagerel pe_emit_import_data+882
	DD	imagerel $chain$7$pe_emit_import_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$pe_emit_import_data DD imagerel pe_emit_import_data+882
	DD	imagerel pe_emit_import_data+973
	DD	imagerel $chain$8$pe_emit_import_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pe_set_base_relocs DD imagerel pe_set_base_relocs
	DD	imagerel pe_set_base_relocs+395
	DD	imagerel $unwind$pe_set_base_relocs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pe_set_values DD imagerel pe_set_values
	DD	imagerel pe_set_values+16
	DD	imagerel $unwind$pe_set_values
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$pe_set_values DD imagerel pe_set_values+16
	DD	imagerel pe_set_values+34
	DD	imagerel $chain$1$pe_set_values
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pe_set_values DD imagerel pe_set_values+34
	DD	imagerel pe_set_values+76
	DD	imagerel $chain$2$pe_set_values
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$pe_set_values DD imagerel pe_set_values+76
	DD	imagerel pe_set_values+1100
	DD	imagerel $chain$3$pe_set_values
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$pe_set_values DD imagerel pe_set_values+1100
	DD	imagerel pe_set_values+1292
	DD	imagerel $chain$4$pe_set_values
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$pe_set_values DD imagerel pe_set_values+1292
	DD	imagerel pe_set_values+1431
	DD	imagerel $chain$5$pe_set_values
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$pe_set_values DD imagerel pe_set_values+1431
	DD	imagerel pe_set_values+1628
	DD	imagerel $chain$6$pe_set_values
pdata	ENDS
pdata	SEGMENT
$pdata$pe_enddirhook DD imagerel pe_enddirhook
	DD	imagerel pe_enddirhook+44
	DD	imagerel $unwind$pe_enddirhook
$pdata$bin_write_module DD imagerel bin_write_module
	DD	imagerel bin_write_module+2142
	DD	imagerel $unwind$bin_write_module
pdata	ENDS
CONST	SEGMENT
dosseg_order DD	01H
	DD	00H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
flat_order DD	06H
	DD	01H
	DD	07H
	DD	02H
	DD	03H
	DD	09H
	DD	08H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$pe_set_values DD 021H
	DD	imagerel pe_set_values
	DD	imagerel pe_set_values+16
	DD	imagerel $unwind$pe_set_values
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$pe_set_values DD 021H
	DD	imagerel pe_set_values+16
	DD	imagerel pe_set_values+34
	DD	imagerel $chain$1$pe_set_values
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$pe_set_values DD 021H
	DD	imagerel pe_set_values+34
	DD	imagerel pe_set_values+76
	DD	imagerel $chain$2$pe_set_values
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$pe_set_values DD 020421H
	DD	02de404H
	DD	imagerel pe_set_values+34
	DD	imagerel pe_set_values+76
	DD	imagerel $chain$2$pe_set_values
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pe_set_values DD 020421H
	DD	02ec404H
	DD	imagerel pe_set_values+16
	DD	imagerel pe_set_values+34
	DD	imagerel $chain$1$pe_set_values
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$pe_set_values DD 040b21H
	DD	02f640bH
	DD	0303404H
	DD	imagerel pe_set_values
	DD	imagerel pe_set_values+16
	DD	imagerel $unwind$pe_set_values
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pe_set_values DD 061001H
	DD	0310110H
	DD	0d007f009H
	DD	050047005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pe_set_base_relocs DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$pe_emit_import_data DD 021H
	DD	imagerel pe_emit_import_data
	DD	imagerel pe_emit_import_data+9
	DD	imagerel $unwind$pe_emit_import_data
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$pe_emit_import_data DD 021H
	DD	imagerel pe_emit_import_data+9
	DD	imagerel pe_emit_import_data+90
	DD	imagerel $chain$3$pe_emit_import_data
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$pe_emit_import_data DD 060c21H
	DD	09e40cH
	DD	0106408H
	DD	0e3404H
	DD	imagerel pe_emit_import_data+9
	DD	imagerel pe_emit_import_data+90
	DD	imagerel $chain$3$pe_emit_import_data
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$pe_emit_import_data DD 083321H
	DD	08f433H
	DD	0ac428H
	DD	0b740fH
	DD	0f5404H
	DD	imagerel pe_emit_import_data
	DD	imagerel pe_emit_import_data+9
	DD	imagerel $unwind$pe_emit_import_data
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pe_emit_import_data DD 020901H
	DD	0d005b209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pe_emit_export_data DD 0750b2401H
	DD	0157424H
	DD	0146420H
	DD	013341aH
	DD	0d20a730fH
	DD	0e004f006H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pe_create_section_table DD 021H
	DD	imagerel pe_create_section_table
	DD	imagerel pe_create_section_table+26
	DD	imagerel $unwind$pe_create_section_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$pe_create_section_table DD 041121H
	DD	096411H
	DD	085405H
	DD	imagerel pe_create_section_table
	DD	imagerel pe_create_section_table+26
	DD	imagerel $unwind$pe_create_section_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pe_create_section_table DD 040a01H
	DD	0a340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$pe_create_MZ_header DD 021H
	DD	imagerel pe_create_MZ_header
	DD	imagerel pe_create_MZ_header+60
	DD	imagerel $unwind$pe_create_MZ_header
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pe_create_MZ_header DD 020521H
	DD	087405H
	DD	imagerel pe_create_MZ_header
	DD	imagerel pe_create_MZ_header+60
	DD	imagerel $unwind$pe_create_MZ_header
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pe_create_MZ_header DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$DoFixup DD 021H
	DD	imagerel DoFixup
	DD	imagerel DoFixup+47
	DD	imagerel $unwind$DoFixup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$DoFixup DD 0c1f21H
	DD	08c41fH
	DD	09741bH
	DD	06f417H
	DD	07e413H
	DD	0a640fH
	DD	0103404H
	DD	imagerel DoFixup
	DD	imagerel DoFixup+47
	DD	imagerel $unwind$DoFixup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DoFixup DD 030e01H
	DD	0d00aa20eH
	DD	05008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetImageSize DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetSegRelocs DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$CalcOffset DD 021H
	DD	imagerel CalcOffset
	DD	imagerel CalcOffset+66
	DD	imagerel $unwind$CalcOffset
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$CalcOffset DD 041121H
	DD	076411H
	DD	065405H
	DD	imagerel CalcOffset
	DD	imagerel CalcOffset+66
	DD	imagerel $unwind$CalcOffset
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CalcOffset DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
xdata	SEGMENT
$unwind$pe_create_PE_header DD 010401H
	DD	06204H
$chain$2$pe_create_PE_header DD 060f21H
	DD	06740fH
	DD	09640aH
	DD	083405H
	DD	imagerel $LN14
	DD	imagerel $LN14+24
	DD	imagerel $unwind$pe_create_PE_header
$chain$3$pe_create_PE_header DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+24
	DD	imagerel $unwind$pe_create_PE_header
$unwind$set_file_flags DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$pe_enddirhook DD 020601H
	DD	030023206H
$unwind$bin_write_module DD 0350b2b01H
	DD	016342bH
	DD	0b2143319H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
modinfo$ = 8
bin_check_external PROC

; 1821 :     struct dsym *curr;
; 1822 :     for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next )

	mov	rdx, QWORD PTR SymTables+16
	test	rdx, rdx
	je	SHORT $LN3@bin_check_
	npad	4
$LL4@bin_check_:

; 1823 :         if( curr->sym.weak == FALSE || curr->sym.used == TRUE ) {

	test	BYTE PTR [rdx+47], 8
	je	SHORT $LN9@bin_check_
	test	BYTE PTR [rdx+40], 1
	jne	SHORT $LN9@bin_check_

; 1821 :     struct dsym *curr;
; 1822 :     for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next )

	mov	rdx, QWORD PTR [rdx+104]
	test	rdx, rdx
	jne	SHORT $LL4@bin_check_
$LN3@bin_check_:

; 1826 :         }
; 1827 :     return( NOT_ERROR );

	xor	eax, eax

; 1828 : }

	ret	0
$LN9@bin_check_:

; 1824 :             DebugMsg(("CheckExternal: error, %s weak=%u\n", curr->sym.name, curr->sym.weak ));
; 1825 :             return( EmitErr( FORMAT_DOESNT_SUPPORT_EXTERNALS, curr->sym.name ) );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 201				; 000000c9H
	jmp	EmitErr
bin_check_external ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
cp$ = 0
sizeheap$ = 112
hdrbuf$ = 112
reloccnt$ = 112
modinfo$ = 112
bin_write_module PROC

; 1513 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+48]

; 1514 :     struct dsym *curr;
; 1515 :     uint_32 size;
; 1516 :     uint_32 sizetotal;
; 1517 :     //const enum seg_type *segtype;
; 1518 :     int i;
; 1519 :     int first;
; 1520 :     uint_32 sizeheap;
; 1521 : #if MZ_SUPPORT
; 1522 :     struct IMAGE_DOS_HEADER *pMZ;
; 1523 :     uint_16 reloccnt;
; 1524 :     uint_32 sizemem;
; 1525 :     struct dsym *stack = NULL;
; 1526 :     uint_8  *hdrbuf;
; 1527 : #endif
; 1528 :     struct calc_param cp = { TRUE, 0 };
; 1529 : 
; 1530 :     DebugMsg(("bin_write_module: enter\n" ));
; 1531 : 
; 1532 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdx, QWORD PTR SymTables+32
	xor	eax, eax
	xor	edi, edi
	mov	QWORD PTR [rbp+128], rbx
	mov	WORD PTR cp$[rbp], 1
	mov	r15, rcx
	mov	QWORD PTR cp$[rbp+4], rax
	mov	esi, edi
	mov	QWORD PTR cp$[rbp+12], rax
	mov	QWORD PTR cp$[rbp+20], rax
	mov	QWORD PTR cp$[rbp+28], rax
	mov	QWORD PTR cp$[rbp+36], rax
	mov	DWORD PTR cp$[rbp+44], eax
	test	rdx, rdx
	je	SHORT $LN3@bin_write_
	npad	14
$LL4@bin_write_:

; 1533 :         /* reset the offset fields of segments */
; 1534 :         /* it was used to store the size in there */
; 1535 :         curr->e.seginfo->start_offset = 0;

	mov	rax, QWORD PTR [rdx+96]
	mov	DWORD PTR [rax+12], edi

; 1536 :         /* set STACK segment type */
; 1537 :         if ( curr->e.seginfo->combine == COMB_STACK )

	mov	rcx, QWORD PTR [rdx+96]
	movzx	eax, BYTE PTR [rcx+108]
	and	al, 7
	cmp	al, 5
	jne	SHORT $LN2@bin_write_

; 1538 :             curr->e.seginfo->segtype = SEGTYPE_STACK;

	mov	DWORD PTR [rcx+72], 4
$LN2@bin_write_:

; 1514 :     struct dsym *curr;
; 1515 :     uint_32 size;
; 1516 :     uint_32 sizetotal;
; 1517 :     //const enum seg_type *segtype;
; 1518 :     int i;
; 1519 :     int first;
; 1520 :     uint_32 sizeheap;
; 1521 : #if MZ_SUPPORT
; 1522 :     struct IMAGE_DOS_HEADER *pMZ;
; 1523 :     uint_16 reloccnt;
; 1524 :     uint_32 sizemem;
; 1525 :     struct dsym *stack = NULL;
; 1526 :     uint_8  *hdrbuf;
; 1527 : #endif
; 1528 :     struct calc_param cp = { TRUE, 0 };
; 1529 : 
; 1530 :     DebugMsg(("bin_write_module: enter\n" ));
; 1531 : 
; 1532 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdx, QWORD PTR [rdx+104]
	test	rdx, rdx
	jne	SHORT $LL4@bin_write_
$LN3@bin_write_:

; 1539 :     }
; 1540 : 
; 1541 :     /* calculate size of header */
; 1542 :     switch( modinfo->sub_format ) {

	cmp	DWORD PTR [r15+372], 1
	je	SHORT $LN28@bin_write_

; 1547 :         DebugMsg(("bin_write_module: MZ format, fixups=%u, sizehdr=%" I32_SPEC "X\n", reloccnt, cp.sizehdr ));
; 1548 :         break;
; 1549 : #endif
; 1550 :     default:
; 1551 :         cp.sizehdr = 0;

	movzx	r13d, WORD PTR reloccnt$[rbp]
	mov	r12d, edi
	mov	DWORD PTR cp$[rbp+8], edi
	jmp	$LN5@bin_write_
$LN28@bin_write_:

; 1543 : #if MZ_SUPPORT
; 1544 :     case SFORMAT_MZ:
; 1545 :         reloccnt = GetSegRelocs( NULL );

	mov	rbx, QWORD PTR SymTables+32
	mov	r9, rdi
	mov	r13d, edi
	test	rbx, rbx
	je	$LN79@bin_write_
	npad	11
$LL80@bin_write_:
	mov	r10, QWORD PTR [rbx+96]
	cmp	DWORD PTR [r10+72], 5
	je	$LN78@bin_write_
	mov	r10, QWORD PTR [r10+40]
	test	r10, r10
	je	$LN78@bin_write_
	npad	4
$LL83@bin_write_:
	mov	r11d, DWORD PTR [r10+24]
	lea	eax, DWORD PTR [r11-8]
	cmp	eax, 2
	ja	$LN81@bin_write_
	mov	rax, QWORD PTR [r10+56]
	test	rax, rax
	je	SHORT $LN90@bin_write_
	mov	rax, QWORD PTR [rax+24]
	test	rax, rax
	je	SHORT $LN90@bin_write_
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 5
	je	$LN81@bin_write_
$LN90@bin_write_:
	inc	r13d
	test	r9, r9
	je	$LN81@bin_write_
	mov	rcx, QWORD PTR [rbx+96]
	mov	r8d, DWORD PTR [rcx+12]
	mov	eax, r8d
	mov	rdx, QWORD PTR [rcx]
	and	eax, 15
	add	eax, DWORD PTR [r10+20]
	shr	r8d, 4
	test	rdx, rdx
	je	SHORT $LN92@bin_write_
	mov	edx, DWORD PTR [rdx+16]
	mov	ecx, edx
	and	ecx, 15
	sar	edx, 4
	add	eax, ecx
	add	r8w, dx
$LN92@bin_write_:
	cmp	r11d, 9
	jne	SHORT $LN93@bin_write_
	add	eax, 2
	jmp	SHORT $LN151@bin_write_
$LN93@bin_write_:
	cmp	r11d, 10
	jne	SHORT $LN151@bin_write_
	add	eax, 4
$LN151@bin_write_:
	cmp	eax, 65536				; 00010000H
	jb	SHORT $LN87@bin_write_
	lea	edx, DWORD PTR [rax-65520]
	shr	rdx, 4
	add	r8w, dx
$LL86@bin_write_:
	add	eax, -16				; fffffff0H
	sub	rdx, 1
	jne	SHORT $LL86@bin_write_
$LN87@bin_write_:
	mov	WORD PTR [r9], ax
	mov	WORD PTR [r9+2], r8w
	add	r9, 4
$LN81@bin_write_:
	mov	r10, QWORD PTR [r10+8]
	test	r10, r10
	jne	$LL83@bin_write_
$LN78@bin_write_:
	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	$LL80@bin_write_
$LN79@bin_write_:

; 1546 :         cp.sizehdr = (reloccnt * 4 + modinfo->mz_data.ofs_fixups + (modinfo->mz_data.alignment - 1)) & ~(modinfo->mz_data.alignment-1);

	movzx	r8d, WORD PTR [r15+414]
	movzx	r12d, WORD PTR [r15+412]
	dec	r12d
	movzx	edx, r13w
	add	r12d, r8d
	lea	eax, DWORD PTR [r8-1]
	not	eax
	lea	r12d, DWORD PTR [r12+rdx*4]
	and	r12d, eax
	mov	DWORD PTR cp$[rbp+8], r12d
$LN5@bin_write_:

; 1552 :     }
; 1553 :     cp.fileoffset = cp.sizehdr;

	mov	DWORD PTR cp$[rbp+4], r12d

; 1554 : 
; 1555 :     if ( cp.sizehdr ) {

	test	r12d, r12d
	je	SHORT $LN224@bin_write_

; 1556 :         hdrbuf = LclAlloc( cp.sizehdr );

	mov	ecx, r12d
	call	LclAlloc

; 1557 :         memset( hdrbuf, 0, cp.sizehdr );

	mov	r8d, r12d
	xor	edx, edx
	mov	rcx, rax
	mov	r14, rax
	call	memset
	jmp	SHORT $LN30@bin_write_
$LN224@bin_write_:
	mov	r14, QWORD PTR hdrbuf$[rbp]
$LN30@bin_write_:

; 1558 :     }
; 1559 :     cp.entryoffset = -1;
; 1560 : 
; 1561 :     /* set starting offsets for all sections */
; 1562 : 
; 1563 : #if PE_SUPPORT
; 1564 :     cp.rva = 0;
; 1565 :     if ( modinfo->sub_format == SFORMAT_PE ) {

	cmp	DWORD PTR [r15+372], 2
	mov	DWORD PTR cp$[rbp+12], -1		; ffffffffH
	mov	DWORD PTR cp$[rbp+28], edi
	jne	SHORT $LN31@bin_write_

; 1566 :         if ( ModuleInfo.model == MODEL_NONE ) {

	cmp	DWORD PTR ModuleInfo+360, esi
	jne	SHORT $LN33@bin_write_

; 1567 :             return( EmitErr( MODEL_IS_NOT_DECLARED ) );

	mov	ecx, 96					; 00000060H
	call	EmitErr
	jmp	$LN1@bin_write_
$LN33@bin_write_:

; 1568 :         }
; 1569 :         pe_set_values( &cp );

	lea	rcx, QWORD PTR cp$[rbp]
	call	pe_set_values

; 1570 :     } else

	jmp	$LN227@bin_write_
$LN31@bin_write_:

; 1571 : #endif
; 1572 :     if ( modinfo->segorder == SEGORDER_DOSSEG ) {

	mov	eax, DWORD PTR [r15+380]
	cmp	eax, 1
	jne	SHORT $LN34@bin_write_

; 1573 :         DebugMsg(("bin_write_module: .DOSSEG active\n" ));
; 1574 :         /* for .DOSSEG, regroup segments (CODE, UNDEF, DATA, BSS) */
; 1575 :         for ( i = 0 ; i < SIZE_DOSSEG; i++ ) {

	lea	rdi, OFFSET FLAT:dosseg_order
$LL9@bin_write_:

; 1576 :             DebugMsg(("bin_write_module: searching segment types %Xh\n", dosseg_order[i] ));
; 1577 :             for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	test	rbx, rbx
	je	SHORT $LN7@bin_write_
	npad	1
$LL12@bin_write_:

; 1578 :                 if ( curr->e.seginfo->segtype != dosseg_order[i] )

	mov	rcx, QWORD PTR [rbx+96]
	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [rcx+72], eax
	jne	SHORT $LN10@bin_write_

; 1579 :                     continue;
; 1580 :                 CalcOffset( curr, &cp );

	lea	rdx, QWORD PTR cp$[rbp]
	mov	rcx, rbx
	call	CalcOffset
$LN10@bin_write_:

; 1576 :             DebugMsg(("bin_write_module: searching segment types %Xh\n", dosseg_order[i] ));
; 1577 :             for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	SHORT $LL12@bin_write_
$LN7@bin_write_:

; 1573 :         DebugMsg(("bin_write_module: .DOSSEG active\n" ));
; 1574 :         /* for .DOSSEG, regroup segments (CODE, UNDEF, DATA, BSS) */
; 1575 :         for ( i = 0 ; i < SIZE_DOSSEG; i++ ) {

	inc	esi
	add	rdi, 4
	movsxd	rax, esi
	cmp	rax, 6
	jb	SHORT $LL9@bin_write_

; 1581 :                 DebugMsg(("bin_write_module: section %s, start ofs=%" I32_SPEC "Xh, size=%" I32_SPEC "Xh, file ofs=%" I32_SPEC "Xh\n",
; 1582 :                           curr->sym.name, curr->e.seginfo->start_offset, curr->sym.max_offset - curr->e.seginfo->start_loc, curr->e.seginfo->fileoffset ));
; 1583 :             }
; 1584 :         }
; 1585 :         SortSegments( 0 );

	xor	ecx, ecx
	call	SortSegments

; 1586 :     } else { /* segment order .SEQ (default) and .ALPHA */

	xor	edi, edi
	mov	esi, edi
	jmp	SHORT $LN227@bin_write_
$LN34@bin_write_:

; 1587 :         
; 1588 :         if ( modinfo->segorder == SEGORDER_ALPHA ) {

	cmp	eax, 2
	jne	SHORT $LN37@bin_write_

; 1589 :             DebugMsg(("bin_write_module: .ALPHA active\n" ));
; 1590 :             SortSegments( 1 );

	lea	ecx, QWORD PTR [rax-1]
	call	SortSegments
$LN37@bin_write_:

; 1591 :         }
; 1592 :         for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	test	rbx, rbx
	je	SHORT $LN14@bin_write_
	npad	11
$LL15@bin_write_:

; 1593 :             /* ignore absolute segments */
; 1594 :             CalcOffset( curr, &cp );

	lea	rdx, QWORD PTR cp$[rbp]
	mov	rcx, rbx
	call	CalcOffset
	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	SHORT $LL15@bin_write_
$LN227@bin_write_:

; 1591 :         }
; 1592 :         for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r12d, DWORD PTR cp$[rbp+8]
$LN14@bin_write_:

; 1595 :             DebugMsg(("bin_write_module(%s): start ofs=%" I32_SPEC "Xh, size=%" I32_SPEC "Xh, file ofs=%" I32_SPEC "Xh, grp=%s\n",
; 1596 :                       curr->sym.name, curr->e.seginfo->start_offset, curr->sym.max_offset - curr->e.seginfo->start_loc, curr->e.seginfo->fileoffset, (curr->e.seginfo->group ? curr->e.seginfo->group->name : "NULL" )));
; 1597 :         }
; 1598 :     }
; 1599 :     DebugMsg(("bin_write_module: all CalcOffset() done\n" ));
; 1600 : 
; 1601 :     /* handle relocs */
; 1602 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	test	rbx, rbx
	je	SHORT $LN17@bin_write_
	npad	11
$LL18@bin_write_:

; 1603 :         /* v2.04: scan ALL fixups! */
; 1604 :         //if ( DoFixup( curr ) == ERROR )
; 1605 :         //    return( ERROR );
; 1606 :         DoFixup( curr, &cp );

	lea	rdx, QWORD PTR cp$[rbp]
	mov	rcx, rbx
	call	DoFixup

; 1607 : #if MZ_SUPPORT
; 1608 :         if ( stack == NULL &&

	test	rsi, rsi
	jne	SHORT $LN16@bin_write_
	mov	rax, QWORD PTR [rbx+96]
	movzx	ecx, BYTE PTR [rax+108]
	and	cl, 7
	cmp	cl, 5
	cmove	rsi, rbx
$LN16@bin_write_:

; 1595 :             DebugMsg(("bin_write_module(%s): start ofs=%" I32_SPEC "Xh, size=%" I32_SPEC "Xh, file ofs=%" I32_SPEC "Xh, grp=%s\n",
; 1596 :                       curr->sym.name, curr->e.seginfo->start_offset, curr->sym.max_offset - curr->e.seginfo->start_loc, curr->e.seginfo->fileoffset, (curr->e.seginfo->group ? curr->e.seginfo->group->name : "NULL" )));
; 1597 :         }
; 1598 :     }
; 1599 :     DebugMsg(("bin_write_module: all CalcOffset() done\n" ));
; 1600 : 
; 1601 :     /* handle relocs */
; 1602 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	SHORT $LL18@bin_write_
$LN17@bin_write_:

; 1609 :             curr->e.seginfo->combine == COMB_STACK )
; 1610 :             stack = curr;
; 1611 : #endif
; 1612 :     }
; 1613 :     /* v2.04: return if any errors occured during fixup handling */
; 1614 :     if ( modinfo->g.error_count )

	cmp	DWORD PTR [r15], 0
	je	SHORT $LN39@bin_write_

; 1615 :         return( ERROR );

	or	eax, -1
	jmp	$LN1@bin_write_
$LN39@bin_write_:

; 1616 : 
; 1617 :     /* for plain binaries make sure the start label is at
; 1618 :      * the beginning of the first segment */
; 1619 :     if ( modinfo->sub_format == SFORMAT_NONE ) {

	mov	r11d, DWORD PTR [r15+372]
	test	r11d, r11d
	jne	SHORT $LN42@bin_write_

; 1620 :         if ( modinfo->g.start_label ) {

	mov	rax, QWORD PTR [r15+208]
	test	rax, rax
	je	SHORT $LN42@bin_write_

; 1621 :             if ( cp.entryoffset == -1 || cp.entryseg != modinfo->g.start_label->segment ) {

	cmp	DWORD PTR cp$[rbp+12], -1		; ffffffffH
	je	SHORT $LN43@bin_write_
	mov	rax, QWORD PTR [rax+24]
	cmp	QWORD PTR cp$[rbp+16], rax
	je	SHORT $LN42@bin_write_
$LN43@bin_write_:

; 1622 :                 return( EmitError( START_LABEL_INVALID ) );

	mov	ecx, 202				; 000000caH
	call	EmitError
	jmp	$LN1@bin_write_
$LN42@bin_write_:

; 1623 :             }
; 1624 :         }
; 1625 :     }
; 1626 : 
; 1627 :     sizetotal = GetImageSize( FALSE );

	mov	rdx, QWORD PTR SymTables+32
	mov	r9d, edi
	mov	r15d, edi
	mov	r10b, 1
	test	rdx, rdx
	je	SHORT $LN220@bin_write_
	npad	10
$LL100@bin_write_:
	mov	r8, QWORD PTR [rdx+96]
	cmp	DWORD PTR [r8+72], 5
	je	SHORT $LN98@bin_write_
	test	BYTE PTR [r8+107], 2
	jne	SHORT $LN98@bin_write_
	cmp	DWORD PTR [r8+24], 0
	jne	SHORT $LN164@bin_write_
	mov	rcx, QWORD PTR [rdx+104]
$LN229@bin_write_:
	test	rcx, rcx
	je	SHORT $LN220@bin_write_
	mov	rax, QWORD PTR [rcx+96]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN164@bin_write_
	mov	rcx, QWORD PTR [rcx+104]
	jmp	SHORT $LN229@bin_write_
$LN164@bin_write_:
	mov	eax, DWORD PTR [rdx+56]
	add	eax, DWORD PTR [r8+56]
	mov	ecx, DWORD PTR [r8+8]
	sub	eax, ecx
	test	r10b, r10b
	jne	SHORT $LN110@bin_write_
	add	r9d, ecx
$LN110@bin_write_:
	cmp	r15d, eax
	cmovb	r15d, eax
	xor	r10b, r10b
$LN98@bin_write_:
	mov	rdx, QWORD PTR [rdx+104]
	test	rdx, rdx
	jne	SHORT $LL100@bin_write_
$LN220@bin_write_:

; 1628 : 
; 1629 :     /* for MZ|PE format, initialize the header */
; 1630 : 
; 1631 :     switch ( modinfo->sub_format ) {

	cmp	r11d, 1
	jne	$LN225@bin_write_

; 1632 : #if MZ_SUPPORT
; 1633 :     case SFORMAT_MZ:
; 1634 :         /* set fields in MZ header */
; 1635 :         pMZ = (struct IMAGE_DOS_HEADER *)hdrbuf;
; 1636 :         pMZ->e_magic   = 'M' + ('Z' << 8);
; 1637 :         pMZ->e_cblp    = sizetotal % 512; /* bytes last page */

	mov	ecx, 511				; 000001ffH

; 1638 :         pMZ->e_cp      = sizetotal / 512 + (sizetotal % 512 ? 1 : 0); /* pages */
; 1639 :         pMZ->e_crlc    = reloccnt;

	mov	WORD PTR [r14+6], r13w
	mov	eax, 23117				; 00005a4dH

; 1640 :         pMZ->e_cparhdr = cp.sizehdr >> 4; /* size header in paras */
; 1641 :         sizeheap = GetImageSize( TRUE ) - sizetotal;

	movzx	r10d, r11b
	mov	WORD PTR [r14], ax
	movzx	eax, r15w
	and	ax, cx
	test	r15d, ecx
	mov	WORD PTR [r14+2], ax
	mov	ecx, edi
	mov	eax, r15d
	setne	cl
	shr	eax, 9
	add	cx, ax
	xor	r13d, r13d
	mov	eax, r12d
	mov	WORD PTR [r14+4], cx
	shr	eax, 4
	mov	r9d, r13d
	mov	WORD PTR [r14+8], ax
	mov	edi, r13d
	mov	rcx, QWORD PTR SymTables+32
	test	rcx, rcx
	je	SHORT $LN221@bin_write_
	npad	3
$LL117@bin_write_:
	mov	rdx, QWORD PTR [rcx+96]
	cmp	DWORD PTR [rdx+72], 5
	je	SHORT $LN115@bin_write_
	test	BYTE PTR [rdx+107], 2
	jne	SHORT $LN115@bin_write_
	mov	eax, DWORD PTR [rcx+56]
	add	eax, DWORD PTR [rdx+56]
	mov	r8d, DWORD PTR [rdx+8]
	sub	eax, r8d
	test	r10b, r10b
	jne	SHORT $LN127@bin_write_
	add	r9d, r8d
$LN127@bin_write_:
	add	eax, r9d
	cmp	edi, eax
	cmovb	edi, eax
	xor	r10b, r10b
$LN115@bin_write_:
	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL117@bin_write_
$LN221@bin_write_:

; 1642 :         DebugMsg(( "bin_write_module: MZ, sizetotal=%" I32_SPEC "Xh sizeheap=%" I32_SPEC "Xh\n", sizetotal, sizeheap ));
; 1643 :         pMZ->e_minalloc = sizeheap / 16 + ((sizeheap % 16) ? 1 : 0); /* heap min */
; 1644 :         if ( pMZ->e_minalloc < modinfo->mz_data.heapmin )

	mov	rbx, QWORD PTR modinfo$[rbp]
	sub	edi, r15d
	test	dil, 15
	mov	ecx, r13d
	mov	eax, edi
	setne	cl
	shr	eax, 4
	add	cx, ax
	mov	WORD PTR [r14+10], cx
	movzx	eax, WORD PTR [rbx+416]
	cmp	cx, ax
	cmovb	cx, ax
	mov	WORD PTR [r14+10], cx

; 1645 :             pMZ->e_minalloc = modinfo->mz_data.heapmin;
; 1646 :         pMZ->e_maxalloc = modinfo->mz_data.heapmax; /* heap max */

	movzx	eax, WORD PTR [rbx+418]

; 1647 :         if ( pMZ->e_maxalloc < pMZ->e_minalloc )

	cmp	ax, cx
	cmovb	ax, cx
	mov	WORD PTR [r14+12], ax

; 1648 :             pMZ->e_maxalloc = pMZ->e_minalloc;
; 1649 : 
; 1650 :         /* set stack if there's one defined */
; 1651 : 
; 1652 :         if ( stack ) {

	test	rsi, rsi
	je	SHORT $LN47@bin_write_

; 1653 :             uint_32 addr = stack->e.seginfo->start_offset;

	mov	rax, QWORD PTR [rsi+96]

; 1654 :             if ( stack->e.seginfo->group )

	mov	rdx, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+12]
	test	rdx, rdx
	je	SHORT $LN49@bin_write_

; 1655 :                 addr += stack->e.seginfo->group->offset;

	add	ecx, DWORD PTR [rdx+16]
$LN49@bin_write_:

; 1656 :             DebugMsg(("bin_write_module: MZ, stack=%" I32_SPEC "Xh ofs=%" I32_SPEC "Xh\n", addr, stack->sym.max_offset ));
; 1657 :             pMZ->e_ss = (addr >> 4) + ((addr & 0xF) ? 1 : 0); /* SS */

	test	cl, 15
	mov	eax, r13d
	setne	al
	shr	ecx, 4
	add	ax, cx
	mov	WORD PTR [r14+14], ax

; 1658 :             /* v2.11: changed sym.offset to sym.max_offset */
; 1659 :             pMZ->e_sp = stack->sym.max_offset; /* SP */

	movzx	eax, WORD PTR [rsi+56]
	mov	WORD PTR [r14+16], ax

; 1660 :         } else {

	jmp	SHORT $LN48@bin_write_
$LN47@bin_write_:

; 1661 :             EmitWarn( 2, NO_STACK );

	mov	edx, 204				; 000000ccH
	mov	ecx, 2
	call	EmitWarn
$LN48@bin_write_:

; 1662 :         }
; 1663 :         pMZ->e_csum = 0; /* checksum */

	mov	WORD PTR [r14+18], r13w

; 1664 : 
; 1665 :         /* set entry CS:IP if defined */
; 1666 : 
; 1667 :         if ( modinfo->g.start_label ) {

	mov	r8, QWORD PTR [rbx+208]
	test	r8, r8
	je	SHORT $LN50@bin_write_

; 1668 :             uint_32 addr;
; 1669 :             curr = (struct dsym *)modinfo->g.start_label->segment;

	mov	rax, QWORD PTR [r8+24]

; 1670 :             DebugMsg(("bin_write_module, start_label: offs=%" I32_SPEC "Xh, seg.offs=%" I32_SPEC "Xh, group.offs=%" I32_SPEC "Xh\n",
; 1671 :                       modinfo->g.start_label->offset, curr->e.seginfo->start_offset, curr->e.seginfo->group ? curr->e.seginfo->group->offset : 0 ));
; 1672 :             if ( curr->e.seginfo->group ) {

	mov	rcx, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	SHORT $LN52@bin_write_

; 1673 :                 addr = curr->e.seginfo->group->offset;

	mov	edx, DWORD PTR [rax+16]

; 1674 :                 pMZ->e_ip = (addr & 0xF ) + curr->e.seginfo->start_offset + modinfo->g.start_label->offset; /* IP */

	movzx	eax, dx
	movzx	ecx, WORD PTR [rcx+12]
	and	ax, 15
	add	cx, ax
	add	cx, WORD PTR [r8+16]

; 1675 :                 pMZ->e_cs = addr >> 4; /* CS */

	shr	edx, 4
	mov	WORD PTR [r14+22], dx
	mov	WORD PTR [r14+20], cx

; 1676 :             } else {

	jmp	SHORT $LN51@bin_write_
$LN52@bin_write_:

; 1677 :                 addr = curr->e.seginfo->start_offset;

	mov	ecx, DWORD PTR [rcx+12]

; 1678 :                 pMZ->e_ip = (addr & 0xF ) + modinfo->g.start_label->offset; /* IP */

	movzx	eax, cx
	and	ax, 15
	add	ax, WORD PTR [r8+16]

; 1679 :                 pMZ->e_cs = addr >> 4; /* CS */

	shr	ecx, 4
	mov	WORD PTR [r14+22], cx
	mov	WORD PTR [r14+20], ax

; 1680 :             }
; 1681 :         } else {

	jmp	SHORT $LN51@bin_write_
$LN50@bin_write_:

; 1682 :             DebugMsg(("bin_write_module, ModuleInfo->start_label=%p\n", modinfo->g.start_label ));
; 1683 :             EmitWarn( 2, NO_START_LABEL );

	mov	edx, 203				; 000000cbH
	mov	ecx, 2
	call	EmitWarn
$LN51@bin_write_:

; 1684 :         }
; 1685 :         pMZ->e_lfarlc = modinfo->mz_data.ofs_fixups;

	movzx	eax, WORD PTR [rbx+412]
	mov	WORD PTR [r14+24], ax

; 1686 :         DebugMsg(("bin_write_module: MZ, mzdata ofs_fixups=%Xh, alignment=%Xh\n", modinfo->mz_data.ofs_fixups, modinfo->mz_data.alignment ));
; 1687 :         GetSegRelocs( (uint_16 *)( hdrbuf + pMZ->e_lfarlc ) );

	lea	rcx, QWORD PTR [r14+rax]
	call	GetSegRelocs
	jmp	SHORT $LN19@bin_write_
$LN225@bin_write_:
	mov	edi, DWORD PTR sizeheap$[rbp]
	xor	r13d, r13d
$LN19@bin_write_:

; 1688 :         break;
; 1689 : #endif
; 1690 :     }
; 1691 : 
; 1692 : #if SECTORMAP
; 1693 :     if( CurrFile[LST] ) {

	mov	rcx, QWORD PTR ModuleInfo+112
	test	rcx, rcx
	je	SHORT $LN54@bin_write_

; 1694 :         /* go to EOF */
; 1695 :         fseek( CurrFile[LST], 0, SEEK_END );

	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+2]
	call	fseek

; 1696 :         LstNL();

	call	LstNL

; 1697 :         LstNL();

	call	LstNL

; 1698 :         LstPrintf( szCaption );

	lea	rcx, OFFSET FLAT:szCaption
	call	LstPrintf

; 1699 :         LstNL();

	call	LstNL

; 1700 :         LstNL();

	call	LstNL

; 1701 :         LstPrintf( szCaption2 );

	lea	rcx, OFFSET FLAT:szCaption2
	call	LstPrintf

; 1702 :         LstNL();

	call	LstNL

; 1703 :         LstPrintf( szSep );

	lea	rcx, OFFSET FLAT:szSep
	call	LstPrintf

; 1704 :         LstNL();

	call	LstNL
$LN54@bin_write_:

; 1705 :     }
; 1706 : #endif
; 1707 : 
; 1708 :     if ( cp.sizehdr ) {

	test	r12d, r12d
	je	SHORT $LN55@bin_write_

; 1709 :         if ( fwrite( hdrbuf, 1, cp.sizehdr, CurrFile[OBJ] ) != cp.sizehdr )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	edx, 1
	mov	r8d, r12d
	mov	rcx, r14
	mov	ebx, r12d
	call	fwrite
	cmp	rax, rbx
	je	SHORT $LN56@bin_write_

; 1710 :             WriteError();

	call	WriteError
$LN56@bin_write_:

; 1711 : #if SECTORMAP
; 1712 :         LstPrintf( szSegLine, szHeader, 0, 0, cp.sizehdr, 0 );

	mov	QWORD PTR [rsp+40], r13
	lea	rdx, OFFSET FLAT:szHeader
	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], r12d
	xor	r8d, r8d
	lea	rcx, OFFSET FLAT:szSegLine
	call	LstPrintf

; 1713 :         LstNL();

	call	LstNL
$LN55@bin_write_:

; 1714 : #endif
; 1715 :         LclFree( hdrbuf );
; 1716 :     }
; 1717 : 
; 1718 : #ifdef DEBUG_OUT
; 1719 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {
; 1720 :         DebugMsg(("bin_write_module(%s): type=%u written=%" I32_SPEC "X max=%" I32_SPEC "X start=%" I32_SPEC "X fileofs=%" I32_SPEC "X\n",
; 1721 :                 curr->sym.name, curr->e.seginfo->segtype,
; 1722 :                 curr->e.seginfo->bytes_written,
; 1723 :                 curr->sym.max_offset,
; 1724 :                 curr->e.seginfo->start_loc,
; 1725 :                 curr->e.seginfo->fileoffset ));
; 1726 :     }
; 1727 : #endif
; 1728 : 
; 1729 :     /* write sections */
; 1730 :     for( curr = SymTables[TAB_SEG].head, first = TRUE; curr; curr = curr->next ) {

	mov	rsi, QWORD PTR SymTables+32
	mov	r8d, 1
	test	rsi, rsi
	je	$LN22@bin_write_
	npad	14
$LL23@bin_write_:

; 1731 :         if ( curr->e.seginfo->segtype == SEGTYPE_ABS ) {

	mov	rdx, QWORD PTR [rsi+96]
	mov	eax, DWORD PTR [rdx+72]
	cmp	eax, 5
	je	$LN21@bin_write_

; 1732 :             DebugMsg(("bin_write_module(%s): ABS segment not written\n", curr->sym.name ));
; 1733 :             continue;
; 1734 :         }
; 1735 : #if PE_SUPPORT
; 1736 :         if ( ModuleInfo.sub_format == SFORMAT_PE &&

	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN58@bin_write_
	cmp	eax, 3
	je	SHORT $LN60@bin_write_
	test	BYTE PTR [rdx+107], 2
	je	SHORT $LN58@bin_write_
$LN60@bin_write_:

; 1737 :             ( curr->e.seginfo->segtype == SEGTYPE_BSS || curr->e.seginfo->info ) )
; 1738 :             size = 0;

	mov	ebx, r13d
	jmp	SHORT $LN59@bin_write_
$LN58@bin_write_:

; 1739 :         else
; 1740 : #endif
; 1741 :             /* v2.05: changed */
; 1742 :             size = curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	ebx, DWORD PTR [rsi+56]
	sub	ebx, DWORD PTR [rdx+8]
$LN59@bin_write_:

; 1743 :         //size = sizemem;
; 1744 :         sizemem = first ? size : curr->sym.max_offset;

	mov	r10d, ebx
	test	r8d, r8d
	jne	SHORT $LN74@bin_write_
	mov	r10d, DWORD PTR [rsi+56]
$LN74@bin_write_:

; 1745 :         /* if no bytes have been written to the segment, check if there's
; 1746 :          * any further segments with bytes set. If no, skip write! */
; 1747 :         if ( curr->e.seginfo->bytes_written == 0 ) {

	cmp	DWORD PTR [rdx+24], 0
	jne	SHORT $LN63@bin_write_

; 1748 :             struct dsym *dir;
; 1749 :             for ( dir = curr->next; dir; dir = dir->next )

	mov	rcx, QWORD PTR [rsi+104]
	test	rcx, rcx
	je	SHORT $LN219@bin_write_
	npad	6
$LL26@bin_write_:

; 1750 :                 if ( dir->e.seginfo->bytes_written )

	mov	rax, QWORD PTR [rcx+96]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN63@bin_write_

; 1748 :             struct dsym *dir;
; 1749 :             for ( dir = curr->next; dir; dir = dir->next )

	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL26@bin_write_
$LN219@bin_write_:

; 1751 :                     break;
; 1752 :             if ( !dir ) {
; 1753 :                 DebugMsg(("bin_write_module(%s): segment not written, size=% " I32_SPEC "Xh sizemem=%" I32_SPEC "X\n",
; 1754 :                           curr->sym.name, size, sizemem ));
; 1755 :                 size = 0;

	mov	ebx, r13d
$LN63@bin_write_:

; 1756 :             }
; 1757 :         }
; 1758 : #if SECTORMAP
; 1759 :         /* v2.05: changed
; 1760 :          * print name, fileoffset, objoffset, filesize, memsize
; 1761 :          */
; 1762 :         //LstPrintf( szSegLine, curr->sym.name, curr->e.seginfo->fileoffset, curr->e.seginfo->start_offset + curr->e.seginfo->start_loc, size, sizemem );
; 1763 :         LstPrintf( szSegLine, curr->sym.name, curr->e.seginfo->fileoffset, first ? curr->e.seginfo->start_offset + curr->e.seginfo->start_loc : curr->e.seginfo->start_offset, size, sizemem );

	mov	r9d, DWORD PTR [rdx+12]
	test	r8d, r8d
	je	SHORT $LN76@bin_write_
	add	r9d, DWORD PTR [rdx+8]
$LN76@bin_write_:
	mov	r8d, DWORD PTR [rdx+56]
	lea	rcx, OFFSET FLAT:szSegLine
	mov	rdx, QWORD PTR [rsi+8]
	mov	DWORD PTR [rsp+40], r10d
	mov	DWORD PTR [rsp+32], ebx
	call	LstPrintf

; 1764 :         LstNL();

	call	LstNL

; 1765 : #endif
; 1766 :         if ( size != 0 && curr->e.seginfo->CodeBuffer ) {

	test	ebx, ebx
	je	SHORT $LN65@bin_write_
	mov	rax, QWORD PTR [rsi+96]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN65@bin_write_

; 1767 :             DebugMsg(("bin_write_module(%s): write %" I32_SPEC "Xh bytes at offset %" I32_SPEC "Xh, initialized bytes=%" I32_SPEC "u, buffer=%p\n",
; 1768 :                       curr->sym.name, size, curr->e.seginfo->fileoffset, curr->e.seginfo->bytes_written, curr->e.seginfo->CodeBuffer ));
; 1769 :             fseek( CurrFile[OBJ], curr->e.seginfo->fileoffset, SEEK_SET );

	mov	edx, DWORD PTR [rax+56]
	xor	r8d, r8d
	mov	rcx, QWORD PTR ModuleInfo+104
	call	fseek

; 1770 : #ifdef __I86__
; 1771 :             if ( hfwrite( curr->e.seginfo->CodeBuffer, 1, size, CurrFile[OBJ] ) != size )
; 1772 :                 WriteError();
; 1773 : #else
; 1774 :             if ( fwrite( curr->e.seginfo->CodeBuffer, 1, size, CurrFile[OBJ] ) != size )

	mov	rcx, QWORD PTR [rsi+96]
	mov	r8, rbx
	mov	r9, QWORD PTR ModuleInfo+104
	mov	edx, 1
	mov	rcx, QWORD PTR [rcx+16]
	call	fwrite
	cmp	rax, rbx
	je	SHORT $LN65@bin_write_

; 1775 :                 WriteError();

	call	WriteError
$LN65@bin_write_:

; 1776 : #endif
; 1777 :         }
; 1778 : #ifdef DEBUG_OUT
; 1779 :         else DebugMsg(("bin_write_module(%s): nothing written\n", curr->sym.name ));
; 1780 : #endif
; 1781 :         first = FALSE;

	mov	r8d, r13d
$LN21@bin_write_:

; 1714 : #endif
; 1715 :         LclFree( hdrbuf );
; 1716 :     }
; 1717 : 
; 1718 : #ifdef DEBUG_OUT
; 1719 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {
; 1720 :         DebugMsg(("bin_write_module(%s): type=%u written=%" I32_SPEC "X max=%" I32_SPEC "X start=%" I32_SPEC "X fileofs=%" I32_SPEC "X\n",
; 1721 :                 curr->sym.name, curr->e.seginfo->segtype,
; 1722 :                 curr->e.seginfo->bytes_written,
; 1723 :                 curr->sym.max_offset,
; 1724 :                 curr->e.seginfo->start_loc,
; 1725 :                 curr->e.seginfo->fileoffset ));
; 1726 :     }
; 1727 : #endif
; 1728 : 
; 1729 :     /* write sections */
; 1730 :     for( curr = SymTables[TAB_SEG].head, first = TRUE; curr; curr = curr->next ) {

	mov	rsi, QWORD PTR [rsi+104]
	test	rsi, rsi
	jne	$LL23@bin_write_
$LN22@bin_write_:

; 1782 :     }
; 1783 : #if PE_SUPPORT && RAWSIZE_ROUND
; 1784 :     if ( modinfo->sub_format == SFORMAT_PE ) {

	mov	r14, QWORD PTR modinfo$[rbp]
	cmp	DWORD PTR [r14+372], 2
	jne	SHORT $LN67@bin_write_

; 1785 :         size = ftell( CurrFile[OBJ] );

	mov	rcx, QWORD PTR ModuleInfo+104
	call	ftell

; 1786 :         if ( size & ( cp.rawpagesize - 1 ) ) {

	mov	ecx, DWORD PTR cp$[rbp+40]
	lea	edx, DWORD PTR [rcx-1]
	and	edx, eax
	je	SHORT $LN67@bin_write_

; 1787 :             char *tmp;
; 1788 :             size = cp.rawpagesize - ( size & ( cp.rawpagesize - 1 ) );

	sub	ecx, edx

; 1789 :             tmp = myalloca( size );

	mov	esi, ecx
	lea	rax, QWORD PTR [rcx+15]
	cmp	rax, rsi
	ja	SHORT $LN223@bin_write_
	mov	rax, 1152921504606846960		; 0ffffffffffffff0H
$LN223@bin_write_:
	and	rax, -16
	call	__chkstk
	sub	rsp, rax

; 1790 :             memset( tmp, 0, size );

	mov	r8, rsi
	xor	edx, edx
	lea	rbx, QWORD PTR [rsp+48]
	mov	rcx, rbx
	call	memset

; 1791 :             fwrite( tmp, 1, size, CurrFile[OBJ] );

	mov	r9, QWORD PTR ModuleInfo+104
	mov	r8, rsi
	mov	edx, 1
	mov	rcx, rbx
	call	fwrite
$LN67@bin_write_:

; 1792 :         }
; 1793 :     }
; 1794 : #endif
; 1795 : #if SECTORMAP
; 1796 :     LstPrintf( szSep );

	lea	rcx, OFFSET FLAT:szSep
	call	LstPrintf

; 1797 :     LstNL();

	call	LstNL

; 1798 : #if MZ_SUPPORT
; 1799 :     if ( modinfo->sub_format == SFORMAT_MZ )

	mov	eax, DWORD PTR [r14+372]
	cmp	eax, 1
	jne	SHORT $LN68@bin_write_

; 1800 :         sizeheap += sizetotal - cp.sizehdr;

	mov	eax, r15d
	sub	eax, r12d
	add	edi, eax
	jmp	SHORT $LN71@bin_write_
$LN68@bin_write_:

; 1801 :     else
; 1802 : #endif
; 1803 : #if PE_SUPPORT
; 1804 :     if ( modinfo->sub_format == SFORMAT_PE )

	cmp	eax, 2
	jne	SHORT $LN70@bin_write_

; 1805 :         sizeheap = cp.rva;

	mov	edi, DWORD PTR cp$[rbp+28]
	jmp	SHORT $LN71@bin_write_
$LN70@bin_write_:

; 1806 :     else
; 1807 : #endif
; 1808 :         sizeheap = GetImageSize( TRUE );

	mov	rcx, QWORD PTR SymTables+32
	mov	edi, r13d
	mov	r8b, 1
	test	rcx, rcx
	je	SHORT $LN71@bin_write_
	npad	1
$LL134@bin_write_:
	mov	rax, QWORD PTR [rcx+96]
	cmp	DWORD PTR [rax+72], 5
	je	SHORT $LN132@bin_write_
	test	BYTE PTR [rax+107], 2
	jne	SHORT $LN132@bin_write_
	mov	edx, DWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax+56]
	add	eax, DWORD PTR [rcx+56]
	sub	eax, edx
	test	r8b, r8b
	jne	SHORT $LN144@bin_write_
	add	r13d, edx
$LN144@bin_write_:
	add	eax, r13d
	cmp	edi, eax
	cmovb	edi, eax
	xor	r8b, r8b
$LN132@bin_write_:
	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL134@bin_write_
$LN71@bin_write_:

; 1809 :     LstPrintf( szTotal, " ", sizetotal, sizeheap );

	mov	r9d, edi
	lea	rdx, OFFSET FLAT:$SG12381
	mov	r8d, r15d
	lea	rcx, OFFSET FLAT:szTotal
	call	LstPrintf

; 1810 :     LstNL();

	call	LstNL

; 1811 : #endif
; 1812 :     DebugMsg(("bin_write_module: exit\n"));
; 1813 : 
; 1814 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@bin_write_:

; 1815 : }

	mov	rbx, QWORD PTR [rbp+128]
	lea	rsp, QWORD PTR [rbp+48]
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
bin_write_module ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
modinfo$ = 48
pe_enddirhook PROC

; 1495 : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1496 :     pe_create_MZ_header( modinfo );

	call	pe_create_MZ_header

; 1497 :     //pe_create_PE_header(); /* the PE header is created when the .MODEL directive is found */
; 1498 :     pe_emit_export_data();

	call	pe_emit_export_data

; 1499 :     if ( modinfo->g.DllQueue )

	cmp	QWORD PTR [rbx+80], 0
	je	SHORT $LN2@pe_enddirh

; 1500 :         pe_emit_import_data();

	call	pe_emit_import_data
$LN2@pe_enddirh:

; 1501 :     pe_create_section_table();

	call	pe_create_section_table

; 1502 :     return( NOT_ERROR );

	xor	eax, eax

; 1503 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
pe_enddirhook ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
;	COMDAT pe_set_values
_TEXT	SEGMENT
ph32$ = 48
ph64$1$ = 56
sizeimg$1$ = 64
pehdr$1$ = 72
mzhdr$1$ = 80
objtab$1$ = 88
buffer$ = 96
codesize$1$ = 432
ph64$ = 432
cp$ = 432
sizehdr$1$ = 440
datasize$1$ = 448
database$1$ = 456
pe_set_values PROC					; COMDAT

; 1232 : {

	mov	rax, rsp
	push	rbp
	push	rdi
	push	r13
	push	r15
	sub	rsp, 392				; 00000188H
	mov	QWORD PTR [rax-40], rbx
	mov	r15, rcx
	mov	QWORD PTR [rax-48], rsi

; 1233 :     int i;
; 1234 :     int falign;
; 1235 :     int malign;
; 1236 :     uint_16 ff;
; 1237 :     uint_32 codebase = 0;
; 1238 :     uint_32 database = 0;
; 1239 :     uint_32 codesize = 0;
; 1240 :     uint_32 datasize = 0;
; 1241 :     uint_32 sizehdr  = 0;
; 1242 :     uint_32 sizeimg  = 0;
; 1243 :     struct dsym *curr;
; 1244 :     struct dsym *mzhdr;
; 1245 :     struct dsym *pehdr;
; 1246 :     struct dsym *objtab;
; 1247 :     struct dsym *reloc = NULL;
; 1248 :     struct IMAGE_PE_HEADER32 *ph32;
; 1249 : #if AMD64_SUPPORT
; 1250 :     struct IMAGE_PE_HEADER64 *ph64;
; 1251 : #endif
; 1252 :     struct IMAGE_FILE_HEADER *fh;
; 1253 :     struct IMAGE_SECTION_HEADER *section;
; 1254 :     struct IMAGE_DATA_DIRECTORY *datadir;
; 1255 :     char *secname;
; 1256 :     char buffer[MAX_ID_LEN+1];
; 1257 : 
; 1258 :     mzhdr  = ( struct dsym *)SymSearch( hdrname "1" );

	lea	rcx, OFFSET FLAT:$SG12231
	mov	QWORD PTR [rax-56], r12
	xor	r12d, r12d
	mov	DWORD PTR database$1$[rsp], r12d
	mov	r13d, r12d
	mov	DWORD PTR codesize$1$[rsp], r12d
	mov	DWORD PTR datasize$1$[rsp], r12d
	mov	DWORD PTR sizehdr$1$[rsp], r12d
	mov	QWORD PTR [rax-64], r14
	call	SymFind

; 1259 :     pehdr  = ( struct dsym *)SymSearch( hdrname "2" );

	lea	rcx, OFFSET FLAT:$SG12232
	mov	QWORD PTR mzhdr$1$[rsp], rax
	mov	rdi, rax
	call	SymFind

; 1260 :     objtab = ( struct dsym *)SymSearch( hdrname "3" );

	lea	rcx, OFFSET FLAT:$SG12233
	mov	QWORD PTR pehdr$1$[rsp], rax
	mov	rbx, rax
	call	SymFind

; 1261 : 
; 1262 :     /* make sure all header objects are in FLAT group */
; 1263 :     mzhdr->e.seginfo->group = &ModuleInfo.flat_grp->sym;

	mov	rcx, QWORD PTR [rdi+96]
	mov	rsi, rax
	mov	QWORD PTR objtab$1$[rsp], rax
	mov	rax, QWORD PTR ModuleInfo+440
	mov	QWORD PTR [rcx], rax

; 1264 : #if AMD64_SUPPORT
; 1265 :     if ( ModuleInfo.defOfssize == USE64 ) {

	movzx	r9d, BYTE PTR ModuleInfo+405

; 1266 :         ph64 = ( struct IMAGE_PE_HEADER64 *)pehdr->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [rbx+96]
	cmp	r9b, 2
	jne	SHORT $LN14@pe_set_val
	mov	rbp, QWORD PTR [rax+16]

; 1267 :         ff = ph64->FileHeader.Characteristics;
; 1268 :     } else {

	mov	rbx, QWORD PTR ph32$[rsp]
	movzx	eax, WORD PTR [rbp+22]
	jmp	SHORT $LN89@pe_set_val
$LN14@pe_set_val:

; 1269 : #endif
; 1270 :         ph32 = ( struct IMAGE_PE_HEADER32 *)pehdr->e.seginfo->CodeBuffer;

	mov	rbx, QWORD PTR [rax+16]

; 1271 :         ff = ph32->FileHeader.Characteristics;

	mov	rbp, QWORD PTR ph64$[rsp]
	mov	QWORD PTR ph32$[rsp], rbx
	movzx	eax, WORD PTR [rbx+22]
$LN89@pe_set_val:
	mov	QWORD PTR ph64$1$[rsp], rbp

; 1272 : #if AMD64_SUPPORT
; 1273 :     }
; 1274 : #endif
; 1275 :     if ( !( ff & IMAGE_FILE_RELOCS_STRIPPED ) ) {

	test	al, 1
	jne	$LN17@pe_set_val

; 1276 :         DebugMsg(("pe_set_values: .reloc section required\n" ));
; 1277 :         reloc = (struct dsym *)CreateIntSegment( ".reloc", "RELOC", 2, ModuleInfo.defOfssize, TRUE );

	mov	r8b, 2
	mov	BYTE PTR [rsp+32], 1
	lea	rdx, OFFSET FLAT:$SG12237
	lea	rcx, OFFSET FLAT:$SG12238
	call	CreateIntSegment
	mov	r13, rax

; 1278 :         if ( reloc ) {

	test	rax, rax
	je	SHORT $LN17@pe_set_val

; 1279 :             reloc->e.seginfo->group = &ModuleInfo.flat_grp->sym;

	mov	rdx, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+440
	mov	QWORD PTR [rdx], rcx

; 1280 :             reloc->e.seginfo->combine = COMB_ADDOFF;  /* PUBLIC */

	mov	rdx, QWORD PTR [rax+96]
	movzx	ecx, BYTE PTR [rdx+108]
	and	cl, 250					; 000000faH
	or	cl, 2
	mov	BYTE PTR [rdx+108], cl

; 1281 :             reloc->e.seginfo->segtype = SEGTYPE_RELOC;

	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+72], 8

; 1282 :             reloc->e.seginfo->characteristics = ((IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ) >> 24 );

	mov	rax, QWORD PTR [r13+96]
	mov	BYTE PTR [rax+105], 66			; 00000042H

; 1283 :             /* make sure the section isn't empty ( true size will be calculated later ) */
; 1284 :             reloc->sym.max_offset = sizeof( struct IMAGE_BASE_RELOCATION );
; 1285 :             reloc->e.seginfo->bytes_written = reloc->sym.max_offset;

	mov	rax, QWORD PTR [r13+96]
	mov	DWORD PTR [r13+56], 8
	mov	DWORD PTR [rax+24], 8

; 1286 :             /* clear the additionally allocated entry in object table */
; 1287 :             memset( objtab->e.seginfo->CodeBuffer + objtab->sym.max_offset, 0, sizeof( struct IMAGE_SECTION_HEADER ) );

	mov	rax, QWORD PTR [rsi+96]
	movsxd	rcx, DWORD PTR [rsi+56]
	add	rcx, QWORD PTR [rax+16]
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax

; 1288 :             objtab->sym.max_offset += sizeof( struct IMAGE_SECTION_HEADER );

	add	DWORD PTR [rsi+56], 40			; 00000028H
$LN17@pe_set_val:

; 1289 :         }
; 1290 :     }
; 1291 : 
; 1292 : 
; 1293 :     /* sort: header, executable, readable, read-write segments, resources, relocs */
; 1294 :     for ( i = 0; i < SIZE_PEFLAT; i++ ) {

	mov	edx, r12d
	lea	r9, OFFSET FLAT:flat_order
	npad	3
$LL4@pe_set_val:

; 1295 :         DebugMsg(("pe_set_values: searching segment types %Xh\n", flat_order[i] ));
; 1296 :         for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rax, QWORD PTR SymTables+32
	test	rax, rax
	je	SHORT $LN2@pe_set_val

; 1297 :             if ( curr->e.seginfo->segtype == flat_order[i] ) {

	mov	r8d, DWORD PTR [r9]
	npad	1
$LL7@pe_set_val:
	mov	rcx, QWORD PTR [rax+96]
	cmp	DWORD PTR [rcx+72], r8d
	jne	SHORT $LN5@pe_set_val

; 1298 :                 curr->e.seginfo->lname_idx = i;

	mov	DWORD PTR [rcx+76], edx
$LN5@pe_set_val:

; 1295 :         DebugMsg(("pe_set_values: searching segment types %Xh\n", flat_order[i] ));
; 1296 :         for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rax, QWORD PTR [rax+104]
	test	rax, rax
	jne	SHORT $LL7@pe_set_val
$LN2@pe_set_val:

; 1289 :         }
; 1290 :     }
; 1291 : 
; 1292 : 
; 1293 :     /* sort: header, executable, readable, read-write segments, resources, relocs */
; 1294 :     for ( i = 0; i < SIZE_PEFLAT; i++ ) {

	inc	edx
	add	r9, 4
	movsxd	rax, edx
	cmp	rax, 7
	jb	SHORT $LL4@pe_set_val

; 1299 :             }
; 1300 :         }
; 1301 : 
; 1302 :     }
; 1303 :     SortSegments( 2 );

	mov	ecx, 2
	call	SortSegments

; 1304 :     falign = get_bit( GHF( OptionalHeader.FileAlignment ) );

	movzx	ecx, BYTE PTR ModuleInfo+405
	cmp	cl, 2
	jne	SHORT $LN52@pe_set_val
	mov	eax, DWORD PTR [rbp+60]
	jmp	SHORT $LN53@pe_set_val
$LN52@pe_set_val:
	mov	eax, DWORD PTR [rbx+60]
$LN53@pe_set_val:
	or	r14d, -1
	mov	edi, r14d
	test	eax, eax
	je	SHORT $LN66@pe_set_val
	npad	2
$LL65@pe_set_val:
	inc	edi
	sar	eax, 1
	jne	SHORT $LL65@pe_set_val
$LN66@pe_set_val:

; 1305 :     malign = GHF( OptionalHeader.SectionAlignment );

	cmp	cl, 2
	jne	SHORT $LN54@pe_set_val
	mov	ebp, DWORD PTR [rbp+56]
	jmp	SHORT $LN55@pe_set_val
$LN54@pe_set_val:
	mov	ebp, DWORD PTR [rbx+56]
$LN55@pe_set_val:

; 1306 : 
; 1307 :     /* assign RVAs to sections */
; 1308 : 
; 1309 :     for ( curr = SymTables[TAB_SEG].head, i = -1; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	mov	esi, r14d
	test	rbx, rbx
	je	SHORT $LN9@pe_set_val
$LL10@pe_set_val:

; 1310 :         if ( curr->e.seginfo->lname_idx == SEGTYPE_ERROR || curr->e.seginfo->lname_idx != i ) {

	mov	rcx, QWORD PTR [rbx+96]
	mov	eax, DWORD PTR [rcx+76]
	cmp	eax, 10
	je	SHORT $LN21@pe_set_val
	cmp	eax, esi
	jne	SHORT $LN21@pe_set_val

; 1314 :         } else {
; 1315 :             uint_32 align = 1 << curr->e.seginfo->alignment;

	movzx	ecx, BYTE PTR [rcx+106]
	mov	edx, 1
	shl	edx, cl

; 1316 :             cp->alignment = 0;
; 1317 :             cp->rva = (cp->rva + (align - 1)) & (~(align-1));

	mov	ecx, DWORD PTR [r15+28]
	dec	ecx
	mov	BYTE PTR [r15+1], r12b
	add	ecx, edx
	lea	eax, DWORD PTR [rdx-1]
	jmp	SHORT $LN90@pe_set_val
$LN21@pe_set_val:

; 1311 :             i = curr->e.seginfo->lname_idx;
; 1312 :             cp->alignment = falign;
; 1313 :             cp->rva = (cp->rva + (malign - 1)) & (~(malign-1));

	mov	ecx, DWORD PTR [r15+28]
	mov	esi, eax
	dec	ecx
	mov	BYTE PTR [r15+1], dil
	add	ecx, ebp
	lea	eax, DWORD PTR [rbp-1]
$LN90@pe_set_val:
	not	eax

; 1318 :         }
; 1319 :         CalcOffset( curr, cp );

	mov	rdx, r15
	and	ecx, eax
	mov	DWORD PTR [r15+28], ecx
	mov	rcx, rbx
	call	CalcOffset
	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	SHORT $LL10@pe_set_val
$LN9@pe_set_val:

; 1320 :         DebugMsg(("pe_set_values: section %s, start ofs=%" I32_SPEC "Xh, size=%" I32_SPEC "Xh, file ofs=%" I32_SPEC "Xh\n",
; 1321 :                   curr->sym.name, curr->e.seginfo->start_offset, curr->sym.max_offset - curr->e.seginfo->start_loc, curr->e.seginfo->fileoffset ));
; 1322 :     }
; 1323 : 
; 1324 :     if ( reloc ) {

	test	r13, r13
	je	SHORT $LN22@pe_set_val

; 1325 :         pe_set_base_relocs( reloc );

	mov	rcx, r13
	call	pe_set_base_relocs

; 1326 :         cp->rva = reloc->e.seginfo->start_offset + reloc->sym.max_offset;

	mov	rax, QWORD PTR [r13+96]
	mov	ecx, DWORD PTR [rax+12]
	add	ecx, DWORD PTR [r13+56]
	mov	DWORD PTR [r15+28], ecx
$LN22@pe_set_val:

; 1327 :     }
; 1328 : 
; 1329 :     sizeimg = cp->rva;
; 1330 : 
; 1331 :     /* set e_lfanew of dosstub to start of PE header */
; 1332 :     if ( mzhdr->sym.max_offset >= 0x40 )

	mov	rax, QWORD PTR mzhdr$1$[rsp]
	mov	esi, DWORD PTR [r15+28]

; 1333 :         ((struct IMAGE_DOS_HEADER *)mzhdr->e.seginfo->CodeBuffer)->e_lfanew = pehdr->e.seginfo->fileoffset;

	mov	r8, QWORD PTR pehdr$1$[rsp]
	mov	DWORD PTR sizeimg$1$[rsp], esi
	cmp	DWORD PTR [rax+56], 64			; 00000040H
	jl	SHORT $LN23@pe_set_val
	mov	rax, QWORD PTR [rax+96]
	mov	rdx, QWORD PTR [r8+96]
	mov	rcx, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rdx+56]
	mov	DWORD PTR [rcx+60], eax
$LN23@pe_set_val:

; 1334 : 
; 1335 :     /* set number of sections in PE file header (doesn't matter if it's 32- or 64-bit) */
; 1336 :     fh = &((struct IMAGE_PE_HEADER32 *)pehdr->e.seginfo->CodeBuffer)->FileHeader;
; 1337 :     fh->NumberOfSections = objtab->sym.max_offset / sizeof( struct IMAGE_SECTION_HEADER );

	mov	r9, QWORD PTR objtab$1$[rsp]
	mov	rax, -3689348814741910323		; cccccccccccccccdH

; 1338 : 
; 1339 : #if RAWSIZE_ROUND
; 1340 :     cp->rawpagesize = ( ModuleInfo.defOfssize == USE64 ? ph64->OptionalHeader.FileAlignment : ph32->OptionalHeader.FileAlignment );

	mov	r13, QWORD PTR ph64$1$[rsp]
	mov	rbp, QWORD PTR ph32$[rsp]
	movsxd	rcx, DWORD PTR [r9+56]
	mul	rcx
	mov	rax, QWORD PTR [r8+96]
	shr	rdx, 5
	mov	rcx, QWORD PTR [rax+16]
	mov	WORD PTR [rcx+6], dx
	cmp	BYTE PTR ModuleInfo+405, 2
	jne	SHORT $LN56@pe_set_val
	mov	eax, DWORD PTR [r13+60]
	jmp	SHORT $LN57@pe_set_val
$LN56@pe_set_val:
	mov	eax, DWORD PTR [rbp+60]
$LN57@pe_set_val:
	mov	DWORD PTR [r15+40], eax

; 1341 : #endif
; 1342 : 
; 1343 :     /* fill object table values */
; 1344 :     section = (struct IMAGE_SECTION_HEADER *)objtab->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [r9+96]

; 1345 :     for( curr = SymTables[TAB_SEG].head, i = -1; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	mov	rdi, QWORD PTR [rax+16]
	test	rbx, rbx
	je	$LN12@pe_set_val
	mov	ebp, r12d
	mov	r13d, r12d
	mov	esi, r12d
	npad	8
$LL13@pe_set_val:

; 1346 :         if ( curr->e.seginfo->segtype == SEGTYPE_HDR )

	mov	rax, QWORD PTR [rbx+96]
	cmp	DWORD PTR [rax+72], 6
	je	$LN11@pe_set_val

; 1347 :             continue;
; 1348 :         if ( curr->sym.max_offset == 0 ) /* ignore empty sections */

	cmp	DWORD PTR [rbx+56], 0
	je	$LN11@pe_set_val

; 1349 :             continue;
; 1350 :         if ( curr->e.seginfo->lname_idx != i ) {

	mov	ecx, DWORD PTR [rax+76]
	cmp	ecx, r14d
	je	SHORT $LN28@pe_set_val

; 1351 :             i = curr->e.seginfo->lname_idx;
; 1352 :             secname = ( curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ConvertSectionName( &curr->sym, NULL, buffer ) );

	mov	rax, QWORD PTR [rax+96]
	mov	r14d, ecx
	test	rax, rax
	jne	SHORT $LN59@pe_set_val
	lea	r8, QWORD PTR buffer$[rsp]
	xor	edx, edx
	mov	rcx, rbx
	call	ConvertSectionName
$LN59@pe_set_val:

; 1353 :             strncpy( section->Name, secname, sizeof ( section->Name ) );

	mov	r8d, 8
	mov	rdx, rax
	mov	rcx, rdi
	call	strncpy

; 1354 :             if ( curr->e.seginfo->segtype != SEGTYPE_BSS )

	mov	rax, QWORD PTR [rbx+96]
	cmp	DWORD PTR [rax+72], 3
	je	SHORT $LN27@pe_set_val

; 1355 :                 section->PointerToRawData = curr->e.seginfo->fileoffset;

	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rdi+20], eax
$LN27@pe_set_val:

; 1356 :             section->VirtualAddress = curr->e.seginfo->start_offset;

	mov	rax, QWORD PTR [rbx+96]
	mov	ecx, DWORD PTR [rax+12]
	mov	DWORD PTR [rdi+12], ecx

; 1357 :             /* file offset of first section in object table defines SizeOfHeader */
; 1358 :             if ( sizehdr == 0 )

	test	r13d, r13d
	jne	SHORT $LN28@pe_set_val

; 1359 :                 sizehdr = curr->e.seginfo->fileoffset;

	mov	rax, QWORD PTR [rbx+96]
	mov	r13d, DWORD PTR [rax+56]
$LN28@pe_set_val:

; 1360 :         }
; 1361 :         section->Characteristics |= pe_get_characteristics( curr );

	mov	rcx, rbx
	call	pe_get_characteristics
	or	DWORD PTR [rdi+36], eax

; 1362 :         if ( curr->e.seginfo->segtype != SEGTYPE_BSS ) {

	mov	rax, QWORD PTR [rbx+96]
	mov	r8d, DWORD PTR [rdi+36]
	cmp	DWORD PTR [rax+72], 3
	je	SHORT $LN29@pe_set_val

; 1363 :             section->SizeOfRawData += curr->sym.max_offset;

	mov	eax, DWORD PTR [rbx+56]
	add	DWORD PTR [rdi+16], eax
$LN29@pe_set_val:

; 1364 :         }
; 1365 : 
; 1366 :         /* v2.10: this calculation is not correct */
; 1367 :         //section->Misc.VirtualSize += curr->sym.max_offset;
; 1368 :         section->Misc.VirtualSize = curr->sym.max_offset + ( curr->e.seginfo->start_offset - section->VirtualAddress );

	mov	rax, QWORD PTR [rbx+96]
	mov	edx, DWORD PTR [rdi+12]
	mov	ecx, DWORD PTR [rax+12]
	sub	ecx, edx
	add	ecx, DWORD PTR [rbx+56]
	mov	DWORD PTR [rdi+8], ecx

; 1369 : 
; 1370 :         if ( curr->next == NULL || curr->next->e.seginfo->lname_idx != i ) {

	mov	rax, QWORD PTR [rbx+104]
	test	rax, rax
	je	SHORT $LN31@pe_set_val
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+76], r14d
	je	SHORT $LN34@pe_set_val
$LN31@pe_set_val:

; 1371 : #if RAWSIZE_ROUND /* AntiVir TR/Crypt.XPACK Gen */
; 1372 :             section->SizeOfRawData += cp->rawpagesize - 1;

	mov	eax, DWORD PTR [r15+40]
	dec	eax
	add	DWORD PTR [rdi+16], eax

; 1373 :             section->SizeOfRawData &= ~(cp->rawpagesize - 1);

	mov	eax, DWORD PTR [r15+40]
	dec	eax
	not	eax
	and	eax, DWORD PTR [rdi+16]
	mov	DWORD PTR [rdi+16], eax

; 1374 : #endif
; 1375 :             if ( section->Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

	bt	r8d, 29
	jae	SHORT $LN32@pe_set_val

; 1376 :                 if ( codebase == 0 )

	test	r12d, r12d
	cmove	r12d, edx

; 1377 :                     codebase = section->VirtualAddress;
; 1378 :                 codesize += section->SizeOfRawData;

	add	esi, eax
$LN32@pe_set_val:

; 1379 :             }
; 1380 :             if ( section->Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA ) {

	test	r8b, 64					; 00000040H
	je	SHORT $LN34@pe_set_val

; 1381 :                 if ( database == 0 )

	test	ebp, ebp
	cmove	ebp, edx

; 1382 :                     database = section->VirtualAddress;
; 1383 :                 datasize += section->SizeOfRawData;

	add	DWORD PTR datasize$1$[rsp], eax
$LN34@pe_set_val:

; 1384 :             }
; 1385 :         }
; 1386 :         if ( curr->next && curr->next->e.seginfo->lname_idx != i ) {

	mov	rax, QWORD PTR [rbx+104]
	test	rax, rax
	je	SHORT $LN11@pe_set_val
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+76], r14d
	je	SHORT $LN11@pe_set_val

; 1387 :             DebugMsg(("pe_set_values: object %.8s, VA=%" I32_SPEC "X size=%" I32_SPEC "X phys ofs/size=%" I32_SPEC "Xh/%" I32_SPEC "Xh\n",
; 1388 :                   section->Name, section->VirtualAddress, section->Misc.VirtualSize, section->PointerToRawData, section->SizeOfRawData ));
; 1389 :             section++;

	add	rdi, 40					; 00000028H
$LN11@pe_set_val:

; 1345 :     for( curr = SymTables[TAB_SEG].head, i = -1; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	$LL13@pe_set_val
	mov	DWORD PTR codesize$1$[rsp], esi
	mov	esi, DWORD PTR sizeimg$1$[rsp]
	mov	DWORD PTR sizehdr$1$[rsp], r13d
	mov	r13, QWORD PTR ph64$1$[rsp]
	mov	DWORD PTR database$1$[rsp], ebp
	mov	rbp, QWORD PTR ph32$[rsp]
$LN12@pe_set_val:

; 1390 :         }
; 1391 :     }
; 1392 : 
; 1393 : 
; 1394 :     if ( ModuleInfo.g.start_label ) {

	mov	rdx, QWORD PTR ModuleInfo+208
	mov	r14, QWORD PTR [rsp+360]
	test	rdx, rdx
	je	SHORT $LN37@pe_set_val

; 1395 : #if AMD64_SUPPORT
; 1396 :         if ( ModuleInfo.defOfssize == USE64 )
; 1397 :             ph64->OptionalHeader.AddressOfEntryPoint = ((struct dsym *)ModuleInfo.g.start_label->segment)->e.seginfo->start_offset + ModuleInfo.g.start_label->offset;

	mov	rax, QWORD PTR [rdx+24]
	mov	rcx, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rcx+12]
	add	eax, DWORD PTR [rdx+16]
	cmp	BYTE PTR ModuleInfo+405, 2
	jne	SHORT $LN39@pe_set_val
	mov	DWORD PTR [r13+40], eax
	jmp	SHORT $LN38@pe_set_val
$LN39@pe_set_val:

; 1398 :         else
; 1399 : #endif
; 1400 :             ph32->OptionalHeader.AddressOfEntryPoint = ((struct dsym *)ModuleInfo.g.start_label->segment)->e.seginfo->start_offset + ModuleInfo.g.start_label->offset;

	mov	DWORD PTR [rbp+40], eax

; 1401 :     } else {

	jmp	SHORT $LN38@pe_set_val
$LN37@pe_set_val:

; 1402 :         DebugMsg(("pe_set_values: warning: not start label found\n" ));
; 1403 :         EmitWarn( 2, NO_START_LABEL );

	mov	edx, 203				; 000000cbH
	mov	ecx, 2
	call	EmitWarn
$LN38@pe_set_val:

; 1404 :     }
; 1405 : 
; 1406 : #if AMD64_SUPPORT
; 1407 :     if ( ModuleInfo.defOfssize == USE64 ) {

	cmp	BYTE PTR ModuleInfo+405, 2

; 1408 : #if IMGSIZE_ROUND
; 1409 :         /* round up the SizeOfImage field to page boundary */
; 1410 :         sizeimg = ( sizeimg + ph64->OptionalHeader.SectionAlignment - 1 ) & ~(ph64->OptionalHeader.SectionAlignment - 1);
; 1411 : #endif
; 1412 :         ph64->OptionalHeader.SizeOfCode = codesize;
; 1413 :         ph64->OptionalHeader.BaseOfCode = codebase;
; 1414 :         ph64->OptionalHeader.SizeOfImage = sizeimg;

	lea	ecx, DWORD PTR [rsi-1]
	mov	eax, DWORD PTR codesize$1$[rsp]
	jne	SHORT $LN41@pe_set_val

; 1415 :         ph64->OptionalHeader.SizeOfHeaders = sizehdr;
; 1416 :         datadir = &ph64->OptionalHeader.DataDirectory[0];

	mov	DWORD PTR [r13+28], eax
	lea	rdi, QWORD PTR [r13+136]
	mov	eax, DWORD PTR [r13+56]
	add	ecx, eax
	dec	eax
	mov	DWORD PTR [r13+44], r12d
	not	eax
	and	ecx, eax
	mov	eax, DWORD PTR sizehdr$1$[rsp]
	mov	DWORD PTR [r13+80], ecx
	mov	DWORD PTR [r13+84], eax

; 1417 :     } else {

	jmp	SHORT $LN42@pe_set_val
$LN41@pe_set_val:

; 1418 : #endif
; 1419 : #if IMGSIZE_ROUND
; 1420 :         /* round up the SizeOfImage field to page boundary */
; 1421 :         sizeimg = ( sizeimg + ph32->OptionalHeader.SectionAlignment - 1 ) & ~(ph32->OptionalHeader.SectionAlignment - 1);
; 1422 : #endif
; 1423 :         ph32->OptionalHeader.SizeOfCode = codesize;

	mov	DWORD PTR [rbp+28], eax

; 1424 :         ph32->OptionalHeader.SizeOfInitializedData = datasize;
; 1425 :         ph32->OptionalHeader.BaseOfCode = codebase;
; 1426 :         ph32->OptionalHeader.BaseOfData = database;
; 1427 :         ph32->OptionalHeader.SizeOfImage = sizeimg;
; 1428 :         ph32->OptionalHeader.SizeOfHeaders = sizehdr;
; 1429 :         datadir = &ph32->OptionalHeader.DataDirectory[0];

	lea	rdi, QWORD PTR [rbp+120]
	mov	eax, DWORD PTR datasize$1$[rsp]
	mov	DWORD PTR [rbp+32], eax
	mov	eax, DWORD PTR database$1$[rsp]
	mov	DWORD PTR [rbp+48], eax
	mov	eax, DWORD PTR [rbp+56]
	add	ecx, eax
	dec	eax
	mov	DWORD PTR [rbp+44], r12d
	not	eax
	and	ecx, eax
	mov	eax, DWORD PTR sizehdr$1$[rsp]
	mov	DWORD PTR [rbp+80], ecx
	mov	DWORD PTR [rbp+84], eax
$LN42@pe_set_val:

; 1430 : #if AMD64_SUPPORT
; 1431 :     }
; 1432 : #endif
; 1433 : 
; 1434 :     /* set export directory data dir value */
; 1435 :     if ( curr = (struct dsym *)SymSearch( edataname ) ) {

	lea	rcx, OFFSET FLAT:edataname
	call	SymFind
	mov	r12, QWORD PTR [rsp+368]
	test	rax, rax
	je	SHORT $LN43@pe_set_val

; 1436 :         datadir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = curr->e.seginfo->start_offset;

	mov	rcx, QWORD PTR [rax+96]
	mov	edx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdi], edx

; 1437 :         datadir[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = curr->sym.max_offset;

	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rdi+4], eax
$LN43@pe_set_val:

; 1438 :     }
; 1439 : 
; 1440 :     /* set import directory and IAT data dir value */
; 1441 :     if ( curr = (struct dsym *)SymSearch( ".idata$" IMPDIRSUF ) ) {

	lea	rcx, OFFSET FLAT:$SG12267
	call	SymFind
	mov	rsi, rax
	test	rax, rax
	je	SHORT $LN44@pe_set_val

; 1442 :         struct dsym *idata_null;
; 1443 :         struct dsym *idata_iat;
; 1444 :         uint_32 size;
; 1445 :         idata_null = (struct dsym *)SymSearch( ".idata$" IMPNDIRSUF ); /* final NULL import directory entry */

	lea	rcx, OFFSET FLAT:$SG12268
	call	SymFind

; 1446 :         idata_iat = (struct dsym *)SymSearch( ".idata$" IMPIATSUF ); /* IAT entries */

	lea	rcx, OFFSET FLAT:$SG12269
	mov	rbx, rax
	call	SymFind

; 1447 :         size = idata_null->e.seginfo->start_offset + idata_null->sym.max_offset - curr->e.seginfo->start_offset;

	mov	rcx, QWORD PTR [rsi+96]
	mov	r8d, DWORD PTR [rcx+12]
	mov	rcx, QWORD PTR [rbx+96]
	mov	edx, DWORD PTR [rcx+12]
	add	edx, DWORD PTR [rbx+56]

; 1448 :         datadir[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = curr->e.seginfo->start_offset;

	mov	DWORD PTR [rdi+8], r8d
	sub	edx, r8d

; 1449 :         datadir[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = size;

	mov	DWORD PTR [rdi+12], edx

; 1450 :         datadir[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress = idata_iat->e.seginfo->start_offset;

	mov	rcx, QWORD PTR [rax+96]
	mov	edx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdi+96], edx

; 1451 :         datadir[IMAGE_DIRECTORY_ENTRY_IAT].Size = idata_iat->sym.max_offset;

	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rdi+100], eax
$LN44@pe_set_val:

; 1452 :     }
; 1453 : 
; 1454 :     /* set resource directory data dir value */
; 1455 :     if ( curr = (struct dsym *)SymSearch(".rsrc") ) {

	lea	rcx, OFFSET FLAT:$SG12271
	call	SymFind
	mov	rsi, QWORD PTR [rsp+376]
	mov	rbx, QWORD PTR [rsp+384]
	test	rax, rax
	je	SHORT $LN45@pe_set_val

; 1456 :         datadir[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = curr->e.seginfo->start_offset;

	mov	rcx, QWORD PTR [rax+96]
	mov	edx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdi+16], edx

; 1457 :         datadir[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = curr->sym.max_offset;

	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rdi+20], eax
$LN45@pe_set_val:

; 1458 :     }
; 1459 : 
; 1460 :     /* set relocation data dir value */
; 1461 :     if ( curr = (struct dsym *)SymSearch(".reloc") ) {

	lea	rcx, OFFSET FLAT:$SG12273
	call	SymFind
	test	rax, rax
	je	SHORT $LN46@pe_set_val

; 1462 :         datadir[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = curr->e.seginfo->start_offset;

	mov	rcx, QWORD PTR [rax+96]
	mov	edx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdi+40], edx

; 1463 :         datadir[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = curr->sym.max_offset;

	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rdi+44], eax
$LN46@pe_set_val:

; 1464 :     }
; 1465 : 
; 1466 :     /* fixme: TLS entry is not written because there exists a segment .tls, but
; 1467 :      * because a _tls_used symbol is found ( type: IMAGE_THREAD_DIRECTORY )
; 1468 :      */
; 1469 :     if ( curr = (struct dsym *)SymSearch(".tls") ) {

	lea	rcx, OFFSET FLAT:$SG12275
	call	SymFind
	test	rax, rax
	je	SHORT $LN47@pe_set_val

; 1470 :         datadir[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = curr->e.seginfo->start_offset;

	mov	rcx, QWORD PTR [rax+96]
	mov	edx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdi+72], edx

; 1471 :         datadir[IMAGE_DIRECTORY_ENTRY_TLS].Size = curr->sym.max_offset;

	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rdi+76], eax
$LN47@pe_set_val:

; 1472 :     }
; 1473 : 
; 1474 : #if AMD64_SUPPORT
; 1475 :     if ( ModuleInfo.defOfssize == USE64 ) {

	cmp	BYTE PTR ModuleInfo+405, 2
	jne	SHORT $LN62@pe_set_val

; 1476 :         if ( curr = (struct dsym *)SymSearch( ".pdata" ) ) {

	lea	rcx, OFFSET FLAT:$SG12279
	call	SymFind
	test	rax, rax
	je	SHORT $LN50@pe_set_val

; 1477 :             datadir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress = curr->e.seginfo->start_offset;

	mov	rcx, QWORD PTR [rax+96]
	mov	edx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdi+24], edx

; 1478 :             datadir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size = curr->sym.max_offset;

	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rdi+28], eax
$LN50@pe_set_val:

; 1479 :         }
; 1480 :         cp->imagebase64 = GHF( OptionalHeader.ImageBase );

	cmp	BYTE PTR ModuleInfo+405, 2
	jne	SHORT $LN60@pe_set_val
	mov	rax, QWORD PTR [r13+48]
	mov	QWORD PTR [r15+32], rax

; 1484 : 
; 1485 :     /* remove .hdr$1 from FLAT group again */
; 1486 :     //mzhdr->e.seginfo->group = NULL;
; 1487 : }

	add	rsp, 392				; 00000188H
	pop	r15
	pop	r13
	pop	rdi
	pop	rbp
	ret	0
$LN60@pe_set_val:

; 1479 :         }
; 1480 :         cp->imagebase64 = GHF( OptionalHeader.ImageBase );

	mov	eax, DWORD PTR [rbp+52]
	mov	QWORD PTR [r15+32], rax

; 1484 : 
; 1485 :     /* remove .hdr$1 from FLAT group again */
; 1486 :     //mzhdr->e.seginfo->group = NULL;
; 1487 : }

	add	rsp, 392				; 00000188H
	pop	r15
	pop	r13
	pop	rdi
	pop	rbp
	ret	0
$LN62@pe_set_val:

; 1481 :     } else
; 1482 : #endif
; 1483 :         cp->imagebase = GHF( OptionalHeader.ImageBase );

	mov	eax, DWORD PTR [rbp+52]
	mov	DWORD PTR [r15+32], eax

; 1484 : 
; 1485 :     /* remove .hdr$1 from FLAT group again */
; 1486 :     //mzhdr->e.seginfo->group = NULL;
; 1487 : }

	add	rsp, 392				; 00000188H
	pop	r15
	pop	r13
	pop	rdi
	pop	rbp
	ret	0
pe_set_values ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
;	COMDAT pe_set_base_relocs
_TEXT	SEGMENT
reloc$ = 48
pe_set_base_relocs PROC					; COMDAT

; 1126 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1127 :     int cnt1 = 0;
; 1128 :     int cnt2 = 0;
; 1129 :     int ftype;
; 1130 :     uint_32 currpage = -1;
; 1131 :     uint_32 currloc;
; 1132 :     struct dsym *curr;
; 1133 :     struct fixup *fixup;
; 1134 :     struct IMAGE_BASE_RELOCATION *baserel;
; 1135 :     uint_16 *prel;
; 1136 : 
; 1137 :     for ( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r11, QWORD PTR SymTables+32
	xor	edi, edi
	or	r8d, -1					; ffffffffH
	mov	rbx, rcx
	mov	edx, edi
	mov	r9d, edi
	test	r11, r11
	je	SHORT $LN3@pe_set_bas
$LL4@pe_set_bas:

; 1138 :         if ( curr->e.seginfo->segtype == SEGTYPE_HDR )

	mov	r10, QWORD PTR [r11+96]
	cmp	DWORD PTR [r10+72], 6
	je	SHORT $LN2@pe_set_bas

; 1139 :             continue;
; 1140 :         for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rcx, QWORD PTR [r10+40]
	test	rcx, rcx
	je	SHORT $LN2@pe_set_bas
	npad	8
$LL7@pe_set_bas:

; 1141 :             switch ( fixup->type ) {

	mov	eax, DWORD PTR [rcx+24]
	add	eax, -5					; fffffffbH
	cmp	eax, 2
	ja	SHORT $LN5@pe_set_bas

; 1142 :             case FIX_OFF16:
; 1143 :             case FIX_OFF32:
; 1144 : #if AMD64_SUPPORT
; 1145 :             case FIX_OFF64:
; 1146 : #endif
; 1147 :                 currloc = curr->e.seginfo->start_offset + ( fixup->locofs & 0xFFFFF000 );

	mov	eax, DWORD PTR [rcx+20]
	and	eax, -4096				; fffff000H
	add	eax, DWORD PTR [r10+12]

; 1148 :                 if ( currloc != currpage ) {

	cmp	eax, r8d
	je	SHORT $LN21@pe_set_bas

; 1149 :                     currpage = currloc;
; 1150 :                     cnt2++;

	inc	r9d
	mov	r8d, eax

; 1151 :                     if ( cnt1 & 1 )

	test	dl, 1
	je	SHORT $LN21@pe_set_bas

; 1152 :                         cnt1++;

	inc	edx
$LN21@pe_set_bas:

; 1153 :                 }
; 1154 :                 cnt1++;

	inc	edx
$LN5@pe_set_bas:

; 1139 :             continue;
; 1140 :         for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	jne	SHORT $LL7@pe_set_bas
$LN2@pe_set_bas:

; 1127 :     int cnt1 = 0;
; 1128 :     int cnt2 = 0;
; 1129 :     int ftype;
; 1130 :     uint_32 currpage = -1;
; 1131 :     uint_32 currloc;
; 1132 :     struct dsym *curr;
; 1133 :     struct fixup *fixup;
; 1134 :     struct IMAGE_BASE_RELOCATION *baserel;
; 1135 :     uint_16 *prel;
; 1136 : 
; 1137 :     for ( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r11, QWORD PTR [r11+104]
	test	r11, r11
	jne	SHORT $LL4@pe_set_bas
$LN3@pe_set_bas:

; 1155 :                 break;
; 1156 :             //case FIX_RELOFF08: /* needs no base reloc */
; 1157 :             //case FIX_RELOFF16: /* needs no base reloc */
; 1158 :             //case FIX_RELOFF32: /* needs no base reloc */
; 1159 :             //case FIX_OFF08:    /* needs no base reloc */
; 1160 :             //case FIX_OFF32_IMGREL: /* needs no base reloc */
; 1161 :             //case FIX_OFF32_SECREL: /* needs no base reloc */
; 1162 :             //case FIX_SEG:   /* segmented fixups have caused an error already */
; 1163 :             //case FIX_PTR16: /* segmented fixups have caused an error already */
; 1164 :             //case FIX_PTR32: /* segmented fixups have caused an error already */
; 1165 :             //case FIX_HIBYTE: /* is an error */
; 1166 :             default:
; 1167 :                 break;
; 1168 :             }
; 1169 :         }
; 1170 :     }
; 1171 :     reloc->sym.max_offset = cnt2 * sizeof( struct IMAGE_BASE_RELOCATION ) + cnt1 * sizeof( uint_16 );

	lea	eax, DWORD PTR [rdx+r9*4]
	add	eax, eax

; 1172 :     reloc->e.seginfo->CodeBuffer = LclAlloc( reloc->sym.max_offset );

	movsxd	rcx, eax
	mov	DWORD PTR [rbx+56], eax
	call	LclAlloc
	mov	rcx, QWORD PTR [rbx+96]
	mov	QWORD PTR [rcx+16], rax

; 1173 : 
; 1174 :     baserel = (struct IMAGE_BASE_RELOCATION *)reloc->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [rbx+96]
	mov	r8, QWORD PTR [rax+16]

; 1175 :     prel = (uint_16 *)((uint_8 *)baserel + sizeof ( struct IMAGE_BASE_RELOCATION ));
; 1176 : 
; 1177 :     baserel->VirtualAddress = -1;

	mov	DWORD PTR [r8], -1			; ffffffffH
	lea	r9, QWORD PTR [r8+8]

; 1178 :     for ( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r11, QWORD PTR SymTables+32
	test	r11, r11
	je	$LN11@pe_set_bas
	mov	ebx, 4095				; 00000fffH
	npad	2
$LL12@pe_set_bas:

; 1179 :         if ( curr->e.seginfo->segtype == SEGTYPE_HDR )

	mov	rdx, QWORD PTR [r11+96]
	cmp	DWORD PTR [rdx+72], 6
	je	$LN10@pe_set_bas

; 1180 :             continue;
; 1181 :         for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rdx, QWORD PTR [rdx+40]
	test	rdx, rdx
	je	$LN10@pe_set_bas
	npad	5
$LL15@pe_set_bas:

; 1182 :             switch ( fixup->type ) {

	mov	ecx, DWORD PTR [rdx+24]
	sub	ecx, 5
	je	SHORT $LN24@pe_set_bas
	sub	ecx, 1
	je	SHORT $LN25@pe_set_bas
	cmp	ecx, 1
	jne	SHORT $LN13@pe_set_bas

; 1185 : #if AMD64_SUPPORT
; 1186 :             case FIX_OFF64: ftype = IMAGE_REL_BASED_DIR64; break;

	mov	ecx, 10
	jmp	SHORT $LN49@pe_set_bas
$LN25@pe_set_bas:

; 1184 :             case FIX_OFF32: ftype = IMAGE_REL_BASED_HIGHLOW; break;

	mov	ecx, 3
	jmp	SHORT $LN49@pe_set_bas
$LN24@pe_set_bas:

; 1183 :             case FIX_OFF16: ftype = IMAGE_REL_BASED_LOW; break;

	mov	ecx, 2
$LN49@pe_set_bas:

; 1187 : #endif
; 1188 :             default: ftype = 0;
; 1189 :             }
; 1190 :             if ( ftype ) {
; 1191 :                 currloc = curr->e.seginfo->start_offset + ( fixup->locofs & 0xFFFFF000 );

	mov	rax, QWORD PTR [r11+96]
	mov	r10d, DWORD PTR [rdx+20]
	and	r10d, -4096				; fffff000H
	add	r10d, DWORD PTR [rax+12]

; 1192 :                 if ( currloc != baserel->VirtualAddress ) {

	mov	eax, DWORD PTR [r8]
	cmp	r10d, eax
	je	SHORT $LN29@pe_set_bas

; 1193 :                     if ( baserel->VirtualAddress != -1 ) {

	cmp	eax, -1					; ffffffffH
	je	SHORT $LN30@pe_set_bas

; 1194 :                         /* address of relocation header must be DWORD aligned */
; 1195 :                         if ( baserel->SizeOfBlock & 2 ) {

	test	BYTE PTR [r8+4], 2
	je	SHORT $LN31@pe_set_bas

; 1196 :                             *prel++ = 0;

	mov	WORD PTR [r9], di
	add	r9, 2

; 1197 :                             baserel->SizeOfBlock += sizeof( uint_16 );

	add	DWORD PTR [r8+4], 2
$LN31@pe_set_bas:

; 1198 :                         }
; 1199 :                         baserel = (struct IMAGE_BASE_RELOCATION *)prel;

	mov	r8, r9

; 1200 :                         prel += 4; /* 4*2 = sizeof( struct IMAGE_BASE_RELOCATION ) */

	add	r9, 8
$LN30@pe_set_bas:

; 1201 :                     }
; 1202 :                     baserel->VirtualAddress = currloc;

	mov	DWORD PTR [r8], r10d

; 1203 :                     baserel->SizeOfBlock = sizeof( struct IMAGE_BASE_RELOCATION );

	mov	DWORD PTR [r8+4], 8
$LN29@pe_set_bas:

; 1204 :                 }
; 1205 :                 *prel++ = ( fixup->locofs & 0xfff ) | ( ftype << 12 );

	movzx	eax, WORD PTR [rdx+20]
	and	ax, bx
	shl	cx, 12
	or	ax, cx
	mov	WORD PTR [r9], ax
	add	r9, 2

; 1206 :                 baserel->SizeOfBlock += sizeof( uint_16 );

	add	DWORD PTR [r8+4], 2
$LN13@pe_set_bas:

; 1180 :             continue;
; 1181 :         for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rdx, QWORD PTR [rdx+8]
	test	rdx, rdx
	jne	$LL15@pe_set_bas
$LN10@pe_set_bas:

; 1178 :     for ( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r11, QWORD PTR [r11+104]
	test	r11, r11
	jne	$LL12@pe_set_bas
$LN11@pe_set_bas:

; 1207 :             }
; 1208 :         }
; 1209 :     }
; 1210 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
pe_set_base_relocs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
;	COMDAT pe_get_characteristics
_TEXT	SEGMENT
seg$ = 8
pe_get_characteristics PROC				; COMDAT

; 1093 :     uint_32 result = 0;
; 1094 :     //if ( seg->e.seginfo->alignment != MAX_SEGALIGNMENT ) /* ABS not possible */
; 1095 :     //    result |= (uint_32)(seg->e.seginfo->alignment + 1) << 20;
; 1096 : 
; 1097 :     if ( seg->e.seginfo->segtype == SEGTYPE_CODE ) {

	mov	r8, QWORD PTR [rcx+96]
	mov	eax, DWORD PTR [r8+72]
	cmp	eax, 1
	jne	SHORT $LN2@pe_get_cha

; 1098 :         result |= IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ;

	mov	eax, 1610612768				; 60000020H
	jmp	SHORT $LN11@pe_get_cha
$LN2@pe_get_cha:

; 1099 :     } else if ( seg->e.seginfo->segtype == SEGTYPE_BSS ) {

	cmp	eax, 3
	jne	SHORT $LN4@pe_get_cha

; 1100 :         result |= IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	mov	eax, -1073741696			; c0000080H
	jmp	SHORT $LN11@pe_get_cha
$LN4@pe_get_cha:

; 1101 :         /* ish.SizeOfRawData = 0; */
; 1102 :         //ish.PointerToRawData = 0;
; 1103 :     } else if ( seg->e.seginfo->combine == COMB_STACK && seg->e.seginfo->bytes_written == 0 ) {

	movzx	eax, BYTE PTR [r8+108]
	and	al, 7
	cmp	al, 5
	jne	SHORT $LN6@pe_get_cha
	cmp	DWORD PTR [r8+24], 0
	jne	SHORT $LN6@pe_get_cha

; 1104 :         result |= IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	mov	eax, -1073741696			; c0000080H
	jmp	SHORT $LN11@pe_get_cha
$LN6@pe_get_cha:

; 1105 :         //ish.SizeOfRawData = 0;
; 1106 :         //ish.PointerToRawData = 0;
; 1107 :     } else if ( seg->e.seginfo->readonly ) {

	test	BYTE PTR [r8+107], 1
	je	SHORT $LN8@pe_get_cha

; 1108 :         result |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;

	mov	eax, 1073741888				; 40000040H
	jmp	SHORT $LN11@pe_get_cha
$LN8@pe_get_cha:

; 1109 :     } else if ( seg->e.seginfo->clsym && strcmp( seg->e.seginfo->clsym->name, "CONST" ) == 0 ) {

	mov	rax, QWORD PTR [r8+80]
	test	rax, rax
	je	SHORT $LN10@pe_get_cha
	mov	rax, QWORD PTR [rax+8]
	lea	r9, OFFSET FLAT:$SG12108
	sub	r9, rax
	npad	2
$LL14@pe_get_cha:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r9]
	sub	edx, ecx
	jne	SHORT $LN15@pe_get_cha
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL14@pe_get_cha
$LN15@pe_get_cha:

; 1110 :         result |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;

	mov	eax, 1073741888				; 40000040H
	test	edx, edx
	je	SHORT $LN11@pe_get_cha
$LN10@pe_get_cha:

; 1111 :     } else
; 1112 :         result |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	mov	eax, -1073741760			; c0000040H
$LN11@pe_get_cha:

; 1113 : 
; 1114 :     /* manual characteristics set? */
; 1115 :     if ( seg->e.seginfo->characteristics ) {

	movzx	edx, BYTE PTR [r8+105]
	test	dl, dl
	je	SHORT $LN16@pe_get_cha

; 1116 :         result &= 0x1FFFFFF; /* clear the IMAGE_SCN_MEM flags */
; 1117 :         result |= (uint_32)(seg->e.seginfo->characteristics & 0xFE) << 24;

	movzx	ecx, dl
	shl	ecx, 24
	xor	ecx, eax
	movzx	eax, dl
	shl	eax, 24
	and	ecx, 33554431				; 01ffffffH
	xor	eax, ecx
$LN16@pe_get_cha:

; 1118 :     }
; 1119 :     return( result );
; 1120 : }

	ret	0
pe_get_characteristics ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
;	COMDAT get_bit
_TEXT	SEGMENT
value$ = 8
get_bit	PROC						; COMDAT

; 1082 :     int rc = -1;

	or	eax, -1

; 1083 :     while( value ) {

	test	ecx, ecx
	je	SHORT $LN9@get_bit
$LL2@get_bit:

; 1084 :         value = (value >> 1);
; 1085 :         rc++;

	inc	eax
	sar	ecx, 1
	jne	SHORT $LL2@get_bit
$LN9@get_bit:

; 1086 :     }
; 1087 :     return( rc );
; 1088 : }

	ret	0
get_bit	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
;	COMDAT pe_emit_import_data
_TEXT	SEGMENT
pe_emit_import_data PROC				; COMDAT

; 991  : {

	mov	rax, rsp
	push	r13
	sub	rsp, 96					; 00000060H
	mov	QWORD PTR [rax+16], rbp

; 992  :     struct dll_desc *p;
; 993  :     int type = 0;
; 994  : #if AMD64_SUPPORT
; 995  :     int ptrtype = ( ModuleInfo.defOfssize == USE64 ? T_QWORD : T_DWORD );
; 996  :     char *align = ( ModuleInfo.defOfssize == USE64 ? "ALIGN(8)" : "ALIGN(4)" );
; 997  : #else
; 998  :     int ptrtype = T_DWORD;
; 999  :     char *align = "DWORD";
; 1000 : #endif
; 1001 : 
; 1002 :     DebugMsg(("pe_emit_import_data enter\n" ));
; 1003 :     for ( p = ModuleInfo.g.DllQueue; p; p = p->next ) {

	lea	r13, OFFSET FLAT:idataattr
	mov	QWORD PTR [rax-16], rdi
	xor	ebp, ebp
	cmp	BYTE PTR ModuleInfo+405, 2
	mov	ecx, 213				; 000000d5H
	mov	rdi, QWORD PTR ModuleInfo+80
	mov	QWORD PTR [rax-24], r12
	lea	r12, OFFSET FLAT:$SG12049
	mov	QWORD PTR [rax-40], r15
	mov	r15d, 209				; 000000d1H
	cmove	r15d, ecx
	lea	rcx, OFFSET FLAT:$SG12048
	cmove	r12, rcx
	test	rdi, rdi
	je	$LN3@pe_emit_im
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax-32], r14
$LL4@pe_emit_im:

; 1004 :         if ( p->cnt ) {

	cmp	DWORD PTR [rdi+8], 0
	je	$LN2@pe_emit_im

; 1005 :             struct dsym *curr;
; 1006 :             char *pdot;
; 1007 :             if ( !type ) {

	test	ebp, ebp
	jne	SHORT $LN15@pe_emit_im

; 1008 :                 type = 1;
; 1009 :                 AddLineQueueX( "@LPPROC %r %r %r", T_TYPEDEF, T_PTR, T_PROC );

	mov	edx, 420				; 000001a4H
	lea	rcx, OFFSET FLAT:$SG12052
	mov	r8d, 258				; 00000102H
	mov	ebp, 1
	lea	r9d, QWORD PTR [rdx+8]
	call	AddLineQueueX

; 1010 :                 AddLineQueueX( "%r DOTNAME", T_OPTION );

	mov	edx, 447				; 000001bfH
	lea	rcx, OFFSET FLAT:$SG12053
	call	AddLineQueueX
$LN15@pe_emit_im:

; 1011 :             }
; 1012 : 
; 1013 :             /* avoid . in IDs */
; 1014 :             if ( pdot = strchr( p->name, '.') )

	lea	rsi, QWORD PTR [rdi+12]
	mov	edx, 46					; 0000002eH
	mov	rcx, rsi
	call	strchr
	mov	r14, rax
	test	rax, rax
	je	SHORT $LN16@pe_emit_im

; 1015 :                 *pdot = '_';

	mov	BYTE PTR [rax], 95			; 0000005fH
$LN16@pe_emit_im:

; 1016 : 
; 1017 :             /* import directory entry */
; 1018 :             AddLineQueueX( "%s" IMPDIRSUF " %r %r %s", idataname, T_SEGMENT, T_DWORD, idataattr );

	mov	r9d, 209				; 000000d1H
	mov	QWORD PTR [rsp+32], r13
	mov	r8d, 436				; 000001b4H
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12055
	call	AddLineQueueX

; 1019 :             AddLineQueueX( "DD %r @%s_ilt, 0, 0, %r @%s_name, %r @%s_iat", T_IMAGEREL, p->name, T_IMAGEREL, p->name, T_IMAGEREL, p->name );

	mov	r9d, 233				; 000000e9H
	mov	QWORD PTR [rsp+48], rsi
	mov	edx, r9d
	mov	DWORD PTR [rsp+40], 233			; 000000e9H
	mov	r8, rsi
	mov	QWORD PTR [rsp+32], rsi
	lea	rcx, OFFSET FLAT:$SG12056
	call	AddLineQueueX

; 1020 :             AddLineQueueX( "%s" IMPDIRSUF " %r", idataname, T_ENDS );

	mov	r8d, 437				; 000001b5H
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12057
	call	AddLineQueueX

; 1021 : 
; 1022 :             /* emit ILT */
; 1023 :             AddLineQueueX( "%s" IMPILTSUF " %r %s %s", idataname, T_SEGMENT, align, idataattr );

	mov	r9, r12
	mov	QWORD PTR [rsp+32], r13
	mov	r8d, 436				; 000001b4H
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12058
	call	AddLineQueueX

; 1024 :             AddLineQueueX( "@%s_ilt label %r", p->name, ptrtype );

	mov	r8d, r15d
	lea	rcx, OFFSET FLAT:$SG12059
	mov	rdx, rsi
	call	AddLineQueueX

; 1025 :             for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+16
	test	rbx, rbx
	je	SHORT $LN6@pe_emit_im
$LL7@pe_emit_im:

; 1026 :                 if ( curr->sym.iat_used && curr->sym.dll == p ) {

	test	BYTE PTR [rbx+40], 8
	je	SHORT $LN5@pe_emit_im
	cmp	QWORD PTR [rbx+56], rdi
	jne	SHORT $LN5@pe_emit_im

; 1027 :                     AddLineQueueX( "@LPPROC %r @%s_name", T_IMAGEREL, curr->sym.name );

	mov	r8, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG12061
	mov	edx, 233				; 000000e9H
	call	AddLineQueueX
$LN5@pe_emit_im:

; 1025 :             for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	SHORT $LL7@pe_emit_im
$LN6@pe_emit_im:

; 1028 :                 }
; 1029 :             }
; 1030 :             /* ILT termination entry */
; 1031 :             AddLineQueueX( "@LPPROC 0" );

	lea	rcx, OFFSET FLAT:$SG12062
	call	AddLineQueueX

; 1032 :             AddLineQueueX( "%s" IMPILTSUF " %r", idataname, T_ENDS );

	mov	r8d, 437				; 000001b5H
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12063
	call	AddLineQueueX

; 1033 : 
; 1034 :             /* emit IAT */
; 1035 :             AddLineQueueX( "%s" IMPIATSUF " %r %s %s", idataname, T_SEGMENT, align, idataattr );

	mov	r9, r12
	mov	QWORD PTR [rsp+32], r13
	mov	r8d, 436				; 000001b4H
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12064
	call	AddLineQueueX

; 1036 :             AddLineQueueX( "@%s_iat label %r", p->name, ptrtype );

	mov	r8d, r15d
	lea	rcx, OFFSET FLAT:$SG12065
	mov	rdx, rsi
	call	AddLineQueueX

; 1037 : 
; 1038 :             for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+16
	test	rbx, rbx
	je	SHORT $LN9@pe_emit_im
$LL10@pe_emit_im:

; 1039 :                 if ( curr->sym.iat_used && curr->sym.dll == p ) {

	test	BYTE PTR [rbx+40], 8
	je	SHORT $LN8@pe_emit_im
	cmp	QWORD PTR [rbx+56], rdi
	jne	SHORT $LN8@pe_emit_im

; 1040 :                     Mangle( &curr->sym, StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, rbx
	call	Mangle

; 1041 :                     AddLineQueueX( "%s%s @LPPROC %r @%s_name", ModuleInfo.g.imp_prefix, StringBufferEnd, T_IMAGEREL, curr->sym.name );

	mov	rax, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG12067
	mov	r8, QWORD PTR ModuleInfo+488
	mov	r9d, 233				; 000000e9H
	mov	rdx, QWORD PTR ModuleInfo+88
	mov	QWORD PTR [rsp+32], rax
	call	AddLineQueueX
$LN8@pe_emit_im:

; 1037 : 
; 1038 :             for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	SHORT $LL10@pe_emit_im
$LN9@pe_emit_im:

; 1042 :                 }
; 1043 :             }
; 1044 :             /* IAT termination entry */
; 1045 :             AddLineQueueX( "@LPPROC 0" );

	lea	rcx, OFFSET FLAT:$SG12068
	call	AddLineQueueX

; 1046 :             AddLineQueueX( "%s" IMPIATSUF " %r", idataname, T_ENDS );

	mov	r8d, 437				; 000001b5H
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12069
	call	AddLineQueueX

; 1047 : 
; 1048 :             /* emit name table */
; 1049 :             AddLineQueueX( "%s" IMPSTRSUF " %r %r %s", idataname, T_SEGMENT, T_WORD, idataattr );

	mov	r9d, 207				; 000000cfH
	mov	QWORD PTR [rsp+32], r13
	mov	r8d, 436				; 000001b4H
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12070
	call	AddLineQueueX

; 1050 :             for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+16
	test	rbx, rbx
	je	SHORT $LN12@pe_emit_im
$LL13@pe_emit_im:

; 1051 :                 if ( curr->sym.iat_used && curr->sym.dll == p ) {

	test	BYTE PTR [rbx+40], 8
	je	SHORT $LN11@pe_emit_im
	cmp	QWORD PTR [rbx+56], rdi
	jne	SHORT $LN11@pe_emit_im

; 1052 :                     AddLineQueueX( "@%s_name dw 0", curr->sym.name );

	mov	rdx, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG12072
	call	AddLineQueueX

; 1053 :                     AddLineQueueX( "db '%s',0", curr->sym.name );

	mov	rdx, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG12073
	call	AddLineQueueX

; 1054 :                     AddLineQueue( "even" );

	lea	rcx, OFFSET FLAT:$SG12074
	call	AddLineQueue
$LN11@pe_emit_im:

; 1050 :             for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	SHORT $LL13@pe_emit_im
$LN12@pe_emit_im:

; 1055 :                 }
; 1056 :             }
; 1057 :             /* dll name table entry */
; 1058 :             if ( pdot ) {
; 1059 :                 *pdot = NULLC;
; 1060 :                 AddLineQueueX( "@%s_%s_name db '%s.%s',0", p->name, pdot+1, p->name, pdot+1 );

	mov	rdx, rsi
	test	r14, r14
	je	SHORT $LN20@pe_emit_im
	lea	r8, QWORD PTR [r14+1]
	mov	BYTE PTR [r14], 0
	mov	r9, rsi
	mov	QWORD PTR [rsp+32], r8
	lea	rcx, OFFSET FLAT:$SG12077
	call	AddLineQueueX

; 1061 :                 *pdot = '.';  /* restore '.' in dll name */

	mov	BYTE PTR [r14], 46			; 0000002eH

; 1062 :             } else

	jmp	SHORT $LN21@pe_emit_im
$LN20@pe_emit_im:

; 1063 :                 AddLineQueueX( "@%s_name db '%s',0", p->name, p->name );

	mov	r8, rsi
	lea	rcx, OFFSET FLAT:$SG12078
	call	AddLineQueueX
$LN21@pe_emit_im:

; 1064 : 
; 1065 :             AddLineQueue( "even" );

	lea	rcx, OFFSET FLAT:$SG12079
	call	AddLineQueue

; 1066 :             AddLineQueueX( "%s" IMPSTRSUF " %r", idataname, T_ENDS );

	mov	r8d, 437				; 000001b5H
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12080
	call	AddLineQueueX
$LN2@pe_emit_im:

; 992  :     struct dll_desc *p;
; 993  :     int type = 0;
; 994  : #if AMD64_SUPPORT
; 995  :     int ptrtype = ( ModuleInfo.defOfssize == USE64 ? T_QWORD : T_DWORD );
; 996  :     char *align = ( ModuleInfo.defOfssize == USE64 ? "ALIGN(8)" : "ALIGN(4)" );
; 997  : #else
; 998  :     int ptrtype = T_DWORD;
; 999  :     char *align = "DWORD";
; 1000 : #endif
; 1001 : 
; 1002 :     DebugMsg(("pe_emit_import_data enter\n" ));
; 1003 :     for ( p = ModuleInfo.g.DllQueue; p; p = p->next ) {

	mov	rdi, QWORD PTR [rdi]
	test	rdi, rdi
	jne	$LL4@pe_emit_im
	mov	r14, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [rsp+112]
$LN3@pe_emit_im:

; 1067 : 
; 1068 :         }
; 1069 :     }
; 1070 :     if ( is_linequeue_populated() ) {

	cmp	QWORD PTR ModuleInfo+184, 0
	mov	r15, QWORD PTR [rsp+64]
	mov	r12, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+120]
	je	SHORT $LN22@pe_emit_im

; 1071 :         /* import directory NULL entry */
; 1072 :         AddLineQueueX( "%s" IMPNDIRSUF " %r %r %s", idataname, T_SEGMENT, T_DWORD, idataattr );

	mov	r9d, 209				; 000000d1H
	mov	QWORD PTR [rsp+32], r13
	mov	r8d, 436				; 000001b4H
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12082
	call	AddLineQueueX

; 1073 :         AddLineQueueX( "DD 0, 0, 0, 0, 0" );

	lea	rcx, OFFSET FLAT:$SG12083
	call	AddLineQueueX

; 1074 :         AddLineQueueX( "%s" IMPNDIRSUF " %r", idataname, T_ENDS );

	mov	r8d, 437				; 000001b5H
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12084
	call	AddLineQueueX

; 1076 :     }
; 1077 : }

	add	rsp, 96					; 00000060H
	pop	r13

; 1075 :         RunLineQueue();

	jmp	RunLineQueue
$LN22@pe_emit_im:

; 1076 :     }
; 1077 : }

	add	rsp, 96					; 00000060H
	pop	r13
	ret	0
pe_emit_import_data ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
;	COMDAT pe_emit_export_data
_TEXT	SEGMENT
timedate$ = 32
pe_emit_export_data PROC				; COMDAT

; 899  : {

	push	rbp
	push	r14
	push	r15
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+112]

; 900  :     struct dsym *curr;
; 901  :     int_32 timedate;
; 902  :     int cnt;
; 903  :     int i;
; 904  :     char *name;
; 905  :     char *fname;
; 906  :     struct expitem *pitems;
; 907  :     struct expitem *pexp;
; 908  : 
; 909  :     DebugMsg(("pe_emit_export_data enter\n" ));
; 910  :     for( curr = SymTables[TAB_PROC].head, cnt = 0; curr; curr = curr->nextproc ) {

	mov	rcx, QWORD PTR SymTables+64
	mov	QWORD PTR [rbp+40], rbx
	xor	ebx, ebx
	mov	QWORD PTR [rbp+48], rsi
	mov	QWORD PTR [rbp+56], rdi
	mov	edi, ebx
	test	rcx, rcx
	je	$LN24@pe_emit_ex
	npad	1
$LL4@pe_emit_ex:

; 911  :         if( curr->e.procinfo->isexport )

	mov	rax, QWORD PTR [rcx+96]
	test	BYTE PTR [rax+84], 4
	je	SHORT $LN2@pe_emit_ex

; 912  :             cnt++;

	inc	edi
$LN2@pe_emit_ex:

; 900  :     struct dsym *curr;
; 901  :     int_32 timedate;
; 902  :     int cnt;
; 903  :     int i;
; 904  :     char *name;
; 905  :     char *fname;
; 906  :     struct expitem *pitems;
; 907  :     struct expitem *pexp;
; 908  : 
; 909  :     DebugMsg(("pe_emit_export_data enter\n" ));
; 910  :     for( curr = SymTables[TAB_PROC].head, cnt = 0; curr; curr = curr->nextproc ) {

	mov	rcx, QWORD PTR [rcx+112]
	test	rcx, rcx
	jne	SHORT $LL4@pe_emit_ex

; 913  :     }
; 914  :     if ( cnt ) {

	test	edi, edi
	je	$LN24@pe_emit_ex

; 915  :         name = ModuleInfo.name;
; 916  :         AddLineQueueX( "%r DOTNAME", T_OPTION );

	mov	edx, 447				; 000001bfH
	lea	rcx, OFFSET FLAT:$SG12007
	call	AddLineQueueX

; 917  :         /* create .edata segment */
; 918  :         AddLineQueueX( "%s %r %r %s", edataname, T_SEGMENT, T_DWORD, edataattr );

	lea	rax, OFFSET FLAT:edataattr
	mov	r9d, 209				; 000000d1H
	mov	r8d, 436				; 000001b4H
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, OFFSET FLAT:edataname
	lea	rcx, OFFSET FLAT:$SG12008
	call	AddLineQueueX

; 919  : #if 0 //def __UNIX__
; 920  :         time( &timedate );
; 921  : #else
; 922  :         time( (time_t *)&timedate );

	lea	rcx, QWORD PTR timedate$[rbp]
	call	_time64

; 923  : #endif
; 924  :         /* create export directory: Characteristics, Timedate, MajMin, Name, Base, ... */
; 925  :         AddLineQueueX( "DD 0, 0%xh, 0, %r @%s_name, %u, %u, %u, %r @%s_func, %r @%s_names, %r @%s_nameord",

	mov	edx, DWORD PTR timedate$[rbp]
	lea	r15, OFFSET FLAT:ModuleInfo+512
	mov	QWORD PTR [rsp+96], r15
	lea	rcx, OFFSET FLAT:$SG12009
	mov	DWORD PTR [rsp+88], 233			; 000000e9H
	mov	r9, r15
	mov	QWORD PTR [rsp+80], r15
	mov	r8d, 233				; 000000e9H
	mov	DWORD PTR [rsp+72], 233			; 000000e9H
	mov	QWORD PTR [rsp+64], r15
	mov	DWORD PTR [rsp+56], 233			; 000000e9H
	mov	DWORD PTR [rsp+48], edi
	mov	DWORD PTR [rsp+40], edi
	mov	DWORD PTR [rsp+32], 1
	call	AddLineQueueX

; 926  :                       timedate, T_IMAGEREL, name, 1, cnt, cnt, T_IMAGEREL, name, T_IMAGEREL, name, T_IMAGEREL, name );
; 927  : 
; 928  :         /* the name pointer table must be in ascending order!
; 929  :          * so we have to fill an array of exports and sort it.
; 930  :          */
; 931  :         pitems = (struct expitem *)myalloca( cnt * sizeof( struct expitem ) );

	movsxd	rdi, edi
	mov	rax, rdi
	shl	rax, 4
	lea	rcx, QWORD PTR [rax+15]
	cmp	rcx, rax
	ja	SHORT $LN67@pe_emit_ex
	mov	rcx, 1152921504606846960		; 0ffffffffffffff0H
$LN67@pe_emit_ex:
	and	rcx, -16
	mov	rax, rcx
	call	__chkstk
	sub	rsp, rcx

; 932  :         for( curr = SymTables[TAB_PROC].head, pexp = pitems, i = 0; curr; curr = curr->nextproc ) {

	mov	rcx, QWORD PTR SymTables+64
	lea	r14, QWORD PTR [rsp+112]
	mov	rdx, r14
	test	rcx, rcx
	je	SHORT $LN6@pe_emit_ex
	npad	8
$LL7@pe_emit_ex:

; 933  :             if( curr->e.procinfo->isexport ) {

	mov	rax, QWORD PTR [rcx+96]
	test	BYTE PTR [rax+84], 4
	je	SHORT $LN5@pe_emit_ex

; 934  :                 pexp->name = curr->sym.name;

	mov	rax, QWORD PTR [rcx+8]

; 935  :                 pexp->idx  = i++;

	mov	DWORD PTR [rdx+8], ebx
	inc	ebx
	mov	QWORD PTR [rdx], rax

; 936  :                 pexp++;

	add	rdx, 16
$LN5@pe_emit_ex:

; 932  :         for( curr = SymTables[TAB_PROC].head, pexp = pitems, i = 0; curr; curr = curr->nextproc ) {

	mov	rcx, QWORD PTR [rcx+112]
	test	rcx, rcx
	jne	SHORT $LL7@pe_emit_ex
$LN6@pe_emit_ex:

; 937  :             }
; 938  :         }
; 939  :         qsort( pitems, cnt, sizeof( struct expitem ), compare_exp );

	lea	r9, OFFSET FLAT:compare_exp
	mov	r8d, 16
	mov	rdx, rdi
	mov	rcx, r14
	call	qsort

; 940  : 
; 941  :         /* emit export address table.
; 942  :          * would be possible to just use the array of sorted names,
; 943  :          * but we want to emit the EAT being sorted by address.
; 944  :          */
; 945  :         AddLineQueueX( "@%s_func %r DWORD", name, T_LABEL );

	mov	r8d, 431				; 000001afH
	lea	rcx, OFFSET FLAT:$SG12011
	mov	rdx, r15
	call	AddLineQueueX

; 946  :         for( curr = SymTables[TAB_PROC].head; curr; curr = curr->nextproc ) {

	mov	rbx, QWORD PTR SymTables+64
	test	rbx, rbx
	je	SHORT $LN9@pe_emit_ex
	npad	4
$LL10@pe_emit_ex:

; 947  :             if( curr->e.procinfo->isexport )

	mov	rax, QWORD PTR [rbx+96]
	test	BYTE PTR [rax+84], 4
	je	SHORT $LN8@pe_emit_ex

; 948  :                 AddLineQueueX( "DD %r %s", T_IMAGEREL, curr->sym.name );

	mov	r8, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG12013
	mov	edx, 233				; 000000e9H
	call	AddLineQueueX
$LN8@pe_emit_ex:

; 946  :         for( curr = SymTables[TAB_PROC].head; curr; curr = curr->nextproc ) {

	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL10@pe_emit_ex
$LN9@pe_emit_ex:

; 949  :         }
; 950  : 
; 951  :         /* emit the name pointer table */
; 952  :         AddLineQueueX( "@%s_names %r DWORD", name, T_LABEL );

	mov	r8d, 431				; 000001afH
	lea	rcx, OFFSET FLAT:$SG12014
	mov	rdx, r15
	call	AddLineQueueX

; 953  :         for ( i = 0; i < cnt; i++ )

	test	rdi, rdi
	jle	SHORT $LN12@pe_emit_ex

; 949  :         }
; 950  : 
; 951  :         /* emit the name pointer table */
; 952  :         AddLineQueueX( "@%s_names %r DWORD", name, T_LABEL );

	mov	rbx, r14
	mov	rsi, rdi
	npad	8
$LL13@pe_emit_ex:

; 954  :             AddLineQueueX( "DD %r @%s", T_IMAGEREL, (pitems+i)->name );

	mov	r8, QWORD PTR [rbx]
	lea	rcx, OFFSET FLAT:$SG12015
	mov	edx, 233				; 000000e9H
	call	AddLineQueueX
	lea	rbx, QWORD PTR [rbx+16]
	sub	rsi, 1
	jne	SHORT $LL13@pe_emit_ex
$LN12@pe_emit_ex:

; 955  : 
; 956  :         /* ordinal table. each ordinal is an index into the export address table */
; 957  :         AddLineQueueX( "@%s_nameord %r WORD", name, T_LABEL );

	mov	r8d, 431				; 000001afH
	lea	rcx, OFFSET FLAT:$SG12016
	mov	rdx, r15
	call	AddLineQueueX

; 958  :         for( i = 0; i < cnt; i++ ) {

	test	rdi, rdi
	jle	SHORT $LN15@pe_emit_ex

; 955  : 
; 956  :         /* ordinal table. each ordinal is an index into the export address table */
; 957  :         AddLineQueueX( "@%s_nameord %r WORD", name, T_LABEL );

	lea	rbx, QWORD PTR [r14+8]
	npad	4
$LL16@pe_emit_ex:

; 959  :             AddLineQueueX( "DW %u", (pitems+i)->idx );

	mov	edx, DWORD PTR [rbx]
	lea	rcx, OFFSET FLAT:$SG12017
	call	AddLineQueueX
	lea	rbx, QWORD PTR [rbx+16]
	sub	rdi, 1
	jne	SHORT $LL16@pe_emit_ex
$LN15@pe_emit_ex:

; 960  :         }
; 961  :         /* v2.10: name+ext of dll */
; 962  :         //AddLineQueueX( "@%s_name DB '%s',0", name, name );
; 963  :         for ( fname = CurrFName[OBJ] + strlen( CurrFName[OBJ] ); fname > CurrFName[OBJ]; fname-- )

	mov	rcx, QWORD PTR ModuleInfo+136
	or	r8, -1
$LL66@pe_emit_ex:
	inc	r8
	cmp	BYTE PTR [rcx+r8], 0
	jne	SHORT $LL66@pe_emit_ex
	add	r8, rcx
	cmp	r8, rcx
	jbe	SHORT $LN42@pe_emit_ex
	mov	rdx, 35184372090881			; 0000200000000801H
	npad	1
$LL19@pe_emit_ex:
	movzx	eax, BYTE PTR [r8]
	sub	al, 47					; 0000002fH
	cmp	al, 45					; 0000002dH
	ja	SHORT $LN64@pe_emit_ex
	movsx	rax, al
	bt	rdx, rax
	jb	SHORT $LN42@pe_emit_ex
$LN64@pe_emit_ex:
	dec	r8
	cmp	r8, rcx
	ja	SHORT $LL19@pe_emit_ex
$LN42@pe_emit_ex:

; 964  :             if ( *fname == '/' || *fname == '\\' || *fname == ':' )
; 965  :                 break;
; 966  :         AddLineQueueX( "@%s_name DB '%s',0", name, fname );

	mov	rdx, r15
	lea	rcx, OFFSET FLAT:$SG12020
	call	AddLineQueueX

; 967  : 
; 968  :         for( curr = SymTables[TAB_PROC].head; curr; curr = curr->nextproc ) {

	mov	rbx, QWORD PTR SymTables+64
	test	rbx, rbx
	je	SHORT $LN21@pe_emit_ex
	npad	9
$LL22@pe_emit_ex:

; 969  :             if( curr->e.procinfo->isexport ) {

	mov	rax, QWORD PTR [rbx+96]
	test	BYTE PTR [rax+84], 4
	je	SHORT $LN20@pe_emit_ex

; 970  :                 Mangle( &curr->sym, StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, rbx
	call	Mangle

; 971  :                 AddLineQueueX( "@%s DB '%s',0", curr->sym.name, Options.no_export_decoration ? curr->sym.name : StringBufferEnd );

	cmp	BYTE PTR Options+119, 0
	je	SHORT $LN31@pe_emit_ex
	mov	r8, QWORD PTR [rbx+8]
	jmp	SHORT $LN32@pe_emit_ex
$LN31@pe_emit_ex:
	mov	r8, QWORD PTR ModuleInfo+488
$LN32@pe_emit_ex:
	mov	rdx, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG12022
	call	AddLineQueueX
$LN20@pe_emit_ex:

; 967  : 
; 968  :         for( curr = SymTables[TAB_PROC].head; curr; curr = curr->nextproc ) {

	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL22@pe_emit_ex
$LN21@pe_emit_ex:

; 972  :             }
; 973  :         }
; 974  :         /* exit .edata segment */
; 975  :         AddLineQueueX( "%s %r", edataname, T_ENDS );

	mov	r8d, 437				; 000001b5H
	lea	rdx, OFFSET FLAT:edataname
	lea	rcx, OFFSET FLAT:$SG12023
	call	AddLineQueueX

; 976  :         RunLineQueue();

	call	RunLineQueue
$LN24@pe_emit_ex:

; 977  :     }
; 978  : }

	mov	rbx, QWORD PTR [rbp+40]
	mov	rsi, QWORD PTR [rbp+48]
	mov	rdi, QWORD PTR [rbp+56]
	mov	rsp, rbp
	pop	r15
	pop	r14
	pop	rbp
	ret	0
pe_emit_export_data ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
p1$ = 8
p2$ = 16
compare_exp PROC

; 894  :     return( strcmp( ((struct expitem *)p1)->name, ((struct expitem *)p2)->name ) );

	mov	rax, QWORD PTR [rcx]
	mov	r8, QWORD PTR [rdx]
	sub	r8, rax
	npad	7
$LL3@compare_ex:
	movzx	ecx, BYTE PTR [rax]
	cmp	cl, BYTE PTR [rax+r8]
	jne	SHORT $LN5@compare_ex
	inc	rax
	test	cl, cl
	jne	SHORT $LL3@compare_ex
	xor	eax, eax

; 895  : }

	ret	0
$LN5@compare_ex:

; 894  :     return( strcmp( ((struct expitem *)p1)->name, ((struct expitem *)p2)->name ) );

	sbb	eax, eax
	or	eax, 1

; 895  : }

	ret	0
compare_exp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
;	COMDAT pe_create_section_table
_TEXT	SEGMENT
pe_create_section_table PROC				; COMDAT

; 804  : {

	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 805  :     int i;
; 806  :     struct dsym *objtab;
; 807  :     struct dsym *curr;
; 808  :     int bCreated = FALSE;

	xor	edi, edi
	mov	ebx, edi

; 809  :     int objs;
; 810  : 
; 811  :     DebugMsg(("pe_create_section table enter\n" ));
; 812  :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, ebx
	jne	$LN27@pe_create_

; 813  :         objtab = ( struct dsym *)SymSearch( hdrname "3" );

	mov	QWORD PTR [rsp+64], rbp
	lea	rcx, OFFSET FLAT:$SG11936
	mov	QWORD PTR [rsp+72], rsi
	call	SymFind

; 814  :         if ( !objtab ) {

	lea	esi, QWORD PTR [rdi+1]
	mov	rbp, rax
	test	rax, rax
	jne	SHORT $LN12@pe_create_

; 815  :             bCreated = TRUE;
; 816  :             objtab = (struct dsym *)CreateIntSegment( hdrname "3", "HDR", 2, ModuleInfo.defOfssize, TRUE );

	movzx	r9d, BYTE PTR ModuleInfo+405
	lea	rdx, OFFSET FLAT:$SG11938
	mov	ebx, esi
	lea	rcx, OFFSET FLAT:$SG11939
	mov	r8b, 2
	mov	BYTE PTR [rsp+32], bl
	call	CreateIntSegment
	mov	rbp, rax

; 817  :             objtab->e.seginfo->group = &ModuleInfo.flat_grp->sym;

	mov	rcx, QWORD PTR [rax+96]
	mov	rax, QWORD PTR ModuleInfo+440
	mov	QWORD PTR [rcx], rax

; 818  :             objtab->e.seginfo->combine = COMB_ADDOFF;  /* PUBLIC */

	mov	rcx, QWORD PTR [rbp+96]
	movzx	eax, BYTE PTR [rcx+108]
	and	al, 250					; 000000faH
	or	al, 2
	mov	BYTE PTR [rcx+108], al
$LN12@pe_create_:

; 819  :         }
; 820  :         objtab->e.seginfo->segtype = SEGTYPE_HDR;

	mov	rax, QWORD PTR [rbp+96]
	mov	DWORD PTR [rax+72], 6

; 821  : 
; 822  :         if ( !bCreated )

	test	ebx, ebx
	je	$LN48@pe_create_

; 823  :             return;
; 824  : 
; 825  :         /* before objects can be counted, the segment types
; 826  :          * SEGTYPE_CDATA ( for readonly segments ) &
; 827  :          * SEGTYPE_RSRC ( for resource segments )
; 828  :          * SEGTYPE_RELOC ( for relocations )
; 829  :          * must be set  - also, init lname_idx field
; 830  :          */
; 831  :         for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r10, QWORD PTR SymTables+32
	test	r10, r10
	je	$LN3@pe_create_
	npad	14
$LL4@pe_create_:

; 832  :             curr->e.seginfo->lname_idx = SEGTYPE_ERROR; /* use the highest index possible */

	mov	rax, QWORD PTR [r10+96]
	mov	DWORD PTR [rax+76], 10

; 833  :             if ( curr->e.seginfo->segtype == SEGTYPE_DATA ) {

	mov	r9, QWORD PTR [r10+96]
	mov	eax, DWORD PTR [r9+72]
	cmp	eax, 2
	jne	SHORT $LN14@pe_create_

; 834  :                 if ( curr->e.seginfo->readonly || curr->e.seginfo->characteristics == CHAR_READONLY )

	test	BYTE PTR [r9+107], sil
	jne	SHORT $LN18@pe_create_
	cmp	BYTE PTR [r9+105], 64			; 00000040H
	je	SHORT $LN18@pe_create_

; 835  :                     curr->e.seginfo->segtype = SEGTYPE_CDATA;
; 836  :                 else if ( curr->e.seginfo->clsym && strcmp( curr->e.seginfo->clsym->name, "CONST" ) == 0 )

	mov	rax, QWORD PTR [r9+80]
	test	rax, rax
	je	$LN2@pe_create_
	mov	rax, QWORD PTR [rax+8]
	lea	r8, OFFSET FLAT:$SG11947
	sub	r8, rax
$LL45@pe_create_:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN46@pe_create_
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL45@pe_create_
$LN46@pe_create_:
	test	edx, edx
	jne	SHORT $LN2@pe_create_
$LN18@pe_create_:

; 837  :                     curr->e.seginfo->segtype = SEGTYPE_CDATA;

	mov	DWORD PTR [r9+72], 7
	jmp	SHORT $LN2@pe_create_
$LN14@pe_create_:

; 838  :             } else if ( curr->e.seginfo->segtype == SEGTYPE_UNDEF ) {

	test	eax, eax
	jne	SHORT $LN2@pe_create_

; 839  :                 if ( ( memcmp( curr->sym.name, ".rsrc", 5 ) == 0 ) &&

	mov	rcx, QWORD PTR [r10+8]
	mov	eax, DWORD PTR [rcx]
	cmp	eax, DWORD PTR $SG11951
	jne	SHORT $LN21@pe_create_
	movzx	eax, BYTE PTR [rcx+4]
	cmp	al, BYTE PTR $SG11951+4
	jne	SHORT $LN21@pe_create_
	movzx	eax, BYTE PTR [rcx+5]
	test	al, al
	je	SHORT $LN23@pe_create_
	cmp	al, 36					; 00000024H
	jne	SHORT $LN21@pe_create_
$LN23@pe_create_:

; 840  :                     ( *(curr->sym.name+5) == NULLC || *(curr->sym.name+5) == '$' ) )
; 841  :                     curr->e.seginfo->segtype = SEGTYPE_RSRC;

	mov	DWORD PTR [r9+72], 9
	jmp	SHORT $LN2@pe_create_
$LN21@pe_create_:

; 842  :                 else if ( strcmp( curr->sym.name, ".reloc" ) == 0 )

	lea	r8, OFFSET FLAT:$SG11954
	sub	r8, rcx
	npad	1
$LL43@pe_create_:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+r8]
	sub	edx, eax
	jne	SHORT $LN44@pe_create_
	inc	rcx
	test	eax, eax
	jne	SHORT $LL43@pe_create_
$LN44@pe_create_:
	test	edx, edx
	jne	SHORT $LN2@pe_create_

; 843  :                     curr->e.seginfo->segtype = SEGTYPE_RELOC;

	mov	DWORD PTR [r9+72], 8
$LN2@pe_create_:

; 823  :             return;
; 824  : 
; 825  :         /* before objects can be counted, the segment types
; 826  :          * SEGTYPE_CDATA ( for readonly segments ) &
; 827  :          * SEGTYPE_RSRC ( for resource segments )
; 828  :          * SEGTYPE_RELOC ( for relocations )
; 829  :          * must be set  - also, init lname_idx field
; 830  :          */
; 831  :         for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r10, QWORD PTR [r10+104]
	test	r10, r10
	jne	$LL4@pe_create_
	mov	r10, QWORD PTR SymTables+32
$LN3@pe_create_:

; 844  :             }
; 845  :         }
; 846  : 
; 847  :         /* count objects ( without header types ) */
; 848  :         for ( i = 1, objs = 0; i < SIZE_PEFLAT; i++ ) {

	lea	r8, OFFSET FLAT:flat_order+4
	npad	6
$LL7@pe_create_:

; 849  :             DebugMsg(("pe_create_section_table: searching type %u\n", flat_order[i] ));
; 850  :             for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rax, r10
	test	r10, r10
	je	SHORT $LN5@pe_create_

; 851  :                 DebugMsg(("pe_create_section_table: section %s, type=%u, size=%X\n", curr->sym.name, curr->e.seginfo->segtype, curr->sym.max_offset ));
; 852  :                 if ( curr->e.seginfo->segtype != flat_order[i] )

	mov	edx, DWORD PTR [r8]
	npad	5
$LL10@pe_create_:
	mov	rcx, QWORD PTR [rax+96]
	cmp	DWORD PTR [rcx+72], edx
	jne	SHORT $LN8@pe_create_

; 853  :                     continue;
; 854  :                 if ( curr->sym.max_offset ) {

	cmp	DWORD PTR [rax+56], 0
	jne	SHORT $LN32@pe_create_
$LN8@pe_create_:

; 849  :             DebugMsg(("pe_create_section_table: searching type %u\n", flat_order[i] ));
; 850  :             for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rax, QWORD PTR [rax+104]
	test	rax, rax
	jne	SHORT $LL10@pe_create_
	jmp	SHORT $LN5@pe_create_
$LN32@pe_create_:

; 855  :                     DebugMsg(("pe_create_section_table: %s, type=%u is object %u\n", curr->sym.name, curr->e.seginfo->segtype, objs ));
; 856  :                     objs++;

	inc	edi
$LN5@pe_create_:

; 844  :             }
; 845  :         }
; 846  : 
; 847  :         /* count objects ( without header types ) */
; 848  :         for ( i = 1, objs = 0; i < SIZE_PEFLAT; i++ ) {

	inc	esi
	add	r8, 4
	movsxd	rax, esi
	cmp	rax, 7
	jb	SHORT $LL7@pe_create_

; 857  :                     break;
; 858  :                 }
; 859  :             }
; 860  :         }
; 861  :         if ( objs ) {

	test	edi, edi
	je	SHORT $LN48@pe_create_

; 862  :             DebugMsg(("pe_create_section_table: items in object table: %u\n", objs ));
; 863  :             objtab->sym.max_offset = sizeof(struct IMAGE_SECTION_HEADER) * objs;

	lea	eax, DWORD PTR [rdi+rdi*4]
	shl	eax, 3

; 864  :             /* alloc space for 1 more section (.reloc) */
; 865  :             objtab->e.seginfo->CodeBuffer = LclAlloc( objtab->sym.max_offset + sizeof(struct IMAGE_SECTION_HEADER) );

	movsxd	rcx, eax
	add	rcx, 40					; 00000028H
	mov	DWORD PTR [rbp+56], eax
	call	LclAlloc
	mov	rcx, QWORD PTR [rbp+96]
	mov	QWORD PTR [rcx+16], rax
$LN48@pe_create_:
	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
$LN27@pe_create_:

; 866  :         }
; 867  :     }
; 868  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
pe_create_section_table ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
sym$ = 48
opnd$ = 56
set_file_flags PROC

; 728  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	rbx, rdx

; 729  :     struct dsym *pehdr;
; 730  :     struct IMAGE_PE_HEADER32 *pe;
; 731  : 
; 732  :     pehdr = ( struct dsym *)SymSearch( hdrname "2" );

	lea	rcx, OFFSET FLAT:$SG11881
	call	SymFind

; 733  :     if ( !pehdr )

	test	rax, rax
	je	SHORT $LN1@set_file_f

; 734  :         return;
; 735  :     pe = (struct IMAGE_PE_HEADER32 *)pehdr->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [rax+96]
	mov	r8, QWORD PTR [rax+16]

; 736  : 
; 737  :     if ( opnd ) /* set the value? */

	test	rbx, rbx
	je	SHORT $LN3@set_file_f

; 738  :         pe->FileHeader.Characteristics = opnd->value;

	movzx	eax, WORD PTR [rbx]
	mov	WORD PTR [r8+22], ax
$LN3@set_file_f:

; 739  : 
; 740  :     sym->value = pe->FileHeader.Characteristics;

	movzx	eax, WORD PTR [r8+22]
	mov	DWORD PTR [rdi+16], eax
$LN1@set_file_f:

; 741  :     DebugMsg(("set_file_flags(%s, %X): value=%X\n", sym->name, opnd, sym->value ));
; 742  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
set_file_flags ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
;	COMDAT pe_create_MZ_header
_TEXT	SEGMENT
modinfo$ = 64
pe_create_MZ_header PROC				; COMDAT

; 704  : {

	push	rbx
	sub	rsp, 48					; 00000030H

; 705  :     const char *p;
; 706  :     struct asym *sym;
; 707  : 
; 708  :     DebugMsg(("pe_create_MZ_header enter\n" ));
; 709  :     if ( Parse_Pass == PASS_1 && SymSearch( hdrname "1" ) == NULL )

	cmp	DWORD PTR Parse_Pass, 0
	mov	rbx, rcx
	jne	SHORT $LN5@pe_create_
	lea	rcx, OFFSET FLAT:$SG11862
	call	SymFind
	test	rax, rax
	jne	SHORT $LN5@pe_create_

; 710  :         modinfo->g.pe_flags |= PEF_MZHDR;

	or	BYTE PTR [rbx+312], 1
$LN5@pe_create_:

; 711  :     if ( modinfo->g.pe_flags & PEF_MZHDR ) {

	test	BYTE PTR [rbx+312], 1
	je	$LN7@pe_create_

; 712  :         DebugMsg(("pe_create_MZ_header: generate code\n" ));
; 713  :         AddLineQueueX("%r DOTNAME", T_OPTION );

	mov	edx, 447				; 000001bfH
	mov	QWORD PTR [rsp+64], rdi
	lea	rcx, OFFSET FLAT:$SG11864
	call	AddLineQueueX

; 714  :         AddLineQueueX("%s1 %r USE16 %r %s", hdrname, T_SEGMENT, T_WORD, hdrattr );

	lea	rax, OFFSET FLAT:hdrattr
	mov	r9d, 207				; 000000cfH
	mov	r8d, 436				; 000001b4H
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, OFFSET FLAT:$SG11865
	lea	rcx, OFFSET FLAT:$SG11866
	call	AddLineQueueX

; 715  :         for( p = mzcode; p < mzcode + sizeof( mzcode ); p += strlen( p ) + 1 )

	lea	rbx, OFFSET FLAT:mzcode
	lea	rdi, OFFSET FLAT:mzcode+180
$LL4@pe_create_:

; 716  :             AddLineQueue( p );

	mov	rcx, rbx
	call	AddLineQueue
	or	rax, -1
$LL13@pe_create_:

; 715  :         for( p = mzcode; p < mzcode + sizeof( mzcode ); p += strlen( p ) + 1 )

	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL13@pe_create_
	inc	rbx
	add	rbx, rax
	cmp	rbx, rdi
	jb	SHORT $LL4@pe_create_

; 717  :         AddLineQueueX("%s1 %r", hdrname, T_ENDS );

	mov	r8d, 437				; 000001b5H
	lea	rdx, OFFSET FLAT:$SG11867
	lea	rcx, OFFSET FLAT:$SG11868
	call	AddLineQueueX

; 718  :         RunLineQueue();

	call	RunLineQueue

; 719  :         if ( ( sym = SymSearch( hdrname "1" ) ) && sym->state == SYM_SEG )

	lea	rcx, OFFSET FLAT:$SG11870
	call	SymFind
	mov	rdi, QWORD PTR [rsp+64]
	test	rax, rax
	je	SHORT $LN7@pe_create_
	cmp	DWORD PTR [rax+32], 3
	jne	SHORT $LN7@pe_create_

; 720  :            (( struct dsym *)sym)->e.seginfo->segtype = SEGTYPE_HDR;

	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+72], 6
$LN7@pe_create_:

; 721  :     }
; 722  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
pe_create_MZ_header ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
;	COMDAT DoFixup
_TEXT	SEGMENT
value64$ = 112
curr$ = 112
cp$ = 120
DoFixup	PROC						; COMDAT

; 439  : {

	mov	rax, rsp
	mov	QWORD PTR [rax+16], rdx
	push	rbp
	push	r13
	sub	rsp, 88					; 00000058H

; 440  :     union genptr codeptr;
; 441  :     struct dsym *seg;
; 442  :     uint_32 value;
; 443  : #if PE_SUPPORT && AMD64_SUPPORT
; 444  :     uint_64 value64;
; 445  : #endif
; 446  :     uint_32 offset;  /* v2.07 */
; 447  :     struct fixup *fixup;
; 448  :     char *tmp;
; 449  : 
; 450  :     if ( curr->e.seginfo->segtype == SEGTYPE_ABS )

	mov	rbp, QWORD PTR [rcx+96]
	mov	r8, rdx
	mov	r13, rcx
	cmp	DWORD PTR [rbp+72], 5
	je	$LN3@DoFixup

; 451  :         return( NOT_ERROR );
; 452  : 
; 453  :     DebugMsg(("DoFixup(%s) enter, segment start ofs=%" I32_SPEC "Xh\n", curr->sym.name, curr->e.seginfo->start_offset ));
; 454  :     for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rbp, QWORD PTR [rbp+40]
	test	rbp, rbp
	je	$LN3@DoFixup
	mov	QWORD PTR [rax+24], rbx
	lea	r9, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rax-24], rsi
	mov	QWORD PTR [rax-48], r14
	mov	QWORD PTR [rax-56], r15
	mov	QWORD PTR [rax-32], rdi
	mov	QWORD PTR [rax-40], r12
	npad	2
$LL4@DoFixup:

; 455  :         codeptr.db = curr->e.seginfo->CodeBuffer +

	mov	rdx, QWORD PTR [r13+96]
	mov	ebx, DWORD PTR [rbp+20]

; 456  :             ( fixup->locofs - curr->e.seginfo->start_loc );
; 457  : 
; 458  :         //if ( fixup->sym && fixup->sym->segment ) { /* v2.08: changed */
; 459  :         if ( fixup->sym && ( fixup->sym->segment || fixup->sym->variable ) ) {

	mov	rax, QWORD PTR [rbp+56]
	sub	ebx, DWORD PTR [rdx+8]
	add	rbx, QWORD PTR [rdx+16]
	test	rax, rax
	je	$LN13@DoFixup
	mov	r14, QWORD PTR [rax+24]
	test	r14, r14
	jne	SHORT $LN15@DoFixup
	test	BYTE PTR [rax+40], 64			; 00000040H
	je	$LN13@DoFixup
$LN15@DoFixup:

; 460  :             /* assembly time variable (also $ symbol) in reloc? */
; 461  :             /* v2.07: moved inside if-block, using new local var "offset" */
; 462  :             if ( fixup->sym->variable ) {

	test	BYTE PTR [rax+40], 64			; 00000040H
	je	SHORT $LN16@DoFixup

; 463  :                 seg = (struct dsym *)fixup->segment_var;

	mov	r14, QWORD PTR [rbp+40]

; 464  :                 offset = 0;

	xor	r12d, r12d

; 465  :                 DebugMsg(("DoFixup(%s, %04" I32_SPEC "X, %s): variable, fixup->segment=%Xh fixup->offset=%" I32_SPEC "Xh, fixup->sym->offset=%" I32_SPEC "Xh\n",
; 466  :                           curr->sym.name, fixup->locofs, fixup->sym->name, seg, fixup->offset, fixup->sym->offset ));
; 467  :             } else {

	jmp	SHORT $LN17@DoFixup
$LN16@DoFixup:

; 468  :                 seg = (struct dsym *)fixup->sym->segment;
; 469  :                 offset = fixup->sym->offset;

	mov	r12d, DWORD PTR [rax+16]
$LN17@DoFixup:

; 470  :             }
; 471  :             /* the offset result consists of
; 472  :              * - the symbol's offset
; 473  :              * - the fixup's offset (usually the displacement )
; 474  :              * - the segment/group offset in the image
; 475  :              */
; 476  :             switch ( fixup->type ) {

	mov	eax, DWORD PTR [rbp+24]
	test	eax, eax
	jle	$LN23@DoFixup
	cmp	eax, 3
	jle	$LN22@DoFixup
	cmp	eax, 12
	je	$LN18@DoFixup
	cmp	eax, 13
	jne	$LN23@DoFixup

; 482  :             case FIX_OFF32_SECREL:
; 483  :                 value = ( fixup->offset + offset ) - seg->e.seginfo->start_loc;

	mov	rax, QWORD PTR [r14+96]
	mov	edi, r12d

; 484  :                 /* check if symbol's segment name contains a '$'.
; 485  :                  * If yes, search the segment without suffix.
; 486  :                  */
; 487  :                 if ( tmp = strchr( seg->sym.name, '$' ) ) {

	mov	rcx, QWORD PTR [r14+8]
	mov	edx, 36					; 00000024H
	sub	edi, DWORD PTR [rax+8]
	add	edi, DWORD PTR [rbp+16]
	call	strchr
	mov	r15, rax
	test	rax, rax
	je	SHORT $LN77@DoFixup

; 488  :                     int namlen = tmp - seg->sym.name;

	sub	r15d, DWORD PTR [r14+8]

; 489  :                     struct dsym *segfirst;
; 490  :                     for( segfirst = SymTables[TAB_SEG].head; segfirst; segfirst = segfirst->next ) {

	mov	rsi, QWORD PTR SymTables+32
	test	rsi, rsi
	je	SHORT $LN77@DoFixup
	npad	6
$LL9@DoFixup:

; 491  :                         if ( segfirst->sym.name_size == namlen &&

	movzx	ecx, BYTE PTR [rsi+72]
	cmp	ecx, r15d
	jne	SHORT $LN7@DoFixup
	mov	rdx, QWORD PTR [r14+8]
	mov	rcx, QWORD PTR [rsi+8]
	movsxd	r8, r15d
	call	memcmp
	test	eax, eax
	je	SHORT $LN70@DoFixup
$LN7@DoFixup:

; 489  :                     struct dsym *segfirst;
; 490  :                     for( segfirst = SymTables[TAB_SEG].head; segfirst; segfirst = segfirst->next ) {

	mov	rsi, QWORD PTR [rsi+104]
	test	rsi, rsi
	jne	SHORT $LL9@DoFixup

; 494  :                             DebugMsg(("DoFixup(%s): SECREL, primary seg=%s, start_offset=%" I32_SPEC "X\n",
; 495  :                                       curr->sym.name, segfirst->sym.name, segfirst->e.seginfo->start_offset ));
; 496  :                             break;
; 497  :                         }
; 498  :                     }
; 499  :                 }
; 500  :                 DebugMsg(("DoFixup(%s): SECREL, loc=%" I32_SPEC "X, value=%" I32_SPEC "X\n",
; 501  :                         curr->sym.name, fixup->locofs, value ));
; 502  :                 break;

	lea	r9, OFFSET FLAT:__ImageBase
	jmp	$LN14@DoFixup
$LN70@DoFixup:

; 492  :                             ( memcmp( segfirst->sym.name, seg->sym.name, namlen ) == 0 ) ) {
; 493  :                             value = ( fixup->offset + offset + seg->e.seginfo->start_offset ) - segfirst->e.seginfo->start_offset;

	mov	rcx, QWORD PTR [r14+96]
	mov	rax, QWORD PTR [rsi+96]
	mov	edi, DWORD PTR [rcx+12]
	sub	edi, DWORD PTR [rax+12]
	add	edi, r12d
	add	edi, DWORD PTR [rbp+16]
$LN77@DoFixup:

; 494  :                             DebugMsg(("DoFixup(%s): SECREL, primary seg=%s, start_offset=%" I32_SPEC "X\n",
; 495  :                                       curr->sym.name, segfirst->sym.name, segfirst->e.seginfo->start_offset ));
; 496  :                             break;
; 497  :                         }
; 498  :                     }
; 499  :                 }
; 500  :                 DebugMsg(("DoFixup(%s): SECREL, loc=%" I32_SPEC "X, value=%" I32_SPEC "X\n",
; 501  :                         curr->sym.name, fixup->locofs, value ));
; 502  :                 break;

	lea	r9, OFFSET FLAT:__ImageBase
	jmp	SHORT $LN14@DoFixup
$LN18@DoFixup:

; 477  :             case FIX_OFF32_IMGREL:
; 478  :                 value = ( fixup->offset + offset + seg->e.seginfo->start_offset ) - cp->imagestart;

	mov	rax, QWORD PTR [r14+96]
	mov	edi, DWORD PTR [rax+12]
	sub	edi, DWORD PTR [r8+24]
	add	edi, DWORD PTR [rbp+16]
	add	edi, r12d

; 479  :                 DebugMsg(("DoFixup(%s): IMGREL, loc=%" I32_SPEC "X value=%" I32_SPEC "X seg.start=%" I32_SPEC "X imagestart=%" I32_SPEC "X\n",
; 480  :                           curr->sym.name, fixup->locofs, value, seg->e.seginfo->start_offset, cp->imagestart ));
; 481  :                 break;

	jmp	SHORT $LN14@DoFixup
$LN22@DoFixup:

; 503  :             case FIX_RELOFF8:
; 504  :             case FIX_RELOFF16:
; 505  :             case FIX_RELOFF32:
; 506  :                 /* v1.96: special handling for "relative" fixups */
; 507  :                 value = seg->e.seginfo->start_offset + fixup->offset + offset;

	mov	rax, QWORD PTR [r14+96]
	mov	edi, DWORD PTR [rax+12]
	add	edi, DWORD PTR [rbp+16]
	add	edi, r12d

; 508  :                 DebugMsg(("DoFixup(%s): RELOFFx, loc=%" I32_SPEC "X, sym=%s, [start_offset=%" I32_SPEC "Xh, fixup->offset=%" I32_SPEC "Xh, fixup->sym->offset=%" I32_SPEC "Xh\n",
; 509  :                         curr->sym.name, fixup->locofs, fixup->sym->name, seg->e.seginfo->start_offset, fixup->offset, offset ));
; 510  :                 break;

	jmp	SHORT $LN14@DoFixup
$LN23@DoFixup:

; 511  :             default:
; 512  :                 /* v2.01: don't use group if fixup explicitely refers the segment! */
; 513  :                 //if ( seg->e.seginfo->group ) {
; 514  :                 if ( seg->e.seginfo->group && fixup->frame_type != FRAME_SEG ) {

	mov	rax, QWORD PTR [r14+96]
	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN24@DoFixup
	cmp	BYTE PTR [rbp+40], 0
	je	SHORT $LN24@DoFixup

; 515  :                     value = (seg->e.seginfo->group->offset & 0xF) + seg->e.seginfo->start_offset + fixup->offset + offset;

	mov	edi, DWORD PTR [rcx+16]
	and	edi, 15
	add	edi, DWORD PTR [rax+12]
	add	edi, DWORD PTR [rbp+16]
	add	edi, r12d

; 516  : #if PE_SUPPORT
; 517  :                     if ( ModuleInfo.sub_format == SFORMAT_PE ) {

	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN14@DoFixup

; 518  : #if AMD64_SUPPORT
; 519  :                         if ( curr->e.seginfo->Ofssize == USE64 )

	cmp	BYTE PTR [rdx+104], 2
	jne	SHORT $LN27@DoFixup

; 520  :                             value64 = value + cp->imagebase64;

	mov	eax, edi
	add	rax, QWORD PTR [r8+32]
	mov	QWORD PTR value64$[rsp], rax
$LN27@DoFixup:

; 521  : #endif
; 522  :                         value += cp->imagebase;

	add	edi, DWORD PTR [r8+32]

; 523  :                     }
; 524  : #endif
; 525  :                 } else

	jmp	SHORT $LN14@DoFixup
$LN24@DoFixup:

; 526  :                     value = (seg->e.seginfo->start_offset & 0xF) + fixup->offset + offset;

	mov	edi, DWORD PTR [rax+12]
	and	edi, 15
	add	edi, DWORD PTR [rbp+16]
	add	edi, r12d

; 527  : 
; 528  :                 DebugMsg(("DoFixup(%s): loc=%04" I32_SPEC "X, sym=%s, target->start_offset=%" I32_SPEC "Xh, fixup->offset=%" I32_SPEC "Xh, fixup->sym->offset=%" I32_SPEC "Xh\n",
; 529  :                         curr->sym.name, fixup->locofs, fixup->sym->name, seg->e.seginfo->start_offset, fixup->offset, offset ));
; 530  :                 break;
; 531  :             }
; 532  : 
; 533  :         } else {

	jmp	SHORT $LN14@DoFixup
$LN13@DoFixup:

; 534  :             /* v2.10: member segment_var is for assembly-time variables only */
; 535  :             //seg = (struct dsym *)fixup->segment_var;
; 536  :             seg = NULL;

	xor	r14d, r14d

; 537  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X, %s): target segment=0, fixup->offset=%" I32_SPEC "Xh, fixup->sym->offset=%" I32_SPEC "Xh\n",
; 538  :                       curr->sym.name, fixup->locofs, fixup->sym ? fixup->sym->name : "", fixup->offset ? offset : 0 ));
; 539  :             value = 0;

	xor	edi, edi
$LN14@DoFixup:

; 540  :         }
; 541  : 
; 542  :         switch ( fixup->type ) {

	mov	r8d, DWORD PTR [rbp+24]
	lea	eax, DWORD PTR [r8-1]
	cmp	eax, 12
	ja	$LN57@DoFixup
	cdqe
	mov	ecx, DWORD PTR $LN78@DoFixup[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN28@DoFixup:

; 543  :         case FIX_RELOFF8:
; 544  :             //*codeptr.db += (value - fixup->locofs + 1) & 0xff;
; 545  :             /* changed in v1.95 */
; 546  :             *codeptr.db += (value - (fixup->locofs + curr->e.seginfo->start_offset) - 1) & 0xff;

	mov	rax, QWORD PTR [r13+96]
	sub	dil, BYTE PTR [rax+12]
	sub	dil, BYTE PTR [rbp+20]
	dec	dil
	add	BYTE PTR [rbx], dil

; 547  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_RELOFF8, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.db ));
; 548  :             break;

	jmp	$LN2@DoFixup
$LN29@DoFixup:

; 549  :         case FIX_RELOFF16:
; 550  :             //*codeptr.dw += (value - fixup->locofs + 2) & 0xffff;
; 551  :             /* changed in v1.95 */
; 552  :             *codeptr.dw += (value - (fixup->locofs + curr->e.seginfo->start_offset) - 2) & 0xffff;

	mov	rax, QWORD PTR [r13+96]
	sub	di, WORD PTR [rax+12]
	sub	di, WORD PTR [rbp+20]
	sub	di, 2
	add	WORD PTR [rbx], di

; 553  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_RELOFF16, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dw ));
; 554  :             break;

	jmp	$LN2@DoFixup
$LN30@DoFixup:

; 555  :         case FIX_RELOFF32:
; 556  : #if AMD64_SUPPORT
; 557  :             /* adjust the location for EIP-related offsets if USE64 */
; 558  :             if ( curr->e.seginfo->Ofssize == USE64 ) {

	mov	rax, QWORD PTR [r13+96]
	cmp	BYTE PTR [rax+104], 2
	jne	SHORT $LN31@DoFixup

; 559  :                 fixup->locofs += fixup->addbytes - 4;

	movzx	eax, BYTE PTR [rbp+32]
	sub	eax, 4
	add	DWORD PTR [rbp+20], eax
$LN31@DoFixup:

; 560  :             }
; 561  : #endif
; 562  :             //*codeptr.dd += (value - fixup->locofs + 4);
; 563  :             /* changed in v1.95 */
; 564  :             *codeptr.dd += (value - (fixup->locofs + curr->e.seginfo->start_offset) - 4);

	mov	rax, QWORD PTR [r13+96]
	sub	edi, DWORD PTR [rax+12]
	sub	edi, DWORD PTR [rbp+20]
	sub	edi, 4
	add	DWORD PTR [rbx], edi

; 565  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_RELOFF32, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dd ));
; 566  :             break;

	jmp	$LN2@DoFixup
$LN33@DoFixup:

; 567  :         case FIX_OFF8:
; 568  :             *codeptr.db = value & 0xff;
; 569  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF8, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.db ));
; 570  :             break;
; 571  :         case FIX_OFF16:
; 572  :             *codeptr.dw = value & 0xffff;

	mov	WORD PTR [rbx], di

; 573  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF16, value=%" I32_SPEC "Xh, target=%p *target=%Xh\n", curr->sym.name, fixup->locofs, value, codeptr, *codeptr.dw ));
; 574  :             break;

	jmp	$LN2@DoFixup
$LN34@DoFixup:

; 575  :         case FIX_OFF32:
; 576  :             *codeptr.dd = value;

	mov	DWORD PTR [rbx], edi

; 577  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF32, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dd ));
; 578  :             break;

	jmp	$LN2@DoFixup
$LN37@DoFixup:

; 579  :         case FIX_OFF32_IMGREL:
; 580  :             *codeptr.dd = value;
; 581  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF32_IMGREL, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dd ));
; 582  :             break;
; 583  :         case FIX_OFF32_SECREL:
; 584  :             *codeptr.dd = value;
; 585  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF32_SECREL, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dd ));
; 586  :             break;
; 587  : #if AMD64_SUPPORT
; 588  :         case FIX_OFF64:
; 589  : #if PE_SUPPORT
; 590  :             if ( ModuleInfo.sub_format == SFORMAT_PE && curr->e.seginfo->Ofssize == USE64 )

	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN38@DoFixup
	mov	rax, QWORD PTR [r13+96]
	cmp	BYTE PTR [rax+104], 2
	jne	SHORT $LN38@DoFixup

; 591  :                 *codeptr.dq = value64;

	mov	rax, QWORD PTR value64$[rsp]
	mov	QWORD PTR [rbx], rax
	jmp	$LN2@DoFixup
$LN38@DoFixup:

; 592  :             else
; 593  : #endif
; 594  :                 *codeptr.dq = value;

	mov	eax, edi
	mov	QWORD PTR [rbx], rax

; 595  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF64, value=%" I32_SPEC "Xh, *target=%" I64_SPEC "Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dq ));
; 596  :             break;

	jmp	$LN2@DoFixup
$LN40@DoFixup:

; 597  : #endif
; 598  :         case FIX_HIBYTE:
; 599  :             *codeptr.db = (value >> 8) & 0xff;

	shr	edi, 8
$LN32@DoFixup:
	mov	BYTE PTR [rbx], dil

; 600  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_HIBYTE, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.db ));
; 601  :             break;

	jmp	$LN2@DoFixup
$LN41@DoFixup:

; 602  :         case FIX_SEG:
; 603  :             /* absolute segments are ok */
; 604  :             if ( fixup->sym &&
; 605  :                 fixup->sym->state == SYM_SEG &&

	mov	rax, QWORD PTR [rbp+56]
	test	rax, rax
	je	SHORT $LN42@DoFixup
	cmp	DWORD PTR [rax+32], 3
	jne	SHORT $LN42@DoFixup
	mov	rcx, QWORD PTR [rax+96]
	cmp	DWORD PTR [rcx+72], 5
	jne	SHORT $LN42@DoFixup

; 606  :                 ((struct dsym *)fixup->sym)->e.seginfo->segtype == SEGTYPE_ABS ) {
; 607  :                 *codeptr.dw = ((struct dsym *)fixup->sym)->e.seginfo->abs_frame;

	movzx	eax, WORD PTR [rcx+88]
	mov	WORD PTR [rbx], ax

; 608  :                 break;

	jmp	$LN2@DoFixup
$LN42@DoFixup:

; 609  :             }
; 610  : #if MZ_SUPPORT
; 611  :             if ( ModuleInfo.sub_format == SFORMAT_MZ ) {

	cmp	DWORD PTR ModuleInfo+372, 1
	jne	SHORT $LN43@DoFixup

; 612  :                 DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_SEG frame=%u, ", curr->sym.name, fixup->locofs, fixup->frame_type ));
; 613  :                 if ( fixup->sym->state == SYM_GRP ) {

	mov	ecx, DWORD PTR [rax+32]
	cmp	ecx, 4
	jne	SHORT $LN44@DoFixup

; 614  :                     seg = (struct dsym *)fixup->sym;
; 615  :                     *codeptr.dw = seg->sym.offset >> 4;

	mov	eax, DWORD PTR [rax+16]
	sar	eax, 4
	mov	WORD PTR [rbx], ax
	jmp	$LN2@DoFixup
$LN44@DoFixup:

; 616  :                     DebugMsg(("GROUP symbol, offset=%" I32_SPEC "Xh codeptr=%p\n", seg->sym.offset, codeptr ));
; 617  :                 } else if ( fixup->sym->state == SYM_SEG ) {

	cmp	ecx, 3
	jne	SHORT $LN46@DoFixup

; 618  :                     /* v2.04: added */
; 619  :                     seg = (struct dsym *)fixup->sym;
; 620  :                     *codeptr.dw = ( seg->e.seginfo->start_offset + ( seg->e.seginfo->group ? seg->e.seginfo->group->offset : 0 ) ) >> 4;

	mov	rdx, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rdx]
	test	rax, rax
	je	SHORT $LN62@DoFixup
	mov	ecx, DWORD PTR [rax+16]
	mov	eax, DWORD PTR [rdx+12]
	add	eax, ecx
	shr	eax, 4
	mov	WORD PTR [rbx], ax
	jmp	$LN2@DoFixup
$LN62@DoFixup:
	mov	eax, DWORD PTR [rdx+12]
	xor	ecx, ecx
	add	eax, ecx
	shr	eax, 4
	mov	WORD PTR [rbx], ax
	jmp	$LN2@DoFixup
$LN46@DoFixup:

; 621  :                     DebugMsg(("SEGMENT symbol, start_offset=%" I32_SPEC "Xh\n", seg->e.seginfo->start_offset ));
; 622  :                 //} else if ( seg->e.seginfo->group ) {
; 623  :                 } else if ( fixup->frame_type == FRAME_GRP ) {

	cmp	BYTE PTR [rbp+40], 1

; 624  :                     /* v2.04: changed */
; 625  :                     //*codeptr.dw = (seg->e.seginfo->start_offset + seg->e.seginfo->group->offset) >> 4;
; 626  :                     *codeptr.dw = seg->e.seginfo->group->offset >> 4;

	mov	rax, QWORD PTR [r14+96]
	jne	SHORT $LN48@DoFixup
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rcx+16]
	sar	eax, 4
	mov	WORD PTR [rbx], ax

; 627  :                     DebugMsg(("group.offset=%" I32_SPEC "Xh\n", seg->e.seginfo->group->offset ));
; 628  :                 } else {

	jmp	$LN2@DoFixup
$LN48@DoFixup:

; 629  :                     *codeptr.dw = seg->e.seginfo->start_offset >> 4;

	mov	ecx, DWORD PTR [rax+12]
	shr	ecx, 4
	mov	WORD PTR [rbx], cx

; 630  :                     DebugMsg(("segment.offset=%" I32_SPEC "Xh\n", seg->e.seginfo->start_offset ));
; 631  :                 }
; 632  :                 break;

	jmp	$LN2@DoFixup
$LN43@DoFixup:

; 633  :             }
; 634  : #endif
; 635  :         case FIX_PTR16:
; 636  : #if 1
; 637  :             /* v2.10: absolute segments are ok */
; 638  :             if ( seg && seg->e.seginfo->segtype == SEGTYPE_ABS ) {

	test	r14, r14
	je	SHORT $LN51@DoFixup
	mov	rax, QWORD PTR [r14+96]
	cmp	DWORD PTR [rax+72], 5
	jne	SHORT $LN51@DoFixup

; 639  :                 *codeptr.dw = value & 0xffff;

	mov	WORD PTR [rbx], di

; 640  :                 codeptr.dw++;
; 641  :                 *codeptr.dw = seg->e.seginfo->abs_frame;

	mov	rax, QWORD PTR [r14+96]
	movzx	ecx, WORD PTR [rax+88]
	mov	WORD PTR [rbx+2], cx

; 642  :                 break;

	jmp	$LN2@DoFixup
$LN51@DoFixup:

; 643  :             }
; 644  : #endif
; 645  : #if MZ_SUPPORT
; 646  :             if ( ModuleInfo.sub_format == SFORMAT_MZ ) {

	cmp	DWORD PTR ModuleInfo+372, 1
	jne	SHORT $LN52@DoFixup

; 647  :                 DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_PTR16, seg->start=%Xh\n", curr->sym.name, fixup->locofs, seg->e.seginfo->start_offset ));
; 648  :                 *codeptr.dw = value & 0xffff;

	mov	WORD PTR [rbx], di

; 649  :                 codeptr.dw++;
; 650  :                 //if ( seg->e.seginfo->group ) { /* v2.04: changed */
; 651  :                 if ( fixup->frame_type == FRAME_GRP ) {

	cmp	BYTE PTR [rbp+40], 1
	jne	SHORT $LN53@DoFixup

; 652  :                     /* v2.04: changed */
; 653  :                     //*codeptr.dw = (seg->e.seginfo->start_offset + seg->e.seginfo->group->offset) >> 4;
; 654  :                     *codeptr.dw = seg->e.seginfo->group->offset >> 4;

	mov	rax, QWORD PTR [r14+96]
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rcx+16]
	sar	eax, 4
	mov	WORD PTR [rbx+2], ax

; 655  :                 } else {

	jmp	$LN2@DoFixup
$LN53@DoFixup:

; 656  :                     /* v2.05: changed */
; 657  :                     //*codeptr.dw = seg->e.seginfo->start_offset >> 4;
; 658  :                     *codeptr.dw = ( seg->e.seginfo->start_offset + ( seg->e.seginfo->group ? seg->e.seginfo->group->offset : 0 ) ) >> 4;

	mov	rdx, QWORD PTR [r14+96]
	mov	rax, QWORD PTR [rdx]
	test	rax, rax
	je	SHORT $LN64@DoFixup
	mov	ecx, DWORD PTR [rax+16]
	mov	eax, DWORD PTR [rdx+12]
	add	eax, ecx
	shr	eax, 4
	mov	WORD PTR [rbx+2], ax

; 659  :                 }
; 660  :                 break;

	jmp	$LN2@DoFixup
$LN64@DoFixup:

; 656  :                     /* v2.05: changed */
; 657  :                     //*codeptr.dw = seg->e.seginfo->start_offset >> 4;
; 658  :                     *codeptr.dw = ( seg->e.seginfo->start_offset + ( seg->e.seginfo->group ? seg->e.seginfo->group->offset : 0 ) ) >> 4;

	mov	eax, DWORD PTR [rdx+12]
	xor	ecx, ecx
	add	eax, ecx
	shr	eax, 4
	mov	WORD PTR [rbx+2], ax

; 659  :                 }
; 660  :                 break;

	jmp	$LN2@DoFixup
$LN52@DoFixup:

; 661  :             }
; 662  : #endif
; 663  :         case FIX_PTR32:
; 664  : #if 1
; 665  :             /* v2.10: absolute segments are ok */
; 666  :             if ( seg && seg->e.seginfo->segtype == SEGTYPE_ABS ) {

	test	r14, r14
	je	SHORT $LN56@DoFixup
	mov	rax, QWORD PTR [r14+96]
	cmp	DWORD PTR [rax+72], 5
	jne	SHORT $LN56@DoFixup

; 667  :                 *codeptr.dd = value;

	mov	DWORD PTR [rbx], edi

; 668  :                 codeptr.dd++;
; 669  :                 *codeptr.dw = seg->e.seginfo->abs_frame;

	mov	rax, QWORD PTR [r14+96]
	movzx	ecx, WORD PTR [rax+88]
	mov	WORD PTR [rbx+4], cx

; 670  :                 break;

	jmp	SHORT $LN2@DoFixup
$LN56@DoFixup:

; 671  :             }
; 672  : #endif
; 673  : #if MZ_SUPPORT
; 674  :             if ( ModuleInfo.sub_format == SFORMAT_MZ ) {

	cmp	DWORD PTR ModuleInfo+372, 1
	jne	SHORT $LN57@DoFixup

; 675  :                 DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_PTR32\n", curr->sym.name, fixup->locofs ));
; 676  :                 *codeptr.dd = value;

	mov	DWORD PTR [rbx], edi

; 677  :                 codeptr.dd++;
; 678  :                 //if (seg->e.seginfo->group ) { /* v2.04: changed */
; 679  :                 if ( fixup->frame_type == FRAME_GRP ) {

	cmp	BYTE PTR [rbp+40], 1
	jne	SHORT $LN58@DoFixup

; 680  :                     /* v2.04: changed */
; 681  :                     //*codeptr.dw = (seg->e.seginfo->start_offset + seg->e.seginfo->group->offset) >> 4;
; 682  :                     *codeptr.dw = seg->e.seginfo->group->offset >> 4;

	mov	rax, QWORD PTR [r14+96]
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rcx+16]
	sar	eax, 4
	mov	WORD PTR [rbx+4], ax

; 683  :                 } else {

	jmp	SHORT $LN2@DoFixup
$LN58@DoFixup:

; 684  :                     /* v2.05: changed */
; 685  :                     //*codeptr.dw = seg->e.seginfo->start_offset >> 4;
; 686  :                     *codeptr.dw = ( seg->e.seginfo->start_offset + ( seg->e.seginfo->group ? seg->e.seginfo->group->offset : 0 ) ) >> 4;

	mov	rdx, QWORD PTR [r14+96]
	mov	rax, QWORD PTR [rdx]
	test	rax, rax
	je	SHORT $LN66@DoFixup
	mov	ecx, DWORD PTR [rax+16]
	mov	eax, DWORD PTR [rdx+12]
	add	eax, ecx
	shr	eax, 4
	mov	WORD PTR [rbx+4], ax

; 687  :                 }
; 688  :                 break;

	jmp	SHORT $LN2@DoFixup
$LN66@DoFixup:

; 684  :                     /* v2.05: changed */
; 685  :                     //*codeptr.dw = seg->e.seginfo->start_offset >> 4;
; 686  :                     *codeptr.dw = ( seg->e.seginfo->start_offset + ( seg->e.seginfo->group ? seg->e.seginfo->group->offset : 0 ) ) >> 4;

	mov	eax, DWORD PTR [rdx+12]
	xor	ecx, ecx
	add	eax, ecx
	shr	eax, 4
	mov	WORD PTR [rbx+4], ax

; 687  :                 }
; 688  :                 break;

	jmp	SHORT $LN2@DoFixup
$LN57@DoFixup:

; 689  :             }
; 690  : #endif
; 691  :         default:
; 692  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): invalid fixup %u\n", curr->sym.name, fixup->locofs, fixup->type ));
; 693  :             EmitErr( INVALID_FIXUP_TYPE, ModuleInfo.fmtopt->formatname, fixup->type, curr->sym.name, fixup->locofs );

	mov	rdx, QWORD PTR ModuleInfo+344
	mov	ecx, 198				; 000000c6H
	mov	eax, DWORD PTR [rbp+20]
	add	rdx, 10
	mov	r9, QWORD PTR [r13+8]
	mov	DWORD PTR [rsp+32], eax
	call	EmitErr
	lea	r9, OFFSET FLAT:__ImageBase
$LN2@DoFixup:

; 451  :         return( NOT_ERROR );
; 452  : 
; 453  :     DebugMsg(("DoFixup(%s) enter, segment start ofs=%" I32_SPEC "Xh\n", curr->sym.name, curr->e.seginfo->start_offset ));
; 454  :     for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rbp, QWORD PTR [rbp+8]
	mov	r8, QWORD PTR cp$[rsp]
	test	rbp, rbp
	jne	$LL4@DoFixup
	mov	r15, QWORD PTR [rsp+48]
	mov	r14, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+128]
$LN3@DoFixup:

; 694  :             //return( ERROR );
; 695  :         }
; 696  :     }
; 697  :     return( NOT_ERROR );

	xor	eax, eax

; 698  : }

	add	rsp, 88					; 00000058H
	pop	r13
	pop	rbp
	ret	0
	npad	3
$LN78@DoFixup:
	DD	$LN28@DoFixup
	DD	$LN29@DoFixup
	DD	$LN30@DoFixup
	DD	$LN32@DoFixup
	DD	$LN33@DoFixup
	DD	$LN34@DoFixup
	DD	$LN37@DoFixup
	DD	$LN41@DoFixup
	DD	$LN43@DoFixup
	DD	$LN52@DoFixup
	DD	$LN40@DoFixup
	DD	$LN34@DoFixup
	DD	$LN34@DoFixup
DoFixup	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
;	COMDAT GetImageSize
_TEXT	SEGMENT
memimage$ = 8
GetImageSize PROC					; COMDAT

; 388  : {

	mov	QWORD PTR [rsp+8], rbx

; 389  :     struct dsym *curr;
; 390  :     bool first;
; 391  :     uint_32 vsize = 0;
; 392  :     uint_32 size = 0;
; 393  : 
; 394  :     for( curr = SymTables[TAB_SEG].head, first = TRUE; curr; curr = curr->next ) {

	mov	rdx, QWORD PTR SymTables+32
	xor	r10d, r10d
	movzx	r11d, cl
	mov	r9d, r10d
	mov	bl, 1
	test	rdx, rdx
	je	SHORT $LN30@GetImageSi
	npad	3
$LL4@GetImageSi:

; 395  :         uint_32 tmp;
; 396  :         if ( curr->e.seginfo->segtype == SEGTYPE_ABS || curr->e.seginfo->info )

	mov	r8, QWORD PTR [rdx+96]
	cmp	DWORD PTR [r8+72], 5
	je	SHORT $LN2@GetImageSi
	test	BYTE PTR [r8+107], 2
	jne	SHORT $LN2@GetImageSi

; 397  :             continue;
; 398  :         if ( memimage == FALSE ) {

	test	r11b, r11b
	jne	SHORT $LN20@GetImageSi

; 399  :             if ( curr->e.seginfo->bytes_written == 0 ) {

	cmp	DWORD PTR [r8+24], 0
	jne	SHORT $LN20@GetImageSi

; 400  :                 struct dsym *dir;
; 401  :                 for ( dir = curr->next; dir; dir = dir->next )

	mov	rax, QWORD PTR [rdx+104]
	test	rax, rax
	je	SHORT $LN30@GetImageSi
	npad	9
$LL7@GetImageSi:

; 402  :                     if ( dir->e.seginfo->bytes_written )

	mov	rcx, QWORD PTR [rax+96]
	cmp	DWORD PTR [rcx+24], 0
	jne	SHORT $LN20@GetImageSi

; 400  :                 struct dsym *dir;
; 401  :                 for ( dir = curr->next; dir; dir = dir->next )

	mov	rax, QWORD PTR [rax+104]
	test	rax, rax
	jne	SHORT $LL7@GetImageSi

; 418  :     }
; 419  :     DebugMsg(("GetImageSize(%u)=%" I32_SPEC "Xh\n", memimage, size ));
; 420  :     return( size );

	mov	eax, r9d

; 421  : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
$LN20@GetImageSi:

; 403  :                         break;
; 404  :                 if ( !dir )
; 405  :                     break; /* done, skip rest of segments! */
; 406  :             }
; 407  :         }
; 408  :         tmp = curr->e.seginfo->fileoffset + (curr->sym.max_offset - curr->e.seginfo->start_loc );

	mov	eax, DWORD PTR [r8+56]
	add	eax, DWORD PTR [rdx+56]
	mov	ecx, DWORD PTR [r8+8]
	sub	eax, ecx

; 409  :         if ( first == FALSE )

	test	bl, bl
	jne	SHORT $LN14@GetImageSi

; 410  :             vsize += curr->e.seginfo->start_loc;

	add	r10d, ecx
$LN14@GetImageSi:

; 411  :         if ( memimage )

	test	r11b, r11b
	je	SHORT $LN15@GetImageSi

; 412  :             tmp += vsize;

	add	eax, r10d
$LN15@GetImageSi:

; 413  :         DebugMsg(("GetImageSize(%s): fileofs=%" I32_SPEC "Xh, max_offs=%" I32_SPEC "Xh start=%" I32_SPEC "Xh\n",
; 414  :                   curr->sym.name, curr->e.seginfo->fileoffset, curr->sym.max_offset, curr->e.seginfo->start_loc ));
; 415  :         if ( size < tmp )

	cmp	r9d, eax
	cmovb	r9d, eax

; 416  :             size = tmp;
; 417  :         first = FALSE;

	xor	bl, bl
$LN2@GetImageSi:

; 389  :     struct dsym *curr;
; 390  :     bool first;
; 391  :     uint_32 vsize = 0;
; 392  :     uint_32 size = 0;
; 393  : 
; 394  :     for( curr = SymTables[TAB_SEG].head, first = TRUE; curr; curr = curr->next ) {

	mov	rdx, QWORD PTR [rdx+104]
	test	rdx, rdx
	jne	SHORT $LL4@GetImageSi
$LN30@GetImageSi:

; 421  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	eax, r9d
	ret	0
GetImageSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
;	COMDAT GetSegRelocs
_TEXT	SEGMENT
pDst$ = 8
GetSegRelocs PROC					; COMDAT

; 324  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi

; 325  :     struct dsym *curr;
; 326  :     int count = 0;
; 327  :     uint_16 valueofs;
; 328  :     uint_16 valueseg;
; 329  :     uint_32 loc;
; 330  :     struct fixup *fixup;
; 331  : 
; 332  :     DebugMsg(("GetSegRelocs( %p ) enter\n", pDst ));
; 333  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdi, QWORD PTR SymTables+32
	xor	ebx, ebx
	mov	r8, rcx
	test	rdi, rdi
	je	$LN33@GetSegRelo
	npad	1
$LL4@GetSegRelo:

; 334  :         if ( curr->e.seginfo->segtype == SEGTYPE_ABS )

	mov	r9, QWORD PTR [rdi+96]
	cmp	DWORD PTR [r9+72], 5
	je	$LN2@GetSegRelo

; 335  :             continue;
; 336  :         for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	r9, QWORD PTR [r9+40]
	test	r9, r9
	je	$LN2@GetSegRelo
	npad	4
$LL7@GetSegRelo:

; 337  :             switch ( fixup->type ) {

	mov	r11d, DWORD PTR [r9+24]
	lea	eax, DWORD PTR [r11-8]
	cmp	eax, 2
	ja	$LN5@GetSegRelo

; 338  :             case FIX_PTR32:
; 339  :             case FIX_PTR16:
; 340  :             case FIX_SEG:
; 341  :                 /* ignore fixups for absolute segments */
; 342  :                 if ( fixup->sym && fixup->sym->segment && ((struct dsym *)fixup->sym->segment)->e.seginfo->segtype == SEGTYPE_ABS )

	mov	rax, QWORD PTR [r9+56]
	test	rax, rax
	je	SHORT $LN14@GetSegRelo
	mov	rax, QWORD PTR [rax+24]
	test	rax, rax
	je	SHORT $LN14@GetSegRelo
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 5
	je	SHORT $LN5@GetSegRelo
$LN14@GetSegRelo:

; 343  :                     break;
; 344  :                 DebugMsg(("GetSegRelocs: found seg-related fixup at %s.%" I32_SPEC "X\n", curr->sym.name, fixup->locofs ));
; 345  :                 count++;

	inc	ebx

; 346  :                 if ( pDst ) {

	test	r8, r8
	je	SHORT $LN5@GetSegRelo

; 347  :                     /* v2.04: fixed */
; 348  :                     loc = fixup->locofs + ( curr->e.seginfo->start_offset & 0xf );

	mov	rcx, QWORD PTR [rdi+96]
	mov	r10d, DWORD PTR [rcx+12]
	mov	eax, r10d

; 349  :                     valueseg = curr->e.seginfo->start_offset >> 4;
; 350  :                     if ( curr->e.seginfo->group ) {

	mov	rdx, QWORD PTR [rcx]
	and	eax, 15
	add	eax, DWORD PTR [r9+20]
	shr	r10d, 4
	test	rdx, rdx
	je	SHORT $LN16@GetSegRelo

; 351  :                         loc += curr->e.seginfo->group->offset & 0xf;

	mov	edx, DWORD PTR [rdx+16]
	mov	ecx, edx
	and	ecx, 15

; 352  :                         valueseg += curr->e.seginfo->group->offset >> 4;

	sar	edx, 4
	add	eax, ecx
	add	r10w, dx
$LN16@GetSegRelo:

; 353  :                     }
; 354  :                     if ( fixup->type == FIX_PTR16 )

	cmp	r11d, 9
	jne	SHORT $LN17@GetSegRelo

; 355  :                         loc += 2;

	add	eax, 2
	jmp	SHORT $LN23@GetSegRelo
$LN17@GetSegRelo:

; 356  :                     else if ( fixup->type == FIX_PTR32 )

	cmp	r11d, 10
	jne	SHORT $LN23@GetSegRelo

; 357  :                         loc += 4;

	add	eax, 4
$LN23@GetSegRelo:

; 358  : 
; 359  :                     /* offset may be > 64 kB */
; 360  :                     while ( loc >= 0x10000 ) {

	cmp	eax, 65536				; 00010000H
	jb	SHORT $LN11@GetSegRelo
	lea	edx, DWORD PTR [rax-65520]
	shr	rdx, 4
	add	r10w, dx
	npad	4
$LL10@GetSegRelo:

; 361  :                         loc -= 16;

	add	eax, -16				; fffffff0H
	sub	rdx, 1
	jne	SHORT $LL10@GetSegRelo
$LN11@GetSegRelo:

; 362  :                         valueseg++;
; 363  :                     };
; 364  : 
; 365  :                     valueofs = loc;
; 366  :                     DebugMsg(("GetSegRelocs: locofs=%" I32_SPEC "X fileofs=%" I32_SPEC "X segofs=%" I32_SPEC "X grpofs=%" I32_SPEC "X, fixup value: %X %X\n",
; 367  :                               fixup->locofs, curr->e.seginfo->fileoffset, curr->e.seginfo->start_offset, curr->e.seginfo->group ? curr->e.seginfo->group->offset: 0, valueofs, valueseg ));
; 368  :                     *pDst++ = valueofs;

	mov	WORD PTR [r8], ax

; 369  :                     *pDst++ = valueseg;

	mov	WORD PTR [r8+2], r10w
	add	r8, 4
$LN5@GetSegRelo:

; 335  :             continue;
; 336  :         for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	r9, QWORD PTR [r9+8]
	test	r9, r9
	jne	$LL7@GetSegRelo
$LN2@GetSegRelo:

; 325  :     struct dsym *curr;
; 326  :     int count = 0;
; 327  :     uint_16 valueofs;
; 328  :     uint_16 valueseg;
; 329  :     uint_32 loc;
; 330  :     struct fixup *fixup;
; 331  : 
; 332  :     DebugMsg(("GetSegRelocs( %p ) enter\n", pDst ));
; 333  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdi, QWORD PTR [rdi+104]
	test	rdi, rdi
	jne	$LL4@GetSegRelo
$LN33@GetSegRelo:

; 370  :                 }
; 371  :                 break;
; 372  :             }
; 373  :         }
; 374  :     }
; 375  :     DebugMsg(("GetSegRelocs()=%u\n", count ));
; 376  :     return( count );
; 377  : }

	mov	rdi, QWORD PTR [rsp+16]
	mov	eax, ebx
	mov	rbx, QWORD PTR [rsp+8]
	ret	0
GetSegRelocs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
;	COMDAT CalcOffset
_TEXT	SEGMENT
curr$ = 48
cp$ = 56
CalcOffset PROC						; COMDAT

; 209  : {

	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	rbx, rdx

; 210  :     uint_32 align;
; 211  :     uint_32 alignbytes;
; 212  :     uint_32 offset;
; 213  :     struct dsym *grp;
; 214  : 
; 215  :     if ( curr->e.seginfo->segtype == SEGTYPE_ABS ) {

	mov	rcx, QWORD PTR [rcx+96]
	cmp	DWORD PTR [rcx+72], 5
	jne	SHORT $LN2@CalcOffset

; 216  :         curr->e.seginfo->start_offset = curr->e.seginfo->abs_frame << 4;

	movzx	eax, WORD PTR [rcx+88]
	shl	eax, 4
	mov	DWORD PTR [rcx+12], eax

; 312  :     return;
; 313  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@CalcOffset:

; 217  :         DebugMsg(("CalcOffset(%s): abs seg, offset=%" I32_SPEC "Xh\n",
; 218  :                   curr->sym.name, curr->e.seginfo->start_offset ));
; 219  :         return;
; 220  :     } else if ( curr->e.seginfo->info )

	test	BYTE PTR [rcx+107], 2
	jne	$LN1@CalcOffset

; 221  :         return;
; 222  : 
; 223  :     grp = (struct dsym *)curr->e.seginfo->group;
; 224  :     if ( cp->alignment > curr->e.seginfo->alignment )

	movzx	eax, BYTE PTR [rdx+1]

; 225  :         align = 1 << cp->alignment;

	mov	edx, 1
	mov	QWORD PTR [rsp+48], rbp
	mov	rbp, QWORD PTR [rcx]
	movzx	ecx, BYTE PTR [rcx+106]
	mov	QWORD PTR [rsp+56], rsi
	cmp	al, cl
	jbe	SHORT $LN5@CalcOffset
	movzx	ecx, al
$LN5@CalcOffset:

; 226  :     else
; 227  :         align = 1 << curr->e.seginfo->alignment;
; 228  :     //alignbytes = ((offset + (align - 1)) & (-align)) - offset;
; 229  :     alignbytes = ((cp->fileoffset + (align - 1)) & (-align)) - cp->fileoffset;

	mov	eax, DWORD PTR [rbx+4]
	shl	edx, cl
	lea	ecx, DWORD PTR [rax-1]
	add	ecx, edx
	neg	edx
	and	ecx, edx
	sub	ecx, eax

; 230  :     cp->fileoffset += alignbytes;

	add	DWORD PTR [rbx+4], ecx
	mov	esi, DWORD PTR [rbx+4]

; 231  : 
; 232  :     if ( grp == NULL ) {

	test	rbp, rbp
	jne	SHORT $LN7@CalcOffset

; 233  :         offset = cp->fileoffset - cp->sizehdr;  // + alignbytes;

	sub	esi, DWORD PTR [rbx+8]

; 234  :         DebugMsg(("CalcOffset(%s): fileofs=%" I32_SPEC "Xh, ofs=%" I32_SPEC "Xh\n", curr->sym.name, cp->fileoffset, offset ));
; 235  :     } else {

	jmp	SHORT $LN12@CalcOffset
$LN7@CalcOffset:

; 236  : #if PE_SUPPORT
; 237  :         if ( ModuleInfo.sub_format == SFORMAT_PE )

	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN9@CalcOffset

; 238  :             offset = cp->rva;

	mov	esi, DWORD PTR [rbx+28]
	jmp	SHORT $LN12@CalcOffset
$LN9@CalcOffset:

; 239  :         else
; 240  : #endif
; 241  :             if ( grp->sym.total_size == 0 ) {

	mov	eax, DWORD PTR [rbp+56]
	test	eax, eax
	jne	SHORT $LN11@CalcOffset

; 242  :                 grp->sym.offset = cp->fileoffset - cp->sizehdr;

	sub	esi, DWORD PTR [rbx+8]
	mov	DWORD PTR [rbp+16], esi

; 243  :                 offset = 0;

	xor	esi, esi

; 244  :             } else

	jmp	SHORT $LN12@CalcOffset
$LN11@CalcOffset:

; 245  :                 offset = grp->sym.total_size + alignbytes;

	lea	esi, DWORD PTR [rax+rcx]
$LN12@CalcOffset:

; 246  :         DebugMsg(("CalcOffset(%s): fileofs=%" I32_SPEC "Xh, alignbytes=%" I32_SPEC "u, ofs=%" I32_SPEC "Xh, group=%s, grp.ofs=%" I32_SPEC "Xh\n",
; 247  :                   curr->sym.name, cp->fileoffset, alignbytes, offset, grp->sym.name, grp->sym.offset ));
; 248  :     }
; 249  : 
; 250  :     /* v2.04: added */
; 251  :     /* v2.05: this addition did mess sample Win32_5.asm, because the
; 252  :      * "empty" alignment sections are now added to <fileoffset>.
; 253  :      * todo: VA in binary map is displayed wrong.
; 254  :      */
; 255  :     if ( cp->first == FALSE ) {

	cmp	BYTE PTR [rbx], 0
	jne	SHORT $LN14@CalcOffset

; 256  :         /* v2.05: do the reset more carefully.
; 257  :          * Do reset start_loc only if
; 258  :          * - segment is in a group and
; 259  :          * - group isn't FLAT or segment's name contains '$'
; 260  :          */
; 261  :         if ( grp && ( grp != ModuleInfo.flat_grp ||

	test	rbp, rbp
	je	SHORT $LN14@CalcOffset
	cmp	rbp, QWORD PTR ModuleInfo+440
	jne	SHORT $LN15@CalcOffset
	mov	rcx, QWORD PTR [rdi+8]
	mov	edx, 36					; 00000024H
	call	strchr
	test	rax, rax
	je	SHORT $LN14@CalcOffset
$LN15@CalcOffset:

; 262  :                      strchr( curr->sym.name, '$' ) ) )
; 263  :             curr->e.seginfo->start_loc = 0;

	mov	rax, QWORD PTR [rdi+96]
	mov	DWORD PTR [rax+8], 0
$LN14@CalcOffset:

; 264  :     }
; 265  : 
; 266  :     curr->e.seginfo->fileoffset = cp->fileoffset;

	mov	rcx, QWORD PTR [rdi+96]
	mov	eax, DWORD PTR [rbx+4]
	mov	DWORD PTR [rcx+56], eax

; 267  :     curr->e.seginfo->start_offset = offset;

	mov	rax, QWORD PTR [rdi+96]
	mov	DWORD PTR [rax+12], esi

; 268  : 
; 269  :     //if ( cp->first && ModuleInfo.sub_format == SFORMAT_NONE ) {
; 270  :     if ( ModuleInfo.sub_format == SFORMAT_NONE ) {
; 271  :         cp->fileoffset += curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR [rdi+96]
	mov	ecx, DWORD PTR [rdi+56]
	sub	ecx, DWORD PTR [rax+8]
	cmp	DWORD PTR ModuleInfo+372, 0
	jne	SHORT $LN16@CalcOffset
	add	DWORD PTR [rbx+4], ecx

; 272  :         if ( cp->first )

	cmp	BYTE PTR [rbx], 0
	je	SHORT $LN18@CalcOffset

; 273  :             cp->imagestart = curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR [rdi+96]
	mov	ecx, DWORD PTR [rax+8]
	mov	DWORD PTR [rbx+24], ecx
$LN18@CalcOffset:

; 274  :         /* there's no real entry address for BIN, therefore the
; 275  :          start label must be at the very beginning of the file */
; 276  :         if ( cp->entryoffset == -1 ) {

	cmp	DWORD PTR [rbx+12], -1			; ffffffffH
	jne	SHORT $LN21@CalcOffset

; 277  :             cp->entryoffset = offset;

	mov	DWORD PTR [rbx+12], esi

; 278  :             cp->entryseg = (struct asym *)curr;

	mov	QWORD PTR [rbx+16], rdi

; 279  :         }
; 280  :     } else {

	jmp	SHORT $LN21@CalcOffset
$LN16@CalcOffset:

; 281  :         /* v2.05: changed, removed */
; 282  :         //curr->e.seginfo->fileoffset += curr->e.seginfo->start_loc;
; 283  :         //fileoffset += curr->sym.max_offset;
; 284  : #if PE_SUPPORT
; 285  :         cp->rva += curr->sym.max_offset - curr->e.seginfo->start_loc;

	add	DWORD PTR [rbx+28], ecx

; 286  :         if ( curr->e.seginfo->segtype == SEGTYPE_BSS )

	mov	rcx, QWORD PTR [rdi+96]
	cmp	DWORD PTR [rcx+72], 3
	je	SHORT $LN21@CalcOffset

; 287  :             ;
; 288  :         else
; 289  : #endif
; 290  :         cp->fileoffset += curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	eax, DWORD PTR [rdi+56]
	sub	eax, DWORD PTR [rcx+8]
	add	DWORD PTR [rbx+4], eax
$LN21@CalcOffset:

; 295  :     if ( grp ) {

	test	rbp, rbp
	je	SHORT $LN23@CalcOffset

; 291  :     }
; 292  : 
; 293  :     //offset += curr->sym.max_offset - curr->e.seginfo->start_loc;
; 294  :     offset += curr->sym.max_offset;

	mov	ecx, DWORD PTR [rdi+56]
	add	ecx, esi

; 296  :         //grp->sym.total_size = offset + curr->e.seginfo->start_loc;
; 297  :         grp->sym.total_size = offset;

	mov	DWORD PTR [rbp+56], ecx

; 298  :         /* v2.07: for 16-bit groups, ensure that it fits in 64 kB */
; 299  :         if ( grp->sym.total_size > 0x10000 && grp->sym.Ofssize == USE16 ) {

	cmp	ecx, 65536				; 00010000H
	jbe	SHORT $LN23@CalcOffset
	cmp	BYTE PTR [rbp+44], 0
	jne	SHORT $LN23@CalcOffset

; 300  :             EmitWarn( 2, GROUP_EXCEEDS_64K, grp->sym.name );

	mov	r8, QWORD PTR [rbp+8]
	mov	edx, 275				; 00000113H
	mov	ecx, 2
	call	EmitWarn
$LN23@CalcOffset:

; 301  :         }
; 302  :     }
; 303  : #if PE_SUPPORT
; 304  :     DebugMsg(("CalcOffset(%s) exit: seg.fileofs=%" I32_SPEC "Xh, seg.start_offset=%" I32_SPEC "Xh, endofs=%" I32_SPEC "Xh fileofs=%" I32_SPEC "Xh rva=%" I32_SPEC "Xh\n",
; 305  :               curr->sym.name, curr->e.seginfo->fileoffset, curr->e.seginfo->start_offset, offset, cp->fileoffset, cp->rva ));
; 306  : #else
; 307  :     DebugMsg(("CalcOffset(%s) exit: seg.fileofs=%" I32_SPEC "Xh, seg.start_offset=%" I32_SPEC "Xh, endofs=%" I32_SPEC "Xh fileofs=%" I32_SPEC "Xh\n",
; 308  :               curr->sym.name, curr->e.seginfo->fileoffset, curr->e.seginfo->start_offset, offset, cp->fileoffset ));
; 309  : #endif
; 310  : 
; 311  :     cp->first = FALSE;

	mov	rsi, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+48]
	mov	BYTE PTR [rbx], 0
$LN1@CalcOffset:

; 312  :     return;
; 313  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CalcOffset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
pe_create_PE_header PROC

; 746  : {

$LN14:
	sub	rsp, 56					; 00000038H

; 747  :     struct asym *sym;
; 748  :     struct dsym *pehdr;
; 749  :     int size;
; 750  :     void *p;
; 751  : 
; 752  :     DebugMsg(("pe_create_PE_header enter\n" ));
; 753  :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN9@pe_create_

; 754  :         if ( ModuleInfo.model != MODEL_FLAT ) {

	cmp	DWORD PTR ModuleInfo+360, 7
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rsi
	mov	QWORD PTR [rsp+48], rdi
	je	SHORT $LN3@pe_create_

; 755  :             EmitError( MODEL_MUST_BE_FLAT );

	mov	ecx, 211				; 000000d3H
	call	EmitError
$LN3@pe_create_:

; 756  :         }
; 757  : #if AMD64_SUPPORT
; 758  :         if ( ModuleInfo.defOfssize == USE64 ) {

	cmp	BYTE PTR ModuleInfo+405, 2
	jne	SHORT $LN4@pe_create_

; 759  :             size = sizeof( struct IMAGE_PE_HEADER64 );

	mov	ebx, 264				; 00000108H

; 760  :             p = (void *)&pe64def;

	lea	rsi, OFFSET FLAT:pe64def

; 761  :         } else {

	jmp	SHORT $LN5@pe_create_
$LN4@pe_create_:

; 762  : #endif
; 763  :             size = sizeof( struct IMAGE_PE_HEADER32 );

	mov	ebx, 248				; 000000f8H

; 764  :             p = (void *)&pe32def;

	lea	rsi, OFFSET FLAT:pe32def
$LN5@pe_create_:

; 765  : #if AMD64_SUPPORT
; 766  :         }
; 767  : #endif
; 768  :         pehdr = ( struct dsym *)SymSearch( hdrname "2" );

	lea	rcx, OFFSET FLAT:$SG11906
	call	SymFind

; 769  :         if ( pehdr == NULL ) {

	test	rax, rax
	jne	SHORT $LN6@pe_create_

; 770  :             pehdr = (struct dsym *)CreateIntSegment( hdrname "2", "HDR", 2, ModuleInfo.defOfssize, TRUE );

	movzx	r9d, BYTE PTR ModuleInfo+405
	lea	rdx, OFFSET FLAT:$SG11909
	mov	r8b, 2
	mov	BYTE PTR [rsp+32], 1
	lea	rcx, OFFSET FLAT:$SG11910
	call	CreateIntSegment

; 771  :             pehdr->e.seginfo->group = &ModuleInfo.flat_grp->sym;

	mov	rcx, QWORD PTR ModuleInfo+440
	mov	r8, rax
	mov	rdx, QWORD PTR [rax+96]
	lea	rdi, QWORD PTR [rax+96]
	mov	QWORD PTR [rdx], rcx

; 772  :             pehdr->e.seginfo->combine = COMB_ADDOFF;  /* PUBLIC */

	mov	rdx, QWORD PTR [rdi]
	movzx	ecx, BYTE PTR [rdx+108]
	and	cl, 250					; 000000faH
	or	cl, 2
	mov	BYTE PTR [rdx+108], cl

; 773  :             pehdr->e.seginfo->characteristics = (IMAGE_SCN_MEM_READ >> 24);

	mov	rcx, QWORD PTR [rdi]
	mov	BYTE PTR [rcx+105], 64			; 00000040H

; 774  :             pehdr->e.seginfo->readonly = 1;

	mov	rcx, QWORD PTR [rdi]
	or	BYTE PTR [rcx+107], 1

; 775  :             pehdr->e.seginfo->bytes_written = size; /* ensure that ORG won't set start_loc (assemble.c, SetCurrOffset) */

	mov	rax, QWORD PTR [rdi]
	mov	DWORD PTR [rax+24], ebx

; 776  :             pehdr->sym.max_offset = size;

	mov	DWORD PTR [r8+56], ebx

; 777  :         } else {

	jmp	SHORT $LN7@pe_create_
$LN6@pe_create_:

; 778  :             if ( pehdr->sym.max_offset < size )

	cmp	DWORD PTR [rax+56], ebx
	jge	SHORT $LN8@pe_create_

; 779  :                 pehdr->sym.max_offset = size;

	mov	DWORD PTR [rax+56], ebx
$LN8@pe_create_:

; 780  :             pehdr->e.seginfo->internal = TRUE;

	lea	rdi, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+96]
	or	BYTE PTR [rax+107], 16

; 781  :             pehdr->e.seginfo->start_loc = 0;

	mov	rax, QWORD PTR [rdi]
	mov	DWORD PTR [rax+8], 0
$LN7@pe_create_:

; 782  :         }
; 783  :         pehdr->e.seginfo->segtype = SEGTYPE_HDR;

	mov	rax, QWORD PTR [rdi]

; 784  :         pehdr->e.seginfo->CodeBuffer = LclAlloc( size );

	movsxd	rbx, ebx
	mov	rcx, rbx
	mov	DWORD PTR [rax+72], 6
	call	LclAlloc
	mov	rcx, QWORD PTR [rdi]

; 785  :         memcpy( pehdr->e.seginfo->CodeBuffer, p, size );

	mov	r8, rbx
	mov	rdx, rsi
	mov	QWORD PTR [rcx+16], rax
	mov	rcx, QWORD PTR [rdi]
	mov	rcx, QWORD PTR [rcx+16]
	call	memcpy

; 786  : #if 0 //def __UNIX__
; 787  :         time((int_32 *)(pehdr->e.seginfo->CodeBuffer+offsetof( struct IMAGE_PE_HEADER32, FileHeader.TimeDateStamp )));
; 788  : #else
; 789  :         time((time_t *)(pehdr->e.seginfo->CodeBuffer+offsetof( struct IMAGE_PE_HEADER32, FileHeader.TimeDateStamp )));

	mov	rax, QWORD PTR [rdi]
	mov	rcx, QWORD PTR [rax+16]
	add	rcx, 8
	call	_time64

; 790  : #endif
; 791  :         sym = CreateVariable( "@pe_file_flags", ((struct IMAGE_PE_HEADER32 *)p)->FileHeader.Characteristics );

	movzx	edx, WORD PTR [rsi+22]
	lea	rcx, OFFSET FLAT:$SG11912
	call	CreateVariable
	mov	rdi, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 792  :         if ( sym ) {

	test	rax, rax
	je	SHORT $LN9@pe_create_

; 793  :             DebugMsg(("pe_create_PE_header: CreateVariable(@pe_file_flags)=%X [value=%X]\n", sym, sym ? sym->value : 0 ));
; 794  :             sym->predefined = TRUE;

	or	BYTE PTR [rax+40], 32			; 00000020H

; 795  :             sym->sfunc_ptr = (internal_func)&set_file_flags;

	lea	rcx, OFFSET FLAT:set_file_flags
	mov	QWORD PTR [rax+64], rcx
$LN9@pe_create_:

; 796  :         }
; 797  :     }
; 798  : }

	add	rsp, 56					; 00000038H
	ret	0
pe_create_PE_header ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
modinfo$ = 8
bin_init PROC

; 1834 :     modinfo->g.WriteModule = bin_write_module;
; 1835 :     modinfo->g.Pass1Checks = bin_check_external;
; 1836 :     switch ( modinfo->sub_format ) {

	mov	edx, DWORD PTR [rcx+372]
	lea	rax, OFFSET FLAT:bin_write_module
	mov	QWORD PTR [rcx+288], rax
	lea	rax, OFFSET FLAT:bin_check_external
	mov	QWORD PTR [rcx+304], rax
	sub	edx, 1
	je	SHORT $LN4@bin_init
	cmp	edx, 1
	jne	SHORT $LN2@bin_init

; 1840 :         break;
; 1841 : #endif
; 1842 : #if PE_SUPPORT
; 1843 :     case SFORMAT_PE:
; 1844 :         modinfo->g.EndDirHook = pe_enddirhook; /* v2.11 */

	lea	rax, OFFSET FLAT:pe_enddirhook
	mov	QWORD PTR [rcx+296], rax

; 1845 :         break;
; 1846 : #endif
; 1847 :     }
; 1848 :     return;
; 1849 : }

	ret	0
$LN4@bin_init:

; 1837 : #if MZ_SUPPORT
; 1838 :     case SFORMAT_MZ:
; 1839 :         memcpy( &modinfo->mz_data, &mzdata, sizeof( struct MZDATA ) );

	mov	rax, QWORD PTR mzdata
	mov	QWORD PTR [rcx+412], rax
$LN2@bin_init:

; 1845 :         break;
; 1846 : #endif
; 1847 :     }
; 1848 :     return;
; 1849 : }

	ret	0
bin_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\time.h
;	COMDAT time
_TEXT	SEGMENT
_Time$ = 8
time	PROC						; COMDAT

; 535  :             return _time64(_Time);

	jmp	_time64
time	ENDP
_TEXT	ENDS
END
