; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11283 DB	'TLS', 00H
$SG11082 DB	'@@%u', 00H
	ORG $+7
$SG11147 DB	'__unnamed', 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	sprintf
PUBLIC	cv_write_debug_tables
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	SymEnum:PROC
EXTRN	SizeFromMemtype:PROC
EXTRN	GetSymOfssize:PROC
EXTRN	CreateFixup:PROC
EXTRN	store_fixup:PROC
EXTRN	memcpy:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	szCVCompiler:BYTE
EXTRN	__ImageBase:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN8
	DD	imagerel $LN8+90
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetTyperef DD imagerel GetTyperef
	DD	imagerel GetTyperef+584
	DD	imagerel $unwind$GetTyperef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cv_write_bitfield DD imagerel cv_write_bitfield
	DD	imagerel cv_write_bitfield+151
	DD	imagerel $unwind$cv_write_bitfield
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cv_write_array_type DD imagerel cv_write_array_type
	DD	imagerel cv_write_array_type+304
	DD	imagerel $unwind$cv_write_array_type
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cv_write_ptr_type DD imagerel cv_write_ptr_type
	DD	imagerel cv_write_ptr_type+209
	DD	imagerel $unwind$cv_write_ptr_type
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$cv_write_ptr_type DD imagerel cv_write_ptr_type+209
	DD	imagerel cv_write_ptr_type+241
	DD	imagerel $chain$0$cv_write_ptr_type
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$cv_write_ptr_type DD imagerel cv_write_ptr_type+241
	DD	imagerel cv_write_ptr_type+279
	DD	imagerel $chain$1$cv_write_ptr_type
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cv_write_type DD imagerel cv_write_type
	DD	imagerel cv_write_type+99
	DD	imagerel $unwind$cv_write_type
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$cv_write_type DD imagerel cv_write_type+99
	DD	imagerel cv_write_type+596
	DD	imagerel $chain$1$cv_write_type
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$cv_write_type DD imagerel cv_write_type+596
	DD	imagerel cv_write_type+742
	DD	imagerel $chain$2$cv_write_type
pdata	ENDS
pdata	SEGMENT
$pdata$cv_cntproc DD imagerel cv_cntproc
	DD	imagerel cv_cntproc+184
	DD	imagerel $unwind$cv_cntproc
$pdata$cv_memberproc DD imagerel cv_memberproc
	DD	imagerel cv_memberproc+395
	DD	imagerel $unwind$cv_memberproc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cv_enum_fields DD imagerel cv_enum_fields
	DD	imagerel cv_enum_fields+48
	DD	imagerel $unwind$cv_enum_fields
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$cv_enum_fields DD imagerel cv_enum_fields+48
	DD	imagerel cv_enum_fields+215
	DD	imagerel $chain$0$cv_enum_fields
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$cv_enum_fields DD imagerel cv_enum_fields+215
	DD	imagerel cv_enum_fields+223
	DD	imagerel $chain$1$cv_enum_fields
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cv_write_type_procedure DD imagerel cv_write_type_procedure
	DD	imagerel cv_write_type_procedure+276
	DD	imagerel $unwind$cv_write_type_procedure
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cv_write_symbol DD imagerel cv_write_symbol
	DD	imagerel cv_write_symbol+216
	DD	imagerel $unwind$cv_write_symbol
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$cv_write_symbol DD imagerel cv_write_symbol+216
	DD	imagerel cv_write_symbol+2387
	DD	imagerel $chain$3$cv_write_symbol
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$cv_write_symbol DD imagerel cv_write_symbol+2387
	DD	imagerel cv_write_symbol+2398
	DD	imagerel $chain$4$cv_write_symbol
pdata	ENDS
pdata	SEGMENT
$pdata$cv_write_debug_tables DD imagerel $LN45
	DD	imagerel $LN45+801
	DD	imagerel $unwind$cv_write_debug_tables
pdata	ENDS
CONST	SEGMENT
?padtab@?1??PadBytes@@9@9 DB 0f1H			; `PadBytes'::`2'::padtab
	DB	0f2H
	DB	0f3H
	ORG $+5
reg64	DB	00H
	DB	02H
	DB	03H
	DB	01H
	DB	07H
	DB	06H
	DB	04H
	DB	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$cv_write_symbol DD 021H
	DD	imagerel cv_write_symbol
	DD	imagerel cv_write_symbol+216
	DD	imagerel $unwind$cv_write_symbol
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$cv_write_symbol DD 081421H
	DD	06f414H
	DD	0fe40fH
	DD	0e740aH
	DD	0d5405H
	DD	imagerel cv_write_symbol
	DD	imagerel cv_write_symbol+216
	DD	imagerel $unwind$cv_write_symbol
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cv_write_symbol DD 050b01H
	DD	0d007620bH
	DD	06003c005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cv_write_type_procedure DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$cv_enum_fields DD 021H
	DD	imagerel cv_enum_fields
	DD	imagerel cv_enum_fields+48
	DD	imagerel $unwind$cv_enum_fields
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$cv_enum_fields DD 020521H
	DD	0d7405H
	DD	imagerel cv_enum_fields
	DD	imagerel cv_enum_fields+48
	DD	imagerel $unwind$cv_enum_fields
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cv_enum_fields DD 041101H
	DD	0600d5211H
	DD	0300b500cH
xdata	ENDS
xdata	SEGMENT
$unwind$cv_cntproc DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$cv_memberproc DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
$unwind$cv_write_debug_tables DD 0a1901H
	DD	0126419H
	DD	0113419H
	DD	0f0129219H
	DD	0c00ee010H
	DD	0500b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$cv_write_type DD 021H
	DD	imagerel cv_write_type
	DD	imagerel cv_write_type+99
	DD	imagerel $unwind$cv_write_type
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$cv_write_type DD 041821H
	DD	067418H
	DD	0a5405H
	DD	imagerel cv_write_type
	DD	imagerel cv_write_type+99
	DD	imagerel $unwind$cv_write_type
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cv_write_type DD 030701H
	DD	060036207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$cv_write_ptr_type DD 021H
	DD	imagerel cv_write_ptr_type
	DD	imagerel cv_write_ptr_type+209
	DD	imagerel $unwind$cv_write_ptr_type
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$cv_write_ptr_type DD 020521H
	DD	063405H
	DD	imagerel cv_write_ptr_type
	DD	imagerel cv_write_ptr_type+209
	DD	imagerel $unwind$cv_write_ptr_type
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cv_write_ptr_type DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cv_write_array_type DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cv_write_bitfield DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetTyperef DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
cv$ = 32
i$ = 128
symbols$ = 128
types$ = 136
pv$ = 144
cv_write_debug_tables PROC

; 987  : {

$LN45:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 80					; 00000050H

; 988  :     struct asym *sym;
; 989  :     int        i;
; 990  :     int        len;
; 991  :     char       *objname;
; 992  :     struct dbgcv cv;
; 993  : 
; 994  :     DebugMsg(( "cv_write_debug_tables enter\n"));
; 995  : 
; 996  :     /**/myassert( types && symbols && types->sym.state == SYM_SEG &&  symbols->sym.state == SYM_SEG );
; 997  : 
; 998  :     cv.ps = symbols->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [rcx+96]

; 999  :     cv.symbols = symbols;
; 1000 :     cv.pt = types->e.seginfo->CodeBuffer;
; 1001 :     cv.types   = types;
; 1002 :     cv.currtype = 0x1000; /* user-defined types start at 0x1000 */
; 1003 :     cv.level   = 0;

	xor	r12d, r12d
	mov	r15, rcx
	mov	r14, rdx
	mov	r9, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rdx+96]
	mov	QWORD PTR cv$[rbp-80], r9
	mov	QWORD PTR cv$[rbp-72], rcx
	mov	r9, QWORD PTR [rax+16]
	mov	eax, 4096				; 00001000H
	mov	QWORD PTR cv$[rbp-64], r9
	mov	WORD PTR cv$[rbp-36], ax

; 1004 :     cv.param = pv;
; 1005 : #if GENPTRTYPE
; 1006 :     cv.ptrtype[0] = 0;
; 1007 :     cv.ptrtype[1] = 0;
; 1008 :     cv.ptrtype[2] = 0;
; 1009 : #endif
; 1010 :     /* init types */
; 1011 :     //memset( pt, 0, 1024 ); /* it's ensured to have at least size 1024 */
; 1012 :     *(uint_32 *)cv.pt = Options.debug_symbols; /* "signature" */

	movzx	eax, BYTE PTR Options+2
	mov	QWORD PTR cv$[rbp-56], rdx
	mov	DWORD PTR cv$[rbp-40], r12d
	mov	QWORD PTR cv$[rbp-48], r8
	mov	DWORD PTR [r9], eax

; 1013 :     cv.pt += sizeof( uint_32 );
; 1014 : 
; 1015 :     /* init symbols */
; 1016 :     //memset( ps, 0, 1024 ); /* it's ensured to has at least size 1024 */
; 1017 :     *(uint_32 *)cv.ps = Options.debug_symbols; /* "signature" */

	mov	rax, QWORD PTR cv$[rbp-80]
	movzx	ecx, BYTE PTR Options+2
	add	QWORD PTR cv$[rbp-64], 4
	mov	DWORD PTR [rax], ecx

; 1018 :     cv.ps += sizeof(uint_32);

	mov	r9, QWORD PTR cv$[rbp-80]

; 1019 : 
; 1020 :     /* 1. symbol record: object name */
; 1021 :     objname = CurrFName[OBJ];

	mov	rdx, QWORD PTR ModuleInfo+136
	add	r9, 4

; 1022 :     for ( i = strlen( objname ); i; i-- )

	or	rdi, -1
	mov	QWORD PTR cv$[rbp-80], r9
	mov	rcx, rdi
	npad	7
$LL41@cv_write_d:
	inc	rcx
	cmp	BYTE PTR [rdx+rcx], r12b
	jne	SHORT $LL41@cv_write_d
	mov	DWORD PTR i$[rbp-80], ecx
	test	ecx, ecx
	je	SHORT $LN42@cv_write_d
$LL4@cv_write_d:

; 1023 :         if ( *(objname+i-1) == '/' || *(objname+i-1) == '\\' )

	movsxd	rax, ecx
	movzx	r8d, BYTE PTR [rax+rdx-1]
	cmp	r8b, 47					; 0000002fH
	je	SHORT $LN42@cv_write_d
	cmp	r8b, 92					; 0000005cH
	je	SHORT $LN42@cv_write_d

; 1022 :     for ( i = strlen( objname ); i; i-- )

	sub	ecx, 1
	mov	DWORD PTR i$[rbp-80], ecx
	jne	SHORT $LL4@cv_write_d
$LN42@cv_write_d:

; 1024 :             break;
; 1025 :     objname += i;

	movsxd	rax, ecx

; 1026 :     len = strlen( objname );

	mov	r8, rdi
	add	rdx, rax
$LL40@cv_write_d:
	inc	r8
	cmp	BYTE PTR [rdx+r8], r12b
	jne	SHORT $LL40@cv_write_d

; 1027 :     cv.ps_on->sr.size = sizeof( struct cv_symrec_objname ) - sizeof(uint_16) + 1 + len;

	lea	eax, DWORD PTR [r8+7]

; 1028 :     cv.ps_on->sr.type = S_OBJNAME;
; 1029 :     cv.ps_on->Signature = 1;
; 1030 :     DebugMsg(( "cv_write_debug_tables: at %X objname=%s\n", GetPos(cv.symbols,cv.ps), objname ));
; 1031 :     cv.ps += sizeof( struct cv_symrec_objname );
; 1032 :     SetPrefixName( cv.ps, objname, len );

	movsxd	rbx, r8d
	mov	WORD PTR [r9], ax
	mov	ecx, 9
	mov	rax, QWORD PTR cv$[rbp-80]
	mov	esi, 1
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR cv$[rbp-80]
	mov	DWORD PTR [rax+4], esi
	mov	rax, QWORD PTR cv$[rbp-80]
	add	rax, 8
	mov	QWORD PTR cv$[rbp-80], rax
	mov	BYTE PTR [rax], r8b
	mov	r8, rbx
	mov	rcx, QWORD PTR cv$[rbp-80]
	inc	rcx
	mov	QWORD PTR cv$[rbp-80], rcx
	call	memcpy
	mov	rcx, QWORD PTR cv$[rbp-80]

; 1033 : 
; 1034 :     /* 2. symbol record: compiler */
; 1035 :     len = strlen( szCVCompiler );

	lea	r9, OFFSET FLAT:szCVCompiler
	add	rcx, rbx
	mov	QWORD PTR cv$[rbp-80], rcx
$LL39@cv_write_d:
	inc	rdi
	cmp	BYTE PTR [r9+rdi], r12b
	jne	SHORT $LL39@cv_write_d

; 1036 :     cv.ps_cp->sr.size = sizeof( struct cv_symrec_compile ) - sizeof(uint_16) + 1 + len;

	lea	eax, DWORD PTR [rdi+7]
	mov	WORD PTR [rcx], ax

; 1037 :     cv.ps_cp->sr.type = S_COMPILE;

	mov	rax, QWORD PTR cv$[rbp-80]
	mov	WORD PTR [rax+2], si

; 1038 : #if AMD64_SUPPORT
; 1039 :     /* v2.11: use a valid 64-bit value */
; 1040 :     cv.ps_cp->machine = ( ModuleInfo.defOfssize == USE64 ? CV_MACH_AMD64 : ( ModuleInfo.curr_cpu & P_CPU_MASK ) >> 4 );

	cmp	BYTE PTR ModuleInfo+405, 2
	jne	SHORT $LN24@cv_write_d
	mov	ecx, 208				; 000000d0H
	jmp	SHORT $LN25@cv_write_d
$LN24@cv_write_d:
	mov	ecx, DWORD PTR ModuleInfo+392
	sar	ecx, 4
	and	ecx, 15
$LN25@cv_write_d:
	mov	rax, QWORD PTR cv$[rbp-80]
	mov	BYTE PTR [rax+4], cl

; 1041 : #else
; 1042 :     cv.ps_cp->machine = ( ModuleInfo.curr_cpu & P_CPU_MASK ) >> 4;
; 1043 : #endif
; 1044 :     /* 0 isnt possible, 1 is 8086 and 80186 */
; 1045 :     if ( cv.ps_cp->machine == 0 )

	mov	rax, QWORD PTR cv$[rbp-80]
	cmp	BYTE PTR [rax+4], r12b
	jne	SHORT $LN13@cv_write_d

; 1046 :         cv.ps_cp->machine = CV_MACH_8086;

	mov	BYTE PTR [rax+4], sil
	mov	rax, QWORD PTR cv$[rbp-80]
$LN13@cv_write_d:

; 1047 :     cv.ps_cp->Language = CV_LANG_MASM;

	mov	BYTE PTR [rax+5], 3

; 1048 :     cv.ps_cp->flags = 0;

	mov	rax, QWORD PTR cv$[rbp-80]
	mov	WORD PTR [rax+6], r12w

; 1049 :     if ( ModuleInfo.model ) {

	mov	ecx, DWORD PTR ModuleInfo+360
	test	ecx, ecx
	je	SHORT $LN14@cv_write_d

; 1050 :         if ( ModuleInfo.model == MODEL_HUGE )

	cmp	ecx, 6
	jne	SHORT $LN15@cv_write_d

; 1051 :             cv.ps_cp->AmbientData = CV_AMB_HUGE;

	mov	rcx, QWORD PTR cv$[rbp-80]
	movzx	eax, BYTE PTR [rcx+6]
	and	al, 31
	or	al, 64					; 00000040H
	mov	BYTE PTR [rcx+6], al
	jmp	SHORT $LN16@cv_write_d
$LN15@cv_write_d:

; 1052 :         else
; 1053 :             cv.ps_cp->AmbientData = ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) ? CV_AMB_FAR : CV_AMB_NEAR );

	mov	rdx, QWORD PTR cv$[rbp-80]
	mov	eax, esi
	shl	eax, cl
	test	al, 104					; 00000068H
	movzx	eax, BYTE PTR [rdx+6]
	setne	cl
	shl	cl, 5
	and	al, 31
	or	cl, al
	mov	BYTE PTR [rdx+6], cl
$LN16@cv_write_d:

; 1054 :         cv.ps_cp->AmbientCode = ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ? CV_AMB_FAR : CV_AMB_NEAR );

	mov	ecx, DWORD PTR ModuleInfo+360
	mov	r8, QWORD PTR cv$[rbp-80]
	shl	esi, cl
	test	sil, 112				; 00000070H
	setne	al
	xor	al, BYTE PTR [r8+7]
	and	al, 7
	xor	BYTE PTR [r8+7], al
$LN14@cv_write_d:

; 1055 :     }
; 1056 :     DebugMsg(( "cv_write_debug_tables: at %X compiler=%s\n", GetPos(cv.symbols,cv.ps), szCVCompiler ));
; 1057 :     cv.ps += sizeof( struct cv_symrec_compile );

	mov	rax, QWORD PTR cv$[rbp-80]

; 1058 :     SetPrefixName( cv.ps, szCVCompiler, len );

	mov	rdx, r9
	add	rax, 8
	movsxd	rbx, edi
	mov	QWORD PTR cv$[rbp-80], rax
	mov	r8, rbx
	mov	BYTE PTR [rax], dil
	mov	rcx, QWORD PTR cv$[rbp-80]
	inc	rcx
	mov	QWORD PTR cv$[rbp-80], rcx
	call	memcpy
	add	QWORD PTR cv$[rbp-80], rbx

; 1059 : 
; 1060 :     /* CurrSeg must be set for store_fixup(); v2.12: obsolete */
; 1061 :     //CurrSeg = symbols;
; 1062 : 
; 1063 :     /* scan symbol table for types */
; 1064 : 
; 1065 :     sym = NULL;
; 1066 :     while ( sym = SymEnum( sym, &i ) ) {

	lea	rdx, QWORD PTR i$[rbp-80]
	xor	ecx, ecx
	call	SymEnum
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN6@cv_write_d
$LL5@cv_write_d:

; 1067 :         if ( sym->state == SYM_TYPE && sym->typekind != TYPE_TYPEDEF && sym->cvtyperef == 0 ) {

	cmp	DWORD PTR [rbx+32], 7
	jne	SHORT $LN17@cv_write_d
	cmp	BYTE PTR [rbx+66], 3
	je	SHORT $LN17@cv_write_d
	cmp	WORD PTR [rbx+64], r12w
	jne	SHORT $LN17@cv_write_d

; 1068 :             /**/myassert( cv.currtype >= 0x1000 ); /* check for overflow */
; 1069 :             cv_write_type( &cv, sym );

	mov	rdx, rbx
	lea	rcx, QWORD PTR cv$[rbp-80]
	call	cv_write_type
$LN17@cv_write_d:

; 1059 : 
; 1060 :     /* CurrSeg must be set for store_fixup(); v2.12: obsolete */
; 1061 :     //CurrSeg = symbols;
; 1062 : 
; 1063 :     /* scan symbol table for types */
; 1064 : 
; 1065 :     sym = NULL;
; 1066 :     while ( sym = SymEnum( sym, &i ) ) {

	lea	rdx, QWORD PTR i$[rbp-80]
	mov	rcx, rbx
	call	SymEnum
	mov	rbx, rax
	test	rax, rax
	jne	SHORT $LL5@cv_write_d
$LN6@cv_write_d:

; 1070 :         }
; 1071 :     }
; 1072 : 
; 1073 :     /* scan symbol table for SYM_TYPE, SYM_INTERNAL */
; 1074 : 
; 1075 :     sym = NULL;
; 1076 :     while ( sym = SymEnum( sym, &i ) ) {

	lea	rdx, QWORD PTR i$[rbp-80]
	xor	ecx, ecx
	call	SymEnum
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN8@cv_write_d
	npad	3
$LL7@cv_write_d:

; 1077 :         switch ( sym->state ) {

	mov	eax, DWORD PTR [rbx+32]
	movzx	ecx, BYTE PTR Options+3
	sub	eax, 1
	je	SHORT $LN19@cv_write_d
	cmp	eax, 6
	jne	SHORT $LN22@cv_write_d

; 1078 :         case SYM_TYPE: /* may create an S_UDT entry in the symbols table */
; 1079 :             if ( Options.debug_ext < CVEX_NORMAL ) /* v2.10: no UDTs for -Zi0 and -Zi1 */

	cmp	cl, 2
	jb	SHORT $LN22@cv_write_d
$LN19@cv_write_d:

; 1080 :                 break;
; 1081 :         case SYM_INTERNAL:
; 1082 :             if (
; 1083 : #if EQUATESYMS
; 1084 :                 /* emit constants if -Zi3 */
; 1085 :                 ( Options.debug_ext < CVEX_MAX ? sym->isequate : sym->variable )
; 1086 : #else
; 1087 :                 sym->isequate
; 1088 : #endif
; 1089 :                 || sym->predefined ) { /* EQUates? */

	cmp	cl, 3
	movzx	ecx, BYTE PTR [rbx+40]
	mov	eax, ecx
	jae	SHORT $LN26@cv_write_d
	shr	eax, 4
	jmp	SHORT $LN43@cv_write_d
$LN26@cv_write_d:
	shr	eax, 6
$LN43@cv_write_d:
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN22@cv_write_d
	test	cl, 32					; 00000020H
	jne	SHORT $LN22@cv_write_d

; 1090 :                 break;
; 1091 :             }
; 1092 :             /**/myassert( cv.currtype >= 0x1000 ); /* check for overflow */
; 1093 :             cv_write_symbol( &cv, sym );

	mov	rdx, rbx
	lea	rcx, QWORD PTR cv$[rbp-80]
	call	cv_write_symbol
$LN22@cv_write_d:

; 1070 :         }
; 1071 :     }
; 1072 : 
; 1073 :     /* scan symbol table for SYM_TYPE, SYM_INTERNAL */
; 1074 : 
; 1075 :     sym = NULL;
; 1076 :     while ( sym = SymEnum( sym, &i ) ) {

	lea	rdx, QWORD PTR i$[rbp-80]
	mov	rcx, rbx
	call	SymEnum
	mov	rbx, rax
	test	rax, rax
	jne	SHORT $LL7@cv_write_d
$LN8@cv_write_d:

; 1094 :             break;
; 1095 :         }
; 1096 :     }
; 1097 : 
; 1098 :     /* final flush for both types and symbols.
; 1099 :      * use 'fictional' size of MAX_LINE_LEN * 2!
; 1100 :      */
; 1101 :     checkflush( cv.types, cv.pt, SIZE_CV_SEGBUF, cv.param );

	mov	rcx, QWORD PTR cv$[rbp-56]
	mov	r8d, 2048				; 00000800H
	mov	r9, QWORD PTR cv$[rbp-48]
	mov	rdx, QWORD PTR cv$[rbp-64]
	mov	rax, QWORD PTR [rcx+96]
	call	QWORD PTR [rax+32]

; 1102 :     checkflush( cv.symbols, cv.ps, SIZE_CV_SEGBUF, cv.param );

	mov	rcx, QWORD PTR cv$[rbp-72]
	mov	r8d, 2048				; 00000800H
	mov	r9, QWORD PTR cv$[rbp-48]
	mov	rdx, QWORD PTR cv$[rbp-80]
	mov	rax, QWORD PTR [rcx+96]
	call	QWORD PTR [rax+32]

; 1103 :     types->sym.max_offset = types->e.seginfo->current_loc;

	mov	rcx, QWORD PTR [r14+96]

; 1104 :     types->e.seginfo->start_loc = 0; /* required for COFF */
; 1105 :     symbols->sym.max_offset = symbols->e.seginfo->current_loc;
; 1106 :     symbols->e.seginfo->start_loc = 0; /* required for COFF */
; 1107 : 
; 1108 :     //CurrSeg = NULL;
; 1109 :     //Modend = TRUE;
; 1110 : 
; 1111 :     DebugMsg(( "cv_write_debug_tables exit, max type=%Xh\n", cv.currtype - 1 ));
; 1112 :     return;
; 1113 : }

	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [r14+56], eax
	mov	DWORD PTR [rcx+8], r12d
	mov	rcx, QWORD PTR [r15+96]
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [r15+56], eax
	mov	DWORD PTR [rcx+8], r12d
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
cv_write_debug_tables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
;	COMDAT cv_write_symbol
_TEXT	SEGMENT
locals$ = 32
$T1 = 96
cnt$ = 96
proc$ = 96
cv$ = 96
sym$ = 104
cv_write_symbol PROC					; COMDAT

; 666  : {

	push	rbx
	push	rsi
	push	r12
	push	r13
	sub	rsp, 56					; 00000038H
	mov	rbx, rcx
	mov	rsi, rdx

; 667  :     int        len;
; 668  :     unsigned   ofs;
; 669  :     enum fixup_types rlctype;
; 670  :     uint_8     Ofssize;
; 671  :     struct fixup *fixup;
; 672  :     struct dsym *proc;
; 673  :     struct dsym *lcl;
; 674  :     int        i;
; 675  :     int        cnt[2];
; 676  :     struct     dsym *locals[2];
; 677  : 
; 678  :     Ofssize = GetSymOfssize( sym );

	mov	rcx, rdx
	call	GetSymOfssize

; 679  :     len = GetCVStructLen( sym, Ofssize );

	movzx	edx, al
	mov	rcx, rsi
	mov	r13d, eax
	call	GetCVStructLen

; 680  :     cv->ps = checkflush( cv->symbols, cv->ps, 1 + sym->name_size + len, cv->param );

	mov	rcx, QWORD PTR [rbx+8]
	movzx	r8d, BYTE PTR [rsi+72]
	mov	r9, QWORD PTR [rbx+32]
	inc	r8d
	mov	rdx, QWORD PTR [rbx]
	mov	r10, QWORD PTR [rcx+96]
	movzx	r12d, ax
	add	r8d, r12d
	call	QWORD PTR [r10+32]
	mov	QWORD PTR [rbx], rax
	mov	rdx, rax

; 681  : 
; 682  :     if ( sym->state == SYM_TYPE ) {

	cmp	DWORD PTR [rsi+32], 7
	jne	SHORT $LN14@cv_write_s

; 683  :         /* Masm does only generate an UDT for typedefs
; 684  :          * if the underlying type is "used" somewhere.
; 685  :          * example:
; 686  :          * LPSTR typedef ptr BYTE
; 687  :          * will only generate an S_UDT for LPSTR if either
; 688  :          * "LPSTR" or "ptr BYTE" is used in the source.
; 689  :          */
; 690  :         cv->ps_udt->sr.size = sizeof( struct cv_symrec_udt ) - sizeof(uint_16) + 1 + sym->name_size;

	movzx	ecx, BYTE PTR [rsi+72]
	add	cx, 5
	mov	WORD PTR [rax], cx

; 691  :         cv->ps_udt->sr.type = S_UDT;

	mov	ecx, 4
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], cx

; 692  :         /* v2.10: pointer typedefs will now have a cv_typeref */
; 693  :         //if ( sym->typekind != TYPE_TYPEDEF ) {
; 694  :         if ( sym->cvtyperef ) {

	movzx	ecx, WORD PTR [rsi+64]
	test	cx, cx
	je	SHORT $LN15@cv_write_s

; 695  :             cv->ps_udt->type = sym->cvtyperef;

	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+4], cx

; 696  :         } else {

	jmp	SHORT $LN16@cv_write_s
$LN15@cv_write_s:

; 697  :             cv->ps_udt->type = GetTyperef( sym, Ofssize );

	movzx	edx, r13b
	mov	rcx, rsi
	call	GetTyperef
	mov	rcx, QWORD PTR [rbx]
	mov	WORD PTR [rcx+4], ax
$LN16@cv_write_s:

; 698  :         }
; 699  : 
; 700  :         /* Some typedefs won't get a valid type (<name> TYPEDEF PROTO ...).
; 701  :          * In such cases just skip the type!
; 702  :          */
; 703  :         if ( cv->ps_udt->type == 0 )

	mov	rcx, QWORD PTR [rbx]
	cmp	WORD PTR [rcx+4], 0
	je	$LN40@cv_write_s

; 704  :             return;
; 705  : 
; 706  :         DebugMsg(( "cv_write_symbol(%X): TYPE=%s typeref=%Xh\n", GetPos(cv->symbols, cv->ps), sym->name, cv->ps_udt->type ));
; 707  :         cv->ps += len;

	movsxd	rax, r12d
	add	rcx, rax
	mov	QWORD PTR [rbx], rcx

; 708  :         SetPrefixName( cv->ps, sym->name, sym->name_size );

	movzx	eax, BYTE PTR [rsi+72]
	mov	BYTE PTR [rcx], al
	inc	QWORD PTR [rbx]
	movzx	r8d, BYTE PTR [rsi+72]
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rbx]
	call	memcpy
	movzx	eax, BYTE PTR [rsi+72]
	add	QWORD PTR [rbx], rax

; 974  :     }
; 975  :     return;
; 976  : }

	add	rsp, 56					; 00000038H
	pop	r13
	pop	r12
	pop	rsi
	pop	rbx
	ret	0
$LN14@cv_write_s:

; 709  :         return;
; 710  :     }
; 711  : 
; 712  :     /* rest is SYM_INTERNAL */
; 713  :     /* there are 3 types of INTERNAL symbols:
; 714  :      * - numeric constants ( equates, memtype MT_EMPTY )
; 715  :      * - code labels, memtype == MT_NEAR | MT_FAR
; 716  :      *   - procs
; 717  :      *   - simple labels
; 718  :      * - data labels, memtype != MT_NEAR | MT_FAR
; 719  :      */
; 720  : 
; 721  :     if ( sym->isproc && Options.debug_ext >= CVEX_REDUCED ) { /* v2.10: no locals for -Zi0 */

	movzx	ecx, BYTE PTR [rsi+41]
	mov	QWORD PTR [rsp+104], rbp
	mov	QWORD PTR [rsp+112], rdi
	mov	QWORD PTR [rsp+120], r14
	mov	QWORD PTR [rsp+48], r15
	test	cl, 8
	je	$LN18@cv_write_s
	cmp	BYTE PTR Options+3, 1
	jb	$LN18@cv_write_s

; 722  : 
; 723  :         proc = (struct dsym *)sym;
; 724  : 
; 725  :         /* for PROCs, scan parameters and locals and create their types. */
; 726  : 
; 727  :         /* scan local symbols */
; 728  :         locals[0] = proc->e.procinfo->paralist;

	mov	rcx, QWORD PTR [rsi+96]
	lea	r14, QWORD PTR cnt$[rsp]

; 729  :         locals[1] = proc->e.procinfo->locallist;
; 730  :         for ( i = 0; i < 2; i++ ) {

	xor	edx, edx
	mov	r15d, edx
	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR locals$[rsp], rax
	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR locals$[rsp+8], rax
$LL4@cv_write_s:

; 731  :             cnt[i] = 0;
; 732  :             for ( lcl = locals[i]; lcl; lcl = lcl->nextparam ) {

	mov	rdi, QWORD PTR locals$[rsp+r15*8]
	mov	DWORD PTR [r14], edx
	test	rdi, rdi
	je	SHORT $LN2@cv_write_s
	mov	ebp, edx
$LL7@cv_write_s:

; 733  :                 cv_typeref typeref;
; 734  :                 cnt[i]++;

	inc	ebp

; 735  :                 typeref = ( lcl->sym.mem_type == MT_PTR ? cv_write_ptr_type( cv, &lcl->sym ) : GetTyperef( &lcl->sym, Ofssize ) );

	cmp	DWORD PTR [rdi+36], 195			; 000000c3H
	jne	SHORT $LN53@cv_write_s
	mov	rdx, rdi
	mov	rcx, rbx
	call	cv_write_ptr_type
	jmp	SHORT $LN54@cv_write_s
$LN53@cv_write_s:
	movzx	edx, r13b
	mov	rcx, rdi
	call	GetTyperef
$LN54@cv_write_s:

; 736  :                 if ( lcl->sym.isarray ) {

	test	BYTE PTR [rdi+41], 2
	je	SHORT $LN20@cv_write_s

; 737  :                     cv_write_array_type( cv, &lcl->sym, typeref, Ofssize );

	movzx	r9d, r13b
	movzx	r8d, ax
	mov	rdx, rdi
	mov	rcx, rbx
	call	cv_write_array_type

; 738  :                     typeref = cv->currtype - 1;

	movzx	eax, WORD PTR [rbx+44]
	dec	ax
$LN20@cv_write_s:

; 739  :                 }
; 740  :                 lcl->sym.ext_idx1 = typeref;

	mov	WORD PTR [rdi+88], ax
	mov	rdi, QWORD PTR [rdi+112]
	test	rdi, rdi
	jne	SHORT $LL7@cv_write_s
	mov	DWORD PTR [r14], ebp
	xor	edx, edx
$LN2@cv_write_s:

; 729  :         locals[1] = proc->e.procinfo->locallist;
; 730  :         for ( i = 0; i < 2; i++ ) {

	inc	r15
	add	r14, 4
	cmp	r15, 2
	jl	SHORT $LL4@cv_write_s

; 741  :             }
; 742  :         }
; 743  : 
; 744  :         DebugMsg(( "cv_write_symbol(%X): PROC=%s\n", GetPos(cv->symbols, cv->ps), sym->name ));
; 745  :         if ( Ofssize == USE16 ) {
; 746  :             cv->ps_p16->sr.size = sizeof( struct cv_symrec_lproc16 ) - sizeof(uint_16) + 1 + sym->name_size;

	movzx	ecx, BYTE PTR [rsi+72]
	mov	rax, QWORD PTR [rbx]
	test	r13b, r13b
	jne	$LN21@cv_write_s
	add	cx, 28

; 747  :             cv->ps_p16->sr.type = (sym->ispublic ? S_GPROC16 : S_LPROC16);
; 748  :             cv->ps_p16->pParent = 0;  /* filled by CVPACK */
; 749  :             cv->ps_p16->pEnd = 0;     /* filled by CVPACK */
; 750  :             cv->ps_p16->pNext = 0;    /* filled by CVPACK */
; 751  :             cv->ps_p16->proc_length = sym->total_size;
; 752  :             cv->ps_p16->debug_start = ((struct dsym *)sym)->e.procinfo->size_prolog;
; 753  :             cv->ps_p16->debug_end = sym->total_size;
; 754  :             cv->ps_p16->offset = 0;
; 755  :             cv->ps_p16->segment = 0;
; 756  :             cv->ps_p16->proctype = cv->currtype; /* typeref LF_PROCEDURE */
; 757  :             cv->ps_p16->flags = ( sym->mem_type == MT_FAR ? CV_PROCF_FAR : 0 );

	mov	r14d, 4
	mov	WORD PTR [rax], cx
	movzx	eax, BYTE PTR [rsi+40]
	and	al, 128					; 00000080H
	movzx	ecx, al

; 758  :             rlctype = FIX_PTR16;

	lea	edi, QWORD PTR [r14+5]
	mov	eax, 33407				; 0000827fH

; 759  :             ofs = offsetof( struct cv_symrec_lproc16, offset );

	lea	ebp, QWORD PTR [rdi+13]
	or	cx, ax
	mov	rax, QWORD PTR [rbx]
	shr	cx, 7
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+4], edx
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+8], edx
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+12], edx
	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rsi+56]
	mov	WORD PTR [rcx+16], ax
	mov	rax, QWORD PTR [rsi+96]
	movzx	ecx, BYTE PTR [rax+85]
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+18], cx
	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rsi+56]
	mov	WORD PTR [rcx+20], ax
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+22], dx
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+24], dx
	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rbx+44]
	mov	WORD PTR [rcx+26], ax
	mov	ecx, edx
	cmp	DWORD PTR [rsi+36], 130			; 00000082H
	mov	rax, QWORD PTR [rbx]
	cmove	ecx, r14d
	mov	BYTE PTR [rax+28], cl

; 760  :         } else {

	jmp	$LN22@cv_write_s
$LN21@cv_write_s:

; 761  :             cv->ps_p32->sr.size = sizeof( struct cv_symrec_lproc32 ) - sizeof(uint_16) + 1 + sym->name_size;

	add	cx, 36					; 00000024H

; 762  :             cv->ps_p32->sr.type = (sym->ispublic ? S_GPROC32 : S_LPROC32 );
; 763  :             cv->ps_p32->pParent = 0; /* filled by CVPACK */
; 764  :             cv->ps_p32->pEnd = 0;    /* filled by CVPACK */
; 765  :             cv->ps_p32->pNext = 0;   /* filled by CVPACK */
; 766  :             cv->ps_p32->proc_length = sym->total_size;
; 767  :             cv->ps_p32->debug_start = ((struct dsym *)sym)->e.procinfo->size_prolog;
; 768  :             cv->ps_p32->debug_end = sym->total_size;
; 769  :             cv->ps_p32->offset = 0;
; 770  :             cv->ps_p32->segment = 0;
; 771  :             cv->ps_p32->proctype = cv->currtype; /* typeref LF_PROCEDURE */
; 772  : #if STACKBASESUPP
; 773  :             cv->ps_p32->flags = ( ( sym->mem_type == MT_FAR ? CV_PROCF_FAR : 0 ) | ( proc->e.procinfo->fpo ? CV_PROCF_FPO : 0 ) );
; 774  : #else
; 775  :             cv->ps_p32->flags = ( sym->mem_type == MT_FAR ? CV_PROCF_FAR : 0 );
; 776  : #endif
; 777  :             rlctype = FIX_PTR32;

	mov	edi, 10
	mov	WORD PTR [rax], cx
	movzx	eax, BYTE PTR [rsi+40]
	shr	al, 7
	movzx	ecx, al

; 778  :             ofs = offsetof( struct cv_symrec_lproc32, offset );

	lea	ebp, QWORD PTR [rdi+18]
	mov	eax, 516				; 00000204H
	or	cx, ax
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+4], edx
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+8], edx
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+12], edx
	mov	rcx, QWORD PTR [rbx]
	mov	eax, DWORD PTR [rsi+56]
	mov	DWORD PTR [rcx+16], eax
	mov	rax, QWORD PTR [rsi+96]
	movzx	ecx, BYTE PTR [rax+85]
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+20], ecx
	mov	rcx, QWORD PTR [rbx]
	mov	eax, DWORD PTR [rsi+56]
	mov	DWORD PTR [rcx+24], eax
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+28], edx
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+32], dx
	movzx	eax, WORD PTR [rbx+44]
	mov	rcx, QWORD PTR [rbx]
	mov	WORD PTR [rcx+34], ax
	mov	eax, 4
	cmp	DWORD PTR [rsi+36], 130			; 00000082H
	cmove	edx, eax
	mov	rax, QWORD PTR [rsi+96]
	movzx	ecx, BYTE PTR [rax+84]
	mov	rax, QWORD PTR [rbx]
	shr	cl, 7
	or	dl, cl
	mov	BYTE PTR [rax+36], dl
$LN22@cv_write_s:

; 779  :         }
; 780  :         cv_write_type_procedure( cv, sym, cnt[0] );

	mov	r8d, DWORD PTR cnt$[rsp]
	mov	rdx, rsi
	mov	rcx, rbx
	call	cv_write_type_procedure
	xor	r14d, r14d
	mov	r15, rsi
	jmp	$LN27@cv_write_s
$LN18@cv_write_s:
	mov	eax, DWORD PTR [rsi+36]
	sub	eax, 129				; 00000081H
	cmp	eax, 1
	jbe	$LN25@cv_write_s

; 801  :             DebugMsg(( "cv_write_symbol(%X): LABEL32=%s\n", GetPos(cv->symbols,cv->ps), sym->name ));
; 802  :         }
; 803  : #if EQUATESYMS
; 804  :     } else if ( sym->isequate ) {

	test	BYTE PTR [rsi+40], 16
	je	$LN28@cv_write_s

; 805  :         cv->ps_con->sr.size = len - sizeof(uint_16) + 1 + sym->name_size;

	movzx	eax, BYTE PTR [rsi+72]

; 806  :         cv->ps_con->sr.type = S_CONSTANT;

	mov	ecx, 3
	dec	ax
	add	ax, r12w
	mov	WORD PTR [rdx], ax
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], cx

; 807  :         cv->ps_con->type = cv_abs_type.uvalue;

	mov	ecx, 1
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+4], cx

; 808  :         if ( sym->value >= LF_NUMERIC ) {

	cmp	DWORD PTR [rsi+16], 32768		; 00008000H
	jl	SHORT $LN30@cv_write_s

; 809  :             uint_8 *tmp;
; 810  :             cv->ps_con->value = LF_ULONG;

	mov	rax, QWORD PTR [rbx]
	mov	ecx, 32772				; 00008004H
	mov	WORD PTR [rax+6], cx

; 811  :             tmp = (uint_8 *)&cv->ps_con->value;
; 812  :             *(uint_32 *)tmp = sym->value;

	mov	rcx, QWORD PTR [rbx]
	mov	eax, DWORD PTR [rsi+16]
	mov	DWORD PTR [rcx+6], eax

; 813  :         } else {

	jmp	SHORT $LN31@cv_write_s
$LN30@cv_write_s:

; 814  :             cv->ps_con->value = sym->value;

	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rsi+16]
	mov	WORD PTR [rcx+6], ax
$LN31@cv_write_s:

; 815  :         }
; 816  :         cv->ps += len;

	add	QWORD PTR [rbx], r12
	mov	rcx, QWORD PTR [rbx]

; 817  :         SetPrefixName( cv->ps, sym->name, sym->name_size );

	movzx	eax, BYTE PTR [rsi+72]
	mov	BYTE PTR [rcx], al
	inc	QWORD PTR [rbx]
	movzx	r8d, BYTE PTR [rsi+72]
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rbx]
	call	memcpy
	movzx	eax, BYTE PTR [rsi+72]
	add	QWORD PTR [rbx], rax

; 818  :         return;

	jmp	$LN96@cv_write_s
$LN28@cv_write_s:

; 819  : #endif
; 820  :     } else {
; 821  :         /* v2.10: set S_GDATA[16|32] if symbol is public */
; 822  :         cv_typeref typeref;
; 823  : 
; 824  :         if ( sym->isarray ) {

	test	cl, 2
	je	SHORT $LN32@cv_write_s

; 825  :             typeref = cv->currtype;

	movzx	edi, WORD PTR [rbx+44]

; 826  :             cv_write_array_type( cv, sym, 0, Ofssize );

	xor	r8d, r8d
	movzx	r9d, r13b
	mov	rdx, rsi
	mov	rcx, rbx
	call	cv_write_array_type

; 827  :         } else

	jmp	SHORT $LN33@cv_write_s
$LN32@cv_write_s:

; 828  :             typeref = GetTyperef( sym, Ofssize );

	movzx	edx, r13b
	mov	rcx, rsi
	call	GetTyperef
	movzx	edi, ax
$LN33@cv_write_s:

; 829  : 
; 830  :         if ( Ofssize == USE16 ) {

	test	r13b, r13b
	jne	SHORT $LN34@cv_write_s

; 831  :             cv->ps_d16->sr.size = sizeof( struct cv_symrec_ldata16 ) - sizeof(uint_16) + 1 + sym->name_size;

	mov	rcx, QWORD PTR [rbx]

; 832  :             cv->ps_d16->sr.type = (sym->ispublic ? S_GDATA16 : S_LDATA16 );

	mov	r14d, 0
	movzx	edx, BYTE PTR [rsi+72]
	add	dx, 9
	mov	WORD PTR [rcx], dx
	mov	ecx, r14d
	test	BYTE PTR [rsi+40], 128			; 00000080H
	mov	rax, QWORD PTR [rbx]
	setne	cl
	add	cx, 257					; 00000101H
	mov	WORD PTR [rax+2], cx

; 833  :             cv->ps_d16->offset = 0;

	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+4], r14w

; 834  :             cv->ps_d16->segment = 0;

	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+6], r14w

; 835  :             cv->ps_d16->type = typeref;

	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+8], di

; 836  :             rlctype = FIX_PTR16;

	lea	edi, QWORD PTR [r14+9]

; 837  :             ofs = offsetof( struct cv_symrec_ldata16, offset );

	lea	ebp, QWORD PTR [rdi-5]

; 838  :             DebugMsg(( "cv_write_symbol(%X): INTERN16=%s typeref=%Xh\n", GetPos(cv->symbols,cv->ps), sym->name, cv->ps_d16->type ));
; 839  :         } else {

	jmp	$LN97@cv_write_s
$LN34@cv_write_s:

; 840  :             cv->ps_d32->sr.size = sizeof( struct cv_symrec_ldata32 ) - sizeof(uint_16) + 1 + sym->name_size;

	movzx	ecx, BYTE PTR [rsi+72]
	mov	rax, QWORD PTR [rbx]
	add	cx, 11
	mov	WORD PTR [rax], cx

; 841  : #if CVOSUPP
; 842  :             if ( ( ModuleInfo.cv_opt & CVO_STATICTLS ) && ((struct dsym *)sym->segment)->e.seginfo->clsym &&

	test	BYTE PTR ModuleInfo+427, 1
	je	SHORT $LN36@cv_write_s
	mov	rax, QWORD PTR [rsi+24]
	mov	rcx, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rcx+80]
	test	rax, rax
	je	SHORT $LN36@cv_write_s
	mov	rax, QWORD PTR [rax+8]
	lea	r8, OFFSET FLAT:$SG11283
	sub	r8, rax
	npad	9
$LL91@cv_write_s:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN92@cv_write_s
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL91@cv_write_s
$LN92@cv_write_s:
	test	edx, edx
	jne	SHORT $LN36@cv_write_s

; 843  :                 strcmp( ((struct dsym *)sym->segment)->e.seginfo->clsym->name, "TLS" ) == 0 )
; 844  :                 cv->ps_d32->sr.type = (sym->ispublic ? S_GTHREAD32 : S_LTHREAD32 );

	test	BYTE PTR [rsi+40], 128			; 00000080H
	mov	r14d, 0
	mov	ecx, r14d
	setne	cl
	add	cx, 525					; 0000020dH
	jmp	SHORT $LN98@cv_write_s
$LN36@cv_write_s:

; 845  :             else
; 846  : #endif
; 847  :             cv->ps_d32->sr.type = (sym->ispublic ? S_GDATA32 : S_LDATA32 );

	test	BYTE PTR [rsi+40], 128			; 00000080H
	mov	r14d, 0
	mov	ecx, r14d
	setne	cl
	add	cx, 513					; 00000201H
$LN98@cv_write_s:
	mov	rax, QWORD PTR [rbx]

; 848  :             cv->ps_d32->offset = 0;
; 849  :             cv->ps_d32->segment = 0;
; 850  :             cv->ps_d32->type = typeref;
; 851  :             rlctype = FIX_PTR32;
; 852  :             ofs = offsetof( struct cv_symrec_ldata32, offset );

	mov	ebp, 4
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+4], r14d
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+8], r14w
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+10], di
	jmp	$LN99@cv_write_s
$LN25@cv_write_s:

; 781  : 
; 782  :     } else if ( sym->mem_type == MT_NEAR || sym->mem_type == MT_FAR ) {
; 783  : 
; 784  :         if ( Ofssize == USE16 ) {
; 785  :             cv->ps_l16->sr.size = sizeof( struct cv_symrec_label16 ) - sizeof(uint_16) + 1 + sym->name_size;

	movzx	eax, BYTE PTR [rsi+72]

; 787  :             cv->ps_l16->offset = 0;

	xor	r14d, r14d
	test	r13b, r13b
	jne	SHORT $LN26@cv_write_s

; 786  :             cv->ps_l16->sr.type = S_LABEL16;

	add	ax, 8
	mov	ecx, 265				; 00000109H
	mov	WORD PTR [rdx], ax

; 788  :             cv->ps_l16->segment = 0;
; 789  :             cv->ps_l16->flags = ( sym->mem_type == MT_FAR ? CV_PROCF_FAR : 0 );

	mov	edx, 4
	mov	rax, QWORD PTR [rbx]

; 790  :             rlctype = FIX_PTR16;
; 791  :             ofs = offsetof( struct cv_symrec_label16, offset );

	mov	ebp, edx
	lea	edi, QWORD PTR [rdx+5]
	mov	WORD PTR [rax+2], cx
	mov	ecx, r14d
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+4], r14w
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+6], r14w
	cmp	DWORD PTR [rsi+36], 130			; 00000082H
	mov	rax, QWORD PTR [rbx]
	cmove	ecx, edx
	mov	BYTE PTR [rax+8], cl

; 792  :             DebugMsg(( "cv_write_symbol(%X): LABEL16=%s\n", GetPos(cv->symbols,cv->ps), sym->name ));
; 793  :         } else {

	jmp	SHORT $LN97@cv_write_s
$LN26@cv_write_s:

; 794  :             cv->ps_l32->sr.size = sizeof( struct cv_symrec_label32 ) - sizeof(uint_16) + 1 + sym->name_size;

	add	ax, 10

; 795  :             cv->ps_l32->sr.type = S_LABEL32;

	mov	ecx, 521				; 00000209H
	mov	WORD PTR [rdx], ax

; 796  :             cv->ps_l32->offset = 0;
; 797  :             cv->ps_l32->segment = 0;
; 798  :             cv->ps_l32->flags = ( sym->mem_type == MT_FAR ? CV_PROCF_FAR : 0 );

	mov	edx, 4
	mov	rax, QWORD PTR [rbx]

; 800  :             ofs = offsetof( struct cv_symrec_label32, offset );

	mov	ebp, edx
	mov	WORD PTR [rax+2], cx
	mov	ecx, r14d
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+4], r14d
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+8], r14w
	cmp	DWORD PTR [rsi+36], 130			; 00000082H
	mov	rax, QWORD PTR [rbx]
	cmove	ecx, edx
	mov	BYTE PTR [rax+10], cl
$LN99@cv_write_s:

; 799  :             rlctype = FIX_PTR32;

	mov	edi, 10
$LN97@cv_write_s:

; 800  :             ofs = offsetof( struct cv_symrec_label32, offset );

	mov	r15, QWORD PTR proc$[rsp]
$LN27@cv_write_s:

; 853  :             DebugMsg(( "cv_write_symbol(%X): INTERN32=%s typeref=%Xh\n", GetPos(cv->symbols,cv->ps), sym->name, cv->ps_d16->type ));
; 854  :         }
; 855  :     }
; 856  :     cv->ps += ofs;

	mov	eax, ebp

; 857  :     cv->symbols->e.seginfo->current_loc = cv->symbols->e.seginfo->start_loc + ( cv->ps - cv->symbols->e.seginfo->CodeBuffer );
; 858  : #if COFF_SUPPORT
; 859  :     /* v2.10: also handle FIX_PTR16 for COFF */
; 860  :     //if ( rlctype == FIX_PTR32 && Options.output_format == OFORMAT_COFF ) {
; 861  :     if ( Options.output_format == OFORMAT_COFF ) {
; 862  :         /* COFF has no "far" fixups. Instead Masm creates a
; 863  :          * section-relative fixup + a section fixup.
; 864  :          */
; 865  :         fixup = CreateFixup( sym, FIX_OFF32_SECREL, OPTJ_NONE );

	xor	r8d, r8d
	add	QWORD PTR [rbx], rax
	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rcx+8]
	sub	eax, DWORD PTR [rcx+16]
	add	eax, DWORD PTR [rbx]
	mov	DWORD PTR [rcx+12], eax
	mov	rcx, rsi
	cmp	DWORD PTR Options+144, 2
	jne	SHORT $LN38@cv_write_s
	lea	edx, QWORD PTR [r8+13]
	call	CreateFixup

; 866  :         fixup->locofs = cv->symbols->e.seginfo->current_loc;

	mov	rcx, QWORD PTR [rbx+8]
	mov	rdx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rdx+12]
	mov	DWORD PTR [rax+20], ecx

; 867  :         store_fixup( fixup, cv->symbols, (int_32 *)cv->ps );

	mov	rcx, rax
	mov	r8, QWORD PTR [rbx]
	mov	rdx, QWORD PTR [rbx+8]
	call	store_fixup

; 868  :         fixup = CreateFixup( sym, FIX_SEG, OPTJ_NONE );

	xor	r8d, r8d
	mov	rcx, rsi
	lea	edx, QWORD PTR [r8+8]
	call	CreateFixup

; 869  :         //fixup->locofs += sizeof( int_32 );
; 870  :         fixup->locofs = cv->symbols->e.seginfo->current_loc + ( rlctype == FIX_PTR32 ? sizeof( int_32 ) : sizeof ( int_16 ) );

	mov	rcx, QWORD PTR [rbx+8]
	cmp	edi, 10
	mov	r8d, 4
	mov	rdx, QWORD PTR [rcx+96]
	mov	ecx, 2
	cmove	ecx, r8d
	add	ecx, DWORD PTR [rdx+12]

; 871  :         store_fixup( fixup, cv->symbols, (int_32 *)cv->ps );
; 872  :     } else {

	jmp	SHORT $LN100@cv_write_s
$LN38@cv_write_s:

; 873  : #endif
; 874  :         fixup = CreateFixup( sym, rlctype, OPTJ_NONE );

	mov	edx, edi
	call	CreateFixup

; 875  :         fixup->locofs = cv->symbols->e.seginfo->current_loc;

	mov	rcx, QWORD PTR [rbx+8]
	mov	rdx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rdx+12]
$LN100@cv_write_s:
	mov	DWORD PTR [rax+20], ecx

; 876  :         /* todo: for OMF, delay fixup store until checkflush has been called! */
; 877  :         store_fixup( fixup, cv->symbols, (int_32 *)cv->ps );

	mov	rcx, rax
	mov	r8, QWORD PTR [rbx]
	mov	rdx, QWORD PTR [rbx+8]
	call	store_fixup

; 878  : #if COFF_SUPPORT
; 879  :     }
; 880  : #endif
; 881  :     cv->ps += len - ofs;

	sub	r12d, ebp
	mov	eax, r12d
	add	QWORD PTR [rbx], rax
	mov	rcx, QWORD PTR [rbx]

; 882  : 
; 883  :     SetPrefixName( cv->ps, sym->name, sym->name_size );

	movzx	eax, BYTE PTR [rsi+72]
	mov	BYTE PTR [rcx], al
	inc	QWORD PTR [rbx]
	movzx	r8d, BYTE PTR [rsi+72]
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rbx]
	call	memcpy
	movzx	eax, BYTE PTR [rsi+72]
	add	QWORD PTR [rbx], rax

; 884  : 
; 885  :     /* for PROCs, scan parameters and locals.
; 886  :      * to mark the block's end, write an ENDBLK item.
; 887  :      */
; 888  :     if ( sym->isproc && Options.debug_ext >= CVEX_REDUCED ) { /* v2.10: no locals for -Zi0 */

	test	BYTE PTR [rsi+41], 8
	je	$LN96@cv_write_s
	cmp	BYTE PTR Options+3, 1
	jb	$LN96@cv_write_s

; 889  : 
; 890  :         /* scan local symbols again */
; 891  :         for ( i = 0; i < 2 ; i++ ) {

	mov	rbp, r14
	mov	QWORD PTR $T1[rsp], r14
	lea	r12, OFFSET FLAT:__ImageBase
$LL10@cv_write_s:

; 892  :             for ( lcl = locals[i]; lcl; lcl = lcl->nextparam ) {

	mov	rdi, QWORD PTR locals$[rsp+rbp*8]
	test	rdi, rdi
	je	$LN8@cv_write_s
	mov	ebp, 213				; 000000d5H
$LL13@cv_write_s:

; 893  : 
; 894  :                 /* FASTCALL register argument? */
; 895  :                 if ( lcl->sym.state == SYM_TMACRO ) {

	cmp	DWORD PTR [rdi+32], 10
	jne	$LN41@cv_write_s

; 896  :                     len = sizeof( struct cv_symrec_register );
; 897  :                     cv->ps = checkflush( cv->symbols, cv->ps, 1 + lcl->sym.name_size + len, cv->param );

	mov	rcx, QWORD PTR [rbx+8]
	mov	esi, 8
	movzx	r8d, BYTE PTR [rdi+72]
	mov	r9, QWORD PTR [rbx+32]
	add	r8d, 9
	mov	rdx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [rcx+96]
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rbx], rax

; 898  :                     cv->ps_reg->sr.size = sizeof( struct cv_symrec_register ) - sizeof(uint_16) + 1 + lcl->sym.name_size;
; 899  :                     cv->ps_reg->sr.type = S_REGISTER;
; 900  :                     cv->ps_reg->type = lcl->sym.ext_idx1;
; 901  :                     cv->ps_reg->registr = cv_get_register( &lcl->sym );

	movzx	r10d, r14w
	movzx	ecx, BYTE PTR [rdi+72]
	lea	r9, QWORD PTR [rdi+48]
	add	cx, 7
	mov	edx, r14d
	mov	WORD PTR [rax], cx
	mov	ecx, 2
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], cx
	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rdi+88]
	mov	WORD PTR [rcx+4], ax
	npad	3
$LL58@cv_write_s:
	movzx	eax, WORD PTR [r9]
	test	ax, ax
	je	SHORT $LN56@cv_write_s
	movzx	eax, ax
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR SpecialTable[r12+rcx*4+10]
	mov	r8d, DWORD PTR SpecialTable[r12+rcx*4]
	inc	ax
	test	r8b, 2
	je	SHORT $LN60@cv_write_s
	add	ax, si
	jmp	SHORT $LN64@cv_write_s
$LN60@cv_write_s:
	test	r8b, 4
	je	SHORT $LN62@cv_write_s
	add	ax, 16
	jmp	SHORT $LN64@cv_write_s
$LN62@cv_write_s:
	test	r8d, 24576				; 00006000H
	je	SHORT $LN64@cv_write_s
	add	ax, 24
$LN64@cv_write_s:
	mov	ecx, edx
	shl	ax, cl
	or	r10w, ax
$LN56@cv_write_s:
	add	edx, esi
	add	r9, 2
	cmp	edx, 16
	jl	SHORT $LL58@cv_write_s
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+6], r10w
	jmp	$LN51@cv_write_s
$LN41@cv_write_s:

; 902  :                 } else if ( Ofssize == USE16 ) {

	test	r13b, r13b
	jne	SHORT $LN43@cv_write_s

; 903  :                     len = sizeof( struct cv_symrec_bprel16 );
; 904  :                     cv->ps = checkflush( cv->symbols, cv->ps, 1 + lcl->sym.name_size + len, cv->param );

	mov	rcx, QWORD PTR [rbx+8]
	mov	esi, 8
	movzx	r8d, BYTE PTR [rdi+72]
	mov	r9, QWORD PTR [rbx+32]
	add	r8d, 9
	mov	rdx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [rcx+96]
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rbx], rax

; 905  :                     cv->ps_br16->sr.size = sizeof( struct cv_symrec_bprel16 ) - sizeof(uint_16) + 1 + lcl->sym.name_size;

	movzx	ecx, BYTE PTR [rdi+72]
	add	cx, 7
	mov	WORD PTR [rax], cx

; 906  :                     cv->ps_br16->sr.type = S_BPREL16;

	mov	ecx, 256				; 00000100H
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], cx

; 907  :                     cv->ps_br16->offset = lcl->sym.offset;

	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rdi+16]
	mov	WORD PTR [rcx+4], ax

; 908  :                     cv->ps_br16->type = lcl->sym.ext_idx1;

	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rdi+88]
	mov	WORD PTR [rcx+6], ax

; 909  :                     DebugMsg(( "cv_write_symbol(%X): proc=%s, S_BPREL16, var=%s [memt=%X typeref=%X]\n",
; 910  :                               GetPos(cv->symbols,cv->ps), proc->sym.name, lcl->sym.name, lcl->sym.mem_type, cv->ps_br16->type ));
; 911  :                 } else {

	jmp	$LN51@cv_write_s
$LN43@cv_write_s:

; 912  : #if STACKBASESUPP || AMD64_SUPPORT
; 913  :                     /* v2.11: use S_REGREL if 64-bit or frame reg != [E|BP */
; 914  :                     if (
; 915  : #if AMD64_SUPPORT
; 916  :                         Ofssize == USE64
; 917  : #if STACKBASESUPP
; 918  :                         || ( GetRegNo( proc->e.procinfo->basereg ) != 5 )

	cmp	r13b, 2
	je	SHORT $LN47@cv_write_s
	mov	rax, QWORD PTR [r15+96]
	movzx	ecx, WORD PTR [rax+86]
	lea	rax, QWORD PTR [rcx+rcx*2]
	cmp	BYTE PTR SpecialTable[r12+rax*4+10], 5
	jne	SHORT $LN47@cv_write_s

; 948  :                         DebugMsg(( "cv_write_symbol(%X): proc=%s, S_REGREL32, var=%s [memt=%X typeref=%X]\n",
; 949  :                                   GetPos(cv->symbols,cv->ps), proc->sym.name, lcl->sym.name, lcl->sym.mem_type, cv->ps_rr32->type ));
; 950  :                     } else {
; 951  : #endif
; 952  :                         len = sizeof( struct cv_symrec_bprel32 );
; 953  :                         cv->ps = checkflush( cv->symbols, cv->ps, 1 + lcl->sym.name_size + len, cv->param );

	mov	rcx, QWORD PTR [rbx+8]
	mov	esi, 10
	movzx	r8d, BYTE PTR [rdi+72]
	mov	r9, QWORD PTR [rbx+32]
	add	r8d, 11
	mov	rdx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [rcx+96]
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rbx], rax

; 954  :                         cv->ps_br32->sr.size = sizeof( struct cv_symrec_bprel32 ) - sizeof(uint_16) + 1 + lcl->sym.name_size;

	movzx	ecx, BYTE PTR [rdi+72]
	add	cx, 9
	mov	WORD PTR [rax], cx

; 955  :                         cv->ps_br32->sr.type = S_BPREL32;

	mov	ecx, 512				; 00000200H
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], cx

; 956  :                         cv->ps_br32->offset = lcl->sym.offset;

	mov	rcx, QWORD PTR [rbx]
	mov	eax, DWORD PTR [rdi+16]
	mov	DWORD PTR [rcx+4], eax

; 957  :                         cv->ps_br32->type = lcl->sym.ext_idx1;

	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rdi+88]
	mov	WORD PTR [rcx+8], ax
	jmp	$LN51@cv_write_s
$LN47@cv_write_s:

; 919  : #endif
; 920  : #else
; 921  :                         GetRegNo( proc->e.procinfo->basereg ) != 5
; 922  : #endif
; 923  :                        ) {
; 924  : 
; 925  :                         len = sizeof( struct cv_symrec_regrel32 );
; 926  :                         cv->ps = checkflush( cv->symbols, cv->ps, 1 + lcl->sym.name_size + len, cv->param );

	mov	rcx, QWORD PTR [rbx+8]
	mov	esi, 12
	movzx	r8d, BYTE PTR [rdi+72]
	mov	r9, QWORD PTR [rbx+32]
	add	r8d, 13
	mov	rdx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [rcx+96]
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rbx], rax

; 927  :                         cv->ps_rr32->sr.size = sizeof( struct cv_symrec_regrel32 ) - sizeof(uint_16) + 1 + lcl->sym.name_size;

	movzx	ecx, BYTE PTR [rdi+72]
	add	cx, 11
	mov	WORD PTR [rax], cx

; 928  :                         cv->ps_rr32->sr.type = S_REGREL32;

	mov	ecx, 524				; 0000020cH
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], cx

; 929  :                         cv->ps_rr32->offset = lcl->sym.offset ;

	mov	rcx, QWORD PTR [rbx]
	mov	eax, DWORD PTR [rdi+16]
	mov	DWORD PTR [rcx+4], eax

; 930  :                         cv->ps_rr32->type = lcl->sym.ext_idx1;

	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rdi+88]
	mov	WORD PTR [rcx+10], ax

; 931  : #if AMD64_SUPPORT
; 932  :                         //if W64F_HABRAN recalculate parameters pozitions
; 933  :                         if (ModuleInfo.win64_flags & W64F_HABRAN){

	test	BYTE PTR ModuleInfo+413, 11
	je	SHORT $LN49@cv_write_s

; 934  :                           if (lcl->sym.isparam){

	test	BYTE PTR [rdi+41], 128			; 00000080H
	je	SHORT $LN49@cv_write_s

; 935  :                             int cnt = proc->e.procinfo->pushed_reg;

	mov	r8, QWORD PTR [r15+96]

; 936  :                             cnt = cnt * 8;

	mov	ecx, DWORD PTR [r8+64]

; 937  :                             cnt += lcl->sym.offset + proc->e.procinfo->localsize + proc->e.procinfo->xmmsize; //pointing to RSP
; 938  :                             cnt -= 8;     //pointing abowe RSP to the shadow space off RCX RDX R8 R9
; 939  :                             cv->ps_rr32->offset = cnt;

	mov	eax, DWORD PTR [r8+72]
	lea	edx, DWORD PTR [rax+rcx*8]
	mov	ecx, DWORD PTR [rdi+16]
	add	edx, DWORD PTR [r8+36]
	add	ecx, -8
	mov	rax, QWORD PTR [rbx]
	add	ecx, edx
	mov	DWORD PTR [rax+4], ecx
$LN49@cv_write_s:

; 940  :                           }
; 941  :                         }
; 942  :                         /* x64 register numbers are different */
; 943  :                         if ( SpecialTable[ proc->e.procinfo->basereg ].cpu == P_64 )

	mov	rax, QWORD PTR [r15+96]
	movzx	ecx, WORD PTR [rax+86]
	lea	rax, QWORD PTR [rcx+rcx*2]
	lea	rax, QWORD PTR [rax*4]
	cmp	WORD PTR SpecialTable[rax+r12+8], 112	; 00000070H
	jne	SHORT $LN50@cv_write_s

; 944  :                             cv->ps_rr32->reg = cv_get_x64_regno( proc->e.procinfo->basereg );

	lea	eax, DWORD PTR [rcx-115]
	cmp	ax, 7
	ja	SHORT $LN67@cv_write_s
	movzx	ecx, BYTE PTR reg64[rcx+r12-115]
	mov	eax, 328				; 00000148H
	add	cx, ax
	jmp	SHORT $LN66@cv_write_s
$LN67@cv_write_s:
	lea	eax, DWORD PTR [rcx-123]
	cmp	ax, 7
	ja	SHORT $LN68@cv_write_s
	add	cx, bp
	jmp	SHORT $LN66@cv_write_s
$LN68@cv_write_s:
	mov	eax, 253				; 000000fdH
	add	cx, ax
	jmp	SHORT $LN66@cv_write_s
$LN50@cv_write_s:

; 945  :                         else
; 946  : #endif
; 947  :                             cv->ps_rr32->reg = GetRegNo( proc->e.procinfo->basereg ) + CV_REG_START32;

	movzx	ecx, BYTE PTR SpecialTable[rax+r12+10]
	add	cx, 17
$LN66@cv_write_s:
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+8], cx
$LN51@cv_write_s:

; 958  :                         DebugMsg(( "cv_write_symbol(%X): proc=%s, S_BPREL32, var=%s [memt=%X typeref=%X]\n",
; 959  :                                   GetPos(cv->symbols,cv->ps), proc->sym.name, lcl->sym.name, lcl->sym.mem_type, cv->ps_br32->type ));
; 960  : #if STACKBASESUPP || AMD64_SUPPORT
; 961  :                     }
; 962  : #endif
; 963  :                 }
; 964  :                 lcl->sym.ext_idx1 = 0; /* to be safe, clear the temp. used field */

	mov	WORD PTR [rdi+88], r14w

; 965  :                 cv->ps += len;

	movsxd	rax, esi
	add	QWORD PTR [rbx], rax
	mov	rcx, QWORD PTR [rbx]

; 966  :                 SetPrefixName( cv->ps, lcl->sym.name, lcl->sym.name_size );

	movzx	eax, BYTE PTR [rdi+72]
	mov	BYTE PTR [rcx], al
	inc	QWORD PTR [rbx]
	movzx	r8d, BYTE PTR [rdi+72]
	mov	rdx, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rbx]
	call	memcpy
	movzx	eax, BYTE PTR [rdi+72]
	add	QWORD PTR [rbx], rax
	mov	rdi, QWORD PTR [rdi+112]
	test	rdi, rdi
	jne	$LL13@cv_write_s
	mov	rbp, QWORD PTR $T1[rsp]
$LN8@cv_write_s:

; 889  : 
; 890  :         /* scan local symbols again */
; 891  :         for ( i = 0; i < 2 ; i++ ) {

	inc	rbp
	mov	QWORD PTR $T1[rsp], rbp
	cmp	rbp, 2
	jl	$LL10@cv_write_s

; 967  :             }
; 968  :         }
; 969  : 
; 970  :         cv->ps = checkflush( cv->symbols, cv->ps, sizeof( struct cv_symrec_endblk ), cv->param );

	mov	rcx, QWORD PTR [rbx+8]
	mov	r8d, 4
	mov	r9, QWORD PTR [rbx+32]
	mov	rdx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [rcx+96]
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rbx], rax

; 971  :         cv->ps_eb->sr.size = sizeof( struct cv_symrec_endblk ) - sizeof(uint_16);

	mov	ecx, 2
	mov	WORD PTR [rax], cx

; 972  :         cv->ps_eb->sr.type = S_ENDBLK;

	mov	ecx, 6
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], cx

; 973  :         cv->ps += sizeof( struct cv_symrec_endblk );

	add	QWORD PTR [rbx], 4
$LN96@cv_write_s:
	mov	r14, QWORD PTR [rsp+120]
	mov	rdi, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+104]
	mov	r15, QWORD PTR [rsp+48]
$LN40@cv_write_s:

; 974  :     }
; 975  :     return;
; 976  : }

	add	rsp, 56					; 00000038H
	pop	r13
	pop	r12
	pop	rsi
	pop	rbx
	ret	0
cv_write_symbol ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
;	COMDAT cv_get_x64_regno
_TEXT	SEGMENT
regno$ = 8
cv_get_x64_regno PROC					; COMDAT

; 648  :     if ( regno >= T_RAX && regno <= T_RDI )

	lea	eax, DWORD PTR [rcx-115]
	cmp	ax, 7
	ja	SHORT $LN2@cv_get_x64

; 649  :         return( reg64[ regno - T_RAX ] + CV_REG_AMD64_START64 );

	movzx	eax, cx
	lea	rcx, OFFSET FLAT:reg64
	movzx	eax, BYTE PTR [rax+rcx-115]
	add	eax, 328				; 00000148H

; 654  : 
; 655  : }

	ret	0
$LN2@cv_get_x64:

; 650  :     if ( regno >= T_R8 && regno <= T_R15 )

	lea	eax, DWORD PTR [rcx-123]
	cmp	ax, 7

; 651  :         return( regno - T_R8 + CV_REG_AMD64_START64 + 8 );

	movzx	eax, cx
	ja	SHORT $LN3@cv_get_x64
	add	eax, 213				; 000000d5H

; 654  : 
; 655  : }

	ret	0
$LN3@cv_get_x64:

; 652  :     /* it's a 32-bit register r8d-r15d */
; 653  :     return( regno - T_R8D + CV_REG_AMD64_START32 );

	add	eax, 253				; 000000fdH

; 654  : 
; 655  : }

	ret	0
cv_get_x64_regno ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
;	COMDAT cv_get_register
_TEXT	SEGMENT
sym$ = 8
cv_get_register PROC					; COMDAT

; 613  :     uint_16 regno;
; 614  :     uint_16 rc = 0;

	xor	r10d, r10d
	lea	r8, QWORD PTR [rcx+48]
	mov	edx, r10d
	lea	r11, OFFSET FLAT:SpecialTable
$LL4@cv_get_reg:

; 619  :         if ( sym->regist[i] ) {

	movzx	eax, WORD PTR [r8]
	test	ax, ax
	je	SHORT $LN2@cv_get_reg

; 620  :             flags = GetValueSp( sym->regist[i] );

	movzx	eax, ax
	lea	rcx, QWORD PTR [rax+rax*2]

; 621  :             regno = 1 + GetRegNo( sym->regist[i] );

	movzx	eax, BYTE PTR [r11+rcx*4+10]
	mov	r9d, DWORD PTR [r11+rcx*4]
	inc	ax

; 622  :             if ( flags & OP_R16 )

	test	r9b, 2
	je	SHORT $LN6@cv_get_reg

; 623  :                 regno += 8;

	add	ax, 8
	jmp	SHORT $LN10@cv_get_reg
$LN6@cv_get_reg:

; 624  :             else if ( flags & OP_R32 )

	test	r9b, 4
	je	SHORT $LN8@cv_get_reg

; 625  :                 regno += 16;

	add	ax, 16
	jmp	SHORT $LN10@cv_get_reg
$LN8@cv_get_reg:

; 626  :             else if ( flags & OP_SR )

	test	r9d, 24576				; 00006000H
	je	SHORT $LN10@cv_get_reg

; 627  :                 regno += 24;

	add	ax, 24
$LN10@cv_get_reg:

; 628  :             rc |= regno << ( i * 8 );

	mov	ecx, edx
	shl	ax, cl
	or	r10w, ax
$LN2@cv_get_reg:

; 615  :     unsigned flags;
; 616  :     int i;
; 617  : 
; 618  :     for ( i = 0; i < 2; i++ ) {

	add	edx, 8
	add	r8, 2
	cmp	edx, 16
	jl	SHORT $LL4@cv_get_reg

; 629  :         }
; 630  :     }
; 631  :     return( rc );

	movzx	eax, r10w

; 632  : }

	ret	0
cv_get_register ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
;	COMDAT cv_write_type_procedure
_TEXT	SEGMENT
cv$ = 48
sym$ = 56
cnt$ = 64
cv_write_type_procedure PROC				; COMDAT

; 439  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx
	mov	ebx, r8d

; 440  :     int         size;
; 441  :     cv_typeref  *ptr;
; 442  :     struct dsym *param;
; 443  : 
; 444  :     size = sizeof( struct cv_typerec_procedure );
; 445  :     cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rcx, QWORD PTR [rcx+24]
	mov	rdi, rdx
	mov	r8d, 12
	mov	r9, QWORD PTR [rsi+32]
	mov	rax, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR [rsi+16]
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rsi+16], rax

; 446  :     cv->pt_pr->tr.size = size - sizeof(uint_16);

	mov	ecx, 10

; 447  :     cv->pt_pr->tr.leaf = LF_PROCEDURE;
; 448  :     cv->pt_pr->rvtype = cv_void.uvalue;
; 449  :     cv->pt_pr->call = 0;
; 450  :     cv->pt_pr->rsvd = 0;
; 451  :     cv->pt_pr->numparams = cnt;
; 452  :     cv->pt_pr->arglist = ++cv->currtype;
; 453  :     cv->pt += size;
; 454  :     size = sizeof( struct cv_typerec_arglist ) + cnt * sizeof( cv_typeref );

	lea	ebp, DWORD PTR [rbx*2+6]

; 455  :     cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	r8d, ebp
	mov	WORD PTR [rax], cx
	mov	ecx, 8
	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+2], cx
	mov	ecx, 3
	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+4], cx
	mov	rax, QWORD PTR [rsi+16]
	mov	BYTE PTR [rax+6], 0
	mov	rax, QWORD PTR [rsi+16]
	mov	BYTE PTR [rax+7], 0
	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+8], bx
	mov	rax, QWORD PTR [rsi+16]
	inc	WORD PTR [rsi+44]
	movzx	ecx, WORD PTR [rsi+44]
	mov	WORD PTR [rax+10], cx
	add	QWORD PTR [rsi+16], 12
	mov	rcx, QWORD PTR [rsi+24]
	mov	r9, QWORD PTR [rsi+32]
	mov	rdx, QWORD PTR [rsi+16]
	mov	rax, QWORD PTR [rcx+96]
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rsi+16], rax

; 456  :     cv->pt_al->tr.size = size - sizeof(uint_16);

	lea	ecx, DWORD PTR [rbp-2]
	mov	WORD PTR [rax], cx

; 457  :     cv->pt_al->tr.leaf = LF_ARGLIST;

	mov	ecx, 513				; 00000201H
	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+2], cx

; 458  :     cv->pt_al->argcount = cnt;

	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+4], bx

; 459  :     ptr = (cv_typeref *)(cv->pt + sizeof( struct cv_typerec_arglist ) );
; 460  :     /* fixme: order might be wrong ( is "push" order ) */
; 461  :     for ( param = ((struct dsym *)sym)->e.procinfo->paralist; param; param = param->nextparam ) {

	mov	rax, QWORD PTR [rdi+96]
	mov	rdx, QWORD PTR [rsi+16]
	add	rdx, 6
	mov	rax, QWORD PTR [rax+8]
	test	rax, rax
	je	SHORT $LN3@cv_write_t
	npad	6
$LL4@cv_write_t:

; 462  :         *ptr++ = param->sym.ext_idx1;

	movzx	ecx, WORD PTR [rax+88]
	mov	WORD PTR [rdx], cx
	lea	rdx, QWORD PTR [rdx+2]
	mov	rax, QWORD PTR [rax+112]
	test	rax, rax
	jne	SHORT $LL4@cv_write_t
$LN3@cv_write_t:

; 463  :     }
; 464  :     cv->pt += size;
; 465  :     cv->currtype++;
; 466  :     return;
; 467  : }

	mov	rbx, QWORD PTR [rsp+48]
	movsxd	rax, ebp
	add	QWORD PTR [rsi+16], rax
	inc	WORD PTR [rsi+44]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
cv_write_type_procedure ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
;	COMDAT cv_enum_fields
_TEXT	SEGMENT
tmpname$1 = 32
i$1$ = 80
sym$ = 80
enumfunc$ = 88
cv$ = 96
cc$ = 104
cv_enum_fields PROC					; COMDAT

; 408  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	push	rsi
	sub	rsp, 48					; 00000030H

; 409  :     unsigned i;
; 410  :     struct sfield  *curr;
; 411  :     for ( curr = sym->e.structinfo->head, i = 0; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR [rcx+96]
	xor	eax, eax
	mov	rsi, r9
	mov	DWORD PTR i$1$[rsp], eax
	mov	r10, rdx
	mov	rbp, rcx
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	je	$LN3@cv_enum_fi
	mov	QWORD PTR [rsp+104], rdi
$LL4@cv_enum_fi:

; 412  :         if ( curr->sym.name_size ) { /* has member a name? */

	cmp	BYTE PTR [rbx+72], 0
	je	SHORT $LN5@cv_enum_fi

; 413  :             enumfunc( sym, &curr->sym, cv, cc );

	mov	r9, rsi
	mov	rdx, rbx
	mov	rcx, rbp
	call	r10
	jmp	SHORT $LN15@cv_enum_fi
$LN5@cv_enum_fi:

; 414  :         } else if ( curr->sym.type ) { /* is member a type (struct, union, record)? */

	cmp	QWORD PTR [rbx+80], 0
	je	SHORT $LN7@cv_enum_fi

; 415  :             cc->ofs += curr->sym.offset;

	mov	eax, DWORD PTR [rbx+16]

; 416  :             cv_enum_fields( (struct dsym *)curr->sym.type, enumfunc, cv, cc );

	mov	r9, rsi
	add	DWORD PTR [rsi+8], eax
	mov	rdx, r10
	mov	rcx, QWORD PTR [rbx+80]
	call	cv_enum_fields

; 417  :             cc->ofs -= curr->sym.offset;

	mov	eax, DWORD PTR [rbx+16]
	sub	DWORD PTR [rsi+8], eax
	jmp	SHORT $LN15@cv_enum_fi
$LN7@cv_enum_fi:

; 418  :         } else if ( sym->sym.typekind == TYPE_UNION ) {

	cmp	BYTE PTR [rbp+66], 2
	jne	SHORT $LN2@cv_enum_fi

; 419  :             /* v2.11: include anonymous union members.
; 420  :              * to make the MS debugger work with those members, they must have a name -
; 421  :              * a temporary name is generated below which starts with "@@".
; 422  :              */
; 423  :             char *pold = curr->sym.name;

	mov	rdi, QWORD PTR [rbx+8]

; 424  :             char tmpname[8];
; 425  :             curr->sym.name_size = sprintf( tmpname, "@@%u", ++i );

	lea	rdx, OFFSET FLAT:$SG11082
	inc	eax
	lea	rcx, QWORD PTR tmpname$1[rsp]
	mov	r8d, eax
	mov	DWORD PTR i$1$[rsp], eax
	call	sprintf

; 426  :             curr->sym.name = tmpname;
; 427  :             enumfunc( sym, &curr->sym, cv, cc );

	mov	r8, QWORD PTR cv$[rsp]
	mov	r9, rsi
	mov	BYTE PTR [rbx+72], al
	mov	rdx, rbx
	lea	rax, QWORD PTR tmpname$1[rsp]
	mov	rcx, rbp
	mov	QWORD PTR [rbx+8], rax
	call	QWORD PTR enumfunc$[rsp]

; 428  :             curr->sym.name = pold;

	mov	QWORD PTR [rbx+8], rdi

; 429  :             curr->sym.name_size = 0;

	mov	BYTE PTR [rbx+72], 0
$LN15@cv_enum_fi:
	mov	r8, QWORD PTR cv$[rsp]
	mov	r10, QWORD PTR enumfunc$[rsp]
	mov	eax, DWORD PTR i$1$[rsp]
$LN2@cv_enum_fi:

; 409  :     unsigned i;
; 410  :     struct sfield  *curr;
; 411  :     for ( curr = sym->e.structinfo->head, i = 0; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+96]
	test	rbx, rbx
	jne	$LL4@cv_enum_fi
	mov	rdi, QWORD PTR [rsp+104]
$LN3@cv_enum_fi:

; 430  :         }
; 431  :     }
; 432  :     return;
; 433  : }

	add	rsp, 48					; 00000030H
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
cv_enum_fields ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
type$ = 64
mbr$ = 72
cv$ = 80
cc$ = 88
cv_memberproc PROC

; 359  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 360  :     uint_32     offset;
; 361  :     int         typelen;
; 362  :     int         size;
; 363  :     uint_8      *tmp;
; 364  : 
; 365  :     offset = ( type->sym.typekind == TYPE_RECORD ? 0 : mbr->offset + cc->ofs );

	xor	r14d, r14d
	mov	rbx, r8
	cmp	BYTE PTR [rcx+66], 4
	mov	rdi, rdx
	jne	SHORT $LN7@cv_memberp
	mov	esi, r14d
	jmp	SHORT $LN8@cv_memberp
$LN7@cv_memberp:
	mov	esi, DWORD PTR [rdx+16]
	add	esi, DWORD PTR [r9+8]
$LN8@cv_memberp:

; 366  :     typelen = ( offset >= LF_NUMERIC ? sizeof( uint_32 ) : 0 );
; 367  :     size = ( sizeof( struct cv_typerec_member ) + typelen + 1 + mbr->name_size + 3 ) & ~3;

	movzx	ebp, BYTE PTR [rdx+72]
	mov	eax, 4

; 368  :     cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rcx, QWORD PTR [r8+24]
	cmp	esi, 32768				; 00008000H
	mov	r9, QWORD PTR [r8+32]
	mov	r15d, r14d
	mov	rdx, QWORD PTR [rbx+16]
	cmovae	r15d, eax
	add	ebp, 12
	mov	rax, QWORD PTR [rcx+96]
	add	ebp, r15d
	and	ebp, -4
	mov	r8d, ebp
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rbx+16], rax

; 369  :     cv->pt_mbr->leaf = LF_MEMBER;

	mov	ecx, 1030				; 00000406H
	mov	WORD PTR [rax], cx

; 370  :     if ( mbr->isarray ) {

	test	BYTE PTR [rdi+41], 2
	je	SHORT $LN2@cv_memberp

; 371  :         cv->pt_mbr->type = mbr->ext_idx1;

	mov	rcx, QWORD PTR [rbx+16]
	movzx	eax, WORD PTR [rdi+88]
	mov	WORD PTR [rcx+2], ax

; 372  :         mbr->ext_idx1 = 0; /* reset the temporarily used field */

	mov	WORD PTR [rdi+88], r14w

; 373  :     } else

	jmp	SHORT $LN3@cv_memberp
$LN2@cv_memberp:

; 374  :         cv->pt_mbr->type = GetTyperef( mbr, USE16 );

	xor	edx, edx
	mov	rcx, rdi
	call	GetTyperef
	mov	rcx, QWORD PTR [rbx+16]
	mov	WORD PTR [rcx+2], ax
$LN3@cv_memberp:

; 375  : 
; 376  :     cv->pt_mbr->attribute.access = CV_ATTR_ACC_PUBLIC;

	mov	rax, QWORD PTR [rbx+16]

; 377  :     cv->pt_mbr->attribute.mprop = CV_ATTR_MPR_VANILLA;

	mov	ecx, 65507				; 0000ffe3H
	or	WORD PTR [rax+4], 3
	mov	rax, QWORD PTR [rbx+16]
	and	WORD PTR [rax+4], cx

; 378  :     cv->pt_mbr->attribute.pseudo = 0;

	mov	ecx, 65503				; 0000ffdfH
	mov	rax, QWORD PTR [rbx+16]
	and	WORD PTR [rax+4], cx

; 379  :     cv->pt_mbr->attribute.noinherit = 0;

	mov	ecx, 65471				; 0000ffbfH
	mov	rax, QWORD PTR [rbx+16]
	and	WORD PTR [rax+4], cx

; 380  :     cv->pt_mbr->attribute.noconstruct = 0;

	mov	ecx, 65407				; 0000ff7fH
	mov	rax, QWORD PTR [rbx+16]
	and	WORD PTR [rax+4], cx

; 381  :     cv->pt_mbr->attribute.reserved = 0;

	mov	rax, QWORD PTR [rbx+16]
	mov	BYTE PTR [rax+5], r14b

; 382  :     tmp = cv->pt + sizeof( struct cv_typerec_member );

	mov	rax, QWORD PTR [rbx+16]
	lea	r14, QWORD PTR [rax+8]

; 383  :     if ( typelen == 0 ) {

	test	r15d, r15d
	jne	SHORT $LN4@cv_memberp

; 384  :         cv->pt_mbr->offset = offset;

	mov	WORD PTR [rax+6], si

; 385  :     } else {

	jmp	SHORT $LN5@cv_memberp
$LN4@cv_memberp:

; 386  :         cv->pt_mbr->offset = LF_ULONG;

	mov	ecx, 32772				; 00008004H
	mov	WORD PTR [rax+6], cx

; 387  :         *(uint_32 *)tmp = offset;

	mov	DWORD PTR [r14], esi

; 388  :         tmp += sizeof( uint_32 );

	add	r14, 4
$LN5@cv_memberp:

; 389  :     }
; 390  :     DebugMsg(( "%u cv_memberproc(%Xh, %u): struct=%s MEMBER=%s [memt=%X], typeref=%X\n", cv->level, GetPos(cv->types, cv->pt), cc->cnt++, type->sym.name, mbr->name, mbr->mem_type, cv->pt_mbr->type ));
; 391  :     SetPrefixName( tmp, mbr->name, mbr->name_size );

	movzx	eax, BYTE PTR [rdi+72]
	mov	BYTE PTR [r14], al
	inc	r14
	movzx	r8d, BYTE PTR [rdi+72]
	mov	rcx, r14
	mov	rdx, QWORD PTR [rdi+8]
	call	memcpy

; 392  :     PadBytes( tmp, cv->types->e.seginfo->CodeBuffer );

	mov	rax, QWORD PTR [rbx+24]
	movzx	edx, BYTE PTR [rdi+72]
	add	rdx, r14
	mov	r8, rdx
	mov	rcx, QWORD PTR [rax+96]
	sub	r8, QWORD PTR [rcx+16]
	mov	rcx, r8
	and	ecx, 3
	je	SHORT $LN17@cv_memberp

; 389  :     }
; 390  :     DebugMsg(( "%u cv_memberproc(%Xh, %u): struct=%s MEMBER=%s [memt=%X], typeref=%X\n", cv->level, GetPos(cv->types, cv->pt), cc->cnt++, type->sym.name, mbr->name, mbr->mem_type, cv->pt_mbr->type ));
; 391  :     SetPrefixName( tmp, mbr->name, mbr->name_size );

	lea	r9, OFFSET FLAT:?padtab@?1??PadBytes@@9@9+3
	npad	9

; 392  :     PadBytes( tmp, cv->types->e.seginfo->CodeBuffer );

$LL10@cv_memberp:
	inc	r8
	lea	rdx, QWORD PTR [rdx+1]
	mov	rax, r9
	sub	rax, rcx
	mov	rcx, r8
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rdx-1], al
	and	ecx, 3
	jne	SHORT $LL10@cv_memberp
$LN17@cv_memberp:

; 393  :     cv->pt += size;
; 394  :     return;
; 395  : }

	mov	rsi, QWORD PTR [rsp+80]
	movsxd	rax, ebp
	add	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
cv_memberproc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
type$ = 48
mbr$ = 56
cv$ = 64
cc$ = 72
cv_cntproc PROC

; 326  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 327  :     int      numsize;
; 328  :     uint_32  offset;
; 329  : 
; 330  :     cc->cnt++;

	inc	DWORD PTR [r9]
	mov	rbx, rdx

; 331  :     offset = ( type->sym.typekind == TYPE_RECORD ? 0 : mbr->offset + cc->ofs );

	xor	edx, edx
	mov	rdi, r8
	cmp	BYTE PTR [rcx+66], 4
	mov	r10, rcx
	jne	SHORT $LN7@cv_cntproc
	mov	eax, edx
	jmp	SHORT $LN8@cv_cntproc
$LN7@cv_cntproc:
	mov	eax, DWORD PTR [rbx+16]
	add	eax, DWORD PTR [r9+8]
$LN8@cv_cntproc:

; 332  :     numsize = ( offset >= LF_NUMERIC ? sizeof( uint_32 ) : 0 );

	cmp	eax, 32768				; 00008000H
	mov	ecx, 4
	cmovae	edx, ecx

; 333  :     cc->size += ( sizeof( struct cv_typerec_member ) + numsize + mbr->name_size + 1 + 3 ) & ~3;

	movzx	ecx, BYTE PTR [rbx+72]
	add	ecx, 12
	add	ecx, edx
	and	ecx, -4					; fffffffcH
	add	DWORD PTR [r9+4], ecx

; 334  : 
; 335  :     /* field cv_typeref can only be queried from SYM_TYPE items! */
; 336  : 
; 337  :     if ( mbr->mem_type == MT_TYPE && mbr->type->cvtyperef == 0 ) {

	mov	ecx, DWORD PTR [rbx+36]
	cmp	ecx, 196				; 000000c4H
	jne	SHORT $LN2@cv_cntproc
	mov	rax, QWORD PTR [rbx+80]
	cmp	WORD PTR [rax+64], 0
	jne	SHORT $LN2@cv_cntproc

; 338  :         cv->level++;

	inc	DWORD PTR [r8+40]

; 339  :         cv_write_type( cv, mbr->type );

	mov	rcx, r8
	mov	rdx, QWORD PTR [rbx+80]
	call	cv_write_type

; 340  :         cv->level--;

	dec	DWORD PTR [rdi+40]
	jmp	SHORT $LN4@cv_cntproc
$LN2@cv_cntproc:

; 341  :     } else if ( mbr->mem_type == MT_BITS && mbr->cvtyperef == 0 ) {

	cmp	ecx, 193				; 000000c1H
	jne	SHORT $LN4@cv_cntproc
	cmp	WORD PTR [rbx+64], 0
	jne	SHORT $LN4@cv_cntproc

; 342  :         cv_write_bitfield( cv, type, mbr );

	mov	r8, rbx
	mov	rdx, r10
	mov	rcx, rdi
	call	cv_write_bitfield
$LN4@cv_cntproc:

; 343  :     }
; 344  :     //DebugMsg(( "%u cv_cntproc(%Xh, %u): struct=%s MEMBER=%s [memt=%X type=%s]\n", cv->level, GetPos(cv->types, cv->pt), cc->cnt++, type->sym.name, mbr->name, mbr->mem_type, mbr->type ? mbr->type->name : "NULL" ));
; 345  :     if ( mbr->isarray ) {

	test	BYTE PTR [rbx+41], 2
	je	SHORT $LN5@cv_cntproc

; 346  :         /* temporarily (mis)use ext_idx1 member to store the type;
; 347  :          * this field usually isn't used by struct fields */
; 348  :         mbr->ext_idx1 = cv->currtype;

	movzx	eax, WORD PTR [rdi+44]

; 349  :         cv_write_array_type( cv, mbr, 0, USE16 );

	xor	r8d, r8d
	xor	r9d, r9d
	mov	WORD PTR [rbx+88], ax
	mov	rdx, rbx
	mov	rcx, rdi
	call	cv_write_array_type
$LN5@cv_cntproc:

; 350  :     }
; 351  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
cv_cntproc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
;	COMDAT cv_write_type
_TEXT	SEGMENT
count$ = 32
cv$ = 80
namesize$1$ = 88
tmp$ = 88
sym$ = 88
size$ = 96
typelen$1$ = 104
cv_write_type PROC					; COMDAT

; 475  : {

	push	rbx
	push	rsi
	sub	rsp, 56					; 00000038H

; 476  :     struct dsym *type = (struct dsym *)sym;
; 477  :     uint_8      *tmp;
; 478  :     int         namesize;
; 479  :     int         typelen;
; 480  :     int         size;
; 481  :     uint_16     property;
; 482  :     struct cv_counters count;
; 483  : 
; 484  :     /* v2.10: handle typedefs. when the types are enumerated,
; 485  :      * typedefs are ignored.
; 486  :      */
; 487  :     if ( sym->typekind == TYPE_TYPEDEF ) {

	movzx	eax, BYTE PTR [rdx+66]
	mov	rsi, rdx
	mov	rbx, rcx
	cmp	al, 3
	jne	SHORT $LN4@cv_write_t

; 488  :         //if ( sym->is_ptr ) {
; 489  :         if ( sym->mem_type == MT_PTR ) {

	cmp	DWORD PTR [rdx+36], 195			; 000000c3H
	jne	$LN1@cv_write_t

; 490  : #if GENPTRTYPE
; 491  :             /* for untyped void pointers use ONE generic definition */
; 492  :             if ( !sym->isfar ) {
; 493  :                 if ( cv->ptrtype[sym->Ofssize] ) {
; 494  :                     sym->cv_typeref = cv->ptrtype[sym->Ofssize];
; 495  :                     return;
; 496  :                 }
; 497  :                 cv->ptrtype[sym->Ofssize] = cv->currtype;
; 498  :             }
; 499  : #endif
; 500  : #if 1
; 501  :             if ( sym->ptr_memtype != MT_PROC && sym->target_type && sym->target_type->cvtyperef == 0 ) {

	cmp	BYTE PTR [rdx+46], 128			; 00000080H
	je	SHORT $LN8@cv_write_t
	mov	rdx, QWORD PTR [rdx+48]
	test	rdx, rdx
	je	SHORT $LN8@cv_write_t
	cmp	WORD PTR [rdx+64], 0
	jne	SHORT $LN8@cv_write_t

; 502  :                 DebugMsg(( "%u cv_write_type(%Xh): TYPEDEF=%s target type=%s [kind=%u memt=%X] not defined yet\n",
; 503  :                           cv->level, GetPos(cv->types, cv->pt), sym->name, sym->target_type->name, sym->target_type->typekind, sym->target_type->mem_type ));
; 504  :                 //cv->level++;
; 505  :                 //sym->cv_typeref = GetTyperef( sym, sym->Ofssize ); /* to avoid circular references! */
; 506  :                 if ( cv->level == 0 ) /* avoid circles */

	cmp	DWORD PTR [rcx+40], 0
	jne	SHORT $LN8@cv_write_t

; 507  :                     cv_write_type( cv, sym->target_type );

	call	cv_write_type
$LN8@cv_write_t:

; 508  :                 //cv->level--;
; 509  :             }
; 510  :             sym->cvtyperef = cv_write_ptr_type( cv, sym );

	mov	rdx, rsi
	mov	rcx, rbx
	call	cv_write_ptr_type
	mov	WORD PTR [rsi+64], ax

; 605  :     return;
; 606  : }

	add	rsp, 56					; 00000038H
	pop	rsi
	pop	rbx
	ret	0
$LN4@cv_write_t:

; 511  :             DebugMsg(( "%u cv_write_type(%Xh): TYPEDEF=%s typeref=%X\n", cv->level, GetPos(cv->types, cv->pt), sym->name, sym->cvtyperef ));
; 512  : #else
; 513  :             sym->cv_typeref = cv->currtype++;
; 514  :             size = ( sizeof( struct cv_typerec_pointer ) + sizeof( uint_32 ) );
; 515  :             cv->pt = checkflush( cv->types, cv->pt, size );
; 516  :             cv->pt_ptr->tr.size = size - sizeof(uint_16);
; 517  :             cv->pt_ptr->tr.leaf = LF_POINTER;
; 518  :             if ( sym->Ofssize == USE16 ) {
; 519  :                 cv->pt_ptr->attribute = ( sym->isfar ? CV_TYPE_POINTER_FAR : CV_TYPE_POINTER_NEAR );
; 520  :             } else {
; 521  :                 cv->pt_ptr->attribute = ( sym->isfar ? CV_TYPE_POINTER_FAR32 : CV_TYPE_POINTER_NEAR32 );
; 522  :             }
; 523  :             cv->pt_ptr->pptype = cv_pvoid.s;
; 524  :             *(uint_32 *)( cv->pt + sizeof( struct cv_typerec_pointer ) ) = 0; /* variant */
; 525  :             DebugMsg(( "%u cv_write_type(%Xh, ref=%X): POINTER, attr=%X\n", cv->level, GetPos(cv->types, cv->pt), cv->currtype-1, cv->pt_ptr->attribute ));
; 526  :             cv->pt += size;
; 527  : #endif
; 528  :         }
; 529  :         return;
; 530  :     } else if ( sym->typekind == TYPE_NONE ) {

	test	al, al
	je	$LN1@cv_write_t

; 531  :         DebugMsg(( "cv_write_type: %s has typekind=TYPE_NONE, ignored!\n", sym->name ));
; 532  :         return;
; 533  :     }
; 534  : 
; 535  :     typelen = ( sym->total_size >= LF_NUMERIC ? sizeof( uint_32 ) : 0 );

	xor	ecx, ecx
	mov	QWORD PTR [rsp+80], rbp
	cmp	DWORD PTR [rdx+56], 32768		; 00008000H

; 536  : 
; 537  :     property = ( cv->level ? CVTSP_ISNESTED : 0 );
; 538  : 
; 539  :     /* Count the member fields. If a member's type is unknown, create it! */
; 540  :     count.cnt = 0;
; 541  :     count.size = 0;
; 542  :     count.ofs = 0;
; 543  :     cv_enum_fields( type, cv_cntproc, cv, &count );

	lea	r9, QWORD PTR count$[rsp]
	mov	ebp, ecx
	mov	QWORD PTR [rsp+48], rdi
	mov	eax, 4
	mov	QWORD PTR count$[rsp], rcx
	cmovae	ebp, eax
	mov	DWORD PTR count$[rsp+8], ecx
	mov	eax, DWORD PTR [rbx+40]
	lea	rdx, OFFSET FLAT:cv_cntproc
	neg	eax
	mov	DWORD PTR typelen$1$[rsp], ebp
	mov	r8, rbx
	mov	rcx, rsi
	sbb	di, di
	and	di, 8
	call	cv_enum_fields

; 544  : 
; 545  :     /* WinDbg wants embedded structs to have a name - else it won't allow to "open" it. */
; 546  :     namesize = ( sym->name_size ? sym->name_size : 9 );  /* 9 is sizeof("__unnamed") */

	movzx	eax, BYTE PTR [rsi+72]
	movzx	edx, al
	test	al, al
	jne	SHORT $LN29@cv_write_t
	mov	edx, 9
$LN29@cv_write_t:

; 547  : 
; 548  :     sym->cvtyperef = cv->currtype++;

	movzx	eax, WORD PTR [rbx+44]
	mov	WORD PTR [rsi+64], ax
	inc	WORD PTR [rbx+44]

; 549  :     switch ( type->sym.typekind ) {

	movzx	ecx, BYTE PTR [rsi+66]
	mov	DWORD PTR namesize$1$[rsp], edx
	sub	ecx, 1
	je	SHORT $LN12@cv_write_t
	sub	ecx, 1
	je	$LN10@cv_write_t
	cmp	ecx, 2
	jne	$LN28@cv_write_t

; 561  :     case TYPE_RECORD:
; 562  :         property |= CVTSP_PACKED; /* is "packed" */

	or	di, 1
$LN12@cv_write_t:

; 563  :         /* no break */
; 564  :     case TYPE_STRUCT:
; 565  :         DebugMsg(( "%u cv_write_type(%Xh, ref=%X): STRUCT=%s\n", cv->level, GetPos(cv->types, cv->pt), sym->cvtyperef, sym->name ));
; 566  :         size = ( sizeof( struct cv_typerec_structure ) + typelen + 1 + namesize + 3 ) & ~3;
; 567  :         cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rcx, QWORD PTR [rbx+24]
	add	ebp, 20
	mov	r9, QWORD PTR [rbx+32]
	add	ebp, edx
	mov	rdx, QWORD PTR [rbx+16]
	and	ebp, -4
	mov	r8d, ebp
	mov	DWORD PTR size$[rsp], ebp
	mov	rax, QWORD PTR [rcx+96]
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rbx+16], rax

; 568  :         cv->pt_st->tr.size = size - sizeof(uint_16);

	lea	ecx, DWORD PTR [rbp-2]
	mov	WORD PTR [rax], cx

; 569  :         cv->pt_st->tr.leaf = LF_STRUCTURE;

	mov	ecx, 5
	mov	rax, QWORD PTR [rbx+16]
	mov	WORD PTR [rax+2], cx

; 570  :         cv->pt_st->count = count.cnt;

	movzx	eax, WORD PTR count$[rsp]
	mov	rcx, QWORD PTR [rbx+16]
	mov	WORD PTR [rcx+4], ax

; 571  :         cv->pt_st->field = cv->currtype++;

	movzx	eax, WORD PTR [rbx+44]
	mov	rcx, QWORD PTR [rbx+16]
	mov	WORD PTR [rcx+6], ax

; 572  :         cv->pt_st->property = property;
; 573  :         cv->pt_st->dList = 0;

	xor	ecx, ecx
	mov	rax, QWORD PTR [rbx+16]
	inc	WORD PTR [rbx+44]
	mov	WORD PTR [rax+8], di
	mov	rax, QWORD PTR [rbx+16]
	mov	WORD PTR [rax+10], cx

; 574  :         cv->pt_st->vshape = 0;

	mov	rax, QWORD PTR [rbx+16]
	mov	WORD PTR [rax+12], cx

; 575  :         tmp = (uint_8 *)&cv->pt_st->length;

	mov	rbp, QWORD PTR [rbx+16]
	add	rbp, 14
$LN2@cv_write_t:

; 576  :         break;
; 577  :     }
; 578  :     if ( typelen ) {

	cmp	DWORD PTR typelen$1$[rsp], 0
	je	$LN13@cv_write_t

; 579  :         ((struct leaf32 *)tmp)->leaf = LF_ULONG;

	mov	eax, 32772				; 00008004H
	mov	WORD PTR [rbp], ax

; 580  :         ((struct leaf32 *)tmp)->value32 = sym->total_size;

	mov	eax, DWORD PTR [rsi+56]
	mov	DWORD PTR [rbp+4], eax

; 581  :         tmp += sizeof( struct leaf32 );

	add	rbp, 8

; 582  :     } else {

	jmp	SHORT $LN14@cv_write_t
$LN28@cv_write_t:

; 575  :         tmp = (uint_8 *)&cv->pt_st->length;

	mov	rbp, QWORD PTR tmp$[rsp]
	jmp	SHORT $LN2@cv_write_t
$LN10@cv_write_t:

; 550  :     case TYPE_UNION:
; 551  :         DebugMsg(( "%u cv_write_type(%Xh, ref=%X): UNION=%s\n", cv->level, GetPos(cv->types, cv->pt), sym->cvtyperef, sym->name ));
; 552  :         size = ( sizeof( struct cv_typerec_union ) + typelen + 1 + namesize + 3 ) & ~3;
; 553  :         cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rcx, QWORD PTR [rbx+24]
	add	ebp, 16
	mov	r9, QWORD PTR [rbx+32]
	add	ebp, edx
	mov	rdx, QWORD PTR [rbx+16]
	and	ebp, -4
	mov	r8d, ebp
	mov	DWORD PTR size$[rsp], ebp
	mov	rax, QWORD PTR [rcx+96]
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rbx+16], rax

; 554  :         cv->pt_un->tr.size = size - sizeof(uint_16);

	lea	ecx, DWORD PTR [rbp-2]
	mov	WORD PTR [rax], cx

; 555  :         cv->pt_un->tr.leaf = LF_UNION;

	mov	ecx, 6
	mov	rax, QWORD PTR [rbx+16]
	mov	WORD PTR [rax+2], cx

; 556  :         cv->pt_un->count = count.cnt;

	movzx	eax, WORD PTR count$[rsp]
	mov	rcx, QWORD PTR [rbx+16]
	mov	WORD PTR [rcx+4], ax

; 557  :         cv->pt_un->field = cv->currtype++;

	movzx	eax, WORD PTR [rbx+44]
	mov	rcx, QWORD PTR [rbx+16]
	mov	WORD PTR [rcx+6], ax
	inc	WORD PTR [rbx+44]

; 558  :         cv->pt_un->property = property;

	mov	rax, QWORD PTR [rbx+16]
	mov	WORD PTR [rax+8], di

; 559  :         tmp = (uint_8 *)&cv->pt_un->length;

	mov	rbp, QWORD PTR [rbx+16]
	add	rbp, 10

; 560  :         break;

	jmp	$LN2@cv_write_t
$LN13@cv_write_t:

; 583  :         *(uint_16 *)tmp = sym->total_size;

	movzx	eax, WORD PTR [rsi+56]
	mov	WORD PTR [rbp], ax

; 584  :         tmp += sizeof( uint_16 );

	add	rbp, 2
$LN14@cv_write_t:

; 585  :     }
; 586  :     SetPrefixName( tmp, sym->name_size ? sym->name : "__unnamed", namesize );

	movsxd	rax, DWORD PTR namesize$1$[rsp]
	mov	BYTE PTR [rbp], al
	inc	rbp
	cmp	BYTE PTR [rsi+72], 0
	je	SHORT $LN18@cv_write_t
	mov	rdx, QWORD PTR [rsi+8]
	jmp	SHORT $LN19@cv_write_t
$LN18@cv_write_t:
	lea	rdx, OFFSET FLAT:$SG11147
$LN19@cv_write_t:
	mov	r8, rax
	mov	rcx, rbp
	mov	rdi, rax
	call	memcpy

; 587  : 
; 588  :     PadBytes( tmp, cv->types->e.seginfo->CodeBuffer );

	mov	rax, QWORD PTR [rbx+24]
	lea	r9, QWORD PTR [rdi+rbp]
	mov	rdi, QWORD PTR [rsp+48]
	mov	rdx, r9
	mov	rbp, QWORD PTR [rsp+80]
	mov	rcx, QWORD PTR [rax+96]
	sub	rdx, QWORD PTR [rcx+16]
	mov	rcx, rdx
	and	ecx, 3
	je	SHORT $LN22@cv_write_t

; 585  :     }
; 586  :     SetPrefixName( tmp, sym->name_size ? sym->name : "__unnamed", namesize );

	lea	r10, OFFSET FLAT:?padtab@?1??PadBytes@@9@9+3
	npad	5

; 587  : 
; 588  :     PadBytes( tmp, cv->types->e.seginfo->CodeBuffer );

$LL21@cv_write_t:
	inc	rdx
	lea	r9, QWORD PTR [r9+1]
	mov	rax, r10
	sub	rax, rcx
	mov	rcx, rdx
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [r9-1], al
	and	ecx, 3
	jne	SHORT $LL21@cv_write_t
$LN22@cv_write_t:

; 589  :     cv->pt += size;
; 590  : 
; 591  :     /* write the fieldlist record */
; 592  :     cv->pt = checkflush( cv->types, cv->pt, sizeof( struct cv_typerec_fieldlist ), cv->param );

	mov	rcx, QWORD PTR [rbx+24]
	mov	r8d, 4
	movsxd	rax, DWORD PTR size$[rsp]
	add	QWORD PTR [rbx+16], rax
	mov	r9, QWORD PTR [rbx+32]
	mov	rax, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR [rbx+16]
	call	QWORD PTR [rax+32]

; 593  :     size = sizeof( struct cv_typerec_fieldlist) + count.size;
; 594  :     cv->pt_fl->tr.size = size - sizeof(uint_16);

	movzx	ecx, WORD PTR count$[rsp+4]

; 595  :     cv->pt_fl->tr.leaf = LF_FIELDLIST;
; 596  :     DebugMsg(( "%u cv_write_type(%Xh, ref=%X): FIELDLIST, size=%u\n", cv->level, GetPos(cv->types, cv->pt), cv->currtype-1, size ));
; 597  :     cv->pt += sizeof( struct cv_typerec_fieldlist );
; 598  : 
; 599  :     /* add the struct's members to the fieldlist. */
; 600  :     count.ofs = 0;
; 601  : #ifdef DEBUG_OUT
; 602  :     count.cnt = 0;
; 603  : #endif
; 604  :     cv_enum_fields( type, cv_memberproc, cv, &count );

	lea	r9, QWORD PTR count$[rsp]
	mov	QWORD PTR [rbx+16], rax
	lea	rdx, OFFSET FLAT:cv_memberproc
	add	cx, 2
	mov	r8, rbx
	mov	WORD PTR [rax], cx
	mov	ecx, 516				; 00000204H
	mov	rax, QWORD PTR [rbx+16]
	mov	WORD PTR [rax+2], cx
	mov	rcx, rsi
	add	QWORD PTR [rbx+16], 4
	mov	DWORD PTR count$[rsp+8], 0
	call	cv_enum_fields
$LN1@cv_write_t:

; 605  :     return;
; 606  : }

	add	rsp, 56					; 00000038H
	pop	rsi
	pop	rbx
	ret	0
cv_write_type ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
;	COMDAT cv_write_ptr_type
_TEXT	SEGMENT
cv$ = 48
sym$ = 56
cv_write_ptr_type PROC					; COMDAT

; 267  : {

	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 268  :     int size = ( sizeof( struct cv_typerec_pointer ) + sizeof( uint_32 ) );
; 269  : 
; 270  :     /* for untyped pointers & for function pointers don't create a type, just
; 271  :      * return a void ptr.
; 272  :      */
; 273  :     if ( ( sym->ptr_memtype == MT_EMPTY && sym->target_type == NULL ) || sym->ptr_memtype == MT_PROC )

	movzx	eax, BYTE PTR [rdx+46]
	mov	rdi, rdx
	mov	rsi, rcx
	cmp	al, 192					; 000000c0H
	jne	SHORT $LN4@cv_write_p
	cmp	QWORD PTR [rdx+48], 0
	je	SHORT $LN3@cv_write_p
$LN4@cv_write_p:
	cmp	al, 128					; 00000080H
	jne	SHORT $LN2@cv_write_p
$LN3@cv_write_p:

; 274  :         return( GetTyperef( sym, sym->Ofssize ) );

	movzx	edx, BYTE PTR [rdx+44]
	mov	rcx, rdi

; 304  : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 274  :         return( GetTyperef( sym, sym->Ofssize ) );

	jmp	GetTyperef
$LN2@cv_write_p:

; 275  : 
; 276  :     cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rcx, QWORD PTR [rcx+24]
	mov	r8d, 12
	mov	r9, QWORD PTR [rsi+32]
	mov	rdx, QWORD PTR [rsi+16]
	mov	rax, QWORD PTR [rcx+96]
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rsi+16], rax

; 277  :     cv->pt_ptr->tr.size = size - sizeof(uint_16);

	mov	ecx, 10
	mov	WORD PTR [rax], cx

; 278  :     cv->pt_ptr->tr.leaf = LF_POINTER;

	mov	ecx, 2
	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+2], cx

; 279  :     if ( sym->Ofssize == USE16 ) {

	cmp	BYTE PTR [rdi+44], 0

; 280  :         cv->pt_ptr->attribute = ( sym->isfar ? CV_TYPE_PTRTYPE_FAR : CV_TYPE_PTRTYPE_NEAR );

	movzx	eax, BYTE PTR [rdi+47]
	jne	SHORT $LN5@cv_write_p
	shr	al, 4
	and	al, 1

; 281  :     } else {

	jmp	SHORT $LN14@cv_write_p
$LN5@cv_write_p:

; 282  :         cv->pt_ptr->attribute = ( sym->isfar ? CV_TYPE_PTRTYPE_FAR32 : CV_TYPE_PTRTYPE_NEAR32 );

	and	al, 16
	or	al, 175					; 000000afH
	shr	al, 4
$LN14@cv_write_p:
	movzx	ecx, al
	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+4], cx

; 283  :     }
; 284  :     /* if indirection is > 1, define an untyped pointer - to be improved */
; 285  :     if ( sym->is_ptr > 1 ) {

	cmp	BYTE PTR [rdi+45], 1
	ja	SHORT $LN11@cv_write_p

; 286  :         cv->pt_ptr->type = GetTyperef( sym, sym->Ofssize );
; 287  :     } else if ( sym->target_type ) {

	mov	rax, QWORD PTR [rdi+48]
	test	rax, rax
	je	SHORT $LN9@cv_write_p

; 288  :         /* the target's typeref must have been set here */
; 289  :         if ( sym->target_type->cvtyperef )

	movzx	ecx, WORD PTR [rax+64]
	test	cx, cx
	je	SHORT $LN11@cv_write_p

; 290  :             cv->pt_ptr->type = sym->target_type->cvtyperef;

	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+6], cx
	jmp	SHORT $LN10@cv_write_p
$LN11@cv_write_p:

; 291  :         else
; 292  :             cv->pt_ptr->type = GetTyperef( sym, sym->Ofssize );

	movzx	edx, BYTE PTR [rdi+44]
	mov	rcx, rdi
	call	GetTyperef
	mov	rcx, QWORD PTR [rsi+16]
	mov	WORD PTR [rcx+6], ax

; 293  :     } else { /* pointer to simple type */

	jmp	SHORT $LN10@cv_write_p
$LN9@cv_write_p:

; 294  :         enum memtype tmpmt = sym->mem_type; /* the target type is tmp. copied to mem_type */
; 295  :         sym->mem_type = sym->ptr_memtype;   /* thus GetTyperef() can be used */

	movzx	eax, BYTE PTR [rdi+46]

; 296  :         cv->pt_ptr->type = GetTyperef( sym, sym->Ofssize );

	mov	rcx, rdi
	movzx	edx, BYTE PTR [rdi+44]
	mov	QWORD PTR [rsp+48], rbx
	mov	ebx, DWORD PTR [rdi+36]
	mov	DWORD PTR [rdi+36], eax
	call	GetTyperef
	mov	rcx, QWORD PTR [rsi+16]
	mov	WORD PTR [rcx+6], ax

; 297  :         sym->mem_type = tmpmt;

	mov	DWORD PTR [rdi+36], ebx
	mov	rbx, QWORD PTR [rsp+48]
$LN10@cv_write_p:

; 298  :     }
; 299  :     *(uint_32 *)( cv->pt + sizeof( struct cv_typerec_pointer ) ) = 0; /* variant */

	mov	rax, QWORD PTR [rsi+16]
	mov	DWORD PTR [rax+8], 0

; 300  :     DebugMsg(( "%u cv_write_ptr_type(%Xh, typeref=%X ): name=%s [memt=%X ptr_memt=%X target_type=%s] reftype=%X\n",
; 301  :               cv->level, GetPos(cv->types, cv->pt), cv->currtype, sym->name, sym->mem_type, sym->ptr_memtype, sym->target_type ? sym->target_type->name : "NULL", cv->pt_ptr->type ));
; 302  :     cv->pt += size;
; 303  :     return( cv->currtype++ );

	movzx	eax, WORD PTR [rsi+44]
	add	QWORD PTR [rsi+16], 12
	lea	ecx, DWORD PTR [rax+1]
	mov	WORD PTR [rsi+44], cx

; 304  : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
cv_write_ptr_type ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
;	COMDAT cv_write_array_type
_TEXT	SEGMENT
cv$ = 64
sym$ = 72
elemtype$ = 80
Ofssize$ = 88
cv_write_array_type PROC				; COMDAT

; 234  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 235  :     uint_8      *tmp;
; 236  :     int         typelen;
; 237  :     int         size;
; 238  : 
; 239  :     typelen = ( sym->total_size >= LF_NUMERIC ? sizeof( uint_32 ) : 0 );

	xor	esi, esi
	cmp	DWORD PTR [rdx+56], 32768		; 00008000H
	mov	eax, 4

; 240  :     size = ( sizeof( struct cv_typerec_array ) + 2 + typelen + 1 + 3 ) & ~3;
; 241  :     cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rcx, QWORD PTR [rcx+24]
	movzx	r15d, r9b
	cmovae	esi, eax
	movzx	ebp, r8w
	mov	r9, QWORD PTR [rbx+32]
	mov	rdi, rdx
	mov	rdx, QWORD PTR [rbx+16]
	mov	rax, QWORD PTR [rcx+96]
	lea	r14d, DWORD PTR [rsi+16]
	and	r14d, -4
	mov	r8d, r14d
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rbx+16], rax

; 242  :     cv->pt_ar->tr.size = size - sizeof(uint_16);

	lea	ecx, DWORD PTR [r14-2]
	mov	WORD PTR [rax], cx

; 243  :     cv->pt_ar->tr.leaf = LF_ARRAY;

	mov	ecx, 3
	mov	rax, QWORD PTR [rbx+16]
	mov	WORD PTR [rax+2], cx

; 244  :     cv->pt_ar->elemtype = ( elemtype ? elemtype : GetTyperef( sym, Ofssize ) );

	test	bp, bp
	je	SHORT $LN5@cv_write_a
	movzx	ecx, bp
	jmp	SHORT $LN6@cv_write_a
$LN5@cv_write_a:
	movzx	edx, r15b
	mov	rcx, rdi
	call	GetTyperef
	movzx	ecx, ax
$LN6@cv_write_a:
	mov	rax, QWORD PTR [rbx+16]
	mov	WORD PTR [rax+4], cx

; 245  :     cv->pt_ar->idxtype = cv_idx_type.uvalue; /* ok? */

	mov	ecx, 18
	mov	rax, QWORD PTR [rbx+16]
	mov	WORD PTR [rax+6], cx

; 246  :     tmp = cv->pt + sizeof( struct cv_typerec_array );

	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rcx+10]

; 247  :     if ( typelen ) {

	test	esi, esi
	je	SHORT $LN2@cv_write_a

; 248  :         cv->pt_ar->length = LF_ULONG;

	mov	eax, 32772				; 00008004H
	mov	WORD PTR [rcx+8], ax

; 249  :         *(uint_32 *)tmp = sym->total_size;

	mov	eax, DWORD PTR [rdi+56]
	mov	DWORD PTR [r8], eax

; 250  :         tmp += sizeof( uint_32 );

	add	r8, 4

; 251  :     } else {

	jmp	SHORT $LN3@cv_write_a
$LN2@cv_write_a:

; 252  :         cv->pt_ar->length = sym->total_size;

	movzx	eax, WORD PTR [rdi+56]
	mov	WORD PTR [rcx+8], ax
$LN3@cv_write_a:

; 253  :     }
; 254  :     *tmp++ = NULLC; /* the array type name is empty */

	mov	BYTE PTR [r8], 0
	inc	r8

; 255  :     PadBytes( tmp, cv->types->e.seginfo->CodeBuffer );

	mov	rax, QWORD PTR [rbx+24]
	mov	rdx, r8
	mov	rcx, QWORD PTR [rax+96]
	sub	rdx, QWORD PTR [rcx+16]
	mov	rax, rdx
	and	eax, 3
	je	SHORT $LN9@cv_write_a

; 253  :     }
; 254  :     *tmp++ = NULLC; /* the array type name is empty */

	lea	r9, OFFSET FLAT:?padtab@?1??PadBytes@@9@9+3
	npad	7

; 255  :     PadBytes( tmp, cv->types->e.seginfo->CodeBuffer );

$LL8@cv_write_a:
	inc	rdx
	lea	r8, QWORD PTR [r8+1]
	mov	rcx, r9
	sub	rcx, rax
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [r8-1], al
	mov	rax, rdx
	and	eax, 3
	jne	SHORT $LL8@cv_write_a
$LN9@cv_write_a:

; 256  :     cv->pt += size;
; 257  :     cv->currtype++;
; 258  :     return;
; 259  : }

	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	movsxd	rax, r14d
	add	QWORD PTR [rbx+16], rax
	inc	WORD PTR [rbx+44]
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
cv_write_array_type ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
;	COMDAT cv_write_bitfield
_TEXT	SEGMENT
cv$ = 48
type$ = 56
sym$ = 64
cv_write_bitfield PROC					; COMDAT

; 216  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx
	mov	rbx, r8

; 217  :     cv->pt = checkflush( cv->types, cv->pt, sizeof( struct cv_typerec_bitfield ), cv->param );

	mov	rcx, QWORD PTR [rcx+24]
	mov	rdi, rdx
	mov	r8d, 8
	mov	r9, QWORD PTR [rsi+32]
	mov	rax, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR [rsi+16]
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rsi+16], rax

; 218  :     sym->cvtyperef = cv->currtype++;
; 219  :     cv->pt_bf->tr.size = sizeof( struct cv_typerec_bitfield ) - sizeof(uint_16);

	mov	ecx, 6
	movzx	eax, WORD PTR [rsi+44]

; 220  :     cv->pt_bf->tr.leaf = LF_BITFIELD;
; 221  :     cv->pt_bf->length = sym->total_size;
; 222  :     cv->pt_bf->position = sym->offset;
; 223  :     cv->pt_bf->type = GetTyperef( (struct asym *)type, USE16 );

	xor	edx, edx
	mov	WORD PTR [rbx+64], ax
	inc	WORD PTR [rsi+44]
	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax], cx
	mov	ecx, 518				; 00000206H
	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+2], cx
	mov	rcx, QWORD PTR [rsi+16]
	movzx	eax, BYTE PTR [rbx+56]
	mov	BYTE PTR [rcx+4], al
	mov	rcx, QWORD PTR [rsi+16]
	movzx	eax, BYTE PTR [rbx+16]
	mov	BYTE PTR [rcx+5], al
	mov	rcx, rdi
	call	GetTyperef
	mov	rcx, QWORD PTR [rsi+16]

; 224  :     cv->pt += sizeof( struct cv_typerec_bitfield );
; 225  :     return;
; 226  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	WORD PTR [rcx+6], ax
	add	QWORD PTR [rsi+16], 8
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
cv_write_bitfield ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
;	COMDAT PadBytes
_TEXT	SEGMENT
curr$ = 8
base$ = 16
PadBytes PROC						; COMDAT

; 207  :     static const char padtab[] = { LF_PAD1, LF_PAD2, LF_PAD3 };
; 208  :     while( ( curr - base ) & 3 )

	mov	rax, rcx
	mov	r8, rcx
	sub	rax, rdx
	and	eax, 3
	je	SHORT $LN3@PadBytes
	neg	rdx
	lea	r9, OFFSET FLAT:?padtab@?1??PadBytes@@9@9+3
	npad	8
$LL2@PadBytes:

; 209  :         *curr++ = padtab[3-((curr - base) & 3)];

	mov	rcx, r9
	lea	r8, QWORD PTR [r8+1]
	sub	rcx, rax
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [r8-1], al
	lea	rax, QWORD PTR [rdx+r8]
	and	eax, 3
	jne	SHORT $LL2@PadBytes
$LN3@PadBytes:

; 210  : }

	ret	0
PadBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
;	COMDAT GetCVStructLen
_TEXT	SEGMENT
sym$ = 8
Ofssize$ = 16
GetCVStructLen PROC					; COMDAT

; 174  :     uint_16 len;
; 175  :     switch ( sym->state ) {

	cmp	DWORD PTR [rcx+32], 7
	je	SHORT $LN4@GetCVStruc

; 178  :         break;
; 179  :     default:
; 180  :         if ( sym->isproc && Options.debug_ext >= CVEX_REDUCED ) {

	test	BYTE PTR [rcx+41], 8
	je	SHORT $LN6@GetCVStruc
	cmp	BYTE PTR Options+3, 1
	jb	SHORT $LN6@GetCVStruc

; 181  :             len = ( Ofssize == USE16 ? sizeof( struct cv_symrec_lproc16 ) : sizeof( struct cv_symrec_lproc32 ) );

	test	dl, dl
	mov	eax, 37					; 00000025H
	mov	ecx, 29
	cmove	ax, cx

; 190  :         }
; 191  :     }
; 192  :     return( len );
; 193  : }

	ret	0
$LN6@GetCVStruc:
	mov	eax, DWORD PTR [rcx+36]
	sub	eax, 129				; 00000081H
	cmp	eax, 1
	jbe	SHORT $LN10@GetCVStruc

; 184  : #if EQUATESYMS
; 185  :         } else if ( sym->isequate ) {

	test	BYTE PTR [rcx+40], 16
	je	SHORT $LN11@GetCVStruc

; 186  :             len = sizeof( struct cv_symrec_constant ) + ( sym->value >= LF_NUMERIC ? 2 : 0 );

	xor	eax, eax
	mov	edx, 2
	cmp	DWORD PTR [rcx+16], 32768		; 00008000H
	cmovge	ax, dx
	add	ax, 8

; 190  :         }
; 191  :     }
; 192  :     return( len );
; 193  : }

	ret	0
$LN11@GetCVStruc:

; 187  : #endif
; 188  :         } else {
; 189  :             len = ( Ofssize == USE16 ? sizeof( struct cv_symrec_ldata16 ) : sizeof( struct cv_symrec_ldata32 ) );

	test	dl, dl
	mov	eax, 12
	mov	ecx, 10
	cmove	ax, cx

; 190  :         }
; 191  :     }
; 192  :     return( len );
; 193  : }

	ret	0
$LN10@GetCVStruc:

; 182  :         } else if ( sym->mem_type == MT_NEAR || sym->mem_type == MT_FAR ) {
; 183  :             len = ( Ofssize == USE16 ? sizeof( struct cv_symrec_label16 ) : sizeof( struct cv_symrec_label32 ) );

	test	dl, dl
	mov	eax, 11
	mov	ecx, 9
	cmove	ax, cx

; 190  :         }
; 191  :     }
; 192  :     return( len );
; 193  : }

	ret	0
$LN4@GetCVStruc:

; 176  :     case SYM_TYPE:
; 177  :         len = sizeof( struct cv_symrec_udt );

	mov	eax, 6

; 190  :         }
; 191  :     }
; 192  :     return( len );
; 193  : }

	ret	0
GetCVStructLen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
;	COMDAT GetTyperef
_TEXT	SEGMENT
sym$ = 48
Ofssize$ = 56
GetTyperef PROC						; COMDAT

; 92   : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 93   :     union cv_typeref_u value = { CV_PDS_SPECIAL_NO_TYPE, 0, CV_PDT_SPECIAL, CV_PDM_DIRECT, 0 };

	xor	r9d, r9d
	mov	rbx, rcx

; 94   : 
; 95   :     if ( ( sym->mem_type & MT_SPECIAL ) == 0 ) {

	mov	ecx, DWORD PTR [rcx+36]
	movzx	r8d, r9w
	test	cl, cl
	jns	SHORT $LN43@GetTyperef
	npad	9
$LL40@GetTyperef:

; 128  :         }
; 129  :     } else {
; 130  :         switch ( sym->mem_type ) {

	sub	ecx, 129				; 00000081H
	je	$LN35@GetTyperef
	sub	ecx, 1
	je	$LN36@GetTyperef
	sub	ecx, 63					; 0000003fH
	je	$LN33@GetTyperef
	sub	ecx, 2
	je	$LN29@GetTyperef
	cmp	ecx, 1
	jne	$LN6@GetTyperef

; 156  :         case MT_TYPE:
; 157  :             for ( sym = sym->type; sym->type; sym = sym->type );

	mov	rbx, QWORD PTR [rbx+80]
	mov	rax, QWORD PTR [rbx+80]
	test	rax, rax
	je	SHORT $LN11@GetTyperef
	npad	3
$LL12@GetTyperef:
	mov	rbx, rax
	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	jne	SHORT $LL12@GetTyperef
$LN11@GetTyperef:

; 158  :             if ( sym->cvtyperef )

	cmp	WORD PTR [rbx+64], r9w
	jne	SHORT $LN44@GetTyperef

; 93   :     union cv_typeref_u value = { CV_PDS_SPECIAL_NO_TYPE, 0, CV_PDT_SPECIAL, CV_PDM_DIRECT, 0 };

	mov	ecx, DWORD PTR [rbx+36]
	mov	r8d, r9d

; 94   : 
; 95   :     if ( ( sym->mem_type & MT_SPECIAL ) == 0 ) {

	test	cl, cl
	js	SHORT $LL40@GetTyperef
$LN43@GetTyperef:

; 96   :         int size = SizeFromMemtype( sym->mem_type, Ofssize, sym->type );

	mov	r8, QWORD PTR [rbx+80]
	mov	ecx, DWORD PTR [rbx+36]
	movzx	edx, dl
	call	SizeFromMemtype

; 97   :         if ( sym->mem_type & MT_FLOAT ) {

	mov	edx, DWORD PTR [rbx+36]
	mov	ecx, eax
	test	dl, 32					; 00000020H
	je	$LN15@GetTyperef

; 98   :             value.s.type = CV_PDT_REAL;

	mov	eax, 64					; 00000040H
	movzx	r8d, ax

; 99   :             switch ( size ) {

	cmp	ecx, 4
	je	SHORT $LN17@GetTyperef
	cmp	ecx, 8
	je	$LN18@GetTyperef
	cmp	ecx, 10
	jne	$LN6@GetTyperef

; 102  :             case 10: value.s.size = CV_PDS_REAL_80BIT; break;

	mov	r8d, 66					; 00000042H

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	movzx	eax, r8w

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN44@GetTyperef:

; 159  :                 return( sym->cvtyperef );

	movzx	eax, WORD PTR [rbx+64]

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN29@GetTyperef:

; 131  :         //case MT_ABS:  break;  /* v2.07: MT_ABS obsolete */
; 132  :         case MT_PTR:
; 133  :             /* v2.10 */
; 134  :             value.s.size = CV_PDS_SPECIAL_VOID;
; 135  :             value.s.type = CV_PDT_SPECIAL;
; 136  :             switch ( sym->Ofssize ) {

	movzx	ecx, BYTE PTR [rbx+44]
	mov	r8d, 3
	test	ecx, ecx
	je	SHORT $LN30@GetTyperef
	sub	ecx, 1
	je	SHORT $LN31@GetTyperef
	cmp	ecx, 1
	jne	$LN6@GetTyperef

; 142  :                 break;
; 143  : #if AMD64_SUPPORT
; 144  :             case USE64:
; 145  :                 value.s.mode = CV_PDM_NEAR64PTR;

	mov	r8d, 1539				; 00000603H

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	movzx	eax, r8w

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN31@GetTyperef:

; 139  :                 break;
; 140  :             case USE32:
; 141  :                 value.s.mode = ( sym->isfar ? CV_PDM_FAR32PTR : CV_PDM_NEAR32PTR );

	movzx	eax, BYTE PTR [rbx+47]
	and	al, 16
	or	al, 64					; 00000040H
	shr	al, 4
	movzx	eax, al
	shl	ax, 8
	or	ax, r8w
$LN17@GetTyperef:
	movzx	r8d, ax

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN30@GetTyperef:

; 137  :             case USE16:
; 138  :                 value.s.mode = ( sym->isfar ? CV_PDM_FARPTR : CV_PDM_NEARPTR );

	test	BYTE PTR [rbx+47], 16
	setne	r9b
	lea	r8d, DWORD PTR [r9+1]
	and	r8w, 7
	shl	r8w, 8
	or	r8w, 3

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	movzx	eax, r8w

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN33@GetTyperef:

; 146  :                 break;
; 147  : #endif
; 148  :             }
; 149  :             break;
; 150  :         case MT_BITS:
; 151  :             if ( sym->cvtyperef )

	movzx	eax, WORD PTR [rbx+64]
	test	ax, ax
	je	$LN6@GetTyperef

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN36@GetTyperef:

; 155  :         case MT_FAR:  value.s.mode = CV_PDM_FARPTR; break;

	mov	r8d, 512				; 00000200H

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	movzx	eax, r8w

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN35@GetTyperef:

; 152  :                 return( sym->cvtyperef );
; 153  :             break;
; 154  :         case MT_NEAR: value.s.mode = CV_PDM_NEARPTR; break;

	mov	r8d, 256				; 00000100H

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	movzx	eax, r8w

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@GetTyperef:

; 100  :             case 4:  value.s.size = CV_PDS_REAL_32BIT; break;
; 101  :             case 8:  value.s.size = CV_PDS_REAL_64BIT; break;

	mov	r8d, 65					; 00000041H

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	movzx	eax, r8w

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN15@GetTyperef:

; 103  :             }
; 104  :         } else if ( size <= 8 ) {

	cmp	eax, 8
	jg	$LN20@GetTyperef

; 105  :             if ( sym->mem_type & MT_SIGNED )

	test	dl, 64					; 00000040H

; 106  :                 value.s.type = CV_PDT_SIGNED_INTEGRAL;

	mov	r8d, 16

; 107  :             else
; 108  :                 value.s.type = CV_PDT_UNSIGNED_INTEGRAL;

	mov	eax, 32					; 00000020H
	cmovne	ax, r8w
	movzx	r8d, ax

; 109  :             switch ( size ) {

	sub	ecx, 1
	je	SHORT $LN24@GetTyperef
	sub	ecx, 1
	je	SHORT $LN25@GetTyperef
	sub	ecx, 2
	je	SHORT $LN26@GetTyperef
	sub	ecx, 2
	je	SHORT $LN28@GetTyperef
	cmp	ecx, 2
	jne	SHORT $LN6@GetTyperef

; 113  :             case 8:  value.s.size = CV_PDS_INTEGRAL_8BYTE; break;

	mov	eax, 65531				; 0000fffbH
	and	r8w, ax
	or	r8w, 3

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	movzx	eax, r8w

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN28@GetTyperef:
	mov	eax, 64779				; 0000fd0bH
	and	r8w, ax

; 114  :             case 6: /* v2.11: added ( FWORD ) */
; 115  :                 value.s.type = CV_PDT_SPECIAL;
; 116  :                 value.s.size = CV_PDS_SPECIAL_VOID;
; 117  :                 value.s.mode = CV_PDM_FAR32PTR;

	mov	eax, 1283				; 00000503H
	or	r8w, ax

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	movzx	eax, r8w

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@GetTyperef:

; 112  :             case 4:  value.s.size = CV_PDS_INTEGRAL_4BYTE; break;

	mov	eax, 65530				; 0000fffaH
	and	r8w, ax
	or	r8w, 2

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	movzx	eax, r8w

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN25@GetTyperef:

; 111  :             case 2:  value.s.size = CV_PDS_INTEGRAL_2BYTE; break;

	mov	eax, 65529				; 0000fff9H
	and	r8w, ax
	or	r8w, 1

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	movzx	eax, r8w

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN24@GetTyperef:

; 110  :             case 1:  value.s.size = CV_PDS_INTEGRAL_1BYTE; break;

	mov	eax, 65528				; 0000fff8H
	and	r8w, ax

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	movzx	eax, r8w

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN20@GetTyperef:

; 118  :                 break;
; 119  :             }
; 120  :         } else { /* v2.11: branch added */
; 121  :             /* problem: there's no integral size > 8 bytes.
; 122  :              * Masm v8+ sets 79h (=?) for 16-byte and 3h (=void) for 32-byte.
; 123  :              * jwasm sets uint64, which allows to view at least
; 124  :              * the lower 8 bytes.
; 125  :              */
; 126  :             value.s.type = CV_PDT_REAL_INT_VALUE;
; 127  :             value.s.size = CV_PDS_REAL_INT_UINT64;

	mov	r8d, 119				; 00000077H
$LN6@GetTyperef:

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	movzx	eax, r8w

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
GetTyperef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rdi, rcx

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rbx
	mov	QWORD PTR [rsp+40], rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], 0
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf
	test	eax, eax
	cmovs	eax, ebx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbx
	mov	r9, rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, rbx
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf

; 1459 :     #pragma warning(pop)
; 1460 : }

	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ebx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_Locale$ = 88
_ArgList$ = 96
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR _ArgList$[rsp]
	or	rcx, 1
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rbx
	call	__stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;
; 1391 : }

	mov	rbx, QWORD PTR [rsp+64]
	or	ecx, -1
	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ecx
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
