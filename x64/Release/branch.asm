; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG10739 DB	01H DUP (?)
_BSS	ENDS
PUBLIC	process_branch
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	OutputByte:PROC
EXTRN	set_frame:PROC
EXTRN	CreateFixup:PROC
EXTRN	GetSymOfssize:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	GetOverrideAssume:PROC
EXTRN	segm_override:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	InstrTable:BYTE
EXTRN	optable_idx:BYTE
EXTRN	SegOverride:QWORD
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$jumpExtend DD imagerel jumpExtend
	DD	imagerel jumpExtend+171
	DD	imagerel $unwind$jumpExtend
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$FarCallToNear DD imagerel FarCallToNear
	DD	imagerel FarCallToNear+53
	DD	imagerel $unwind$FarCallToNear
pdata	ENDS
pdata	SEGMENT
$pdata$process_branch DD imagerel $LN167
	DD	imagerel $LN167+242
	DD	imagerel $unwind$process_branch
$pdata$4$process_branch DD imagerel $LN167+242
	DD	imagerel $LN167+2116
	DD	imagerel $chain$4$process_branch
$pdata$5$process_branch DD imagerel $LN167+2116
	DD	imagerel $LN167+2135
	DD	imagerel $chain$5$process_branch
pdata	ENDS
xdata	SEGMENT
$unwind$process_branch DD 08d301H
	DD	04f4d3H
	DD	05e4c7H
	DD	0d0055209H
	DD	030026003H
$chain$4$process_branch DD 060f21H
	DD	0dc40fH
	DD	0c740aH
	DD	0a5405H
	DD	imagerel $LN167
	DD	imagerel $LN167+242
	DD	imagerel $unwind$process_branch
$chain$5$process_branch DD 021H
	DD	imagerel $LN167
	DD	imagerel $LN167+242
	DD	imagerel $unwind$process_branch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FarCallToNear DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jumpExtend DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\branch.c
_TEXT	SEGMENT
CodeInfo$ = 80
state$1$ = 88
CurrOpnd$ = 88
opndx$ = 96
process_branch PROC

; 135  : {

$LN167:
	push	rbx
	push	rsi
	push	r13
	sub	rsp, 48					; 00000030H

; 136  :     int_32              addr;
; 137  :     enum fixup_types    fixup_type;
; 138  :     enum fixup_options  fixup_option;
; 139  :     enum sym_state      state;
; 140  :     struct asym         *sym;
; 141  :     enum memtype        mem_type;
; 142  :     struct dsym         *symseg;
; 143  :     unsigned            opidx = IndexFromToken( CodeInfo->token );

	movsxd	rax, DWORD PTR [rcx+24]
	mov	rbx, rcx
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	rsi, r8
	movzx	r13d, WORD PTR optable_idx[rcx+rax*2-908]

; 144  : 
; 145  :     /* v2.05: just 1 operand possible */
; 146  :     if ( CurrOpnd != OPND1 ) {

	test	edx, edx
	je	SHORT $LN14@process_br

; 147  :         //EmitError( SYNTAX_ERROR ); /* v2.10: error msg changed */
; 148  :         return( EmitError( INVALID_INSTRUCTION_OPERANDS ) );

	mov	ecx, 49					; 00000031H

; 632  : }

	add	rsp, 48					; 00000030H
	pop	r13
	pop	rsi
	pop	rbx

; 147  :         //EmitError( SYNTAX_ERROR ); /* v2.10: error msg changed */
; 148  :         return( EmitError( INVALID_INSTRUCTION_OPERANDS ) );

	jmp	EmitError
$LN14@process_br:

; 149  :     }
; 150  :     if ( opndx->explicit && opndx->instr != T_SHORT )

	test	BYTE PTR [r8+72], 2
	je	SHORT $LN15@process_br
	cmp	DWORD PTR [r8+56], 245			; 000000f5H
	je	SHORT $LN15@process_br

; 151  :         CodeInfo->mem_type = opndx->mem_type;

	mov	eax, DWORD PTR [r8+64]
	mov	DWORD PTR [rbx+28], eax
$LN15@process_br:

; 152  :     /*
; 153  :      * Masm checks overrides for branch instructions with immediate operand!
; 154  :      * Of course, no segment prefix byte is emitted - would be pretty useless.
; 155  :      * It might cause the call/jmp to become FAR, though.
; 156  :      */
; 157  :     if ( opndx->override != NULL ) {

	cmp	QWORD PTR [r8+48], 0
	je	SHORT $LN19@process_br

; 158  :         segm_override( opndx, NULL );

	xor	edx, edx
	mov	rcx, r8
	call	segm_override

; 159  :         DebugMsg(("process_branch(%" I32_SPEC "X): segment override %s\n", GetCurrOffset(), SegOverride ? SegOverride->name : "NULL" ));
; 160  :         if ( SegOverride && opndx->sym && opndx->sym->segment ) {

	mov	rcx, QWORD PTR SegOverride
	test	rcx, rcx
	je	SHORT $LN19@process_br
	mov	rdx, QWORD PTR [rsi+80]
	test	rdx, rdx
	je	SHORT $LN19@process_br
	mov	rax, QWORD PTR [rdx+24]
	test	rax, rax
	je	SHORT $LN19@process_br

; 161  :             if ( SegOverride != opndx->sym->segment &&  SegOverride != ((struct dsym *)opndx->sym->segment)->e.seginfo->group ) {

	cmp	rcx, rax
	je	SHORT $LN18@process_br
	mov	rax, QWORD PTR [rax+96]
	cmp	rcx, QWORD PTR [rax]
	je	SHORT $LN18@process_br

; 162  :                 return( EmitErr( CANNOT_ACCESS_LABEL_THROUGH_SEGMENT_REGISTERS, opndx->sym ? opndx->sym->name : "" ) );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 89					; 00000059H

; 632  : }

	add	rsp, 48					; 00000030H
	pop	r13
	pop	rsi
	pop	rbx

; 162  :                 return( EmitErr( CANNOT_ACCESS_LABEL_THROUGH_SEGMENT_REGISTERS, opndx->sym ? opndx->sym->name : "" ) );

	jmp	EmitErr
$LN18@process_br:

; 163  :             }
; 164  :             /* v2.05: switch to far jmp/call */
; 165  :             if ( SegOverride != &CurrSeg->sym && SegOverride != CurrSeg->e.seginfo->group ) {

	mov	rax, QWORD PTR ModuleInfo+432
	cmp	rcx, rax
	je	SHORT $LN19@process_br
	mov	rax, QWORD PTR [rax+96]
	cmp	rcx, QWORD PTR [rax]
	je	SHORT $LN19@process_br

; 166  :                 DebugMsg(("process_branch(%" I32_SPEC "X): segment override %s caused FAR jmp/call\n", GetCurrOffset(), SegOverride->name ));
; 167  :                 //CodeInfo->isfar = TRUE;
; 168  :                 CodeInfo->mem_type = MT_FAR;

	mov	DWORD PTR [rbx+28], 130			; 00000082H
$LN19@process_br:

; 169  :             }
; 170  :         }
; 171  :     }
; 172  : 
; 173  :     CodeInfo->opnd[OPND1].data32l = opndx->value;

	mov	eax, DWORD PTR [rsi]
	mov	QWORD PTR [rsp+40], r14

; 174  :     /* v2.06: make sure, that next bytes are cleared (for OP_I48)! */
; 175  :     CodeInfo->opnd[OPND1].data32h = 0;

	xor	r14d, r14d
	mov	DWORD PTR [rbx+44], r14d
	mov	QWORD PTR [rsp+32], r15
	mov	DWORD PTR [rbx+40], eax

; 176  :     sym = opndx->sym;

	mov	r15, QWORD PTR [rsi+80]

; 177  :     if( sym == NULL ) { /* no symbolic label specified? */

	test	r15, r15
	jne	SHORT $LN20@process_br

; 178  :         DebugMsg(("process_branch(%" I32_SPEC "X): sym=NULL, op.memtype=%Xh\n", GetCurrOffset(), opndx->mem_type ));
; 179  : 
; 180  :         /* Masm rejects: "jump dest must specify a label */
; 181  : #if NEEDLABEL
; 182  :         return( EmitError( JUMP_DESTINATION_MUST_SPECIFY_A_LABEL ) );

	mov	ecx, 249				; 000000f9H
	call	EmitError
	jmp	$LN153@process_br
$LN20@process_br:

; 183  : #else
; 184  :         if( IS_JMPCALL( CodeInfo->token ) )
; 185  :             CodeInfo->isfar = TRUE; /* ??? most likely nonsense! */
; 186  : 
; 187  :         if( CodeInfo->opnd[OPND1].data32l > USHRT_MAX )
; 188  :             CodeInfo->opnd[OPND1].type = OP_I32;
; 189  :         else
; 190  :             CodeInfo->opnd_type[OPND1] = OP_I16;
; 191  : 
; 192  :         return( NOT_ERROR );
; 193  : #endif
; 194  :     }
; 195  :     DebugMsg1(("process_branch(%" I32_SPEC "X, %s): opnd.explicit=%u/memtype=%X/Ofssize=%u CI.memtype=%X sym.state=%u/mem_type=%Xh/ofs=%" I32_SPEC "X/seg=%s\n",
; 196  :               GetCurrOffset(), sym->name, opndx->explicit, opndx->mem_type, opndx->Ofssize, CodeInfo->mem_type,
; 197  :               sym->state, sym->mem_type, sym->offset, sym->segment ? sym->segment->name : "NULL" ));
; 198  : 
; 199  :     state = sym->state;

	mov	eax, DWORD PTR [r15+32]
	mov	QWORD PTR [rsp+80], rbp
	mov	QWORD PTR [rsp+96], rdi
	mov	QWORD PTR [rsp+104], r12
	mov	DWORD PTR state$1$[rsp], eax

; 200  :     addr = GetCurrOffset(); /* for SYM_UNDEFINED, will force distance to SHORT */

	call	GetCurrOffset

; 201  : 
; 202  :     /* v2.02: if symbol is GLOBAL and it isn't clear yet were
; 203  :      * it's located, then assume it is a forward reference (=SYM_UNDEFINED)!
; 204  :      * This applies to PROTOs and EXTERNDEFs in Pass 1.
; 205  :      */
; 206  :     if ( ( state == SYM_EXTERNAL ) && sym->weak ) {

	mov	ecx, DWORD PTR state$1$[rsp]
	mov	ebp, eax
	mov	edi, 1
	mov	r12d, 262144				; 00040000H
	cmp	ecx, 2
	jne	SHORT $LN21@process_br
	test	BYTE PTR [r15+47], 8
	je	SHORT $LN25@process_br

; 207  :         DebugMsg1(("process_branch(%s): EXTERNDEF assumed forward reference (=SYM_UNDEFINED)\n", sym->name ));
; 208  :         state = SYM_UNDEFINED;

	mov	DWORD PTR state$1$[rsp], r14d

; 209  :     }
; 210  : 
; 211  :     /* v2.02: removed SYM_UNDEFINED. Don't check segment of such symbols! */
; 212  : //    if ( state == SYM_UNDEFINED || state == SYM_INTERNAL || state == SYM_EXTERNAL ) {
; 213  :     if ( state == SYM_INTERNAL || state == SYM_EXTERNAL ) {

	jmp	SHORT $LN139@process_br
$LN21@process_br:
	cmp	ecx, edi
	je	SHORT $LN136@process_br

; 249  :         }
; 250  :     } else if ( state != SYM_UNDEFINED ) {

	test	ecx, ecx
	je	SHORT $LN27@process_br

; 251  :         DebugMsg(("process_branch(%s): error, unexpected symbol state=%u\n", sym->name, sym->state ));
; 252  :         return( EmitErr( JUMP_DESTINATION_MUST_SPECIFY_A_LABEL ) );

	mov	ecx, 249				; 000000f9H
	call	EmitErr
	jmp	$LN156@process_br
$LN136@process_br:

; 214  :         /* v2.04: if the symbol is internal, but wasn't met yet
; 215  :          * in this pass and its offset is < $, don't use current offset
; 216  :          */
; 217  :         if ( state == SYM_INTERNAL &&
; 218  :             sym->asmpass != ( Parse_Pass & 0xFF) &&

	movzx	eax, BYTE PTR [r15+46]
	cmp	al, BYTE PTR Parse_Pass
	je	SHORT $LN25@process_br
	cmp	DWORD PTR [r15+16], ebp
	jl	SHORT $LN26@process_br
$LN25@process_br:

; 219  :             sym->offset < addr )
; 220  :             ;
; 221  :         else
; 222  :             addr = sym->offset; /* v2.02: init addr, so sym->offset isn't changed */

	mov	ebp, DWORD PTR [r15+16]
$LN26@process_br:

; 223  :         symseg = GetSegm( sym );

	mov	rdx, QWORD PTR [r15+24]

; 224  :         if( symseg == NULL || ( CurrSeg != symseg ) ) {

	test	rdx, rdx
	je	$LN28@process_br
	cmp	QWORD PTR ModuleInfo+432, rdx
	jne	$LN28@process_br
$LN27@process_br:

; 253  :     }
; 254  : 
; 255  :     if ( state != SYM_EXTERNAL ) {

	cmp	ecx, 2
	je	$LN150@process_br
$LN139@process_br:

; 256  :         /* v1.94: if a segment override is active,
; 257  :          check if it's matching the assumed value of CS.
; 258  :          If no, assume a FAR call.
; 259  :          */
; 260  :         if ( SegOverride != NULL && CodeInfo->mem_type == MT_EMPTY ) {

	cmp	QWORD PTR SegOverride, r14
	je	SHORT $LN147@process_br
	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	jne	SHORT $LN147@process_br

; 261  :             if ( SegOverride != GetOverrideAssume( ASSUME_CS ) ) {

	mov	ecx, edi
	call	GetOverrideAssume
	cmp	QWORD PTR SegOverride, rax
	je	SHORT $LN147@process_br

; 262  :                 CodeInfo->mem_type = MT_FAR;

	mov	DWORD PTR [rbx+28], 130			; 00000082H
$LN147@process_br:

; 263  :             }
; 264  :         }
; 265  :         if(  ( CodeInfo->mem_type == MT_EMPTY ||
; 266  :               CodeInfo->mem_type == MT_NEAR ) &&

	mov	eax, DWORD PTR [rbx+28]
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN41@process_br
	cmp	eax, 129				; 00000081H
	jne	$LN149@process_br
$LN41@process_br:
	test	BYTE PTR [rbx+142], 4
	jne	$LN149@process_br

; 267  :            CodeInfo->isfar == FALSE ) {
; 268  : 
; 269  :             /* if the label is FAR - or there is a segment override
; 270  :              * which equals assumed value of CS - and there is no type cast,
; 271  :              * then do a "far call optimization".
; 272  :              */
; 273  :             if( CodeInfo->token == T_CALL &&
; 274  :                 CodeInfo->mem_type == MT_EMPTY &&

	cmp	DWORD PTR [rbx+24], 454			; 000001c6H
	jne	SHORT $LN42@process_br
	cmp	eax, 192				; 000000c0H
	jne	SHORT $LN42@process_br
	cmp	DWORD PTR [r15+36], 130			; 00000082H
	je	SHORT $LN43@process_br
	cmp	QWORD PTR SegOverride, r14
	je	SHORT $LN42@process_br
$LN43@process_br:

; 275  :                 ( sym->mem_type == MT_FAR || SegOverride ) ) {
; 276  :                 DebugMsg1(("process_branch: FAR call optimization applied!\n" ));
; 277  :                 FarCallToNear( CodeInfo ); /* switch mem_type to NEAR */

	mov	rcx, rbx
	call	FarCallToNear
$LN42@process_br:

; 278  :             }
; 279  : 
; 280  :             //addr = sym->offset; /* v2.02: this has been done above */
; 281  :             DebugMsg(("process_branch: step1: addr=%Xh\n", addr ));
; 282  :             addr -= ( GetCurrOffset() + 2 );  /* calculate the displacement */

	call	GetCurrOffset

; 283  :             addr += CodeInfo->opnd[OPND1].data32l;
; 284  :             /*  JCXZ, LOOPW, LOOPEW, LOOPZW, LOOPNEW, LOOPNZW,
; 285  :                JECXZ, LOOPD, LOOPED, LOOPZD, LOOPNED, LOOPNZD? */
; 286  :             if (( CodeInfo->Ofssize && InstrTable[opidx].byte1_info == F_16A ) ||

	movzx	r8d, BYTE PTR [rbx+106]
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	ecx, -2
	sub	ecx, eax
	add	ebp, ecx
	add	ebp, DWORD PTR [rbx+40]
	test	r8b, r8b
	je	SHORT $LN46@process_br
	imul	rcx, r13, 14
	cmp	BYTE PTR InstrTable[rcx+rdx+1], 3
	je	SHORT $LN45@process_br
$LN46@process_br:
	cmp	r8b, dil
	je	SHORT $LN44@process_br
	imul	rcx, r13, 14
	cmp	BYTE PTR InstrTable[rcx+rdx+1], 4
	jne	SHORT $LN44@process_br
$LN45@process_br:

; 287  :                 ( CodeInfo->Ofssize != USE32 && InstrTable[opidx].byte1_info == F_32A ))
; 288  :                 addr--; /* 1 extra byte for ADRSIZ (0x67) */

	dec	ebp
$LN44@process_br:

; 289  : 
; 290  :             /* v2.02: removed */
; 291  :             //if( CodeInfo->token == T_CALL && CodeInfo->mem_type == MT_EMPTY ) {
; 292  :             //    CodeInfo->mem_type = MT_NEAR;
; 293  :             //}
; 294  :             DebugMsg(("process_branch: CI.memtype=%Xh addr=%Xh\n", CodeInfo->mem_type, addr ));
; 295  :             if( CodeInfo->mem_type != MT_NEAR && CodeInfo->token != T_CALL &&

	mov	edx, DWORD PTR [rbx+28]
	cmp	edx, 129				; 00000081H
	je	SHORT $LN47@process_br
	cmp	DWORD PTR [rbx+24], 454			; 000001c6H
	je	SHORT $LN47@process_br
	lea	eax, DWORD PTR [rbp+128]
	cmp	eax, 255				; 000000ffH
	ja	SHORT $LN47@process_br

; 296  :                 ( addr >= SCHAR_MIN && addr <= SCHAR_MAX ) ) {
; 297  :                 CodeInfo->opnd[OPND1].type = OP_I8;

	mov	DWORD PTR [rbx+32], 131072		; 00020000H

; 298  :             } else {

	jmp	SHORT $LN61@process_br
$LN47@process_br:

; 299  :                 if ( opndx->instr == T_SHORT || ( IS_XCX_BRANCH( CodeInfo->token ) ) ) {

	cmp	DWORD PTR [rsi+56], 245			; 000000f5H
	je	$LN50@process_br
	mov	eax, DWORD PTR [rbx+24]
	sub	eax, 486				; 000001e6H
	cmp	eax, 17
	jbe	$LN50@process_br

; 320  :                 }
; 321  :                 /* near destination */
; 322  :                 /* is there a type coercion? */
; 323  :                 if ( opndx->Ofssize != USE_EMPTY ) {

	movzx	eax, BYTE PTR [rsi+69]
	cmp	al, 254					; 000000feH
	je	SHORT $LN54@process_br

; 324  :                     if ( opndx->Ofssize == USE16 ) {

	test	al, al
	jne	SHORT $LN56@process_br

; 325  :                         CodeInfo->opnd[OPND1].type = OP_I16;

	mov	DWORD PTR [rbx+32], r12d

; 326  :                         addr -= 1; /* 16 bit displacement */

	dec	ebp

; 327  :                     } else {

	jmp	SHORT $LN57@process_br
$LN56@process_br:

; 328  :                         CodeInfo->opnd[OPND1].type = OP_I32;

	mov	DWORD PTR [rbx+32], 524288		; 00080000H

; 329  :                         addr -= 3; /* 32 bit displacement */

	sub	ebp, 3
$LN57@process_br:

; 330  :                     }
; 331  :                     CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, opndx->Ofssize );

	movzx	eax, BYTE PTR [rsi+69]
	cmp	BYTE PTR [rbx+106], al
	setne	al
	add	al, al
	xor	al, BYTE PTR [rbx+9]
	and	al, 2
	xor	BYTE PTR [rbx+9], al

; 332  :                     if ( CodeInfo->prefix.opsiz )

	test	BYTE PTR [rbx+9], 2
	je	SHORT $LN60@process_br

; 333  :                         addr--;
; 334  :                 } else if( CodeInfo->Ofssize > USE16 ) {

	jmp	SHORT $LN157@process_br
$LN54@process_br:
	test	r8b, r8b
	je	SHORT $LN59@process_br

; 335  :                     CodeInfo->opnd[OPND1].type = OP_I32;

	mov	DWORD PTR [rbx+32], 524288		; 00080000H

; 336  :                     addr -= 3; /* 32 bit displacement */

	sub	ebp, 3

; 337  :                 } else {

	jmp	SHORT $LN60@process_br
$LN59@process_br:

; 338  :                     CodeInfo->opnd[OPND1].type = OP_I16;

	mov	DWORD PTR [rbx+32], r12d
$LN157@process_br:

; 339  :                     addr -= 1; /* 16 bit displacement */

	dec	ebp
$LN60@process_br:
	mov	eax, DWORD PTR [rbx+24]
	sub	eax, 456				; 000001c8H
	cmp	eax, 29
	ja	SHORT $LN61@process_br

; 340  :                 }
; 341  :                 if( IS_CONDJMP( CodeInfo->token ) ) {
; 342  :                     /* 1 extra byte for opcode ( 0F ) */
; 343  :                     addr--;

	dec	ebp
$LN61@process_br:

; 344  :                 }
; 345  :             }
; 346  : 
; 347  :             /* store the displacement */
; 348  :             CodeInfo->opnd[OPND1].data32l = addr;

	mov	DWORD PTR [rbx+40], ebp

; 349  :             DebugMsg1(("process_branch: displacement=%" I32_SPEC "X opnd_type=%" I32_SPEC "X\n", addr, CodeInfo->opnd[OPND1].type ));
; 350  : 
; 351  :             /* automatic (conditional) jump expansion.
; 352  :              * for 386 and above this is not needed, since there exists
; 353  :              * an extended version of Jcc
; 354  :              */
; 355  :             if( ( ModuleInfo.curr_cpu & P_CPU_MASK) < P_386 && IS_JCC( CodeInfo->token ) ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jge	SHORT $LN65@process_br
	mov	eax, DWORD PTR [rbx+24]
	sub	eax, 456				; 000001c8H
	cmp	eax, 29
	ja	SHORT $LN65@process_br

; 356  :                 /* look into jump extension */
; 357  :                 if( CodeInfo->opnd[OPND1].type != OP_I8 ) {

	cmp	DWORD PTR [rbx+32], 131072		; 00020000H
	je	SHORT $LN65@process_br

; 358  :                     if( CodeInfo->mem_type == MT_EMPTY && ModuleInfo.ljmp == TRUE ) {

	mov	edx, DWORD PTR [rbx+28]
	cmp	edx, 192				; 000000c0H
	jne	SHORT $LN64@process_br
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	je	SHORT $LN64@process_br

; 359  :                         jumpExtend( CodeInfo, FALSE );

	xor	edx, edx
	mov	rcx, rbx
	call	jumpExtend

; 360  :                         addr -= 1;

	lea	eax, DWORD PTR [rbp-1]

; 361  :                         CodeInfo->opnd[OPND1].data32l = addr;

	mov	DWORD PTR [rbx+40], eax
$LN65@process_br:

; 368  :                     }
; 369  :                 }
; 370  :             }
; 371  :             /* v2.02: in pass one, write "backpatch" fixup for forward
; 372  :              * references.
; 373  :              */
; 374  :             /* the "if" below needs to be explaind.
; 375  :              * Fixups will be written for forward references in pass one.
; 376  :              * state is SYM_UNDEFINED then. The fixups will be scanned when
; 377  :              * the label is met finally, still in pass one. See backptch.c
; 378  :              * for details.
; 379  :              */
; 380  :             if ( state != SYM_UNDEFINED )

	mov	r13d, DWORD PTR state$1$[rsp]
	test	r13d, r13d
	je	$LN66@process_br

; 381  :                 return( NOT_ERROR ); /* exit, no fixup is written! */

	jmp	$LN158@process_br
$LN64@process_br:

; 362  :                         //return( SCRAP_INSTRUCTION );
; 363  :                     //} else if( !PhaseError ) {
; 364  :                     } else {
; 365  :                         DebugMsg(("%u process_branch: CPU < 386 and Jcc distance != SHORT, mem_type=%X, curr_ofs=%X, addr=%d\n", Parse_Pass + 1, CodeInfo->mem_type, GetCurrOffset(), addr ));
; 366  :                         /* v2.11: don't emit "out of range" if OP_I16 was forced by type coercion ( jmp near ptr xxx ) */
; 367  :                         return( EmitErr( CodeInfo->mem_type == MT_EMPTY ? JUMP_OUT_OF_RANGE : JUMP_DISTANCE_NOT_POSSIBLE, addr ) );

	mov	ecx, 50					; 00000032H
	jmp	SHORT $LN165@process_br
$LN50@process_br:

; 300  :                     /* v2.06: added */
; 301  :                     if( CodeInfo->token == T_CALL ) {

	cmp	DWORD PTR [rbx+24], 454			; 000001c6H
	je	$LN164@process_br

; 302  :                         return( EmitError( CANNOT_USE_SHORT_WITH_CALL ) );
; 303  :                     }
; 304  :                     /* v1.96: since HJWasm's backpatch strategy is to move from
; 305  :                      * "smallest" to "largest" distance, an "out of range"
; 306  :                      * error can be detected at any time.
; 307  :                      */
; 308  :                     DebugMsg(("process_branch: jump out of range, mem_type=%Xh addr=%Xh\n", CodeInfo->mem_type, addr ));
; 309  :                     /* v2.06: removed */
; 310  :                     /* v2.03: added */
; 311  :                     //if ( addr >= SCHAR_MIN && addr <= SCHAR_MAX ) {
; 312  :                     //    return( EmitError( ONLY_SHORT_JUMP_DISTANCE_IS_ALLOWED ) );
; 313  :                     //}
; 314  :                     if ( addr < 0 ) {

	test	ebp, ebp
	jns	SHORT $LN52@process_br

; 315  :                         addr -= SCHAR_MIN;

	mov	eax, -128				; ffffffffffffff80H
	sub	eax, ebp

; 316  :                         addr = 0 - addr;

	mov	ebp, eax

; 317  :                     } else

	jmp	SHORT $LN53@process_br
$LN52@process_br:

; 318  :                         addr -= SCHAR_MAX;

	sub	ebp, 127				; 0000007fH
$LN53@process_br:

; 319  :                     return( EmitErr( CodeInfo->mem_type == MT_EMPTY ? JUMP_OUT_OF_RANGE : ONLY_SHORT_JUMP_DISTANCE_IS_ALLOWED, addr ) );

	mov	ecx, 44					; 0000002cH
$LN165@process_br:
	cmp	edx, 192				; 000000c0H
	mov	eax, 53					; 00000035H
	mov	edx, ebp
	cmove	ecx, eax
	call	EmitErr
	jmp	$LN156@process_br
$LN149@process_br:
	mov	r13d, DWORD PTR state$1$[rsp]
	jmp	SHORT $LN66@process_br
$LN150@process_br:
	mov	r13d, ecx
	jmp	SHORT $LN66@process_br
$LN28@process_br:

; 225  :             /* if label has a different segment and jump/call is near or short,
; 226  :              report an error */
; 227  :             //if ( ModuleInfo.flatgrp_idx != 0 )
; 228  :             /* v2.09: make sure there's no near jmp/call between 32- and 64-bit */
; 229  :             //if ( ModuleInfo.flat_grp )
; 230  :             if ( ModuleInfo.flat_grp
; 231  : #if AMD64_SUPPORT
; 232  :                 && ( symseg == NULL || symseg->e.seginfo->Ofssize == ModuleInfo.Ofssize )

	cmp	QWORD PTR ModuleInfo+440, r14
	je	SHORT $LN29@process_br
	test	rdx, rdx
	je	SHORT $LN35@process_br
	mov	rcx, QWORD PTR [rdx+96]
	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	BYTE PTR [rcx+104], al
	je	SHORT $LN35@process_br
$LN29@process_br:

; 233  : #endif
; 234  :                ) {
; 235  :             } else if ( symseg != NULL && CurrSeg != NULL ) {

	test	rdx, rdx
	je	SHORT $LN35@process_br
	mov	rcx, QWORD PTR ModuleInfo+432
	test	rcx, rcx
	je	SHORT $LN35@process_br

; 236  :                 /* if the segments belong to the same group, it's ok */
; 237  :                 if ( symseg->e.seginfo->group != NULL &&

	mov	rax, QWORD PTR [rdx+96]
	mov	rdx, QWORD PTR [rax]
	test	rdx, rdx
	je	SHORT $LN33@process_br
	mov	rax, QWORD PTR [rcx+96]
	cmp	rdx, QWORD PTR [rax]
	je	SHORT $LN35@process_br
$LN33@process_br:

; 238  :                     symseg->e.seginfo->group == CurrSeg->e.seginfo->group )
; 239  :                     ;
; 240  :                 /* v2.05: added SegOverride condition */
; 241  :                 //else if ( opndx->mem_type == MT_NEAR ) {
; 242  :                 else if ( opndx->mem_type == MT_NEAR && SegOverride == NULL ) {

	cmp	DWORD PTR [rsi+64], 129			; 00000081H
	jne	SHORT $LN35@process_br
	cmp	QWORD PTR SegOverride, r14
	jne	SHORT $LN35@process_br

; 243  :                     DebugMsg(("process_branch: error, opndx.mem_type is MT_NEAR\n" ));
; 244  :                     return( EmitError( CANNOT_HAVE_IMPLICIT_FAR_JUMP_OR_CALL_TO_NEAR_LABEL ) );

	mov	ecx, 169				; 000000a9H
	call	EmitError
	jmp	$LN156@process_br
$LN35@process_br:

; 245  :                 }
; 246  :             }
; 247  :             /* jumps to another segment are just like to another file */
; 248  :             state = SYM_EXTERNAL;

	mov	r13d, 2
$LN66@process_br:

; 382  :         }
; 383  :     }
; 384  : 
; 385  :     DebugMsg1(("process_branch: fixup needed\n" ));
; 386  : 
; 387  :     fixup_option = OPTJ_NONE;
; 388  :     fixup_type = FIX_RELOFF8;
; 389  : 
; 390  :     mem_type = opndx->mem_type;
; 391  : 
; 392  :     /* v2.04: far call optimization possible if destination is in
; 393  :      * another segment of the same group. However, a fixup must be written.
; 394  :      * Masm does NOT optimize if destination is external!
; 395  :      */
; 396  :     if( CodeInfo->token == T_CALL &&
; 397  :        CodeInfo->mem_type == MT_EMPTY &&

	cmp	DWORD PTR [rbx+24], 454			; 000001c6H
	mov	ebp, DWORD PTR [rsi+64]
	jne	SHORT $LN69@process_br
	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	jne	$LN76@process_br
	cmp	DWORD PTR [r15+36], 130			; 00000082H
	je	SHORT $LN68@process_br
	cmp	QWORD PTR SegOverride, r14
	je	SHORT $LN69@process_br
$LN68@process_br:

; 398  :        ( sym->mem_type == MT_FAR || SegOverride ) ) {
; 399  :         symseg = GetSegm( sym );

	mov	rax, QWORD PTR [r15+24]

; 400  :         if ( symseg == CurrSeg ||

	mov	rcx, QWORD PTR ModuleInfo+432
	cmp	rax, rcx
	je	SHORT $LN70@process_br
	test	rax, rax
	je	SHORT $LN69@process_br
	mov	rax, QWORD PTR [rax+96]
	mov	rdx, QWORD PTR [rax]
	test	rdx, rdx
	je	SHORT $LN69@process_br
	mov	rax, QWORD PTR [rcx+96]
	cmp	rdx, QWORD PTR [rax]
	jne	SHORT $LN69@process_br
$LN70@process_br:

; 401  :             ( symseg != NULL && symseg->e.seginfo->group != NULL && symseg->e.seginfo->group == CurrSeg->e.seginfo->group ) ) {
; 402  :             DebugMsg1(("process_branch: FAR call optimization applied!, seg=%X, CurrSeg=%X, grps=%X/%X\n", symseg, CurrSeg, symseg->e.seginfo->group, CurrSeg->e.seginfo->group ));
; 403  :             FarCallToNear( CodeInfo ); /* switch mem_type to NEAR */

	mov	rcx, rbx
	call	FarCallToNear
$LN69@process_br:

; 404  :         }
; 405  :     }
; 406  :     /* forward ref, or external symbol */
; 407  :     if( CodeInfo->mem_type == MT_EMPTY && mem_type != MT_EMPTY && opndx->instr != T_SHORT ) {

	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	jne	SHORT $LN76@process_br
	cmp	ebp, 192				; 000000c0H
	je	SHORT $LN76@process_br
	cmp	DWORD PTR [rsi+56], 245			; 000000f5H
	je	SHORT $LN76@process_br

; 408  :         /* MT_PROC is most likely obsolete ( used by TYPEDEF only ) */
; 409  :         /* v2.09: removed */
; 410  :         //if ( mem_type == MT_PROC )
; 411  :         //    mem_type = ( ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) ? MT_FAR : MT_NEAR );
; 412  :         switch( mem_type ) {

	mov	ecx, ebp
	sub	ecx, 129				; 00000081H
	je	SHORT $LN73@process_br
	cmp	ecx, edi
	jne	SHORT $LN160@process_br
	mov	eax, DWORD PTR [rbx+24]
	sub	eax, 454				; 000001c6H
	cmp	eax, edi
	ja	SHORT $LN73@process_br

; 413  :         case MT_FAR:
; 414  :             if( IS_JMPCALL( CodeInfo->token ) ) {
; 415  :                 CodeInfo->isfar = TRUE;

	or	BYTE PTR [rbx+142], 4
$LN73@process_br:

; 416  :             }
; 417  :             /* v2.06: commented 2 lines to copy behavior of MT_NEAR */
; 418  :             //CodeInfo->mem_type = mem_type;
; 419  :             //break;
; 420  :         case MT_NEAR:
; 421  :             /* v2.04: 'if' added */
; 422  :             if ( state != SYM_UNDEFINED )

	test	r13d, r13d
	je	SHORT $LN76@process_br
$LN160@process_br:

; 423  :                 CodeInfo->mem_type = mem_type;

	mov	DWORD PTR [rbx+28], ebp
$LN76@process_br:

; 424  :             break;
; 425  :         default:
; 426  :             DebugMsg(("process_branch: unexpected mem_type %Xh\n", mem_type ));
; 427  :             /**/myassert( 0 );
; 428  :             CodeInfo->mem_type = mem_type;
; 429  :         }
; 430  :     }
; 431  : 
; 432  :     /* handle far JMP + CALL? */
; 433  :     if ( IS_JMPCALL( CodeInfo->token ) &&

	mov	edx, DWORD PTR [rbx+24]
	lea	eax, DWORD PTR [rdx-454]
	cmp	eax, edi
	ja	$LN78@process_br
	movzx	eax, BYTE PTR [rbx+142]
	test	al, 4
	jne	SHORT $LN80@process_br
	cmp	DWORD PTR [rbx+28], 130			; 00000082H
	jne	$LN78@process_br
$LN80@process_br:

; 434  :         ( CodeInfo->isfar == TRUE || CodeInfo->mem_type == MT_FAR )) {
; 435  :         CodeInfo->isfar = TRUE; /* flag isn't set if explicit is true */
; 436  :         DebugMsg1(("process_branch: FAR call/jmp\n"));
; 437  :         switch( CodeInfo->mem_type ) {

	mov	ecx, DWORD PTR [rbx+28]
	or	al, 4
	mov	BYTE PTR [rbx+142], al
	sub	ecx, 129				; 00000081H
	je	SHORT $LN81@process_br
	sub	ecx, edi
	je	SHORT $LN82@process_br
	cmp	ecx, 62					; 0000003eH
	je	SHORT $LN82@process_br

; 460  :             }
; 461  :             break;
; 462  : #ifdef DEBUG_OUT
; 463  :         default: /* cannot happen */
; 464  :             DebugMsg(("process_branch: JMP/CALL far, unexpected mem_type=%X\n", CodeInfo->mem_type ));
; 465  :             /**/myassert( 0 );
; 466  :             //return( EmitError( INVALID_OPERAND_SIZE ) );
; 467  : #endif
; 468  :         }
; 469  :         CodeInfo->opnd[OPND1].InsFixup = CreateFixup( sym, fixup_type, fixup_option );

	xor	r8d, r8d

; 470  :         return( NOT_ERROR );

	jmp	$LN162@process_br
$LN81@process_br:

; 438  :         case MT_NEAR:
; 439  :             if( opndx->explicit || opndx->instr == T_SHORT ) {

	test	BYTE PTR [rsi+72], 2
	jne	SHORT $LN83@process_br
	cmp	DWORD PTR [rsi+56], 245			; 000000f5H
	je	SHORT $LN83@process_br
$LN82@process_br:

; 441  :             }
; 442  :             /* fall through */
; 443  :         case MT_FAR:
; 444  :         case MT_EMPTY:
; 445  :             /* v1.95: explicit flag to be removed! */
; 446  :             //if ( opndx->explicit && opndx->Ofssize != USE_EMPTY )
; 447  :             if ( opndx->Ofssize != USE_EMPTY )

	movzx	eax, BYTE PTR [rsi+69]
	cmp	al, 254					; 000000feH
	je	SHORT $LN85@process_br

; 448  :                 CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, opndx->Ofssize );

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], al
	jmp	SHORT $LN161@process_br
$LN85@process_br:

; 449  :             else
; 450  :                 CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, GetSymOfssize( sym ) );

	mov	rcx, r15
	call	GetSymOfssize
	movzx	ecx, BYTE PTR [rbx+106]
	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	ecx, eax
$LN161@process_br:
	setne	al

; 451  : 
; 452  :             /* set fixup frame variables Frame + Frame_Datum */
; 453  :             set_frame( sym );

	mov	rcx, r15
	and	al, dil
	add	al, al
	or	BYTE PTR [rbx+9], al
	call	set_frame

; 454  :             if( IS_OPER_32( CodeInfo ) ) {

	movzx	eax, BYTE PTR [rbx+9]
	shr	eax, 1
	cmp	BYTE PTR [rbx+106], r14b
	je	SHORT $LN132@process_br
	not	eax
$LN132@process_br:
	and	eax, edi
	test	eax, eax
	je	SHORT $LN87@process_br

; 455  :                 fixup_type = FIX_PTR32;

	mov	edi, 10

; 456  :                 CodeInfo->opnd[OPND1].type = OP_I48;

	mov	DWORD PTR [rbx+32], 2097152		; 00200000H

; 460  :             }
; 461  :             break;
; 462  : #ifdef DEBUG_OUT
; 463  :         default: /* cannot happen */
; 464  :             DebugMsg(("process_branch: JMP/CALL far, unexpected mem_type=%X\n", CodeInfo->mem_type ));
; 465  :             /**/myassert( 0 );
; 466  :             //return( EmitError( INVALID_OPERAND_SIZE ) );
; 467  : #endif
; 468  :         }
; 469  :         CodeInfo->opnd[OPND1].InsFixup = CreateFixup( sym, fixup_type, fixup_option );

	xor	r8d, r8d

; 470  :         return( NOT_ERROR );

	jmp	$LN162@process_br
$LN87@process_br:

; 457  :             } else {
; 458  :                 fixup_type = FIX_PTR16;

	mov	edi, 9

; 459  :                 CodeInfo->opnd[OPND1].type = OP_I32;

	mov	DWORD PTR [rbx+32], 524288		; 00080000H

; 460  :             }
; 461  :             break;
; 462  : #ifdef DEBUG_OUT
; 463  :         default: /* cannot happen */
; 464  :             DebugMsg(("process_branch: JMP/CALL far, unexpected mem_type=%X\n", CodeInfo->mem_type ));
; 465  :             /**/myassert( 0 );
; 466  :             //return( EmitError( INVALID_OPERAND_SIZE ) );
; 467  : #endif
; 468  :         }
; 469  :         CodeInfo->opnd[OPND1].InsFixup = CreateFixup( sym, fixup_type, fixup_option );

	xor	r8d, r8d

; 470  :         return( NOT_ERROR );

	jmp	$LN162@process_br
$LN83@process_br:

; 440  :                 return( EmitError( CANNOT_USE_SHORT_OR_NEAR ) );

	mov	ecx, 52					; 00000034H
	call	EmitError
	jmp	$LN156@process_br
$LN78@process_br:

; 471  :     }  /* end if FAR JMP/CALL */
; 472  : 
; 473  :     switch( CodeInfo->token ) {

	mov	ecx, edx
	sub	ecx, 454				; 000001c6H
	je	$LN89@process_br
	cmp	ecx, edi
	je	$LN91@process_br
	lea	eax, DWORD PTR [rdx-486]
	cmp	eax, 17
	ja	SHORT $LN104@process_br

; 523  :             break;
; 524  : #ifdef DEBUG_OUT
; 525  :         default:
; 526  :             DebugMsg(("process_branch: JMP/CALL, unexpected mem_type=%X\n", CodeInfo->mem_type ));
; 527  :             /**/myassert( 0 );
; 528  :             //return( EmitError( INVALID_OPERAND_SIZE ) );
; 529  : #endif
; 530  :         }
; 531  :         /* deactivated because there's no override involved here */
; 532  :         // check_assume( sym, EMPTY );
; 533  :         break;
; 534  :     default: /* JxCXZ, LOOPxx, Jxx */
; 535  :         /* JxCXZ and LOOPxx always require SHORT label */
; 536  :         if ( IS_XCX_BRANCH( CodeInfo->token ) ) {
; 537  :             if( CodeInfo->mem_type != MT_EMPTY && opndx->instr != T_SHORT ) {

	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	je	SHORT $LN105@process_br
	cmp	DWORD PTR [rsi+56], 245			; 000000f5H
	jne	$LN125@process_br
$LN105@process_br:

; 538  :                 return( EmitError( ONLY_SHORT_JUMP_DISTANCE_IS_ALLOWED ) );
; 539  :             }
; 540  :             CodeInfo->opnd[OPND1].type = OP_I8;

	mov	DWORD PTR [rbx+32], 131072		; 00020000H

; 541  :             fixup_option = OPTJ_EXPLICIT;

	mov	r14d, edi

; 542  :             fixup_type = FIX_RELOFF8;
; 543  :             break;

	jmp	$LN8@process_br
$LN104@process_br:

; 544  :         }
; 545  :         /* just Jxx remaining */
; 546  : 
; 547  :         if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	$LN106@process_br

; 548  : 
; 549  :             switch( CodeInfo->mem_type ) {

	mov	ecx, DWORD PTR [rbx+28]
	sub	ecx, 129				; 00000081H
	je	$LN109@process_br
	sub	ecx, edi
	je	SHORT $LN114@process_br
	cmp	ecx, 62					; 0000003eH
	jne	$LN115@process_br

; 550  :             case MT_EMPTY:
; 551  :                 /* forward reference */
; 552  :                 fixup_option = ( opndx->instr == T_SHORT ) ? OPTJ_EXPLICIT : OPTJ_JXX;

	cmp	DWORD PTR [rsi+56], 245			; 000000f5H
	mov	r14d, 3

; 553  :                 fixup_type = FIX_RELOFF8;
; 554  :                 CodeInfo->opnd[OPND1].type = OP_I8;

	mov	DWORD PTR [rbx+32], 131072		; 00020000H
	cmove	r14d, edi

; 555  :                 break;

	jmp	$LN8@process_br
$LN114@process_br:

; 563  :                 } else if( CodeInfo->Ofssize > USE16 ) {
; 564  :                     fixup_type = FIX_RELOFF32;
; 565  :                     CodeInfo->opnd[OPND1].type = OP_I32;
; 566  :                 } else {
; 567  :                     fixup_type = FIX_RELOFF16;
; 568  :                     CodeInfo->opnd[OPND1].type = OP_I16;
; 569  :                 }
; 570  :                 break;
; 571  :             case MT_FAR:
; 572  :                 if ( ModuleInfo.ljmp ) { /* OPTION LJMP set? */

	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	je	SHORT $LN115@process_br

; 573  :                     /* v1.95: explicit flag to be removed! */
; 574  :                     //if ( opndx->explicit && opndx->Ofssize != USE_EMPTY )
; 575  :                     if ( opndx->Ofssize != USE_EMPTY )

	movzx	eax, BYTE PTR [rsi+69]
	cmp	al, 254					; 000000feH
	je	SHORT $LN116@process_br

; 576  :                         CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, opndx->Ofssize );

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], al
	jmp	SHORT $LN163@process_br
$LN116@process_br:

; 577  :                     else
; 578  :                         CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, GetSymOfssize( sym ));

	mov	rcx, r15
	call	GetSymOfssize
	movzx	ecx, BYTE PTR [rbx+106]
	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	ecx, eax
$LN163@process_br:
	setne	al

; 579  :                     /* destination is FAR (externdef <dest>:far */
; 580  :                     DebugMsg(("process_branch: JMP/CALL, FAR memtype, jump extension\n" ));
; 581  :                     jumpExtend( CodeInfo, TRUE );

	mov	edx, edi
	and	al, dil
	mov	rcx, rbx
	add	al, al
	or	BYTE PTR [rbx+9], al
	call	jumpExtend

; 582  :                     CodeInfo->isfar = TRUE;
; 583  :                     if( IS_OPER_32( CodeInfo ) ) {

	movzx	eax, BYTE PTR [rbx+9]
	or	BYTE PTR [rbx+142], 4
	shr	eax, 1
	cmp	BYTE PTR [rbx+106], r14b
	je	SHORT $LN134@process_br
	not	eax
$LN134@process_br:
	and	eax, edi
	test	eax, eax
	je	SHORT $LN118@process_br

; 584  :                         fixup_type = FIX_PTR32;

	mov	edi, 10

; 585  :                         CodeInfo->opnd[OPND1].type = OP_I48;

	mov	DWORD PTR [rbx+32], 2097152		; 00200000H

; 586  :                     } else {

	jmp	$LN8@process_br
$LN118@process_br:

; 587  :                         fixup_type = FIX_PTR16;

	mov	edi, 9

; 588  :                         CodeInfo->opnd[OPND1].type = OP_I32;

	mov	DWORD PTR [rbx+32], 524288		; 00080000H

; 589  :                     }
; 590  :                     break;

	jmp	$LN8@process_br
$LN115@process_br:

; 591  :                 }
; 592  :                 /* fall through */
; 593  :             default: /* is another memtype possible at all? */
; 594  :                 return( EmitError( ONLY_SHORT_AND_NEAR_JUMP_DISTANCE_IS_ALLOWED ) );

	mov	ecx, 75					; 0000004bH
	call	EmitError
	jmp	$LN156@process_br
$LN109@process_br:

; 556  :             case MT_NEAR:
; 557  :                 fixup_option = OPTJ_EXPLICIT;
; 558  :                 /* v1.95: explicit flag to be removed! */
; 559  :                 //if ( opndx->explicit && opndx->Ofssize != USE_EMPTY ) {
; 560  :                 if ( opndx->Ofssize != USE_EMPTY ) {

	movzx	eax, BYTE PTR [rsi+69]
	mov	r14d, edi
	cmp	al, 254					; 000000feH
	je	$LN110@process_br

; 561  :                     CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, opndx->Ofssize );

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], al
	setne	al
	and	al, dil
	add	al, al
	or	BYTE PTR [rbx+9], al

; 562  :                     CodeInfo->opnd[OPND1].type = (opndx->Ofssize >= USE32) ? OP_I32 : OP_I16;

	mov	eax, 524288				; 00080000H
	cmp	BYTE PTR [rsi+69], dil
	cmovae	r12d, eax
	mov	DWORD PTR [rbx+32], r12d
	jmp	$LN8@process_br
$LN106@process_br:

; 595  :             }
; 596  :         } else {
; 597  :             /* the only mode in 8086, 80186, 80286 is
; 598  :              * Jxx SHORT
; 599  :              * Masm allows "Jxx near" if LJMP is on (default) */
; 600  :             switch( CodeInfo->mem_type ) {

	mov	eax, DWORD PTR [rbx+28]
	cmp	eax, 129				; 00000081H
	jl	SHORT $LN125@process_br
	cmp	eax, 130				; 00000082H
	jle	SHORT $LN124@process_br
	cmp	eax, 192				; 000000c0H
	jne	SHORT $LN125@process_br

; 601  :             case MT_EMPTY:
; 602  :                 if ( opndx->instr == T_SHORT )

	cmp	DWORD PTR [rsi+56], 245			; 000000f5H

; 603  :                     fixup_option = OPTJ_EXPLICIT;
; 604  :                 else
; 605  :                     fixup_option = OPTJ_EXTEND;
; 606  :                 fixup_type = FIX_RELOFF8;
; 607  :                 CodeInfo->opnd[OPND1].type = OP_I8;

	mov	DWORD PTR [rbx+32], 131072		; 00020000H
	setne	r14b
	inc	r14d

; 608  :                 break;

	jmp	$LN8@process_br
$LN124@process_br:

; 609  :             case MT_NEAR: /* allow Jxx NEAR if LJMP on */
; 610  :             case MT_FAR:
; 611  :                 if ( ModuleInfo.ljmp ) {

	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	je	SHORT $LN125@process_br

; 612  :                     if ( CodeInfo->mem_type == MT_FAR ) {
; 613  :                         jumpExtend( CodeInfo, TRUE );

	mov	rcx, rbx
	cmp	eax, 130				; 00000082H
	jne	SHORT $LN126@process_br
	mov	edx, edi
	call	jumpExtend

; 614  :                         fixup_type = FIX_PTR16;
; 615  :                         CodeInfo->isfar = TRUE;

	or	BYTE PTR [rbx+142], 4

; 616  :                         CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 524288				; 00080000H
	mov	DWORD PTR [rbx+32], eax
	mov	edi, 9

; 617  :                     } else {

	jmp	$LN8@process_br
$LN126@process_br:

; 618  :                         jumpExtend( CodeInfo, FALSE );

	xor	edx, edx
	call	jumpExtend
$LN112@process_br:

; 619  :                         fixup_type = FIX_RELOFF16;

	mov	edi, 2

; 620  :                         CodeInfo->opnd[OPND1].type = OP_I16;

	mov	DWORD PTR [rbx+32], r12d

; 621  :                     }
; 622  :                     break;

	jmp	$LN8@process_br
$LN125@process_br:

; 623  :                 }
; 624  :                 /* fall through */
; 625  :             default:
; 626  :                 return( EmitError( ONLY_SHORT_JUMP_DISTANCE_IS_ALLOWED ) );

	mov	ecx, 44					; 0000002cH
	call	EmitError
	jmp	$LN156@process_br
$LN89@process_br:

; 474  :     case T_CALL:
; 475  :         if( opndx->instr == T_SHORT ) {

	cmp	DWORD PTR [rsi+56], 245			; 000000f5H
	jne	SHORT $LN90@process_br
$LN164@process_br:

; 476  :             return( EmitError( CANNOT_USE_SHORT_WITH_CALL ) );

	mov	ecx, 43					; 0000002bH
	call	EmitError
	jmp	$LN156@process_br
$LN90@process_br:

; 477  :         }
; 478  :         if( CodeInfo->mem_type == MT_EMPTY ) {

	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	jne	SHORT $LN91@process_br

; 479  :             fixup_option = OPTJ_CALL;

	mov	r14d, 4
$LN110@process_br:

; 480  :             if( CodeInfo->Ofssize > USE16 ) {

	cmp	BYTE PTR [rbx+106], 0
	jbe	SHORT $LN112@process_br

; 481  :                 fixup_type = FIX_RELOFF32;
; 482  :                 CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 524288				; 00080000H
	mov	edi, 3
	mov	DWORD PTR [rbx+32], eax

; 483  :             } else {

	jmp	$LN8@process_br
$LN91@process_br:

; 484  :                 fixup_type = FIX_RELOFF16;
; 485  :                 CodeInfo->opnd[OPND1].type = OP_I16;
; 486  :             }
; 487  :             break;
; 488  :         }
; 489  :         /* fall through */
; 490  :     case T_JMP:
; 491  :         DebugMsg1(("process_branch: JMP/CALL, CodeInfo->memtype=%X\n", CodeInfo->mem_type ));
; 492  :         switch( CodeInfo->mem_type ) {

	mov	ecx, DWORD PTR [rbx+28]
	sub	ecx, 129				; 00000081H
	je	SHORT $LN96@process_br
	cmp	ecx, 63					; 0000003fH
	jne	SHORT $LN8@process_br

; 493  :         case MT_EMPTY:
; 494  :             /* forward reference
; 495  :              * default distance is short, we will expand later if needed
; 496  :              */
; 497  :             CodeInfo->opnd[OPND1].type = OP_I8;

	mov	DWORD PTR [rbx+32], 131072		; 00020000H

; 498  :             fixup_type = FIX_RELOFF8;
; 499  :             fixup_option = (opndx->instr == T_SHORT) ? OPTJ_EXPLICIT : OPTJ_NONE;

	cmp	DWORD PTR [rsi+56], 245			; 000000f5H
	sete	r14b

; 500  :             break;

	jmp	SHORT $LN8@process_br
$LN96@process_br:

; 501  :         case MT_NEAR:
; 502  :             fixup_option = OPTJ_EXPLICIT;
; 503  : #if 1 /* v2.11: added, see call5.aso */
; 504  :             if( opndx->Ofssize != USE_EMPTY ) {

	movzx	eax, BYTE PTR [rsi+69]
	mov	r14d, edi
	cmp	al, 254					; 000000feH
	je	SHORT $LN97@process_br

; 505  :                 if ( opndx->Ofssize == USE16 ) {

	test	al, al
	jne	SHORT $LN99@process_br

; 506  :                     fixup_type = FIX_RELOFF16;

	mov	edi, 2

; 507  :                     CodeInfo->opnd[OPND1].type = OP_I16;

	mov	DWORD PTR [rbx+32], r12d

; 508  :                 } else {

	jmp	SHORT $LN100@process_br
$LN99@process_br:

; 509  :                     fixup_type = FIX_RELOFF32;
; 510  :                     CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 524288				; 00080000H
	mov	edi, 3
	mov	DWORD PTR [rbx+32], eax
$LN100@process_br:

; 511  :                 }
; 512  :                 CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, opndx->Ofssize );

	movzx	eax, BYTE PTR [rsi+69]
	cmp	BYTE PTR [rbx+106], al
	setne	al
	add	al, al
	xor	al, BYTE PTR [rbx+9]
	and	al, 2
	xor	BYTE PTR [rbx+9], al

; 513  :             } else

	jmp	SHORT $LN102@process_br
$LN97@process_br:

; 514  : #endif
; 515  :             if( CodeInfo->Ofssize > USE16 ) {

	cmp	BYTE PTR [rbx+106], 0
	jbe	SHORT $LN101@process_br

; 516  :                 fixup_type = FIX_RELOFF32;
; 517  :                 CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 524288				; 00080000H
	mov	edi, 3
	mov	DWORD PTR [rbx+32], eax

; 518  :             } else {

	jmp	SHORT $LN102@process_br
$LN101@process_br:

; 519  :                 fixup_type = FIX_RELOFF16;

	mov	edi, 2

; 520  :                 CodeInfo->opnd[OPND1].type = OP_I16;

	mov	DWORD PTR [rbx+32], r12d
$LN102@process_br:

; 521  :             }
; 522  :             set_frame( sym );/* added v1.95 (after change in fixup.c */

	mov	rcx, r15
	call	set_frame
$LN8@process_br:

; 627  :             }
; 628  :         }
; 629  :     } /* end switch (CodeInfo->token) */
; 630  :     CodeInfo->opnd[OPND1].InsFixup = CreateFixup( sym, fixup_type, fixup_option );

	mov	r8d, r14d
$LN162@process_br:
	mov	edx, edi
	mov	rcx, r15
	call	CreateFixup
	mov	QWORD PTR [rbx+48], rax
$LN158@process_br:

; 631  :     return( NOT_ERROR );

	xor	eax, eax
$LN156@process_br:
	mov	rdi, QWORD PTR [rsp+96]
	mov	r12, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+80]
$LN153@process_br:
	mov	r14, QWORD PTR [rsp+40]
	mov	r15, QWORD PTR [rsp+32]

; 632  : }

	add	rsp, 48					; 00000030H
	pop	r13
	pop	rsi
	pop	rbx
	ret	0
process_branch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\branch.c
;	COMDAT FarCallToNear
_TEXT	SEGMENT
CodeInfo$ = 48
FarCallToNear PROC					; COMDAT

; 114  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 115  :     if( Parse_Pass == PASS_2 )

	cmp	DWORD PTR Parse_Pass, 1
	mov	rbx, rcx
	jne	SHORT $LN2@FarCallToN

; 116  :         EmitWarn( 4, CALL_FAR_TO_NEAR );

	mov	edx, 133				; 00000085H
	mov	ecx, 4
	call	EmitWarn
$LN2@FarCallToN:

; 117  : 
; 118  :     OutputCodeByte( 0x0E ); /* 0x0E is "PUSH CS" opcode */

	mov	cl, 14
	call	OutputByte

; 119  :     CodeInfo->mem_type = MT_NEAR;

	mov	DWORD PTR [rbx+28], 129			; 00000081H

; 120  : 
; 121  :     return;
; 122  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
FarCallToNear ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\branch.c
;	COMDAT jumpExtend
_TEXT	SEGMENT
CodeInfo$ = 48
far_flag$ = 56
jumpExtend PROC						; COMDAT

; 76   : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 77   :     //uint_8 opcode;
; 78   :     unsigned next_ins_size;
; 79   : 
; 80   :     if( Parse_Pass == PASS_2 )

	cmp	DWORD PTR Parse_Pass, 1
	mov	ebx, edx
	mov	rdi, rcx
	jne	SHORT $LN2@jumpExtend

; 81   :         EmitWarn( 4, EXTENDING_JUMP );

	mov	edx, 127				; 0000007fH
	lea	ecx, QWORD PTR [rdx-123]
	call	EmitWarn
$LN2@jumpExtend:

; 82   : 
; 83   :     DebugMsg(("jumpExtend(far=%u), pass=%u, curr offset=%X, Ofssize=%u\n", far_flag, Parse_Pass + 1, GetCurrOffset(), CodeInfo->Ofssize ));
; 84   :     if( far_flag ) {

	test	ebx, ebx
	je	SHORT $LN3@jumpExtend

; 85   :         if ( CodeInfo->prefix.opsiz ) {

	test	BYTE PTR [rdi+9], 2
	je	SHORT $LN5@jumpExtend

; 86   :             /* it's 66 EA OOOO SSSS or 66 EA OOOOOOOO SSSS */
; 87   :             next_ins_size = CodeInfo->Ofssize ? 6 : 8;

	cmp	BYTE PTR [rdi+106], 0
	mov	ebx, 8
	mov	eax, 6
	cmovne	ebx, eax

; 88   :         } else {

	jmp	SHORT $LN4@jumpExtend
$LN5@jumpExtend:

; 89   :             /* it's EA OOOOOOOO SSSS or EA OOOO SSSS */
; 90   :             next_ins_size = CodeInfo->Ofssize ? 7 : 5;

	cmp	BYTE PTR [rdi+106], 0
	mov	ebx, 5
	mov	eax, 7
	cmovne	ebx, eax

; 91   :         }
; 92   :     } else {

	jmp	SHORT $LN4@jumpExtend
$LN3@jumpExtend:

; 93   :         /* it's E9 OOOOOOOO or E9 OOOO */
; 94   :         next_ins_size = CodeInfo->Ofssize ? 5 : 3;

	cmp	BYTE PTR [rdi+106], 0
	mov	ebx, 5
	mov	eax, 3
	cmovne	eax, ebx
	mov	ebx, eax
$LN4@jumpExtend:

; 95   :     }
; 96   : 
; 97   :     /* it's ensured that the short jump version is first in InstrTable */
; 98   :     //opcode = InstrTable[optable_idx[CodeInfo->token]].opcode;
; 99   :     //OutputCodeByte( opcode ^ 1 );
; 100  :     /* the negation is achieved by XOR 1 */
; 101  :     OutputCodeByte( CodeInfo->pinstr->opcode ^ 1 );

	mov	rax, QWORD PTR [rdi+16]
	movzx	ecx, BYTE PTR [rax+12]
	xor	cl, 1
	call	OutputByte

; 102  :     OutputCodeByte( next_ins_size );

	movzx	ecx, bl
	call	OutputByte

; 103  :     CodeInfo->token = T_JMP;
; 104  :     CodeInfo->pinstr = &InstrTable[ IndexFromToken( T_JMP )];
; 105  : 
; 106  :     return;
; 107  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rdi+24], 455			; 000001c7H
	movzx	eax, WORD PTR optable_idx+2
	imul	rcx, rax, 14
	lea	rax, OFFSET FLAT:InstrTable
	add	rcx, rax
	mov	QWORD PTR [rdi+16], rcx
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
jumpExtend ENDP
_TEXT	ENDS
END
