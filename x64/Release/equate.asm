; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	maxintvalues
PUBLIC	minintvalues
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
maxintvalues DQ	00000000ffffffffH
	DQ	00000000ffffffffH
	DQ	7fffffffffffffffH
minintvalues DQ	ffffffff00000000H
	DQ	ffffffff00000000H
	DQ	8000000000000000H
CONST	ENDS
PUBLIC	CreateConstant
PUBLIC	CreateVariable
PUBLIC	EqualSgnDirective
PUBLIC	EquDirective
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	SymCreate:PROC
EXTRN	SymFind:PROC
EXTRN	sym_remove_table:PROC
EXTRN	sym_ext2int:PROC
EXTRN	EvalOperand:PROC
EXTRN	EmitConstError:PROC
EXTRN	ExpandLineItems:PROC
EXTRN	SetTextMacro:PROC
EXTRN	StoreLine:PROC
EXTRN	SaveVariableState:PROC
EXTRN	LstWrite:PROC
EXTRN	BackPatch:PROC
EXTRN	myatoi128:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SymTables:BYTE
EXTRN	StoreState:BYTE
EXTRN	__ImageBase:BYTE
pdata	SEGMENT
$pdata$CreateConstant DD imagerel $LN47
	DD	imagerel $LN47+213
	DD	imagerel $unwind$CreateConstant
$pdata$0$CreateConstant DD imagerel $LN47+213
	DD	imagerel $LN47+593
	DD	imagerel $chain$0$CreateConstant
$pdata$1$CreateConstant DD imagerel $LN47+593
	DD	imagerel $LN47+617
	DD	imagerel $chain$1$CreateConstant
$pdata$2$CreateConstant DD imagerel $LN47+617
	DD	imagerel $LN47+811
	DD	imagerel $chain$2$CreateConstant
$pdata$CreateVariable DD imagerel $LN10
	DD	imagerel $LN10+203
	DD	imagerel $unwind$CreateVariable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateAssemblyTimeVariable DD imagerel CreateAssemblyTimeVariable
	DD	imagerel CreateAssemblyTimeVariable+681
	DD	imagerel $unwind$CreateAssemblyTimeVariable
pdata	ENDS
pdata	SEGMENT
$pdata$EqualSgnDirective DD imagerel $LN7
	DD	imagerel $LN7+80
	DD	imagerel $unwind$EqualSgnDirective
$pdata$EquDirective DD imagerel $LN7
	DD	imagerel $LN7+80
	DD	imagerel $unwind$EquDirective
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateAssemblyTimeVariable DD 050d01H
	DD	017340dH
	DD	014010dH
	DD	07006H
xdata	ENDS
xdata	SEGMENT
$unwind$CreateConstant DD 091d01H
	DD	067641dH
	DD	066341dH
	DD	060011dH
	DD	0700cf00eH
	DD	0500bH
$chain$0$CreateConstant DD 020821H
	DD	065e408H
	DD	imagerel $LN47
	DD	imagerel $LN47+213
	DD	imagerel $unwind$CreateConstant
$chain$1$CreateConstant DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+213
	DD	imagerel $unwind$CreateConstant
$chain$2$CreateConstant DD 020021H
	DD	065e400H
	DD	imagerel $LN47
	DD	imagerel $LN47+213
	DD	imagerel $unwind$CreateConstant
$unwind$CreateVariable DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$EqualSgnDirective DD 010401H
	DD	04204H
$unwind$EquDirective DD 010401H
	DD	04204H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\equate.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
EquDirective PROC

; 508  : {

$LN7:
	sub	rsp, 40					; 00000028H

; 509  :     struct asym *sym;
; 510  : 
; 511  :     if( tokenarray[0].token != T_ID ) {

	cmp	BYTE PTR [rdx], 8
	je	SHORT $LN2@EquDirecti

; 512  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 210				; 000000d2H

; 523  : }

	add	rsp, 40					; 00000028H

; 512  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );

	jmp	EmitErr
$LN2@EquDirecti:

; 513  :     }
; 514  :     DebugMsg1(("EquDirective(%s): calling CreateConstant\n", tokenarray[0].string_ptr ));
; 515  :     if ( sym = CreateConstant( tokenarray ) ) {

	mov	rcx, rdx
	call	CreateConstant
	test	rax, rax
	je	SHORT $LN3@EquDirecti

; 516  :         /**/myassert( sym->state == SYM_INTERNAL ); /* must not be a text macro */
; 517  :         if ( ModuleInfo.list == TRUE ) {

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN4@EquDirecti

; 518  :             LstWrite( LSTTYPE_EQUATE, 0, sym );

	xor	edx, edx
	mov	r8, rax
	lea	ecx, QWORD PTR [rdx+2]
	call	LstWrite
$LN4@EquDirecti:

; 519  :         }
; 520  :         return( NOT_ERROR );

	xor	eax, eax

; 523  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@EquDirecti:

; 521  :     }
; 522  :     return( ERROR );

	or	eax, -1

; 523  : }

	add	rsp, 40					; 00000028H
	ret	0
EquDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\equate.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
EqualSgnDirective PROC

; 258  : {

$LN7:
	sub	rsp, 40					; 00000028H

; 259  :     struct asym *sym;
; 260  : 
; 261  :     if( tokenarray[0].token != T_ID ) {

	cmp	BYTE PTR [rdx], 8
	je	SHORT $LN2@EqualSgnDi

; 262  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 210				; 000000d2H

; 271  : }

	add	rsp, 40					; 00000028H

; 262  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );

	jmp	EmitErr
$LN2@EqualSgnDi:

; 263  :     }
; 264  :     if ( sym = CreateAssemblyTimeVariable( tokenarray ) ) {

	mov	rcx, rdx
	call	CreateAssemblyTimeVariable
	test	rax, rax
	je	SHORT $LN3@EqualSgnDi

; 265  :         if ( ModuleInfo.list == TRUE ) {

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN4@EqualSgnDi

; 266  :             LstWrite( LSTTYPE_EQUATE, 0, sym );

	xor	edx, edx
	mov	r8, rax
	lea	ecx, QWORD PTR [rdx+2]
	call	LstWrite
$LN4@EqualSgnDi:

; 267  :         }
; 268  :         return( NOT_ERROR );

	xor	eax, eax

; 271  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@EqualSgnDi:

; 269  :     }
; 270  :     return( ERROR );

	or	eax, -1

; 271  : }

	add	rsp, 40					; 00000028H
	ret	0
EqualSgnDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\equate.c
;	COMDAT CreateAssemblyTimeVariable
_TEXT	SEGMENT
opnd$ = 48
i$ = 176
tokenarray$ = 176
CreateAssemblyTimeVariable PROC				; COMDAT

; 128  : {

	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 160				; 000000a0H

; 129  :     struct asym         *sym;
; 130  :     const char          *name = tokenarray[0].string_ptr;
; 131  :     int                 i = 2;
; 132  :     struct expr         opnd;
; 133  : 
; 134  :     DebugMsg1(( "CreateAssemblyTimeVariable(%s) enter\n", name ));
; 135  : 
; 136  :     /* v2.08: for plain numbers ALWAYS avoid to call evaluator */
; 137  :     if ( tokenarray[2].token == T_NUM &&

	cmp	BYTE PTR [rcx+64], 10
	mov	rbx, rcx
	mov	rdi, QWORD PTR [rcx+8]
	mov	DWORD PTR i$[rsp], 2
	jne	SHORT $LN2@CreateAsse
	cmp	BYTE PTR [rcx+96], 0
	jne	SHORT $LN2@CreateAsse

; 138  :         //tokenarray[3].token == T_FINAL &&
; 139  :         //tokenarray[2].itemlen <= 8 ) {
; 140  :         tokenarray[3].token == T_FINAL ) {
; 141  :         //opnd.llvalue = tokenarray[2].value64;
; 142  :         //opnd.llvalue = *(uint_64 *)(tokenarray[2].string_ptr - sizeof(uint_64) );
; 143  :         myatoi128( tokenarray[i].string_ptr, &opnd.llvalue, tokenarray[i].numbase, tokenarray[i].itemlen );

	movsx	r8d, BYTE PTR [rcx+65]
	lea	rdx, QWORD PTR opnd$[rsp]
	mov	r9d, DWORD PTR [rcx+80]
	mov	rcx, QWORD PTR [rcx+72]
	call	myatoi128
	mov	rax, QWORD PTR opnd$[rsp+8]
	jmp	$check_number$35
$LN2@CreateAsse:

; 153  :         }
; 154  :     } else {
; 155  :         /* v2.09: don't create not-(yet)-defined symbols. Example:
; 156  :          * E1 = E1 or 1
; 157  :          * must NOT create E1.
; 158  :          */
; 159  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opnd, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opnd$[rsp]
	mov	rdx, rcx
	mov	BYTE PTR [rsp+32], 0
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	je	$LN33@CreateAsse

; 160  :             return( NULL );
; 161  :         if( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rbx], 0
	je	SHORT $LN7@CreateAsse

; 162  :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rax+rbx+8]
	mov	ecx, 210				; 000000d2H
	call	EmitErr

; 163  :             return( NULL );

	xor	eax, eax

; 252  : }

	mov	rbx, QWORD PTR [rsp+184]
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
$LN7@CreateAsse:

; 164  :         }
; 165  : 
; 166  :         /* expression may be a constant or a relocatable item.
; 167  :          * v2.09: kind may be EXPR_CONST and still include an undefined symbol.
; 168  :          * This is caused by MakeConst() in expreval.c. Brackets changed so
; 169  :          * opnd.sym is also checked for opnd.kind == EXPR_CONST.
; 170  :          */
; 171  :         if( opnd.kind != EXPR_CONST &&
; 172  :            ( opnd.kind != EXPR_ADDR || opnd.indirect == TRUE ) ||

	mov	edx, DWORD PTR opnd$[rsp+60]
	mov	rax, QWORD PTR opnd$[rsp+80]
	mov	ecx, DWORD PTR opnd$[rsp+76]
	test	edx, edx
	je	SHORT $LN10@CreateAsse
	cmp	edx, 1
	jne	SHORT $LN9@CreateAsse
	test	cl, dl
	jne	SHORT $LN9@CreateAsse
$LN10@CreateAsse:
	test	rax, rax
	je	SHORT $LN8@CreateAsse
	cmp	DWORD PTR [rax+32], 1
	je	SHORT $LN8@CreateAsse
$LN9@CreateAsse:

; 173  :             ( opnd.sym != NULL && opnd.sym->state != SYM_INTERNAL ) ) {
; 174  :             DebugMsg(( "CreateAssemblyTimeVariable(%s) kind=%u sym=%p state=%u\n", name, opnd.kind, opnd.sym, opnd.sym ? opnd.sym->state : 0 ));
; 175  :             /* v2.09: no error if argument is a forward reference,
; 176  :              * but don't create the variable either. Will enforce an
; 177  :              * error if referenced symbol is still undefined in pass 2.
; 178  :              */
; 179  :             if( opnd.sym && opnd.sym->state == SYM_UNDEFINED && opnd.indirect == FALSE ) {

	test	rax, rax
	je	SHORT $LN11@CreateAsse
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN11@CreateAsse
	test	cl, 1
	jne	SHORT $LN11@CreateAsse

; 180  : #if FASTPASS
; 181  :                 if ( StoreState == FALSE ) FStoreLine(0); /* make sure this line is evaluated in pass two */

	cmp	BYTE PTR StoreState, 0
	jne	$LN33@CreateAsse
	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN33@CreateAsse
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
	xor	eax, eax

; 252  : }

	mov	rbx, QWORD PTR [rsp+184]
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
$LN11@CreateAsse:

; 182  : #endif
; 183  :             } else
; 184  :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 66					; 00000042H
	call	EmitError

; 185  :             return( NULL );

	xor	eax, eax

; 252  : }

	mov	rbx, QWORD PTR [rsp+184]
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
$LN8@CreateAsse:

; 186  :         }
; 187  : 
; 188  :         /* v2.08: accept any result that fits in 64-bits from expression evaluator */
; 189  :         if ( opnd.hlvalue != 0 ) {

	mov	rax, QWORD PTR opnd$[rsp+8]
	test	rax, rax
	jne	SHORT $LN5@CreateAsse

; 190  :             EmitConstError( &opnd );
; 191  :             return( NULL );
; 192  :         }
; 193  :         /* for quoted strings, the same restrictions as for plain numbers apply */
; 194  :         if ( opnd.quoted_string )

	cmp	QWORD PTR opnd$[rsp+16], rax
	je	SHORT $LN17@CreateAsse
$check_number$35:

; 144  :     check_number:
; 145  :         opnd.kind = EXPR_CONST;

	mov	DWORD PTR opnd$[rsp+60], 0

; 146  :         opnd.mem_type = MT_EMPTY; /* v2.07: added */

	mov	DWORD PTR opnd$[rsp+64], 192		; 000000c0H

; 147  :         /* v2.08: check added. the number must be 32-bit */
; 148  :         if ( opnd.hlvalue != 0 ||
; 149  :             opnd.value64 < minintvalues[ModuleInfo.Ofssize] ||

	test	rax, rax
	jne	SHORT $LN5@CreateAsse
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	rcx, QWORD PTR opnd$[rsp]
	cmp	rcx, QWORD PTR minintvalues[rdx+rax*8]
	jl	SHORT $LN5@CreateAsse
	cmp	rcx, QWORD PTR maxintvalues[rdx+rax*8]
	jle	SHORT $LN17@CreateAsse
$LN5@CreateAsse:

; 150  :             opnd.value64 > maxintvalues[ModuleInfo.Ofssize] ) {
; 151  :             EmitConstError( &opnd );

	lea	rcx, QWORD PTR opnd$[rsp]
	call	EmitConstError
$LN33@CreateAsse:

; 152  :             return( NULL );

	xor	eax, eax

; 252  : }

	mov	rbx, QWORD PTR [rsp+184]
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
$LN17@CreateAsse:

; 195  :             goto check_number;
; 196  :     }
; 197  : 
; 198  :     sym = SymSearch( name );

	mov	rcx, rdi
	call	SymFind
	mov	rbx, rax

; 199  :     if( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rax, rax
	je	$LN32@CreateAsse
	mov	eax, DWORD PTR [rax+32]
	test	eax, eax
	je	SHORT $LN21@CreateAsse

; 209  : #endif
; 210  :     //} else if ( sym->state == SYM_EXTERNAL && sym->weak == TRUE && sym->mem_type == MT_ABS ) {
; 211  :     } else if ( sym->state == SYM_EXTERNAL && sym->weak == TRUE && sym->mem_type == MT_EMPTY ) {

	cmp	eax, 2
	jne	SHORT $LN23@CreateAsse
	test	BYTE PTR [rbx+47], 8
	je	SHORT $LN23@CreateAsse
	cmp	DWORD PTR [rbx+36], 192			; 000000c0H
	jne	SHORT $LN23@CreateAsse

; 212  :         sym_ext2int( sym );

	mov	rcx, rbx
	call	sym_ext2int

; 213  :         //sym->variable  = TRUE;
; 214  : #if FASTPASS
; 215  :         sym->issaved = StoreState; /* v2.10: added */
; 216  : #endif
; 217  :     } else {

	jmp	SHORT $LN22@CreateAsse
$LN23@CreateAsse:

; 218  :         if ( sym->state != SYM_INTERNAL ||

	cmp	eax, 1
	jne	SHORT $LN27@CreateAsse
	test	BYTE PTR [rbx+40], 64			; 00000040H
	jne	SHORT $LN25@CreateAsse
	mov	eax, DWORD PTR [rbx+16]
	cmp	DWORD PTR opnd$[rsp], eax
	jne	SHORT $LN27@CreateAsse
	mov	eax, DWORD PTR [rbx+56]
	cmp	DWORD PTR opnd$[rsp+4], eax
	jne	SHORT $LN27@CreateAsse
$LN25@CreateAsse:

; 223  :         }
; 224  : #if FASTPASS
; 225  :         /* v2.04a regression in v2.04. Do not save the variable when it
; 226  :          * is defined the first time
; 227  :          * v2.10: store state only when variable is changed and has been
; 228  :          * defined BEFORE SaveState() has been called.
; 229  :          */
; 230  :         //if ( StoreState && sym->issaved == FALSE && sym->isdefined == TRUE ) {
; 231  :         if ( StoreState && sym->issaved == FALSE ) {

	cmp	BYTE PTR StoreState, 0
	je	SHORT $LN28@CreateAsse
	test	BYTE PTR [rbx+41], 16
	jne	SHORT $LN28@CreateAsse

; 232  :             SaveVariableState( sym );

	mov	rcx, rbx
	call	SaveVariableState
	jmp	SHORT $LN28@CreateAsse
$LN27@CreateAsse:

; 219  :             ( sym->variable == FALSE &&
; 220  :              ( opnd.uvalue != sym->uvalue || opnd.hvalue != sym->value3264 ) ) ) {
; 221  :             EmitErr( SYMBOL_REDEFINITION, sym->name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 144				; 00000090H
	call	EmitErr

; 222  :             return( NULL );

	xor	eax, eax

; 252  : }

	mov	rbx, QWORD PTR [rsp+184]
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
$LN21@CreateAsse:

; 202  :         } else {
; 203  :             sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table

; 204  :             sym->fwdref = TRUE;

	or	BYTE PTR [rbx+41], 32			; 00000020H
	jmp	SHORT $LN22@CreateAsse
$LN32@CreateAsse:

; 200  :         if( sym == NULL ) {
; 201  :             sym = SymCreate( name );

	mov	rcx, rdi
	call	SymCreate
	mov	rbx, rax
$LN22@CreateAsse:

; 205  :         }
; 206  :         //sym->variable  = TRUE;
; 207  : #if FASTPASS
; 208  :         sym->issaved = StoreState; /* v2.10: added */

	movzx	eax, BYTE PTR StoreState
	shl	al, 4
	xor	al, BYTE PTR [rbx+41]
	and	al, 16
	xor	BYTE PTR [rbx+41], al
$LN28@CreateAsse:

; 233  :         }
; 234  : #endif
; 235  :     }
; 236  :     sym->variable = TRUE;

	or	BYTE PTR [rbx+40], 64			; 00000040H

; 237  : #ifdef DEBUG_OUT
; 238  :     if ( Parse_Pass > PASS_1 ) {
; 239  :         if ( opnd.kind == EXPR_CONST && sym->uvalue != opnd.uvalue )
; 240  :             DebugMsg1(( "CreateAssemblyTimeVariable(%s): kind=%u, value changed ( %d -> %d )\n", name, opnd.kind, sym->uvalue, opnd.uvalue ) );
; 241  :         else if ( opnd.kind == EXPR_ADDR && sym->uvalue != ( opnd.uvalue + opnd.sym->uvalue ) )
; 242  :             DebugMsg1(( "CreateAssemblyTimeVariable(%s): kind=%u, value changed ( %d -> %d )\n", name, opnd.kind, sym->uvalue, opnd.uvalue + opnd.sym->uvalue ) );
; 243  :     }
; 244  : #endif
; 245  :     /* v2.09: allow internal variables to be set */
; 246  :     if ( sym->predefined && sym->sfunc_ptr )

	test	BYTE PTR [rbx+40], 32			; 00000020H
	je	SHORT $LN29@CreateAsse
	mov	rax, QWORD PTR [rbx+64]
	test	rax, rax
	je	SHORT $LN29@CreateAsse

; 247  :         sym->sfunc_ptr( sym, &opnd );

	lea	rdx, QWORD PTR opnd$[rsp]
	mov	rcx, rbx
	call	rax
	jmp	SHORT $LN30@CreateAsse
$LN29@CreateAsse:

; 248  :     else
; 249  :         SetValue( sym, &opnd );

	lea	rdx, QWORD PTR opnd$[rsp]
	mov	rcx, rbx
	call	SetValue
$LN30@CreateAsse:

; 250  :     DebugMsg1(( "CreateAssemblyTimeVariable(%s) memtype=%Xh value=%d\n", name, sym->mem_type, sym->value ));
; 251  :     return( sym );

	mov	rax, rbx

; 252  : }

	mov	rbx, QWORD PTR [rsp+184]
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
CreateAssemblyTimeVariable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\equate.c
;	COMDAT SetValue
_TEXT	SEGMENT
sym$ = 8
opndx$ = 16
SetValue PROC						; COMDAT

; 59   : 
; 60   :     sym->isequate = TRUE;
; 61   :     sym->state = SYM_INTERNAL;
; 62   :     sym->isdefined = TRUE;

	or	BYTE PTR [rcx+40], 18
	mov	r9d, 1
	mov	DWORD PTR [rcx+32], r9d
	mov	r8, rcx

; 63   :     if ( opndx->kind == EXPR_CONST ) {

	cmp	DWORD PTR [rdx+60], 0
	jne	SHORT $LN2@SetValue

; 64   :         /* v2.07: use expression's memtype */
; 65   :         //sym->mem_type = MT_ABS;
; 66   :         sym->mem_type = opndx->mem_type;

	mov	eax, DWORD PTR [rdx+64]
	mov	DWORD PTR [rcx+36], eax

; 67   :         sym->uvalue = opndx->uvalue;

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+16], eax

; 68   :         sym->value3264 = opndx->hvalue;

	mov	eax, DWORD PTR [rdx+4]

; 69   :         sym->segment = NULL;
; 70   :         sym->isproc = FALSE;

	and	BYTE PTR [rcx+41], 247			; 000000f7H
	mov	DWORD PTR [rcx+56], eax
	mov	QWORD PTR [rcx+24], 0

; 116  :         }
; 117  : #endif
; 118  :     }
; 119  :     return;
; 120  : }

	ret	0
$LN2@SetValue:

; 71   :     } else {
; 72   :         sym->isproc = opndx->sym->isproc;

	mov	rax, QWORD PTR [rdx+80]
	movzx	ecx, BYTE PTR [rax+41]
	xor	cl, BYTE PTR [r8+41]
	and	cl, 8
	xor	BYTE PTR [r8+41], cl

; 73   :         /* for a PROC alias, copy the procinfo extension! */
; 74   :         if ( sym->isproc ) {

	test	BYTE PTR [r8+41], 8
	je	SHORT $LN4@SetValue

; 75   :             struct dsym *dir = (struct dsym *)sym;
; 76   :             dir->e.procinfo = ((struct dsym *)opndx->sym)->e.procinfo;

	mov	rax, QWORD PTR [rdx+80]
	mov	rcx, QWORD PTR [rax+96]
	mov	QWORD PTR [r8+96], rcx
$LN4@SetValue:

; 77   :         }
; 78   :         sym->mem_type = opndx->mem_type;

	mov	eax, DWORD PTR [rdx+64]
	mov	DWORD PTR [r8+36], eax

; 79   :         /* v2.01: allow equates of variables with arbitrary type.
; 80   :          * Currently the expression evaluator sets opndx.mem_type
; 81   :          * to the mem_type of the type (i.e. QWORD for a struct with size 8),
; 82   :          * which is a bad idea in this case. So the original mem_type of the
; 83   :          * label is used instead.
; 84   :          */
; 85   :         if ( opndx->sym->mem_type == MT_TYPE && opndx->explicit == FALSE ) {

	mov	rax, QWORD PTR [rdx+80]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN5@SetValue
	test	BYTE PTR [rdx+76], 2
	jne	SHORT $LN5@SetValue

; 86   :             sym->mem_type = opndx->sym->mem_type;

	mov	DWORD PTR [r8+36], 196			; 000000c4H

; 87   :             sym->type = opndx->sym->type;

	mov	rax, QWORD PTR [rdx+80]
	mov	rcx, QWORD PTR [rax+80]
	mov	QWORD PTR [r8+80], rcx
$LN5@SetValue:

; 88   :         }
; 89   :         sym->value3264 = 0; /* v2.09: added */
; 90   :         sym->segment = opndx->sym->segment;
; 91   : #if 1 /* v2.10: added */
; 92   :         /* labels are supposed to be added to the current segment's label_list chain.
; 93   :          * this isn't done for alias equates, for various reasons.
; 94   :          * consequently, if the alias was forward referenced, ensure that a third pass
; 95   :          * will be done! regression test forward5.asm.
; 96   :          */
; 97   :         if ( sym->variable ) {

	test	BYTE PTR [r8+40], 64			; 00000040H
	mov	DWORD PTR [r8+56], 0
	mov	rax, QWORD PTR [rdx+80]
	mov	rcx, QWORD PTR [rax+24]
	mov	QWORD PTR [r8+24], rcx
	je	SHORT $LN6@SetValue

; 98   :             sym->offset = opndx->sym->offset + opndx->value;

	mov	rax, QWORD PTR [rdx+80]
	mov	ecx, DWORD PTR [rax+16]
	add	ecx, DWORD PTR [rdx]
	mov	DWORD PTR [r8+16], ecx

; 99   :             if ( Parse_Pass == PASS_2 && sym->fwdref ) {

	cmp	DWORD PTR Parse_Pass, r9d
	jne	SHORT $LN7@SetValue
	test	BYTE PTR [r8+41], 32			; 00000020H
	je	SHORT $LN7@SetValue

; 100  : #ifdef DEBUG_OUT
; 101  :                 if ( !ModuleInfo.PhaseError )
; 102  :                     DebugMsg(("SetValue(%s): Phase error, enforced by alias equate\n", sym->name ));
; 103  : #endif
; 104  :                 ModuleInfo.PhaseError = TRUE;

	mov	BYTE PTR ModuleInfo+422, r9b

; 116  :         }
; 117  : #endif
; 118  :     }
; 119  :     return;
; 120  : }

	ret	0
$LN6@SetValue:

; 105  :             }
; 106  :         } else {
; 107  :             if( Parse_Pass != PASS_1 && sym->offset != ( opndx->sym->offset + opndx->value ) ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN9@SetValue
	mov	rax, QWORD PTR [rdx+80]
	mov	ecx, DWORD PTR [rax+16]
	add	ecx, DWORD PTR [rdx]
	cmp	DWORD PTR [r8+16], ecx
	movzx	eax, BYTE PTR ModuleInfo+422
	cmovne	eax, r9d
	mov	BYTE PTR ModuleInfo+422, al
$LN9@SetValue:

; 108  : #ifdef DEBUG_OUT
; 109  :                 if ( !ModuleInfo.PhaseError )
; 110  :                     DebugMsg1(("SetValue(%s): Phase error, enforced by alias equate %" I32_SPEC "X != %" I32_SPEC "X\n", sym->name, sym->offset, opndx->sym->offset + opndx->value ));
; 111  : #endif
; 112  :                 ModuleInfo.PhaseError = TRUE;
; 113  :             }
; 114  :             sym->offset = opndx->sym->offset + opndx->value;

	mov	rax, QWORD PTR [rdx+80]
	mov	ecx, DWORD PTR [rax+16]
	add	ecx, DWORD PTR [rdx]
	mov	DWORD PTR [r8+16], ecx

; 115  :             BackPatch( sym );

	mov	rcx, r8
	jmp	BackPatch
$LN7@SetValue:

; 116  :         }
; 117  : #endif
; 118  :     }
; 119  :     return;
; 120  : }

	ret	0
SetValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\equate.c
_TEXT	SEGMENT
name$ = 48
value$ = 56
CreateVariable PROC

; 280  : {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	esi, edx
	mov	rdi, rcx

; 281  :     struct asym      *sym;
; 282  : 
; 283  :     DebugMsg1(( "CreateVariable(%s, %d ) enter\n", name, value ));
; 284  : 
; 285  :     sym = SymSearch( name );

	call	SymFind
	mov	rbx, rax

; 286  :     if( sym == NULL ) {

	test	rax, rax
	jne	SHORT $LN2@CreateVari

; 287  :         sym = SymCreate( name );

	mov	rcx, rdi
	call	SymCreate
	mov	rbx, rax

; 288  : #if FASTPASS
; 289  :         //sym->issaved = FALSE;
; 290  :         sym->issaved = StoreState; /* v2.10 */

	movzx	eax, BYTE PTR StoreState
	shl	al, 4
	xor	al, BYTE PTR [rbx+41]
	and	al, 16
	xor	BYTE PTR [rbx+41], al
	jmp	SHORT $LN7@CreateVari
$LN2@CreateVari:

; 291  : #endif
; 292  :     } else if ( sym->state == SYM_UNDEFINED ) {

	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN4@CreateVari

; 293  :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	rdx, rax
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table

; 294  :         sym->fwdref = TRUE;

	or	BYTE PTR [rbx+41], 32			; 00000020H

; 295  : #if FASTPASS
; 296  :         sym->issaved = StoreState; /* v2.10 */

	movzx	ecx, BYTE PTR StoreState
	shl	cl, 4
	xor	cl, BYTE PTR [rbx+41]
	and	cl, 16
	xor	BYTE PTR [rbx+41], cl

; 297  : #endif
; 298  :     } else {

	jmp	SHORT $LN7@CreateVari
$LN4@CreateVari:

; 299  :         if ( sym->isequate == FALSE ) {

	test	BYTE PTR [rax+40], 16
	jne	SHORT $LN6@CreateVari

; 300  :             EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, rdi
	mov	ecx, 144				; 00000090H
	call	EmitErr

; 301  :             return( NULL );

	xor	eax, eax

; 322  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@CreateVari:

; 302  :         }
; 303  : #if FASTPASS
; 304  :         /*
; 305  :          * v2.09: don't save variable when it is defined the first time
; 306  :          * v2.10: store state only when variable is changed and has been
; 307  :          * defined BEFORE SaveState() has been called.
; 308  :          */
; 309  :         //if ( StoreState && sym->issaved == FALSE && sym->isdefined == TRUE ) {
; 310  :         if ( StoreState && sym->issaved == FALSE ) {

	cmp	BYTE PTR StoreState, 0
	je	SHORT $LN7@CreateVari
	test	BYTE PTR [rax+41], 16
	jne	SHORT $LN7@CreateVari

; 311  :             SaveVariableState( sym );

	mov	rcx, rax
	call	SaveVariableState
$LN7@CreateVari:

; 312  :         }
; 313  : #endif
; 314  :     }
; 315  :     sym->isdefined  = TRUE;
; 316  :     sym->state    = SYM_INTERNAL;
; 317  :     //sym->mem_type = MT_ABS;
; 318  :     sym->variable = TRUE;
; 319  :     sym->value    = value;
; 320  :     sym->isequate = TRUE;

	or	BYTE PTR [rbx+40], 82			; 00000052H

; 321  :     return( sym );

	mov	rax, rbx
	mov	DWORD PTR [rbx+16], esi

; 322  : }

	mov	rsi, QWORD PTR [rsp+56]
	mov	DWORD PTR [rbx+32], 1
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CreateVariable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\equate.c
_TEXT	SEGMENT
opnd$ = 48
argbuffer$ = 160
i$ = 800
tokenarray$ = 800
CreateConstant PROC

; 339  : {

$LN47:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rbp
	push	rdi
	push	r15
	lea	rbp, QWORD PTR [rsp-512]
	sub	rsp, 768				; 00000300H

; 340  :     struct asym         *sym;
; 341  :     const char          *name = tokenarray[0].string_ptr;

	mov	rsi, QWORD PTR [rcx+8]
	mov	rdi, rcx

; 342  :     int                 i = 2;
; 343  :     ret_code            rc;
; 344  :     char                *p;
; 345  :     bool                cmpvalue = FALSE;
; 346  :     struct expr         opnd;
; 347  :     char                argbuffer[MAX_LINE_LEN];
; 348  : 
; 349  :     DebugMsg1(( "CreateConstant(%s) enter\n", name ));
; 350  : 
; 351  :     sym = SymSearch( name );

	mov	rcx, rsi
	mov	DWORD PTR i$[rbp-256], 2
	xor	r15b, r15b
	call	SymFind

; 352  : 
; 353  :     /* if a literal follows, the equate MUST be(come) a text macro */
; 354  :     if ( tokenarray[2].token == T_STRING && tokenarray[2].string_delim == '<' )

	cmp	BYTE PTR [rdi+64], 9
	mov	rbx, rax
	jne	SHORT $LN2@CreateCons
	cmp	BYTE PTR [rdi+65], 60			; 0000003cH
	jne	SHORT $LN2@CreateCons

; 355  :         return ( SetTextMacro( tokenarray, sym, name, NULL ) );

	xor	r9d, r9d
	mov	r8, rsi
	mov	rdx, rax
	mov	rcx, rdi
	call	SetTextMacro
	jmp	$LN1@CreateCons
$LN2@CreateCons:

; 356  : 
; 357  :     if( sym == NULL ||
; 358  :        sym->state == SYM_UNDEFINED ||

	mov	edx, 1
	test	rax, rax
	je	SHORT $LN5@CreateCons
	mov	eax, DWORD PTR [rax+32]
	test	eax, eax
	je	SHORT $LN5@CreateCons
	cmp	eax, 2
	jne	SHORT $LN3@CreateCons
	test	BYTE PTR [rbx+47], 8
	je	SHORT $LN3@CreateCons
	test	BYTE PTR [rbx+41], 8
	je	SHORT $LN5@CreateCons
$LN3@CreateCons:

; 359  :        ( sym->state == SYM_EXTERNAL && sym->weak == TRUE && sym->isproc == FALSE ) ) {
; 360  :         /* It's a "new" equate.
; 361  :          * wait with definition until type of equate is clear
; 362  :          */
; 363  :     } else if( sym->state == SYM_TMACRO ) {

	cmp	eax, 10
	jne	SHORT $LN6@CreateCons

; 364  : 
; 365  :         return ( SetTextMacro( tokenarray, sym, name, tokenarray[2].tokpos ) );

	mov	r9, QWORD PTR [rdi+88]
	mov	r8, rsi
	mov	rdx, rbx
	mov	rcx, rdi
	call	SetTextMacro
	jmp	$LN1@CreateCons
$LN6@CreateCons:

; 366  : 
; 367  :     } else if( sym->isequate == FALSE ) {

	test	BYTE PTR [rbx+40], 16
	jne	SHORT $LN8@CreateCons

; 368  : 
; 369  :         DebugMsg1(( "CreateConstant(%s) state=%u, mem_type=%Xh, value=%" I32_SPEC "X, symbol redefinition\n", name, sym->state, sym->mem_type, sym->value));
; 370  :         EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, rsi
	mov	ecx, 144				; 00000090H
	call	EmitErr

; 371  :         return( NULL );

	xor	eax, eax
	jmp	$LN1@CreateCons
$LN8@CreateCons:

; 372  : 
; 373  :     } else {
; 374  :         if ( sym->asmpass == ( Parse_Pass & 0xFF ) )

	mov	eax, DWORD PTR Parse_Pass
	cmp	BYTE PTR [rbx+46], al
	movzx	r15d, r15b
	cmove	r15d, edx

; 375  :             cmpvalue = TRUE;
; 376  :         sym->asmpass = Parse_Pass;

	mov	BYTE PTR [rbx+46], al
$LN5@CreateCons:

; 377  :     }
; 378  : 
; 379  :     /* try to evaluate the expression */
; 380  : 
; 381  :     if ( tokenarray[2].token == T_NUM && Token_Count == 3 ) {

	cmp	BYTE PTR [rdi+64], 10
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	QWORD PTR [rsp+808], r14
	jne	SHORT $LN11@CreateCons
	cmp	r8d, 3
	jne	SHORT $LN11@CreateCons

; 382  : 
; 383  :         p = tokenarray[2].string_ptr;

	mov	r14, QWORD PTR [rdi+72]
	jmp	SHORT $do_single_number$48
$LN11@CreateCons:

; 404  :         p = tokenarray[2].tokpos;
; 405  :         if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	r14, QWORD PTR [rdi+88]
	jne	SHORT $LN17@CreateCons

; 406  :             /* if the expression cannot be evaluated to a numeric value,
; 407  :              * it's to become a text macro. The value of this macro will be
; 408  :              * the original (unexpanded!) line - that's why it has to be
; 409  :              * saved here to argbuffer[].
; 410  :              */
; 411  :             strcpy( argbuffer, p );

	lea	r8, QWORD PTR argbuffer$[rbp-256]
	mov	rcx, r14
	sub	r8, r14
	npad	14
$LL37@CreateCons:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [r8+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL37@CreateCons

; 412  :             DebugMsg1(("CreateConstant(%s): before ExpandLineItems: >%s<\n", name, p ));
; 413  :             /* expand EQU argument (macro functions won't be expanded!) */
; 414  :             if ( ExpandLineItems( p, 2, tokenarray, FALSE, TRUE ) )

	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], edx
	mov	r8, rdi
	mov	rcx, r14
	lea	edx, QWORD PTR [r9+2]
	call	ExpandLineItems

; 415  :                 /* v2.08: if expansion result is a plain number, handle is specifically.
; 416  :                  * this is necessary because values of expressions may be 64-bit now.
; 417  :                  */
; 418  :                 p = argbuffer; /* ensure that p points to unexpanded source */
; 419  :                 if ( tokenarray[2].token == T_NUM && Token_Count == 3 ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	rcx, QWORD PTR argbuffer$[rbp-256]
	test	eax, eax
	cmove	rcx, r14
	cmp	BYTE PTR [rdi+64], 10
	mov	r14, rcx
	jne	SHORT $LN17@CreateCons
	cmp	r8d, 3
	jne	SHORT $LN17@CreateCons
$do_single_number$48:

; 384  :     do_single_number:
; 385  :         /* value is a plain number. it will be accepted only if it fits into 32-bits.
; 386  :          * Else a text macro is created.
; 387  :          */
; 388  :         myatoi128( tokenarray[2].string_ptr, &opnd.llvalue, tokenarray[2].numbase, tokenarray[2].itemlen );

	movsx	r8d, BYTE PTR [rdi+65]
	lea	rdx, QWORD PTR opnd$[rsp]
	mov	r9d, DWORD PTR [rdi+80]
	mov	rcx, QWORD PTR [rdi+72]
	call	myatoi128
	mov	ecx, DWORD PTR i$[rbp-256]
	jmp	SHORT $check_single_number$49
$LN17@CreateCons:

; 420  :                     goto do_single_number;
; 421  :                 }
; 422  :             DebugMsg1(("CreateConstant(%s): after ExpandLineItems: >%s<\n", name, p ));
; 423  :         }
; 424  :         rc = EvalOperand( &i, tokenarray, Token_Count, &opnd, EXPF_NOERRMSG | EXPF_NOUNDEF );

	lea	r9, QWORD PTR opnd$[rsp]
	mov	BYTE PTR [rsp+32], 3
	mov	rdx, rdi
	lea	rcx, QWORD PTR i$[rbp-256]
	call	EvalOperand

; 425  : 
; 426  :         /* v2.08: if it's a quoted string, handle it like a plain number */
; 427  :         /* v2.10: quoted_string field is != 0 if kind == EXPR_FLOAT,
; 428  :          * so this is a regression in v2.08-2.09.
; 429  :          */
; 430  :         if ( opnd.quoted_string && opnd.kind == EXPR_CONST ) {

	cmp	QWORD PTR opnd$[rsp+16], 0
	mov	edx, DWORD PTR opnd$[rsp+60]
	je	SHORT $LN18@CreateCons
	test	edx, edx
	jne	SHORT $LN18@CreateCons

; 431  :             i--; /* v2.09: added; regression in v2.08 and v2.08a */

	mov	ecx, DWORD PTR i$[rbp-256]
	dec	ecx
	mov	DWORD PTR i$[rbp-256], ecx
$check_single_number$49:

; 389  :     check_single_number:
; 390  :         opnd.instr = EMPTY;
; 391  :         opnd.kind = EXPR_CONST;

	mov	r9, QWORD PTR opnd$[rsp+8]
	xor	edx, edx
	mov	DWORD PTR opnd$[rsp+60], edx
	mov	r10d, -2
	mov	DWORD PTR opnd$[rsp+56], r10d

; 392  :         opnd.mem_type = MT_EMPTY; /* v2.07: added */

	mov	DWORD PTR opnd$[rsp+64], 192		; 000000c0H

; 393  :         opnd.flags1 = 0;

	mov	BYTE PTR opnd$[rsp+76], dl

; 394  :         /* v2.08: does it fit in 32-bits */
; 395  :         if ( opnd.hlvalue == 0 && opnd.value64 >= minintvalues[ModuleInfo.Ofssize] &&

	test	r9, r9
	jne	SHORT $LN13@CreateCons
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	r11, OFFSET FLAT:__ImageBase
	mov	r8, QWORD PTR opnd$[rsp]
	cmp	r8, QWORD PTR minintvalues[r11+rax*8]
	jl	SHORT $LN13@CreateCons
	cmp	r8, QWORD PTR maxintvalues[r11+rax*8]
	jg	SHORT $LN13@CreateCons

; 396  :             opnd.value64 <= maxintvalues[ModuleInfo.Ofssize] ) {
; 397  :             rc = NOT_ERROR;
; 398  :             DebugMsg1(( "CreateConstant(%s): simple numeric value=%" I64_SPEC "d\n", name, opnd.value64 ));
; 399  :             i++;

	inc	ecx
	mov	DWORD PTR i$[rbp-256], ecx

; 402  : 
; 403  :     } else {

	jmp	SHORT $LN41@CreateCons
$LN13@CreateCons:

; 400  :         } else
; 401  :             return ( SetTextMacro( tokenarray, sym, name, p ) );

	mov	r9, r14
	jmp	SHORT $LN44@CreateCons
$LN18@CreateCons:

; 432  :             goto check_single_number;
; 433  :         }
; 434  : 
; 435  :         /* check here if last token has been reached? */
; 436  :     }
; 437  :     /* what is an acceptable 'number' for EQU?
; 438  :      * 1. a numeric value - if magnitude is <= 64 (or 32, if it's a plain number)
; 439  :      *    This includes struct fields.
; 440  :      * 2. an address - if it is direct, has a label and is of type SYM_INTERNAL -
; 441  :      *    that is, no forward references, no seg, groups, externals;
; 442  :      *    Anything else will be stored as a text macro.
; 443  :      * v2.04: large parts rewritten.
; 444  :      */
; 445  :     if ( rc != ERROR &&
; 446  :         tokenarray[i].token == T_FINAL &&
; 447  :         ( ( opnd.kind == EXPR_CONST && opnd.hlvalue == 0 ) || /* magnitude <= 64 bits? */
; 448  :          ( opnd.kind == EXPR_ADDR && opnd.indirect == FALSE &&
; 449  :           opnd.sym != NULL &&
; 450  :           //opnd.sym->state != SYM_EXTERNAL ) ) && /* SYM_SEG, SYM_GROUP are also not ok */
; 451  :           opnd.sym->state == SYM_INTERNAL ) ) &&

	cmp	eax, -1
	je	SHORT $LN19@CreateCons
	mov	ecx, DWORD PTR i$[rbp-256]
	mov	r10d, DWORD PTR opnd$[rsp+56]
	mov	r9, QWORD PTR opnd$[rsp+8]
$LN41@CreateCons:
	movsxd	rax, ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 0
	jne	SHORT $LN19@CreateCons
	mov	r8, QWORD PTR opnd$[rbp-176]
	test	edx, edx
	jne	SHORT $LN21@CreateCons
	test	r9, r9
	je	SHORT $LN20@CreateCons
$LN19@CreateCons:

; 494  :     }
; 495  :     DebugMsg1(("CreateConstant(%s): calling SetTextMacro() [MI.Ofssize=%u]\n", name, ModuleInfo.Ofssize ));
; 496  :     return ( SetTextMacro( tokenarray, sym, name, argbuffer ) );

	lea	r9, QWORD PTR argbuffer$[rbp-256]
$LN44@CreateCons:
	mov	r8, rsi
	mov	rdx, rbx
	mov	rcx, rdi
	call	SetTextMacro
$LN43@CreateCons:
	mov	r14, QWORD PTR [rsp+808]
$LN1@CreateCons:

; 497  : }

	lea	r11, QWORD PTR [rsp+768]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r15
	pop	rdi
	pop	rbp
	ret	0
$LN21@CreateCons:

; 432  :             goto check_single_number;
; 433  :         }
; 434  : 
; 435  :         /* check here if last token has been reached? */
; 436  :     }
; 437  :     /* what is an acceptable 'number' for EQU?
; 438  :      * 1. a numeric value - if magnitude is <= 64 (or 32, if it's a plain number)
; 439  :      *    This includes struct fields.
; 440  :      * 2. an address - if it is direct, has a label and is of type SYM_INTERNAL -
; 441  :      *    that is, no forward references, no seg, groups, externals;
; 442  :      *    Anything else will be stored as a text macro.
; 443  :      * v2.04: large parts rewritten.
; 444  :      */
; 445  :     if ( rc != ERROR &&
; 446  :         tokenarray[i].token == T_FINAL &&
; 447  :         ( ( opnd.kind == EXPR_CONST && opnd.hlvalue == 0 ) || /* magnitude <= 64 bits? */
; 448  :          ( opnd.kind == EXPR_ADDR && opnd.indirect == FALSE &&
; 449  :           opnd.sym != NULL &&
; 450  :           //opnd.sym->state != SYM_EXTERNAL ) ) && /* SYM_SEG, SYM_GROUP are also not ok */
; 451  :           opnd.sym->state == SYM_INTERNAL ) ) &&

	cmp	edx, 1
	jne	SHORT $LN19@CreateCons
	test	BYTE PTR opnd$[rsp+76], dl
	jne	SHORT $LN19@CreateCons
	test	r8, r8
	je	SHORT $LN19@CreateCons
	cmp	DWORD PTR [r8+32], edx
	jne	SHORT $LN19@CreateCons
$LN20@CreateCons:
	cmp	r10d, -2
	jne	SHORT $LN19@CreateCons

; 452  :         ( opnd.instr == EMPTY ) ) {
; 453  : 
; 454  :         if ( !sym ) {

	test	rbx, rbx
	jne	SHORT $LN22@CreateCons

; 455  :             sym = SymCreate( name );

	mov	rcx, rsi
	call	SymCreate
	mov	rbx, rax

; 456  :             sym->asmpass = Parse_Pass;

	movzx	eax, BYTE PTR Parse_Pass
	mov	BYTE PTR [rbx+46], al
$LN34@CreateCons:

; 477  :                 }
; 478  :             }
; 479  :         }
; 480  :         /* change from alias to number is ok if value (=offset) won't change!
; 481  :          * memtype must not be checked!
; 482  :          */
; 483  :         //if ( opnd.kind == EXPR_CONST ) {
; 484  :         //    if ( sym->mem_type != MT_ABS && sym->mem_type != MT_EMPTY ) {
; 485  :         //        EmitErr( SYMBOL_REDEFINITION, name );
; 486  :         //        return( NULL );
; 487  :         //    }
; 488  :         //}
; 489  :         sym->variable = FALSE;

	and	BYTE PTR [rbx+40], 191			; 000000bfH

; 490  :         SetValue( sym, &opnd );

	lea	rdx, QWORD PTR opnd$[rsp]
	mov	rcx, rbx
	call	SetValue

; 491  :         DebugMsg1(("CreateConstant(%s): memtype=%Xh value=%" I64_SPEC "X isproc=%u variable=%u type=%s\n",
; 492  :             name, sym->mem_type, (uint_64)sym->value + ( (uint_64)sym->value3264 << 32), sym->isproc, sym->variable, sym->type ? sym->type->name : "NULL" ));
; 493  :         return( sym );

	mov	rax, rbx
	jmp	SHORT $LN43@CreateCons
$LN22@CreateCons:

; 457  :         } else if ( sym->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [rbx+32]
	test	eax, eax
	jne	SHORT $LN24@CreateCons

; 458  :             sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table

; 459  :             sym->fwdref = TRUE;

	or	BYTE PTR [rbx+41], 32			; 00000020H
	jmp	SHORT $LN34@CreateCons
$LN24@CreateCons:

; 460  :         } else if ( sym->state == SYM_EXTERNAL ) {

	cmp	eax, 2
	jne	SHORT $LN26@CreateCons

; 461  :             sym_ext2int( sym );

	mov	rcx, rbx
	call	sym_ext2int
	jmp	SHORT $LN34@CreateCons
$LN26@CreateCons:

; 462  :         } else if ( cmpvalue ) {

	test	r15b, r15b
	je	SHORT $LN34@CreateCons

; 463  :             if ( opnd.kind == EXPR_CONST ) {

	test	edx, edx
	jne	SHORT $LN29@CreateCons

; 464  :                 /* for 64bit, it may be necessary to check 64bit value! */
; 465  :                 /* v2.08: always compare 64-bit values */
; 466  :                 //if ( sym->value != opnd.value ) {
; 467  :                 if ( sym->value != opnd.value || sym->value3264 != opnd.hvalue ) {

	mov	eax, DWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rbx+16], eax
	jne	SHORT $LN35@CreateCons
	mov	eax, DWORD PTR opnd$[rsp+4]
	cmp	DWORD PTR [rbx+56], eax

; 468  :                     DebugMsg(("CreateConstant(%s), CONST value changed: old=%X, new=%X\n", name, sym->offset, opnd.value ));
; 469  :                     EmitErr( SYMBOL_REDEFINITION, name );
; 470  :                     return( NULL );

	jmp	SHORT $LN45@CreateCons
$LN29@CreateCons:

; 471  :                 }
; 472  :             } else if ( opnd.kind == EXPR_ADDR ) {

	cmp	edx, 1
	jne	SHORT $LN34@CreateCons

; 473  :                 if ( ( sym->offset != ( opnd.sym->offset + opnd.value ) ) || ( sym->segment != opnd.sym->segment ) ) {

	mov	ecx, DWORD PTR [r8+16]
	add	ecx, DWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rbx+16], ecx
	jne	SHORT $LN35@CreateCons
	mov	rax, QWORD PTR [r8+24]
	cmp	QWORD PTR [rbx+24], rax
$LN45@CreateCons:
	je	SHORT $LN34@CreateCons
$LN35@CreateCons:

; 474  :                     DebugMsg(("CreateConstant(%s), ADDR value changed: old=%X, new ofs+val=%X+%X\n", name, sym->offset, opnd.sym->offset, opnd.value));
; 475  :                     EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, rsi
	mov	ecx, 144				; 00000090H
	call	EmitErr

; 476  :                     return( NULL );

	xor	eax, eax
	jmp	$LN43@CreateCons
CreateConstant ENDP
_TEXT	ENDS
END
