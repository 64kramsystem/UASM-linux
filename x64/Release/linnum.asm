; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11399 DB	'$$$%05u', 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	sprintf
PUBLIC	AddLinnumDataRef
PUBLIC	LinnumInit
PUBLIC	LinnumFini
PUBLIC	QueueDeleteLinnum
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	EmitWarn:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymFind:PROC
EXTRN	GetLineNumber:PROC
EXTRN	SetSymSegOfs:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	TypeFromClassName:PROC
EXTRN	CreateProc:PROC
EXTRN	AddPublicData:PROC
EXTRN	omf_check_flush:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	write_to_file:BYTE
EXTRN	CurrProc:QWORD
EXTRN	LinnumQueue:BYTE
EXTRN	procidx:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
dmyproc	DQ	01H DUP (?)
lastLineNumber DD 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN8
	DD	imagerel $LN8+90
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$AddLinnumDataRef DD imagerel $LN23
	DD	imagerel $LN23+683
	DD	imagerel $unwind$AddLinnumDataRef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AddLinnumData DD imagerel AddLinnumData
	DD	imagerel AddLinnumData+124
	DD	imagerel $unwind$AddLinnumData
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddLinnumData DD 020601H
	DD	030023206H
xdata	ENDS
xdata	SEGMENT
$unwind$AddLinnumDataRef DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\linnum.c
;	COMDAT AddLinnumData
_TEXT	SEGMENT
data$ = 48
AddLinnumData PROC					; COMDAT

; 40   : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 41   :     struct qdesc *q;
; 42   : #if COFF_SUPPORT
; 43   :     if ( Options.output_format == OFORMAT_COFF ) {

	cmp	DWORD PTR Options+144, 2
	mov	rbx, rcx
	jne	SHORT $LN2@AddLinnumD

; 44   :         q = (struct qdesc *)CurrSeg->e.seginfo->LinnumQueue;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rdx, QWORD PTR [rax+96]
	mov	r8, QWORD PTR [rdx+56]

; 45   :         if ( q == NULL ) {

	test	r8, r8
	jne	SHORT $LN3@AddLinnumD

; 46   :             q = LclAlloc( sizeof( struct qdesc ) );

	lea	ecx, QWORD PTR [r8+16]
	call	LclAlloc

; 47   :             CurrSeg->e.seginfo->LinnumQueue = q;

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	r8, rax
	mov	rdx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rdx+56], rax

; 48   :             q->head = NULL;

	mov	QWORD PTR [rax], 0

; 49   :         }
; 50   :     } else

	jmp	SHORT $LN3@AddLinnumD
$LN2@AddLinnumD:

; 51   : #endif
; 52   :         q = &LinnumQueue;

	lea	r8, OFFSET FLAT:LinnumQueue
$LN3@AddLinnumD:

; 53   : 
; 54   :     data->next = NULL;

	mov	QWORD PTR [rbx], 0

; 55   :     if ( q->head == NULL)

	cmp	QWORD PTR [r8], 0
	jne	SHORT $LN5@AddLinnumD

; 56   :         q->head = q->tail = data;

	mov	QWORD PTR [r8], rbx

; 59   :         q->tail = data;

	mov	QWORD PTR [r8+8], rbx

; 60   :     }
; 61   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@AddLinnumD:

; 57   :     else {
; 58   :         ((struct line_num_info *)q->tail)->next = data;

	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR [rax], rbx

; 59   :         q->tail = data;

	mov	QWORD PTR [r8+8], rbx

; 60   :     }
; 61   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
AddLinnumData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\linnum.c
_TEXT	SEGMENT
queue$ = 8
QueueDeleteLinnum PROC

; 203  :     struct line_num_info    *curr;
; 204  :     struct line_num_info    *next;
; 205  : 
; 206  :     if ( queue == NULL )
; 207  :         return;
; 208  :     curr = queue->head;
; 209  :     for( ; curr ; curr = next ) {
; 210  :         next = curr->next;
; 211  :         LclFree( curr );
; 212  :     }
; 213  :     return;
; 214  : }

	ret	0
QueueDeleteLinnum ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\linnum.c
_TEXT	SEGMENT
LinnumFini PROC

; 222  : #if COFF_SUPPORT
; 223  :     if ( dmyproc ) {

	mov	rdx, QWORD PTR dmyproc
	test	rdx, rdx
	je	SHORT $LN2@LinnumFini

; 224  :         dmyproc->total_size =

	mov	rax, QWORD PTR [rdx+24]
	mov	rcx, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rcx+12]
	sub	eax, DWORD PTR [rdx+16]
	mov	DWORD PTR [rdx+56], eax
$LN2@LinnumFini:

; 225  :             ((struct dsym *)dmyproc->segment)->e.seginfo->current_loc -
; 226  :             dmyproc->offset;
; 227  :         DebugMsg(("LinnumFini: last dummy proc size=%Xh\n"));
; 228  :     }
; 229  : #endif
; 230  : }

	ret	0
LinnumFini ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\linnum.c
_TEXT	SEGMENT
LinnumInit PROC

; 235  :     lastLineNumber = 0;

	xor	eax, eax
	mov	DWORD PTR lastLineNumber, eax

; 236  : #if COFF_SUPPORT
; 237  :     dmyproc = NULL;

	mov	QWORD PTR dmyproc, rax

; 238  : #endif
; 239  : }

	ret	0
LinnumInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\linnum.c
_TEXT	SEGMENT
procname$1 = 32
srcfile$ = 64
line_num$ = 72
AddLinnumDataRef PROC

; 71   : {

$LN23:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 72   :     struct line_num_info    *curr;
; 73   : 
; 74   : #if COFF_SUPPORT
; 75   :     /* COFF line number info is related to functions/procedures. Since
; 76   :      * assembly allows code lines outside of procs, "dummy" procs must
; 77   :      * be generated. A dummy proc lasts until
; 78   :      * - a true PROC is detected or
; 79   :      * - the source file changes or
; 80   :      * - the segment/section changes ( added in v2.11 )
; 81   :      */
; 82   :     if ( Options.output_format == OFORMAT_COFF &&
; 83   :         CurrProc == NULL &&

	cmp	DWORD PTR Options+144, 2
	mov	edi, edx
	mov	esi, ecx
	jne	$LN20@AddLinnumD
	cmp	QWORD PTR CurrProc, 0
	jne	$LN20@AddLinnumD
	mov	r8, QWORD PTR dmyproc
	test	r8, r8
	je	SHORT $LN4@AddLinnumD
	mov	rax, QWORD PTR [r8+64]
	movzx	ecx, WORD PTR [rax+14]
	cmp	ecx, esi
	jne	SHORT $LN3@AddLinnumD
	mov	rax, QWORD PTR ModuleInfo+432
	cmp	QWORD PTR [r8+24], rax
	je	$LN20@AddLinnumD
$LN3@AddLinnumD:

; 84   :         ( dmyproc == NULL ||
; 85   :         dmyproc->debuginfo->file != srcfile ||
; 86   :         dmyproc->segment != (struct asym *)CurrSeg ) ) {
; 87   :         char procname[12];
; 88   :         if ( dmyproc ) {
; 89   :             /**/myassert( dmyproc->segment );
; 90   :             dmyproc->total_size =

	mov	rax, QWORD PTR [r8+24]
	mov	rcx, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rcx+12]
	sub	eax, DWORD PTR [r8+16]
	mov	DWORD PTR [r8+56], eax
$LN4@AddLinnumD:

; 91   :                 ((struct dsym *)dmyproc->segment)->e.seginfo->current_loc -
; 92   :                 dmyproc->offset;
; 93   :         }
; 94   :         sprintf( procname, "$$$%05u", procidx );

	mov	r8d, DWORD PTR procidx
	lea	rdx, OFFSET FLAT:$SG11399
	lea	rcx, QWORD PTR procname$1[rsp]
	call	sprintf

; 95   :         DebugMsg1(("AddLinnumDataRef(src=%u.%u): CurrProc==NULL, dmyproc=%s searching proc=%s\n", srcfile, line_num, dmyproc ? dmyproc->name : "NULL", procname ));
; 96   :         dmyproc = SymSearch( procname );

	lea	rcx, QWORD PTR procname$1[rsp]
	call	SymFind
	mov	QWORD PTR dmyproc, rax

; 97   : 
; 98   :         /* in pass 1, create the proc */
; 99   :         if ( dmyproc == NULL ) {

	test	rax, rax
	jne	SHORT $LN5@AddLinnumD

; 100  :             dmyproc = CreateProc( NULL, procname, SYM_INTERNAL );

	lea	r8d, QWORD PTR [rax+1]
	xor	ecx, ecx
	lea	rdx, QWORD PTR procname$1[rsp]
	call	CreateProc

; 101  :             DebugMsg1(("AddLinnumDataRef: new proc %s created\n", procname ));
; 102  :             dmyproc->isproc = TRUE; /* flag is usually set inside ParseProc() */
; 103  :             dmyproc->included = TRUE;
; 104  :             AddPublicData( dmyproc );

	mov	rcx, rax
	mov	QWORD PTR dmyproc, rax
	or	BYTE PTR [rax+41], 72			; 00000048H
	call	AddPublicData

; 105  :         } else

	mov	rax, QWORD PTR dmyproc
	jmp	SHORT $LN6@AddLinnumD
$LN5@AddLinnumD:

; 106  :             procidx++; /* for passes > 1, adjust procidx */

	inc	DWORD PTR procidx
$LN6@AddLinnumD:

; 107  : 
; 108  :         /* if the symbols isn't a PROC, the symbol name has been used
; 109  :          * by the user - bad! A warning should be displayed */
; 110  :         if ( dmyproc->isproc == TRUE ) {

	test	BYTE PTR [rax+41], 8
	je	SHORT $LN20@AddLinnumD

; 111  :             SetSymSegOfs( dmyproc );

	mov	rcx, rax
	call	SetSymSegOfs

; 112  :             dmyproc->Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	rcx, QWORD PTR dmyproc
	mov	BYTE PTR [rcx+44], al

; 113  :             dmyproc->langtype = ModuleInfo.langtype;

	mov	eax, DWORD PTR ModuleInfo+364
	mov	DWORD PTR [rcx+76], eax

; 114  :             if ( write_to_file == TRUE ) {

	cmp	BYTE PTR write_to_file, 1
	jne	SHORT $LN20@AddLinnumD

; 115  :                 curr = LclAlloc( sizeof( struct line_num_info ) );

	mov	ecx, 24
	call	LclAlloc

; 116  :                 curr->sym = dmyproc;

	mov	rcx, QWORD PTR dmyproc
	mov	rbx, rax
	mov	QWORD PTR [rax+16], rcx

; 117  :                 curr->line_number = GetLineNumber();

	call	GetLineNumber

; 118  :                 curr->file = srcfile;

	mov	ecx, esi

; 119  :                 curr->number = 0;

	mov	DWORD PTR [rbx+8], 0
	shl	ecx, 20
	and	eax, 1048575				; 000fffffH
	or	eax, ecx

; 120  :                 DebugMsg1(("AddLinnumDataRef: CURRPROC=NULL, sym=%s, calling AddLinnumData(src=%u.%u)\n", curr->sym->name, curr->file, curr->line_number ));
; 121  :                 AddLinnumData( curr );

	mov	rcx, rbx
	mov	DWORD PTR [rbx+12], eax
	call	AddLinnumData
$LN20@AddLinnumD:

; 122  :             }
; 123  :         }
; 124  :     }
; 125  : #endif
; 126  : 
; 127  :     if(  line_num && ( write_to_file == FALSE || lastLineNumber == line_num )) {

	test	edi, edi
	je	SHORT $LN9@AddLinnumD
	cmp	BYTE PTR write_to_file, 0
	je	$LN1@AddLinnumD
	cmp	DWORD PTR lastLineNumber, edi
	je	$LN1@AddLinnumD
$LN9@AddLinnumD:

; 128  : #ifdef DEBUG_OUT
; 129  :         if ( write_to_file == TRUE )
; 130  :             DebugMsg1(("AddLinnumDataRef(src=%u.%u) line skipped, lastline=%u\n", srcfile, line_num, lastLineNumber ));
; 131  : #endif
; 132  :         return;
; 133  :     }
; 134  :     DebugMsg1(("AddLinnumDataRef(src=%u.%u): currofs=%Xh, CurrProc=%s, GeneratedCode=%u\n", srcfile, line_num, GetCurrOffset(), CurrProc ? CurrProc->sym.name : "NULL", ModuleInfo.GeneratedCode ));
; 135  : 
; 136  :     curr = LclAlloc( sizeof( struct line_num_info ) );

	mov	ecx, 24
	call	LclAlloc
	mov	rbx, rax

; 137  :     curr->number = line_num;

	mov	DWORD PTR [rax+8], edi

; 138  : #if COFF_SUPPORT
; 139  :     if ( line_num == 0 ) { /* happens for COFF only */

	test	edi, edi
	jne	$LN11@AddLinnumD

; 140  :         /* changed v2.03 (CurrProc might have been NULL) */
; 141  :         /* if ( Options.output_format == OFORMAT_COFF && CurrProc->sym.public == FALSE ) { */
; 142  :         /* v2.09: avoid duplicates, check for pass 1 */
; 143  :         //if ( Options.output_format == OFORMAT_COFF && CurrProc && CurrProc->sym.public == FALSE ) {
; 144  :         if ( Parse_Pass == PASS_1 &&
; 145  :             Options.output_format == OFORMAT_COFF && CurrProc && CurrProc->sym.ispublic == FALSE ) {

	cmp	DWORD PTR Parse_Pass, edi
	jne	SHORT $LN21@AddLinnumD
	cmp	DWORD PTR Options+144, 2
	jne	SHORT $LN21@AddLinnumD
	mov	rcx, QWORD PTR CurrProc
	test	rcx, rcx
	je	SHORT $LN13@AddLinnumD
	test	BYTE PTR [rcx+40], 128			; 00000080H
	jne	SHORT $LN13@AddLinnumD

; 146  :             CurrProc->sym.included = TRUE;

	or	BYTE PTR [rcx+41], 64			; 00000040H

; 147  :             AddPublicData( (struct asym *)CurrProc );

	mov	rcx, QWORD PTR CurrProc
	call	AddPublicData
$LN21@AddLinnumD:
	mov	rcx, QWORD PTR CurrProc
$LN13@AddLinnumD:

; 148  :         }
; 149  :         /* changed v2.03 */
; 150  :         /* curr->sym = (struct asym *)CurrProc; */
; 151  :         curr->sym = ( CurrProc ? (struct asym *)CurrProc : dmyproc );

	mov	rax, QWORD PTR dmyproc
	test	rcx, rcx
	cmovne	rax, rcx
	mov	QWORD PTR [rbx+16], rax

; 152  :         curr->line_number = GetLineNumber();

	call	GetLineNumber

; 153  :         curr->file        = srcfile;
; 154  :         /* set the function's size! */
; 155  :         if ( dmyproc ) {

	mov	rdx, QWORD PTR dmyproc
	and	eax, 1048575				; 000fffffH
	mov	ecx, esi
	shl	ecx, 20
	or	eax, ecx
	mov	DWORD PTR [rbx+12], eax
	test	rdx, rdx
	je	SHORT $LN14@AddLinnumD

; 156  :             /**/myassert( dmyproc->segment );
; 157  :             dmyproc->total_size =

	mov	rax, QWORD PTR [rdx+24]

; 158  :                 ((struct dsym *)dmyproc->segment)->e.seginfo->current_loc -
; 159  :                 dmyproc->offset;
; 160  :             dmyproc = NULL;

	mov	QWORD PTR dmyproc, 0
	mov	rcx, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rcx+12]
	sub	eax, DWORD PTR [rdx+16]
	mov	DWORD PTR [rdx+56], eax
$LN14@AddLinnumD:

; 161  :         }
; 162  :         /* v2.11: write a 0x7fff line item if prologue exists */
; 163  :         if ( CurrProc && CurrProc->e.procinfo->size_prolog ) {

	mov	rax, QWORD PTR CurrProc
	test	rax, rax
	je	SHORT $LN12@AddLinnumD
	mov	rax, QWORD PTR [rax+96]
	cmp	BYTE PTR [rax+85], 0
	je	SHORT $LN12@AddLinnumD

; 164  :             DebugMsg1(("AddLinnumDataRef: calling AddLinnumData(src=%u.%u) sym=%s\n", curr->file, curr->line_number, curr->sym->name ));
; 165  :             AddLinnumData( curr );

	mov	rcx, rbx
	call	AddLinnumData

; 166  :             curr = LclAlloc( sizeof( struct line_num_info ) );

	mov	ecx, 24
	call	LclAlloc
	mov	rbx, rax

; 167  :             curr->number = GetLineNumber();

	call	GetLineNumber
	mov	DWORD PTR [rbx+8], eax
$LN11@AddLinnumD:

; 168  :             curr->offset = GetCurrOffset();
; 169  :             curr->srcfile = srcfile;
; 170  :         }
; 171  :     } else {
; 172  : #endif
; 173  :         curr->offset = GetCurrOffset();

	call	GetCurrOffset

; 174  :         curr->srcfile = srcfile;

	mov	DWORD PTR [rbx+16], esi
	mov	DWORD PTR [rbx+12], eax
$LN12@AddLinnumD:

; 175  : #if COFF_SUPPORT
; 176  :     }
; 177  : #endif
; 178  :     lastLineNumber = line_num;
; 179  : 
; 180  :     /* v2.11: added, improved multi source support for CV.
; 181  :      * Also, the size of line number info could have become > 1024,
; 182  :      * ( even > 4096, thus causing an "internal error in omfint.c" )
; 183  :      */
; 184  :     if ( Options.output_format == OFORMAT_OMF )

	cmp	DWORD PTR Options+144, 1
	mov	DWORD PTR lastLineNumber, edi
	jne	SHORT $LN16@AddLinnumD

; 185  :         omf_check_flush( curr );

	mov	rcx, rbx
	call	omf_check_flush
$LN16@AddLinnumD:

; 186  : 
; 187  :     /* v2.10: warning if line-numbers for segments without class code! */
; 188  :     if ( CurrSeg->e.seginfo->linnum_init == FALSE ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rcx+107]
	test	al, 64					; 00000040H
	jne	SHORT $LN18@AddLinnumD

; 189  :         CurrSeg->e.seginfo->linnum_init = TRUE;

	or	al, 64					; 00000040H
	mov	BYTE PTR [rcx+107], al

; 190  :         if ( TypeFromClassName( CurrSeg, CurrSeg->e.seginfo->clsym ) != SEGTYPE_CODE ) {

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rdx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR [rdx+80]
	call	TypeFromClassName
	cmp	eax, 1
	je	SHORT $LN18@AddLinnumD

; 191  :             EmitWarn( 2, LINNUM_INFO_FOR_SEGMENT_WITHOUT_CLASS_CODE, CurrSeg->sym.name );

	mov	r8, QWORD PTR ModuleInfo+432
	mov	edx, 187				; 000000bbH
	mov	ecx, 2
	mov	r8, QWORD PTR [r8+8]
	call	EmitWarn
$LN18@AddLinnumD:

; 192  :         }
; 193  :     }
; 194  :     DebugMsg1(("AddLinnumDataRef: calling AddLinnumData(src=%u.%u ofs=%X)\n", curr->number == 0 ? curr->file : curr->srcfile, curr->number, curr->offset ));
; 195  :     AddLinnumData( curr );

	mov	rcx, rbx
	call	AddLinnumData
$LN1@AddLinnumD:

; 196  : 
; 197  :     return;
; 198  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
AddLinnumDataRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rdi, rcx

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rbx
	mov	QWORD PTR [rsp+40], rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], 0
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf
	test	eax, eax
	cmovs	eax, ebx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbx
	mov	r9, rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, rbx
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf

; 1459 :     #pragma warning(pop)
; 1460 : }

	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ebx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_Locale$ = 88
_ArgList$ = 96
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR _ArgList$[rsp]
	or	rcx, 1
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rbx
	call	__stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;
; 1391 : }

	mov	rbx, QWORD PTR [rsp+64]
	or	ecx, -1
	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ecx
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
