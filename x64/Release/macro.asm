; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG10852 DB	'%X', 00H
	ORG $+1
$SG10915 DB	'<>"''', 00H
	ORG $+3
$SG11007 DB	'REQ', 00H
$SG11016 DB	'VARARGML', 00H
	ORG $+7
$SG11128 DB	'macro name', 00H
	ORG $+5
$SG11151 DB	'@Environ', 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	sprintf
PUBLIC	CreateMacro
PUBLIC	ReleaseMacroData
PUBLIC	fill_placeholders
PUBLIC	StoreMacro
PUBLIC	MacroInit
PUBLIC	MacroDir
PUBLIC	PurgeDirective
EXTRN	isalpha:PROC
EXTRN	isdigit:PROC
EXTRN	isspace:PROC
EXTRN	isalnum:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	getenv:PROC
EXTRN	memmove:PROC
EXTRN	strchr:PROC
EXTRN	_stricmp:PROC
EXTRN	Fatal:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymCreate:PROC
EXTRN	SymFind:PROC
EXTRN	sym_remove_table:PROC
EXTRN	GetTextLine:PROC
EXTRN	get_curr_srcfile:PROC
EXTRN	GetToken:PROC
EXTRN	StringInit:PROC
EXTRN	LstWrite:PROC
EXTRN	LstWriteSrcLine:PROC
EXTRN	__chkstk:PROC
EXTRN	memcpy:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	MacroLevel:BYTE
EXTRN	SymCmpFunc:QWORD
EXTRN	SymTables:BYTE
EXTRN	MacroLocals:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN8
	DD	imagerel $LN8+90
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$CreateMacro DD imagerel $LN6
	DD	imagerel $LN6+89
	DD	imagerel $unwind$CreateMacro
$pdata$fill_placeholders DD imagerel $LN35
	DD	imagerel $LN35+34
	DD	imagerel $unwind$fill_placeholders
$pdata$1$fill_placeholders DD imagerel $LN35+34
	DD	imagerel $LN35+327
	DD	imagerel $chain$1$fill_placeholders
$pdata$2$fill_placeholders DD imagerel $LN35+327
	DD	imagerel $LN35+344
	DD	imagerel $chain$2$fill_placeholders
$pdata$StoreMacro DD imagerel $LN213
	DD	imagerel $LN213+2235
	DD	imagerel $unwind$StoreMacro
$pdata$MacroInit DD imagerel $LN9
	DD	imagerel $LN9+29
	DD	imagerel $unwind$MacroInit
$pdata$0$MacroInit DD imagerel $LN9+29
	DD	imagerel $LN9+193
	DD	imagerel $chain$0$MacroInit
$pdata$1$MacroInit DD imagerel $LN9+193
	DD	imagerel $LN9+201
	DD	imagerel $chain$1$MacroInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_parm DD imagerel replace_parm
	DD	imagerel replace_parm+301
	DD	imagerel $unwind$replace_parm
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$store_placeholders DD imagerel store_placeholders
	DD	imagerel store_placeholders+55
	DD	imagerel $unwind$store_placeholders
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$store_placeholders DD imagerel store_placeholders+55
	DD	imagerel store_placeholders+520
	DD	imagerel $chain$0$store_placeholders
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$store_placeholders DD imagerel store_placeholders+520
	DD	imagerel store_placeholders+544
	DD	imagerel $chain$1$store_placeholders
pdata	ENDS
pdata	SEGMENT
$pdata$MacroDir DD imagerel $LN33
	DD	imagerel $LN33+362
	DD	imagerel $unwind$MacroDir
$pdata$PurgeDirective DD imagerel $LN40
	DD	imagerel $LN40+253
	DD	imagerel $unwind$PurgeDirective
$pdata$EnvironFunc DD imagerel EnvironFunc
	DD	imagerel EnvironFunc+29
	DD	imagerel $unwind$EnvironFunc
$pdata$0$EnvironFunc DD imagerel EnvironFunc+29
	DD	imagerel EnvironFunc+87
	DD	imagerel $chain$0$EnvironFunc
$pdata$1$EnvironFunc DD imagerel EnvironFunc+87
	DD	imagerel EnvironFunc+95
	DD	imagerel $chain$1$EnvironFunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$store_placeholders DD 021H
	DD	imagerel store_placeholders
	DD	imagerel store_placeholders+55
	DD	imagerel $unwind$store_placeholders
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$store_placeholders DD 020521H
	DD	0a7405H
	DD	imagerel store_placeholders
	DD	imagerel store_placeholders+55
	DD	imagerel $unwind$store_placeholders
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$store_placeholders DD 0a1c01H
	DD	0d541cH
	DD	0c341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	06010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_parm DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
xdata	SEGMENT
$unwind$CreateMacro DD 020601H
	DD	030023206H
$unwind$fill_placeholders DD 060d01H
	DD	0a340dH
	DD	0f009320dH
	DD	050066007H
$chain$1$fill_placeholders DD 040f21H
	DD	08740fH
	DD	09e405H
	DD	imagerel $LN35
	DD	imagerel $LN35+34
	DD	imagerel $unwind$fill_placeholders
$chain$2$fill_placeholders DD 021H
	DD	imagerel $LN35
	DD	imagerel $LN35+34
	DD	imagerel $unwind$fill_placeholders
$unwind$StoreMacro DD 0250c3001H
	DD	02673430H
	DD	011d2322H
	DD	0f010025eH
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
$unwind$MacroInit DD 020601H
	DD	070023206H
$chain$0$MacroInit DD 020521H
	DD	063405H
	DD	imagerel $LN9
	DD	imagerel $LN9+29
	DD	imagerel $unwind$MacroInit
$chain$1$MacroInit DD 021H
	DD	imagerel $LN9
	DD	imagerel $LN9+29
	DD	imagerel $unwind$MacroInit
$unwind$MacroDir DD 081201H
	DD	0a5412H
	DD	083412H
	DD	0e00e3212H
	DD	0600b700cH
$unwind$PurgeDirective DD 081401H
	DD	096414H
	DD	085414H
	DD	063414H
	DD	070103214H
$unwind$EnvironFunc DD 020601H
	DD	070023206H
$chain$0$EnvironFunc DD 020521H
	DD	063405H
	DD	imagerel EnvironFunc
	DD	imagerel EnvironFunc+29
	DD	imagerel $unwind$EnvironFunc
$chain$1$EnvironFunc DD 021H
	DD	imagerel EnvironFunc
	DD	imagerel EnvironFunc+29
	DD	imagerel $unwind$EnvironFunc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
mi$ = 48
buffer$ = 56
tokenarray$ = 64
EnvironFunc PROC

; 782  : {

	push	rdi
	sub	rsp, 32					; 00000020H

; 783  :     char *p = getenv( mi->parm_array[0] );

	mov	rcx, QWORD PTR [rcx+24]
	mov	rdi, rdx
	mov	rcx, QWORD PTR [rcx]
	call	getenv

; 784  :     int i;
; 785  : 
; 786  :     buffer[0] = NULLC;

	mov	BYTE PTR [rdi], 0

; 787  :     if ( p ) {

	test	rax, rax
	je	SHORT $LN6@EnvironFun

; 788  :         i = strlen( p );

	mov	QWORD PTR [rsp+48], rbx
	or	rcx, -1
$LL5@EnvironFun:
	inc	rcx
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL5@EnvironFun

; 789  :         if ( i >= MAX_LINE_LEN )

	cmp	ecx, 600				; 00000258H
	mov	edx, 599				; 00000257H
	cmovge	ecx, edx

; 790  :             i = MAX_LINE_LEN - 1;
; 791  :         memcpy( buffer, p, i );

	mov	rdx, rax
	movsxd	rbx, ecx
	mov	rcx, rdi
	mov	r8, rbx
	call	memcpy

; 792  :         buffer[i] = NULLC;

	mov	BYTE PTR [rbx+rdi], 0
	mov	rbx, QWORD PTR [rsp+48]
$LN6@EnvironFun:

; 793  :     }
; 794  :     return( NOT_ERROR );

	xor	eax, eax

; 795  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
EnvironFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
PurgeDirective PROC

; 736  : {

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 737  :     struct asym *sym;
; 738  : 
; 739  :     i++; /* skip directive */

	lea	edi, DWORD PTR [rcx+1]
	mov	rsi, rdx
	movsxd	rbx, edi
	shl	rbx, 5
	add	rbx, rdx
	xor	ebp, ebp
$LL4@PurgeDirec:

; 740  :     do {
; 741  :         if ( tokenarray[i].token != T_ID ) {

	cmp	BYTE PTR [rbx], 8
	jne	$LN24@PurgeDirec

; 743  :         }
; 744  :         sym = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rbx+8]
	call	SymFind
	mov	rdx, rax

; 745  :         if ( sym == NULL ) {

	test	rax, rax
	je	SHORT $LN26@PurgeDirec

; 747  :         }
; 748  :         if ( sym->state != SYM_MACRO ) {

	cmp	DWORD PTR [rax+32], 9
	jne	SHORT $LN27@PurgeDirec

; 750  :         }
; 751  : #if TRUEPURGE
; 752  :         sym->defined = FALSE;
; 753  : #else
; 754  : #if FASTMEM==0
; 755  :         /* don't free memory of macro data lines if macro is in use */
; 756  :         if ( MacroInUse( (struct dsym *)sym ) ) {
; 757  :             DebugMsg1(("PurgeDirective(%s): macro is in use\n", sym->name ));
; 758  :             ((struct dsym *)sym)->e.macroinfo->data = NULL;
; 759  :         }
; 760  : #endif
; 761  :         ReleaseMacroData( (struct dsym *)sym );

	mov	rcx, QWORD PTR [rax+96]
	mov	WORD PTR [rcx], bp
	mov	rcx, QWORD PTR [rax+96]
	mov	WORD PTR [rcx+2], bp
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+8], rbp
	je	SHORT $LN19@PurgeDirec
	mov	QWORD PTR [rax+8], rbp
$LN19@PurgeDirec:
	mov	rcx, QWORD PTR [rdx+96]

; 762  :         sym->variable = TRUE;
; 763  :         sym->purged = TRUE;
; 764  : #endif
; 765  :         i++;

	inc	edi
	mov	QWORD PTR [rcx+16], rbp
	mov	rax, QWORD PTR [rdx+96]
	mov	DWORD PTR [rax+24], ebp
	and	BYTE PTR [rdx+44], 254			; 000000feH
	or	BYTE PTR [rdx+44], 16
	or	BYTE PTR [rdx+40], 64			; 00000040H

; 766  :         if ( i < Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	edi, eax
	jge	SHORT $LN25@PurgeDirec

; 767  :             if ( tokenarray[i].token != T_COMMA || tokenarray[i+1].token == T_FINAL ) {

	cmp	BYTE PTR [rbx+32], 44			; 0000002cH
	jne	SHORT $LN28@PurgeDirec

; 769  :             }
; 770  :             i++;
; 771  :         }
; 772  :     } while ( i < Token_Count );

	add	rbx, 64					; 00000040H
	cmp	BYTE PTR [rbx], bpl
	je	SHORT $LN28@PurgeDirec
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL4@PurgeDirec
$LN25@PurgeDirec:

; 773  : 
; 774  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@PurgeDirec
$LN28@PurgeDirec:

; 768  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rdx, edi
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	jmp	SHORT $LN37@PurgeDirec
$LN27@PurgeDirec:

; 749  :             return( EmitErr( EXPECTED, "macro name" ) );

	lea	rdx, OFFSET FLAT:$SG11128
	mov	ecx, 231				; 000000e7H
	jmp	SHORT $LN38@PurgeDirec
$LN26@PurgeDirec:

; 746  :             return( EmitErr( SYMBOL_NOT_DEFINED, tokenarray[i].string_ptr ) );

	movsxd	rdx, edi
	mov	ecx, 103				; 00000067H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+8]
	jmp	SHORT $LN38@PurgeDirec
$LN24@PurgeDirec:

; 742  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, edi
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+8]
$LN37@PurgeDirec:
	mov	ecx, 210				; 000000d2H
$LN38@PurgeDirec:
	call	EmitErr
$LN1@PurgeDirec:

; 775  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
PurgeDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
i$ = 64
tokenarray$ = 72
MacroDir PROC

; 675  : {

$LN33:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 676  :     char                *name;
; 677  :     bool                store_data;
; 678  :     struct dsym         *macro;
; 679  : 
; 680  :     name = tokenarray[0].string_ptr;

	mov	rdi, QWORD PTR [rdx+8]
	mov	ebp, ecx

; 681  :     DebugMsg1(("MacroDir(%s) enter, i=%u\n", name, i ));
; 682  : 
; 683  :     macro = (struct dsym *)SymSearch( name );

	mov	rcx, rdi
	mov	rsi, rdx
	call	SymFind

; 684  :     if( macro == NULL ) {

	xor	r14d, r14d
	mov	rbx, rax
	test	rax, rax
	jne	SHORT $LN2@MacroDir

; 685  :         macro = CreateMacro( name );

	mov	rcx, rdi
	call	SymCreate
	mov	rbx, rax
	test	rax, rax
	je	$LN4@MacroDir
	lea	ecx, QWORD PTR [r14+32]
	mov	DWORD PTR [rax+32], 9
	call	LclAlloc
	mov	QWORD PTR [rbx+96], rax
	mov	WORD PTR [rax], r14w
	mov	rax, QWORD PTR [rbx+96]
	mov	WORD PTR [rax+2], r14w
	mov	rax, QWORD PTR [rbx+96]
	mov	QWORD PTR [rax+8], r14
	mov	rax, QWORD PTR [rbx+96]
	mov	QWORD PTR [rax+16], r14
	mov	rax, QWORD PTR [rbx+96]
	mov	DWORD PTR [rax+24], r14d
	and	BYTE PTR [rbx+44], 252			; 000000fcH
	jmp	SHORT $LN4@MacroDir
$LN2@MacroDir:

; 686  :     } else if( macro->sym.state != SYM_MACRO ) {

	mov	eax, DWORD PTR [rax+32]
	cmp	eax, 9
	je	SHORT $LN4@MacroDir

; 687  :         if ( macro->sym.state != SYM_UNDEFINED ) {

	test	eax, eax
	je	SHORT $LN5@MacroDir

; 688  :             return( EmitErr( SYMBOL_REDEFINITION, name ) );

	mov	rdx, rdi
	mov	ecx, 144				; 00000090H
	call	EmitErr
	jmp	$LN1@MacroDir
$LN5@MacroDir:

; 689  :         }
; 690  :         /* the macro was used before it's defined. That's
; 691  :          * a severe error. Nevertheless define the macro now,
; 692  :          * error msg 'invalid symbol type in expression' will
; 693  :          * be displayed in second pass when the (unexpanded)
; 694  :          * macro name is found by the expression evaluator.
; 695  :          */
; 696  :         sym_remove_table( &SymTables[TAB_UNDEF], macro );

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table

; 697  :         macro->sym.state = SYM_MACRO;
; 698  :         macro->e.macroinfo = LclAlloc( sizeof( struct macro_info ) );

	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rbx+32], 9
	call	LclAlloc

; 699  :         memset( macro->e.macroinfo, 0, sizeof( struct macro_info ) );

	xor	ecx, ecx
	mov	QWORD PTR [rbx+96], rax
	mov	QWORD PTR [rax], rcx
	mov	QWORD PTR [rax+8], rcx
	mov	QWORD PTR [rax+16], rcx
	mov	QWORD PTR [rax+24], rcx
$LN4@MacroDir:

; 700  :     }
; 701  :     macro->e.macroinfo->srcfile = get_curr_srcfile();

	call	get_curr_srcfile
	mov	rcx, QWORD PTR [rbx+96]
	mov	DWORD PTR [rcx+24], eax

; 702  : 
; 703  :     if ( ( Parse_Pass == PASS_1 ) || ( macro->sym.variable ) ) {

	cmp	DWORD PTR Parse_Pass, r14d
	je	SHORT $LN8@MacroDir
	test	BYTE PTR [rbx+40], 64			; 00000040H
	jne	SHORT $LN8@MacroDir

; 718  :     } else
; 719  :         store_data = FALSE;

	xor	dil, dil
	jmp	SHORT $LN7@MacroDir
$LN8@MacroDir:

; 704  :         /* is the macro redefined? */
; 705  :         if ( macro->e.macroinfo->data != NULL ) {

	mov	rax, QWORD PTR [rbx+96]
	cmp	QWORD PTR [rax+16], r14
	je	SHORT $LN9@MacroDir

; 706  :             DebugMsg(("MacroDir(%s): macro already defined\n", name));
; 707  : #if FASTMEM==0
; 708  :             /* don't free memory of macro data lines if macro is in use */
; 709  :             if ( MacroInUse( macro ) )
; 710  :                 macro->e.macroinfo->data = NULL;
; 711  : #endif
; 712  :             ReleaseMacroData( macro );

	mov	WORD PTR [rax], r14w
	mov	rax, QWORD PTR [rbx+96]
	mov	WORD PTR [rax+2], r14w
	mov	rax, QWORD PTR [rbx+96]
	cmp	QWORD PTR [rax+8], r14
	je	SHORT $LN22@MacroDir
	mov	QWORD PTR [rax+8], r14
$LN22@MacroDir:
	mov	rcx, QWORD PTR [rbx+96]
	mov	QWORD PTR [rcx+16], r14
	mov	rax, QWORD PTR [rbx+96]
	mov	DWORD PTR [rax+24], r14d

; 713  :             /* v2.07: isfunc isn't reset anymore in ReleaseMacroData() */
; 714  :             macro->sym.isfunc = FALSE;

	and	BYTE PTR [rbx+44], 252			; 000000fcH

; 715  :             macro->sym.variable = TRUE;

	or	BYTE PTR [rbx+40], 64			; 00000040H
$LN9@MacroDir:

; 716  :         }
; 717  :         store_data = TRUE;

	mov	dil, 1
$LN7@MacroDir:

; 720  : 
; 721  :     if ( ModuleInfo.list )

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN10@MacroDir

; 722  :         LstWriteSrcLine();

	call	LstWriteSrcLine
$LN10@MacroDir:

; 723  : 
; 724  :     return( StoreMacro( macro, ++i, tokenarray, store_data ) );

	lea	edx, DWORD PTR [rbp+1]
	movzx	r9d, dil
	mov	r8, rsi
	mov	rcx, rbx
	call	StoreMacro
$LN1@MacroDir:

; 725  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
MacroDir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
;	COMDAT store_placeholders
_TEXT	SEGMENT
line$ = 80
mnames$ = 88
store_placeholders PROC					; COMDAT

; 178  : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	mov	QWORD PTR [rsp+16], rdx
	push	rsi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 179  :     /* scan a macro source line for parameter and local names.
; 180  :      * - line: the source line
; 181  :      * - mnames: list of macro params + locals
; 182  :      * if a param/local is found, replace the name by a 2-byte placeholder.
; 183  :      */
; 184  :     char *p;
; 185  :     char *start;
; 186  :     char quote = NULLC;
; 187  :     int brlevel = 0;

	xor	eax, eax
	xor	sil, sil
	mov	r14, rcx
	mov	ebp, eax

; 188  :     int params = 0; /* number of replacements in this line */

	mov	r15d, eax

; 189  :     int qlevel = 0;

	mov	r12d, eax

; 190  :     bool substprf;  /* substitution character before ID? */
; 191  : 
; 192  :     for( p = line; *p != NULLC; ) {

	mov	rbx, rcx
	cmp	BYTE PTR [rcx], al
	je	$LN56@store_plac
	mov	QWORD PTR [rsp+80], rdi
	mov	rdi, 576460752706076673			; 0800000018000001H
$LL2@store_plac:

; 193  :         if ( isdigit( *p) ) {

	movsx	ecx, BYTE PTR [rbx]
	call	isdigit
	test	eax, eax
	je	SHORT $LN11@store_plac
$LL5@store_plac:

; 194  :             /* skip numbers (they may contain alphas)
; 195  :              * this is not exactly what masm does. Masm
; 196  :              * stops at the first non-digit.
; 197  :              */
; 198  :             while ( is_valid_id_char( *p )) p++;

	movsx	ecx, BYTE PTR [rbx]
	call	isalnum
	test	eax, eax
	jne	SHORT $LN13@store_plac
	movzx	eax, BYTE PTR [rbx]
	sub	al, 36					; 00000024H
	cmp	al, 59					; 0000003bH
	ja	$LN21@store_plac
	movsx	rax, al
	bt	rdi, rax
	jae	$LN21@store_plac
$LN13@store_plac:
	inc	rbx
	jmp	SHORT $LL5@store_plac
$LN11@store_plac:

; 199  :         } else if ( ( is_valid_id_char( *p ) ) ||

	movsx	ecx, BYTE PTR [rbx]
	call	isalnum
	test	eax, eax
	jne	$LN17@store_plac
	movzx	ecx, BYTE PTR [rbx]
	lea	eax, DWORD PTR [rcx-36]
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN49@store_plac
	movsx	rax, al
	bt	rdi, rax
	jb	$LN17@store_plac
$LN49@store_plac:
	cmp	cl, 46					; 0000002eH
	jne	SHORT $LN33@store_plac
	test	BYTE PTR ModuleInfo+408, 16
	je	SHORT $LN33@store_plac
	cmp	rbx, r14
	je	$LN17@store_plac
	movzx	eax, BYTE PTR [rbx-1]
	cmp	al, 93					; 0000005dH
	je	SHORT $LN33@store_plac
	movsx	ecx, al
	call	isalnum
	test	eax, eax
	jne	SHORT $LN33@store_plac
	movzx	eax, BYTE PTR [rbx-1]
	sub	al, 36					; 00000024H
	cmp	al, 59					; 0000003bH
	ja	$LN17@store_plac
	movsx	rax, al
	bt	rdi, rax
	jae	$LN17@store_plac
$LN33@store_plac:

; 215  :                 }
; 216  :             }
; 217  :         } else {
; 218  :             switch (*p) {

	movsx	edx, BYTE PTR [rbx]
	mov	ecx, edx
	sub	ecx, 33					; 00000021H
	je	SHORT $LN22@store_plac
	sub	ecx, 1
	je	SHORT $LN28@store_plac
	sub	ecx, 5
	je	SHORT $LN28@store_plac
	sub	ecx, 21
	je	SHORT $LN24@store_plac
	cmp	ecx, 2
	jne	SHORT $LN23@store_plac

; 227  :                 break;
; 228  :             case '>':
; 229  :                 if (brlevel) {

	test	ebp, ebp
	je	SHORT $LN23@store_plac

; 230  :                     if (qlevel == brlevel)

	cmp	r12d, ebp
	movzx	esi, sil
	mov	eax, 0
	cmove	esi, eax

; 231  :                         quote = NULLC;
; 232  :                     brlevel--;

	dec	ebp

; 243  :                 }
; 244  :             }
; 245  :             p++;

	inc	rbx
	jmp	$LN21@store_plac
$LN24@store_plac:

; 223  :                     p++;
; 224  :                 break;
; 225  :             case '<':
; 226  :                 brlevel++;

	inc	ebp

; 243  :                 }
; 244  :             }
; 245  :             p++;

	inc	rbx
	jmp	$LN21@store_plac
$LN28@store_plac:

; 233  :                 }
; 234  :                 break;
; 235  :             case '"':
; 236  :             case '\'':
; 237  :                 if ( quote ) {

	test	sil, sil
	je	SHORT $LN29@store_plac

; 238  :                     if ( quote == *p )

	cmp	sil, dl
	jne	SHORT $LN23@store_plac

; 239  :                         quote = NULLC;

	xor	sil, sil

; 243  :                 }
; 244  :             }
; 245  :             p++;

	inc	rbx
	jmp	$LN21@store_plac
$LN29@store_plac:

; 240  :                 } else {
; 241  :                     quote = *p;

	movzx	esi, dl

; 242  :                     qlevel = brlevel;

	mov	r12d, ebp

; 243  :                 }
; 244  :             }
; 245  :             p++;

	inc	rbx
	jmp	$LN21@store_plac
$LN22@store_plac:

; 219  :             case '!':
; 220  :                 /* v2.11: skip next char only if it is a "special" one; see expans40.asm */
; 221  :                 //if ( quote == NULLC && *(p+1) != NULLC )
; 222  :                 if ( quote == NULLC && strchr( "<>\"'", *(p+1) ) )

	test	sil, sil
	jne	SHORT $LN23@store_plac
	movsx	edx, BYTE PTR [rbx+1]
	lea	rdi, QWORD PTR [rbx+1]
	lea	rcx, OFFSET FLAT:$SG10915
	call	strchr
	test	rax, rax
	cmovne	rbx, rdi
$LN23@store_plac:

; 243  :                 }
; 244  :             }
; 245  :             p++;

	inc	rbx
	jmp	SHORT $LN21@store_plac
$LN17@store_plac:

; 200  :                    ( *p == '.' &&
; 201  :                     ModuleInfo.dotname &&
; 202  :                     //is_valid_id_char(*(p+1)) && /* v2.05: masm allows a single dot as param/local name */
; 203  :                     ( p == line ||
; 204  :                      ( *(p-1) != ']' && ( is_valid_id_char( *(p-1) ) == FALSE ) ) ) ) ) {
; 205  :             DebugMsg1(("store_placeholders: found ID: %s\n", p));
; 206  :             start = p++;

	mov	rdi, rbx
	mov	r13, 576460752706076673			; 0800000018000001H
$LN18@store_plac:

; 207  :             while ( is_valid_id_char( *p )) p++;

	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isalnum
	test	eax, eax
	jne	SHORT $LN18@store_plac
	movzx	eax, BYTE PTR [rbx]
	sub	al, 36					; 00000024H
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN8@store_plac
	movsx	rax, al
	bt	r13, rax
	jb	SHORT $LN18@store_plac
$LN8@store_plac:

; 208  :             /* v2.08: both a '&' before AND after the name trigger substitution (and disappear) */
; 209  :             substprf = ( ( start > line && *(start-1) == '&') || *p == '&' );

	mov	r13, QWORD PTR mnames$[rsp]
	cmp	rdi, r14
	jbe	SHORT $LN35@store_plac
	cmp	BYTE PTR [rdi-1], 38			; 00000026H
	je	SHORT $LN36@store_plac
$LN35@store_plac:
	cmp	BYTE PTR [rbx], 38			; 00000026H
	je	SHORT $LN36@store_plac
	xor	al, al
	jmp	SHORT $LN37@store_plac
$LN36@store_plac:
	mov	al, 1
$LN37@store_plac:

; 210  :             if ( quote == NULLC || substprf ) {

	test	sil, sil
	je	SHORT $LN20@store_plac
	test	al, al
	je	SHORT $LN21@store_plac
$LN20@store_plac:

; 211  :                 /* look for this word in the macro parms, and replace it if it is */
; 212  :                 if ( start = replace_parm( line, start, p - start, mnames ) ) {

	mov	r8d, ebx
	mov	r9, r13
	sub	r8d, edi
	mov	rdx, rdi
	mov	rcx, r14
	call	replace_parm
	test	rax, rax
	je	SHORT $LN21@store_plac

; 213  :                     params++;

	inc	r15d

; 214  :                     p = start;

	mov	rbx, rax
$LN21@store_plac:

; 190  :     bool substprf;  /* substitution character before ID? */
; 191  : 
; 192  :     for( p = line; *p != NULLC; ) {

	cmp	BYTE PTR [rbx], 0
	mov	rdi, 576460752706076673			; 0800000018000001H
	jne	$LL2@store_plac

; 246  :         }
; 247  :     }
; 248  :     return( params );

	mov	rdi, QWORD PTR [rsp+80]
	mov	eax, r15d
$LN56@store_plac:

; 249  : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rsi
	ret	0
store_placeholders ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
;	COMDAT replace_parm
_TEXT	SEGMENT
line$ = 48
start$ = 56
len$ = 64
mnames$ = 72
replace_parm PROC					; COMDAT

; 120  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	movsxd	rbp, r8d

; 121  :     /* scan list of macro paras/locals if current word is found.
; 122  :      * - line: current line
; 123  :      * - start: start 'current word' in line
; 124  :      * - len: size current word
; 125  :      * - mnames: list of macro params+locals
; 126  :      * if found, the 'current word' is replaced by a placeholder.
; 127  :      * format of placeholders is <placeholder_char><index>
; 128  :      * <placeholder_char> is an escape character whose hex-code is
; 129  :      * "impossible" to occur in a source line, <index> has type uint_8,
; 130  :      * value 00 isn't used - this restricts the total of parameters
; 131  :      * and locals for a macro to 255.
; 132  :      */
; 133  :     char       *rest;
; 134  :     unsigned   count;
; 135  : 
; 136  : //  DebugMsg(("replace_parm(%s) enter, len=%u\n", start, len ));
; 137  : 
; 138  :     for( count = 1; mnames->label; count++, mnames++ ) {

	mov	rdx, QWORD PTR [r9]
	mov	rdi, r9
	mov	r14, rcx
	mov	esi, 1
	test	rdx, rdx
	je	SHORT $LN23@replace_pa
$LL4@replace_pa:

; 139  :         if( mnames->len == len && SymCmpFunc( start, mnames->label, len ) == 0 ) {

	movzx	eax, WORD PTR [rdi+8]
	cmp	eax, ebp
	jne	SHORT $LN2@replace_pa
	mov	r8, rbp
	mov	rcx, rbx
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN16@replace_pa
$LN2@replace_pa:

; 121  :     /* scan list of macro paras/locals if current word is found.
; 122  :      * - line: current line
; 123  :      * - start: start 'current word' in line
; 124  :      * - len: size current word
; 125  :      * - mnames: list of macro params+locals
; 126  :      * if found, the 'current word' is replaced by a placeholder.
; 127  :      * format of placeholders is <placeholder_char><index>
; 128  :      * <placeholder_char> is an escape character whose hex-code is
; 129  :      * "impossible" to occur in a source line, <index> has type uint_8,
; 130  :      * value 00 isn't used - this restricts the total of parameters
; 131  :      * and locals for a macro to 255.
; 132  :      */
; 133  :     char       *rest;
; 134  :     unsigned   count;
; 135  : 
; 136  : //  DebugMsg(("replace_parm(%s) enter, len=%u\n", start, len ));
; 137  : 
; 138  :     for( count = 1; mnames->label; count++, mnames++ ) {

	mov	rdx, QWORD PTR [rdi+16]
	add	rdi, 16
	inc	esi
	test	rdx, rdx
	jne	SHORT $LL4@replace_pa
$LN23@replace_pa:

; 171  :         }
; 172  :     }
; 173  :     return( NULL );

	xor	eax, eax
$LN1@replace_pa:

; 174  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN16@replace_pa:

; 140  : 
; 141  :             /* found a macro parameter/local! */
; 142  : 
; 143  :             if ( count >= MAX_PLACEHOLDERS ) {

	cmp	esi, 256				; 00000100H
	jb	SHORT $LN8@replace_pa

; 144  :                 EmitError( TOO_MANY_MACRO_PLACEHOLDERS );

	mov	ecx, 220				; 000000dcH
	call	EmitError

; 145  :                 break;

	jmp	SHORT $LN23@replace_pa
$LN8@replace_pa:

; 146  :             }
; 147  : 
; 148  :             /* handle substitution operator '&' */
; 149  :             rest = start + len;

	lea	rdx, QWORD PTR [rbx+rbp]

; 150  :             if ( start != line && *(start-1) == '&' )

	cmp	rbx, r14
	je	SHORT $LN9@replace_pa
	cmp	BYTE PTR [rbx-1], 38			; 00000026H
	lea	rax, QWORD PTR [rbx-1]
	cmove	rbx, rax
$LN9@replace_pa:

; 151  :                 start--;
; 152  :             if (*rest == '&')

	cmp	BYTE PTR [rdx], 38			; 00000026H
	jne	SHORT $LN10@replace_pa

; 153  :                 rest++;

	inc	rdx
$LN10@replace_pa:

; 154  : 
; 155  :             *start++ = PLACEHOLDER_CHAR;

	mov	BYTE PTR [rbx], 10
	inc	rbx

; 156  : 
; 157  :             /* additional space needed for the placeholder? */
; 158  :             if ( start >= rest ) {

	cmp	rbx, rdx
	jb	SHORT $LN11@replace_pa

; 159  :                 char *end = rest + strlen(rest);

	or	r8, -1
	npad	9
$LL25@replace_pa:
	inc	r8
	cmp	BYTE PTR [rdx+r8], 0
	jne	SHORT $LL25@replace_pa
	add	r8, rdx

; 160  :                 char *dst = end + 1;

	lea	rcx, QWORD PTR [r8+1]

; 161  :                 while ( end >= rest )

	cmp	r8, rdx
	jb	SHORT $LN6@replace_pa
	npad	10
$LL5@replace_pa:

; 162  :                     *dst-- = *end--;

	movzx	eax, BYTE PTR [r8]
	dec	r8
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR [rcx-1]
	cmp	r8, rdx
	jae	SHORT $LL5@replace_pa
$LN6@replace_pa:

; 163  :                 *start = count;

	mov	BYTE PTR [rbx], sil

; 169  :             }
; 170  :             return( start ); /* word has been replaced */

	mov	rax, rbx
	jmp	$LN1@replace_pa
$LN11@replace_pa:

; 164  :             } else {
; 165  :                 *start++ = count;

	mov	BYTE PTR [rbx], sil
	inc	rbx

; 166  :                 /* v2.10: strcpy should not be used if strings overlap */
; 167  :                 //strcpy( start, rest );
; 168  :                 memmove( start, rest, strlen( rest) + 1 );

	or	r8, -1
	npad	9
$LL24@replace_pa:
	inc	r8
	cmp	BYTE PTR [rdx+r8], 0
	jne	SHORT $LL24@replace_pa
	inc	r8
	mov	rcx, rbx
	call	memmove

; 169  :             }
; 170  :             return( start ); /* word has been replaced */

	mov	rax, rbx
	jmp	$LN1@replace_pa
replace_parm ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
;	COMDAT HexDigit
_TEXT	SEGMENT
x$ = 8
HexDigit PROC						; COMDAT

; 69   :     x &= 0xF;

	and	cl, 15

; 70   :     return((x > 9) ? (x - 10 + 'A') : (x + '0'));

	movsx	eax, cl
	cmp	cl, 9
	jle	SHORT $LN3@HexDigit
	add	eax, 55					; 00000037H

; 71   : }

	ret	0
$LN3@HexDigit:

; 70   :     return((x > 9) ? (x - 10 + 'A') : (x + '0'));

	add	eax, 48					; 00000030H

; 71   : }

	ret	0
HexDigit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
pass$ = 48
MacroInit PROC

; 802  : {

$LN9:
	push	rdi
	sub	rsp, 32					; 00000020H

; 803  :     struct dsym *macro;
; 804  : 
; 805  :     DebugMsg(( "MacroInit(%u)\n", pass ));
; 806  : 
; 807  :     MacroLevel = 0;
; 808  :     MacroLocals = 0;

	xor	edi, edi
	mov	BYTE PTR MacroLevel, 0
	mov	DWORD PTR MacroLocals, edi

; 809  :     if (pass == PASS_1) {

	test	ecx, ecx
	jne	$LN7@MacroInit

; 810  : 
; 811  :         StringInit();

	mov	QWORD PTR [rsp+48], rbx
	call	StringInit

; 812  : 
; 813  :         /* add @Environ() macro func */
; 814  : 
; 815  :         macro = CreateMacro( "@Environ" );

	lea	rcx, OFFSET FLAT:$SG11151
	call	SymCreate
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN5@MacroInit
	lea	ecx, QWORD PTR [rdi+32]
	mov	DWORD PTR [rax+32], 9
	call	LclAlloc
	mov	QWORD PTR [rbx+96], rax
	mov	WORD PTR [rax], di
	mov	rcx, QWORD PTR [rbx+96]
	mov	WORD PTR [rcx+2], di
	mov	rax, QWORD PTR [rbx+96]
	mov	QWORD PTR [rax+8], rdi
	mov	rax, QWORD PTR [rbx+96]
	mov	QWORD PTR [rax+16], rdi
	mov	rax, QWORD PTR [rbx+96]
	mov	DWORD PTR [rax+24], edi
	and	BYTE PTR [rbx+44], 252			; 000000fcH
$LN5@MacroInit:

; 816  :         macro->sym.isdefined = TRUE;
; 817  :         macro->sym.predefined = TRUE;

	or	BYTE PTR [rbx+40], 34			; 00000022H

; 818  :         macro->sym.func_ptr = EnvironFunc;

	lea	rax, OFFSET FLAT:EnvironFunc

; 819  :         macro->sym.isfunc = TRUE;

	or	BYTE PTR [rbx+44], 2

; 820  :         macro->e.macroinfo->parmcnt = 1;

	mov	ecx, 1
	mov	QWORD PTR [rbx+16], rax
	mov	rax, QWORD PTR [rbx+96]
	mov	WORD PTR [rax], cx

; 821  :         macro->e.macroinfo->parmlist = LclAlloc(sizeof(struct mparm_list));

	mov	ecx, 16
	call	LclAlloc
	mov	rcx, QWORD PTR [rbx+96]
	mov	QWORD PTR [rcx+8], rax

; 822  :         macro->e.macroinfo->parmlist->deflt = NULL;

	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rdi

; 823  :         macro->e.macroinfo->parmlist->required = TRUE;

	mov	rax, QWORD PTR [rbx+96]
	mov	rbx, QWORD PTR [rsp+48]
	mov	rcx, QWORD PTR [rax+8]
	or	BYTE PTR [rcx+8], 1
$LN7@MacroInit:

; 824  :     }
; 825  :     return( NOT_ERROR );

	xor	eax, eax

; 826  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
MacroInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
nesting_depth$1$ = 0
$T1 = 8
info$1$ = 8
ls$ = 16
tok$ = 48
buffer$ = 112
mnames$ = 720
locals_done$1$ = 4880
mindex$1$ = 4880
macro$ = 4880
i$ = 4888
tokenarray$ = 4896
mindex$ = 4904
store_data$ = 4904
StoreMacro PROC

; 287  : {

$LN213:
	mov	BYTE PTR [rsp+32], r9b
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	mov	eax, 4848				; 000012f0H
	call	__chkstk
	sub	rsp, rax
	lea	rbp, QWORD PTR [rsp+32]

; 288  :     struct macro_info   *info;
; 289  :     char                *src;
; 290  :     char                *token;
; 291  :     int                 mindex;
; 292  :     struct mparm_list   *paranode;
; 293  :     struct srcline      **nextline;
; 294  : #ifdef DEBUG_OUT
; 295  :     int lineno = 0;
; 296  : #endif
; 297  :     unsigned            nesting_depth = 0;
; 298  :     bool                locals_done;
; 299  :     struct line_status  ls;
; 300  :     struct asm_tok      tok[2];
; 301  :     struct mname_list   mnames[MAX_PLACEHOLDERS]; /* there are max 255 placeholders */
; 302  :     char                buffer[MAX_LINE_LEN];
; 303  : 
; 304  :     DebugMsg1(("StoreMacro(%s, i=%u, store_data=%u) enter, params=>%s<\n", macro->sym.name, i, store_data, tokenarray[i].tokpos ));
; 305  :     info = macro->e.macroinfo;

	mov	r12, QWORD PTR [rcx+96]
	mov	r14, r8
	mov	QWORD PTR [rbp+4888], rbx
	mov	r13, rcx
	mov	ebx, edx
	mov	QWORD PTR info$1$[rbp], r12
	xor	edx, edx
	mov	DWORD PTR nesting_depth$1$[rbp], edx

; 306  : 
; 307  :     if( store_data ) {

	test	r9b, r9b
	je	$LN196@StoreMacro

; 308  :         int j;
; 309  : 
; 310  :         if ( i < Token_Count ) {

	cmp	ebx, DWORD PTR ModuleInfo+496
	jge	SHORT $LN32@StoreMacro

; 311  :             for ( j = i, info->parmcnt = 1; j < Token_Count; j++ )

	mov	eax, 1
	mov	ecx, ebx
	mov	WORD PTR [r12], ax
	mov	edx, DWORD PTR ModuleInfo+496
	cmp	ebx, edx
	jge	SHORT $LN3@StoreMacro
	npad	11
$LL4@StoreMacro:

; 312  :                 if ( tokenarray[j].token == T_COMMA )

	movsxd	rax, ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+r8], 44			; 0000002cH
	jne	SHORT $LN2@StoreMacro

; 313  :                     info->parmcnt++;

	inc	WORD PTR [r12]
	mov	edx, DWORD PTR ModuleInfo+496
$LN2@StoreMacro:

; 311  :             for ( j = i, info->parmcnt = 1; j < Token_Count; j++ )

	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LL4@StoreMacro
$LN3@StoreMacro:

; 314  :             info->parmlist = LclAlloc( info->parmcnt * sizeof(struct mparm_list));

	movzx	ecx, WORD PTR [r12]
	shl	rcx, 4
	call	LclAlloc
	mov	QWORD PTR [r12+8], rax

; 315  :         } else {

	xor	edx, edx
	jmp	SHORT $LN33@StoreMacro
$LN32@StoreMacro:

; 316  :             info->parmcnt = 0;

	mov	WORD PTR [r12], dx

; 317  :             info->parmlist = NULL;

	mov	QWORD PTR [r12+8], rdx
$LN33@StoreMacro:

; 318  :         }
; 319  : 
; 320  :         for( paranode = info->parmlist, mindex = 0; i < Token_Count ; paranode++ ) {

	cmp	ebx, DWORD PTR ModuleInfo+496
	mov	r15d, edx
	mov	rsi, QWORD PTR [r12+8]
	mov	DWORD PTR mindex$1$[rbp], edx
	jge	$LN6@StoreMacro
	lea	r12, QWORD PTR mnames$[rbp]
$LL7@StoreMacro:

; 321  : 
; 322  :             token = tokenarray[i].string_ptr;

	movsxd	r15, ebx
	shl	r15, 5
	mov	rdi, QWORD PTR [r15+r14+8]

; 323  :             /* Masm accepts reserved words and instructions as parameter
; 324  :              * names! So just check that the token is a valid id.
; 325  :              */
; 326  :             if ( !is_valid_id_first_char( *token ) || tokenarray[i].token == T_STRING ) {

	movsx	ecx, BYTE PTR [rdi]
	call	isalpha
	test	eax, eax
	jne	SHORT $LN38@StoreMacro
	movzx	ecx, BYTE PTR [rdi]
	lea	eax, DWORD PTR [rcx-36]
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN172@StoreMacro
	movsx	rax, al
	mov	rdx, 576460752706076673			; 0800000018000001H
	bt	rdx, rax
	jb	SHORT $LN38@StoreMacro
$LN172@StoreMacro:
	cmp	cl, 46					; 0000002eH
	jne	$LN37@StoreMacro
	test	BYTE PTR ModuleInfo+408, 16
	je	$LN37@StoreMacro
$LN38@StoreMacro:
	movzx	eax, BYTE PTR [r15+r14]
	cmp	al, 9
	je	$LN37@StoreMacro

; 328  :                 break;
; 329  :             } else if ( tokenarray[i].token != T_ID )

	cmp	al, 8
	je	SHORT $LN39@StoreMacro

; 330  :                 EmitWarn( 4, PARAM_IS_RESERVED_WORD, tokenarray[i].string_ptr );

	mov	r8, QWORD PTR [r15+r14+8]
	mov	edx, 270				; 0000010eH
	mov	ecx, 4
	call	EmitWarn
$LN39@StoreMacro:

; 331  : 
; 332  :             paranode->deflt = NULL;
; 333  :             paranode->required = FALSE;

	and	BYTE PTR [rsi+8], 254			; 000000feH
	xor	edx, edx
	mov	QWORD PTR [rsi], rdx

; 334  : 
; 335  :             /* first get the parm. name */
; 336  :             j = strlen( token );

	or	rax, -1

; 337  :             mnames[mindex].label = token;

	mov	QWORD PTR [r12], rdi
$LL188@StoreMacro:

; 334  : 
; 335  :             /* first get the parm. name */
; 336  :             j = strlen( token );

	inc	rax
	cmp	BYTE PTR [rdi+rax], dl
	jne	SHORT $LL188@StoreMacro

; 338  :             mnames[mindex].len = j;
; 339  :             mindex++;

	mov	r15d, DWORD PTR mindex$1$[rbp]

; 340  :             mnames[mindex].label = NULL; /* init next entry */
; 341  :             i++;

	inc	ebx
	mov	WORD PTR [r12+8], ax
	inc	r15d
	add	r12, 16

; 342  : 
; 343  :             /* now see if it has a default value or is required */
; 344  :             if( tokenarray[i].token == T_COLON ) {

	movsxd	rax, ebx
	shl	rax, 5
	mov	DWORD PTR mindex$1$[rbp], r15d
	mov	QWORD PTR [r12], rdx
	cmp	BYTE PTR [rax+r14], 58			; 0000003aH
	jne	$LN54@StoreMacro

; 345  :                 i++;

	inc	ebx

; 346  :                 if( tokenarray[i].token == T_DIRECTIVE && tokenarray[i].dirtype == DRT_EQUALSGN ) {

	movsxd	r15, ebx
	mov	rdi, r15
	shl	rdi, 5
	add	rdi, r14
	cmp	BYTE PTR [rdi], 3
	jne	SHORT $LN41@StoreMacro
	cmp	BYTE PTR [rdi+1], 48			; 00000030H
	jne	SHORT $LN41@StoreMacro

; 347  :                     i++;

	inc	ebx

; 348  :                     /* allowed syntax is parm:=<literal> */
; 349  :                     if( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rdi, ebx
	shl	rdi, 5
	add	rdi, r14
	cmp	BYTE PTR [rdi], 9
	jne	$LN119@StoreMacro
	cmp	BYTE PTR [rdi+1], 60			; 0000003cH
	jne	$LN119@StoreMacro

; 352  :                     }
; 353  :                     paranode->deflt = LclAlloc( tokenarray[i].stringlen + 1 );

	mov	ecx, DWORD PTR [rdi+16]
	inc	ecx
	call	LclAlloc
	mov	QWORD PTR [rsi], rax

; 354  :                     memcpy( paranode->deflt, tokenarray[i].string_ptr, tokenarray[i].stringlen + 1 );

	mov	rcx, rax
	mov	r8d, DWORD PTR [rdi+16]
	mov	rdx, QWORD PTR [rdi+8]
	inc	r8d
	call	memcpy

; 355  :                     i++;

	jmp	$LN207@StoreMacro
$LN41@StoreMacro:

; 356  :                 } else if( _stricmp( tokenarray[i].string_ptr, "REQ" ) == 0 ) {

	mov	rcx, QWORD PTR [rdi+8]
	lea	rdx, OFFSET FLAT:$SG11007
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN45@StoreMacro

; 357  :                     /* required parameter */
; 358  :                     paranode->required = TRUE;

	or	BYTE PTR [rsi+8], 1

; 359  :                     i++;

	jmp	SHORT $LN207@StoreMacro
$LN45@StoreMacro:
	movzx	eax, BYTE PTR [rdi]

; 360  :                 } else if( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_VARARG ) {

	cmp	al, 7
	jne	SHORT $LN47@StoreMacro
	cmp	DWORD PTR [rdi+16], 262			; 00000106H
	jne	SHORT $LN50@StoreMacro

; 361  :                     /* more parameters can follow */
; 362  :                     macro->sym.mac_vararg = TRUE;

	or	BYTE PTR [r13+44], 1

; 366  :                     }
; 367  :                     i++;
; 368  : #if MACROLABEL
; 369  :                 } else if( tokenarray[i].token == T_DIRECTIVE &&

	jmp	SHORT $LN211@StoreMacro
$LN47@StoreMacro:

; 370  :                           tokenarray[i].tokval == T_LABEL &&

	cmp	al, 3
	jne	SHORT $LN50@StoreMacro
	cmp	DWORD PTR [rdi+16], 431			; 000001afH
	jne	SHORT $LN50@StoreMacro
	cmp	BYTE PTR Options+127, 0
	jne	SHORT $LN50@StoreMacro

; 371  :                           Options.strict_masm_compat == FALSE ) { /* parm:LABEL? */
; 372  :                     /* LABEL attribute for first param only! */
; 373  :                     if ( paranode != info->parmlist ) {

	mov	rax, QWORD PTR info$1$[rbp]
	cmp	rsi, QWORD PTR [rax+8]
	jne	$LN121@StoreMacro

; 376  :                     }
; 377  :                     macro->sym.label = TRUE;

	or	BYTE PTR [r13+44], 4

; 378  :                     i++;

	jmp	SHORT $LN207@StoreMacro
$LN50@StoreMacro:

; 379  : #endif
; 380  : #if VARARGML
; 381  :                 } else if( _stricmp( tokenarray[i].string_ptr, "VARARGML" ) == 0 ) {

	mov	rcx, QWORD PTR [rdi+8]
	lea	rdx, OFFSET FLAT:$SG11016
	call	_stricmp
	test	eax, eax
	jne	$LN53@StoreMacro

; 382  :                     /* more parameters can follow, multi lines possible */
; 383  :                     macro->sym.mac_vararg = TRUE;
; 384  :                     macro->sym.mac_multiline = TRUE;

	or	BYTE PTR [r13+44], 9
$LN211@StoreMacro:

; 385  :                     if ( tokenarray[i+1].token != T_FINAL ) {

	lea	rax, QWORD PTR [r15+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+r14], 0
	jne	SHORT $LN120@StoreMacro
$LN207@StoreMacro:
	mov	r15d, DWORD PTR mindex$1$[rbp]

; 386  :                         EmitError( VARARG_PARAMETER_MUST_BE_LAST );
; 387  :                         break;
; 388  :                     }
; 389  :                     i++;

	inc	ebx
$LN54@StoreMacro:

; 394  :                 }
; 395  :             }
; 396  :             DebugMsg1(("StoreMacro(%s): param=>%s< found\n", macro->sym.name, mnames[mindex].label));
; 397  :             if( i < Token_Count && tokenarray[i].token != T_COMMA ) {

	mov	ecx, DWORD PTR ModuleInfo+496
	cmp	ebx, ecx
	jge	SHORT $LN56@StoreMacro
	movsxd	rax, ebx
	shl	rax, 5
	cmp	BYTE PTR [rax+r14], 44			; 0000002cH
	jne	SHORT $LN123@StoreMacro
$LN56@StoreMacro:

; 399  :                 break; // return( ERROR );
; 400  :             }
; 401  :             /* go past comma */
; 402  :             i++;

	inc	ebx
	add	rsi, 16
	cmp	ebx, ecx
	jge	SHORT $LN184@StoreMacro

; 318  :         }
; 319  : 
; 320  :         for( paranode = info->parmlist, mindex = 0; i < Token_Count ; paranode++ ) {

	jmp	$LL7@StoreMacro
$LN119@StoreMacro:

; 350  :                         EmitError( LITERAL_EXPECTED_AFTER_EQ );

	mov	ecx, 186				; 000000baH
	call	EmitError

; 351  :                         break; // return( ERROR );

	mov	r15d, DWORD PTR mindex$1$[rbp]
$LN184@StoreMacro:
	mov	r12, QWORD PTR info$1$[rbp]
	jmp	SHORT $LN6@StoreMacro
$LN120@StoreMacro:

; 363  :                     if ( tokenarray[i+1].token != T_FINAL ) {
; 364  :                         EmitError( VARARG_PARAMETER_MUST_BE_LAST );

	mov	ecx, 148				; 00000094H
	call	EmitError

; 365  :                         break;

	mov	r15d, DWORD PTR mindex$1$[rbp]
	mov	r12, QWORD PTR info$1$[rbp]
	jmp	SHORT $LN6@StoreMacro
$LN121@StoreMacro:

; 374  :                         EmitError( LABEL_PARAMETER_MUST_BE_FIRST );

	mov	ecx, 149				; 00000095H
	call	EmitError

; 375  :                         break;

	mov	r15d, DWORD PTR mindex$1$[rbp]
	mov	r12, QWORD PTR info$1$[rbp]
	jmp	SHORT $LN6@StoreMacro
$LN53@StoreMacro:

; 390  : #endif
; 391  :                 } else {
; 392  :                     EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	movsxd	rdx, ebx
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r14+8]
$LN208@StoreMacro:
	mov	ecx, 210				; 000000d2H
	call	EmitErr

; 393  :                     break;

	mov	r15d, DWORD PTR mindex$1$[rbp]
	mov	r12, QWORD PTR info$1$[rbp]
	jmp	SHORT $LN6@StoreMacro
$LN123@StoreMacro:

; 398  :                 EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );

	movsxd	rdx, ebx
	mov	ecx, 210				; 000000d2H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r14+24]
	call	EmitErr
	mov	r12, QWORD PTR info$1$[rbp]
	jmp	SHORT $LN6@StoreMacro
$LN37@StoreMacro:

; 327  :                 EmitErr( SYNTAX_ERROR_EX, token );

	mov	rdx, rdi
	jmp	SHORT $LN208@StoreMacro
$LN196@StoreMacro:
	mov	r15d, DWORD PTR mindex$[rbp]
$LN6@StoreMacro:

; 403  : 
; 404  :         } /* end for() */
; 405  :         DebugMsg1(("StoreMacro(%s): macro parameters done\n", macro->sym.name));
; 406  :     }
; 407  : 
; 408  :     locals_done = FALSE;

	xor	dil, dil
	movsxd	rax, r15d
	mov	BYTE PTR locals_done$1$[rbp], dil

; 409  :     nextline = &info->data;

	lea	r14, QWORD PTR [r12+16]
	mov	QWORD PTR $T1[rbp], rax
	jmp	SHORT $LN8@StoreMacro
$LN206@StoreMacro:
	movzx	edi, BYTE PTR locals_done$1$[rbp]
$LN8@StoreMacro:

; 410  : 
; 411  :     /* now read in the lines of the macro, and store them if store_data is TRUE */
; 412  :     for( ; ; ) {
; 413  :         char *ptr;
; 414  : 
; 415  :         src = GetTextLine( buffer );

	lea	rcx, QWORD PTR buffer$[rbp]
	call	GetTextLine
	mov	rsi, rax

; 416  :         if( src == NULL ) {

	test	rax, rax
	jne	SHORT $LN57@StoreMacro

; 417  :             /* v2.11: fatal error if source ends without an ENDM found */
; 418  :             //EmitError( UNMATCHED_MACRO_NESTING );
; 419  :             //ModuleInfo.EndDirFound = TRUE; /* avoid error "END not found" */
; 420  :             //return( ERROR );
; 421  :             Fatal( UNMATCHED_MACRO_NESTING );

	mov	ecx, 163				; 000000a3H
	call	Fatal
$LN57@StoreMacro:

; 422  :         }
; 423  : 
; 424  :         /* add the macro line to the listing file */
; 425  :         /* v2.09: don't make listing depend on store_data */
; 426  :         //if ( ModuleInfo.list && store_data ) {
; 427  :         if ( ModuleInfo.list ) {

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN58@StoreMacro

; 428  :             ModuleInfo.line_flags &= ~LOF_LISTED;

	and	BYTE PTR ModuleInfo+398, 254		; 000000feH

; 429  :             LstWrite( LSTTYPE_MACROLINE, 0, buffer );

	lea	r8, QWORD PTR buffer$[rbp]
	xor	edx, edx
	lea	ecx, QWORD PTR [rdx+8]
	call	LstWrite
$LN58@StoreMacro:

; 430  :         }
; 431  :         ls.input = src;

	mov	rbx, rsi

; 432  :         ls.start = src;

	mov	QWORD PTR ls$[rbp+16], rsi
	mov	QWORD PTR ls$[rbp], rbx

; 433  :         ls.index = 0;

	mov	DWORD PTR ls$[rbp+24], 0
$continue_scan$214:

; 434  :     continue_scan:
; 435  :         while ( isspace(*ls.input) ) ls.input++;

	movsx	ecx, BYTE PTR [rbx]
	call	isspace
	test	eax, eax
	je	SHORT $LN12@StoreMacro
	npad	3
$LL11@StoreMacro:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL11@StoreMacro
$LN12@StoreMacro:

; 436  : 
; 437  :         /* skip empty lines! */
; 438  :         if ( *ls.input == NULLC || *ls.input == ';' ) {

	mov	rax, QWORD PTR ls$[rbp]
	movzx	ecx, BYTE PTR [rax]
	test	cl, cl
	je	$LN60@StoreMacro
	cmp	cl, 59					; 0000003bH
	je	$LN60@StoreMacro

; 449  :         }
; 450  : 
; 451  :         /* get first token */
; 452  :         ls.output = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488

; 453  :         //ls.last_token = T_FINAL;
; 454  :         ls.flags = TOK_DEFAULT;
; 455  :         ls.flags2 = 0;
; 456  :         tok[0].token = T_FINAL;
; 457  :         if ( GetToken( &tok[0], &ls ) == ERROR )

	lea	rdx, QWORD PTR ls$[rbp]
	lea	rcx, QWORD PTR tok$[rbp]
	mov	QWORD PTR ls$[rbp+8], rax
	mov	WORD PTR ls$[rbp+28], 0
	mov	BYTE PTR tok$[rbp], 0
	call	GetToken
	cmp	eax, -1
	je	$LN125@StoreMacro

; 459  : 
; 460  :         /* v2.05: GetTextLine() doesn't concat lines anymore.
; 461  :          * So if a backslash is found in the current source line,
; 462  :          * tokenize it to get possible concatenated lines.
; 463  :          */
; 464  :         if ( strchr( ls.input, '\\' ) ) {

	mov	rcx, QWORD PTR ls$[rbp]
	mov	edx, 92					; 0000005cH
	call	strchr

; 465  :             ptr = ls.input;

	mov	rbx, QWORD PTR ls$[rbp]
	test	rax, rax
	je	$LN63@StoreMacro

; 466  :             while ( *ls.input && *ls.input != ';' ) {

	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	SHORT $LN14@StoreMacro
	npad	4
$LL13@StoreMacro:
	cmp	al, 59					; 0000003bH
	je	SHORT $LN14@StoreMacro

; 467  :                 ls.flags3 = 0;
; 468  :                 GetToken( &tok[1], &ls );

	lea	rdx, QWORD PTR ls$[rbp]
	mov	BYTE PTR ls$[rbp+30], 0
	lea	rcx, QWORD PTR tok$[rbp+32]
	call	GetToken

; 469  :                 /* v2.09: don't query store_data */
; 470  :                 //if ( ( ls.flags3 & TF3_ISCONCAT ) && ModuleInfo.list && store_data ) {
; 471  :                 if ( ( ls.flags3 & TF3_ISCONCAT ) && ModuleInfo.list ) {

	test	BYTE PTR ls$[rbp+30], 1
	je	SHORT $LN112@StoreMacro
	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN112@StoreMacro

; 472  :                     ModuleInfo.line_flags &= ~LOF_LISTED;

	and	BYTE PTR ModuleInfo+398, 254		; 000000feH

; 473  :                     LstWrite( LSTTYPE_MACROLINE, 0, ls.input );

	xor	edx, edx
	mov	r8, QWORD PTR ls$[rbp]
	lea	ecx, QWORD PTR [rdx+8]
	call	LstWrite
$LN112@StoreMacro:

; 474  :                 }
; 475  :                 while( isspace( *ls.input ) ) ls.input++;

	mov	rax, QWORD PTR ls$[rbp]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	je	SHORT $LN16@StoreMacro
	npad	4
$LL15@StoreMacro:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL15@StoreMacro
$LN16@StoreMacro:

; 466  :             while ( *ls.input && *ls.input != ';' ) {

	mov	rax, QWORD PTR ls$[rbp]
	movzx	eax, BYTE PTR [rax]
	test	al, al
	jne	SHORT $LL13@StoreMacro
$LN14@StoreMacro:

; 476  :             }
; 477  :             ls.input = ptr;

	mov	QWORD PTR ls$[rbp], rbx
$LN63@StoreMacro:

; 478  :         }
; 479  :         if ( tok[0].token == T_FINAL ) {/* did GetToken() return EMPTY? */

	movzx	eax, BYTE PTR tok$[rbp]
	test	al, al
	je	$continue_scan$214

; 480  :             DebugMsg1(("StoreMacro(%s): no token\n", macro->sym.name));
; 481  :             goto continue_scan;
; 482  :         }
; 483  :         /* handle LOCAL directive(s) */
; 484  :         if( locals_done == FALSE && tok[0].token == T_DIRECTIVE && tok[0].tokval == T_LOCAL ) {

	mov	ecx, DWORD PTR tok$[rbp+16]
	test	dil, dil
	jne	$LN66@StoreMacro
	cmp	al, 3
	jne	$LN66@StoreMacro
	cmp	ecx, 430				; 000001aeH
	jne	$LN66@StoreMacro

; 485  :             if( !store_data )

	cmp	BYTE PTR store_data$[rbp], dil
	je	$LN8@StoreMacro
	mov	rsi, QWORD PTR $T1[rbp]
	lea	rdi, QWORD PTR mnames$[rbp]
	mov	rax, rsi
	shl	rax, 4
	add	rdi, rax
$LL17@StoreMacro:

; 486  :                 continue;
; 487  :             for ( ;; ) {
; 488  :                 int size;
; 489  :                 while( isspace( *ls.input ) ) ls.input++;

	movsx	ecx, BYTE PTR [rbx]
	call	isspace
	test	eax, eax
	je	SHORT $LN21@StoreMacro
$LL20@StoreMacro:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL20@StoreMacro
$LN21@StoreMacro:

; 490  :                 if ( *ls.input == NULLC || *ls.input == ';' ) /* 0 locals are ok */

	mov	rax, QWORD PTR ls$[rbp]
	movzx	ecx, BYTE PTR [rax]
	test	cl, cl
	je	$LN206@StoreMacro
	cmp	cl, 59					; 0000003bH
	je	$LN206@StoreMacro

; 491  :                     break;
; 492  :                 ls.output = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488

; 493  :                 GetToken( &tok[0], &ls );

	lea	rdx, QWORD PTR ls$[rbp]
	lea	rcx, QWORD PTR tok$[rbp]
	mov	QWORD PTR ls$[rbp+8], rax
	call	GetToken

; 494  :                 if ( !is_valid_id_first_char( *StringBufferEnd ) ) {

	mov	rax, QWORD PTR ModuleInfo+488
	movsx	ecx, BYTE PTR [rax]
	call	isalpha
	mov	rdx, QWORD PTR ModuleInfo+488
	test	eax, eax
	jne	SHORT $LN70@StoreMacro
	movzx	ecx, BYTE PTR [rdx]
	lea	eax, DWORD PTR [rcx-36]
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN174@StoreMacro
	mov	r8, 576460752706076673			; 0800000018000001H
	bt	r8, rax
	jb	SHORT $LN70@StoreMacro
$LN174@StoreMacro:
	cmp	cl, 46					; 0000002eH
	jne	$LN72@StoreMacro
	test	BYTE PTR ModuleInfo+408, 16
	je	$LN72@StoreMacro
$LN70@StoreMacro:

; 495  :                     EmitErr( SYNTAX_ERROR_EX, StringBufferEnd );
; 496  :                     break;
; 497  :                 } else if ( tok[0].token != T_ID )

	cmp	BYTE PTR tok$[rbp], 8
	je	SHORT $LN73@StoreMacro

; 498  :                     EmitWarn( 4, PARAM_IS_RESERVED_WORD, StringBufferEnd );

	mov	r8, rdx
	mov	ecx, 4
	mov	edx, 270				; 0000010eH
	call	EmitWarn
	mov	rdx, QWORD PTR ModuleInfo+488
$LN73@StoreMacro:

; 499  : 
; 500  :                 if ( mindex == ( MAX_PLACEHOLDERS - 1 ) ) {

	cmp	r15d, 255				; 000000ffH
	je	$LN127@StoreMacro

; 503  :                 }
; 504  :                 size = strlen( StringBufferEnd );

	or	rbx, -1
$LL187@StoreMacro:
	inc	rbx
	cmp	BYTE PTR [rdx+rbx], 0
	jne	SHORT $LL187@StoreMacro

; 505  :                 mnames[mindex].label = myalloca( size );

	movsxd	r8, ebx
	lea	rax, QWORD PTR [r8+15]
	cmp	rax, r8
	ja	SHORT $LN186@StoreMacro
	mov	rax, 1152921504606846960		; 0ffffffffffffff0H
$LN186@StoreMacro:
	and	rax, -16
	call	__chkstk
	sub	rsp, rax
	lea	rcx, QWORD PTR [rsp+32]
	mov	QWORD PTR [rdi], rcx

; 506  :                 memcpy( mnames[mindex].label, StringBufferEnd, size );

	call	memcpy

; 507  :                 mnames[mindex].len = size;
; 508  :                 mindex++;
; 509  :                 mnames[mindex].label = NULL; /* mark end of placeholder array */
; 510  :                 info->localcnt++;

	inc	WORD PTR [r12+2]
	inc	rsi

; 511  :                 DebugMsg1(("StoreMacro(%s, %u): local=>%s< added, rest=%s\n", macro->sym.name, nesting_depth, mnames[mindex].label, ls.input ));
; 512  :                 while( isspace( *ls.input ) ) ls.input++;

	mov	rax, QWORD PTR ls$[rbp]
	inc	r15d
	mov	WORD PTR [rdi+8], bx
	add	rdi, 16
	mov	QWORD PTR $T1[rbp], rsi
	movsx	ecx, BYTE PTR [rax]
	mov	QWORD PTR [rdi], 0
	call	isspace
	test	eax, eax
	je	SHORT $LN23@StoreMacro
	npad	8
$LL22@StoreMacro:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL22@StoreMacro
$LN23@StoreMacro:

; 513  :                 if ( *ls.input == ',' ) {

	mov	rbx, QWORD PTR ls$[rbp]
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 44					; 0000002cH
	jne	SHORT $LN75@StoreMacro

; 514  :                     ls.input++;

	inc	rbx
	mov	QWORD PTR ls$[rbp], rbx
	jmp	$LL17@StoreMacro
$LN75@StoreMacro:

; 515  :                 } else if ( is_valid_id_first_char( *ls.input ) ) {

	movsx	ecx, al
	call	isalpha
	mov	rbx, QWORD PTR ls$[rbp]
	test	eax, eax
	jne	SHORT $LN128@StoreMacro
	movzx	ecx, BYTE PTR [rbx]
	lea	eax, DWORD PTR [rcx-36]
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN176@StoreMacro
	mov	rdx, 576460752706076673			; 0800000018000001H
	bt	rdx, rax
	jb	SHORT $LN128@StoreMacro
$LN176@StoreMacro:
	cmp	cl, 46					; 0000002eH
	jne	$LL17@StoreMacro
	test	BYTE PTR ModuleInfo+408, 16
	je	$LL17@StoreMacro
$LN128@StoreMacro:

; 516  :                     EmitErr( SYNTAX_ERROR_EX, ls.input );

	mov	rdx, rbx
$LN72@StoreMacro:
	mov	ecx, 210				; 000000d2H
	call	EmitErr

; 517  :                     break;
; 518  :                 }
; 519  :             }
; 520  :             continue;

	jmp	$LN206@StoreMacro
$LN127@StoreMacro:

; 501  :                     EmitError( TOO_MANY_MACRO_PLACEHOLDERS );

	mov	ecx, 220				; 000000dcH
	call	EmitError

; 502  :                     break;

	jmp	$LN206@StoreMacro
$LN66@StoreMacro:

; 521  :         }
; 522  :         locals_done = TRUE;

	mov	dil, 1
	mov	BYTE PTR locals_done$1$[rbp], dil

; 523  : 
; 524  :         /* handle macro labels, EXITM, ENDM and macro loop directives.
; 525  :          * this must be done always, even if store_data is false,
; 526  :          * to find the matching ENDM that terminates the macro.
; 527  :          */
; 528  :         if ( tok[0].token == T_COLON ) { /* macro label? */

	cmp	al, 58					; 0000003aH
	jne	SHORT $LN79@StoreMacro

; 529  :             /* skip leading spaces for macro labels! In RunMacro(),
; 530  :              * the label search routine expects no spaces before ':'.
; 531  :              */
; 532  :             src = ls.input - 1;

	lea	rsi, QWORD PTR [rbx-1]
	jmp	$LN100@StoreMacro
$LN79@StoreMacro:

; 533  :         } else if( tok[0].token == T_DIRECTIVE ) {

	cmp	al, 3
	jne	SHORT $LN81@StoreMacro

; 534  :             if ( tok[0].tokval == T_EXITM ) {

	cmp	ecx, 393				; 00000189H
	jne	SHORT $LN83@StoreMacro

; 535  :                 DebugMsg1(("StoreMacro(%s): exitm found, lvl=%u, >%s<\n", macro->sym.name, nesting_depth, ls.input ));
; 536  :                 if ( nesting_depth == 0 ) {

	cmp	DWORD PTR nesting_depth$1$[rbp], 0
	jne	$LN100@StoreMacro

; 537  :                     ptr = ls.input;
; 538  :                     while( isspace( *ptr ) ) ptr++;

	movsx	ecx, BYTE PTR [rbx]
	call	isspace
	test	eax, eax
	je	SHORT $LN25@StoreMacro
	npad	8
$LL24@StoreMacro:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL24@StoreMacro
$LN25@StoreMacro:

; 539  :                     if ( *ptr && *ptr != ';' )

	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	$LN100@StoreMacro
	cmp	al, 59					; 0000003bH
	je	$LN100@StoreMacro

; 540  :                         macro->sym.isfunc = TRUE;

	or	BYTE PTR [r13+44], 2

; 541  :                     //macro->sym.runsync = TRUE;
; 542  :                 }

	jmp	$LN100@StoreMacro
$LN83@StoreMacro:

; 543  :             } else if( tok[0].tokval == T_ENDM ) {

	cmp	ecx, 394				; 0000018aH
	jne	$LN87@StoreMacro

; 544  :                 DebugMsg1(("StoreMacro(%s): endm found, lvl=%u\n", macro->sym.name, nesting_depth ));
; 545  :                 if( nesting_depth ) {

	mov	eax, DWORD PTR nesting_depth$1$[rbp]
	test	eax, eax
	je	$LN89@StoreMacro

; 546  :                     nesting_depth--;

	dec	eax
	mov	DWORD PTR nesting_depth$1$[rbp], eax

; 547  :                 } else {
; 548  :                     break; /* exit the for() loop */
; 549  :                 }

	jmp	$LN100@StoreMacro
$LN81@StoreMacro:

; 550  :             } else if( tok[0].dirtype == DRT_LOOPDIR ) {
; 551  :                 nesting_depth++; /* FOR[C], IRP[C], REP[EA]T, WHILE */
; 552  :             }
; 553  :         } else if ( tok[0].token != T_INSTRUCTION || *ls.input == '&' ) {

	cmp	al, 1
	jne	SHORT $LL26@StoreMacro
	cmp	BYTE PTR [rbx], 38			; 00000026H
	jne	$LN100@StoreMacro
	npad	5
$LL26@StoreMacro:

; 554  :             /* Skip any token != directive or instruction (and no '&' attached)
; 555  :              * might be text macro ids, macro function calls,
; 556  :              * code labels, ...
; 557  :              */
; 558  :             for (;;) {
; 559  :                 char oldc;
; 560  :                 tok[0].token = T_FINAL;

	mov	BYTE PTR tok$[rbp], 0

; 561  :                 while ( isspace( *ls.input ) ) ls.input++;

	movsx	ecx, BYTE PTR [rbx]
	call	isspace
	test	eax, eax
	je	SHORT $LN30@StoreMacro
$LL29@StoreMacro:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL29@StoreMacro
$LN30@StoreMacro:

; 562  :                 if ( *ls.input == NULLC || *ls.input == ';' )

	mov	rcx, QWORD PTR ls$[rbp]
	movzx	eax, BYTE PTR [rcx]
	test	al, al
	je	SHORT $LN199@StoreMacro
	cmp	al, 59					; 0000003bH
	je	SHORT $LN199@StoreMacro

; 563  :                     break;
; 564  :                 oldc = *(ls.input-1);

	movzx	ebx, BYTE PTR [rcx-1]

; 565  :                 if ( GetToken( &tok[0], &ls ) == ERROR )

	lea	rdx, QWORD PTR ls$[rbp]
	lea	rcx, QWORD PTR tok$[rbp]
	call	GetToken
	cmp	eax, -1
	je	SHORT $LN199@StoreMacro
	movzx	ecx, BYTE PTR tok$[rbp]
	lea	eax, DWORD PTR [rcx-1]
	test	al, 253					; 000000fdH
	jne	SHORT $LL198@StoreMacro

; 566  :                     break;
; 567  :                 if ( ( tok[0].token == T_INSTRUCTION || tok[0].token == T_DIRECTIVE ) &&
; 568  :                     oldc != '&' && *ls.input != '&' )

	cmp	bl, 38					; 00000026H
	jne	SHORT $LN200@StoreMacro
	npad	4
$LL198@StoreMacro:

; 550  :             } else if( tok[0].dirtype == DRT_LOOPDIR ) {
; 551  :                 nesting_depth++; /* FOR[C], IRP[C], REP[EA]T, WHILE */
; 552  :             }
; 553  :         } else if ( tok[0].token != T_INSTRUCTION || *ls.input == '&' ) {

	mov	rbx, QWORD PTR ls$[rbp]
	jmp	SHORT $LL26@StoreMacro
$LN200@StoreMacro:

; 566  :                     break;
; 567  :                 if ( ( tok[0].token == T_INSTRUCTION || tok[0].token == T_DIRECTIVE ) &&
; 568  :                     oldc != '&' && *ls.input != '&' )

	mov	rbx, QWORD PTR ls$[rbp]
	cmp	BYTE PTR [rbx], 38			; 00000026H
	je	SHORT $LL26@StoreMacro
	jmp	SHORT $LN129@StoreMacro
$LN199@StoreMacro:
	movzx	ecx, BYTE PTR tok$[rbp]
$LN129@StoreMacro:

; 569  :                     break;
; 570  :             }
; 571  :             if ( tok[0].token == T_DIRECTIVE ) {

	cmp	cl, 3
	jne	SHORT $LN100@StoreMacro

; 572  :                 /* MACRO or loop directive? */
; 573  :                 if ( tok[0].tokval == T_MACRO || tok[0].dirtype == DRT_LOOPDIR )

	cmp	DWORD PTR tok$[rbp+16], 392		; 00000188H
	je	SHORT $LN101@StoreMacro
$LN87@StoreMacro:
	cmp	BYTE PTR tok$[rbp+1], 1
	jne	SHORT $LN100@StoreMacro
$LN101@StoreMacro:

; 574  :                     nesting_depth++;

	inc	DWORD PTR nesting_depth$1$[rbp]
$LN100@StoreMacro:

; 575  :             }
; 576  :         }
; 577  : 
; 578  :         /* store the line, but first check for placeholders!
; 579  :          * this is to be improved. store_placeholders() is too
; 580  :          * primitive. It's necessary to use the tokenizer.
; 581  :          */
; 582  :         if( store_data ) {

	cmp	BYTE PTR store_data$[rbp], 0
	je	$LN8@StoreMacro

; 583  :             int j;
; 584  :             uint_8 phs = 0;

	xor	dil, dil

; 585  :             if ( mindex )

	test	r15d, r15d
	je	SHORT $LN103@StoreMacro

; 586  :                 phs = store_placeholders( src, mnames );

	lea	rdx, QWORD PTR mnames$[rbp]
	mov	rcx, rsi
	call	store_placeholders
	mov	edi, eax
$LN103@StoreMacro:

; 587  :             j = strlen( src );

	or	rbx, -1
$LL185@StoreMacro:
	inc	rbx
	cmp	BYTE PTR [rsi+rbx], 0
	jne	SHORT $LL185@StoreMacro

; 588  :             *nextline = LclAlloc( sizeof( struct srcline ) + j );

	movsxd	rcx, ebx
	add	rcx, 16
	call	LclAlloc
	mov	QWORD PTR [r14], rax

; 589  :             (*nextline)->next = NULL;
; 590  :             (*nextline)->ph_count = phs;
; 591  :             memcpy( (*nextline)->line, src, j + 1 );

	mov	rdx, rsi
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR [r14]
	mov	BYTE PTR [rax+8], dil
	lea	eax, DWORD PTR [rbx+1]
	mov	rcx, QWORD PTR [r14]
	movsxd	r8, eax
	add	rcx, 9
	call	memcpy

; 592  :             nextline = &(*nextline)->next;

	mov	r14, QWORD PTR [r14]

; 593  :             DebugMsg1(("StoreMacro(%s, %u): cnt=%u, %u. line >%s<\n", macro->sym.name, nesting_depth, phs, ++lineno, RenderMacroLine( src ) ));
; 594  :         }
; 595  :     } /* end for */

	jmp	$LN206@StoreMacro
$LN60@StoreMacro:

; 439  : #if STORE_EMPTY_LINES
; 440  :             if( store_data ) {

	cmp	BYTE PTR store_data$[rbp], 0
	je	$LN8@StoreMacro

; 441  :                 *nextline = LclAlloc( sizeof( struct srcline ) );

	mov	ecx, 16
	call	LclAlloc
	mov	QWORD PTR [r14], rax

; 442  :                 (*nextline)->next = NULL;

	mov	QWORD PTR [rax], 0

; 443  :                 (*nextline)->ph_count = 0;

	mov	rax, QWORD PTR [r14]
	mov	BYTE PTR [rax+8], 0

; 444  :                 (*nextline)->line[0] = NULLC;

	mov	rax, QWORD PTR [r14]
	mov	BYTE PTR [rax+9], 0

; 445  :                 nextline = &(*nextline)->next;

	mov	r14, QWORD PTR [r14]

; 446  :             }
; 447  : #endif
; 448  :             continue;

	jmp	$LN8@StoreMacro
$LN89@StoreMacro:

; 596  :     macro->sym.isdefined = TRUE;

	or	BYTE PTR [r13+40], 2

; 597  :     macro->sym.purged = FALSE;

	and	BYTE PTR [r13+44], 239			; 000000efH

; 598  :     DebugMsg1(("StoreMacro(%s): exit, no error, isfunc=%u\n", macro->sym.name, macro->sym.isfunc));
; 599  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@StoreMacro
$LN125@StoreMacro:

; 458  :             return( ERROR );

	or	eax, -1
$LN1@StoreMacro:

; 600  : }

	mov	rbx, QWORD PTR [rbp+4888]
	lea	rsp, QWORD PTR [rbp+4816]
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
StoreMacro ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
dst$ = 64
src$ = 72
argc$ = 80
localstart$ = 88
argv$ = 96
fill_placeholders PROC

; 79   : {

$LN35:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	r15
	sub	rsp, 32					; 00000020H

; 80   :     uint_32 i;
; 81   :     const char *p;
; 82   :     unsigned parmno;
; 83   : 
; 84   :     /* scan the string, replace the placeholders #nn */
; 85   :     for( p = src ;*p != NULLC; ) {

	cmp	BYTE PTR [rdx], 0
	mov	r15d, r9d
	mov	ebp, r8d
	mov	rsi, rdx
	mov	rbx, rcx
	je	$LN33@fill_place
	mov	QWORD PTR [rsp+72], r14
	mov	r14, QWORD PTR argv$[rsp]
	mov	QWORD PTR [rsp+64], rdi
$LL2@fill_place:

; 86   :         if (*p == PLACEHOLDER_CHAR ) {

	movzx	eax, BYTE PTR [rsi]
	cmp	al, 10
	jne	$LN5@fill_place

; 87   :             p++;
; 88   :             /* we found a placeholder, get the index part! */
; 89   :             parmno = *(unsigned char *)p - 1; /* index is one-based! */

	movzx	eax, BYTE PTR [rsi+1]

; 90   :             p++;

	add	rsi, 2
	dec	eax

; 91   :             /* if parmno > argc, then it's a macro local */
; 92   :             if ( parmno >= argc ) {

	cmp	eax, ebp
	jb	$LN7@fill_place

; 93   :                 *dst++ = '?';
; 94   :                 *dst++ = '?';
; 95   :                 i = localstart + parmno - argc;

	sub	eax, ebp
	mov	WORD PTR [rbx], 16191			; 00003f3fH
	add	eax, r15d
	add	rbx, 2

; 96   :                 if ( i > 0xFFFF ) {

	cmp	eax, 65535				; 0000ffffH
	jbe	SHORT $LN9@fill_place

; 97   :                     i = sprintf( dst, "%X", i );

	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG10852
	mov	rcx, rbx
	call	sprintf
	mov	eax, eax

; 98   :                     dst += i;

	add	rbx, rax

; 99   :                 } else {

	jmp	$LN6@fill_place
$LN9@fill_place:

; 100  :                     *dst++ = HexDigit( i >> 12 );

	mov	ecx, eax
	shr	ecx, 12
	and	cl, 15
	movsx	edx, cl
	cmp	cl, 9
	jle	SHORT $LN15@fill_place
	add	edx, 55					; 00000037H
	jmp	SHORT $LN16@fill_place
$LN15@fill_place:
	add	edx, 48					; 00000030H
$LN16@fill_place:

; 101  :                     *dst++ = HexDigit( i >> 8 );

	mov	ecx, eax
	mov	BYTE PTR [rbx], dl
	shr	ecx, 8
	and	cl, 15
	movsx	edx, cl
	cmp	cl, 9
	jle	SHORT $LN19@fill_place
	add	edx, 55					; 00000037H
	jmp	SHORT $LN20@fill_place
$LN19@fill_place:
	add	edx, 48					; 00000030H
$LN20@fill_place:

; 102  :                     *dst++ = HexDigit( i >> 4 );

	mov	ecx, eax
	mov	BYTE PTR [rbx+1], dl
	shr	ecx, 4
	and	cl, 15
	movsx	edx, cl
	cmp	cl, 9
	jle	SHORT $LN23@fill_place
	add	edx, 55					; 00000037H
	jmp	SHORT $LN24@fill_place
$LN23@fill_place:
	add	edx, 48					; 00000030H
$LN24@fill_place:

; 103  :                     *dst++ = HexDigit( i );

	and	al, 15
	mov	BYTE PTR [rbx+2], dl
	movsx	ecx, al
	cmp	al, 9
	jle	SHORT $LN27@fill_place
	add	ecx, 55					; 00000037H
	mov	BYTE PTR [rbx+3], cl
	add	rbx, 4

; 104  :                 }

	jmp	SHORT $LN6@fill_place

; 103  :                     *dst++ = HexDigit( i );

$LN27@fill_place:
	add	ecx, 48					; 00000030H
	mov	BYTE PTR [rbx+3], cl
	add	rbx, 4

; 104  :                 }

	jmp	SHORT $LN6@fill_place
$LN7@fill_place:
	mov	rdx, QWORD PTR [r14+rax*8]

; 105  :             } else if ( argv[parmno] ) {  /* actual parameter might be empty (=NULL) */

	test	rdx, rdx
	je	SHORT $LN6@fill_place

; 106  :                 i = strlen( argv[parmno] );

	or	rax, -1
	npad	3
$LL32@fill_place:
	inc	rax
	cmp	BYTE PTR [rdx+rax], 0
	jne	SHORT $LL32@fill_place

; 107  :                 memcpy( dst, argv[parmno], i );

	mov	r8d, eax
	mov	rcx, rbx
	mov	edi, eax
	call	memcpy

; 108  :                 dst += i;

	add	rbx, rdi

; 109  :             }
; 110  :         } else {

	jmp	SHORT $LN6@fill_place
$LN5@fill_place:

; 111  :             *dst++ = *p++;

	mov	BYTE PTR [rbx], al
	inc	rbx
	inc	rsi
$LN6@fill_place:

; 80   :     uint_32 i;
; 81   :     const char *p;
; 82   :     unsigned parmno;
; 83   : 
; 84   :     /* scan the string, replace the placeholders #nn */
; 85   :     for( p = src ;*p != NULLC; ) {

	cmp	BYTE PTR [rsi], 0
	jne	$LL2@fill_place

; 112  :         }
; 113  :     }
; 114  :     *dst = NULLC;

	mov	r14, QWORD PTR [rsp+72]
	mov	rdi, QWORD PTR [rsp+64]
	mov	BYTE PTR [rbx], 0

; 115  :     return;
; 116  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	rsi
	pop	rbp
	ret	0
$LN33@fill_place:

; 112  :         }
; 113  :     }
; 114  :     *dst = NULLC;

	mov	BYTE PTR [rcx], 0

; 115  :     return;
; 116  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	rsi
	pop	rbp
	ret	0
fill_placeholders ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
macro$ = 8
ReleaseMacroData PROC

; 630  :     int             i;
; 631  :     struct srcline  *datacurr;
; 632  :     struct srcline  *datanext;
; 633  : 
; 634  :     DebugMsg1(("ReleaseMacroData(%s) enter\n", macro->sym.name));
; 635  :     /* free the parm list */
; 636  :     for( i = 0 ; i < macro->e.macroinfo->parmcnt; i++ ) {

	mov	rax, QWORD PTR [rcx+96]

; 637  :         /*
; 638  :          for predefined macros, don't free the param labels,
; 639  :          the items are stored in static memory
; 640  :          */
; 641  :         //if ( macro->sym.predefined == FALSE )
; 642  :         //    LclFree( (void *)macro->e.macroinfo->parmlist[i].label );
; 643  :         LclFree( macro->e.macroinfo->parmlist[i].deflt );
; 644  :     }
; 645  : 
; 646  :     macro->e.macroinfo->parmcnt = 0;

	xor	r8d, r8d
	mov	rdx, rcx
	mov	WORD PTR [rax], r8w

; 647  :     macro->e.macroinfo->localcnt = 0;

	mov	rax, QWORD PTR [rcx+96]
	mov	WORD PTR [rax+2], r8w

; 648  : 
; 649  :     if( macro->e.macroinfo->parmlist ) {

	mov	rax, QWORD PTR [rcx+96]
	cmp	QWORD PTR [rax+8], r8
	je	SHORT $LN8@ReleaseMac

; 650  :         LclFree( macro->e.macroinfo->parmlist );
; 651  :         macro->e.macroinfo->parmlist = NULL;

	mov	QWORD PTR [rax+8], r8
$LN8@ReleaseMac:

; 652  :     }
; 653  : 
; 654  :     /* free the lines list */
; 655  :     for( datacurr = macro->e.macroinfo->data ;datacurr; ) {

	mov	rcx, QWORD PTR [rcx+96]

; 656  :         datanext = datacurr->next;
; 657  :         LclFree( datacurr );
; 658  :         datacurr = datanext;
; 659  :     }
; 660  :     macro->e.macroinfo->data = NULL;

	mov	QWORD PTR [rcx+16], r8

; 661  :     macro->e.macroinfo->srcfile = 0;

	mov	rax, QWORD PTR [rdx+96]
	mov	DWORD PTR [rax+24], r8d

; 662  :     macro->sym.mac_vararg = FALSE;

	and	BYTE PTR [rdx+44], 254			; 000000feH

; 663  :     /* v2.07: the macro type should not change if a macro is
; 664  :      * PURGEd.
; 665  :      */
; 666  :     //macro->sym.isfunc = FALSE;
; 667  :     return;
; 668  : }

	ret	0
ReleaseMacroData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
name$ = 48
CreateMacro PROC

; 606  : {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H

; 607  :     struct dsym *macro;
; 608  :     if ( macro = (struct dsym *)SymCreate( name ) ) {

	call	SymCreate
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN2@CreateMacr

; 609  :         macro->sym.state = SYM_MACRO;
; 610  :         macro->e.macroinfo = LclAlloc( sizeof( struct macro_info ) );

	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rax+32], 9
	call	LclAlloc
	mov	QWORD PTR [rbx+96], rax

; 611  :         macro->e.macroinfo->parmcnt  = 0;

	xor	edx, edx
	mov	WORD PTR [rax], dx

; 612  :         macro->e.macroinfo->localcnt = 0;

	mov	rcx, QWORD PTR [rbx+96]
	mov	WORD PTR [rcx+2], dx

; 613  :         macro->e.macroinfo->parmlist = NULL;

	mov	rax, QWORD PTR [rbx+96]
	mov	QWORD PTR [rax+8], rdx

; 614  :         macro->e.macroinfo->data     = NULL;

	mov	rax, QWORD PTR [rbx+96]
	mov	QWORD PTR [rax+16], rdx

; 615  : #ifdef DEBUG_OUT
; 616  :         macro->e.macroinfo->count = 0;
; 617  : #endif
; 618  :         macro->e.macroinfo->srcfile  = 0;

	mov	rax, QWORD PTR [rbx+96]
	mov	DWORD PTR [rax+24], edx

; 619  :         macro->sym.mac_vararg = FALSE;
; 620  :         macro->sym.isfunc = FALSE;
; 621  :     }
; 622  :     return( macro );

	mov	rax, rbx
	and	BYTE PTR [rbx+44], 252			; 000000fcH
$LN2@CreateMacr:

; 623  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
CreateMacro ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rdi, rcx

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rbx
	mov	QWORD PTR [rsp+40], rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], 0
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf
	test	eax, eax
	cmovs	eax, ebx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbx
	mov	r9, rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, rbx
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf

; 1459 :     #pragma warning(pop)
; 1460 : }

	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ebx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_Locale$ = 88
_ArgList$ = 96
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR _ArgList$[rsp]
	or	rcx, 1
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rbx
	call	__stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;
; 1391 : }

	mov	rbx, QWORD PTR [rsp+64]
	or	ecx, -1
	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ecx
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
