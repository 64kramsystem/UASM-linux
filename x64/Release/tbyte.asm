; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
CONST	SEGMENT
tab_plus_exp DD	00H
	DD	00H
	DD	0a0000000H
	DW	04002H
	ORG $+2
	DD	00H
	DD	00H
	DD	0c8000000H
	DW	04005H
	ORG $+2
	DD	00H
	DD	00H
	DD	09c400000H
	DW	0400cH
	ORG $+2
	DD	00H
	DD	00H
	DD	0bebc2000H
	DW	04019H
	ORG $+2
	DD	00H
	DD	04000000H
	DD	08e1bc9bfH
	DW	04034H
	ORG $+2
	DD	0f0200000H
	DD	02b70b59dH
	DD	09dc5ada8H
	DW	04069H
	ORG $+2
	DD	03cbf6b71H
	DD	0ffcfa6d5H
	DD	0c2781f49H
	DW	040d3H
	ORG $+2
	DD	0c66f336bH
	DD	080e98cdfH
	DD	093ba47c9H
	DW	041a8H
	ORG $+2
	DD	0ddbb9018H
	DD	09df9de8dH
	DD	0aa7eebfbH
	DW	04351H
	ORG $+2
	DD	0cc655c4bH
	DD	0a60e91c6H
	DD	0e319a0aeH
	DW	046a3H
	ORG $+2
	DD	0650d3d17H
	DD	081750c17H
	DD	0c9767586H
	DW	04d48H
	ORG $+2
	DD	0a74d28b1H
	DD	0c53d5de4H
	DD	09e8b3b5dH
	DW	05a92H
	ORG $+2
	DD	0c94c14f7H
	DD	08a20979aH
	DD	0c4605202H
	DW	07525H
	ORG $+2
tab_minus_exp DD 0cccccccdH
	DD	0ccccccccH
	DD	0ccccccccH
	DW	03ffbH
	ORG $+2
	DD	03d70a3d7H
	DD	070a3d70aH
	DD	0a3d70a3dH
	DW	03ff8H
	ORG $+2
	DD	0d3c36113H
	DD	0e219652bH
	DD	0d1b71758H
	DW	03ff1H
	ORG $+2
	DD	0fdc20d2aH
	DD	08461cefcH
	DD	0abcc7711H
	DW	03fe4H
	ORG $+2
	DD	04c2ebe65H
	DD	0c44de15bH
	DD	0e69594beH
	DW	03fc9H
	ORG $+2
	DD	067de18e7H
	DD	0453994baH
	DD	0cfb11eadH
	DW	03f94H
	ORG $+2
	DD	03f2398ccH
	DD	0a539e9a5H
	DD	0a87fea27H
	DW	03f2aH
	ORG $+2
	DD	0ac7cb3d9H
	DD	064bce4a0H
	DD	0ddd0467cH
	DW	03e55H
	ORG $+2
	DD	0fa911122H
	DD	0637a1939H
	DD	0c0314325H
	DW	03cacH
	ORG $+2
	DD	07132d2e4H
	DD	0db23d21cH
	DD	09049ee32H
	DW	0395aH
	ORG $+2
	DD	087a600a6H
	DD	0da57c0bdH
	DD	0a2a682a5H
	DW	032b5H
	ORG $+2
	DD	04925110fH
	DD	034362de4H
	DD	0ceae534fH
	DW	0256bH
	ORG $+2
	DD	02de37e46H
	DD	0d2ce9fdeH
	DD	0a6dd04c8H
	DW	0ad8H
	ORG $+2
CONST	ENDS
PUBLIC	strtotb
EXTRN	isspace:PROC
pdata	SEGMENT
$pdata$strtotb DD imagerel $LN122
	DD	imagerel $LN122+16
	DD	imagerel $unwind$strtotb
$pdata$1$strtotb DD imagerel $LN122+16
	DD	imagerel $LN122+34
	DD	imagerel $chain$1$strtotb
$pdata$5$strtotb DD imagerel $LN122+34
	DD	imagerel $LN122+373
	DD	imagerel $chain$5$strtotb
$pdata$6$strtotb DD imagerel $LN122+373
	DD	imagerel $LN122+590
	DD	imagerel $chain$6$strtotb
$pdata$7$strtotb DD imagerel $LN122+590
	DD	imagerel $LN122+754
	DD	imagerel $chain$7$strtotb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$normalize DD imagerel normalize
	DD	imagerel normalize+313
	DD	imagerel $unwind$normalize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$multiply DD imagerel multiply
	DD	imagerel multiply+811
	DD	imagerel $unwind$multiply
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TB_create DD imagerel TB_create
	DD	imagerel TB_create+6
	DD	imagerel $unwind$TB_create
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$TB_create DD imagerel TB_create+6
	DD	imagerel TB_create+157
	DD	imagerel $chain$2$TB_create
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$TB_create DD imagerel TB_create+157
	DD	imagerel TB_create+205
	DD	imagerel $chain$3$TB_create
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$TB_create DD 021H
	DD	imagerel TB_create
	DD	imagerel TB_create+6
	DD	imagerel $unwind$TB_create
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$TB_create DD 061421H
	DD	0a7414H
	DD	09540dH
	DD	083405H
	DD	imagerel TB_create
	DD	imagerel TB_create+6
	DD	imagerel $unwind$TB_create
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TB_create DD 020601H
	DD	060025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$multiply DD 0a1901H
	DD	0133419H
	DD	0f0157219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalize DD 020501H
	DD	013405H
xdata	ENDS
xdata	SEGMENT
$unwind$strtotb DD 031001H
	DD	03009c210H
	DD	05008H
$chain$1$strtotb DD 040e21H
	DD	0c740eH
	DD	0136404H
	DD	imagerel $LN122
	DD	imagerel $LN122+16
	DD	imagerel $unwind$strtotb
$chain$5$strtotb DD 085f21H
	DD	0bc45fH
	DD	08f40cH
	DD	09e408H
	DD	0ad404H
	DD	imagerel $LN122+16
	DD	imagerel $LN122+34
	DD	imagerel $chain$1$strtotb
$chain$6$strtotb DD 060021H
	DD	08f400H
	DD	09e400H
	DD	0bc400H
	DD	imagerel $LN122+16
	DD	imagerel $LN122+34
	DD	imagerel $chain$1$strtotb
$chain$7$strtotb DD 021H
	DD	imagerel $LN122
	DD	imagerel $LN122+16
	DD	imagerel $unwind$strtotb
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
;	COMDAT TB_create
_TEXT	SEGMENT
res$ = 32
value$ = 64
exponent$ = 72
ld$ = 80
TB_create PROC						; COMDAT

; 329  : {

	push	rsi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR [rsp+64], rbx
	mov	rsi, r8
	mov	QWORD PTR [rsp+72], rbp
	mov	ebx, edx
	mov	QWORD PTR [rsp+80], rdi

; 330  :     const struct ELD *tabExp;
; 331  :     int i;
; 332  :     struct ELD res;
; 333  : 
; 334  :     if( exponent < 0 ) {

	test	edx, edx
	jns	SHORT $LN5@TB_create

; 335  :         exponent = -exponent;

	neg	ebx

; 336  :         tabExp = tab_minus_exp;

	lea	rbp, OFFSET FLAT:tab_minus_exp

; 337  :     } else {

	jmp	SHORT $LN6@TB_create
$LN5@TB_create:

; 338  :         tabExp = tab_plus_exp;

	lea	rbp, OFFSET FLAT:tab_plus_exp
$LN6@TB_create:

; 339  :     }
; 340  :     U96LD(value, &res);

	lea	rdx, QWORD PTR res$[rsp]
	call	U96LD

; 341  :     for( i = 0; i < MAX_EXP_INDEX; i++ ) {

	xor	edi, edi
	npad	4
$LL4@TB_create:

; 342  :         if ( exponent & 1 ) {

	test	bl, 1
	je	SHORT $LN7@TB_create

; 343  :             multiply(&res, tabExp + i, &res);

	movsxd	rdx, edi
	lea	r8, QWORD PTR res$[rsp]
	shl	rdx, 4
	lea	rcx, QWORD PTR res$[rsp]
	add	rdx, rbp
	call	multiply
$LN7@TB_create:

; 344  :         }
; 345  :         exponent >>= 1;

	sar	ebx, 1

; 346  :         if( exponent == 0 ) break;

	je	SHORT $LN15@TB_create

; 341  :     for( i = 0; i < MAX_EXP_INDEX; i++ ) {

	inc	edi
	cmp	edi, 13
	jl	SHORT $LL4@TB_create
$LN15@TB_create:

; 347  :     }
; 348  :     if( exponent != 0 ) {
; 349  :         /* exponent overflow */
; 350  :     }
; 351  :     ld->e = res.e;
; 352  :     ld->m = res.m32[1] + ((uint_64)res.m32[2] << 32) ;

	mov	ecx, DWORD PTR res$[rsp+8]
	mov	eax, DWORD PTR res$[rsp+4]
	movzx	edx, WORD PTR res$[rsp+12]
	mov	rdi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]
	shl	rcx, 32					; 00000020H
	add	rax, rcx
	mov	WORD PTR [rsi+8], dx

; 353  :     /* round result */
; 354  :     if( res.m32[0] & 0x80000000U ) {

	test	DWORD PTR res$[rsp], -2147483648	; 80000000H
	mov	QWORD PTR [rsi], rax
	je	SHORT $LN19@TB_create

; 355  :         if( ld->m == MAXUI64 ) {

	cmp	rax, -1
	jne	SHORT $LN11@TB_create

; 356  :             ld->m = MAXUI64BIT;

	mov	rax, -9223372036854775808		; 8000000000000000H

; 357  :             ld->e++;

	inc	dx

; 358  :         } else {
; 359  :             ld->m++;

	mov	QWORD PTR [rsi], rax

; 360  :         }
; 361  :     }
; 362  :     return( 0 );

	xor	eax, eax
	mov	WORD PTR [rsi+8], dx

; 363  : }

	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
$LN11@TB_create:

; 358  :         } else {
; 359  :             ld->m++;

	inc	rax
	mov	QWORD PTR [rsi], rax
$LN19@TB_create:

; 360  :         }
; 361  :     }
; 362  :     return( 0 );

	xor	eax, eax

; 363  : }

	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
TB_create ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
;	COMDAT multiply
_TEXT	SEGMENT
r1$ = 32
exp$1$ = 128
op1$ = 128
cy$3$ = 136
op2$ = 136
res$ = 144
multiply PROC						; COMDAT

; 283  : {

	mov	QWORD PTR [rsp+32], rbx
	mov	QWORD PTR [rsp+24], r8
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H

; 284  :     uint_64 x1;
; 285  :     union u192 r1;
; 286  :     int_32 exp;
; 287  : 
; 288  :     exp = (int_32)(op1->e & 0x7fff) + (int_32)(op2->e & 0x7fff) - EXPONENT_BIAS + 1;
; 289  :     r1.m64[0] = (uint_64)(op1->m32[0]) * (uint_64)(op2->m32[0]);

	mov	ebp, DWORD PTR [rdx]
	mov	esi, DWORD PTR [rcx]
	mov	eax, ebp

; 290  :     r1.m64[1] = (uint_64)(op1->m32[1]) * (uint_64)(op2->m32[1]);

	mov	r12d, DWORD PTR [rdx+4]
	mov	r14d, DWORD PTR [rcx+4]

; 291  :     r1.m64[2] = (uint_64)(op1->m32[2]) * (uint_64)(op2->m32[2]);
; 292  :     x1 = (uint_64)(op1->m32[1]) * (uint_64)(op2->m32[0]);
; 293  :     add192( &r1, x1, 1 );
; 294  :     x1 = (uint_64)(op1->m32[0]) * (uint_64)(op2->m32[1]);

	mov	ebx, r12d
	movzx	r8d, WORD PTR [rdx+12]
	mov	edi, r14d
	movzx	r9d, WORD PTR [rcx+12]
	and	r8d, 32767				; 00007fffH
	mov	r13d, DWORD PTR [rdx+8]
	add	r8d, -16382				; ffffffffffffc002H
	imul	rax, rsi
	imul	rdi, rbp
	imul	rbx, rsi
	mov	QWORD PTR r1$[rsp], rax
	and	r9d, 32767				; 00007fffH
	mov	r11d, DWORD PTR r1$[rsp+4]
	add	r8d, r9d
	mov	DWORD PTR exp$1$[rsp], r8d
	mov	eax, r12d
	mov	r8d, DWORD PTR [rcx+8]
	imul	rax, r14
	mov	QWORD PTR cy$3$[rsp], r8
	mov	QWORD PTR r1$[rsp+8], rax
	mov	eax, r13d
	imul	rax, r8
	mov	QWORD PTR r1$[rsp+16], rax
	mov	r15d, DWORD PTR r1$[rsp+20]
	mov	eax, edi
	add	r11, rax
	shr	rdi, 32					; 00000020H
	mov	eax, DWORD PTR r1$[rsp+8]
	mov	rcx, r11
	shr	rcx, 32					; 00000020H
	add	rcx, rax
	mov	eax, DWORD PTR r1$[rsp+12]
	mov	rdx, rcx
	shr	rdx, 32					; 00000020H
	add	rdx, rax
	mov	eax, DWORD PTR r1$[rsp+16]
	mov	r8, rdx
	shr	r8, 32					; 00000020H
	add	r8, rax
	mov	rax, r8
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, ecx
	add	rdi, rax
	mov	eax, edx
	mov	r9, rdi
	shr	r9, 32					; 00000020H
	add	r9, rax
	mov	eax, r8d
	mov	r10, r9

; 295  :     add192( &r1, x1, 1 );

	mov	r8d, r11d
	shr	r10, 32					; 00000020H
	add	r10, rax
	mov	rax, r10
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, ebx
	add	r8, rax
	shr	rbx, 32					; 00000020H
	mov	DWORD PTR r1$[rsp+4], r8d
	shr	r8, 32					; 00000020H
	mov	eax, edi
	add	r8, rax
	mov	eax, r9d
	mov	rcx, r8
	shr	rcx, 32					; 00000020H
	add	rcx, rax
	mov	eax, r10d
	mov	rdx, rcx
	shr	rdx, 32					; 00000020H
	add	rdx, rax
	mov	rax, rdx
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, r8d
	add	rbx, rax
	mov	eax, ecx

; 296  :     x1 = (uint_64)(op1->m32[0]) * (uint_64)(op2->m32[2]);

	mov	r11d, r13d
	imul	r11, rsi

; 297  :     add192( &r1, x1, 2 );
; 298  :     x1 = (uint_64)(op1->m32[2]) * (uint_64)(op2->m32[0]);
; 299  :     add192( &r1, x1, 2 );
; 300  :     x1 = (uint_64)(op1->m32[1]) * (uint_64)(op2->m32[2]);

	imul	r13, r14
	mov	r8, rbx
	mov	r10d, ebx
	mov	rbx, QWORD PTR cy$3$[rsp]
	shr	r8, 32					; 00000020H
	add	r8, rax
	mov	eax, edx
	mov	r9, r8
	shr	r9, 32					; 00000020H
	add	r9, rax
	mov	rax, r9
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, r11d
	add	r10, rax
	shr	r11, 32					; 00000020H
	mov	eax, r8d
	mov	rcx, r10
	shr	rcx, 32					; 00000020H
	add	rcx, rax
	mov	eax, r9d
	mov	rdx, rcx
	mov	r9, rbx
	shr	rdx, 32					; 00000020H
	add	rdx, rax
	mov	rax, rdx
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, ecx
	add	r11, rax
	mov	eax, edx
	imul	r9, rbp
	mov	r8, r11
	mov	edx, r10d
	shr	r8, 32					; 00000020H
	add	r8, rax
	mov	rax, r8
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, r9d
	add	rdx, rax
	shr	r9, 32					; 00000020H
	mov	DWORD PTR r1$[rsp+8], edx
	shr	rdx, 32					; 00000020H
	mov	eax, r11d
	add	rdx, rax
	mov	eax, r8d
	mov	rcx, rdx
	shr	rcx, 32					; 00000020H
	add	rcx, rax
	mov	rax, rcx
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, edx
	add	r9, rax
	mov	eax, ecx
	mov	rdx, r9

; 301  :     add192( &r1, x1, 3 );

	mov	r8d, r9d
	shr	rdx, 32					; 00000020H
	add	rdx, rax
	mov	rax, rdx
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, r13d
	add	r8, rax
	shr	r13, 32					; 00000020H
	mov	eax, edx
	mov	rcx, r8
	shr	rcx, 32					; 00000020H
	add	rcx, rax
	mov	rax, rcx
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, ecx
	add	r13, rax
	mov	rax, r13
	shr	rax, 32					; 00000020H
	add	r15d, eax

; 302  :     x1 = (uint_64)(op1->m32[2]) * (uint_64)(op2->m32[1]);

	imul	rbx, r12

; 303  :     add192( &r1, x1, 3 );

	mov	ecx, r8d
	mov	eax, ebx
	add	rcx, rax
	shr	rbx, 32					; 00000020H
	mov	DWORD PTR r1$[rsp+12], ecx
	shr	rcx, 32					; 00000020H
	mov	eax, r13d
	add	rcx, rax
	mov	rax, rcx
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, ecx
	add	rbx, rax

; 304  :     exp += normalize( &r1 );

	lea	rcx, QWORD PTR r1$[rsp]
	mov	DWORD PTR r1$[rsp+16], ebx
	shr	rbx, 32					; 00000020H
	add	r15d, ebx
	mov	DWORD PTR r1$[rsp+20], r15d
	call	normalize
	mov	r9d, DWORD PTR exp$1$[rsp]

; 305  :     /* round result */
; 306  :     if( r1.m32[2] & 0x80000000U ) {
; 307  :         if( r1.m32[5] == 0xffffffffU && r1.m32[4] == 0xffffffffU && r1.m32[3] == 0xffffffffU ) {

	mov	edx, DWORD PTR r1$[rsp+20]
	add	r9d, eax
	test	DWORD PTR r1$[rsp+8], -2147483648	; 80000000H
	je	SHORT $LN179@multiply
	mov	eax, DWORD PTR r1$[rsp+16]
	mov	ecx, DWORD PTR r1$[rsp+12]
	cmp	edx, -1					; ffffffffH
	jne	SHORT $LN3@multiply
	cmp	eax, edx
	jne	SHORT $LN3@multiply
	cmp	ecx, edx
	jne	SHORT $LN3@multiply

; 308  :             r1.m32[3] = 0;

	xor	r8d, r8d

; 309  :             r1.m32[4] = 0;
; 310  :             r1.m32[5] = 0x80000000U;

	mov	edx, -2147483648			; 80000000H
	mov	ecx, r8d

; 311  :             exp++;

	inc	r9d

; 312  :         } else {

	jmp	SHORT $LN176@multiply
$LN3@multiply:

; 313  :             x1 = 1L;
; 314  :             add192( &r1, x1, 3 );

	lea	r8, QWORD PTR [rcx+1]
	mov	rcx, r8
	shr	rcx, 32					; 00000020H
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, ecx
	shr	rax, 32					; 00000020H
	add	edx, eax
	mov	eax, ecx
	shr	rax, 32					; 00000020H
	add	edx, eax
	jmp	SHORT $LN176@multiply
$LN179@multiply:
	mov	ecx, DWORD PTR r1$[rsp+16]
	mov	r8d, DWORD PTR r1$[rsp+12]
$LN176@multiply:

; 315  :         }
; 316  :     }
; 317  :     res->m32[0] = r1.m32[3];

	mov	rax, QWORD PTR res$[rsp]

; 318  :     res->m32[1] = r1.m32[4];
; 319  :     res->m32[2] = r1.m32[5];
; 320  :     res->e = exp;
; 321  :     return( 0 );
; 322  : }

	mov	rbx, QWORD PTR [rsp+152]
	mov	DWORD PTR [rax], r8d
	mov	DWORD PTR [rax+4], ecx
	mov	DWORD PTR [rax+8], edx
	mov	WORD PTR [rax+12], r9w
	xor	eax, eax
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
multiply ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
;	COMDAT add192
_TEXT	SEGMENT
res$ = 8
x$ = 16
pos$ = 24
add192	PROC						; COMDAT

; 260  :     uint_64 cy;
; 261  :     int i;
; 262  : 
; 263  :     cy = (uint_32)x;
; 264  :     for( i = pos; i < 6; i++ ) {

	movsxd	r10, r8d
	mov	r11, rcx
	mov	r9d, edx
	cmp	r10, 6
	jge	SHORT $LN3@add192
	npad	1
$LL13@add192:

; 265  :         cy += res->m32[i];

	mov	eax, DWORD PTR [rcx+r10*4]
	add	r9, rax

; 266  :         res->m32[i] = cy;

	mov	DWORD PTR [rcx+r10*4], r9d
	inc	r10

; 267  :         cy >>= 32;

	shr	r9, 32					; 00000020H
	cmp	r10, 6
	jl	SHORT $LL13@add192
$LN3@add192:

; 268  :     }
; 269  :     cy = x >> 32;
; 270  :     for( i = pos + 1; i < 6; i++ ) {

	lea	eax, DWORD PTR [r8+1]
	shr	rdx, 32					; 00000020H
	movsxd	rcx, eax
	cmp	rcx, 6
	jge	SHORT $LN21@add192
	npad	7
$LL15@add192:

; 271  :         cy += res->m32[i];

	mov	eax, DWORD PTR [r11+rcx*4]
	add	rdx, rax

; 272  :         res->m32[i] = cy;

	mov	DWORD PTR [r11+rcx*4], edx
	inc	rcx

; 273  :         cy >>= 32;

	shr	rdx, 32					; 00000020H
	cmp	rcx, 6
	jl	SHORT $LL15@add192
$LN21@add192:

; 274  :     }
; 275  :     return( 0 );

	xor	eax, eax

; 276  : }

	ret	0
add192	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
;	COMDAT normalize
_TEXT	SEGMENT
res$ = 8
normalize PROC						; COMDAT

; 222  : {

	mov	QWORD PTR [rsp+8], rbx

; 223  :     int shft;
; 224  :     int bs;
; 225  :     int bs1;
; 226  : 
; 227  :     bs = bitsize64( res->m64[2] ) + 128;

	mov	rax, QWORD PTR [rcx+16]
	mov	edx, 64					; 00000040H
	mov	r10d, edx
	mov	rbx, rcx
	mov	r8, -9223372036854775808		; 8000000000000000H
	npad	2
$LL10@normalize:
	test	rax, r8
	jne	SHORT $LN28@normalize
	add	rax, rax
	test	rax, r8
	jne	SHORT $LN37@normalize
	add	rax, rax
	sub	r10d, 2
	test	r10d, r10d
	jg	SHORT $LL10@normalize
	jmp	SHORT $LN28@normalize
$LN37@normalize:
	dec	r10d
$LN28@normalize:
	sub	r10d, -128				; ffffffffffffff80H

; 228  :     if( bs == 128 ) {

	xor	r9d, r9d
	cmp	r10d, 128				; 00000080H
	jne	SHORT $LN2@normalize

; 229  :         res->m64[2] = res->m64[1];

	mov	rcx, QWORD PTR [rcx+8]

; 230  :         res->m64[1] = res->m64[0];
; 231  :         res->m64[0] = 0;
; 232  :         bs = bitsize64( res->m64[2] ) + 64;

	mov	r10d, edx
	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rbx+16], rcx
	mov	QWORD PTR [rbx+8], rax
	mov	QWORD PTR [rbx], r9
$LL16@normalize:
	test	rcx, r8
	jne	SHORT $LN29@normalize
	add	rcx, rcx
	test	rcx, r8
	jne	SHORT $LN38@normalize
	add	rcx, rcx
	sub	r10d, 2
	test	r10d, r10d
	jg	SHORT $LL16@normalize
	jmp	SHORT $LN29@normalize
$LN38@normalize:
	dec	r10d
$LN29@normalize:
	add	r10d, edx
$LN2@normalize:

; 233  :     }
; 234  :     if( bs == 64 ) {

	cmp	r10d, edx
	jne	SHORT $LN30@normalize

; 235  :         res->m64[2] = res->m64[1];

	mov	rax, QWORD PTR [rbx+8]

; 236  :         res->m64[1] = res->m64[0];
; 237  :         res->m64[0] = 0;
; 238  :         bs = bitsize64( res->m64[2] );

	mov	r10d, edx
	mov	rcx, QWORD PTR [rbx]
	mov	QWORD PTR [rbx+16], rax
	mov	QWORD PTR [rbx+8], rcx
	mov	QWORD PTR [rbx], r9
	npad	2
$LL22@normalize:
	test	rax, r8
	jne	SHORT $LN30@normalize
	add	rax, rax
	test	rax, r8
	jne	SHORT $LN39@normalize
	add	rax, rax
	sub	r10d, 2
	test	r10d, r10d
	jg	SHORT $LL22@normalize
	jmp	SHORT $LN30@normalize
$LN39@normalize:
	dec	r10d
$LN30@normalize:

; 239  :     }
; 240  :     if( bs == 0 ) {

	test	r10d, r10d
	jne	SHORT $LN4@normalize

; 241  :         return( 0 );

	xor	eax, eax

; 251  :     }
; 252  :     return( bs - 192 );
; 253  : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
$LN4@normalize:

; 242  :     }
; 243  :     bs1 = bs % 64;

	mov	r11d, r10d
	and	r11d, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN43@normalize
	dec	r11d
	or	r11d, -64				; ffffffffffffffc0H
	inc	r11d
$LN43@normalize:

; 244  :     if ( bs1 ) {

	test	r11d, r11d
	je	SHORT $LN5@normalize

; 245  :         shft = 64 - bs1;
; 246  :         res->m64[2] <<= shft;
; 247  :         res->m64[2] |= res->m64[1] >> bs1;

	mov	r8, QWORD PTR [rbx+8]
	sub	edx, r11d
	movsxd	r9, edx
	mov	rax, r8
	mov	rdx, QWORD PTR [rbx+16]
	mov	rcx, r9
	shl	rdx, cl
	mov	ecx, r11d
	shr	rax, cl

; 248  :         res->m64[1] <<= shft;

	mov	rcx, r9
	or	rdx, rax
	shl	r8, cl
	mov	QWORD PTR [rbx+16], rdx

; 249  :         res->m64[1] |= res->m64[0] >> bs1;

	mov	ecx, r11d
	mov	rdx, QWORD PTR [rbx]
	mov	rax, rdx
	shr	rax, cl

; 250  :         res->m64[0] <<= shft;

	mov	rcx, r9
	or	r8, rax
	shl	rdx, cl
	mov	QWORD PTR [rbx], rdx
	mov	QWORD PTR [rbx+8], r8
$LN5@normalize:

; 251  :     }
; 252  :     return( bs - 192 );
; 253  : }

	mov	rbx, QWORD PTR [rsp+8]
	lea	eax, DWORD PTR [r10-192]
	ret	0
normalize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
;	COMDAT U96LD
_TEXT	SEGMENT
op$ = 8
res$ = 16
U96LD	PROC						; COMDAT

; 183  :     int bs;
; 184  :     int shft;
; 185  : 
; 186  :     memcpy( res, op, sizeof( union u96 ) );

	movsd	xmm0, QWORD PTR [rcx]

; 187  :     bs = bitsize32( res->m32[2] ) + 64;

	mov	r11d, 32				; 00000020H
	movsd	QWORD PTR [rdx], xmm0
	mov	r10, rdx
	mov	eax, DWORD PTR [rcx+8]
	mov	ecx, r11d
	mov	DWORD PTR [rdx+8], eax
	npad	6
$LL11@U96LD:
	test	eax, eax
	js	SHORT $LN29@U96LD
	add	eax, eax
	js	SHORT $LN38@U96LD
	add	eax, eax
	sub	ecx, 2
	test	ecx, ecx
	jg	SHORT $LL11@U96LD
	jmp	SHORT $LN29@U96LD
$LN38@U96LD:
	dec	ecx
$LN29@U96LD:
	lea	eax, DWORD PTR [rcx+64]

; 188  :     if( bs == 64 ) {

	xor	edx, edx
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN2@U96LD

; 189  :         res->m32[2] = res->m32[1];
; 190  :         res->m32[1] = res->m32[0];

	mov	eax, DWORD PTR [r10]
	mov	ecx, DWORD PTR [r10+4]
	mov	DWORD PTR [r10+4], eax

; 191  :         res->m32[0] = 0;
; 192  :         bs = bitsize32( res->m32[2] ) + 32;

	mov	eax, r11d
	mov	DWORD PTR [r10+8], ecx
	mov	DWORD PTR [r10], edx
$LL17@U96LD:
	test	ecx, ecx
	js	SHORT $LN30@U96LD
	add	ecx, ecx
	js	SHORT $LN39@U96LD
	add	ecx, ecx
	sub	eax, 2
	test	eax, eax
	jg	SHORT $LL17@U96LD
	jmp	SHORT $LN30@U96LD
$LN39@U96LD:
	dec	eax
$LN30@U96LD:
	add	eax, r11d
$LN2@U96LD:

; 193  :     }
; 194  :     if( bs == 32 ) {

	cmp	eax, r11d
	jne	SHORT $LN3@U96LD

; 195  :         res->m32[2] = res->m32[1];
; 196  :         res->m32[1] = res->m32[0];

	mov	eax, DWORD PTR [r10]
	mov	ecx, DWORD PTR [r10+4]
	mov	DWORD PTR [r10+4], eax

; 197  :         res->m32[0] = 0;
; 198  :         bs = bitsize32( res->m32[2] );

	mov	eax, r11d
	mov	DWORD PTR [r10+8], ecx
	mov	DWORD PTR [r10], edx
$LL23@U96LD:
	test	ecx, ecx
	js	SHORT $LN3@U96LD
	add	ecx, ecx
	js	SHORT $LN40@U96LD
	add	ecx, ecx
	sub	eax, 2
	test	eax, eax
	jg	SHORT $LL23@U96LD
	jmp	SHORT $LN3@U96LD
$LN40@U96LD:
	dec	eax
$LN3@U96LD:

; 199  :     }
; 200  :     if( bs == 0 ) {

	test	eax, eax
	jne	SHORT $LN4@U96LD

; 201  :         res->e = 0;

	mov	WORD PTR [r10+12], dx

; 215  : }

	ret	0
$LN4@U96LD:

; 202  :     } else {
; 203  :         res->e = bs - 1 + EXPONENT_BIAS;

	mov	ecx, 16382				; 00003ffeH
	add	ecx, eax
	mov	WORD PTR [r10+12], cx

; 204  :         bs %= 32;

	and	eax, -2147483617			; ffffffff8000001fH
	jge	SHORT $LN44@U96LD
	dec	eax
	or	eax, -32				; ffffffffffffffe0H
	inc	eax
$LN44@U96LD:

; 205  :         if( bs ) {

	test	eax, eax
	je	SHORT $LN45@U96LD

; 206  :             shft = 32 - bs;
; 207  :             res->m32[2] <<= shft;
; 208  :             res->m32[2] |= res->m32[1] >> bs;

	mov	r9d, DWORD PTR [r10+4]
	sub	r11d, eax
	mov	r8d, DWORD PTR [r10+8]
	mov	ecx, r11d
	shl	r8d, cl
	mov	edx, r9d
	mov	ecx, eax
	shr	edx, cl
	or	edx, r8d

; 209  :             res->m32[1] <<= shft;
; 210  :             res->m32[1] |= res->m32[0] >> bs;

	mov	r8d, DWORD PTR [r10]
	mov	DWORD PTR [r10+8], edx
	mov	edx, r8d
	shr	edx, cl
	mov	ecx, r11d
	shl	r9d, cl
	or	edx, r9d

; 211  :             res->m32[0] <<= shft;

	shl	r8d, cl
	mov	DWORD PTR [r10], r8d
	mov	DWORD PTR [r10+4], edx
$LN45@U96LD:

; 212  :         }
; 213  :     }
; 214  :     return( 0 );

	xor	eax, eax

; 215  : }

	ret	0
U96LD	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
;	COMDAT bitsize64
_TEXT	SEGMENT
x$ = 8
bitsize64 PROC						; COMDAT

; 169  :     int i;
; 170  : 
; 171  :     for( i = 64; i > 0 ; i-- ) {

	mov	eax, 64					; 00000040H
	mov	rdx, -9223372036854775808		; 8000000000000000H
	npad	1
$LL4@bitsize64:

; 172  :         if( x & MAXUI64BIT ) break;

	test	rcx, rdx
	jne	SHORT $LN13@bitsize64

; 173  :         x <<= 1;

	add	rcx, rcx
	test	rcx, rdx
	jne	SHORT $LN11@bitsize64
	add	rcx, rcx
	sub	eax, 2
	test	eax, eax
	jg	SHORT $LL4@bitsize64

; 174  :     }
; 175  :     return( i );
; 176  : }

	ret	0
$LN11@bitsize64:

; 172  :         if( x & MAXUI64BIT ) break;

	dec	eax
$LN13@bitsize64:

; 174  :     }
; 175  :     return( i );
; 176  : }

	ret	0
bitsize64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
;	COMDAT bitsize32
_TEXT	SEGMENT
x$ = 8
bitsize32 PROC						; COMDAT

; 155  :     int i;
; 156  : 
; 157  :     for( i = 32; i > 0 ; i-- ) {

	mov	eax, 32					; 00000020H
$LL4@bitsize32:

; 158  :         if( x & 0x80000000U ) break;

	test	ecx, ecx
	js	SHORT $LN13@bitsize32

; 159  :         x <<= 1;

	add	ecx, ecx

; 158  :         if( x & 0x80000000U ) break;

	js	SHORT $LN11@bitsize32

; 159  :         x <<= 1;

	add	ecx, ecx
	sub	eax, 2
	test	eax, eax
	jg	SHORT $LL4@bitsize32

; 160  :     }
; 161  :     return( i );
; 162  : }

	ret	0
$LN11@bitsize32:

; 158  :         if( x & 0x80000000U ) break;

	dec	eax
$LN13@bitsize32:

; 160  :     }
; 161  :     return( i );
; 162  : }

	ret	0
bitsize32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
;	COMDAT add_check_u96_overflow
_TEXT	SEGMENT
x$ = 8
c$ = 16
add_check_u96_overflow PROC				; COMDAT

; 134  :     uint_64 cy;
; 135  :     int i;
; 136  : 
; 137  :     if( cmp_u96_max( x ) > 0 ) {

	mov	eax, DWORD PTR [rcx+8]
	mov	r9, rcx
	cmp	eax, 429496729				; 19999999H
	ja	SHORT $LN29@add_check_
	jb	SHORT $LN5@add_check_
	mov	eax, DWORD PTR [rcx+4]
	cmp	eax, -1717986919			; 99999999H
	ja	SHORT $LN29@add_check_
	jb	SHORT $LN5@add_check_
	cmp	DWORD PTR [rcx], -1717986919		; 99999999H
	jae	SHORT $LN29@add_check_
$LN5@add_check_:

; 139  :     } else {
; 140  :         cy = c;
; 141  :         for( i = 0; i < 3; i++ ) {
; 142  :             cy += (uint_64)x->m32[i] * 10;

	mov	eax, DWORD PTR [rcx]
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	eax, edx
	lea	rdx, QWORD PTR [rax+rcx*2]
	mov	eax, DWORD PTR [r9+4]

; 143  :             x->m32[i] = cy;

	mov	DWORD PTR [r9], edx

; 144  :             cy >>= 32;

	shr	rdx, 32					; 00000020H
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	eax, DWORD PTR [r9+8]
	lea	r8, QWORD PTR [rdx+rcx*2]
	mov	DWORD PTR [r9+4], r8d
	lea	ecx, DWORD PTR [rax+rax*4]
	shr	r8, 32					; 00000020H
	add	ecx, ecx
	add	r8d, ecx
	mov	DWORD PTR [r9+8], r8d

; 145  :         }
; 146  :         return( 0 );

	xor	eax, eax

; 147  :     }
; 148  : }

	ret	0
$LN29@add_check_:

; 138  :         return( 1 );

	mov	eax, 1

; 147  :     }
; 148  : }

	ret	0
add_check_u96_overflow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
;	COMDAT cmp_u96_max
_TEXT	SEGMENT
x$ = 8
cmp_u96_max PROC					; COMDAT

; 111  :     if( x->m32[2] > 0x19999999UL ) {

	mov	eax, DWORD PTR [rcx+8]
	cmp	eax, 429496729				; 19999999H
	jbe	SHORT $LN15@cmp_u96_ma
$LN18@cmp_u96_ma:

; 112  :         return( 1 );

	mov	eax, 1

; 122  :         return( -1 );
; 123  :     } else {
; 124  :         return( 0 );
; 125  :     }
; 126  : }

	ret	0
$LN15@cmp_u96_ma:

; 113  :     } else if( x->m32[2] < 0x19999999UL ) {

	jae	SHORT $LN4@cmp_u96_ma
$LN19@cmp_u96_ma:

; 114  :         return( -1 );

	or	eax, -1

; 122  :         return( -1 );
; 123  :     } else {
; 124  :         return( 0 );
; 125  :     }
; 126  : }

	ret	0
$LN4@cmp_u96_ma:

; 115  :     } else if( x->m32[1] > 0x99999999UL ) {

	mov	eax, DWORD PTR [rcx+4]
	cmp	eax, -1717986919			; 99999999H
	ja	SHORT $LN18@cmp_u96_ma

; 116  :         return( 1 );
; 117  :     } else if( x->m32[1] < 0x99999999UL ) {

	jb	SHORT $LN19@cmp_u96_ma

; 118  :         return( -1 );
; 119  :     } else if( x->m32[0] > 0x99999998UL ) {

	mov	eax, DWORD PTR [rcx]
	cmp	eax, -1717986920			; 99999998H
	ja	SHORT $LN18@cmp_u96_ma

; 120  :         return( 1 );
; 121  :     } else if( x->m32[0] < 0x99999998UL ) {

	sbb	eax, eax

; 122  :         return( -1 );
; 123  :     } else {
; 124  :         return( 0 );
; 125  :     }
; 126  : }

	ret	0
cmp_u96_max ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
_TEXT	SEGMENT
value_tmp$ = 32
value$ = 48
exp_sign$1$ = 128
p$ = 128
ld$ = 136
sign$1$ = 144
negative$ = 144
strtotb	PROC

; 370  : {

$LN122:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rdx
	push	rbp
	push	rbx
	mov	rbp, rsp
	sub	rsp, 104				; 00000068H
	mov	QWORD PTR [rax+32], rsi
	mov	rbx, rcx

; 371  :     int              sign = +1;
; 372  :     int              exp_sign = +1;
; 373  :     int_32           exp_value;
; 374  :     int              overflow;
; 375  :     int_32           exp1;
; 376  :     int_32           exponent;
; 377  :     int_32           exponent_tmp;
; 378  :     union u96        value;
; 379  :     union u96        value_tmp;
; 380  : 
; 381  :     while ( isspace( *p ) ) p++;

	movsx	ecx, BYTE PTR [rcx]
	mov	QWORD PTR [rax-24], rdi
	movzx	edi, r8b
	mov	QWORD PTR [rax-40], r13
	mov	QWORD PTR [rax-48], r14
	mov	QWORD PTR [rax-56], r15
	mov	eax, 1
	mov	DWORD PTR exp_sign$1$[rbp-104], eax
	mov	esi, eax
	mov	DWORD PTR sign$1$[rbp-104], eax
	call	isspace
	test	eax, eax
	je	SHORT $LN3@strtotb
$LL2@strtotb:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL2@strtotb
$LN3@strtotb:

; 382  :     switch (*p) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, 43					; 0000002bH
	je	SHORT $LN15@strtotb
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN16@strtotb

; 383  :     case '-':
; 384  :         sign = -1;

	or	esi, -1
	mov	DWORD PTR sign$1$[rbp-104], esi
$LN15@strtotb:

; 385  :     case '+':
; 386  :         p++;

	inc	rbx
$LN16@strtotb:

; 387  :     default :
; 388  :         break;
; 389  :     }
; 390  :     if( negative ) {

	test	dil, dil
	je	SHORT $LN17@strtotb

; 391  :         sign = -sign;

	neg	esi
	mov	DWORD PTR sign$1$[rbp-104], esi
$LN17@strtotb:

; 392  :     }
; 393  :     memset( &value, 0, sizeof( value ) );
; 394  :     memset( &value_tmp, 0, sizeof( value_tmp ) );
; 395  :     //exponent = 0;
; 396  :     exp1 = 0;
; 397  :     exponent_tmp = 0;
; 398  :     overflow = 0;
; 399  :     while ( (unsigned int)(*p - '0') < 10u ) {

	movsx	r8d, BYTE PTR [rbx]
	xor	r10d, r10d
	xor	r13d, r13d
	mov	QWORD PTR [rsp+88], r12
	xor	r11d, r11d
	mov	QWORD PTR value$[rbp-104], r13
	mov	edx, r13d
	mov	QWORD PTR value_tmp$[rbp-104], r11
	mov	edi, DWORD PTR value_tmp$[rbp-100]
	lea	r14d, DWORD PTR [r8-48]
	mov	DWORD PTR value$[rbp-96], edx
	mov	r9d, r10d
	mov	esi, r10d
	mov	r15d, r10d
	mov	eax, r8d
	mov	r12d, r11d
	cmp	r14d, 10
	jae	$LN7@strtotb
$LL6@strtotb:

; 400  :         if( overflow ) {

	test	r15d, r15d
	jne	$LN120@strtotb

; 401  :             exponent_tmp++;
; 402  :             exp1++;
; 403  :         } else {
; 404  :             if( add_check_u96_overflow( &value_tmp, *p - '0' ) ) {

	cmp	r11d, 429496729				; 19999999H
	ja	SHORT $LN113@strtotb
	jb	SHORT $LN44@strtotb
	cmp	edi, -1717986919			; 99999999H
	ja	SHORT $LN113@strtotb
	jb	SHORT $LN44@strtotb
	cmp	r12d, -1717986919			; 99999999H
	jae	SHORT $LN113@strtotb
$LN44@strtotb:
	mov	eax, r12d
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	eax, edi
	lea	r12, QWORD PTR [r14+rcx*2]
	mov	DWORD PTR value_tmp$[rbp-104], r12d
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, r12
	shr	rax, 32					; 00000020H
	lea	rdi, QWORD PTR [rax+rcx*2]
	lea	eax, DWORD PTR [r11+r11*4]
	mov	DWORD PTR value_tmp$[rbp-100], edi
	add	eax, eax
	mov	rcx, rdi
	shr	rcx, 32					; 00000020H
	add	ecx, eax
	mov	r11d, ecx

; 408  :             } else if( *p != '0' ) {

	cmp	r8b, 48					; 00000030H
	je	SHORT $LN22@strtotb

; 409  :                 memcpy( &value, &value_tmp, sizeof( value ) );

	movsd	xmm0, QWORD PTR value_tmp$[rbp-104]
	mov	edx, ecx
	movsd	QWORD PTR value$[rbp-104], xmm0

; 410  :                 exp1 = 0;

	mov	r9d, r10d
	mov	r13, QWORD PTR value$[rbp-104]
	jmp	SHORT $LN24@strtotb
$LN22@strtotb:

; 411  :             } else if( U96ISNOTZERO(value) ) {

	cmp	DWORD PTR value$[rbp-104], r10d
	jne	SHORT $LN25@strtotb
	mov	rax, r13
	shr	rax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN25@strtotb
	test	edx, edx
	je	SHORT $LN24@strtotb

; 412  :                 exp1++;

	jmp	SHORT $LN25@strtotb
$LN113@strtotb:

; 405  :                 overflow = 1;

	mov	r15d, 1
$LN120@strtotb:

; 406  :                 exponent_tmp++;

	inc	esi
$LN25@strtotb:

; 407  :                 exp1++;

	inc	r9d
$LN24@strtotb:

; 392  :     }
; 393  :     memset( &value, 0, sizeof( value ) );
; 394  :     memset( &value_tmp, 0, sizeof( value_tmp ) );
; 395  :     //exponent = 0;
; 396  :     exp1 = 0;
; 397  :     exponent_tmp = 0;
; 398  :     overflow = 0;
; 399  :     while ( (unsigned int)(*p - '0') < 10u ) {

	movsx	r8d, BYTE PTR [rbx+1]

; 413  :             }
; 414  :         }
; 415  :         p++;

	inc	rbx
	mov	eax, r8d
	lea	r14d, DWORD PTR [r8-48]
	cmp	r14d, 10
	jb	$LL6@strtotb

; 409  :                 memcpy( &value, &value_tmp, sizeof( value ) );

	mov	DWORD PTR value$[rbp-96], edx
$LN7@strtotb:

; 416  :     }
; 417  :     exponent = exp1;
; 418  :     if ( *p == '.' ) {

	cmp	BYTE PTR [rbx], 46			; 0000002eH
	mov	r13, QWORD PTR [rsp+80]
	jne	$LN9@strtotb

; 419  :         p++;
; 420  :         while ( (unsigned int)(*p - '0') < 10u ) {

	movsx	r14d, BYTE PTR [rbx+1]
	inc	rbx
	mov	eax, r14d
	lea	edx, DWORD PTR [r14-48]
	cmp	edx, 10
	jae	$LN9@strtotb
	mov	r10d, 1
$LL8@strtotb:

; 421  :             if( overflow == 0 ) {

	test	r15d, r15d
	jne	SHORT $LN30@strtotb

; 422  :                 if( add_check_u96_overflow( &value_tmp, *p - '0' ) ) {

	cmp	r11d, 429496729				; 19999999H
	ja	SHORT $LN115@strtotb
	jb	SHORT $LN65@strtotb
	cmp	edi, -1717986919			; 99999999H
	ja	SHORT $LN115@strtotb
	jb	SHORT $LN65@strtotb
	cmp	r12d, -1717986919			; 99999999H
	jae	SHORT $LN115@strtotb
$LN65@strtotb:
	mov	eax, r12d

; 424  :                 } else {
; 425  :                     exponent_tmp--;

	dec	esi
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	eax, edi
	lea	rdx, QWORD PTR [rdx+rcx*2]
	mov	r12d, edx
	mov	DWORD PTR value_tmp$[rbp-104], edx
	shr	rdx, 32					; 00000020H
	lea	rcx, QWORD PTR [rax+rax*4]
	lea	eax, DWORD PTR [r11+r11*4]
	add	eax, eax
	lea	r8, QWORD PTR [rdx+rcx*2]
	mov	edi, r8d
	mov	DWORD PTR value_tmp$[rbp-100], r8d
	shr	r8, 32					; 00000020H
	add	r8d, eax
	mov	r11d, r8d

; 426  :                     if( *p != '0' ) {

	cmp	r14b, 48				; 00000030H
	je	SHORT $LN30@strtotb

; 427  :                         memcpy( &value, &value_tmp, sizeof( value ) );

	movsd	xmm0, QWORD PTR value_tmp$[rbp-104]

; 428  :                         exponent = exponent_tmp;

	mov	r9d, esi
	movsd	QWORD PTR value$[rbp-104], xmm0
	mov	DWORD PTR value$[rbp-96], r8d
	jmp	SHORT $LN30@strtotb
$LN115@strtotb:

; 423  :                     overflow = 1;

	mov	r15d, r10d
$LN30@strtotb:

; 419  :         p++;
; 420  :         while ( (unsigned int)(*p - '0') < 10u ) {

	movsx	r14d, BYTE PTR [rbx+1]

; 429  :                     }
; 430  :                 }
; 431  :             }
; 432  :             p++;

	inc	rbx
	mov	eax, r14d
	lea	edx, DWORD PTR [r14-48]
	cmp	edx, 10
	jb	$LL8@strtotb
	xor	r10d, r10d
$LN9@strtotb:

; 433  :         }
; 434  :     }
; 435  :     exp_value   = 0;
; 436  :     if ( (*p | 0x20) == 'e' ) {

	movzx	eax, BYTE PTR [rbx]
	mov	r15, QWORD PTR [rsp+64]
	or	al, 32					; 00000020H
	mov	r14, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+152]
	cmp	al, 101					; 00000065H
	jne	$LN37@strtotb

; 437  :         switch ( *++p ) {

	movzx	eax, BYTE PTR [rbx+1]
	inc	rbx
	cmp	al, 43					; 0000002bH
	je	SHORT $LN33@strtotb
	cmp	al, 45					; 0000002dH
	je	SHORT $LN32@strtotb
	sub	al, 48					; 00000030H
	cmp	al, 9
	jbe	SHORT $LN87@strtotb

; 441  :             break;
; 442  :         case '0':
; 443  :         case '1':
; 444  :         case '2':
; 445  :         case '3':
; 446  :         case '4':
; 447  :         case '5':
; 448  :         case '6':
; 449  :         case '7':
; 450  :         case '8':
; 451  :         case '9':
; 452  :             break;
; 453  :         default :
; 454  :             ld->m = 0;
; 455  :             ld->e = 0;
; 456  :             SET_SIGN( ld, sign );

	cmp	DWORD PTR sign$1$[rbp-104], 0
	mov	rcx, QWORD PTR ld$[rbp-104]
	mov	QWORD PTR [rcx], r10
	mov	WORD PTR [rcx+8], r10w
	jge	SHORT $LN36@strtotb
	mov	eax, 32768				; 00008000H
	mov	WORD PTR [rcx+8], ax
$LN36@strtotb:

; 457  :             return( ld );

	mov	rax, rcx

; 468  : }

	add	rsp, 104				; 00000068H
	pop	rbx
	pop	rbp
	ret	0
$LN32@strtotb:

; 438  :         case '-':
; 439  :             exp_sign = -1;

	mov	DWORD PTR exp_sign$1$[rbp-104], -1
$LN33@strtotb:

; 440  :         case '+': p++;

	inc	rbx
$LN87@strtotb:

; 458  :         }
; 459  :         while ( (unsigned int)(*p - '0') < 10u )

	movsx	ecx, BYTE PTR [rbx]
	lea	eax, DWORD PTR [rcx-48]
	cmp	eax, 10
	jae	SHORT $LN13@strtotb
	npad	3
$LL12@strtotb:

; 460  :             exp_value = 10 * exp_value + (*p++ - '0');

	lea	eax, DWORD PTR [r10-6]
	lea	eax, DWORD PTR [r10+rax*4]
	lea	r10d, DWORD PTR [rcx+rax*2]
	movsx	ecx, BYTE PTR [rbx+1]
	lea	rbx, QWORD PTR [rbx+1]
	lea	eax, DWORD PTR [rcx-48]
	cmp	eax, 10
	jb	SHORT $LL12@strtotb
$LN13@strtotb:

; 461  :         if( exp_sign < 0 )

	cmp	DWORD PTR exp_sign$1$[rbp-104], 0
	jge	SHORT $LN37@strtotb

; 462  :             exp_value = -exp_value;

	neg	r10d
$LN37@strtotb:

; 463  :     }
; 464  :     exp_value += exponent;
; 465  :     TB_create( &value, exp_value, ld );

	mov	rbx, QWORD PTR ld$[rbp-104]
	lea	edx, DWORD PTR [r10+r9]
	mov	r8, rbx
	lea	rcx, QWORD PTR value$[rbp-104]
	call	TB_create

; 466  :     SET_SIGN( ld, sign );

	cmp	DWORD PTR sign$1$[rbp-104], 0
	jge	SHORT $LN38@strtotb
	mov	eax, 32768				; 00008000H
	or	WORD PTR [rbx+8], ax
$LN38@strtotb:

; 467  :     return( ld );

	mov	rax, rbx

; 468  : }

	add	rsp, 104				; 00000068H
	pop	rbx
	pop	rbp
	ret	0
strtotb	ENDP
_TEXT	ENDS
END
