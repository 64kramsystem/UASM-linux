; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	SymTables:BYTE:060H
COMM	SegOverride:QWORD
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG12292 DB	'BYTE', 00H
	ORG $+3
$SG12360 DB	'WORD', 00H
	ORG $+3
$SG12367 DB	'DWORD', 00H
	ORG $+2
$SG12371 DB	'BYTE', 00H
	ORG $+3
$SG12388 DB	'BYTE', 00H
	ORG $+3
$SG12391 DB	'WORD', 00H
	ORG $+3
$SG12395 DB	'DWORD', 00H
_DATA	ENDS
PUBLIC	SizeFromMemtype
PUBLIC	MemtypeFromSize
PUBLIC	SizeFromRegister
PUBLIC	GetLangType
PUBLIC	sym_add_table
PUBLIC	sym_remove_table
PUBLIC	sym_ext2int
PUBLIC	OperandSize
PUBLIC	set_frame
PUBLIC	set_frame2
PUBLIC	ParseLine
PUBLIC	ProcessFile
PUBLIC	segm_override
PUBLIC	idata_fixup
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	SymFind:PROC
EXTRN	WritePreprocessedLine:PROC
EXTRN	PreprocessLine:PROC
EXTRN	GetResWName:PROC
EXTRN	codegen:PROC
EXTRN	EvalOperand:PROC
EXTRN	EmitConstError:PROC
EXTRN	CreateFixup:PROC
EXTRN	SetFixupFrame:PROC
EXTRN	CreateLabel:PROC
EXTRN	GetSymOfssize:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	GetAssume:PROC
EXTRN	GetOverrideAssume:PROC
EXTRN	RetInstr:PROC
EXTRN	write_prologue:PROC
EXTRN	GetTextLine:PROC
EXTRN	LstWrite:PROC
EXTRN	LstWriteSrcLine:PROC
EXTRN	data_dir:PROC
EXTRN	StoreLine:PROC
EXTRN	omf_OutSelect:PROC
EXTRN	AddPublicData:PROC
EXTRN	atofloat:PROC
EXTRN	process_branch:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	InstrTable:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	optable_idx:BYTE
EXTRN	CurrStruct:QWORD
EXTRN	SegAssumeTable:BYTE
EXTRN	StdAssumeTable:BYTE
EXTRN	CurrProc:QWORD
EXTRN	StoreState:BYTE
EXTRN	UseSavedState:BYTE
EXTRN	directive_tab:BYTE
EXTRN	ProcStatus:DWORD
EXTRN	maxintvalues:BYTE
EXTRN	minintvalues:BYTE
EXTRN	opnd_clstab:BYTE
EXTRN	vex_flags:BYTE
EXTRN	Frame_Type:BYTE
EXTRN	Frame_Datum:WORD
EXTRN	__ImageBase:BYTE
_BSS	SEGMENT
LastRegOverride DD 01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$sym_ext2int DD imagerel $LN13
	DD	imagerel $LN13+139
	DD	imagerel $unwind$sym_ext2int
$pdata$ParseLine DD imagerel $LN331
	DD	imagerel $LN331+247
	DD	imagerel $unwind$ParseLine
$pdata$0$ParseLine DD imagerel $LN331+247
	DD	imagerel $LN331+1558
	DD	imagerel $chain$0$ParseLine
$pdata$3$ParseLine DD imagerel $LN331+1558
	DD	imagerel $LN331+4298
	DD	imagerel $chain$3$ParseLine
$pdata$4$ParseLine DD imagerel $LN331+4298
	DD	imagerel $LN331+4319
	DD	imagerel $chain$4$ParseLine
$pdata$ProcessFile DD imagerel $LN12
	DD	imagerel $LN12+107
	DD	imagerel $unwind$ProcessFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_assume DD imagerel check_assume
	DD	imagerel check_assume+47
	DD	imagerel $unwind$check_assume
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$check_assume DD imagerel check_assume+47
	DD	imagerel check_assume+143
	DD	imagerel $chain$0$check_assume
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$check_assume DD imagerel check_assume+143
	DD	imagerel check_assume+159
	DD	imagerel $chain$1$check_assume
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$seg_override DD imagerel seg_override
	DD	imagerel seg_override+91
	DD	imagerel $unwind$seg_override
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$seg_override DD imagerel seg_override+91
	DD	imagerel seg_override+309
	DD	imagerel $chain$0$seg_override
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$seg_override DD imagerel seg_override+309
	DD	imagerel seg_override+332
	DD	imagerel $chain$1$seg_override
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_rm_sib DD imagerel set_rm_sib
	DD	imagerel set_rm_sib+1116
	DD	imagerel $unwind$set_rm_sib
pdata	ENDS
pdata	SEGMENT
$pdata$segm_override DD imagerel $LN13
	DD	imagerel $LN13+210
	DD	imagerel $unwind$segm_override
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$idata_nofixup DD imagerel idata_nofixup
	DD	imagerel idata_nofixup+47
	DD	imagerel $unwind$idata_nofixup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$idata_nofixup DD imagerel idata_nofixup+47
	DD	imagerel idata_nofixup+92
	DD	imagerel $chain$1$idata_nofixup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$idata_nofixup DD imagerel idata_nofixup+92
	DD	imagerel idata_nofixup+221
	DD	imagerel $chain$2$idata_nofixup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$idata_nofixup DD imagerel idata_nofixup+221
	DD	imagerel idata_nofixup+304
	DD	imagerel $chain$4$idata_nofixup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$idata_nofixup DD imagerel idata_nofixup+304
	DD	imagerel idata_nofixup+309
	DD	imagerel $chain$5$idata_nofixup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$idata_nofixup DD imagerel idata_nofixup+309
	DD	imagerel idata_nofixup+328
	DD	imagerel $chain$6$idata_nofixup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$idata_nofixup DD imagerel idata_nofixup+328
	DD	imagerel idata_nofixup+527
	DD	imagerel $chain$8$idata_nofixup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$idata_nofixup DD imagerel idata_nofixup+527
	DD	imagerel idata_nofixup+540
	DD	imagerel $chain$9$idata_nofixup
pdata	ENDS
pdata	SEGMENT
$pdata$idata_fixup DD imagerel $LN158
	DD	imagerel $LN158+55
	DD	imagerel $unwind$idata_fixup
$pdata$2$idata_fixup DD imagerel $LN158+55
	DD	imagerel $LN158+173
	DD	imagerel $chain$2$idata_fixup
$pdata$4$idata_fixup DD imagerel $LN158+173
	DD	imagerel $LN158+1650
	DD	imagerel $chain$4$idata_fixup
$pdata$5$idata_fixup DD imagerel $LN158+1650
	DD	imagerel $LN158+1676
	DD	imagerel $chain$5$idata_fixup
$pdata$7$idata_fixup DD imagerel $LN158+1676
	DD	imagerel $LN158+1934
	DD	imagerel $chain$7$idata_fixup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetPtrMemtype DD imagerel SetPtrMemtype
	DD	imagerel SetPtrMemtype+172
	DD	imagerel $unwind$SetPtrMemtype
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$SetPtrMemtype DD imagerel SetPtrMemtype+172
	DD	imagerel SetPtrMemtype+233
	DD	imagerel $chain$0$SetPtrMemtype
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$SetPtrMemtype DD imagerel SetPtrMemtype+233
	DD	imagerel SetPtrMemtype+410
	DD	imagerel $chain$1$SetPtrMemtype
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_operand DD imagerel memory_operand
	DD	imagerel memory_operand+332
	DD	imagerel $unwind$memory_operand
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$memory_operand DD imagerel memory_operand+332
	DD	imagerel memory_operand+1688
	DD	imagerel $chain$1$memory_operand
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$process_address DD imagerel process_address
	DD	imagerel process_address+598
	DD	imagerel $unwind$process_address
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$process_register DD imagerel process_register
	DD	imagerel process_register+739
	DD	imagerel $unwind$process_register
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HandleStringInstructions DD imagerel HandleStringInstructions
	DD	imagerel HandleStringInstructions+788
	DD	imagerel $unwind$HandleStringInstructions
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_size DD imagerel check_size
	DD	imagerel check_size+2420
	DD	imagerel $unwind$check_size
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsType DD imagerel IsType
	DD	imagerel IsType+27
	DD	imagerel $unwind$IsType
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsType DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_size DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HandleStringInstructions DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$process_register DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$process_address DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$memory_operand DD 040d21H
	DD	06f40dH
	DD	010e408H
	DD	imagerel memory_operand
	DD	imagerel memory_operand+332
	DD	imagerel $unwind$memory_operand
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_operand DD 071501H
	DD	0d0116215H
	DD	0700dc00fH
	DD	0500b600cH
	DD	0300aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$SetPtrMemtype DD 021H
	DD	imagerel SetPtrMemtype
	DD	imagerel SetPtrMemtype+172
	DD	imagerel $unwind$SetPtrMemtype
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$SetPtrMemtype DD 020521H
	DD	063405H
	DD	imagerel SetPtrMemtype
	DD	imagerel SetPtrMemtype+172
	DD	imagerel $unwind$SetPtrMemtype
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetPtrMemtype DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$idata_nofixup DD 060021H
	DD	04f400H
	DD	0b6400H
	DD	0a5400H
	DD	imagerel idata_nofixup
	DD	imagerel idata_nofixup+47
	DD	imagerel $unwind$idata_nofixup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$idata_nofixup DD 0a0021H
	DD	04f400H
	DD	05d400H
	DD	0cc400H
	DD	0b6400H
	DD	0a5400H
	DD	imagerel idata_nofixup
	DD	imagerel idata_nofixup+47
	DD	imagerel $unwind$idata_nofixup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$idata_nofixup DD 021H
	DD	imagerel idata_nofixup+47
	DD	imagerel idata_nofixup+92
	DD	imagerel $chain$1$idata_nofixup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$idata_nofixup DD 021H
	DD	imagerel idata_nofixup+92
	DD	imagerel idata_nofixup+221
	DD	imagerel $chain$2$idata_nofixup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$idata_nofixup DD 041021H
	DD	05d410H
	DD	0cc405H
	DD	imagerel idata_nofixup+92
	DD	imagerel idata_nofixup+221
	DD	imagerel $chain$2$idata_nofixup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$idata_nofixup DD 020521H
	DD	0a5405H
	DD	imagerel idata_nofixup+47
	DD	imagerel idata_nofixup+92
	DD	imagerel $chain$1$idata_nofixup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$idata_nofixup DD 041121H
	DD	04f411H
	DD	0b6405H
	DD	imagerel idata_nofixup
	DD	imagerel idata_nofixup+47
	DD	imagerel $unwind$idata_nofixup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$idata_nofixup DD 040901H
	DD	0e0055209H
	DD	030027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_rm_sib DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$seg_override DD 021H
	DD	imagerel seg_override
	DD	imagerel seg_override+91
	DD	imagerel $unwind$seg_override
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$seg_override DD 020521H
	DD	066405H
	DD	imagerel seg_override
	DD	imagerel seg_override+91
	DD	imagerel $unwind$seg_override
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$seg_override DD 060f01H
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$check_assume DD 021H
	DD	imagerel check_assume
	DD	imagerel check_assume+47
	DD	imagerel $unwind$check_assume
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$check_assume DD 020521H
	DD	065405H
	DD	imagerel check_assume
	DD	imagerel check_assume+47
	DD	imagerel $unwind$check_assume
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_assume DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
xdata	SEGMENT
$unwind$sym_ext2int DD 020601H
	DD	030023206H
$unwind$ParseLine DD 061501H
	DD	0510115H
	DD	06004e006H
	DD	050023003H
$chain$0$ParseLine DD 020821H
	DD	0507408H
	DD	imagerel $LN331
	DD	imagerel $LN331+247
	DD	imagerel $unwind$ParseLine
$chain$3$ParseLine DD 061821H
	DD	04df418H
	DD	04ed410H
	DD	04fc408H
	DD	imagerel $LN331+247
	DD	imagerel $LN331+1558
	DD	imagerel $chain$0$ParseLine
$chain$4$ParseLine DD 021H
	DD	imagerel $LN331+247
	DD	imagerel $LN331+1558
	DD	imagerel $chain$0$ParseLine
$unwind$ProcessFile DD 020601H
	DD	030023206H
$unwind$segm_override DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$idata_fixup DD 040901H
	DD	0c0055209H
	DD	030027003H
$chain$2$idata_fixup DD 061a21H
	DD	05e41aH
	DD	0dd40eH
	DD	0c6405H
	DD	imagerel $LN158
	DD	imagerel $LN158+55
	DD	imagerel $unwind$idata_fixup
$chain$4$idata_fixup DD 040a21H
	DD	04f40aH
	DD	0b5405H
	DD	imagerel $LN158+55
	DD	imagerel $LN158+173
	DD	imagerel $chain$2$idata_fixup
$chain$5$idata_fixup DD 021H
	DD	imagerel $LN158+55
	DD	imagerel $LN158+173
	DD	imagerel $chain$2$idata_fixup
$chain$7$idata_fixup DD 0a0021H
	DD	04f400H
	DD	05e400H
	DD	0dd400H
	DD	0c6400H
	DD	0b5400H
	DD	imagerel $LN158
	DD	imagerel $LN158+55
	DD	imagerel $unwind$idata_fixup
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
;	COMDAT IsType
_TEXT	SEGMENT
name$ = 48
IsType	PROC						; COMDAT

; 2855 : {

	sub	rsp, 40					; 00000028H

; 2856 :     struct asym *sym;
; 2857 : 
; 2858 :     sym = SymSearch( name );

	call	SymFind

; 2859 :     if ( sym && (sym->state == SYM_TYPE ) )

	test	rax, rax
	je	SHORT $LN2@IsType
	cmp	DWORD PTR [rax+32], 7
	je	SHORT $LN1@IsType
$LN2@IsType:

; 2860 :         return( sym );
; 2861 :     return( NULL );

	xor	eax, eax
$LN1@IsType:

; 2862 : }

	add	rsp, 40					; 00000028H
	ret	0
IsType	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
;	COMDAT check_size
_TEXT	SEGMENT
CodeInfo$ = 80
opndx$ = 88
check_size PROC						; COMDAT

; 2335 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2336 :     enum operand_type op1 = CodeInfo->opnd[OPND1].type;

	mov	ebp, DWORD PTR [rcx+32]
	mov	rbx, rcx

; 2337 :     enum operand_type op2 = CodeInfo->opnd[OPND2].type;

	mov	edi, DWORD PTR [rcx+56]

; 2338 :     ret_code    rc = NOT_ERROR;

	xor	r14d, r14d

; 2339 :     int         op1_size;
; 2340 :     int         op2_size;
; 2341 :     //int         op_size = 0;
; 2342 :     DebugMsg1(("check_size enter, optype1=%" I32_SPEC "X, optype2=%" I32_SPEC "X\n", op1, op2 ));
; 2343 :     if (CodeInfo->token >= T_KADDB && CodeInfo->token <= T_KUNPCKDQ){

	mov	ecx, DWORD PTR [rcx+24]
	mov	r13, rdx
	mov	r12d, 262144				; 00040000H
	lea	eax, DWORD PTR [rcx-1686]
	cmp	eax, 26
	ja	SHORT $LN12@check_size

; 2344 :       //int op3_size;
; 2345 :       if ((CodeInfo->opnd[OPND1].type != OP_K) && (CodeInfo->opnd[OPND2].type != OP_K) &&

	cmp	ebp, 64					; 00000040H
	je	SHORT $LN13@check_size
	cmp	edi, 64					; 00000040H
	je	SHORT $LN13@check_size
	cmp	DWORD PTR [rbx+80], 64			; 00000040H
	je	SHORT $LN13@check_size

; 2346 :         (CodeInfo->opnd[OPND3].type != OP_K))
; 2347 :         return(EmitError(INVALID_INSTRUCTION_OPERANDS));

	lea	ecx, QWORD PTR [r14+49]
	call	EmitError
	jmp	$LN1@check_size
$LN13@check_size:

; 2348 :       CodeInfo->indextype = OP_K;

	mov	DWORD PTR [rbx+132], 64			; 00000040H

; 2349 :       CodeInfo->basetype = OP_K;

	mov	BYTE PTR [rbx+108], 64			; 00000040H

; 2350 : 
; 2351 :       op1_size = CodeInfo->pinstr->prefix;
; 2352 :       op2_size = CodeInfo->pinstr->prefix;
; 2353 :       goto def_check;

	jmp	$def_check$171
$LN12@check_size:

; 2354 :     }
; 2355 : 
; 2356 :     switch( CodeInfo->token ) {

	cmp	ecx, 1024				; 00000400H
	jg	$LN140@check_size
	cmp	ecx, 1023				; 000003ffH
	jge	$LN131@check_size
	sub	ecx, 512				; 00000200H
	cmp	ecx, 131				; 00000083H
	ja	$def_check$171
	movsxd	rax, ecx
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN161@check_size[rdx+rax]
	mov	ecx, DWORD PTR $LN162@check_size[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN14@check_size:

; 2357 :     case T_IN:
; 2358 :         if( op2 == OP_DX ) {

	cmp	edi, 2050				; 00000802H
	jne	$LN131@check_size

; 2359 :             /* wide and size is NOT determined by DX, but
; 2360 :              * by the first operand, AL|AX|EAX
; 2361 :              */
; 2362 :             switch( op1 ) {

	sub	ebp, 513				; 00000201H
	je	SHORT $LN23@check_size
	cmp	ebp, 3
	je	SHORT $LN24@check_size
	jmp	$LN131@check_size
$LN20@check_size:

; 2363 :             case OP_AX:
; 2364 :                 break;
; 2365 :             case OP_AL:
; 2366 :                 CodeInfo->iswide = 0;         /* clear w-bit */
; 2367 :             case OP_EAX:
; 2368 :                 if( CodeInfo->Ofssize ) {
; 2369 :                     CodeInfo->prefix.opsiz = FALSE;
; 2370 :                 }
; 2371 :                 break;
; 2372 :             }
; 2373 :         }
; 2374 :         break;
; 2375 :     case T_OUT:
; 2376 :         if( op1 == OP_DX ) {

	cmp	ebp, 2050				; 00000802H
	jne	$LN131@check_size

; 2377 :             switch( op2 ) {

	sub	edi, 513				; 00000201H
	je	SHORT $LN23@check_size
	cmp	edi, 3
	je	SHORT $LN24@check_size
	jmp	$LN131@check_size
$LN23@check_size:

; 2378 :             case OP_AX:
; 2379 :                 break;
; 2380 :             case OP_AL:
; 2381 :                 CodeInfo->iswide = 0;         /* clear w-bit */

	and	BYTE PTR [rbx+142], 254			; 000000feH
$LN24@check_size:

; 2382 :             case OP_EAX:
; 2383 :                 if( CodeInfo->Ofssize ) {

	cmp	BYTE PTR [rbx+106], r14b
	je	$LN131@check_size

; 2384 :                     CodeInfo->prefix.opsiz = FALSE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH

; 2385 :                 }
; 2386 :             }
; 2387 :         }
; 2388 :         break;

	jmp	$LN131@check_size
$LN27@check_size:

; 2389 :     case T_LEA:
; 2390 : #if 0
; 2391 :         /* first op must be 16/32 register, but this condition is checked
; 2392 :          in CodeGen. operands 1 and 2 can be mixed:
; 2393 :          lea cx,[bp]
; 2394 :          lea cx,[ebp]
; 2395 :          lea ecx,[bp]
; 2396 :          lea ecx,[ebp]
; 2397 :          are all valid. However, Masm sometimes complains
; 2398 :          "cannot use 16-bit register with a 32-bit address"
; 2399 :          */
; 2400 :         switch( OperandSize( op1, CodeInfo ) ) {
; 2401 :         case 2:
; 2402 :         case 4:
; 2403 :             break;
; 2404 :         default:
; 2405 :             EmitErr( OPERANDS_MUST_BE_THE_SAME_SIZE, OperandSize( op1, CodeInfo ), ModuleInfo.Ofssize ? 4 : 2);
; 2406 :             rc = ERROR;
; 2407 :         }
; 2408 : #endif
; 2409 :         break;
; 2410 :     case T_RCL:
; 2411 :     case T_RCR:
; 2412 :     case T_ROL:
; 2413 :     case T_ROR:
; 2414 :     case T_SAL:
; 2415 :     case T_SAR:
; 2416 :     case T_SHL:
; 2417 :     case T_SHR:
; 2418 :         /* v2.11: added */
; 2419 :         if ( CodeInfo->opnd[OPND1].type == OP_M && CodeInfo->undef_sym == FALSE &&

	cmp	ebp, -1887436800			; ffffffff8f800000H
	jne	SHORT $LN28@check_size
	test	BYTE PTR [rbx+142], 64			; 00000040H
	jne	SHORT $LN28@check_size
	mov	rax, QWORD PTR [r13+80]
	test	rax, rax
	je	SHORT $LN29@check_size
	cmp	DWORD PTR [rax+32], r14d
	je	SHORT $LN28@check_size
$LN29@check_size:

; 2420 :             ( opndx[OPND1].sym == NULL || opndx[OPND1].sym->state != SYM_UNDEFINED ) ) {
; 2421 :             EmitErr( INSTRUCTION_OPERAND_MUST_HAVE_SIZE );

	mov	ecx, 182				; 000000b6H
	call	EmitErr

; 2422 :             rc = ERROR;

	or	r14d, -1

; 2423 :             break;

	jmp	$LN131@check_size
$LN28@check_size:

; 2424 :         }
; 2425 :         //if ( CodeInfo->opnd[OPND1].type == OP_M && Parse_Pass == PASS_2 )
; 2426 :         //    EmitWarn( 2, SIZE_NOT_SPECIFIED_ASSUMING, "BYTE" );
; 2427 : 
; 2428 :         /* v2.0: if second argument is a forward reference,
; 2429 :          * change type to "immediate 1"
; 2430 :          */
; 2431 :         if ( opndx[OPND2].kind == EXPR_ADDR &&
; 2432 :             Parse_Pass == PASS_1 &&
; 2433 :             opndx[OPND2].indirect == FALSE &&
; 2434 :             opndx[OPND2].sym &&

	cmp	DWORD PTR [r13+164], 1
	jne	SHORT $LN30@check_size
	cmp	DWORD PTR Parse_Pass, r14d
	jne	SHORT $LN30@check_size
	test	BYTE PTR [r13+176], 1
	jne	SHORT $LN30@check_size
	mov	rax, QWORD PTR [r13+184]
	test	rax, rax
	je	SHORT $LN30@check_size
	cmp	DWORD PTR [rax+32], r14d
	jne	SHORT $LN30@check_size

; 2435 :             opndx[OPND2].sym->state == SYM_UNDEFINED ) {
; 2436 :             CodeInfo->opnd[OPND2].type = OP_I8;

	mov	eax, 131072				; 00020000H

; 2437 :             CodeInfo->opnd[OPND2].data32l = 1;

	mov	DWORD PTR [rbx+64], 1
	mov	DWORD PTR [rbx+56], eax
$LN30@check_size:

; 2438 :         }
; 2439 :         /* v2.06: added (because if first operand is memory, wide bit
; 2440 :          * isn't set!)
; 2441 :          */
; 2442 :         if ( OperandSize( op1, CodeInfo ) > 1 )

	mov	rdx, rbx
	mov	ecx, ebp
	call	OperandSize
	cmp	eax, 1
	jle	SHORT $LN31@check_size

; 2443 :             CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1
$LN31@check_size:

; 2444 :         /* v2.06: makes the OP_CL_ONLY case in codegen.c obsolete */
; 2445 :         if ( op2 == OP_CL ) {

	cmp	edi, 1025				; 00000401H
	jne	$LN131@check_size

; 2446 :             /* CL is encoded in bit 345 of rm_byte, but we don't need it
; 2447 :              * so clear it here */
; 2448 :             CodeInfo->rm_byte &= NOT_BIT_345;

	and	BYTE PTR [rbx+104], 199			; 000000c7H

; 2449 :         }
; 2450 :         break;

	jmp	$LN131@check_size
$LN33@check_size:

; 2457 :         op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, rbx
	mov	ecx, edi
	call	OperandSize
	mov	edi, eax

; 2458 :         if ( op2_size != 0 && op1_size != op2_size ) {

	test	eax, eax
	je	$LN131@check_size

; 2451 :     case T_LDS:
; 2452 :     case T_LES:
; 2453 :     case T_LFS:
; 2454 :     case T_LGS:
; 2455 :     case T_LSS:
; 2456 :         op1_size = OperandSize( op1, CodeInfo ) + 2; /* add 2 for the impl. segment register */

	mov	rdx, rbx
	mov	ecx, ebp
	call	OperandSize
	add	eax, 2

; 2458 :         if ( op2_size != 0 && op1_size != op2_size ) {

	cmp	eax, edi
	je	$LN131@check_size
$LN169@check_size:

; 2459 :             return( EmitError( INVALID_OPERAND_SIZE ) );

	mov	ecx, 71					; 00000047H
	call	EmitError
	jmp	$LN1@check_size
$LN36@check_size:

; 2460 :         }
; 2461 :         break;
; 2462 :     case T_ENTER:
; 2463 : #if 0 /* v2.11: operand sizes are checked in codegen */
; 2464 :         /* ENTER has to be OP_I16, OP_I8_U */
; 2465 :         if( op1 == OP_I32 ) {
; 2466 :             /* parse_phase_1 will treat 16-bit data as OP_I32 if CPU is 386 */
; 2467 :             if( CodeInfo->opnd[OPND1].data32l > (int_32)USHRT_MAX ) {
; 2468 :                 /* if op1 is really 32-bit data, then error */
; 2469 :                 EmitError( INVALID_OPERAND_SIZE );
; 2470 :                 rc = ERROR;
; 2471 :             }
; 2472 :         }
; 2473 :         /* type cast op1 to OP_I16 */
; 2474 :         CodeInfo->opnd[OPND1].type = OP_I16;
; 2475 :         /* op2 have to be 8-bit data */
; 2476 :         if( op2 >= OP_I16 ) {
; 2477 :             if( CodeInfo->opnd[OPND2].data32l > UCHAR_MAX ) {
; 2478 :                 EmitError( INVALID_OPERAND_SIZE );
; 2479 :                 rc = ERROR;
; 2480 :             }
; 2481 :             CodeInfo->opnd[OPND2].type = OP_I8;
; 2482 :         }
; 2483 : #endif
; 2484 :         break;
; 2485 :     case T_MOVSX:
; 2486 :     case T_MOVZX:
; 2487 :         CodeInfo->iswide = 0;

	and	BYTE PTR [rbx+142], 254			; 000000feH

; 2488 :         op1_size = OperandSize( op1, CodeInfo );

	mov	rdx, rbx
	mov	ecx, ebp
	call	OperandSize

; 2489 :         op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, rbx
	mov	ecx, edi
	mov	esi, eax
	call	OperandSize
	mov	edi, eax

; 2490 :         DebugMsg1(("check_size, MOVZX/MOVSX: op2_size=%u, opndx.memtype=%Xh, opndx.sym=%X\n", op2_size, opndx[OPND2].mem_type, opndx[OPND2].sym ));
; 2491 :         if ( op2_size == 0 && Parse_Pass == PASS_2 )

	test	eax, eax
	jne	SHORT $LN39@check_size
	cmp	DWORD PTR Parse_Pass, 1
	jne	SHORT $LN39@check_size

; 2492 :             if ( op1_size == 2 ) {

	cmp	esi, 2
	jne	SHORT $LN38@check_size

; 2493 :                 EmitWarn( 2, SIZE_NOT_SPECIFIED_ASSUMING, "BYTE" );

	lea	r8, OFFSET FLAT:$SG12292
	mov	ecx, esi
	lea	edx, QWORD PTR [rax+73]
	call	EmitWarn

; 2494 :             } else

	jmp	SHORT $LN46@check_size
$LN38@check_size:

; 2495 :                 EmitErr( INSTRUCTION_OPERAND_MUST_HAVE_SIZE );

	mov	ecx, 182				; 000000b6H
	call	EmitErr
$LN39@check_size:

; 2496 :         switch( op1_size ) {

	cmp	esi, 2
	je	SHORT $LN45@check_size
	lea	eax, DWORD PTR [rsi-4]
	test	eax, -5					; fffffffbH
	je	SHORT $LN40@check_size

; 2519 :             break;
; 2520 :         default:
; 2521 :             /* op1 must be r16/r32/r64 */
; 2522 :             EmitError( OP1_TOO_SMALL );

	mov	ecx, 60					; 0000003cH
	call	EmitError

; 2523 :             rc = ERROR;

	or	r14d, -1
	jmp	$LN131@check_size
$LN40@check_size:

; 2497 : #if AMD64_SUPPORT
; 2498 :         case 8:
; 2499 :             //if ( CodeInfo->Ofssize == USE64 )
; 2500 :             //    break;
; 2501 : #endif
; 2502 :         case 4:
; 2503 :             if (op2_size < 2)

	cmp	edi, 2
	jl	SHORT $LN44@check_size

; 2504 :                 ;
; 2505 :             else if (op2_size == 2)

	jne	SHORT $LN43@check_size

; 2506 :                 CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1
	jmp	SHORT $LN44@check_size
$LN43@check_size:

; 2507 :             else {
; 2508 :                 EmitError( OP2_TOO_BIG );

	mov	ecx, 59					; 0000003bH
	call	EmitError

; 2509 :                 rc = ERROR;

	or	r14d, -1
$LN44@check_size:

; 2510 :             }
; 2511 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? FALSE : TRUE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], 0
	sete	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al

; 2512 :             break;

	jmp	$LN131@check_size
$LN45@check_size:

; 2513 :         case 2:
; 2514 :             if( op2_size >= 2 ) {

	cmp	edi, 2
	jl	SHORT $LN46@check_size

; 2515 :                 EmitError( OP2_TOO_BIG );

	mov	ecx, 59					; 0000003bH
	call	EmitError

; 2516 :                 rc = ERROR;

	or	r14d, -1
$LN46@check_size:

; 2517 :             }
; 2518 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? TRUE : FALSE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], 0
	setne	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al

; 2524 :         }
; 2525 :         break;

	jmp	$LN131@check_size
$LN49@check_size:

; 2526 : #if AMD64_SUPPORT
; 2527 :     case T_MOVSXD:
; 2528 :         break;
; 2529 : #endif
; 2530 :     case T_ARPL: /* v2.06: new, avoids the OP_R16 hack in codegen.c */
; 2531 :         CodeInfo->prefix.opsiz = 0;

	and	BYTE PTR [rbx+9], 253			; 000000fdH

; 2532 :         goto def_check;

	jmp	$def_check$171
$LN50@check_size:

; 2533 :         break;
; 2534 : #if AMD64_SUPPORT
; 2535 :     case T_LAR: /* v2.04: added */
; 2536 :     case T_LSL: /* 19-sep-93 */
; 2537 : #if 1 /* v2.04: changed */
; 2538 :         if ( ModuleInfo.Ofssize != USE64 || ( ( op2 & OP_M ) == 0 ) )

	cmp	BYTE PTR ModuleInfo+404, 2
	jne	$def_check$171
	test	edi, -1887436800			; ffffffff8f800000H
	je	$def_check$171

; 2539 :             goto def_check;
; 2540 :         /* in 64-bit, if second argument is memory operand,
; 2541 :          * ensure it has size WORD ( or 0 if a forward ref )
; 2542 :          */
; 2543 :         op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, rbx
	mov	ecx, edi
	call	OperandSize
	test	eax, -3					; fffffffdH

; 2544 :         if ( op2_size != 2 && op2_size != 0 ) {
; 2545 :             return( EmitError( INVALID_OPERAND_SIZE ) );

	jne	$LN169@check_size

; 2546 :         }
; 2547 :         /* the opsize prefix depends on the FIRST operand only! */
; 2548 :         op1_size = OperandSize( op1, CodeInfo );

	mov	rdx, rbx
	mov	ecx, ebp
	call	OperandSize

; 2549 :         if ( op1_size != 2 )

	cmp	eax, 2
	je	$LN131@check_size
$LN168@check_size:

; 2550 :             CodeInfo->prefix.opsiz = FALSE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH

; 2551 : #else
; 2552 :         op1_size = OperandSize( op1, CodeInfo );
; 2553 :         switch( op1_size ) {
; 2554 :         case 2:
; 2555 :             if( CodeInfo->Ofssize )
; 2556 :                 CodeInfo->prefix.opsiz = TRUE;
; 2557 :             break;
; 2558 :         case 4:
; 2559 :             if( CodeInfo->Ofssize )
; 2560 :                 CodeInfo->prefix.opsiz = FALSE;
; 2561 :             break;
; 2562 :         default:
; 2563 :             return( EmitError( INVALID_OPERAND_SIZE ) );
; 2564 :         }
; 2565 :         op2_size = OperandSize( op2, CodeInfo );
; 2566 :         switch( op2_size ) {
; 2567 :         case 2:
; 2568 :         case 4:
; 2569 :             break;
; 2570 :         default:
; 2571 :             EmitError( INVALID_OPERAND_SIZE );
; 2572 :             rc = ERROR;
; 2573 :             break;
; 2574 :         }
; 2575 : #endif
; 2576 :         break;

	jmp	$LN131@check_size
$LN55@check_size:

; 2577 : #endif
; 2578 :     case T_IMUL: /* v2.06: check for 3rd operand must be done here */
; 2579 :         if ( CodeInfo->opnd[OPND3].type != OP_NONE ) {

	mov	esi, DWORD PTR [rbx+80]
	test	esi, esi
	je	$def_check$171

; 2580 :             int op3_size;
; 2581 :             op1_size = OperandSize( op1, CodeInfo );

	mov	rdx, rbx
	mov	ecx, ebp
	call	OperandSize

; 2582 :             op3_size = OperandSize( CodeInfo->opnd[OPND3].type, CodeInfo );

	mov	rdx, rbx
	mov	ecx, esi
	mov	r15d, eax
	call	OperandSize

; 2583 :             /* the only case which must be checked here
; 2584 :              * is a WORD register as op1 and a DWORD immediate as op3 */
; 2585 :             if ( op1_size == 2 && op3_size > 2 ) {

	cmp	r15d, 2
	jne	SHORT $LN57@check_size
	cmp	eax, r15d
	jle	SHORT $LN57@check_size

; 2586 :                 EmitErr( OPERANDS_MUST_BE_THE_SAME_SIZE, op1_size, op3_size );

	mov	r8d, eax
	lea	ecx, QWORD PTR [r15+46]
	mov	edx, r15d
	call	EmitErr

; 2587 :                 rc = ERROR;

	or	r14d, -1

; 2588 :                 break;

	jmp	$LN131@check_size
$LN57@check_size:

; 2589 :             }
; 2590 :             if ( CodeInfo->opnd[OPND3].type & ( OP_I16 | OP_I32 ) )

	test	esi, 786432				; 000c0000H
	je	$def_check$171

; 2591 :                 CodeInfo->opnd[OPND3].type = ( op1_size == 2 ? OP_I16 : OP_I32 );

	cmp	r15d, 2
	mov	eax, 524288				; 00080000H
	cmove	eax, r12d
	mov	DWORD PTR [rbx+80], eax

; 2592 :         }
; 2593 :         goto def_check;

	jmp	$def_check$171
$LN73@check_size:

; 2663 :     case T_MOV:
; 2664 :         if( op1 & OP_SR ) { /* segment register as op1? */

	test	ebp, 24576				; 00006000H
	je	SHORT $LN74@check_size

; 2665 :             op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, rbx
	mov	ecx, edi
	call	OperandSize
	lea	ecx, DWORD PTR [rax-2]
	test	ecx, -3					; fffffffdH
	je	SHORT $LN77@check_size

; 2666 :             if( ( op2_size == 2 ) || ( op2_size == 4 )
; 2667 : #if AMD64_SUPPORT
; 2668 :                || ( op2_size == 8 && ModuleInfo.Ofssize == USE64 )

	cmp	eax, 8
	jne	$def_check$171
	cmp	BYTE PTR ModuleInfo+404, 2
	jne	$def_check$171
$LN77@check_size:

; 2669 : #endif
; 2670 :               ) {
; 2671 :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@check_size
$LN74@check_size:

; 2672 :             }
; 2673 :         } else if( op2 & OP_SR ) {

	test	edi, 24576				; 00006000H
	je	SHORT $LN78@check_size

; 2674 :             op1_size = OperandSize( op1, CodeInfo );

	mov	rdx, rbx
	mov	ecx, ebp
	call	OperandSize
	lea	ecx, DWORD PTR [rax-2]
	test	ecx, -3					; fffffffdH
	je	SHORT $LN77@check_size

; 2675 :             if( ( op1_size == 2 ) || ( op1_size == 4 )
; 2676 : #if AMD64_SUPPORT
; 2677 :                || ( op1_size == 8 && ModuleInfo.Ofssize == USE64 )

	cmp	eax, 8
	jne	$def_check$171
	cmp	BYTE PTR ModuleInfo+404, 2
	jne	$def_check$171

; 2678 : #endif
; 2679 :               ) {
; 2680 :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@check_size
$LN78@check_size:

; 2681 :             }
; 2682 :         } else if( ( op1 & OP_M ) && ( op2 & OP_A ) ) { /* 1. operand memory reference, 2. AL|AX|EAX|RAX? */

	test	ebp, -1887436800			; ffffffff8f800000H
	je	SHORT $LN82@check_size
	bt	edi, 9
	jae	SHORT $LN82@check_size

; 2683 : 
; 2684 :             if ( CodeInfo->isdirect == FALSE ) {

	test	BYTE PTR [rbx+142], 2
	jne	SHORT $LN84@check_size

; 2685 :                 /* address mode is indirect.
; 2686 :                  * don't use the short format (opcodes A0-A3) - it exists for direct
; 2687 :                  * addressing only. Reset OP_A flag!
; 2688 :                  */
; 2689 :                 CodeInfo->opnd[OPND2].type &= ~OP_A;

	mov	eax, edi
	btr	eax, 9
	mov	DWORD PTR [rbx+56], eax
	jmp	$def_check$171
$LN84@check_size:

; 2690 :                 DebugMsg1(("check_size: OP_A flag reset, new op2=%X\n", CodeInfo->opnd[OPND2].type ));
; 2691 : #if AMD64_SUPPORT
; 2692 :             } else if ( CodeInfo->Ofssize == USE64 && ( CodeInfo->opnd[OPND1].data64 < 0x80000000 || CodeInfo->opnd[OPND1].data64 >= 0xffffffff80000000 ) ) {

	cmp	BYTE PTR [rbx+106], 2
	jne	$def_check$171
	mov	rax, QWORD PTR [rbx+40]
	mov	ecx, -2147483648			; 80000000H
	sub	rax, rcx
	mov	rcx, -4294967297			; fffffffeffffffffH
	cmp	rax, rcx
	jbe	$def_check$171

; 2693 :                 /* for 64bit, opcodes A0-A3 ( direct memory addressing with AL/AX/EAX/RAX )
; 2694 :                  * are followed by a full 64-bit moffs. This is only used if the offset won't fit
; 2695 :                  * in a 32-bit signed value.
; 2696 :                  */
; 2697 :                 CodeInfo->opnd[OPND2].type &= ~OP_A;

	mov	eax, edi
	btr	eax, 9
	mov	DWORD PTR [rbx+56], eax

; 2698 :                 DebugMsg1(("check_size: OP_A flag reset, new op2=%X\n", CodeInfo->opnd[OPND2].type ));
; 2699 : #endif
; 2700 :             }

	jmp	$def_check$171
$LN82@check_size:

; 2701 : 
; 2702 :         } else if( ( op1 & OP_A ) && ( op2 & OP_M ) ) { /* 2. operand memory reference, 1. AL|AX|EAX|RAX? */

	bt	ebp, 9
	jae	$def_check$171
	test	edi, -1887436800			; ffffffff8f800000H
	je	$def_check$171

; 2703 : 
; 2704 :             if ( CodeInfo->isdirect == FALSE ) {

	test	BYTE PTR [rbx+142], 2
	jne	SHORT $LN89@check_size

; 2705 :                 CodeInfo->opnd[OPND1].type &= ~OP_A;

	mov	eax, ebp
	btr	eax, 9
	mov	DWORD PTR [rbx+32], eax
	jmp	$def_check$171
$LN89@check_size:

; 2706 :                 DebugMsg1(("check_size: OP_A flag reset, new op1=%X\n", CodeInfo->opnd[OPND1].type ));
; 2707 : #if AMD64_SUPPORT
; 2708 :             } else if ( CodeInfo->Ofssize == USE64 && ( CodeInfo->opnd[OPND2].data64 < 0x80000000 || CodeInfo->opnd[OPND2].data64 >= 0xffffffff80000000 ) ) {

	cmp	BYTE PTR [rbx+106], 2
	jne	$def_check$171
	mov	rax, QWORD PTR [rbx+64]
	mov	ecx, -2147483648			; 80000000H
	sub	rax, rcx
	mov	rcx, -4294967297			; fffffffeffffffffH
	cmp	rax, rcx
	jbe	$def_check$171

; 2709 :                 CodeInfo->opnd[OPND1].type &= ~OP_A;

	mov	eax, ebp
	btr	eax, 9
	mov	DWORD PTR [rbx+32], eax
	jmp	$def_check$171
$LN140@check_size:

; 2354 :     }
; 2355 : 
; 2356 :     switch( CodeInfo->token ) {

	cmp	ecx, 1333				; 00000535H
	jg	$LN141@check_size
	je	$LN64@check_size
	cmp	ecx, 1266				; 000004f2H
	jg	SHORT $LN142@check_size
	je	SHORT $LN67@check_size
	lea	eax, DWORD PTR [rcx-1031]
	cmp	eax, 1
	jbe	$LN131@check_size
	cmp	ecx, 1209				; 000004b9H
	je	$LN131@check_size
	cmp	ecx, 1045				; 00000415H
	jne	$def_check$171

; 2651 : #endif
; 2652 :     case T_MOVD:
; 2653 : #if 0
; 2654 :         op1_size = OperandSize( op1, CodeInfo );
; 2655 :         op2_size = OperandSize( op2, CodeInfo );
; 2656 :         if( ( op1_size != 0 ) && ( op1_size != 4 )
; 2657 :             || ( op2_size != 0 ) && ( op2_size != 4 ) ) {
; 2658 :             EmitErr( OPERANDS_MUST_BE_THE_SAME_SIZE, op1_size, op2_size );
; 2659 :             rc = ERROR;
; 2660 :         }
; 2661 : #endif
; 2662 :         break;

	jmp	$LN131@check_size
$LN67@check_size:

; 2637 : #endif
; 2638 : #if SSE4SUPP
; 2639 :     case T_CRC32:
; 2640 :         /* v2.02: for CRC32, the second operand determines whether an
; 2641 :          * OPSIZE prefix byte is to be written.
; 2642 :          */
; 2643 :         op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, rbx
	mov	ecx, edi
	call	OperandSize

; 2644 :         if ( op2_size < 2)

	cmp	eax, 2
	jl	$LN168@check_size

; 2645 :             CodeInfo->prefix.opsiz = FALSE;
; 2646 :         else if ( op2_size == 2 )

	jne	SHORT $LN70@check_size

; 2647 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? TRUE : FALSE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], r14b
	setne	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al
	jmp	$LN131@check_size
$LN70@check_size:

; 2648 :         else
; 2649 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? FALSE : TRUE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], r14b
	sete	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al

; 2650 :         break;

	jmp	$LN131@check_size
$LN142@check_size:
	add	ecx, -1293				; fffffffffffffaf3H
	cmp	ecx, 22
	ja	$def_check$171
	mov	eax, 4194331				; 0040001bH

; 2354 :     }
; 2355 : 
; 2356 :     switch( CodeInfo->token ) {

	jmp	$LN165@check_size
$LN141@check_size:
	cmp	ecx, 1602				; 00000642H
	jg	SHORT $LN143@check_size
	je	SHORT $LN60@check_size
	cmp	ecx, 1338				; 0000053aH
	je	SHORT $LN61@check_size
	cmp	ecx, 1340				; 0000053cH
	jle	$def_check$171
	cmp	ecx, 1342				; 0000053eH
	jle	SHORT $LN61@check_size
	cmp	ecx, 1343				; 0000053fH
	jne	SHORT $def_check$171

; 2627 :         }
; 2628 :         break;
; 2629 :     case T_VMOVDDUP:
; 2630 :         if ( !( op1 & OP_YMM ) )

	test	bpl, bpl
	jns	$LN131@check_size
$LN64@check_size:

; 2631 :             break;
; 2632 :         /* fall through */
; 2633 :     case T_VPERM2F128: /* has just one memory variant, and VX_L isnt set */
; 2634 :         if ( op2 == OP_M )

	cmp	edi, -1887436800			; ffffffff8f800000H
	jne	$LN131@check_size

; 2635 :             CodeInfo->opnd[OPND2].type |= OP_M256;

	bts	edi, 28
	mov	DWORD PTR [rbx+56], edi

; 2636 :         break;

	jmp	$LN131@check_size
$LN61@check_size:

; 2622 :     case T_VCVTPD2DQ:
; 2623 :     case T_VCVTTPD2DQ:
; 2624 :     case T_VCVTPD2PS:
; 2625 :         if ( op2 == OP_M && opndx[OPND2].indirect ) {

	cmp	edi, -1887436800			; ffffffff8f800000H
	jne	$LN131@check_size
	test	BYTE PTR [rdx+176], 1
	je	$LN131@check_size

; 2626 :             return( EmitError( INSTRUCTION_OPERAND_MUST_HAVE_SIZE ) );

	mov	ecx, 182				; 000000b6H
	call	EmitError
	jmp	$LN1@check_size
$LN60@check_size:

; 2594 :         break;
; 2595 :     case T_CVTSD2SI:
; 2596 :     case T_CVTTSD2SI:
; 2597 :     case T_CVTSS2SI:
; 2598 :     case T_CVTTSS2SI:
; 2599 :     //case T_MOVNTI: /* v2.05: removed */
; 2600 : #if AVXSUPP
; 2601 :     case T_VBROADCASTSD:
; 2602 :     case T_VBROADCASTF128:
; 2603 :     case T_VEXTRACTF128:
; 2604 :     case T_VINSERTF128:
; 2605 :     case T_VCVTSD2SI:
; 2606 :     case T_VCVTTSD2SI:
; 2607 :     case T_VCVTSS2SI:
; 2608 :     case T_VCVTTSS2SI:
; 2609 : #endif
; 2610 : #if VMXSUPP /* v2.09: added */
; 2611 :     case T_INVEPT:
; 2612 :     case T_INVVPID:
; 2613 : #endif
; 2614 : #if SVMSUPP /* v2.09: added */
; 2615 :     case T_INVLPGA:
; 2616 : #endif
; 2617 :         break;
; 2618 : #if AVXSUPP
; 2619 :     case T_VCVTSD2USI:
; 2620 :           CodeInfo->evex_flag = TRUE;

	mov	BYTE PTR [rbx+136], 1

; 2621 :           break;

	jmp	$LN131@check_size
$LN143@check_size:
	cmp	ecx, 1630				; 0000065eH
	je	$LN131@check_size
	add	ecx, -1908				; fffffffffffff88cH
	cmp	ecx, 6
	ja	SHORT $def_check$171
	mov	eax, 99					; 00000063H
$LN165@check_size:
	bt	eax, ecx
	jb	$LN131@check_size
$def_check$171:

; 2710 :                 DebugMsg1(("check_size: OP_A flag reset, new op2=%X\n", CodeInfo->opnd[OPND1].type ));
; 2711 : #endif
; 2712 :             }
; 2713 :         }
; 2714 :         /* fall through */
; 2715 :     default:
; 2716 : //#if AMD64_SUPPORT
; 2717 :     def_check:
; 2718 : //#endif
; 2719 :         /* make sure the 2 opnds are of the same type */
; 2720 :         op1_size = OperandSize( op1, CodeInfo );

	mov	rdx, rbx
	mov	ecx, ebp
	call	OperandSize

; 2721 :         op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, rbx
	mov	ecx, edi
	mov	r15d, eax
	call	OperandSize
	mov	esi, eax

; 2722 :         DebugMsg1(("check_size default: op1_size1=%u, op2_size=%u\n", op1_size, op2_size));
; 2723 :         if( op1_size > op2_size ) {

	cmp	r15d, eax
	jle	SHORT $LN95@check_size

; 2724 :             if( ( op2 >= OP_I8 ) && ( op2 <= OP_I32 ) ) {     /* immediate */

	lea	ecx, DWORD PTR [rdi-131072]
	cmp	ecx, 393216				; 00060000H
	cmovbe	esi, r15d
$LN95@check_size:

; 2725 :                 op2_size = op1_size;    /* promote to larger size */
; 2726 :             }
; 2727 :         }
; 2728 : #if 1
; 2729 :         /* v2.04: check in idata_nofixup was signed,
; 2730 :          * so now add -256 - -129 and 128-255 to acceptable byte range.
; 2731 :          * Since Masm v8, the check is more restrictive, -255 - -129
; 2732 :          * is no longer accepted.
; 2733 :          */
; 2734 :         if( ( op1_size == 1 ) && ( op2 == OP_I16 ) &&
; 2735 :             ( CodeInfo->opnd[OPND2].data32l <= UCHAR_MAX ) &&

	cmp	r15d, 1
	jne	SHORT $LN96@check_size
	cmp	edi, r12d
	jne	SHORT $LN96@check_size

; 2736 :             //CodeInfo->opnd[OPND2].data32l >= -128 ) ) {
; 2737 :             ( CodeInfo->opnd[OPND2].data32l >= -255 ) ) {
; 2738 :             return( rc ); /* OK cause no sign extension */

	mov	eax, DWORD PTR [rbx+64]
	add	eax, 255				; 000000ffH
	cmp	eax, 510				; 000001feH
	jbe	$LN77@check_size
$LN96@check_size:

; 2739 :         }
; 2740 : #endif
; 2741 : #if 0
; 2742 :         /* v2.03: this "if" made HJWasm accept any 32-bit constant
; 2743 :          *        for 16-bit destinations, which is Masm compatibel,
; 2744 :          *      "mov ax, 12345h"
; 2745 :          * the test is a bit too liberal here, IMO, because
; 2746 :          * it makes HJWasm accept "mov ax, near32 ptr var",
; 2747 :          * which is rejected by Masm.
; 2748 :          */
; 2749 :         if( ( op1_size == 2 ) && ( op2 == OP_I32 )
; 2750 :             && ( CodeInfo->data[OPND2] <= USHRT_MAX ) ) {
; 2751 :             return( rc ); /* OK cause no sign extension */
; 2752 :         }
; 2753 : #endif
; 2754 :         if( op1_size != op2_size ) {

	cmp	r15d, esi
	je	$LN131@check_size

; 2755 :             /* if one or more are !defined, set them appropriately */
; 2756 : #if AVXSUPP
; 2757 :             if( ( op1 | op2 ) & ( OP_MMX | OP_XMM | OP_YMM | OP_K | OP_ZMM ) ) {

	mov	r12d, edi
	or	r12d, ebp
	test	r12d, 496				; 000001f0H
	jne	SHORT $LN102@check_size

; 2758 : #else
; 2759 :             if( ( op1 | op2 ) & ( OP_MMX | OP_XMM ) ) {
; 2760 : #endif
; 2761 :             }
; 2762 :             else if( ( op1_size != 0 ) && ( op2_size != 0 ) ) {

	test	r15d, r15d
	je	SHORT $LN145@check_size
	test	esi, esi
	je	SHORT $LN102@check_size
	mov	ecx, DWORD PTR [rbx+24]
	lea	eax, DWORD PTR [rcx-1602]
	cmp	eax, 1
	jbe	SHORT $LN103@check_size
	lea	eax, DWORD PTR [rcx-1622]
	cmp	eax, 1
	jbe	SHORT $LN103@check_size

; 2766 :               else{
; 2767 :                 EmitErr(OPERANDS_MUST_BE_THE_SAME_SIZE, op1_size, op2_size);

	mov	r8d, esi
	mov	edx, r15d
	mov	ecx, 48					; 00000030H
	call	EmitErr

; 2768 :                 rc = ERROR;

	or	r14d, -1
	jmp	SHORT $LN102@check_size
$LN103@check_size:

; 2763 :               if ((CodeInfo->token == T_VCVTSD2USI)||(CodeInfo->token == T_VCVTSS2USI)||
; 2764 :                 (CodeInfo->token == T_VCVTTSD2USI)||(CodeInfo->token == T_VCVTTSS2USI))
; 2765 :                 CodeInfo->evex_flag = TRUE;

	mov	BYTE PTR [rbx+136], 1
$LN102@check_size:

; 2769 :               }
; 2770 :             }
; 2771 :             /* size == 0 is assumed to mean "undefined", but there
; 2772 :              * is also the case of an "empty" struct or union. The
; 2773 :              * latter case isn't handled correctly.
; 2774 :              */
; 2775 :             if( op1_size == 0 ) {

	test	r15d, r15d
	jne	$LN131@check_size
$LN145@check_size:

; 2776 :                 if( ( op1 & OP_M_ANY ) && ( op2 & OP_I ) ) {

	mov	eax, ebp
	and	eax, -8388608				; ffffffffff800000H
	je	$LN105@check_size
	test	edi, 917504				; 000e0000H
	je	$LN105@check_size

; 2777 :                     char *p = "WORD";
; 2778 :                     if( (uint_32)CodeInfo->opnd[OPND2].data32l > USHRT_MAX || op2_size == 4 ) {

	mov	ecx, DWORD PTR [rbx+64]
	lea	r8, OFFSET FLAT:$SG12360
	cmp	ecx, 65535				; 0000ffffH
	ja	SHORT $LN109@check_size
	cmp	esi, 4
	je	SHORT $LN109@check_size

; 2792 :                         }
; 2793 :                     } else if( (uint_32)CodeInfo->opnd[OPND2].data32l > UCHAR_MAX || op2_size == 2 ) {

	cmp	ecx, 255				; 000000ffH
	ja	SHORT $LN115@check_size
	cmp	esi, 2
	je	SHORT $LN115@check_size

; 2798 :                          CodeInfo->mem_type = MT_BYTE;
; 2799 :                          CodeInfo->opnd[OPND2].type = OP_I8;

	mov	eax, 131072				; 00020000H
	mov	DWORD PTR [rbx+28], 0
	mov	DWORD PTR [rbx+56], eax

; 2800 :                          p = "BYTE";

	lea	r8, OFFSET FLAT:$SG12371
	jmp	SHORT $LN112@check_size
$LN115@check_size:

; 2794 :                          CodeInfo->mem_type = MT_WORD;
; 2795 :                          CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1

; 2796 :                          CodeInfo->opnd[OPND2].type = OP_I16;

	mov	ecx, 262144				; 00040000H
	mov	DWORD PTR [rbx+56], ecx
	mov	DWORD PTR [rbx+28], 1

; 2797 :                     } else {

	jmp	SHORT $LN112@check_size
$LN109@check_size:

; 2779 :                         CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1

; 2780 :                         DebugMsg1(("check_size: op1=%X op1_size=0, op2=%X, op2_size=%u CodeInfo->data[2]=%X\n", op1, op2, op2_size, CodeInfo->opnd[OPND2].data32l ));
; 2781 : #if 1 /* added v1.95: in 16bit code, 'mov [di],8000h' should warn: assuming WORD */
; 2782 :                         if ( ModuleInfo.Ofssize == USE16 && op2_size > 2 && InWordRange( CodeInfo->opnd[OPND2].data32l ) )

	movzx	edx, BYTE PTR ModuleInfo+404
	test	dl, dl
	jne	SHORT $LN110@check_size
	cmp	esi, 2
	jle	SHORT $LN144@check_size
	lea	eax, DWORD PTR [rcx+65535]
	cmp	eax, 131070				; 0001fffeH
	jbe	SHORT $LN144@check_size
$LN110@check_size:

; 2783 :                             op2_size = 2;
; 2784 : #endif
; 2785 :                         if (op2_size <= 2 && CodeInfo->opnd[OPND2].data32l > SHRT_MIN && ModuleInfo.Ofssize == USE16 ) {

	cmp	esi, 2
	jg	SHORT $LN111@check_size
$LN144@check_size:
	cmp	ecx, -32768				; ffffffffffff8000H
	jle	SHORT $LN111@check_size
	test	dl, dl
	jne	SHORT $LN111@check_size

; 2786 :                             CodeInfo->mem_type = MT_WORD;
; 2787 :                             CodeInfo->opnd[OPND2].type = OP_I16;

	mov	ecx, 262144				; 00040000H
	mov	DWORD PTR [rbx+28], 1
	mov	DWORD PTR [rbx+56], ecx

; 2788 :                         } else {

	jmp	SHORT $LN112@check_size
$LN111@check_size:

; 2789 :                             CodeInfo->mem_type = MT_DWORD;

	mov	DWORD PTR [rbx+28], 3

; 2790 :                             CodeInfo->opnd[OPND2].type = OP_I32;
; 2791 :                             p = "DWORD";

	lea	r8, OFFSET FLAT:$SG12367
	mov	DWORD PTR [rbx+56], 524288		; 00080000H
$LN112@check_size:

; 2801 :                     }
; 2802 :                     if( opndx[OPND2].explicit == FALSE ) {

	test	BYTE PTR [r13+176], 2
	jne	$LN131@check_size

; 2803 :                         /* v2.06: emit warning at pass one if mem op isn't a forward ref */
; 2804 :                         /* v2.06b: added "undefined" check */
; 2805 :                         if ( ( CodeInfo->opnd[OPND1].InsFixup == NULL && Parse_Pass == PASS_1 && CodeInfo->undef_sym == FALSE ) ||

	mov	rcx, QWORD PTR [rbx+48]
	mov	eax, DWORD PTR Parse_Pass
	test	rcx, rcx
	jne	SHORT $LN167@check_size
	test	eax, eax
	jne	SHORT $LN119@check_size
	test	BYTE PTR [rbx+142], 64			; 00000040H
	je	$LN118@check_size
$LN119@check_size:
	test	rcx, rcx
	je	$LN131@check_size
$LN167@check_size:
	cmp	eax, 1
	jne	$LN131@check_size

; 2806 :                             ( CodeInfo->opnd[OPND1].InsFixup && Parse_Pass == PASS_2 ) )
; 2807 :                                 EmitWarn( 1, SIZE_NOT_SPECIFIED_ASSUMING, p );  //ovde je greska
; 2808 :                     }

	jmp	$LN118@check_size
$LN105@check_size:

; 2809 :                 } else if( ( op1 & OP_M_ANY ) && ( op2 & ( OP_R | OP_SR ) ) ) {

	test	eax, eax
	je	SHORT $LN120@check_size
	test	edi, 24591				; 0000600fH
	jne	$LN131@check_size
$LN120@check_size:

; 2810 :                 } else if( ( op1 & ( OP_MMX | OP_XMM ) ) && ( op2 & OP_I ) ) {

	test	bpl, 48					; 00000030H
	je	SHORT $LN122@check_size
	test	edi, 917504				; 000e0000H
	je	SHORT $LN122@check_size

; 2811 :                     if( (uint_32)CodeInfo->opnd[OPND2].data32l > USHRT_MAX ) {

	mov	ecx, DWORD PTR [rbx+64]
	cmp	ecx, 65535				; 0000ffffH
	jbe	SHORT $LN124@check_size

; 2812 :                          CodeInfo->opnd[OPND2].type = OP_I32;

	mov	DWORD PTR [rbx+56], 524288		; 00080000H
	jmp	$LN131@check_size
$LN124@check_size:

; 2813 :                     } else if( (uint_32)CodeInfo->opnd[OPND2].data32l > UCHAR_MAX ) {

	cmp	ecx, 255				; 000000ffH
	mov	eax, 131072				; 00020000H
	mov	ecx, 262144				; 00040000H
	cmova	eax, ecx
	mov	DWORD PTR [rbx+56], eax

; 2814 :                          CodeInfo->opnd[OPND2].type = OP_I16;
; 2815 :                     } else {
; 2816 :                          CodeInfo->opnd[OPND2].type = OP_I8;
; 2817 :                     }

	jmp	$LN131@check_size
$LN122@check_size:

; 2818 :                 } else if( ( op1 | op2 ) & ( OP_MMX | OP_XMM ) ) {

	test	r12b, 48				; 00000030H
	jne	$LN131@check_size

; 2819 :                 } else {
; 2820 :                     //AsmIntErr( 1 ); /* printf("internal error = %u", 1 ) */
; 2821 :                     switch( op2_size ) {

	sub	esi, 1
	je	SHORT $LN130@check_size
	sub	esi, 1
	je	SHORT $LN132@check_size
	cmp	esi, 2
	jne	$LN131@check_size

; 2837 :                     case 4:
; 2838 :                         CodeInfo->mem_type = MT_DWORD;
; 2839 :                         CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1
	mov	DWORD PTR [rbx+28], 3

; 2840 :                         if( ( Parse_Pass == PASS_1 ) && ( op2 & OP_I ) ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN131@check_size
	test	edi, 917504				; 000e0000H
	je	SHORT $LN131@check_size

; 2841 :                             EmitWarn( 1, SIZE_NOT_SPECIFIED_ASSUMING, "DWORD" );

	lea	r8, OFFSET FLAT:$SG12395
	jmp	SHORT $LN118@check_size
$LN132@check_size:

; 2826 :                         }
; 2827 :                         break;
; 2828 :                     case 2:
; 2829 :                         CodeInfo->mem_type = MT_WORD;
; 2830 :                         CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1
	mov	DWORD PTR [rbx+28], 1

; 2831 :                         if( ( Parse_Pass == PASS_1 ) && ( op2 & OP_I ) ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN133@check_size
	test	edi, 917504				; 000e0000H
	je	SHORT $LN133@check_size

; 2832 :                             EmitWarn( 1, SIZE_NOT_SPECIFIED_ASSUMING, "WORD" );

	mov	edx, 73					; 00000049H
	lea	r8, OFFSET FLAT:$SG12391
	lea	ecx, QWORD PTR [rdx-72]
	call	EmitWarn
$LN133@check_size:

; 2833 :                         }
; 2834 :                         if( CodeInfo->Ofssize )

	cmp	BYTE PTR [rbx+106], 0
	je	SHORT $LN131@check_size

; 2835 :                             CodeInfo->prefix.opsiz = TRUE;

	or	BYTE PTR [rbx+9], 2

; 2836 :                         break;

	jmp	SHORT $LN131@check_size
$LN130@check_size:

; 2822 :                     case 1:
; 2823 :                         CodeInfo->mem_type = MT_BYTE;

	mov	DWORD PTR [rbx+28], 0

; 2824 :                         if( ( Parse_Pass == PASS_1 ) && ( op2 & OP_I ) ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN131@check_size
	test	edi, 917504				; 000e0000H
	je	SHORT $LN131@check_size

; 2825 :                             EmitWarn( 1, SIZE_NOT_SPECIFIED_ASSUMING, "BYTE" );

	lea	r8, OFFSET FLAT:$SG12388
$LN118@check_size:
	mov	edx, 73					; 00000049H
	lea	ecx, QWORD PTR [rdx-72]
	call	EmitWarn
$LN131@check_size:

; 2842 :                         }
; 2843 :                         break;
; 2844 :                     }
; 2845 :                 }
; 2846 :             }
; 2847 :         }
; 2848 :     }
; 2849 :     DebugMsg1(("check_size exit [CodeInfo->mem_type=%Xh]\n", CodeInfo->mem_type));
; 2850 :     return( rc );

	mov	eax, r14d
$LN1@check_size:

; 2851 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
	npad	1
$LN162@check_size:
	DD	$LN27@check_size
	DD	$LN33@check_size
	DD	$LN49@check_size
	DD	$LN73@check_size
	DD	$LN131@check_size
	DD	$LN55@check_size
	DD	$LN14@check_size
	DD	$LN50@check_size
	DD	$LN36@check_size
	DD	$LN20@check_size
	DD	$def_check$171
$LN161@check_size:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	1
	DB	1
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	2
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	3
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	4
	DB	10
	DB	5
	DB	6
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	7
	DB	7
	DB	4
	DB	10
	DB	1
	DB	1
	DB	1
	DB	10
	DB	10
	DB	8
	DB	8
	DB	10
	DB	9
check_size ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
;	COMDAT HandleStringInstructions
_TEXT	SEGMENT
CodeInfo$ = 48
opndx$ = 56
HandleStringInstructions PROC				; COMDAT

; 2163 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2164 :     int opndidx = OPND1;
; 2165 :     int op_size;
; 2166 : 
; 2167 :     switch( CodeInfo->token ) {

	lea	rsi, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR [rcx+24]
	xor	edi, edi
	cmp	ecx, 1210				; 000004baH
	jg	SHORT $LN53@HandleStri
	je	$LN7@HandleStri
	cmp	ecx, 535				; 00000217H
	jg	SHORT $LN54@HandleStri
	je	$LN17@HandleStri
	sub	ecx, 520				; 00000208H
	cmp	ecx, 14
	ja	$LN29@HandleStri
	movsxd	rax, ecx
	mov	ecx, DWORD PTR $LN57@HandleStri[rsi+rax*4]
	add	rcx, rsi
	jmp	rcx
$LN54@HandleStri:
	cmp	ecx, 539				; 0000021bH
	jle	SHORT $LN25@HandleStri
	cmp	ecx, 1046				; 00000416H
	je	$LN18@HandleStri
	cmp	ecx, 1052				; 0000041cH
	jmp	SHORT $LN58@HandleStri
$LN25@HandleStri:

; 2239 :                 EmitError( INVALID_INSTRUCTION_OPERANDS );
; 2240 :             else if ( CodeInfo->prefix.RegOverride == ASSUME_DS )
; 2241 :                 CodeInfo->prefix.RegOverride = EMPTY;
; 2242 :         break;
; 2243 :     case T_OUTS:
; 2244 :     case T_OUTSB:
; 2245 :     case T_OUTSW:
; 2246 :     case T_OUTSD:
; 2247 :         /* v2.01: remove default DS prefix */
; 2248 :         if ( CodeInfo->prefix.RegOverride == ASSUME_DS )

	cmp	DWORD PTR [rbx+4], 3
	jne	SHORT $LN26@HandleStri

; 2249 :             CodeInfo->prefix.RegOverride = EMPTY;

	mov	ecx, -2
	mov	DWORD PTR [rbx+4], ecx
$LN26@HandleStri:

; 2250 :         opndidx = OPND2;

	mov	edi, 1

; 2251 :         break;

	jmp	$LN16@HandleStri
$LN53@HandleStri:

; 2164 :     int opndidx = OPND1;
; 2165 :     int op_size;
; 2166 : 
; 2167 :     switch( CodeInfo->token ) {

	cmp	ecx, 1457				; 000005b1H
	jg	SHORT $LN55@HandleStri
	cmp	ecx, 1456				; 000005b0H
	jge	SHORT $LN6@HandleStri
	cmp	ecx, 1211				; 000004bbH
	je	SHORT $LN27@HandleStri
	cmp	ecx, 1212				; 000004bcH
	je	SHORT $LN18@HandleStri
	lea	eax, DWORD PTR [rcx-1450]
	cmp	eax, 1
	ja	SHORT $LN29@HandleStri
$LN6@HandleStri:

; 2168 : #if AVXSUPP
; 2169 :     case T_VCMPSD:
; 2170 :     case T_VPCMPD:
; 2171 :     case T_VPCMPB:
; 2172 :     case T_VPCMPUD:
; 2173 :     case T_VPCMPUB:
; 2174 : #endif
; 2175 :     case T_CMPSD:
; 2176 :         /* filter SSE2 opcode CMPSD */
; 2177 :         if ( CodeInfo->opnd[OPND1].type & (OP_XMM | OP_MMX)) {

	test	BYTE PTR [rbx+32], 48			; 00000030H
	je	$LN7@HandleStri
$LN19@HandleStri:

; 2178 :             /* v2.01: QWORD operand for CMPSD/MOVSD may have set REX_W! */
; 2179 : #if AMD64_SUPPORT
; 2180 :             CodeInfo->prefix.rex &= ~REX_W;

	and	BYTE PTR [rbx+8], 247			; 000000f7H

; 2318 :             }
; 2319 :             break;
; 2320 : #endif
; 2321 :         }
; 2322 :     }
; 2323 :     return;
; 2324 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN27@HandleStri:

; 2252 :     case T_LODS:
; 2253 :     case T_LODSB:
; 2254 :     case T_LODSW:
; 2255 :     case T_LODSD:
; 2256 : #if AMD64_SUPPORT
; 2257 :     case T_LODSQ:
; 2258 : #endif
; 2259 :         /* v2.10: remove unnecessary DS prefix ( Masm-compatible ) */
; 2260 :         if ( CodeInfo->prefix.RegOverride == ASSUME_DS )

	cmp	DWORD PTR [rbx+4], 3

; 2261 :             CodeInfo->prefix.RegOverride = EMPTY;
; 2262 :         break;

	jmp	SHORT $LN59@HandleStri
$LN55@HandleStri:

; 2164 :     int opndidx = OPND1;
; 2165 :     int op_size;
; 2166 : 
; 2167 :     switch( CodeInfo->token ) {

	sub	ecx, 1762				; 000006e2H
	je	SHORT $LN6@HandleStri
	sub	ecx, 181				; 000000b5H
	je	SHORT $LN17@HandleStri
	cmp	ecx, 11
$LN58@HandleStri:
	je	SHORT $LN17@HandleStri
$LN29@HandleStri:

; 2263 :     default: /*INS[B|W|D], SCAS[B|W|D|Q], STOS[B|W|D|Q] */
; 2264 :         /* INSx, SCASx and STOSx don't allow any segment prefix != ES
; 2265 :          for the memory operand.
; 2266 :          */
; 2267 :         if ( CodeInfo->prefix.RegOverride != EMPTY )

	mov	eax, DWORD PTR [rbx+4]
	cmp	eax, -2
	je	SHORT $LN16@HandleStri

; 2268 :             if ( CodeInfo->prefix.RegOverride == ASSUME_ES )

	test	eax, eax
	je	SHORT $LN60@HandleStri
$LN12@HandleStri:

; 2269 :                 CodeInfo->prefix.RegOverride = EMPTY;
; 2270 :             else
; 2271 :                 EmitError( INVALID_INSTRUCTION_OPERANDS );

	mov	ecx, 49					; 00000031H
	call	EmitError
	jmp	SHORT $LN16@HandleStri
$LN17@HandleStri:

; 2209 :             }
; 2210 :         }
; 2211 :         break;
; 2212 : #if AVXSUPP
; 2213 :     case T_VMOVSD:
; 2214 :     case T_VMOVUPS:
; 2215 : #endif
; 2216 :     case T_MOVSD:
; 2217 :     case T_MOVUPS:
; 2218 : 
; 2219 :         /* filter SSE2 opcode MOVSD */
; 2220 :         if ( ( CodeInfo->opnd[OPND1].type & (OP_XMM | OP_MMX | OP_YMM | OP_ZMM) ) ||

	test	DWORD PTR [rbx+32], 432			; 000001b0H
	jne	SHORT $LN19@HandleStri
	test	DWORD PTR [rbx+56], 432			; 000001b0H
	jne	SHORT $LN19@HandleStri
$LN18@HandleStri:

; 2221 :             ( CodeInfo->opnd[OPND2].type & (OP_XMM | OP_MMX | OP_YMM | OP_ZMM) ) ) {
; 2222 :             /* v2.01: QWORD operand for CMPSD/MOVSD may have set REX_W! */
; 2223 : #if AMD64_SUPPORT
; 2224 :             CodeInfo->prefix.rex &= ~REX_W;
; 2225 : #endif
; 2226 :             return;
; 2227 :         }
; 2228 :         /* fall through */
; 2229 :     case T_MOVS:
; 2230 :     case T_MOVSB:
; 2231 :     case T_MOVSW:
; 2232 : #if AMD64_SUPPORT
; 2233 :     case T_MOVSQ:
; 2234 :     case T_MOVQ:
; 2235 : #endif
; 2236 :         /* movs allows prefix for the second operand (=source) only */
; 2237 :         if ( CodeInfo->prefix.RegOverride != EMPTY )

	mov	eax, DWORD PTR [rbx+4]
	cmp	eax, -2
	je	SHORT $LN16@HandleStri

; 2238 :             if ( opndx[OPND2].override == NULL )

	cmp	QWORD PTR [rdx+152], rdi
	je	SHORT $LN12@HandleStri
$LN10@HandleStri:

; 2203 :                     DebugMsg1(("HandleStringInstructions: CMPS: CodeInfo->RegOverride=%X, opndx->override=%s\n", CodeInfo->prefix.RegOverride, opndx[OPND2].override->string_ptr ));
; 2204 :                     EmitError( INVALID_INSTRUCTION_OPERANDS );
; 2205 :                 }
; 2206 :             } else if ( CodeInfo->prefix.RegOverride == ASSUME_DS ) {

	cmp	eax, 3
$LN59@HandleStri:
	jne	SHORT $LN16@HandleStri
$LN60@HandleStri:

; 2207 :                 /* prefix for first operand? */
; 2208 :                 CodeInfo->prefix.RegOverride = EMPTY;

	mov	ecx, -2
	mov	DWORD PTR [rbx+4], ecx
$LN16@HandleStri:

; 2272 :     }
; 2273 : 
; 2274 :     if ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[opndidx] == OP_NONE ) {

	mov	rdx, QWORD PTR [rbx+16]
	movsxd	rdi, edi
	movzx	ecx, BYTE PTR [rdx]
	lea	rax, QWORD PTR [rdi+rcx*2]
	add	rcx, rax
	cmp	DWORD PTR opnd_clstab[rsi+rcx*4], 0
	jne	SHORT $LN33@HandleStri

; 2275 :         CodeInfo->iswide = 0;

	and	BYTE PTR [rbx+142], 254			; 000000feH

; 2276 :         CodeInfo->prefix.opsiz = FALSE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
$LN33@HandleStri:

; 2277 :     }
; 2278 : 
; 2279 :     /* if the instruction is the variant without suffix (MOVS, LODS, ..),
; 2280 :      * then use the operand's size to get further info.
; 2281 :      */
; 2282 :     //if ( CodeInfo->pinstr->opnd_type[opndidx] != OP_NONE &&
; 2283 :     if ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[opndidx] != OP_NONE &&

	movzx	ecx, BYTE PTR [rdx]
	lea	rax, QWORD PTR [rdi+rcx*2]
	add	rcx, rax
	cmp	DWORD PTR opnd_clstab[rsi+rcx*4], 0
	je	$LN51@HandleStri
	lea	rax, QWORD PTR [rdi+rdi*2]
	mov	ecx, DWORD PTR [rbx+rax*8+32]
	test	ecx, ecx
	je	$LN51@HandleStri

; 2284 :         CodeInfo->opnd[opndidx].type != OP_NONE ) {
; 2285 :         if (CodeInfo->token == T_KMOVB) op_size = 1;

	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 1729				; 000006c1H
	je	$LN45@HandleStri

; 2286 :         else if (CodeInfo->token == T_KMOVW) op_size = 2;

	cmp	eax, 1732				; 000006c4H
	jne	SHORT $LN37@HandleStri
	mov	ecx, 2
	jmp	$LN44@HandleStri
$LN7@HandleStri:

; 2181 : #endif
; 2182 :             return;
; 2183 :         }
; 2184 :         /* fall through */
; 2185 :     case T_CMPS:
; 2186 :     case T_CMPSB:
; 2187 :     case T_CMPSW:
; 2188 : #if AMD64_SUPPORT
; 2189 :     case T_CMPSQ:
; 2190 : #endif
; 2191 :          /* cmps allows prefix for the first operand (=source) only */
; 2192 :         if ( CodeInfo->prefix.RegOverride != EMPTY ) {

	mov	eax, DWORD PTR [rbx+4]
	cmp	eax, -2
	je	SHORT $LN16@HandleStri

; 2193 :             if ( opndx[OPND2].override != NULL ) {

	cmp	QWORD PTR [rdx+152], rdi
	je	$LN10@HandleStri

; 2194 :                 if ( CodeInfo->prefix.RegOverride == ASSUME_ES ) {

	test	eax, eax
	jne	$LN12@HandleStri

; 2195 :                     /* content of LastRegOverride is valid if
; 2196 :                      * CodeInfo->RegOverride is != EMPTY.
; 2197 :                      */
; 2198 :                     if ( LastRegOverride == ASSUME_DS )

	mov	eax, DWORD PTR LastRegOverride
	mov	ecx, -2
	cmp	eax, 3
	cmove	eax, ecx
	mov	DWORD PTR [rbx+4], eax

; 2199 :                         CodeInfo->prefix.RegOverride = EMPTY;
; 2200 :                     else
; 2201 :                         CodeInfo->prefix.RegOverride = LastRegOverride;
; 2202 :                 } else {

	jmp	$LN16@HandleStri
$LN37@HandleStri:

; 2287 :         else if (CodeInfo->token == T_KMOVD) op_size = 4;

	cmp	eax, 1730				; 000006c2H
	jne	SHORT $LN39@HandleStri
	mov	ecx, 4
	jmp	SHORT $LN44@HandleStri
$LN39@HandleStri:

; 2288 :         else if (CodeInfo->token == T_KMOVQ) op_size = 8;

	cmp	eax, 1731				; 000006c3H
	jne	SHORT $LN41@HandleStri
	mov	ecx, 8
	jmp	SHORT $LN44@HandleStri
$LN41@HandleStri:

; 2289 :         else op_size = OperandSize( CodeInfo->opnd[opndidx].type, CodeInfo );

	mov	rdx, rbx
	call	OperandSize
	mov	ecx, eax

; 2290 :         /* v2.06: added. if memory operand has no size */
; 2291 :         if ( op_size == 0 )

	test	eax, eax
	jne	SHORT $LN44@HandleStri

; 2292 :           op_size = OperandSize( CodeInfo->opnd[opndidx+1].type, CodeInfo );

	lea	rax, QWORD PTR [rdi+rdi*2]
	mov	rdx, rbx
	mov	ecx, DWORD PTR [rbx+rax*8+56]
	call	OperandSize
	mov	ecx, eax

; 2293 :         if ( op_size == 0 ) {

	test	eax, eax
	jne	SHORT $LN44@HandleStri

; 2294 :             if ( CodeInfo->opnd[opndidx].InsFixup == NULL || CodeInfo->opnd[opndidx].InsFixup->sym->state != SYM_UNDEFINED )

	lea	rax, QWORD PTR [rdi+rdi*2]
	mov	rax, QWORD PTR [rbx+rax*8+48]
	test	rax, rax
	je	SHORT $LN46@HandleStri
	mov	rax, QWORD PTR [rax+56]
	cmp	DWORD PTR [rax+32], ecx
	je	SHORT $LN45@HandleStri
$LN46@HandleStri:

; 2295 :                 EmitError( INSTRUCTION_OPERAND_MUST_HAVE_SIZE );

	mov	ecx, 182				; 000000b6H
	call	EmitError
$LN45@HandleStri:

; 2296 :             op_size = 1; /* assume shortest format */

	mov	ecx, 1
$LN44@HandleStri:

; 2297 :         }
; 2298 :         switch( op_size ) {

	sub	ecx, 1
	je	SHORT $LN47@HandleStri
	sub	ecx, 1
	je	SHORT $LN48@HandleStri
	sub	ecx, 2
	je	SHORT $LN49@HandleStri
	cmp	ecx, 4
	jne	SHORT $LN51@HandleStri

; 2311 :             break;
; 2312 : #if AMD64_SUPPORT
; 2313 :         case 8:
; 2314 :             if ( CodeInfo->Ofssize == USE64 ) {

	cmp	BYTE PTR [rbx+106], 2
	jne	SHORT $LN51@HandleStri

; 2315 :                 CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1

; 2316 :                 CodeInfo->prefix.opsiz = FALSE;
; 2317 :                 CodeInfo->prefix.rex = REX_W;

	mov	BYTE PTR [rbx+8], 8
	jmp	SHORT $LN61@HandleStri
$LN49@HandleStri:

; 2307 :             break;
; 2308 :         case 4:
; 2309 :             CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1

; 2310 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? FALSE : TRUE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], 0
	sete	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al

; 2318 :             }
; 2319 :             break;
; 2320 : #endif
; 2321 :         }
; 2322 :     }
; 2323 :     return;
; 2324 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN48@HandleStri:

; 2303 :             break;
; 2304 :         case 2:
; 2305 :             CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1

; 2306 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? TRUE : FALSE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], 0
	setne	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al

; 2318 :             }
; 2319 :             break;
; 2320 : #endif
; 2321 :         }
; 2322 :     }
; 2323 :     return;
; 2324 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN47@HandleStri:

; 2299 :         case 1:
; 2300 :             CodeInfo->iswide = 0;

	and	BYTE PTR [rbx+142], 254			; 000000feH
$LN61@HandleStri:

; 2301 :             //if( CodeInfo->Ofssize )
; 2302 :                 CodeInfo->prefix.opsiz = FALSE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
$LN51@HandleStri:

; 2318 :             }
; 2319 :             break;
; 2320 : #endif
; 2321 :         }
; 2322 :     }
; 2323 :     return;
; 2324 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
	npad	3
$LN57@HandleStri:
	DD	$LN7@HandleStri
	DD	$LN7@HandleStri
	DD	$LN7@HandleStri
	DD	$LN6@HandleStri
	DD	$LN29@HandleStri
	DD	$LN29@HandleStri
	DD	$LN29@HandleStri
	DD	$LN29@HandleStri
	DD	$LN27@HandleStri
	DD	$LN27@HandleStri
	DD	$LN27@HandleStri
	DD	$LN27@HandleStri
	DD	$LN18@HandleStri
	DD	$LN18@HandleStri
	DD	$LN18@HandleStri
HandleStringInstructions ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
;	COMDAT process_register
_TEXT	SEGMENT
CodeInfo$ = 48
CurrOpnd$ = 56
opndx$ = 64
process_register PROC					; COMDAT

; 2003 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	esi, edx

; 2004 :     enum special_token regtok;
; 2005 :     int  regno;
; 2006 :     uint_32 flags;
; 2007 :     DebugMsg1(( "process_register enter (%s)\n", opndx[CurrOpnd].base_reg->string_ptr ));
; 2008 :     regtok = opndx[CurrOpnd].base_reg->tokval;
; 2009 :     regno = GetRegNo( regtok );

	lea	rbp, OFFSET FLAT:__ImageBase
	mov	r10, rcx
	imul	rcx, rsi, 104				; 00000068H
	add	rcx, r8
	mov	rax, QWORD PTR [rcx+24]
	movsxd	rdi, DWORD PTR [rax+16]

; 2010 :     /* the register's "OP-flags" are stored in the 'value' field */
; 2011 :     flags = GetValueSp( regtok );
; 2012 :     CodeInfo->opnd[CurrOpnd].type = flags;

	lea	rax, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR [rdi+rdi*2]
	lea	rbx, QWORD PTR [r8*4]
	mov	edx, DWORD PTR SpecialTable[rbx+rbp]
	lea	r8, QWORD PTR [r10+rax*8]
	movzx	r11d, BYTE PTR SpecialTable[rbx+rbp+10]
	mov	DWORD PTR [r8+32], edx

; 2013 : #if AVXSUPP
; 2014 : 	if (CodeInfo->opnd[CurrOpnd].type == OP_XMM || CodeInfo->opnd[CurrOpnd].type == OP_YMM)

	movzx	eax, BYTE PTR evex
	cmp	edx, 32					; 00000020H
	je	SHORT $LN3@process_re
	cmp	edx, 128				; 00000080H
	jne	SHORT $LN4@process_re
$LN3@process_re:

; 2015 : 	{
; 2016 : 		if (!evex && regno > 15)

	test	al, al
	jne	SHORT $LN4@process_re
	cmp	r11d, 15
	jle	SHORT $LN4@process_re
$LN6@process_re:

; 2017 : 		{ 
; 2018 : 			return(EmitError(UNAUTHORISED_USE_OF_EVEX_REGISTERS));

	mov	ecx, 22
	call	EmitError
	jmp	$LN1@process_re
$LN4@process_re:

; 2019 : 		}
; 2020 : 	}
; 2021 : 	if (CodeInfo->opnd[CurrOpnd].type == OP_ZMM) {

	cmp	edx, 256				; 00000100H
	jne	SHORT $LN7@process_re

; 2022 : 		if (evex)

	test	al, al
	je	SHORT $LN6@process_re

; 2023 : 			CodeInfo->evex_flag = TRUE;

	mov	BYTE PTR [r10+136], 1
$LN7@process_re:

; 2024 : 		else
; 2025 : 			return(EmitError(UNAUTHORISED_USE_OF_EVEX_REGISTERS));
; 2026 : 	}
; 2027 : 	if (CodeInfo->opnd[CurrOpnd].type == OP_K && regno > 7) {

	cmp	DWORD PTR [r8+32], 64			; 00000040H
	jne	SHORT $LN8@process_re
	cmp	r11d, 7
	jg	SHORT $LN47@process_re
$LN8@process_re:

; 2028 : 		DebugMsg(("process_register: assume error, reg=%u\n", regno));
; 2029 : 		return(EmitError(USE_OF_REGISTER_ASSUMED_TO_ERROR));
; 2030 : 	}
; 2031 : #endif    
; 2032 : 	if ( flags & OP_R8 ) {

	test	dl, 1
	je	SHORT $LN9@process_re

; 2033 :         /* it's probably better to not reset the wide bit at all */
; 2034 :         if ( flags != OP_CL )      /* problem: SHL AX|AL, CL */

	cmp	edx, 1025				; 00000401H
	je	SHORT $LN11@process_re

; 2035 :             CodeInfo->iswide = 0;

	and	BYTE PTR [r10+142], 254			; 000000feH
$LN11@process_re:

; 2036 : 
; 2037 : #if AMD64_SUPPORT
; 2038 :         if ( CodeInfo->Ofssize == USE64 && regno >=4 && regno <=7 )

	cmp	BYTE PTR [r10+106], 2
	jne	SHORT $LN14@process_re
	lea	eax, DWORD PTR [r11-4]
	cmp	eax, 3
	ja	SHORT $LN14@process_re

; 2039 :             if ( SpecialTable[regtok].cpu == P_86 )

	cmp	WORD PTR SpecialTable[rbx+rbp+8], 0
	jne	SHORT $LN13@process_re

; 2040 :                 CodeInfo->x86hi_used = 1; /* it's AH,BH,CH,DH */

	or	BYTE PTR [r10+142], 16
	jmp	SHORT $LN14@process_re
$LN13@process_re:

; 2041 :             else
; 2042 :                 CodeInfo->x64lo_used = 1; /* it's SPL,BPL,SIL,DIL */

	or	BYTE PTR [r10+142], 32			; 00000020H
$LN14@process_re:

; 2043 : #endif
; 2044 :         if ( StdAssumeTable[regno].error & (( regtok >= T_AH && regtok <= T_BH ) ? RH_ERROR : RL_ERROR ) ) {

	lea	eax, DWORD PTR [rdi-5]
	mov	ecx, 1
	cmp	eax, 3
	mov	r8d, 16
	movsxd	rax, r11d
	cmovbe	ecx, r8d
	shl	rax, 4
	test	BYTE PTR StdAssumeTable[rax+rbp+8], cl
	je	$LN31@process_re
$LN47@process_re:

; 2045 :             DebugMsg(("process_register: assume error, reg=%u\n", regno ));
; 2046 :             return( EmitError( USE_OF_REGISTER_ASSUMED_TO_ERROR ) );

	mov	ecx, 183				; 000000b7H
	call	EmitError
	jmp	$LN1@process_re
$LN9@process_re:

; 2047 :         }
; 2048 :     } else if ( flags & OP_R ) { /* 16-, 32- or 64-bit GPR? */

	test	dl, 15
	je	SHORT $LN16@process_re

; 2049 :         CodeInfo->iswide = 1;

	or	BYTE PTR [r10+142], 1

; 2050 :         if ( StdAssumeTable[regno].error & flags & OP_R ) {

	mov	rax, r11
	add	rax, rax
	movzx	eax, BYTE PTR StdAssumeTable[rbp+rax*8+8]
	and	eax, edx
	test	al, 15
	jne	SHORT $LN47@process_re

; 2051 :             DebugMsg(("process_register: assume error, reg=%u\n", regno ));
; 2052 :             return( EmitError( USE_OF_REGISTER_ASSUMED_TO_ERROR ) );
; 2053 :         }
; 2054 :         if ( flags & OP_R16 ) {

	test	dl, 2
	je	SHORT $LN19@process_re

; 2055 :             if ( CodeInfo->Ofssize > USE16 )

	cmp	BYTE PTR [r10+106], 0
	jbe	$LN31@process_re

; 2056 :                 CodeInfo->prefix.opsiz = TRUE;

	or	BYTE PTR [r10+9], 2

; 2057 :         } else {

	jmp	$LN31@process_re
$LN19@process_re:

; 2058 :             if( CodeInfo->Ofssize == USE16 )

	cmp	BYTE PTR [r10+106], 0
	jne	$LN31@process_re

; 2059 :                 CodeInfo->prefix.opsiz = TRUE;

	or	BYTE PTR [r10+9], 2

; 2060 :         }

	jmp	$LN31@process_re
$LN16@process_re:

; 2061 :     } else if ( flags & OP_SR ) {

	test	edx, 24576				; 00006000H
	je	SHORT $LN23@process_re

; 2062 :         if( regno == 1 ) { /* 1 is CS */

	cmp	r11d, 1
	jne	$LN31@process_re

; 2063 :             /* POP CS is not allowed */
; 2064 :             if( CodeInfo->token == T_POP ) {

	cmp	DWORD PTR [r10+24], 601			; 00000259H
	jne	$LN31@process_re

; 2065 :                 return( EmitError( POP_CS_IS_NOT_ALLOWED ) );

	lea	ecx, QWORD PTR [r11+40]
	call	EmitError
	jmp	$LN1@process_re
$LN23@process_re:

; 2066 :             }
; 2067 :         }
; 2068 :     } else if ( flags & OP_ST ) {

	bt	edx, 15
	jae	SHORT $LN27@process_re

; 2069 : 
; 2070 :         regno = opndx[CurrOpnd].st_idx;

	mov	ecx, DWORD PTR [rcx]

; 2071 :         if ( regno > 7 ) { /* v1.96: index check added */

	cmp	ecx, 7
	jle	SHORT $LN29@process_re

; 2072 :             return( EmitError( INVALID_COPROCESSOR_REGISTER ) );

	mov	ecx, 252				; 000000fcH
	call	EmitError
	jmp	$LN1@process_re
$LN29@process_re:

; 2073 :         }
; 2074 :         CodeInfo->rm_byte |= regno;

	or	BYTE PTR [r10+104], cl

; 2075 :         if( regno != 0 )

	mov	edx, 65536				; 00010000H
	mov	eax, DWORD PTR [r8+32]
	test	ecx, ecx
	cmovne	eax, edx
	mov	DWORD PTR [r8+32], eax

; 2076 :             CodeInfo->opnd[CurrOpnd].type = OP_ST_REG;
; 2077 :         /* v2.06: exit, rm_byte is already set. */
; 2078 :         return( NOT_ERROR );

	jmp	$LN42@process_re
$LN27@process_re:

; 2079 : 
; 2080 :     } else if ( flags & OP_RSPEC ) { /* CRx, DRx, TRx */

	bt	edx, 12
	jae	SHORT $LN31@process_re

; 2081 :         if( CodeInfo->token != T_MOV ) {

	cmp	DWORD PTR [r10+24], 605			; 0000025dH
	je	SHORT $LN32@process_re

; 2082 :             return( EmitError( ONLY_MOV_CAN_USE_SPECIAL_REGISTER ) );

	mov	ecx, 42					; 0000002aH
	call	EmitError
	jmp	$LN1@process_re
$LN32@process_re:

; 2083 :         }
; 2084 :         /* v2.04: previously there were 3 flags, OP_CR, OP_DR and OP_TR.
; 2085 :          * this was summoned to one flag OP_RSPEC to free 2 flags, which
; 2086 :          * are needed if AVC ( new YMM registers ) is to be supported.
; 2087 :          * To distinguish between CR, DR and TR, the register number is
; 2088 :          * used now: CRx are numbers 0-F, DRx are numbers 0x10-0x1F and
; 2089 :          * TRx are 0x20-0x2F.
; 2090 :          */
; 2091 : 		if (regno >= 0x20) { /* TRx? */

	cmp	r11d, 32				; 00000020H
	jl	SHORT $LN33@process_re

; 2092 : 			CodeInfo->opc_or |= 0x04;

	or	BYTE PTR [r10+107], 4

; 2093 : 			/* TR3-TR5 are available on 486-586
; 2094 : 			* TR6+TR7 are available on 386-586
; 2095 : 			* v2.11: simplified.
; 2096 : 			*/
; 2097 : 			if ((ModuleInfo.curr_cpu & P_CPU_MASK) >= P_686) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 96					; 00000060H
	jl	SHORT $LN36@process_re

; 2098 : 				return(EmitErr(CANNOT_USE_TRN_TO_TRM_WITH_CURRENT_CPU_SETTING, regno > 0x25 ? 6 : 3, regno > 0x25 ? 7 : 5));

	mov	eax, 7
	cmp	r11d, 37				; 00000025H
	mov	r8d, 5
	mov	edx, 3
	cmovg	r8d, eax
	mov	eax, 6
	cmovg	edx, eax
	lea	ecx, QWORD PTR [rax+26]
	call	EmitErr
	jmp	$LN1@process_re
$LN33@process_re:

; 2099 : 			}
; 2100 : 		}
; 2101 : 		else if (regno >= 0x10) { /* DRx? */

	cmp	r11d, 16
	jl	SHORT $LN36@process_re

; 2102 : 			CodeInfo->opc_or |= 0x01;

	or	BYTE PTR [r10+107], 1
$LN36@process_re:

; 2103 : 		}
; 2104 : 		regno &= 0x0F;

	and	r11d, 15
$LN31@process_re:

; 2105 : 	}
; 2106 : #if AMD64_SUPPORT
; 2107 : 
; 2108 :     /* if it's a x86-64 register (SIL, R8W, R8D, RSI, ... */
; 2109 :     if ( ( SpecialTable[regtok].cpu & P_CPU_MASK ) == P_64 ) {

	movzx	eax, BYTE PTR SpecialTable[rbx+rbp+8]
	and	al, 240					; 000000f0H
	cmp	al, 112					; 00000070H
	jne	SHORT $LN38@process_re

; 2110 :         CodeInfo->prefix.rex |= 0x40;

	or	BYTE PTR [r10+8], 64			; 00000040H
	movzx	eax, BYTE PTR [r10+8]

; 2111 :         if ( flags & OP_R64 )

	test	dl, 8
	je	SHORT $LN38@process_re

; 2112 :             CodeInfo->prefix.rex |= REX_W;

	or	al, 8
	mov	BYTE PTR [r10+8], al
$LN38@process_re:

; 2113 :     }
; 2114 : #endif
; 2115 :     if( CurrOpnd == OPND1 ) {

	test	esi, esi
	jne	SHORT $LN39@process_re

; 2116 :         /* the first operand
; 2117 :          * r/m is treated as a 'reg' field */
; 2118 :         CodeInfo->rm_byte |= MOD_11;
; 2119 : #if AMD64_SUPPORT
; 2120 :         CodeInfo->prefix.rex |= (regno & 8 ) >> 3; /* set REX_B */

	mov	eax, r11d

; 2121 :         regno &= BIT_012;

	and	r11b, 7
	sar	eax, 3
	and	al, 1

; 2122 : #endif
; 2123 :         /* fill the r/m field */
; 2124 :         CodeInfo->rm_byte |= regno;

	or	r11b, 192				; 000000c0H

; 2125 :     } else {

	jmp	SHORT $LN46@process_re
$LN39@process_re:

; 2126 :         /* the second operand
; 2127 :          * XCHG can use short form if op1 is AX/EAX/RAX */
; 2128 :         if( ( CodeInfo->token == T_XCHG ) && ( CodeInfo->opnd[OPND1].type & OP_A ) &&

	cmp	DWORD PTR [r10+24], 665			; 00000299H
	jne	SHORT $LN41@process_re
	mov	eax, DWORD PTR [r10+32]
	and	eax, 513				; 00000201H
	cmp	eax, 512				; 00000200H
	jne	SHORT $LN41@process_re

; 2129 :              ( 0 == (CodeInfo->opnd[OPND1].type & OP_R8 ) ) ) {
; 2130 : #if AMD64_SUPPORT
; 2131 :             CodeInfo->prefix.rex |= (regno & 8 ) >> 3; /* set REX_B */
; 2132 :             regno &= BIT_012;
; 2133 : #endif
; 2134 :             CodeInfo->rm_byte = ( CodeInfo->rm_byte & BIT_67 ) | regno;

	and	BYTE PTR [r10+104], 192			; 000000c0H
	mov	eax, r11d
	sar	eax, 3
	and	al, 1
	and	r11b, 7

; 2135 :         } else {

	jmp	SHORT $LN46@process_re
$LN41@process_re:

; 2136 :             /* fill reg field with reg */
; 2137 : #if AMD64_SUPPORT
; 2138 :             CodeInfo->prefix.rex |= (regno & 8 ) >> 1; /* set REX_R */
; 2139 :             regno &= BIT_012;
; 2140 : #endif
; 2141 :             CodeInfo->rm_byte = ( CodeInfo->rm_byte & ~BIT_345 ) | ( regno << 3 );

	and	BYTE PTR [r10+104], 199			; 000000c7H
	mov	eax, r11d
	sar	eax, 1
	and	r11b, 7
	and	al, 4
	shl	r11b, 3
$LN46@process_re:
	or	BYTE PTR [r10+8], al
	or	BYTE PTR [r10+104], r11b
$LN42@process_re:

; 2142 :         }
; 2143 :     }
; 2144 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@process_re:

; 2145 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
process_register ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
;	COMDAT process_const
_TEXT	SEGMENT
CodeInfo$ = 8
CurrOpnd$ = 16
opndx$ = 24
process_const PROC					; COMDAT

; 1946 : #if 0 /* v2.06: obsolete */
; 1947 :     /* hack for IMUL: compress the operands so there are 2 only */
; 1948 :     if( ( CodeInfo->token == T_IMUL ) &&
; 1949 :        ( CodeInfo->opnd_type[OPND1] & OP_R ) ) {
; 1950 :         if( CurrOpnd == OPND2 ) {
; 1951 : #if AMD64_SUPPORT
; 1952 :             CodeInfo->prefix.rex |= ((CodeInfo->prefix.rex & REX_B) ? REX_R : 0);
; 1953 : #endif
; 1954 :             CodeInfo->rm_byte = ( CodeInfo->rm_byte & ~BIT_345 )
; 1955 :                           | ( ( CodeInfo->rm_byte & BIT_012 ) << 3 );
; 1956 :         } else if( CurrOpnd == OPND3 ) {
; 1957 :             /* v2.04b: if op2 was assumed an immediate due to fwd ref,
; 1958 :              * change it back to a mem ref now.
; 1959 :              */
; 1960 :             if ( ( CodeInfo->opnd_type[OPND2] & OP_I ) &&
; 1961 :                 CodeInfo->InsFixup[OPND2] &&
; 1962 :                 CodeInfo->InsFixup[OPND2]->sym->state == SYM_UNDEFINED )
; 1963 :                 CodeInfo->opnd_type[OPND2] = OP_M;
; 1964 :             CodeInfo->opnd_type[OPND1] = CodeInfo->opnd_type[OPND2];
; 1965 :             CodeInfo->opnd_type[OPND2] = OP_NONE;
; 1966 :             CodeInfo->data[OPND1] = CodeInfo->data[OPND2];
; 1967 :             CodeInfo->data[OPND2] = 0;
; 1968 :             CodeInfo->InsFixup[OPND1] = CodeInfo->InsFixup[OPND2];
; 1969 :             CodeInfo->InsFixup[OPND2] = NULL;
; 1970 :             CurrOpnd = OPND2;
; 1971 :         }
; 1972 :     }
; 1973 : #endif
; 1974 :     /* v2.11: don't accept an empty string */
; 1975 :     if ( opndx->quoted_string && opndx->quoted_string->stringlen == 0 )

	mov	rax, QWORD PTR [r8+16]
	mov	r9, rcx
	test	rax, rax
	je	SHORT $LN2@process_co
	cmp	DWORD PTR [rax+16], 0
	jne	SHORT $LN2@process_co

; 1976 :         return( EmitError( EMPTY_STRING ) );

	mov	ecx, 163				; 000000a3H
	jmp	EmitError
$LN2@process_co:

; 1977 : 
; 1978 :     /* optimization: skip <value> if it is 0 and instruction
; 1979 :      * is RET[W|D|N|F]. */
; 1980 :     /* v2.06: moved here and checked the opcode directly, so
; 1981 :      * RETD and RETW are also handled. */
; 1982 :     if ( ( ( CodeInfo->pinstr->opcode & 0xf7 ) == 0xc2 ) &&
; 1983 :         CurrOpnd == OPND1 && opndx->value == 0 ) {

	mov	rax, QWORD PTR [rcx+16]
	movzx	ecx, BYTE PTR [rax+12]
	and	cl, 247					; 000000f7H
	cmp	cl, 194					; 000000c2H
	jne	SHORT $LN3@process_co
	test	edx, edx
	jne	SHORT $LN3@process_co
	cmp	DWORD PTR [r8], edx
	jne	SHORT $LN3@process_co

; 1984 :         //     (CodeInfo.token == T_RET ||
; 1985 :         //      CodeInfo.token == T_RETN ||
; 1986 :         //      CodeInfo.token == T_RETF)) {
; 1987 :         //if ( opndx.sym == NULL || opndx.sym->state == SYM_INTERNAL ) {
; 1988 :         return( NOT_ERROR );

	xor	eax, eax

; 1991 : }

	ret	0
$LN3@process_co:

; 1989 :     }
; 1990 :     return( idata_nofixup( CodeInfo, CurrOpnd, opndx ) );

	mov	rcx, r9
	jmp	idata_nofixup
process_const ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
;	COMDAT process_address
_TEXT	SEGMENT
CodeInfo$ = 48
CurrOpnd$ = 56
opndx$ = 64
process_address PROC					; COMDAT

; 1802 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	rbx, r8

; 1803 :     if( opndx->indirect ) {  /* indirect register operand or stack var */

	mov	ecx, DWORD PTR [r8+72]
	mov	esi, edx
	test	cl, 1
	je	SHORT $LN7@process_ad

; 1804 : 
; 1805 :         DebugMsg1(("process_address: INDIRECT, sym=%s mbr=%s ci.adrsiz=%u\n",
; 1806 :                    opndx->sym ? opndx->sym->name : "NULL",
; 1807 :                    opndx->mbr ? opndx->mbr->name : "NULL",
; 1808 :                    CodeInfo->prefix.adrsiz ));
; 1809 :         /* if displacement doesn't fit in 32-bits:
; 1810 :          * Masm (both ML and ML64) just truncates.
; 1811 :          * HJWasm throws an error in 64bit mode and
; 1812 :          * warns (level 3) in the other modes.
; 1813 :          * todo: this check should also be done for direct addressing!
; 1814 :          */
; 1815 :         if ( opndx->hvalue && ( opndx->hvalue != -1 || opndx->value >= 0 ) ) {

	mov	eax, DWORD PTR [r8+4]
	test	eax, eax
	je	SHORT $LN9@process_ad
	cmp	eax, -1
	jne	SHORT $LN10@process_ad
	cmp	DWORD PTR [r8], 0
	jl	SHORT $LN9@process_ad
$LN10@process_ad:

; 1816 :             DebugMsg1(("process_address: displacement doesn't fit in 32 bits: %" I64_SPEC "X\n", opndx->value64 ));
; 1817 : #if AMD64_SUPPORT
; 1818 :             if ( ModuleInfo.Ofssize == USE64 ) {

	cmp	BYTE PTR ModuleInfo+404, 2
	jne	SHORT $LN11@process_ad

; 1819 :                 return( EmitConstError( opndx ) );

	mov	rcx, rbx

; 1937 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1819 :                 return( EmitConstError( opndx ) );

	jmp	EmitConstError
$LN11@process_ad:

; 1820 :             }
; 1821 : #endif
; 1822 :             EmitWarn( 3, DISPLACEMENT_OUT_OF_RANGE, opndx->value64 );

	mov	r8, QWORD PTR [r8]
	mov	edx, 54					; 00000036H
	lea	ecx, QWORD PTR [rdx-51]
	call	EmitWarn
$LN9@process_ad:

; 1823 :         }
; 1824 :         if( opndx->sym == NULL || opndx->sym->state == SYM_STACK ) {

	mov	rax, QWORD PTR [rbx+80]
	test	rax, rax
	je	SHORT $LN13@process_ad
	cmp	DWORD PTR [rax+32], 5
	jne	$LN44@process_ad
$LN13@process_ad:

; 1825 :             return( memory_operand( CodeInfo, CurrOpnd, opndx, FALSE ) );

	xor	r9d, r9d
	mov	r8, rbx
	mov	edx, esi
	mov	rcx, rdi

; 1937 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1825 :             return( memory_operand( CodeInfo, CurrOpnd, opndx, FALSE ) );

	jmp	memory_operand
$LN7@process_ad:

; 1826 :         }
; 1827 :         /* do default processing */
; 1828 : 
; 1829 :     } else if( opndx->instr != EMPTY ) {

	mov	eax, DWORD PTR [r8+56]
	cmp	eax, -2
	je	SHORT $LN14@process_ad

; 1830 :         /* instr is OFFSET | LROFFSET | SEG | LOW | LOWWORD, ... */
; 1831 :         DebugMsg1(("process_address: instr=%s\n", GetResWName( opndx->instr, NULL ) ));
; 1832 :         if( opndx->sym == NULL ) { /* better to check opndx->type? */

	cmp	QWORD PTR [r8+80], 0
	jne	SHORT $LN16@process_ad
$LN21@process_ad:

; 1833 :             return( idata_nofixup( CodeInfo, CurrOpnd, opndx ) );

	mov	rcx, rdi

; 1937 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1833 :             return( idata_nofixup( CodeInfo, CurrOpnd, opndx ) );

	jmp	idata_nofixup
$LN16@process_ad:

; 1834 :         } else {
; 1835 :             /* allow "lea <reg>, [offset <sym>]" */
; 1836 :             if( CodeInfo->token == T_LEA && opndx->instr == T_OFFSET )

	cmp	DWORD PTR [rdi+24], 633			; 00000279H
	jne	$LN18@process_ad
	cmp	eax, 241				; 000000f1H
	jne	$LN18@process_ad
$LN53@process_ad:

; 1837 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );

	mov	r9b, 1
	mov	rcx, rdi

; 1937 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1837 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );

	jmp	memory_operand
$LN14@process_ad:

; 1838 :             return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );
; 1839 :         }
; 1840 :     } else if( opndx->sym == NULL ) { /* direct operand without symbol */

	mov	rax, QWORD PTR [r8+80]
	test	rax, rax
	jne	SHORT $LN19@process_ad

; 1841 :         DebugMsg1(("process_address: symbol=NULL\n" ));
; 1842 :         if( opndx->override != NULL ) {

	mov	rax, QWORD PTR [r8+48]
	test	rax, rax
	je	SHORT $LN21@process_ad

; 1843 :             /* direct absolute memory without symbol.
; 1844 :              DS:[0] won't create a fixup, but
; 1845 :              DGROUP:[0] will create one! */
; 1846 : #if AMD64_SUPPORT
; 1847 :             /* for 64bit, always create a fixup, since RIP-relative addressing is used
; 1848 :              * v2.11: don't create fixup in 64-bit.
; 1849 :              */
; 1850 :             //if ( opndx->override->token == T_REG && CodeInfo->Ofssize != USE64 )
; 1851 :             if ( opndx->override->token == T_REG || CodeInfo->Ofssize == USE64 )

	cmp	BYTE PTR [rax], 2
	je	SHORT $LN25@process_ad
	cmp	BYTE PTR [rdi+106], 2
	jne	SHORT $LN53@process_ad
$LN25@process_ad:

; 1852 : #else
; 1853 :             if ( opndx->override->token == T_REG )
; 1854 : #endif
; 1855 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, FALSE ) );

	xor	r9d, r9d
	mov	rcx, rdi

; 1937 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1852 : #else
; 1853 :             if ( opndx->override->token == T_REG )
; 1854 : #endif
; 1855 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, FALSE ) );

	jmp	memory_operand
$LN19@process_ad:

; 1856 :             else
; 1857 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );
; 1858 :         } else {
; 1859 :             return( idata_nofixup( CodeInfo, CurrOpnd, opndx ) );
; 1860 :         }
; 1861 :     } else if( ( opndx->sym->state == SYM_UNDEFINED ) && !opndx->explicit ) {

	mov	eax, DWORD PTR [rax+32]
	test	eax, eax
	jne	$LN26@process_ad
	test	cl, 2
	jne	$LN26@process_ad

; 1862 :         DebugMsg1(("process_address: sym=SYM_UNDEFINED, name=%s, state=%X\n", opndx->sym->name, opndx->sym->state ));
; 1863 :         /* v2.04: unnecessary, the expression evaluator will have emitted an error already */
; 1864 :         //if( Parse_Pass != PASS_1 ) {
; 1865 :         //    EmitErr( SYMBOL_NOT_DEFINED, opndx->sym->name );
; 1866 :         //    return( ERROR );
; 1867 :         //}
; 1868 :         /* undefined symbol, it's not possible to determine
; 1869 :          * operand type and size currently. However, for backpatching
; 1870 :          * a fixup should be created.
; 1871 :          */
; 1872 :         /* assume a code label for branch instructions! */
; 1873 :         if( IS_ANY_BRANCH( CodeInfo->token ) )

	mov	ecx, DWORD PTR [rdi+24]
	lea	eax, DWORD PTR [rcx-454]
	cmp	eax, 49					; 00000031H
	ja	SHORT $LN28@process_ad

; 1874 :             return( process_branch( CodeInfo, CurrOpnd, opndx ) );

	mov	rcx, rdi

; 1937 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1874 :             return( process_branch( CodeInfo, CurrOpnd, opndx ) );

	jmp	process_branch
$LN28@process_ad:

; 1875 : 
; 1876 :         switch( CodeInfo->token ) {

	sub	ecx, 564				; 00000234H
	je	SHORT $LN29@process_ad
	sub	ecx, 36					; 00000024H
	je	SHORT $LN29@process_ad
	cmp	ecx, 2
	je	SHORT $LN29@process_ad

; 1884 :             }
; 1885 :             break;
; 1886 :         default:
; 1887 :             /* v2.04: if operand is the second argument (and the first is NOT
; 1888 :              * a segment register!), scan the
; 1889 :              * instruction table if the instruction allows an immediate!
; 1890 :              * If so, assume the undefined symbol is a constant.
; 1891 :              */
; 1892 :             if ( CurrOpnd == OPND2 && (( CodeInfo->opnd[OPND1].type & OP_SR ) == 0 ) ) {

	cmp	edx, 1
	jne	SHORT $LN5@process_ad
	test	DWORD PTR [rdi+32], 24576		; 00006000H
	jne	SHORT $LN44@process_ad

; 1893 :                 const struct instr_item  *p = CodeInfo->pinstr;

	mov	rdx, QWORD PTR [rdi+16]
	lea	r8, OFFSET FLAT:opnd_clstab+4
	npad	7
$LL6@process_ad:

; 1894 :                 do {
; 1895 :                     if ( opnd_clstab[p->opclsidx].opnd_type[OPND2] & OP_I ) {

	movzx	eax, BYTE PTR [rdx]
	lea	rcx, QWORD PTR [rax+rax*2]
	test	DWORD PTR [r8+rcx*4], 917504		; 000e0000H
	jne	SHORT $LN47@process_ad

; 1897 :                     }
; 1898 :                     p++;

	add	rdx, 14

; 1899 :                 } while ( p->first == FALSE );

	cmp	BYTE PTR [rdx+4], 0
	je	SHORT $LL6@process_ad
	jmp	SHORT $LN44@process_ad
$LN47@process_ad:

; 1896 :                         return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	mov	r8, rbx
	mov	edx, 1
	jmp	$LN18@process_ad
$LN5@process_ad:

; 1900 :             }
; 1901 :             /* v2.10: if current operand is the third argument, always assume an immediate */
; 1902 :             if ( CurrOpnd == OPND3 )

	cmp	edx, 2
	jne	SHORT $LN44@process_ad

; 1903 :                 return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	jmp	SHORT $LN18@process_ad
$LN29@process_ad:

; 1877 :         case T_PUSH:
; 1878 :         case T_PUSHW:
; 1879 :         case T_PUSHD:
; 1880 :             /* v2.0: don't assume immediate operand if cpu is 8086 */
; 1881 :             if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) > P_86 ) {

	test	DWORD PTR ModuleInfo+392, 240		; 000000f0H
	jle	SHORT $LN44@process_ad

; 1882 :                 //return( idata_nofixup( CodeInfo, opndx ) ); /* v1.96: changed */
; 1883 :                 return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	jmp	SHORT $LN18@process_ad
$LN26@process_ad:
	add	eax, -3					; fffffffdH
	cmp	eax, 1
	jbe	SHORT $LN37@process_ad

; 1914 :     } else {
; 1915 :         DebugMsg1(("process_address direct, sym=%s sym.memtype=%X opndx.memtype=%X\n", opndx->sym->name, opndx->sym->mem_type, opndx->mem_type ));
; 1916 : 
; 1917 :         /* symbol external, but absolute? */
; 1918 :         if( opndx->is_abs ) {

	test	cl, 4
	jne	SHORT $LN18@process_ad
	mov	eax, DWORD PTR [r8+64]
	sub	eax, 129				; 00000081H
	cmp	eax, 1
	jbe	SHORT $LN40@process_ad
$LN44@process_ad:

; 1930 :             } else {
; 1931 :                 return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );
; 1932 :             }
; 1933 :         }
; 1934 :     }
; 1935 :     /* default processing: memory with fixup */
; 1936 :     return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );

	mov	r9b, 1
	mov	r8, rbx
	mov	edx, esi
	mov	rcx, rdi

; 1937 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1930 :             } else {
; 1931 :                 return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );
; 1932 :             }
; 1933 :         }
; 1934 :     }
; 1935 :     /* default processing: memory with fixup */
; 1936 :     return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );

	jmp	memory_operand
$LN40@process_ad:

; 1919 :             return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );
; 1920 :         }
; 1921 : 
; 1922 :         /* CODE location is converted to OFFSET symbol */
; 1923 :         if ( opndx->mem_type == MT_NEAR || opndx->mem_type == MT_FAR ) {
; 1924 :             if( CodeInfo->token == T_LEA ) {

	cmp	DWORD PTR [rdi+24], 633			; 00000279H
	je	$LN53@process_ad

; 1925 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );
; 1926 :             //} else if( opndx->sym == &symPC ) {
; 1927 :             //    return( idata_fixup( CodeInfo, opndx ) );
; 1928 :             } else if( opndx->mbr != NULL ) { /* structure field? */

	cmp	QWORD PTR [r8+88], 0

; 1929 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );

	mov	rcx, rdi
	je	SHORT $LN43@process_ad
	mov	r9b, 1

; 1937 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1929 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );

	jmp	memory_operand
$LN37@process_ad:

; 1904 :         }
; 1905 :         /* do default processing */
; 1906 : 
; 1907 :     } else if( ( opndx->sym->state == SYM_SEG ) ||
; 1908 :                ( opndx->sym->state == SYM_GRP ) ) {
; 1909 :         DebugMsg1(("process_address: sym->state=SEG/GROUP\n"));
; 1910 :         /* SEGMENT and GROUP symbol is converted to SEG symbol
; 1911 :          * for next processing */
; 1912 :         opndx->instr = T_SEG;

	mov	DWORD PTR [r8+56], 244			; 000000f4H
$LN18@process_ad:

; 1913 :         return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	mov	rcx, rdi
$LN43@process_ad:

; 1937 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1913 :         return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	jmp	idata_fixup
process_address ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
;	COMDAT memory_operand
_TEXT	SEGMENT
tv1052 = 112
CodeInfo$ = 112
CurrOpnd$ = 120
opndx$ = 128
with_fixup$ = 136
memory_operand PROC					; COMDAT

; 1427 : {

	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+16], edx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	sub	rsp, 56					; 00000038H
	mov	eax, edx
	mov	rbx, rcx

; 1428 :     char                ss = SCALE_FACTOR_1;
; 1429 :     int                 index;
; 1430 :     int                 base;
; 1431 :     int                 j;
; 1432 :     struct asym         *sym;
; 1433 :     uint_8              Ofssize;
; 1434 :     enum fixup_types    fixup_type;
; 1435 : 
; 1436 :     DebugMsg1(("memory_operand(opndx.value=%X / sym=%s / memtype=%Xh, with_fixup=%u) enter, [CodeInfo->memtype=%Xh, Ofssize=%u, adrsiz=%u]\n",
; 1437 :                opndx->value, opndx->sym ? opndx->sym->name : "NULL", opndx->mem_type, with_fixup, CodeInfo->mem_type, CodeInfo->Ofssize, CodeInfo->prefix.adrsiz ));
; 1438 : 
; 1439 :     /* v211: use full 64-bit value */
; 1440 :     //CodeInfo->opnd[CurrOpnd].data = opndx->value;
; 1441 :     CodeInfo->opnd[CurrOpnd].data64 = opndx->value64;

	mov	QWORD PTR tv1052[rsp], rax

; 1442 :     CodeInfo->opnd[CurrOpnd].type = OP_M;
; 1443 : 
; 1444 :     sym = opndx->sym;
; 1445 : 
; 1446 :     segm_override( opndx, CodeInfo );

	mov	rdx, rcx
	mov	rsi, r8
	lea	rax, QWORD PTR [rax+rax*2]
	lea	rbp, QWORD PTR [rcx+rax*8]
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rbp+40], rax
	mov	rcx, r8
	mov	DWORD PTR [rbp+32], -1887436800		; ffffffff8f800000H
	mov	r13, QWORD PTR [r8+80]
	call	segm_override

; 1447 : 
; 1448 :     /* change pointer types ( MT_NEAR, MT_FAR, MT_PTR */
; 1449 :     /* v2.04a: should not be called if OFFSET was used */
; 1450 :     //if ( opndx->mem_type == MT_PTR ) /* this was before v2.04 */
; 1451 :     //if ( ( opndx->mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS )
; 1452 :     /* v2.05: change reverted */
; 1453 :     //if ( ( opndx->mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS && opndx->instr == EMPTY )
; 1454 :     if ( opndx->mem_type == MT_PTR )

	mov	eax, DWORD PTR [rsi+64]
	cmp	eax, 195				; 000000c3H
	jne	SHORT $LN10@memory_ope

; 1455 :         SetPtrMemtype( CodeInfo, opndx );

	mov	rdx, rsi
	mov	rcx, rbx
	call	SetPtrMemtype
	jmp	SHORT $LN12@memory_ope
$LN10@memory_ope:

; 1456 :     else if ( ( opndx->mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS ) {

	and	eax, 192				; 000000c0H
	cmp	al, -128				; ffffffffffffff80H
	jne	SHORT $LN12@memory_ope

; 1457 :         int size;
; 1458 :         if ( opndx->Ofssize == USE_EMPTY && sym )

	cmp	BYTE PTR [rsi+69], 254			; 000000feH
	jne	SHORT $LN13@memory_ope
	test	r13, r13
	je	SHORT $LN13@memory_ope

; 1459 :             opndx->Ofssize = GetSymOfssize( sym );

	mov	rcx, r13
	call	GetSymOfssize
	mov	BYTE PTR [rsi+69], al
$LN13@memory_ope:

; 1460 :         /* v2.09: use opndx->type ( for MT_PROC ) */
; 1461 :         //size = SizeFromMemtype( opndx->mem_type, opndx->Ofssize, NULL );
; 1462 :         size = SizeFromMemtype( opndx->mem_type, opndx->Ofssize, opndx->type );

	movzx	edx, BYTE PTR [rsi+69]
	mov	r8, QWORD PTR [rsi+96]
	mov	ecx, DWORD PTR [rsi+64]
	call	SizeFromMemtype
	mov	ecx, eax

; 1463 :         MemtypeFromSize( size, &opndx->mem_type );

	lea	rdx, QWORD PTR [rsi+64]
	call	MemtypeFromSize
$LN12@memory_ope:

; 1464 :     }
; 1465 : 
; 1466 :     Set_Memtype( CodeInfo, opndx->mem_type );

	mov	edx, DWORD PTR [rsi+64]
	mov	rcx, rbx
	call	Set_Memtype

; 1467 :     if( opndx->mbr != NULL ) {

	mov	rax, QWORD PTR [rsi+88]
	lea	r11, OFFSET FLAT:__ImageBase
	mov	edi, 3
	test	rax, rax
	je	$LN19@memory_ope

; 1468 :         /* if the struct field is just another struct, use it's total size
; 1469 :          * to set CodeInfo->mem_type.
; 1470 :          */
; 1471 :         //if ( opndx->mbr->mem_type == MT_TYPE ) {
; 1472 :         /* v2: don't overwrite opndx->mem_type,
; 1473 :          *    testcase: cmp (dword ptr <struct_field>), 0
; 1474 :          */
; 1475 :         if ( opndx->mbr->mem_type == MT_TYPE && opndx->mem_type == MT_EMPTY ) {

	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN125@memory_ope
	cmp	DWORD PTR [rsi+64], 192			; 000000c0H
	jne	SHORT $LN125@memory_ope

; 1476 :             enum memtype mem_type;
; 1477 :             DebugMsg1(("memory_operand: mbr %s has mem_type MT_TYPE, total_size=%u\n", opndx->mbr->name, opndx->mbr->total_size ));
; 1478 : #if AVXSUPP
; 1479 :             if (CodeInfo->token == T_VMOVSS){       //MemtypeFromSize returns OP_M128

	cmp	DWORD PTR [rbx+24], 1944		; 00000798H
	jne	SHORT $LN16@memory_ope

; 1480 :               mem_type = MT_DWORD;                  //but we need MT_DWORD ;habran
; 1481 :               Set_Memtype(CodeInfo, mem_type);

	mov	edx, edi

; 1482 :          }

	jmp	SHORT $LN136@memory_ope
$LN16@memory_ope:

; 1483 :         else
; 1484 : #endif
; 1485 :             if ( MemtypeFromSize( opndx->mbr->total_size, &mem_type ) == NOT_ERROR )

	cmp	BYTE PTR SpecialTable+2471, 6
	mov	r8d, DWORD PTR [rax+56]
	jne	SHORT $LN125@memory_ope
	mov	edx, 205				; 000000cdH
	mov	eax, 2460				; 0000099cH
$LL113@memory_ope:
	movzx	ecx, BYTE PTR SpecialTable[rax+r11+10]
	test	cl, cl
	js	SHORT $LN111@memory_ope
	movzx	eax, cl
	and	eax, 31
	inc	eax
	cmp	eax, r8d
	je	SHORT $LN118@memory_ope
$LN111@memory_ope:
	inc	rdx
	lea	rax, QWORD PTR [rdx+rdx*2]
	lea	rax, QWORD PTR [rax*4]
	cmp	BYTE PTR SpecialTable[rax+r11+11], 6
	je	SHORT $LL113@memory_ope
	jmp	SHORT $LN125@memory_ope
$LN118@memory_ope:
	movzx	edx, cl
$LN136@memory_ope:

; 1486 :                 Set_Memtype( CodeInfo, mem_type );

	mov	rcx, rbx
	call	Set_Memtype
$LN125@memory_ope:

; 1487 :         }
; 1488 :         //else  /* v2: obsolete */
; 1489 :         //    Set_Memtype( CodeInfo, opndx->mbr->mem_type );
; 1490 :         /* v2.06b: tell codegen that the member is a forward ref */
; 1491 :         if ( opndx->mbr->state == SYM_UNDEFINED )

	mov	rax, QWORD PTR [rsi+88]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN19@memory_ope

; 1492 :             CodeInfo->undef_sym = TRUE;

	or	BYTE PTR [rbx+142], 64			; 00000040H
$LN19@memory_ope:

; 1493 :     }
; 1494 : 
; 1495 :     /* instruction-specific handling */
; 1496 :     switch ( CodeInfo->token ) {

	mov	eax, DWORD PTR [rbx+24]
	add	eax, -454				; fffffe3aH
	mov	QWORD PTR [rsp+128], r14
	mov	QWORD PTR [rsp+48], r15
	cmp	eax, 1
	ja	$LN25@memory_ope

; 1497 :     case T_JMP:
; 1498 :     case T_CALL:
; 1499 :         /* the 2 branch instructions are peculiar because they
; 1500 :          * will work with an unsized label.
; 1501 :          */
; 1502 :         /* v1.95: convert MT_NEAR/MT_FAR and display error if no type.
; 1503 :          * For memory operands, expressions of type MT_NEAR/MT_FAR are
; 1504 :          * call [bx+<code_label>]
; 1505 :          */
; 1506 :         if ( CodeInfo->mem_type == MT_EMPTY ) {

	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	jne	SHORT $LN21@memory_ope

; 1507 :             /* with -Zm, no size needed for indirect CALL/JMP */
; 1508 :             if ( ModuleInfo.m510 == FALSE &&

	test	BYTE PTR ModuleInfo+408, 64		; 00000040H
	jne	SHORT $LN22@memory_ope
	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN22@memory_ope
	cmp	QWORD PTR [rsi+80], 0
	jne	SHORT $LN22@memory_ope
$LN138@memory_ope:

; 1509 :                 ( Parse_Pass > PASS_1 && opndx->sym == NULL ) ) {
; 1510 :                 DebugMsg1(("memory_operand, JMP/CALL: CodeInfo->memtype=empty, instruction operand must have size\n" ));
; 1511 :                 return( EmitError( INSTRUCTION_OPERAND_MUST_HAVE_SIZE ) );

	mov	ecx, 182				; 000000b6H
	call	EmitError
	jmp	$LN1@memory_ope
$LN22@memory_ope:

; 1512 :             }
; 1513 : #if AMD64_SUPPORT
; 1514 :             opndx->mem_type = (CodeInfo->Ofssize == USE64) ? MT_QWORD : (CodeInfo->Ofssize == USE32) ? MT_DWORD : MT_WORD;

	movzx	eax, BYTE PTR [rbx+106]
	cmp	al, 2
	jne	SHORT $LN100@memory_ope
	mov	edx, 7
	jmp	SHORT $LN101@memory_ope
$LN100@memory_ope:
	mov	edx, 1
	cmp	al, dl
	cmove	edx, edi
$LN101@memory_ope:

; 1515 : #else
; 1516 :             opndx->mem_type = (CodeInfo->Ofssize == USE32) ? MT_DWORD : MT_WORD;
; 1517 : #endif
; 1518 :             Set_Memtype( CodeInfo, opndx->mem_type );

	mov	rcx, rbx
	mov	DWORD PTR [rsi+64], edx
	call	Set_Memtype
$LN21@memory_ope:

; 1519 :             DebugMsg1(("memory_operand, JMP/CALL: CodeInfo->memtype set to %Xh\n", CodeInfo->mem_type ));
; 1520 :         }
; 1521 :         j = SizeFromMemtype( CodeInfo->mem_type, CodeInfo->Ofssize, NULL );

	movzx	r14d, BYTE PTR [rbx+106]
	xor	r8d, r8d
	mov	r15d, DWORD PTR [rbx+28]
	mov	edx, r14d
	mov	ecx, r15d
	call	SizeFromMemtype

; 1522 :         if ( ( j == 1 || j > 6 )
; 1523 : #if AMD64_SUPPORT
; 1524 :             && ( CodeInfo->Ofssize != USE64 )

	cmp	eax, 1
	je	SHORT $LN24@memory_ope
	cmp	eax, 6
	jle	SHORT $LN23@memory_ope
$LN24@memory_ope:
	cmp	r14b, 2
	je	SHORT $LN23@memory_ope

; 1525 : #endif
; 1526 :         ) {
; 1527 :             /* CALL/JMP possible for WORD/DWORD/FWORD memory operands only */
; 1528 :             DebugMsg1(("memory_operand: invalid operand, size=%u\n", j ));
; 1529 :             return( EmitError( INVALID_OPERAND_SIZE ) );

	mov	ecx, 71					; 00000047H
	call	EmitError
	jmp	$LN1@memory_ope
$LN23@memory_ope:

; 1530 :         }
; 1531 : 
; 1532 :         if( opndx->mem_type == MT_FAR || CodeInfo->mem_type == MT_FWORD ||
; 1533 : #if AMD64_SUPPORT
; 1534 :            ( CodeInfo->mem_type == MT_TBYTE && CodeInfo->Ofssize == USE64 ) ||

	cmp	DWORD PTR [rsi+64], 130			; 00000082H
	je	SHORT $LN28@memory_ope
	cmp	r15d, 5
	je	SHORT $LN28@memory_ope
	cmp	r15d, 9
	jne	SHORT $LN27@memory_ope
	cmp	r14b, 2
	je	SHORT $LN28@memory_ope
$LN27@memory_ope:
	cmp	r15d, edi
	jne	SHORT $LN135@memory_ope
	test	r14b, r14b
	jne	SHORT $LN29@memory_ope
	cmp	BYTE PTR [rsi+69], 1
	jne	SHORT $LN28@memory_ope
$LN29@memory_ope:
	cmp	r14b, 1
	jne	SHORT $LN135@memory_ope
	cmp	BYTE PTR [rsi+69], 0
	jne	SHORT $LN135@memory_ope
$LN28@memory_ope:

; 1535 : #endif
; 1536 :             ( CodeInfo->mem_type == MT_DWORD &&
; 1537 :               (( CodeInfo->Ofssize == USE16 && opndx->Ofssize != USE32 ) ||
; 1538 :                ( CodeInfo->Ofssize == USE32 && opndx->Ofssize == USE16 )))) {
; 1539 :             CodeInfo->isfar = TRUE;

	or	BYTE PTR [rbx+142], 4
$LN135@memory_ope:
	lea	r11, OFFSET FLAT:__ImageBase
$LN25@memory_ope:

; 1540 :         }
; 1541 :         DebugMsg1(("memory_operand: JMP/CALL, CodeInfo->far=%u\n", CodeInfo->isfar ));
; 1542 :         break;
; 1543 :     }
; 1544 : 
; 1545 :     if ( ( CodeInfo->mem_type & MT_SPECIAL) == 0 ) {

	mov	eax, DWORD PTR [rbx+28]
	test	al, al
	js	SHORT $LN30@memory_ope

; 1546 :         switch ( CodeInfo->mem_type & MT_SIZE_MASK ) {

	and	eax, 31
	cmp	eax, 63					; 0000003fH
	ja	$LN43@memory_ope
	cdqe
	movzx	eax, BYTE PTR $LN126@memory_ope[r11+rax]
	mov	ecx, DWORD PTR $LN127@memory_ope[r11+rax*4]
	add	rcx, r11
	jmp	rcx
$LN32@memory_ope:

; 1547 :             /* size is encoded 0-based */
; 1548 :         case  0:  CodeInfo->opnd[CurrOpnd].type = OP_M08;  break;

	mov	DWORD PTR [rbp+32], 8388608		; 00800000H
	jmp	$LN43@memory_ope
$LN33@memory_ope:

; 1549 :         case  1:  CodeInfo->opnd[CurrOpnd].type = OP_M16;  break;

	mov	DWORD PTR [rbp+32], 16777216		; 01000000H
	jmp	$LN43@memory_ope
$LN34@memory_ope:

; 1550 :         case  3:  CodeInfo->opnd[CurrOpnd].type = OP_M32;  break;

	mov	DWORD PTR [rbp+32], 33554432		; 02000000H
	jmp	SHORT $LN43@memory_ope
$LN35@memory_ope:

; 1551 :         case  5:  CodeInfo->opnd[CurrOpnd].type = OP_M48;  break;

	mov	DWORD PTR [rbp+32], 1073741824		; 40000000H
	jmp	SHORT $LN43@memory_ope
$LN36@memory_ope:

; 1552 :         case  7:  CodeInfo->opnd[CurrOpnd].type = OP_M64;  break;

	mov	DWORD PTR [rbp+32], 67108864		; 04000000H
	jmp	SHORT $LN43@memory_ope
$LN37@memory_ope:

; 1553 :         case  9:  CodeInfo->opnd[CurrOpnd].type = OP_M80;  break;

	mov	DWORD PTR [rbp+32], -2147483648		; ffffffff80000000H
	jmp	SHORT $LN43@memory_ope
$LN38@memory_ope:

; 1554 :         case 15:  CodeInfo->opnd[CurrOpnd].type = OP_M128; break;

	mov	DWORD PTR [rbp+32], 134217728		; 08000000H
	jmp	SHORT $LN43@memory_ope
$LN39@memory_ope:

; 1555 : #if AVXSUPP
; 1556 :         case 31:  CodeInfo->opnd[CurrOpnd].type = OP_M256; break;

	mov	DWORD PTR [rbp+32], 268435456		; 10000000H
	jmp	SHORT $LN43@memory_ope
$LN40@memory_ope:

; 1557 :         case 63:  CodeInfo->opnd[CurrOpnd].type = OP_M512; break;

	mov	DWORD PTR [rbp+32], 536870912		; 20000000H

; 1558 : #endif
; 1559 : #ifdef DEBUG_OUT
; 1560 :         default:
; 1561 :             DebugMsg1(("memory_operand: unexpected mem_type=%X\n", CodeInfo->mem_type ));
; 1562 :             /**/myassert( 0 );
; 1563 : #endif
; 1564 :         }
; 1565 : #if 0 /* v2.06: the wide flag isn't set for memory operands currently, */
; 1566 :         if ( CodeInfo->opnd_type[CurrOpnd] & ( OP_M16 | OP_M32 | OP_M64 ) )
; 1567 :             CodeInfo->iswide = 1;
; 1568 : #endif
; 1569 :     } else if ( CodeInfo->mem_type == MT_EMPTY ) {

	jmp	SHORT $LN43@memory_ope
$LN30@memory_ope:
	cmp	eax, 192				; 000000c0H
	jne	SHORT $LN43@memory_ope

; 1570 :         /* v2.05: added */
; 1571 :         switch ( CodeInfo->token ) {

	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 598				; 00000256H
	jl	SHORT $LN43@memory_ope
	cmp	eax, 599				; 00000257H
	jle	SHORT $LN42@memory_ope
	cmp	eax, 601				; 00000259H
	jg	SHORT $LN43@memory_ope

; 1576 :                 return( EmitError( INSTRUCTION_OPERAND_MUST_HAVE_SIZE ) );
; 1577 :             }
; 1578 :             break;
; 1579 :         case T_PUSH:
; 1580 :         case T_POP:
; 1581 :             if ( opndx->mem_type == MT_TYPE ) {

	cmp	DWORD PTR [rsi+64], 196			; 000000c4H
	jne	SHORT $LN43@memory_ope

; 1582 :                 return( EmitError( INVALID_INSTRUCTION_OPERANDS ) );

	mov	ecx, 49					; 00000031H
	call	EmitError
	jmp	$LN1@memory_ope
$LN42@memory_ope:

; 1572 :         case T_INC:
; 1573 :         case T_DEC:
; 1574 :             /* hjwasm v1.94-v2.04 accepted unsized operand for INC/DEC */
; 1575 :             if ( opndx->sym == NULL ) {

	cmp	QWORD PTR [rsi+80], 0
	je	$LN138@memory_ope
$LN43@memory_ope:

; 1583 :             }
; 1584 :             break;
; 1585 :         }
; 1586 :     }
; 1587 : 
; 1588 :     base = ( opndx->base_reg ? opndx->base_reg->tokval : EMPTY );

	mov	rax, QWORD PTR [rsi+24]
	mov	ebp, -2
	test	rax, rax
	je	SHORT $LN102@memory_ope
	mov	r14d, DWORD PTR [rax+16]
	jmp	SHORT $LN103@memory_ope
$LN102@memory_ope:
	mov	r14d, ebp
$LN103@memory_ope:

; 1589 :     index = ( opndx->idx_reg ? opndx->idx_reg->tokval : EMPTY );

	mov	rax, QWORD PTR [rsi+32]
	test	rax, rax
	je	SHORT $LN104@memory_ope
	mov	ebp, DWORD PTR [rax+16]
$LN104@memory_ope:

; 1590 :     CodeInfo->indexreg = GetRegNo( index );

	movsxd	rax, ebp
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rdx, QWORD PTR [rcx*4]
	movzx	eax, BYTE PTR SpecialTable[rdx+r11+10]
	mov	BYTE PTR [rbx+112], al

; 1591 :     CodeInfo->basereg = GetRegNo( base );

	movsxd	rax, r14d
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR SpecialTable[r11+rcx*4+10]
	mov	BYTE PTR [rbx+113], al

; 1592 :     /* use base + index from here - don't use opndx-> base_reg/idx_reg! */
; 1593 : 
; 1594 : #if 0 /* v2.10: moved to expreval.c */
; 1595 :     if ( sym && sym->state == SYM_STACK ) {
; 1596 :         if( base != EMPTY ) {
; 1597 :             if( index != EMPTY ) {
; 1598 :                 /* no free index register */
; 1599 :                 return( EmitError( MULTIPLE_INDEX_REGISTERS_NOT_ALLOWED ) );
; 1600 :             } else {
; 1601 :                 index = base;
; 1602 :             }
; 1603 :         }
; 1604 :         base = basereg[CodeInfo->Ofssize];
; 1605 :     }
; 1606 : #endif
; 1607 : 
; 1608 :     /* check for base registers */
; 1609 : 
; 1610 :     if ( base != EMPTY ) {

	cmp	r14d, -2
	je	SHORT $LN52@memory_ope

; 1611 :         if ( ( ( GetValueSp( base ) & OP_R32) && CodeInfo->Ofssize == USE32 ) ||
; 1612 : #if AMD64_SUPPORT
; 1613 :             ( ( GetValueSp( base ) & OP_R64) && CodeInfo->Ofssize == USE64 ) ||

	mov	eax, DWORD PTR SpecialTable[r11+rcx*4]
	test	al, 4
	je	SHORT $LN50@memory_ope
	cmp	BYTE PTR [rbx+106], 1
	je	SHORT $LN49@memory_ope
$LN50@memory_ope:
	test	al, 8
	je	SHORT $LN51@memory_ope
	cmp	BYTE PTR [rbx+106], 2
	je	SHORT $LN49@memory_ope
$LN51@memory_ope:
	test	al, 2
	je	SHORT $LN47@memory_ope
	cmp	BYTE PTR [rbx+106], 0
	jne	SHORT $LN47@memory_ope
$LN49@memory_ope:

; 1614 : #endif
; 1615 :             ( ( GetValueSp( base ) & OP_R16) && CodeInfo->Ofssize == USE16 ) )
; 1616 :             CodeInfo->prefix.adrsiz = FALSE;

	and	BYTE PTR [rbx+9], 254			; 000000feH
$LN52@memory_ope:

; 1623 :             }
; 1624 : #endif
; 1625 :         }
; 1626 :     }
; 1627 : 
; 1628 :     /* check for index registers */
; 1629 : 
; 1630 :     if( index != EMPTY ) {

	cmp	ebp, -2
	je	$LN130@memory_ope

; 1631 :         if ( ( ( GetValueSp( index ) & OP_R32) && CodeInfo->Ofssize == USE32 ) ||
; 1632 : #if AMD64_SUPPORT
; 1633 :             ( ( GetValueSp( index ) & OP_R64) && CodeInfo->Ofssize == USE64 ) ||

	mov	eax, DWORD PTR SpecialTable[rdx+r11]
	test	al, 4
	je	SHORT $LN57@memory_ope
	cmp	BYTE PTR [rbx+106], 1
	je	SHORT $LN56@memory_ope
$LN57@memory_ope:
	test	al, 8
	je	SHORT $LN58@memory_ope
	cmp	BYTE PTR [rbx+106], 2
	je	SHORT $LN56@memory_ope
$LN58@memory_ope:
	test	al, 2
	je	SHORT $LN54@memory_ope
	cmp	BYTE PTR [rbx+106], 0
	jne	SHORT $LN54@memory_ope
$LN56@memory_ope:

; 1634 : #endif
; 1635 :             ( ( GetValueSp( index ) & OP_R16) && CodeInfo->Ofssize == USE16 ) ) {
; 1636 :             CodeInfo->prefix.adrsiz = FALSE;

	and	BYTE PTR [rbx+9], 254			; 000000feH

; 1637 :         } else {

	jmp	SHORT $LN55@memory_ope
$LN47@memory_ope:

; 1617 :         else {
; 1618 :             CodeInfo->prefix.adrsiz = TRUE;

	or	BYTE PTR [rbx+9], 1

; 1619 : #if AMD64_SUPPORT
; 1620 :             /* 16bit addressing modes don't exist in long mode */
; 1621 :             if ( ( GetValueSp( base ) & OP_R16) && CodeInfo->Ofssize == USE64 ) {

	test	BYTE PTR SpecialTable[r11+rcx*4], 2
	je	SHORT $LN52@memory_ope
	cmp	BYTE PTR [rbx+106], 2
	jne	SHORT $LN52@memory_ope
$LN66@memory_ope:

; 1622 :                 return( EmitError( INVALID_ADDRESSING_MODE_WITH_CURRENT_CPU_SETTING ) );

	mov	ecx, 31
	call	EmitError
	jmp	$LN1@memory_ope
$LN54@memory_ope:

; 1638 :             CodeInfo->prefix.adrsiz = TRUE;

	or	BYTE PTR [rbx+9], 1
$LN55@memory_ope:

; 1639 :         }
; 1640 : 
; 1641 :         /* v2.10: register swapping has been moved to expreval.c, index_connect().
; 1642 :          * what has remained here is the check if R/ESP is used as index reg.
; 1643 :          */
; 1644 : 		if ((GetRegNo(index) == 4)

	cmp	BYTE PTR SpecialTable[rdx+r11+10], 4
	jne	SHORT $LN59@memory_ope

; 1645 : #if 0
; 1646 : 			&& (GetResWName(index, NULL) <= T_RBP)
; 1647 : #endif
; 1648 : 			) { /* [E|R]SP? */
; 1649 : 			
; 1650 : 				//if ( (GetRegNo( index ) == 4) && (GetResWName( index, NULL ) <= T_RBP )) { /* [E|R]SP? */ /* Removed in 2.13 in favour of above */
; 1651 : 
; 1652 :             DebugMsg(( "memory_operand: error, base regno=%u, index regno=%u, opnd.scale=%u\n", GetRegNo( base ), GetRegNo( index ), opndx->scale ));
; 1653 :             //int tmp = index;
; 1654 :             if( opndx->scale ) { /* no scale must be set */

	cmp	BYTE PTR [rsi+68], 0
	je	SHORT $LN60@memory_ope

; 1655 :                 EmitErr( CANNOT_BE_USED_AS_INDEX_REGISTER, GetResWName( index, NULL ) );

	xor	edx, edx
	mov	ecx, ebp
	call	GetResWName
	mov	rdx, rax
	mov	ecx, 37					; 00000025H
	call	EmitErr

; 1660 :                 //return( ERROR );
; 1661 :             }
; 1662 :             return( ERROR );

	or	eax, -1
	jmp	$LN1@memory_ope
$LN60@memory_ope:

; 1656 :                 //return( ERROR );
; 1657 :             } else {
; 1658 :             //if ( GetRegNo( base ) == 4 ) {
; 1659 :                 EmitErr( MULTIPLE_BASE_REGISTERS_NOT_ALLOWED );

	mov	ecx, 29
	call	EmitErr
$LN61@memory_ope:

; 1660 :                 //return( ERROR );
; 1661 :             }
; 1662 :             return( ERROR );

	or	eax, -1
	jmp	$LN1@memory_ope
$LN59@memory_ope:

; 1663 :             /* swap base and index */
; 1664 :             //index = base;
; 1665 :             //base = tmp;
; 1666 : #if 0
; 1667 :         } else if ( Options.masm_compat_gencode && opndx->scale == 0 && GetRegNo( base ) != 4 ) {
; 1668 :             /* v2.08: Masm 6+ swaps base and index, even if -Zm is set (Masm 5.1 does NOT swap) */
; 1669 :             int tmp = index;
; 1670 :             /* swap base and index */
; 1671 :             index = base;
; 1672 :             base = tmp;
; 1673 : #endif
; 1674 :         }
; 1675 : 
; 1676 :         /* 32/64 bit indirect addressing? */
; 1677 :         if( ( CodeInfo->Ofssize == USE16 && CodeInfo->prefix.adrsiz == 1 ) ||
; 1678 : #if AMD64_SUPPORT
; 1679 :            CodeInfo->Ofssize == USE64  ||

	movzx	eax, BYTE PTR [rbx+106]
	test	al, al
	jne	SHORT $LN65@memory_ope
	test	BYTE PTR [rbx+9], 1
	jne	SHORT $LN64@memory_ope
$LN65@memory_ope:
	cmp	al, 2
	je	SHORT $LN64@memory_ope
	cmp	al, 1
	jne	SHORT $LN62@memory_ope
	test	BYTE PTR [rbx+9], al
	je	SHORT $LN64@memory_ope
$LN62@memory_ope:

; 1698 :             /* v2.01: 16-bit addressing mode. No scale possible */
; 1699 :             if ( opndx->scale ) {

	cmp	BYTE PTR [rsi+68], 0
	je	SHORT $LN130@memory_ope

; 1700 :                 return( EmitError( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	EmitError
	jmp	$LN1@memory_ope
$LN64@memory_ope:

; 1680 : #endif
; 1681 :            ( CodeInfo->Ofssize == USE32 && CodeInfo->prefix.adrsiz == 0 ) ) {
; 1682 :             if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	$LN66@memory_ope

; 1683 :                 /* scale, 0 or 1->00, 2->40, 4->80, 8->C0 */
; 1684 :                 switch( opndx->scale ) {

	movzx	eax, BYTE PTR [rsi+68]
	cmp	al, 1
	jbe	SHORT $LN130@memory_ope
	cmp	al, 2
	je	SHORT $LN69@memory_ope
	cmp	al, 4
	je	SHORT $LN70@memory_ope
	cmp	al, 8
	jne	SHORT $LN72@memory_ope

; 1689 :                 case 8: ss = SCALE_FACTOR_8; break; /* ss = 11 */

	mov	r15b, -64				; ffffffffffffffc0H
	jmp	SHORT $LN73@memory_ope
$LN72@memory_ope:

; 1690 :                 default: /* must be * 1, 2, 4 or 8 */
; 1691 :                     return( EmitError( SCALE_FACTOR_MUST_BE_1_2_4_OR_8 ) );

	mov	ecx, 36					; 00000024H
	call	EmitError
	jmp	$LN1@memory_ope
$LN70@memory_ope:

; 1688 :                 case 4: ss = SCALE_FACTOR_4; break; /* ss = 10 */

	mov	r15b, -128				; ffffffffffffff80H
	jmp	SHORT $LN73@memory_ope
$LN69@memory_ope:

; 1685 :                 case 0:
; 1686 :                 case 1:  break; /* ss = 00 */
; 1687 :                 case 2: ss = SCALE_FACTOR_2; break; /* ss = 01 */

	mov	r15b, 64				; 00000040H

; 1692 :                 }
; 1693 :             } else {
; 1694 :                 /* 286 and down cannot use this memory mode */
; 1695 :                 return( EmitError( INVALID_ADDRESSING_MODE_WITH_CURRENT_CPU_SETTING ) );
; 1696 :             }
; 1697 :         } else {

	jmp	SHORT $LN73@memory_ope
$LN130@memory_ope:
	xor	r15b, r15b
$LN73@memory_ope:

; 1701 :             }
; 1702 :         }
; 1703 :     }
; 1704 : 
; 1705 :     if( with_fixup ) {

	cmp	BYTE PTR with_fixup$[rsp], 0
	je	$LN132@memory_ope

; 1706 : 
; 1707 :         if( opndx->is_abs ) {

	test	BYTE PTR [rsi+72], 4
	je	SHORT $LN75@memory_ope

; 1708 :             Ofssize = IS_ADDR32( CodeInfo );

	cmp	BYTE PTR [rbx+106], 0
	movzx	edx, BYTE PTR [rbx+9]
	je	SHORT $LN106@memory_ope
	not	dl
$LN106@memory_ope:
	and	dl, 1
	jmp	SHORT $LN80@memory_ope
$LN75@memory_ope:

; 1709 :         } else if ( sym ) {

	test	r13, r13
	je	SHORT $LN77@memory_ope

; 1710 :             Ofssize = GetSymOfssize( sym );

	mov	rcx, r13
	call	GetSymOfssize
	mov	edx, eax
	jmp	SHORT $LN80@memory_ope
$LN77@memory_ope:

; 1711 :         } else if ( SegOverride ) {

	mov	rcx, QWORD PTR SegOverride
	test	rcx, rcx
	je	SHORT $LN79@memory_ope

; 1712 :             Ofssize = GetSymOfssize( SegOverride );

	call	GetSymOfssize
	movzx	edx, al

; 1713 :         } else

	jmp	SHORT $LN80@memory_ope
$LN79@memory_ope:

; 1714 :             Ofssize = CodeInfo->Ofssize;

	movzx	edx, BYTE PTR [rbx+106]
$LN80@memory_ope:

; 1715 : 
; 1716 :         /* now set fixup_type.
; 1717 :          * for direct addressing, the fixup type can easily be set by
; 1718 :          * the symbol's offset size.
; 1719 :          */
; 1720 :         if( base == EMPTY && index == EMPTY ) {

	cmp	r14d, -2
	jne	SHORT $LN81@memory_ope
	cmp	ebp, r14d
	jne	SHORT $LN81@memory_ope

; 1721 :             CodeInfo->prefix.adrsiz = ADDRSIZE( CodeInfo->Ofssize, Ofssize );

	and	BYTE PTR [rbx+9], 254			; 000000feH
	movzx	eax, BYTE PTR [rbx+106]
	xor	al, dl
	setne	cl
	and	cl, 1
	or	BYTE PTR [rbx+9], cl

; 1722 : #if AMD64_SUPPORT
; 1723 :             if ( Ofssize == USE64 )

	cmp	dl, 2
	jne	SHORT $LN83@memory_ope

; 1724 :                 /* v2.03: override with a segment assumed != FLAT? */
; 1725 :                 if ( opndx->override != NULL &&

	cmp	QWORD PTR [rsi+48], 0
	je	$LN95@memory_ope
	mov	rax, QWORD PTR ModuleInfo+440
	cmp	QWORD PTR SegOverride, rax
	je	SHORT $LN95@memory_ope

; 1726 :                     SegOverride != &ModuleInfo.flat_grp->sym )
; 1727 :                     fixup_type = FIX_OFF32;

	jmp	SHORT $LN137@memory_ope
$LN83@memory_ope:

; 1728 :                 else
; 1729 :                     fixup_type = FIX_RELOFF32;
; 1730 :             else
; 1731 : #endif
; 1732 :                 fixup_type = ( Ofssize ) ? FIX_OFF32 : FIX_OFF16;

	xor	edi, edi
	test	dl, dl
	setne	dil
	add	edi, 5

; 1760 :                 }
; 1761 :             }
; 1762 :         }
; 1763 : 
; 1764 : #if IMAGERELSUPP || SECTIONRELSUPP /* v2.10: added; IMAGEREL/SECTIONREL for indirect memory operands */
; 1765 :         if ( fixup_type == FIX_OFF32 )

	cmp	edi, 6
	jne	SHORT $LN95@memory_ope
	jmp	SHORT $LN123@memory_ope
$LN81@memory_ope:

; 1733 :             DebugMsg1(( "memory_operand: direct addressing, fixup type=%u\n", fixup_type ));
; 1734 :         } else {
; 1735 :             DebugMsg1(( "memory_operand: CodeInfo->Ofssize=%u/prefix.adrsize=%u, Ofssize=%u\n",
; 1736 :                       CodeInfo->Ofssize, CodeInfo->prefix.adrsiz, Ofssize ));
; 1737 : #if AMD64_SUPPORT
; 1738 :             if( Ofssize == USE64 ) {

	cmp	dl, 2
	je	SHORT $LN137@memory_ope

; 1739 :                 fixup_type = FIX_OFF32;
; 1740 :             } else
; 1741 : #endif
; 1742 :             if( IS_ADDR32( CodeInfo ) ) { /* address prefix needed? */

	cmp	BYTE PTR [rbx+106], 0
	movzx	eax, BYTE PTR [rbx+9]
	je	SHORT $LN108@memory_ope
	not	eax
$LN108@memory_ope:
	and	eax, 1
	test	eax, eax
	je	SHORT $LN89@memory_ope
$LN137@memory_ope:

; 1743 :                 /* changed for v1.95. Probably more tests needed!
; 1744 :                  * test case:
; 1745 :                  *   mov eax,[ebx*2-10+offset var] ;code and var are 16bit!
; 1746 :                  * the old code usually works fine because HiWord of the
; 1747 :                  * symbol's offset is zero. However, if there's an additional
; 1748 :                  * displacement which makes the value stored at the location
; 1749 :                  * < 0, then the target's HiWord becomes <> 0.
; 1750 :                  */
; 1751 :                 //fixup_type = ( Ofssize ) ? FIX_OFF32 : FIX_OFF16;
; 1752 :                 fixup_type = FIX_OFF32;

	mov	edi, 6
$LN123@memory_ope:

; 1766 :             if ( opndx->instr == T_IMAGEREL )

	mov	eax, DWORD PTR [rsi+56]
	cmp	eax, 233				; 000000e9H
	jne	SHORT $LN93@memory_ope

; 1767 :                 fixup_type = FIX_OFF32_IMGREL;

	mov	edi, 12
	jmp	SHORT $LN95@memory_ope
$LN93@memory_ope:

; 1768 :             else if ( opndx->instr == T_SECTIONREL )

	cmp	eax, 243				; 000000f3H
	mov	ecx, 13
	cmove	edi, ecx
	jmp	SHORT $LN95@memory_ope
$LN89@memory_ope:

; 1753 :             } else {
; 1754 :                 fixup_type = FIX_OFF16;

	mov	edi, 5

; 1755 :                 if( Ofssize && Parse_Pass == PASS_2 ) {

	test	dl, dl
	je	SHORT $LN95@memory_ope
	cmp	DWORD PTR Parse_Pass, 1
	jne	SHORT $LN95@memory_ope

; 1756 :                     /* address size is 16bit but label is 32-bit.
; 1757 :                      * example: use a 16bit register as base in FLAT model:
; 1758 :                      *   test buff[di],cl */
; 1759 :                     EmitWarn( 2, WORD_FIXUP_FOR_32BIT_LABEL, sym->name );

	mov	r8, QWORD PTR [r13+8]
	lea	ecx, QWORD PTR [rdi-3]
	mov	edx, 218				; 000000daH
	call	EmitWarn
$LN95@memory_ope:
	mov	eax, DWORD PTR [rbx+24]
	sub	eax, 666				; 0000029aH
	cmp	eax, 1
	jbe	SHORT $LN132@memory_ope

; 1769 :                 fixup_type = FIX_OFF32_SECREL;
; 1770 : #endif
; 1771 :         /* no fixups are needed for memory operands of string instructions and XLAT/XLATB.
; 1772 :          * However, CMPSD and MOVSD are also SSE2 opcodes, so the fixups must be generated
; 1773 :          * anyways.
; 1774 :          */
; 1775 :         if ( CodeInfo->token != T_XLAT && CodeInfo->token != T_XLATB ) {
; 1776 :             //DebugMsg1(("memory_operand: calling CreateFixup(%s, fixup=%u) [CodeInfo->memtype=%Xh]\n", sym ? sym->name : "NULL", fixup_type, CodeInfo->mem_type));
; 1777 :             CodeInfo->opnd[CurrOpnd].InsFixup = CreateFixup( sym, fixup_type, OPTJ_NONE );

	xor	r8d, r8d
	mov	edx, edi
	mov	rcx, r13
	call	CreateFixup
	mov	rdi, QWORD PTR tv1052[rsp]
	lea	rcx, QWORD PTR [rdi+rdi*2]
	mov	QWORD PTR [rbx+rcx*8+48], rax
	jmp	SHORT $LN96@memory_ope
$LN132@memory_ope:
	mov	rdi, QWORD PTR tv1052[rsp]
$LN96@memory_ope:

; 1778 :         }
; 1779 :     }
; 1780 : 
; 1781 :     if( set_rm_sib( CodeInfo, CurrOpnd, ss, index, base, sym ) == ERROR ) {

	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	r9d, ebp
	mov	QWORD PTR [rsp+40], r13
	movzx	r8d, r15b
	mov	rcx, rbx
	mov	DWORD PTR [rsp+32], r14d
	call	set_rm_sib
	cmp	eax, -1
	je	$LN61@memory_ope

; 1782 :         return( ERROR );
; 1783 :     }
; 1784 :     /* set frame type/data in fixup if one was created */
; 1785 :     if ( CodeInfo->opnd[CurrOpnd].InsFixup ) {

	lea	rax, QWORD PTR [rdi+2]
	lea	rax, QWORD PTR [rax+rax*2]
	mov	rdx, QWORD PTR [rbx+rax*8]
	lea	rcx, QWORD PTR [rbx+rax*8]
	test	rdx, rdx
	je	SHORT $LN98@memory_ope

; 1786 :         CodeInfo->opnd[CurrOpnd].InsFixup->frame_type = Frame_Type;

	movzx	eax, BYTE PTR Frame_Type
	mov	BYTE PTR [rdx+40], al

; 1787 :         CodeInfo->opnd[CurrOpnd].InsFixup->frame_datum = Frame_Datum;

	mov	rcx, QWORD PTR [rcx]
	movzx	eax, WORD PTR Frame_Datum
	mov	WORD PTR [rcx+42], ax
$LN98@memory_ope:

; 1788 :     }
; 1789 : 
; 1790 :     DebugMsg1(("memory_operand exit, ok, opndx.type/value=%Xh/%Xh, CodeInfo.memtype/rmbyte=%X/%X opndtype=%Xh fix=%Xh\n",
; 1791 :               opndx->type, opndx->value, CodeInfo->mem_type, CodeInfo->rm_byte, CodeInfo->opnd[CurrOpnd].type, CodeInfo->opnd[CurrOpnd].InsFixup ));
; 1792 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@memory_ope:
	mov	r15, QWORD PTR [rsp+48]
	mov	r14, QWORD PTR [rsp+128]

; 1793 : }

	add	rsp, 56					; 00000038H
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
	npad	2
$LN127@memory_ope:
	DD	$LN32@memory_ope
	DD	$LN33@memory_ope
	DD	$LN34@memory_ope
	DD	$LN35@memory_ope
	DD	$LN36@memory_ope
	DD	$LN37@memory_ope
	DD	$LN38@memory_ope
	DD	$LN39@memory_ope
	DD	$LN40@memory_ope
	DD	$LN43@memory_ope
$LN126@memory_ope:
	DB	0
	DB	1
	DB	9
	DB	2
	DB	9
	DB	3
	DB	9
	DB	4
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	7
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	8
memory_operand ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
;	COMDAT Set_Memtype
_TEXT	SEGMENT
CodeInfo$ = 8
mem_type$ = 16
Set_Memtype PROC					; COMDAT

; 1297 :     if( CodeInfo->token == T_LEA )

	mov	r9d, DWORD PTR [rcx+24]
	mov	r8, rcx
	cmp	r9d, 633				; 00000279H
	je	$LN10@Set_Memtyp
	cmp	edx, 192				; 000000c0H
	je	$LN10@Set_Memtyp
	cmp	edx, 196				; 000000c4H
	je	$LN10@Set_Memtyp
	lea	eax, DWORD PTR [rdx-129]
	cmp	eax, 1
	jbe	$LN10@Set_Memtyp

; 1298 :         return;
; 1299 :     /* v2.05: changed. Set "data" types only. */
; 1300 :     if( mem_type == MT_EMPTY || mem_type == MT_TYPE ||
; 1301 :        mem_type == MT_NEAR || mem_type == MT_FAR )
; 1302 :         return;
; 1303 : 
; 1304 :     CodeInfo->mem_type = mem_type;
; 1305 : 
; 1306 :     if( CodeInfo->Ofssize > USE16 ) {

	cmp	BYTE PTR [rcx+106], 0
	mov	DWORD PTR [rcx+28], edx
	jbe	$LN11@Set_Memtyp
	lea	eax, DWORD PTR [rdx-1]
	test	eax, -65				; ffffffbfH
	je	$LN15@Set_Memtyp

; 1313 : #if AMD64_SUPPORT
; 1314 :         /*
; 1315 :          * set rex Wide bit if a QWORD operand is found (not for FPU/MMX/SSE instr).
; 1316 :          * This looks pretty hackish now and is to be cleaned!
; 1317 :          * v2.01: also had issues with SSE2 MOVSD/CMPSD, now fixed!
; 1318 :          */
; 1319 :         /* v2.06: with AVX, SSE tokens may exist twice, one
; 1320 :          * for "legacy", the other for VEX encoding!
; 1321 :          */
; 1322 :         else if ( IS_MEMTYPE_SIZ( mem_type, sizeof( uint_64 ) ) ) {

	mov	eax, edx
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	jge	$LN10@Set_Memtyp
	and	edx, 31
	cmp	dl, 7
	jne	$LN10@Set_Memtyp
	cmp	r9d, 616				; 00000268H
	je	$LN10@Set_Memtyp
	lea	eax, DWORD PTR [r9-600]
	cmp	eax, 1
	jbe	$LN10@Set_Memtyp
	lea	eax, DWORD PTR [r9-1287]
	cmp	eax, 3
	jbe	$LN10@Set_Memtyp

; 1323 :             switch( CodeInfo->token ) {
; 1324 :             case T_PUSH: /* for PUSH/POP, REX_W isn't needed (no 32-bit variants in 64-bit mode) */
; 1325 :             case T_POP:
; 1326 :             case T_CMPXCHG8B:
; 1327 : #if VMXSUPP
; 1328 :             case T_VMPTRLD:
; 1329 :             case T_VMPTRST:
; 1330 :             case T_VMCLEAR:
; 1331 :             case T_VMXON:
; 1332 : #endif
; 1333 :                 break;
; 1334 :             default:
; 1335 :                 /* don't set REX for opcodes that accept memory operands
; 1336 :                  * of any size.
; 1337 :                  */
; 1338 :                 if ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[OPND1] == OP_M_ANY ) {

	mov	r10, QWORD PTR [rcx+16]
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR [r10]
	lea	rcx, QWORD PTR [rax+rax*2]
	cmp	DWORD PTR opnd_clstab[rdx+rcx*4], -8388608 ; ffffffffff800000H
	je	$LN10@Set_Memtyp

; 1339 :                     //printf( "Set_Memtype: OP_M_ANY detected, file=%s, instr=%s\n", CurrFName[ASM], GetResWName( CodeInfo->token, NULL ) );
; 1340 :                     break;
; 1341 :                 }
; 1342 :                 /* don't set REX for FPU opcodes */
; 1343 :                 if ( CodeInfo->pinstr->cpu & P_FPU_MASK )

	movzx	eax, WORD PTR [r10+10]
	test	al, 7
	jne	$LN10@Set_Memtyp

; 1344 :                     break;
; 1345 :                 /* don't set REX for - most - MMX/SSE opcodes */
; 1346 :                 if ( CodeInfo->pinstr->cpu & P_EXT_MASK ) {

	mov	ecx, 65280				; 0000ff00H
	test	ax, cx
	je	$LN23@Set_Memtyp
	cmp	r9d, 1445				; 000005a5H
	je	$LN23@Set_Memtyp
	lea	eax, DWORD PTR [r9-1027]
	cmp	eax, 1
	jbe	$LN23@Set_Memtyp
	cmp	r9d, 1045				; 00000415H
	je	$LN23@Set_Memtyp
	lea	eax, DWORD PTR [r9-1215]
	cmp	eax, 1
	jbe	$LN23@Set_Memtyp
	cmp	r9d, 1911				; 00000777H
	je	$LN23@Set_Memtyp
	cmp	r9d, 1933				; 0000078dH
	je	$LN23@Set_Memtyp
	lea	eax, DWORD PTR [r9-1989]
	cmp	eax, 1
	ja	$LN10@Set_Memtyp

; 1409 :                 /* setting REX.W will cause an error in codegen */
; 1410 :                 CodeInfo->prefix.rex |= REX_W;

	or	BYTE PTR [r8+8], 8

; 1411 :         }
; 1412 : #endif
; 1413 :     }
; 1414 :     return;
; 1415 : }

	ret	0
$LN15@Set_Memtyp:

; 1307 :         /* if we are in use32 mode, we have to add OPSIZ prefix for
; 1308 :          * most of the 386 instructions when operand has type WORD.
; 1309 :          * Exceptions ( MOVSX and MOVZX ) are handled in check_size().
; 1310 :          */
; 1311 :         if ( IS_MEM_TYPE( mem_type, WORD ) )
; 1312 :             CodeInfo->prefix.opsiz = TRUE;

	or	BYTE PTR [rcx+9], 2

; 1411 :         }
; 1412 : #endif
; 1413 :     }
; 1414 :     return;
; 1415 : }

	ret	0
$LN11@Set_Memtyp:

; 1347 :                     switch ( CodeInfo->token ) {
; 1348 :                         /* [V]CMPSD and [V]MOVSD are also candidates,
; 1349 :                          * but currently they are handled in HandleStringInstructions()
; 1350 :                          */
; 1351 :                     case T_CVTSI2SD: /* v2.06: added */
; 1352 :                     case T_CVTSI2SS: /* v2.06: added */
; 1353 :                     case T_PEXTRQ: /* v2.06: added */
; 1354 :                     case T_PINSRQ: /* v2.06: added */
; 1355 :                     case T_MOVD:
; 1356 : #if AVXSUPP
; 1357 :                     case T_VCVTSI2SD:
; 1358 :                     case T_VCVTSI2SS:
; 1359 :                     case T_VPEXTRQ:
; 1360 :                     case T_VPINSRQ:
; 1361 :                     case T_VMOVD:
; 1362 : #endif
; 1363 :                         CodeInfo->prefix.rex |= REX_W;
; 1364 :                         break;
; 1365 :                     default:
; 1366 :                         break;
; 1367 :                     }
; 1368 :                 }
; 1369 :                 else
; 1370 :                     CodeInfo->prefix.rex |= REX_W;
; 1371 :             }
; 1372 :         }
; 1373 : #endif
; 1374 : 
; 1375 :     /* v2.05: IS_MEM_TYPE() doesn't work with MT_REALx */
; 1376 :     //} else if( CodeInfo->Ofssize == USE16 && ( IS_MEM_TYPE( mem_type, DWORD ) ) ) {
; 1377 :     } else {
; 1378 :         if( IS_MEMTYPE_SIZ( mem_type, sizeof(uint_32) ) ) {

	mov	ecx, edx
	and	ecx, 192				; 000000c0H
	cmp	ecx, 128				; 00000080H
	jge	$LN10@Set_Memtyp
	mov	eax, edx
	and	eax, 31
	cmp	al, 3
	jne	SHORT $LN25@Set_Memtyp

; 1379 : 
; 1380 :             /* in 16bit mode, a DWORD memory access usually requires an OPSIZ
; 1381 :              * prefix. A few instructions, which access m16:16 operands,
; 1382 :              * are exceptions.
; 1383 :              */
; 1384 :             switch( CodeInfo->token ) {

	add	r9d, -454				; fffffffffffffe3aH
	cmp	r9d, 183				; 000000b7H
	ja	SHORT $LN28@Set_Memtyp
	lea	rdx, OFFSET FLAT:__ImageBase
	movsxd	rax, r9d
	movzx	eax, BYTE PTR $LN41@Set_Memtyp[rdx+rax]
	mov	ecx, DWORD PTR $LN42@Set_Memtyp[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN28@Set_Memtyp:

; 1385 :             case T_LDS:
; 1386 :             case T_LES:
; 1387 :             case T_LFS:
; 1388 :             case T_LGS:
; 1389 :             case T_LSS:
; 1390 :             case T_CALL: /* v2.0: added */
; 1391 :             case T_JMP:  /* v2.0: added */
; 1392 :                 /* in these cases, opsize does NOT need to be changed  */
; 1393 :                 break;
; 1394 :             default:
; 1395 :                 CodeInfo->prefix.opsiz = TRUE;

	or	BYTE PTR [r8+9], 2

; 1411 :         }
; 1412 : #endif
; 1413 :     }
; 1414 :     return;
; 1415 : }

	ret	0
$LN25@Set_Memtyp:

; 1396 :                 break;
; 1397 :             }
; 1398 :         }
; 1399 : #if AMD64_SUPPORT
; 1400 :         /* v2.06: added because in v2.05, 64-bit memory operands were
; 1401 :          * accepted in 16-bit code
; 1402 :          */
; 1403 :         else if ( IS_MEMTYPE_SIZ( mem_type, sizeof(uint_64) ) ) {

	cmp	ecx, 128				; 00000080H
	jge	SHORT $LN10@Set_Memtyp
	and	edx, 31
	cmp	dl, 7
	jne	SHORT $LN10@Set_Memtyp

; 1404 :             if ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[OPND1] == OP_M_ANY ) {

	mov	r10, QWORD PTR [r8+16]
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR [r10]
	lea	rcx, QWORD PTR [rax+rax*2]
	cmp	DWORD PTR opnd_clstab[rdx+rcx*4], -8388608 ; ffffffffff800000H
	je	SHORT $LN10@Set_Memtyp

; 1405 :                 //printf( "Set_Memtype: OP_M_ANY detected, file=%s, instr=%s\n", CurrFName[ASM], GetResWName( CodeInfo->token, NULL ) );
; 1406 :             } else if ( CodeInfo->pinstr->cpu & ( P_FPU_MASK | P_EXT_MASK ) ) {

	mov	eax, 65287				; 0000ff07H
	test	WORD PTR [r10+10], ax
	jne	SHORT $LN10@Set_Memtyp

; 1407 :                 ;
; 1408 :             } else if ( CodeInfo->token != T_CMPXCHG8B )

	cmp	r9d, 616				; 00000268H
	je	SHORT $LN10@Set_Memtyp
$LN23@Set_Memtyp:

; 1409 :                 /* setting REX.W will cause an error in codegen */
; 1410 :                 CodeInfo->prefix.rex |= REX_W;

	or	BYTE PTR [r8+8], 8
$LN10@Set_Memtyp:

; 1411 :         }
; 1412 : #endif
; 1413 :     }
; 1414 :     return;
; 1415 : }

	ret	0
	npad	1
$LN42@Set_Memtyp:
	DD	$LN10@Set_Memtyp
	DD	$LN28@Set_Memtyp
$LN41@Set_Memtyp:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
Set_Memtype ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
;	COMDAT SetPtrMemtype
_TEXT	SEGMENT
CodeInfo$ = 48
opndx$ = 56
SetPtrMemtype PROC					; COMDAT

; 1242 : {

	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1243 :     struct asym *sym = opndx->sym;
; 1244 :     int size = 0;
; 1245 : 
; 1246 :     if ( opndx->mbr )  /* the mbr field has higher priority */

	mov	rax, QWORD PTR [rdx+88]
	xor	r9d, r9d
	mov	r8, QWORD PTR [rdx+80]
	test	rax, rax
	mov	rsi, rdx
	mov	rdi, rcx
	cmovne	r8, rax

; 1247 :         sym = opndx->mbr;
; 1248 : 
; 1249 :     /* v2.10: the "explicit" condition is now handled FIRST */
; 1250 : #if 1 /* v2.0: handle PF16 ptr [ebx], which didn't work in v1.96 */
; 1251 :     if ( opndx->explicit && opndx->type ) {

	test	BYTE PTR [rdx+72], 2
	je	SHORT $LN3@SetPtrMemt
	mov	rax, QWORD PTR [rdx+96]
	test	rax, rax
	je	SHORT $LN3@SetPtrMemt

; 1252 :         size = opndx->type->total_size;

	mov	r9d, DWORD PTR [rax+56]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2

; 1253 :         CodeInfo->isfar = opndx->type->isfar;

	xor	al, BYTE PTR [rcx+142]
	and	al, 4
	xor	BYTE PTR [rcx+142], al

; 1254 :     } else

	jmp	$LN6@SetPtrMemt
$LN3@SetPtrMemt:

; 1255 : #endif
; 1256 :     if ( sym ) {

	test	r8, r8
	je	$LN5@SetPtrMemt

; 1257 :         if ( sym->type ) {

	mov	rax, QWORD PTR [r8+80]
	test	rax, rax
	je	SHORT $LN7@SetPtrMemt

; 1258 :             size = sym->type->total_size;

	mov	r9d, DWORD PTR [rax+56]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2

; 1259 :             CodeInfo->isfar = sym->type->isfar;

	xor	al, BYTE PTR [rcx+142]
	and	al, 4
	xor	BYTE PTR [rcx+142], al

; 1260 : 
; 1261 :             /* there's an ambiguity with pointers of size DWORD,
; 1262 :              since they can be either NEAR32 or FAR16 */
; 1263 :             if ( size == 4 && sym->type->Ofssize != CodeInfo->Ofssize )

	cmp	r9d, 4
	jne	$LN6@SetPtrMemt
	mov	rax, QWORD PTR [r8+80]
	movzx	ecx, BYTE PTR [rax+44]
	cmp	cl, BYTE PTR [rdi+106]
	je	$LN29@SetPtrMemt

; 1264 :                 opndx->Ofssize = sym->type->Ofssize;

	mov	BYTE PTR [rdx+69], cl

; 1265 : 
; 1266 :         } else if ( sym->mem_type == MT_PTR ) {

	jmp	$LN29@SetPtrMemt
$LN7@SetPtrMemt:
	cmp	DWORD PTR [r8+36], 195			; 000000c3H
	jne	SHORT $LN10@SetPtrMemt

; 1267 :             size = SizeFromMemtype( sym->isfar ? MT_FAR : MT_NEAR, sym->Ofssize, NULL );

	movzx	edx, BYTE PTR [r8+44]
	mov	QWORD PTR [rsp+48], rbx
	movzx	ebx, BYTE PTR [r8+47]
	test	bl, 16
	setne	r9b
	xor	r8d, r8d
	lea	ecx, DWORD PTR [r9+129]
	call	SizeFromMemtype

; 1268 :             CodeInfo->isfar = sym->isfar;

	and	BYTE PTR [rdi+142], 251			; 000000fbH
	mov	r9d, eax
	shr	bl, 2
	and	bl, 4
	or	BYTE PTR [rdi+142], bl
	mov	rbx, QWORD PTR [rsp+48]

; 1269 :         } else  {

	jmp	SHORT $LN6@SetPtrMemt
$LN10@SetPtrMemt:

; 1270 :             if ( sym->isarray )

	test	BYTE PTR [r8+41], 2
	je	SHORT $LN12@SetPtrMemt

; 1271 :                 size = sym->total_size / sym->total_length;

	mov	eax, DWORD PTR [r8+56]
	xor	edx, edx
	div	DWORD PTR [r8+64]
	mov	r9d, eax
	jmp	SHORT $LN6@SetPtrMemt
$LN12@SetPtrMemt:

; 1272 :             else
; 1273 :                 size = sym->total_size;

	mov	r9d, DWORD PTR [r8+56]

; 1274 :         }
; 1275 :     } else {

	jmp	SHORT $LN6@SetPtrMemt
$LN5@SetPtrMemt:

; 1276 :         if ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) ) {

	mov	ecx, DWORD PTR ModuleInfo+360
	mov	edx, 2
	mov	eax, 1
	shl	al, cl

; 1277 :             DebugMsg1(("SetPtrMemtype: model with FAR data pointers\n" ));
; 1278 :             size = 2;
; 1279 :         }
; 1280 :         size += (2 << ModuleInfo.defOfssize );

	movzx	ecx, BYTE PTR ModuleInfo+405
	and	al, 104					; 00000068H
	cmovne	r9d, edx
	shl	edx, cl
	add	r9d, edx
$LN6@SetPtrMemt:

; 1281 :     }
; 1282 :     if ( size )

	test	r9d, r9d
	je	SHORT $LN30@SetPtrMemt
$LN29@SetPtrMemt:

; 1283 :         MemtypeFromSize( size, &opndx->mem_type );

	cmp	BYTE PTR SpecialTable+2471, 6
	jne	SHORT $LN30@SetPtrMemt
	mov	ecx, 205				; 000000cdH
	lea	r8, OFFSET FLAT:SpecialTable
	mov	eax, 2460				; 0000099cH
	npad	8
$LL20@SetPtrMemt:
	movzx	edx, BYTE PTR [rax+r8+10]
	test	dl, dl
	js	SHORT $LN18@SetPtrMemt
	movzx	eax, dl
	and	eax, 31
	inc	eax
	cmp	eax, r9d
	je	SHORT $LN25@SetPtrMemt
$LN18@SetPtrMemt:
	inc	rcx
	lea	rax, QWORD PTR [rcx+rcx*2]
	lea	rax, QWORD PTR [rax*4]
	cmp	BYTE PTR [rax+r8+11], 6
	je	SHORT $LL20@SetPtrMemt

; 1284 :     DebugMsg1(("SetPtrMemtype: size=%u, new memtype=0x%x\n", size, opndx->mem_type ));
; 1285 : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN25@SetPtrMemt:

; 1283 :         MemtypeFromSize( size, &opndx->mem_type );

	movzx	eax, dl
	mov	DWORD PTR [rsi+64], eax
$LN30@SetPtrMemt:

; 1284 :     DebugMsg1(("SetPtrMemtype: size=%u, new memtype=0x%x\n", size, opndx->mem_type ));
; 1285 : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetPtrMemtype ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
fixup_option$1$ = 80
CodeInfo$ = 80
CurrOpnd$ = 88
opndx$ = 96
idata_fixup PROC

; 922  : {

$LN158:
	push	rbx
	push	rdi
	push	r12
	sub	rsp, 48					; 00000030H
	mov	eax, DWORD PTR [rcx+24]
	mov	rdi, r8
	sub	eax, 454				; 000001c6H
	mov	r12d, edx

; 923  :     //struct fixup      *fixup;
; 924  :     enum fixup_types    fixup_type;
; 925  :     enum fixup_options  fixup_option = OPTJ_NONE;

	mov	DWORD PTR fixup_option$1$[rsp], 0
	mov	rbx, rcx
	cmp	eax, 49					; 00000031H
	ja	SHORT $LN12@idata_fixu

; 926  :     int                 size;
; 927  :     uint_8              Ofssize; /* 1=32bit, 0=16bit offset for fixup */
; 928  : 
; 929  :     DebugMsg1(("idata_fixup( CurrOpnd=%u ) enter [opndx.kind=%u mem_type=%Xh, CodeInfo.mem_type=%Xh]\n", CurrOpnd, opndx->kind, opndx->mem_type, CodeInfo->mem_type));
; 930  : 
; 931  :     /* jmp/call/jcc/loopcc/jxcxz? */
; 932  :     if( IS_ANY_BRANCH( CodeInfo->token ) ) {
; 933  :         return( process_branch( CodeInfo, CurrOpnd, opndx ) );

	mov	edx, r12d

; 1232 : }

	add	rsp, 48					; 00000030H
	pop	r12
	pop	rdi
	pop	rbx

; 926  :     int                 size;
; 927  :     uint_8              Ofssize; /* 1=32bit, 0=16bit offset for fixup */
; 928  : 
; 929  :     DebugMsg1(("idata_fixup( CurrOpnd=%u ) enter [opndx.kind=%u mem_type=%Xh, CodeInfo.mem_type=%Xh]\n", CurrOpnd, opndx->kind, opndx->mem_type, CodeInfo->mem_type));
; 930  : 
; 931  :     /* jmp/call/jcc/loopcc/jxcxz? */
; 932  :     if( IS_ANY_BRANCH( CodeInfo->token ) ) {
; 933  :         return( process_branch( CodeInfo, CurrOpnd, opndx ) );

	jmp	process_branch
$LN12@idata_fixu:
	mov	QWORD PTR [rsp+96], rsi

; 934  :     }
; 935  :     CodeInfo->opnd[CurrOpnd].data32l = opndx->value;

	lea	rax, QWORD PTR [r12+r12*2]
	mov	QWORD PTR [rsp+104], r13
	mov	rsi, r12
	lea	r13, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR [rsp+40], r14
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [r13+40], eax

; 936  : 
; 937  :     if ( opndx->Ofssize != USE_EMPTY ) {

	movzx	r14d, BYTE PTR [r8+69]
	cmp	r14b, 254				; 000000feH
	jne	SHORT $LN19@idata_fixu

; 938  :         Ofssize = opndx->Ofssize;
; 939  :     } else if( ( opndx->sym->state == SYM_SEG )
; 940  :         || ( opndx->sym->state == SYM_GRP )
; 941  :         || ( opndx->instr == T_SEG ) ) {

	mov	rcx, QWORD PTR [r8+80]
	mov	eax, DWORD PTR [rcx+32]
	sub	eax, 3
	cmp	eax, 1
	jbe	SHORT $LN17@idata_fixu
	cmp	DWORD PTR [r8+56], 244			; 000000f4H
	je	SHORT $LN17@idata_fixu

; 943  :     } else if( opndx->is_abs ) {  /* an (external) absolute symbol? */

	test	BYTE PTR [r8+72], 4
	jne	SHORT $LN17@idata_fixu

; 944  :         Ofssize = USE16;
; 945  :     } else {
; 946  :         Ofssize = GetSymOfssize( opndx->sym );

	call	GetSymOfssize
	mov	r14d, eax
	jmp	SHORT $LN19@idata_fixu
$LN17@idata_fixu:

; 942  :         Ofssize = USE16;

	xor	r14b, r14b
$LN19@idata_fixu:

; 947  :     }
; 948  : 
; 949  :     if( opndx->instr == T_SHORT ) {

	cmp	DWORD PTR [rdi+56], 245			; 000000f5H
	jne	SHORT $LN20@idata_fixu

; 950  :         /* short works for branch instructions only */
; 951  :         return( EmitErr( INVALID_INSTRUCTION_OPERANDS ) );

	mov	ecx, 49					; 00000031H
	call	EmitErr
	jmp	$LN150@idata_fixu
$LN20@idata_fixu:
	mov	eax, DWORD PTR [rdi+72]
	and	al, 6
	mov	QWORD PTR [rsp+88], rbp
	mov	QWORD PTR [rsp+32], r15
	cmp	al, 2

; 952  :     }
; 953  : 
; 954  :     /* the code below should be rewritten.
; 955  :      * - an address operator ( OFFSET, LROFFSET, IMAGEREL, SECTIONREL,
; 956  :      *   LOW, HIGH, LOWWORD, HIGHWORD, LOW32, HIGH32, SEG ) should not
; 957  :      *   force a magnitude, but may set a minimal magnitude - and the
; 958  :      *   fixup type, of course.
; 959  :      * - check if Codeinfo->mem_type really has to be set here!
; 960  :      */
; 961  : 
; 962  :     /* v2.06: added */
; 963  :     /* v2.10: modified */
; 964  :     //if ( opndx->explicit ) {
; 965  :     if ( opndx->explicit && !opndx->is_abs ) {

	jne	SHORT $LN22@idata_fixu

; 966  :         CodeInfo->const_size_fixed = TRUE;

	or	BYTE PTR [rbx+142], 8

; 967  :         if ( CodeInfo->mem_type == MT_EMPTY )

	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	jne	SHORT $LN22@idata_fixu

; 968  :             CodeInfo->mem_type = opndx->mem_type;

	mov	eax, DWORD PTR [rdi+64]
	mov	DWORD PTR [rbx+28], eax
$LN22@idata_fixu:

; 969  :     }
; 970  :     /* v2.03: don't ignore a "NEAR32 ptr" qualifier */
; 971  :     //if ( CodeInfo->mem_type == MT_EMPTY && CurrOpnd > OPND1 ) {
; 972  :     if ( CodeInfo->mem_type == MT_EMPTY && CurrOpnd > OPND1 && opndx->Ofssize == USE_EMPTY ) {

	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	mov	ebp, 7
	lea	r8d, QWORD PTR [rbp-4]
	lea	r15d, QWORD PTR [rbp-6]
	jne	$LN31@idata_fixu
	test	r12d, r12d
	je	$LN31@idata_fixu
	cmp	BYTE PTR [rdi+69], 254			; 000000feH
	jne	$LN31@idata_fixu

; 973  :         size = OperandSize( CodeInfo->opnd[OPND1].type, CodeInfo );

	mov	esi, DWORD PTR [rbx+32]
	mov	rdx, rbx
	mov	ecx, esi
	call	OperandSize

; 974  :         /* may be a forward reference, so wait till pass 2 */
; 975  :         if( Parse_Pass > PASS_1 && opndx->instr != EMPTY ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	edx, eax
	jbe	SHORT $LN28@idata_fixu
	mov	eax, DWORD PTR [rdi+56]
	cmp	eax, -2
	je	SHORT $LN28@idata_fixu

; 976  :             switch ( opndx->instr ) {

	sub	eax, 233				; 000000e9H
	je	SHORT $LN27@idata_fixu
	sub	eax, 6
	je	SHORT $LN27@idata_fixu
	sub	eax, 2
	je	SHORT $LN27@idata_fixu
	sub	eax, 2
	je	SHORT $LN27@idata_fixu
	cmp	eax, r15d
	jne	SHORT $LN28@idata_fixu
	mov	eax, -2147483648			; 80000000H
	test	edx, eax
	jne	SHORT $LN132@idata_fixu
	cmp	edx, r15d
	jne	SHORT $LN28@idata_fixu
$LN132@idata_fixu:

; 977  :             case T_SEG: /* v2.04a: added */
; 978  :                 if( size && (size < 2 ) ) {
; 979  :                     return( EmitErr( OPERANDS_MUST_BE_THE_SAME_SIZE, size, 2 ) );

	mov	ecx, 48					; 00000030H
	lea	r8d, QWORD PTR [rcx-46]
	call	EmitErr
	jmp	$LN152@idata_fixu
$LN27@idata_fixu:

; 980  :                 }
; 981  :                 break;
; 982  :             case T_OFFSET:
; 983  :             case T_LROFFSET:
; 984  : #if IMAGERELSUPP
; 985  :             case T_IMAGEREL:
; 986  : #endif
; 987  : #if SECTIONRELSUPP
; 988  :             case T_SECTIONREL:
; 989  : #endif
; 990  :                 if( size && (size < 2 || ( Ofssize && size < 4 ))) {

	test	edx, edx
	je	SHORT $LN28@idata_fixu
	cmp	edx, 2
	jl	SHORT $LN29@idata_fixu
	test	r14b, r14b
	je	SHORT $LN28@idata_fixu
	cmp	edx, 4
	jge	SHORT $LN28@idata_fixu
$LN29@idata_fixu:

; 991  :                     return( EmitErr( OPERANDS_MUST_BE_THE_SAME_SIZE, size, ( 2 << Ofssize ) ) );

	movzx	ecx, r14b
	mov	r8d, 2
	shl	r8d, cl
	mov	ecx, 48					; 00000030H
	call	EmitErr
	jmp	$LN152@idata_fixu
$LN28@idata_fixu:

; 992  :                 }
; 993  :             }
; 994  :         }
; 995  :         switch ( size ) {

	sub	edx, r15d
	je	SHORT $LN30@idata_fixu
	sub	edx, r15d
	je	SHORT $LN33@idata_fixu
	sub	edx, 2
	je	SHORT $LN42@idata_fixu
	cmp	edx, 4
	jne	SHORT $LN143@idata_fixu

; 1009 :         case 4:
; 1010 :             CodeInfo->mem_type = MT_DWORD;
; 1011 :             break;
; 1012 : #if AMD64_SUPPORT
; 1013 :         case 8:
; 1014 :             /* v2.05: it's questionable if size 8 is a good assumption for an
; 1015 :              * immediate constant. It's valid for MOV <reg>, <imm> only.
; 1016 :              */
; 1017 :             //case 8: CodeInfo->mem_type = MT_QWORD;break;
; 1018 :             /* v2.05a: added */
; 1019 :             if ( Ofssize == USE64 ) {

	cmp	r14b, 2
	jne	SHORT $LN143@idata_fixu

; 1020 :                 if ( CodeInfo->token == T_MOV &&

	cmp	DWORD PTR [rbx+24], 605			; 0000025dH
	jne	SHORT $LN39@idata_fixu
	test	sil, 8
	je	SHORT $LN39@idata_fixu

; 1021 :                     ( CodeInfo->opnd[OPND1].type & OP_R64 ) )
; 1022 :                     CodeInfo->mem_type = MT_QWORD;

	mov	DWORD PTR [rbx+28], ebp
	jmp	SHORT $LN143@idata_fixu
$LN39@idata_fixu:

; 1023 :                 else if ( opndx->instr == T_LOW32 || opndx->instr == T_HIGH32 )

	mov	eax, DWORD PTR [rdi+56]
	cmp	eax, 237				; 000000edH
	je	SHORT $LN42@idata_fixu
	cmp	eax, 231				; 000000e7H
	jne	SHORT $LN143@idata_fixu
$LN42@idata_fixu:

; 1024 :                     /* v2.10:added; LOW32/HIGH32 in expreval.c won't set mem_type anymore. */
; 1025 :                     CodeInfo->mem_type = MT_DWORD;

	mov	r8d, 3
	mov	DWORD PTR [rbx+28], r8d
	jmp	SHORT $LN153@idata_fixu
$LN33@idata_fixu:

; 1000 :             break;
; 1001 :         case 2:
; 1002 :             /* v2.05: if () added */
; 1003 :             if ( opndx->is_abs ||
; 1004 :                 CodeInfo->Ofssize == USE16 ||
; 1005 :                 opndx->instr == T_LOWWORD ||

	test	BYTE PTR [rdi+72], 4
	jne	SHORT $LN35@idata_fixu
	cmp	BYTE PTR [rbx+106], 0
	je	SHORT $LN35@idata_fixu
	mov	eax, DWORD PTR [rdi+56]
	cmp	eax, 238				; 000000eeH
	je	SHORT $LN35@idata_fixu
	cmp	eax, 232				; 000000e8H
	jne	SHORT $LN143@idata_fixu
$LN35@idata_fixu:

; 1006 :                 opndx->instr == T_HIGHWORD )
; 1007 :                 CodeInfo->mem_type = MT_WORD;

	mov	DWORD PTR [rbx+28], r15d

; 1008 :             break;

	jmp	SHORT $LN143@idata_fixu
$LN30@idata_fixu:

; 996  :         case 1:
; 997  :             /* v2.05: if () added */
; 998  :             if ( opndx->is_abs || opndx->instr == T_LOW || opndx->instr == T_HIGH )

	test	BYTE PTR [rdi+72], 4
	jne	SHORT $LN32@idata_fixu
	mov	eax, DWORD PTR [rdi+56]
	cmp	eax, 236				; 000000ecH
	je	SHORT $LN32@idata_fixu
	cmp	eax, 230				; 000000e6H
	jne	SHORT $LN143@idata_fixu
$LN32@idata_fixu:

; 999  :                 CodeInfo->mem_type = MT_BYTE;

	mov	DWORD PTR [rbx+28], 0
$LN143@idata_fixu:
	mov	r8d, 3
$LN153@idata_fixu:
	mov	rsi, r12
$LN31@idata_fixu:

; 1026 :             }
; 1027 :             break;
; 1028 : #endif
; 1029 :         }
; 1030 :     }
; 1031 :     if ( CodeInfo->mem_type == MT_EMPTY ) {

	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	lea	r9, OFFSET FLAT:__ImageBase
	jne	$LN63@idata_fixu

; 1032 :         if( opndx->is_abs ) {

	mov	edx, DWORD PTR [rdi+72]
	test	dl, 4
	je	SHORT $LN44@idata_fixu

; 1033 :             //if( opndx->mem_type != MT_EMPTY && opndx->mem_type != MT_ABS ) {
; 1034 :             if( opndx->mem_type != MT_EMPTY ) {

	mov	eax, DWORD PTR [rdi+64]
	cmp	eax, 192				; 000000c0H
	jne	$LN100@idata_fixu

; 1035 :                 CodeInfo->mem_type = opndx->mem_type;
; 1036 :             } else if ( CodeInfo->token == T_PUSHW ) { /* v2.10: special handling PUSHW */

	cmp	DWORD PTR [rbx+24], 602			; 0000025aH
	jne	SHORT $LN48@idata_fixu

; 1037 :                 CodeInfo->mem_type = MT_WORD;

	mov	DWORD PTR [rbx+28], r15d

; 1038 :             } else {

	jmp	$LN63@idata_fixu
$LN48@idata_fixu:

; 1039 :                 CodeInfo->mem_type = ( IS_OPER_32( CodeInfo ) ? MT_DWORD : MT_WORD );

	movzx	ecx, BYTE PTR [rbx+9]
	shr	ecx, 1
	cmp	BYTE PTR [rbx+106], 0
	je	SHORT $LN97@idata_fixu
	not	ecx
$LN97@idata_fixu:
	and	ecx, r15d
	mov	eax, r15d
	test	ecx, ecx
	cmovne	eax, r8d

; 1040 :             }
; 1041 :         } else {

	jmp	$LN100@idata_fixu
$LN44@idata_fixu:

; 1042 :             switch ( CodeInfo->token ) {

	mov	ecx, DWORD PTR [rbx+24]
	sub	ecx, 564				; 00000234H
	je	SHORT $LN50@idata_fixu
	sub	ecx, 36					; 00000024H
	je	SHORT $LN50@idata_fixu
	cmp	ecx, 2
	jne	$LN146@idata_fixu
$LN50@idata_fixu:

; 1043 :             case T_PUSHW:
; 1044 :             case T_PUSHD:
; 1045 :             case T_PUSH:
; 1046 :                 /* for forward reference, assume BYTE */
; 1047 :                 /* v2.02: don't assume BYTE if it is SEG/GRP */
; 1048 :                 //if ( opndx->mem_type == MT_EMPTY ) {
; 1049 :                 /* v2.07: added cases IMAGEREL and SECTIONREL */
; 1050 :                 if ( opndx->mem_type == MT_EMPTY  ) {

	cmp	DWORD PTR [rdi+64], 192			; 000000c0H
	jne	SHORT $LN8@idata_fixu

; 1051 :                     switch( opndx->instr ) {

	mov	eax, DWORD PTR [rdi+56]
	add	eax, 2
	cmp	eax, 245				; 000000f5H
	ja	SHORT $LN8@idata_fixu
	cdqe
	movzx	eax, BYTE PTR $LN136@idata_fixu[r9+rax]
	mov	ecx, DWORD PTR $LN137@idata_fixu[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN52@idata_fixu:

; 1052 :                     case EMPTY:
; 1053 :                     case T_LOW:
; 1054 :                     case T_HIGH:
; 1055 :                         opndx->mem_type = MT_BYTE;

	mov	DWORD PTR [rdi+64], 0

; 1056 :                         break;

	jmp	SHORT $LN8@idata_fixu
$LN53@idata_fixu:

; 1057 :                     case T_LOW32: /* v2.10: added - low32_op() doesn't set mem_type anymore. */
; 1058 : #if IMAGERELSUPP
; 1059 :                     case T_IMAGEREL:
; 1060 : #endif
; 1061 : #if SECTIONRELSUPP
; 1062 :                     case T_SECTIONREL:
; 1063 : #endif
; 1064 :                         opndx->mem_type = MT_DWORD;

	mov	DWORD PTR [rdi+64], r8d
$LN8@idata_fixu:

; 1065 :                         break;
; 1066 :                     };
; 1067 :                 }
; 1068 :                 /* default: push offset only */
; 1069 :                 /* for PUSH + undefined symbol, assume BYTE */
; 1070 :                 if ( opndx->mem_type == MT_FAR && ( opndx->explicit == FALSE ) )

	cmp	DWORD PTR [rdi+64], 130			; 00000082H
	jne	SHORT $LN54@idata_fixu
	test	dl, 2
	jne	SHORT $LN54@idata_fixu

; 1071 :                     opndx->mem_type = MT_NEAR;

	mov	DWORD PTR [rdi+64], 129			; 00000081H
$LN54@idata_fixu:

; 1072 :                 /* v2.04: curly brackets added */
; 1073 :                 if ( CodeInfo->token == T_PUSHW ) {

	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 602				; 0000025aH
	jne	SHORT $LN55@idata_fixu

; 1074 :                     if ( SizeFromMemtype( opndx->mem_type, Ofssize, opndx->type ) < 2 )

	mov	r8, QWORD PTR [rdi+96]
	mov	ecx, DWORD PTR [rdi+64]
	movzx	edx, r14b
	call	SizeFromMemtype

; 1076 :                 } else if ( CodeInfo->token == T_PUSHD ) {

	lea	r9, OFFSET FLAT:__ImageBase
	mov	ecx, 3
	cmp	eax, 2
	jge	SHORT $LN59@idata_fixu

; 1075 :                         opndx->mem_type = MT_WORD;

	mov	DWORD PTR [rdi+64], r15d

; 1076 :                 } else if ( CodeInfo->token == T_PUSHD ) {

	jmp	SHORT $LN59@idata_fixu
$LN55@idata_fixu:
	cmp	eax, 564				; 00000234H
	jne	SHORT $LN146@idata_fixu

; 1077 :                     if ( SizeFromMemtype( opndx->mem_type, Ofssize, opndx->type ) < 4 )

	mov	r8, QWORD PTR [rdi+96]
	mov	ecx, DWORD PTR [rdi+64]
	movzx	edx, r14b
	call	SizeFromMemtype

; 1078 :                         opndx->mem_type = MT_DWORD;

	lea	r9, OFFSET FLAT:__ImageBase
	mov	ecx, 3
	cmp	eax, 4
	jge	SHORT $LN59@idata_fixu
	mov	DWORD PTR [rdi+64], ecx
	jmp	SHORT $LN59@idata_fixu
$LN146@idata_fixu:
	mov	ecx, 3
$LN59@idata_fixu:

; 1079 :                 }
; 1080 :                 break;
; 1081 :             }
; 1082 :             /* if a WORD size is given, don't override it with */
; 1083 :             /* anything what might look better at first glance */
; 1084 :             if( opndx->mem_type != MT_EMPTY )

	mov	eax, DWORD PTR [rdi+64]
	cmp	eax, 192				; 000000c0H
	jne	SHORT $LN100@idata_fixu

; 1085 :                 CodeInfo->mem_type = opndx->mem_type;
; 1086 :             /* v2.04: assume BYTE size if symbol is undefined */
; 1087 :             else if ( opndx->sym->state == SYM_UNDEFINED ) {

	mov	rax, QWORD PTR [rdi+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN62@idata_fixu

; 1088 :                 CodeInfo->mem_type = MT_BYTE;

	mov	DWORD PTR [rbx+28], 0

; 1089 :                 fixup_option = OPTJ_PUSH;

	mov	DWORD PTR fixup_option$1$[rsp], 5

; 1090 :             } else

	jmp	SHORT $LN63@idata_fixu
$LN62@idata_fixu:

; 1091 : #if AMD64_SUPPORT
; 1092 :                 /* v2.06d: changed */
; 1093 :                    CodeInfo->mem_type = ( Ofssize == USE64 ? MT_QWORD : Ofssize == USE32 ? MT_DWORD : MT_WORD );

	cmp	r14b, 2
	jne	SHORT $LN99@idata_fixu
	mov	eax, ebp
	jmp	SHORT $LN100@idata_fixu
$LN99@idata_fixu:
	mov	eax, r15d
	cmp	r14b, al
	cmove	eax, ecx
$LN100@idata_fixu:
	mov	DWORD PTR [rbx+28], eax
$LN63@idata_fixu:

; 1094 : #else
; 1095 :                 CodeInfo->mem_type = ( Ofssize > USE16 ? MT_DWORD : MT_WORD );
; 1096 : #endif
; 1097 :         }
; 1098 :     }
; 1099 :     size = SizeFromMemtype( CodeInfo->mem_type, Ofssize, NULL );

	mov	edx, DWORD PTR [rbx+28]
	movzx	r8d, r14b
	test	dl, dl
	js	SHORT $LN106@idata_fixu
	and	edx, 31
	inc	edx
	jmp	SHORT $LN103@idata_fixu
$LN106@idata_fixu:
	cmp	r8d, 254				; 000000feH
	jne	SHORT $LN107@idata_fixu
	movzx	r8d, BYTE PTR ModuleInfo+404
$LN107@idata_fixu:
	sub	edx, 128				; 00000080H
	je	SHORT $LN110@idata_fixu
	sub	edx, r15d
	je	SHORT $LN108@idata_fixu
	sub	edx, r15d
	je	SHORT $LN109@idata_fixu
	cmp	edx, 65					; 00000041H
	je	SHORT $LN111@idata_fixu
	xor	edx, edx
	jmp	SHORT $LN103@idata_fixu
$LN111@idata_fixu:
	mov	ecx, DWORD PTR ModuleInfo+360
	shl	r15d, cl
	and	r15b, 104				; 00000068H
	neg	r15b
	sbb	edx, edx
	jmp	SHORT $LN154@idata_fixu
$LN109@idata_fixu:
	mov	ecx, r8d
	mov	edx, 2
	shl	edx, cl
	add	edx, 2
	jmp	SHORT $LN103@idata_fixu
$LN108@idata_fixu:
	mov	ecx, r8d
	mov	edx, 2
	shl	edx, cl
	jmp	SHORT $LN103@idata_fixu
$LN110@idata_fixu:
	movzx	edx, BYTE PTR ds:47
	shr	edx, 3
$LN154@idata_fixu:
	mov	ecx, r8d
	mov	eax, 2
	shl	eax, cl
	and	edx, 2
	add	edx, eax
$LN103@idata_fixu:

; 1100 :     switch( size ) {

	mov	ecx, edx
	sub	ecx, 1
	je	$LN64@idata_fixu
	sub	ecx, 1
	je	SHORT $LN65@idata_fixu
	sub	ecx, 2
	je	SHORT $LN66@idata_fixu
	cmp	ecx, 4
	jne	$LN10@idata_fixu
	mov	rax, QWORD PTR [rdi]
	mov	ecx, -2147483648			; 80000000H
	add	rax, rcx
	mov	ecx, -1					; ffffffffH
	cmp	rax, rcx
	ja	SHORT $LN70@idata_fixu

; 1107 : #if AMD64_SUPPORT
; 1108 :     case 8:
; 1109 :         /* v2.05: do only assume size 8 if the constant won't fit in 4 bytes. */
; 1110 :         if ( opndx->value64 > LONG_MAX || opndx->value64 < LONG_MIN ||

	test	BYTE PTR [rdi+72], 2
	je	SHORT $LN68@idata_fixu
	mov	eax, DWORD PTR [rdi+64]
	and	eax, 31
	cmp	al, bpl
	je	SHORT $LN70@idata_fixu
$LN68@idata_fixu:

; 1114 :         //} else if ( Ofssize == USE64 ) { /* v2.11: assume 64-bit only for OFFSET or MOV r64, xxx */
; 1115 :         } else if ( Ofssize == USE64 && ( opndx->instr == T_OFFSET || ( CodeInfo->token == T_MOV && ( CodeInfo->opnd[OPND1].type & OP_R64 ) ) ) ) {

	cmp	r14b, 2
	jne	SHORT $LN66@idata_fixu
	cmp	DWORD PTR [rdi+56], 241			; 000000f1H
	je	SHORT $LN70@idata_fixu
	cmp	DWORD PTR [rbx+24], 605			; 0000025dH
	jne	SHORT $LN66@idata_fixu
	test	BYTE PTR [rbx+32], 8
	je	SHORT $LN66@idata_fixu
$LN70@idata_fixu:

; 1111 :             (opndx->explicit && ( opndx->mem_type & MT_SIZE_MASK ) == 7 ) ) {
; 1112 :             CodeInfo->opnd[CurrOpnd].type = OP_I64;

	mov	DWORD PTR [r13+32], 1048576		; 00100000H

; 1113 :             CodeInfo->opnd[CurrOpnd].data32h = opndx->hvalue;

	mov	eax, DWORD PTR [rdi+4]
	mov	DWORD PTR [r13+44], eax

; 1116 :             /* v2.06d: in 64-bit, ALWAYS set OP_I64, so "mov m64, ofs" will fail,
; 1117 :              * This was accepted in v2.05-v2.06c)
; 1118 :              */
; 1119 :             CodeInfo->opnd[CurrOpnd].type = OP_I64;
; 1120 :             CodeInfo->opnd[CurrOpnd].data32h = opndx->hvalue;
; 1121 :         } else {
; 1122 :             CodeInfo->opnd[CurrOpnd].type = OP_I32;
; 1123 :         }
; 1124 :         CodeInfo->prefix.opsiz = OPSIZE32( CodeInfo );

	jmp	SHORT $LN72@idata_fixu
$LN66@idata_fixu:

; 1106 :     case 4:  CodeInfo->opnd[CurrOpnd].type = OP_I32; CodeInfo->prefix.opsiz = OPSIZE32( CodeInfo );  break;

	mov	DWORD PTR [r13+32], 524288		; 00080000H
$LN72@idata_fixu:
	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], 0
	sete	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al
	jmp	SHORT $LN10@idata_fixu
$LN65@idata_fixu:

; 1104 :         break;
; 1105 :     case 2:  CodeInfo->opnd[CurrOpnd].type = OP_I16; CodeInfo->prefix.opsiz = OPSIZE16( CodeInfo );  break;

	mov	DWORD PTR [r13+32], 262144		; 00040000H
	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], 0
	setne	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al
	jmp	SHORT $LN10@idata_fixu
$LN64@idata_fixu:

; 1101 :     case 1:
; 1102 :         CodeInfo->opnd[CurrOpnd].type = OP_I8;

	mov	DWORD PTR [r13+32], 131072		; 00020000H

; 1103 :         CodeInfo->prefix.opsiz = FALSE; /* v2.10: reset opsize is not really a good idea - might have been set by previous operand */

	and	BYTE PTR [rbx+9], 253			; 000000fdH
$LN10@idata_fixu:

; 1125 :         break;
; 1126 : #endif
; 1127 : #ifdef DEBUG_OUT
; 1128 :     default:
; 1129 :         DebugMsg1(("idata_fixup, unexpected size %u\n", size ));
; 1130 :         /**/myassert( 0 );
; 1131 : #endif
; 1132 :     }
; 1133 : 
; 1134 :     /* set fixup_type */
; 1135 : 
; 1136 :     if( opndx->instr == T_SEG ) {

	mov	ecx, DWORD PTR [rdi+56]
	cmp	ecx, 244				; 000000f4H
	jne	SHORT $LN74@idata_fixu

; 1137 :         fixup_type = FIX_SEG;

	mov	ebp, 8
	jmp	SHORT $LN81@idata_fixu
$LN74@idata_fixu:

; 1138 :     } else if( CodeInfo->mem_type == MT_BYTE ) {

	cmp	DWORD PTR [rbx+28], 0
	jne	SHORT $LN76@idata_fixu

; 1139 :         DebugMsg1(("idata_fixup, mem_type=BYTE\n" ));
; 1140 :         if ( opndx->instr == T_HIGH ) {

	cmp	ecx, 230				; 000000e6H
	mov	ebp, 4
	mov	eax, 11
	cmove	ebp, eax

; 1141 :             DebugMsg1(("idata_fixup, FIX_HIBYTE\n" ));
; 1142 :             fixup_type = FIX_HIBYTE;
; 1143 :         } else {
; 1144 :             DebugMsg1(("idata_fixup, FIX_OFF8\n" ));
; 1145 :             fixup_type = FIX_OFF8;
; 1146 :         }

	jmp	SHORT $LN81@idata_fixu
$LN76@idata_fixu:

; 1147 : #if 0
; 1148 :     } else if( CodeInfo->mem_type == MT_FAR ) {
; 1149 :         /* v2.04: to be tested. this code is most likely obsolete.
; 1150 :          * There's never a PTR16|PTR32 fixup here. Far JMP/CALL are handled
; 1151 :          * elsewhere, and data items also.
; 1152 :          */
; 1153 :         /* temporary */
; 1154 :         printf("idata_fixup: MT_FAR occured at %s:%" I32_SPEC "u\n", CurrFName[ASM], LineNumber );
; 1155 :         fixup_type = ( Ofssize ) ? FIX_PTR32 : FIX_PTR16;
; 1156 :         CodeInfo->isfar = TRUE; /* needed for mark_fixupp() */
; 1157 :         if ( opndx->Ofssize != USE_EMPTY )
; 1158 :             CodeInfo->Ofssize = opndx->Ofssize;
; 1159 : #endif
; 1160 :     } else if( IS_OPER_32( CodeInfo ) ) {

	movzx	eax, BYTE PTR [rbx+9]
	shr	eax, 1
	cmp	BYTE PTR [rbx+106], 0
	je	SHORT $LN101@idata_fixu
	not	eax
$LN101@idata_fixu:
	and	eax, 1
	test	eax, eax
	je	SHORT $LN80@idata_fixu

; 1161 : #if AMD64_SUPPORT
; 1162 :         /* v2.06: changed */
; 1163 :         //if ( Ofssize == USE64 && CodeInfo->mem_type == MT_QWORD )
; 1164 :         /* v2.10: changed */
; 1165 :         //if ( CodeInfo->opnd[CurrOpnd].type == OP_I64 )
; 1166 :         if ( CodeInfo->opnd[CurrOpnd].type == OP_I64 && ( opndx->instr == EMPTY || opndx->instr == T_OFFSET ) )

	cmp	DWORD PTR [r13+32], 1048576		; 00100000H
	jne	SHORT $LN82@idata_fixu
	cmp	ecx, -2
	je	SHORT $LN81@idata_fixu
	cmp	ecx, 241				; 000000f1H
	je	SHORT $LN81@idata_fixu
$LN82@idata_fixu:

; 1167 :             fixup_type = FIX_OFF64;
; 1168 :         else
; 1169 : #endif
; 1170 :             /* v2.04: changed, no longer depends on OfsSize */
; 1171 :             /* v2.05a: changed, so size==8 won't get a FIX_OFF16 type */
; 1172 :             //if ( size == 4 )
; 1173 :             if ( size >= 4 && opndx->instr != T_LOWWORD ) {

	cmp	edx, 4
	jl	SHORT $LN80@idata_fixu
	cmp	ecx, 238				; 000000eeH
	je	SHORT $LN80@idata_fixu

; 1174 :                 /* v2.06: added branch for PTR16 fixup.
; 1175 :                  * it's only done if type coercion is FAR (Masm-compat)
; 1176 :                  */
; 1177 :                 if ( opndx->explicit && Ofssize == USE16 && opndx->mem_type == MT_FAR )

	test	BYTE PTR [rdi+72], 2
	je	SHORT $LN87@idata_fixu
	test	r14b, r14b
	jne	SHORT $LN87@idata_fixu
	cmp	DWORD PTR [rdi+64], 130			; 00000082H
	jne	SHORT $LN87@idata_fixu

; 1178 :                     fixup_type = FIX_PTR16;

	mov	ebp, 9
	jmp	SHORT $LN81@idata_fixu
$LN87@idata_fixu:

; 1179 :                 else
; 1180 :                     fixup_type = FIX_OFF32;

	mov	ebp, 6

; 1181 :             } else

	jmp	SHORT $LN81@idata_fixu
$LN80@idata_fixu:

; 1182 :                 fixup_type = FIX_OFF16;
; 1183 :     } else {
; 1184 :         /* v2.04: changed, no longer depends on OfsSize */
; 1185 :         //if ( CodeInfo->mem_type == MT_DWORD ) {
; 1186 :             /* fixme !!!! warning
; 1187 :              * operand size is 16bit
; 1188 :              * but fixup is 32-bit */
; 1189 :         //    fixup_type = FIX_OFF32;
; 1190 :         //} else
; 1191 :             fixup_type = FIX_OFF16;

	mov	ebp, 5
$LN81@idata_fixu:

; 1192 :     }
; 1193 :     /* v2.04: 'if' added, don't set W bit if size == 1
; 1194 :      * code example:
; 1195 :      *   extern x:byte
; 1196 :      *   or al,x
; 1197 :      * v2.11: set wide bit only if immediate is second operand.
; 1198 :      * and first operand is a memory reference with size > 1
; 1199 :      */
; 1200 :     //if ( size != 1 )
; 1201 :     if ( CurrOpnd == OPND2 && size != 1 )

	cmp	r12d, 1
	jne	SHORT $LN89@idata_fixu
	cmp	edx, r12d
	je	SHORT $LN89@idata_fixu

; 1202 :         CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], r12b
$LN89@idata_fixu:

; 1203 : 
; 1204 :     segm_override( opndx, NULL ); /* set SegOverride global var */

	mov	rcx, QWORD PTR [rdi+48]
	test	rcx, rcx
	je	SHORT $LN138@idata_fixu
	cmp	BYTE PTR [rcx], 2
	jne	SHORT $LN118@idata_fixu
	mov	eax, DWORD PTR [rcx+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	ecx, BYTE PTR SpecialTable[r9+rcx*4+10]
	mov	eax, ecx
	add	rax, rax
	cmp	BYTE PTR SegAssumeTable[r9+rax*8+8], 0
	je	SHORT $LN120@idata_fixu
	mov	ecx, 183				; 000000b7H
	call	EmitError
$LN138@idata_fixu:
	mov	rdx, QWORD PTR SegOverride
$LN123@idata_fixu:

; 1205 : 
; 1206 :     /* set frame type in variables Frame_Type and Frame_Datum for fixup creation */
; 1207 :     if ( ModuleInfo.offsettype == OT_SEGMENT &&

	cmp	DWORD PTR ModuleInfo+384, 2
	jne	SHORT $LN90@idata_fixu
	mov	eax, DWORD PTR [rdi+56]
	cmp	eax, 241				; 000000f1H
	je	SHORT $LN92@idata_fixu
	cmp	eax, 244				; 000000f4H
	jne	SHORT $LN90@idata_fixu
$LN92@idata_fixu:

; 1208 :         ( opndx->instr == T_OFFSET || opndx->instr == T_SEG ))
; 1209 :         set_frame2( opndx->sym );

	mov	rcx, QWORD PTR [rdi+80]
	test	rdx, rdx
	cmovne	rcx, rdx
	mov	dl, 1
	jmp	SHORT $LN156@idata_fixu

; 1203 : 
; 1204 :     segm_override( opndx, NULL ); /* set SegOverride global var */

$LN120@idata_fixu:
	call	GetOverrideAssume
	jmp	SHORT $LN155@idata_fixu
$LN118@idata_fixu:
	mov	rcx, QWORD PTR [rcx+8]
	call	SymFind
$LN155@idata_fixu:
	mov	rcx, rax
	test	rax, rax
	je	SHORT $LN138@idata_fixu
	mov	eax, DWORD PTR [rax+32]
	mov	rdx, QWORD PTR SegOverride
	sub	eax, 3
	cmp	eax, 1
	cmovbe	rdx, rcx
	mov	QWORD PTR SegOverride, rdx
	jmp	SHORT $LN123@idata_fixu
$LN90@idata_fixu:

; 1210 :     else
; 1211 :         set_frame( opndx->sym );

	mov	rcx, QWORD PTR [rdi+80]
	test	rdx, rdx
	cmovne	rcx, rdx
	xor	edx, edx
$LN156@idata_fixu:
	call	SetFixupFrame

; 1212 : 
; 1213 :     //DebugMsg1(("idata_fixup: calling CreateFixup(%s, %u)\n", opndx->sym->name, fixup_type ));
; 1214 :     CodeInfo->opnd[CurrOpnd].InsFixup = CreateFixup( opndx->sym, fixup_type, fixup_option );

	mov	r8d, DWORD PTR fixup_option$1$[rsp]
	mov	edx, ebp
	mov	rcx, QWORD PTR [rdi+80]
	call	CreateFixup
	lea	rcx, QWORD PTR [rsi+rsi*2]
	mov	QWORD PTR [rbx+rcx*8+48], rax

; 1215 : 
; 1216 :     if ( opndx->instr == T_LROFFSET )

	cmp	DWORD PTR [rdi+56], 239			; 000000efH
	jne	SHORT $LN93@idata_fixu

; 1217 :         CodeInfo->opnd[CurrOpnd].InsFixup->loader_resolved = TRUE;

	or	BYTE PTR [rax+33], 1
$LN93@idata_fixu:

; 1218 : 
; 1219 : #if IMAGERELSUPP
; 1220 :     if ( opndx->instr == T_IMAGEREL && fixup_type == FIX_OFF32 )

	cmp	DWORD PTR [rdi+56], 233			; 000000e9H
	jne	SHORT $LN94@idata_fixu
	cmp	ebp, 6
	jne	SHORT $LN94@idata_fixu

; 1221 :         CodeInfo->opnd[CurrOpnd].InsFixup->type = FIX_OFF32_IMGREL;

	mov	rax, QWORD PTR [rbx+rcx*8+48]
	mov	DWORD PTR [rax+24], 12
$LN94@idata_fixu:

; 1222 : #endif
; 1223 : #if SECTIONRELSUPP
; 1224 :     if ( opndx->instr == T_SECTIONREL && fixup_type == FIX_OFF32 )

	cmp	DWORD PTR [rdi+56], 243			; 000000f3H
	jne	SHORT $LN95@idata_fixu
	cmp	ebp, 6
	jne	SHORT $LN95@idata_fixu

; 1225 :         CodeInfo->opnd[CurrOpnd].InsFixup->type = FIX_OFF32_SECREL;

	mov	rax, QWORD PTR [rbx+rcx*8+48]
	mov	DWORD PTR [rax+24], 13
$LN95@idata_fixu:

; 1226 : #endif
; 1227 :     DebugMsg1(("idata_fixup exit [CodeInfo.mem_type=%Xh Ofssize=%u opsiz=%u fixup.type=%u fixup.frame=%d]\n",
; 1228 :                CodeInfo->mem_type, CodeInfo->Ofssize, CodeInfo->prefix.opsiz,
; 1229 :                CodeInfo->opnd[CurrOpnd].InsFixup->type, CodeInfo->opnd[CurrOpnd].InsFixup->frame_type ));
; 1230 : 
; 1231 :     return( NOT_ERROR );

	xor	eax, eax
$LN152@idata_fixu:
	mov	rbp, QWORD PTR [rsp+88]
	mov	r15, QWORD PTR [rsp+32]
$LN150@idata_fixu:
	mov	rsi, QWORD PTR [rsp+96]
	mov	r13, QWORD PTR [rsp+104]
	mov	r14, QWORD PTR [rsp+40]

; 1232 : }

	add	rsp, 48					; 00000030H
	pop	r12
	pop	rdi
	pop	rbx
	ret	0
	npad	2
$LN137@idata_fixu:
	DD	$LN52@idata_fixu
	DD	$LN53@idata_fixu
	DD	$LN8@idata_fixu
$LN136@idata_fixu:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	0
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
idata_fixup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
;	COMDAT idata_nofixup
_TEXT	SEGMENT
CodeInfo$ = 80
CurrOpnd$ = 88
opndx$ = 96
idata_nofixup PROC					; COMDAT

; 784  : {

	push	rbx
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	eax, DWORD PTR [rcx+24]
	mov	rdi, r8
	sub	eax, 454				; 000001c6H
	mov	r14d, edx
	mov	rbx, rcx
	cmp	eax, 49					; 00000031H
	ja	SHORT $LN6@idata_nofi

; 785  :     enum operand_type op_type;
; 786  :     int_32      value;
; 787  :     int         size;
; 788  : 
; 789  :     DebugMsg1(("idata_nofixup( CurrOpnd=%u ) enter [opnd kind=%u mem_type=%Xh value=%" I64_SPEC "X]\n", CurrOpnd, opndx->kind, opndx->mem_type, opndx->value64));
; 790  : 
; 791  :     /* jmp/call/jxx/loop/jcxz/jecxz? */
; 792  :     if( IS_ANY_BRANCH( CodeInfo->token ) ) {
; 793  :         return( process_branch( CodeInfo, CurrOpnd, opndx ) );

	mov	edx, r14d

; 907  : }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rbx

; 785  :     enum operand_type op_type;
; 786  :     int_32      value;
; 787  :     int         size;
; 788  : 
; 789  :     DebugMsg1(("idata_nofixup( CurrOpnd=%u ) enter [opnd kind=%u mem_type=%Xh value=%" I64_SPEC "X]\n", CurrOpnd, opndx->kind, opndx->mem_type, opndx->value64));
; 790  : 
; 791  :     /* jmp/call/jxx/loop/jcxz/jecxz? */
; 792  :     if( IS_ANY_BRANCH( CodeInfo->token ) ) {
; 793  :         return( process_branch( CodeInfo, CurrOpnd, opndx ) );

	jmp	process_branch
$LN6@idata_nofi:
	mov	QWORD PTR [rsp+88], rsi

; 794  :     }
; 795  :     value = opndx->value;
; 796  :     CodeInfo->opnd[CurrOpnd].data32l = value;

	lea	rcx, QWORD PTR [r14+r14*2]
	mov	esi, DWORD PTR [r8]
	mov	QWORD PTR [rsp+32], r15
	lea	r15, QWORD PTR [rbx+rcx*8]
	mov	DWORD PTR [r15+40], esi

; 797  : 
; 798  : #if AMD64_SUPPORT
; 799  :     /* 64bit immediates are restricted to MOV <reg>,<imm64>
; 800  :      */
; 801  :     if ( opndx->hlvalue != 0 ) { /* magnitude > 64 bits? */

	cmp	QWORD PTR [r8+8], 0
	je	SHORT $LN7@idata_nofi

; 802  :         DebugMsg1(("idata_nofixup: error, hlvalue=%" I64_SPEC "X\n", opndx->hlvalue ));
; 803  :         return( EmitConstError( opndx ) );

	mov	rcx, r8
	call	EmitConstError
	jmp	$LN42@idata_nofi
$LN7@idata_nofi:
	mov	QWORD PTR [rsp+80], rbp

; 804  :     }
; 805  :     /* v2.03: handle QWORD type coercion here as well!
; 806  :      * This change also reveals an old problem in the expression evaluator:
; 807  :      * the mem_type field is set whenever a (simple) type token is found.
; 808  :      * It should be set ONLY when the type is used in conjuction with the
; 809  :      * PTR operator!
; 810  :      * current workaround: query the 'explicit' flag.
; 811  :      */
; 812  :     //if ( opndx->value64 <= minintvalues[0] || opndx->value64 > maxintvalues[0] ) {
; 813  :     /* use long format of MOV for 64-bit if value won't fit in a signed DWORD */
; 814  :     if ( CodeInfo->Ofssize == USE64 &&
; 815  :         CodeInfo->token == T_MOV &&
; 816  :         CurrOpnd == OPND2 &&
; 817  :         ( CodeInfo->opnd[OPND1].type & OP_R64 ) &&

	movzx	ebp, BYTE PTR [rbx+106]
	cmp	bpl, 2
	jne	SHORT $LN8@idata_nofi
	cmp	DWORD PTR [rbx+24], 605			; 0000025dH
	jne	SHORT $LN8@idata_nofi
	cmp	r14d, 1
	jne	SHORT $LN8@idata_nofi
	test	BYTE PTR [rbx+32], 8
	je	SHORT $LN8@idata_nofi
	mov	rax, QWORD PTR [r8]
	mov	ecx, -2147483648			; 80000000H
	add	rax, rcx
	mov	ecx, -1					; ffffffffH
	cmp	rax, rcx
	ja	SHORT $LN10@idata_nofi
	test	BYTE PTR [r8+72], bpl
	je	SHORT $LN8@idata_nofi
	mov	eax, DWORD PTR [r8+64]
	sub	eax, 7
	test	eax, -65				; ffffffbfH
	jne	SHORT $LN8@idata_nofi
$LN10@idata_nofi:

; 818  :         ( opndx->value64 > LONG_MAX || opndx->value64 < LONG_MIN ||
; 819  :          (opndx->explicit && ( opndx->mem_type == MT_QWORD || opndx->mem_type == MT_SQWORD ) ) ) ) {
; 820  :         // CodeInfo->iswide = 1; /* has been set by first operand already */
; 821  :         CodeInfo->opnd[CurrOpnd].type = OP_I64;

	mov	DWORD PTR [rbx+56], 1048576		; 00100000H

; 822  :         CodeInfo->opnd[CurrOpnd].data32h = opndx->hvalue;

	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rbx+68], eax

; 823  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN43@idata_nofi
$LN8@idata_nofi:

; 824  :     }
; 825  :     if ( opndx->value64 <= minintvalues[0] || opndx->value64 > maxintvalues[0] ) {

	mov	rax, QWORD PTR [r8]
	cmp	rax, QWORD PTR minintvalues
	jle	$LN12@idata_nofi
	cmp	rax, QWORD PTR maxintvalues
	jg	$LN12@idata_nofi

; 828  :     }
; 829  : #endif
; 830  : 
; 831  :     /* v2.06: code simplified.
; 832  :      * to be fixed: the "wide" bit should not be set here!
; 833  :      * Problem: the "wide" bit isn't set in memory_operand(),
; 834  :      * probably because of the instructions which accept both
; 835  :      * signed and unsigned arguments (ADD, CMP, ... ).
; 836  :      */
; 837  : 
; 838  :     if ( opndx->explicit ) {

	test	BYTE PTR [r8+72], 2
	mov	QWORD PTR [rsp+96], r12
	mov	r12d, 524288				; 00080000H
	mov	QWORD PTR [rsp+40], r13
	mov	r13d, 262144				; 00040000H
	je	SHORT $LN13@idata_nofi

; 839  :         /* size coercion for immediate value */
; 840  :         CodeInfo->const_size_fixed = TRUE;

	or	BYTE PTR [rbx+142], 8

; 841  :         size = SizeFromMemtype( opndx->mem_type,

	movzx	edx, BYTE PTR [r8+69]
	mov	r8, QWORD PTR [r8+96]
	mov	ecx, DWORD PTR [rdi+64]
	call	SizeFromMemtype

; 842  :                                opndx->Ofssize,
; 843  :                                opndx->type );
; 844  :         /* don't check if size and value are compatible. */
; 845  :         switch ( size ) {

	sub	eax, 1
	je	SHORT $LN15@idata_nofi
	sub	eax, 1
	je	SHORT $LN16@idata_nofi
	cmp	eax, 2
	je	SHORT $LN17@idata_nofi

; 849  :         default:
; 850  :             DebugMsg1(("idata_nofixup: invalid size %d for immediate operand\n", size ));
; 851  :             return( EmitError( INVALID_INSTRUCTION_OPERANDS ) );

	mov	ecx, 49					; 00000031H
	call	EmitError
$LN45@idata_nofi:
	mov	r13, QWORD PTR [rsp+40]
	mov	r12, QWORD PTR [rsp+96]
$LN43@idata_nofi:
	mov	rbp, QWORD PTR [rsp+80]
$LN42@idata_nofi:
	mov	rsi, QWORD PTR [rsp+88]
	mov	r15, QWORD PTR [rsp+32]

; 907  : }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rbx
	ret	0
$LN17@idata_nofi:

; 848  :         case 4: op_type = OP_I32; break;

	mov	ecx, r12d
	jmp	SHORT $LN21@idata_nofi
$LN16@idata_nofi:

; 846  :         case 1: op_type = OP_I8;  break;
; 847  :         case 2: op_type = OP_I16; break;

	mov	ecx, r13d
	jmp	SHORT $LN21@idata_nofi
$LN13@idata_nofi:

; 852  :         }
; 853  :     } else {
; 854  :         /* use true signed values for BYTE only! */
; 855  :         if ( (int_8)value == value )

	movsx	eax, sil
	cmp	eax, esi
	jne	SHORT $LN19@idata_nofi
$LN15@idata_nofi:

; 856  :             op_type = OP_I8;

	mov	ecx, 131072				; 00020000H
	jmp	SHORT $LN21@idata_nofi
$LN19@idata_nofi:

; 857  :         //else if ( value <= SHRT_MAX && value >= SHRT_MIN )
; 858  :         /* v2.04: range FFFF0000-FFFF7FFF is also acceptable for 16-bit */
; 859  :         //else if ( value <= USHRT_MAX && value >= SHRT_MIN )
; 860  :         /* v2.04b: HJWASMR needs a 1L */
; 861  :         //else if( value <= USHRT_MAX && value >= - (USHRT_MAX+1) )
; 862  :         /* v2.07: HJWASMR needs 0L before the - op */
; 863  :         //else if( value <= USHRT_MAX && value >= - USHRT_MAX )
; 864  :         else if( value <= USHRT_MAX && value >= 0L - USHRT_MAX )

	lea	eax, DWORD PTR [rsi+65535]
	mov	ecx, r12d
	cmp	eax, 131070				; 0001fffeH
	cmovbe	ecx, r13d
$LN21@idata_nofi:

; 865  :             op_type = OP_I16;
; 866  :         else {
; 867  :             op_type = OP_I32;
; 868  :         }
; 869  :     }
; 870  : 
; 871  :     switch ( CodeInfo->token ) {

	mov	edx, DWORD PTR [rbx+24]
	sub	edx, 564				; 00000234H
	je	SHORT $LN32@idata_nofi
	sub	edx, 36					; 00000024H
	je	SHORT $LN23@idata_nofi
	cmp	edx, 2
	jne	SHORT $LN33@idata_nofi

; 882  :     case T_PUSHW:
; 883  :         if ( op_type != OP_I32 ) {

	cmp	ecx, r12d
	je	SHORT $LN33@idata_nofi

; 884  :             op_type = OP_I16;
; 885  :             if( (int_8)value == (int_16)value ) {

	movsx	eax, sil
	mov	ecx, r13d
	cmp	ax, si
	jne	SHORT $LN33@idata_nofi

; 886  :                 op_type = OP_I8;

	mov	ecx, 131072				; 00020000H

; 887  :             }
; 888  :         }
; 889  :         break;

	jmp	SHORT $LN33@idata_nofi
$LN23@idata_nofi:

; 872  :     case T_PUSH:
; 873  :         if ( opndx->explicit == FALSE ) {

	test	BYTE PTR [rdi+72], 2
	jne	SHORT $LN25@idata_nofi

; 874  :             if ( CodeInfo->Ofssize > USE16 && op_type == OP_I16 )

	test	bpl, bpl
	je	SHORT $LN25@idata_nofi
	cmp	ecx, r13d
	jne	SHORT $LN26@idata_nofi

; 875  :                 op_type = OP_I32;

	mov	ecx, r12d

; 876  :         }
; 877  :         if ( op_type == OP_I16 )

	jmp	SHORT $LN37@idata_nofi
$LN25@idata_nofi:
	cmp	ecx, r13d
	jne	SHORT $LN26@idata_nofi

; 878  :             CodeInfo->prefix.opsiz = OPSIZE16( CodeInfo );

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	test	bpl, bpl
	setne	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al
	jmp	SHORT $LN33@idata_nofi
$LN26@idata_nofi:

; 879  :         else if ( op_type == OP_I32 )

	cmp	ecx, r12d
	jne	SHORT $LN33@idata_nofi
$LN37@idata_nofi:

; 880  :             CodeInfo->prefix.opsiz = OPSIZE32( CodeInfo );

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	test	bpl, bpl
	sete	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al

; 881  :         break;

	jmp	SHORT $LN33@idata_nofi
$LN32@idata_nofi:

; 890  :     case T_PUSHD:
; 891  :         if ( op_type == OP_I16 )

	cmp	ecx, r13d
	cmove	ecx, r12d
$LN33@idata_nofi:

; 892  :             op_type = OP_I32;
; 893  :         break;
; 894  :     }
; 895  : 
; 896  :     /* v2.11: set the wide-bit if a mem_type size of > BYTE is set???
; 897  :      * actually, it should only be set if immediate is second operand
; 898  :      * ( and first operand is a memory ref with a size > 1 )
; 899  :      */
; 900  :     if ( CurrOpnd == OPND2 )

	cmp	r14d, 1
	jne	SHORT $LN35@idata_nofi

; 901  :         if ( !(CodeInfo->mem_type & MT_SPECIAL) && ( CodeInfo->mem_type & MT_SIZE_MASK ) )

	mov	eax, DWORD PTR [rbx+28]
	test	al, al
	js	SHORT $LN35@idata_nofi
	test	al, 31
	je	SHORT $LN35@idata_nofi

; 902  :             CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], r14b
$LN35@idata_nofi:

; 903  : 
; 904  :     CodeInfo->opnd[CurrOpnd].type = op_type;

	mov	DWORD PTR [r15+32], ecx

; 905  :     DebugMsg1(("idata_nofixup exit, op_type=%" I32_SPEC "X\n", op_type ));
; 906  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN45@idata_nofi
$LN12@idata_nofi:

; 826  :         DebugMsg1(("idata_nofixup: error, hvalue=%Xh\n", opndx->hvalue ));
; 827  :         return( EmitConstError( opndx ) );

	mov	rcx, r8
	call	EmitConstError
	jmp	$LN43@idata_nofi
idata_nofixup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
opndx$ = 48
CodeInfo$ = 56
segm_override PROC

; 742  : {

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 743  :     struct asym      *sym;
; 744  : 
; 745  :     if( opndx->override != NULL ) {

	mov	rcx, QWORD PTR [rcx+48]
	mov	rbx, rdx
	test	rcx, rcx
	je	$LN8@segm_overr

; 746  :         if( opndx->override->token == T_REG ) {

	cmp	BYTE PTR [rcx], 2
	jne	SHORT $LN3@segm_overr

; 747  :             int temp = GetRegNo( opndx->override->tokval );

	mov	eax, DWORD PTR [rcx+16]
	lea	rdx, OFFSET FLAT:__ImageBase
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	edi, BYTE PTR SpecialTable[rdx+rcx*4+10]

; 748  :             if ( SegAssumeTable[temp].error ) {

	mov	eax, edi
	add	rax, rax
	cmp	BYTE PTR SegAssumeTable[rdx+rax*8+8], 0
	je	SHORT $LN5@segm_overr

; 749  :                 DebugMsg(("segm_override: assume error, reg=%u\n", temp ));
; 750  :                 return( EmitError( USE_OF_REGISTER_ASSUMED_TO_ERROR ) );

	mov	ecx, 183				; 000000b7H

; 771  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 749  :                 DebugMsg(("segm_override: assume error, reg=%u\n", temp ));
; 750  :                 return( EmitError( USE_OF_REGISTER_ASSUMED_TO_ERROR ) );

	jmp	EmitError
$LN5@segm_overr:

; 751  :             }
; 752  : #if AMD64_SUPPORT
; 753  :             /* ES,CS,SS and DS overrides are invalid in 64-bit */
; 754  :             if ( CodeInfo && CodeInfo->Ofssize == USE64 && temp < ASSUME_FS ) {

	test	rbx, rbx
	je	SHORT $LN6@segm_overr
	cmp	BYTE PTR [rbx+106], 2
	jne	SHORT $LN6@segm_overr
	cmp	edi, 4
	jge	SHORT $LN6@segm_overr

; 755  :                 return( EmitError( ILLEGAL_USE_OF_SEGMENT_REGISTER ) );

	mov	ecx, 275				; 00000113H

; 771  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 755  :                 return( EmitError( ILLEGAL_USE_OF_SEGMENT_REGISTER ) );

	jmp	EmitError
$LN6@segm_overr:

; 756  :             }
; 757  : #endif
; 758  :             sym = GetOverrideAssume( temp );

	mov	ecx, edi
	call	GetOverrideAssume
	mov	rdx, rax

; 759  :             if ( CodeInfo ) {

	test	rbx, rbx
	je	SHORT $LN4@segm_overr

; 760  :                 /* hack: save the previous reg override value (needed for CMPS) */
; 761  :                 LastRegOverride = CodeInfo->prefix.RegOverride;

	mov	ecx, DWORD PTR [rbx+4]
	mov	DWORD PTR LastRegOverride, ecx

; 762  :                 CodeInfo->prefix.RegOverride = temp;

	mov	DWORD PTR [rbx+4], edi

; 763  :             }
; 764  :         } else {

	jmp	SHORT $LN4@segm_overr
$LN3@segm_overr:

; 765  :             sym = SymSearch( opndx->override->string_ptr );

	mov	rcx, QWORD PTR [rcx+8]
	call	SymFind
	mov	rdx, rax
$LN4@segm_overr:

; 766  :         }
; 767  :         if ( sym && ( sym->state == SYM_GRP || sym->state == SYM_SEG ))

	test	rdx, rdx
	je	SHORT $LN8@segm_overr
	mov	eax, DWORD PTR [rdx+32]
	mov	rcx, QWORD PTR SegOverride
	sub	eax, 3
	cmp	eax, 1
	cmovbe	rcx, rdx
	mov	QWORD PTR SegOverride, rcx
$LN8@segm_overr:

; 768  :             SegOverride = sym;
; 769  :     }
; 770  :     return( NOT_ERROR );

	xor	eax, eax

; 771  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
segm_override ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
;	COMDAT set_rm_sib
_TEXT	SEGMENT
CodeInfo$ = 80
CurrOpnd$ = 88
ss$ = 96
index$ = 104
bit3_idx$1$ = 112
base$ = 112
sym$ = 120
set_rm_sib PROC						; COMDAT

; 503  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 504  :     int                 temp;
; 505  :     unsigned char       mod_field;
; 506  :     unsigned char       rm_field;
; 507  :     unsigned char       base_reg;
; 508  :     unsigned char       idx_reg;
; 509  : #if AMD64_SUPPORT
; 510  :     unsigned char       bit3_base;
; 511  :     unsigned char       bit3_idx;
; 512  :     unsigned char       rex;
; 513  : #endif
; 514  : 
; 515  :     DebugMsg1(("set_rm_sib(scale=%u, index=%d, base=%d, sym=%s) enter [CI.adrsiz=%u]\n", 1 << (ss >> 6), index, base, sym ? sym->name : "NULL", CodeInfo->prefix.adrsiz ));
; 516  : 
; 517  :     /* clear mod */
; 518  :     rm_field = 0;
; 519  :     CodeInfo->basetype = base;

	movsxd	rbp, DWORD PTR base$[rsp]

; 520  : #if AMD64_SUPPORT
; 521  :     bit3_base = 0;
; 522  :     bit3_idx = 0;
; 523  :     rex = 0;

	xor	r14b, r14b
	mov	r13d, edx
	movzx	r11d, r8b
	mov	BYTE PTR [rcx+108], bpl
	mov	rbx, rcx

; 524  : #endif
; 525  :     if( CodeInfo->opnd[CurrOpnd].InsFixup != NULL ) { /* symbolic displacement given? */

	mov	edi, edx
	mov	edx, 64					; 00000040H
	movsxd	r15, r9d
	lea	rax, QWORD PTR [r13+2]
	lea	rax, QWORD PTR [rax+rax*2]
	cmp	QWORD PTR [rcx+rax*8], 0
	lea	r12, QWORD PTR [rcx+rax*8]
	je	SHORT $LN6@set_rm_sib

; 526  :         mod_field = MOD_10;

	mov	sil, 128				; 00000080H
	jmp	SHORT $LN12@set_rm_sib
$LN6@set_rm_sib:

; 527  :     } else if((CodeInfo->opnd[CurrOpnd].data32l == 0) ||( base == T_RIP)) { /* no displacement (or 0) */

	lea	rax, QWORD PTR [r13*2]
	add	rax, r13
	mov	eax, DWORD PTR [rcx+rax*8+40]
	test	eax, eax
	je	SHORT $LN10@set_rm_sib
	cmp	ebp, 131				; 00000083H
	je	SHORT $LN10@set_rm_sib

; 529  :     } else if( ( CodeInfo->opnd[CurrOpnd].data32l > SCHAR_MAX )
; 530  :        || ( CodeInfo->opnd[CurrOpnd].data32l < SCHAR_MIN ) ) {
; 531  :         mod_field = MOD_10; /* full size displacement */
; 532  :     } else {

	sub	eax, -128				; ffffffffffffff80H
	mov	esi, 128				; 00000080H
	cmp	eax, 255				; 000000ffH
	cmovbe	esi, edx
	jmp	SHORT $LN12@set_rm_sib
$LN10@set_rm_sib:

; 528  :         mod_field = MOD_00;

	xor	sil, sil
$LN12@set_rm_sib:

; 533  :         mod_field = MOD_01; /* byte size displacement */
; 534  :     }
; 535  : 
; 536  :     if( ( index == EMPTY ) && ( base == EMPTY ) ) {

	cmp	r15d, -2
	jne	$LN60@set_rm_sib
	cmp	ebp, r15d
	jne	$LN62@set_rm_sib

; 537  :         /* direct memory.
; 538  :          * clear the rightmost 3 bits
; 539  :          */
; 540  :         CodeInfo->isdirect = TRUE;
; 541  :         mod_field = MOD_00;
; 542  : 
; 543  :         /* default is DS:[], DS: segment override is not needed */
; 544  :         seg_override( CodeInfo, T_DS, sym, TRUE );

	mov	r8, QWORD PTR sym$[rsp]
	lea	edx, QWORD PTR [r15+30]
	or	BYTE PTR [rcx+142], 2
	mov	r9b, 1
	xor	sil, sil
	call	seg_override

; 545  : 
; 546  :         DebugMsg1(( "set_rm_sib: direct addressing, CI.Ofssize=%u / adrsize=%u / data=%" I32_SPEC "X\n",
; 547  :                    CodeInfo->Ofssize, CodeInfo->prefix.adrsiz, CodeInfo->opnd[CurrOpnd].data32l ));
; 548  :         //if( !IS_ADDR32( CodeInfo ) ) {
; 549  :         if( ( CodeInfo->Ofssize == USE16 && CodeInfo->prefix.adrsiz == 0 ) ||

	movzx	eax, BYTE PTR [rbx+106]
	test	al, al
	jne	SHORT $LN19@set_rm_sib
	test	BYTE PTR [rbx+9], 1
	je	SHORT $LN18@set_rm_sib
$LN19@set_rm_sib:
	cmp	al, 1
	jne	SHORT $LN16@set_rm_sib
	test	BYTE PTR [rbx+9], al
	je	SHORT $LN16@set_rm_sib
$LN18@set_rm_sib:

; 550  :             ( CodeInfo->Ofssize == USE32 && CodeInfo->prefix.adrsiz == 1 )) {
; 551  :             if( !InWordRange( CodeInfo->opnd[CurrOpnd].data32l ) ) {

	lea	rax, QWORD PTR [r13*2]
	add	rax, r13
	mov	ecx, DWORD PTR [rbx+rax*8+40]
	add	ecx, 65535				; 0000ffffH
	cmp	ecx, 131070				; 0001fffeH
	jbe	SHORT $LN20@set_rm_sib

; 552  :                 /* expect 16-bit but got 32-bit address */
; 553  :                 DebugMsg1(( "set_rm_sib: error, Ofssize=%u, adrsize=%u, data=%" I32_SPEC "X\n",
; 554  :                         CodeInfo->Ofssize, CodeInfo->prefix.adrsiz, CodeInfo->opnd[CurrOpnd].data32l ));
; 555  :                 return( EmitError( MAGNITUDE_OF_OFFSET_EXCEEDS_16BIT ) );

	mov	ecx, 58					; 0000003aH
	call	EmitError
	jmp	$LN1@set_rm_sib
$LN20@set_rm_sib:

; 556  :             }
; 557  :             rm_field = RM_D16; /* D16=110b */

	mov	dil, 6

; 558  :         } else {

	jmp	$LN4@set_rm_sib
$LN16@set_rm_sib:

; 559  :             rm_field = RM_D32; /* D32=101b */

	mov	dil, 5

; 560  : #if AMD64_SUPPORT
; 561  :             /* v2.03: the non-RIP encoding for 64bit uses a redundant SIB mode (base=none, index=none) */
; 562  :             /* v2.11: always use 64-bit non-RIP addressing if no fixup has been created. */
; 563  :             //if ( CodeInfo->Ofssize == USE64 && CodeInfo->prefix.RegOverride != EMPTY && SegOverride != &ModuleInfo.flat_grp->sym ) {
; 564  :             if ( CodeInfo->Ofssize == USE64 && CodeInfo->opnd[CurrOpnd].InsFixup == NULL ) {

	cmp	al, 2
	jne	$LN4@set_rm_sib
	cmp	QWORD PTR [r12], 0
	jne	$LN4@set_rm_sib

; 565  :                 DebugMsg1(( "set_rm_sib: 64-bit, no fixup, data64=%" I64_SPEC "X\n", CodeInfo->opnd[CurrOpnd].data64 ));
; 566  :                 rm_field = RM_SIB;

	mov	dil, 4

; 567  :                 CodeInfo->sib = 0x25; /* IIIBBB, base=101b, index=100b */

	mov	BYTE PTR [rbx+105], 37			; 00000025H

; 568  :             }
; 569  : #endif
; 570  :         }

	jmp	$LN4@set_rm_sib
$LN62@set_rm_sib:

; 571  :         DebugMsg1(("set_rm_sib, direct, CodeInfo->prefix.adrsiz=%u\n", CodeInfo->prefix.adrsiz ));
; 572  :     } else if( ( index == EMPTY ) && ( base != EMPTY ) ) {
; 573  :         /* for SI, DI and BX: default is DS:[],
; 574  :          * DS: segment override is not needed
; 575  :          * for BP: default is SS:[], SS: segment override is not needed
; 576  :          */
; 577  :         switch( base ) {

	mov	ecx, ebp
	sub	ecx, 12
	je	$LN29@set_rm_sib
	sub	ecx, 2
	je	SHORT $LN26@set_rm_sib
	sub	ecx, 1
	je	$LN24@set_rm_sib
	cmp	ecx, 1
	je	SHORT $LN25@set_rm_sib

; 592  :             break;
; 593  :         default: /* for 386 and up */
; 594  :             base_reg = GetRegNo( base );

	lea	rcx, QWORD PTR [rbp*2]
	add	rcx, rbp
	lea	r8, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR SpecialTable[r8+rcx*4+10]

; 595  : #if AMD64_SUPPORT
; 596  :             if (base_reg == 16)

	mov	ecx, 5
	cmp	al, 16
	mov	edi, eax
	cmove	edi, ecx

; 597  :                base_reg=5;  //RIP bytval=16 but we need 5 added by habran
; 598  :             bit3_base = base_reg >> 3;

	movzx	r14d, dil

; 599  :             base_reg &= BIT_012;

	and	dil, 7
	shr	r14b, 3

; 600  : #endif
; 601  :             rm_field = base_reg;
; 602  :             DebugMsg1(("set_rm_sib: base_reg is %u\n", base_reg ));
; 603  :             if ( base_reg == 4 ) {

	cmp	dil, 4
	jne	SHORT $LN32@set_rm_sib

; 604  :                 /* 4 is RSP/ESP or R12/R12D, which must use SIB encoding.
; 605  :                  * SSIIIBBB, ss = 00, index = 100b ( no index ), base = 100b ( ESP ) */
; 606  :                 CodeInfo->sib = 0x24;

	mov	BYTE PTR [rbx+105], 36			; 00000024H
	jmp	$LN2@set_rm_sib
$LN32@set_rm_sib:

; 607  :             } else if ( base_reg == 5 && mod_field == MOD_00 ) {

	cmp	dil, cl
	jne	$LN2@set_rm_sib
	test	sil, sil
	jne	$LN2@set_rm_sib

; 608  :                 /* 5 is [E|R]BP or R13[D]. Needs displacement */
; 609  :                // 5 is also RIP register but doesn't need MOD_01
; 610  :                 if (base != T_RIP)  //added by habran

	cmp	ebp, 131				; 00000083H
	movzx	esi, sil
	cmovne	esi, edx

; 611  :                  mod_field = MOD_01; /* byte size displacement */
; 612  :             }
; 613  : #if AMD64_SUPPORT
; 614  :             /* v2.02 */
; 615  :             //rex = ( bit3_base << 2 ); /* set REX_R */
; 616  :             rex = bit3_base; /* set REX_R */

	jmp	$LN2@set_rm_sib
$LN25@set_rm_sib:

; 578  :         case T_SI:
; 579  :             rm_field = RM_SI; /* 4 */
; 580  :             break;
; 581  :         case T_DI:
; 582  :             rm_field = RM_DI; /* 5 */

	mov	dil, 5

; 583  :             break;

	jmp	$LN2@set_rm_sib
$LN26@set_rm_sib:

; 584  :         case T_BP:
; 585  :             rm_field = RM_BP; /* 6 */

	mov	dil, 6

; 586  :             if( mod_field == MOD_00 ) {

	test	sil, sil
	jne	$LN2@set_rm_sib

; 587  :                if (base != T_RIP) mod_field = MOD_01;

	movzx	esi, dl

; 588  :             }
; 589  :             break;

	jmp	$LN2@set_rm_sib
$LN29@set_rm_sib:

; 590  :         case T_BX:
; 591  :             rm_field = RM_BX; /* 7 */

	mov	dil, 7

; 617  : #endif
; 618  :         }
; 619  : #if AMD64_SUPPORT
; 620  :         DebugMsg1(("set_rm_sib, indirect with base, mod_field=%X, rm_field=%X, rex=%X\n", mod_field, rm_field, rex ));
; 621  : #else
; 622  :         DebugMsg1(("set_rm_sib, indirect with base, rm_field=%X\n", rm_field ));
; 623  : #endif
; 624  :         seg_override( CodeInfo, base, sym, FALSE );

	jmp	$LN2@set_rm_sib
$LN60@set_rm_sib:

; 625  :     } else if( ( index != EMPTY ) && ( base == EMPTY ) ) {
; 626  :         idx_reg = GetRegNo( index );

	lea	r8, OFFSET FLAT:__ImageBase
	cmp	ebp, -2
	jne	SHORT $LN36@set_rm_sib
	lea	rcx, QWORD PTR [r15+r15*2]

; 627  : #if AMD64_SUPPORT
; 628  :         bit3_idx = idx_reg >> 3;
; 629  :         idx_reg &= BIT_012;
; 630  : #endif
; 631  :         /* mod field is 00 */
; 632  :         mod_field = MOD_00;

	xor	sil, sil
	movzx	r14d, BYTE PTR SpecialTable[r8+rcx*4+10]

; 633  :         /* s-i-b is present ( r/m = 100b ) */
; 634  :         rm_field = RM_SIB;
; 635  :         /* scale factor, index, base ( 0x05 => no base reg ) */
; 636  :         CodeInfo->sib = ( ss | ( idx_reg << 3 ) | 0x05 );
; 637  : #if AMD64_SUPPORT
; 638  :         rex = (bit3_idx << 1); /* set REX_X */
; 639  : #endif
; 640  :         /* default is DS:[], DS: segment override is not needed */
; 641  :         seg_override( CodeInfo, T_DS, sym, FALSE );

	lea	edx, QWORD PTR [rbp+30]
	movzx	eax, r14b
	mov	dil, 4
	and	al, 7
	shr	r14b, 2
	shl	al, 3
	or	al, r11b
	or	al, 5
	mov	BYTE PTR [rbx+105], al
	and	r14b, 62				; 0000003eH

; 642  :     } else {

	jmp	$LN70@set_rm_sib
$LN36@set_rm_sib:

; 643  :         /* base != EMPTY && index != EMPTY */
; 644  :         base_reg = GetRegNo( base );

	lea	rcx, QWORD PTR [rbp*2]
	add	rcx, rbp

; 645  :         idx_reg  = GetRegNo( index );
; 646  :         if ( base == T_RIP)

	cmp	ebp, 131				; 00000083H
	lea	rdx, QWORD PTR [rcx*4]
	movzx	r10d, BYTE PTR SpecialTable[rdx+r8+10]
	lea	rcx, QWORD PTR [r15+r15*2]
	lea	rdi, QWORD PTR [rcx*4]
	mov	ecx, 5
	movzx	r9d, BYTE PTR SpecialTable[rdi+r8+10]
	cmove	r10d, ecx

; 647  :           base_reg = 0x5;
; 648  : #if AMD64_SUPPORT
; 649  :         bit3_base = base_reg >> 3;
; 650  :         bit3_idx  = idx_reg  >> 3;
; 651  :         base_reg &= BIT_012;
; 652  :         idx_reg  &= BIT_012;
; 653  : #endif
; 654  :         if ( ( GetSflagsSp( base ) & GetSflagsSp( index ) & SFR_SIZMSK ) == 0 ) {

	mov	eax, DWORD PTR SpecialTable[rdi+r8+4]
	movzx	r12d, r10b
	and	eax, DWORD PTR SpecialTable[rdx+r8+4]
	movzx	ecx, r9b
	shr	cl, 3
	and	r10b, 7
	shr	r12b, 3
	and	r9b, 7
	mov	BYTE PTR bit3_idx$1$[rsp], cl
	test	al, 31
	jne	SHORT $LN42@set_rm_sib

; 655  : #if AVXSUPP
; 656  :            CodeInfo->indextype = GetValueSp( index );

	mov	eax, DWORD PTR SpecialTable[rdi+r8]
	mov	DWORD PTR [rbx+132], eax

; 657  :            if (CodeInfo->indextype == OP_XMM || CodeInfo->indextype == OP_YMM || CodeInfo->indextype == OP_ZMM){

	cmp	eax, 32					; 00000020H
	je	SHORT $LN42@set_rm_sib
	cmp	eax, 128				; 00000080H
	je	SHORT $LN42@set_rm_sib
	cmp	eax, 256				; 00000100H
	je	SHORT $LN42@set_rm_sib

; 658  :              ;
; 659  :            }
; 660  :           else
; 661  : #endif
; 662  :           return( EmitError( CANNOT_MIX_16_AND_32_BIT_REGISTERS ) );

	mov	ecx, 38					; 00000026H
	call	EmitError
	jmp	$LN1@set_rm_sib
$LN42@set_rm_sib:

; 663  :         }
; 664  :   
; 665  :         switch( index ) {

	lea	eax, DWORD PTR [r15-12]
	cmp	eax, 119				; 00000077H
	ja	SHORT $LN48@set_rm_sib
	cdqe
	movzx	eax, BYTE PTR $LN67@set_rm_sib[r8+rax]
	mov	ecx, DWORD PTR $LN68@set_rm_sib[r8+rax*4]
	add	rcx, r8
	jmp	rcx
$LN43@set_rm_sib:

; 666  :         case T_BX:
; 667  :         case T_BP:
; 668  :             if( ( temp = comp_mem16( index, base ) ) == ERROR )

	mov	edx, ebp
	mov	ecx, r15d
	call	comp_mem16
	cmp	eax, -1
	jne	SHORT $LN44@set_rm_sib
$LN71@set_rm_sib:

; 669  :                 return( ERROR );

	or	eax, -1
	jmp	$LN1@set_rm_sib
$LN44@set_rm_sib:

; 670  :             rm_field = temp;

	movzx	edi, al

; 671  :             seg_override( CodeInfo, index, sym, FALSE );

	mov	edx, r15d

; 672  :             break;

	jmp	SHORT $LN70@set_rm_sib
$LN45@set_rm_sib:

; 673  :         case T_SI:
; 674  :         case T_DI:
; 675  :             if( ( temp = comp_mem16( base, index ) ) == ERROR )

	mov	edx, r15d
	mov	ecx, ebp
	call	comp_mem16
	cmp	eax, -1
	je	SHORT $LN71@set_rm_sib

; 676  :                 return( ERROR );
; 677  :             rm_field = temp;

	movzx	edi, al

; 678  :             seg_override( CodeInfo, base, sym, FALSE );
; 679  :             break;

	jmp	SHORT $LN2@set_rm_sib
$LN47@set_rm_sib:

; 680  : #if AMD64_SUPPORT
; 681  :         case T_RSP:
; 682  :         case T_RIP:      //added by habran
; 683  : #endif
; 684  :         case T_ESP:
; 685  :             //EmitErr( CANNOT_BE_USED_AS_INDEX_REGISTER, ??? );
; 686  :             return( EmitError( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	EmitError
	jmp	$LN1@set_rm_sib
$LN69@set_rm_sib:
	movzx	ecx, BYTE PTR bit3_idx$1$[rsp]
$LN48@set_rm_sib:

; 687  :         default:
; 688  :             if( base_reg == 5 ) { /* v2.03: EBP/RBP/R13/R13D? */

	cmp	r10b, 5
	jne	SHORT $LN51@set_rm_sib

; 689  :                 if( mod_field == MOD_00 ) {

	test	sil, sil
	jne	SHORT $LN51@set_rm_sib

; 690  :                     if (base != T_RIP) mod_field = MOD_01;     //ADDED BY HABRAN

	cmp	ebp, 131				; 00000083H
	movzx	esi, sil
	mov	edx, 64					; 00000040H
	cmovne	esi, edx
$LN51@set_rm_sib:

; 696  :             CodeInfo->sib = ( ss | idx_reg << 3 | base_reg );

	shl	r9b, 3

; 697  : #if AMD64_SUPPORT
; 698  :             rex = (bit3_idx << 1) + (bit3_base); /* set REX_X + REX_B */

	movzx	r14d, cl
	or	r9b, r10b
	add	r14b, r14b
	or	r9b, r11b
	mov	BYTE PTR [rbx+105], r9b
	add	r14b, r12b
$LN24@set_rm_sib:

; 691  :                 }
; 692  :             }
; 693  : 
; 694  :             /* s-i-b is present ( r/m = 100b ) */
; 695  :             rm_field |= RM_SIB;

	mov	dil, 4
$LN2@set_rm_sib:

; 699  : #endif
; 700  :             seg_override( CodeInfo, base, sym, FALSE );

	mov	edx, ebp
$LN70@set_rm_sib:
	mov	r8, QWORD PTR sym$[rsp]
	xor	r9d, r9d
	mov	rcx, rbx
	call	seg_override
$LN4@set_rm_sib:

; 701  :         } /* end switch(index) */
; 702  : #if AMD64_SUPPORT
; 703  :         DebugMsg1(("set_rm_sib, indirect, base+index: mod_field=%X, rm_field=%X, rex=%X\n", mod_field, rm_field, rex ));
; 704  : #else
; 705  :         DebugMsg1(("set_rm_sib, indirect, base+index: rm_field=%X\n", rm_field ));
; 706  : #endif
; 707  :     }
; 708  :     if( CurrOpnd == OPND2 ) {

	cmp	r13d, 1
	jne	SHORT $LN52@set_rm_sib

; 709  :         /* shift the register field to left by 3 bit */
; 710  :        if ( base == T_RIP )      //added by habran

	cmp	ebp, 131				; 00000083H
	jne	SHORT $LN54@set_rm_sib

; 711  :           mod_field &= BIT_012;

	and	sil, 7
$LN54@set_rm_sib:

; 712  :           CodeInfo->rm_byte = mod_field | ( rm_field << 3 ) | ( CodeInfo->rm_byte & BIT_012 );

	and	BYTE PTR [rbx+104], 7

; 713  : 
; 714  : #if AMD64_SUPPORT
; 715  :         /* v2.02: exchange B and R, keep X */
; 716  :         //CodeInfo->prefix.rex |= (rex >> 2 );
; 717  :         CodeInfo->prefix.rex |= ( ( rex >> 2 ) | ( rex & REX_X ) | (( rex & 1) << 2 ) );

	movzx	ecx, r14b
	and	cl, 1
	shl	dil, 3
	shl	cl, 2
	movzx	eax, r14b
	shr	al, 2
	or	dil, sil
	or	BYTE PTR [rbx+104], dil
	or	cl, al
	and	r14b, 2
	or	cl, r14b
	or	BYTE PTR [rbx+8], cl
	jmp	SHORT $LN55@set_rm_sib
$LN52@set_rm_sib:

; 718  : #endif
; 719  :     } else if( CurrOpnd == OPND1 ) {

	test	r13d, r13d
	jne	SHORT $LN55@set_rm_sib

; 720  :        if ( base == T_RIP )     //added by habran

	cmp	ebp, 131				; 00000083H
	jne	SHORT $LN56@set_rm_sib

; 721  :           mod_field &= BIT_012;

	and	sil, 7
$LN56@set_rm_sib:

; 722  :         CodeInfo->rm_byte = mod_field | rm_field;

	or	sil, dil

; 723  : #if AMD64_SUPPORT
; 724  :         CodeInfo->prefix.rex |= rex;

	or	BYTE PTR [rbx+8], r14b
	mov	BYTE PTR [rbx+104], sil
$LN55@set_rm_sib:

; 725  : #endif
; 726  :     }
; 727  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@set_rm_sib:

; 728  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
	npad	1
$LN68@set_rm_sib:
	DD	$LN43@set_rm_sib
	DD	$LN45@set_rm_sib
	DD	$LN47@set_rm_sib
	DD	$LN69@set_rm_sib
$LN67@set_rm_sib:
	DB	0
	DB	3
	DB	0
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
set_rm_sib ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
;	COMDAT seg_override
_TEXT	SEGMENT
CodeInfo$ = 48
seg_reg$ = 56
sym$ = 64
direct$ = 72
seg_override PROC					; COMDAT

; 403  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR [rcx+16]
	movzx	ebp, r9b
	mov	rdi, r8
	mov	rbx, rcx
	movzx	r10d, WORD PTR [rax+2]
	sub	r10w, 2
	cmp	r10w, 1
	jbe	$LN5@seg_overri

; 404  :     enum assume_segreg  default_seg;
; 405  :     struct asym         *assume;
; 406  : 
; 407  :     /* don't touch segment overrides for string instructions */
; 408  :     //if ( InstrTable[optable_idx[CodeInfo->token]].allowed_prefix == AP_REP ||
; 409  :     //     InstrTable[optable_idx[CodeInfo->token]].allowed_prefix == AP_REPxx )
; 410  :     if ( CodeInfo->pinstr->allowed_prefix == AP_REP ||
; 411  :          CodeInfo->pinstr->allowed_prefix == AP_REPxx )
; 412  :         return;
; 413  : 
; 414  :     if( CodeInfo->token == T_LEA ) {

	cmp	DWORD PTR [rcx+24], 633			; 00000279H
	jne	SHORT $LN6@seg_overri

; 415  :         CodeInfo->prefix.RegOverride = EMPTY; /* skip segment override */

	mov	DWORD PTR [rcx+4], -2

; 416  :         SetFixupFrame( sym, FALSE );

	xor	edx, edx
	mov	rcx, r8

; 464  :     }
; 465  : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 416  :         SetFixupFrame( sym, FALSE );

	jmp	SetFixupFrame
$LN6@seg_overri:
	mov	QWORD PTR [rsp+48], rsi
	cmp	edx, 14
	je	SHORT $LN7@seg_overri
	lea	eax, DWORD PTR [rdx-21]

; 427  :         break;
; 428  :     default:
; 429  :         default_seg = ASSUME_DS;

	mov	esi, 3
	cmp	eax, 1
	ja	SHORT $LN2@seg_overri
$LN7@seg_overri:

; 417  :         return;
; 418  :     }
; 419  : 
; 420  :     switch( seg_reg ) {
; 421  :     //case T_SS: /* doesn't happen */
; 422  :     case T_BP:
; 423  :     case T_EBP:
; 424  :     case T_ESP:
; 425  :         /* todo: check why cases T_RBP/T_RSP aren't needed! */
; 426  :         default_seg = ASSUME_SS;

	mov	esi, 2
$LN2@seg_overri:

; 430  :     }
; 431  : 
; 432  :     if( CodeInfo->prefix.RegOverride != EMPTY ) {

	mov	ecx, DWORD PTR [rcx+4]
	cmp	ecx, -2
	je	SHORT $LN9@seg_overri

; 433  :         assume = GetOverrideAssume( CodeInfo->prefix.RegOverride );

	call	GetOverrideAssume

; 434  :         /* assume now holds assumed SEG/GRP symbol */
; 435  :         if ( sym ) {

	test	rdi, rdi
	je	SHORT $LN11@seg_overri

; 436  :             DebugMsg1(("seg_override: sym=%s\n", sym->name ));
; 437  :             SetFixupFrame( assume ? assume : sym, FALSE );

	test	rax, rax
	cmovne	rdi, rax
	xor	edx, edx
	mov	rcx, rdi
	call	SetFixupFrame
	jmp	$LN20@seg_overri
$LN11@seg_overri:

; 438  :         } else if ( direct ) {

	test	bpl, bpl
	je	$LN20@seg_overri

; 439  :             /* no label attached (DS:[0]). No fixup is to be created! */
; 440  :             if ( assume ) {

	test	rax, rax
	je	SHORT $LN14@seg_overri

; 441  :                 DebugMsg1(("seg_override, direct addressing: prefix.adrsiz will be set, assume=%s CI->ofssize=%u\n", assume->name, CodeInfo->Ofssize ));
; 442  :                 CodeInfo->prefix.adrsiz = ADDRSIZE( CodeInfo->Ofssize, GetSymOfssize( assume ) );

	mov	rcx, rax

; 443  :                 //DebugMsg1(("seg_override: CI->prefix.adrsiz=%u\n", CodeInfo->prefix.adrsiz ));
; 444  :             } else {

	jmp	SHORT $LN26@seg_overri
$LN14@seg_overri:

; 445  :                 /* v2.01: if -Zm, then use current CS offset size.
; 446  :                  * This isn't how Masm v6 does it, but it matches Masm v5.
; 447  :                  */
; 448  :                 if ( ModuleInfo.m510 )

	test	BYTE PTR ModuleInfo+408, 64		; 00000040H

; 449  :                     CodeInfo->prefix.adrsiz = ADDRSIZE( CodeInfo->Ofssize, ModuleInfo.Ofssize );

	movzx	eax, BYTE PTR [rbx+106]
	je	SHORT $LN16@seg_overri
	xor	al, BYTE PTR ModuleInfo+404
	setne	cl
	xor	cl, BYTE PTR [rbx+9]
	and	cl, 1
	xor	BYTE PTR [rbx+9], cl
	jmp	SHORT $LN20@seg_overri
$LN16@seg_overri:

; 450  :                 else
; 451  :                     CodeInfo->prefix.adrsiz = ADDRSIZE( CodeInfo->Ofssize, ModuleInfo.defOfssize );

	xor	al, BYTE PTR ModuleInfo+405
	setne	cl
	xor	cl, BYTE PTR [rbx+9]
	and	cl, 1
	xor	BYTE PTR [rbx+9], cl

; 452  :             }
; 453  :         }
; 454  :     } else {

	jmp	SHORT $LN20@seg_overri
$LN9@seg_overri:

; 455  :         if ( sym || SegOverride )

	test	r8, r8
	jne	SHORT $LN19@seg_overri
	cmp	QWORD PTR SegOverride, r8
	je	SHORT $LN20@seg_overri
$LN19@seg_overri:

; 456  :             check_assume( CodeInfo, sym, default_seg );

	mov	r8d, esi
	mov	rdx, rdi
	mov	rcx, rbx
	call	check_assume

; 457  :         if ( sym == NULL && SegOverride ) {

	test	rdi, rdi
	jne	SHORT $LN20@seg_overri
	mov	rcx, QWORD PTR SegOverride
	test	rcx, rcx
	je	SHORT $LN20@seg_overri
$LN26@seg_overri:

; 458  :             CodeInfo->prefix.adrsiz = ADDRSIZE( CodeInfo->Ofssize, GetSymOfssize( SegOverride ) );

	call	GetSymOfssize
	and	BYTE PTR [rbx+9], 254			; 000000feH
	movzx	ecx, BYTE PTR [rbx+106]
	xor	ecx, eax
	setne	al
	and	al, 1
	or	BYTE PTR [rbx+9], al
$LN20@seg_overri:

; 459  :         }
; 460  :     }
; 461  : 
; 462  :     if( CodeInfo->prefix.RegOverride == default_seg ) {

	cmp	DWORD PTR [rbx+4], esi
	mov	rsi, QWORD PTR [rsp+48]
	jne	SHORT $LN5@seg_overri

; 463  :         CodeInfo->prefix.RegOverride = EMPTY;

	mov	DWORD PTR [rbx+4], -2
$LN5@seg_overri:

; 464  :     }
; 465  : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
seg_override ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
;	COMDAT check_assume
_TEXT	SEGMENT
CodeInfo$ = 48
assume$ = 56
sym$ = 56
default_reg$ = 64
check_assume PROC					; COMDAT

; 364  : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, r8d
	mov	rbx, rdx
	mov	rsi, rcx

; 365  :     enum assume_segreg     reg;
; 366  :     struct asym            *assume;
; 367  : 
; 368  :     if( sym && sym->state == SYM_UNDEFINED )

	test	rdx, rdx
	je	SHORT $LN2@check_assu
	cmp	DWORD PTR [rdx+32], 0
	je	SHORT $LN9@check_assu
$LN2@check_assu:

; 369  :         return;
; 370  : 
; 371  :     reg = GetAssume( SegOverride, sym, default_reg, &assume );

	mov	rcx, QWORD PTR SegOverride
	lea	r9, QWORD PTR assume$[rsp]
	mov	QWORD PTR [rsp+48], rbp
	call	GetAssume

; 372  :     /* set global vars Frame and Frame_Datum */
; 373  :     DebugMsg1(("check_assume(%s): calling SetFixupFrame(%s, FALSE)\n", sym ? sym->name : "NULL", assume ? assume->name : "NULL" ));
; 374  :     SetFixupFrame( assume, FALSE );

	mov	rcx, QWORD PTR assume$[rsp]
	xor	edx, edx
	mov	ebp, eax
	call	SetFixupFrame

; 375  : 
; 376  :     if( reg == ASSUME_NOTHING ) {

	cmp	ebp, -2
	jne	SHORT $LN3@check_assu

; 377  :         if ( sym ) {

	test	rbx, rbx
	je	SHORT $LN5@check_assu

; 378  :             //if( sym->state != SYM_EXTERNAL && sym->state != SYM_STACK ) {
; 379  :             /* v1.95: condition changed. Now there's an error msg only if
; 380  :              * the symbol has an explicite segment.
; 381  :              */
; 382  :             if( sym->segment != NULL ) {

	cmp	QWORD PTR [rbx+24], 0
	je	SHORT $LN7@check_assu

; 383  :                 DebugMsg1(("check_assume: no segment register available to access label %s\n", sym->name ));
; 384  :                 EmitErr( CANNOT_ACCESS_LABEL_THROUGH_SEGMENT_REGISTERS, sym->name );

	mov	rdx, QWORD PTR [rbx+8]
	lea	ecx, QWORD PTR [rbp+91]
	call	EmitErr

; 385  :             } else

	jmp	SHORT $LN11@check_assu
$LN7@check_assu:

; 386  :                 CodeInfo->prefix.RegOverride = default_reg;

	mov	DWORD PTR [rsi+4], edi

; 387  :         } else {

	jmp	SHORT $LN11@check_assu
$LN5@check_assu:

; 388  :             DebugMsg1(("check_assume: no segment register available to access seg-label %s\n", SegOverride->name ));
; 389  :             EmitErr( CANNOT_ACCESS_LABEL_THROUGH_SEGMENT_REGISTERS, SegOverride->name );

	mov	rdx, QWORD PTR SegOverride
	mov	ecx, 89					; 00000059H
	mov	rdx, QWORD PTR [rdx+8]
	call	EmitErr

; 390  :         }

	jmp	SHORT $LN11@check_assu
$LN3@check_assu:

; 391  :     } else if( default_reg != EMPTY ) {

	cmp	edi, -2
	je	SHORT $LN11@check_assu

; 392  :         CodeInfo->prefix.RegOverride = reg;

	mov	DWORD PTR [rsi+4], ebp
$LN11@check_assu:
	mov	rbp, QWORD PTR [rsp+48]
$LN9@check_assu:

; 393  :     }
; 394  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
check_assume ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
;	COMDAT comp_mem16
_TEXT	SEGMENT
reg1$ = 8
reg2$ = 16
comp_mem16 PROC						; COMDAT

; 338  :     switch( reg1 ) {

	cmp	ecx, 12
	je	SHORT $LN8@comp_mem16
	cmp	ecx, 14
	je	SHORT $LN11@comp_mem16

; 349  :         }
; 350  :         break;
; 351  :     default:
; 352  :         return( EmitError( MULTIPLE_INDEX_REGISTERS_NOT_ALLOWED ) );

	mov	ecx, 34					; 00000022H
	jmp	EmitError
$LN11@comp_mem16:

; 343  :         }
; 344  :         break;
; 345  :     case T_BP:
; 346  :         switch( reg2 ) {

	sub	edx, 15
	je	SHORT $LN12@comp_mem16
	cmp	edx, 1
	jne	SHORT $LN4@comp_mem16

; 348  :         case T_DI: return( RM_BP_DI ); /* 03 */

	lea	eax, QWORD PTR [rdx+2]

; 355  : }

	ret	0
$LN12@comp_mem16:

; 347  :         case T_SI: return( RM_BP_SI ); /* 02 */

	mov	eax, 2

; 355  : }

	ret	0
$LN8@comp_mem16:

; 339  :     case T_BX:
; 340  :         switch( reg2 ) {

	sub	edx, 15
	je	SHORT $LN9@comp_mem16
	cmp	edx, 1
	je	SHORT $LN10@comp_mem16
$LN4@comp_mem16:

; 353  :     }
; 354  :     return( EmitError( MULTIPLE_BASE_REGISTERS_NOT_ALLOWED ) );

	mov	ecx, 29
	jmp	EmitError
$LN10@comp_mem16:

; 342  :         case T_DI: return( RM_BX_DI ); /* 01 */

	mov	eax, 1

; 355  : }

	ret	0
$LN9@comp_mem16:

; 341  :         case T_SI: return( RM_BX_SI ); /* 00 */

	xor	eax, eax

; 355  : }

	ret	0
comp_mem16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
tokenarray$ = 48
ProcessFile PROC

; 3536 : {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H

; 3537 :     while ( ModuleInfo.EndDirFound == FALSE && GetTextLine( CurrSource ) ) {

	test	BYTE PTR ModuleInfo+410, 1
	mov	rbx, rcx
	jne	SHORT $LN10@ProcessFil
$LL2@ProcessFil:
	mov	rcx, QWORD PTR ModuleInfo+464
	call	GetTextLine
	test	rax, rax
	je	SHORT $LN10@ProcessFil

; 3538 :         if ( PreprocessLine( CurrSource, tokenarray ) ) {

	mov	rcx, QWORD PTR ModuleInfo+464
	mov	rdx, rbx
	call	PreprocessLine
	test	eax, eax
	je	SHORT $LN5@ProcessFil

; 3539 :             ParseLine( tokenarray );

	mov	rcx, rbx
	call	ParseLine

; 3540 :             if ( Options.preprocessor_stdout == TRUE && Parse_Pass == PASS_1 )

	cmp	BYTE PTR Options+125, 1
	jne	SHORT $LN5@ProcessFil
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN5@ProcessFil

; 3541 :                 WritePreprocessedLine( CurrSource );

	mov	rcx, QWORD PTR ModuleInfo+464
	call	WritePreprocessedLine
$LN5@ProcessFil:

; 3537 :     while ( ModuleInfo.EndDirFound == FALSE && GetTextLine( CurrSource ) ) {

	test	BYTE PTR ModuleInfo+410, 1
	je	SHORT $LL2@ProcessFil
$LN10@ProcessFil:

; 3542 :         }
; 3543 :     }
; 3544 :     return;
; 3545 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ProcessFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
CodeInfo$ = 48
opndx$ = 192
oldofs$ = 688
i$ = 688
tokenarray$ = 688
oldofs$1$ = 696
tv2630 = 704
tv2245 = 704
tv2258 = 712
ParseLine PROC

; 2875 : {

$LN331:
	push	rbp
	push	rbx
	push	rsi
	push	r14
	lea	rbp, QWORD PTR [rsp-392]
	sub	rsp, 648				; 00000288H

; 2876 :   int                 i;
; 2877 :   int                 j;
; 2878 :   unsigned            dirflags;
; 2879 :   unsigned            CurrOpnd;
; 2880 :   ret_code            temp;
; 2881 :   struct asym         *sym;
; 2882 :   uint_32             oldofs;
; 2883 :   enum special_token regtok;
; 2884 : #ifdef DEBUG_OUT
; 2885 :   char                *instr;
; 2886 : #endif
; 2887 :   struct code_info    CodeInfo;
; 2888 : #if AVXSUPP
; 2889 :   struct expr         opndx[MAX_OPND + 1];
; 2890 : #else
; 2891 :   struct expr         opndx[MAX_OPND];
; 2892 : #endif
; 2893 : 
; 2894 :   DebugMsg1(("ParseLine enter, Token_Count=%u, ofs=%Xh\n",
; 2895 :     Token_Count, GetCurrOffset()));
; 2896 :   i = 0;

	xor	ebx, ebx
	mov	rsi, rcx

; 2897 :   /* Does line start with a code label? */
; 2898 :   if (tokenarray[0].token == T_ID && (tokenarray[1].token == T_COLON || tokenarray[1].token == T_DBL_COLON)) {

	cmp	BYTE PTR [rcx], 8
	mov	r9d, ebx
	mov	DWORD PTR i$[rbp-256], ebx
	lea	r14d, QWORD PTR [rbx+1]
	jne	$LN39@ParseLine
	movzx	eax, BYTE PTR [rcx+32]
	cmp	al, 58					; 0000003aH
	je	SHORT $LN36@ParseLine
	cmp	al, 13
	jne	$LN39@ParseLine
$LN36@ParseLine:

; 2899 :     i = 2;
; 2900 :     DebugMsg1(("ParseLine T_COLON, code label=%s\n", tokenarray[0].string_ptr));
; 2901 :     if (ProcStatus & PRST_PROLOGUE_NOT_DONE) write_prologue(tokenarray);

	test	BYTE PTR ProcStatus, -128		; ffffffffffffff80H
	mov	DWORD PTR i$[rbp-256], 2
	je	SHORT $LN37@ParseLine
	call	write_prologue
$LN37@ParseLine:

; 2902 : 
; 2903 :     /* create a global or local code label */
; 2904 :     if (CreateLabel(tokenarray[0].string_ptr, MT_NEAR, NULL,
; 2905 :       (ModuleInfo.scoped && CurrProc && tokenarray[1].token != T_DBL_COLON)) == NULL) {

	test	BYTE PTR ModuleInfo+408, 128		; 00000080H
	je	SHORT $LN206@ParseLine
	cmp	QWORD PTR CurrProc, rbx
	je	SHORT $LN206@ParseLine
	cmp	BYTE PTR [rsi+32], 13
	mov	eax, r14d
	jne	SHORT $LN207@ParseLine
$LN206@ParseLine:
	mov	eax, ebx
$LN207@ParseLine:
	mov	rcx, QWORD PTR [rsi+8]
	movzx	r9d, al
	xor	r8d, r8d
	mov	edx, 129				; 00000081H
	call	CreateLabel
	test	rax, rax
	jne	SHORT $LN38@ParseLine

; 2906 :       DebugMsg(("ParseLine, CreateLabel(%s) failed, exit\n", tokenarray[0].string_ptr));
; 2907 :       return(ERROR);

	or	eax, -1

; 3529 :   return( temp );
; 3530 : }

	add	rsp, 648				; 00000288H
	pop	r14
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN38@ParseLine:

; 2908 :     }
; 2909 :     if (tokenarray[i].token == T_FINAL) {

	movsxd	r9, DWORD PTR i$[rbp-256]
	mov	rax, r9
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], bl
	jne	SHORT $LN39@ParseLine

; 2910 :       /* v2.06: this is a bit too late. Should be done BEFORE
; 2911 :        * CreateLabel, because of '@@'. There's a flag supposed to
; 2912 :        * be used for this handling, LOF_STORED in line_flags.
; 2913 :        * It's only a problem if a '@@:' is the first line
; 2914 :        * in the code section.
; 2915 :        * v2.10: is no longer an issue because the label counter has
; 2916 :        * been moved to module_vars (see global.h).
; 2917 :        */
; 2918 :       FStoreLine(0);

	cmp	DWORD PTR Parse_Pass, ebx
	jne	SHORT $LN40@ParseLine
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
$LN40@ParseLine:

; 2919 :       if (CurrFile[LST]) {

	cmp	QWORD PTR ModuleInfo+112, rbx
	je	SHORT $LN42@ParseLine

; 2920 :         LstWrite(LSTTYPE_LABEL, 0, NULL);

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+7]
	call	LstWrite
$LN42@ParseLine:

; 2921 :       }
; 2922 :       return(NOT_ERROR);

	xor	eax, eax

; 3529 :   return( temp );
; 3530 : }

	add	rsp, 648				; 00000288H
	pop	r14
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN39@ParseLine:

; 2923 :     }
; 2924 :   }
; 2925 :   /* handle directives and (anonymous) data items */
; 2926 :   if (tokenarray[i].token != T_INSTRUCTION) {

	movsxd	rax, r9d
	shl	rax, 5
	mov	QWORD PTR [rsp+640], rdi
	cmp	BYTE PTR [rax+rsi], r14b
	je	$LN43@ParseLine

; 2927 :     /* a code label before a data item is only accepted in Masm5 compat mode */
; 2928 :     Frame_Type = FRAME_NONE;

	mov	BYTE PTR Frame_Type, 6

; 2929 :     SegOverride = NULL;

	mov	QWORD PTR SegOverride, rbx

; 2930 :     if (i == 0 && tokenarray[0].token == T_ID) {

	test	r9d, r9d
	jne	SHORT $LN295@ParseLine
	cmp	BYTE PTR [rsi], 8
	jne	SHORT $LN295@ParseLine

; 2931 :       /* token at pos 0 may be a label.
; 2932 :        * it IS a label if:
; 2933 :        * 1. token at pos 1 is a directive (lbl dd ...)
; 2934 :        * 2. token at pos 0 is NOT a userdef type ( lbl DWORD ...)
; 2935 :        * 3. inside a struct and token at pos 1 is a userdef type
; 2936 :        *    or a predefined type. (usertype DWORD|usertype ... )
; 2937 :        *    the separate namespace allows this syntax here.
; 2938 :        */
; 2939 :       if (tokenarray[1].token == T_DIRECTIVE)

	cmp	BYTE PTR [rsi+32], 3
	jne	SHORT $LN45@ParseLine

; 2940 :         i++;

	mov	r9d, r14d
	mov	DWORD PTR i$[rbp-256], r14d
	jmp	SHORT $LN295@ParseLine
$LN45@ParseLine:

; 2941 :       else {
; 2942 :         sym = IsType(tokenarray[0].string_ptr);

	mov	rcx, QWORD PTR [rsi+8]
	call	SymFind
	test	rax, rax
	je	SHORT $LN277@ParseLine
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN277@ParseLine

; 2945 :         else if (CurrStruct &&

	cmp	QWORD PTR CurrStruct, rbx
	je	SHORT $LN294@ParseLine
	movzx	eax, BYTE PTR [rsi+32]
	cmp	al, 6
	je	SHORT $LN277@ParseLine
	cmp	al, 8
	jne	SHORT $LN294@ParseLine
	mov	rcx, QWORD PTR [rsi+40]
	call	SymFind
	test	rax, rax
	je	SHORT $LN294@ParseLine
	cmp	DWORD PTR [rax+32], 7
	je	SHORT $LN277@ParseLine
$LN294@ParseLine:

; 2943 :         if (sym == NULL)
; 2944 :           i++;

	mov	r9d, DWORD PTR i$[rbp-256]
	jmp	SHORT $LN295@ParseLine
$LN277@ParseLine:
	mov	r9d, DWORD PTR i$[rbp-256]
	inc	r9d
	mov	DWORD PTR i$[rbp-256], r9d
$LN295@ParseLine:

; 2946 :           ((tokenarray[1].token == T_STYPE) ||
; 2947 :           (tokenarray[1].token == T_ID && (IsType(tokenarray[1].string_ptr)))))
; 2948 :           i++;
; 2949 :       }
; 2950 :     }
; 2951 :     switch (tokenarray[i].token) {

	movsxd	rax, r9d
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+rsi]
	lea	rdx, QWORD PTR [rax+rsi]
	movzx	eax, cl
	cmp	cl, 3
	je	$LN51@ParseLine
	cmp	al, 6
	je	$LN74@ParseLine
	cmp	al, 8
	je	SHORT $LN75@ParseLine

; 3027 :       }
; 3028 :       break;
; 3029 :     default:
; 3030 :       if (tokenarray[i].token == T_COLON) {

	cmp	cl, 58					; 0000003aH
	jne	SHORT $LN76@ParseLine

; 3031 :         DebugMsg(("ParseLine: unexpected colon\n"));
; 3032 :         return(EmitError(SYNTAX_ERROR_UNEXPECTED_COLON));

	mov	ecx, 47					; 0000002fH
	call	EmitError
	jmp	$LN315@ParseLine
$LN75@ParseLine:

; 3020 :     case T_STYPE:
; 3021 :       DebugMsg1(("ParseLine: T_STYPE >%s<\n", tokenarray[i].string_ptr));
; 3022 :       return(data_dir(i, tokenarray, NULL));
; 3023 :     case T_ID:
; 3024 :       DebugMsg1(("ParseLine: T_ID >%s<\n", tokenarray[i].string_ptr));
; 3025 :       if (sym = IsType(tokenarray[i].string_ptr)) {

	mov	rcx, QWORD PTR [rdx+8]
	call	SymFind
	test	rax, rax
	je	SHORT $LN297@ParseLine
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN297@ParseLine

; 3026 :         return(data_dir(i, tokenarray, sym));

	mov	ecx, DWORD PTR i$[rbp-256]
	mov	r8, rax
	mov	rdx, rsi
	call	data_dir
	jmp	$LN315@ParseLine
$LN297@ParseLine:
	mov	r9d, DWORD PTR i$[rbp-256]
$LN76@ParseLine:

; 3033 :       }
; 3034 :       break;
; 3035 :     } /* end switch (tokenarray[i].token) */
; 3036 :     if (i && tokenarray[i - 1].token == T_ID)

	test	r9d, r9d
	je	SHORT $LN79@ParseLine
	movsxd	rax, r9d
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi-32], 8
	jne	SHORT $LN79@ParseLine

; 3037 :       i--;

	dec	r9d
	mov	DWORD PTR i$[rbp-256], r9d
$LN79@ParseLine:

; 3038 :     DebugMsg(("ParseLine: unexpected token=%u, i=%u, string=%s\n", tokenarray[i].token, i, tokenarray[i].string_ptr));
; 3039 :     return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr));

	movsxd	rdx, r9d
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+8]
	call	EmitErr
	jmp	$LN315@ParseLine
$LN51@ParseLine:

; 2952 :     case T_DIRECTIVE:
; 2953 :       DebugMsg1(("ParseLine: T_DIRECTIVE >%s<\n", tokenarray[i].string_ptr));
; 2954 :       if (tokenarray[i].dirtype == DRT_DATADIR) {

	cmp	BYTE PTR [rdx+1], 8
	jne	SHORT $LN52@ParseLine
$LN74@ParseLine:

; 2955 :         return(data_dir(i, tokenarray, NULL));

	xor	r8d, r8d
	mov	rdx, rsi
	mov	ecx, r9d
	call	data_dir
	jmp	$LN315@ParseLine
$LN52@ParseLine:

; 2956 :       }
; 2957 :       dirflags = GetValueSp(tokenarray[i].tokval);
; 2958 :       if (CurrStruct && (dirflags & DF_NOSTRUC)) {

	cmp	QWORD PTR CurrStruct, 0
	lea	rdi, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR [rdx+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	ebx, DWORD PTR SpecialTable[rdi+rcx*4]
	je	SHORT $LN53@ParseLine
	test	bl, 16
	jne	$LN328@ParseLine
$LN53@ParseLine:

; 2959 :         return(EmitError(STATEMENT_NOT_ALLOWED_INSIDE_STRUCTURE_DEFINITION));
; 2960 :       }
; 2961 :       /* label allowed for directive? */
; 2962 :       //if ( tokenarray[i].flags & DF_LABEL ) {
; 2963 :       if (dirflags & DF_LABEL) {

	test	bl, 8
	je	SHORT $LN54@ParseLine

; 2964 :         if (i && tokenarray[0].token != T_ID) {

	test	r9d, r9d
	je	SHORT $LN57@ParseLine
	cmp	BYTE PTR [rsi], 8
	je	SHORT $LN57@ParseLine

; 2965 :           return(EmitErr(SYNTAX_ERROR_EX, tokenarray[0].string_ptr));

	mov	rdx, QWORD PTR [rsi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN315@ParseLine
$LN54@ParseLine:

; 2966 :         }
; 2967 :       }
; 2968 :       else if (i && tokenarray[i - 1].token != T_COLON && tokenarray[i - 1].token != T_DBL_COLON) {

	test	r9d, r9d
	je	SHORT $LN57@ParseLine
	movzx	eax, BYTE PTR [rdx-32]
	cmp	al, 58					; 0000003aH
	je	SHORT $LN57@ParseLine
	cmp	al, 13
	je	SHORT $LN57@ParseLine

; 2969 :         return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i - 1].string_ptr));

	mov	rdx, QWORD PTR [rdx-24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN315@ParseLine
$LN57@ParseLine:

; 2970 :       }
; 2971 :       /* must be done BEFORE FStoreLine()! */
; 2972 :       if ((ProcStatus & PRST_PROLOGUE_NOT_DONE) && (dirflags & DF_PROC)) write_prologue(tokenarray);

	test	BYTE PTR ProcStatus, -128		; ffffffffffffff80H
	je	SHORT $LN58@ParseLine
	test	bl, 64					; 00000040H
	je	SHORT $LN58@ParseLine
	mov	rcx, rsi
	call	write_prologue
	mov	r9d, DWORD PTR i$[rbp-256]
$LN58@ParseLine:

; 2973 : #if FASTPASS
; 2974 :       if (StoreState || (dirflags & DF_STORE)) {

	cmp	BYTE PTR StoreState, 0
	jne	SHORT $LN60@ParseLine
	test	bl, bl
	jns	SHORT $LN65@ParseLine
$LN60@ParseLine:

; 2975 :         /* v2.07: the comment must be stored as well
; 2976 :          * if a listing (with -Sg) is to be written and
; 2977 :          * the directive will generate lines
; 2978 :          */
; 2979 :         if ((dirflags & DF_CGEN) && ModuleInfo.CurrComment && ModuleInfo.list_generated_code) {

	bt	ebx, 8
	jae	SHORT $LN61@ParseLine
	cmp	QWORD PTR ModuleInfo+472, 0
	je	SHORT $LN61@ParseLine
	test	DWORD PTR ModuleInfo+408, 16384		; 00004000H
	je	SHORT $LN61@ParseLine

; 2980 :           FStoreLine(1);

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN65@ParseLine
	mov	edx, r14d

; 2981 :         }

	jmp	SHORT $LN319@ParseLine
$LN61@ParseLine:

; 2982 :         else
; 2983 :           FStoreLine(0);

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN65@ParseLine
	xor	edx, edx
$LN319@ParseLine:
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	call	StoreLine
	mov	r9d, DWORD PTR i$[rbp-256]
$LN65@ParseLine:

; 2984 :       }
; 2985 : #endif
; 2986 :       if (tokenarray[i].dirtype > DRT_DATADIR) {

	movsxd	rax, r9d
	shl	rax, 5
	lea	rdx, QWORD PTR [rax+rsi]
	movzx	eax, BYTE PTR [rax+rsi+1]
	cmp	al, 8
	jbe	SHORT $LN67@ParseLine

; 2987 :         temp = directive_tab[tokenarray[i].dirtype](i, tokenarray);

	movzx	eax, al
	mov	rdx, rsi
	mov	ecx, r9d
	call	QWORD PTR directive_tab[rdi+rax*8]
	mov	ebx, eax

; 2988 :       }

	jmp	SHORT $LN4@ParseLine
$LN67@ParseLine:

; 2989 :       else {
; 2990 :         temp = ERROR;
; 2991 :         /* ENDM, EXITM and GOTO directives should never be seen here */
; 2992 :         switch (tokenarray[i].tokval) {

	mov	ecx, DWORD PTR [rdx+16]
	or	ebx, -1
	sub	ecx, 397				; 0000018dH
	je	SHORT $LN70@ParseLine
	sub	ecx, r14d
	je	SHORT $LN69@ParseLine
	cmp	ecx, r14d
	je	SHORT $LN70@ParseLine

; 2999 :           break;
; 3000 :         default:
; 3001 :           /* this error may happen if
; 3002 :            * CATSTR, SUBSTR, MACRO, ...
; 3003 :            * aren't at pos 1
; 3004 :            */
; 3005 :           EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr);

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN4@ParseLine
$LN69@ParseLine:

; 2993 :         case T_ENDM:
; 2994 :           EmitError(UNMATCHED_MACRO_NESTING);

	mov	ecx, 162				; 000000a2H

; 2995 :           break;

	jmp	SHORT $LN320@ParseLine
$LN70@ParseLine:

; 2996 :         case T_EXITM:
; 2997 :         case T_GOTO:
; 2998 :           EmitError(DIRECTIVE_MUST_APPEAR_INSIDE_A_MACRO);

	mov	ecx, 178				; 000000b2H
$LN320@ParseLine:
	call	EmitError
$LN4@ParseLine:

; 3006 :           break;
; 3007 :         }
; 3008 :       }
; 3009 :       /* v2.0: for generated code it's important that list file is
; 3010 :        * written in ALL passes, to update file position! */
; 3011 :       //if ( ModuleInfo.list && (( line_flags & LOF_LISTED ) == 0 ) && Parse_Pass == PASS_1 )
; 3012 : #if FASTPASS
; 3013 :       /* v2.08: UseSavedState == FALSE added */
; 3014 :       if (ModuleInfo.list && (Parse_Pass == PASS_1 || ModuleInfo.GeneratedCode || UseSavedState == FALSE))

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN72@ParseLine
	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN73@ParseLine
	cmp	DWORD PTR ModuleInfo+456, 0
	jne	SHORT $LN73@ParseLine
	cmp	BYTE PTR UseSavedState, 0
	jne	SHORT $LN72@ParseLine
$LN73@ParseLine:

; 3015 : #else
; 3016 :       if ( ModuleInfo.list )
; 3017 : #endif
; 3018 :         LstWriteSrcLine();

	call	LstWriteSrcLine
$LN72@ParseLine:

; 3019 :       return(temp);

	mov	eax, ebx
	jmp	$LN315@ParseLine
$LN43@ParseLine:

; 3040 :   }
; 3041 : 
; 3042 :   DebugMsg1(("ParseLine: %s\n", tokenarray[i].string_ptr));
; 3043 :   /* v2.04 added */
; 3044 :   if (CurrStruct) {

	cmp	QWORD PTR CurrStruct, rbx
	je	SHORT $LN80@ParseLine
$LN328@ParseLine:

; 3045 :     return(EmitError(STATEMENT_NOT_ALLOWED_INSIDE_STRUCTURE_DEFINITION));

	mov	ecx, 141				; 0000008dH
	call	EmitError
	jmp	$LN315@ParseLine
$LN80@ParseLine:

; 3046 :   }
; 3047 : 
; 3048 :   if (ProcStatus & PRST_PROLOGUE_NOT_DONE) write_prologue(tokenarray);

	test	BYTE PTR ProcStatus, -128		; ffffffffffffff80H
	je	SHORT $LN81@ParseLine
	mov	rcx, rsi
	call	write_prologue
	mov	r9d, DWORD PTR i$[rbp-256]
$LN81@ParseLine:

; 3049 : 
; 3050 :   /* v2.07: moved because special handling is needed for RET/IRET */
; 3051 :   //FStoreLine(); /* must be placed AFTER write_prologue() */
; 3052 : 
; 3053 :   if (CurrFile[LST]) oldofs = GetCurrOffset();

	cmp	QWORD PTR ModuleInfo+112, rbx
	je	SHORT $LN298@ParseLine
	call	GetCurrOffset
	mov	r9d, DWORD PTR i$[rbp-256]
	jmp	SHORT $LN321@ParseLine
$LN298@ParseLine:
	mov	eax, DWORD PTR oldofs$[rbp-256]
$LN321@ParseLine:

; 3054 : 
; 3055 :   /* init CodeInfo */
; 3056 :   CodeInfo.prefix.ins = EMPTY;
; 3057 :   CodeInfo.prefix.RegOverride = EMPTY;
; 3058 : #if AMD64_SUPPORT
; 3059 :   CodeInfo.prefix.rex = 0;
; 3060 : #endif
; 3061 :   CodeInfo.prefix.adrsiz = FALSE;
; 3062 :   CodeInfo.prefix.opsiz = FALSE;

	and	BYTE PTR CodeInfo$[rsp+9], 252		; 000000fcH
	mov	DWORD PTR oldofs$1$[rbp-256], eax

; 3063 :   CodeInfo.mem_type = MT_EMPTY;
; 3064 :   for (j = 0; j < MAX_OPND; j++) {
; 3065 :     CodeInfo.opnd[j].type = OP_NONE;
; 3066 : #ifdef DEBUG_OUT
; 3067 :     CodeInfo.opnd[j].data32l = -1;
; 3068 :     /* make sure it's invalid */
; 3069 :     CodeInfo.opnd[j].InsFixup = (void *)0xffffffff;
; 3070 : #endif
; 3071 :   }
; 3072 :   CodeInfo.rm_byte = 0;
; 3073 :   CodeInfo.sib = 0;            /* assume ss is *1 */
; 3074 :   CodeInfo.Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	BYTE PTR CodeInfo$[rbp-150], al
	mov	eax, DWORD PTR [rsi+16]
	sub	eax, 1686				; 00000696H
	mov	DWORD PTR CodeInfo$[rsp], -2
	mov	DWORD PTR CodeInfo$[rsp+4], -2
	mov	BYTE PTR CodeInfo$[rsp+8], bl
	mov	QWORD PTR CodeInfo$[rsp+28], 192	; 000000c0H
	mov	DWORD PTR CodeInfo$[rsp+56], ebx
	mov	DWORD PTR CodeInfo$[rbp-176], ebx
	mov	WORD PTR CodeInfo$[rbp-152], bx

; 3075 :   CodeInfo.opc_or = 0;

	mov	WORD PTR CodeInfo$[rbp-149], bx

; 3076 :   CodeInfo.basetype = 0;
; 3077 : #if AVXSUPP
; 3078 :   CodeInfo.evex_sae = 0;
; 3079 :   CodeInfo.vexregop = 0;
; 3080 :   CodeInfo.tuple = 0;

	mov	WORD PTR CodeInfo$[rbp-116], bx
	mov	BYTE PTR CodeInfo$[rbp-128], bl

; 3081 :   CodeInfo.vexconst = 0;

	mov	DWORD PTR CodeInfo$[rbp-132], ebx

; 3082 :   CodeInfo.evex_flag = FALSE;  /* if TRUE will output 0x62 */

	mov	BYTE PTR CodeInfo$[rbp-120], bl

; 3083 :   CodeInfo.reg3 = 0xff;          /* if not reg3 make it negative  */

	mov	WORD PTR CodeInfo$[rbp-145], 65535	; 0000ffffH

; 3084 :   CodeInfo.basereg = 0xff;

	mov	BYTE PTR CodeInfo$[rbp-143], 255	; 000000ffH
	cmp	eax, 46					; 0000002eH
	ja	SHORT $LN83@ParseLine

; 3085 :   CodeInfo.indexreg = 0xff;
; 3086 :   if (tokenarray[0].tokval >= T_KADDB && tokenarray[0].tokval <= T_KMOVW){
; 3087 :     CodeInfo.evex_flag = FALSE;

	mov	BYTE PTR CodeInfo$[rbp-120], bl

; 3088 :   }

	jmp	SHORT $LN85@ParseLine
$LN83@ParseLine:

; 3089 :   else{
; 3090 :     //Init EVEX three bytes
; 3091 :     CodeInfo.evex_p0 = 0;      /* P0[3 : 2] Must be 0 */
; 3092 :     CodeInfo.evex_p1 = 0x4;    /* P1[2]    Must be 1  */
; 3093 :     CodeInfo.evex_p2 = 0;
; 3094 :     if (broadflags || decoflags)

	cmp	BYTE PTR broadflags, bl
	mov	WORD PTR CodeInfo$[rbp-119], 1024	; 00000400H
	mov	BYTE PTR CodeInfo$[rbp-117], bl
	jne	SHORT $LN86@ParseLine
	cmp	BYTE PTR decoflags, bl
	je	SHORT $LN85@ParseLine
$LN86@ParseLine:

; 3095 :       CodeInfo.evex_flag = TRUE;   /* if TRUE will output 0x62 */

	mov	BYTE PTR CodeInfo$[rbp-120], r14b
$LN85@ParseLine:

; 3096 :   }
; 3097 : #endif
; 3098 :   CodeInfo.flags = 0;
; 3099 : 
; 3100 :   /* instruction prefix?
; 3101 :    * T_LOCK, T_REP, T_REPE, T_REPNE, T_REPNZ, T_REPZ */
; 3102 :   if (tokenarray[i].tokval >= T_LOCK && tokenarray[i].tokval <= T_REPZ) {

	movsxd	rcx, r9d
	shl	rcx, 5
	add	rcx, rsi
	mov	BYTE PTR CodeInfo$[rbp-114], bl
	mov	edx, DWORD PTR [rcx+16]
	lea	eax, DWORD PTR [rdx-581]
	cmp	eax, 5
	ja	SHORT $LN88@ParseLine

; 3103 :     CodeInfo.prefix.ins = tokenarray[i].tokval;
; 3104 :     i++;

	inc	r9d
	mov	DWORD PTR CodeInfo$[rsp], edx

; 3105 :     /* prefix has to be followed by an instruction */
; 3106 :     if (tokenarray[i].token != T_INSTRUCTION) {

	movsxd	rcx, r9d
	shl	rcx, 5
	add	rcx, rsi
	mov	DWORD PTR i$[rbp-256], r9d
	cmp	BYTE PTR [rcx], r14b
	je	SHORT $LN88@ParseLine

; 3107 :       DebugMsg(("ParseLine: unexpected token %u after prefix, exit, error\n", tokenarray[i].token));
; 3108 :       return(EmitError(PREFIX_MUST_BE_FOLLOWED_BY_AN_INSTRUCTION));

	mov	ecx, 46					; 0000002eH
	call	EmitError
	jmp	$LN315@ParseLine
$LN88@ParseLine:

; 3109 :     }
; 3110 :     DebugMsg1(("ParseLine: %s\n", tokenarray[i].tokpos));
; 3111 :   };
; 3112 : 
; 3113 :   if (CurrProc) {

	mov	r8, QWORD PTR CurrProc
	test	r8, r8
	je	$LN94@ParseLine

; 3114 :     switch (tokenarray[i].tokval) {

	mov	edx, DWORD PTR [rcx+16]
	lea	eax, DWORD PTR [rdx-626]
	cmp	eax, r14d
	jbe	SHORT $LN90@ParseLine
	cmp	edx, 648				; 00000288H
	je	SHORT $LN90@ParseLine
	cmp	edx, 1207				; 000004b7H
	jne	$LN94@ParseLine
$LN90@ParseLine:

; 3115 :     case T_RET:
; 3116 :     case T_IRET:  /* IRET is always 16-bit; OTOH, IRETW doesn't exist */
; 3117 :     case T_IRETD:
; 3118 : #if AMD64_SUPPORT
; 3119 :     case T_IRETQ:
; 3120 : #endif
; 3121 :       if (!(ProcStatus & PRST_INSIDE_EPILOGUE) && ModuleInfo.epiloguemode != PEM_NONE) {

	test	BYTE PTR ProcStatus, 2
	jne	SHORT $LN91@ParseLine
	cmp	BYTE PTR ModuleInfo+425, 2
	je	SHORT $LN91@ParseLine

; 3122 :         /* v2.07: special handling for RET/IRET */
; 3123 :         FStoreLine((ModuleInfo.CurrComment && ModuleInfo.list_generated_code) ? 1 : 0);

	cmp	DWORD PTR Parse_Pass, ebx
	jne	SHORT $LN92@ParseLine
	cmp	QWORD PTR ModuleInfo+472, rbx
	je	SHORT $LN208@ParseLine
	test	DWORD PTR ModuleInfo+408, 16384		; 00004000H
	jne	SHORT $LN209@ParseLine
$LN208@ParseLine:
	mov	r14d, ebx
$LN209@ParseLine:
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	mov	edx, r14d
	call	StoreLine
	mov	r9d, DWORD PTR i$[rbp-256]
$LN92@ParseLine:

; 3124 :         ProcStatus |= PRST_INSIDE_EPILOGUE;
; 3125 :         temp = RetInstr(i, tokenarray, Token_Count);

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, rsi
	or	DWORD PTR ProcStatus, 2
	mov	ecx, r9d
	call	RetInstr

; 3126 :         ProcStatus &= ~PRST_INSIDE_EPILOGUE;

	and	DWORD PTR ProcStatus, -3

; 3127 :         return(temp);

	jmp	$LN315@ParseLine
$LN91@ParseLine:

; 3128 :       }
; 3129 :       /* default translation: just RET to RETF if proc is far */
; 3130 :       /* v2.08: this code must run even if PRST_INSIDE_EPILOGUE is set */
; 3131 :       if (tokenarray[i].tokval == T_RET && CurrProc->sym.mem_type == MT_FAR)

	cmp	edx, 648				; 00000288H
	jne	SHORT $LN94@ParseLine
	cmp	DWORD PTR [r8+36], 130			; 00000082H
	jne	SHORT $LN94@ParseLine

; 3132 :         tokenarray[i].tokval = T_RETF;

	mov	DWORD PTR [rcx+16], 650			; 0000028aH
	mov	r9d, DWORD PTR i$[rbp-256]
$LN94@ParseLine:

; 3133 :     }
; 3134 :   }
; 3135 : 
; 3136 :   FStoreLine(0); /* must be placed AFTER write_prologue() */

	cmp	DWORD PTR Parse_Pass, ebx
	jne	SHORT $LN95@ParseLine
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
	mov	r9d, DWORD PTR i$[rbp-256]
$LN95@ParseLine:

; 3137 : 
; 3138 : #ifdef DEBUG_OUT
; 3139 :   instr = tokenarray[i].string_ptr;
; 3140 : #endif
; 3141 :   CodeInfo.token = tokenarray[i].tokval;

	movsxd	rax, r9d

; 3142 :   /* get the instruction's start position in InstrTable[] */
; 3143 :   CodeInfo.pinstr = &InstrTable[IndexFromToken(CodeInfo.token)];

	lea	rcx, OFFSET FLAT:__ImageBase
	shl	rax, 5

; 3144 :   i++;

	inc	r9d
	movsxd	r8, DWORD PTR [rax+rsi+16]
	mov	DWORD PTR CodeInfo$[rsp+24], r8d
	mov	DWORD PTR i$[rbp-256], r9d
	movzx	eax, WORD PTR optable_idx[rcx+r8*2-908]
	imul	rcx, rax, 14
	lea	rax, OFFSET FLAT:InstrTable
	add	rcx, rax

; 3145 : 
; 3146 :   if (CurrSeg == NULL) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR CodeInfo$[rsp+16], rcx
	test	rax, rax
	jne	SHORT $LN97@ParseLine

; 3147 :     return(EmitError(MUST_BE_IN_SEGMENT_BLOCK));

	lea	ecx, QWORD PTR [rax+82]
	call	EmitError
	jmp	$LN315@ParseLine
$LN97@ParseLine:

; 3148 :   }
; 3149 :   if (CurrSeg->e.seginfo->segtype == SEGTYPE_UNDEF) {

	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rsp+632], r12
	mov	QWORD PTR [rsp+624], r13
	mov	QWORD PTR [rsp+616], r15
	cmp	DWORD PTR [rax+72], ebx
	jne	SHORT $LN98@ParseLine

; 3150 :     CurrSeg->e.seginfo->segtype = SEGTYPE_CODE;

	mov	DWORD PTR [rax+72], r14d
	mov	r9d, DWORD PTR i$[rbp-256]
	mov	r8d, DWORD PTR CodeInfo$[rsp+24]
$LN98@ParseLine:

; 3151 :   }
; 3152 :   if (ModuleInfo.CommentDataInCode)

	cmp	BYTE PTR ModuleInfo+423, bl
	je	SHORT $LN99@ParseLine

; 3153 :     omf_OutSelect(FALSE);

	xor	ecx, ecx
	call	omf_OutSelect
	mov	r9d, DWORD PTR i$[rbp-256]
	mov	r8d, DWORD PTR CodeInfo$[rsp+24]
$LN99@ParseLine:

; 3154 : 
; 3155 :   /* get the instruction's arguments.
; 3156 :    * This loop accepts up to 4 arguments if AVXSUPP is on */
; 3157 :   for (j = 0; j < sizeof(opndx) / sizeof(opndx[0]) && tokenarray[i].token != T_FINAL; j++) {

	xor	r10d, r10d
	lea	rax, QWORD PTR opndx$[rbp-192]
	lea	r15, QWORD PTR opndx$[rbp-184]
	mov	QWORD PTR tv2245[rbp-256], rax
	mov	edi, r10d
	lea	r12, QWORD PTR opndx$[rbp-240]
	sub	r15, 208				; 000000d0H
	lea	rbx, QWORD PTR opndx$[rbp-196]
	lea	r14, QWORD PTR opndx$[rbp-184]
	lea	r13, QWORD PTR opndx$[rbp-186]
	npad	6
$LL13@ParseLine:
	movsxd	rax, r9d
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+rsi]
	test	cl, cl
	je	$LN12@ParseLine

; 3158 :     if (j) {

	test	edi, edi
	je	SHORT $LN100@ParseLine

; 3159 :       if (tokenarray[i].token != T_COMMA)

	cmp	cl, 44					; 0000002cH
	jne	$LN12@ParseLine

; 3160 :         break;
; 3161 :       i++;

	inc	r9d
	mov	DWORD PTR i$[rbp-256], r9d
$LN100@ParseLine:

; 3162 :     }
; 3163 :     DebugMsg1(("ParseLine(%s): calling EvalOperand, i=%u\n", instr, i));
; 3164 :     //if (CodeInfo.token == T_VMOVSS) __debugbreak();
; 3165 :     if (EvalOperand(&i, tokenarray, Token_Count, &opndx[j], 0) == ERROR) {

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, rsi
	movsxd	rax, edi
	imul	rcx, rax, 104				; 00000068H
	lea	rax, QWORD PTR opndx$[rbp-256]
	mov	BYTE PTR [rsp+32], 0
	add	rax, rcx
	lea	rcx, QWORD PTR i$[rbp-256]
	mov	r9, rax
	mov	QWORD PTR tv2258[rbp-256], rax
	call	EvalOperand
	cmp	eax, -1
	je	$LN239@ParseLine

; 3166 :       DebugMsg(("ParseLine(%s): EvalOperand() failed\n", instr));
; 3167 :       return(ERROR);
; 3168 :     }
; 3169 : 
; 3170 :     if (j == 2 && (opndx[j].kind == EXPR_REG)){

	cmp	edi, 2
	jne	SHORT $LN103@ParseLine
	cmp	DWORD PTR [rbx], edi
	jne	SHORT $LN103@ParseLine

; 3171 :       regtok = opndx[OPND3].base_reg->tokval;
; 3172 :       CodeInfo.reg3 = GetRegNo(regtok);

	mov	rax, QWORD PTR opndx$[rbp-24]
	movsxd	rcx, DWORD PTR [rax+16]
	lea	rax, QWORD PTR [rcx+rcx*2]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR SpecialTable[rcx+rax*4+10]
	mov	BYTE PTR CodeInfo$[rbp-145], al
$LN103@ParseLine:

; 3173 :     }
; 3174 :     switch (opndx[j].kind) {

	mov	eax, DWORD PTR [rbx]
	cmp	eax, -2
	je	$LN111@ParseLine
	cmp	eax, -1
	je	$LN299@ParseLine
	mov	r8d, DWORD PTR CodeInfo$[rsp+24]
	cmp	eax, 3
	je	SHORT $LN104@ParseLine
	cmp	eax, 4
	je	SHORT $LN105@ParseLine
	xor	r10d, r10d
	jmp	$LN322@ParseLine
$LN104@ParseLine:

; 3175 :     case EXPR_FLOAT:
; 3176 :       /* v2.06: accept float constants for PUSH */
; 3177 :       if (j == OPND2 || CodeInfo.token == T_PUSH || CodeInfo.token == T_PUSHD) {

	cmp	edi, 1
	je	SHORT $LN106@ParseLine
	cmp	r8d, 600				; 00000258H
	je	SHORT $LN106@ParseLine
	cmp	r8d, 564				; 00000234H
	je	SHORT $LN106@ParseLine
$LN105@ParseLine:

; 3154 : 
; 3155 :   /* get the instruction's arguments.
; 3156 :    * This loop accepts up to 4 arguments if AVXSUPP is on */
; 3157 :   for (j = 0; j < sizeof(opndx) / sizeof(opndx[0]) && tokenarray[i].token != T_FINAL; j++) {

	add	r14, -104				; ffffffffffffff98H

; 3189 :       }
; 3190 : #if AVXSUPP
; 3191 :  /* here is handled EVEX Static Rounding Mode {sae}, {rn-sae}, {rd-sae}, {ru-sae}, {rz-sae} */
; 3192 :     case EXPR_DECORATOR:
; 3193 :       if (opndx[j - 1].indirect || opndx[j - 2].indirect)

	test	BYTE PTR [r14], 1
	jne	$LN233@ParseLine
	test	BYTE PTR [r15], 1
	jne	$LN233@ParseLine

; 3195 :         CodeInfo.evex_sae = opndx[j].saeflags;

	movzx	eax, BYTE PTR [r13]

; 3196 :         j--;

	dec	edi
	mov	rdx, QWORD PTR tv2245[rbp-256]
	sub	r15, 104				; 00000068H
	sub	rdx, 104				; 00000068H
	mov	BYTE PTR CodeInfo$[rbp-115], al
	sub	r13, 104				; 00000068H
	sub	rbx, 104				; 00000068H
	sub	r12, 104				; 00000068H

; 3197 :         break;

	xor	r10d, r10d
	jmp	SHORT $LN11@ParseLine
$LN106@ParseLine:

; 3178 : #if FPIMMEDIATE
; 3179 :         if (Options.strict_masm_compat == FALSE) {

	cmp	BYTE PTR Options+127, 0
	jne	$LN107@ParseLine

; 3180 :           /* convert to REAL4, unless REAL8 coercion is requested */
; 3181 :           atofloat(&opndx[j].fvalue, opndx[j].float_tok->string_ptr, opndx[j].mem_type == MT_REAL8 ? 8 : 4, opndx[j].negative, opndx[j].float_tok->floattype);

	mov	rax, QWORD PTR tv2245[rbp-256]
	mov	r8d, 4
	mov	rdx, QWORD PTR [r12]
	mov	r9d, DWORD PTR [r14]
	mov	rcx, QWORD PTR tv2258[rbp-256]
	shr	r9d, 5
	and	r9b, 1
	cmp	DWORD PTR [rax], 39			; 00000027H
	mov	eax, 8
	cmove	r8d, eax
	movzx	eax, BYTE PTR [rdx+1]
	mov	rdx, QWORD PTR [rdx+8]
	mov	BYTE PTR [rsp+32], al
	call	atofloat

; 3182 :           opndx[j].kind = EXPR_CONST;

	xor	r10d, r10d
	mov	DWORD PTR [rbx], r10d

; 3183 :           opndx[j].float_tok = NULL;

	mov	QWORD PTR [r12], r10
$LN322@ParseLine:
	mov	rdx, QWORD PTR tv2245[rbp-256]
	mov	r8d, DWORD PTR CodeInfo$[rsp+24]
$LN11@ParseLine:

; 3154 : 
; 3155 :   /* get the instruction's arguments.
; 3156 :    * This loop accepts up to 4 arguments if AVXSUPP is on */
; 3157 :   for (j = 0; j < sizeof(opndx) / sizeof(opndx[0]) && tokenarray[i].token != T_FINAL; j++) {

	mov	r9d, DWORD PTR i$[rbp-256]
	inc	edi
	add	rdx, 104				; 00000068H
	movsxd	rax, edi
	add	r15, 104				; 00000068H
	mov	QWORD PTR tv2245[rbp-256], rdx
	add	r13, 104				; 00000068H
	add	r14, 104				; 00000068H
	add	rbx, 104				; 00000068H
	add	r12, 104				; 00000068H
	cmp	rax, 4
	jb	$LL13@ParseLine
$LN12@ParseLine:

; 3207 :     }
; 3208 :   }
; 3209 :   if (tokenarray[i].token != T_FINAL) {

	movsxd	rdx, r9d
	shl	rdx, 5
	add	rdx, rsi
	cmp	BYTE PTR [rdx], 0
	je	SHORT $LN114@ParseLine

; 3210 :     DebugMsg(("ParseLine(%s): too many operands (%s) \n", instr, tokenarray[i].tokpos));
; 3211 :     return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos));

	mov	rdx, QWORD PTR [rdx+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN318@ParseLine
$LN233@ParseLine:

; 3194 :         return(EmitError(EMBEDDED_ROUNDING_IS_AVAILABLE_ONLY_WITH_REG_REG_OP));

	mov	ecx, 21
	call	EmitError
	jmp	$LN318@ParseLine
$LN107@ParseLine:

; 3184 :           break;
; 3185 :         }
; 3186 : #endif
; 3187 :         /* Masm message is: real or BCD number not allowed */
; 3188 :         return(EmitError(FP_INITIALIZER_IGNORED));

	mov	ecx, 74					; 0000004aH
	call	EmitError
	jmp	$LN318@ParseLine
$LN299@ParseLine:

; 3202 :         i--;  /* v2.08: if there was a terminating comma, display it */

	mov	eax, DWORD PTR i$[rbp-256]
	jmp	SHORT $LN112@ParseLine
$LN111@ParseLine:

; 3198 :       /* fall through */
; 3199 : #endif
; 3200 :     case EXPR_EMPTY:
; 3201 :       if (i == Token_Count)

	mov	eax, DWORD PTR i$[rbp-256]
	cmp	eax, DWORD PTR ModuleInfo+496
	jne	SHORT $LN112@ParseLine

; 3202 :         i--;  /* v2.08: if there was a terminating comma, display it */

	dec	eax
	mov	DWORD PTR i$[rbp-256], eax
$LN112@ParseLine:

; 3203 :       /* fall through */
; 3204 :     case EXPR_ERROR:
; 3205 :       DebugMsg(("ParseLine(%s): unexpected operand kind=%d, error, exit\n", instr, opndx[j].kind));
; 3206 :       return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr));

	movsxd	rdx, eax
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+8]
	call	EmitErr
	jmp	$LN318@ParseLine
$LN114@ParseLine:

; 3212 :   }
; 3213 :   for (CurrOpnd = 0; CurrOpnd < j && CurrOpnd < MAX_OPND; CurrOpnd++) {

	mov	ebx, r10d
	mov	r13d, -1887436800			; ffffffff8f800000H
	test	edi, edi
	je	$LN307@ParseLine
	mov	r9, QWORD PTR opndx$[rbp-128]
	npad	6
$LL18@ParseLine:
	cmp	ebx, 3
	jae	$LN308@ParseLine

; 3214 : 
; 3215 :     Frame_Type = FRAME_NONE;
; 3216 :     SegOverride = NULL; /* segreg prefix is stored in RegOverride */
; 3217 :     CodeInfo.opnd[CurrOpnd].data32l = 0;

	mov	r15d, ebx
	mov	BYTE PTR Frame_Type, 6
	mov	QWORD PTR SegOverride, r10
	lea	rax, QWORD PTR [r15+r15*2]
	mov	DWORD PTR CodeInfo$[rsp+rax*8+40], r10d

; 3218 :     CodeInfo.opnd[CurrOpnd].InsFixup = NULL;

	mov	QWORD PTR CodeInfo$[rsp+rax*8+48], r10

; 3219 : #if AVXSUPP
; 3220 :     /* if encoding is VEX and destination op is XMM, YMM or memory,
; 3221 :      * the second argument may be stored in the vexregop field.
; 3222 :      */
; 3223 :     if (CodeInfo.token >= VEX_START &&
; 3224 :       CurrOpnd == OPND2 &&

	movsxd	r8, DWORD PTR CodeInfo$[rsp+24]
	cmp	r8d, 1295				; 0000050fH
	jl	$LN313@ParseLine
	cmp	ebx, 1
	jne	$LN313@ParseLine
	test	DWORD PTR CodeInfo$[rsp+32], -1082129940 ; ffffffffbf8001ecH
	je	$LN313@ParseLine

; 3225 :       (CodeInfo.opnd[OPND1].type & (OP_R32 | OP_R64 | OP_K | OP_XMM | OP_YMM | OP_ZMM | OP_M | OP_M64 | OP_M256 | OP_M512))) {
; 3226 :       CodeInfo.indexreg = 0xFF;
; 3227 :       CodeInfo.basereg = 0xFF;
; 3228 :       if (opndx[OPND1].kind == EXPR_REG){

	cmp	DWORD PTR opndx$[rbp-196], 2

; 3229 :         regtok = opndx[OPND1].base_reg->tokval;
; 3230 :       CodeInfo.reg1 = GetRegNo(regtok);

	lea	r14, OFFSET FLAT:__ImageBase
	mov	WORD PTR CodeInfo$[rbp-144], 65535	; 0000ffffH
	jne	SHORT $LN300@ParseLine
	mov	r10, QWORD PTR opndx$[rbp-232]
	movsxd	rax, DWORD PTR [r10+16]
	lea	rcx, QWORD PTR [rax+rax*2]

; 3231 :       if (opndx[OPND1].idx_reg) CodeInfo.indexreg = opndx[OPND1].idx_reg->bytval;

	mov	rax, QWORD PTR opndx$[rbp-224]
	movzx	r11d, BYTE PTR SpecialTable[r14+rcx*4+10]
	mov	BYTE PTR CodeInfo$[rbp-147], r11b
	test	rax, rax
	je	SHORT $LN117@ParseLine
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR CodeInfo$[rbp-144], al
$LN117@ParseLine:

; 3232 :       if (CodeInfo.reg1 > 15) CodeInfo.evex_flag = TRUE;

	movzx	edx, BYTE PTR CodeInfo$[rbp-120]
	cmp	r11b, 15
	mov	r12d, 1
	cmova	edx, r12d
	mov	BYTE PTR CodeInfo$[rbp-120], dl

; 3233 :       CodeInfo.r1type = GetValueSp(opndx[OPND1].base_reg->tokval);

	mov	eax, DWORD PTR [r10+16]

; 3234 :       if (CodeInfo.r1type == OP_ZMM)CodeInfo.evex_flag = TRUE;

	movzx	r10d, dl
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR SpecialTable[r14+rcx*4]
	cmp	eax, 256				; 00000100H
	mov	DWORD PTR CodeInfo$[rbp-140], eax
	cmove	r10d, r12d
	mov	BYTE PTR CodeInfo$[rbp-120], r10b
	jmp	SHORT $LN119@ParseLine
$LN300@ParseLine:
	movzx	r10d, BYTE PTR CodeInfo$[rbp-120]
	mov	r12d, 1
$LN119@ParseLine:

; 3235 :       }
; 3236 :       if (opndx[OPND2].kind == EXPR_REG){

	cmp	DWORD PTR opndx$[rbp-92], 2
	jne	SHORT $LN314@ParseLine

; 3237 :         regtok = opndx[OPND2].base_reg->tokval;
; 3238 :       CodeInfo.reg2 = GetRegNo(regtok);

	movsxd	rax, DWORD PTR [r9+16]
	lea	rcx, QWORD PTR [rax+rax*2]

; 3239 :       if (opndx[OPND2].idx_reg) CodeInfo.indexreg = opndx[OPND2].idx_reg->bytval;

	mov	rax, QWORD PTR opndx$[rbp-120]
	movzx	r11d, BYTE PTR SpecialTable[r14+rcx*4+10]
	mov	BYTE PTR CodeInfo$[rbp-146], r11b
	test	rax, rax
	je	SHORT $LN121@ParseLine
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR CodeInfo$[rbp-144], al
$LN121@ParseLine:

; 3240 :       if (CodeInfo.reg2 > 15) CodeInfo.evex_flag = TRUE;

	cmp	r11b, 15
	movzx	edx, r10b

; 3241 :        CodeInfo.r2type = GetValueSp(opndx[OPND2].base_reg->tokval);

	lea	r10, OFFSET FLAT:__ImageBase
	cmova	edx, r12d
	mov	BYTE PTR CodeInfo$[rbp-120], dl
	mov	eax, DWORD PTR [r9+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR SpecialTable[r10+rcx*4]

; 3242 :        if (CodeInfo.r2type == OP_ZMM)CodeInfo.evex_flag = TRUE;

	cmp	eax, 256				; 00000100H
	movzx	ecx, dl
	cmove	ecx, r12d
	mov	DWORD PTR CodeInfo$[rbp-136], eax
	mov	BYTE PTR CodeInfo$[rbp-120], cl
	jmp	SHORT $LN123@ParseLine
$LN314@ParseLine:
	lea	r10, OFFSET FLAT:__ImageBase
$LN123@ParseLine:
	lea	eax, DWORD PTR [r8-1673]
	cmp	eax, 1
	jbe	$putinvex$332
	lea	eax, DWORD PTR [r8-1683]
	cmp	eax, 1
	jbe	$putinvex$332

; 3243 :        }
; 3244 :       if (((CodeInfo.token == T_ANDN)||(CodeInfo.token == T_MULX)||
; 3245 :         (CodeInfo.token == T_PEXT)||(CodeInfo.token == T_PDEP)) &&
; 3246 :         (CurrOpnd == OPND2 )) goto putinvex;
; 3247 :       if (vex_flags[CodeInfo.token - VEX_START] & VX_NND)

	movzx	edx, BYTE PTR vex_flags[r8+r10-1295]
	test	dl, 2
	jne	$LN303@ParseLine

; 3248 :         ;
; 3249 :       else if ((vex_flags[CodeInfo.token - VEX_START] & VX_IMM) &&
; 3250 :         (opndx[OPND3].kind == EXPR_CONST) && (j > 2))

	test	dl, 8
	je	SHORT $LN128@ParseLine
	cmp	DWORD PTR opndx$[rbp+12], 0
	jne	SHORT $LN128@ParseLine
	cmp	edi, 2
	jg	$LN303@ParseLine
$LN128@ParseLine:

; 3251 :         ;
; 3252 :       else if ( ( vex_flags[CodeInfo.token - VEX_START] & VX_NMEM ) &&

	test	dl, 16
	je	SHORT $LN136@ParseLine
	test	DWORD PTR CodeInfo$[rsp+32], r13d
	jne	$LN303@ParseLine
	lea	eax, DWORD PTR [r8-1943]
	cmp	eax, 1
	ja	SHORT $LN136@ParseLine
	cmp	DWORD PTR opndx$[rbp-92], 2
	jne	$LN303@ParseLine
	test	BYTE PTR opndx$[rbp-80], 1
	jne	$LN303@ParseLine
$LN136@ParseLine:

; 3253 :                ( ( CodeInfo.opnd[OPND1].type & OP_M ) ||
; 3254 :                /* v2.11: VMOVSD and VMOVSS always have 2 ops if a memory op is involved */
; 3255 :                ( ( CodeInfo.token == T_VMOVSD || CodeInfo.token == T_VMOVSS ) &&
; 3256 :                ( opndx[OPND2].kind != EXPR_REG || opndx[OPND2].indirect == TRUE ) ) )
; 3257 :               )
; 3258 :           ;
; 3259 :       else {
; 3260 :         if (opndx[OPND2].kind != EXPR_REG ||
; 3261 :           (!(GetValueSp(opndx[CurrOpnd].base_reg->tokval) & (OP_R32 | OP_R64 |OP_K | OP_XMM | OP_YMM | OP_ZMM)))) {
; 3262 :           DebugMsg(("ParseLine(%s,%u): avx invalid operand, op2.kind=%u\n", instr, CurrOpnd, opndx[OPND2].kind));
; 3263 :           if ((CodeInfo.token < T_KMOVB) && (CodeInfo.token > T_KMOVW))
; 3264 :             return(EmitErr(INVALID_INSTRUCTION_OPERANDS));
; 3265 :         }
; 3266 :         /* fixme: check if there's an operand behind OPND2 at all!
; 3267 :          * if no, there's no point to continue with switch (opndx[].kind).
; 3268 :          * v2.11: additional check for j <= 2 added
; 3269 :          */
; 3270 :         if (j <= 2) {

	cmp	edi, 2
	jle	$LN147@ParseLine

; 3271 :           DebugMsg(("ParseLine(%s,%u): avx not enough operands (%u)\n", instr, CurrOpnd, opndx[OPND2].kind, j));
; 3272 :           /* v2.11: next line should be activated - currently the error is emitted below as syntax error */
; 3273 :           //return( EmitErr( INVALID_INSTRUCTION_OPERANDS ) );
; 3274 :         }
; 3275 :         else
; 3276 : 
; 3277 : 		  /* flag VX_DST is set if an immediate is expected as operand 3 */
; 3278 : 			if ((vex_flags[CodeInfo.token - VEX_START] & VX_DST) &&

	test	dl, 4
	je	$LN140@ParseLine
	cmp	DWORD PTR opndx$[rbp+12], 0
	jne	$LN140@ParseLine

; 3279 : 				(opndx[OPND3].kind == EXPR_CONST)) {
; 3280 : 				DebugMsg1(("ParseLine(%s,%u): avx VX_DST, op3.kind=CONST (value=%u), numops=%u\n", instr, CurrOpnd, opndx[OPND3].kind, opndx[OPND3].value, j));
; 3281 : 				if (opndx[OPND2].idx_reg)

	mov	rax, QWORD PTR opndx$[rbp-120]
	test	rax, rax
	je	SHORT $LN142@ParseLine

; 3282 : 					CodeInfo.indexreg = opndx[OPND2].idx_reg->bytval;

	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR CodeInfo$[rbp-144], al
$LN142@ParseLine:

; 3283 : 				if (opndx[OPND2].base_reg)

	test	r9, r9
	je	SHORT $LN143@ParseLine

; 3284 : 					CodeInfo.basereg = opndx[OPND2].base_reg->bytval;

	movzx	eax, BYTE PTR [r9+1]
	mov	BYTE PTR CodeInfo$[rbp-143], al
$LN143@ParseLine:

; 3285 : 				/* third operand data goes in CodeInfo.vexconst used in codegen.c */
; 3286 : 				CodeInfo.vexconst = opndx[CurrOpnd].value;

	mov	eax, DWORD PTR opndx$[rbp-152]
	mov	DWORD PTR CodeInfo$[rbp-132], eax

; 3287 : 				if (opndx[OPND1].base_reg) {

	mov	rax, QWORD PTR opndx$[rbp-232]
	test	rax, rax
	je	$LN147@ParseLine

; 3288 : 					/* first operand register is moved to vexregop */
; 3289 : 					/* handle VEX.NDD */
; 3290 : 					CodeInfo.vexregop = opndx[OPND1].base_reg->bytval + 1;

	movzx	eax, BYTE PTR [rax+1]

; 3291 : 					memcpy(&opndx[OPND1], &opndx[CurrOpnd], sizeof(opndx[0]) * 3);

	lea	rcx, QWORD PTR opndx$[rbp-256]
	inc	al
	mov	edx, 2
	mov	BYTE PTR CodeInfo$[rbp-128], al
	lea	rax, QWORD PTR opndx$[rbp-152]
	npad	3
$LL293@ParseLine:
	lea	rcx, QWORD PTR [rcx+128]
	movups	xmm0, XMMWORD PTR [rax]
	lea	rax, QWORD PTR [rax+128]
	movups	XMMWORD PTR [rcx-128], xmm0
	movups	xmm1, XMMWORD PTR [rax-112]
	movups	XMMWORD PTR [rcx-112], xmm1
	movups	xmm0, XMMWORD PTR [rax-96]
	movups	XMMWORD PTR [rcx-96], xmm0
	movups	xmm1, XMMWORD PTR [rax-80]
	movups	XMMWORD PTR [rcx-80], xmm1
	movups	xmm0, XMMWORD PTR [rax-64]
	movups	XMMWORD PTR [rcx-64], xmm0
	movups	xmm1, XMMWORD PTR [rax-48]
	movups	XMMWORD PTR [rcx-48], xmm1
	movups	xmm0, XMMWORD PTR [rax-32]
	movups	XMMWORD PTR [rcx-32], xmm0
	movups	xmm1, XMMWORD PTR [rax-16]
	movups	XMMWORD PTR [rcx-16], xmm1
	sub	rdx, 1
	jne	SHORT $LL293@ParseLine
	movups	xmm0, XMMWORD PTR [rax]

; 3292 : 					CodeInfo.rm_byte = 0;
; 3293 : 					if (process_register(&CodeInfo, OPND1, opndx) == ERROR)

	lea	r8, QWORD PTR opndx$[rbp-256]
	mov	BYTE PTR CodeInfo$[rbp-152], dl
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [rax+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR [rcx+48], rax
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	process_register
	cmp	eax, -1
	je	$LN239@ParseLine

; 3294 : 						return(ERROR);
; 3295 : 				}
; 3296 : 			}

	mov	r8d, DWORD PTR CodeInfo$[rsp+24]
	jmp	$LN323@ParseLine
$LN140@ParseLine:

; 3297 : 
; 3298 :           else if (CodeInfo.token < T_VGETMANTPD || CodeInfo.token > T_VGETMANTPS ) {

	lea	eax, DWORD PTR [r8-1433]
	cmp	eax, 1
	ja	SHORT $LN148@ParseLine

; 3324 :           }
; 3325 :           else
; 3326 :           {
; 3327 :             CodeInfo.vexconst = opndx[CurrOpnd + 1].value;

	mov	eax, DWORD PTR opndx$[rbp-48]

; 3328 :             j++;

	inc	edi
	mov	DWORD PTR CodeInfo$[rbp-132], eax
	jmp	$LN147@ParseLine
$LN148@ParseLine:

; 3299 :             unsigned flags = GetValueSp(opndx[CurrOpnd].base_reg->tokval);

	mov	eax, DWORD PTR [r9+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR SpecialTable[r10+rcx*4]

; 3300 :             //CodeInfo.rtype = GetValueSp(opndx[CurrOpnd].base_reg->tokval);
; 3301 :             DebugMsg1(("ParseLine(%s,%u): opnd2 is avx reg (%s), flags=%X ci.type[0]=%X numops=%u\n",
; 3302 :               instr, CurrOpnd, opndx[CurrOpnd].base_reg->string_ptr, flags, CodeInfo.opnd[OPND1].type, j));
; 3303 : //#if 1
; 3304 :             /* v2.08: no error here if first op is an untyped memory reference
; 3305 :              * note that OP_M includes OP_M128, but not OP_M256 (to be fixed?)
; 3306 :              */
; 3307 :             if (CodeInfo.opnd[OPND1].type == OP_M)

	mov	ecx, DWORD PTR CodeInfo$[rsp+32]
	cmp	ecx, r13d
	je	SHORT $putinvex$332

; 3308 :               ; else
; 3309 : //#endif
; 3310 :               if ((flags & (OP_XMM | OP_M128)) &&
; 3311 :                 (CodeInfo.opnd[OPND1].type & (OP_YMM | OP_M256)) ||

	test	eax, 134217760				; 08000020H
	je	SHORT $LN153@ParseLine
	test	ecx, 268435584				; 10000080H
	jne	$LN152@ParseLine
$LN153@ParseLine:
	test	eax, 268435584				; 10000080H
	je	SHORT $putinvex$332
	test	DWORD PTR CodeInfo$[rsp+32], 134217760	; 08000020H
	jne	$LN152@ParseLine
$putinvex$332:

; 3316 :               }
; 3317 :             /* second operand register is moved to vexregop */
; 3318 :             /* to be fixed: CurrOpnd is always OPND2, so use this const here */
; 3319 :             //CodeInfo.vexdata is containing I_U8 data of EXPR_CONST ,habran
; 3320 :        putinvex:
; 3321 :             CodeInfo.vexconst = opndx[CurrOpnd].value;

	mov	eax, DWORD PTR opndx$[rbp-152]

; 3322 :             CodeInfo.vexregop = opndx[CurrOpnd].base_reg->bytval + 1;
; 3323 :             memcpy(&opndx[CurrOpnd], &opndx[CurrOpnd + 1], sizeof(opndx[0]) * 2);

	lea	rcx, QWORD PTR opndx$[rbp-152]
	lea	rcx, QWORD PTR [rcx+128]
	mov	DWORD PTR CodeInfo$[rbp-132], eax
	movzx	eax, BYTE PTR [r9+1]
	inc	al
	mov	BYTE PTR CodeInfo$[rbp-128], al
	lea	rax, QWORD PTR opndx$[rbp-48]
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rcx-128], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR [rcx-112], xmm1
	movups	xmm0, XMMWORD PTR [rax+32]
	movups	XMMWORD PTR [rcx-96], xmm0
	movups	xmm1, XMMWORD PTR [rax+48]
	movups	XMMWORD PTR [rcx-80], xmm1
	movups	xmm0, XMMWORD PTR [rax+64]
	movups	XMMWORD PTR [rcx-64], xmm0
	movups	xmm1, XMMWORD PTR [rax+80]
	movups	XMMWORD PTR [rcx-48], xmm1
	movups	xmm0, XMMWORD PTR [rax+96]
	movups	XMMWORD PTR [rcx-32], xmm0
	movups	xmm1, XMMWORD PTR [rax+112]
	movups	XMMWORD PTR [rcx-16], xmm1
	movups	xmm0, XMMWORD PTR [rax+128]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rax+144]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [rax+160]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [rax+176]
	movups	XMMWORD PTR [rcx+48], xmm1
	movups	xmm0, XMMWORD PTR [rax+192]
	movups	XMMWORD PTR [rcx+64], xmm0
$LN323@ParseLine:
	mov	r9, QWORD PTR opndx$[rbp-128]
$LN147@ParseLine:

; 3329 :           }
; 3330 :           j--;

	dec	edi
$LN313@ParseLine:
	lea	r10, OFFSET FLAT:__ImageBase
$LN303@ParseLine:

; 3331 :       }
; 3332 :     }
; 3333 : #endif
; 3334 :     DebugMsg1(("ParseLine(%s,%u): type/value/mem_type/ofssize=%Xh/%" I64_SPEC "Xh/%Xh/%d\n", instr, CurrOpnd, opndx[CurrOpnd].kind, opndx[CurrOpnd].value64, opndx[CurrOpnd].mem_type, opndx[CurrOpnd].Ofssize));
; 3335 :     switch (opndx[CurrOpnd].kind) {

	imul	rdx, r15, 104				; 00000068H
	mov	ecx, DWORD PTR opndx$[rbp+rdx-196]
	test	ecx, ecx
	je	$LN157@ParseLine
	sub	ecx, 1
	je	SHORT $LN155@ParseLine
	sub	ecx, 1
	je	SHORT $LN159@ParseLine
	cmp	ecx, 2
	jne	$LN16@ParseLine

; 3336 :     case EXPR_DECORATOR:
; 3337 :       CodeInfo.evex_sae = opndx[CurrOpnd].saeflags;
; 3338 :       return( codegen( &CodeInfo, oldofs ) );

	mov	edx, DWORD PTR oldofs$1$[rbp-256]
	mov	eax, ebx
	imul	rcx, rax, 104				; 00000068H
	movzx	eax, BYTE PTR opndx$[rbp+rcx-186]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR CodeInfo$[rbp-115], al
	call	codegen
	jmp	$LN318@ParseLine
$LN159@ParseLine:

; 3348 :       break;
; 3349 :     case EXPR_REG:
; 3350 :       DebugMsg1(("ParseLine(%s,%u): type REG\n", instr, CurrOpnd));
; 3351 :       if (opndx[CurrOpnd].indirect) { /* indirect operand ( "[EBX+...]" )? */

	test	BYTE PTR opndx$[rbp+rdx-184], 1
	je	SHORT $LN160@ParseLine
$LN155@ParseLine:

; 3352 :         if (process_address(&CodeInfo, CurrOpnd, &opndx[CurrOpnd]) == ERROR)

	lea	r8, QWORD PTR opndx$[rbp-256]
	add	r8, rdx
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, ebx
	call	process_address

; 3353 :           return(ERROR);
; 3354 :       }

	jmp	$LN220@ParseLine
$LN160@ParseLine:

; 3355 :       else {
; 3356 :         /* process_register() can't handle 3rd operand */
; 3357 :         if (!CodeInfo.vexregop){

	cmp	BYTE PTR CodeInfo$[rbp-128], 0
	jne	SHORT $LN168@ParseLine

; 3358 :           if (CurrOpnd == OPND1){

	test	ebx, ebx
	jne	SHORT $LN164@ParseLine

; 3359 :             regtok = opndx[OPND1].base_reg->tokval;
; 3360 :             CodeInfo.reg1 = GetRegNo(regtok);

	mov	rax, QWORD PTR opndx$[rbp-232]
	movsxd	rcx, DWORD PTR [rax+16]
	lea	rax, QWORD PTR [rcx+rcx*2]
	movzx	eax, BYTE PTR SpecialTable[r10+rax*4+10]
	mov	BYTE PTR CodeInfo$[rbp-147], al
$LN325@ParseLine:

; 3366 :             if (CodeInfo.reg2 > 15) CodeInfo.evex_flag = TRUE;

	cmp	al, 15
	jbe	SHORT $LN169@ParseLine
	mov	BYTE PTR CodeInfo$[rbp-120], 1
$LN169@ParseLine:

; 3376 :         else if (process_register(&CodeInfo, CurrOpnd, opndx) == ERROR)

	lea	r8, QWORD PTR opndx$[rbp-256]
	mov	edx, ebx
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	process_register
	jmp	$LN220@ParseLine
$LN164@ParseLine:

; 3361 :             if (CodeInfo.reg1 > 15) CodeInfo.evex_flag = TRUE;
; 3362 :           }
; 3363 :           else if (CurrOpnd == OPND2){

	cmp	ebx, 1
	jne	SHORT $LN168@ParseLine

; 3364 :             regtok = opndx[OPND2].base_reg->tokval;
; 3365 :             CodeInfo.reg2 = GetRegNo(regtok);

	movsxd	rax, DWORD PTR [r9+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR SpecialTable[r10+rcx*4+10]
	mov	BYTE PTR CodeInfo$[rbp-146], al

; 3367 :           }
; 3368 :         }
; 3369 :         if (CurrOpnd == OPND3) {

	jmp	SHORT $LN325@ParseLine
$LN168@ParseLine:
	cmp	ebx, 2
	jne	SHORT $LN169@ParseLine

; 3370 :           CodeInfo.opnd[OPND3].type = GetValueSp(opndx[OPND3].base_reg->tokval);

	mov	rdx, QWORD PTR opndx$[rbp-24]
	mov	eax, DWORD PTR [rdx+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR SpecialTable[r10+rcx*4]
	mov	DWORD PTR CodeInfo$[rbp-176], eax

; 3371 :           CodeInfo.opnd[OPND3].data32l = opndx[OPND3].base_reg->bytval;

	movzx	eax, BYTE PTR [rdx+1]
	mov	DWORD PTR CodeInfo$[rbp-168], eax

; 3372 :           regtok = opndx[OPND3].base_reg->tokval;
; 3373 :           CodeInfo.reg3 = GetRegNo(regtok);

	movsxd	rax, DWORD PTR [rdx+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR SpecialTable[r10+rcx*4+10]
	mov	BYTE PTR CodeInfo$[rbp-145], al

; 3374 :           if (CodeInfo.reg3 > 15) CodeInfo.evex_flag = TRUE;

	cmp	al, 15
	jbe	SHORT $LN16@ParseLine
	mov	BYTE PTR CodeInfo$[rbp-120], 1

; 3375 :         }

	jmp	SHORT $LN16@ParseLine
$LN157@ParseLine:

; 3339 :     case EXPR_ADDR:
; 3340 :       DebugMsg1(("ParseLine(%s,%u): type ADDRESS\n", instr, CurrOpnd));
; 3341 :       if (process_address(&CodeInfo, CurrOpnd, &opndx[CurrOpnd]) == ERROR)
; 3342 :         return(ERROR);
; 3343 :       break;
; 3344 :     case EXPR_CONST:
; 3345 :       DebugMsg1(("ParseLine(%s,%u): type CONST, opndx.memtype=%Xh\n", instr, CurrOpnd, opndx[CurrOpnd].mem_type));
; 3346 :       if (process_const(&CodeInfo, CurrOpnd, &opndx[CurrOpnd]) == ERROR)

	lea	r10, QWORD PTR opndx$[rbp-256]
	add	r10, rdx
	mov	rax, QWORD PTR [r10+16]
	test	rax, rax
	je	SHORT $LN221@ParseLine
	cmp	DWORD PTR [rax+16], 0
	jne	SHORT $LN221@ParseLine
	mov	ecx, 163				; 000000a3H
	call	EmitError
	jmp	SHORT $LN220@ParseLine
$LN221@ParseLine:
	mov	rax, QWORD PTR CodeInfo$[rsp+16]
	movzx	ecx, BYTE PTR [rax+12]
	and	cl, 247					; 000000f7H
	cmp	cl, 194					; 000000c2H
	jne	SHORT $LN222@ParseLine
	test	ebx, ebx
	jne	SHORT $LN222@ParseLine
	cmp	DWORD PTR [r10], ebx
	je	SHORT $LN16@ParseLine
$LN222@ParseLine:
	mov	r8, r10
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, ebx
	call	idata_nofixup
$LN220@ParseLine:
	cmp	eax, -1
	je	$LN239@ParseLine
	mov	r9, QWORD PTR opndx$[rbp-128]
	mov	r8d, DWORD PTR CodeInfo$[rsp+24]
$LN16@ParseLine:

; 3212 :   }
; 3213 :   for (CurrOpnd = 0; CurrOpnd < j && CurrOpnd < MAX_OPND; CurrOpnd++) {

	inc	ebx
	cmp	ebx, edi
	jae	SHORT $LN308@ParseLine
	xor	r10d, r10d
	jmp	$LL18@ParseLine
$LN152@ParseLine:

; 3312 :                 (flags & (OP_YMM | OP_M256)) &&
; 3313 :                 (CodeInfo.opnd[OPND1].type & (OP_XMM | OP_M128))) {
; 3314 :                 DebugMsg(("ParseLine(%s,%u): avx invalid opnd 2, flags=%X ci.type[0]=%X\n", instr, CurrOpnd, flags, CodeInfo.opnd[OPND1].type));
; 3315 :                 return(EmitErr(INVALID_INSTRUCTION_OPERANDS));

	mov	ecx, 49					; 00000031H
	call	EmitErr
	jmp	$LN318@ParseLine
$LN308@ParseLine:

; 3347 :         return(ERROR);

	mov	r9d, DWORD PTR i$[rbp-256]
$LN307@ParseLine:

; 3377 :           return(ERROR);
; 3378 :       }
; 3379 :       break;
; 3380 :     }
; 3381 :    } /* end for */
; 3382 : 
; 3383 : #if AVXSUPP
; 3384 : 	 /* 4 arguments are valid vor AVX only */
; 3385 :    if (CurrOpnd != j) {

	cmp	ebx, edi
	je	SHORT $LN176@ParseLine

; 3386 : 	   for (; tokenarray[i].token != T_COMMA; i--);

	movsxd	rax, r9d
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	je	SHORT $LN22@ParseLine
	npad	6
$LL23@ParseLine:
	dec	r9d
	movsxd	rax, r9d
	shl	rax, 5
	mov	DWORD PTR i$[rbp-256], r9d
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	jne	SHORT $LL23@ParseLine
$LN22@ParseLine:

; 3387 : 	   DebugMsg(("ParseLine(%s): CurrOpnd != j ( %u - %u ) >%s<\n", instr, CurrOpnd, j, tokenarray[i].tokpos));
; 3388 : 	   if (CodeInfo.token < VEX_START)

	cmp	r8d, 1295				; 0000050fH
	jl	$LN31@ParseLine
	lea	eax, DWORD PTR [r8-1325]
	cmp	eax, 1
	ja	SHORT $LN176@ParseLine

; 3389 : 		   return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos));
; 3390 : 	   else
; 3391 : 		   if ((CodeInfo.token == T_VMASKMOVPS || CodeInfo.token == T_VMASKMOVPD) && (j < 3))

	cmp	edi, 3
	jl	SHORT $LN327@ParseLine
$LN176@ParseLine:
	lea	eax, DWORD PTR [r8-1313]
	cmp	eax, 1
	ja	SHORT $LN180@ParseLine

; 3392 : 			   return(EmitErr(MISSING_OPERATOR_IN_EXPRESSION));
; 3393 :    }
; 3394 :    if (CodeInfo.token == T_VBLENDVPS || CodeInfo.token == T_VBLENDVPD) {
; 3395 : 	   DebugMsg(("ParseLine(%s): ( %u - %u ) >%s<\n", instr, CurrOpnd, j, tokenarray[i].tokpos));
; 3396 : 	   if (CodeInfo.opnd[OPND3].type == OP_NONE) {

	cmp	DWORD PTR CodeInfo$[rbp-176], 0
	jne	SHORT $LN180@ParseLine
$LN327@ParseLine:

; 3397 : 		   return (EmitErr(MISSING_OPERATOR_IN_EXPRESSION));

	mov	ecx, 150				; 00000096H
	call	EmitErr
	jmp	$LN318@ParseLine
$LN180@ParseLine:

; 3398 : 	   }
; 3399 :    }
; 3400 : 
; 3401 : #endif
; 3402 : 
; 3403 :   /* for FAR calls/jmps some special handling is required:
; 3404 :    * in the instruction tables, the "far" entries are located BEHIND
; 3405 :    * the "near" entries, that's why it's needed to skip all items
; 3406 :    * until the next "first" item is found.
; 3407 :    */
; 3408 :   if (CodeInfo.isfar) {

	movzx	edx, BYTE PTR CodeInfo$[rbp-114]
	test	dl, 4
	je	SHORT $LN25@ParseLine
	lea	eax, DWORD PTR [r8-454]
	cmp	eax, 1
	ja	SHORT $LN25@ParseLine
	npad	5
$LL26@ParseLine:

; 3409 :     if (CodeInfo.token == T_CALL || CodeInfo.token == T_JMP) {
; 3410 :       do {
; 3411 :         CodeInfo.pinstr++;

	mov	rcx, QWORD PTR CodeInfo$[rsp+16]
	add	rcx, 14
	mov	QWORD PTR CodeInfo$[rsp+16], rcx

; 3412 :       } while (CodeInfo.pinstr->first == FALSE);

	cmp	BYTE PTR [rcx+4], 0
	je	SHORT $LL26@ParseLine
$LN25@ParseLine:
	mov	rcx, QWORD PTR CodeInfo$[rsp+16]
	movzx	eax, WORD PTR [rcx+2]
	sub	ax, 2
	cmp	ax, 1
	jbe	$LN186@ParseLine

; 3420 : #if SVMSUPP /* v2.09, not active because a bit too hackish yet - it "works", though. */
; 3421 :   } else if ( CodeInfo.token >= T_VMRUN && CodeInfo.token <= T_INVLPGA && CodeInfo.pinstr->opclsidx ) {
; 3422 :     /* the size of the first operand is to trigger the address size byte 67h,
; 3423 :      * not the operand size byte 66h!
; 3424 :      */
; 3425 :     CodeInfo.prefix.adrsiz = CodeInfo.prefix.opsiz;
; 3426 :     CodeInfo.prefix.opsiz = 0;
; 3427 :     /* the first op must be EAX/AX or RAX/EAX. The operand class
; 3428 :      * used in the instruction table is OP_A ( which is AL/AX/EAX/RAX ).
; 3429 :      */
; 3430 :     if ( ( CodeInfo.opnd[OPND1].type & ( CodeInfo.Ofssize == USE64 ? OP_R64 | OP_R32 : OP_R32 | OP_R16 ) ) == 0 ) {
; 3431 :       DebugMsg(("ParseLine(%s): opnd1 unexpected type=%X\n", instr, CodeInfo.opnd[OPND1].type ));
; 3432 :       return( EmitErr( INVALID_INSTRUCTION_OPERANDS ) );
; 3433 :     }
; 3434 :     /* the INVLPGA instruction has a fix second operand (=ECX). However, there's no
; 3435 :      * operand class for ECX alone. So it has to be ensured here that the register IS ecx.
; 3436 :      */
; 3437 :     if ( CodeInfo.token == T_INVLPGA )
; 3438 :       if ( ( CodeInfo.rm_byte & BIT_345 ) != ( 1 << 3 ) ) { /* ECX is register 1 */
; 3439 :         DebugMsg(("ParseLine(%s): opnd2 is not ecx\n", instr ));
; 3440 :         return( EmitErr( INVALID_INSTRUCTION_OPERANDS ) );
; 3441 :       }
; 3442 : #endif
; 3443 :   }
; 3444 :   else {
; 3445 :     if (CurrOpnd > 1) {

	cmp	ebx, 1
	jbe	$LN197@ParseLine

; 3446 :       /* v1.96: check if a third argument is ok */
; 3447 :       if (CurrOpnd > 2) {

	cmp	ebx, 2
	jbe	SHORT $LN28@ParseLine

; 3448 :         do {
; 3449 :           //if ( CodeInfo.pinstr->opnd_type_3rd != OP3_NONE )
; 3450 :           if ((opnd_clstab[CodeInfo.pinstr->opclsidx].opnd_type_3rd != OP3_NONE) ||

	movzx	eax, BYTE PTR [rcx]
	lea	r10, OFFSET FLAT:__ImageBase
	lea	rcx, QWORD PTR [rax+rax*2]
	cmp	BYTE PTR opnd_clstab[r10+rcx*4+8], 0
	jne	SHORT $LN190@ParseLine
	mov	eax, ebx
	imul	rcx, rax, 104				; 00000068H
	mov	edx, DWORD PTR opndx$[rbp+rcx-196]
	npad	4
$LL29@ParseLine:
	cmp	edx, 4
	je	SHORT $LN190@ParseLine

; 3453 :             break;
; 3454 :           }
; 3455 :           CodeInfo.pinstr++;           //work here for {sae}

	mov	rcx, QWORD PTR CodeInfo$[rsp+16]
	add	rcx, 14
	mov	QWORD PTR CodeInfo$[rsp+16], rcx

; 3456 :           if ((CodeInfo.pinstr->first == TRUE)) {

	cmp	BYTE PTR [rcx+4], 1
	je	SHORT $LN241@ParseLine

; 3448 :         do {
; 3449 :           //if ( CodeInfo.pinstr->opnd_type_3rd != OP3_NONE )
; 3450 :           if ((opnd_clstab[CodeInfo.pinstr->opclsidx].opnd_type_3rd != OP3_NONE) ||

	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rax+rax*2]
	cmp	BYTE PTR opnd_clstab[r10+rcx*4+8], 0
	je	SHORT $LL29@ParseLine
$LN190@ParseLine:

; 3451 :             (opndx[CurrOpnd].kind == EXPR_DECORATOR)){
; 3452 :             if (opndx[CurrOpnd].kind == EXPR_DECORATOR)CodeInfo.evex_sae = opndx[CurrOpnd].saeflags;

	mov	eax, ebx
	imul	rcx, rax, 104				; 00000068H
	cmp	DWORD PTR opndx$[rbp+rcx-196], 4
	jne	SHORT $LN28@ParseLine
	movzx	eax, BYTE PTR opndx$[rbp+rcx-186]
	mov	BYTE PTR CodeInfo$[rbp-115], al
$LN28@ParseLine:

; 3460 :           }
; 3461 :         } while (1);
; 3462 :       }
; 3463 :       /* v2.06: moved here from process_const() */
; 3464 :       if (CodeInfo.token == T_IMUL) {

	cmp	r8d, 620				; 0000026cH
	jne	$LN196@ParseLine

; 3465 :         /* the 2-operand form with an immediate as second op
; 3466 :          * is actually a 3-operand form. That's why the rm byte
; 3467 :          * has to be adjusted. */
; 3468 :         if (CodeInfo.opnd[OPND3].type == OP_NONE && (CodeInfo.opnd[OPND2].type & OP_I)) {

	cmp	DWORD PTR CodeInfo$[rbp-176], 0
	jne	SHORT $LN273@ParseLine
	test	DWORD PTR CodeInfo$[rsp+56], 917504	; 000e0000H
	je	$LN196@ParseLine

; 3469 : #if AMD64_SUPPORT
; 3470 :           CodeInfo.prefix.rex |= ((CodeInfo.prefix.rex & REX_B) ? REX_R : 0);

	movzx	ecx, BYTE PTR CodeInfo$[rsp+8]
	movzx	eax, cl
	and	al, 1
	shl	al, 2
	or	cl, al
	mov	BYTE PTR CodeInfo$[rsp+8], cl

; 3471 : #endif
; 3472 :           CodeInfo.rm_byte = (CodeInfo.rm_byte & ~BIT_345) | ((CodeInfo.rm_byte & BIT_012) << 3);

	movzx	ecx, BYTE PTR CodeInfo$[rbp-152]
	movzx	eax, cl
	shl	al, 3
	xor	al, cl
	and	al, 56					; 00000038H
	xor	cl, al
	mov	BYTE PTR CodeInfo$[rbp-152], cl

; 3473 :         }

	jmp	SHORT $LN196@ParseLine
$LN241@ParseLine:

; 3457 :             DebugMsg(("ParseLine(%s): no third operand expected\n", instr));
; 3458 :             for (; tokenarray[i].token != T_COMMA; i--);

	movsxd	rax, r9d
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	je	SHORT $LN31@ParseLine
$LL32@ParseLine:
	dec	r9d
	movsxd	rax, r9d
	shl	rax, 5
	mov	DWORD PTR i$[rbp-256], r9d
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	jne	SHORT $LL32@ParseLine
$LN31@ParseLine:

; 3459 :             return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos));

	movsxd	rdx, r9d
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	call	EmitErr
	jmp	$LN318@ParseLine
$LN273@ParseLine:

; 3474 :         else if ((CodeInfo.opnd[OPND3].type != OP_NONE) &&
; 3475 :           (CodeInfo.opnd[OPND2].type & OP_I) &&
; 3476 :           CodeInfo.opnd[OPND2].InsFixup &&

	mov	ecx, DWORD PTR CodeInfo$[rsp+56]
	test	ecx, 917504				; 000e0000H
	je	SHORT $LN196@ParseLine
	mov	rax, QWORD PTR CodeInfo$[rsp+72]
	test	rax, rax
	je	SHORT $LN196@ParseLine
	mov	rax, QWORD PTR [rax+56]
	cmp	DWORD PTR [rax+32], 0
	cmove	ecx, r13d
	mov	DWORD PTR CodeInfo$[rsp+56], ecx
$LN196@ParseLine:

; 3477 :           CodeInfo.opnd[OPND2].InsFixup->sym->state == SYM_UNDEFINED)
; 3478 :           CodeInfo.opnd[OPND2].type = OP_M;
; 3479 :       }
; 3480 :       if (check_size(&CodeInfo, opndx) == ERROR) {

	lea	rdx, QWORD PTR opndx$[rbp-256]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	check_size
	cmp	eax, -1
	jne	SHORT $LN309@ParseLine
$LN239@ParseLine:

; 3481 :         DebugMsg(("ParseLine(%s): check_size() failed, exit\n", instr));
; 3482 :         return(ERROR);

	or	eax, -1
	jmp	$LN318@ParseLine
$LN309@ParseLine:
	movzx	edx, BYTE PTR CodeInfo$[rbp-114]
	mov	r8d, DWORD PTR CodeInfo$[rsp+24]
$LN197@ParseLine:

; 3483 :       }
; 3484 :     }
; 3485 : #if AMD64_SUPPORT
; 3486 :     if (CodeInfo.Ofssize == USE64) {

	cmp	BYTE PTR CodeInfo$[rbp-150], 2
	jne	$LN203@ParseLine

; 3487 : 
; 3488 :       //if ( CodeInfo.x86hi_used && ( CodeInfo.x64lo_used || CodeInfo.prefix.rex & 7 ))
; 3489 :       if (CodeInfo.x86hi_used && CodeInfo.prefix.rex)

	movzx	ecx, BYTE PTR CodeInfo$[rsp+8]
	test	dl, 16
	je	SHORT $LN199@ParseLine
	test	cl, cl
	je	SHORT $LN199@ParseLine

; 3490 :         EmitError(INVALID_USAGE_OF_AHBHCHDH);

	mov	ecx, 254				; 000000feH
	call	EmitError
	mov	r8d, DWORD PTR CodeInfo$[rsp+24]
	movzx	ecx, BYTE PTR CodeInfo$[rsp+8]
$LN199@ParseLine:

; 3491 : 
; 3492 :       /* for some instructions, the "wide" flag has to be removed selectively.
; 3493 :        * this is to be improved - by a new flag in struct instr_item.
; 3494 :        */
; 3495 :       switch (CodeInfo.token) {

	cmp	r8d, 605				; 0000025dH
	jg	SHORT $LN210@ParseLine
	je	SHORT $LN202@ParseLine
	cmp	r8d, 454				; 000001c6H
	jl	SHORT $LN203@ParseLine
	cmp	r8d, 455				; 000001c7H
	jle	SHORT $LN201@ParseLine
	lea	eax, DWORD PTR [r8-600]
$LN326@ParseLine:
	cmp	eax, 1
	ja	SHORT $LN203@ParseLine
$LN201@ParseLine:

; 3496 :       case T_PUSH:
; 3497 :       case T_POP:
; 3498 :         /* v2.06: REX.W prefix is always 0, because size is either 2 or 8 */
; 3499 :         //if ( CodeInfo.opnd_type[OPND1] & OP_R64 )
; 3500 :         CodeInfo.prefix.rex &= 0x7;

	and	cl, 7
	mov	BYTE PTR CodeInfo$[rsp+8], cl

; 3501 :         break;

	jmp	SHORT $LN203@ParseLine
$LN202@ParseLine:

; 3515 :       case T_MOV:
; 3516 :         /* don't use the Wide bit for moves to/from special regs */
; 3517 :         if (CodeInfo.opnd[OPND1].type & OP_RSPEC || CodeInfo.opnd[OPND2].type & OP_RSPEC)

	test	DWORD PTR CodeInfo$[rsp+32], 4096	; 00001000H
	jne	SHORT $LN201@ParseLine
	test	DWORD PTR CodeInfo$[rsp+56], 4096	; 00001000H
	je	SHORT $LN203@ParseLine

; 3496 :       case T_PUSH:
; 3497 :       case T_POP:
; 3498 :         /* v2.06: REX.W prefix is always 0, because size is either 2 or 8 */
; 3499 :         //if ( CodeInfo.opnd_type[OPND1] & OP_R64 )
; 3500 :         CodeInfo.prefix.rex &= 0x7;

	and	cl, 7
	mov	BYTE PTR CodeInfo$[rsp+8], cl

; 3501 :         break;

	jmp	SHORT $LN203@ParseLine
$LN210@ParseLine:

; 3491 : 
; 3492 :       /* for some instructions, the "wide" flag has to be removed selectively.
; 3493 :        * this is to be improved - by a new flag in struct instr_item.
; 3494 :        */
; 3495 :       switch (CodeInfo.token) {

	lea	eax, DWORD PTR [r8-1291]

; 3502 :       case T_CALL:
; 3503 :       case T_JMP:
; 3504 : #if VMXSUPP /* v2.09: added */
; 3505 :       case T_VMREAD:
; 3506 :       case T_VMWRITE:
; 3507 : #endif
; 3508 :         /* v2.02: previously rex-prefix was cleared entirely,
; 3509 :          * but bits 0-2 are needed to make "call rax" and "call r8"
; 3510 :          * distinguishable!
; 3511 :          */
; 3512 :         //CodeInfo.prefix.rex = 0;
; 3513 :         CodeInfo.prefix.rex &= 0x7;
; 3514 :         break;

	jmp	SHORT $LN326@ParseLine
$LN186@ParseLine:

; 3413 :     }
; 3414 :   }
; 3415 :   /* special handling for string instructions */
; 3416 : 
; 3417 :   if (CodeInfo.pinstr->allowed_prefix == AP_REP ||
; 3418 :     CodeInfo.pinstr->allowed_prefix == AP_REPxx) {
; 3419 :     HandleStringInstructions(&CodeInfo, opndx);

	lea	rdx, QWORD PTR opndx$[rbp-256]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	HandleStringInstructions
$LN203@ParseLine:

; 3518 :           CodeInfo.prefix.rex &= 0x7;
; 3519 :         break;
; 3520 :       }
; 3521 :     }
; 3522 : #endif
; 3523 :   }
; 3524 :   /* now call the code generator */
; 3525 :   temp = codegen( &CodeInfo, oldofs );

	mov	edx, DWORD PTR oldofs$1$[rbp-256]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	codegen

; 3526 :   /* now reset EVEX maskflags for the next line */
; 3527 :   decoflags = 0;

	mov	BYTE PTR decoflags, 0

; 3528 :   broadflags = 0;

	mov	BYTE PTR broadflags, 0
$LN318@ParseLine:
	mov	r13, QWORD PTR [rsp+624]
	mov	r12, QWORD PTR [rsp+632]
	mov	r15, QWORD PTR [rsp+616]
$LN315@ParseLine:
	mov	rdi, QWORD PTR [rsp+640]

; 3529 :   return( temp );
; 3530 : }

	add	rsp, 648				; 00000288H
	pop	r14
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ParseLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
sym$ = 8
set_frame2 PROC

; 489  :     SetFixupFrame( SegOverride ? SegOverride : sym, TRUE );

	mov	rax, QWORD PTR SegOverride
	mov	dl, 1
	test	rax, rax
	cmovne	rcx, rax
	jmp	SetFixupFrame
set_frame2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
sym$ = 8
set_frame PROC

; 477  :     SetFixupFrame( SegOverride ? SegOverride : sym, FALSE );

	mov	rax, QWORD PTR SegOverride
	test	rax, rax
	cmovne	rcx, rax
	xor	edx, edx
	jmp	SetFixupFrame
set_frame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
opnd$ = 8
CodeInfo$ = 16
OperandSize PROC

; 287  : {

	mov	r9, rdx

; 288  :     /* v2.0: OP_M8_R8 and OP_M16_R16 have the DFT bit set! */
; 289  :     if( opnd == OP_NONE ) {

	test	ecx, ecx
	je	$LN26@OperandSiz

; 290  :         return( 0 );
; 291  :     } else if( opnd == OP_M ) {

	cmp	ecx, -1887436800			; ffffffff8f800000H
	jne	SHORT $LN4@OperandSiz

; 292  :         return( SizeFromMemtype( CodeInfo->mem_type, CodeInfo->Ofssize, NULL ) );

	movzx	edx, BYTE PTR [rdx+106]
	xor	r8d, r8d
	mov	ecx, DWORD PTR [r9+28]
	jmp	SizeFromMemtype
$LN4@OperandSiz:

; 293  :     } else if( opnd & ( OP_R8 | OP_M08 | OP_I8 ) ) {

	test	ecx, 8519681				; 00820001H
	je	SHORT $LN6@OperandSiz

; 294  :         return( 1 );

	mov	eax, 1

; 329  : }

	ret	0
$LN6@OperandSiz:

; 295  :     } else if( opnd & ( OP_R16 | OP_M16 | OP_I16 | OP_SR ) ) {

	test	ecx, 17063938				; 01046002H
	je	SHORT $LN8@OperandSiz

; 296  :         return( 2 );

	mov	eax, 2

; 329  : }

	ret	0
$LN8@OperandSiz:

; 297  :     } else if( opnd & ( OP_R32 | OP_M32 | OP_I32 ) ) {

	test	ecx, 34078724				; 02080004H
	je	SHORT $LN10@OperandSiz

; 298  :         return( 4 );

	mov	eax, 4

; 329  : }

	ret	0
$LN10@OperandSiz:

; 299  : #if AMD64_SUPPORT
; 300  :     } else if( opnd & ( OP_R64 | OP_M64 | OP_MMX | OP_I64 ) ) {

	test	ecx, 68157464				; 04100018H
	je	SHORT $LN12@OperandSiz
$LN28@OperandSiz:

; 301  : #else
; 302  :     } else if( opnd & ( OP_M64 | OP_MMX ) ) {
; 303  : #endif
; 304  :         return( 8 );

	mov	eax, 8

; 329  : }

	ret	0
$LN12@OperandSiz:

; 305  : //    } else if( opnd & ( OP_I | OP_I48 ) ) {
; 306  :     } else if( opnd & ( OP_I48 | OP_M48 ) ) {

	test	ecx, 1075838976				; 40200000H
	je	SHORT $LN14@OperandSiz

; 307  :         return( 6 );

	mov	eax, 6

; 329  : }

	ret	0
$LN14@OperandSiz:

; 308  :     } else if( opnd & ( OP_STI | OP_M80 ) ) {

	test	ecx, -2147385344			; ffffffff80018000H
	je	SHORT $LN16@OperandSiz

; 309  :         return( 10 );

	mov	eax, 10

; 329  : }

	ret	0
$LN16@OperandSiz:

; 310  :     } else if( opnd & ( OP_XMM | OP_M128 ) ) {

	test	ecx, 134217760				; 08000020H
	je	SHORT $LN18@OperandSiz

; 311  :         return( 16 );

	mov	eax, 16

; 329  : }

	ret	0
$LN18@OperandSiz:

; 312  : #if AVXSUPP
; 313  :     }else if (opnd & (OP_K | OP_M64)) {

	test	ecx, 67108928				; 04000040H
	jne	SHORT $LN28@OperandSiz

; 314  :       return(8);
; 315  :     }else if (opnd & (OP_YMM | OP_M256)) {

	test	ecx, 268435584				; 10000080H
	je	SHORT $LN22@OperandSiz

; 316  :         return( 32 );

	mov	eax, 32					; 00000020H

; 329  : }

	ret	0
$LN22@OperandSiz:

; 317  :     }else if (opnd & (OP_ZMM | OP_M512)) {

	test	ecx, 536871168				; 20000100H
	je	SHORT $LN24@OperandSiz

; 318  :       return(64);

	mov	eax, 64					; 00000040H

; 329  : }

	ret	0
$LN24@OperandSiz:

; 319  : #endif
; 320  :     } else if( opnd & OP_RSPEC ) {

	bt	ecx, 12
	jae	SHORT $LN26@OperandSiz

; 321  : #if AMD64_SUPPORT
; 322  :         return( ( CodeInfo->Ofssize == USE64 ) ? 8 : 4 );

	cmp	BYTE PTR [rdx+106], 2
	mov	eax, 8
	mov	ecx, 4
	cmove	ecx, eax
	mov	eax, ecx

; 329  : }

	ret	0
$LN26@OperandSiz:

; 323  : #else
; 324  :         return( 4 );
; 325  : #endif
; 326  :     }
; 327  :     DebugMsg1(("OperandSize: unhandled operand type %Xh!!!\n", opnd ));
; 328  :     return( 0 );

	xor	eax, eax

; 329  : }

	ret	0
OperandSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
sym$ = 48
sym_ext2int PROC

; 150  : {

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H

; 151  :     /* v2.07: GlobalQueue has been removed */
; 152  :     if ( sym->isproc == FALSE && sym->ispublic == FALSE ) {

	test	BYTE PTR [rcx+41], 8
	mov	rbx, rcx
	jne	SHORT $LN2@sym_ext2in
	movzx	eax, BYTE PTR [rcx+40]
	test	al, al
	js	SHORT $LN2@sym_ext2in

; 153  :         sym->ispublic = TRUE;

	or	al, 128					; 00000080H
	mov	BYTE PTR [rcx+40], al

; 154  :         AddPublicData( sym );

	call	AddPublicData
$LN2@sym_ext2in:

; 155  :     }
; 156  :     sym_remove_table( &SymTables[TAB_EXT], (struct dsym *)sym );

	mov	rcx, QWORD PTR [rbx+112]
	test	rcx, rcx
	je	SHORT $LN6@sym_ext2in
	mov	rax, QWORD PTR [rbx+104]
	mov	QWORD PTR [rcx+104], rax
$LN6@sym_ext2in:
	mov	rcx, QWORD PTR [rbx+104]
	test	rcx, rcx
	je	SHORT $LN7@sym_ext2in
	mov	rax, QWORD PTR [rbx+112]
	mov	QWORD PTR [rcx+112], rax
$LN7@sym_ext2in:
	cmp	QWORD PTR SymTables+16, rbx
	jne	SHORT $LN8@sym_ext2in
	mov	rax, QWORD PTR [rbx+104]
	mov	QWORD PTR SymTables+16, rax
$LN8@sym_ext2in:
	cmp	QWORD PTR SymTables+24, rbx
	jne	SHORT $LN9@sym_ext2in
	mov	rax, QWORD PTR [rbx+112]
	mov	QWORD PTR SymTables+24, rax
$LN9@sym_ext2in:
	xor	eax, eax

; 159  :     sym->state = SYM_INTERNAL;

	mov	DWORD PTR [rbx+32], 1
	test	BYTE PTR [rbx+41], 8
	mov	QWORD PTR [rbx+104], rax
	mov	QWORD PTR [rbx+112], rax
	jne	SHORT $LN3@sym_ext2in

; 157  :     if ( sym->isproc == FALSE ) /* v2.01: don't clear flags for PROTO */
; 158  :         sym->first_size = 0;

	mov	DWORD PTR [rbx+44], eax
$LN3@sym_ext2in:

; 160  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
sym_ext2int ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
queue$ = 8
item$ = 16
sym_remove_table PROC

; 122  :     /* unlink the node */
; 123  :     if( item->prev )

	mov	r8, QWORD PTR [rdx+112]
	test	r8, r8
	je	SHORT $LN2@sym_remove

; 124  :         item->prev->next = item->next;

	mov	rax, QWORD PTR [rdx+104]
	mov	QWORD PTR [r8+104], rax
$LN2@sym_remove:

; 125  :     if( item->next )

	mov	r8, QWORD PTR [rdx+104]
	test	r8, r8
	je	SHORT $LN3@sym_remove

; 126  :         item->next->prev = item->prev;

	mov	rax, QWORD PTR [rdx+112]
	mov	QWORD PTR [r8+112], rax
$LN3@sym_remove:

; 127  : 
; 128  :     //if ( dir->next == NULL )
; 129  :     //    dir->next = dir->prev;
; 130  : 
; 131  :     if ( queue->head == item )

	cmp	QWORD PTR [rcx], rdx
	jne	SHORT $LN4@sym_remove

; 132  :         queue->head = item->next;

	mov	rax, QWORD PTR [rdx+104]
	mov	QWORD PTR [rcx], rax
$LN4@sym_remove:

; 133  :     if ( queue->tail == item )

	cmp	QWORD PTR [rcx+8], rdx
	jne	SHORT $LN7@sym_remove

; 134  :         queue->tail = item->prev;

	mov	rax, QWORD PTR [rdx+112]
	mov	QWORD PTR [rcx+8], rax
$LN7@sym_remove:

; 135  : 
; 136  :     item->next = NULL;

	xor	eax, eax

; 137  :     item->prev = NULL;

	mov	QWORD PTR [rdx+112], rax
	mov	QWORD PTR [rdx+104], rax

; 138  : }

	ret	0
sym_remove_table ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
queue$ = 8
item$ = 16
sym_add_table PROC

; 100  : #ifdef DEBUG_OUT
; 101  :     if ( queue == &SymTables[TAB_UNDEF] )
; 102  :         item->sym.fwdref = TRUE;
; 103  : #endif
; 104  :     if( queue->head == NULL ) {

	cmp	QWORD PTR [rcx], 0
	jne	SHORT $LN2@sym_add_ta

; 105  :         queue->head = queue->tail = item;
; 106  :         item->next = item->prev = NULL;

	xor	eax, eax
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rdx+112], rax

; 110  :         queue->tail = item;
; 111  :         item->next = NULL;

	mov	QWORD PTR [rdx+104], rax

; 112  :     }
; 113  : }

	ret	0
$LN2@sym_add_ta:

; 107  :     } else {
; 108  :         item->prev = queue->tail;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+112], rax

; 109  :         queue->tail->next = item;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+104], rdx

; 110  :         queue->tail = item;
; 111  :         item->next = NULL;

	xor	eax, eax
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rdx+104], rax

; 112  :     }
; 113  : }

	ret	0
sym_add_table ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
i$ = 8
tokenarray$ = 16
plang$ = 24
GetLangType PROC

; 165  :     if( tokenarray[*i].token == T_RES_ID ) {

	movsxd	r9, DWORD PTR [rcx]
	shl	r9, 5
	cmp	BYTE PTR [r9+rdx], 7
	jne	SHORT $LN3@GetLangTyp
	mov	eax, DWORD PTR [r9+rdx+16]
	sub	eax, 264				; 00000108H
	cmp	eax, 6
	ja	SHORT $LN3@GetLangTyp

; 166  : #if 1 /* v2.03: simplified */
; 167  :         if ( tokenarray[(*i)].tokval >= T_C &&
; 168  :             tokenarray[(*i)].tokval <= T_FASTCALL ) {
; 169  :             *plang = tokenarray[(*i)].bytval;

	movzx	eax, BYTE PTR [r9+rdx+1]
	mov	DWORD PTR [r8], eax

; 170  :             (*i)++;

	inc	DWORD PTR [rcx]

; 171  :             return( NOT_ERROR );

	xor	eax, eax

; 190  : }

	ret	0
$LN3@GetLangTyp:

; 172  :         }
; 173  : #else
; 174  :         switch( tokenarray[(*i)].tokval ) {
; 175  :         case T_C:        *plang = LANG_C;        break;
; 176  :         case T_SYSCALL:  *plang = LANG_SYSCALL;  break;
; 177  :         case T_STDCALL:  *plang = LANG_STDCALL;  break;
; 178  :         case T_PASCAL:   *plang = LANG_PASCAL;   break;
; 179  :         case T_FORTRAN:  *plang = LANG_FORTRAN;  break;
; 180  :         case T_BASIC:    *plang = LANG_BASIC;    break;
; 181  :         case T_FASTCALL: *plang = LANG_FASTCALL; break;
; 182  :         default:
; 183  :             return( ERROR );
; 184  :         }
; 185  :         (*i)++;
; 186  :         return( NOT_ERROR );
; 187  : #endif
; 188  :     }
; 189  :     return( ERROR );

	or	eax, -1

; 190  : }

	ret	0
GetLangType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
registertoken$ = 8
SizeFromRegister PROC

; 199  : {

	lea	eax, DWORD PTR [rcx-56]
	cmp	eax, 7
	jbe	SHORT $LN4@SizeFromRe
	lea	eax, DWORD PTR [rcx-156]
	cmp	eax, 23
	jbe	SHORT $LN4@SizeFromRe
	lea	eax, DWORD PTR [rcx-64]
	cmp	eax, 7
	jbe	SHORT $LN8@SizeFromRe
	lea	eax, DWORD PTR [rcx-180]
	cmp	eax, 23
	jbe	SHORT $LN8@SizeFromRe

; 207  :     else
; 208  :       flags = GetSflagsSp( registertoken ) & SFR_SIZMSK;

	movsxd	rax, ecx
	lea	rdx, OFFSET FLAT:SpecialTable
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rcx, QWORD PTR [rcx*4]
	mov	eax, DWORD PTR [rcx+rdx+4]
	and	eax, 31
	jmp	SHORT $LN7@SizeFromRe
$LN8@SizeFromRe:

; 204  :     else if (((registertoken >= T_ZMM0) && (registertoken <= T_ZMM7 ))||
; 205  :       ((registertoken >= T_ZMM8) && (registertoken <= T_ZMM31 )))
; 206  :       flags = GetSflagsSp( registertoken ) & SFR_ZMMMASK ;

	movsxd	rax, ecx
	lea	rdx, OFFSET FLAT:SpecialTable
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rcx, QWORD PTR [rcx*4]
	mov	eax, DWORD PTR [rcx+rdx+4]
	and	eax, 127				; 0000007fH
	jmp	SHORT $LN7@SizeFromRe
$LN4@SizeFromRe:

; 200  :     unsigned flags;
; 201  :     if (((registertoken >= T_YMM0) && (registertoken <= T_YMM7 ))||
; 202  :       ((registertoken >= T_YMM8) && (registertoken <= T_YMM31 )))
; 203  :       flags = GetSflagsSp( registertoken ) & SFR_YMMMASK ;

	movsxd	rax, ecx
	lea	rdx, OFFSET FLAT:SpecialTable
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rcx, QWORD PTR [rcx*4]
	mov	eax, DWORD PTR [rcx+rdx+4]
	and	eax, 63					; 0000003fH
$LN7@SizeFromRe:

; 209  : 
; 210  :     if ( flags )

	test	eax, eax
	jne	SHORT $LN1@SizeFromRe

; 211  :         return( flags );
; 212  : 
; 213  :     flags = GetValueSp( registertoken );
; 214  :     if ( flags & OP_SR )

	test	DWORD PTR [rcx+rdx], 24576		; 00006000H
	je	SHORT $LN11@SizeFromRe

; 215  :         return( CurrWordSize );

	movzx	eax, BYTE PTR ModuleInfo+406

; 220  : #else
; 221  :     return( 4 );
; 222  : #endif
; 223  : }

	ret	0
$LN11@SizeFromRe:

; 216  : 
; 217  :     /* CRx, DRx, TRx remaining */
; 218  : #if AMD64_SUPPORT
; 219  :     return( ModuleInfo.Ofssize == USE64 ? 8 : 4 );

	cmp	BYTE PTR ModuleInfo+404, 2
	mov	eax, 4
	mov	ecx, 8
	cmove	eax, ecx
$LN1@SizeFromRe:

; 220  : #else
; 221  :     return( 4 );
; 222  : #endif
; 223  : }

	ret	0
SizeFromRegister ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
size$ = 8
ptype$ = 16
MemtypeFromSize PROC

; 272  :     int i;
; 273  :     for ( i = T_BYTE; SpecialTable[i].type == RWT_STYPE; i++ ) {

	cmp	BYTE PTR SpecialTable+2471, 6
	jne	SHORT $LN13@MemtypeFro
	mov	eax, 2460				; 0000099cH
	lea	r10, OFFSET FLAT:SpecialTable
	mov	r9d, 205				; 000000cdH
	npad	5
$LL4@MemtypeFro:

; 274  :         if( ( SpecialTable[i].bytval & MT_SPECIAL ) == 0 ) {

	movzx	r8d, BYTE PTR [rax+r10+10]
	test	r8b, r8b
	js	SHORT $LN2@MemtypeFro

; 275  :             /* the size is encoded 0-based in field mem_type */
; 276  :             if( ( ( SpecialTable[i].bytval & MT_SIZE_MASK) + 1 ) == size ) {

	movzx	eax, r8b
	and	eax, 31
	inc	eax
	cmp	eax, ecx
	je	SHORT $LN9@MemtypeFro
$LN2@MemtypeFro:

; 272  :     int i;
; 273  :     for ( i = T_BYTE; SpecialTable[i].type == RWT_STYPE; i++ ) {

	inc	r9
	lea	rax, QWORD PTR [r9+r9*2]
	lea	rax, QWORD PTR [rax*4]
	cmp	BYTE PTR [rax+r10+11], 6
	je	SHORT $LL4@MemtypeFro
$LN13@MemtypeFro:

; 279  :             }
; 280  :         }
; 281  :     }
; 282  :     return( ERROR );

	or	eax, -1

; 283  : }

	ret	0
$LN9@MemtypeFro:

; 277  :                 *ptype = SpecialTable[i].bytval;

	movzx	eax, r8b
	mov	DWORD PTR [rdx], eax

; 278  :                 return( NOT_ERROR );

	xor	eax, eax

; 283  : }

	ret	0
MemtypeFromSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
mem_type$ = 8
Ofssize$ = 16
type$ = 24
SizeFromMemtype PROC

; 236  :     if ( ( mem_type & MT_SPECIAL) == 0 )

	test	cl, cl
	js	SHORT $LN4@SizeFromMe

; 237  :         return ( (mem_type & MT_SIZE_MASK) + 1 );

	and	ecx, 31
	lea	eax, DWORD PTR [rcx+1]

; 264  :     }
; 265  : }

	ret	0
$LN4@SizeFromMe:

; 238  : 
; 239  :     if ( Ofssize == USE_EMPTY )

	cmp	edx, 254				; 000000feH
	jne	SHORT $LN5@SizeFromMe

; 240  :         Ofssize = ModuleInfo.Ofssize;

	movzx	edx, BYTE PTR ModuleInfo+404
$LN5@SizeFromMe:

; 241  : 
; 242  :     switch ( mem_type ) {

	sub	ecx, 128				; 00000080H
	je	SHORT $LN8@SizeFromMe
	sub	ecx, 1
	je	SHORT $LN6@SizeFromMe
	sub	ecx, 1
	je	SHORT $LN7@SizeFromMe
	sub	ecx, 65					; 00000041H
	je	SHORT $LN9@SizeFromMe
	cmp	ecx, 1
	jne	SHORT $LN11@SizeFromMe

; 257  :     case MT_TYPE:
; 258  :         if ( type )

	test	r8, r8
	je	SHORT $LN11@SizeFromMe

; 259  : 
; 260  : return( type->total_size );

	mov	eax, DWORD PTR [r8+56]

; 264  :     }
; 265  : }

	ret	0
$LN11@SizeFromMe:

; 261  :     default:
; 262  :         DebugMsg1(("SizeFromMemtype( memtype=%Xh, Ofssize=%u )=%u\n", mem_type, Ofssize, 0 ));
; 263  :         return( 0 );

	xor	eax, eax

; 264  :     }
; 265  : }

	ret	0
$LN9@SizeFromMe:

; 254  :     case MT_PTR:
; 255  :         DebugMsg1(("SizeFromMemtype( MT_PTR, Ofssize=%u )=%u\n", Ofssize, ( 2 << Ofssize ) + ( ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) ) ? 2 : 0 ) ));
; 256  :         return( ( 2 << Ofssize ) + ( ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) ) ? 2 : 0 ) );

	mov	ecx, DWORD PTR ModuleInfo+360
	mov	eax, 1
	shl	eax, cl
	mov	ecx, edx
	and	al, 104					; 00000068H
	mov	edx, 2
	neg	al
	sbb	eax, eax
	shl	edx, cl
	and	eax, 2
	add	eax, edx

; 264  :     }
; 265  : }

	ret	0
$LN7@SizeFromMe:

; 246  :     case MT_FAR:
; 247  :         DebugMsg1(("SizeFromMemtype( MT_FAR, Ofssize=%u )=%u\n", Ofssize, ( 2 << Ofssize ) + 2 ));
; 248  :         return ( ( 2 << Ofssize ) + 2 );

	mov	ecx, edx
	mov	eax, 2
	shl	eax, cl
	add	eax, 2

; 264  :     }
; 265  : }

	ret	0
$LN6@SizeFromMe:

; 243  :     case MT_NEAR:
; 244  :         DebugMsg1(("SizeFromMemtype( MT_NEAR, Ofssize=%u )=%u\n", Ofssize, 2 << Ofssize ));
; 245  :         return ( 2 << Ofssize );

	mov	ecx, edx
	mov	eax, 2
	shl	eax, cl

; 264  :     }
; 265  : }

	ret	0
$LN8@SizeFromMe:

; 249  :     case MT_PROC:
; 250  :         DebugMsg1(("SizeFromMemtype( MT_PROC, Ofssize=%u, type=%s )=%u\n", Ofssize, type->name, ( 2 << Ofssize ) + ( type->isfar ? 2 : 0 ) ));
; 251  :         /* v2.09: use type->isfar setting */
; 252  :         //return( ( 2 << Ofssize ) + ( ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) ? 2 : 0 ) );
; 253  :         return( ( 2 << Ofssize ) + ( type->isfar ? 2 : 0 ) );

	movzx	eax, BYTE PTR [r8+47]
	mov	ecx, edx
	shr	eax, 3
	mov	edx, 2
	and	eax, 2
	shl	edx, cl
	add	eax, edx

; 264  :     }
; 265  : }

	ret	0
SizeFromMemtype ENDP
_TEXT	ENDS
END
