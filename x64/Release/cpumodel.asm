; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	ModelToken
PUBLIC	coff64_fmtopt
PUBLIC	elf64_fmtopt
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	sym_Interface:QWORD
COMM	sym_Cpu:QWORD
_DATA	ENDS
_DATA	SEGMENT
$SG11092 DB	'TINY', 00H
	ORG $+3
$SG11093 DB	'SMALL', 00H
	ORG $+2
$SG11094 DB	'COMPACT', 00H
$SG11095 DB	'MEDIUM', 00H
	ORG $+1
$SG11096 DB	'LARGE', 00H
	ORG $+2
$SG11097 DB	'HUGE', 00H
	ORG $+3
$SG11098 DB	'FLAT', 00H
	ORG $+3
$SG11103 DB	'NEARSTACK', 00H
	ORG $+6
$SG11104 DB	'FARSTACK', 00H
	ORG $+3
$SG11105 DB	'OS_OS2', 00H
	ORG $+1
$SG11106 DB	'OS_DOS', 00H
	ORG $+5
$SG11160 DB	'@CodeSize', 00H
	ORG $+2
$SG11161 DB	'@code', 00H
	ORG $+6
$SG11165 DB	'@DataSize', 00H
	ORG $+2
$SG11166 DB	'FLAT', 00H
	ORG $+3
$SG11167 DB	'@data', 00H
	ORG $+2
$SG11169 DB	'STACK', 00H
	ORG $+2
$SG11170 DB	'@stack', 00H
	ORG $+1
$SG11171 DB	'@Model', 00H
	ORG $+5
$SG11172 DB	'@Interface', 00H
	ORG $+5
$SG11174 DB	'@ReservedStack', 00H
	ORG $+1
$SG11250 DB	'@Cpu', 00H
_DATA	ENDS
CONST	SEGMENT
ModelToken DQ	FLAT:$SG11092
	DQ	FLAT:$SG11093
	DQ	FLAT:$SG11094
	DQ	FLAT:$SG11095
	DQ	FLAT:$SG11096
	DQ	FLAT:$SG11097
	DQ	FLAT:$SG11098
ModelAttr DQ	FLAT:$SG11103
	DQ	FLAT:$SG11104
	DQ	FLAT:$SG11105
	DQ	FLAT:$SG11106
ModelAttrValue DB 00H
	DB	02H
	DB	01H
	DB	02H
	DB	00H
	DB	04H
	DB	01H
	DB	04H
coff64_fmtopt DQ 0000000000000000H
	DW	0e12H
	DB	'PE32+', 00H
elf64_fmtopt DQ	0000000000000000H
	DW	0f00H
	DB	'ELF64', 00H
CONST	ENDS
PUBLIC	ModelDirective
PUBLIC	SetCPU
PUBLIC	CpuDirective
EXTRN	_stricmp:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	GetLangType:PROC
EXTRN	SetOfssize:PROC
EXTRN	DefineFlatGroup:PROC
EXTRN	SimGetSegName:PROC
EXTRN	ModelSimSegmInit:PROC
EXTRN	SetModelDefaultSegNames:PROC
EXTRN	ModelAssumeInit:PROC
EXTRN	CreateVariable:PROC
EXTRN	RunLineQueue:PROC
EXTRN	LstWriteSrcLine:PROC
EXTRN	AddPredefinedText:PROC
EXTRN	pe_create_PE_header:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SpecialTable:BYTE
EXTRN	sym_ReservedStack:QWORD
EXTRN	szDgroup:BYTE
EXTRN	__ImageBase:BYTE
_BSS	SEGMENT
sym_CodeSize DQ	01H DUP (?)
sym_DataSize DQ	01H DUP (?)
sym_Model DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$FindToken DD imagerel FindToken
	DD	imagerel FindToken+89
	DD	imagerel $unwind$FindToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AddPredefinedConstant DD imagerel AddPredefinedConstant
	DD	imagerel AddPredefinedConstant+23
	DD	imagerel $unwind$AddPredefinedConstant
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetModel DD imagerel SetModel
	DD	imagerel SetModel+522
	DD	imagerel $unwind$SetModel
pdata	ENDS
pdata	SEGMENT
$pdata$ModelDirective DD imagerel $LN75
	DD	imagerel $LN75+45
	DD	imagerel $unwind$ModelDirective
$pdata$0$ModelDirective DD imagerel $LN75+45
	DD	imagerel $LN75+88
	DD	imagerel $chain$0$ModelDirective
$pdata$4$ModelDirective DD imagerel $LN75+88
	DD	imagerel $LN75+178
	DD	imagerel $chain$4$ModelDirective
$pdata$8$ModelDirective DD imagerel $LN75+178
	DD	imagerel $LN75+558
	DD	imagerel $chain$8$ModelDirective
$pdata$9$ModelDirective DD imagerel $LN75+558
	DD	imagerel $LN75+579
	DD	imagerel $chain$9$ModelDirective
$pdata$11$ModelDirective DD imagerel $LN75+579
	DD	imagerel $LN75+740
	DD	imagerel $chain$11$ModelDirective
$pdata$SetCPU DD imagerel $LN44
	DD	imagerel $LN44+581
	DD	imagerel $unwind$SetCPU
pdata	ENDS
xdata	SEGMENT
$unwind$ModelDirective DD 020901H
	DD	050059209H
$chain$0$ModelDirective DD 020521H
	DD	096405H
	DD	imagerel $LN75
	DD	imagerel $LN75+45
	DD	imagerel $unwind$ModelDirective
$chain$4$ModelDirective DD 061121H
	DD	087411H
	DD	0d340aH
	DD	096400H
	DD	imagerel $LN75
	DD	imagerel $LN75+45
	DD	imagerel $unwind$ModelDirective
$chain$8$ModelDirective DD 084321H
	DD	04f443H
	DD	06d43eH
	DD	07c429H
	DD	05e405H
	DD	imagerel $LN75+88
	DD	imagerel $LN75+178
	DD	imagerel $chain$4$ModelDirective
$chain$9$ModelDirective DD 021H
	DD	imagerel $LN75+88
	DD	imagerel $LN75+178
	DD	imagerel $chain$4$ModelDirective
$chain$11$ModelDirective DD 0e0021H
	DD	04f400H
	DD	05e400H
	DD	06d400H
	DD	07c400H
	DD	087400H
	DD	096400H
	DD	0d3400H
	DD	imagerel $LN75
	DD	imagerel $LN75+45
	DD	imagerel $unwind$ModelDirective
$unwind$SetCPU DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetModel DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddPredefinedConstant DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FindToken DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cpumodel.c
_TEXT	SEGMENT
i$ = 8
tokenarray$ = 16
CpuDirective PROC

; 463  :     enum cpu_info newcpu;
; 464  : 
; 465  :     //newcpu = comp_opt( tokenarray[i].tokval );
; 466  :     newcpu = GetSflagsSp( tokenarray[i].tokval );

	movsxd	rax, ecx
	shl	rax, 5
	mov	eax, DWORD PTR [rax+rdx+16]
	lea	r8, QWORD PTR [rax+rax*2]
	lea	rax, OFFSET FLAT:SpecialTable+4
	mov	r9d, DWORD PTR [rax+r8*4]

; 467  : 
; 468  : #if DOT_XMMARG
; 469  :     .if ( tokenarray[i].tokval == T_DOT_XMM && tokenarray[i+1].token != T_FINAL ) {
; 470  :         struct expr opndx;
; 471  :         i++;
; 472  :         if ( EvalOperand( &i, Token_Count, &opndx, 0 ) == ERROR )
; 473  :             return( ERROR );
; 474  :         if ( opndx.kind != EXPR_CONST || opndx.value < 1 || opndx.value > 4 ) {
; 475  :             return( EmitConstError( &opndx ) );
; 476  :         }
; 477  :         newcpy &= ~P_SSEALL; 
; 478  :         switch ( opndx.value ) {
; 479  :         case 4: newcpy |= P_SSE4;
; 480  :         case 3: newcpy |= P_SSE3|P_SSSE3;
; 481  :         case 2: newcpy |= P_SSE2;
; 482  :         case 1: newcpy |= P_SSE1; break;
; 483  :         }
; 484  :     } else
; 485  : #endif
; 486  :     i++;

	lea	eax, DWORD PTR [rcx+1]

; 487  : 
; 488  :     if ( tokenarray[i].token != T_FINAL ) {

	cdqe
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 0
	je	SHORT $LN2@CpuDirecti

; 489  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rax+rdx+24]
	mov	ecx, 209				; 000000d1H
	jmp	EmitErr
$LN2@CpuDirecti:

; 490  :     }
; 491  : 
; 492  :     return( SetCPU( newcpu ) );

	mov	ecx, r9d
	jmp	SetCPU
CpuDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cpumodel.c
_TEXT	SEGMENT
newcpu$ = 48
SetCPU	PROC

; 369  : {

$LN44:
	sub	rsp, 40					; 00000028H

; 370  :     int temp;
; 371  : 
; 372  :     DebugMsg1(("SetCPU(%X) enter\n", newcpu ));
; 373  :     if ( newcpu == P_86 || ( newcpu & P_CPU_MASK ) ) {

	test	ecx, ecx
	je	SHORT $LN7@SetCPU
	test	cl, -16
	jne	SHORT $LN7@SetCPU

; 386  :             else if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < P_386 )

	mov	edx, DWORD PTR ModuleInfo+392
	jmp	SHORT $LN12@SetCPU
$LN7@SetCPU:

; 374  :         /* reset CPU and EXT bits */
; 375  :         ModuleInfo.curr_cpu &= ~( P_CPU_MASK | P_EXT_MASK | P_PM );

	mov	edx, DWORD PTR ModuleInfo+392

; 376  : 
; 377  :         /* set CPU bits */
; 378  :         ModuleInfo.curr_cpu |= newcpu & ( P_CPU_MASK | P_PM );

	mov	eax, ecx
	and	eax, 248				; 000000f8H
	and	edx, -65529				; ffffffffffff0007H
	or	edx, eax

; 379  : 
; 380  :         /* set default FPU bits if nothing is given and .NO87 not active */
; 381  :         if ( (ModuleInfo.curr_cpu & P_FPU_MASK) != P_NO87 &&

	mov	eax, edx
	mov	DWORD PTR ModuleInfo+392, edx
	and	al, 7
	cmp	al, 1
	je	SHORT $LN12@SetCPU
	test	cl, 7
	jne	SHORT $LN12@SetCPU

; 382  :             ( newcpu & P_FPU_MASK ) == 0 ) {
; 383  :             ModuleInfo.curr_cpu &= ~P_FPU_MASK;

	and	edx, -8

; 384  :             if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < P_286 )

	mov	r8d, edx
	and	r8d, 240				; 000000f0H
	cmp	r8d, 32					; 00000020H
	jge	SHORT $LN9@SetCPU

; 385  :                 ModuleInfo.curr_cpu |= P_87;

	or	edx, 2
	jmp	SHORT $LN40@SetCPU
$LN9@SetCPU:
	mov	eax, edx

; 387  :                 ModuleInfo.curr_cpu |= P_287;
; 388  :             else
; 389  :                 ModuleInfo.curr_cpu |= P_387;

	or	edx, 4
	or	eax, 3
	cmp	r8d, 48					; 00000030H
	cmovl	edx, eax
$LN40@SetCPU:
	mov	DWORD PTR ModuleInfo+392, edx
$LN12@SetCPU:

; 390  :         }
; 391  : 
; 392  :     }
; 393  :     if( newcpu & P_FPU_MASK ) {

	mov	eax, ecx
	and	eax, 7
	je	SHORT $LN13@SetCPU

; 394  :         ModuleInfo.curr_cpu &= ~P_FPU_MASK;

	and	edx, -8

; 395  :         ModuleInfo.curr_cpu |= (newcpu & P_FPU_MASK);

	or	edx, eax
	mov	DWORD PTR ModuleInfo+392, edx
$LN13@SetCPU:

; 396  :     }
; 397  : #if AMD64_SUPPORT
; 398  :     /* enable MMX, K3D, SSEx for 64bit cpus */
; 399  :     if ( ( newcpu & P_CPU_MASK ) == P_64 )

	mov	eax, ecx
	and	eax, 240				; 000000f0H
	cmp	al, 112					; 00000070H
	jne	SHORT $LN14@SetCPU

; 400  :         ModuleInfo.curr_cpu |= P_EXT_ALL;

	or	edx, 65280				; 0000ff00H
	mov	DWORD PTR ModuleInfo+392, edx
$LN14@SetCPU:

; 401  : #endif
; 402  :     if( newcpu & P_EXT_MASK ) {

	and	ecx, 65280				; 0000ff00H
	je	SHORT $LN15@SetCPU

; 403  :         ModuleInfo.curr_cpu &= ~P_EXT_MASK;

	mov	BYTE PTR ModuleInfo+393, 0

; 404  :         ModuleInfo.curr_cpu |= (newcpu & P_EXT_MASK);

	mov	edx, DWORD PTR ModuleInfo+392
	or	edx, ecx
	mov	DWORD PTR ModuleInfo+392, edx
$LN15@SetCPU:

; 405  :     }
; 406  : 
; 407  :     /* set the Masm compatible @Cpu value */
; 408  : 
; 409  :     temp = ModuleInfo.curr_cpu & P_CPU_MASK;

	mov	r8d, edx
	and	r8d, 240				; 000000f0H

; 410  :     switch ( temp ) {

	lea	eax, DWORD PTR [r8-16]
	cmp	eax, 96					; 00000060H
	ja	SHORT $LN22@SetCPU
	lea	r9, OFFSET FLAT:__ImageBase
	cdqe
	movzx	eax, BYTE PTR $LN37@SetCPU[r9+rax]
	mov	ecx, DWORD PTR $LN38@SetCPU[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN16@SetCPU:

; 411  :     case P_186: ModuleInfo.cpu = M_8086 | M_186; break;

	mov	ecx, 3
	jmp	SHORT $LN41@SetCPU
$LN17@SetCPU:

; 412  :     case P_286: ModuleInfo.cpu = M_8086 | M_186 | M_286; break;

	mov	ecx, 7
	jmp	SHORT $LN41@SetCPU
$LN18@SetCPU:

; 413  :     case P_386: ModuleInfo.cpu = M_8086 | M_186 | M_286 | M_386; break;

	mov	ecx, 15
	jmp	SHORT $LN41@SetCPU
$LN19@SetCPU:

; 414  :     case P_486: ModuleInfo.cpu = M_8086 | M_186 | M_286 | M_386 | M_486; break;

	mov	ecx, 31
	jmp	SHORT $LN41@SetCPU
$LN20@SetCPU:

; 415  :     case P_586: ModuleInfo.cpu = M_8086 | M_186 | M_286 | M_386 | M_486 | M_586; break;

	mov	ecx, 63					; 0000003fH
	jmp	SHORT $LN41@SetCPU
$LN21@SetCPU:

; 416  :     /* Masm's .686 directive doesn't set the Pentium flag! A bug? */
; 417  :     //case P_686: ModuleInfo.cpu = M_8086 | M_186 | M_286 | M_386 | M_486 | M_586 | M_686; break;
; 418  : #if AMD64_SUPPORT
; 419  :     case P_64:
; 420  : #endif
; 421  :     case P_686: ModuleInfo.cpu = M_8086 | M_186 | M_286 | M_386 | M_486 | M_686; break;

	mov	ecx, 95					; 0000005fH
	jmp	SHORT $LN41@SetCPU
$LN22@SetCPU:

; 422  :     default: ModuleInfo.cpu = M_8086; break;

	mov	ecx, 1
$LN41@SetCPU:
	mov	WORD PTR ModuleInfo+388, cx

; 423  :     }
; 424  :     if ( ModuleInfo.curr_cpu & P_PM )

	test	dl, 8
	je	SHORT $LN23@SetCPU

; 425  :         ModuleInfo.cpu = ModuleInfo.cpu | M_PROT;

	mov	eax, 128				; 00000080H
	or	cx, ax
	mov	WORD PTR ModuleInfo+388, cx
$LN23@SetCPU:

; 426  : 
; 427  :     temp = ModuleInfo.curr_cpu & P_FPU_MASK;

	and	edx, 7

; 428  :     switch (temp) {

	sub	edx, 2
	je	SHORT $LN24@SetCPU
	sub	edx, 1
	je	SHORT $LN25@SetCPU
	cmp	edx, 1
	jne	SHORT $LN4@SetCPU

; 431  :     case P_387: ModuleInfo.cpu = ModuleInfo.cpu | M_8087 | M_287 | M_387; break;

	mov	eax, 3328				; 00000d00H
	jmp	SHORT $LN42@SetCPU
$LN25@SetCPU:

; 430  :     case P_287: ModuleInfo.cpu = ModuleInfo.cpu | M_8087 | M_287; break;

	mov	eax, 1280				; 00000500H
	jmp	SHORT $LN42@SetCPU
$LN24@SetCPU:

; 429  :     case P_87:  ModuleInfo.cpu = ModuleInfo.cpu | M_8087;     break;

	mov	eax, 256				; 00000100H
$LN42@SetCPU:
	or	cx, ax
	mov	WORD PTR ModuleInfo+388, cx
$LN4@SetCPU:

; 432  :     }
; 433  : 
; 434  :     DebugMsg1(("SetCPU: ModuleInfo.curr_cpu=%X, @Cpu=%X\n", ModuleInfo.curr_cpu, ModuleInfo.cpu ));
; 435  : 
; 436  :     //MakeCPUConstant( newcpu );
; 437  :     if ( ModuleInfo.model == MODEL_NONE )

	cmp	DWORD PTR ModuleInfo+360, 0
	jne	SHORT $LN29@SetCPU

; 438  : #if AMD64_SUPPORT
; 439  :         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK) >= P_64 ) {

	cmp	r8d, 112				; 00000070H
	jl	SHORT $LN28@SetCPU

; 440  :             SetDefaultOfssize( USE64 );

	movzx	eax, BYTE PTR ModuleInfo+405
	mov	ecx, 2
	cmp	QWORD PTR ModuleInfo+432, 0
	cmove	eax, ecx
	mov	BYTE PTR ModuleInfo+405, al

; 441  :         } else

	jmp	SHORT $LN35@SetCPU
$LN28@SetCPU:

; 442  : #endif
; 443  :             SetDefaultOfssize( ((ModuleInfo.curr_cpu & P_CPU_MASK) >= P_386) ? USE32 : USE16 );

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN35@SetCPU
	cmp	r8d, 48					; 00000030H
	setge	BYTE PTR ModuleInfo+405
$LN35@SetCPU:
	call	SetOfssize
	movzx	ecx, WORD PTR ModuleInfo+388
$LN29@SetCPU:

; 444  : 
; 445  :     /* Set @Cpu */
; 446  :     /* differs from Codeinfo cpu setting */
; 447  : 
; 448  :     sym_Cpu = CreateVariable( "@Cpu", ModuleInfo.cpu );

	movsx	edx, cx
	lea	rcx, OFFSET FLAT:$SG11250
	call	CreateVariable
	mov	QWORD PTR sym_Cpu, rax

; 449  : 
; 450  :     return( NOT_ERROR );

	xor	eax, eax

; 451  : }

	add	rsp, 40					; 00000028H
	ret	0
	npad	1
$LN38@SetCPU:
	DD	$LN16@SetCPU
	DD	$LN17@SetCPU
	DD	$LN18@SetCPU
	DD	$LN19@SetCPU
	DD	$LN20@SetCPU
	DD	$LN21@SetCPU
	DD	$LN22@SetCPU
$LN37@SetCPU:
	DB	0
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
SetCPU	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cpumodel.c
_TEXT	SEGMENT
i$ = 96
tokenarray$ = 104
model$1$ = 112
ostype$ = 112
distance$ = 112
language$ = 120
ModelDirective PROC

; 249  : {

$LN75:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 80					; 00000050H

; 250  :     enum model_type model;
; 251  :     enum lang_type language;
; 252  :     enum dist_type distance;
; 253  :     enum os_type ostype;
; 254  :     int index;
; 255  :     uint_8 init;
; 256  :     uint_8 initv;
; 257  : 
; 258  :     DebugMsg1(("ModelDirective enter\n"));
; 259  :     /* v2.03: it may occur that "code" is defined BEFORE the MODEL
; 260  :      * directive (i.e. DB directives in AT-segments). For FASTPASS,
; 261  :      * this may have caused errors because contents of the ModuleInfo
; 262  :      * structure was saved before the .MODEL directive.
; 263  :      */
; 264  :     //if( Parse_Pass != PASS_1 ) {
; 265  :     if( Parse_Pass != PASS_1 && ModuleInfo.model != MODEL_NONE ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	rbp, rdx
	je	SHORT $LN8@ModelDirec
	cmp	DWORD PTR ModuleInfo+360, 0
	je	SHORT $LN8@ModelDirec

; 266  :         /* just set the model with SetModel() if pass is != 1.
; 267  :          * This won't set the language ( which can be modified by
; 268  :          * OPTION LANGUAGE directive ), but the language in ModuleInfo
; 269  :          * isn't needed anymore once pass one is done.
; 270  :          */
; 271  :         SetModel();

	call	SetModel

; 272  :         return( NOT_ERROR );

	xor	eax, eax

; 357  : }

	add	rsp, 80					; 00000050H
	pop	rbp
	ret	0
$LN8@ModelDirec:

; 273  :     }
; 274  : 
; 275  :     i++;

	inc	ecx
	mov	QWORD PTR [rsp+72], rsi

; 276  :     if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rsi, ecx
	shl	rsi, 5
	mov	DWORD PTR i$[rsp], ecx
	cmp	BYTE PTR [rsi+rdx], 0
	jne	SHORT $LN9@ModelDirec

; 277  :         return( EmitError( EXPECTED_MEMORY_MODEL ) );

	mov	ecx, 246				; 000000f6H
	call	EmitError
	mov	rsi, QWORD PTR [rsp+72]

; 357  : }

	add	rsp, 80					; 00000050H
	pop	rbp
	ret	0
$LN9@ModelDirec:

; 278  :     }
; 279  :     /* get the model argument */
; 280  :     index = FindToken( tokenarray[i].string_ptr, ModelToken, sizeof( ModelToken )/sizeof( ModelToken[0] ) );

	mov	rsi, QWORD PTR [rsi+rdx+8]
	mov	QWORD PTR [rsp+104], rbx
	xor	ebx, ebx
	mov	QWORD PTR [rsp+64], rdi
	lea	rdi, OFFSET FLAT:ModelToken
$LL34@ModelDirec:
	mov	rcx, QWORD PTR [rdi]
	mov	rdx, rsi
	call	_stricmp
	test	eax, eax
	je	SHORT $LN31@ModelDirec
	inc	ebx
	add	rdi, 8
	cmp	ebx, 7
	jl	SHORT $LL34@ModelDirec
$LN10@ModelDirec:

; 288  :     } else {
; 289  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbp+8]
	call	EmitErr
	jmp	$LN67@ModelDirec

; 278  :     }
; 279  :     /* get the model argument */
; 280  :     index = FindToken( tokenarray[i].string_ptr, ModelToken, sizeof( ModelToken )/sizeof( ModelToken[0] ) );

$LN31@ModelDirec:

; 281  :     if( index >= 0 ) {

	test	ebx, ebx
	js	SHORT $LN10@ModelDirec

; 282  :         if( ModuleInfo.model != MODEL_NONE ) {

	cmp	DWORD PTR ModuleInfo+360, 0
	mov	QWORD PTR [rsp+40], r14
	je	SHORT $LN12@ModelDirec

; 283  :             //if ( Parse_Pass == PASS_1 ) /* not needed, this code runs in pass one only */
; 284  :             EmitWarn( 2, MODEL_DECLARED_ALREADY );

	mov	edx, 95					; 0000005fH
	lea	ecx, QWORD PTR [rdx-93]
	call	EmitWarn
$LN12@ModelDirec:

; 285  :         }
; 286  :         model = index + 1; /* model is one-base ( 0 is MODEL_NONE ) */
; 287  :         i++;

	mov	ecx, DWORD PTR i$[rsp]
	lea	r8d, DWORD PTR [rbx+1]

; 290  :     }
; 291  : 
; 292  :     /* get the optional arguments: language, stack distance, os */
; 293  :     init = 0;
; 294  :     while ( i < ( Token_Count - 1 ) && tokenarray[i].token == T_COMMA ) {

	mov	edx, DWORD PTR ModuleInfo+496
	inc	ecx
	mov	QWORD PTR [rsp+56], r12
	xor	r14b, r14b
	mov	DWORD PTR model$1$[rsp], r8d

; 305  :                 case INIT_STACK:
; 306  :                     if ( model == MODEL_FLAT ) {

	mov	r12d, DWORD PTR ostype$[rsp]
	lea	eax, DWORD PTR [rdx-1]
	mov	QWORD PTR [rsp+48], r13
	mov	QWORD PTR [rsp+32], r15
	mov	r15d, DWORD PTR distance$[rsp]
	mov	DWORD PTR i$[rsp], ecx
	cmp	ecx, eax
	jge	$LN3@ModelDirec
	movsxd	r13, r8d
	npad	7
$LL2@ModelDirec:

; 290  :     }
; 291  : 
; 292  :     /* get the optional arguments: language, stack distance, os */
; 293  :     init = 0;
; 294  :     while ( i < ( Token_Count - 1 ) && tokenarray[i].token == T_COMMA ) {

	movsxd	rax, ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+rbp], 44			; 0000002cH
	jne	SHORT $LN64@ModelDirec

; 295  :         i++;

	inc	ecx

; 296  :         if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rax, ecx
	shl	rax, 5
	mov	DWORD PTR i$[rsp], ecx
	cmp	BYTE PTR [rax+rbp], 44			; 0000002cH
	je	$LN13@ModelDirec

; 297  :             if ( GetLangType( &i, tokenarray, &language ) == NOT_ERROR ) {

	lea	r8, QWORD PTR language$[rsp]
	mov	rdx, rbp
	lea	rcx, QWORD PTR i$[rsp]
	call	GetLangType
	test	eax, eax
	jne	SHORT $LN14@ModelDirec

; 298  :                 initv = INIT_LANG;
; 299  :             } else {

	mov	ecx, DWORD PTR i$[rsp]
	mov	al, 1
	jmp	$LN15@ModelDirec
$LN14@ModelDirec:

; 300  :                 index = FindToken( tokenarray[i].string_ptr, ModelAttr, sizeof( ModelAttr )/sizeof( ModelAttr[0] ) );

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rdi, OFFSET FLAT:ModelAttr
	shl	rax, 5
	xor	ebx, ebx
	mov	rsi, QWORD PTR [rax+rbp+8]
	npad	4
$LL40@ModelDirec:
	mov	rcx, QWORD PTR [rdi]
	mov	rdx, rsi
	call	_stricmp
	test	eax, eax
	je	SHORT $LN47@ModelDirec
	inc	rbx
	add	rdi, 8
	cmp	rbx, 4
	jl	SHORT $LL40@ModelDirec
$LN62@ModelDirec:

; 307  :                         return( EmitError( INVALID_MODEL_PARAM_FOR_FLAT ) );

	mov	ecx, DWORD PTR i$[rsp]
$LN64@ModelDirec:
	mov	r8d, DWORD PTR model$1$[rsp]
$LN3@ModelDirec:

; 323  :         }
; 324  :     }
; 325  :     /* everything parsed successfully? */
; 326  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+rbp], 0
	je	$LN21@ModelDirec

; 327  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rax+rbp+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN71@ModelDirec
$LN47@ModelDirec:

; 301  :                 if ( index < 0 )

	test	rbx, rbx
	js	SHORT $LN62@ModelDirec

; 302  :                     break;
; 303  :                 initv = ModelAttrValue[index].init;

	lea	r8, OFFSET FLAT:ModelAttrValue
	movzx	eax, BYTE PTR [r8+rbx*2+1]

; 304  :                 switch ( initv ) {

	cmp	al, 2
	je	SHORT $LN17@ModelDirec
	cmp	al, 4
	jne	SHORT $LN4@ModelDirec

; 310  :                     break;
; 311  :                 case INIT_OS:
; 312  :                     ostype = ModelAttrValue[index].value;

	movzx	r12d, BYTE PTR [r8+rbx*2]
	jmp	SHORT $LN4@ModelDirec
$LN17@ModelDirec:

; 305  :                 case INIT_STACK:
; 306  :                     if ( model == MODEL_FLAT ) {

	cmp	r13, 7
	je	SHORT $LN49@ModelDirec

; 308  :                     }
; 309  :                     distance = ModelAttrValue[index].value;

	movzx	r15d, BYTE PTR [r8+rbx*2]
$LN4@ModelDirec:

; 313  :                     break;
; 314  :                 }
; 315  :                 i++;

	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx
	mov	DWORD PTR i$[rsp], ecx
$LN15@ModelDirec:

; 316  :             }
; 317  :             /* attribute set already? */
; 318  :             if ( initv & init ) {

	test	al, r14b
	jne	SHORT $LN50@ModelDirec

; 320  :                 break;
; 321  :             }
; 322  :             init |= initv;

	mov	edx, DWORD PTR ModuleInfo+496
	or	r14b, al
$LN13@ModelDirec:

; 290  :     }
; 291  : 
; 292  :     /* get the optional arguments: language, stack distance, os */
; 293  :     init = 0;
; 294  :     while ( i < ( Token_Count - 1 ) && tokenarray[i].token == T_COMMA ) {

	lea	eax, DWORD PTR [rdx-1]
	cmp	ecx, eax
	jl	$LL2@ModelDirec
	jmp	SHORT $LN64@ModelDirec
$LN50@ModelDirec:

; 319  :                 i--;

	dec	ecx
	mov	DWORD PTR i$[rsp], ecx
	jmp	SHORT $LN64@ModelDirec
$LN49@ModelDirec:

; 307  :                         return( EmitError( INVALID_MODEL_PARAM_FOR_FLAT ) );

	mov	ecx, 200				; 000000c8H
$LN73@ModelDirec:
	call	EmitError
$LN71@ModelDirec:
	mov	r12, QWORD PTR [rsp+56]
	mov	r13, QWORD PTR [rsp+48]
	mov	r15, QWORD PTR [rsp+32]
	mov	r14, QWORD PTR [rsp+40]
$LN67@ModelDirec:
	mov	rbx, QWORD PTR [rsp+104]
	mov	rdi, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]

; 357  : }

	add	rsp, 80					; 00000050H
	pop	rbp
	ret	0
$LN21@ModelDirec:

; 328  :     }
; 329  : 
; 330  :     if ( model == MODEL_FLAT ) {

	cmp	r8d, 7
	jne	SHORT $LN6@ModelDirec

; 331  :         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK) < P_386 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jge	SHORT $LN23@ModelDirec

; 332  :             return( EmitError( INSTRUCTION_OR_REGISTER_NOT_ACCEPTED_IN_CURRENT_CPU_MODE ) );

	lea	ecx, QWORD PTR [r8+23]
	jmp	SHORT $LN73@ModelDirec
$LN23@ModelDirec:

; 333  :         }
; 334  : #if AMD64_SUPPORT
; 335  :         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_64 ) /* cpu 64-bit? */

	cmp	eax, 112				; 00000070H
	jl	SHORT $LN6@ModelDirec

; 336  :             switch ( Options.output_format ) {

	mov	ecx, DWORD PTR Options+144
	sub	ecx, 2
	je	SHORT $LN25@ModelDirec
	cmp	ecx, 1
	jne	SHORT $LN6@ModelDirec

; 338  :             case OFORMAT_ELF:  ModuleInfo.fmtopt = &elf64_fmtopt;  break;

	lea	rax, OFFSET FLAT:elf64_fmtopt
	jmp	SHORT $LN72@ModelDirec
$LN25@ModelDirec:

; 337  :             case OFORMAT_COFF: ModuleInfo.fmtopt = &coff64_fmtopt; break;

	lea	rax, OFFSET FLAT:coff64_fmtopt
$LN72@ModelDirec:
	mov	QWORD PTR ModuleInfo+344, rax
$LN6@ModelDirec:

; 339  :             };
; 340  : #endif
; 341  :         /* v2.11: define FLAT symbol is to early here, because defOfssize isn't set yet */
; 342  :         //DefineFlatGroup();
; 343  :     }
; 344  : 
; 345  :     ModuleInfo.model = model;
; 346  :     if ( init & INIT_LANG )

	mov	ecx, DWORD PTR ModuleInfo+364
	movzx	eax, r14b
	and	al, 1
	mov	DWORD PTR ModuleInfo+360, r8d

; 347  :         ModuleInfo.langtype = language;
; 348  :     if ( init & INIT_STACK )

	movzx	eax, r14b
	cmovne	ecx, DWORD PTR language$[rsp]
	and	al, 2

; 349  :         ModuleInfo.distance = distance;
; 350  :     if ( init & INIT_OS )

	mov	eax, DWORD PTR ModuleInfo+368
	mov	DWORD PTR ModuleInfo+364, ecx
	mov	ecx, DWORD PTR ModuleInfo+356
	cmovne	ecx, r15d
	and	r14b, 4
	mov	DWORD PTR ModuleInfo+356, ecx
	cmovne	eax, r12d
	mov	DWORD PTR ModuleInfo+368, eax

; 351  :         ModuleInfo.ostype = ostype;
; 352  : 
; 353  :     SetModelDefaultSegNames();

	call	SetModelDefaultSegNames

; 354  :     SetModel();

	call	SetModel

; 355  : 
; 356  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN71@ModelDirec
ModelDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cpumodel.c
;	COMDAT SetModel
_TEXT	SEGMENT
SetModel PROC						; COMDAT

; 134  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 135  :     int         value;
; 136  :     const char  *textvalue;
; 137  :     //struct asym     *sym;
; 138  : 
; 139  :     DebugMsg1(("SetModel() enter (model=%u)\n", ModuleInfo.model ));
; 140  :     /* if model is set, it disables OT_SEGMENT of -Zm switch */
; 141  :     if ( ModuleInfo.model == MODEL_FLAT ) {

	mov	ecx, DWORD PTR ModuleInfo+360
	xor	ebx, ebx
	lea	edi, QWORD PTR [rbx+2]
	cmp	ecx, 7
	jne	SHORT $LN4@SetModel

; 142  :         ModuleInfo.offsettype = OT_FLAT;
; 143  : #if AMD64_SUPPORT
; 144  :         SetDefaultOfssize( ((ModuleInfo.curr_cpu & P_CPU_MASK) >= P_64 ) ? USE64 : USE32 );

	cmp	QWORD PTR ModuleInfo+432, rbx
	mov	DWORD PTR ModuleInfo+384, 1
	jne	SHORT $LN21@SetModel
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 112				; 00000070H
	setge	al
	inc	al
	mov	BYTE PTR ModuleInfo+405, al
$LN21@SetModel:
	call	SetOfssize

; 145  :         /* v2.03: if cpu is x64 and language is fastcall,
; 146  :          * set fastcall type to win64.
; 147  :          * This is rather hackish, but currently there's no other possibility
; 148  :          * to enable the win64 ABI from the source.
; 149  :          */
; 150  :         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) == P_64 )

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	al, 112					; 00000070H
	jne	SHORT $LN8@SetModel

; 151  :             if ( ModuleInfo.langtype == LANG_FASTCALL ) {

	cmp	DWORD PTR ModuleInfo+364, 7
	jne	SHORT $LN8@SetModel

; 152  :                 if ( Options.output_format != OFORMAT_ELF ) {

	mov	eax, DWORD PTR ModuleInfo+376
	cmp	DWORD PTR Options+144, 3
	cmovne	eax, edi
	mov	DWORD PTR ModuleInfo+376, eax
$LN8@SetModel:

; 153  :                     DebugMsg(("SetModel: FASTCALL type set to WIN64\n"));
; 154  :                     ModuleInfo.fctype = FCT_WIN64;
; 155  :                 }
; 156  :             }
; 157  : #else
; 158  :         SetDefaultOfssize( USE32 );
; 159  : #endif
; 160  :         /* v2.11: define symbol FLAT - after default offset size has been set! */
; 161  :         DefineFlatGroup();

	call	DefineFlatGroup

; 162  :     } else

	mov	ecx, DWORD PTR ModuleInfo+360
	jmp	SHORT $LN5@SetModel
$LN4@SetModel:

; 163  :         ModuleInfo.offsettype = OT_GROUP;

	mov	DWORD PTR ModuleInfo+384, ebx
$LN5@SetModel:

; 164  : 
; 165  :     ModelSimSegmInit( ModuleInfo.model ); /* create segments in first pass */

	call	ModelSimSegmInit

; 166  :     ModelAssumeInit();

	call	ModelAssumeInit

; 167  : 
; 168  :     if ( ModuleInfo.list )

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN9@SetModel

; 169  :         LstWriteSrcLine();

	call	LstWriteSrcLine
$LN9@SetModel:

; 170  : 
; 171  :     RunLineQueue();

	call	RunLineQueue

; 172  : 
; 173  :     if ( Parse_Pass != PASS_1 )

	cmp	DWORD PTR Parse_Pass, ebx
	jne	$LN18@SetModel

; 174  :         return;
; 175  : 
; 176  :     /* Set @CodeSize */
; 177  :     if ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) {

	mov	ecx, DWORD PTR ModuleInfo+360
	mov	eax, 1
	shl	al, cl
	mov	edx, ebx
	test	al, 112					; 00000070H

; 178  :         value = 1;
; 179  :         /* v2.06: SimpleType[] is obsolete */
; 180  :         //SimpleType[ST_PROC].mem_type = MT_FAR;
; 181  :     } else {
; 182  :         value = 0;
; 183  :         // SimpleType[ST_PROC].mem_type = MT_NEAR; /* this is default */
; 184  :     }
; 185  :     sym_CodeSize = AddPredefinedConstant( "@CodeSize", value );

	lea	rcx, OFFSET FLAT:$SG11160
	setne	dl
	call	CreateVariable
	test	rax, rax
	je	SHORT $LN24@SetModel
	or	BYTE PTR [rax+40], 32			; 00000020H
$LN24@SetModel:

; 186  :     AddPredefinedText( "@code", SimGetSegName( SIM_CODE ) );

	xor	ecx, ecx
	mov	QWORD PTR sym_CodeSize, rax
	call	SimGetSegName
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11161
	call	AddPredefinedText

; 187  : 
; 188  :     /* Set @DataSize */
; 189  :     switch( ModuleInfo.model ) {

	mov	ecx, DWORD PTR ModuleInfo+360
	sub	ecx, 3
	je	SHORT $LN13@SetModel
	sub	ecx, edi
	je	SHORT $LN13@SetModel
	cmp	ecx, 1
	jne	SHORT $LN2@SetModel

; 193  :         break;
; 194  :     case MODEL_HUGE:
; 195  :         value = 2;

	mov	ebx, edi

; 196  :         break;

	jmp	SHORT $LN2@SetModel
$LN13@SetModel:

; 190  :     case MODEL_COMPACT:
; 191  :     case MODEL_LARGE:
; 192  :         value = 1;

	mov	ebx, 1
$LN2@SetModel:

; 197  :     default:
; 198  :         value = 0;
; 199  :         break;
; 200  :     }
; 201  :     sym_DataSize = AddPredefinedConstant( "@DataSize", value );

	mov	edx, ebx
	lea	rcx, OFFSET FLAT:$SG11165
	call	CreateVariable
	test	rax, rax
	je	SHORT $LN27@SetModel
	or	BYTE PTR [rax+40], 32			; 00000020H
$LN27@SetModel:

; 202  : 
; 203  :     textvalue = ( ModuleInfo.model == MODEL_FLAT ? "FLAT" : szDgroup );

	cmp	DWORD PTR ModuleInfo+360, 7
	lea	rbx, OFFSET FLAT:szDgroup
	mov	QWORD PTR sym_DataSize, rax

; 204  :     AddPredefinedText( "@data", textvalue );

	lea	rcx, OFFSET FLAT:$SG11167
	lea	rax, OFFSET FLAT:$SG11166
	cmove	rbx, rax
	mov	rdx, rbx
	call	AddPredefinedText

; 205  : 
; 206  :     if ( ModuleInfo.distance == STACK_FAR )

	cmp	DWORD PTR ModuleInfo+356, 1
	lea	rdx, OFFSET FLAT:$SG11169

; 207  :         textvalue = "STACK";
; 208  :     AddPredefinedText( "@stack", textvalue );

	lea	rcx, OFFSET FLAT:$SG11170
	cmovne	rdx, rbx
	call	AddPredefinedText

; 209  : 
; 210  : #if 0
; 211  :     AddPredefinedText( "@fardata", ( ModuleInfo.model == MODEL_FLAT ? "FLAT" : SimGetSegName( SIM_FARDATA ) ) );
; 212  :     AddPredefinedText( "@fardata?", ( ModuleInfo.model == MODEL_FLAT ? "FLAT" : SimGetSegName( SIM_FARDATA_UN ) ) );
; 213  : #endif
; 214  : 
; 215  :     /* Set @Model and @Interface */
; 216  : 
; 217  :     sym_Model     = AddPredefinedConstant( "@Model", ModuleInfo.model );

	mov	edx, DWORD PTR ModuleInfo+360
	lea	rcx, OFFSET FLAT:$SG11171
	call	CreateVariable
	test	rax, rax
	je	SHORT $LN30@SetModel
	or	BYTE PTR [rax+40], 32			; 00000020H
$LN30@SetModel:

; 218  :     sym_Interface = AddPredefinedConstant( "@Interface", ModuleInfo.langtype );

	mov	edx, DWORD PTR ModuleInfo+364
	lea	rcx, OFFSET FLAT:$SG11172
	mov	QWORD PTR sym_Model, rax
	call	CreateVariable
	test	rax, rax
	je	SHORT $LN33@SetModel
	or	BYTE PTR [rax+40], 32			; 00000020H
$LN33@SetModel:

; 219  : 
; 220  : #if AMD64_SUPPORT
; 221  :     if ( ModuleInfo.defOfssize == USE64 && ModuleInfo.fctype == FCT_WIN64 ) {

	cmp	BYTE PTR ModuleInfo+405, dil
	mov	QWORD PTR sym_Interface, rax
	jne	SHORT $LN17@SetModel
	cmp	DWORD PTR ModuleInfo+376, edi
	jne	SHORT $LN17@SetModel

; 222  :         sym_ReservedStack = AddPredefinedConstant( "@ReservedStack", 0 );

	xor	edx, edx
	lea	rcx, OFFSET FLAT:$SG11174
	call	CreateVariable
	test	rax, rax
	je	SHORT $LN36@SetModel
	or	BYTE PTR [rax+40], 32			; 00000020H
$LN36@SetModel:
	mov	QWORD PTR sym_ReservedStack, rax
$LN17@SetModel:

; 223  :     }
; 224  : #endif
; 225  : #if PE_SUPPORT
; 226  :     if ( ModuleInfo.sub_format == SFORMAT_PE )

	cmp	DWORD PTR ModuleInfo+372, edi
	jne	SHORT $LN18@SetModel

; 227  :         pe_create_PE_header();

	call	pe_create_PE_header
$LN18@SetModel:

; 228  : #endif
; 229  : 
; 230  : #ifdef DEBUG_OUT
; 231  :     if ( Options.dump_reswords )
; 232  :         DumpResWords();
; 233  : #endif
; 234  : 
; 235  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetModel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cpumodel.c
;	COMDAT SetDefaultOfssize
_TEXT	SEGMENT
size$ = 8
SetDefaultOfssize PROC					; COMDAT

; 110  :     /* outside any segments? */
; 111  :     if( CurrSeg == NULL ) {

	movzx	edx, BYTE PTR ModuleInfo+405
	cmp	QWORD PTR ModuleInfo+432, 0
	movzx	eax, cl
	cmove	edx, eax
	mov	BYTE PTR ModuleInfo+405, dl

; 112  :         ModuleInfo.defOfssize = size;
; 113  :     }
; 114  :     return( SetOfssize() );

	jmp	SetOfssize
SetDefaultOfssize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cpumodel.c
;	COMDAT AddPredefinedConstant
_TEXT	SEGMENT
name$ = 48
value$ = 56
AddPredefinedConstant PROC				; COMDAT

; 98   : {

	sub	rsp, 40					; 00000028H

; 99   :     struct asym *sym = CreateVariable( name, value );

	call	CreateVariable

; 100  :     if (sym)

	test	rax, rax
	je	SHORT $LN4@AddPredefi

; 101  :         sym->predefined = TRUE;

	or	BYTE PTR [rax+40], 32			; 00000020H
$LN4@AddPredefi:

; 102  :     return(sym);
; 103  : }

	add	rsp, 40					; 00000028H
	ret	0
AddPredefinedConstant ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cpumodel.c
;	COMDAT FindToken
_TEXT	SEGMENT
token$ = 48
table$ = 56
size$ = 64
FindToken PROC						; COMDAT

; 86   : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 87   :     int i;
; 88   :     for( i = 0; i < size; i++, table++ ) {

	xor	ebx, ebx
	mov	esi, r8d
	mov	rdi, rdx
	mov	rbp, rcx
	test	r8d, r8d
	jle	SHORT $LN3@FindToken
$LL4@FindToken:

; 89   :         if( _stricmp( *table, token ) == 0 ) {

	mov	rcx, QWORD PTR [rdi]
	mov	rdx, rbp
	call	_stricmp
	test	eax, eax
	je	SHORT $LN8@FindToken

; 87   :     int i;
; 88   :     for( i = 0; i < size; i++, table++ ) {

	inc	ebx
	add	rdi, 8
	cmp	ebx, esi
	jl	SHORT $LL4@FindToken
$LN3@FindToken:

; 91   :         }
; 92   :     }
; 93   :     return( -1 );  /* Not found */

	or	eax, -1
$LN1@FindToken:

; 94   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN8@FindToken:

; 90   :             return( i );

	mov	eax, ebx
	jmp	SHORT $LN1@FindToken
FindToken ENDP
_TEXT	ENDS
END
