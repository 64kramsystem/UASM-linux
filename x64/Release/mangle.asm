; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG10668 DB	'_%s@%d', 00H
	ORG $+1
$SG10675 DB	'@%s@%u', 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	sprintf
PUBLIC	Mangle
PUBLIC	SetMangler
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	_strupr:PROC
EXTRN	memcpy:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	__ImageBase:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN8
	DD	imagerel $LN8+90
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$ow_decorate DD imagerel ow_decorate
	DD	imagerel ow_decorate+149
	DD	imagerel $unwind$ow_decorate
$pdata$ms64_decorate DD imagerel ms64_decorate
	DD	imagerel ms64_decorate+43
	DD	imagerel $unwind$ms64_decorate
$pdata$VoidMangler DD imagerel VoidMangler
	DD	imagerel VoidMangler+43
	DD	imagerel $unwind$VoidMangler
$pdata$UCaseMangler DD imagerel UCaseMangler
	DD	imagerel UCaseMangler+60
	DD	imagerel $unwind$UCaseMangler
$pdata$UScoreMangler DD imagerel UScoreMangler
	DD	imagerel UScoreMangler+46
	DD	imagerel $unwind$UScoreMangler
$pdata$StdcallMangler DD imagerel StdcallMangler
	DD	imagerel StdcallMangler+96
	DD	imagerel $unwind$StdcallMangler
pdata	ENDS
CONST	SEGMENT
fcmanglers DQ	FLAT:ms32_decorate
	DQ	FLAT:ow_decorate
	DQ	FLAT:ms64_decorate
CONST	ENDS
xdata	SEGMENT
$unwind$ow_decorate DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$ms64_decorate DD 020601H
	DD	030023206H
$unwind$VoidMangler DD 020601H
	DD	030023206H
$unwind$UCaseMangler DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$UScoreMangler DD 020601H
	DD	030023206H
$unwind$StdcallMangler DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\mangle.c
_TEXT	SEGMENT
sym$ = 48
buffer$ = 56
StdcallMangler PROC

; 103  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 104  :     const struct dsym *dir = (struct dsym *)sym;
; 105  : 
; 106  :     if( Options.stdcall_decoration == STDCALL_FULL && sym->isproc ) {

	cmp	BYTE PTR Options+118, 0
	mov	r10, rdx
	mov	rbx, rcx
	jne	SHORT $LN2@StdcallMan
	test	BYTE PTR [rcx+41], 8
	je	SHORT $LN2@StdcallMan

; 107  :         return( sprintf( buffer, "_%s@%d", sym->name, dir->e.procinfo->parasize ) );

	mov	rax, QWORD PTR [rcx+96]
	lea	rdx, OFFSET FLAT:$SG10668
	mov	r8, QWORD PTR [rcx+8]
	mov	rcx, r10
	mov	r9d, DWORD PTR [rax+32]

; 110  :     }
; 111  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 107  :         return( sprintf( buffer, "_%s@%d", sym->name, dir->e.procinfo->parasize ) );

	jmp	sprintf
$LN2@StdcallMan:

; 108  :     } else {
; 109  :         return( UScoreMangler( sym, buffer ) );

	mov	BYTE PTR [rdx], 95			; 0000005fH
	movzx	eax, BYTE PTR [rcx+72]
	lea	rcx, QWORD PTR [rdx+1]
	mov	rdx, QWORD PTR [rbx+8]
	inc	eax
	movsxd	r8, eax
	call	memcpy
	movzx	eax, BYTE PTR [rbx+72]
	inc	eax

; 110  :     }
; 111  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
StdcallMangler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\mangle.c
_TEXT	SEGMENT
sym$ = 48
buffer$ = 56
UScoreMangler PROC

; 92   : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 93   :     buffer[0] = '_';

	mov	BYTE PTR [rdx], 95			; 0000005fH

; 94   :     memcpy( buffer+1, sym->name, sym->name_size + 1 );

	movzx	eax, BYTE PTR [rcx+72]
	lea	rcx, QWORD PTR [rdx+1]
	inc	eax
	movsxd	r8, eax
	mov	rdx, QWORD PTR [rbx+8]
	call	memcpy

; 95   :     return( sym->name_size + 1 );

	movzx	eax, BYTE PTR [rbx+72]
	inc	eax

; 96   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
UScoreMangler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\mangle.c
_TEXT	SEGMENT
sym$ = 48
buffer$ = 56
UCaseMangler PROC

; 82   : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 83   :     memcpy( buffer, sym->name, sym->name_size + 1 );

	movzx	eax, BYTE PTR [rcx+72]
	mov	rbx, rdx
	mov	rdx, QWORD PTR [rcx+8]
	inc	eax
	mov	rdi, rcx
	movsxd	r8, eax
	mov	rcx, rbx
	call	memcpy

; 84   :     _strupr( buffer );

	mov	rcx, rbx
	call	_strupr

; 85   :     return( sym->name_size );

	movzx	eax, BYTE PTR [rdi+72]

; 86   : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
UCaseMangler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\mangle.c
_TEXT	SEGMENT
sym$ = 48
buffer$ = 56
VoidMangler PROC

; 73   : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 74   :     memcpy( buffer, sym->name, sym->name_size + 1 );

	movzx	eax, BYTE PTR [rcx+72]
	mov	r9, rdx
	mov	rdx, QWORD PTR [rcx+8]
	inc	eax
	mov	rbx, rcx
	movsxd	r8, eax
	mov	rcx, r9
	call	memcpy

; 75   :     return( sym->name_size );

	movzx	eax, BYTE PTR [rbx+72]

; 76   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
VoidMangler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\mangle.c
_TEXT	SEGMENT
sym$ = 48
buffer$ = 56
ms64_decorate PROC

; 175  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 176  :     memcpy( buffer, sym->name, sym->name_size + 1 );

	movzx	eax, BYTE PTR [rcx+72]
	mov	r9, rdx
	mov	rdx, QWORD PTR [rcx+8]
	inc	eax
	mov	rbx, rcx
	movsxd	r8, eax
	mov	rcx, r9
	call	memcpy

; 177  :     return( sym->name_size );

	movzx	eax, BYTE PTR [rbx+72]

; 178  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ms64_decorate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\mangle.c
_TEXT	SEGMENT
sym$ = 48
buffer$ = 56
ow_decorate PROC

; 137  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 138  :     char                *name;
; 139  :     enum changes        changes = NORMAL;
; 140  : 
; 141  :     if( sym->isproc ) {

	test	BYTE PTR [rcx+41], 8
	mov	rsi, rdx
	mov	rbp, rcx
	jne	SHORT $LN6@ow_decorat

; 142  :         changes |= USCORE_BACK;
; 143  :     } else {
; 144  :         switch( sym->mem_type ) {

	mov	ecx, DWORD PTR [rcx+36]
	lea	eax, DWORD PTR [rcx-129]
	cmp	eax, 1
	jbe	SHORT $LN6@ow_decorat

; 149  :             break;
; 150  :         default:
; 151  :             changes |= USCORE_FRONT;

	mov	edi, 1
	cmp	ecx, 192				; 000000c0H
	jne	SHORT $LN2@ow_decorat
$LN6@ow_decorat:

; 145  :         case MT_NEAR:
; 146  :         case MT_FAR:
; 147  :         case MT_EMPTY:
; 148  :             changes |= USCORE_BACK;

	mov	edi, 2
$LN2@ow_decorat:

; 152  :         }
; 153  :     }
; 154  : 
; 155  :     name = buffer;

	mov	rbx, rdx

; 156  : 
; 157  :     if( changes & USCORE_FRONT )

	test	dil, 1
	je	SHORT $LN8@ow_decorat

; 158  :         *name++ = '_';

	mov	BYTE PTR [rdx], 95			; 0000005fH
	lea	rbx, QWORD PTR [rdx+1]
$LN8@ow_decorat:

; 159  :     memcpy( name, sym->name, sym->name_size + 1 );

	movzx	eax, BYTE PTR [rbp+72]
	mov	rcx, rbx
	mov	rdx, QWORD PTR [rbp+8]
	inc	eax
	movsxd	r8, eax
	call	memcpy

; 160  :     name += sym->name_size;

	movzx	ecx, BYTE PTR [rbp+72]
	add	rbx, rcx

; 161  :     if( changes & USCORE_BACK ) {

	test	dil, 2
	je	SHORT $LN9@ow_decorat

; 162  :         *name++ = '_';

	mov	BYTE PTR [rbx], 95			; 0000005fH
	inc	rbx

; 163  :         *name = NULLC;

	mov	BYTE PTR [rbx], 0
$LN9@ow_decorat:

; 164  :     }
; 165  :     return( name - buffer );
; 166  : }

	mov	rbp, QWORD PTR [rsp+56]
	sub	rbx, rsi
	mov	rsi, QWORD PTR [rsp+64]
	mov	eax, ebx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ow_decorate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\mangle.c
_TEXT	SEGMENT
sym$ = 8
buffer$ = 16
ms32_decorate PROC

; 118  :     return ( sprintf( buffer, "@%s@%u", sym->name, ((struct dsym *)sym)->e.procinfo->parasize ) );

	mov	rax, QWORD PTR [rcx+96]
	mov	r10, rdx
	mov	r8, QWORD PTR [rcx+8]
	lea	rdx, OFFSET FLAT:$SG10675
	mov	rcx, r10
	mov	r9d, DWORD PTR [rax+32]
	jmp	sprintf
ms32_decorate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\mangle.c
_TEXT	SEGMENT
sym$ = 8
langtype$ = 16
mangle_type$ = 24
SetMangler PROC

; 256  : #if MANGLERSUPP
; 257  :     mangle_func mangler;
; 258  : #endif
; 259  : 
; 260  :     if( langtype != LANG_NONE )

	test	edx, edx
	je	SHORT $LN2@SetMangler

; 261  :         sym->langtype = langtype;

	mov	DWORD PTR [rcx+76], edx
$LN2@SetMangler:

; 262  : 
; 263  : #if MANGLERSUPP
; 264  :     mangler = GetMangler( mangle_type );
; 265  :     if( mangler == NULL ) {
; 266  :         /* nothing to do */
; 267  :     } else if( sym->mangler == NULL ) {
; 268  :         sym->mangler = mangler;
; 269  :     } else if( sym->mangler != mangler ) {
; 270  :         EmitErr( CONFLICTING_MANGLER, sym->name );
; 271  :     }
; 272  : #endif
; 273  : }

	ret	0
SetMangler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\mangle.c
_TEXT	SEGMENT
sym$ = 8
buffer$ = 16
Mangle	PROC

; 213  :     mangle_func mangler;
; 214  : 
; 215  :     switch( sym->langtype ) {

	mov	eax, DWORD PTR [rcx+76]
	mov	r8, rcx
	dec	eax
	cmp	eax, 6
	ja	SHORT $LN9@Mangle
	cdqe
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN11@Mangle[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@Mangle:

; 216  :     case LANG_C:
; 217  :         /* leading underscore for C? */
; 218  :         mangler = Options.no_cdecl_decoration ? VoidMangler : UScoreMangler;

	cmp	BYTE PTR Options+117, 0
	lea	rcx, OFFSET FLAT:VoidMangler
	lea	rax, OFFSET FLAT:UScoreMangler
	cmovne	rax, rcx

; 242  :         break;
; 243  :     }
; 244  : #if MANGLERSUPP
; 245  :     sym->mangler = mangler;
; 246  : #endif
; 247  :     return( mangler( sym, buffer ) );

	mov	rcx, r8
	rex_jmp	rax
$LN6@Mangle:

; 219  :         break;
; 220  :     case LANG_SYSCALL:
; 221  :         mangler = VoidMangler;
; 222  :         break;
; 223  :     case LANG_STDCALL:
; 224  :         mangler = ( Options.stdcall_decoration == STDCALL_NONE ) ? VoidMangler : StdcallMangler;

	cmp	BYTE PTR Options+118, 1
	lea	rcx, OFFSET FLAT:VoidMangler
	lea	rax, OFFSET FLAT:StdcallMangler
	cmove	rax, rcx

; 242  :         break;
; 243  :     }
; 244  : #if MANGLERSUPP
; 245  :     sym->mangler = mangler;
; 246  : #endif
; 247  :     return( mangler( sym, buffer ) );

	mov	rcx, r8
	rex_jmp	rax
$LN7@Mangle:

; 225  :         break;
; 226  :     case LANG_PASCAL:
; 227  :     case LANG_FORTRAN:
; 228  :     case LANG_BASIC:
; 229  :         mangler = UCaseMangler;

	lea	rax, OFFSET FLAT:UCaseMangler

; 242  :         break;
; 243  :     }
; 244  : #if MANGLERSUPP
; 245  :     sym->mangler = mangler;
; 246  : #endif
; 247  :     return( mangler( sym, buffer ) );

	mov	rcx, r8
	rex_jmp	rax
$LN8@Mangle:

; 230  :         break;
; 231  :     case LANG_FASTCALL:          /* registers passing parameters */
; 232  :         mangler = fcmanglers[ModuleInfo.fctype];

	movsxd	rax, DWORD PTR ModuleInfo+376
	mov	rax, QWORD PTR fcmanglers[rcx+rax*8]

; 242  :         break;
; 243  :     }
; 244  : #if MANGLERSUPP
; 245  :     sym->mangler = mangler;
; 246  : #endif
; 247  :     return( mangler( sym, buffer ) );

	mov	rcx, r8
	rex_jmp	rax
$LN9@Mangle:

; 233  :         break;
; 234  :     default: /* LANG_NONE */
; 235  : #if MANGLERSUPP
; 236  :         mangler = sym->mangler;
; 237  :         if( mangler == NULL )
; 238  :             mangler = GetMangler( Options.default_name_mangler );
; 239  :         if( mangler == NULL )
; 240  : #endif
; 241  :             mangler = VoidMangler;

	lea	rax, OFFSET FLAT:VoidMangler

; 242  :         break;
; 243  :     }
; 244  : #if MANGLERSUPP
; 245  :     sym->mangler = mangler;
; 246  : #endif
; 247  :     return( mangler( sym, buffer ) );

	mov	rcx, r8
	rex_jmp	rax
	npad	1
$LN11@Mangle:

; 248  : }

	DD	$LN4@Mangle
	DD	$LN9@Mangle
	DD	$LN6@Mangle
	DD	$LN7@Mangle
	DD	$LN7@Mangle
	DD	$LN7@Mangle
	DD	$LN8@Mangle
Mangle	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rdi, rcx

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rbx
	mov	QWORD PTR [rsp+40], rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], 0
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf
	test	eax, eax
	cmovs	eax, ebx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbx
	mov	r9, rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, rbx
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf

; 1459 :     #pragma warning(pop)
; 1460 : }

	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ebx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_Locale$ = 88
_ArgList$ = 96
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR _ArgList$[rsp]
	or	rcx, 1
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rbx
	call	__stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;
; 1391 : }

	mov	rbx, QWORD PTR [rsp+64]
	or	ecx, -1
	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ecx
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
