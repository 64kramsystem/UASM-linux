; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG11733 DB	01H DUP (?)
	ALIGN	4

$SG11741 DB	01H DUP (?)
	ALIGN	4

$SG11744 DB	02H DUP (?)
	ALIGN	4

$SG11749 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11300 DB	0aH, 00H
	ORG $+2
$SG11303 DB	':', 0aH, 00H
	ORG $+1
$SG11333 DB	0aH, 00H
	ORG $+2
$SG11337 DB	'%s:', 0aH, 00H
	ORG $+3
$SG11338 DB	'%s:', 0aH, 00H
	ORG $+3
$SG11342 DB	':', 0aH, 00H
	ORG $+1
$SG11391 DB	'loope', 00H
	ORG $+2
$SG11395 DB	'loop', 00H
	ORG $+3
$SG11398 DB	'ax', 00H
	ORG $+1
$SG11399 DB	'eax', 00H
$SG11400 DB	'rax', 00H
$SG11402 DB	'dx', 00H
	ORG $+1
$SG11403 DB	'edx', 00H
$SG11404 DB	'rdx', 00H
$SG11406 DB	'cx', 00H
	ORG $+1
$SG11407 DB	'ecx', 00H
$SG11408 DB	'rcx', 00H
$SG11418 DB	', ', 00H
	ORG $+1
$SG11456 DB	'=!<>&|-+*^%/', 00H
	ORG $+3
$SG11464 DB	' inc ', 00H
	ORG $+2
$SG11466 DB	' dec ', 00H
	ORG $+2
$SG11484 DB	' mov  ', 00H
	ORG $+1
$SG11487 DB	' cdq ', 00H
	ORG $+2
$SG11490 DB	' mov  ', 00H
	ORG $+1
$SG11494 DB	' idiv ', 00H
	ORG $+1
$SG11495 DB	' imul ', 00H
	ORG $+1
$SG11499 DB	' idiv ', 00H
	ORG $+1
$SG11500 DB	' imul ', 00H
	ORG $+1
$SG11502 DB	' mov  ', 00H
	ORG $+1
$SG11503 DB	' mov  ', 00H
	ORG $+1
$SG11507 DB	' cdq ', 00H
	ORG $+2
$SG11508 DB	' idiv ', 00H
	ORG $+1
$SG11509 DB	' imul ', 00H
	ORG $+1
$SG11512 DB	' mov  ', 00H
	ORG $+1
$SG11513 DB	' mov  ', 00H
	ORG $+1
$SG11519 DB	' cdq ', 00H
	ORG $+2
$SG11520 DB	' idiv ', 00H
	ORG $+1
$SG11521 DB	' imul ', 00H
	ORG $+1
$SG11523 DB	' mov  ', 00H
	ORG $+1
$SG11529 DB	' cdq ', 00H
	ORG $+2
$SG11530 DB	' idiv ', 00H
	ORG $+1
$SG11531 DB	' imul ', 00H
	ORG $+1
$SG11533 DB	' mov  ', 00H
	ORG $+1
$SG11536 DB	' mov  ', 00H
	ORG $+1
$SG11540 DB	' cdq ', 00H
	ORG $+2
$SG11541 DB	' idiv ', 00H
	ORG $+1
$SG11542 DB	' imul ', 00H
	ORG $+1
$SG11544 DB	' mov  ', 00H
	ORG $+1
$SG11547 DB	' sub ', 00H
	ORG $+2
$SG11550 DB	' add ', 00H
	ORG $+2
$SG11553 DB	' and ', 00H
	ORG $+2
$SG11556 DB	' or ', 00H
	ORG $+3
$SG11559 DB	' xor ', 00H
	ORG $+2
$SG11562 DB	' shl ', 00H
	ORG $+2
$SG11564 DB	' shr ', 00H
	ORG $+2
$SG11571 DB	' xor  ', 00H
	ORG $+1
$SG11578 DB	'BYTE PTR', 00H
	ORG $+3
$SG11579 DB	'BPTR', 00H
	ORG $+3
$SG11580 DB	'WPTR', 00H
	ORG $+3
$SG11586 DB	' lea  ', 00H
	ORG $+1
$SG11750 DB	'%s:', 00H
$SG11581 DB	'WORD PTR', 00H
	ORG $+3
$SG11587 DB	' mov  ', 00H
	ORG $+1
$SG11758 DB	'jmp', 00H
$SG11582 DB	' movzx  ', 00H
	ORG $+3
$SG11585 DB	'ADDR', 00H
	ORG $+3
$SG11593 DB	'OFFSET', 00H
	ORG $+1
$SG11594 DB	' lea  ', 00H
	ORG $+1
$SG11595 DB	' mov  ', 00H
	ORG $+1
$SG11760 DB	'%s:', 00H
$SG11602 DB	'DWORD PTR', 00H
	ORG $+2
$SG11603 DB	'DPTR', 00H
	ORG $+3
$SG11606 DB	' mov  ', 00H
	ORG $+1
$SG11824 DB	'%s:', 00H
$SG11605 DB	' movsxd  ', 00H
	ORG $+2
$SG11613 DB	' mov  ', 00H
	ORG $+1
$SG11831 DB	'%s:', 00H
$SG11612 DB	' invoke  ', 00H
	ORG $+2
$SG11616 DB	' mov  ', 00H
	ORG $+1
$SG11832 DB	'%s:', 00H
$SG11619 DB	' mov  byte ptr ', 00H
$SG11620 DB	' mov  ', 00H
	ORG $+1
$SG11688 DB	' movzx eax, %s', 00H
	ORG $+1
$SG11690 DB	' mov eax, %s', 00H
	ORG $+3
$SG11695 DB	' movzx eax, %s', 00H
	ORG $+1
$SG11698 DB	' mov eax, %s', 00H
	ORG $+3
$SG11700 DB	' mov rax, %s', 00H
	ORG $+3
$SG11707 DB	' movzx eax, %s', 00H
	ORG $+1
$SG11708 DB	' mov eax, %s', 00H
	ORG $+3
$SG11712 DB	' movzx eax, %s', 00H
	ORG $+1
$SG11715 DB	' mov eax, %s', 00H
	ORG $+3
$SG11716 DB	' mov rax, %s', 00H
	ORG $+3
$SG11717 DB	'jmp %s', 00H
	ORG $+1
$SG11725 DB	'(::)', 00H
	ORG $+3
$SG11740 DB	' jmp %s', 00H
$SG11743 DB	'.for ', 00H
	ORG $+2
$SG11745 DB	'.for', 00H, 00H
	ORG $+2
$SG11759 DB	'jmp %s', 00H
	ORG $+1
$SG11829 DB	'jmp %s', 00H
	ORG $+1
$SG11853 DB	'cmp  eax,%d', 00H
$SG11854 DB	'je  %s', 00H
	ORG $+1
$SG11855 DB	'jmp %s', 00H
	ORG $+1
$SG11949 DB	'%s:', 00H
$SG11856 DB	'mov rcx, %q', 00H
$SG11955 DB	'cdq', 00H
$SG11857 DB	'cmp rax, rcx', 00H
	ORG $+3
$SG11858 DB	'je  %s', 00H
	ORG $+1
$SG11859 DB	'jmp %s', 00H
	ORG $+1
$SG11865 DB	'cmp  eax,%d', 00H
$SG11866 DB	'je  %s', 00H
	ORG $+1
$SG11966 DB	'cdq', 00H
$SG11867 DB	'cmp  eax,%d', 00H
$SG11868 DB	'je  %s', 00H
	ORG $+1
$SG11869 DB	'jmp %s', 00H
	ORG $+1
$SG11976 DB	'cdq', 00H
$SG11870 DB	'mov rcx, %q', 00H
$SG11985 DB	'%s:', 00H
$SG11871 DB	'cmp rax, rcx', 00H
	ORG $+3
$SG11872 DB	'je  %s', 00H
	ORG $+1
$SG11873 DB	'mov rcx, %q', 00H
$SG11997 DB	'%s:', 00H
$SG11874 DB	'cmp rax, rcx', 00H
	ORG $+3
$SG11875 DB	'je  %s', 00H
	ORG $+1
$SG11876 DB	'jmp %s', 00H
	ORG $+1
$SG11882 DB	'cmp  eax,%d', 00H
$SG11883 DB	'je  %s', 00H
	ORG $+1
$SG12007 DB	'%s:', 00H
$SG11884 DB	'cmp  eax,%d', 00H
$SG11885 DB	'je  %s', 00H
	ORG $+1
$SG12024 DB	'%s:', 00H
$SG11886 DB	'cmp  eax,%d', 00H
$SG11887 DB	'je  %s', 00H
	ORG $+1
$SG11888 DB	'jmp %s', 00H
	ORG $+1
$SG12040 DB	'%s:', 00H
$SG11889 DB	'mov rcx, %q', 00H
$SG12060 DB	'%s:', 00H
$SG11890 DB	'cmp rax, rcx', 00H
	ORG $+3
$SG11891 DB	'je  %s', 00H
	ORG $+1
$SG11892 DB	'mov rcx, %q', 00H
$SG12066 DB	'%s:', 00H
$SG11893 DB	'cmp rax, rcx', 00H
	ORG $+3
$SG11894 DB	'je  %s', 00H
	ORG $+1
$SG11895 DB	'mov rcx, %q', 00H
$SG12068 DB	'%s:', 00H
$SG11896 DB	'cmp rax, rcx', 00H
	ORG $+3
$SG11897 DB	'je  %s', 00H
	ORG $+1
$SG11898 DB	'jmp %s', 00H
	ORG $+1
$SG11903 DB	'cmp eax,%d', 00H
	ORG $+1
$SG11904 DB	'ja  %s', 00H
	ORG $+1
$SG12075 DB	'%s:', 00H
$SG11905 DB	'sub eax,%d', 00H
	ORG $+1
$SG11906 DB	'jc  %s', 00H
	ORG $+1
$SG12079 DB	'%s:', 00H
$SG11907 DB	'mov rcx, %q', 00H
$SG12089 DB	'%s:', 00H
$SG11908 DB	'cmp rax, rcx', 00H
	ORG $+3
$SG11909 DB	'ja  %s', 00H
	ORG $+1
$SG11910 DB	'mov rcx, %q', 00H
$SG12093 DB	'%s:', 00H
$SG11911 DB	'sub rax, rcx', 00H
	ORG $+3
$SG11912 DB	'jc  %s', 00H
	ORG $+1
$SG11915 DB	'lea  edx,%s', 00H
$SG12148 DB	'%s:', 00H
$SG11916 DB	'movzx  eax,BYTE PTR[edx+eax]', 00H
	ORG $+3
$SG11917 DB	'lea  edx,%s', 00H
$SG12156 DB	'%s:', 00H
$SG11918 DB	'jmp  dword ptr[edx+eax*4]', 00H
	ORG $+2
$SG11959 DB	'je  %s', 00H
	ORG $+1
$SG12181 DB	'%s:', 00H
$SG11919 DB	'lea  rdx,%s', 00H
$SG11217 DB	'cmp', 00H
$SG11920 DB	'movzx  rax,byte ptr[rdx+rax]', 00H
	ORG $+3
$SG11921 DB	'lea  rdx,%s', 00H
$SG11235 DB	'or', 00H
	ORG $+1
$SG11922 DB	'jmp  qword ptr[rdx+rax*8]', 00H
	ORG $+2
$SG11960 DB	'jge %s', 00H
	ORG $+1
$SG11236 DB	'cmp', 00H
$SG11926 DB	'push', 09H, 'ebx', 00H
	ORG $+3
$SG11962 DB	'jmp %s', 00H
	ORG $+5
$SG11927 DB	'push', 09H, 'esi', 00H
	ORG $+7
$SG11928 DB	'push', 09H, 'edi', 00H
	ORG $+7
$SG11929 DB	'mov     esi,eax', 00H
$SG11930 DB	'mov     ebx,%d', 00H
	ORG $+1
$SG11931 DB	'xor     ecx,ecx', 00H
$SG11932 DB	'lea     edi,%s', 00H
	ORG $+1
$SG11933 DB	'test    ebx,ebx', 00H
$SG11934 DB	'js      %s', 00H
	ORG $+5
$SG11937 DB	'mov     r8d,eax', 00H
$SG11938 DB	'mov     r10d,%d', 00H
$SG11939 DB	'xor     r9d,r9d', 00H
$SG11940 DB	'lea     r11,%s', 00H
	ORG $+1
$SG11941 DB	'test    r10d,r10d', 00H
	ORG $+6
$SG11942 DB	'js      %s', 00H
	ORG $+5
$SG11943 DB	'mov     r8,rax', 00H
	ORG $+1
$SG11944 DB	'mov     r10d,%d', 00H
$SG11945 DB	'xor     r9d,r9d', 00H
$SG11946 DB	'lea     r11,%s', 00H
	ORG $+1
$SG11947 DB	'test    r10,r10', 00H
$SG11948 DB	'js      %s', 00H
	ORG $+5
$SG11954 DB	'lea     eax,[ecx + ebx]', 00H
$SG11956 DB	'sub     eax,edx', 00H
$SG11957 DB	'sar     eax,1', 00H
	ORG $+2
$SG11958 DB	'cmp     [edi+eax*4],esi', 00H
$SG11961 DB	'lea     ecx,[eax+1]', 00H
	ORG $+4
$SG11965 DB	'lea     eax,[r10+r9]', 00H
	ORG $+3
$SG11967 DB	'sub     eax,edx', 00H
$SG11968 DB	'sar     eax,1', 00H
	ORG $+2
$SG11969 DB	'movsxd  rcx,eax', 00H
$SG11970 DB	'cmp     [r11+rcx*4],r8d', 00H
$SG11971 DB	'je  %s', 00H
	ORG $+1
$SG11972 DB	'jge %s', 00H
	ORG $+1
$SG11973 DB	'lea     r9d,[rax+1]', 00H
$SG11974 DB	'jmp %s', 00H
	ORG $+5
$SG11975 DB	'lea     rax,[r10+r9]', 00H
	ORG $+3
$SG11977 DB	'sub     rax,rdx', 00H
$SG11978 DB	'sar     rax,1', 00H
	ORG $+2
$SG11979 DB	'mov     rcx,rax', 00H
$SG11980 DB	'cmp     [r11+rcx*8],r8', 00H
	ORG $+1
$SG11981 DB	'je  %s', 00H
	ORG $+1
$SG11982 DB	'jge %s', 00H
	ORG $+1
$SG11983 DB	'lea     r9,[rax+1]', 00H
	ORG $+1
$SG11984 DB	'jmp %s', 00H
	ORG $+5
$SG11990 DB	'lea edx,%s', 00H
	ORG $+5
$SG11991 DB	'pop', 09H, 'edi', 00H
$SG11992 DB	'pop', 09H, 'esi', 00H
$SG11993 DB	'pop', 09H, 'ebx', 00H
$SG11994 DB	'jmp dword ptr[edx+eax*4]', 00H
	ORG $+7
$SG11995 DB	'lea     r11,%s', 00H
	ORG $+1
$SG11996 DB	'jmp     qword ptr[r11+rcx*8]', 00H
	ORG $+3
$SG12002 DB	'lea     ebx,[eax-1]', 00H
	ORG $+4
$SG12005 DB	'lea     r10d,[rax-1]', 00H
	ORG $+3
$SG12006 DB	'lea     r10,[rax-1]', 00H
	ORG $+4
$SG12012 DB	'cmp  ecx,ebx', 00H
	ORG $+3
$SG12013 DB	'jle %s', 00H
	ORG $+1
$SG12014 DB	'pop', 09H, 'edi', 00H
$SG12015 DB	'pop', 09H, 'esi', 00H
$SG12016 DB	'pop', 09H, 'ebx', 00H
$SG12017 DB	'jmp  %s', 00H
$SG12020 DB	'cmp  r9d,r10d', 00H
	ORG $+2
$SG12021 DB	'cmp  r9,r10', 00H
$SG12022 DB	'jle %s', 00H
	ORG $+5
$SG12023 DB	'jmp  %s', 00H
$SG12031 DB	' dd %s', 00H
	ORG $+1
$SG12032 DB	' dd %s', 00H
	ORG $+1
$SG11008 DB	'ZERO', 00H
	ORG $+3
$SG12033 DB	' dd %s', 00H
	ORG $+1
$SG11011 DB	'CARRY', 00H
	ORG $+2
$SG12037 DB	' dq %s', 00H
	ORG $+1
$SG12038 DB	' dq %s', 00H
	ORG $+1
$SG11014 DB	'SIGN', 00H
	ORG $+3
$SG12039 DB	' dq %s', 00H
	ORG $+1
$SG11017 DB	'PARITY', 00H
	ORG $+1
$SG12044 DB	' db %d', 00H
	ORG $+1
$SG11020 DB	'OVERFLOW', 00H
	ORG $+3
$SG12045 DB	' db %d', 00H
	ORG $+1
$SG12047 DB	' db %d', 00H
	ORG $+1
$SG11023 DB	'LESS', 00H
	ORG $+3
$SG12048 DB	' db %d', 00H
	ORG $+5
$SG11026 DB	'GREATER', 00H
$SG12053 DB	' dd %d', 00H
	ORG $+1
$SG11029 DB	'ABOVE', 00H
	ORG $+2
$SG12054 DB	' dq %q', 00H
	ORG $+1
$SG11032 DB	'EQUAL', 00H
	ORG $+2
$SG11035 DB	'BELOW', 00H
	ORG $+2
$SG12069 DB	' jmp %s', 00H
$SG12071 DB	' jmp %s', 00H
$SG12085 DB	'loop %s', 00H
$SG11111 DB	', %d', 00H
	ORG $+3
$SG11118 DB	'@C%04X', 00H
	ORG $+1
$SG12146 DB	'jmp %s', 00H
	ORG $+1
$SG12154 DB	'jmp %s', 00H
	ORG $+1
$SG12179 DB	'jmp %s', 00H
	ORG $+1
$SG12198 DB	'jmp %s', 00H
	ORG $+1
$SG12205 DB	'.if-.repeat-.while', 00H
	ORG $+1
$SG11215 DB	'test', 00H
	ORG $+7
$SG11224 DB	'jmp @C%04X', 0aH, 00H
$SG11229 DB	'test', 00H
	ORG $+3
$SG11242 DB	'jmp ', 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	sprintf
PUBLIC	HllInit
PUBLIC	HllCheckOpen
PUBLIC	hex2dec
PUBLIC	HllStartDir
PUBLIC	HllEndDir
PUBLIC	HllExitDir
EXTRN	tolower:PROC
EXTRN	strchr:PROC
EXTRN	strstr:PROC
EXTRN	_memicmp:PROC
EXTRN	_stricmp:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	LclAlloc:PROC
EXTRN	EvalOperand:PROC
EXTRN	EmitConstError:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	LstWrite:PROC
EXTRN	AddLineQueue:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	RunLineQueue:PROC
EXTRN	Tokenize:PROC
EXTRN	atofloat:PROC
EXTRN	__chkstk:PROC
EXTRN	memcpy:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	__ImageBase:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN8
	DD	imagerel $LN8+90
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetExpression DD imagerel GetExpression
	DD	imagerel GetExpression+769
	DD	imagerel $unwind$GetExpression
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetCOp DD imagerel GetCOp
	DD	imagerel GetCOp+658
	DD	imagerel $unwind$GetCOp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bubblesort DD imagerel bubblesort
	DD	imagerel bubblesort+29
	DD	imagerel $unwind$bubblesort
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$bubblesort DD imagerel bubblesort+29
	DD	imagerel bubblesort+137
	DD	imagerel $chain$1$bubblesort
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$bubblesort DD imagerel bubblesort+137
	DD	imagerel bubblesort+169
	DD	imagerel $chain$2$bubblesort
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bubblesort64 DD imagerel bubblesort64
	DD	imagerel bubblesort64+29
	DD	imagerel $unwind$bubblesort64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$bubblesort64 DD imagerel bubblesort64+29
	DD	imagerel bubblesort64+140
	DD	imagerel $chain$1$bubblesort64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$bubblesort64 DD imagerel bubblesort64+140
	DD	imagerel bubblesort64+185
	DD	imagerel $chain$2$bubblesort64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RenderInstr DD imagerel RenderInstr
	DD	imagerel RenderInstr+240
	DD	imagerel $unwind$RenderInstr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetLabelStr DD imagerel GetLabelStr
	DD	imagerel GetLabelStr+36
	DD	imagerel $unwind$GetLabelStr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RenderJcc DD imagerel RenderJcc
	DD	imagerel RenderJcc+96
	DD	imagerel $unwind$RenderJcc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetToken DD imagerel GetToken
	DD	imagerel GetToken+38
	DD	imagerel $unwind$GetToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$GetToken DD imagerel GetToken+38
	DD	imagerel GetToken+520
	DD	imagerel $chain$2$GetToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$GetToken DD imagerel GetToken+520
	DD	imagerel GetToken+622
	DD	imagerel $chain$3$GetToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetSimpleExpression DD imagerel GetSimpleExpression
	DD	imagerel GetSimpleExpression+1376
	DD	imagerel $unwind$GetSimpleExpression
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReplaceLabel DD imagerel ReplaceLabel
	DD	imagerel ReplaceLabel+161
	DD	imagerel $unwind$ReplaceLabel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetAndExpression DD imagerel GetAndExpression
	DD	imagerel GetAndExpression+564
	DD	imagerel $unwind$GetAndExpression
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$QueueTestLines DD imagerel QueueTestLines
	DD	imagerel QueueTestLines+14
	DD	imagerel $unwind$QueueTestLines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$QueueTestLines DD imagerel QueueTestLines+14
	DD	imagerel QueueTestLines+85
	DD	imagerel $chain$0$QueueTestLines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$QueueTestLines DD imagerel QueueTestLines+85
	DD	imagerel QueueTestLines+93
	DD	imagerel $chain$1$QueueTestLines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$EvaluateHllExpression DD imagerel EvaluateHllExpression
	DD	imagerel EvaluateHllExpression+138
	DD	imagerel $unwind$EvaluateHllExpression
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CheckCXZLines DD imagerel CheckCXZLines
	DD	imagerel CheckCXZLines+274
	DD	imagerel $unwind$CheckCXZLines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$WriteAsmLine DD imagerel WriteAsmLine
	DD	imagerel WriteAsmLine+226
	DD	imagerel $unwind$WriteAsmLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ForInitAndNext DD imagerel ForInitAndNext
	DD	imagerel ForInitAndNext+8208
	DD	imagerel $unwind$ForInitAndNext
pdata	ENDS
pdata	SEGMENT
$pdata$HllStartDir DD imagerel $LN302
	DD	imagerel $LN302+774
	DD	imagerel $unwind$HllStartDir
$pdata$1$HllStartDir DD imagerel $LN302+774
	DD	imagerel $LN302+951
	DD	imagerel $chain$1$HllStartDir
$pdata$2$HllStartDir DD imagerel $LN302+951
	DD	imagerel $LN302+3034
	DD	imagerel $chain$2$HllStartDir
$pdata$HllEndDir DD imagerel $LN391
	DD	imagerel $LN391+130
	DD	imagerel $unwind$HllEndDir
$pdata$0$HllEndDir DD imagerel $LN391+130
	DD	imagerel $LN391+4307
	DD	imagerel $chain$0$HllEndDir
$pdata$1$HllEndDir DD imagerel $LN391+4307
	DD	imagerel $LN391+4675
	DD	imagerel $chain$1$HllEndDir
$pdata$2$HllEndDir DD imagerel $LN391+4675
	DD	imagerel $LN391+5972
	DD	imagerel $chain$2$HllEndDir
$pdata$3$HllEndDir DD imagerel $LN391+5972
	DD	imagerel $LN391+6008
	DD	imagerel $chain$3$HllEndDir
$pdata$HllExitDir DD imagerel $LN202
	DD	imagerel $LN202+81
	DD	imagerel $unwind$HllExitDir
$pdata$2$HllExitDir DD imagerel $LN202+81
	DD	imagerel $LN202+2132
	DD	imagerel $chain$2$HllExitDir
$pdata$3$HllExitDir DD imagerel $LN202+2132
	DD	imagerel $LN202+2180
	DD	imagerel $chain$3$HllExitDir
pdata	ENDS
_DATA	SEGMENT
	ORG $+7
reax	DQ	FLAT:$SG11398
	DQ	FLAT:$SG11399
	DQ	FLAT:$SG11400
redx	DQ	FLAT:$SG11402
	DQ	FLAT:$SG11403
	DQ	FLAT:$SG11404
recx	DQ	FLAT:$SG11406
	DQ	FLAT:$SG11407
	DQ	FLAT:$SG11408
_DATA	ENDS
CONST	SEGMENT
flaginstr DB	07aH
	DB	063H
	DB	073H
	DB	070H
	DB	06fH
	DB	06cH
	DB	067H
	DB	061H
	DB	065H
	DB	062H
	ORG $+2
unsigned_cjmptype DB 07aH
	DB	07aH
	DB	061H
	DB	062H
	DB	062H
	DB	061H
	ORG $+2
signed_cjmptype DB 07aH
	DB	07aH
	DB	067H
	DB	06cH
	DB	06cH
	DB	067H
	ORG $+2
neg_cjmptype DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
CONST	ENDS
xdata	SEGMENT
$unwind$HllStartDir DD 0b6301H
	DD	03a16463H
	DD	03a33426H
	DD	039a0126H
	DD	0d00ff011H
	DD	0700bc00dH
	DD	0500aH
$chain$1$HllStartDir DD 020821H
	DD	03a2e408H
	DD	imagerel $LN302
	DD	imagerel $LN302+774
	DD	imagerel $unwind$HllStartDir
$chain$2$HllStartDir DD 021H
	DD	imagerel $LN302
	DD	imagerel $LN302+774
	DD	imagerel $unwind$HllStartDir
$unwind$HllEndDir DD 082001H
	DD	010f0120H
	DD	0c00ff011H
	DD	0600c700dH
	DD	0500a300bH
$chain$0$HllEndDir DD 020821H
	DD	010de408H
	DD	imagerel $LN391
	DD	imagerel $LN391+130
	DD	imagerel $unwind$HllEndDir
$chain$1$HllEndDir DD 020821H
	DD	010ed408H
	DD	imagerel $LN391+130
	DD	imagerel $LN391+4307
	DD	imagerel $chain$0$HllEndDir
$chain$2$HllEndDir DD 021H
	DD	imagerel $LN391+130
	DD	imagerel $LN391+4307
	DD	imagerel $chain$0$HllEndDir
$chain$3$HllEndDir DD 021H
	DD	imagerel $LN391
	DD	imagerel $LN391+130
	DD	imagerel $unwind$HllEndDir
$unwind$HllExitDir DD 071a01H
	DD	09a011aH
	DD	0c009e00bH
	DD	030067007H
	DD	05005H
$chain$2$HllExitDir DD 062421H
	DD	0a3f424H
	DD	0a2d416H
	DD	0a16408H
	DD	imagerel $LN202
	DD	imagerel $LN202+81
	DD	imagerel $unwind$HllExitDir
$chain$3$HllExitDir DD 021H
	DD	imagerel $LN202
	DD	imagerel $LN202+81
	DD	imagerel $unwind$HllExitDir
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ForInitAndNext DD 0b2901H
	DD	08f3429H
	DD	0840129H
	DD	0e018f01aH
	DD	0c014d016H
	DD	060117012H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WriteAsmLine DD 020701H
	DD	0250107H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CheckCXZLines DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EvaluateHllExpression DD 040a01H
	DD	0c340aH
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$QueueTestLines DD 021H
	DD	imagerel QueueTestLines
	DD	imagerel QueueTestLines+14
	DD	imagerel $unwind$QueueTestLines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$QueueTestLines DD 020521H
	DD	067405H
	DD	imagerel QueueTestLines
	DD	imagerel QueueTestLines+14
	DD	imagerel $unwind$QueueTestLines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$QueueTestLines DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetAndExpression DD 0a1e01H
	DD	011341eH
	DD	0f01a721eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReplaceLabel DD 040a01H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetSimpleExpression DD 0b9001H
	DD	02ee490H
	DD	024011bH
	DD	0d012f014H
	DD	0700ec010H
	DD	0500c600dH
	DD	0300bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$GetToken DD 021H
	DD	imagerel GetToken
	DD	imagerel GetToken+38
	DD	imagerel $unwind$GetToken
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$GetToken DD 061621H
	DD	0cc416H
	DD	0b640aH
	DD	0a3405H
	DD	imagerel GetToken
	DD	imagerel GetToken+38
	DD	imagerel $unwind$GetToken
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetToken DD 060e01H
	DD	0d540eH
	DD	0f00a520eH
	DD	07006e008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RenderJcc DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetLabelStr DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RenderInstr DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$bubblesort64 DD 021H
	DD	imagerel bubblesort64
	DD	imagerel bubblesort64+29
	DD	imagerel $unwind$bubblesort64
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$bubblesort64 DD 040d21H
	DD	03640dH
	DD	023405H
	DD	imagerel bubblesort64
	DD	imagerel bubblesort64+29
	DD	imagerel $unwind$bubblesort64
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bubblesort64 DD 050c01H
	DD	05740cH
	DD	04540cH
	DD	0e00cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$bubblesort DD 021H
	DD	imagerel bubblesort
	DD	imagerel bubblesort+29
	DD	imagerel $unwind$bubblesort
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$bubblesort DD 040d21H
	DD	03640dH
	DD	023405H
	DD	imagerel bubblesort
	DD	imagerel bubblesort+29
	DD	imagerel $unwind$bubblesort
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bubblesort DD 050c01H
	DD	05740cH
	DD	04540cH
	DD	0e00cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetCOp DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetExpression DD 0a1e01H
	DD	012341eH
	DD	0f01a921eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
buff$ = 64
hllop$1 = 80
hllop$2 = 80
opndx$ = 96
buffer$ = 208
i$ = 1280
tokenarray$ = 1288
HllExitDir PROC

; 2151 : {

$LN202:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rbx
	push	rdi
	push	r12
	push	r14
	lea	rbp, QWORD PTR [rsp-976]
	sub	rsp, 1232				; 000004d0H

; 2152 :   struct expr         opndx;
; 2153 :   struct hll_item     *hll;
; 2154 :   ret_code            rc = NOT_ERROR;
; 2155 :   int                 j;
; 2156 :   int                 idx;
; 2157 :   int                 cmd = tokenarray[i].tokval;
; 2158 :   int                 *newcp;
; 2159 :   uint_16             *newlp;
; 2160 :   char buff[16];
; 2161 :   char                *p;
; 2162 :   char buffer[MAX_LINE_LEN];
; 2163 : #if AMD64_SUPPORT
; 2164 :   int_64              *newcp64;
; 2165 : #endif
; 2166 : 
; 2167 : 
; 2168 :   DebugMsg1(("HllExitDir(%s) enter\n", tokenarray[i].string_ptr));
; 2169 : 
; 2170 :   hll = HllStack;

	mov	rbx, QWORD PTR ModuleInfo+224
	mov	r12, rdx
	movsxd	rdx, ecx
	xor	r14d, r14d
	shl	rdx, 5
	mov	edi, DWORD PTR [rdx+r12+16]

; 2171 : 
; 2172 :   if (hll == NULL) {

	test	rbx, rbx
	jne	SHORT $LN18@HllExitDir

; 2173 :     DebugMsg(("HllExitDir stack error\n"));
; 2174 :     return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError

; 2407 : }

	add	rsp, 1232				; 000004d0H
	pop	r14
	pop	r12
	pop	rdi
	pop	rbx
	pop	rbp
	ret	0
$LN18@HllExitDir:
	mov	QWORD PTR [rsp+1288], rsi

; 2175 :   }
; 2176 :   switch (cmd) {

	lea	eax, DWORD PTR [rdi-331]
	mov	QWORD PTR [rsp+1296], r13
	mov	r13d, 4
	mov	QWORD PTR [rsp+1304], r15
	cmp	eax, 11
	ja	$LN65@HllExitDir
	lea	r8, OFFSET FLAT:__ImageBase
	cdqe
	mov	ecx, DWORD PTR $LN184@HllExitDir[r8+rax*4]
	add	rcx, r8
	jmp	rcx
$LN19@HllExitDir:

; 2177 :   case T_DOT_DEFAULT:
; 2178 :     if (hll->flags & HLLF_ELSEOCCURED) {

	test	BYTE PTR [rbx+112], 1
	jne	$LN200@HllExitDir

; 2179 :       DebugMsg(("HllExitDir stack error\n"));
; 2180 :       return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));
; 2181 :     }
; 2182 :     if (hll->labels[LEXIT] == 0)

	cmp	DWORD PTR [rbx+40], r14d
	jne	SHORT $LN21@HllExitDir

; 2183 :       hll->labels[LEXIT] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+40], eax
$LN21@HllExitDir:

; 2184 :     AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+40]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12146
	call	AddLineQueueX

; 2185 :     if (hll->labels[LDEF] == 0)

	cmp	DWORD PTR [rbx+56], r14d
	jne	SHORT $LN22@HllExitDir

; 2186 :       hll->labels[LDEF] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+56], eax
$LN22@HllExitDir:

; 2187 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12148
	call	AddLineQueueX

; 2188 :     hll->flags |= HLLF_ELSEOCCURED;

	or	DWORD PTR [rbx+112], 1

; 2189 :     i++;

	inc	DWORD PTR i$[rbp-256]

; 2190 :     break;

	jmp	$LN65@HllExitDir
$LN23@HllExitDir:

; 2191 :   case T_DOT_CASE:
; 2192 :     if (hll->cmd != HLL_SWITCH) {

	cmp	DWORD PTR [rbx+104], 5
	jne	$LN200@HllExitDir

; 2193 :       DebugMsg(("HllExitDir stack error\n"));
; 2194 :       return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));
; 2195 :     }
; 2196 :     if (ModuleInfo.switch_style == ASMSWITCH) {

	test	DWORD PTR ModuleInfo+408, 524288	; 00080000H
	jne	SHORT $LN175@HllExitDir

; 2197 :       if (hll->casecnt) {

	cmp	DWORD PTR [rbx+100], r14d
	je	SHORT $LN175@HllExitDir

; 2198 :         if (hll->labels[LEXIT] == 0)

	cmp	DWORD PTR [rbx+40], r14d
	jne	SHORT $LN27@HllExitDir

; 2199 :           hll->labels[LEXIT] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+40], eax
$LN27@HllExitDir:

; 2200 :         AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+40]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12154
	call	AddLineQueueX

; 2201 :         hll->breakoccured = TRUE;

	mov	BYTE PTR [rbx+109], 1
$LN175@HllExitDir:
	mov	r15d, 8
	npad	6
$LL4@HllExitDir:

; 2202 :       }
; 2203 :     }
; 2204 :     for (;;) {
; 2205 :     if (hll->breakoccured) {

	cmp	BYTE PTR [rbx+109], r14b
	je	SHORT $LN28@HllExitDir

; 2206 :       hll->labels[LTEST] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352

; 2207 :       hll->breakoccured = FALSE;  // if .break did not occure label will not be increased
; 2208 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	lea	rdx, OFFSET FLAT:$SG11118
	inc	eax
	lea	rcx, QWORD PTR buff$[rsp]
	mov	DWORD PTR ModuleInfo+352, eax
	mov	r8d, eax
	mov	DWORD PTR [rbx+36], eax
	mov	BYTE PTR [rbx+109], r14b
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12156
	call	AddLineQueueX

; 2209 :       hll->savedlab = hex2dec(buff + 2);

	lea	rcx, QWORD PTR buff$[rsp+2]
	call	hex2dec
	mov	WORD PTR [rbx+32], ax
$LN28@HllExitDir:

; 2210 :     }
; 2211 :     i++;    

	mov	ecx, DWORD PTR i$[rbp-256]
	inc	ecx

; 2212 :       if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, ecx
	shl	rax, 5
	mov	DWORD PTR i$[rbp-256], ecx
	cmp	BYTE PTR [rax+r12], r14b
	je	$LN29@HllExitDir

; 2213 :         strcpy(buffer, tokenarray[i].tokpos);

	mov	rcx, QWORD PTR [rax+r12+24]
	lea	rdx, QWORD PTR buffer$[rbp-256]
	npad	10
$LL72@HllExitDir:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL72@HllExitDir

; 2214 :         DebugMsg1(("HllExitDir(%s): calling EvalOperand, i=%u\n", tokenarray[i].string_ptr, i));
; 2215 :         if (EvalOperand(&i, tokenarray, Token_Count, &opndx, 0) == ERROR) {

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	mov	rdx, r12
	mov	BYTE PTR [rsp+32], r14b
	lea	rcx, QWORD PTR i$[rbp-256]
	call	EvalOperand
	cmp	eax, -1
	je	$LN132@HllExitDir

; 2218 :         }
; 2219 :         //i++;
; 2220 :         p = tokenarray[i].tokpos;
; 2221 :         switch (opndx.kind) {

	cmp	DWORD PTR opndx$[rbp-196], 3
	jne	SHORT $LN34@HllExitDir

; 2222 :         case EXPR_CONST:
; 2223 :           //tokenarray[i].token = T_FINAL;
; 2224 :           break;
; 2225 :         case EXPR_FLOAT:
; 2226 : #if FPIMMEDIATE
; 2227 :           if (Options.strict_masm_compat == FALSE) {

	cmp	BYTE PTR Options+127, r14b
	jne	SHORT $LN34@HllExitDir

; 2228 :             /* convert to REAL4, unless REAL8 coercion is requested */
; 2229 :             atofloat(&opndx.fvalue, opndx.float_tok->string_ptr, opndx.mem_type == MT_REAL8 ? 8 : 4, opndx.negative, opndx.float_tok->floattype);

	mov	rdx, QWORD PTR opndx$[rsp+16]
	lea	rcx, QWORD PTR opndx$[rsp]
	mov	r9d, DWORD PTR opndx$[rbp-184]
	mov	r8d, r13d
	shr	r9d, 5
	and	r9d, 1
	movsx	eax, BYTE PTR [rdx+1]
	cmp	DWORD PTR opndx$[rbp-192], 39		; 00000027H
	mov	rdx, QWORD PTR [rdx+8]
	cmove	r8d, r15d
	mov	DWORD PTR [rsp+32], eax
	call	atofloat
$LN34@HllExitDir:

; 2239 :       }
; 2240 :       if (hll->csize == 4) {

	movzx	eax, BYTE PTR [rbx+111]
	cmp	al, r13b
	jne	SHORT $LN35@HllExitDir

; 2241 :         if (!hll->maxalloccasen) {

	cmp	DWORD PTR [rbx+128], r14d
	jne	SHORT $LN37@HllExitDir

; 2242 :           hll->pcases = LclAlloc(hll->csize * 50);

	mov	ecx, 200				; 000000c8H
	call	LclAlloc

; 2243 :           hll->plabels = LclAlloc(sizeof(uint_16) * 50);

	mov	ecx, 100				; 00000064H
	mov	QWORD PTR [rbx+8], rax
	call	LclAlloc
	mov	QWORD PTR [rbx+24], rax

; 2244 :           hll->maxalloccasen = 50;

	mov	DWORD PTR [rbx+128], 50			; 00000032H
$LN37@HllExitDir:

; 2245 :         }
; 2246 :         if (hll->casecnt >= hll->maxalloccasen) {

	mov	ecx, DWORD PTR [rbx+128]
	cmp	DWORD PTR [rbx+100], ecx
	jb	$LN40@HllExitDir

; 2247 :           hll->maxalloccasen += 50;
; 2248 :           newcp = LclAlloc(hll->csize * hll->maxalloccasen);

	movsx	eax, BYTE PTR [rbx+111]
	add	ecx, 50					; 00000032H
	imul	eax, ecx
	mov	DWORD PTR [rbx+128], ecx
	movsxd	rcx, eax
	call	LclAlloc

; 2249 :           memcpy(newcp, hll->pcases, hll->casecnt * hll->csize);

	movsx	r8d, BYTE PTR [rbx+111]
	mov	rcx, rax
	imul	r8d, DWORD PTR [rbx+100]
	mov	rdi, rax
	mov	rdx, QWORD PTR [rbx+8]
	call	memcpy

; 2250 :           LclFree(hll->pcases);
; 2251 :           hll->pcases = newcp;

	mov	QWORD PTR [rbx+8], rdi

; 2252 : 
; 2253 :           newlp = LclAlloc(sizeof(uint_16) * hll->maxalloccasen);
; 2254 :           memcpy(newlp, hll->plabels, hll->casecnt * sizeof(uint_16));
; 2255 :           LclFree(hll->plabels);
; 2256 :           hll->plabels = newlp;
; 2257 :         }
; 2258 :       }

	jmp	SHORT $LN199@HllExitDir
$LN35@HllExitDir:

; 2259 : #if AMD64_SUPPORT
; 2260 :       else {
; 2261 :         if (!hll->maxalloccasen) {

	cmp	DWORD PTR [rbx+128], r14d
	jne	SHORT $LN39@HllExitDir

; 2262 :           hll->pcases64 = LclAlloc(hll->csize * 50);

	movsx	eax, al
	imul	ecx, eax, 50				; 00000032H
	movsxd	rcx, ecx
	call	LclAlloc

; 2263 :           hll->plabels = LclAlloc(sizeof(uint_16) * 50);

	mov	ecx, 100				; 00000064H
	mov	QWORD PTR [rbx+16], rax
	call	LclAlloc
	mov	QWORD PTR [rbx+24], rax

; 2264 :           hll->maxalloccasen = 50;

	mov	DWORD PTR [rbx+128], 50			; 00000032H
$LN39@HllExitDir:

; 2265 :         }
; 2266 :         if (hll->casecnt >= hll->maxalloccasen) {

	mov	ecx, DWORD PTR [rbx+128]
	cmp	DWORD PTR [rbx+100], ecx
	jb	SHORT $LN40@HllExitDir

; 2267 :           hll->maxalloccasen += 50;
; 2268 :           newcp64 = LclAlloc(hll->csize * hll->maxalloccasen);

	movsx	eax, BYTE PTR [rbx+111]
	add	ecx, 50					; 00000032H
	imul	eax, ecx
	mov	DWORD PTR [rbx+128], ecx
	movsxd	rcx, eax
	call	LclAlloc

; 2269 :           memcpy(newcp64, hll->pcases64, hll->casecnt * hll->csize);

	movsx	r8d, BYTE PTR [rbx+111]
	mov	rcx, rax
	imul	r8d, DWORD PTR [rbx+100]
	mov	rdi, rax
	mov	rdx, QWORD PTR [rbx+16]
	call	memcpy

; 2270 :           LclFree(hll->pcases64);
; 2271 :           hll->pcases64 = newcp64;

	mov	QWORD PTR [rbx+16], rdi
$LN199@HllExitDir:

; 2272 : 
; 2273 :           newlp = LclAlloc(sizeof(uint_16) * hll->maxalloccasen);

	movsxd	rcx, DWORD PTR [rbx+128]
	add	rcx, rcx
	call	LclAlloc

; 2274 :           memcpy(newlp, hll->plabels, hll->casecnt * sizeof(uint_16));

	mov	r8d, DWORD PTR [rbx+100]
	mov	rcx, rax
	mov	rdx, QWORD PTR [rbx+24]
	add	r8, r8
	mov	rdi, rax
	call	memcpy

; 2275 :           LclFree(hll->plabels);
; 2276 :           hll->plabels = newlp;

	mov	QWORD PTR [rbx+24], rdi
$LN40@HllExitDir:

; 2277 :         }
; 2278 :       }
; 2279 : #endif
; 2280 :       if ((ModuleInfo.Ofssize == USE32) || (hll->csize == 4)) {

	cmp	BYTE PTR ModuleInfo+404, 1
	je	SHORT $LN43@HllExitDir
	cmp	BYTE PTR [rbx+111], r13b
	je	SHORT $LN43@HllExitDir

; 2286 :       }
; 2287 : #if AMD64_SUPPORT
; 2288 :       else {
; 2289 :         for (j = 0; j < hll->casecnt; j++) {

	mov	esi, r14d
	cmp	DWORD PTR [rbx+100], r14d
	jbe	SHORT $LN189@HllExitDir
	mov	rdi, r14
$LL14@HllExitDir:

; 2290 :           if (hll->pcases64[j] == opndx.value64)

	mov	rcx, QWORD PTR [rbx+16]
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rdi+rcx], rax
	jne	SHORT $LN12@HllExitDir

; 2291 :             EmitErr(CASE_ALREADY_OCCURED_IN_THIS_SWITCH_BLOCK, buffer);

	lea	rdx, QWORD PTR buffer$[rbp-256]
	mov	ecx, 253				; 000000fdH
	call	EmitErr
$LN12@HllExitDir:

; 2286 :       }
; 2287 : #if AMD64_SUPPORT
; 2288 :       else {
; 2289 :         for (j = 0; j < hll->casecnt; j++) {

	inc	esi
	add	rdi, r15
	cmp	esi, DWORD PTR [rbx+100]
	jb	SHORT $LL14@HllExitDir
$LN189@HllExitDir:

; 2292 :         }
; 2293 :         hll->pcases64[hll->casecnt] = opndx.value64;

	mov	edx, DWORD PTR [rbx+100]
	mov	rcx, QWORD PTR [rbx+16]
	mov	rax, QWORD PTR opndx$[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	jmp	SHORT $LN42@HllExitDir
$LN43@HllExitDir:

; 2281 :         for (j = 0; j < hll->casecnt; j++) {

	mov	esi, r14d
	cmp	DWORD PTR [rbx+100], r14d
	jbe	SHORT $LN190@HllExitDir
	mov	rdi, r14
	npad	11
$LL11@HllExitDir:

; 2282 :           if (hll->pcases[j] == opndx.value)

	mov	rcx, QWORD PTR [rbx+8]
	mov	eax, DWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rdi+rcx], eax
	jne	SHORT $LN9@HllExitDir

; 2283 :             EmitErr(CASE_ALREADY_OCCURED_IN_THIS_SWITCH_BLOCK, buffer);

	lea	rdx, QWORD PTR buffer$[rbp-256]
	mov	ecx, 253				; 000000fdH
	call	EmitErr
$LN9@HllExitDir:

; 2281 :         for (j = 0; j < hll->casecnt; j++) {

	inc	esi
	add	rdi, r13
	cmp	esi, DWORD PTR [rbx+100]
	jb	SHORT $LL11@HllExitDir
$LN190@HllExitDir:

; 2284 :         }
; 2285 :         hll->pcases[hll->casecnt] = opndx.value;

	mov	edx, DWORD PTR [rbx+100]
	mov	rcx, QWORD PTR [rbx+8]
	mov	eax, DWORD PTR opndx$[rsp]
	mov	DWORD PTR [rcx+rdx*4], eax
$LN42@HllExitDir:

; 2294 :       }
; 2295 : #endif
; 2296 :       hll->plabels[hll->casecnt] = hll->savedlab;

	mov	edx, DWORD PTR [rbx+100]
	mov	rcx, QWORD PTR [rbx+24]
	movzx	eax, WORD PTR [rbx+32]
	mov	WORD PTR [rcx+rdx*2], ax

; 2297 :       hll->casecnt++;

	inc	DWORD PTR [rbx+100]

; 2298 :       if (tokenarray[i].token != T_COMMA)

	movsxd	rcx, DWORD PTR i$[rbp-256]
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 44			; 0000002cH
	je	$LL4@HllExitDir

; 2299 :       break;
; 2300 :     }
; 2301 :     tokenarray[i].token = T_FINAL;

	mov	rax, rcx
	shl	rax, 5
	mov	BYTE PTR [rax+r12], r14b

; 2302 :     //hll->breakoccured = TRUE;
; 2303 :     //if (hll->labels[LEXIT] == 0)
; 2304 :     //  hll->labels[LEXIT] = GetHllLabel();
; 2305 :     //AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[LEXIT], buff));
; 2306 :     break;

	jmp	$LN65@HllExitDir
$LN132@HllExitDir:

; 2216 :           DebugMsg(("HllExitDir(%s): EvalOperand() failed\n", tokenarray[i].string_ptr));
; 2217 :           return(ERROR);

	or	eax, -1
	jmp	$LN198@HllExitDir
$LN29@HllExitDir:

; 2230 :             //tokenarray[i].token = T_FINAL;
; 2231 :             break;
; 2232 :           }
; 2233 : #endif
; 2234 :         }
; 2235 :       }
; 2236 :       else {
; 2237 :         DebugMsg(("HllExitDir stack error\n"));
; 2238 :         return(EmitError(MISSING_OPERATOR_IN_EXPRESSION));

	mov	ecx, 150				; 00000096H
	call	EmitError
	jmp	$LN198@HllExitDir
$LN47@HllExitDir:

; 2307 :   case T_DOT_ELSE:
; 2308 :   case T_DOT_ELSEIF:
; 2309 :     if (hll->cmd != HLL_IF) {

	cmp	DWORD PTR [rbx+104], r14d
	je	SHORT $LN48@HllExitDir

; 2310 :       DebugMsg(("HllExitDir(%s): labels[LTEST]=%X\n", tokenarray[i].string_ptr, hll->labels[LTEST]));
; 2311 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	mov	rdx, QWORD PTR [rdx+r12+8]
	mov	ecx, 80					; 00000050H
	call	EmitErr
	jmp	$LN198@HllExitDir
$LN48@HllExitDir:

; 2312 :     }
; 2313 :     /* v2.08: check for multiple ELSE clauses */
; 2314 :     if (hll->flags & HLLF_ELSEOCCURED) {

	test	BYTE PTR [rbx+112], 1
	je	SHORT $LN49@HllExitDir

; 2315 :       return(EmitError(DOT_ELSE_CLAUSE_ALREADY_OCCURED_IN_THIS_DOT_IF_BLOCK));

	mov	ecx, 67					; 00000043H
	call	EmitError
	jmp	$LN198@HllExitDir
$LN49@HllExitDir:

; 2316 :     }
; 2317 : 
; 2318 :     /* the 'exit'-label is only needed if an .ELSE branch exists.
; 2319 :     * That's why it is created delayed.
; 2320 :     */
; 2321 :     if (hll->labels[LEXIT] == 0)

	cmp	DWORD PTR [rbx+40], r14d
	jne	SHORT $LN50@HllExitDir

; 2322 :       hll->labels[LEXIT] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+40], eax
$LN50@HllExitDir:

; 2323 :     AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+40]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12179
	call	AddLineQueueX

; 2324 : 
; 2325 :     if (hll->labels[LTEST] > 0) {

	mov	r8d, DWORD PTR [rbx+36]
	test	r8d, r8d
	je	SHORT $LN51@HllExitDir

; 2326 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12181
	call	AddLineQueueX

; 2327 :       hll->labels[LTEST] = 0;

	mov	DWORD PTR [rbx+36], r14d
$LN51@HllExitDir:

; 2328 :     }
; 2329 :     i++;

	inc	DWORD PTR i$[rbp-256]

; 2330 :     if (cmd == T_DOT_ELSEIF) {

	cmp	edi, 334				; 0000014eH
	jne	$LN52@HllExitDir

; 2331 :       /* create new labels[LTEST] label */
; 2332 :       hll->labels[LTEST] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352

; 2333 :       rc = EvaluateHllExpression(hll, &i, tokenarray, LTEST, FALSE, buffer);

	lea	rdx, QWORD PTR i$[rbp-256]
	inc	eax
	mov	QWORD PTR hllop$2[rsp], r14
	mov	DWORD PTR ModuleInfo+352, eax
	xor	r9d, r9d
	mov	DWORD PTR [rbx+36], eax
	mov	r8, r12
	lea	rax, QWORD PTR hllop$2[rsp]
	mov	DWORD PTR hllop$2[rsp+8], r14d
	mov	QWORD PTR [rsp+48], rax
	mov	rcx, rbx
	lea	rax, QWORD PTR buffer$[rbp-256]
	mov	BYTE PTR buffer$[rbp-256], r14b
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], r14b
	call	GetExpression
	cmp	eax, -1
	jne	SHORT $LN98@HllExitDir
	or	r14d, eax
	jmp	$LN65@HllExitDir
$LN98@HllExitDir:
	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], r14b
	je	SHORT $LN99@HllExitDir
	mov	ecx, 199				; 000000c7H
	call	EmitError
	mov	r14d, eax

; 2334 :       if (rc == NOT_ERROR)

	test	eax, eax
	jne	$LN65@HllExitDir

; 2333 :       rc = EvaluateHllExpression(hll, &i, tokenarray, LTEST, FALSE, buffer);

$LN99@HllExitDir:

; 2335 :         QueueTestLines(buffer);

	lea	rbx, QWORD PTR buffer$[rbp-256]
	npad	11
$LL102@HllExitDir:
	mov	edx, 10
	mov	rcx, rbx
	mov	rdi, rbx
	call	strchr
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN104@HllExitDir
	mov	BYTE PTR [rax], 0
	inc	rbx
$LN104@HllExitDir:
	cmp	BYTE PTR [rdi], 0
	je	SHORT $LN105@HllExitDir
	mov	rcx, rdi
	call	AddLineQueue
$LN105@HllExitDir:
	test	rbx, rbx
	jne	SHORT $LL102@HllExitDir

; 2336 :     }

	jmp	$LN65@HllExitDir
$LN52@HllExitDir:

; 2337 :     else
; 2338 :       hll->flags |= HLLF_ELSEOCCURED;

	or	DWORD PTR [rbx+112], 1

; 2339 : 
; 2340 :     break;

	jmp	$LN65@HllExitDir
	npad	2
$LL192@HllExitDir:

; 2341 :   case T_DOT_BREAK:
; 2342 :   case T_DOT_CONTINUE:
; 2343 :     for (; hll && hll->cmd == HLL_IF; hll = hll->next);

	cmp	DWORD PTR [rbx+104], r14d
	jne	SHORT $LN56@HllExitDir
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL192@HllExitDir
$LN200@HllExitDir:

; 2344 :     if (hll == NULL) {
; 2345 :       return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError
	jmp	$LN198@HllExitDir
$LN56@HllExitDir:

; 2346 :     }
; 2347 :     /* v2.11: create 'exit' and 'test' labels delayed.
; 2348 :     */
; 2349 :     if (cmd == T_DOT_BREAK) {

	cmp	edi, 331				; 0000014bH
	jne	SHORT $LN57@HllExitDir

; 2350 :       hll->breakoccured = TRUE;

	mov	BYTE PTR [rbx+109], 1

; 2351 :       if (hll->labels[LEXIT] == 0)

	cmp	DWORD PTR [rbx+40], r14d
	jne	SHORT $LN59@HllExitDir

; 2352 :         hll->labels[LEXIT] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+40], eax
$LN59@HllExitDir:

; 2353 :       idx = LEXIT;

	mov	edx, 1

; 2354 :     }

	jmp	SHORT $LN61@HllExitDir
$LN57@HllExitDir:

; 2355 :     else if (hll->cmd == HLL_FOR) {

	mov	eax, DWORD PTR [rbx+104]
	cmp	eax, r13d
	jne	SHORT $LN60@HllExitDir

; 2356 :       /* added by habran
; 2357 :       .CONTINUE label is created here for .FOR loops only if it exists.
; 2358 :       It is different than .WHILE because it has to first alter counters
; 2359 :       */
; 2360 :       if (hll->labels[LCONT] == 0) hll->labels[LCONT] = GetHllLabel();

	cmp	DWORD PTR [rbx+52], r14d
	jne	SHORT $LN62@HllExitDir
	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+52], eax
$LN62@HllExitDir:

; 2361 :       idx = (hll->labels[LCONT] ? LCONT : LSTART);

	cmp	DWORD PTR [rbx+52], r14d
	mov	edx, 2
	cmovne	edx, r13d

; 2362 :     }

	jmp	SHORT $LN61@HllExitDir
$LN60@HllExitDir:

; 2363 :     else {
; 2364 :       /* 'test' is not created for .WHILE loops here; because
; 2365 :       * if it doesn't exist, there's no condition to test.
; 2366 :       */
; 2367 :       if (hll->cmd == HLL_REPEAT && hll->labels[LTEST] == 0)

	cmp	eax, 2
	jne	SHORT $LN63@HllExitDir
	cmp	DWORD PTR [rbx+36], r14d
	jne	SHORT $LN63@HllExitDir

; 2368 :         hll->labels[LTEST] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+36], eax
$LN63@HllExitDir:

; 2369 :       idx = (hll->labels[LTEST] ? LTEST : LSTART);

	cmp	DWORD PTR [rbx+36], r14d
	mov	edx, 2
	cmovne	edx, r14d
$LN61@HllExitDir:

; 2370 :     }
; 2371 : 
; 2372 :     /* .BREAK .IF ... or .CONTINUE .IF ? */
; 2373 :     i++;

	mov	ecx, DWORD PTR i$[rbp-256]
	inc	ecx

; 2374 :     if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, ecx
	shl	rax, 5
	mov	DWORD PTR i$[rbp-256], ecx
	lea	rcx, QWORD PTR [rax+r12]
	movzx	eax, BYTE PTR [rax+r12]
	test	al, al
	je	$LN64@HllExitDir

; 2375 :       if (tokenarray[i].token == T_DIRECTIVE && tokenarray[i].tokval == T_DOT_IF) {

	cmp	al, 3
	jne	$LN65@HllExitDir
	cmp	DWORD PTR [rcx+16], 327			; 00000147H
	jne	$LN65@HllExitDir

; 2376 :         enum hll_cmd savedcmd = hll->cmd;

	mov	r15d, DWORD PTR [rbx+104]

; 2377 :         hll->cmd = HLL_BREAK;
; 2378 :         i++;
; 2379 :         /* v2.11: set rc and don't exit if an error occurs; see hll3.aso */
; 2380 :         rc = EvaluateHllExpression(hll, &i, tokenarray, idx, TRUE, buffer);

	lea	rax, QWORD PTR hllop$1[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	r9d, edx
	mov	DWORD PTR [rbx+104], 3
	lea	rax, QWORD PTR buffer$[rbp-256]
	inc	DWORD PTR i$[rbp-256]
	lea	rdx, QWORD PTR i$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	r8, r12
	mov	rcx, rbx
	mov	BYTE PTR [rsp+32], 1
	mov	QWORD PTR hllop$1[rsp], r14
	mov	DWORD PTR hllop$1[rsp+8], r14d
	mov	BYTE PTR buffer$[rbp-256], r14b
	call	GetExpression
	cmp	eax, -1
	jne	SHORT $LN114@HllExitDir
	or	r14d, eax

; 2383 :         hll->cmd = savedcmd;

	mov	DWORD PTR [rbx+104], r15d

; 2384 :       }
; 2385 :     }

	jmp	$LN65@HllExitDir

; 2377 :         hll->cmd = HLL_BREAK;
; 2378 :         i++;
; 2379 :         /* v2.11: set rc and don't exit if an error occurs; see hll3.aso */
; 2380 :         rc = EvaluateHllExpression(hll, &i, tokenarray, idx, TRUE, buffer);

$LN114@HllExitDir:
	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], r14b
	je	SHORT $LN115@HllExitDir
	mov	ecx, 199				; 000000c7H
	call	EmitError
	mov	r14d, eax

; 2381 :         if (rc == NOT_ERROR)

	test	eax, eax
	jne	SHORT $LN119@HllExitDir

; 2377 :         hll->cmd = HLL_BREAK;
; 2378 :         i++;
; 2379 :         /* v2.11: set rc and don't exit if an error occurs; see hll3.aso */
; 2380 :         rc = EvaluateHllExpression(hll, &i, tokenarray, idx, TRUE, buffer);

$LN115@HllExitDir:

; 2382 :           QueueTestLines(buffer);

	lea	rdi, QWORD PTR buffer$[rbp-256]
	npad	4
$LL118@HllExitDir:
	mov	edx, 10
	mov	rcx, rdi
	mov	rsi, rdi
	call	strchr
	mov	rdi, rax
	test	rax, rax
	je	SHORT $LN120@HllExitDir
	mov	BYTE PTR [rax], 0
	inc	rdi
$LN120@HllExitDir:
	cmp	BYTE PTR [rsi], 0
	je	SHORT $LN121@HllExitDir
	mov	rcx, rsi
	call	AddLineQueue
$LN121@HllExitDir:
	test	rdi, rdi
	jne	SHORT $LL118@HllExitDir
$LN119@HllExitDir:

; 2383 :         hll->cmd = savedcmd;

	mov	DWORD PTR [rbx+104], r15d

; 2384 :       }
; 2385 :     }

	jmp	SHORT $LN65@HllExitDir
$LN64@HllExitDir:

; 2386 :     else {
; 2387 :       AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[idx], buff));

	movsxd	rax, edx
	lea	rcx, QWORD PTR buff$[rsp]
	lea	rdx, OFFSET FLAT:$SG11118
	mov	r8d, DWORD PTR [rbx+rax*4+36]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12198
	call	AddLineQueueX
$LN65@HllExitDir:

; 2388 :     }
; 2389 :     break;
; 2390 : #ifdef DEBUG_OUT
; 2391 :   default: /**/myassert(0); break;
; 2392 : #endif
; 2393 :   }
; 2394 :   if (tokenarray[i].token != T_FINAL && rc == NOT_ERROR) {

	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 0
	je	SHORT $LN68@HllExitDir
	test	r14d, r14d
	jne	SHORT $LN68@HllExitDir

; 2395 :     EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos);

	mov	rdx, QWORD PTR [rax+r12+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 2396 :     rc = ERROR;

	or	r14d, -1
$LN68@HllExitDir:

; 2397 :   }
; 2398 : 
; 2399 :   if (ModuleInfo.list)

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN69@HllExitDir

; 2400 :     LstWrite(LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL);

	call	GetCurrOffset
	mov	edx, eax
	xor	r8d, r8d
	mov	ecx, r13d
	call	LstWrite
$LN69@HllExitDir:

; 2401 : 
; 2402 :   /* v2.11: always run line-queue if it's not empty. */
; 2403 :   if (is_linequeue_populated())

	cmp	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN70@HllExitDir

; 2404 :     RunLineQueue();

	call	RunLineQueue
$LN70@HllExitDir:

; 2405 : 
; 2406 :   return(rc);

	mov	eax, r14d
$LN198@HllExitDir:
	mov	r13, QWORD PTR [rsp+1296]
	mov	rsi, QWORD PTR [rsp+1288]
	mov	r15, QWORD PTR [rsp+1304]

; 2407 : }

	add	rsp, 1232				; 000004d0H
	pop	r14
	pop	r12
	pop	rdi
	pop	rbx
	pop	rbp
	ret	0
	npad	3
$LN184@HllExitDir:
	DD	$LL192@HllExitDir
	DD	$LL192@HllExitDir
	DD	$LN47@HllExitDir
	DD	$LN47@HllExitDir
	DD	$LN65@HllExitDir
	DD	$LN65@HllExitDir
	DD	$LN65@HllExitDir
	DD	$LN65@HllExitDir
	DD	$LN65@HllExitDir
	DD	$LN65@HllExitDir
	DD	$LN23@HllExitDir
	DD	$LN19@HllExitDir
HllExitDir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
buff$ = 64
tv2219 = 80
tv2180 = 80
hllop$1 = 80
hllop$2 = 80
buffer$ = 96
i$ = 2224
tokenarray$ = 2232
acnt$1$ = 2240
bcnt$1$ = 2248
HllEndDir PROC

; 1605 : {

$LN391:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r15
	lea	rbp, QWORD PTR [rsp-1912]
	sub	rsp, 2168				; 00000878H

; 1606 :   //struct asym       *sym;
; 1607 :   struct hll_item     *hll;
; 1608 :   ret_code            rc = NOT_ERROR;
; 1609 :   int                 cmd = tokenarray[i].tokval;
; 1610 :   int                 j, n;
; 1611 :   int                 temp;
; 1612 :   int                 acnt = 0;
; 1613 :   int                 bcnt = 0;
; 1614 :   uint_16             lbl;
; 1615 : 
; 1616 :   char buff[16];
; 1617 :   //char buffer[MAX_LINE_LEN*2];
; 1618 : 
; 1619 : 
; 1620 :   char buffer[MAX_LINE_LEN * 2];
; 1621 : 
; 1622 :   DebugMsg1(("HllEndDir(%s) enter\n", tokenarray[i].string_ptr));
; 1623 : 
; 1624 :   if (HllStack == NULL) {

	mov	rbx, QWORD PTR ModuleInfo+224
	xor	esi, esi
	movsxd	rax, ecx
	mov	rdi, rdx
	shl	rax, 5
	mov	r12d, esi
	mov	DWORD PTR acnt$1$[rbp-256], esi
	mov	r15d, esi
	mov	DWORD PTR bcnt$1$[rbp-256], esi
	mov	ecx, DWORD PTR [rax+rdx+16]
	test	rbx, rbx
	jne	SHORT $LN32@HllEndDir

; 1625 :     DebugMsg(("HllEndDir: hll stack is empty\n"));
; 1626 :     return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError

; 2137 : }

	add	rsp, 2168				; 00000878H
	pop	r15
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN32@HllEndDir:

; 1627 :   }
; 1628 : 
; 1629 :   hll = HllStack;
; 1630 :   HllStack = hll->next;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR ModuleInfo+224, rax

; 1631 :   /* v2.06: move the item to the free stack */
; 1632 :   hll->next = HllFree;

	mov	rax, QWORD PTR ModuleInfo+232
	mov	QWORD PTR [rbx], rax

; 1633 :   HllFree = hll;
; 1634 : 
; 1635 :   switch (cmd) {

	lea	eax, DWORD PTR [rcx-335]
	mov	QWORD PTR [rsp+2152], r14
	mov	QWORD PTR ModuleInfo+232, rbx
	cmp	eax, 8
	ja	$LN373@HllEndDir
	lea	rdx, OFFSET FLAT:__ImageBase
	cdqe
	mov	ecx, DWORD PTR $LN372@HllEndDir[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN33@HllEndDir:

; 1636 :   case T_DOT_ENDIF:
; 1637 :     if (hll->cmd != HLL_IF) {

	cmp	DWORD PTR [rbx+104], esi
	jne	$LN389@HllEndDir

; 1638 :       DebugMsg(("HllEndDir: no .IF on the hll stack\n"));
; 1639 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));
; 1640 :     }
; 1641 :     i++;

	inc	DWORD PTR i$[rbp-256]

; 1642 :     /* if a test label isn't created yet, create it */
; 1643 :     if (hll->labels[LTEST]) {

	mov	r8d, DWORD PTR [rbx+36]
	test	r8d, r8d
	je	$LN373@HllEndDir

; 1644 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11824
	call	AddLineQueueX

; 1645 :     }
; 1646 :     break;

	jmp	$LN373@HllEndDir
$LN36@HllEndDir:

; 1647 :     // added by habran
; 1648 :   case T_DOT_ENDSWITCH:
; 1649 :     if (hll->cmd != HLL_SWITCH) {

	cmp	DWORD PTR [rbx+104], 5
	je	SHORT $LN37@HllEndDir

; 1650 :       DebugMsg(("HllExitDir stack error\n"));
; 1651 :       return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError
	jmp	$LN377@HllEndDir
$LN37@HllEndDir:

; 1652 :     }
; 1653 :     i++;

	inc	DWORD PTR i$[rbp-256]

; 1654 :     if (ModuleInfo.switch_style == ASMSWITCH) {

	test	DWORD PTR ModuleInfo+408, 524288	; 00080000H
	jne	SHORT $LN38@HllEndDir

; 1655 :       if (hll->labels[LEXIT] == 0)

	cmp	DWORD PTR [rbx+40], esi
	jne	SHORT $LN39@HllEndDir

; 1656 :         hll->labels[LEXIT] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+40], eax
$LN39@HllEndDir:

; 1657 :       AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+40]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11829
	call	AddLineQueueX
$LN38@HllEndDir:

; 1658 :     }
; 1659 :     if (hll->labels[LDEF] == 0) {

	cmp	DWORD PTR [rbx+56], esi
	jne	SHORT $LN40@HllEndDir

; 1660 :       hll->labels[LDEF] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352

; 1661 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LDEF], buff));

	lea	rdx, OFFSET FLAT:$SG11118
	inc	eax
	lea	rcx, QWORD PTR buff$[rsp]
	mov	DWORD PTR ModuleInfo+352, eax
	mov	r8d, eax
	mov	DWORD PTR [rbx+56], eax
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11831
	call	AddLineQueueX
$LN40@HllEndDir:

; 1662 :     }
; 1663 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSTART], buff));

	mov	r8d, DWORD PTR [rbx+44]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11832
	call	AddLineQueueX

; 1664 :     if (Parse_Pass) {

	cmp	DWORD PTR Parse_Pass, esi
	je	$LN81@HllEndDir

; 1665 :       if (hll->casecnt == 1)

	mov	r9d, DWORD PTR [rbx+100]
	cmp	r9d, 1
	jne	SHORT $LN42@HllEndDir

; 1666 :         hll->cflag = 1;

	mov	BYTE PTR [rbx+110], r9b
	jmp	SHORT $LN52@HllEndDir
$LN42@HllEndDir:

; 1667 :       else if (hll->casecnt == 2)

	cmp	r9d, 2
	jne	SHORT $LN44@HllEndDir

; 1668 :         hll->cflag = 2;

	mov	BYTE PTR [rbx+110], r9b
	jmp	SHORT $LN52@HllEndDir
$LN44@HllEndDir:

; 1669 :       else if (hll->casecnt == 3)

	cmp	r9d, 3
	jne	SHORT $LN46@HllEndDir

; 1670 :         hll->cflag = 3;

	mov	BYTE PTR [rbx+110], r9b
	jmp	SHORT $LN52@HllEndDir
$LN46@HllEndDir:

; 1671 :       else
; 1672 :       {
; 1673 :         if (hll->plabels) {

	mov	rdx, QWORD PTR [rbx+24]
	test	rdx, rdx
	je	SHORT $LN52@HllEndDir

; 1674 :           if ((ModuleInfo.Ofssize == USE32) || (hll->csize == 4)) {

	cmp	BYTE PTR ModuleInfo+404, 1
	je	SHORT $LN51@HllEndDir
	cmp	BYTE PTR [rbx+111], 4
	je	SHORT $LN51@HllEndDir

; 1677 :               hll->cflag = 4;
; 1678 :             else
; 1679 :               hll->cflag = 5;
; 1680 :           }
; 1681 : #if AMD64_SUPPORT
; 1682 :           else {     //USE64
; 1683 :             bubblesort64(hll, hll->plabels, hll->pcases64, hll->casecnt);

	mov	r8, QWORD PTR [rbx+16]
	mov	rcx, rbx
	call	bubblesort64

; 1684 :             if (hll->delta64 < 256)

	cmp	QWORD PTR [rbx+152], 256		; 00000100H

; 1685 :               hll->cflag = 4;
; 1686 :             else
; 1687 :               hll->cflag = 5;

	jmp	SHORT $LN379@HllEndDir
$LN51@HllEndDir:

; 1675 :             bubblesort(hll, hll->plabels, hll->pcases, hll->casecnt);

	mov	r8, QWORD PTR [rbx+8]
	mov	rcx, rbx
	call	bubblesort

; 1676 :             if (hll->delta < 256)

	cmp	DWORD PTR [rbx+124], 256		; 00000100H
$LN379@HllEndDir:
	setge	al
	add	al, 4
	mov	BYTE PTR [rbx+110], al
$LN52@HllEndDir:

; 1688 :           }
; 1689 : #endif
; 1690 :         }
; 1691 :       }
; 1692 :       if (hll->cflag == 1) {

	movzx	eax, BYTE PTR [rbx+110]
	cmp	al, 1
	jne	$LN56@HllEndDir

; 1693 :         if ((ModuleInfo.Ofssize == USE32) || (hll->csize == 4)) {

	cmp	BYTE PTR ModuleInfo+404, al
	je	SHORT $LN60@HllEndDir
	cmp	BYTE PTR [rbx+111], 4
	je	SHORT $LN60@HllEndDir

; 1697 :         }
; 1698 : #if AMD64_SUPPORT
; 1699 :         else
; 1700 :         {
; 1701 :           AddLineQueueX("mov rcx, %q", hll->pcases64[0]);

	mov	rdx, QWORD PTR [rbx+16]
	lea	rcx, OFFSET FLAT:$SG11856
	mov	rdx, QWORD PTR [rdx]
	call	AddLineQueueX

; 1702 :           AddLineQueueX("cmp rax, rcx");

	lea	rcx, OFFSET FLAT:$SG11857
	call	AddLineQueueX

; 1703 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	rax, QWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [rax]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11858
	call	AddLineQueueX

; 1704 :           AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG11859
	jmp	$LN380@HllEndDir
$LN60@HllEndDir:

; 1694 :           AddLineQueueX("cmp  eax,%d", hll->pcases[0]);

	mov	rax, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG11853
	mov	edx, DWORD PTR [rax]
	call	AddLineQueueX

; 1695 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	rax, QWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [rax]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11854
	call	AddLineQueueX

; 1696 :           AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG11855

; 1705 :         }
; 1706 : #endif
; 1707 :       }

	jmp	$LN380@HllEndDir
$LN56@HllEndDir:

; 1708 :       else if (hll->cflag == 2) {

	cmp	al, 2
	jne	$LN61@HllEndDir

; 1709 :         if ((ModuleInfo.Ofssize == USE32) || (hll->csize == 4)) {

	cmp	BYTE PTR ModuleInfo+404, 1
	je	$LN65@HllEndDir
	cmp	BYTE PTR [rbx+111], 4
	je	$LN65@HllEndDir

; 1715 :         }
; 1716 : #if AMD64_SUPPORT
; 1717 :         else
; 1718 :         {
; 1719 :           AddLineQueueX("mov rcx, %q", hll->pcases64[0]);

	mov	rdx, QWORD PTR [rbx+16]
	lea	rcx, OFFSET FLAT:$SG11870
	mov	rdx, QWORD PTR [rdx]
	call	AddLineQueueX

; 1720 :           AddLineQueueX("cmp rax, rcx");

	lea	rcx, OFFSET FLAT:$SG11871
	call	AddLineQueueX

; 1721 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	rax, QWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [rax]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11872
	call	AddLineQueueX

; 1722 :           AddLineQueueX("mov rcx, %q", hll->pcases64[1]);

	mov	rdx, QWORD PTR [rbx+16]
	lea	rcx, OFFSET FLAT:$SG11873
	mov	rdx, QWORD PTR [rdx+8]
	call	AddLineQueueX

; 1723 :           AddLineQueueX("cmp rax, rcx");

	lea	rcx, OFFSET FLAT:$SG11874
	call	AddLineQueueX

; 1724 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[1], buff));

	mov	rax, QWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [rax+2]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11875
	call	AddLineQueueX

; 1725 :           AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG11876
	jmp	$LN380@HllEndDir
$LN65@HllEndDir:

; 1710 :           AddLineQueueX("cmp  eax,%d", hll->pcases[0]);

	mov	rax, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG11865
	mov	edx, DWORD PTR [rax]
	call	AddLineQueueX

; 1711 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	rax, QWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [rax]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11866
	call	AddLineQueueX

; 1712 :           AddLineQueueX("cmp  eax,%d", hll->pcases[1]);

	mov	rax, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG11867
	mov	edx, DWORD PTR [rax+4]
	call	AddLineQueueX

; 1713 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[1], buff));

	mov	rax, QWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [rax+2]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11868
	call	AddLineQueueX

; 1714 :           AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG11869

; 1726 :         }
; 1727 : #endif
; 1728 :       }

	jmp	$LN380@HllEndDir
$LN61@HllEndDir:

; 1729 :       else if (hll->cflag == 3) {

	cmp	al, 3
	jne	$LN66@HllEndDir

; 1730 :         if ((ModuleInfo.Ofssize == USE32) || (hll->csize == 4)) {

	cmp	BYTE PTR ModuleInfo+404, 1
	je	$LN70@HllEndDir
	cmp	BYTE PTR [rbx+111], 4
	je	$LN70@HllEndDir

; 1738 :         }
; 1739 : #if AMD64_SUPPORT
; 1740 :         else
; 1741 :         {
; 1742 :           AddLineQueueX("mov rcx, %q", hll->pcases64[0]);

	mov	rdx, QWORD PTR [rbx+16]
	lea	rcx, OFFSET FLAT:$SG11889
	mov	rdx, QWORD PTR [rdx]
	call	AddLineQueueX

; 1743 :           AddLineQueueX("cmp rax, rcx");

	lea	rcx, OFFSET FLAT:$SG11890
	call	AddLineQueueX

; 1744 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	rax, QWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [rax]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11891
	call	AddLineQueueX

; 1745 :           AddLineQueueX("mov rcx, %q", hll->pcases64[1]);

	mov	rdx, QWORD PTR [rbx+16]
	lea	rcx, OFFSET FLAT:$SG11892
	mov	rdx, QWORD PTR [rdx+8]
	call	AddLineQueueX

; 1746 :           AddLineQueueX("cmp rax, rcx");

	lea	rcx, OFFSET FLAT:$SG11893
	call	AddLineQueueX

; 1747 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[1], buff));

	mov	rax, QWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [rax+2]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11894
	call	AddLineQueueX

; 1748 :           AddLineQueueX("mov rcx, %q", hll->pcases64[2]);

	mov	rdx, QWORD PTR [rbx+16]
	lea	rcx, OFFSET FLAT:$SG11895
	mov	rdx, QWORD PTR [rdx+16]
	call	AddLineQueueX

; 1749 :           AddLineQueueX("cmp rax, rcx");

	lea	rcx, OFFSET FLAT:$SG11896
	call	AddLineQueueX

; 1750 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[2], buff));

	mov	rax, QWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [rax+4]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11897
	call	AddLineQueueX

; 1751 :           AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG11898
	jmp	$LN380@HllEndDir
$LN70@HllEndDir:

; 1731 :           AddLineQueueX("cmp  eax,%d", hll->pcases[0]);

	mov	rax, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG11882
	mov	edx, DWORD PTR [rax]
	call	AddLineQueueX

; 1732 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	rax, QWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [rax]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11883
	call	AddLineQueueX

; 1733 :           AddLineQueueX("cmp  eax,%d", hll->pcases[1]);

	mov	rax, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG11884
	mov	edx, DWORD PTR [rax+4]
	call	AddLineQueueX

; 1734 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[1], buff));

	mov	rax, QWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [rax+2]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11885
	call	AddLineQueueX

; 1735 :           AddLineQueueX("cmp  eax,%d", hll->pcases[2]);

	mov	rax, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG11886
	mov	edx, DWORD PTR [rax+8]
	call	AddLineQueueX

; 1736 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[2], buff));

	mov	rax, QWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [rax+4]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11887
	call	AddLineQueueX

; 1737 :           AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG11888

; 1752 :         }
; 1753 : #endif
; 1754 :       }

	jmp	$LN380@HllEndDir
$LN66@HllEndDir:

; 1755 :       else if (hll->cflag == 4) {

	cmp	al, 4
	jne	$LN71@HllEndDir

; 1756 :         if (hll->csize == 4) {

	cmp	BYTE PTR [rbx+111], al
	jne	SHORT $LN73@HllEndDir

; 1757 :           AddLineQueueX("cmp eax,%d", hll->maxcase);

	mov	edx, DWORD PTR [rbx+116]
	lea	rcx, OFFSET FLAT:$SG11903
	call	AddLineQueueX

; 1758 :           AddLineQueueX("ja  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11904
	call	AddLineQueueX

; 1759 :           AddLineQueueX("sub eax,%d", hll->mincase);

	mov	edx, DWORD PTR [rbx+120]
	lea	rcx, OFFSET FLAT:$SG11905
	call	AddLineQueueX

; 1760 :           AddLineQueueX("jc  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG11906

; 1761 :         }

	jmp	$LN381@HllEndDir
$LN73@HllEndDir:

; 1762 : #if AMD64_SUPPORT
; 1763 :         else {
; 1764 :           AddLineQueueX("mov rcx, %q", hll->maxcase64);

	mov	rdx, QWORD PTR [rbx+136]
	lea	rcx, OFFSET FLAT:$SG11907
	call	AddLineQueueX

; 1765 :           AddLineQueueX("cmp rax, rcx");

	lea	rcx, OFFSET FLAT:$SG11908
	call	AddLineQueueX

; 1766 :           AddLineQueueX("ja  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11909
	call	AddLineQueueX

; 1767 :           AddLineQueueX("mov rcx, %q", hll->mincase64);

	mov	rdx, QWORD PTR [rbx+144]
	lea	rcx, OFFSET FLAT:$SG11910
	call	AddLineQueueX

; 1768 :           AddLineQueueX("sub rax, rcx");

	lea	rcx, OFFSET FLAT:$SG11911
	call	AddLineQueueX

; 1769 :           AddLineQueueX("jc  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG11912
$LN381@HllEndDir:
	lea	rdx, QWORD PTR buff$[rsp]
	call	AddLineQueueX

; 1770 :         }
; 1771 : #endif
; 1772 :         if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1

; 1773 :           AddLineQueueX("lea  edx,%s", GetLabelStr(hll->labels[LDATA2], buff));

	lea	rdx, OFFSET FLAT:$SG11118
	mov	r8d, DWORD PTR [rbx+64]
	lea	rcx, QWORD PTR buff$[rsp]
	jne	SHORT $LN75@HllEndDir
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11915
	call	AddLineQueueX

; 1774 :           AddLineQueueX("movzx  eax,BYTE PTR[edx+eax]");

	lea	rcx, OFFSET FLAT:$SG11916
	call	AddLineQueueX

; 1775 :           AddLineQueueX("lea  edx,%s", GetLabelStr(hll->labels[LDATA1], buff));

	mov	r8d, DWORD PTR [rbx+60]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11917
	call	AddLineQueueX

; 1776 :           AddLineQueueX("jmp  dword ptr[edx+eax*4]");

	lea	rcx, OFFSET FLAT:$SG11918
	call	AddLineQueueX

; 1777 :         }

	jmp	$LN81@HllEndDir
$LN75@HllEndDir:

; 1778 : #if AMD64_SUPPORT
; 1779 :         else {
; 1780 :           AddLineQueueX("lea  rdx,%s", GetLabelStr(hll->labels[LDATA2], buff));

	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11919
	call	AddLineQueueX

; 1781 :           AddLineQueueX("movzx  rax,byte ptr[rdx+rax]");

	lea	rcx, OFFSET FLAT:$SG11920
	call	AddLineQueueX

; 1782 :           AddLineQueueX("lea  rdx,%s", GetLabelStr(hll->labels[LDATA1], buff));

	mov	r8d, DWORD PTR [rbx+60]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11921
	call	AddLineQueueX

; 1783 :           AddLineQueueX("jmp  qword ptr[rdx+rax*8]");

	lea	rcx, OFFSET FLAT:$SG11922
	call	AddLineQueueX

; 1784 :         }
; 1785 : #endif
; 1786 :       }

	jmp	$LN81@HllEndDir
$LN71@HllEndDir:

; 1787 :       /* simple binary tree
; 1788 :       while (low <= high) {
; 1789 :       int mid = (low + high) / 2;
; 1790 :       if (hll->pcases[mid] == hll->casecnt)
; 1791 :       return mid;
; 1792 :       else if (hll->pcases[mid] < x)
; 1793 :       low = mid + 1;
; 1794 :       else high = mid - 1;
; 1795 :       }*/
; 1796 :       else if (hll->cflag == 5) {

	cmp	al, 5
	jne	$LN81@HllEndDir

; 1797 :         if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	$LN78@HllEndDir

; 1798 :           AddLineQueueX("push	ebx");

	lea	rcx, OFFSET FLAT:$SG11926
	call	AddLineQueueX

; 1799 :           AddLineQueueX("push	esi");

	lea	rcx, OFFSET FLAT:$SG11927
	call	AddLineQueueX

; 1800 :           AddLineQueueX("push	edi");

	lea	rcx, OFFSET FLAT:$SG11928
	call	AddLineQueueX

; 1801 :           AddLineQueueX("mov     esi,eax");

	lea	rcx, OFFSET FLAT:$SG11929
	call	AddLineQueueX

; 1802 :           AddLineQueueX("mov     ebx,%d", hll->casecnt - 1);//int high = len - 1;

	mov	edx, DWORD PTR [rbx+100]
	lea	rcx, OFFSET FLAT:$SG11930
	dec	edx
	call	AddLineQueueX

; 1803 :           AddLineQueueX("xor     ecx,ecx");//int low = 0;

	lea	rcx, OFFSET FLAT:$SG11931
	call	AddLineQueueX

; 1804 :           AddLineQueueX("lea     edi,%s", GetLabelStr(hll->labels[LDATA2], buff));//int hll->pcases

	mov	r8d, DWORD PTR [rbx+64]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11932
	call	AddLineQueueX

; 1805 :           AddLineQueueX("test    ebx,ebx");//while (low <= high) {

	lea	rcx, OFFSET FLAT:$SG11933
	call	AddLineQueueX

; 1806 :           AddLineQueueX("js      %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG11934

; 1807 :         }

	jmp	$LN380@HllEndDir
$LN78@HllEndDir:

; 1808 : #if AMD64_SUPPORT
; 1809 :         else {
; 1810 :           if (hll->csize == 4) {

	cmp	BYTE PTR [rbx+111], 4
	jne	SHORT $LN80@HllEndDir

; 1811 :             AddLineQueueX("mov     r8d,eax");

	lea	rcx, OFFSET FLAT:$SG11937
	call	AddLineQueueX

; 1812 :             AddLineQueueX("mov     r10d,%d", hll->casecnt - 1);//int high = len - 1;

	mov	edx, DWORD PTR [rbx+100]
	lea	rcx, OFFSET FLAT:$SG11938
	dec	edx
	call	AddLineQueueX

; 1813 :             AddLineQueueX("xor     r9d,r9d");//int low = 0;

	lea	rcx, OFFSET FLAT:$SG11939
	call	AddLineQueueX

; 1814 :             AddLineQueueX("lea     r11,%s", GetLabelStr(hll->labels[LDATA2], buff));//int hll->pcases

	mov	r8d, DWORD PTR [rbx+64]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11940
	call	AddLineQueueX

; 1815 :             AddLineQueueX("test    r10d,r10d");//while (low <= high) {

	lea	rcx, OFFSET FLAT:$SG11941
	call	AddLineQueueX

; 1816 :             AddLineQueueX("js      %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG11942

; 1817 :           }

	jmp	SHORT $LN380@HllEndDir
$LN80@HllEndDir:

; 1818 :           else {
; 1819 :             AddLineQueueX("mov     r8,rax");

	lea	rcx, OFFSET FLAT:$SG11943
	call	AddLineQueueX

; 1820 :             AddLineQueueX("mov     r10d,%d", hll->casecnt - 1);//int high = len - 1;

	mov	edx, DWORD PTR [rbx+100]
	lea	rcx, OFFSET FLAT:$SG11944
	dec	edx
	call	AddLineQueueX

; 1821 :             AddLineQueueX("xor     r9d,r9d");//int low = 0;

	lea	rcx, OFFSET FLAT:$SG11945
	call	AddLineQueueX

; 1822 :             AddLineQueueX("lea     r11,%s", GetLabelStr(hll->labels[LDATA2], buff));//int hll->pcases

	mov	r8d, DWORD PTR [rbx+64]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11946
	call	AddLineQueueX

; 1823 :             AddLineQueueX("test    r10,r10");//while (low <= high) {

	lea	rcx, OFFSET FLAT:$SG11947
	call	AddLineQueueX

; 1824 :             AddLineQueueX("js      %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG11948
$LN380@HllEndDir:
	lea	rdx, QWORD PTR buff$[rsp]
	call	AddLineQueueX
$LN81@HllEndDir:

; 1825 :           }
; 1826 :         }
; 1827 : #endif
; 1828 :       }
; 1829 :     } //end if Parse_Pass
; 1830 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTOP], buff));

	mov	r8d, DWORD PTR [rbx+68]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11949
	call	AddLineQueueX

; 1831 :     if (Parse_Pass) {

	cmp	DWORD PTR Parse_Pass, esi
	je	$LN87@HllEndDir

; 1832 :       if (hll->cflag == 5) {

	cmp	BYTE PTR [rbx+110], 5
	jne	$LN87@HllEndDir

; 1833 :         if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	$LN84@HllEndDir

; 1834 :           AddLineQueueX("lea     eax,[ecx + ebx]");//int eax = (ecx + ebx) / 2;

	lea	rcx, OFFSET FLAT:$SG11954
	call	AddLineQueueX

; 1835 :           AddLineQueueX("cdq");

	lea	rcx, OFFSET FLAT:$SG11955
	call	AddLineQueueX

; 1836 :           AddLineQueueX("sub     eax,edx");

	lea	rcx, OFFSET FLAT:$SG11956
	call	AddLineQueueX

; 1837 :           AddLineQueueX("sar     eax,1");

	lea	rcx, OFFSET FLAT:$SG11957
	call	AddLineQueueX

; 1838 :           AddLineQueueX("cmp     [edi+eax*4],esi");

	lea	rcx, OFFSET FLAT:$SG11958
	call	AddLineQueueX

; 1839 :           AddLineQueueX("je  %s", GetLabelStr(hll->labels[LJUMP], buff));

	mov	r8d, DWORD PTR [rbx+72]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11959
	call	AddLineQueueX

; 1840 :           AddLineQueueX("jge %s", GetLabelStr(hll->labels[LSKIP], buff));//else if (hll->pcases[mid] < hll->casecnt) 

	mov	r8d, DWORD PTR [rbx+48]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11960
	call	AddLineQueueX

; 1841 :           AddLineQueueX("lea     ecx,[eax+1]");                          //low = mid + 1

	lea	rcx, OFFSET FLAT:$SG11961
	call	AddLineQueueX

; 1842 :           AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LCONT], buff));

	mov	r8d, DWORD PTR [rbx+52]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG11962

; 1843 :         }

	jmp	$LN382@HllEndDir
$LN84@HllEndDir:

; 1844 : #if AMD64_SUPPORT
; 1845 :         else {
; 1846 :           if (hll->csize == 4) {

	cmp	BYTE PTR [rbx+111], 4
	jne	$LN86@HllEndDir

; 1847 :             AddLineQueueX("lea     eax,[r10+r9]");//int mid = (low + high) / 2;

	lea	rcx, OFFSET FLAT:$SG11965
	call	AddLineQueueX

; 1848 :             AddLineQueueX("cdq");

	lea	rcx, OFFSET FLAT:$SG11966
	call	AddLineQueueX

; 1849 :             AddLineQueueX("sub     eax,edx");

	lea	rcx, OFFSET FLAT:$SG11967
	call	AddLineQueueX

; 1850 :             AddLineQueueX("sar     eax,1");

	lea	rcx, OFFSET FLAT:$SG11968
	call	AddLineQueueX

; 1851 :             AddLineQueueX("movsxd  rcx,eax");//if (hll->pcases[mid] == x) return mid;

	lea	rcx, OFFSET FLAT:$SG11969
	call	AddLineQueueX

; 1852 :             AddLineQueueX("cmp     [r11+rcx*4],r8d");

	lea	rcx, OFFSET FLAT:$SG11970
	call	AddLineQueueX

; 1853 :             AddLineQueueX("je  %s", GetLabelStr(hll->labels[LJUMP], buff));

	mov	r8d, DWORD PTR [rbx+72]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11971
	call	AddLineQueueX

; 1854 :             AddLineQueueX("jge %s", GetLabelStr(hll->labels[LSKIP], buff));//else if (hll->pcases[mid] < hll->casecnt) 

	mov	r8d, DWORD PTR [rbx+48]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11972
	call	AddLineQueueX

; 1855 :             AddLineQueueX("lea     r9d,[rax+1]");                          //low = mid + 1

	lea	rcx, OFFSET FLAT:$SG11973
	call	AddLineQueueX

; 1856 :             AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LCONT], buff));

	mov	r8d, DWORD PTR [rbx+52]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG11974

; 1857 :           }

	jmp	$LN382@HllEndDir
$LN86@HllEndDir:

; 1858 :           else {
; 1859 :             AddLineQueueX("lea     rax,[r10+r9]");//int mid = (low + high) / 2;

	lea	rcx, OFFSET FLAT:$SG11975
	call	AddLineQueueX

; 1860 :             AddLineQueueX("cdq");

	lea	rcx, OFFSET FLAT:$SG11976
	call	AddLineQueueX

; 1861 :             AddLineQueueX("sub     rax,rdx");

	lea	rcx, OFFSET FLAT:$SG11977
	call	AddLineQueueX

; 1862 :             AddLineQueueX("sar     rax,1");

	lea	rcx, OFFSET FLAT:$SG11978
	call	AddLineQueueX

; 1863 :             AddLineQueueX("mov     rcx,rax");//if (hll->pcases[mid] == x) return mid;

	lea	rcx, OFFSET FLAT:$SG11979
	call	AddLineQueueX

; 1864 :             AddLineQueueX("cmp     [r11+rcx*8],r8");

	lea	rcx, OFFSET FLAT:$SG11980
	call	AddLineQueueX

; 1865 :             AddLineQueueX("je  %s", GetLabelStr(hll->labels[LJUMP], buff));

	mov	r8d, DWORD PTR [rbx+72]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11981
	call	AddLineQueueX

; 1866 :             AddLineQueueX("jge %s", GetLabelStr(hll->labels[LSKIP], buff));//else if (hll->pcases[mid] < hll->casecnt) 

	mov	r8d, DWORD PTR [rbx+48]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11982
	call	AddLineQueueX

; 1867 :             AddLineQueueX("lea     r9,[rax+1]");                          //low = mid + 1

	lea	rcx, OFFSET FLAT:$SG11983
	call	AddLineQueueX

; 1868 :             AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LCONT], buff));

	mov	r8d, DWORD PTR [rbx+52]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG11984
$LN382@HllEndDir:
	lea	rdx, QWORD PTR buff$[rsp]
	call	AddLineQueueX
$LN87@HllEndDir:

; 1869 : 
; 1870 :           }
; 1871 :         }
; 1872 : #endif
; 1873 :       }
; 1874 :     }
; 1875 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LJUMP], buff));

	mov	r8d, DWORD PTR [rbx+72]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11985
	call	AddLineQueueX

; 1876 :     if (Parse_Pass) {

	cmp	DWORD PTR Parse_Pass, esi
	je	$LN91@HllEndDir

; 1877 :       if (hll->cflag == 5) {

	cmp	BYTE PTR [rbx+110], 5
	jne	SHORT $LN91@HllEndDir

; 1878 :         if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1

; 1879 :           AddLineQueueX("lea edx,%s", GetLabelStr(hll->labels[LDATA1], buff));

	lea	rdx, OFFSET FLAT:$SG11118
	mov	r8d, DWORD PTR [rbx+60]
	lea	rcx, QWORD PTR buff$[rsp]
	jne	SHORT $LN90@HllEndDir
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11990
	call	AddLineQueueX

; 1880 :           AddLineQueueX("pop	edi");

	lea	rcx, OFFSET FLAT:$SG11991
	call	AddLineQueueX

; 1881 :           AddLineQueueX("pop	esi");

	lea	rcx, OFFSET FLAT:$SG11992
	call	AddLineQueueX

; 1882 :           AddLineQueueX("pop	ebx");

	lea	rcx, OFFSET FLAT:$SG11993
	call	AddLineQueueX

; 1883 :           AddLineQueueX("jmp dword ptr[edx+eax*4]");

	lea	rcx, OFFSET FLAT:$SG11994

; 1884 :         }

	jmp	SHORT $LN383@HllEndDir
$LN90@HllEndDir:

; 1885 : #if AMD64_SUPPORT
; 1886 :         else {
; 1887 :           AddLineQueueX("lea     r11,%s", GetLabelStr(hll->labels[LDATA1], buff));

	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11995
	call	AddLineQueueX

; 1888 :           AddLineQueueX("jmp     qword ptr[r11+rcx*8]");

	lea	rcx, OFFSET FLAT:$SG11996
$LN383@HllEndDir:
	call	AddLineQueueX
$LN91@HllEndDir:

; 1889 :         }
; 1890 : #endif
; 1891 :       }
; 1892 :     }
; 1893 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSKIP], buff));

	mov	r8d, DWORD PTR [rbx+48]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11997
	call	AddLineQueueX

; 1894 :     if (Parse_Pass) {

	cmp	DWORD PTR Parse_Pass, esi
	je	SHORT $LN97@HllEndDir

; 1895 :       if (hll->cflag == 5) {

	cmp	BYTE PTR [rbx+110], 5
	jne	SHORT $LN97@HllEndDir

; 1896 :         if (ModuleInfo.Ofssize == USE32)

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	SHORT $LN94@HllEndDir

; 1897 :           AddLineQueueX("lea     ebx,[eax-1]");//else high = mid - 1;

	lea	rcx, OFFSET FLAT:$SG12002
	jmp	SHORT $LN384@HllEndDir
$LN94@HllEndDir:

; 1898 : #if AMD64_SUPPORT
; 1899 :         else {
; 1900 :           if (hll->csize == 4)

	cmp	BYTE PTR [rbx+111], 4

; 1901 :             AddLineQueueX("lea     r10d,[rax-1]");//else high = mid - 1;

	lea	rcx, OFFSET FLAT:$SG12005
	je	SHORT $LN384@HllEndDir

; 1902 :           else
; 1903 :             AddLineQueueX("lea     r10,[rax-1]");//else high = mid - 1;

	lea	rcx, OFFSET FLAT:$SG12006
$LN384@HllEndDir:
	call	AddLineQueueX
$LN97@HllEndDir:

; 1904 :         }
; 1905 : #endif
; 1906 :       }
; 1907 :     }
; 1908 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LCONT], buff));

	mov	r8d, DWORD PTR [rbx+52]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12007
	call	AddLineQueueX

; 1909 :     if (Parse_Pass) {

	cmp	DWORD PTR Parse_Pass, esi
	je	$LN101@HllEndDir

; 1910 :       if (hll->cflag == 5) {

	cmp	BYTE PTR [rbx+110], 5
	jne	$LN101@HllEndDir

; 1911 :         if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	SHORT $LN100@HllEndDir

; 1912 :           AddLineQueueX("cmp  ecx,ebx");

	lea	rcx, OFFSET FLAT:$SG12012
	call	AddLineQueueX

; 1913 :           AddLineQueueX("jle %s", GetLabelStr(hll->labels[LTOP], buff));

	mov	r8d, DWORD PTR [rbx+68]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12013
	call	AddLineQueueX

; 1914 :           AddLineQueueX("pop	edi");

	lea	rcx, OFFSET FLAT:$SG12014
	call	AddLineQueueX

; 1915 :           AddLineQueueX("pop	esi");

	lea	rcx, OFFSET FLAT:$SG12015
	call	AddLineQueueX

; 1916 :           AddLineQueueX("pop	ebx");

	lea	rcx, OFFSET FLAT:$SG12016
	call	AddLineQueueX

; 1917 :           AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG12017

; 1918 :         }

	jmp	SHORT $LN385@HllEndDir
$LN100@HllEndDir:

; 1919 : #if AMD64_SUPPORT
; 1920 :         else
; 1921 :         {
; 1922 :           if (hll->csize == 4)

	cmp	BYTE PTR [rbx+111], 4

; 1923 :             AddLineQueueX("cmp  r9d,r10d");

	lea	rcx, OFFSET FLAT:$SG12020
	je	SHORT $LN386@HllEndDir

; 1924 :           else
; 1925 :             AddLineQueueX("cmp  r9,r10");

	lea	rcx, OFFSET FLAT:$SG12021
$LN386@HllEndDir:
	call	AddLineQueueX

; 1926 : 
; 1927 :           AddLineQueueX("jle %s", GetLabelStr(hll->labels[LTOP], buff));

	mov	r8d, DWORD PTR [rbx+68]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12022
	call	AddLineQueueX

; 1928 :           AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG12023
$LN385@HllEndDir:
	lea	rdx, QWORD PTR buff$[rsp]
	call	AddLineQueueX
$LN101@HllEndDir:

; 1929 :         }
; 1930 : #endif
; 1931 :       }
; 1932 :     }
; 1933 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LDATA1], buff));

	mov	r8d, DWORD PTR [rbx+60]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12024
	call	AddLineQueueX

; 1934 :     if (hll->cflag > 3) {

	movzx	eax, BYTE PTR [rbx+110]
	cmp	al, 3
	jle	$LN106@HllEndDir

; 1935 :       if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1

; 1936 :         lbl = 0;

	movzx	edx, si
	jne	$LN105@HllEndDir

; 1937 :         if (hll->cflag == 4) {

	cmp	al, 4
	jne	SHORT $LN107@HllEndDir

; 1938 :           for (j = 0; j < hll->casecnt; j++) {

	mov	r14d, esi
	cmp	DWORD PTR [rbx+100], esi
	jbe	$LN8@HllEndDir
	mov	rdi, rsi
$LL6@HllEndDir:

; 1939 :             if (hll->plabels[j] != lbl) {

	mov	rax, QWORD PTR [rbx+24]
	movzx	ecx, WORD PTR [rdi+rax]
	cmp	cx, dx
	je	SHORT $LN109@HllEndDir

; 1940 :               AddLineQueueX(" dd %s", GetLabelStr(hll->plabels[j], buff));

	movzx	r8d, cx
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12031
	call	AddLineQueueX

; 1941 :               acnt++;

	inc	r12d
$LN109@HllEndDir:

; 1942 :             }
; 1943 :             lbl = hll->plabels[j];

	mov	rax, QWORD PTR [rbx+24]
	inc	r14d
	movzx	edx, WORD PTR [rdi+rax]
	add	rdi, 2
	cmp	r14d, DWORD PTR [rbx+100]
	jb	SHORT $LL6@HllEndDir
	mov	DWORD PTR acnt$1$[rbp-256], r12d

; 1944 :           }
; 1945 :         }

	jmp	SHORT $LN8@HllEndDir
$LN107@HllEndDir:

; 1946 :         else {
; 1947 :           for (j = 0; j < hll->casecnt; j++)

	mov	edi, esi
	cmp	DWORD PTR [rbx+100], esi
	jbe	SHORT $LN8@HllEndDir
	mov	r14, rsi
	npad	1
$LL9@HllEndDir:

; 1948 :             AddLineQueueX(" dd %s", GetLabelStr(hll->plabels[j], buff));

	mov	rax, QWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [r14+rax]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12032
	call	AddLineQueueX
	inc	edi
	lea	r14, QWORD PTR [r14+2]
	cmp	edi, DWORD PTR [rbx+100]
	jb	SHORT $LL9@HllEndDir
$LN8@HllEndDir:

; 1949 :         }
; 1950 :         AddLineQueueX(" dd %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG12033

; 1951 :       }

	jmp	$LN387@HllEndDir
$LN105@HllEndDir:

; 1952 : #if AMD64_SUPPORT
; 1953 :       else {
; 1954 :         lbl = 0;
; 1955 :         if (hll->cflag == 4) {

	cmp	al, 4
	jne	SHORT $LN110@HllEndDir

; 1956 :           for (j = 0; j < hll->casecnt; j++) {

	mov	r14d, esi
	cmp	DWORD PTR [rbx+100], esi
	jbe	$LN14@HllEndDir
	mov	rdi, rsi
	npad	6
$LL12@HllEndDir:

; 1957 :             if (hll->plabels[j] != lbl) {

	mov	rax, QWORD PTR [rbx+24]
	movzx	ecx, WORD PTR [rdi+rax]
	cmp	cx, dx
	je	SHORT $LN112@HllEndDir

; 1958 :               AddLineQueueX(" dq %s", GetLabelStr(hll->plabels[j], buff));

	movzx	r8d, cx
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12037
	call	AddLineQueueX

; 1959 :               acnt++;

	inc	r12d
$LN112@HllEndDir:

; 1960 :             }
; 1961 :             lbl = hll->plabels[j];

	mov	rax, QWORD PTR [rbx+24]
	inc	r14d
	movzx	edx, WORD PTR [rdi+rax]
	add	rdi, 2
	cmp	r14d, DWORD PTR [rbx+100]
	jb	SHORT $LL12@HllEndDir
	mov	DWORD PTR acnt$1$[rbp-256], r12d

; 1962 :           }
; 1963 :         }

	jmp	SHORT $LN14@HllEndDir
$LN110@HllEndDir:

; 1964 :         else {
; 1965 :           for (j = 0; j < hll->casecnt; j++)

	mov	edi, esi
	cmp	DWORD PTR [rbx+100], esi
	jbe	SHORT $LN14@HllEndDir
	mov	r14, rsi
	npad	2
$LL15@HllEndDir:

; 1966 :             AddLineQueueX(" dq %s", GetLabelStr(hll->plabels[j], buff));

	mov	rax, QWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [r14+rax]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12038
	call	AddLineQueueX
	inc	edi
	lea	r14, QWORD PTR [r14+2]
	cmp	edi, DWORD PTR [rbx+100]
	jb	SHORT $LL15@HllEndDir
$LN14@HllEndDir:

; 1967 :         }
; 1968 :         AddLineQueueX(" dq %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rcx, OFFSET FLAT:$SG12039
$LN387@HllEndDir:
	lea	rdx, QWORD PTR buff$[rsp]
	call	AddLineQueueX
$LN106@HllEndDir:

; 1969 :       }
; 1970 : #endif
; 1971 :     }
; 1972 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LDATA2], buff));

	mov	r8d, DWORD PTR [rbx+64]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12040
	call	AddLineQueueX

; 1973 :     if (hll->cflag == 4) {

	cmp	BYTE PTR [rbx+110], 4
	jne	$LN22@HllEndDir

; 1974 :       n = 0;
; 1975 :       if (hll->csize == 4) {

	cmp	BYTE PTR [rbx+111], 4
	mov	r14d, esi
	mov	QWORD PTR [rsp+2160], r13

; 1976 :         for (j = 0; j < hll->casecnt; j++) {

	mov	r12d, esi
	jne	$LN114@HllEndDir
	cmp	DWORD PTR [rbx+100], esi
	jbe	$LN378@HllEndDir
	mov	rdi, rsi
	mov	QWORD PTR tv2219[rsp], rsi
	mov	r13, rsi
	mov	esi, DWORD PTR acnt$1$[rbp-256]
	npad	2
$LL18@HllEndDir:

; 1977 :           temp = hll->pcases[j] - hll->mincase;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+r13]
	sub	ecx, DWORD PTR [rbx+120]

; 1978 :           while (n < temp) {

	cmp	r14d, ecx
	jge	SHORT $LN20@HllEndDir

; 1977 :           temp = hll->pcases[j] - hll->mincase;

	sub	ecx, r14d
	movsx	r15d, sil
	mov	edi, ecx

; 1978 :           while (n < temp) {

	add	r14d, ecx
	npad	4
$LL19@HllEndDir:

; 1979 :             AddLineQueueX(" db %d", (int_8)acnt);

	mov	edx, r15d
	lea	rcx, OFFSET FLAT:$SG12044
	call	AddLineQueueX
	sub	rdi, 1
	jne	SHORT $LL19@HllEndDir
	mov	rdi, QWORD PTR tv2219[rsp]
	mov	r15d, DWORD PTR bcnt$1$[rbp-256]
$LN20@HllEndDir:

; 1980 :             n++;
; 1981 :           }
; 1982 :           AddLineQueueX(" db %d", (int_8)bcnt);

	movsx	edx, r15b
	lea	rcx, OFFSET FLAT:$SG12045
	call	AddLineQueueX

; 1983 :           n++;
; 1984 :           if (hll->plabels[j] != hll->plabels[j + 1])

	mov	rcx, QWORD PTR [rbx+24]
	lea	rdx, QWORD PTR [rdi+2]
	inc	r14d
	movzx	eax, WORD PTR [rcx+rdx]
	cmp	WORD PTR [rcx+rdi], ax
	je	SHORT $LN16@HllEndDir

; 1985 :             bcnt++;

	inc	r15d
	mov	DWORD PTR bcnt$1$[rbp-256], r15d
$LN16@HllEndDir:

; 1976 :         for (j = 0; j < hll->casecnt; j++) {

	inc	r12d
	mov	QWORD PTR tv2219[rsp], rdx
	add	r13, 4
	mov	rdi, rdx
	cmp	r12d, DWORD PTR [rbx+100]
	jb	$LL18@HllEndDir

; 1986 :         }
; 1987 :       }

	jmp	$LN388@HllEndDir
$LN114@HllEndDir:

; 1988 : #if AMD64_SUPPORT
; 1989 :       else {
; 1990 :         n = 0;
; 1991 :         for (j = 0; j < hll->casecnt; j++) {

	cmp	DWORD PTR [rbx+100], esi
	jbe	$LN378@HllEndDir
	mov	rdi, rsi
	mov	QWORD PTR tv2180[rsp], rsi
	mov	r13, rsi
	mov	esi, DWORD PTR acnt$1$[rbp-256]
	npad	8
$LL23@HllEndDir:

; 1992 :           temp = (int)hll->pcases64[j] - hll->mincase64;

	mov	rax, QWORD PTR [rbx+16]
	mov	ecx, DWORD PTR [rax+r13]
	sub	ecx, DWORD PTR [rbx+144]

; 1993 :           while (n < temp) {

	cmp	r14d, ecx
	jge	SHORT $LN25@HllEndDir

; 1992 :           temp = (int)hll->pcases64[j] - hll->mincase64;

	sub	ecx, r14d
	movsx	r15d, sil
	mov	edi, ecx

; 1993 :           while (n < temp) {

	add	r14d, ecx
	npad	1
$LL24@HllEndDir:

; 1994 :             AddLineQueueX(" db %d", (int_8)acnt);

	mov	edx, r15d
	lea	rcx, OFFSET FLAT:$SG12047
	call	AddLineQueueX
	sub	rdi, 1
	jne	SHORT $LL24@HllEndDir
	mov	rdi, QWORD PTR tv2180[rsp]
	mov	r15d, DWORD PTR bcnt$1$[rbp-256]
$LN25@HllEndDir:

; 1995 :             n++;
; 1996 :           }
; 1997 :           AddLineQueueX(" db %d", (int_8)bcnt);

	movsx	edx, r15b
	lea	rcx, OFFSET FLAT:$SG12048
	call	AddLineQueueX

; 1998 :           n++;
; 1999 :           if (hll->plabels[j] != hll->plabels[j + 1]) bcnt++;

	mov	rcx, QWORD PTR [rbx+24]
	lea	rdx, QWORD PTR [rdi+2]
	inc	r14d
	movzx	eax, WORD PTR [rcx+rdx]
	cmp	WORD PTR [rcx+rdi], ax
	je	SHORT $LN21@HllEndDir
	inc	r15d
	mov	DWORD PTR bcnt$1$[rbp-256], r15d
$LN21@HllEndDir:

; 1988 : #if AMD64_SUPPORT
; 1989 :       else {
; 1990 :         n = 0;
; 1991 :         for (j = 0; j < hll->casecnt; j++) {

	inc	r12d
	mov	QWORD PTR tv2180[rsp], rdx
	add	r13, 8
	mov	rdi, rdx
	cmp	r12d, DWORD PTR [rbx+100]
	jb	$LL23@HllEndDir
$LN388@HllEndDir:
	xor	esi, esi
$LN378@HllEndDir:
	mov	r13, QWORD PTR [rsp+2160]
$LN22@HllEndDir:

; 2000 :         }
; 2001 :       }
; 2002 : #endif
; 2003 :     }
; 2004 :     if (hll->cflag == 5) {

	cmp	BYTE PTR [rbx+110], 5
	jne	$LN376@HllEndDir

; 2005 :       n = 0;
; 2006 :       if (hll->csize == 4) {

	cmp	BYTE PTR [rbx+111], 4

; 2007 :         for (j = 0; j < hll->casecnt; j++)

	mov	edi, esi
	jne	SHORT $LN119@HllEndDir
	cmp	DWORD PTR [rbx+100], 0
	jbe	$LN376@HllEndDir
	mov	r14, rsi
	npad	14
$LL28@HllEndDir:

; 2008 :           AddLineQueueX(" dd %d", hll->pcases[j]);

	mov	rax, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG12053
	mov	edx, DWORD PTR [r14+rax]
	call	AddLineQueueX
	inc	edi
	lea	r14, QWORD PTR [r14+4]
	cmp	edi, DWORD PTR [rbx+100]
	jb	SHORT $LL28@HllEndDir

; 2009 :       }

	jmp	$LN376@HllEndDir
$LN119@HllEndDir:

; 2010 : #if AMD64_SUPPORT
; 2011 :       else {
; 2012 :         for (j = 0; j < hll->casecnt; j++)

	cmp	DWORD PTR [rbx+100], 0
	jbe	$LN376@HllEndDir
	mov	r14, rsi
$LL31@HllEndDir:

; 2013 :           AddLineQueueX(" dq %q", hll->pcases64[j]);

	mov	rdx, QWORD PTR [rbx+16]
	lea	rcx, OFFSET FLAT:$SG12054
	mov	rdx, QWORD PTR [r14+rdx]
	call	AddLineQueueX
	inc	edi
	lea	r14, QWORD PTR [r14+8]
	cmp	edi, DWORD PTR [rbx+100]
	jb	SHORT $LL31@HllEndDir

; 2014 :       }
; 2015 : #endif
; 2016 :     }
; 2017 :     if (hll->csize == 4) {
; 2018 :       LclFree(hll->pcases);
; 2019 :     }
; 2020 : #if AMD64_SUPPORT
; 2021 :     else
; 2022 :       LclFree(hll->pcases64);
; 2023 : #endif
; 2024 :     LclFree(hll->plabels);
; 2025 :     break;

	jmp	$LN376@HllEndDir
$LN123@HllEndDir:

; 2026 :   case T_DOT_ENDFOR:
; 2027 :     if (hll->cmd != HLL_FOR) {

	cmp	DWORD PTR [rbx+104], 4
	je	SHORT $LN124@HllEndDir

; 2028 :       DebugMsg(("HllEndDir: no .FOR on the hll stack\n"));
; 2029 :       EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr);

	movsxd	rdx, DWORD PTR i$[rbp-256]
	mov	ecx, 80					; 00000050H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+8]
	call	EmitErr

; 2030 :       return(ERROR);

	or	eax, -1
	jmp	$LN377@HllEndDir
$LN124@HllEndDir:

; 2031 :     }
; 2032 :     i++;

	inc	DWORD PTR i$[rbp-256]

; 2033 :     //Insert .CONTINUE label here if there is any 
; 2034 :     if (hll->labels[LCONT])

	mov	r8d, DWORD PTR [rbx+52]
	test	r8d, r8d
	je	SHORT $LN125@HllEndDir

; 2035 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LCONT], buff));

	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12060
	call	AddLineQueueX
$LN125@HllEndDir:

; 2036 :     //forever loop '.for (::)'
; 2037 :     if (hll->cmcnt == 0) goto adlabel;

	mov	edx, DWORD PTR [rbx+96]
	test	edx, edx
	je	$adlabel$392

; 2038 :     //If counters exist  
; 2039 :     else if (hll->counterlines[0]) {

	mov	r8, QWORD PTR [rbx+88]
	cmp	BYTE PTR [r8], sil
	je	SHORT $LN128@HllEndDir

; 2040 :       //here we write counters
; 2041 :       if (hll->counterlines) {      //if there is something after second ':' expand it here

	test	r8, r8
	je	SHORT $LN130@HllEndDir

; 2042 :         ForInitAndNext(tokenarray, hll->cmcnt, hll->counterlines);

	mov	rcx, rdi
	call	ForInitAndNext
$LN130@HllEndDir:

; 2043 :         LclFree(hll->counterlines);
; 2044 :       }
; 2045 :       //first jump from the top happens here after the counters
; 2046 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSKIP], buff));

	mov	r8d, DWORD PTR [rbx+48]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12066
	call	AddLineQueueX

; 2047 :       /* create test label */
; 2048 :       if (hll->labels[LTEST]) {

	mov	r8d, DWORD PTR [rbx+36]
	test	r8d, r8d
	je	SHORT $LN131@HllEndDir

; 2049 :         AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12068
	call	AddLineQueueX
$LN131@HllEndDir:

; 2050 :       }
; 2051 :       QueueTestLines(hll->condlines);

	mov	rcx, QWORD PTR [rbx+80]
	call	QueueTestLines

; 2052 :       LclFree(hll->condlines);
; 2053 :     }

	jmp	SHORT $LN129@HllEndDir
$LN128@HllEndDir:

; 2054 :     else
; 2055 :       AddLineQueueX(" jmp %s", GetLabelStr(hll->labels[LSTART], buff));

	mov	r8d, DWORD PTR [rbx+44]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12069
	call	AddLineQueueX
$LN129@HllEndDir:

; 2056 :     if (!hll->cond)

	cmp	BYTE PTR [rbx+108], sil
	jne	SHORT $LN132@HllEndDir
$adlabel$392:

; 2057 :       adlabel:
; 2058 :     AddLineQueueX(" jmp %s", GetLabelStr(hll->labels[LSTART], buff));

	mov	r8d, DWORD PTR [rbx+44]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12071
	call	AddLineQueueX
$LN132@HllEndDir:

; 2059 :     tokenarray[i].token = T_FINAL;

	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	mov	BYTE PTR [rax+rdi], sil

; 2060 :     break;

	jmp	$LN373@HllEndDir
$LN133@HllEndDir:

; 2061 :     //end of .ENDFOR
; 2062 :   case T_DOT_ENDW:
; 2063 :     if (hll->cmd != HLL_WHILE) {

	cmp	DWORD PTR [rbx+104], 1
	jne	$LN389@HllEndDir

; 2064 :       DebugMsg(("HllEndDir: no .WHILE on the hll stack\n"));
; 2065 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));
; 2066 :     }
; 2067 :     i++;

	inc	DWORD PTR i$[rbp-256]

; 2068 :     /* create test label */
; 2069 :     if (hll->labels[LTEST]) {

	mov	r8d, DWORD PTR [rbx+36]
	test	r8d, r8d
	je	SHORT $LN135@HllEndDir

; 2070 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12075
	call	AddLineQueueX
$LN135@HllEndDir:

; 2071 :     }
; 2072 :     QueueTestLines(hll->condlines);

	mov	rcx, QWORD PTR [rbx+80]
	call	QueueTestLines

; 2073 :     LclFree(hll->condlines);
; 2074 :     break;

	jmp	$LN373@HllEndDir
$LN136@HllEndDir:

; 2075 :   case T_DOT_UNTILCXZ:
; 2076 :     if (hll->cmd != HLL_REPEAT) {

	cmp	DWORD PTR [rbx+104], 2
	jne	$LN389@HllEndDir

; 2077 :       DebugMsg(("HllEndDir: no .REPEAT on the hll stack\n"));
; 2078 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));
; 2079 :     }
; 2080 :     i++;

	mov	eax, DWORD PTR i$[rbp-256]
	inc	eax
	mov	DWORD PTR i$[rbp-256], eax

; 2081 :     if (hll->labels[LTEST]) /* v2.11: LTEST only needed if .CONTINUE has occured */

	mov	r8d, DWORD PTR [rbx+36]
	test	r8d, r8d
	je	SHORT $LN138@HllEndDir

; 2082 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12079
	call	AddLineQueueX
	mov	eax, DWORD PTR i$[rbp-256]
$LN138@HllEndDir:

; 2083 : 
; 2084 :     /* read in optional (simple) expression */
; 2085 :     if (tokenarray[i].token != T_FINAL) {

	cdqe
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], sil
	je	$LN139@HllEndDir

; 2086 :       rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, FALSE, buffer);

	lea	rax, QWORD PTR hllop$2[rsp]
	mov	QWORD PTR hllop$2[rsp], rsi
	mov	QWORD PTR [rsp+48], rax
	lea	rdx, QWORD PTR i$[rbp-256]
	lea	rax, QWORD PTR buffer$[rsp]
	mov	DWORD PTR hllop$2[rsp+8], esi
	mov	QWORD PTR [rsp+40], rax
	mov	r9d, 2
	mov	r8, rdi
	mov	BYTE PTR [rsp+32], sil
	mov	rcx, rbx
	mov	BYTE PTR buffer$[rsp], sil
	call	GetExpression
	cmp	eax, -1
	jne	SHORT $LN299@HllEndDir
	or	esi, eax
	jmp	$LN373@HllEndDir
$LN299@HllEndDir:
	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], sil
	je	SHORT $LN370@HllEndDir
	mov	ecx, 199				; 000000c7H
	call	EmitError
	mov	esi, eax

; 2087 :       if (rc == NOT_ERROR) {

	test	eax, eax
	jne	$LN373@HllEndDir
$LN370@HllEndDir:

; 2088 :         rc = CheckCXZLines(buffer);

	lea	rcx, QWORD PTR buffer$[rsp]
	call	CheckCXZLines
	mov	esi, eax

; 2089 :         if (rc == NOT_ERROR)

	test	eax, eax
	jne	SHORT $LN142@HllEndDir

; 2090 :           QueueTestLines(buffer); /* write condition lines */

	lea	rdi, QWORD PTR buffer$[rsp]
	npad	8
$LL303@HllEndDir:
	mov	edx, 10
	mov	rcx, rdi
	mov	r14, rdi
	call	strchr
	mov	rdi, rax
	test	rax, rax
	je	SHORT $LN305@HllEndDir
	mov	BYTE PTR [rax], r12b
	inc	rdi
$LN305@HllEndDir:
	cmp	BYTE PTR [r14], r12b
	je	SHORT $LN306@HllEndDir
	mov	rcx, r14
	call	AddLineQueue
$LN306@HllEndDir:
	test	rdi, rdi
	jne	SHORT $LL303@HllEndDir
	jmp	$LN376@HllEndDir
$LN142@HllEndDir:

; 2091 :         else
; 2092 :           EmitError(EXPR_TOO_COMPLEX_FOR_UNTILCXZ);

	mov	ecx, 191				; 000000bfH
	call	EmitError

; 2093 :       }
; 2094 :     }

	jmp	$LN373@HllEndDir
$LN139@HllEndDir:

; 2095 :     else {
; 2096 :       AddLineQueueX(JMPPREFIX "loop %s", GetLabelStr(hll->labels[LSTART], buff));

	mov	r8d, DWORD PTR [rbx+44]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12085
	call	AddLineQueueX

; 2097 :     }
; 2098 :     break;

	jmp	$LN373@HllEndDir
$LN144@HllEndDir:

; 2099 :   case T_DOT_UNTIL:
; 2100 :     if (hll->cmd != HLL_REPEAT) {

	cmp	DWORD PTR [rbx+104], 2
	je	SHORT $LN145@HllEndDir
$LN389@HllEndDir:

; 2101 :       DebugMsg(("HllEndDir: no .REPEAT on the hll stack\n"));
; 2102 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	movsxd	rdx, DWORD PTR i$[rbp-256]
	mov	ecx, 80					; 00000050H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+8]
	call	EmitErr
	jmp	$LN377@HllEndDir
$LN145@HllEndDir:

; 2103 :     }
; 2104 :     i++;

	inc	DWORD PTR i$[rbp-256]

; 2105 :     if (hll->labels[LTEST]) /* v2.11: LTEST only needed if .CONTINUE has occured */

	mov	r8d, DWORD PTR [rbx+36]
	test	r8d, r8d
	je	SHORT $LN146@HllEndDir

; 2106 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12089
	call	AddLineQueueX
$LN146@HllEndDir:

; 2107 : 
; 2108 :     /* read in (optional) expression */
; 2109 :     /* if expression is missing, just generate nothing */
; 2110 :     if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], sil
	je	$LN373@HllEndDir

; 2111 :       rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, FALSE, buffer);

	lea	rax, QWORD PTR hllop$1[rsp]
	mov	QWORD PTR hllop$1[rsp], rsi
	mov	QWORD PTR [rsp+48], rax
	lea	rdx, QWORD PTR i$[rbp-256]
	lea	rax, QWORD PTR buffer$[rsp]
	mov	DWORD PTR hllop$1[rsp+8], esi
	mov	QWORD PTR [rsp+40], rax
	mov	r9d, 2
	mov	r8, rdi
	mov	BYTE PTR [rsp+32], sil
	mov	rcx, rbx
	mov	BYTE PTR buffer$[rsp], sil
	call	GetExpression
	cmp	eax, -1
	jne	SHORT $LN313@HllEndDir
	or	esi, eax
	jmp	SHORT $LN373@HllEndDir
$LN313@HllEndDir:
	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], sil
	je	SHORT $LN314@HllEndDir
	mov	ecx, 199				; 000000c7H
	call	EmitError
	mov	esi, eax

; 2112 :       if (rc == NOT_ERROR)

	test	eax, eax
	jne	SHORT $LN373@HllEndDir

; 2111 :       rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, FALSE, buffer);

$LN314@HllEndDir:

; 2113 :         QueueTestLines(buffer); /* write condition lines */

	lea	rdi, QWORD PTR buffer$[rsp]
	npad	8
$LL317@HllEndDir:
	mov	edx, 10
	mov	rcx, rdi
	mov	r14, rdi
	call	strchr
	mov	rdi, rax
	test	rax, rax
	je	SHORT $LN319@HllEndDir
	mov	BYTE PTR [rax], r12b
	inc	rdi
$LN319@HllEndDir:
	cmp	BYTE PTR [r14], r12b
	je	SHORT $LN320@HllEndDir
	mov	rcx, r14
	call	AddLineQueue
$LN320@HllEndDir:
	test	rdi, rdi
	jne	SHORT $LL317@HllEndDir
$LN376@HllEndDir:
	mov	rdi, QWORD PTR tokenarray$[rbp-256]
$LN373@HllEndDir:

; 2114 :     }
; 2115 :     break;
; 2116 : #ifdef DEBUG_OUT
; 2117 :   default: /**/myassert(0); break;
; 2118 : #endif
; 2119 :   }
; 2120 : 
; 2121 :   /* create the exit label if it has been referenced */
; 2122 :   if (hll->labels[LEXIT])

	mov	r8d, DWORD PTR [rbx+40]
	test	r8d, r8d
	je	SHORT $LN149@HllEndDir

; 2123 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LEXIT], buff));

	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12093
	call	AddLineQueueX
$LN149@HllEndDir:

; 2124 : 
; 2125 :   if (tokenarray[i].token != T_FINAL && rc == NOT_ERROR) {

	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 0
	je	SHORT $LN150@HllEndDir
	test	esi, esi
	jne	SHORT $LN150@HllEndDir

; 2126 :     EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos);

	mov	rdx, QWORD PTR [rax+rdi+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 2127 :     rc = ERROR;

	or	esi, -1
$LN150@HllEndDir:

; 2128 :   }
; 2129 :   if (ModuleInfo.list)

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN151@HllEndDir

; 2130 :     LstWrite(LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL);

	call	GetCurrOffset
	xor	r8d, r8d
	mov	edx, eax
	lea	ecx, QWORD PTR [r8+4]
	call	LstWrite
$LN151@HllEndDir:

; 2131 : 
; 2132 :   /* v2.11: always run line-queue if it's not empty. */
; 2133 :   if (is_linequeue_populated())

	cmp	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN152@HllEndDir

; 2134 :     RunLineQueue();

	call	RunLineQueue
$LN152@HllEndDir:

; 2135 : 
; 2136 :   return(rc);

	mov	eax, esi
$LN377@HllEndDir:
	mov	r14, QWORD PTR [rsp+2152]

; 2137 : }

	add	rsp, 2168				; 00000878H
	pop	r15
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
	npad	3
$LN372@HllEndDir:
	DD	$LN33@HllEndDir
	DD	$LN133@HllEndDir
	DD	$LN144@HllEndDir
	DD	$LN136@HllEndDir
	DD	$LN123@HllEndDir
	DD	$LN373@HllEndDir
	DD	$LN373@HllEndDir
	DD	$LN373@HllEndDir
	DD	$LN36@HllEndDir
HllEndDir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
hllop$1 = 64
hllop$2 = 64
hllop$3 = 64
buff$ = 80
opndx$ = 96
forbuff$ = 208
forbuffcnt$ = 1232
forbuffcond$ = 2256
buffer$ = 3280
forbuffinit$ = 5328
transformed$ = 6352
i$ = 7424
tokenarray$ = 7432
HllStartDir PROC

; 1252 : {

$LN302:
	mov	QWORD PTR [rsp+32], rbx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	push	r12
	push	r13
	push	r15
	lea	rbp, QWORD PTR [rsp-7120]
	mov	eax, 7376				; 00001cd0H
	call	__chkstk
	sub	rsp, rax

; 1253 :   struct hll_item      *hll;
; 1254 :   ret_code             rc = NOT_ERROR;
; 1255 :   int                  cmd = tokenarray[i].tokval;
; 1256 :   char buff[16];
; 1257 :   char buffer[MAX_LINE_LEN * 2];
; 1258 :   char codebuff[256];
; 1259 :   char param[256];
; 1260 :   char init[256];
; 1261 :   char limit[MAX_LINE_LEN];
; 1262 :   char op[4];
; 1263 :   char forbuff[MAX_LINE_LEN];
; 1264 :   char forbuffinit[MAX_LINE_LEN];
; 1265 :   char forbuffcond[MAX_LINE_LEN];
; 1266 :   char forbuffcnt[MAX_LINE_LEN];
; 1267 :   char transformed[MAX_LINE_LEN];
; 1268 :   int a;
; 1269 :   int j;
; 1270 :   int b;
; 1271 :   int e;
; 1272 :   int size;
; 1273 :   int eqcnt;
; 1274 :   int cmcnt;
; 1275 :   char *p;
; 1276 :   char c;
; 1277 :   struct expr         opndx;
; 1278 :   struct asm_tok      *t;
; 1279 :   DebugMsg1(("HllStartDir(%s) enter\n", tokenarray[i].string_ptr));
; 1280 : 
; 1281 :   i++; /* skip directive */
; 1282 : 
; 1283 :        /* v2.06: is there an item on the free stack? */
; 1284 :   if (HllFree) {

	mov	rdi, QWORD PTR ModuleInfo+232
	xor	r13d, r13d
	movsxd	rax, ecx
	mov	r15, rdx
	shl	rax, 5
	inc	ecx
	mov	r12d, r13d
	mov	ebx, DWORD PTR [rax+rdx+16]
	mov	DWORD PTR i$[rbp-256], ecx
	test	rdi, rdi
	jne	SHORT $LN19@HllStartDi

; 1285 :     hll = HllFree;
; 1286 :     DebugCmd(cntReused++);
; 1287 :   }
; 1288 :   else {
; 1289 :     hll = LclAlloc(sizeof(struct hll_item));

	mov	ecx, 160				; 000000a0H
	call	LclAlloc
	mov	rdi, rax
$LN19@HllStartDi:

; 1290 :     DebugCmd(cntAlloc++);
; 1291 :   }
; 1292 : 
; 1293 :   /* structure for .IF .ELSE .ENDIF
; 1294 :   *    cond jump to LTEST-label
; 1295 :   *    ...
; 1296 :   *    jmp LEXIT
; 1297 :   *  LTEST:
; 1298 :   *    ...
; 1299 :   *  LEXIT:
; 1300 : 
; 1301 :   * structure for .IF .ELSEIF
; 1302 :   *    cond jump to LTEST
; 1303 :   *    ...
; 1304 :   *    jmp LEXIT
; 1305 :   *  LTEST:
; 1306 :   *    cond jump to (new) LTEST
; 1307 :   *    ...
; 1308 :   *    jmp LEXIT
; 1309 :   *  LTEST:
; 1310 :   *    ...
; 1311 : 
; 1312 :   * structure for .WHILE and .REPEAT:
; 1313 :   *   jmp LTEST (for .WHILE only)
; 1314 :   * LSTART:
; 1315 :   *   ...
; 1316 :   * LTEST: (jumped to by .continue)
; 1317 :   *   a) test end condition, cond jump to LSTART label
; 1318 :   *   b) unconditional jump to LSTART label
; 1319 :   * LEXIT: (jumped to by .BREAK)
; 1320 :   */
; 1321 : 
; 1322 :   hll->labels[LEXIT] = 0;

	mov	QWORD PTR [rsp+7432], rsi
	mov	DWORD PTR [rdi+40], r13d

; 1323 : 
; 1324 :   switch (cmd) {

	cmp	ebx, 327				; 00000147H
	je	$LN20@HllStartDi
	jle	$LN22@HllStartDi
	cmp	ebx, 329				; 00000149H
	jle	$LN75@HllStartDi
	cmp	ebx, 330				; 0000014aH
	je	$LN51@HllStartDi
	cmp	ebx, 340				; 00000154H
	jne	$LN22@HllStartDi

; 1338 :       }
; 1339 :     }
; 1340 :     break;
; 1341 :     // added by habran
; 1342 :   case T_DOT_SWITCH:
; 1343 :     hll->cmd = HLL_SWITCH;

	mov	DWORD PTR [rdi+104], 5

; 1344 :     hll->flags = HLLF_WHILE;

	mov	DWORD PTR [rdi+112], 4

; 1345 :     hll->labels[LSKIP] = GetHllLabel();   /* used by .ENDSWITCH */

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rdi+48], eax

; 1346 :     hll->labels[LJUMP] = GetHllLabel();   /* used by .ENDSWITCH */

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rdi+72], eax

; 1347 :     hll->labels[LEXIT] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rdi+40], eax

; 1348 :     hll->labels[LDATA1] = GetHllLabel();   /* used by .ENDSWITCH */

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rdi+60], eax

; 1349 :     hll->labels[LSTART] = GetHllLabel();   /* used by .CASE      */

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rdi+44], eax

; 1350 :     hll->labels[LTEST] = 0;               /* used by .CASE      */

	mov	DWORD PTR [rdi+36], r13d

; 1351 :     hll->labels[LDEF] = 0;   /* used by .DEFAULT   */

	mov	DWORD PTR [rdi+56], r13d

; 1352 :     hll->labels[LDATA2] = GetHllLabel();   /* used by .ENDSWITCH */

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rdi+64], eax

; 1353 :     hll->labels[LTOP] = GetHllLabel();   /* used by .ENDSWITCH */

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rdi+68], eax

; 1354 :     hll->labels[LCONT] = GetHllLabel();   /* used by .ENDSWITCH */

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rdi+52], eax

; 1355 :     hll->maxalloccasen = 0;

	mov	DWORD PTR [rdi+128], r13d

; 1356 :     hll->casecnt = 0;

	mov	DWORD PTR [rdi+100], r13d

; 1357 :     hll->csize = 4;

	mov	BYTE PTR [rdi+111], 4

; 1358 :     hll->breakoccured = TRUE; //first label for .CASE hast to be set

	mov	BYTE PTR [rdi+109], 1

; 1359 : 
; 1360 :     if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	cmp	BYTE PTR [rax+r15], r12b
	je	$LN24@HllStartDi

; 1361 :       DebugMsg1(("HllStartDir(%s): calling EvalOperand, i=%u\n", tokenarray[i].string_ptr, i));
; 1362 :       if (EvalOperand(&i, tokenarray, Token_Count, &opndx, 0) == ERROR) {

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	mov	rdx, r15
	mov	BYTE PTR [rsp+32], r12b
	lea	rcx, QWORD PTR i$[rbp-256]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN26@HllStartDi

; 1363 :         DebugMsg(("HllStartDir(%s): EvalOperand() failed\n", tokenarray[i].string_ptr));
; 1364 :         return(ERROR);

	or	eax, eax
	jmp	$LN1@HllStartDi
$LN26@HllStartDi:

; 1365 :       }
; 1366 :       i--; //EvalOperand increases i, decrease it to point to proper tokenarray[i].tokpos 

	mov	ecx, DWORD PTR i$[rbp-256]

; 1367 :       switch (opndx.kind) {

	mov	edx, DWORD PTR opndx$[rbp-196]
	dec	ecx
	mov	DWORD PTR i$[rbp-256], ecx
	sub	edx, 1
	je	$LN40@HllStartDi
	cmp	edx, 1
	jne	$LN50@HllStartDi

; 1368 :       case EXPR_REG:
; 1369 :         t = opndx.base_reg;
; 1370 :         if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1

; 1371 :           if (t->tokval <= T_BX)   // AL, CL, DL, BL, AH, CH, DH, BH, AX, CX, DX, BX

	mov	rax, QWORD PTR opndx$[rsp+24]
	mov	edx, DWORD PTR [rax+16]
	jne	SHORT $LN28@HllStartDi
	cmp	edx, 12
	ja	SHORT $LN30@HllStartDi

; 1372 :             AddLineQueueX(" movzx eax, %s", tokenarray[i].tokpos);

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG11688
	jmp	$LN297@HllStartDi
$LN30@HllStartDi:

; 1373 :           else {
; 1374 :             if (t->tokval != T_EAX) //skip it, no need to write MOV EAX,EAX

	cmp	edx, 17
	je	$LN50@HllStartDi

; 1375 :               AddLineQueueX(" mov eax, %s", tokenarray[i].tokpos);

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG11690

; 1376 :           }
; 1377 :         }

	jmp	$LN297@HllStartDi
$LN28@HllStartDi:

; 1378 : #if AMD64_SUPPORT
; 1379 :         else             //USE64
; 1380 :         {
; 1381 :           if ((t->tokval <= T_EAX))

	cmp	edx, 17
	jbe	$LN50@HllStartDi

; 1382 :             ; //skip it, no need to write MOV EAX,EAX
; 1383 :           else if (t->tokval <= T_BX) // AL, CL, DL, BL, AH, CH, DH, BH, AX, CX, DX, BX

	cmp	edx, 12
	ja	SHORT $LN35@HllStartDi

; 1384 :             AddLineQueueX(" movzx eax, %s", tokenarray[i].tokpos);

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG11695
	jmp	$LN297@HllStartDi
$LN35@HllStartDi:

; 1385 :           else if (t->tokval <= T_EDI) //EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI

	cmp	edx, 24
	ja	SHORT $LN37@HllStartDi

; 1386 :             AddLineQueueX(" mov eax, %s", tokenarray[i].tokpos);

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG11698
	jmp	$LN297@HllStartDi
$LN37@HllStartDi:

; 1387 :           else {
; 1388 :             if (t->tokval != T_RAX) //skip it, no need to write MOV RAX,RAX

	cmp	edx, 115				; 00000073H
	je	SHORT $LN39@HllStartDi

; 1389 :               AddLineQueueX(" mov rax, %s", tokenarray[i].tokpos);

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG11700
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r15+24]
	call	AddLineQueueX
$LN39@HllStartDi:

; 1390 :             hll->csize = 8;

	mov	BYTE PTR [rdi+111], 8

; 1391 :           }
; 1392 :         }               //end USE64
; 1393 : #endif
; 1394 :         break;

	jmp	SHORT $LN298@HllStartDi
$LN40@HllStartDi:

; 1395 :       case EXPR_ADDR:
; 1396 :         if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1

; 1399 :           else
; 1400 :             AddLineQueueX(" mov eax, %s", tokenarray[i].tokpos);

	movsxd	rdx, ecx
	jne	SHORT $LN41@HllStartDi
	shl	rdx, 5
	cmp	DWORD PTR opndx$[rbp-192], 1
	mov	rdx, QWORD PTR [rdx+r15+24]
	jbe	SHORT $LN45@HllStartDi
	lea	rcx, OFFSET FLAT:$SG11708
	jmp	SHORT $LN299@HllStartDi
$LN45@HllStartDi:

; 1397 :           if (opndx.mem_type == MT_BYTE || opndx.mem_type == MT_WORD)
; 1398 :             AddLineQueueX(" movzx eax, %s", tokenarray[i].tokpos);

	lea	rcx, OFFSET FLAT:$SG11707

; 1401 :         }

	jmp	SHORT $LN299@HllStartDi
$LN41@HllStartDi:
	mov	eax, DWORD PTR opndx$[rbp-192]
	cmp	eax, 1
	jbe	SHORT $LN48@HllStartDi

; 1407 :           else if (opndx.mem_type == MT_DWORD)
; 1408 :             AddLineQueueX(" mov eax, %s", tokenarray[i].tokpos);

	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r15+24]
	cmp	eax, 3
	jne	SHORT $LN49@HllStartDi
	lea	rcx, OFFSET FLAT:$SG11715
	jmp	SHORT $LN299@HllStartDi
$LN49@HllStartDi:

; 1409 :           else {
; 1410 :             AddLineQueueX(" mov rax, %s", tokenarray[i].tokpos);

	lea	rcx, OFFSET FLAT:$SG11716
	call	AddLineQueueX

; 1411 :             hll->csize = 8;

	mov	BYTE PTR [rdi+111], 8
	jmp	SHORT $LN298@HllStartDi
$LN48@HllStartDi:

; 1402 : #if AMD64_SUPPORT
; 1403 :         else             //USE64
; 1404 :         {
; 1405 :           if (opndx.mem_type == MT_BYTE || opndx.mem_type == MT_WORD)
; 1406 :             AddLineQueueX(" movzx eax, %s", tokenarray[i].tokpos);

	lea	rcx, OFFSET FLAT:$SG11712
$LN297@HllStartDi:
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r15+24]
$LN299@HllStartDi:
	call	AddLineQueueX
$LN298@HllStartDi:
	mov	ecx, DWORD PTR i$[rbp-256]
$LN50@HllStartDi:

; 1421 :     }
; 1422 :     i++;

	inc	ecx

; 1423 :     AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[LSTART], buff));

	lea	rdx, OFFSET FLAT:$SG11118
	mov	DWORD PTR i$[rbp-256], ecx
	lea	rcx, QWORD PTR buff$[rsp]
	mov	r8d, DWORD PTR [rdi+44]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11717
	call	AddLineQueueX

; 1424 :     break;

	jmp	$LN22@HllStartDi
$LN24@HllStartDi:

; 1412 :           }
; 1413 :         }                //end USE64
; 1414 : #endif
; 1415 :         break;
; 1416 :       }
; 1417 :     }
; 1418 :     else {
; 1419 :       DebugMsg(("HllExitDir stack error\n"));
; 1420 :       return(EmitError(MISSING_OPERATOR_IN_EXPRESSION));

	mov	ecx, 150				; 00000096H
	call	EmitError
	jmp	$LN1@HllStartDi
$LN51@HllStartDi:

; 1425 :   case T_DOT_FOR:
; 1426 :     /* create the label to loop start */
; 1427 :     hll->labels[LSTART] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	QWORD PTR [rsp+7440], r14
	mov	DWORD PTR ModuleInfo+352, eax

; 1428 :     hll->labels[LSKIP] = GetHllLabel();
; 1429 :     hll->labels[LCONT] = 0;
; 1430 :     hll->labels[LTEST] = 0;
; 1431 :     hll->flags = 0;
; 1432 :     hll->cmd = HLL_FOR;
; 1433 :     //copy string to the buffer and get read of spaces
; 1434 :     p = tokenarray[i].tokpos;
; 1435 :     for (b = 0; *p; p++)

	mov	r14d, r13d
	mov	DWORD PTR [rdi+44], eax
	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rdi+48], eax
	mov	DWORD PTR [rdi+52], r13d
	mov	DWORD PTR [rdi+36], r13d
	mov	DWORD PTR [rdi+112], r13d
	mov	DWORD PTR [rdi+104], 4
	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	mov	rsi, QWORD PTR [rax+r15+24]
	movzx	eax, BYTE PTR [rsi]
	test	al, al
	je	SHORT $LN7@HllStartDi
	lea	rbx, QWORD PTR forbuff$[rbp-256]
	npad	7
$LL8@HllStartDi:

; 1436 :     {
; 1437 :       if ((*p == ' ') || (*p == '\t')) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN54@HllStartDi
	cmp	al, 9
	jne	SHORT $LN300@HllStartDi
$LN54@HllStartDi:

; 1438 :         //if there is QWORD PTR, DWORD PTR, WORD PTR, BYTE PTR, OFFSET or ADDR leave a space between
; 1439 :         c = tolower(*(p + 1));

	movsx	ecx, BYTE PTR [rsi+1]
	call	tolower

; 1440 :         if ((c >= 'a') && (c <= 'z')) {

	sub	al, 97					; 00000061H
	cmp	al, 25
	ja	SHORT $LN6@HllStartDi

; 1441 :           forbuff[b] = *p;

	movzx	eax, BYTE PTR [rsi]
$LN300@HllStartDi:

; 1442 :           b++;

	inc	r14d
	mov	BYTE PTR [rbx], al
	inc	rbx
$LN6@HllStartDi:

; 1428 :     hll->labels[LSKIP] = GetHllLabel();
; 1429 :     hll->labels[LCONT] = 0;
; 1430 :     hll->labels[LTEST] = 0;
; 1431 :     hll->flags = 0;
; 1432 :     hll->cmd = HLL_FOR;
; 1433 :     //copy string to the buffer and get read of spaces
; 1434 :     p = tokenarray[i].tokpos;
; 1435 :     for (b = 0; *p; p++)

	movzx	eax, BYTE PTR [rsi+1]
	inc	rsi
	test	al, al
	jne	SHORT $LL8@HllStartDi
$LN7@HllStartDi:

; 1443 :         }
; 1444 :       }
; 1445 :       else {
; 1446 :         forbuff[b] = *p;
; 1447 :         b++;
; 1448 :       }
; 1449 :     }
; 1450 :     forbuff[b] = NULLC;

	movsxd	rax, r14d

; 1451 :     if (0 == _memicmp(forbuff, "(::)", 4)) {

	lea	rdx, OFFSET FLAT:$SG11725
	mov	r8d, 4
	lea	rcx, QWORD PTR forbuff$[rbp-256]
	mov	BYTE PTR forbuff$[rbp+rax-256], r12b
	call	_memicmp
	mov	r14, QWORD PTR [rsp+7440]
	test	eax, eax
	jne	SHORT $LN56@HllStartDi

; 1452 :       hll->cmcnt = 0;

	mov	DWORD PTR [rdi+96], r13d

; 1453 :     }

	jmp	$LN73@HllStartDi
$LN56@HllStartDi:

; 1454 :     else {
; 1455 :       //count initializers
; 1456 :       eqcnt = 1;
; 1457 :       forbuffinit[0] = NULLC;
; 1458 :       for (j = 1, b = 0; forbuff[j];) {

	mov	r9d, r13d
	mov	BYTE PTR forbuffinit$[rbp-256], r12b
	mov	r10d, 1
	mov	r8d, r10d
	cmp	BYTE PTR forbuff$[rbp-255], r9b
	je	SHORT $LN295@HllStartDi
	mov	ecx, r10d
	mov	rax, r13
	npad	1
$LL9@HllStartDi:

; 1459 :         c = forbuff[j];

	movzx	edx, BYTE PTR forbuff$[rbp+rcx-256]

; 1460 :         if (c == ':') {

	cmp	dl, 58					; 0000003aH
	jne	SHORT $LN59@HllStartDi

; 1461 :           if (forbuff[j - 1] != 39 && forbuff[j + 1] != 39) break;

	cmp	BYTE PTR forbuff$[rbp+rcx-257], 39	; 00000027H
	je	SHORT $LN60@HllStartDi
	cmp	BYTE PTR forbuff$[rbp+rcx-255], 39	; 00000027H
	jne	SHORT $LN295@HllStartDi

; 1462 :         }
; 1463 :         if (c == ',' && forbuff[j - 1] != 39 && forbuff[j + 1] != 39) eqcnt++;

	jmp	SHORT $LN60@HllStartDi
$LN59@HllStartDi:
	cmp	dl, 44					; 0000002cH
	jne	SHORT $LN60@HllStartDi
	cmp	BYTE PTR forbuff$[rbp+rcx-257], 39	; 00000027H
	je	SHORT $LN60@HllStartDi
	cmp	BYTE PTR forbuff$[rbp+rcx-255], 39	; 00000027H
	je	SHORT $LN60@HllStartDi
	inc	r10d
$LN60@HllStartDi:

; 1464 :         forbuffinit[b] = c;

	mov	BYTE PTR forbuffinit$[rbp+rax-256], dl

; 1465 :         if (c == 39 && forbuffinit[b - 2] == 39) {

	cmp	dl, 39					; 00000027H
	jne	SHORT $LN61@HllStartDi
	cmp	BYTE PTR forbuffinit$[rbp+rax-258], dl
	jne	SHORT $LN61@HllStartDi

; 1466 :           b++;

	inc	r9d

; 1467 :           forbuffinit[b] = ' ';

	mov	BYTE PTR forbuffinit$[rbp+rax-255], 32	; 00000020H
	inc	rax
$LN61@HllStartDi:

; 1468 :         }
; 1469 :         j++;

	inc	rcx
	inc	r8d

; 1470 :         b++;

	inc	r9d
	inc	rax
	cmp	BYTE PTR forbuff$[rbp+rcx-256], r12b
	jne	SHORT $LL9@HllStartDi
$LN295@HllStartDi:

; 1471 :       }
; 1472 :       forbuffinit[b] = NULLC;

	movsxd	rax, r9d

; 1474 :       //coppy the condition to the buffer
; 1475 :       forbuffcond[0] = NULLC;
; 1476 :       hll->labels[LTEST] = 0;
; 1477 :       for (b = 0; forbuff[j] && forbuff[j] != ':'; forbuffcond[b] = forbuff[j], j++, b++);

	lea	rcx, QWORD PTR forbuff$[rbp-256]
	inc	r8d
	mov	DWORD PTR [rdi+36], r13d
	mov	r9d, r13d
	mov	BYTE PTR forbuffcond$[rbp-256], r12b
	mov	BYTE PTR forbuffinit$[rbp+rax-256], r12b
	movsxd	rax, r8d
	add	rcx, rax
	cmp	BYTE PTR [rcx], r9b
	je	SHORT $LN296@HllStartDi

; 1473 :       j++;

	lea	rax, QWORD PTR forbuffcond$[rbp-256]
$LL14@HllStartDi:

; 1474 :       //coppy the condition to the buffer
; 1475 :       forbuffcond[0] = NULLC;
; 1476 :       hll->labels[LTEST] = 0;
; 1477 :       for (b = 0; forbuff[j] && forbuff[j] != ':'; forbuffcond[b] = forbuff[j], j++, b++);

	movzx	edx, BYTE PTR [rcx]
	cmp	dl, 58					; 0000003aH
	je	SHORT $LN296@HllStartDi
	inc	rcx
	mov	BYTE PTR [rax], dl
	inc	r8d
	inc	r9d
	inc	rax
	cmp	BYTE PTR [rcx], r12b
	jne	SHORT $LL14@HllStartDi
$LN296@HllStartDi:

; 1478 :       if (forbuffcond[b - 2] == '>' && forbuffcond[b - 1] == '0') forbuffcond[b - 2] = NULLC;

	movsxd	rax, r9d
	cmp	BYTE PTR forbuffcond$[rbp+rax-258], 62	; 0000003eH
	jne	SHORT $LN62@HllStartDi
	cmp	BYTE PTR forbuffcond$[rbp+rax-257], 48	; 00000030H
	jne	SHORT $LN62@HllStartDi
	mov	BYTE PTR forbuffcond$[rbp+rax-258], r12b
$LN62@HllStartDi:

; 1479 :       forbuffcond[b] = NULLC;
; 1480 :       if (!b) hll->cond = FALSE;

	test	r9d, r9d
	mov	BYTE PTR forbuffcond$[rbp+rax-256], r12b

; 1481 :       else    hll->cond = TRUE;
; 1482 :       j++;
; 1483 :       //copy the counter to the buffer
; 1484 :       cmcnt = 0;

	mov	esi, r13d

; 1485 :       forbuffcnt[0] = NULLC;
; 1486 :       hll->condlines = "";
; 1487 :       for (b = 0; forbuff[j] != ')'; b++, j++) {

	mov	edx, r13d
	setne	al
	mov	BYTE PTR forbuffcnt$[rbp-256], sil
	inc	r8d
	mov	BYTE PTR [rdi+108], al
	movsxd	rcx, r8d
	lea	rax, OFFSET FLAT:$SG11733
	mov	QWORD PTR [rdi+80], rax
	cmp	BYTE PTR forbuff$[rbp+rcx-256], 41	; 00000029H
	je	SHORT $LN16@HllStartDi
	mov	rax, r13
	npad	5
$LL17@HllStartDi:

; 1488 :         forbuffcnt[b] = forbuff[j];

	movzx	r8d, BYTE PTR forbuff$[rbp+rcx-256]
	mov	BYTE PTR forbuffcnt$[rbp+rax-256], r8b

; 1489 :         if (forbuffcnt[b] == ',' && forbuff[j - 1] != 39 && forbuff[j + 1] != 39) ++cmcnt;

	cmp	r8b, 44					; 0000002cH
	jne	SHORT $LN65@HllStartDi
	cmp	BYTE PTR forbuff$[rbp+rcx-257], 39	; 00000027H
	je	SHORT $LN15@HllStartDi
	cmp	BYTE PTR forbuff$[rbp+rcx-255], 39	; 00000027H
	je	SHORT $LN15@HllStartDi
	inc	esi

; 1490 :         if (forbuffcnt[b] == 39 && forbuffcnt[b - 2] == 39) {

	jmp	SHORT $LN15@HllStartDi
$LN65@HllStartDi:
	cmp	r8b, 39					; 00000027H
	jne	SHORT $LN15@HllStartDi
	cmp	BYTE PTR forbuffcnt$[rbp+rax-258], r8b
	jne	SHORT $LN15@HllStartDi

; 1491 :           b++;

	inc	edx

; 1492 :           forbuffcnt[b] = ' ';

	mov	BYTE PTR forbuffcnt$[rbp+rax-255], 32	; 00000020H
	inc	rax
$LN15@HllStartDi:

; 1485 :       forbuffcnt[0] = NULLC;
; 1486 :       hll->condlines = "";
; 1487 :       for (b = 0; forbuff[j] != ')'; b++, j++) {

	inc	rcx
	inc	edx
	inc	rax
	cmp	BYTE PTR forbuff$[rbp+rcx-256], 41	; 00000029H
	jne	SHORT $LL17@HllStartDi
$LN16@HllStartDi:

; 1493 :         }
; 1494 :       }
; 1495 :       if (forbuffcnt[b - 1] == ')') b--;

	movsxd	rax, edx
	cmp	BYTE PTR forbuffcnt$[rbp+rax-257], 41	; 00000029H
	jne	SHORT $LN67@HllStartDi
	dec	edx
$LN67@HllStartDi:

; 1496 :       forbuffcnt[b] = NULLC;

	movsxd	rax, edx
	mov	BYTE PTR forbuffcnt$[rbp+rax-256], r12b

; 1497 :       //create valid command and add to LineQueue to initiate .for loop vars
; 1498 :       //anything that is before the first ':'
; 1499 :       if (forbuffinit[0]) ForInitAndNext(tokenarray, eqcnt, forbuffinit);

	cmp	BYTE PTR forbuffinit$[rbp-256], r12b
	je	SHORT $LN68@HllStartDi
	lea	r8, QWORD PTR forbuffinit$[rbp-256]
	mov	edx, r10d
	mov	rcx, r15
	call	ForInitAndNext
$LN68@HllStartDi:

; 1500 :       //note hll->counterlines is new var in the struct hll_item for store of forbuffcnt used in .ENDFOR
; 1501 :       //hll->cmcnt is also new var in the struct hll_item for commas counter used in .ENDFOR
; 1502 :       //copy forbuffcnt context to hll->counterlines 
; 1503 :       //forbuffcnt contains anything that is written after the second ':'
; 1504 :       hll->cmcnt = 0;

	mov	DWORD PTR [rdi+96], r13d

; 1505 :       if (forbuffcnt[0])

	cmp	BYTE PTR forbuffcnt$[rbp-256], r12b
	je	SHORT $LN69@HllStartDi

; 1506 :       {
; 1507 :         //skip altering conditions the first time
; 1508 :         AddLineQueueX(" jmp %s", GetLabelStr(hll->labels[LSKIP], buff));

	mov	r8d, DWORD PTR [rdi+48]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11740
	call	AddLineQueueX

; 1509 :         size = strlen(forbuffcnt) + 1;

	lea	rcx, QWORD PTR forbuffcnt$[rbp-256]
	or	rax, -1
$LL294@HllStartDi:
	inc	rax
	cmp	BYTE PTR [rcx+rax], r12b
	jne	SHORT $LL294@HllStartDi
	inc	eax

; 1510 :         hll->counterlines = LclAlloc(size);

	movsxd	rbx, eax
	mov	rcx, rbx
	call	LclAlloc

; 1511 :         memcpy(hll->counterlines, forbuffcnt, size);

	mov	r8, rbx
	mov	QWORD PTR [rdi+88], rax
	lea	rdx, QWORD PTR forbuffcnt$[rbp-256]
	mov	rcx, rax
	call	memcpy

; 1512 :         hll->cmcnt = cmcnt + 1;

	lea	eax, DWORD PTR [rsi+1]
	mov	DWORD PTR [rdi+96], eax

; 1513 :       }

	jmp	SHORT $LN70@HllStartDi
$LN69@HllStartDi:

; 1514 :       else hll->counterlines = "";    //there is nothing after the second ':'

	lea	rax, OFFSET FLAT:$SG11741
	mov	QWORD PTR [rdi+88], rax
$LN70@HllStartDi:

; 1515 :       if (forbuffcond[0]) {

	cmp	BYTE PTR forbuffcond$[rbp-256], r12b
	je	$LN73@HllStartDi

; 1516 :         strcpy(transformed, ".for ");

	mov	rcx, r13
	lea	rdx, OFFSET FLAT:$SG11743
	npad	5
$LL87@HllStartDi:
	movzx	eax, BYTE PTR [rcx+rdx]
	mov	BYTE PTR transformed$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL87@HllStartDi

; 1517 :         strcat(transformed, forbuffcond);

	lea	rcx, QWORD PTR transformed$[rbp-256]
	dec	rcx
	npad	3
$LL292@HllStartDi:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL292@HllStartDi
	lea	r8, QWORD PTR forbuffcond$[rbp-256]
	xor	edx, edx
	npad	13
$LL293@HllStartDi:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL293@HllStartDi

; 1518 :         strcat(transformed, "\0");

	lea	rcx, QWORD PTR transformed$[rbp-256]
	dec	rcx
	npad	6
$LL290@HllStartDi:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL290@HllStartDi
	lea	r8, OFFSET FLAT:$SG11744
	xor	edx, edx
	npad	13
$LL291@HllStartDi:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL291@HllStartDi

; 1519 :         tokenarray[0].string_ptr = ".for\0";

	lea	rax, OFFSET FLAT:$SG11745

; 1520 :         tokenarray[0].tokpos = transformed;
; 1521 :         Token_Count = Tokenize(tokenarray[0].tokpos, 0, tokenarray, 0);

	xor	r9d, r9d
	mov	QWORD PTR [r15+8], rax
	lea	rcx, QWORD PTR transformed$[rbp-256]
	lea	rax, QWORD PTR transformed$[rbp-256]
	mov	r8, r15
	xor	edx, edx
	mov	QWORD PTR [r15+24], rax
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 1522 :         if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	cmp	BYTE PTR [rax+r15], r12b
	je	$LN72@HllStartDi

; 1523 :           rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, TRUE, buffer);

	lea	rax, QWORD PTR hllop$2[rsp]
	mov	QWORD PTR hllop$2[rsp], r13
	mov	QWORD PTR [rsp+48], rax
	lea	rdx, QWORD PTR i$[rbp-256]
	lea	rax, QWORD PTR buffer$[rbp-256]
	mov	DWORD PTR hllop$2[rsp+8], r13d
	mov	QWORD PTR [rsp+40], rax
	lea	rbx, QWORD PTR buffer$[rbp-256]
	mov	r9d, 2
	mov	BYTE PTR [rsp+32], 1
	mov	r8, r15
	mov	BYTE PTR buffer$[rbp-256], r12b
	mov	rcx, rdi
	call	GetAndExpression
	cmp	eax, -1
	je	$LN279@HllStartDi
	movsxd	rcx, DWORD PTR i$[rbp-256]
	shl	rcx, 5
	add	rcx, r15
	call	GetCOp
	cmp	eax, 8
	jne	SHORT $LN125@HllStartDi
$LL129@HllStartDi:
	inc	DWORD PTR i$[rbp-256]
	or	rax, -1
	npad	5
$LL289@HllStartDi:
	inc	rax
	cmp	BYTE PTR [rbx+rax], r12b
	jne	SHORT $LL289@HllStartDi
	add	rbx, rax
	mov	DWORD PTR hllop$2[rsp+8], r13d
	lea	rax, QWORD PTR hllop$2[rsp]
	mov	r9d, 2
	mov	QWORD PTR [rsp+48], rax
	lea	rdx, QWORD PTR i$[rbp-256]
	mov	QWORD PTR [rsp+40], rbx
	mov	r8, r15
	mov	rcx, rdi
	mov	BYTE PTR [rsp+32], 1
	call	GetAndExpression
	cmp	eax, -1
	je	SHORT $LN279@HllStartDi
	movsxd	rcx, DWORD PTR i$[rbp-256]
	shl	rcx, 5
	add	rcx, r15
	call	GetCOp
	cmp	eax, 8
	je	SHORT $LL129@HllStartDi
$LN125@HllStartDi:
	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	cmp	BYTE PTR [rax+r15], r12b
	je	SHORT $LN280@HllStartDi
	mov	ecx, 199				; 000000c7H
	call	EmitError
	mov	r12d, eax

; 1524 :           if (rc == NOT_ERROR) {

	test	eax, eax
	jne	SHORT $LN73@HllStartDi
$LN280@HllStartDi:

; 1525 :             size = strlen(buffer) + 1;

	lea	rcx, QWORD PTR buffer$[rbp-256]
	or	rax, -1
$LL288@HllStartDi:
	inc	rax
	cmp	BYTE PTR [rcx+rax], r13b
	jne	SHORT $LL288@HllStartDi
	inc	eax

; 1526 :             hll->condlines = LclAlloc(size);

	movsxd	rbx, eax
	mov	rcx, rbx
	call	LclAlloc

; 1527 :             memcpy(hll->condlines, buffer, size);

	mov	r8, rbx
	mov	QWORD PTR [rdi+80], rax
	lea	rdx, QWORD PTR buffer$[rbp-256]
	mov	rcx, rax
	call	memcpy

; 1528 :             DebugCmd(cntCond++); DebugCmd(cntCondBytes += size);
; 1529 :           }
; 1530 :         }

	jmp	SHORT $LN73@HllStartDi
$LN279@HllStartDi:

; 1523 :           rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, TRUE, buffer);

	or	r12d, -1
	jmp	SHORT $LN73@HllStartDi
$LN72@HllStartDi:

; 1531 :         else
; 1532 :           hll->condlines = "";

	lea	rax, OFFSET FLAT:$SG11749
	mov	QWORD PTR [rdi+80], rax
$LN73@HllStartDi:

; 1533 :       }
; 1534 :     }
; 1535 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSTART], buff));

	mov	r8d, DWORD PTR [rdi+44]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11750
	call	AddLineQueueX

; 1536 :     tokenarray[i].token = T_FINAL;

	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	mov	BYTE PTR [rax+r15], r13b

; 1537 :     break;

	jmp	$LN22@HllStartDi
$LN75@HllStartDi:

; 1538 :     //end of .FOR
; 1539 :   case T_DOT_WHILE:
; 1540 :   case T_DOT_REPEAT:
; 1541 :     /* create the label to start of loop */
; 1542 :     hll->labels[LSTART] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rdi+44], eax

; 1543 :     hll->labels[LTEST] = 0; /* v2.11: test label is created only if needed */

	mov	DWORD PTR [rdi+36], r13d

; 1544 :                             //hll->labels[LEXIT] = GetHllLabel(); /* v2.11: LEXIT is only needed for .BREAK */
; 1545 :     if (cmd == T_DOT_WHILE) {

	cmp	ebx, 329				; 00000149H
	jne	$LN76@HllStartDi

; 1546 :       hll->cmd = HLL_WHILE;
; 1547 :       hll->condlines = NULL;

	mov	QWORD PTR [rdi+80], r13
	mov	r10d, 1
	mov	DWORD PTR [rdi+104], r10d

; 1548 :       if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	cmp	BYTE PTR [rax+r15], r12b

; 1549 :         rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, TRUE, buffer);

	mov	BYTE PTR buffer$[rbp-256], r12b
	je	$LN79@HllStartDi
	lea	rax, QWORD PTR hllop$1[rsp]
	mov	QWORD PTR hllop$1[rsp], r13
	mov	QWORD PTR [rsp+48], rax
	lea	r9d, QWORD PTR [r10+1]
	lea	rax, QWORD PTR buffer$[rbp-256]
	mov	DWORD PTR hllop$1[rsp+8], r13d
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, QWORD PTR i$[rbp-256]
	mov	r8, r15
	mov	BYTE PTR [rsp+32], r10b
	mov	rcx, rdi
	lea	rbx, QWORD PTR buffer$[rbp-256]
	call	GetAndExpression
	cmp	eax, -1
	je	$LN281@HllStartDi
	movsxd	rcx, DWORD PTR i$[rbp-256]
	shl	rcx, 5
	add	rcx, r15
	call	GetCOp
	cmp	eax, 8
	jne	SHORT $LN178@HllStartDi
	npad	2
$LL182@HllStartDi:
	inc	DWORD PTR i$[rbp-256]
	or	rax, -1
	npad	6
$LL287@HllStartDi:
	inc	rax
	cmp	BYTE PTR [rbx+rax], r12b
	jne	SHORT $LL287@HllStartDi
	add	rbx, rax
	mov	DWORD PTR hllop$1[rsp+8], r13d
	lea	rax, QWORD PTR hllop$1[rsp]
	mov	r9d, 2
	mov	QWORD PTR [rsp+48], rax
	lea	rdx, QWORD PTR i$[rbp-256]
	mov	QWORD PTR [rsp+40], rbx
	mov	r8, r15
	mov	rcx, rdi
	mov	BYTE PTR [rsp+32], 1
	call	GetAndExpression
	cmp	eax, -1
	je	SHORT $LN281@HllStartDi
	movsxd	rcx, DWORD PTR i$[rbp-256]
	shl	rcx, 5
	add	rcx, r15
	call	GetCOp
	cmp	eax, 8
	je	SHORT $LL182@HllStartDi
$LN178@HllStartDi:
	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	cmp	BYTE PTR [rax+r15], r12b
	je	SHORT $LN282@HllStartDi
	mov	ecx, 199				; 000000c7H
	call	EmitError
	mov	r12d, eax

; 1550 :         if (rc == NOT_ERROR) {

	test	eax, eax
	jne	SHORT $LN79@HllStartDi
$LN282@HllStartDi:

; 1551 :           int size;
; 1552 :           size = strlen(buffer) + 1;

	lea	rcx, QWORD PTR buffer$[rbp-256]
	or	rax, -1
$LL286@HllStartDi:
	inc	rax
	cmp	BYTE PTR [rcx+rax], r13b
	jne	SHORT $LL286@HllStartDi
	inc	eax

; 1553 :           hll->condlines = LclAlloc(size);

	movsxd	rbx, eax
	mov	rcx, rbx
	call	LclAlloc

; 1554 :           memcpy(hll->condlines, buffer, size);

	mov	r8, rbx
	mov	QWORD PTR [rdi+80], rax
	lea	rdx, QWORD PTR buffer$[rbp-256]
	mov	rcx, rax
	call	memcpy

; 1555 :           DebugCmd(cntCond++); DebugCmd(cntCondBytes += size);
; 1556 :         }
; 1557 :       }

	jmp	SHORT $LN79@HllStartDi
$LN281@HllStartDi:

; 1549 :         rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, TRUE, buffer);

	or	r12d, -1
$LN79@HllStartDi:

; 1558 :       else
; 1559 :         buffer[0] = NULLC;  /* just ".while" without expression is accepted */
; 1560 : 
; 1561 :                             /* create a jump to test label */
; 1562 :                             /* optimisation: if line at 'test' label is just a jump, dont create label and don't jump! */
; 1563 :       if (_memicmp(buffer, "jmp", 3)) {

	mov	r8d, 3
	lea	rdx, OFFSET FLAT:$SG11758
	lea	rcx, QWORD PTR buffer$[rbp-256]
	call	_memicmp
	test	eax, eax
	je	SHORT $LN77@HllStartDi

; 1564 :         hll->labels[LTEST] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352

; 1565 :         AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[LTEST], buff));

	lea	rdx, OFFSET FLAT:$SG11118
	inc	eax
	lea	rcx, QWORD PTR buff$[rsp]
	mov	DWORD PTR ModuleInfo+352, eax
	mov	r8d, eax
	mov	DWORD PTR [rdi+36], eax
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11759
	call	AddLineQueueX

; 1566 :       }
; 1567 :     }

	jmp	SHORT $LN77@HllStartDi
$LN76@HllStartDi:

; 1568 :     else {
; 1569 :       hll->cmd = HLL_REPEAT;

	mov	DWORD PTR [rdi+104], 2
$LN77@HllStartDi:

; 1570 :     }
; 1571 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSTART], buff));

	mov	r8d, DWORD PTR [rdi+44]
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG11760
	call	AddLineQueueX
	jmp	$LN22@HllStartDi
$LN20@HllStartDi:

; 1325 :   case T_DOT_IF:
; 1326 :     hll->labels[LSTART] = 0; /* not used by .IF */

	mov	DWORD PTR [rdi+44], r13d

; 1327 :     hll->labels[LTEST] = GetHllLabel();
; 1328 :     hll->cmd = HLL_IF;
; 1329 :     hll->flags = 0;
; 1330 :     /* get the C-style expression, convert to ASM code lines */
; 1331 :     rc = EvaluateHllExpression(hll, &i, tokenarray, LTEST, FALSE, buffer);

	lea	rdx, QWORD PTR i$[rbp-256]
	mov	eax, DWORD PTR ModuleInfo+352
	xor	r9d, r9d
	inc	eax
	mov	QWORD PTR hllop$3[rsp], r13
	mov	DWORD PTR ModuleInfo+352, eax
	mov	r8, r15
	mov	DWORD PTR [rdi+36], eax
	mov	rcx, rdi
	lea	rax, QWORD PTR hllop$3[rsp]
	mov	DWORD PTR [rdi+104], r13d
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR buffer$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rdi+112], r13d
	mov	BYTE PTR [rsp+32], r12b
	mov	DWORD PTR hllop$3[rsp+8], r13d
	mov	BYTE PTR buffer$[rbp-256], r12b
	call	GetExpression
	cmp	eax, -1
	jne	SHORT $LN91@HllStartDi
	or	r12d, eax
	jmp	SHORT $LN22@HllStartDi
$LN91@HllStartDi:
	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	cmp	BYTE PTR [rax+r15], r12b
	je	SHORT $LN283@HllStartDi
	mov	ecx, 199				; 000000c7H
	call	EmitError
	mov	r12d, eax

; 1332 :     if (rc == NOT_ERROR) {

	test	eax, eax
	jne	SHORT $LN22@HllStartDi
$LN283@HllStartDi:

; 1333 :       QueueTestLines(buffer);

	lea	rbx, QWORD PTR buffer$[rbp-256]
	npad	15
$LL95@HllStartDi:
	mov	edx, 10
	mov	rcx, rbx
	mov	rsi, rbx
	call	strchr
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN97@HllStartDi
	mov	BYTE PTR [rax], r13b
	inc	rbx
$LN97@HllStartDi:
	cmp	BYTE PTR [rsi], r13b
	je	SHORT $LN98@HllStartDi
	mov	rcx, rsi
	call	AddLineQueue
$LN98@HllStartDi:
	test	rbx, rbx
	jne	SHORT $LL95@HllStartDi

; 1334 :       /* if no lines have been created, the LTEST label isn't needed */
; 1335 :       //if ( !is_linequeue_populated() ) {
; 1336 :       if (buffer[0] == NULLC) {

	cmp	BYTE PTR buffer$[rbp-256], r13b
	jne	SHORT $LN22@HllStartDi

; 1337 :         hll->labels[LTEST] = 0;

	mov	DWORD PTR [rdi+36], r13d
$LN22@HllStartDi:

; 1572 :     break;
; 1573 : #ifdef DEBUG_OUT
; 1574 :   default: /**/myassert(0); break;
; 1575 : #endif
; 1576 :   }
; 1577 : 
; 1578 :   if (tokenarray[i].token != T_FINAL && rc == NOT_ERROR) {

	movsxd	rax, DWORD PTR i$[rbp-256]
	shl	rax, 5
	cmp	BYTE PTR [rax+r15], r13b
	je	SHORT $LN82@HllStartDi
	test	r12d, r12d
	jne	SHORT $LN82@HllStartDi

; 1579 :     DebugMsg(("HllStartDir: unexpected token [%s]\n", tokenarray[i].tokpos));
; 1580 :     EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos);

	mov	rdx, QWORD PTR [rax+r15+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1581 :     rc = ERROR;

	or	r12d, -1
$LN82@HllStartDi:

; 1582 :     //return( ERROR ); /* v2.08: continue and parse the line queue */
; 1583 :   }
; 1584 :   /* v2.06: remove the item from the free stack */
; 1585 :   if (hll == HllFree)

	cmp	rdi, QWORD PTR ModuleInfo+232
	jne	SHORT $LN83@HllStartDi

; 1586 :     HllFree = hll->next;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR ModuleInfo+232, rax
$LN83@HllStartDi:

; 1587 :   hll->next = HllStack;

	mov	rax, QWORD PTR ModuleInfo+224
	mov	QWORD PTR [rdi], rax

; 1588 :   HllStack = hll;
; 1589 : 
; 1590 :   if (ModuleInfo.list)

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	mov	QWORD PTR ModuleInfo+224, rdi
	je	SHORT $LN84@HllStartDi

; 1591 :     LstWrite(LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL);

	call	GetCurrOffset
	xor	r8d, r8d
	mov	edx, eax
	lea	ecx, QWORD PTR [r8+4]
	call	LstWrite
$LN84@HllStartDi:

; 1592 : 
; 1593 :   if (is_linequeue_populated()) /* might be NULL! (".if 1") */

	cmp	QWORD PTR ModuleInfo+184, r13
	je	SHORT $LN85@HllStartDi

; 1594 :     RunLineQueue();

	call	RunLineQueue
$LN85@HllStartDi:

; 1595 : 
; 1596 :   return(rc);

	mov	eax, r12d
$LN1@HllStartDi:
	mov	rsi, QWORD PTR [rsp+7432]

; 1597 : }

	mov	rbx, QWORD PTR [rsp+7448]
	add	rsp, 7376				; 00001cd0H
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
HllStartDir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT ForInitAndNext
_TEXT	SEGMENT
codebuff$1 = 32
codebuff$2 = 32
codebuff$3 = 32
codebuff$4 = 32
codebuff$5 = 32
codebuff$6 = 32
codebuff$7 = 32
codebuff$8 = 32
codebuff$9 = 32
codebuff$10 = 32
codebuff$11 = 32
codebuff$12 = 32
codebuff$13 = 32
codebuff$14 = 32
codebuff$15 = 32
codebuff$16 = 32
codebuff$17 = 32
codebuff$18 = 32
codebuff$19 = 32
codebuff$20 = 32
codebuff$ = 288
init$ = 544
param$ = 800
tokenarray$ = 1120
op$ = 1128
cnt$ = 1128
buff$ = 1136
ForInitAndNext PROC					; COMDAT

; 1001 : static ret_code ForInitAndNext(struct asm_tok tokenarray[], int cnt, char *buff) {

	mov	QWORD PTR [rsp+32], rbx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-800]
	sub	rsp, 1056				; 00000420H

; 1002 :   int a;
; 1003 :   int j;
; 1004 :   int	b = 0;

	xor	r15d, r15d
	mov	r12, r8

; 1005 :   bool brct = 0;

	xor	r14b, r14b
	mov	esi, edx
	mov	r13, rcx
	mov	r9, 145272973819904			; 0000842000000000H
$LL4@ForInitAnd:

; 1006 :   char codebuff[256];
; 1007 :   char param[256];
; 1008 :   char init[256];
; 1009 :   char op[4];
; 1010 :   char *p;
; 1011 :   //create valid command and add to LineQueue
; 1012 :   do {
; 1013 :     //extracting the first parameter "param" before the operator
; 1014 :     a = 0;
; 1015 :     while (buff[b] && !strchr("=!<>&|-+*^%/", buff[b]))

	movsxd	rbx, r15d
	xor	edi, edi
	add	rbx, r12
	cmp	BYTE PTR [rbx], dil
	je	SHORT $LN268@ForInitAnd
	npad	2
$LL5@ForInitAnd:
	movsx	edx, BYTE PTR [rbx]
	lea	rcx, OFFSET FLAT:$SG11456
	call	strchr
	test	rax, rax
	jne	SHORT $LN531@ForInitAnd

; 1016 :     {
; 1017 :       if (buff[b] == '-' || buff[b] == '+') break;

	movzx	ecx, BYTE PTR [rbx]
	lea	eax, DWORD PTR [rcx-43]
	test	al, 253					; 000000fdH
	je	SHORT $LN531@ForInitAnd

; 1018 :       param[a] = buff[b];
; 1019 :       b++;

	inc	rbx
	mov	BYTE PTR param$[rbp+rdi-256], cl
	inc	r15d

; 1020 :       a++;

	inc	rdi
	cmp	BYTE PTR [rbx], 0
	jne	SHORT $LL5@ForInitAnd
$LN531@ForInitAnd:
	mov	r9, 145272973819904			; 0000842000000000H
$LN268@ForInitAnd:

; 1021 :     }
; 1022 :     param[a] = '\0';
; 1023 :     //end of param
; 1024 :     //is it simple operator
; 1025 :     if ((buff[b + 1] == '+') || (buff[b + 1] == '-')) {            //if ++ or -- finish it here

	movsxd	rax, r15d
	movzx	edx, BYTE PTR [rax+r12+1]
	lea	rcx, QWORD PTR [rax+r12]
	mov	BYTE PTR param$[rbp+rdi-256], 0
	lea	eax, DWORD PTR [rdx-43]
	test	al, 253					; 000000fdH
	je	$LN23@ForInitAnd

; 1032 :     }
; 1033 : 
; 1034 :     //we finis here "inc REX" or  "dec REX" or "inc mem" or "dec mem"
; 1035 :     else						//if not ++ or -- 
; 1036 :     {							//extracting the operator
; 1037 :       op[0] = buff[b];

	movzx	ebx, BYTE PTR [rcx]

; 1038 :       b++;

	inc	r15d
	mov	BYTE PTR op$[rbp-256], bl

; 1039 :       if (op[0] == '=') {     //if operator is only '='

	cmp	bl, 61					; 0000003dH
	jne	SHORT $LN27@ForInitAnd

; 1040 :         op[1] = '\0';       //finish here

	xor	r8b, r8b
	mov	BYTE PTR op$[rbp-255], r8b

; 1041 :       }

	jmp	SHORT $LN30@ForInitAnd
$LN27@ForInitAnd:

; 1042 :       else {                 //extract next operator
; 1043 :         op[1] = buff[b];

	movsxd	rax, r15d

; 1044 :         b++;

	inc	r15d
	movzx	r8d, BYTE PTR [rax+r12]
	mov	BYTE PTR op$[rbp-255], r8b
	lea	eax, DWORD PTR [r8-60]
	test	al, 253					; 000000fdH
	jne	SHORT $LN29@ForInitAnd

; 1045 :         if ((op[1] == '<' || op[1] == '>') && (buff[b] == '=')) {

	movsxd	rax, r15d
	cmp	BYTE PTR [rax+r12], 61			; 0000003dH
	jne	SHORT $LN29@ForInitAnd

; 1046 :           op[2] = buff[b]; //if a second operator is shift sign "<<=" or ">>="

	mov	WORD PTR op$[rbp-254], 61		; 0000003dH

; 1047 :           op[3] = NULLC;
; 1048 :           b++;

	inc	r15d

; 1049 :         }

	jmp	SHORT $LN30@ForInitAnd
$LN29@ForInitAnd:

; 1050 :         else op[2] = NULLC; //not shift so we have two operands

	mov	BYTE PTR op$[rbp-254], 0
$LN30@ForInitAnd:

; 1051 : 
; 1052 :       }
; 1053 :       //we finished with param and op
; 1054 :       //now extracting the second parameter "init" after the operator
; 1055 :       for (a = 0; buff[b];) { //checking if we have a char in a single ' '

	movsxd	rax, r15d
	xor	edx, edx
	movzx	ecx, BYTE PTR [rax+r12]
	test	cl, cl
	je	SHORT $LN532@ForInitAnd
$LL7@ForInitAnd:

; 1056 :         if (buff[b] == '(' && buff[b - 1] != 39 && buff[b + 1] != 39 && b) break;

	cmp	cl, 40					; 00000028H
	je	SHORT $LN541@ForInitAnd

; 1057 :         if (buff[b] == ',' && buff[b - 1] != 39 && buff[b + 1] != 39 && b) break;

	cmp	cl, 44					; 0000002cH
	jne	SHORT $LN33@ForInitAnd
$LN541@ForInitAnd:
	cmp	BYTE PTR [rax+r12-1], 39		; 00000027H
	je	SHORT $LN33@ForInitAnd
	cmp	BYTE PTR [rax+r12+1], 39		; 00000027H
	je	SHORT $LN33@ForInitAnd
	test	rax, rax
	jne	SHORT $LN532@ForInitAnd
$LN33@ForInitAnd:

; 1058 :         init[a] = buff[b];
; 1059 :         b++;

	inc	rax
	mov	BYTE PTR init$[rbp+rdx-256], cl
	inc	r15d

; 1060 :         a++;

	inc	rdx
	movzx	ecx, BYTE PTR [rax+r12]
	test	cl, cl
	jne	SHORT $LL7@ForInitAnd
$LN532@ForInitAnd:

; 1061 :       }
; 1062 :       if (buff[b] == '(' && buff[b - 1] != 39 && buff[b + 1] != 39 && b) {

	movsxd	rax, r15d
	cmp	BYTE PTR [rax+r12], 40			; 00000028H
	lea	rcx, QWORD PTR [rax+r12]
	jne	SHORT $LN34@ForInitAnd
	cmp	BYTE PTR [rcx-1], 39			; 00000027H
	je	SHORT $LN34@ForInitAnd
	cmp	BYTE PTR [rcx+1], 39			; 00000027H
	je	SHORT $LN34@ForInitAnd
	test	r15d, r15d
	je	SHORT $LN34@ForInitAnd
	mov	al, 40					; 00000028H
	npad	6
$LL12@ForInitAnd:

; 1063 :         for (; buff[b] && buff[b] != ')'; b++, a++) {

	cmp	al, 41					; 00000029H
	je	SHORT $LN11@ForInitAnd
	inc	rcx

; 1064 :           init[a] = buff[b];

	mov	BYTE PTR init$[rbp+rdx-256], al
	inc	r15d
	inc	rdx
	movzx	eax, BYTE PTR [rcx]
	test	al, al
	jne	SHORT $LL12@ForInitAnd
$LN11@ForInitAnd:

; 1065 :         }
; 1066 :         if (buff[b] == ')' && buff[b - 1] != 39 && buff[b + 1] != 39) {

	movsxd	rax, r15d
	cmp	BYTE PTR [rax+r12], 41			; 00000029H
	jne	SHORT $LN35@ForInitAnd
	cmp	BYTE PTR [rax+r12-1], 39		; 00000027H
	je	SHORT $LN35@ForInitAnd
	cmp	BYTE PTR [rax+r12+1], 39		; 00000027H
	je	SHORT $LN35@ForInitAnd

; 1067 :           init[a] = buff[b];
; 1068 :           b++;

	inc	r15d
	mov	BYTE PTR init$[rbp+rdx-256], 41		; 00000029H

; 1069 :           a++;

	inc	rdx
$LN35@ForInitAnd:

; 1070 :         }
; 1071 :         brct = TRUE;

	mov	r14b, 1
$LN34@ForInitAnd:

; 1072 :       }
; 1073 :       init[a] = NULLC;
; 1074 :       b++;

	inc	r15d
	mov	BYTE PTR init$[rbp+rdx-256], 0
	cmp	bl, 47					; 0000002fH
	ja	$LN386@ForInitAnd
	movsx	rax, bl
	bt	r9, rax
	jae	$LN386@ForInitAnd

; 1075 :       //we finished with init
; 1076 :       //is operator devision, multiplication or mod
; 1077 :       if (op[0] == '/' || op[0] == '*' || op[0] == '%') {
; 1078 :         Tokenize(param, 0, tokenarray, 0);

	xor	r9d, r9d
	lea	rcx, QWORD PTR param$[rbp-256]
	mov	r8, r13
	xor	edx, edx
	call	Tokenize

; 1079 :         if (strcasecmp(param, reax[ModuleInfo.Ofssize]) && strcasecmp(init, reax[ModuleInfo.Ofssize])) { //param not rax init not rax?    

	movzx	edx, BYTE PTR ModuleInfo+404
	lea	rax, OFFSET FLAT:__ImageBase
	lea	rcx, QWORD PTR param$[rbp-256]
	mov	rdx, QWORD PTR reax[rax+rdx*8]
	call	_stricmp
	test	eax, eax
	je	$LN39@ForInitAnd
	movzx	edx, BYTE PTR ModuleInfo+404
	lea	rax, OFFSET FLAT:__ImageBase
	lea	rcx, QWORD PTR init$[rbp-256]
	mov	rdx, QWORD PTR reax[rax+rdx*8]
	call	_stricmp
	test	eax, eax
	je	$LN39@ForInitAnd

; 1080 :           if (tokenarray[0].token == T_REG) {			//is param register              

	movzx	eax, BYTE PTR [r13]
	cmp	al, 2
	jne	$LN41@ForInitAnd

; 1081 :             if (strcasecmp(param, recx[ModuleInfo.Ofssize])) {				//make sure that param is not rcx

	movzx	edx, BYTE PTR ModuleInfo+404
	lea	rax, OFFSET FLAT:recx
	lea	rcx, QWORD PTR param$[rbp-256]
	mov	rdx, QWORD PTR [rax+rdx*8]
	call	_stricmp
	test	eax, eax
	je	$LN43@ForInitAnd

; 1082 :               WriteAsmLine(" mov  ", reax[ModuleInfo.Ofssize], param);				// MOV RAX,param

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rdx, OFFSET FLAT:__ImageBase
	xor	ecx, ecx
	mov	r8, QWORD PTR reax[rdx+rax*8]
	npad	5
$LL157@ForInitAnd:
	movzx	eax, BYTE PTR $SG11484[rcx+rdx]
	mov	BYTE PTR codebuff$20[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL157@ForInitAnd
	lea	rcx, QWORD PTR codebuff$20[rsp]
	dec	rcx
	npad	4
$LL528@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL528@ForInitAnd
	xor	edx, edx
	npad	4
$LL529@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL529@ForInitAnd
	lea	rcx, QWORD PTR codebuff$20[rsp]
	dec	rcx
	npad	8
$LL526@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL526@ForInitAnd
	xor	edx, edx
	lea	r8, OFFSET FLAT:$SG11418
	npad	13
$LL527@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL527@ForInitAnd
	lea	rcx, QWORD PTR codebuff$20[rsp]
	dec	rcx
	npad	8
$LL524@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL524@ForInitAnd
	lea	r8, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL525@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL525@ForInitAnd
	lea	rcx, QWORD PTR codebuff$20[rsp]
	call	AddLineQueue
$LN43@ForInitAnd:

; 1083 :             }						if (op[0] == '/' || op[0] == '%') {

	cmp	bl, 47					; 0000002fH
	je	SHORT $LN45@ForInitAnd
	cmp	bl, 37					; 00000025H
	jne	SHORT $LN44@ForInitAnd
$LN45@ForInitAnd:

; 1084 :               strcpy(codebuff, " cdq ");			//extend to RDX if division	

	xor	ecx, ecx
	lea	r12, OFFSET FLAT:__ImageBase
	npad	3
$LL130@ForInitAnd:
	movzx	eax, BYTE PTR $SG11487[rcx+r12]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL130@ForInitAnd

; 1085 :               AddLineQueue(codebuff);

	mov	r12, QWORD PTR buff$[rbp-256]
	lea	rcx, QWORD PTR codebuff$[rbp-256]
	call	AddLineQueue
$LN44@ForInitAnd:

; 1086 :             }
; 1087 :             Tokenize(init, 0, tokenarray, 0);

	xor	r9d, r9d
	lea	rcx, QWORD PTR init$[rbp-256]
	mov	r8, r13
	xor	edx, edx
	call	Tokenize

; 1088 :             if (tokenarray[0].token == T_NUM) {      //is init number? 

	cmp	BYTE PTR [r13], 10
	jne	$LN46@ForInitAnd

; 1089 :               WriteAsmLine(" mov  ", recx[ModuleInfo.Ofssize], init);        //MOV RCX,init

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	r8, OFFSET FLAT:recx
	xor	ecx, ecx
	lea	r12, OFFSET FLAT:__ImageBase
	mov	r8, QWORD PTR [r8+rax*8]
	npad	1
$LL160@ForInitAnd:
	movzx	eax, BYTE PTR $SG11490[rcx+r12]
	mov	BYTE PTR codebuff$19[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL160@ForInitAnd
	lea	rcx, QWORD PTR codebuff$19[rsp]
	dec	rcx
	npad	3
$LL522@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL522@ForInitAnd
	xor	edx, edx
	npad	4
$LL523@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL523@ForInitAnd
	lea	rcx, QWORD PTR codebuff$19[rsp]
	dec	rcx
	npad	8
$LL520@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL520@ForInitAnd
	xor	edx, edx
	lea	r13, OFFSET FLAT:$SG11418
	npad	13
$LL521@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+r13]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL521@ForInitAnd
	mov	r13, QWORD PTR tokenarray$[rbp-256]
	lea	rcx, QWORD PTR codebuff$19[rsp]
	dec	rcx
	npad	1
$LL518@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL518@ForInitAnd
	lea	r8, QWORD PTR init$[rbp-256]
	xor	edx, edx
	npad	13
$LL519@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL519@ForInitAnd
	lea	rcx, QWORD PTR codebuff$19[rsp]
	call	AddLineQueue

; 1090 :               if (op[0] == '/' || op[0] == '%')

	cmp	bl, 47					; 0000002fH
	je	SHORT $LN50@ForInitAnd
	cmp	bl, 37					; 00000025H
	je	SHORT $LN50@ForInitAnd

; 1092 :               else strcpy(codebuff, " imul ");		//IMUL RCX        

	xor	ecx, ecx
	lea	r12, OFFSET FLAT:__ImageBase
	npad	3
$LL132@ForInitAnd:
	movzx	eax, BYTE PTR $SG11495[rcx+r12]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL132@ForInitAnd
	jmp	SHORT $LN542@ForInitAnd
$LN50@ForInitAnd:

; 1091 :                 strcpy(codebuff, " idiv ");		//IDIV RCX        

	xor	ecx, ecx
	lea	r12, OFFSET FLAT:__ImageBase
$LL131@ForInitAnd:
	movzx	eax, BYTE PTR $SG11494[rcx+r12]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL131@ForInitAnd
$LN542@ForInitAnd:
	mov	r12, QWORD PTR buff$[rbp-256]

; 1093 :               strcat(codebuff, recx[ModuleInfo.Ofssize]);

	lea	rcx, QWORD PTR codebuff$[rbp-256]
	movzx	r8d, BYTE PTR ModuleInfo+404
	dec	rcx
	npad	5
$LL516@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL516@ForInitAnd
	lea	rax, OFFSET FLAT:recx
	xor	edx, edx
	mov	r8, QWORD PTR [rax+r8*8]
	npad	9
$LL517@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL517@ForInitAnd

; 1094 :               AddLineQueue(codebuff);
; 1095 :               goto cont;

	jmp	$LN543@ForInitAnd
$LN46@ForInitAnd:

; 1096 :             }
; 1097 :             else {
; 1098 :               if (op[0] == '/' || op[0] == '%') //it is a variable

	cmp	bl, 47					; 0000002fH
	je	SHORT $LN53@ForInitAnd
	cmp	bl, 37					; 00000025H
	je	SHORT $LN53@ForInitAnd

; 1100 :               else strcpy(codebuff, " imul ");

	xor	ecx, ecx
	lea	r12, OFFSET FLAT:__ImageBase
	npad	8
$LL134@ForInitAnd:
	movzx	eax, BYTE PTR $SG11500[rcx+r12]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL134@ForInitAnd
	mov	r12, QWORD PTR buff$[rbp-256]
	jmp	SHORT $LN52@ForInitAnd
$LN53@ForInitAnd:

; 1099 :                 strcpy(codebuff, " idiv ");

	xor	ecx, ecx
	lea	r13, OFFSET FLAT:__ImageBase
	npad	9
$LL133@ForInitAnd:
	movzx	eax, BYTE PTR $SG11499[rcx+r13]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL133@ForInitAnd
	mov	r13, QWORD PTR tokenarray$[rbp-256]
$LN52@ForInitAnd:

; 1101 :               strcat(codebuff, init);

	lea	rcx, QWORD PTR codebuff$[rbp-256]
	dec	rcx
$LL514@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL514@ForInitAnd
	lea	r8, QWORD PTR init$[rbp-256]
	xor	edx, edx
	npad	10
$LL515@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL515@ForInitAnd

; 1102 :               AddLineQueue(codebuff);
; 1103 :               goto cont;

	jmp	$LN543@ForInitAnd
$LN41@ForInitAnd:

; 1104 :             }
; 1105 :           }
; 1106 :           //if param is a variable
; 1107 :           else if (tokenarray[0].token == T_ID) {		 //YES             

	cmp	al, 8
	jne	$LN537@ForInitAnd

; 1108 :             WriteAsmLine(" mov  ", recx[ModuleInfo.Ofssize], init);        //MOV RCX,init

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	r8, OFFSET FLAT:recx
	xor	ecx, ecx
	lea	r12, OFFSET FLAT:__ImageBase
	mov	r8, QWORD PTR [r8+rax*8]
	npad	8
$LL163@ForInitAnd:
	movzx	eax, BYTE PTR $SG11502[rcx+r12]
	mov	BYTE PTR codebuff$18[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL163@ForInitAnd
	lea	rcx, QWORD PTR codebuff$18[rsp]
	dec	rcx
	npad	3
$LL512@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL512@ForInitAnd
	xor	edx, edx
	npad	4
$LL513@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL513@ForInitAnd
	lea	rcx, QWORD PTR codebuff$18[rsp]
	dec	rcx
	npad	8
$LL510@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL510@ForInitAnd
	xor	edx, edx
	lea	r13, OFFSET FLAT:$SG11418
	npad	13
$LL511@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+r13]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL511@ForInitAnd
	lea	rcx, QWORD PTR codebuff$18[rsp]
	dec	rcx
	npad	8
$LL508@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL508@ForInitAnd
	lea	r8, QWORD PTR init$[rbp-256]
	xor	edx, edx
	npad	13
$LL509@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL509@ForInitAnd
	lea	rcx, QWORD PTR codebuff$18[rsp]
	call	AddLineQueue

; 1109 :             WriteAsmLine(" mov  ", reax[ModuleInfo.Ofssize], param);		// MOV RAX,param

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rdx, OFFSET FLAT:__ImageBase
	xor	ecx, ecx
	mov	r8, QWORD PTR reax[rdx+rax*8]
	npad	14
$LL166@ForInitAnd:
	movzx	eax, BYTE PTR $SG11503[rcx+rdx]
	mov	BYTE PTR codebuff$17[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL166@ForInitAnd
	lea	rcx, QWORD PTR codebuff$17[rsp]
	dec	rcx
	npad	4
$LL506@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL506@ForInitAnd
	xor	edx, edx
	npad	4
$LL507@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL507@ForInitAnd
	lea	rcx, QWORD PTR codebuff$17[rsp]
	dec	rcx
	npad	8
$LL504@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL504@ForInitAnd
	xor	edx, edx
	lea	r13, OFFSET FLAT:$SG11418
	npad	13
$LL505@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+r13]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL505@ForInitAnd
	mov	r13, QWORD PTR tokenarray$[rbp-256]
	lea	rcx, QWORD PTR codebuff$17[rsp]
	dec	rcx
	npad	1
$LL502@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL502@ForInitAnd
	lea	r8, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL503@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL503@ForInitAnd
	lea	rcx, QWORD PTR codebuff$17[rsp]
	call	AddLineQueue

; 1110 :             if (op[0] == '/' || op[0] == '%') {

	cmp	bl, 47					; 0000002fH
	je	SHORT $LN57@ForInitAnd
	cmp	bl, 37					; 00000025H
	je	SHORT $LN57@ForInitAnd

; 1114 :             }
; 1115 :             else strcpy(codebuff, " imul ");

	xor	ecx, ecx
	lea	r12, OFFSET FLAT:__ImageBase
	npad	3
$LL137@ForInitAnd:
	movzx	eax, BYTE PTR $SG11509[rcx+r12]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL137@ForInitAnd
	jmp	SHORT $LN544@ForInitAnd
$LN57@ForInitAnd:

; 1111 :               strcpy(codebuff, " cdq ");

	xor	ecx, ecx
	lea	r13, OFFSET FLAT:__ImageBase
$LL135@ForInitAnd:
	movzx	eax, BYTE PTR $SG11507[rcx+r13]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL135@ForInitAnd

; 1112 :               AddLineQueue(codebuff);

	mov	r13, QWORD PTR tokenarray$[rbp-256]
	lea	rcx, QWORD PTR codebuff$[rbp-256]
	call	AddLineQueue

; 1113 :               strcpy(codebuff, " idiv ");

	xor	ecx, ecx
	lea	r12, OFFSET FLAT:__ImageBase
	npad	2
$LL136@ForInitAnd:
	movzx	eax, BYTE PTR $SG11508[rcx+r12]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL136@ForInitAnd
$LN544@ForInitAnd:
	mov	r12, QWORD PTR buff$[rbp-256]

; 1116 :             strcat(codebuff, recx[ModuleInfo.Ofssize]);

	lea	rcx, QWORD PTR codebuff$[rbp-256]
	movzx	r8d, BYTE PTR ModuleInfo+404
	dec	rcx
	npad	5
$LL500@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL500@ForInitAnd
	lea	rax, OFFSET FLAT:recx
	xor	edx, edx
	mov	r8, QWORD PTR [rax+r8*8]
	npad	9
$LL501@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL501@ForInitAnd
$LN543@ForInitAnd:

; 1117 :             AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rbp-256]
	call	AddLineQueue
$cont$553:

; 1118 :           cont:
; 1119 :             if (op[0] == '%') {
; 1120 :               WriteAsmLine(" mov  ", param, redx[ModuleInfo.Ofssize]);

	movzx	eax, BYTE PTR ModuleInfo+404
	xor	ecx, ecx
	cmp	bl, 37					; 00000025H
	lea	rbx, OFFSET FLAT:__ImageBase
	jne	$LN58@ForInitAnd
	mov	r8, QWORD PTR redx[rbx+rax*8]
	npad	6
$LL169@ForInitAnd:
	movzx	eax, BYTE PTR $SG11512[rcx+rbx]
	mov	BYTE PTR codebuff$16[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL169@ForInitAnd
	lea	rcx, QWORD PTR codebuff$16[rsp]
	dec	rcx
	npad	4
$LL498@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL498@ForInitAnd
	lea	r9, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL499@ForInitAnd:
	movzx	eax, BYTE PTR [r9+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL499@ForInitAnd
	lea	rcx, QWORD PTR codebuff$16[rsp]
	dec	rcx
	npad	8
$LL496@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL496@ForInitAnd
	xor	edx, edx
	lea	r12, OFFSET FLAT:$SG11418
	npad	13
$LL497@ForInitAnd:
	movzx	eax, BYTE PTR [r12+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL497@ForInitAnd
	mov	r12, QWORD PTR buff$[rbp-256]
	lea	rcx, QWORD PTR codebuff$16[rsp]
	dec	rcx
	npad	1
$LL494@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL494@ForInitAnd
	xor	edx, edx
	npad	4
$LL495@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL495@ForInitAnd
	lea	rcx, QWORD PTR codebuff$16[rsp]
	call	AddLineQueue

; 1121 :               goto skip;

	jmp	$skip$554
$LN58@ForInitAnd:

; 1122 :             }
; 1123 :             else {
; 1124 :               WriteAsmLine(" mov  ", param, reax[ModuleInfo.Ofssize]);

	mov	r8, QWORD PTR reax[rbx+rax*8]
	npad	10
$LL172@ForInitAnd:
	movzx	eax, BYTE PTR $SG11513[rcx+rbx]
	mov	BYTE PTR codebuff$15[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL172@ForInitAnd
	lea	rcx, QWORD PTR codebuff$15[rsp]
	dec	rcx
	npad	4
$LL492@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL492@ForInitAnd
	lea	r9, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL493@ForInitAnd:
	movzx	eax, BYTE PTR [r9+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL493@ForInitAnd
	lea	rcx, QWORD PTR codebuff$15[rsp]
	dec	rcx
	npad	8
$LL490@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL490@ForInitAnd
	xor	edx, edx
	lea	r13, OFFSET FLAT:$SG11418
	npad	13
$LL491@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+r13]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL491@ForInitAnd
	mov	r13, QWORD PTR tokenarray$[rbp-256]
	lea	rcx, QWORD PTR codebuff$15[rsp]
	dec	rcx
	npad	1
$LL488@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL488@ForInitAnd
	xor	edx, edx
	npad	4
$LL489@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL489@ForInitAnd
	lea	rcx, QWORD PTR codebuff$15[rsp]
	call	AddLineQueue

; 1125 :               goto skip;

	jmp	$skip$554
$LN39@ForInitAnd:

; 1126 :             }
; 1127 :           }
; 1128 :         }
; 1129 :         // if param is not RAX and init is RCX
; 1130 :         else if ((strcasecmp(param, reax[ModuleInfo.Ofssize]) && !(strcasecmp(init, recx[ModuleInfo.Ofssize])))) {

	movzx	edx, BYTE PTR ModuleInfo+404
	lea	rax, OFFSET FLAT:__ImageBase
	lea	rcx, QWORD PTR param$[rbp-256]
	mov	rdx, QWORD PTR reax[rax+rdx*8]
	call	_stricmp
	test	eax, eax
	je	$LN60@ForInitAnd
	movzx	edx, BYTE PTR ModuleInfo+404
	lea	rax, OFFSET FLAT:recx
	lea	rcx, QWORD PTR init$[rbp-256]
	mov	rdx, QWORD PTR [rax+rdx*8]
	call	_stricmp
	test	eax, eax
	jne	$LN60@ForInitAnd

; 1131 :           if (op[0] == '/' || op[0] == '%') {

	cmp	bl, 47					; 0000002fH
	je	SHORT $LN64@ForInitAnd
	cmp	bl, 37					; 00000025H
	je	SHORT $LN64@ForInitAnd

; 1135 :           }
; 1136 :           else strcpy(codebuff, " imul ");

	xor	ecx, ecx
	lea	r12, OFFSET FLAT:__ImageBase
$LL140@ForInitAnd:
	movzx	eax, BYTE PTR $SG11521[rcx+r12]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL140@ForInitAnd
	jmp	SHORT $LN545@ForInitAnd
$LN64@ForInitAnd:

; 1132 :             strcpy(codebuff, " cdq ");

	xor	ecx, ecx
	lea	r13, OFFSET FLAT:__ImageBase
$LL138@ForInitAnd:
	movzx	eax, BYTE PTR $SG11519[rcx+r13]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL138@ForInitAnd

; 1133 :             AddLineQueue(codebuff);

	mov	r13, QWORD PTR tokenarray$[rbp-256]
	lea	rcx, QWORD PTR codebuff$[rbp-256]
	call	AddLineQueue

; 1134 :             strcpy(codebuff, " idiv ");

	xor	ecx, ecx
	lea	r12, OFFSET FLAT:__ImageBase
	npad	1
$LL139@ForInitAnd:
	movzx	eax, BYTE PTR $SG11520[rcx+r12]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL139@ForInitAnd
$LN545@ForInitAnd:
	mov	r12, QWORD PTR buff$[rbp-256]

; 1137 :           strcat(codebuff, recx[ModuleInfo.Ofssize]);

	lea	rcx, QWORD PTR codebuff$[rbp-256]
	movzx	r8d, BYTE PTR ModuleInfo+404
	dec	rcx
	npad	5
$LL486@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL486@ForInitAnd
	lea	rax, OFFSET FLAT:recx
	xor	edx, edx
	mov	r8, QWORD PTR [rax+r8*8]
	npad	9
$LL487@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL487@ForInitAnd

; 1138 :           AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rbp-256]
	call	AddLineQueue

; 1139 :           if (op[0] == '%') WriteAsmLine(" mov  ", param, redx[ModuleInfo.Ofssize]);

	cmp	bl, 37					; 00000025H
	jne	$skip$554
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rbx, OFFSET FLAT:__ImageBase
	xor	ecx, ecx
	mov	r8, QWORD PTR redx[rbx+rax*8]
	npad	7
$LL175@ForInitAnd:
	movzx	eax, BYTE PTR $SG11523[rcx+rbx]
	mov	BYTE PTR codebuff$14[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL175@ForInitAnd
	lea	rcx, QWORD PTR codebuff$14[rsp]
	dec	rcx
	npad	4
$LL484@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL484@ForInitAnd
	lea	r9, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL485@ForInitAnd:
	movzx	eax, BYTE PTR [r9+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL485@ForInitAnd
	lea	rcx, QWORD PTR codebuff$14[rsp]
	dec	rcx
	npad	8
$LL482@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL482@ForInitAnd
	xor	edx, edx
	lea	r13, OFFSET FLAT:$SG11418
	npad	13
$LL483@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+r13]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL483@ForInitAnd
	mov	r13, QWORD PTR tokenarray$[rbp-256]
	lea	rcx, QWORD PTR codebuff$14[rsp]
	dec	rcx
	npad	1
$LL480@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL480@ForInitAnd
	xor	edx, edx
	npad	4
$LL481@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL481@ForInitAnd
	lea	rcx, QWORD PTR codebuff$14[rsp]
	call	AddLineQueue

; 1140 :           goto skip;

	jmp	$skip$554
$LN60@ForInitAnd:

; 1141 :         }
; 1142 :         // if param is RAX and init is RCX
; 1143 :         else if ((!(strcasecmp(param, reax[ModuleInfo.Ofssize])) && (!(strcmp(init, recx[ModuleInfo.Ofssize]))))) {

	movzx	edx, BYTE PTR ModuleInfo+404
	lea	rax, OFFSET FLAT:__ImageBase
	lea	rcx, QWORD PTR param$[rbp-256]
	mov	rdx, QWORD PTR reax[rax+rdx*8]
	call	_stricmp
	movzx	r9d, BYTE PTR ModuleInfo+404
	test	eax, eax
	jne	$LN66@ForInitAnd
	movzx	eax, r9b
	lea	r10, OFFSET FLAT:recx
	lea	rcx, QWORD PTR init$[rbp-256]
	mov	r8, QWORD PTR [r10+rax*8]
	sub	r8, rcx
	npad	7
$LL478@ForInitAnd:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+r8]
	sub	edx, eax
	jne	SHORT $LN479@ForInitAnd
	inc	rcx
	test	eax, eax
	jne	SHORT $LL478@ForInitAnd
$LN479@ForInitAnd:
	test	edx, edx
	jne	$LN66@ForInitAnd

; 1144 :           if (op[0] == '/' || op[0] == '%') {

	cmp	bl, 47					; 0000002fH
	je	SHORT $LN70@ForInitAnd
	cmp	bl, 37					; 00000025H
	je	SHORT $LN70@ForInitAnd

; 1148 :           }
; 1149 :           else strcpy(codebuff, " imul ");

	xor	ecx, ecx
	lea	r12, OFFSET FLAT:__ImageBase
	npad	2
$LL143@ForInitAnd:
	movzx	eax, BYTE PTR $SG11531[rcx+r12]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL143@ForInitAnd
	jmp	SHORT $LN546@ForInitAnd
$LN70@ForInitAnd:

; 1145 :             strcpy(codebuff, " cdq ");

	xor	ecx, ecx
	lea	r13, OFFSET FLAT:__ImageBase
$LL141@ForInitAnd:
	movzx	eax, BYTE PTR $SG11529[rcx+r13]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL141@ForInitAnd

; 1146 :             AddLineQueue(codebuff);

	mov	r13, QWORD PTR tokenarray$[rbp-256]
	lea	rcx, QWORD PTR codebuff$[rbp-256]
	call	AddLineQueue

; 1147 :             strcpy(codebuff, " idiv ");

	xor	ecx, ecx
	lea	r12, OFFSET FLAT:__ImageBase
	npad	2
$LL142@ForInitAnd:
	movzx	eax, BYTE PTR $SG11530[rcx+r12]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL142@ForInitAnd
	movzx	r9d, BYTE PTR ModuleInfo+404
	lea	r10, OFFSET FLAT:recx
$LN546@ForInitAnd:

; 1150 :           strcat(codebuff, recx[ModuleInfo.Ofssize]);

	mov	r12, QWORD PTR buff$[rbp-256]
	lea	rcx, QWORD PTR codebuff$[rbp-256]
	dec	rcx
	movzx	r8d, r9b
$LL476@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL476@ForInitAnd
	mov	r8, QWORD PTR [r10+r8*8]
	xor	edx, edx
	npad	10
$LL477@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL477@ForInitAnd

; 1151 :           AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rbp-256]
	call	AddLineQueue

; 1152 :           if (op[0] == '%') WriteAsmLine(" mov  ", param, redx[ModuleInfo.Ofssize]);

	cmp	bl, 37					; 00000025H
	jne	$skip$554
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rbx, OFFSET FLAT:__ImageBase
	xor	ecx, ecx
	mov	r8, QWORD PTR redx[rbx+rax*8]
	npad	7
$LL178@ForInitAnd:
	movzx	eax, BYTE PTR $SG11533[rcx+rbx]
	mov	BYTE PTR codebuff$13[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL178@ForInitAnd
	lea	rcx, QWORD PTR codebuff$13[rsp]
	dec	rcx
	npad	4
$LL474@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL474@ForInitAnd
	lea	r9, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL475@ForInitAnd:
	movzx	eax, BYTE PTR [r9+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL475@ForInitAnd
	lea	rcx, QWORD PTR codebuff$13[rsp]
	dec	rcx
	npad	8
$LL472@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL472@ForInitAnd
	xor	edx, edx
	lea	r13, OFFSET FLAT:$SG11418
	npad	13
$LL473@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+r13]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL473@ForInitAnd
	mov	r13, QWORD PTR tokenarray$[rbp-256]
	lea	rcx, QWORD PTR codebuff$13[rsp]
	dec	rcx
	npad	1
$LL470@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL470@ForInitAnd
	xor	edx, edx
	npad	4
$LL471@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL471@ForInitAnd
	lea	rcx, QWORD PTR codebuff$13[rsp]
	call	AddLineQueue

; 1153 :           goto skip;

	jmp	$skip$554
$LN66@ForInitAnd:

; 1154 :         }
; 1155 :         // if param is RAX and init is not RCX
; 1156 :         else if (!(strcasecmp(param, reax[ModuleInfo.Ofssize]) && (strcasecmp(init, recx[ModuleInfo.Ofssize])))) {

	movzx	edx, r9b
	lea	rax, OFFSET FLAT:__ImageBase
	lea	rcx, QWORD PTR param$[rbp-256]
	mov	rdx, QWORD PTR reax[rax+rdx*8]
	call	_stricmp
	test	eax, eax
	je	SHORT $LN73@ForInitAnd
	movzx	edx, BYTE PTR ModuleInfo+404
	lea	rax, OFFSET FLAT:recx
	lea	rcx, QWORD PTR init$[rbp-256]
	mov	rdx, QWORD PTR [rax+rdx*8]
	call	_stricmp
	test	eax, eax
	jne	$LN537@ForInitAnd
$LN73@ForInitAnd:

; 1157 :           WriteAsmLine(" mov  ", recx[ModuleInfo.Ofssize], init);        //MOV RCX,init

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	r8, OFFSET FLAT:recx
	xor	ecx, ecx
	lea	r12, OFFSET FLAT:__ImageBase
	mov	r8, QWORD PTR [r8+rax*8]
$LL181@ForInitAnd:
	movzx	eax, BYTE PTR $SG11536[rcx+r12]
	mov	BYTE PTR codebuff$12[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL181@ForInitAnd
	lea	rcx, QWORD PTR codebuff$12[rsp]
	dec	rcx
	npad	1
$LL468@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL468@ForInitAnd
	xor	edx, edx
	npad	4
$LL469@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL469@ForInitAnd
	lea	rcx, QWORD PTR codebuff$12[rsp]
	dec	rcx
	npad	8
$LL466@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL466@ForInitAnd
	xor	edx, edx
	lea	r13, OFFSET FLAT:$SG11418
	npad	13
$LL467@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+r13]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL467@ForInitAnd
	mov	r13, QWORD PTR tokenarray$[rbp-256]
	lea	rcx, QWORD PTR codebuff$12[rsp]
	dec	rcx
	npad	1
$LL464@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL464@ForInitAnd
	lea	r8, QWORD PTR init$[rbp-256]
	xor	edx, edx
	npad	13
$LL465@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL465@ForInitAnd
	lea	rcx, QWORD PTR codebuff$12[rsp]
	call	AddLineQueue

; 1158 :           if (op[0] == '/' || op[0] == '%') {

	cmp	bl, 47					; 0000002fH
	je	SHORT $LN76@ForInitAnd
	cmp	bl, 37					; 00000025H
	je	SHORT $LN76@ForInitAnd

; 1162 :           }
; 1163 :           else strcpy(codebuff, " imul ");

	xor	ecx, ecx
	lea	r12, OFFSET FLAT:__ImageBase
	npad	3
$LL146@ForInitAnd:
	movzx	eax, BYTE PTR $SG11542[rcx+r12]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL146@ForInitAnd
	jmp	SHORT $LN547@ForInitAnd
$LN76@ForInitAnd:

; 1159 :             strcpy(codebuff, " cdq ");

	xor	ecx, ecx
	lea	r13, OFFSET FLAT:__ImageBase
$LL144@ForInitAnd:
	movzx	eax, BYTE PTR $SG11540[rcx+r13]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL144@ForInitAnd

; 1160 :             AddLineQueue(codebuff);

	mov	r13, QWORD PTR tokenarray$[rbp-256]
	lea	rcx, QWORD PTR codebuff$[rbp-256]
	call	AddLineQueue

; 1161 :             strcpy(codebuff, " idiv ");

	xor	ecx, ecx
	lea	r12, OFFSET FLAT:__ImageBase
	npad	2
$LL145@ForInitAnd:
	movzx	eax, BYTE PTR $SG11541[rcx+r12]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL145@ForInitAnd
$LN547@ForInitAnd:
	mov	r12, QWORD PTR buff$[rbp-256]

; 1164 :           strcat(codebuff, recx[ModuleInfo.Ofssize]);

	lea	rcx, QWORD PTR codebuff$[rbp-256]
	movzx	r8d, BYTE PTR ModuleInfo+404
	dec	rcx
	npad	5
$LL462@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL462@ForInitAnd
	lea	rax, OFFSET FLAT:recx
	xor	edx, edx
	mov	r8, QWORD PTR [rax+r8*8]
	npad	9
$LL463@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL463@ForInitAnd

; 1165 :           AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rbp-256]
	call	AddLineQueue

; 1166 :           if (op[0] == '%') WriteAsmLine(" mov  ", param, redx[ModuleInfo.Ofssize]);

	cmp	bl, 37					; 00000025H
	jne	$skip$554
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rbx, OFFSET FLAT:__ImageBase
	xor	ecx, ecx
	mov	r8, QWORD PTR redx[rbx+rax*8]
	npad	7
$LL184@ForInitAnd:
	movzx	eax, BYTE PTR $SG11544[rcx+rbx]
	mov	BYTE PTR codebuff$11[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL184@ForInitAnd
	lea	rcx, QWORD PTR codebuff$11[rsp]
	dec	rcx
	npad	4
$LL460@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL460@ForInitAnd
	lea	r9, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL461@ForInitAnd:
	movzx	eax, BYTE PTR [r9+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL461@ForInitAnd
	lea	rcx, QWORD PTR codebuff$11[rsp]
	dec	rcx
	npad	8
$LL458@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL458@ForInitAnd
	xor	edx, edx
	lea	r12, OFFSET FLAT:$SG11418
	npad	13
$LL459@ForInitAnd:
	movzx	eax, BYTE PTR [r12+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL459@ForInitAnd
	mov	r12, QWORD PTR buff$[rbp-256]
	lea	rcx, QWORD PTR codebuff$11[rsp]
	dec	rcx
	npad	1
$LL456@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL456@ForInitAnd
	xor	edx, edx
	npad	4
$LL457@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL457@ForInitAnd
	lea	rcx, QWORD PTR codebuff$11[rsp]
	call	AddLineQueue

; 1167 :           goto skip;

	jmp	$skip$554
$LN386@ForInitAnd:

; 1168 :         }
; 1169 :       }
; 1170 :       //if operator not devision, multiplication or mod
; 1171 :       else if (op[0] == '-') strcpy(codebuff, " sub ");

	cmp	bl, 45					; 0000002dH
	jne	SHORT $LN78@ForInitAnd
	xor	ecx, ecx
	lea	rbx, OFFSET FLAT:__ImageBase
	npad	4
$LL147@ForInitAnd:
	movzx	eax, BYTE PTR $SG11547[rcx+rbx]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL147@ForInitAnd
	jmp	$LN72@ForInitAnd
$LN78@ForInitAnd:

; 1172 :       else if (op[0] == '+') strcpy(codebuff, " add ");

	cmp	bl, 43					; 0000002bH
	jne	SHORT $LN80@ForInitAnd
	xor	ecx, ecx
	lea	rbx, OFFSET FLAT:__ImageBase
	npad	9
$LL148@ForInitAnd:
	movzx	eax, BYTE PTR $SG11550[rcx+rbx]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL148@ForInitAnd
	jmp	$LN72@ForInitAnd
$LN80@ForInitAnd:

; 1173 :       else if (op[0] == '&') strcpy(codebuff, " and ");

	cmp	bl, 38					; 00000026H
	jne	SHORT $LN82@ForInitAnd
	xor	ecx, ecx
	lea	rbx, OFFSET FLAT:__ImageBase
	npad	9
$LL149@ForInitAnd:
	movzx	eax, BYTE PTR $SG11553[rcx+rbx]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL149@ForInitAnd
	jmp	$LN72@ForInitAnd
$LN82@ForInitAnd:

; 1174 :       else if (op[0] == '|') strcpy(codebuff, " or ");

	cmp	bl, 124					; 0000007cH
	jne	SHORT $LN84@ForInitAnd
	xor	ecx, ecx
	lea	rbx, OFFSET FLAT:__ImageBase
	npad	9
$LL150@ForInitAnd:
	movzx	eax, BYTE PTR $SG11556[rcx+rbx]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL150@ForInitAnd
	jmp	$LN72@ForInitAnd
$LN84@ForInitAnd:

; 1175 :       else if (op[0] == '^') strcpy(codebuff, " xor ");

	cmp	bl, 94					; 0000005eH
	jne	SHORT $LN86@ForInitAnd
	xor	ecx, ecx
	lea	rbx, OFFSET FLAT:__ImageBase
	npad	9
$LL151@ForInitAnd:
	movzx	eax, BYTE PTR $SG11559[rcx+rbx]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL151@ForInitAnd
	jmp	SHORT $LN72@ForInitAnd
$LN86@ForInitAnd:

; 1176 :       else if (op[0] == '<' && op[1] == '<') strcpy(codebuff, " shl ");

	cmp	bl, 60					; 0000003cH
	jne	SHORT $LN88@ForInitAnd
	lea	rbx, OFFSET FLAT:__ImageBase
	cmp	r8b, 60					; 0000003cH
	jne	SHORT $LN72@ForInitAnd
	xor	ecx, ecx
	npad	6
$LL152@ForInitAnd:
	movzx	eax, BYTE PTR $SG11562[rcx+rbx]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL152@ForInitAnd
	jmp	SHORT $LN72@ForInitAnd
$LN88@ForInitAnd:

; 1177 :       else if (op[0] == '>' && op[1] == '>') strcpy(codebuff, " shr ");

	cmp	bl, 62					; 0000003eH
	jne	SHORT $LN537@ForInitAnd
	lea	rbx, OFFSET FLAT:__ImageBase
	cmp	r8b, 62					; 0000003eH
	jne	SHORT $LN72@ForInitAnd
	xor	ecx, ecx
	npad	6
$LL153@ForInitAnd:
	movzx	eax, BYTE PTR $SG11564[rbx+rcx]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL153@ForInitAnd
	jmp	SHORT $LN72@ForInitAnd
$LN537@ForInitAnd:
	lea	rbx, OFFSET FLAT:__ImageBase
$LN72@ForInitAnd:

; 1178 :       Tokenize(init, 0, tokenarray, 0);

	xor	r9d, r9d
	lea	rcx, QWORD PTR init$[rbp-256]
	mov	r8, r13
	xor	edx, edx
	call	Tokenize
	movzx	eax, BYTE PTR [r13]
	sub	al, 2
	test	al, 246					; 000000f6H
	je	$simple$555

; 1179 :       if (tokenarray[0].token == T_REG || tokenarray[0].token == T_NUM || tokenarray[0].token == T_FLOAT || tokenarray[0].token == T_DIRECTIVE)
; 1180 :         goto simple;
; 1181 :       Tokenize(param, 0, tokenarray, 0);

	xor	r9d, r9d
	lea	rcx, QWORD PTR param$[rbp-256]
	mov	r8, r13
	xor	edx, edx
	call	Tokenize

; 1182 :       if (tokenarray[0].token == T_REG) {

	cmp	BYTE PTR [r13], 2
	je	$simple$555

; 1232 :       else
; 1233 :       {
; 1234 :         if (init[0] == 39 && init[2] == 39)

	cmp	BYTE PTR init$[rbp-256], 39		; 00000027H
	jne	$LN124@ForInitAnd
	cmp	BYTE PTR init$[rbp-254], 39		; 00000027H
	jne	$LN124@ForInitAnd

; 1235 :           WriteAsmLine(" mov  byte ptr ", param, init);

	xor	ecx, ecx
	npad	5
$LL214@ForInitAnd:
	movzx	eax, BYTE PTR $SG11619[rcx+rbx]
	mov	BYTE PTR codebuff$1[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL214@ForInitAnd
	lea	rcx, QWORD PTR codebuff$1[rsp]
	dec	rcx
	npad	4
$LL454@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL454@ForInitAnd
	lea	r8, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL455@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL455@ForInitAnd
	lea	rcx, QWORD PTR codebuff$1[rsp]
	dec	rcx
	npad	8
$LL452@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL452@ForInitAnd
	xor	edx, edx
	lea	r12, OFFSET FLAT:$SG11418
	npad	13
$LL453@ForInitAnd:
	movzx	eax, BYTE PTR [r12+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL453@ForInitAnd
	mov	r12, QWORD PTR buff$[rbp-256]
	lea	rcx, QWORD PTR codebuff$1[rsp]
	dec	rcx
	npad	1
$LL450@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL450@ForInitAnd
	lea	r8, QWORD PTR init$[rbp-256]
	xor	edx, edx
	npad	13
$LL451@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL451@ForInitAnd
	lea	rcx, QWORD PTR codebuff$1[rsp]
	call	AddLineQueue
	jmp	$skip$554
$LN124@ForInitAnd:

; 1236 :         else {
; 1237 :           WriteAsmLine(" mov  ", reax[ModuleInfo.Ofssize], init);

	movzx	edx, BYTE PTR ModuleInfo+404
	lea	r8, QWORD PTR init$[rbp-256]
	lea	rcx, OFFSET FLAT:$SG11620
	mov	rdx, QWORD PTR reax[rbx+rdx*8]
	call	WriteAsmLine

; 1238 :           WriteAsmLine(codebuff, param, reax[ModuleInfo.Ofssize]);

	movzx	r8d, BYTE PTR ModuleInfo+404
	lea	rdx, QWORD PTR param$[rbp-256]
	lea	rcx, QWORD PTR codebuff$[rbp-256]
	mov	r8, QWORD PTR reax[rbx+r8*8]
	call	WriteAsmLine
	jmp	$skip$554
$simple$555:

; 1183 :       simple:			Tokenize(param, 0, tokenarray, 0);

	xor	r9d, r9d
	lea	rcx, QWORD PTR param$[rbp-256]
	mov	r8, r13
	xor	edx, edx
	call	Tokenize

; 1184 : 
; 1185 :         if (strlen(init) == 1 && init[0] == '0')                        //REX=0?

	lea	rax, QWORD PTR init$[rbp-256]
	or	rcx, -1
$LL449@ForInitAnd:
	inc	rcx
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL449@ForInitAnd
	cmp	rcx, 1
	jne	$LN95@ForInitAnd
	cmp	BYTE PTR init$[rbp-256], 48		; 00000030H
	jne	$LN95@ForInitAnd

; 1186 :           WriteAsmLine(" xor  ", param, param);							            //XOR REX,REX //instead MOV REX,0				

	xor	ecx, ecx
	npad	10
$LL187@ForInitAnd:
	movzx	eax, BYTE PTR $SG11571[rcx+rbx]
	mov	BYTE PTR codebuff$10[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL187@ForInitAnd
	lea	rcx, QWORD PTR codebuff$10[rsp]
	dec	rcx
	npad	4
$LL447@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL447@ForInitAnd
	lea	r8, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL448@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL448@ForInitAnd
	lea	rcx, QWORD PTR codebuff$10[rsp]
	dec	rcx
	npad	8
$LL445@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL445@ForInitAnd
	xor	edx, edx
	lea	r12, OFFSET FLAT:$SG11418
	npad	13
$LL446@ForInitAnd:
	movzx	eax, BYTE PTR [r12+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL446@ForInitAnd
	mov	r12, QWORD PTR buff$[rbp-256]
	lea	rcx, QWORD PTR codebuff$10[rsp]
	dec	rcx
	npad	1
$LL443@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL443@ForInitAnd
	lea	r8, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL444@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL444@ForInitAnd
	lea	rcx, QWORD PTR codebuff$10[rsp]
	call	AddLineQueue
	jmp	$skip$554
$LN95@ForInitAnd:

; 1187 :         else if ((strlen(op) == 1) && ((init[4] == ' ') || (init[4] == '\t'))) {  //op is '='

	lea	rdx, QWORD PTR op$[rbp-256]
	or	rax, -1
	npad	7
$LL442@ForInitAnd:
	inc	rax
	cmp	BYTE PTR [rdx+rax], 0
	jne	SHORT $LL442@ForInitAnd
	cmp	rax, 1
	jne	$LN122@ForInitAnd
	movzx	edx, BYTE PTR init$[rbp-252]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN99@ForInitAnd
	cmp	dl, 9
	jne	$LN97@ForInitAnd
$LN99@ForInitAnd:

; 1188 :           if ((0 == _memicmp(init, "BYTE PTR", 8)) ||                   //reax=BYTE PTR al 
; 1189 :             (0 == _memicmp(init, "BPTR", 4)) ||
; 1190 :             (0 == _memicmp(init, "WPTR", 4)) ||

	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG11578
	lea	rcx, QWORD PTR init$[rbp-256]
	call	_memicmp
	test	eax, eax
	je	$LN102@ForInitAnd
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11579
	lea	rcx, QWORD PTR init$[rbp-256]
	call	_memicmp
	test	eax, eax
	je	$LN102@ForInitAnd
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11580
	lea	rcx, QWORD PTR init$[rbp-256]
	call	_memicmp
	test	eax, eax
	je	$LN102@ForInitAnd
	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG11581
	lea	rcx, QWORD PTR init$[rbp-256]
	call	_memicmp
	test	eax, eax
	je	$LN102@ForInitAnd

; 1194 :           else if (0 == _memicmp(init, "ADDR", 4))

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11585
	lea	rcx, QWORD PTR init$[rbp-256]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN103@ForInitAnd

; 1195 :             WriteAsmLine(" lea  ", param, init + 5);

	lea	r8, QWORD PTR init$[rbp-251]
	lea	rdx, QWORD PTR param$[rbp-256]
	lea	rcx, OFFSET FLAT:$SG11586
	call	WriteAsmLine
	jmp	$skip$554
$LN103@ForInitAnd:

; 1196 :           else WriteAsmLine(" mov  ", param, init);

	xor	ecx, ecx
	npad	6
$LL193@ForInitAnd:
	movzx	eax, BYTE PTR $SG11587[rcx+rbx]
	mov	BYTE PTR codebuff$8[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL193@ForInitAnd
	lea	rcx, QWORD PTR codebuff$8[rsp]
	dec	rcx
	npad	4
$LL440@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL440@ForInitAnd
	lea	r8, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL441@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL441@ForInitAnd
	lea	rcx, QWORD PTR codebuff$8[rsp]
	dec	rcx
	npad	8
$LL438@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL438@ForInitAnd
	xor	edx, edx
	lea	r12, OFFSET FLAT:$SG11418
	npad	13
$LL439@ForInitAnd:
	movzx	eax, BYTE PTR [r12+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL439@ForInitAnd
	mov	r12, QWORD PTR buff$[rbp-256]
	lea	rcx, QWORD PTR codebuff$8[rsp]
	dec	rcx
	npad	1
$LL436@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL436@ForInitAnd
	lea	r8, QWORD PTR init$[rbp-256]
	xor	edx, edx
	npad	13
$LL437@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL437@ForInitAnd
	lea	rcx, QWORD PTR codebuff$8[rsp]
	call	AddLineQueue
	jmp	$skip$554
$LN102@ForInitAnd:

; 1191 :             (0 == _memicmp(init, "WORD PTR", 8)))                     //reax=WORD PTR ax 
; 1192 : 
; 1193 :             WriteAsmLine(" movzx  ", param, init);                      //movzx reax,ax					    

	xor	ecx, ecx
$LL190@ForInitAnd:
	movzx	eax, BYTE PTR $SG11582[rbx+rcx]
	mov	BYTE PTR codebuff$9[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL190@ForInitAnd
	lea	rcx, QWORD PTR codebuff$9[rsp]
	dec	rcx
	npad	4
$LL434@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL434@ForInitAnd
	lea	r8, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL435@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL435@ForInitAnd
	lea	rcx, QWORD PTR codebuff$9[rsp]
	dec	rcx
	npad	8
$LL432@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL432@ForInitAnd
	xor	edx, edx
	lea	r12, OFFSET FLAT:$SG11418
	npad	13
$LL433@ForInitAnd:
	movzx	eax, BYTE PTR [r12+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL433@ForInitAnd
	mov	r12, QWORD PTR buff$[rbp-256]
	lea	rcx, QWORD PTR codebuff$9[rsp]
	dec	rcx
	npad	1
$LL430@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL430@ForInitAnd
	lea	r8, QWORD PTR init$[rbp-256]
	xor	edx, edx
	npad	13
$LL431@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL431@ForInitAnd
	lea	rcx, QWORD PTR codebuff$9[rsp]
	call	AddLineQueue

; 1197 :         }

	jmp	$skip$554
$LN97@ForInitAnd:

; 1198 :         else if ((strlen(op) == 1) && ((init[6] == ' ') || (init[6] == '\t'))) {

	cmp	rax, 1
	jne	$LN122@ForInitAnd
	movzx	edx, BYTE PTR init$[rbp-250]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN107@ForInitAnd
	cmp	dl, 9
	jne	$LN105@ForInitAnd
$LN107@ForInitAnd:

; 1199 :           if (0 == _memicmp(init, "OFFSET", 6))

	mov	r8d, 6
	lea	rdx, OFFSET FLAT:$SG11593
	lea	rcx, QWORD PTR init$[rbp-256]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN108@ForInitAnd

; 1200 :             WriteAsmLine(" lea  ", param, init + 7);

	lea	r8, QWORD PTR init$[rbp-249]
	lea	rdx, QWORD PTR param$[rbp-256]
	lea	rcx, OFFSET FLAT:$SG11594
	call	WriteAsmLine
	jmp	$skip$554
$LN108@ForInitAnd:

; 1201 :           else WriteAsmLine(" mov  ", param, init);

	xor	ecx, ecx
	npad	5
$LL196@ForInitAnd:
	movzx	eax, BYTE PTR $SG11595[rcx+rbx]
	mov	BYTE PTR codebuff$7[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL196@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7[rsp]
	dec	rcx
	npad	4
$LL428@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL428@ForInitAnd
	lea	r8, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL429@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL429@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7[rsp]
	dec	rcx
	npad	8
$LL426@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL426@ForInitAnd
	xor	edx, edx
	lea	r12, OFFSET FLAT:$SG11418
	npad	13
$LL427@ForInitAnd:
	movzx	eax, BYTE PTR [r12+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL427@ForInitAnd
	mov	r12, QWORD PTR buff$[rbp-256]
	lea	rcx, QWORD PTR codebuff$7[rsp]
	dec	rcx
	npad	1
$LL424@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL424@ForInitAnd
	lea	r8, QWORD PTR init$[rbp-256]
	xor	edx, edx
	npad	13
$LL425@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL425@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7[rsp]
	call	AddLineQueue

; 1202 :         }

	jmp	$skip$554
$LN105@ForInitAnd:

; 1203 :         else if ((strlen(op) == 1) && ((init[5] == ' ') || (init[5] == '\t'))) {            //op is '='

	cmp	rax, 1
	jne	$LN122@ForInitAnd
	movzx	edx, BYTE PTR init$[rbp-251]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN112@ForInitAnd
	cmp	dl, 9
	jne	$LN110@ForInitAnd
$LN112@ForInitAnd:

; 1204 :           if ((0 == _memicmp(init, "DWORD PTR", 9) || 0 == _memicmp(init, "DPTR", 4)

	mov	r8d, 9
	lea	rdx, OFFSET FLAT:$SG11602
	lea	rcx, QWORD PTR init$[rbp-256]
	call	_memicmp
	test	eax, eax
	je	$LN116@ForInitAnd
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11603
	lea	rcx, QWORD PTR init$[rbp-256]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN113@ForInitAnd
	movzx	eax, BYTE PTR param$[rbp-256]
	sub	al, 82					; 00000052H
	test	al, 223					; 000000dfH
	je	$LN116@ForInitAnd
$LN113@ForInitAnd:

; 1207 :           else WriteAsmLine(" mov  ", param, init);

	xor	ecx, ecx
	npad	2
$LL202@ForInitAnd:
	movzx	eax, BYTE PTR $SG11606[rcx+rbx]
	mov	BYTE PTR codebuff$5[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL202@ForInitAnd
	lea	rcx, QWORD PTR codebuff$5[rsp]
	dec	rcx
	npad	4
$LL422@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL422@ForInitAnd
	lea	r8, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL423@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL423@ForInitAnd
	lea	rcx, QWORD PTR codebuff$5[rsp]
	dec	rcx
	npad	8
$LL420@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL420@ForInitAnd
	xor	edx, edx
	lea	r13, OFFSET FLAT:$SG11418
	npad	13
$LL421@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+r13]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL421@ForInitAnd
	mov	r13, QWORD PTR tokenarray$[rbp-256]
	lea	rcx, QWORD PTR codebuff$5[rsp]
	dec	rcx
	npad	1
$LL418@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL418@ForInitAnd
	lea	r8, QWORD PTR init$[rbp-256]
	xor	edx, edx
	npad	13
$LL419@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL419@ForInitAnd
	lea	rcx, QWORD PTR codebuff$5[rsp]
	call	AddLineQueue
	jmp	$skip$554
$LN116@ForInitAnd:

; 1205 :             && (param[0] == 'r' || param[0] == 'R'))) 							   //rax=DWORD PTR eax
; 1206 :             WriteAsmLine(" movsxd  ", param, init);								     //movsxd rax,eax

	xor	ecx, ecx
$LL199@ForInitAnd:
	movzx	eax, BYTE PTR $SG11605[rcx+rbx]
	mov	BYTE PTR codebuff$6[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL199@ForInitAnd
	lea	rcx, QWORD PTR codebuff$6[rsp]
	dec	rcx
	npad	4
$LL416@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL416@ForInitAnd
	lea	r8, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL417@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL417@ForInitAnd
	lea	rcx, QWORD PTR codebuff$6[rsp]
	dec	rcx
	npad	8
$LL414@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL414@ForInitAnd
	xor	edx, edx
	lea	r12, OFFSET FLAT:$SG11418
	npad	13
$LL415@ForInitAnd:
	movzx	eax, BYTE PTR [r12+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL415@ForInitAnd
	mov	r12, QWORD PTR buff$[rbp-256]
	lea	rcx, QWORD PTR codebuff$6[rsp]
	dec	rcx
	npad	1
$LL412@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL412@ForInitAnd
	lea	r8, QWORD PTR init$[rbp-256]
	xor	edx, edx
	npad	13
$LL413@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL413@ForInitAnd
	lea	rcx, QWORD PTR codebuff$6[rsp]
	call	AddLineQueue

; 1208 :         }

	jmp	$skip$554
$LN110@ForInitAnd:

; 1209 :         else if ((strlen(op) == 1) && brct) {											    //op is '='

	cmp	rax, 1
	jne	$LN122@ForInitAnd
	test	r14b, r14b
	je	$LN117@ForInitAnd

; 1210 :           for (j = strlen(init); j; j--) {

	movsxd	r8, ecx
	test	ecx, ecx
	je	SHORT $LN14@ForInitAnd
	npad	8
$LL15@ForInitAnd:
	lea	rdx, QWORD PTR init$[rbp-256]
	add	rdx, r8

; 1211 :             if (init[j] == ')') init[j] = NULLC;

	cmp	BYTE PTR [rdx], 41			; 00000029H
	jne	SHORT $LN119@ForInitAnd
	mov	BYTE PTR [rdx], 0
$LN119@ForInitAnd:

; 1212 :             if (init[j] == '(') {

	cmp	BYTE PTR [rdx], 40			; 00000028H
	jne	SHORT $LN13@ForInitAnd

; 1213 :               for (p = init, p += j; *p; p++) {

	mov	rcx, rdx
	mov	al, 40					; 00000028H
	npad	4
$LL18@ForInitAnd:

; 1214 :                 if (*p == ',' && cnt) --cnt;

	cmp	al, 44					; 0000002cH
	jne	SHORT $LN16@ForInitAnd
	test	esi, esi
	je	SHORT $LN16@ForInitAnd
	dec	esi
$LN16@ForInitAnd:

; 1213 :               for (p = init, p += j; *p; p++) {

	movzx	eax, BYTE PTR [rcx+1]
	inc	rcx
	test	al, al
	jne	SHORT $LL18@ForInitAnd

; 1215 :               }
; 1216 :               init[j] = ',';

	mov	BYTE PTR [rdx], 44			; 0000002cH
$LN13@ForInitAnd:

; 1210 :           for (j = strlen(init); j; j--) {

	sub	r8, 1
	jne	SHORT $LL15@ForInitAnd
$LN14@ForInitAnd:

; 1217 :             }
; 1218 :           }
; 1219 :           strcpy(codebuff, " invoke  ");

	xor	ecx, ecx
$LL154@ForInitAnd:
	movzx	eax, BYTE PTR $SG11612[rcx+rbx]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL154@ForInitAnd

; 1220 :           strcat(codebuff, init);

	lea	rcx, QWORD PTR codebuff$[rbp-256]
	dec	rcx
	npad	5
$LL410@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL410@ForInitAnd
	lea	r8, QWORD PTR init$[rbp-256]
	xor	edx, edx
	npad	13
$LL411@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL411@ForInitAnd

; 1221 :           AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rbp-256]
	call	AddLineQueue

; 1222 :           WriteAsmLine(" mov  ", param, reax[ModuleInfo.Ofssize]);

	movzx	eax, BYTE PTR ModuleInfo+404
	xor	ecx, ecx
	mov	r8, QWORD PTR reax[rbx+rax*8]
	npad	6
$LL205@ForInitAnd:
	movzx	eax, BYTE PTR $SG11613[rcx+rbx]
	mov	BYTE PTR codebuff$4[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL205@ForInitAnd
	lea	rcx, QWORD PTR codebuff$4[rsp]
	dec	rcx
	npad	4
$LL408@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL408@ForInitAnd
	lea	r9, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL409@ForInitAnd:
	movzx	eax, BYTE PTR [r9+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL409@ForInitAnd
	lea	rcx, QWORD PTR codebuff$4[rsp]
	dec	rcx
	npad	8
$LL406@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL406@ForInitAnd
	xor	edx, edx
	lea	r12, OFFSET FLAT:$SG11418
	npad	13
$LL407@ForInitAnd:
	movzx	eax, BYTE PTR [r12+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL407@ForInitAnd
	mov	r12, QWORD PTR buff$[rbp-256]
	lea	rcx, QWORD PTR codebuff$4[rsp]
	dec	rcx
	npad	1
$LL404@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL404@ForInitAnd
	xor	edx, edx
	npad	4
$LL405@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL405@ForInitAnd
	lea	rcx, QWORD PTR codebuff$4[rsp]
	call	AddLineQueue

; 1223 :           brct = FALSE;

	xor	r14b, r14b

; 1224 :         }

	jmp	$skip$554
$LN117@ForInitAnd:

; 1225 :         else {
; 1226 :           if (strlen(op) == 1)

	cmp	rax, 1
	jne	$LN122@ForInitAnd

; 1227 :             WriteAsmLine(" mov  ", param, init);

	xor	ecx, ecx
	npad	3
$LL208@ForInitAnd:
	movzx	eax, BYTE PTR $SG11616[rcx+rbx]
	mov	BYTE PTR codebuff$3[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL208@ForInitAnd
	lea	rcx, QWORD PTR codebuff$3[rsp]
	dec	rcx
	npad	4
$LL402@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL402@ForInitAnd
	lea	r8, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL403@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL403@ForInitAnd
	lea	rcx, QWORD PTR codebuff$3[rsp]
	dec	rcx
	npad	8
$LL400@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL400@ForInitAnd
	xor	edx, edx
	lea	r12, OFFSET FLAT:$SG11418
	npad	13
$LL401@ForInitAnd:
	movzx	eax, BYTE PTR [r12+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL401@ForInitAnd
	mov	r12, QWORD PTR buff$[rbp-256]
	lea	rcx, QWORD PTR codebuff$3[rsp]
	dec	rcx
	npad	1
$LL398@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL398@ForInitAnd
	lea	r8, QWORD PTR init$[rbp-256]
	xor	edx, edx
	npad	13
$LL399@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL399@ForInitAnd
	lea	rcx, QWORD PTR codebuff$3[rsp]
	call	AddLineQueue
	jmp	$skip$554
$LN122@ForInitAnd:

; 1228 :           else
; 1229 :             WriteAsmLine(codebuff, param, init);

	xor	ecx, ecx
$LL211@ForInitAnd:
	movzx	eax, BYTE PTR codebuff$[rbp+rcx-256]
	mov	BYTE PTR codebuff$2[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL211@ForInitAnd
	lea	rcx, QWORD PTR codebuff$2[rsp]
	dec	rcx
	npad	7
$LL396@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL396@ForInitAnd
	lea	r8, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL397@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL397@ForInitAnd
	lea	rcx, QWORD PTR codebuff$2[rsp]
	dec	rcx
	npad	8
$LL394@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL394@ForInitAnd
	xor	edx, edx
	lea	r12, OFFSET FLAT:$SG11418
	npad	13
$LL395@ForInitAnd:
	movzx	eax, BYTE PTR [r12+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL395@ForInitAnd
	mov	r12, QWORD PTR buff$[rbp-256]
	lea	rcx, QWORD PTR codebuff$2[rsp]
	dec	rcx
	npad	1
$LL392@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL392@ForInitAnd
	lea	r8, QWORD PTR init$[rbp-256]
	xor	edx, edx
	npad	13
$LL393@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL393@ForInitAnd
	lea	rcx, QWORD PTR codebuff$2[rsp]
	call	AddLineQueue

; 1230 :         }
; 1231 :       }

	jmp	$skip$554
$LN23@ForInitAnd:

; 1026 :       param[a] = '\0';
; 1027 :       if ((buff[b] == '+') && (buff[b + 1] == '+')) strcpy(codebuff, " inc ");

	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR param$[rbp+rdi-256], 0
	cmp	al, 43					; 0000002bH
	jne	SHORT $LN24@ForInitAnd
	cmp	dl, al
	jne	SHORT $LN24@ForInitAnd
	xor	ecx, ecx
	lea	rbx, OFFSET FLAT:__ImageBase
	npad	6
$LL128@ForInitAnd:
	movzx	eax, BYTE PTR $SG11464[rcx+rbx]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL128@ForInitAnd
	jmp	SHORT $LN26@ForInitAnd
$LN24@ForInitAnd:

; 1028 :       else if ((buff[b] == '-') && (buff[b + 1] == '-')) strcpy(codebuff, " dec ");

	cmp	al, 45					; 0000002dH
	jne	SHORT $LN26@ForInitAnd
	cmp	dl, al
	jne	SHORT $LN26@ForInitAnd
	xor	ecx, ecx
	lea	rbx, OFFSET FLAT:__ImageBase
	npad	9
$LL129@ForInitAnd:
	movzx	eax, BYTE PTR $SG11466[rcx+rbx]
	mov	BYTE PTR codebuff$[rbp+rcx-256], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL129@ForInitAnd
$LN26@ForInitAnd:

; 1029 :       strcat(codebuff, param);

	lea	rcx, QWORD PTR codebuff$[rbp-256]
	dec	rcx
	npad	5
$LL390@ForInitAnd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL390@ForInitAnd
	lea	r8, QWORD PTR param$[rbp-256]
	xor	edx, edx
	npad	13
$LL391@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	inc	rdx
	test	al, al
	jne	SHORT $LL391@ForInitAnd

; 1030 :       AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rbp-256]
	call	AddLineQueue

; 1031 :       b += 3;

	add	r15d, 3
$skip$554:

; 1239 :         }
; 1240 :       }
; 1241 :     }
; 1242 :   skip:
; 1243 :     if (cnt) cnt--;

	test	esi, esi
	je	SHORT $LN530@ForInitAnd

; 1244 :   } while (cnt);

	mov	r9, 145272973819904			; 0000842000000000H
	sub	esi, 1
	jne	$LL4@ForInitAnd
$LN530@ForInitAnd:

; 1245 :   return(NOT_ERROR);

	xor	eax, eax

; 1246 : }

	mov	rbx, QWORD PTR [rsp+1144]
	add	rsp, 1056				; 00000420H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ForInitAndNext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT WriteAsmLine
_TEXT	SEGMENT
codebuff$ = 32
cmd$ = 304
s1$ = 312
s2$ = 320
WriteAsmLine PROC					; COMDAT

; 992  : static void WriteAsmLine(const char *cmd, const char *s1, const char *s2) {

	sub	rsp, 296				; 00000128H

; 993  :   char codebuff[256];
; 994  :   strcpy(codebuff, cmd);

	lea	r9, QWORD PTR codebuff$[rsp]
	mov	r10, rdx
	sub	r9, rcx
	npad	14
$LL3@WriteAsmLi:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [r9+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL3@WriteAsmLi

; 995  :   strcat(codebuff, s1);

	lea	rcx, QWORD PTR codebuff$[rsp]
	dec	rcx
	npad	9
$LL11@WriteAsmLi:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL11@WriteAsmLi
	xor	edx, edx
	npad	4
$LL12@WriteAsmLi:
	movzx	eax, BYTE PTR [r10+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL12@WriteAsmLi

; 996  :   strcat(codebuff, ", ");

	lea	rcx, QWORD PTR codebuff$[rsp]
	dec	rcx
	npad	8
$LL9@WriteAsmLi:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL9@WriteAsmLi
	lea	r9, OFFSET FLAT:$SG11418
	xor	edx, edx
	npad	13
$LL10@WriteAsmLi:
	movzx	eax, BYTE PTR [r9+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL10@WriteAsmLi

; 997  :   strcat(codebuff, s2);

	lea	rcx, QWORD PTR codebuff$[rsp]
	dec	rcx
	npad	8
$LL7@WriteAsmLi:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL7@WriteAsmLi
	xor	edx, edx
	npad	4
$LL8@WriteAsmLi:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL8@WriteAsmLi

; 998  :   AddLineQueue(codebuff);				// MOV RAX,param

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 999  :   return;
; 1000 : }

	add	rsp, 296				; 00000128H
	ret	0
WriteAsmLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT CheckCXZLines
_TEXT	SEGMENT
p$ = 48
CheckCXZLines PROC					; COMDAT

; 935  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 936  :   int lines = 0;
; 937  :   int i;
; 938  :   int addchars;
; 939  :   char *px;
; 940  :   bool NL = TRUE;
; 941  : 
; 942  :   DebugMsg1(("CheckCXZLines enter, p=>%s<\n", p));
; 943  :   /* syntax ".untilcxz 1" has a problem: there's no "jmp" generated at all.
; 944  :   * if this syntax is to be supported, activate the #if below.
; 945  :   */
; 946  :   for (; *p; p++) {

	movzx	eax, BYTE PTR [rcx]
	xor	edi, edi
	mov	rbx, rcx
	mov	sil, 1
	test	al, al
	je	$LN17@CheckCXZLi
$LL4@CheckCXZLi:

; 947  :     if (*p == EOLCHAR) {

	cmp	al, 10
	jne	SHORT $LN8@CheckCXZLi

; 948  :       NL = TRUE;

	mov	sil, 1

; 949  :       lines++;

	inc	edi

; 950  :     }

	jmp	$LN2@CheckCXZLi
$LN8@CheckCXZLi:

; 951  :     else if (NL) {

	test	sil, sil
	je	$LN2@CheckCXZLi

; 952  :       NL = FALSE;

	xor	sil, sil

; 953  :       if (*p == 'j') {

	cmp	al, 106					; 0000006aH
	jne	$LN2@CheckCXZLi

; 954  :         p++;
; 955  :         /* v2.06: rewritten */
; 956  :         if (*p == 'm' && lines == 0) {

	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, 109					; 0000006dH
	jne	SHORT $LN12@CheckCXZLi
	test	edi, edi
	jne	SHORT $LN12@CheckCXZLi

; 957  :           addchars = 2; /* make room for 2 chars, to replace "jmp" by "loope" */

	lea	r8d, QWORD PTR [rdi+2]

; 958  :           px = "loope";

	lea	r9, OFFSET FLAT:$SG11391

; 959  :         }

	jmp	SHORT $LN15@CheckCXZLi
$LN12@CheckCXZLi:

; 960  :         else if (lines == 1 && (*p == 'z' || (*p == 'n' && *(p + 1) == 'z'))) {

	cmp	edi, 1
	jne	$LN14@CheckCXZLi
	cmp	al, 122					; 0000007aH
	je	SHORT $LN16@CheckCXZLi
	cmp	al, 110					; 0000006eH
	jne	$LN14@CheckCXZLi
	cmp	BYTE PTR [rbx+2], 122			; 0000007aH
	jne	$LN14@CheckCXZLi
$LN16@CheckCXZLi:

; 961  :           addchars = 3; /* make room for 3 chars, to replace "jz"/"jnz" by "loopz"/"loopnz" */

	mov	r8d, 3

; 962  :           px = "loop";

	lea	r9, OFFSET FLAT:$SG11395
$LN15@CheckCXZLi:

; 963  :         }
; 964  :         else
; 965  :           return(ERROR); /* anything else is "too complex" */
; 966  :                          //replace_instr:
; 967  :         for (p--, i = strlen(p); i >= 0; i--) {

	or	rax, -1
	npad	3
$LL29@CheckCXZLi:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL29@CheckCXZLi
	movsxd	rdx, eax
	test	eax, eax
	js	SHORT $LN6@CheckCXZLi
	lea	rax, QWORD PTR [rdx+r8]
	neg	r8
	add	rax, rbx
	inc	rdx
	npad	3
$LL7@CheckCXZLi:

; 968  :           *(p + addchars + i) = *(p + i);

	movzx	ecx, BYTE PTR [r8+rax]
	mov	BYTE PTR [rax], cl
	dec	rax
	sub	rdx, 1
	jne	SHORT $LL7@CheckCXZLi
$LN6@CheckCXZLi:

; 969  :         }
; 970  :         memcpy(p, px, strlen(px));

	or	r8, -1
$LL28@CheckCXZLi:
	inc	r8
	cmp	BYTE PTR [r9+r8], 0
	jne	SHORT $LL28@CheckCXZLi
	mov	rdx, r9
	mov	rcx, rbx
	call	memcpy
$LN2@CheckCXZLi:

; 936  :   int lines = 0;
; 937  :   int i;
; 938  :   int addchars;
; 939  :   char *px;
; 940  :   bool NL = TRUE;
; 941  : 
; 942  :   DebugMsg1(("CheckCXZLines enter, p=>%s<\n", p));
; 943  :   /* syntax ".untilcxz 1" has a problem: there's no "jmp" generated at all.
; 944  :   * if this syntax is to be supported, activate the #if below.
; 945  :   */
; 946  :   for (; *p; p++) {

	movzx	eax, BYTE PTR [rbx+1]
	inc	rbx
	test	al, al
	jne	$LL4@CheckCXZLi

; 971  :       }
; 972  : #if 0 /* handle ".untilcxz 1" like masm does */
; 973  :       else if (*p == ' ' && *(p + 1) == EOLCHAR && lines == 0) {
; 974  :         p++;
; 975  :         GetLabelStr(hll->labels[LSTART], p);
; 976  :         strcat(p, EOLSTR);
; 977  :         addchars = 5;
; 978  :         px = "loope";
; 979  :         goto replace_instr;
; 980  :       }
; 981  : #endif
; 982  :     }
; 983  :   }
; 984  :   if (lines > 2)

	cmp	edi, 2
	jg	SHORT $LN14@CheckCXZLi
$LN17@CheckCXZLi:

; 985  :     return(ERROR);
; 986  :   return(NOT_ERROR);

	xor	eax, eax

; 987  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN14@CheckCXZLi:
	mov	rbx, QWORD PTR [rsp+48]
	or	eax, -1
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CheckCXZLines ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT EvaluateHllExpression
_TEXT	SEGMENT
hllop$ = 64
hll$ = 96
i$ = 104
tokenarray$ = 112
ilabel$ = 120
is_true$ = 128
buffer$ = 136
EvaluateHllExpression PROC				; COMDAT

; 910  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 80					; 00000050H

; 911  :   struct hll_opnd hllop = { NULL, 0 };

	xor	eax, eax
	mov	rdi, rdx
	mov	QWORD PTR hllop$[rsp], rax

; 912  : 
; 913  :   DebugMsg1(("EvaluateHllExpression enter\n"));
; 914  : 
; 915  :   *buffer = NULLC;
; 916  :   if (ERROR == GetExpression(hll, i, tokenarray, ilabel, is_true, buffer, &hllop))

	lea	rdx, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rsp+48], rdx
	mov	rbx, r8
	mov	DWORD PTR hllop$[rsp+8], eax
	mov	rdx, rdi
	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rax], 0
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	BYTE PTR [rsp+32], al
	call	GetExpression
	cmp	eax, -1
	jne	SHORT $LN2@EvaluateHl

; 917  :     return(ERROR);

	or	eax, eax

; 926  : }

	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN2@EvaluateHl:

; 918  :   /* v2.11: changed */
; 919  :   //if ( *buffer == EOLCHAR ) {
; 920  :   //DebugMsg(( "EvaluateHllExpression: EOL at pos 0 in line buffer\n" ));
; 921  :   if (tokenarray[*i].token != T_FINAL) {

	movsxd	rax, DWORD PTR [rdi]
	shl	rax, 5
	cmp	BYTE PTR [rax+rbx], 0
	je	SHORT $LN3@EvaluateHl

; 922  :     DebugMsg(("EvaluateHllExpression: unexpected tokens >%s<\n", tokenarray[*i].tokpos));
; 923  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, 199				; 000000c7H
	call	EmitError

; 926  : }

	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN3@EvaluateHl:

; 924  :   }
; 925  :   return(NOT_ERROR);

	xor	eax, eax

; 926  : }

	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
EvaluateHllExpression ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT QueueTestLines
_TEXT	SEGMENT
src$ = 48
QueueTestLines PROC					; COMDAT

; 873  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 874  :   char *start;
; 875  : 
; 876  :   DebugMsg1(("QueueTestLines(\"%s\") enter\n", src ? src : "NULL"));
; 877  :   while (src) {

	test	rcx, rcx
	je	SHORT $LN10@QueueTestL
	mov	QWORD PTR [rsp+48], rdi
	npad	13
$LL2@QueueTestL:

; 878  :     //if (*src == ' ') src++; /* v2.11: obsolete */
; 879  :     start = src;
; 880  :     if (src = strchr(src, EOLCHAR))

	mov	edx, 10
	mov	rcx, rbx
	mov	rdi, rbx
	call	strchr
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN4@QueueTestL

; 881  :       *src++ = NULLC;

	mov	BYTE PTR [rax], 0
	inc	rbx
$LN4@QueueTestL:

; 882  :     if (*start)

	cmp	BYTE PTR [rdi], 0
	je	SHORT $LN5@QueueTestL

; 883  :       AddLineQueue(start);

	mov	rcx, rdi
	call	AddLineQueue
$LN5@QueueTestL:

; 874  :   char *start;
; 875  : 
; 876  :   DebugMsg1(("QueueTestLines(\"%s\") enter\n", src ? src : "NULL"));
; 877  :   while (src) {

	test	rbx, rbx
	jne	SHORT $LL2@QueueTestL
	mov	rdi, QWORD PTR [rsp+48]
$LN10@QueueTestL:

; 884  :   }
; 885  : 
; 886  :   DebugMsg1(("QueueTestLines exit\n"));
; 887  :   return(NOT_ERROR);

	xor	eax, eax

; 888  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
QueueTestLines ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT GetAndExpression
_TEXT	SEGMENT
hll$ = 128
i$ = 136
tokenarray$ = 144
ilabel$ = 152
is_true$ = 160
buffer$ = 168
hllop$ = 176
GetAndExpression PROC					; COMDAT

; 721  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H

; 722  :   char *ptr = buffer;
; 723  :   uint_32 truelabel = 0;
; 724  :   //char buff[16];
; 725  :   //char *nlabel;
; 726  :   //char *olabel;
; 727  : 
; 728  :   DebugMsg1(("%u GetAndExpression(>%.32s< buf=>%s<) enter\n", evallvl, tokenarray[*i].tokpos, buffer));
; 729  : 
; 730  :   if (ERROR == GetSimpleExpression(hll, i, tokenarray, ilabel, is_true, ptr, hllop))

	mov	r15, QWORD PTR hllop$[rsp]
	mov	rax, rcx
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	ebx, r9d
	movzx	r12d, BYTE PTR is_true$[rsp]
	mov	rdi, rcx
	mov	QWORD PTR [rsp+48], r15
	mov	r13, r8
	mov	QWORD PTR [rsp+40], rcx
	mov	r14, rdx
	mov	rcx, rax
	mov	BYTE PTR [rsp+32], r12b
	xor	ebp, ebp
	call	GetSimpleExpression
	cmp	eax, -1
	jne	SHORT $LN20@GetAndExpr

; 731  :     return(ERROR);

	or	rax, -1
	jmp	$LN1@GetAndExpr
$LN20@GetAndExpr:

; 732  :   while (COP_AND == GetCOp(&tokenarray[*i])) {

	movsxd	rcx, DWORD PTR [r14]
	shl	rcx, 5
	add	rcx, r13
	call	GetCOp
	cmp	eax, 7
	jne	$LN10@GetAndExpr
	or	rsi, -1
	npad	7
$LL2@GetAndExpr:

; 733  : 
; 734  :     (*i)++;

	inc	DWORD PTR [r14]

; 735  :     DebugMsg1(("%u GetAndExpression: &&-operator found, is_true=%u, lastjmp=%s\n", evallvl, is_true, hllop->lastjmp ? hllop->lastjmp : "NULL"));
; 736  : 
; 737  :     if (is_true) {

	test	r12b, r12b
	je	$LN6@GetAndExpr

; 738  :       /* todo: please describe what's done here and why! */
; 739  :       if (hllop->lastjmp) {

	mov	rbx, QWORD PTR [r15]
	test	rbx, rbx
	je	$LN31@GetAndExpr

; 740  :         char *p = hllop->lastjmp;
; 741  :         InvertJump(p);          /* step 1 */

	mov	rcx, rbx
	call	InvertJump

; 742  :         if (truelabel == 0)     /* step 2 */

	test	ebp, ebp
	jne	SHORT $LN7@GetAndExpr

; 743  :           truelabel = GetHllLabel();

	mov	ebp, DWORD PTR ModuleInfo+352
	inc	ebp
	mov	DWORD PTR ModuleInfo+352, ebp
$LN7@GetAndExpr:

; 744  : 
; 745  :         if (*p && strlen(p) < 11) {/* v2.11: there might be a 0 at lastjmp */

	cmp	BYTE PTR [rbx], 0
	je	SHORT $LN8@GetAndExpr
	mov	rax, rsi
	npad	6
$LL30@GetAndExpr:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL30@GetAndExpr
	cmp	rax, 11
	jae	SHORT $LN8@GetAndExpr

; 746  :           p += 4;               /* skip 'jcc ' or 'jmp ' */
; 747  :           GetLabelStr(truelabel, p);

	mov	r8d, ebp
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR [rbx+4]
	call	sprintf

; 748  :           strcat(p, EOLSTR);

	sub	rbx, -3
$LL28@GetAndExpr:
	cmp	BYTE PTR [rbx+1], 0
	lea	rbx, QWORD PTR [rbx+1]
	jne	SHORT $LL28@GetAndExpr
	xor	ecx, ecx
	lea	r12, OFFSET FLAT:$SG11300
	npad	7
$LL29@GetAndExpr:
	movzx	eax, BYTE PTR [r12+rcx]
	mov	BYTE PTR [rbx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL29@GetAndExpr
	movzx	r12d, BYTE PTR is_true$[rsp]
$LN8@GetAndExpr:

; 749  :         }
; 750  : 
; 751  :         DebugMsg1(("%u GetAndExpression: jmp inverted >%s<\n", evallvl, hllop->lastjmp));
; 752  :         ReplaceLabel(buffer, GetLabel(hll, ilabel), truelabel);

	mov	rcx, QWORD PTR hll$[rsp]
	mov	r8d, ebp
	movsxd	rbx, DWORD PTR ilabel$[rsp]
	mov	edx, DWORD PTR [rcx+rbx*4+36]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	ReplaceLabel

; 753  :         hllop->lastjmp = NULL;

	mov	QWORD PTR [r15], 0
	jmp	SHORT $LN6@GetAndExpr
$LN31@GetAndExpr:
	mov	ebx, DWORD PTR ilabel$[rsp]
$LN6@GetAndExpr:

; 754  :       }
; 755  :     }
; 756  :     ptr += strlen(ptr);

	mov	rax, rsi
$LL27@GetAndExpr:
	inc	rax
	cmp	BYTE PTR [rdi+rax], 0
	jne	SHORT $LL27@GetAndExpr

; 757  :     hllop->lasttruelabel = 0; /* v2.08 */
; 758  :     if (ERROR == GetSimpleExpression(hll, i, tokenarray, ilabel, is_true, ptr, hllop))

	mov	rcx, QWORD PTR hll$[rsp]
	add	rdi, rax
	mov	QWORD PTR [rsp+48], r15
	mov	r9d, ebx
	mov	QWORD PTR [rsp+40], rdi
	mov	r8, r13
	mov	rdx, r14
	mov	BYTE PTR [rsp+32], r12b
	mov	DWORD PTR [r15+8], 0
	call	GetSimpleExpression
	cmp	eax, -1
	je	$LN21@GetAndExpr

; 732  :   while (COP_AND == GetCOp(&tokenarray[*i])) {

	movsxd	rcx, DWORD PTR [r14]
	shl	rcx, 5
	add	rcx, r13
	call	GetCOp
	cmp	eax, 7
	je	$LL2@GetAndExpr

; 760  :   };
; 761  : 
; 762  :   if (truelabel > 0) {

	test	ebp, ebp
	je	SHORT $LN10@GetAndExpr
	npad	2
$LL26@GetAndExpr:

; 763  :     ptr += strlen(ptr);

	inc	rsi
	cmp	BYTE PTR [rdi+rsi], 0
	jne	SHORT $LL26@GetAndExpr
	add	rdi, rsi

; 764  :     GetLabelStr(truelabel, ptr);

	lea	rdx, OFFSET FLAT:$SG11118
	mov	rcx, rdi
	mov	r8d, ebp
	call	sprintf

; 765  :     strcat(ptr, LABELQUAL EOLSTR);

	dec	rdi
$LL24@GetAndExpr:
	cmp	BYTE PTR [rdi+1], 0
	lea	rdi, QWORD PTR [rdi+1]
	jne	SHORT $LL24@GetAndExpr
	lea	rdx, OFFSET FLAT:$SG11303
	xor	ecx, ecx
	npad	12
$LL25@GetAndExpr:
	movzx	eax, BYTE PTR [rdx+rcx]
	mov	BYTE PTR [rdi+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL25@GetAndExpr

; 766  :     DebugMsg1(("%u GetAndExpression: label added >%s<\n", evallvl, ptr));
; 767  :     hllop->lastjmp = NULL;

	mov	QWORD PTR [r15], 0
$LN10@GetAndExpr:

; 768  :   }
; 769  :   return(NOT_ERROR);

	xor	eax, eax
$LN1@GetAndExpr:

; 770  : }

	mov	rbx, QWORD PTR [rsp+136]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN21@GetAndExpr:

; 759  :       return(ERROR);

	mov	eax, esi
	jmp	SHORT $LN1@GetAndExpr
GetAndExpression ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT ReplaceLabel
_TEXT	SEGMENT
newlbl$ = 32
oldlbl$ = 48
p$ = 80
olabel$ = 88
nlabel$ = 96
ReplaceLabel PROC					; COMDAT

; 700  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	ebx, r8d
	mov	rdi, rcx

; 701  :   char oldlbl[16];
; 702  :   char newlbl[16];
; 703  :   int i;
; 704  : 
; 705  :   GetLabelStr(olabel, oldlbl);

	mov	r8d, edx
	lea	rcx, QWORD PTR oldlbl$[rsp]
	lea	rdx, OFFSET FLAT:$SG11118
	call	sprintf

; 706  :   GetLabelStr(nlabel, newlbl);

	mov	r8d, ebx
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR newlbl$[rsp]
	call	sprintf

; 707  : 
; 708  :   i = strlen(newlbl);

	lea	rax, QWORD PTR newlbl$[rsp]
	or	rbx, -1
$LL13@ReplaceLab:
	inc	rbx
	cmp	BYTE PTR [rax+rbx], 0
	jne	SHORT $LL13@ReplaceLab

; 709  : 
; 710  :   DebugMsg1(("%u ReplaceLabel(%s->%s, >%s<)\n", evallvl, oldlbl, newlbl, p));
; 711  :   while (p = strstr(p, oldlbl)) {

	lea	rdx, QWORD PTR oldlbl$[rsp]
	mov	rcx, rdi
	call	strstr
	mov	rdi, rax
	test	rax, rax
	je	SHORT $LN3@ReplaceLab
	movsxd	rbx, ebx
	npad	14
$LL2@ReplaceLab:

; 712  :     memcpy(p, newlbl, i);

	mov	r8, rbx
	lea	rdx, QWORD PTR newlbl$[rsp]
	mov	rcx, rdi
	call	memcpy

; 713  :     p += i;

	lea	rcx, QWORD PTR [rbx+rdi]
	lea	rdx, QWORD PTR oldlbl$[rsp]
	call	strstr
	mov	rdi, rax
	test	rax, rax
	jne	SHORT $LL2@ReplaceLab
$LN3@ReplaceLab:

; 714  :   }
; 715  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ReplaceLabel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT InvertJump
_TEXT	SEGMENT
p$ = 8
InvertJump PROC						; COMDAT

; 649  :   if (*p == NULLC) { /* v2.11: convert 0 to "jmp" */

	cmp	BYTE PTR [rcx], 0
	jne	SHORT $LN2@InvertJump

; 650  :     strcpy(p, "jmp ");

	lea	rdx, OFFSET FLAT:$SG11242
	sub	rcx, rdx
	npad	1
$LL20@InvertJump:
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL20@InvertJump

; 686  :     *p = ' ';
; 687  :   else
; 688  :     *p = 'e';
; 689  :   return;
; 690  : }

	ret	0
$LN2@InvertJump:

; 651  :     return;
; 652  :   }
; 653  : 
; 654  :   p++;
; 655  :   if (*p == 'e' || *p == 'z' || *p == 'c' || *p == 's' || *p == 'p' || *p == 'o') {

	movzx	edx, BYTE PTR [rcx+1]
	lea	eax, DWORD PTR [rdx-99]
	cmp	al, 23
	ja	SHORT $LN24@InvertJump
	mov	r8d, 8466437				; 00813005H
	bt	r8d, eax
	jae	SHORT $LN24@InvertJump

; 656  :     *(p + 1) = *p;

	mov	BYTE PTR [rcx+2], dl

; 657  :     *p = 'n';

	mov	BYTE PTR [rcx+1], 110			; 0000006eH

; 686  :     *p = ' ';
; 687  :   else
; 688  :     *p = 'e';
; 689  :   return;
; 690  : }

	ret	0
$LN24@InvertJump:

; 658  :     return;
; 659  :   }
; 660  :   else if (*p == 'n') {

	cmp	dl, 110					; 0000006eH
	jne	SHORT $LN6@InvertJump

; 661  :     *p = *(p + 1);

	movzx	eax, BYTE PTR [rcx+2]
	mov	BYTE PTR [rcx+1], al

; 662  :     *(p + 1) = ' ';

	mov	BYTE PTR [rcx+2], 32			; 00000020H

; 686  :     *p = ' ';
; 687  :   else
; 688  :     *p = 'e';
; 689  :   return;
; 690  : }

	ret	0
$LN6@InvertJump:

; 663  :     return;
; 664  :   }
; 665  :   else if (*p == 'a') {

	cmp	dl, 97					; 00000061H
	jne	SHORT $LN8@InvertJump

; 666  :     *p++ = 'b';

	mov	BYTE PTR [rcx+1], 98			; 00000062H

; 667  :   }

	jmp	SHORT $LN26@InvertJump
$LN8@InvertJump:

; 668  :   else if (*p == 'b') {

	cmp	dl, 98					; 00000062H
	jne	SHORT $LN10@InvertJump

; 669  :     *p++ = 'a';

	mov	BYTE PTR [rcx+1], 97			; 00000061H

; 670  :   }

	jmp	SHORT $LN26@InvertJump
$LN10@InvertJump:

; 671  :   else if (*p == 'g') {

	cmp	dl, 103					; 00000067H
	jne	SHORT $LN12@InvertJump

; 672  :     *p++ = 'l';

	mov	BYTE PTR [rcx+1], 108			; 0000006cH

; 673  :   }

	jmp	SHORT $LN26@InvertJump
$LN12@InvertJump:

; 674  :   else if (*p == 'l') {

	cmp	dl, 108					; 0000006cH
	jne	SHORT $LN14@InvertJump

; 675  :     *p++ = 'g';

	mov	BYTE PTR [rcx+1], 103			; 00000067H
$LN26@InvertJump:
	add	rcx, 2

; 682  :     }
; 683  :     return;
; 684  :   }
; 685  :   if (*p == 'e')

	mov	eax, 101				; 00000065H
	mov	edx, 32					; 00000020H
	cmp	BYTE PTR [rcx], al
	cmove	eax, edx
	mov	BYTE PTR [rcx], al

; 686  :     *p = ' ';
; 687  :   else
; 688  :     *p = 'e';
; 689  :   return;
; 690  : }

	ret	0
$LN14@InvertJump:

; 676  :   }
; 677  :   else {
; 678  :     /* v2.11: convert "jmp" to 0 */
; 679  :     if (*p == 'm') {

	cmp	dl, 109					; 0000006dH
	jne	SHORT $LN18@InvertJump

; 680  :       p--;
; 681  :       *p = NULLC;

	mov	BYTE PTR [rcx], 0
$LN18@InvertJump:

; 686  :     *p = ' ';
; 687  :   else
; 688  :     *p = 'e';
; 689  :   return;
; 690  : }

	ret	0
InvertJump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT GetSimpleExpression
_TEXT	SEGMENT
op1$ = 64
op2$ = 176
hll$ = 352
op2_pos$1$ = 360
i$ = 360
tokenarray$ = 368
ilabel$ = 376
is_true$ = 384
buffer$ = 392
hllop$ = 400
GetSimpleExpression PROC				; COMDAT

; 447  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r15
	sub	rsp, 288				; 00000120H

; 448  :   enum c_bop op;
; 449  :   char instr;
; 450  :   int op1_pos;
; 451  :   int op1_end;
; 452  :   int op2_pos;
; 453  :   int op2_end;
; 454  :   char *p;
; 455  :   struct expr op1;
; 456  :   struct expr op2;
; 457  :   uint_32 label;
; 458  : 
; 459  :   DebugMsg1(("%u GetSimpleExpression(>%.32s< buf=>%s<) enter\n", evallvl, tokenarray[*i].tokpos, buffer));
; 460  : 
; 461  :   while (tokenarray[*i].string_ptr[0] == '!' && tokenarray[*i].string_ptr[1] == '\0') {

	movsxd	rax, DWORD PTR [rdx]
	mov	r12d, r9d
	movzx	ebp, BYTE PTR is_true$[rsp]
	mov	rsi, r8
	shl	rax, 5
	mov	rdi, rdx
	mov	r13, rcx
	mov	ebx, 1
	mov	r10, QWORD PTR [rax+r8+8]
	cmp	BYTE PTR [r10], 33			; 00000021H
	jne	SHORT $LN3@GetSimpleE
	npad	10
$LL2@GetSimpleE:
	movsxd	rcx, DWORD PTR [rdx]
	mov	rax, rcx
	shl	rax, 5
	mov	rax, QWORD PTR [rax+r8+8]
	cmp	BYTE PTR [rax+1], 0
	jne	SHORT $LN3@GetSimpleE

; 462  :     (*i)++; //GetCOp( i );

	inc	ecx

; 463  :     is_true = 1 - is_true;

	mov	eax, ebx
	sub	al, bpl
	mov	DWORD PTR [rdx], ecx
	movzx	ebp, al
	movsxd	rax, ecx
	shl	rax, 5
	mov	rax, QWORD PTR [rax+r8+8]
	cmp	BYTE PTR [rax], 33			; 00000021H
	je	SHORT $LL2@GetSimpleE
$LN3@GetSimpleE:

; 464  :   }
; 465  : 
; 466  :   /* the problem with '()' is that is might enclose just a standard Masm
; 467  :   * expression or a "hll" expression. The first case is to be handled
; 468  :   * entirely by the expression evaluator, while the latter case is to be
; 469  :   * handled HERE!
; 470  :   */
; 471  :   if (tokenarray[*i].token == T_OP_BRACKET) {

	movsxd	r15, DWORD PTR [rdx]
	mov	rax, r15
	mov	QWORD PTR [rsp+368], r14
	shl	rax, 5
	cmp	BYTE PTR [rax+r8], 40			; 00000028H
	jne	SHORT $LN18@GetSimpleE

; 472  :     int brcnt;
; 473  :     int j;
; 474  :     for (brcnt = 1, j = *i + 1; tokenarray[j].token != T_FINAL; j++) {

	inc	r15d
	movsxd	r14, r15d
	mov	rax, r14
	shl	rax, 5
	cmp	BYTE PTR [rax+r8], 0
	lea	rcx, QWORD PTR [rax+r8]
	je	$LN108@GetSimpleE
$LL6@GetSimpleE:
	movzx	eax, BYTE PTR [rcx]

; 475  :       if (tokenarray[j].token == T_OP_BRACKET)

	cmp	al, 40					; 00000028H
	jne	SHORT $LN12@GetSimpleE

; 476  :         brcnt++;

	inc	ebx
	jmp	SHORT $LN4@GetSimpleE
$LN12@GetSimpleE:

; 477  :       else if (tokenarray[j].token == T_CL_BRACKET) {

	cmp	al, 41					; 00000029H
	jne	SHORT $LN14@GetSimpleE

; 478  :         brcnt--;

	sub	ebx, 1

; 479  :         if (brcnt == 0) /* a standard Masm expression? */

	jne	SHORT $LN4@GetSimpleE
$LN18@GetSimpleE:

; 498  :     }
; 499  :   }
; 500  : 
; 501  :   /* get (first) operand */
; 502  :   op1_pos = *i;

	movsxd	r12, DWORD PTR [rdi]

; 503  :   if (ERROR == GetToken(hll, i, tokenarray, &op1))

	lea	r9, QWORD PTR op1$[rsp]
	mov	r8, rsi
	mov	rdx, rdi
	mov	rcx, r13
	call	GetToken
	cmp	eax, -1
	je	$LN119@GetSimpleE

; 504  :     return (ERROR);
; 505  :   op1_end = *i;

	movsxd	r15, DWORD PTR [rdi]

; 506  : 
; 507  :   op = GetCOp(&tokenarray[*i]); /* get operator */

	mov	rcx, r15
	shl	rcx, 5
	add	rcx, rsi
	call	GetCOp
	xor	r14d, r14d
	mov	ebx, eax
	lea	ecx, DWORD PTR [rax-7]
	cmp	ecx, 1
	jbe	$LN24@GetSimpleE

; 515  :   }
; 516  :   else if (op != COP_NONE)

	test	eax, eax
	je	$LN25@GetSimpleE

; 517  :     (*i)++;

	inc	DWORD PTR [rdi]
	jmp	$LN25@GetSimpleE
$LN14@GetSimpleE:

; 480  :           break;
; 481  :       }
; 482  :       else if ((GetCOp(&tokenarray[j])) != COP_NONE)

	movsxd	rcx, r15d
	shl	rcx, 5
	add	rcx, rsi
	call	GetCOp
	test	eax, eax
	jne	SHORT $LN100@GetSimpleE
$LN4@GetSimpleE:

; 472  :     int brcnt;
; 473  :     int j;
; 474  :     for (brcnt = 1, j = *i + 1; tokenarray[j].token != T_FINAL; j++) {

	inc	r14
	inc	r15d
	mov	rax, r14
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 0
	lea	rcx, QWORD PTR [rax+rsi]
	jne	$LL6@GetSimpleE
$LN100@GetSimpleE:

; 483  :         break;
; 484  :     }
; 485  :     if (brcnt) {

	test	ebx, ebx
	je	$LN18@GetSimpleE
$LN108@GetSimpleE:

; 486  :       (*i)++;
; 487  :       DebugMsg1(("%u GetSimpleExpression: calling GetExpression, i=%u\n", evallvl, *i));
; 488  :       if (ERROR == GetExpression(hll, i, tokenarray, ilabel, is_true, buffer, hllop))

	mov	rax, QWORD PTR hllop$[rsp]
	mov	r9d, r12d
	inc	DWORD PTR [rdi]
	mov	r8, rsi
	mov	QWORD PTR [rsp+48], rax
	mov	rdx, rdi
	mov	rax, QWORD PTR buffer$[rsp]
	mov	rcx, r13
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], bpl
	call	GetExpression
	cmp	eax, -1
	jne	SHORT $LN19@GetSimpleE
$LN119@GetSimpleE:

; 489  :         return(ERROR);

	or	rax, -1
	jmp	$LN1@GetSimpleE
$LN19@GetSimpleE:

; 490  : 
; 491  :       if (tokenarray[*i].token != T_CL_BRACKET) {

	movsxd	rcx, DWORD PTR [rdi]
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 41			; 00000029H
	jne	$LN28@GetSimpleE

; 492  :         //if (( tokenarray[*i].token == T_FINAL ) || ( tokenarray[*i].token == T_CL_BRACKET ))
; 493  :         DebugMsg(("GetSimpleExpression: expected ')', found: %s\n", tokenarray[*i].string_ptr));
; 494  :         return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));
; 495  :       }
; 496  :       (*i)++;

	lea	eax, DWORD PTR [rcx+1]
	mov	DWORD PTR [rdi], eax

; 497  :       return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@GetSimpleE
$LN24@GetSimpleE:

; 508  : 
; 509  :                                 /* lower precedence operator ( && or || ) detected? */
; 510  :   if (op == COP_AND || op == COP_OR) {
; 511  :     /* v2.11: next 2 lines removed - && and || operators need a valid first operand */
; 512  :     //if ( op1.kind == EXPR_EMPTY )
; 513  :     //    return( NOT_ERROR );
; 514  :     op = COP_NONE;

	mov	ebx, r14d
$LN25@GetSimpleE:

; 518  : 
; 519  :   label = GetLabel(hll, ilabel);

	movsxd	rax, DWORD PTR ilabel$[rsp]
	mov	r13d, DWORD PTR [r13+rax*4+36]

; 520  : 
; 521  :   DebugMsg1(("%u GetSimpleExpression: EvalOperand ok, kind=%X, i=%u [%s]\n", evallvl, op1.kind, *i, tokenarray[*i].tokpos));
; 522  : 
; 523  :   /* check for special operators with implicite operand:
; 524  :   * COP_ZERO, COP_CARRY, COP_SIGN, COP_PARITY, COP_OVERFLOW
; 525  :   */
; 526  :   if (op >= COP_ZERO) {

	cmp	ebx, 11
	jl	SHORT $LN26@GetSimpleE

; 527  :     if (op1.kind != EXPR_EMPTY) {

	cmp	DWORD PTR op1$[rsp+60], -2
	jne	$LN28@GetSimpleE

; 528  :       DebugMsg(("GetSimpleExpression: non-empty expression rejected: %s\n", tokenarray[op1_pos].tokpos));
; 529  :       return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));
; 530  :     }
; 531  :     p = buffer;
; 532  :     hllop->lastjmp = p;

	mov	rax, QWORD PTR hllop$[rsp]

; 533  :     RenderJcc(p, flaginstr[op - COP_ZERO], !is_true, label);

	lea	rdx, OFFSET FLAT:__ImageBase
	mov	rcx, QWORD PTR buffer$[rsp]
	test	bpl, bpl
	mov	r9d, r13d
	sete	r14b
	mov	QWORD PTR [rax], rcx
	mov	r8d, r14d
	movsxd	rax, ebx
	movzx	edx, BYTE PTR flaginstr[rax+rdx-11]
	call	RenderJcc

; 534  :     return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@GetSimpleE
$LN26@GetSimpleE:

; 535  :   }
; 536  : 
; 537  :   switch (op1.kind) {

	mov	ecx, DWORD PTR op1$[rsp+60]
	cmp	ecx, -2
	je	$LN28@GetSimpleE
	cmp	ecx, 3
	je	$LN29@GetSimpleE

; 544  :   }
; 545  : 
; 546  :   if (op == COP_NONE) {

	test	ebx, ebx
	jne	$LN30@GetSimpleE

; 547  :     switch (op1.kind) {

	test	ecx, ecx
	je	$LN34@GetSimpleE
	sub	ecx, 1
	je	SHORT $LN32@GetSimpleE
	cmp	ecx, 1
	jne	$LN37@GetSimpleE

; 548  :     case EXPR_REG:
; 549  :       if (op1.indirect == FALSE) {

	test	BYTE PTR op1$[rsp+72], cl
	jne	SHORT $LN32@GetSimpleE

; 550  :         p = RenderInstr(buffer, "test", op1_pos, op1_end, op1_pos, op1_end, tokenarray);

	mov	rcx, QWORD PTR buffer$[rsp]
	lea	rdx, OFFSET FLAT:$SG11215
	mov	QWORD PTR [rsp+48], rsi
	mov	r9d, r15d
	mov	DWORD PTR [rsp+40], r15d
	mov	r8d, r12d
	mov	DWORD PTR [rsp+32], r12d
	call	RenderInstr

; 551  :         hllop->lastjmp = p;

	mov	rcx, QWORD PTR hllop$[rsp]

; 552  :         RenderJcc(p, 'z', is_true, label);

	mov	r9d, r13d
	movzx	r8d, bpl
	mov	dl, 122					; 0000007aH
	mov	QWORD PTR [rcx], rax
	mov	rcx, rax
	call	RenderJcc

; 581  :       }
; 582  :       break;
; 583  : #ifdef DEBUG_OUT
; 584  :     default: /**/myassert(0); break;
; 585  : #endif
; 586  :     }
; 587  :     return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@GetSimpleE
$LN32@GetSimpleE:

; 553  :         break;
; 554  :       }
; 555  :       /* no break */
; 556  :     case EXPR_ADDR:
; 557  :       p = RenderInstr(buffer, "cmp", op1_pos, op1_end, EMPTY, 0, tokenarray);

	lea	rdx, OFFSET FLAT:$SG11217
	or	rax, -1
$LL113@GetSimpleE:
	inc	rax
	cmp	BYTE PTR [rdx+rax], r14b
	jne	SHORT $LL113@GetSimpleE
	mov	rcx, QWORD PTR buffer$[rsp]
	movsxd	rdi, eax
	mov	r8, rdi
	call	memcpy
	add	rdi, QWORD PTR buffer$[rsp]
	mov	rax, r15
	shl	rax, 5
	mov	rdx, r12
	shl	rdx, 5
	mov	BYTE PTR [rdi], 32			; 00000020H
	inc	rdi
	mov	eax, DWORD PTR [rax+rsi+24]
	mov	rcx, rdi
	sub	eax, DWORD PTR [rdx+rsi+24]
	mov	rdx, QWORD PTR [rdx+rsi+24]
	movsxd	rbx, eax
	mov	r8, rbx
	call	memcpy
	add	rdi, rbx
	lea	rdx, OFFSET FLAT:$SG11111
	mov	rcx, rdi
	xor	r8d, r8d
	call	sprintf
	movsxd	rdx, eax

; 558  :       hllop->lastjmp = p;
; 559  :       RenderJcc(p, 'z', is_true, label);

	mov	r9d, r13d
	mov	rax, QWORD PTR hllop$[rsp]
	add	rdi, rdx
	movzx	r8d, bpl
	mov	dl, 122					; 0000007aH
	mov	BYTE PTR [rdi], 10
	inc	rdi
	mov	rcx, rdi
	mov	BYTE PTR [rdi], r14b
	mov	QWORD PTR [rax], rdi
	call	RenderJcc

; 581  :       }
; 582  :       break;
; 583  : #ifdef DEBUG_OUT
; 584  :     default: /**/myassert(0); break;
; 585  : #endif
; 586  :     }
; 587  :     return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@GetSimpleE
$LN34@GetSimpleE:
	mov	eax, DWORD PTR op1$[rsp+4]
	inc	eax
	cmp	eax, 1
	jbe	SHORT $LN35@GetSimpleE

; 560  :       break;
; 561  :     case EXPR_CONST:
; 562  : #if 0
; 563  :       /* v2.05: string constant is allowed! */
; 564  :       if (op1.string != NULL) {
; 565  :         return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));
; 566  :       }
; 567  : #endif
; 568  :       /* v2.11: error if constant doesn't fit in 32-bits */
; 569  :       if (op1.hvalue != 0 && op1.hvalue != -1)
; 570  :         return(EmitConstError(&op1));

	lea	rcx, QWORD PTR op1$[rsp]
	call	EmitConstError
	jmp	$LN1@GetSimpleE
$LN35@GetSimpleE:

; 571  : 
; 572  :       hllop->lastjmp = buffer;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rax], rcx

; 573  : 
; 574  :       if ((is_true == TRUE && op1.value) ||

	cmp	bpl, 1
	jne	SHORT $LN39@GetSimpleE
	cmp	DWORD PTR op1$[rsp], r14d
	jne	SHORT $LN38@GetSimpleE
$LN36@GetSimpleE:

; 577  :       }
; 578  :       else {
; 579  :         //strcpy( buffer, " " EOLSTR ); /* v2.11: obsolete */
; 580  :         *buffer = NULLC;

	mov	BYTE PTR [rcx], r14b
$LN37@GetSimpleE:

; 581  :       }
; 582  :       break;
; 583  : #ifdef DEBUG_OUT
; 584  :     default: /**/myassert(0); break;
; 585  : #endif
; 586  :     }
; 587  :     return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@GetSimpleE
$LN39@GetSimpleE:

; 573  : 
; 574  :       if ((is_true == TRUE && op1.value) ||

	test	bpl, bpl
	jne	SHORT $LN36@GetSimpleE
	cmp	DWORD PTR op1$[rsp], r14d
	jne	SHORT $LN36@GetSimpleE
$LN38@GetSimpleE:

; 575  :         (is_true == FALSE && op1.value == 0)) {
; 576  :         sprintf(buffer, "jmp " LABELFMT EOLSTR, label);

	mov	r8d, r13d
	lea	rdx, OFFSET FLAT:$SG11224
	call	sprintf

; 581  :       }
; 582  :       break;
; 583  : #ifdef DEBUG_OUT
; 584  :     default: /**/myassert(0); break;
; 585  : #endif
; 586  :     }
; 587  :     return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@GetSimpleE
$LN30@GetSimpleE:

; 588  :   }
; 589  : 
; 590  :   /* get second operand for binary operator */
; 591  :   op2_pos = *i;

	mov	eax, DWORD PTR [rdi]

; 592  :   if (ERROR == GetToken(hll, i, tokenarray, &op2)) {

	lea	r9, QWORD PTR op2$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	r8, rsi
	mov	rdx, rdi
	mov	DWORD PTR op2_pos$1$[rsp], eax
	call	GetToken
	cmp	eax, -1
	je	$LN119@GetSimpleE

; 593  :     return(ERROR);
; 594  :   }
; 595  :   DebugMsg1(("%u GetSimpleExpression: EvalOperand 2 ok, type=%X, i=%u [%s]\n", evallvl, op2.type, *i, tokenarray[*i].tokpos));
; 596  :   if (op2.kind != EXPR_CONST && op2.kind != EXPR_ADDR && op2.kind != EXPR_REG) {
; 597  :     DebugMsg(("GetSimpleExpression: syntax error, op2.kind=%u\n", op2.kind));
; 598  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, DWORD PTR op2$[rsp+60]
	cmp	ecx, 2
	ja	$LN28@GetSimpleE

; 599  :   }
; 600  :   op2_end = *i;

	mov	edx, DWORD PTR [rdi]

; 601  : 
; 602  :   /* now generate ASM code for expression */
; 603  : 
; 604  :   if (op == COP_ANDB) {

	cmp	ebx, 9
	jne	SHORT $LN42@GetSimpleE

; 605  :     p = RenderInstr(buffer, "test", op1_pos, op1_end, op2_pos, op2_end, tokenarray);

	mov	eax, DWORD PTR op2_pos$1$[rsp]
	mov	r9d, r15d
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	r8d, r12d
	mov	QWORD PTR [rsp+48], rsi
	mov	DWORD PTR [rsp+40], edx
	lea	rdx, OFFSET FLAT:$SG11229
	mov	DWORD PTR [rsp+32], eax
	call	RenderInstr

; 606  :     hllop->lastjmp = p;

	mov	rcx, QWORD PTR hllop$[rsp]

; 607  :     RenderJcc(p, 'e', is_true, label);

	mov	dl, 101					; 00000065H
	movzx	r8d, bpl

; 626  :     RenderJcc(p, instr, neg_cjmptype[op - COP_EQ] ? is_true : !is_true, label);

	mov	r9d, r13d
	mov	QWORD PTR [rcx], rax
	mov	rcx, rax
	call	RenderJcc

; 627  :   }
; 628  :   else {
; 629  :     DebugMsg(("GetSimpleExpression: unexpected operator %s\n", tokenarray[op1_pos].tokpos));
; 630  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));
; 631  :   }
; 632  :   return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@GetSimpleE
$LN42@GetSimpleE:

; 608  :   }
; 609  :   else if (op <= COP_LE) { /* ==, !=, >, <, >= or <= operator */

	cmp	ebx, 6
	jg	$LN28@GetSimpleE

; 610  :                            /*
; 611  :                            * optimisation: generate 'or EAX,EAX' instead of 'cmp EAX,0'.
; 612  :                            * v2.11: use op2.value64 instead of op2.value
; 613  :                            */
; 614  :     if (Options.masm_compat_gencode &&
; 615  :       (op == COP_EQ || op == COP_NE) &&
; 616  :       op1.kind == EXPR_REG && op1.indirect == FALSE &&
; 617  :       op2.kind == EXPR_CONST && op2.value64 == 0) {

	cmp	BYTE PTR Options+128, r14b
	je	SHORT $LN46@GetSimpleE
	lea	eax, DWORD PTR [rbx-1]
	cmp	eax, 1
	ja	SHORT $LN46@GetSimpleE
	cmp	DWORD PTR op1$[rsp+60], 2
	jne	SHORT $LN46@GetSimpleE
	test	BYTE PTR op1$[rsp+72], 1
	jne	SHORT $LN46@GetSimpleE
	test	ecx, ecx
	jne	SHORT $LN46@GetSimpleE
	cmp	QWORD PTR op2$[rsp], r14
	jne	SHORT $LN46@GetSimpleE

; 618  :       p = RenderInstr(buffer, "or", op1_pos, op1_end, op1_pos, op1_end, tokenarray);

	mov	QWORD PTR [rsp+48], rsi
	lea	rdx, OFFSET FLAT:$SG11235
	mov	DWORD PTR [rsp+40], r15d
	mov	DWORD PTR [rsp+32], r12d

; 619  :     }

	jmp	SHORT $LN116@GetSimpleE
$LN46@GetSimpleE:

; 620  :     else {
; 621  :       p = RenderInstr(buffer, "cmp", op1_pos, op1_end, op2_pos, op2_end, tokenarray);

	mov	eax, DWORD PTR op2_pos$1$[rsp]
	mov	QWORD PTR [rsp+48], rsi
	mov	DWORD PTR [rsp+40], edx
	lea	rdx, OFFSET FLAT:$SG11236
	mov	DWORD PTR [rsp+32], eax
$LN116@GetSimpleE:
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	r9d, r15d
	mov	r8d, r12d
	call	RenderInstr
	mov	r10, rax

; 622  :     }
; 623  : 
; 624  :     instr = ((IS_SIGNED(op1.mem_type) || IS_SIGNED(op2.mem_type)) ? signed_cjmptype[op - COP_EQ] : unsigned_cjmptype[op - COP_EQ]);

	mov	eax, DWORD PTR op1$[rsp+64]
	and	al, -64					; ffffffffffffffc0H
	cmp	al, 64					; 00000040H
	je	SHORT $LN50@GetSimpleE
	mov	eax, DWORD PTR op2$[rsp+64]
	and	al, -64					; ffffffffffffffc0H
	cmp	al, 64					; 00000040H
	je	SHORT $LN50@GetSimpleE
	movsxd	rcx, ebx
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	r11d, BYTE PTR unsigned_cjmptype[rcx+rdx-1]
	jmp	SHORT $LN51@GetSimpleE
$LN50@GetSimpleE:
	movsxd	rcx, ebx
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	r11d, BYTE PTR signed_cjmptype[rcx+rdx-1]
$LN51@GetSimpleE:

; 625  :     hllop->lastjmp = p;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rax], r10

; 626  :     RenderJcc(p, instr, neg_cjmptype[op - COP_EQ] ? is_true : !is_true, label);

	cmp	BYTE PTR neg_cjmptype[rcx+rdx-1], r14b
	je	SHORT $LN52@GetSimpleE
	movzx	r14d, bpl
	jmp	SHORT $LN53@GetSimpleE
$LN52@GetSimpleE:
	test	bpl, bpl
	sete	r14b
$LN53@GetSimpleE:
	mov	r8d, r14d
	movzx	edx, r11b
	mov	rcx, r10
	mov	r9d, r13d
	call	RenderJcc

; 627  :   }
; 628  :   else {
; 629  :     DebugMsg(("GetSimpleExpression: unexpected operator %s\n", tokenarray[op1_pos].tokpos));
; 630  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));
; 631  :   }
; 632  :   return(NOT_ERROR);

	xor	eax, eax
	jmp	SHORT $LN1@GetSimpleE
$LN29@GetSimpleE:

; 541  :   case EXPR_FLOAT:
; 542  :     DebugMsg(("GetSimpleExpression: float expression rejected: %s\n", tokenarray[op1_pos].tokpos));
; 543  :     return(EmitError(REAL_OR_BCD_NUMBER_NOT_ALLOWED)); /* v2.10: added */

	mov	ecx, 271				; 0000010fH
	jmp	SHORT $LN118@GetSimpleE
$LN28@GetSimpleE:

; 538  :   case EXPR_EMPTY:
; 539  :     DebugMsg(("GetSimpleExpression: empty expression rejected\n"));
; 540  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE)); /* v2.09: changed from NOT_ERROR to ERROR */

	mov	ecx, 199				; 000000c7H
$LN118@GetSimpleE:
	call	EmitError
$LN1@GetSimpleE:
	mov	r14, QWORD PTR [rsp+368]

; 633  : }

	add	rsp, 288				; 00000120H
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
GetSimpleExpression ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT GetLabel
_TEXT	SEGMENT
hll$ = 8
index$ = 16
GetLabel PROC						; COMDAT

; 435  :   /**/myassert(hll->labels[index]);
; 436  :   return(hll->labels[index]);

	movsxd	rax, edx
	mov	eax, DWORD PTR [rcx+rax*4+36]

; 437  : }

	ret	0
GetLabel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT GetToken
_TEXT	SEGMENT
hll$ = 80
i$ = 88
tokenarray$ = 96
opnd$ = 104
GetToken PROC						; COMDAT

; 404  : {

	mov	QWORD PTR [rsp+32], rbp
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 405  :   int end_tok;
; 406  : 
; 407  :   /* scan for the next C operator in the token array.
; 408  :   * because the ASM evaluator may report an error if such a thing
; 409  :   * is found ( CARRY?, ZERO? and alikes will be regarded as - not yet defined - labels )
; 410  :   */
; 411  :   for (end_tok = *i; end_tok < Token_Count; end_tok++) {

	movsxd	rdi, DWORD PTR [rdx]
	mov	rbp, r9
	cmp	edi, DWORD PTR ModuleInfo+496
	mov	r15, r8
	mov	r14, rdx
	jge	$LN81@GetToken
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+88], rsi
	mov	rsi, rdi
	shl	rsi, 5
	mov	QWORD PTR [rsp+96], r12
	add	rsi, r8
	mov	r12, 5764607806502076416		; 5000004200000000H
	npad	7
$LL4@GetToken:

; 412  :     if ((GetCOp(&tokenarray[end_tok])) != COP_NONE)

	movzx	ecx, BYTE PTR [rsi]
	mov	rbx, QWORD PTR [rsi+8]
	cmp	cl, 9
	jne	SHORT $LN24@GetToken
	mov	eax, DWORD PTR [rsi+16]
	cmp	eax, 2
	jne	SHORT $LN15@GetToken
	movzx	ecx, WORD PTR [rbx]
	cmp	ecx, 15677				; 00003d3dH
	jg	SHORT $LN56@GetToken
	je	$LN84@GetToken
	sub	ecx, 9766				; 00002626H
	je	$LN84@GetToken
	sub	ecx, 5883				; 000016fbH
	je	$LN84@GetToken
	sub	ecx, 27
	jmp	$LN85@GetToken
$LN56@GetToken:
	cmp	ecx, 15678				; 00003d3eH
	je	$LN84@GetToken
	cmp	ecx, 31868				; 00007c7cH
	jmp	$LN85@GetToken
$LN15@GetToken:
	cmp	eax, 1
	jne	SHORT $LN24@GetToken
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 62					; 0000003eH
	ja	$LN51@GetToken
	bt	r12, rax
	jb	$LN84@GetToken
	jmp	$LN51@GetToken
$LN24@GetToken:
	cmp	cl, 8
	jne	$LN51@GetToken
	or	rcx, -1
	npad	8
$LL80@GetToken:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], 0
	jne	SHORT $LL80@GetToken
	movsxd	rax, ecx
	cmp	BYTE PTR [rax+rbx-1], 63		; 0000003fH
	jne	$LN51@GetToken
	cmp	ecx, 5
	jne	SHORT $LN33@GetToken
	lea	r8d, QWORD PTR [rcx-1]
	mov	rcx, rbx
	lea	rdx, OFFSET FLAT:$SG11008
	call	_memicmp
	test	eax, eax
	je	$LN84@GetToken
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11014
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	je	$LN84@GetToken
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11023
	jmp	$LN86@GetToken
$LN33@GetToken:
	cmp	ecx, 6
	jne	SHORT $LN37@GetToken
	lea	r8d, QWORD PTR [rcx-1]
	mov	rcx, rbx
	lea	rdx, OFFSET FLAT:$SG11011
	call	_memicmp
	test	eax, eax
	je	$LN84@GetToken
	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG11029
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	je	SHORT $LN84@GetToken
	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG11032
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	je	SHORT $LN84@GetToken
	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG11035
	jmp	SHORT $LN86@GetToken
$LN37@GetToken:
	cmp	ecx, 7
	jne	SHORT $LN39@GetToken
	lea	r8d, QWORD PTR [rcx-1]
	lea	rdx, OFFSET FLAT:$SG11017
	jmp	SHORT $LN86@GetToken
$LN39@GetToken:
	cmp	ecx, 9
	jne	SHORT $LN43@GetToken
	lea	r8d, QWORD PTR [rcx-1]
	lea	rdx, OFFSET FLAT:$SG11020
	jmp	SHORT $LN86@GetToken
$LN43@GetToken:
	cmp	ecx, 8
	jne	SHORT $LN51@GetToken
	lea	r8d, QWORD PTR [rcx-1]
	lea	rdx, OFFSET FLAT:$SG11026
$LN86@GetToken:
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
$LN85@GetToken:
	je	SHORT $LN84@GetToken
$LN51@GetToken:

; 405  :   int end_tok;
; 406  : 
; 407  :   /* scan for the next C operator in the token array.
; 408  :   * because the ASM evaluator may report an error if such a thing
; 409  :   * is found ( CARRY?, ZERO? and alikes will be regarded as - not yet defined - labels )
; 410  :   */
; 411  :   for (end_tok = *i; end_tok < Token_Count; end_tok++) {

	inc	edi
	add	rsi, 32					; 00000020H
	cmp	edi, DWORD PTR ModuleInfo+496
	jl	$LL4@GetToken
$LN84@GetToken:
	mov	rsi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
	mov	r12, QWORD PTR [rsp+96]
$LN81@GetToken:

; 413  :       break;
; 414  :   }
; 415  :   if (end_tok == *i) {

	cmp	edi, DWORD PTR [r14]
	jne	SHORT $LN6@GetToken

; 416  :     opnd->kind = EXPR_EMPTY;

	mov	DWORD PTR [rbp+60], -2
$LN8@GetToken:

; 427  :   }
; 428  : 
; 429  :   return(NOT_ERROR);

	xor	eax, eax

; 430  : }

	mov	rbp, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN6@GetToken:

; 417  :     return(NOT_ERROR);
; 418  :   }
; 419  :   if (ERROR == EvalOperand(i, tokenarray, end_tok, opnd, 0))

	mov	r9, rbp
	mov	BYTE PTR [rsp+32], 0
	mov	r8d, edi
	mov	rdx, r15
	mov	rcx, r14
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN7@GetToken

; 420  :     return(ERROR);

	or	eax, eax

; 430  : }

	mov	rbp, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN7@GetToken:

; 421  : 
; 422  :   /* v2.11: emit error 'syntax error in control flow directive'.
; 423  :   * May happen for expressions like ".if 1 + CARRY?"
; 424  :   */
; 425  :   if (*i > end_tok) {

	cmp	DWORD PTR [r14], edi
	jle	SHORT $LN8@GetToken

; 426  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, 199				; 000000c7H

; 430  : }

	mov	rbp, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi

; 426  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	jmp	EmitError
GetToken ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT RenderJcc
_TEXT	SEGMENT
dst$ = 48
cc$ = 56
neg$ = 64
label$ = 72
RenderJcc PROC						; COMDAT

; 379  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 380  : #ifdef DEBUG_OUT
; 381  :   char *old = dst;
; 382  : #endif
; 383  :   /* create the jump opcode: j[n]cc */
; 384  :   *dst++ = 'j';

	mov	BYTE PTR [rcx], 106			; 0000006aH
	lea	rbx, QWORD PTR [rcx+1]

; 385  :   if (neg)

	test	r8d, r8d
	je	SHORT $LN2@RenderJcc

; 386  :     *dst++ = 'n';

	mov	BYTE PTR [rbx], 110			; 0000006eH
	inc	rbx
$LN2@RenderJcc:

; 387  :   *dst++ = cc;

	mov	BYTE PTR [rbx], dl
	inc	rbx

; 388  :   if (neg == FALSE)

	test	r8d, r8d
	jne	SHORT $LN3@RenderJcc

; 389  :     *dst++ = ' '; /* make sure there's room for the inverse jmp */

	mov	BYTE PTR [rbx], 32			; 00000020H
	inc	rbx
$LN3@RenderJcc:

; 390  : 
; 391  :   *dst++ = ' ';
; 392  :   GetLabelStr(label, dst);

	mov	r8d, r9d
	mov	BYTE PTR [rbx], 32			; 00000020H
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR [rbx+1]
	call	sprintf

; 393  :   dst += strlen(dst);

	or	rax, -1
$LL7@RenderJcc:
	inc	rax
	cmp	BYTE PTR [rbx+rax+1], 0
	jne	SHORT $LL7@RenderJcc

; 394  :   *dst++ = EOLCHAR;

	mov	WORD PTR [rbx+rax+1], 10

; 395  :   *dst = NULLC;
; 396  :   DebugMsg1(("%u RenderJcc()=>%s<\n", evallvl, old));
; 397  :   return(dst);

	add	rbx, 2
	add	rax, rbx

; 398  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
RenderJcc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT GetLabelStr
_TEXT	SEGMENT
label$ = 48
buff$ = 56
GetLabelStr PROC					; COMDAT

; 370  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 371  :   sprintf(buff, LABELFMT, label);

	mov	r8d, ecx
	mov	rcx, rbx
	lea	rdx, OFFSET FLAT:$SG11118
	call	sprintf

; 372  :   return(buff);

	mov	rax, rbx

; 373  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
GetLabelStr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT RenderInstr
_TEXT	SEGMENT
dst$ = 48
instr$ = 56
start1$ = 64
end1$ = 72
start2$ = 80
end2$ = 88
tokenarray$ = 96
RenderInstr PROC					; COMDAT

; 337  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rbp, r9d
	mov	rbx, rcx
	movsxd	rsi, r8d

; 338  :   int i;
; 339  : #ifdef DEBUG_OUT
; 340  :   char *old = dst;
; 341  : #endif
; 342  :   i = strlen(instr);

	or	rax, -1
$LL6@RenderInst:
	inc	rax
	cmp	BYTE PTR [rdx+rax], 0
	jne	SHORT $LL6@RenderInst

; 343  :   /* copy the instruction */
; 344  :   memcpy(dst, instr, i);

	movsxd	rdi, eax
	mov	r8, rdi
	call	memcpy

; 345  :   dst += i;

	add	rbx, rdi

; 346  :   /* copy the first operand's tokens */
; 347  :   *dst++ = ' ';
; 348  :   i = tokenarray[end1].tokpos - tokenarray[start1].tokpos;

	mov	rdx, rsi
	mov	rsi, QWORD PTR tokenarray$[rsp]
	mov	rax, rbp
	shl	rdx, 5
	shl	rax, 5
	mov	BYTE PTR [rbx], 32			; 00000020H
	inc	rbx
	mov	ecx, DWORD PTR [rax+rsi+24]
	sub	ecx, DWORD PTR [rdx+rsi+24]

; 349  :   memcpy(dst, tokenarray[start1].tokpos, i);

	mov	rdx, QWORD PTR [rdx+rsi+24]
	movsxd	rdi, ecx
	mov	rcx, rbx
	mov	r8, rdi
	call	memcpy

; 350  :   dst += i;
; 351  :   if (start2 != EMPTY) {

	movsxd	rax, DWORD PTR start2$[rsp]
	add	rbx, rdi
	cmp	eax, -2
	je	SHORT $LN2@RenderInst

; 352  :     *dst++ = ',';

	mov	WORD PTR [rbx], 8236			; 0000202cH

; 353  :     /* copy the second operand's tokens */
; 354  :     *dst++ = ' ';
; 355  :     i = tokenarray[end2].tokpos - tokenarray[start2].tokpos;

	mov	rdx, rax
	movsxd	rax, DWORD PTR end2$[rsp]
	add	rbx, 2
	shl	rdx, 5
	shl	rax, 5
	mov	ecx, DWORD PTR [rax+rsi+24]
	sub	ecx, DWORD PTR [rdx+rsi+24]

; 356  :     memcpy(dst, tokenarray[start2].tokpos, i);

	mov	rdx, QWORD PTR [rdx+rsi+24]
	movsxd	rdi, ecx
	mov	rcx, rbx
	mov	r8, rdi
	call	memcpy

; 357  :     dst += i;

	add	rbx, rdi

; 358  :   }

	jmp	SHORT $LN4@RenderInst
$LN2@RenderInst:

; 359  :   else if (end2 != EMPTY) {

	mov	r8d, DWORD PTR end2$[rsp]
	cmp	r8d, -2
	je	SHORT $LN4@RenderInst

; 360  :     dst += sprintf(dst, ", %d", end2);

	lea	rdx, OFFSET FLAT:$SG11111
	mov	rcx, rbx
	call	sprintf
	movsxd	rcx, eax
	add	rbx, rcx
$LN4@RenderInst:

; 361  :   }
; 362  :   *dst++ = EOLCHAR;
; 363  :   *dst = NULLC;
; 364  :   DebugMsg1(("%u RenderInstr(%s)=>%s<\n", evallvl, instr, old));
; 365  :   return(dst);
; 366  : }

	mov	rbp, QWORD PTR [rsp+56]
	lea	rax, QWORD PTR [rbx+1]
	mov	rsi, QWORD PTR [rsp+64]
	mov	WORD PTR [rbx], 10
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
RenderInstr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT bubblesort64
_TEXT	SEGMENT
hll$ = 16
lbl$ = 24
src$ = 32
n$ = 40
bubblesort64 PROC					; COMDAT

; 307  : static void bubblesort64(struct hll_item *hll, uint_16 *lbl, int_64 *src, int n) {

	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	movsxd	rdi, r9d
	mov	r14, r8
	mov	r11, rdx
	mov	rbp, rcx

; 308  :   /*******************************************************************************************************************************/
; 309  :   int i;
; 310  :   int j;
; 311  :   int_64 temp1;
; 312  :   uint_16 temp2;
; 313  :   for (i = 0; i < n; ++i)

	test	r9d, r9d
	jle	SHORT $LN3@bubblesort
	mov	QWORD PTR [rsp+16], rbx
	mov	r10, r8
	mov	QWORD PTR [rsp+24], rsi
	mov	ebx, 1
	mov	esi, edi
$LL4@bubblesort:

; 314  :   {
; 315  :     for (j = i + 1; j < n; ++j)

	cmp	ebx, edi
	jge	SHORT $LN2@bubblesort
	mov	r9d, edi
	lea	r8, QWORD PTR [r11+2]
	sub	r9d, ebx
	lea	rax, QWORD PTR [r10+8]
$LL7@bubblesort:

; 316  :     {
; 317  :       if (src[i] > src[j])

	mov	rcx, QWORD PTR [r10]
	mov	rdx, QWORD PTR [rax]
	cmp	rcx, rdx
	jle	SHORT $LN5@bubblesort

; 318  :       {
; 319  :         temp1 = src[i];
; 320  :         src[i] = src[j];

	mov	QWORD PTR [r10], rdx

; 321  :         src[j] = temp1;

	mov	QWORD PTR [rax], rcx

; 322  :         temp2 = lbl[i];
; 323  :         lbl[i] = lbl[j];

	movzx	ecx, WORD PTR [r8]
	movzx	edx, WORD PTR [r11]
	mov	WORD PTR [r11], cx

; 324  :         lbl[j] = temp2;

	mov	WORD PTR [r8], dx
$LN5@bubblesort:

; 314  :   {
; 315  :     for (j = i + 1; j < n; ++j)

	add	rax, 8
	add	r8, 2
	sub	r9, 1
	jne	SHORT $LL7@bubblesort
$LN2@bubblesort:

; 308  :   /*******************************************************************************************************************************/
; 309  :   int i;
; 310  :   int j;
; 311  :   int_64 temp1;
; 312  :   uint_16 temp2;
; 313  :   for (i = 0; i < n; ++i)

	inc	ebx
	add	r10, 8
	add	r11, 2
	sub	rsi, 1
	jne	SHORT $LL4@bubblesort
	mov	rsi, QWORD PTR [rsp+24]
	mov	rbx, QWORD PTR [rsp+16]
$LN3@bubblesort:

; 325  :       }
; 326  :     }
; 327  :   }
; 328  : 
; 329  :   hll->mincase64 = src[0];

	mov	rdx, QWORD PTR [r14]
	mov	QWORD PTR [rbp+144], rdx

; 330  :   hll->maxcase64 = src[n - 1];

	mov	rcx, QWORD PTR [r14+rdi*8-8]

; 331  :   hll->delta64 = hll->maxcase64 - hll->mincase64;
; 332  : }

	mov	rdi, QWORD PTR [rsp+40]
	mov	QWORD PTR [rbp+136], rcx
	sub	rcx, rdx
	mov	QWORD PTR [rbp+152], rcx
	mov	rbp, QWORD PTR [rsp+32]
	pop	r14
	ret	0
bubblesort64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT bubblesort
_TEXT	SEGMENT
hll$ = 16
lbl$ = 24
src$ = 32
n$ = 40
bubblesort PROC						; COMDAT

; 281  : static void bubblesort(struct hll_item *hll, uint_16 *lbl, int *src, int n) {

	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	movsxd	rdi, r9d
	mov	r14, r8
	mov	r11, rdx
	mov	rbp, rcx

; 282  :   /*******************************************************************************************************************************/
; 283  :   int i;
; 284  :   int j;
; 285  :   int temp1;
; 286  :   uint_16 temp2;
; 287  :   for (i = 0; i < n; ++i)

	test	r9d, r9d
	jle	SHORT $LN3@bubblesort
	mov	QWORD PTR [rsp+16], rbx
	mov	r10, r8
	mov	QWORD PTR [rsp+24], rsi
	mov	ebx, 1
	mov	esi, edi
$LL4@bubblesort:

; 288  :   {
; 289  :     for (j = i + 1; j < n; ++j)

	cmp	ebx, edi
	jge	SHORT $LN2@bubblesort
	mov	r9d, edi
	lea	r8, QWORD PTR [r11+2]
	sub	r9d, ebx
	lea	rax, QWORD PTR [r10+4]
$LL7@bubblesort:

; 290  :     {
; 291  :       if (src[i] > src[j])

	mov	ecx, DWORD PTR [r10]
	mov	edx, DWORD PTR [rax]
	cmp	ecx, edx
	jle	SHORT $LN5@bubblesort

; 292  :       {
; 293  :         temp1 = src[i];
; 294  :         src[i] = src[j];

	mov	DWORD PTR [r10], edx

; 295  :         src[j] = temp1;

	mov	DWORD PTR [rax], ecx

; 296  :         temp2 = lbl[i];
; 297  :         lbl[i] = lbl[j];

	movzx	ecx, WORD PTR [r8]
	movzx	edx, WORD PTR [r11]
	mov	WORD PTR [r11], cx

; 298  :         lbl[j] = temp2;

	mov	WORD PTR [r8], dx
$LN5@bubblesort:

; 288  :   {
; 289  :     for (j = i + 1; j < n; ++j)

	add	rax, 4
	add	r8, 2
	sub	r9, 1
	jne	SHORT $LL7@bubblesort
$LN2@bubblesort:

; 282  :   /*******************************************************************************************************************************/
; 283  :   int i;
; 284  :   int j;
; 285  :   int temp1;
; 286  :   uint_16 temp2;
; 287  :   for (i = 0; i < n; ++i)

	inc	ebx
	add	r10, 4
	add	r11, 2
	sub	rsi, 1
	jne	SHORT $LL4@bubblesort
	mov	rsi, QWORD PTR [rsp+24]
	mov	rbx, QWORD PTR [rsp+16]
$LN3@bubblesort:

; 299  :       }
; 300  :     }
; 301  :   }
; 302  :   hll->mincase = src[0];

	mov	edx, DWORD PTR [r14]
	mov	DWORD PTR [rbp+120], edx

; 303  :   hll->maxcase = src[n - 1];

	mov	ecx, DWORD PTR [r14+rdi*4-4]

; 304  :   hll->delta = hll->maxcase - hll->mincase;
; 305  : }

	mov	rdi, QWORD PTR [rsp+40]
	mov	DWORD PTR [rbp+116], ecx
	sub	ecx, edx
	mov	DWORD PTR [rbp+124], ecx
	mov	rbp, QWORD PTR [rsp+32]
	pop	r14
	ret	0
bubblesort ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
src$ = 8
hex2dec	PROC

; 263  :   uint_32 a;
; 264  :   uint_32 b = 0;
; 265  :   for (;;)
; 266  :   {
; 267  :     a = *src;

	movsx	eax, BYTE PTR [rcx]
	xor	edx, edx
	mov	r9, rcx

; 268  :     if (!a) break;

	test	eax, eax
	je	SHORT $LN16@hex2dec
	npad	4
$LL2@hex2dec:

; 269  :     b = (b << 4);

	shl	edx, 4

; 270  :     if (a >= '0' && a <= '9') a -= '0';

	lea	r8d, DWORD PTR [rax-48]
	cmp	r8d, 9
	ja	SHORT $LN6@hex2dec
	mov	eax, r8d
	jmp	SHORT $LN8@hex2dec
$LN6@hex2dec:

; 271  :     else {
; 272  :       a |= 0x20;

	or	eax, 32					; 00000020H

; 273  :       if (a >= 'a' && a <= 'f') a -= 'a' - 10;

	lea	ecx, DWORD PTR [rax-97]
	cmp	ecx, 5
	ja	SHORT $LN8@hex2dec
	add	eax, -87				; ffffffa9H
$LN8@hex2dec:

; 274  :     }
; 275  :     b = b + a;
; 276  :     src++;

	inc	r9
	add	edx, eax
	movsx	eax, BYTE PTR [r9]
	test	eax, eax
	jne	SHORT $LL2@hex2dec
$LN16@hex2dec:

; 277  :   }
; 278  :   return (b);

	mov	eax, edx

; 279  : }

	ret	0
hex2dec	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT GetCOp
_TEXT	SEGMENT
item$ = 48
GetCOp	PROC						; COMDAT

; 201  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 202  :   int size;
; 203  :   enum c_bop rc;
; 204  :   char *p = item->string_ptr;
; 205  : 
; 206  :   size = (item->token == T_STRING ? item->stringlen : 0);

	movzx	eax, BYTE PTR [rcx]
	mov	rbx, QWORD PTR [rcx+8]
	cmp	al, 9
	jne	$LN15@GetCOp
	mov	edx, DWORD PTR [rcx+16]

; 207  : 
; 208  :   if (size == 2) {

	cmp	edx, 2
	jne	SHORT $LN6@GetCOp

; 209  :     switch (*(uint_16 *)p) {

	movzx	ecx, WORD PTR [rbx]
	cmp	ecx, 15677				; 00003d3dH
	jg	SHORT $LN47@GetCOp
	je	SHORT $LN8@GetCOp
	sub	ecx, 9766				; 00002626H
	je	SHORT $LN12@GetCOp
	sub	ecx, 5883				; 000016fbH
	je	SHORT $LN9@GetCOp
	cmp	ecx, 27
	jne	$LN42@GetCOp

; 213  :     case CHARS_LE:  rc = COP_LE;  break;

	lea	eax, QWORD PTR [rdx+4]

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN9@GetCOp:

; 211  :     case CHARS_NE:  rc = COP_NE;  break;

	mov	eax, 2

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN12@GetCOp:

; 214  :     case CHARS_AND: rc = COP_AND; break;

	mov	eax, 7

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN8@GetCOp:

; 210  :     case CHARS_EQ:  rc = COP_EQ;  break;

	mov	eax, 1

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN47@GetCOp:

; 209  :     switch (*(uint_16 *)p) {

	cmp	ecx, 15678				; 00003d3eH
	je	SHORT $LN10@GetCOp
	cmp	ecx, 31868				; 00007c7cH
	jne	$LN42@GetCOp

; 215  :     case CHARS_OR:  rc = COP_OR;  break;

	mov	eax, 8

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN10@GetCOp:

; 212  :     case CHARS_GE:  rc = COP_GE;  break;

	mov	eax, 5

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN6@GetCOp:

; 216  :     default: return(COP_NONE);
; 217  :     }
; 218  :   }
; 219  :   else if (size == 1) {

	cmp	edx, 1
	jne	SHORT $LN15@GetCOp

; 220  :     switch (*p) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, 33					; 00000021H
	je	SHORT $LN20@GetCOp
	cmp	al, 38					; 00000026H
	je	SHORT $LN19@GetCOp
	cmp	al, 60					; 0000003cH
	je	SHORT $LN18@GetCOp
	cmp	al, 62					; 0000003eH
	jne	$LN42@GetCOp

; 221  :     case '>': rc = COP_GT;   break;

	lea	eax, QWORD PTR [rdx+2]

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@GetCOp:

; 222  :     case '<': rc = COP_LT;   break;

	mov	eax, 4

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@GetCOp:

; 223  :     case '&': rc = COP_ANDB; break;

	mov	eax, 9

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN20@GetCOp:

; 224  :     case '!': rc = COP_NEG;  break;

	mov	eax, 10

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN15@GetCOp:

; 225  :     default: return(COP_NONE);
; 226  :     }
; 227  :   }
; 228  :   else {
; 229  :     if (item->token != T_ID)

	cmp	al, 8
	jne	$LN42@GetCOp

; 230  :       return(COP_NONE);
; 231  :     /* a valid "flag" string must end with a question mark */
; 232  :     size = strlen(p);

	or	rcx, -1
	npad	7
$LL53@GetCOp:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], 0
	jne	SHORT $LL53@GetCOp

; 233  :     if (*(p + size - 1) != '?')

	movsxd	rax, ecx
	cmp	BYTE PTR [rax+rbx-1], 63		; 0000003fH
	jne	$LN42@GetCOp

; 234  :       return(COP_NONE);
; 235  :     if (size == 5 && (0 == _memicmp(p, "ZERO", 4)))

	cmp	ecx, 5
	jne	SHORT $LN24@GetCOp
	lea	r8d, QWORD PTR [rcx-1]
	mov	rcx, rbx
	lea	rdx, OFFSET FLAT:$SG11008
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN48@GetCOp

; 236  :       rc = COP_ZERO;

	mov	eax, 11

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN48@GetCOp:

; 239  :     else if (size == 5 && (0 == _memicmp(p, "SIGN", 4)))

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11014
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN50@GetCOp

; 240  :       rc = COP_SIGN;

	mov	eax, 13

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN50@GetCOp:

; 245  :     //added by habran
; 246  :     else if (size == 5 && (0 == _memicmp(p, "LESS", 4)))

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11023
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	jne	$LN42@GetCOp

; 247  :       rc = COP_LESS;

	mov	eax, 16

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN24@GetCOp:

; 237  :     else if (size == 6 && (0 == _memicmp(p, "CARRY", 5)))

	cmp	ecx, 6
	jne	$LN28@GetCOp
	lea	r8d, QWORD PTR [rcx-1]
	mov	rcx, rbx
	lea	rdx, OFFSET FLAT:$SG11011
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN49@GetCOp

; 238  :       rc = COP_CARRY;

	mov	eax, 12

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN49@GetCOp:

; 250  :     else if (size == 6 && (0 == _memicmp(p, "ABOVE", 5)))

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG11029
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN51@GetCOp

; 251  :       rc = COP_ABOVE;

	mov	eax, 18

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN51@GetCOp:

; 252  :     else if (size == 6 && (0 == _memicmp(p, "EQUAL", 5)))

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG11032
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN52@GetCOp

; 253  :       rc = COP_EQUAL;

	mov	eax, 19

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN52@GetCOp:

; 254  :     else if (size == 6 && (0 == _memicmp(p, "BELOW", 5)))

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG11035
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	jne	$LN42@GetCOp

; 255  :       rc = COP_BELOW;

	mov	eax, 20

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN28@GetCOp:

; 241  :     else if (size == 7 && (0 == _memicmp(p, "PARITY", 6)))

	cmp	ecx, 7
	jne	SHORT $LN30@GetCOp
	lea	r8d, QWORD PTR [rcx-1]
	mov	rcx, rbx
	lea	rdx, OFFSET FLAT:$SG11017
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN42@GetCOp

; 242  :       rc = COP_PARITY;

	mov	eax, 14

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN30@GetCOp:

; 243  :     else if (size == 9 && (0 == _memicmp(p, "OVERFLOW", 8)))

	cmp	ecx, 9
	jne	SHORT $LN34@GetCOp
	lea	r8d, QWORD PTR [rcx-1]
	mov	rcx, rbx
	lea	rdx, OFFSET FLAT:$SG11020
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN42@GetCOp

; 244  :       rc = COP_OVERFLOW;

	mov	eax, 15

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN34@GetCOp:

; 248  :     else if (size == 8 && (0 == _memicmp(p, "GREATER", 7)))

	cmp	ecx, 8
	jne	SHORT $LN42@GetCOp
	lea	r8d, QWORD PTR [rcx-1]
	mov	rcx, rbx
	lea	rdx, OFFSET FLAT:$SG11026
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN42@GetCOp

; 249  :       rc = COP_GREATER;

	mov	eax, 17

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN42@GetCOp:

; 256  :     else
; 257  :       return(COP_NONE);

	xor	eax, eax

; 258  :   }
; 259  :   return(rc);
; 260  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
GetCOp	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT GetHllLabel
_TEXT	SEGMENT
GetHllLabel PROC					; COMDAT

; 181  :   return (++ModuleInfo.hll_label);

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax

; 182  : }

	ret	0
GetHllLabel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
;	COMDAT GetExpression
_TEXT	SEGMENT
buff$1 = 64
hll$ = 144
i$ = 152
tokenarray$ = 160
ilabel$ = 168
is_true$ = 176
buffer$ = 184
hllop$ = 192
GetExpression PROC					; COMDAT

; 776  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H

; 777  :   char *ptr = buffer;
; 778  :   uint_32 truelabel = 0;
; 779  : 
; 780  :   DebugMsg1(("%u GetExpression(>%.32s< buf=>%s<) enter\n", ++evallvl, tokenarray[*i].tokpos, buffer));
; 781  : 
; 782  :   /* v2.08: structure changed from for(;;) to while() to increase
; 783  :   * readability and - optionally - handle the second operand differently
; 784  :   * than the first.
; 785  :   */
; 786  : 
; 787  :   if (ERROR == GetAndExpression(hll, i, tokenarray, ilabel, is_true, ptr, hllop)) {

	mov	r15, QWORD PTR hllop$[rsp]
	mov	r13, rcx
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	rbx, r8
	movzx	ebp, BYTE PTR is_true$[rsp]
	mov	rdi, rcx
	mov	QWORD PTR [rsp+48], r15
	mov	r12, rdx
	mov	QWORD PTR [rsp+40], rcx
	xor	r14d, r14d
	mov	rcx, r13
	mov	BYTE PTR [rsp+32], bpl
	call	GetAndExpression
	cmp	eax, -1
	jne	SHORT $LN30@GetExpress

; 788  :     DebugMsg1(("%u GetExpression exit, error\n", evallvl--));
; 789  :     return(ERROR);

	or	rax, -1
	jmp	$LN1@GetExpress
$LN30@GetExpress:

; 790  :   }
; 791  :   while (COP_OR == GetCOp(&tokenarray[*i])) {

	movsxd	rcx, DWORD PTR [r12]
	shl	rcx, 5
	add	rcx, rbx
	call	GetCOp
	cmp	eax, 8
	jne	$LN13@GetExpress
	or	rsi, -1
	npad	9
$LL2@GetExpress:

; 792  : 
; 793  :     uint_32 nlabel;
; 794  :     uint_32 olabel;
; 795  :     char buff[16];
; 796  : 
; 797  :     /* the generated code of last simple expression has to be modified
; 798  :     1. the last jump must be inverted
; 799  :     2. a "is_true" label must be created (it's used to jump "behind" the expr)
; 800  :     3. create a new label
; 801  :     4. the current "false" label must be generated
; 802  : 
; 803  :     if it is a .REPEAT, step 4 is slightly more difficult, since the "false"
; 804  :     label is already "gone":
; 805  :     4a. create a new label
; 806  :     4b. replace the "false" label in the generated code by the new label
; 807  :     */
; 808  : 
; 809  :     (*i)++;

	inc	DWORD PTR [r12]

; 810  :     DebugMsg1(("%u GetExpression: ||-operator found, is_true=%u, lastjmp=%s\n", evallvl, is_true, hllop->lastjmp ? hllop->lastjmp : "NULL"));
; 811  : 
; 812  :     if (is_true == FALSE) {

	test	bpl, bpl
	jne	$LN11@GetExpress

; 813  :       if (hllop->lastjmp) {

	mov	rbx, QWORD PTR [r15]
	test	rbx, rbx
	je	$LN42@GetExpress

; 814  :         char *p = hllop->lastjmp;
; 815  :         InvertJump(p);           /* step 1 */

	mov	rcx, rbx
	call	InvertJump

; 816  :         if (truelabel == 0)      /* step 2 */

	test	r14d, r14d
	jne	SHORT $LN7@GetExpress

; 817  :           truelabel = GetHllLabel();

	mov	r14d, DWORD PTR ModuleInfo+352
	inc	r14d
	mov	DWORD PTR ModuleInfo+352, r14d
$LN7@GetExpress:

; 818  :         if (*p) { /* v2.11: there might be a 0 at lastjmp */

	cmp	BYTE PTR [rbx], 0
	je	SHORT $LN8@GetExpress

; 819  :           p += 4;                /* skip 'jcc ' or 'jmp ' */
; 820  :           GetLabelStr(truelabel, p);

	mov	r8d, r14d
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR [rbx+4]
	call	sprintf

; 821  :           strcat(p, EOLSTR);

	sub	rbx, -3
$LL40@GetExpress:
	cmp	BYTE PTR [rbx+1], 0
	lea	rbx, QWORD PTR [rbx+1]
	jne	SHORT $LL40@GetExpress
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG11333
	npad	10
$LL41@GetExpress:
	movzx	eax, BYTE PTR [r15+rcx]
	mov	BYTE PTR [rbx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL41@GetExpress
	mov	r15, QWORD PTR hllop$[rsp]
$LN8@GetExpress:

; 822  :         }
; 823  :         /* v2.08: if-block added */
; 824  :         if (hllop->lasttruelabel)

	mov	edx, DWORD PTR [r15+8]
	test	edx, edx
	je	SHORT $LN9@GetExpress

; 825  :           ReplaceLabel(ptr, hllop->lasttruelabel, truelabel);

	mov	r8d, r14d
	mov	rcx, rdi
	call	ReplaceLabel
$LN9@GetExpress:

; 826  :         DebugMsg1(("%u GetExpression: jmp inverted, dest changed >%s<\n", evallvl, ptr));
; 827  :         hllop->lastjmp = NULL;
; 828  : 
; 829  :         nlabel = GetHllLabel();  /* step 3 */
; 830  :         olabel = GetLabel(hll, ilabel);

	movsxd	rax, DWORD PTR ilabel$[rsp]
	mov	QWORD PTR [r15], 0
	mov	ebx, DWORD PTR ModuleInfo+352
	inc	ebx
	mov	DWORD PTR ModuleInfo+352, ebx

; 831  :         if (hll->cmd == HLL_REPEAT) {

	cmp	DWORD PTR [r13+104], 2
	mov	ebp, DWORD PTR [r13+rax*4+36]
	jne	SHORT $LN10@GetExpress

; 832  :           ReplaceLabel(buffer, olabel, nlabel);

	mov	rcx, QWORD PTR buffer$[rsp]
	mov	r8d, ebx
	mov	edx, ebp
	call	ReplaceLabel

; 833  :           sprintf(ptr + strlen(ptr), "%s" LABELQUAL EOLSTR, GetLabelStr(nlabel, buff));

	mov	r8d, ebx
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$1[rsp]
	call	sprintf
	mov	rcx, rsi
	npad	3
$LL39@GetExpress:
	inc	rcx
	cmp	BYTE PTR [rdi+rcx], 0
	jne	SHORT $LL39@GetExpress
	add	rcx, rdi
	lea	r8, QWORD PTR buff$1[rsp]
	lea	rdx, OFFSET FLAT:$SG11337
	call	sprintf

; 834  :         }

	jmp	SHORT $LN46@GetExpress
$LN10@GetExpress:

; 835  :         else {
; 836  :           sprintf(ptr + strlen(ptr), "%s" LABELQUAL EOLSTR, GetLabelStr(olabel, buff));

	mov	r8d, ebp
	lea	rdx, OFFSET FLAT:$SG11118
	lea	rcx, QWORD PTR buff$1[rsp]
	call	sprintf
	mov	rcx, rsi
$LL38@GetExpress:
	inc	rcx
	cmp	BYTE PTR [rdi+rcx], 0
	jne	SHORT $LL38@GetExpress
	add	rcx, rdi
	lea	r8, QWORD PTR buff$1[rsp]
	lea	rdx, OFFSET FLAT:$SG11338
	call	sprintf

; 837  :           ReplaceLabel(buffer, olabel, nlabel);

	mov	rcx, QWORD PTR buffer$[rsp]
	mov	r8d, ebx
	mov	edx, ebp
	call	ReplaceLabel
$LN46@GetExpress:
	movzx	ebp, BYTE PTR is_true$[rsp]
$LN42@GetExpress:
	mov	rbx, QWORD PTR tokenarray$[rsp]
$LN11@GetExpress:

; 838  :         }
; 839  :         DebugMsg1(("%u GetExpression: dest changed, label added >%s<\n", evallvl, ptr));
; 840  :       }
; 841  :     }
; 842  :     ptr += strlen(ptr);

	mov	rax, rsi
	npad	8
$LL37@GetExpress:
	inc	rax
	cmp	BYTE PTR [rdi+rax], 0
	jne	SHORT $LL37@GetExpress

; 843  :     hllop->lasttruelabel = 0; /* v2.08 */
; 844  :     if (ERROR == GetAndExpression(hll, i, tokenarray, ilabel, is_true, ptr, hllop)) {

	mov	r9d, DWORD PTR ilabel$[rsp]
	add	rdi, rax
	mov	QWORD PTR [rsp+48], r15
	mov	r8, rbx
	mov	QWORD PTR [rsp+40], rdi
	mov	rdx, r12
	mov	rcx, r13
	mov	BYTE PTR [rsp+32], bpl
	mov	DWORD PTR [r15+8], 0
	call	GetAndExpression
	cmp	eax, -1
	je	$LN31@GetExpress

; 790  :   }
; 791  :   while (COP_OR == GetCOp(&tokenarray[*i])) {

	movsxd	rcx, DWORD PTR [r12]
	shl	rcx, 5
	add	rcx, rbx
	call	GetCOp
	cmp	eax, 8
	je	$LL2@GetExpress

; 847  :     }
; 848  :   }
; 849  :   if (truelabel > 0) {

	test	r14d, r14d
	je	$LN13@GetExpress

; 850  :     /* v2.08: this is needed, but ober-hackish. to be improved... */
; 851  :     if (hllop->lastjmp && hllop->lasttruelabel) {

	cmp	QWORD PTR [r15], 0
	je	SHORT $LL14@GetExpress
	mov	edx, DWORD PTR [r15+8]
	test	edx, edx
	je	SHORT $LL14@GetExpress

; 852  :       DebugMsg1(("%u GetExpression: suppressed ReplaceLabel %u -> %u, lastjmp=%s\n", evallvl, hllop->lasttruelabel, truelabel, hllop->lastjmp));
; 853  :       ReplaceLabel(ptr, hllop->lasttruelabel, truelabel);

	mov	r8d, r14d
	mov	rcx, rdi
	call	ReplaceLabel

; 854  :       *(strchr(hllop->lastjmp, EOLCHAR) + 1) = NULLC;

	mov	rcx, QWORD PTR [r15]
	mov	edx, 10
	call	strchr
	mov	BYTE PTR [rax+1], 0
	npad	2
$LL14@GetExpress:

; 855  :     }
; 856  :     ptr += strlen(ptr);

	inc	rsi
	cmp	BYTE PTR [rdi+rsi], 0
	jne	SHORT $LL14@GetExpress
	add	rdi, rsi

; 857  :     GetLabelStr(truelabel, ptr);

	lea	rdx, OFFSET FLAT:$SG11118
	mov	rcx, rdi
	mov	r8d, r14d
	call	sprintf

; 858  :     strcat(ptr, LABELQUAL EOLSTR);

	dec	rdi
$LL34@GetExpress:
	cmp	BYTE PTR [rdi+1], 0
	lea	rdi, QWORD PTR [rdi+1]
	jne	SHORT $LL34@GetExpress
	lea	rdx, OFFSET FLAT:$SG11342
	xor	ecx, ecx
	npad	12
$LL35@GetExpress:
	movzx	eax, BYTE PTR [rdx+rcx]
	mov	BYTE PTR [rdi+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL35@GetExpress

; 859  :     DebugMsg1(("%u GetExpression: label added >%s<\n", evallvl, ptr));
; 860  :     hllop->lasttruelabel = truelabel; /* v2.08 */

	mov	DWORD PTR [r15+8], r14d
$LN13@GetExpress:

; 861  :   }
; 862  :   DebugMsg1(("%u GetExpression exit\n", evallvl--));
; 863  :   return(NOT_ERROR);

	xor	eax, eax
$LN1@GetExpress:

; 864  : }

	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN31@GetExpress:

; 845  :       DebugMsg1(("%u GetExpression exit, error\n", evallvl--));
; 846  :       return(ERROR);

	mov	eax, esi
	jmp	SHORT $LN1@GetExpress
GetExpression ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
HllCheckOpen PROC

; 2414 :   if (HllStack) {

	cmp	QWORD PTR ModuleInfo+224, 0
	je	SHORT $LN2@HllCheckOp

; 2415 :     //EmitErr( BLOCK_NESTING_ERROR, ".if-.repeat-.while" );
; 2416 :     EmitErr(UNMATCHED_BLOCK_NESTING, ".if-.repeat-.while");

	lea	rdx, OFFSET FLAT:$SG12205
	mov	ecx, 142				; 0000008eH
	jmp	EmitErr
$LN2@HllCheckOp:

; 2417 :   }
; 2418 :   DebugMsg(("HllCheckOpen: allocated items:%u, reused items:%u, .while cond-blocks/bytes:%u/%u\n", cntAlloc, cntReused, cntCond, cntCondBytes));
; 2419 : }

	ret	0
HllCheckOpen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
pass$ = 8
HllInit	PROC

; 2442 :   //if ( pass == PASS_1 )
; 2443 :   //    HllFree = NULL;
; 2444 : 
; 2445 :   //HllStack = NULL; /* empty stack of open hll directives */
; 2446 :   ModuleInfo.hll_label = 0; /* init hll label counter */

	mov	DWORD PTR ModuleInfo+352, 0

; 2447 : #ifdef DEBUG_OUT
; 2448 :   evallvl = 0;
; 2449 :   if (pass == PASS_1) {
; 2450 :     cntAlloc = 0;
; 2451 :     cntReused = 0;
; 2452 :     cntCond = 0;
; 2453 :     cntCondBytes = 0;
; 2454 :   }
; 2455 : #endif
; 2456 :   return;
; 2457 : }

	ret	0
HllInit	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rdi, rcx

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rbx
	mov	QWORD PTR [rsp+40], rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], 0
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf
	test	eax, eax
	cmovs	eax, ebx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbx
	mov	r9, rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, rbx
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf

; 1459 :     #pragma warning(pop)
; 1460 : }

	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ebx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_Locale$ = 88
_ArgList$ = 96
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR _ArgList$[rsp]
	or	rcx, 1
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rbx
	call	__stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;
; 1391 : }

	mov	rbx, QWORD PTR [rsp+64]
	or	ecx, -1
	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ecx
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
