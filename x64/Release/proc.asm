; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	stackreg
_DATA	SEGMENT
COMM	procidx:DWORD
COMM	ProcStatus:DWORD
COMM	StackAdj:DWORD
COMM	StackAdjHigh:DWORD
_DATA	ENDS
_BSS	SEGMENT
$SG12544 DB	01H DUP (?)
$SG11600 DB	01H DUP (?)
$SG11630 DB	01H DUP (?)
$SG11633 DB	01H DUP (?)
$SG11652 DB	01H DUP (?)
$SG11774 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG12108 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	CurrProc:QWORD
COMM	sym_ReservedStack:QWORD
_DATA	ENDS
CONST	SEGMENT
fastcall_tab DQ	FLAT:ms32_pcheck
	DQ	FLAT:ms32_return
	DQ	FLAT:watc_pcheck
	DQ	FLAT:watc_return
	DQ	FLAT:ms64_pcheck
	DQ	FLAT:ms64_return
stackreg DD	0dH
	DD	015H
	DD	077H
	ORG $+4
fmtstk0	DQ	FLAT:$SG11330
	DQ	FLAT:$SG11331
fmtstk1	DQ	FLAT:$SG11333
	DQ	FLAT:$SG11334
CONST	ENDS
_DATA	SEGMENT
$SG12288 DB	'rep stosb', 00H
	ORG $+2
$SG12289 DB	'pop %r', 00H
	ORG $+1
$SG12290 DB	'pop %r', 00H
	ORG $+1
$SG12301 DB	'%r', 00H
	ORG $+1
$SG12295 DB	'vmovdqa [%r+%u+%s], %r', 00H
	ORG $+1
$SG12297 DB	'%r %r, %u+%s', 00H
	ORG $+3
$SG12298 DB	'vmovdqa [%r+%u], %r', 00H
$SG11376 DB	'::', 00H
	ORG $+1
$SG12300 DB	'%r %r, %u', 00H
	ORG $+2
$SG11379 DB	'%s::%s', 00H
	ORG $+1
$SG11933 DB	'dw', 00H
	ORG $+1
$SG12327 DB	'push %r', 00H
$SG12328 DB	'mov %r, %r', 00H
	ORG $+1
$SG11935 DB	',', 00H
	ORG $+2
$SG12332 DB	'push %r', 00H
$SG12333 DB	'sub %r, %d + %s', 00H
$SG12338 DB	'add %r, %d', 00H
	ORG $+1
$SG11938 DB	'dw', 00H
	ORG $+1
$SG12339 DB	'sub %r, %d', 00H
	ORG $+1
$SG12286 DB	'cld', 00H
$SG12341 DB	'push %r', 00H
$SG12342 DB	'mov %r, %s', 00H
	ORG $+5
$SG12343 DB	'mov %r, %r', 00H
	ORG $+5
$SG12345 DB	'push %r', 00H
$SG11330 DB	'sub %r, %d', 00H
	ORG $+1
$SG11331 DB	'%r %d', 00H
	ORG $+6
$SG11333 DB	'sub %r, %d + %s', 00H
$SG11334 DB	'%r %d + %s', 00H
	ORG $+1
$SG11388 DB	'%d%c', 00H
	ORG $+3
$SG11406 DB	'%d%c', 00H
	ORG $+3
$SG12437 DB	'pop %r', 00H
	ORG $+1
$SG12439 DB	'pop %r', 00H
	ORG $+5
$SG12467 DB	'vmovdqa %r, [%r + %u + %s]', 00H
	ORG $+5
$SG12468 DB	'vmovdqa %r, [%r + %u]', 00H
	ORG $+2
$SG12474 DB	'add %r, %d + %s', 00H
$SG12475 DB	'add %r, %d + %s', 00H
$SG12476 DB	'add %r, %d', 00H
	ORG $+5
$SG12485 DB	'mov %r, [%r+%u]', 00H
$SG12488 DB	'pop %r', 00H
	ORG $+1
$SG12498 DB	'add %r, %d + %s', 00H
$SG12500 DB	'pop %r', 00H
	ORG $+1
$SG12506 DB	'leave', 00H
	ORG $+2
$SG12511 DB	'add %r, %d', 00H
	ORG $+5
$SG12513 DB	'mov %r, %r', 00H
	ORG $+1
$SG12514 DB	'pop %r', 00H
	ORG $+5
$SG12545 DB	'%s, 0%XH, 0%XH, 0%XH, <<%s>>, <%s>', 00H
	ORG $+5
$SG12547 DB	'option epilogue:none', 0aH, 00H
	ORG $+2
$SG12578 DB	'%d%c', 00H
	ORG $+3
$SG12582 DB	'%d%c', 00H
	ORG $+3
$SG11728 DB	'PRIVATE', 00H
$SG11733 DB	'PUBLIC', 00H
	ORG $+1
$SG11735 DB	'EXPORT', 00H
	ORG $+1
$SG11747 DB	'FORCEFRAME', 00H
	ORG $+1
$SG11750 DB	'LOADDS', 00H
	ORG $+1
$SG11763 DB	'USES', 00H
	ORG $+3
$SG11922 DB	'.xdata', 00H
	ORG $+1
$SG11927 DB	'%s %r', 00H
	ORG $+6
$SG11928 DB	'%s %r align(%u) flat read ''DATA''', 00H
	ORG $+7
$SG11929 DB	'$xdatasym label near', 00H
	ORG $+3
$SG11931 DB	'db %ut + (0%xh shl 3), %ut, %ut, 0%xh + (0%xh shl 4)', 00H
	ORG $+3
$SG11934 DB	'%s 0%xh', 00H
$SG11939 DB	'%r 4', 00H
	ORG $+3
$SG11941 DB	'dd %r %s', 00H
	ORG $+3
$SG11942 DB	'%r 8', 00H
	ORG $+3
$SG11943 DB	'%s %r', 00H
	ORG $+2
$SG11946 DB	'.pdata', 00H
	ORG $+5
$SG11947 DB	'.pdata$%04u', 00H
$SG11950 DB	'%s %r', 00H
	ORG $+6
$SG11951 DB	'%s %r align(%u) flat read ''DATA''', 00H
	ORG $+7
$SG11952 DB	'dd %r %s, %r %s+0%xh, %r $xdatasym+0%xh', 00H
$SG11953 DB	'%s %r', 00H
	ORG $+2
$SG12039 DB	'CODE', 00H
	ORG $+3
$SG12105 DB	'option prologue:none', 0aH, 00H
	ORG $+2
$SG12109 DB	' (%s, 0%XH, 0%XH, 0%XH, <<%s>>, <%s>)', 00H
	ORG $+2
$SG12132 DB	'movq [%r+%u], %r', 00H
	ORG $+7
$SG12134 DB	'mov [%r+%u], %r', 00H
$SG12135 DB	'mov [%r+%u], %r', 00H
$SG12140 DB	'movq [%r+%u], %r', 00H
	ORG $+7
$SG12141 DB	'mov [%r+%u], %r', 00H
$SG12142 DB	'mov [%r+%u], %r', 00H
$SG12202 DB	'mov [%r+%u], %r', 00H
$SG12203 DB	'%r %r, %u', 00H
	ORG $+6
$SG12236 DB	'push %r', 00H
$SG12237 DB	'%r %r', 00H
	ORG $+2
$SG12238 DB	'mov %r, %r', 00H
	ORG $+5
$SG12239 DB	'%r %r, 0', 00H
	ORG $+7
$SG12247 DB	'push %r', 00H
$SG12249 DB	'%r %r', 00H
	ORG $+2
$SG12253 DB	'push %r', 00H
$SG12255 DB	'%r %r', 00H
	ORG $+2
$SG12278 DB	'mov %r, %u', 00H
	ORG $+1
$SG12279 DB	'dec %r', 00H
	ORG $+5
$SG12280 DB	'mov byte ptr [%r + %r], 0', 00H
	ORG $+6
$SG12281 DB	'dw 0F875h', 00H
	ORG $+6
$SG12282 DB	'push %r', 00H
$SG12283 DB	'push %r', 00H
$SG12284 DB	'xor %r, %r', 00H
	ORG $+5
$SG12285 DB	'mov %r, %u', 00H
	ORG $+5
$SG12287 DB	'lea %r, [%r+16]', 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	printf
PUBLIC	sprintf
PUBLIC	ParseProc
PUBLIC	CreateProc
PUBLIC	DeleteProc
PUBLIC	CopyPrototype
PUBLIC	RetInstr
PUBLIC	write_prologue
PUBLIC	ProcInit
PUBLIC	ProcCheckOpen
PUBLIC	LocalDir
PUBLIC	UpdateStackBase
PUBLIC	UpdateProcStatus
PUBLIC	ProcDir
PUBLIC	EndpDir
PUBLIC	ExcFrameDirective
EXTRN	__acrt_iob_func:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	atoi:PROC
EXTRN	_stricmp:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	AddLinnumDataRef:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymAlloc:PROC
EXTRN	SymFree:PROC
EXTRN	SymCreate:PROC
EXTRN	SymLCreate:PROC
EXTRN	SymAddLocal:PROC
EXTRN	SymFind:PROC
EXTRN	SymClearLocal:PROC
EXTRN	SymSetLocal:PROC
EXTRN	SymGetLocal:PROC
EXTRN	SizeFromMemtype:PROC
EXTRN	SizeFromRegister:PROC
EXTRN	GetLangType:PROC
EXTRN	sym_add_table:PROC
EXTRN	sym_remove_table:PROC
EXTRN	sym_ext2int:PROC
EXTRN	ParseLine:PROC
EXTRN	SetSymSegOfs:PROC
EXTRN	GetSymOfssize:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	GetSegIdx:PROC
EXTRN	SimGetSegName:PROC
EXTRN	AddPublicData:PROC
EXTRN	BackPatch:PROC
EXTRN	GetLineNumber:PROC
EXTRN	get_curr_srcfile:PROC
EXTRN	AddLineQueue:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	RunLineQueue:PROC
EXTRN	Tokenize:PROC
EXTRN	EvalOperand:PROC
EXTRN	EmitConstError:PROC
EXTRN	GetQualifiedType:PROC
EXTRN	RunMacro:PROC
EXTRN	SkipSavedState:PROC
EXTRN	LstWrite:PROC
EXTRN	LstSetPosition:PROC
EXTRN	AlignCurrOffset:PROC
EXTRN	GetResWName:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SymCmpFunc:QWORD
EXTRN	SymTables:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	LineStoreCurr:QWORD
EXTRN	UseSavedState:BYTE
EXTRN	szDgroup:BYTE
EXTRN	list_pos:DWORD
EXTRN	__ImageBase:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	8

ProcStack DQ	01H DUP (?)
endprolog_found DB 01H DUP (?)
	ALIGN	4

unw_segs_defined DB 01H DUP (?)
	ALIGN	4

unw_info DD	01H DUP (?)
unw_code DW	0102H DUP (?)
?regname@?1??watc_pcheck@@9@9 DB 040H DUP (?)		; `watc_pcheck'::`2'::regname
?regist@?1??watc_pcheck@@9@9 DB 020H DUP (?)		; `watc_pcheck'::`2'::regist
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+83
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN8
	DD	imagerel $LN8+90
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$ParseProc DD imagerel $LN128
	DD	imagerel $LN128+1925
	DD	imagerel $unwind$ParseProc
$pdata$CreateProc DD imagerel $LN22
	DD	imagerel $LN22+302
	DD	imagerel $unwind$CreateProc
$pdata$DeleteProc DD imagerel $LN15
	DD	imagerel $LN15+23
	DD	imagerel $unwind$DeleteProc
$pdata$0$DeleteProc DD imagerel $LN15+23
	DD	imagerel $LN15+54
	DD	imagerel $chain$0$DeleteProc
$pdata$1$DeleteProc DD imagerel $LN15+54
	DD	imagerel $LN15+59
	DD	imagerel $chain$1$DeleteProc
$pdata$CopyPrototype DD imagerel $LN21
	DD	imagerel $LN21+302
	DD	imagerel $unwind$CopyPrototype
$pdata$RetInstr DD imagerel $LN36
	DD	imagerel $LN36+573
	DD	imagerel $unwind$RetInstr
$pdata$write_prologue DD imagerel $LN14
	DD	imagerel $LN14+198
	DD	imagerel $unwind$write_prologue
$pdata$ProcCheckOpen DD imagerel $LN60
	DD	imagerel $LN60+20
	DD	imagerel $unwind$ProcCheckOpen
$pdata$2$ProcCheckOpen DD imagerel $LN60+20
	DD	imagerel $LN60+544
	DD	imagerel $chain$2$ProcCheckOpen
$pdata$3$ProcCheckOpen DD imagerel $LN60+544
	DD	imagerel $LN60+549
	DD	imagerel $chain$3$ProcCheckOpen
$pdata$ms32_pcheck DD imagerel ms32_pcheck
	DD	imagerel ms32_pcheck+240
	DD	imagerel $unwind$ms32_pcheck
$pdata$watc_pcheck DD imagerel watc_pcheck
	DD	imagerel watc_pcheck+73
	DD	imagerel $unwind$watc_pcheck
$pdata$0$watc_pcheck DD imagerel watc_pcheck+73
	DD	imagerel watc_pcheck+211
	DD	imagerel $chain$0$watc_pcheck
$pdata$2$watc_pcheck DD imagerel watc_pcheck+211
	DD	imagerel watc_pcheck+234
	DD	imagerel $chain$2$watc_pcheck
$pdata$6$watc_pcheck DD imagerel watc_pcheck+234
	DD	imagerel watc_pcheck+255
	DD	imagerel $chain$6$watc_pcheck
$pdata$7$watc_pcheck DD imagerel watc_pcheck+255
	DD	imagerel watc_pcheck+560
	DD	imagerel $chain$7$watc_pcheck
$pdata$8$watc_pcheck DD imagerel watc_pcheck+560
	DD	imagerel watc_pcheck+672
	DD	imagerel $chain$8$watc_pcheck
$pdata$9$watc_pcheck DD imagerel watc_pcheck+672
	DD	imagerel watc_pcheck+715
	DD	imagerel $chain$9$watc_pcheck
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pushitem DD imagerel pushitem
	DD	imagerel pushitem+50
	DD	imagerel $unwind$pushitem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$push_proc DD imagerel push_proc
	DD	imagerel push_proc+60
	DD	imagerel $unwind$push_proc
pdata	ENDS
pdata	SEGMENT
$pdata$LocalDir DD imagerel $LN66
	DD	imagerel $LN66+74
	DD	imagerel $unwind$LocalDir
$pdata$2$LocalDir DD imagerel $LN66+74
	DD	imagerel $LN66+759
	DD	imagerel $chain$2$LocalDir
$pdata$4$LocalDir DD imagerel $LN66+759
	DD	imagerel $LN66+778
	DD	imagerel $chain$4$LocalDir
$pdata$5$LocalDir DD imagerel $LN66+778
	DD	imagerel $LN66+798
	DD	imagerel $chain$5$LocalDir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ParseParams DD imagerel ParseParams
	DD	imagerel ParseParams+100
	DD	imagerel $unwind$ParseParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ParseParams DD imagerel ParseParams+100
	DD	imagerel ParseParams+157
	DD	imagerel $chain$1$ParseParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ParseParams DD imagerel ParseParams+157
	DD	imagerel ParseParams+190
	DD	imagerel $chain$2$ParseParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ParseParams DD imagerel ParseParams+190
	DD	imagerel ParseParams+1640
	DD	imagerel $chain$3$ParseParams
pdata	ENDS
pdata	SEGMENT
$pdata$ProcDir DD imagerel $LN47
	DD	imagerel $LN47+66
	DD	imagerel $unwind$ProcDir
$pdata$1$ProcDir DD imagerel $LN47+66
	DD	imagerel $LN47+205
	DD	imagerel $chain$1$ProcDir
$pdata$3$ProcDir DD imagerel $LN47+205
	DD	imagerel $LN47+329
	DD	imagerel $chain$3$ProcDir
$pdata$4$ProcDir DD imagerel $LN47+329
	DD	imagerel $LN47+357
	DD	imagerel $chain$4$ProcDir
$pdata$6$ProcDir DD imagerel $LN47+357
	DD	imagerel $LN47+982
	DD	imagerel $chain$6$ProcDir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$WriteSEHData DD imagerel WriteSEHData
	DD	imagerel WriteSEHData+34
	DD	imagerel $unwind$WriteSEHData
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$WriteSEHData DD imagerel WriteSEHData+34
	DD	imagerel WriteSEHData+232
	DD	imagerel $chain$1$WriteSEHData
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$WriteSEHData DD imagerel WriteSEHData+232
	DD	imagerel WriteSEHData+394
	DD	imagerel $chain$2$WriteSEHData
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$WriteSEHData DD imagerel WriteSEHData+394
	DD	imagerel WriteSEHData+790
	DD	imagerel $chain$3$WriteSEHData
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$WriteSEHData DD imagerel WriteSEHData+790
	DD	imagerel WriteSEHData+799
	DD	imagerel $chain$4$WriteSEHData
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetLocalOffsets DD imagerel SetLocalOffsets
	DD	imagerel SetLocalOffsets+20
	DD	imagerel $unwind$SetLocalOffsets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$SetLocalOffsets DD imagerel SetLocalOffsets+20
	DD	imagerel SetLocalOffsets+139
	DD	imagerel $chain$2$SetLocalOffsets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$SetLocalOffsets DD imagerel SetLocalOffsets+139
	DD	imagerel SetLocalOffsets+196
	DD	imagerel $chain$3$SetLocalOffsets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$SetLocalOffsets DD imagerel SetLocalOffsets+196
	DD	imagerel SetLocalOffsets+321
	DD	imagerel $chain$4$SetLocalOffsets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$SetLocalOffsets DD imagerel SetLocalOffsets+321
	DD	imagerel SetLocalOffsets+472
	DD	imagerel $chain$5$SetLocalOffsets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$SetLocalOffsets DD imagerel SetLocalOffsets+472
	DD	imagerel SetLocalOffsets+729
	DD	imagerel $chain$6$SetLocalOffsets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ProcFini DD imagerel ProcFini
	DD	imagerel ProcFini+11
	DD	imagerel $unwind$ProcFini
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ProcFini DD imagerel ProcFini+11
	DD	imagerel ProcFini+92
	DD	imagerel $chain$0$ProcFini
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ProcFini DD imagerel ProcFini+92
	DD	imagerel ProcFini+199
	DD	imagerel $chain$1$ProcFini
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ProcFini DD imagerel ProcFini+199
	DD	imagerel ProcFini+363
	DD	imagerel $chain$2$ProcFini
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ProcFini DD imagerel ProcFini+363
	DD	imagerel ProcFini+498
	DD	imagerel $chain$3$ProcFini
pdata	ENDS
pdata	SEGMENT
$pdata$EndpDir DD imagerel $LN9
	DD	imagerel $LN9+125
	DD	imagerel $unwind$EndpDir
$pdata$ExcFrameDirective DD imagerel $LN81
	DD	imagerel $LN81+162
	DD	imagerel $unwind$ExcFrameDirective
$pdata$4$ExcFrameDirective DD imagerel $LN81+162
	DD	imagerel $LN81+943
	DD	imagerel $chain$4$ExcFrameDirective
$pdata$6$ExcFrameDirective DD imagerel $LN81+943
	DD	imagerel $LN81+1496
	DD	imagerel $chain$6$ExcFrameDirective
$pdata$7$ExcFrameDirective DD imagerel $LN81+1496
	DD	imagerel $LN81+1552
	DD	imagerel $chain$7$ExcFrameDirective
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$write_userdef_prologue DD imagerel write_userdef_prologue
	DD	imagerel write_userdef_prologue+220
	DD	imagerel $unwind$write_userdef_prologue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$write_userdef_prologue DD imagerel write_userdef_prologue+220
	DD	imagerel write_userdef_prologue+263
	DD	imagerel $chain$4$write_userdef_prologue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$write_userdef_prologue DD imagerel write_userdef_prologue+263
	DD	imagerel write_userdef_prologue+344
	DD	imagerel $chain$5$write_userdef_prologue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$write_userdef_prologue DD imagerel write_userdef_prologue+344
	DD	imagerel write_userdef_prologue+538
	DD	imagerel $chain$6$write_userdef_prologue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$write_userdef_prologue DD imagerel write_userdef_prologue+538
	DD	imagerel write_userdef_prologue+625
	DD	imagerel $chain$7$write_userdef_prologue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$win64_SaveRegParams DD imagerel win64_SaveRegParams
	DD	imagerel win64_SaveRegParams+362
	DD	imagerel $unwind$win64_SaveRegParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$win64_StoreRegHome DD imagerel win64_StoreRegHome
	DD	imagerel win64_StoreRegHome+42
	DD	imagerel $unwind$win64_StoreRegHome
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$win64_StoreRegHome DD imagerel win64_StoreRegHome+42
	DD	imagerel win64_StoreRegHome+365
	DD	imagerel $chain$1$win64_StoreRegHome
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$win64_StoreRegHome DD imagerel win64_StoreRegHome+365
	DD	imagerel win64_StoreRegHome+490
	DD	imagerel $chain$2$win64_StoreRegHome
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$win64_StoreRegHome DD imagerel win64_StoreRegHome+490
	DD	imagerel win64_StoreRegHome+500
	DD	imagerel $chain$3$win64_StoreRegHome
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$win64_StoreRegHome DD imagerel win64_StoreRegHome+500
	DD	imagerel win64_StoreRegHome+509
	DD	imagerel $chain$4$win64_StoreRegHome
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$write_win64_default_prologue DD imagerel write_win64_default_prologue
	DD	imagerel write_win64_default_prologue+10
	DD	imagerel $unwind$write_win64_default_prologue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$write_win64_default_prologue DD imagerel write_win64_default_prologue+10
	DD	imagerel write_win64_default_prologue+212
	DD	imagerel $chain$3$write_win64_default_prologue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$write_win64_default_prologue DD imagerel write_win64_default_prologue+212
	DD	imagerel write_win64_default_prologue+486
	DD	imagerel $chain$4$write_win64_default_prologue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$write_win64_default_prologue DD imagerel write_win64_default_prologue+486
	DD	imagerel write_win64_default_prologue+545
	DD	imagerel $chain$5$write_win64_default_prologue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$write_win64_default_prologue DD imagerel write_win64_default_prologue+545
	DD	imagerel write_win64_default_prologue+1288
	DD	imagerel $chain$6$write_win64_default_prologue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$write_default_prologue DD imagerel write_default_prologue
	DD	imagerel write_default_prologue+139
	DD	imagerel $unwind$write_default_prologue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$write_default_prologue DD imagerel write_default_prologue+139
	DD	imagerel write_default_prologue+147
	DD	imagerel $chain$0$write_default_prologue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$write_default_prologue DD imagerel write_default_prologue+147
	DD	imagerel write_default_prologue+429
	DD	imagerel $chain$1$write_default_prologue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$write_default_prologue DD imagerel write_default_prologue+429
	DD	imagerel write_default_prologue+557
	DD	imagerel $chain$2$write_default_prologue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$write_default_prologue DD imagerel write_default_prologue+557
	DD	imagerel write_default_prologue+691
	DD	imagerel $chain$3$write_default_prologue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pop_register DD imagerel pop_register
	DD	imagerel pop_register+20
	DD	imagerel $unwind$pop_register
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pop_register DD imagerel pop_register+20
	DD	imagerel pop_register+140
	DD	imagerel $chain$2$pop_register
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$pop_register DD imagerel pop_register+140
	DD	imagerel pop_register+211
	DD	imagerel $chain$4$pop_register
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$pop_register DD imagerel pop_register+211
	DD	imagerel pop_register+216
	DD	imagerel $chain$5$pop_register
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$write_win64_default_epilogue DD imagerel write_win64_default_epilogue
	DD	imagerel write_win64_default_epilogue+6
	DD	imagerel $unwind$write_win64_default_epilogue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$write_win64_default_epilogue DD imagerel write_win64_default_epilogue+6
	DD	imagerel write_win64_default_epilogue+611
	DD	imagerel $chain$4$write_win64_default_epilogue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$write_win64_default_epilogue DD imagerel write_win64_default_epilogue+611
	DD	imagerel write_win64_default_epilogue+652
	DD	imagerel $chain$5$write_win64_default_epilogue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$write_default_epilogue DD imagerel write_default_epilogue
	DD	imagerel write_default_epilogue+393
	DD	imagerel $unwind$write_default_epilogue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$write_userdef_epilogue DD imagerel write_userdef_epilogue
	DD	imagerel write_userdef_epilogue+81
	DD	imagerel $unwind$write_userdef_epilogue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$write_userdef_epilogue DD imagerel write_userdef_epilogue+81
	DD	imagerel write_userdef_epilogue+92
	DD	imagerel $chain$0$write_userdef_epilogue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$write_userdef_epilogue DD imagerel write_userdef_epilogue+92
	DD	imagerel write_userdef_epilogue+211
	DD	imagerel $chain$1$write_userdef_epilogue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$write_userdef_epilogue DD imagerel write_userdef_epilogue+211
	DD	imagerel write_userdef_epilogue+304
	DD	imagerel $chain$3$write_userdef_epilogue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$write_userdef_epilogue DD imagerel write_userdef_epilogue+304
	DD	imagerel write_userdef_epilogue+438
	DD	imagerel $chain$4$write_userdef_epilogue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$write_userdef_epilogue DD imagerel write_userdef_epilogue+438
	DD	imagerel write_userdef_epilogue+515
	DD	imagerel $chain$5$write_userdef_epilogue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$write_userdef_epilogue DD imagerel write_userdef_epilogue+515
	DD	imagerel write_userdef_epilogue+546
	DD	imagerel $chain$6$write_userdef_epilogue
pdata	ENDS
CONST	SEGMENT
ms32_regs16 DD	09H
	DD	0bH
	DD	0cH
	ORG $+4
ms32_regs32 DD	012H
	DD	013H
ms32_maxreg DD	03H
	DD	02H
watc_regs8 DD	01H
	DD	03H
	DD	04H
	DD	02H
watc_regs16 DD	09H
	DD	0bH
	DD	0cH
	DD	0aH
watc_regs32 DD	011H
	DD	013H
	DD	014H
	DD	012H
watc_regs_qw DD	09H
	DD	0cH
	DD	0aH
	DD	0bH
ms64_regs DD	074H
	DD	075H
	DD	07bH
	DD	07cH
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$write_userdef_epilogue DD 021H
	DD	imagerel write_userdef_epilogue
	DD	imagerel write_userdef_epilogue+81
	DD	imagerel $unwind$write_userdef_epilogue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$write_userdef_epilogue DD 021H
	DD	imagerel write_userdef_epilogue+81
	DD	imagerel write_userdef_epilogue+92
	DD	imagerel $chain$0$write_userdef_epilogue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$write_userdef_epilogue DD 021H
	DD	imagerel write_userdef_epilogue+92
	DD	imagerel write_userdef_epilogue+211
	DD	imagerel $chain$1$write_userdef_epilogue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$write_userdef_epilogue DD 041021H
	DD	09f7410H
	DD	09e6408H
	DD	imagerel write_userdef_epilogue+92
	DD	imagerel write_userdef_epilogue+211
	DD	imagerel $chain$1$write_userdef_epilogue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$write_userdef_epilogue DD 020821H
	DD	098f408H
	DD	imagerel write_userdef_epilogue+81
	DD	imagerel write_userdef_epilogue+92
	DD	imagerel $chain$0$write_userdef_epilogue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$write_userdef_epilogue DD 020821H
	DD	0a1d408H
	DD	imagerel write_userdef_epilogue
	DD	imagerel write_userdef_epilogue+81
	DD	imagerel $unwind$write_userdef_epilogue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$write_userdef_epilogue DD 060e01H
	DD	099010eH
	DD	0c005e007H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$write_default_epilogue DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$write_win64_default_epilogue DD 021H
	DD	imagerel write_win64_default_epilogue
	DD	imagerel write_win64_default_epilogue+6
	DD	imagerel $unwind$write_win64_default_epilogue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$write_win64_default_epilogue DD 0a2121H
	DD	06f421H
	DD	077419H
	DD	0c6414H
	DD	0b540dH
	DD	0a3405H
	DD	imagerel write_win64_default_epilogue
	DD	imagerel write_win64_default_epilogue+6
	DD	imagerel $unwind$write_win64_default_epilogue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$write_win64_default_epilogue DD 020601H
	DD	0e0027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$pop_register DD 021H
	DD	imagerel pop_register
	DD	imagerel pop_register+20
	DD	imagerel $unwind$pop_register
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$pop_register DD 060021H
	DD	047400H
	DD	076400H
	DD	063400H
	DD	imagerel pop_register
	DD	imagerel pop_register+20
	DD	imagerel $unwind$pop_register
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pop_register DD 061221H
	DD	047412H
	DD	07640dH
	DD	063405H
	DD	imagerel pop_register
	DD	imagerel pop_register+20
	DD	imagerel $unwind$pop_register
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pop_register DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$write_default_prologue DD 021H
	DD	imagerel write_default_prologue
	DD	imagerel write_default_prologue+139
	DD	imagerel $unwind$write_default_prologue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$write_default_prologue DD 021H
	DD	imagerel write_default_prologue+139
	DD	imagerel write_default_prologue+147
	DD	imagerel $chain$0$write_default_prologue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$write_default_prologue DD 020521H
	DD	07e405H
	DD	imagerel write_default_prologue+139
	DD	imagerel write_default_prologue+147
	DD	imagerel $chain$0$write_default_prologue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$write_default_prologue DD 020521H
	DD	067405H
	DD	imagerel write_default_prologue
	DD	imagerel write_default_prologue+139
	DD	imagerel $unwind$write_default_prologue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$write_default_prologue DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$write_win64_default_prologue DD 060021H
	DD	0e6400H
	DD	0d5400H
	DD	0c3400H
	DD	imagerel write_win64_default_prologue
	DD	imagerel write_win64_default_prologue+10
	DD	imagerel $unwind$write_win64_default_prologue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$write_win64_default_prologue DD 021H
	DD	imagerel write_win64_default_prologue+10
	DD	imagerel write_win64_default_prologue+212
	DD	imagerel $chain$3$write_win64_default_prologue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$write_win64_default_prologue DD 020521H
	DD	06e405H
	DD	imagerel write_win64_default_prologue+10
	DD	imagerel write_win64_default_prologue+212
	DD	imagerel $chain$3$write_win64_default_prologue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$write_win64_default_prologue DD 08ca21H
	DD	0e64caH
	DD	0d54c2H
	DD	0c34baH
	DD	07d405H
	DD	imagerel write_win64_default_prologue
	DD	imagerel write_win64_default_prologue+10
	DD	imagerel $unwind$write_win64_default_prologue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$write_win64_default_prologue DD 040a01H
	DD	0f006720aH
	DD	07002c004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$win64_StoreRegHome DD 021H
	DD	imagerel win64_StoreRegHome
	DD	imagerel win64_StoreRegHome+42
	DD	imagerel $unwind$win64_StoreRegHome
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$win64_StoreRegHome DD 021H
	DD	imagerel win64_StoreRegHome+42
	DD	imagerel win64_StoreRegHome+365
	DD	imagerel $chain$1$win64_StoreRegHome
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$win64_StoreRegHome DD 020521H
	DD	095405H
	DD	imagerel win64_StoreRegHome+42
	DD	imagerel win64_StoreRegHome+365
	DD	imagerel $chain$1$win64_StoreRegHome
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$win64_StoreRegHome DD 040a21H
	DD	0af40aH
	DD	083405H
	DD	imagerel win64_StoreRegHome
	DD	imagerel win64_StoreRegHome+42
	DD	imagerel $unwind$win64_StoreRegHome
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win64_StoreRegHome DD 040901H
	DD	0e0053209H
	DD	060027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win64_SaveRegParams DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$write_userdef_prologue DD 021H
	DD	imagerel write_userdef_prologue
	DD	imagerel write_userdef_prologue+220
	DD	imagerel $unwind$write_userdef_prologue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$write_userdef_prologue DD 021H
	DD	imagerel write_userdef_prologue+220
	DD	imagerel write_userdef_prologue+263
	DD	imagerel $chain$4$write_userdef_prologue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$write_userdef_prologue DD 020821H
	DD	0a17408H
	DD	imagerel write_userdef_prologue+220
	DD	imagerel write_userdef_prologue+263
	DD	imagerel $chain$4$write_userdef_prologue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$write_userdef_prologue DD 041021H
	DD	0a06410H
	DD	09e3408H
	DD	imagerel write_userdef_prologue
	DD	imagerel write_userdef_prologue+220
	DD	imagerel $unwind$write_userdef_prologue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$write_userdef_prologue DD 0a5901H
	DD	098f459H
	DD	099e44dH
	DD	09ad442H
	DD	09b010bH
	DD	05002c004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ProcFini DD 021H
	DD	imagerel ProcFini
	DD	imagerel ProcFini+11
	DD	imagerel $unwind$ProcFini
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ProcFini DD 021H
	DD	imagerel ProcFini+11
	DD	imagerel ProcFini+92
	DD	imagerel $chain$0$ProcFini
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ProcFini DD 020521H
	DD	063405H
	DD	imagerel ProcFini+11
	DD	imagerel ProcFini+92
	DD	imagerel $chain$0$ProcFini
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ProcFini DD 020521H
	DD	047405H
	DD	imagerel ProcFini
	DD	imagerel ProcFini+11
	DD	imagerel $unwind$ProcFini
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ProcFini DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$SetLocalOffsets DD 021H
	DD	imagerel SetLocalOffsets
	DD	imagerel SetLocalOffsets+20
	DD	imagerel $unwind$SetLocalOffsets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$SetLocalOffsets DD 020021H
	DD	086400H
	DD	imagerel SetLocalOffsets
	DD	imagerel SetLocalOffsets+20
	DD	imagerel $unwind$SetLocalOffsets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$SetLocalOffsets DD 021H
	DD	imagerel SetLocalOffsets+20
	DD	imagerel SetLocalOffsets+139
	DD	imagerel $chain$2$SetLocalOffsets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$SetLocalOffsets DD 020421H
	DD	0c404H
	DD	imagerel SetLocalOffsets+20
	DD	imagerel SetLocalOffsets+139
	DD	imagerel $chain$2$SetLocalOffsets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$SetLocalOffsets DD 061e21H
	DD	01741eH
	DD	086416H
	DD	073405H
	DD	imagerel SetLocalOffsets
	DD	imagerel SetLocalOffsets+20
	DD	imagerel $unwind$SetLocalOffsets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetLocalOffsets DD 040a01H
	DD	0f006120aH
	DD	05002e004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$WriteSEHData DD 021H
	DD	imagerel WriteSEHData
	DD	imagerel WriteSEHData+34
	DD	imagerel $unwind$WriteSEHData
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$WriteSEHData DD 021H
	DD	imagerel WriteSEHData+34
	DD	imagerel WriteSEHData+232
	DD	imagerel $chain$1$WriteSEHData
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$WriteSEHData DD 020821H
	DD	01f7408H
	DD	imagerel WriteSEHData+34
	DD	imagerel WriteSEHData+232
	DD	imagerel $chain$1$WriteSEHData
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$WriteSEHData DD 040821H
	DD	01e5408H
	DD	01c3404H
	DD	imagerel WriteSEHData
	DD	imagerel WriteSEHData+34
	DD	imagerel $unwind$WriteSEHData
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WriteSEHData DD 030b01H
	DD	01a010bH
	DD	06004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ParseParams DD 040021H
	DD	0bc400H
	DD	0c6400H
	DD	imagerel ParseParams
	DD	imagerel ParseParams+100
	DD	imagerel $unwind$ParseParams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ParseParams DD 021H
	DD	imagerel ParseParams
	DD	imagerel ParseParams+100
	DD	imagerel $unwind$ParseParams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ParseParams DD 041421H
	DD	0bc414H
	DD	0c6405H
	DD	imagerel ParseParams
	DD	imagerel ParseParams+100
	DD	imagerel $unwind$ParseParams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ParseParams DD 071e01H
	DD	0f017c21eH
	DD	0d013e015H
	DD	030107011H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$push_proc DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pushitem DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
xdata	SEGMENT
$unwind$ParseProc DD 0aea01H
	DD	0ee4eaH
	DD	0f013321aH
	DD	0c00fd011H
	DD	0600c700dH
	DD	0500a300bH
$unwind$CreateProc DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$DeleteProc DD 010401H
	DD	04204H
$chain$0$DeleteProc DD 020521H
	DD	043405H
	DD	imagerel $LN15
	DD	imagerel $LN15+23
	DD	imagerel $unwind$DeleteProc
$chain$1$DeleteProc DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+23
	DD	imagerel $unwind$DeleteProc
$unwind$CopyPrototype DD 062a01H
	DD	07642aH
	DD	063425H
	DD	070023206H
$unwind$RetInstr DD 0b1d01H
	DD	089741dH
	DD	088641dH
	DD	087541dH
	DD	086341dH
	DD	084011dH
	DD	0e016H
$unwind$write_prologue DD 020601H
	DD	030023206H
$unwind$ProcCheckOpen DD 010401H
	DD	04204H
$chain$2$ProcCheckOpen DD 061121H
	DD	047411H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN60
	DD	imagerel $LN60+20
	DD	imagerel $unwind$ProcCheckOpen
$chain$3$ProcCheckOpen DD 021H
	DD	imagerel $LN60
	DD	imagerel $LN60+20
	DD	imagerel $unwind$ProcCheckOpen
$unwind$ms32_pcheck DD 040a01H
	DD	0a340aH
	DD	07006720aH
$unwind$watc_pcheck DD 050b01H
	DD	0d007420bH
	DD	05003c005H
	DD	03002H
$chain$0$watc_pcheck DD 020521H
	DD	0ce405H
	DD	imagerel watc_pcheck
	DD	imagerel watc_pcheck+73
	DD	imagerel $unwind$watc_pcheck
$chain$2$watc_pcheck DD 020021H
	DD	0ce400H
	DD	imagerel watc_pcheck
	DD	imagerel watc_pcheck+73
	DD	imagerel $unwind$watc_pcheck
$chain$6$watc_pcheck DD 060e21H
	DD	0b740eH
	DD	0a6405H
	DD	0ce400H
	DD	imagerel watc_pcheck
	DD	imagerel watc_pcheck+73
	DD	imagerel $unwind$watc_pcheck
$chain$7$watc_pcheck DD 020521H
	DD	04f405H
	DD	imagerel watc_pcheck+234
	DD	imagerel watc_pcheck+255
	DD	imagerel $chain$6$watc_pcheck
$chain$8$watc_pcheck DD 021H
	DD	imagerel watc_pcheck+234
	DD	imagerel watc_pcheck+255
	DD	imagerel $chain$6$watc_pcheck
$chain$9$watc_pcheck DD 040021H
	DD	0b7400H
	DD	0ce400H
	DD	imagerel watc_pcheck
	DD	imagerel watc_pcheck+73
	DD	imagerel $unwind$watc_pcheck
$unwind$LocalDir DD 041201H
	DD	0190112H
	DD	050057006H
$chain$2$LocalDir DD 064321H
	DD	01d3443H
	DD	018e414H
	DD	01e6408H
	DD	imagerel $LN66
	DD	imagerel $LN66+74
	DD	imagerel $unwind$LocalDir
$chain$4$LocalDir DD 060021H
	DD	018e400H
	DD	01e6400H
	DD	01d3400H
	DD	imagerel $LN66
	DD	imagerel $LN66+74
	DD	imagerel $unwind$LocalDir
$chain$5$LocalDir DD 021H
	DD	imagerel $LN66
	DD	imagerel $LN66+74
	DD	imagerel $unwind$LocalDir
$unwind$ProcDir DD 020601H
	DD	050025206H
$chain$1$ProcDir DD 041121H
	DD	096411H
	DD	083405H
	DD	imagerel $LN47
	DD	imagerel $LN47+66
	DD	imagerel $unwind$ProcDir
$chain$3$ProcDir DD 040d21H
	DD	0be40dH
	DD	0a7405H
	DD	imagerel $LN47+66
	DD	imagerel $LN47+205
	DD	imagerel $chain$1$ProcDir
$chain$4$ProcDir DD 021H
	DD	imagerel $LN47+66
	DD	imagerel $LN47+205
	DD	imagerel $chain$1$ProcDir
$chain$6$ProcDir DD 080021H
	DD	0be400H
	DD	0a7400H
	DD	096400H
	DD	083400H
	DD	imagerel $LN47
	DD	imagerel $LN47+66
	DD	imagerel $unwind$ProcDir
$unwind$EndpDir DD 020601H
	DD	030023206H
$unwind$ExcFrameDirective DD 051501H
	DD	0160115H
	DD	0d007f009H
	DD	05005H
$chain$4$ExcFrameDirective DD 0a3321H
	DD	014e433H
	DD	015c42bH
	DD	01d7423H
	DD	01c6410H
	DD	01b3408H
	DD	imagerel $LN81
	DD	imagerel $LN81+162
	DD	imagerel $unwind$ExcFrameDirective
$chain$6$ExcFrameDirective DD 0a0021H
	DD	014e400H
	DD	015c400H
	DD	01d7400H
	DD	01c6400H
	DD	01b3400H
	DD	imagerel $LN81
	DD	imagerel $LN81+162
	DD	imagerel $unwind$ExcFrameDirective
$chain$7$ExcFrameDirective DD 021H
	DD	imagerel $LN81
	DD	imagerel $LN81+162
	DD	imagerel $unwind$ExcFrameDirective
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT write_userdef_epilogue
_TEXT	SEGMENT
reglst$ = 64
buffer$ = 192
flag_iret$ = 1264
tokenarray$ = 1272
is_exitm$ = 1280
write_userdef_epilogue PROC				; COMDAT

; 3176 : {

	push	rbx
	push	rbp
	push	r12
	push	r14
	sub	rsp, 1224				; 000004c8H

; 3177 :     uint_16 *regs;
; 3178 :     int i;
; 3179 :     char *p;
; 3180 :     bool is_exitm;
; 3181 :     struct proc_info   *info;
; 3182 :     int flags = CurrProc->sym.langtype; /* set bits 0-2 */

	mov	rax, QWORD PTR CurrProc
	movzx	ebx, cl

; 3183 :     struct dsym *dir;
; 3184 :     char reglst[128];
; 3185 :     char buffer[MAX_LINE_LEN]; /* stores string for RunMacro() */
; 3186 : 
; 3187 :     dir = (struct dsym *)SymSearch( ModuleInfo.proc_epilogue );

	mov	rcx, QWORD PTR ModuleInfo+328
	mov	r12, rdx
	mov	ebp, DWORD PTR [rax+76]
	call	SymFind
	mov	r14, rax

; 3188 :     if (dir == NULL ||
; 3189 :         dir->sym.state != SYM_MACRO ||

	test	rax, rax
	je	$LN6@write_user
	cmp	DWORD PTR [rax+32], 9
	jne	$LN6@write_user
	test	BYTE PTR [rax+44], 2
	jne	$LN6@write_user

; 3192 :     }
; 3193 : 
; 3194 :     info = CurrProc->e.procinfo;

	mov	rdx, QWORD PTR CurrProc
	mov	QWORD PTR [rsp+1288], r13

; 3195 : 
; 3196 : #if AMD64_SUPPORT
; 3197 :     /* to be compatible with ML64, translate FASTCALL to 0 (not 7) */
; 3198 :     if ( CurrProc->sym.langtype == LANG_FASTCALL && ModuleInfo.fctype == FCT_WIN64 )

	xor	r13d, r13d
	mov	QWORD PTR [rsp+1216], r15
	mov	ecx, DWORD PTR [rdx+76]
	mov	r15, QWORD PTR [rdx+96]
	cmp	ecx, 7
	jne	SHORT $LN7@write_user
	cmp	DWORD PTR ModuleInfo+376, 2
	cmove	ebp, r13d
$LN7@write_user:
	lea	eax, DWORD PTR [rcx-1]
	cmp	eax, 1
	jbe	SHORT $LN9@write_user
	cmp	ecx, 7
	jne	SHORT $LN8@write_user
$LN9@write_user:

; 3199 :         flags = 0;
; 3200 : #endif
; 3201 :     if ( CurrProc->sym.langtype == LANG_C ||
; 3202 :          CurrProc->sym.langtype == LANG_SYSCALL ||
; 3203 :          CurrProc->sym.langtype == LANG_FASTCALL)
; 3204 :         flags |= 0x10;

	or	ebp, 16
$LN8@write_user:

; 3205 : 
; 3206 :     flags |= ( CurrProc->sym.mem_type == MT_FAR ? 0x20 : 0 );
; 3207 :     flags |= ( CurrProc->sym.ispublic ? 0 : 0x40 );
; 3208 :     /* v2.11: set bit 7, the export flag */
; 3209 :     flags |= ( info->isexport ? 0x80 : 0 );
; 3210 :     flags |= flag_iret ? 0x100 : 0;  /* bit 8: 1 if IRET    */

	movzx	ecx, BYTE PTR [rdx+40]
	mov	r8d, 32					; 00000020H
	movzx	eax, BYTE PTR [r15+84]
	not	cl
	shr	ecx, 1
	and	eax, 4
	shl	eax, 5
	and	ecx, 64					; 00000040H
	or	ecx, eax
	mov	eax, r13d
	cmp	DWORD PTR [rdx+36], 130			; 00000082H
	cmove	eax, r8d
	or	ecx, eax
	neg	bl

; 3211 : 
; 3212 :     p = reglst;

	lea	rbx, QWORD PTR reglst$[rsp]
	sbb	eax, eax
	and	eax, 256				; 00000100H
	or	ecx, eax
	or	ebp, ecx

; 3213 :     if ( info->regslist ) {

	mov	rcx, QWORD PTR [r15]
	test	rcx, rcx
	je	SHORT $LN3@write_user

; 3214 :         int cnt = *info->regslist;

	mov	QWORD PTR [rsp+1264], rsi
	mov	QWORD PTR [rsp+1272], rdi
	movzx	edi, WORD PTR [rcx]

; 3215 :         regs = info->regslist + cnt;

	lea	rsi, QWORD PTR [rcx+rdi*2]

; 3216 :         for ( ; cnt; regs--, cnt-- ) {

	test	edi, edi
	je	SHORT $LN23@write_user
	npad	2
$LL4@write_user:

; 3217 :             GetResWName( *regs, p );

	movzx	ecx, WORD PTR [rsi]
	mov	rdx, rbx
	call	GetResWName

; 3218 :             p += strlen( p );

	or	rax, -1
	npad	1
$LL21@write_user:
	inc	rax
	cmp	BYTE PTR [rbx+rax], r13b
	jne	SHORT $LL21@write_user
	add	rbx, rax

; 3219 :             if ( cnt != 1 )

	cmp	edi, 1
	je	SHORT $LN2@write_user

; 3220 :                 *p++ = ',';

	mov	BYTE PTR [rbx], 44			; 0000002cH
	inc	rbx
$LN2@write_user:

; 3216 :         for ( ; cnt; regs--, cnt-- ) {

	sub	rsi, 2
	sub	edi, 1
	jne	SHORT $LL4@write_user
$LN23@write_user:
	mov	rsi, QWORD PTR [rsp+1264]
	mov	rdi, QWORD PTR [rsp+1272]
$LN3@write_user:

; 3221 :         }
; 3222 :     }
; 3223 :     *p = NULLC;

	mov	BYTE PTR [rbx], r13b

; 3224 :     //strcat( reglst, ">" );
; 3225 : 
; 3226 :     /* v2.07: make the numeric arguments more Masm-compatible */
; 3227 :     //sprintf( buffer,"%s %s, %02XH, %02XH, %02XH, <<%s>>, <%s>", ModuleInfo.proc_epilogue,
; 3228 :     sprintf( buffer,"%s, 0%XH, 0%XH, 0%XH, <<%s>>, <%s>",

	lea	rcx, OFFSET FLAT:$SG12544
	mov	rax, QWORD PTR [r15+40]
	lea	rdx, OFFSET FLAT:$SG12545
	mov	r8, QWORD PTR CurrProc
	test	rax, rax
	mov	r9d, ebp
	cmovne	rcx, rax
	lea	rax, QWORD PTR reglst$[rsp]
	mov	QWORD PTR [rsp+56], rcx
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r8, QWORD PTR [r8+8]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR [r15+36]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [r15+32]
	mov	DWORD PTR [rsp+32], eax
	call	sprintf

; 3229 :             CurrProc->sym.name, flags, info->parasize, info->localsize,
; 3230 :             reglst, info->prologuearg ? info->prologuearg : "" );
; 3231 :     i = Token_Count + 1;

	mov	ebx, DWORD PTR ModuleInfo+496

; 3232 :     Tokenize( buffer, i, tokenarray, TOK_RESCAN );

	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r9d, 1
	mov	r8, r12
	lea	edx, DWORD PTR [rbx+1]
	call	Tokenize

; 3233 : 
; 3234 :     /* if -EP is on, emit "epilogue: none" */
; 3235 :     if ( Options.preprocessor_stdout )

	cmp	BYTE PTR Options+125, r13b
	mov	r15, QWORD PTR [rsp+1216]
	je	SHORT $LN12@write_user

; 3236 :         printf( "option epilogue:none\n" );

	lea	rcx, OFFSET FLAT:$SG12547
	call	printf
$LN12@write_user:

; 3237 : 
; 3238 :     RunMacro( dir, i, tokenarray, NULL, 0, &is_exitm );

	lea	rax, QWORD PTR is_exitm$[rsp]
	xor	r9d, r9d
	mov	QWORD PTR [rsp+40], rax
	lea	edx, DWORD PTR [rbx+1]
	mov	r8, r12
	mov	DWORD PTR [rsp+32], r13d
	mov	rcx, r14
	call	RunMacro
	mov	r13, QWORD PTR [rsp+1288]

; 3239 :     Token_Count = i - 1;
; 3240 :     return( NOT_ERROR );

	xor	eax, eax
	mov	DWORD PTR ModuleInfo+496, ebx

; 3241 : }

	add	rsp, 1224				; 000004c8H
	pop	r14
	pop	r12
	pop	rbp
	pop	rbx
	ret	0
$LN6@write_user:

; 3190 :         dir->sym.isfunc == TRUE ) {
; 3191 :         return( EmitErr( EPILOGUE_MUST_BE_MACRO_PROC, ModuleInfo.proc_epilogue ) );

	mov	rdx, QWORD PTR ModuleInfo+328
	mov	ecx, 157				; 0000009dH
	call	EmitErr

; 3241 : }

	add	rsp, 1224				; 000004c8H
	pop	r14
	pop	r12
	pop	rbp
	pop	rbx
	ret	0
write_userdef_epilogue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT write_default_epilogue
_TEXT	SEGMENT
write_default_epilogue PROC				; COMDAT

; 3087 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 3088 :     struct proc_info   *info;
; 3089 : #if AMD64_SUPPORT
; 3090 :     int resstack = 0;
; 3091 : #endif
; 3092 : 
; 3093 :     info = CurrProc->e.procinfo;

	mov	rcx, QWORD PTR CurrProc
	xor	edi, edi
	mov	rbx, QWORD PTR [rcx+96]

; 3094 : 
; 3095 : #if AMD64_SUPPORT
; 3096 :     if ( info->isframe ) {

	test	BYTE PTR [rbx+84], 64			; 00000040H
	je	SHORT $LN2@write_defa

; 3097 :         if ( ModuleInfo.frame_auto )

	test	DWORD PTR ModuleInfo+408, 131072	; 00020000H
	je	$LN10@write_defa

; 3098 :             write_win64_default_epilogue( info );

	mov	rcx, rbx

; 3165 : #else
; 3166 :         AddLineQueueX( "pop %r", basereg[ModuleInfo.Ofssize] );
; 3167 : #endif
; 3168 :     }
; 3169 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 3098 :             write_win64_default_epilogue( info );

	jmp	write_win64_default_epilogue
$LN2@write_defa:

; 3099 :         return;
; 3100 :     }
; 3101 :     if ( ModuleInfo.Ofssize == USE64 && ModuleInfo.fctype == FCT_WIN64 && ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) ) {

	cmp	BYTE PTR ModuleInfo+404, 2
	jne	SHORT $LN4@write_defa
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN4@write_defa
	test	BYTE PTR ModuleInfo+413, 2
	je	SHORT $LN4@write_defa

; 3102 :         resstack  = sym_ReservedStack->value;

	mov	r9, QWORD PTR sym_ReservedStack

; 3103 :         /* if no framepointer was pushed, add 8 to align stack on OWORD
; 3104 :          * v2.12: obsolete; localsize contains correct value.
; 3105 :          */
; 3106 :         //if( !(info->localsize || info->stackparam || info->has_vararg || info->forceframe ))
; 3107 :         //    AddLineQueueX( "add %r, 8 + %s", stackreg[ModuleInfo.Ofssize], sym_ReservedStack->name );
; 3108 :         //else
; 3109 :         AddLineQueueX( "add %r, %d + %s", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize, sym_ReservedStack->name );

	lea	rcx, OFFSET FLAT:$SG12498
	mov	r8d, DWORD PTR [rbx+36]
	mov	edx, 119				; 00000077H
	mov	edi, DWORD PTR [r9+16]
	mov	r9, QWORD PTR [r9+8]
	call	AddLineQueueX
	mov	rcx, QWORD PTR CurrProc
$LN4@write_defa:

; 3110 :     }
; 3111 : #endif
; 3112 : 
; 3113 :     /* Pop the registers */
; 3114 :     pop_register( CurrProc->e.procinfo->regslist );

	mov	rcx, QWORD PTR [rcx+96]
	mov	rcx, QWORD PTR [rcx]
	call	pop_register

; 3115 : 
; 3116 :     if ( info->loadds ) {

	test	BYTE PTR [rbx+84], 16
	je	SHORT $LN5@write_defa

; 3117 :         AddLineQueueX( "pop %r", T_DS );

	mov	edx, 28
	lea	rcx, OFFSET FLAT:$SG12500
	call	AddLineQueueX
$LN5@write_defa:

; 3118 :     }
; 3119 : 
; 3120 :     if( ( info->locallist == NULL ) &&
; 3121 :        info->stackparam == FALSE &&
; 3122 :        info->has_vararg == FALSE &&
; 3123 : #if AMD64_SUPPORT
; 3124 :        resstack == 0 &&

	mov	rax, QWORD PTR [rbx+16]
	test	rax, rax
	jne	SHORT $LN7@write_defa
	movzx	ecx, BYTE PTR [rbx+84]
	test	cl, 33					; 00000021H
	jne	SHORT $LN6@write_defa
	test	edi, edi
	jne	SHORT $LN6@write_defa
	test	cl, 8
	je	$LN10@write_defa
$LN6@write_defa:

; 3125 : #endif
; 3126 :        info->forceframe == FALSE )
; 3127 :         return;
; 3128 : 
; 3129 :     /* restore registers e/sp and e/bp.
; 3130 :      * emit either "leave" or "mov e/sp,e/bp, pop e/bp".
; 3131 :      */
; 3132 : #if AMD64_SUPPORT
; 3133 :     if( !(info->locallist || info->stackparam || info->has_vararg || info->forceframe ))

	test	rax, rax
	jne	SHORT $LN7@write_defa
	movzx	eax, BYTE PTR [rbx+84]
	test	al, 33					; 00000021H
	jne	SHORT $LN7@write_defa
	test	al, 8
	je	$LN10@write_defa
$LN7@write_defa:

; 3134 :         ;
; 3135 :     else
; 3136 : #endif
; 3137 :     if( info->pe_type ) {

	movzx	eax, BYTE PTR [rbx+84]
	test	al, 2
	je	SHORT $LN9@write_defa

; 3138 :         AddLineQueue( "leave" );

	lea	rcx, OFFSET FLAT:$SG12506

; 3165 : #else
; 3166 :         AddLineQueueX( "pop %r", basereg[ModuleInfo.Ofssize] );
; 3167 : #endif
; 3168 :     }
; 3169 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 3138 :         AddLineQueue( "leave" );

	jmp	AddLineQueue
$LN9@write_defa:

; 3139 :     } else  {
; 3140 : #if STACKBASESUPP
; 3141 :         if ( info->fpo ) {

	test	al, al
	jns	SHORT $LN11@write_defa

; 3142 : #if AMD64_SUPPORT
; 3143 :             if ( ModuleInfo.Ofssize == USE64 && ModuleInfo.fctype == FCT_WIN64 && ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) )

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	al, 2
	jne	SHORT $LN12@write_defa
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN12@write_defa
	test	BYTE PTR ModuleInfo+413, al
	jne	SHORT $LN10@write_defa
$LN12@write_defa:

; 3144 :                 ;
; 3145 :             else
; 3146 : #endif
; 3147 :             if ( info->localsize )

	mov	r8d, DWORD PTR [rbx+36]
	test	r8d, r8d
	je	SHORT $LN10@write_defa

; 3148 :                 AddLineQueueX( "add %r, %d", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize );

	movzx	eax, al
	lea	rcx, OFFSET FLAT:stackreg
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12511

; 3165 : #else
; 3166 :         AddLineQueueX( "pop %r", basereg[ModuleInfo.Ofssize] );
; 3167 : #endif
; 3168 :     }
; 3169 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 3148 :                 AddLineQueueX( "add %r, %d", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize );

	jmp	AddLineQueueX
$LN11@write_defa:

; 3149 :             return;
; 3150 :         }
; 3151 : #endif
; 3152 :         /*
; 3153 :          MOV [E|R]SP, [E|R]BP
; 3154 :          POP [E|R]BP
; 3155 :          */
; 3156 :         if( info->localsize != 0 ) {

	cmp	DWORD PTR [rbx+36], 0
	je	SHORT $LN15@write_defa

; 3157 : #if STACKBASESUPP
; 3158 :             AddLineQueueX( "mov %r, %r", stackreg[ModuleInfo.Ofssize], info->basereg );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	movzx	r8d, WORD PTR [rbx+86]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12513
	call	AddLineQueueX
$LN15@write_defa:

; 3159 : #else
; 3160 :             AddLineQueueX( "mov %r, %r", stackreg[ModuleInfo.Ofssize], basereg[ModuleInfo.Ofssize] );
; 3161 : #endif
; 3162 :         }
; 3163 : #if STACKBASESUPP
; 3164 :         AddLineQueueX( "pop %r", info->basereg );

	movzx	edx, WORD PTR [rbx+86]
	lea	rcx, OFFSET FLAT:$SG12514
	call	AddLineQueueX
$LN10@write_defa:

; 3165 : #else
; 3166 :         AddLineQueueX( "pop %r", basereg[ModuleInfo.Ofssize] );
; 3167 : #endif
; 3168 :     }
; 3169 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
write_default_epilogue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT write_win64_default_epilogue
_TEXT	SEGMENT
info$ = 80
write_win64_default_epilogue PROC			; COMDAT

; 2938 : {

	push	r14
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR [rsp+80], rbx
	mov	r14, rcx
	mov	QWORD PTR [rsp+88], rbp

; 2939 : #if STACKBASESUPP
; 2940 :     /* v2.12: obsolete */
; 2941 :     //if ( GetRegNo( info->basereg ) == 4 || ( info->parasize == 0 && info->locallist == NULL ) )
; 2942 :     //    sizestd = 8;
; 2943 : #endif
; 2944 :     /* restore non-volatile xmm registers */
; 2945 :     if ( info->regslist ) {

	xor	ebp, ebp
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+56], rdi
	mov	rdi, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+48], r15
	lea	r15, OFFSET FLAT:__ImageBase
	test	rdi, rdi
	je	$LN6@write_win6

; 2946 :         uint_16 *regs;
; 2947 :         int cnt;
; 2948 :         int i;
; 2949 : 
; 2950 :         /* v2.12: space for xmm saves is now included in localsize
; 2951 :          * so first thing to do is to count the xmm regs that were saved
; 2952 :          */
; 2953 :         for( regs = info->regslist, cnt = *regs++, i = 0; cnt; cnt--, regs++ )

	movzx	r8d, WORD PTR [rdi]
	lea	rdx, QWORD PTR [rdi+2]
	mov	r9d, ebp
	test	r8d, r8d
	je	$LN6@write_win6
	npad	5
$LL4@write_win6:

; 2954 :             if ( GetValueSp( *regs ) & OP_XYZMM )

	movzx	eax, WORD PTR [rdx]
	lea	rcx, QWORD PTR [rax+rax*2]
	test	BYTE PTR SpecialTable[r15+rcx*4], 128	; 00000080H
	je	SHORT $LN2@write_win6

; 2955 :                 i++;

	inc	r9d
$LN2@write_win6:

; 2946 :         uint_16 *regs;
; 2947 :         int cnt;
; 2948 :         int i;
; 2949 : 
; 2950 :         /* v2.12: space for xmm saves is now included in localsize
; 2951 :          * so first thing to do is to count the xmm regs that were saved
; 2952 :          */
; 2953 :         for( regs = info->regslist, cnt = *regs++, i = 0; cnt; cnt--, regs++ )

	add	rdx, 2
	sub	r8d, 1
	jne	SHORT $LL4@write_win6

; 2956 : 
; 2957 :         DebugMsg1(("write_win64_default_epilogue(%s): %u xmm registers to restore\n", CurrProc->sym.name , i ));
; 2958 : 
; 2959 :         if ( i ) {

	test	r9d, r9d
	je	$LN6@write_win6

; 2960 :             i = ( info->localsize - i * XYZMMsize ) & ~(XYZMMsize-1);
; 2961 :             for( regs = info->regslist, cnt = *regs++; cnt; cnt--, regs++ ) {

	movzx	esi, WORD PTR [rdi]
	add	rdi, 2
	mov	ebx, DWORD PTR [r14+36]
	shl	r9d, 5
	sub	ebx, r9d
	and	ebx, -32				; ffffffffffffffe0H
	test	esi, esi
	je	$LN6@write_win6
	npad	11
$LL7@write_win6:

; 2962 :                 if ( GetValueSp( *regs ) & OP_XYZMM ) {

	movzx	ecx, WORD PTR [rdi]
	lea	rax, QWORD PTR [rcx+rcx*2]
	test	BYTE PTR SpecialTable[r15+rax*4], 128	; 00000080H
	je	SHORT $LN5@write_win6

; 2963 :                     DebugMsg1(("write_win64_default_epilogue(%s): restore %s, offset=%d\n", CurrProc->sym.name , GetResWName( *regs, NULL ), i ));
; 2964 :                     //AddLineQueueX( "movdqa %r, [%r+%u]", *regist, stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize + sizexmm );
; 2965 :                     /* v2.11: use @ReservedStack only if option win64:2 is set */
; 2966 :                     if ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP )

	test	BYTE PTR ModuleInfo+413, 2

; 2967 :                         AddLineQueueX( "vmovdqa %r, [%r + %u + %s]", *regs, stackreg[ModuleInfo.Ofssize], NUMQUAL i, sym_ReservedStack->name );

	mov	edx, ecx
	mov	r9d, ebx
	je	SHORT $LN15@write_win6
	mov	rax, QWORD PTR sym_ReservedStack
	movzx	r8d, BYTE PTR ModuleInfo+404
	mov	rcx, QWORD PTR [rax+8]
	mov	r8d, DWORD PTR stackreg[r15+r8*4]
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, OFFSET FLAT:$SG12467
	call	AddLineQueueX
	jmp	SHORT $LN16@write_win6
$LN15@write_win6:

; 2968 :                     else
; 2969 :                         AddLineQueueX( "vmovdqa %r, [%r + %u]", *regs, stackreg[ModuleInfo.Ofssize], NUMQUAL i );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:$SG12468
	mov	r8d, DWORD PTR stackreg[r15+rax*4]
	call	AddLineQueueX
$LN16@write_win6:

; 2970 :                     i += XYZMMsize;

	add	ebx, 32					; 00000020H
$LN5@write_win6:

; 2960 :             i = ( info->localsize - i * XYZMMsize ) & ~(XYZMMsize-1);
; 2961 :             for( regs = info->regslist, cnt = *regs++; cnt; cnt--, regs++ ) {

	add	rdi, 2
	sub	esi, 1
	jne	SHORT $LL7@write_win6
$LN6@write_win6:

; 2971 :                 }
; 2972 :             }
; 2973 :         }
; 2974 :     }
; 2975 : 
; 2976 :     if (ModuleInfo.fctype == FCT_WIN64 && (ModuleInfo.win64_flags & W64F_AUTOSTACKSP)){

	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN17@write_win6
	movzx	eax, BYTE PTR ModuleInfo+413
	test	al, 2
	je	SHORT $LN17@write_win6

; 2977 :       if (ModuleInfo.win64_flags & W64F_HABRAN){
; 2978 :         if (info->localsize + sym_ReservedStack->value)

	mov	r8d, DWORD PTR [r14+36]
	mov	r9, QWORD PTR sym_ReservedStack
	test	al, 11
	je	SHORT $LN19@write_win6
	mov	ecx, DWORD PTR [r9+16]
	add	ecx, r8d
	je	SHORT $LN18@write_win6

; 2979 :           AddLineQueueX("add %r, %d + %s", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize, sym_ReservedStack->name);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:$SG12474
	mov	r9, QWORD PTR [r9+8]
	mov	edx, DWORD PTR stackreg[r15+rax*4]
	call	AddLineQueueX

; 2980 :       }

	jmp	SHORT $LN18@write_win6
$LN19@write_win6:

; 2981 :         else
; 2982 :           AddLineQueueX("add %r, %d + %s", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize, sym_ReservedStack->name);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:$SG12475
	mov	r9, QWORD PTR [r9+8]
	mov	edx, DWORD PTR stackreg[r15+rax*4]
	call	AddLineQueueX

; 2983 :     }

	jmp	SHORT $LN18@write_win6
$LN17@write_win6:

; 2984 :     else
; 2985 :         AddLineQueueX( "add %r, %d", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:$SG12476
	mov	r8d, DWORD PTR [r14+36]
	mov	edx, DWORD PTR stackreg[r15+rax*4]
	call	AddLineQueueX
$LN18@write_win6:

; 2986 :     pop_register( CurrProc->e.procinfo->regslist );

	mov	rax, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR [rcx]
	call	pop_register

; 2987 : #if STACKBASESUPP
; 2988 :     if (ModuleInfo.win64_flags & W64F_HABRAN){

	movzx	eax, BYTE PTR ModuleInfo+413
	test	al, 11
	je	SHORT $LN9@write_win6

; 2989 :       /* restore non-volatile registers from shadow space */
; 2990 :       if (info->regslist) {

	mov	rbx, QWORD PTR [r14]
	test	rbx, rbx
	je	SHORT $LN9@write_win6

; 2991 :         uint_16 *regist = info->regslist;
; 2992 :         int cnt;
; 2993 :         if (ModuleInfo.win64_flags){

	test	al, al
	je	SHORT $LN9@write_win6

; 2995 :           int gprzize = 0;
; 2996 :           for (cnt = *regist++; cnt; cnt--, regist++)

	movzx	edi, WORD PTR [rbx]
	add	rbx, 2
	test	edi, edi
	je	SHORT $LN9@write_win6

; 2994 :           int i = 0;

	mov	rsi, rbp
	npad	6
$LL10@write_win6:

; 2997 :           {
; 2998 :             if (GetValueSp(*regist) & OP_XYZMM) continue;

	movzx	ecx, WORD PTR [rbx]
	lea	rax, QWORD PTR [rcx+rcx*2]
	test	BYTE PTR SpecialTable[r15+rax*4], 128	; 00000080H
	jne	SHORT $LN8@write_win6

; 2999 :             else {
; 3000 :               gprzize += 8;

	add	ebp, 8

; 3001 :               if (gprzize <= 0x20)

	cmp	ebp, 32					; 00000020H
	jg	SHORT $LN8@write_win6

; 3002 :               {
; 3003 :                 if (info->home_used[i] == 0){

	cmp	BYTE PTR [rsi+r14+76], 0
	jne	SHORT $LN28@write_win6

; 3004 :                   AddLineQueueX("mov %r, [%r+%u]", *regist, stackreg[ModuleInfo.Ofssize], NUMQUAL gprzize);

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	edx, ecx
	mov	r9d, ebp
	lea	rcx, OFFSET FLAT:$SG12485
	mov	r8d, DWORD PTR stackreg[r15+rax*4]
	call	AddLineQueueX

; 3005 :                 }

	jmp	SHORT $LN29@write_win6
$LN28@write_win6:

; 3006 :                 else {
; 3007 :                   cnt++; regist--;

	inc	edi
	sub	rbx, 2
$LN29@write_win6:

; 3008 :                 }
; 3009 :                 i++;

	inc	rsi
$LN8@write_win6:

; 2995 :           int gprzize = 0;
; 2996 :           for (cnt = *regist++; cnt; cnt--, regist++)

	add	rbx, 2
	sub	edi, 1
	jne	SHORT $LL10@write_win6
$LN9@write_win6:

; 3010 :               }
; 3011 :             }
; 3012 :           }
; 3013 :         }
; 3014 :       }
; 3015 :     }
; 3016 :     //if ( !info->fpo )
; 3017 :     if ( GetRegNo( info->basereg ) != 4 && ( info->parasize != 0 || info->locallist != NULL ) )

	movzx	ecx, WORD PTR [r14+86]
	mov	rdi, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
	lea	rax, QWORD PTR [rcx+rcx*2]
	cmp	BYTE PTR SpecialTable[r15+rax*4+10], 4
	mov	r15, QWORD PTR [rsp+48]
	je	SHORT $LN30@write_win6
	cmp	DWORD PTR [r14+32], 0
	jne	SHORT $LN31@write_win6
	cmp	QWORD PTR [r14+16], 0
	je	SHORT $LN30@write_win6
$LN31@write_win6:

; 3018 :         AddLineQueueX( "pop %r", info->basereg );

	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG12488

; 3019 : #else
; 3020 :     AddLineQueueX( "pop %r", basereg[ModuleInfo.Ofssize] );
; 3021 : #endif
; 3022 :     return;
; 3023 : }

	add	rsp, 64					; 00000040H
	pop	r14

; 3018 :         AddLineQueueX( "pop %r", info->basereg );

	jmp	AddLineQueueX
$LN30@write_win6:

; 3019 : #else
; 3020 :     AddLineQueueX( "pop %r", basereg[ModuleInfo.Ofssize] );
; 3021 : #endif
; 3022 :     return;
; 3023 : }

	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
write_win64_default_epilogue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT pop_register
_TEXT	SEGMENT
regist$ = 48
pop_register PROC					; COMDAT

; 2904 : {

	sub	rsp, 40					; 00000028H

; 2905 :     int cnt;
; 2906 :     if( regist == NULL )

	test	rcx, rcx
	je	$LN6@pop_regist

; 2907 :         return;
; 2908 :     cnt = *regist;
; 2909 :     regist += cnt;
; 2910 :     if (ModuleInfo.win64_flags & W64F_HABRAN)

	test	BYTE PTR ModuleInfo+413, 11
	mov	QWORD PTR [rsp+48], rbx
	movzx	ebx, WORD PTR [rcx]
	mov	QWORD PTR [rsp+56], rsi
	mov	QWORD PTR [rsp+32], rdi
	lea	rdi, QWORD PTR [rcx+rbx*2]
	je	SHORT $LN9@pop_regist

; 2911 :     {
; 2912 :       for (cnt = CurrProc->e.procinfo->pushed_reg; cnt; cnt--, regist--) {

	mov	rax, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rax+96]
	mov	ebx, DWORD PTR [rcx+64]
	test	ebx, ebx
	je	$LN24@pop_regist
	lea	rsi, OFFSET FLAT:SpecialTable
	npad	7
$LL4@pop_regist:

; 2913 :         /* don't "pop" xmm registers */
; 2914 :         if (GetValueSp(*regist) & OP_XYZMM){

	movzx	ecx, WORD PTR [rdi]
	lea	rax, QWORD PTR [rcx+rcx*2]
	test	BYTE PTR [rsi+rax*4], 128		; 00000080H
	je	SHORT $LN11@pop_regist

; 2915 :           cnt++;

	inc	ebx

; 2916 :           continue;

	jmp	SHORT $LN2@pop_regist
$LN11@pop_regist:

; 2917 :         }
; 2918 :         AddLineQueueX("pop %r", *regist);

	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG12437
	call	AddLineQueueX
$LN2@pop_regist:

; 2911 :     {
; 2912 :       for (cnt = CurrProc->e.procinfo->pushed_reg; cnt; cnt--, regist--) {

	sub	rdi, 2
	sub	ebx, 1
	jne	SHORT $LL4@pop_regist
	mov	rsi, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+32]

; 2927 :       }
; 2928 :     }
; 2929 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN9@pop_regist:

; 2919 :       }
; 2920 :     }
; 2921 :     else {
; 2922 :       for (; cnt; cnt--, regist--) {

	test	ebx, ebx
	je	SHORT $LN24@pop_regist
	lea	rsi, OFFSET FLAT:SpecialTable
	npad	9
$LL7@pop_regist:

; 2923 :         /* don't "pop" xmm registers */
; 2924 :         if (GetValueSp(*regist) & OP_XYZMM)

	movzx	ecx, WORD PTR [rdi]
	lea	rax, QWORD PTR [rcx+rcx*2]
	test	BYTE PTR [rsi+rax*4], 128		; 00000080H
	jne	SHORT $LN5@pop_regist

; 2925 :           continue;
; 2926 :         AddLineQueueX("pop %r", *regist);

	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG12439
	call	AddLineQueueX
$LN5@pop_regist:

; 2919 :       }
; 2920 :     }
; 2921 :     else {
; 2922 :       for (; cnt; cnt--, regist--) {

	sub	rdi, 2
	sub	ebx, 1
	jne	SHORT $LL7@pop_regist
$LN24@pop_regist:
	mov	rsi, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+32]
$LN6@pop_regist:

; 2927 :       }
; 2928 :     }
; 2929 : }

	add	rsp, 40					; 00000028H
	ret	0
pop_register ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT write_default_prologue
_TEXT	SEGMENT
write_default_prologue PROC				; COMDAT

; 2563 : {

	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 2564 :     struct proc_info    *info;
; 2565 :     uint_16             *regist;
; 2566 :     uint_8              oldlinenumbers;
; 2567 :     int                 cnt;
; 2568 : #if AMD64_SUPPORT
; 2569 :     int                 resstack = 0;
; 2570 : #endif
; 2571 : 
; 2572 :     info = CurrProc->e.procinfo;

	mov	r8, QWORD PTR CurrProc
	xor	ebx, ebx
	mov	rsi, QWORD PTR [r8+96]

; 2573 : 
; 2574 : #if AMD64_SUPPORT
; 2575 :     if ( info->isframe ) {

	movzx	edx, BYTE PTR [rsi+84]
	test	dl, 64					; 00000040H
	je	SHORT $LN8@write_defa

; 2576 :         //DebugMsg(("write_default_prologue: isframe\n"));
; 2577 :         if ( ModuleInfo.frame_auto ) {

	test	DWORD PTR ModuleInfo+408, 131072	; 00020000H
	je	$LN28@write_defa

; 2578 :             write_win64_default_prologue( info );

	mov	rcx, rsi
	call	write_win64_default_prologue

; 2579 :             /* v2.11: line queue is now run here */
; 2580 :             goto runqueue;

	jmp	$runqueue$41
$LN8@write_defa:

; 2581 :         }
; 2582 :         return( NOT_ERROR );
; 2583 :     }
; 2584 :     if ( ModuleInfo.Ofssize == USE64 && ModuleInfo.fctype == FCT_WIN64 && ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) )

	movzx	ecx, BYTE PTR ModuleInfo+404
	movzx	r10d, BYTE PTR ModuleInfo+413
	mov	r9d, DWORD PTR ModuleInfo+376
	cmp	cl, 2
	jne	SHORT $LN10@write_defa
	cmp	r9d, 2
	jne	SHORT $LN10@write_defa
	test	r10b, cl
	je	SHORT $LN10@write_defa

; 2585 :         resstack = sym_ReservedStack->value;

	mov	rax, QWORD PTR sym_ReservedStack
	mov	ebx, DWORD PTR [rax+16]
$LN10@write_defa:

; 2586 : #endif
; 2587 :     /* default processing. if no params/locals are defined, continue */
; 2588 :     if( info->forceframe == FALSE &&
; 2589 :        info->localsize == 0 &&
; 2590 :        info->stackparam == FALSE &&
; 2591 :        info->has_vararg == FALSE &&
; 2592 : #if AMD64_SUPPORT
; 2593 :        resstack == 0 &&

	test	dl, 8
	jne	SHORT $LN11@write_defa
	cmp	DWORD PTR [rsi+36], 0
	jne	SHORT $LN11@write_defa
	test	dl, 33					; 00000021H
	jne	SHORT $LN11@write_defa
	test	ebx, ebx
	jne	SHORT $LN11@write_defa
	cmp	QWORD PTR [rsi], 0
	je	$LN28@write_defa
$LN11@write_defa:
	mov	QWORD PTR [rsp+48], rdi

; 2594 : #endif
; 2595 :        info->regslist == NULL )
; 2596 :         return( NOT_ERROR );
; 2597 : 
; 2598 :     /* v2.11: now done in write_prologue() */
; 2599 :     //info->localsize = ROUND_UP( info->localsize, CurrWordSize );
; 2600 :     regist = info->regslist;

	mov	rdi, QWORD PTR [rsi]
	mov	QWORD PTR [rsp+56], r14

; 2601 : 
; 2602 : #if AMD64_SUPPORT
; 2603 :     /* initialize shadow space for register params */
; 2604 :     if ( ModuleInfo.Ofssize == USE64 &&
; 2605 :         CurrProc->sym.langtype == LANG_FASTCALL &&
; 2606 :         ModuleInfo.fctype == FCT_WIN64 &&

	cmp	cl, 2
	jne	SHORT $LN12@write_defa
	cmp	DWORD PTR [r8+76], 7
	jne	SHORT $LN12@write_defa
	cmp	r9d, 2
	jne	SHORT $LN12@write_defa
	test	r10b, 1
	je	SHORT $LN12@write_defa

; 2607 :         ( ModuleInfo.win64_flags & W64F_SAVEREGPARAMS ) )
; 2608 :         win64_SaveRegParams( info );

	mov	rcx, rsi
	call	win64_SaveRegParams
	movzx	ecx, BYTE PTR ModuleInfo+404
$LN12@write_defa:

; 2609 : #endif
; 2610 :     if( info->locallist || info->stackparam || info->has_vararg || info->forceframe ) {

	cmp	QWORD PTR [rsi+16], 0
	lea	r14, OFFSET FLAT:stackreg
	jne	SHORT $LN14@write_defa
	test	BYTE PTR [rsi+84], 41			; 00000029H
	je	SHORT $LN15@write_defa
$LN14@write_defa:

; 2611 : 
; 2612 :         /* write 80386 prolog code
; 2613 :          * PUSH [E|R]BP
; 2614 :          * MOV  [E|R]BP, [E|R]SP
; 2615 :          * SUB  [E|R]SP, localsize
; 2616 :          */
; 2617 : #if STACKBASESUPP
; 2618 :         if ( !info->fpo ) {

	test	BYTE PTR [rsi+84], 128			; 00000080H
	jne	SHORT $LN15@write_defa

; 2619 :             AddLineQueueX( "push %r", info->basereg );

	movzx	edx, WORD PTR [rsi+86]
	lea	rcx, OFFSET FLAT:$SG12327
	call	AddLineQueueX

; 2620 :             AddLineQueueX( "mov %r, %r", info->basereg, stackreg[ModuleInfo.Ofssize] );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:$SG12328
	movzx	edx, WORD PTR [rsi+86]
	mov	r8d, DWORD PTR [r14+rax*4]
	call	AddLineQueueX
	movzx	ecx, BYTE PTR ModuleInfo+404
$LN15@write_defa:

; 2621 :         }
; 2622 : #else
; 2623 :         AddLineQueueX( "push %r", basereg[ModuleInfo.Ofssize] );
; 2624 :         AddLineQueueX( "mov %r, %r", basereg[ModuleInfo.Ofssize], stackreg[ModuleInfo.Ofssize] );
; 2625 : #endif
; 2626 :     }
; 2627 : #if AMD64_SUPPORT
; 2628 :     if( resstack ) {

	test	ebx, ebx
	je	SHORT $LN16@write_defa

; 2629 :         /* in this case, push the USES registers BEFORE the stack space is reserved */
; 2630 :         if ( regist ) {

	test	rdi, rdi
	je	SHORT $LN18@write_defa

; 2631 :             for( cnt = *regist++; cnt; cnt--, regist++ )

	movzx	ebx, WORD PTR [rdi]
	add	rdi, 2
	test	ebx, ebx
	je	SHORT $LN3@write_defa
	npad	1
$LL4@write_defa:

; 2632 :                 AddLineQueueX( "push %r", *regist );

	movzx	edx, WORD PTR [rdi]
	lea	rcx, OFFSET FLAT:$SG12332
	call	AddLineQueueX
	lea	rdi, QWORD PTR [rdi+2]
	sub	ebx, 1
	jne	SHORT $LL4@write_defa

; 2631 :             for( cnt = *regist++; cnt; cnt--, regist++ )

	movzx	ecx, BYTE PTR ModuleInfo+404
$LN3@write_defa:

; 2633 :             regist = NULL;

	xor	edi, edi
$LN18@write_defa:

; 2634 :         }
; 2635 :         /* if no framepointer was pushed, add 8 to align stack on OWORD.
; 2636 :          * v2.12: obsolete, localsize contains correct value in this case.
; 2637 :          */
; 2638 :         //if( !(info->localsize || info->stackparam || info->has_vararg || info->forceframe ))
; 2639 :         //    AddLineQueueX( "sub %r, 8 + %s", stackreg[ModuleInfo.Ofssize], sym_ReservedStack->name );
; 2640 :         //else
; 2641 :         AddLineQueueX( "sub %r, %d + %s", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize, sym_ReservedStack->name );

	mov	r9, QWORD PTR sym_ReservedStack
	mov	r8d, DWORD PTR [rsi+36]
	movzx	eax, cl
	lea	rcx, OFFSET FLAT:$SG12333
	mov	r9, QWORD PTR [r9+8]
	mov	edx, DWORD PTR [r14+rax*4]
	call	AddLineQueueX

; 2642 :     
; 2643 :     } else

	jmp	SHORT $LN21@write_defa
$LN16@write_defa:

; 2644 : #endif
; 2645 :     if( info->localsize  ) {

	mov	r8d, DWORD PTR [rsi+36]
	test	r8d, r8d
	je	SHORT $LN21@write_defa

; 2646 :         /* using ADD and the 2-complement has one advantage:
; 2647 :          * it will generate short instructions up to a size of 128.
; 2648 :          * with SUB, short instructions work up to 127 only.
; 2649 :          */
; 2650 :         if ( Options.masm_compat_gencode || info->localsize == 128 )

	cmp	BYTE PTR Options+128, 0
	jne	SHORT $LN22@write_defa
	cmp	r8d, 128				; 00000080H
	je	SHORT $LN22@write_defa

; 2652 :         else
; 2653 :             AddLineQueueX( "sub %r, %d", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize );

	movzx	eax, cl
	lea	rcx, OFFSET FLAT:$SG12339
	jmp	SHORT $LN39@write_defa
$LN22@write_defa:

; 2651 :             AddLineQueueX( "add %r, %d", stackreg[ModuleInfo.Ofssize], NUMQUAL - info->localsize );

	movzx	eax, cl
	neg	r8d
	lea	rcx, OFFSET FLAT:$SG12338
$LN39@write_defa:
	mov	edx, DWORD PTR [r14+rax*4]
	call	AddLineQueueX
$LN21@write_defa:

; 2654 :     }
; 2655 : 
; 2656 :     if ( info->loadds ) {

	test	BYTE PTR [rsi+84], 16
	mov	r14, QWORD PTR [rsp+56]
	je	SHORT $LN23@write_defa

; 2657 :         AddLineQueueX( "push %r", T_DS );

	mov	edx, 28
	lea	rcx, OFFSET FLAT:$SG12341
	call	AddLineQueueX

; 2658 :         AddLineQueueX( "mov %r, %s", T_AX, szDgroup );

	mov	ebx, 9
	lea	r8, OFFSET FLAT:szDgroup
	mov	edx, ebx
	lea	rcx, OFFSET FLAT:$SG12342
	call	AddLineQueueX

; 2659 :         AddLineQueueX( "mov %r, %r", T_DS, ModuleInfo.Ofssize ? T_EAX : T_AX );

	cmp	BYTE PTR ModuleInfo+404, 0
	lea	rcx, OFFSET FLAT:$SG12343
	mov	eax, 17
	cmovne	ebx, eax
	mov	r8d, ebx
	lea	edx, QWORD PTR [rax+11]
	call	AddLineQueueX
$LN23@write_defa:

; 2660 :     }
; 2661 : 
; 2662 :     /* Push the GPR registers of the USES clause */
; 2663 :     if ( regist ) {

	test	rdi, rdi
	je	SHORT $LN38@write_defa

; 2664 :         for( cnt = *regist++; cnt; cnt--, regist++ ) {

	movzx	ebx, WORD PTR [rdi]
	add	rdi, 2
	test	ebx, ebx
	je	SHORT $LN38@write_defa
	npad	7
$LL7@write_defa:

; 2665 :             AddLineQueueX( "push %r", *regist );

	movzx	edx, WORD PTR [rdi]
	lea	rcx, OFFSET FLAT:$SG12345
	call	AddLineQueueX
	lea	rdi, QWORD PTR [rdi+2]
	sub	ebx, 1
	jne	SHORT $LL7@write_defa
$LN38@write_defa:
	mov	rdi, QWORD PTR [rsp+48]
$runqueue$41:

; 2666 :         }
; 2667 :     }
; 2668 : 
; 2669 : #if AMD64_SUPPORT
; 2670 : runqueue:
; 2671 : #endif
; 2672 : 
; 2673 : #if FASTPASS
; 2674 :     /* special case: generated code runs BEFORE the line.*/
; 2675 :     if ( ModuleInfo.list && UseSavedState )

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN27@write_defa
	cmp	BYTE PTR UseSavedState, 0
	je	SHORT $LN27@write_defa

; 2676 :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN26@write_defa

; 2677 :             info->prolog_list_pos = list_pos;

	mov	eax, DWORD PTR list_pos
	mov	DWORD PTR [rsi+80], eax
	jmp	SHORT $LN27@write_defa
$LN26@write_defa:

; 2678 :         else
; 2679 :             list_pos = info->prolog_list_pos;

	mov	eax, DWORD PTR [rsi+80]
	mov	DWORD PTR list_pos, eax
$LN27@write_defa:

; 2680 : #endif
; 2681 :     /* line number debug info also needs special treatment
; 2682 :      * because current line number is the first true src line
; 2683 :      * IN the proc.
; 2684 :      */
; 2685 :     oldlinenumbers = Options.line_numbers;

	movzx	ebx, BYTE PTR Options+1

; 2686 :     Options.line_numbers = FALSE; /* temporarily disable line numbers */

	mov	BYTE PTR Options+1, 0

; 2687 :     RunLineQueue();

	call	RunLineQueue

; 2688 :     Options.line_numbers = oldlinenumbers;
; 2689 : 
; 2690 : #if FASTPASS
; 2691 :     if ( ModuleInfo.list && UseSavedState && (Parse_Pass > PASS_1))

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	mov	BYTE PTR Options+1, bl
	je	SHORT $LN28@write_defa
	cmp	BYTE PTR UseSavedState, 0
	je	SHORT $LN28@write_defa
	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN28@write_defa

; 2692 :          LineStoreCurr->list_pos = list_pos;

	mov	rax, QWORD PTR LineStoreCurr
	mov	ecx, DWORD PTR list_pos
	mov	DWORD PTR [rax+12], ecx
$LN28@write_defa:

; 2693 : #endif
; 2694 : 
; 2695 :     return( NOT_ERROR );

	xor	eax, eax

; 2696 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
write_default_prologue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT write_win64_default_prologue
_TEXT	SEGMENT
info$ = 96
write_win64_default_prologue PROC			; COMDAT

; 2331 : {

	push	rdi
	push	r12
	push	r15
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR [rsp+56], r13
	mov	rdi, rcx

; 2332 :     uint_16             *regist;
; 2333 :     const char * const  *ppfmt;
; 2334 :     int                 cntxmm;
; 2335 :     int                 n;
; 2336 :     int                 m;
; 2337 :     int                 resstack = ( ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) ? sym_ReservedStack->value : 0 );

	xor	r13d, r13d
	test	BYTE PTR ModuleInfo+413, 2
	je	SHORT $LN59@write_win6
	mov	rax, QWORD PTR sym_ReservedStack
	mov	r15d, DWORD PTR [rax+16]
	jmp	SHORT $LN60@write_win6
$LN59@write_win6:
	mov	r15d, r13d
$LN60@write_win6:

; 2338 : 
; 2339 :     DebugMsg1(("write_win64_default_prologue enter\n"));
; 2340 : 
; 2341 :     if ( ModuleInfo.win64_flags & W64F_SAVEREGPARAMS )

	test	BYTE PTR ModuleInfo+413, 1
	je	SHORT $LN13@write_win6

; 2342 :         win64_SaveRegParams( info );

	call	win64_SaveRegParams
$LN13@write_win6:

; 2343 :     if (ModuleInfo.win64_flags & W64F_HABRAN) 

	test	BYTE PTR ModuleInfo+413, 11
	je	SHORT $LN14@write_win6

; 2344 :       win64_StoreRegHome(info);

	mov	rcx, rdi
	call	win64_StoreRegHome
$LN14@write_win6:

; 2345 :     /*
; 2346 :      * PUSH RBP
; 2347 :      * .PUSHREG RBP
; 2348 :      * MOV RBP, RSP
; 2349 :      * .SETFRAME RBP, 0
; 2350 :      */
; 2351 : #if STACKBASESUPP
; 2352 :     /* info->locallist tells whether there are local variables ( info->localsize doesn't! ) */
; 2353 :     if ( info->fpo || ( info->parasize == 0 && info->locallist == NULL ) ) {

	test	BYTE PTR [rdi+84], 128			; 00000080H
	jne	SHORT $LN17@write_win6
	cmp	DWORD PTR [rdi+32], r13d
	jne	SHORT $LN15@write_win6
	cmp	QWORD PTR [rdi+16], r13
	je	SHORT $LN17@write_win6
$LN15@write_win6:

; 2354 :         DebugMsg1(("write_win64_default_prologue: no frame register needed\n"));
; 2355 :         //sizestd += 8; /* v2.12: obsolete */
; 2356 :     } else {
; 2357 :         AddLineQueueX( "push %r", info->basereg );

	movzx	edx, WORD PTR [rdi+86]
	lea	rcx, OFFSET FLAT:$SG12236
	call	AddLineQueueX

; 2358 :         AddLineQueueX( "%r %r", T_DOT_PUSHREG, info->basereg );

	movzx	r8d, WORD PTR [rdi+86]
	lea	rcx, OFFSET FLAT:$SG12237
	mov	edx, 416				; 000001a0H
	call	AddLineQueueX

; 2359 :         AddLineQueueX( "mov %r, %r", info->basereg, T_RSP );

	movzx	edx, WORD PTR [rdi+86]
	lea	rcx, OFFSET FLAT:$SG12238
	mov	r8d, 119				; 00000077H
	call	AddLineQueueX

; 2360 :         AddLineQueueX( "%r %r, 0", T_DOT_SETFRAME, info->basereg );

	movzx	r8d, WORD PTR [rdi+86]
	lea	rcx, OFFSET FLAT:$SG12239
	mov	edx, 420				; 000001a4H
	call	AddLineQueueX
$LN17@write_win6:

; 2361 :     }
; 2362 : #else
; 2363 :     AddLineQueueX( "push %r", basereg[USE64] );
; 2364 :     AddLineQueueX( "%r %r", T_DOT_PUSHREG, basereg[USE64] );
; 2365 :     AddLineQueueX( "mov %r, %r", basereg[USE64], T_RSP );
; 2366 :     AddLineQueueX( "%r %r, 0", T_DOT_SETFRAME, basereg[USE64] );
; 2367 : #endif
; 2368 :     if (ModuleInfo.win64_flags & W64F_HABRAN){

	test	BYTE PTR ModuleInfo+413, 11
	lea	r12, OFFSET FLAT:SpecialTable
	mov	QWORD PTR [rsp+96], rbx

; 2369 :       cntxmm = 0;
; 2370 :       if (info->regslist) {

	mov	rbx, QWORD PTR [rdi]
	mov	QWORD PTR [rsp+104], rbp
	mov	ebp, r13d
	mov	QWORD PTR [rsp+112], rsi
	mov	QWORD PTR [rsp+48], r14
	je	$LN18@write_win6
	test	rbx, rbx
	je	$LN6@write_win6

; 2371 :         int cnt;
; 2372 :         int n = 0;
; 2373 :         info->pushed_reg = 0; /*count of pushed registers */

	mov	DWORD PTR [rdi+64], r13d
	mov	r14d, r13d

; 2374 :         regist = info->regslist;
; 2375 :         for (cnt = *regist++; cnt; cnt--, regist++) {

	movzx	esi, WORD PTR [rbx]
	add	rbx, 2
	test	esi, esi
	je	$LN6@write_win6
	npad	2
$LL4@write_win6:

; 2376 :           if (GetValueSp(*regist) & OP_XYZMM) {

	movzx	eax, WORD PTR [rbx]
	lea	rcx, QWORD PTR [rax+rax*2]
	test	BYTE PTR [r12+rcx*4], 128		; 00000080H
	je	SHORT $LN21@write_win6

; 2377 :             cntxmm += 1;

	inc	ebp

; 2378 :           }

	jmp	SHORT $LN2@write_win6
$LN21@write_win6:

; 2379 :           else {
; 2380 :             if (n < info->stored_reg) n++;

	cmp	r14d, DWORD PTR [rdi+60]
	jge	SHORT $LN23@write_win6
	inc	r14d
	jmp	SHORT $LN2@write_win6
$LN23@write_win6:

; 2381 :             else{
; 2382 :               info->pushed_reg += 1;

	inc	DWORD PTR [rdi+64]

; 2383 :               AddLineQueueX("push %r", *regist);

	lea	rcx, OFFSET FLAT:$SG12247
	movzx	edx, WORD PTR [rbx]
	call	AddLineQueueX

; 2384 :               if ((1 << GetRegNo(*regist)) & win64_nvgpr) {

	movzx	edx, WORD PTR [rbx]
	lea	rax, QWORD PTR [rdx+rdx*2]
	movzx	ecx, BYTE PTR [r12+rax*4+10]
	mov	eax, 1
	shl	eax, cl
	test	eax, 61672				; 0000f0e8H
	je	SHORT $LN2@write_win6

; 2385 :                 AddLineQueueX("%r %r", T_DOT_PUSHREG, *regist);

	mov	r8d, edx
	lea	rcx, OFFSET FLAT:$SG12249
	mov	edx, 416				; 000001a0H
	call	AddLineQueueX
$LN2@write_win6:

; 2374 :         regist = info->regslist;
; 2375 :         for (cnt = *regist++; cnt; cnt--, regist++) {

	add	rbx, 2
	sub	esi, 1
	jne	SHORT $LL4@write_win6

; 2386 :               }
; 2387 :             }
; 2388 :           }
; 2389 :         } /* end for */
; 2390 :       }
; 2391 :     }

	jmp	SHORT $LN6@write_win6
$LN18@write_win6:

; 2392 :     else{
; 2393 :       /* after the "push rbp", the stack is xmmword aligned */
; 2394 : 
; 2395 :       /* Push the registers */
; 2396 :       cntxmm = 0;
; 2397 :       if (info->regslist) {

	test	rbx, rbx
	je	SHORT $LN6@write_win6

; 2398 :         int cnt;
; 2399 :         regist = info->regslist;
; 2400 :         for (cnt = *regist++; cnt; cnt--, regist++) {

	movzx	esi, WORD PTR [rbx]
	add	rbx, 2
	test	esi, esi
	je	SHORT $LN6@write_win6
	npad	7
$LL7@write_win6:

; 2401 :           if (GetValueSp(*regist) & OP_XYZMM) {

	movzx	ecx, WORD PTR [rbx]
	lea	rax, QWORD PTR [rcx+rcx*2]
	test	BYTE PTR [r12+rax*4], 128		; 00000080H
	je	SHORT $LN27@write_win6

; 2402 :             cntxmm += 1;

	inc	ebp

; 2403 :           }

	jmp	SHORT $LN5@write_win6
$LN27@write_win6:

; 2404 :           else {
; 2405 :             AddLineQueueX("push %r", *regist);

	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG12253
	call	AddLineQueueX

; 2406 :             if ((1 << GetRegNo(*regist)) & win64_nvgpr) {

	movzx	edx, WORD PTR [rbx]
	lea	rax, QWORD PTR [rdx+rdx*2]
	movzx	ecx, BYTE PTR [r12+rax*4+10]
	mov	eax, 1
	shl	eax, cl
	test	eax, 61672				; 0000f0e8H
	je	SHORT $LN5@write_win6

; 2407 :               AddLineQueueX("%r %r", T_DOT_PUSHREG, *regist);

	mov	r8d, edx
	lea	rcx, OFFSET FLAT:$SG12255
	mov	edx, 416				; 000001a0H
	call	AddLineQueueX
$LN5@write_win6:

; 2398 :         int cnt;
; 2399 :         regist = info->regslist;
; 2400 :         for (cnt = *regist++; cnt; cnt--, regist++) {

	add	rbx, 2
	sub	esi, 1
	jne	SHORT $LL7@write_win6
$LN6@write_win6:

; 2408 :             }
; 2409 :           }
; 2410 :         } /* end for */
; 2411 :       }
; 2412 :     }
; 2413 :     /* v2.11: now done in write_prologue() */
; 2414 :     //info->localsize = ROUND_UP( info->localsize, CurrWordSize );
; 2415 :     if (ModuleInfo.win64_flags & W64F_HABRAN){

	test	BYTE PTR ModuleInfo+413, 11
	mov	r14, QWORD PTR [rsp+48]
	je	SHORT $LN32@write_win6

; 2416 :       if (Parse_Pass && sym_ReservedStack->hasinvoke == 0) resstack = 0;

	cmp	DWORD PTR Parse_Pass, r13d
	je	SHORT $LN31@write_win6
	mov	rax, QWORD PTR sym_ReservedStack
	cmp	DWORD PTR [rax+16], r13d
	cmove	r15d, r13d
$LN31@write_win6:

; 2417 :       if (!(info->locallist) && !(resstack)) info->localsize = 0;

	cmp	QWORD PTR [rdi+16], r13
	jne	SHORT $LN32@write_win6
	test	r15d, r15d
	jne	SHORT $LN32@write_win6
	mov	DWORD PTR [rdi+36], r13d
$LN32@write_win6:

; 2418 :     }
; 2419 :     /* alloc space for local variables */
; 2420 :     //if( info->localsize + sizestd ) {
; 2421 :     if( info->localsize + resstack ) {

	mov	ecx, DWORD PTR [rdi+36]
	mov	r13, QWORD PTR [rsp+56]
	lea	eax, DWORD PTR [rcx+r15]
	test	eax, eax
	je	$LN11@write_win6

; 2422 :         DebugMsg1(("write_win64_default_prologue: localsize=%u resstack=%u\n", info->localsize, resstack ));
; 2423 :         if (ModuleInfo.win64_flags & W64F_HABRAN){

	test	BYTE PTR ModuleInfo+413, 11
	je	SHORT $LN78@write_win6

; 2424 :           if (info->localsize == 0){

	test	ecx, ecx
	jne	SHORT $LN35@write_win6

; 2425 :             if (info->pushed_reg == 0)        

	cmp	DWORD PTR [rdi+64], 0
	mov	eax, 16
	mov	ecx, 24
	cmove	eax, ecx
	mov	DWORD PTR [rdi+36], eax

; 2426 :               info->localsize += 0x18;  
; 2427 :             else 
; 2428 :               info->localsize += 0x10; 
; 2429 :           }

	jmp	SHORT $LN78@write_win6
$LN35@write_win6:

; 2430 :           else {
; 2431 :               n = info->localsize + resstack;
; 2432 :               if (n < XYZMMsize)   

	cmp	eax, 32					; 00000020H
	jge	SHORT $LN39@write_win6

; 2433 :                 n = XYZMMsize;

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN41@write_win6
$LN39@write_win6:

; 2434 :               else {
; 2435 :                 m = n & (XYZMMsize - 1);

	test	al, 31

; 2436 :                 if (m != 0){

	je	SHORT $LN41@write_win6

; 2437 :                   n += XYZMMsize;

	add	eax, 32					; 00000020H

; 2438 :                   n &= ~(XYZMMsize - 1);

	and	eax, -32				; ffffffffffffffe0H
$LN41@write_win6:

; 2439 :                 }
; 2440 :               }
; 2441 :                 info->localsize = n - resstack;
; 2442 :               if (info->pushed_reg == 0) {      

	mov	ecx, DWORD PTR [rdi+64]
	sub	eax, r15d
	mov	DWORD PTR [rdi+36], eax
	test	ecx, ecx
	jne	SHORT $LN42@write_win6

; 2443 :                 info->localsize += 0x18;    

	add	eax, 24
	mov	DWORD PTR [rdi+36], eax

; 2444 :               }

	jmp	SHORT $LN78@write_win6
$LN42@write_win6:

; 2445 :               else{
; 2446 :                 info->localsize += 0x10;

	add	eax, 16

; 2447 :                 n = info->pushed_reg - 1;

	dec	ecx
	mov	DWORD PTR [rdi+36], eax

; 2448 :                 if (OP_XYZMM == OP_ZMM){
; 2449 :                   if (n >= 8) 
; 2450 :                     n -= 8;
; 2451 :                 }
; 2452 :                 else {
; 2453 :                   if (n >= 4) n -= 4;

	cmp	ecx, 4
	jl	SHORT $LN63@write_win6
	sub	ecx, 4

; 2454 :                   if (n >= 4) n -= 4;

	cmp	ecx, 4
	jl	SHORT $LN63@write_win6
	sub	ecx, 4
$LN63@write_win6:

; 2455 :                 }
; 2456 :                 while (n){

	test	ecx, ecx
	je	SHORT $LN78@write_win6
	lea	ecx, DWORD PTR [rax+rcx*8]
	mov	DWORD PTR [rdi+36], ecx
$LN78@write_win6:

; 2457 :                   info->localsize += 0x8;
; 2458 :                   n--;
; 2459 :                 }
; 2460 :               }
; 2461 :             }
; 2462 :           }          
; 2463 :           /*
; 2464 :          * SUB  RSP, localsize
; 2465 :          * .ALLOCSTACK localsize
; 2466 :          */
; 2467 :         ppfmt = ( resstack ? fmtstk1 : fmtstk0 );
; 2468 : #if STACKPROBE
; 2469 :         if ( info->localsize + resstack > 0x1000 ) {
; 2470 :             AddLineQueueX( *(ppfmt+2), T_RAX, NUMQUAL info->localsize, sym_ReservedStack->name );
; 2471 :             AddLineQueue(  "externdef __chkstk:PROC" );
; 2472 :             AddLineQueue(  "call __chkstk" );
; 2473 :             AddLineQueueX( "mov %r, %r", T_RSP, T_RAX );
; 2474 :         } else
; 2475 : #endif
; 2476 : 
; 2477 : 		AddLineQueueX(*(ppfmt + 0), T_RSP, NUMQUAL info->localsize, sym_ReservedStack->name);

	mov	r9, QWORD PTR sym_ReservedStack
	lea	rax, OFFSET FLAT:fmtstk1
	mov	r8d, DWORD PTR [rdi+36]
	lea	rbx, OFFSET FLAT:fmtstk0
	test	r15d, r15d
	mov	edx, 119				; 00000077H
	mov	r9, QWORD PTR [r9+8]
	cmovne	rbx, rax
	mov	rcx, QWORD PTR [rbx]
	call	AddLineQueueX

; 2478 : 		AddLineQueueX(*(ppfmt + 1), T_DOT_ALLOCSTACK, NUMQUAL info->localsize, sym_ReservedStack->name);

	mov	r9, QWORD PTR sym_ReservedStack
	mov	edx, 413				; 0000019dH
	mov	r8d, DWORD PTR [rdi+36]
	mov	rcx, QWORD PTR [rbx+8]
	mov	r9, QWORD PTR [r9+8]
	call	AddLineQueueX

; 2479 : 
; 2480 : 		/* Handle ZEROLOCALS option */
; 2481 : 		if (ZEROLOCALS && info->localsize) 

	cmp	BYTE PTR ZEROLOCALS, 0
	je	$LN51@write_win6
	mov	r8d, DWORD PTR [rdi+36]
	test	r8d, r8d
	je	$LN51@write_win6

; 2482 : 		{
; 2483 : 			if (info->localsize <= 128) 

	cmp	r8d, 128				; 00000080H
	ja	SHORT $LN50@write_win6

; 2484 : 			{
; 2485 : 				AddLineQueueX("mov %r, %u", T_EAX, info->localsize);

	mov	edx, 17
	lea	rcx, OFFSET FLAT:$SG12278
	call	AddLineQueueX

; 2486 : 				AddLineQueueX("dec %r", T_EAX);

	mov	edx, 17
	lea	rcx, OFFSET FLAT:$SG12279
	call	AddLineQueueX

; 2487 : 				AddLineQueueX("mov byte ptr [%r + %r], 0", T_RSP, T_RAX);

	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12280
	lea	r8d, QWORD PTR [rdx-4]
	call	AddLineQueueX

; 2488 : 				AddLineQueueX("dw 0F875h");

	lea	rcx, OFFSET FLAT:$SG12281
	call	AddLineQueueX

; 2489 : 			}

	jmp	$LN51@write_win6
$LN50@write_win6:

; 2490 : 			else
; 2491 : 			{
; 2492 : 				AddLineQueueX("push %r", T_RDI);

	mov	edx, 122				; 0000007aH
	lea	rcx, OFFSET FLAT:$SG12282
	call	AddLineQueueX

; 2493 : 				AddLineQueueX("push %r", T_RCX);

	mov	edx, 116				; 00000074H
	lea	rcx, OFFSET FLAT:$SG12283
	call	AddLineQueueX

; 2494 : 				AddLineQueueX("xor %r, %r", T_EAX, T_EAX);

	mov	edx, 17
	lea	rcx, OFFSET FLAT:$SG12284
	mov	r8d, edx
	call	AddLineQueueX

; 2495 : 				AddLineQueueX("mov %r, %u", T_ECX, info->localsize);

	mov	r8d, DWORD PTR [rdi+36]
	lea	rcx, OFFSET FLAT:$SG12285
	mov	edx, 18
	call	AddLineQueueX

; 2496 : 				AddLineQueueX("cld");

	lea	rcx, OFFSET FLAT:$SG12286
	call	AddLineQueueX

; 2497 : 				AddLineQueueX("lea %r, [%r+16]", T_RDI, T_RSP);

	mov	edx, 122				; 0000007aH
	lea	rcx, OFFSET FLAT:$SG12287
	lea	r8d, QWORD PTR [rdx-3]
	call	AddLineQueueX

; 2498 : 				AddLineQueueX("rep stosb");

	lea	rcx, OFFSET FLAT:$SG12288
	call	AddLineQueueX

; 2499 : 				AddLineQueueX("pop %r", T_RCX);

	mov	edx, 116				; 00000074H
	lea	rcx, OFFSET FLAT:$SG12289
	call	AddLineQueueX

; 2500 : 				AddLineQueueX("pop %r", T_RDI);

	mov	edx, 122				; 0000007aH
	lea	rcx, OFFSET FLAT:$SG12290
	call	AddLineQueueX
$LN51@write_win6:

; 2501 : 			}
; 2502 : 		}
; 2503 : 
; 2504 :         /* save xmm registers */
; 2505 :         if ( cntxmm ) {

	test	ebp, ebp
	je	$LN11@write_win6

; 2506 :             int i;
; 2507 :             int cnt;
; 2508 :             regist = info->regslist;

	mov	rsi, QWORD PTR [rdi]

; 2509 :             i = ( info->localsize - cntxmm * XYZMMsize ) & ~(XYZMMsize-1);

	mov	ebx, DWORD PTR [rdi+36]
	shl	ebp, 5
	sub	ebx, ebp

; 2510 :             for( cnt = *regist++; cnt; cnt--, regist++ ) {

	movzx	edi, WORD PTR [rsi]
	and	ebx, -32				; ffffffffffffffe0H
	add	rsi, 2
	test	edi, edi
	je	$LN11@write_win6
	npad	7
$LL12@write_win6:

; 2511 :                 if ( GetValueSp( *regist ) & OP_XYZMM ) {

	movzx	ecx, WORD PTR [rsi]
	lea	rax, QWORD PTR [rcx+rcx*2]
	test	BYTE PTR [r12+rax*4], 128		; 00000080H
	je	$LN10@write_win6

; 2512 :                     if ( resstack ) {
; 2513 :                         AddLineQueueX( "vmovdqa [%r+%u+%s], %r", T_RSP, NUMQUAL i, sym_ReservedStack->name, *regist );

	mov	r8d, ebx
	mov	edx, 119				; 00000077H
	test	r15d, r15d
	je	SHORT $LN54@write_win6
	mov	r9, QWORD PTR sym_ReservedStack
	mov	DWORD PTR [rsp+32], ecx
	lea	rcx, OFFSET FLAT:$SG12295
	mov	r9, QWORD PTR [r9+8]
	call	AddLineQueueX

; 2514 :                         if ( ( 1 << GetRegNo( *regist ) ) & win64_nvxmm )  {

	movzx	edx, WORD PTR [rsi]
	lea	rax, QWORD PTR [rdx+rdx*2]
	movzx	ecx, BYTE PTR [r12+rax*4+10]
	mov	eax, 1
	shl	eax, cl
	test	eax, 65472				; 0000ffc0H
	je	SHORT $LN57@write_win6

; 2515 :                             AddLineQueueX( "%r %r, %u+%s", T_DOT_SAVEYMM256, *regist, NUMQUAL i, sym_ReservedStack->name );

	mov	rax, QWORD PTR sym_ReservedStack
	mov	r8d, edx
	mov	r9d, ebx
	mov	edx, 419				; 000001a3H
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, OFFSET FLAT:$SG12297
	call	AddLineQueueX

; 2516 :                         }
; 2517 :                     } else {

	jmp	SHORT $LN57@write_win6
$LN54@write_win6:

; 2518 :                         AddLineQueueX( "vmovdqa [%r+%u], %r", T_RSP, NUMQUAL i, *regist );

	mov	r9d, ecx
	lea	rcx, OFFSET FLAT:$SG12298
	call	AddLineQueueX

; 2519 :                         if ( ( 1 << GetRegNo( *regist ) ) & win64_nvxmm )  {

	movzx	edx, WORD PTR [rsi]
	lea	rax, QWORD PTR [rdx+rdx*2]
	movzx	ecx, BYTE PTR [r12+rax*4+10]
	mov	eax, 1
	shl	eax, cl
	test	eax, 65472				; 0000ffc0H
	je	SHORT $LN57@write_win6

; 2520 :                             AddLineQueueX( "%r %r, %u", T_DOT_SAVEYMM256, *regist, NUMQUAL i );

	mov	r8d, edx
	lea	rcx, OFFSET FLAT:$SG12300
	mov	edx, 419				; 000001a3H
	mov	r9d, ebx
	call	AddLineQueueX
$LN57@write_win6:

; 2521 :                         }
; 2522 :                     }
; 2523 :                     i += XYZMMsize;

	add	ebx, 32					; 00000020H
$LN10@write_win6:

; 2510 :             for( cnt = *regist++; cnt; cnt--, regist++ ) {

	add	rsi, 2
	sub	edi, 1
	jne	$LL12@write_win6
$LN11@write_win6:

; 2524 :                 }
; 2525 :             }
; 2526 :         }
; 2527 : 
; 2528 :     }
; 2529 :     AddLineQueueX( "%r", T_DOT_ENDPROLOG );

	mov	edx, 414				; 0000019eH
	lea	rcx, OFFSET FLAT:$SG12301
	mov	rsi, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+96]

; 2530 : 
; 2531 :     /* v2.11: linequeue is now run in write_default_prologue() */
; 2532 :     return;
; 2533 : }

	add	rsp, 64					; 00000040H
	pop	r15
	pop	r12
	pop	rdi

; 2524 :                 }
; 2525 :             }
; 2526 :         }
; 2527 : 
; 2528 :     }
; 2529 :     AddLineQueueX( "%r", T_DOT_ENDPROLOG );

	jmp	AddLineQueueX
write_win64_default_prologue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT win64_StoreRegHome
_TEXT	SEGMENT
info$ = 64
win64_StoreRegHome PROC					; COMDAT

; 2253 : {

	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 2254 :   int			       i = 0;
; 2255 :   int			       cnt;
; 2256 :   int            grcount = 0;
; 2257 :   int			       sizestd = 0;
; 2258 :   int            freeshadow = 4;
; 2259 :   uint_16        *regist;
; 2260 :   info->stored_reg = 0;
; 2261 :   if (info->regslist) {

	mov	rdi, QWORD PTR [rcx]
	xor	r14d, r14d
	mov	DWORD PTR [rcx+60], r14d
	mov	rsi, rcx
	mov	edx, r14d
	test	rdi, rdi
	je	$LN24@win64_Stor

; 2262 :     for (regist = info->regslist, cnt = *regist++; cnt; cnt--, regist++, i++) {

	movzx	r8d, WORD PTR [rdi]
	add	rdi, 2
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+80], r15
	lea	r15, OFFSET FLAT:SpecialTable
	test	r8d, r8d
	je	SHORT $LN3@win64_Stor
$LL4@win64_Stor:

; 2263 :       if (GetValueSp(*regist) & OP_XYZMM) continue;

	movzx	eax, WORD PTR [rdi]
	lea	rcx, QWORD PTR [rax+rax*2]
	test	BYTE PTR [r15+rcx*4], 128		; 00000080H
	jne	SHORT $LN2@win64_Stor

; 2264 :       else ++grcount;                                       //find how many general registers to save

	inc	edx
$LN2@win64_Stor:

; 2262 :     for (regist = info->regslist, cnt = *regist++; cnt; cnt--, regist++, i++) {

	add	rdi, 2
	sub	r8d, 1
	jne	SHORT $LL4@win64_Stor
$LN3@win64_Stor:

; 2265 :     }
; 2266 :     //for (i = 0, freeshadow = 0; i<4; i++){                  
; 2267 :     //  if (info->home_used[i] == 0) ++freeshadow;
; 2268 :     //}
; 2269 :     freeshadow -= info->home_taken;                         //find out how many free shadows

	mov	r8d, 4
	mov	eax, r8d
	sub	eax, DWORD PTR [rsi+68]

; 2270 :     if (freeshadow){                                        //skip if all shadow spaces are taken  

	je	$LN44@win64_Stor

; 2271 :       if (grcount == 1) memset(info->home_used, 1, 4);      //1 register only? don't store it, push it to prevent 'sub rsp,...8'

	cmp	edx, 1
	jne	SHORT $LN30@win64_Stor
	mov	rax, 72340172838076673			; 0101010101010101H
	mov	DWORD PTR [rsi+76], eax
	jmp	$LN44@win64_Stor
$LN30@win64_Stor:

; 2272 :       else if (grcount == 2 && freeshadow >= 2){            //store only one egister, another push to prevent 'sub rsp,...8'

	cmp	edx, 2
	jne	SHORT $LN32@win64_Stor
	cmp	eax, edx
	jl	$LN44@win64_Stor

; 2273 :         for (i = 0; i<4; i++){

	mov	ecx, r14d
	mov	rax, r14
$LL7@win64_Stor:

; 2274 :           if (info->home_used[i] == 0) break;               //we need only one space   

	cmp	BYTE PTR [rsi+rax+76], r14b
	je	SHORT $LN60@win64_Stor

; 2273 :         for (i = 0; i<4; i++){

	inc	ecx
	inc	rax
	cmp	rax, r8
	jl	SHORT $LL7@win64_Stor
$LN60@win64_Stor:

; 2275 :         }
; 2276 :         for (++i; i<4; i++)                                 //the rest of free spaces render as taken

	lea	eax, DWORD PTR [rcx+1]

; 2277 :           info->home_used[i] = 1;
; 2278 :       }

	jmp	SHORT $LN92@win64_Stor
$LN32@win64_Stor:

; 2279 :       else if (grcount == 3){                               //3 registers?

	cmp	edx, 3
	jne	SHORT $LN35@win64_Stor

; 2280 :         if (freeshadow == 1) memset(info->home_used, 1, 4); //if only 1 free shadow, don't store it, push them

	cmp	eax, 1
	jne	SHORT $LN37@win64_Stor
	mov	rax, 72340172838076673			; 0101010101010101H
	mov	DWORD PTR [rsi+76], eax

; 2281 :         if (freeshadow >= 3){                               //enen if there is enough space we will store only two

	jmp	$LN44@win64_Stor
$LN37@win64_Stor:
	cmp	eax, 3
	jl	$LN44@win64_Stor

; 2282 :           for (i = 0; i<4; i++){                            //the third one we will push to keep uneven stack 

	mov	eax, r14d
	mov	rcx, r14
$LL13@win64_Stor:

; 2283 :             if (info->home_used[i] == 0) break;             //found first availible

	cmp	BYTE PTR [rsi+rcx+76], r14b
	je	SHORT $LN61@win64_Stor

; 2282 :           for (i = 0; i<4; i++){                            //the third one we will push to keep uneven stack 

	inc	eax
	inc	rcx
	cmp	rcx, r8
	jl	SHORT $LL13@win64_Stor
$LN61@win64_Stor:

; 2284 :           }
; 2285 :           for (++i; i<4; i++){

	inc	eax
	movsxd	rcx, eax
	cmp	rcx, r8
	jge	SHORT $LN88@win64_Stor
$LL16@win64_Stor:

; 2286 :             if (info->home_used[i] == 0) break;            //found second availible

	cmp	BYTE PTR [rsi+rcx+76], r14b
	je	SHORT $LN88@win64_Stor

; 2284 :           }
; 2285 :           for (++i; i<4; i++){

	inc	eax
	inc	rcx
	cmp	rcx, r8
	jl	SHORT $LL16@win64_Stor
$LN88@win64_Stor:

; 2287 :           }
; 2288 :           for (++i; i<4; i++)

	inc	eax
$LN92@win64_Stor:
	movsxd	rcx, eax
	cmp	rcx, r8
	jge	SHORT $LN44@win64_Stor
	lea	rdi, QWORD PTR [rsi+76]
	mov	eax, 1
	add	rdi, rcx
	sub	r8, rcx
	mov	rcx, r8
	rep stosb

; 2289 :             info->home_used[i] = 1;                        //render the rest of the shadow spaces as taken
; 2290 :         }
; 2291 :       }

	jmp	SHORT $LN44@win64_Stor
$LN35@win64_Stor:

; 2292 :       else if (grcount == 4 && freeshadow == 4){          //easy case

	cmp	edx, r8d
	jne	SHORT $LN91@win64_Stor
	cmp	eax, r8d
	jne	SHORT $LN44@win64_Stor

; 2293 :         info->home_used[3] = 1;                           //render the last shadow spaces as taken

	mov	BYTE PTR [rsi+79], 1

; 2294 :       }                                                   //remember the first space is 0 than 1, 2 and 3 follow 

	jmp	SHORT $LN44@win64_Stor
$LN91@win64_Stor:

; 2295 :       else if (grcount > 4){                              //if more registars than spaces

	jle	SHORT $LN44@win64_Stor

; 2296 :         freeshadow = grcount - freeshadow;                //find out how many we can store

	sub	edx, eax

; 2297 :         if (!(freeshadow & 1)){                           //if it is even number

	test	dl, 1
	jne	SHORT $LN44@win64_Stor

; 2298 :           for (i = 0; i<4; i++){                          //than we have to disable one space

	mov	ecx, r14d
	mov	rax, r14
$LL22@win64_Stor:

; 2299 :             if (info->home_used[i] == 0) break;           //find the first free space 

	cmp	BYTE PTR [rsi+rax+76], r14b
	je	SHORT $LN63@win64_Stor

; 2298 :           for (i = 0; i<4; i++){                          //than we have to disable one space

	inc	ecx
	inc	rax
	cmp	rax, r8
	jl	SHORT $LL22@win64_Stor
$LN63@win64_Stor:

; 2300 :           }
; 2301 :           info->home_used[i] = 1;                         //and render it as taken

	movsxd	rax, ecx
	mov	BYTE PTR [rax+rsi+76], 1
$LN44@win64_Stor:

; 2302 :         }
; 2303 :       }
; 2304 :     }
; 2305 :     for (i = 0, regist = info->regslist, cnt = *regist++; cnt; cnt--, regist++, i++) {

	mov	rdi, QWORD PTR [rsi]
	movzx	ebx, WORD PTR [rdi]
	add	rdi, 2
	test	ebx, ebx
	je	$LN90@win64_Stor
	mov	QWORD PTR [rsp+72], rbp
	mov	rbp, r14
	npad	11
$LL25@win64_Stor:

; 2306 :       if (GetValueSp(*regist) & (OP_XYZMM )) continue;

	movzx	ecx, WORD PTR [rdi]
	lea	rax, QWORD PTR [rcx+rcx*2]
	test	BYTE PTR [r15+rax*4], 128		; 00000080H
	jne	SHORT $LN23@win64_Stor

; 2307 :       else {
; 2308 :         sizestd += 8;

	add	r14d, 8

; 2309 :         if (i < 4)

	cmp	rbp, 4
	jge	SHORT $LN23@win64_Stor

; 2310 :         {
; 2311 :           if (info->home_used[i] == 0){

	cmp	BYTE PTR [rsi+rbp+76], 0
	jne	SHORT $LN49@win64_Stor

; 2312 :             AddLineQueueX("mov [%r+%u], %r", T_RSP, NUMQUAL sizestd, *regist);

	mov	r9d, ecx
	mov	r8d, r14d
	lea	rcx, OFFSET FLAT:$SG12202
	mov	edx, 119				; 00000077H
	call	AddLineQueueX

; 2313 :             AddLineQueueX("%r %r, %u", T_DOT_SAVEREG, *regist, NUMQUAL sizestd);

	movzx	r8d, WORD PTR [rdi]
	lea	rcx, OFFSET FLAT:$SG12203
	mov	r9d, r14d
	mov	edx, 417				; 000001a1H
	call	AddLineQueueX

; 2314 :             info->stored_reg++;

	inc	DWORD PTR [rsi+60]

; 2315 :           }

	jmp	SHORT $LN23@win64_Stor
$LN49@win64_Stor:

; 2316 :           else {
; 2317 :             cnt++; regist--;

	inc	ebx
	sub	rdi, 2
$LN23@win64_Stor:

; 2302 :         }
; 2303 :       }
; 2304 :     }
; 2305 :     for (i = 0, regist = info->regslist, cnt = *regist++; cnt; cnt--, regist++, i++) {

	add	rdi, 2
	inc	rbp
	sub	ebx, 1
	jne	SHORT $LL25@win64_Stor
	mov	rbp, QWORD PTR [rsp+72]
$LN90@win64_Stor:
	mov	rbx, QWORD PTR [rsp+64]
	mov	r15, QWORD PTR [rsp+80]
$LN24@win64_Stor:

; 2318 :           }
; 2319 :         }
; 2320 :       }
; 2321 :     }/* end for */
; 2322 :   }
; 2323 :   return;
; 2324 : }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
win64_StoreRegHome ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT win64_SaveRegParams
_TEXT	SEGMENT
info$ = 64
win64_SaveRegParams PROC				; COMDAT

; 2198 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2199 :     int i;
; 2200 :     struct dsym *param;
; 2201 :     if (ModuleInfo.win64_flags & W64F_HABRAN){
; 2202 :       int			   cnt;
; 2203 :       uint_16        *regist;
; 2204 :       info->home_taken = 0;

	xor	ebp, ebp
	mov	r14, rcx
	test	BYTE PTR ModuleInfo+413, 11
	je	$LN8@win64_Save

; 2205 :       memset(info->home_used, 0, 4);

	xor	eax, eax
	mov	DWORD PTR [rcx+68], ebp
	lea	r15, QWORD PTR [rcx+76]
	mov	DWORD PTR [r15], eax

; 2206 :       if (info->regslist)
; 2207 :         regist = info->regslist;
; 2208 : 
; 2209 :       for (i = 0, param = info->paralist; param && (i < 4); i++) {

	mov	rdi, QWORD PTR [rcx+8]
	test	rdi, rdi
	je	$LN29@win64_Save
	mov	ebx, 8
	lea	rsi, OFFSET FLAT:ms64_regs
	npad	1
$LL4@win64_Save:
	cmp	ebx, 40					; 00000028H
	jge	$LN29@win64_Save

; 2210 :         /* v2.05: save XMMx if type is float/double */
; 2211 :         if (param->sym.is_vararg == FALSE) {

	test	BYTE PTR [rdi+47], 32			; 00000020H
	jne	SHORT $LN11@win64_Save

; 2212 :           if ((param->sym.mem_type & MT_FLOAT) && param->sym.used){  // added  && param->sym.used

	test	BYTE PTR [rdi+36], 32			; 00000020H
	je	SHORT $LN13@win64_Save
	test	BYTE PTR [rdi+40], 1
	je	SHORT $LN15@win64_Save

; 2213 :             AddLineQueueX("movq [%r+%u], %r", T_RSP, 8 + i * 8, T_XMM0 + i);

	lea	r9d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG12132

; 2214 :             info->home_used[i] = 1;
; 2215 :             ++info->home_taken;
; 2216 :           }

	jmp	SHORT $LN31@win64_Save
$LN13@win64_Save:

; 2217 :           else{
; 2218 :             if (param->sym.used){                                    //here as well 

	test	BYTE PTR [rdi+40], 1
	je	SHORT $LN15@win64_Save

; 2219 :               AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	mov	r9d, DWORD PTR [rsi]
	lea	rcx, OFFSET FLAT:$SG12134
$LN31@win64_Save:
	mov	r8d, ebx
	mov	edx, 119				; 00000077H
	call	AddLineQueueX

; 2220 :               info->home_used[i] = 1;

	mov	BYTE PTR [r15], 1

; 2221 :               ++info->home_taken;

	inc	DWORD PTR [r14+68]
$LN15@win64_Save:

; 2222 :             }
; 2223 :           }
; 2224 :           param = param->nextparam;

	mov	rdi, QWORD PTR [rdi+112]

; 2225 :         }

	jmp	SHORT $LN2@win64_Save
$LN11@win64_Save:

; 2226 :         else { /* v2.09: else branch added */
; 2227 :           AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	mov	r9d, DWORD PTR [rsi]
	lea	rcx, OFFSET FLAT:$SG12135
	mov	r8d, ebx
	mov	edx, 119				; 00000077H
	call	AddLineQueueX

; 2228 :           info->home_used[i] = 1;

	mov	BYTE PTR [r15], 1

; 2229 :           ++info->home_taken;

	inc	DWORD PTR [r14+68]
$LN2@win64_Save:

; 2206 :       if (info->regslist)
; 2207 :         regist = info->regslist;
; 2208 : 
; 2209 :       for (i = 0, param = info->paralist; param && (i < 4); i++) {

	inc	ebp
	add	ebx, 8
	add	rsi, 4
	inc	r15
	test	rdi, rdi
	jne	$LL4@win64_Save

; 2230 :         }
; 2231 :       }
; 2232 :     }

	jmp	SHORT $LN29@win64_Save
$LN8@win64_Save:

; 2233 :     else {
; 2234 :       for (i = 0, param = info->paralist; param && (i < 4); i++) {

	mov	rdi, QWORD PTR [rcx+8]
	test	rdi, rdi
	je	SHORT $LN29@win64_Save
	mov	ebx, 8
	lea	rsi, OFFSET FLAT:ms64_regs
	npad	2
$LL7@win64_Save:
	cmp	ebx, 40					; 00000028H
	jge	SHORT $LN29@win64_Save

; 2235 :         /* v2.05: save XMMx if type is float/double */
; 2236 :         if (param->sym.is_vararg == FALSE) {

	test	BYTE PTR [rdi+47], 32			; 00000020H

; 2238 :             AddLineQueueX("movq [%r+%u], %r", T_RSP, 8 + i * 8, T_XMM0 + i);

	mov	r8d, ebx
	mov	edx, 119				; 00000077H
	jne	SHORT $LN16@win64_Save

; 2237 :           if (param->sym.mem_type & MT_FLOAT)

	test	BYTE PTR [rdi+36], 32			; 00000020H
	je	SHORT $LN18@win64_Save

; 2238 :             AddLineQueueX("movq [%r+%u], %r", T_RSP, 8 + i * 8, T_XMM0 + i);

	lea	r9d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG12140

; 2239 :           else
; 2240 :             AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	call	AddLineQueueX

; 2241 :           param = param->nextparam;

	mov	rdi, QWORD PTR [rdi+112]

; 2242 :         }

	jmp	SHORT $LN5@win64_Save
$LN18@win64_Save:

; 2239 :           else
; 2240 :             AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	mov	r9d, DWORD PTR [rsi]
	lea	rcx, OFFSET FLAT:$SG12141
	call	AddLineQueueX

; 2241 :           param = param->nextparam;

	mov	rdi, QWORD PTR [rdi+112]

; 2242 :         }

	jmp	SHORT $LN5@win64_Save
$LN16@win64_Save:

; 2243 :         else { /* v2.09: else branch added */
; 2244 :           AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	mov	r9d, DWORD PTR [rsi]
	lea	rcx, OFFSET FLAT:$SG12142
	call	AddLineQueueX
$LN5@win64_Save:

; 2233 :     else {
; 2234 :       for (i = 0, param = info->paralist; param && (i < 4); i++) {

	inc	ebp
	add	ebx, 8
	add	rsi, 4
	test	rdi, rdi
	jne	SHORT $LL7@win64_Save
$LN29@win64_Save:

; 2245 :         }
; 2246 :       }
; 2247 :     }
; 2248 :     return;
; 2249 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
win64_SaveRegParams ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT write_userdef_prologue
_TEXT	SEGMENT
reglst$ = 64
buffer$ = 192
tokenarray$ = 1264
is_exitm$ = 1272
write_userdef_prologue PROC				; COMDAT

; 2107 : {

	push	rbp
	push	r12
	sub	rsp, 1240				; 000004d8H

; 2108 :     int                 len;
; 2109 :     int                 i;
; 2110 :     struct proc_info    *info;
; 2111 :     char                *p;
; 2112 :     bool                is_exitm;
; 2113 :     struct dsym         *dir;
; 2114 :     //int                 align = CurrWordSize;
; 2115 :     int                 flags = CurrProc->sym.langtype; /* set bits 0-2 */
; 2116 :     uint_16             *regs;
; 2117 :     char                reglst[128];
; 2118 :     char                buffer[MAX_LINE_LEN];
; 2119 : 
; 2120 : #if FASTPASS
; 2121 :     if ( Parse_Pass > PASS_1 && UseSavedState )

	cmp	DWORD PTR Parse_Pass, 0
	mov	r12, rcx
	mov	r8, QWORD PTR CurrProc
	mov	edx, DWORD PTR [r8+76]
	mov	ebp, edx
	jbe	SHORT $LN8@write_user
	cmp	BYTE PTR UseSavedState, 0
	je	SHORT $LN8@write_user

; 2122 :         return( NOT_ERROR );

	xor	eax, eax

; 2190 : }

	add	rsp, 1240				; 000004d8H
	pop	r12
	pop	rbp
	ret	0
$LN8@write_user:
	mov	QWORD PTR [rsp+1232], r13

; 2123 : #endif
; 2124 : 
; 2125 :     info = CurrProc->e.procinfo;
; 2126 :     /* v2.11: now done in write_prologue() */
; 2127 :     //info->localsize = ROUND_UP( info->localsize, CurrWordSize );
; 2128 : #if AMD64_SUPPORT
; 2129 :     /* to be compatible with ML64, translate FASTCALL to 0 (not 7) */
; 2130 :     if ( CurrProc->sym.langtype == LANG_FASTCALL && ModuleInfo.fctype == FCT_WIN64 )

	xor	r13d, r13d
	mov	QWORD PTR [rsp+1224], r14
	mov	r14, QWORD PTR [r8+96]
	mov	QWORD PTR [rsp+1216], r15
	cmp	edx, 7
	jne	SHORT $LN9@write_user
	cmp	DWORD PTR ModuleInfo+376, 2
	cmove	ebp, r13d
$LN9@write_user:
	lea	eax, DWORD PTR [rdx-1]
	cmp	eax, 1
	jbe	SHORT $LN11@write_user
	cmp	edx, 7
	jne	SHORT $LN10@write_user
$LN11@write_user:

; 2131 :         flags = 0;
; 2132 : #endif
; 2133 :     /* set bit 4 if the caller restores (E)SP */
; 2134 :     if ( CurrProc->sym.langtype == LANG_C ||
; 2135 :         CurrProc->sym.langtype == LANG_SYSCALL ||
; 2136 :         CurrProc->sym.langtype == LANG_FASTCALL )
; 2137 :         flags |= 0x10;

	or	ebp, 16
$LN10@write_user:

; 2138 : 
; 2139 :     /* set bit 5 if proc is far */
; 2140 :     /* set bit 6 if proc is private */
; 2141 :     /* v2.11: set bit 7 if proc is export */
; 2142 :     flags |= ( CurrProc->sym.mem_type == MT_FAR ? 0x20 : 0 );
; 2143 :     flags |= ( CurrProc->sym.ispublic ? 0 : 0x40 );
; 2144 :     flags |= ( info->isexport ? 0x80 : 0 );

	movzx	ecx, BYTE PTR [r8+40]
	mov	edx, 32					; 00000020H
	movzx	eax, BYTE PTR [r14+84]
	not	cl
	shr	ecx, 1
	and	eax, 4
	and	ecx, 64					; 00000040H
	shl	eax, 5
	or	ecx, eax
	mov	eax, r13d
	cmp	DWORD PTR [r8+36], 130			; 00000082H
	cmove	eax, edx
	or	ecx, eax
	or	ebp, ecx

; 2145 : 
; 2146 :     dir = (struct dsym *)SymSearch( ModuleInfo.proc_prologue );

	mov	rcx, QWORD PTR ModuleInfo+320
	call	SymFind
	mov	r15, rax

; 2147 :     if ( dir == NULL || dir->sym.state != SYM_MACRO || dir->sym.isfunc != TRUE ) {

	test	rax, rax
	je	$LN13@write_user
	cmp	DWORD PTR [rax+32], 9
	jne	$LN13@write_user
	test	BYTE PTR [rax+44], 2
	je	$LN13@write_user

; 2149 :     }
; 2150 : 
; 2151 :     /* if -EP is on, emit "prologue: none" */
; 2152 :     if ( Options.preprocessor_stdout )

	cmp	BYTE PTR Options+125, r13b
	mov	QWORD PTR [rsp+1264], rbx
	mov	QWORD PTR [rsp+1280], rsi
	je	SHORT $LN14@write_user

; 2153 :         printf( "option prologue:none\n" );

	lea	rcx, OFFSET FLAT:$SG12105
	call	printf
$LN14@write_user:

; 2154 : 
; 2155 :     p = reglst;
; 2156 :     if ( info->regslist ) {

	mov	rsi, QWORD PTR [r14]
	lea	rbx, QWORD PTR reglst$[rsp]
	test	rsi, rsi
	je	SHORT $LN3@write_user

; 2157 :         regs = info->regslist;
; 2158 :         for ( len = *regs++; len; len--, regs++ ) {

	mov	QWORD PTR [rsp+1288], rdi
	movzx	edi, WORD PTR [rsi]
	add	rsi, 2
	test	edi, edi
	je	SHORT $LN34@write_user
	npad	6
$LL4@write_user:

; 2159 :             GetResWName( *regs, p );

	movzx	ecx, WORD PTR [rsi]
	mov	rdx, rbx
	call	GetResWName

; 2160 :             p += strlen( p );

	or	rax, -1
	npad	1
$LL30@write_user:
	inc	rax
	cmp	BYTE PTR [rbx+rax], r13b
	jne	SHORT $LL30@write_user
	add	rbx, rax

; 2161 :             if ( len > 1 )

	cmp	edi, 1
	jle	SHORT $LN2@write_user

; 2162 :                 *p++ = ',';

	mov	BYTE PTR [rbx], 44			; 0000002cH
	inc	rbx
$LN2@write_user:

; 2157 :         regs = info->regslist;
; 2158 :         for ( len = *regs++; len; len--, regs++ ) {

	add	rsi, 2
	sub	edi, 1
	jne	SHORT $LL4@write_user
$LN34@write_user:
	mov	rdi, QWORD PTR [rsp+1288]
$LN3@write_user:

; 2163 :         }
; 2164 :     }
; 2165 :     *p = NULLC;

	mov	BYTE PTR [rbx], r13b

; 2166 : 
; 2167 :     /* v2.07: make this work with radix != 10 */
; 2168 :     /* leave a space at pos 0 of buffer, because the buffer is used for
; 2169 :      * both macro arguments and EXITM return value.
; 2170 :      */
; 2171 :     sprintf( buffer," (%s, 0%XH, 0%XH, 0%XH, <<%s>>, <%s>)",

	lea	rcx, OFFSET FLAT:$SG12108
	mov	rax, QWORD PTR [r14+40]
	lea	rdx, OFFSET FLAT:$SG12109
	mov	r8, QWORD PTR CurrProc
	test	rax, rax
	mov	r9d, ebp
	cmovne	rcx, rax
	lea	rax, QWORD PTR reglst$[rsp]
	mov	QWORD PTR [rsp+56], rcx
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r8, QWORD PTR [r8+8]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR [r14+36]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [r14+32]
	mov	DWORD PTR [rsp+32], eax
	call	sprintf

; 2172 :              CurrProc->sym.name, flags, info->parasize, info->localsize,
; 2173 :             reglst, info->prologuearg ? info->prologuearg : "" );
; 2174 :     i = Token_Count + 1;

	mov	ebx, DWORD PTR ModuleInfo+496

; 2175 :     Token_Count = Tokenize( buffer, i, tokenarray, TOK_RESCAN );

	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r9d, 1
	mov	r8, r12
	lea	edx, DWORD PTR [rbx+1]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 2176 : 
; 2177 :     RunMacro( dir, i, tokenarray, buffer, 0, &is_exitm );

	lea	r9, QWORD PTR buffer$[rsp]
	lea	rax, QWORD PTR is_exitm$[rsp]
	mov	r8, r12
	mov	QWORD PTR [rsp+40], rax
	lea	edx, DWORD PTR [rbx+1]
	mov	rcx, r15
	mov	DWORD PTR [rsp+32], r13d
	call	RunMacro

; 2178 :     Token_Count = i - 1;
; 2179 :     DebugMsg(("write_userdef_prologue: macro %s returned >%s<\n", ModuleInfo.proc_prologue, buffer ));
; 2180 : 
; 2181 :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, r13d
	mov	rsi, QWORD PTR [rsp+1280]
	mov	DWORD PTR ModuleInfo+496, ebx
	mov	rbx, QWORD PTR [rsp+1264]
	jne	SHORT $LN6@write_user

; 2182 :         struct dsym *curr;
; 2183 :         len = atoi( buffer ) - info->localsize;

	lea	rcx, QWORD PTR buffer$[rsp]
	call	atoi
	sub	eax, DWORD PTR [r14+36]

; 2184 :         for ( curr = info->locallist; curr; curr = curr->nextlocal ) {

	mov	rcx, QWORD PTR [r14+16]
	test	rcx, rcx
	je	SHORT $LN6@write_user
$LL7@write_user:

; 2185 :             curr->sym.offset -= len;

	sub	DWORD PTR [rcx+16], eax
	mov	rcx, QWORD PTR [rcx+112]
	test	rcx, rcx
	jne	SHORT $LL7@write_user
$LN6@write_user:

; 2186 :         }
; 2187 :     }
; 2188 : 
; 2189 :     return ( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN33@write_user
$LN13@write_user:

; 2148 :         return( EmitError( PROLOGUE_MUST_BE_MACRO_FUNC ) );

	mov	ecx, 156				; 0000009cH
	call	EmitError
$LN33@write_user:
	mov	r13, QWORD PTR [rsp+1232]
	mov	r14, QWORD PTR [rsp+1224]
	mov	r15, QWORD PTR [rsp+1216]

; 2190 : }

	add	rsp, 1240				; 000004d8H
	pop	r12
	pop	rbp
	ret	0
write_userdef_prologue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
opndx$ = 48
i$ = 208
tokenarray$ = 216
ExcFrameDirective PROC

; 1861 : {

$LN81:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	r13
	push	r15
	lea	rbp, QWORD PTR [rsp-71]
	sub	rsp, 176				; 000000b0H
	mov	eax, DWORD PTR Options+144
	mov	r15, rdx

; 1862 :     struct expr opndx;
; 1863 :     int token;
; 1864 :     unsigned int size;
; 1865 :     uint_8 oldcodes = unw_info.CountOfCodes;

	movzx	r13d, BYTE PTR unw_info+2
	add	eax, -2					; fffffffeH
	cmp	eax, 1
	jbe	SHORT $LN6@ExcFrameDi

; 1866 :     uint_8 reg;
; 1867 :     uint_8 ofs;
; 1868 :     UNWIND_CODE *puc;
; 1869 : 
; 1870 :     DebugMsg1(("ExcFrameDirective(%s) enter\n", tokenarray[i].string_ptr ));
; 1871 :     /* v2.05: accept directives for windows only */
; 1872 : 	if (Options.output_format != OFORMAT_COFF && Options.output_format != OFORMAT_ELF /* John Hankinson 2016-02-10 Added elf win64 hack */
; 1873 : #if PE_SUPPORT
; 1874 :         && ModuleInfo.sub_format != SFORMAT_PE

	cmp	DWORD PTR ModuleInfo+372, 2
	je	SHORT $LN6@ExcFrameDi

; 1875 : #endif
; 1876 :        ) {
; 1877 :         return( EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, GetResWName( tokenarray[i].tokval, NULL ) ) );

	movsxd	rax, ecx
	xor	edx, edx
	shl	rax, 5
	mov	ecx, DWORD PTR [rax+r15+16]
	call	GetResWName
	mov	rdx, rax
	mov	ecx, 224				; 000000e0H
	call	EmitErr

; 2089 : }

	add	rsp, 176				; 000000b0H
	pop	r15
	pop	r13
	pop	rbp
	ret	0
$LN6@ExcFrameDi:

; 1878 :     }
; 1879 :     if ( CurrProc == NULL || endprolog_found == TRUE ) {

	mov	rax, QWORD PTR CurrProc
	test	rax, rax
	je	$LN8@ExcFrameDi
	cmp	BYTE PTR endprolog_found, 1
	je	$LN8@ExcFrameDi

; 1881 :     }
; 1882 :     if ( CurrProc->e.procinfo->isframe == FALSE ) {

	mov	rax, QWORD PTR [rax+96]
	test	BYTE PTR [rax+84], 64			; 00000040H
	jne	SHORT $LN9@ExcFrameDi

; 1883 :         return( EmitError( MISSING_FRAME_IN_PROC ) );

	mov	ecx, 256				; 00000100H
	call	EmitError

; 2089 : }

	add	rsp, 176				; 000000b0H
	pop	r15
	pop	r13
	pop	rbp
	ret	0
$LN9@ExcFrameDi:
	mov	QWORD PTR [rsp+216], rbx
	mov	QWORD PTR [rsp+224], rsi

; 1884 :     }
; 1885 : 
; 1886 :     puc = &unw_code[unw_info.CountOfCodes];

	lea	rsi, OFFSET FLAT:__ImageBase
	movzx	eax, r13b
	mov	QWORD PTR [rsp+232], rdi
	mov	QWORD PTR [rsp+168], r12
	mov	QWORD PTR [rsp+160], r14
	lea	rbx, QWORD PTR unw_code[rax*2]
	add	rbx, rsi

; 1887 : 
; 1888 :     ofs = GetCurrOffset() - CurrProc->sym.offset;

	call	GetCurrOffset

; 1889 :     token = tokenarray[i].tokval;

	movsxd	r8, DWORD PTR i$[rbp-105]
	mov	r12d, eax
	mov	rcx, QWORD PTR CurrProc
	sub	r12b, BYTE PTR [rcx+16]
	mov	rcx, r8
	shl	rcx, 5

; 1890 :     i++;

	inc	r8d
	mov	edi, DWORD PTR [rcx+r15+16]
	mov	DWORD PTR i$[rbp-105], r8d

; 1891 : 
; 1892 :     /* note: since the codes will be written from "right to left",
; 1893 :      * the opcode item has to be written last!
; 1894 :      */
; 1895 : 
; 1896 :     switch ( token ) {

	lea	eax, DWORD PTR [rdi-413]
	cmp	eax, 7
	ja	$LN62@ExcFrameDi
	movsxd	rcx, eax
	mov	eax, DWORD PTR $LN60@ExcFrameDi[rsi+rcx*4]
	add	rax, rsi
	jmp	rax
$LN10@ExcFrameDi:

; 1897 :     case T_DOT_ALLOCSTACK: /* syntax: .ALLOCSTACK size */
; 1898 :         if ( ERROR == EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rbp-105]
	mov	rdx, r15
	mov	BYTE PTR [rsp+32], 0
	lea	rcx, QWORD PTR i$[rbp-105]
	call	EvalOperand
	cmp	eax, -1
	je	$LN76@ExcFrameDi

; 1899 :             return( ERROR );
; 1900 :         if ( opndx.kind == EXPR_ADDR && opndx.sym->state == SYM_UNDEFINED ) /* v2.11: allow forward references */

	mov	eax, DWORD PTR opndx$[rbp-45]
	cmp	eax, 1
	jne	SHORT $LN12@ExcFrameDi
	mov	rax, QWORD PTR opndx$[rbp-25]
	cmp	DWORD PTR [rax+32], 0

; 1901 :              ;
; 1902 :         else if ( opndx.kind != EXPR_CONST ) {

	jmp	SHORT $LN69@ExcFrameDi
$LN12@ExcFrameDi:
	test	eax, eax
$LN69@ExcFrameDi:
	jne	$LN75@ExcFrameDi

; 1903 :             return( EmitError( CONSTANT_EXPECTED ) );
; 1904 :         }
; 1905 :         /* v2.11: check added */
; 1906 :         if ( opndx.hvalue ) {

	cmp	DWORD PTR opndx$[rbp-101], 0
	jne	$LN73@ExcFrameDi

; 1907 :             return( EmitConstError( &opndx ) );
; 1908 :         }
; 1909 :         if ( opndx.uvalue == 0 ) {

	mov	eax, DWORD PTR opndx$[rbp-105]
	test	eax, eax
	jne	SHORT $LN16@ExcFrameDi

; 1910 :             return( EmitError( NONZERO_VALUE_EXPECTED ) );

	mov	ecx, 258				; 00000102H
	call	EmitError
	jmp	$LN68@ExcFrameDi
$LN16@ExcFrameDi:

; 1911 :         }
; 1912 :         if ( opndx.value & 7 ) {

	test	al, 7
	jne	$LN74@ExcFrameDi

; 1918 :                 /* allocation size 512k - 4G-8 */
; 1919 :                 /* v2.11: value is stored UNSCALED in 2 WORDs! */
; 1920 :                 puc->FrameOffset = ( opndx.uvalue >> 16 );
; 1921 :                 puc++;
; 1922 :                 puc->FrameOffset = opndx.uvalue & 0xFFFF;
; 1923 :                 puc++;
; 1924 :                 unw_info.CountOfCodes += 2;

	movzx	ecx, BYTE PTR unw_info+2
	cmp	eax, 128				; 00000080H
	jbe	SHORT $LN18@ExcFrameDi

; 1913 :             return( EmitError( BAD_ALIGNMENT_FOR_OFFSET_IN_UNWIND_CODE ) );
; 1914 :         }
; 1915 :         //opndx.value -= 8; /* v2.11: subtract 8 only for UWOP_ALLOC_SMALL! */
; 1916 :         if ( opndx.uvalue > 16*8 ) {
; 1917 :             if ( opndx.uvalue >= 65536*8 ) {

	cmp	eax, 524288				; 00080000H
	jb	SHORT $LN20@ExcFrameDi

; 1925 :                 puc->OpInfo = 1;
; 1926 :                 DebugMsg1(("ExcFrameDirective: UWOP_ALLOC_LARGE, operation info 1, size=%Xh\n", opndx.value ));
; 1927 :             } else {
; 1928 :                 /* allocation size 128+8 - 512k-8 */
; 1929 :                 puc->FrameOffset = ( opndx.uvalue >> 3 );
; 1930 :                 puc++;
; 1931 :                 unw_info.CountOfCodes++;
; 1932 :                 puc->OpInfo = 0;
; 1933 :                 DebugMsg1(("ExcFrameDirective: UWOP_ALLOC_LARGE, operation info 0, size=%Xh\n", opndx.value ));
; 1934 :             }
; 1935 :             puc->UnwindOp = UWOP_ALLOC_LARGE;
; 1936 :         } else {
; 1937 :             /* allocation size 8-128 bytes */
; 1938 :             puc->UnwindOp = UWOP_ALLOC_SMALL;
; 1939 :             /* v2.11: subtract 8 only for UWOP_ALLOC_SMALL! */
; 1940 :             //puc->OpInfo = ( opndx.value >> 3 );
; 1941 :             puc->OpInfo = ( (opndx.uvalue - 8 ) >> 3 );
; 1942 :             DebugMsg1(("ExcFrameDirective: UWOP_ALLOC_SMALL, size=%Xh\n", opndx.value ));
; 1943 :         }
; 1944 :         puc->CodeOffset = ofs;
; 1945 :         unw_info.CountOfCodes++;
; 1946 :         break;

	mov	r8d, DWORD PTR i$[rbp-105]
	add	cl, 2
	shr	eax, 16
	mov	WORD PTR [rbx], ax
	movzx	eax, WORD PTR opndx$[rbp-105]
	mov	WORD PTR [rbx+2], ax
	add	rbx, 4
	and	BYTE PTR [rbx+1], 15
	or	BYTE PTR [rbx+1], 16
	and	BYTE PTR [rbx+1], 241			; 000000f1H
	or	BYTE PTR [rbx+1], 1
	inc	cl
	mov	BYTE PTR [rbx], r12b
	mov	BYTE PTR unw_info+2, cl
	jmp	$LN4@ExcFrameDi
$LN20@ExcFrameDi:
	mov	r8d, DWORD PTR i$[rbp-105]
	inc	cl
	shr	eax, 3
	mov	WORD PTR [rbx], ax
	add	rbx, 2
	and	BYTE PTR [rbx+1], 15
	and	BYTE PTR [rbx+1], 241			; 000000f1H
	or	BYTE PTR [rbx+1], 1
	inc	cl
	mov	BYTE PTR [rbx], r12b
	mov	BYTE PTR unw_info+2, cl
	jmp	SHORT $LN4@ExcFrameDi
$LN18@ExcFrameDi:
	mov	r8d, DWORD PTR i$[rbp-105]
	add	eax, -8					; fffffff8H
	shr	eax, 3
	shl	al, 4
	or	al, 2
	inc	cl
	mov	BYTE PTR [rbx+1], al
	mov	BYTE PTR unw_info+2, cl
	mov	BYTE PTR [rbx], r12b
	jmp	SHORT $LN4@ExcFrameDi
$LN22@ExcFrameDi:

; 1947 :     case T_DOT_ENDPROLOG: /* syntax: .ENDPROLOG */
; 1948 :         opndx.value = GetCurrOffset() - CurrProc->sym.offset;

	call	GetCurrOffset
	mov	rcx, QWORD PTR CurrProc
	sub	eax, DWORD PTR [rcx+16]
	mov	DWORD PTR opndx$[rbp-105], eax

; 1949 :         if ( opndx.uvalue > 255 ) {

	cmp	eax, 255				; 000000ffH
	jbe	SHORT $LN23@ExcFrameDi

; 1950 :             return( EmitError( SIZE_OF_PROLOG_TOO_BIG ) );

	mov	ecx, 259				; 00000103H
	call	EmitError
	jmp	$LN68@ExcFrameDi
$LN23@ExcFrameDi:

; 1951 :         }
; 1952 :         unw_info.SizeOfProlog = (uint_8)opndx.uvalue;

	movzx	eax, BYTE PTR opndx$[rbp-105]
	mov	BYTE PTR unw_info+1, al

; 1953 :         endprolog_found = TRUE;

	mov	BYTE PTR endprolog_found, 1
$LN63@ExcFrameDi:

; 1954 :         break;

	mov	r8d, DWORD PTR i$[rbp-105]
$LN62@ExcFrameDi:

; 2044 :             }
; 2045 :             puc->CodeOffset = ofs;
; 2046 :             puc->OpInfo = reg;

	movzx	ecx, BYTE PTR unw_info+2
$LN4@ExcFrameDi:

; 2076 :             break;
; 2077 :         }
; 2078 :         break;
; 2079 :     }
; 2080 :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+r15], 0
	je	$LN54@ExcFrameDi

; 2081 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rax+r15+8]
	jmp	$LN78@ExcFrameDi
$LN24@ExcFrameDi:

; 1955 :     case T_DOT_PUSHFRAME: /* syntax: .PUSHFRAME [code] */
; 1956 :         puc->CodeOffset = ofs;
; 1957 :         puc->UnwindOp = UWOP_PUSH_MACHFRAME;
; 1958 :         puc->OpInfo = 0;
; 1959 :         if ( tokenarray[i].token == T_ID && (_stricmp( tokenarray[i].string_ptr, "CODE") == 0 ) ) {

	movsxd	rax, r8d
	shl	rax, 5
	mov	BYTE PTR [rbx], r12b
	mov	BYTE PTR [rbx+1], 10
	cmp	BYTE PTR [rax+r15], 8
	jne	SHORT $LN25@ExcFrameDi
	mov	rcx, QWORD PTR [rax+r15+8]
	lea	rdx, OFFSET FLAT:$SG12039
	call	_stricmp

; 1961 :             i++;

	mov	r8d, DWORD PTR i$[rbp-105]
	test	eax, eax
	jne	SHORT $LN25@ExcFrameDi

; 1960 :             puc->OpInfo = 1;

	and	BYTE PTR [rbx+1], 15
	or	BYTE PTR [rbx+1], 16

; 1961 :             i++;

	inc	r8d
	mov	DWORD PTR i$[rbp-105], r8d
$LN25@ExcFrameDi:

; 1962 :         }
; 1963 :         unw_info.CountOfCodes++;

	movzx	ecx, BYTE PTR unw_info+2
	inc	cl
	mov	BYTE PTR unw_info+2, cl

; 1964 :         break;

	jmp	SHORT $LN4@ExcFrameDi
$LN26@ExcFrameDi:

; 1965 :     case T_DOT_PUSHREG: /* syntax: .PUSHREG r64 */
; 1966 :         if ( tokenarray[i].token != T_REG || !( GetValueSp( tokenarray[i].tokval ) & OP_R64 ) ) {

	movsxd	r9, r8d
	shl	r9, 5
	add	r9, r15
	cmp	BYTE PTR [r9], 2
	jne	SHORT $LN28@ExcFrameDi
	mov	eax, DWORD PTR [r9+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	test	BYTE PTR SpecialTable[rsi+rcx*4], 8
	je	SHORT $LN28@ExcFrameDi

; 1968 :         }
; 1969 :         puc->CodeOffset = ofs;
; 1970 :         puc->UnwindOp = UWOP_PUSH_NONVOL;

	and	BYTE PTR [rbx+1], 240			; 000000f0H
	movzx	edx, BYTE PTR [rbx+1]

; 1971 :         puc->OpInfo = GetRegNo( tokenarray[i].tokval );

	and	dl, 15
	mov	BYTE PTR [rbx], r12b
	mov	eax, DWORD PTR [r9+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR SpecialTable[rsi+rcx*4+10]

; 1972 :         unw_info.CountOfCodes++;

	movzx	ecx, BYTE PTR unw_info+2
	shl	al, 4
	inc	cl
	or	al, dl
	mov	BYTE PTR unw_info+2, cl

; 1973 :         i++;

	inc	r8d
	mov	BYTE PTR [rbx+1], al
	mov	DWORD PTR i$[rbp-105], r8d

; 1974 :         break;

	jmp	$LN4@ExcFrameDi
$LN28@ExcFrameDi:

; 1967 :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [r9+8]
	jmp	SHORT $LN78@ExcFrameDi
$LN29@ExcFrameDi:

; 1975 :     case T_DOT_SAVEREG:    /* syntax: .SAVEREG r64, offset       */
; 1976 :     case T_DOT_SAVEXMM128: /* syntax: .SAVEXMM128 xmmreg, offset */
; 1977 :     case T_DOT_SAVEYMM256: /* syntax: .SAVEYMM256 ymmreg, offset */
; 1978 : #if EVEXSUPP
; 1979 :     case T_DOT_SAVEZMM512: /* syntax: .SAVEXMM512 zmmreg, offset */
; 1980 : #endif
; 1981 :     case T_DOT_SETFRAME:   /* syntax: .SETFRAME r64, offset      */
; 1982 :         if ( tokenarray[i].token != T_REG ) {

	movsxd	rdx, r8d
	shl	rdx, 5
	add	rdx, r15
	cmp	BYTE PTR [rdx], 2
	jne	SHORT $LN77@ExcFrameDi

; 1983 :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );
; 1984 :         }
; 1985 :         if ( token == T_DOT_SAVEXMM128 ) {
; 1986 :             if ( !( GetValueSp( tokenarray[i].tokval ) & OP_XMM ) ) {

	mov	eax, DWORD PTR [rdx+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rcx, QWORD PTR [rcx*4]
	cmp	edi, 418				; 000001a2H
	jne	SHORT $LN31@ExcFrameDi
	test	BYTE PTR SpecialTable[rcx+rsi], 32	; 00000020H
$LN79@ExcFrameDi:

; 1991 :           if (!(GetValueSp(tokenarray[i].tokval) & OP_YMM)) {

	jne	SHORT $LN37@ExcFrameDi
$LN77@ExcFrameDi:

; 1992 :             return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr));

	mov	rdx, QWORD PTR [rdx+8]
$LN78@ExcFrameDi:

; 2016 :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN68@ExcFrameDi:
	mov	r12, QWORD PTR [rsp+168]
	mov	rdi, QWORD PTR [rsp+232]
	mov	rsi, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [rsp+216]
	mov	r14, QWORD PTR [rsp+160]

; 2089 : }

	add	rsp, 176				; 000000b0H
	pop	r15
	pop	r13
	pop	rbp
	ret	0
$LN31@ExcFrameDi:

; 1987 :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );
; 1988 :             }
; 1989 :         } 
; 1990 :         else if (token == T_DOT_SAVEYMM256) {

	cmp	edi, 419				; 000001a3H
	jne	SHORT $LN34@ExcFrameDi

; 1991 :           if (!(GetValueSp(tokenarray[i].tokval) & OP_YMM)) {

	test	BYTE PTR SpecialTable[rcx+rsi], 128	; 00000080H

; 1992 :             return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr));

	jmp	SHORT $LN79@ExcFrameDi
$LN34@ExcFrameDi:

; 1993 :           }
; 1994 :         }
; 1995 : #if EVEXSUPP
; 1996 :         else if (token == T_DOT_SAVEZMM512) {
; 1997 :           if (!(GetValueSp(tokenarray[i].tokval) & OP_ZMM)) {
; 1998 :             return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr));
; 1999 :           }
; 2000 :         }
; 2001 : #endif
; 2002 :         else {
; 2003 :             if ( !( GetValueSp( tokenarray[i].tokval ) & OP_R64 ) ) {

	test	BYTE PTR SpecialTable[rcx+rsi], 8

; 2004 :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jmp	SHORT $LN79@ExcFrameDi
$LN37@ExcFrameDi:

; 2005 :             }
; 2006 :         }
; 2007 :         reg = GetRegNo( tokenarray[i].tokval );

	movzx	esi, BYTE PTR SpecialTable[rcx+rsi+10]

; 2008 : 
; 2009 :         if ( token == T_DOT_SAVEREG )

	cmp	edi, 417				; 000001a1H
	mov	eax, 8
	mov	r14d, 16
	cmove	r14d, eax

; 2010 :             size = 8;
; 2011 :         else
; 2012 :             size = 16;
; 2013 : 
; 2014 :         i++;

	inc	r8d

; 2015 :         if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rdx, r8d
	shl	rdx, 5
	mov	DWORD PTR i$[rbp-105], r8d
	cmp	BYTE PTR [rdx+r15], 44			; 0000002cH
	je	SHORT $LN40@ExcFrameDi

; 2016 :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+r15+8]
	jmp	$LN78@ExcFrameDi
$LN40@ExcFrameDi:

; 2017 :         }
; 2018 :         i++;

	inc	r8d

; 2019 :         if ( ERROR == EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) )

	mov	BYTE PTR [rsp+32], 0
	mov	DWORD PTR i$[rbp-105], r8d
	lea	r9, QWORD PTR opndx$[rbp-105]
	mov	r8d, DWORD PTR ModuleInfo+496
	lea	rcx, QWORD PTR i$[rbp-105]
	mov	rdx, r15
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN41@ExcFrameDi
$LN76@ExcFrameDi:

; 2020 :             return( ERROR );

	or	eax, -1
	jmp	$LN68@ExcFrameDi
$LN41@ExcFrameDi:

; 2021 :         if ( opndx.kind == EXPR_ADDR && opndx.sym->state == SYM_UNDEFINED ) /* v2.11: allow forward references */

	mov	eax, DWORD PTR opndx$[rbp-45]
	cmp	eax, 1
	jne	SHORT $LN42@ExcFrameDi
	mov	rax, QWORD PTR opndx$[rbp-25]
	cmp	DWORD PTR [rax+32], 0

; 2022 :              ;
; 2023 :         else if ( opndx.kind != EXPR_CONST ) {

	jmp	SHORT $LN70@ExcFrameDi
$LN42@ExcFrameDi:
	test	eax, eax
$LN70@ExcFrameDi:
	je	SHORT $LN44@ExcFrameDi
$LN75@ExcFrameDi:

; 2024 :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN68@ExcFrameDi
$LN44@ExcFrameDi:

; 2025 :         }
; 2026 :         if ( opndx.value & (size - 1) ) {

	mov	ecx, DWORD PTR opndx$[rbp-105]
	lea	eax, DWORD PTR [r14-1]
	test	eax, ecx
	je	SHORT $LN45@ExcFrameDi
$LN74@ExcFrameDi:

; 2027 :             return( EmitError( BAD_ALIGNMENT_FOR_OFFSET_IN_UNWIND_CODE ) );

	mov	ecx, 257				; 00000101H
	call	EmitError
	jmp	$LN68@ExcFrameDi
$LN45@ExcFrameDi:

; 2028 :         }
; 2029 :         switch ( token ) {

	sub	edi, 417				; 000001a1H
	je	$LN46@ExcFrameDi
	sub	edi, 1
	je	SHORT $LN49@ExcFrameDi
	cmp	edi, 2
	jne	$LN63@ExcFrameDi

; 2065 :         case T_DOT_SETFRAME:
; 2066 :             if ( opndx.uvalue > 240 ) {

	cmp	ecx, 240				; 000000f0H
	jbe	SHORT $LN53@ExcFrameDi
$LN73@ExcFrameDi:

; 2067 :                 return( EmitConstError( &opndx ) );

	lea	rcx, QWORD PTR opndx$[rbp-105]
	call	EmitConstError
	jmp	$LN68@ExcFrameDi
$LN53@ExcFrameDi:

; 2068 :             }
; 2069 :             unw_info.FrameRegister = reg;
; 2070 :             unw_info.FrameOffset = ( opndx.uvalue >> 4 );
; 2071 :             puc->CodeOffset = ofs;
; 2072 :             puc->UnwindOp = UWOP_SET_FPREG;
; 2073 :             //puc->OpInfo = ( opndx.uvalue >> 4 );
; 2074 :             puc->OpInfo = reg;
; 2075 :             unw_info.CountOfCodes++;

	mov	r8d, DWORD PTR i$[rbp-105]
	movzx	eax, sil
	shr	ecx, 4
	and	al, 15
	shl	cl, 4
	or	cl, al
	shl	sil, 4
	mov	BYTE PTR unw_info+3, cl
	or	sil, 3
	movzx	ecx, BYTE PTR unw_info+2
	inc	cl
	mov	BYTE PTR [rbx], r12b
	mov	BYTE PTR unw_info+2, cl
	mov	BYTE PTR [rbx+1], sil
	jmp	$LN4@ExcFrameDi
$LN49@ExcFrameDi:

; 2047 :             break;
; 2048 :         case T_DOT_SAVEXMM128:
; 2049 :             if ( opndx.value > 65536 * size ) {

	shl	r14d, 16
	cmp	ecx, r14d
	jbe	SHORT $LN50@ExcFrameDi

; 2050 :                 puc->FrameOffset = ( opndx.value >> 20 );

	mov	eax, ecx

; 2051 :                 puc++;
; 2052 :                 puc->FrameOffset = ( opndx.value >> 4 );

	sar	ecx, 4
	sar	eax, 20
	mov	WORD PTR [rbx], ax
	mov	WORD PTR [rbx+2], cx

; 2053 :                 puc++;

	add	rbx, 4

; 2054 :                 puc->UnwindOp = UWOP_SAVE_XMM128_FAR;
; 2055 :                 unw_info.CountOfCodes += 3;

	movzx	ecx, BYTE PTR unw_info+2
	and	BYTE PTR [rbx+1], 249			; 000000f9H
	or	BYTE PTR [rbx+1], 9
	add	cl, 3

; 2056 :             } else {

	jmp	SHORT $LN71@ExcFrameDi
$LN50@ExcFrameDi:

; 2057 :                 puc->FrameOffset = ( opndx.value >> 4 );

	sar	ecx, 4
	mov	WORD PTR [rbx], cx

; 2058 :                 puc++;

	add	rbx, 2

; 2059 :                 puc->UnwindOp = UWOP_SAVE_XMM128;
; 2060 :                 unw_info.CountOfCodes += 2;

	movzx	ecx, BYTE PTR unw_info+2
	and	BYTE PTR [rbx+1], 248			; 000000f8H
	or	BYTE PTR [rbx+1], 8
	add	cl, 2
$LN71@ExcFrameDi:

; 2061 :             }
; 2062 :             puc->CodeOffset = ofs;
; 2063 :             puc->OpInfo = reg;

	and	BYTE PTR [rbx+1], 15

; 2064 :             break;

	mov	r8d, DWORD PTR i$[rbp-105]
	shl	sil, 4
	or	BYTE PTR [rbx+1], sil
	mov	BYTE PTR unw_info+2, cl
	mov	BYTE PTR [rbx], r12b
	jmp	$LN4@ExcFrameDi
$LN46@ExcFrameDi:

; 2030 :         case T_DOT_SAVEREG:
; 2031 :             puc->OpInfo = reg;

	and	BYTE PTR [rbx+1], 15
	shl	sil, 4
	or	BYTE PTR [rbx+1], sil

; 2032 :             if ( opndx.value > 65536 * size ) {

	shl	r14d, 16
	cmp	ecx, r14d
	jbe	SHORT $LN47@ExcFrameDi

; 2033 :                 puc->FrameOffset = ( opndx.value >> 19 );

	mov	eax, ecx

; 2034 :                 puc++;
; 2035 :                 puc->FrameOffset = ( opndx.value >> 3 );

	sar	ecx, 3
	sar	eax, 19
	mov	WORD PTR [rbx], ax
	mov	WORD PTR [rbx+2], cx

; 2036 :                 puc++;

	add	rbx, 4

; 2037 :                 puc->UnwindOp = UWOP_SAVE_NONVOL_FAR;
; 2038 :                 unw_info.CountOfCodes += 3;

	movzx	ecx, BYTE PTR unw_info+2
	and	BYTE PTR [rbx+1], 245			; 000000f5H
	or	BYTE PTR [rbx+1], 5
	add	cl, 3

; 2039 :             } else {

	jmp	SHORT $LN72@ExcFrameDi
$LN47@ExcFrameDi:

; 2040 :                 puc->FrameOffset = ( opndx.value >> 3 );

	sar	ecx, 3
	mov	WORD PTR [rbx], cx

; 2041 :                 puc++;

	add	rbx, 2

; 2042 :                 puc->UnwindOp = UWOP_SAVE_NONVOL;
; 2043 :                 unw_info.CountOfCodes += 2;

	movzx	ecx, BYTE PTR unw_info+2
	and	BYTE PTR [rbx+1], 244			; 000000f4H
	or	BYTE PTR [rbx+1], 4
	add	cl, 2
$LN72@ExcFrameDi:

; 2044 :             }
; 2045 :             puc->CodeOffset = ofs;
; 2046 :             puc->OpInfo = reg;

	and	BYTE PTR [rbx+1], 15
	or	BYTE PTR [rbx+1], sil
	mov	r8d, DWORD PTR i$[rbp-105]
	mov	BYTE PTR unw_info+2, cl
	mov	BYTE PTR [rbx], r12b
	jmp	$LN4@ExcFrameDi
$LN54@ExcFrameDi:

; 2082 :     }
; 2083 :     /* v2.11: check if the table of codes has been exceeded */
; 2084 :     if ( oldcodes > unw_info.CountOfCodes ) {

	cmp	r13b, cl
	jbe	SHORT $LN55@ExcFrameDi

; 2085 :         return( EmitErr( TOO_MANY_UNWIND_CODES_IN_FRAME_PROC ) );

	mov	ecx, 210				; 000000d2H
	call	EmitErr
	jmp	$LN68@ExcFrameDi
$LN55@ExcFrameDi:

; 2086 :     }
; 2087 :     DebugMsg1(("ExcFrameDirective() exit, ok\n" ));
; 2088 :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN68@ExcFrameDi
$LN8@ExcFrameDi:

; 1880 :         return( EmitError( ENDPROLOG_FOUND_BEFORE_EH_DIRECTIVES ) );

	mov	ecx, 255				; 000000ffH
	call	EmitError

; 2089 : }

	add	rsp, 176				; 000000b0H
	pop	r15
	pop	r13
	pop	rbp
	ret	0
	npad	1
$LN60@ExcFrameDi:
	DD	$LN10@ExcFrameDi
	DD	$LN22@ExcFrameDi
	DD	$LN24@ExcFrameDi
	DD	$LN26@ExcFrameDi
	DD	$LN29@ExcFrameDi
	DD	$LN29@ExcFrameDi
	DD	$LN29@ExcFrameDi
	DD	$LN29@ExcFrameDi
ExcFrameDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
EndpDir	PROC

; 1832 : {

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 1833 :     DebugMsg1(("EndpDir(%s) enter, curr ofs=% " I32_SPEC "X, CurrProc=%s\n", tokenarray[0].string_ptr, GetCurrOffset(), CurrProc ? CurrProc->sym.name : "NULL" ));
; 1834 :     if( i != 1 || tokenarray[2].token != T_FINAL ) {

	cmp	ecx, 1
	jne	SHORT $LN3@EndpDir
	cmp	BYTE PTR [rdx+64], 0
	jne	SHORT $LN3@EndpDir

; 1836 :     }
; 1837 :     /* v2.10: "+ 1" added to CurrProc->sym.name_size */
; 1838 :     if( CurrProc &&

	mov	rcx, QWORD PTR CurrProc
	test	rcx, rcx
	je	SHORT $LN4@EndpDir
	movzx	eax, BYTE PTR [rcx+72]
	mov	rdx, QWORD PTR [rdx+8]
	inc	eax
	mov	rcx, QWORD PTR [rcx+8]
	movsxd	r8, eax
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	jne	SHORT $LN4@EndpDir

; 1839 :        ( SymCmpFunc(CurrProc->sym.name, tokenarray[0].string_ptr, CurrProc->sym.name_size + 1 ) == 0 ) ) {
; 1840 :         ProcFini( CurrProc );

	mov	rcx, QWORD PTR CurrProc
	call	ProcFini

; 1843 :     }
; 1844 :     return( NOT_ERROR );

	xor	eax, eax

; 1845 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@EndpDir:

; 1841 :     } else {
; 1842 :         return( EmitErr( UNMATCHED_BLOCK_NESTING, tokenarray[0].string_ptr ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 142				; 0000008eH

; 1845 : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 1841 :     } else {
; 1842 :         return( EmitErr( UNMATCHED_BLOCK_NESTING, tokenarray[0].string_ptr ) );

	jmp	EmitErr
$LN3@EndpDir:

; 1835 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbx+24]

; 1845 : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 1835 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	jmp	EmitErr
EndpDir	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT ProcFini
_TEXT	SEGMENT
proc$ = 48
ProcFini PROC						; COMDAT

; 1756 : {

	sub	rsp, 40					; 00000028H

; 1757 :     struct dsym *curr;
; 1758 :     /* v2.06: emit an error if current segment isn't equal to
; 1759 :      * the one of the matching PROC directive. Close the proc anyway!
; 1760 :      */
; 1761 :     if ( proc->sym.segment == &CurrSeg->sym ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rsp+32], rdi
	mov	rdi, rcx
	cmp	QWORD PTR [rcx+24], rax
	jne	SHORT $LN14@ProcFini

; 1762 :         proc->sym.total_size = GetCurrOffset() - proc->sym.offset;

	call	GetCurrOffset

; 1763 :     } else {

	jmp	SHORT $LN52@ProcFini
$LN14@ProcFini:

; 1764 :         DebugMsg1(("ProcFini(%s): unmatched block nesting error, proc->seg=%s, CurrSeg=%s\n",
; 1765 :                    proc->sym.name, proc->sym.segment->name, CurrSeg ? CurrSeg->sym.name : "NULL" ));
; 1766 :         EmitErr( UNMATCHED_BLOCK_NESTING, proc->sym.name );

	mov	rdx, QWORD PTR [rcx+8]
	mov	ecx, 142				; 0000008eH
	call	EmitErr

; 1767 :         proc->sym.total_size = CurrProc->sym.segment->offset - proc->sym.offset;

	mov	rax, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rax+24]
	mov	eax, DWORD PTR [rcx+16]
$LN52@ProcFini:
	sub	eax, DWORD PTR [rdi+16]
	mov	DWORD PTR [rdi+56], eax

; 1768 :     }
; 1769 : 
; 1770 :     /* v2.03: for W3+, check for unused params and locals */
; 1771 :     if ( Options.warning_level > 2 && Parse_Pass == PASS_1 ) {

	cmp	BYTE PTR Options+13, 2
	jbe	SHORT $LN49@ProcFini
	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN50@ProcFini

; 1772 :         for ( curr = proc->e.procinfo->paralist; curr; curr = curr->nextparam ) {

	mov	rax, QWORD PTR [rdi+96]
	mov	QWORD PTR [rsp+48], rbx
	mov	rbx, QWORD PTR [rax+8]
	test	rbx, rbx
	je	SHORT $LN3@ProcFini
	npad	6
$LL4@ProcFini:

; 1773 :             if ( curr->sym.used == FALSE )

	test	BYTE PTR [rbx+40], 1
	jne	SHORT $LN2@ProcFini

; 1774 :                 EmitWarn( 3, PROCEDURE_ARGUMENT_OR_LOCAL_NOT_REFERENCED, curr->sym.name );

	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 266				; 0000010aH
	mov	ecx, 3
	call	EmitWarn
$LN2@ProcFini:

; 1772 :         for ( curr = proc->e.procinfo->paralist; curr; curr = curr->nextparam ) {

	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL4@ProcFini
$LN3@ProcFini:

; 1775 :         }
; 1776 :         for ( curr = proc->e.procinfo->locallist; curr; curr = curr->nextlocal ) {

	mov	rax, QWORD PTR [rdi+96]
	mov	rbx, QWORD PTR [rax+16]
	test	rbx, rbx
	je	SHORT $LN51@ProcFini
	npad	1
$LL7@ProcFini:

; 1777 :             if ( curr->sym.used == FALSE )

	test	BYTE PTR [rbx+40], 1
	jne	SHORT $LN5@ProcFini

; 1778 :                 EmitWarn( 3, PROCEDURE_ARGUMENT_OR_LOCAL_NOT_REFERENCED, curr->sym.name );

	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 266				; 0000010aH
	mov	ecx, 3
	call	EmitWarn
$LN5@ProcFini:

; 1775 :         }
; 1776 :         for ( curr = proc->e.procinfo->locallist; curr; curr = curr->nextlocal ) {

	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL7@ProcFini
$LN51@ProcFini:
	mov	rbx, QWORD PTR [rsp+48]
$LN49@ProcFini:

; 1779 :         }
; 1780 :     }
; 1781 : #if AMD64_SUPPORT
; 1782 :     /* save stack space reserved for INVOKE if OPTION WIN64:2 is set */
; 1783 :     if ( Parse_Pass == PASS_1 &&
; 1784 :         ModuleInfo.fctype == FCT_WIN64 &&

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN50@ProcFini
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN50@ProcFini
	test	BYTE PTR ModuleInfo+413, 2
	je	SHORT $LN50@ProcFini

; 1785 :         ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) ) {
; 1786 :         proc->e.procinfo->ReservedStack = sym_ReservedStack->value;

	mov	rax, QWORD PTR sym_ReservedStack
	mov	rdx, QWORD PTR [rdi+96]
	mov	ecx, DWORD PTR [rax+16]
	mov	DWORD PTR [rdx+56], ecx

; 1787 :         DebugMsg1(("ProcFini(%s): localsize=%u ReservedStack=%u\n", proc->sym.name, proc->e.procinfo->localsize, proc->e.procinfo->ReservedStack ));
; 1788 : #if STACKBASESUPP
; 1789 :         if ( proc->e.procinfo->fpo ) {

	mov	rdx, QWORD PTR [rdi+96]
	test	BYTE PTR [rdx+84], 128			; 00000080H
	je	SHORT $LN50@ProcFini

; 1790 :             for ( curr = proc->e.procinfo->locallist; curr; curr = curr->nextlocal ) {

	mov	rdx, QWORD PTR [rdx+16]
	test	rdx, rdx
	je	SHORT $LN9@ProcFini
	npad	10
$LL10@ProcFini:

; 1791 :                 DebugMsg1(("ProcFini(%s): FPO, offset for %s %8d -> %8d\n", proc->sym.name, curr->sym.name, curr->sym.offset, curr->sym.offset + proc->e.procinfo->ReservedStack ));
; 1792 :                 curr->sym.offset += proc->e.procinfo->ReservedStack;

	mov	rax, QWORD PTR [rdi+96]
	mov	ecx, DWORD PTR [rax+56]
	add	DWORD PTR [rdx+16], ecx
	mov	rdx, QWORD PTR [rdx+112]
	test	rdx, rdx
	jne	SHORT $LL10@ProcFini
$LN9@ProcFini:

; 1793 :             }
; 1794 :             for ( curr = proc->e.procinfo->paralist; curr; curr = curr->nextparam ) {

	mov	rax, QWORD PTR [rdi+96]
	mov	rdx, QWORD PTR [rax+8]
	test	rdx, rdx
	je	SHORT $LN50@ProcFini
$LL13@ProcFini:

; 1795 :                 DebugMsg1(("ProcFini(%s): FPO, offset for %s %8d -> %8d\n", proc->sym.name, curr->sym.name, curr->sym.offset, curr->sym.offset + proc->e.procinfo->ReservedStack ));
; 1796 :                 curr->sym.offset += proc->e.procinfo->ReservedStack;

	mov	rax, QWORD PTR [rdi+96]
	mov	ecx, DWORD PTR [rax+56]
	add	DWORD PTR [rdx+16], ecx
	mov	rdx, QWORD PTR [rdx+112]
	test	rdx, rdx
	jne	SHORT $LL13@ProcFini
$LN50@ProcFini:

; 1797 :             }
; 1798 :         }
; 1799 : #endif
; 1800 :     }
; 1801 : 
; 1802 :     /* create the .pdata and .xdata stuff */
; 1803 :     if ( proc->e.procinfo->isframe ) {

	mov	rax, QWORD PTR [rdi+96]
	test	BYTE PTR [rax+84], 64			; 00000040H
	je	SHORT $LN21@ProcFini

; 1804 : #if FASTPASS
; 1805 :         LstSetPosition(); /* needed if generated code is done BEFORE the line is listed */

	call	LstSetPosition

; 1806 : #endif
; 1807 :         WriteSEHData( proc );

	mov	rcx, rdi
	call	WriteSEHData
$LN21@ProcFini:

; 1808 :     }
; 1809 : #endif
; 1810 :     if ( ModuleInfo.list )

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	mov	rdi, QWORD PTR [rsp+32]
	je	SHORT $LN22@ProcFini

; 1811 :         LstWrite( LSTTYPE_LABEL, 0, NULL );

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+7]
	call	LstWrite
$LN22@ProcFini:

; 1812 : 
; 1813 :     /* create the list of locals */
; 1814 :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN23@ProcFini

; 1815 :         /* in case the procedure is empty, init addresses of local variables ( for proper listing ) */
; 1816 :         if( ProcStatus & PRST_PROLOGUE_NOT_DONE )

	test	BYTE PTR ProcStatus, -128		; ffffffffffffff80H
	je	SHORT $LN24@ProcFini

; 1817 :             SetLocalOffsets( CurrProc->e.procinfo );

	mov	rcx, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rcx+96]
	call	SetLocalOffsets
$LN24@ProcFini:

; 1818 :         SymGetLocal( (struct asym *)CurrProc );

	mov	rcx, QWORD PTR CurrProc
	call	SymGetLocal
$LN23@ProcFini:

; 1819 :     }
; 1820 : 
; 1821 :     CurrProc = pop_proc();

	mov	rcx, QWORD PTR ProcStack
	test	rcx, rcx
	jne	SHORT $LN28@ProcFini
	xor	eax, eax
	mov	QWORD PTR CurrProc, rax

; 1824 : 
; 1825 :     ProcStatus = 0; /* in case there was an empty PROC/ENDP pair */

	mov	DWORD PTR ProcStatus, eax

; 1826 : }

	add	rsp, 40					; 00000028H
	ret	0

; 1819 :     }
; 1820 : 
; 1821 :     CurrProc = pop_proc();

$LN28@ProcFini:
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR ProcStack, rax
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR CurrProc, rcx

; 1822 :     if ( CurrProc )

	test	rcx, rcx
	je	SHORT $LN48@ProcFini

; 1823 :         SymSetLocal( (struct asym *)CurrProc );  /* restore local symbol table */

	call	SymSetLocal
$LN48@ProcFini:

; 1824 : 
; 1825 :     ProcStatus = 0; /* in case there was an empty PROC/ENDP pair */

	xor	eax, eax
	mov	DWORD PTR ProcStatus, eax

; 1826 : }

	add	rsp, 40					; 00000028H
	ret	0
ProcFini ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT SetLocalOffsets
_TEXT	SEGMENT
paramadj$1 = 48
info$ = 48
SetLocalOffsets PROC					; COMDAT

; 2711 : {

	push	rbp
	push	r14
	push	r15
	sub	rsp, 16

; 2712 :     struct dsym *curr;
; 2713 : #if AMD64_SUPPORT || STACKBASESUPP
; 2714 :     int         cntxmm = 0;
; 2715 :     int         cntstd = 0;
; 2716 :     int         start = 0;
; 2717 : #endif
; 2718 : #if AMD64_SUPPORT
; 2719 :     int         rspalign = FALSE;
; 2720 : #endif
; 2721 :     int         align = CurrWordSize;
; 2722 : #if AMD64_SUPPORT
; 2723 :     if ( info->isframe || ( ModuleInfo.fctype == FCT_WIN64 && ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) ) ) {

	movzx	r9d, BYTE PTR ModuleInfo+413
	xor	edx, edx
	mov	QWORD PTR [rsp+56], rbx
	xor	r14d, r14d
	movzx	ebx, BYTE PTR ModuleInfo+406
	xor	ebp, ebp
	mov	QWORD PTR [rsp+64], rsi
	xor	r15d, r15d
	mov	QWORD PTR [rsp+8], rdi
	mov	r8, rcx
	movzx	edi, BYTE PTR [rcx+84]
	mov	esi, ebx
	test	dil, 64					; 00000040H
	jne	SHORT $LN15@SetLocalOf
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN16@SetLocalOf
	test	r9b, 2
	je	SHORT $LN16@SetLocalOf
$LN15@SetLocalOf:

; 2724 :         rspalign = TRUE;
; 2725 :         if ( ModuleInfo.win64_flags & W64F_STACKALIGN16 )

	movzx	eax, r9b
	mov	ecx, 16
	and	al, 4
	mov	r15d, 1
	cmovne	esi, ecx
$LN16@SetLocalOf:

; 2726 :             align = 16;
; 2727 :     }
; 2728 : #endif
; 2729 : #if AMD64_SUPPORT || STACKBASESUPP
; 2730 :     /* in 64-bit, if the FRAME attribute is set, the space for the registers
; 2731 :      * saved by the USES clause is located ABOVE the local variables!
; 2732 :      * v2.09: if stack space is to be reserved for INVOKE ( option WIN64:2 ),
; 2733 :      * the registers are also saved ABOVE the local variables.
; 2734 :      */
; 2735 :     if (
; 2736 : #if STACKBASESUPP
; 2737 :         info->fpo
; 2738 : #endif
; 2739 : #if AMD64_SUPPORT
; 2740 :         || rspalign

	shr	dil, 7
	test	dil, dil
	jne	SHORT $LN18@SetLocalOf
	test	r15d, r15d
	je	$LN28@SetLocalOf
$LN18@SetLocalOf:

; 2741 : #endif
; 2742 :        ) {
; 2743 :         /* count registers to be saved ABOVE local variables.
; 2744 :          * v2.06: the list may contain xmm registers, which have size 16!
; 2745 :          */
; 2746 :         if ( info->regslist ) {

	mov	r10, QWORD PTR [r8]
	test	r10, r10
	je	SHORT $LN3@SetLocalOf

; 2747 :             int         cnt;
; 2748 :             uint_16     *regs;
; 2749 :             for( regs = info->regslist, cnt = *regs++; cnt; cnt--, regs++ )

	movzx	r11d, WORD PTR [r10]
	add	r10, 2
	test	r11d, r11d
	je	SHORT $LN3@SetLocalOf
	mov	QWORD PTR [rsp], r12
	lea	r12, OFFSET FLAT:SpecialTable
	npad	10
$LL4@SetLocalOf:

; 2750 :                 if ( GetValueSp( *regs ) & OP_XYZMM )

	movzx	eax, WORD PTR [r10]
	lea	rcx, QWORD PTR [rax+rax*2]
	test	BYTE PTR [r12+rcx*4], 128		; 00000080H
	je	SHORT $LN20@SetLocalOf

; 2751 :                     cntxmm++;

	inc	edx
	jmp	SHORT $LN2@SetLocalOf
$LN20@SetLocalOf:

; 2752 :                 else
; 2753 :                     cntstd++;

	inc	r14d
$LN2@SetLocalOf:

; 2747 :             int         cnt;
; 2748 :             uint_16     *regs;
; 2749 :             for( regs = info->regslist, cnt = *regs++; cnt; cnt--, regs++ )

	add	r10, 2
	sub	r11d, 1
	jne	SHORT $LL4@SetLocalOf
	mov	r12, QWORD PTR [rsp]
$LN3@SetLocalOf:

; 2754 :         }        
; 2755 :         /* in case there's no frame register, adjust start offset. */
; 2756 :         if ( info->parasize == 0 && info->locallist == NULL  )

	cmp	DWORD PTR [r8+32], ebp
	jne	SHORT $LN22@SetLocalOf
	cmp	QWORD PTR [r8+16], rbp
	cmove	ebp, ebx
$LN22@SetLocalOf:

; 2757 :             start = CurrWordSize;
; 2758 :         if (info->fpo && !(ModuleInfo.win64_flags & W64F_HABRAN)) start = CurrWordSize;

	test	dil, dil
	je	SHORT $LN23@SetLocalOf
	movzx	eax, r9b
	and	al, 11
	cmove	ebp, ebx
$LN23@SetLocalOf:

; 2759 : #if AMD64_SUPPORT
; 2760 :         if (ModuleInfo.win64_flags & W64F_HABRAN){

	test	r9b, 11
	je	SHORT $LN24@SetLocalOf

; 2761 :           info->localsize += start;

	add	DWORD PTR [r8+36], ebp

; 2762 :           cntstd = info->pushed_reg;

	mov	r14d, DWORD PTR [r8+64]

; 2763 :           if (rspalign && cntxmm) {

	test	r15d, r15d
	je	SHORT $LN65@SetLocalOf
	test	edx, edx
	je	SHORT $LN65@SetLocalOf

; 2764 :               //if ((cntstd & 1)) info->localsize += 8;
; 2765 :               info->localsize += XYZMMsize * cntxmm;

	shl	edx, 5
	add	DWORD PTR [r8+36], edx

; 2766 :               }
; 2767 :            }

	jmp	SHORT $LN65@SetLocalOf
$LN24@SetLocalOf:

; 2768 :         else {
; 2769 :           if (rspalign) {

	test	r15d, r15d
	je	SHORT $LN28@SetLocalOf

; 2770 :             info->localsize = start + cntstd * CurrWordSize;

	imul	ebx, r14d
	lea	eax, DWORD PTR [rbx+rbp]
	mov	DWORD PTR [r8+36], eax

; 2771 :             if (cntxmm) {

	test	edx, edx
	je	SHORT $LN65@SetLocalOf

; 2772 :               info->localsize += XYZMMsize * cntxmm;

	shl	edx, 5

; 2773 :               info->localsize = ROUND_UP(info->localsize, XYZMMsize);

	add	eax, 31
	add	eax, edx
	and	eax, -32				; ffffffe0H
	mov	DWORD PTR [r8+36], eax
$LN65@SetLocalOf:
	movzx	r9d, BYTE PTR ModuleInfo+413
$LN28@SetLocalOf:

; 2774 :             }
; 2775 :           }
; 2776 :         }
; 2777 : #endif
; 2778 :         DebugMsg1(("SetLocalOffsets(%s): cntxmm=%u cntstd=%u start=%u align=%u localsize=%u\n", CurrProc->sym.name, cntxmm, cntstd, start, align, info->localsize ));
; 2779 :     }
; 2780 : #endif
; 2781 : 
; 2782 :     /* scan the locals list and set member sym.offset */
; 2783 :     for( curr = info->locallist; curr; curr = curr->nextlocal ) {

	mov	r10, QWORD PTR [r8+16]
	mov	rdi, QWORD PTR [rsp+8]
	mov	rbx, QWORD PTR [rsp+56]
	test	r10, r10
	je	$LN6@SetLocalOf
$LL7@SetLocalOf:

; 2784 :         uint_32 itemsize = ( curr->sym.total_size == 0 ? 0 : curr->sym.total_size / curr->sym.total_length );

	mov	r11d, DWORD PTR [r10+56]
	test	r11d, r11d
	jne	SHORT $LN47@SetLocalOf
	xor	edx, edx
	jmp	SHORT $LN48@SetLocalOf
$LN47@SetLocalOf:
	xor	edx, edx
	mov	eax, r11d
	div	DWORD PTR [r10+64]
	mov	edx, eax
$LN48@SetLocalOf:

; 2785 :         if (ModuleInfo.win64_flags & W64F_HABRAN){

	test	r9b, 11
	je	SHORT $LN29@SetLocalOf

; 2786 :           int n = 0;

	xor	ecx, ecx

; 2787 :           if (curr->sym.isarray) n = curr->sym.total_size & 0x7;

	test	BYTE PTR [r10+41], 2
	je	SHORT $LN30@SetLocalOf
	mov	ecx, r11d
	and	ecx, 7
$LN30@SetLocalOf:

; 2788 :           curr->sym.offset = info->localsize + n; //that works

	add	ecx, DWORD PTR [r8+36]
	mov	DWORD PTR [r10+16], ecx
$LN29@SetLocalOf:

; 2789 :         }
; 2790 :         info->localsize += curr->sym.total_size;

	add	DWORD PTR [r8+36], r11d
	mov	eax, DWORD PTR [r8+36]

; 2791 :         if ( itemsize > align )

	cmp	edx, esi
	jbe	SHORT $LN31@SetLocalOf

; 2792 :             info->localsize = ROUND_UP( info->localsize, align );

	lea	ecx, DWORD PTR [rax-1]
	add	ecx, esi
	lea	eax, DWORD PTR [rsi-1]
	jmp	SHORT $LN67@SetLocalOf
$LN31@SetLocalOf:

; 2793 :         else if ( itemsize ) /* v2.04: skip if size == 0 */

	test	edx, edx
	je	SHORT $LN33@SetLocalOf

; 2794 :             info->localsize = ROUND_UP( info->localsize, itemsize );

	lea	ecx, DWORD PTR [rax-1]
	add	ecx, edx
	lea	eax, DWORD PTR [rdx-1]
$LN67@SetLocalOf:
	not	eax
	and	ecx, eax
	mov	DWORD PTR [r8+36], ecx
$LN33@SetLocalOf:

; 2795 :         if (!(ModuleInfo.win64_flags & W64F_HABRAN))

	movzx	r9d, BYTE PTR ModuleInfo+413
	test	r9b, 11
	jne	SHORT $LN5@SetLocalOf

; 2796 :         curr->sym.offset = - info->localsize;

	mov	eax, DWORD PTR [r8+36]
	neg	eax
	mov	DWORD PTR [r10+16], eax
	movzx	r9d, BYTE PTR ModuleInfo+413
$LN5@SetLocalOf:

; 2774 :             }
; 2775 :           }
; 2776 :         }
; 2777 : #endif
; 2778 :         DebugMsg1(("SetLocalOffsets(%s): cntxmm=%u cntstd=%u start=%u align=%u localsize=%u\n", CurrProc->sym.name, cntxmm, cntstd, start, align, info->localsize ));
; 2779 :     }
; 2780 : #endif
; 2781 : 
; 2782 :     /* scan the locals list and set member sym.offset */
; 2783 :     for( curr = info->locallist; curr; curr = curr->nextlocal ) {

	mov	r10, QWORD PTR [r10+112]
	test	r10, r10
	jne	$LL7@SetLocalOf
$LN6@SetLocalOf:
	mov	rsi, QWORD PTR [rsp+64]

; 2797 :         DebugMsg1(("SetLocalOffsets(%s): offset of %s (size=%u) set to %d\n", CurrProc->sym.name, curr->sym.name, curr->sym.total_size, curr->sym.offset));
; 2798 :     }
; 2799 : 
; 2800 :     /* v2.11: localsize must be rounded before offset adjustment if fpo */
; 2801 :     if (!(ModuleInfo.win64_flags & W64F_HABRAN))

	test	r9b, 11
	jne	SHORT $LN35@SetLocalOf

; 2802 :     info->localsize = ROUND_UP( info->localsize, CurrWordSize );

	movzx	ecx, BYTE PTR ModuleInfo+406
	lea	edx, DWORD PTR [rcx-1]
	add	edx, DWORD PTR [r8+36]
	lea	eax, DWORD PTR [rcx-1]
	not	eax
	and	edx, eax
	mov	DWORD PTR [r8+36], edx
	movzx	r9d, BYTE PTR ModuleInfo+413
$LN35@SetLocalOf:

; 2803 : #if AMD64_SUPPORT
; 2804 :     /* RSP 16-byte alignment? */
; 2805 :     if ( rspalign ) {

	test	r15d, r15d
	je	SHORT $LN38@SetLocalOf

; 2806 :       if (ModuleInfo.win64_flags & W64F_HABRAN)info->localsize = ROUND_UP(info->localsize, 8);

	mov	eax, DWORD PTR [r8+36]
	test	r9b, 11
	je	SHORT $LN37@SetLocalOf
	add	eax, 7
	and	eax, -8					; fffffff8H
	jmp	SHORT $LN68@SetLocalOf
$LN37@SetLocalOf:

; 2807 :       else  info->localsize = ROUND_UP( info->localsize, XYZMMsize);

	add	eax, 31
	and	eax, -32				; ffffffe0H
$LN68@SetLocalOf:
	mov	DWORD PTR [r8+36], eax
	movzx	r9d, BYTE PTR ModuleInfo+413
$LN38@SetLocalOf:

; 2808 :     }
; 2809 : #endif
; 2810 : 
; 2811 :     DebugMsg1(("SetLocalOffsets(%s): localsize=%u after processing locals\n", CurrProc->sym.name, info->localsize ));
; 2812 : 
; 2813 : #if STACKBASESUPP
; 2814 :     /* v2.11: recalculate offsets for params and locals if there's no frame pointer.
; 2815 :      * Problem in 64-bit: option win64:2 triggers the "stack space reservation" feature -
; 2816 :      * but the final value of this space is known at the procedure's END only.
; 2817 :      * Hence in this case the values calculated below are "preliminary".
; 2818 :      */
; 2819 :     if (info->fpo) {

	test	BYTE PTR [r8+84], 128			; 00000080H
	je	$LN12@SetLocalOf

; 2820 :       unsigned localadj;
; 2821 :       unsigned paramadj;
; 2822 : #if AMD64_SUPPORT
; 2823 :       if (rspalign) {

	test	r15d, r15d
	je	SHORT $LN40@SetLocalOf

; 2824 :         localadj = info->localsize;

	mov	r10d, DWORD PTR [r8+36]

; 2825 :         if (!(ModuleInfo.win64_flags & W64F_HABRAN))

	test	r9b, 11
	jne	SHORT $LN66@SetLocalOf

; 2826 :           paramadj = info->localsize - CurrWordSize - start;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	edx, r10d
	sub	edx, eax
	sub	edx, ebp

; 2827 :       }

	jmp	SHORT $LN41@SetLocalOf
$LN66@SetLocalOf:

; 2831 :         paramadj = info->localsize + cntstd * CurrWordSize - CurrWordSize;

	mov	edx, DWORD PTR paramadj$1[rsp]
	jmp	SHORT $LN41@SetLocalOf
$LN40@SetLocalOf:

; 2828 :       else {
; 2829 : #endif
; 2830 :         localadj = info->localsize + cntstd * CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406

; 2831 :         paramadj = info->localsize + cntstd * CurrWordSize - CurrWordSize;

	lea	edx, DWORD PTR [r14-1]
	mov	r10d, eax
	imul	edx, eax
	imul	r10d, r14d
	add	r10d, DWORD PTR [r8+36]
	add	edx, DWORD PTR [r8+36]
$LN41@SetLocalOf:

; 2832 : #if AMD64_SUPPORT
; 2833 :       }
; 2834 : #endif
; 2835 :       if (!(ModuleInfo.win64_flags & W64F_HABRAN)){

	test	r9b, 11
	jne	SHORT $LN45@SetLocalOf

; 2836 :         DebugMsg1(("SetLocalOffsets(%s): FPO, adjusting offsets\n", CurrProc->sym.name));
; 2837 :         /* subtract CurrWordSize value for params, since no space is required to save the frame pointer value */
; 2838 :         for (curr = info->locallist; curr; curr = curr->nextlocal) {

	mov	rax, QWORD PTR [r8+16]
	test	rax, rax
	je	SHORT $LN9@SetLocalOf
	npad	2
$LL10@SetLocalOf:

; 2839 :           DebugMsg1(("SetLocalOffsets(%s): FPO, offset for %s %4d -> %4d\n", CurrProc->sym.name, curr->sym.name, curr->sym.offset, curr->sym.offset + localadj));
; 2840 :           curr->sym.offset += localadj;

	add	DWORD PTR [rax+16], r10d
	mov	rax, QWORD PTR [rax+112]
	test	rax, rax
	jne	SHORT $LL10@SetLocalOf

; 2836 :         DebugMsg1(("SetLocalOffsets(%s): FPO, adjusting offsets\n", CurrProc->sym.name));
; 2837 :         /* subtract CurrWordSize value for params, since no space is required to save the frame pointer value */
; 2838 :         for (curr = info->locallist; curr; curr = curr->nextlocal) {

	movzx	r9d, BYTE PTR ModuleInfo+413
$LN9@SetLocalOf:

; 2841 :         }
; 2842 :         for (curr = info->paralist; curr; curr = curr->nextparam) {

	mov	rax, QWORD PTR [r8+8]
	test	rax, rax
	je	SHORT $LN12@SetLocalOf
	npad	2
$LL13@SetLocalOf:

; 2843 :           DebugMsg1(("SetLocalOffsets(%s): FPO, offset for %s %4d -> %4d\n", CurrProc->sym.name, curr->sym.name, curr->sym.offset, curr->sym.offset + paramadj));
; 2844 :           curr->sym.offset += paramadj;

	add	DWORD PTR [rax+16], edx
	mov	rax, QWORD PTR [rax+112]
	test	rax, rax
	jne	SHORT $LL13@SetLocalOf

; 2841 :         }
; 2842 :         for (curr = info->paralist; curr; curr = curr->nextparam) {

	movzx	r9d, BYTE PTR ModuleInfo+413
$LN12@SetLocalOf:

; 2845 :         }
; 2846 :       }
; 2847 :     }
; 2848 : #endif
; 2849 : 
; 2850 : #if AMD64_SUPPORT
; 2851 :     /* v2.12: if the space used for register saves has been added to localsize,
; 2852 :      * the part that covers "pushed" GPRs has to be subtracted now, before prologue code is generated.
; 2853 :      */
; 2854 :     if (!(ModuleInfo.win64_flags & W64F_HABRAN)){

	test	r9b, 11
	jne	SHORT $LN45@SetLocalOf

; 2855 :       if (rspalign) {

	test	r15d, r15d
	je	SHORT $LN45@SetLocalOf

; 2856 :         info->localsize -= cntstd * 8 + start;

	neg	ebp
	lea	eax, DWORD PTR [r14*8]
	sub	ebp, eax
	add	DWORD PTR [r8+36], ebp
$LN45@SetLocalOf:

; 2857 :         DebugMsg1(("SetLocalOffsets(%s): final localsize=%u\n", CurrProc->sym.name, info->localsize));
; 2858 :       }
; 2859 :     }
; 2860 : #endif
; 2861 : }

	add	rsp, 16
	pop	r15
	pop	r14
	pop	rbp
	ret	0
SetLocalOffsets ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT WriteSEHData
_TEXT	SEGMENT
segnamebuff$ = 64
buffer$ = 80
proc$ = 224
WriteSEHData PROC					; COMDAT

; 1656 : {

	mov	rax, rsp
	push	rsi
	sub	rsp, 208				; 000000d0H

; 1657 :     struct dsym *xdata;
; 1658 :     char *segname = ".xdata";
; 1659 :     int i;
; 1660 :     int simplespec;
; 1661 :     uint_8 olddotname;
; 1662 :     uint_32 xdataofs = 0;
; 1663 :     char segnamebuff[12];
; 1664 :     char buffer[128];
; 1665 : 
; 1666 : 	/* 2016-02-10 John Hankinson - Don't bother writing SEH data for ELF64 Win64 ABI hack */
; 1667 : 	if (Options.output_format == OFORMAT_ELF)

	cmp	DWORD PTR Options+144, 3
	mov	rsi, rcx
	je	$LN1@WriteSEHDa

; 1668 : 	return;
; 1669 : 
; 1670 :     if ( endprolog_found == FALSE ) {

	cmp	BYTE PTR endprolog_found, 0
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+24], rbp
	jne	SHORT $LN6@WriteSEHDa

; 1671 :         EmitErr( MISSING_ENDPROLOG, proc->sym.name );

	mov	rdx, QWORD PTR [rcx+8]
	mov	ecx, 260				; 00000104H
	call	EmitErr
$LN6@WriteSEHDa:

; 1672 :     }
; 1673 :     if ( unw_segs_defined )

	cmp	BYTE PTR unw_segs_defined, 0

; 1674 :         AddLineQueueX("%s %r", segname, T_SEGMENT );

	lea	rdx, OFFSET FLAT:$SG11922
	mov	r8d, 440				; 000001b8H
	je	SHORT $LN7@WriteSEHDa
	lea	rcx, OFFSET FLAT:$SG11927
	call	AddLineQueueX
	jmp	SHORT $LN8@WriteSEHDa
$LN7@WriteSEHDa:

; 1675 :     else {
; 1676 :         AddLineQueueX("%s %r align(%u) flat read 'DATA'", segname, T_SEGMENT, 8 );

	mov	r9d, 8
	lea	rcx, OFFSET FLAT:$SG11928
	call	AddLineQueueX

; 1677 :         AddLineQueue("$xdatasym label near");

	lea	rcx, OFFSET FLAT:$SG11929
	call	AddLineQueue
$LN8@WriteSEHDa:

; 1678 :     }
; 1679 :     xdataofs = 0;
; 1680 :     xdata = (struct dsym *)SymSearch( segname );

	lea	rcx, OFFSET FLAT:$SG11922
	xor	ebp, ebp
	call	SymFind

; 1681 :     if ( xdata ) {

	test	rax, rax
	je	SHORT $LN9@WriteSEHDa

; 1682 :         /* v2.11: changed offset to max_offset.
; 1683 :          * However, value structinfo.current_loc might even be better.
; 1684 :          */
; 1685 :         xdataofs = xdata->sym.max_offset;

	mov	ebp, DWORD PTR [rax+56]
$LN9@WriteSEHDa:

; 1686 :     }
; 1687 : 
; 1688 :     /* write the .xdata stuff (a UNWIND_INFO entry )
; 1689 :      * v2.11: 't'-suffix added to ensure the values are correct if radix is != 10.
; 1690 :      */
; 1691 :     AddLineQueueX( "db %ut + (0%xh shl 3), %ut, %ut, 0%xh + (0%xh shl 4)",

	movzx	edx, BYTE PTR unw_info+3
	movzx	r8d, BYTE PTR unw_info
	mov	ecx, edx
	movzx	eax, BYTE PTR unw_info+2
	and	edx, 15
	movzx	r9d, BYTE PTR unw_info+1
	shr	ecx, 4
	mov	DWORD PTR [rsp+48], ecx
	lea	rcx, OFFSET FLAT:$SG11931
	mov	DWORD PTR [rsp+40], edx
	mov	edx, 1
	shr	r8d, 3
	mov	DWORD PTR [rsp+32], eax
	call	AddLineQueueX

; 1692 :             UNW_VERSION, unw_info.Flags, unw_info.SizeOfProlog,
; 1693 :             unw_info.CountOfCodes, unw_info.FrameRegister, unw_info.FrameOffset );
; 1694 :     if ( unw_info.CountOfCodes ) {

	movzx	eax, BYTE PTR unw_info+2
	test	al, al
	je	$LN3@WriteSEHDa

; 1695 :         char *pfx = "dw";

	mov	QWORD PTR [rsp+248], rdi
	lea	r8, OFFSET FLAT:$SG11933

; 1696 :         buffer[0] = NULLC;
; 1697 :         /* write the codes from right to left */
; 1698 :         for ( i = unw_info.CountOfCodes; i ; i-- ) {

	movzx	ebx, al
	lea	rdi, OFFSET FLAT:unw_code
	lea	rdi, QWORD PTR [rdi-2]
	mov	BYTE PTR buffer$[rsp], 0
	lea	rdi, QWORD PTR [rdi+rbx*2]
	npad	2
$LL4@WriteSEHDa:

; 1699 :             /* v2.11: use field FrameOffset */
; 1700 :             //sprintf( buffer + strlen( buffer ), "%s 0%xh", pfx, unw_code[i-1] );
; 1701 :             sprintf( buffer + strlen( buffer ), "%s 0%xh", pfx, unw_code[i-1].FrameOffset );

	movzx	r9d, WORD PTR [rdi]
	lea	rcx, QWORD PTR buffer$[rsp]
	or	rax, -1
	npad	3
$LL26@WriteSEHDa:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL26@WriteSEHDa
	lea	rcx, QWORD PTR buffer$[rsp]
	add	rcx, rax
	lea	rdx, OFFSET FLAT:$SG11934
	call	sprintf

; 1702 :             pfx = ",";

	lea	r8, OFFSET FLAT:$SG11935

; 1703 :             if ( i == 1 || strlen( buffer ) > 72 ) {

	cmp	rbx, 1
	je	SHORT $LN12@WriteSEHDa
	lea	rcx, QWORD PTR buffer$[rsp]
	or	rax, -1
$LL25@WriteSEHDa:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL25@WriteSEHDa
	cmp	rax, 72					; 00000048H
	jbe	SHORT $LN2@WriteSEHDa
$LN12@WriteSEHDa:

; 1704 :                 AddLineQueue( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	AddLineQueue

; 1705 :                 buffer[0] = NULLC;
; 1706 :                 pfx = "dw";

	lea	r8, OFFSET FLAT:$SG11938
	mov	BYTE PTR buffer$[rsp], 0
$LN2@WriteSEHDa:

; 1696 :         buffer[0] = NULLC;
; 1697 :         /* write the codes from right to left */
; 1698 :         for ( i = unw_info.CountOfCodes; i ; i-- ) {

	sub	rdi, 2
	sub	rbx, 1
	jne	SHORT $LL4@WriteSEHDa
	mov	rdi, QWORD PTR [rsp+248]
$LN3@WriteSEHDa:

; 1707 :             }
; 1708 :         }
; 1709 :     }
; 1710 :     /* make sure the unwind codes array has an even number of entries */
; 1711 :     AddLineQueueX( "%r 4", T_ALIGN );

	mov	edx, 438				; 000001b6H
	lea	rcx, OFFSET FLAT:$SG11939
	call	AddLineQueueX

; 1712 : 
; 1713 :     if ( proc->e.procinfo->exc_handler ) {

	mov	rax, QWORD PTR [rsi+96]
	mov	r8, QWORD PTR [rax+48]
	test	r8, r8
	je	SHORT $LN13@WriteSEHDa

; 1714 :         AddLineQueueX( "dd %r %s", T_IMAGEREL, proc->e.procinfo->exc_handler->name );

	mov	r8, QWORD PTR [r8+8]
	lea	rcx, OFFSET FLAT:$SG11941
	mov	edx, 233				; 000000e9H
	call	AddLineQueueX

; 1715 :         AddLineQueueX( "%r 8", T_ALIGN );

	mov	edx, 438				; 000001b6H
	lea	rcx, OFFSET FLAT:$SG11942
	call	AddLineQueueX
$LN13@WriteSEHDa:

; 1716 :     }
; 1717 :     AddLineQueueX( "%s %r", segname, T_ENDS );

	mov	r8d, 441				; 000001b9H
	lea	rdx, OFFSET FLAT:$SG11922
	lea	rcx, OFFSET FLAT:$SG11943
	call	AddLineQueueX

; 1718 : 
; 1719 :     /* v2.07: ensure that .pdata items are sorted */
; 1720 :     if ( 0 == strcmp( SimGetSegName( SIM_CODE ), proc->sym.segment->name ) ) {

	mov	rbx, QWORD PTR [rsi+24]
	xor	ecx, ecx
	call	SimGetSegName
	mov	r9, QWORD PTR [rbx+8]
	sub	r9, rax
	npad	7
$LL23@WriteSEHDa:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r9]
	sub	edx, ecx
	jne	SHORT $LN24@WriteSEHDa
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL23@WriteSEHDa
$LN24@WriteSEHDa:
	test	edx, edx
	jne	SHORT $LN14@WriteSEHDa

; 1721 :         segname = ".pdata";
; 1722 :         simplespec = ( unw_segs_defined & 1 );

	movzx	eax, BYTE PTR unw_segs_defined
	lea	rbx, OFFSET FLAT:$SG11946

; 1723 :         unw_segs_defined = 3;

	mov	BYTE PTR unw_segs_defined, 3
	and	eax, 1

; 1729 :     }
; 1730 : 
; 1731 :     if ( simplespec )

	je	SHORT $LN16@WriteSEHDa

; 1732 :         AddLineQueueX( "%s %r", segname, T_SEGMENT );

	mov	r8d, 440				; 000001b8H
	lea	rcx, OFFSET FLAT:$SG11950
	mov	rdx, rbx
	call	AddLineQueueX
	jmp	SHORT $LN17@WriteSEHDa
$LN14@WriteSEHDa:

; 1724 :     } else {
; 1725 :         segname = segnamebuff;
; 1726 :         sprintf( segname, ".pdata$%04u", GetSegIdx( proc->sym.segment ) );

	mov	rcx, QWORD PTR [rsi+24]
	lea	rbx, QWORD PTR segnamebuff$[rsp]
	call	GetSegIdx
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG11947
	lea	rcx, QWORD PTR segnamebuff$[rsp]
	call	sprintf

; 1727 :         simplespec = 0;
; 1728 :         unw_segs_defined |= 2;

	or	BYTE PTR unw_segs_defined, 2
$LN16@WriteSEHDa:

; 1733 :     else
; 1734 :         AddLineQueueX( "%s %r align(%u) flat read 'DATA'", segname, T_SEGMENT, 4 );

	mov	r9d, 4
	lea	rcx, OFFSET FLAT:$SG11951
	mov	r8d, 440				; 000001b8H
	mov	rdx, rbx
	call	AddLineQueueX
$LN17@WriteSEHDa:

; 1735 :     /* write the .pdata stuff ( type IMAGE_RUNTIME_FUNCTION_ENTRY )*/
; 1736 :     AddLineQueueX( "dd %r %s, %r %s+0%xh, %r $xdatasym+0%xh",

	mov	r8, QWORD PTR [rsi+8]
	lea	rcx, OFFSET FLAT:$SG11952
	mov	eax, DWORD PTR [rsi+56]
	mov	edx, 233				; 000000e9H
	mov	DWORD PTR [rsp+56], ebp
	mov	r9d, edx
	mov	DWORD PTR [rsp+48], 233			; 000000e9H
	mov	DWORD PTR [rsp+40], eax
	mov	QWORD PTR [rsp+32], r8
	call	AddLineQueueX

; 1737 :                   T_IMAGEREL, proc->sym.name,
; 1738 :                   T_IMAGEREL, proc->sym.name, proc->sym.total_size,
; 1739 :                   T_IMAGEREL, xdataofs );
; 1740 :     AddLineQueueX("%s %r", segname, T_ENDS );

	mov	r8d, 441				; 000001b9H
	lea	rcx, OFFSET FLAT:$SG11953
	mov	rdx, rbx
	call	AddLineQueueX

; 1741 :     olddotname = ModuleInfo.dotname;

	mov	eax, DWORD PTR ModuleInfo+408
	mov	ebx, eax

; 1742 :     ModuleInfo.dotname = TRUE; /* set OPTION DOTNAME because .pdata and .xdata */

	or	eax, 16
	shr	ebx, 4
	and	bl, 1
	mov	DWORD PTR ModuleInfo+408, eax

; 1743 :     RunLineQueue();

	call	RunLineQueue

; 1744 :     ModuleInfo.dotname = olddotname;

	mov	eax, DWORD PTR ModuleInfo+408
	mov	rbp, QWORD PTR [rsp+240]
	movzx	ecx, bl
	mov	rbx, QWORD PTR [rsp+224]
	shl	ecx, 4
	xor	ecx, eax
	and	ecx, 16
	xor	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax
$LN1@WriteSEHDa:

; 1745 :     return;
; 1746 : }

	add	rsp, 208				; 000000d0H
	pop	rsi
	ret	0
WriteSEHData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
i$ = 64
tokenarray$ = 72
ProcDir	PROC

; 1422 : {

$LN47:
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx

; 1423 :     struct asym         *sym;
; 1424 :     unsigned int        ofs;
; 1425 :     char                *name;
; 1426 :     bool                oldpubstate;
; 1427 :     bool                is_global;
; 1428 : 
; 1429 :     DebugMsg1(("ProcDir enter, curr ofs=%X\n", GetCurrOffset() ));
; 1430 :     if( i != 1 ) {

	cmp	ecx, 1
	je	SHORT $LN2@ProcDir

; 1431 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbp+8]

; 1611 : }

	add	rsp, 48					; 00000030H
	pop	rbp

; 1431 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jmp	EmitErr
$LN2@ProcDir:

; 1432 :     }
; 1433 :     /* v2.04b: check was missing */
; 1434 :     if( CurrSeg == NULL ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN3@ProcDir

; 1435 :         return( EmitError( MUST_BE_IN_SEGMENT_BLOCK ) );

	mov	ecx, 82					; 00000052H

; 1611 : }

	add	rsp, 48					; 00000030H
	pop	rbp

; 1435 :         return( EmitError( MUST_BE_IN_SEGMENT_BLOCK ) );

	jmp	EmitError
$LN3@ProcDir:
	mov	QWORD PTR [rsp+64], rbx

; 1436 :     }
; 1437 : 
; 1438 :     name = tokenarray[0].string_ptr;
; 1439 : 
; 1440 :     if( CurrProc != NULL ) {

	mov	rbx, QWORD PTR CurrProc
	mov	QWORD PTR [rsp+72], rsi
	mov	rsi, QWORD PTR [rdx+8]
	test	rbx, rbx
	je	SHORT $LN39@ProcDir

; 1441 : 
; 1442 :         /* this is not needed for HJWasm, but Masm will reject nested
; 1443 :          * procs if there are params, locals or used registers.
; 1444 :          */
; 1445 :         if ( CurrProc->e.procinfo->paralist ||
; 1446 : #if AMD64_SUPPORT
; 1447 :             CurrProc->e.procinfo->isframe ||
; 1448 : #endif
; 1449 :             CurrProc->e.procinfo->locallist ||

	mov	rax, QWORD PTR [rbx+96]
	cmp	QWORD PTR [rax+8], 0
	jne	$LN6@ProcDir
	test	BYTE PTR [rax+84], 64			; 00000040H
	jne	$LN6@ProcDir
	cmp	QWORD PTR [rax+16], 0
	jne	$LN6@ProcDir
	cmp	QWORD PTR [rax], 0
	jne	$LN6@ProcDir

; 1452 :         }
; 1453 :         /* nested procs ... push currproc on a stack */
; 1454 :         push_proc( CurrProc );

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN37@ProcDir
	mov	rcx, rbx
	call	SymGetLocal
$LN37@ProcDir:
	mov	ecx, 16
	call	LclAlloc
	mov	rcx, QWORD PTR ProcStack
	mov	QWORD PTR [rax], rcx
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR ProcStack, rax
$LN39@ProcDir:

; 1455 :     }
; 1456 : 
; 1457 : 
; 1458 :     if ( ModuleInfo.procalign ) {

	movzx	eax, BYTE PTR ModuleInfo+399
	test	al, al
	je	SHORT $LN7@ProcDir

; 1459 :         AlignCurrOffset( ModuleInfo.procalign );

	movzx	ecx, al
	call	AlignCurrOffset
$LN7@ProcDir:

; 1460 :     }
; 1461 : 
; 1462 :     i++; /* go past PROC */
; 1463 : 
; 1464 :     sym = SymSearch( name );

	mov	QWORD PTR [rsp+80], rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+88], r14
	call	SymFind

; 1465 : 
; 1466 :     if( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	rbx, rax
	jne	$LN8@ProcDir

; 1467 : 
; 1468 :         oldpubstate = sym ? sym->ispublic : FALSE;

	test	rax, rax
	je	$LN32@ProcDir
	movzx	edi, BYTE PTR [rax+40]

; 1469 :         if( sym == NULL || sym->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [rax+32]
	shr	dil, 7
	test	eax, eax
	je	$LN12@ProcDir

; 1472 :         } else if ( sym->state == SYM_EXTERNAL && sym->weak == TRUE ) {

	cmp	eax, 2
	jne	SHORT $LN13@ProcDir
	test	BYTE PTR [rbx+47], 8
	je	SHORT $LN13@ProcDir

; 1473 :             /* PROTO or EXTERNDEF item */
; 1474 :             is_global = TRUE;
; 1475 :             if ( sym->isproc == TRUE  ) {

	test	BYTE PTR [rbx+41], 8
	mov	r14b, 1
	je	SHORT $LN15@ProcDir

; 1476 :                 /* don't create the procinfo extension; it exists already */
; 1477 :                 procidx++; /* v2.04: added */

	inc	DWORD PTR procidx

; 1478 :                 if ( Options.line_numbers ) {

	cmp	BYTE PTR Options+1, 0
	je	SHORT $LN14@ProcDir

; 1479 :                     sym->debuginfo = LclAlloc( sizeof( struct debug_info ) );

	lea	ecx, QWORD PTR [rax+22]
	call	LclAlloc
	mov	QWORD PTR [rbx+64], rax

; 1480 :                     sym->debuginfo->file = get_curr_srcfile();

	call	get_curr_srcfile
	mov	rcx, QWORD PTR [rbx+64]
	mov	WORD PTR [rcx+14], ax

; 1481 :                 }
; 1482 :             } else {

	jmp	SHORT $LN14@ProcDir
$LN6@ProcDir:

; 1450 :             CurrProc->e.procinfo->regslist ) {
; 1451 :             return( EmitErr( CANNOT_NEST_PROCEDURES, name ) );

	mov	rdx, rsi
	mov	ecx, 93					; 0000005dH
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]

; 1611 : }

	add	rsp, 48					; 00000030H
	pop	rbp

; 1450 :             CurrProc->e.procinfo->regslist ) {
; 1451 :             return( EmitErr( CANNOT_NEST_PROCEDURES, name ) );

	jmp	EmitErr
$LN15@ProcDir:

; 1483 :                 /* it's a simple EXTERNDEF. Create a PROC item!
; 1484 :                  * this will be SYM_INTERNAL */
; 1485 :                 /* v2.03: don't call dir_free(), it'll clear field Ofssize */
; 1486 :                 //dir_free( (struct dsym *)sym );
; 1487 :                 sym = CreateProc( sym, name, SYM_INTERNAL );

	mov	r8d, 1
	mov	rdx, rsi
	mov	rcx, rbx
	call	CreateProc

; 1488 :             }
; 1489 :         } else {

	jmp	SHORT $LN45@ProcDir
$LN13@ProcDir:

; 1490 :             /* Masm won't reject a redefinition if "certain" parameters
; 1491 :              * won't change. However, in a lot of cases one gets "internal assembler error".
; 1492 :              * Hence this "feature" isn't active in hjwasm.
; 1493 :              */
; 1494 :             //} else if ( sym->state != SYM_INTERNAL || sym->isproc != TRUE ||
; 1495 :             //           sym->offset != GetCurrOffset() || sym->segment != &CurrSeg->sym ) {
; 1496 :             return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN44@ProcDir
$LN32@ProcDir:

; 1467 : 
; 1468 :         oldpubstate = sym ? sym->ispublic : FALSE;

	xor	dil, dil
$LN12@ProcDir:

; 1470 :             sym = CreateProc( sym, name, SYM_INTERNAL );

	mov	r8d, 1
	mov	rdx, rsi
	mov	rcx, rbx
	call	CreateProc

; 1471 :             is_global = FALSE;

	xor	r14b, r14b
$LN45@ProcDir:

; 1470 :             sym = CreateProc( sym, name, SYM_INTERNAL );

	mov	rbx, rax
$LN14@ProcDir:

; 1497 :         }
; 1498 :         SetSymSegOfs( sym );

	mov	rcx, rbx
	call	SetSymSegOfs

; 1499 : 
; 1500 :         SymClearLocal();

	call	SymClearLocal

; 1501 : 
; 1502 : #if STACKBASESUPP
; 1503 :         /* v2.11: added. Note that fpo flag is only set if there ARE params! */
; 1504 :         ((struct dsym *)sym)->e.procinfo->basereg = ModuleInfo.basereg[ModuleInfo.Ofssize];

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rsi, OFFSET FLAT:__ImageBase
	mov	rcx, QWORD PTR [rbx+96]

; 1505 : #endif
; 1506 :         /* CurrProc must be set, it's used inside SymFind() and SymLCreate()! */
; 1507 :         CurrProc = (struct dsym *)sym;
; 1508 :         if( ParseProc( (struct dsym *)sym, i, tokenarray, TRUE, ModuleInfo.langtype ) == ERROR ) {

	mov	r9b, 1
	mov	r8, rbp
	mov	edx, 2
	movzx	eax, WORD PTR ModuleInfo[rsi+rax*4+500]
	mov	WORD PTR [rcx+86], ax
	mov	rcx, rbx
	mov	eax, DWORD PTR ModuleInfo+364
	mov	DWORD PTR [rsp+32], eax
	mov	QWORD PTR CurrProc, rbx
	call	ParseProc
	cmp	eax, -1
	jne	SHORT $LN18@ProcDir

; 1509 :             CurrProc = NULL;

	xor	edi, edi
	mov	QWORD PTR CurrProc, rdi

; 1510 :             return( ERROR );

	or	eax, eax
	jmp	$LN44@ProcDir
$LN18@ProcDir:

; 1511 :         }
; 1512 :         /* v2.04: added */
; 1513 :         if ( is_global && Options.masm8_proc_visibility )

	test	r14b, r14b
	je	SHORT $LN19@ProcDir
	cmp	BYTE PTR Options+129, 0
	je	SHORT $LN19@ProcDir

; 1514 :             sym->ispublic = TRUE;

	or	BYTE PTR [rbx+40], 128			; 00000080H
$LN19@ProcDir:

; 1515 : 
; 1516 :         /* if there was a PROTO (or EXTERNDEF name:PROTO ...),
; 1517 :          * change symbol to SYM_INTERNAL!
; 1518 :          */
; 1519 :         if ( sym->state == SYM_EXTERNAL && sym->isproc == TRUE ) {

	cmp	DWORD PTR [rbx+32], 2
	jne	SHORT $LN20@ProcDir
	test	BYTE PTR [rbx+41], 8
	je	SHORT $LN20@ProcDir

; 1520 :             sym_ext2int( sym );

	mov	rcx, rbx
	call	sym_ext2int

; 1521 :             /* v2.11: added ( may be better to call CreateProc() - currently not possible ) */
; 1522 :             if ( SymTables[TAB_PROC].head == NULL )

	cmp	QWORD PTR SymTables+64, 0
	jne	SHORT $LN21@ProcDir

; 1523 :                 SymTables[TAB_PROC].head = (struct dsym *)sym;

	mov	QWORD PTR SymTables+64, rbx
	jmp	SHORT $LN22@ProcDir
$LN21@ProcDir:

; 1524 :             else {
; 1525 :                 SymTables[TAB_PROC].tail->nextproc = (struct dsym *)sym;

	mov	rax, QWORD PTR SymTables+72
	mov	QWORD PTR [rax+112], rbx
$LN22@ProcDir:

; 1526 :             }
; 1527 :             SymTables[TAB_PROC].tail = (struct dsym *)sym;

	mov	QWORD PTR SymTables+72, rbx
$LN20@ProcDir:

; 1528 :         }
; 1529 : 
; 1530 :         /* v2.11: sym->isproc is set inside ParseProc() */
; 1531 :         //sym->isproc = TRUE;
; 1532 : #if STACKBASESUPP
; 1533 :         /* v2.11: Note that fpo flag is only set if there ARE params ( or locals )! */
; 1534 :         if ( CurrProc->e.procinfo->paralist && GetRegNo( CurrProc->e.procinfo->basereg ) == 4 )

	mov	rax, QWORD PTR CurrProc
	mov	rdx, QWORD PTR [rax+96]
	cmp	QWORD PTR [rdx+8], 0
	je	SHORT $LN23@ProcDir
	movzx	eax, WORD PTR [rdx+86]
	lea	rcx, QWORD PTR [rax+rax*2]
	cmp	BYTE PTR SpecialTable[rsi+rcx*4+10], 4
	jne	SHORT $LN23@ProcDir

; 1535 :             CurrProc->e.procinfo->fpo = TRUE;

	or	BYTE PTR [rdx+84], 128			; 00000080H
$LN23@ProcDir:

; 1536 : #endif
; 1537 :         if( sym->ispublic == TRUE && oldpubstate == FALSE )

	test	BYTE PTR [rbx+40], 128			; 00000080H
	je	SHORT $LN24@ProcDir
	test	dil, dil
	jne	SHORT $LN24@ProcDir

; 1538 :             AddPublicData( sym );

	mov	rcx, rbx
	call	AddPublicData
$LN24@ProcDir:

; 1539 : 
; 1540 :         /* v2.04: add the proc to the list of labels attached to curr segment.
; 1541 :          * this allows to reduce the number of passes (see fixup.c)
; 1542 :          */
; 1543 :         ((struct dsym *)sym)->next = (struct dsym *)CurrSeg->e.seginfo->label_list;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rcx+32]
	mov	QWORD PTR [rbx+104], rax

; 1544 :         CurrSeg->e.seginfo->label_list = sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	mov	QWORD PTR [rcx+32], rbx

; 1545 : 
; 1546 :     } else {

	jmp	SHORT $LN26@ProcDir
$LN8@ProcDir:

; 1547 :         /**/myassert( sym != NULL );
; 1548 : 
; 1549 :         procidx++;

	inc	DWORD PTR procidx

; 1550 :         sym->isdefined = TRUE;
; 1551 : 
; 1552 :         SymSetLocal( sym );

	mov	rcx, rax
	or	BYTE PTR [rax+40], 2
	call	SymSetLocal

; 1553 : 
; 1554 :         /* it's necessary to check for a phase error here
; 1555 :          as it is done in LabelCreate() and data_dir()!
; 1556 :          */
; 1557 :         ofs = GetCurrOffset();

	call	GetCurrOffset

; 1558 : 
; 1559 :         if ( ofs != sym->offset) {

	cmp	eax, DWORD PTR [rbx+16]
	je	SHORT $LN25@ProcDir

; 1560 :             DebugMsg(("ProcDir(%s): %spass %u, old ofs=%" I32_SPEC "X, new ofs=%" I32_SPEC "X\n",
; 1561 :                     sym->name,
; 1562 :                     ModuleInfo.PhaseError ? "" : "phase error ",
; 1563 :                     Parse_Pass+1, sym->offset, ofs ));
; 1564 :             sym->offset = ofs;

	mov	DWORD PTR [rbx+16], eax

; 1565 :             ModuleInfo.PhaseError = TRUE;

	mov	BYTE PTR ModuleInfo+422, 1
$LN25@ProcDir:

; 1566 :         }
; 1567 :         CurrProc = (struct dsym *)sym;

	mov	QWORD PTR CurrProc, rbx

; 1568 : #if AMD64_SUPPORT
; 1569 :         /* check if the exception handler set by FRAME is defined */
; 1570 :         if ( CurrProc->e.procinfo->isframe &&
; 1571 :             CurrProc->e.procinfo->exc_handler &&

	mov	rdx, QWORD PTR [rbx+96]
	test	BYTE PTR [rdx+84], 64			; 00000040H
	je	SHORT $LN26@ProcDir
	mov	rdx, QWORD PTR [rdx+48]
	test	rdx, rdx
	je	SHORT $LN26@ProcDir
	cmp	DWORD PTR [rdx+32], 0
	jne	SHORT $LN26@ProcDir

; 1572 :             CurrProc->e.procinfo->exc_handler->state == SYM_UNDEFINED ) {
; 1573 :             EmitErr( SYMBOL_NOT_DEFINED, CurrProc->e.procinfo->exc_handler->name );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr
$LN26@ProcDir:

; 1574 :         }
; 1575 : #endif
; 1576 :     }
; 1577 : 
; 1578 :     /* v2.11: init @ProcStatus - prologue not written yet, optionally set FPO flag */
; 1579 : #if STACKBASESUPP
; 1580 :     ProcStatus = PRST_PROLOGUE_NOT_DONE | ( CurrProc->e.procinfo->fpo ? PRST_FPO : 0 );

	mov	rdx, QWORD PTR CurrProc

; 1581 :     StackAdj = 0;  /* init @StackBase to 0 */

	xor	edi, edi
	mov	rax, QWORD PTR [rdx+96]
	movzx	ecx, BYTE PTR [rax+84]
	shr	ecx, 5
	and	ecx, 4
	mov	DWORD PTR StackAdj, edi
	bts	ecx, 7

; 1582 :     StackAdjHigh = 0;

	mov	DWORD PTR StackAdjHigh, edi
	mov	DWORD PTR ProcStatus, ecx

; 1583 : #else
; 1584 :     ProcStatus = PRST_PROLOGUE_NOT_DONE;
; 1585 : #endif
; 1586 : 
; 1587 : #if AMD64_SUPPORT
; 1588 :     if ( CurrProc->e.procinfo->isframe ) {

	mov	rax, QWORD PTR [rdx+96]
	test	BYTE PTR [rax+84], 64			; 00000040H
	je	SHORT $LN28@ProcDir

; 1589 :         endprolog_found = FALSE;
; 1590 :         /* v2.11: clear all fields */
; 1591 :         memset( &unw_info, 0, sizeof( unw_info ) );

	xor	eax, eax
	mov	BYTE PTR endprolog_found, dil
	mov	DWORD PTR unw_info, eax

; 1592 :         if ( CurrProc->e.procinfo->exc_handler )

	mov	rax, QWORD PTR [rdx+96]
	cmp	QWORD PTR [rax+48], rdi
	je	SHORT $LN28@ProcDir

; 1593 :             unw_info.Flags = UNW_FLAG_FHANDLER;

	movzx	eax, BYTE PTR unw_info
	and	al, 7
	or	al, 24
	mov	BYTE PTR unw_info, al
$LN28@ProcDir:

; 1594 :     }
; 1595 : #endif
; 1596 : 
; 1597 :     sym->asmpass = Parse_Pass;

	movzx	eax, BYTE PTR Parse_Pass
	mov	BYTE PTR [rbx+46], al

; 1598 :     if ( ModuleInfo.list )

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN29@ProcDir

; 1599 :         LstWrite( LSTTYPE_LABEL, 0, NULL );

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+7]
	call	LstWrite
$LN29@ProcDir:

; 1600 : 
; 1601 :     if( Options.line_numbers ) {

	cmp	BYTE PTR Options+1, dil
	je	SHORT $LN30@ProcDir

; 1602 : #if COFF_SUPPORT
; 1603 :         AddLinnumDataRef( get_curr_srcfile(), Options.output_format == OFORMAT_COFF ? 0 : GetLineNumber() );

	cmp	DWORD PTR Options+144, 2
	je	SHORT $LN35@ProcDir
	call	GetLineNumber
	mov	edi, eax
$LN35@ProcDir:
	call	get_curr_srcfile
	mov	ecx, eax
	mov	edx, edi
	call	AddLinnumDataRef
$LN30@ProcDir:

; 1604 : #else
; 1605 :         AddLinnumDataRef( get_curr_srcfile(), GetLineNumber() );
; 1606 : #endif
; 1607 :     }
; 1608 : 
; 1609 :     BackPatch( sym );

	mov	rcx, rbx
	call	BackPatch

; 1610 :     return( NOT_ERROR );

	xor	eax, eax
$LN44@ProcDir:
	mov	rdi, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]

; 1611 : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
ProcDir	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT ParseParams
_TEXT	SEGMENT
fcint$ = 32
ti$ = 40
init_done$1$ = 160
proc$ = 160
i$ = 168
tokenarray$ = 176
IsPROC$ = 184
ParseParams PROC					; COMDAT

; 631  : {

	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	push	rbp
	push	rbx
	push	rdi
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 104				; 00000068H

; 632  :     char            *name;
; 633  :     struct asym     *sym;
; 634  :     int             cntParam;
; 635  :     int             offset;
; 636  :     //int             size;
; 637  :     int             fcint = 0;

	xor	r15d, r15d
	movsxd	r10, edx

; 638  :     struct qualified_type ti;
; 639  :     bool            is_vararg;
; 640  :     bool            init_done;
; 641  :     struct dsym     *paranode;
; 642  :     struct dsym     *paracurr;
; 643  :     int             curr;
; 644  : 
; 645  :     /*
; 646  :      * find "first" parameter ( that is, the first to be pushed in INVOKE ).
; 647  :      */
; 648  :     if (proc->sym.langtype == LANG_C ||
; 649  :         proc->sym.langtype == LANG_SYSCALL ||
; 650  : #if AMD64_SUPPORT
; 651  :         ( proc->sym.langtype == LANG_FASTCALL && ModuleInfo.Ofssize != USE64 ) ||

	mov	edx, DWORD PTR [rcx+76]
	movzx	ebx, r9b
	mov	r9, r8
	mov	DWORD PTR fcint$[rbp-104], r15d
	mov	r14, rcx
	lea	eax, DWORD PTR [rdx-1]
	cmp	eax, 1
	jbe	SHORT $LN37@ParseParam
	cmp	edx, 7
	jne	SHORT $LN38@ParseParam
	cmp	BYTE PTR ModuleInfo+404, 2
	jne	SHORT $LN37@ParseParam
$LN38@ParseParam:
	cmp	edx, 3
	je	SHORT $LN37@ParseParam

; 657  :     else
; 658  :         paracurr = proc->e.procinfo->paralist;

	mov	rax, QWORD PTR [rcx+96]
	mov	rdi, QWORD PTR [rax+8]
$LN162@ParseParam:

; 659  : 
; 660  :     /* v2.11: proc_info.init_done has been removed, sym.isproc flag is used instead */
; 661  :     init_done = proc->sym.isproc;

	movzx	eax, BYTE PTR [rcx+41]

; 662  : 
; 663  :     for( cntParam = 0 ; tokenarray[i].token != T_FINAL ; cntParam++ ) {

	mov	r13d, r15d
	shr	al, 3
	and	al, 1
	mov	QWORD PTR [rsp+96], rsi
	mov	BYTE PTR init_done$1$[rbp-104], al
	mov	rax, r10
	shl	rax, 5
	mov	QWORD PTR [rsp+88], r12
	lea	rcx, QWORD PTR [rax+r8]
$LN170@ParseParam:
	movzx	eax, BYTE PTR [rcx]
	test	al, al
	je	$LN161@ParseParam
	mov	edx, 3

; 664  : 
; 665  :         if ( tokenarray[i].token == T_ID ) {

	cmp	al, 8
	jne	SHORT $LN39@ParseParam

; 666  :             name = tokenarray[i++].string_ptr;

	mov	r12, QWORD PTR [rcx+8]
	inc	r10d
	mov	DWORD PTR i$[rbp-104], r10d
	jmp	SHORT $LN44@ParseParam
$LN37@ParseParam:

; 652  : #else
; 653  :         proc->sym.langtype == LANG_FASTCALL ||
; 654  : #endif
; 655  :         proc->sym.langtype == LANG_STDCALL)
; 656  :         for ( paracurr = proc->e.procinfo->paralist; paracurr && paracurr->nextparam; paracurr = paracurr->nextparam );

	mov	rax, QWORD PTR [rcx+96]
	mov	rdi, QWORD PTR [rax+8]
	test	rdi, rdi
	je	SHORT $LN162@ParseParam
	npad	6
$LL4@ParseParam:
	mov	rax, QWORD PTR [rdi+112]
	test	rax, rax
	je	SHORT $LN162@ParseParam
	mov	rdi, rax
	jmp	SHORT $LL4@ParseParam
$LN39@ParseParam:

; 667  :         } else if ( IsPROC == FALSE && tokenarray[i].token == T_COLON ) {

	test	bl, bl
	jne	$LN41@ParseParam
	cmp	al, 58					; 0000003aH
	jne	$LN41@ParseParam

; 668  :             if ( paracurr )

	test	rdi, rdi
	je	SHORT $LN43@ParseParam

; 669  :                 name = paracurr->sym.name;

	mov	r12, QWORD PTR [rdi+8]
	jmp	SHORT $LN44@ParseParam
$LN43@ParseParam:

; 670  :             else
; 671  :                 name = "";

	lea	r12, OFFSET FLAT:$SG11600
$LN44@ParseParam:

; 676  :         }
; 677  : 
; 678  :         ti.symtype = NULL;
; 679  :         ti.is_ptr = 0;
; 680  :         ti.ptr_memtype = MT_EMPTY;
; 681  :         /* v2.02: init is_far depending on memory model */
; 682  :         //ti.is_far = FALSE;
; 683  :         if ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) )

	mov	ecx, DWORD PTR ModuleInfo+360
	mov	eax, 1
	shl	al, cl

; 684  :             ti.is_far = TRUE;
; 685  :         else
; 686  :             ti.is_far = FALSE;
; 687  :         ti.Ofssize = ModuleInfo.Ofssize;

	movzx	ecx, BYTE PTR ModuleInfo+404
	test	al, 104					; 00000068H

; 688  :         ti.size = CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	DWORD PTR ti$[rbp-104], eax
	setne	BYTE PTR ti$[rbp-83]

; 689  : 
; 690  :         is_vararg = FALSE;
; 691  : 
; 692  :         /* read colon. It's optional for PROC.
; 693  :          * Masm also allows a missing colon for PROTO - if there's
; 694  :          * just one parameter. Probably a Masm bug.
; 695  :          * HJWasm always require a colon for PROTO.
; 696  :          */
; 697  :         if( tokenarray[i].token != T_COLON ) {

	movsxd	rax, r10d
	xor	sil, sil
	shl	rax, 5
	mov	QWORD PTR ti$[rbp-96], r15
	mov	BYTE PTR ti$[rbp-84], r15b
	mov	DWORD PTR ti$[rbp-80], 192		; 000000c0H
	mov	BYTE PTR ti$[rbp-82], cl
	cmp	BYTE PTR [rax+r9], 58			; 0000003aH
	je	SHORT $LN47@ParseParam

; 698  :             if ( IsPROC == FALSE ) {

	test	bl, bl
	je	$LN123@ParseParam

; 700  :             }
; 701  :             switch ( ti.Ofssize ) {

	test	cl, cl
	mov	r9d, 1
	cmovne	r9d, edx
	mov	DWORD PTR ti$[rbp-88], r9d

; 702  :             case USE16:
; 703  :                 ti.mem_type = MT_WORD; break;
; 704  : #if AMD64_SUPPORT
; 705  :                 /* v2.08: default size for arguments is DWORD in 64-bit ( Win64 ) */
; 706  :                 //case USE64: ti.mem_type = MT_QWORD; break;
; 707  : #endif
; 708  :             default:
; 709  :                 ti.mem_type = MT_DWORD; break;
; 710  :             }
; 711  :         } else {

	jmp	$LN57@ParseParam
$LN47@ParseParam:

; 712  :             i++;

	inc	r10d

; 713  :             if (( tokenarray[i].token == T_RES_ID ) && ( tokenarray[i].tokval == T_VARARG )) {

	movsxd	rcx, r10d
	shl	rcx, 5
	mov	DWORD PTR i$[rbp-104], r10d
	cmp	BYTE PTR [rcx+r9], 7
	jne	SHORT $LN52@ParseParam
	cmp	DWORD PTR [rcx+r9+16], 262		; 00000106H
	jne	SHORT $LN52@ParseParam

; 714  :                 switch( proc->sym.langtype ) {

	mov	eax, DWORD PTR [r14+76]
	test	eax, eax
	je	$LN54@ParseParam
	add	eax, -3					; fffffffdH
	cmp	eax, 3
	jbe	$LN54@ParseParam

; 721  :                 }
; 722  :                 /* v2.05: added check */
; 723  :                 if ( tokenarray[i+1].token != T_FINAL )

	cmp	BYTE PTR [rcx+r9+32], r15b
	je	SHORT $LN55@ParseParam

; 724  :                     EmitError( VARARG_PARAMETER_MUST_BE_LAST );

	mov	ecx, 147				; 00000093H
	call	EmitError
	mov	r10d, DWORD PTR i$[rbp-104]
	jmp	SHORT $LN56@ParseParam
$LN55@ParseParam:

; 725  :                 else
; 726  :                     is_vararg = TRUE;

	mov	sil, 1
$LN56@ParseParam:

; 727  :                 ti.mem_type = MT_EMPTY;

	mov	r9d, 192				; 000000c0H

; 728  :                 ti.size = 0;

	mov	DWORD PTR ti$[rbp-104], r15d

; 729  :                 i++;

	inc	r10d
	mov	DWORD PTR ti$[rbp-88], r9d
	mov	DWORD PTR i$[rbp-104], r10d

; 730  :             } else {

	jmp	SHORT $LN57@ParseParam
$LN52@ParseParam:

; 731  :                 if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rbp-104]
	mov	rdx, r9
	lea	rcx, QWORD PTR i$[rbp-104]
	call	GetQualifiedType
	cmp	eax, -1
	je	$LN124@ParseParam
	mov	r10d, DWORD PTR i$[rbp-104]
	mov	r9d, DWORD PTR ti$[rbp-88]
$LN57@ParseParam:

; 733  :             }
; 734  :         }
; 735  : 
; 736  :         /* check if parameter name is defined already */
; 737  :         if (( IsPROC ) && ( sym = SymSearch( name ) ) && sym->state != SYM_UNDEFINED ) {

	test	bl, bl
	je	SHORT $LN58@ParseParam
	mov	rcx, r12
	call	SymFind
	test	rax, rax
	je	SHORT $LN160@ParseParam
	cmp	DWORD PTR [rax+32], r15d
	jne	$LN125@ParseParam
$LN160@ParseParam:
	mov	r10d, DWORD PTR i$[rbp-104]
	mov	r9d, DWORD PTR ti$[rbp-88]
$LN58@ParseParam:

; 740  :         }
; 741  : 
; 742  :         /* redefinition? */
; 743  :         if ( paracurr ) {

	test	rdi, rdi
	je	$LN59@ParseParam

; 744  : #if 0 /* was active till v2.04 */
; 745  :             int newsize = ti.size;
; 746  :             int oldsize;
; 747  : 
; 748  :             /* check size only (so UINT <-> DWORD wont cause an error) */
; 749  :             if ( paracurr->sym.type )
; 750  :                 oldsize = paracurr->sym.total_size;
; 751  :             else if ( paracurr->sym.mem_type == MT_EMPTY )
; 752  :                 oldsize = 0;
; 753  :             else if ( paracurr->sym.mem_type == MT_PTR )
; 754  :                 oldsize = SizeFromMemtype( paracurr->sym.isfar ? MT_FAR : MT_NEAR, paracurr->sym.Ofssize, NULL );
; 755  :             else
; 756  :                 oldsize = SizeFromMemtype( paracurr->sym.mem_type, paracurr->sym.Ofssize, paracurr->sym.type );
; 757  :             if ( oldsize != newsize ) {
; 758  :                 DebugMsg(("ParseParams: old memtype=%u, new memtype=%u\n", paracurr->sym.mem_type, ti.mem_type));
; 759  :                 EmitErr( CONFLICTING_PARAMETER_DEFINITION, name );
; 760  :                 //return( ERROR );
; 761  :             }
; 762  :             /* the parameter type used in PROC has highest priority! */
; 763  :             if ( IsPROC ) {
; 764  :                 if ( ti.symtype ) {
; 765  :                     paracurr->sym.type = ti.symtype;
; 766  :                     paracurr->sym.mem_type = MT_TYPE;
; 767  :                 } else
; 768  :                     paracurr->sym.mem_type = ti.mem_type;
; 769  :             }
; 770  : #else
; 771  :             struct asym *to;
; 772  :             struct asym *tn;
; 773  :             char oo;
; 774  :             char on;
; 775  :             for( tn = ti.symtype; tn && tn->type; tn = tn->type );

	mov	r8, QWORD PTR ti$[rbp-96]
	test	r8, r8
	je	SHORT $LN163@ParseParam
$LL14@ParseParam:
	mov	rax, QWORD PTR [r8+80]
	test	rax, rax
	je	SHORT $LN163@ParseParam
	mov	r8, rax
	jmp	SHORT $LL14@ParseParam
$LN163@ParseParam:

; 776  :             /* v2.12: don't assume pointer type if mem_type is != MT_TYPE!
; 777  :              * regression test proc9.asm.
; 778  :              */
; 779  :             //to = ( paracurr->sym.mem_type == MT_TYPE ) ? paracurr->sym.type : paracurr->sym.target_type;
; 780  :             if ( paracurr->sym.mem_type == MT_TYPE )

	mov	esi, DWORD PTR [rdi+36]
	cmp	esi, 196				; 000000c4H
	jne	SHORT $LN61@ParseParam

; 781  :                 to = paracurr->sym.type;

	mov	rdx, QWORD PTR [rdi+80]
	jmp	SHORT $LN104@ParseParam
$LN61@ParseParam:

; 782  :             else
; 783  :                 to = ( paracurr->sym.mem_type == MT_PTR ? paracurr->sym.target_type : NULL );

	cmp	esi, 195				; 000000c3H
	jne	SHORT $LN103@ParseParam
	mov	rdx, QWORD PTR [rdi+48]
$LN104@ParseParam:

; 784  :             for( ; to && to->type; to = to->type );

	test	rdx, rdx
	je	SHORT $LN16@ParseParam
$LL17@ParseParam:
	mov	rax, QWORD PTR [rdx+80]
	test	rax, rax
	je	SHORT $LN16@ParseParam
	mov	rdx, rax
	jmp	SHORT $LL17@ParseParam
$LN103@ParseParam:

; 782  :             else
; 783  :                 to = ( paracurr->sym.mem_type == MT_PTR ? paracurr->sym.target_type : NULL );

	mov	rdx, r15
$LN16@ParseParam:

; 785  :             oo = ( paracurr->sym.Ofssize != USE_EMPTY ) ? paracurr->sym.Ofssize : ModuleInfo.Ofssize;

	movzx	ecx, BYTE PTR ModuleInfo+404
	movzx	eax, BYTE PTR [rdi+44]
	mov	r11d, ecx
	cmp	al, 254					; 000000feH

; 786  :             on = ( ti.Ofssize != USE_EMPTY ) ? ti.Ofssize : ModuleInfo.Ofssize;

	mov	ebx, ecx
	movzx	ecx, BYTE PTR ti$[rbp-82]
	cmovne	r11d, eax
	cmp	cl, 254					; 000000feH
	cmovne	ebx, ecx

; 787  :             if ( ti.mem_type != paracurr->sym.mem_type ||
; 788  :                 ( ti.mem_type == MT_TYPE && tn != to ) ||

	cmp	r9d, esi
	jne	SHORT $LN66@ParseParam
	cmp	r9d, 196				; 000000c4H
	jne	SHORT $LN65@ParseParam
	cmp	r8, rdx
	jne	SHORT $LN66@ParseParam
	jmp	SHORT $LN63@ParseParam
$LN65@ParseParam:
	cmp	r9d, 195				; 000000c3H
	jne	SHORT $LN63@ParseParam
	movzx	eax, BYTE PTR [rdi+47]
	shr	al, 4
	and	al, 1
	cmp	BYTE PTR ti$[rbp-83], al
	jne	SHORT $LN66@ParseParam
	cmp	bl, r11b
	jne	SHORT $LN66@ParseParam
	movzx	eax, BYTE PTR [rdi+46]
	cmp	DWORD PTR ti$[rbp-80], eax
	jne	SHORT $LN66@ParseParam
	cmp	r8, rdx
	je	SHORT $LN63@ParseParam
$LN66@ParseParam:

; 789  :                 ( ti.mem_type == MT_PTR &&
; 790  :                  ( ti.is_far != paracurr->sym.isfar ||
; 791  :                   on != oo ||
; 792  :                   ti.ptr_memtype != paracurr->sym.ptr_memtype ||
; 793  :                   tn != to ))) {
; 794  :                 DebugMsg(("ParseParams: old-new memtype=%X-%X type=%X(%s)-%X(%s) far=%u-%u ind=%u-%u ofss=%d-%d pmt=%X-%X\n",
; 795  :                           paracurr->sym.mem_type, ti.mem_type, 
; 796  :                           (paracurr->sym.mem_type == MT_TYPE) ? paracurr->sym.type : paracurr->sym.target_type,
; 797  :                           (paracurr->sym.mem_type == MT_TYPE) ? paracurr->sym.type->name : paracurr->sym.target_type ? paracurr->sym.target_type->name : "",
; 798  :                           ti.symtype, ti.symtype ? ti.symtype->name : "",
; 799  :                           paracurr->sym.isfar, ti.is_far,
; 800  :                           paracurr->sym.is_ptr, ti.is_ptr,
; 801  :                           paracurr->sym.Ofssize, ti.Ofssize,
; 802  :                           paracurr->sym.ptr_memtype, ti.ptr_memtype ));
; 803  :                 EmitErr( CONFLICTING_PARAMETER_DEFINITION, name );

	mov	rdx, r12
	mov	ecx, 137				; 00000089H
	call	EmitErr
	mov	r10d, DWORD PTR i$[rbp-104]
$LN63@ParseParam:

; 804  :                 //return( ERROR );
; 805  :             }
; 806  : #endif
; 807  :             if ( IsPROC ) {

	movzx	ebx, BYTE PTR IsPROC$[rbp-104]
	test	bl, bl
	je	SHORT $LN67@ParseParam

; 808  :                 DebugMsg1(("ParseParams: calling SymAddLocal(%s, %s)\n", paracurr->sym.name, name ));
; 809  :                 /* it has been checked already that the name isn't found - SymAddLocal() shouldn't fail */
; 810  :                 SymAddLocal( &paracurr->sym, name );

	mov	rdx, r12
	mov	rcx, rdi
	call	SymAddLocal
	mov	r10d, DWORD PTR i$[rbp-104]
$LN67@ParseParam:

; 811  :             }
; 812  :             /* set paracurr to next parameter */
; 813  :             if ( proc->sym.langtype == LANG_C ||
; 814  :                 proc->sym.langtype == LANG_SYSCALL ||
; 815  : #if AMD64_SUPPORT
; 816  :                 ( proc->sym.langtype == LANG_FASTCALL && ti.Ofssize != USE64 ) ||

	mov	ecx, DWORD PTR [r14+76]
	lea	eax, DWORD PTR [rcx-1]
	cmp	eax, 1
	jbe	SHORT $LN70@ParseParam
	cmp	ecx, 7
	jne	SHORT $LN71@ParseParam
	cmp	BYTE PTR ti$[rbp-82], 2
	jne	SHORT $LN70@ParseParam
$LN71@ParseParam:
	cmp	ecx, 3
	je	SHORT $LN70@ParseParam

; 826  :             } else
; 827  :                 paracurr = paracurr->nextparam;

	mov	rdi, QWORD PTR [rdi+112]
	jmp	$LN21@ParseParam
$LN70@ParseParam:

; 817  : #else
; 818  :                 proc->sym.langtype == LANG_FASTCALL ||
; 819  : #endif
; 820  :                 proc->sym.langtype == LANG_STDCALL) {
; 821  :                 struct dsym *l;
; 822  :                 for (l = proc->e.procinfo->paralist;

	mov	rax, QWORD PTR [r14+96]
	mov	rcx, QWORD PTR [rax+8]

; 823  :                      l && ( l->nextparam != paracurr );

	test	rcx, rcx
	je	SHORT $LN164@ParseParam
	npad	3
$LL20@ParseParam:
	mov	rax, QWORD PTR [rcx+112]
	cmp	rax, rdi
	je	SHORT $LN164@ParseParam

; 824  :                      l = l->nextparam );

	mov	rcx, rax
	test	rax, rax
	jne	SHORT $LL20@ParseParam
$LN164@ParseParam:

; 825  :                 paracurr = l;

	mov	rdi, rcx

; 828  : 
; 829  :         //} else if ( proc->e.procinfo->init_done == TRUE ) {
; 830  :         } else if ( init_done == TRUE ) {

	jmp	$LN21@ParseParam
$LN59@ParseParam:
	cmp	BYTE PTR init_done$1$[rbp-104], 1
	je	$LN126@ParseParam

; 834  :         } else {
; 835  :             if ( IsPROC ) {

	test	bl, bl
	je	SHORT $LN74@ParseParam

; 836  :                 paranode = (struct dsym *)SymLCreate( name );

	mov	rcx, r12
	call	SymLCreate

; 837  :             } else

	jmp	SHORT $LN165@ParseParam
$LN74@ParseParam:

; 838  :                 paranode = (struct dsym *)SymAlloc( "" );/* for PROTO, no param name needed */

	lea	rcx, OFFSET FLAT:$SG11633
	call	SymAlloc
$LN165@ParseParam:
	mov	rbx, rax

; 839  : 
; 840  :             if( paranode == NULL ) { /* error msg has been displayed already */

	test	rax, rax
	je	$LN124@ParseParam

; 841  :                 DebugMsg(("ParseParams: SymLCreate(%s) failed\n", name ));
; 842  :                 return( ERROR );
; 843  :             }
; 844  :             paranode->sym.isdefined = TRUE;

	or	BYTE PTR [rax+40], 2

; 845  :             paranode->sym.mem_type = ti.mem_type;

	mov	eax, DWORD PTR ti$[rbp-88]
	mov	DWORD PTR [rbx+36], eax

; 846  :             if ( ti.mem_type == MT_TYPE ) {

	cmp	DWORD PTR ti$[rbp-88], 196		; 000000c4H

; 847  :                 paranode->sym.type = ti.symtype;

	mov	rax, QWORD PTR ti$[rbp-96]
	jne	SHORT $LN77@ParseParam
	mov	QWORD PTR [rbx+80], rax

; 848  :             } else {

	jmp	SHORT $LN78@ParseParam
$LN77@ParseParam:

; 849  :                 paranode->sym.target_type = ti.symtype;

	mov	QWORD PTR [rbx+48], rax
$LN78@ParseParam:

; 850  :             }
; 851  : 
; 852  :             /* v2.05: moved BEFORE fastcall_tab() */
; 853  :             paranode->sym.isfar   = ti.is_far;

	movzx	eax, BYTE PTR ti$[rbp-83]
	shl	al, 4
	xor	al, BYTE PTR [rbx+47]
	and	al, 16

; 854  :             paranode->sym.Ofssize = ti.Ofssize;
; 855  :             paranode->sym.is_ptr  = ti.is_ptr;
; 856  :             paranode->sym.ptr_memtype = ti.ptr_memtype;
; 857  :             paranode->sym.is_vararg = is_vararg;

	shl	sil, 5
	xor	BYTE PTR [rbx+47], al
	movzx	eax, BYTE PTR ti$[rbp-82]
	xor	sil, BYTE PTR [rbx+47]
	mov	BYTE PTR [rbx+44], al
	and	sil, 32					; 00000020H
	movzx	eax, BYTE PTR ti$[rbp-84]
	mov	BYTE PTR [rbx+45], al
	movzx	eax, BYTE PTR ti$[rbp-80]
	xor	BYTE PTR [rbx+47], sil
	mov	BYTE PTR [rbx+46], al

; 858  :             if ( proc->sym.langtype == LANG_FASTCALL &&

	cmp	DWORD PTR [r14+76], 7
	jne	SHORT $LN79@ParseParam
	movsxd	rax, DWORD PTR ModuleInfo+376
	lea	r8, QWORD PTR fcint$[rbp-104]
	add	rax, rax
	lea	r9, OFFSET FLAT:fastcall_tab
	mov	rdx, rbx
	mov	rcx, r14
	call	QWORD PTR [r9+rax*8]
	test	eax, eax
	jne	SHORT $LN80@ParseParam
$LN79@ParseParam:

; 859  :                 fastcall_tab[ModuleInfo.fctype].paramcheck( proc, paranode, &fcint ) ) {
; 860  :             } else {
; 861  :                 paranode->sym.state = SYM_STACK;

	mov	DWORD PTR [rbx+32], 5
$LN80@ParseParam:

; 862  :             }
; 863  : 
; 864  :             paranode->sym.total_length = 1; /* v2.04: added */
; 865  :             paranode->sym.total_size = ti.size;
; 866  : 
; 867  :             if( paranode->sym.is_vararg == FALSE )

	test	BYTE PTR [rbx+47], 32			; 00000020H
	mov	DWORD PTR [rbx+64], 1
	mov	eax, DWORD PTR ti$[rbp-104]
	mov	DWORD PTR [rbx+56], eax
	jne	SHORT $LN81@ParseParam

; 868  :                 /* v2.11: CurrWordSize does reflect the default parameter size only for PROCs.
; 869  :                  * For PROTOs and TYPEs use member seg_ofssize.
; 870  :                  */
; 871  :                 //proc->e.procinfo->parasize += ROUND_UP( ti.size, CurrWordSize );
; 872  :                 proc->e.procinfo->parasize += ROUND_UP( ti.size, IsPROC ? CurrWordSize : ( 2 << proc->sym.seg_ofssize ) );

	cmp	BYTE PTR IsPROC$[rbp-104], r15b
	je	SHORT $LN109@ParseParam
	movzx	r8d, BYTE PTR ModuleInfo+406
	jmp	SHORT $LN166@ParseParam
$LN109@ParseParam:
	movzx	ecx, BYTE PTR [r14+47]
	mov	r8d, 2
	and	ecx, 3
	shl	r8d, cl
$LN166@ParseParam:
	mov	ecx, DWORD PTR ti$[rbp-104]
	lea	eax, DWORD PTR [r8-1]
	mov	rdx, QWORD PTR [r14+96]
	dec	ecx
	add	ecx, r8d
	not	eax
	and	ecx, eax
	mov	r9d, r8d
	add	DWORD PTR [rdx+32], ecx
$LN81@ParseParam:

; 873  : 
; 874  :             /* v2.05: the PROC's vararg flag has been set already */
; 875  :             //proc->e.procinfo->is_vararg |= paranode->sym.is_vararg;
; 876  : 
; 877  :             /* Parameters usually are stored in "push" order.
; 878  :              * However, for Win64, it's better to store them
; 879  :              * the "natural" way from left to right, since the
; 880  :              * arguments aren't "pushed".
; 881  :              */
; 882  : 
; 883  :             switch( proc->sym.langtype ) {

	mov	eax, DWORD PTR [r14+76]
	cmp	eax, 4
	jl	SHORT $LN88@ParseParam
	cmp	eax, 6
	jle	SHORT $left_to_right$172
	cmp	eax, 7
	jne	SHORT $LN88@ParseParam

; 901  :             case LANG_FASTCALL:
; 902  : #if AMD64_SUPPORT
; 903  :                 if ( ti.Ofssize == USE64 )

	movzx	eax, BYTE PTR ti$[rbp-82]
	cmp	al, 2
	je	SHORT $left_to_right$172

; 904  :                     goto left_to_right;
; 905  : #endif
; 906  :                 /* v2.07: MS fastcall 16-bit is PASCAL! */
; 907  :                 if ( ti.Ofssize == USE16 && ModuleInfo.fctype == FCT_MSC )

	test	al, al
	jne	SHORT $LN88@ParseParam
	cmp	DWORD PTR ModuleInfo+376, r15d
	jne	SHORT $LN88@ParseParam
$left_to_right$172:

; 884  :             case LANG_BASIC:
; 885  :             case LANG_FORTRAN:
; 886  :             case LANG_PASCAL:
; 887  :             left_to_right:
; 888  :                 paranode->nextparam = NULL;

	mov	QWORD PTR [rbx+112], r15

; 889  :                 if( proc->e.procinfo->paralist == NULL ) {

	mov	rax, QWORD PTR [r14+96]
	mov	rcx, QWORD PTR [rax+8]
	test	rcx, rcx
	je	SHORT $LN167@ParseParam

; 893  :                         if( paracurr->nextparam == NULL ) {

	mov	rax, QWORD PTR [rcx+112]
	test	rax, rax
	je	SHORT $LN122@ParseParam
	npad	1
$LL25@ParseParam:

; 890  :                     proc->e.procinfo->paralist = paranode;
; 891  :                 } else {
; 892  :                     for( paracurr = proc->e.procinfo->paralist;; paracurr = paracurr->nextparam ) {

	mov	rcx, rax

; 893  :                         if( paracurr->nextparam == NULL ) {

	mov	rax, QWORD PTR [rax+112]
	test	rax, rax
	jne	SHORT $LL25@ParseParam
$LN122@ParseParam:

; 894  :                             break;
; 895  :                         }
; 896  :                     }
; 897  :                     paracurr->nextparam = paranode;

	mov	QWORD PTR [rcx+112], rbx

; 898  :                     paracurr = NULL;

	mov	rdi, r15

; 899  :                 }
; 900  :                 break;

	jmp	SHORT $LN168@ParseParam
$LN88@ParseParam:

; 908  :                     goto left_to_right;
; 909  :             default:
; 910  :                 paranode->nextparam = proc->e.procinfo->paralist;

	mov	rax, QWORD PTR [r14+96]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rbx+112], rcx

; 911  :                 proc->e.procinfo->paralist = paranode;

	mov	rax, QWORD PTR [r14+96]
$LN167@ParseParam:
	mov	QWORD PTR [rax+8], rbx
$LN168@ParseParam:
	mov	r10d, DWORD PTR i$[rbp-104]
	movzx	ebx, BYTE PTR IsPROC$[rbp-104]
$LN21@ParseParam:

; 912  :                 break;
; 913  :             }
; 914  :         }
; 915  :         if ( tokenarray[i].token != T_FINAL ) {

	mov	r9, QWORD PTR tokenarray$[rbp-104]
	movsxd	rax, r10d
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+r9]
	test	cl, cl
	je	SHORT $LN5@ParseParam

; 916  :             if( tokenarray[i].token != T_COMMA ) {

	cmp	cl, 44					; 0000002cH
	jne	SHORT $LN128@ParseParam

; 919  :             }
; 920  :             i++;    /* go past comma */

	inc	r10d
	mov	DWORD PTR i$[rbp-104], r10d
$LN5@ParseParam:

; 662  : 
; 663  :     for( cntParam = 0 ; tokenarray[i].token != T_FINAL ; cntParam++ ) {

	inc	r13d
	movsxd	rax, r10d
	shl	rax, 5
	lea	rcx, QWORD PTR [rax+r9]
	jmp	$LN170@ParseParam
$LN123@ParseParam:

; 699  :                 return( EmitError( COLON_EXPECTED ) );

	mov	ecx, 84					; 00000054H
	call	EmitError
	jmp	$LN1@ParseParam
$LN54@ParseParam:

; 715  :                 case LANG_NONE:
; 716  :                 case LANG_BASIC:
; 717  :                 case LANG_FORTRAN:
; 718  :                 case LANG_PASCAL:
; 719  :                 case LANG_STDCALL:
; 720  :                     return( EmitError( VARARG_REQUIRES_C_CALLING_CONVENTION ) );

	mov	ecx, 94					; 0000005eH
	call	EmitError
	jmp	$LN1@ParseParam
$LN125@ParseParam:

; 738  :             DebugMsg(("ParseParams: %s defined already, state=%u, local=%u\n", sym->name, sym->state, sym->scoped ));
; 739  :             return( EmitErr( SYMBOL_REDEFINITION, name ) );

	mov	rdx, r12
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@ParseParam
$LN128@ParseParam:

; 917  :                 DebugMsg(("ParseParams: error, cntParam=%u, found %s\n", cntParam, tokenarray[i].tokpos ));
; 918  :                 return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rdx, r10d
	mov	ecx, 39					; 00000027H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r9+24]
	call	EmitErr
	jmp	$LN1@ParseParam
$LN126@ParseParam:

; 831  :             /* second definition has more parameters than first */
; 832  :             DebugMsg(("ParseParams: different param count\n"));
; 833  :             return( EmitErr( CONFLICTING_PARAMETER_DEFINITION, "" ) );

	lea	rdx, OFFSET FLAT:$SG11630
	mov	ecx, 137				; 00000089H
	call	EmitErr
	jmp	$LN1@ParseParam
$LN124@ParseParam:

; 732  :                     return( ERROR );

	or	eax, -1
	jmp	$LN1@ParseParam
$LN41@ParseParam:

; 672  :         } else {
; 673  :             /* PROC needs a parameter name, PROTO accepts <void> also */
; 674  :             DebugMsg(("ParseParams: name missing/invalid for parameter %u, i=%u\n", cntParam+1, i));
; 675  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, r10d
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r9+8]
	call	EmitErr
	jmp	$LN1@ParseParam
$LN161@ParseParam:

; 921  :         }
; 922  :     } /* end for */
; 923  : 
; 924  :     //if ( proc->e.procinfo->init_done == TRUE ) {
; 925  :     if ( init_done == TRUE ) {

	cmp	BYTE PTR init_done$1$[rbp-104], 1
	jne	SHORT $LN93@ParseParam

; 926  :         if ( paracurr ) {

	test	rdi, rdi
	je	SHORT $LN93@ParseParam

; 927  :             /* first definition has more parameters than second */
; 928  :             DebugMsg(("ParseParams: a param is left over, cntParam=%u\n", cntParam));
; 929  :             return( EmitErr( CONFLICTING_PARAMETER_DEFINITION, "" ) );

	lea	rdx, OFFSET FLAT:$SG11652
	mov	ecx, 137				; 00000089H
	call	EmitErr
	jmp	$LN1@ParseParam
$LN93@ParseParam:

; 930  :         }
; 931  :     }
; 932  : 
; 933  :     if ( IsPROC ) {

	test	bl, bl
	je	$LN30@ParseParam

; 934  :         /* calc starting offset for parameters,
; 935  :          * offset from [E|R]BP : return addr + old [E|R]BP
; 936  :          * NEAR: 2 * wordsize, FAR: 3 * wordsize
; 937  :          *         NEAR  FAR
; 938  :          *-------------------------
; 939  :          * USE16   +4    +6
; 940  :          * USE32   +8    +12
; 941  :          * USE64   +16   +24
; 942  :          * without frame pointer:
; 943  :          * USE16   +2    +4
; 944  :          * USE32   +4    +8
; 945  :          * USE64   +8    +16
; 946  :          */
; 947  :         offset = ( ( 2 + ( proc->sym.mem_type == MT_FAR ? 1 : 0 ) ) * CurrWordSize );

	cmp	DWORD PTR [r14+36], 130			; 00000082H
	movzx	eax, BYTE PTR ModuleInfo+406
	sete	r15b
	add	r15d, 2
	imul	r15d, eax

; 948  : 
; 949  :         /* now calculate the [E|R]BP offsets */
; 950  : 
; 951  : #if AMD64_SUPPORT
; 952  :         if ( ModuleInfo.Ofssize == USE64 && proc->sym.langtype == LANG_FASTCALL ) {

	cmp	BYTE PTR ModuleInfo+404, 2
	jne	SHORT $LN95@ParseParam
	cmp	DWORD PTR [r14+76], 7
	jne	SHORT $LN95@ParseParam

; 953  :             for ( paranode = proc->e.procinfo->paralist; paranode ;paranode = paranode->nextparam )

	mov	rax, QWORD PTR [r14+96]
	mov	r8, QWORD PTR [rax+8]
	test	r8, r8
	je	$LN30@ParseParam
	npad	3
$LL28@ParseParam:

; 954  :                 if ( paranode->sym.state == SYM_TMACRO ) /* register param */

	cmp	DWORD PTR [r8+32], 10
	je	SHORT $LN26@ParseParam

; 955  :                     ;
; 956  :                 else {
; 957  :                     paranode->sym.offset = offset;

	mov	DWORD PTR [r8+16], r15d

; 958  :                     proc->e.procinfo->stackparam = TRUE;

	mov	rax, QWORD PTR [r14+96]
	or	BYTE PTR [rax+84], 32			; 00000020H

; 959  :                     offset += ROUND_UP( paranode->sym.total_size, CurrWordSize );

	movzx	ecx, BYTE PTR ModuleInfo+406
	lea	edx, DWORD PTR [rcx-1]
	add	edx, DWORD PTR [r8+56]
	lea	eax, DWORD PTR [rcx-1]
	not	eax
	and	edx, eax
	add	r15d, edx

; 960  :                     //set isparam var for W64F_HABRAN
; 961  :                     if (ModuleInfo.win64_flags & W64F_HABRAN) paranode->sym.isparam = TRUE;

	test	BYTE PTR ModuleInfo+413, 11
	je	SHORT $LN26@ParseParam
	or	BYTE PTR [r8+41], 128			; 00000080H
$LN26@ParseParam:

; 953  :             for ( paranode = proc->e.procinfo->paralist; paranode ;paranode = paranode->nextparam )

	mov	r8, QWORD PTR [r8+112]
	test	r8, r8
	jne	SHORT $LL28@ParseParam

; 962  :                 }
; 963  :         } else

	jmp	SHORT $LN30@ParseParam
$LN95@ParseParam:

; 964  : #endif
; 965  :         for ( ; cntParam; cntParam-- ) {

	test	r13d, r13d
	je	SHORT $LN30@ParseParam
	npad	7
$LL31@ParseParam:

; 966  :             for ( curr = 1, paranode = proc->e.procinfo->paralist; curr < cntParam;paranode = paranode->nextparam, curr++ );

	mov	rax, QWORD PTR [r14+96]
	mov	rax, QWORD PTR [rax+8]
	cmp	r13d, 1
	jle	SHORT $LN33@ParseParam
	lea	edx, DWORD PTR [r13-1]
$LL34@ParseParam:
	mov	rax, QWORD PTR [rax+112]
	sub	rdx, 1
	jne	SHORT $LL34@ParseParam
$LN33@ParseParam:

; 967  :             DebugMsg1(("ParseParams: parm=%s, ofs=%u, size=%d\n", paranode->sym.name, offset, paranode->sym.total_size));
; 968  :             if ( paranode->sym.state == SYM_TMACRO ) /* register param? */

	cmp	DWORD PTR [rax+32], 10
	je	SHORT $LN29@ParseParam

; 969  :                 ;
; 970  :             else {
; 971  :                 paranode->sym.offset = offset;

	mov	DWORD PTR [rax+16], r15d

; 972  :                 proc->e.procinfo->stackparam = TRUE;

	mov	rcx, QWORD PTR [r14+96]
	or	BYTE PTR [rcx+84], 32			; 00000020H

; 973  :                 offset += ROUND_UP( paranode->sym.total_size, CurrWordSize );

	movzx	edx, BYTE PTR ModuleInfo+406
	lea	r8d, DWORD PTR [rdx-1]
	add	r8d, DWORD PTR [rax+56]
	lea	eax, DWORD PTR [rdx-1]
	not	eax
	and	r8d, eax
	add	r15d, r8d
$LN29@ParseParam:

; 964  : #endif
; 965  :         for ( ; cntParam; cntParam-- ) {

	sub	r13d, 1
	jne	SHORT $LL31@ParseParam
$LN30@ParseParam:

; 974  :             }
; 975  :         }
; 976  :     }
; 977  :     return ( NOT_ERROR );

	xor	eax, eax
$LN1@ParseParam:
	mov	r12, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]

; 978  : }

	add	rsp, 104				; 00000068H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rbx
	pop	rbp
	ret	0
ParseParams ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
sym$ = 8
opnd$ = 16
UpdateProcStatus PROC

; 620  :     sym->value = ( CurrProc ? ProcStatus : 0 );

	xor	eax, eax
	cmp	QWORD PTR CurrProc, rax
	cmovne	eax, DWORD PTR ProcStatus
	mov	DWORD PTR [rcx+16], eax

; 621  : }

	ret	0
UpdateProcStatus ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
sym$ = 8
opnd$ = 16
UpdateStackBase PROC

; 607  :     if ( opnd ) {

	test	rdx, rdx
	je	SHORT $LN4@UpdateStac

; 608  :         StackAdj = opnd->uvalue;

	mov	r8d, DWORD PTR [rdx]
	mov	DWORD PTR StackAdj, r8d

; 609  :         StackAdjHigh = opnd->hvalue;

	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR StackAdjHigh, eax

; 610  :     }
; 611  :     sym->value = StackAdj;

	mov	DWORD PTR [rcx+16], r8d

; 612  :     sym->value3264 = StackAdjHigh;

	mov	eax, DWORD PTR StackAdjHigh
	mov	DWORD PTR [rcx+56], eax

; 613  : }

	ret	0
$LN4@UpdateStac:

; 610  :     }
; 611  :     sym->value = StackAdj;

	mov	eax, DWORD PTR StackAdj
	mov	DWORD PTR [rcx+16], eax

; 612  :     sym->value3264 = StackAdjHigh;

	mov	eax, DWORD PTR StackAdjHigh
	mov	DWORD PTR [rcx+56], eax

; 613  : }

	ret	0
UpdateStackBase ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
ti$ = 48
opndx$1 = 80
i$ = 224
tokenarray$ = 232
LocalDir PROC

; 441  : {

$LN66:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	lea	rbp, QWORD PTR [rsp-79]
	sub	rsp, 200				; 000000c8H

; 442  :     char        *name;
; 443  :     struct dsym *local;
; 444  :     struct dsym *curr;
; 445  :     struct proc_info *info;
; 446  :     //int         size;
; 447  :     //int         idx;
; 448  :     struct qualified_type ti;
; 449  : 
; 450  :     if ( Parse_Pass != PASS_1 ) /* everything is done in pass 1 */

	cmp	DWORD PTR Parse_Pass, 0
	mov	rdi, rdx
	mov	r8d, ecx
	je	SHORT $LN13@LocalDir

; 451  :         return( NOT_ERROR );

	xor	eax, eax

; 598  : }

	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rbp
	ret	0
$LN13@LocalDir:

; 452  : 
; 453  :     DebugMsg1(("LocalDir(%u) entry\n", i));
; 454  : 
; 455  :     if( !( ProcStatus & PRST_PROLOGUE_NOT_DONE ) || CurrProc == NULL ) {

	test	BYTE PTR ProcStatus, -128		; ffffffffffffff80H
	je	$LN15@LocalDir
	mov	rax, QWORD PTR CurrProc
	test	rax, rax
	je	$LN15@LocalDir

; 457  :     }
; 458  :     info = CurrProc->e.procinfo;

	mov	QWORD PTR [rsp+240], rsi
	mov	rsi, QWORD PTR [rax+96]
	mov	QWORD PTR [rsp+192], r14

; 459  : #if STACKBASESUPP
; 460  :     /* ensure the fpo bit is set - it's too late to set it in write_prologue().
; 461  :      * Note that the fpo bit is set only IF there are locals or arguments.
; 462  :      * fixme: what if pass > 1?
; 463  :      */
; 464  :     if ( GetRegNo( info->basereg ) == 4 ) {

	movzx	eax, WORD PTR [rsi+86]
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, OFFSET FLAT:SpecialTable+10
	cmp	BYTE PTR [rax+rcx*4], 4
	jne	SHORT $LN16@LocalDir

; 465  :         info->fpo = TRUE;

	or	BYTE PTR [rsi+84], 128			; 00000080H

; 466  :         ProcStatus |= PRST_FPO;

	or	DWORD PTR ProcStatus, 4
	mov	r8d, DWORD PTR i$[rbp-121]
$LN16@LocalDir:

; 467  :     }
; 468  : #endif
; 469  : 
; 470  :     i++; /* go past LOCAL */

	inc	r8d
	mov	QWORD PTR [rsp+232], rbx
	mov	DWORD PTR i$[rbp-121], r8d
	xor	r14d, r14d
$LL4@LocalDir:

; 471  : 
; 472  :     do  {
; 473  :         if( tokenarray[i].token != T_ID ) {

	movsxd	rax, r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 8
	jne	$LN46@LocalDir

; 475  :         }
; 476  :         name = tokenarray[i].string_ptr;

	mov	rdx, QWORD PTR [rax+rdi+8]

; 477  : 
; 478  :         DebugMsg1(("LocalDir: item=%s\n", tokenarray[i].tokpos ));
; 479  : 
; 480  :         ti.symtype = NULL;
; 481  :         ti.is_ptr = 0;
; 482  :         ti.ptr_memtype = MT_EMPTY;
; 483  :         if ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) )

	mov	eax, 1
	mov	ecx, DWORD PTR ModuleInfo+360
	shl	al, cl

; 484  :             ti.is_far = TRUE;
; 485  :         else
; 486  :             ti.is_far = FALSE;
; 487  :         ti.Ofssize = ModuleInfo.Ofssize;
; 488  : 
; 489  : #if 0
; 490  :         /* since v1.95 a local hash table is used. No need to search the
; 491  :          * symbol before SymLCreate() is called. SymLCreate() will display
; 492  :          * an error if the symbol is already defined.
; 493  :          */
; 494  :         if ((local = (struct dsym *)SymSearch( name )) && local->sym.state != SYM_UNDEFINED ) {
; 495  :             return( EmitErr( SYMBOL_ALREADY_DEFINED, name ) );
; 496  :         }
; 497  : #endif
; 498  :         local = (struct dsym *)SymLCreate( name );

	mov	rcx, rdx
	test	al, 104					; 00000068H
	mov	QWORD PTR ti$[rbp-113], r14
	movzx	eax, BYTE PTR ModuleInfo+404
	setne	BYTE PTR ti$[rbp-100]
	mov	BYTE PTR ti$[rbp-99], al
	mov	BYTE PTR ti$[rbp-101], r14b
	mov	DWORD PTR ti$[rbp-97], 192		; 000000c0H
	call	SymLCreate
	mov	rbx, rax

; 499  :         if( !local ) { /* if it failed, an error msg has been written already */

	test	rax, rax
	je	$LN50@LocalDir

; 500  :             DebugMsg(("LocalDir: SymLCreate( %s ) failed\n", name ));
; 501  :             return( ERROR );
; 502  :         }
; 503  :         if (ModuleInfo.win64_flags & W64F_HABRAN) local->sym.isparam = FALSE; //clear isparam var, added  by habran

	test	BYTE PTR ModuleInfo+413, 11
	je	SHORT $LN21@LocalDir
	and	BYTE PTR [rax+41], 127			; 0000007fH
$LN21@LocalDir:

; 504  :         local->sym.state = SYM_STACK;
; 505  :         local->sym.isdefined = TRUE;

	or	BYTE PTR [rax+40], 2
	mov	DWORD PTR [rax+32], 5

; 506  :         local->sym.total_length = 1; /* v2.04: added */

	mov	DWORD PTR [rax+64], 1

; 507  :         switch ( ti.Ofssize ) {

	cmp	BYTE PTR ti$[rbp-99], r14b
	je	SHORT $LN22@LocalDir

; 511  :             break;
; 512  : #if AMD64_SUPPORT
; 513  :             /* v2.08: default type for locals in 64-bit is still DWORD (at least in Win64) */
; 514  :             //case USE64: local->sym.mem_type = MT_QWORD; break;
; 515  :             //ti.size = sizeof( uint_64 );
; 516  : #endif
; 517  :         default: 
; 518  :             local->sym.mem_type = MT_DWORD;

	mov	DWORD PTR [rax+36], 3

; 519  :             ti.size = sizeof( uint_32 );

	mov	DWORD PTR ti$[rbp-121], 4
	jmp	SHORT $LN5@LocalDir
$LN22@LocalDir:

; 508  :         case USE16:
; 509  :             local->sym.mem_type = MT_WORD;

	mov	DWORD PTR [rax+36], 1

; 510  :             ti.size = sizeof( uint_16 );

	mov	DWORD PTR ti$[rbp-121], 2
$LN5@LocalDir:

; 520  :             break;
; 521  :         }
; 522  : 
; 523  :         i++; /* go past name */

	mov	eax, DWORD PTR i$[rbp-121]
	inc	eax

; 524  : 
; 525  :         /* get the optional index factor: local name[xx]:... */
; 526  :         if( tokenarray[i].token == T_OP_SQ_BRACKET ) {

	movsxd	rcx, eax
	shl	rcx, 5
	mov	DWORD PTR i$[rbp-121], eax
	cmp	BYTE PTR [rcx+rdi], 91			; 0000005bH
	jne	$LN30@LocalDir

; 527  :             int j;
; 528  :             struct expr opndx;
; 529  :             i++; /* go past '[' */
; 530  :             /* scan for comma or colon. this isn't really necessary,
; 531  :              * but will prevent the expression evaluator from emitting
; 532  :              * confusing error messages.
; 533  :              */
; 534  :             for ( j = i; j < Token_Count; j++ )

	mov	r8d, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR i$[rbp-121], eax
	cmp	eax, r8d
	jge	SHORT $LN60@LocalDir
	movsxd	rcx, eax
	shl	rcx, 5
	add	rcx, rdi
$LL9@LocalDir:

; 535  :                 if ( tokenarray[j].token == T_COMMA ||

	movzx	edx, BYTE PTR [rcx]
	cmp	dl, 44					; 0000002cH
	je	SHORT $LN60@LocalDir
	cmp	dl, 58					; 0000003aH
	je	SHORT $LN60@LocalDir

; 527  :             int j;
; 528  :             struct expr opndx;
; 529  :             i++; /* go past '[' */
; 530  :             /* scan for comma or colon. this isn't really necessary,
; 531  :              * but will prevent the expression evaluator from emitting
; 532  :              * confusing error messages.
; 533  :              */
; 534  :             for ( j = i; j < Token_Count; j++ )

	inc	eax
	add	rcx, 32					; 00000020H
	cmp	eax, r8d
	jl	SHORT $LL9@LocalDir
$LN60@LocalDir:

; 536  :                     tokenarray[j].token == T_COLON)
; 537  :                     break;
; 538  :             if ( ERROR == EvalOperand( &i, tokenarray, j, &opndx, 0 ) )

	lea	r9, QWORD PTR opndx$1[rbp-121]
	mov	BYTE PTR [rsp+32], r14b
	mov	r8d, eax
	lea	rcx, QWORD PTR i$[rbp-121]
	mov	rdx, rdi
	call	EvalOperand
	cmp	eax, -1
	je	$LN50@LocalDir

; 539  :                 return( ERROR );
; 540  :             if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$1[rbp-61], r14d
	je	SHORT $LN59@LocalDir

; 541  :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 542  :                 opndx.value = 1;

	mov	eax, 1
	mov	DWORD PTR opndx$1[rbp-121], eax
	jmp	SHORT $LN28@LocalDir
$LN59@LocalDir:
	mov	eax, DWORD PTR opndx$1[rbp-121]
$LN28@LocalDir:

; 543  :             }
; 544  :             /* zero is allowed as value! */
; 545  :             local->sym.total_length = opndx.value;
; 546  :             local->sym.isarray = TRUE;

	or	BYTE PTR [rbx+41], 2
	mov	DWORD PTR [rbx+64], eax

; 547  :             if( tokenarray[i].token == T_CL_SQ_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rbp-121]
	mov	rcx, rax
	shl	rcx, 5
	cmp	BYTE PTR [rcx+rdi], 93			; 0000005dH
	jne	SHORT $LN29@LocalDir

; 548  :                 i++; /* go past ']' */

	inc	eax
	mov	DWORD PTR i$[rbp-121], eax

; 549  :             } else {

	jmp	SHORT $LN30@LocalDir
$LN29@LocalDir:

; 550  :                 EmitError( EXPECTED_CL_SQ_BRACKET );

	mov	ecx, 111				; 0000006fH
	call	EmitError
	mov	eax, DWORD PTR i$[rbp-121]
$LN30@LocalDir:

; 551  :             }
; 552  :         }
; 553  : 
; 554  :         /* get the optional type: local name[xx]:type  */
; 555  :         if( tokenarray[i].token == T_COLON ) {

	movsxd	rcx, eax
	shl	rcx, 5
	cmp	BYTE PTR [rcx+rdi], 58			; 0000003aH
	jne	SHORT $LN34@LocalDir

; 556  :             i++;

	inc	eax

; 557  : 
; 558  :             if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rbp-121]
	mov	rdx, rdi
	mov	DWORD PTR i$[rbp-121], eax
	lea	rcx, QWORD PTR i$[rbp-121]
	call	GetQualifiedType
	cmp	eax, -1
	je	$LN50@LocalDir

; 560  : 
; 561  :             local->sym.mem_type = ti.mem_type;

	mov	eax, DWORD PTR ti$[rbp-105]
	mov	DWORD PTR [rbx+36], eax

; 562  :             if ( ti.mem_type == MT_TYPE ) {

	cmp	DWORD PTR ti$[rbp-105], 196		; 000000c4H

; 563  :                 local->sym.type = ti.symtype;

	mov	rax, QWORD PTR ti$[rbp-113]
	jne	SHORT $LN33@LocalDir
	mov	QWORD PTR [rbx+80], rax

; 564  :             } else {

	jmp	SHORT $LN34@LocalDir
$LN33@LocalDir:

; 565  :                 local->sym.target_type = ti.symtype;

	mov	QWORD PTR [rbx+48], rax
$LN34@LocalDir:

; 566  :             }
; 567  :             DebugMsg1(("LocalDir: memtype=%X, type=%s, size=%u*%u\n",
; 568  :                        local->sym.mem_type,
; 569  :                        ti.symtype ? ti.symtype->name : "NULL",
; 570  :                        ti.size, local->sym.total_length ));
; 571  :         }
; 572  :         local->sym.is_ptr  = ti.is_ptr;

	movzx	eax, BYTE PTR ti$[rbp-101]
	mov	BYTE PTR [rbx+45], al

; 573  :         local->sym.isfar   = ti.is_far;

	movzx	eax, BYTE PTR ti$[rbp-100]
	shl	al, 4
	xor	al, BYTE PTR [rbx+47]
	and	al, 16
	xor	BYTE PTR [rbx+47], al

; 574  :         local->sym.Ofssize = ti.Ofssize;

	movzx	eax, BYTE PTR ti$[rbp-99]
	mov	BYTE PTR [rbx+44], al

; 575  :         local->sym.ptr_memtype = ti.ptr_memtype;

	movzx	eax, BYTE PTR ti$[rbp-97]
	mov	BYTE PTR [rbx+46], al

; 576  :         local->sym.total_size = ti.size * local->sym.total_length;

	mov	eax, DWORD PTR [rbx+64]
	imul	eax, DWORD PTR ti$[rbp-121]
	mov	DWORD PTR [rbx+56], eax

; 577  : 
; 578  :         /* v2.12: address calculation is now done in SetLocalOffsets() */
; 579  : 
; 580  :         if( info->locallist == NULL ) {

	mov	rcx, QWORD PTR [rsi+16]
	test	rcx, rcx
	jne	SHORT $LN35@LocalDir

; 581  :             info->locallist = local;

	mov	QWORD PTR [rsi+16], rbx

; 582  :         } else {

	jmp	SHORT $LN36@LocalDir
$LN35@LocalDir:

; 583  :             for( curr = info->locallist; curr->nextlocal ; curr = curr->nextlocal );

	mov	rax, QWORD PTR [rcx+112]
	test	rax, rax
	je	SHORT $LN11@LocalDir
$LL12@LocalDir:
	mov	rcx, rax
	mov	rax, QWORD PTR [rax+112]
	test	rax, rax
	jne	SHORT $LL12@LocalDir
$LN11@LocalDir:

; 584  :             curr->nextlocal = local;

	mov	QWORD PTR [rcx+112], rbx
$LN36@LocalDir:

; 585  :         }
; 586  : 
; 587  :         if ( tokenarray[i].token != T_FINAL )

	movsxd	r8, DWORD PTR i$[rbp-121]
	mov	edx, DWORD PTR ModuleInfo+496
	mov	rax, r8
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+rdi]
	test	cl, cl
	je	SHORT $LN2@LocalDir

; 588  :             if ( tokenarray[i].token == T_COMMA ) {

	cmp	cl, 44					; 0000002cH
	jne	SHORT $LN38@LocalDir

; 589  :                 if ( (i + 1) < Token_Count )

	lea	eax, DWORD PTR [r8+1]
	cmp	eax, edx
	cmovl	r8d, eax
	mov	DWORD PTR i$[rbp-121], r8d
$LN2@LocalDir:

; 593  :             }
; 594  : 
; 595  :     } while ( i < Token_Count );

	cmp	r8d, edx
	jl	$LL4@LocalDir

; 596  : 
; 597  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN63@LocalDir
$LN50@LocalDir:

; 559  :                 return( ERROR );

	or	eax, -1
	jmp	SHORT $LN63@LocalDir
$LN38@LocalDir:

; 590  :                     i++;
; 591  :             } else {
; 592  :                 return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, r8
	mov	ecx, 39					; 00000027H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+24]
$LN64@LocalDir:

; 474  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	call	EmitErr
$LN63@LocalDir:
	mov	rbx, QWORD PTR [rsp+232]
	mov	rsi, QWORD PTR [rsp+240]
	mov	r14, QWORD PTR [rsp+192]

; 598  : }

	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rbp
	ret	0
$LN46@LocalDir:

; 474  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, r8d
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+8]
	jmp	SHORT $LN64@LocalDir
$LN15@LocalDir:

; 456  :         return( EmitError( PROC_MACRO_MUST_PRECEDE_LOCAL ) );

	mov	ecx, 92					; 0000005cH
	call	EmitError

; 598  : }

	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rbp
	ret	0
LocalDir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT pop_proc
_TEXT	SEGMENT
pop_proc PROC						; COMDAT

; 426  :     if( ProcStack == NULL )

	mov	rax, QWORD PTR ProcStack
	test	rax, rax
	jne	SHORT $LN2@pop_proc

; 429  : }

	ret	0
$LN2@pop_proc:

; 427  :         return( NULL );
; 428  :     return( (struct dsym *)popitem( &ProcStack ) );

	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR ProcStack, rcx
	mov	rax, QWORD PTR [rax+8]

; 429  : }

	ret	0
pop_proc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT push_proc
_TEXT	SEGMENT
proc$ = 48
push_proc PROC						; COMDAT

; 416  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 417  :     if ( Parse_Pass == PASS_1 ) /* get the locals stored so far */

	cmp	DWORD PTR Parse_Pass, 0
	mov	rbx, rcx
	jne	SHORT $LN2@push_proc

; 418  :         SymGetLocal( (struct asym *)proc );

	call	SymGetLocal
$LN2@push_proc:

; 419  :     pushitem( &ProcStack, proc );

	mov	ecx, 16
	call	LclAlloc
	mov	rdx, QWORD PTR ProcStack
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR ProcStack, rax

; 420  :     return;
; 421  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
push_proc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT popitem
_TEXT	SEGMENT
stk$ = 8
popitem	PROC						; COMDAT

; 386  :     void        **stack = stk;
; 387  :     struct qnode *node;
; 388  :     void        *elmt;
; 389  : 
; 390  :     node = (struct qnode *)(*stack);

	mov	rax, QWORD PTR [rcx]

; 391  :     *stack = node->next;

	mov	rdx, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rdx

; 392  :     elmt = (void *)node->elmt;
; 393  :     LclFree( node );
; 394  :     return( elmt );

	mov	rax, QWORD PTR [rax+8]

; 395  : }

	ret	0
popitem	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
;	COMDAT pushitem
_TEXT	SEGMENT
stk$ = 48
elmt$ = 56
pushitem PROC						; COMDAT

; 373  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	rbx, rdx

; 374  :     void      **stack = stk;
; 375  :     struct qnode *node;
; 376  : 
; 377  :     node = LclAlloc( sizeof( struct qnode ));

	mov	ecx, 16
	call	LclAlloc

; 378  :     node->next = *stack;

	mov	r8, QWORD PTR [rdi]

; 379  :     node->elmt = elmt;

	mov	QWORD PTR [rax+8], rbx

; 380  :     *stack = node;
; 381  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rax], r8
	mov	QWORD PTR [rdi], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
pushitem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
proc$ = 8
buffer$ = 16
ms64_return PROC

; 366  :     /* nothing to do, the caller cleans the stack */
; 367  :     return;
; 368  : }

	ret	0
ms64_return ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
proc$ = 8
paranode$ = 16
used$ = 24
ms64_pcheck PROC

; 355  :     /* since the parameter names refer the stack-backup locations,
; 356  :      * there's nothing to do here!
; 357  :      * That is, if a parameter's size is > 8, it has to be changed
; 358  :      * to a pointer. This is to be done yet.
; 359  :      */
; 360  :     return( 0 );

	xor	eax, eax

; 361  : }

	ret	0
ms64_pcheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
proc$ = 8
buffer$ = 16
watc_return PROC

; 293  :     int value;
; 294  :     value = 4 * CurrWordSize;
; 295  :     if( proc->e.procinfo->has_vararg == FALSE && proc->e.procinfo->parasize > value )

	mov	r8, QWORD PTR [rcx+96]
	movzx	eax, BYTE PTR ModuleInfo+406
	shl	eax, 2
	test	BYTE PTR [r8+84], 1
	jne	SHORT $LN2@watc_retur
	mov	r8d, DWORD PTR [r8+32]
	cmp	r8d, eax
	jbe	SHORT $LN2@watc_retur

; 296  :         sprintf( buffer + strlen( buffer ), "%d%c", proc->e.procinfo->parasize - value, ModuleInfo.radix != 10 ? 't' : NULLC );

	xor	r9d, r9d
	mov	ecx, 116				; 00000074H
	cmp	BYTE PTR ModuleInfo+396, 10
	cmovne	r9d, ecx
	sub	r8d, eax
	or	rcx, -1
	npad	8
$LL4@watc_retur:
	inc	rcx
	cmp	BYTE PTR [rdx+rcx], 0
	jne	SHORT $LL4@watc_retur
	add	rcx, rdx
	lea	rdx, OFFSET FLAT:$SG11388
	jmp	sprintf
$LN2@watc_retur:

; 297  :     return;
; 298  : }

	ret	0
watc_return ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
proc$ = 80
paranode$ = 88
used$ = 96
watc_pcheck PROC

; 211  : {

	push	rbx
	push	rbp
	push	r12
	push	r13
	sub	rsp, 40					; 00000028H
	mov	r12, r8
	mov	r13, rdx
	mov	rbx, rcx

; 212  :     static char regname[64];
; 213  :     static char regist[32];
; 214  :     int newflg;
; 215  :     int shift;
; 216  :     int firstreg;
; 217  :     uint_8 Ofssize = GetSymOfssize( &proc->sym );

	call	GetSymOfssize

; 218  :     int size = SizeFromMemtype( paranode->sym.mem_type, paranode->sym.Ofssize, paranode->sym.type );

	movzx	edx, BYTE PTR [r13+44]
	mov	ebp, eax
	mov	r8, QWORD PTR [r13+80]
	mov	ecx, DWORD PTR [r13+36]
	call	SizeFromMemtype

; 219  : 
; 220  :     /* v2.05: VARARG procs don't have register params */
; 221  :     if ( proc->e.procinfo->has_vararg )

	mov	rcx, QWORD PTR [rbx+96]
	mov	r9d, eax
	test	BYTE PTR [rcx+84], 1
	je	SHORT $LN10@watc_pchec

; 222  :         return( 0 );

	xor	eax, eax

; 288  : }

	add	rsp, 40					; 00000028H
	pop	r13
	pop	r12
	pop	rbp
	pop	rbx
	ret	0
$LN10@watc_pchec:
	dec	eax
	mov	QWORD PTR [rsp+96], r14
	test	eax, -4					; fffffffcH
	jne	SHORT $LN44@watc_pchec
	cmp	r9d, 3
	je	SHORT $LN44@watc_pchec

; 225  :         return( 0 );
; 226  : 
; 227  :     /* v2.05: rewritten. The old code didn't allow to "fill holes" */
; 228  :     if ( size == 8 ) {

	cmp	r9d, 8
	je	SHORT $LN43@watc_pchec

; 231  :     } else if ( size == 4 && Ofssize == USE16 ) {

	cmp	r9d, 4
	jne	SHORT $LN14@watc_pchec
	test	bpl, bpl
	jne	SHORT $LN14@watc_pchec

; 232  :         newflg = 3;
; 233  :         shift = 2;

	lea	ecx, QWORD PTR [r9-2]
	lea	r14d, QWORD PTR [r9-1]

; 234  :     } else {

	jmp	SHORT $LN15@watc_pchec
$LN14@watc_pchec:

; 235  :         newflg = 1;
; 236  :         shift = 1;

	mov	ecx, 1
	mov	r14d, ecx
	jmp	SHORT $LN15@watc_pchec
$LN44@watc_pchec:

; 223  : 
; 224  :     if ( size != 1 && size != 2 && size != 4 && size != 8 )

	cmp	r9d, 8
	jne	SHORT $LN42@watc_pchec
$LN43@watc_pchec:

; 229  :         newflg = Ofssize ? 3 : 15;

	test	bpl, bpl
	mov	r14d, 3

; 230  :         shift = Ofssize ? 2 : 4;

	mov	ecx, 2
	mov	eax, 15
	cmovne	eax, r14d
	mov	r14d, eax
	mov	eax, 4
	cmovne	eax, ecx
	mov	ecx, eax
$LN15@watc_pchec:

; 237  :     }
; 238  : 
; 239  :     /* scan if there's a free register (pair/quadrupel) */
; 240  :     for ( firstreg = 0; firstreg < 4 && (newflg & *used ); newflg <<= shift, firstreg += shift );

	mov	eax, DWORD PTR [r12]
	xor	ebx, ebx
	mov	edx, ebx
$LL4@watc_pchec:
	test	eax, r14d
	je	SHORT $LN3@watc_pchec
	shl	r14d, cl
	add	edx, ecx
	cmp	edx, 4
	jl	SHORT $LL4@watc_pchec

; 242  :         return( 0 );

	xor	eax, eax
	mov	r14, QWORD PTR [rsp+96]

; 288  : }

	add	rsp, 40					; 00000028H
	pop	r13
	pop	r12
	pop	rbp
	pop	rbx
	ret	0
$LN3@watc_pchec:

; 241  :     if ( firstreg >= 4 ) /* exit if nothing is free */

	cmp	edx, 4
	jl	SHORT $LN16@watc_pchec
$LN42@watc_pchec:

; 242  :         return( 0 );

	xor	eax, eax
	mov	r14, QWORD PTR [rsp+96]

; 288  : }

	add	rsp, 40					; 00000028H
	pop	r13
	pop	r12
	pop	rbp
	pop	rbx
	ret	0
$LN16@watc_pchec:
	mov	QWORD PTR [rsp+80], rsi

; 243  : 
; 244  :     paranode->sym.state = SYM_TMACRO;
; 245  :     switch ( size ) {

	or	rsi, -1
	mov	QWORD PTR [rsp+88], rdi
	lea	rdi, OFFSET FLAT:?regname@?1??watc_pcheck@@9@9
	mov	QWORD PTR [rsp+32], r15
	mov	DWORD PTR [r13+32], 10
	sub	r9d, 1
	je	$LN17@watc_pchec
	sub	r9d, 1
	je	$LN18@watc_pchec
	sub	r9d, 2
	je	$LN19@watc_pchec
	cmp	r9d, 4
	jne	$LN8@watc_pchec

; 260  :     case 8:
; 261  :         if ( Ofssize ) {
; 262  :             paranode->sym.regist[0] = watc_regs32[firstreg];

	lea	r15, OFFSET FLAT:__ImageBase
	test	bpl, bpl
	je	SHORT $LN23@watc_pchec
	movsxd	rcx, edx
	movzx	eax, WORD PTR watc_regs32[r15+rcx*4]
	mov	WORD PTR [r13+48], ax

; 263  :             paranode->sym.regist[1] = watc_regs32[firstreg+1];

	movzx	eax, WORD PTR watc_regs32[r15+rcx*4+4]
	mov	WORD PTR [r13+50], ax

; 264  :         } else {

	jmp	$LN8@watc_pchec
$LN23@watc_pchec:

; 265  :             /* the AX:BX:CX:DX sequence is for 16-bit only.
; 266  :              * fixme: no support for codeview debug info yet;
; 267  :              * the S_REGISTER record supports max 2 registers only.
; 268  :              */
; 269  :             for( firstreg = 0, regname[0] = NULLC; firstreg < 4; firstreg++ ) {

	mov	BYTE PTR ?regname@?1??watc_pcheck@@9@9, bl
	lea	rbp, OFFSET FLAT:$SG11376
$LL9@watc_pchec:

; 270  :                 GetResWName( watc_regs_qw[firstreg], regname + strlen( regname ) );

	mov	rdx, rsi
$LL49@watc_pchec:
	inc	rdx
	cmp	BYTE PTR [rdi+rdx], 0
	jne	SHORT $LL49@watc_pchec
	mov	ecx, DWORD PTR watc_regs_qw[r15+rbx*4]
	add	rdx, rdi
	call	GetResWName

; 271  :                 if ( firstreg != 3 )

	cmp	rbx, 3
	je	SHORT $LN7@watc_pchec

; 272  :                     strcat( regname, "::");

	lea	rax, QWORD PTR [rdi-1]
$LL47@watc_pchec:
	inc	rax
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LL47@watc_pchec
	xor	edx, edx
$LL48@watc_pchec:
	movzx	ecx, BYTE PTR [rdx+rbp]
	mov	BYTE PTR [rax+rdx], cl
	lea	rdx, QWORD PTR [rdx+1]
	test	cl, cl
	jne	SHORT $LL48@watc_pchec
$LN7@watc_pchec:

; 265  :             /* the AX:BX:CX:DX sequence is for 16-bit only.
; 266  :              * fixme: no support for codeview debug info yet;
; 267  :              * the S_REGISTER record supports max 2 registers only.
; 268  :              */
; 269  :             for( firstreg = 0, regname[0] = NULLC; firstreg < 4; firstreg++ ) {

	inc	rbx
	cmp	rbx, 4
	jl	SHORT $LL9@watc_pchec

; 237  :     }
; 238  : 
; 239  :     /* scan if there's a free register (pair/quadrupel) */
; 240  :     for ( firstreg = 0; firstreg < 4 && (newflg & *used ); newflg <<= shift, firstreg += shift );

	jmp	SHORT $LN8@watc_pchec
$LN19@watc_pchec:

; 252  :     case 4:
; 253  :         if ( Ofssize ) {
; 254  :             paranode->sym.regist[0] = watc_regs32[firstreg];

	lea	r15, OFFSET FLAT:__ImageBase
	test	bpl, bpl
	je	SHORT $LN20@watc_pchec
	movsxd	rax, edx
	movzx	eax, WORD PTR watc_regs32[r15+rax*4]

; 255  :         } else {

	jmp	SHORT $LN51@watc_pchec
$LN20@watc_pchec:

; 256  :             paranode->sym.regist[0] = watc_regs16[firstreg];

	movsxd	rcx, edx
	movzx	eax, WORD PTR watc_regs16[r15+rcx*4]
	mov	WORD PTR [r13+48], ax

; 257  :             paranode->sym.regist[1] = watc_regs16[firstreg+1];

	movzx	eax, WORD PTR watc_regs16[r15+rcx*4+4]
	mov	WORD PTR [r13+50], ax

; 258  :         }
; 259  :         break;

	jmp	SHORT $LN8@watc_pchec
$LN18@watc_pchec:

; 248  :         break;
; 249  :     case 2:
; 250  :         paranode->sym.regist[0] = watc_regs16[firstreg];

	movsxd	rax, edx
	lea	r15, OFFSET FLAT:__ImageBase
	movzx	eax, WORD PTR watc_regs16[r15+rax*4]

; 251  :         break;

	jmp	SHORT $LN51@watc_pchec
$LN17@watc_pchec:

; 246  :     case 1:
; 247  :         paranode->sym.regist[0] = watc_regs8[firstreg];

	movsxd	rax, edx
	lea	r15, OFFSET FLAT:__ImageBase
	movzx	eax, WORD PTR watc_regs8[r15+rax*4]
$LN51@watc_pchec:
	mov	WORD PTR [r13+48], ax
$LN8@watc_pchec:

; 273  :             }
; 274  :         }
; 275  :     }
; 276  :     if ( paranode->sym.regist[1] ) {

	cmp	WORD PTR [r13+50], 0
	mov	r15, QWORD PTR [rsp+32]
	je	SHORT $LN26@watc_pchec

; 277  :         sprintf( regname, "%s::%s",

	movzx	ecx, WORD PTR [r13+48]
	xor	edx, edx
	call	GetResWName
	movzx	ecx, WORD PTR [r13+50]
	lea	rdx, OFFSET FLAT:?regist@?1??watc_pcheck@@9@9
	mov	rbx, rax
	call	GetResWName
	mov	r8, rax
	lea	rdx, OFFSET FLAT:$SG11379
	mov	r9, rbx
	mov	rcx, rdi
	call	sprintf
	jmp	SHORT $LN28@watc_pchec
$LN26@watc_pchec:

; 278  :                 GetResWName( paranode->sym.regist[1], regist ),
; 279  :                 GetResWName( paranode->sym.regist[0], NULL ) );
; 280  :     } else if ( paranode->sym.regist[0] ) {

	movzx	eax, WORD PTR [r13+48]
	test	ax, ax
	je	SHORT $LN28@watc_pchec

; 281  :         GetResWName( paranode->sym.regist[0], regname );

	movzx	ecx, ax
	mov	rdx, rdi
	call	GetResWName
$LN28@watc_pchec:

; 282  :     }
; 283  :     *used |= newflg;

	or	DWORD PTR [r12], r14d
$LL46@watc_pchec:

; 284  :     paranode->sym.string_ptr = LclAlloc( strlen( regname ) + 1 );

	cmp	BYTE PTR [rdi+rsi+1], 0
	lea	rsi, QWORD PTR [rsi+1]
	jne	SHORT $LL46@watc_pchec
	lea	rcx, QWORD PTR [rsi+1]
	call	LclAlloc
	mov	rsi, QWORD PTR [rsp+80]
	mov	QWORD PTR [r13+16], rax
	npad	3
$LL30@watc_pchec:

; 285  :     strcpy( paranode->sym.string_ptr, regname );

	movzx	ecx, BYTE PTR [rdi]
	lea	rdi, QWORD PTR [rdi+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL30@watc_pchec

; 286  :     DebugMsg(("watc_pcheck(%s.%s): size=%u ptr=%u far=%u reg=%s\n", proc->sym.name, paranode->sym.name, size, paranode->sym.is_ptr, paranode->sym.isfar, regname ));
; 287  :     return( 1 );

	mov	rdi, QWORD PTR [rsp+88]
	mov	eax, 1
	mov	r14, QWORD PTR [rsp+96]

; 288  : }

	add	rsp, 40					; 00000028H
	pop	r13
	pop	r12
	pop	rbp
	pop	rbx
	ret	0
watc_pcheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
proc$ = 8
buffer$ = 16
ms32_return PROC

; 331  :     /* v2.07: changed */
; 332  :     //if( proc->e.procinfo->parasize > ( 2 * CurrWordSize ) )
; 333  :     //    sprintf( buffer + strlen( buffer ), "%d%c", proc->e.procinfo->parasize - (2 * CurrWordSize), ModuleInfo.radix != 10 ? 't' : NULLC );
; 334  :     if( proc->e.procinfo->parasize > ( ms32_maxreg[ModuleInfo.Ofssize] * CurrWordSize ) )

	movzx	r8d, BYTE PTR ModuleInfo+404
	lea	r9, OFFSET FLAT:ms32_maxreg
	movzx	eax, BYTE PTR ModuleInfo+406
	mov	r9d, DWORD PTR [r9+r8*4]
	imul	r9d, eax
	mov	rax, QWORD PTR [rcx+96]
	mov	r8d, DWORD PTR [rax+32]
	cmp	r8d, r9d
	jbe	SHORT $LN2@ms32_retur

; 335  :         sprintf( buffer + strlen( buffer ), "%d%c", proc->e.procinfo->parasize - ( ms32_maxreg[ModuleInfo.Ofssize] * CurrWordSize), ModuleInfo.radix != 10 ? 't' : NULLC );

	xor	eax, eax
	mov	ecx, 116				; 00000074H
	cmp	BYTE PTR ModuleInfo+396, 10
	cmovne	eax, ecx
	sub	r8d, r9d
	or	rcx, -1
$LL4@ms32_retur:
	inc	rcx
	cmp	BYTE PTR [rdx+rcx], 0
	jne	SHORT $LL4@ms32_retur
	add	rcx, rdx
	mov	r9d, eax
	lea	rdx, OFFSET FLAT:$SG11406
	jmp	sprintf
$LN2@ms32_retur:

; 336  :     return;
; 337  : }

	ret	0
ms32_return ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
regname$ = 32
proc$ = 80
paranode$ = 88
used$ = 96
ms32_pcheck PROC

; 310  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rdx
	mov	rbx, r8

; 311  :     char regname[32];
; 312  :     int size = SizeFromMemtype( paranode->sym.mem_type, paranode->sym.Ofssize, paranode->sym.type );

	movzx	edx, BYTE PTR [rdx+44]
	mov	r8, QWORD PTR [rdi+80]
	mov	ecx, DWORD PTR [rdi+36]
	call	SizeFromMemtype

; 313  : 
; 314  :     /* v2.07: 16-bit has 3 register params (AX,DX,BX) */
; 315  :     //if ( size > CurrWordSize || *used >= 2 )
; 316  :     if ( size > CurrWordSize || *used >= ms32_maxreg[ModuleInfo.Ofssize] )

	movzx	ecx, BYTE PTR ModuleInfo+406
	cmp	eax, ecx
	jg	$LN3@ms32_pchec
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR ms32_maxreg[rdx+rax*4]
	cmp	DWORD PTR [rbx], eax
	jge	$LN3@ms32_pchec

; 318  :     paranode->sym.state = SYM_TMACRO;

	mov	DWORD PTR [rdi+32], 10

; 319  :     /* v2.10: for codeview debug info, store the register index in the symbol */
; 320  :     paranode->sym.regist[0] = ModuleInfo.Ofssize ? ms32_regs32[*used] : ms32_regs16[*used];

	cmp	BYTE PTR ModuleInfo+404, 0
	movsxd	rax, DWORD PTR [rbx]
	je	SHORT $LN5@ms32_pchec
	mov	ecx, DWORD PTR ms32_regs32[rdx+rax*4]
	jmp	SHORT $LN6@ms32_pchec
$LN5@ms32_pchec:
	mov	ecx, DWORD PTR ms32_regs16[rdx+rax*4]
$LN6@ms32_pchec:
	mov	WORD PTR [rdi+48], cx

; 321  :     GetResWName( ModuleInfo.Ofssize ? ms32_regs32[*used] : ms32_regs16[*used], regname );

	cmp	BYTE PTR ModuleInfo+404, 0
	movsxd	rax, DWORD PTR [rbx]
	je	SHORT $LN7@ms32_pchec
	mov	ecx, DWORD PTR ms32_regs32[rdx+rax*4]
	jmp	SHORT $LN8@ms32_pchec
$LN7@ms32_pchec:
	mov	ecx, DWORD PTR ms32_regs16[rdx+rax*4]
$LN8@ms32_pchec:
	lea	rdx, QWORD PTR regname$[rsp]
	call	GetResWName

; 322  :     paranode->sym.string_ptr = LclAlloc( strlen( regname ) + 1 );

	lea	rax, QWORD PTR regname$[rsp]
	or	rcx, -1
$LL13@ms32_pchec:
	inc	rcx
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL13@ms32_pchec
	inc	rcx
	call	LclAlloc
	mov	QWORD PTR [rdi+16], rax

; 323  :     strcpy( paranode->sym.string_ptr, regname );

	lea	rdx, QWORD PTR regname$[rsp]
	npad	4
$LL9@ms32_pchec:
	movzx	ecx, BYTE PTR [rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL9@ms32_pchec

; 324  :     (*used)++;

	inc	DWORD PTR [rbx]

; 325  :     return( 1 );

	mov	eax, 1

; 326  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN3@ms32_pchec:

; 317  :         return( 0 );

	xor	eax, eax

; 326  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ms32_pcheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
ProcCheckOpen PROC

; 2097 : {

$LN60:
	sub	rsp, 40					; 00000028H

; 2098 :     while( CurrProc != NULL ) {

	mov	rax, QWORD PTR CurrProc
	test	rax, rax
	je	$LN3@ProcCheckO
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi
	xor	esi, esi
	mov	QWORD PTR [rsp+32], rdi
	npad	11
$LL2@ProcCheckO:

; 2099 :         DebugMsg1(("ProcCheckOpen: unmatched block nesting error, CurrProc=%s\n", CurrProc->sym.name ));
; 2100 :         EmitErr( UNMATCHED_BLOCK_NESTING, CurrProc->sym.name );

	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 142				; 0000008eH
	call	EmitErr

; 2101 :         ProcFini( CurrProc );

	mov	rdi, QWORD PTR CurrProc
	mov	rax, QWORD PTR ModuleInfo+432
	cmp	QWORD PTR [rdi+24], rax
	jne	SHORT $LN18@ProcCheckO
	call	GetCurrOffset
	jmp	SHORT $LN58@ProcCheckO
$LN18@ProcCheckO:
	mov	rdx, QWORD PTR [rdi+8]
	mov	ecx, 142				; 0000008eH
	call	EmitErr
	mov	rax, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rax+24]
	mov	eax, DWORD PTR [rcx+16]
$LN58@ProcCheckO:
	sub	eax, DWORD PTR [rdi+16]
	mov	DWORD PTR [rdi+56], eax
	cmp	BYTE PTR Options+13, 2
	jbe	SHORT $LN56@ProcCheckO
	cmp	DWORD PTR Parse_Pass, esi
	jne	$LN57@ProcCheckO
	mov	rax, QWORD PTR [rdi+96]
	mov	rbx, QWORD PTR [rax+8]
	test	rbx, rbx
	je	SHORT $LN7@ProcCheckO
	npad	3
$LL8@ProcCheckO:
	test	BYTE PTR [rbx+40], 1
	jne	SHORT $LN6@ProcCheckO
	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 266				; 0000010aH
	mov	ecx, 3
	call	EmitWarn
$LN6@ProcCheckO:
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL8@ProcCheckO
$LN7@ProcCheckO:
	mov	rbx, QWORD PTR [rdi+96]
	mov	rbx, QWORD PTR [rbx+16]
	test	rbx, rbx
	je	SHORT $LN56@ProcCheckO
	npad	1
$LL11@ProcCheckO:
	test	BYTE PTR [rbx+40], 1
	jne	SHORT $LN9@ProcCheckO
	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 266				; 0000010aH
	mov	ecx, 3
	call	EmitWarn
$LN9@ProcCheckO:
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL11@ProcCheckO
$LN56@ProcCheckO:
	cmp	DWORD PTR Parse_Pass, esi
	jne	SHORT $LN57@ProcCheckO
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN57@ProcCheckO
	test	BYTE PTR ModuleInfo+413, 2
	je	SHORT $LN57@ProcCheckO
	mov	rax, QWORD PTR sym_ReservedStack
	mov	rdx, QWORD PTR [rdi+96]
	mov	ecx, DWORD PTR [rax+16]
	mov	DWORD PTR [rdx+56], ecx
	mov	rdx, QWORD PTR [rdi+96]
	test	BYTE PTR [rdx+84], 128			; 00000080H
	je	SHORT $LN57@ProcCheckO
	mov	rdx, QWORD PTR [rdx+16]
	test	rdx, rdx
	je	SHORT $LN13@ProcCheckO
$LL14@ProcCheckO:
	mov	rax, QWORD PTR [rdi+96]
	mov	ecx, DWORD PTR [rax+56]
	add	DWORD PTR [rdx+16], ecx
	mov	rdx, QWORD PTR [rdx+112]
	test	rdx, rdx
	jne	SHORT $LL14@ProcCheckO
$LN13@ProcCheckO:
	mov	rax, QWORD PTR [rdi+96]
	mov	r8, QWORD PTR [rax+8]
	test	r8, r8
	je	SHORT $LN57@ProcCheckO
$LL17@ProcCheckO:
	mov	rax, QWORD PTR [rdi+96]
	mov	edx, DWORD PTR [rax+56]
	add	DWORD PTR [r8+16], edx
	mov	r8, QWORD PTR [r8+112]
	test	r8, r8
	jne	SHORT $LL17@ProcCheckO
$LN57@ProcCheckO:
	mov	rax, QWORD PTR [rdi+96]
	test	BYTE PTR [rax+84], 64			; 00000040H
	je	SHORT $LN25@ProcCheckO
	call	LstSetPosition
	mov	rcx, rdi
	call	WriteSEHData
$LN25@ProcCheckO:
	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN26@ProcCheckO
	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+7]
	call	LstWrite
$LN26@ProcCheckO:
	cmp	DWORD PTR Parse_Pass, esi
	jne	SHORT $LN27@ProcCheckO
	test	BYTE PTR ProcStatus, -128		; ffffffffffffff80H
	je	SHORT $LN28@ProcCheckO
	mov	rcx, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rcx+96]
	call	SetLocalOffsets
$LN28@ProcCheckO:
	mov	rcx, QWORD PTR CurrProc
	call	SymGetLocal
$LN27@ProcCheckO:
	mov	rcx, QWORD PTR ProcStack
	test	rcx, rcx
	jne	SHORT $LN32@ProcCheckO
	mov	rax, rsi
	mov	QWORD PTR CurrProc, rax
	jmp	SHORT $LN29@ProcCheckO
$LN32@ProcCheckO:
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR ProcStack, rax
	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR CurrProc, rax
	test	rax, rax
	je	SHORT $LN29@ProcCheckO
	mov	rcx, rax
	call	SymSetLocal
	mov	rax, QWORD PTR CurrProc
$LN29@ProcCheckO:
	mov	DWORD PTR ProcStatus, esi
	test	rax, rax
	jne	$LL2@ProcCheckO
	mov	rdi, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
$LN3@ProcCheckO:

; 2102 :     }
; 2103 : }

	add	rsp, 40					; 00000028H
	ret	0
ProcCheckOpen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
ProcInit PROC

; 3350 :     ProcStack = NULL;

	xor	eax, eax

; 3351 :     CurrProc  = NULL;
; 3352 :     procidx = 1;

	mov	DWORD PTR procidx, 1
	mov	QWORD PTR ProcStack, rax
	mov	QWORD PTR CurrProc, rax

; 3353 :     ProcStatus = 0;

	mov	DWORD PTR ProcStatus, eax

; 3354 :     /* v2.09: reset prolog and epilog mode */
; 3355 :     ModuleInfo.prologuemode = PEM_DEFAULT;

	mov	WORD PTR ModuleInfo+424, ax

; 3356 :     ModuleInfo.epiloguemode = PEM_DEFAULT;
; 3357 :     /* v2.06: no forward references in INVOKE if -Zne is set */
; 3358 :     ModuleInfo.invoke_exprparm = ( Options.strict_masm_compat ? EXPF_NOUNDEF : 0 );

	movzx	eax, BYTE PTR Options+127
	neg	al

; 3359 : #if STACKBASESUPP
; 3360 :     ModuleInfo.basereg[USE16] = T_BP;

	mov	DWORD PTR ModuleInfo+500, 14

; 3361 :     ModuleInfo.basereg[USE32] = T_EBP;

	mov	DWORD PTR ModuleInfo+504, 22
	sbb	cl, cl

; 3362 : #if AMD64_SUPPORT
; 3363 :     ModuleInfo.basereg[USE64] = T_RBP;

	mov	DWORD PTR ModuleInfo+508, 120		; 00000078H
	and	cl, 2

; 3364 : #endif
; 3365 : #endif
; 3366 : #if AMD64_SUPPORT
; 3367 :     unw_segs_defined = 0;

	mov	BYTE PTR unw_segs_defined, 0
	mov	BYTE PTR ModuleInfo+426, cl

; 3368 : #endif
; 3369 : }

	ret	0
ProcInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
tokenarray$ = 48
write_prologue PROC

; 2865 : {

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2866 :     /* reset @ProcStatus flag */
; 2867 :     ProcStatus &= ~PRST_PROLOGUE_NOT_DONE;

	and	DWORD PTR ProcStatus, -129		; ffffffffffffff7fH
	mov	rbx, rcx

; 2868 : 
; 2869 : #if AMD64_SUPPORT
; 2870 :     if ( ModuleInfo.fctype == FCT_WIN64 && ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) ) {

	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN3@write_prol
	test	BYTE PTR ModuleInfo+413, 2
	je	SHORT $LN3@write_prol

; 2871 :         /* in pass one init reserved stack with 4*8 to force stack frame creation */
; 2872 :         sym_ReservedStack->value = ( Parse_Pass == PASS_1 ? 4 * sizeof( uint_64 ) : CurrProc->e.procinfo->ReservedStack );

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN10@write_prol
	mov	edx, 32					; 00000020H
	jmp	SHORT $LN11@write_prol
$LN10@write_prol:
	mov	rax, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rax+96]
	movsxd	rdx, DWORD PTR [rcx+56]
$LN11@write_prol:
	mov	rax, QWORD PTR sym_ReservedStack
	mov	DWORD PTR [rax+16], edx

; 2873 :         if (Parse_Pass == PASS_1) sym_ReservedStack->hasinvoke = 0;

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN4@write_prol
	mov	rax, QWORD PTR sym_ReservedStack
	mov	DWORD PTR [rax+16], 0
$LN3@write_prol:

; 2874 :     }
; 2875 : #endif
; 2876 :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN4@write_prol

; 2877 :         /* v2.12: calculation of offsets of local variables is done delayed now */
; 2878 :         SetLocalOffsets( CurrProc->e.procinfo );

	mov	rcx, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rcx+96]
	call	SetLocalOffsets
$LN4@write_prol:

; 2879 :     }
; 2880 :     ProcStatus |= PRST_INSIDE_PROLOGUE;

	or	DWORD PTR ProcStatus, 1

; 2881 :     /* there are 3 cases:
; 2882 :      * option prologue:NONE           proc_prologue == NULL
; 2883 :      * option prologue:default        *proc_prologue == NULLC
; 2884 :      * option prologue:usermacro      *proc_prologue != NULLC
; 2885 :      */
; 2886 :     if ( ModuleInfo.prologuemode == PEM_DEFAULT ) {

	movzx	eax, BYTE PTR ModuleInfo+424
	test	al, al
	jne	SHORT $LN5@write_prol

; 2887 :         DebugMsg1(("write_prologue(%s): default prologue\n", CurrProc->sym.name ));
; 2888 :         write_default_prologue();

	call	write_default_prologue
	jmp	SHORT $LN8@write_prol
$LN5@write_prol:

; 2889 :     } else if ( ModuleInfo.prologuemode == PEM_NONE ) {

	cmp	al, 2
	je	SHORT $LN8@write_prol

; 2890 :         DebugMsg1(("write_prologue(%s): prologue is NULL\n", CurrProc->sym.name  ));
; 2891 :     } else {
; 2892 :         DebugMsg1(("write_prologue(%s): userdefined prologue %s\n", CurrProc->sym.name , ModuleInfo.proc_prologue ));
; 2893 :         write_userdef_prologue( tokenarray );

	mov	rcx, rbx
	call	write_userdef_prologue
$LN8@write_prol:

; 2894 :     }
; 2895 :     ProcStatus &= ~PRST_INSIDE_PROLOGUE;

	and	DWORD PTR ProcStatus, -2

; 2896 :     /* v2.10: for debug info, calculate prologue size */
; 2897 :     CurrProc->e.procinfo->size_prolog = GetCurrOffset() - CurrProc->sym.offset;

	call	GetCurrOffset
	mov	rcx, QWORD PTR CurrProc
	sub	al, BYTE PTR [rcx+16]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+85], al

; 2898 :     return;
; 2899 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
write_prologue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
buffer$ = 32
i$ = 1072
tokenarray$ = 1080
count$ = 1088
RetInstr PROC

; 3249 : {

$LN36:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 1056				; 00000420H
	movsxd	rdi, ecx

; 3250 :     struct proc_info   *info;
; 3251 :     bool        is_iret = FALSE;

	xor	sil, sil

; 3252 :     char        *p;
; 3253 : #ifdef DEBUG_OUT
; 3254 :     ret_code    rc;
; 3255 : #endif
; 3256 :     char        buffer[MAX_LINE_LEN]; /* stores modified RETN/RETF/IRET instruction */
; 3257 : 
; 3258 :     DebugMsg1(( "RetInstr() enter\n" ));
; 3259 : 
; 3260 : #if AMD64_SUPPORT
; 3261 :     if( tokenarray[i].tokval == T_IRET || tokenarray[i].tokval == T_IRETD || tokenarray[i].tokval == T_IRETQ )

	mov	rbx, rdi
	mov	r14d, r8d
	shl	rbx, 5
	mov	rbp, rdx
	mov	ecx, DWORD PTR [rbx+rdx+16]
	lea	eax, DWORD PTR [rcx-626]
	cmp	eax, 1
	jbe	SHORT $LN5@RetInstr
	cmp	ecx, 1207				; 000004b7H
	jne	SHORT $LN4@RetInstr
$LN5@RetInstr:

; 3262 : #else
; 3263 :     if( tokenarray[i].tokval == T_IRET || tokenarray[i].tokval == T_IRETD )
; 3264 : #endif
; 3265 :         is_iret = TRUE;

	mov	sil, 1
$LN4@RetInstr:

; 3266 : 
; 3267 :     if ( ModuleInfo.epiloguemode == PEM_MACRO ) {

	cmp	BYTE PTR ModuleInfo+425, 1
	jne	SHORT $LN6@RetInstr

; 3268 : #if FASTPASS
; 3269 :         /* don't run userdefined epilogue macro if pass > 1 */
; 3270 :         if ( UseSavedState ) {

	cmp	BYTE PTR UseSavedState, 0
	je	SHORT $LN7@RetInstr

; 3271 :             if ( Parse_Pass > PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN8@RetInstr

; 3272 :                 DebugMsg(( "RetInstr() exit\n" ));
; 3273 :                 //return( NOT_ERROR );
; 3274 :                 return( ParseLine( tokenarray ) );

	mov	rcx, rdx
	call	ParseLine
	jmp	$LN1@RetInstr
$LN8@RetInstr:

; 3275 :             }
; 3276 :             /* handle the current line as if it is REPLACED by the macro content */
; 3277 :             *(LineStoreCurr->line) = ';';

	mov	rax, QWORD PTR LineStoreCurr
	mov	BYTE PTR [rax+16], 59			; 0000003bH
$LN7@RetInstr:

; 3278 :         }
; 3279 : #endif
; 3280 : #ifdef DEBUG_OUT
; 3281 :         rc = write_userdef_epilogue( is_iret, tokenarray );
; 3282 :         DebugMsg(( "RetInstr() exit\n" ));
; 3283 :         return( rc );
; 3284 : #else
; 3285 :         return( write_userdef_epilogue( is_iret, tokenarray ) );

	movzx	ecx, sil
	call	write_userdef_epilogue
	jmp	$LN1@RetInstr
$LN6@RetInstr:

; 3286 : #endif
; 3287 :     }
; 3288 : 
; 3289 :     if ( ModuleInfo.list ) {

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN9@RetInstr

; 3290 :         LstWrite( LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL );

	call	GetCurrOffset
	xor	r8d, r8d
	mov	edx, eax
	lea	ecx, QWORD PTR [r8+4]
	call	LstWrite
$LN9@RetInstr:

; 3291 :     }
; 3292 : 
; 3293 :     strcpy( buffer, tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rbx+rbp+8]
	lea	rdx, QWORD PTR buffer$[rsp]
	sub	rdx, rcx
	npad	9
$LL24@RetInstr:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rdx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL24@RetInstr

; 3294 :     p = buffer + strlen( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	or	rax, -1
$LL33@RetInstr:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL33@RetInstr
	lea	rbx, QWORD PTR buffer$[rsp]
	add	rbx, rax

; 3295 : 
; 3296 :     write_default_epilogue();

	call	write_default_epilogue

; 3297 : 
; 3298 :     info = CurrProc->e.procinfo;

	mov	r8, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [r8+96]

; 3299 : 
; 3300 :     /* skip this part for IRET */
; 3301 :     if( is_iret == FALSE ) {

	test	sil, sil
	jne	SHORT $LN12@RetInstr

; 3302 :         if ( CurrProc->sym.mem_type == MT_FAR )

	cmp	DWORD PTR [r8+36], 130			; 00000082H
	jne	SHORT $LN11@RetInstr

; 3303 :             *p++ = 'f';   /* ret -> retf */

	mov	BYTE PTR [rbx], 102			; 00000066H
	jmp	SHORT $LN34@RetInstr
$LN11@RetInstr:

; 3304 :         else
; 3305 :             *p++ = 'n';     /* ret -> retn */

	mov	BYTE PTR [rbx], 110			; 0000006eH
$LN34@RetInstr:
	inc	rbx
$LN12@RetInstr:

; 3306 :     }
; 3307 :     i++; /* skip directive */

	inc	edi

; 3308 :     if ( info->parasize || ( count != i ) )

	cmp	DWORD PTR [rcx+32], 0
	jne	SHORT $LN14@RetInstr
	cmp	r14d, edi
	je	SHORT $LN13@RetInstr
$LN14@RetInstr:

; 3309 :         *p++ = ' ';

	mov	BYTE PTR [rbx], 32			; 00000020H
	inc	rbx
$LN13@RetInstr:

; 3310 :     *p = NULLC;

	mov	BYTE PTR [rbx], 0

; 3311 :     /* RET without argument? Then calculate the value */
; 3312 :     if( is_iret == FALSE && count == i ) {

	test	sil, sil
	jne	$LN15@RetInstr
	cmp	r14d, edi
	jne	$LN15@RetInstr

; 3313 :         if ( ModuleInfo.epiloguemode != PEM_NONE ) {

	cmp	BYTE PTR ModuleInfo+425, 2
	je	$LN16@RetInstr

; 3314 :             switch( CurrProc->sym.langtype ) {

	mov	eax, DWORD PTR [r8+76]
	cmp	eax, 3
	je	SHORT $LN21@RetInstr
	jle	$LN16@RetInstr
	cmp	eax, 6
	jle	SHORT $LN18@RetInstr
	cmp	eax, 7
	jne	$LN16@RetInstr

; 3322 :             case LANG_FASTCALL:
; 3323 :                 fastcall_tab[ModuleInfo.fctype].handlereturn( CurrProc, buffer );

	movsxd	rax, DWORD PTR ModuleInfo+376
	lea	r9, OFFSET FLAT:fastcall_tab+8
	add	rax, rax
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, r8
	call	QWORD PTR [r9+rax*8]

; 3324 :                 break;

	jmp	$LN16@RetInstr
$LN18@RetInstr:

; 3315 :             case LANG_BASIC:
; 3316 :             case LANG_FORTRAN:
; 3317 :             case LANG_PASCAL:
; 3318 :                 if( info->parasize != 0 ) {

	mov	r8d, DWORD PTR [rcx+32]
	test	r8d, r8d
	je	SHORT $LN16@RetInstr

; 3319 :                     sprintf( p, "%d%c", info->parasize, ModuleInfo.radix != 10 ? 't' : NULLC );

	xor	r9d, r9d
	lea	rdx, OFFSET FLAT:$SG12578
	cmp	BYTE PTR ModuleInfo+396, 10
	mov	eax, 116				; 00000074H
	mov	rcx, rbx
	cmovne	r9d, eax
	call	sprintf

; 3320 :                 }
; 3321 :                 break;

	jmp	SHORT $LN16@RetInstr
$LN21@RetInstr:

; 3325 :             case LANG_STDCALL:
; 3326 :                 if( !info->has_vararg && info->parasize != 0 ) {

	test	BYTE PTR [rcx+84], 1
	jne	SHORT $LN16@RetInstr
	mov	r8d, DWORD PTR [rcx+32]
	test	r8d, r8d
	je	SHORT $LN16@RetInstr

; 3327 :                     sprintf( p, "%d%c", info->parasize, ModuleInfo.radix != 10 ? 't' : NULLC  );

	xor	r9d, r9d
	lea	rdx, OFFSET FLAT:$SG12582
	cmp	BYTE PTR ModuleInfo+396, 10
	mov	eax, 116				; 00000074H
	mov	rcx, rbx
	cmovne	r9d, eax
	call	sprintf

; 3328 :                 }
; 3329 :                 break;
; 3330 :             }
; 3331 :         }
; 3332 :     } else {

	jmp	SHORT $LN16@RetInstr
$LN15@RetInstr:

; 3333 :         /* v2.04: changed. Now works for both RET nn and IRETx */
; 3334 :         /* v2.06: changed. Now works even if RET has ben "renamed" */
; 3335 :         strcpy( p, tokenarray[i].tokpos );

	movsxd	rax, edi
	shl	rax, 5
	mov	rcx, QWORD PTR [rax+rbp+24]
	sub	rbx, rcx
	npad	11
$LL25@RetInstr:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rbx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL25@RetInstr
$LN16@RetInstr:

; 3336 :     }
; 3337 :     AddLineQueue( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	AddLineQueue

; 3338 :     RunLineQueue();

	call	RunLineQueue

; 3339 : 
; 3340 :     DebugMsg1(( "RetInstr() exit\n" ));
; 3341 : 
; 3342 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@RetInstr:

; 3343 : }

	lea	r11, QWORD PTR [rsp+1056]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	r14
	ret	0
RetInstr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
proc$ = 48
src$ = 56
CopyPrototype PROC

; 1615 : {

$LN21:
	push	rdi
	sub	rsp, 32					; 00000020H

; 1616 :     struct dsym *curr;
; 1617 :     struct dsym *newl;
; 1618 :     struct dsym *oldl;
; 1619 : 
; 1620 :     if ( src->sym.isproc == FALSE )

	test	BYTE PTR [rdx+41], 8
	mov	rdi, rcx
	jne	SHORT $LN8@CopyProtot

; 1621 :         return( ERROR );

	or	eax, -1

; 1648 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN8@CopyProtot:

; 1622 :     memcpy(proc->e.procinfo, src->e.procinfo, sizeof( struct proc_info ) );

	mov	rax, QWORD PTR [rdx+96]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1623 :     proc->sym.mem_type = src->sym.mem_type;
; 1624 :     proc->sym.langtype = src->sym.langtype;
; 1625 : #if MANGLERSUPP
; 1626 :     proc->sym.mangler  = src->sym.mangler;
; 1627 : #endif
; 1628 :     proc->sym.ispublic   = src->sym.ispublic;
; 1629 :     /* we use the PROTO part, not the TYPE part */
; 1630 :     //dir->sym.seg_ofssize = src->sym.Ofssize;
; 1631 :     proc->sym.seg_ofssize = src->sym.seg_ofssize;
; 1632 :     proc->sym.isproc = TRUE;
; 1633 :     proc->e.procinfo->paralist = NULL;

	xor	esi, esi
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [rax+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [rax+48]
	movups	XMMWORD PTR [rcx+48], xmm1
	movups	xmm0, XMMWORD PTR [rax+64]
	movups	XMMWORD PTR [rcx+64], xmm0
	movsd	xmm1, QWORD PTR [rax+80]
	movsd	QWORD PTR [rcx+80], xmm1
	mov	eax, DWORD PTR [rdx+36]
	mov	DWORD PTR [rdi+36], eax
	mov	eax, DWORD PTR [rdx+76]
	mov	DWORD PTR [rdi+76], eax
	movzx	eax, BYTE PTR [rdx+40]
	xor	al, BYTE PTR [rdi+40]
	and	al, 127					; 0000007fH
	xor	al, BYTE PTR [rdx+40]
	mov	BYTE PTR [rdi+40], al
	movzx	eax, BYTE PTR [rdx+47]
	xor	al, BYTE PTR [rdi+47]
	or	BYTE PTR [rdi+41], 8
	and	al, 3
	xor	BYTE PTR [rdi+47], al
	mov	rax, QWORD PTR [rdi+96]
	mov	QWORD PTR [rax+8], rsi

; 1634 :     for ( curr = src->e.procinfo->paralist; curr; curr = curr->nextparam ) {

	mov	rax, QWORD PTR [rdx+96]
	mov	rbx, QWORD PTR [rax+8]
	test	rbx, rbx
	je	$LN3@CopyProtot
$LL4@CopyProtot:

; 1635 :         newl = LclAlloc( sizeof( struct dsym ) );

	mov	ecx, 120				; 00000078H
	call	LclAlloc

; 1636 :         memcpy( newl, curr, sizeof( struct dsym ) );

	movups	xmm0, XMMWORD PTR [rbx]
	mov	rdx, rax
	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR [rbx+16]
	movups	XMMWORD PTR [rax+16], xmm1
	movups	xmm0, XMMWORD PTR [rbx+32]
	movups	XMMWORD PTR [rax+32], xmm0
	movups	xmm1, XMMWORD PTR [rbx+48]
	movups	XMMWORD PTR [rax+48], xmm1
	movups	xmm0, XMMWORD PTR [rbx+64]
	movups	XMMWORD PTR [rax+64], xmm0
	movups	xmm1, XMMWORD PTR [rbx+80]
	movups	XMMWORD PTR [rax+80], xmm1
	movups	xmm0, XMMWORD PTR [rbx+96]
	movups	XMMWORD PTR [rax+96], xmm0

; 1637 :         newl->nextparam = NULL;

	mov	QWORD PTR [rax+112], rsi

; 1638 :         if ( proc->e.procinfo->paralist == NULL)

	mov	rax, QWORD PTR [rdi+96]
	mov	rcx, QWORD PTR [rax+8]
	test	rcx, rcx
	jne	SHORT $LN9@CopyProtot

; 1639 :             proc->e.procinfo->paralist = newl;

	mov	QWORD PTR [rax+8], rdx
	jmp	SHORT $LN2@CopyProtot
$LN9@CopyProtot:

; 1640 :         else {
; 1641 :             for ( oldl = proc->e.procinfo->paralist; oldl->nextparam; oldl = oldl->nextparam );

	mov	rax, QWORD PTR [rcx+112]
	test	rax, rax
	je	SHORT $LN6@CopyProtot
$LL7@CopyProtot:
	mov	rcx, rax
	mov	rax, QWORD PTR [rax+112]
	test	rax, rax
	jne	SHORT $LL7@CopyProtot
$LN6@CopyProtot:

; 1642 :             oldl->nextparam = newl;

	mov	QWORD PTR [rcx+112], rdx
$LN2@CopyProtot:

; 1634 :     for ( curr = src->e.procinfo->paralist; curr; curr = curr->nextparam ) {

	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL4@CopyProtot
$LN3@CopyProtot:
	mov	rsi, QWORD PTR [rsp+56]

; 1643 :         }
; 1644 :     }
; 1645 :     DebugMsg1(("CopyPrototype(%s,src=%s): ofssize=%u\n",
; 1646 :                proc->sym.name, src->sym.name, src->sym.seg_ofssize ));
; 1647 :     return( NOT_ERROR );

	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+48]

; 1648 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CopyPrototype ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
proc$ = 48
DeleteProc PROC

; 1380 : {

$LN15:
	sub	rsp, 40					; 00000028H

; 1381 :     struct dsym *curr;
; 1382 :     struct dsym *next;
; 1383 : 
; 1384 :     DebugMsg(("DeleteProc(%s) enter\n", proc->sym.name ));
; 1385 :     if ( proc->sym.state == SYM_INTERNAL ) {

	cmp	DWORD PTR [rcx+32], 1
	jne	SHORT $LN3@DeleteProc

; 1386 : 
; 1387 :         /* delete all local symbols ( params, locals, labels ) */
; 1388 :         for( curr = proc->e.procinfo->labellist; curr; ) {

	mov	rax, QWORD PTR [rcx+96]
	mov	rcx, QWORD PTR [rax+24]
	test	rcx, rcx
	je	SHORT $LN3@DeleteProc
	mov	QWORD PTR [rsp+32], rbx
	npad	4
$LL2@DeleteProc:

; 1389 :             next = curr->e.nextll;

	mov	rbx, QWORD PTR [rcx+96]

; 1390 :             DebugMsg(("DeleteProc(%s): free %s [next=%p]\n", proc->sym.name, curr->sym.name, curr->next ));
; 1391 :             SymFree( &curr->sym );

	call	SymFree

; 1392 :             curr = next;

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL2@DeleteProc
	mov	rbx, QWORD PTR [rsp+32]
$LN3@DeleteProc:

; 1393 :         }
; 1394 : 
; 1395 :         if ( proc->e.procinfo->regslist )
; 1396 :             LclFree( proc->e.procinfo->regslist );
; 1397 : 
; 1398 :         if ( proc->e.procinfo->prologuearg )
; 1399 :             LclFree( proc->e.procinfo->prologuearg );
; 1400 : 
; 1401 :         if ( Options.line_numbers && proc->sym.state == SYM_INTERNAL )
; 1402 :             LclFree( proc->sym.debuginfo );
; 1403 : #if FASTMEM==0 || defined(DEBUG_OUT)
; 1404 :     } else {
; 1405 :         /* PROTOs have just a parameter list, usually without names */
; 1406 :         for( curr = proc->e.procinfo->paralist; curr; ) {
; 1407 :             next = curr->nextparam;
; 1408 :             DebugMsg(("DeleteProc(%s): free %p (%s) [next=%p]\n", proc->sym.name, curr, curr->sym.name, curr->next ));
; 1409 :             SymFree( &curr->sym );
; 1410 :             curr = next;
; 1411 :         }
; 1412 : #endif
; 1413 :     }
; 1414 :     LclFree( proc->e.procinfo );
; 1415 :     return;
; 1416 : }

	add	rsp, 40					; 00000028H
	ret	0
DeleteProc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
sym$ = 48
name$ = 56
state$ = 64
CreateProc PROC

; 1328 : {

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1329 :     if ( sym == NULL )

	lea	rsi, OFFSET FLAT:SymTables+16
	mov	edi, r8d
	mov	rbx, rcx
	test	rcx, rcx
	jne	SHORT $LN4@CreateProc

; 1330 :         sym = ( *name ? SymCreate( name ) : SymAlloc( name ) );

	mov	rcx, rdx
	cmp	BYTE PTR [rdx], bl
	je	SHORT $LN14@CreateProc
	call	SymCreate
	mov	rbx, rax
	jmp	SHORT $LN5@CreateProc
$LN14@CreateProc:
	call	SymAlloc
	mov	rbx, rax
	jmp	SHORT $LN5@CreateProc
$LN4@CreateProc:

; 1331 :     else
; 1332 :         sym_remove_table( ( sym->state == SYM_UNDEFINED ) ? &SymTables[TAB_UNDEF] : &SymTables[TAB_EXT], (struct dsym *)sym );

	cmp	DWORD PTR [rbx+32], 0
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rbx
	cmovne	rcx, rsi
	call	sym_remove_table
$LN5@CreateProc:

; 1333 : 
; 1334 :     if ( sym ) {

	test	rbx, rbx
	je	$LN19@CreateProc

; 1335 :         struct proc_info *info;
; 1336 :         sym->state = state;

	mov	DWORD PTR [rbx+32], edi

; 1337 :         if ( state != SYM_INTERNAL ) {

	cmp	edi, 1
	je	SHORT $LN7@CreateProc

; 1338 :             sym->seg_ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR [rbx+47]
	xor	al, BYTE PTR ModuleInfo+404
	and	al, 3
	xor	BYTE PTR [rbx+47], al
$LN7@CreateProc:

; 1339 :         }
; 1340 :         info = LclAlloc( sizeof( struct proc_info ) );

	mov	ecx, 88					; 00000058H
	call	LclAlloc

; 1341 :         ((struct dsym *)sym)->e.procinfo = info;
; 1342 :         info->regslist = NULL;

	xor	edx, edx
	mov	QWORD PTR [rbx+96], rax
	mov	QWORD PTR [rax], rdx

; 1343 :         info->paralist = NULL;

	mov	QWORD PTR [rax+8], rdx

; 1344 :         info->locallist = NULL;

	mov	QWORD PTR [rax+16], rdx

; 1345 :         info->labellist = NULL;

	mov	QWORD PTR [rax+24], rdx

; 1346 :         info->parasize = 0;

	mov	QWORD PTR [rax+32], rdx

; 1347 :         info->localsize = 0;
; 1348 :         info->prologuearg = NULL;

	mov	QWORD PTR [rax+40], rdx

; 1349 :         info->flags = 0;

	mov	BYTE PTR [rax+84], dl

; 1350 :         switch ( sym->state ) {

	mov	edx, DWORD PTR [rbx+32]
	sub	edx, 1
	je	SHORT $LN8@CreateProc
	cmp	edx, 1
	jne	SHORT $LN19@CreateProc

; 1365 :             }
; 1366 :             break;
; 1367 :         case SYM_EXTERNAL:
; 1368 :             sym->weak = TRUE;

	or	BYTE PTR [rbx+47], 8

; 1369 :             sym_add_table( &SymTables[TAB_EXT], (struct dsym *)sym );

	mov	rdx, rbx
	mov	rcx, rsi
	call	sym_add_table

; 1370 :             break;
; 1371 :         }
; 1372 :     }
; 1373 :     return( sym );

	mov	rax, rbx

; 1374 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN8@CreateProc:

; 1351 :         case SYM_INTERNAL:
; 1352 :             /* v2.04: don't use sym_add_table() and thus
; 1353 :              * free the <next> member field!
; 1354 :              */
; 1355 :             if ( SymTables[TAB_PROC].head == NULL )

	cmp	QWORD PTR SymTables+64, 0
	jne	SHORT $LN9@CreateProc

; 1356 :                 SymTables[TAB_PROC].head = (struct dsym *)sym;

	mov	QWORD PTR SymTables+64, rbx
	jmp	SHORT $LN10@CreateProc
$LN9@CreateProc:

; 1357 :             else {
; 1358 :                 SymTables[TAB_PROC].tail->nextproc = (struct dsym *)sym;

	mov	rax, QWORD PTR SymTables+72
	mov	QWORD PTR [rax+112], rbx
$LN10@CreateProc:

; 1359 :             }
; 1360 :             SymTables[TAB_PROC].tail = (struct dsym *)sym;
; 1361 :             procidx++;

	inc	DWORD PTR procidx

; 1362 :             if ( Options.line_numbers ) {

	cmp	BYTE PTR Options+1, 0
	mov	QWORD PTR SymTables+72, rbx
	je	SHORT $LN19@CreateProc

; 1363 :                 sym->debuginfo = LclAlloc( sizeof( struct debug_info ) );

	mov	ecx, 24
	call	LclAlloc
	mov	QWORD PTR [rbx+64], rax

; 1364 :                 sym->debuginfo->file = get_curr_srcfile();

	call	get_curr_srcfile
	mov	rcx, QWORD PTR [rbx+64]
	mov	WORD PTR [rcx+14], ax
$LN19@CreateProc:

; 1374 : }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CreateProc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
tv1298 = 96
proc$ = 96
i$ = 104
tokenarray$ = 112
IsPROC$ = 120
langtype$ = 128
ParseProc PROC

; 999  : {

$LN128:
	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+16], edx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r15
	mov	rbp, rsp
	sub	rsp, 32					; 00000020H

; 1000 :     char            *token;
; 1001 :     uint_16         *regist;
; 1002 :     //int             type;
; 1003 :     //enum lang_type  langtype;
; 1004 :     enum memtype    newmemtype;
; 1005 :     uint_8          newofssize;
; 1006 :     uint_8          oldofssize;
; 1007 : #if FASTPASS
; 1008 :     bool            oldpublic = proc->sym.ispublic;

	movzx	r12d, BYTE PTR [rcx+40]

; 1009 : #endif
; 1010 : 
; 1011 :     /* set some default values */
; 1012 : 
; 1013 :     if ( IsPROC ) {

	lea	rdi, OFFSET FLAT:SpecialTable
	shr	r12b, 7
	xor	r13d, r13d
	movzx	r15d, r9b
	mov	rsi, r8
	mov	rbx, rcx
	test	r9b, r9b
	je	$LN16@ParseProc

; 1014 :         proc->e.procinfo->isexport = ModuleInfo.procs_export;

	mov	eax, DWORD PTR ModuleInfo+408
	mov	rdx, QWORD PTR [rcx+96]
	shr	eax, 3
	shl	al, 2
	xor	al, BYTE PTR [rdx+84]
	and	al, 4
	xor	BYTE PTR [rdx+84], al

; 1015 :         /* don't overwrite a PUBLIC directive for this symbol! */
; 1016 :         if ( ModuleInfo.procs_private == FALSE )

	test	BYTE PTR ModuleInfo+408, 4
	jne	SHORT $LN12@ParseProc

; 1017 :             proc->sym.ispublic = TRUE;

	or	BYTE PTR [rcx+40], 128			; 00000080H
$LN12@ParseProc:

; 1018 : 
; 1019 :         /* set type of epilog code */
; 1020 : #if STACKBASESUPP
; 1021 :         /* v2.11: if base register isn't [E|R]BP, don't use LEAVE! */
; 1022 :         if ( GetRegNo( proc->e.procinfo->basereg ) != 5 ) {

	mov	rdx, QWORD PTR [rcx+96]
	movzx	eax, WORD PTR [rdx+86]
	lea	rcx, QWORD PTR [rax+rax*2]
	cmp	BYTE PTR [rdi+rcx*4+10], 5
	je	SHORT $LN13@ParseProc

; 1023 :             proc->e.procinfo->pe_type = 0;

	and	BYTE PTR [rdx+84], 253			; 000000fdH

; 1024 :         } else

	jmp	SHORT $LN16@ParseProc
$LN13@ParseProc:

; 1025 : #endif
; 1026 :         if ( Options.masm_compat_gencode ) {

	cmp	BYTE PTR Options+128, r13b
	je	SHORT $LN15@ParseProc

; 1027 :             /* v2.07: Masm uses LEAVE if
; 1028 :              * - current code is 32-bit/64-bit or
; 1029 :              * - cpu is .286 or .586+ */
; 1030 :             //proc->e.procinfo->pe_type = ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_286 );
; 1031 :             proc->e.procinfo->pe_type = ( ModuleInfo.Ofssize > USE16 ||

	cmp	BYTE PTR ModuleInfo+404, r13b
	ja	SHORT $LN85@ParseProc
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 32					; 00000020H
	je	SHORT $LN85@ParseProc
	cmp	eax, 80					; 00000050H
	mov	eax, r13d
	jl	SHORT $LN88@ParseProc
$LN85@ParseProc:
	mov	eax, 1

; 1032 :                                          ( ModuleInfo.curr_cpu & P_CPU_MASK ) == P_286 ||
; 1033 :                                          ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_586 ) ? 1 : 0;
; 1034 :         } else {

	jmp	SHORT $LN88@ParseProc
$LN15@ParseProc:

; 1035 :             /* use LEAVE for 286, 386 (and x64) */
; 1036 :             proc->e.procinfo->pe_type = ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) == P_286 ||

	mov	ecx, DWORD PTR ModuleInfo+392
	and	ecx, 240				; 000000f0H
	lea	eax, DWORD PTR [rcx-32]
	test	eax, -81				; ffffffafH
	jne	SHORT $LN108@ParseProc
	mov	eax, 1
	cmp	ecx, 96					; 00000060H
	jne	SHORT $LN88@ParseProc
$LN108@ParseProc:
	mov	eax, r13d
$LN88@ParseProc:
	and	BYTE PTR [rdx+84], 253			; 000000fdH
	and	al, 1
	add	al, al
	or	BYTE PTR [rdx+84], al
$LN16@ParseProc:

; 1037 : #if AMD64_SUPPORT
; 1038 :                                          ( ModuleInfo.curr_cpu & P_CPU_MASK ) == P_64 ||
; 1039 : #endif
; 1040 :                                          ( ModuleInfo.curr_cpu & P_CPU_MASK ) == P_386 ) ? 1 : 0;
; 1041 :         }
; 1042 :     }
; 1043 : 
; 1044 : #if MANGLERSUPP
; 1045 :     /* OW name mangling */
; 1046 :     if( tokenarray[i].token == T_STRING && IsPROC ) {
; 1047 :         /* SetMangler() will ignore LANG_NONE */
; 1048 :         SetMangler( &proc->sym, LANG_NONE, tokenarray[i].string_ptr );
; 1049 :         i++;
; 1050 :     }
; 1051 : #endif
; 1052 : 
; 1053 :     /* 1. attribute is <distance> */
; 1054 :     if ( tokenarray[i].token == T_STYPE &&
; 1055 :         tokenarray[i].tokval >= T_NEAR && tokenarray[i].tokval <= T_FAR32 ) {

	movsxd	rax, DWORD PTR i$[rbp-32]
	shl	rax, 5
	mov	QWORD PTR [rsp+112], r14
	cmp	BYTE PTR [rax+r8], 6
	jne	SHORT $LN17@ParseProc
	mov	ecx, DWORD PTR [rax+r8+16]
	lea	eax, DWORD PTR [rcx-221]
	cmp	eax, 5
	ja	SHORT $LN17@ParseProc

; 1056 :         uint_8 Ofssize = GetSflagsSp( tokenarray[i].tokval );

	lea	rcx, QWORD PTR [rcx+rcx*2]

; 1057 :         /* v2.06: SimpleType is obsolete */
; 1058 :         /* v2.05: FindStdType() is obsolete */
; 1059 :         //type = tokenarray[i].bytval;
; 1060 :         //type = FindStdType(tokenarray[i].value);
; 1061 :         if ( IsPROC ) {
; 1062 :             if ( ( ModuleInfo.Ofssize >= USE32 && Ofssize == USE16 ) ||

	movzx	edx, BYTE PTR ModuleInfo+404
	movzx	r15d, BYTE PTR [rdi+rcx*4+4]
	cmp	BYTE PTR IsPROC$[rbp-32], r13b
	je	SHORT $LN20@ParseProc
	cmp	dl, 1
	jb	SHORT $LN22@ParseProc
	test	r15b, r15b
	je	SHORT $LN21@ParseProc
$LN22@ParseProc:
	test	dl, dl
	jne	SHORT $LN20@ParseProc
	cmp	r15b, 1
	jne	SHORT $LN20@ParseProc
$LN21@ParseProc:

; 1063 :                 ( ModuleInfo.Ofssize == USE16 && Ofssize == USE32 ) ) {
; 1064 :                 EmitError( DISTANCE_INVALID );

	mov	ecx, 171				; 000000abH
	call	EmitError
	movzx	edx, BYTE PTR ModuleInfo+404
$LN20@ParseProc:

; 1065 :             }
; 1066 :         }
; 1067 :         newmemtype = GetMemtypeSp( tokenarray[i].tokval );

	movsxd	rax, DWORD PTR i$[rbp-32]
	shl	rax, 5

; 1068 :         newofssize = (( Ofssize != USE_EMPTY ) ? Ofssize : ModuleInfo.Ofssize );

	cmp	r15b, 254				; 000000feH
	movzx	r14d, dl
	mov	eax, DWORD PTR [rax+rsi+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, r15b
	movzx	edi, BYTE PTR [rdi+rcx*4+10]
	cmovne	r14d, eax

; 1069 :         i++;

	inc	DWORD PTR i$[rbp-32]

; 1070 :     } else {

	movzx	r15d, BYTE PTR IsPROC$[rbp-32]
	jmp	SHORT $LN18@ParseProc
$LN17@ParseProc:

; 1071 :         newmemtype = ( ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) ? MT_FAR : MT_NEAR );

	mov	ecx, DWORD PTR ModuleInfo+360
	mov	edi, r13d

; 1072 :         newofssize = ModuleInfo.Ofssize;

	movzx	r14d, BYTE PTR ModuleInfo+404
	mov	eax, 1
	shl	eax, cl
	test	al, 112					; 00000070H
	setne	dil
	add	edi, 129				; 00000081H
$LN18@ParseProc:

; 1073 :     }
; 1074 : 
; 1075 :     /* v2.11: GetSymOfssize() cannot handle SYM_TYPE correctly */
; 1076 :     if ( proc->sym.state == SYM_TYPE )

	cmp	DWORD PTR [rbx+32], 7
	jne	SHORT $LN23@ParseProc

; 1077 :         oldofssize = proc->sym.seg_ofssize;

	movzx	eax, BYTE PTR [rbx+47]
	and	al, 3
	jmp	SHORT $LN24@ParseProc
$LN23@ParseProc:

; 1078 :     else
; 1079 :         oldofssize = GetSymOfssize( &proc->sym );

	mov	rcx, rbx
	call	GetSymOfssize
$LN24@ParseProc:

; 1080 : 
; 1081 :     /* did the distance attribute change? */
; 1082 :     if ( proc->sym.mem_type != MT_EMPTY &&

	mov	ecx, DWORD PTR [rbx+36]
	cmp	ecx, 192				; 000000c0H
	je	SHORT $LN25@ParseProc
	cmp	ecx, edi
	jne	SHORT $LN27@ParseProc
	cmp	al, r14b
	je	SHORT $LN25@ParseProc
$LN27@ParseProc:
	lea	eax, DWORD PTR [rcx-129]
	cmp	eax, 1
	jbe	SHORT $LN30@ParseProc

; 1088 :         else {
; 1089 :             return( EmitErr( SYMBOL_REDEFINITION, proc->sym.name ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 143				; 0000008fH
	jmp	$LN124@ParseProc
$LN30@ParseProc:

; 1083 :         ( proc->sym.mem_type != newmemtype ||
; 1084 :          oldofssize != newofssize ) ) {
; 1085 :         DebugMsg(("ParseProc: error, memtype changed, old-new memtype=%X-%X, ofssize=%X-%X\n", proc->sym.mem_type, newmemtype, proc->sym.Ofssize, newofssize));
; 1086 :         if ( proc->sym.mem_type == MT_NEAR || proc->sym.mem_type == MT_FAR )
; 1087 :             EmitError( PROC_AND_PROTO_CALLING_CONV_CONFLICT );

	mov	ecx, 138				; 0000008aH
	call	EmitError

; 1090 :         }
; 1091 :     } else {

	jmp	SHORT $LN31@ParseProc
$LN25@ParseProc:

; 1092 :         proc->sym.mem_type = newmemtype;

	mov	DWORD PTR [rbx+36], edi

; 1093 :         if ( IsPROC == FALSE )

	test	r15b, r15b
	jne	SHORT $LN31@ParseProc

; 1094 :             proc->sym.seg_ofssize = newofssize;

	and	BYTE PTR [rbx+47], 252			; 000000fcH
	and	r14b, 3
	or	BYTE PTR [rbx+47], r14b
$LN31@ParseProc:

; 1095 :     }
; 1096 : 
; 1097 :     /* 2. attribute is <langtype> */
; 1098 :     /* v2.09: the default language value is now a function argument. This is because
; 1099 :      * EXTERN[DEF] allows to set the language attribute by:
; 1100 :      * EXTERN[DEF] <langtype> <name> PROTO ...
; 1101 :      * ( see CreateProto() in extern.c )
; 1102 :      */
; 1103 :     //langtype = ModuleInfo.langtype; /* set the default value */
; 1104 :     GetLangType( &i, tokenarray, &langtype ); /* optionally overwrite the value */

	lea	r8, QWORD PTR langtype$[rbp-32]
	mov	rdx, rsi
	lea	rcx, QWORD PTR i$[rbp-32]
	call	GetLangType

; 1105 :     
; 1106 : 	/* John Hankinson: 2016-02-10 Allows Linux64 to utlise Win64 ABI */
; 1107 : 	#if AMD64_SUPPORT
; 1108 : 	if (Options.output_format == OFORMAT_ELF)

	cmp	DWORD PTR Options+144, 3
	mov	edi, 7
	mov	eax, DWORD PTR langtype$[rbp-32]

; 1109 : 		langtype = LANG_FASTCALL;
; 1110 : 	#endif
; 1111 : 
; 1112 : 	/* has language changed? */
; 1113 :     if ( proc->sym.langtype != LANG_NONE && proc->sym.langtype != langtype ) {

	mov	edx, DWORD PTR [rbx+76]
	cmove	eax, edi
	mov	DWORD PTR langtype$[rbp-32], eax
	test	edx, edx
	je	SHORT $LN33@ParseProc
	cmp	edx, eax
	je	SHORT $LN33@ParseProc

; 1114 :         DebugMsg(("ParseProc: error, language changed, %u - %u\n", proc->sym.langtype, langtype ));
; 1115 :         EmitError( PROC_AND_PROTO_CALLING_CONV_CONFLICT );

	mov	ecx, 138				; 0000008aH
	call	EmitError

; 1116 :     } else

	jmp	SHORT $LN34@ParseProc
$LN33@ParseProc:

; 1117 :         proc->sym.langtype = langtype;

	mov	DWORD PTR [rbx+76], eax
$LN34@ParseProc:

; 1118 : 
; 1119 : 	/* John Hankinson: 2016-02-10 Allows Linux64 to utlise Win64 ABI */
; 1120 : 	#if AMD64_SUPPORT
; 1121 : 	if (proc->sym.langtype == LANG_NONE && Options.output_format == OFORMAT_ELF)

	cmp	DWORD PTR [rbx+76], r13d
	jne	SHORT $LN116@ParseProc
	cmp	DWORD PTR Options+144, 3
	jne	SHORT $LN116@ParseProc

; 1122 : 	{
; 1123 : 		proc->sym.langtype = LANG_FASTCALL;

	mov	DWORD PTR [rbx+76], edi
$LN116@ParseProc:

; 1124 : 	}
; 1125 : 	#endif
; 1126 : 
; 1127 :     /* 3. attribute is <visibility> */
; 1128 :     /* note that reserved word PUBLIC is a directive! */
; 1129 :     /* PROTO does NOT accept PUBLIC! However,
; 1130 :      * PROTO accepts PRIVATE and EXPORT, but these attributes are just ignored!
; 1131 :      */
; 1132 : 
; 1133 :     if ( tokenarray[i].token == T_ID || tokenarray[i].token == T_DIRECTIVE ) {

	movsxd	rdx, DWORD PTR i$[rbp-32]
	mov	rax, rdx
	shl	rax, 5
	lea	rdi, QWORD PTR [rax+rsi]
	movzx	eax, BYTE PTR [rax+rsi]
	cmp	al, 8
	je	SHORT $LN37@ParseProc
	cmp	al, 3
	jne	$LN44@ParseProc
$LN37@ParseProc:

; 1134 :         token = tokenarray[i].string_ptr;

	mov	rdi, QWORD PTR [rdi+8]

; 1135 :         if ( _stricmp( token, "PRIVATE") == 0 ) {

	lea	rdx, OFFSET FLAT:$SG11728
	mov	rcx, rdi
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN38@ParseProc

; 1136 :             if ( IsPROC ) { /* v2.11: ignore PRIVATE for PROTO */

	test	r15b, r15b
	je	SHORT $LN40@ParseProc

; 1137 :                 proc->sym.ispublic = FALSE;

	and	BYTE PTR [rbx+40], 123			; 0000007bH

; 1138 : #if FASTPASS
; 1139 :                 /* error if there was a PUBLIC directive! */
; 1140 :                 proc->sym.scoped = TRUE;

	or	BYTE PTR [rbx+40], 4

; 1141 :                 if ( oldpublic ) {

	test	r12b, r12b
	je	SHORT $LN41@ParseProc

; 1142 :                     SkipSavedState(); /* do a full pass-2 scan */

	call	SkipSavedState

; 1143 :                 }
; 1144 : #endif
; 1145 :                 proc->e.procinfo->isexport = FALSE;
; 1146 :             }
; 1147 :             i++;

	jmp	SHORT $LN41@ParseProc
$LN38@ParseProc:

; 1148 :         } else if ( IsPROC && (_stricmp(token, "PUBLIC") == 0 ) ) {

	test	r15b, r15b
	je	SHORT $LN42@ParseProc
	lea	rdx, OFFSET FLAT:$SG11733
	mov	rcx, rdi
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN42@ParseProc

; 1149 :             proc->sym.ispublic = TRUE;

	or	BYTE PTR [rbx+40], 128			; 00000080H
$LN41@ParseProc:

; 1150 :             proc->e.procinfo->isexport = FALSE;

	mov	rax, QWORD PTR [rbx+96]
	and	BYTE PTR [rax+84], 251			; 000000fbH
$LN40@ParseProc:

; 1151 :             i++;

	mov	edx, DWORD PTR i$[rbp-32]
	inc	edx
	mov	DWORD PTR i$[rbp-32], edx
	jmp	SHORT $LN44@ParseProc
$LN42@ParseProc:

; 1152 :         } else if ( _stricmp(token, "EXPORT") == 0 ) {

	lea	rdx, OFFSET FLAT:$SG11735
	mov	rcx, rdi
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN118@ParseProc

; 1153 :             DebugMsg1(("ParseProc(%s): EXPORT detected\n", proc->sym.name ));
; 1154 :             if ( IsPROC ) { /* v2.11: ignore EXPORT for PROTO */

	test	r15b, r15b
	je	SHORT $LN40@ParseProc

; 1155 :                 proc->sym.ispublic = TRUE;

	or	BYTE PTR [rbx+40], 128			; 00000080H

; 1156 :                 proc->e.procinfo->isexport = TRUE;

	mov	rax, QWORD PTR [rbx+96]
	or	BYTE PTR [rax+84], 4

; 1157 :                 /* v2.11: no export for 16-bit near */
; 1158 :                 if ( ModuleInfo.Ofssize == USE16 && proc->sym.mem_type == MT_NEAR )

	cmp	BYTE PTR ModuleInfo+404, r13b
	jne	SHORT $LN40@ParseProc
	cmp	DWORD PTR [rbx+36], 129			; 00000081H
	jne	SHORT $LN40@ParseProc

; 1159 :                     EmitErr( EXPORT_MUST_BE_FAR, proc->sym.name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 277				; 00000115H
	call	EmitErr
	mov	edx, DWORD PTR i$[rbp-32]
	inc	edx
	mov	DWORD PTR i$[rbp-32], edx
	jmp	SHORT $LN44@ParseProc
$LN118@ParseProc:

; 1160 :             }
; 1161 :             i++;

	mov	edx, DWORD PTR i$[rbp-32]
$LN44@ParseProc:

; 1162 :         }
; 1163 :     }
; 1164 : 
; 1165 :     /* 4. attribute is <prologuearg>, for PROC only.
; 1166 :      * it must be enclosed in <>
; 1167 :      */
; 1168 :     if ( IsPROC && tokenarray[i].token == T_STRING && tokenarray[i].string_delim == '<' ) {

	test	r15b, r15b
	je	$LN121@ParseProc
	movsxd	rcx, edx
	shl	rcx, 5
	add	rcx, rsi
	cmp	BYTE PTR [rcx], 9
	jne	$LN121@ParseProc
	cmp	BYTE PTR [rcx+1], 60			; 0000003cH
	jne	$LN121@ParseProc

; 1169 :         int idx = Token_Count + 1;

	mov	eax, DWORD PTR ModuleInfo+496
	lea	r12d, DWORD PTR [rax+1]

; 1170 :         int max;
; 1171 :         if ( ModuleInfo.prologuemode == PEM_NONE )

	movzx	eax, BYTE PTR ModuleInfo+424
	cmp	al, 2
	je	$LN3@ParseProc

; 1172 :             ; /* no prologue at all */
; 1173 :         else if ( ModuleInfo.prologuemode == PEM_MACRO ) {

	cmp	al, 1
	jne	SHORT $LN50@ParseProc

; 1174 :             proc->e.procinfo->prologuearg = LclAlloc( tokenarray[i].stringlen + 1 );

	mov	ecx, DWORD PTR [rcx+16]
	inc	ecx
	call	LclAlloc
	mov	rcx, QWORD PTR [rbx+96]
	mov	QWORD PTR [rcx+40], rax

; 1175 :             strcpy( proc->e.procinfo->prologuearg, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rbp-32]
	shl	rax, 5
	mov	rcx, QWORD PTR [rax+rsi+8]
	mov	rax, QWORD PTR [rbx+96]
	mov	rdx, QWORD PTR [rax+40]
	npad	4
$LL91@ParseProc:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL91@ParseProc

; 1176 :         } else {

	jmp	$LN125@ParseProc
$LN50@ParseProc:

; 1177 :             /* check the argument. The default prologue
; 1178 :              understands FORCEFRAME and LOADDS only
; 1179 :              */
; 1180 :             max = Tokenize( tokenarray[i].string_ptr, idx, tokenarray, TOK_RESCAN );

	mov	rcx, QWORD PTR [rcx+8]
	mov	r9d, 1
	mov	r8, rsi
	movsxd	r15, r12d
	mov	edx, r12d
	call	Tokenize

; 1181 :             for ( ; idx < max; idx++ ) {

	cdqe
	mov	QWORD PTR tv1298[rbp-32], rax
	cmp	r15, rax
	jge	$LN120@ParseProc

; 1169 :         int idx = Token_Count + 1;

	mov	rdi, r15
	lea	r14, QWORD PTR [r15+2]
	shl	rdi, 5
	add	rdi, rsi
	shl	r14, 5
	add	r14, rsi
$LL4@ParseProc:

; 1182 :                 if ( tokenarray[idx].token == T_ID ) {

	cmp	BYTE PTR [rdi], 8
	jne	$LN52@ParseProc

; 1183 :                     if ( _stricmp( tokenarray[idx].string_ptr, "FORCEFRAME") == 0 ) {

	mov	rcx, QWORD PTR [rdi+8]
	lea	rdx, OFFSET FLAT:$SG11747
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN54@ParseProc

; 1184 :                         proc->e.procinfo->forceframe = TRUE;

	mov	rax, QWORD PTR [rbx+96]
	or	BYTE PTR [rax+84], 8
	jmp	SHORT $LN59@ParseProc
$LN54@ParseProc:

; 1185 : #if AMD64_SUPPORT
; 1186 :                     } else if ( ModuleInfo.Ofssize != USE64 && (_stricmp( tokenarray[idx].string_ptr, "LOADDS") == 0 ) ) {

	cmp	BYTE PTR ModuleInfo+404, 2
	je	$LN56@ParseProc
	mov	rcx, QWORD PTR [rdi+8]
	lea	rdx, OFFSET FLAT:$SG11750
	call	_stricmp
	test	eax, eax
	jne	$LN56@ParseProc

; 1187 : #else
; 1188 :                     } else if ( _stricmp( tokenarray[idx].string_ptr, "LOADDS") == 0 ) {
; 1189 : #endif
; 1190 :                         if ( ModuleInfo.model == MODEL_FLAT ) {

	cmp	DWORD PTR ModuleInfo+360, 7
	jne	SHORT $LN58@ParseProc

; 1191 :                             EmitWarn( 2, LOADDS_IGNORED_IN_FLAT_MODEL );

	mov	edx, 226				; 000000e2H
	lea	ecx, QWORD PTR [rax+2]
	call	EmitWarn

; 1192 :                         } else

	jmp	SHORT $LN59@ParseProc
$LN58@ParseProc:

; 1193 :                             proc->e.procinfo->loadds = TRUE;

	mov	rax, QWORD PTR [rbx+96]
	or	BYTE PTR [rax+84], 16
$LN59@ParseProc:

; 1196 :                     }
; 1197 :                     if ( tokenarray[idx+1].token == T_COMMA && tokenarray[idx+2].token != T_FINAL)

	cmp	BYTE PTR [rdi+32], 44			; 0000002cH
	jne	SHORT $LN2@ParseProc
	cmp	BYTE PTR [r14], r13b
	je	SHORT $LN2@ParseProc

; 1198 :                         idx++;

	inc	r12d
	inc	r15
	add	rdi, 32					; 00000020H
	add	r14, 32					; 00000020H
$LN2@ParseProc:

; 1181 :             for ( ; idx < max; idx++ ) {

	inc	r12d
	inc	r15
	add	rdi, 32					; 00000020H
	add	r14, 32					; 00000020H
	cmp	r15, QWORD PTR tv1298[rbp-32]
	jl	$LL4@ParseProc
$LN120@ParseProc:
	movzx	r15d, BYTE PTR IsPROC$[rbp-32]
$LN125@ParseProc:

; 1199 :                 } else {
; 1200 :                     return( EmitErr( SYNTAX_ERROR_EX, tokenarray[idx].string_ptr ) );

	mov	edx, DWORD PTR i$[rbp-32]
$LN3@ParseProc:

; 1201 :                 }
; 1202 :             }
; 1203 :         }
; 1204 :         i++;

	inc	edx
	mov	DWORD PTR i$[rbp-32], edx
$LN121@ParseProc:

; 1205 :     }
; 1206 : 
; 1207 : #if AMD64_SUPPORT
; 1208 :     /* check for optional FRAME[:exc_proc] */
; 1209 :     if ( ModuleInfo.Ofssize == USE64 &&
; 1210 :         IsPROC &&
; 1211 :         tokenarray[i].token == T_RES_ID &&

	cmp	BYTE PTR ModuleInfo+404, 2
	jne	$LN61@ParseProc
	test	r15b, r15b
	je	$LN61@ParseProc
	movsxd	rax, edx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 7
	jne	$LN61@ParseProc
	cmp	DWORD PTR [rax+rsi+16], 263		; 00000107H
	jne	$LN61@ParseProc
	mov	eax, DWORD PTR Options+144
	add	eax, -2					; fffffffeH
	cmp	eax, 1
	jbe	SHORT $LN62@ParseProc

; 1212 :         tokenarray[i].tokval == T_FRAME ) {
; 1213 : 		/* v2.05: don't accept FRAME for ELF  - 2016-02-10 John Hankinson allowed ELF64 to use FRAME/Win64 ABI */
; 1214 : 		if (Options.output_format != OFORMAT_COFF && Options.output_format != OFORMAT_ELF
; 1215 : #if PE_SUPPORT
; 1216 :             && ModuleInfo.sub_format != SFORMAT_PE

	cmp	DWORD PTR ModuleInfo+372, 2
	je	SHORT $LN62@ParseProc

; 1217 : #endif
; 1218 :            ) {
; 1219 :             return( EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, GetResWName( T_FRAME, NULL ) ) );

	xor	edx, edx
	mov	ecx, 263				; 00000107H
	call	GetResWName
	mov	rdx, rax
	mov	ecx, 224				; 000000e0H
	jmp	$LN124@ParseProc
$LN56@ParseProc:

; 1194 :                     } else {
; 1195 :                         return( EmitErr( UNKNOWN_DEFAULT_PROLOGUE_ARGUMENT, tokenarray[idx].string_ptr ) );

	movsxd	rdx, r12d
	mov	ecx, 225				; 000000e1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+8]
	jmp	$LN124@ParseProc
$LN52@ParseProc:

; 1199 :                 } else {
; 1200 :                     return( EmitErr( SYNTAX_ERROR_EX, tokenarray[idx].string_ptr ) );

	movsxd	rdx, r12d
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+8]
	jmp	$LN126@ParseProc
$LN62@ParseProc:

; 1220 :         }
; 1221 :         i++;

	inc	edx

; 1222 :         if( tokenarray[i].token == T_COLON ) {

	movsxd	rax, edx
	shl	rax, 5
	mov	DWORD PTR i$[rbp-32], edx
	cmp	BYTE PTR [rax+rsi], 58			; 0000003aH
	jne	SHORT $LN63@ParseProc

; 1223 :             struct asym *sym;
; 1224 :             i++;

	inc	edx

; 1225 :             if ( tokenarray[i].token != T_ID ) {

	movsxd	rcx, edx
	shl	rcx, 5
	mov	DWORD PTR i$[rbp-32], edx
	cmp	BYTE PTR [rcx+rsi], 8
	je	SHORT $LN65@ParseProc

; 1226 :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rcx+rsi+8]
	jmp	$LN126@ParseProc
$LN65@ParseProc:

; 1227 :             }
; 1228 :             sym = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rcx+rsi+8]
	call	SymFind
	mov	rdi, rax

; 1229 :             if ( sym == NULL ) {

	test	rax, rax
	jne	SHORT $LN66@ParseProc

; 1230 :                 sym = SymCreate( tokenarray[i].string_ptr );

	movsxd	rcx, DWORD PTR i$[rbp-32]
	shl	rcx, 5
	mov	rcx, QWORD PTR [rcx+rsi+8]
	call	SymCreate

; 1231 :                 sym->state = SYM_UNDEFINED;
; 1232 :                 sym->used = TRUE;
; 1233 :                 sym_add_table( &SymTables[TAB_UNDEF], (struct dsym *)sym ); /* add UNDEFINED */

	mov	rdx, rax
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdi, rax
	or	BYTE PTR [rax+40], 1
	mov	DWORD PTR [rax+32], r13d
	call	sym_add_table
$LN68@ParseProc:

; 1238 :             }
; 1239 :             proc->e.procinfo->exc_handler = sym;

	mov	rax, QWORD PTR [rbx+96]
	mov	QWORD PTR [rax+48], rdi

; 1240 :             i++;

	inc	DWORD PTR i$[rbp-32]

; 1241 :         } else

	jmp	SHORT $LN64@ParseProc
$LN66@ParseProc:
	cmp	DWORD PTR [rax+32], 2
	jbe	SHORT $LN68@ParseProc

; 1234 :             } else if ( sym->state != SYM_UNDEFINED &&
; 1235 :                        sym->state != SYM_INTERNAL &&
; 1236 :                        sym->state != SYM_EXTERNAL ) {
; 1237 :                 return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	jmp	$LN124@ParseProc
$LN63@ParseProc:

; 1242 :             proc->e.procinfo->exc_handler = NULL;

	mov	rax, QWORD PTR [rbx+96]
	mov	QWORD PTR [rax+48], r13
$LN64@ParseProc:

; 1243 :         proc->e.procinfo->isframe = TRUE;

	mov	rax, QWORD PTR [rbx+96]
	or	BYTE PTR [rax+84], 64			; 00000040H
	mov	edx, DWORD PTR i$[rbp-32]
$LN61@ParseProc:

; 1244 :     }
; 1245 : #endif
; 1246 :     /* check for USES */
; 1247 :     if ( tokenarray[i].token == T_ID && _stricmp( tokenarray[i].string_ptr, "USES" ) == 0 ) {

	movsxd	rax, edx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 8
	jne	$LN9@ParseProc
	mov	rcx, QWORD PTR [rax+rsi+8]
	lea	rdx, OFFSET FLAT:$SG11763
	call	_stricmp
	test	eax, eax
	jne	$LN123@ParseProc

; 1248 :         int cnt;
; 1249 :         int j;
; 1250 :         if ( !IsPROC ) {/* not for PROTO! */

	test	r15b, r15b
	jne	SHORT $LN70@ParseProc

; 1251 :             DebugMsg(("ParseProc: USES found in PROTO\n"));
; 1252 :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	movsxd	rdx, DWORD PTR i$[rbp-32]
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+8]
	call	EmitErr
$LN70@ParseProc:

; 1253 :         }
; 1254 :         i++;

	mov	eax, DWORD PTR i$[rbp-32]
	inc	eax

; 1255 :         /* count register names which follow */
; 1256 :         for ( cnt = 0, j = i; tokenarray[j].token == T_REG; j++, cnt++ );

	movsxd	rcx, eax
	mov	rdx, rcx
	mov	DWORD PTR i$[rbp-32], eax
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rsi], 2
	jne	$LN107@ParseProc
	shl	rcx, 5
	add	rcx, rsi
$LL7@ParseProc:
	lea	rcx, QWORD PTR [rcx+32]
	inc	r13d
	cmp	BYTE PTR [rcx], 2
	je	SHORT $LL7@ParseProc

; 1257 : 
; 1258 :         if ( cnt == 0 ) {

	test	r13d, r13d
	je	SHORT $LN107@ParseProc

; 1261 :         } else {
; 1262 :             regist = LclAlloc( (cnt + 1) * sizeof( uint_16 ) );

	lea	eax, DWORD PTR [r13+1]
	movsxd	rcx, eax
	add	rcx, rcx
	call	LclAlloc

; 1263 :             proc->e.procinfo->regslist = regist;

	mov	rcx, QWORD PTR [rbx+96]

; 1264 :             *regist++ = cnt;

	lea	rdi, QWORD PTR [rax+2]
	mov	QWORD PTR [rcx], rax
	mov	WORD PTR [rax], r13w

; 1265 :             /* read in registers */
; 1266 :             for( ; tokenarray[i].token == T_REG; i++ ) {

	movsxd	rdx, DWORD PTR i$[rbp-32]
	mov	rcx, rdx
	shl	rcx, 5
	cmp	BYTE PTR [rcx+rsi], 2
	lea	rax, QWORD PTR [rcx+rsi]
	jne	SHORT $LN9@ParseProc
$LL10@ParseProc:

; 1267 :                 if ( SizeFromRegister( tokenarray[i].tokval ) == 1 ) {

	mov	ecx, DWORD PTR [rax+16]
	call	SizeFromRegister
	cmp	eax, 1
	jne	SHORT $LN73@ParseProc

; 1268 :                     EmitError( INVALID_USE_OF_REGISTER );

	mov	ecx, 170				; 000000aaH
	call	EmitError
$LN73@ParseProc:

; 1269 :                 }
; 1270 :                 *regist++ = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rbp-32]
	shl	rax, 5
	movzx	eax, WORD PTR [rax+rsi+16]
	mov	WORD PTR [rdi], ax
	add	rdi, 2
	mov	edx, DWORD PTR i$[rbp-32]
	inc	edx
	movsxd	rax, edx
	shl	rax, 5
	add	rax, rsi
	mov	DWORD PTR i$[rbp-32], edx
	cmp	BYTE PTR [rax], 2
	je	SHORT $LL10@ParseProc

; 1265 :             /* read in registers */
; 1266 :             for( ; tokenarray[i].token == T_REG; i++ ) {

	jmp	SHORT $LN9@ParseProc
$LN107@ParseProc:

; 1259 :             DebugMsg(("ParseProc: no registers for regslist\n"));
; 1260 :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i-1].tokpos );

	mov	rdx, QWORD PTR [rdx+rsi-8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN123@ParseProc:
	mov	edx, DWORD PTR i$[rbp-32]
$LN9@ParseProc:

; 1271 :             }
; 1272 :         }
; 1273 :     }
; 1274 : 
; 1275 :     /* the parameters must follow */
; 1276 :     if ( tokenarray[i].token == T_STYPE || tokenarray[i].token == T_RES_ID || tokenarray[i].token == T_DIRECTIVE ) {

	movsxd	r8, edx
	shl	r8, 5
	movzx	ecx, BYTE PTR [r8+rsi]
	lea	eax, DWORD PTR [rcx-6]
	cmp	al, 1
	jbe	$LN75@ParseProc
	cmp	cl, 3
	je	$LN75@ParseProc

; 1278 :     }
; 1279 : 
; 1280 :     /* skip optional comma */
; 1281 :     if ( tokenarray[i].token == T_COMMA )

	cmp	cl, 44					; 0000002cH
	jne	SHORT $LN76@ParseProc

; 1282 :         i++;

	inc	edx
	mov	DWORD PTR i$[rbp-32], edx
$LN76@ParseProc:

; 1283 : 
; 1284 :     DebugMsg1(("ParseProc(%s): i=%u, Token_Count=%u, CurrWordSize=%u\n", proc->sym.name, i, Token_Count, CurrWordSize ));
; 1285 : 
; 1286 :     if( i >= Token_Count ) {

	cmp	edx, DWORD PTR ModuleInfo+496
	jl	SHORT $LN77@ParseProc

; 1287 :         /* procedure has no parameters at all */
; 1288 :         if ( proc->e.procinfo->paralist != NULL )

	mov	rax, QWORD PTR [rbx+96]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN83@ParseProc

; 1289 :             EmitErr( CONFLICTING_PARAMETER_DEFINITION, "" );

	lea	rdx, OFFSET FLAT:$SG11774
	mov	ecx, 137				; 00000089H
	call	EmitErr

; 1301 :             /* do proceed if the parameter scan returns an error */
; 1302 :             ;//return( ERROR );
; 1303 :     }
; 1304 : 
; 1305 :     /* v2.11: isdefined and isproc now set here */
; 1306 :     proc->sym.isdefined = TRUE;

	or	BYTE PTR [rbx+40], 2

; 1307 :     proc->sym.isproc = TRUE;

	or	BYTE PTR [rbx+41], 8

; 1308 :     //proc->e.procinfo->init_done = TRUE;
; 1309 :     DebugMsg1(("ParseProc(%s): memtype=%Xh parasize=%u\n", proc->sym.name, proc->sym.mem_type, proc->e.procinfo->parasize));
; 1310 : 
; 1311 :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@ParseProc
$LN77@ParseProc:

; 1290 :     } else if( proc->sym.langtype == LANG_NONE ) {

	cmp	DWORD PTR [rbx+76], 0
	jne	SHORT $LN80@ParseProc

; 1291 :         EmitError( LANG_MUST_BE_SPECIFIED );

	mov	ecx, 91					; 0000005bH
	call	EmitError

; 1301 :             /* do proceed if the parameter scan returns an error */
; 1302 :             ;//return( ERROR );
; 1303 :     }
; 1304 : 
; 1305 :     /* v2.11: isdefined and isproc now set here */
; 1306 :     proc->sym.isdefined = TRUE;

	or	BYTE PTR [rbx+40], 2

; 1307 :     proc->sym.isproc = TRUE;

	or	BYTE PTR [rbx+41], 8

; 1308 :     //proc->e.procinfo->init_done = TRUE;
; 1309 :     DebugMsg1(("ParseProc(%s): memtype=%Xh parasize=%u\n", proc->sym.name, proc->sym.mem_type, proc->e.procinfo->parasize));
; 1310 : 
; 1311 :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@ParseProc
$LN80@ParseProc:

; 1292 :     } else {
; 1293 :         /* v2.05: set PROC's vararg flag BEFORE params are scanned! */
; 1294 :         if ( tokenarray[Token_Count - 1].token == T_RES_ID &&

	movsxd	rax, DWORD PTR ModuleInfo+496
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi-32], 7
	jne	SHORT $LN82@ParseProc
	cmp	DWORD PTR [rax+rsi-16], 262		; 00000106H
	jne	SHORT $LN82@ParseProc

; 1295 :             tokenarray[Token_Count - 1].tokval == T_VARARG )
; 1296 :             proc->e.procinfo->has_vararg = TRUE;

	mov	rax, QWORD PTR [rbx+96]
	or	BYTE PTR [rax+84], 1
	mov	edx, DWORD PTR i$[rbp-32]
$LN82@ParseProc:

; 1297 :         /* v2.04: removed, comma is checked above already */
; 1298 :         //if( tokenarray[i].token == T_COMMA )
; 1299 :         //    i++;
; 1300 :         if ( ERROR == ParseParams( proc, i, tokenarray, IsPROC ) )

	movzx	r9d, r15b
	mov	r8, rsi
	mov	rcx, rbx
	call	ParseParams
$LN83@ParseProc:

; 1301 :             /* do proceed if the parameter scan returns an error */
; 1302 :             ;//return( ERROR );
; 1303 :     }
; 1304 : 
; 1305 :     /* v2.11: isdefined and isproc now set here */
; 1306 :     proc->sym.isdefined = TRUE;

	or	BYTE PTR [rbx+40], 2

; 1307 :     proc->sym.isproc = TRUE;

	or	BYTE PTR [rbx+41], 8

; 1308 :     //proc->e.procinfo->init_done = TRUE;
; 1309 :     DebugMsg1(("ParseProc(%s): memtype=%Xh parasize=%u\n", proc->sym.name, proc->sym.mem_type, proc->e.procinfo->parasize));
; 1310 : 
; 1311 :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@ParseProc
$LN75@ParseProc:

; 1277 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [r8+rsi+8]
$LN126@ParseProc:
	mov	ecx, 209				; 000000d1H
$LN124@ParseProc:
	call	EmitErr
$LN1@ParseProc:
	mov	r14, QWORD PTR [rsp+112]

; 1312 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ParseProc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rdi, rcx

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rbx
	mov	QWORD PTR [rsp+40], rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], 0
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf
	test	eax, eax
	cmovs	eax, ebx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbx
	mov	r9, rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, rbx
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf

; 1459 :     #pragma warning(pop)
; 1460 : }

	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ebx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_Locale$ = 88
_ArgList$ = 96
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR _ArgList$[rsp]
	or	rcx, 1
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rbx
	call	__stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;
; 1391 : }

	mov	rbx, QWORD PTR [rsp+64]
	or	ecx, -1
	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ecx
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 950  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	rbx, rax
	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 955  :     __crt_va_end(_ArgList);
; 956  :     return _Result;
; 957  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 640  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
