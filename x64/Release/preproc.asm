; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
PUBLIC	WriteCodeLabel
PUBLIC	PreprocessLine
EXTRN	EmitErr:PROC
EXTRN	ParseLine:PROC
EXTRN	WritePreprocessedLine:PROC
EXTRN	Tokenize:PROC
EXTRN	CreateConstant:PROC
EXTRN	ExpandText:PROC
EXTRN	ExpandLine:PROC
EXTRN	StoreLine:PROC
EXTRN	LstWrite:PROC
EXTRN	LstWriteSrcLine:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	CurrIfState:DWORD
EXTRN	StoreState:BYTE
EXTRN	directive_tab:BYTE
pdata	SEGMENT
$pdata$WriteCodeLabel DD imagerel $LN7
	DD	imagerel $LN7+192
	DD	imagerel $unwind$WriteCodeLabel
$pdata$PreprocessLine DD imagerel $LN33
	DD	imagerel $LN33+494
	DD	imagerel $unwind$PreprocessLine
pdata	ENDS
xdata	SEGMENT
$unwind$WriteCodeLabel DD 0a4401H
	DD	08e444H
	DD	07643fH
	DD	06543aH
	DD	09340aH
	DD	07006320aH
$unwind$PreprocessLine DD 0ab701H
	DD	0774b7H
	DD	0654b2H
	DD	096410H
	DD	083410H
	DD	0e00c3210H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\preproc.c
_TEXT	SEGMENT
line$ = 48
tokenarray$ = 56
PreprocessLine PROC

; 73   : {

$LN33:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 74   :     int i;
; 75   : 
; 76   :     /* v2.11: GetTextLine() removed - this is now done in ProcessFile() */
; 77   : 
; 78   :     /* v2.08: moved here from GetTextLine() */
; 79   :     ModuleInfo.CurrComment = NULL;

	xor	esi, esi

; 80   :     /* v2.06: moved here from Tokenize() */
; 81   :     ModuleInfo.line_flags = 0;
; 82   :     /* Token_Count is the number of tokens scanned */
; 83   :     Token_Count = Tokenize( line, 0, tokenarray, TOK_DEFAULT );

	mov	r8, rdx
	mov	QWORD PTR ModuleInfo+472, rsi
	xor	edx, edx
	mov	BYTE PTR ModuleInfo+398, sil
	xor	r9d, r9d
	mov	r14, rcx
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax
	mov	edx, eax

; 84   : 
; 85   : #ifdef DEBUG_OUT
; 86   :     cntppl0++;
; 87   :     if ( ModuleInfo.GeneratedCode )
; 88   :         DebugMsg1(("PreprocessLine: >%s<\n", line ));
; 89   :     else
; 90   :         DebugMsg1(("PreprocessLine(%s): >%s< cmt=%s\n", GetTopSrcName(), line, ModuleInfo.CurrComment ? ModuleInfo.CurrComment : "" ));
; 91   : #endif
; 92   : 
; 93   : #if REMOVECOMENT == 0
; 94   :     if ( Token_Count == 0 && ( CurrIfState == BLOCK_ACTIVE || ModuleInfo.listif ) )

	test	eax, eax
	jne	SHORT $LN6@Preprocess
	cmp	DWORD PTR CurrIfState, esi
	je	SHORT $LN5@Preprocess
	test	DWORD PTR ModuleInfo+408, 8192		; 00002000H
	je	SHORT $LN27@Preprocess
$LN5@Preprocess:

; 95   :         LstWriteSrcLine();

	call	LstWriteSrcLine

; 96   : #endif
; 97   : 
; 98   :     if ( Token_Count == 0 )

	mov	edx, DWORD PTR ModuleInfo+496
	test	edx, edx
	jne	SHORT $LN6@Preprocess
$LN27@Preprocess:

; 99   :         return( 0 );

	xor	eax, eax

; 181  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN6@Preprocess:

; 100  : 
; 101  : #ifdef DEBUG_OUT
; 102  :     /* option -np, skip preprocessor? */
; 103  :     if ( Options.skip_preprocessor )
; 104  :         return( Token_Count );
; 105  : #endif
; 106  : 
; 107  :     /* CurrIfState != BLOCK_ACTIVE && Token_Count == 1 | 3 may happen
; 108  :      * if a conditional assembly directive has been detected by Tokenize().
; 109  :      * However, it's important NOT to expand then */
; 110  :     if ( CurrIfState == BLOCK_ACTIVE ) {

	cmp	DWORD PTR CurrIfState, esi
	jne	SHORT $LN8@Preprocess

; 111  :         if ( ( tokenarray[Token_Count].bytval & TF3_EXPANSION ? ExpandText( line, tokenarray, TRUE ) : ExpandLine( line, tokenarray ) ) < NOT_ERROR )

	movsxd	rax, edx
	mov	rcx, r14
	shl	rax, 5
	mov	rdx, rbx
	test	BYTE PTR [rax+rbx+1], 2
	je	SHORT $LN25@Preprocess
	mov	r8d, 1
	call	ExpandText
	jmp	SHORT $LN26@Preprocess
$LN25@Preprocess:
	call	ExpandLine
$LN26@Preprocess:
	test	eax, eax
	js	SHORT $LN27@Preprocess

; 112  :             return( 0 );

	mov	edx, DWORD PTR ModuleInfo+496
$LN8@Preprocess:
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+56], rdi

; 113  :     }
; 114  : 
; 115  :     DebugCmd( cntppl1++ );
; 116  : 
; 117  :     i = 0;

	mov	edi, esi

; 118  :     if ( Token_Count > 2 && ( tokenarray[1].token == T_COLON || tokenarray[1].token == T_DBL_COLON ) )

	cmp	edx, 2
	jle	SHORT $LN9@Preprocess
	movzx	eax, BYTE PTR [rbx+32]
	cmp	al, 58					; 0000003aH
	je	SHORT $LN10@Preprocess
	cmp	al, 13
	jne	SHORT $LN9@Preprocess
$LN10@Preprocess:

; 119  :         i = 2;

	mov	edi, 2
$LN9@Preprocess:

; 120  : 
; 121  :     /* handle "preprocessor" directives:
; 122  :      * IF, ELSE, ENDIF, ...
; 123  :      * FOR, REPEAT, WHILE, ...
; 124  :      * PURGE
; 125  :      * INCLUDE
; 126  :      * since v2.05, error directives are no longer handled here!
; 127  :      */
; 128  :     if ( tokenarray[i].token == T_DIRECTIVE &&

	movsxd	rax, edi
	shl	rax, 5
	cmp	BYTE PTR [rax+rbx], 3
	lea	rbp, QWORD PTR [rax+rbx]
	jne	SHORT $LN11@Preprocess
	cmp	BYTE PTR [rbp+1], 3
	ja	SHORT $LN11@Preprocess

; 129  :         tokenarray[i].dirtype <= DRT_INCLUDE ) {
; 130  : 
; 131  :         /* if i != 0, then a code label is located before the directive */
; 132  :         if ( i > 1 ) {

	cmp	edi, 1
	jle	SHORT $LN13@Preprocess

; 133  :             if ( ERROR == WriteCodeLabel( line, tokenarray ) )

	mov	rdx, rbx
	mov	rcx, r14
	call	WriteCodeLabel
	cmp	eax, -1
	je	$LN31@Preprocess
$LN13@Preprocess:

; 134  :                 return( 0 );
; 135  :         }
; 136  :         directive_tab[tokenarray[i].dirtype]( i, tokenarray );

	movzx	eax, BYTE PTR [rbp+1]
	lea	r8, OFFSET FLAT:directive_tab
	mov	rdx, rbx
	mov	ecx, edi
	call	QWORD PTR [r8+rax*8]

; 137  :         return( 0 );

	xor	eax, eax
	jmp	$LN30@Preprocess
$LN11@Preprocess:

; 138  :     }
; 139  : 
; 140  :     /* handle preprocessor directives which need a label */
; 141  : 
; 142  :     if ( tokenarray[0].token == T_ID && tokenarray[1].token == T_DIRECTIVE ) {

	cmp	BYTE PTR [rbx], 8
	jne	$LN2@Preprocess
	cmp	BYTE PTR [rbx+32], 3
	jne	$LN2@Preprocess

; 143  :         struct asym *sym;
; 144  :         switch ( tokenarray[1].dirtype ) {

	movzx	ecx, BYTE PTR [rbx+33]
	movzx	eax, cl
	cmp	cl, 4
	jb	$LN2@Preprocess
	cmp	al, 6
	jbe	SHORT $LN23@Preprocess
	cmp	al, 47					; 0000002fH
	jne	$LN2@Preprocess

; 145  :         case DRT_EQU:
; 146  :             /*
; 147  :              * EQU is a special case:
; 148  :              * If an EQU directive defines a text equate
; 149  :              * it MUST be handled HERE and 0 must be returned to the caller.
; 150  :              * This will prevent further processing, nothing will be stored
; 151  :              * if FASTPASS is on.
; 152  :              * Since one cannot decide whether EQU defines a text equate or
; 153  :              * a number before it has scanned its argument, we'll have to
; 154  :              * handle it in ANY case and if it defines a number, the line
; 155  :              * must be stored and, if -EP is set, written to stdout.
; 156  :              */
; 157  :             if ( sym = CreateConstant( tokenarray ) ) {

	mov	rcx, rbx
	call	CreateConstant
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN31@Preprocess

; 158  :                 if ( sym->state != SYM_TMACRO ) {

	cmp	DWORD PTR [rax+32], 10
	je	SHORT $LN21@Preprocess

; 159  : #if FASTPASS
; 160  :                     if ( StoreState ) FStoreLine( 0 );

	cmp	BYTE PTR StoreState, sil
	je	SHORT $LN19@Preprocess
	cmp	DWORD PTR Parse_Pass, esi
	jne	SHORT $LN19@Preprocess
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
$LN19@Preprocess:

; 161  : #endif
; 162  :                     if ( Options.preprocessor_stdout == TRUE )

	cmp	BYTE PTR Options+125, 1
	jne	SHORT $LN21@Preprocess

; 163  :                         WritePreprocessedLine( line );

	mov	rcx, r14
	call	WritePreprocessedLine
$LN21@Preprocess:

; 164  :                 }
; 165  :                 /* v2.03: LstWrite() must be called AFTER StoreLine()! */
; 166  :                 if ( ModuleInfo.list == TRUE ) {

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN31@Preprocess

; 167  :                     LstWrite( sym->state == SYM_INTERNAL ? LSTTYPE_EQUATE : LSTTYPE_TMACRO, 0, sym );

	cmp	DWORD PTR [rbx+32], 1
	mov	r8, rbx
	setne	sil
	xor	edx, edx
	lea	ecx, DWORD PTR [rsi+2]
	call	LstWrite

; 168  :                 }
; 169  :             }
; 170  :             return( 0 );

	xor	eax, eax
	jmp	SHORT $LN30@Preprocess
$LN23@Preprocess:

; 171  :         case DRT_MACRO:
; 172  :         case DRT_CATSTR: /* CATSTR + TEXTEQU directives */
; 173  :         case DRT_SUBSTR:
; 174  :             directive_tab[tokenarray[1].dirtype]( 1, tokenarray );

	movzx	eax, cl
	lea	r8, OFFSET FLAT:directive_tab
	mov	rdx, rbx
	mov	ecx, 1
	call	QWORD PTR [r8+rax*8]
$LN31@Preprocess:

; 175  :             return( 0 );

	xor	eax, eax
	jmp	SHORT $LN30@Preprocess
$LN2@Preprocess:

; 176  :         }
; 177  :     }
; 178  : 
; 179  :     DebugCmd( cntppl2++ );
; 180  :     return( Token_Count );

	mov	eax, edx
$LN30@Preprocess:
	mov	rbp, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+56]

; 181  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
PreprocessLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\preproc.c
_TEXT	SEGMENT
line$ = 48
tokenarray$ = 56
WriteCodeLabel PROC

; 40   : {

$LN7:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 41   :     int oldcnt;
; 42   :     int oldtoken;
; 43   :     char oldchar;
; 44   : 
; 45   :     if ( tokenarray[0].token != T_ID ) {

	cmp	BYTE PTR [rdx], 8
	mov	rbx, rdx
	mov	rdi, rcx
	je	SHORT $LN2@WriteCodeL

; 46   :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 209				; 000000d1H

; 63   :     return( NOT_ERROR );
; 64   : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 46   :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );

	jmp	EmitErr
$LN2@WriteCodeL:

; 47   :     }
; 48   :     /* ensure the listing is written with the FULL source line */
; 49   :     if ( CurrFile[LST] ) LstWrite( LSTTYPE_LABEL, 0, NULL );

	cmp	QWORD PTR ModuleInfo+112, 0
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+56], rsi
	mov	QWORD PTR [rsp+64], r14
	je	SHORT $LN3@WriteCodeL
	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+7]
	call	LstWrite
$LN3@WriteCodeL:

; 50   :     /* v2.04: call ParseLine() to parse the "label" part of the line */
; 51   :     oldcnt = Token_Count;
; 52   :     oldtoken = tokenarray[2].token;
; 53   :     oldchar = *tokenarray[2].tokpos;

	mov	rax, QWORD PTR [rbx+88]

; 54   :     Token_Count = 2;
; 55   :     tokenarray[2].token = T_FINAL;
; 56   :     *tokenarray[2].tokpos = NULLC;
; 57   :     ParseLine( tokenarray );

	mov	rcx, rbx
	mov	esi, DWORD PTR ModuleInfo+496
	movzx	ebp, BYTE PTR [rbx+64]
	movzx	r14d, BYTE PTR [rax]
	mov	DWORD PTR ModuleInfo+496, 2
	mov	rax, QWORD PTR [rbx+88]
	mov	BYTE PTR [rbx+64], 0
	mov	BYTE PTR [rax], 0
	call	ParseLine

; 58   :     if ( Options.preprocessor_stdout == TRUE )

	cmp	BYTE PTR Options+125, 1
	jne	SHORT $LN4@WriteCodeL

; 59   :         WritePreprocessedLine( line );

	mov	rcx, rdi
	call	WritePreprocessedLine
$LN4@WriteCodeL:

; 60   :     Token_Count = oldcnt;

	mov	DWORD PTR ModuleInfo+496, esi

; 61   :     tokenarray[2].token = oldtoken;
; 62   :     *tokenarray[2].tokpos = oldchar;

	mov	rax, QWORD PTR [rbx+88]
	mov	rsi, QWORD PTR [rsp+56]
	mov	BYTE PTR [rbx+64], bpl
	mov	rbp, QWORD PTR [rsp+48]

; 63   :     return( NOT_ERROR );
; 64   : }

	mov	rbx, QWORD PTR [rsp+72]
	mov	BYTE PTR [rax], r14b
	xor	eax, eax
	mov	r14, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
WriteCodeLabel ENDP
_TEXT	ENDS
END
