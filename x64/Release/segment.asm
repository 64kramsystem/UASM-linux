; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	symCurSeg:QWORD
_DATA	ENDS
_BSS	SEGMENT
$SG11362 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11278 DB	'READONLY', 00H
	ORG $+3
$SG11279 DB	'BYTE', 00H
	ORG $+3
$SG11280 DB	'WORD', 00H
	ORG $+3
$SG11281 DB	'DWORD', 00H
	ORG $+2
$SG11282 DB	'PARA', 00H
	ORG $+3
$SG11283 DB	'PAGE', 00H
	ORG $+3
$SG11284 DB	'ALIGN', 00H
	ORG $+2
$SG11286 DB	'PUBLIC', 00H
	ORG $+1
$SG11290 DB	'AT', 00H
	ORG $+1
$SG11285 DB	'PRIVATE', 00H
$SG11287 DB	'STACK', 00H
	ORG $+2
$SG11288 DB	'COMMON', 00H
	ORG $+1
$SG11289 DB	'MEMORY', 00H
	ORG $+1
$SG11291 DB	'COMDAT', 00H
	ORG $+1
$SG11292 DB	'USE16', 00H
	ORG $+2
$SG11293 DB	'USE32', 00H
	ORG $+2
$SG11294 DB	'USE64', 00H
	ORG $+2
$SG11295 DB	'FLAT', 00H
	ORG $+3
$SG11296 DB	'INFO', 00H
	ORG $+3
$SG11297 DB	'DISCARD', 00H
$SG11298 DB	'NOCACHE', 00H
$SG11299 DB	'NOPAGE', 00H
	ORG $+1
$SG11300 DB	'SHARED', 00H
	ORG $+1
$SG11301 DB	'EXECUTE', 00H
$SG11302 DB	'READ', 00H
	ORG $+3
$SG11303 DB	'WRITE', 00H
	ORG $+2
$SG11304 DB	'ALIAS', 00H
	ORG $+2
$SG11503 DB	'FLAT', 00H
	ORG $+3
$SG11550 DB	'CONST', 00H
	ORG $+2
$SG11552 DB	'DBTYP', 00H
	ORG $+2
$SG11554 DB	'DBSYM', 00H
	ORG $+2
$SG11557 DB	'CODE', 00H
	ORG $+3
$SG11559 DB	'DATA', 00H
	ORG $+3
$SG11562 DB	'BSS', 00H
$SG11731 DB	'(', 00H
	ORG $+2
$SG11734 DB	')', 00H
	ORG $+2
$SG11745 DB	'(', 00H
	ORG $+2
$SG11751 DB	'1-6', 00H
$SG11759 DB	')', 00H
	ORG $+2
$SG11772 DB	'(', 00H
	ORG $+2
$SG11776 DB	')', 00H
_DATA	ENDS
CONST	SEGMENT
SegAttrToken DQ	FLAT:$SG11278
	DQ	FLAT:$SG11279
	DQ	FLAT:$SG11280
	DQ	FLAT:$SG11281
	DQ	FLAT:$SG11282
	DQ	FLAT:$SG11283
	DQ	FLAT:$SG11284
	DQ	FLAT:$SG11285
	DQ	FLAT:$SG11286
	DQ	FLAT:$SG11287
	DQ	FLAT:$SG11288
	DQ	FLAT:$SG11289
	DQ	FLAT:$SG11290
	DQ	FLAT:$SG11291
	DQ	FLAT:$SG11292
	DQ	FLAT:$SG11293
	DQ	FLAT:$SG11294
	DQ	FLAT:$SG11295
	DQ	FLAT:$SG11296
	DQ	FLAT:$SG11297
	DQ	FLAT:$SG11298
	DQ	FLAT:$SG11299
	DQ	FLAT:$SG11300
	DQ	FLAT:$SG11301
	DQ	FLAT:$SG11302
	DQ	FLAT:$SG11303
	DQ	FLAT:$SG11304
SegAttrValue DB	00H
	DB	01H
	DB	00H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	02H
	DB	08H
	DB	02H
	DB	00H
	DB	082H
	DB	00H
	DB	04H
	DB	02H
	DB	04H
	DB	05H
	DB	04H
	DB	06H
	DB	04H
	DB	02H
	DB	04H
	DB	00H
	DB	084H
	DB	00H
	DB	0c4H
	DB	00H
	DB	08H
	DB	01H
	DB	08H
	DB	02H
	DB	08H
	DB	01H
	DB	088H
	DB	00H
	DB	0a0H
	DB	02H
	DB	020H
	DB	04H
	DB	020H
	DB	08H
	DB	020H
	DB	010H
	DB	020H
	DB	020H
	DB	020H
	DB	040H
	DB	020H
	DB	080H
	DB	020H
	DB	00H
	DB	010H
CONST	ENDS
PUBLIC	SetSymSegOfs
PUBLIC	GetSymOfssize
PUBLIC	GetCurrOffset
PUBLIC	CreateIntSegment
PUBLIC	GetSegIdx
PUBLIC	SegmentInit
PUBLIC	SegmentFini
PUBLIC	GetGroup
PUBLIC	GetCurrSegAlign
PUBLIC	SetOfssize
PUBLIC	TypeFromClassName
PUBLIC	DefineFlatGroup
PUBLIC	SegmentModuleExit
PUBLIC	DeleteGroup
PUBLIC	SegmentSaveState
PUBLIC	UpdateCurPC
PUBLIC	GrpDir
PUBLIC	UpdateWordSize
PUBLIC	EndsDir
PUBLIC	SegmentDir
PUBLIC	SortSegments
EXTRN	_stricmp:PROC
EXTRN	_strupr:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	QAddItem:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymAlloc:PROC
EXTRN	SymFree:PROC
EXTRN	SymCreate:PROC
EXTRN	SymFind:PROC
EXTRN	sym_add_table:PROC
EXTRN	sym_remove_table:PROC
EXTRN	Set64Bit:PROC
EXTRN	GetCodeClass:PROC
EXTRN	ModelSimSegmExit:PROC
EXTRN	EvalOperand:PROC
EXTRN	omf_OutSelect:PROC
EXTRN	omf_FlushCurrSeg:PROC
EXTRN	LstWrite:PROC
EXTRN	MsgGetEx:PROC
EXTRN	EndstructDirective:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	write_to_file:BYTE
EXTRN	SymCmpFunc:QWORD
EXTRN	SymTables:BYTE
EXTRN	UseSavedState:BYTE
EXTRN	SegAssumeTable:BYTE
EXTRN	CurrStruct:QWORD
EXTRN	__ImageBase:BYTE
_BSS	SEGMENT
	ALIGN	4

grpdefidx DD	01H DUP (?)
SegStack DQ	014H DUP (?)
stkindex DD	01H DUP (?)
	ALIGN	8

saved_CurrSeg DQ 01H DUP (?)
saved_SegStack DQ 01H DUP (?)
saved_stkindex DD 01H DUP (?)
codebuf	DB	0400H DUP (?)
buffer_size DD	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$CreateIntSegment DD imagerel $LN28
	DD	imagerel $LN28+375
	DD	imagerel $unwind$CreateIntSegment
$pdata$SegmentInit DD imagerel $LN33
	DD	imagerel $LN33+410
	DD	imagerel $unwind$SegmentInit
$pdata$SegmentFini DD imagerel $LN15
	DD	imagerel $LN15+16
	DD	imagerel $unwind$SegmentFini
$pdata$0$SegmentFini DD imagerel $LN15+16
	DD	imagerel $LN15+63
	DD	imagerel $chain$0$SegmentFini
$pdata$1$SegmentFini DD imagerel $LN15+63
	DD	imagerel $LN15+68
	DD	imagerel $chain$1$SegmentFini
$pdata$SetOfssize DD imagerel $LN7
	DD	imagerel $LN7+116
	DD	imagerel $unwind$SetOfssize
$pdata$TypeFromClassName DD imagerel $LN22
	DD	imagerel $LN22+120
	DD	imagerel $unwind$TypeFromClassName
$pdata$0$TypeFromClassName DD imagerel $LN22+120
	DD	imagerel $LN22+282
	DD	imagerel $chain$0$TypeFromClassName
$pdata$2$TypeFromClassName DD imagerel $LN22+282
	DD	imagerel $LN22+312
	DD	imagerel $chain$2$TypeFromClassName
$pdata$4$TypeFromClassName DD imagerel $LN22+312
	DD	imagerel $LN22+365
	DD	imagerel $chain$4$TypeFromClassName
$pdata$6$TypeFromClassName DD imagerel $LN22+365
	DD	imagerel $LN22+384
	DD	imagerel $chain$6$TypeFromClassName
$pdata$DefineFlatGroup DD imagerel $LN6
	DD	imagerel $LN6+61
	DD	imagerel $unwind$DefineFlatGroup
$pdata$SegmentModuleExit DD imagerel $LN24
	DD	imagerel $LN24+43
	DD	imagerel $unwind$SegmentModuleExit
$pdata$1$SegmentModuleExit DD imagerel $LN24+43
	DD	imagerel $LN24+216
	DD	imagerel $chain$1$SegmentModuleExit
$pdata$2$SegmentModuleExit DD imagerel $LN24+216
	DD	imagerel $LN24+223
	DD	imagerel $chain$2$SegmentModuleExit
$pdata$SegmentSaveState DD imagerel $LN5
	DD	imagerel $LN5+89
	DD	imagerel $unwind$SegmentSaveState
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$FindToken DD imagerel FindToken
	DD	imagerel FindToken+89
	DD	imagerel $unwind$FindToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$FreeLnameQueue DD imagerel FreeLnameQueue
	DD	imagerel FreeLnameQueue+16
	DD	imagerel $unwind$FreeLnameQueue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$FreeLnameQueue DD imagerel FreeLnameQueue+16
	DD	imagerel FreeLnameQueue+63
	DD	imagerel $chain$0$FreeLnameQueue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$FreeLnameQueue DD imagerel FreeLnameQueue+63
	DD	imagerel FreeLnameQueue+68
	DD	imagerel $chain$1$FreeLnameQueue
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateGroup DD imagerel CreateGroup
	DD	imagerel CreateGroup+202
	DD	imagerel $unwind$CreateGroup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateSegment DD imagerel CreateSegment
	DD	imagerel CreateSegment+201
	DD	imagerel $unwind$CreateSegment
pdata	ENDS
pdata	SEGMENT
$pdata$GrpDir DD imagerel $LN58
	DD	imagerel $LN58+81
	DD	imagerel $unwind$GrpDir
$pdata$0$GrpDir DD imagerel $LN58+81
	DD	imagerel $LN58+114
	DD	imagerel $chain$0$GrpDir
$pdata$8$GrpDir DD imagerel $LN58+114
	DD	imagerel $LN58+562
	DD	imagerel $chain$8$GrpDir
$pdata$10$GrpDir DD imagerel $LN58+562
	DD	imagerel $LN58+586
	DD	imagerel $chain$10$GrpDir
$pdata$11$GrpDir DD imagerel $LN58+586
	DD	imagerel $LN58+614
	DD	imagerel $chain$11$GrpDir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CloseSeg DD imagerel CloseSeg
	DD	imagerel CloseSeg+150
	DD	imagerel $unwind$CloseSeg
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$FindClass DD imagerel FindClass
	DD	imagerel FindClass+104
	DD	imagerel $unwind$FindClass
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateClassLname DD imagerel CreateClassLname
	DD	imagerel CreateClassLname+175
	DD	imagerel $unwind$CreateClassLname
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetSegmentClass DD imagerel SetSegmentClass
	DD	imagerel SetSegmentClass+50
	DD	imagerel $unwind$SetSegmentClass
pdata	ENDS
pdata	SEGMENT
$pdata$EndsDir DD imagerel $LN10
	DD	imagerel $LN10+147
	DD	imagerel $unwind$EndsDir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetCurrSeg DD imagerel SetCurrSeg
	DD	imagerel SetCurrSeg+214
	DD	imagerel $unwind$SetCurrSeg
pdata	ENDS
pdata	SEGMENT
$pdata$SegmentDir DD imagerel $LN158
	DD	imagerel $LN158+113
	DD	imagerel $unwind$SegmentDir
$pdata$1$SegmentDir DD imagerel $LN158+113
	DD	imagerel $LN158+407
	DD	imagerel $chain$1$SegmentDir
$pdata$2$SegmentDir DD imagerel $LN158+407
	DD	imagerel $LN158+1990
	DD	imagerel $chain$2$SegmentDir
$pdata$3$SegmentDir DD imagerel $LN158+1990
	DD	imagerel $LN158+2332
	DD	imagerel $chain$3$SegmentDir
$pdata$5$SegmentDir DD imagerel $LN158+2332
	DD	imagerel $LN158+2572
	DD	imagerel $chain$5$SegmentDir
$pdata$SortSegments DD imagerel $LN33
	DD	imagerel $LN33+291
	DD	imagerel $unwind$SortSegments
pdata	ENDS
CONST	SEGMENT
	ORG $+2
min_cpu	DW	00H
	DW	030H
	DW	070H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetCurrSeg DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetSegmentClass DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateClassLname DD 084a01H
	DD	07644aH
	DD	06343eH
	DD	08540aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FindClass DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CloseSeg DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateSegment DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateGroup DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$FreeLnameQueue DD 021H
	DD	imagerel FreeLnameQueue
	DD	imagerel FreeLnameQueue+16
	DD	imagerel $unwind$FreeLnameQueue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$FreeLnameQueue DD 020521H
	DD	043405H
	DD	imagerel FreeLnameQueue
	DD	imagerel FreeLnameQueue+16
	DD	imagerel $unwind$FreeLnameQueue
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FreeLnameQueue DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FindToken DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
xdata	SEGMENT
$unwind$CreateIntSegment DD 0a1a01H
	DD	09e41aH
	DD	08741aH
	DD	07541aH
	DD	06341aH
	DD	0f016321aH
$unwind$SegmentInit DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$SegmentFini DD 010401H
	DD	04204H
$chain$0$SegmentFini DD 020521H
	DD	043405H
	DD	imagerel $LN15
	DD	imagerel $LN15+16
	DD	imagerel $unwind$SegmentFini
$chain$1$SegmentFini DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+16
	DD	imagerel $unwind$SegmentFini
$unwind$SetOfssize DD 010401H
	DD	04204H
$unwind$TypeFromClassName DD 030901H
	DD	0240109H
	DD	07002H
$chain$0$TypeFromClassName DD 020821H
	DD	0263408H
	DD	imagerel $LN22
	DD	imagerel $LN22+120
	DD	imagerel $unwind$TypeFromClassName
$chain$2$TypeFromClassName DD 020021H
	DD	0263400H
	DD	imagerel $LN22
	DD	imagerel $LN22+120
	DD	imagerel $unwind$TypeFromClassName
$chain$4$TypeFromClassName DD 020021H
	DD	0263400H
	DD	imagerel $LN22
	DD	imagerel $LN22+120
	DD	imagerel $unwind$TypeFromClassName
$chain$6$TypeFromClassName DD 020021H
	DD	0263400H
	DD	imagerel $LN22
	DD	imagerel $LN22+120
	DD	imagerel $unwind$TypeFromClassName
$unwind$DefineFlatGroup DD 010401H
	DD	04204H
$unwind$SegmentModuleExit DD 010401H
	DD	04204H
$chain$1$SegmentModuleExit DD 041621H
	DD	063416H
	DD	047405H
	DD	imagerel $LN24
	DD	imagerel $LN24+43
	DD	imagerel $unwind$SegmentModuleExit
$chain$2$SegmentModuleExit DD 021H
	DD	imagerel $LN24
	DD	imagerel $LN24+43
	DD	imagerel $unwind$SegmentModuleExit
$unwind$SegmentSaveState DD 010401H
	DD	04204H
$unwind$GrpDir DD 020601H
	DD	0d0027206H
$chain$0$GrpDir DD 020521H
	DD	077405H
	DD	imagerel $LN58
	DD	imagerel $LN58+81
	DD	imagerel $unwind$GrpDir
$chain$8$GrpDir DD 0e2e21H
	DD	05e42eH
	DD	0a3429H
	DD	04f420H
	DD	06c418H
	DD	0c640fH
	DD	0b5405H
	DD	077400H
	DD	imagerel $LN58
	DD	imagerel $LN58+81
	DD	imagerel $unwind$GrpDir
$chain$10$GrpDir DD 0e0021H
	DD	04f400H
	DD	05e400H
	DD	06c400H
	DD	077400H
	DD	0c6400H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel $LN58
	DD	imagerel $LN58+81
	DD	imagerel $unwind$GrpDir
$chain$11$GrpDir DD 021H
	DD	imagerel $LN58
	DD	imagerel $LN58+81
	DD	imagerel $unwind$GrpDir
$unwind$EndsDir DD 020601H
	DD	030023206H
$unwind$SegmentDir DD 071801H
	DD	0180118H
	DD	0d00af00cH
	DD	06006c008H
	DD	05005H
$chain$1$SegmentDir DD 041721H
	DD	0177417H
	DD	01f3408H
	DD	imagerel $LN158
	DD	imagerel $LN158+113
	DD	imagerel $unwind$SegmentDir
$chain$2$SegmentDir DD 020821H
	DD	016e408H
	DD	imagerel $LN158+113
	DD	imagerel $LN158+407
	DD	imagerel $chain$1$SegmentDir
$chain$3$SegmentDir DD 021H
	DD	imagerel $LN158+113
	DD	imagerel $LN158+407
	DD	imagerel $chain$1$SegmentDir
$chain$5$SegmentDir DD 060021H
	DD	016e400H
	DD	0177400H
	DD	01f3400H
	DD	imagerel $LN158
	DD	imagerel $LN158+113
	DD	imagerel $unwind$SegmentDir
$unwind$SortSegments DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
type$ = 48
SortSegments PROC

; 1361 : {

$LN33:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	ebp, ecx
	npad	4
$LL2@SortSegmen:

; 1368 :         struct dsym *prev = NULL;
; 1369 :         changed = FALSE;
; 1370 :         for( curr = SymTables[TAB_SEG].head; curr && curr->next ; prev = curr, curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	xor	esi, esi
	xor	r14b, r14b
	test	rbx, rbx
	je	$LN27@SortSegmen
	npad	11
$LL6@SortSegmen:
	mov	rdx, QWORD PTR [rbx+104]
	test	rdx, rdx
	je	$LN5@SortSegmen

; 1371 :             swap = FALSE;
; 1372 :             switch (type ) {

	mov	ecx, ebp
	test	ebp, ebp
	je	SHORT $LN9@SortSegmen
	sub	ecx, 1
	je	SHORT $LN11@SortSegmen
	cmp	ecx, 1
	jne	$LN4@SortSegmen

; 1381 :             case 2:
; 1382 :                 if ( curr->e.seginfo->lname_idx > curr->next->e.seginfo->lname_idx ||

	mov	rax, QWORD PTR [rbx+96]
	mov	ecx, DWORD PTR [rax+76]
	mov	rax, QWORD PTR [rdx+96]
	mov	r8d, DWORD PTR [rax+76]
	cmp	ecx, r8d
	jg	SHORT $LN28@SortSegmen
	jne	SHORT $LN4@SortSegmen
	mov	rdx, QWORD PTR [rdx+8]
	mov	rcx, QWORD PTR [rbx+8]
	call	_stricmp
	test	eax, eax
	jg	SHORT $LN28@SortSegmen
	jmp	SHORT $LN4@SortSegmen
$LN11@SortSegmen:

; 1375 :                     swap = TRUE;
; 1376 :                 break;
; 1377 :             case 1:
; 1378 :                 if ( strcmp( curr->sym.name, curr->next->sym.name ) > 0 )

	mov	rax, QWORD PTR [rbx+8]
	mov	r8, QWORD PTR [rdx+8]
	sub	r8, rax
	npad	11
$LL29@SortSegmen:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN30@SortSegmen
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL29@SortSegmen
$LN30@SortSegmen:
	test	edx, edx
	jle	SHORT $LN4@SortSegmen

; 1379 :                     swap = TRUE;
; 1380 :                 break;

	jmp	SHORT $LN28@SortSegmen
$LN9@SortSegmen:

; 1373 :             case 0:
; 1374 :                 if ( curr->e.seginfo->fileoffset > curr->next->e.seginfo->fileoffset )

	mov	rax, QWORD PTR [rdx+96]
	mov	rcx, QWORD PTR [rbx+96]
	mov	eax, DWORD PTR [rax+56]
	cmp	DWORD PTR [rcx+56], eax
	jbe	SHORT $LN4@SortSegmen
$LN28@SortSegmen:

; 1383 :                     ( curr->e.seginfo->lname_idx == curr->next->e.seginfo->lname_idx &&
; 1384 :                     ( _stricmp( curr->sym.name, curr->next->sym.name ) > 0 ) ) )
; 1385 :                     swap = TRUE;
; 1386 :                 break;
; 1387 : #ifdef DEBUG_OUT
; 1388 :             default: /**/myassert( 0 );
; 1389 : #endif
; 1390 :             }
; 1391 :             if ( swap ) {
; 1392 :                 struct dsym *tmp = curr->next;

	mov	rcx, QWORD PTR [rbx+104]

; 1393 :                 changed = TRUE;

	mov	r14b, 1

; 1394 :                 if ( prev == NULL ) {

	test	rsi, rsi
	jne	SHORT $LN17@SortSegmen

; 1395 :                     SymTables[TAB_SEG].head = tmp;

	mov	QWORD PTR SymTables+32, rcx

; 1396 :                 } else {

	jmp	SHORT $LN18@SortSegmen
$LN17@SortSegmen:

; 1397 :                     prev->next = tmp;

	mov	QWORD PTR [rsi+104], rcx
$LN18@SortSegmen:

; 1398 :                 }
; 1399 :                 curr->next = tmp->next;

	mov	rax, QWORD PTR [rcx+104]
	mov	QWORD PTR [rbx+104], rax

; 1400 :                 tmp->next = curr;

	mov	QWORD PTR [rcx+104], rbx
$LN4@SortSegmen:

; 1368 :         struct dsym *prev = NULL;
; 1369 :         changed = FALSE;
; 1370 :         for( curr = SymTables[TAB_SEG].head; curr && curr->next ; prev = curr, curr = curr->next ) {

	mov	rsi, rbx
	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	$LL6@SortSegmen
$LN5@SortSegmen:

; 1362 :     bool changed = TRUE;
; 1363 :     bool swap;
; 1364 :     struct dsym *curr;
; 1365 :     //int index = 1;
; 1366 : 
; 1367 :     while ( changed == TRUE ) {

	cmp	r14b, 1
	je	$LL2@SortSegmen
$LN27@SortSegmen:

; 1401 :             }
; 1402 :         }
; 1403 :     }
; 1404 : 
; 1405 :     /* v2.7: don't change segment indices! They're stored in fixup.frame_datum */
; 1406 :     //for ( curr = SymTables[TAB_SEG].head; curr ; curr = curr->next ) {
; 1407 :     //    curr->e.seginfo->seg_idx = index++;
; 1408 :     //}
; 1409 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
SortSegments ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
oldcombine$ = 48
oldOfssize$ = 49
opndx$ = 64
i$ = 240
tokenarray$ = 248
is_old$1$ = 256
oldalign$ = 264
SegmentDir PROC

; 919  : {

$LN158:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rsi
	push	r12
	push	r13
	push	r15
	lea	rbp, QWORD PTR [rsp-55]
	sub	rsp, 192				; 000000c0H

; 920  :     char                is_old = FALSE;

	xor	sil, sil

; 921  :     char                *token;
; 922  :     int                 typeidx;
; 923  :     const struct typeinfo *type;          /* type of option */
; 924  :     int                 temp;
; 925  :     int                 temp2;
; 926  :     unsigned            initstate = 0;  /* flags for attribute initialization */

	xor	r12d, r12d

; 927  :     //unsigned char       oldreadonly;    /* readonly value of a defined segment */
; 928  :     //unsigned char       oldsegtype;
; 929  :     unsigned char       oldOfssize;
; 930  :     char                oldalign;
; 931  :     char                oldcombine;
; 932  :     //struct asym         *oldclsym;
; 933  :     uint_8              newcharacteristics = 0;

	xor	r13b, r13b
	mov	BYTE PTR is_old$1$[rbp-137], sil

; 934  :     struct dsym         *dir;
; 935  :     char                *name;
; 936  :     struct asym         *sym;
; 937  :     struct expr         opndx;
; 938  : 
; 939  :     if ( Parse_Pass != PASS_1 )

	cmp	DWORD PTR Parse_Pass, r12d
	mov	r15, rdx
	je	SHORT $LN10@SegmentDir

; 940  :         return( SetCurrSeg( i, tokenarray ) );

	call	SetCurrSeg

; 1351 : }

	add	rsp, 192				; 000000c0H
	pop	r15
	pop	r13
	pop	r12
	pop	rsi
	pop	rbp
	ret	0
$LN10@SegmentDir:

; 941  : 
; 942  :     if( i != 1 ) {

	cmp	ecx, 1
	je	SHORT $LN11@SegmentDir

; 943  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r15+8]
	call	EmitErr

; 1351 : }

	add	rsp, 192				; 000000c0H
	pop	r15
	pop	r13
	pop	r12
	pop	rsi
	pop	rbp
	ret	0
$LN11@SegmentDir:
	mov	QWORD PTR [rsp+248], rbx

; 944  :     }
; 945  : 
; 946  :     name = tokenarray[0].string_ptr;

	mov	rbx, QWORD PTR [rdx+8]

; 947  : 
; 948  :     DebugMsg1(("SegmentDir(%s) enter: ModuleInfo.Ofssize=%u, num_seg=%u\n", name, ModuleInfo.Ofssize, ModuleInfo.g.num_segs ));
; 949  : 
; 950  :     /* See if the segment is already defined */
; 951  :     sym = SymSearch( name );

	mov	rcx, rbx
	mov	QWORD PTR [rsp+184], rdi
	call	SymFind
	mov	rdi, rax

; 952  :     if( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rax, rax
	je	$LN14@SegmentDir
	mov	eax, DWORD PTR [rax+32]
	test	eax, eax
	je	$LN14@SegmentDir

; 957  :         dir = (struct dsym *)sym;
; 958  :         /* v2.12: seg_idx member now set AFTER parsing is done */
; 959  :         //dir->e.seginfo->seg_idx = ++ModuleInfo.g.num_segs;
; 960  : #if 0 //COFF_SUPPORT || ELF_SUPPORT /* v2.09: removed, since not Masm-compatible */
; 961  :         if ( Options.output_format == OFORMAT_COFF
; 962  : #if ELF_SUPPORT
; 963  :             || Options.output_format == OFORMAT_ELF
; 964  : #endif
; 965  :            ) {
; 966  :             char *p;
; 967  :             if ( p = strchr(sym->name, '$') ) {
; 968  :                 char buffer[MAX_ID_LEN+1];
; 969  :                 struct dsym *dir2;
; 970  :                 /* initialize segment with values from the one without suffix */
; 971  :                 memcpy( buffer, sym->name, p - sym->name );
; 972  :                 buffer[p - sym->name] = NULLC;
; 973  :                 if ( ( dir2 = (struct dsym *)SymSearch( buffer ) ) && dir2->sym.state == SYM_SEG ) {
; 974  :                     dir->e.seginfo->segtype  = dir2->e.seginfo->segtype;
; 975  :                     dir->e.seginfo->combine  = dir2->e.seginfo->combine;
; 976  :                     dir->e.seginfo->readonly = dir2->e.seginfo->readonly;
; 977  :                     dir->e.seginfo->Ofssize  = dir2->e.seginfo->Ofssize;
; 978  :                     dir->e.seginfo->alignment= dir2->e.seginfo->alignment;
; 979  :                     dir->e.seginfo->characteristics = dir2->e.seginfo->characteristics;
; 980  :                     dir->e.seginfo->clsym           = dir2->e.seginfo->clsym;
; 981  :                 }
; 982  :             }
; 983  :         }
; 984  : #endif
; 985  :     } else if ( sym->state == SYM_SEG ) { /* segment already defined? */

	cmp	eax, 3
	jne	$LN15@SegmentDir

; 986  :         
; 987  :         dir = (struct dsym *)sym;
; 988  :         /* v2.12: check 'isdefined' instead of lname_idx */
; 989  :         //if( dir->e.seginfo->lname_idx == 0 ) {
; 990  :         if( sym->isdefined == FALSE ) {

	test	BYTE PTR [rdi+40], 2
	jne	SHORT $LN17@SegmentDir

; 991  :             /* segment was forward referenced (in a GROUP directive), but not really set up */
; 992  :             /* the segment list is to be sorted.
; 993  :              * So unlink the segment and add it at the end.
; 994  :              */
; 995  :             UnlinkSeg( dir );

	mov	rcx, QWORD PTR SymTables+32
	xor	edx, edx
	test	rcx, rcx
	je	SHORT $LN100@SegmentDir
$LL96@SegmentDir:
	cmp	rcx, rdi
	je	SHORT $LN120@SegmentDir
	mov	rdx, rcx
	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL96@SegmentDir

; 1045 :         }
; 1046 : 
; 1047 :         /* check the rest of segment attributes.
; 1048 :          */
; 1049 :         typeidx = FindToken( token, SegAttrToken, sizeof( SegAttrToken )/sizeof( SegAttrToken[0] ) );

	jmp	SHORT $LN100@SegmentDir
$LN120@SegmentDir:

; 991  :             /* segment was forward referenced (in a GROUP directive), but not really set up */
; 992  :             /* the segment list is to be sorted.
; 993  :              * So unlink the segment and add it at the end.
; 994  :              */
; 995  :             UnlinkSeg( dir );

	mov	rax, QWORD PTR [rcx+104]
	test	rdx, rdx
	jne	SHORT $LN98@SegmentDir
	mov	QWORD PTR SymTables+32, rax
	jmp	SHORT $LN99@SegmentDir
$LN98@SegmentDir:
	mov	QWORD PTR [rdx+104], rax
$LN99@SegmentDir:
	cmp	QWORD PTR [rcx+104], r12
	mov	rax, QWORD PTR SymTables+40
	cmove	rax, rdx
	mov	QWORD PTR SymTables+40, rax
$LN100@SegmentDir:

; 996  :             /* v2.12: seg_idx member now set AFTER parsing is done */
; 997  :             //dir->e.seginfo->seg_idx = ++ModuleInfo.g.num_segs;
; 998  :             dir->next = NULL;

	mov	QWORD PTR [rdi+104], r12

; 999  :             if ( SymTables[TAB_SEG].head == NULL )

	cmp	QWORD PTR SymTables+32, r12
	jne	SHORT $LN19@SegmentDir

; 1000 :                 SymTables[TAB_SEG].head = SymTables[TAB_SEG].tail = dir;

	mov	QWORD PTR SymTables+40, rdi
	mov	QWORD PTR SymTables+32, rdi
	jmp	SHORT $LN16@SegmentDir
$LN19@SegmentDir:

; 1001 :             else {
; 1002 :                 SymTables[TAB_SEG].tail->next = dir;

	mov	rax, QWORD PTR SymTables+40
	mov	QWORD PTR [rax+104], rdi

; 1003 :                 SymTables[TAB_SEG].tail = dir;

	mov	QWORD PTR SymTables+40, rdi

; 1004 :             }
; 1005 :         } else {

	jmp	SHORT $LN16@SegmentDir
$LN17@SegmentDir:

; 1006 :             is_old = TRUE;
; 1007 :             //oldreadonly = dir->e.seginfo->readonly;
; 1008 :             //oldsegtype  = dir->e.seginfo->segtype;
; 1009 :             oldOfssize  = dir->e.seginfo->Ofssize;

	mov	rcx, QWORD PTR [rdi+96]
	mov	sil, 1
	mov	BYTE PTR is_old$1$[rbp-137], sil
	movzx	eax, BYTE PTR [rcx+104]
	mov	BYTE PTR oldOfssize$[rbp-137], al

; 1010 :             oldalign    = dir->e.seginfo->alignment;

	movzx	eax, BYTE PTR [rcx+106]
	mov	BYTE PTR oldalign$[rbp-137], al

; 1011 :             oldcombine  = dir->e.seginfo->combine;

	movzx	eax, BYTE PTR [rcx+108]
	and	al, 7
	mov	BYTE PTR oldcombine$[rbp-137], al

; 1012 :             /* v2.09: class isn't checked anymore, and characteristics is handled differently */
; 1013 :             //oldcharacteristics = dir->e.seginfo->characteristics;
; 1014 :             //oldclsym    = dir->e.seginfo->clsym;
; 1015 :         }
; 1016 : 
; 1017 :     } else {

	jmp	SHORT $LN16@SegmentDir
$LN15@SegmentDir:

; 1018 :         /* symbol is different kind, error */
; 1019 :         DebugMsg(("SegmentDir(%s): symbol redefinition\n", name ));
; 1020 :         return( EmitErr( SYMBOL_REDEFINITION, name ) );

	mov	rdx, rbx
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN150@SegmentDir
$LN14@SegmentDir:

; 953  : 
; 954  :         /* segment is not defined (yet) */
; 955  :         sym = (struct asym *)CreateSegment( (struct dsym *)sym, name, TRUE );

	mov	r8b, 1
	mov	rdx, rbx
	mov	rcx, rdi
	call	CreateSegment
	mov	rdi, rax

; 956  :         sym->list = TRUE; /* always list segments */

	or	BYTE PTR [rax+41], 1
$LN16@SegmentDir:

; 1021 :     }
; 1022 : 
; 1023 :     i++; /* go past SEGMENT */

	mov	eax, DWORD PTR i$[rbp-137]

; 1024 : 
; 1025 :     for( ; i < Token_Count; i++ ) {

	lea	rbx, OFFSET FLAT:__ImageBase
	inc	eax
	cmp	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rbp-137], eax
	jge	$LN3@SegmentDir
	mov	QWORD PTR [rsp+176], r14
	npad	1
$LL4@SegmentDir:

; 1026 :         token = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rbp-137]
	shl	rax, 5

; 1027 :         DebugMsg1(("SegmentDir(%s): i=%u, string=%s token=%X\n", name, i, token, tokenarray[i].token ));
; 1028 :         if( tokenarray[i].token == T_STRING ) {

	cmp	BYTE PTR [rax+r15], 9
	lea	rcx, QWORD PTR [rax+r15]
	mov	r14, QWORD PTR [rcx+8]
	jne	SHORT $LN21@SegmentDir

; 1029 : 
; 1030 :             /* the class name - the only token which is of type STRING */
; 1031 :             /* string must be delimited by [double]quotes */
; 1032 :             if ( tokenarray[i].string_delim != '"' &&

	movzx	eax, BYTE PTR [rcx+1]
	cmp	al, 34					; 00000022H
	je	SHORT $LN22@SegmentDir
	cmp	al, 39					; 00000027H
	je	SHORT $LN22@SegmentDir

; 1033 :                 tokenarray[i].string_delim != '\'' ) {
; 1034 :                 EmitErr( SYNTAX_ERROR_EX, token );

	mov	rdx, r14
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1035 :                 continue;

	jmp	$LN2@SegmentDir
$LN22@SegmentDir:

; 1036 :             }
; 1037 :             /* remove the quote delimiters */
; 1038 :             token++;
; 1039 :             *(token+tokenarray[i].stringlen) = NULLC;

	mov	eax, DWORD PTR [rcx+16]

; 1040 : 
; 1041 :             SetSegmentClass( dir, token );

	lea	rcx, QWORD PTR [r14+1]
	mov	BYTE PTR [rax+r14+1], 0
	call	CreateClassLname
	test	rax, rax
	je	$LN2@SegmentDir
	mov	rcx, QWORD PTR [rdi+96]
	mov	QWORD PTR [rcx+80], rax

; 1042 : 
; 1043 :             DebugMsg1(("SegmentDir(%s): class found: %s\n", name, token ));
; 1044 :             continue;

	jmp	$LN2@SegmentDir
$LN21@SegmentDir:

; 1045 :         }
; 1046 : 
; 1047 :         /* check the rest of segment attributes.
; 1048 :          */
; 1049 :         typeidx = FindToken( token, SegAttrToken, sizeof( SegAttrToken )/sizeof( SegAttrToken[0] ) );

	lea	rsi, OFFSET FLAT:SegAttrToken
	xor	ebx, ebx
	npad	10
$LL108@SegmentDir:
	mov	rcx, QWORD PTR [rsi]
	mov	rdx, r14
	call	_stricmp
	test	eax, eax
	je	SHORT $LN105@SegmentDir
	inc	rbx
	add	rsi, 8
	cmp	rbx, 27
	jl	SHORT $LL108@SegmentDir

; 1051 :             EmitErr( UNKNOWN_SEGMENT_ATTRIBUTE, token );

	mov	rdx, r14
	mov	ecx, 81					; 00000051H
	call	EmitErr

; 1052 :             continue;

	jmp	$LN148@SegmentDir

; 1045 :         }
; 1046 : 
; 1047 :         /* check the rest of segment attributes.
; 1048 :          */
; 1049 :         typeidx = FindToken( token, SegAttrToken, sizeof( SegAttrToken )/sizeof( SegAttrToken[0] ) );

$LN105@SegmentDir:

; 1050 :         if( typeidx < 0 ) {

	test	rbx, rbx
	jns	SHORT $LN23@SegmentDir

; 1051 :             EmitErr( UNKNOWN_SEGMENT_ATTRIBUTE, token );

	mov	rdx, r14
	mov	ecx, 81					; 00000051H
	call	EmitErr

; 1052 :             continue;

	jmp	$LN148@SegmentDir
$LN23@SegmentDir:

; 1053 :         }
; 1054 :         type = &SegAttrValue[typeidx];

	lea	r8, OFFSET FLAT:__ImageBase
	lea	rbx, QWORD PTR SegAttrValue[rbx*2]
	add	rbx, r8

; 1055 : 
; 1056 :         /* initstate is used to check if any field is already
; 1057 :          * initialized
; 1058 :          */
; 1059 :         if( initstate & INIT_EXCL_MASK & type->init ) {

	movzx	edx, BYTE PTR [rbx+1]
	mov	eax, edx
	and	eax, r12d
	test	al, 31
	je	SHORT $LN24@SegmentDir

; 1060 :             EmitErr( SEGMENT_ATTRIBUTE_DEFINED_ALREADY, token );

	mov	rdx, r14
	mov	ecx, 77					; 0000004dH
	call	EmitErr

; 1061 :             continue;

	jmp	$LN148@SegmentDir
$LN24@SegmentDir:

; 1062 :         } else {
; 1063 :             initstate |= type->init; /* mark it initialized */

	or	r12d, edx

; 1064 :         }
; 1065 : 
; 1066 :         switch ( type->init ) {

	lea	eax, DWORD PTR [rdx-1]
	cmp	eax, 195				; 000000c3H
	ja	$LN148@SegmentDir
	cdqe
	movzx	eax, BYTE PTR $LN138@SegmentDir[r8+rax]
	mov	ecx, DWORD PTR $LN139@SegmentDir[r8+rax*4]
	add	rcx, r8
	jmp	rcx
$LN26@SegmentDir:

; 1067 :         case INIT_ATTR:
; 1068 :             dir->e.seginfo->readonly = TRUE;

	mov	rax, QWORD PTR [rdi+96]
	or	BYTE PTR [rax+107], 1

; 1069 :             break;

	jmp	$LN148@SegmentDir
$LN27@SegmentDir:

; 1070 :         case INIT_ALIGN:
; 1071 :             DebugMsg1(("SegmentDir(%s): align attribute found\n", name ));
; 1072 :             dir->e.seginfo->alignment = type->value;

	mov	rcx, QWORD PTR [rdi+96]
	movzx	eax, BYTE PTR [rbx]
	mov	BYTE PTR [rcx+106], al

; 1073 :             break;

	jmp	$LN148@SegmentDir
$LN28@SegmentDir:

; 1074 :         case INIT_ALIGN_PARAM:
; 1075 :             DebugMsg1(("SegmentDir(%s): ALIGN() found\n", name ));
; 1076 :             if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN29@SegmentDir

; 1077 :                 EmitErr( NOT_SUPPORTED_WITH_OMF_FORMAT, tokenarray[i].string_ptr );

	mov	ecx, 223				; 000000dfH

; 1078 :                 i = Token_Count; /* stop further parsing of this line */
; 1079 :                 break;

	jmp	$LN154@SegmentDir
$LN29@SegmentDir:

; 1080 :             }
; 1081 :             i++;

	mov	ecx, DWORD PTR i$[rbp-137]
	inc	ecx

; 1082 :             if ( tokenarray[i].token != T_OP_BRACKET ) {

	movsxd	rax, ecx
	shl	rax, 5
	mov	DWORD PTR i$[rbp-137], ecx
	cmp	BYTE PTR [rax+r15], 40			; 00000028H
	je	SHORT $LN30@SegmentDir

; 1083 :                 EmitErr( EXPECTED, "(" );

	lea	rdx, OFFSET FLAT:$SG11731
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1084 :                 break;

	jmp	$LN148@SegmentDir
$LN30@SegmentDir:

; 1085 :             }
; 1086 :             i++;
; 1087 :             if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rbp-137]
	inc	ecx
	mov	BYTE PTR [rsp+32], 0
	mov	DWORD PTR i$[rbp-137], ecx
	mov	rdx, r15
	lea	rcx, QWORD PTR i$[rbp-137]
	call	EvalOperand
	cmp	eax, -1
	je	$LN148@SegmentDir

; 1088 :                 break;
; 1089 :             if ( tokenarray[i].token != T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rbp-137]
	shl	rax, 5
	cmp	BYTE PTR [rax+r15], 41			; 00000029H
	je	SHORT $LN32@SegmentDir

; 1090 :                 EmitErr( EXPECTED, ")" );

	lea	rdx, OFFSET FLAT:$SG11734
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1091 :                 break;

	jmp	$LN148@SegmentDir
$LN32@SegmentDir:

; 1092 :             }
; 1093 :             if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rbp-77], 0
	je	SHORT $LN33@SegmentDir
$LN38@SegmentDir:

; 1094 :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 1095 :                 break;

	jmp	$LN148@SegmentDir
$LN33@SegmentDir:

; 1096 :             }
; 1097 :             /*
; 1098 :              COFF allows alignment values
; 1099 :              1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192
; 1100 :              */
; 1101 :             for( temp = 1, temp2 = 0; temp < opndx.value && temp < 8192 ; temp <<= 1, temp2++ );

	mov	edx, DWORD PTR opndx$[rbp-137]
	mov	eax, 1
	xor	ebx, ebx
	cmp	eax, edx
	jge	SHORT $LN151@SegmentDir
	npad	4
$LL9@SegmentDir:
	cmp	eax, 8192				; 00002000H
	jge	SHORT $LN143@SegmentDir
	add	eax, eax
	inc	ebx
	cmp	eax, edx
	jl	SHORT $LL9@SegmentDir
$LN143@SegmentDir:

; 1102 :             if( temp != opndx.value ) {

	cmp	eax, edx
$LN151@SegmentDir:
	je	SHORT $LN34@SegmentDir

; 1103 :                 EmitErr( POWER_OF_2, opndx.value );

	mov	ecx, 129				; 00000081H
	call	EmitErr
$LN34@SegmentDir:

; 1104 :             }
; 1105 :             dir->e.seginfo->alignment = temp2;

	mov	rax, QWORD PTR [rdi+96]
	mov	BYTE PTR [rax+106], bl

; 1106 :             break;

	jmp	$LN148@SegmentDir
$LN36@SegmentDir:

; 1107 :         case INIT_COMBINE:
; 1108 :             DebugMsg1(("SegmentDir(%s): combine attribute found\n", name ));
; 1109 :             dir->e.seginfo->combine = type->value;
; 1110 :             break;
; 1111 :         case INIT_COMBINE_AT:
; 1112 :             DebugMsg1(("SegmentDir(%s): AT found\n", name ));
; 1113 :             dir->e.seginfo->combine = type->value;

	mov	rcx, QWORD PTR [rdi+96]

; 1114 :             /* v2.05: always use MAX_SEGALIGNMENT */
; 1115 :             //dir->e.seginfo->alignment = -1;
; 1116 :             dir->e.seginfo->alignment = MAX_SEGALIGNMENT;
; 1117 :             i++;
; 1118 :             if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) != ERROR ) {

	lea	r9, QWORD PTR opndx$[rbp-137]
	movzx	eax, BYTE PTR [rbx]
	mov	rdx, r15
	mov	BYTE PTR [rsp+32], 0
	xor	al, BYTE PTR [rcx+108]
	and	al, 7
	xor	BYTE PTR [rcx+108], al
	lea	rcx, QWORD PTR i$[rbp-137]
	mov	rax, QWORD PTR [rdi+96]
	mov	BYTE PTR [rax+106], 255			; 000000ffH
	mov	r8d, DWORD PTR ModuleInfo+496
	inc	DWORD PTR i$[rbp-137]
	call	EvalOperand
	cmp	eax, -1
	je	$LN148@SegmentDir

; 1119 :                 if ( opndx.kind == EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rbp-77], 0
	jne	$LN38@SegmentDir

; 1120 :                     dir->e.seginfo->abs_frame = opndx.value;

	movzx	eax, WORD PTR opndx$[rbp-137]
	mov	rcx, QWORD PTR [rdi+96]
	mov	WORD PTR [rcx+88], ax

; 1121 :                     dir->e.seginfo->abs_offset = 0;

	mov	rax, QWORD PTR [rdi+96]
	mov	DWORD PTR [rax+96], 0

; 1122 :                 } else {

	jmp	$LN148@SegmentDir
$LN40@SegmentDir:
	mov	eax, DWORD PTR Options+144
	dec	eax
	cmp	eax, 1

; 1123 :                     EmitError( CONSTANT_EXPECTED );
; 1124 :                 }
; 1125 :             }
; 1126 :             break;
; 1127 : #if COMDATSUPP
; 1128 :         case INIT_COMBINE_COMDAT:
; 1129 :             DebugMsg1(("SegmentDir(%s): COMDAT found\n", name ));
; 1130 :             /* v2.12: COMDAT supported by OMF */
; 1131 :             //if ( Options.output_format != OFORMAT_COFF ) {
; 1132 :             if ( Options.output_format != OFORMAT_COFF && Options.output_format != OFORMAT_OMF ) {
; 1133 :                 EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, tokenarray[i].string_ptr );
; 1134 :                 i = Token_Count; /* stop further parsing of this line */
; 1135 :                 break;

	ja	$LN65@SegmentDir

; 1136 :             }
; 1137 :             i++;

	mov	ecx, DWORD PTR i$[rbp-137]
	inc	ecx

; 1138 :             if ( tokenarray[i].token != T_OP_BRACKET ) {

	movsxd	rax, ecx
	shl	rax, 5
	mov	DWORD PTR i$[rbp-137], ecx
	cmp	BYTE PTR [rax+r15], 40			; 00000028H
	je	SHORT $LN42@SegmentDir

; 1139 :                 EmitErr( EXPECTED, "(" );

	lea	rdx, OFFSET FLAT:$SG11745
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1140 :                 break;

	jmp	$LN148@SegmentDir
$LN42@SegmentDir:

; 1141 :             }
; 1142 :             i++;
; 1143 :             if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rbp-137]
	inc	ecx
	mov	BYTE PTR [rsp+32], 0
	mov	DWORD PTR i$[rbp-137], ecx
	mov	rdx, r15
	lea	rcx, QWORD PTR i$[rbp-137]
	call	EvalOperand
	cmp	eax, -1
	je	$LN148@SegmentDir

; 1144 :                 break;
; 1145 :             if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rbp-77], 0
	je	SHORT $LN44@SegmentDir

; 1146 :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 1147 :                 i = Token_Count; /* stop further parsing of this line */
; 1148 :                 break;

	jmp	$LN155@SegmentDir
$LN44@SegmentDir:

; 1149 :             }
; 1150 :             if ( opndx.value < 1 || opndx.value > 6 ) {

	mov	ecx, DWORD PTR opndx$[rbp-137]
	lea	eax, DWORD PTR [rcx-1]
	cmp	eax, 5
	ja	$LN47@SegmentDir

; 1152 :             } else {
; 1153 :                 /* if value is IMAGE_COMDAT_SELECT_ASSOCIATIVE,
; 1154 :                  * get the associated segment name argument.
; 1155 :                  */
; 1156 :                 if ( opndx.value == 5 ) {

	cmp	ecx, 5
	jne	$LN48@SegmentDir

; 1157 :                     struct asym *sym2;
; 1158 :                     if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rcx, DWORD PTR i$[rbp-137]
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+r15], 44			; 0000002cH
	je	SHORT $LN49@SegmentDir

; 1159 :                         EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos );

	mov	rdx, QWORD PTR [rax+r15+24]
	mov	ecx, 39					; 00000027H

; 1160 :                         i = Token_Count; /* stop further parsing of this line */
; 1161 :                         break;

	jmp	$LN156@SegmentDir
$LN49@SegmentDir:

; 1162 :                     }
; 1163 :                     i++;

	inc	ecx
	mov	DWORD PTR i$[rbp-137], ecx

; 1164 :                     if ( tokenarray[i].token != T_ID ) {

	movsxd	rcx, ecx
	shl	rcx, 5
	cmp	BYTE PTR [rcx+r15], 8
	je	SHORT $LN50@SegmentDir

; 1165 :                         EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rcx+r15+8]
	mov	ecx, 209				; 000000d1H

; 1166 :                         i = Token_Count; /* stop further parsing of this line */
; 1167 :                         break;

	jmp	$LN156@SegmentDir
$LN50@SegmentDir:

; 1168 :                     }
; 1169 :                     /* associated segment must be COMDAT, but not associative */
; 1170 :                     sym2 = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rcx+r15+8]
	call	SymFind

; 1171 :                     if ( sym2 == NULL ||
; 1172 :                         sym2->state != SYM_SEG ||
; 1173 :                         ((struct dsym *)sym2)->e.seginfo->comdat_selection == 0 ||

	test	rax, rax
	je	SHORT $LN53@SegmentDir
	cmp	DWORD PTR [rax+32], 3
	jne	SHORT $LN53@SegmentDir
	mov	rdx, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rdx+108]
	shr	al, 3
	and	al, 7
	je	SHORT $LN53@SegmentDir
	cmp	al, 5
	je	SHORT $LN53@SegmentDir

; 1176 :                     else
; 1177 :                         dir->e.seginfo->comdat_number = ((struct dsym *)sym2)->e.seginfo->seg_idx;

	mov	rcx, QWORD PTR [rdi+96]
	movzx	eax, WORD PTR [rdx+68]
	mov	WORD PTR [rcx+88], ax

; 1178 :                     i++;

	inc	DWORD PTR i$[rbp-137]
	jmp	SHORT $LN152@SegmentDir
$LN53@SegmentDir:

; 1174 :                         ((struct dsym *)sym2)->e.seginfo->comdat_selection == 5 )
; 1175 :                         EmitErr( INVALID_ASSOCIATED_SEGMENT, tokenarray[i].string_ptr );

	movsxd	rdx, DWORD PTR i$[rbp-137]
	mov	ecx, 25
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r15+8]
	call	EmitErr

; 1178 :                     i++;

	inc	DWORD PTR i$[rbp-137]
	jmp	SHORT $LN152@SegmentDir
$LN47@SegmentDir:

; 1151 :                 EmitErr( VALUE_NOT_WITHIN_ALLOWED_RANGE, "1-6" );

	lea	rdx, OFFSET FLAT:$SG11751
	mov	ecx, 24
	call	EmitErr
$LN152@SegmentDir:
	mov	ecx, DWORD PTR opndx$[rbp-137]
$LN48@SegmentDir:

; 1179 :                 }
; 1180 :             }
; 1181 :             if ( tokenarray[i].token != T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rbp-137]
	shl	rax, 5
	cmp	BYTE PTR [rax+r15], 41			; 00000029H
	je	SHORT $LN54@SegmentDir

; 1182 :                 EmitErr( EXPECTED, ")" );

	lea	rdx, OFFSET FLAT:$SG11759
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1183 :                 break;

	jmp	$LN148@SegmentDir
$LN54@SegmentDir:

; 1184 :             }
; 1185 :             dir->e.seginfo->comdat_selection = opndx.value;

	mov	rax, QWORD PTR [rdi+96]
	shl	cl, 3
	xor	cl, BYTE PTR [rax+108]
	and	cl, 56					; 00000038H
	xor	BYTE PTR [rax+108], cl
$LN35@SegmentDir:

; 1186 :             dir->e.seginfo->combine = type->value;

	mov	rcx, QWORD PTR [rdi+96]
	movzx	eax, BYTE PTR [rbx]
	xor	al, BYTE PTR [rcx+108]
	and	al, 7
	xor	BYTE PTR [rcx+108], al

; 1187 :             break;

	jmp	$LN148@SegmentDir
$LN55@SegmentDir:

; 1188 : #endif
; 1189 :         case INIT_OFSSIZE:
; 1190 :         case INIT_OFSSIZE_FLAT:
; 1191 :             if ( type->init == INIT_OFSSIZE_FLAT ) {

	cmp	dl, 136					; 00000088H
	jne	SHORT $LN56@SegmentDir

; 1192 :                 DefineFlatGroup();

	call	DefineFlatGroup

; 1193 : #if AMD64_SUPPORT
; 1194 :                 /* v2.09: make sure ofssize is at least USE32 for FLAT */
; 1195 :                 dir->e.seginfo->Ofssize = ( ModuleInfo.defOfssize > USE16 ? ModuleInfo.defOfssize : USE32 );

	movzx	eax, BYTE PTR ModuleInfo+405
	movzx	ecx, al
	test	al, al
	jne	SHORT $LN92@SegmentDir
	mov	ecx, 1
$LN92@SegmentDir:
	mov	rax, QWORD PTR [rdi+96]
	mov	BYTE PTR [rax+104], cl

; 1196 : #else
; 1197 :                 dir->e.seginfo->Ofssize = USE32;
; 1198 : #endif
; 1199 :                 /* put the segment into the FLAT group.
; 1200 :                  * this is not quite Masm-compatible, because trying to put
; 1201 :                  * the segment into another group will cause an error.
; 1202 :                  */
; 1203 :                 dir->e.seginfo->group = &ModuleInfo.flat_grp->sym;

	mov	rcx, QWORD PTR [rdi+96]
	mov	rax, QWORD PTR ModuleInfo+440
	mov	QWORD PTR [rcx], rax

; 1204 :             } else

	jmp	$LN148@SegmentDir
$LN56@SegmentDir:

; 1205 :                 dir->e.seginfo->Ofssize = type->value;

	mov	rcx, QWORD PTR [rdi+96]
	movzx	eax, BYTE PTR [rbx]
	mov	BYTE PTR [rcx+104], al

; 1206 :             break;

	jmp	$LN148@SegmentDir
$LN58@SegmentDir:

; 1207 : #if COFF_SUPPORT || ELF_SUPPORT || PE_SUPPORT
; 1208 :         case INIT_CHAR_INFO:
; 1209 :             dir->e.seginfo->info = TRUE; /* fixme: check that this flag isn't changed */

	mov	rax, QWORD PTR [rdi+96]
	or	BYTE PTR [rax+107], 2

; 1210 :             break;

	jmp	$LN148@SegmentDir
$LN59@SegmentDir:

; 1211 :         case INIT_CHAR:
; 1212 :             DebugMsg1(("SegmentDir(%s): characteristics found\n", name ));
; 1213 :             /* characteristics are restricted to COFF/ELF/BIN-PE */
; 1214 :             if ( Options.output_format == OFORMAT_OMF
; 1215 : #if PE_SUPPORT
; 1216 :                 || ( Options.output_format == OFORMAT_BIN && ModuleInfo.sub_format != SFORMAT_PE )

	mov	eax, DWORD PTR Options+144
	cmp	eax, 1
	je	SHORT $LN62@SegmentDir
	test	eax, eax
	jne	SHORT $LN60@SegmentDir
	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN62@SegmentDir
$LN60@SegmentDir:

; 1220 :             } else
; 1221 :                 newcharacteristics |= type->value;

	or	r13b, BYTE PTR [rbx]
	jmp	$LN148@SegmentDir
$LN62@SegmentDir:

; 1217 : #endif
; 1218 :                ) {
; 1219 :                 EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, tokenarray[i].string_ptr );

	movsxd	rdx, DWORD PTR i$[rbp-137]
	mov	ecx, 224				; 000000e0H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r15+8]
	call	EmitErr

; 1222 :             break;

	jmp	$LN148@SegmentDir
$LN63@SegmentDir:

; 1223 :         case INIT_ALIAS:
; 1224 :             DebugMsg1(("SegmentDir(%s): ALIAS found, curr value=%s\n", name, dir->e.seginfo->aliasname ? dir->e.seginfo->aliasname : "NULL" ));
; 1225 :             /* alias() is restricted to COFF/ELF/BIN-PE */
; 1226 :             if ( Options.output_format == OFORMAT_OMF
; 1227 :                 || ( Options.output_format == OFORMAT_BIN && ModuleInfo.sub_format != SFORMAT_PE )

	mov	eax, DWORD PTR Options+144
	cmp	eax, 1
	je	$LN65@SegmentDir
	test	eax, eax
	jne	SHORT $LN64@SegmentDir
	cmp	DWORD PTR ModuleInfo+372, 2
	jne	$LN65@SegmentDir
$LN64@SegmentDir:

; 1231 :                 break;
; 1232 :             }
; 1233 :             i++;

	mov	eax, DWORD PTR i$[rbp-137]
	inc	eax
	mov	DWORD PTR i$[rbp-137], eax

; 1234 :             if ( tokenarray[i].token != T_OP_BRACKET ) {

	cdqe
	shl	rax, 5
	cmp	BYTE PTR [rax+r15], 40			; 00000028H
	je	SHORT $LN66@SegmentDir

; 1235 :                 EmitErr( EXPECTED, "(" );

	lea	rdx, OFFSET FLAT:$SG11772
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1236 :                 break;

	jmp	$LN148@SegmentDir
$LN66@SegmentDir:

; 1237 :             }
; 1238 :             i++;

	mov	eax, DWORD PTR i$[rbp-137]
	inc	eax
	mov	DWORD PTR i$[rbp-137], eax

; 1239 :             if ( tokenarray[i].token != T_STRING ||

	cdqe
	shl	rax, 5
	cmp	BYTE PTR [rax+r15], 9
	jne	$LN68@SegmentDir
	movzx	eax, BYTE PTR [rax+r15+1]
	cmp	al, 34					; 00000022H
	je	SHORT $LN67@SegmentDir
	cmp	al, 39					; 00000027H
	jne	$LN68@SegmentDir
$LN67@SegmentDir:

; 1243 :                 i = Token_Count; /* stop further parsing of this line */
; 1244 :                 break;
; 1245 :             }
; 1246 :             temp = i;
; 1247 :             i++;

	mov	eax, DWORD PTR i$[rbp-137]
	movsxd	rdx, DWORD PTR i$[rbp-137]
	inc	eax
	mov	DWORD PTR i$[rbp-137], eax

; 1248 :             if ( tokenarray[i].token != T_CL_BRACKET ) {

	cdqe
	shl	rax, 5
	cmp	BYTE PTR [rax+r15], 41			; 00000029H
	je	SHORT $LN69@SegmentDir

; 1249 :                 EmitErr( EXPECTED, ")" );

	lea	rdx, OFFSET FLAT:$SG11776
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1250 :                 break;

	jmp	$LN148@SegmentDir
$LN69@SegmentDir:

; 1251 :             }
; 1252 :             /* v2.10: if segment already exists, check that old and new aliasname are equal */
; 1253 :             if ( is_old ) {

	movzx	esi, BYTE PTR is_old$1$[rbp-137]
	test	sil, sil
	je	SHORT $LN70@SegmentDir

; 1254 :                 if ( dir->e.seginfo->aliasname == NULL ||
; 1255 :                     ( tokenarray[temp].stringlen != strlen( dir->e.seginfo->aliasname ) ) ||

	mov	rax, QWORD PTR [rdi+96]
	mov	rcx, QWORD PTR [rax+96]
	test	rcx, rcx
	je	SHORT $LN73@SegmentDir
	shl	rdx, 5
	or	rax, -1
	mov	r8d, DWORD PTR [rdx+r15+16]
	npad	2
$LL137@SegmentDir:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL137@SegmentDir
	cmp	r8, rax
	jne	SHORT $LN73@SegmentDir
	mov	rdx, QWORD PTR [rdx+r15+8]
	inc	rdx
	call	memcmp
	test	eax, eax
	je	$LN2@SegmentDir
$LN73@SegmentDir:

; 1256 :                     memcmp( dir->e.seginfo->aliasname, tokenarray[temp].string_ptr + 1, tokenarray[temp].stringlen ) ) {
; 1257 :                     EmitErr( SEGDEF_CHANGED, dir->sym.name, MsgGetEx( TXT_ALIASNAME ) );

	mov	ecx, 13
	call	MsgGetEx
	mov	rdx, QWORD PTR [rdi+8]
	mov	r8, rax
	mov	ecx, 78					; 0000004eH
	call	EmitErr

; 1258 :                     break;

	jmp	SHORT $LN2@SegmentDir
$LN70@SegmentDir:

; 1259 :                 }
; 1260 :             } else {
; 1261 :                 /* v2.10: " + 1" was missing in next line */
; 1262 :                 dir->e.seginfo->aliasname = LclAlloc( tokenarray[temp].stringlen + 1 );

	mov	rbx, rdx
	shl	rbx, 5
	add	rbx, r15
	mov	ecx, DWORD PTR [rbx+16]
	inc	ecx
	call	LclAlloc
	mov	rcx, QWORD PTR [rdi+96]
	mov	QWORD PTR [rcx+96], rax

; 1263 :                 memcpy( dir->e.seginfo->aliasname, tokenarray[temp].string_ptr+1, tokenarray[temp].stringlen );

	mov	rcx, QWORD PTR [rdi+96]
	mov	rdx, QWORD PTR [rbx+8]
	mov	r8d, DWORD PTR [rbx+16]
	inc	rdx
	mov	rcx, QWORD PTR [rcx+96]
	call	memcpy

; 1264 :                 *(dir->e.seginfo->aliasname+tokenarray[temp].stringlen) = NULLC;

	mov	rax, QWORD PTR [rdi+96]
	mov	ecx, DWORD PTR [rbx+16]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rcx+rax], 0
	jmp	SHORT $LN2@SegmentDir
$LN68@SegmentDir:

; 1240 :                 ( tokenarray[i].string_delim != '"' &&
; 1241 :                 tokenarray[i].string_delim != '\'' ) ) {
; 1242 :                 EmitErr( SYNTAX_ERROR_EX, token );

	mov	rdx, r14
	mov	ecx, 209				; 000000d1H
	jmp	SHORT $LN156@SegmentDir
$LN65@SegmentDir:

; 1228 :                ) {
; 1229 :                 EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, tokenarray[i].string_ptr );

	mov	ecx, 224				; 000000e0H
$LN154@SegmentDir:
	movsxd	rdx, DWORD PTR i$[rbp-137]
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r15+8]
$LN156@SegmentDir:
	call	EmitErr
$LN155@SegmentDir:

; 1230 :                 i = Token_Count; /* stop further parsing of this line */

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rbp-137], eax
$LN148@SegmentDir:
	movzx	esi, BYTE PTR is_old$1$[rbp-137]
$LN2@SegmentDir:

; 1024 : 
; 1025 :     for( ; i < Token_Count; i++ ) {

	mov	eax, DWORD PTR i$[rbp-137]
	inc	eax
	cmp	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rbp-137], eax
	jl	$LL4@SegmentDir
	mov	r14, QWORD PTR [rsp+176]
	lea	rbx, OFFSET FLAT:__ImageBase
$LN3@SegmentDir:

; 1265 :             }
; 1266 :             DebugMsg1(("SegmentDir(%s): ALIAS argument=>%s<\n", name, dir->e.seginfo->aliasname ));
; 1267 :             break;
; 1268 : #endif
; 1269 : #ifdef DEBUG_OUT
; 1270 :         default: /* shouldn't happen */
; 1271 :             /**/myassert( 0 );
; 1272 :             break;
; 1273 : #endif
; 1274 :         }
; 1275 :     } /* end for */
; 1276 : 
; 1277 :     /* make a guess about the segment's type */
; 1278 :     if( dir->e.seginfo->segtype != SEGTYPE_CODE ) {

	mov	rdx, QWORD PTR [rdi+96]
	cmp	DWORD PTR [rdx+72], 1
	je	SHORT $LN75@SegmentDir

; 1279 :         enum seg_type res;
; 1280 : 
; 1281 :         //token = GetLname( dir->e.seginfo->class_name_idx );
; 1282 :         res = TypeFromClassName( dir, dir->e.seginfo->clsym );

	mov	rdx, QWORD PTR [rdx+80]
	mov	rcx, rdi
	call	TypeFromClassName

; 1283 :         if( res != SEGTYPE_UNDEF ) {

	test	eax, eax
	je	SHORT $LN75@SegmentDir

; 1284 :             dir->e.seginfo->segtype = res;

	mov	rcx, QWORD PTR [rdi+96]
	mov	DWORD PTR [rcx+72], eax
$LN75@SegmentDir:

; 1285 :         }
; 1286 : #if 0 /* v2.03: removed */
; 1287 :         else {
; 1288 :             res = TypeFromSegmentName( name );
; 1289 :             dir->e.seginfo->segtype = res;
; 1290 :         }
; 1291 : #endif
; 1292 :     }
; 1293 : 
; 1294 :     if( is_old ) {

	test	sil, sil
	je	SHORT $LN76@SegmentDir

; 1295 :         int txt = 0;
; 1296 : 
; 1297 :         /* Check if new definition is different from previous one */
; 1298 : 
; 1299 :         // oldobj = dir->e.seginfo->segrec;
; 1300 :         if ( oldalign    != dir->e.seginfo->alignment )

	mov	rdx, QWORD PTR [rdi+96]
	movsx	eax, BYTE PTR oldalign$[rbp-137]
	movzx	ecx, BYTE PTR [rdx+106]
	cmp	eax, ecx
	je	SHORT $LN78@SegmentDir

; 1301 :             txt = TXT_ALIGNMENT;

	mov	ecx, 8
	jmp	SHORT $LN135@SegmentDir
$LN78@SegmentDir:

; 1302 :         else if ( oldcombine  != dir->e.seginfo->combine )

	movzx	ecx, BYTE PTR [rdx+108]
	and	ecx, 7
	cmp	BYTE PTR oldcombine$[rbp-137], cl
	je	SHORT $LN80@SegmentDir

; 1303 :             txt = TXT_COMBINE;

	mov	ecx, 9
	jmp	SHORT $LN135@SegmentDir
$LN80@SegmentDir:

; 1304 :         else if ( oldOfssize  != dir->e.seginfo->Ofssize )

	movzx	eax, BYTE PTR [rdx+104]
	cmp	BYTE PTR oldOfssize$[rbp-137], al
	je	SHORT $LN82@SegmentDir

; 1305 :             txt = TXT_SEG_WORD_SIZE;

	mov	ecx, 10
	jmp	SHORT $LN135@SegmentDir
$LN82@SegmentDir:

; 1306 : #if 0 /* v2.09: removed */
; 1307 :         else if(  oldreadonly != dir->e.seginfo->readonly )
; 1308 :             /* readonly is not a true segment attribute */
; 1309 :             txt = TXT_READONLY;
; 1310 :         else if ( oldclsym != dir->e.seginfo->clsym )
; 1311 :             /* segment class check is done in SetSegmentClass() */
; 1312 :             txt = TXT_CLASS;
; 1313 : #endif
; 1314 :         else if ( newcharacteristics && ( newcharacteristics != dir->e.seginfo->characteristics ) )

	test	r13b, r13b
	je	SHORT $LN88@SegmentDir
	cmp	r13b, BYTE PTR [rdx+105]
	je	SHORT $LN87@SegmentDir

; 1315 :             txt = TXT_CHARACTERISTICS;

	mov	ecx, 12
$LN135@SegmentDir:

; 1316 : 
; 1317 :         if ( txt ) {
; 1318 :             EmitErr( SEGDEF_CHANGED, dir->sym.name, MsgGetEx( txt ) );

	call	MsgGetEx
	mov	rdx, QWORD PTR [rdi+8]
	mov	r8, rax
	mov	ecx, 78					; 0000004eH
	call	EmitErr

; 1319 :             //return( ERROR ); /* v2: display error, but continue */
; 1320 :         }
; 1321 : 
; 1322 :     } else {

	jmp	SHORT $LN87@SegmentDir
$LN76@SegmentDir:

; 1323 :         /* A new definition */
; 1324 : 
; 1325 :         //sym = &dir->sym;
; 1326 :         sym->isdefined = TRUE;

	or	BYTE PTR [rdi+40], 2

; 1327 :         sym->segment = sym;

	mov	QWORD PTR [rdi+24], rdi

; 1328 :         sym->offset = 0; /* remains 0 ( =segment's local start offset ) */

	mov	DWORD PTR [rdi+16], 0

; 1329 : #if COMDATSUPP
; 1330 :         /* no segment index for COMDAT segments in OMF! */
; 1331 :         if ( dir->e.seginfo->comdat_selection && Options.output_format == OFORMAT_OMF )

	mov	rax, QWORD PTR [rdi+96]
	test	BYTE PTR [rax+108], 56			; 00000038H
	je	SHORT $LN86@SegmentDir
	cmp	DWORD PTR Options+144, 1
	je	SHORT $LN87@SegmentDir
$LN86@SegmentDir:

; 1332 :             ;
; 1333 :         else {
; 1334 : #endif
; 1335 :             dir->e.seginfo->seg_idx = ++ModuleInfo.g.num_segs;

	mov	ecx, DWORD PTR ModuleInfo+8

; 1336 :             /* dir->e.seginfo->lname_idx = */ AddLnameItem( sym );

	mov	rdx, rdi
	inc	ecx
	mov	DWORD PTR ModuleInfo+8, ecx
	mov	rax, QWORD PTR [rdi+96]
	mov	DWORD PTR [rax+68], ecx
	lea	rcx, OFFSET FLAT:ModuleInfo+32
	call	QAddItem
$LN87@SegmentDir:

; 1337 : #if COMDATSUPP
; 1338 :         }
; 1339 : #endif
; 1340 : 
; 1341 :     }
; 1342 :     if ( newcharacteristics )

	test	r13b, r13b
	je	SHORT $LN88@SegmentDir

; 1343 :         dir->e.seginfo->characteristics = newcharacteristics;

	mov	rax, QWORD PTR [rdi+96]
	mov	BYTE PTR [rax+105], r13b
$LN88@SegmentDir:

; 1344 : 
; 1345 :     push_seg( dir ); /* set CurrSeg */

	movsxd	rdx, DWORD PTR stkindex
	cmp	edx, 20
	jl	SHORT $LN114@SegmentDir
	mov	ecx, 100				; 00000064H
	call	EmitError
	jmp	SHORT $LN113@SegmentDir
$LN114@SegmentDir:
	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR SegStack[rbx+rdx*8], rax
	inc	edx
	mov	DWORD PTR stkindex, edx
	mov	QWORD PTR ModuleInfo+432, rdi
	call	UpdateCurrSegVars
$LN113@SegmentDir:

; 1346 : 
; 1347 :     if ( ModuleInfo.list )

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN89@SegmentDir

; 1348 :         LstWrite( LSTTYPE_LABEL, 0, NULL );

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+7]
	call	LstWrite
$LN89@SegmentDir:

; 1349 : 
; 1350 :     return( SetOfssize() );

	call	SetOfssize
$LN150@SegmentDir:
	mov	rbx, QWORD PTR [rsp+248]
	mov	rdi, QWORD PTR [rsp+184]

; 1351 : }

	add	rsp, 192				; 000000c0H
	pop	r15
	pop	r13
	pop	r12
	pop	rsi
	pop	rbp
	ret	0
	npad	2
$LN139@SegmentDir:
	DD	$LN26@SegmentDir
	DD	$LN27@SegmentDir
	DD	$LN35@SegmentDir
	DD	$LN55@SegmentDir
	DD	$LN63@SegmentDir
	DD	$LN59@SegmentDir
	DD	$LN28@SegmentDir
	DD	$LN36@SegmentDir
	DD	$LN58@SegmentDir
	DD	$LN40@SegmentDir
	DD	$LN148@SegmentDir
$LN138@SegmentDir:
	DB	0
	DB	1
	DB	10
	DB	2
	DB	10
	DB	10
	DB	10
	DB	3
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	4
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	5
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	6
	DB	10
	DB	7
	DB	10
	DB	10
	DB	10
	DB	3
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	8
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	9
SegmentDir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
;	COMDAT UnlinkSeg
_TEXT	SEGMENT
dir$ = 8
UnlinkSeg PROC						; COMDAT

; 897  :     struct dsym *curr;
; 898  :     struct dsym *prev;
; 899  :     for ( curr = SymTables[TAB_SEG].head, prev = NULL; curr; prev = curr, curr = curr->next )

	mov	rax, QWORD PTR SymTables+32
	xor	edx, edx
	test	rax, rax
	je	SHORT $LN8@UnlinkSeg
	npad	2
$LL4@UnlinkSeg:

; 900  :         if ( curr == dir ) {

	cmp	rax, rcx
	je	SHORT $LN11@UnlinkSeg

; 897  :     struct dsym *curr;
; 898  :     struct dsym *prev;
; 899  :     for ( curr = SymTables[TAB_SEG].head, prev = NULL; curr; prev = curr, curr = curr->next )

	mov	rdx, rax
	mov	rax, QWORD PTR [rax+104]
	test	rax, rax
	jne	SHORT $LL4@UnlinkSeg

; 909  :                 SymTables[TAB_SEG].tail = prev;
; 910  :             break;
; 911  :         }
; 912  :     return;
; 913  : }

	ret	0
$LN11@UnlinkSeg:

; 901  :             /* if segment is first, set a new head */
; 902  :             if ( prev == NULL )
; 903  :                 SymTables[TAB_SEG].head = curr->next;

	mov	rcx, QWORD PTR [rax+104]
	test	rdx, rdx
	jne	SHORT $LN6@UnlinkSeg
	mov	QWORD PTR SymTables+32, rcx
	jmp	SHORT $LN7@UnlinkSeg
$LN6@UnlinkSeg:

; 904  :             else
; 905  :                 prev->next = curr->next;

	mov	QWORD PTR [rdx+104], rcx
$LN7@UnlinkSeg:

; 906  : 
; 907  :             /* if segment is last, set a new tail */
; 908  :             if ( curr->next == NULL )

	cmp	QWORD PTR [rax+104], 0
	mov	rcx, QWORD PTR SymTables+40
	cmove	rcx, rdx
	mov	QWORD PTR SymTables+40, rcx
$LN8@UnlinkSeg:

; 909  :                 SymTables[TAB_SEG].tail = prev;
; 910  :             break;
; 911  :         }
; 912  :     return;
; 913  : }

	ret	0
UnlinkSeg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
;	COMDAT SetCurrSeg
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
SetCurrSeg PROC						; COMDAT

; 871  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 872  :     struct asym *sym;
; 873  : 
; 874  :     sym = SymSearch( tokenarray[0].string_ptr );

	mov	rcx, QWORD PTR [rdx+8]
	mov	rdi, rdx
	call	SymFind
	mov	rbx, rax

; 875  :     DebugMsg1(("SetCurrSeg(%s) sym=%p\n", tokenarray[0].string_ptr, sym));
; 876  :     if ( sym == NULL || sym->state != SYM_SEG ) {

	test	rax, rax
	je	$LN3@SetCurrSeg
	cmp	DWORD PTR [rax+32], 3
	jne	$LN3@SetCurrSeg

; 878  :     }
; 879  :     /* v2.04: added */
; 880  :     sym->isdefined = TRUE;

	or	BYTE PTR [rax+40], 2

; 881  :     if ( CurrSeg && Options.output_format == OFORMAT_OMF ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN11@SetCurrSeg
	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN11@SetCurrSeg

; 882  :         omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 883  :         if ( Options.no_comment_data_in_code_records == FALSE )

	cmp	BYTE PTR Options+112, 0
	jne	SHORT $LN11@SetCurrSeg

; 884  :             omf_OutSelect( FALSE );

	xor	ecx, ecx
	call	omf_OutSelect
$LN11@SetCurrSeg:

; 885  :     }
; 886  :     push_seg( (struct dsym *)sym );

	movsxd	rdx, DWORD PTR stkindex
	cmp	edx, 20
	jl	SHORT $LN9@SetCurrSeg
	mov	ecx, 100				; 00000064H
	call	EmitError
	jmp	SHORT $LN8@SetCurrSeg
$LN9@SetCurrSeg:
	mov	rax, QWORD PTR ModuleInfo+432
	lea	r8, OFFSET FLAT:SegStack
	mov	QWORD PTR [r8+rdx*8], rax
	inc	edx
	mov	DWORD PTR stkindex, edx
	mov	QWORD PTR ModuleInfo+432, rbx
	call	UpdateCurrSegVars
$LN8@SetCurrSeg:

; 887  : 
; 888  :     if ( ModuleInfo.list )

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN6@SetCurrSeg

; 889  :         LstWrite( LSTTYPE_LABEL, 0, NULL );

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+7]
	call	LstWrite
$LN6@SetCurrSeg:

; 892  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 890  : 
; 891  :     return( SetOfssize() );

	jmp	SetOfssize
$LN3@SetCurrSeg:

; 877  :         return( EmitErr( SEGMENT_NOT_DEFINED, tokenarray[0].string_ptr ) );

	mov	rdx, QWORD PTR [rdi+8]
	mov	ecx, 83					; 00000053H

; 892  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 877  :         return( EmitErr( SEGMENT_NOT_DEFINED, tokenarray[0].string_ptr ) );

	jmp	EmitErr
SetCurrSeg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
EndsDir	PROC

; 846  : {

$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H

; 847  :     if( CurrStruct != NULL ) {

	cmp	QWORD PTR CurrStruct, 0
	mov	rbx, rdx
	je	SHORT $LN2@EndsDir

; 865  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 848  :         return( EndstructDirective( i, tokenarray ) );

	jmp	EndstructDirective
$LN2@EndsDir:

; 849  :     }
; 850  :     /* a label must precede ENDS */
; 851  :     if( i != 1 ) {

	cmp	ecx, 1
	je	SHORT $LN3@EndsDir

; 852  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbx+8]

; 865  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 852  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jmp	EmitErr
$LN3@EndsDir:

; 853  :     }
; 854  :     if ( Parse_Pass != PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN5@EndsDir

; 855  :         if ( ModuleInfo.list )

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN5@EndsDir

; 856  :             LstWrite( LSTTYPE_LABEL, 0, NULL );

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+7]
	call	LstWrite
$LN5@EndsDir:

; 857  :     }
; 858  :     if ( CloseSeg( tokenarray[0].string_ptr ) == ERROR )

	mov	rcx, QWORD PTR [rbx+8]
	call	CloseSeg
	cmp	eax, -1
	jne	SHORT $LN6@EndsDir

; 859  :         return( ERROR );

	or	eax, eax

; 865  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN6@EndsDir:

; 860  :     i++;
; 861  :     if ( tokenarray[i].token != T_FINAL ) {

	cmp	BYTE PTR [rbx+64], 0
	je	SHORT $LN7@EndsDir

; 862  :         EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rbx+72]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN7@EndsDir:

; 865  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 863  :     }
; 864  :     return( SetOfssize() );

	jmp	SetOfssize
EndsDir	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
;	COMDAT SetSegmentClass
_TEXT	SEGMENT
seg$ = 48
name$ = 56
SetSegmentClass PROC					; COMDAT

; 787  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 788  :     struct asym *clsym;
; 789  : 
; 790  :     clsym = CreateClassLname( name );

	mov	rcx, rdx
	call	CreateClassLname
	mov	rdx, rax

; 791  :     if( clsym == NULL ) {

	test	rax, rax
	jne	SHORT $LN2@SetSegment

; 792  :         return( ERROR );

	or	eax, -1

; 804  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@SetSegment:

; 793  :     }
; 794  : #if 0 /* v2.09: Masm allows a segment's class name to change */
; 795  :     if ( seg->e.seginfo->clsym == NULL )
; 796  :         seg->e.seginfo->clsym = clsym;
; 797  :     else if ( seg->e.seginfo->clsym != clsym ) {
; 798  :         return( EmitErr( SEGDEF_CHANGED, seg->sym.name, MsgGetEx( TXT_CLASS ) ) );
; 799  :     }
; 800  : #else
; 801  :     seg->e.seginfo->clsym = clsym;

	mov	rax, QWORD PTR [rbx+96]
	mov	QWORD PTR [rax+80], rdx

; 802  : #endif
; 803  :     return( NOT_ERROR );

	xor	eax, eax

; 804  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
SetSegmentClass ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
;	COMDAT CreateClassLname
_TEXT	SEGMENT
name$ = 48
CreateClassLname PROC					; COMDAT

; 761  : {

	mov	QWORD PTR [rsp+24], rbp
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbp, rcx

; 762  :     struct asym *sym;
; 763  :     int len = strlen( name );

	or	rdi, -1
$LL20@CreateClas:
	inc	rdi
	cmp	BYTE PTR [rdi+rcx], 0
	jne	SHORT $LL20@CreateClas

; 764  : 
; 765  :     /* max lname is 255 - this is an OMF restriction */
; 766  :     if( len > MAX_LNAME ) {

	cmp	edi, 255				; 000000ffH
	jle	SHORT $LN2@CreateClas

; 767  :         EmitError( CLASS_NAME_TOO_LONG );

	mov	ecx, 79					; 0000004fH
	call	EmitError

; 768  :         return( NULL );

	xor	eax, eax

; 780  : }

	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@CreateClas:
	mov	QWORD PTR [rsp+48], rbx

; 769  :     }
; 770  : 
; 771  :     if ( !( sym = FindClass( name, len ) ) ) {

	mov	rbx, QWORD PTR ModuleInfo+32
	mov	QWORD PTR [rsp+56], rsi
	test	rbx, rbx
	je	SHORT $LN19@CreateClas
	npad	1
$LL8@CreateClas:
	mov	rsi, QWORD PTR [rbx+8]
	cmp	DWORD PTR [rsi+32], 11
	jne	SHORT $LN6@CreateClas
	mov	rcx, QWORD PTR [rsi+8]
	mov	rdx, rbp
	movsxd	r8, edi
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN3@CreateClas
$LN6@CreateClas:
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL8@CreateClas
$LN19@CreateClas:

; 772  :         /* the classes aren't inserted into the symbol table
; 773  :          but they are in a queue */
; 774  :         sym = SymAlloc( name );

	mov	rcx, rbp
	call	SymAlloc

; 775  :         sym->state = SYM_CLASS_LNAME;
; 776  :         /* sym->class_lname_idx = */ AddLnameItem( sym ); /* index needed by OMF only */

	mov	rdx, rax
	lea	rcx, OFFSET FLAT:ModuleInfo+32
	mov	rsi, rax
	mov	DWORD PTR [rax+32], 11
	call	QAddItem
$LN3@CreateClas:

; 777  :     }
; 778  : 
; 779  :     return( sym );

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+56]

; 780  : }

	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CreateClassLname ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
;	COMDAT FindClass
_TEXT	SEGMENT
name$ = 48
len$ = 56
FindClass PROC						; COMDAT

; 742  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 743  :     struct qnode    *node;
; 744  : 
; 745  :     for( node = ModuleInfo.g.LnameQueue.head; node; node = node->next ) {

	mov	rbx, QWORD PTR ModuleInfo+32
	mov	rbp, rcx
	movsxd	rsi, edx
	test	rbx, rbx
	je	SHORT $LN12@FindClass
$LL4@FindClass:

; 746  :         struct asym *sym = node->sym;

	mov	rdi, QWORD PTR [rbx+8]

; 747  :         /* v2.09: use SymCmpFunc (optionally case-sensitive, depending on OPTION CASEMAP) */
; 748  :         //if( sym->state == SYM_CLASS_LNAME && ( _stricmp( sym->name, name ) == 0 ) )
; 749  :         if( sym->state == SYM_CLASS_LNAME && ( SymCmpFunc( sym->name, name, len ) == 0 ) )

	cmp	DWORD PTR [rdi+32], 11
	jne	SHORT $LN2@FindClass
	mov	rcx, QWORD PTR [rdi+8]
	mov	r8, rsi
	mov	rdx, rbp
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN8@FindClass
$LN2@FindClass:

; 743  :     struct qnode    *node;
; 744  : 
; 745  :     for( node = ModuleInfo.g.LnameQueue.head; node; node = node->next ) {

	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL4@FindClass
$LN12@FindClass:

; 751  :     }
; 752  :     return( NULL );

	xor	eax, eax
$LN1@FindClass:

; 753  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN8@FindClass:

; 750  :             return( sym );

	mov	rax, rdi
	jmp	SHORT $LN1@FindClass
FindClass ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
;	COMDAT CloseSeg
_TEXT	SEGMENT
name$ = 48
CloseSeg PROC						; COMDAT

; 546  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 547  :     //struct asym      *sym;
; 548  : 
; 549  :     DebugMsg1(("CloseSeg(%s) enter\n", name));
; 550  : 
; 551  :     if( CurrSeg == NULL || ( SymCmpFunc( CurrSeg->sym.name, name, CurrSeg->sym.name_size ) != 0 ) ) {

	mov	rcx, QWORD PTR ModuleInfo+432
	test	rcx, rcx
	je	SHORT $LN3@CloseSeg
	movzx	r8d, BYTE PTR [rcx+72]
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rcx+8]
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	jne	SHORT $LN3@CloseSeg

; 554  :     }
; 555  : 
; 556  :     DebugMsg1(("CloseSeg(%s): current ofs=%" I32_SPEC "X\n", name, CurrSeg->e.seginfo->current_loc));
; 557  : 
; 558  :     if ( write_to_file && ( Options.output_format == OFORMAT_OMF ) ) {

	cmp	BYTE PTR write_to_file, al
	je	SHORT $LN5@CloseSeg
	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN5@CloseSeg

; 559  : 
; 560  :         //if ( !omf_FlushCurrSeg() ) /* v2: error check is obsolete */
; 561  :         //    EmitErr( INTERNAL_ERROR, "CloseSeg", 1 ); /* coding error! */
; 562  :         omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 563  :         if ( Options.no_comment_data_in_code_records == FALSE )

	cmp	BYTE PTR Options+112, 0
	jne	SHORT $LN5@CloseSeg

; 564  :             omf_OutSelect( FALSE );

	xor	ecx, ecx
	call	omf_OutSelect
$LN5@CloseSeg:

; 565  :     }
; 566  : 
; 567  :     pop_seg();

	mov	eax, DWORD PTR stkindex
	test	eax, eax
	je	SHORT $LN8@CloseSeg
	dec	eax
	lea	rcx, OFFSET FLAT:SegStack
	mov	DWORD PTR stkindex, eax
	cdqe
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR ModuleInfo+432, rax
	call	UpdateCurrSegVars
$LN8@CloseSeg:

; 568  : 
; 569  :     return( NOT_ERROR );

	xor	eax, eax

; 570  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@CloseSeg:

; 552  :         DebugMsg(("CloseSeg(%s): nesting error, CurrSeg=%s\n", name, CurrSeg ? CurrSeg->sym.name : "(null)" ));
; 553  :         return( EmitErr( BLOCK_NESTING_ERROR, name ) );

	mov	rdx, rbx
	mov	ecx, 80					; 00000050H

; 570  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 552  :         DebugMsg(("CloseSeg(%s): nesting error, CurrSeg=%s\n", name, CurrSeg ? CurrSeg->sym.name : "(null)" ));
; 553  :         return( EmitErr( BLOCK_NESTING_ERROR, name ) );

	jmp	EmitErr
CloseSeg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
sym$ = 8
p$ = 16
UpdateWordSize PROC

; 511  :     sym->value = CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	DWORD PTR [rcx+16], eax

; 512  :     return;
; 513  : }

	ret	0
UpdateWordSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
i$ = 80
tokenarray$ = 88
GrpDir	PROC

; 399  : {

$LN58:
	push	r13
	sub	rsp, 64					; 00000040H
	mov	r13, rdx

; 400  :     char        *name;
; 401  :     struct dsym *grp;
; 402  :     struct dsym *seg;
; 403  : 
; 404  :     /* GROUP directive must be at pos 1, needs a name at pos 0 */
; 405  :     if( i != 1 ) {

	cmp	ecx, 1
	je	SHORT $LN7@GrpDir

; 406  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r13+8]

; 504  : }

	add	rsp, 64					; 00000040H
	pop	r13

; 406  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jmp	EmitErr
$LN7@GrpDir:
	mov	ecx, DWORD PTR Options+144
	lea	eax, DWORD PTR [rcx-2]
	cmp	eax, 1
	jbe	$LN9@GrpDir

; 407  :     }
; 408  :     /* GROUP isn't valid for COFF/ELF/BIN-PE */
; 409  : #if COFF_SUPPORT || ELF_SUPPORT || PE_SUPPORT
; 410  :     if ( Options.output_format == OFORMAT_COFF
; 411  : #if ELF_SUPPORT
; 412  :         || Options.output_format == OFORMAT_ELF
; 413  : #endif
; 414  : #if PE_SUPPORT
; 415  :         || ( Options.output_format == OFORMAT_BIN && ModuleInfo.sub_format == SFORMAT_PE )

	test	ecx, ecx
	jne	SHORT $LN8@GrpDir
	cmp	DWORD PTR ModuleInfo+372, 2
	je	$LN9@GrpDir
$LN8@GrpDir:

; 419  :     }
; 420  : #endif
; 421  :     grp = CreateGroup( tokenarray[0].string_ptr );

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsp+56], rdi
	call	CreateGroup
	mov	rdi, rax

; 422  :     if( grp == NULL )

	test	rax, rax
	jne	SHORT $LN10@GrpDir

; 423  :         return( ERROR );

	or	eax, -1
	mov	rdi, QWORD PTR [rsp+56]

; 504  : }

	add	rsp, 64					; 00000040H
	pop	r13
	ret	0
$LN10@GrpDir:
	mov	QWORD PTR [rsp+88], rbp

; 424  : 
; 425  :     i++; /* go past GROUP */

	mov	ebp, 2
	mov	QWORD PTR [rsp+96], rsi
	lea	rsi, QWORD PTR [r13+64]
	mov	QWORD PTR [rsp+48], r12
	xor	r12d, r12d
	mov	QWORD PTR [rsp+32], r15
	lea	r15, QWORD PTR [r13+96]
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+40], r14
$LL4@GrpDir:

; 426  : 
; 427  :     do {
; 428  : 
; 429  :         /* get segment name */
; 430  :         if ( tokenarray[i].token != T_ID ) {

	cmp	BYTE PTR [rsi], 8
	jne	$LN35@GrpDir

; 432  :         }
; 433  :         name = tokenarray[i].string_ptr;

	mov	r14, QWORD PTR [rsi+8]

; 434  :         i++;

	inc	ebp

; 435  : 
; 436  :         seg = (struct dsym *)SymSearch( name );

	mov	rcx, r14
	call	SymFind

; 437  :         if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, r12d
	mov	rbx, rax
	jne	$LN12@GrpDir

; 438  :             if( seg == NULL || seg->sym.state == SYM_UNDEFINED ) {

	test	rax, rax
	je	SHORT $LN16@GrpDir
	mov	eax, DWORD PTR [rax+32]
	test	eax, eax
	je	SHORT $LN16@GrpDir

; 443  :             } else if( seg->sym.state != SYM_SEG ) {

	cmp	eax, 3
	jne	$LN37@GrpDir

; 445  :             } else if( seg->e.seginfo->group != NULL &&
; 446  :                       /* v2.09: allow segments in FLAT magic group be moved to a "real" group */
; 447  :                       seg->e.seginfo->group != &ModuleInfo.flat_grp->sym &&

	mov	rcx, QWORD PTR [rbx+96]
	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	SHORT $LN17@GrpDir
	cmp	rax, QWORD PTR ModuleInfo+440
	je	SHORT $LN17@GrpDir
	cmp	rax, rdi
	je	SHORT $LN17@GrpDir

; 448  :                       seg->e.seginfo->group != &grp->sym ) {
; 449  :                 /* segment is in another group */
; 450  :                 DebugMsg(("GrpDir: segment >%s< is in group >%s< already\n", name, seg->e.seginfo->group->name));
; 451  :                 return( EmitErr( SEGMENT_IN_ANOTHER_GROUP, name ) );

	mov	rdx, r14
	mov	ecx, 135				; 00000087H
	jmp	$LN55@GrpDir
$LN16@GrpDir:

; 439  :                 seg = CreateSegment( seg, name, TRUE );

	mov	r8b, 1
	mov	rdx, r14
	mov	rcx, rbx
	call	CreateSegment
	mov	rbx, rax

; 440  :                 /* inherit the offset magnitude from the group */
; 441  :                 if ( grp->e.grpinfo->seglist )

	mov	rax, QWORD PTR [rdi+96]
	cmp	QWORD PTR [rax], r12
	je	SHORT $LN17@GrpDir

; 442  :                     seg->e.seginfo->Ofssize = grp->sym.Ofssize;

	mov	rcx, QWORD PTR [rbx+96]
	movzx	eax, BYTE PTR [rdi+44]
	mov	BYTE PTR [rcx+104], al
$LN17@GrpDir:

; 452  :             }
; 453  :             /* the first segment will define the group's word size */
; 454  :             if( grp->e.grpinfo->seglist == NULL ) {

	mov	rax, QWORD PTR [rdi+96]
	cmp	QWORD PTR [rax], r12

; 455  :                 grp->sym.Ofssize = seg->e.seginfo->Ofssize;

	mov	rax, QWORD PTR [rbx+96]
	movzx	ecx, BYTE PTR [rax+104]
	jne	SHORT $LN21@GrpDir
	mov	BYTE PTR [rdi+44], cl
	jmp	SHORT $LN24@GrpDir
$LN21@GrpDir:

; 456  :             } else if ( grp->sym.Ofssize != seg->e.seginfo->Ofssize ) {

	cmp	BYTE PTR [rdi+44], cl
	je	SHORT $LN24@GrpDir

; 457  :                 return( EmitErr( GROUP_SEGMENT_SIZE_CONFLICT, grp->sym.name, seg->sym.name ) );

	mov	r8, QWORD PTR [rbx+8]
	mov	ecx, 239				; 000000efH
	mov	rdx, QWORD PTR [rdi+8]
	call	EmitErr
	jmp	$LN54@GrpDir
$LN12@GrpDir:

; 458  :             }
; 459  :         } else {
; 460  :             /* v2.04: don't check the "defined" flag in passes > 1. It's for IFDEF only! */
; 461  :             //if( seg == NULL || seg->sym.state != SYM_SEG || seg->sym.defined == FALSE ) {
; 462  :             /* v2.07: check the "segment" field instead of "defined" flag! */
; 463  :             //if( seg == NULL || seg->sym.state != SYM_SEG ) {
; 464  :             if( seg == NULL || seg->sym.state != SYM_SEG || seg->sym.segment == NULL ) {

	test	rax, rax
	je	$LN25@GrpDir
	cmp	DWORD PTR [rax+32], 3
	jne	$LN25@GrpDir
	cmp	QWORD PTR [rax+24], r12
	je	$LN25@GrpDir
$LN24@GrpDir:

; 466  :             }
; 467  :         }
; 468  : 
; 469  :         /* insert segment in group if it's not there already */
; 470  :         if ( seg->e.seginfo->group == NULL ) {

	mov	rax, QWORD PTR [rbx+96]
	cmp	QWORD PTR [rax], r12
	jne	SHORT $LN28@GrpDir

; 471  :             struct seg_item    *si;
; 472  : 
; 473  :             /* set the segment's grp */
; 474  :             seg->e.seginfo->group = &grp->sym;
; 475  : 
; 476  :             si = LclAlloc( sizeof( struct seg_item ) );

	mov	ecx, 16
	mov	QWORD PTR [rax], rdi
	call	LclAlloc

; 477  :             si->seg = seg;

	mov	QWORD PTR [rax+8], rbx

; 478  :             si->next = NULL;

	mov	QWORD PTR [rax], r12

; 479  :             grp->e.grpinfo->numseg++;

	mov	rcx, QWORD PTR [rdi+96]
	inc	DWORD PTR [rcx+16]

; 480  : 
; 481  :             /* insert the segment at the end of linked list */
; 482  :             if( grp->e.grpinfo->seglist == NULL ) {

	mov	rdx, QWORD PTR [rdi+96]
	mov	rcx, QWORD PTR [rdx]
	test	rcx, rcx
	jne	SHORT $LN27@GrpDir

; 483  :                 grp->e.grpinfo->seglist = si;

	mov	QWORD PTR [rdx], rax

; 484  :             } else {

	jmp	SHORT $LN28@GrpDir
$LN27@GrpDir:

; 485  :                 struct seg_item *curr;
; 486  :                 curr = grp->e.grpinfo->seglist;
; 487  :                 while( curr->next != NULL ) {

	cmp	QWORD PTR [rcx], r12
	je	SHORT $LN6@GrpDir
$LL5@GrpDir:

; 488  :                     curr = curr->next;

	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rcx], r12
	jne	SHORT $LL5@GrpDir
$LN6@GrpDir:

; 489  :                 }
; 490  :                 curr->next = si;

	mov	QWORD PTR [rcx], rax
$LN28@GrpDir:

; 491  :             }
; 492  :         }
; 493  : 
; 494  :         if ( i < Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	ebp, eax
	jge	SHORT $LN36@GrpDir

; 495  :             if ( tokenarray[i].token != T_COMMA || tokenarray[i+1].token == T_FINAL ) {

	cmp	BYTE PTR [rsi+32], 44			; 0000002cH
	jne	SHORT $LN41@GrpDir
	cmp	BYTE PTR [r15+32], r12b
	je	SHORT $LN41@GrpDir

; 497  :             }
; 498  :             i++;

	inc	ebp
	add	rsi, 64					; 00000040H
	add	r15, 64					; 00000040H

; 499  :         }
; 500  : 
; 501  :     } while ( i < Token_Count );

	cmp	ebp, eax
	jl	$LL4@GrpDir
$LN36@GrpDir:

; 502  : 
; 503  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN54@GrpDir
$LN37@GrpDir:

; 444  :                 return( EmitErr( SEGMENT_EXPECTED, name ) );

	mov	rdx, r14
	mov	ecx, 131				; 00000083H
	jmp	SHORT $LN55@GrpDir
$LN41@GrpDir:

; 496  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rdx, ebp
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r13+24]
$LN56@GrpDir:
	mov	ecx, 209				; 000000d1H
$LN55@GrpDir:

; 465  :                 return( EmitErr( SEGMENT_NOT_DEFINED, name ) );

	call	EmitErr
$LN54@GrpDir:
	mov	r14, QWORD PTR [rsp+40]
	mov	rbx, QWORD PTR [rsp+80]
	mov	r12, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+88]
	mov	r15, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+56]

; 504  : }

	add	rsp, 64					; 00000040H
	pop	r13
	ret	0
$LN25@GrpDir:

; 465  :                 return( EmitErr( SEGMENT_NOT_DEFINED, name ) );

	mov	rdx, r14
	mov	ecx, 83					; 00000053H
	jmp	SHORT $LN55@GrpDir
$LN35@GrpDir:

; 431  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ebp
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r13+8]
	jmp	SHORT $LN56@GrpDir
$LN9@GrpDir:

; 416  : #endif
; 417  :        ) {
; 418  :         return( EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, _strupr( tokenarray[i].string_ptr ) ) );

	mov	rcx, QWORD PTR [rdx+40]
	call	_strupr
	mov	rdx, rax
	mov	ecx, 224				; 000000e0H

; 504  : }

	add	rsp, 64					; 00000040H
	pop	r13

; 416  : #endif
; 417  :        ) {
; 418  :         return( EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, _strupr( tokenarray[i].string_ptr ) ) );

	jmp	EmitErr
GrpDir	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
;	COMDAT CreateSegment
_TEXT	SEGMENT
seg$ = 48
name$ = 56
add_global$ = 64
CreateSegment PROC					; COMDAT

; 347  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 348  :     if ( seg == NULL )

	test	rcx, rcx
	jne	SHORT $LN2@CreateSegm

; 349  :         seg = ( add_global ? (struct dsym *)SymCreate( name ) : (struct dsym *)SymAlloc( name ) );

	mov	rcx, rdx
	test	r8b, r8b
	je	SHORT $LN9@CreateSegm
	call	SymCreate
	mov	rbx, rax
	jmp	SHORT $LN4@CreateSegm
$LN9@CreateSegm:
	call	SymAlloc
	mov	rbx, rax
	jmp	SHORT $LN4@CreateSegm
$LN2@CreateSegm:

; 350  :     else if ( seg->sym.state == SYM_UNDEFINED )

	cmp	DWORD PTR [rcx+32], 0
	jne	SHORT $LN4@CreateSegm

; 351  :         sym_remove_table( &SymTables[TAB_UNDEF], seg );

	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table
$LN4@CreateSegm:

; 352  : 
; 353  :     if ( seg ) {

	test	rbx, rbx
	je	SHORT $LN11@CreateSegm

; 354  :         seg->sym.state = SYM_SEG;
; 355  :         seg->e.seginfo = LclAlloc( sizeof( struct seg_info ) );

	mov	ecx, 112				; 00000070H
	mov	DWORD PTR [rbx+32], 3
	call	LclAlloc

; 356  :         memset( seg->e.seginfo, 0, sizeof( struct seg_info ) );

	xor	edx, edx
	mov	QWORD PTR [rbx+96], rax
	mov	rcx, rax
	lea	r8d, QWORD PTR [rdx+112]
	call	memset

; 357  :         seg->e.seginfo->Ofssize = ModuleInfo.defOfssize;

	movzx	eax, BYTE PTR ModuleInfo+405
	mov	rcx, QWORD PTR [rbx+96]
	mov	BYTE PTR [rcx+104], al

; 358  :         seg->e.seginfo->alignment = 4; /* this is PARA (2^4) */

	mov	rax, QWORD PTR [rbx+96]
	mov	BYTE PTR [rax+106], 4

; 359  :         seg->e.seginfo->combine = COMB_INVALID;

	mov	rax, QWORD PTR [rbx+96]
	and	BYTE PTR [rax+108], 248			; 000000f8H

; 360  :         /* null class name, in case none is mentioned */
; 361  :         //seg->e.seginfo->clsym = NULL;
; 362  :         seg->next = NULL;

	mov	QWORD PTR [rbx+104], 0

; 363  :         /* don't use sym_add_table(). Thus the "prev" member
; 364  :          * becomes free for another use.
; 365  :          */
; 366  :         if ( SymTables[TAB_SEG].head == NULL )

	cmp	QWORD PTR SymTables+32, 0
	jne	SHORT $LN6@CreateSegm

; 367  :             SymTables[TAB_SEG].head = SymTables[TAB_SEG].tail = seg;

	mov	QWORD PTR SymTables+32, rbx

; 371  :         }
; 372  :     }
; 373  :     return( seg );

	mov	rax, rbx
	mov	QWORD PTR SymTables+40, rbx

; 374  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN6@CreateSegm:

; 368  :         else {
; 369  :             SymTables[TAB_SEG].tail->next = seg;

	mov	rax, QWORD PTR SymTables+40
	mov	QWORD PTR [rax+104], rbx

; 370  :             SymTables[TAB_SEG].tail = seg;

	mov	QWORD PTR SymTables+40, rbx
$LN11@CreateSegm:

; 371  :         }
; 372  :     }
; 373  :     return( seg );

	mov	rax, rbx

; 374  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
CreateSegment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
;	COMDAT CreateGroup
_TEXT	SEGMENT
name$ = 48
CreateGroup PROC					; COMDAT

; 315  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 316  :     struct dsym    *grp;
; 317  : 
; 318  :     grp = (struct dsym *)SymSearch( name );

	call	SymFind
	mov	rbx, rax

; 319  : 
; 320  :     if( grp == NULL || grp->sym.state == SYM_UNDEFINED ) {

	test	rax, rax
	je	SHORT $LN11@CreateGrou
	mov	eax, DWORD PTR [rax+32]
	test	eax, eax
	je	SHORT $LN5@CreateGrou

; 337  :     } else if( grp->sym.state != SYM_GRP ) {

	cmp	eax, 4
	je	$LN7@CreateGrou

; 338  :         EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, rdi
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 339  :         return( NULL );

	xor	eax, eax

; 343  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN5@CreateGrou:

; 323  :         else
; 324  :             sym_remove_table( &SymTables[TAB_UNDEF], grp );

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table
	jmp	SHORT $LN6@CreateGrou
$LN11@CreateGrou:

; 321  :         if ( grp == NULL )
; 322  :             grp = (struct dsym *)SymCreate( name );

	mov	rcx, rdi
	call	SymCreate
	mov	rbx, rax
$LN6@CreateGrou:

; 325  : 
; 326  :         grp->sym.state = SYM_GRP;
; 327  :         grp->e.grpinfo = LclAlloc( sizeof( struct grp_info ) );

	mov	ecx, 24
	mov	DWORD PTR [rbx+32], 4
	call	LclAlloc

; 328  :         grp->e.grpinfo->seglist = NULL;

	xor	ecx, ecx
	mov	QWORD PTR [rbx+96], rax

; 329  :         //grp->e.grpinfo->grp_idx = 0;
; 330  :         //grp->e.grpinfo->lname_idx = 0;
; 331  :         grp->e.grpinfo->numseg = 0;
; 332  :         sym_add_table( &SymTables[TAB_GRP], grp );

	mov	rdx, rbx
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR [rbx+96]
	mov	DWORD PTR [rax+16], ecx
	lea	rcx, OFFSET FLAT:SymTables+48
	call	sym_add_table

; 333  : 
; 334  :         grp->sym.list = TRUE;
; 335  :         grp->e.grpinfo->grp_idx = ++grpdefidx;

	mov	ecx, DWORD PTR grpdefidx

; 336  :         /* grp->e.grpinfo->lname_idx = */ AddLnameItem( &grp->sym );

	mov	rdx, rbx
	mov	rax, QWORD PTR [rbx+96]
	inc	ecx
	or	BYTE PTR [rbx+41], 1
	mov	DWORD PTR grpdefidx, ecx
	mov	DWORD PTR [rax+8], ecx
	lea	rcx, OFFSET FLAT:ModuleInfo+32
	call	QAddItem
$LN7@CreateGrou:

; 340  :     }
; 341  :     grp->sym.isdefined = TRUE;

	or	BYTE PTR [rbx+40], 2

; 342  :     return( grp );

	mov	rax, rbx

; 343  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CreateGroup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
;	COMDAT pop_seg
_TEXT	SEGMENT
pop_seg	PROC						; COMDAT

; 267  :     //seg = popitem( &CurrSeg ); /* changed in v1.96 */
; 268  :     /* it's already checked that CurrSeg is != NULL, so
; 269  :      * stkindex must be > 0, but anyway ...
; 270  :      */
; 271  :     if ( stkindex ) {

	mov	eax, DWORD PTR stkindex
	test	eax, eax
	je	SHORT $LN2@pop_seg

; 272  :         stkindex--;

	dec	eax

; 273  :         CurrSeg = SegStack[stkindex];

	lea	rcx, OFFSET FLAT:SegStack
	mov	DWORD PTR stkindex, eax
	cdqe
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR ModuleInfo+432, rax

; 274  :         UpdateCurrSegVars();

	jmp	UpdateCurrSegVars
$LN2@pop_seg:

; 275  :     }
; 276  :     return;
; 277  : }

	ret	0
pop_seg	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
;	COMDAT push_seg
_TEXT	SEGMENT
seg$ = 8
push_seg PROC						; COMDAT

; 251  :     //pushitem( &CurrSeg, seg ); /* changed in v1.96 */
; 252  :     if ( stkindex >= MAX_SEG_NESTING ) {

	movsxd	rdx, DWORD PTR stkindex
	cmp	edx, 20
	jl	SHORT $LN2@push_seg

; 253  :         EmitError( NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 100				; 00000064H
	jmp	EmitError
$LN2@push_seg:

; 254  :         return;
; 255  :     }
; 256  :     SegStack[stkindex] = CurrSeg;

	mov	rax, QWORD PTR ModuleInfo+432
	lea	r9, OFFSET FLAT:SegStack
	mov	QWORD PTR [r9+rdx*8], rax

; 257  :     stkindex++;

	inc	edx
	mov	DWORD PTR stkindex, edx

; 258  :     CurrSeg = seg;

	mov	QWORD PTR ModuleInfo+432, rcx

; 259  :     UpdateCurrSegVars();

	jmp	UpdateCurrSegVars
push_seg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
;	COMDAT UpdateCurrSegVars
_TEXT	SEGMENT
UpdateCurrSegVars PROC					; COMDAT

; 220  :     struct assume_info *info;
; 221  : 
; 222  :     DebugMsg1(("UpdateCurrSegVars(%s)\n", CurrSeg ? CurrSeg->sym.name : "NULL" ));
; 223  :     info = &(SegAssumeTable[ ASSUME_CS ]);
; 224  :     if( CurrSeg == NULL ) {

	mov	rcx, QWORD PTR ModuleInfo+432
	test	rcx, rcx
	jne	SHORT $LN2@UpdateCurr

; 240  :         }
; 241  :         symCurSeg->string_ptr = CurrSeg->sym.name;

	mov	rax, QWORD PTR symCurSeg
	mov	QWORD PTR SegAssumeTable+16, rcx
	lea	rcx, OFFSET FLAT:$SG11362
	mov	WORD PTR SegAssumeTable+24, 1
	mov	QWORD PTR [rax+16], rcx

; 242  :         //symPC.segment = &CurrSeg->sym; /* v2.05: removed */
; 243  :     }
; 244  :     return;
; 245  : }

	ret	0
$LN2@UpdateCurr:

; 225  :         info->symbol = NULL;
; 226  :         info->is_flat = FALSE;
; 227  :         info->error = TRUE;
; 228  :         symCurSeg->string_ptr = "";
; 229  :         //symPC.segment = NULL; /* v2.05: removed */
; 230  :     } else {
; 231  :         info->is_flat = FALSE;
; 232  :         info->error = FALSE;

	mov	WORD PTR SegAssumeTable+24, 0

; 233  :         /* fixme: OPTION OFFSET:SEGMENT? */
; 234  :         if( CurrSeg->e.seginfo->group != NULL ) {

	mov	rax, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR [rax]
	test	rdx, rdx
	je	SHORT $LN4@UpdateCurr

; 235  :             info->symbol = CurrSeg->e.seginfo->group;
; 236  :             if ( info->symbol == &ModuleInfo.flat_grp->sym )

	cmp	rdx, QWORD PTR ModuleInfo+440
	mov	QWORD PTR SegAssumeTable+16, rdx
	jne	SHORT $LN5@UpdateCurr

; 240  :         }
; 241  :         symCurSeg->string_ptr = CurrSeg->sym.name;

	mov	rax, QWORD PTR symCurSeg
	mov	BYTE PTR SegAssumeTable+25, 1
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+16], rcx

; 242  :         //symPC.segment = &CurrSeg->sym; /* v2.05: removed */
; 243  :     }
; 244  :     return;
; 245  : }

	ret	0
$LN4@UpdateCurr:

; 237  :                 info->is_flat = TRUE;
; 238  :         } else {
; 239  :             info->symbol = &CurrSeg->sym;

	mov	QWORD PTR SegAssumeTable+16, rcx
$LN5@UpdateCurr:

; 240  :         }
; 241  :         symCurSeg->string_ptr = CurrSeg->sym.name;

	mov	rax, QWORD PTR symCurSeg
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+16], rcx

; 242  :         //symPC.segment = &CurrSeg->sym; /* v2.05: removed */
; 243  :     }
; 244  :     return;
; 245  : }

	ret	0
UpdateCurrSegVars ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
;	COMDAT FreeLnameQueue
_TEXT	SEGMENT
FreeLnameQueue PROC					; COMDAT

; 195  : {

	sub	rsp, 40					; 00000028H

; 196  :     struct qnode *curr;
; 197  :     struct qnode *next;
; 198  : 
; 199  :     DebugMsg(("FreeLnameQueue enter\n" ));
; 200  :     for( curr = ModuleInfo.g.LnameQueue.head; curr; curr = next ) {

	mov	rax, QWORD PTR ModuleInfo+32
	test	rax, rax
	je	SHORT $LN3@FreeLnameQ
	mov	QWORD PTR [rsp+32], rbx
	npad	11
$LL4@FreeLnameQ:

; 201  :         next = curr->next;
; 202  :         /* the class name symbols are not part of the
; 203  :          * symbol table and hence must be freed now.
; 204  :          */
; 205  :         if( curr->sym->state == SYM_CLASS_LNAME ) {

	mov	rcx, QWORD PTR [rax+8]
	mov	rbx, QWORD PTR [rax]
	cmp	DWORD PTR [rcx+32], 11
	jne	SHORT $LN2@FreeLnameQ

; 206  :             SymFree( curr->sym );

	call	SymFree
$LN2@FreeLnameQ:

; 196  :     struct qnode *curr;
; 197  :     struct qnode *next;
; 198  : 
; 199  :     DebugMsg(("FreeLnameQueue enter\n" ));
; 200  :     for( curr = ModuleInfo.g.LnameQueue.head; curr; curr = next ) {

	mov	rax, rbx
	test	rbx, rbx
	jne	SHORT $LL4@FreeLnameQ
	mov	rbx, QWORD PTR [rsp+32]
$LN3@FreeLnameQ:

; 207  :         }
; 208  :         LclFree( curr );
; 209  :     }
; 210  :     DebugMsg(("FreeLnameQueue exit\n" ));
; 211  : }

	add	rsp, 40					; 00000028H
	ret	0
FreeLnameQueue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
;	COMDAT AddLnameItem
_TEXT	SEGMENT
sym$ = 8
AddLnameItem PROC					; COMDAT

; 181  :     QAddItem( &ModuleInfo.g.LnameQueue, sym );

	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:ModuleInfo+32
	jmp	QAddItem
AddLnameItem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
sym$ = 8
p$ = 16
UpdateCurPC PROC

; 132  :     if( CurrStruct ) {

	cmp	QWORD PTR CurrStruct, 0
	mov	rdx, rcx
	je	SHORT $LN2@UpdateCurP

; 133  :         //symPC.segment = NULL;
; 134  :         //symPC.mem_type = MT_ABS;
; 135  :         sym->mem_type = MT_EMPTY;

	mov	DWORD PTR [rcx+36], 192			; 000000c0H

; 136  :         sym->segment = NULL; /* v2.07: needed again */

	xor	ecx, ecx
	mov	QWORD PTR [rdx+24], rcx

; 137  :         sym->offset = CurrStruct->sym.offset + (CurrStruct->next ? CurrStruct->next->sym.offset : 0);

	mov	r8, QWORD PTR CurrStruct
	mov	rax, QWORD PTR [r8+104]
	test	rax, rax
	je	SHORT $LN8@UpdateCurP
	mov	ecx, DWORD PTR [rax+16]
$LN8@UpdateCurP:
	add	ecx, DWORD PTR [r8+16]
	mov	DWORD PTR [rdx+16], ecx

; 144  : 
; 145  :     DebugMsg1(("UpdateCurPC: curr value=%" I32_SPEC "Xh\n", sym->offset ));
; 146  : }

	ret	0
$LN2@UpdateCurP:

; 138  :     } else if ( CurrSeg ) { /* v2.10: check for CurrSeg != NULL */

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN4@UpdateCurP

; 139  :         sym->mem_type = MT_NEAR;

	mov	DWORD PTR [rcx+36], 129			; 00000081H

; 140  :         sym->segment = (struct asym *)CurrSeg;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rcx+24], rax

; 141  :         sym->offset = GetCurrOffset();

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	je	SHORT $LN11@UpdateCurP
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR [rax+12]
	mov	DWORD PTR [rdx+16], ecx

; 144  : 
; 145  :     DebugMsg1(("UpdateCurPC: curr value=%" I32_SPEC "Xh\n", sym->offset ));
; 146  : }

	ret	0

; 141  :         sym->offset = GetCurrOffset();

$LN11@UpdateCurP:
	xor	ecx, ecx
	mov	DWORD PTR [rdx+16], ecx

; 144  : 
; 145  :     DebugMsg1(("UpdateCurPC: curr value=%" I32_SPEC "Xh\n", sym->offset ));
; 146  : }

	ret	0
$LN4@UpdateCurP:

; 142  :     } else
; 143  :         EmitErr( MUST_BE_IN_SEGMENT_BLOCK ); /* v2.10: added */

	mov	ecx, 82					; 00000052H
	jmp	EmitErr
UpdateCurPC ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
;	COMDAT FindToken
_TEXT	SEGMENT
token$ = 48
table$ = 56
size$ = 64
FindToken PROC						; COMDAT

; 117  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 118  :     int i;
; 119  :     for( i = 0; i < size; i++, table++ ) {

	xor	ebx, ebx
	mov	esi, r8d
	mov	rdi, rdx
	mov	rbp, rcx
	test	r8d, r8d
	jle	SHORT $LN3@FindToken
$LL4@FindToken:

; 120  :         if( _stricmp( *table, token ) == 0 ) {

	mov	rcx, QWORD PTR [rdi]
	mov	rdx, rbp
	call	_stricmp
	test	eax, eax
	je	SHORT $LN8@FindToken

; 118  :     int i;
; 119  :     for( i = 0; i < size; i++, table++ ) {

	inc	ebx
	add	rdi, 8
	cmp	ebx, esi
	jl	SHORT $LL4@FindToken
$LN3@FindToken:

; 122  :         }
; 123  :     }
; 124  :     return( -1 );  /* Not found */

	or	eax, -1
$LN1@FindToken:

; 125  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN8@FindToken:

; 121  :             return( i );

	mov	eax, ebx
	jmp	SHORT $LN1@FindToken
FindToken ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
SegmentSaveState PROC

; 1587 : {

$LN5:
	sub	rsp, 40					; 00000028H

; 1588 :     //int i;
; 1589 : 
; 1590 :     //i = stkindex;
; 1591 : 
; 1592 :     saved_CurrSeg = CurrSeg;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR saved_CurrSeg, rax

; 1593 :     saved_stkindex = stkindex;

	movsxd	rax, DWORD PTR stkindex
	mov	DWORD PTR saved_stkindex, eax

; 1594 :     if ( stkindex ) {

	test	eax, eax
	je	SHORT $LN2@SegmentSav

; 1595 :         saved_SegStack = LclAlloc( stkindex * sizeof(struct dsym *) );

	mov	rcx, rax
	shl	rcx, 3
	call	LclAlloc

; 1596 :         memcpy( saved_SegStack, &SegStack, stkindex * sizeof(struct dsym *) );

	movsxd	r8, DWORD PTR stkindex
	lea	rdx, OFFSET FLAT:SegStack
	shl	r8, 3
	mov	rcx, rax
	mov	QWORD PTR saved_SegStack, rax

; 1597 :         DebugMsg(("SegmentSaveState: saved_segStack=%X\n", saved_SegStack ));
; 1598 :     }
; 1599 : 
; 1600 :     //saved_CurSeg_name  = symCurSeg->string_ptr;
; 1601 : }

	add	rsp, 40					; 00000028H

; 1596 :         memcpy( saved_SegStack, &SegStack, stkindex * sizeof(struct dsym *) );

	jmp	memcpy
$LN2@SegmentSav:

; 1597 :         DebugMsg(("SegmentSaveState: saved_segStack=%X\n", saved_SegStack ));
; 1598 :     }
; 1599 : 
; 1600 :     //saved_CurSeg_name  = symCurSeg->string_ptr;
; 1601 : }

	add	rsp, 40					; 00000028H
	ret	0
SegmentSaveState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
dir$ = 8
DeleteGroup PROC

; 380  : #if FASTMEM==0 || defined(DEBUG_OUT)
; 381  :     struct seg_item    *curr;
; 382  :     struct seg_item    *next;
; 383  : 
; 384  :     for( curr = dir->e.grpinfo->seglist; curr; curr = next ) {
; 385  :         next = curr->next;
; 386  :         DebugMsg(("DeleteGroup(%s): free seg_item=%p\n", dir->sym.name, curr ));
; 387  :         LclFree( curr );
; 388  :     }
; 389  : #endif
; 390  :     DebugMsg(("DeleteGroup(%s): extension %p will be freed\n", dir->sym.name, dir->e.grpinfo ));
; 391  :     LclFree( dir->e.grpinfo );
; 392  :     return;
; 393  : }

	ret	0
DeleteGroup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
SegmentModuleExit PROC

; 1415 : {

$LN24:
	sub	rsp, 40					; 00000028H

; 1416 :     if ( ModuleInfo.model != MODEL_NONE )

	cmp	DWORD PTR ModuleInfo+360, 0
	je	SHORT $LN4@SegmentMod

; 1417 :         ModelSimSegmExit();

	call	ModelSimSegmExit
$LN4@SegmentMod:

; 1418 :     /* if there's still an open segment, it's an error */
; 1419 :     if ( CurrSeg ) {

	mov	rdx, QWORD PTR ModuleInfo+432
	test	rdx, rdx
	je	$LN20@SegmentMod

; 1420 :         EmitErr( BLOCK_NESTING_ERROR, CurrSeg->sym.name );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 80					; 00000050H
	mov	QWORD PTR [rsp+32], rdi
	call	EmitErr
	lea	rdi, OFFSET FLAT:SegStack
	mov	QWORD PTR [rsp+48], rbx
$LL2@SegmentMod:

; 1421 :         /* but close the still open segments anyway */
; 1422 :         while( CurrSeg && ( CloseSeg( CurrSeg->sym.name ) == NOT_ERROR ) );

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	je	SHORT $LN19@SegmentMod
	mov	rbx, QWORD PTR [rax+8]
	movzx	r8d, BYTE PTR [rax+72]
	mov	rdx, rbx
	mov	rcx, rbx
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	jne	SHORT $LN9@SegmentMod
	cmp	BYTE PTR write_to_file, al
	je	SHORT $LN11@SegmentMod
	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN11@SegmentMod
	call	omf_FlushCurrSeg
	cmp	BYTE PTR Options+112, 0
	jne	SHORT $LN11@SegmentMod
	xor	ecx, ecx
	call	omf_OutSelect
$LN11@SegmentMod:
	mov	eax, DWORD PTR stkindex
	test	eax, eax
	je	SHORT $LL2@SegmentMod
	dec	eax
	mov	DWORD PTR stkindex, eax
	cdqe
	mov	rax, QWORD PTR [rdi+rax*8]
	mov	QWORD PTR ModuleInfo+432, rax
	call	UpdateCurrSegVars
	jmp	SHORT $LL2@SegmentMod
$LN9@SegmentMod:
	mov	rdx, rbx
	mov	ecx, 80					; 00000050H
	call	EmitErr
	test	eax, eax
	je	$LL2@SegmentMod
$LN19@SegmentMod:
	mov	rbx, QWORD PTR [rsp+48]

; 1423 :     }
; 1424 : 
; 1425 :     return( NOT_ERROR );

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+32]

; 1426 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN20@SegmentMod:

; 1423 :     }
; 1424 : 
; 1425 :     return( NOT_ERROR );

	xor	eax, eax

; 1426 : }

	add	rsp, 40					; 00000028H
	ret	0
SegmentModuleExit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
DefineFlatGroup PROC

; 574  : {

$LN6:
	sub	rsp, 40					; 00000028H

; 575  :     if( ModuleInfo.flat_grp == NULL ) {

	mov	rax, QWORD PTR ModuleInfo+440
	test	rax, rax
	jne	SHORT $LN4@DefineFlat

; 576  :         /* can't fail because <FLAT> is a reserved word */
; 577  :         ModuleInfo.flat_grp = CreateGroup( "FLAT" );

	lea	rcx, OFFSET FLAT:$SG11503
	call	CreateGroup

; 578  :         ModuleInfo.flat_grp->sym.Ofssize = ModuleInfo.defOfssize;

	movzx	ecx, BYTE PTR ModuleInfo+405
	mov	QWORD PTR ModuleInfo+440, rax
	mov	BYTE PTR [rax+44], cl

; 579  :         DebugMsg1(("DefineFlatGroup(): Ofssize=%u\n", ModuleInfo.flat_grp->sym.Ofssize ));
; 580  :     }
; 581  :     ModuleInfo.flat_grp->sym.isdefined = TRUE; /* v2.09 */

	mov	rax, QWORD PTR ModuleInfo+440
$LN4@DefineFlat:
	or	BYTE PTR [rax+40], 2

; 582  : }

	add	rsp, 40					; 00000028H
	ret	0
DefineFlatGroup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
uname$ = 32
seg$ = 304
clname$ = 312
TypeFromClassName PROC

; 645  : {

$LN22:
	push	rdi
	sub	rsp, 288				; 00000120H

; 646  :     int     slen;
; 647  :     char    uname[MAX_ID_LEN+1];
; 648  : 
; 649  :     if ( seg->e.seginfo->alignment == MAX_SEGALIGNMENT )

	mov	rax, QWORD PTR [rcx+96]
	mov	rdi, rdx
	cmp	BYTE PTR [rax+106], 255			; 000000ffH
	jne	SHORT $LN4@TypeFromCl

; 650  :         return( SEGTYPE_ABS );

	mov	eax, 5

; 691  :     }
; 692  : }

	add	rsp, 288				; 00000120H
	pop	rdi
	ret	0
$LN4@TypeFromCl:

; 651  : 
; 652  :     /* v2.03: added */
; 653  :     if ( seg->e.seginfo->combine == COMB_STACK )

	movzx	eax, BYTE PTR [rax+108]
	and	al, 7
	cmp	al, 5
	jne	SHORT $LN5@TypeFromCl

; 654  :         return( SEGTYPE_STACK );

	mov	eax, 4

; 691  :     }
; 692  : }

	add	rsp, 288				; 00000120H
	pop	rdi
	ret	0
$LN5@TypeFromCl:

; 655  : 
; 656  :     if( clname == NULL )

	test	rdx, rdx
	jne	SHORT $LN6@TypeFromCl

; 657  :         return( SEGTYPE_UNDEF );

	xor	eax, eax

; 691  :     }
; 692  : }

	add	rsp, 288				; 00000120H
	pop	rdi
	ret	0
$LN6@TypeFromCl:

; 658  : 
; 659  :     if( _stricmp( clname->name, GetCodeClass() ) == 0 )

	call	GetCodeClass
	mov	rcx, QWORD PTR [rdi+8]
	mov	rdx, rax
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN7@TypeFromCl

; 660  :         return( SEGTYPE_CODE );

	mov	eax, 1

; 691  :     }
; 692  : }

	add	rsp, 288				; 00000120H
	pop	rdi
	ret	0
$LN7@TypeFromCl:

; 661  : 
; 662  :     slen = clname->name_size;
; 663  :     memcpy( uname, clname->name, clname->name_size + 1 );

	mov	rdx, QWORD PTR [rdi+8]
	lea	rcx, QWORD PTR uname$[rsp]
	mov	QWORD PTR [rsp+304], rbx
	movzx	ebx, BYTE PTR [rdi+72]
	lea	eax, DWORD PTR [rbx+1]
	movsxd	r8, eax
	call	memcpy

; 664  :     _strupr( uname );

	lea	rcx, QWORD PTR uname$[rsp]
	call	_strupr

; 665  :     switch( slen ) {

	test	ebx, ebx
	js	SHORT $LN8@TypeFromCl
	cmp	ebx, 2
	jle	$LN16@TypeFromCl
	cmp	ebx, 3
	je	$LN14@TypeFromCl
	cmp	ebx, 4
	je	SHORT $LN11@TypeFromCl
$LN8@TypeFromCl:

; 666  :     default:
; 667  :     case 5:
; 668  :         if( memcmp( uname, "CONST", 6 ) == 0 )

	mov	ecx, DWORD PTR uname$[rsp]
	cmp	ecx, DWORD PTR $SG11550
	movzx	eax, WORD PTR uname$[rsp+4]
	jne	SHORT $LN9@TypeFromCl
	cmp	ax, WORD PTR $SG11550+4
	je	SHORT $LN20@TypeFromCl
$LN9@TypeFromCl:

; 669  :             return( SEGTYPE_DATA );
; 670  :         //if( memcmp( uname, "STACK", 6 ) == 0 )
; 671  :         //    return( SEGTYPE_DATA );
; 672  :         if( memcmp( uname, "DBTYP", 6 ) == 0 )

	cmp	ecx, DWORD PTR $SG11552
	jne	SHORT $LN10@TypeFromCl
	cmp	ax, WORD PTR $SG11552+4
	je	SHORT $LN20@TypeFromCl
$LN10@TypeFromCl:

; 673  :             return( SEGTYPE_DATA );
; 674  :         if( memcmp( uname, "DBSYM", 6 ) == 0 )

	cmp	ecx, DWORD PTR $SG11554
	jne	SHORT $LN11@TypeFromCl
	cmp	ax, WORD PTR $SG11554+4
	je	SHORT $LN20@TypeFromCl
$LN11@TypeFromCl:

; 675  :             return( SEGTYPE_DATA );
; 676  :     case 4:
; 677  :         /* v2.03: changed */
; 678  :         //if( memcmp( uname , "CODE", 5 ) == 0 )
; 679  :         //    return( SEGTYPE_CODE );
; 680  :         if( memcmp( uname + slen - 4, "CODE", 4 ) == 0 )

	movsxd	rax, ebx
	lea	rcx, QWORD PTR uname$[rsp+rax-4]
	mov	eax, DWORD PTR uname$[rsp+rax-4]
	cmp	eax, DWORD PTR $SG11557
	jne	SHORT $LN13@TypeFromCl

; 681  :             return( SEGTYPE_CODE );

	mov	eax, 1
	mov	rbx, QWORD PTR [rsp+304]

; 691  :     }
; 692  : }

	add	rsp, 288				; 00000120H
	pop	rdi
	ret	0
$LN13@TypeFromCl:

; 682  :         if( memcmp( uname + slen - 4, "DATA", 4 ) == 0 )

	cmp	eax, DWORD PTR $SG11559
	jne	SHORT $LN14@TypeFromCl
$LN20@TypeFromCl:

; 683  :             return( SEGTYPE_DATA );

	mov	eax, 2
	mov	rbx, QWORD PTR [rsp+304]

; 691  :     }
; 692  : }

	add	rsp, 288				; 00000120H
	pop	rdi
	ret	0
$LN14@TypeFromCl:

; 684  :     case 3:
; 685  :         if( memcmp( uname + slen - 3, "BSS", 3 ) == 0 )

	movzx	eax, WORD PTR uname$[rsp+rbx-3]
	lea	rcx, QWORD PTR uname$[rsp+rbx-3]
	cmp	ax, WORD PTR $SG11562
	jne	SHORT $LN16@TypeFromCl
	movzx	eax, BYTE PTR [rcx+2]
	cmp	al, BYTE PTR $SG11562+2
	jne	SHORT $LN16@TypeFromCl

; 686  :             return( SEGTYPE_BSS );

	mov	eax, 3
	mov	rbx, QWORD PTR [rsp+304]

; 691  :     }
; 692  : }

	add	rsp, 288				; 00000120H
	pop	rdi
	ret	0
$LN16@TypeFromCl:

; 687  :     case 2:
; 688  :     case 1:
; 689  :     case 0:
; 690  :         return( SEGTYPE_UNDEF );

	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+304]

; 691  :     }
; 692  : }

	add	rsp, 288				; 00000120H
	pop	rdi
	ret	0
TypeFromClassName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
SetOfssize PROC

; 520  : {

$LN7:
	sub	rsp, 40					; 00000028H

; 521  :     if( CurrSeg == NULL ) {

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	jne	SHORT $LN2@SetOfssize

; 522  :         ModuleInfo.Ofssize = ModuleInfo.defOfssize;

	movzx	ecx, BYTE PTR ModuleInfo+405
	mov	BYTE PTR ModuleInfo+404, cl
$LN4@SetOfssize:

; 529  :         }
; 530  :     }
; 531  :     DebugMsg1(("SetOfssize: ModuleInfo.Ofssize=%u\n", ModuleInfo.Ofssize ));
; 532  : 
; 533  :     CurrWordSize = (2 << ModuleInfo.Ofssize);

	mov	eax, 2
	shl	al, cl

; 534  : 
; 535  : #if AMD64_SUPPORT
; 536  :     Set64Bit( ModuleInfo.Ofssize == USE64 );

	cmp	cl, 2
	mov	BYTE PTR ModuleInfo+406, al
	sete	cl
	call	Set64Bit

; 537  : #endif
; 538  : 
; 539  :     return( NOT_ERROR );

	xor	eax, eax

; 540  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@SetOfssize:

; 523  :     } else {
; 524  :         ModuleInfo.Ofssize = CurrSeg->e.seginfo->Ofssize;

	mov	rax, QWORD PTR [rax+96]

; 525  :         if( (uint_8)ModuleInfo.curr_cpu < min_cpu[ModuleInfo.Ofssize] ) {

	lea	r8, OFFSET FLAT:min_cpu
	movzx	ecx, BYTE PTR [rax+104]
	movzx	eax, BYTE PTR ModuleInfo+392
	mov	BYTE PTR ModuleInfo+404, cl
	cmp	ax, WORD PTR [r8+rcx*2]
	jae	SHORT $LN4@SetOfssize

; 526  :             DebugMsg(("SetOfssize, error: CurrSeg=%s, ModuleInfo.Ofssize=%u, curr_cpu=%X, defOfssize=%u\n",
; 527  :                       CurrSeg->sym.name, ModuleInfo.Ofssize, ModuleInfo.curr_cpu, ModuleInfo.defOfssize ));
; 528  :             return( EmitErr( INCOMPATIBLE_CPU_MODE_FOR_XXBIT_SEGMENT, 16 << ModuleInfo.Ofssize ) );

	mov	edx, 16
	shl	edx, cl
	mov	ecx, 132				; 00000084H

; 540  : }

	add	rsp, 40					; 00000028H

; 526  :             DebugMsg(("SetOfssize, error: CurrSeg=%s, ModuleInfo.Ofssize=%u, curr_cpu=%X, defOfssize=%u\n",
; 527  :                       CurrSeg->sym.name, ModuleInfo.Ofssize, ModuleInfo.curr_cpu, ModuleInfo.defOfssize ));
; 528  :             return( EmitErr( INCOMPATIBLE_CPU_MODE_FOR_XXBIT_SEGMENT, 16 << ModuleInfo.Ofssize ) );

	jmp	EmitErr
SetOfssize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
GetCurrSegAlign PROC

; 306  :     if( CurrSeg == NULL )

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	jne	SHORT $LN2@GetCurrSeg

; 311  : }

	ret	0
$LN2@GetCurrSeg:

; 307  :         return( 0 );
; 308  :     if ( CurrSeg->e.seginfo->alignment == MAX_SEGALIGNMENT ) /* ABS? */

	mov	rax, QWORD PTR [rax+96]
	movzx	ecx, BYTE PTR [rax+106]
	cmp	cl, 255					; 000000ffH
	jne	SHORT $LN3@GetCurrSeg

; 309  :         return( 0x40 ); /* assume PARA alignment for AT segments */

	mov	eax, 64					; 00000040H

; 311  : }

	ret	0
$LN3@GetCurrSeg:

; 310  :     return( 1 << CurrSeg->e.seginfo->alignment );

	mov	eax, 1
	shl	eax, cl

; 311  : }

	ret	0
GetCurrSegAlign ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
sym$ = 8
GetGroup PROC

; 597  :     struct dsym  *curr;
; 598  : 
; 599  :     curr = GetSegm( sym );

	mov	rax, QWORD PTR [rcx+24]

; 600  :     if( curr != NULL )

	test	rax, rax
	je	SHORT $LN2@GetGroup

; 601  :         return( curr->e.seginfo->group );

	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]

; 602  :     return( NULL );
; 603  : }

	ret	0
$LN2@GetGroup:
	ret	0
GetGroup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
SegmentFini PROC

; 1432 : {

$LN15:
	sub	rsp, 40					; 00000028H

; 1433 : #if FASTMEM==0
; 1434 :     struct dsym    *curr;
; 1435 : #endif
; 1436 : 
; 1437 :     DebugMsg(("SegmentFini() enter\n"));
; 1438 : #if FASTMEM==0
; 1439 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {
; 1440 :         struct fixup *fix;
; 1441 :         DebugMsg(("SegmentFini: segment %s\n", curr->sym.name ));
; 1442 :         for ( fix = curr->e.seginfo->FixupList.head; fix ; ) {
; 1443 :             struct fixup *next = fix->nextrlc;
; 1444 :             DebugMsg(("SegmentFini: free fixup [sym=%s, loc=%" I32_SPEC "X]\n", fix->sym ? fix->sym->name : "NULL", fix->location ));
; 1445 :             LclFree( fix );
; 1446 :             fix = next;
; 1447 :         }
; 1448 :     }
; 1449 : #endif
; 1450 : 
; 1451 : #if FASTPASS
; 1452 :     if ( saved_SegStack ) {
; 1453 :         LclFree( saved_SegStack );
; 1454 :     }
; 1455 : #endif
; 1456 :     FreeLnameQueue();

	mov	rax, QWORD PTR ModuleInfo+32
	test	rax, rax
	je	SHORT $LN6@SegmentFin
	mov	QWORD PTR [rsp+32], rbx
	npad	11
$LL7@SegmentFin:
	mov	rcx, QWORD PTR [rax+8]
	mov	rbx, QWORD PTR [rax]
	cmp	DWORD PTR [rcx+32], 11
	jne	SHORT $LN5@SegmentFin
	call	SymFree
$LN5@SegmentFin:
	mov	rax, rbx
	test	rbx, rbx
	jne	SHORT $LL7@SegmentFin
	mov	rbx, QWORD PTR [rsp+32]
$LN6@SegmentFin:

; 1457 :     DebugMsg(("SegmentFini() exit\n"));
; 1458 : }

	add	rsp, 40					; 00000028H
	ret	0
SegmentFini ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
pass$ = 48
SegmentInit PROC

; 1464 : {

$LN33:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1465 :     struct dsym *curr;
; 1466 :     uint_32     i;
; 1467 : #ifdef __I86__
; 1468 :     char __huge *p;
; 1469 : #else
; 1470 :     char        *p;
; 1471 : #endif
; 1472 :     //struct fixup *fix;
; 1473 : 
; 1474 :     DebugMsg(("SegmentInit(%u) enter\n", pass ));
; 1475 :     CurrSeg      = NULL;

	xor	edi, edi
	mov	ebx, ecx
	mov	QWORD PTR ModuleInfo+432, rdi

; 1476 :     stkindex     = 0;

	mov	DWORD PTR stkindex, edi

; 1477 : 
; 1478 :     if ( pass == PASS_1 ) {

	test	ecx, ecx
	jne	SHORT $LN8@SegmentIni

; 1479 :         grpdefidx   = 0;

	mov	DWORD PTR grpdefidx, edi

; 1480 :         //LnamesIdx   = 1; /* the first Lname is a null-string */
; 1481 :         //pCodeBuff = NULL;
; 1482 :         buffer_size = 0;

	mov	DWORD PTR buffer_size, edi
$LN8@SegmentIni:

; 1483 :         //flat_grp    = NULL;
; 1484 : #if FASTPASS
; 1485 : #if FASTMEM==0
; 1486 :         saved_SegStack = NULL;
; 1487 : #endif
; 1488 : #endif
; 1489 : 
; 1490 : #if 0 /* v2.03: obsolete, also belongs to simplified segment handling */
; 1491 :         /* set ModuleInfo.code_class */
; 1492 :         if( Options.code_class  )
; 1493 :             size = strlen( Options.code_class ) + 1;
; 1494 :         else
; 1495 :             size = 4 + 1;
; 1496 :         ModuleInfo.code_class = LclAlloc( size );
; 1497 :         if ( Options.code_class )
; 1498 :             strcpy( ModuleInfo.code_class, Options.code_class );
; 1499 :         else
; 1500 :             strcpy( ModuleInfo.code_class, "CODE" );
; 1501 : #endif
; 1502 :     }
; 1503 : 
; 1504 :     /*
; 1505 :      * alloc a buffer for the contents
; 1506 :      */
; 1507 : 
; 1508 :     if ( ModuleInfo.pCodeBuff == NULL && Options.output_format != OFORMAT_OMF ) {

	mov	r9, QWORD PTR ModuleInfo+448
	test	r9, r9
	jne	SHORT $LN31@SegmentIni
	cmp	DWORD PTR Options+144, 1
	je	SHORT $LN31@SegmentIni

; 1509 :         for( curr = SymTables[TAB_SEG].head, buffer_size = 0; curr; curr = curr->next ) {

	mov	rdx, QWORD PTR SymTables+32
	mov	r8d, edi
	mov	DWORD PTR buffer_size, edi
	test	rdx, rdx
	je	SHORT $LN31@SegmentIni
$LL4@SegmentIni:

; 1510 :             if ( curr->e.seginfo->internal )

	mov	rax, QWORD PTR [rdx+96]
	test	BYTE PTR [rax+107], 16
	jne	SHORT $LN2@SegmentIni

; 1511 :                 continue;
; 1512 :             if ( curr->e.seginfo->bytes_written ) {

	cmp	DWORD PTR [rax+24], edi
	je	SHORT $LN2@SegmentIni

; 1513 :                 i = curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	ecx, DWORD PTR [rdx+56]
	sub	ecx, DWORD PTR [rax+8]

; 1514 :                 /* the segment can grow in step 2-n due to forward references.
; 1515 :                  * for a quick solution just add 25% to the size if segment
; 1516 :                  * is a code segment. (v2.02: previously if was added only if
; 1517 :                  * code segment contained labels, but this isn't sufficient.)
; 1518 :                  */
; 1519 :                 //if ( curr->e.seginfo->labels ) /* v2.02: changed */
; 1520 :                 if ( curr->e.seginfo->segtype == SEGTYPE_CODE )

	cmp	DWORD PTR [rax+72], 1
	jne	SHORT $LN12@SegmentIni

; 1521 :                     i = i + (i >> 2);

	mov	eax, ecx
	shr	eax, 2
	add	ecx, eax
$LN12@SegmentIni:

; 1522 :                 DebugMsg(("SegmentInit(%u), %s: max_ofs=%" I32_SPEC "X, alloc_size=%" I32_SPEC "Xh\n", pass, curr->sym.name, curr->sym.max_offset, i ));
; 1523 :                 buffer_size += i;

	add	r8d, ecx
$LN2@SegmentIni:

; 1509 :         for( curr = SymTables[TAB_SEG].head, buffer_size = 0; curr; curr = curr->next ) {

	mov	rdx, QWORD PTR [rdx+104]
	test	rdx, rdx
	jne	SHORT $LL4@SegmentIni

; 1522 :                 DebugMsg(("SegmentInit(%u), %s: max_ofs=%" I32_SPEC "X, alloc_size=%" I32_SPEC "Xh\n", pass, curr->sym.name, curr->sym.max_offset, i ));
; 1523 :                 buffer_size += i;

	mov	DWORD PTR buffer_size, r8d

; 1524 :             }
; 1525 :         }
; 1526 :         if ( buffer_size ) {

	test	r8d, r8d
	je	SHORT $LN31@SegmentIni

; 1527 :             ModuleInfo.pCodeBuff = LclAlloc( buffer_size );

	mov	ecx, r8d
	call	LclAlloc
	mov	r9, rax
	mov	QWORD PTR ModuleInfo+448, rax
$LN31@SegmentIni:

; 1528 :             DebugMsg(("SegmentInit(%u): total buffer size=%" I32_SPEC "X, start=%p\n", pass, buffer_size, ModuleInfo.pCodeBuff ));
; 1529 :         }
; 1530 :     }
; 1531 :     /* Reset length of all segments to zero.
; 1532 :      * set start of segment buffers.
; 1533 :      */
; 1534 : #if FASTMEM==0
; 1535 :     /* fastmem clears the memory blocks, but malloc() won't */
; 1536 :     if ( ModuleInfo.pCodeBuff )
; 1537 :         memset( ModuleInfo.pCodeBuff, 0, buffer_size );
; 1538 : #endif
; 1539 :     for( curr = SymTables[TAB_SEG].head, p = ModuleInfo.pCodeBuff; curr; curr = curr->next ) {

	mov	rcx, QWORD PTR SymTables+32
	test	rcx, rcx
	je	$LN6@SegmentIni
	lea	r8, OFFSET FLAT:codebuf
	npad	8
$LL7@SegmentIni:

; 1540 :         curr->e.seginfo->current_loc = 0;

	mov	rdx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rdx+12], edi

; 1541 :         if ( curr->e.seginfo->internal )

	mov	rax, QWORD PTR [rcx+96]
	test	BYTE PTR [rax+107], 16
	jne	SHORT $LN5@SegmentIni

; 1542 :             continue;
; 1543 :         if ( curr->e.seginfo->bytes_written ) {

	cmp	DWORD PTR [rax+24], edi
	je	SHORT $LN17@SegmentIni

; 1544 :             if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN16@SegmentIni

; 1545 :                 curr->e.seginfo->CodeBuffer = codebuf;

	mov	QWORD PTR [rax+16], r8

; 1546 :                 DebugMsg(("SegmentInit(%u), %s: buffer=%p\n", pass, curr->sym.name, codebuf ));
; 1547 :             } else {

	jmp	SHORT $LN17@SegmentIni
$LN16@SegmentIni:

; 1548 :                 curr->e.seginfo->CodeBuffer = p;

	mov	QWORD PTR [rax+16], r9

; 1549 :                 i = curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR [rcx+96]
	mov	edx, DWORD PTR [rcx+56]
	sub	edx, DWORD PTR [rax+8]

; 1550 :                 DebugMsg(("SegmentInit(%u), %s: size=%" I32_SPEC "X buffer=%p\n", pass, curr->sym.name, i, p ));
; 1551 :                 p += i;

	mov	eax, edx
	add	r9, rax
$LN17@SegmentIni:

; 1552 :             }
; 1553 :         }
; 1554 :         if( curr->e.seginfo->combine != COMB_STACK ) {

	mov	rdx, QWORD PTR [rcx+96]
	movzx	eax, BYTE PTR [rdx+108]
	and	al, 7
	cmp	al, 5
	je	SHORT $LN18@SegmentIni

; 1555 :             curr->sym.max_offset = 0;

	mov	DWORD PTR [rcx+56], edi
$LN18@SegmentIni:

; 1556 :         }
; 1557 :         if ( Options.output_format == OFORMAT_OMF ) { /* v2.03: do this selectively */

	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN19@SegmentIni

; 1558 :             curr->e.seginfo->start_loc = 0;

	mov	DWORD PTR [rdx+8], edi

; 1559 :             curr->e.seginfo->data_in_code = FALSE;

	mov	rax, QWORD PTR [rcx+96]
	and	BYTE PTR [rax+107], 247			; 000000f7H
$LN19@SegmentIni:

; 1560 :         }
; 1561 :         curr->e.seginfo->bytes_written = 0;

	mov	rax, QWORD PTR [rcx+96]
	mov	DWORD PTR [rax+24], edi

; 1562 : 
; 1563 :         //if ( Options.output_format != OFORMAT_OMF ) {
; 1564 :         curr->e.seginfo->FixupList.head = NULL;

	mov	rax, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+40], rdi

; 1565 :         curr->e.seginfo->FixupList.tail = NULL;

	mov	rax, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+48], rdi
$LN5@SegmentIni:

; 1528 :             DebugMsg(("SegmentInit(%u): total buffer size=%" I32_SPEC "X, start=%p\n", pass, buffer_size, ModuleInfo.pCodeBuff ));
; 1529 :         }
; 1530 :     }
; 1531 :     /* Reset length of all segments to zero.
; 1532 :      * set start of segment buffers.
; 1533 :      */
; 1534 : #if FASTMEM==0
; 1535 :     /* fastmem clears the memory blocks, but malloc() won't */
; 1536 :     if ( ModuleInfo.pCodeBuff )
; 1537 :         memset( ModuleInfo.pCodeBuff, 0, buffer_size );
; 1538 : #endif
; 1539 :     for( curr = SymTables[TAB_SEG].head, p = ModuleInfo.pCodeBuff; curr; curr = curr->next ) {

	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL7@SegmentIni
$LN6@SegmentIni:

; 1566 :         //}
; 1567 :     }
; 1568 : 
; 1569 :     ModuleInfo.Ofssize = USE16;

	mov	BYTE PTR ModuleInfo+404, dil

; 1570 : 
; 1571 : #if FASTPASS
; 1572 :     if ( pass != PASS_1 && UseSavedState == TRUE ) {

	test	ebx, ebx
	je	SHORT $LN20@SegmentIni
	cmp	BYTE PTR UseSavedState, 1
	jne	SHORT $LN20@SegmentIni

; 1573 :         CurrSeg = saved_CurrSeg;

	mov	rax, QWORD PTR saved_CurrSeg
	mov	QWORD PTR ModuleInfo+432, rax

; 1574 :         stkindex = saved_stkindex;

	movsxd	rax, DWORD PTR saved_stkindex
	mov	DWORD PTR stkindex, eax

; 1575 :         if ( stkindex )

	test	eax, eax
	je	SHORT $LN21@SegmentIni

; 1576 :             memcpy( &SegStack, saved_SegStack, stkindex * sizeof(struct dsym *) );

	mov	rdx, QWORD PTR saved_SegStack
	lea	rcx, OFFSET FLAT:SegStack
	mov	r8, rax
	shl	r8, 3
	call	memcpy
$LN21@SegmentIni:

; 1577 : 
; 1578 :         //symCurSeg->string_ptr = saved_CurSeg_name;
; 1579 : 
; 1580 :         UpdateCurrSegVars();

	call	UpdateCurrSegVars
$LN20@SegmentIni:

; 1581 :     }
; 1582 : #endif
; 1583 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SegmentInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
sym$ = 8
GetSegIdx PROC

; 588  :     if( sym )

	test	rcx, rcx
	je	SHORT $LN2@GetSegIdx

; 589  :         return( ((struct dsym *)sym)->e.seginfo->seg_idx );

	mov	rax, QWORD PTR [rcx+96]
	mov	eax, DWORD PTR [rax+68]

; 591  : }

	ret	0
$LN2@GetSegIdx:

; 590  :     return( 0 );

	xor	eax, eax

; 591  : }

	ret	0
GetSegIdx ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
name$ = 48
classname$ = 56
alignment$ = 64
Ofssize$ = 72
add_global$ = 80
CreateIntSegment PROC

; 812  : {

$LN28:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r14
	push	r15
	sub	rsp, 32					; 00000020H

; 813  :     struct dsym *seg;
; 814  :     if ( add_global ) {

	cmp	BYTE PTR add_global$[rsp], 0
	movzx	ebp, r9b
	movzx	r14d, r8b
	mov	r15, rdx
	mov	rdi, rcx
	je	SHORT $LN2@CreateIntS

; 815  :         seg = (struct dsym *)SymSearch( name );

	call	SymFind
	mov	rbx, rax

; 816  :         if ( seg == NULL || seg->sym.state == SYM_UNDEFINED )

	test	rax, rax
	je	SHORT $LN6@CreateIntS
	mov	eax, DWORD PTR [rax+32]
	test	eax, eax
	je	SHORT $LN6@CreateIntS

; 818  :         else if ( seg->sym.state != SYM_SEG ) {

	cmp	eax, 3
	je	$LN17@CreateIntS

; 819  :             EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, rdi
	mov	ecx, 143				; 0000008fH
	call	EmitErr
$LN8@CreateIntS:

; 838  :     }
; 839  :     return( NULL );

	xor	eax, eax
$LN1@CreateIntS:

; 840  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	mov	r14, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r15
	ret	0
$LN6@CreateIntS:

; 817  :             seg = CreateSegment( seg, name, add_global );

	movzx	r8d, BYTE PTR add_global$[rsp]
	mov	rdx, rdi
	mov	rcx, rbx
	call	CreateSegment
	mov	rbx, rax

; 820  :             return( NULL );
; 821  :         }
; 822  :     } else

	jmp	SHORT $LN17@CreateIntS
$LN2@CreateIntS:

; 823  :         seg = CreateSegment( NULL, name, FALSE );

	call	SymAlloc
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN17@CreateIntS
	mov	ecx, 112				; 00000070H
	mov	DWORD PTR [rax+32], 3
	call	LclAlloc
	xor	edx, edx
	mov	QWORD PTR [rbx+96], rax
	mov	rcx, rax
	lea	r8d, QWORD PTR [rdx+112]
	call	memset
	movzx	eax, BYTE PTR ModuleInfo+405
	mov	rcx, QWORD PTR [rbx+96]
	mov	BYTE PTR [rcx+104], al
	mov	rax, QWORD PTR [rbx+96]
	mov	BYTE PTR [rax+106], 4
	mov	rax, QWORD PTR [rbx+96]
	and	BYTE PTR [rax+108], 248			; 000000f8H
	mov	QWORD PTR [rbx+104], 0
	cmp	QWORD PTR SymTables+32, 0
	jne	SHORT $LN16@CreateIntS
	mov	QWORD PTR SymTables+32, rbx
	jmp	SHORT $LN26@CreateIntS
$LN16@CreateIntS:
	mov	rax, QWORD PTR SymTables+40
	mov	QWORD PTR [rax+104], rbx
$LN26@CreateIntS:
	mov	QWORD PTR SymTables+40, rbx
$LN17@CreateIntS:

; 824  :     if ( seg ) {

	test	rbx, rbx
	je	$LN8@CreateIntS

; 825  :         /* v2.12: check 'isdefined' instead of 'lname_idx' */
; 826  :         //if( seg->e.seginfo->lname_idx == 0 ) {
; 827  :         if( seg->sym.isdefined == FALSE ) {

	test	BYTE PTR [rbx+40], 2
	jne	SHORT $LN9@CreateIntS

; 828  :             seg->e.seginfo->seg_idx = ++ModuleInfo.g.num_segs;

	mov	ecx, DWORD PTR ModuleInfo+8

; 829  :             /* seg->e.seginfo->lname_idx = */ AddLnameItem( &seg->sym );

	mov	rdx, rbx
	inc	ecx
	mov	DWORD PTR ModuleInfo+8, ecx
	mov	rax, QWORD PTR [rbx+96]
	mov	DWORD PTR [rax+68], ecx
	lea	rcx, OFFSET FLAT:ModuleInfo+32
	call	QAddItem

; 830  :             seg->sym.isdefined = TRUE; /* v2.12: added */

	or	BYTE PTR [rbx+40], 2
$LN9@CreateIntS:

; 831  :         }
; 832  :         seg->e.seginfo->internal = TRUE; /* segment has private buffer */

	mov	rax, QWORD PTR [rbx+96]

; 833  :         seg->sym.segment = &seg->sym;
; 834  :         seg->e.seginfo->alignment = alignment;
; 835  :         seg->e.seginfo->Ofssize = Ofssize;
; 836  :         SetSegmentClass( seg, classname );

	mov	rcx, r15
	or	BYTE PTR [rax+107], 16
	mov	rax, QWORD PTR [rbx+96]
	mov	QWORD PTR [rbx+24], rbx
	mov	BYTE PTR [rax+106], r14b
	mov	rax, QWORD PTR [rbx+96]
	mov	BYTE PTR [rax+104], bpl
	call	CreateClassLname
	test	rax, rax
	je	SHORT $LN23@CreateIntS
	mov	rcx, QWORD PTR [rbx+96]
	mov	QWORD PTR [rcx+80], rax
$LN23@CreateIntS:

; 837  :         return( &seg->sym );

	mov	rax, rbx
	jmp	$LN1@CreateIntS
CreateIntSegment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
GetCurrOffset PROC

; 282  :     return( CurrSeg ? CurrSeg->e.seginfo->current_loc : 0 );

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	je	SHORT $LN3@GetCurrOff
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]

; 283  : }

	ret	0
$LN3@GetCurrOff:
	ret	0
GetCurrOffset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
sym$ = 8
GetSymOfssize PROC

; 609  :     struct dsym   *curr;
; 610  : 
; 611  :     /* v2.07: MT_ABS has been removed */
; 612  :     //if ( sym->mem_type == MT_ABS )
; 613  :     //    return( USE16 );
; 614  : 
; 615  :     curr = GetSegm( sym );

	mov	rax, QWORD PTR [rcx+24]

; 616  :     if( curr == NULL ) {

	test	rax, rax
	jne	SHORT $LN2@GetSymOfss

; 617  :         /* v2.04: SYM_STACK added */
; 618  :         //if( sym->state == SYM_EXTERNAL || ( sym->state == SYM_INTERNAL && sym->isproc ) || sym->state == SYM_GRP )
; 619  :         if( sym->state == SYM_EXTERNAL )

	mov	edx, DWORD PTR [rcx+32]
	cmp	edx, 2
	jne	SHORT $LN4@GetSymOfss

; 620  :             return( sym->seg_ofssize );

	movzx	eax, BYTE PTR [rcx+47]
	and	eax, 3

; 632  : }

	ret	0
$LN4@GetSymOfss:
	lea	eax, DWORD PTR [rdx-4]
	cmp	eax, 1
	jbe	SHORT $LN6@GetSymOfss

; 623  :         if( sym->state == SYM_SEG  )

	cmp	edx, 3
	jne	SHORT $LN7@GetSymOfss

; 624  :             return( ((struct dsym *)sym)->e.seginfo->Ofssize );

	mov	rax, QWORD PTR [rcx+96]

; 628  :     } else {
; 629  :         return( curr->e.seginfo->Ofssize );

	movzx	eax, BYTE PTR [rax+104]

; 632  : }

	ret	0
$LN7@GetSymOfss:

; 625  :         /* v2.07: added */
; 626  :         if ( sym->mem_type == MT_EMPTY )

	cmp	DWORD PTR [rcx+36], 192			; 000000c0H
	jne	SHORT $LN8@GetSymOfss

; 627  :             return( USE16 );

	xor	eax, eax

; 632  : }

	ret	0
$LN8@GetSymOfss:

; 630  :     }
; 631  :     return( ModuleInfo.Ofssize );

	movzx	eax, BYTE PTR ModuleInfo+404

; 632  : }

	ret	0
$LN6@GetSymOfss:

; 621  :         if( sym->state == SYM_STACK || sym->state == SYM_GRP )
; 622  :             return( sym->Ofssize );

	movzx	eax, BYTE PTR [rcx+44]

; 632  : }

	ret	0
$LN2@GetSymOfss:

; 628  :     } else {
; 629  :         return( curr->e.seginfo->Ofssize );

	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+104]

; 632  : }

	ret	0
GetSymOfssize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
sym$ = 8
SetSymSegOfs PROC

; 637  :     sym->segment = &CurrSeg->sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rcx+24], rax

; 638  :     sym->offset = GetCurrOffset();

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	je	SHORT $LN5@SetSymSegO
	mov	rax, QWORD PTR [rax+96]
	mov	edx, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+16], edx

; 639  : }

	ret	0

; 638  :     sym->offset = GetCurrOffset();

$LN5@SetSymSegO:
	mov	DWORD PTR [rcx+16], 0

; 639  : }

	ret	0
SetSymSegOfs ENDP
_TEXT	ENDS
END
