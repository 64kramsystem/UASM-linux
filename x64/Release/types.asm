; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG11317 DB	01H DUP (?)
$SG11325 DB	01H DUP (?)
$SG11475 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
COMM	CurrStruct:QWORD
_DATA	ENDS
_BSS	SEGMENT
$SG11156 DB	01H DUP (?)
$SG11226 DB	01H DUP (?)
$SG11235 DB	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
szStructure DB	'structure', 00H
	ORG $+2
szRecord DB	'record', 00H
	ORG $+5
szNonUnique DB	'NONUNIQUE', 00H
CONST	ENDS
PUBLIC	CreateTypeSymbol
PUBLIC	SearchNameInStruct
PUBLIC	GetQualifiedType
PUBLIC	CreateStructField
PUBLIC	UpdateStructSize
PUBLIC	SetStructCurrentOffset
PUBLIC	AlignInStruct
PUBLIC	TypesInit
PUBLIC	DeleteType
PUBLIC	StructDirective
PUBLIC	EndstructDirective
PUBLIC	TypedefDirective
PUBLIC	RecordDirective
EXTRN	_stricmp:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	myltoa:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymAlloc:PROC
EXTRN	SymFree:PROC
EXTRN	SymCreate:PROC
EXTRN	SymAddGlobal:PROC
EXTRN	SymLookup:PROC
EXTRN	SymFind:PROC
EXTRN	SizeFromMemtype:PROC
EXTRN	sym_remove_table:PROC
EXTRN	ParseProc:PROC
EXTRN	CreateProc:PROC
EXTRN	EvalOperand:PROC
EXTRN	LstWrite:PROC
EXTRN	SymSimd:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SymCmpFunc:QWORD
EXTRN	SymTables:BYTE
EXTRN	SpecialTable:BYTE
_BSS	SEGMENT
	ALIGN	8

redef_struct DQ	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$CreateTypeSymbol DD imagerel $LN11
	DD	imagerel $LN11+106
	DD	imagerel $unwind$CreateTypeSymbol
$pdata$SearchNameInStruct DD imagerel $LN29
	DD	imagerel $LN29+252
	DD	imagerel $unwind$SearchNameInStruct
$pdata$GetQualifiedType DD imagerel $LN85
	DD	imagerel $LN85+307
	DD	imagerel $unwind$GetQualifiedType
$pdata$1$GetQualifiedType DD imagerel $LN85+307
	DD	imagerel $LN85+988
	DD	imagerel $chain$1$GetQualifiedType
$pdata$CreateStructField DD imagerel $LN59
	DD	imagerel $LN59+943
	DD	imagerel $unwind$CreateStructField
$pdata$StructDirective DD imagerel $LN89
	DD	imagerel $LN89+70
	DD	imagerel $unwind$StructDirective
$pdata$2$StructDirective DD imagerel $LN89+70
	DD	imagerel $LN89+142
	DD	imagerel $chain$2$StructDirective
$pdata$3$StructDirective DD imagerel $LN89+142
	DD	imagerel $LN89+172
	DD	imagerel $chain$3$StructDirective
$pdata$4$StructDirective DD imagerel $LN89+172
	DD	imagerel $LN89+1019
	DD	imagerel $chain$4$StructDirective
$pdata$EndstructDirective DD imagerel $LN61
	DD	imagerel $LN61+228
	DD	imagerel $unwind$EndstructDirective
$pdata$1$EndstructDirective DD imagerel $LN61+228
	DD	imagerel $LN61+461
	DD	imagerel $chain$1$EndstructDirective
$pdata$2$EndstructDirective DD imagerel $LN61+461
	DD	imagerel $LN61+547
	DD	imagerel $chain$2$EndstructDirective
$pdata$3$EndstructDirective DD imagerel $LN61+547
	DD	imagerel $LN61+754
	DD	imagerel $chain$3$EndstructDirective
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CheckAnonymousStruct DD imagerel CheckAnonymousStruct
	DD	imagerel CheckAnonymousStruct+306
	DD	imagerel $unwind$CheckAnonymousStruct
pdata	ENDS
pdata	SEGMENT
$pdata$TypedefDirective DD imagerel $LN69
	DD	imagerel $LN69+462
	DD	imagerel $unwind$TypedefDirective
$pdata$5$TypedefDirective DD imagerel $LN69+462
	DD	imagerel $LN69+863
	DD	imagerel $chain$5$TypedefDirective
$pdata$6$TypedefDirective DD imagerel $LN69+863
	DD	imagerel $LN69+900
	DD	imagerel $chain$6$TypedefDirective
$pdata$RecordDirective DD imagerel $LN101
	DD	imagerel $LN101+362
	DD	imagerel $unwind$RecordDirective
$pdata$5$RecordDirective DD imagerel $LN101+362
	DD	imagerel $LN101+1274
	DD	imagerel $chain$5$RecordDirective
$pdata$6$RecordDirective DD imagerel $LN101+1274
	DD	imagerel $LN101+1390
	DD	imagerel $chain$6$RecordDirective
$pdata$7$RecordDirective DD imagerel $LN101+1390
	DD	imagerel $LN101+1474
	DD	imagerel $chain$7$RecordDirective
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CheckAnonymousStruct DD 060c01H
	DD	0a340cH
	DD	07008320cH
	DD	050066007H
xdata	ENDS
xdata	SEGMENT
$unwind$CreateTypeSymbol DD 020601H
	DD	030023206H
$unwind$SearchNameInStruct DD 061101H
	DD	083411H
	DD	0700d3211H
	DD	0500b600cH
$unwind$GetQualifiedType DD 081201H
	DD	0c3412H
	DD	0f00e3212H
	DD	0d00ae00cH
	DD	06006c008H
$chain$1$GetQualifiedType DD 040a21H
	DD	0b740aH
	DD	0a5405H
	DD	imagerel $LN85
	DD	imagerel $LN85+307
	DD	imagerel $unwind$GetQualifiedType
$unwind$CreateStructField DD 0ad501H
	DD	01034d5H
	DD	0f0157219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
$unwind$StructDirective DD 040e01H
	DD	015010eH
	DD	07005e007H
$chain$2$StructDirective DD 062121H
	DD	0146421H
	DD	01b5415H
	DD	01a3408H
	DD	imagerel $LN89
	DD	imagerel $LN89+70
	DD	imagerel $unwind$StructDirective
$chain$3$StructDirective DD 021H
	DD	imagerel $LN89
	DD	imagerel $LN89+70
	DD	imagerel $unwind$StructDirective
$chain$4$StructDirective DD 060021H
	DD	0146400H
	DD	01b5400H
	DD	01a3400H
	DD	imagerel $LN89
	DD	imagerel $LN89+70
	DD	imagerel $unwind$StructDirective
$unwind$EndstructDirective DD 060f01H
	DD	0b540fH
	DD	0a340fH
	DD	0600b520fH
$chain$1$EndstructDirective DD 040a21H
	DD	09f40aH
	DD	08e405H
	DD	imagerel $LN61
	DD	imagerel $LN61+228
	DD	imagerel $unwind$EndstructDirective
$chain$2$EndstructDirective DD 020021H
	DD	09f400H
	DD	imagerel $LN61
	DD	imagerel $LN61+228
	DD	imagerel $unwind$EndstructDirective
$chain$3$EndstructDirective DD 021H
	DD	imagerel $LN61
	DD	imagerel $LN61+228
	DD	imagerel $unwind$EndstructDirective
$unwind$TypedefDirective DD 0c5401H
	DD	0be454H
	DD	0cd448H
	DD	0d7443H
	DD	0125439H
	DD	0113431H
	DD	06002d206H
$chain$5$TypedefDirective DD 020521H
	DD	0af405H
	DD	imagerel $LN69
	DD	imagerel $LN69+462
	DD	imagerel $unwind$TypedefDirective
$chain$6$TypedefDirective DD 021H
	DD	imagerel $LN69
	DD	imagerel $LN69+462
	DD	imagerel $unwind$TypedefDirective
$unwind$RecordDirective DD 085601H
	DD	0196456H
	DD	01f3447H
	DD	01b010eH
	DD	07005d007H
$chain$5$RecordDirective DD 082a21H
	DD	018c42aH
	DD	01a541bH
	DD	016f410H
	DD	017e408H
	DD	imagerel $LN101
	DD	imagerel $LN101+362
	DD	imagerel $unwind$RecordDirective
$chain$6$RecordDirective DD 020021H
	DD	016f400H
	DD	imagerel $LN101
	DD	imagerel $LN101+362
	DD	imagerel $unwind$RecordDirective
$chain$7$RecordDirective DD 021H
	DD	imagerel $LN101
	DD	imagerel $LN101+362
	DD	imagerel $unwind$RecordDirective
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
oldr$1$ = 48
opndx$ = 64
redef_err$ = 240
i$ = 240
tokenarray$ = 248
redef_err$1$ = 256
init_loc$ = 264
RecordDirective PROC

; 1116 : {

$LN101:
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	push	r13
	sub	rsp, 216				; 000000d8H

; 1117 :     char *name;
; 1118 :     struct asym *sym;
; 1119 :     struct dsym *newr;
; 1120 :     struct dsym *oldr = NULL;

	xor	r13d, r13d
	mov	rdi, rdx
	mov	QWORD PTR oldr$1$[rsp], r13

; 1121 :     struct sfield *f;
; 1122 :     int cntBits;
; 1123 :     int define;
; 1124 :     int len;
; 1125 :     int redef_err;
; 1126 :     int count;
; 1127 :     //int value;
; 1128 :     int name_loc;
; 1129 :     int init_loc;
; 1130 :     struct expr opndx;
; 1131 : 
; 1132 :     DebugMsg1(("RecordDirective(%d) enter\n", i));
; 1133 :     if ( i != 1 ) {

	cmp	ecx, 1
	je	SHORT $LN11@RecordDire

; 1134 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+8]
	call	EmitErr

; 1314 : }

	add	rsp, 216				; 000000d8H
	pop	r13
	pop	rdi
	ret	0
$LN11@RecordDire:
	mov	QWORD PTR [rsp+248], rbx

; 1135 :     }
; 1136 : 
; 1137 :     name = tokenarray[0].string_ptr;

	mov	rbx, QWORD PTR [rdx+8]

; 1138 :     sym = SymSearch( name );

	mov	rcx, rbx
	mov	QWORD PTR [rsp+200], rsi
	call	SymFind
	mov	rsi, rax

; 1139 :     if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rax, rax
	je	$LN14@RecordDire
	mov	eax, DWORD PTR [rax+32]
	test	eax, eax
	je	SHORT $LN14@RecordDire

; 1141 :     } else if ( sym->state == SYM_TYPE &&

	cmp	eax, 7
	jne	SHORT $LN15@RecordDire
	movzx	eax, BYTE PTR [rsi+66]
	test	al, 251					; 000000fbH
	jne	SHORT $LN15@RecordDire

; 1142 :                ( sym->typekind == TYPE_RECORD ||
; 1143 :                sym->typekind == TYPE_NONE ) ) {
; 1144 :         /* v2.04: allow redefinition of record and forward references.
; 1145 :          * the record redefinition may have different initial values,
; 1146 :          * but those new values are IGNORED! ( Masm bug? )
; 1147 :          */
; 1148 :         if ( Parse_Pass == PASS_1 && sym->typekind == TYPE_RECORD ) {

	cmp	DWORD PTR Parse_Pass, r13d
	jne	$LN57@RecordDire
	cmp	al, 4
	jne	$LN57@RecordDire

; 1149 :             oldr = (struct dsym *)sym;
; 1150 :             sym = CreateTypeSymbol( NULL, name, FALSE );

	mov	rcx, rbx
	mov	QWORD PTR oldr$1$[rsp], rsi
	mov	r13, rsi
	call	SymAlloc
	mov	rsi, rax
	test	rax, rax
	je	SHORT $LN64@RecordDire
	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rax+32], 7
	mov	BYTE PTR [rax+66], 0
	call	LclAlloc
	mov	QWORD PTR [rsi+96], rax
	mov	QWORD PTR [rax], 0
	mov	QWORD PTR [rax+8], 0
	mov	WORD PTR [rax+28], 0
$LN64@RecordDire:

; 1151 :             redef_err = 0;

	xor	eax, eax

; 1152 :         }
; 1153 :     } else {

	jmp	SHORT $LN96@RecordDire
$LN15@RecordDire:

; 1154 :         return( EmitErr( SYMBOL_REDEFINITION, name ) );

	mov	rdx, rbx
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN95@RecordDire
$LN14@RecordDire:

; 1140 :         sym = CreateTypeSymbol( sym, name, TRUE );

	test	rsi, rsi
	je	SHORT $LN55@RecordDire
	mov	rdx, rsi
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table
	jmp	SHORT $LN60@RecordDire
$LN55@RecordDire:
	mov	rcx, rbx
	call	SymCreate
	mov	rsi, rax
$LN60@RecordDire:
	test	rsi, rsi
	je	SHORT $LN57@RecordDire
	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rsi+32], 7
	mov	BYTE PTR [rsi+66], r13b
	call	LclAlloc
	mov	QWORD PTR [rsi+96], rax
	mov	QWORD PTR [rax], r13
	mov	QWORD PTR [rax+8], r13
	mov	WORD PTR [rax+28], r13w
$LN57@RecordDire:
	mov	eax, DWORD PTR redef_err$[rsp]
$LN96@RecordDire:

; 1155 :     }
; 1156 :     sym->isdefined = TRUE;

	or	BYTE PTR [rsi+40], 2

; 1157 : 
; 1158 :     if ( Parse_Pass > PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	mov	DWORD PTR redef_err$1$[rsp], eax
	ja	$LN50@RecordDire

; 1159 :         return( NOT_ERROR );
; 1160 : 
; 1161 :     newr = (struct dsym *)sym;
; 1162 :     newr->sym.typekind = TYPE_RECORD;

	mov	BYTE PTR [rsi+66], 4

; 1163 : 
; 1164 :     i++; /* go past RECORD */

	mov	ecx, DWORD PTR i$[rsp]

; 1165 : 
; 1166 :     cntBits = 0; /* counter for total of bits in record */

	mov	r8d, DWORD PTR ModuleInfo+496
	inc	ecx
	mov	QWORD PTR [rsp+184], r14
	mov	QWORD PTR [rsp+176], r15
	xor	r15d, r15d
	mov	QWORD PTR [rsp+208], rbp
	mov	DWORD PTR i$[rsp], ecx
	mov	QWORD PTR [rsp+192], r12
$LN97@RecordDire:

; 1167 :     /* parse bitfields */
; 1168 :     do {
; 1169 :         if ( tokenarray[i].token != T_ID ) {

	movsxd	rax, ecx
	mov	r14d, 64				; 00000040H
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 8
	jne	$LN71@RecordDire

; 1171 :             break;
; 1172 :         }
; 1173 :         len = strlen( tokenarray[i].string_ptr );

	mov	rax, QWORD PTR [rax+rdi+8]
	or	rbx, -1
$LL91@RecordDire:
	inc	rbx
	cmp	BYTE PTR [rax+rbx], 0
	jne	SHORT $LL91@RecordDire

; 1174 :         if( len > MAX_ID_LEN ) {

	cmp	ebx, 247				; 000000f7H
	jg	$LN72@RecordDire

; 1177 :         }
; 1178 :         name_loc = i;

	movsxd	rbp, ecx

; 1179 :         i++;

	inc	ecx

; 1180 :         if ( tokenarray[i].token != T_COLON ) {

	movsxd	rax, ecx
	shl	rax, 5
	mov	DWORD PTR i$[rsp], ecx
	cmp	BYTE PTR [rax+rdi], 58			; 0000003aH
	jne	$LN73@RecordDire

; 1183 :         }
; 1184 :         i++;

	inc	ecx

; 1185 :         /* get width */
; 1186 :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	BYTE PTR [rsp+32], 0
	mov	DWORD PTR i$[rsp], ecx
	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rdi
	call	EvalOperand
	cmp	eax, -1
	je	$LN3@RecordDire

; 1187 :             break;
; 1188 :         if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN24@RecordDire

; 1189 :             EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 1190 :             opndx.value = 1;

	mov	eax, 1
	mov	DWORD PTR opndx$[rsp], eax

; 1191 :         }
; 1192 :         if ( opndx.value == 0 ) {

	jmp	SHORT $LN88@RecordDire
$LN24@RecordDire:
	mov	eax, DWORD PTR opndx$[rsp]
	test	eax, eax
	je	$LN75@RecordDire
$LN88@RecordDire:

; 1195 :         } else if ( ( opndx.value + cntBits ) > MAXRECBITS ) {

	cmp	BYTE PTR ModuleInfo+404, 2
	mov	ecx, 32					; 00000020H
	cmove	ecx, r14d
	add	eax, r15d
	cmp	eax, ecx
	jg	$LN76@RecordDire

; 1198 :         }
; 1199 :         count = 0;
; 1200 :         /* is there an initializer? ('=') */
; 1201 :         if ( tokenarray[i].token == T_DIRECTIVE &&

	movsxd	rcx, DWORD PTR i$[rsp]
	xor	r12d, r12d
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 3
	jne	SHORT $LN30@RecordDire
	cmp	BYTE PTR [rax+rdi+1], 48		; 00000030H
	jne	SHORT $LN30@RecordDire

; 1202 :             tokenarray[i].dirtype == DRT_EQUALSGN ) {
; 1203 :             i++;

	inc	ecx

; 1204 :             for( init_loc = i; tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA; i++ );

	movsxd	rdx, ecx
	mov	r8d, ecx
	mov	rax, rdx
	mov	DWORD PTR i$[rsp], ecx
	shl	rax, 5
	mov	DWORD PTR init_loc$[rsp], ecx
	movzx	eax, BYTE PTR [rax+rdi]
	test	al, al
	je	$LN77@RecordDire
	npad	3
$LL7@RecordDire:
	cmp	al, 44					; 0000002cH
	je	SHORT $LN6@RecordDire
	inc	ecx
	movsxd	rax, ecx
	shl	rax, 5
	mov	DWORD PTR i$[rsp], ecx
	movzx	eax, BYTE PTR [rax+rdi]
	test	al, al
	jne	SHORT $LL7@RecordDire
$LN6@RecordDire:

; 1205 :             /* no value? */
; 1206 :             if ( init_loc == i ) {

	cmp	r8d, ecx
	je	$LN77@RecordDire

; 1209 :             }
; 1210 :             /* v2.09: initial values of record redefinitions are ignored! */
; 1211 :             if ( oldr == NULL )

	test	r13, r13
	jne	SHORT $LN30@RecordDire

; 1212 :                 count = tokenarray[i].tokpos - tokenarray[init_loc].tokpos;

	movsxd	rax, ecx
	shl	rax, 5
	shl	rdx, 5
	mov	r12d, DWORD PTR [rax+rdi+24]
	sub	r12d, DWORD PTR [rdx+rdi+24]
$LN30@RecordDire:

; 1213 :         }
; 1214 :         /* record field names are global! (Masm design flaw) */
; 1215 :         sym = SymSearch( tokenarray[name_loc].string_ptr );

	mov	r14, rbp
	shl	r14, 5
	mov	rcx, QWORD PTR [r14+rdi+8]
	call	SymFind

; 1216 :         define = TRUE;
; 1217 :         if ( oldr ) {

	mov	ecx, DWORD PTR opndx$[rsp]
	test	r13, r13
	je	SHORT $LN31@RecordDire

; 1218 :             if ( sym == NULL ||
; 1219 :                 sym->state != SYM_STRUCT_FIELD ||
; 1220 :                 sym->mem_type != MT_BITS ||

	test	rax, rax
	je	SHORT $LN34@RecordDire
	cmp	DWORD PTR [rax+32], 6
	jne	SHORT $LN34@RecordDire
	cmp	DWORD PTR [rax+36], 193			; 000000c1H
	jne	SHORT $LN34@RecordDire
	cmp	DWORD PTR [rax+56], ecx
	je	SHORT $LN89@RecordDire
$LN34@RecordDire:

; 1221 :                 sym->total_size != opndx.value ) {
; 1222 :                 EmitErr( NON_BENIGN_XXX_REDEFINITION, szRecord, tokenarray[name_loc].string_ptr );

	mov	r8, QWORD PTR [r14+rdi+8]
	lea	rdx, OFFSET FLAT:szRecord
	mov	ecx, 139				; 0000008bH
	call	EmitErr

; 1223 :                 redef_err++;

	inc	DWORD PTR redef_err$1$[rsp]

; 1224 :                 define = FALSE; /* v2.06: added */
; 1225 :             }
; 1226 :         } else {

	jmp	$LN40@RecordDire
$LN31@RecordDire:

; 1227 :             if ( sym ) {

	test	rax, rax
	jne	$LN78@RecordDire
$LN89@RecordDire:

; 1230 :             }
; 1231 :         }
; 1232 : 
; 1233 :         if ( define ) { /* v2.06: don't add field if there was an error */
; 1234 :             cntBits += opndx.value;

	add	r15d, ecx

; 1235 :             f = LclAlloc( sizeof( struct sfield ) + count );

	movsxd	r13, r12d
	lea	rcx, QWORD PTR [r13+112]
	call	LclAlloc

; 1236 :             memset( f, 0, sizeof( struct sfield ) );

	xor	edx, edx
	mov	rcx, rax
	mov	rbp, rax
	lea	r8d, QWORD PTR [rdx+112]
	call	memset

; 1237 :             f->sym.name_size = len;
; 1238 :             f->sym.name = LclAlloc( len + 1 );

	lea	ecx, DWORD PTR [rbx+1]
	mov	BYTE PTR [rbp+72], bl
	movsxd	rbx, ecx
	mov	rcx, rbx
	call	LclAlloc
	mov	QWORD PTR [rbp+8], rax

; 1239 :             memcpy( f->sym.name, tokenarray[name_loc].string_ptr, len + 1 );

	mov	r8, rbx
	mov	rdx, QWORD PTR [r14+rdi+8]
	mov	rcx, rax
	call	memcpy

; 1240 :             f->sym.list = ModuleInfo.cref;

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 12
	xor	al, BYTE PTR [rbp+41]
	and	al, 1

; 1241 :             f->sym.state = SYM_STRUCT_FIELD;

	mov	DWORD PTR [rbp+32], 6
	xor	BYTE PTR [rbp+41], al

; 1242 :             f->sym.mem_type = MT_BITS;
; 1243 :             f->sym.total_size = opndx.value;
; 1244 :             if ( !oldr ) {

	cmp	QWORD PTR oldr$1$[rsp], 0
	mov	DWORD PTR [rbp+36], 193			; 000000c1H
	mov	eax, DWORD PTR opndx$[rsp]
	mov	DWORD PTR [rbp+56], eax
	jne	SHORT $LN37@RecordDire

; 1245 :                 SymAddGlobal( &f->sym );

	mov	rcx, rbp
	call	SymAddGlobal
$LN37@RecordDire:

; 1246 :             }
; 1247 :             f->next = NULL;

	mov	QWORD PTR [rbp+96], 0

; 1248 :             //f->sym = sym;
; 1249 :             f->ivalue[0] = NULLC;

	lea	rcx, QWORD PTR [rbp+104]
	mov	BYTE PTR [rcx], 0

; 1250 :             //f->init_dir = NULL;
; 1251 :             if( newr->e.structinfo->head == NULL ) {

	mov	rax, QWORD PTR [rsi+96]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN38@RecordDire

; 1252 :                 newr->e.structinfo->head = newr->e.structinfo->tail = f;

	mov	QWORD PTR [rax+8], rbp
	mov	rax, QWORD PTR [rsi+96]
	mov	QWORD PTR [rax], rbp

; 1253 :             } else {

	jmp	SHORT $LN39@RecordDire
$LN38@RecordDire:

; 1254 :                 newr->e.structinfo->tail->next = f;

	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax+96], rbp

; 1255 :                 newr->e.structinfo->tail = f;

	mov	rax, QWORD PTR [rsi+96]
	mov	QWORD PTR [rax+8], rbp
$LN39@RecordDire:

; 1256 :             }
; 1257 :             if ( count ) {

	test	r12d, r12d
	je	SHORT $LN93@RecordDire

; 1258 :                 //f->value = LclAlloc( count + 1 );
; 1259 :                 memcpy( f->ivalue, tokenarray[init_loc].tokpos, count );

	movsxd	rdx, DWORD PTR init_loc$[rsp]
	mov	r8, r13
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+24]
	call	memcpy

; 1260 :                 f->ivalue[count] = NULLC;

	mov	BYTE PTR [rbp+r13+104], 0
$LN93@RecordDire:
	mov	r13, QWORD PTR oldr$1$[rsp]
$LN40@RecordDire:

; 1261 :             }
; 1262 :         }
; 1263 : 
; 1264 :         if ( i < Token_Count ) {

	movsxd	rcx, DWORD PTR i$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	cmp	ecx, r8d
	jge	$LN3@RecordDire

; 1265 :             if ( tokenarray[i].token != T_COMMA || tokenarray[i+1].token == T_FINAL ) {

	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 44			; 0000002cH
	jne	SHORT $LN79@RecordDire
	lea	rax, QWORD PTR [rcx+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 0
	je	SHORT $LN79@RecordDire

; 1267 :                 break;
; 1268 :             }
; 1269 :             i++;

	inc	ecx
	mov	DWORD PTR i$[rsp], ecx

; 1270 :         }
; 1271 : 
; 1272 :     } while ( i < Token_Count );

	cmp	ecx, r8d
	jge	$LN3@RecordDire
	jmp	$LN97@RecordDire
$LN77@RecordDire:

; 1207 :                 EmitErr( SYNTAX_ERROR_EX, tokenarray[name_loc].tokpos );

	mov	rdx, rbp
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+24]

; 1208 :                 break;

	jmp	SHORT $LN98@RecordDire
$LN79@RecordDire:

; 1266 :                 EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );

	mov	rdx, rcx
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+24]
	jmp	SHORT $LN98@RecordDire
$LN78@RecordDire:

; 1228 :                 EmitErr( SYMBOL_REDEFINITION, sym->name );

	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH

; 1229 :                 break;

	jmp	SHORT $LN99@RecordDire
$LN76@RecordDire:

; 1196 :             EmitErr( TOO_MANY_BITS_IN_RECORD, tokenarray[name_loc].string_ptr );

	mov	rdx, rbp
	mov	ecx, 140				; 0000008cH
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+8]

; 1197 :             break;

	jmp	SHORT $LN99@RecordDire
$LN75@RecordDire:

; 1193 :             EmitErr( TOO_FEW_BITS_IN_RECORD, tokenarray[name_loc].string_ptr );

	mov	rdx, rbp
	mov	ecx, 35					; 00000023H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+8]

; 1194 :             break;

	jmp	SHORT $LN99@RecordDire
$LN73@RecordDire:

; 1181 :             EmitError( COLON_EXPECTED );

	mov	ecx, 84					; 00000054H
	call	EmitError

; 1182 :             break;

	jmp	SHORT $LN3@RecordDire
$LN72@RecordDire:

; 1175 :             EmitError( IDENTIFIER_TOO_LONG );

	mov	ecx, 70					; 00000046H
	call	EmitError

; 1176 :             break;

	jmp	SHORT $LN3@RecordDire
$LN71@RecordDire:

; 1170 :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	movsxd	rdx, ecx
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+8]
$LN98@RecordDire:
	mov	ecx, 209				; 000000d1H
$LN99@RecordDire:
	call	EmitErr
$LN3@RecordDire:
	mov	r14, QWORD PTR [rsp+184]
	mov	r12, QWORD PTR [rsp+192]
	mov	rbp, QWORD PTR [rsp+208]

; 1273 : 
; 1274 :     /* now calc size in bytes and set the bit positions */
; 1275 : 
; 1276 :     if ( cntBits > 16 ) {

	cmp	r15d, 16
	jle	SHORT $LN44@RecordDire

; 1277 : #if AMD64_SUPPORT
; 1278 :         if ( cntBits > 32 ) {

	cmp	r15d, 32				; 00000020H
	jle	SHORT $LN46@RecordDire

; 1279 :             newr->sym.total_size = sizeof( uint_64 );

	mov	DWORD PTR [rsi+56], 8

; 1280 :             newr->sym.mem_type = MT_QWORD;

	mov	DWORD PTR [rsi+36], 7

; 1281 :         } else {

	jmp	SHORT $LN49@RecordDire
$LN46@RecordDire:

; 1282 : #endif
; 1283 :             newr->sym.total_size = sizeof( uint_32 );

	mov	DWORD PTR [rsi+56], 4

; 1284 :             newr->sym.mem_type = MT_DWORD;

	mov	DWORD PTR [rsi+36], 3

; 1285 : #if AMD64_SUPPORT
; 1286 :         }

	jmp	SHORT $LN49@RecordDire
$LN44@RecordDire:

; 1287 : #endif
; 1288 :     } else if ( cntBits > 8 ) {

	cmp	r15d, 8
	jle	SHORT $LN48@RecordDire

; 1289 :         newr->sym.total_size = sizeof( uint_16 );

	mov	DWORD PTR [rsi+56], 2

; 1290 :         newr->sym.mem_type = MT_WORD;

	mov	DWORD PTR [rsi+36], 1

; 1291 :     } else {

	jmp	SHORT $LN49@RecordDire
$LN48@RecordDire:

; 1292 :         newr->sym.total_size = sizeof( uint_8 );

	mov	DWORD PTR [rsi+56], 1

; 1293 :         newr->sym.mem_type = MT_BYTE;

	mov	DWORD PTR [rsi+36], 0
$LN49@RecordDire:

; 1294 :     }
; 1295 :     /* if the BYTE/WORD/DWORD isn't used fully, shift bits to the right! */
; 1296 :     // cntBits = dir->sym.total_size * 8;
; 1297 : 
; 1298 :     /* set the bit position */
; 1299 :     for ( f = newr->e.structinfo->head; f; f = f->next ) {

	mov	rax, QWORD PTR [rsi+96]
	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN9@RecordDire
$LL10@RecordDire:

; 1300 :         cntBits = cntBits - f->sym.total_size;

	sub	r15d, DWORD PTR [rcx+56]

; 1301 :         f->sym.offset = cntBits;

	mov	DWORD PTR [rcx+16], r15d
	mov	rcx, QWORD PTR [rcx+96]
	test	rcx, rcx
	jne	SHORT $LL10@RecordDire
$LN9@RecordDire:
	mov	r15, QWORD PTR [rsp+176]

; 1302 :     }
; 1303 :     if ( oldr ) {

	test	r13, r13
	je	SHORT $LN50@RecordDire

; 1304 :         if ( redef_err > 0 ||

	mov	eax, DWORD PTR redef_err$1$[rsp]
	test	eax, eax
	jg	SHORT $LN52@RecordDire
	mov	rdx, r13
	mov	rcx, rsi
	call	AreStructsEqual
	test	al, al
	jne	SHORT $LN51@RecordDire
$LN52@RecordDire:

; 1305 :             AreStructsEqual( newr, oldr ) == FALSE )
; 1306 :             EmitErr( NON_BENIGN_XXX_REDEFINITION, szRecord, newr->sym.name );

	mov	r8, QWORD PTR [rsi+8]
	lea	rdx, OFFSET FLAT:szRecord
	mov	ecx, 139				; 0000008bH
	call	EmitErr
$LN51@RecordDire:

; 1307 :         /* record can be freed, because the record's fields are global items.
; 1308 :          * And initial values of the new definition are ignored!
; 1309 :          */
; 1310 :         SymFree( (struct asym *)newr );

	mov	rcx, rsi
	call	SymFree
$LN50@RecordDire:

; 1311 :     }
; 1312 :     DebugMsg(("RecordDirective(%s) exit, no error\n", name ));
; 1313 :     return( NOT_ERROR );

	xor	eax, eax
$LN95@RecordDire:
	mov	rbx, QWORD PTR [rsp+248]
	mov	rsi, QWORD PTR [rsp+200]

; 1314 : }

	add	rsp, 216				; 000000d8H
	pop	r13
	pop	rdi
	ret	0
RecordDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
ti$ = 48
i$ = 128
tokenarray$ = 136
TypedefDirective PROC

; 969  : {

$LN69:
	push	rsi
	sub	rsp, 112				; 00000070H
	mov	rsi, rdx

; 970  :     struct asym         *sym;
; 971  :     char                *name;
; 972  :     struct qualified_type ti;
; 973  : 
; 974  :     DebugMsg1(("TypedefDirective(%d) enter\n", i));
; 975  : 
; 976  :     if( i != 1 ) {

	cmp	ecx, 1
	je	SHORT $LN8@TypedefDir

; 977  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+8]

; 1106 : }

	add	rsp, 112				; 00000070H
	pop	rsi

; 977  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jmp	EmitErr
$LN8@TypedefDir:
	mov	QWORD PTR [rsp+136], rbx
	mov	QWORD PTR [rsp+144], rbp

; 978  :     }
; 979  :     name = tokenarray[0].string_ptr;
; 980  : 
; 981  :     i++; /* go past TYPEDEF */

	mov	ebp, 2
	mov	QWORD PTR [rsp+104], rdi
	mov	QWORD PTR [rsp+96], r13
	mov	r13, QWORD PTR [rdx+8]

; 982  : 
; 983  :     sym = SymSearch( name );

	mov	rcx, r13
	mov	QWORD PTR [rsp+88], r14
	mov	DWORD PTR i$[rsp], ebp
	call	SymFind

; 984  :     if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	xor	r14d, r14d
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN11@TypedefDir
	mov	eax, DWORD PTR [rax+32]
	test	eax, eax
	je	SHORT $LN11@TypedefDir

; 987  :             return( ERROR );
; 988  : #if TYPEOPT
; 989  :         /* release the structinfo data extension */
; 990  :         LclFree( ((struct dsym *)sym)->e.structinfo );
; 991  :         ((struct dsym *)sym)->e.structinfo = NULL;
; 992  : #endif
; 993  :     } else {
; 994  :         /* MASM allows to have the TYPEDEF included multiple times */
; 995  :         /* but the types must be identical! */
; 996  :         if ( ( sym->state != SYM_TYPE ) ||

	cmp	eax, 7
	jne	SHORT $LN14@TypedefDir
	movzx	eax, BYTE PTR [rbx+66]
	cmp	al, 3
	je	SHORT $LN12@TypedefDir
	test	al, al
	je	SHORT $LN12@TypedefDir
$LN14@TypedefDir:

; 997  :             ( sym->typekind != TYPE_TYPEDEF &&
; 998  :              sym->typekind != TYPE_NONE ) ) {
; 999  :             return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN64@TypedefDir
$LN11@TypedefDir:

; 985  :         sym = CreateTypeSymbol( sym, name, TRUE );

	mov	rdi, rbx
	test	rbx, rbx
	je	SHORT $LN43@TypedefDir
	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table
	jmp	SHORT $LN48@TypedefDir
$LN43@TypedefDir:
	mov	rcx, r13
	call	SymCreate
	mov	rdi, rax
$LN48@TypedefDir:
	test	rdi, rdi
	je	SHORT $LN45@TypedefDir
	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rdi+32], 7
	mov	BYTE PTR [rdi+66], r14b
	call	LclAlloc
	mov	QWORD PTR [rdi+96], rax
	mov	QWORD PTR [rax], r14
	mov	QWORD PTR [rax+8], r14
	mov	WORD PTR [rax+28], r14w
$LN45@TypedefDir:
	mov	rbx, rdi

; 986  :         if ( sym == NULL )

	test	rdi, rdi
	je	$LN67@TypedefDir
$LN12@TypedefDir:

; 1000 :         }
; 1001 :     }
; 1002 : 
; 1003 :     sym->isdefined = TRUE;

	or	BYTE PTR [rbx+40], bpl

; 1004 :     if ( Parse_Pass > PASS_1 )

	cmp	DWORD PTR Parse_Pass, r14d
	ja	$LN66@TypedefDir

; 1005 :         return( NOT_ERROR );
; 1006 :     sym->typekind = TYPE_TYPEDEF;

	mov	BYTE PTR [rbx+66], 3

; 1007 : 
; 1008 :     /* PROTO is special */
; 1009 :     if ( tokenarray[i].token == T_DIRECTIVE && tokenarray[i].tokval == T_PROTO ) {

	movzx	eax, BYTE PTR [rsi+64]
	cmp	al, 3
	jne	$LN16@TypedefDir
	cmp	DWORD PTR [rsi+80], 432			; 000001b0H
	jne	$LN16@TypedefDir

; 1010 :         struct dsym *proto;  /* create a PROTOtype item without name */
; 1011 :         /* v2.04: added check if prototype is set already */
; 1012 :         if ( sym->target_type == NULL && sym->mem_type == MT_EMPTY ) {

	mov	rdi, QWORD PTR [rbx+48]
	test	rdi, rdi
	jne	SHORT $LN17@TypedefDir
	cmp	DWORD PTR [rbx+36], 192			; 000000c0H
	jne	SHORT $LN17@TypedefDir

; 1013 :             proto = (struct dsym *)CreateProc( NULL, "", SYM_TYPE );

	lea	r8d, QWORD PTR [rdi+7]
	xor	ecx, ecx
	lea	rdx, OFFSET FLAT:$SG11475
	call	CreateProc
	mov	rdi, rax
	jmp	SHORT $LN20@TypedefDir
$LN17@TypedefDir:

; 1014 :             DebugMsg1(("TypedefDirective PROTO, created new unnamed prototype %p\n", proto ));
; 1015 :         } else if ( sym->mem_type == MT_PROC ) {

	cmp	DWORD PTR [rbx+36], 128			; 00000080H
	jne	SHORT $LN19@TypedefDir
$LN20@TypedefDir:

; 1019 :         }
; 1020 :         i++;
; 1021 :         DebugMsg1(("TypedefDirective PROTO, call ParseProc(sym=%p i=%d, 0)\n", proto, i));
; 1022 :         if( ParseProc( proto, i, tokenarray, FALSE, ModuleInfo.langtype ) == ERROR )

	mov	eax, DWORD PTR ModuleInfo+364
	xor	r9d, r9d
	mov	r8, rsi
	mov	DWORD PTR [rsp+32], eax
	mov	rcx, rdi
	lea	edx, QWORD PTR [r9+3]
	call	ParseProc
	cmp	eax, -1
	jne	SHORT $LN21@TypedefDir
$LN67@TypedefDir:

; 1023 :             return ( ERROR );

	or	eax, -1
	jmp	$LN64@TypedefDir
$LN21@TypedefDir:

; 1024 :         DebugMsg1(("TypedefDirective PROTO, ParseProc() returned status ok\n"));
; 1025 :         sym->mem_type = MT_PROC;

	mov	DWORD PTR [rbx+36], 128			; 00000080H

; 1026 :         /* v2.11: member isproc was set inside ParseProc() */
; 1027 :         //proto->sym.isproc = TRUE; /* v2.05: added */
; 1028 :         sym->Ofssize = proto->sym.seg_ofssize;

	movzx	ecx, BYTE PTR [rdi+47]
	and	cl, 3

; 1029 :         /* v2.03: set value of field total_size (previously was 0) */
; 1030 :         sym->total_size = ( 2 << sym->Ofssize );

	shl	ebp, cl
	mov	DWORD PTR [rbx+56], ebp
	mov	BYTE PTR [rbx+44], cl

; 1031 :         if( proto->sym.mem_type != MT_NEAR ) {

	cmp	DWORD PTR [rdi+36], 129			; 00000081H
	je	SHORT $LN22@TypedefDir

; 1032 :             sym->isfar = TRUE; /* v2.04: added */

	or	BYTE PTR [rbx+47], 16

; 1033 :             sym->total_size += 2;

	add	DWORD PTR [rbx+56], 2
$LN22@TypedefDir:

; 1034 :         }
; 1035 :         sym->target_type = (struct asym *)proto;

	mov	QWORD PTR [rbx+48], rdi
$LN66@TypedefDir:

; 1036 :         DebugMsg1(("TypedefDirective(%s) ok, mem_type=%Xh, ofssize=%u\n", sym->name, sym->mem_type, sym->Ofssize ));
; 1037 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN64@TypedefDir
$LN19@TypedefDir:

; 1016 :             proto = (struct dsym *)sym->target_type;
; 1017 :         } else {
; 1018 :             return( EmitErr( SYMBOL_TYPE_CONFLICT, sym->name ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 136				; 00000088H
	call	EmitErr
	jmp	$LN64@TypedefDir
$LN16@TypedefDir:

; 1038 :     }
; 1039 :     ti.size = 0;
; 1040 :     ti.is_ptr = 0;
; 1041 :     ti.is_far = FALSE;
; 1042 :     ti.mem_type = MT_EMPTY;
; 1043 :     ti.ptr_memtype = MT_EMPTY;
; 1044 :     ti.symtype = NULL;
; 1045 :     ti.Ofssize = ModuleInfo.Ofssize;

	movzx	edi, BYTE PTR ModuleInfo+404
	mov	r10d, 192				; 000000c0H
	xor	r8b, r8b
	mov	QWORD PTR [rsp+80], r15
	mov	DWORD PTR ti$[rsp], r14d
	mov	r9, r14
	mov	WORD PTR ti$[rsp+20], r14w
	movzx	r15d, dil
	mov	DWORD PTR ti$[rsp+16], r10d
	mov	DWORD PTR ti$[rsp+24], r10d
	mov	QWORD PTR ti$[rsp+8], r14
	mov	BYTE PTR ti$[rsp+22], dil

; 1046 : 
; 1047 :     /* "empty" type is ok for TYPEDEF */
; 1048 :     if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_COMMA )

	test	al, al
	je	SHORT $LN25@TypedefDir
	cmp	al, 44					; 0000002cH
	je	SHORT $LN25@TypedefDir

; 1049 :         ;
; 1050 :     else if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rsp]
	mov	rdx, rsi
	lea	rcx, QWORD PTR i$[rsp]
	call	GetQualifiedType
	cmp	eax, -1
	jne	SHORT $LN57@TypedefDir

; 1051 :         return( ERROR );

	or	eax, eax
	jmp	$LN65@TypedefDir
$LN57@TypedefDir:
	mov	ebp, DWORD PTR i$[rsp]
	movzx	r15d, BYTE PTR ti$[rsp+22]
	movzx	r8d, BYTE PTR ti$[rsp+21]
	mov	r10d, DWORD PTR ti$[rsp+16]
	mov	r9, QWORD PTR ti$[rsp+8]
	mov	r14d, DWORD PTR ti$[rsp]
	movzx	edi, BYTE PTR ModuleInfo+404
$LN25@TypedefDir:

; 1052 : 
; 1053 :     /* if type did exist already, check for type conflicts
; 1054 :      * v2.05: this code has been rewritten */
; 1055 :     if ( sym->mem_type != MT_EMPTY ) {

	cmp	DWORD PTR [rbx+36], 192			; 000000c0H
	je	SHORT $LN28@TypedefDir

; 1056 :         struct asym *to;
; 1057 :         struct asym *tn;
; 1058 :         char oo;
; 1059 :         char on;
; 1060 :         for( tn = ti.symtype; tn && tn->type; tn = tn->type );

	mov	rdx, r9
	test	r9, r9
	je	SHORT $LN58@TypedefDir
	npad	4
$LL4@TypedefDir:
	mov	rax, QWORD PTR [rdx+80]
	test	rax, rax
	je	SHORT $LN58@TypedefDir
	mov	rdx, rax
	jmp	SHORT $LL4@TypedefDir
$LN58@TypedefDir:

; 1061 :         to = ( sym->mem_type == MT_TYPE ) ? sym->type : sym->target_type;

	cmp	DWORD PTR [rbx+36], 196			; 000000c4H
	jne	SHORT $LN36@TypedefDir
	mov	rcx, QWORD PTR [rbx+80]
	jmp	SHORT $LN37@TypedefDir
$LN36@TypedefDir:
	mov	rcx, QWORD PTR [rbx+48]
$LN37@TypedefDir:

; 1062 :         for( ; to && to->type; to = to->type );

	test	rcx, rcx
	je	SHORT $LN59@TypedefDir
$LL7@TypedefDir:
	mov	rax, QWORD PTR [rcx+80]
	test	rax, rax
	je	SHORT $LN59@TypedefDir
	mov	rcx, rax
	jmp	SHORT $LL7@TypedefDir
$LN59@TypedefDir:

; 1063 :         oo = ( sym->Ofssize != USE_EMPTY ) ? sym->Ofssize : ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR [rbx+44]
	cmp	al, 254					; 000000feH
	movzx	r11d, dil
	cmovne	r11d, eax

; 1064 :         on = ( ti.Ofssize != USE_EMPTY ) ? ti.Ofssize : ModuleInfo.Ofssize;

	cmp	r15b, 254				; 000000feH
	movzx	eax, r15b
	cmovne	edi, eax

; 1065 :         if ( ti.mem_type != sym->mem_type ||
; 1066 :             ( ti.mem_type == MT_TYPE && tn != to ) ||

	cmp	r10d, DWORD PTR [rbx+36]
	jne	SHORT $LN31@TypedefDir
	cmp	r10d, 196				; 000000c4H
	jne	SHORT $LN30@TypedefDir
	cmp	rdx, rcx
	jne	SHORT $LN31@TypedefDir
$LN28@TypedefDir:

; 1082 :         }
; 1083 :     }
; 1084 : 
; 1085 :     sym->mem_type = ti.mem_type;
; 1086 :     sym->Ofssize = ti.Ofssize;
; 1087 :     sym->total_size = ti.size;
; 1088 :     sym->is_ptr = ti.is_ptr;
; 1089 :     sym->isfar = ti.is_far;

	and	BYTE PTR [rbx+47], 239			; 000000efH
	and	r8b, 1
	movzx	eax, BYTE PTR ti$[rsp+20]
	shl	r8b, 4
	or	BYTE PTR [rbx+47], r8b
	mov	DWORD PTR [rbx+36], r10d
	mov	BYTE PTR [rbx+44], r15b
	mov	DWORD PTR [rbx+56], r14d
	mov	BYTE PTR [rbx+45], al

; 1090 :     if ( ti.mem_type == MT_TYPE )

	cmp	r10d, 196				; 000000c4H
	jne	SHORT $LN32@TypedefDir

; 1091 :         sym->type = ti.symtype;

	mov	QWORD PTR [rbx+80], r9
	jmp	SHORT $LN33@TypedefDir
$LN30@TypedefDir:

; 1065 :         if ( ti.mem_type != sym->mem_type ||
; 1066 :             ( ti.mem_type == MT_TYPE && tn != to ) ||

	cmp	r10d, 195				; 000000c3H
	jne	SHORT $LN28@TypedefDir
	movzx	eax, BYTE PTR [rbx+47]
	shr	al, 4
	and	al, 1
	cmp	r8b, al
	jne	SHORT $LN31@TypedefDir
	cmp	dil, r11b
	jne	SHORT $LN31@TypedefDir
	movzx	eax, BYTE PTR [rbx+46]
	cmp	DWORD PTR ti$[rsp+24], eax
	jne	SHORT $LN31@TypedefDir
	cmp	rdx, rcx
	je	SHORT $LN28@TypedefDir
$LN31@TypedefDir:

; 1067 :             ( ti.mem_type == MT_PTR &&
; 1068 :              ( ti.is_far != sym->isfar ||
; 1069 :               on != oo ||
; 1070 :               ti.ptr_memtype != sym->ptr_memtype ||
; 1071 :               tn != to ))) {
; 1072 :             DebugMsg(("TypedefDirective: old-new memtype=%X-%X type=%X(%s)-%X(%s) far=%u-%u ind=%u-%u ofss=%d-%d pmt=%X-%X\n",
; 1073 :                       sym->mem_type, ti.mem_type,
; 1074 :                       (sym->mem_type == MT_TYPE) ? sym->type : sym->target_type,
; 1075 :                       (sym->mem_type == MT_TYPE) ? sym->type->name : sym->target_type ? sym->target_type->name : "",
; 1076 :                       ti.symtype, ti.symtype ? ti.symtype->name : "",
; 1077 :                       sym->isfar, ti.is_far,
; 1078 :                       sym->is_ptr, ti.is_ptr,
; 1079 :                       sym->Ofssize, ti.Ofssize,
; 1080 :                       sym->ptr_memtype, ti.ptr_memtype ));
; 1081 :             return( EmitErr( SYMBOL_TYPE_CONFLICT, name ) );

	mov	rdx, r13
	mov	ecx, 136				; 00000088H
	call	EmitErr
	jmp	SHORT $LN65@TypedefDir
$LN32@TypedefDir:

; 1092 :     else
; 1093 :         sym->target_type = ti.symtype;

	mov	QWORD PTR [rbx+48], r9
$LN33@TypedefDir:

; 1094 :     sym->ptr_memtype = ti.ptr_memtype;

	movzx	eax, BYTE PTR ti$[rsp+24]
	mov	BYTE PTR [rbx+46], al

; 1095 :     DebugMsg1(("TypedefDirective(%s) ok, mem_type=MT_TYPE, size=%" I32_SPEC "u, type=%p type.memtype=%X\n",
; 1096 :                sym->name, sym->total_size, sym->type, ti.symtype ? ti.symtype->mem_type : 0 ));
; 1097 : 
; 1098 :     DebugMsg1(("TypedefDirective(%s) ok, mem_type=%Xh, size=%u, indirection=%u target=%p\n", sym->name, sym->mem_type, ti.size, ti.is_ptr, ti.symtype ));
; 1099 : 
; 1100 :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, ebp
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 0
	je	SHORT $LN34@TypedefDir

; 1101 :         DebugMsg(("TypedefDirective: unexpected token %u, idx=%u\n", tokenarray[i].token, i));
; 1102 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rax+rsi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN65@TypedefDir
$LN34@TypedefDir:

; 1103 :     }
; 1104 : 
; 1105 :     return( NOT_ERROR );

	xor	eax, eax
$LN65@TypedefDir:
	mov	r15, QWORD PTR [rsp+80]
$LN64@TypedefDir:
	mov	r13, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [rsp+136]
	mov	r14, QWORD PTR [rsp+88]

; 1106 : }

	add	rsp, 112				; 00000070H
	pop	rsi
	ret	0
TypedefDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
;	COMDAT CheckAnonymousStruct
_TEXT	SEGMENT
disp$ = 64
type$ = 64
f$1$ = 72
CheckAnonymousStruct PROC				; COMDAT

; 518  : {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 519  :     uint_32 disp;
; 520  :     struct asym  *sym;
; 521  :     struct sfield *f;
; 522  : 
; 523  :     for ( f = type->e.structinfo->head; f; f = f->next ) {

	mov	rax, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR [rax]
	mov	QWORD PTR f$1$[rsp], rdx
	test	rdx, rdx
	je	$LN43@CheckAnony
$LL4@CheckAnony:

; 524  :         if ( *f->sym.name ) {

	mov	rsi, QWORD PTR [rdx+8]
	cmp	BYTE PTR [rsi], 0
	je	$LN5@CheckAnony

; 525  :             sym = SearchNameInStruct((struct asym *)CurrStruct, f->sym.name, &disp, 0 );

	or	rdi, -1
$LL44@CheckAnony:
	inc	rdi
	cmp	BYTE PTR [rsi+rdi], 0
	jne	SHORT $LL44@CheckAnony
	mov	rax, QWORD PTR CurrStruct
	xor	ebp, ebp
	mov	rbx, QWORD PTR [rax+96]
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	je	$LN2@CheckAnony
$LL16@CheckAnony:
	mov	rdx, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rdx], 0
	jne	SHORT $LN18@CheckAnony
	cmp	DWORD PTR [rbx+32], 7
	jne	SHORT $LN20@CheckAnony
	mov	rcx, rbx
	jmp	SHORT $LN47@CheckAnony
$LN20@CheckAnony:
	cmp	DWORD PTR [rbx+36], 196			; 000000c4H
	jne	SHORT $LN14@CheckAnony
	mov	rcx, QWORD PTR [rbx+80]
$LN47@CheckAnony:
	mov	rdx, rsi
	lea	r8, QWORD PTR disp$[rsp]
	mov	r9d, 1
	call	SearchNameInStruct
	mov	rbp, rax
	test	rax, rax
	je	SHORT $LN14@CheckAnony
	mov	eax, DWORD PTR [rbx+16]
	add	DWORD PTR disp$[rsp], eax
	jmp	SHORT $LN42@CheckAnony
$LN18@CheckAnony:
	movzx	eax, BYTE PTR [rbx+72]
	cmp	edi, eax
	jne	SHORT $LN14@CheckAnony
	movsxd	r8, edi
	mov	rcx, rsi
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN31@CheckAnony
$LN14@CheckAnony:
	mov	rbx, QWORD PTR [rbx+96]
	test	rbx, rbx
	jne	SHORT $LL16@CheckAnony
	jmp	SHORT $LN42@CheckAnony
$LN31@CheckAnony:
	mov	rbp, rbx
$LN42@CheckAnony:

; 526  :             if ( sym ) {

	test	rbp, rbp
	je	SHORT $LN45@CheckAnony

; 527  :                 return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rbp+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 539  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN5@CheckAnony:

; 528  :             }
; 529  :         } else if ( f->sym.type ) {

	mov	rcx, QWORD PTR [rdx+80]
	test	rcx, rcx
	je	SHORT $LN2@CheckAnony
	movzx	eax, BYTE PTR [rcx+66]
	dec	al
	cmp	al, 1
	ja	SHORT $LN2@CheckAnony

; 530  :             struct dsym *stype = (struct dsym *)f->sym.type;
; 531  :             if ( stype->sym.typekind == TYPE_STRUCT ||
; 532  :                 stype->sym.typekind == TYPE_UNION ) {
; 533  :             if ( CheckAnonymousStruct( stype ) == ERROR )

	call	CheckAnonymousStruct
	cmp	eax, -1
	je	SHORT $LN33@CheckAnony
$LN45@CheckAnony:
	mov	rdx, QWORD PTR f$1$[rsp]
$LN2@CheckAnony:

; 519  :     uint_32 disp;
; 520  :     struct asym  *sym;
; 521  :     struct sfield *f;
; 522  : 
; 523  :     for ( f = type->e.structinfo->head; f; f = f->next ) {

	mov	rdx, QWORD PTR [rdx+96]
	mov	QWORD PTR f$1$[rsp], rdx
	test	rdx, rdx
	jne	$LL4@CheckAnony
$LN43@CheckAnony:

; 535  :             }
; 536  :         }
; 537  :     }
; 538  :     return( NOT_ERROR );

	xor	eax, eax

; 539  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN33@CheckAnony:

; 534  :                 return( ERROR );

	or	eax, -1

; 539  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
CheckAnonymousStruct ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
i$ = 64
tokenarray$ = 72
EndstructDirective PROC

; 369  : {

$LN61:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	sub	rsp, 48					; 00000030H

; 370  :     //char *name;
; 371  :     //unsigned int offset;
; 372  :     unsigned int size;
; 373  :     //struct asym *sym;
; 374  :     //memtype mem_type;
; 375  :     struct dsym *dir;
; 376  : 
; 377  :     dir = CurrStruct; /* cannot be NULL */
; 378  : 
; 379  :     DebugMsg1(("EndstructDirective(%s), ofs=%" I32_SPEC "u, struct size=%" I32_SPEC "u, max_mbr=%" I32_SPEC "u, alignment=%u\n",
; 380  :               dir->sym.name,
; 381  :               dir->sym.offset,
; 382  :               dir->sym.total_size,
; 383  :               dir->sym.max_mbr_size,
; 384  :               dir->e.structinfo->alignment));
; 385  : 
; 386  :     /* if pass is > 1 just do minimal work */
; 387  :     if ( Parse_Pass > PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	rbp, rdx
	mov	rbx, QWORD PTR CurrStruct
	mov	esi, ecx
	jbe	SHORT $LN7@EndstructD

; 388  :         CurrStruct->sym.offset = 0;

	mov	DWORD PTR [rbx+16], 0

; 389  :         size = CurrStruct->sym.total_size;

	mov	rax, QWORD PTR CurrStruct

; 390  :         CurrStruct = CurrStruct->next;

	mov	rcx, QWORD PTR [rax+104]
	mov	edx, DWORD PTR [rax+56]
	mov	QWORD PTR CurrStruct, rcx

; 391  :         if ( CurrStruct )

	test	rcx, rcx
	je	SHORT $LN45@EndstructD

; 392  :             UpdateStructSize( (struct asym *)dir );

	cmp	BYTE PTR [rcx+66], 2
	mov	eax, DWORD PTR [rbx+56]
	jne	SHORT $LN42@EndstructD
	cmp	eax, DWORD PTR [rcx+56]
	jbe	SHORT $LN45@EndstructD
	mov	DWORD PTR [rcx+56], eax
	jmp	SHORT $LN45@EndstructD
$LN42@EndstructD:
	add	DWORD PTR [rcx+16], eax
	mov	rax, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR [rax+16]
	cmp	ecx, DWORD PTR [rax+56]
	jle	SHORT $LN45@EndstructD
	mov	DWORD PTR [rax+56], ecx
$LN45@EndstructD:

; 393  :         if ( CurrFile[LST] )

	cmp	QWORD PTR ModuleInfo+112, 0
	je	SHORT $LN9@EndstructD

; 394  :             LstWrite( LSTTYPE_STRUCT, size, dir );

	mov	r8, rbx
	mov	ecx, 6
	call	LstWrite
$LN9@EndstructD:

; 395  :         return( NOT_ERROR );

	xor	eax, eax

; 510  :     }
; 511  :     return( NOT_ERROR );
; 512  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
$LN7@EndstructD:

; 396  :     }
; 397  : 
; 398  :     /* syntax is either "<name> ENDS" (i=1) or "ENDS" (i=0).
; 399  :      * first case must be top level (next=NULL), latter case must NOT be top level (next!=NULL)
; 400  :      */
; 401  :     if ( ( i == 1 && dir->next == NULL ) ||

	cmp	ecx, 1
	jne	SHORT $LN13@EndstructD
	cmp	QWORD PTR [rbx+104], 0
	je	SHORT $LN57@EndstructD

; 402  :         ( i == 0 && dir->next != NULL ) ) {
; 403  :         ;
; 404  :     } else {
; 405  :         /* v2.04: error msg improved */
; 406  :         //EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );
; 407  :         return( EmitErr( UNMATCHED_BLOCK_NESTING, i == 1 ? tokenarray[0].string_ptr : "" ) );

	mov	rdx, QWORD PTR [rdx+8]
	jmp	$LN38@EndstructD
$LN57@EndstructD:

; 408  :     }
; 409  : 
; 410  :     if ( i == 1 ) { /* an global struct ends with <name ENDS> */
; 411  :         if ( SymCmpFunc( tokenarray[0].string_ptr, dir->sym.name, dir->sym.name_size ) != 0 ) {

	movzx	r8d, BYTE PTR [rbx+72]
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbp+8]
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN15@EndstructD

; 412  :             /* names don't match */
; 413  :             DebugMsg(("EndstructDirective: names don't match, i=%u, name=%s - %s\n", i, tokenarray[0].string_ptr, dir->sym.name));
; 414  :             return( EmitErr( UNMATCHED_BLOCK_NESTING, tokenarray[0].string_ptr ) );

	mov	rdx, QWORD PTR [rbp+8]
	jmp	$LN38@EndstructD
$LN13@EndstructD:

; 396  :     }
; 397  : 
; 398  :     /* syntax is either "<name> ENDS" (i=1) or "ENDS" (i=0).
; 399  :      * first case must be top level (next=NULL), latter case must NOT be top level (next!=NULL)
; 400  :      */
; 401  :     if ( ( i == 1 && dir->next == NULL ) ||

	test	ecx, ecx
	jne	$LN37@EndstructD
	cmp	QWORD PTR [rbx+104], 0
	je	$LN37@EndstructD
$LN15@EndstructD:

; 415  :         }
; 416  :     }
; 417  : 
; 418  :     i++; /* go past ENDS */
; 419  : 
; 420  :     /* v2.07: if ORG was used inside the struct, the struct's size
; 421  :      * has to be calculated now - there may exist negative offsets.
; 422  :      */
; 423  :     if ( dir->e.structinfo->OrgInside ) {

	mov	r8, QWORD PTR [rbx+96]
	inc	esi
	mov	QWORD PTR [rsp+64], r14
	mov	QWORD PTR [rsp+72], r15
	test	BYTE PTR [r8+29], 4
	je	SHORT $LN16@EndstructD

; 424  :         struct sfield *f;
; 425  :         int_32 min = 0;
; 426  :         for ( f = dir->e.structinfo->head; f; f = f->next )

	mov	rdx, QWORD PTR [r8]
	xor	ecx, ecx
	test	rdx, rdx
	je	SHORT $LN3@EndstructD
	npad	1
$LL4@EndstructD:

; 427  :             if ( f->sym.offset < min )

	mov	eax, DWORD PTR [rdx+16]
	cmp	eax, ecx
	mov	rdx, QWORD PTR [rdx+96]
	cmovl	ecx, eax
	test	rdx, rdx
	jne	SHORT $LL4@EndstructD
$LN3@EndstructD:

; 428  :                 min = f->sym.offset;
; 429  :         dir->sym.total_size = dir->sym.total_size - min;

	sub	DWORD PTR [rbx+56], ecx
$LN16@EndstructD:

; 430  :     }
; 431  : 
; 432  :     /* Pad bytes at the end of the structure. */
; 433  : #if 1
; 434  :     /* v2.02: this is to be done in any case, whether -Zg is set or not */
; 435  :     //if ( dir->e.structinfo->alignment > 1 && Options.masm_compat_gencode == FALSE ) {
; 436  :     if ( dir->e.structinfo->alignment > 1 ) {

	movzx	eax, BYTE PTR [r8+28]
	mov	r15d, 1
	cmp	al, r15b
	jbe	SHORT $LN18@EndstructD

; 437  :         size = dir->sym.max_mbr_size;

	mov	edx, DWORD PTR [rbx+48]

; 438  :         if ( size == 0 )

	test	edx, edx

; 439  :             size++;
; 440  :         if ( size > dir->e.structinfo->alignment )
; 441  :             size = dir->e.structinfo->alignment;
; 442  :         dir->sym.total_size = (dir->sym.total_size + size - 1) & (-size);

	mov	ecx, DWORD PTR [rbx+56]
	cmove	edx, r15d
	movzx	eax, al
	cmp	edx, eax
	cmova	edx, eax
	dec	ecx
	add	ecx, edx
	neg	edx
	and	ecx, edx
	mov	DWORD PTR [rbx+56], ecx
$LN18@EndstructD:

; 443  :         DebugMsg1(("EndstructDirective:, struct size after final alignment=%" I32_SPEC "u\n", dir->sym.total_size));
; 444  :     }
; 445  : #endif
; 446  :     dir->e.structinfo->isOpen = FALSE;

	and	BYTE PTR [r8+29], 253			; 000000fdH

; 447  :     dir->sym.isdefined = TRUE;

	or	BYTE PTR [rbx+40], 2

; 448  : 
; 449  :     /* if there's a negative offset, size will be wrong! */
; 450  :     size = dir->sym.total_size;
; 451  : 
; 452  :     /* reset offset, it's just used during the definition */
; 453  :     dir->sym.offset = 0;
; 454  : 
; 455  :     CurrStruct = dir->next;

	mov	rax, QWORD PTR [rbx+104]
	mov	r14d, DWORD PTR [rbx+56]
	mov	DWORD PTR [rbx+16], 0
	mov	QWORD PTR CurrStruct, rax

; 456  :     /* v2.0: add the embedded struct AFTER it has been parsed! */
; 457  :     if ( i == 1 ) {

	cmp	esi, r15d
	jne	SHORT $LN21@EndstructD

; 458  :         struct asym *sym;
; 459  :         /* v2.06: the struct name is needed for checks */
; 460  :         sym = CreateStructField( -1, NULL, *dir->sym.name ? dir->sym.name : NULL, MT_TYPE, &dir->sym, dir->sym.total_size );

	mov	rax, QWORD PTR [rbx+8]
	xor	r8d, r8d
	mov	r9d, 196				; 000000c4H
	cmp	BYTE PTR [rax], r8b
	cmovne	r8, rax
	mov	eax, DWORD PTR [rbx+56]
	mov	DWORD PTR [rsp+40], eax
	xor	edx, edx
	or	ecx, -1
	mov	QWORD PTR [rsp+32], rbx
	call	CreateStructField

; 461  :         /* the member name was stored in the type name */
; 462  :         //sym->name = dir->sym.name;
; 463  :         //sym->name_size = strlen( dir->sym.name );
; 464  :         sym->total_size = dir->sym.total_size;

	mov	ecx, DWORD PTR [rbx+56]
	mov	DWORD PTR [rax+56], ecx

; 465  :         dir->sym.name = ""; /* the type becomes anonymous */

	lea	rax, OFFSET FLAT:$SG11235
	mov	QWORD PTR [rbx+8], rax

; 466  :         dir->sym.name_size = 0;

	mov	BYTE PTR [rbx+72], 0
$LN21@EndstructD:

; 467  :     }
; 468  : 
; 469  :     if ( CurrFile[LST] ) {

	cmp	QWORD PTR ModuleInfo+112, 0
	je	SHORT $LN22@EndstructD

; 470  :         LstWrite( LSTTYPE_STRUCT, size, dir );

	mov	r8, rbx
	mov	edx, r14d
	mov	ecx, 6
	call	LstWrite
$LN22@EndstructD:

; 471  :     }
; 472  : #if 1
; 473  :     /* to allow direct structure access */
; 474  :     switch ( dir->sym.total_size ) {

	mov	ecx, DWORD PTR [rbx+56]
	mov	r14, QWORD PTR [rsp+64]
	sub	ecx, r15d
	je	SHORT $LN23@EndstructD
	sub	ecx, r15d
	je	SHORT $LN24@EndstructD
	sub	ecx, 2
	je	SHORT $LN25@EndstructD
	sub	ecx, 2
	je	SHORT $LN26@EndstructD
	cmp	ecx, 2
	je	SHORT $LN27@EndstructD

; 480  :     //case 16:  dir->sym.mem_type = MT_OWORD;  break;
; 481  :     default: dir->sym.mem_type = MT_EMPTY;

	mov	DWORD PTR [rbx+36], 192			; 000000c0H
	jmp	SHORT $LN5@EndstructD
$LN27@EndstructD:

; 479  :     case 8:  dir->sym.mem_type = MT_QWORD;  break;

	mov	DWORD PTR [rbx+36], 7
	jmp	SHORT $LN5@EndstructD
$LN26@EndstructD:

; 478  :     case 6:  dir->sym.mem_type = MT_FWORD;  break;

	mov	DWORD PTR [rbx+36], 5
	jmp	SHORT $LN5@EndstructD
$LN25@EndstructD:

; 477  :     case 4:  dir->sym.mem_type = MT_DWORD;  break;

	mov	DWORD PTR [rbx+36], 3
	jmp	SHORT $LN5@EndstructD
$LN24@EndstructD:

; 476  :     case 2:  dir->sym.mem_type = MT_WORD;   break;

	mov	DWORD PTR [rbx+36], r15d
	jmp	SHORT $LN5@EndstructD
$LN23@EndstructD:

; 475  :     case 1:  dir->sym.mem_type = MT_BYTE;   break;

	mov	DWORD PTR [rbx+36], 0
$LN5@EndstructD:

; 482  :     }
; 483  : #endif
; 484  :     /* reset redefine */
; 485  :     if ( CurrStruct == NULL ) {

	mov	rcx, QWORD PTR CurrStruct
	mov	r15, QWORD PTR [rsp+72]
	test	rcx, rcx
	jne	SHORT $LN29@EndstructD

; 486  :         if ( redef_struct ) {

	mov	rdx, QWORD PTR redef_struct
	test	rdx, rdx
	je	SHORT $LN51@EndstructD

; 487  :             if ( AreStructsEqual( dir, redef_struct) == FALSE ) {

	mov	rcx, rbx
	call	AreStructsEqual
	test	al, al
	jne	SHORT $LN32@EndstructD

; 488  :                 EmitErr( NON_BENIGN_XXX_REDEFINITION, szStructure, dir->sym.name );

	mov	r8, QWORD PTR [rbx+8]
	lea	rdx, OFFSET FLAT:szStructure
	mov	ecx, 139				; 0000008bH
	call	EmitErr
$LN32@EndstructD:

; 489  :             }
; 490  :             DebugMsg(("EndstructDirective: delete the redefinition of %s\n", dir->sym.name ));
; 491  :             SymFree( (struct asym *)dir );

	mov	rcx, rbx
	call	SymFree

; 492  :             redef_struct = NULL;

	mov	QWORD PTR redef_struct, 0

; 493  :         }
; 494  :     } else {

	jmp	SHORT $LN51@EndstructD
$LN29@EndstructD:

; 495  : 
; 496  :         if ( dir->sym.max_mbr_size > CurrStruct->sym.max_mbr_size )

	mov	eax, DWORD PTR [rbx+48]
	cmp	eax, DWORD PTR [rcx+48]
	jbe	SHORT $LN33@EndstructD

; 497  :             CurrStruct->sym.max_mbr_size = dir->sym.max_mbr_size;

	mov	DWORD PTR [rcx+48], eax
	mov	rcx, QWORD PTR CurrStruct
$LN33@EndstructD:

; 498  : 
; 499  :         UpdateStructSize( (struct asym *)dir );

	cmp	BYTE PTR [rcx+66], 2
	mov	eax, DWORD PTR [rbx+56]
	jne	SHORT $LN48@EndstructD
	cmp	eax, DWORD PTR [rcx+56]
	jbe	SHORT $LN51@EndstructD
	mov	DWORD PTR [rcx+56], eax
	jmp	SHORT $LN51@EndstructD
$LN48@EndstructD:
	add	DWORD PTR [rcx+16], eax
	mov	rax, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR [rax+16]
	cmp	ecx, DWORD PTR [rax+56]
	jle	SHORT $LN51@EndstructD
	mov	DWORD PTR [rax+56], ecx
$LN51@EndstructD:

; 500  :         DebugMsg1(("EndstructDirective: new size of restored structure=%u\n", CurrStruct->sym.total_size));
; 501  :     }
; 502  :     //dir->sym.max_mbr_size = 0;
; 503  :     if (dir->sym.state == SYM_TYPE)

	cmp	DWORD PTR [rbx+32], 7
	jne	SHORT $LN34@EndstructD

; 504  :     {  
; 505  :            dir->e.structinfo->isHomogenous = 0;

	mov	rax, QWORD PTR [rbx+96]

; 506  :            SymSimd(dir);

	mov	rcx, rbx
	mov	BYTE PTR [rax+20], 0
	call	SymSimd
$LN34@EndstructD:

; 507  :     }
; 508  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, esi
	shl	rax, 5
	cmp	BYTE PTR [rax+rbp], 0
	je	$LN9@EndstructD

; 509  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rax+rbp+8]
	mov	ecx, 209				; 000000d1H
	jmp	SHORT $LN59@EndstructD
$LN37@EndstructD:

; 402  :         ( i == 0 && dir->next != NULL ) ) {
; 403  :         ;
; 404  :     } else {
; 405  :         /* v2.04: error msg improved */
; 406  :         //EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );
; 407  :         return( EmitErr( UNMATCHED_BLOCK_NESTING, i == 1 ? tokenarray[0].string_ptr : "" ) );

	lea	rdx, OFFSET FLAT:$SG11226
$LN38@EndstructD:
	mov	ecx, 142				; 0000008eH
$LN59@EndstructD:

; 510  :     }
; 511  :     return( NOT_ERROR );
; 512  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rsi

; 402  :         ( i == 0 && dir->next != NULL ) ) {
; 403  :         ;
; 404  :     } else {
; 405  :         /* v2.04: error msg improved */
; 406  :         //EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );
; 407  :         return( EmitErr( UNMATCHED_BLOCK_NESTING, i == 1 ? tokenarray[0].string_ptr : "" ) );

	jmp	EmitErr
EndstructDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
opndx$1 = 48
i$ = 192
offset$ = 200
tokenarray$ = 200
StructDirective PROC

; 169  : {

$LN89:
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	push	r14
	sub	rsp, 168				; 000000a8H

; 170  :     char *name;
; 171  :     unsigned alignment;
; 172  :     uint_32 offset;
; 173  :     uint_8 typekind = ( tokenarray[i].tokval == T_UNION ? TYPE_UNION : TYPE_STRUCT );
; 174  :     //unsigned int size;
; 175  :     struct asym *sym;
; 176  :     struct dsym *dir;
; 177  : 
; 178  :     DebugMsg1(("StructDirective(%s) enter, i=%u, CurrStruct=%s\n", tokenarray[i].string_ptr, i, CurrStruct ? CurrStruct->sym.name : "NULL" ));
; 179  : 
; 180  :     /* top level structs/unions must have an identifier at pos 0.
; 181  :      * for embedded structs, the directive must be at pos 0,
; 182  :      * an identifier is optional then.
; 183  :      */
; 184  :     if (( CurrStruct == NULL && i != 1 ) ||

	mov	r10, QWORD PTR CurrStruct
	mov	rdi, rdx
	movsxd	r8, ecx
	mov	rdx, r8
	shl	rdx, 5
	cmp	DWORD PTR [rdx+rdi+16], 424		; 000001a8H
	sete	r14b
	inc	r14b
	test	r10, r10
	jne	SHORT $LN76@StructDire
	cmp	r8d, 1
	jne	SHORT $LN8@StructDire
$LN7@StructDire:

; 188  :     }
; 189  : 
; 190  :     alignment = ( 1 << ModuleInfo.fieldalign );

	movzx	ecx, BYTE PTR ModuleInfo+397

; 191  : 
; 192  :     i++; /* go past STRUCT/UNION */

	inc	r8d
	mov	QWORD PTR [rsp+208], rbx
	mov	ebx, 1
	mov	QWORD PTR [rsp+216], rbp
	mov	ebp, ebx
	shl	ebp, cl
	mov	QWORD PTR [rsp+160], rsi
	mov	DWORD PTR i$[rsp], r8d

; 193  : 
; 194  :     if ( i == 1 ) { /* embedded struct? */

	cmp	r8d, ebx
	jne	SHORT $LN10@StructDire

; 195  :         /* scan for the optional name */
; 196  : #if ANYNAME
; 197  :         /* the name might be a reserved word!
; 198  :          * Masm won't allow those.
; 199  :          */
; 200  :         //if ( tokenarray[i].token != T_FINAL && is_valid_id_first_char(*(tokenarray[i].string_ptr) ) ) {
; 201  : #else
; 202  :         if ( tokenarray[i].token == T_ID ) {

	cmp	BYTE PTR [rdi+32], 8
	jne	SHORT $LN12@StructDire

; 203  : #endif
; 204  :             name = tokenarray[i].string_ptr;

	mov	rsi, QWORD PTR [rdi+40]

; 205  :             i++;

	mov	r8d, 2
	mov	DWORD PTR i$[rsp], r8d

; 206  :         } else {

	jmp	SHORT $LN11@StructDire
$LN76@StructDire:

; 170  :     char *name;
; 171  :     unsigned alignment;
; 172  :     uint_32 offset;
; 173  :     uint_8 typekind = ( tokenarray[i].tokval == T_UNION ? TYPE_UNION : TYPE_STRUCT );
; 174  :     //unsigned int size;
; 175  :     struct asym *sym;
; 176  :     struct dsym *dir;
; 177  : 
; 178  :     DebugMsg1(("StructDirective(%s) enter, i=%u, CurrStruct=%s\n", tokenarray[i].string_ptr, i, CurrStruct ? CurrStruct->sym.name : "NULL" ));
; 179  : 
; 180  :     /* top level structs/unions must have an identifier at pos 0.
; 181  :      * for embedded structs, the directive must be at pos 0,
; 182  :      * an identifier is optional then.
; 183  :      */
; 184  :     if (( CurrStruct == NULL && i != 1 ) ||

	test	ecx, ecx
	je	SHORT $LN7@StructDire
$LN8@StructDire:

; 185  :         ( CurrStruct != NULL && i != 0 ) ) {
; 186  :         DebugMsg(("StructDirective(%s): error: either currstruct or i must be 0\n", tokenarray[i].string_ptr ));
; 187  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rdi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 363  : }

	add	rsp, 168				; 000000a8H
	pop	r14
	pop	rdi
	ret	0
$LN12@StructDire:

; 207  :             name = "";

	lea	rsi, OFFSET FLAT:$SG11156

; 208  :         }
; 209  :     } else {

	jmp	SHORT $LN11@StructDire
$LN10@StructDire:

; 210  :         name = tokenarray[0].string_ptr;

	mov	rsi, QWORD PTR [rdi+8]
$LN11@StructDire:

; 211  :     }
; 212  : 
; 213  :     /* get an optional alignment argument: 1,2,4,8,16 or 32 */
; 214  :     if ( CurrStruct == NULL && tokenarray[i].token != T_FINAL ) {

	test	r10, r10
	jne	$LN27@StructDire
	movsxd	rax, r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], r10b
	je	$LN27@StructDire

; 215  :         int power;
; 216  :         struct expr opndx;
; 217  :         /* get the optional alignment parameter.
; 218  :          * forward references aren't accepted, but EXPF_NOUNDEF isn't used here!
; 219  :          */
; 220  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) != ERROR ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$1[rsp]
	mov	rdx, rdi
	mov	BYTE PTR [rsp+32], r10b
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	je	SHORT $LN25@StructDire

; 221  :             /* an empty expression is accepted */
; 222  :             if ( opndx.kind == EXPR_EMPTY ) {

	mov	eax, DWORD PTR opndx$1[rsp+60]
	cmp	eax, -2
	je	SHORT $LN25@StructDire

; 223  :                 ;
; 224  :             } else if ( opndx.kind != EXPR_CONST ) {

	test	eax, eax
	je	SHORT $LN18@StructDire

; 225  :                 /* v2.09: better error msg */
; 226  :                 if ( opndx.sym && opndx.sym->state == SYM_UNDEFINED )

	mov	rdx, QWORD PTR opndx$1[rsp+80]
	test	rdx, rdx
	je	SHORT $LN20@StructDire
	cmp	DWORD PTR [rdx+32], 0
	jne	SHORT $LN20@StructDire

; 227  :                     EmitErr( SYMBOL_NOT_DEFINED, opndx.sym->name );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr
	jmp	SHORT $LN25@StructDire
$LN20@StructDire:

; 228  :                 else
; 229  :                     EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 230  :             } else if( opndx.value > MAX_STRUCT_ALIGN ) {

	jmp	SHORT $LN25@StructDire
$LN18@StructDire:
	mov	eax, DWORD PTR opndx$1[rsp]
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN22@StructDire

; 231  :                 EmitError( STRUCT_ALIGN_TOO_HIGH );

	mov	ecx, 214				; 000000d6H
	call	EmitError

; 232  :             } else {

	jmp	SHORT $LN25@StructDire
$LN22@StructDire:

; 233  :                 for( power = 1; power < opndx.value; power <<= 1 );

	cmp	ebx, eax
	jge	SHORT $LN83@StructDire
	npad	2
$LL4@StructDire:
	add	ebx, ebx
	cmp	ebx, eax
	jl	SHORT $LL4@StructDire
$LN83@StructDire:

; 234  :                 if( power != opndx.value ) {

	je	SHORT $LN24@StructDire

; 235  :                     EmitErr( POWER_OF_2, opndx.value );

	mov	edx, eax
	mov	ecx, 129				; 00000081H
	call	EmitErr

; 236  :                 } else

	jmp	SHORT $LN25@StructDire
$LN24@StructDire:

; 237  :                     alignment = opndx.value;

	mov	ebp, eax
$LN25@StructDire:

; 238  :             }
; 239  :             DebugMsg1(("StructDirective(%s) alignment=%u\n", name, alignment));
; 240  :         }
; 241  :         /* there might also be the NONUNIQUE parameter */
; 242  :         if ( tokenarray[i].token == T_COMMA ) {

	movsxd	r8, DWORD PTR i$[rsp]
	mov	rax, r8
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 44			; 0000002cH
	jne	SHORT $LN79@StructDire

; 243  :             i++;

	inc	r8d

; 244  :             if ( tokenarray[i].token == T_ID &&

	movsxd	rax, r8d
	shl	rax, 5
	mov	DWORD PTR i$[rsp], r8d
	cmp	BYTE PTR [rax+rdi], 8
	jne	SHORT $LN79@StructDire
	mov	rcx, QWORD PTR [rax+rdi+8]
	lea	rdx, OFFSET FLAT:szNonUnique
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN78@StructDire

; 245  :                 (_stricmp( tokenarray[i].string_ptr, szNonUnique ) == 0 ) ) {
; 246  :                 /* currently NONUNIQUE is ignored */
; 247  :                 EmitWarn( 2, TOKEN_IGNORED, szNonUnique );

	lea	r8, OFFSET FLAT:szNonUnique
	mov	edx, 250				; 000000faH
	lea	ecx, QWORD PTR [rax+2]
	call	EmitWarn

; 248  :                 i++;

	mov	r8d, DWORD PTR i$[rsp]
	inc	r8d
	mov	DWORD PTR i$[rsp], r8d
	jmp	SHORT $LN79@StructDire
$LN78@StructDire:
	mov	r8d, DWORD PTR i$[rsp]
$LN79@StructDire:
	mov	r10, QWORD PTR CurrStruct
$LN27@StructDire:

; 249  :             }
; 250  :         }
; 251  :     }
; 252  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 0
	je	SHORT $LN28@StructDire

; 253  :         DebugMsg(("StructDirective(%s): error: unexpected token %u >%s<\n", tokenarray[i].token, tokenarray[i].tokpos ));
; 254  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rax+rdi+24]
	mov	ecx, 209				; 000000d1H
	jmp	$LN84@StructDire
$LN28@StructDire:

; 255  :     }
; 256  : 
; 257  :     /* does struct have a name? */
; 258  :     if ( *name ) {

	xor	edi, edi
	cmp	BYTE PTR [rsi], dil
	je	SHORT $LN29@StructDire

; 259  :         if ( CurrStruct == NULL ) {

	test	r10, r10
	jne	SHORT $LN31@StructDire

; 260  :             /* the "top-level" struct is part of the global namespace */
; 261  :             sym = SymSearch( name );

	mov	rcx, rsi
	call	SymFind

; 262  :             DebugMsg1(("StructDirective: SymSearch (%s)=%X (curr struct=%X)\n", name, sym, CurrStruct ));
; 263  :         } else {

	mov	r10, QWORD PTR CurrStruct
	mov	rbx, rax
	jmp	SHORT $LN30@StructDire
$LN31@StructDire:

; 264  :             sym = SearchNameInStruct( (struct asym *)CurrStruct, name, &offset, 0 );

	xor	r9d, r9d
	lea	r8, QWORD PTR offset$[rsp]
	mov	rdx, rsi
	mov	rcx, r10
	call	SearchNameInStruct

; 265  :             DebugMsg1(("StructDirective(%s): SearchNameInStruc()=%X\n", name, sym));
; 266  :         }
; 267  :     } else {

	mov	r10, QWORD PTR CurrStruct
	mov	rbx, rax
	jmp	SHORT $LN30@StructDire
$LN29@StructDire:

; 268  :         sym = NULL;   /* anonymous struct */

	mov	rbx, rdi
$LN30@StructDire:

; 269  :     }
; 270  : 
; 271  :     if ( ModuleInfo.list ) {

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN35@StructDire

; 272  :         if ( CurrStruct )
; 273  :             LstWrite( LSTTYPE_STRUCT, CurrStruct->sym.total_size, NULL );

	xor	r8d, r8d
	lea	ecx, QWORD PTR [r8+6]
	test	r10, r10
	je	SHORT $LN34@StructDire
	mov	edx, DWORD PTR [r10+56]
	jmp	SHORT $LN85@StructDire
$LN34@StructDire:

; 274  :         else
; 275  :             LstWrite( LSTTYPE_STRUCT, 0, NULL );

	xor	edx, edx
$LN85@StructDire:
	call	LstWrite
	mov	r10, QWORD PTR CurrStruct
$LN35@StructDire:

; 276  :     }
; 277  : 
; 278  :     /* if pass is > 1, update struct stack + CurrStruct.offset and exit */
; 279  :     if ( Parse_Pass > PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, edi
	jbe	SHORT $LN36@StructDire

; 280  :         /* v2.04 changed. the previous implementation was insecure.
; 281  :          * See also change in data.c, behind CreateStructField().
; 282  :          */
; 283  :         if ( CurrStruct ) {

	test	r10, r10
	je	SHORT $LN37@StructDire

; 284  :             sym = CurrStruct->e.structinfo->tail->sym.type;

	mov	rcx, QWORD PTR [r10+96]
	mov	rax, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rax+80]

; 285  :             /**/myassert( sym );
; 286  :             CurrStruct->e.structinfo->tail = CurrStruct->e.structinfo->tail->next;

	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rcx+8], rax
$LN37@StructDire:

; 287  :         }
; 288  :         /**/myassert( sym );
; 289  :         dir = (struct dsym *)sym;
; 290  :         dir->e.structinfo->tail = dir->e.structinfo->head;

	mov	rcx, QWORD PTR [rbx+96]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 291  :         sym->offset = 0;
; 292  :         sym->isdefined = TRUE;

	or	BYTE PTR [rbx+40], 2
	mov	DWORD PTR [rbx+16], edi

; 293  :         ((struct dsym *)sym)->next = CurrStruct;

	mov	rax, QWORD PTR CurrStruct
	mov	QWORD PTR [rbx+104], rax

; 294  :         CurrStruct = (struct dsym *)sym;
; 295  :         return( NOT_ERROR );

	xor	eax, eax
	mov	QWORD PTR CurrStruct, rbx
	jmp	$LN82@StructDire
$LN36@StructDire:

; 296  :     }
; 297  : 
; 298  :     if( sym == NULL ) {

	test	rbx, rbx
	jne	SHORT $LN38@StructDire

; 299  : 
; 300  :         /* embedded or global STRUCT? */
; 301  :         if ( CurrStruct == NULL )
; 302  :             sym = CreateTypeSymbol( NULL, name, TRUE );

	mov	rcx, rsi
	test	r10, r10
	jne	SHORT $LN40@StructDire
	call	SymCreate
	jmp	$LN87@StructDire
$LN40@StructDire:

; 303  :         else {
; 304  :             /* an embedded struct is split in an anonymous STRUCT type
; 305  :              * and a struct field with/without name
; 306  :              */
; 307  :             sym = CreateTypeSymbol( NULL, name, FALSE );

	call	SymAlloc
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN61@StructDire
	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rax+32], 7
	mov	BYTE PTR [rax+66], dil
	call	LclAlloc
	mov	QWORD PTR [rbx+96], rax
	mov	QWORD PTR [rax], rdi
	mov	QWORD PTR [rax+8], rdi
	mov	WORD PTR [rax+28], di
$LN61@StructDire:

; 308  :             /* v2: don't create the struct field here. First the
; 309  :              * structure must be read in ( because of alignment issues
; 310  :              */
; 311  :             // sym = CreateStructField( name_loc, -1, MT_TYPE, dir, 0 );
; 312  : 
; 313  :             alignment = CurrStruct->e.structinfo->alignment;

	mov	rax, QWORD PTR CurrStruct
	mov	rcx, QWORD PTR [rax+96]
	movzx	ebp, BYTE PTR [rcx+28]

; 314  :         }

	jmp	SHORT $LN47@StructDire
$LN38@StructDire:

; 315  : 
; 316  :     } else if( sym->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [rbx+32]
	test	eax, eax
	jne	SHORT $LN42@StructDire

; 317  : 
; 318  :         /* forward reference */
; 319  :         CreateTypeSymbol( sym, NULL, CurrStruct == NULL );

	test	r10, r10
	mov	rcx, rbx
	sete	r8b
	xor	edx, edx
	call	CreateTypeSymbol
	jmp	SHORT $LN47@StructDire
$LN42@StructDire:

; 320  : 
; 321  :     } else if( sym->state == SYM_TYPE && CurrStruct == NULL ) {

	cmp	eax, 7
	jne	$LN44@StructDire
	test	r10, r10
	jne	$LN44@StructDire

; 322  : 
; 323  :         switch ( sym->typekind ) {

	movzx	eax, BYTE PTR [rbx+66]
	test	al, al
	je	SHORT $LN47@StructDire
	dec	al
	cmp	al, 1
	ja	SHORT $LN44@StructDire

; 324  :         case TYPE_STRUCT:
; 325  :         case TYPE_UNION:
; 326  :             /* if a struct is redefined as a union ( or vice versa )
; 327  :              * do accept the directive and just check if the redefinition
; 328  :              * is compatible (usually it isn't) */
; 329  :             redef_struct = (struct dsym *)sym;
; 330  :             sym = CreateTypeSymbol( NULL, name, FALSE );

	mov	rcx, rsi
	mov	QWORD PTR redef_struct, rbx
	call	SymAlloc
$LN87@StructDire:
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN47@StructDire
	mov	DWORD PTR [rax+32], 7
	mov	ecx, 32					; 00000020H
	mov	BYTE PTR [rax+66], dil
	call	LclAlloc
	mov	QWORD PTR [rbx+96], rax
	mov	WORD PTR [rax+28], di
	mov	QWORD PTR [rax+8], rdi
	mov	QWORD PTR [rax], rdi
$LN47@StructDire:

; 340  :     }
; 341  : 
; 342  :     sym->offset = 0;
; 343  :     sym->typekind = typekind;
; 344  :     dir = (struct dsym *)sym;
; 345  :     dir->e.structinfo->alignment = alignment;

	mov	rax, QWORD PTR [rbx+96]
	mov	DWORD PTR [rbx+16], edi
	mov	BYTE PTR [rbx+66], r14b
	mov	BYTE PTR [rax+28], bpl

; 346  :     dir->e.structinfo->isOpen = TRUE;

	mov	rax, QWORD PTR [rbx+96]
	or	BYTE PTR [rax+29], 2

; 347  :     if ( CurrStruct )

	mov	rax, QWORD PTR CurrStruct
	test	rax, rax
	je	SHORT $LN49@StructDire

; 348  :         dir->e.structinfo->isInline = TRUE;

	mov	rax, QWORD PTR [rbx+96]
	or	BYTE PTR [rax+29], 1
	mov	rax, QWORD PTR CurrStruct
$LN49@StructDire:

; 349  : 
; 350  :     dir->next = CurrStruct;

	mov	QWORD PTR [rbx+104], rax

; 351  :     CurrStruct = dir;
; 352  : 
; 353  : #if 0 //def DEBUG_OUT
; 354  :     {
; 355  :         struct dsym *struc;
; 356  :         for ( struc = CurrStruct; struc; struc = struc->next ) {
; 357  :             DebugMsg(("StructDirective stack: %X, name=>%s<\n", struc, struc->sym.name ));
; 358  :         }
; 359  :     }
; 360  : #endif
; 361  : 
; 362  :     return( NOT_ERROR );

	xor	eax, eax
	mov	QWORD PTR CurrStruct, rbx
	jmp	SHORT $LN82@StructDire
$LN44@StructDire:

; 331  :             break;
; 332  :         case TYPE_NONE:  /* TYPE_NONE is forward reference */
; 333  :             break;
; 334  :         default:
; 335  :             return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );
; 336  :         }
; 337  : 
; 338  :     } else {
; 339  :         return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 143				; 0000008fH
$LN84@StructDire:
	call	EmitErr
$LN82@StructDire:
	mov	rbp, QWORD PTR [rsp+216]
	mov	rbx, QWORD PTR [rsp+208]
	mov	rsi, QWORD PTR [rsp+160]

; 363  : }

	add	rsp, 168				; 000000a8H
	pop	r14
	pop	rdi
	ret	0
StructDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
;	COMDAT AreStructsEqual
_TEXT	SEGMENT
newstr$ = 8
oldstr$ = 16
AreStructsEqual PROC					; COMDAT

; 129  :     struct sfield *fold = oldstr->e.structinfo->head;

	mov	rax, QWORD PTR [rdx+96]
	mov	r9, QWORD PTR [rax]

; 130  :     struct sfield *fnew = newstr->e.structinfo->head;

	mov	rax, QWORD PTR [rcx+96]
	mov	r8, QWORD PTR [rax]

; 131  : 
; 132  :     DebugMsg(("AreStructsEqual(%s) enter\n", oldstr->sym.name ));
; 133  : 
; 134  :     /* kind of structs must be identical */
; 135  :     if ( oldstr->sym.typekind != newstr->sym.typekind )

	movzx	eax, BYTE PTR [rcx+66]
	cmp	BYTE PTR [rdx+66], al
	je	SHORT $LN5@AreStructs
$LN15@AreStructs:

; 136  :         return( FALSE );

	xor	al, al

; 160  :         return( FALSE );
; 161  :     return( TRUE );
; 162  : }

	ret	0
$LN5@AreStructs:

; 137  : 
; 138  :     for ( ; fold; fold = fold->next, fnew = fnew->next ) {

	test	r9, r9
	je	SHORT $LN3@AreStructs
	mov	r11d, DWORD PTR ModuleInfo+408
$LL4@AreStructs:

; 139  :         if ( !fnew ) {

	test	r8, r8
	je	SHORT $LN15@AreStructs

; 140  :             DebugMsg(("AreStructsEqual: fields don't match\n"));
; 141  :             return( FALSE );
; 142  :         }
; 143  :         /* for global member names, don't check the name if it's "" */
; 144  :         if ( ModuleInfo.oldstructs && *fnew->sym.name == NULLC )

	bt	r11d, 8
	jae	SHORT $LN7@AreStructs
	mov	rax, QWORD PTR [r8+8]
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN9@AreStructs
$LN7@AreStructs:

; 145  :             ;
; 146  :         else if ( 0 != strcmp( fold->sym.name, fnew->sym.name ) ) {

	mov	rax, QWORD PTR [r9+8]
	mov	r10, QWORD PTR [r8+8]
	sub	r10, rax
	npad	10
$LL22@AreStructs:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r10]
	sub	edx, ecx
	jne	SHORT $LN23@AreStructs
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL22@AreStructs
$LN23@AreStructs:
	test	edx, edx
	jne	SHORT $LN15@AreStructs
$LN9@AreStructs:

; 147  :             DebugMsg(("AreStructsEqual: type name of field changed\n"));
; 148  :             return( FALSE );
; 149  :         }
; 150  :         if ( fold->sym.offset != fnew->sym.offset ) {

	mov	eax, DWORD PTR [r8+16]
	cmp	DWORD PTR [r9+16], eax
	jne	SHORT $LN15@AreStructs

; 151  :             DebugMsg(("AreStructsEqual: offset of field %s changed: %u - %u\n", fold->sym.name, fold->sym.offset, fnew->sym.offset));
; 152  :             return( FALSE );
; 153  :         }
; 154  :         if ( fold->sym.total_size != fnew->sym.total_size ) {

	mov	eax, DWORD PTR [r8+56]
	cmp	DWORD PTR [r9+56], eax
	jne	SHORT $LN15@AreStructs

; 137  : 
; 138  :     for ( ; fold; fold = fold->next, fnew = fnew->next ) {

	mov	r9, QWORD PTR [r9+96]
	mov	r8, QWORD PTR [r8+96]
	test	r9, r9
	jne	SHORT $LL4@AreStructs
$LN3@AreStructs:

; 155  :             DebugMsg(("AreStructsEqual: total_size of field changed\n"));
; 156  :             return( FALSE );
; 157  :         }
; 158  :     }
; 159  :     if ( fnew )

	test	r8, r8
	sete	al

; 160  :         return( FALSE );
; 161  :     return( TRUE );
; 162  : }

	ret	0
AreStructsEqual ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
dir$ = 8
DeleteType PROC

; 1319 :     struct sfield      *curr;
; 1320 :     struct sfield      *next;
; 1321 : 
; 1322 :     DebugMsg(("DeleteType(%s) enter, typekind=%u, memtype=%Xh\n", dir->sym.name, dir->sym.typekind, dir->sym.mem_type ));
; 1323 : #if FASTMEM==0
; 1324 :     /* release prototype in target_type if typedef is PROTO */
; 1325 :     if ( dir->sym.mem_type == MT_PROC ) {
; 1326 :         /* v2.11: change the prototype type to an external, because SymFree()
; 1327 :          * doesn't expect a prototype in a type.
; 1328 :          */
; 1329 :         dir->sym.target_type->state = SYM_EXTERNAL;
; 1330 :         SymFree( dir->sym.target_type );
; 1331 :     }
; 1332 : #endif
; 1333 : #if TYPEOPT
; 1334 :     if ( dir->sym.typekind == TYPE_TYPEDEF )
; 1335 :         return;
; 1336 : #endif
; 1337 :     /* bitfields field names are global, don't free them here! */
; 1338 :     if ( dir->sym.typekind != TYPE_RECORD )
; 1339 :         for( curr = dir->e.structinfo->head; curr != NULL; curr = next ) {
; 1340 :             next = curr->next;
; 1341 : #if FASTMEM==0
; 1342 :             if ( curr->sym.name_size ) LclFree( curr->sym.name );
; 1343 : #endif
; 1344 :             LclFree( curr );
; 1345 :         }
; 1346 :     LclFree( dir->e.structinfo );
; 1347 :     return;
; 1348 : }

	ret	0
DeleteType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
TypesInit PROC

; 49   :     CurrStruct   = NULL;

	xor	eax, eax
	mov	QWORD PTR CurrStruct, rax

; 50   :     redef_struct = NULL;

	mov	QWORD PTR redef_struct, rax

; 51   : }

	ret	0
TypesInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
value$ = 8
AlignInStruct PROC

; 749  :     if ( CurrStruct->sym.typekind != TYPE_UNION ) {

	mov	r8, QWORD PTR CurrStruct
	cmp	BYTE PTR [r8+66], 2
	je	SHORT $LN6@AlignInStr

; 750  :         int offset;
; 751  :         offset = CurrStruct->sym.offset;
; 752  :         offset = (offset + (value - 1)) & (-value);

	mov	edx, DWORD PTR [r8+16]
	dec	edx
	add	edx, ecx
	neg	ecx
	and	edx, ecx

; 753  :         CurrStruct->sym.offset = offset;

	mov	DWORD PTR [r8+16], edx

; 754  :         if ( offset > CurrStruct->sym.total_size )

	mov	rax, QWORD PTR CurrStruct
	cmp	edx, DWORD PTR [rax+56]
	jbe	SHORT $LN6@AlignInStr

; 755  :             CurrStruct->sym.total_size = offset;

	mov	DWORD PTR [rax+56], edx
$LN6@AlignInStr:

; 756  :     }
; 757  :     return( NOT_ERROR );

	xor	eax, eax

; 758  : }

	ret	0
AlignInStruct ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
offset$ = 8
SetStructCurrentOffset PROC

; 789  :     if ( CurrStruct->sym.typekind == TYPE_UNION ) {

	mov	rax, QWORD PTR CurrStruct
	mov	edx, ecx
	cmp	BYTE PTR [rax+66], 2
	jne	SHORT $LN2@SetStructC

; 790  :         return( EmitError( ORG_NOT_ALLOWED_IN_UNIONS ) );

	mov	ecx, 213				; 000000d5H
	jmp	EmitError
$LN2@SetStructC:

; 791  :     }
; 792  :     CurrStruct->sym.offset = offset;

	mov	DWORD PTR [rax+16], ecx

; 793  :     /* if an ORG is inside the struct, it cannot be instanced anymore */
; 794  :     CurrStruct->e.structinfo->OrgInside = TRUE;

	mov	rax, QWORD PTR CurrStruct
	mov	rcx, QWORD PTR [rax+96]
	or	BYTE PTR [rcx+29], 4

; 795  :     if ( offset > (int_32)CurrStruct->sym.total_size )

	mov	rax, QWORD PTR CurrStruct
	cmp	edx, DWORD PTR [rax+56]
	jle	SHORT $LN3@SetStructC

; 796  :         CurrStruct->sym.total_size = offset;

	mov	DWORD PTR [rax+56], edx
$LN3@SetStructC:

; 797  : 
; 798  :     return( NOT_ERROR );

	xor	eax, eax

; 799  : }

	ret	0
SetStructCurrentOffset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
sym$ = 8
UpdateStructSize PROC

; 765  :     if ( CurrStruct->sym.typekind == TYPE_UNION ) {

	mov	rdx, QWORD PTR CurrStruct

; 766  :         //if ( no_of_bytes > CurrStruct->sym.total_size )
; 767  :         //    CurrStruct->sym.total_size = no_of_bytes;
; 768  :         if ( sym->total_size > CurrStruct->sym.total_size )

	mov	eax, DWORD PTR [rcx+56]
	cmp	BYTE PTR [rdx+66], 2
	jne	SHORT $LN2@UpdateStru
	cmp	eax, DWORD PTR [rdx+56]
	jbe	SHORT $LN5@UpdateStru

; 769  :             CurrStruct->sym.total_size = sym->total_size;

	mov	DWORD PTR [rdx+56], eax

; 774  :     }
; 775  :     DebugMsg1(("UpdateStructSize(%s.%s): %s, curr mbr size=%u curr struc/union size=%u\n",
; 776  :                CurrStruct->sym.name,
; 777  :                sym->name,
; 778  :                CurrStruct->sym.typekind == TYPE_UNION ? "union" : "struct",
; 779  :                sym->total_size,
; 780  :                CurrStruct->sym.total_size));
; 781  :     return;
; 782  : }

	ret	0
$LN2@UpdateStru:

; 770  :     } else {
; 771  :         CurrStruct->sym.offset += sym->total_size;

	add	DWORD PTR [rdx+16], eax

; 772  :         if ( CurrStruct->sym.offset > (int_32)CurrStruct->sym.total_size )

	mov	rax, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR [rax+16]
	cmp	ecx, DWORD PTR [rax+56]
	jle	SHORT $LN5@UpdateStru

; 773  :             CurrStruct->sym.total_size = CurrStruct->sym.offset;

	mov	DWORD PTR [rax+56], ecx
$LN5@UpdateStru:

; 774  :     }
; 775  :     DebugMsg1(("UpdateStructSize(%s.%s): %s, curr mbr size=%u curr struc/union size=%u\n",
; 776  :                CurrStruct->sym.name,
; 777  :                sym->name,
; 778  :                CurrStruct->sym.typekind == TYPE_UNION ? "union" : "struct",
; 779  :                sym->total_size,
; 780  :                CurrStruct->sym.total_size));
; 781  :     return;
; 782  : }

	ret	0
UpdateStructSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
si$1$ = 48
loc$ = 128
tokenarray$ = 136
disp$ = 144
name$ = 144
mem_type$ = 152
vartype$ = 160
size$ = 168
CreateStructField PROC

; 551  : {

$LN59:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	edi, ecx

; 552  :     int_32 offset;
; 553  :     //int count;
; 554  :     int i;
; 555  :     int len;
; 556  :     uint_32 disp;
; 557  :     char *init;
; 558  :     struct struct_info *si;
; 559  :     struct sfield *f;
; 560  :     struct asym  *gsym;
; 561  : 
; 562  :     si = CurrStruct->e.structinfo;

	mov	rcx, QWORD PTR CurrStruct
	mov	r12d, r9d
	mov	r13, r8
	mov	rbp, rdx
	mov	r15, QWORD PTR [rcx+96]

; 563  :     offset = CurrStruct->sym.offset;

	mov	esi, DWORD PTR [rcx+16]
	mov	QWORD PTR si$1$[rsp], r15

; 564  : 
; 565  :     DebugMsg1(("CreateStructField(%s): name=%s, curr ofs=%" I32_SPEC "u, vartype=%s, size=%" I32_SPEC "u\n",
; 566  :                CurrStruct->sym.name, name ? name : "<anonymous>", offset,
; 567  :                vartype ? vartype->name : "NULL", size ));
; 568  : 
; 569  :     if ( name ) {

	test	r8, r8
	je	SHORT $LN8@CreateStru

; 570  :         struct asym  *sym;
; 571  :         len = strlen( name );

	or	r14, -1
$LL51@CreateStru:
	inc	r14
	cmp	BYTE PTR [r14+r8], 0
	jne	SHORT $LL51@CreateStru

; 572  :         if( len > MAX_ID_LEN ) {

	cmp	r14d, 247				; 000000f7H
	jle	SHORT $LN10@CreateStru

; 573  :             EmitError( IDENTIFIER_TOO_LONG );

	mov	ecx, 70					; 00000046H
	call	EmitError

; 574  :             return( NULL );

	xor	eax, eax

; 741  : }

	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN10@CreateStru:

; 575  :         }
; 576  :         sym = SearchNameInStruct((struct asym *)CurrStruct, name, &disp, 0 );

	xor	r9d, r9d
	lea	r8, QWORD PTR disp$[rsp]
	mov	rdx, r13
	call	SearchNameInStruct

; 577  :         if ( sym ) {

	test	rax, rax
	je	SHORT $LN9@CreateStru

; 578  :             EmitErr( SYMBOL_ALREADY_DEFINED, sym->name );

	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 579  :             return( NULL );

	xor	eax, eax

; 741  : }

	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN8@CreateStru:

; 580  :         }
; 581  :     } else {
; 582  :         /* v2.06: check fields of anonymous struct member */
; 583  :         if ( vartype &&

	mov	rcx, QWORD PTR vartype$[rsp]
	test	rcx, rcx
	je	SHORT $LN12@CreateStru
	movzx	eax, BYTE PTR [rcx+66]
	dec	al
	cmp	al, 1
	ja	SHORT $LN12@CreateStru

; 584  :             ( vartype->typekind == TYPE_STRUCT ||
; 585  :              vartype->typekind == TYPE_UNION ) ) {
; 586  :             CheckAnonymousStruct( (struct dsym *)vartype );

	call	CheckAnonymousStruct
$LN12@CreateStru:

; 587  :         }
; 588  :         name = "";

	lea	r13, OFFSET FLAT:$SG11317

; 589  :         len = 0;

	xor	r14d, r14d
$LN9@CreateStru:

; 590  :     }
; 591  : 
; 592  :     if ( loc != -1 ) {

	mov	QWORD PTR [rsp+128], rbx
	cmp	edi, -1
	je	$LN14@CreateStru

; 593  : 
; 594  :         //i = strlen( tokenarray[loc].string_ptr ) + 1;
; 595  :         //DebugMsg1(("CreateStructField(%s): type=>%s<\n", CurrStruct->sym.name, tokenarray[loc].string_ptr ));
; 596  :         //f->init_dir = LclAlloc( i );
; 597  :         //memcpy( f->init_dir, tokenarray[loc].string_ptr, i );
; 598  : 
; 599  :         /* now add the value to initialize the struct to */
; 600  : 
; 601  :         /* v2.03: the initializer value may contain assembly time
; 602  :          * variables ( $ inside structs is also one ). It's crucial that
; 603  :          * the variable's CURRENT value is used then.
; 604  :          * v2.08: modified. avoid usage of token->string_ptr,
; 605  :          * and prefer to use token->tokpos.
; 606  :          */
; 607  :         init = StringBufferEnd;

	mov	rbx, QWORD PTR ModuleInfo+488

; 608  :         for ( i = loc+1; tokenarray[i].token != T_FINAL; i++ ) {

	lea	eax, DWORD PTR [rdi+1]
	movsxd	r15, eax
	mov	rdi, r15
	shl	rdi, 5
	add	rdi, rbp
	cmp	BYTE PTR [rdi], 0
	je	$LN3@CreateStru
	lea	r12, QWORD PTR [rdi+56]
$LL4@CreateStru:

; 609  :             if ( tokenarray[i].token == T_ID ) {

	cmp	BYTE PTR [rdi], 8
	jne	SHORT $LN17@CreateStru

; 610  :                 struct asym *sym2 = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rdi+8]
	call	SymFind
	mov	rbp, rax

; 611  :                 if ( sym2 && sym2->variable ) {

	test	rax, rax
	je	SHORT $LN55@CreateStru
	movzx	eax, BYTE PTR [rax+40]
	test	al, 64					; 00000040H
	je	SHORT $LN55@CreateStru

; 612  :                     if ( sym2->predefined && sym2->sfunc_ptr )

	test	al, 32					; 00000020H
	je	SHORT $LN18@CreateStru
	mov	rax, QWORD PTR [rbp+64]
	test	rax, rax
	je	SHORT $LN18@CreateStru

; 613  :                         sym2->sfunc_ptr( sym2, NULL );

	xor	edx, edx
	mov	rcx, rbp
	call	rax
$LN18@CreateStru:

; 614  :                     myltoa( sym2->uvalue, init, ModuleInfo.radix, sym2->value3264 < 0, TRUE );

	cmp	DWORD PTR [rbp+56], 0
	mov	rdx, rbx
	movzx	r8d, BYTE PTR ModuleInfo+396
	mov	ecx, DWORD PTR [rbp+16]
	setl	r9b
	mov	BYTE PTR [rsp+32], 1
	call	myltoa

; 615  :                     init += strlen( init );

	or	rax, -1
	npad	8
$LL50@CreateStru:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL50@CreateStru

; 616  :                     *init++= ' ';
; 617  :                     continue;

	mov	rbp, QWORD PTR tokenarray$[rsp]
	add	rbx, rax
	mov	BYTE PTR [rbx], 32			; 00000020H
	inc	rbx
	jmp	SHORT $LN2@CreateStru
$LN55@CreateStru:
	mov	rbp, QWORD PTR tokenarray$[rsp]
$LN17@CreateStru:

; 618  :                 }
; 619  :             }
; 620  :             memcpy( init, tokenarray[i].tokpos, tokenarray[i+1].tokpos - tokenarray[i].tokpos );

	mov	rdx, QWORD PTR [rdi+24]
	mov	rcx, rbx
	mov	r8, QWORD PTR [r12]
	sub	r8, rdx
	call	memcpy

; 621  :             init += tokenarray[i+1].tokpos - tokenarray[i].tokpos;

	mov	rax, QWORD PTR [r12]
	sub	rax, QWORD PTR [rdi+24]
	add	rbx, rax
$LN2@CreateStru:

; 608  :         for ( i = loc+1; tokenarray[i].token != T_FINAL; i++ ) {

	inc	r15
	add	r12, 32					; 00000020H
	mov	rdi, r15
	shl	rdi, 5
	add	rdi, rbp
	cmp	BYTE PTR [rdi], 0
	jne	$LL4@CreateStru
	mov	r12d, DWORD PTR mem_type$[rsp]
$LN3@CreateStru:

; 622  :         }
; 623  :         *init = NULLC;

	mov	BYTE PTR [rbx], 0

; 624  :         f = LclAlloc( sizeof( struct sfield ) + ( init - StringBufferEnd ) );

	sub	rbx, QWORD PTR ModuleInfo+488
	lea	rcx, QWORD PTR [rbx+112]
	call	LclAlloc

; 625  :         //f->value = LclAlloc( init - StringBufferEnd + 1 );
; 626  :         memset( f, 0, sizeof( struct sfield ) );

	xor	edx, edx
	mov	rcx, rax
	mov	rdi, rax
	lea	r8d, QWORD PTR [rdx+112]
	call	memset

; 627  :         strcpy( f->ivalue, StringBufferEnd );

	mov	rax, QWORD PTR ModuleInfo+488
	lea	rdx, QWORD PTR [rdi+104]
	npad	13
$LL36@CreateStru:
	movzx	ecx, BYTE PTR [rax]
	lea	rax, QWORD PTR [rax+1]
	mov	BYTE PTR [rdx], cl
	lea	rdx, QWORD PTR [rdx+1]
	test	cl, cl
	jne	SHORT $LL36@CreateStru

; 628  :         DebugMsg1(("CreateStructField(%s): initializer=>%s<\n", CurrStruct->sym.name, f->ivalue ));
; 629  : 
; 630  :     } else {

	mov	r15, QWORD PTR si$1$[rsp]
	jmp	SHORT $LN15@CreateStru
$LN14@CreateStru:

; 631  :         f = LclAlloc( sizeof( struct sfield ) );

	mov	ecx, 112				; 00000070H
	call	LclAlloc

; 632  :         memset( f, 0, sizeof( struct sfield ) );

	xor	edx, edx
	mov	rcx, rax
	mov	rdi, rax
	lea	r8d, QWORD PTR [rdx+112]
	call	memset

; 633  :         DebugMsg1(("CreateStructField(%s): no initializer<\n", CurrStruct->sym.name ));
; 634  :         //f->init_dir = NULL;
; 635  :         f->ivalue[0] = NULLC;

	mov	BYTE PTR [rdi+104], 0
$LN15@CreateStru:

; 636  :     }
; 637  : 
; 638  :     /* create the struct field symbol */
; 639  : 
; 640  :     //sym = SymAlloc( name );
; 641  :     f->sym.name_size = len;

	mov	BYTE PTR [rdi+72], r14b

; 642  :     if ( len ) {

	test	r14d, r14d
	je	SHORT $LN19@CreateStru

; 643  :         f->sym.name = LclAlloc( len + 1 );

	lea	eax, DWORD PTR [r14+1]
	movsxd	rcx, eax
	call	LclAlloc

; 644  :         memcpy( f->sym.name, name, len );

	movsxd	rbx, r14d
	mov	rdx, r13
	mov	r8, rbx
	mov	QWORD PTR [rdi+8], rax
	mov	rcx, rax
	call	memcpy

; 645  :         f->sym.name[len] = NULLC;

	mov	rax, QWORD PTR [rdi+8]
	mov	BYTE PTR [rbx+rax], 0

; 646  :     } else

	jmp	SHORT $LN20@CreateStru
$LN19@CreateStru:

; 647  :         f->sym.name = "";

	lea	rax, OFFSET FLAT:$SG11325
	mov	QWORD PTR [rdi+8], rax
$LN20@CreateStru:

; 648  :     f->sym.state = SYM_STRUCT_FIELD;
; 649  :     f->sym.list = ModuleInfo.cref;
; 650  :     f->sym.isdefined = TRUE;
; 651  :     f->sym.mem_type = mem_type;
; 652  :     f->sym.type = vartype;

	mov	rbx, QWORD PTR vartype$[rsp]
	mov	DWORD PTR [rdi+32], 6
	mov	eax, DWORD PTR ModuleInfo+408
	or	BYTE PTR [rdi+40], 2
	shr	eax, 12
	xor	al, BYTE PTR [rdi+41]
	and	al, 1
	mov	DWORD PTR [rdi+36], r12d
	xor	BYTE PTR [rdi+41], al
	mov	QWORD PTR [rdi+80], rbx

; 653  :     /* fields total/first_size, total/first_length are set in data_item() */
; 654  :     // sym->total_size = SizeFromMemtype( mem_type, ModuleInfo.Ofssize );
; 655  : 
; 656  :     f->next = NULL;

	mov	QWORD PTR [rdi+96], 0

; 657  :     //f->sym = sym;
; 658  : 
; 659  :     if( si->head == NULL ) {

	cmp	QWORD PTR [r15], 0
	jne	SHORT $LN21@CreateStru

; 660  :         si->head = si->tail = f;

	mov	QWORD PTR [r15], rdi

; 661  :     } else {

	jmp	SHORT $LN56@CreateStru
$LN21@CreateStru:

; 662  :         si->tail->next = f;

	mov	rax, QWORD PTR [r15+8]
	mov	QWORD PTR [rax+96], rdi
$LN56@CreateStru:

; 663  :         si->tail = f;

	mov	QWORD PTR [r15+8], rdi

; 664  :     }
; 665  : 
; 666  : #if 1
; 667  :     /* v2.0: for STRUCTs, don't use the struct's size for alignment calculations,
; 668  :      * instead use the size of the "max" member!
; 669  :      */
; 670  :     if ( mem_type == MT_TYPE &&

	cmp	r12d, 196				; 000000c4H
	jne	SHORT $LN52@CreateStru
	movzx	eax, BYTE PTR [rbx+66]
	dec	al
	cmp	al, 1
	ja	SHORT $LN52@CreateStru

; 671  :         ( vartype->typekind == TYPE_STRUCT ||
; 672  :          vartype->typekind == TYPE_UNION ) ) {
; 673  :         size = vartype->max_mbr_size;

	mov	ecx, DWORD PTR [rbx+48]
	jmp	SHORT $LN23@CreateStru
$LN52@CreateStru:
	mov	ecx, DWORD PTR size$[rsp]
$LN23@CreateStru:

; 674  :     }
; 675  : #endif
; 676  :     /* align the field if an alignment argument was given */
; 677  :     if ( si->alignment > 1 ) {

	movzx	eax, BYTE PTR [r15+28]
	cmp	al, 1
	jbe	SHORT $LN53@CreateStru

; 678  :         //enum memtype mt;
; 679  :         //struct dsym *tdir;
; 680  :         DebugMsg1(("CreateStructField(%s): align=%u, size=%u, ofs=%u\n", CurrStruct->sym.name, si->alignment, size, offset ));
; 681  :         /* if it's the first field to add, use offset of the parent's current field */
; 682  : #if 0
; 683  :         /* v2: removed. An embedded struct is now added AFTER it has
; 684  :          * been parsed. */
; 685  :         if ( offset == 0 && CurrStruct->next ) {
; 686  :             struct dsym *parent = CurrStruct->next;
; 687  :             if ( si->alignment < size )
; 688  :                 parent->e.structinfo->tail->sym->offset =
; 689  :                     (parent->e.structinfo->tail->sym->offset + (si->alignment - 1)) & ( - si->alignment);
; 690  :             else if ( size )
; 691  :                 parent->e.structinfo->tail->sym->offset =
; 692  :                     (parent->e.structinfo->tail->sym->offset + (size - 1)) & (-size);
; 693  :         } else
; 694  : #endif
; 695  :         {
; 696  :             if ( si->alignment < size )

	movzx	eax, al
	cmp	eax, ecx
	jae	SHORT $LN26@CreateStru

; 697  :                 offset = (offset + (si->alignment - 1)) & ( - si->alignment);

	dec	esi
	add	esi, eax
	jmp	SHORT $LN57@CreateStru
$LN26@CreateStru:

; 698  :             else if ( size )

	test	ecx, ecx
	je	SHORT $LN28@CreateStru

; 699  :                 offset = (offset + (size - 1)) & (-size);

	dec	esi
	mov	eax, ecx
	add	esi, ecx
$LN57@CreateStru:
	neg	eax
	and	esi, eax
$LN28@CreateStru:

; 700  :         }
; 701  :         /* adjust the struct's current offset + size.
; 702  :          The field's size is added in UpdateStructSize()
; 703  :          */
; 704  :         if ( CurrStruct->sym.typekind != TYPE_UNION ) {

	mov	rax, QWORD PTR CurrStruct
	cmp	BYTE PTR [rax+66], 2
	je	SHORT $LN30@CreateStru

; 705  :             CurrStruct->sym.offset = offset;

	mov	DWORD PTR [rax+16], esi

; 706  :             if ( offset > CurrStruct->sym.total_size )

	mov	rax, QWORD PTR CurrStruct
	cmp	esi, DWORD PTR [rax+56]
	jbe	SHORT $LN30@CreateStru

; 707  :                 CurrStruct->sym.total_size = offset;

	mov	DWORD PTR [rax+56], esi
$LN53@CreateStru:
	mov	rax, QWORD PTR CurrStruct
$LN30@CreateStru:

; 708  :         }
; 709  :     }
; 710  :     /* v2.0: for padding, save the max member size */
; 711  :     if ( size > CurrStruct->sym.max_mbr_size ) {

	cmp	ecx, DWORD PTR [rax+48]
	jbe	SHORT $LN31@CreateStru

; 712  :         DebugMsg1(("CreateStructField(%s): max_mbr_size set to %u\n", CurrStruct->sym.name, size ));
; 713  :         CurrStruct->sym.max_mbr_size = size;

	mov	DWORD PTR [rax+48], ecx
$LN31@CreateStru:

; 714  :     }
; 715  :     f->sym.offset = offset;

	mov	DWORD PTR [rdi+16], esi

; 716  : 
; 717  :     /* if -Zm is on, create a global symbol */
; 718  :     if ( ModuleInfo.oldstructs == TRUE && *name != NULLC ) {

	test	DWORD PTR ModuleInfo+408, 256		; 00000100H
	je	SHORT $LN34@CreateStru
	cmp	BYTE PTR [r13], 0
	je	SHORT $LN34@CreateStru

; 719  :         DebugMsg(("CreateStructField(%s): Masm51 compat on, lookup %s in global symbol table\n", CurrStruct->sym.name, name ));
; 720  :         gsym  = SymLookup( name );

	mov	rcx, r13
	call	SymLookup
	mov	rdx, rax

; 721  :         /* v2.11: cannot fail */
; 722  :         //if ( gsym ) {
; 723  :             if ( gsym->state == SYM_UNDEFINED )

	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN33@CreateStru

; 724  :                 gsym->state = SYM_STRUCT_FIELD;

	mov	DWORD PTR [rax+32], 6
$LN33@CreateStru:

; 725  :             if ( gsym->state == SYM_STRUCT_FIELD ) {

	cmp	DWORD PTR [rax+32], 6
	jne	SHORT $LN34@CreateStru

; 726  :                 struct dsym *dir;
; 727  :                 gsym->mem_type = mem_type;

	mov	DWORD PTR [rax+36], r12d

; 728  :                 gsym->type = vartype;

	mov	QWORD PTR [rax+80], rbx

; 729  :                 gsym->offset = offset; /* added v2.0 */

	mov	DWORD PTR [rax+16], esi

; 730  :                 /* v2.01: must be the full offset.
; 731  :                  * (there's still a problem if alignment is > 1!)
; 732  :                  */
; 733  :                 for ( dir = CurrStruct->next; dir; dir = dir->next )

	mov	rax, QWORD PTR CurrStruct
	mov	rcx, QWORD PTR [rax+104]
	test	rcx, rcx
	je	SHORT $LN6@CreateStru
$LL7@CreateStru:

; 734  :                     gsym->offset += dir->sym.offset;

	add	esi, DWORD PTR [rcx+16]
	mov	DWORD PTR [rdx+16], esi
	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL7@CreateStru
$LN6@CreateStru:

; 735  :                 gsym->isdefined = TRUE;

	or	BYTE PTR [rdx+40], 2
$LN34@CreateStru:

; 736  :             }
; 737  :         //}
; 738  :     }
; 739  : 
; 740  :     return( &f->sym );

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+128]

; 741  : }

	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
CreateStructField ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
pi$ = 80
tokenarray$ = 88
pti$ = 96
GetQualifiedType PROC

; 812  : {

$LN85:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 813  :     int             type;
; 814  :     int             tmp;
; 815  :     enum memtype    mem_type;
; 816  :     int             i = *pi;

	movsxd	rsi, DWORD PTR [rcx]

; 817  :     int             distance = FALSE;

	xor	r12d, r12d

; 818  :     struct asym     *sym;
; 819  : 
; 820  :     /* convert PROC token to a type qualifier */
; 821  :     for ( tmp = i; tokenarray[tmp].token != T_FINAL && tokenarray[tmp].token != T_COMMA; tmp++ )

	mov	rax, rsi
	mov	rbx, r8
	shl	rax, 5
	mov	r10, rdx
	mov	r13, rcx
	mov	r15d, r12d
	mov	r8, rsi
	cmp	BYTE PTR [rax+rdx], r12b
	lea	r9, QWORD PTR [rax+rdx]
	je	SHORT $LN80@GetQualifi
	mov	rdx, r9
	npad	5
$LL4@GetQualifi:
	movzx	eax, BYTE PTR [rdx]
	cmp	al, 44					; 0000002cH
	je	SHORT $LN80@GetQualifi

; 822  :         if ( tokenarray[tmp].token == T_DIRECTIVE && tokenarray[tmp].tokval == T_PROC ) {

	cmp	al, 3
	jne	SHORT $LN2@GetQualifi
	cmp	DWORD PTR [rdx+16], 433			; 000001b1H
	jne	SHORT $LN2@GetQualifi

; 823  :             tokenarray[tmp].token = T_STYPE;

	mov	BYTE PTR [rdx], 6

; 824  :             /* v2.06: avoid to use ST_PROC */
; 825  :             tokenarray[tmp].tokval = ( ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) ? T_FAR : T_NEAR );

	mov	eax, 1
	mov	ecx, DWORD PTR ModuleInfo+360
	shl	eax, cl
	test	al, 112					; 00000070H
	mov	eax, r12d
	setne	al
	add	eax, 221				; 000000ddH
	mov	DWORD PTR [rdx+16], eax
$LN2@GetQualifi:

; 818  :     struct asym     *sym;
; 819  : 
; 820  :     /* convert PROC token to a type qualifier */
; 821  :     for ( tmp = i; tokenarray[tmp].token != T_FINAL && tokenarray[tmp].token != T_COMMA; tmp++ )

	inc	r8
	mov	rax, r8
	shl	rax, 5
	cmp	BYTE PTR [rax+r10], r12b
	lea	rdx, QWORD PTR [rax+r10]
	jne	SHORT $LL4@GetQualifi
$LN80@GetQualifi:

; 826  :         }
; 827  :     /* with NEAR/FAR, there are several syntax variants allowed:
; 828  :      * 1. NEARxx | FARxx
; 829  :      * 2. PTR NEARxx | FARxx
; 830  :      * 3. NEARxx | FARxx PTR [<type>]
; 831  :      */
; 832  :     /* read qualified type */
; 833  :     for ( type = ERROR; tokenarray[i].token == T_STYPE || tokenarray[i].token == T_BINARY_OPERATOR; i++ ) {

	lea	rdx, QWORD PTR [r9+16]
	or	r14d, -1
	lea	r9, OFFSET FLAT:SpecialTable
$LL7@GetQualifi:
	movzx	eax, BYTE PTR [rdx-16]
	cmp	al, 6
	je	SHORT $LN77@GetQualifi
	cmp	al, 5
	jne	$LN71@GetQualifi

; 852  :                 break;
; 853  :             }
; 854  :         } else if ( tokenarray[i].tokval == T_PTR ) {

	cmp	DWORD PTR [rdx], 258			; 00000102H
	jne	$LN71@GetQualifi

; 855  :             /* v2.06: avoid to use ST_PTR */
; 856  :             //type = ST_PTR;
; 857  :             type = EMPTY;
; 858  :             pti->is_ptr++;

	inc	BYTE PTR [rbx+20]
	inc	esi
	add	rdx, 32					; 00000020H
	mov	r14d, -2
	jmp	SHORT $LL7@GetQualifi
$LN77@GetQualifi:

; 834  :         if ( tokenarray[i].token == T_STYPE ) {
; 835  :             tmp = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR [rdx]

; 836  :             if ( type == ERROR )

	cmp	r14d, -1
	cmove	r14d, eax

; 837  :                 type = tmp;
; 838  :             mem_type = GetMemtypeSp( tmp );

	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	r8d, BYTE PTR [r9+rcx*4+10]
	lea	eax, DWORD PTR [r8-129]
	cmp	eax, 1
	ja	SHORT $LN13@GetQualifi

; 839  :             if ( mem_type == MT_FAR || mem_type == MT_NEAR ) {
; 840  :                 if ( distance == FALSE ) {

	test	r15d, r15d
	jne	SHORT $LN16@GetQualifi

; 841  :                     uint_8 Ofssize = GetSflagsSp( tmp );

	movzx	ecx, BYTE PTR [r9+rcx*4+4]

; 842  :                     pti->is_far = ( mem_type == MT_FAR );

	cmp	r8d, 130				; 00000082H
	sete	al
	mov	BYTE PTR [rbx+21], al

; 843  :                     if ( Ofssize != USE_EMPTY )

	cmp	cl, 254					; 000000feH
	je	SHORT $LN18@GetQualifi

; 844  :                         pti->Ofssize = Ofssize;

	mov	BYTE PTR [rbx+22], cl
$LN18@GetQualifi:

; 826  :         }
; 827  :     /* with NEAR/FAR, there are several syntax variants allowed:
; 828  :      * 1. NEARxx | FARxx
; 829  :      * 2. PTR NEARxx | FARxx
; 830  :      * 3. NEARxx | FARxx PTR [<type>]
; 831  :      */
; 832  :     /* read qualified type */
; 833  :     for ( type = ERROR; tokenarray[i].token == T_STYPE || tokenarray[i].token == T_BINARY_OPERATOR; i++ ) {

	inc	esi

; 845  :                     distance = TRUE;

	mov	r15d, 1
	add	rdx, 32					; 00000020H
	jmp	SHORT $LL7@GetQualifi
$LN16@GetQualifi:

; 846  :                 } else if ( tokenarray[i-1].tokval != T_PTR )

	cmp	DWORD PTR [rdx-32], 258			; 00000102H
	jne	SHORT $LN71@GetQualifi

; 826  :         }
; 827  :     /* with NEAR/FAR, there are several syntax variants allowed:
; 828  :      * 1. NEARxx | FARxx
; 829  :      * 2. PTR NEARxx | FARxx
; 830  :      * 3. NEARxx | FARxx PTR [<type>]
; 831  :      */
; 832  :     /* read qualified type */
; 833  :     for ( type = ERROR; tokenarray[i].token == T_STYPE || tokenarray[i].token == T_BINARY_OPERATOR; i++ ) {

	inc	esi
	add	rdx, 32					; 00000020H
	jmp	$LL7@GetQualifi
$LN13@GetQualifi:

; 847  :                     break;
; 848  :             } else {
; 849  :                 if ( pti->is_ptr )

	cmp	BYTE PTR [rbx+20], r12b
	je	SHORT $LN20@GetQualifi

; 850  :                     pti->ptr_memtype = mem_type;

	mov	DWORD PTR [rbx+24], r8d
$LN20@GetQualifi:

; 851  :                 i++;

	inc	esi
$LN71@GetQualifi:
	mov	QWORD PTR [rsp+80], rbp
	mov	QWORD PTR [rsp+88], rdi

; 859  :         } else
; 860  :             break;
; 861  :     }
; 862  : 
; 863  :     /* v2.06: don't use ST_PTR anymore! */
; 864  :     //if ( type == ST_PTR ) {
; 865  :     if ( type == EMPTY ) {

	cmp	r14d, -2
	jne	$LN24@GetQualifi

; 866  :         if ( tokenarray[i].token == T_ID && tokenarray[i-1].tokval == T_PTR ) {

	movsxd	rbp, esi
	shl	rbp, 5
	add	rbp, r10
	cmp	BYTE PTR [rbp], 8
	jne	$LN40@GetQualifi
	cmp	DWORD PTR [rbp-16], 258			; 00000102H
	jne	$LN40@GetQualifi

; 867  :             pti->symtype = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rbp+8]
	call	SymFind
	mov	QWORD PTR [rbx+8], rax
	mov	rdi, rax

; 868  :             if ( pti->symtype == NULL || pti->symtype->state == SYM_UNDEFINED )

	test	rax, rax
	je	$LN27@GetQualifi
	mov	eax, DWORD PTR [rax+32]
	test	eax, eax
	je	$LN27@GetQualifi

; 870  :             else if ( pti->symtype->state != SYM_TYPE ) {

	cmp	eax, 7
	je	SHORT $LN28@GetQualifi

; 871  :                 return( EmitErr( INVALID_QUALIFIED_TYPE, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rbp+8]
	lea	ecx, QWORD PTR [r14+87]
	call	EmitErr
	jmp	$LN1@GetQualifi
$LN28@GetQualifi:

; 872  :             } else {
; 873  :                 sym = pti->symtype;
; 874  :                 /* if it's a typedef, simplify the info */
; 875  :                 if ( sym->typekind == TYPE_TYPEDEF ) {

	cmp	BYTE PTR [rdi+66], 3
	jne	$LN39@GetQualifi

; 876  :                     pti->is_ptr     += sym->is_ptr;

	movzx	eax, BYTE PTR [rdi+45]
	add	BYTE PTR [rbx+20], al

; 877  :                     if ( sym->is_ptr == 0 ) {

	cmp	BYTE PTR [rdi+45], r12b
	jne	SHORT $LN31@GetQualifi

; 878  :                         /* v2.06b: alias types have MT_TYPE, dont use for ptr_memtype! */
; 879  :                         //pti->ptr_memtype = sym->mem_type;
; 880  :                         pti->ptr_memtype = ( sym->mem_type != MT_TYPE ? sym->mem_type : MT_EMPTY );

	mov	eax, DWORD PTR [rdi+36]
	mov	ecx, 192				; 000000c0H
	cmp	eax, 196				; 000000c4H
	cmovne	ecx, eax
	mov	DWORD PTR [rbx+24], ecx

; 881  :                         if ( distance == FALSE && pti->is_ptr == 1 &&

	test	r15d, r15d
	jne	SHORT $LN33@GetQualifi
	cmp	BYTE PTR [rbx+20], 1
	jne	SHORT $LN33@GetQualifi
	mov	eax, DWORD PTR [rdi+36]
	add	eax, -128				; ffffffffffffff80H
	cmp	eax, 2
	ja	SHORT $LN33@GetQualifi

; 882  :                             ( sym->mem_type == MT_NEAR ||
; 883  :                              sym->mem_type == MT_PROC ||
; 884  :                              sym->mem_type == MT_FAR ) )
; 885  :                             pti->is_far = sym->isfar;
; 886  :                             if ( sym->Ofssize != USE_EMPTY )
; 887  :                                 pti->Ofssize = sym->Ofssize;
; 888  :                     } else {

	jmp	SHORT $LN82@GetQualifi
$LN31@GetQualifi:

; 889  :                         pti->ptr_memtype = sym->ptr_memtype;

	movzx	eax, BYTE PTR [rdi+46]
	mov	DWORD PTR [rbx+24], eax

; 890  :                         if ( distance == FALSE && pti->is_ptr == 1 ) {

	test	r15d, r15d
	jne	SHORT $LN37@GetQualifi
	cmp	BYTE PTR [rbx+20], 1
	jne	SHORT $LN37@GetQualifi
$LN82@GetQualifi:

; 891  :                             pti->is_far = sym->isfar;

	movzx	eax, BYTE PTR [rdi+47]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR [rbx+21], al
$LN33@GetQualifi:

; 892  :                             if ( sym->Ofssize != USE_EMPTY )

	movzx	eax, BYTE PTR [rdi+44]
	cmp	al, 254					; 000000feH
	je	SHORT $LN37@GetQualifi

; 893  :                                 pti->Ofssize = sym->Ofssize;

	mov	BYTE PTR [rbx+22], al
$LN37@GetQualifi:

; 894  :                         }
; 895  :                     }
; 896  :                     if ( sym->mem_type == MT_TYPE )

	cmp	DWORD PTR [rdi+36], 196			; 000000c4H
	jne	SHORT $LN38@GetQualifi

; 897  :                         pti->symtype  = sym->type;

	mov	rax, QWORD PTR [rdi+80]
	mov	QWORD PTR [rbx+8], rax
	jmp	SHORT $LN39@GetQualifi
$LN38@GetQualifi:

; 898  :                     else {
; 899  :                         DebugMsg1(("GetQualifiedType: memtype=%X, symtype set by target_type\n", sym->mem_type ));
; 900  :                         pti->symtype  = sym->target_type;

	mov	rax, QWORD PTR [rdi+48]
	mov	QWORD PTR [rbx+8], rax
	jmp	SHORT $LN39@GetQualifi
$LN27@GetQualifi:

; 869  :                 pti->symtype = CreateTypeSymbol( pti->symtype, tokenarray[i].string_ptr, TRUE );

	test	rdi, rdi
	je	SHORT $LN63@GetQualifi
	mov	rdx, rdi
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table
	jmp	SHORT $LN68@GetQualifi
$LN63@GetQualifi:
	mov	rcx, QWORD PTR [rbp+8]
	call	SymCreate
	mov	rdi, rax
$LN68@GetQualifi:
	test	rdi, rdi
	je	SHORT $LN65@GetQualifi
	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rdi+32], 7
	mov	BYTE PTR [rdi+66], r12b
	call	LclAlloc
	mov	QWORD PTR [rdi+96], rax
	mov	QWORD PTR [rax], r12
	mov	QWORD PTR [rax+8], r12
	mov	WORD PTR [rax+28], r12w
$LN65@GetQualifi:
	mov	QWORD PTR [rbx+8], rdi
$LN39@GetQualifi:

; 901  :                     }
; 902  :                 }
; 903  :             }
; 904  :             i++;

	inc	esi

; 905  :         }
; 906  :     }
; 907  : 
; 908  :     if( type == ERROR ) {

	lea	r9, OFFSET FLAT:SpecialTable
$LN40@GetQualifi:

; 947  :         if ( pti->is_ptr )

	cmp	BYTE PTR [rbx+20], r12b
	je	$LN55@GetQualifi

; 948  :             pti->mem_type = MT_PTR;

	mov	DWORD PTR [rbx+16], 195			; 000000c3H
	jmp	$LN56@GetQualifi
$LN24@GetQualifi:

; 905  :         }
; 906  :     }
; 907  : 
; 908  :     if( type == ERROR ) {

	cmp	r14d, -1
	jne	SHORT $LN40@GetQualifi

; 909  :         if ( tokenarray[i].token != T_ID ) {

	movsxd	rax, esi
	shl	rax, 5
	lea	rdi, QWORD PTR [rax+r10]
	movzx	eax, BYTE PTR [rax+r10]
	cmp	al, 8
	je	SHORT $LN42@GetQualifi

; 910  :             if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_COMMA )

	test	al, al
	je	SHORT $LN45@GetQualifi
	cmp	al, 44					; 0000002cH
	je	SHORT $LN45@GetQualifi

; 912  :             else {
; 913  :                 EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rdi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 914  :                 i++;
; 915  :             }
; 916  :             return( ERROR );

	or	eax, r14d
	jmp	$LN1@GetQualifi
$LN45@GetQualifi:

; 911  :                 EmitError( QUALIFIED_TYPE_EXPECTED );

	mov	ecx, 86					; 00000056H
	call	EmitError

; 914  :                 i++;
; 915  :             }
; 916  :             return( ERROR );

	or	eax, -1
	jmp	$LN1@GetQualifi
$LN42@GetQualifi:

; 917  :         }
; 918  :         pti->symtype = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rdi+8]
	call	SymFind
	mov	QWORD PTR [rbx+8], rax
	mov	rcx, rax

; 919  :         if( pti->symtype == NULL || pti->symtype->state != SYM_TYPE ) {

	test	rax, rax
	je	SHORT $LN50@GetQualifi
	mov	eax, DWORD PTR [rax+32]
	cmp	eax, 7
	jne	SHORT $LN47@GetQualifi

; 926  :         }
; 927  :         sym = pti->symtype;
; 928  :         if ( sym->typekind == TYPE_TYPEDEF ) {

	cmp	BYTE PTR [rcx+66], 3
	jne	SHORT $LN51@GetQualifi

; 929  :             pti->mem_type = sym->mem_type;

	mov	eax, DWORD PTR [rcx+36]
	mov	DWORD PTR [rbx+16], eax

; 930  :             pti->is_far   = sym->isfar;

	movzx	eax, BYTE PTR [rcx+47]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR [rbx+21], al

; 931  :             pti->is_ptr   = sym->is_ptr;

	movzx	eax, BYTE PTR [rcx+45]
	mov	BYTE PTR [rbx+20], al

; 932  :             pti->Ofssize  = sym->Ofssize;

	movzx	eax, BYTE PTR [rcx+44]
	mov	BYTE PTR [rbx+22], al

; 933  :             pti->size     = sym->total_size;

	mov	eax, DWORD PTR [rcx+56]
	mov	DWORD PTR [rbx], eax

; 934  :             pti->ptr_memtype = sym->ptr_memtype;

	movzx	eax, BYTE PTR [rcx+46]
	mov	DWORD PTR [rbx+24], eax

; 935  :             if ( sym->mem_type == MT_TYPE )

	cmp	DWORD PTR [rcx+36], 196			; 000000c4H
	jne	SHORT $LN53@GetQualifi

; 936  :                 pti->symtype  = sym->type;

	mov	rax, QWORD PTR [rcx+80]

; 943  :             pti->size = sym->total_size;
; 944  :         }
; 945  :         i++;

	inc	esi
	mov	QWORD PTR [rbx+8], rax

; 946  :     } else {

	jmp	SHORT $LN58@GetQualifi
$LN53@GetQualifi:

; 937  :             else {
; 938  :                 DebugMsg1(("GetQualifiedType: memtype=%X, symtype set by target_type\n", sym->mem_type ));
; 939  :                 pti->symtype  = sym->target_type;

	mov	rax, QWORD PTR [rcx+48]

; 943  :             pti->size = sym->total_size;
; 944  :         }
; 945  :         i++;

	inc	esi
	mov	QWORD PTR [rbx+8], rax

; 946  :     } else {

	jmp	SHORT $LN58@GetQualifi
$LN51@GetQualifi:

; 940  :             }
; 941  :         } else {
; 942  :             pti->mem_type = MT_TYPE;

	mov	DWORD PTR [rbx+16], 196			; 000000c4H

; 943  :             pti->size = sym->total_size;
; 944  :         }
; 945  :         i++;

	inc	esi
	mov	eax, DWORD PTR [rcx+56]
	mov	DWORD PTR [rbx], eax

; 946  :     } else {

	jmp	SHORT $LN58@GetQualifi
$LN47@GetQualifi:

; 923  :             else
; 924  :                 EmitErr( INVALID_QUALIFIED_TYPE, tokenarray[i].string_ptr );

	mov	ecx, 85					; 00000055H
	test	eax, eax
	jne	SHORT $LN83@GetQualifi
$LN50@GetQualifi:

; 920  :             DebugMsg(("GetQualifiedType: invalid type : %s\n", tokenarray[i].string_ptr ));
; 921  :             if ( pti->symtype == NULL || pti->symtype ->state == SYM_UNDEFINED )
; 922  :                 EmitErr( SYMBOL_NOT_DEFINED, tokenarray[i].string_ptr );

	mov	ecx, 102				; 00000066H
$LN83@GetQualifi:
	mov	rdx, QWORD PTR [rdi+8]
	call	EmitErr

; 925  :             return( ERROR );

	or	eax, -1
	jmp	SHORT $LN1@GetQualifi
$LN55@GetQualifi:

; 949  :         else
; 950  :             pti->mem_type = GetMemtypeSp( type );

	movsxd	rax, r14d
	lea	rdx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR [r9+rdx*4+10]
	mov	DWORD PTR [rbx+16], eax
$LN56@GetQualifi:

; 951  :         if ( pti->mem_type == MT_PTR )

	mov	ecx, DWORD PTR [rbx+16]

; 952  :             pti->size = SizeFromMemtype( pti->is_far ? MT_FAR : MT_NEAR, pti->Ofssize, NULL );

	movzx	edx, BYTE PTR [rbx+22]
	cmp	ecx, 195				; 000000c3H
	jne	SHORT $LN57@GetQualifi
	cmp	BYTE PTR [rbx+21], r12b
	setne	r12b
	lea	ecx, DWORD PTR [r12+129]
$LN57@GetQualifi:

; 953  :         else
; 954  :             pti->size = SizeFromMemtype( pti->mem_type, pti->Ofssize, NULL );

	xor	r8d, r8d
	call	SizeFromMemtype
	mov	DWORD PTR [rbx], eax
$LN58@GetQualifi:

; 955  :     }
; 956  :     *pi = i;

	mov	DWORD PTR [r13], esi

; 957  :     DebugMsg1(("GetQualifiedType: i=%u, memtype=%Xh, ptr=%u, far=%u, ofssize=%d, arbtype=%s:%X\n",
; 958  :                i, pti->mem_type, pti->is_ptr, pti->is_far, pti->Ofssize,
; 959  :                pti->symtype ? pti->symtype->name : "NULL",
; 960  :                pti->symtype ? pti->symtype->mem_type : 0 ));
; 961  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@GetQualifi:

; 962  : }

	mov	rdi, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rsi
	ret	0
GetQualifiedType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
tstruct$ = 64
name$ = 72
poffset$ = 80
level$ = 88
SearchNameInStruct PROC

; 85   : {

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], r8
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, r8
	mov	rbp, rdx

; 86   :     int len = strlen( name );

	or	rdi, -1
	npad	5
$LL23@SearchName:
	inc	rdi
	cmp	BYTE PTR [rdi+rdx], 0
	jne	SHORT $LL23@SearchName

; 87   :     struct sfield *fl = ((struct dsym *)tstruct)->e.structinfo->head;

	mov	rbx, QWORD PTR [rcx+96]

; 88   :     struct asym *sym = NULL;

	xor	esi, esi
	mov	rbx, QWORD PTR [rbx]

; 89   : 
; 90   :     //if (ModuleInfo.oldstructs == TRUE) {
; 91   :     //    return( SymSearch( name ) );
; 92   :     //}
; 93   :     if ( level >= MAX_STRUCT_NESTING ) {

	cmp	r9d, 32					; 00000020H
	jl	SHORT $LN5@SearchName

; 94   :         EmitError( NESTING_LEVEL_TOO_DEEP );

	lea	ecx, QWORD PTR [rsi+100]
	call	EmitError

; 95   :         return( NULL );

	xor	eax, eax

; 122  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN5@SearchName:

; 96   :     }
; 97   :     level++;

	inc	r9d
	mov	DWORD PTR level$[rsp], r9d

; 98   :     for ( ; fl; fl = fl->next ) {

	test	rbx, rbx
	je	$LN22@SearchName
$LL4@SearchName:

; 99   :         /* recursion: if member has no name, check if it is a structure
; 100  :          and scan this structure's fieldlist then */
; 101  :         if ( *( fl->sym.name ) == NULLC ) {

	mov	rdx, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rdx], 0
	jne	SHORT $LN6@SearchName

; 102  :             /* there are 2 cases: an anonymous inline struct ... */
; 103  :             if ( fl->sym.state == SYM_TYPE ) {

	cmp	DWORD PTR [rbx+32], 7
	jne	SHORT $LN8@SearchName

; 104  :                 if ( sym = SearchNameInStruct( &fl->sym, name, poffset, level ) ) {

	mov	rcx, rbx
$LN27@SearchName:
	mov	rdx, rbp
	mov	r8, rax
	call	SearchNameInStruct
	mov	rsi, rax
	test	rax, rax
	je	SHORT $LN25@SearchName

; 105  :                     *poffset += fl->sym.offset;

	mov	eax, DWORD PTR [rbx+16]
	mov	rcx, QWORD PTR poffset$[rsp]
	add	DWORD PTR [rcx], eax

; 118  :             break;
; 119  :         }
; 120  :     }
; 121  :     return( sym );

	mov	rax, rsi

; 122  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN8@SearchName:

; 106  :                     break;
; 107  :                 }
; 108  :             /* or an anonymous structured field */
; 109  :             } else if ( fl->sym.mem_type == MT_TYPE ) {

	cmp	DWORD PTR [rbx+36], 196			; 000000c4H
	jne	SHORT $LN2@SearchName

; 110  :                 if ( sym = SearchNameInStruct( fl->sym.type, name, poffset, level ) ) {

	mov	rcx, QWORD PTR [rbx+80]

; 111  :                     *poffset += fl->sym.offset;
; 112  :                     break;
; 113  :                 }
; 114  :             }

	jmp	SHORT $LN27@SearchName
$LN6@SearchName:

; 115  :         } else if ( len == fl->sym.name_size && SymCmpFunc( name, fl->sym.name, len ) == 0 ) {

	movzx	eax, BYTE PTR [rbx+72]
	cmp	edi, eax
	jne	SHORT $LN24@SearchName
	movsxd	r8, edi
	mov	rcx, rbp
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN18@SearchName
$LN25@SearchName:
	mov	r9d, DWORD PTR level$[rsp]
$LN24@SearchName:
	mov	rax, QWORD PTR poffset$[rsp]
$LN2@SearchName:

; 98   :     for ( ; fl; fl = fl->next ) {

	mov	rbx, QWORD PTR [rbx+96]
	test	rbx, rbx
	jne	SHORT $LL4@SearchName

; 118  :             break;
; 119  :         }
; 120  :     }
; 121  :     return( sym );

	mov	rax, rsi

; 122  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN18@SearchName:

; 116  :             DebugMsg(("SearchNameInStruct: '%s' found in struct %s\n", name, tstruct->name ));
; 117  :             sym = &fl->sym;

	mov	rsi, rbx
$LN22@SearchName:

; 118  :             break;
; 119  :         }
; 120  :     }
; 121  :     return( sym );

	mov	rax, rsi

; 122  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
SearchNameInStruct ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
sym$ = 48
name$ = 56
global$ = 64
CreateTypeSymbol PROC

; 61   : {

$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 62   :     struct struct_info *si;
; 63   : 
; 64   :     if ( sym )

	test	rcx, rcx
	je	SHORT $LN2@CreateType

; 65   :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table
	jmp	SHORT $LN7@CreateType
$LN2@CreateType:

; 66   :     else
; 67   :         sym = ( global ? SymCreate( name ) : SymAlloc( name ) );

	mov	rcx, rdx
	test	r8b, r8b
	je	SHORT $LN6@CreateType
	call	SymCreate
	jmp	SHORT $LN9@CreateType
$LN6@CreateType:
	call	SymAlloc
$LN9@CreateType:
	mov	rbx, rax
$LN7@CreateType:

; 68   : 
; 69   :     if ( sym ) {

	test	rbx, rbx
	je	SHORT $LN8@CreateType

; 70   :         sym->state = SYM_TYPE;
; 71   :         sym->typekind = TYPE_NONE;
; 72   :         ((struct dsym *)sym)->e.structinfo = si = LclAlloc( sizeof( struct struct_info ) );

	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rbx+32], 7
	mov	BYTE PTR [rbx+66], 0
	call	LclAlloc

; 73   :         si->head = NULL;

	xor	ecx, ecx
	mov	QWORD PTR [rbx+96], rax
	mov	QWORD PTR [rax], rcx

; 74   :         si->tail = NULL;

	mov	QWORD PTR [rax+8], rcx

; 75   :         si->alignment = 0;

	mov	WORD PTR [rax+28], cx
$LN8@CreateType:

; 76   :         si->flags = 0;
; 77   :     }
; 78   :     return( sym );

	mov	rax, rbx

; 79   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
CreateTypeSymbol ENDP
_TEXT	ENDS
END
