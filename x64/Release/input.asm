; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	commentbuffer:QWORD
COMM	FileCur:QWORD
COMM	LineCur:QWORD
COMM	token_stringbuf:QWORD
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG10932 DB	01H DUP (?)
$SG10936 DB	01H DUP (?)
$SG10937 DB	01H DUP (?)
$SG10938 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG10915 DB	'%s(%u) : ', 00H
	ORG $+2
$SG10916 DB	'%s : ', 00H
	ORG $+2
$SG10961 DB	'rb', 00H
	ORG $+1
$SG10935 DB	'MacroLoop', 00H
	ORG $+2
$SG10989 DB	'rb', 00H
	ORG $+1
$SG10991 DB	'rb', 00H
	ORG $+1
$SG11022 DB	';', 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	sprintf
PUBLIC	GetLineNumber
PUBLIC	GetFNamePart
PUBLIC	GetExtPart
PUBLIC	SearchFile
PUBLIC	GetTextLine
PUBLIC	PushMacro
PUBLIC	SetLineNumber
PUBLIC	AddStringToIncludePath
PUBLIC	InputInit
PUBLIC	InputPassInit
PUBLIC	InputFini
PUBLIC	PushInputStatus
PUBLIC	PopInputStatus
PUBLIC	GetCurrSrcPos
PUBLIC	ClearSrcStack
PUBLIC	get_curr_srcfile
PUBLIC	set_curr_srcfile
PUBLIC	GetFName
PUBLIC	UpdateLineNumber
PUBLIC	print_source_nesting_structure
EXTRN	isspace:PROC
EXTRN	fclose:PROC
EXTRN	fopen:PROC
EXTRN	getc:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	strchr:PROC
EXTRN	_stricmp:PROC
EXTRN	EmitErr:PROC
EXTRN	PrintNote:PROC
EXTRN	ErrnoStr:PROC
EXTRN	MemAlloc:PROC
EXTRN	MemFree:PROC
EXTRN	LclAlloc:PROC
EXTRN	fill_placeholders:PROC
EXTRN	DeleteLineQueue:PROC
EXTRN	memcpy:PROC
EXTRN	ModuleInfo:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	8

SrcFree	DQ	01H DUP (?)
srclinebuffer DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN8
	DD	imagerel $LN8+90
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$SearchFile DD imagerel $LN64
	DD	imagerel $LN64+517
	DD	imagerel $unwind$SearchFile
$pdata$GetTextLine DD imagerel $LN26
	DD	imagerel $LN26+330
	DD	imagerel $unwind$GetTextLine
$pdata$PushMacro DD imagerel $LN8
	DD	imagerel $LN8+84
	DD	imagerel $unwind$PushMacro
$pdata$AddStringToIncludePath DD imagerel $LN34
	DD	imagerel $LN34+72
	DD	imagerel $unwind$AddStringToIncludePath
$pdata$0$AddStringToIncludePath DD imagerel $LN34+72
	DD	imagerel $LN34+144
	DD	imagerel $chain$0$AddStringToIncludePath
$pdata$2$AddStringToIncludePath DD imagerel $LN34+144
	DD	imagerel $LN34+318
	DD	imagerel $chain$2$AddStringToIncludePath
$pdata$3$AddStringToIncludePath DD imagerel $LN34+318
	DD	imagerel $LN34+324
	DD	imagerel $chain$3$AddStringToIncludePath
$pdata$InputInit DD imagerel $LN10
	DD	imagerel $LN10+220
	DD	imagerel $unwind$InputInit
$pdata$InputFini DD imagerel $LN9
	DD	imagerel $LN9+69
	DD	imagerel $unwind$InputFini
$pdata$ClearSrcStack DD imagerel $LN12
	DD	imagerel $LN12+22
	DD	imagerel $unwind$ClearSrcStack
$pdata$0$ClearSrcStack DD imagerel $LN12+22
	DD	imagerel $LN12+102
	DD	imagerel $chain$0$ClearSrcStack
$pdata$1$ClearSrcStack DD imagerel $LN12+102
	DD	imagerel $LN12+107
	DD	imagerel $chain$1$ClearSrcStack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AddFile DD imagerel AddFile
	DD	imagerel AddFile+71
	DD	imagerel $unwind$AddFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$AddFile DD imagerel AddFile+71
	DD	imagerel AddFile+209
	DD	imagerel $chain$0$AddFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$AddFile DD imagerel AddFile+209
	DD	imagerel AddFile+239
	DD	imagerel $chain$1$AddFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$FreeFiles DD imagerel FreeFiles
	DD	imagerel FreeFiles+48
	DD	imagerel $unwind$FreeFiles
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$my_fgets DD imagerel my_fgets
	DD	imagerel my_fgets+143
	DD	imagerel $unwind$my_fgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PushSrcItem DD imagerel PushSrcItem
	DD	imagerel PushSrcItem+100
	DD	imagerel $unwind$PushSrcItem
pdata	ENDS
pdata	SEGMENT
$pdata$print_source_nesting_structure DD imagerel $LN36
	DD	imagerel $LN36+41
	DD	imagerel $unwind$print_source_nesting_structure
$pdata$0$print_source_nesting_structure DD imagerel $LN36+41
	DD	imagerel $LN36+298
	DD	imagerel $chain$0$print_source_nesting_structure
$pdata$1$print_source_nesting_structure DD imagerel $LN36+298
	DD	imagerel $LN36+314
	DD	imagerel $chain$1$print_source_nesting_structure
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$open_file_in_include_path DD imagerel open_file_in_include_path
	DD	imagerel open_file_in_include_path+84
	DD	imagerel $unwind$open_file_in_include_path
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$open_file_in_include_path DD imagerel open_file_in_include_path+84
	DD	imagerel open_file_in_include_path+303
	DD	imagerel $chain$2$open_file_in_include_path
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$open_file_in_include_path DD imagerel open_file_in_include_path+303
	DD	imagerel open_file_in_include_path+318
	DD	imagerel $chain$3$open_file_in_include_path
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$open_file_in_include_path DD 021H
	DD	imagerel open_file_in_include_path
	DD	imagerel open_file_in_include_path+84
	DD	imagerel $unwind$open_file_in_include_path
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$open_file_in_include_path DD 061921H
	DD	0ce419H
	DD	0bd40aH
	DD	0a7405H
	DD	imagerel open_file_in_include_path
	DD	imagerel open_file_in_include_path+84
	DD	imagerel $unwind$open_file_in_include_path
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$open_file_in_include_path DD 060c01H
	DD	0f008320cH
	DD	06004c006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PushSrcItem DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$my_fgets DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FreeFiles DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$AddFile DD 021H
	DD	imagerel AddFile
	DD	imagerel AddFile+71
	DD	imagerel $unwind$AddFile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$AddFile DD 020521H
	DD	066405H
	DD	imagerel AddFile
	DD	imagerel AddFile+71
	DD	imagerel $unwind$AddFile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddFile DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
xdata	SEGMENT
$unwind$SearchFile DD 091501H
	DD	02c5415H
	DD	02b3415H
	DD	0260115H
	DD	0700ce00eH
	DD	0600bH
$unwind$GetTextLine DD 040a01H
	DD	08340aH
	DD	07006520aH
$unwind$PushMacro DD 020601H
	DD	030023206H
$unwind$AddStringToIncludePath DD 020601H
	DD	030023206H
$chain$0$AddStringToIncludePath DD 020521H
	DD	067405H
	DD	imagerel $LN34
	DD	imagerel $LN34+72
	DD	imagerel $unwind$AddStringToIncludePath
$chain$2$AddStringToIncludePath DD 020021H
	DD	067400H
	DD	imagerel $LN34
	DD	imagerel $LN34+72
	DD	imagerel $unwind$AddStringToIncludePath
$chain$3$AddStringToIncludePath DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+72
	DD	imagerel $unwind$AddStringToIncludePath
$unwind$InputInit DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$InputFini DD 020601H
	DD	030023206H
$unwind$ClearSrcStack DD 010401H
	DD	04204H
$chain$0$ClearSrcStack DD 020521H
	DD	043405H
	DD	imagerel $LN12
	DD	imagerel $LN12+22
	DD	imagerel $unwind$ClearSrcStack
$chain$1$ClearSrcStack DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+22
	DD	imagerel $unwind$ClearSrcStack
$unwind$print_source_nesting_structure DD 040a01H
	DD	09340aH
	DD	07006520aH
$chain$0$print_source_nesting_structure DD 020521H
	DD	086405H
	DD	imagerel $LN36
	DD	imagerel $LN36+41
	DD	imagerel $unwind$print_source_nesting_structure
$chain$1$print_source_nesting_structure DD 021H
	DD	imagerel $LN36
	DD	imagerel $LN36+41
	DD	imagerel $unwind$print_source_nesting_structure
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
;	COMDAT open_file_in_include_path
_TEXT	SEGMENT
name$ = 80
fullpath$ = 88
open_file_in_include_path PROC				; COMDAT

; 538  : {

	push	rbx
	push	rbp
	push	rsi
	push	r12
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rbp, rcx
	mov	r12, rdx

; 539  :     char            *curr;
; 540  :     char            *next;
; 541  :     int             i;
; 542  :     int             namelen;
; 543  :     FILE            *file = NULL;
; 544  : 
; 545  :     while( isspace( *name ) )

	movsx	ecx, BYTE PTR [rcx]
	xor	ebx, ebx
	call	isspace
	test	eax, eax
	je	SHORT $LN3@open_file_
$LL2@open_file_:
	movsx	ecx, BYTE PTR [rbp+1]

; 546  :         name++;

	inc	rbp
	call	isspace
	test	eax, eax
	jne	SHORT $LL2@open_file_
$LN3@open_file_:

; 547  : 
; 548  :     curr = ModuleInfo.g.IncludePath;

	mov	rsi, QWORD PTR ModuleInfo+176

; 549  :     namelen = strlen( name );

	or	r15, -1
	npad	5
$LL30@open_file_:
	cmp	BYTE PTR [r15+rbp+1], bl
	lea	r15, QWORD PTR [r15+1]
	jne	SHORT $LL30@open_file_

; 550  : 
; 551  :     DebugMsg(("open_file_in_include_path(%s) enter\n", name ));
; 552  :     for ( ; curr; curr = next ) {

	test	rsi, rsi
	je	$LN32@open_file_
	mov	QWORD PTR [rsp+80], rdi
	mov	QWORD PTR [rsp+88], r13
	mov	r13, 35184372090881			; 0000200000000801H
	mov	QWORD PTR [rsp+96], r14
	npad	3
$LL6@open_file_:

; 553  :         next = strchr( curr, INC_PATH_DELIM );

	mov	edx, 59					; 0000003bH
	mov	rcx, rsi
	call	strchr
	mov	r14, rax

; 554  :         if ( next ) {

	test	rax, rax
	je	SHORT $LN7@open_file_

; 555  :             i = next - curr;

	mov	edi, eax
	sub	edi, esi

; 556  :             next++; /* skip path delimiter char (; or :) */

	inc	r14

; 557  :         } else {

	jmp	SHORT $LN8@open_file_
$LN7@open_file_:

; 558  :             i = strlen( curr );

	or	rdi, -1
$LL29@open_file_:
	inc	rdi
	cmp	BYTE PTR [rsi+rdi], 0
	jne	SHORT $LL29@open_file_
$LN8@open_file_:

; 559  :         }
; 560  : 
; 561  :         /* v2.06: ignore
; 562  :          * - "empty" entries in PATH
; 563  :          * - entries which would cause a buffer overflow
; 564  :          */
; 565  :         if ( i == 0 || ( ( i + namelen ) >= FILENAME_MAX ) )

	test	edi, edi
	je	SHORT $LN4@open_file_
	lea	eax, DWORD PTR [rdi+r15]
	cmp	eax, 260				; 00000104H
	jge	SHORT $LN4@open_file_

; 566  :             continue;
; 567  : 
; 568  :         memcpy( fullpath, curr, i );

	movsxd	rbx, edi
	mov	rdx, rsi
	mov	r8, rbx
	mov	rcx, r12
	call	memcpy
	movzx	eax, BYTE PTR [rbx+r12-1]
	sub	al, 47					; 0000002fH
	cmp	al, 45					; 0000002dH
	ja	SHORT $LN27@open_file_
	bt	r13, rax
	jb	SHORT $LN11@open_file_
$LN27@open_file_:

; 569  :         if( fullpath[i-1] != '/'
; 570  : #if !defined(__UNIX__)
; 571  :            && fullpath[i-1] != '\\' && fullpath[i-1] != ':'
; 572  : #endif
; 573  :         ) {
; 574  :             fullpath[i] = DIR_SEPARATOR;

	mov	BYTE PTR [rbx+r12], 92			; 0000005cH

; 575  :             i++;

	inc	edi
$LN11@open_file_:

; 576  :         }
; 577  :         strcpy( fullpath+i, name );

	movsxd	rdx, edi
	mov	rax, rbp
	sub	rdx, rbp
	add	rdx, r12
$LL14@open_file_:
	movzx	ecx, BYTE PTR [rax]
	mov	BYTE PTR [rdx+rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL14@open_file_

; 578  : 
; 579  :         DebugMsg(("open_file_in_include_path: >%s<\n", fullpath ));
; 580  :         file = fopen( fullpath, "rb" );

	lea	rdx, OFFSET FLAT:$SG10961
	mov	rcx, r12
	call	fopen
	mov	rbx, rax

; 581  :         if( file ) {

	test	rax, rax
	jne	SHORT $LN36@open_file_
$LN4@open_file_:

; 550  : 
; 551  :     DebugMsg(("open_file_in_include_path(%s) enter\n", name ));
; 552  :     for ( ; curr; curr = next ) {

	mov	rsi, r14
	test	r14, r14
	jne	$LL6@open_file_

; 582  :             break;
; 583  :         }
; 584  :     }
; 585  :     DebugMsg(("open_file_in_include_path()=%p\n", file ));
; 586  :     return( file );

	mov	rax, rbx
$LN36@open_file_:
	mov	r13, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+96]

; 587  : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r12
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN32@open_file_:

; 582  :             break;
; 583  :         }
; 584  :     }
; 585  :     DebugMsg(("open_file_in_include_path()=%p\n", file ));
; 586  :     return( file );

	mov	rax, rbx

; 587  : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r12
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
open_file_in_include_path ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
print_source_nesting_structure PROC

; 508  : {

$LN36:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 509  :     struct src_item *curr;
; 510  :     unsigned        tab = 1;
; 511  : 
; 512  :     /* in main source file? */
; 513  :     if ( src_stack == NULL || src_stack->next == NULL )

	mov	rbx, QWORD PTR ModuleInfo+200
	mov	edi, 1
	test	rbx, rbx
	je	$LN6@print_sour
	cmp	QWORD PTR [rbx], 0
	je	$LN6@print_sour

; 514  :         return;
; 515  : 
; 516  :     for( curr = src_stack; curr->next ; curr = curr->next ) {

	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, 35184372090881			; 0000200000000801H
$LL4@print_sour:

; 517  :         if( curr->type == SIT_FILE ) {

	cmp	BYTE PTR [rbx+8], 0
	jne	SHORT $LN7@print_sour

; 518  :             PrintNote( NOTE_INCLUDED_BY, tab, "", GetFName( curr->srcfile )->fname, curr->line_num );

	movzx	ecx, WORD PTR [rbx+10]
	lea	r8, OFFSET FLAT:$SG10932
	mov	r9, QWORD PTR ModuleInfo+160
	mov	edx, edi
	mov	eax, DWORD PTR [rbx+24]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR [r9+rcx*8]
	mov	ecx, 123				; 0000007bH
	call	PrintNote

; 519  :             tab++;
; 520  :         } else {

	jmp	$LN10@print_sour
$LN7@print_sour:

; 521  :             //char fname[_MAX_FNAME+_MAX_EXT];
; 522  :             if (*(curr->mi->macro->name) == NULLC ) {

	mov	rax, QWORD PTR [rbx+16]
	mov	rax, QWORD PTR [rax+32]
	mov	r9, QWORD PTR [rax+8]
	cmp	BYTE PTR [r9], 0
	jne	SHORT $LN9@print_sour

; 523  :                 PrintNote( NOTE_ITERATION_MACRO_CALLED_FROM, tab, "", "MacroLoop", curr->line_num, curr->mi->macro->value + 1 );

	mov	eax, DWORD PTR [rax+16]
	lea	r9, OFFSET FLAT:$SG10935
	inc	eax
	lea	r8, OFFSET FLAT:$SG10936
	mov	DWORD PTR [rsp+40], eax
	mov	ecx, 125				; 0000007dH

; 524  :             } else {

	jmp	SHORT $LN34@print_sour
$LN9@print_sour:

; 525  :                 PrintNote( NOTE_MACRO_CALLED_FROM, tab, "", curr->mi->macro->name, curr->line_num, GetFNamePart( GetFName(((struct dsym *)curr->mi->macro)->e.macroinfo->srcfile)->fname ) ) ;

	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR [rax+24]
	mov	rax, QWORD PTR ModuleInfo+160
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	r8, rdx
	movzx	eax, BYTE PTR [rdx]
	test	al, al
	je	SHORT $LN18@print_sour
$LL19@print_sour:
	sub	al, 47					; 0000002fH
	cmp	al, 45					; 0000002dH
	ja	SHORT $LN17@print_sour
	bt	rsi, rax
	jae	SHORT $LN17@print_sour
	lea	r8, QWORD PTR [rdx+1]
$LN17@print_sour:
	movzx	eax, BYTE PTR [rdx+1]
	inc	rdx
	test	al, al
	jne	SHORT $LL19@print_sour
$LN18@print_sour:
	mov	QWORD PTR [rsp+40], r8
	mov	ecx, 124				; 0000007cH
	lea	r8, OFFSET FLAT:$SG10937
$LN34@print_sour:
	mov	eax, DWORD PTR [rbx+24]
	mov	edx, edi
	mov	DWORD PTR [rsp+32], eax
	call	PrintNote
$LN10@print_sour:

; 526  :             }
; 527  :             tab++;

	mov	rbx, QWORD PTR [rbx]
	inc	edi
	cmp	QWORD PTR [rbx], 0
	jne	$LL4@print_sour

; 528  :         }
; 529  :     }
; 530  :     PrintNote( NOTE_MAIN_LINE_CODE, tab, "", GetFName( curr->srcfile )->fname, curr->line_num );

	movzx	ecx, WORD PTR [rbx+10]
	lea	r8, OFFSET FLAT:$SG10938
	mov	r9, QWORD PTR ModuleInfo+160
	mov	edx, edi
	mov	eax, DWORD PTR [rbx+24]
	mov	rsi, QWORD PTR [rsp+64]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR [r9+rcx*8]
	mov	ecx, 126				; 0000007eH
	call	PrintNote
$LN6@print_sour:

; 531  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
print_source_nesting_structure ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
;	COMDAT PushSrcItem
_TEXT	SEGMENT
type$ = 48
pv$ = 56
PushSrcItem PROC					; COMDAT

; 416  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 417  :     struct src_item   *curr;
; 418  : 
; 419  :     if ( SrcFree ) {

	mov	r8, QWORD PTR SrcFree
	mov	rbx, rdx
	movzx	edi, cl
	test	r8, r8
	je	SHORT $LN2@PushSrcIte

; 420  :         curr = SrcFree;
; 421  :         SrcFree = curr->next;

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR SrcFree, rax

; 422  :     } else

	jmp	SHORT $LN3@PushSrcIte
$LN2@PushSrcIte:

; 423  :         curr = LclAlloc( sizeof( struct src_item ) );

	mov	ecx, 32					; 00000020H
	call	LclAlloc
	mov	r8, rax
$LN3@PushSrcIte:

; 424  :     curr->next = src_stack;

	mov	rcx, QWORD PTR ModuleInfo+200

; 425  :     src_stack = curr;
; 426  :     curr->type = type;
; 427  :     curr->content = pv;
; 428  :     curr->line_num = 0;
; 429  :     return( curr );

	mov	rax, r8
	mov	QWORD PTR [r8], rcx
	mov	QWORD PTR ModuleInfo+200, r8
	mov	QWORD PTR [r8+16], rbx

; 430  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	BYTE PTR [r8+8], dil
	mov	DWORD PTR [r8+24], 0
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
PushSrcItem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
;	COMDAT my_fgets
_TEXT	SEGMENT
buffer$ = 48
max$ = 56
fp$ = 64
my_fgets PROC						; COMDAT

; 355  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 356  :     char        *ptr = buffer;
; 357  :     char        *last = buffer + max;

	movsxd	rsi, edx
	mov	rdi, rcx
	add	rsi, rcx
	mov	rbx, rcx

; 358  :     int         c;
; 359  : 
; 360  :     c = getc( fp );

	mov	rcx, r8
	mov	rbp, r8
	call	getc

; 361  :     while( ptr < last ) {

	cmp	rbx, rsi
	jae	SHORT $LN3@my_fgets
$LL2@my_fgets:

; 362  :         switch ( c ) {

	cmp	eax, -1
	je	SHORT $LN8@my_fgets
	cmp	eax, 10
	je	SHORT $LN7@my_fgets
	cmp	eax, 13
	je	SHORT $LN6@my_fgets
	cmp	eax, 26
	je	SHORT $LN8@my_fgets

; 384  :         default:
; 385  :             *ptr++ = c;

	mov	BYTE PTR [rbx], al
	inc	rbx
$LN6@my_fgets:

; 386  :         }
; 387  :         c = getc( fp );

	mov	rcx, rbp
	call	getc
	cmp	rbx, rsi
	jb	SHORT $LL2@my_fgets
$LN3@my_fgets:

; 388  :     }
; 389  :     EmitErr( LINE_TOO_LONG );

	mov	ecx, 61					; 0000003dH
	call	EmitErr

; 390  :     *(ptr-1) = NULLC;

	mov	BYTE PTR [rbx-1], 0
$LN15@my_fgets:

; 391  :     return( buffer );

	mov	rax, rdi
$LN1@my_fgets:

; 392  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN7@my_fgets:

; 363  :         case '\r':
; 364  :             break; /* don't store CR */
; 365  :         case '\n':
; 366  :             /* fall through */
; 367  :         //case '\0': /* v2.08: */
; 368  : #ifdef DEBUG_OUT
; 369  :             if ( Parse_Pass == PASS_1 )
; 370  :                 cntflines++;
; 371  : #endif
; 372  :             *ptr = NULLC;

	mov	BYTE PTR [rbx], 0

; 373  :             return( buffer );

	jmp	SHORT $LN15@my_fgets
$LN8@my_fgets:

; 374  : #if DETECTCTRLZ
; 375  :         case 0x1a:
; 376  :             /* since source files are opened in binary mode, ctrl-z
; 377  :              * handling must be done here.
; 378  :              */
; 379  :             /* no break */
; 380  : #endif
; 381  :         case EOF:
; 382  :             *ptr = NULLC;
; 383  :             return( ptr > buffer ? buffer : NULL );

	xor	eax, eax
	mov	BYTE PTR [rbx], 0
	cmp	rbx, rdi
	cmova	rax, rdi
	jmp	SHORT $LN1@my_fgets
my_fgets ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
sym$ = 8
p$ = 16
UpdateLineNumber PROC

; 307  :     struct src_item *curr;
; 308  :     for ( curr = src_stack; curr ; curr = curr->next )

	mov	rax, QWORD PTR ModuleInfo+200
	mov	rdx, rcx
	test	rax, rax
	je	SHORT $LN3@UpdateLine
	npad	1
$LL4@UpdateLine:

; 309  :         if ( curr->type == SIT_FILE ) {

	cmp	BYTE PTR [rax+8], 0
	je	SHORT $LN8@UpdateLine

; 307  :     struct src_item *curr;
; 308  :     for ( curr = src_stack; curr ; curr = curr->next )

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL4@UpdateLine

; 311  :             break;
; 312  :         }
; 313  :     return;
; 314  : }

	ret	0
$LN8@UpdateLine:

; 310  :             sym->value = curr->line_num;

	mov	ecx, DWORD PTR [rax+24]
	mov	DWORD PTR [rdx+16], ecx
$LN3@UpdateLine:

; 311  :             break;
; 312  :         }
; 313  :     return;
; 314  : }

	ret	0
UpdateLineNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
;	COMDAT FreeFiles
_TEXT	SEGMENT
FreeFiles PROC						; COMDAT

; 241  : {

	sub	rsp, 40					; 00000028H

; 242  : #if FASTMEM==0
; 243  :     int i;
; 244  : 
; 245  :     /* remove the main src item from src stack */
; 246  :     src_stack->next = SrcFree;
; 247  :     SrcFree = src_stack;
; 248  : #endif
; 249  :     /* v2.03: set src_stack=NULL to ensure that GetCurrSrcPos()
; 250  :      * won't find something when called from main().
; 251  :      */
; 252  :     src_stack = NULL;
; 253  : 
; 254  : #if FASTMEM==0
; 255  :     /* free the "free src_items"-heap */
; 256  :     while ( SrcFree ) {
; 257  :         struct src_item *next;
; 258  :         next = SrcFree->next;
; 259  :         LclFree( SrcFree );
; 260  :         SrcFree = next;
; 261  :     };
; 262  :     for ( i = 0; i < ModuleInfo.g.cnt_fnames; i++ ) {
; 263  :         LclFree( ModuleInfo.g.FNames[i].fname );
; 264  :         //LclFree( ModuleInfo.g.FNames[i].fullname );
; 265  :     }
; 266  : #endif
; 267  :     if ( ModuleInfo.g.FNames ) {

	mov	rcx, QWORD PTR ModuleInfo+160
	mov	QWORD PTR ModuleInfo+200, 0
	test	rcx, rcx
	je	SHORT $LN2@FreeFiles

; 268  :         MemFree( ModuleInfo.g.FNames );

	call	MemFree

; 269  :         ModuleInfo.g.FNames = NULL;

	mov	QWORD PTR ModuleInfo+160, 0
$LN2@FreeFiles:

; 270  :     }
; 271  :     return;
; 272  : }

	add	rsp, 40					; 00000028H
	ret	0
FreeFiles ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
;	COMDAT AddFile
_TEXT	SEGMENT
fname$ = 48
AddFile	PROC						; COMDAT

; 192  : {

	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 193  :     unsigned    index;
; 194  : 
; 195  :     DebugMsg1(("AddFile(%s) enter, curr index=%u\n", fname, ModuleInfo.g.cnt_fnames ));
; 196  :     for( index = 0; index < ModuleInfo.g.cnt_fnames; index++ ) {

	mov	eax, DWORD PTR ModuleInfo+168
	xor	ebx, ebx
	mov	rdi, rcx
	test	eax, eax
	je	SHORT $LN3@AddFile
	npad	7
$LL4@AddFile:

; 197  :         if( filecmp( fname, ModuleInfo.g.FNames[index].fname ) == 0 ) {

	mov	rdx, QWORD PTR ModuleInfo+160
	mov	rcx, rdi
	mov	rdx, QWORD PTR [rdx+rbx*8]
	call	_stricmp
	test	eax, eax
	je	$LN12@AddFile

; 193  :     unsigned    index;
; 194  : 
; 195  :     DebugMsg1(("AddFile(%s) enter, curr index=%u\n", fname, ModuleInfo.g.cnt_fnames ));
; 196  :     for( index = 0; index < ModuleInfo.g.cnt_fnames; index++ ) {

	mov	eax, DWORD PTR ModuleInfo+168
	inc	ebx
	cmp	ebx, eax
	jb	SHORT $LL4@AddFile
$LN3@AddFile:
	mov	QWORD PTR [rsp+48], rsi

; 198  : #ifdef DEBUG_OUT
; 199  :             if ( Parse_Pass == PASS_1 )
; 200  :                 ModuleInfo.g.FNames[index].included++;
; 201  : #endif
; 202  :             return( index );
; 203  :         }
; 204  :     }
; 205  : 
; 206  :     if ( ( index % 64 ) == 0 ) {

	test	bl, 63					; 0000003fH
	jne	SHORT $LN6@AddFile

; 207  :         struct fname_item *newfn;
; 208  :         newfn = (struct fname_item *)MemAlloc( ( index + 64 ) * sizeof( struct fname_item ) );

	lea	ecx, DWORD PTR [rbx+64]
	shl	rcx, 3
	call	MemAlloc

; 209  :         if ( ModuleInfo.g.FNames ) {

	mov	rdx, QWORD PTR ModuleInfo+160
	mov	rsi, rax
	test	rdx, rdx
	je	SHORT $LN7@AddFile

; 210  :             memcpy( newfn, ModuleInfo.g.FNames, index * sizeof( struct fname_item ) );

	mov	r8d, ebx
	mov	rcx, rax
	shl	r8, 3
	call	memcpy

; 211  :             MemFree( ModuleInfo.g.FNames );

	mov	rcx, QWORD PTR ModuleInfo+160
	call	MemFree
$LN7@AddFile:

; 212  :         }
; 213  :         ModuleInfo.g.FNames = newfn;

	mov	eax, DWORD PTR ModuleInfo+168
	mov	QWORD PTR ModuleInfo+160, rsi
$LN6@AddFile:

; 214  :     }
; 215  :     ModuleInfo.g.cnt_fnames++;

	inc	eax

; 216  : 
; 217  :     /* v2.11: use name directly - allows COFF .file entries with relative paths */
; 218  :     //_splitpath( fname, NULL, NULL, name, ext );
; 219  : 
; 220  :     ModuleInfo.g.FNames[index].fname = (char *)LclAlloc( strlen( fname ) + 1 );

	lea	rsi, QWORD PTR [rbx*8]
	mov	DWORD PTR ModuleInfo+168, eax
	or	rcx, -1
	npad	8
$LL18@AddFile:
	inc	rcx
	cmp	BYTE PTR [rdi+rcx], 0
	jne	SHORT $LL18@AddFile
	inc	rcx
	call	LclAlloc
	mov	rcx, QWORD PTR ModuleInfo+160
	mov	QWORD PTR [rsi+rcx], rax
	mov	rsi, QWORD PTR [rsp+48]
$LL9@AddFile:

; 221  :     strcpy( ModuleInfo.g.FNames[index].fname, fname );

	movzx	ecx, BYTE PTR [rdi]
	lea	rdi, QWORD PTR [rdi+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL9@AddFile
$LN12@AddFile:

; 222  :     /* v2.11: field fullname removed */
; 223  :     //ModuleInfo.g.FNames[index].fullname = (char *)LclAlloc( strlen( fullname ) + 1 );
; 224  :     //strcpy( ModuleInfo.g.FNames[index].fullname, fullname );
; 225  :     DebugCmd( ModuleInfo.g.FNames[index].included = 1 );
; 226  :     return( index );

	mov	eax, ebx

; 227  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
AddFile	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
index$ = 8
GetFName PROC

; 232  :     return( ModuleInfo.g.FNames+index );

	mov	rax, QWORD PTR ModuleInfo+160
	mov	edx, ecx
	lea	rax, QWORD PTR [rax+rdx*8]

; 233  : }

	ret	0
GetFName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
file$ = 8
line_num$ = 16
set_curr_srcfile PROC

; 470  :     if ( file != 0xFFF ) /* 0xFFF is the special value for macro lines */
; 471  :         src_stack->srcfile = file;

	mov	rax, QWORD PTR ModuleInfo+200
	cmp	ecx, 4095				; 00000fffH
	je	SHORT $LN4@set_curr_s
	mov	WORD PTR [rax+10], cx

; 472  :     src_stack->line_num = line_num;

	mov	rax, QWORD PTR ModuleInfo+200
$LN4@set_curr_s:
	mov	DWORD PTR [rax+24], edx

; 473  :     return;
; 474  : }

	ret	0
set_curr_srcfile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
get_curr_srcfile PROC

; 459  :     struct src_item *curr;
; 460  :     for ( curr = src_stack; curr ; curr = curr->next )

	mov	rax, QWORD PTR ModuleInfo+200
	test	rax, rax
	je	SHORT $LN3@get_curr_s
	npad	4
$LL4@get_curr_s:

; 461  :         if ( curr->type == SIT_FILE )

	cmp	BYTE PTR [rax+8], 0
	je	SHORT $LN8@get_curr_s

; 459  :     struct src_item *curr;
; 460  :     for ( curr = src_stack; curr ; curr = curr->next )

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL4@get_curr_s
$LN3@get_curr_s:

; 463  :     return( ModuleInfo.srcfile );

	mov	eax, DWORD PTR ModuleInfo+428

; 464  : }

	ret	0
$LN8@get_curr_s:

; 462  :             return( curr->srcfile );

	movzx	eax, WORD PTR [rax+10]

; 464  : }

	ret	0
get_curr_srcfile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
ClearSrcStack PROC

; 284  : {

$LN12:
	sub	rsp, 40					; 00000028H

; 285  :     struct src_item   *nextfile;
; 286  : 
; 287  :     DeleteLineQueue();

	call	DeleteLineQueue

; 288  : 
; 289  :     /* dont close the last item (which is the main src file) */
; 290  :     for( ; src_stack->next ; src_stack = nextfile ) {

	mov	rax, QWORD PTR ModuleInfo+200
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@ClearSrcSt
	mov	QWORD PTR [rsp+32], rbx
	npad	5
$LL4@ClearSrcSt:

; 291  :         nextfile = src_stack->next;
; 292  :         if ( src_stack->type == SIT_FILE ) {

	cmp	BYTE PTR [rax+8], 0
	mov	rbx, QWORD PTR [rax]
	jne	SHORT $LN5@ClearSrcSt

; 293  :             fclose( src_stack->file );

	mov	rcx, QWORD PTR [rax+16]
	call	fclose
	mov	rax, QWORD PTR ModuleInfo+200
$LN5@ClearSrcSt:

; 294  :         }
; 295  :         //LclFree( src_stack );
; 296  :         src_stack->next = SrcFree;

	mov	rcx, QWORD PTR SrcFree
	mov	QWORD PTR [rax], rcx

; 297  :         SrcFree = src_stack;

	mov	rax, QWORD PTR ModuleInfo+200
	mov	QWORD PTR ModuleInfo+200, rbx
	cmp	QWORD PTR [rbx], 0
	mov	QWORD PTR SrcFree, rax
	mov	rax, rbx
	jne	SHORT $LL4@ClearSrcSt
	mov	rbx, QWORD PTR [rsp+32]
$LN3@ClearSrcSt:

; 298  :     }
; 299  :     return;
; 300  : }

	add	rsp, 40					; 00000028H
	ret	0
ClearSrcStack ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
buffer$ = 8
GetCurrSrcPos PROC

; 491  :     struct src_item *curr;
; 492  : 
; 493  :     for( curr = src_stack; curr; curr = curr->next ) {

	mov	rax, QWORD PTR ModuleInfo+200
	mov	r10, rcx
	test	rax, rax
	je	SHORT $LN3@GetCurrSrc
	npad	1
$LL4@GetCurrSrc:

; 494  :         if ( curr->type == SIT_FILE ) {

	cmp	BYTE PTR [rax+8], 0
	je	SHORT $LN10@GetCurrSrc

; 491  :     struct src_item *curr;
; 492  : 
; 493  :     for( curr = src_stack; curr; curr = curr->next ) {

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL4@GetCurrSrc
$LN3@GetCurrSrc:

; 496  :         }
; 497  :     }
; 498  :     *buffer = NULLC;

	mov	BYTE PTR [rcx], 0

; 499  :     return( 0 );

	xor	eax, eax

; 500  : }

	ret	0
$LN10@GetCurrSrc:

; 495  :             return( sprintf( buffer, ModuleInfo.EndDirFound == FALSE ? "%s(%" I32_SPEC "u) : " : "%s : ", GetFName( curr->srcfile )->fname , curr->line_num ) );

	mov	rcx, QWORD PTR ModuleInfo+160
	lea	r9, OFFSET FLAT:$SG10915
	movzx	edx, WORD PTR [rax+10]
	lea	r8, QWORD PTR [rcx+rdx*8]
	movzx	ecx, BYTE PTR ModuleInfo+410
	mov	r8, QWORD PTR [r8]
	lea	rdx, OFFSET FLAT:$SG10916
	and	cl, 1
	mov	rcx, r10
	cmove	rdx, r9
	mov	r9d, DWORD PTR [rax+24]
	jmp	sprintf
GetCurrSrcPos ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
newstat$ = 8
PopInputStatus PROC

; 860  :     DebugMsg1(("PopInputStatus() old=%X-%u-%X new=%X-%u-%X\n",
; 861  :                token_stringbuf, Token_Count, CurrSource,
; 862  :                newstat->token_stringbuf, newstat->token_count, newstat->currsource ));
; 863  : #ifdef __I86__
; 864  :     MemFree( CurrSource );
; 865  : #else
; 866  :     StringBufferEnd = token_stringbuf;

	mov	rax, QWORD PTR token_stringbuf
	mov	r8, rcx
	mov	QWORD PTR ModuleInfo+488, rax

; 867  : #endif
; 868  :     token_stringbuf = newstat->token_stringbuf;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR token_stringbuf, rax

; 869  :     Token_Count = newstat->token_count;

	mov	ecx, DWORD PTR [rcx+24]
	mov	DWORD PTR ModuleInfo+496, ecx

; 870  :     CurrSource = newstat->currsource;

	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR ModuleInfo+464, rax

; 871  :     if ( newstat->CurrComment ) {

	cmp	QWORD PTR [r8+16], 0
	je	SHORT $LN2@PopInputSt

; 872  :         ModuleInfo.CurrComment = commentbuffer;

	mov	rdx, QWORD PTR commentbuffer
	mov	QWORD PTR ModuleInfo+472, rdx

; 873  :         strcpy( ModuleInfo.CurrComment, newstat->CurrComment );

	mov	rcx, QWORD PTR [r8+16]
	npad	8
$LL5@PopInputSt:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL5@PopInputSt

; 874  :         *newstat->CurrComment = NULLC;

	mov	rax, QWORD PTR [r8+16]
	mov	BYTE PTR [rax], 0

; 875  :     } else

	mov	ecx, DWORD PTR ModuleInfo+496
	jmp	SHORT $LN3@PopInputSt
$LN2@PopInputSt:

; 876  :         ModuleInfo.CurrComment = NULL;

	mov	QWORD PTR ModuleInfo+472, 0
$LN3@PopInputSt:

; 877  : #ifdef __I86__
; 878  :     StringBufferEnd = newstat->stringbufferend;
; 879  :     ModuleInfo.tokenarray = newstat->tokenarray;
; 880  : #else
; 881  :     ModuleInfo.tokenarray -= Token_Count + 1;

	lea	eax, DWORD PTR [rcx+1]
	movsxd	rcx, eax
	neg	rcx
	shl	rcx, 5
	add	QWORD PTR ModuleInfo+480, rcx

; 882  : #endif
; 883  :     ModuleInfo.line_flags = newstat->line_flags; /* v2.08 */

	movzx	eax, BYTE PTR [r8+28]
	mov	BYTE PTR ModuleInfo+398, al

; 884  :     return;
; 885  : }

	ret	0
PopInputStatus ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
oldstat$ = 8
PushInputStatus PROC

; 826  :     oldstat->token_stringbuf = token_stringbuf;

	mov	rax, QWORD PTR token_stringbuf

; 827  :     oldstat->token_count = Token_Count;
; 828  :     oldstat->currsource = CurrSource;
; 829  :     /* if there's a comment, attach it to current source */
; 830  :     if ( ModuleInfo.CurrComment ) {

	or	rdx, -1
	mov	QWORD PTR [rcx], rax
	mov	r9, rcx
	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR [rcx+24], eax
	mov	rax, QWORD PTR ModuleInfo+464
	mov	QWORD PTR [rcx+8], rax
	cmp	QWORD PTR ModuleInfo+472, 0
	je	SHORT $LN2@PushInputS

; 831  :         int i = strlen( CurrSource );

	mov	rcx, QWORD PTR ModuleInfo+464
	mov	rax, rdx
	npad	7
$LL10@PushInputS:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL10@PushInputS

; 832  :         oldstat->CurrComment = CurrSource + i;

	cdqe
	add	rcx, rax
	mov	QWORD PTR [r9+16], rcx

; 833  :         strcpy( oldstat->CurrComment, ModuleInfo.CurrComment );

	mov	r8, QWORD PTR ModuleInfo+472
	npad	7
$LL5@PushInputS:
	movzx	eax, BYTE PTR [r8]
	lea	r8, QWORD PTR [r8+1]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL5@PushInputS

; 834  :     } else

	jmp	SHORT $LN3@PushInputS
$LN2@PushInputS:

; 835  :         oldstat->CurrComment = NULL;

	mov	QWORD PTR [rcx+16], 0
$LN3@PushInputS:

; 836  :     oldstat->line_flags = ModuleInfo.line_flags; /* v2.08 */

	movzx	eax, BYTE PTR ModuleInfo+398
	mov	BYTE PTR [r9+28], al

; 837  : #ifdef __I86__
; 838  :     oldstat->tokenarray = ModuleInfo.tokenarray;
; 839  :     oldstat->stringbufferend = StringBufferEnd;
; 840  :     CurrSource = MemAlloc( MAX_LINE_LEN + SIZE_TOKENARRAY + SIZE_STRINGBUFFER );
; 841  :     ModuleInfo.tokenarray = (struct asm_tok *)( CurrSource + MAX_LINE_LEN );
; 842  :     token_stringbuf = CurrSource + MAX_LINE_LEN + SIZE_TOKENARRAY;
; 843  : #else
; 844  :     token_stringbuf = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR token_stringbuf, rax

; 845  :     ModuleInfo.tokenarray += Token_Count + 1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR ModuleInfo+480
	shl	rcx, 5
	add	rax, rcx

; 846  :     CurrSource = GetAlignedPointer( CurrSource, strlen( CurrSource ) );

	mov	rcx, QWORD PTR ModuleInfo+464
	mov	QWORD PTR ModuleInfo+480, rax
	npad	4
$LL9@PushInputS:
	inc	rdx
	cmp	BYTE PTR [rcx+rdx], 0
	jne	SHORT $LL9@PushInputS
	add	rdx, 8
	and	rdx, -8
	add	rcx, rdx
	mov	QWORD PTR ModuleInfo+464, rcx

; 847  :     /*myassert( ( CurrSource + MAX_LINE_LEN ) <= (char *)ModuleInfo.tokenarray );*/
; 848  :     /*myassert( ( ModuleInfo.tokenarray + sizeof( struct asm_tok ) * MAX_TOKEN ) <= end_tokenarray ); */
; 849  :     /*myassert( ( token_stringbuf + 2 * MAX_LINE_LEN ) <= end_stringbuf ); */
; 850  : #endif
; 851  :     DebugMsg1(("PushInputStatus() stringbuf-tokencnt-currsrc old=%X-%u-%X new=%X-%X-%X\n",
; 852  :                oldstat->token_stringbuf, oldstat->token_count, oldstat->currsource,
; 853  :                token_stringbuf, ModuleInfo.tokenarray, CurrSource ));
; 854  :     return( ModuleInfo.tokenarray );
; 855  : }

	ret	0
PushInputStatus ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
InputFini PROC

; 967  : {

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 968  : #ifdef DEBUG_OUT
; 969  :     int   i;
; 970  : 
; 971  :     /* for the main source file, lines usually isn't filled yet */
; 972  :     if ( ModuleInfo.g.FNames )
; 973  :         ModuleInfo.g.FNames[ModuleInfo.srcfile].lines = src_stack->line_num;
; 974  :     for( i = 0; i < ModuleInfo.g.cnt_fnames; i++ ) {
; 975  :         if ( Options.log_all_files ) {
; 976  :             if ( ModuleInfo.g.FNames[i].included > 1 )
; 977  :                 printf("%2u: %5u *%2u %s\n", i+1, ModuleInfo.g.FNames[i].lines, ModuleInfo.g.FNames[i].included, ModuleInfo.g.FNames[i].fname );
; 978  :             else
; 979  :                 printf("%2u: %5u     %s\n", i+1, ModuleInfo.g.FNames[i].lines, ModuleInfo.g.FNames[i].fname );
; 980  :         }
; 981  :         DebugMsg(( "InputFini: idx=%u name=%s\n", i, ModuleInfo.g.FNames[i].fname ));
; 982  :     }
; 983  : #endif
; 984  :     if ( ModuleInfo.g.IncludePath )

	mov	rcx, QWORD PTR ModuleInfo+176
	test	rcx, rcx
	je	SHORT $LN2@InputFini

; 985  :         MemFree( ModuleInfo.g.IncludePath );

	call	MemFree
$LN2@InputFini:

; 986  : 
; 987  :     /* free items in ModuleInfo.g.FNames ( and FreeFile, if FASTMEM==0 ) */
; 988  :     FreeFiles();

	mov	rcx, QWORD PTR ModuleInfo+160
	xor	ebx, ebx
	mov	QWORD PTR ModuleInfo+200, rbx
	test	rcx, rcx
	je	SHORT $LN7@InputFini
	call	MemFree
	mov	QWORD PTR ModuleInfo+160, rbx
$LN7@InputFini:

; 989  : #ifdef DEBUG_OUT
; 990  :     if ( Options.quiet == FALSE ) {
; 991  :         printf("lines read(files)/processed in pass one: %" I32_SPEC "u / %" I32_SPEC "u\n", cntflines, cntlines );
; 992  :         printf("invokations: PreprocessLine=%" I32_SPEC "u/%" I32_SPEC "u/%" I32_SPEC "u, Tokenize=%" I32_SPEC "u/%" I32_SPEC "u\n", cntppl0, cntppl1, cntppl2, cnttok0, cnttok1 );
; 993  :     }
; 994  : #endif
; 995  :     ModuleInfo.tokenarray = NULL;

	mov	QWORD PTR ModuleInfo+480, rbx

; 996  : #ifdef DEBUG_OUT
; 997  :     token_stringbuf = NULL;
; 998  :     StringBufferEnd = NULL;
; 999  :     commentbuffer = NULL;
; 1000 :     CurrSource = NULL;
; 1001 : #endif
; 1002 :     LclFree( srclinebuffer );
; 1003 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
InputFini ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
InputPassInit PROC

; 954  :     DebugMsg(( "InputPassInit() enter\n" ));
; 955  :     src_stack->line_num = 0;

	mov	rax, QWORD PTR ModuleInfo+200
	mov	DWORD PTR [rax+24], 0

; 956  :     //inside_comment = NULLC;
; 957  :     CurrSource = srclinebuffer;

	mov	rax, QWORD PTR srclinebuffer
	mov	QWORD PTR ModuleInfo+464, rax

; 958  :     *CurrSource = NULLC;

	mov	BYTE PTR [rax], 0

; 959  :     StringBufferEnd = token_stringbuf;

	mov	rax, QWORD PTR token_stringbuf
	mov	QWORD PTR ModuleInfo+488, rax

; 960  :     return;
; 961  : }

	ret	0
InputPassInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
InputInit PROC

; 891  : {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 892  :     struct src_item *fl;
; 893  : #if 0
; 894  :     char        path[FILENAME_MAX];
; 895  :     char        drive[_MAX_DRIVE];
; 896  :     char        dir[_MAX_DIR];
; 897  : #endif
; 898  : 
; 899  :     DebugMsg(( "InputInit() enter\n" ));
; 900  :     //ModuleInfo.g.cnt_fnames = 0;
; 901  :     //ModuleInfo.g.FNames = NULL;
; 902  :     //IncludePath = NULL;
; 903  :     //src_stack = NULL;
; 904  :     SrcFree = NULL; /* v2.11 */
; 905  : #if FILESEQ
; 906  :     FileSeq.head = NULL;
; 907  : #endif
; 908  : #ifdef DEBUG_OUT
; 909  :     cntppl0 = 0;
; 910  :     cntppl1 = 0;
; 911  :     cntppl2 = 0;
; 912  :     cnttok0 = 0;
; 913  :     cnttok1 = 0;
; 914  :     cntflines = 0;
; 915  :     cntlines = 0;
; 916  : #endif
; 917  : 
; 918  :     /* add path of main module to the include path.
; 919  :      * v2.12: unnecessary since v2.10, since the directory part of the
; 920  :      * current source is added if a file is to be included; see SearchFile().
; 921  :      */
; 922  :     //_splitpath( CurrFName[ASM], drive, dir, NULL, NULL );
; 923  :     //if ( drive[0] || dir[0] ) {
; 924  :     //    _makepath( path, drive, dir, NULL, NULL );
; 925  :     //    AddStringToIncludePath( path );
; 926  :     //}
; 927  : 
; 928  :     srclinebuffer = LclAlloc( SIZE_SRCLINES + SIZE_TOKENARRAY + SIZE_STRINGBUFFER );

	mov	ecx, 1311744				; 00140400H
	mov	QWORD PTR SrcFree, 0
	call	LclAlloc

; 929  :     /* the comment buffer is at the end of the source line buffer */
; 930  :     commentbuffer = srclinebuffer + SIZE_SRCLINES - MAX_LINE_LEN;
; 931  :     /* behind the comment buffer is the token buffer */
; 932  :     ModuleInfo.tokenarray = (struct asm_tok *)( srclinebuffer + SIZE_SRCLINES );
; 933  :     token_stringbuf = srclinebuffer + SIZE_SRCLINES + SIZE_TOKENARRAY;
; 934  : #ifdef DEBUG_OUT
; 935  :     end_tokenarray = (struct asm_tok *)token_stringbuf;
; 936  :     end_stringbuf = token_stringbuf + SIZE_STRINGBUFFER;
; 937  :     DebugMsg(( "InputInit: srclinebuffer=%p, tokenarray=%p, token_stringbuf=%p end_stringbuf=%p\n", srclinebuffer, ModuleInfo.tokenarray, token_stringbuf, end_stringbuf ));
; 938  : #endif
; 939  : 
; 940  :     fl = PushSrcItem( SIT_FILE, CurrFile[ASM] );

	mov	rbx, QWORD PTR SrcFree
	mov	rdi, QWORD PTR ModuleInfo+96
	mov	QWORD PTR srclinebuffer, rax
	lea	rcx, QWORD PTR [rax+131072]
	mov	QWORD PTR commentbuffer, rcx
	lea	rcx, QWORD PTR [rax+132096]
	add	rax, 1180672				; 00120400H
	mov	QWORD PTR ModuleInfo+480, rcx
	mov	QWORD PTR token_stringbuf, rax
	test	rbx, rbx
	je	SHORT $LN4@InputInit
	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR SrcFree, rax
	jmp	SHORT $LN5@InputInit
$LN4@InputInit:
	mov	ecx, 32					; 00000020H
	call	LclAlloc
	mov	rbx, rax
$LN5@InputInit:
	mov	rcx, QWORD PTR ModuleInfo+200
	mov	QWORD PTR [rbx], rcx
	mov	QWORD PTR ModuleInfo+200, rbx
	mov	BYTE PTR [rbx+8], 0
	mov	QWORD PTR [rbx+16], rdi
	mov	DWORD PTR [rbx+24], 0

; 941  :     fl->srcfile = ModuleInfo.srcfile = AddFile( CurrFName[ASM] );

	mov	rcx, QWORD PTR ModuleInfo+128
	call	AddFile
	mov	DWORD PTR ModuleInfo+428, eax
	movzx	ecx, ax
	mov	WORD PTR [rbx+10], ax

; 942  :     /* setting a function pointer won't work for text macros! */
; 943  :     //FileCur->sfunc_ptr = &GetFileCur;
; 944  :     FileCur->string_ptr = GetFName( fl->srcfile )->fname;

	mov	rax, QWORD PTR ModuleInfo+160
	movzx	ecx, WORD PTR ModuleInfo+428

; 945  : 
; 946  :     DebugMsg(( "InputInit() exit\n" ));
; 947  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	rax, QWORD PTR FileCur
	mov	QWORD PTR [rax+16], rdx
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
InputInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
string$ = 48
AddStringToIncludePath PROC

; 757  : {

$LN34:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 758  :     char *tmp;
; 759  :     int len;
; 760  : 
; 761  :     DebugMsg(("AddStringToIncludePath(%s) enter\n", string ));
; 762  :     while( isspace( *string ) )

	movsx	ecx, BYTE PTR [rcx]
	call	isspace
	test	eax, eax
	je	SHORT $LN3@AddStringT
	npad	11
$LL2@AddStringT:
	movsx	ecx, BYTE PTR [rbx+1]

; 763  :         string++;

	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL2@AddStringT
$LN3@AddStringT:

; 764  :     len = strlen( string );

	or	rcx, -1
	mov	rax, rcx
$LL25@AddStringT:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL25@AddStringT

; 765  :     if ( len == 0 )

	test	eax, eax
	je	$LN6@AddStringT

; 766  :         return;
; 767  :     if( ModuleInfo.g.IncludePath == NULL ) {

	mov	QWORD PTR [rsp+48], rdi
	mov	rdi, QWORD PTR ModuleInfo+176
	test	rdi, rdi
	jne	SHORT $LL5@AddStringT

; 768  :         ModuleInfo.g.IncludePath = MemAlloc( len + 1 );

	inc	eax
	movsxd	rcx, eax
	call	MemAlloc
	mov	QWORD PTR ModuleInfo+176, rax
	npad	6
$LL8@AddStringT:

; 769  :         strcpy( ModuleInfo.g.IncludePath, string );

	movzx	ecx, BYTE PTR [rbx]
	lea	rbx, QWORD PTR [rbx+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL8@AddStringT
	mov	rdi, QWORD PTR [rsp+48]

; 778  :     }
; 779  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
	npad	4
$LL5@AddStringT:

; 770  :     } else {
; 771  :         tmp = ModuleInfo.g.IncludePath;
; 772  :         ModuleInfo.g.IncludePath = MemAlloc( strlen( tmp ) + sizeof( INC_PATH_DELIM_STR ) +

	inc	rcx
	cmp	BYTE PTR [rdi+rcx], 0
	jne	SHORT $LL5@AddStringT
	cdqe
	add	rax, 3
	add	rcx, rax
	call	MemAlloc
	mov	QWORD PTR ModuleInfo+176, rax

; 773  :                                 len + 1 );
; 774  :         strcpy( ModuleInfo.g.IncludePath, tmp );

	mov	rdx, rdi
$LL9@AddStringT:
	movzx	ecx, BYTE PTR [rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL9@AddStringT

; 775  :         strcat( ModuleInfo.g.IncludePath, INC_PATH_DELIM_STR );

	mov	rcx, QWORD PTR ModuleInfo+176
	dec	rcx
	npad	4
$LL22@AddStringT:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL22@AddStringT
	lea	r8, OFFSET FLAT:$SG11022
	xor	edx, edx
	npad	13
$LL23@AddStringT:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL23@AddStringT

; 776  :         strcat( ModuleInfo.g.IncludePath, string );

	mov	rdx, QWORD PTR ModuleInfo+176
	dec	rdx
	npad	6
$LL20@AddStringT:
	cmp	BYTE PTR [rdx+1], 0
	lea	rdx, QWORD PTR [rdx+1]
	jne	SHORT $LL20@AddStringT
	xor	r8d, r8d
	npad	3
$LL21@AddStringT:
	movzx	eax, BYTE PTR [rbx+r8]
	mov	BYTE PTR [rdx+r8], al
	lea	r8, QWORD PTR [r8+1]
	test	al, al
	jne	SHORT $LL21@AddStringT

; 777  :         MemFree( tmp );

	mov	rcx, rdi
	call	MemFree
	mov	rdi, QWORD PTR [rsp+48]
$LN6@AddStringT:

; 778  :     }
; 779  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
AddStringToIncludePath ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
line$ = 8
SetLineNumber PROC

; 480  :     src_stack->line_num = line;

	mov	rax, QWORD PTR ModuleInfo+200
	mov	DWORD PTR [rax+24], ecx

; 481  :     return;
; 482  : }

	ret	0
SetLineNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
mi$ = 48
PushMacro PROC

; 436  : {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 437  :     DebugMsg1(( "PushMacro(%s)\n", mi->macro->name ));
; 438  :     PushSrcItem( SIT_MACRO, mi );

	mov	rdx, QWORD PTR SrcFree
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN4@PushMacro
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR SrcFree, rax
	jmp	SHORT $LN5@PushMacro
$LN4@PushMacro:
	mov	ecx, 32					; 00000020H
	call	LclAlloc
	mov	rdx, rax
$LN5@PushMacro:
	mov	rcx, QWORD PTR ModuleInfo+200
	mov	QWORD PTR [rdx], rcx
	mov	QWORD PTR ModuleInfo+200, rdx
	mov	BYTE PTR [rdx+8], 1
	mov	QWORD PTR [rdx+16], rbx
	mov	DWORD PTR [rdx+24], 0

; 439  :     return;
; 440  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
PushMacro ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
buffer$ = 64
GetTextLine PROC

; 694  : {

$LN26:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 695  :     struct src_item *curr = src_stack;

	mov	rbx, QWORD PTR ModuleInfo+200
	mov	rdi, rcx

; 696  : 
; 697  :     if ( curr->type == SIT_FILE ) {

	cmp	BYTE PTR [rbx+8], 0
	jne	SHORT $LN5@GetTextLin

; 698  : 
; 699  :         if( my_fgets( buffer, MAX_LINE_LEN, curr->file ) ) {

	mov	r8, QWORD PTR [rbx+16]
	mov	edx, 1024				; 00000400H
	call	my_fgets
	test	rax, rax
	jne	$LN11@GetTextLin

; 700  :             curr->line_num++;
; 701  : #ifdef DEBUG_OUT
; 702  :             if ( Parse_Pass == PASS_1 ) cntlines++;
; 703  : #endif
; 704  :             return( buffer );
; 705  :         }
; 706  :         DebugCmd( ModuleInfo.g.FNames[curr->srcfile].lines = curr->line_num );
; 707  :         DebugMsg1(("GetTextLine: ***** EOF file %s (idx=%u) *****\n", GetFName( curr->srcfile )->fname, curr->srcfile ));
; 708  :         /* don't close and remove main source file */
; 709  :         if ( curr->next ) {

	cmp	QWORD PTR [rbx], rax
	je	SHORT $LN8@GetTextLin

; 710  :             fclose( curr->file );

	mov	rcx, QWORD PTR [rbx+16]
	call	fclose

; 711  :             src_stack = curr->next;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR ModuleInfo+200, rax

; 712  :             curr->next = SrcFree;

	mov	rax, QWORD PTR SrcFree
	mov	QWORD PTR [rbx], rax

; 713  :             SrcFree = curr;

	mov	QWORD PTR SrcFree, rbx
$LN8@GetTextLin:

; 714  :         }
; 715  :         /* update value of @FileCur variable */
; 716  :         for( curr = src_stack; curr->type != SIT_FILE; curr = curr->next );

	mov	rax, QWORD PTR ModuleInfo+200
	cmp	BYTE PTR [rax+8], 0
	je	SHORT $LN3@GetTextLin
$LL4@GetTextLin:
	mov	rax, QWORD PTR [rax]
	cmp	BYTE PTR [rax+8], 0
	jne	SHORT $LL4@GetTextLin
$LN3@GetTextLin:

; 717  :         FileCur->string_ptr = GetFName( curr->srcfile)->fname;

	movzx	ecx, WORD PTR [rax+10]
	mov	rax, QWORD PTR ModuleInfo+160
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	rax, QWORD PTR FileCur
	mov	QWORD PTR [rax+16], rdx

; 744  :         SrcFree = curr;
; 745  :     }
; 746  : 
; 747  :     return( NULL ); /* end of file or macro reached */

	xor	eax, eax

; 748  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN5@GetTextLin:

; 718  : #if FILESEQ
; 719  :         if ( Options.line_numbers && Parse_Pass == PASS_1 )
; 720  :             AddFileSeq( curr->srcfile );
; 721  : #endif
; 722  : 
; 723  :     } else {
; 724  : 
; 725  :         curr->mi->currline = ( curr->mi->currline ? curr->mi->currline->next : curr->mi->startline );

	mov	rax, QWORD PTR [rbx+16]
	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN13@GetTextLin
	mov	rdx, QWORD PTR [rcx]
	jmp	SHORT $LN14@GetTextLin
$LN13@GetTextLin:
	mov	rdx, QWORD PTR [rax+8]
$LN14@GetTextLin:
	mov	QWORD PTR [rax], rdx

; 726  :         if ( curr->mi->currline ) {

	mov	r8, QWORD PTR [rbx+16]
	mov	rcx, QWORD PTR [r8]
	test	rcx, rcx
	je	SHORT $LN9@GetTextLin

; 727  :             /* if line contains placeholders, replace them by current values */
; 728  :             if ( curr->mi->currline->ph_count ) {

	cmp	BYTE PTR [rcx+8], 0
	je	SHORT $LN10@GetTextLin

; 729  :                 fill_placeholders( buffer,

	mov	rax, QWORD PTR [r8+24]
	lea	rdx, QWORD PTR [rcx+9]
	mov	r9d, DWORD PTR [r8+16]
	mov	rcx, rdi
	mov	r8d, DWORD PTR [r8+40]
	mov	QWORD PTR [rsp+32], rax
	call	fill_placeholders

; 735  :             }
; 736  :             curr->line_num++;

	inc	DWORD PTR [rbx+24]

; 737  : #ifdef DEBUG_OUT
; 738  :             if ( Parse_Pass == PASS_1 ) cntlines++;
; 739  : #endif
; 740  :             return( buffer );

	mov	rax, rdi

; 748  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN10@GetTextLin:

; 730  :                                   curr->mi->currline->line,
; 731  :                                   curr->mi->parmcnt,
; 732  :                                   curr->mi->localstart, curr->mi->parm_array );
; 733  :             } else {
; 734  :                 strcpy( buffer, curr->mi->currline->line );

	add	rcx, 9
	mov	rdx, rdi
	npad	10
$LL15@GetTextLin:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL15@GetTextLin
$LN11@GetTextLin:

; 735  :             }
; 736  :             curr->line_num++;

	inc	DWORD PTR [rbx+24]

; 737  : #ifdef DEBUG_OUT
; 738  :             if ( Parse_Pass == PASS_1 ) cntlines++;
; 739  : #endif
; 740  :             return( buffer );

	mov	rax, rdi

; 748  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN9@GetTextLin:

; 741  :         }
; 742  :         src_stack = curr->next;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR ModuleInfo+200, rax

; 743  :         curr->next = SrcFree;

	mov	rax, QWORD PTR SrcFree
	mov	QWORD PTR [rbx], rax

; 744  :         SrcFree = curr;
; 745  :     }
; 746  : 
; 747  :     return( NULL ); /* end of file or macro reached */

	xor	eax, eax
	mov	QWORD PTR SrcFree, rbx

; 748  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
GetTextLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
fullpath$ = 32
path$ = 336
queue$ = 344
SearchFile PROC

; 597  : {

$LN64:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 304				; 00000130H

; 598  :     FILE        *file = NULL;
; 599  :     struct src_item *fl;
; 600  :     const char  *fn;
; 601  :     bool        isabs;
; 602  :     char        fullpath[FILENAME_MAX];
; 603  : 
; 604  :     DebugMsg1(("SearchFile(%s) enter\n", path ));
; 605  : 
; 606  :     //_splitpath( path, drive, dir, fname, ext );
; 607  :     //DebugMsg1(("SearchFile(): drive=%s, dir=%s, fname=%s, ext=%s\n", drive, dir, fname, ext ));
; 608  :     fn = GetFNamePart( path );

	movzx	eax, BYTE PTR [rcx]
	movzx	r14d, dl
	mov	rdi, rcx

; 609  : 
; 610  :     /* if no absolute path is given, then search in the directory
; 611  :      * of the current source file first!
; 612  :      * v2.11: various changes because field fullpath has been removed.
; 613  :      */
; 614  : 
; 615  :     isabs = ISABS( path );

	cmp	al, 47					; 0000002fH
	je	$LN15@SearchFile
	cmp	al, 92					; 0000005cH
	je	$LN15@SearchFile
	test	al, al
	je	SHORT $LN16@SearchFile
	cmp	BYTE PTR [rcx+1], 58			; 0000003aH
	jne	SHORT $LN16@SearchFile
	movzx	eax, BYTE PTR [rcx+2]
	cmp	al, 47					; 0000002fH
	je	$LN15@SearchFile
	cmp	al, 92					; 0000005cH
	je	$LN15@SearchFile
$LN16@SearchFile:

; 616  :     //if ( dir[0] != '\\' && dir[0] != '/' ) {
; 617  :     if ( !isabs ) {
; 618  :         for ( fl = src_stack; fl ; fl = fl->next ) {

	mov	rax, QWORD PTR ModuleInfo+200
	xor	bpl, bpl
	test	rax, rax
	je	$LN59@SearchFile
$LL4@SearchFile:

; 619  :             if ( fl->type == SIT_FILE ) {

	cmp	BYTE PTR [rax+8], 0
	je	SHORT $LN46@SearchFile

; 616  :     //if ( dir[0] != '\\' && dir[0] != '/' ) {
; 617  :     if ( !isabs ) {
; 618  :         for ( fl = src_stack; fl ; fl = fl->next ) {

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL4@SearchFile

; 619  :             if ( fl->type == SIT_FILE ) {

	jmp	$LN59@SearchFile
$LN46@SearchFile:

; 620  :                 const char  *fn2;
; 621  :                 char        *src;
; 622  :                 //_splitpath( GetFName( fl->srcfile )->fname, drive2, dir2, NULL, NULL );
; 623  :                 //DebugMsg1(("SearchFile(): curr src=%s, split into drive=%s, dir=%s\n", GetFName( fl->srcfile)->fname, drive2, dir2 ));
; 624  :                 src = GetFName( fl->srcfile )->fname;

	movzx	ecx, WORD PTR [rax+10]
	mov	rax, QWORD PTR ModuleInfo+160
	mov	r9, QWORD PTR [rax+rcx*8]

; 625  :                 fn2 = GetFNamePart( src );

	mov	rcx, r9
	mov	rdx, r9
	movzx	eax, BYTE PTR [r9]
	test	al, al
	je	$LN59@SearchFile
	mov	r8, 35184372090881			; 0000200000000801H
	npad	2
$LL32@SearchFile:
	sub	al, 47					; 0000002fH
	cmp	al, 45					; 0000002dH
	ja	SHORT $LN30@SearchFile
	movsx	rax, al
	bt	r8, rax
	jae	SHORT $LN30@SearchFile
	lea	rdx, QWORD PTR [rcx+1]
$LN30@SearchFile:
	movzx	eax, BYTE PTR [rcx+1]
	inc	rcx
	test	al, al
	jne	SHORT $LL32@SearchFile

; 626  :                 if ( fn2 != src ) {

	cmp	rdx, r9
	je	SHORT $LN59@SearchFile

; 627  :                     int i = fn2 - src;

	sub	edx, r9d

; 628  :                     /* v2.10: if there's a directory part, add it to the directory part of the current file.
; 629  :                      * fixme: check that both parts won't exceed FILENAME_MAX!
; 630  :                      * fixme: 'path' is relative, but it may contain a drive letter!
; 631  :                      */
; 632  :                     memcpy( fullpath, src, i );

	lea	rcx, QWORD PTR fullpath$[rsp]
	movsxd	rbx, edx
	mov	rdx, r9
	mov	r8, rbx
	call	memcpy

; 633  :                     strcpy( fullpath + i, path );

	lea	rdx, QWORD PTR fullpath$[rsp]
	sub	rbx, rdi
	add	rdx, rbx
	mov	rcx, rdi
	npad	8
$LL19@SearchFile:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rdx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL19@SearchFile

; 634  :                     if ( file = fopen( fullpath, "rb" ) ) {

	lea	rdx, OFFSET FLAT:$SG10989
	lea	rcx, QWORD PTR fullpath$[rsp]
	call	fopen
	mov	rsi, rax
	test	rax, rax
	je	SHORT $LN59@SearchFile
$LN62@SearchFile:

; 635  :                         DebugMsg1(("SearchFile(): file found, fopen(%s)=%X\n", fullpath, file ));
; 636  :                         path = fullpath;

	lea	rdi, QWORD PTR fullpath$[rsp]
$LN12@SearchFile:

; 668  :         }
; 669  :     }
; 670  :     /* is the file to be added to the file stack?
; 671  :      * assembly files usually are, but binary files ( INCBIN ) aren't.
; 672  :      */
; 673  :     if ( queue ) {

	test	r14b, r14b
	je	$LN13@SearchFile

; 674  :         fl = PushSrcItem( SIT_FILE, file );

	mov	rbx, QWORD PTR SrcFree
	test	rbx, rbx
	je	SHORT $LN37@SearchFile
	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR SrcFree, rax
	jmp	SHORT $LN38@SearchFile
$LN15@SearchFile:

; 609  : 
; 610  :     /* if no absolute path is given, then search in the directory
; 611  :      * of the current source file first!
; 612  :      * v2.11: various changes because field fullpath has been removed.
; 613  :      */
; 614  : 
; 615  :     isabs = ISABS( path );

	mov	bpl, 1
$LN59@SearchFile:

; 637  :                     }
; 638  : #ifdef DEBUG_OUT
; 639  :                     else
; 640  :                         DebugMsg1(("SearchFile(): fopen(%s) failed\n", fullpath ));
; 641  : #endif
; 642  :                 }
; 643  :                 break;
; 644  :             }
; 645  :         }
; 646  :     }
; 647  :     if ( file == NULL ) {
; 648  :         fullpath[0] = NULLC;
; 649  :         file = fopen( path, "rb" );

	lea	rdx, OFFSET FLAT:$SG10991
	mov	BYTE PTR fullpath$[rsp], 0
	mov	rcx, rdi
	call	fopen
	mov	rsi, rax

; 650  :         DebugMsg1(("SearchFile(): fopen(%s)=%X\n", path, file ));
; 651  : 
; 652  :         /* if the file isn't found yet and include paths have been set,
; 653  :          * and NO absolute path is given, then search include dirs
; 654  :          */
; 655  :         if( file == NULL && ModuleInfo.g.IncludePath != NULL && !isabs ) {

	test	rax, rax
	jne	SHORT $LN12@SearchFile
	cmp	QWORD PTR ModuleInfo+176, rax
	je	SHORT $LN58@SearchFile
	test	bpl, bpl
	jne	SHORT $LN58@SearchFile

; 656  :             if ( file = open_file_in_include_path( path, fullpath ) ) {

	lea	rdx, QWORD PTR fullpath$[rsp]
	mov	rcx, rdi
	call	open_file_in_include_path
	mov	rsi, rax
	test	rax, rax
	jne	SHORT $LN62@SearchFile
$LN58@SearchFile:

; 657  :                 DebugMsg1(("SearchFile(): open_file_in_include_path(%s)=%X [%s]\n", path, file, fullpath ));
; 658  :                 path = fullpath;
; 659  :             }
; 660  : #ifdef DEBUG_OUT
; 661  :             else
; 662  :                 DebugMsg1(("SearchFile(): open_file_in_include_path(%s)=NULL\n", path ));
; 663  : #endif
; 664  :         }
; 665  :         if( file == NULL ) {
; 666  :             EmitErr( CANNOT_OPEN_FILE, path, ErrnoStr() );

	call	ErrnoStr
	mov	r8, rax
	mov	rdx, rdi
	mov	ecx, 106				; 0000006aH
	call	EmitErr

; 667  :             return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@SearchFile

; 674  :         fl = PushSrcItem( SIT_FILE, file );

$LN37@SearchFile:
	mov	ecx, 32					; 00000020H
	call	LclAlloc
	mov	rbx, rax
$LN38@SearchFile:
	mov	rcx, QWORD PTR ModuleInfo+200
	mov	QWORD PTR [rbx], rcx

; 675  :         fl->srcfile = AddFile( path );

	mov	rcx, rdi
	mov	QWORD PTR ModuleInfo+200, rbx
	mov	BYTE PTR [rbx+8], 0
	mov	QWORD PTR [rbx+16], rsi
	mov	DWORD PTR [rbx+24], 0
	call	AddFile
	mov	WORD PTR [rbx+10], ax

; 676  :         FileCur->string_ptr = GetFName( fl->srcfile )->fname;

	movzx	ecx, ax
	mov	rax, QWORD PTR ModuleInfo+160
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	rax, QWORD PTR FileCur
	mov	QWORD PTR [rax+16], rdx
$LN13@SearchFile:

; 677  : #if FILESEQ
; 678  :         if ( Options.line_numbers && Parse_Pass == PASS_1 )
; 679  :             AddFileSeq( fl->srcfile );
; 680  : #endif
; 681  :     }
; 682  :     return( file );

	mov	rax, rsi
$LN1@SearchFile:

; 683  : }

	lea	r11, QWORD PTR [rsp+304]
	mov	rbx, QWORD PTR [r11+40]
	mov	rbp, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
SearchFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
fname$ = 8
GetExtPart PROC

; 172  :     char *rc;
; 173  :     for( rc = NULL; *fname; fname++ ) {

	movzx	eax, BYTE PTR [rcx]
	xor	r8d, r8d
	mov	rdx, rcx
	test	al, al
	je	SHORT $LN3@GetExtPart
	mov	r9, 35184372090881			; 0000200000000801H
$LL4@GetExtPart:

; 174  :         if( *fname == '.' ) {

	cmp	al, 46					; 0000002eH
	jne	SHORT $LN5@GetExtPart

; 175  :             rc = (char *)fname;

	mov	r8, rdx
	jmp	SHORT $LN2@GetExtPart
$LN5@GetExtPart:
	sub	al, 47					; 0000002fH
	cmp	al, 45					; 0000002dH
	ja	SHORT $LN2@GetExtPart
	bt	r9, rax
	jae	SHORT $LN2@GetExtPart

; 176  :         } else if( ISPC( *fname ) ) {
; 177  :             rc = NULL;

	xor	r8d, r8d
$LN2@GetExtPart:

; 172  :     char *rc;
; 173  :     for( rc = NULL; *fname; fname++ ) {

	movzx	eax, BYTE PTR [rdx+1]
	inc	rdx
	test	al, al
	jne	SHORT $LL4@GetExtPart
$LN3@GetExtPart:

; 178  :         }
; 179  :     }
; 180  :     return( rc ? rc : (char *)fname );

	test	r8, r8
	cmovne	rdx, r8
	mov	rax, rdx

; 181  : }

	ret	0
GetExtPart ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
fname$ = 8
GetFNamePart PROC

; 160  :     const char *rc;
; 161  :     for ( rc = fname; *fname; fname++ )

	movzx	eax, BYTE PTR [rcx]
	mov	rdx, rcx
	mov	r8, rcx
	test	al, al
	je	SHORT $LN13@GetFNamePa
	mov	r9, 35184372090881			; 0000200000000801H
$LL4@GetFNamePa:
	sub	al, 47					; 0000002fH
	cmp	al, 45					; 0000002dH
	ja	SHORT $LN2@GetFNamePa
	bt	r9, rax
	jae	SHORT $LN2@GetFNamePa

; 162  :         if ( ISPC( *fname ) )
; 163  :             rc = fname + 1;

	lea	r8, QWORD PTR [rdx+1]
$LN2@GetFNamePa:

; 160  :     const char *rc;
; 161  :     for ( rc = fname; *fname; fname++ )

	movzx	eax, BYTE PTR [rdx+1]
	inc	rdx
	test	al, al
	jne	SHORT $LL4@GetFNamePa
$LN13@GetFNamePa:

; 164  :     return( rc );

	mov	rax, r8

; 165  : }

	ret	0
GetFNamePart ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
GetLineNumber PROC

; 319  :     UpdateLineNumber( LineCur, NULL );

	mov	rcx, QWORD PTR ModuleInfo+200
	mov	rdx, QWORD PTR LineCur
	test	rcx, rcx
	je	SHORT $LN14@GetLineNum
$LL6@GetLineNum:
	cmp	BYTE PTR [rcx+8], 0
	je	SHORT $LN10@GetLineNum
	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	SHORT $LL6@GetLineNum
$LN14@GetLineNum:

; 320  :     return( LineCur->uvalue );

	mov	eax, DWORD PTR [rdx+16]

; 321  : }

	ret	0
$LN10@GetLineNum:

; 319  :     UpdateLineNumber( LineCur, NULL );

	mov	eax, DWORD PTR [rcx+24]
	mov	DWORD PTR [rdx+16], eax

; 320  :     return( LineCur->uvalue );

	mov	rax, QWORD PTR LineCur
	mov	eax, DWORD PTR [rax+16]

; 321  : }

	ret	0
GetLineNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rdi, rcx

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rbx
	mov	QWORD PTR [rsp+40], rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], 0
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf
	test	eax, eax
	cmovs	eax, ebx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbx
	mov	r9, rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, rbx
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf

; 1459 :     #pragma warning(pop)
; 1460 : }

	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ebx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_Locale$ = 88
_ArgList$ = 96
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR _ArgList$[rsp]
	or	rcx, 1
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rbx
	call	__stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;
; 1391 : }

	mov	rbx, QWORD PTR [rsp+64]
	or	ecx, -1
	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ecx
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
