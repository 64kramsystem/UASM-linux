; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	CurrIfState:DWORD
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11204 DB	'if-else', 00H
_DATA	ENDS
PUBLIC	conditional_assembly_prepare
PUBLIC	GetIfNestLevel
PUBLIC	SetIfNestLevel
PUBLIC	CondCheckOpen
PUBLIC	CondInit
PUBLIC	CondAsmDirective
PUBLIC	ErrorDirective
EXTRN	isspace:PROC
EXTRN	_stricmp:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	SymFind:PROC
EXTRN	GetResWName:PROC
EXTRN	EvalOperand:PROC
EXTRN	LstWriteSrcLine:PROC
EXTRN	TextItemError:PROC
EXTRN	SearchNameInStruct:PROC
EXTRN	memcpy:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	MacroLevel:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	__ImageBase:BYTE
_BSS	SEGMENT
blocknestlevel DD 01H DUP (?)
falseblocknestlevel DD 01H DUP (?)
elseoccured DD	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$conditional_assembly_prepare DD imagerel $LN22
	DD	imagerel $LN22+317
	DD	imagerel $unwind$conditional_assembly_prepare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_defd DD imagerel check_defd
	DD	imagerel check_defd+39
	DD	imagerel $unwind$check_defd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_blank DD imagerel check_blank
	DD	imagerel check_blank+55
	DD	imagerel $unwind$check_blank
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_dif DD imagerel check_dif
	DD	imagerel check_dif+62
	DD	imagerel $unwind$check_dif
pdata	ENDS
pdata	SEGMENT
$pdata$CondAsmDirective DD imagerel $LN118
	DD	imagerel $LN118+136
	DD	imagerel $unwind$CondAsmDirective
$pdata$1$CondAsmDirective DD imagerel $LN118+136
	DD	imagerel $LN118+1412
	DD	imagerel $chain$1$CondAsmDirective
$pdata$2$CondAsmDirective DD imagerel $LN118+1412
	DD	imagerel $LN118+1500
	DD	imagerel $chain$2$CondAsmDirective
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetErrText DD imagerel GetErrText
	DD	imagerel GetErrText+126
	DD	imagerel $unwind$GetErrText
pdata	ENDS
pdata	SEGMENT
$pdata$ErrorDirective DD imagerel $LN112
	DD	imagerel $LN112+1517
	DD	imagerel $unwind$ErrorDirective
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetErrText DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_dif DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_blank DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_defd DD 010401H
	DD	04204H
xdata	ENDS
xdata	SEGMENT
$unwind$conditional_assembly_prepare DD 010401H
	DD	04204H
$unwind$CondAsmDirective DD 051401H
	DD	0140114H
	DD	06006e008H
	DD	05005H
$chain$1$CondAsmDirective DD 041421H
	DD	01b7414H
	DD	01a3408H
	DD	imagerel $LN118
	DD	imagerel $LN118+136
	DD	imagerel $unwind$CondAsmDirective
$chain$2$CondAsmDirective DD 021H
	DD	imagerel $LN118
	DD	imagerel $LN118+136
	DD	imagerel $unwind$CondAsmDirective
$unwind$ErrorDirective DD 0b2001H
	DD	01e3420H
	DD	0140120H
	DD	0e012f014H
	DD	0c00ed010H
	DD	0600b700cH
	DD	0500aH
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
opndx$ = 48
i$ = 224
value$1 = 232
tokenarray$ = 232
ErrorDirective PROC

; 453  : {

$LN112:
	mov	QWORD PTR [rsp+24], rbx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 160				; 000000a0H
	mov	rsi, rdx

; 454  :     struct expr opndx;
; 455  :     unsigned direct;
; 456  :     const char *string1;
; 457  :     const char *string2;
; 458  :     int errmsg = EMPTY;
; 459  :     int erridx = 0;
; 460  :     struct asym *sym;
; 461  :     int idloc;
; 462  : 
; 463  :     direct = tokenarray[i].tokval;

	movsxd	rax, ecx
	shl	rax, 5

; 464  : 
; 465  :     i++; /* go past directive */

	inc	ecx
	xor	r12d, r12d
	mov	r15d, DWORD PTR [rax+rdx+16]

; 466  : 
; 467  :     /* get an expression if necessary */
; 468  :     switch( GetSflagsSp( direct) ) {

	lea	rdx, OFFSET FLAT:SpecialTable+4
	mov	DWORD PTR i$[rbp-121], ecx
	lea	r8, QWORD PTR [r15+r15*2]
	mov	edx, DWORD PTR [rdx+r8*4]
	sub	edx, 1
	je	$LN12@ErrorDirec
	sub	edx, 1
	je	$LN49@ErrorDirec
	sub	edx, 1
	je	$LN40@ErrorDirec
	sub	edx, 1
	je	SHORT $LN24@ErrorDirec
	cmp	edx, 2
	jne	SHORT $LN67@ErrorDirec

; 621  :     case CC_PASS2: /* .ERR2 */
; 622  :         if ( ModuleInfo.setif2 == FALSE ) {

	test	DWORD PTR ModuleInfo+408, 1024		; 00000400H
	jne	SHORT $LN67@ErrorDirec

; 623  :             return( EmitError( IF2_NOT_ALLOWED ) );

	mov	ecx, 190				; 000000beH
	call	EmitError
	jmp	$LN1@ErrorDirec
$LN67@ErrorDirec:

; 624  :         }
; 625  :     case CC_PASS1: /* .ERR1 */
; 626  :     default: /* .ERR */
; 627  :         if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], r12b
	je	SHORT $LN69@ErrorDirec

; 628  :             erridx = i++;

	mov	r12d, ecx
	inc	ecx
	mov	DWORD PTR i$[rbp-121], ecx
$LN69@ErrorDirec:

; 629  :         }
; 630  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	je	$LN23@ErrorDirec

; 631  :             break;
; 632  :         EmitErr( FORCED_ERR, GetErrText( erridx, tokenarray ) );

	mov	rdx, rsi
	mov	ecx, r12d
	call	GetErrText
	mov	rdx, rax
	mov	ecx, 114				; 00000072H
	call	EmitErr
	jmp	$LN108@ErrorDirec
$LN24@ErrorDirec:

; 494  :         break;
; 495  :     case CC_SYMARG: /* .ERR[N]DEF */
; 496  :         /* there's a special handling of these directives in ExpandLine()! */
; 497  :         if ( tokenarray[i].token != T_ID ) {

	movsxd	rdx, ecx
	shl	rdx, 5
	add	rdx, rsi
	cmp	BYTE PTR [rdx], 8
	je	SHORT $LN25@ErrorDirec
$LN110@ErrorDirec:

; 498  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ErrorDirec
$LN25@ErrorDirec:

; 499  :         }
; 500  :         idloc = i;

	movsxd	r14, ecx
	npad	6
$LL6@ErrorDirec:

; 501  :         /* skip the next param */
; 502  :         do {
; 503  :             i++;

	inc	ecx

; 504  :         } while ( tokenarray[i].token == T_DOT || tokenarray[i].token == T_ID );

	movsxd	rax, ecx
	shl	rax, 5
	mov	DWORD PTR i$[rbp-121], ecx
	movzx	edx, BYTE PTR [rax+rsi]
	cmp	dl, 46					; 0000002eH
	je	SHORT $LL6@ErrorDirec
	cmp	dl, 8
	je	SHORT $LL6@ErrorDirec

; 505  :         if ( tokenarray[i].token == T_COMMA && tokenarray[i+1].token != T_FINAL ) {

	movsxd	rdx, ecx
	mov	rax, rdx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	jne	SHORT $LN26@ErrorDirec
	lea	rax, QWORD PTR [rdx+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], r12b
	je	SHORT $LN26@ErrorDirec

; 506  :             /* v2.05: added */
; 507  :             /* v2.08: obsolete, the expansion occurs in the preprocessor.
; 508  :              * See ExpandLine() in expans.c
; 509  :              */
; 510  :             //ExpandLineItems( tokenarray[i].tokpos, i, tokenarray, TRUE, FALSE );
; 511  :             i++;
; 512  :             erridx = i++;  /* Masm seems to accept anything as text */

	add	ecx, 2
	mov	DWORD PTR i$[rbp-121], ecx
$LN26@ErrorDirec:

; 513  :         }
; 514  : 
; 515  :         //if ( tokenarray[i].token != T_FINAL )
; 516  :         //    break;
; 517  : 
; 518  :         /* should run on pass 2 only! */
; 519  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, r12d
	je	$LN23@ErrorDirec

; 520  :             break;
; 521  : 
; 522  :         /* don't use check_defd()! */
; 523  :         /* v2.07: check for structured variables */
; 524  :         if ( Options.strict_masm_compat == FALSE &&
; 525  :             tokenarray[idloc+1].token == T_DOT &&
; 526  :             ( sym = SymSearch( tokenarray[idloc].string_ptr ) ) &&

	cmp	BYTE PTR Options+127, r12b
	jne	$LN28@ErrorDirec
	lea	rax, QWORD PTR [r14+1]
	mov	rcx, r14
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 46			; 0000002eH
	jne	$LN28@ErrorDirec
	shl	rcx, 5
	lea	r13, QWORD PTR [rcx+rsi]
	mov	rcx, QWORD PTR [rcx+rsi+8]
	call	SymFind
	mov	rdi, rax
	test	rax, rax
	je	$LN28@ErrorDirec
	cmp	DWORD PTR [rax+32], 7
	je	SHORT $LN30@ErrorDirec
	cmp	QWORD PTR [rax+80], r12
	je	$LN28@ErrorDirec
$LN30@ErrorDirec:

; 527  :             ( ( sym->state == SYM_TYPE ) || sym->type ) ) {
; 528  :             uint_32 value;
; 529  :             int j = idloc;
; 530  :             int size;
; 531  :             value = 0;

	mov	DWORD PTR value$1[rbp-121], r12d
	lea	rbx, QWORD PTR [r13+32]
	npad	13
$LL9@ErrorDirec:

; 532  :             do {
; 533  :                 j += 2;

	add	r14d, 2
	lea	rbx, QWORD PTR [rbx+64]

; 534  :                 /* if it's a structured variable, use its type! */
; 535  :                 if ( sym->state != SYM_TYPE )

	cmp	DWORD PTR [rdi+32], 7
	je	SHORT $LN31@ErrorDirec

; 536  :                     sym = sym->type;

	mov	rdi, QWORD PTR [rdi+80]
$LN31@ErrorDirec:

; 537  :                 sym = SearchNameInStruct( sym, tokenarray[j].string_ptr, &value, 0 );

	mov	rdx, QWORD PTR [rbx-24]
	lea	r8, QWORD PTR value$1[rbp-121]
	xor	r9d, r9d
	mov	rcx, rdi
	call	SearchNameInStruct
	mov	rdi, rax

; 538  :             } while ( sym && tokenarray[j+1].token == T_DOT );

	test	rax, rax
	je	SHORT $LN32@ErrorDirec
	cmp	BYTE PTR [rbx], 46			; 0000002eH
	je	SHORT $LL9@ErrorDirec
$LN32@ErrorDirec:

; 539  :             if ( tokenarray[j].token == T_ID )

	movsxd	rax, r14d
	shl	rax, 5
	lea	rdx, QWORD PTR [rax+rsi]
	movzx	eax, BYTE PTR [rax+rsi]
	cmp	al, 8
	jne	SHORT $LN33@ErrorDirec

; 540  :                 j++;

	inc	r14d
	jmp	SHORT $LN35@ErrorDirec
$LN33@ErrorDirec:

; 541  :             else if ( tokenarray[j].token != T_FINAL && tokenarray[j].token != T_COMMA ) {

	test	al, al
	je	SHORT $LN35@ErrorDirec
	cmp	al, 44					; 0000002cH
	jne	$LN110@ErrorDirec
$LN35@ErrorDirec:

; 542  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[j].string_ptr ) );
; 543  :             }
; 544  :             size = tokenarray[j].tokpos - tokenarray[idloc].tokpos;
; 545  :             memcpy( StringBufferEnd, tokenarray[idloc].tokpos, size );

	mov	rdx, QWORD PTR [r13+24]
	movsxd	rax, r14d
	shl	rax, 5
	mov	ecx, DWORD PTR [rax+rsi+24]
	sub	ecx, DWORD PTR [r13+24]
	movsxd	rbx, ecx
	mov	rcx, QWORD PTR ModuleInfo+488
	mov	r8, rbx
	call	memcpy

; 546  :             *(StringBufferEnd+size) = NULLC;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rbx+rax], r12b

; 547  :         } else {

	jmp	SHORT $LN29@ErrorDirec
$LN28@ErrorDirec:

; 548  :             sym = SymSearch( tokenarray[idloc].string_ptr );

	mov	rbx, r14
	shl	rbx, 5
	mov	rcx, QWORD PTR [rbx+rsi+8]
	call	SymFind

; 549  :             strcpy( StringBufferEnd, tokenarray[idloc].string_ptr );

	mov	rcx, QWORD PTR [rbx+rsi+8]
	mov	rdi, rax
	mov	rdx, QWORD PTR ModuleInfo+488
	npad	8
$LL73@ErrorDirec:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL73@ErrorDirec
$LN29@ErrorDirec:

; 550  :         }
; 551  :         if ( sym && sym->state == SYM_UNDEFINED )

	test	rdi, rdi
	je	SHORT $LN36@ErrorDirec
	cmp	DWORD PTR [rdi+32], r12d
	cmove	rdi, r12
$LN36@ErrorDirec:

; 552  :             sym = NULL;
; 553  : 
; 554  :         /* Masm "usually" ignores the optional errtxt! */
; 555  :         if( direct == T_DOT_ERRDEF && sym != NULL )

	cmp	r15d, 356				; 00000164H
	jne	SHORT $LN37@ErrorDirec
	test	rdi, rdi
	je	$LN108@ErrorDirec

; 556  :             EmitErr( FORCED_DEF, StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	ecx, 117				; 00000075H
	call	EmitErr
	jmp	$LN108@ErrorDirec
$LN37@ErrorDirec:

; 557  :         else if( direct == T_DOT_ERRNDEF && sym == NULL )

	cmp	r15d, 357				; 00000165H
	jne	$LN108@ErrorDirec
	test	rdi, rdi
	jne	$LN108@ErrorDirec

; 558  :             EmitErr( FORCED_NOT_DEF, StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	lea	ecx, QWORD PTR [rdi+118]
	call	EmitErr

; 559  :         break;

	jmp	$LN108@ErrorDirec
$LN40@ErrorDirec:

; 560  :     case CC_BLKARG: /* .ERR[N]B */
; 561  :         string1 = tokenarray[i].string_ptr;

	movsxd	rdx, ecx
	shl	rdx, 5
	add	rdx, rsi

; 562  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	cmp	BYTE PTR [rdx], 9
	mov	rbx, QWORD PTR [rdx+8]
	jne	$LN42@ErrorDirec
	cmp	BYTE PTR [rdx+1], 60			; 0000003cH
	jne	$LN42@ErrorDirec

; 564  :         }
; 565  :         i++;

	inc	ecx

; 566  :         if ( tokenarray[i].token == T_COMMA && tokenarray[i+1].token != T_FINAL ) {

	movsxd	rdx, ecx
	mov	rax, rdx
	mov	DWORD PTR i$[rbp-121], ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	jne	SHORT $LN43@ErrorDirec
	lea	rax, QWORD PTR [rdx+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], r12b
	je	SHORT $LN43@ErrorDirec

; 567  :             i++;
; 568  :             erridx = i++;

	lea	r12d, DWORD PTR [rcx+1]
	add	ecx, 2
	mov	DWORD PTR i$[rbp-121], ecx
$LN43@ErrorDirec:

; 569  :         }
; 570  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	je	$LN23@ErrorDirec

; 571  :             break;
; 572  :         if ( direct == T_DOT_ERRB && check_blank( string1 ) )

	cmp	r15d, 354				; 00000162H
	jne	SHORT $LN45@ErrorDirec
	mov	rcx, rbx
	call	check_blank
	test	al, al
	je	$LN108@ErrorDirec

; 573  :             errmsg = FORCED_BLANK;

	mov	edi, 119				; 00000077H
	jmp	SHORT $LN100@ErrorDirec
$LN45@ErrorDirec:

; 574  :         else if ( direct == T_DOT_ERRNB && !check_blank( string1 ) )

	cmp	r15d, 355				; 00000163H
	jne	$LN23@ErrorDirec
	mov	rcx, rbx
	call	check_blank
	test	al, al
	jne	$LN108@ErrorDirec

; 575  :             errmsg = FORCED_NOT_BLANK;

	mov	edi, 120				; 00000078H
$LN100@ErrorDirec:

; 576  :         if ( errmsg != EMPTY )
; 577  :             EmitErr( errmsg, string1, GetErrText( erridx, tokenarray ) );

	mov	rdx, rsi
	mov	ecx, r12d
	call	GetErrText
	mov	r8, rax
	mov	rdx, rbx
	mov	ecx, edi
	call	EmitErr

; 578  :         break;

	jmp	$LN108@ErrorDirec
$LN42@ErrorDirec:

; 563  :             return( TextItemError( &tokenarray[i] ) );

	mov	rcx, rdx
	call	TextItemError
	jmp	$LN1@ErrorDirec
$LN49@ErrorDirec:

; 579  :     case CC_LITARG: /* .ERRDIF[I], .ERRIDN[I] */
; 580  :         string1 = tokenarray[i].string_ptr;

	movsxd	rdx, ecx
	shl	rdx, 5
	add	rdx, rsi

; 581  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	cmp	BYTE PTR [rdx], 9
	mov	r14, QWORD PTR [rdx+8]
	jne	SHORT $LN42@ErrorDirec
	cmp	BYTE PTR [rdx+1], 60			; 0000003cH
	jne	SHORT $LN42@ErrorDirec

; 582  :             return( TextItemError( &tokenarray[i] ) );
; 583  :         }
; 584  :         i++;

	inc	ecx

; 585  :         if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rdx, ecx
	shl	rdx, 5
	mov	DWORD PTR i$[rbp-121], ecx
	cmp	BYTE PTR [rdx+rsi], 44			; 0000002cH
	je	SHORT $LN52@ErrorDirec

; 586  :             return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rsi+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	$LN1@ErrorDirec
$LN52@ErrorDirec:

; 587  :         }
; 588  :         i++;

	inc	ecx
	mov	DWORD PTR i$[rbp-121], ecx

; 589  :         string2 = tokenarray[i].string_ptr;

	movsxd	rdx, ecx
	shl	rdx, 5
	add	rdx, rsi

; 590  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	cmp	BYTE PTR [rdx], 9
	mov	rdi, QWORD PTR [rdx+8]
	jne	SHORT $LN42@ErrorDirec
	cmp	BYTE PTR [rdx+1], 60			; 0000003cH
	jne	SHORT $LN42@ErrorDirec

; 591  :             return( TextItemError( &tokenarray[i] ) );
; 592  :         }
; 593  :         i++;

	inc	ecx

; 594  :         if ( tokenarray[i].token == T_COMMA && tokenarray[i+1].token != T_FINAL ) {

	movsxd	rdx, ecx
	mov	rax, rdx
	mov	DWORD PTR i$[rbp-121], ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	jne	SHORT $LN55@ErrorDirec
	lea	rax, QWORD PTR [rdx+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], r12b
	je	SHORT $LN55@ErrorDirec

; 595  :             i++;
; 596  :             erridx = i++;

	lea	r12d, DWORD PTR [rcx+1]
	add	ecx, 2
	mov	DWORD PTR i$[rbp-121], ecx
$LN55@ErrorDirec:

; 597  :         }
; 598  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	je	$LN23@ErrorDirec

; 599  :             break;
; 600  : 
; 601  :         switch ( direct ) {

	sub	r15d, 350				; 0000015eH
	je	SHORT $LN57@ErrorDirec
	sub	r15d, 1
	je	SHORT $LN59@ErrorDirec
	cmp	r15d, 1
	je	SHORT $LN61@ErrorDirec

; 614  :         default:
; 615  :             if ( !check_dif( string1, string2, FALSE ) )

	mov	rdx, rdi
	mov	rcx, r14
	call	_stricmp
	test	eax, eax
	jne	$LN108@ErrorDirec

; 616  :                 errmsg = FORCED_IDN;

	lea	ebx, QWORD PTR [rax+122]
	jmp	SHORT $LN101@ErrorDirec
$LN61@ErrorDirec:

; 608  :                 errmsg = FORCED_DIF;
; 609  :             break;
; 610  :         case T_DOT_ERRIDN:
; 611  :             if ( !check_dif( string1, string2, TRUE ) )

	mov	r9, rdi
	mov	rax, r14
	sub	r9, r14
	npad	12
$LL105@ErrorDirec:
	movzx	r8d, BYTE PTR [rax]
	movzx	edx, BYTE PTR [rax+r9]
	sub	r8d, edx
	jne	SHORT $LN106@ErrorDirec
	inc	rax
	test	edx, edx
	jne	SHORT $LL105@ErrorDirec
$LN106@ErrorDirec:
	test	r8d, r8d
	jne	$LN23@ErrorDirec

; 612  :                 errmsg = FORCED_IDN;

	lea	ebx, QWORD PTR [r8+122]

; 613  :             break;

	jmp	SHORT $LN101@ErrorDirec
$LN59@ErrorDirec:

; 605  :             break;
; 606  :         case T_DOT_ERRDIFI:
; 607  :             if ( check_dif( string1, string2, FALSE ) )

	mov	rdx, rdi
	mov	rcx, r14
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN109@ErrorDirec
	jmp	$LN108@ErrorDirec
$LN57@ErrorDirec:

; 602  :         case T_DOT_ERRDIF:
; 603  :             if ( check_dif( string1, string2, TRUE ) )

	mov	r10, rdi
	mov	rax, r14
	sub	r10, r14
$LL103@ErrorDirec:
	movzx	r9d, BYTE PTR [rax]
	movzx	edx, BYTE PTR [rax+r10]
	sub	r9d, edx
	jne	SHORT $LN104@ErrorDirec
	inc	rax
	test	edx, edx
	jne	SHORT $LL103@ErrorDirec
$LN104@ErrorDirec:
	test	r9d, r9d
	je	$LN23@ErrorDirec
$LN109@ErrorDirec:

; 604  :                 errmsg = FORCED_DIF;

	mov	ebx, 121				; 00000079H
$LN101@ErrorDirec:

; 617  :         }
; 618  :         if ( errmsg != EMPTY )
; 619  :             EmitErr( errmsg, string1, string2, GetErrText( erridx, tokenarray ) );

	mov	rdx, rsi
	mov	ecx, r12d
	call	GetErrText
	mov	r9, rax
	mov	r8, rdi
	mov	rdx, r14
	mov	ecx, ebx
	call	EmitErr

; 620  :         break;

	jmp	$LN108@ErrorDirec
$LN12@ErrorDirec:

; 469  :     case CC_NUMARG: /* .ERR[E|NZ] */
; 470  : 
; 471  :         if (( ERROR == EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) ))

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rbp-121]
	mov	rdx, rsi
	mov	BYTE PTR [rsp+32], r12b
	lea	rcx, QWORD PTR i$[rbp-121]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN13@ErrorDirec

; 472  :             return( ERROR );

	or	eax, eax
	jmp	$LN1@ErrorDirec
$LN13@ErrorDirec:

; 473  :         if ( opndx.kind == EXPR_CONST )

	mov	eax, DWORD PTR opndx$[rbp-61]
	test	eax, eax
	je	SHORT $LN17@ErrorDirec

; 474  :             ;
; 475  :         else if ( opndx.kind == EXPR_ADDR && opndx.indirect == FALSE && opndx.sym && opndx.sym->state == SYM_UNDEFINED )

	cmp	eax, 1
	jne	SHORT $LN16@ErrorDirec
	test	BYTE PTR opndx$[rbp-45], al
	jne	SHORT $LN16@ErrorDirec
	mov	rax, QWORD PTR opndx$[rbp-41]
	test	rax, rax
	je	SHORT $LN16@ErrorDirec
	cmp	DWORD PTR [rax+32], r12d
	je	SHORT $LN17@ErrorDirec
$LN16@ErrorDirec:

; 476  :             ;//opndx.value += opndx.sym->offset;
; 477  :         else {
; 478  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN1@ErrorDirec
$LN17@ErrorDirec:

; 479  :         }
; 480  :         if ( tokenarray[i].token == T_COMMA && tokenarray[i+1].token != T_FINAL ) {

	movsxd	rcx, DWORD PTR i$[rbp-121]
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	jne	SHORT $LN18@ErrorDirec
	lea	rax, QWORD PTR [rcx+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], r12b
	je	SHORT $LN18@ErrorDirec

; 481  :             i++;
; 482  :             erridx = i++;

	lea	r12d, DWORD PTR [rcx+1]
	add	ecx, 2
	mov	DWORD PTR i$[rbp-121], ecx
$LN18@ErrorDirec:

; 483  :         }
; 484  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN23@ErrorDirec

; 485  :             break;
; 486  :         if ( direct == T_DOT_ERRNZ && opndx.value ) {

	cmp	r15d, 349				; 0000015dH
	jne	SHORT $LN20@ErrorDirec
	cmp	DWORD PTR opndx$[rbp-121], 0
	je	SHORT $LN23@ErrorDirec

; 487  :             errmsg = FORCED_NOT_ZERO;

	mov	ebx, 115				; 00000073H
	jmp	SHORT $LN102@ErrorDirec
$LN20@ErrorDirec:

; 488  :         } else if ( direct == T_DOT_ERRE && !opndx.value ) {

	cmp	r15d, 348				; 0000015cH
	jne	SHORT $LN23@ErrorDirec
	cmp	DWORD PTR opndx$[rbp-121], 0
	jne	SHORT $LN23@ErrorDirec

; 489  :             errmsg = FORCED_EQUAL;

	mov	ebx, 116				; 00000074H
$LN102@ErrorDirec:

; 490  :         }
; 491  : 
; 492  :         if ( errmsg != EMPTY )
; 493  :             EmitErr( errmsg, opndx.value, GetErrText( erridx, tokenarray ) );

	mov	rdx, rsi
	mov	ecx, r12d
	call	GetErrText
	mov	edx, DWORD PTR opndx$[rbp-121]
	mov	r8, rax
	mov	ecx, ebx
	call	EmitErr
$LN108@ErrorDirec:
	mov	ecx, DWORD PTR i$[rbp-121]
$LN23@ErrorDirec:

; 633  :         break;
; 634  :     }
; 635  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 0
	je	SHORT $LN71@ErrorDirec

; 636  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rax+rsi+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@ErrorDirec
$LN71@ErrorDirec:

; 637  :     }
; 638  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@ErrorDirec:

; 639  : }

	mov	rbx, QWORD PTR [rsp+240]
	add	rsp, 160				; 000000a0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ErrorDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
;	COMDAT GetErrText
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
GetErrText PROC						; COMDAT

; 425  : {

	sub	rsp, 40					; 00000028H

; 426  :     *StringBufferEnd = NULLC;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rax], 0

; 427  :     if ( i ) {

	test	ecx, ecx
	je	SHORT $LN11@GetErrText

; 428  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rcx, ecx
	shl	rcx, 5
	add	rcx, rdx
	cmp	BYTE PTR [rcx], 9
	jne	SHORT $LN5@GetErrText
	cmp	BYTE PTR [rcx+1], 60			; 0000003cH
	jne	SHORT $LN5@GetErrText

; 430  :         } else {
; 431  :             *(StringBufferEnd+0) = ':';

	mov	rax, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rax], 58			; 0000003aH

; 432  :             *(StringBufferEnd+1) = ' ';

	mov	rax, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rax+1], 32			; 00000020H

; 433  :             //GetLiteralValue( buffer+2, text->string_ptr );
; 434  :             strcpy( StringBufferEnd+2, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR [rcx+8]
	add	rdx, 2
	npad	5
$LL7@GetErrText:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL7@GetErrText

; 435  :         }
; 436  :     }
; 437  :     return( StringBufferEnd );

	mov	rax, QWORD PTR ModuleInfo+488

; 438  : 
; 439  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN5@GetErrText:

; 429  :             TextItemError( &tokenarray[i] );

	call	TextItemError
$LN11@GetErrText:

; 435  :         }
; 436  :     }
; 437  :     return( StringBufferEnd );

	mov	rax, QWORD PTR ModuleInfo+488

; 438  : 
; 439  : }

	add	rsp, 40					; 00000028H
	ret	0
GetErrText ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
opndx$ = 48
NextIfState$ = 192
i$ = 192
value$1 = 200
tokenarray$ = 200
CondAsmDirective PROC

; 221  : {

$LN118:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rsi
	push	r14
	lea	rbp, QWORD PTR [rsp-71]
	sub	rsp, 160				; 000000a0H
	movsxd	r8, ecx
	mov	rsi, rdx

; 222  :     int directive = tokenarray[i].tokval;

	mov	rax, r8
	shl	rax, 5

; 223  :     const char *string1;
; 224  :     const char *string2;
; 225  :     enum if_state NextIfState;
; 226  :     struct expr opndx;
; 227  : 
; 228  :     if ( CurrIfState != BLOCK_ACTIVE ) {

	cmp	DWORD PTR CurrIfState, 0
	movsxd	r14, DWORD PTR [rax+rdx+16]
	je	SHORT $LN11@CondAsmDir

; 229  :         DebugMsg1(("CondAsmDirective(%s), CurrIfState=%u(%s), lvl=%u, falselvl=%u\n",
; 230  :                    GetResWName(directive, NULL), CurrIfState, GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 231  :         if ( i || ModuleInfo.listif ) {

	test	ecx, ecx
	jne	SHORT $LN13@CondAsmDir
	test	DWORD PTR ModuleInfo+408, 8192		; 00002000H
	je	SHORT $LN12@CondAsmDir
$LN13@CondAsmDir:

; 232  :             LstWriteSrcLine();

	call	LstWriteSrcLine
$LN12@CondAsmDir:

; 233  :         }
; 234  :         return( NOT_ERROR );

	xor	eax, eax

; 421  : }

	add	rsp, 160				; 000000a0H
	pop	r14
	pop	rsi
	pop	rbp
	ret	0
$LN11@CondAsmDir:

; 235  :     }
; 236  : 
; 237  :     if ( ModuleInfo.list == TRUE ) {

	mov	edx, DWORD PTR ModuleInfo+408
	bt	edx, 11
	jae	SHORT $LN15@CondAsmDir

; 238  :         if ( MacroLevel == 0 ||
; 239  :             ModuleInfo.list_macro == LM_LISTMACROALL ||

	cmp	BYTE PTR MacroLevel, 0
	je	SHORT $LN16@CondAsmDir
	cmp	DWORD PTR ModuleInfo+400, 2
	je	SHORT $LN16@CondAsmDir
	bt	edx, 13
	jae	SHORT $LN15@CondAsmDir
$LN16@CondAsmDir:

; 240  :             ModuleInfo.listif )
; 241  :             LstWriteSrcLine();

	call	LstWriteSrcLine
	mov	r8d, DWORD PTR i$[rbp-89]
	mov	edx, DWORD PTR ModuleInfo+408
$LN15@CondAsmDir:

; 242  :     }
; 243  : 
; 244  :     DebugMsg1(("CondAsmDirective(%s), BLOCK_ACTIVE, lvl=%u, falselvl=%u [%s]\n", GetResWName(directive, NULL), blocknestlevel, falseblocknestlevel, tokenarray[i].tokpos ));
; 245  : 
; 246  :     i++; /* go past IFx, ELSEx, ENDIF */

	inc	r8d
	mov	QWORD PTR [rsp+208], rbx

; 247  : 
; 248  :     /* check params and call appropriate test routine */
; 249  : 
; 250  :     switch( GetSflagsSp(directive) ) {

	lea	rcx, QWORD PTR [r14+r14*2]
	mov	QWORD PTR [rsp+216], rdi
	lea	r9, OFFSET FLAT:__ImageBase
	mov	DWORD PTR i$[rbp-89], r8d
	mov	eax, DWORD PTR SpecialTable[r9+rcx*4+4]
	dec	eax
	cmp	eax, 5
	ja	$LN68@CondAsmDir
	mov	ecx, DWORD PTR $LN106@CondAsmDir[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN17@CondAsmDir:

; 251  :     case CC_NUMARG: /* [ELSE]IF[E] */
; 252  :         /* no forward reference allowed, symbol must be defined */
; 253  :         if ( ( ERROR == EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) ) ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rbp-89]
	mov	rdx, rsi
	mov	BYTE PTR [rsp+32], 2
	lea	rcx, QWORD PTR i$[rbp-89]
	call	EvalOperand
	xor	edi, edi
	cmp	eax, -1
	jne	SHORT $LN18@CondAsmDir

; 254  :             DebugMsg(("CondAsmDirective(%s), EvalOperand returned with ERROR\n", GetResWName(directive, NULL) ));
; 255  :             /* v2.11: don't exit, assume 0 */
; 256  :             //return( ERROR );
; 257  :             opndx.kind = EXPR_CONST;
; 258  :             opndx.value = 0;
; 259  :             i = Token_Count;

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	eax, edi
	mov	DWORD PTR opndx$[rbp-89], eax
	mov	DWORD PTR opndx$[rbp-29], edi
	mov	DWORD PTR i$[rbp-89], r8d

; 260  :         }
; 261  : #if 0 /* v2.05: obsolete */
; 262  :         if ( opndx.sym && opndx.sym->state == SYM_UNDEFINED ) {
; 263  :             EmitErr( SYMBOL_NOT_DEFINED, opndx.sym->name );
; 264  :         } else
; 265  : #endif
; 266  :         if ( opndx.kind == EXPR_CONST )

	jmp	SHORT $LN22@CondAsmDir
$LN18@CondAsmDir:
	mov	eax, DWORD PTR opndx$[rbp-29]
	test	eax, eax
	je	SHORT $LN107@CondAsmDir

; 267  :             ;
; 268  :         else if ( opndx.kind == EXPR_ADDR && opndx.indirect == FALSE ) {

	cmp	eax, 1
	jne	SHORT $LN21@CondAsmDir
	test	BYTE PTR opndx$[rbp-13], al
	jne	SHORT $LN21@CondAsmDir

; 269  :             opndx.value += opndx.sym->offset;

	mov	rax, QWORD PTR opndx$[rbp-9]

; 270  :             /* v2.07: Masm doesn't accept a relocatable item,
; 271  :              * so emit at least a warning!
; 272  :              */
; 273  :             EmitWarn( 2, CONSTANT_EXPECTED );

	mov	edx, 65					; 00000041H
	mov	ecx, DWORD PTR [rax+16]
	add	DWORD PTR opndx$[rbp-89], ecx
	lea	ecx, QWORD PTR [rdx-63]
	call	EmitWarn
$LN107@CondAsmDir:

; 274  :         } else {
; 275  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	eax, DWORD PTR opndx$[rbp-89]
	mov	r8d, DWORD PTR i$[rbp-89]
$LN22@CondAsmDir:

; 276  :         }
; 277  :         if ( directive == T_IF || directive == T_ELSEIF )

	cmp	r14d, 359				; 00000167H
	je	SHORT $LN25@CondAsmDir
	cmp	r14d, 372				; 00000174H
	je	SHORT $LN25@CondAsmDir

; 279  :         else
; 280  :             NextIfState = ( !opndx.value ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	test	eax, eax
	setne	dil
	jmp	$LN112@CondAsmDir
$LN21@CondAsmDir:

; 274  :         } else {
; 275  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN111@CondAsmDir
$LN25@CondAsmDir:

; 278  :             NextIfState = ( opndx.value ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	test	eax, eax
	mov	ebx, edi
	sete	bl

; 281  :         break;

	jmp	$LN2@CondAsmDir
$LN26@CondAsmDir:

; 282  :     case CC_LITARG: /*  [ELSE]IFDIF[I], [ELSE]IFIDN[I] */
; 283  :         string1 = tokenarray[i].string_ptr;

	movsxd	rax, r8d
	shl	rax, 5

; 284  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movzx	ecx, BYTE PTR [rax+rsi]
	mov	rbx, QWORD PTR [rax+rsi+8]
	cmp	cl, 9
	jne	$LN42@CondAsmDir
	cmp	BYTE PTR [rax+rsi+1], 60		; 0000003cH
	jne	$LN42@CondAsmDir

; 285  :             if ( tokenarray[i].token == T_ID && SymSearch( string1 ) == NULL )
; 286  :                 EmitErr( SYMBOL_NOT_DEFINED, string1 );
; 287  :             else
; 288  :                 EmitError( TEXT_ITEM_REQUIRED );
; 289  :             return( ERROR );
; 290  :         }
; 291  :         i++;

	inc	r8d

; 292  :         if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rdx, r8d
	shl	rdx, 5
	mov	DWORD PTR i$[rbp-89], r8d
	cmp	BYTE PTR [rdx+rsi], 44			; 0000002cH
	je	SHORT $LN31@CondAsmDir

; 293  :             return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rsi+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	$LN111@CondAsmDir
$LN31@CondAsmDir:

; 294  :         }
; 295  :         i++;

	inc	r8d
	mov	DWORD PTR i$[rbp-89], r8d

; 296  :         string2 = tokenarray[i].string_ptr;

	movsxd	rax, r8d
	shl	rax, 5

; 297  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movzx	ecx, BYTE PTR [rax+rsi]
	mov	rdi, QWORD PTR [rax+rsi+8]
	cmp	cl, 9
	jne	$LN33@CondAsmDir
	cmp	BYTE PTR [rax+rsi+1], 60		; 0000003cH
	jne	$LN33@CondAsmDir

; 300  :             else
; 301  :                 EmitError( TEXT_ITEM_REQUIRED );
; 302  :             return( ERROR );
; 303  :         }
; 304  :         i++;

	inc	r8d

; 305  :         DebugMsg1(("CondAsmDirective(%s), cmp >%s< and >%s<\n", GetResWName(directive, NULL), string1, string2 ));
; 306  :         switch ( directive ) {

	add	r14d, -363				; fffffffffffffe95H
	mov	DWORD PTR i$[rbp-89], r8d
	cmp	r14d, 15
	ja	$LN39@CondAsmDir
	movsxd	rax, r14d
	mov	ecx, DWORD PTR $LN105@CondAsmDir[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN36@CondAsmDir:

; 307  :         case T_IFDIF:
; 308  :         case T_ELSEIFDIF:
; 309  :             NextIfState = check_dif( string1, string2, TRUE ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	sub	rdi, rbx
	npad	8
$LL103@CondAsmDir:
	movzx	ecx, BYTE PTR [rbx]
	movzx	eax, BYTE PTR [rbx+rdi]
	sub	ecx, eax
	jne	SHORT $LN104@CondAsmDir
	inc	rbx
	test	eax, eax
	jne	SHORT $LL103@CondAsmDir
$LN104@CondAsmDir:
	test	ecx, ecx
	mov	ebx, 0
	sete	bl

; 310  :             break;

	jmp	$LN2@CondAsmDir
$LN37@CondAsmDir:

; 311  :         case T_IFDIFI:
; 312  :         case T_ELSEIFDIFI:
; 313  :             NextIfState = check_dif( string1, string2, FALSE ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	mov	rdx, rdi
	mov	rcx, rbx
	call	_stricmp

; 314  :             break;

	mov	r8d, DWORD PTR i$[rbp-89]
	test	eax, eax
	mov	ebx, 0
	sete	bl
	jmp	$LN2@CondAsmDir
$LN38@CondAsmDir:

; 315  :         case T_IFIDN:
; 316  :         case T_ELSEIFIDN:
; 317  :             NextIfState = !check_dif( string1, string2, TRUE ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	sub	rdi, rbx
$LL101@CondAsmDir:
	movzx	ecx, BYTE PTR [rbx]
	movzx	eax, BYTE PTR [rbx+rdi]
	sub	ecx, eax
	jne	SHORT $LN102@CondAsmDir
	inc	rbx
	test	eax, eax
	jne	SHORT $LL101@CondAsmDir
$LN102@CondAsmDir:
	test	ecx, ecx
	mov	ebx, 0
	setne	bl

; 318  :             break;

	jmp	$LN2@CondAsmDir
$LN39@CondAsmDir:

; 319  :         default:
; 320  :             NextIfState = !check_dif( string1, string2, FALSE ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	mov	rdx, rdi
	mov	rcx, rbx
	call	_stricmp

; 321  :         }
; 322  :         break;

	mov	r8d, DWORD PTR i$[rbp-89]
	test	eax, eax
	mov	ebx, 0
	setne	bl
	jmp	$LN2@CondAsmDir
$LN33@CondAsmDir:

; 298  :             if ( tokenarray[i].token == T_ID && SymSearch( string2 ) == NULL )

	cmp	cl, 8
	jne	$LN43@CondAsmDir
	mov	rcx, rdi
	call	SymFind
	test	rax, rax
	jne	$LN43@CondAsmDir

; 299  :                 EmitErr( SYMBOL_NOT_DEFINED, string2 );

	mov	rdx, rdi
	lea	ecx, QWORD PTR [rax+102]
	call	EmitErr

; 331  :             return( ERROR );

	or	eax, -1
	jmp	$LN111@CondAsmDir
$LN40@CondAsmDir:

; 323  :     case CC_BLKARG: /* [ELSE]IF[N]B */
; 324  :         string1 = tokenarray[i].string_ptr;

	movsxd	rax, r8d
	shl	rax, 5

; 325  : 
; 326  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movzx	ecx, BYTE PTR [rax+rsi]
	mov	rbx, QWORD PTR [rax+rsi+8]
	cmp	cl, 9
	jne	SHORT $LN42@CondAsmDir
	cmp	BYTE PTR [rax+rsi+1], 60		; 0000003cH
	jne	SHORT $LN42@CondAsmDir

; 332  :         }
; 333  :         i++;

	inc	r8d
	mov	DWORD PTR i$[rbp-89], r8d

; 334  :         if ( directive == T_IFB || directive == T_ELSEIFB ) {

	cmp	r14d, 367				; 0000016fH
	je	SHORT $LN47@CondAsmDir
	cmp	r14d, 380				; 0000017cH
	je	SHORT $LN47@CondAsmDir

; 336  :         } else {
; 337  :             NextIfState = !check_blank( string1 ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	mov	rcx, rbx
	call	check_blank
	mov	r8d, DWORD PTR i$[rbp-89]
	xor	edi, edi
	test	al, al
	mov	ebx, edi
	setne	bl
	jmp	$LN2@CondAsmDir
$LN47@CondAsmDir:

; 335  :             NextIfState = check_blank( string1 ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	mov	rcx, rbx
	call	check_blank

; 338  :         }
; 339  :         break;

	mov	r8d, DWORD PTR i$[rbp-89]
	xor	edi, edi
	test	al, al
	mov	ebx, edi
	sete	bl
	jmp	$LN2@CondAsmDir
$LN42@CondAsmDir:

; 327  :             if ( tokenarray[i].token == T_ID && SymSearch( string1 ) == NULL )

	cmp	cl, 8
	jne	SHORT $LN43@CondAsmDir
	mov	rcx, rbx
	call	SymFind
	test	rax, rax
	jne	SHORT $LN43@CondAsmDir

; 328  :                 EmitErr( SYMBOL_NOT_DEFINED, string1 );

	mov	rdx, rbx
	lea	ecx, QWORD PTR [rax+102]
	call	EmitErr

; 331  :             return( ERROR );

	or	eax, -1
	jmp	$LN111@CondAsmDir
$LN43@CondAsmDir:

; 329  :             else
; 330  :                 EmitError( TEXT_ITEM_REQUIRED );

	mov	ecx, 144				; 00000090H
	call	EmitError

; 331  :             return( ERROR );

	or	eax, -1
	jmp	$LN111@CondAsmDir
$LN49@CondAsmDir:

; 340  :     case CC_PASS1: /* [ELSE]IF1 */
; 341  :         /* v2.04: changed */
; 342  :         //NextIfState = ((Parse_Pass == PASS_1) ? BLOCK_ACTIVE : BLOCK_INACTIVE);
; 343  :         NextIfState = BLOCK_ACTIVE;
; 344  :         break;
; 345  :     case CC_PASS2: /* [ELSE]IF2 */
; 346  :         if ( ModuleInfo.setif2 == FALSE ) {

	bt	edx, 10
	jb	$LN68@CondAsmDir

; 347  :             EmitError( IF2_NOT_ALLOWED );

	mov	ecx, 190				; 000000beH
	call	EmitError

; 348  :             break;

	mov	r8d, DWORD PTR i$[rbp-89]
	mov	ebx, DWORD PTR NextIfState$[rbp-89]

; 349  :         }
; 350  :         /* v2.04: changed */
; 351  :         //NextIfState = ((Parse_Pass == PASS_1) ? BLOCK_INACTIVE : BLOCK_ACTIVE);
; 352  :         NextIfState = BLOCK_ACTIVE;
; 353  :         break;

	jmp	$LN2@CondAsmDir
$LN51@CondAsmDir:

; 354  :     case CC_SYMARG: /* [ELSE]IF[N]DEF */
; 355  :         NextIfState = BLOCK_INACTIVE;
; 356  :         /* Masm's implementation works with IDs as arguments only. The rest
; 357  :          * will return FALSE. However, it's nice to be able to check whether
; 358  :          * a reserved word is defined or not.
; 359  :          */
; 360  :         /* v2.0: [ELSE]IF[N]DEF is valid *without* an argument! */
; 361  :         //if ( tokenarray[i].token == T_ID && tokenarray[i+1].token == T_FINAL) {
; 362  :         if ( tokenarray[i].token == T_FINAL ) {

	movsxd	r9, r8d
	xor	edi, edi
	mov	rcx, r9
	mov	ebx, 1
	shl	rcx, 5
	movzx	edx, BYTE PTR [rcx+rsi]
	test	dl, dl
	je	$LN63@CondAsmDir

; 363  :         } else if ( tokenarray[i].token == T_ID  ) {

	cmp	dl, 8
	jne	$LN54@CondAsmDir

; 364  :             /* v2.07: handle structs + members (if -Zne is NOT set) */
; 365  :             struct asym *sym;
; 366  :             if ( Options.strict_masm_compat == FALSE &&
; 367  :                 tokenarray[i+1].token == T_DOT &&
; 368  :                 ( sym = SymSearch( tokenarray[i].string_ptr ) ) &&

	cmp	BYTE PTR Options+127, dil
	jne	$LN56@CondAsmDir
	lea	rax, QWORD PTR [r9+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 46			; 0000002eH
	jne	$LN56@CondAsmDir
	mov	rcx, QWORD PTR [rcx+rsi+8]
	call	SymFind
	mov	rcx, rax
	test	rax, rax
	je	SHORT $LN108@CondAsmDir
	cmp	DWORD PTR [rax+32], 7
	je	SHORT $LN58@CondAsmDir
	cmp	QWORD PTR [rax+80], rdi
	je	SHORT $LN108@CondAsmDir
$LN58@CondAsmDir:

; 369  :                 ( ( sym->state == SYM_TYPE ) || sym->type ) ) {
; 370  :                 uint_32 value;
; 371  :                 value = 0;

	mov	r8d, DWORD PTR i$[rbp-89]
	mov	DWORD PTR value$1[rbp-89], edi
	npad	8
$LL8@CondAsmDir:

; 372  :                 do {
; 373  :                     i += 2;

	add	r8d, 2
	mov	DWORD PTR i$[rbp-89], r8d

; 374  :                     /* if it's a structured variable, use its type! */
; 375  :                     if ( sym->state != SYM_TYPE )

	cmp	DWORD PTR [rcx+32], 7
	je	SHORT $LN59@CondAsmDir

; 376  :                         sym = sym->type;

	mov	rcx, QWORD PTR [rcx+80]
$LN59@CondAsmDir:

; 377  :                     sym = SearchNameInStruct( sym, tokenarray[i].string_ptr, &value, 0 );

	movsxd	rdx, r8d
	xor	r9d, r9d
	shl	rdx, 5
	lea	r8, QWORD PTR value$1[rbp-89]
	mov	rdx, QWORD PTR [rdx+rsi+8]
	call	SearchNameInStruct

; 378  :                 } while ( sym && tokenarray[i+1].token == T_DOT );

	movsxd	r8, DWORD PTR i$[rbp-89]
	mov	rcx, rax
	test	rax, rax
	je	SHORT $LN60@CondAsmDir
	lea	rax, QWORD PTR [r8+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 46			; 0000002eH
	je	SHORT $LL8@CondAsmDir
$LN60@CondAsmDir:

; 379  :                 NextIfState = ( sym ? BLOCK_ACTIVE : BLOCK_INACTIVE );

	test	rcx, rcx

; 381  :                 NextIfState = ( check_defd( tokenarray[i].string_ptr )  ? BLOCK_ACTIVE : BLOCK_INACTIVE );

	mov	ebx, edi
	sete	bl

; 382  :             }
; 383  :             i++;

	jmp	$LN115@CondAsmDir
$LN108@CondAsmDir:

; 380  :             } else {

	mov	r8d, DWORD PTR i$[rbp-89]
$LN56@CondAsmDir:

; 381  :                 NextIfState = ( check_defd( tokenarray[i].string_ptr )  ? BLOCK_ACTIVE : BLOCK_INACTIVE );

	movsxd	rax, r8d
	shl	rax, 5
	mov	rcx, QWORD PTR [rax+rsi+8]
	cmp	BYTE PTR [rcx], dil
	je	SHORT $LN91@CondAsmDir
	call	SymFind
	mov	r8d, DWORD PTR i$[rbp-89]
	test	rax, rax
	je	SHORT $LN91@CondAsmDir
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, bl
	mov	ebx, edi
	test	al, al
	sete	bl

; 382  :             }
; 383  :             i++;

	jmp	SHORT $LN115@CondAsmDir

; 381  :                 NextIfState = ( check_defd( tokenarray[i].string_ptr )  ? BLOCK_ACTIVE : BLOCK_INACTIVE );

$LN91@CondAsmDir:
	xor	al, al
	mov	ebx, edi
	test	al, al
	sete	bl

; 382  :             }
; 383  :             i++;

	jmp	SHORT $LN115@CondAsmDir
$LN54@CondAsmDir:

; 384  :         } else if ( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_FLAT ) {

	cmp	dl, 7
	jne	SHORT $LN61@CondAsmDir
	cmp	DWORD PTR [rcx+rsi+16], 261		; 00000105H
	jne	SHORT $LN61@CondAsmDir

; 385  :             /* v2.09: special treatment of FLAT added */
; 386  :             NextIfState = (( ModuleInfo.flat_grp && ModuleInfo.flat_grp->sym.isdefined ) ? BLOCK_ACTIVE : BLOCK_INACTIVE );

	mov	rax, QWORD PTR ModuleInfo+440
	test	rax, rax
	je	SHORT $LN115@CondAsmDir
	test	BYTE PTR [rax+40], 2
	je	SHORT $LN115@CondAsmDir

; 387  :             i++;
; 388  :         } else if ( Options.strict_masm_compat == FALSE && (

	jmp	SHORT $LN116@CondAsmDir
$LN61@CondAsmDir:

; 389  :                     tokenarray[i].token == T_RES_ID ||
; 390  :                     tokenarray[i].token == T_STYPE ||
; 391  :                     tokenarray[i].token == T_INSTRUCTION ||
; 392  :                     tokenarray[i].token == T_DIRECTIVE ||
; 393  :                     //tokenarray[i].token == T_UNARY_OP ||
; 394  :                     //tokenarray[i].token == T_BINARY_OP ||
; 395  :                     tokenarray[i].token == T_REG ) &&

	cmp	BYTE PTR Options+127, dil
	jne	SHORT $LN63@CondAsmDir
	lea	eax, DWORD PTR [rdx-6]
	cmp	al, bl
	jbe	SHORT $LN64@CondAsmDir
	dec	dl
	cmp	dl, 2
	ja	SHORT $LN63@CondAsmDir
$LN64@CondAsmDir:
	lea	rax, QWORD PTR [r9+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], dil
	jne	SHORT $LN63@CondAsmDir
$LN116@CondAsmDir:

; 396  :                    tokenarray[i+1].token == T_FINAL ) {
; 397  :             NextIfState = BLOCK_ACTIVE;

	mov	ebx, edi
$LN115@CondAsmDir:

; 398  :             i++;

	inc	r8d
	mov	DWORD PTR i$[rbp-89], r8d
$LN63@CondAsmDir:

; 399  :         }
; 400  :         if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rcx, r8d
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], dil
	je	SHORT $LN10@CondAsmDir

; 401  :             EmitWarn( 2, IFDEF_EXPECTS_SYMBOL_ARGUMENT, tokenarray[i-1].tokpos );

	shl	rcx, 5
	mov	edx, 248				; 000000f8H
	mov	r8, QWORD PTR [rcx+rsi-8]
	mov	ecx, 2
	call	EmitWarn

; 402  :             while ( tokenarray[i].token != T_FINAL ) i++;

	movsxd	r8, DWORD PTR i$[rbp-89]
	mov	rax, r8
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], dil
	je	SHORT $LN10@CondAsmDir
	npad	6
$LL9@CondAsmDir:
	inc	r8d
	movsxd	rax, r8d
	shl	rax, 5
	mov	DWORD PTR i$[rbp-89], r8d
	cmp	BYTE PTR [rax+rsi], dil
	jne	SHORT $LL9@CondAsmDir
$LN10@CondAsmDir:

; 403  :         }
; 404  :         if ( directive == T_IFNDEF || directive == T_ELSEIFNDEF )

	cmp	r14d, 370				; 00000172H
	je	SHORT $LN67@CondAsmDir
	cmp	r14d, 383				; 0000017fH
	jne	SHORT $LN2@CondAsmDir
$LN67@CondAsmDir:

; 405  :             NextIfState = ( ( NextIfState == BLOCK_ACTIVE ) ? BLOCK_INACTIVE : BLOCK_ACTIVE );

	test	ebx, ebx
	sete	dil

; 406  :         break;

	jmp	SHORT $LN112@CondAsmDir
$LN68@CondAsmDir:

; 407  :     default: /* ELSE and ENDIF */
; 408  :         NextIfState = BLOCK_ACTIVE;

	xor	edi, edi
$LN112@CondAsmDir:
	mov	ebx, edi
$LN2@CondAsmDir:

; 409  :         break;
; 410  :     }
; 411  : 
; 412  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 0
	je	SHORT $LN69@CondAsmDir

; 413  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rax+rsi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN111@CondAsmDir
$LN69@CondAsmDir:

; 414  :     }
; 415  : 
; 416  :     CurrIfState = NextIfState;

	mov	DWORD PTR CurrIfState, ebx

; 417  : 
; 418  :     DebugMsg1(("CondAsmDirective(%s) exit, state=%s, lvl=%u, falselvl=%u\n",
; 419  :                GetResWName(directive, NULL), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 420  :     return( NOT_ERROR );

	xor	eax, eax
$LN111@CondAsmDir:
	mov	rbx, QWORD PTR [rsp+208]
	mov	rdi, QWORD PTR [rsp+216]

; 421  : }

	add	rsp, 160				; 000000a0H
	pop	r14
	pop	rsi
	pop	rbp
	ret	0
$LN106@CondAsmDir:
	DD	$LN17@CondAsmDir
	DD	$LN26@CondAsmDir
	DD	$LN40@CondAsmDir
	DD	$LN51@CondAsmDir
	DD	$LN68@CondAsmDir
	DD	$LN49@CondAsmDir
$LN105@CondAsmDir:
	DD	$LN36@CondAsmDir
	DD	$LN37@CondAsmDir
	DD	$LN38@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN36@CondAsmDir
	DD	$LN37@CondAsmDir
	DD	$LN38@CondAsmDir
CondAsmDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
;	COMDAT check_dif
_TEXT	SEGMENT
string1$ = 48
string2$ = 56
sensitive$ = 64
check_dif PROC						; COMDAT

; 211  : {

	sub	rsp, 40					; 00000028H

; 212  :     if( sensitive ) {

	test	r8b, r8b
	je	SHORT $LN2@check_dif

; 213  :         return( strcmp( string1, string2 ) != 0 );

	sub	rdx, rcx
	npad	4
$LL5@check_dif:
	movzx	r8d, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+rdx]
	sub	r8d, eax
	jne	SHORT $LN6@check_dif
	inc	rcx
	test	eax, eax
	jne	SHORT $LL5@check_dif
$LN6@check_dif:
	test	r8d, r8d

; 214  :     } else {
; 215  :         return( _stricmp( string1, string2 ) != 0 );

	setne	al

; 216  :     }
; 217  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@check_dif:

; 214  :     } else {
; 215  :         return( _stricmp( string1, string2 ) != 0 );

	call	_stricmp
	test	eax, eax
	setne	al

; 216  :     }
; 217  : }

	add	rsp, 40					; 00000028H
	ret	0
check_dif ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
;	COMDAT check_blank
_TEXT	SEGMENT
string$ = 48
check_blank PROC					; COMDAT

; 198  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 199  :     for ( ;*string; string++ )

	movzx	eax, BYTE PTR [rcx]
	mov	rbx, rcx
	test	al, al
	je	SHORT $LN3@check_blan
$LL4@check_blan:

; 200  :         if ( isspace(*string) == FALSE )

	movsx	ecx, al
	call	isspace
	test	eax, eax
	je	SHORT $LN8@check_blan

; 199  :     for ( ;*string; string++ )

	movzx	eax, BYTE PTR [rbx+1]
	inc	rbx
	test	al, al
	jne	SHORT $LL4@check_blan
$LN3@check_blan:

; 202  :     return( TRUE );

	mov	al, 1

; 203  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN8@check_blan:

; 201  :             return FALSE;

	xor	al, al

; 203  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
check_blank ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
;	COMDAT check_defd
_TEXT	SEGMENT
name$ = 48
check_defd PROC						; COMDAT

; 179  : {

	sub	rsp, 40					; 00000028H

; 180  :     struct asym      *sym;
; 181  :     if ( *name ) {

	cmp	BYTE PTR [rcx], 0
	je	SHORT $LN3@check_defd

; 182  :         sym = SymSearch( name );

	call	SymFind

; 183  :         if( sym ) {

	test	rax, rax
	je	SHORT $LN3@check_defd

; 184  :             DebugMsg1(("check_defd(%s): state=%u defined=%u\n", name, sym->state, sym->isdefined ));
; 185  :             /* v2.04: changed. the "defined" flag is active for ALL symbols */
; 186  :             //if ( sym->state == SYM_INTERNAL || sym->state == SYM_MACRO || sym->state == SYM_TMACRO || sym->state == SYM_UNDEFINED ) {
; 187  :             return( sym->isdefined );

	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1

; 192  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@check_defd:

; 188  :         }
; 189  :         DebugMsg1(("check_defd(%s): sym=NULL\n", name ));
; 190  :     }
; 191  :     return( FALSE );

	xor	al, al

; 192  : }

	add	rsp, 40					; 00000028H
	ret	0
check_defd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
CondInit PROC

; 668  :     CurrIfState = BLOCK_ACTIVE;

	xor	eax, eax
	mov	DWORD PTR CurrIfState, eax

; 669  :     blocknestlevel = 0;

	mov	DWORD PTR blocknestlevel, eax

; 670  :     falseblocknestlevel = 0;

	mov	DWORD PTR falseblocknestlevel, eax

; 671  : }

	ret	0
CondInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
CondCheckOpen PROC

; 644  :     if( blocknestlevel > 0 ) {

	cmp	DWORD PTR blocknestlevel, 0
	jle	SHORT $LN2@CondCheckO

; 645  :         EmitErr( BLOCK_NESTING_ERROR, "if-else" );

	lea	rdx, OFFSET FLAT:$SG11204
	mov	ecx, 80					; 00000050H
	jmp	EmitErr
$LN2@CondCheckO:

; 646  :     }
; 647  :     return;
; 648  : }

	ret	0
CondCheckOpen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
newlevel$ = 8
SetIfNestLevel PROC

; 659  :     blocknestlevel = newlevel;

	mov	DWORD PTR blocknestlevel, ecx

; 660  :     return;
; 661  : }

	ret	0
SetIfNestLevel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
GetIfNestLevel PROC

; 653  :     return( blocknestlevel );

	mov	eax, DWORD PTR blocknestlevel

; 654  : }

	ret	0
GetIfNestLevel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
directive$ = 48
conditional_assembly_prepare PROC

; 92   : {

$LN22:
	sub	rsp, 40					; 00000028H
	mov	r8d, ecx

; 93   :     DebugMsg1(("condasm_prepare(%s), old status: %s, lvl=%u, falselvl=%u\n",
; 94   :                GetResWName( directive, NULL), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 95   :     switch( directive ) {

	cmp	ecx, 359				; 00000167H
	jl	$LN15@conditiona
	cmp	ecx, 370				; 00000172H
	jle	$LN4@conditiona
	cmp	ecx, 383				; 0000017fH
	jle	SHORT $LN7@conditiona
	cmp	ecx, 384				; 00000180H
	jne	$LN15@conditiona

; 151  :         }
; 152  :         break;
; 153  :     case T_ENDIF:
; 154  :         if ( blocknestlevel ) {

	mov	ecx, DWORD PTR blocknestlevel
	test	ecx, ecx
	je	SHORT $LN14@conditiona

; 155  :             if ( falseblocknestlevel > 0 ) {

	mov	eax, DWORD PTR falseblocknestlevel
	test	eax, eax
	jle	SHORT $LN16@conditiona

; 156  :                 falseblocknestlevel--;

	dec	eax
	mov	DWORD PTR falseblocknestlevel, eax

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",
; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN16@conditiona:

; 157  :                 break;
; 158  :             }
; 159  :             blocknestlevel--;

	dec	ecx

; 160  :             CurrIfState = BLOCK_ACTIVE; /* v2.04: added */

	xor	r9d, r9d
	mov	DWORD PTR blocknestlevel, ecx
	mov	DWORD PTR CurrIfState, r9d

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",
; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN14@conditiona:

; 161  :         } else {
; 162  :             EmitErr( BLOCK_NESTING_ERROR, GetResWName( directive, NULL ) );

	mov	ecx, 384				; 00000180H
	jmp	SHORT $LN20@conditiona
$LN7@conditiona:

; 118  :         break;
; 119  :     case T_ELSE:
; 120  :     case T_ELSEIF:
; 121  :     case T_ELSEIF1:
; 122  :     case T_ELSEIF2:
; 123  :     case T_ELSEIFB:
; 124  :     case T_ELSEIFDEF:
; 125  :     case T_ELSEIFDIF:
; 126  :     case T_ELSEIFDIFI:
; 127  :     case T_ELSEIFE:
; 128  :     case T_ELSEIFIDN:
; 129  :     case T_ELSEIFIDNI:
; 130  :     case T_ELSEIFNB:
; 131  :     case T_ELSEIFNDEF:
; 132  :         if ( blocknestlevel ) { /* v2.04: do nothing if there was no IFx */

	mov	ecx, DWORD PTR blocknestlevel
	test	ecx, ecx
	je	SHORT $LN8@conditiona

; 133  :             if ( falseblocknestlevel > 0 ) {

	cmp	DWORD PTR falseblocknestlevel, 0
	jg	$LN15@conditiona

; 134  :                 break;
; 135  :             }
; 136  :             /* v2.06: check added to detect multiple ELSE branches */
; 137  :             if ( elseoccured & ( 1 << ( blocknestlevel - 1 ) ) ) {

	dec	ecx
	mov	edx, 1
	shl	edx, cl
	mov	ecx, DWORD PTR elseoccured
	test	edx, ecx
	je	SHORT $LN11@conditiona

; 138  :                 EmitError( ELSE_CLAUSE_ALREADY_OCCURED_IN_THIS_IF_BLOCK );

	mov	ecx, 273				; 00000111H

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",
; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 40					; 00000028H

; 138  :                 EmitError( ELSE_CLAUSE_ALREADY_OCCURED_IN_THIS_IF_BLOCK );

	jmp	EmitError
$LN11@conditiona:

; 139  :                 break;
; 140  :             }
; 141  :             /* status may change:
; 142  :              * inactive -> active
; 143  :              * active   -> done
; 144  :              */
; 145  :             CurrIfState = (( CurrIfState == BLOCK_INACTIVE ) ? BLOCK_ACTIVE : BLOCK_DONE );

	xor	r9d, r9d
	mov	eax, 2
	cmp	DWORD PTR CurrIfState, 1
	cmove	eax, r9d
	mov	DWORD PTR CurrIfState, eax

; 146  :             /* v2.06: no further ELSEx once ELSE was detected */
; 147  :             if ( directive == T_ELSE )

	cmp	r8d, 371				; 00000173H
	jne	SHORT $LN15@conditiona

; 148  :                 elseoccured |= ( 1 << ( blocknestlevel - 1 ) );

	or	ecx, edx
	mov	DWORD PTR elseoccured, ecx

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",
; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@conditiona:

; 149  :         } else {
; 150  :             EmitErr( BLOCK_NESTING_ERROR, GetResWName( directive, NULL ) );

	mov	ecx, r8d
$LN20@conditiona:
	xor	edx, edx
	call	GetResWName
	mov	rdx, rax
	mov	ecx, 80					; 00000050H

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",
; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 40					; 00000028H

; 149  :         } else {
; 150  :             EmitErr( BLOCK_NESTING_ERROR, GetResWName( directive, NULL ) );

	jmp	EmitErr
$LN4@conditiona:

; 96   :     case T_IF:
; 97   :     case T_IF1:
; 98   :     case T_IF2:
; 99   :     case T_IFB:
; 100  :     case T_IFDEF:
; 101  :     case T_IFDIF:
; 102  :     case T_IFDIFI:
; 103  :     case T_IFE:
; 104  :     case T_IFIDN:
; 105  :     case T_IFIDNI:
; 106  :     case T_IFNB:
; 107  :     case T_IFNDEF:
; 108  :         if( CurrIfState != BLOCK_ACTIVE ) {

	cmp	DWORD PTR CurrIfState, 0
	je	SHORT $LN5@conditiona

; 109  :             falseblocknestlevel++;

	inc	DWORD PTR falseblocknestlevel

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",
; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN5@conditiona:

; 110  :             break;
; 111  :         }
; 112  :         if( blocknestlevel == MAX_IF_NESTING ) {

	mov	ecx, DWORD PTR blocknestlevel
	cmp	ecx, 20
	jne	SHORT $LN6@conditiona

; 113  :             EmitError( NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 100				; 00000064H

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",
; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 40					; 00000028H

; 113  :             EmitError( NESTING_LEVEL_TOO_DEEP );

	jmp	EmitError
$LN6@conditiona:

; 114  :             break;
; 115  :         }
; 116  :         elseoccured &= ~( 1 << blocknestlevel ); /* v2.06: added */

	mov	edx, 1
	shl	edx, cl
	not	edx
	and	DWORD PTR elseoccured, edx

; 117  :         blocknestlevel++;

	inc	ecx
	mov	DWORD PTR blocknestlevel, ecx
$LN15@conditiona:

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",
; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 40					; 00000028H
	ret	0
conditional_assembly_prepare ENDP
_TEXT	ENDS
END
