; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	jmpenv
EXTRN	omf_init:PROC
EXTRN	coff_init:PROC
EXTRN	elf_init:PROC
EXTRN	bin_init:PROC
_BSS	SEGMENT
jmpenv	DB	0100H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	LinnumQueue:BYTE:010H
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	ModuleInfo:BYTE:0308H
COMM	Parse_Pass:DWORD
COMM	write_to_file:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11716 DB	'_TEXT', 00H
	ORG $+2
$SG11717 DB	'.text', 00H
	ORG $+2
$SG11718 DB	'_DATA', 00H
	ORG $+2
$SG11719 DB	'.data', 00H
	ORG $+2
$SG11720 DB	'CONST', 00H
	ORG $+2
$SG11721 DB	'.rdata', 00H
	ORG $+1
$SG11722 DB	'_BSS', 00H
	ORG $+3
$SG11723 DB	'.bss', 00H
	ORG $+3
$SG11837 DB	'w', 00H
	ORG $+2
$SG11901 DB	'%s', 0aH, 00H
$SG11841 DB	'import ''%s''  %s.%s', 0aH, 00H
$SG11903 DB	0aH, 00H
	ORG $+2
$SG11889 DB	'INCLUDE', 00H
$SG11926 DB	'%r %s', 00H
	ORG $+2
$SG12026 DB	'rb', 00H
	ORG $+1
$SG12029 DB	'wb', 00H
	ORG $+1
$SG12032 DB	'wb', 00H
	ORG $+1
$SG12065 DB	'EXE', 00H
$SG12066 DB	'BIN', 00H
$SG12067 DB	'obj', 00H
$SG12069 DB	'lst', 00H
$SG12071 DB	'err', 00H
$SG12138 DB	'%s', 0aH, 00H
_DATA	ENDS
CONST	SEGMENT
formatoptions DQ FLAT:bin_init
	DW	00H
	DB	'BIN', 00H
	ORG $+2
	DQ	FLAT:omf_init
	DW	00H
	DB	'OMF', 00H
	ORG $+2
	DQ	FLAT:coff_init
	DW	0e12H
	DB	'COFF', 00H
	ORG $+1
	DQ	FLAT:elf_init
	DW	0f00H
	DB	'ELF', 00H
	ORG $+2
cst	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11716
	DQ	FLAT:$SG11717
	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11718
	DQ	FLAT:$SG11719
	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11720
	DQ	FLAT:$SG11721
	DB	04H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG11722
	DQ	FLAT:$SG11723
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	printf
PUBLIC	sprintf
PUBLIC	OutputByte
PUBLIC	FillDataBytes
PUBLIC	OutputBytes
PUBLIC	AssembleModule
PUBLIC	SetMasm510
PUBLIC	close_files
PUBLIC	ConvertSectionName
PUBLIC	WritePreprocessedLine
PUBLIC	SetCurrOffset
PUBLIC	OutputBinBytes
EXTRN	isalpha:PROC
EXTRN	isdigit:PROC
EXTRN	isspace:PROC
EXTRN	isalnum:PROC
EXTRN	clock:PROC
EXTRN	__acrt_iob_func:PROC
EXTRN	fclose:PROC
EXTRN	fopen:PROC
EXTRN	fwrite:PROC
EXTRN	remove:PROC
EXTRN	rewind:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	_errno:PROC
EXTRN	getenv:PROC
EXTRN	strchr:PROC
EXTRN	strncpy:PROC
EXTRN	_strupr:PROC
EXTRN	Fatal:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	ErrnoStr:PROC
EXTRN	WriteError:PROC
EXTRN	MemInit:PROC
EXTRN	MemFini:PROC
EXTRN	LclAlloc:PROC
EXTRN	GetLineNumber:PROC
EXTRN	GetFNamePart:PROC
EXTRN	GetExtPart:PROC
EXTRN	SearchFile:PROC
EXTRN	AddStringToIncludePath:PROC
EXTRN	InputInit:PROC
EXTRN	InputPassInit:PROC
EXTRN	InputFini:PROC
EXTRN	ClearSrcStack:PROC
EXTRN	set_curr_srcfile:PROC
EXTRN	GetFName:PROC
EXTRN	SymCreate:PROC
EXTRN	SymFind:PROC
EXTRN	SymInit:PROC
EXTRN	SymFini:PROC
EXTRN	SymPassInit:PROC
EXTRN	SymMakeAllSymbolsPublic:PROC
EXTRN	SymSetCmpFunc:PROC
EXTRN	sym_remove_table:PROC
EXTRN	ParseLine:PROC
EXTRN	ProcessFile:PROC
EXTRN	DisableKeyword:PROC
EXTRN	ResWordsInit:PROC
EXTRN	ResWordsFini:PROC
EXTRN	Tokenize:PROC
EXTRN	CondCheckOpen:PROC
EXTRN	CondInit:PROC
EXTRN	SegmentInit:PROC
EXTRN	SegmentFini:PROC
EXTRN	AssumeInit:PROC
EXTRN	ProcInit:PROC
EXTRN	ExprEvalInit:PROC
EXTRN	HllInit:PROC
EXTRN	HllCheckOpen:PROC
EXTRN	ContextInit:PROC
EXTRN	TypesInit:PROC
EXTRN	LabelInit:PROC
EXTRN	MacroInit:PROC
EXTRN	FreePubQueue:PROC
EXTRN	store_fixup:PROC
EXTRN	omf_set_filepos:PROC
EXTRN	omf_OutSelect:PROC
EXTRN	omf_FlushCurrSeg:PROC
EXTRN	FastpassInit:PROC
EXTRN	SkipSavedState:PROC
EXTRN	RestoreState:PROC
EXTRN	LstInit:PROC
EXTRN	LstWriteCRef:PROC
EXTRN	LstPrintf:PROC
EXTRN	LstNL:PROC
EXTRN	MsgGetEx:PROC
EXTRN	LinnumInit:PROC
EXTRN	LinnumFini:PROC
EXTRN	QueueDeleteLinnum:PROC
EXTRN	SetCPU:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	RunLineQueue:PROC
EXTRN	Mangle:PROC
EXTRN	__chkstk:PROC
EXTRN	_setjmp:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	Options:BYTE
EXTRN	MacroLevel:BYTE
EXTRN	SymTables:BYTE
EXTRN	LineStoreCurr:QWORD
EXTRN	StoreState:BYTE
EXTRN	UseSavedState:BYTE
EXTRN	LastCodeBufSize:DWORD
EXTRN	DefaultDir:BYTE
EXTRN	ModelToken:BYTE
EXTRN	__ImageBase:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+83
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN8
	DD	imagerel $LN8+90
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$OutputByte DD imagerel $LN9
	DD	imagerel $LN9+185
	DD	imagerel $unwind$OutputByte
$pdata$FillDataBytes DD imagerel $LN20
	DD	imagerel $LN20+233
	DD	imagerel $unwind$FillDataBytes
$pdata$OutputBytes DD imagerel $LN10
	DD	imagerel $LN10+11
	DD	imagerel $unwind$OutputBytes
$pdata$2$OutputBytes DD imagerel $LN10+11
	DD	imagerel $LN10+44
	DD	imagerel $chain$2$OutputBytes
$pdata$3$OutputBytes DD imagerel $LN10+44
	DD	imagerel $LN10+151
	DD	imagerel $chain$3$OutputBytes
$pdata$4$OutputBytes DD imagerel $LN10+151
	DD	imagerel $LN10+250
	DD	imagerel $chain$4$OutputBytes
$pdata$5$OutputBytes DD imagerel $LN10+250
	DD	imagerel $LN10+258
	DD	imagerel $chain$5$OutputBytes
$pdata$AssembleModule DD imagerel $LN59
	DD	imagerel $LN59+730
	DD	imagerel $unwind$AssembleModule
$pdata$close_files DD imagerel $LN13
	DD	imagerel $LN13+222
	DD	imagerel $unwind$close_files
$pdata$ConvertSectionName DD imagerel $LN25
	DD	imagerel $LN25+328
	DD	imagerel $unwind$ConvertSectionName
$pdata$WritePreprocessedLine DD imagerel $LN16
	DD	imagerel $LN16+18
	DD	imagerel $unwind$WritePreprocessedLine
$pdata$0$WritePreprocessedLine DD imagerel $LN16+18
	DD	imagerel $LN16+106
	DD	imagerel $chain$0$WritePreprocessedLine
$pdata$1$WritePreprocessedLine DD imagerel $LN16+106
	DD	imagerel $LN16+145
	DD	imagerel $chain$1$WritePreprocessedLine
$pdata$SetCurrOffset DD imagerel $LN18
	DD	imagerel $LN18+176
	DD	imagerel $unwind$SetCurrOffset
$pdata$OutputBinBytes DD imagerel $LN20
	DD	imagerel $LN20+225
	DD	imagerel $unwind$OutputBinBytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$WriteModule DD imagerel WriteModule
	DD	imagerel WriteModule+374
	DD	imagerel $unwind$WriteModule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$is_valid_identifier DD imagerel is_valid_identifier
	DD	imagerel is_valid_identifier+66
	DD	imagerel $unwind$is_valid_identifier
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$is_valid_identifier DD imagerel is_valid_identifier+66
	DD	imagerel is_valid_identifier+149
	DD	imagerel $chain$0$is_valid_identifier
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$is_valid_identifier DD imagerel is_valid_identifier+149
	DD	imagerel is_valid_identifier+163
	DD	imagerel $chain$2$is_valid_identifier
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_cmdline_tmacros DD imagerel add_cmdline_tmacros
	DD	imagerel add_cmdline_tmacros+401
	DD	imagerel $unwind$add_cmdline_tmacros
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_incpaths DD imagerel add_incpaths
	DD	imagerel add_incpaths+41
	DD	imagerel $unwind$add_incpaths
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CmdlParamsInit DD imagerel CmdlParamsInit
	DD	imagerel CmdlParamsInit+8
	DD	imagerel $unwind$CmdlParamsInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$CmdlParamsInit DD imagerel CmdlParamsInit+8
	DD	imagerel CmdlParamsInit+63
	DD	imagerel $chain$0$CmdlParamsInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$CmdlParamsInit DD imagerel CmdlParamsInit+63
	DD	imagerel CmdlParamsInit+97
	DD	imagerel $chain$1$CmdlParamsInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ModulePassInit DD imagerel ModulePassInit
	DD	imagerel ModulePassInit+499
	DD	imagerel $unwind$ModulePassInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PassOneChecks DD imagerel PassOneChecks
	DD	imagerel PassOneChecks+293
	DD	imagerel $unwind$PassOneChecks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PassOneChecks DD imagerel PassOneChecks+293
	DD	imagerel PassOneChecks+419
	DD	imagerel $chain$0$PassOneChecks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PassOneChecks DD imagerel PassOneChecks+419
	DD	imagerel PassOneChecks+501
	DD	imagerel $chain$1$PassOneChecks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OnePass DD imagerel OnePass
	DD	imagerel OnePass+4
	DD	imagerel $unwind$OnePass
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$OnePass DD imagerel OnePass+4
	DD	imagerel OnePass+499
	DD	imagerel $chain$0$OnePass
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$OnePass DD imagerel OnePass+499
	DD	imagerel OnePass+519
	DD	imagerel $chain$1$OnePass
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_module_name DD imagerel get_module_name
	DD	imagerel get_module_name+226
	DD	imagerel $unwind$get_module_name
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ModuleInit DD imagerel ModuleInit
	DD	imagerel ModuleInit+174
	DD	imagerel $unwind$ModuleInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReswTableInit DD imagerel ReswTableInit
	DD	imagerel ReswTableInit+76
	DD	imagerel $unwind$ReswTableInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$open_files DD imagerel open_files
	DD	imagerel open_files+199
	DD	imagerel $unwind$open_files
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetFilenames DD imagerel SetFilenames
	DD	imagerel SetFilenames+654
	DD	imagerel $unwind$SetFilenames
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AssembleInit DD imagerel AssembleInit
	DD	imagerel AssembleInit+148
	DD	imagerel $unwind$AssembleInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AssembleFini DD imagerel AssembleFini
	DD	imagerel AssembleFini+65
	DD	imagerel $unwind$AssembleFini
pdata	ENDS
_DATA	SEGMENT
?PrintEmptyLine@?1??WritePreprocessedLine@@9@9 DB 01H	; `WritePreprocessedLine'::`2'::PrintEmptyLine
_DATA	ENDS
CONST	SEGMENT
stt	DD	01H
	DD	02H
	DD	02H
	DD	03H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AssembleFini DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AssembleInit DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetFilenames DD 0b1d01H
	DD	02b741dH
	DD	02a641dH
	DD	029541dH
	DD	028341dH
	DD	026011dH
	DD	0e016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$open_files DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReswTableInit DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ModuleInit DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_module_name DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$OnePass DD 021H
	DD	imagerel OnePass
	DD	imagerel OnePass+4
	DD	imagerel $unwind$OnePass
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$OnePass DD 020521H
	DD	043405H
	DD	imagerel OnePass
	DD	imagerel OnePass+4
	DD	imagerel $unwind$OnePass
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OnePass DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PassOneChecks DD 021H
	DD	imagerel PassOneChecks
	DD	imagerel PassOneChecks+293
	DD	imagerel $unwind$PassOneChecks
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PassOneChecks DD 020521H
	DD	043405H
	DD	imagerel PassOneChecks
	DD	imagerel PassOneChecks+293
	DD	imagerel $unwind$PassOneChecks
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PassOneChecks DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ModulePassInit DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$CmdlParamsInit DD 021H
	DD	imagerel CmdlParamsInit
	DD	imagerel CmdlParamsInit+8
	DD	imagerel $unwind$CmdlParamsInit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$CmdlParamsInit DD 020521H
	DD	043405H
	DD	imagerel CmdlParamsInit
	DD	imagerel CmdlParamsInit+8
	DD	imagerel $unwind$CmdlParamsInit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CmdlParamsInit DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_incpaths DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_cmdline_tmacros DD 0250d2601H
	DD	0c7426H
	DD	0b6422H
	DD	0a341eH
	DD	0320e2313H
	DD	0e008f00aH
	DD	0c004d006H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$is_valid_identifier DD 020021H
	DD	067400H
	DD	imagerel is_valid_identifier
	DD	imagerel is_valid_identifier+66
	DD	imagerel $unwind$is_valid_identifier
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$is_valid_identifier DD 020521H
	DD	067405H
	DD	imagerel is_valid_identifier
	DD	imagerel is_valid_identifier+66
	DD	imagerel $unwind$is_valid_identifier
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_valid_identifier DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WriteModule DD 067001H
	DD	086470H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
xdata	SEGMENT
$unwind$OutputByte DD 020601H
	DD	030023206H
$unwind$FillDataBytes DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$OutputBytes DD 010401H
	DD	04204H
$chain$2$OutputBytes DD 061521H
	DD	047415H
	DD	08640dH
	DD	075405H
	DD	imagerel $LN10
	DD	imagerel $LN10+11
	DD	imagerel $unwind$OutputBytes
$chain$3$OutputBytes DD 020521H
	DD	063405H
	DD	imagerel $LN10+11
	DD	imagerel $LN10+44
	DD	imagerel $chain$2$OutputBytes
$chain$4$OutputBytes DD 021H
	DD	imagerel $LN10+11
	DD	imagerel $LN10+44
	DD	imagerel $chain$2$OutputBytes
$chain$5$OutputBytes DD 021H
	DD	imagerel $LN10
	DD	imagerel $LN10+11
	DD	imagerel $unwind$OutputBytes
$unwind$AssembleModule DD 0a1d01H
	DD	011641dH
	DD	010541dH
	DD	0f341dH
	DD	0f019921dH
	DD	07015e017H
$unwind$close_files DD 020601H
	DD	030023206H
$unwind$ConvertSectionName DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
$unwind$WritePreprocessedLine DD 020601H
	DD	070023206H
$chain$0$WritePreprocessedLine DD 020521H
	DD	063405H
	DD	imagerel $LN16
	DD	imagerel $LN16+18
	DD	imagerel $unwind$WritePreprocessedLine
$chain$1$WritePreprocessedLine DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+18
	DD	imagerel $unwind$WritePreprocessedLine
$unwind$SetCurrOffset DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$OutputBinBytes DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT AssembleFini
_TEXT	SEGMENT
AssembleFini PROC					; COMDAT

; 1389 : {

	sub	rsp, 40					; 00000028H

; 1390 :     int i;
; 1391 :     SegmentFini();

	call	SegmentFini

; 1392 :     SymFini();

	call	SymFini

; 1393 :     ResWordsFini();

	call	ResWordsFini

; 1394 : #ifdef DEBUG_OUT
; 1395 :     DumpInstrStats();
; 1396 :     MacroFini();
; 1397 : #endif
; 1398 :     FreePubQueue();

	call	FreePubQueue

; 1399 : #if FASTMEM==0
; 1400 :     FreeLibQueue();
; 1401 :     ContextFini();
; 1402 :     HllFini();
; 1403 : #endif
; 1404 :     InputFini();

	call	InputFini

; 1405 :     close_files();

	call	close_files
	xorps	xmm0, xmm0
	xorps	xmm1, xmm1
	movdqu	XMMWORD PTR ModuleInfo+128, xmm0
	movdqu	XMMWORD PTR ModuleInfo+144, xmm1

; 1419 :     return;
; 1420 : }

	add	rsp, 40					; 00000028H

; 1406 : 
; 1407 : #if FASTPASS
; 1408 : #if FASTMEM==0
; 1409 :     FreeLineStore();
; 1410 : #endif
; 1411 : #endif
; 1412 : 
; 1413 :     for ( i = 0; i < NUM_FILE_TYPES; i++ ) {
; 1414 :         LclFree( CurrFName[i] );
; 1415 :         /* v2.05: make sure the pointer for ERR is cleared */
; 1416 :         CurrFName[i] = NULL;
; 1417 :     }
; 1418 :     MemFini();

	jmp	MemFini
AssembleFini ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT AssembleInit
_TEXT	SEGMENT
source$ = 48
AssembleInit PROC					; COMDAT

; 1349 : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1350 :     DebugMsg(("AssembleInit(\"%s\") enter\n", source ));
; 1351 : 
; 1352 :     MemInit();

	call	MemInit

; 1353 :     //start_label   = NULL;
; 1354 :     //start_displ   = 0;
; 1355 :     write_to_file = FALSE;
; 1356 :     //GeneratedCode = 0;
; 1357 :     LinnumQueue.head = NULL;
; 1358 : 
; 1359 :     SetFilenames( source );

	mov	rcx, rbx
	mov	BYTE PTR write_to_file, 0
	mov	QWORD PTR LinnumQueue, 0
	call	SetFilenames

; 1360 : 
; 1361 : #if FASTPASS
; 1362 :     FastpassInit();

	call	FastpassInit

; 1363 : #endif
; 1364 :     open_files();

	call	open_files

; 1365 : #if BUILD_TARGET
; 1366 :     get_os_include();
; 1367 : #endif
; 1368 :     ReswTableInit();

	call	ResWordsInit
	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN4@AssembleIn
	mov	ecx, 233				; 000000e9H
	call	DisableKeyword
	mov	ecx, 243				; 000000f3H
	call	DisableKeyword
$LN4@AssembleIn:
	cmp	BYTE PTR Options+127, 1
	jne	SHORT $LN5@AssembleIn
	mov	ecx, 444				; 000001bcH
	call	DisableKeyword
	mov	ecx, 270				; 0000010eH
	call	DisableKeyword
$LN5@AssembleIn:

; 1369 :     SymInit();

	call	SymInit

; 1370 :     InputInit();

	call	InputInit

; 1371 : 
; 1372 :     ModuleInit();

	call	ModuleInit

; 1373 :     CondInit();

	call	CondInit

; 1374 :     ExprEvalInit();

	call	ExprEvalInit

; 1376 : 
; 1377 :     DebugMsg(("AssembleInit() exit\n"));
; 1378 :     return;
; 1379 : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 1375 :     LstInit();

	jmp	LstInit
AssembleInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT SetFilenames
_TEXT	SEGMENT
path$ = 32
name$ = 320
SetFilenames PROC					; COMDAT

; 1301 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 304				; 00000130H
	mov	rbx, rcx

; 1302 :     int i;
; 1303 :     const char *fn;
; 1304 :     char *ext;
; 1305 :     char path[ FILENAME_MAX ];
; 1306 : 
; 1307 :     DebugMsg(("SetFilenames(\"%s\") enter\n", name ));
; 1308 : 
; 1309 :     /* set CurrFName[ASM] */
; 1310 :     CurrFName[ASM] = LclAlloc( strlen( name ) + 1 );

	or	rcx, -1
$LL70@SetFilenam:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], 0
	jne	SHORT $LL70@SetFilenam
	inc	rcx
	call	LclAlloc
	mov	QWORD PTR ModuleInfo+128, rax

; 1311 :     strcpy( CurrFName[ASM], name );

	mov	rdx, rbx
	npad	1
$LL11@SetFilenam:
	movzx	ecx, BYTE PTR [rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL11@SetFilenam

; 1312 : 
; 1313 :     /* set [OBJ], [ERR], [LST] */
; 1314 :     fn = GetFNamePart( name );

	mov	rcx, rbx
	call	GetFNamePart
	mov	rdi, rax

; 1315 :     for ( i = ASM+1; i < NUM_FILE_TYPES; i++ ) {

	lea	rbp, OFFSET FLAT:__ImageBase
	xor	esi, esi
	lea	r14, OFFSET FLAT:$SG12065
	mov	ebx, 1
$LL4@SetFilenam:

; 1316 :         if( Options.names[i] == NULL ) {

	mov	rcx, QWORD PTR Options[rsi+rbp+24]
	test	rcx, rcx
	jne	$LN5@SetFilenam

; 1317 :             path[0] = NULLC;

	mov	BYTE PTR path$[rsp], cl
	mov	rcx, QWORD PTR DefaultDir[rsi+rbp+8]

; 1318 :             if ( DefaultDir[i])

	test	rcx, rcx
	je	SHORT $LN7@SetFilenam

; 1319 :                 strcpy( path, DefaultDir[i] );

	lea	rdx, QWORD PTR path$[rsp]
	sub	rdx, rcx
	npad	5
$LL12@SetFilenam:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rdx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL12@SetFilenam
$LN7@SetFilenam:

; 1320 :             strcat( path, fn );

	lea	rcx, QWORD PTR path$[rsp]
	dec	rcx
$LL68@SetFilenam:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL68@SetFilenam
	xor	edx, edx
	npad	14
$LL69@SetFilenam:
	movzx	eax, BYTE PTR [rdi+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL69@SetFilenam

; 1321 :             ext = GetExtPart( path );

	lea	rcx, QWORD PTR path$[rsp]
	call	GetExtPart

; 1322 :             *ext++  = '.';

	mov	BYTE PTR [rax], 46			; 0000002eH
	lea	rdx, QWORD PTR [rax+1]

; 1323 :             strcpy( ext, GetExt( i ) );

	mov	eax, ebx
	sub	eax, 1
	je	SHORT $LN21@SetFilenam
	sub	eax, 1
	je	SHORT $LN26@SetFilenam
	cmp	eax, 1
	je	SHORT $LN27@SetFilenam
	xor	ecx, ecx
	jmp	SHORT $LN18@SetFilenam
$LN27@SetFilenam:
	lea	rcx, OFFSET FLAT:$SG12071
	jmp	SHORT $LN18@SetFilenam
$LN26@SetFilenam:
	lea	rcx, OFFSET FLAT:$SG12069
	jmp	SHORT $LN18@SetFilenam
$LN21@SetFilenam:
	cmp	DWORD PTR Options+144, 0
	jne	SHORT $LN24@SetFilenam
	mov	eax, DWORD PTR Options+148
	lea	rcx, OFFSET FLAT:$SG12066
	dec	eax
	cmp	eax, 1
	cmovbe	rcx, r14
	jmp	SHORT $LN18@SetFilenam
$LN24@SetFilenam:
	lea	rcx, OFFSET FLAT:$SG12067
$LN18@SetFilenam:
	sub	rdx, rcx
$LL13@SetFilenam:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rdx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL13@SetFilenam

; 1324 : 
; 1325 :         } else {

	jmp	$LN9@SetFilenam
$LN5@SetFilenam:

; 1326 :             /* filename has been set by cmdline option -Fo, -Fl or -Fr */
; 1327 :             const char *fn2;
; 1328 :             strcpy( path, Options.names[i] );

	lea	rdx, QWORD PTR path$[rsp]
	sub	rdx, rcx
	npad	3
$LL14@SetFilenam:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rdx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL14@SetFilenam

; 1329 :             fn2 = GetFNamePart( path );

	lea	rcx, QWORD PTR path$[rsp]
	call	GetFNamePart

; 1330 :             if( *fn2 == NULLC )

	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN8@SetFilenam

; 1331 :                 strcpy( (char *)fn2, fn );

	mov	r8, rax
	mov	rdx, rdi
	sub	r8, rdi
	npad	10
$LL15@SetFilenam:
	movzx	ecx, BYTE PTR [rdx]
	mov	BYTE PTR [r8+rdx], cl
	lea	rdx, QWORD PTR [rdx+1]
	test	cl, cl
	jne	SHORT $LL15@SetFilenam
$LN8@SetFilenam:

; 1332 :             ext = GetExtPart( fn2 );

	mov	rcx, rax
	call	GetExtPart
	mov	rdx, rax

; 1333 :             if( *ext == NULLC ) {

	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN9@SetFilenam

; 1334 :                 *ext++  = '.';

	mov	BYTE PTR [rax], 46			; 0000002eH
	inc	rdx

; 1335 :                 strcpy( ext, GetExt( i ) );

	mov	eax, ebx
	sub	eax, 1
	je	SHORT $LN32@SetFilenam
	sub	eax, 1
	je	SHORT $LN37@SetFilenam
	cmp	eax, 1
	je	SHORT $LN38@SetFilenam
	xor	eax, eax
	jmp	SHORT $LN29@SetFilenam
$LN38@SetFilenam:
	lea	rax, OFFSET FLAT:$SG12071
	jmp	SHORT $LN29@SetFilenam
$LN37@SetFilenam:
	lea	rax, OFFSET FLAT:$SG12069
	jmp	SHORT $LN29@SetFilenam
$LN32@SetFilenam:
	cmp	DWORD PTR Options+144, 0
	jne	SHORT $LN35@SetFilenam
	mov	ecx, DWORD PTR Options+148
	lea	rax, OFFSET FLAT:$SG12066
	dec	ecx
	cmp	ecx, 1
	cmovbe	rax, r14
	jmp	SHORT $LN29@SetFilenam
$LN35@SetFilenam:
	lea	rax, OFFSET FLAT:$SG12067
$LN29@SetFilenam:
	sub	rdx, rax
	npad	9
$LL16@SetFilenam:
	movzx	ecx, BYTE PTR [rax]
	mov	BYTE PTR [rdx+rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL16@SetFilenam
$LN9@SetFilenam:

; 1336 :             }
; 1337 :         }
; 1338 :         DebugMsg(("SetFilenames: i=%u >%s<\n", i, path ));
; 1339 :         CurrFName[i] = LclAlloc( strlen( path ) + 1 );

	lea	rax, QWORD PTR path$[rsp]
	or	rcx, -1
$LL67@SetFilenam:
	inc	rcx
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL67@SetFilenam
	inc	rcx
	call	LclAlloc
	mov	QWORD PTR ModuleInfo[rsi+rbp+136], rax

; 1340 :         strcpy( CurrFName[i], path );

	lea	rdx, QWORD PTR path$[rsp]
	npad	11
$LL17@SetFilenam:
	movzx	ecx, BYTE PTR [rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL17@SetFilenam

; 1315 :     for ( i = ASM+1; i < NUM_FILE_TYPES; i++ ) {

	inc	ebx
	add	rsi, 8
	cmp	ebx, 4
	jl	$LL4@SetFilenam

; 1341 :     }
; 1342 :     return;
; 1343 : }

	lea	r11, QWORD PTR [rsp+304]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	r14
	ret	0
SetFilenames ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT GetExt
_TEXT	SEGMENT
type$ = 8
GetExt	PROC						; COMDAT

; 1266 :     switch ( type ) {

	sub	ecx, 1
	je	SHORT $LN4@GetExt
	sub	ecx, 1
	je	SHORT $LN9@GetExt
	cmp	ecx, 1
	je	SHORT $LN10@GetExt

; 1286 :     }
; 1287 :     return( NULL );

	xor	eax, eax

; 1288 : }

	ret	0
$LN10@GetExt:

; 1284 :     case ERR:
; 1285 :         return( ERR_EXT );

	lea	rax, OFFSET FLAT:$SG12071

; 1288 : }

	ret	0
$LN9@GetExt:

; 1282 :     case LST:
; 1283 :         return( LST_EXT );

	lea	rax, OFFSET FLAT:$SG12069

; 1288 : }

	ret	0
$LN4@GetExt:

; 1267 :     case OBJ:
; 1268 : #if BIN_SUPPORT
; 1269 :         if ( Options.output_format == OFORMAT_BIN )

	cmp	DWORD PTR Options+144, 0
	jne	SHORT $LN7@GetExt
	mov	eax, DWORD PTR Options+148
	dec	eax
	cmp	eax, 1
	jbe	SHORT $LN8@GetExt

; 1277 :             else
; 1278 : #endif
; 1279 :                 return( BIN_EXT );

	lea	rax, OFFSET FLAT:$SG12066

; 1288 : }

	ret	0
$LN8@GetExt:

; 1270 : #if MZ_SUPPORT || PE_SUPPORT
; 1271 :             if ( Options.sub_format == SFORMAT_MZ
; 1272 : #if PE_SUPPORT
; 1273 :                 || Options.sub_format == SFORMAT_PE
; 1274 : #endif
; 1275 :                )
; 1276 :                 return( EXE_EXT );

	lea	rax, OFFSET FLAT:$SG12065

; 1288 : }

	ret	0
$LN7@GetExt:

; 1280 : #endif
; 1281 :         return( OBJ_EXT );

	lea	rax, OFFSET FLAT:$SG12067

; 1288 : }

	ret	0
GetExt	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT open_files
_TEXT	SEGMENT
open_files PROC						; COMDAT

; 1189 : {

	sub	rsp, 40					; 00000028H

; 1190 :     /* open ASM file */
; 1191 :     DebugMsg(("open_files() enter\n" ));
; 1192 : 
; 1193 :     //memset( CurrFile, 0, sizeof( CurrFile ) );
; 1194 :     /* CurrFile[ASM] = fopen( CurrFName[ASM], "r" ); */
; 1195 :     CurrFile[ASM] = fopen( CurrFName[ASM], "rb" );

	mov	rcx, QWORD PTR ModuleInfo+128
	lea	rdx, OFFSET FLAT:$SG12026
	call	fopen
	mov	QWORD PTR ModuleInfo+96, rax

; 1196 :     if( CurrFile[ASM] == NULL ) {

	test	rax, rax
	jne	SHORT $LN2@open_files

; 1197 :         DebugMsg(("open_files(): cannot open source file, fopen(\"%s\") failed\n", CurrFName[ASM] ));
; 1198 :         Fatal( CANNOT_OPEN_FILE, CurrFName[ASM], ErrnoStr() );

	call	ErrnoStr
	mov	rdx, QWORD PTR ModuleInfo+128
	mov	r8, rax
	mov	ecx, 106				; 0000006aH
	call	Fatal
$LN2@open_files:

; 1199 :     }
; 1200 : 
; 1201 :     /* open OBJ file */
; 1202 :     if ( Options.syntax_check_only == FALSE ) {

	cmp	BYTE PTR Options+172, 0
	jne	SHORT $LN4@open_files

; 1203 :         CurrFile[OBJ] = fopen( CurrFName[OBJ], "wb" );

	mov	rcx, QWORD PTR ModuleInfo+136
	lea	rdx, OFFSET FLAT:$SG12029
	call	fopen
	mov	QWORD PTR ModuleInfo+104, rax

; 1204 :         if( CurrFile[OBJ] == NULL ) {

	test	rax, rax
	jne	SHORT $LN4@open_files

; 1205 :             DebugMsg(("open_files(): cannot open object file, fopen(\"%s\") failed\n", CurrFName[OBJ] ));
; 1206 :             Fatal( CANNOT_OPEN_FILE, CurrFName[OBJ], ErrnoStr() );

	call	ErrnoStr
	mov	rdx, QWORD PTR ModuleInfo+136
	mov	r8, rax
	mov	ecx, 106				; 0000006aH
	call	Fatal
$LN4@open_files:

; 1207 :         }
; 1208 :         DebugMsg(("open_files(): output, fopen(\"%s\") ok\n", CurrFName[OBJ] ));
; 1209 :     }
; 1210 : 
; 1211 :     if( Options.write_listing ) {

	cmp	BYTE PTR Options+121, 0
	je	SHORT $LN6@open_files

; 1212 :         CurrFile[LST] = fopen( CurrFName[LST], "wb" );

	mov	rcx, QWORD PTR ModuleInfo+144
	lea	rdx, OFFSET FLAT:$SG12032
	call	fopen
	mov	QWORD PTR ModuleInfo+112, rax

; 1213 :         if ( CurrFile[LST] == NULL )

	test	rax, rax
	jne	SHORT $LN6@open_files

; 1214 :             Fatal( CANNOT_OPEN_FILE, CurrFName[LST], ErrnoStr() );

	call	ErrnoStr
	mov	rdx, QWORD PTR ModuleInfo+144
	mov	r8, rax
	mov	ecx, 106				; 0000006aH

; 1215 :     }
; 1216 :     return;
; 1217 : }

	add	rsp, 40					; 00000028H

; 1214 :             Fatal( CANNOT_OPEN_FILE, CurrFName[LST], ErrnoStr() );

	jmp	Fatal
$LN6@open_files:

; 1215 :     }
; 1216 :     return;
; 1217 : }

	add	rsp, 40					; 00000028H
	ret	0
open_files ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT ReswTableInit
_TEXT	SEGMENT
ReswTableInit PROC					; COMDAT

; 1165 : {

	sub	rsp, 40					; 00000028H

; 1166 :     ResWordsInit();

	call	ResWordsInit

; 1167 :     if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN2@ReswTableI

; 1168 :         /* DebugMsg(("InitAsm: disable IMAGEREL+SECTIONREL\n")); */
; 1169 :         /* for OMF, IMAGEREL and SECTIONREL are disabled */
; 1170 : #if IMAGERELSUPP
; 1171 :         DisableKeyword( T_IMAGEREL );

	mov	ecx, 233				; 000000e9H
	call	DisableKeyword

; 1172 : #endif
; 1173 : #if SECTIONRELSUPP
; 1174 :         DisableKeyword( T_SECTIONREL );

	mov	ecx, 243				; 000000f3H
	call	DisableKeyword
$LN2@ReswTableI:

; 1175 : #endif
; 1176 :     }
; 1177 : 
; 1178 :     if ( Options.strict_masm_compat == TRUE ) {

	cmp	BYTE PTR Options+127, 1
	jne	SHORT $LN3@ReswTableI

; 1179 :         DebugMsg(("ReswTableInit: disable INCBIN + FASTCALL keywords\n"));
; 1180 :         DisableKeyword( T_INCBIN );

	mov	ecx, 444				; 000001bcH
	call	DisableKeyword

; 1181 :         DisableKeyword( T_FASTCALL );

	mov	ecx, 270				; 0000010eH

; 1182 :     }
; 1183 : 
; 1184 :     return;
; 1185 : }

	add	rsp, 40					; 00000028H

; 1181 :         DisableKeyword( T_FASTCALL );

	jmp	DisableKeyword
$LN3@ReswTableI:

; 1182 :     }
; 1183 : 
; 1184 :     return;
; 1185 : }

	add	rsp, 40					; 00000028H
	ret	0
ReswTableInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT ModuleInit
_TEXT	SEGMENT
ModuleInit PROC						; COMDAT

; 1139 : {

	sub	rsp, 40					; 00000028H

; 1140 :     ModuleInfo.sub_format = Options.sub_format;

	mov	eax, DWORD PTR Options+148

; 1141 :     ModuleInfo.fmtopt = &formatoptions[Options.output_format];

	lea	rdx, OFFSET FLAT:formatoptions
	movsxd	rcx, DWORD PTR Options+144
	mov	DWORD PTR ModuleInfo+372, eax
	mov	rax, rcx
	shl	rax, 4
	add	rax, rdx
	mov	QWORD PTR ModuleInfo+344, rax

; 1142 :     ModuleInfo.CommentDataInCode = (Options.output_format == OFORMAT_OMF &&

	cmp	ecx, 1
	jne	SHORT $LN3@ModuleInit
	cmp	BYTE PTR Options+112, 0
	mov	BYTE PTR ModuleInfo+423, cl
	je	SHORT $LN4@ModuleInit
$LN3@ModuleInit:
	mov	BYTE PTR ModuleInfo+423, 0
$LN4@ModuleInit:

; 1143 :                          Options.no_comment_data_in_code_records == FALSE);
; 1144 :     ModuleInfo.g.error_count = 0;
; 1145 :     ModuleInfo.g.warning_count = 0;
; 1146 :     ModuleInfo.model = MODEL_NONE;
; 1147 :     /* ModuleInfo.distance = STACK_NONE; */
; 1148 :     ModuleInfo.ostype = OPSYS_DOS;
; 1149 :     ModuleInfo.emulator = (Options.floating_point == FPO_EMULATION);

	mov	eax, DWORD PTR ModuleInfo+408
	xor	ecx, ecx
	cmp	DWORD PTR Options+4, 1
	mov	QWORD PTR ModuleInfo, rcx
	mov	DWORD PTR ModuleInfo+360, ecx
	mov	DWORD PTR ModuleInfo+368, ecx
	sete	cl
	shl	ecx, 9
	xor	ecx, eax
	and	ecx, 512				; 00000200H
	xor	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 1150 :     //ModuleInfo.flatgrp_idx = 0;
; 1151 : 
; 1152 :     get_module_name(); /* set ModuleInfo.name */

	call	get_module_name

; 1153 : 
; 1154 :     /* v2.06: ST_PROC has been removed */
; 1155 :     //SimpleType[ST_PROC].mem_type = MT_NEAR;
; 1156 : 
; 1157 :     memset( SymTables, 0, sizeof( SymTables[0] ) * TAB_LAST );

	xor	edx, edx
	lea	rcx, OFFSET FLAT:SymTables
	lea	r8d, QWORD PTR [rdx+96]
	call	memset

; 1158 :     ModuleInfo.fmtopt->init( &ModuleInfo );

	mov	rax, QWORD PTR ModuleInfo+344
	lea	rcx, OFFSET FLAT:ModuleInfo

; 1159 : 
; 1160 :     return;
; 1161 : }

	add	rsp, 40					; 00000028H

; 1158 :     ModuleInfo.fmtopt->init( &ModuleInfo );

	rex_jmp	QWORD PTR [rax]
ModuleInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT get_module_name
_TEXT	SEGMENT
get_module_name PROC					; COMDAT

; 1100 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1101 :     //char dummy[_MAX_EXT];
; 1102 :     char        *p;
; 1103 : 
; 1104 :     /* v2.08: prefer name given by -nm option */
; 1105 :     if ( Options.names[OPTN_MODULE_NAME] ) {

	mov	rdx, QWORD PTR Options+56
	test	rdx, rdx
	je	SHORT $LN5@get_module

; 1106 :         strncpy( ModuleInfo.name, Options.names[OPTN_MODULE_NAME], sizeof( ModuleInfo.name ) );

	lea	rbx, OFFSET FLAT:ModuleInfo+512
	mov	r8d, 260				; 00000104H
	mov	rcx, rbx
	call	strncpy

; 1107 :         ModuleInfo.name[ sizeof( ModuleInfo.name ) - 1] = NULLC;

	mov	BYTE PTR ModuleInfo+771, 0

; 1108 :     } else {

	jmp	SHORT $LN6@get_module
$LN5@get_module:

; 1109 :         /* v2.12: _splitpath()/_makepath() removed */
; 1110 :         const char *fn = GetFNamePart( CurrFName[ASM] );

	mov	rcx, QWORD PTR ModuleInfo+128
	call	GetFNamePart

; 1111 :         char *ext = GetExtPart( fn );

	mov	rcx, rax
	mov	rbx, rax
	call	GetExtPart
	mov	rdi, rax

; 1112 :         memcpy( ModuleInfo.name, fn, ext - fn );

	mov	rdx, rbx
	sub	rdi, rbx
	lea	rbx, OFFSET FLAT:ModuleInfo+512
	mov	rcx, rbx
	mov	r8, rdi
	call	memcpy

; 1113 :         ModuleInfo.name[ ext - fn ] = NULLC;

	mov	BYTE PTR [rdi+rbx], 0
$LN6@get_module:

; 1114 :         //_splitpath( CurrFName[ASM], NULL, NULL, ModuleInfo.name, dummy );
; 1115 :     }
; 1116 : 
; 1117 :     _strupr( ModuleInfo.name );

	mov	rcx, rbx
	call	_strupr

; 1118 :     /* the module name must be a valid identifier, because it's used
; 1119 :      * as part of a segment name in certain memory models.
; 1120 :      */
; 1121 :     for( p = ModuleInfo.name; *p; ++p ) {

	movzx	eax, BYTE PTR ModuleInfo+512
	test	al, al
	je	SHORT $LN3@get_module
	mov	rdi, 576460752706076673			; 0800000018000001H
$LL4@get_module:

; 1122 :         if( !( isalnum( *p ) || ( *p == '_' ) || ( *p == '$' )

	movsx	ecx, BYTE PTR [rbx]
	call	isalnum
	test	eax, eax
	jne	SHORT $LN2@get_module
	movzx	eax, BYTE PTR [rbx]
	sub	al, 36					; 00000024H
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN14@get_module
	movsx	rax, al
	bt	rdi, rax
	jb	SHORT $LN2@get_module
$LN14@get_module:

; 1123 :             || ( *p == '@' ) || ( *p == '?') ) ) {
; 1124 :             /* it's not a legal character for a symbol name */
; 1125 :             *p = '_';

	mov	BYTE PTR [rbx], 95			; 0000005fH
$LN2@get_module:

; 1118 :     /* the module name must be a valid identifier, because it's used
; 1119 :      * as part of a segment name in certain memory models.
; 1120 :      */
; 1121 :     for( p = ModuleInfo.name; *p; ++p ) {

	inc	rbx
	cmp	BYTE PTR [rbx], 0
	jne	SHORT $LL4@get_module
	movzx	eax, BYTE PTR ModuleInfo+512
$LN3@get_module:

; 1126 :         }
; 1127 :     }
; 1128 :     /* first character can't be a digit either */
; 1129 :     if( isdigit( ModuleInfo.name[0] ) ) {

	movsx	ecx, al
	call	isdigit
	movzx	ecx, BYTE PTR ModuleInfo+512
	test	eax, eax

; 1130 :         ModuleInfo.name[0] = '_';
; 1131 :     }
; 1132 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	edx, 95					; 0000005fH
	cmovne	ecx, edx
	mov	BYTE PTR ModuleInfo+512, cl
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
get_module_name ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT OnePass
_TEXT	SEGMENT
OnePass	PROC						; COMDAT

; 990  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+32], rbx

; 991  : 
; 992  :     InputPassInit();

	call	InputPassInit

; 993  :     ModulePassInit();

	call	ModulePassInit

; 994  :     SymPassInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	SymPassInit

; 995  :     LabelInit();

	call	LabelInit

; 996  :     SegmentInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	SegmentInit

; 997  :     ContextInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	ContextInit

; 998  :     ProcInit();

	call	ProcInit

; 999  :     TypesInit();

	call	TypesInit

; 1000 :     HllInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	HllInit

; 1001 :     MacroInit( Parse_Pass ); /* insert predefined macros */

	mov	ecx, DWORD PTR Parse_Pass
	call	MacroInit

; 1002 :     AssumeInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	AssumeInit

; 1003 :     CmdlParamsInit( Parse_Pass );

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN17@OnePass
	call	add_cmdline_tmacros
	mov	rbx, QWORD PTR Options+104
	test	rbx, rbx
	je	SHORT $LN21@OnePass
	npad	2
$LL22@OnePass:
	lea	rcx, QWORD PTR [rbx+8]
	call	AddStringToIncludePath
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL22@OnePass
$LN21@OnePass:
	cmp	BYTE PTR Options+140, 0
	jne	SHORT $LN17@OnePass
	lea	rcx, OFFSET FLAT:$SG11889
	call	getenv
	test	rax, rax
	je	SHORT $LN17@OnePass
	mov	rcx, rax
	call	AddStringToIncludePath
$LN17@OnePass:

; 1004 : 
; 1005 :     ModuleInfo.EndDirFound = FALSE;

	and	DWORD PTR ModuleInfo+408, -65537	; fffeffffH

; 1006 :     ModuleInfo.PhaseError = FALSE;

	mov	BYTE PTR ModuleInfo+422, 0

; 1007 :     //Modend = FALSE;
; 1008 :     /* LineNumber = 0; */
; 1009 :     LinnumInit();

	call	LinnumInit

; 1010 : 
; 1011 : #ifdef DEBUG_OUT
; 1012 :     if ( Parse_Pass > PASS_1 ) {
; 1013 :         DebugMsg(("OnePass(%u) segments (current=%s):\n", Parse_Pass + 1, CurrSeg ? CurrSeg->sym.name : "NULL" ));
; 1014 :         {
; 1015 :             struct dsym *dir;
; 1016 :             for( dir = SymTables[TAB_SEG].head; dir; dir = dir->next ) {
; 1017 :                 DebugMsg(("OnePass(%u): segm=%-8s typ=%X start=%8X max_ofs=%8X\n", Parse_Pass + 1,
; 1018 :                           dir->sym.name, dir->e.seginfo->segtype, dir->e.seginfo->start_loc, dir->sym.max_offset ));
; 1019 :             }
; 1020 :         }
; 1021 :     }
; 1022 : #endif
; 1023 :     /* the functions above might have written something to the line queue */
; 1024 :     if ( is_linequeue_populated() )

	cmp	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN7@OnePass

; 1025 :         RunLineQueue();

	call	RunLineQueue
$LN7@OnePass:

; 1026 : #if FASTPASS
; 1027 :     StoreState = FALSE;
; 1028 :     if ( Parse_Pass > PASS_1 && UseSavedState == TRUE ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	BYTE PTR StoreState, 0
	jbe	$LN8@OnePass
	cmp	BYTE PTR UseSavedState, 1
	jne	$LN8@OnePass

; 1029 :         LineStoreCurr = RestoreState();

	call	RestoreState
	mov	QWORD PTR LineStoreCurr, rax

; 1030 :         while ( LineStoreCurr && ModuleInfo.EndDirFound == FALSE ) {

	test	rax, rax
	je	$LN9@OnePass
	xor	ebx, ebx
$LL2@OnePass:
	test	BYTE PTR ModuleInfo+410, 1
	jne	$LN9@OnePass

; 1031 :             /* the source line is modified in Tokenize() if it contains a comment! */
; 1032 : #if USELSLINE==0
; 1033 :             strcpy( CurrSource, LineStoreCurr->line );
; 1034 : #endif
; 1035 :             set_curr_srcfile( LineStoreCurr->srcfile, LineStoreCurr->lineno );

	mov	ecx, DWORD PTR [rax+8]
	mov	edx, ecx
	and	edx, 1048575				; 000fffffH
	shr	ecx, 20
	call	set_curr_srcfile

; 1036 :             /* v2.06: list flags now initialized on the top level */
; 1037 :             ModuleInfo.line_flags = 0;
; 1038 :             MacroLevel = ( LineStoreCurr->srcfile == 0xFFF ? 1 : 0 );

	mov	rcx, QWORD PTR LineStoreCurr

; 1039 :             DebugMsg1(("OnePass(%u) cur/nxt=%X/%X src=%X.%u mlvl=%u: >%s<\n", Parse_Pass+1, LineStoreCurr, LineStoreCurr->next, LineStoreCurr->srcfile, LineStoreCurr->lineno, MacroLevel, LineStoreCurr->line ));
; 1040 :             ModuleInfo.CurrComment = NULL; /* v2.08: added (var is never reset because GetTextLine() isn't called) */
; 1041 : #if USELSLINE
; 1042 :             if ( Token_Count = Tokenize( LineStoreCurr->line, 0, ModuleInfo.tokenarray, TOK_DEFAULT ) )

	mov	r8, QWORD PTR ModuleInfo+480
	mov	BYTE PTR ModuleInfo+398, bl
	mov	eax, DWORD PTR [rcx+8]
	and	eax, -1048576				; fff00000H
	mov	QWORD PTR ModuleInfo+472, rbx
	cmp	eax, -1048576				; fff00000H
	sete	BYTE PTR MacroLevel
	add	rcx, 16
	xor	r9d, r9d
	xor	edx, edx
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax
	test	eax, eax
	je	SHORT $LN10@OnePass

; 1043 : #else
; 1044 :             if ( Token_Count = Tokenize( CurrSource, 0, ModuleInfo.tokenarray, TOK_DEFAULT ) )
; 1045 : #endif
; 1046 :                 ParseLine( ModuleInfo.tokenarray );

	mov	rcx, QWORD PTR ModuleInfo+480
	call	ParseLine
$LN10@OnePass:

; 1047 :             LineStoreCurr = LineStoreCurr->next;

	mov	rax, QWORD PTR LineStoreCurr
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR LineStoreCurr, rax
	test	rax, rax
	jne	$LL2@OnePass

; 1048 :         }
; 1049 :     } else

	jmp	SHORT $LN9@OnePass
$LN8@OnePass:

; 1050 : #endif
; 1051 :     {
; 1052 :         struct qitem *pq;
; 1053 :         /* v2.11: handle -Fi files here ( previously in CmdlParamsInit ) */
; 1054 :         for ( pq = Options.queues[OPTQ_FINCLUDE]; pq; pq = pq->next ) {

	mov	rbx, QWORD PTR Options+88
	test	rbx, rbx
	je	SHORT $LN5@OnePass
	npad	5
$LL6@OnePass:

; 1055 :             DebugMsg(("OnePass: force include of file: %s\n", pq->value ));
; 1056 :             if ( SearchFile( pq->value, TRUE ) )

	lea	rcx, QWORD PTR [rbx+8]
	mov	dl, 1
	call	SearchFile
	test	rax, rax
	je	SHORT $LN4@OnePass

; 1057 :                 ProcessFile( ModuleInfo.tokenarray );

	mov	rcx, QWORD PTR ModuleInfo+480
	call	ProcessFile
$LN4@OnePass:

; 1050 : #endif
; 1051 :     {
; 1052 :         struct qitem *pq;
; 1053 :         /* v2.11: handle -Fi files here ( previously in CmdlParamsInit ) */
; 1054 :         for ( pq = Options.queues[OPTQ_FINCLUDE]; pq; pq = pq->next ) {

	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL6@OnePass
$LN5@OnePass:

; 1058 :         }
; 1059 :         ProcessFile( ModuleInfo.tokenarray ); /* process the main source file */

	mov	rcx, QWORD PTR ModuleInfo+480
	call	ProcessFile
$LN9@OnePass:

; 1060 :     }
; 1061 : 
; 1062 :     LinnumFini();

	call	LinnumFini

; 1063 : 
; 1064 :     if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	mov	rbx, QWORD PTR [rsp+32]
	jne	SHORT $LN12@OnePass

; 1065 :         PassOneChecks();

	call	PassOneChecks
$LN12@OnePass:

; 1066 : 
; 1067 :     ClearSrcStack();

	call	ClearSrcStack

; 1068 : 
; 1069 :     return( 1 );

	mov	eax, 1

; 1070 : }

	add	rsp, 40					; 00000028H
	ret	0
OnePass	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT PassOneChecks
_TEXT	SEGMENT
PassOneChecks PROC					; COMDAT

; 764  : {

	sub	rsp, 40					; 00000028H

; 765  :     struct dsym *curr;
; 766  :     struct dsym *next;
; 767  :     struct qnode *q;
; 768  :     struct qnode *qn;
; 769  : #ifdef DEBUG_OUT
; 770  :     int cntUnusedExt = 0;
; 771  : #endif
; 772  : 
; 773  :     /* check for open structures and segments has been done inside the
; 774  :      * END directive handling already
; 775  :      * v2.10: now done for PROCs as well, since procedures
; 776  :      * must be closed BEFORE segments are to be closed.
; 777  :      */
; 778  :     //ProcCheckOpen();
; 779  :     HllCheckOpen();

	call	HllCheckOpen

; 780  :     CondCheckOpen();

	call	CondCheckOpen

; 781  : 
; 782  :     if( ModuleInfo.EndDirFound == FALSE )

	test	BYTE PTR ModuleInfo+410, 1
	jne	SHORT $LN17@PassOneChe

; 783  :         EmitError( END_DIRECTIVE_REQUIRED );

	mov	ecx, 99					; 00000063H
	call	EmitError
$LN17@PassOneChe:

; 784  : 
; 785  : #ifdef DEBUG_OUT
; 786  :     for ( curr = SymTables[TAB_UNDEF].head; curr; curr = curr->next ) {
; 787  :         DebugMsg(("PassOneChecks: undefined symbol %s\n", curr->sym.name ));
; 788  :     }
; 789  : #endif
; 790  :     /* v2.04: check the publics queue.
; 791  :      * - only internal symbols can be public.
; 792  :      * - weak external symbols are filtered ( since v2.11 )
; 793  :      * - anything else is an error
; 794  :      * v2.11: moved here ( from inside the "#if FASTPASS"-block )
; 795  :      * because the loop will now filter weak externals [ this
; 796  :      * was previously done in GetPublicSymbols() ]
; 797  :      */
; 798  :     for( q = ModuleInfo.g.PubQueue.head, qn = (struct qnode *)&ModuleInfo.g.PubQueue ; q; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo+16
	lea	rcx, OFFSET FLAT:ModuleInfo+16
	test	rax, rax
	je	SHORT $LN3@PassOneChe
	npad	12
$LL4@PassOneChe:

; 799  : 
; 800  :         if ( q->sym->state == SYM_INTERNAL )

	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR [r8+32]
	cmp	edx, 1
	jne	SHORT $LN18@PassOneChe

; 801  :             qn = q;

	mov	rcx, rax
	jmp	SHORT $LN2@PassOneChe
$LN18@PassOneChe:

; 802  :         else if ( q->sym->state == SYM_EXTERNAL && q->sym->weak == TRUE ) {

	cmp	edx, 2
	jne	SHORT $LN20@PassOneChe
	test	BYTE PTR [r8+47], 8
	je	SHORT $LN20@PassOneChe

; 803  :             DebugMsg(("PassOneChecks: public for weak external skipped: %s\n", q->sym->name ));
; 804  :             qn->next = q->next;

	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 805  :             LclFree( q );
; 806  :             q = qn;

	mov	rax, rcx
$LN2@PassOneChe:

; 784  : 
; 785  : #ifdef DEBUG_OUT
; 786  :     for ( curr = SymTables[TAB_UNDEF].head; curr; curr = curr->next ) {
; 787  :         DebugMsg(("PassOneChecks: undefined symbol %s\n", curr->sym.name ));
; 788  :     }
; 789  : #endif
; 790  :     /* v2.04: check the publics queue.
; 791  :      * - only internal symbols can be public.
; 792  :      * - weak external symbols are filtered ( since v2.11 )
; 793  :      * - anything else is an error
; 794  :      * v2.11: moved here ( from inside the "#if FASTPASS"-block )
; 795  :      * because the loop will now filter weak externals [ this
; 796  :      * was previously done in GetPublicSymbols() ]
; 797  :      */
; 798  :     for( q = ModuleInfo.g.PubQueue.head, qn = (struct qnode *)&ModuleInfo.g.PubQueue ; q; q = q->next ) {

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL4@PassOneChe

; 862  :             /* check if symbol is external or public */
; 863  :             if ( sym == NULL ||

	jmp	SHORT $LN3@PassOneChe
$LN20@PassOneChe:

; 807  :         } else {
; 808  :             DebugMsg(("PassOneChecks: invalid public attribute for %s [state=%u weak=%u]\n", q->sym->name, q->sym->state, q->sym->weak ));
; 809  : #if FASTPASS
; 810  :             SkipSavedState();

	call	SkipSavedState
$LN3@PassOneChe:

; 811  : #endif
; 812  :             break;
; 813  :         }
; 814  :     }
; 815  : #if FASTPASS
; 816  :     if ( SymTables[TAB_UNDEF].head ) {
; 817  :         /* to force a full second pass in case of missing symbols,
; 818  :          * activate the next line. It was implemented to have proper
; 819  :          * error displays if a forward reference wasn't found.
; 820  :          * However, v1.95 final won't need this anymore, because both
; 821  :          * filename + lineno for every line is known now in pass 2.
; 822  :          */
; 823  :         /* SkipSavedState(); */
; 824  :     }
; 825  : 
; 826  :     /* check if there's an undefined segment reference.
; 827  :      * This segment was an argument to a group definition then.
; 828  :      * Just do a full second pass, the GROUP directive will report
; 829  :      * the error.
; 830  :      */
; 831  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rax, QWORD PTR SymTables+32
	test	rax, rax
	je	SHORT $LN6@PassOneChe
$LL7@PassOneChe:

; 832  :         if( curr->sym.segment == NULL ) {

	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN51@PassOneChe

; 811  : #endif
; 812  :             break;
; 813  :         }
; 814  :     }
; 815  : #if FASTPASS
; 816  :     if ( SymTables[TAB_UNDEF].head ) {
; 817  :         /* to force a full second pass in case of missing symbols,
; 818  :          * activate the next line. It was implemented to have proper
; 819  :          * error displays if a forward reference wasn't found.
; 820  :          * However, v1.95 final won't need this anymore, because both
; 821  :          * filename + lineno for every line is known now in pass 2.
; 822  :          */
; 823  :         /* SkipSavedState(); */
; 824  :     }
; 825  : 
; 826  :     /* check if there's an undefined segment reference.
; 827  :      * This segment was an argument to a group definition then.
; 828  :      * Just do a full second pass, the GROUP directive will report
; 829  :      * the error.
; 830  :      */
; 831  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rax, QWORD PTR [rax+104]
	test	rax, rax
	jne	SHORT $LL7@PassOneChe

; 862  :             /* check if symbol is external or public */
; 863  :             if ( sym == NULL ||

	jmp	SHORT $LN6@PassOneChe
$LN51@PassOneChe:

; 833  :             DebugMsg(("PassOneChecks: undefined segment %s\n", curr->sym.name ));
; 834  :             SkipSavedState();

	call	SkipSavedState
$LN6@PassOneChe:

; 835  :             break;
; 836  :         }
; 837  :     }
; 838  : #if COFF_SUPPORT
; 839  :     /* if there's an item in the safeseh list which is not an
; 840  :      * internal proc, make a full second pass to emit a proper
; 841  :      * error msg at the .SAFESEH directive
; 842  :      */
; 843  :     for ( q = ModuleInfo.g.SafeSEHQueue.head; q; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo+48
	test	rax, rax
	je	SHORT $LN9@PassOneChe
$LL10@PassOneChe:

; 844  :         if ( q->sym->state != SYM_INTERNAL || q->sym->isproc == FALSE ) {

	mov	rcx, QWORD PTR [rax+8]
	cmp	DWORD PTR [rcx+32], 1
	jne	SHORT $LN52@PassOneChe
	test	BYTE PTR [rcx+41], 8
	je	SHORT $LN52@PassOneChe

; 835  :             break;
; 836  :         }
; 837  :     }
; 838  : #if COFF_SUPPORT
; 839  :     /* if there's an item in the safeseh list which is not an
; 840  :      * internal proc, make a full second pass to emit a proper
; 841  :      * error msg at the .SAFESEH directive
; 842  :      */
; 843  :     for ( q = ModuleInfo.g.SafeSEHQueue.head; q; q = q->next ) {

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL10@PassOneChe

; 862  :             /* check if symbol is external or public */
; 863  :             if ( sym == NULL ||

	jmp	SHORT $LN9@PassOneChe
$LN52@PassOneChe:

; 845  :             SkipSavedState();

	call	SkipSavedState
$LN9@PassOneChe:
	mov	eax, DWORD PTR Options+144
	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	SHORT $LN12@PassOneChe

; 846  :             break;
; 847  :         }
; 848  :     }
; 849  : #endif
; 850  : 
; 851  :     /* scan ALIASes for COFF/ELF */
; 852  : 
; 853  : #if COFF_SUPPORT || ELF_SUPPORT
; 854  :     if ( Options.output_format == OFORMAT_COFF
; 855  : #if ELF_SUPPORT
; 856  :         || Options.output_format == OFORMAT_ELF
; 857  : #endif
; 858  :        ) {
; 859  :         for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {

	mov	rcx, QWORD PTR SymTables+80
	test	rcx, rcx
	je	SHORT $LN12@PassOneChe
	npad	2
$LL13@PassOneChe:

; 860  :             struct asym *sym;
; 861  :             sym = curr->sym.substitute;

	mov	rax, QWORD PTR [rcx+16]

; 862  :             /* check if symbol is external or public */
; 863  :             if ( sym == NULL ||

	test	rax, rax
	je	SHORT $LN53@PassOneChe
	mov	edx, DWORD PTR [rax+32]
	cmp	edx, 2
	je	SHORT $LN72@PassOneChe
	cmp	edx, 1
	jne	SHORT $LN53@PassOneChe
	test	BYTE PTR [rax+40], 128			; 00000080H
	je	SHORT $LN53@PassOneChe

; 867  :                 break;
; 868  :             }
; 869  :             /* make sure it becomes a strong external */
; 870  :             if ( sym->state == SYM_EXTERNAL )

	cmp	edx, 2
	jne	SHORT $LN11@PassOneChe
$LN72@PassOneChe:

; 871  :                 sym->used = TRUE;

	or	BYTE PTR [rax+40], 1
$LN11@PassOneChe:

; 846  :             break;
; 847  :         }
; 848  :     }
; 849  : #endif
; 850  : 
; 851  :     /* scan ALIASes for COFF/ELF */
; 852  : 
; 853  : #if COFF_SUPPORT || ELF_SUPPORT
; 854  :     if ( Options.output_format == OFORMAT_COFF
; 855  : #if ELF_SUPPORT
; 856  :         || Options.output_format == OFORMAT_ELF
; 857  : #endif
; 858  :        ) {
; 859  :         for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {

	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL13@PassOneChe

; 862  :             /* check if symbol is external or public */
; 863  :             if ( sym == NULL ||

	jmp	SHORT $LN12@PassOneChe
$LN53@PassOneChe:

; 864  :                 ( sym->state != SYM_EXTERNAL &&
; 865  :                  ( sym->state != SYM_INTERNAL || sym->ispublic == FALSE ))) {
; 866  :                 SkipSavedState();

	call	SkipSavedState
$LN12@PassOneChe:

; 872  :         }
; 873  :     }
; 874  : #endif
; 875  : 
; 876  : #endif /* FASTPASS */
; 877  : 
; 878  :     /* scan the EXTERN/EXTERNDEF items */
; 879  : 
; 880  :     for( curr = SymTables[TAB_EXT].head ; curr; curr = next ) {

	mov	rax, QWORD PTR SymTables+16
	test	rax, rax
	je	$LN15@PassOneChe
	mov	QWORD PTR [rsp+32], rbx
	npad	6
$LL16@PassOneChe:

; 881  :         next = curr->next;
; 882  :         /* v2.01: externdefs which have been "used" become "strong" */
; 883  :         if ( curr->sym.used )

	movzx	ecx, BYTE PTR [rax+40]
	mov	rbx, QWORD PTR [rax+104]
	test	cl, 1
	je	SHORT $LN32@PassOneChe

; 884  :             curr->sym.weak = FALSE;

	and	BYTE PTR [rax+47], 247			; 000000f7H
$LN32@PassOneChe:

; 885  :         /* remove unused EXTERNDEF/PROTO items from queue. */
; 886  :         if ( curr->sym.weak == TRUE
; 887  : #if DLLIMPORT
; 888  :             && curr->sym.iat_used == FALSE

	movzx	edx, BYTE PTR [rax+47]
	test	dl, 8
	je	SHORT $LN33@PassOneChe
	test	cl, 8
	jne	SHORT $LN33@PassOneChe

; 889  : #endif
; 890  :            ) {
; 891  :             sym_remove_table( &SymTables[TAB_EXT], curr );

	mov	rdx, rax
	lea	rcx, OFFSET FLAT:SymTables+16
	call	sym_remove_table

; 892  : #ifdef DEBUG_OUT
; 893  :             cntUnusedExt++;
; 894  : #endif
; 895  :             continue;

	jmp	SHORT $LN14@PassOneChe
$LN33@PassOneChe:

; 896  :         }
; 897  : 
; 898  : #if FASTMEM==0
; 899  :         /* v2.05: clear fixup list (used for backpatching in pass one) */
; 900  :         if ( curr->sym.bp_fixup ) {
; 901  :             struct fixup *c;
; 902  :             struct fixup *n;
; 903  :             for( c = curr->sym.bp_fixup ; c; ) {
; 904  :                 n = c->nextbp;
; 905  :                 LclFree( c );
; 906  :                 c = n;
; 907  :             }
; 908  :             curr->sym.bp_fixup = NULL;
; 909  :         }
; 910  : #endif
; 911  : 
; 912  :         if ( curr->sym.iscomm == TRUE )

	test	dl, 4
	jne	SHORT $LN14@PassOneChe

; 913  :             continue;
; 914  :         /* optional alternate symbol must be INTERNAL or EXTERNAL.
; 915  :          * COFF ( and ELF? ) also wants internal symbols to be public
; 916  :          * ( which is reasonable, since the linker won't know private
; 917  :          * symbols and hence will search for a symbol of that name
; 918  :          * "elsewhere" ).
; 919  :          */
; 920  : #if FASTPASS
; 921  :         if ( curr->sym.altname ) {

	mov	rcx, QWORD PTR [rax+64]
	test	rcx, rcx
	je	SHORT $LN14@PassOneChe

; 922  :             if ( curr->sym.altname->state == SYM_INTERNAL ) {

	mov	eax, DWORD PTR [rcx+32]
	cmp	eax, 1
	jne	SHORT $LN36@PassOneChe

; 923  : #if COFF_SUPPORT || ELF_SUPPORT
; 924  :                 /* for COFF/ELF, the altname must be public or external */
; 925  :                 if ( curr->sym.altname->ispublic == FALSE &&

	test	BYTE PTR [rcx+40], 128			; 00000080H
	jne	SHORT $LN14@PassOneChe
	mov	eax, DWORD PTR Options+144
	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	SHORT $LN14@PassOneChe

; 926  :                     ( Options.output_format == OFORMAT_COFF
; 927  : #if ELF_SUPPORT
; 928  :                      || Options.output_format == OFORMAT_ELF
; 929  : #endif
; 930  :                     ) ) {
; 931  :                     SkipSavedState();
; 932  :                 }

	jmp	SHORT $LN73@PassOneChe
$LN36@PassOneChe:

; 933  : #endif
; 934  :             } else if ( curr->sym.altname->state != SYM_EXTERNAL ) {

	cmp	eax, 2
	je	SHORT $LN14@PassOneChe
$LN73@PassOneChe:

; 935  :                 /* do not use saved state, scan full source in second pass */
; 936  :                 SkipSavedState();

	call	SkipSavedState
$LN14@PassOneChe:

; 872  :         }
; 873  :     }
; 874  : #endif
; 875  : 
; 876  : #endif /* FASTPASS */
; 877  : 
; 878  :     /* scan the EXTERN/EXTERNDEF items */
; 879  : 
; 880  :     for( curr = SymTables[TAB_EXT].head ; curr; curr = next ) {

	mov	rax, rbx
	test	rbx, rbx
	jne	SHORT $LL16@PassOneChe
	mov	rbx, QWORD PTR [rsp+32]
$LN15@PassOneChe:

; 937  :             }
; 938  :         }
; 939  : #endif
; 940  :     }
; 941  : 
; 942  : #ifdef DEBUG_OUT
; 943  :     DebugMsg(("PassOneChecks: removed unused externals: %u\n", cntUnusedExt ));
; 944  :     DebugMsg(("PassOneChecks: forward references:\n"));
; 945  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {
; 946  :         int i;
; 947  :         int j;
; 948  :         struct asym * sym;
; 949  :         struct fixup * fix;
; 950  :         for ( i = 0, j = 0, sym = curr->e.seginfo->label_list; sym; sym = (struct asym *)((struct dsym *)sym)->next ) {
; 951  :             i++;
; 952  :             for ( fix = sym->bp_fixup; fix ; fix = fix->nextbp, j++ );
; 953  :         }
; 954  :         DebugMsg(("PassOneChecks: segm=%s, labels=%u forward refs=%u\n", curr->sym.name, i, j));
; 955  :     }
; 956  : #endif
; 957  : 
; 958  :     if ( ModuleInfo.g.error_count == 0 ) {

	cmp	DWORD PTR ModuleInfo, 0
	jne	SHORT $LN44@PassOneChe

; 959  : 
; 960  :         /* make all symbols of type SYM_INTERNAL, which aren't
; 961  :          a constant, public.  */
; 962  :         if ( Options.all_symbols_public )

	cmp	BYTE PTR Options+138, 0
	je	SHORT $LN42@PassOneChe

; 963  :             SymMakeAllSymbolsPublic();

	call	SymMakeAllSymbolsPublic
$LN42@PassOneChe:

; 964  : 
; 965  :         if ( Options.syntax_check_only == FALSE )

	movzx	eax, BYTE PTR write_to_file
	mov	ecx, 1
	cmp	BYTE PTR Options+172, 0
	cmove	eax, ecx
	mov	BYTE PTR write_to_file, al

; 966  :             write_to_file = TRUE;
; 967  : 
; 968  :         if ( ModuleInfo.g.Pass1Checks )

	mov	rax, QWORD PTR ModuleInfo+304
	test	rax, rax
	je	SHORT $LN44@PassOneChe

; 969  :             ModuleInfo.g.Pass1Checks( &ModuleInfo );

	lea	rcx, OFFSET FLAT:ModuleInfo

; 970  :     }
; 971  : 
; 972  : 
; 973  :     return;
; 974  : }

	add	rsp, 40					; 00000028H

; 969  :             ModuleInfo.g.Pass1Checks( &ModuleInfo );

	rex_jmp	rax
$LN44@PassOneChe:

; 970  :     }
; 971  : 
; 972  : 
; 973  :     return;
; 974  : }

	add	rsp, 40					; 00000028H
	ret	0
PassOneChecks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT ModulePassInit
_TEXT	SEGMENT
ModulePassInit PROC					; COMDAT

; 640  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 641  :     enum cpu_info cpu = Options.cpu;
; 642  :     enum model_type model = Options.model;
; 643  : #if DLLIMPORT
; 644  :     struct dsym *curr;
; 645  : #endif
; 646  : 
; 647  :     DebugMsg(( "ModulePassInit() enter\n" ));
; 648  :     /* set default values not affected by the masm 5.1 compat switch */
; 649  :     ModuleInfo.procs_private = FALSE;
; 650  :     ModuleInfo.procs_export = FALSE;

	mov	edx, DWORD PTR ModuleInfo+408
	mov	ecx, DWORD PTR Options+164
	and	edx, -13				; fffffff3H
	mov	ebx, DWORD PTR Options+160

; 651  :     ModuleInfo.offsettype = OT_GROUP;
; 652  :     ModuleInfo.scoped = TRUE;

	bts	edx, 7

; 653  : 
; 654  : 
; 655  : #if FASTPASS
; 656  :     /* v2.03: don't generate the code if fastpass is active */
; 657  :     /* v2.08: query UseSavedState instead of StoreState */
; 658  :     //if ( StoreState == FALSE ) {
; 659  :     if ( UseSavedState == FALSE ) {

	cmp	BYTE PTR UseSavedState, 0
	mov	DWORD PTR ModuleInfo+384, 0
	mov	DWORD PTR ModuleInfo+408, edx
	jne	$LN11@ModulePass

; 660  : #endif
; 661  :         ModuleInfo.langtype = Options.langtype;
; 662  :         ModuleInfo.fctype = Options.fctype;
; 663  : #if AMD64_SUPPORT
; 664  :         if ( ModuleInfo.sub_format == SFORMAT_64BIT ) {

	cmp	DWORD PTR ModuleInfo+372, 3
	mov	edx, DWORD PTR Options+156
	mov	eax, DWORD PTR Options+168
	mov	DWORD PTR ModuleInfo+364, edx
	mov	DWORD PTR ModuleInfo+376, eax
	jne	SHORT $LN6@ModulePass

; 665  :             /* v2.06: force cpu to be at least P_64, without side effect to Options.cpu */
; 666  :             if ( ( cpu &  P_CPU_MASK ) < P_64 ) /* enforce cpu to be 64-bit */

	mov	r8d, 112				; 00000070H
	mov	eax, ecx
	and	eax, 240				; 000000f0H
	cmp	eax, r8d
	cmovl	ecx, r8d

; 667  :                 cpu = P_64;
; 668  :             /* ignore -m switch for 64-bit formats.
; 669  :              * there's no other model than FLAT possible.
; 670  :              */
; 671  :             model = MODEL_FLAT;

	lea	ebx, QWORD PTR [r8-105]

; 672  :             if ( ModuleInfo.langtype == LANG_NONE && Options.output_format == OFORMAT_COFF )

	test	edx, edx
	jne	SHORT $LN10@ModulePass
	cmp	DWORD PTR Options+144, 2
	jne	SHORT $LN10@ModulePass

; 673  :                 ModuleInfo.langtype = LANG_FASTCALL;

	mov	DWORD PTR ModuleInfo+364, ebx

; 674  :         } else

	jmp	SHORT $LN10@ModulePass
$LN6@ModulePass:

; 675  : #endif
; 676  :             /* if model FLAT is to be set, ensure that cpu is compat. */
; 677  :             if ( model == MODEL_FLAT && ( cpu & P_CPU_MASK ) < P_386 ) /* cpu < 386? */

	cmp	ebx, 7
	jne	SHORT $LN10@ModulePass
	mov	eax, ecx
	mov	edx, 48					; 00000030H
	and	eax, 240				; 000000f0H
	cmp	eax, edx
	cmovl	ecx, edx
$LN10@ModulePass:

; 678  :                 cpu = P_386;
; 679  : 
; 680  :         SetCPU( cpu );

	call	SetCPU

; 681  :         /* table ModelToken starts with MODEL_TINY, which is index 1" */
; 682  :         if ( model != MODEL_NONE )

	test	ebx, ebx
	je	SHORT $LN23@ModulePass

; 683  :             AddLineQueueX( "%r %s", T_DOT_MODEL, ModelToken[model - 1] );

	lea	rax, OFFSET FLAT:ModelToken
	movsxd	r8, ebx
	mov	edx, 342				; 00000156H
	lea	rcx, OFFSET FLAT:$SG11926
	mov	r8, QWORD PTR [rax+r8*8-8]
	call	AddLineQueueX
$LN23@ModulePass:
	mov	edx, DWORD PTR ModuleInfo+408
$LN11@ModulePass:

; 684  : 
; 685  : #if FASTPASS
; 686  :     }
; 687  : #endif
; 688  : 
; 689  :     SetMasm510( Options.masm51_compat );

	movzx	ecx, BYTE PTR Options+126
	and	edx, -1361				; fffffaafH
	mov	eax, ecx
	and	eax, 1
	lea	r8d, DWORD PTR [rax*4]
	or	r8d, eax
	shl	r8d, 2
	or	r8d, eax
	shl	r8d, 2
	or	r8d, eax
	shl	r8d, 4
	or	r8d, edx
	test	cl, cl
	je	SHORT $LN17@ModulePass
	cmp	DWORD PTR ModuleInfo+360, 0
	jne	SHORT $LN17@ModulePass
	cmp	DWORD PTR ModuleInfo+364, 0
	mov	DWORD PTR ModuleInfo+384, 2
	jne	SHORT $LN17@ModulePass
	btr	r8d, 7
	or	r8d, 4
$LN17@ModulePass:

; 690  :     ModuleInfo.defOfssize = USE16;
; 691  :     ModuleInfo.ljmp     = TRUE;
; 692  : 
; 693  :     ModuleInfo.list   = Options.write_listing;
; 694  :     ModuleInfo.cref   = TRUE;
; 695  :     ModuleInfo.listif = Options.listif;
; 696  :     ModuleInfo.list_generated_code = Options.list_generated_code;

	movzx	edx, BYTE PTR Options+131
	and	r8d, -26625				; ffff97ffH
	movzx	eax, BYTE PTR Options+130
	and	edx, 1

; 697  :     ModuleInfo.list_macro = Options.list_macro;
; 698  : 
; 699  :     ModuleInfo.case_sensitive = Options.case_sensitive;
; 700  :     ModuleInfo.convert_uppercase = Options.convert_uppercase;

	movzx	ecx, BYTE PTR Options+124
	add	edx, edx
	and	eax, 1
	mov	BYTE PTR ModuleInfo+405, 0
	or	edx, eax
	and	ecx, 1
	movzx	eax, BYTE PTR Options+121
	add	ecx, ecx
	shl	edx, 2
	and	eax, 1
	or	edx, eax
	mov	eax, DWORD PTR Options+132
	shl	edx, 11
	mov	DWORD PTR ModuleInfo+400, eax
	or	edx, r8d
	movzx	eax, BYTE PTR Options+123
	or	edx, 4128				; 00001020H
	and	eax, 1
	and	edx, -4					; fffffffcH
	or	ecx, eax
	or	ecx, edx
	mov	DWORD PTR ModuleInfo+408, ecx

; 701  :     SymSetCmpFunc();

	call	SymSetCmpFunc

; 702  : 
; 703  :     ModuleInfo.segorder = SEGORDER_SEQ;
; 704  :     ModuleInfo.radix = 10;
; 705  :     ModuleInfo.fieldalign = Options.fieldalign;
; 706  : #if PROCALIGN
; 707  :     ModuleInfo.procalign = 0;
; 708  : #endif
; 709  : #if DLLIMPORT
; 710  :     /* if OPTION DLLIMPORT was used, reset all iat_used flags */
; 711  :     if ( ModuleInfo.g.DllQueue )

	cmp	QWORD PTR ModuleInfo+80, 0
	movzx	eax, BYTE PTR Options+152
	mov	BYTE PTR ModuleInfo+397, al
	mov	DWORD PTR ModuleInfo+380, 0
	mov	BYTE PTR ModuleInfo+396, 10
	mov	BYTE PTR ModuleInfo+399, 0
	je	SHORT $LN3@ModulePass

; 712  :         for ( curr = SymTables[TAB_EXT].head; curr; curr = curr->next )

	mov	rax, QWORD PTR SymTables+16
	test	rax, rax
	je	SHORT $LN3@ModulePass
	npad	6
$LL4@ModulePass:

; 713  :             curr->sym.iat_used = FALSE;

	and	BYTE PTR [rax+40], 247			; 000000f7H
	mov	rax, QWORD PTR [rax+104]
	test	rax, rax
	jne	SHORT $LL4@ModulePass
$LN3@ModulePass:

; 714  : #endif
; 715  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ModulePassInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT CmdlParamsInit
_TEXT	SEGMENT
pass$ = 48
CmdlParamsInit PROC					; COMDAT

; 520  : {

	sub	rsp, 40					; 00000028H

; 521  :     DebugMsg(("CmdlParamsInit(%u) enter\n", pass));
; 522  : 
; 523  : #if BUILD_TARGET
; 524  :     if ( pass == PASS_1 ) {
; 525  :         struct asym *sym;
; 526  :         char *tmp;
; 527  :         char *p;
; 528  : 
; 529  :         _strupr( Options.build_target );
; 530  :         tmp = myalloca( strlen( Options.build_target ) + 5 ); /* null + 4 uscores */
; 531  :         strcpy( tmp, uscores );
; 532  :         strcat( tmp, Options.build_target );
; 533  :         strcat( tmp, uscores );
; 534  : 
; 535  :         /* define target */
; 536  :         sym = CreateVariable( tmp, 0 );
; 537  :         sym->predefined = TRUE;
; 538  : 
; 539  :         p = NULL;
; 540  :         if( _stricmp( Options.build_target, "DOS" ) == 0 ) {
; 541  :             p = "__MSDOS__";
; 542  :         } else if( _stricmp( Options.build_target, "NETWARE" ) == 0 ) {
; 543  :             if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {
; 544  :                 p = "__NETWARE_386__";
; 545  :             } else {
; 546  :                 /* do nothing ... __NETWARE__ already defined */
; 547  :             }
; 548  :         } else if( _stricmp( Options.build_target, "WINDOWS" ) == 0 ) {
; 549  :             if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {
; 550  :                 p = "__WINDOWS_386__";
; 551  :             } else {
; 552  :                 /* do nothing ... __WINDOWS__ already defined */
; 553  :             }
; 554  :         } else if( _stricmp( Options.build_target, "QNX" ) == 0 ) {
; 555  :             p = "__UNIX__";
; 556  :         } else if( _stricmp( Options.build_target, "LINUX" ) == 0 ) {
; 557  :             p = "__UNIX__";
; 558  :         }
; 559  :         if ( p ) {
; 560  :             sym = CreateVariable( p, 0 );
; 561  :             sym->predefined = TRUE;
; 562  :         }
; 563  :     }
; 564  : #endif
; 565  : 
; 566  :     if ( pass == PASS_1 ) {

	test	ecx, ecx
	jne	SHORT $LN4@CmdlParams

; 567  :         char *env;
; 568  :         /* v2.06: this is done in ModulePassInit now */
; 569  :         //SetCPU( Options.cpu );
; 570  :         add_cmdline_tmacros();

	mov	QWORD PTR [rsp+32], rbx
	call	add_cmdline_tmacros

; 571  :         add_incpaths();

	mov	rbx, QWORD PTR Options+104
	test	rbx, rbx
	je	SHORT $LN8@CmdlParams
	npad	2
$LL9@CmdlParams:
	lea	rcx, QWORD PTR [rbx+8]
	call	AddStringToIncludePath
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL9@CmdlParams
$LN8@CmdlParams:

; 572  :         if ( Options.ignore_include == FALSE )

	cmp	BYTE PTR Options+140, 0
	mov	rbx, QWORD PTR [rsp+32]
	jne	SHORT $LN4@CmdlParams

; 573  :             if ( env = getenv( "INCLUDE" ) )

	lea	rcx, OFFSET FLAT:$SG11889
	call	getenv
	test	rax, rax
	je	SHORT $LN4@CmdlParams

; 574  :                 AddStringToIncludePath( env );

	mov	rcx, rax

; 575  :     }
; 576  :     DebugMsg(("CmdlParamsInit exit\n"));
; 577  :     return;
; 578  : }

	add	rsp, 40					; 00000028H

; 574  :                 AddStringToIncludePath( env );

	jmp	AddStringToIncludePath
$LN4@CmdlParams:

; 575  :     }
; 576  :     DebugMsg(("CmdlParamsInit exit\n"));
; 577  :     return;
; 578  : }

	add	rsp, 40					; 00000028H
	ret	0
CmdlParamsInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT add_incpaths
_TEXT	SEGMENT
add_incpaths PROC					; COMDAT

; 507  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 508  :     struct qitem *p;
; 509  :     DebugMsg(("add_incpaths: enter\n"));
; 510  :     for ( p = Options.queues[OPTQ_INCPATH]; p; p = p->next ) {

	mov	rbx, QWORD PTR Options+104
	test	rbx, rbx
	je	SHORT $LN3@add_incpat
$LL4@add_incpat:

; 511  :         AddStringToIncludePath( p->value );

	lea	rcx, QWORD PTR [rbx+8]
	call	AddStringToIncludePath
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL4@add_incpat
$LN3@add_incpat:

; 512  :     }
; 513  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
add_incpaths ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT add_cmdline_tmacros
_TEXT	SEGMENT
add_cmdline_tmacros PROC				; COMDAT

; 457  : {

	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	lea	rbp, QWORD PTR [rsp+32]

; 458  :     struct qitem *p;
; 459  :     char *name;
; 460  :     char *value;
; 461  :     int len;
; 462  :     struct asym *sym;
; 463  : 
; 464  :     DebugMsg(("add_cmdline_tmacros enter\n"));
; 465  :     for ( p = Options.queues[OPTQ_MACRO]; p; p = p->next ) {

	mov	r15, QWORD PTR Options+96
	mov	QWORD PTR [rbp+48], rbx
	mov	QWORD PTR [rbp+56], rsi
	mov	QWORD PTR [rbp+64], rdi
	test	r15, r15
	je	$LN3@add_cmdlin
	mov	rbx, 576460752706077697			; 0800000018000401H
	mov	r13, 1152921504606846960		; 0ffffffffffffff0H
	mov	r12, 576460752706076673			; 0800000018000001H
	npad	3
$LL4@add_cmdlin:

; 466  :         DebugMsg(("add_cmdline_tmacros: found >%s<\n", p->value));
; 467  :         name = p->value;

	lea	r14, QWORD PTR [r15+8]

; 468  :         value = strchr( name, '=' );

	mov	edx, 61					; 0000003dH
	mov	rcx, r14
	mov	rsi, r14
	call	strchr
	mov	rdi, rax

; 469  :         if( value == NULL ) {

	test	rax, rax
	jne	SHORT $LN5@add_cmdlin

; 470  :             /* v2.06: ensure that 'value' doesn't point to r/o space */
; 471  :             //value = "";
; 472  :             value = name + strlen( name ); /* use the terminating NULL */

	or	rdi, -1
$LL42@add_cmdlin:
	inc	rdi
	cmp	BYTE PTR [r14+rdi], 0
	jne	SHORT $LL42@add_cmdlin
	add	rdi, r14

; 473  :         } else {

	jmp	SHORT $LN6@add_cmdlin
$LN5@add_cmdlin:

; 474  :             len = value - name;

	mov	r8d, eax
	sub	r8d, r14d

; 475  :             name = (char *)myalloca( len + 1 );

	lea	eax, DWORD PTR [r8+1]
	movsxd	rcx, eax
	lea	rax, QWORD PTR [rcx+15]
	cmp	rax, rcx
	ja	SHORT $LN41@add_cmdlin
	mov	rax, r13
$LN41@add_cmdlin:
	and	rax, -16
	call	__chkstk
	sub	rsp, rax

; 476  :             memcpy( name, p->value, len );

	movsxd	rbx, r8d
	mov	r8, rbx
	mov	rdx, r14
	lea	rsi, QWORD PTR [rsp+32]
	mov	rcx, rsi
	call	memcpy

; 477  :             *(name + len) = NULLC;

	mov	BYTE PTR [rbx+rsi], 0

; 478  :             value++;

	inc	rdi
	mov	rbx, 576460752706077697			; 0800000018000401H
$LN6@add_cmdlin:

; 479  :         }
; 480  : 
; 481  :         /* there's no check whether the name is a reserved word!
; 482  :          */
; 483  :         if( is_valid_identifier( name ) == ERROR ) {

	movsx	ecx, BYTE PTR [rsi]
	call	isalpha
	test	eax, eax
	jne	SHORT $LN17@add_cmdlin
	movzx	eax, BYTE PTR [rsi]
	sub	al, 36					; 00000024H
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN35@add_cmdlin
	movsx	rax, al
	bt	rbx, rax
	jae	SHORT $LN35@add_cmdlin
$LN17@add_cmdlin:
	movzx	eax, BYTE PTR [rsi+1]
	lea	rbx, QWORD PTR [rsi+1]
	test	al, al
	je	SHORT $LN15@add_cmdlin
$LL16@add_cmdlin:
	movsx	ecx, al
	call	isalnum
	test	eax, eax
	jne	SHORT $LN23@add_cmdlin
	movzx	eax, BYTE PTR [rbx]
	sub	al, 36					; 00000024H
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN35@add_cmdlin
	bt	r12, rax
	jae	SHORT $LN35@add_cmdlin
$LN23@add_cmdlin:
	movzx	eax, BYTE PTR [rbx+1]
	inc	rbx
	test	al, al
	jne	SHORT $LL16@add_cmdlin
$LN15@add_cmdlin:
	cmp	BYTE PTR [rbx-1], 46			; 0000002eH
	jne	SHORT $LN7@add_cmdlin
$LN35@add_cmdlin:

; 484  :             DebugMsg(("add_cmdline_tmacros: name >%s< invalid\n", name ));
; 485  :             EmitErr( SYNTAX_ERROR_EX, name );

	mov	ecx, 209				; 000000d1H

; 486  :         } else {

	jmp	SHORT $LN43@add_cmdlin
$LN7@add_cmdlin:

; 487  :             sym = SymSearch( name );

	mov	rcx, rsi
	call	SymFind

; 488  :             if ( sym == NULL ) {

	test	rax, rax
	jne	SHORT $LN9@add_cmdlin

; 489  :                 sym = SymCreate( name );

	mov	rcx, rsi
	call	SymCreate

; 490  :                 sym->state = SYM_TMACRO;

	mov	DWORD PTR [rax+32], 10
$LN9@add_cmdlin:

; 491  :             }
; 492  :             if ( sym->state == SYM_TMACRO ) {

	cmp	DWORD PTR [rax+32], 10
	jne	SHORT $LN10@add_cmdlin

; 493  :                 sym->isdefined = TRUE;
; 494  :                 sym->predefined = TRUE;

	or	BYTE PTR [rax+40], 34			; 00000022H

; 495  :                 sym->string_ptr = value;

	mov	QWORD PTR [rax+16], rdi

; 496  :             } else

	jmp	SHORT $LN2@add_cmdlin
$LN10@add_cmdlin:

; 497  :                 EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	ecx, 56					; 00000038H
$LN43@add_cmdlin:
	mov	rdx, rsi
	call	EmitErr
$LN2@add_cmdlin:

; 458  :     struct qitem *p;
; 459  :     char *name;
; 460  :     char *value;
; 461  :     int len;
; 462  :     struct asym *sym;
; 463  : 
; 464  :     DebugMsg(("add_cmdline_tmacros enter\n"));
; 465  :     for ( p = Options.queues[OPTQ_MACRO]; p; p = p->next ) {

	mov	r15, QWORD PTR [r15]
	mov	rbx, 576460752706077697			; 0800000018000401H
	test	r15, r15
	jne	$LL4@add_cmdlin
$LN3@add_cmdlin:

; 498  :         }
; 499  :     }
; 500  :     return;
; 501  : }

	mov	rbx, QWORD PTR [rbp+48]
	mov	rsi, QWORD PTR [rbp+56]
	mov	rdi, QWORD PTR [rbp+64]
	mov	rsp, rbp
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
add_cmdline_tmacros ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT is_valid_identifier
_TEXT	SEGMENT
id$ = 48
is_valid_identifier PROC				; COMDAT

; 435  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 436  :     /* special handling of first char of an id: it can't be a digit,
; 437  :      but can be a dot (don't care about ModuleInfo.dotname!). */
; 438  : 
; 439  :     if( is_valid_first_char( *id ) == 0 )

	movsx	ecx, BYTE PTR [rcx]
	call	isalpha
	test	eax, eax
	jne	SHORT $LN5@is_valid_i
	movzx	eax, BYTE PTR [rbx]
	sub	al, 36					; 00000024H
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN18@is_valid_i
	movsx	rax, al
	mov	rcx, 576460752706077697			; 0800000018000401H
	bt	rcx, rax
	jb	SHORT $LN5@is_valid_i
$LN18@is_valid_i:

; 440  :         return( ERROR );

	or	eax, -1

; 448  :         return( ERROR );
; 449  : 
; 450  :     return( NOT_ERROR );
; 451  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@is_valid_i:

; 441  :     id++;
; 442  :     for( ; *id != NULLC; id++ ) {

	movzx	eax, BYTE PTR [rbx+1]
	inc	rbx
	mov	QWORD PTR [rsp+48], rdi
	test	al, al
	je	SHORT $LN3@is_valid_i
	mov	rdi, 576460752706076673			; 0800000018000001H
$LL4@is_valid_i:

; 443  :         if ( is_valid_id_char( *id ) == FALSE )

	movsx	ecx, al
	call	isalnum
	test	eax, eax
	jne	SHORT $LN11@is_valid_i
	movzx	eax, BYTE PTR [rbx]
	sub	al, 36					; 00000024H
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN14@is_valid_i
	movsx	rax, al
	bt	rdi, rax
	jae	SHORT $LN14@is_valid_i
$LN11@is_valid_i:

; 441  :     id++;
; 442  :     for( ; *id != NULLC; id++ ) {

	movzx	eax, BYTE PTR [rbx+1]
	inc	rbx
	test	al, al
	jne	SHORT $LL4@is_valid_i
$LN3@is_valid_i:
	mov	rdi, QWORD PTR [rsp+48]

; 445  :     }
; 446  :     /* don't allow a single dot! */
; 447  :     if ( *(id-1) == '.' )

	xor	eax, eax
	cmp	BYTE PTR [rbx-1], 46			; 0000002eH
	setne	al
	dec	eax

; 448  :         return( ERROR );
; 449  : 
; 450  :     return( NOT_ERROR );
; 451  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN14@is_valid_i:

; 444  :             return( ERROR );

	or	eax, -1
	mov	rdi, QWORD PTR [rsp+48]

; 448  :         return( ERROR );
; 449  : 
; 450  :     return( NOT_ERROR );
; 451  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
is_valid_identifier ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT WriteModule
_TEXT	SEGMENT
modinfo$ = 64
WriteModule PROC					; COMDAT

; 385  : {

	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 386  :     struct dsym *curr;
; 387  : 
; 388  :     DebugMsg(("WriteModule enter\n"));
; 389  : 
; 390  :     /* final checks */
; 391  :     /* check limit of segments */
; 392  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	mov	rdi, rcx
	test	rbx, rbx
	je	SHORT $LN3@WriteModul
	npad	7
$LL4@WriteModul:

; 393  :         if ( curr->e.seginfo->Ofssize == USE16 && curr->sym.max_offset > 0x10000 ) {

	mov	rax, QWORD PTR [rbx+96]
	cmp	BYTE PTR [rax+104], 0
	jne	SHORT $LN2@WriteModul
	cmp	DWORD PTR [rbx+56], 65536		; 00010000H
	jle	SHORT $LN2@WriteModul

; 394  :             if ( Options.output_format == OFORMAT_OMF )

	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN9@WriteModul

; 395  :                 EmitErr( SEGMENT_EXCEEDS_64K_LIMIT, curr->sym.name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 222				; 000000deH
	call	EmitErr
	jmp	SHORT $LN2@WriteModul
$LN9@WriteModul:

; 396  :             else
; 397  :                 EmitWarn( 2, SEGMENT_EXCEEDS_64K_LIMIT, curr->sym.name );

	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 222				; 000000deH
	mov	ecx, 2
	call	EmitWarn
$LN2@WriteModul:

; 386  :     struct dsym *curr;
; 387  : 
; 388  :     DebugMsg(("WriteModule enter\n"));
; 389  : 
; 390  :     /* final checks */
; 391  :     /* check limit of segments */
; 392  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	SHORT $LL4@WriteModul
$LN3@WriteModul:

; 398  :         }
; 399  :     }
; 400  : 
; 401  :     modinfo->g.WriteModule( modinfo );

	mov	rcx, rdi
	mov	QWORD PTR [rsp+64], rsi
	call	QWORD PTR [rdi+288]

; 402  : 
; 403  : #if DLLIMPORT
; 404  :     /* is the -Fd option given with a file name? */
; 405  :     if ( Options.names[OPTN_LNKDEF_FN] ) {

	mov	rcx, QWORD PTR Options+48
	test	rcx, rcx
	je	$LN11@WriteModul

; 406  :         FILE *ld;
; 407  :         ld = fopen( Options.names[OPTN_LNKDEF_FN], "w" );

	lea	rdx, OFFSET FLAT:$SG11837
	call	fopen
	mov	rsi, rax

; 408  :         if ( ld == NULL ) {

	test	rax, rax
	jne	SHORT $LN12@WriteModul

; 409  :             return( EmitErr( CANNOT_OPEN_FILE, Options.names[OPTN_LNKDEF_FN], ErrnoStr() ) );

	call	ErrnoStr
	mov	rdx, QWORD PTR Options+48
	lea	ecx, QWORD PTR [rsi+106]
	mov	r8, rax
	mov	rsi, QWORD PTR [rsp+64]

; 427  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi

; 409  :             return( EmitErr( CANNOT_OPEN_FILE, Options.names[OPTN_LNKDEF_FN], ErrnoStr() ) );

	jmp	EmitErr
$LN12@WriteModul:

; 410  :         }
; 411  :         for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+16
	test	rbx, rbx
	je	$LN6@WriteModul
$LL7@WriteModul:

; 412  :             DebugMsg(("WriteModule: ext=%s, isproc=%u, weak=%u\n", curr->sym.name, curr->sym.isproc, curr->sym.weak ));
; 413  :             if ( curr->sym.isproc && ( curr->sym.weak == FALSE || curr->sym.iat_used ) &&
; 414  :                 curr->sym.dll && *(curr->sym.dll->name) != NULLC ) {

	test	BYTE PTR [rbx+41], 8
	je	SHORT $LN5@WriteModul
	test	BYTE PTR [rbx+47], 8
	je	SHORT $LN14@WriteModul
	test	BYTE PTR [rbx+40], 8
	je	SHORT $LN5@WriteModul
$LN14@WriteModul:
	mov	rax, QWORD PTR [rbx+56]
	test	rax, rax
	je	SHORT $LN5@WriteModul
	cmp	BYTE PTR [rax+12], 0
	je	SHORT $LN5@WriteModul

; 415  :                 int size;
; 416  :                 Mangle( &curr->sym, StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, rbx
	call	Mangle

; 417  :                 size = sprintf( CurrSource, "import '%s'  %s.%s\n", StringBufferEnd, curr->sym.dll->name, curr->sym.name );

	mov	r9, QWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11841
	mov	rax, QWORD PTR [rbx+8]
	add	r9, 12
	mov	r8, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR ModuleInfo+464
	mov	QWORD PTR [rsp+32], rax
	call	sprintf

; 418  :                 if ( fwrite( CurrSource, 1, size, ld ) != size )

	mov	rcx, QWORD PTR ModuleInfo+464
	mov	r9, rsi
	movsxd	rdi, eax
	mov	edx, 1
	mov	r8, rdi
	call	fwrite
	cmp	rax, rdi
	je	SHORT $LN5@WriteModul

; 419  :                     WriteError();

	call	WriteError
$LN5@WriteModul:

; 410  :         }
; 411  :         for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	$LL7@WriteModul
$LN6@WriteModul:

; 420  :             }
; 421  :         }
; 422  :         fclose( ld );

	mov	rcx, rsi
	call	fclose
$LN11@WriteModul:

; 423  :     }
; 424  : #endif
; 425  :     DebugMsg(("WriteModule exit\n"));
; 426  :     return( NOT_ERROR );

	mov	rsi, QWORD PTR [rsp+64]
	xor	eax, eax

; 427  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
WriteModule ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
pBytes$ = 48
len$ = 56
OutputBinBytes PROC

; 238  : {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 239  : 
; 240  : 	if (write_to_file == TRUE) {

	cmp	BYTE PTR write_to_file, 1
	mov	rbx, rcx

; 241  : 		uint_32 idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	edi, edx
	jne	SHORT $LN5@OutputBinB
	mov	r8, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [r8+12]
	sub	eax, DWORD PTR [r8+8]

; 242  : #ifdef DEBUG_OUT
; 243  : 		if (CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc) {
; 244  : 			;//_asm int 3;
; 245  : 		}
; 246  : #endif
; 247  : 		/**/myassert(CurrSeg->e.seginfo->current_loc >= CurrSeg->e.seginfo->start_loc);
; 248  : 		if (Options.output_format == OFORMAT_OMF && idx >= MAX_LEDATA_THRESHOLD) {

	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN7@OutputBinB
	cmp	eax, 1014				; 000003f6H
	jb	SHORT $LN7@OutputBinB

; 249  : 			omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 250  : 			idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rcx+12]
	sub	eax, DWORD PTR [rcx+8]
$LN7@OutputBinB:

; 251  : 		}
; 252  : 		//DebugMsg(("OutputByte: buff=%p, idx=%" I32_SPEC "X, byte=%X, codebuff[0]=%X\n", CurrSeg->e.seginfo->CodeBuffer, idx, byte, *CurrSeg->e.seginfo->CodeBuffer ));
; 253  : 		int i;
; 254  : 		for (i = 0; i < len; i++)

	test	edi, edi
	je	SHORT $LN8@OutputBinB
	mov	r10, rdi
	npad	8
$LL4@OutputBinB:

; 255  : 			CurrSeg->e.seginfo->CodeBuffer[idx++] = *(pBytes++);

	mov	rcx, QWORD PTR ModuleInfo+432
	lea	rbx, QWORD PTR [rbx+1]
	mov	rdx, QWORD PTR [rcx+96]
	movzx	ecx, BYTE PTR [rbx-1]
	mov	r8, QWORD PTR [rdx+16]
	mov	BYTE PTR [rax+r8], cl
	lea	eax, DWORD PTR [rax+1]
	sub	r10, 1
	jne	SHORT $LL4@OutputBinB

; 256  : 
; 257  : 	}

	jmp	SHORT $LN8@OutputBinB
$LN5@OutputBinB:

; 258  : #if 1
; 259  : 	/* check this in pass 1 only */
; 260  : 	else if (CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc) {

	mov	rcx, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rcx+12]
	cmp	eax, DWORD PTR [rcx+8]
	jae	SHORT $LN8@OutputBinB

; 261  : 		DebugMsg(("OutputByte: segment start loc changed from %" I32_SPEC "Xh to %" I32_SPEC "Xh\n",
; 262  : 			CurrSeg->e.seginfo->start_loc,
; 263  : 			CurrSeg->e.seginfo->current_loc));
; 264  : 		CurrSeg->e.seginfo->start_loc = CurrSeg->e.seginfo->current_loc;

	mov	DWORD PTR [rcx+8], eax
$LN8@OutputBinB:

; 265  : 	}
; 266  : #endif
; 267  : 	CurrSeg->e.seginfo->current_loc+=len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	add	DWORD PTR [rcx+12], edi

; 268  : 	CurrSeg->e.seginfo->bytes_written+=len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	add	DWORD PTR [rcx+24], edi

; 269  : 	CurrSeg->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	or	BYTE PTR [rcx+107], 32			; 00000020H

; 270  : 	if (CurrSeg->e.seginfo->current_loc > CurrSeg->sym.max_offset)

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rcx+96]
	mov	edx, DWORD PTR [rax+12]
	cmp	edx, DWORD PTR [rcx+56]
	jbe	SHORT $LN9@OutputBinB

; 271  : 		CurrSeg->sym.max_offset = CurrSeg->e.seginfo->current_loc;

	mov	DWORD PTR [rcx+56], edx
$LN9@OutputBinB:

; 272  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
OutputBinBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
seg$ = 48
value$ = 56
relative$ = 64
select_data$ = 72
SetCurrOffset PROC

; 337  : {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	movzx	esi, r9b
	mov	edi, edx
	mov	rbx, rcx

; 338  :     if( relative )

	test	r8b, r8b
	je	SHORT $LN2@SetCurrOff

; 339  :         value += seg->e.seginfo->current_loc;

	mov	rax, QWORD PTR [rcx+96]
	add	edi, DWORD PTR [rax+12]
$LN2@SetCurrOff:

; 340  : 
; 341  :     if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN3@SetCurrOff

; 342  :         if ( seg == CurrSeg ) {

	cmp	rcx, QWORD PTR ModuleInfo+432
	jne	SHORT $LN5@SetCurrOff

; 343  :             if ( write_to_file == TRUE )

	cmp	BYTE PTR write_to_file, 1
	jne	SHORT $LN6@SetCurrOff

; 344  :                 omf_FlushCurrSeg();

	call	omf_FlushCurrSeg
$LN6@SetCurrOff:

; 345  : 
; 346  :         /* for debugging, tell if data is located in code sections*/
; 347  :             if( select_data )

	test	sil, sil
	je	SHORT $LN8@SetCurrOff

; 348  :                 if ( ModuleInfo.CommentDataInCode )

	cmp	BYTE PTR ModuleInfo+423, 0
	je	SHORT $LN8@SetCurrOff

; 349  :                     omf_OutSelect( TRUE );

	mov	cl, 1
	call	omf_OutSelect
$LN8@SetCurrOff:

; 350  :             LastCodeBufSize = value;

	mov	DWORD PTR LastCodeBufSize, edi
$LN5@SetCurrOff:

; 351  :         }
; 352  :         seg->e.seginfo->start_loc = value;

	mov	rax, QWORD PTR [rbx+96]

; 353  :     /* for -bin, if there's an ORG (relative==false) and no initialized data
; 354  :      * has been set yet, set start_loc!
; 355  :      * v1.96: this is now also done for COFF and ELF
; 356  :      */
; 357  :     /* else if ( Options.output_format == OFORMAT_BIN && relative == FALSE ) { */
; 358  :     } else {

	jmp	SHORT $LN16@SetCurrOff
$LN3@SetCurrOff:

; 359  :         if ( write_to_file == FALSE ) {

	cmp	BYTE PTR write_to_file, 0
	jne	SHORT $LN12@SetCurrOff

; 360  :             if ( relative ) {

	test	r8b, r8b
	jne	SHORT $LN12@SetCurrOff

; 361  : #if 0 /* don't include "preceding" uninitialized data */
; 362  :                 if( seg->e.seginfo->current_loc < seg->e.seginfo->start_loc )
; 363  :                     seg->e.seginfo->start_loc = seg->e.seginfo->current_loc;
; 364  : #endif
; 365  :             } else {
; 366  :                 if ( seg->e.seginfo->bytes_written == 0 )

	mov	rax, QWORD PTR [rcx+96]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN12@SetCurrOff
$LN16@SetCurrOff:

; 367  :                     seg->e.seginfo->start_loc = value;

	mov	DWORD PTR [rax+8], edi
$LN12@SetCurrOff:

; 368  :             }
; 369  :         }
; 370  :     }
; 371  : 
; 372  :     seg->e.seginfo->current_loc = value;

	mov	rax, QWORD PTR [rbx+96]
	mov	DWORD PTR [rax+12], edi

; 373  :     seg->e.seginfo->written = FALSE;

	mov	rax, QWORD PTR [rbx+96]
	and	BYTE PTR [rax+107], 223			; 000000dfH

; 374  : 
; 375  :     if( seg->e.seginfo->current_loc > seg->sym.max_offset )

	mov	rax, QWORD PTR [rbx+96]
	mov	ecx, DWORD PTR [rax+12]

; 377  : 
; 378  :     return( NOT_ERROR );

	xor	eax, eax
	cmp	ecx, DWORD PTR [rbx+56]
	jbe	SHORT $LN13@SetCurrOff

; 376  :         seg->sym.max_offset = seg->e.seginfo->current_loc;

	mov	DWORD PTR [rbx+56], ecx
$LN13@SetCurrOff:

; 379  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetCurrOffset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
string$ = 48
WritePreprocessedLine PROC

; 584  : {

$LN16:
	push	rdi
	sub	rsp, 32					; 00000020H

; 585  :     static bool PrintEmptyLine = TRUE;
; 586  :     const char *p;
; 587  : 
; 588  : #if 0 /* v2.08: removed, obsolete */
; 589  :     /* filter some macro specific directives */
; 590  :     if ( tokenarray[0].token == T_DIRECTIVE &&
; 591  :          ( tokenarray[0].tokval == T_ENDM ||
; 592  :            tokenarray[0].tokval == T_EXITM))
; 593  :         return;
; 594  :     /* don't print generated code - with one exception:
; 595  :      if the code was generated as a result of structure initialization,
; 596  :      then do!
; 597  :      */
; 598  :     if ( GeneratedCode )
; 599  :         return;
; 600  : #endif
; 601  :     if ( Token_Count > 0 ) {

	cmp	DWORD PTR ModuleInfo+496, 0
	mov	rdi, rcx
	jle	SHORT $LN5@WritePrepr

; 602  :         /* v2.08: don't print a leading % (this char is no longer filtered) */
; 603  :         for ( p = string; isspace( *p ); p++ );

	mov	QWORD PTR [rsp+48], rbx
	mov	rbx, rcx
	movsx	ecx, BYTE PTR [rcx]
	call	isspace
	test	eax, eax
	je	SHORT $LN3@WritePrepr
	npad	10
$LL4@WritePrepr:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL4@WritePrepr
$LN3@WritePrepr:

; 604  :         printf("%s\n", *p == '%' ? p+1 : string );

	cmp	BYTE PTR [rbx], 37			; 00000025H
	jne	SHORT $LN9@WritePrepr
	lea	rdi, QWORD PTR [rbx+1]
$LN9@WritePrepr:
	mov	rdx, rdi
	lea	rcx, OFFSET FLAT:$SG11901
	call	printf
	mov	rbx, QWORD PTR [rsp+48]

; 605  :         PrintEmptyLine = TRUE;

	mov	BYTE PTR ?PrintEmptyLine@?1??WritePreprocessedLine@@9@9, 1

; 609  :     }
; 610  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN5@WritePrepr:

; 606  :     } else if ( PrintEmptyLine ) {

	cmp	BYTE PTR ?PrintEmptyLine@?1??WritePreprocessedLine@@9@9, 0
	je	SHORT $LN7@WritePrepr

; 607  :         PrintEmptyLine = FALSE;
; 608  :         printf("\n");

	lea	rcx, OFFSET FLAT:$SG11903
	mov	BYTE PTR ?PrintEmptyLine@?1??WritePreprocessedLine@@9@9, 0

; 609  :     }
; 610  : }

	add	rsp, 32					; 00000020H
	pop	rdi

; 607  :         PrintEmptyLine = FALSE;
; 608  :         printf("\n");

	jmp	printf
$LN7@WritePrepr:

; 609  :     }
; 610  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
WritePreprocessedLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
sym$ = 64
pst$ = 72
buffer$ = 80
ConvertSectionName PROC

; 166  : {

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 170  :         if ( memcmp( sym->name, cst[i].src, cst[i].len ) == 0 ) {

	mov	rbp, QWORD PTR [rcx+8]
	lea	rbx, OFFSET FLAT:cst+8
	mov	r15, r8
	mov	r12, rdx
	mov	r14, rcx
	xor	edi, edi
	npad	12
$LL4@ConvertSec:
	movzx	esi, BYTE PTR [rbx-8]
	mov	rcx, rbp
	mov	rdx, QWORD PTR [rbx]
	mov	r8d, esi
	call	memcmp
	test	eax, eax
	jne	SHORT $LN2@ConvertSec

; 171  :             if ( sym->name[cst[i].len] == NULLC || ( sym->name[cst[i].len] == '$' && ( cst[i].flags & CSF_GRPCHK ) ) ) {

	movzx	eax, BYTE PTR [rsi+rbp]
	test	al, al
	je	SHORT $LN7@ConvertSec
	cmp	al, 36					; 00000024H
	jne	SHORT $LN2@ConvertSec
	test	BYTE PTR [rbx-7], 1
	jne	SHORT $LN7@ConvertSec
$LN2@ConvertSec:

; 167  :     int i;
; 168  : 
; 169  :     for ( i = 0; i < sizeof( cst ) / sizeof( cst[0] ); i++ ) {

	inc	edi
	add	rbx, 24
	movsxd	rax, edi
	cmp	rax, 4
	jb	SHORT $LL4@ConvertSec

; 192  :             }
; 193  :         }
; 194  :     }
; 195  :     return( sym->name );

	mov	rax, rbp
$LN1@ConvertSec:

; 196  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
$LN7@ConvertSec:

; 172  : 
; 173  :                 if ( pst ) {

	lea	r9, OFFSET FLAT:__ImageBase
	test	r12, r12
	je	SHORT $LN10@ConvertSec

; 174  :                     if ( i == CSI_BSS && ( (struct dsym *)sym)->e.seginfo->bytes_written != 0 )

	cmp	edi, 3
	jne	SHORT $LN9@ConvertSec
	mov	rax, QWORD PTR [r14+96]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN10@ConvertSec
$LN9@ConvertSec:

; 175  :                         ; /* don't set segment type to BSS if the segment contains initialized data */
; 176  :                     else
; 177  :                         *pst = stt[i];

	movsxd	rax, edi
	mov	eax, DWORD PTR stt[r9+rax*4]
	mov	DWORD PTR [r12], eax
$LN10@ConvertSec:

; 178  :                 }
; 179  : 
; 180  :                 if ( sym->name[cst[i].len] == NULLC ) {

	movsxd	rax, edi
	lea	r8, QWORD PTR cst[r9]
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, QWORD PTR [rcx*8]
	mov	rcx, QWORD PTR [r14+8]
	add	r8, rax
	movzx	edx, BYTE PTR [r8]
	cmp	BYTE PTR [rdx+rcx], 0
	jne	SHORT $LN11@ConvertSec

; 181  : #if DJGPP_SUPPORT
; 182  :                     /* DJGPP won't be happy with .rdata segment name */
; 183  :                     if( ModuleInfo.sub_format == SFORMAT_DJGPP && i == CSI_CONST )
; 184  :                         return( ".const" );
; 185  : #endif
; 186  :                     return( (char *)cst[i].dst );

	mov	rax, QWORD PTR cst[rax+r9+16]
	jmp	SHORT $LN1@ConvertSec
$LN11@ConvertSec:

; 187  :                 }
; 188  : 
; 189  :                 strcpy( buffer, cst[i].dst );

	mov	rcx, QWORD PTR cst[rax+r9+16]
	mov	rdx, r15
	npad	1
$LL13@ConvertSec:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL13@ConvertSec

; 190  :                 strcat( buffer, sym->name+cst[i].len );

	movzx	r8d, BYTE PTR [r8]
	lea	rcx, QWORD PTR [r15-1]
	add	r8, QWORD PTR [r14+8]
	npad	3
$LL22@ConvertSec:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL22@ConvertSec
	xor	edx, edx
	npad	4
$LL23@ConvertSec:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL23@ConvertSec

; 191  :                 return( buffer );

	mov	rax, r15
	jmp	$LN1@ConvertSec
ConvertSectionName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
close_files PROC

; 1221 : {

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1222 :     /* v2.11: no fatal errors anymore if fclose() fails.
; 1223 :      * That's because Fatal() may cause close_files() to be
; 1224 :      * reentered and thus cause an endless loop.
; 1225 :      */
; 1226 : 
; 1227 :     /* close ASM file */
; 1228 :     if( CurrFile[ASM] != NULL ) {

	mov	rcx, QWORD PTR ModuleInfo+96
	xor	ebx, ebx
	test	rcx, rcx
	je	SHORT $LN2@close_file

; 1229 :         if( fclose( CurrFile[ASM] ) != 0 )

	call	fclose
	test	eax, eax
	je	SHORT $LN3@close_file

; 1230 :             EmitErr( CANNOT_CLOSE_FILE, CurrFName[ASM], errno );

	call	_errno
	mov	rdx, QWORD PTR ModuleInfo+128
	lea	ecx, QWORD PTR [rbx+107]
	mov	r8d, DWORD PTR [rax]
	call	EmitErr
$LN3@close_file:

; 1231 :         CurrFile[ASM] = NULL;

	mov	QWORD PTR ModuleInfo+96, rbx
$LN2@close_file:

; 1232 :     }
; 1233 : 
; 1234 :     /* close OBJ file */
; 1235 :     if ( CurrFile[OBJ] != NULL ) {

	mov	rcx, QWORD PTR ModuleInfo+104
	test	rcx, rcx
	je	SHORT $LN4@close_file

; 1236 :         if ( fclose( CurrFile[OBJ] ) != 0 )

	call	fclose
	test	eax, eax
	je	SHORT $LN5@close_file

; 1237 :             EmitErr( CANNOT_CLOSE_FILE, CurrFName[OBJ], errno );

	call	_errno
	mov	rdx, QWORD PTR ModuleInfo+136
	mov	ecx, 107				; 0000006bH
	mov	r8d, DWORD PTR [rax]
	call	EmitErr
$LN5@close_file:

; 1238 :         CurrFile[OBJ] = NULL;

	mov	QWORD PTR ModuleInfo+104, rbx
$LN4@close_file:

; 1239 :     }
; 1240 :     /* delete the object module if errors occured */
; 1241 :     if ( Options.syntax_check_only == FALSE &&

	cmp	BYTE PTR Options+172, bl
	jne	SHORT $LN6@close_file
	cmp	DWORD PTR ModuleInfo, ebx
	jbe	SHORT $LN6@close_file

; 1242 :         ModuleInfo.g.error_count > 0 ) {
; 1243 :         remove( CurrFName[OBJ] );

	mov	rcx, QWORD PTR ModuleInfo+136
	call	remove
$LN6@close_file:

; 1244 :     }
; 1245 : 
; 1246 :     if( CurrFile[LST] != NULL ) {

	mov	rcx, QWORD PTR ModuleInfo+112
	test	rcx, rcx
	je	SHORT $LN7@close_file

; 1247 :         fclose( CurrFile[LST] );

	call	fclose

; 1248 :         CurrFile[LST] = NULL;

	mov	QWORD PTR ModuleInfo+112, rbx
$LN7@close_file:

; 1249 :     }
; 1250 : 
; 1251 :     /* close ERR file */
; 1252 :     if ( CurrFile[ERR] != NULL ) {

	mov	rcx, QWORD PTR ModuleInfo+120
	test	rcx, rcx
	je	SHORT $LN8@close_file

; 1253 :         fclose( CurrFile[ERR] );

	call	fclose

; 1254 :         CurrFile[ERR] = NULL;

	mov	QWORD PTR ModuleInfo+120, rbx

; 1258 :     return;
; 1259 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN8@close_file:

; 1255 :     } else if ( CurrFName[ERR] )

	mov	rcx, QWORD PTR ModuleInfo+152
	test	rcx, rcx
	je	SHORT $LN10@close_file

; 1258 :     return;
; 1259 : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 1256 :         /* nothing written, delete any existing ERR file */
; 1257 :         remove( CurrFName[ERR] );

	jmp	remove
$LN10@close_file:

; 1258 :     return;
; 1259 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
close_files ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
value$ = 8
SetMasm510 PROC

; 617  :     ModuleInfo.m510 = value;
; 618  :     ModuleInfo.oldstructs = value;
; 619  :     /* ModuleInfo.oldmacros = value; not implemented yet */
; 620  :     ModuleInfo.dotname = value;
; 621  :     ModuleInfo.setif2 = value;

	movzx	eax, cl
	and	eax, 1
	lea	edx, DWORD PTR [rax*4]
	or	edx, eax
	shl	edx, 2
	or	edx, eax
	shl	edx, 2
	or	edx, eax
	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -1361				; fffffaafH
	shl	edx, 4
	or	edx, eax
	mov	DWORD PTR ModuleInfo+408, edx

; 622  : 
; 623  :     if ( value ) {

	test	cl, cl
	je	SHORT $LN4@SetMasm510

; 624  :         if ( ModuleInfo.model == MODEL_NONE ) {

	cmp	DWORD PTR ModuleInfo+360, 0
	jne	SHORT $LN4@SetMasm510

; 625  :             /* if no model is specified, set OFFSET:SEGMENT */
; 626  :             ModuleInfo.offsettype = OT_SEGMENT;
; 627  :             if ( ModuleInfo.langtype == LANG_NONE ) {

	cmp	DWORD PTR ModuleInfo+364, 0
	mov	DWORD PTR ModuleInfo+384, 2
	jne	SHORT $LN4@SetMasm510

; 628  :                 ModuleInfo.scoped = FALSE;

	btr	edx, 7

; 629  :                 ModuleInfo.procs_private = TRUE;

	or	edx, 4
	mov	DWORD PTR ModuleInfo+408, edx
$LN4@SetMasm510:

; 630  :             }
; 631  :         }
; 632  :     }
; 633  :     return;
; 634  : }

	ret	0
SetMasm510 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
prev_written$ = 64
source$ = 112
AssembleModule PROC

; 1426 : {

$LN59:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H

; 1427 :     uint_32       prev_written = -1;
; 1428 :     uint_32       curr_written;
; 1429 :     int           starttime;
; 1430 :     int           endtime;
; 1431 :     struct dsym   *seg;
; 1432 : 
; 1433 :     DebugMsg(("AssembleModule(\"%s\") enter\n", source ));
; 1434 : 
; 1435 :     memset( &ModuleInfo, 0, sizeof(ModuleInfo) );

	xor	edx, edx
	mov	DWORD PTR prev_written$[rsp], -1	; ffffffffH
	mov	r8d, 776				; 00000308H
	lea	rcx, OFFSET FLAT:ModuleInfo
	call	memset

; 1436 :     DebugCmd( ModuleInfo.cref = TRUE ); /* enable debug displays */
; 1437 : 
; 1438 : #if 1 //def __SW_BD
; 1439 :     /* fatal errors during assembly won't terminate the program,
; 1440 :      * just the assembly step.!
; 1441 :      */
; 1442 :     if ( setjmp( jmpenv ) ) {

	lea	rcx, OFFSET FLAT:jmpenv
	mov	rdx, rsp
	call	_setjmp
	xor	ebp, ebp
	test	eax, eax
	je	SHORT $LN11@AssembleMo

; 1443 :         if ( ModuleInfo.g.src_stack )

	cmp	QWORD PTR ModuleInfo+200, rbp
	je	$done$60

; 1444 :             ClearSrcStack(); /* avoid memory leaks! */

	call	ClearSrcStack

; 1445 :         goto done;

	jmp	$done$60
$LN11@AssembleMo:

; 1446 :     }
; 1447 : #endif
; 1448 : 
; 1449 :     AssembleInit( source );

	mov	rcx, QWORD PTR source$[rsp]
	call	AssembleInit

; 1450 : 
; 1451 :     starttime = clock();

	call	clock
	mov	r15d, eax

; 1452 : 
; 1453 : #if 0 /* 1=trigger a protection fault */
; 1454 :     seg = NULL;
; 1455 :     seg->sym.state = SYM_UNDEFINED;
; 1456 : #endif
; 1457 : 
; 1458 :     for( Parse_Pass = PASS_1; ; Parse_Pass++ ) {

	mov	DWORD PTR Parse_Pass, ebp

; 1459 : 
; 1460 :         DebugMsg(( "*************\npass %u\n*************\n", Parse_Pass + 1 ));
; 1461 :         OnePass();

	call	OnePass

; 1462 : 
; 1463 :         if( ModuleInfo.g.error_count > 0 ) {

	cmp	DWORD PTR ModuleInfo, ebp
	ja	$LN37@AssembleMo
	mov	edi, DWORD PTR prev_written$[rsp]
	npad	14
$LL4@AssembleMo:

; 1464 :             DebugMsg(("AssembleModule(%u): errorcnt=%u\n", Parse_Pass + 1, ModuleInfo.g.error_count ));
; 1465 :             break;
; 1466 :         }
; 1467 : 
; 1468 :         /* calculate total size of segments */
; 1469 :         for ( curr_written = 0, seg = SymTables[TAB_SEG].head; seg ; seg = seg->next ) {

	mov	rbx, QWORD PTR SymTables+32
	mov	ecx, ebp
	mov	rax, rbx
	test	rbx, rbx
	je	SHORT $LN6@AssembleMo
$LL7@AssembleMo:

; 1470 :             /* v2.04: use <max_offset> instead of <bytes_written>
; 1471 :              * (the latter is not always reliable due to backpatching).
; 1472 :              */
; 1473 :             //curr_written += seg->e.seginfo->bytes_written;
; 1474 :             curr_written += seg->sym.max_offset;

	add	ecx, DWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax+104]
	test	rax, rax
	jne	SHORT $LL7@AssembleMo
$LN6@AssembleMo:

; 1475 :             DebugMsg(("AssembleModule(%u): segm=%-8s start=%8" I32_SPEC "X max_ofs=%8" I32_SPEC "X written=%" I32_SPEC "X\n",
; 1476 :                       Parse_Pass + 1, seg->sym.name, seg->e.seginfo->start_loc, seg->sym.max_offset,
; 1477 :                       seg->e.seginfo->bytes_written ));
; 1478 :         }
; 1479 : 
; 1480 :         /* if there's no phase error and size of segments didn't change, we're done */
; 1481 :         DebugMsg(("AssembleModule(%u): PhaseError=%u, prev_written=%" I32_SPEC "X, curr_written=%" I32_SPEC "X\n", Parse_Pass + 1, ModuleInfo.PhaseError, prev_written, curr_written));
; 1482 :         if( !ModuleInfo.PhaseError && prev_written == curr_written )

	cmp	BYTE PTR ModuleInfo+422, bpl
	jne	SHORT $LN14@AssembleMo
	cmp	edi, ecx
	je	$LN37@AssembleMo
$LN14@AssembleMo:

; 1483 :             break;
; 1484 : 
; 1485 : #ifdef DEBUG_OUT
; 1486 :         if ( curr_written < prev_written && prev_written != -1 ) {
; 1487 :             printf( "size shrank from %" I32_SPEC "X to %" I32_SPEC "X in pass %u\n", prev_written, curr_written, Parse_Pass + 1 );
; 1488 :         }
; 1489 : #endif
; 1490 : 
; 1491 :         DebugMsg(("AssembleModule(%u): prepare for next pass\n", Parse_Pass + 1));
; 1492 :         prev_written = curr_written;
; 1493 : 
; 1494 :         if ( Parse_Pass % 200 == 199 )

	mov	r8d, DWORD PTR Parse_Pass
	mov	edi, ecx
	mov	DWORD PTR prev_written$[rsp], ecx
	mov	eax, 1374389535				; 51eb851fH
	mul	r8d
	mov	ecx, r8d
	shr	edx, 6
	imul	eax, edx, 200				; 000000c8H
	sub	ecx, eax
	cmp	ecx, 199				; 000000c7H
	jne	SHORT $LN15@AssembleMo

; 1495 :             EmitWarn( 2, ASSEMBLY_PASSES, Parse_Pass+1 );

	lea	edx, QWORD PTR [rcx+41]
	inc	r8d
	mov	ecx, 2
	call	EmitWarn
	mov	rbx, QWORD PTR SymTables+32
$LN15@AssembleMo:

; 1496 : #ifdef DEBUG_OUT
; 1497 :         if ( Options.max_passes && Parse_Pass == (Options.max_passes - 1) )
; 1498 :             break;
; 1499 : #endif
; 1500 :         if ( Options.line_numbers ) {

	cmp	BYTE PTR Options+1, bpl
	je	SHORT $LN18@AssembleMo

; 1501 : #if COFF_SUPPORT
; 1502 :             if ( Options.output_format == OFORMAT_COFF ) {

	cmp	DWORD PTR Options+144, 2
	jne	SHORT $LN17@AssembleMo

; 1503 :                 for( seg = SymTables[TAB_SEG].head; seg; seg = seg->next ) {

	test	rbx, rbx
	je	SHORT $LN18@AssembleMo
	npad	9
$LL10@AssembleMo:

; 1504 :                     if ( seg->e.seginfo->LinnumQueue )

	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+56]
	test	rcx, rcx
	je	SHORT $LN19@AssembleMo

; 1505 :                         QueueDeleteLinnum( seg->e.seginfo->LinnumQueue );

	call	QueueDeleteLinnum
$LN19@AssembleMo:

; 1506 :                     seg->e.seginfo->LinnumQueue = NULL;

	mov	rax, QWORD PTR [rbx+96]
	mov	QWORD PTR [rax+56], rbp
	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	SHORT $LL10@AssembleMo

; 1507 :                 }
; 1508 :             } else {

	jmp	SHORT $LN18@AssembleMo
$LN17@AssembleMo:

; 1509 : #endif
; 1510 :                 QueueDeleteLinnum( &LinnumQueue );

	lea	rcx, OFFSET FLAT:LinnumQueue
	call	QueueDeleteLinnum

; 1511 :                 LinnumQueue.head = NULL;

	mov	QWORD PTR LinnumQueue, rbp
$LN18@AssembleMo:

; 1512 : #if COFF_SUPPORT
; 1513 :             }
; 1514 : #endif
; 1515 :         }
; 1516 : 
; 1517 :         /* set file position of ASM and LST files for next pass */
; 1518 : 
; 1519 :         rewind( CurrFile[ASM] );

	mov	rcx, QWORD PTR ModuleInfo+96
	call	rewind

; 1520 :         if ( write_to_file && Options.output_format == OFORMAT_OMF )

	cmp	BYTE PTR write_to_file, bpl
	je	SHORT $LN20@AssembleMo
	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN20@AssembleMo

; 1521 :             omf_set_filepos();

	call	omf_set_filepos
$LN20@AssembleMo:

; 1522 : 
; 1523 : #if FASTPASS
; 1524 :         if ( UseSavedState == FALSE && CurrFile[LST] ) {

	cmp	BYTE PTR UseSavedState, bpl
	jne	SHORT $LN2@AssembleMo
	mov	rcx, QWORD PTR ModuleInfo+112
	test	rcx, rcx
	je	SHORT $LN2@AssembleMo

; 1525 : #else
; 1526 :         if ( CurrFile[LST] ) {
; 1527 : #endif
; 1528 :             rewind( CurrFile[LST] );

	call	rewind

; 1529 :             LstInit();

	call	LstInit
$LN2@AssembleMo:

; 1459 : 
; 1460 :         DebugMsg(( "*************\npass %u\n*************\n", Parse_Pass + 1 ));
; 1461 :         OnePass();

	inc	DWORD PTR Parse_Pass
	call	OnePass

; 1462 : 
; 1463 :         if( ModuleInfo.g.error_count > 0 ) {

	cmp	DWORD PTR ModuleInfo, ebp
	jbe	$LL4@AssembleMo
$LN37@AssembleMo:

; 1530 :         }
; 1531 :     } /* end for() */
; 1532 : 
; 1533 :     if ( ( Parse_Pass > PASS_1 ) && write_to_file )

	cmp	DWORD PTR Parse_Pass, ebp
	jbe	SHORT $LN22@AssembleMo
	cmp	BYTE PTR write_to_file, bpl
	je	SHORT $LN22@AssembleMo

; 1534 :         WriteModule( &ModuleInfo );

	lea	rcx, OFFSET FLAT:ModuleInfo
	call	WriteModule
$LN22@AssembleMo:

; 1535 : 
; 1536 :     if ( ModuleInfo.pCodeBuff ) {
; 1537 :         LclFree( ModuleInfo.pCodeBuff );
; 1538 :     }
; 1539 :     DebugMsg(("AssembleModule: finished, cleanup\n"));
; 1540 : 
; 1541 :     /* Write a symbol listing file (if requested) */
; 1542 :     LstWriteCRef();

	call	LstWriteCRef

; 1543 : 
; 1544 :     endtime = clock(); /* is in ms already */

	call	clock

; 1545 : 
; 1546 :     sprintf( CurrSource, MsgGetEx( MSG_ASSEMBLY_RESULTS ),

	mov	ecx, DWORD PTR ModuleInfo+428
	mov	esi, eax
	call	GetFName
	mov	edi, DWORD PTR Parse_Pass
	mov	r14, rax
	inc	edi
	sub	esi, r15d
	call	GetLineNumber
	mov	ecx, 1
	mov	ebx, eax
	call	MsgGetEx
	mov	ecx, DWORD PTR ModuleInfo
	mov	rdx, rax
	mov	r8, QWORD PTR [r14]
	mov	r9d, ebx
	mov	DWORD PTR [rsp+56], ecx
	mov	ecx, DWORD PTR ModuleInfo+4
	mov	DWORD PTR [rsp+48], ecx
	mov	rcx, QWORD PTR ModuleInfo+464
	mov	DWORD PTR [rsp+40], esi
	mov	DWORD PTR [rsp+32], edi
	call	sprintf

; 1547 :              GetFName( ModuleInfo.srcfile )->fname,
; 1548 :              GetLineNumber(),
; 1549 :              Parse_Pass + 1,
; 1550 :              endtime - starttime,
; 1551 :              ModuleInfo.g.warning_count,
; 1552 :              ModuleInfo.g.error_count);
; 1553 :     if ( Options.quiet == FALSE )

	cmp	BYTE PTR Options, bpl
	jne	SHORT $LN24@AssembleMo

; 1554 :         printf( "%s\n", CurrSource );

	mov	rdx, QWORD PTR ModuleInfo+464
	lea	rcx, OFFSET FLAT:$SG12138
	call	printf
$LN24@AssembleMo:

; 1555 : 
; 1556 :     if ( CurrFile[LST] ) {

	cmp	QWORD PTR ModuleInfo+112, rbp
	je	SHORT $done$60

; 1557 :         LstPrintf( CurrSource );

	mov	rcx, QWORD PTR ModuleInfo+464
	call	LstPrintf

; 1558 :         LstNL();

	call	LstNL
$done$60:

; 1559 :     }
; 1560 : #if 1 //def __SW_BD
; 1561 : done:
; 1562 : #endif
; 1563 :     AssembleFini();

	call	SegmentFini
	call	SymFini
	call	ResWordsFini
	call	FreePubQueue
	call	InputFini
	call	close_files
	xorps	xmm0, xmm0
	xorps	xmm1, xmm1
	movdqu	XMMWORD PTR ModuleInfo+128, xmm0
	movdqu	XMMWORD PTR ModuleInfo+144, xmm1
	call	MemFini

; 1564 :     DebugMsg(("AssembleModule exit\n"));
; 1565 :     return( ModuleInfo.g.error_count == 0 );

	cmp	DWORD PTR ModuleInfo, ebp

; 1566 : }

	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+56]
	sete	bpl
	mov	eax, ebp
	mov	rbp, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
AssembleModule ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
pbytes$ = 48
len$ = 56
fixup$ = 64
OutputBytes PROC

; 300  : {

$LN10:
	sub	rsp, 40					; 00000028H

; 301  :     if( write_to_file == TRUE ) {

	cmp	BYTE PTR write_to_file, 1
	mov	QWORD PTR [rsp+56], rbp
	mov	rbp, rcx
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, r8
	mov	QWORD PTR [rsp+32], rdi
	movsxd	rdi, edx
	jne	SHORT $LN2@OutputByte

; 302  :         uint_32 idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rdx, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rsp+48], rbx
	mov	rax, QWORD PTR [rdx+96]
	mov	ebx, DWORD PTR [rax+12]
	sub	ebx, DWORD PTR [rax+8]

; 303  : #if 0 /* def DEBUG_OUT */
; 304  :         if ( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc )
; 305  :             _asm int 3;
; 306  : #endif
; 307  :         /**/myassert( CurrSeg->e.seginfo->current_loc >= CurrSeg->e.seginfo->start_loc );
; 308  :         if( Options.output_format == OFORMAT_OMF && ((idx + len) > MAX_LEDATA_THRESHOLD ) ) {

	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN4@OutputByte
	lea	eax, DWORD PTR [rbx+rdi]
	cmp	eax, 1014				; 000003f6H
	jbe	SHORT $LN4@OutputByte

; 309  :             omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 310  :             idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rdx, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rdx+96]
	mov	ebx, DWORD PTR [rax+12]
	sub	ebx, DWORD PTR [rax+8]
$LN4@OutputByte:

; 311  :         }
; 312  :         if ( fixup )

	test	rsi, rsi
	je	SHORT $LN5@OutputByte

; 313  :             store_fixup( fixup, CurrSeg, (int_32 *)pbytes );

	mov	r8, rbp
	mov	rcx, rsi
	call	store_fixup
	mov	rdx, QWORD PTR ModuleInfo+432
$LN5@OutputByte:

; 314  :         //DebugMsg(("OutputBytes: buff=%p, idx=%" I32_SPEC "X, byte=%X\n", CurrSeg->e.seginfo->CodeBuffer, idx, *pbytes ));
; 315  :         memcpy( &CurrSeg->e.seginfo->CodeBuffer[idx], pbytes, len );

	mov	rax, QWORD PTR [rdx+96]
	mov	r8, rdi
	mov	ecx, ebx
	mov	rdx, rbp
	add	rcx, QWORD PTR [rax+16]
	call	memcpy
	mov	rbx, QWORD PTR [rsp+48]

; 316  :     }

	jmp	SHORT $LN6@OutputByte
$LN2@OutputByte:

; 317  : #if 1
; 318  :     /* check this in pass 1 only */
; 319  :     else if( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rcx+12]
	cmp	eax, DWORD PTR [rcx+8]
	jae	SHORT $LN6@OutputByte

; 320  :         DebugMsg(("OutputBytes: segment start loc changed from %" I32_SPEC "Xh to %" I32_SPEC "Xh\n",
; 321  :                   CurrSeg->e.seginfo->start_loc,
; 322  :                   CurrSeg->e.seginfo->current_loc));
; 323  :         CurrSeg->e.seginfo->start_loc = CurrSeg->e.seginfo->current_loc;

	mov	DWORD PTR [rcx+8], eax
$LN6@OutputByte:

; 324  :     }
; 325  : #endif
; 326  :     CurrSeg->e.seginfo->current_loc += len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rcx, QWORD PTR [rax+96]
	add	DWORD PTR [rcx+12], edi

; 327  :     CurrSeg->e.seginfo->bytes_written += len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	add	DWORD PTR [rcx+24], edi

; 328  :     CurrSeg->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rdi, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR [rax+96]
	or	BYTE PTR [rcx+107], 32			; 00000020H

; 329  :     if( CurrSeg->e.seginfo->current_loc > CurrSeg->sym.max_offset )

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rcx+96]
	mov	edx, DWORD PTR [rax+12]
	cmp	edx, DWORD PTR [rcx+56]
	jbe	SHORT $LN7@OutputByte

; 330  :         CurrSeg->sym.max_offset = CurrSeg->e.seginfo->current_loc;

	mov	DWORD PTR [rcx+56], edx
$LN7@OutputByte:

; 331  : }

	add	rsp, 40					; 00000028H
	ret	0
OutputBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
byte$ = 48
len$ = 56
FillDataBytes PROC

; 286  : {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 287  :     if ( ModuleInfo.CommentDataInCode )

	cmp	BYTE PTR ModuleInfo+423, 0
	mov	ebx, edx
	movzx	edi, cl
	je	SHORT $LN5@FillDataBy

; 288  :         omf_OutSelect( TRUE );

	mov	cl, 1
	call	omf_OutSelect
$LN5@FillDataBy:

; 289  :     for( ; len; len-- )

	test	ebx, ebx
	je	$LN3@FillDataBy
	mov	rax, QWORD PTR ModuleInfo+432
	npad	2
$LL4@FillDataBy:

; 290  :         OutputByte( byte );

	cmp	BYTE PTR write_to_file, 1
	jne	SHORT $LN8@FillDataBy
	lea	rdx, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR [rax+12]
	sub	ecx, DWORD PTR [rax+8]
	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN10@FillDataBy
	cmp	ecx, 1014				; 000003f6H
	jb	SHORT $LN10@FillDataBy
	call	omf_FlushCurrSeg
	mov	rdx, QWORD PTR ModuleInfo+432
	add	rdx, 96					; 00000060H
	mov	rax, QWORD PTR [rdx]
	mov	ecx, DWORD PTR [rax+12]
	sub	ecx, DWORD PTR [rax+8]
$LN10@FillDataBy:
	mov	rax, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rax+16]
	mov	BYTE PTR [rcx+rax], dil
	jmp	SHORT $LN18@FillDataBy
$LN8@FillDataBy:
	mov	rcx, QWORD PTR [rax+96]
	mov	edx, DWORD PTR [rcx+12]
	cmp	edx, DWORD PTR [rcx+8]
	jae	SHORT $LN11@FillDataBy
	mov	DWORD PTR [rcx+8], edx
$LN18@FillDataBy:
	mov	rax, QWORD PTR ModuleInfo+432
$LN11@FillDataBy:
	mov	rcx, QWORD PTR [rax+96]
	inc	DWORD PTR [rcx+12]
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	inc	DWORD PTR [rcx+24]
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	or	BYTE PTR [rcx+107], 32			; 00000020H
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	mov	edx, DWORD PTR [rcx+12]
	cmp	edx, DWORD PTR [rax+56]
	jbe	SHORT $LN2@FillDataBy
	mov	DWORD PTR [rax+56], edx
	mov	rax, QWORD PTR ModuleInfo+432
$LN2@FillDataBy:

; 289  :     for( ; len; len-- )

	sub	ebx, 1
	jne	$LL4@FillDataBy
$LN3@FillDataBy:

; 291  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
FillDataBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
byte$ = 48
OutputByte PROC

; 204  : {

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 205  :     if( write_to_file == TRUE ) {

	cmp	BYTE PTR write_to_file, 1
	movzx	ebx, cl
	jne	SHORT $LN2@OutputByte

; 206  :         uint_32 idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	r8, QWORD PTR ModuleInfo+432
	add	r8, 96					; 00000060H
	mov	rax, QWORD PTR [r8]
	mov	edx, DWORD PTR [rax+12]
	sub	edx, DWORD PTR [rax+8]

; 207  : #ifdef DEBUG_OUT
; 208  :         if ( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc ) {
; 209  :             ;//_asm int 3;
; 210  :         }
; 211  : #endif
; 212  :         /**/myassert( CurrSeg->e.seginfo->current_loc >= CurrSeg->e.seginfo->start_loc );
; 213  :         if( Options.output_format == OFORMAT_OMF && idx >= MAX_LEDATA_THRESHOLD ) {

	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN4@OutputByte
	cmp	edx, 1014				; 000003f6H
	jb	SHORT $LN4@OutputByte

; 214  :             omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 215  :             idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	r8, QWORD PTR ModuleInfo+432
	add	r8, 96					; 00000060H
	mov	rax, QWORD PTR [r8]
	mov	edx, DWORD PTR [rax+12]
	sub	edx, DWORD PTR [rax+8]
$LN4@OutputByte:

; 216  :         }
; 217  :         //DebugMsg(("OutputByte: buff=%p, idx=%" I32_SPEC "X, byte=%X, codebuff[0]=%X\n", CurrSeg->e.seginfo->CodeBuffer, idx, byte, *CurrSeg->e.seginfo->CodeBuffer ));
; 218  :         CurrSeg->e.seginfo->CodeBuffer[idx] = byte;

	mov	rax, QWORD PTR [r8]
	mov	rax, QWORD PTR [rax+16]
	mov	BYTE PTR [rdx+rax], bl

; 219  :     }

	jmp	SHORT $LN5@OutputByte
$LN2@OutputByte:

; 220  : #if 1
; 221  :     /* check this in pass 1 only */
; 222  :     else if( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rcx+12]
	cmp	eax, DWORD PTR [rcx+8]
	jae	SHORT $LN5@OutputByte

; 223  :         DebugMsg(("OutputByte: segment start loc changed from %" I32_SPEC "Xh to %" I32_SPEC "Xh\n",
; 224  :                   CurrSeg->e.seginfo->start_loc,
; 225  :                   CurrSeg->e.seginfo->current_loc));
; 226  :         CurrSeg->e.seginfo->start_loc = CurrSeg->e.seginfo->current_loc;

	mov	DWORD PTR [rcx+8], eax
$LN5@OutputByte:

; 227  :     }
; 228  : #endif
; 229  :     CurrSeg->e.seginfo->current_loc++;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	inc	DWORD PTR [rcx+12]

; 230  :     CurrSeg->e.seginfo->bytes_written++;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	inc	DWORD PTR [rcx+24]

; 231  :     CurrSeg->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	or	BYTE PTR [rcx+107], 32			; 00000020H

; 232  :     if( CurrSeg->e.seginfo->current_loc > CurrSeg->sym.max_offset )

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rcx+96]
	mov	edx, DWORD PTR [rax+12]
	cmp	edx, DWORD PTR [rcx+56]
	jbe	SHORT $LN6@OutputByte

; 233  :         CurrSeg->sym.max_offset = CurrSeg->e.seginfo->current_loc;

	mov	DWORD PTR [rcx+56], edx
$LN6@OutputByte:

; 234  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
OutputByte ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rdi, rcx

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rbx
	mov	QWORD PTR [rsp+40], rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], 0
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf
	test	eax, eax
	cmovs	eax, ebx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbx
	mov	r9, rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, rbx
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf

; 1459 :     #pragma warning(pop)
; 1460 : }

	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ebx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_Locale$ = 88
_ArgList$ = 96
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR _ArgList$[rsp]
	or	rcx, 1
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rbx
	call	__stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;
; 1391 : }

	mov	rbx, QWORD PTR [rsp+64]
	or	ecx, -1
	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ecx
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 950  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	rbx, rax
	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 955  :     __crt_va_end(_ArgList);
; 956  :     return _Result;
; 957  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 640  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
