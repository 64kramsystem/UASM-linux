; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	jmpenv
EXTRN	omf_init:PROC
EXTRN	coff_init:PROC
EXTRN	elf_init:PROC
EXTRN	bin_init:PROC
_BSS	SEGMENT
jmpenv	DB	0100H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	LinnumQueue:BYTE:010H
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	ModuleInfo:BYTE:0308H
COMM	Parse_Pass:DWORD
COMM	write_to_file:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11716 DB	'_TEXT', 00H
	ORG $+2
$SG11717 DB	'.text', 00H
	ORG $+2
$SG11718 DB	'_DATA', 00H
	ORG $+2
$SG11719 DB	'.data', 00H
	ORG $+2
$SG11720 DB	'CONST', 00H
	ORG $+2
$SG11721 DB	'.rdata', 00H
	ORG $+1
$SG11722 DB	'_BSS', 00H
	ORG $+3
$SG11723 DB	'.bss', 00H
	ORG $+3
$SG11820 DB	'w', 00H
	ORG $+2
$SG11884 DB	'%s', 0aH, 00H
$SG11824 DB	'import ''%s''  %s.%s', 0aH, 00H
$SG11886 DB	0aH, 00H
	ORG $+2
$SG11872 DB	'INCLUDE', 00H
$SG11909 DB	'%r %s', 00H
	ORG $+2
$SG12009 DB	'rb', 00H
	ORG $+1
$SG12012 DB	'wb', 00H
	ORG $+1
$SG12015 DB	'wb', 00H
	ORG $+1
$SG12048 DB	'EXE', 00H
$SG12049 DB	'BIN', 00H
$SG12050 DB	'obj', 00H
$SG12052 DB	'lst', 00H
$SG12054 DB	'err', 00H
$SG12121 DB	'%s', 0aH, 00H
_DATA	ENDS
CONST	SEGMENT
formatoptions DQ FLAT:bin_init
	DW	00H
	DB	'BIN', 00H
	ORG $+2
	DQ	FLAT:omf_init
	DW	00H
	DB	'OMF', 00H
	ORG $+2
	DQ	FLAT:coff_init
	DW	0e12H
	DB	'COFF', 00H
	ORG $+1
	DQ	FLAT:elf_init
	DW	0f00H
	DB	'ELF', 00H
	ORG $+2
cst	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11716
	DQ	FLAT:$SG11717
	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11718
	DQ	FLAT:$SG11719
	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11720
	DQ	FLAT:$SG11721
	DB	04H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG11722
	DQ	FLAT:$SG11723
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	printf
PUBLIC	sprintf
PUBLIC	OutputByte
PUBLIC	FillDataBytes
PUBLIC	OutputBytes
PUBLIC	AssembleModule
PUBLIC	SetMasm510
PUBLIC	close_files
PUBLIC	ConvertSectionName
PUBLIC	WritePreprocessedLine
PUBLIC	SetCurrOffset
EXTRN	isalpha:PROC
EXTRN	isdigit:PROC
EXTRN	isspace:PROC
EXTRN	isalnum:PROC
EXTRN	clock:PROC
EXTRN	__acrt_iob_func:PROC
EXTRN	fclose:PROC
EXTRN	fopen:PROC
EXTRN	fwrite:PROC
EXTRN	remove:PROC
EXTRN	rewind:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	_errno:PROC
EXTRN	getenv:PROC
EXTRN	strchr:PROC
EXTRN	strncpy:PROC
EXTRN	_strupr:PROC
EXTRN	Fatal:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	ErrnoStr:PROC
EXTRN	WriteError:PROC
EXTRN	MemInit:PROC
EXTRN	MemFini:PROC
EXTRN	LclAlloc:PROC
EXTRN	GetLineNumber:PROC
EXTRN	GetFNamePart:PROC
EXTRN	GetExtPart:PROC
EXTRN	SearchFile:PROC
EXTRN	AddStringToIncludePath:PROC
EXTRN	InputInit:PROC
EXTRN	InputPassInit:PROC
EXTRN	InputFini:PROC
EXTRN	ClearSrcStack:PROC
EXTRN	set_curr_srcfile:PROC
EXTRN	GetFName:PROC
EXTRN	SymCreate:PROC
EXTRN	SymFind:PROC
EXTRN	SymInit:PROC
EXTRN	SymFini:PROC
EXTRN	SymPassInit:PROC
EXTRN	SymMakeAllSymbolsPublic:PROC
EXTRN	SymSetCmpFunc:PROC
EXTRN	sym_remove_table:PROC
EXTRN	ParseLine:PROC
EXTRN	ProcessFile:PROC
EXTRN	DisableKeyword:PROC
EXTRN	ResWordsInit:PROC
EXTRN	ResWordsFini:PROC
EXTRN	Tokenize:PROC
EXTRN	CondCheckOpen:PROC
EXTRN	CondInit:PROC
EXTRN	SegmentInit:PROC
EXTRN	SegmentFini:PROC
EXTRN	AssumeInit:PROC
EXTRN	ProcInit:PROC
EXTRN	ExprEvalInit:PROC
EXTRN	HllInit:PROC
EXTRN	HllCheckOpen:PROC
EXTRN	ContextInit:PROC
EXTRN	TypesInit:PROC
EXTRN	LabelInit:PROC
EXTRN	MacroInit:PROC
EXTRN	FreePubQueue:PROC
EXTRN	store_fixup:PROC
EXTRN	omf_set_filepos:PROC
EXTRN	omf_OutSelect:PROC
EXTRN	omf_FlushCurrSeg:PROC
EXTRN	FastpassInit:PROC
EXTRN	SkipSavedState:PROC
EXTRN	RestoreState:PROC
EXTRN	LstInit:PROC
EXTRN	LstWriteCRef:PROC
EXTRN	LstPrintf:PROC
EXTRN	LstNL:PROC
EXTRN	MsgGetEx:PROC
EXTRN	LinnumInit:PROC
EXTRN	LinnumFini:PROC
EXTRN	QueueDeleteLinnum:PROC
EXTRN	SetCPU:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	RunLineQueue:PROC
EXTRN	Mangle:PROC
EXTRN	__chkstk:PROC
EXTRN	_setjmp:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	Options:BYTE
EXTRN	MacroLevel:BYTE
EXTRN	SymTables:BYTE
EXTRN	LineStoreCurr:QWORD
EXTRN	StoreState:BYTE
EXTRN	UseSavedState:BYTE
EXTRN	LastCodeBufSize:DWORD
EXTRN	DefaultDir:BYTE
EXTRN	ModelToken:BYTE
EXTRN	__ImageBase:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+83
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN8
	DD	imagerel $LN8+90
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$OutputByte DD imagerel $LN9
	DD	imagerel $LN9+185
	DD	imagerel $unwind$OutputByte
$pdata$FillDataBytes DD imagerel $LN20
	DD	imagerel $LN20+233
	DD	imagerel $unwind$FillDataBytes
$pdata$OutputBytes DD imagerel $LN10
	DD	imagerel $LN10+11
	DD	imagerel $unwind$OutputBytes
$pdata$2$OutputBytes DD imagerel $LN10+11
	DD	imagerel $LN10+44
	DD	imagerel $chain$2$OutputBytes
$pdata$3$OutputBytes DD imagerel $LN10+44
	DD	imagerel $LN10+151
	DD	imagerel $chain$3$OutputBytes
$pdata$4$OutputBytes DD imagerel $LN10+151
	DD	imagerel $LN10+250
	DD	imagerel $chain$4$OutputBytes
$pdata$5$OutputBytes DD imagerel $LN10+250
	DD	imagerel $LN10+258
	DD	imagerel $chain$5$OutputBytes
$pdata$AssembleModule DD imagerel $LN59
	DD	imagerel $LN59+730
	DD	imagerel $unwind$AssembleModule
$pdata$close_files DD imagerel $LN13
	DD	imagerel $LN13+222
	DD	imagerel $unwind$close_files
$pdata$ConvertSectionName DD imagerel $LN25
	DD	imagerel $LN25+328
	DD	imagerel $unwind$ConvertSectionName
$pdata$WritePreprocessedLine DD imagerel $LN16
	DD	imagerel $LN16+18
	DD	imagerel $unwind$WritePreprocessedLine
$pdata$0$WritePreprocessedLine DD imagerel $LN16+18
	DD	imagerel $LN16+106
	DD	imagerel $chain$0$WritePreprocessedLine
$pdata$1$WritePreprocessedLine DD imagerel $LN16+106
	DD	imagerel $LN16+145
	DD	imagerel $chain$1$WritePreprocessedLine
$pdata$SetCurrOffset DD imagerel $LN18
	DD	imagerel $LN18+176
	DD	imagerel $unwind$SetCurrOffset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$WriteModule DD imagerel WriteModule
	DD	imagerel WriteModule+374
	DD	imagerel $unwind$WriteModule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$is_valid_identifier DD imagerel is_valid_identifier
	DD	imagerel is_valid_identifier+66
	DD	imagerel $unwind$is_valid_identifier
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$is_valid_identifier DD imagerel is_valid_identifier+66
	DD	imagerel is_valid_identifier+149
	DD	imagerel $chain$0$is_valid_identifier
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$is_valid_identifier DD imagerel is_valid_identifier+149
	DD	imagerel is_valid_identifier+163
	DD	imagerel $chain$2$is_valid_identifier
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_cmdline_tmacros DD imagerel add_cmdline_tmacros
	DD	imagerel add_cmdline_tmacros+401
	DD	imagerel $unwind$add_cmdline_tmacros
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_incpaths DD imagerel add_incpaths
	DD	imagerel add_incpaths+41
	DD	imagerel $unwind$add_incpaths
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CmdlParamsInit DD imagerel CmdlParamsInit
	DD	imagerel CmdlParamsInit+8
	DD	imagerel $unwind$CmdlParamsInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$CmdlParamsInit DD imagerel CmdlParamsInit+8
	DD	imagerel CmdlParamsInit+63
	DD	imagerel $chain$0$CmdlParamsInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$CmdlParamsInit DD imagerel CmdlParamsInit+63
	DD	imagerel CmdlParamsInit+97
	DD	imagerel $chain$1$CmdlParamsInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ModulePassInit DD imagerel ModulePassInit
	DD	imagerel ModulePassInit+499
	DD	imagerel $unwind$ModulePassInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PassOneChecks DD imagerel PassOneChecks
	DD	imagerel PassOneChecks+293
	DD	imagerel $unwind$PassOneChecks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PassOneChecks DD imagerel PassOneChecks+293
	DD	imagerel PassOneChecks+419
	DD	imagerel $chain$0$PassOneChecks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PassOneChecks DD imagerel PassOneChecks+419
	DD	imagerel PassOneChecks+501
	DD	imagerel $chain$1$PassOneChecks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OnePass DD imagerel OnePass
	DD	imagerel OnePass+4
	DD	imagerel $unwind$OnePass
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$OnePass DD imagerel OnePass+4
	DD	imagerel OnePass+499
	DD	imagerel $chain$0$OnePass
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$OnePass DD imagerel OnePass+499
	DD	imagerel OnePass+519
	DD	imagerel $chain$1$OnePass
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_module_name DD imagerel get_module_name
	DD	imagerel get_module_name+226
	DD	imagerel $unwind$get_module_name
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ModuleInit DD imagerel ModuleInit
	DD	imagerel ModuleInit+174
	DD	imagerel $unwind$ModuleInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReswTableInit DD imagerel ReswTableInit
	DD	imagerel ReswTableInit+76
	DD	imagerel $unwind$ReswTableInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$open_files DD imagerel open_files
	DD	imagerel open_files+199
	DD	imagerel $unwind$open_files
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetFilenames DD imagerel SetFilenames
	DD	imagerel SetFilenames+654
	DD	imagerel $unwind$SetFilenames
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AssembleInit DD imagerel AssembleInit
	DD	imagerel AssembleInit+148
	DD	imagerel $unwind$AssembleInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AssembleFini DD imagerel AssembleFini
	DD	imagerel AssembleFini+65
	DD	imagerel $unwind$AssembleFini
pdata	ENDS
_DATA	SEGMENT
?PrintEmptyLine@?1??WritePreprocessedLine@@9@9 DB 01H	; `WritePreprocessedLine'::`2'::PrintEmptyLine
_DATA	ENDS
CONST	SEGMENT
stt	DD	01H
	DD	02H
	DD	02H
	DD	03H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AssembleFini DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AssembleInit DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetFilenames DD 0b1d01H
	DD	02b741dH
	DD	02a641dH
	DD	029541dH
	DD	028341dH
	DD	026011dH
	DD	0e016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$open_files DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReswTableInit DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ModuleInit DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_module_name DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$OnePass DD 021H
	DD	imagerel OnePass
	DD	imagerel OnePass+4
	DD	imagerel $unwind$OnePass
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$OnePass DD 020521H
	DD	043405H
	DD	imagerel OnePass
	DD	imagerel OnePass+4
	DD	imagerel $unwind$OnePass
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OnePass DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PassOneChecks DD 021H
	DD	imagerel PassOneChecks
	DD	imagerel PassOneChecks+293
	DD	imagerel $unwind$PassOneChecks
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PassOneChecks DD 020521H
	DD	043405H
	DD	imagerel PassOneChecks
	DD	imagerel PassOneChecks+293
	DD	imagerel $unwind$PassOneChecks
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PassOneChecks DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ModulePassInit DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$CmdlParamsInit DD 021H
	DD	imagerel CmdlParamsInit
	DD	imagerel CmdlParamsInit+8
	DD	imagerel $unwind$CmdlParamsInit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$CmdlParamsInit DD 020521H
	DD	043405H
	DD	imagerel CmdlParamsInit
	DD	imagerel CmdlParamsInit+8
	DD	imagerel $unwind$CmdlParamsInit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CmdlParamsInit DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_incpaths DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_cmdline_tmacros DD 0250d2601H
	DD	0c7426H
	DD	0b6422H
	DD	0a341eH
	DD	0320e2313H
	DD	0e008f00aH
	DD	0c004d006H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$is_valid_identifier DD 020021H
	DD	067400H
	DD	imagerel is_valid_identifier
	DD	imagerel is_valid_identifier+66
	DD	imagerel $unwind$is_valid_identifier
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$is_valid_identifier DD 020521H
	DD	067405H
	DD	imagerel is_valid_identifier
	DD	imagerel is_valid_identifier+66
	DD	imagerel $unwind$is_valid_identifier
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_valid_identifier DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WriteModule DD 067001H
	DD	086470H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
xdata	SEGMENT
$unwind$OutputByte DD 020601H
	DD	030023206H
$unwind$FillDataBytes DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$OutputBytes DD 010401H
	DD	04204H
$chain$2$OutputBytes DD 061521H
	DD	047415H
	DD	08640dH
	DD	075405H
	DD	imagerel $LN10
	DD	imagerel $LN10+11
	DD	imagerel $unwind$OutputBytes
$chain$3$OutputBytes DD 020521H
	DD	063405H
	DD	imagerel $LN10+11
	DD	imagerel $LN10+44
	DD	imagerel $chain$2$OutputBytes
$chain$4$OutputBytes DD 021H
	DD	imagerel $LN10+11
	DD	imagerel $LN10+44
	DD	imagerel $chain$2$OutputBytes
$chain$5$OutputBytes DD 021H
	DD	imagerel $LN10
	DD	imagerel $LN10+11
	DD	imagerel $unwind$OutputBytes
$unwind$AssembleModule DD 0a1d01H
	DD	011641dH
	DD	010541dH
	DD	0f341dH
	DD	0f019921dH
	DD	07015e017H
$unwind$close_files DD 020601H
	DD	030023206H
$unwind$ConvertSectionName DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
$unwind$WritePreprocessedLine DD 020601H
	DD	070023206H
$chain$0$WritePreprocessedLine DD 020521H
	DD	063405H
	DD	imagerel $LN16
	DD	imagerel $LN16+18
	DD	imagerel $unwind$WritePreprocessedLine
$chain$1$WritePreprocessedLine DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+18
	DD	imagerel $unwind$WritePreprocessedLine
$unwind$SetCurrOffset DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT AssembleFini
_TEXT	SEGMENT
AssembleFini PROC					; COMDAT

; 1351 : {

	sub	rsp, 40					; 00000028H

; 1352 :     int i;
; 1353 :     SegmentFini();

	call	SegmentFini

; 1354 :     SymFini();

	call	SymFini

; 1355 :     ResWordsFini();

	call	ResWordsFini

; 1356 : #ifdef DEBUG_OUT
; 1357 :     DumpInstrStats();
; 1358 :     MacroFini();
; 1359 : #endif
; 1360 :     FreePubQueue();

	call	FreePubQueue

; 1361 : #if FASTMEM==0
; 1362 :     FreeLibQueue();
; 1363 :     ContextFini();
; 1364 :     HllFini();
; 1365 : #endif
; 1366 :     InputFini();

	call	InputFini

; 1367 :     close_files();

	call	close_files
	xorps	xmm0, xmm0
	xorps	xmm1, xmm1
	movdqu	XMMWORD PTR ModuleInfo+128, xmm0
	movdqu	XMMWORD PTR ModuleInfo+144, xmm1

; 1381 :     return;
; 1382 : }

	add	rsp, 40					; 00000028H

; 1368 : 
; 1369 : #if FASTPASS
; 1370 : #if FASTMEM==0
; 1371 :     FreeLineStore();
; 1372 : #endif
; 1373 : #endif
; 1374 : 
; 1375 :     for ( i = 0; i < NUM_FILE_TYPES; i++ ) {
; 1376 :         LclFree( CurrFName[i] );
; 1377 :         /* v2.05: make sure the pointer for ERR is cleared */
; 1378 :         CurrFName[i] = NULL;
; 1379 :     }
; 1380 :     MemFini();

	jmp	MemFini
AssembleFini ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT AssembleInit
_TEXT	SEGMENT
source$ = 48
AssembleInit PROC					; COMDAT

; 1311 : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1312 :     DebugMsg(("AssembleInit(\"%s\") enter\n", source ));
; 1313 : 
; 1314 :     MemInit();

	call	MemInit

; 1315 :     //start_label   = NULL;
; 1316 :     //start_displ   = 0;
; 1317 :     write_to_file = FALSE;
; 1318 :     //GeneratedCode = 0;
; 1319 :     LinnumQueue.head = NULL;
; 1320 : 
; 1321 :     SetFilenames( source );

	mov	rcx, rbx
	mov	BYTE PTR write_to_file, 0
	mov	QWORD PTR LinnumQueue, 0
	call	SetFilenames

; 1322 : 
; 1323 : #if FASTPASS
; 1324 :     FastpassInit();

	call	FastpassInit

; 1325 : #endif
; 1326 :     open_files();

	call	open_files

; 1327 : #if BUILD_TARGET
; 1328 :     get_os_include();
; 1329 : #endif
; 1330 :     ReswTableInit();

	call	ResWordsInit
	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN4@AssembleIn
	mov	ecx, 233				; 000000e9H
	call	DisableKeyword
	mov	ecx, 243				; 000000f3H
	call	DisableKeyword
$LN4@AssembleIn:
	cmp	BYTE PTR Options+127, 1
	jne	SHORT $LN5@AssembleIn
	mov	ecx, 444				; 000001bcH
	call	DisableKeyword
	mov	ecx, 270				; 0000010eH
	call	DisableKeyword
$LN5@AssembleIn:

; 1331 :     SymInit();

	call	SymInit

; 1332 :     InputInit();

	call	InputInit

; 1333 : 
; 1334 :     ModuleInit();

	call	ModuleInit

; 1335 :     CondInit();

	call	CondInit

; 1336 :     ExprEvalInit();

	call	ExprEvalInit

; 1338 : 
; 1339 :     DebugMsg(("AssembleInit() exit\n"));
; 1340 :     return;
; 1341 : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 1337 :     LstInit();

	jmp	LstInit
AssembleInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT SetFilenames
_TEXT	SEGMENT
path$ = 32
name$ = 320
SetFilenames PROC					; COMDAT

; 1263 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 304				; 00000130H
	mov	rbx, rcx

; 1264 :     int i;
; 1265 :     const char *fn;
; 1266 :     char *ext;
; 1267 :     char path[ FILENAME_MAX ];
; 1268 : 
; 1269 :     DebugMsg(("SetFilenames(\"%s\") enter\n", name ));
; 1270 : 
; 1271 :     /* set CurrFName[ASM] */
; 1272 :     CurrFName[ASM] = LclAlloc( strlen( name ) + 1 );

	or	rcx, -1
$LL70@SetFilenam:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], 0
	jne	SHORT $LL70@SetFilenam
	inc	rcx
	call	LclAlloc
	mov	QWORD PTR ModuleInfo+128, rax

; 1273 :     strcpy( CurrFName[ASM], name );

	mov	rdx, rbx
	npad	1
$LL11@SetFilenam:
	movzx	ecx, BYTE PTR [rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL11@SetFilenam

; 1274 : 
; 1275 :     /* set [OBJ], [ERR], [LST] */
; 1276 :     fn = GetFNamePart( name );

	mov	rcx, rbx
	call	GetFNamePart
	mov	rdi, rax

; 1277 :     for ( i = ASM+1; i < NUM_FILE_TYPES; i++ ) {

	lea	rbp, OFFSET FLAT:__ImageBase
	xor	esi, esi
	lea	r14, OFFSET FLAT:$SG12048
	mov	ebx, 1
$LL4@SetFilenam:

; 1278 :         if( Options.names[i] == NULL ) {

	mov	rcx, QWORD PTR Options[rsi+rbp+24]
	test	rcx, rcx
	jne	$LN5@SetFilenam

; 1279 :             path[0] = NULLC;

	mov	BYTE PTR path$[rsp], cl
	mov	rcx, QWORD PTR DefaultDir[rsi+rbp+8]

; 1280 :             if ( DefaultDir[i])

	test	rcx, rcx
	je	SHORT $LN7@SetFilenam

; 1281 :                 strcpy( path, DefaultDir[i] );

	lea	rdx, QWORD PTR path$[rsp]
	sub	rdx, rcx
	npad	5
$LL12@SetFilenam:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rdx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL12@SetFilenam
$LN7@SetFilenam:

; 1282 :             strcat( path, fn );

	lea	rcx, QWORD PTR path$[rsp]
	dec	rcx
$LL68@SetFilenam:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL68@SetFilenam
	xor	edx, edx
	npad	14
$LL69@SetFilenam:
	movzx	eax, BYTE PTR [rdi+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL69@SetFilenam

; 1283 :             ext = GetExtPart( path );

	lea	rcx, QWORD PTR path$[rsp]
	call	GetExtPart

; 1284 :             *ext++  = '.';

	mov	BYTE PTR [rax], 46			; 0000002eH
	lea	rdx, QWORD PTR [rax+1]

; 1285 :             strcpy( ext, GetExt( i ) );

	mov	eax, ebx
	sub	eax, 1
	je	SHORT $LN21@SetFilenam
	sub	eax, 1
	je	SHORT $LN26@SetFilenam
	cmp	eax, 1
	je	SHORT $LN27@SetFilenam
	xor	ecx, ecx
	jmp	SHORT $LN18@SetFilenam
$LN27@SetFilenam:
	lea	rcx, OFFSET FLAT:$SG12054
	jmp	SHORT $LN18@SetFilenam
$LN26@SetFilenam:
	lea	rcx, OFFSET FLAT:$SG12052
	jmp	SHORT $LN18@SetFilenam
$LN21@SetFilenam:
	cmp	DWORD PTR Options+144, 0
	jne	SHORT $LN24@SetFilenam
	mov	eax, DWORD PTR Options+148
	lea	rcx, OFFSET FLAT:$SG12049
	dec	eax
	cmp	eax, 1
	cmovbe	rcx, r14
	jmp	SHORT $LN18@SetFilenam
$LN24@SetFilenam:
	lea	rcx, OFFSET FLAT:$SG12050
$LN18@SetFilenam:
	sub	rdx, rcx
$LL13@SetFilenam:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rdx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL13@SetFilenam

; 1286 : 
; 1287 :         } else {

	jmp	$LN9@SetFilenam
$LN5@SetFilenam:

; 1288 :             /* filename has been set by cmdline option -Fo, -Fl or -Fr */
; 1289 :             const char *fn2;
; 1290 :             strcpy( path, Options.names[i] );

	lea	rdx, QWORD PTR path$[rsp]
	sub	rdx, rcx
	npad	3
$LL14@SetFilenam:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rdx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL14@SetFilenam

; 1291 :             fn2 = GetFNamePart( path );

	lea	rcx, QWORD PTR path$[rsp]
	call	GetFNamePart

; 1292 :             if( *fn2 == NULLC )

	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN8@SetFilenam

; 1293 :                 strcpy( (char *)fn2, fn );

	mov	r8, rax
	mov	rdx, rdi
	sub	r8, rdi
	npad	10
$LL15@SetFilenam:
	movzx	ecx, BYTE PTR [rdx]
	mov	BYTE PTR [r8+rdx], cl
	lea	rdx, QWORD PTR [rdx+1]
	test	cl, cl
	jne	SHORT $LL15@SetFilenam
$LN8@SetFilenam:

; 1294 :             ext = GetExtPart( fn2 );

	mov	rcx, rax
	call	GetExtPart
	mov	rdx, rax

; 1295 :             if( *ext == NULLC ) {

	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN9@SetFilenam

; 1296 :                 *ext++  = '.';

	mov	BYTE PTR [rax], 46			; 0000002eH
	inc	rdx

; 1297 :                 strcpy( ext, GetExt( i ) );

	mov	eax, ebx
	sub	eax, 1
	je	SHORT $LN32@SetFilenam
	sub	eax, 1
	je	SHORT $LN37@SetFilenam
	cmp	eax, 1
	je	SHORT $LN38@SetFilenam
	xor	eax, eax
	jmp	SHORT $LN29@SetFilenam
$LN38@SetFilenam:
	lea	rax, OFFSET FLAT:$SG12054
	jmp	SHORT $LN29@SetFilenam
$LN37@SetFilenam:
	lea	rax, OFFSET FLAT:$SG12052
	jmp	SHORT $LN29@SetFilenam
$LN32@SetFilenam:
	cmp	DWORD PTR Options+144, 0
	jne	SHORT $LN35@SetFilenam
	mov	ecx, DWORD PTR Options+148
	lea	rax, OFFSET FLAT:$SG12049
	dec	ecx
	cmp	ecx, 1
	cmovbe	rax, r14
	jmp	SHORT $LN29@SetFilenam
$LN35@SetFilenam:
	lea	rax, OFFSET FLAT:$SG12050
$LN29@SetFilenam:
	sub	rdx, rax
	npad	9
$LL16@SetFilenam:
	movzx	ecx, BYTE PTR [rax]
	mov	BYTE PTR [rdx+rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL16@SetFilenam
$LN9@SetFilenam:

; 1298 :             }
; 1299 :         }
; 1300 :         DebugMsg(("SetFilenames: i=%u >%s<\n", i, path ));
; 1301 :         CurrFName[i] = LclAlloc( strlen( path ) + 1 );

	lea	rax, QWORD PTR path$[rsp]
	or	rcx, -1
$LL67@SetFilenam:
	inc	rcx
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL67@SetFilenam
	inc	rcx
	call	LclAlloc
	mov	QWORD PTR ModuleInfo[rsi+rbp+136], rax

; 1302 :         strcpy( CurrFName[i], path );

	lea	rdx, QWORD PTR path$[rsp]
	npad	11
$LL17@SetFilenam:
	movzx	ecx, BYTE PTR [rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL17@SetFilenam

; 1277 :     for ( i = ASM+1; i < NUM_FILE_TYPES; i++ ) {

	inc	ebx
	add	rsi, 8
	cmp	ebx, 4
	jl	$LL4@SetFilenam

; 1303 :     }
; 1304 :     return;
; 1305 : }

	lea	r11, QWORD PTR [rsp+304]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	r14
	ret	0
SetFilenames ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT GetExt
_TEXT	SEGMENT
type$ = 8
GetExt	PROC						; COMDAT

; 1228 :     switch ( type ) {

	sub	ecx, 1
	je	SHORT $LN4@GetExt
	sub	ecx, 1
	je	SHORT $LN9@GetExt
	cmp	ecx, 1
	je	SHORT $LN10@GetExt

; 1248 :     }
; 1249 :     return( NULL );

	xor	eax, eax

; 1250 : }

	ret	0
$LN10@GetExt:

; 1246 :     case ERR:
; 1247 :         return( ERR_EXT );

	lea	rax, OFFSET FLAT:$SG12054

; 1250 : }

	ret	0
$LN9@GetExt:

; 1244 :     case LST:
; 1245 :         return( LST_EXT );

	lea	rax, OFFSET FLAT:$SG12052

; 1250 : }

	ret	0
$LN4@GetExt:

; 1229 :     case OBJ:
; 1230 : #if BIN_SUPPORT
; 1231 :         if ( Options.output_format == OFORMAT_BIN )

	cmp	DWORD PTR Options+144, 0
	jne	SHORT $LN7@GetExt
	mov	eax, DWORD PTR Options+148
	dec	eax
	cmp	eax, 1
	jbe	SHORT $LN8@GetExt

; 1239 :             else
; 1240 : #endif
; 1241 :                 return( BIN_EXT );

	lea	rax, OFFSET FLAT:$SG12049

; 1250 : }

	ret	0
$LN8@GetExt:

; 1232 : #if MZ_SUPPORT || PE_SUPPORT
; 1233 :             if ( Options.sub_format == SFORMAT_MZ
; 1234 : #if PE_SUPPORT
; 1235 :                 || Options.sub_format == SFORMAT_PE
; 1236 : #endif
; 1237 :                )
; 1238 :                 return( EXE_EXT );

	lea	rax, OFFSET FLAT:$SG12048

; 1250 : }

	ret	0
$LN7@GetExt:

; 1242 : #endif
; 1243 :         return( OBJ_EXT );

	lea	rax, OFFSET FLAT:$SG12050

; 1250 : }

	ret	0
GetExt	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT open_files
_TEXT	SEGMENT
open_files PROC						; COMDAT

; 1151 : {

	sub	rsp, 40					; 00000028H

; 1152 :     /* open ASM file */
; 1153 :     DebugMsg(("open_files() enter\n" ));
; 1154 : 
; 1155 :     //memset( CurrFile, 0, sizeof( CurrFile ) );
; 1156 :     /* CurrFile[ASM] = fopen( CurrFName[ASM], "r" ); */
; 1157 :     CurrFile[ASM] = fopen( CurrFName[ASM], "rb" );

	mov	rcx, QWORD PTR ModuleInfo+128
	lea	rdx, OFFSET FLAT:$SG12009
	call	fopen
	mov	QWORD PTR ModuleInfo+96, rax

; 1158 :     if( CurrFile[ASM] == NULL ) {

	test	rax, rax
	jne	SHORT $LN2@open_files

; 1159 :         DebugMsg(("open_files(): cannot open source file, fopen(\"%s\") failed\n", CurrFName[ASM] ));
; 1160 :         Fatal( CANNOT_OPEN_FILE, CurrFName[ASM], ErrnoStr() );

	call	ErrnoStr
	mov	rdx, QWORD PTR ModuleInfo+128
	mov	r8, rax
	mov	ecx, 106				; 0000006aH
	call	Fatal
$LN2@open_files:

; 1161 :     }
; 1162 : 
; 1163 :     /* open OBJ file */
; 1164 :     if ( Options.syntax_check_only == FALSE ) {

	cmp	BYTE PTR Options+172, 0
	jne	SHORT $LN4@open_files

; 1165 :         CurrFile[OBJ] = fopen( CurrFName[OBJ], "wb" );

	mov	rcx, QWORD PTR ModuleInfo+136
	lea	rdx, OFFSET FLAT:$SG12012
	call	fopen
	mov	QWORD PTR ModuleInfo+104, rax

; 1166 :         if( CurrFile[OBJ] == NULL ) {

	test	rax, rax
	jne	SHORT $LN4@open_files

; 1167 :             DebugMsg(("open_files(): cannot open object file, fopen(\"%s\") failed\n", CurrFName[OBJ] ));
; 1168 :             Fatal( CANNOT_OPEN_FILE, CurrFName[OBJ], ErrnoStr() );

	call	ErrnoStr
	mov	rdx, QWORD PTR ModuleInfo+136
	mov	r8, rax
	mov	ecx, 106				; 0000006aH
	call	Fatal
$LN4@open_files:

; 1169 :         }
; 1170 :         DebugMsg(("open_files(): output, fopen(\"%s\") ok\n", CurrFName[OBJ] ));
; 1171 :     }
; 1172 : 
; 1173 :     if( Options.write_listing ) {

	cmp	BYTE PTR Options+121, 0
	je	SHORT $LN6@open_files

; 1174 :         CurrFile[LST] = fopen( CurrFName[LST], "wb" );

	mov	rcx, QWORD PTR ModuleInfo+144
	lea	rdx, OFFSET FLAT:$SG12015
	call	fopen
	mov	QWORD PTR ModuleInfo+112, rax

; 1175 :         if ( CurrFile[LST] == NULL )

	test	rax, rax
	jne	SHORT $LN6@open_files

; 1176 :             Fatal( CANNOT_OPEN_FILE, CurrFName[LST], ErrnoStr() );

	call	ErrnoStr
	mov	rdx, QWORD PTR ModuleInfo+144
	mov	r8, rax
	mov	ecx, 106				; 0000006aH

; 1177 :     }
; 1178 :     return;
; 1179 : }

	add	rsp, 40					; 00000028H

; 1176 :             Fatal( CANNOT_OPEN_FILE, CurrFName[LST], ErrnoStr() );

	jmp	Fatal
$LN6@open_files:

; 1177 :     }
; 1178 :     return;
; 1179 : }

	add	rsp, 40					; 00000028H
	ret	0
open_files ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT ReswTableInit
_TEXT	SEGMENT
ReswTableInit PROC					; COMDAT

; 1127 : {

	sub	rsp, 40					; 00000028H

; 1128 :     ResWordsInit();

	call	ResWordsInit

; 1129 :     if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN2@ReswTableI

; 1130 :         /* DebugMsg(("InitAsm: disable IMAGEREL+SECTIONREL\n")); */
; 1131 :         /* for OMF, IMAGEREL and SECTIONREL are disabled */
; 1132 : #if IMAGERELSUPP
; 1133 :         DisableKeyword( T_IMAGEREL );

	mov	ecx, 233				; 000000e9H
	call	DisableKeyword

; 1134 : #endif
; 1135 : #if SECTIONRELSUPP
; 1136 :         DisableKeyword( T_SECTIONREL );

	mov	ecx, 243				; 000000f3H
	call	DisableKeyword
$LN2@ReswTableI:

; 1137 : #endif
; 1138 :     }
; 1139 : 
; 1140 :     if ( Options.strict_masm_compat == TRUE ) {

	cmp	BYTE PTR Options+127, 1
	jne	SHORT $LN3@ReswTableI

; 1141 :         DebugMsg(("ReswTableInit: disable INCBIN + FASTCALL keywords\n"));
; 1142 :         DisableKeyword( T_INCBIN );

	mov	ecx, 444				; 000001bcH
	call	DisableKeyword

; 1143 :         DisableKeyword( T_FASTCALL );

	mov	ecx, 270				; 0000010eH

; 1144 :     }
; 1145 : 
; 1146 :     return;
; 1147 : }

	add	rsp, 40					; 00000028H

; 1143 :         DisableKeyword( T_FASTCALL );

	jmp	DisableKeyword
$LN3@ReswTableI:

; 1144 :     }
; 1145 : 
; 1146 :     return;
; 1147 : }

	add	rsp, 40					; 00000028H
	ret	0
ReswTableInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT ModuleInit
_TEXT	SEGMENT
ModuleInit PROC						; COMDAT

; 1101 : {

	sub	rsp, 40					; 00000028H

; 1102 :     ModuleInfo.sub_format = Options.sub_format;

	mov	eax, DWORD PTR Options+148

; 1103 :     ModuleInfo.fmtopt = &formatoptions[Options.output_format];

	lea	rdx, OFFSET FLAT:formatoptions
	movsxd	rcx, DWORD PTR Options+144
	mov	DWORD PTR ModuleInfo+372, eax
	mov	rax, rcx
	shl	rax, 4
	add	rax, rdx
	mov	QWORD PTR ModuleInfo+344, rax

; 1104 :     ModuleInfo.CommentDataInCode = (Options.output_format == OFORMAT_OMF &&

	cmp	ecx, 1
	jne	SHORT $LN3@ModuleInit
	cmp	BYTE PTR Options+112, 0
	mov	BYTE PTR ModuleInfo+423, cl
	je	SHORT $LN4@ModuleInit
$LN3@ModuleInit:
	mov	BYTE PTR ModuleInfo+423, 0
$LN4@ModuleInit:

; 1105 :                          Options.no_comment_data_in_code_records == FALSE);
; 1106 :     ModuleInfo.g.error_count = 0;
; 1107 :     ModuleInfo.g.warning_count = 0;
; 1108 :     ModuleInfo.model = MODEL_NONE;
; 1109 :     /* ModuleInfo.distance = STACK_NONE; */
; 1110 :     ModuleInfo.ostype = OPSYS_DOS;
; 1111 :     ModuleInfo.emulator = (Options.floating_point == FPO_EMULATION);

	mov	eax, DWORD PTR ModuleInfo+408
	xor	ecx, ecx
	cmp	DWORD PTR Options+4, 1
	mov	QWORD PTR ModuleInfo, rcx
	mov	DWORD PTR ModuleInfo+360, ecx
	mov	DWORD PTR ModuleInfo+368, ecx
	sete	cl
	shl	ecx, 9
	xor	ecx, eax
	and	ecx, 512				; 00000200H
	xor	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 1112 :     //ModuleInfo.flatgrp_idx = 0;
; 1113 : 
; 1114 :     get_module_name(); /* set ModuleInfo.name */

	call	get_module_name

; 1115 : 
; 1116 :     /* v2.06: ST_PROC has been removed */
; 1117 :     //SimpleType[ST_PROC].mem_type = MT_NEAR;
; 1118 : 
; 1119 :     memset( SymTables, 0, sizeof( SymTables[0] ) * TAB_LAST );

	xor	edx, edx
	lea	rcx, OFFSET FLAT:SymTables
	lea	r8d, QWORD PTR [rdx+96]
	call	memset

; 1120 :     ModuleInfo.fmtopt->init( &ModuleInfo );

	mov	rax, QWORD PTR ModuleInfo+344
	lea	rcx, OFFSET FLAT:ModuleInfo

; 1121 : 
; 1122 :     return;
; 1123 : }

	add	rsp, 40					; 00000028H

; 1120 :     ModuleInfo.fmtopt->init( &ModuleInfo );

	rex_jmp	QWORD PTR [rax]
ModuleInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT get_module_name
_TEXT	SEGMENT
get_module_name PROC					; COMDAT

; 1062 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1063 :     //char dummy[_MAX_EXT];
; 1064 :     char        *p;
; 1065 : 
; 1066 :     /* v2.08: prefer name given by -nm option */
; 1067 :     if ( Options.names[OPTN_MODULE_NAME] ) {

	mov	rdx, QWORD PTR Options+56
	test	rdx, rdx
	je	SHORT $LN5@get_module

; 1068 :         strncpy( ModuleInfo.name, Options.names[OPTN_MODULE_NAME], sizeof( ModuleInfo.name ) );

	lea	rbx, OFFSET FLAT:ModuleInfo+512
	mov	r8d, 260				; 00000104H
	mov	rcx, rbx
	call	strncpy

; 1069 :         ModuleInfo.name[ sizeof( ModuleInfo.name ) - 1] = NULLC;

	mov	BYTE PTR ModuleInfo+771, 0

; 1070 :     } else {

	jmp	SHORT $LN6@get_module
$LN5@get_module:

; 1071 :         /* v2.12: _splitpath()/_makepath() removed */
; 1072 :         const char *fn = GetFNamePart( CurrFName[ASM] );

	mov	rcx, QWORD PTR ModuleInfo+128
	call	GetFNamePart

; 1073 :         char *ext = GetExtPart( fn );

	mov	rcx, rax
	mov	rbx, rax
	call	GetExtPart
	mov	rdi, rax

; 1074 :         memcpy( ModuleInfo.name, fn, ext - fn );

	mov	rdx, rbx
	sub	rdi, rbx
	lea	rbx, OFFSET FLAT:ModuleInfo+512
	mov	rcx, rbx
	mov	r8, rdi
	call	memcpy

; 1075 :         ModuleInfo.name[ ext - fn ] = NULLC;

	mov	BYTE PTR [rdi+rbx], 0
$LN6@get_module:

; 1076 :         //_splitpath( CurrFName[ASM], NULL, NULL, ModuleInfo.name, dummy );
; 1077 :     }
; 1078 : 
; 1079 :     _strupr( ModuleInfo.name );

	mov	rcx, rbx
	call	_strupr

; 1080 :     /* the module name must be a valid identifier, because it's used
; 1081 :      * as part of a segment name in certain memory models.
; 1082 :      */
; 1083 :     for( p = ModuleInfo.name; *p; ++p ) {

	movzx	eax, BYTE PTR ModuleInfo+512
	test	al, al
	je	SHORT $LN3@get_module
	mov	rdi, 576460752706076673			; 0800000018000001H
$LL4@get_module:

; 1084 :         if( !( isalnum( *p ) || ( *p == '_' ) || ( *p == '$' )

	movsx	ecx, BYTE PTR [rbx]
	call	isalnum
	test	eax, eax
	jne	SHORT $LN2@get_module
	movzx	eax, BYTE PTR [rbx]
	sub	al, 36					; 00000024H
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN14@get_module
	movsx	rax, al
	bt	rdi, rax
	jb	SHORT $LN2@get_module
$LN14@get_module:

; 1085 :             || ( *p == '@' ) || ( *p == '?') ) ) {
; 1086 :             /* it's not a legal character for a symbol name */
; 1087 :             *p = '_';

	mov	BYTE PTR [rbx], 95			; 0000005fH
$LN2@get_module:

; 1080 :     /* the module name must be a valid identifier, because it's used
; 1081 :      * as part of a segment name in certain memory models.
; 1082 :      */
; 1083 :     for( p = ModuleInfo.name; *p; ++p ) {

	inc	rbx
	cmp	BYTE PTR [rbx], 0
	jne	SHORT $LL4@get_module
	movzx	eax, BYTE PTR ModuleInfo+512
$LN3@get_module:

; 1088 :         }
; 1089 :     }
; 1090 :     /* first character can't be a digit either */
; 1091 :     if( isdigit( ModuleInfo.name[0] ) ) {

	movsx	ecx, al
	call	isdigit
	movzx	ecx, BYTE PTR ModuleInfo+512
	test	eax, eax

; 1092 :         ModuleInfo.name[0] = '_';
; 1093 :     }
; 1094 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	edx, 95					; 0000005fH
	cmovne	ecx, edx
	mov	BYTE PTR ModuleInfo+512, cl
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
get_module_name ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT OnePass
_TEXT	SEGMENT
OnePass	PROC						; COMDAT

; 952  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+32], rbx

; 953  : 
; 954  :     InputPassInit();

	call	InputPassInit

; 955  :     ModulePassInit();

	call	ModulePassInit

; 956  :     SymPassInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	SymPassInit

; 957  :     LabelInit();

	call	LabelInit

; 958  :     SegmentInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	SegmentInit

; 959  :     ContextInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	ContextInit

; 960  :     ProcInit();

	call	ProcInit

; 961  :     TypesInit();

	call	TypesInit

; 962  :     HllInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	HllInit

; 963  :     MacroInit( Parse_Pass ); /* insert predefined macros */

	mov	ecx, DWORD PTR Parse_Pass
	call	MacroInit

; 964  :     AssumeInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	AssumeInit

; 965  :     CmdlParamsInit( Parse_Pass );

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN17@OnePass
	call	add_cmdline_tmacros
	mov	rbx, QWORD PTR Options+104
	test	rbx, rbx
	je	SHORT $LN21@OnePass
	npad	2
$LL22@OnePass:
	lea	rcx, QWORD PTR [rbx+8]
	call	AddStringToIncludePath
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL22@OnePass
$LN21@OnePass:
	cmp	BYTE PTR Options+140, 0
	jne	SHORT $LN17@OnePass
	lea	rcx, OFFSET FLAT:$SG11872
	call	getenv
	test	rax, rax
	je	SHORT $LN17@OnePass
	mov	rcx, rax
	call	AddStringToIncludePath
$LN17@OnePass:

; 966  : 
; 967  :     ModuleInfo.EndDirFound = FALSE;

	and	DWORD PTR ModuleInfo+408, -65537	; fffeffffH

; 968  :     ModuleInfo.PhaseError = FALSE;

	mov	BYTE PTR ModuleInfo+422, 0

; 969  :     //Modend = FALSE;
; 970  :     /* LineNumber = 0; */
; 971  :     LinnumInit();

	call	LinnumInit

; 972  : 
; 973  : #ifdef DEBUG_OUT
; 974  :     if ( Parse_Pass > PASS_1 ) {
; 975  :         DebugMsg(("OnePass(%u) segments (current=%s):\n", Parse_Pass + 1, CurrSeg ? CurrSeg->sym.name : "NULL" ));
; 976  :         {
; 977  :             struct dsym *dir;
; 978  :             for( dir = SymTables[TAB_SEG].head; dir; dir = dir->next ) {
; 979  :                 DebugMsg(("OnePass(%u): segm=%-8s typ=%X start=%8X max_ofs=%8X\n", Parse_Pass + 1,
; 980  :                           dir->sym.name, dir->e.seginfo->segtype, dir->e.seginfo->start_loc, dir->sym.max_offset ));
; 981  :             }
; 982  :         }
; 983  :     }
; 984  : #endif
; 985  :     /* the functions above might have written something to the line queue */
; 986  :     if ( is_linequeue_populated() )

	cmp	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN7@OnePass

; 987  :         RunLineQueue();

	call	RunLineQueue
$LN7@OnePass:

; 988  : #if FASTPASS
; 989  :     StoreState = FALSE;
; 990  :     if ( Parse_Pass > PASS_1 && UseSavedState == TRUE ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	BYTE PTR StoreState, 0
	jbe	$LN8@OnePass
	cmp	BYTE PTR UseSavedState, 1
	jne	$LN8@OnePass

; 991  :         LineStoreCurr = RestoreState();

	call	RestoreState
	mov	QWORD PTR LineStoreCurr, rax

; 992  :         while ( LineStoreCurr && ModuleInfo.EndDirFound == FALSE ) {

	test	rax, rax
	je	$LN9@OnePass
	xor	ebx, ebx
$LL2@OnePass:
	test	BYTE PTR ModuleInfo+410, 1
	jne	$LN9@OnePass

; 993  :             /* the source line is modified in Tokenize() if it contains a comment! */
; 994  : #if USELSLINE==0
; 995  :             strcpy( CurrSource, LineStoreCurr->line );
; 996  : #endif
; 997  :             set_curr_srcfile( LineStoreCurr->srcfile, LineStoreCurr->lineno );

	mov	ecx, DWORD PTR [rax+8]
	mov	edx, ecx
	and	edx, 1048575				; 000fffffH
	shr	ecx, 20
	call	set_curr_srcfile

; 998  :             /* v2.06: list flags now initialized on the top level */
; 999  :             ModuleInfo.line_flags = 0;
; 1000 :             MacroLevel = ( LineStoreCurr->srcfile == 0xFFF ? 1 : 0 );

	mov	rcx, QWORD PTR LineStoreCurr

; 1001 :             DebugMsg1(("OnePass(%u) cur/nxt=%X/%X src=%X.%u mlvl=%u: >%s<\n", Parse_Pass+1, LineStoreCurr, LineStoreCurr->next, LineStoreCurr->srcfile, LineStoreCurr->lineno, MacroLevel, LineStoreCurr->line ));
; 1002 :             ModuleInfo.CurrComment = NULL; /* v2.08: added (var is never reset because GetTextLine() isn't called) */
; 1003 : #if USELSLINE
; 1004 :             if ( Token_Count = Tokenize( LineStoreCurr->line, 0, ModuleInfo.tokenarray, TOK_DEFAULT ) )

	mov	r8, QWORD PTR ModuleInfo+480
	mov	BYTE PTR ModuleInfo+398, bl
	mov	eax, DWORD PTR [rcx+8]
	and	eax, -1048576				; fff00000H
	mov	QWORD PTR ModuleInfo+472, rbx
	cmp	eax, -1048576				; fff00000H
	sete	BYTE PTR MacroLevel
	add	rcx, 16
	xor	r9d, r9d
	xor	edx, edx
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax
	test	eax, eax
	je	SHORT $LN10@OnePass

; 1005 : #else
; 1006 :             if ( Token_Count = Tokenize( CurrSource, 0, ModuleInfo.tokenarray, TOK_DEFAULT ) )
; 1007 : #endif
; 1008 :                 ParseLine( ModuleInfo.tokenarray );

	mov	rcx, QWORD PTR ModuleInfo+480
	call	ParseLine
$LN10@OnePass:

; 1009 :             LineStoreCurr = LineStoreCurr->next;

	mov	rax, QWORD PTR LineStoreCurr
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR LineStoreCurr, rax
	test	rax, rax
	jne	$LL2@OnePass

; 1010 :         }
; 1011 :     } else

	jmp	SHORT $LN9@OnePass
$LN8@OnePass:

; 1012 : #endif
; 1013 :     {
; 1014 :         struct qitem *pq;
; 1015 :         /* v2.11: handle -Fi files here ( previously in CmdlParamsInit ) */
; 1016 :         for ( pq = Options.queues[OPTQ_FINCLUDE]; pq; pq = pq->next ) {

	mov	rbx, QWORD PTR Options+88
	test	rbx, rbx
	je	SHORT $LN5@OnePass
	npad	5
$LL6@OnePass:

; 1017 :             DebugMsg(("OnePass: force include of file: %s\n", pq->value ));
; 1018 :             if ( SearchFile( pq->value, TRUE ) )

	lea	rcx, QWORD PTR [rbx+8]
	mov	dl, 1
	call	SearchFile
	test	rax, rax
	je	SHORT $LN4@OnePass

; 1019 :                 ProcessFile( ModuleInfo.tokenarray );

	mov	rcx, QWORD PTR ModuleInfo+480
	call	ProcessFile
$LN4@OnePass:

; 1012 : #endif
; 1013 :     {
; 1014 :         struct qitem *pq;
; 1015 :         /* v2.11: handle -Fi files here ( previously in CmdlParamsInit ) */
; 1016 :         for ( pq = Options.queues[OPTQ_FINCLUDE]; pq; pq = pq->next ) {

	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL6@OnePass
$LN5@OnePass:

; 1020 :         }
; 1021 :         ProcessFile( ModuleInfo.tokenarray ); /* process the main source file */

	mov	rcx, QWORD PTR ModuleInfo+480
	call	ProcessFile
$LN9@OnePass:

; 1022 :     }
; 1023 : 
; 1024 :     LinnumFini();

	call	LinnumFini

; 1025 : 
; 1026 :     if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	mov	rbx, QWORD PTR [rsp+32]
	jne	SHORT $LN12@OnePass

; 1027 :         PassOneChecks();

	call	PassOneChecks
$LN12@OnePass:

; 1028 : 
; 1029 :     ClearSrcStack();

	call	ClearSrcStack

; 1030 : 
; 1031 :     return( 1 );

	mov	eax, 1

; 1032 : }

	add	rsp, 40					; 00000028H
	ret	0
OnePass	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT PassOneChecks
_TEXT	SEGMENT
PassOneChecks PROC					; COMDAT

; 726  : {

	sub	rsp, 40					; 00000028H

; 727  :     struct dsym *curr;
; 728  :     struct dsym *next;
; 729  :     struct qnode *q;
; 730  :     struct qnode *qn;
; 731  : #ifdef DEBUG_OUT
; 732  :     int cntUnusedExt = 0;
; 733  : #endif
; 734  : 
; 735  :     /* check for open structures and segments has been done inside the
; 736  :      * END directive handling already
; 737  :      * v2.10: now done for PROCs as well, since procedures
; 738  :      * must be closed BEFORE segments are to be closed.
; 739  :      */
; 740  :     //ProcCheckOpen();
; 741  :     HllCheckOpen();

	call	HllCheckOpen

; 742  :     CondCheckOpen();

	call	CondCheckOpen

; 743  : 
; 744  :     if( ModuleInfo.EndDirFound == FALSE )

	test	BYTE PTR ModuleInfo+410, 1
	jne	SHORT $LN17@PassOneChe

; 745  :         EmitError( END_DIRECTIVE_REQUIRED );

	mov	ecx, 99					; 00000063H
	call	EmitError
$LN17@PassOneChe:

; 746  : 
; 747  : #ifdef DEBUG_OUT
; 748  :     for ( curr = SymTables[TAB_UNDEF].head; curr; curr = curr->next ) {
; 749  :         DebugMsg(("PassOneChecks: undefined symbol %s\n", curr->sym.name ));
; 750  :     }
; 751  : #endif
; 752  :     /* v2.04: check the publics queue.
; 753  :      * - only internal symbols can be public.
; 754  :      * - weak external symbols are filtered ( since v2.11 )
; 755  :      * - anything else is an error
; 756  :      * v2.11: moved here ( from inside the "#if FASTPASS"-block )
; 757  :      * because the loop will now filter weak externals [ this
; 758  :      * was previously done in GetPublicSymbols() ]
; 759  :      */
; 760  :     for( q = ModuleInfo.g.PubQueue.head, qn = (struct qnode *)&ModuleInfo.g.PubQueue ; q; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo+16
	lea	rcx, OFFSET FLAT:ModuleInfo+16
	test	rax, rax
	je	SHORT $LN3@PassOneChe
	npad	12
$LL4@PassOneChe:

; 761  : 
; 762  :         if ( q->sym->state == SYM_INTERNAL )

	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR [r8+32]
	cmp	edx, 1
	jne	SHORT $LN18@PassOneChe

; 763  :             qn = q;

	mov	rcx, rax
	jmp	SHORT $LN2@PassOneChe
$LN18@PassOneChe:

; 764  :         else if ( q->sym->state == SYM_EXTERNAL && q->sym->weak == TRUE ) {

	cmp	edx, 2
	jne	SHORT $LN20@PassOneChe
	test	BYTE PTR [r8+47], 8
	je	SHORT $LN20@PassOneChe

; 765  :             DebugMsg(("PassOneChecks: public for weak external skipped: %s\n", q->sym->name ));
; 766  :             qn->next = q->next;

	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 767  :             LclFree( q );
; 768  :             q = qn;

	mov	rax, rcx
$LN2@PassOneChe:

; 746  : 
; 747  : #ifdef DEBUG_OUT
; 748  :     for ( curr = SymTables[TAB_UNDEF].head; curr; curr = curr->next ) {
; 749  :         DebugMsg(("PassOneChecks: undefined symbol %s\n", curr->sym.name ));
; 750  :     }
; 751  : #endif
; 752  :     /* v2.04: check the publics queue.
; 753  :      * - only internal symbols can be public.
; 754  :      * - weak external symbols are filtered ( since v2.11 )
; 755  :      * - anything else is an error
; 756  :      * v2.11: moved here ( from inside the "#if FASTPASS"-block )
; 757  :      * because the loop will now filter weak externals [ this
; 758  :      * was previously done in GetPublicSymbols() ]
; 759  :      */
; 760  :     for( q = ModuleInfo.g.PubQueue.head, qn = (struct qnode *)&ModuleInfo.g.PubQueue ; q; q = q->next ) {

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL4@PassOneChe

; 824  :             /* check if symbol is external or public */
; 825  :             if ( sym == NULL ||

	jmp	SHORT $LN3@PassOneChe
$LN20@PassOneChe:

; 769  :         } else {
; 770  :             DebugMsg(("PassOneChecks: invalid public attribute for %s [state=%u weak=%u]\n", q->sym->name, q->sym->state, q->sym->weak ));
; 771  : #if FASTPASS
; 772  :             SkipSavedState();

	call	SkipSavedState
$LN3@PassOneChe:

; 773  : #endif
; 774  :             break;
; 775  :         }
; 776  :     }
; 777  : #if FASTPASS
; 778  :     if ( SymTables[TAB_UNDEF].head ) {
; 779  :         /* to force a full second pass in case of missing symbols,
; 780  :          * activate the next line. It was implemented to have proper
; 781  :          * error displays if a forward reference wasn't found.
; 782  :          * However, v1.95 final won't need this anymore, because both
; 783  :          * filename + lineno for every line is known now in pass 2.
; 784  :          */
; 785  :         /* SkipSavedState(); */
; 786  :     }
; 787  : 
; 788  :     /* check if there's an undefined segment reference.
; 789  :      * This segment was an argument to a group definition then.
; 790  :      * Just do a full second pass, the GROUP directive will report
; 791  :      * the error.
; 792  :      */
; 793  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rax, QWORD PTR SymTables+32
	test	rax, rax
	je	SHORT $LN6@PassOneChe
$LL7@PassOneChe:

; 794  :         if( curr->sym.segment == NULL ) {

	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN51@PassOneChe

; 773  : #endif
; 774  :             break;
; 775  :         }
; 776  :     }
; 777  : #if FASTPASS
; 778  :     if ( SymTables[TAB_UNDEF].head ) {
; 779  :         /* to force a full second pass in case of missing symbols,
; 780  :          * activate the next line. It was implemented to have proper
; 781  :          * error displays if a forward reference wasn't found.
; 782  :          * However, v1.95 final won't need this anymore, because both
; 783  :          * filename + lineno for every line is known now in pass 2.
; 784  :          */
; 785  :         /* SkipSavedState(); */
; 786  :     }
; 787  : 
; 788  :     /* check if there's an undefined segment reference.
; 789  :      * This segment was an argument to a group definition then.
; 790  :      * Just do a full second pass, the GROUP directive will report
; 791  :      * the error.
; 792  :      */
; 793  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rax, QWORD PTR [rax+104]
	test	rax, rax
	jne	SHORT $LL7@PassOneChe

; 824  :             /* check if symbol is external or public */
; 825  :             if ( sym == NULL ||

	jmp	SHORT $LN6@PassOneChe
$LN51@PassOneChe:

; 795  :             DebugMsg(("PassOneChecks: undefined segment %s\n", curr->sym.name ));
; 796  :             SkipSavedState();

	call	SkipSavedState
$LN6@PassOneChe:

; 797  :             break;
; 798  :         }
; 799  :     }
; 800  : #if COFF_SUPPORT
; 801  :     /* if there's an item in the safeseh list which is not an
; 802  :      * internal proc, make a full second pass to emit a proper
; 803  :      * error msg at the .SAFESEH directive
; 804  :      */
; 805  :     for ( q = ModuleInfo.g.SafeSEHQueue.head; q; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo+48
	test	rax, rax
	je	SHORT $LN9@PassOneChe
$LL10@PassOneChe:

; 806  :         if ( q->sym->state != SYM_INTERNAL || q->sym->isproc == FALSE ) {

	mov	rcx, QWORD PTR [rax+8]
	cmp	DWORD PTR [rcx+32], 1
	jne	SHORT $LN52@PassOneChe
	test	BYTE PTR [rcx+41], 8
	je	SHORT $LN52@PassOneChe

; 797  :             break;
; 798  :         }
; 799  :     }
; 800  : #if COFF_SUPPORT
; 801  :     /* if there's an item in the safeseh list which is not an
; 802  :      * internal proc, make a full second pass to emit a proper
; 803  :      * error msg at the .SAFESEH directive
; 804  :      */
; 805  :     for ( q = ModuleInfo.g.SafeSEHQueue.head; q; q = q->next ) {

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL10@PassOneChe

; 824  :             /* check if symbol is external or public */
; 825  :             if ( sym == NULL ||

	jmp	SHORT $LN9@PassOneChe
$LN52@PassOneChe:

; 807  :             SkipSavedState();

	call	SkipSavedState
$LN9@PassOneChe:
	mov	eax, DWORD PTR Options+144
	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	SHORT $LN12@PassOneChe

; 808  :             break;
; 809  :         }
; 810  :     }
; 811  : #endif
; 812  : 
; 813  :     /* scan ALIASes for COFF/ELF */
; 814  : 
; 815  : #if COFF_SUPPORT || ELF_SUPPORT
; 816  :     if ( Options.output_format == OFORMAT_COFF
; 817  : #if ELF_SUPPORT
; 818  :         || Options.output_format == OFORMAT_ELF
; 819  : #endif
; 820  :        ) {
; 821  :         for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {

	mov	rcx, QWORD PTR SymTables+80
	test	rcx, rcx
	je	SHORT $LN12@PassOneChe
	npad	2
$LL13@PassOneChe:

; 822  :             struct asym *sym;
; 823  :             sym = curr->sym.substitute;

	mov	rax, QWORD PTR [rcx+16]

; 824  :             /* check if symbol is external or public */
; 825  :             if ( sym == NULL ||

	test	rax, rax
	je	SHORT $LN53@PassOneChe
	mov	edx, DWORD PTR [rax+32]
	cmp	edx, 2
	je	SHORT $LN72@PassOneChe
	cmp	edx, 1
	jne	SHORT $LN53@PassOneChe
	test	BYTE PTR [rax+40], 128			; 00000080H
	je	SHORT $LN53@PassOneChe

; 829  :                 break;
; 830  :             }
; 831  :             /* make sure it becomes a strong external */
; 832  :             if ( sym->state == SYM_EXTERNAL )

	cmp	edx, 2
	jne	SHORT $LN11@PassOneChe
$LN72@PassOneChe:

; 833  :                 sym->used = TRUE;

	or	BYTE PTR [rax+40], 1
$LN11@PassOneChe:

; 808  :             break;
; 809  :         }
; 810  :     }
; 811  : #endif
; 812  : 
; 813  :     /* scan ALIASes for COFF/ELF */
; 814  : 
; 815  : #if COFF_SUPPORT || ELF_SUPPORT
; 816  :     if ( Options.output_format == OFORMAT_COFF
; 817  : #if ELF_SUPPORT
; 818  :         || Options.output_format == OFORMAT_ELF
; 819  : #endif
; 820  :        ) {
; 821  :         for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {

	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL13@PassOneChe

; 824  :             /* check if symbol is external or public */
; 825  :             if ( sym == NULL ||

	jmp	SHORT $LN12@PassOneChe
$LN53@PassOneChe:

; 826  :                 ( sym->state != SYM_EXTERNAL &&
; 827  :                  ( sym->state != SYM_INTERNAL || sym->ispublic == FALSE ))) {
; 828  :                 SkipSavedState();

	call	SkipSavedState
$LN12@PassOneChe:

; 834  :         }
; 835  :     }
; 836  : #endif
; 837  : 
; 838  : #endif /* FASTPASS */
; 839  : 
; 840  :     /* scan the EXTERN/EXTERNDEF items */
; 841  : 
; 842  :     for( curr = SymTables[TAB_EXT].head ; curr; curr = next ) {

	mov	rax, QWORD PTR SymTables+16
	test	rax, rax
	je	$LN15@PassOneChe
	mov	QWORD PTR [rsp+32], rbx
	npad	6
$LL16@PassOneChe:

; 843  :         next = curr->next;
; 844  :         /* v2.01: externdefs which have been "used" become "strong" */
; 845  :         if ( curr->sym.used )

	movzx	ecx, BYTE PTR [rax+40]
	mov	rbx, QWORD PTR [rax+104]
	test	cl, 1
	je	SHORT $LN32@PassOneChe

; 846  :             curr->sym.weak = FALSE;

	and	BYTE PTR [rax+47], 247			; 000000f7H
$LN32@PassOneChe:

; 847  :         /* remove unused EXTERNDEF/PROTO items from queue. */
; 848  :         if ( curr->sym.weak == TRUE
; 849  : #if DLLIMPORT
; 850  :             && curr->sym.iat_used == FALSE

	movzx	edx, BYTE PTR [rax+47]
	test	dl, 8
	je	SHORT $LN33@PassOneChe
	test	cl, 8
	jne	SHORT $LN33@PassOneChe

; 851  : #endif
; 852  :            ) {
; 853  :             sym_remove_table( &SymTables[TAB_EXT], curr );

	mov	rdx, rax
	lea	rcx, OFFSET FLAT:SymTables+16
	call	sym_remove_table

; 854  : #ifdef DEBUG_OUT
; 855  :             cntUnusedExt++;
; 856  : #endif
; 857  :             continue;

	jmp	SHORT $LN14@PassOneChe
$LN33@PassOneChe:

; 858  :         }
; 859  : 
; 860  : #if FASTMEM==0
; 861  :         /* v2.05: clear fixup list (used for backpatching in pass one) */
; 862  :         if ( curr->sym.bp_fixup ) {
; 863  :             struct fixup *c;
; 864  :             struct fixup *n;
; 865  :             for( c = curr->sym.bp_fixup ; c; ) {
; 866  :                 n = c->nextbp;
; 867  :                 LclFree( c );
; 868  :                 c = n;
; 869  :             }
; 870  :             curr->sym.bp_fixup = NULL;
; 871  :         }
; 872  : #endif
; 873  : 
; 874  :         if ( curr->sym.iscomm == TRUE )

	test	dl, 4
	jne	SHORT $LN14@PassOneChe

; 875  :             continue;
; 876  :         /* optional alternate symbol must be INTERNAL or EXTERNAL.
; 877  :          * COFF ( and ELF? ) also wants internal symbols to be public
; 878  :          * ( which is reasonable, since the linker won't know private
; 879  :          * symbols and hence will search for a symbol of that name
; 880  :          * "elsewhere" ).
; 881  :          */
; 882  : #if FASTPASS
; 883  :         if ( curr->sym.altname ) {

	mov	rcx, QWORD PTR [rax+64]
	test	rcx, rcx
	je	SHORT $LN14@PassOneChe

; 884  :             if ( curr->sym.altname->state == SYM_INTERNAL ) {

	mov	eax, DWORD PTR [rcx+32]
	cmp	eax, 1
	jne	SHORT $LN36@PassOneChe

; 885  : #if COFF_SUPPORT || ELF_SUPPORT
; 886  :                 /* for COFF/ELF, the altname must be public or external */
; 887  :                 if ( curr->sym.altname->ispublic == FALSE &&

	test	BYTE PTR [rcx+40], 128			; 00000080H
	jne	SHORT $LN14@PassOneChe
	mov	eax, DWORD PTR Options+144
	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	SHORT $LN14@PassOneChe

; 888  :                     ( Options.output_format == OFORMAT_COFF
; 889  : #if ELF_SUPPORT
; 890  :                      || Options.output_format == OFORMAT_ELF
; 891  : #endif
; 892  :                     ) ) {
; 893  :                     SkipSavedState();
; 894  :                 }

	jmp	SHORT $LN73@PassOneChe
$LN36@PassOneChe:

; 895  : #endif
; 896  :             } else if ( curr->sym.altname->state != SYM_EXTERNAL ) {

	cmp	eax, 2
	je	SHORT $LN14@PassOneChe
$LN73@PassOneChe:

; 897  :                 /* do not use saved state, scan full source in second pass */
; 898  :                 SkipSavedState();

	call	SkipSavedState
$LN14@PassOneChe:

; 834  :         }
; 835  :     }
; 836  : #endif
; 837  : 
; 838  : #endif /* FASTPASS */
; 839  : 
; 840  :     /* scan the EXTERN/EXTERNDEF items */
; 841  : 
; 842  :     for( curr = SymTables[TAB_EXT].head ; curr; curr = next ) {

	mov	rax, rbx
	test	rbx, rbx
	jne	SHORT $LL16@PassOneChe
	mov	rbx, QWORD PTR [rsp+32]
$LN15@PassOneChe:

; 899  :             }
; 900  :         }
; 901  : #endif
; 902  :     }
; 903  : 
; 904  : #ifdef DEBUG_OUT
; 905  :     DebugMsg(("PassOneChecks: removed unused externals: %u\n", cntUnusedExt ));
; 906  :     DebugMsg(("PassOneChecks: forward references:\n"));
; 907  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {
; 908  :         int i;
; 909  :         int j;
; 910  :         struct asym * sym;
; 911  :         struct fixup * fix;
; 912  :         for ( i = 0, j = 0, sym = curr->e.seginfo->label_list; sym; sym = (struct asym *)((struct dsym *)sym)->next ) {
; 913  :             i++;
; 914  :             for ( fix = sym->bp_fixup; fix ; fix = fix->nextbp, j++ );
; 915  :         }
; 916  :         DebugMsg(("PassOneChecks: segm=%s, labels=%u forward refs=%u\n", curr->sym.name, i, j));
; 917  :     }
; 918  : #endif
; 919  : 
; 920  :     if ( ModuleInfo.g.error_count == 0 ) {

	cmp	DWORD PTR ModuleInfo, 0
	jne	SHORT $LN44@PassOneChe

; 921  : 
; 922  :         /* make all symbols of type SYM_INTERNAL, which aren't
; 923  :          a constant, public.  */
; 924  :         if ( Options.all_symbols_public )

	cmp	BYTE PTR Options+138, 0
	je	SHORT $LN42@PassOneChe

; 925  :             SymMakeAllSymbolsPublic();

	call	SymMakeAllSymbolsPublic
$LN42@PassOneChe:

; 926  : 
; 927  :         if ( Options.syntax_check_only == FALSE )

	movzx	eax, BYTE PTR write_to_file
	mov	ecx, 1
	cmp	BYTE PTR Options+172, 0
	cmove	eax, ecx
	mov	BYTE PTR write_to_file, al

; 928  :             write_to_file = TRUE;
; 929  : 
; 930  :         if ( ModuleInfo.g.Pass1Checks )

	mov	rax, QWORD PTR ModuleInfo+304
	test	rax, rax
	je	SHORT $LN44@PassOneChe

; 931  :             ModuleInfo.g.Pass1Checks( &ModuleInfo );

	lea	rcx, OFFSET FLAT:ModuleInfo

; 932  :     }
; 933  : 
; 934  : 
; 935  :     return;
; 936  : }

	add	rsp, 40					; 00000028H

; 931  :             ModuleInfo.g.Pass1Checks( &ModuleInfo );

	rex_jmp	rax
$LN44@PassOneChe:

; 932  :     }
; 933  : 
; 934  : 
; 935  :     return;
; 936  : }

	add	rsp, 40					; 00000028H
	ret	0
PassOneChecks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT ModulePassInit
_TEXT	SEGMENT
ModulePassInit PROC					; COMDAT

; 602  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 603  :     enum cpu_info cpu = Options.cpu;
; 604  :     enum model_type model = Options.model;
; 605  : #if DLLIMPORT
; 606  :     struct dsym *curr;
; 607  : #endif
; 608  : 
; 609  :     DebugMsg(( "ModulePassInit() enter\n" ));
; 610  :     /* set default values not affected by the masm 5.1 compat switch */
; 611  :     ModuleInfo.procs_private = FALSE;
; 612  :     ModuleInfo.procs_export = FALSE;

	mov	edx, DWORD PTR ModuleInfo+408
	mov	ecx, DWORD PTR Options+164
	and	edx, -13				; fffffff3H
	mov	ebx, DWORD PTR Options+160

; 613  :     ModuleInfo.offsettype = OT_GROUP;
; 614  :     ModuleInfo.scoped = TRUE;

	bts	edx, 7

; 615  : 
; 616  : 
; 617  : #if FASTPASS
; 618  :     /* v2.03: don't generate the code if fastpass is active */
; 619  :     /* v2.08: query UseSavedState instead of StoreState */
; 620  :     //if ( StoreState == FALSE ) {
; 621  :     if ( UseSavedState == FALSE ) {

	cmp	BYTE PTR UseSavedState, 0
	mov	DWORD PTR ModuleInfo+384, 0
	mov	DWORD PTR ModuleInfo+408, edx
	jne	$LN11@ModulePass

; 622  : #endif
; 623  :         ModuleInfo.langtype = Options.langtype;
; 624  :         ModuleInfo.fctype = Options.fctype;
; 625  : #if AMD64_SUPPORT
; 626  :         if ( ModuleInfo.sub_format == SFORMAT_64BIT ) {

	cmp	DWORD PTR ModuleInfo+372, 3
	mov	edx, DWORD PTR Options+156
	mov	eax, DWORD PTR Options+168
	mov	DWORD PTR ModuleInfo+364, edx
	mov	DWORD PTR ModuleInfo+376, eax
	jne	SHORT $LN6@ModulePass

; 627  :             /* v2.06: force cpu to be at least P_64, without side effect to Options.cpu */
; 628  :             if ( ( cpu &  P_CPU_MASK ) < P_64 ) /* enforce cpu to be 64-bit */

	mov	r8d, 112				; 00000070H
	mov	eax, ecx
	and	eax, 240				; 000000f0H
	cmp	eax, r8d
	cmovl	ecx, r8d

; 629  :                 cpu = P_64;
; 630  :             /* ignore -m switch for 64-bit formats.
; 631  :              * there's no other model than FLAT possible.
; 632  :              */
; 633  :             model = MODEL_FLAT;

	lea	ebx, QWORD PTR [r8-105]

; 634  :             if ( ModuleInfo.langtype == LANG_NONE && Options.output_format == OFORMAT_COFF )

	test	edx, edx
	jne	SHORT $LN10@ModulePass
	cmp	DWORD PTR Options+144, 2
	jne	SHORT $LN10@ModulePass

; 635  :                 ModuleInfo.langtype = LANG_FASTCALL;

	mov	DWORD PTR ModuleInfo+364, ebx

; 636  :         } else

	jmp	SHORT $LN10@ModulePass
$LN6@ModulePass:

; 637  : #endif
; 638  :             /* if model FLAT is to be set, ensure that cpu is compat. */
; 639  :             if ( model == MODEL_FLAT && ( cpu & P_CPU_MASK ) < P_386 ) /* cpu < 386? */

	cmp	ebx, 7
	jne	SHORT $LN10@ModulePass
	mov	eax, ecx
	mov	edx, 48					; 00000030H
	and	eax, 240				; 000000f0H
	cmp	eax, edx
	cmovl	ecx, edx
$LN10@ModulePass:

; 640  :                 cpu = P_386;
; 641  : 
; 642  :         SetCPU( cpu );

	call	SetCPU

; 643  :         /* table ModelToken starts with MODEL_TINY, which is index 1" */
; 644  :         if ( model != MODEL_NONE )

	test	ebx, ebx
	je	SHORT $LN23@ModulePass

; 645  :             AddLineQueueX( "%r %s", T_DOT_MODEL, ModelToken[model - 1] );

	lea	rax, OFFSET FLAT:ModelToken
	movsxd	r8, ebx
	mov	edx, 342				; 00000156H
	lea	rcx, OFFSET FLAT:$SG11909
	mov	r8, QWORD PTR [rax+r8*8-8]
	call	AddLineQueueX
$LN23@ModulePass:
	mov	edx, DWORD PTR ModuleInfo+408
$LN11@ModulePass:

; 646  : 
; 647  : #if FASTPASS
; 648  :     }
; 649  : #endif
; 650  : 
; 651  :     SetMasm510( Options.masm51_compat );

	movzx	ecx, BYTE PTR Options+126
	and	edx, -1361				; fffffaafH
	mov	eax, ecx
	and	eax, 1
	lea	r8d, DWORD PTR [rax*4]
	or	r8d, eax
	shl	r8d, 2
	or	r8d, eax
	shl	r8d, 2
	or	r8d, eax
	shl	r8d, 4
	or	r8d, edx
	test	cl, cl
	je	SHORT $LN17@ModulePass
	cmp	DWORD PTR ModuleInfo+360, 0
	jne	SHORT $LN17@ModulePass
	cmp	DWORD PTR ModuleInfo+364, 0
	mov	DWORD PTR ModuleInfo+384, 2
	jne	SHORT $LN17@ModulePass
	btr	r8d, 7
	or	r8d, 4
$LN17@ModulePass:

; 652  :     ModuleInfo.defOfssize = USE16;
; 653  :     ModuleInfo.ljmp     = TRUE;
; 654  : 
; 655  :     ModuleInfo.list   = Options.write_listing;
; 656  :     ModuleInfo.cref   = TRUE;
; 657  :     ModuleInfo.listif = Options.listif;
; 658  :     ModuleInfo.list_generated_code = Options.list_generated_code;

	movzx	edx, BYTE PTR Options+131
	and	r8d, -26625				; ffff97ffH
	movzx	eax, BYTE PTR Options+130
	and	edx, 1

; 659  :     ModuleInfo.list_macro = Options.list_macro;
; 660  : 
; 661  :     ModuleInfo.case_sensitive = Options.case_sensitive;
; 662  :     ModuleInfo.convert_uppercase = Options.convert_uppercase;

	movzx	ecx, BYTE PTR Options+124
	add	edx, edx
	and	eax, 1
	mov	BYTE PTR ModuleInfo+405, 0
	or	edx, eax
	and	ecx, 1
	movzx	eax, BYTE PTR Options+121
	add	ecx, ecx
	shl	edx, 2
	and	eax, 1
	or	edx, eax
	mov	eax, DWORD PTR Options+132
	shl	edx, 11
	mov	DWORD PTR ModuleInfo+400, eax
	or	edx, r8d
	movzx	eax, BYTE PTR Options+123
	or	edx, 4128				; 00001020H
	and	eax, 1
	and	edx, -4					; fffffffcH
	or	ecx, eax
	or	ecx, edx
	mov	DWORD PTR ModuleInfo+408, ecx

; 663  :     SymSetCmpFunc();

	call	SymSetCmpFunc

; 664  : 
; 665  :     ModuleInfo.segorder = SEGORDER_SEQ;
; 666  :     ModuleInfo.radix = 10;
; 667  :     ModuleInfo.fieldalign = Options.fieldalign;
; 668  : #if PROCALIGN
; 669  :     ModuleInfo.procalign = 0;
; 670  : #endif
; 671  : #if DLLIMPORT
; 672  :     /* if OPTION DLLIMPORT was used, reset all iat_used flags */
; 673  :     if ( ModuleInfo.g.DllQueue )

	cmp	QWORD PTR ModuleInfo+80, 0
	movzx	eax, BYTE PTR Options+152
	mov	BYTE PTR ModuleInfo+397, al
	mov	DWORD PTR ModuleInfo+380, 0
	mov	BYTE PTR ModuleInfo+396, 10
	mov	BYTE PTR ModuleInfo+399, 0
	je	SHORT $LN3@ModulePass

; 674  :         for ( curr = SymTables[TAB_EXT].head; curr; curr = curr->next )

	mov	rax, QWORD PTR SymTables+16
	test	rax, rax
	je	SHORT $LN3@ModulePass
	npad	6
$LL4@ModulePass:

; 675  :             curr->sym.iat_used = FALSE;

	and	BYTE PTR [rax+40], 247			; 000000f7H
	mov	rax, QWORD PTR [rax+104]
	test	rax, rax
	jne	SHORT $LL4@ModulePass
$LN3@ModulePass:

; 676  : #endif
; 677  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ModulePassInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT CmdlParamsInit
_TEXT	SEGMENT
pass$ = 48
CmdlParamsInit PROC					; COMDAT

; 482  : {

	sub	rsp, 40					; 00000028H

; 483  :     DebugMsg(("CmdlParamsInit(%u) enter\n", pass));
; 484  : 
; 485  : #if BUILD_TARGET
; 486  :     if ( pass == PASS_1 ) {
; 487  :         struct asym *sym;
; 488  :         char *tmp;
; 489  :         char *p;
; 490  : 
; 491  :         _strupr( Options.build_target );
; 492  :         tmp = myalloca( strlen( Options.build_target ) + 5 ); /* null + 4 uscores */
; 493  :         strcpy( tmp, uscores );
; 494  :         strcat( tmp, Options.build_target );
; 495  :         strcat( tmp, uscores );
; 496  : 
; 497  :         /* define target */
; 498  :         sym = CreateVariable( tmp, 0 );
; 499  :         sym->predefined = TRUE;
; 500  : 
; 501  :         p = NULL;
; 502  :         if( _stricmp( Options.build_target, "DOS" ) == 0 ) {
; 503  :             p = "__MSDOS__";
; 504  :         } else if( _stricmp( Options.build_target, "NETWARE" ) == 0 ) {
; 505  :             if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {
; 506  :                 p = "__NETWARE_386__";
; 507  :             } else {
; 508  :                 /* do nothing ... __NETWARE__ already defined */
; 509  :             }
; 510  :         } else if( _stricmp( Options.build_target, "WINDOWS" ) == 0 ) {
; 511  :             if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {
; 512  :                 p = "__WINDOWS_386__";
; 513  :             } else {
; 514  :                 /* do nothing ... __WINDOWS__ already defined */
; 515  :             }
; 516  :         } else if( _stricmp( Options.build_target, "QNX" ) == 0 ) {
; 517  :             p = "__UNIX__";
; 518  :         } else if( _stricmp( Options.build_target, "LINUX" ) == 0 ) {
; 519  :             p = "__UNIX__";
; 520  :         }
; 521  :         if ( p ) {
; 522  :             sym = CreateVariable( p, 0 );
; 523  :             sym->predefined = TRUE;
; 524  :         }
; 525  :     }
; 526  : #endif
; 527  : 
; 528  :     if ( pass == PASS_1 ) {

	test	ecx, ecx
	jne	SHORT $LN4@CmdlParams

; 529  :         char *env;
; 530  :         /* v2.06: this is done in ModulePassInit now */
; 531  :         //SetCPU( Options.cpu );
; 532  :         add_cmdline_tmacros();

	mov	QWORD PTR [rsp+32], rbx
	call	add_cmdline_tmacros

; 533  :         add_incpaths();

	mov	rbx, QWORD PTR Options+104
	test	rbx, rbx
	je	SHORT $LN8@CmdlParams
	npad	2
$LL9@CmdlParams:
	lea	rcx, QWORD PTR [rbx+8]
	call	AddStringToIncludePath
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL9@CmdlParams
$LN8@CmdlParams:

; 534  :         if ( Options.ignore_include == FALSE )

	cmp	BYTE PTR Options+140, 0
	mov	rbx, QWORD PTR [rsp+32]
	jne	SHORT $LN4@CmdlParams

; 535  :             if ( env = getenv( "INCLUDE" ) )

	lea	rcx, OFFSET FLAT:$SG11872
	call	getenv
	test	rax, rax
	je	SHORT $LN4@CmdlParams

; 536  :                 AddStringToIncludePath( env );

	mov	rcx, rax

; 537  :     }
; 538  :     DebugMsg(("CmdlParamsInit exit\n"));
; 539  :     return;
; 540  : }

	add	rsp, 40					; 00000028H

; 536  :                 AddStringToIncludePath( env );

	jmp	AddStringToIncludePath
$LN4@CmdlParams:

; 537  :     }
; 538  :     DebugMsg(("CmdlParamsInit exit\n"));
; 539  :     return;
; 540  : }

	add	rsp, 40					; 00000028H
	ret	0
CmdlParamsInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT add_incpaths
_TEXT	SEGMENT
add_incpaths PROC					; COMDAT

; 469  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 470  :     struct qitem *p;
; 471  :     DebugMsg(("add_incpaths: enter\n"));
; 472  :     for ( p = Options.queues[OPTQ_INCPATH]; p; p = p->next ) {

	mov	rbx, QWORD PTR Options+104
	test	rbx, rbx
	je	SHORT $LN3@add_incpat
$LL4@add_incpat:

; 473  :         AddStringToIncludePath( p->value );

	lea	rcx, QWORD PTR [rbx+8]
	call	AddStringToIncludePath
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL4@add_incpat
$LN3@add_incpat:

; 474  :     }
; 475  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
add_incpaths ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT add_cmdline_tmacros
_TEXT	SEGMENT
add_cmdline_tmacros PROC				; COMDAT

; 419  : {

	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	lea	rbp, QWORD PTR [rsp+32]

; 420  :     struct qitem *p;
; 421  :     char *name;
; 422  :     char *value;
; 423  :     int len;
; 424  :     struct asym *sym;
; 425  : 
; 426  :     DebugMsg(("add_cmdline_tmacros enter\n"));
; 427  :     for ( p = Options.queues[OPTQ_MACRO]; p; p = p->next ) {

	mov	r15, QWORD PTR Options+96
	mov	QWORD PTR [rbp+48], rbx
	mov	QWORD PTR [rbp+56], rsi
	mov	QWORD PTR [rbp+64], rdi
	test	r15, r15
	je	$LN3@add_cmdlin
	mov	rbx, 576460752706077697			; 0800000018000401H
	mov	r13, 1152921504606846960		; 0ffffffffffffff0H
	mov	r12, 576460752706076673			; 0800000018000001H
	npad	3
$LL4@add_cmdlin:

; 428  :         DebugMsg(("add_cmdline_tmacros: found >%s<\n", p->value));
; 429  :         name = p->value;

	lea	r14, QWORD PTR [r15+8]

; 430  :         value = strchr( name, '=' );

	mov	edx, 61					; 0000003dH
	mov	rcx, r14
	mov	rsi, r14
	call	strchr
	mov	rdi, rax

; 431  :         if( value == NULL ) {

	test	rax, rax
	jne	SHORT $LN5@add_cmdlin

; 432  :             /* v2.06: ensure that 'value' doesn't point to r/o space */
; 433  :             //value = "";
; 434  :             value = name + strlen( name ); /* use the terminating NULL */

	or	rdi, -1
$LL42@add_cmdlin:
	inc	rdi
	cmp	BYTE PTR [r14+rdi], 0
	jne	SHORT $LL42@add_cmdlin
	add	rdi, r14

; 435  :         } else {

	jmp	SHORT $LN6@add_cmdlin
$LN5@add_cmdlin:

; 436  :             len = value - name;

	mov	r8d, eax
	sub	r8d, r14d

; 437  :             name = (char *)myalloca( len + 1 );

	lea	eax, DWORD PTR [r8+1]
	movsxd	rcx, eax
	lea	rax, QWORD PTR [rcx+15]
	cmp	rax, rcx
	ja	SHORT $LN41@add_cmdlin
	mov	rax, r13
$LN41@add_cmdlin:
	and	rax, -16
	call	__chkstk
	sub	rsp, rax

; 438  :             memcpy( name, p->value, len );

	movsxd	rbx, r8d
	mov	r8, rbx
	mov	rdx, r14
	lea	rsi, QWORD PTR [rsp+32]
	mov	rcx, rsi
	call	memcpy

; 439  :             *(name + len) = NULLC;

	mov	BYTE PTR [rbx+rsi], 0

; 440  :             value++;

	inc	rdi
	mov	rbx, 576460752706077697			; 0800000018000401H
$LN6@add_cmdlin:

; 441  :         }
; 442  : 
; 443  :         /* there's no check whether the name is a reserved word!
; 444  :          */
; 445  :         if( is_valid_identifier( name ) == ERROR ) {

	movsx	ecx, BYTE PTR [rsi]
	call	isalpha
	test	eax, eax
	jne	SHORT $LN17@add_cmdlin
	movzx	eax, BYTE PTR [rsi]
	sub	al, 36					; 00000024H
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN35@add_cmdlin
	movsx	rax, al
	bt	rbx, rax
	jae	SHORT $LN35@add_cmdlin
$LN17@add_cmdlin:
	movzx	eax, BYTE PTR [rsi+1]
	lea	rbx, QWORD PTR [rsi+1]
	test	al, al
	je	SHORT $LN15@add_cmdlin
$LL16@add_cmdlin:
	movsx	ecx, al
	call	isalnum
	test	eax, eax
	jne	SHORT $LN23@add_cmdlin
	movzx	eax, BYTE PTR [rbx]
	sub	al, 36					; 00000024H
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN35@add_cmdlin
	bt	r12, rax
	jae	SHORT $LN35@add_cmdlin
$LN23@add_cmdlin:
	movzx	eax, BYTE PTR [rbx+1]
	inc	rbx
	test	al, al
	jne	SHORT $LL16@add_cmdlin
$LN15@add_cmdlin:
	cmp	BYTE PTR [rbx-1], 46			; 0000002eH
	jne	SHORT $LN7@add_cmdlin
$LN35@add_cmdlin:

; 446  :             DebugMsg(("add_cmdline_tmacros: name >%s< invalid\n", name ));
; 447  :             EmitErr( SYNTAX_ERROR_EX, name );

	mov	ecx, 209				; 000000d1H

; 448  :         } else {

	jmp	SHORT $LN43@add_cmdlin
$LN7@add_cmdlin:

; 449  :             sym = SymSearch( name );

	mov	rcx, rsi
	call	SymFind

; 450  :             if ( sym == NULL ) {

	test	rax, rax
	jne	SHORT $LN9@add_cmdlin

; 451  :                 sym = SymCreate( name );

	mov	rcx, rsi
	call	SymCreate

; 452  :                 sym->state = SYM_TMACRO;

	mov	DWORD PTR [rax+32], 10
$LN9@add_cmdlin:

; 453  :             }
; 454  :             if ( sym->state == SYM_TMACRO ) {

	cmp	DWORD PTR [rax+32], 10
	jne	SHORT $LN10@add_cmdlin

; 455  :                 sym->isdefined = TRUE;
; 456  :                 sym->predefined = TRUE;

	or	BYTE PTR [rax+40], 34			; 00000022H

; 457  :                 sym->string_ptr = value;

	mov	QWORD PTR [rax+16], rdi

; 458  :             } else

	jmp	SHORT $LN2@add_cmdlin
$LN10@add_cmdlin:

; 459  :                 EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	ecx, 56					; 00000038H
$LN43@add_cmdlin:
	mov	rdx, rsi
	call	EmitErr
$LN2@add_cmdlin:

; 420  :     struct qitem *p;
; 421  :     char *name;
; 422  :     char *value;
; 423  :     int len;
; 424  :     struct asym *sym;
; 425  : 
; 426  :     DebugMsg(("add_cmdline_tmacros enter\n"));
; 427  :     for ( p = Options.queues[OPTQ_MACRO]; p; p = p->next ) {

	mov	r15, QWORD PTR [r15]
	mov	rbx, 576460752706077697			; 0800000018000401H
	test	r15, r15
	jne	$LL4@add_cmdlin
$LN3@add_cmdlin:

; 460  :         }
; 461  :     }
; 462  :     return;
; 463  : }

	mov	rbx, QWORD PTR [rbp+48]
	mov	rsi, QWORD PTR [rbp+56]
	mov	rdi, QWORD PTR [rbp+64]
	mov	rsp, rbp
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
add_cmdline_tmacros ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT is_valid_identifier
_TEXT	SEGMENT
id$ = 48
is_valid_identifier PROC				; COMDAT

; 397  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 398  :     /* special handling of first char of an id: it can't be a digit,
; 399  :      but can be a dot (don't care about ModuleInfo.dotname!). */
; 400  : 
; 401  :     if( is_valid_first_char( *id ) == 0 )

	movsx	ecx, BYTE PTR [rcx]
	call	isalpha
	test	eax, eax
	jne	SHORT $LN5@is_valid_i
	movzx	eax, BYTE PTR [rbx]
	sub	al, 36					; 00000024H
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN18@is_valid_i
	movsx	rax, al
	mov	rcx, 576460752706077697			; 0800000018000401H
	bt	rcx, rax
	jb	SHORT $LN5@is_valid_i
$LN18@is_valid_i:

; 402  :         return( ERROR );

	or	eax, -1

; 410  :         return( ERROR );
; 411  : 
; 412  :     return( NOT_ERROR );
; 413  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@is_valid_i:

; 403  :     id++;
; 404  :     for( ; *id != NULLC; id++ ) {

	movzx	eax, BYTE PTR [rbx+1]
	inc	rbx
	mov	QWORD PTR [rsp+48], rdi
	test	al, al
	je	SHORT $LN3@is_valid_i
	mov	rdi, 576460752706076673			; 0800000018000001H
$LL4@is_valid_i:

; 405  :         if ( is_valid_id_char( *id ) == FALSE )

	movsx	ecx, al
	call	isalnum
	test	eax, eax
	jne	SHORT $LN11@is_valid_i
	movzx	eax, BYTE PTR [rbx]
	sub	al, 36					; 00000024H
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN14@is_valid_i
	movsx	rax, al
	bt	rdi, rax
	jae	SHORT $LN14@is_valid_i
$LN11@is_valid_i:

; 403  :     id++;
; 404  :     for( ; *id != NULLC; id++ ) {

	movzx	eax, BYTE PTR [rbx+1]
	inc	rbx
	test	al, al
	jne	SHORT $LL4@is_valid_i
$LN3@is_valid_i:
	mov	rdi, QWORD PTR [rsp+48]

; 407  :     }
; 408  :     /* don't allow a single dot! */
; 409  :     if ( *(id-1) == '.' )

	xor	eax, eax
	cmp	BYTE PTR [rbx-1], 46			; 0000002eH
	setne	al
	dec	eax

; 410  :         return( ERROR );
; 411  : 
; 412  :     return( NOT_ERROR );
; 413  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN14@is_valid_i:

; 406  :             return( ERROR );

	or	eax, -1
	mov	rdi, QWORD PTR [rsp+48]

; 410  :         return( ERROR );
; 411  : 
; 412  :     return( NOT_ERROR );
; 413  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
is_valid_identifier ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
;	COMDAT WriteModule
_TEXT	SEGMENT
modinfo$ = 64
WriteModule PROC					; COMDAT

; 347  : {

	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 348  :     struct dsym *curr;
; 349  : 
; 350  :     DebugMsg(("WriteModule enter\n"));
; 351  : 
; 352  :     /* final checks */
; 353  :     /* check limit of segments */
; 354  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	mov	rdi, rcx
	test	rbx, rbx
	je	SHORT $LN3@WriteModul
	npad	7
$LL4@WriteModul:

; 355  :         if ( curr->e.seginfo->Ofssize == USE16 && curr->sym.max_offset > 0x10000 ) {

	mov	rax, QWORD PTR [rbx+96]
	cmp	BYTE PTR [rax+104], 0
	jne	SHORT $LN2@WriteModul
	cmp	DWORD PTR [rbx+56], 65536		; 00010000H
	jle	SHORT $LN2@WriteModul

; 356  :             if ( Options.output_format == OFORMAT_OMF )

	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN9@WriteModul

; 357  :                 EmitErr( SEGMENT_EXCEEDS_64K_LIMIT, curr->sym.name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 222				; 000000deH
	call	EmitErr
	jmp	SHORT $LN2@WriteModul
$LN9@WriteModul:

; 358  :             else
; 359  :                 EmitWarn( 2, SEGMENT_EXCEEDS_64K_LIMIT, curr->sym.name );

	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 222				; 000000deH
	mov	ecx, 2
	call	EmitWarn
$LN2@WriteModul:

; 348  :     struct dsym *curr;
; 349  : 
; 350  :     DebugMsg(("WriteModule enter\n"));
; 351  : 
; 352  :     /* final checks */
; 353  :     /* check limit of segments */
; 354  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	SHORT $LL4@WriteModul
$LN3@WriteModul:

; 360  :         }
; 361  :     }
; 362  : 
; 363  :     modinfo->g.WriteModule( modinfo );

	mov	rcx, rdi
	mov	QWORD PTR [rsp+64], rsi
	call	QWORD PTR [rdi+288]

; 364  : 
; 365  : #if DLLIMPORT
; 366  :     /* is the -Fd option given with a file name? */
; 367  :     if ( Options.names[OPTN_LNKDEF_FN] ) {

	mov	rcx, QWORD PTR Options+48
	test	rcx, rcx
	je	$LN11@WriteModul

; 368  :         FILE *ld;
; 369  :         ld = fopen( Options.names[OPTN_LNKDEF_FN], "w" );

	lea	rdx, OFFSET FLAT:$SG11820
	call	fopen
	mov	rsi, rax

; 370  :         if ( ld == NULL ) {

	test	rax, rax
	jne	SHORT $LN12@WriteModul

; 371  :             return( EmitErr( CANNOT_OPEN_FILE, Options.names[OPTN_LNKDEF_FN], ErrnoStr() ) );

	call	ErrnoStr
	mov	rdx, QWORD PTR Options+48
	lea	ecx, QWORD PTR [rsi+106]
	mov	r8, rax
	mov	rsi, QWORD PTR [rsp+64]

; 389  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi

; 371  :             return( EmitErr( CANNOT_OPEN_FILE, Options.names[OPTN_LNKDEF_FN], ErrnoStr() ) );

	jmp	EmitErr
$LN12@WriteModul:

; 372  :         }
; 373  :         for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+16
	test	rbx, rbx
	je	$LN6@WriteModul
$LL7@WriteModul:

; 374  :             DebugMsg(("WriteModule: ext=%s, isproc=%u, weak=%u\n", curr->sym.name, curr->sym.isproc, curr->sym.weak ));
; 375  :             if ( curr->sym.isproc && ( curr->sym.weak == FALSE || curr->sym.iat_used ) &&
; 376  :                 curr->sym.dll && *(curr->sym.dll->name) != NULLC ) {

	test	BYTE PTR [rbx+41], 8
	je	SHORT $LN5@WriteModul
	test	BYTE PTR [rbx+47], 8
	je	SHORT $LN14@WriteModul
	test	BYTE PTR [rbx+40], 8
	je	SHORT $LN5@WriteModul
$LN14@WriteModul:
	mov	rax, QWORD PTR [rbx+56]
	test	rax, rax
	je	SHORT $LN5@WriteModul
	cmp	BYTE PTR [rax+12], 0
	je	SHORT $LN5@WriteModul

; 377  :                 int size;
; 378  :                 Mangle( &curr->sym, StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, rbx
	call	Mangle

; 379  :                 size = sprintf( CurrSource, "import '%s'  %s.%s\n", StringBufferEnd, curr->sym.dll->name, curr->sym.name );

	mov	r9, QWORD PTR [rbx+56]
	lea	rdx, OFFSET FLAT:$SG11824
	mov	rax, QWORD PTR [rbx+8]
	add	r9, 12
	mov	r8, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR ModuleInfo+464
	mov	QWORD PTR [rsp+32], rax
	call	sprintf

; 380  :                 if ( fwrite( CurrSource, 1, size, ld ) != size )

	mov	rcx, QWORD PTR ModuleInfo+464
	mov	r9, rsi
	movsxd	rdi, eax
	mov	edx, 1
	mov	r8, rdi
	call	fwrite
	cmp	rax, rdi
	je	SHORT $LN5@WriteModul

; 381  :                     WriteError();

	call	WriteError
$LN5@WriteModul:

; 372  :         }
; 373  :         for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	$LL7@WriteModul
$LN6@WriteModul:

; 382  :             }
; 383  :         }
; 384  :         fclose( ld );

	mov	rcx, rsi
	call	fclose
$LN11@WriteModul:

; 385  :     }
; 386  : #endif
; 387  :     DebugMsg(("WriteModule exit\n"));
; 388  :     return( NOT_ERROR );

	mov	rsi, QWORD PTR [rsp+64]
	xor	eax, eax

; 389  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
WriteModule ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
seg$ = 48
value$ = 56
relative$ = 64
select_data$ = 72
SetCurrOffset PROC

; 299  : {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	movzx	esi, r9b
	mov	edi, edx
	mov	rbx, rcx

; 300  :     if( relative )

	test	r8b, r8b
	je	SHORT $LN2@SetCurrOff

; 301  :         value += seg->e.seginfo->current_loc;

	mov	rax, QWORD PTR [rcx+96]
	add	edi, DWORD PTR [rax+12]
$LN2@SetCurrOff:

; 302  : 
; 303  :     if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN3@SetCurrOff

; 304  :         if ( seg == CurrSeg ) {

	cmp	rcx, QWORD PTR ModuleInfo+432
	jne	SHORT $LN5@SetCurrOff

; 305  :             if ( write_to_file == TRUE )

	cmp	BYTE PTR write_to_file, 1
	jne	SHORT $LN6@SetCurrOff

; 306  :                 omf_FlushCurrSeg();

	call	omf_FlushCurrSeg
$LN6@SetCurrOff:

; 307  : 
; 308  :         /* for debugging, tell if data is located in code sections*/
; 309  :             if( select_data )

	test	sil, sil
	je	SHORT $LN8@SetCurrOff

; 310  :                 if ( ModuleInfo.CommentDataInCode )

	cmp	BYTE PTR ModuleInfo+423, 0
	je	SHORT $LN8@SetCurrOff

; 311  :                     omf_OutSelect( TRUE );

	mov	cl, 1
	call	omf_OutSelect
$LN8@SetCurrOff:

; 312  :             LastCodeBufSize = value;

	mov	DWORD PTR LastCodeBufSize, edi
$LN5@SetCurrOff:

; 313  :         }
; 314  :         seg->e.seginfo->start_loc = value;

	mov	rax, QWORD PTR [rbx+96]

; 315  :     /* for -bin, if there's an ORG (relative==false) and no initialized data
; 316  :      * has been set yet, set start_loc!
; 317  :      * v1.96: this is now also done for COFF and ELF
; 318  :      */
; 319  :     /* else if ( Options.output_format == OFORMAT_BIN && relative == FALSE ) { */
; 320  :     } else {

	jmp	SHORT $LN16@SetCurrOff
$LN3@SetCurrOff:

; 321  :         if ( write_to_file == FALSE ) {

	cmp	BYTE PTR write_to_file, 0
	jne	SHORT $LN12@SetCurrOff

; 322  :             if ( relative ) {

	test	r8b, r8b
	jne	SHORT $LN12@SetCurrOff

; 323  : #if 0 /* don't include "preceding" uninitialized data */
; 324  :                 if( seg->e.seginfo->current_loc < seg->e.seginfo->start_loc )
; 325  :                     seg->e.seginfo->start_loc = seg->e.seginfo->current_loc;
; 326  : #endif
; 327  :             } else {
; 328  :                 if ( seg->e.seginfo->bytes_written == 0 )

	mov	rax, QWORD PTR [rcx+96]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN12@SetCurrOff
$LN16@SetCurrOff:

; 329  :                     seg->e.seginfo->start_loc = value;

	mov	DWORD PTR [rax+8], edi
$LN12@SetCurrOff:

; 330  :             }
; 331  :         }
; 332  :     }
; 333  : 
; 334  :     seg->e.seginfo->current_loc = value;

	mov	rax, QWORD PTR [rbx+96]
	mov	DWORD PTR [rax+12], edi

; 335  :     seg->e.seginfo->written = FALSE;

	mov	rax, QWORD PTR [rbx+96]
	and	BYTE PTR [rax+107], 223			; 000000dfH

; 336  : 
; 337  :     if( seg->e.seginfo->current_loc > seg->sym.max_offset )

	mov	rax, QWORD PTR [rbx+96]
	mov	ecx, DWORD PTR [rax+12]

; 339  : 
; 340  :     return( NOT_ERROR );

	xor	eax, eax
	cmp	ecx, DWORD PTR [rbx+56]
	jbe	SHORT $LN13@SetCurrOff

; 338  :         seg->sym.max_offset = seg->e.seginfo->current_loc;

	mov	DWORD PTR [rbx+56], ecx
$LN13@SetCurrOff:

; 341  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetCurrOffset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
string$ = 48
WritePreprocessedLine PROC

; 546  : {

$LN16:
	push	rdi
	sub	rsp, 32					; 00000020H

; 547  :     static bool PrintEmptyLine = TRUE;
; 548  :     const char *p;
; 549  : 
; 550  : #if 0 /* v2.08: removed, obsolete */
; 551  :     /* filter some macro specific directives */
; 552  :     if ( tokenarray[0].token == T_DIRECTIVE &&
; 553  :          ( tokenarray[0].tokval == T_ENDM ||
; 554  :            tokenarray[0].tokval == T_EXITM))
; 555  :         return;
; 556  :     /* don't print generated code - with one exception:
; 557  :      if the code was generated as a result of structure initialization,
; 558  :      then do!
; 559  :      */
; 560  :     if ( GeneratedCode )
; 561  :         return;
; 562  : #endif
; 563  :     if ( Token_Count > 0 ) {

	cmp	DWORD PTR ModuleInfo+496, 0
	mov	rdi, rcx
	jle	SHORT $LN5@WritePrepr

; 564  :         /* v2.08: don't print a leading % (this char is no longer filtered) */
; 565  :         for ( p = string; isspace( *p ); p++ );

	mov	QWORD PTR [rsp+48], rbx
	mov	rbx, rcx
	movsx	ecx, BYTE PTR [rcx]
	call	isspace
	test	eax, eax
	je	SHORT $LN3@WritePrepr
	npad	10
$LL4@WritePrepr:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL4@WritePrepr
$LN3@WritePrepr:

; 566  :         printf("%s\n", *p == '%' ? p+1 : string );

	cmp	BYTE PTR [rbx], 37			; 00000025H
	jne	SHORT $LN9@WritePrepr
	lea	rdi, QWORD PTR [rbx+1]
$LN9@WritePrepr:
	mov	rdx, rdi
	lea	rcx, OFFSET FLAT:$SG11884
	call	printf
	mov	rbx, QWORD PTR [rsp+48]

; 567  :         PrintEmptyLine = TRUE;

	mov	BYTE PTR ?PrintEmptyLine@?1??WritePreprocessedLine@@9@9, 1

; 571  :     }
; 572  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN5@WritePrepr:

; 568  :     } else if ( PrintEmptyLine ) {

	cmp	BYTE PTR ?PrintEmptyLine@?1??WritePreprocessedLine@@9@9, 0
	je	SHORT $LN7@WritePrepr

; 569  :         PrintEmptyLine = FALSE;
; 570  :         printf("\n");

	lea	rcx, OFFSET FLAT:$SG11886
	mov	BYTE PTR ?PrintEmptyLine@?1??WritePreprocessedLine@@9@9, 0

; 571  :     }
; 572  : }

	add	rsp, 32					; 00000020H
	pop	rdi

; 569  :         PrintEmptyLine = FALSE;
; 570  :         printf("\n");

	jmp	printf
$LN7@WritePrepr:

; 571  :     }
; 572  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
WritePreprocessedLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
sym$ = 64
pst$ = 72
buffer$ = 80
ConvertSectionName PROC

; 166  : {

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 170  :         if ( memcmp( sym->name, cst[i].src, cst[i].len ) == 0 ) {

	mov	rbp, QWORD PTR [rcx+8]
	lea	rbx, OFFSET FLAT:cst+8
	mov	r15, r8
	mov	r12, rdx
	mov	r14, rcx
	xor	edi, edi
	npad	12
$LL4@ConvertSec:
	movzx	esi, BYTE PTR [rbx-8]
	mov	rcx, rbp
	mov	rdx, QWORD PTR [rbx]
	mov	r8d, esi
	call	memcmp
	test	eax, eax
	jne	SHORT $LN2@ConvertSec

; 171  :             if ( sym->name[cst[i].len] == NULLC || ( sym->name[cst[i].len] == '$' && ( cst[i].flags & CSF_GRPCHK ) ) ) {

	movzx	eax, BYTE PTR [rsi+rbp]
	test	al, al
	je	SHORT $LN7@ConvertSec
	cmp	al, 36					; 00000024H
	jne	SHORT $LN2@ConvertSec
	test	BYTE PTR [rbx-7], 1
	jne	SHORT $LN7@ConvertSec
$LN2@ConvertSec:

; 167  :     int i;
; 168  : 
; 169  :     for ( i = 0; i < sizeof( cst ) / sizeof( cst[0] ); i++ ) {

	inc	edi
	add	rbx, 24
	movsxd	rax, edi
	cmp	rax, 4
	jb	SHORT $LL4@ConvertSec

; 192  :             }
; 193  :         }
; 194  :     }
; 195  :     return( sym->name );

	mov	rax, rbp
$LN1@ConvertSec:

; 196  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
$LN7@ConvertSec:

; 172  : 
; 173  :                 if ( pst ) {

	lea	r9, OFFSET FLAT:__ImageBase
	test	r12, r12
	je	SHORT $LN10@ConvertSec

; 174  :                     if ( i == CSI_BSS && ( (struct dsym *)sym)->e.seginfo->bytes_written != 0 )

	cmp	edi, 3
	jne	SHORT $LN9@ConvertSec
	mov	rax, QWORD PTR [r14+96]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN10@ConvertSec
$LN9@ConvertSec:

; 175  :                         ; /* don't set segment type to BSS if the segment contains initialized data */
; 176  :                     else
; 177  :                         *pst = stt[i];

	movsxd	rax, edi
	mov	eax, DWORD PTR stt[r9+rax*4]
	mov	DWORD PTR [r12], eax
$LN10@ConvertSec:

; 178  :                 }
; 179  : 
; 180  :                 if ( sym->name[cst[i].len] == NULLC ) {

	movsxd	rax, edi
	lea	r8, QWORD PTR cst[r9]
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, QWORD PTR [rcx*8]
	mov	rcx, QWORD PTR [r14+8]
	add	r8, rax
	movzx	edx, BYTE PTR [r8]
	cmp	BYTE PTR [rdx+rcx], 0
	jne	SHORT $LN11@ConvertSec

; 181  : #if DJGPP_SUPPORT
; 182  :                     /* DJGPP won't be happy with .rdata segment name */
; 183  :                     if( ModuleInfo.sub_format == SFORMAT_DJGPP && i == CSI_CONST )
; 184  :                         return( ".const" );
; 185  : #endif
; 186  :                     return( (char *)cst[i].dst );

	mov	rax, QWORD PTR cst[rax+r9+16]
	jmp	SHORT $LN1@ConvertSec
$LN11@ConvertSec:

; 187  :                 }
; 188  : 
; 189  :                 strcpy( buffer, cst[i].dst );

	mov	rcx, QWORD PTR cst[rax+r9+16]
	mov	rdx, r15
	npad	1
$LL13@ConvertSec:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL13@ConvertSec

; 190  :                 strcat( buffer, sym->name+cst[i].len );

	movzx	r8d, BYTE PTR [r8]
	lea	rcx, QWORD PTR [r15-1]
	add	r8, QWORD PTR [r14+8]
	npad	3
$LL22@ConvertSec:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL22@ConvertSec
	xor	edx, edx
	npad	4
$LL23@ConvertSec:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL23@ConvertSec

; 191  :                 return( buffer );

	mov	rax, r15
	jmp	$LN1@ConvertSec
ConvertSectionName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
close_files PROC

; 1183 : {

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1184 :     /* v2.11: no fatal errors anymore if fclose() fails.
; 1185 :      * That's because Fatal() may cause close_files() to be
; 1186 :      * reentered and thus cause an endless loop.
; 1187 :      */
; 1188 : 
; 1189 :     /* close ASM file */
; 1190 :     if( CurrFile[ASM] != NULL ) {

	mov	rcx, QWORD PTR ModuleInfo+96
	xor	ebx, ebx
	test	rcx, rcx
	je	SHORT $LN2@close_file

; 1191 :         if( fclose( CurrFile[ASM] ) != 0 )

	call	fclose
	test	eax, eax
	je	SHORT $LN3@close_file

; 1192 :             EmitErr( CANNOT_CLOSE_FILE, CurrFName[ASM], errno );

	call	_errno
	mov	rdx, QWORD PTR ModuleInfo+128
	lea	ecx, QWORD PTR [rbx+107]
	mov	r8d, DWORD PTR [rax]
	call	EmitErr
$LN3@close_file:

; 1193 :         CurrFile[ASM] = NULL;

	mov	QWORD PTR ModuleInfo+96, rbx
$LN2@close_file:

; 1194 :     }
; 1195 : 
; 1196 :     /* close OBJ file */
; 1197 :     if ( CurrFile[OBJ] != NULL ) {

	mov	rcx, QWORD PTR ModuleInfo+104
	test	rcx, rcx
	je	SHORT $LN4@close_file

; 1198 :         if ( fclose( CurrFile[OBJ] ) != 0 )

	call	fclose
	test	eax, eax
	je	SHORT $LN5@close_file

; 1199 :             EmitErr( CANNOT_CLOSE_FILE, CurrFName[OBJ], errno );

	call	_errno
	mov	rdx, QWORD PTR ModuleInfo+136
	mov	ecx, 107				; 0000006bH
	mov	r8d, DWORD PTR [rax]
	call	EmitErr
$LN5@close_file:

; 1200 :         CurrFile[OBJ] = NULL;

	mov	QWORD PTR ModuleInfo+104, rbx
$LN4@close_file:

; 1201 :     }
; 1202 :     /* delete the object module if errors occured */
; 1203 :     if ( Options.syntax_check_only == FALSE &&

	cmp	BYTE PTR Options+172, bl
	jne	SHORT $LN6@close_file
	cmp	DWORD PTR ModuleInfo, ebx
	jbe	SHORT $LN6@close_file

; 1204 :         ModuleInfo.g.error_count > 0 ) {
; 1205 :         remove( CurrFName[OBJ] );

	mov	rcx, QWORD PTR ModuleInfo+136
	call	remove
$LN6@close_file:

; 1206 :     }
; 1207 : 
; 1208 :     if( CurrFile[LST] != NULL ) {

	mov	rcx, QWORD PTR ModuleInfo+112
	test	rcx, rcx
	je	SHORT $LN7@close_file

; 1209 :         fclose( CurrFile[LST] );

	call	fclose

; 1210 :         CurrFile[LST] = NULL;

	mov	QWORD PTR ModuleInfo+112, rbx
$LN7@close_file:

; 1211 :     }
; 1212 : 
; 1213 :     /* close ERR file */
; 1214 :     if ( CurrFile[ERR] != NULL ) {

	mov	rcx, QWORD PTR ModuleInfo+120
	test	rcx, rcx
	je	SHORT $LN8@close_file

; 1215 :         fclose( CurrFile[ERR] );

	call	fclose

; 1216 :         CurrFile[ERR] = NULL;

	mov	QWORD PTR ModuleInfo+120, rbx

; 1220 :     return;
; 1221 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN8@close_file:

; 1217 :     } else if ( CurrFName[ERR] )

	mov	rcx, QWORD PTR ModuleInfo+152
	test	rcx, rcx
	je	SHORT $LN10@close_file

; 1220 :     return;
; 1221 : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 1218 :         /* nothing written, delete any existing ERR file */
; 1219 :         remove( CurrFName[ERR] );

	jmp	remove
$LN10@close_file:

; 1220 :     return;
; 1221 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
close_files ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
value$ = 8
SetMasm510 PROC

; 579  :     ModuleInfo.m510 = value;
; 580  :     ModuleInfo.oldstructs = value;
; 581  :     /* ModuleInfo.oldmacros = value; not implemented yet */
; 582  :     ModuleInfo.dotname = value;
; 583  :     ModuleInfo.setif2 = value;

	movzx	eax, cl
	and	eax, 1
	lea	edx, DWORD PTR [rax*4]
	or	edx, eax
	shl	edx, 2
	or	edx, eax
	shl	edx, 2
	or	edx, eax
	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -1361				; fffffaafH
	shl	edx, 4
	or	edx, eax
	mov	DWORD PTR ModuleInfo+408, edx

; 584  : 
; 585  :     if ( value ) {

	test	cl, cl
	je	SHORT $LN4@SetMasm510

; 586  :         if ( ModuleInfo.model == MODEL_NONE ) {

	cmp	DWORD PTR ModuleInfo+360, 0
	jne	SHORT $LN4@SetMasm510

; 587  :             /* if no model is specified, set OFFSET:SEGMENT */
; 588  :             ModuleInfo.offsettype = OT_SEGMENT;
; 589  :             if ( ModuleInfo.langtype == LANG_NONE ) {

	cmp	DWORD PTR ModuleInfo+364, 0
	mov	DWORD PTR ModuleInfo+384, 2
	jne	SHORT $LN4@SetMasm510

; 590  :                 ModuleInfo.scoped = FALSE;

	btr	edx, 7

; 591  :                 ModuleInfo.procs_private = TRUE;

	or	edx, 4
	mov	DWORD PTR ModuleInfo+408, edx
$LN4@SetMasm510:

; 592  :             }
; 593  :         }
; 594  :     }
; 595  :     return;
; 596  : }

	ret	0
SetMasm510 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
prev_written$ = 64
source$ = 112
AssembleModule PROC

; 1388 : {

$LN59:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H

; 1389 :     uint_32       prev_written = -1;
; 1390 :     uint_32       curr_written;
; 1391 :     int           starttime;
; 1392 :     int           endtime;
; 1393 :     struct dsym   *seg;
; 1394 : 
; 1395 :     DebugMsg(("AssembleModule(\"%s\") enter\n", source ));
; 1396 : 
; 1397 :     memset( &ModuleInfo, 0, sizeof(ModuleInfo) );

	xor	edx, edx
	mov	DWORD PTR prev_written$[rsp], -1	; ffffffffH
	mov	r8d, 776				; 00000308H
	lea	rcx, OFFSET FLAT:ModuleInfo
	call	memset

; 1398 :     DebugCmd( ModuleInfo.cref = TRUE ); /* enable debug displays */
; 1399 : 
; 1400 : #if 1 //def __SW_BD
; 1401 :     /* fatal errors during assembly won't terminate the program,
; 1402 :      * just the assembly step.!
; 1403 :      */
; 1404 :     if ( setjmp( jmpenv ) ) {

	lea	rcx, OFFSET FLAT:jmpenv
	mov	rdx, rsp
	call	_setjmp
	xor	ebp, ebp
	test	eax, eax
	je	SHORT $LN11@AssembleMo

; 1405 :         if ( ModuleInfo.g.src_stack )

	cmp	QWORD PTR ModuleInfo+200, rbp
	je	$done$60

; 1406 :             ClearSrcStack(); /* avoid memory leaks! */

	call	ClearSrcStack

; 1407 :         goto done;

	jmp	$done$60
$LN11@AssembleMo:

; 1408 :     }
; 1409 : #endif
; 1410 : 
; 1411 :     AssembleInit( source );

	mov	rcx, QWORD PTR source$[rsp]
	call	AssembleInit

; 1412 : 
; 1413 :     starttime = clock();

	call	clock
	mov	r15d, eax

; 1414 : 
; 1415 : #if 0 /* 1=trigger a protection fault */
; 1416 :     seg = NULL;
; 1417 :     seg->sym.state = SYM_UNDEFINED;
; 1418 : #endif
; 1419 : 
; 1420 :     for( Parse_Pass = PASS_1; ; Parse_Pass++ ) {

	mov	DWORD PTR Parse_Pass, ebp

; 1421 : 
; 1422 :         DebugMsg(( "*************\npass %u\n*************\n", Parse_Pass + 1 ));
; 1423 :         OnePass();

	call	OnePass

; 1424 : 
; 1425 :         if( ModuleInfo.g.error_count > 0 ) {

	cmp	DWORD PTR ModuleInfo, ebp
	ja	$LN37@AssembleMo
	mov	edi, DWORD PTR prev_written$[rsp]
	npad	14
$LL4@AssembleMo:

; 1426 :             DebugMsg(("AssembleModule(%u): errorcnt=%u\n", Parse_Pass + 1, ModuleInfo.g.error_count ));
; 1427 :             break;
; 1428 :         }
; 1429 : 
; 1430 :         /* calculate total size of segments */
; 1431 :         for ( curr_written = 0, seg = SymTables[TAB_SEG].head; seg ; seg = seg->next ) {

	mov	rbx, QWORD PTR SymTables+32
	mov	ecx, ebp
	mov	rax, rbx
	test	rbx, rbx
	je	SHORT $LN6@AssembleMo
$LL7@AssembleMo:

; 1432 :             /* v2.04: use <max_offset> instead of <bytes_written>
; 1433 :              * (the latter is not always reliable due to backpatching).
; 1434 :              */
; 1435 :             //curr_written += seg->e.seginfo->bytes_written;
; 1436 :             curr_written += seg->sym.max_offset;

	add	ecx, DWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax+104]
	test	rax, rax
	jne	SHORT $LL7@AssembleMo
$LN6@AssembleMo:

; 1437 :             DebugMsg(("AssembleModule(%u): segm=%-8s start=%8" I32_SPEC "X max_ofs=%8" I32_SPEC "X written=%" I32_SPEC "X\n",
; 1438 :                       Parse_Pass + 1, seg->sym.name, seg->e.seginfo->start_loc, seg->sym.max_offset,
; 1439 :                       seg->e.seginfo->bytes_written ));
; 1440 :         }
; 1441 : 
; 1442 :         /* if there's no phase error and size of segments didn't change, we're done */
; 1443 :         DebugMsg(("AssembleModule(%u): PhaseError=%u, prev_written=%" I32_SPEC "X, curr_written=%" I32_SPEC "X\n", Parse_Pass + 1, ModuleInfo.PhaseError, prev_written, curr_written));
; 1444 :         if( !ModuleInfo.PhaseError && prev_written == curr_written )

	cmp	BYTE PTR ModuleInfo+422, bpl
	jne	SHORT $LN14@AssembleMo
	cmp	edi, ecx
	je	$LN37@AssembleMo
$LN14@AssembleMo:

; 1445 :             break;
; 1446 : 
; 1447 : #ifdef DEBUG_OUT
; 1448 :         if ( curr_written < prev_written && prev_written != -1 ) {
; 1449 :             printf( "size shrank from %" I32_SPEC "X to %" I32_SPEC "X in pass %u\n", prev_written, curr_written, Parse_Pass + 1 );
; 1450 :         }
; 1451 : #endif
; 1452 : 
; 1453 :         DebugMsg(("AssembleModule(%u): prepare for next pass\n", Parse_Pass + 1));
; 1454 :         prev_written = curr_written;
; 1455 : 
; 1456 :         if ( Parse_Pass % 200 == 199 )

	mov	r8d, DWORD PTR Parse_Pass
	mov	edi, ecx
	mov	DWORD PTR prev_written$[rsp], ecx
	mov	eax, 1374389535				; 51eb851fH
	mul	r8d
	mov	ecx, r8d
	shr	edx, 6
	imul	eax, edx, 200				; 000000c8H
	sub	ecx, eax
	cmp	ecx, 199				; 000000c7H
	jne	SHORT $LN15@AssembleMo

; 1457 :             EmitWarn( 2, ASSEMBLY_PASSES, Parse_Pass+1 );

	lea	edx, QWORD PTR [rcx+41]
	inc	r8d
	mov	ecx, 2
	call	EmitWarn
	mov	rbx, QWORD PTR SymTables+32
$LN15@AssembleMo:

; 1458 : #ifdef DEBUG_OUT
; 1459 :         if ( Options.max_passes && Parse_Pass == (Options.max_passes - 1) )
; 1460 :             break;
; 1461 : #endif
; 1462 :         if ( Options.line_numbers ) {

	cmp	BYTE PTR Options+1, bpl
	je	SHORT $LN18@AssembleMo

; 1463 : #if COFF_SUPPORT
; 1464 :             if ( Options.output_format == OFORMAT_COFF ) {

	cmp	DWORD PTR Options+144, 2
	jne	SHORT $LN17@AssembleMo

; 1465 :                 for( seg = SymTables[TAB_SEG].head; seg; seg = seg->next ) {

	test	rbx, rbx
	je	SHORT $LN18@AssembleMo
	npad	9
$LL10@AssembleMo:

; 1466 :                     if ( seg->e.seginfo->LinnumQueue )

	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+56]
	test	rcx, rcx
	je	SHORT $LN19@AssembleMo

; 1467 :                         QueueDeleteLinnum( seg->e.seginfo->LinnumQueue );

	call	QueueDeleteLinnum
$LN19@AssembleMo:

; 1468 :                     seg->e.seginfo->LinnumQueue = NULL;

	mov	rax, QWORD PTR [rbx+96]
	mov	QWORD PTR [rax+56], rbp
	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	SHORT $LL10@AssembleMo

; 1469 :                 }
; 1470 :             } else {

	jmp	SHORT $LN18@AssembleMo
$LN17@AssembleMo:

; 1471 : #endif
; 1472 :                 QueueDeleteLinnum( &LinnumQueue );

	lea	rcx, OFFSET FLAT:LinnumQueue
	call	QueueDeleteLinnum

; 1473 :                 LinnumQueue.head = NULL;

	mov	QWORD PTR LinnumQueue, rbp
$LN18@AssembleMo:

; 1474 : #if COFF_SUPPORT
; 1475 :             }
; 1476 : #endif
; 1477 :         }
; 1478 : 
; 1479 :         /* set file position of ASM and LST files for next pass */
; 1480 : 
; 1481 :         rewind( CurrFile[ASM] );

	mov	rcx, QWORD PTR ModuleInfo+96
	call	rewind

; 1482 :         if ( write_to_file && Options.output_format == OFORMAT_OMF )

	cmp	BYTE PTR write_to_file, bpl
	je	SHORT $LN20@AssembleMo
	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN20@AssembleMo

; 1483 :             omf_set_filepos();

	call	omf_set_filepos
$LN20@AssembleMo:

; 1484 : 
; 1485 : #if FASTPASS
; 1486 :         if ( UseSavedState == FALSE && CurrFile[LST] ) {

	cmp	BYTE PTR UseSavedState, bpl
	jne	SHORT $LN2@AssembleMo
	mov	rcx, QWORD PTR ModuleInfo+112
	test	rcx, rcx
	je	SHORT $LN2@AssembleMo

; 1487 : #else
; 1488 :         if ( CurrFile[LST] ) {
; 1489 : #endif
; 1490 :             rewind( CurrFile[LST] );

	call	rewind

; 1491 :             LstInit();

	call	LstInit
$LN2@AssembleMo:

; 1421 : 
; 1422 :         DebugMsg(( "*************\npass %u\n*************\n", Parse_Pass + 1 ));
; 1423 :         OnePass();

	inc	DWORD PTR Parse_Pass
	call	OnePass

; 1424 : 
; 1425 :         if( ModuleInfo.g.error_count > 0 ) {

	cmp	DWORD PTR ModuleInfo, ebp
	jbe	$LL4@AssembleMo
$LN37@AssembleMo:

; 1492 :         }
; 1493 :     } /* end for() */
; 1494 : 
; 1495 :     if ( ( Parse_Pass > PASS_1 ) && write_to_file )

	cmp	DWORD PTR Parse_Pass, ebp
	jbe	SHORT $LN22@AssembleMo
	cmp	BYTE PTR write_to_file, bpl
	je	SHORT $LN22@AssembleMo

; 1496 :         WriteModule( &ModuleInfo );

	lea	rcx, OFFSET FLAT:ModuleInfo
	call	WriteModule
$LN22@AssembleMo:

; 1497 : 
; 1498 :     if ( ModuleInfo.pCodeBuff ) {
; 1499 :         LclFree( ModuleInfo.pCodeBuff );
; 1500 :     }
; 1501 :     DebugMsg(("AssembleModule: finished, cleanup\n"));
; 1502 : 
; 1503 :     /* Write a symbol listing file (if requested) */
; 1504 :     LstWriteCRef();

	call	LstWriteCRef

; 1505 : 
; 1506 :     endtime = clock(); /* is in ms already */

	call	clock

; 1507 : 
; 1508 :     sprintf( CurrSource, MsgGetEx( MSG_ASSEMBLY_RESULTS ),

	mov	ecx, DWORD PTR ModuleInfo+428
	mov	esi, eax
	call	GetFName
	mov	edi, DWORD PTR Parse_Pass
	mov	r14, rax
	inc	edi
	sub	esi, r15d
	call	GetLineNumber
	mov	ecx, 1
	mov	ebx, eax
	call	MsgGetEx
	mov	ecx, DWORD PTR ModuleInfo
	mov	rdx, rax
	mov	r8, QWORD PTR [r14]
	mov	r9d, ebx
	mov	DWORD PTR [rsp+56], ecx
	mov	ecx, DWORD PTR ModuleInfo+4
	mov	DWORD PTR [rsp+48], ecx
	mov	rcx, QWORD PTR ModuleInfo+464
	mov	DWORD PTR [rsp+40], esi
	mov	DWORD PTR [rsp+32], edi
	call	sprintf

; 1509 :              GetFName( ModuleInfo.srcfile )->fname,
; 1510 :              GetLineNumber(),
; 1511 :              Parse_Pass + 1,
; 1512 :              endtime - starttime,
; 1513 :              ModuleInfo.g.warning_count,
; 1514 :              ModuleInfo.g.error_count);
; 1515 :     if ( Options.quiet == FALSE )

	cmp	BYTE PTR Options, bpl
	jne	SHORT $LN24@AssembleMo

; 1516 :         printf( "%s\n", CurrSource );

	mov	rdx, QWORD PTR ModuleInfo+464
	lea	rcx, OFFSET FLAT:$SG12121
	call	printf
$LN24@AssembleMo:

; 1517 : 
; 1518 :     if ( CurrFile[LST] ) {

	cmp	QWORD PTR ModuleInfo+112, rbp
	je	SHORT $done$60

; 1519 :         LstPrintf( CurrSource );

	mov	rcx, QWORD PTR ModuleInfo+464
	call	LstPrintf

; 1520 :         LstNL();

	call	LstNL
$done$60:

; 1521 :     }
; 1522 : #if 1 //def __SW_BD
; 1523 : done:
; 1524 : #endif
; 1525 :     AssembleFini();

	call	SegmentFini
	call	SymFini
	call	ResWordsFini
	call	FreePubQueue
	call	InputFini
	call	close_files
	xorps	xmm0, xmm0
	xorps	xmm1, xmm1
	movdqu	XMMWORD PTR ModuleInfo+128, xmm0
	movdqu	XMMWORD PTR ModuleInfo+144, xmm1
	call	MemFini

; 1526 :     DebugMsg(("AssembleModule exit\n"));
; 1527 :     return( ModuleInfo.g.error_count == 0 );

	cmp	DWORD PTR ModuleInfo, ebp

; 1528 : }

	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+56]
	sete	bpl
	mov	eax, ebp
	mov	rbp, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
AssembleModule ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
pbytes$ = 48
len$ = 56
fixup$ = 64
OutputBytes PROC

; 262  : {

$LN10:
	sub	rsp, 40					; 00000028H

; 263  :     if( write_to_file == TRUE ) {

	cmp	BYTE PTR write_to_file, 1
	mov	QWORD PTR [rsp+56], rbp
	mov	rbp, rcx
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, r8
	mov	QWORD PTR [rsp+32], rdi
	movsxd	rdi, edx
	jne	SHORT $LN2@OutputByte

; 264  :         uint_32 idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rdx, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rsp+48], rbx
	mov	rax, QWORD PTR [rdx+96]
	mov	ebx, DWORD PTR [rax+12]
	sub	ebx, DWORD PTR [rax+8]

; 265  : #if 0 /* def DEBUG_OUT */
; 266  :         if ( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc )
; 267  :             _asm int 3;
; 268  : #endif
; 269  :         /**/myassert( CurrSeg->e.seginfo->current_loc >= CurrSeg->e.seginfo->start_loc );
; 270  :         if( Options.output_format == OFORMAT_OMF && ((idx + len) > MAX_LEDATA_THRESHOLD ) ) {

	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN4@OutputByte
	lea	eax, DWORD PTR [rbx+rdi]
	cmp	eax, 1014				; 000003f6H
	jbe	SHORT $LN4@OutputByte

; 271  :             omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 272  :             idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rdx, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rdx+96]
	mov	ebx, DWORD PTR [rax+12]
	sub	ebx, DWORD PTR [rax+8]
$LN4@OutputByte:

; 273  :         }
; 274  :         if ( fixup )

	test	rsi, rsi
	je	SHORT $LN5@OutputByte

; 275  :             store_fixup( fixup, CurrSeg, (int_32 *)pbytes );

	mov	r8, rbp
	mov	rcx, rsi
	call	store_fixup
	mov	rdx, QWORD PTR ModuleInfo+432
$LN5@OutputByte:

; 276  :         //DebugMsg(("OutputBytes: buff=%p, idx=%" I32_SPEC "X, byte=%X\n", CurrSeg->e.seginfo->CodeBuffer, idx, *pbytes ));
; 277  :         memcpy( &CurrSeg->e.seginfo->CodeBuffer[idx], pbytes, len );

	mov	rax, QWORD PTR [rdx+96]
	mov	r8, rdi
	mov	ecx, ebx
	mov	rdx, rbp
	add	rcx, QWORD PTR [rax+16]
	call	memcpy
	mov	rbx, QWORD PTR [rsp+48]

; 278  :     }

	jmp	SHORT $LN6@OutputByte
$LN2@OutputByte:

; 279  : #if 1
; 280  :     /* check this in pass 1 only */
; 281  :     else if( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rcx+12]
	cmp	eax, DWORD PTR [rcx+8]
	jae	SHORT $LN6@OutputByte

; 282  :         DebugMsg(("OutputBytes: segment start loc changed from %" I32_SPEC "Xh to %" I32_SPEC "Xh\n",
; 283  :                   CurrSeg->e.seginfo->start_loc,
; 284  :                   CurrSeg->e.seginfo->current_loc));
; 285  :         CurrSeg->e.seginfo->start_loc = CurrSeg->e.seginfo->current_loc;

	mov	DWORD PTR [rcx+8], eax
$LN6@OutputByte:

; 286  :     }
; 287  : #endif
; 288  :     CurrSeg->e.seginfo->current_loc += len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rcx, QWORD PTR [rax+96]
	add	DWORD PTR [rcx+12], edi

; 289  :     CurrSeg->e.seginfo->bytes_written += len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	add	DWORD PTR [rcx+24], edi

; 290  :     CurrSeg->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rdi, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR [rax+96]
	or	BYTE PTR [rcx+107], 32			; 00000020H

; 291  :     if( CurrSeg->e.seginfo->current_loc > CurrSeg->sym.max_offset )

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rcx+96]
	mov	edx, DWORD PTR [rax+12]
	cmp	edx, DWORD PTR [rcx+56]
	jbe	SHORT $LN7@OutputByte

; 292  :         CurrSeg->sym.max_offset = CurrSeg->e.seginfo->current_loc;

	mov	DWORD PTR [rcx+56], edx
$LN7@OutputByte:

; 293  : }

	add	rsp, 40					; 00000028H
	ret	0
OutputBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
byte$ = 48
len$ = 56
FillDataBytes PROC

; 248  : {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 249  :     if ( ModuleInfo.CommentDataInCode )

	cmp	BYTE PTR ModuleInfo+423, 0
	mov	ebx, edx
	movzx	edi, cl
	je	SHORT $LN5@FillDataBy

; 250  :         omf_OutSelect( TRUE );

	mov	cl, 1
	call	omf_OutSelect
$LN5@FillDataBy:

; 251  :     for( ; len; len-- )

	test	ebx, ebx
	je	$LN3@FillDataBy
	mov	rax, QWORD PTR ModuleInfo+432
	npad	2
$LL4@FillDataBy:

; 252  :         OutputByte( byte );

	cmp	BYTE PTR write_to_file, 1
	jne	SHORT $LN8@FillDataBy
	lea	rdx, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR [rax+12]
	sub	ecx, DWORD PTR [rax+8]
	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN10@FillDataBy
	cmp	ecx, 1014				; 000003f6H
	jb	SHORT $LN10@FillDataBy
	call	omf_FlushCurrSeg
	mov	rdx, QWORD PTR ModuleInfo+432
	add	rdx, 96					; 00000060H
	mov	rax, QWORD PTR [rdx]
	mov	ecx, DWORD PTR [rax+12]
	sub	ecx, DWORD PTR [rax+8]
$LN10@FillDataBy:
	mov	rax, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rax+16]
	mov	BYTE PTR [rcx+rax], dil
	jmp	SHORT $LN18@FillDataBy
$LN8@FillDataBy:
	mov	rcx, QWORD PTR [rax+96]
	mov	edx, DWORD PTR [rcx+12]
	cmp	edx, DWORD PTR [rcx+8]
	jae	SHORT $LN11@FillDataBy
	mov	DWORD PTR [rcx+8], edx
$LN18@FillDataBy:
	mov	rax, QWORD PTR ModuleInfo+432
$LN11@FillDataBy:
	mov	rcx, QWORD PTR [rax+96]
	inc	DWORD PTR [rcx+12]
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	inc	DWORD PTR [rcx+24]
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	or	BYTE PTR [rcx+107], 32			; 00000020H
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	mov	edx, DWORD PTR [rcx+12]
	cmp	edx, DWORD PTR [rax+56]
	jbe	SHORT $LN2@FillDataBy
	mov	DWORD PTR [rax+56], edx
	mov	rax, QWORD PTR ModuleInfo+432
$LN2@FillDataBy:

; 251  :     for( ; len; len-- )

	sub	ebx, 1
	jne	$LL4@FillDataBy
$LN3@FillDataBy:

; 253  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
FillDataBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
byte$ = 48
OutputByte PROC

; 204  : {

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 205  :     if( write_to_file == TRUE ) {

	cmp	BYTE PTR write_to_file, 1
	movzx	ebx, cl
	jne	SHORT $LN2@OutputByte

; 206  :         uint_32 idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	r8, QWORD PTR ModuleInfo+432
	add	r8, 96					; 00000060H
	mov	rax, QWORD PTR [r8]
	mov	edx, DWORD PTR [rax+12]
	sub	edx, DWORD PTR [rax+8]

; 207  : #ifdef DEBUG_OUT
; 208  :         if ( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc ) {
; 209  :             ;//_asm int 3;
; 210  :         }
; 211  : #endif
; 212  :         /**/myassert( CurrSeg->e.seginfo->current_loc >= CurrSeg->e.seginfo->start_loc );
; 213  :         if( Options.output_format == OFORMAT_OMF && idx >= MAX_LEDATA_THRESHOLD ) {

	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN4@OutputByte
	cmp	edx, 1014				; 000003f6H
	jb	SHORT $LN4@OutputByte

; 214  :             omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 215  :             idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	r8, QWORD PTR ModuleInfo+432
	add	r8, 96					; 00000060H
	mov	rax, QWORD PTR [r8]
	mov	edx, DWORD PTR [rax+12]
	sub	edx, DWORD PTR [rax+8]
$LN4@OutputByte:

; 216  :         }
; 217  :         //DebugMsg(("OutputByte: buff=%p, idx=%" I32_SPEC "X, byte=%X, codebuff[0]=%X\n", CurrSeg->e.seginfo->CodeBuffer, idx, byte, *CurrSeg->e.seginfo->CodeBuffer ));
; 218  :         CurrSeg->e.seginfo->CodeBuffer[idx] = byte;

	mov	rax, QWORD PTR [r8]
	mov	rax, QWORD PTR [rax+16]
	mov	BYTE PTR [rdx+rax], bl

; 219  :     }

	jmp	SHORT $LN5@OutputByte
$LN2@OutputByte:

; 220  : #if 1
; 221  :     /* check this in pass 1 only */
; 222  :     else if( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rcx+12]
	cmp	eax, DWORD PTR [rcx+8]
	jae	SHORT $LN5@OutputByte

; 223  :         DebugMsg(("OutputByte: segment start loc changed from %" I32_SPEC "Xh to %" I32_SPEC "Xh\n",
; 224  :                   CurrSeg->e.seginfo->start_loc,
; 225  :                   CurrSeg->e.seginfo->current_loc));
; 226  :         CurrSeg->e.seginfo->start_loc = CurrSeg->e.seginfo->current_loc;

	mov	DWORD PTR [rcx+8], eax
$LN5@OutputByte:

; 227  :     }
; 228  : #endif
; 229  :     CurrSeg->e.seginfo->current_loc++;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	inc	DWORD PTR [rcx+12]

; 230  :     CurrSeg->e.seginfo->bytes_written++;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	inc	DWORD PTR [rcx+24]

; 231  :     CurrSeg->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	or	BYTE PTR [rcx+107], 32			; 00000020H

; 232  :     if( CurrSeg->e.seginfo->current_loc > CurrSeg->sym.max_offset )

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rcx+96]
	mov	edx, DWORD PTR [rax+12]
	cmp	edx, DWORD PTR [rcx+56]
	jbe	SHORT $LN6@OutputByte

; 233  :         CurrSeg->sym.max_offset = CurrSeg->e.seginfo->current_loc;

	mov	DWORD PTR [rcx+56], edx
$LN6@OutputByte:

; 234  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
OutputByte ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rdi, rcx

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rbx
	mov	QWORD PTR [rsp+40], rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], 0
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf
	test	eax, eax
	cmovs	eax, ebx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbx
	mov	r9, rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, rbx
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf

; 1459 :     #pragma warning(pop)
; 1460 : }

	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ebx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_Locale$ = 88
_ArgList$ = 96
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR _ArgList$[rsp]
	or	rcx, 1
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rbx
	call	__stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;
; 1391 : }

	mov	rbx, QWORD PTR [rsp+64]
	or	ecx, -1
	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ecx
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 950  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	rbx, rax
	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 955  :     __crt_va_end(_ArgList);
; 956  :     return _Result;
; 957  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 640  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
