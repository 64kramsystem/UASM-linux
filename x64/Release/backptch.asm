; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
PUBLIC	BackPatch
EXTRN	EmitWarn:PROC
EXTRN	OutputByte:PROC
EXTRN	FreeFixup:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
pdata	SEGMENT
$pdata$BackPatch DD imagerel $LN86
	DD	imagerel $LN86+23
	DD	imagerel $unwind$BackPatch
$pdata$3$BackPatch DD imagerel $LN86+23
	DD	imagerel $LN86+546
	DD	imagerel $chain$3$BackPatch
$pdata$4$BackPatch DD imagerel $LN86+546
	DD	imagerel $LN86+563
	DD	imagerel $chain$4$BackPatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DoPatch DD imagerel DoPatch
	DD	imagerel DoPatch+46
	DD	imagerel $unwind$DoPatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$DoPatch DD imagerel DoPatch+46
	DD	imagerel DoPatch+479
	DD	imagerel $chain$0$DoPatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$DoPatch DD imagerel DoPatch+479
	DD	imagerel DoPatch+490
	DD	imagerel $chain$1$DoPatch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$DoPatch DD 021H
	DD	imagerel DoPatch
	DD	imagerel DoPatch+46
	DD	imagerel $unwind$DoPatch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$DoPatch DD 020521H
	DD	073405H
	DD	imagerel DoPatch
	DD	imagerel DoPatch+46
	DD	imagerel $unwind$DoPatch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DoPatch DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
xdata	SEGMENT
$unwind$BackPatch DD 030701H
	DD	070034207H
	DD	06002H
$chain$3$BackPatch DD 081d21H
	DD	04f41dH
	DD	0be413H
	DD	0a540aH
	DD	093405H
	DD	imagerel $LN86
	DD	imagerel $LN86+23
	DD	imagerel $unwind$BackPatch
$chain$4$BackPatch DD 021H
	DD	imagerel $LN86
	DD	imagerel $LN86+23
	DD	imagerel $unwind$BackPatch
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\backptch.c
;	COMDAT DoPatch
_TEXT	SEGMENT
max_disp$ = 48
disp$ = 48
sym$ = 48
fixup$ = 56
DoPatch	PROC						; COMDAT

; 54   : {

	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 55   :     int_32              disp;
; 56   :     int_32              max_disp;
; 57   :     unsigned            size;
; 58   :     struct dsym         *seg;
; 59   : #if LABELOPT
; 60   :     struct asym         *sym2;
; 61   :     struct fixup        *fixup2;
; 62   : #endif
; 63   : 
; 64   :     /* all relative fixups should occure only at first pass and they signal forward references
; 65   :      * they must be removed after patching or skiped ( next processed as normal fixup )
; 66   :      */
; 67   : 
; 68   :     DebugMsg(("DoPatch(%u, %s): fixup sym=%s type=%u ofs=%" I32_SPEC "Xh loc=%" I32_SPEC "Xh opt=%u def_seg=%s\n",
; 69   :               Parse_Pass + 1, sym->name,
; 70   :               fixup->sym ? fixup->sym->name : "NULL",
; 71   :               fixup->type,
; 72   :               fixup->offset,
; 73   :               fixup->locofs,
; 74   :               fixup->option,
; 75   :               fixup->def_seg ? fixup->def_seg->sym.name : "NULL" ));
; 76   :     seg = GetSegm( sym );

	mov	rsi, QWORD PTR [rcx+24]
	mov	rdi, rdx
	mov	r9, rcx

; 77   :     if( seg == NULL || fixup->def_seg != seg ) {

	test	rsi, rsi
	je	$LN36@DoPatch
	cmp	QWORD PTR [rdx+48], rsi
	jne	$LN36@DoPatch

; 78   :         /* if fixup location is in another segment, backpatch is possible, but
; 79   :          * complicated and it's a pretty rare case, so nothing's done.
; 80   :          */
; 81   :         DebugMsg(("DoPatch: skipped due to seg incompat: %s - %s\n",
; 82   :                   fixup->def_seg ? fixup->def_seg->sym.name : "NULL",
; 83   :                   seg ? seg->sym.name : "NULL" ));
; 84   :         SkipFixup();
; 85   :         return;
; 86   :     }
; 87   : 
; 88   :     if( Parse_Pass == PASS_1 ) {

	mov	r11d, DWORD PTR Parse_Pass
	mov	QWORD PTR [rsp+56], rbx
	xor	ebx, ebx
	test	r11d, r11d
	jne	SHORT $LN29@DoPatch

; 89   :         if( sym->mem_type == MT_FAR && fixup->option == OPTJ_CALL ) {

	cmp	DWORD PTR [rcx+36], 130			; 00000082H
	jne	SHORT $LN25@DoPatch
	cmp	DWORD PTR [rdx+28], 4
	jne	SHORT $LN25@DoPatch

; 90   :             /* convert near call to push cs + near call,
; 91   :              * (only at first pass) */
; 92   :             DebugMsg(("DoPatch: Phase error! caused by far call optimization\n"));
; 93   :             ModuleInfo.PhaseError = TRUE;

	mov	BYTE PTR ModuleInfo+422, 1

; 94   :             sym->offset++;  /* a PUSH CS will be added */

	inc	DWORD PTR [rcx+16]

; 95   :             /* todo: insert LABELOPT block here */
; 96   :             OutputByte( 0 ); /* it's pass one, nothing is written */

	xor	ecx, ecx
	call	OutputByte

; 97   :             FreeFixup( fixup );
; 98   :             return;

	jmp	$LN20@DoPatch
$LN25@DoPatch:

; 99   :         //} else if( sym->mem_type == MT_NEAR ) {
; 100  :         } else {
; 101  :             /* forward reference, only at first pass */
; 102  :             switch( fixup->type ) {

	mov	eax, DWORD PTR [rdx+24]
	cmp	eax, 2
	jl	SHORT $LN29@DoPatch
	cmp	eax, 3
	jle	SHORT $LN27@DoPatch
	cmp	eax, 4
	jne	SHORT $LN29@DoPatch

; 108  :             case FIX_OFF8:  /* push <forward reference> */
; 109  :                 if ( fixup->option == OPTJ_PUSH ) {

	cmp	DWORD PTR [rdx+28], 5
	jne	SHORT $LN29@DoPatch

; 110  :                     size = 1;    /* size increases from 2 to 3/5 */
; 111  :                     DebugMsg(("DoPatch: FIX_OFF8\n"));
; 112  :                     goto patch;

	mov	r8d, DWORD PTR disp$[rsp]
	lea	edx, QWORD PTR [rax-3]
	mov	r10d, DWORD PTR max_disp$[rsp]
	jmp	SHORT $patch$76
$LN27@DoPatch:

; 103  :             case FIX_RELOFF32:
; 104  :             case FIX_RELOFF16:
; 105  :                 FreeFixup( fixup );

	mov	rcx, rdx

; 106  :                 DebugMsg(("DoPatch: FIX_RELOFF32/FIX_RELOFF16, return\n"));
; 107  :                 return;

	jmp	$LN74@DoPatch
$LN29@DoPatch:

; 113  :                 }
; 114  :             }
; 115  :         }
; 116  :     }
; 117  :     size = 0;
; 118  :     switch( fixup->type ) {

	mov	ecx, DWORD PTR [rdi+24]
	mov	edx, ebx
	sub	ecx, 1
	je	SHORT $LN32@DoPatch
	sub	ecx, 1
	je	SHORT $LN31@DoPatch
	cmp	ecx, 1
	jne	$LN73@DoPatch

; 119  :     case FIX_RELOFF32:
; 120  :         size = 2; /* will be 4 finally */

	mov	edx, 2
$LN31@DoPatch:

; 121  :         /* fall through */
; 122  :     case FIX_RELOFF16:
; 123  :         size++; /* will be 2 finally */

	inc	edx
$LN32@DoPatch:

; 124  :         /* fall through */
; 125  :     case FIX_RELOFF8:
; 126  :         size++;
; 127  :         /* calculate the displacement */
; 128  :         // disp = fixup->offset + GetCurrOffset() - fixup->location - size;
; 129  :         disp = fixup->offset + fixup->sym->offset - fixup->locofs - size - 1;

	mov	rax, QWORD PTR [rdi+56]
	inc	edx

; 130  :         max_disp = (1UL << ((size * 8)-1)) - 1;

	mov	r10d, 1
	mov	r8d, DWORD PTR [rax+16]
	lea	ecx, DWORD PTR [rdx*8-1]
	sub	r8d, DWORD PTR [rdi+20]
	add	r8d, DWORD PTR [rdi+16]
	sub	r8d, edx
	shl	r10d, cl
	dec	r8d
	dec	r10d

; 131  :         if( disp > max_disp || disp < (-max_disp-1) ) {

	cmp	r8d, r10d
	jg	SHORT $patch$76
	or	eax, -1
	sub	eax, r10d
	cmp	r8d, eax
	jge	$LN20@DoPatch
$patch$76:

; 132  :         patch:
; 133  :             DebugMsg(("DoPatch(%u): Phase error, disp=%X, fixup=%s(%X), loc=%X!\n", Parse_Pass + 1, disp, fixup->sym->name, fixup->sym->offset, fixup->locofs ));
; 134  :             ModuleInfo.PhaseError = TRUE;

	mov	BYTE PTR ModuleInfo+422, 1

; 135  :             /* ok, the standard case is: there's a forward jump which
; 136  :              * was assumed to be SHORT, but it must be NEAR instead.
; 137  :              */
; 138  :             switch( size ) {

	sub	edx, 1
	je	SHORT $LN35@DoPatch
	sub	edx, 1
	je	SHORT $LN48@DoPatch
	cmp	edx, 2
	jne	$LN20@DoPatch
$LN48@DoPatch:

; 211  :                     break;
; 212  :                 }
; 213  :                 break;
; 214  :             case 2:
; 215  :             case 4:
; 216  :                 DebugMsg(("DoPatch: jump out of range, disp=%d\n", disp ));
; 217  :                 EmitWarn( 4, JUMP_OUT_OF_RANGE, disp - max_disp );

	mov	edx, 53					; 00000035H
	sub	r8d, r10d
	lea	ecx, QWORD PTR [rdx-49]
	call	EmitWarn
	jmp	$LN20@DoPatch
$LN35@DoPatch:

; 139  :             case 1:
; 140  :                 size = 0;
; 141  :                 switch( fixup->option ) {

	mov	ecx, DWORD PTR [rdi+28]
	sub	ecx, 1
	je	$LN73@DoPatch
	sub	ecx, 1
	je	SHORT $LN37@DoPatch
	cmp	ecx, 1
	je	SHORT $LN38@DoPatch
	jmp	SHORT $LN39@DoPatch
$LN37@DoPatch:

; 142  :                 case OPTJ_EXPLICIT:
; 143  : #if 0 /* don't display the error at the destination line! */
; 144  :                     DebugMsg(("DoPatch: jump out of range, disp=%d\n", disp ));
; 145  :                     EmitErr( JUMP_OUT_OF_RANGE, disp - max_disp );
; 146  : #endif
; 147  :                     return;
; 148  :                 case OPTJ_EXTEND: /* Jxx for 8086 */
; 149  :                     size++;       /* will be 3/5 finally */

	mov	ebx, 1
$LN38@DoPatch:

; 150  :                     /* fall through */
; 151  :                 case OPTJ_JXX: /* Jxx for 386 */
; 152  :                     size++;

	inc	ebx
$LN39@DoPatch:

; 153  :                     /* fall through */
; 154  :                 default: /* normal JMP (and PUSH) */
; 155  :                     // if( CodeInfo->Ofssize ) /* v1.96: don't use CodeInfo here! */
; 156  :                     if( seg->e.seginfo->Ofssize )

	mov	rdx, QWORD PTR [rsi+96]
	cmp	BYTE PTR [rdx+104], 0
	je	SHORT $LN40@DoPatch

; 157  :                         size += 2; /* NEAR32 instead of NEAR16 */

	add	ebx, 2
$LN40@DoPatch:

; 158  :                     size++;

	inc	ebx

; 159  : #if LABELOPT
; 160  :                     /* v2.04: if there's an ORG between src and dst, skip
; 161  :                      * the optimization!
; 162  :                      */
; 163  :                     if ( Parse_Pass == PASS_1 ) {

	test	r11d, r11d
	jne	SHORT $LN56@DoPatch

; 164  :                         for ( fixup2 = seg->e.seginfo->FixupList.head; fixup2; fixup2 = fixup2->nextrlc ) {

	mov	rcx, QWORD PTR [rdx+40]
	test	rcx, rcx
	je	SHORT $LN56@DoPatch
$LL12@DoPatch:

; 165  :                             if ( fixup2->orgoccured ) {

	test	BYTE PTR [rcx+33], 2
	jne	SHORT $LN73@DoPatch

; 166  :                                 DebugMsg(("DoPatch: ORG/ALIGN detected, optimization canceled\n" ));
; 167  :                                 return;
; 168  :                             }
; 169  :                             /* do this check after the check for ORG! */
; 170  :                             if ( fixup2->locofs <= fixup->locofs )

	mov	eax, DWORD PTR [rdi+20]
	cmp	DWORD PTR [rcx+20], eax
	jbe	SHORT $LN56@DoPatch

; 164  :                         for ( fixup2 = seg->e.seginfo->FixupList.head; fixup2; fixup2 = fixup2->nextrlc ) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	jne	SHORT $LL12@DoPatch
$LN56@DoPatch:

; 171  :                                 break;
; 172  :                         }
; 173  :                     }
; 174  :                     /* scan the segment's label list and adjust all labels
; 175  :                      * which are between the fixup loc and the current sym.
; 176  :                      * ( PROCs are NOT contained in this list because they
; 177  :                      * use the <next>-field of dsym already!)
; 178  :                      */
; 179  :                     for ( sym2 = seg->e.seginfo->label_list; sym2; sym2 = (struct asym *)((struct dsym *)sym2)->next ) {

	mov	rcx, QWORD PTR [rdx+32]
	test	rcx, rcx
	je	SHORT $LN57@DoPatch
$LL15@DoPatch:

; 180  :                         //if ( sym2 == sym )
; 181  :                         //    continue;
; 182  :                         /* v2.0: location is at least 1 byte too low, so
; 183  :                          * use the "<=" operator instead of "<"!
; 184  :                          */
; 185  :                         //if ( sym2->offset < fixup->locofs )
; 186  :                         if ( sym2->offset <= fixup->locofs )

	mov	eax, DWORD PTR [rcx+16]
	cmp	eax, DWORD PTR [rdi+20]
	jbe	SHORT $LN71@DoPatch

; 187  :                             break;
; 188  :                         sym2->offset += size;

	add	eax, ebx
	mov	DWORD PTR [rcx+16], eax
	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL15@DoPatch
$LN71@DoPatch:

; 171  :                                 break;
; 172  :                         }
; 173  :                     }
; 174  :                     /* scan the segment's label list and adjust all labels
; 175  :                      * which are between the fixup loc and the current sym.
; 176  :                      * ( PROCs are NOT contained in this list because they
; 177  :                      * use the <next>-field of dsym already!)
; 178  :                      */
; 179  :                     for ( sym2 = seg->e.seginfo->label_list; sym2; sym2 = (struct asym *)((struct dsym *)sym2)->next ) {

	mov	r11d, DWORD PTR Parse_Pass
$LN57@DoPatch:

; 189  :                         DebugMsg(("DoPatch(loc=%" I32_SPEC "X): sym %s, offset changed %" I32_SPEC "X -> %" I32_SPEC "X\n", fixup->locofs, sym2->name, sym2->offset - size, sym2->offset));
; 190  :                     }
; 191  :                     /* v2.03: also adjust fixup locations located between the
; 192  :                      * label reference and the label. This should reduce the
; 193  :                      * number of passes to 2 for not too complex sources.
; 194  :                      */
; 195  :                     if ( Parse_Pass == PASS_1 ) /* v2.04: added, just to be safe */

	test	r11d, r11d
	jne	SHORT $LN72@DoPatch

; 196  :                     for ( fixup2 = seg->e.seginfo->FixupList.head; fixup2; fixup2 = fixup2->nextrlc ) {

	mov	rax, QWORD PTR [rsi+96]
	mov	rcx, QWORD PTR [rax+40]
	test	rcx, rcx
	je	SHORT $LN72@DoPatch
$LL18@DoPatch:

; 197  :                         if ( fixup2->sym == sym )

	cmp	QWORD PTR [rcx+56], r9
	je	SHORT $LN16@DoPatch

; 198  :                             continue;
; 199  :                         if ( fixup2->locofs <= fixup->locofs )

	mov	eax, DWORD PTR [rcx+20]
	cmp	eax, DWORD PTR [rdi+20]
	jbe	SHORT $LN72@DoPatch

; 200  :                             break;
; 201  :                         fixup2->locofs += size;

	add	eax, ebx
	mov	DWORD PTR [rcx+20], eax
$LN16@DoPatch:

; 196  :                     for ( fixup2 = seg->e.seginfo->FixupList.head; fixup2; fixup2 = fixup2->nextrlc ) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	jne	SHORT $LL18@DoPatch
$LN72@DoPatch:

; 202  :                         DebugMsg(("for sym=%s fixup loc %" I32_SPEC "X changed to %" I32_SPEC "X\n", fixup2->sym->name, fixup2->locofs - size, fixup2->locofs ));
; 203  :                     }
; 204  : #else
; 205  :                     DebugMsg(("DoPatch: sym %s, offset changed %" I32_SPEC "X -> %" I32_SPEC "X\n", sym->name, sym->offset, sym->offset + size));
; 206  :                     sym->offset += size;
; 207  : #endif
; 208  :                     /*  it doesn't matter what's actually "written" */
; 209  :                     for ( ; size; size-- )

	test	ebx, ebx
	je	SHORT $LN20@DoPatch
$LL21@DoPatch:

; 210  :                         OutputByte( 0xCC );

	mov	cl, 204					; 000000ccH
	call	OutputByte
	add	ebx, -1					; ffffffffH
	jne	SHORT $LL21@DoPatch
$LN20@DoPatch:

; 218  :                 break;
; 219  :             }
; 220  :         }
; 221  : #ifdef DEBUG_OUT
; 222  :         else
; 223  :             DebugMsg(("DoPatch, loc=%" I32_SPEC "X: displacement still short: %Xh\n", fixup->locofs, disp ));
; 224  : #endif
; 225  :         /* v2.04: fixme: is it ok to remove the fixup?
; 226  :          * it might still be needed in a later backpatch.
; 227  :          */
; 228  :         FreeFixup( fixup );

	mov	rcx, rdi
$LN74@DoPatch:
	call	FreeFixup
$LN73@DoPatch:
	mov	rbx, QWORD PTR [rsp+56]
$LN36@DoPatch:

; 229  :         break;
; 230  :     default:
; 231  :         DebugMsg(("DoPatch: default branch, unhandled fixup type=%u\n", fixup->type ));
; 232  :         SkipFixup();
; 233  :         break;
; 234  :     }
; 235  :     return;
; 236  : }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
DoPatch	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\backptch.c
_TEXT	SEGMENT
max_disp$1 = 64
disp$2 = 64
sym$ = 64
BackPatch PROC

; 249  : {

$LN86:
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H

; 250  :     struct fixup     *fixup;
; 251  :     struct fixup     *next;
; 252  : #ifdef DEBUG_OUT
; 253  :     uint_32 oldofs = sym->offset;
; 254  : #endif
; 255  : 
; 256  :     DebugMsg1(("BackPatch(%s): location=%s:%X, bp_fixup=%p\n", sym->name, sym->segment ? sym->segment->name : "!NULL!", sym->offset, sym->bp_fixup ));
; 257  : 
; 258  :     for( fixup = sym->bp_fixup; fixup; fixup = next ) {

	mov	rdi, QWORD PTR [rcx+88]
	mov	rsi, rcx
	test	rdi, rdi
	je	$LN80@BackPatch
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rbp
	mov	ebp, DWORD PTR disp$2[rsp]
	mov	QWORD PTR [rsp+88], r14
	mov	r14d, DWORD PTR max_disp$1[rsp]
	mov	QWORD PTR [rsp+32], r15
	npad	12
$LL4@BackPatch:

; 259  :         next = fixup->nextbp;
; 260  :         DoPatch( sym, fixup );

	mov	r8, QWORD PTR [rsi+24]
	mov	r15, QWORD PTR [rdi]
	test	r8, r8
	je	$LN2@BackPatch
	cmp	QWORD PTR [rdi+48], r8
	jne	$LN2@BackPatch
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN34@BackPatch
	cmp	DWORD PTR [rsi+36], 130			; 00000082H
	jne	SHORT $LN30@BackPatch
	cmp	DWORD PTR [rdi+28], 4
	jne	SHORT $LN30@BackPatch
	mov	BYTE PTR ModuleInfo+422, 1
	xor	ecx, ecx
	inc	DWORD PTR [rsi+16]
	call	OutputByte
	jmp	$LN25@BackPatch
$LN30@BackPatch:
	mov	eax, DWORD PTR [rdi+24]
	cmp	eax, 2
	jl	SHORT $LN34@BackPatch
	cmp	eax, 3
	jle	$LN25@BackPatch
	cmp	eax, 4
	jne	SHORT $LN34@BackPatch
	cmp	DWORD PTR [rdi+28], 5
	jne	SHORT $LN34@BackPatch
	lea	edx, QWORD PTR [rax-3]
	jmp	SHORT $patch$87
$LN34@BackPatch:
	mov	ecx, DWORD PTR [rdi+24]
	xor	edx, edx
	sub	ecx, 1
	je	SHORT $LN37@BackPatch
	sub	ecx, 1
	je	SHORT $LN36@BackPatch
	cmp	ecx, 1
	jne	$LN2@BackPatch
	mov	edx, 2
$LN36@BackPatch:
	inc	edx
$LN37@BackPatch:
	mov	rax, QWORD PTR [rdi+56]
	inc	edx
	mov	r14d, 1
	mov	ebp, DWORD PTR [rax+16]
	lea	ecx, DWORD PTR [rdx*8-1]
	sub	ebp, DWORD PTR [rdi+20]
	add	ebp, DWORD PTR [rdi+16]
	sub	ebp, edx
	shl	r14d, cl
	dec	ebp
	dec	r14d
	cmp	ebp, r14d
	jg	SHORT $patch$87
	or	eax, -1
	sub	eax, r14d
	cmp	ebp, eax
	jge	$LN25@BackPatch
$patch$87:
	mov	BYTE PTR ModuleInfo+422, 1
	sub	edx, 1
	je	SHORT $LN40@BackPatch
	sub	edx, 1
	je	SHORT $LN53@BackPatch
	cmp	edx, 2
	jne	$LN25@BackPatch
$LN53@BackPatch:
	mov	edx, 53					; 00000035H
	mov	r8d, ebp
	sub	r8d, r14d
	lea	ecx, QWORD PTR [rdx-49]
	call	EmitWarn
	jmp	$LN25@BackPatch
$LN40@BackPatch:
	mov	ecx, DWORD PTR [rdi+28]
	xor	ebx, ebx
	sub	ecx, 1
	je	$LN2@BackPatch
	sub	ecx, 1
	je	SHORT $LN42@BackPatch
	cmp	ecx, 1
	je	SHORT $LN43@BackPatch
	jmp	SHORT $LN44@BackPatch
$LN42@BackPatch:
	mov	ebx, 1
$LN43@BackPatch:
	inc	ebx
$LN44@BackPatch:
	mov	rdx, QWORD PTR [r8+96]
	cmp	BYTE PTR [rdx+104], 0
	je	SHORT $LN45@BackPatch
	add	ebx, 2
$LN45@BackPatch:
	inc	ebx
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN62@BackPatch
	mov	rcx, QWORD PTR [rdx+40]
	test	rcx, rcx
	je	SHORT $LN62@BackPatch
$LL17@BackPatch:
	test	BYTE PTR [rcx+33], 2
	jne	SHORT $LN2@BackPatch
	mov	eax, DWORD PTR [rdi+20]
	cmp	DWORD PTR [rcx+20], eax
	jbe	SHORT $LN62@BackPatch
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	jne	SHORT $LL17@BackPatch
$LN62@BackPatch:
	mov	rcx, QWORD PTR [rdx+32]
	test	rcx, rcx
	je	SHORT $LN82@BackPatch
$LL20@BackPatch:
	mov	eax, DWORD PTR [rcx+16]
	cmp	eax, DWORD PTR [rdi+20]
	jbe	SHORT $LN82@BackPatch
	add	eax, ebx
	mov	DWORD PTR [rcx+16], eax
	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL20@BackPatch
$LN82@BackPatch:
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN83@BackPatch
	mov	rax, QWORD PTR [r8+96]
	mov	rax, QWORD PTR [rax+40]
	test	rax, rax
	je	SHORT $LN83@BackPatch
$LL23@BackPatch:
	cmp	QWORD PTR [rax+56], rsi
	je	SHORT $LN21@BackPatch
	mov	ecx, DWORD PTR [rax+20]
	cmp	ecx, DWORD PTR [rdi+20]
	jbe	SHORT $LN83@BackPatch
	add	ecx, ebx
	mov	DWORD PTR [rax+20], ecx
$LN21@BackPatch:
	mov	rax, QWORD PTR [rax+8]
	test	rax, rax
	jne	SHORT $LL23@BackPatch
$LN83@BackPatch:
	test	ebx, ebx
	je	SHORT $LN25@BackPatch
$LL26@BackPatch:
	mov	cl, 204					; 000000ccH
	call	OutputByte
	add	ebx, -1					; ffffffffH
	jne	SHORT $LL26@BackPatch
$LN25@BackPatch:
	mov	rcx, rdi
	call	FreeFixup
$LN2@BackPatch:

; 250  :     struct fixup     *fixup;
; 251  :     struct fixup     *next;
; 252  : #ifdef DEBUG_OUT
; 253  :     uint_32 oldofs = sym->offset;
; 254  : #endif
; 255  : 
; 256  :     DebugMsg1(("BackPatch(%s): location=%s:%X, bp_fixup=%p\n", sym->name, sym->segment ? sym->segment->name : "!NULL!", sym->offset, sym->bp_fixup ));
; 257  : 
; 258  :     for( fixup = sym->bp_fixup; fixup; fixup = next ) {

	mov	rdi, r15
	test	r15, r15
	jne	$LL4@BackPatch

; 268  : #ifdef DEBUG_OUT
; 269  :     if ( oldofs != sym->offset )
; 270  :         DebugMsg1(("BackPatch(%s) exit, new ofs=%X\n", sym->name, sym->offset ));
; 271  : #endif
; 272  :     return( NOT_ERROR );

	mov	r14, QWORD PTR [rsp+88]
	xor	eax, eax
	mov	rbp, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+72]
	mov	QWORD PTR [rsi+88], r15
	mov	r15, QWORD PTR [rsp+32]

; 273  : }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
$LN80@BackPatch:

; 261  :     }
; 262  :     /* fixme: to clear field bp_fixup may cause memory leaks, since not all fixups are freed here.
; 263  :      * usually no problem, because FASTMEM is true ( that is, LclFree() is a NOP ).
; 264  :      * the problem is that these fixups are in 2 queues, one starts in sym.bp_fixup,
; 265  :      * the other start in CurrSeg.FixupList.
; 266  :      */
; 267  :     sym->bp_fixup = NULL;

	mov	QWORD PTR [rcx+88], 0

; 268  : #ifdef DEBUG_OUT
; 269  :     if ( oldofs != sym->offset )
; 270  :         DebugMsg1(("BackPatch(%s) exit, new ofs=%X\n", sym->name, sym->offset ));
; 271  : #endif
; 272  :     return( NOT_ERROR );

	xor	eax, eax

; 273  : }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
BackPatch ENDP
_TEXT	ENDS
END
