; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	hTrmem:QWORD
COMM	FileTrmem:QWORD
_DATA	ENDS
CONST	SEGMENT
MSG_OUT_OF_MEMORY DB 'Tracker out of memory', 00H
	ORG $+2
MSG_CHUNK_BYTE_UNFREED DB '%U chunks (%L bytes) unfreed', 00H
	ORG $+3
MSG_SIZE_ZERO DB '%W size zero', 00H
	ORG $+3
MSG_OVERRUN_ALLOCATION DB '%W %D overrun allocation by %C of %U bytes', 00H
	ORG $+5
MSG_UNOWNED_CHUNK DB '%W unowned chunk %D', 00H
	ORG $+4
MSG_NULL_PTR DB	'%W NULL pointer', 00H
MSG_NO_ROUTINE DB 'Tracker was not given a %S routine!', 00H
	ORG $+4
MSG_NOT_IN_ALLOCATION DB '%W %D not in any allocation', 00H
	ORG $+4
MSG_OVERRUN_2 DB '%W %D+%U overruns allocation %D+%U', 00H
	ORG $+5
MSG_PRT_USAGE DB 'Current usage: %L bytes; Peak usage: %L bytes', 00H
	ORG $+2
MSG_MIN_ALLOC DB '%W allocation of %U less than minimum size', 00H
	ORG $+5
MSG_PRT_LIST_1 DB '  Who      Addr     Size     Call     Contents', 00H
	ORG $+1
MSG_PRT_LIST_2 DB '======== ======== ======== ======== =================='
	DB	'=========================', 00H
MSG_PRT_LIST_3 DB '%C %D %U %L %X', 00H
CONST	ENDS
_DATA	SEGMENT
$SG7198	DB	'0123456789abcdef', 00H
	ORG $+7
$SG7442	DB	'Validate', 00H
	ORG $+3
$SG7478	DB	'Alloc', 00H
	ORG $+2
$SG7480	DB	'Alloc', 00H
	ORG $+2
$SG7609	DB	'Expand', 00H
	ORG $+1
$SG7703	DB	'w', 00H
	ORG $+2
$SG7515	DB	'Validate', 00H
	ORG $+7
$SG7516	DB	'Validate', 00H
	ORG $+3
$SG7530	DB	'Free', 00H
	ORG $+3
$SG7532	DB	'Free', 00H
	ORG $+3
$SG7533	DB	'Free', 00H
	ORG $+7
$SG7599	DB	'Realloc', 00H
$SG7647	DB	'ChkRange', 00H
	ORG $+7
$SG7650	DB	'ChkRange', 00H
	ORG $+7
$SG7651	DB	'ChkRange', 00H
	ORG $+7
$SG7704	DB	'~hjwasm.trk', 00H
	ORG $+4
$SG7706	DB	'tm_Init: _trmem_open() failed', 0aH, 00H
	ORG $+1
$SG7707	DB	'tm_Init: fopen("~hjwasm.trk") failed [%u]', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	printf
PUBLIC	_trmem_open
PUBLIC	_trmem_close
PUBLIC	_trmem_alloc
PUBLIC	_trmem_free
PUBLIC	_trmem_realloc
PUBLIC	_trmem_expand
PUBLIC	_trmem_strdup
PUBLIC	_trmem_msize
PUBLIC	_trmem_prt_usage
PUBLIC	_trmem_prt_list
PUBLIC	_trmem_get_current_usage
PUBLIC	_trmem_get_peak_usage
PUBLIC	_trmem_guess_who
PUBLIC	_trmem_validate_all
PUBLIC	_trmem_set_min_alloc
PUBLIC	_trmem_validate
PUBLIC	_trmem_chk_range
PUBLIC	_trmem_whoami
PUBLIC	tm_Init
PUBLIC	tm_Fini
EXTRN	__acrt_iob_func:PROC
EXTRN	fclose:PROC
EXTRN	fopen:PROC
EXTRN	fwrite:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	_errno:PROC
EXTRN	exit:PROC
EXTRN	isprint:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__ImageBase:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+83
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$_trmem_open DD imagerel $LN5
	DD	imagerel $LN5+130
	DD	imagerel $unwind$_trmem_open
$pdata$_trmem_close DD imagerel $LN46
	DD	imagerel $LN46+44
	DD	imagerel $unwind$_trmem_close
$pdata$1$_trmem_close DD imagerel $LN46+44
	DD	imagerel $LN46+202
	DD	imagerel $chain$1$_trmem_close
$pdata$2$_trmem_close DD imagerel $LN46+202
	DD	imagerel $LN46+228
	DD	imagerel $chain$2$_trmem_close
$pdata$3$_trmem_close DD imagerel $LN46+228
	DD	imagerel $LN46+356
	DD	imagerel $chain$3$_trmem_close
$pdata$4$_trmem_close DD imagerel $LN46+356
	DD	imagerel $LN46+406
	DD	imagerel $chain$4$_trmem_close
$pdata$_trmem_alloc DD imagerel $LN18
	DD	imagerel $LN18+282
	DD	imagerel $unwind$_trmem_alloc
$pdata$_trmem_free DD imagerel $LN27
	DD	imagerel $LN27+287
	DD	imagerel $unwind$_trmem_free
$pdata$_trmem_realloc DD imagerel $LN4
	DD	imagerel $LN4+35
	DD	imagerel $unwind$_trmem_realloc
$pdata$_trmem_expand DD imagerel $LN4
	DD	imagerel $LN4+35
	DD	imagerel $unwind$_trmem_expand
$pdata$_trmem_strdup DD imagerel $LN7
	DD	imagerel $LN7+94
	DD	imagerel $unwind$_trmem_strdup
$pdata$_trmem_prt_list DD imagerel $LN16
	DD	imagerel $LN16+187
	DD	imagerel $unwind$_trmem_prt_list
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$isValidChunk DD imagerel isValidChunk
	DD	imagerel isValidChunk+92
	DD	imagerel $unwind$isValidChunk
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$trPrt DD	imagerel trPrt
	DD	imagerel trPrt+56
	DD	imagerel $unwind$trPrt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$trPrt DD imagerel trPrt+56
	DD	imagerel trPrt+814
	DD	imagerel $chain$4$trPrt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$trPrt DD imagerel trPrt+814
	DD	imagerel trPrt+948
	DD	imagerel $chain$5$trPrt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$allocEntry DD imagerel allocEntry
	DD	imagerel allocEntry+64
	DD	imagerel $unwind$allocEntry
pdata	ENDS
pdata	SEGMENT
$pdata$_trmem_validate_all DD imagerel $LN18
	DD	imagerel $LN18+124
	DD	imagerel $unwind$_trmem_validate_all
$pdata$_trmem_validate DD imagerel $LN22
	DD	imagerel $LN22+147
	DD	imagerel $unwind$_trmem_validate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ChangeAlloc DD imagerel ChangeAlloc
	DD	imagerel ChangeAlloc+68
	DD	imagerel $unwind$ChangeAlloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ChangeAlloc DD imagerel ChangeAlloc+68
	DD	imagerel ChangeAlloc+485
	DD	imagerel $chain$0$ChangeAlloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ChangeAlloc DD imagerel ChangeAlloc+485
	DD	imagerel ChangeAlloc+505
	DD	imagerel $chain$1$ChangeAlloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ChangeAlloc DD imagerel ChangeAlloc+505
	DD	imagerel ChangeAlloc+668
	DD	imagerel $chain$2$ChangeAlloc
pdata	ENDS
pdata	SEGMENT
$pdata$_trmem_chk_range DD imagerel $LN27
	DD	imagerel $LN27+274
	DD	imagerel $unwind$_trmem_chk_range
$pdata$tm_Init DD imagerel $LN13
	DD	imagerel $LN13+202
	DD	imagerel $unwind$tm_Init
$pdata$tm_Fini DD imagerel $LN4
	DD	imagerel $LN4+44
	DD	imagerel $unwind$tm_Fini
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ChangeAlloc DD 020021H
	DD	0a7400H
	DD	imagerel ChangeAlloc
	DD	imagerel ChangeAlloc+68
	DD	imagerel $unwind$ChangeAlloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ChangeAlloc DD 021H
	DD	imagerel ChangeAlloc
	DD	imagerel ChangeAlloc+68
	DD	imagerel $unwind$ChangeAlloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ChangeAlloc DD 020521H
	DD	0a7405H
	DD	imagerel ChangeAlloc
	DD	imagerel ChangeAlloc+68
	DD	imagerel $unwind$ChangeAlloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ChangeAlloc DD 081301H
	DD	0c5413H
	DD	0b3413H
	DD	0f00f5213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$allocEntry DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$trPrt DD 021H
	DD	imagerel trPrt
	DD	imagerel trPrt+56
	DD	imagerel $unwind$trPrt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$trPrt DD 0a2521H
	DD	013e425H
	DD	014d41bH
	DD	015c410H
	DD	016740cH
	DD	0176404H
	DD	imagerel trPrt
	DD	imagerel trPrt+56
	DD	imagerel $unwind$trPrt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$trPrt DD 051a01H
	DD	018011aH
	DD	05011f013H
	DD	03010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$isValidChunk DD 020601H
	DD	030027206H
xdata	ENDS
xdata	SEGMENT
$unwind$_trmem_open DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$_trmem_close DD 060d01H
	DD	0e340dH
	DD	0f009720dH
	DD	060067007H
$chain$1$_trmem_close DD 040a21H
	DD	0de40aH
	DD	0c5405H
	DD	imagerel $LN46
	DD	imagerel $LN46+44
	DD	imagerel $unwind$_trmem_close
$chain$2$_trmem_close DD 021H
	DD	imagerel $LN46
	DD	imagerel $LN46+44
	DD	imagerel $unwind$_trmem_close
$chain$3$_trmem_close DD 040021H
	DD	0de400H
	DD	0c5400H
	DD	imagerel $LN46
	DD	imagerel $LN46+44
	DD	imagerel $unwind$_trmem_close
$chain$4$_trmem_close DD 021H
	DD	imagerel $LN46
	DD	imagerel $LN46+44
	DD	imagerel $unwind$_trmem_close
$unwind$_trmem_alloc DD 0a5d01H
	DD	09e45dH
	DD	086458H
	DD	0b540fH
	DD	0a340fH
	DD	0700b520fH
$unwind$_trmem_free DD 069101H
	DD	0a6491H
	DD	0b340aH
	DD	07006720aH
$unwind$_trmem_realloc DD 010401H
	DD	06204H
$unwind$_trmem_expand DD 010401H
	DD	06204H
$unwind$_trmem_strdup DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$_trmem_prt_list DD 063601H
	DD	0a7436H
	DD	0b340aH
	DD	06006720aH
$unwind$_trmem_validate_all DD 040a01H
	DD	0a340aH
	DD	07006720aH
$unwind$_trmem_validate DD 010401H
	DD	08204H
$unwind$_trmem_chk_range DD 040a01H
	DD	0a340aH
	DD	07006720aH
$unwind$tm_Init DD 020601H
	DD	030023206H
$unwind$tm_Fini DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
tm_Fini	PROC

; 790  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 791  :     /* if tm_Fini() is called, both hTrmem & memFile are != NULL */
; 792  :     _trmem_prt_list( hTrmem );

	mov	rcx, QWORD PTR hTrmem
	call	_trmem_prt_list

; 793  :     _trmem_close( hTrmem );

	mov	rcx, QWORD PTR hTrmem
	call	_trmem_close

; 794  :     fclose( FileTrmem );

	mov	rcx, QWORD PTR FileTrmem

; 795  : }

	add	rsp, 40					; 00000028H

; 794  :     fclose( FileTrmem );

	jmp	fclose
tm_Fini	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
tm_Init	PROC

; 773  : {

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H

; 774  :     if ( FileTrmem = fopen( TRMEM_LOGFN, "w" ) ) {

	lea	rdx, OFFSET FLAT:$SG7703
	lea	rcx, OFFSET FLAT:$SG7704
	call	fopen
	mov	QWORD PTR FileTrmem, rax
	mov	rbx, rax
	test	rax, rax
	je	$LN2@tm_Init

; 775  :         //hTrmem = _trmem_open( malloc, free, realloc, _expand, memFile, memLine,
; 776  :         hTrmem = _trmem_open( malloc, free, _TRMEM_NO_REALLOC, _TRMEM_NO_REALLOC, FileTrmem, memLine,

	mov	ecx, 88					; 00000058H
	call	malloc
	test	rax, rax
	je	SHORT $LN11@tm_Init
	lea	rcx, OFFSET FLAT:malloc
	mov	QWORD PTR [rax+56], rbx
	mov	QWORD PTR [rax+24], rcx
	lea	rdx, OFFSET FLAT:memLine
	lea	rcx, OFFSET FLAT:free
	mov	QWORD PTR [rax+64], rdx
	mov	QWORD PTR [rax+32], rcx
	xor	ecx, ecx
	mov	QWORD PTR [rax+40], rcx
	mov	QWORD PTR [rax+48], rcx
	mov	QWORD PTR [rax], rcx
	mov	QWORD PTR [rax+8], rcx
	mov	QWORD PTR [rax+80], rcx
	mov	DWORD PTR [rax+16], ecx
	mov	DWORD PTR [rax+72], 57			; 00000039H
	mov	QWORD PTR hTrmem, rax

; 785  :     }
; 786  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN11@tm_Init:

; 775  :         //hTrmem = _trmem_open( malloc, free, realloc, _expand, memFile, memLine,
; 776  :         hTrmem = _trmem_open( malloc, free, _TRMEM_NO_REALLOC, _TRMEM_NO_REALLOC, FileTrmem, memLine,

	xor	ecx, ecx
	mov	QWORD PTR hTrmem, rcx

; 777  :                   _TRMEM_ALLOC_SIZE_0 | _TRMEM_FREE_NULL | _TRMEM_OUT_OF_MEMORY | _TRMEM_CLOSE_CHECK_FREE );
; 778  :         if( hTrmem == NULL ) {
; 779  :             printf("tm_Init: _trmem_open() failed\n" );

	lea	rcx, OFFSET FLAT:$SG7706
	call	printf

; 780  :             exit( EXIT_FAILURE );

	mov	ecx, 1
	call	exit
	int	3
$LN2@tm_Init:

; 781  :         }
; 782  :     } else {
; 783  :         printf("tm_Init: fopen(\"" TRMEM_LOGFN "\") failed [%u]\n", errno );

	call	_errno
	lea	rcx, OFFSET FLAT:$SG7707
	mov	edx, DWORD PTR [rax]
	call	printf

; 784  :         exit( EXIT_FAILURE );

	mov	ecx, 1
	call	exit
	int	3
$LN10@tm_Init:
tm_Init	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
fh$ = 8
buf$ = 16
size$ = 24
memLine	PROC

; 765  : {

	mov	rax, rdx

; 766  :     //fwrite( "***",1, 3, stderr );
; 767  :     //fwrite( buf, 1, size, stderr );
; 768  :     fwrite( buf, 1, size, fh );

	mov	r8d, r8d
	mov	r9, rcx
	mov	edx, 1
	mov	rcx, rax
	jmp	fwrite
memLine	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
_trmem_whoami PROC

; 749  :     return 0;

	xor	eax, eax

; 750  : }

	ret	0
_trmem_whoami ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
start$ = 80
len$ = 88
who$ = 96
hdl$ = 104
_trmem_chk_range PROC

; 658  : {

$LN27:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, r9
	mov	rbx, rcx
	mov	r9, r8

; 659  :     entry_ptr   tr;
; 660  :     void        *end;
; 661  :     void        *end_of_mem;
; 662  : 
; 663  :     tr = hdl->alloc_list;

	mov	rax, QWORD PTR [rdi]

; 664  :     for(;;) {
; 665  :         if( tr == 0 ) {

	test	rax, rax
	je	SHORT $LN20@trmem_chk_
	npad	5
$LL2@trmem_chk_:

; 669  :         }
; 670  :         end_of_mem = _PtrAdd( tr->mem, getSize( tr ) );

	mov	r10, QWORD PTR [rax+8]
	mov	r11, QWORD PTR [rax+24]
	xor	r11, QWORD PTR [rax+16]
	xor	r11, r10
	xor	r11, rax
	add	r11, r10

; 671  :         if( _PtrCmp( start, >=, tr->mem ) &&

	cmp	rcx, r10
	jb	SHORT $LN6@trmem_chk_
	cmp	rcx, r11
	jb	SHORT $LN21@trmem_chk_
$LN6@trmem_chk_:

; 672  :             _PtrCmp( start, < , end_of_mem ) ) break;
; 673  :         tr = tr->next;

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL2@trmem_chk_
$LN20@trmem_chk_:

; 666  :             trPrt( hdl, MSG_NOT_IN_ALLOCATION, "ChkRange", who,

	mov	QWORD PTR [rsp+32], rcx
	lea	r8, OFFSET FLAT:$SG7647
	mov	rcx, rdi
	lea	rdx, OFFSET FLAT:MSG_NOT_IN_ALLOCATION
	call	trPrt

; 667  :                 start );
; 668  :             return( 0 );

	xor	eax, eax

; 682  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN21@trmem_chk_:

; 674  :     }
; 675  :     end = _PtrAdd( start, len );

	add	rcx, rdx

; 676  :     if( _PtrCmp( end, >, end_of_mem ) ) {

	cmp	rcx, r11

; 677  :         trPrt( hdl, MSG_OVERRUN_2, "ChkRange", who,

	mov	rcx, QWORD PTR [rax+24]
	jbe	SHORT $LN7@trmem_chk_
	xor	rcx, QWORD PTR [rax+16]
	lea	r8, OFFSET FLAT:$SG7650
	xor	rcx, r10
	xor	rcx, rax
	mov	QWORD PTR [rsp+56], rcx
	mov	rcx, rdi
	mov	QWORD PTR [rsp+48], r10
	mov	QWORD PTR [rsp+40], rdx
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_2
	mov	QWORD PTR [rsp+32], rbx
	call	trPrt
	xor	eax, eax

; 682  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN7@trmem_chk_:

; 678  :             start, len, tr->mem, getSize( tr ) );
; 679  :         return( 0 );
; 680  :     }
; 681  :     return( isValidChunk( tr, "ChkRange", who, hdl ) );

	mov	r8, QWORD PTR [rax+16]
	xor	rcx, r10
	xor	rcx, r8
	xor	rcx, rax
	cmp	BYTE PTR [r10+rcx], 165			; 000000a5H
	je	SHORT $LN14@trmem_chk_
	mov	QWORD PTR [rsp+48], rcx
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_ALLOCATION
	mov	QWORD PTR [rsp+40], r8
	mov	rcx, rdi
	lea	r8, OFFSET FLAT:$SG7651
	mov	QWORD PTR [rsp+32], r10
	call	trPrt
	xor	eax, eax

; 682  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0

; 678  :             start, len, tr->mem, getSize( tr ) );
; 679  :         return( 0 );
; 680  :     }
; 681  :     return( isValidChunk( tr, "ChkRange", who, hdl ) );

$LN14@trmem_chk_:
	mov	eax, 1

; 682  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
_trmem_chk_range ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
;	COMDAT ChangeAlloc
_TEXT	SEGMENT
old$ = 80
size$ = 88
who$ = 96
hdl$ = 104
fn$ = 112
name$ = 120
ChangeAlloc PROC					; COMDAT

; 540  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 541  :     entry_ptr   tr;
; 542  :     void *      new_block;
; 543  :     size_t      old_size;
; 544  : 
; 545  :     if( fn == (void *) _TRMEM_NO_ROUTINE ) {

	mov	r15, QWORD PTR fn$[rsp]
	mov	rbx, r9
	mov	r14, r8
	mov	rbp, rdx
	mov	rsi, rcx
	test	r15, r15
	jne	SHORT $LN2@ChangeAllo

; 546  :         trPrt( hdl, MSG_NO_ROUTINE, name );

	mov	r8, QWORD PTR name$[rsp]
	lea	rdx, OFFSET FLAT:MSG_NO_ROUTINE
	mov	rcx, rbx
	call	trPrt

; 547  :         return( NULL );

	xor	eax, eax
	jmp	$LN1@ChangeAllo
$LN2@ChangeAllo:
	mov	QWORD PTR [rsp+80], rdi

; 548  :     }
; 549  : 
; 550  :     if( size == 0 ) {

	test	rdx, rdx
	jne	$LN3@ChangeAllo

; 551  :         if( hdl->flags & _TRMEM_REALLOC_SIZE_0 ) {

	test	BYTE PTR [r9+72], 2
	mov	rbp, QWORD PTR name$[rsp]
	je	SHORT $LN4@ChangeAllo

; 552  :             trPrt( hdl, MSG_SIZE_ZERO, name, who );

	mov	r9, r8
	lea	rdx, OFFSET FLAT:MSG_SIZE_ZERO
	mov	r8, rbp
	mov	rcx, rbx
	call	trPrt
$LN4@ChangeAllo:

; 553  :         }
; 554  :         if( old == NULL ) {

	test	rsi, rsi
	jne	SHORT $LN5@ChangeAllo

; 555  :             if( hdl->flags & _TRMEM_REALLOC_NULL ) {

	test	BYTE PTR [rbx+72], 4
	je	SHORT $LN6@ChangeAllo

; 556  :                 trPrt( hdl, MSG_NULL_PTR, name, who );

	mov	r9, r14
	lea	rdx, OFFSET FLAT:MSG_NULL_PTR
	mov	r8, rbp
	mov	rcx, rbx
	call	trPrt
$LN6@ChangeAllo:

; 557  :             }
; 558  :             return( fn( NULL, 0 ) );

	xor	edx, edx
	xor	ecx, ecx
	call	r15
	jmp	$LN58@ChangeAllo
$LN5@ChangeAllo:

; 559  :         }
; 560  : 
; 561  :         /* old != NULL */
; 562  :         tr = removeFromList( old, hdl );

	cmp	QWORD PTR [rbx], 0
	mov	rcx, rbx
	je	SHORT $LN56@ChangeAllo
	npad	8
$LL21@ChangeAllo:
	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rax+8], rsi
	je	SHORT $LN48@ChangeAllo
	cmp	QWORD PTR [rax], 0
	mov	rcx, rax
	jne	SHORT $LL21@ChangeAllo
$LN56@ChangeAllo:

; 563  :         if( tr == NULL ) {
; 564  :             trPrt( hdl, MSG_UNOWNED_CHUNK, name, who, old );

	mov	r9, r14
	mov	r8, rbp

; 565  :             return( NULL );

	jmp	$LN59@ChangeAllo
$LN48@ChangeAllo:

; 559  :         }
; 560  : 
; 561  :         /* old != NULL */
; 562  :         tr = removeFromList( old, hdl );

	mov	rdi, rax

; 566  :         }
; 567  :         isValidChunk( tr, name, who, hdl );

	mov	r9, rbx
	mov	rax, QWORD PTR [rax]
	mov	r8, r14
	mov	QWORD PTR [rcx], rax
	mov	rdx, rbp
	mov	rcx, rdi
	call	isValidChunk

; 568  :         size = getSize( tr );

	mov	r8, QWORD PTR [rdi+24]

; 569  :         hdl->mem_used -= size;
; 570  :         MEMSET( old, FREED_BYTE, size + 1 );

	mov	edx, 189				; 000000bdH
	xor	r8, QWORD PTR [rdi+16]
	mov	rcx, rsi
	xor	r8, QWORD PTR [rdi+8]
	xor	r8, rdi
	sub	DWORD PTR [rbx+8], r8d
	inc	r8
	call	memset

; 571  :         freeEntry( tr, hdl );

	mov	rcx, rdi
	call	QWORD PTR [rbx+32]

; 572  :         return( fn( old, 0 ) );

	xor	edx, edx
	mov	rcx, rsi
	call	r15
	jmp	$LN58@ChangeAllo
$LN3@ChangeAllo:

; 573  :     }
; 574  : 
; 575  :     /* size != 0 */
; 576  :     if( old == NULL ) {

	test	rcx, rcx
	jne	$LN8@ChangeAllo

; 577  :         if( hdl->flags & _TRMEM_REALLOC_NULL ) {

	test	BYTE PTR [r9+72], 4
	je	SHORT $LN9@ChangeAllo

; 578  :             trPrt( hdl, MSG_NULL_PTR, name, who );

	mov	r9, r8
	lea	rdx, OFFSET FLAT:MSG_NULL_PTR
	mov	r8, QWORD PTR name$[rsp]
	mov	rcx, rbx
	call	trPrt
$LN9@ChangeAllo:

; 579  :         }
; 580  :         new_block = fn( NULL, size + 1 );

	lea	rdx, QWORD PTR [rbp+1]
	xor	ecx, ecx
	call	r15
	mov	rdi, rax

; 581  :         if( new_block != NULL ) {

	test	rax, rax
	je	SHORT $LN12@ChangeAllo

; 582  :             MEMSET( new_block, ALLOC_BYTE, size + 1 );

	lea	r8, QWORD PTR [rbp+1]
	mov	edx, 165				; 000000a5H
	mov	rcx, rax
	call	memset

; 583  :             tr = allocEntry( hdl );

	mov	rcx, rbx
	call	allocEntry

; 584  :             if( tr != NULL ) {

	test	rax, rax
	je	SHORT $LN31@ChangeAllo

; 585  :                 tr->mem = new_block;

	mov	QWORD PTR [rax+8], rdi

; 586  :                 tr->who = who;
; 587  :                 setSize( tr, size );

	mov	rcx, rdi
	xor	rcx, rax
	mov	QWORD PTR [rax+16], r14
	xor	rcx, rbp
	xor	rcx, r14
	mov	QWORD PTR [rax+24], rcx

; 588  :                 addToList( tr, hdl );

	mov	rcx, QWORD PTR [rbx]
	mov	QWORD PTR [rax], rcx
	mov	QWORD PTR [rbx], rax
$LN31@ChangeAllo:

; 589  :             }
; 590  :             hdl->mem_used += size;

	add	DWORD PTR [rbx+8], ebp
	mov	eax, DWORD PTR [rbx+8]

; 591  :             if( hdl->mem_used > hdl->max_mem ) {

	cmp	eax, DWORD PTR [rbx+12]
	jbe	SHORT $LN12@ChangeAllo

; 592  :                 hdl->max_mem = hdl->mem_used;

	mov	DWORD PTR [rbx+12], eax
$LN12@ChangeAllo:

; 593  :             }
; 594  :         }
; 595  :         return( new_block );

	mov	rax, rdi
	jmp	SHORT $LN58@ChangeAllo
$LN8@ChangeAllo:

; 596  :     }
; 597  : 
; 598  :     /* old != NULL && size != 0 */
; 599  :     tr = removeFromList( old, hdl );

	cmp	QWORD PTR [r9], 0
	mov	rcx, rbx
	je	SHORT $LN57@ChangeAllo
$LL34@ChangeAllo:
	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rax+8], rsi
	je	SHORT $LN49@ChangeAllo
	cmp	QWORD PTR [rax], 0
	mov	rcx, rax
	jne	SHORT $LL34@ChangeAllo
$LN57@ChangeAllo:

; 600  :     if( tr == NULL ) {
; 601  :         trPrt( hdl, MSG_UNOWNED_CHUNK, name, who, old );

	mov	r9, r8
	mov	r8, QWORD PTR name$[rsp]
$LN59@ChangeAllo:
	lea	rdx, OFFSET FLAT:MSG_UNOWNED_CHUNK
	mov	QWORD PTR [rsp+32], rsi
	mov	rcx, rbx
	call	trPrt
$LN60@ChangeAllo:

; 602  :         return( NULL );

	xor	eax, eax
$LN58@ChangeAllo:
	mov	rdi, QWORD PTR [rsp+80]
$LN1@ChangeAllo:

; 628  : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN49@ChangeAllo:

; 603  :     }
; 604  :     if( !isValidChunk( tr, name, who, hdl ) ) {

	mov	rdx, QWORD PTR name$[rsp]
	mov	rdi, rax
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rcx, rdi
	call	isValidChunk
	test	eax, eax
	je	SHORT $LN60@ChangeAllo

; 605  :         return( NULL );
; 606  :     }
; 607  :     new_block = fn( old, size + 1 );

	lea	rdx, QWORD PTR [rbp+1]
	mov	rcx, rsi
	call	r15
	mov	r15, rax

; 608  :     if( new_block == NULL ) {

	test	rax, rax
	jne	SHORT $LN15@ChangeAllo

; 609  :         addToList( tr, hdl );   /* put back on list without change */

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rdi], rax
	mov	QWORD PTR [rbx], rdi

; 610  :         return( new_block );

	jmp	SHORT $LN60@ChangeAllo
$LN15@ChangeAllo:

; 611  :     }
; 612  :     old_size = getSize( tr );

	mov	rsi, QWORD PTR [rdi+16]
	xor	rsi, rdi
	xor	rsi, QWORD PTR [rdi+24]
	xor	rsi, QWORD PTR [rdi+8]

; 613  :     if( size > old_size ) {

	cmp	rbp, rsi
	jbe	SHORT $LN16@ChangeAllo

; 614  :         MEMSET(_PtrAdd( new_block, old_size ), ALLOC_BYTE, size + 1 - old_size);

	mov	r8, rbp
	lea	rcx, QWORD PTR [rsi+rax]
	sub	r8, rsi
	mov	edx, 165				; 000000a5H
	inc	r8
	call	memset

; 615  :     } else {

	jmp	SHORT $LN17@ChangeAllo
$LN16@ChangeAllo:

; 616  :         *(unsigned char *)_PtrAdd( new_block, size ) = ALLOC_BYTE;

	mov	BYTE PTR [rax+rbp], 165			; 000000a5H
$LN17@ChangeAllo:

; 617  :     }
; 618  :     hdl->mem_used -= old_size;
; 619  :     hdl->mem_used += size;

	mov	eax, ebp
	sub	eax, esi
	add	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR [rbx+8]

; 620  :     if( hdl->mem_used > hdl->max_mem ) {

	cmp	eax, DWORD PTR [rbx+12]
	jbe	SHORT $LN18@ChangeAllo

; 621  :         hdl->max_mem = hdl->mem_used;

	mov	DWORD PTR [rbx+12], eax
$LN18@ChangeAllo:

; 622  :     }
; 623  :     tr->mem = new_block;

	mov	QWORD PTR [rdi+8], r15

; 624  :     tr->who = who;
; 625  :     setSize( tr, size );

	mov	rax, rdi
	xor	rax, r15
	mov	QWORD PTR [rdi+16], r14
	xor	rax, rbp
	xor	rax, r14
	mov	QWORD PTR [rdi+24], rax

; 626  :     addToList( tr, hdl );

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rdi], rax

; 627  :     return( new_block );

	mov	rax, r15
	mov	QWORD PTR [rbx], rdi
	jmp	$LN58@ChangeAllo
ChangeAlloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
mem$ = 80
who$ = 88
hdl$ = 96
_trmem_validate PROC

; 498  : {

$LN22:
	sub	rsp, 72					; 00000048H

; 499  :     entry_ptr tr;
; 500  : 
; 501  :     tr = findOnList( mem, hdl );

	mov	rax, QWORD PTR [r8]
	mov	r10, r8
	mov	r9, rdx
	test	rax, rax
	je	SHORT $LN19@trmem_vali
$LL5@trmem_vali:
	cmp	QWORD PTR [rax+8], rcx
	je	SHORT $LN2@trmem_vali
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL5@trmem_vali
$LN19@trmem_vali:

; 502  :     if( tr == NULL ) {
; 503  :         trPrt( hdl, MSG_UNOWNED_CHUNK, "Validate", who, mem );

	mov	QWORD PTR [rsp+32], rcx
	lea	r8, OFFSET FLAT:$SG7515
	mov	rcx, r10
	lea	rdx, OFFSET FLAT:MSG_UNOWNED_CHUNK
	call	trPrt

; 504  :         return( 0 );

	xor	eax, eax

; 507  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN2@trmem_vali:

; 505  :     }
; 506  :     return( isValidChunk( tr, "Validate", who, hdl ) );

	mov	rdx, QWORD PTR [rax+8]
	mov	r8, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [rax+24]
	xor	rcx, r8
	xor	rcx, rdx
	xor	rcx, rax
	cmp	BYTE PTR [rdx+rcx], 165			; 000000a5H
	je	SHORT $LN10@trmem_vali
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, r10
	mov	QWORD PTR [rsp+40], r8
	lea	r8, OFFSET FLAT:$SG7516
	mov	QWORD PTR [rsp+32], rdx
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_ALLOCATION
	call	trPrt
	xor	eax, eax

; 507  : }

	add	rsp, 72					; 00000048H
	ret	0

; 505  :     }
; 506  :     return( isValidChunk( tr, "Validate", who, hdl ) );

$LN10@trmem_vali:
	mov	eax, 1

; 507  : }

	add	rsp, 72					; 00000048H
	ret	0
_trmem_validate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
size$ = 8
hdl$ = 16
_trmem_set_min_alloc PROC

; 431  :     hdl->min_alloc = size;

	mov	QWORD PTR [rdx+80], rcx

; 432  : }

	ret	0
_trmem_set_min_alloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
hdl$ = 80
_trmem_validate_all PROC

; 378  : {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H

; 379  :     entry_ptr   walk;
; 380  :     int result = 1;
; 381  : 
; 382  :     walk = hdl->alloc_list;

	mov	rbx, QWORD PTR [rcx]
	mov	rdi, rcx
	mov	r8d, 1

; 383  :     while( walk ) {

	test	rbx, rbx
	je	SHORT $LN16@trmem_vali
	npad	5
$LL2@trmem_vali:

; 384  :         //printf("trmem_validate_all: item=%p, next=%p, mem=%p\n", walk, walk->next, walk->mem );
; 385  :         if( !isValidChunk( walk, "Validate", 0, hdl ) ) {

	mov	rdx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx+24]
	mov	r9, QWORD PTR [rbx+16]
	xor	rax, rdx
	xor	rax, r9
	xor	rax, rbx
	cmp	BYTE PTR [rdx+rax], 165			; 000000a5H
	je	SHORT $LN4@trmem_vali
	mov	QWORD PTR [rsp+48], rax
	lea	r8, OFFSET FLAT:$SG7442
	mov	QWORD PTR [rsp+40], r9
	mov	rcx, rdi
	mov	QWORD PTR [rsp+32], rdx
	xor	r9d, r9d
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_ALLOCATION
	call	trPrt

; 386  :             result = 0;

	xor	r8d, r8d
$LN4@trmem_vali:

; 387  :         }
; 388  :         walk = walk->next;

	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL2@trmem_vali
$LN16@trmem_vali:

; 389  :     }
; 390  :     return result;

	mov	eax, r8d

; 391  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
_trmem_validate_all ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
;	COMDAT removeFromList
_TEXT	SEGMENT
mem$ = 8
hdl$ = 16
removeFromList PROC					; COMDAT

; 329  :     entry_ptr_ptr   walk;
; 330  :     entry_ptr       found;
; 331  : 
; 332  :     walk = &hdl->alloc_list;
; 333  :     while( *walk ) {

	cmp	QWORD PTR [rdx], 0
	je	SHORT $LN3@removeFrom
$LL2@removeFrom:

; 334  :         //printf("removeFromList: item=%p, next=%p, mem=%p\n", *walk, (*walk)->next, (*walk)->mem );
; 335  :         if( _PtrCmp( (*walk)->mem, ==, mem ) ) {

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rax+8], rcx
	je	SHORT $LN7@removeFrom

; 338  :             return( found );
; 339  :         }
; 340  :         walk = &(*walk)->next;

	cmp	QWORD PTR [rax], 0
	mov	rdx, rax
	jne	SHORT $LL2@removeFrom
$LN3@removeFrom:

; 341  :     }
; 342  :     return( NULL );

	xor	eax, eax

; 343  : }

	ret	0
$LN7@removeFrom:

; 336  :             found = *walk;
; 337  :             *walk = found->next;

	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rdx], rcx

; 343  : }

	ret	0
removeFromList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
;	COMDAT findOnList
_TEXT	SEGMENT
mem$ = 8
hdl$ = 16
findOnList PROC						; COMDAT

; 314  :     entry_ptr       walk;
; 315  : 
; 316  :     walk = hdl->alloc_list;

	mov	rax, QWORD PTR [rdx]

; 317  :     while( walk ) {

	test	rax, rax
	je	SHORT $LN3@findOnList
$LL2@findOnList:

; 318  :         if( _PtrCmp( walk->mem, ==, mem ) ) {

	cmp	QWORD PTR [rax+8], rcx
	je	SHORT $LN1@findOnList

; 319  :             return( walk );
; 320  :         }
; 321  :         walk = walk->next;

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL2@findOnList
$LN3@findOnList:

; 322  :     }
; 323  :     return( NULL );

	xor	eax, eax
$LN1@findOnList:

; 324  : }

	ret	0
findOnList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
;	COMDAT addToList
_TEXT	SEGMENT
tr$ = 8
hdl$ = 16
addToList PROC						; COMDAT

; 308  :     tr->next = hdl->alloc_list;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 309  :     hdl->alloc_list = tr;

	mov	QWORD PTR [rdx], rcx

; 310  : }

	ret	0
addToList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
;	COMDAT freeEntry
_TEXT	SEGMENT
tr$ = 8
hdl$ = 16
freeEntry PROC						; COMDAT

; 303  :     hdl->free( tr );

	rex_jmp	QWORD PTR [rdx+32]
freeEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
;	COMDAT allocEntry
_TEXT	SEGMENT
hdl$ = 48
allocEntry PROC						; COMDAT

; 291  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 292  :     entry_ptr   tr;
; 293  : 
; 294  :     tr = (entry_ptr) hdl->alloc( sizeof( entry ) );

	mov	ecx, 40					; 00000028H
	call	QWORD PTR [rdi+24]
	mov	rbx, rax

; 295  :     if( tr == NULL && ( hdl->flags & _TRMEM_OUT_OF_MEMORY ) ) {

	test	rax, rax
	jne	SHORT $LN2@allocEntry
	test	BYTE PTR [rdi+72], 16
	je	SHORT $LN2@allocEntry

; 296  :         trPrt( hdl, MSG_OUT_OF_MEMORY );

	lea	rdx, OFFSET FLAT:MSG_OUT_OF_MEMORY
	mov	rcx, rdi
	call	trPrt

; 297  :     }
; 298  :     return( tr );

	mov	rax, rbx
$LN2@allocEntry:

; 299  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
allocEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
;	COMDAT trPrt
_TEXT	SEGMENT
buff$ = 32
hdl$ = 224
fmt$ = 232
trPrt	PROC						; COMDAT

; 192  : {

	mov	r11, rsp
	mov	QWORD PTR [r11+16], rdx
	mov	QWORD PTR [r11+24], r8
	mov	QWORD PTR [r11+32], r9
	push	rbx
	push	rbp
	push	r15
	sub	rsp, 192				; 000000c0H

; 207  :     ptr = buff;
; 208  :     for(;;) {
; 209  :         ch = *fmt++;

	movzx	eax, BYTE PTR [rdx]
	lea	r15, QWORD PTR [r11+24]
	inc	rdx
	lea	rbx, QWORD PTR buff$[rsp]
	mov	QWORD PTR [r11+16], rdx
	mov	rbp, rcx

; 210  :         if( ch == '\0' ) break;

	test	al, al
	je	$LN78@trPrt

; 193  :     va_list     args;
; 194  :     char        buff[100];
; 195  :     char *      ptr;
; 196  :     char        ch;
; 197  :     uint        ui;
; 198  :     uint_32     ul;
; 199  :     void        *dp;
; 200  :     _trmem_who  who;
; 201  :     char *      start;
; 202  :     char *      xptr;
; 203  :     int         i;
; 204  :     size_t      size;
; 205  : 
; 206  :     va_start( args, fmt );

	mov	QWORD PTR [r11-32], rsi
	add	r15, -8
	mov	QWORD PTR [r11-40], rdi
	mov	QWORD PTR [r11-48], r12
	lea	r12, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [r11-56], r13
	mov	r13d, 14
	mov	QWORD PTR [r11-64], r14
	npad	3
$LL2@trPrt:

; 211  :         if( ch == '%' ) {

	cmp	al, 37					; 00000025H
	jne	$LN14@trPrt

; 212  :             ch = *fmt++;

	movsx	r8d, BYTE PTR [rdx]
	inc	rdx
	mov	QWORD PTR fmt$[rsp], rdx

; 213  :             switch( ch ) {

	lea	eax, DWORD PTR [r8-67]
	cmp	eax, 21
	ja	$LN30@trPrt
	cdqe
	mov	ecx, DWORD PTR $LN126@trPrt[r12+rax*4]
	add	rcx, r12
	jmp	rcx
$LN16@trPrt:

; 214  :             case 'W':   /* "a1(a2):" */
; 215  :                 ptr = stpcpy( ptr, va_arg( args, const char * ) );

	mov	rdx, QWORD PTR [r15+8]
	mov	rcx, rbx
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rbx], al
	test	al, al
	je	SHORT $LN34@trPrt
	sub	rdx, rbx
	npad	10
$LL33@trPrt:
	movzx	eax, BYTE PTR [rdx+rcx+1]
	inc	rcx
	mov	BYTE PTR [rcx], al
	test	al, al
	jne	SHORT $LL33@trPrt
$LN34@trPrt:

; 216  :                 who = va_arg( args, _trmem_who );

	mov	rax, QWORD PTR [r15+16]
	add	r15, 16
	mov	rbx, rcx

; 217  :                 if( who != _TRMEM_NO_ROUTINE ) {

	test	rax, rax
	je	SHORT $LN17@trPrt

; 218  :                     *ptr++ = '(';

	mov	BYTE PTR [rcx], 40			; 00000028H

; 219  :                     ptr = formHex( ptr, (uint_32)who, sizeof( who ) );

	mov	r8d, 8
	inc	rcx
	mov	edx, eax
	call	formHex

; 220  :                     *ptr++ = ')';

	mov	BYTE PTR [rax], 41			; 00000029H
	lea	rbx, QWORD PTR [rax+1]
$LN17@trPrt:

; 221  :                 }
; 222  :                 *ptr++ = ':';

	mov	BYTE PTR [rbx], 58			; 0000003aH

; 223  :                 break;

	jmp	$LN127@trPrt
$LN18@trPrt:

; 224  :             case 'C':   /* code pointer */
; 225  :                 who = va_arg( args, _trmem_who );
; 226  :                 ptr = formCodePtr( hdl, ptr, who );

	mov	ecx, DWORD PTR [r15+8]
	add	r15, 8
	mov	r8d, 16
	add	rbx, r8
	mov	rdx, rbx
$LL41@trPrt:
	mov	eax, ecx
	lea	rdx, QWORD PTR [rdx-1]
	and	eax, 15
	shr	ecx, 4
	movzx	eax, BYTE PTR $SG7198[rax+r12]
	mov	BYTE PTR [rdx], al
	add	r8d, -1					; ffffffffH
	jne	SHORT $LL41@trPrt

; 227  :                 break;

	jmp	$LN15@trPrt
$LN19@trPrt:

; 228  :             case 'D':   /* data pointer */
; 229  :                 dp = va_arg( args, void * );
; 230  : #if defined( M_I86LM ) || defined( M_I86HM ) || defined( M_I86CM )
; 231  :                 ptr = formFarPtr( ptr, dp );
; 232  : #else
; 233  :                 ptr = formHex( ptr, (uint_32)dp, sizeof( dp ) );

	mov	ecx, DWORD PTR [r15+8]
	add	r15, 8
	mov	r8d, 16
	add	rbx, r8
	mov	rdx, rbx
	npad	6
$LL46@trPrt:
	mov	eax, ecx
	lea	rdx, QWORD PTR [rdx-1]
	and	eax, 15
	shr	ecx, 4
	movzx	eax, BYTE PTR $SG7198[rax+r12]
	mov	BYTE PTR [rdx], al
	add	r8d, -1					; ffffffffH
	jne	SHORT $LL46@trPrt

; 234  : #endif
; 235  :                 break;

	jmp	$LN15@trPrt
$LN20@trPrt:

; 236  :             case 'S':   /* char * (string) pointer */
; 237  :                 ptr = stpcpy( ptr, va_arg( args, char * ) );

	mov	rcx, QWORD PTR [r15+8]
	add	r15, 8
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rbx], al
	test	al, al
	je	$LN15@trPrt
	sub	rcx, rbx
	npad	6
$LL49@trPrt:
	movzx	eax, BYTE PTR [rcx+rbx+1]
	inc	rbx
	mov	BYTE PTR [rbx], al
	test	al, al
	jne	SHORT $LL49@trPrt

; 238  :                 break;

	jmp	$LN15@trPrt
$LN21@trPrt:

; 239  :             case 'U':   /* unsigned integer */
; 240  :                 ui = va_arg( args, uint );
; 241  :                 ptr = formHex( ptr, (uint_32)ui, sizeof( ui ) );

	mov	ecx, DWORD PTR [r15+8]
	add	rbx, 8
	mov	eax, ecx
	add	r15, 8
	and	eax, 15
	shr	ecx, 4
	movzx	eax, BYTE PTR $SG7198[rax+r12]
	mov	BYTE PTR [rbx-1], al
	mov	eax, ecx
	and	eax, 15
	shr	ecx, 4
	movzx	eax, BYTE PTR $SG7198[rax+r12]
	mov	BYTE PTR [rbx-2], al
	mov	eax, ecx
	and	eax, 15
	shr	ecx, 4
	movzx	eax, BYTE PTR $SG7198[rax+r12]
	mov	BYTE PTR [rbx-3], al
	mov	eax, ecx
	and	eax, 15
	shr	ecx, 4
	movzx	eax, BYTE PTR $SG7198[rax+r12]
	mov	BYTE PTR [rbx-4], al
	mov	eax, ecx
	and	eax, 15
	shr	ecx, 4
	movzx	eax, BYTE PTR $SG7198[rax+r12]
	mov	BYTE PTR [rbx-5], al
	mov	eax, ecx
	and	eax, 15
	shr	ecx, 4
	movzx	eax, BYTE PTR $SG7198[rax+r12]
	mov	BYTE PTR [rbx-6], al
	mov	eax, ecx
	and	eax, 15
	shr	rcx, 4
	and	ecx, 15
	movzx	eax, BYTE PTR $SG7198[rax+r12]
	mov	BYTE PTR [rbx-7], al
	movzx	eax, BYTE PTR $SG7198[rcx+r12]
	mov	BYTE PTR [rbx-8], al

; 242  :                 break;

	jmp	$LN15@trPrt
$LN23@trPrt:

; 243  :             case 'L':   /* unsigned long */
; 244  :                 ul = va_arg( args, uint_32 );
; 245  :                 ptr = formHex( ptr, (uint_32)ul, sizeof( ul ) );
; 246  :                 break;
; 247  :             case 'X':   /* 14 bytes of hex data */
; 248  :                 start = va_arg( args, char* );

	mov	r14, QWORD PTR [r15+8]

; 249  :                 size = va_arg( args, size_t );

	add	r15, 16

; 250  :                 if( size > 14 ) size = 14;
; 251  :                 xptr = start;

	mov	r8, r14
	mov	rsi, QWORD PTR [r15]
	cmp	rsi, r13
	cmova	rsi, r13

; 252  :                 for( i=0; i<14; i++ ) {

	xor	edx, edx
$LL9@trPrt:

; 253  :                     if( i < size ) {

	movsxd	rax, edx
	cmp	rax, rsi
	jae	SHORT $LN25@trPrt

; 254  :                         ptr = formHex( ptr, *xptr, sizeof( char ) );

	movsx	eax, BYTE PTR [r8]
	add	rbx, 2
	mov	ecx, eax
	and	eax, 15
	shr	rcx, 4
	and	ecx, 15

; 255  :                         xptr++;

	inc	r8
	movzx	eax, BYTE PTR $SG7198[rax+r12]
	mov	BYTE PTR [rbx-1], al
	movzx	eax, BYTE PTR $SG7198[rcx+r12]
	mov	BYTE PTR [rbx-2], al

; 256  :                     } else {    // no more to print, so make things line up.

	jmp	SHORT $LN26@trPrt
$LN25@trPrt:

; 257  :                         *ptr = ' ';

	mov	WORD PTR [rbx], 8224			; 00002020H

; 258  :                         *(ptr + 1) = ' ';
; 259  :                         ptr += 2;

	add	rbx, 2
$LN26@trPrt:

; 260  :                     }
; 261  :                     if( i == 7 ) {

	cmp	edx, 7
	jne	SHORT $LN7@trPrt

; 262  :                         *ptr = ' ';

	mov	BYTE PTR [rbx], 32			; 00000020H

; 263  :                         ptr++;

	inc	rbx
$LN7@trPrt:

; 252  :                 for( i=0; i<14; i++ ) {

	inc	edx
	cmp	edx, r13d
	jl	SHORT $LL9@trPrt

; 264  :                     }
; 265  :                 }
; 266  :                 for( i=0; i < size; i++ ) {

	xor	edi, edi
	test	rsi, rsi
	je	SHORT $LN15@trPrt
	sub	r14, rbx
$LL12@trPrt:

; 267  :                     if( isprint( *start ) ) {

	movsx	ecx, BYTE PTR [r14+rbx]
	call	isprint
	test	eax, eax
	je	SHORT $LN28@trPrt

; 268  :                         *ptr = *start;

	movzx	eax, BYTE PTR [r14+rbx]
	mov	BYTE PTR [rbx], al

; 269  :                     } else {

	jmp	SHORT $LN29@trPrt
$LN28@trPrt:

; 270  :                         *ptr = '.';

	mov	BYTE PTR [rbx], 46			; 0000002eH
$LN29@trPrt:

; 264  :                     }
; 265  :                 }
; 266  :                 for( i=0; i < size; i++ ) {

	inc	edi

; 271  :                     }
; 272  :                     ptr++;

	inc	rbx
	movsxd	rax, edi
	cmp	rax, rsi
	jb	SHORT $LL12@trPrt

; 273  :                     start++;
; 274  :                 }
; 275  :                 break;

	jmp	SHORT $LN15@trPrt
$LN30@trPrt:

; 276  :             default:
; 277  :                 *ptr++ = ch;

	mov	BYTE PTR [rbx], r8b

; 278  :                 break;
; 279  :             }
; 280  :         } else {

	jmp	SHORT $LN127@trPrt
$LN14@trPrt:

; 281  :            *ptr++ = ch;

	mov	BYTE PTR [rbx], al
$LN127@trPrt:
	inc	rbx
$LN15@trPrt:

; 207  :     ptr = buff;
; 208  :     for(;;) {
; 209  :         ch = *fmt++;

	mov	rdx, QWORD PTR fmt$[rsp]
	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	mov	QWORD PTR fmt$[rsp], rdx

; 210  :         if( ch == '\0' ) break;

	test	al, al
	jne	$LL2@trPrt
	mov	r14, QWORD PTR [rsp+152]
	mov	r13, QWORD PTR [rsp+160]
	mov	r12, QWORD PTR [rsp+168]
	mov	rdi, QWORD PTR [rsp+176]
	mov	rsi, QWORD PTR [rsp+184]
$LN78@trPrt:

; 282  :         }
; 283  :     }
; 284  :     va_end( args );
; 285  :     *ptr++ = '\n';

	mov	BYTE PTR [rbx], 10

; 286  :     *ptr = '\0';
; 287  :     hdl->prt_line( hdl->prt_parm, buff, ptr - buff );

	lea	rax, QWORD PTR buff$[rsp]
	inc	rbx
	lea	rdx, QWORD PTR buff$[rsp]
	mov	BYTE PTR [rbx], 0
	sub	rbx, rax
	mov	rcx, QWORD PTR [rbp+56]
	mov	r8, rbx
	call	QWORD PTR [rbp+64]

; 288  : }

	add	rsp, 192				; 000000c0H
	pop	r15
	pop	rbp
	pop	rbx
	ret	0
	npad	2
$LN126@trPrt:
	DD	$LN18@trPrt
	DD	$LN19@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN21@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN20@trPrt
	DD	$LN30@trPrt
	DD	$LN21@trPrt
	DD	$LN30@trPrt
	DD	$LN16@trPrt
	DD	$LN23@trPrt
trPrt	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
;	COMDAT formCodePtr
_TEXT	SEGMENT
hdl$ = 8
ptr$ = 16
who$ = 24
formCodePtr PROC					; COMDAT

; 184  : #if defined( M_I86LM ) || defined( M_I86HM ) || defined( M_I86MM )
; 185  :     return formFarPtr( ptr, who );
; 186  : #else
; 187  :     return formHex( ptr, (uint_32) who, sizeof(who) );

	lea	rax, QWORD PTR [rdx+16]
	mov	r9d, 16
	mov	rcx, rax
	lea	r10, OFFSET FLAT:$SG7198
	npad	12
$LL6@formCodePt:
	mov	edx, r8d
	lea	rcx, QWORD PTR [rcx-1]
	and	edx, 15
	shr	r8d, 4
	movzx	edx, BYTE PTR [rdx+r10]
	mov	BYTE PTR [rcx], dl
	add	r9d, -1					; ffffffffH
	jne	SHORT $LL6@formCodePt

; 188  : #endif
; 189  : }

	ret	0
formCodePtr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
;	COMDAT formHex
_TEXT	SEGMENT
ptr$ = 8
data$ = 16
size$ = 24
formHex	PROC						; COMDAT

; 157  :     char            *str;
; 158  : 
; 159  :     size *= 2;

	lea	r9d, DWORD PTR [r8+r8]

; 160  :     ptr += size;

	mov	eax, r9d
	add	rcx, rax

; 161  :     str = ptr;

	mov	r8, rcx

; 162  :     for( ; size > 0; size-- ) {

	test	r9d, r9d
	je	SHORT $LN10@formHex
	lea	r10, OFFSET FLAT:$SG7198
	npad	7
$LL4@formHex:

; 163  :         *--str = "0123456789abcdef"[data & 0x0f];

	mov	eax, edx
	lea	r8, QWORD PTR [r8-1]
	and	eax, 15

; 164  :         data >>= 4;

	shr	edx, 4
	movzx	eax, BYTE PTR [rax+r10]
	mov	BYTE PTR [r8], al
	add	r9d, -1					; ffffffffH
	jne	SHORT $LL4@formHex
$LN10@formHex:

; 165  :     }
; 166  :     return( ptr );

	mov	rax, rcx

; 167  : }

	ret	0
formHex	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
;	COMDAT stpcpy
_TEXT	SEGMENT
dest$ = 8
src$ = 16
stpcpy	PROC						; COMDAT

; 146  :     *dest = *src;

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al

; 147  :     while( *dest ) {

	test	al, al
	je	SHORT $LN9@stpcpy
	sub	rdx, rcx
	npad	4
$LL2@stpcpy:

; 148  :         ++dest;
; 149  :         ++src;
; 150  :         *dest = *src;

	movzx	eax, BYTE PTR [rdx+rcx+1]
	inc	rcx
	mov	BYTE PTR [rcx], al
	test	al, al
	jne	SHORT $LL2@stpcpy
$LN9@stpcpy:

; 151  :     }
; 152  :     return( dest );

	mov	rax, rcx

; 153  : }

	ret	0
stpcpy	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
;	COMDAT getSize
_TEXT	SEGMENT
p$ = 8
getSize	PROC						; COMDAT

; 137  :     return( p->size ^ (size_t)p->mem ^ (size_t)p->who ^ (size_t)p );

	mov	rax, QWORD PTR [rcx+24]
	xor	rax, QWORD PTR [rcx+16]
	xor	rax, QWORD PTR [rcx+8]
	xor	rax, rcx

; 138  : }

	ret	0
getSize	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
;	COMDAT setSize
_TEXT	SEGMENT
p$ = 8
size$ = 16
setSize	PROC						; COMDAT

; 132  :     p->size = size ^ (size_t)p->mem ^ (size_t)p->who ^ (size_t)p;

	mov	rax, QWORD PTR [rcx+16]
	xor	rax, QWORD PTR [rcx+8]
	xor	rax, rcx
	xor	rax, rdx
	mov	QWORD PTR [rcx+24], rax

; 133  : }

	ret	0
setSize	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
;	COMDAT isValidChunk
_TEXT	SEGMENT
tr$ = 80
rtn$ = 88
who$ = 96
hdl$ = 104
isValidChunk PROC					; COMDAT

; 468  : {

	push	rbx
	sub	rsp, 64					; 00000040H

; 469  :     void *mem;
; 470  :     size_t size;
; 471  :     size_t blk_size;
; 472  : 
; 473  :     size = getSize( tr );

	mov	r10, QWORD PTR [rcx+8]
	mov	rbx, r9
	mov	rax, QWORD PTR [rcx+24]
	mov	r11, QWORD PTR [rcx+16]
	xor	rax, r10
	xor	rax, r11
	xor	rax, rcx

; 474  :     mem = tr->mem;
; 475  :     blk_size = *(size_t*)_PtrSub( mem, sizeof( size_t ) );
; 476  : #ifndef __NETWARE__
; 477  : #if 0
; 478  :     if(( blk_size & 1 ) == 0 ) {
; 479  :         trPrt( hdl, MSG_UNDERRUN_ALLOCATION, rtn, who, mem, tr->who, size );
; 480  :         return( 0 );
; 481  :     }
; 482  :     blk_size &= ~1;
; 483  :     if( size > blk_size || ( blk_size - size ) > SIZE_DELTA ) {
; 484  :         trPrt( hdl, MSG_UNDERRUN_ALLOCATION, rtn, who, mem, tr->who, size );
; 485  :         return( 0 );
; 486  :     }
; 487  : #endif
; 488  : #endif
; 489  :     if( *(unsigned char *)_PtrAdd( mem, size ) != ALLOC_BYTE ) {

	cmp	BYTE PTR [r10+rax], 165			; 000000a5H
	je	SHORT $LN2@isValidChu

; 490  :         trPrt( hdl, MSG_OVERRUN_ALLOCATION, rtn, who, mem, tr->who, size );

	mov	QWORD PTR [rsp+48], rax
	mov	r9, r8
	mov	r8, rdx
	mov	QWORD PTR [rsp+40], r11
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_ALLOCATION
	mov	QWORD PTR [rsp+32], r10
	mov	rcx, rbx
	call	trPrt

; 491  :         return( 0 );

	xor	eax, eax

; 494  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN2@isValidChu:

; 492  :     }
; 493  :     return( 1 );

	mov	eax, 1

; 494  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
isValidChunk ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
p$ = 8
_trmem_guess_who PROC

; 740  :     return( (_trmem_who)*((void **)p-1) );

	mov	rax, QWORD PTR [rcx-8]

; 741  : }

	ret	0
_trmem_guess_who ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
hdl$ = 8
_trmem_get_peak_usage PROC

; 732  : /*****************************************************/
; 733  :     return hdl->max_mem;

	mov	eax, DWORD PTR [rcx+12]

; 734  : }

	ret	0
_trmem_get_peak_usage ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
hdl$ = 8
_trmem_get_current_usage PROC

; 727  : /********************************************************/
; 728  :     return hdl->mem_used;

	mov	eax, DWORD PTR [rcx+8]

; 729  : }

	ret	0
_trmem_get_current_usage ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
hdl$ = 80
_trmem_prt_list PROC

; 692  : {

$LN16:
	mov	QWORD PTR [rsp+16], rbx
	push	rsi
	sub	rsp, 64					; 00000040H

; 693  :     entry_ptr   tr;
; 694  :     unsigned    chunks;
; 695  :     size_t      size;
; 696  : 
; 697  :     tr = hdl->alloc_list;

	mov	rbx, QWORD PTR [rcx]
	mov	rsi, rcx

; 698  :     if( tr == 0 ) return( 0 );

	test	rbx, rbx
	jne	SHORT $LN5@trmem_prt_
	xor	eax, eax

; 718  :     return( chunks );
; 719  : }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rsi
	ret	0
$LN5@trmem_prt_:

; 699  :     _trmem_prt_usage( hdl );

	mov	r9d, DWORD PTR [rcx+12]
	lea	rdx, OFFSET FLAT:MSG_PRT_USAGE
	mov	r8d, DWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+80], rdi
	call	trPrt

; 700  :     trPrt( hdl, MSG_PRT_LIST_1 );

	lea	rdx, OFFSET FLAT:MSG_PRT_LIST_1
	mov	rcx, rsi
	call	trPrt

; 701  :     trPrt( hdl, MSG_PRT_LIST_2 );

	lea	rdx, OFFSET FLAT:MSG_PRT_LIST_2
	mov	rcx, rsi
	call	trPrt

; 702  :     chunks = 0;

	xor	edi, edi
	npad	5
$LL4@trmem_prt_:

; 703  :     do {
; 704  :         size = getSize( tr );

	mov	r9, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbx+24]
	mov	r8, QWORD PTR [rbx+16]
	xor	rcx, r9
	xor	rcx, r8
	xor	rcx, rbx

; 705  :         if( chunks < 20 ) {

	cmp	edi, 20
	jae	SHORT $LN6@trmem_prt_

; 706  :             trPrt( hdl

	mov	eax, DWORD PTR [rbx+32]
	lea	rdx, OFFSET FLAT:MSG_PRT_LIST_3
	mov	QWORD PTR [rsp+56], rcx
	mov	QWORD PTR [rsp+48], r9
	mov	DWORD PTR [rsp+40], eax
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rsi
	call	trPrt
$LN6@trmem_prt_:

; 707  :                  , MSG_PRT_LIST_3
; 708  :                  , tr->who
; 709  :                  , tr->mem
; 710  :                  , size
; 711  :                  , tr->when
; 712  :                  , tr->mem
; 713  :                  , size );
; 714  :         }
; 715  :         ++chunks;
; 716  :         tr = tr->next;

	mov	rbx, QWORD PTR [rbx]
	inc	edi

; 717  :     } while( tr );

	test	rbx, rbx
	jne	SHORT $LL4@trmem_prt_

; 718  :     return( chunks );
; 719  : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	eax, edi
	mov	rdi, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rsi
	ret	0
_trmem_prt_list ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
hdl$ = 8
_trmem_prt_usage PROC

; 687  :     trPrt( hdl, MSG_PRT_USAGE, hdl->mem_used, hdl->max_mem );

	mov	r9d, DWORD PTR [rcx+12]
	lea	rdx, OFFSET FLAT:MSG_PRT_USAGE
	mov	r8d, DWORD PTR [rcx+8]
	jmp	trPrt
_trmem_prt_usage ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
mem$ = 8
hdl$ = 16
_trmem_msize PROC

; 722  : /************************************************/
; 723  :     return( getSize( findOnList( mem, hdl ) ) );

	mov	rax, QWORD PTR [rdx]
	test	rax, rax
	je	SHORT $LN5@trmem_msiz
$LL4@trmem_msiz:
	cmp	QWORD PTR [rax+8], rcx
	je	SHORT $LN3@trmem_msiz
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL4@trmem_msiz
$LN5@trmem_msiz:
	xor	eax, eax
$LN3@trmem_msiz:
	mov	rcx, QWORD PTR [rax+24]
	xor	rcx, QWORD PTR [rax+16]
	xor	rcx, QWORD PTR [rax+8]
	xor	rax, rcx

; 724  : }

	ret	0
_trmem_msize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
str$ = 48
who$ = 56
hdl$ = 64
_trmem_strdup PROC

; 644  : {

$LN7:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 645  :     char    *mem;
; 646  :     size_t  len;
; 647  : 
; 648  :     len = strlen( str ) + 1;

	or	rbx, -1
	npad	10
$LL4@trmem_strd:
	cmp	BYTE PTR [rcx+rbx+1], 0
	lea	rbx, QWORD PTR [rbx+1]
	jne	SHORT $LL4@trmem_strd

; 649  :     mem = _trmem_alloc( len, who, hdl );

	lea	rcx, QWORD PTR [rbx+1]
	call	_trmem_alloc
	mov	rsi, rax

; 650  :     if( mem )

	test	rax, rax
	je	SHORT $LN2@trmem_strd

; 651  :         memcpy( mem, str, len );

	lea	r8, QWORD PTR [rbx+1]
	mov	rdx, rdi
	mov	rcx, rax
	call	memcpy

; 652  :     return( mem );

	mov	rax, rsi
$LN2@trmem_strd:

; 653  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
_trmem_strdup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
old$ = 64
size$ = 72
who$ = 80
hdl$ = 88
_trmem_expand PROC

; 638  : {

$LN4:
	sub	rsp, 56					; 00000038H

; 639  :     return( ChangeAlloc( old, size, who, hdl, hdl->expand, "Expand" ) );

	lea	rax, OFFSET FLAT:$SG7609
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR [r9+48]
	mov	QWORD PTR [rsp+32], rax
	call	ChangeAlloc

; 640  : }

	add	rsp, 56					; 00000038H
	ret	0
_trmem_expand ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
old$ = 64
size$ = 72
who$ = 80
hdl$ = 88
_trmem_realloc PROC

; 632  : {

$LN4:
	sub	rsp, 56					; 00000038H

; 633  :     return( ChangeAlloc( old, size, who, hdl, hdl->realloc, "Realloc" ) );

	lea	rax, OFFSET FLAT:$SG7599
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR [r9+40]
	mov	QWORD PTR [rsp+32], rax
	call	ChangeAlloc

; 634  : }

	add	rsp, 56					; 00000038H
	ret	0
_trmem_realloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
mem$ = 80
who$ = 88
hdl$ = 96
_trmem_free PROC

; 511  : {

$LN27:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rbx, r8
	mov	rdi, rcx

; 512  :     entry_ptr   tr;
; 513  :     size_t      size;
; 514  : 
; 515  :     if( mem == NULL ) {

	test	rcx, rcx
	jne	SHORT $LN2@trmem_free

; 516  :         if( hdl->flags & _TRMEM_FREE_NULL ) {

	test	BYTE PTR [r8+72], 8
	je	SHORT $LN3@trmem_free

; 517  :             trPrt( hdl, MSG_NULL_PTR, "Free", who );

	mov	r9, rdx
	lea	r8, OFFSET FLAT:$SG7530
	lea	rdx, OFFSET FLAT:MSG_NULL_PTR
	mov	rcx, rbx
	call	trPrt
$LN3@trmem_free:

; 518  :         }
; 519  :         hdl->free( mem );

	xor	ecx, ecx
	mov	rax, QWORD PTR [rbx+32]

; 534  : }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi

; 518  :         }
; 519  :         hdl->free( mem );

	rex_jmp	rax
$LN2@trmem_free:

; 520  :         return;
; 521  :     }
; 522  :     //printf("trmem_free: item=%p\n", mem );
; 523  :     tr = removeFromList( mem, hdl );

	cmp	QWORD PTR [r8], 0
	mov	rax, rbx
	je	SHORT $LN25@trmem_free
$LL7@trmem_free:
	mov	rcx, QWORD PTR [rax]
	cmp	QWORD PTR [rcx+8], rdi
	je	SHORT $LN21@trmem_free
	cmp	QWORD PTR [rcx], 0
	mov	rax, rcx
	jne	SHORT $LL7@trmem_free
$LN25@trmem_free:

; 524  :     if( tr == NULL ) {
; 525  :         trPrt( hdl, MSG_UNOWNED_CHUNK, "Free", who, mem );

	mov	r9, rdx
	mov	QWORD PTR [rsp+32], rdi
	lea	rdx, OFFSET FLAT:MSG_UNOWNED_CHUNK
	mov	rcx, rbx
	lea	r8, OFFSET FLAT:$SG7532
	call	trPrt

; 534  : }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN21@trmem_free:
	mov	QWORD PTR [rsp+80], rsi

; 520  :         return;
; 521  :     }
; 522  :     //printf("trmem_free: item=%p\n", mem );
; 523  :     tr = removeFromList( mem, hdl );

	mov	rsi, rcx
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 526  :         return;
; 527  :     }
; 528  :     isValidChunk( tr, "Free", who, hdl );

	mov	rcx, QWORD PTR [rsi+8]
	mov	r8, QWORD PTR [rsi+16]
	mov	rax, rcx
	xor	rax, r8
	xor	rax, QWORD PTR [rsi+24]
	xor	rax, rsi
	cmp	BYTE PTR [rcx+rax], 165			; 000000a5H
	je	SHORT $LN12@trmem_free
	mov	QWORD PTR [rsp+48], rax
	mov	r9, rdx
	mov	QWORD PTR [rsp+40], r8
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_ALLOCATION
	mov	QWORD PTR [rsp+32], rcx
	lea	r8, OFFSET FLAT:$SG7533
	mov	rcx, rbx
	call	trPrt
$LN12@trmem_free:

; 529  :     size = getSize( tr );

	mov	r8, QWORD PTR [rsi+16]

; 530  :     hdl->mem_used -= size;
; 531  :     MEMSET( mem, FREED_BYTE, size + 1 );

	mov	edx, 189				; 000000bdH
	xor	r8, QWORD PTR [rsi+24]
	mov	rcx, rdi
	xor	r8, QWORD PTR [rsi+8]
	xor	r8, rsi
	sub	DWORD PTR [rbx+8], r8d
	inc	r8
	call	memset

; 532  :     freeEntry( tr, hdl );

	mov	rcx, rsi
	call	QWORD PTR [rbx+32]

; 533  :     hdl->free( mem );

	mov	rcx, rdi

; 518  :         }
; 519  :         hdl->free( mem );

	mov	rax, QWORD PTR [rbx+32]

; 533  :     hdl->free( mem );

	mov	rsi, QWORD PTR [rsp+80]

; 534  : }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi

; 533  :     hdl->free( mem );

	rex_jmp	rax
_trmem_free ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
size$ = 64
who$ = 72
hdl$ = 80
_trmem_alloc PROC

; 436  : {

$LN18:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rdi
	sub	rsp, 48					; 00000030H

; 437  :     void        *mem;
; 438  :     entry_ptr   tr;
; 439  : 
; 440  :     hdl->alloc_no += 1;

	inc	DWORD PTR [r8+16]
	mov	rbx, r8
	mov	rbp, rdx
	mov	rdi, rcx

; 441  :     if( size == 0 && ( hdl->flags & _TRMEM_ALLOC_SIZE_0 ) ) {

	test	rcx, rcx
	jne	SHORT $LN2@trmem_allo
	test	BYTE PTR [r8+72], 1
	je	SHORT $LN2@trmem_allo

; 442  :         trPrt( hdl, MSG_SIZE_ZERO, "Alloc", who );

	mov	r9, rdx
	lea	r8, OFFSET FLAT:$SG7478
	lea	rdx, OFFSET FLAT:MSG_SIZE_ZERO
	mov	rcx, rbx
	call	trPrt

; 443  :         return ( NULL );

	xor	eax, eax

; 464  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN2@trmem_allo:
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], r14

; 444  :     } else if( size < hdl->min_alloc ) {

	cmp	rcx, QWORD PTR [r8+80]
	jae	SHORT $LN4@trmem_allo

; 445  :         trPrt( hdl, MSG_MIN_ALLOC, "Alloc", who, size );

	mov	QWORD PTR [rsp+32], rcx
	lea	r8, OFFSET FLAT:$SG7480
	mov	r9, rdx
	mov	rcx, rbx
	lea	rdx, OFFSET FLAT:MSG_MIN_ALLOC
	call	trPrt
$LN4@trmem_allo:

; 446  :     }
; 447  :     mem = hdl->alloc( size + 1 );

	lea	rcx, QWORD PTR [rdi+1]
	call	QWORD PTR [rbx+24]
	mov	rsi, rax

; 448  :     if( mem != NULL ) {

	test	rax, rax
	je	SHORT $LN7@trmem_allo

; 449  :         MEMSET( mem, ALLOC_BYTE, size + 1 );

	lea	r8, QWORD PTR [rdi+1]
	mov	edx, 165				; 000000a5H
	mov	rcx, rax
	call	memset

; 450  :         tr = allocEntry( hdl );

	mov	ecx, 40					; 00000028H
	call	QWORD PTR [rbx+24]
	mov	rcx, rax
	test	rax, rax
	jne	SHORT $LN16@trmem_allo
	test	BYTE PTR [rbx+72], 16
	je	SHORT $LN14@trmem_allo
	lea	rdx, OFFSET FLAT:MSG_OUT_OF_MEMORY
	mov	rcx, rbx
	call	trPrt

; 451  :         if( tr != NULL ) {

	jmp	SHORT $LN14@trmem_allo
$LN16@trmem_allo:

; 452  :             tr->mem = mem;

	mov	QWORD PTR [rax+8], rsi

; 453  :             tr->who = who;

	mov	QWORD PTR [rax+16], rbp

; 454  :             tr->when = hdl->alloc_no;

	mov	eax, DWORD PTR [rbx+16]
	mov	DWORD PTR [rcx+32], eax

; 455  :             setSize( tr, size );

	mov	rax, rcx
	xor	rax, rsi
	xor	rax, rdi
	xor	rax, rbp
	mov	QWORD PTR [rcx+24], rax

; 456  :             addToList( tr, hdl );

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rbx], rcx
$LN14@trmem_allo:

; 457  :         }
; 458  :         hdl->mem_used += size;

	add	DWORD PTR [rbx+8], edi
	mov	eax, DWORD PTR [rbx+8]

; 459  :         if( hdl->mem_used > hdl->max_mem ) {

	cmp	eax, DWORD PTR [rbx+12]
	jbe	SHORT $LN7@trmem_allo

; 460  :             hdl->max_mem = hdl->mem_used;

	mov	DWORD PTR [rbx+12], eax
$LN7@trmem_allo:
	mov	r14, QWORD PTR [rsp+72]

; 461  :         }
; 462  :     }
; 463  :     return( mem );

	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+64]

; 464  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_trmem_alloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
hdl$ = 96
_trmem_close PROC

; 395  : {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r15
	sub	rsp, 64					; 00000040H

; 396  :     uint        chunks;
; 397  :     uint_32     mem_used;
; 398  :     entry_ptr   walk;
; 399  :     entry_ptr   next;
; 400  : 
; 401  :     chunks = 0;

	xor	esi, esi
	mov	rdi, rcx

; 402  :     if( hdl->flags & _TRMEM_CLOSE_CHECK_FREE ) {

	test	BYTE PTR [rcx+72], 32			; 00000020H
	je	$LN6@trmem_clos

; 403  :         mem_used = hdl->mem_used;
; 404  :         walk = hdl->alloc_list;

	mov	rbx, QWORD PTR [rcx]
	mov	r15d, DWORD PTR [rcx+8]

; 405  :         while( walk ) {

	test	rbx, rbx
	je	$LN5@trmem_clos
	mov	QWORD PTR [rsp+96], rbp
	mov	QWORD PTR [rsp+104], r14
	npad	10
$LL2@trmem_clos:

; 406  :             //printf("trmem_close: item=%p, next=%p, mem=%p\n", walk, walk->next, walk->mem );
; 407  :             next = walk->next;

	mov	rbp, QWORD PTR [rbx]

; 408  :             ++chunks;

	inc	esi

; 409  :             _trmem_free( walk->mem, _TRMEM_NO_ROUTINE, hdl );

	mov	rbx, QWORD PTR [rbx+8]
	test	rbx, rbx
	jne	SHORT $LN11@trmem_clos
	test	BYTE PTR [rdi+72], 8
	je	SHORT $LN12@trmem_clos
	xor	r9d, r9d
	lea	r8, OFFSET FLAT:$SG7530
	lea	rdx, OFFSET FLAT:MSG_NULL_PTR
	mov	rcx, rdi
	call	trPrt
$LN12@trmem_clos:
	xor	ecx, ecx
	call	QWORD PTR [rdi+32]
	jmp	SHORT $LN10@trmem_clos
$LN11@trmem_clos:
	cmp	QWORD PTR [rdi], 0
	mov	rax, rdi
	je	SHORT $LN44@trmem_clos
	npad	3
$LL16@trmem_clos:
	mov	rcx, QWORD PTR [rax]
	cmp	QWORD PTR [rcx+8], rbx
	je	SHORT $LN34@trmem_clos
	cmp	QWORD PTR [rcx], 0
	mov	rax, rcx
	jne	SHORT $LL16@trmem_clos
$LN44@trmem_clos:
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	lea	r8, OFFSET FLAT:$SG7532
	mov	rcx, rdi
	lea	rdx, OFFSET FLAT:MSG_UNOWNED_CHUNK
	call	trPrt
$LN10@trmem_clos:

; 410  :             walk = next;

	mov	rbx, rbp
	test	rbp, rbp
	jne	SHORT $LL2@trmem_clos

; 411  :         }
; 412  :         if( chunks ) {

	mov	r14, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+96]
	test	esi, esi
	je	$LN5@trmem_clos

; 413  :             trPrt( hdl, MSG_CHUNK_BYTE_UNFREED, chunks, mem_used );

	mov	r9d, r15d
	lea	rdx, OFFSET FLAT:MSG_CHUNK_BYTE_UNFREED
	mov	r8d, esi
	mov	rcx, rdi
	call	trPrt

; 414  :         }
; 415  :     } else {

	jmp	$LN5@trmem_clos
$LN34@trmem_clos:

; 409  :             _trmem_free( walk->mem, _TRMEM_NO_ROUTINE, hdl );

	mov	r14, rcx
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR [r14+8]
	mov	rdx, QWORD PTR [r14+16]
	mov	rax, rcx
	xor	rax, rdx
	xor	rax, QWORD PTR [r14+24]
	xor	rax, r14
	cmp	BYTE PTR [rcx+rax], 165			; 000000a5H
	je	SHORT $LN21@trmem_clos
	mov	QWORD PTR [rsp+48], rax
	lea	r8, OFFSET FLAT:$SG7533
	mov	QWORD PTR [rsp+40], rdx
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rcx
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_ALLOCATION
	mov	rcx, rdi
	call	trPrt
$LN21@trmem_clos:
	mov	r8, QWORD PTR [r14+16]
	mov	edx, 189				; 000000bdH
	xor	r8, QWORD PTR [r14+24]
	mov	rcx, rbx
	xor	r8, QWORD PTR [r14+8]
	xor	r8, r14
	sub	DWORD PTR [rdi+8], r8d
	inc	r8
	call	memset
	mov	rcx, r14
	call	QWORD PTR [rdi+32]
	mov	rcx, rbx
	call	QWORD PTR [rdi+32]
	jmp	$LN10@trmem_clos
$LN6@trmem_clos:

; 416  :         walk = hdl->alloc_list;

	mov	rcx, QWORD PTR [rcx]

; 417  :         while( walk ) {

	test	rcx, rcx
	je	SHORT $LN5@trmem_clos
	npad	4
$LL4@trmem_clos:

; 418  :             next = walk->next;

	mov	rbx, QWORD PTR [rcx]

; 419  :             ++chunks;

	inc	esi

; 420  :             freeEntry( walk, hdl );

	call	QWORD PTR [rdi+32]

; 421  :             walk = next;

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL4@trmem_clos
$LN5@trmem_clos:

; 422  :         }
; 423  :     }
; 424  :     hdl->free( hdl );

	mov	rcx, rdi
	call	QWORD PTR [rdi+32]

; 425  :     return( chunks );
; 426  : }

	mov	rbx, QWORD PTR [rsp+112]
	mov	eax, esi
	add	rsp, 64					; 00000040H
	pop	r15
	pop	rdi
	pop	rsi
	ret	0
_trmem_close ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
alloc$ = 48
free$ = 56
realloc$ = 64
expand$ = 72
prt_parm$ = 80
prt_line$ = 88
flags$ = 96
_trmem_open PROC

; 354  : {

$LN5:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rdi, r9

; 355  :     _trmem_hdl  hdl;
; 356  : 
; 357  :     hdl = (_trmem_hdl) alloc( sizeof( struct _trmem_internal ) );

	mov	ecx, 88					; 00000058H
	mov	rsi, r8
	mov	rbp, rdx
	call	rbx
	mov	r10, rax

; 358  :     if( hdl == NULL ) {

	test	rax, rax
	je	SHORT $LN1@trmem_open
$LN2@trmem_open:

; 359  :         return( NULL );
; 360  :     }
; 361  :     hdl->alloc          = alloc;

	mov	QWORD PTR [rax+24], rbx

; 362  :     hdl->free           = free;

	mov	QWORD PTR [rax+32], rbp

; 363  :     hdl->realloc        = realloc;

	mov	QWORD PTR [rax+40], rsi

; 364  :     hdl->expand         = expand;

	mov	QWORD PTR [rax+48], rdi

; 365  :     hdl->prt_parm       = prt_parm;

	mov	rax, QWORD PTR prt_parm$[rsp]
	mov	QWORD PTR [r10+56], rax

; 366  :     hdl->prt_line       = prt_line;

	mov	rax, QWORD PTR prt_line$[rsp]
	mov	QWORD PTR [r10+64], rax

; 367  :     hdl->flags          = flags;

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [r10+72], eax

; 368  :     hdl->alloc_list     = NULL;

	xor	eax, eax
	mov	QWORD PTR [r10], rax

; 369  :     hdl->mem_used       = 0;

	mov	QWORD PTR [r10+8], rax

; 370  :     hdl->max_mem        = 0;
; 371  :     hdl->min_alloc      = 0;

	mov	QWORD PTR [r10+80], rax

; 372  :     hdl->alloc_no       = 0;

	mov	DWORD PTR [r10+16], eax

; 373  :     return( hdl );

	mov	rax, r10
$LN1@trmem_open:

; 374  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
_trmem_open ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 950  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	rbx, rax
	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 955  :     __crt_va_end(_ArgList);
; 956  :     return _Result;
; 957  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 640  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
