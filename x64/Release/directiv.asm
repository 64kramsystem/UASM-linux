; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	IncludeDirective
PUBLIC	StubDir
PUBLIC	SegOrderDirective
PUBLIC	RadixDirective
PUBLIC	AliasDirective
PUBLIC	EchoDirective
PUBLIC	IncBinDirective
PUBLIC	IncludeLibDirective
PUBLIC	NameDirective
PUBLIC	directive_tab
EXTRN	CondAsmDirective:PROC
EXTRN	LoopDirective:PROC
EXTRN	PurgeDirective:PROC
EXTRN	MacroDir:PROC
EXTRN	CatStrDir:PROC
EXTRN	SubStrDir:PROC
EXTRN	EndDirective:PROC
EXTRN	ErrorDirective:PROC
EXTRN	CpuDirective:PROC
EXTRN	ListingDirective:PROC
EXTRN	ListMacroDirective:PROC
EXTRN	SimplifiedSegDir:PROC
EXTRN	HllStartDir:PROC
EXTRN	HllExitDir:PROC
EXTRN	HllEndDir:PROC
EXTRN	StartupExitDirective:PROC
EXTRN	ModelDirective:PROC
EXTRN	SafeSEHDirective:PROC
EXTRN	InStrDir:PROC
EXTRN	SizeStrDir:PROC
EXTRN	ExcFrameDirective:PROC
EXTRN	StructDirective:PROC
EXTRN	TypedefDirective:PROC
EXTRN	RecordDirective:PROC
EXTRN	CommDirective:PROC
EXTRN	ExternDirective:PROC
EXTRN	ExterndefDirective:PROC
EXTRN	ProtoDirective:PROC
EXTRN	PublicDirective:PROC
EXTRN	ProcDir:PROC
EXTRN	EndpDir:PROC
EXTRN	LocalDir:PROC
EXTRN	InvokeDirective:PROC
EXTRN	OrgDirective:PROC
EXTRN	AlignDirective:PROC
EXTRN	SegmentDir:PROC
EXTRN	EndsDir:PROC
EXTRN	GrpDir:PROC
EXTRN	AssumeDirective:PROC
EXTRN	LabelDirective:PROC
EXTRN	EquDirective:PROC
EXTRN	EqualSgnDirective:PROC
EXTRN	OptionDirective:PROC
EXTRN	ContextDirective:PROC
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11197 DB	'%s', 0aH, 00H
_DATA	ENDS
CONST	SEGMENT
directive_tab DQ FLAT:CondAsmDirective
	DQ	FLAT:LoopDirective
	DQ	FLAT:PurgeDirective
	DQ	FLAT:IncludeDirective
	DQ	FLAT:MacroDir
	DQ	FLAT:CatStrDir
	DQ	FLAT:SubStrDir
	DQ	FLAT:StubDir
	DQ	FLAT:StubDir
	DQ	FLAT:EndDirective
	DQ	FLAT:ErrorDirective
	DQ	FLAT:CpuDirective
	DQ	FLAT:ListingDirective
	DQ	FLAT:ListMacroDirective
	DQ	FLAT:SegOrderDirective
	DQ	FLAT:SimplifiedSegDir
	DQ	FLAT:HllStartDir
	DQ	FLAT:HllExitDir
	DQ	FLAT:HllEndDir
	DQ	FLAT:StartupExitDirective
	DQ	FLAT:ModelDirective
	DQ	FLAT:RadixDirective
	DQ	FLAT:SafeSEHDirective
	DQ	FLAT:InStrDir
	DQ	FLAT:SizeStrDir
	DQ	FLAT:ExcFrameDirective
	DQ	FLAT:StructDirective
	DQ	FLAT:TypedefDirective
	DQ	FLAT:RecordDirective
	DQ	FLAT:CommDirective
	DQ	FLAT:ExternDirective
	DQ	FLAT:ExterndefDirective
	DQ	FLAT:ProtoDirective
	DQ	FLAT:PublicDirective
	DQ	FLAT:ProcDir
	DQ	FLAT:EndpDir
	DQ	FLAT:LocalDir
	DQ	FLAT:InvokeDirective
	DQ	FLAT:OrgDirective
	DQ	FLAT:AlignDirective
	DQ	FLAT:SegmentDir
	DQ	FLAT:EndsDir
	DQ	FLAT:GrpDir
	DQ	FLAT:AssumeDirective
	DQ	FLAT:LabelDirective
	DQ	FLAT:AliasDirective
	DQ	FLAT:EchoDirective
	DQ	FLAT:EquDirective
	DQ	FLAT:EqualSgnDirective
	DQ	FLAT:IncBinDirective
	DQ	FLAT:IncludeLibDirective
	DQ	FLAT:NameDirective
	DQ	FLAT:OptionDirective
	DQ	FLAT:ContextDirective
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	printf
EXTRN	isspace:PROC
EXTRN	__acrt_iob_func:PROC
EXTRN	fclose:PROC
EXTRN	fread:PROC
EXTRN	fseek:PROC
EXTRN	ftell:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	_strupr:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	QEnqueue:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymCreate:PROC
EXTRN	SymFind:PROC
EXTRN	sym_add_table:PROC
EXTRN	sym_remove_table:PROC
EXTRN	ProcessFile:PROC
EXTRN	SearchFile:PROC
EXTRN	Tokenize:PROC
EXTRN	EvalOperand:PROC
EXTRN	LstWriteSrcLine:PROC
EXTRN	omf_OutSelect:PROC
EXTRN	OutputBinBytes:PROC
EXTRN	memcpy:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SymTables:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	CurrStruct:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+83
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$IncludeDirective DD imagerel $LN18
	DD	imagerel $LN18+240
	DD	imagerel $unwind$IncludeDirective
$pdata$SegOrderDirective DD imagerel $LN10
	DD	imagerel $LN10+155
	DD	imagerel $unwind$SegOrderDirective
$pdata$RadixDirective DD imagerel $LN10
	DD	imagerel $LN10+264
	DD	imagerel $unwind$RadixDirective
$pdata$AliasDirective DD imagerel $LN34
	DD	imagerel $LN34+99
	DD	imagerel $unwind$AliasDirective
$pdata$0$AliasDirective DD imagerel $LN34+99
	DD	imagerel $LN34+148
	DD	imagerel $chain$0$AliasDirective
$pdata$3$AliasDirective DD imagerel $LN34+148
	DD	imagerel $LN34+287
	DD	imagerel $chain$3$AliasDirective
$pdata$5$AliasDirective DD imagerel $LN34+287
	DD	imagerel $LN34+332
	DD	imagerel $chain$5$AliasDirective
$pdata$7$AliasDirective DD imagerel $LN34+332
	DD	imagerel $LN34+350
	DD	imagerel $chain$7$AliasDirective
$pdata$9$AliasDirective DD imagerel $LN34+350
	DD	imagerel $LN34+379
	DD	imagerel $chain$9$AliasDirective
$pdata$12$AliasDirective DD imagerel $LN34+379
	DD	imagerel $LN34+492
	DD	imagerel $chain$12$AliasDirective
$pdata$14$AliasDirective DD imagerel $LN34+492
	DD	imagerel $LN34+543
	DD	imagerel $chain$14$AliasDirective
$pdata$15$AliasDirective DD imagerel $LN34+543
	DD	imagerel $LN34+578
	DD	imagerel $chain$15$AliasDirective
$pdata$EchoDirective DD imagerel $LN8
	DD	imagerel $LN8+56
	DD	imagerel $unwind$EchoDirective
$pdata$IncBinDirective DD imagerel $LN31
	DD	imagerel $LN31+451
	DD	imagerel $unwind$IncBinDirective
$pdata$0$IncBinDirective DD imagerel $LN31+451
	DD	imagerel $LN31+492
	DD	imagerel $chain$0$IncBinDirective
$pdata$1$IncBinDirective DD imagerel $LN31+492
	DD	imagerel $LN31+605
	DD	imagerel $chain$1$IncBinDirective
$pdata$2$IncBinDirective DD imagerel $LN31+605
	DD	imagerel $LN31+632
	DD	imagerel $chain$2$IncBinDirective
$pdata$3$IncBinDirective DD imagerel $LN31+632
	DD	imagerel $LN31+659
	DD	imagerel $chain$3$IncBinDirective
$pdata$IncludeLibDirective DD imagerel $LN37
	DD	imagerel $LN37+26
	DD	imagerel $unwind$IncludeLibDirective
$pdata$1$IncludeLibDirective DD imagerel $LN37+26
	DD	imagerel $LN37+124
	DD	imagerel $chain$1$IncludeLibDirective
$pdata$3$IncludeLibDirective DD imagerel $LN37+124
	DD	imagerel $LN37+320
	DD	imagerel $chain$3$IncludeLibDirective
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IncludeLibrary DD imagerel IncludeLibrary
	DD	imagerel IncludeLibrary+79
	DD	imagerel $unwind$IncludeLibrary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$IncludeLibrary DD imagerel IncludeLibrary+79
	DD	imagerel IncludeLibrary+172
	DD	imagerel $chain$0$IncludeLibrary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$IncludeLibrary DD imagerel IncludeLibrary+172
	DD	imagerel IncludeLibrary+182
	DD	imagerel $chain$1$IncludeLibrary
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$IncludeLibrary DD 021H
	DD	imagerel IncludeLibrary
	DD	imagerel IncludeLibrary+79
	DD	imagerel $unwind$IncludeLibrary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$IncludeLibrary DD 020521H
	DD	067405H
	DD	imagerel IncludeLibrary
	DD	imagerel IncludeLibrary+79
	DD	imagerel $unwind$IncludeLibrary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IncludeLibrary DD 020601H
	DD	030023206H
xdata	ENDS
xdata	SEGMENT
$unwind$IncludeDirective DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$SegOrderDirective DD 010401H
	DD	04204H
$unwind$RadixDirective DD 050d01H
	DD	017340dH
	DD	014010dH
	DD	07006H
$unwind$AliasDirective DD 020601H
	DD	050023206H
$chain$0$AliasDirective DD 020521H
	DD	076405H
	DD	imagerel $LN34
	DD	imagerel $LN34+99
	DD	imagerel $unwind$AliasDirective
$chain$3$AliasDirective DD 040921H
	DD	063409H
	DD	076400H
	DD	imagerel $LN34
	DD	imagerel $LN34+99
	DD	imagerel $unwind$AliasDirective
$chain$5$AliasDirective DD 040021H
	DD	076400H
	DD	063400H
	DD	imagerel $LN34
	DD	imagerel $LN34+99
	DD	imagerel $unwind$AliasDirective
$chain$7$AliasDirective DD 040021H
	DD	076400H
	DD	063400H
	DD	imagerel $LN34
	DD	imagerel $LN34+99
	DD	imagerel $unwind$AliasDirective
$chain$9$AliasDirective DD 040021H
	DD	076400H
	DD	063400H
	DD	imagerel $LN34
	DD	imagerel $LN34+99
	DD	imagerel $unwind$AliasDirective
$chain$12$AliasDirective DD 060821H
	DD	087408H
	DD	076400H
	DD	063400H
	DD	imagerel $LN34
	DD	imagerel $LN34+99
	DD	imagerel $unwind$AliasDirective
$chain$14$AliasDirective DD 060021H
	DD	087400H
	DD	076400H
	DD	063400H
	DD	imagerel $LN34
	DD	imagerel $LN34+99
	DD	imagerel $unwind$AliasDirective
$chain$15$AliasDirective DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+99
	DD	imagerel $unwind$AliasDirective
$unwind$EchoDirective DD 010401H
	DD	04204H
$unwind$IncBinDirective DD 050d01H
	DD	019340dH
	DD	014010dH
	DD	07006H
$chain$0$IncBinDirective DD 020821H
	DD	0175408H
	DD	imagerel $LN31
	DD	imagerel $LN31+451
	DD	imagerel $unwind$IncBinDirective
$chain$1$IncBinDirective DD 020821H
	DD	0186408H
	DD	imagerel $LN31+451
	DD	imagerel $LN31+492
	DD	imagerel $chain$0$IncBinDirective
$chain$2$IncBinDirective DD 021H
	DD	imagerel $LN31+451
	DD	imagerel $LN31+492
	DD	imagerel $chain$0$IncBinDirective
$chain$3$IncBinDirective DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+451
	DD	imagerel $unwind$IncBinDirective
$unwind$IncludeLibDirective DD 020601H
	DD	070023206H
$chain$1$IncludeLibDirective DD 040c21H
	DD	07640cH
	DD	063405H
	DD	imagerel $LN37
	DD	imagerel $LN37+26
	DD	imagerel $unwind$IncludeLibDirective
$chain$3$IncludeLibDirective DD 040021H
	DD	076400H
	DD	063400H
	DD	imagerel $LN37
	DD	imagerel $LN37+26
	DD	imagerel $unwind$IncludeLibDirective
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
;	COMDAT IncludeLibrary
_TEXT	SEGMENT
name$ = 48
IncludeLibrary PROC					; COMDAT

; 108  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 109  :     struct qitem *q;
; 110  : 
; 111  :     /* old approach, <= 1.91: add lib name to global namespace */
; 112  :     /* new approach, >= 1.92: check lib table, if entry is missing, add it */
; 113  :     /* Masm doesn't map cases for the paths. So if there is
; 114  :      * includelib <kernel32.lib>
; 115  :      * includelib <KERNEL32.LIB>
; 116  :      * then 2 defaultlib entries are added. If this is to be changed for
; 117  :      * HJWasm, activate the _stricmp() below.
; 118  :      */
; 119  :     for ( q = ModuleInfo.g.LibQueue.head; q ; q = q->next ) {

	mov	r9, QWORD PTR ModuleInfo+64
	mov	rbx, rcx
	test	r9, r9
	je	SHORT $LN3@IncludeLib
	npad	11
$LL4@IncludeLib:

; 120  :         //if ( _stricmp( dir->sym.name, name) == 0)
; 121  :         if ( strcmp( q->value, name ) == 0 )

	lea	rax, QWORD PTR [r9+8]
	mov	r8, rbx
	sub	r8, rax
	npad	6
$LL17@IncludeLib:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN18@IncludeLib
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL17@IncludeLib
$LN18@IncludeLib:
	test	edx, edx
	je	SHORT $LN10@IncludeLib

; 109  :     struct qitem *q;
; 110  : 
; 111  :     /* old approach, <= 1.91: add lib name to global namespace */
; 112  :     /* new approach, >= 1.92: check lib table, if entry is missing, add it */
; 113  :     /* Masm doesn't map cases for the paths. So if there is
; 114  :      * includelib <kernel32.lib>
; 115  :      * includelib <KERNEL32.LIB>
; 116  :      * then 2 defaultlib entries are added. If this is to be changed for
; 117  :      * HJWasm, activate the _stricmp() below.
; 118  :      */
; 119  :     for ( q = ModuleInfo.g.LibQueue.head; q ; q = q->next ) {

	mov	r9, QWORD PTR [r9]
	test	r9, r9
	jne	SHORT $LL4@IncludeLib
$LN3@IncludeLib:
	mov	QWORD PTR [rsp+48], rdi

; 123  :     }
; 124  :     q = LclAlloc( sizeof( struct qitem ) + strlen( name ) );

	or	rcx, -1
	npad	8
$LL16@IncludeLib:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], 0
	jne	SHORT $LL16@IncludeLib
	add	rcx, 16
	call	LclAlloc

; 125  :     strcpy( q->value, name );

	mov	rdx, rax
	sub	rdx, rbx
	lea	rdi, QWORD PTR [rax+8]
	npad	4
$LL7@IncludeLib:
	movzx	ecx, BYTE PTR [rbx]
	mov	BYTE PTR [rdx+rbx+8], cl
	lea	rbx, QWORD PTR [rbx+1]
	test	cl, cl
	jne	SHORT $LL7@IncludeLib

; 126  :     QEnqueue( &ModuleInfo.g.LibQueue, q );

	mov	rdx, rax
	lea	rcx, OFFSET FLAT:ModuleInfo+64
	call	QEnqueue

; 127  :     return( q->value );

	mov	rax, rdi
	mov	rdi, QWORD PTR [rsp+48]

; 128  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN10@IncludeLib:

; 122  :             return( q->value );

	lea	rax, QWORD PTR [r9+8]

; 128  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
IncludeLibrary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
i$ = 8
tokenarray$ = 16
NameDirective PROC

; 394  :     if( Parse_Pass != PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	mov	r8, rdx
	je	SHORT $LN2@NameDirect
$LN7@NameDirect:

; 395  :         return( NOT_ERROR );

	xor	eax, eax

; 420  :     }
; 421  : 
; 422  :     /* don't touch Option fields! if anything at all, ModuleInfo.name may be modified.
; 423  :      * However, since the directive is ignored by Masm, nothing is done.
; 424  :      */
; 425  : //  strncpy( ModuleInfo.name, tokenarray[i].string_ptr, sizeof( ModuleInfo.name ) );
; 426  : //  ModuleInfo.name[ sizeof( ModuleInfo.name ) - 1] = NULLC;
; 427  : //  DebugMsg(("NameDirective: set name to >%s<\n", ModuleInfo.name ));
; 428  :     DebugMsg(("NameDirective: ignored name >%s<\n", tokenarray[i].string_ptr ));
; 429  :     return( NOT_ERROR );
; 430  : }

	ret	0
$LN2@NameDirect:

; 396  :     /* if a module name is set with -nm, ignore NAME directive! */
; 397  :     /* v2.08: removed, since Options.names isn't touched at all */
; 398  :     //if( Options.names[OPTN_MODULE_NAME] != NULL )
; 399  :     //    return( NOT_ERROR );
; 400  : 
; 401  :     i++; /* skip directive */

	inc	ecx

; 402  : 
; 403  :     /* improper use of NAME is difficult to see since it is a nop
; 404  :      therefore some syntax checks are implemented:
; 405  :      - no 'name' structs, unions, records, typedefs!
; 406  :      - no 'name' struct fields!
; 407  :      - no 'name' segments!
; 408  :      - no 'name:' label!
; 409  :      */
; 410  :     if ( CurrStruct != NULL ||
; 411  :         ( tokenarray[i].token == T_DIRECTIVE &&
; 412  :          ( tokenarray[i].tokval == T_SEGMENT ||
; 413  :           tokenarray[i].tokval == T_STRUCT  ||
; 414  :           tokenarray[i].tokval == T_STRUC   ||
; 415  :           tokenarray[i].tokval == T_UNION   ||
; 416  :           tokenarray[i].tokval == T_TYPEDEF ||
; 417  :           tokenarray[i].tokval == T_RECORD)) ||

	cmp	QWORD PTR CurrStruct, 0
	jne	SHORT $LN4@NameDirect
	movsxd	rax, ecx
	shl	rax, 5
	add	rdx, rax
	movzx	eax, BYTE PTR [rdx]
	cmp	al, 3
	jne	SHORT $LN5@NameDirect
	mov	eax, DWORD PTR [rdx+16]
	cmp	eax, 436				; 000001b4H
	je	SHORT $LN4@NameDirect
	add	eax, -417				; fffffe5fH
	cmp	eax, 4
	jbe	SHORT $LN4@NameDirect

; 395  :         return( NOT_ERROR );

	xor	eax, eax

; 420  :     }
; 421  : 
; 422  :     /* don't touch Option fields! if anything at all, ModuleInfo.name may be modified.
; 423  :      * However, since the directive is ignored by Masm, nothing is done.
; 424  :      */
; 425  : //  strncpy( ModuleInfo.name, tokenarray[i].string_ptr, sizeof( ModuleInfo.name ) );
; 426  : //  ModuleInfo.name[ sizeof( ModuleInfo.name ) - 1] = NULLC;
; 427  : //  DebugMsg(("NameDirective: set name to >%s<\n", ModuleInfo.name ));
; 428  :     DebugMsg(("NameDirective: ignored name >%s<\n", tokenarray[i].string_ptr ));
; 429  :     return( NOT_ERROR );
; 430  : }

	ret	0
$LN5@NameDirect:

; 402  : 
; 403  :     /* improper use of NAME is difficult to see since it is a nop
; 404  :      therefore some syntax checks are implemented:
; 405  :      - no 'name' structs, unions, records, typedefs!
; 406  :      - no 'name' struct fields!
; 407  :      - no 'name' segments!
; 408  :      - no 'name:' label!
; 409  :      */
; 410  :     if ( CurrStruct != NULL ||
; 411  :         ( tokenarray[i].token == T_DIRECTIVE &&
; 412  :          ( tokenarray[i].tokval == T_SEGMENT ||
; 413  :           tokenarray[i].tokval == T_STRUCT  ||
; 414  :           tokenarray[i].tokval == T_STRUC   ||
; 415  :           tokenarray[i].tokval == T_UNION   ||
; 416  :           tokenarray[i].tokval == T_TYPEDEF ||
; 417  :           tokenarray[i].tokval == T_RECORD)) ||

	cmp	al, 58					; 0000003aH
	jne	SHORT $LN7@NameDirect
$LN4@NameDirect:

; 418  :          tokenarray[i].token == T_COLON ) {
; 419  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i-1].tokpos ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r8-8]
	jmp	EmitErr
NameDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
IncludeLibDirective PROC

; 150  : {

$LN37:
	push	rdi
	sub	rsp, 32					; 00000020H

; 151  :     char *name;
; 152  :     //struct asym *sym;
; 153  : 
; 154  :     if ( Parse_Pass != PASS_1 ) /* do all work in pass 1 */

	cmp	DWORD PTR Parse_Pass, 0
	mov	rdi, rdx
	je	SHORT $LN5@IncludeLib

; 155  :         return( NOT_ERROR );

	xor	eax, eax

; 184  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN5@IncludeLib:
	mov	QWORD PTR [rsp+48], rbx

; 156  :     i++; /* skip the directive */

	inc	ecx
	mov	QWORD PTR [rsp+56], rsi

; 157  :     /* v2.03: library name may be just a "number" */
; 158  :     //if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_NUM ) {
; 159  :     if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rsi, ecx
	mov	rbx, rsi
	shl	rbx, 5
	add	rbx, rdx
	cmp	BYTE PTR [rbx], 0
	jne	SHORT $LN6@IncludeLib

; 160  :         /* v2.05: Masm doesn't complain if there's no name, so emit a warning only! */
; 161  :         //EmitError( LIBRARY_NAME_MISSING );
; 162  :         //return( ERROR );
; 163  :         EmitWarn( 2, LIBRARY_NAME_MISSING );

	mov	edx, 88					; 00000058H
	lea	ecx, QWORD PTR [rdx-86]
	call	EmitWarn
$LN6@IncludeLib:

; 164  :     }
; 165  : 
; 166  :     if ( tokenarray[i].token == T_STRING && tokenarray[i].string_delim == '<' ) {

	cmp	BYTE PTR [rbx], 9
	jne	SHORT $LN7@IncludeLib
	cmp	BYTE PTR [rbx+1], 60			; 0000003cH
	jne	SHORT $LN7@IncludeLib

; 167  :         if ( tokenarray[i+1].token != T_FINAL ) {

	lea	rax, QWORD PTR [rsi+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 0
	je	SHORT $LN9@IncludeLib

; 168  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].tokpos ) );

	mov	rdx, QWORD PTR [rax+rdi+24]
	mov	ecx, 209				; 000000d1H
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]

; 184  : }

	add	rsp, 32					; 00000020H
	pop	rdi

; 168  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].tokpos ) );

	jmp	EmitErr
$LN9@IncludeLib:

; 169  :         }
; 170  :         /* v2.08: use GetLiteralValue() */
; 171  :         //name = StringBufferEnd;
; 172  :         //GetLiteralValue( name, tokenarray[i].string_ptr );
; 173  :         name = tokenarray[i].string_ptr;

	mov	rbx, QWORD PTR [rbx+8]

; 174  :     } else {

	jmp	SHORT $LN33@IncludeLib
$LN7@IncludeLib:

; 175  :         char *p;
; 176  :         /* regard "everything" behind INCLUDELIB as the library name */
; 177  :         name = tokenarray[i].tokpos;
; 178  :         /* remove trailing white spaces */
; 179  :         for ( p = tokenarray[Token_Count].tokpos - 1; p > name && isspace( *p ); *p = NULLC, p-- );

	movsxd	rax, DWORD PTR ModuleInfo+496
	mov	rbx, QWORD PTR [rbx+24]
	shl	rax, 5
	mov	rdi, QWORD PTR [rax+rdi+24]
	dec	rdi
	cmp	rdi, rbx
	jbe	SHORT $LN33@IncludeLib
	npad	2
$LL4@IncludeLib:
	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN33@IncludeLib
	mov	BYTE PTR [rdi], 0
	dec	rdi
	cmp	rdi, rbx
	ja	SHORT $LL4@IncludeLib
$LN33@IncludeLib:

; 180  :     }
; 181  : 
; 182  :     IncludeLibrary( name );

	mov	r9, QWORD PTR ModuleInfo+64
	test	r9, r9
	je	SHORT $LN13@IncludeLib
$LL14@IncludeLib:
	lea	rax, QWORD PTR [r9+8]
	mov	r8, rbx
	sub	r8, rax
	npad	3
$LL31@IncludeLib:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN32@IncludeLib
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL31@IncludeLib
$LN32@IncludeLib:
	test	edx, edx
	je	SHORT $LN11@IncludeLib
	mov	r9, QWORD PTR [r9]
	test	r9, r9
	jne	SHORT $LL14@IncludeLib
$LN13@IncludeLib:
	or	rcx, -1
$LL30@IncludeLib:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], 0
	jne	SHORT $LL30@IncludeLib
	add	rcx, 16
	call	LclAlloc
	mov	rdx, rax
	sub	rdx, rbx
	npad	5
$LL17@IncludeLib:
	movzx	ecx, BYTE PTR [rbx]
	mov	BYTE PTR [rdx+rbx+8], cl
	lea	rbx, QWORD PTR [rbx+1]
	test	cl, cl
	jne	SHORT $LL17@IncludeLib
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:ModuleInfo+64
	call	QEnqueue
$LN11@IncludeLib:

; 183  :     return( NOT_ERROR );

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+56]

; 184  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
IncludeLibDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
opndx$ = 48
i$ = 176
tokenarray$ = 184
IncBinDirective PROC

; 192  : {

$LN31:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 160				; 000000a0H

; 193  :     FILE *file;
; 194  :     //int size;
; 195  :     uint_32 fileoffset = 0; /* fixme: should be uint_64 */
; 196  :     uint_32 sizemax = -1;
; 197  :     struct expr opndx;
; 198  : 	long sz;
; 199  : 	unsigned char* pBinData;
; 200  : 
; 201  :     DebugMsg(("IncBinDirective enter\n"));
; 202  : 
; 203  :     i++; /* skip the directive */

	inc	ecx
	mov	rbx, rdx

; 204  :     /* v2.03: file name may be just a "number" */
; 205  :     //if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_NUM ) {
; 206  :     if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rax, ecx
	xor	edi, edi
	shl	rax, 5
	add	rdx, rax
	mov	DWORD PTR i$[rsp], ecx
	movzx	eax, BYTE PTR [rdx]
	test	al, al
	jne	SHORT $LN2@IncBinDire

; 207  :         return( EmitError( EXPECTED_FILE_NAME ) );

	lea	ecx, QWORD PTR [rdi+112]
	jmp	$LN27@IncBinDire
$LN2@IncBinDire:

; 208  :     }
; 209  : 
; 210  :     if ( tokenarray[i].token == T_STRING ) {

	cmp	al, 9
	jne	$LN3@IncBinDire

; 211  : 
; 212  :         /* v2.08: use string buffer to avoid buffer overflow if string is > FILENAME_MAX */
; 213  :         if ( tokenarray[i].string_delim == '"' || tokenarray[i].string_delim == '\'' ) {

	movzx	eax, BYTE PTR [rdx+1]
	cmp	al, 34					; 00000022H
	je	SHORT $LN7@IncBinDire
	cmp	al, 39					; 00000027H
	je	SHORT $LN7@IncBinDire

; 216  :         } else if ( tokenarray[i].string_delim == '<' ) {

	cmp	al, 60					; 0000003cH
	jne	$LN3@IncBinDire

; 217  :             /* v2.08: use GetLiteralValue() instead of strncpy() */
; 218  :             //GetLiteralValue( StringBufferEnd, tokenarray[i].string_ptr );
; 219  :             memcpy( StringBufferEnd, tokenarray[i].string_ptr, tokenarray[i].stringlen+1 );

	mov	r8d, DWORD PTR [rdx+16]
	mov	rdx, QWORD PTR [rdx+8]
	inc	r8d
	mov	rcx, QWORD PTR ModuleInfo+488
	call	memcpy

; 220  :         } else {

	jmp	SHORT $LN9@IncBinDire
$LN7@IncBinDire:

; 214  :             memcpy( StringBufferEnd, tokenarray[i].string_ptr+1, tokenarray[i].stringlen );

	mov	r8d, DWORD PTR [rdx+16]
	mov	rdx, QWORD PTR [rdx+8]
	mov	rcx, QWORD PTR ModuleInfo+488
	inc	rdx
	call	memcpy

; 215  :             StringBufferEnd[tokenarray[i].stringlen] = NULLC;

	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	mov	ecx, DWORD PTR [rax+rbx+16]
	mov	rax, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rcx+rax], dil
$LN9@IncBinDire:

; 225  :     }
; 226  :     i++;

	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx

; 227  :     if ( tokenarray[i].token == T_COMMA ) {

	movsxd	rax, ecx
	shl	rax, 5
	mov	DWORD PTR i$[rsp], ecx
	cmp	BYTE PTR [rax+rbx], 44			; 0000002cH
	jne	$LN19@IncBinDire

; 228  :         i++;
; 229  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	inc	ecx
	mov	BYTE PTR [rsp+32], dil
	mov	DWORD PTR i$[rsp], ecx
	mov	rdx, rbx
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN11@IncBinDire
$LN29@IncBinDire:

; 230  :             return( ERROR );

	or	eax, -1

; 286  : }

	mov	rbx, QWORD PTR [rsp+200]
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
$LN11@IncBinDire:

; 231  :         if ( opndx.kind == EXPR_CONST ) {

	mov	eax, DWORD PTR opndx$[rsp+60]
	test	eax, eax
	jne	$LN12@IncBinDire

; 232  :             fileoffset = opndx.value;

	mov	edi, DWORD PTR opndx$[rsp]
$LN14@IncBinDire:

; 235  :         }
; 236  :         if ( tokenarray[i].token == T_COMMA ) {

	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rbx], 44			; 0000002cH
	jne	SHORT $LN19@IncBinDire

; 237  :             i++;
; 238  :             if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	inc	ecx
	mov	BYTE PTR [rsp+32], 0
	mov	DWORD PTR i$[rsp], ecx
	mov	rdx, rbx
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	je	SHORT $LN29@IncBinDire

; 239  :                 return( ERROR );
; 240  :             if ( opndx.kind == EXPR_CONST ) {
; 241  :                 sizemax = opndx.value;
; 242  :             } else if ( opndx.kind != EXPR_EMPTY ) {
; 243  :                 return( EmitError( CONSTANT_EXPECTED ) );

	mov	eax, DWORD PTR opndx$[rsp+60]
	add	eax, 2
	test	eax, -3					; fffffffdH
	jne	SHORT $LN28@IncBinDire
	mov	ecx, DWORD PTR i$[rsp]
$LN19@IncBinDire:

; 244  :             }
; 245  :         }
; 246  :     }
; 247  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+rbx], 0
	je	SHORT $LN20@IncBinDire

; 248  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rax+rbx+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 286  : }

	mov	rbx, QWORD PTR [rsp+200]
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
$LN12@IncBinDire:

; 233  :         } else if ( opndx.kind != EXPR_EMPTY ) {

	cmp	eax, -2
	je	$LN14@IncBinDire
$LN28@IncBinDire:

; 234  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	jmp	$LN27@IncBinDire
$LN20@IncBinDire:

; 249  :     }
; 250  : 
; 251  :     if( CurrSeg == NULL ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN21@IncBinDire

; 252  :         return( EmitError( MUST_BE_IN_SEGMENT_BLOCK ) );

	mov	ecx, 82					; 00000052H
	jmp	$LN27@IncBinDire
$LN21@IncBinDire:

; 253  :     }
; 254  : 
; 255  :     /* v2.04: tell assembler that data is emitted */
; 256  :     if ( ModuleInfo.CommentDataInCode )

	cmp	BYTE PTR ModuleInfo+423, 0
	mov	QWORD PTR [rsp+184], rbp
	je	SHORT $LN22@IncBinDire

; 257  :         omf_OutSelect( TRUE );

	mov	cl, 1
	call	omf_OutSelect
$LN22@IncBinDire:

; 258  : 
; 259  :     DebugMsg1(("IncBinDirective: filename=%s, offset=%" I32_SPEC "u, size=%" I32_SPEC "u\n", StringBufferEnd, fileoffset, sizemax ));
; 260  : 
; 261  :     /* try to open the file */
; 262  :     if ( file = SearchFile( StringBufferEnd, FALSE ) ) 

	mov	rcx, QWORD PTR ModuleInfo+488
	xor	edx, edx
	call	SearchFile
	mov	rbp, rax
	test	rax, rax
	je	SHORT $LN23@IncBinDire

; 263  : 	{
; 264  : 		/* v2.14 : Get File Size */
; 265  : 		fseek( file, 0L, SEEK_END );

	xor	edx, edx
	mov	QWORD PTR [rsp+192], rsi
	mov	rcx, rax
	lea	r8d, QWORD PTR [rdx+2]
	call	fseek

; 266  : 		sz = ftell( file ) - fileoffset; // sz = total data size to load into segment/section.

	mov	rcx, rbp
	call	ftell
	mov	esi, eax

; 267  : 		fseek( file, 0L, SEEK_SET );

	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, rbp
	sub	esi, edi
	call	fseek

; 268  : 		pBinData = (unsigned char*)malloc(sz);

	movsxd	rbx, esi
	mov	rcx, rbx
	call	malloc

; 269  : 		fread(pBinData, sz, 1, file);

	mov	r9, rbp
	mov	r8d, 1
	mov	rdx, rbx
	mov	rcx, rax
	mov	rdi, rax
	call	fread

; 270  : 		OutputBinBytes(pBinData, sz);

	mov	edx, esi
	mov	rcx, rdi
	call	OutputBinBytes

; 271  : 
; 272  :         /* transfer file content to the current segment. */
; 273  :         //if ( fileoffset )
; 274  :             //fseek( file, fileoffset, SEEK_SET );  /* fixme: use fseek64() */
; 275  :         //for( ; sizemax; sizemax-- ) {
; 276  :             //int ch = fgetc( file );
; 277  :             //if ( ( ch == EOF ) && feof( file ) )
; 278  :                 //break;
; 279  :             //OutputByte( ch );
; 280  :         //}
; 281  : 		free((void*)pBinData);

	mov	rcx, rdi
	call	free

; 282  :         fclose( file );

	mov	rcx, rbp
	call	fclose
	mov	rsi, QWORD PTR [rsp+192]
$LN23@IncBinDire:

; 283  :     }
; 284  : 
; 285  :     return( NOT_ERROR );

	xor	eax, eax
	mov	rbp, QWORD PTR [rsp+184]

; 286  : }

	mov	rbx, QWORD PTR [rsp+200]
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
$LN3@IncBinDire:

; 221  :             return( EmitError( FILENAME_MUST_BE_ENCLOSED_IN_QUOTES_OR_BRACKETS ) );
; 222  :         }
; 223  :     } else {
; 224  :         return( EmitError( FILENAME_MUST_BE_ENCLOSED_IN_QUOTES_OR_BRACKETS ) );

	mov	ecx, 241				; 000000f1H
$LN27@IncBinDire:
	call	EmitError

; 286  : }

	mov	rbx, QWORD PTR [rsp+200]
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
IncBinDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
EchoDirective PROC

; 55   : {

$LN8:
	sub	rsp, 40					; 00000028H

; 56   :     if ( Parse_Pass == PASS_1 ) /* display in pass 1 only */

	cmp	DWORD PTR Parse_Pass, 0
	mov	rax, rdx
	jne	SHORT $LN6@EchoDirect

; 57   :         if ( Options.preprocessor_stdout == FALSE ) { /* don't print to stdout if -EP is on! */

	cmp	BYTE PTR Options+125, 0
	jne	SHORT $LN6@EchoDirect

; 58   :             printf( "%s\n", tokenarray[i+1].tokpos );

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG11197
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rax+56]
	call	printf
$LN6@EchoDirect:

; 59   :         }
; 60   :     return( NOT_ERROR );

	xor	eax, eax

; 61   : }

	add	rsp, 40					; 00000028H
	ret	0
EchoDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
AliasDirective PROC

; 305  : {

$LN34:
	push	rbp
	sub	rsp, 32					; 00000020H

; 306  :     //char *tmp;
; 307  :     struct asym *sym;
; 308  :     char *subst;
; 309  : 
; 310  :     i++; /* go past ALIAS */

	inc	ecx

; 311  : 
; 312  :     if ( tokenarray[i].token != T_STRING ||

	movsxd	r8, ecx
	mov	rbp, r8
	shl	rbp, 5
	add	rbp, rdx
	cmp	BYTE PTR [rbp], 9
	jne	$LN7@AliasDirec
	cmp	BYTE PTR [rbp+1], 60			; 0000003cH
	jne	$LN7@AliasDirec

; 313  :         tokenarray[i].string_delim != '<' ) {
; 314  :         DebugMsg(("AliasDirective: first argument is not a literal: %s\n", tokenarray[i].string_ptr ));
; 315  :         return( EmitError( TEXT_ITEM_REQUIRED ) );
; 316  :     }
; 317  : 
; 318  :     /* check syntax. note that '=' is T_DIRECTIVE && DRT_EQUALSGN */
; 319  :     if ( tokenarray[i+1].token != T_DIRECTIVE ||

	lea	rcx, QWORD PTR [r8+1]
	shl	rcx, 5
	cmp	BYTE PTR [rcx+rdx], 3
	jne	$LN5@AliasDirec
	cmp	BYTE PTR [rcx+rdx+1], 48		; 00000030H
	jne	$LN5@AliasDirec

; 324  :     }
; 325  : 
; 326  :     if ( tokenarray[i+2].token != T_STRING ||

	lea	rax, QWORD PTR [r8+2]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 9
	jne	$LN7@AliasDirec
	cmp	BYTE PTR [rax+rdx+1], 60		; 0000003cH
	jne	$LN7@AliasDirec

; 330  :     }
; 331  :     subst = tokenarray[i+2].string_ptr;

	mov	QWORD PTR [rsp+56], rsi
	mov	rsi, QWORD PTR [rax+rdx+8]

; 332  : 
; 333  :     if ( tokenarray[i+3].token != T_FINAL ) {

	lea	rax, QWORD PTR [r8+3]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 0
	je	SHORT $LN8@AliasDirec

; 334  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+3].string_ptr ) );

	mov	rdx, QWORD PTR [rax+rdx+8]
	mov	ecx, 209				; 000000d1H
	mov	rsi, QWORD PTR [rsp+56]

; 387  : }

	add	rsp, 32					; 00000020H
	pop	rbp

; 334  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+3].string_ptr ) );

	jmp	EmitErr
$LN8@AliasDirec:

; 335  :     }
; 336  : 
; 337  :     /* make sure <alias_name> isn't defined elsewhere */
; 338  :     sym = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rbp+8]
	mov	QWORD PTR [rsp+48], rbx
	call	SymFind
	mov	rbx, rax

; 339  :     if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rax, rax
	je	$LN10@AliasDirec
	mov	eax, DWORD PTR [rax+32]
	test	eax, eax
	je	$LN10@AliasDirec

; 363  :     }
; 364  :     if ( sym->state != SYM_ALIAS || ( strcmp( sym->substitute->name, subst ) != 0 )) {

	cmp	eax, 8
	jne	$LN17@AliasDirec
	mov	r9, QWORD PTR [rbx+16]
	mov	r8, rsi
	mov	rcx, QWORD PTR [r9+8]
	sub	r8, rcx
$LL28@AliasDirec:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+r8]
	sub	edx, eax
	jne	SHORT $LN29@AliasDirec
	inc	rcx
	test	eax, eax
	jne	SHORT $LL28@AliasDirec
$LN29@AliasDirec:
	test	edx, edx
	jne	SHORT $LN17@AliasDirec

; 367  :     }
; 368  : #if COFF_SUPPORT || ELF_SUPPORT
; 369  :     /* for COFF+ELF, make sure <actual_name> is "global" (EXTERNAL or
; 370  :      * public INTERNAL). For OMF, there's no check at all. */
; 371  :     if ( Parse_Pass != PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, edx
	je	SHORT $LN23@AliasDirec
	mov	eax, DWORD PTR Options+144
	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	SHORT $LN23@AliasDirec

; 372  :         if ( Options.output_format == OFORMAT_COFF
; 373  : #if ELF_SUPPORT
; 374  :              || Options.output_format == OFORMAT_ELF
; 375  : #endif
; 376  :            ) {
; 377  :             if ( sym->substitute->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [r9+32]
	test	eax, eax
	jne	SHORT $LN21@AliasDirec

; 378  :                 return( EmitErr( SYMBOL_NOT_DEFINED, subst ) );

	mov	rdx, rsi
	lea	ecx, QWORD PTR [rax+102]
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]

; 387  : }

	add	rsp, 32					; 00000020H
	pop	rbp

; 378  :                 return( EmitErr( SYMBOL_NOT_DEFINED, subst ) );

	jmp	EmitErr
$LN21@AliasDirec:

; 379  :             } else if ( sym->substitute->state != SYM_EXTERNAL &&

	cmp	eax, 2
	je	SHORT $LN23@AliasDirec
	cmp	eax, 1
	jne	SHORT $LN24@AliasDirec
	test	BYTE PTR [r9+40], 128			; 00000080H
	jne	SHORT $LN23@AliasDirec
$LN24@AliasDirec:

; 380  :                        ( sym->substitute->state != SYM_INTERNAL || sym->substitute->ispublic == FALSE ) ) {
; 381  :                 return( EmitErr( MUST_BE_PUBLIC_OR_EXTERNAL, subst ) );

	mov	rdx, rsi
	mov	ecx, 268				; 0000010cH
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]

; 387  : }

	add	rsp, 32					; 00000020H
	pop	rbp

; 380  :                        ( sym->substitute->state != SYM_INTERNAL || sym->substitute->ispublic == FALSE ) ) {
; 381  :                 return( EmitErr( MUST_BE_PUBLIC_OR_EXTERNAL, subst ) );

	jmp	EmitErr
$LN23@AliasDirec:
	mov	rbx, QWORD PTR [rsp+48]

; 382  :             }
; 383  :         }
; 384  :     }
; 385  : #endif
; 386  :     return( NOT_ERROR );

	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+56]

; 387  : }

	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
$LN17@AliasDirec:

; 365  :         DebugMsg(("AliasDirective: symbol redefinition\n"));
; 366  :         return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 143				; 0000008fH
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]

; 387  : }

	add	rsp, 32					; 00000020H
	pop	rbp

; 365  :         DebugMsg(("AliasDirective: symbol redefinition\n"));
; 366  :         return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	jmp	EmitErr
$LN10@AliasDirec:

; 340  :         struct asym *sym2;
; 341  :         /* v2.04b: adjusted to new field <substitute> */
; 342  :         sym2 = SymSearch( subst );

	mov	rcx, rsi
	mov	QWORD PTR [rsp+64], rdi
	call	SymFind
	mov	rdi, rax

; 343  :         if ( sym2 == NULL ) {

	test	rax, rax
	jne	SHORT $LN11@AliasDirec

; 344  :             sym2 = SymCreate( subst );

	mov	rcx, rsi
	call	SymCreate

; 345  :             sym2->state = SYM_UNDEFINED;
; 346  :             sym_add_table( &SymTables[TAB_UNDEF], (struct dsym *)sym2 );

	mov	rdx, rax
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdi, rax
	mov	DWORD PTR [rax+32], 0
	call	sym_add_table
$LN13@AliasDirec:

; 351  :         }
; 352  :         if ( sym == NULL )

	test	rbx, rbx
	jne	SHORT $LN14@AliasDirec

; 353  :             sym = SymCreate( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rbp+8]
	call	SymCreate
	mov	rbx, rax
	jmp	SHORT $LN15@AliasDirec
$LN11@AliasDirec:
	cmp	DWORD PTR [rax+32], 2
	jbe	SHORT $LN13@AliasDirec

; 347  :         } else if ( sym2->state != SYM_UNDEFINED &&
; 348  :                    sym2->state != SYM_INTERNAL &&
; 349  :                    sym2->state != SYM_EXTERNAL ) {
; 350  :             return( EmitErr( MUST_BE_PUBLIC_OR_EXTERNAL, subst ) );

	mov	rdx, rsi
	mov	ecx, 268				; 0000010cH
	call	EmitErr
$LN32@AliasDirec:
	mov	rdi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]

; 387  : }

	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
$LN14@AliasDirec:

; 354  :         else
; 355  :             sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table
$LN15@AliasDirec:

; 356  : 
; 357  :         sym->state = SYM_ALIAS;

	mov	DWORD PTR [rbx+32], 8

; 358  :         sym->substitute = sym2;
; 359  :         /* v2.10: copy language type of alias */
; 360  :         sym->langtype = sym2->langtype;
; 361  :         sym_add_table( &SymTables[TAB_ALIAS], (struct dsym *)sym ); /* add ALIAS */

	lea	rcx, OFFSET FLAT:SymTables+80
	mov	QWORD PTR [rbx+16], rdi
	mov	rdx, rbx
	mov	eax, DWORD PTR [rdi+76]
	mov	DWORD PTR [rbx+76], eax
	call	sym_add_table

; 362  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN32@AliasDirec
$LN7@AliasDirec:

; 327  :         tokenarray[i+2].string_delim != '<' )  {
; 328  :         DebugMsg(("AliasDirective: second argument is not a literal: %s\n", tokenarray[i+2].string_ptr ));
; 329  :         return( EmitError( TEXT_ITEM_REQUIRED ) );

	mov	ecx, 144				; 00000090H

; 387  : }

	add	rsp, 32					; 00000020H
	pop	rbp

; 327  :         tokenarray[i+2].string_delim != '<' )  {
; 328  :         DebugMsg(("AliasDirective: second argument is not a literal: %s\n", tokenarray[i+2].string_ptr ));
; 329  :         return( EmitError( TEXT_ITEM_REQUIRED ) );

	jmp	EmitError
$LN5@AliasDirec:

; 320  :         //tokenarray[i+1].tokval != T_EQU ||
; 321  :         tokenarray[i+1].dirtype != DRT_EQUALSGN ) {
; 322  :         DebugMsg(("AliasDirective: syntax error: %s\n", tokenarray[i+1].string_ptr ));
; 323  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].string_ptr ) );

	mov	rdx, QWORD PTR [rcx+rdx+8]
	mov	ecx, 209				; 000000d1H

; 387  : }

	add	rsp, 32					; 00000020H
	pop	rbp

; 320  :         //tokenarray[i+1].tokval != T_EQU ||
; 321  :         tokenarray[i+1].dirtype != DRT_EQUALSGN ) {
; 322  :         DebugMsg(("AliasDirective: syntax error: %s\n", tokenarray[i+1].string_ptr ));
; 323  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].string_ptr ) );

	jmp	EmitErr
AliasDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
opndx$ = 48
i$ = 176
tokenarray$ = 184
RadixDirective PROC

; 436  : {

$LN10:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 160				; 000000a0H

; 437  :     uint_8          oldradix;
; 438  :     struct expr     opndx;
; 439  : 
; 440  :     /* to get the .radix parameter, enforce radix 10 and retokenize! */
; 441  :     oldradix = ModuleInfo.radix;

	movzx	ebx, BYTE PTR ModuleInfo+396
	mov	rdi, rdx

; 442  :     ModuleInfo.radix = 10;
; 443  :     i++; /* skip directive token */

	lea	edx, DWORD PTR [rcx+1]
	mov	BYTE PTR ModuleInfo+396, 10

; 444  :     Tokenize( tokenarray[i].tokpos, i, tokenarray, TOK_RESCAN );

	movsxd	rcx, edx
	mov	r9d, 1
	shl	rcx, 5
	mov	r8, rdi
	mov	DWORD PTR i$[rsp], edx
	mov	rcx, QWORD PTR [rcx+rdi+24]
	call	Tokenize

; 445  :     ModuleInfo.radix = oldradix;
; 446  :     /* v2.11: flag NOUNDEF added - no forward ref possible */
; 447  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	mov	rdx, rdi
	mov	BYTE PTR ModuleInfo+396, bl
	lea	rcx, QWORD PTR i$[rsp]
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN2@RadixDirec

; 448  :         return( ERROR );

	or	eax, eax

; 465  : }

	mov	rbx, QWORD PTR [rsp+184]
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
$LN2@RadixDirec:

; 449  :     }
; 450  : 
; 451  :     if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN3@RadixDirec

; 452  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	jmp	SHORT $LN8@RadixDirec
$LN3@RadixDirec:

; 453  :     }
; 454  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 0
	je	SHORT $LN4@RadixDirec

; 455  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rax+rdi+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 465  : }

	mov	rbx, QWORD PTR [rsp+184]
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
$LN4@RadixDirec:

; 456  :     }
; 457  :     if ( opndx.value > 16 || opndx.value < 2 || opndx.hvalue != 0 ) {

	mov	ecx, DWORD PTR opndx$[rsp]
	lea	eax, DWORD PTR [rcx-2]
	cmp	eax, 14
	ja	SHORT $LN6@RadixDirec
	cmp	DWORD PTR opndx$[rsp+4], 0
	jne	SHORT $LN6@RadixDirec

; 459  :     }
; 460  : 
; 461  :     ModuleInfo.radix = opndx.value;

	mov	BYTE PTR ModuleInfo+396, cl

; 462  :     DebugMsg(("RadixDirective: new radix=%u\n", ModuleInfo.radix ));
; 463  : 
; 464  :     return( NOT_ERROR );

	xor	eax, eax

; 465  : }

	mov	rbx, QWORD PTR [rsp+184]
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
$LN6@RadixDirec:

; 458  :         return( EmitError( INVALID_RADIX_TAG ) );

	mov	ecx, 181				; 000000b5H
$LN8@RadixDirec:
	call	EmitError

; 465  : }

	mov	rbx, QWORD PTR [rsp+184]
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
RadixDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
SegOrderDirective PROC

; 471  : {

$LN10:
	sub	rsp, 40					; 00000028H
	mov	r8, rdx

; 472  :     if ( tokenarray[i+1].token != T_FINAL ) {

	movsxd	rcx, ecx
	lea	rdx, QWORD PTR [rcx+1]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+r8], 0
	je	SHORT $LN2@SegOrderDi

; 473  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].tokpos ) );

	mov	rdx, QWORD PTR [rdx+r8+24]
	mov	ecx, 209				; 000000d1H

; 491  : }

	add	rsp, 40					; 00000028H

; 473  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].tokpos ) );

	jmp	EmitErr
$LN2@SegOrderDi:
	mov	edx, DWORD PTR Options+144
	lea	eax, DWORD PTR [rdx-2]
	cmp	eax, 1
	jbe	SHORT $LN5@SegOrderDi

; 474  :     }
; 475  : #if COFF_SUPPORT || ELF_SUPPORT || PE_SUPPORT
; 476  :     if ( Options.output_format == OFORMAT_COFF
; 477  : #if ELF_SUPPORT
; 478  :         || Options.output_format == OFORMAT_ELF
; 479  : #endif
; 480  : #if PE_SUPPORT
; 481  :         || ( Options.output_format == OFORMAT_BIN && ModuleInfo.sub_format == SFORMAT_PE )

	test	edx, edx
	jne	SHORT $LN3@SegOrderDi
	cmp	DWORD PTR ModuleInfo+372, 2
	je	SHORT $LN5@SegOrderDi
$LN3@SegOrderDi:

; 486  :     } else
; 487  : #endif
; 488  :         ModuleInfo.segorder = GetSflagsSp( tokenarray[i].tokval );

	shl	rcx, 5
	mov	eax, DWORD PTR [rcx+r8+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, OFFSET FLAT:SpecialTable+4
	mov	eax, DWORD PTR [rax+rcx*4]
	mov	DWORD PTR ModuleInfo+380, eax

; 489  : 
; 490  :     return( NOT_ERROR );

	xor	eax, eax

; 491  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN5@SegOrderDi:

; 482  : #endif
; 483  :        ) {
; 484  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN6@SegOrderDi

; 485  :             EmitWarn( 2, NOT_SUPPORTED_WITH_CURR_FORMAT, _strupr( tokenarray[i].string_ptr ) );

	shl	rcx, 5
	mov	rcx, QWORD PTR [rcx+r8+8]
	call	_strupr
	mov	r8, rax
	mov	edx, 224				; 000000e0H
	mov	ecx, 2
	call	EmitWarn
$LN6@SegOrderDi:

; 489  : 
; 490  :     return( NOT_ERROR );

	xor	eax, eax

; 491  : }

	add	rsp, 40					; 00000028H
	ret	0
SegOrderDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
i$ = 8
tokenarray$ = 16
StubDir	PROC

; 48   : ret_code StubDir( int i, struct asm_tok tokenarray[] ){ return( ERROR ); }

	or	eax, -1
	ret	0
StubDir	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
IncludeDirective PROC

; 70   : {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 71   :     char *name;
; 72   : 
; 73   :     DebugMsg1(("IncludeDirective enter\n"));
; 74   : 
; 75   :     if ( CurrFile[LST] ) {

	cmp	QWORD PTR ModuleInfo+112, 0
	mov	rsi, rdx
	mov	ebx, ecx
	je	SHORT $LN5@IncludeDir

; 76   :         LstWriteSrcLine();

	call	LstWriteSrcLine
$LN5@IncludeDir:

; 77   :     }
; 78   : 
; 79   :     i++; /* skip directive */

	inc	ebx

; 80   :     /* v2.03: allow plain numbers as file name argument */
; 81   :     //if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_NUM ) {
; 82   :     if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rcx, ebx
	mov	rax, rcx
	shl	rax, 5
	lea	rdi, QWORD PTR [rax+rsi]
	movzx	eax, BYTE PTR [rax+rsi]
	test	al, al
	jne	SHORT $LN6@IncludeDir

; 83   :         return( EmitError( EXPECTED_FILE_NAME ) );

	mov	ecx, 112				; 00000070H

; 103  :     return( NOT_ERROR );
; 104  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 83   :         return( EmitError( EXPECTED_FILE_NAME ) );

	jmp	EmitError
$LN6@IncludeDir:

; 84   :     }
; 85   : 
; 86   :     /* if the filename is enclosed in <>, just use this literal */
; 87   : 
; 88   :     if ( tokenarray[i].token == T_STRING && tokenarray[i].string_delim == '<' ) {

	cmp	al, 9
	jne	SHORT $LN7@IncludeDir
	cmp	BYTE PTR [rdi+1], 60			; 0000003cH
	jne	SHORT $LN7@IncludeDir

; 89   :         if ( tokenarray[i+1].token != T_FINAL ) {

	lea	rdx, QWORD PTR [rcx+1]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rsi], 0
	je	SHORT $LN9@IncludeDir

; 90   :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rsi+24]
	mov	ecx, 209				; 000000d1H

; 103  :     return( NOT_ERROR );
; 104  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 90   :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].tokpos ) );

	jmp	EmitErr
$LN9@IncludeDir:

; 91   :         }
; 92   :         name = tokenarray[i].string_ptr;

	mov	rdi, QWORD PTR [rdi+8]

; 93   :     } else {

	jmp	SHORT $LN16@IncludeDir
$LN7@IncludeDir:

; 94   :         char *p;
; 95   :         /* if the filename isn't enclosed in <>, use anything that comes
; 96   :          * after INCLUDE - and remove trailing white spaces.
; 97   :          */
; 98   :         name = tokenarray[i].tokpos;
; 99   :         for ( p = tokenarray[Token_Count].tokpos - 1; p > name && isspace(*p); *p = NULLC, p-- );

	movsxd	rax, DWORD PTR ModuleInfo+496
	mov	rdi, QWORD PTR [rdi+24]
	shl	rax, 5
	mov	rbx, QWORD PTR [rax+rsi+24]
	dec	rbx
	cmp	rbx, rdi
	jbe	SHORT $LN16@IncludeDir
	npad	4
$LL4@IncludeDir:
	movsx	ecx, BYTE PTR [rbx]
	call	isspace
	test	eax, eax
	je	SHORT $LN16@IncludeDir
	mov	BYTE PTR [rbx], 0
	dec	rbx
	cmp	rbx, rdi
	ja	SHORT $LL4@IncludeDir
$LN16@IncludeDir:

; 100  :     }
; 101  :     if ( SearchFile( name, TRUE ) )

	mov	dl, 1
	mov	rcx, rdi
	call	SearchFile
	test	rax, rax
	je	SHORT $LN10@IncludeDir

; 102  :         ProcessFile( tokenarray );   /* v2.11: process the file synchronously */

	mov	rcx, rsi
	call	ProcessFile
$LN10@IncludeDir:

; 103  :     return( NOT_ERROR );
; 104  : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
IncludeDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 950  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	rbx, rax
	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 955  :     __crt_va_end(_ArgList);
; 956  :     return _Result;
; 957  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 640  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
