; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
COMM	MacroLevel:BYTE
COMM	MacroLocals:DWORD
_DATA	ENDS
_BSS	SEGMENT
$SG11072 DB	01H DUP (?)
$SG11143 DB	01H DUP (?)
_BSS	ENDS
PUBLIC	myltoa
PUBLIC	RunMacro
PUBLIC	ExpandText
PUBLIC	ExpandLineItems
PUBLIC	ExpandLine
PUBLIC	ExpandLiterals
EXTRN	isalpha:PROC
EXTRN	isspace:PROC
EXTRN	isalnum:PROC
EXTRN	strchr:PROC
EXTRN	_memicmp:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	SymFind:PROC
EXTRN	ParseLine:PROC
EXTRN	WritePreprocessedLine:PROC
EXTRN	PreprocessLine:PROC
EXTRN	WriteCodeLabel:PROC
EXTRN	EvalOperand:PROC
EXTRN	GetTextLine:PROC
EXTRN	PushMacro:PROC
EXTRN	SetLineNumber:PROC
EXTRN	PushInputStatus:PROC
EXTRN	PopInputStatus:PROC
EXTRN	Tokenize:PROC
EXTRN	fill_placeholders:PROC
EXTRN	TextItemError:PROC
EXTRN	GetIfNestLevel:PROC
EXTRN	SetIfNestLevel:PROC
EXTRN	LstWriteSrcLine:PROC
EXTRN	__chkstk:PROC
EXTRN	memcpy:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	__ImageBase:BYTE
pdata	SEGMENT
$pdata$myltoa DD imagerel $LN16
	DD	imagerel $LN16+45
	DD	imagerel $unwind$myltoa
$pdata$0$myltoa DD imagerel $LN16+45
	DD	imagerel $LN16+95
	DD	imagerel $chain$0$myltoa
$pdata$1$myltoa DD imagerel $LN16+95
	DD	imagerel $LN16+164
	DD	imagerel $chain$1$myltoa
$pdata$RunMacro DD imagerel $LN436
	DD	imagerel $LN436+4846
	DD	imagerel $unwind$RunMacro
$pdata$ExpandText DD imagerel $LN103
	DD	imagerel $LN103+1268
	DD	imagerel $unwind$ExpandText
$pdata$ExpandLineItems DD imagerel $LN25
	DD	imagerel $LN25+232
	DD	imagerel $unwind$ExpandLineItems
$pdata$ExpandLine DD imagerel $LN102
	DD	imagerel $LN102+1080
	DD	imagerel $unwind$ExpandLine
$pdata$ExpandLiterals DD imagerel $LN20
	DD	imagerel $LN20+31
	DD	imagerel $unwind$ExpandLiterals
$pdata$0$ExpandLiterals DD imagerel $LN20+31
	DD	imagerel $LN20+143
	DD	imagerel $chain$0$ExpandLiterals
$pdata$1$ExpandLiterals DD imagerel $LN20+143
	DD	imagerel $LN20+154
	DD	imagerel $chain$1$ExpandLiterals
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ExpandTMacro DD imagerel ExpandTMacro
	DD	imagerel ExpandTMacro+67
	DD	imagerel $unwind$ExpandTMacro
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ExpandTMacro DD imagerel ExpandTMacro+67
	DD	imagerel ExpandTMacro+288
	DD	imagerel $chain$2$ExpandTMacro
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ExpandTMacro DD imagerel ExpandTMacro+288
	DD	imagerel ExpandTMacro+758
	DD	imagerel $chain$4$ExpandTMacro
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SkipMacro DD imagerel SkipMacro
	DD	imagerel SkipMacro+74
	DD	imagerel $unwind$SkipMacro
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RebuildLine DD imagerel RebuildLine
	DD	imagerel RebuildLine+429
	DD	imagerel $unwind$RebuildLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ExpandToken DD imagerel ExpandToken
	DD	imagerel ExpandToken+1381
	DD	imagerel $unwind$ExpandToken
pdata	ENDS
CONST	SEGMENT
__digits DB	'0123456789ABCDEF'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ExpandToken DD 0b2e01H
	DD	0a6342eH
	DD	09c012eH
	DD	0e01df01fH
	DD	0c019d01bH
	DD	060167017H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RebuildLine DD 0d1f01H
	DD	08d641fH
	DD	08b541fH
	DD	08a341fH
	DD	084011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SkipMacro DD 030901H
	DD	0840109H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ExpandTMacro DD 060021H
	DD	08b7400H
	DD	08c6400H
	DD	08d5400H
	DD	imagerel ExpandTMacro
	DD	imagerel ExpandTMacro+67
	DD	imagerel $unwind$ExpandTMacro
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ExpandTMacro DD 061821H
	DD	08b7418H
	DD	08c6410H
	DD	08d5408H
	DD	imagerel ExpandTMacro
	DD	imagerel ExpandTMacro+67
	DD	imagerel $unwind$ExpandTMacro
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ExpandTMacro DD 031c01H
	DD	08e011cH
	DD	03015H
xdata	ENDS
xdata	SEGMENT
$unwind$myltoa DD 020601H
	DD	030029206H
$chain$0$myltoa DD 020521H
	DD	0c7405H
	DD	imagerel $LN16
	DD	imagerel $LN16+45
	DD	imagerel $unwind$myltoa
$chain$1$myltoa DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+45
	DD	imagerel $unwind$myltoa
$unwind$RunMacro DD 035072301H
	DD	011e3323H
	DD	0701700afH
	DD	030156016H
	DD	05014H
$unwind$ExpandText DD 0a2201H
	DD	01f0122H
	DD	0e019f01bH
	DD	0c015d017H
	DD	060127013H
	DD	030105011H
$unwind$ExpandLineItems DD 0c1c01H
	DD	0f641cH
	DD	0e541cH
	DD	0c341cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
$unwind$ExpandLine DD 0c1c01H
	DD	0f641cH
	DD	0d541cH
	DD	0c341cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
$unwind$ExpandLiterals DD 040a01H
	DD	07340aH
	DD	07006320aH
$chain$0$ExpandLiterals DD 020521H
	DD	066405H
	DD	imagerel $LN20
	DD	imagerel $LN20+31
	DD	imagerel $unwind$ExpandLiterals
$chain$1$ExpandLiterals DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+31
	DD	imagerel $unwind$ExpandLiterals
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
;	COMDAT ExpandToken
_TEXT	SEGMENT
evaluate$1$ = 48
i$3$ = 52
tmp$ = 56
is_exitm$ = 60
tmpbuf$1 = 64
opndx$ = 112
buffer$ = 224
line$ = 1312
pi$ = 1320
tokenarray$ = 1328
pos$ = 1336
max$ = 1336
bracket_flags$ = 1344
equmode$ = 1352
ExpandToken PROC					; COMDAT

; 1101 : {

	mov	QWORD PTR [rsp+24], rbx
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-992]
	sub	rsp, 1248				; 000004e0H

; 1102 :     int pos;
; 1103 :     int tmp;
; 1104 :     int i = *pi;

	mov	ebx, DWORD PTR [rdx]

; 1105 :     int size;
; 1106 :     int addbrackets = bracket_flags;
; 1107 :     char evaluate = FALSE;

	xor	cl, cl
	mov	r13d, DWORD PTR bracket_flags$[rbp-256]

; 1108 :     //char *p;
; 1109 :     bool is_exitm;
; 1110 :     struct expr opndx;
; 1111 :     struct asym *sym;
; 1112 :     ret_code rc = NOT_ERROR;

	xor	r14d, r14d
	mov	BYTE PTR evaluate$1$[rsp], cl
	mov	r15, r8
	mov	r12d, r14d

; 1113 :     char buffer[MAX_LINE_LEN];
; 1114 : 
; 1115 :     for ( ; i < max && tokenarray[i].token != T_COMMA; i++ ) {

	cmp	ebx, r9d
	jge	$LN78@ExpandToke
	mov	esi, DWORD PTR pos$[rbp-256]
	mov	DWORD PTR i$3$[rsp], esi
	npad	7
$LL4@ExpandToke:
	movsxd	rax, ebx
	shl	rax, 5
	lea	rsi, QWORD PTR [rax+r15]
	movzx	eax, BYTE PTR [rax+r15]
	cmp	al, 44					; 0000002cH
	je	$LN85@ExpandToke

; 1116 :         /* v2.05: the '%' should only be handled as an operator if addbrackets==TRUE,
; 1117 :          * which means that the current directive is a preprocessor directive and the
; 1118 :          * expected argument is a literal (or text macro).
; 1119 :          */
; 1120 :         if ( tokenarray[i].token == T_PERCENT && addbrackets && evaluate == FALSE ) {

	cmp	al, 37					; 00000025H
	jne	SHORT $LN8@ExpandToke
	test	r13d, r13d
	je	$LN88@ExpandToke
	test	cl, cl
	jne	$LN88@ExpandToke

; 1121 :             evaluate = TRUE;

	mov	cl, 1

; 1122 :             addbrackets = FALSE;
; 1123 :             equmode = FALSE;

	mov	DWORD PTR equmode$[rbp-256], r14d
	mov	BYTE PTR evaluate$1$[rsp], cl
	mov	r13d, r14d

; 1124 :             pos = i;

	mov	edx, ebx
	mov	DWORD PTR i$3$[rsp], ebx

; 1125 :             DebugMsg1(("ExpandToken: %% found, line=%s\n", tokenarray[i].tokpos ));
; 1126 :             continue;

	jmp	$LN2@ExpandToke
$LN8@ExpandToke:

; 1127 :         }
; 1128 :         if( tokenarray[i].token == T_ID ) {

	cmp	al, 8
	jne	$LN88@ExpandToke

; 1129 :             sym = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rsi+8]
	call	SymFind
	mov	rdi, rax

; 1130 :             DebugMsg1(("ExpandToken: testing id >%s< equmode=%u\n", tokenarray[i].string_ptr, equmode ));
; 1131 :             /* don't check isdefined flag (which cannot occur in pass one, and this code usually runs
; 1132 :              * in pass one only!
; 1133 :              */
; 1134 :             //if( sym && sym->isdefined ) {
; 1135 :             if( sym ) {

	test	rax, rax
	je	$LN84@ExpandToke

; 1136 :                 if ( sym->state == SYM_MACRO ) {

	mov	eax, DWORD PTR [rax+32]
	cmp	eax, 9
	jne	$LN11@ExpandToke

; 1137 :                     tmp = i; /* save index of macro name */

	mov	DWORD PTR tmp$[rsp], ebx
	mov	ecx, ebx

; 1138 :                     if ( sym->isfunc == TRUE ) {

	movzx	eax, BYTE PTR [rdi+44]
	test	al, 2
	je	$LN13@ExpandToke

; 1139 :                         /* ignore macro functions without a following '(' */
; 1140 :                         if ( tokenarray[i+1].token != T_OP_BRACKET ) {

	cmp	BYTE PTR [rsi+32], 40			; 00000028H
	jne	$LN84@ExpandToke

; 1141 :                             DebugMsg1(("ExpandToken(%s): macro function without () - not expanded!\n", sym->name ));
; 1142 :                             continue;
; 1143 :                         }
; 1144 :                         i++;
; 1145 :                         if ( equmode == TRUE ) {

	cmp	DWORD PTR equmode$[rbp-256], 1
	jne	SHORT $LN16@ExpandToke

; 1147 :                             /* go beyond the ')' */
; 1148 :                             for ( tmp = 1; i < max; i++ ) {

	movsxd	r9, DWORD PTR max$[rbp-256]
	add	ebx, 2
	movsxd	rdx, ebx
	mov	eax, 1
	mov	DWORD PTR tmp$[rsp], eax
	cmp	rdx, r9
	jge	SHORT $LN80@ExpandToke

; 1146 :                             i++; /* skip '(' */

	mov	rcx, rdx
	shl	rcx, 5
	add	rcx, r15
	npad	5
$LL7@ExpandToke:

; 1149 :                                 if ( tokenarray[i].token == T_OP_BRACKET )

	movzx	r8d, BYTE PTR [rcx]
	cmp	r8b, 40					; 00000028H
	jne	SHORT $LN17@ExpandToke

; 1150 :                                     tmp++;

	inc	eax
	mov	DWORD PTR tmp$[rsp], eax
	jmp	SHORT $LN5@ExpandToke
$LN17@ExpandToke:

; 1151 :                                 else if ( tokenarray[i].token == T_CL_BRACKET ) {

	cmp	r8b, 41					; 00000029H
	jne	SHORT $LN5@ExpandToke

; 1152 :                                     tmp--;

	sub	eax, 1
	mov	DWORD PTR tmp$[rsp], eax

; 1153 :                                     if ( tmp == 0 )

	je	SHORT $LN80@ExpandToke
$LN5@ExpandToke:

; 1147 :                             /* go beyond the ')' */
; 1148 :                             for ( tmp = 1; i < max; i++ ) {

	inc	ebx
	inc	rdx
	add	rcx, 32					; 00000020H
	cmp	rdx, r9
	jl	SHORT $LL7@ExpandToke
$LN80@ExpandToke:

; 1154 :                                         break;
; 1155 :                                 }
; 1156 :                             }
; 1157 :                             i--;

	dec	ebx

; 1158 :                             continue;

	jmp	$LN84@ExpandToke
$LN16@ExpandToke:

; 1159 :                         }
; 1160 :                         //DebugMsg1(("ExpandToken: macro function %s to be expanded\n", sym->name ));
; 1161 :                         i = RunMacro( (struct dsym *)sym, i, tokenarray, buffer,

	mov	eax, r14d
	lea	rcx, QWORD PTR is_exitm$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	lea	r9, QWORD PTR buffer$[rbp-256]
	cmp	ebx, 1
	lea	edx, DWORD PTR [rbx+1]
	mov	r8, r15
	mov	rcx, rdi
	sete	al
	mov	DWORD PTR [rsp+32], eax
	call	RunMacro
	movsxd	r12, eax

; 1162 : #if MACROLABEL
; 1163 :                                      (tmp == 1 ? MF_LABEL : 0),
; 1164 : #else
; 1165 :                                      0,
; 1166 : #endif
; 1167 :                                      &is_exitm );
; 1168 :                         if ( i == -1 )

	cmp	r12d, -1
	je	$LN58@ExpandToke

; 1170 :                         DebugMsg1(("ExpandToken(%s, addbr=%u): macro function expanded to >%s<\n", sym->name, addbrackets, buffer));
; 1171 :                         /* expand text, but don't if macro was at position 0 (might be a text macro definition directive */
; 1172 :                         /* v2.09: don't expand further if addbrackets is set */
; 1173 :                         if ( tmp && (!addbrackets) && ( ERROR == ExpandTMacro( buffer, tokenarray, equmode, 0 ) ) )

	mov	esi, DWORD PTR tmp$[rsp]
	test	esi, esi
	je	SHORT $LN22@ExpandToke
	test	r13d, r13d
	jne	SHORT $LN22@ExpandToke
	mov	r8d, DWORD PTR equmode$[rbp-256]
	lea	rcx, QWORD PTR buffer$[rbp-256]
	xor	r9d, r9d
	mov	rdx, r15
	call	ExpandTMacro
	cmp	eax, -1
	je	$LN58@ExpandToke
	mov	esi, DWORD PTR tmp$[rsp]
$LN22@ExpandToke:

; 1174 :                             return( ERROR );
; 1175 :                         /* get size of string to replace ( must be done before AddTokens() */
; 1176 :                         size = ( tokenarray[i-1].tokpos + 1) - tokenarray[tmp].tokpos;
; 1177 :                         AddTokens( tokenarray, tmp+1, tmp+1 - i, Token_Count );

	mov	r9d, DWORD PTR ModuleInfo+496
	lea	edx, DWORD PTR [rsi+1]
	mov	rcx, r12
	movsxd	rbx, esi
	shl	rcx, 5
	mov	r8d, esi
	shl	rbx, 5
	sub	r8d, r12d
	inc	r8d
	mov	edi, DWORD PTR [rcx+r15-8]
	mov	rcx, r15
	sub	edi, DWORD PTR [rbx+r15+24]
	call	AddTokens

; 1178 :                         Token_Count += (tmp+1) - i;

	mov	eax, DWORD PTR ModuleInfo+496

; 1179 :                         if ( Token_Count < max ) /* take care not to read beyond T_FINAL */
; 1180 :                             max = Token_Count;
; 1181 :                         if ( ERROR == RebuildLine( buffer, tmp, tokenarray,

	lea	r9d, DWORD PTR [rdi+1]
	inc	eax
	mov	DWORD PTR [rsp+40], r13d
	mov	ecx, esi
	mov	r8, r15
	sub	ecx, r12d
	mov	edx, esi
	add	ecx, eax
	mov	eax, DWORD PTR max$[rbp-256]
	cmp	ecx, eax
	mov	DWORD PTR ModuleInfo+496, ecx
	cmovl	eax, ecx
	lea	rcx, QWORD PTR buffer$[rbp-256]
	mov	DWORD PTR max$[rbp-256], eax
	mov	eax, DWORD PTR [rbx+r15+24]
	sub	eax, DWORD PTR line$[rbp-256]
	mov	DWORD PTR [rsp+32], eax
	call	RebuildLine
	cmp	eax, -1
	je	$LN58@ExpandToke

; 1182 :                                                   size, tokenarray[tmp].tokpos - line, addbrackets ) )
; 1183 :                             return( ERROR );
; 1184 :                         rc = STRING_EXPANDED;
; 1185 :                         i = tmp;

	mov	ebx, DWORD PTR tmp$[rsp]

; 1239 :                         break;
; 1240 :                     }

	jmp	$LN89@ExpandToke
$LN13@ExpandToke:

; 1186 :                     } else {
; 1187 :                         /* a macro proc is expanded at pos 0 or pos 2
; 1188 :                          * (or at pos 1 if sym->label is on)
; 1189 :                          */
; 1190 :                         if ( i == 0 ||
; 1191 :                             ( i == 2 && ( tokenarray[1].token == T_COLON ||
; 1192 :                                          tokenarray[1].token == T_DBL_COLON ))
; 1193 : #if MACROLABEL
; 1194 :                             || ( i == 1 && sym->label )

	test	ebx, ebx
	je	SHORT $LN30@ExpandToke
	cmp	ebx, 2
	jne	SHORT $LN28@ExpandToke
	movzx	eax, BYTE PTR [r15+32]
	cmp	al, 58					; 0000003aH
	je	SHORT $LN75@ExpandToke
	cmp	al, 13
	jne	$LN84@ExpandToke
$LN75@ExpandToke:

; 1202 : #else
; 1203 :                             return( EmitErr( SYNTAX_ERROR_EX, sym->name ) );
; 1204 : #endif
; 1205 :                         }
; 1206 :                         /* v2.08: write optional code label. This has been
; 1207 :                          * moved out from RunMacro().
; 1208 :                          */
; 1209 :                         if ( i == 2 ) {
; 1210 :                             if ( ERROR == WriteCodeLabel( line, tokenarray ) )

	mov	rcx, QWORD PTR line$[rbp-256]
	mov	rdx, r15
	call	WriteCodeLabel
	cmp	eax, -1
	je	$LN58@ExpandToke
$LN30@ExpandToke:

; 1211 :                                 return( ERROR );
; 1212 :                         }
; 1213 :                         //buffer[0] = NULLC; /* nothing should be returned, just to be safe */
; 1214 :                         DebugMsg1(("ExpandToken(%s): macro proc to be expanded\n", sym->name ));
; 1215 :                         i = RunMacro( (struct dsym *)sym, i+1, tokenarray, NULL,

	mov	eax, r14d
	lea	rcx, QWORD PTR is_exitm$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	lea	edx, DWORD PTR [rbx+1]
	cmp	ebx, 1
	mov	r8, r15
	mov	rcx, rdi
	sete	al
	xor	r9d, r9d
	or	eax, 2
	mov	DWORD PTR [rsp+32], eax
	call	RunMacro

; 1216 : #if MACROLABEL
; 1217 :                                      MF_NOSAVE | (i == 1 ? MF_LABEL : 0),
; 1218 : #else
; 1219 :                                      MF_NOSAVE,
; 1220 : #endif
; 1221 :                                      &is_exitm );
; 1222 :                         DebugMsg1(("ExpandToken(%s): macro proc called\n", sym->name));
; 1223 :                         if ( i == -1 )

	cmp	eax, -1
	sete	r14b
	lea	eax, DWORD PTR [r14-2]

; 1224 :                             return( ERROR );
; 1225 : #if 0
; 1226 :                         /* it's possible to "hide" the EXITM directive when the
; 1227 :                          * macro lines are read. But it's not useful for macro
; 1228 :                          * procs to check if exitm has been executed, because
; 1229 :                          * Masm simply will ignore anything that's "returned".
; 1230 :                          */
; 1231 :                         if ( is_exitm ) {
; 1232 :                             DebugMsg(("ExpandToken: EXITM in macro procedure!\n" ));
; 1233 :                             strcat( buffer, tokenarray[tmp].tokpos );
; 1234 :                             strcpy( line, buffer );
; 1235 :                             rc = STRING_EXPANDED;
; 1236 :                         } else
; 1237 : #endif
; 1238 :                             return( EMPTY ); /* no further processing */

	jmp	$LN1@ExpandToke
$LN28@ExpandToke:

; 1186 :                     } else {
; 1187 :                         /* a macro proc is expanded at pos 0 or pos 2
; 1188 :                          * (or at pos 1 if sym->label is on)
; 1189 :                          */
; 1190 :                         if ( i == 0 ||
; 1191 :                             ( i == 2 && ( tokenarray[1].token == T_COLON ||
; 1192 :                                          tokenarray[1].token == T_DBL_COLON ))
; 1193 : #if MACROLABEL
; 1194 :                             || ( i == 1 && sym->label )

	cmp	ebx, 1
	jne	$LN84@ExpandToke
	test	al, 4
	jne	SHORT $LN30@ExpandToke

; 1195 : #endif
; 1196 :                            )
; 1197 :                             ;
; 1198 :                         else {
; 1199 :                             DebugMsg1(("ExpandToken(%s): macro proc at pos %u NOT expanded\n", sym->name, i ));
; 1200 : #if 1 /* v2.03: no error, just don't expand! */
; 1201 :                             continue;

	jmp	$LN84@ExpandToke
$LN11@ExpandToke:

; 1241 :                 } else if( sym->state == SYM_TMACRO ) {

	cmp	eax, 10
	jne	SHORT $LN84@ExpandToke

; 1242 : 
; 1243 :                     //GetLiteralValue( buffer, sym->string_ptr );
; 1244 :                     strcpy( buffer, sym->string_ptr );

	mov	rcx, QWORD PTR [rdi+16]
	lea	rdx, QWORD PTR buffer$[rbp-256]
	npad	7
$LL43@ExpandToke:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL43@ExpandToke

; 1245 :                     if ( ERROR == ExpandTMacro( buffer, tokenarray, equmode, 0 ) )

	mov	r8d, DWORD PTR equmode$[rbp-256]
	lea	rcx, QWORD PTR buffer$[rbp-256]
	xor	r9d, r9d
	mov	rdx, r15
	call	ExpandTMacro
	cmp	eax, -1
	je	SHORT $LN58@ExpandToke

; 1247 :                     DebugMsg1(("ExpandToken(%s, addbr=%u): value >%s< expanded to >%s<\n", sym->name, addbrackets, sym->string_ptr, buffer ));
; 1248 :                     if ( ERROR == RebuildLine( buffer, i, tokenarray, strlen( tokenarray[i].string_ptr ),

	mov	ecx, DWORD PTR [rsi+24]
	sub	ecx, DWORD PTR line$[rbp-256]
	mov	rax, QWORD PTR [rsi+8]
	or	r9, -1
	npad	3
$LL77@ExpandToke:
	inc	r9
	cmp	BYTE PTR [rax+r9], r14b
	jne	SHORT $LL77@ExpandToke
	mov	DWORD PTR [rsp+40], r13d
	mov	r8, r15
	mov	DWORD PTR [rsp+32], ecx
	mov	edx, ebx
	lea	rcx, QWORD PTR buffer$[rbp-256]
	call	RebuildLine
	cmp	eax, -1
	je	SHORT $LN58@ExpandToke
$LN89@ExpandToke:

; 1249 :                                               tokenarray[i].tokpos - line, addbrackets ) )
; 1250 :                         return( ERROR );
; 1251 :                     rc = STRING_EXPANDED;

	mov	r12d, 1
$LN84@ExpandToke:
	movzx	ecx, BYTE PTR evaluate$1$[rsp]
$LN88@ExpandToke:
	mov	edx, DWORD PTR i$3$[rsp]
$LN2@ExpandToke:

; 1113 :     char buffer[MAX_LINE_LEN];
; 1114 : 
; 1115 :     for ( ; i < max && tokenarray[i].token != T_COMMA; i++ ) {

	inc	ebx
	cmp	ebx, DWORD PTR max$[rbp-256]
	jl	$LL4@ExpandToke
	jmp	SHORT $LN76@ExpandToke
$LN58@ExpandToke:

; 1169 :                             return( ERROR );

	or	eax, -1
	jmp	$LN1@ExpandToke
$LN78@ExpandToke:

; 1246 :                         return( ERROR );

	mov	edx, DWORD PTR pos$[rbp-256]
	mov	DWORD PTR i$3$[rsp], edx
	jmp	SHORT $LN76@ExpandToke
$LN85@ExpandToke:
	mov	edx, DWORD PTR i$3$[rsp]
$LN76@ExpandToke:

; 1252 :                     DebugMsg1(("ExpandToken(%s): rest after expansion: %s\n", sym->name, tokenarray[i].tokpos ));
; 1253 :                 }
; 1254 :             }
; 1255 :         }
; 1256 :     }
; 1257 :     *pi = i;

	mov	r13, QWORD PTR pi$[rbp-256]
	mov	DWORD PTR [r13], ebx

; 1258 :     if ( evaluate ) {

	test	cl, cl
	je	$LN35@ExpandToke

; 1259 :         int old_tokencount = Token_Count;

	mov	edi, DWORD PTR ModuleInfo+496

; 1260 :         if ( i == (pos+1) ) { /* just a single %? */

	lea	eax, DWORD PTR [rdx+1]
	cmp	ebx, eax
	jne	SHORT $LN36@ExpandToke

; 1261 :             opndx.value = 0;

	mov	DWORD PTR opndx$[rsp], r14d

; 1262 :             i = pos;
; 1263 :         } else {

	jmp	$LN37@ExpandToke
$LN36@ExpandToke:

; 1264 :             i = pos++;

	mov	DWORD PTR i$3$[rsp], edx

; 1265 :             tmp = tokenarray[*pi].tokpos - tokenarray[pos].tokpos;

	movsxd	rdx, eax
	movsxd	rax, DWORD PTR [r13]
	shl	rdx, 5
	shl	rax, 5
	mov	ecx, DWORD PTR [rax+r15+24]
	sub	ecx, DWORD PTR [rdx+r15+24]

; 1266 :             memcpy( buffer, tokenarray[pos].tokpos, tmp );

	mov	rdx, QWORD PTR [rdx+r15+24]
	movsxd	rbx, ecx
	mov	DWORD PTR tmp$[rsp], ecx
	mov	r8, rbx
	lea	rcx, QWORD PTR buffer$[rbp-256]
	call	memcpy

; 1267 :             buffer[tmp] = NULLC;
; 1268 :             tmp = old_tokencount + 1;

	lea	edx, DWORD PTR [rdi+1]
	mov	BYTE PTR buffer$[rbp+rbx-256], r14b

; 1269 :             Token_Count = Tokenize( buffer, tmp, tokenarray, TOK_RESCAN );

	mov	r9d, 1
	mov	DWORD PTR tmp$[rsp], edx
	mov	r8, r15
	lea	rcx, QWORD PTR buffer$[rbp-256]
	call	Tokenize

; 1270 :             if ( EvalOperand( &tmp, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	lea	r9, QWORD PTR opndx$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax
	mov	r8d, eax
	mov	BYTE PTR [rsp+32], 2
	mov	rdx, r15
	lea	rcx, QWORD PTR tmp$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN38@ExpandToke

; 1271 :                 opndx.value = 0; /* v2.09: assume value 0, don't return with ERROR */

	mov	DWORD PTR opndx$[rsp], r14d
	jmp	SHORT $LN40@ExpandToke
$LN38@ExpandToke:

; 1272 :             else if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rbp-196], r14d
	je	SHORT $LN79@ExpandToke

; 1273 :                 /* v2.09: with flag EXPF_NOUNDEF, EvalOperand() will have returned
; 1274 :                  * with error if there's an undefined symbol involved
; 1275 :                  */
; 1276 :                 //if ( opndx.sym && opndx.sym->state == SYM_UNDEFINED )
; 1277 :                 //    EmitErr( SYMBOL_NOT_DEFINED, opndx.sym->name );
; 1278 :                 //else {
; 1279 :                     DebugMsg(("ExpandToken: 'constant expected' error\n"));
; 1280 :                     EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 1281 :                 //}
; 1282 :                 //return( ERROR );
; 1283 :                 opndx.value = 0; /* assume value 0 */

	mov	DWORD PTR opndx$[rsp], r14d
	jmp	SHORT $LN40@ExpandToke
$LN79@ExpandToke:
	mov	r14d, DWORD PTR opndx$[rsp]
$LN40@ExpandToke:

; 1284 :             }
; 1285 :             Token_Count = old_tokencount;

	mov	DWORD PTR ModuleInfo+496, edi
$LN37@ExpandToke:

; 1286 :         }
; 1287 : #if TEVALUE_UNSIGNED
; 1288 :         /* v2.03: Masm compatible: returns an unsigned value */
; 1289 :         myltoa( opndx.value, StringBufferEnd, ModuleInfo.radix, FALSE, FALSE );

	movzx	r10d, BYTE PTR ModuleInfo+396
	mov	rcx, QWORD PTR ModuleInfo+488
	test	r14d, r14d
	jne	SHORT $LN50@ExpandToke
	mov	WORD PTR [rcx], 48			; 00000030H
	jmp	SHORT $LN44@ExpandToke
$LN50@ExpandToke:
	lea	r9, QWORD PTR tmpbuf$1[rsp+33]
	mov	BYTE PTR tmpbuf$1[rsp+33], 0
	lea	r11, OFFSET FLAT:__digits
	npad	13
$LL47@ExpandToke:
	xor	edx, edx
	mov	eax, r14d
	div	r10d
	dec	r9
	mov	r14d, eax
	movzx	eax, BYTE PTR [rdx+r11]
	mov	BYTE PTR [r9], al
	test	r14d, r14d
	jne	SHORT $LL47@ExpandToke
	lea	r8, QWORD PTR tmpbuf$1[rsp+34]
	mov	rdx, r9
	sub	r8, r9
	call	memcpy
$LN44@ExpandToke:

; 1290 : #else
; 1291 :         myltoa( opndx.value, StringBufferEnd, ModuleInfo.radix, opndx.hvalue < 0, FALSE );
; 1292 : #endif
; 1293 :             /* v2.05: get size of string to be "replaced" */
; 1294 :         tmp = tokenarray[*pi].tokpos - tokenarray[i].tokpos;

	movsxd	rax, DWORD PTR [r13]

; 1295 :         DebugMsg1(("ExpandToken: curr pos=%u, start expr=%u, expr size=%d\n", *pi, i, tmp ));
; 1296 : 
; 1297 :         //tokenarray[i].token = T_STRING;
; 1298 :         tokenarray[i].string_ptr = StringBufferEnd;
; 1299 :         AddTokens( tokenarray, i+1, i+1 - *pi, Token_Count );

	mov	rcx, r15
	movsxd	rsi, DWORD PTR i$3$[rsp]
	shl	rax, 5
	mov	rdi, rsi
	shl	rdi, 5
	mov	r8d, esi
	lea	edx, DWORD PTR [rsi+1]
	mov	ebx, DWORD PTR [rax+r15+24]
	mov	rax, QWORD PTR ModuleInfo+488
	sub	ebx, DWORD PTR [rdi+r15+24]
	mov	QWORD PTR [rdi+r15+8], rax
	sub	r8d, DWORD PTR [r13]
	mov	r9d, DWORD PTR ModuleInfo+496
	inc	r8d
	mov	DWORD PTR tmp$[rsp], ebx
	call	AddTokens

; 1300 :         Token_Count += (i+1) - *pi;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	ecx, esi
	sub	ecx, DWORD PTR [r13]
	inc	eax
	add	ecx, eax

; 1301 : 
; 1302 :         if ( ERROR == RebuildLine( StringBufferEnd, i, tokenarray,

	mov	r9d, ebx
	mov	DWORD PTR ModuleInfo+496, ecx
	mov	r8, r15
	mov	eax, DWORD PTR [rdi+r15+24]
	mov	edx, esi
	mov	ecx, DWORD PTR bracket_flags$[rbp-256]
	sub	eax, DWORD PTR line$[rbp-256]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR ModuleInfo+488
	mov	DWORD PTR [rsp+32], eax
	call	RebuildLine
	cmp	eax, -1
	je	$LN58@ExpandToke

; 1303 :                                   tmp, tokenarray[i].tokpos - line, bracket_flags ) )
; 1304 :             return( ERROR );
; 1305 :         rc = STRING_EXPANDED;

	mov	r12d, 1
$LN35@ExpandToke:

; 1306 :     }
; 1307 :     return( rc );

	mov	eax, r12d
$LN1@ExpandToke:

; 1308 : }

	mov	rbx, QWORD PTR [rsp+1328]
	add	rsp, 1248				; 000004e0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ExpandToken ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
;	COMDAT RebuildLine
_TEXT	SEGMENT
buffer$ = 32
newstring$ = 1104
i$ = 1112
tv327 = 1120
tokenarray$ = 1120
oldlen$ = 1128
pos_line$ = 1136
addbrackets$ = 1144
RebuildLine PROC					; COMDAT

; 1051 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 1056				; 00000420H
	movsxd	r14, edx
	mov	r13, r8

; 1052 :     char *dest;
; 1053 :     const char *src;
; 1054 :     unsigned  newlen;
; 1055 :     unsigned  rest = strlen( tokenarray[i].tokpos + oldlen ) + 1;

	mov	rbx, r14
	mov	r12d, r9d
	shl	rbx, 5
	mov	rsi, rcx
	or	rbp, -1
	mov	rdi, rbp
	mov	rbx, QWORD PTR [rbx+r8+24]
	lea	rax, QWORD PTR [r12+rbx]
$LL36@RebuildLin:
	inc	rdi
	cmp	BYTE PTR [rax+rdi], 0
	jne	SHORT $LL36@RebuildLin
	inc	edi

; 1056 :     char buffer[MAX_LINE_LEN];
; 1057 : 
; 1058 :     dest = tokenarray[i].tokpos;
; 1059 :     memcpy( buffer, dest + oldlen, rest ); /* save content of line behind item */

	lea	rdx, QWORD PTR [r12+rbx]
	mov	eax, edi
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r8d, edi
	mov	QWORD PTR tv327[rsp], rax
	call	memcpy
	npad	8
$LL35@RebuildLin:

; 1060 :     newlen = strlen( newstring );

	inc	rbp
	cmp	BYTE PTR [rsi+rbp], 0
	jne	SHORT $LL35@RebuildLin

; 1061 :     if ( addbrackets ) {

	mov	edx, DWORD PTR addbrackets$[rsp]
	mov	r8, 5764607531624169472			; 5000000200000000H
	test	edx, edx
	je	SHORT $LN3@RebuildLin

; 1062 :         newlen += 2;   /* count '<' and '>' */
; 1063 :         for ( src = newstring; *src; src++ )

	movzx	eax, BYTE PTR [rsi]
	add	ebp, 2
	mov	rcx, rsi
	test	al, al
	je	SHORT $LN3@RebuildLin
	npad	5
$LL4@RebuildLin:
	cmp	al, 62					; 0000003eH
	ja	SHORT $LN2@RebuildLin
	movsx	rax, al
	bt	r8, rax
	jae	SHORT $LN2@RebuildLin

; 1064 :             if ( *src == '<' || *src == '>' || *src == '!' )    /* count '!' operator */
; 1065 :                 newlen++;

	inc	ebp
$LN2@RebuildLin:

; 1062 :         newlen += 2;   /* count '<' and '>' */
; 1063 :         for ( src = newstring; *src; src++ )

	movzx	eax, BYTE PTR [rcx+1]
	inc	rcx
	test	al, al
	jne	SHORT $LL4@RebuildLin
$LN3@RebuildLin:

; 1066 :     }
; 1067 :     if ( newlen > oldlen )

	cmp	ebp, r12d
	jbe	SHORT $LN15@RebuildLin

; 1068 :         if ( ( pos_line + newlen - oldlen + rest ) >= MAX_LINE_LEN ) {

	mov	eax, ebp
	sub	eax, r12d
	add	eax, edi
	add	eax, DWORD PTR pos_line$[rsp]
	cmp	eax, 1024				; 00000400H
	jb	SHORT $LN15@RebuildLin

; 1069 :             return( EmitErr( EXPANDED_LINE_TOO_LONG, tokenarray[0].tokpos ) );

	mov	rdx, QWORD PTR [r13+24]
	mov	ecx, 90					; 0000005aH
	call	EmitErr
	jmp	$LN1@RebuildLin
$LN15@RebuildLin:

; 1070 :         }
; 1071 : 
; 1072 :     if ( addbrackets ) {

	test	edx, edx
	je	SHORT $LN16@RebuildLin

; 1073 :         *dest++ = '<';

	mov	BYTE PTR [rbx], 60			; 0000003cH
	inc	rbx

; 1074 :         for ( src = newstring; *src; src++ ) {

	cmp	BYTE PTR [rsi], 0
	je	SHORT $LN6@RebuildLin
$LL7@RebuildLin:

; 1075 :             if ( *src == '<' || *src == '>' || *src == '!' )    /* count '!' operator */

	movzx	eax, BYTE PTR [rsi]
	cmp	al, 62					; 0000003eH
	ja	SHORT $LN18@RebuildLin
	movsx	rax, al
	bt	r8, rax
	jae	SHORT $LN18@RebuildLin

; 1076 :                 *dest++ = '!';

	mov	BYTE PTR [rbx], 33			; 00000021H
	inc	rbx
$LN18@RebuildLin:

; 1077 :             *dest++ = *src;

	movzx	eax, BYTE PTR [rsi]
	inc	rsi
	mov	BYTE PTR [rbx], al
	inc	rbx
	cmp	BYTE PTR [rsi], 0
	jne	SHORT $LL7@RebuildLin
$LN6@RebuildLin:

; 1078 :         }
; 1079 :         *dest++ = '>';

	mov	BYTE PTR [rbx], 62			; 0000003eH
	inc	rbx

; 1080 :     } else {

	jmp	SHORT $LN17@RebuildLin
$LN16@RebuildLin:

; 1081 :         memcpy( dest, newstring, newlen );

	mov	r8d, ebp
	mov	rdx, rsi
	mov	rcx, rbx
	mov	edi, ebp
	call	memcpy

; 1082 :         dest += newlen;

	add	rbx, rdi
$LN17@RebuildLin:

; 1083 :     }
; 1084 :     memcpy( dest, buffer, rest ); /* add rest of line */

	mov	r8, QWORD PTR tv327[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbx
	call	memcpy

; 1085 : 
; 1086 :     /* v2.05: changed '<' to '<=' */
; 1087 :     for ( i++; i <= Token_Count; i++ ) {

	inc	r14d
	cmp	r14d, DWORD PTR ModuleInfo+496
	jg	SHORT $LN9@RebuildLin
	movsxd	rax, r14d
	lea	rcx, QWORD PTR [r13+24]
	shl	rax, 5
	add	rcx, rax
	mov	edx, ebp
	npad	6
$LL10@RebuildLin:

; 1088 :         tokenarray[i].tokpos = tokenarray[i].tokpos - oldlen + newlen;

	mov	rax, rdx
	lea	rcx, QWORD PTR [rcx+32]
	sub	rax, r12
	inc	r14d
	add	QWORD PTR [rcx-32], rax
	cmp	r14d, DWORD PTR ModuleInfo+496
	jle	SHORT $LL10@RebuildLin
$LN9@RebuildLin:

; 1089 :     }
; 1090 : 
; 1091 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@RebuildLin:

; 1092 : }

	lea	r11, QWORD PTR [rsp+1056]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
RebuildLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
;	COMDAT AddTokens
_TEXT	SEGMENT
tokenarray$ = 8
start$ = 16
count$ = 24
end$ = 32
AddTokens PROC						; COMDAT

; 797  : {

	mov	r11, rcx

; 798  :     int i;
; 799  : 
; 800  :     if ( count > 0 ) {

	test	r8d, r8d
	jle	SHORT $LN20@AddTokens

; 801  :         for( i = end; i >= start; i-- ) {

	movsxd	r9, r9d
	movsxd	r10, edx
	cmp	r9, r10
	jl	$LN6@AddTokens
	mov	rax, r9
	sub	r9, r10
	shl	rax, 5
	add	rax, rcx
	movsxd	rcx, r8d
	shl	rcx, 5
	inc	r9
	npad	2
$LL4@AddTokens:

; 802  :             tokenarray[i+count] = tokenarray[i];

	movups	xmm0, XMMWORD PTR [rax]
	lea	rax, QWORD PTR [rax-32]
	movups	XMMWORD PTR [rcx+rax+32], xmm0
	movups	xmm1, XMMWORD PTR [rax+48]
	movups	XMMWORD PTR [rcx+rax+48], xmm1
	sub	r9, 1
	jne	SHORT $LL4@AddTokens

; 807  :         }
; 808  :     }
; 809  : }

	ret	0
$LN20@AddTokens:

; 803  :         }
; 804  :     } else if ( count < 0 ) {

	jns	SHORT $LN6@AddTokens

; 805  :         for( i = start - count; i <= end; ++i ) {

	sub	edx, r8d
	movsxd	rcx, r9d
	movsxd	r10, edx
	cmp	r10, rcx
	jg	SHORT $LN6@AddTokens
	mov	rax, r10
	movsxd	rdx, r8d
	shl	rax, 5
	sub	rcx, r10
	add	rax, r11
	shl	rdx, 5
	inc	rcx
	npad	13
$LL7@AddTokens:

; 806  :             tokenarray[i+count] = tokenarray[i];

	movups	xmm0, XMMWORD PTR [rax]
	lea	rax, QWORD PTR [rax+32]
	movups	XMMWORD PTR [rax+rdx-32], xmm0
	movups	xmm1, XMMWORD PTR [rax-16]
	movups	XMMWORD PTR [rax+rdx-16], xmm1
	sub	rcx, 1
	jne	SHORT $LL7@AddTokens
$LN6@AddTokens:

; 807  :         }
; 808  :     }
; 809  : }

	ret	0
AddTokens ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
;	COMDAT SkipMacro
_TEXT	SEGMENT
buffer$ = 32
tokenarray$ = 1072
SkipMacro PROC						; COMDAT

; 103  : {

	push	rbx
	sub	rsp, 1056				; 00000420H
	mov	rbx, rcx

; 104  :     char buffer[MAX_LINE_LEN];
; 105  : 
; 106  :     /* The queue isn't just thrown away, because any
; 107  :      * coditional assembly directives found in the source
; 108  :      * must be executed.
; 109  :      */
; 110  :      while ( GetTextLine( buffer ) ) {

	lea	rcx, QWORD PTR buffer$[rsp]
	call	GetTextLine
	test	rax, rax
	je	SHORT $LN3@SkipMacro
	npad	5
$LL2@SkipMacro:

; 111  :         Tokenize( buffer, 0, tokenarray, TOK_DEFAULT );

	xor	r9d, r9d
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r8, rbx
	xor	edx, edx
	call	Tokenize
	lea	rcx, QWORD PTR buffer$[rsp]
	call	GetTextLine
	test	rax, rax
	jne	SHORT $LL2@SkipMacro
$LN3@SkipMacro:

; 112  :     }
; 113  : 
; 114  : }

	add	rsp, 1056				; 00000420H
	pop	rbx
	ret	0
SkipMacro ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
;	COMDAT ExpandTMacro
_TEXT	SEGMENT
is_exitm$ = 48
old_tokencount$1$ = 52
tv495 = 56
tv485 = 64
buffer$ = 80
outbuf$ = 1152
tokenarray$ = 1160
equmode$ = 1168
level$ = 1176
ExpandTMacro PROC					; COMDAT

; 972  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 1136				; 00000470H
	mov	rbx, rdx

; 973  :     int old_tokencount = Token_Count;

	movsxd	rdx, DWORD PTR ModuleInfo+496
	mov	DWORD PTR old_tokencount$1$[rsp], edx

; 974  :     int i;
; 975  :     char expanded = TRUE;
; 976  :     int len;
; 977  :     bool is_exitm;
; 978  :     struct asym *sym;
; 979  :     //char lvalue[MAX_LINE_LEN];    /* holds literal value */
; 980  :     char buffer[MAX_LINE_LEN];
; 981  : 
; 982  :     DebugMsg1(("ExpandTMacro(text=>%s< equm=%u lvl=%u) enter\n", outbuf, equmode, level ));
; 983  : 
; 984  :     if ( level >= MAX_TEXTMACRO_NESTING ) {

	cmp	r9d, 20
	jl	SHORT $LN18@ExpandTMac

; 985  :         return( EmitError( MACRO_NESTING_LEVEL_TOO_DEEP ) );

	mov	ecx, 101				; 00000065H
	call	EmitError

; 1039 : }

	add	rsp, 1136				; 00000470H
	pop	rbx
	ret	0
$LN18@ExpandTMac:
	mov	QWORD PTR [rsp+1128], rbp
	mov	QWORD PTR [rsp+1120], rsi
	mov	QWORD PTR [rsp+1112], rdi
	lea	rdi, QWORD PTR [rdx+1]
	inc	edx
	mov	QWORD PTR tv485[rsp], rdi
	mov	DWORD PTR tv495[rsp], edx
	npad	6
$LL2@ExpandTMac:

; 990  :         Token_Count = Tokenize( outbuf, i, tokenarray, TOK_RESCAN );

	mov	r9d, 1
	mov	r8, rbx
	mov	esi, edx
	mov	rbp, rdi
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 991  :         expanded = FALSE;
; 992  :         for ( ; i < Token_Count; i++ ) {

	cmp	esi, eax
	jge	SHORT $LN3@ExpandTMac

; 986  :     }
; 987  : 
; 988  :     while ( expanded == TRUE ) {
; 989  :         i = old_tokencount + 1;

	inc	rdi
	shl	rdi, 5
	add	rdi, rbx
$LL6@ExpandTMac:

; 993  :             if ( tokenarray[i].token == T_ID ) {

	cmp	BYTE PTR [rdi-32], 8
	jne	SHORT $LN4@ExpandTMac

; 994  :                 sym = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rdi-24]
	call	SymFind
	mov	rbx, rax

; 995  :                 /* expand macro functions */
; 996  :                 if ( sym && sym->state == SYM_MACRO &&
; 997  :                     sym->isdefined == TRUE && sym->isfunc == TRUE &&
; 998  :                     tokenarray[i+1].token == T_OP_BRACKET && equmode == FALSE ) {

	test	rax, rax
	je	SHORT $LN46@ExpandTMac
	mov	eax, DWORD PTR [rax+32]
	cmp	eax, 9
	jne	SHORT $LN9@ExpandTMac
	test	BYTE PTR [rbx+40], 2
	je	SHORT $LN9@ExpandTMac
	test	BYTE PTR [rbx+44], 2
	je	SHORT $LN9@ExpandTMac
	cmp	BYTE PTR [rdi], 40			; 00000028H
	jne	SHORT $LN9@ExpandTMac
	cmp	DWORD PTR equmode$[rsp], 0
	je	SHORT $LN23@ExpandTMac
$LN9@ExpandTMac:

; 1012 :                 } else if ( sym && sym->state == SYM_TMACRO && sym->isdefined == TRUE ) {

	cmp	eax, 10
	jne	SHORT $LN46@ExpandTMac
	test	BYTE PTR [rbx+40], 2
	jne	$LN24@ExpandTMac
$LN46@ExpandTMac:
	mov	eax, DWORD PTR ModuleInfo+496
$LN4@ExpandTMac:

; 991  :         expanded = FALSE;
; 992  :         for ( ; i < Token_Count; i++ ) {

	inc	esi
	inc	rbp
	add	rdi, 32					; 00000020H
	cmp	esi, eax
	jl	SHORT $LL6@ExpandTMac
$LN3@ExpandTMac:

; 1030 :                     expanded = TRUE;
; 1031 :                     break;
; 1032 :                 }
; 1033 :             }
; 1034 :         }
; 1035 :     }
; 1036 :     Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$1$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax

; 1037 :     //strcpy( outbuf, lvalue );
; 1038 :     return( NOT_ERROR );

	xor	eax, eax
$LN50@ExpandTMac:
	mov	rsi, QWORD PTR [rsp+1120]
	mov	rbp, QWORD PTR [rsp+1128]
	mov	rdi, QWORD PTR [rsp+1112]

; 1039 : }

	add	rsp, 1136				; 00000470H
	pop	rbx
	ret	0
$LN23@ExpandTMac:

; 999  :                     len = tokenarray[i].tokpos - outbuf;

	mov	rax, QWORD PTR tokenarray$[rsp]

; 1000 :                     memcpy( buffer, outbuf, len );

	lea	rcx, QWORD PTR buffer$[rsp]
	shl	rbp, 5
	mov	eax, DWORD PTR [rax+rbp+24]
	mov	rbp, QWORD PTR outbuf$[rsp]
	sub	eax, ebp
	mov	rdx, rbp
	movsxd	rdi, eax
	mov	r8, rdi
	call	memcpy

; 1001 :                     i = RunMacro( (struct dsym *)sym, i+1, tokenarray, buffer+len, 0, &is_exitm );

	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rax, QWORD PTR buffer$[rsp]
	add	rdi, rax
	lea	edx, DWORD PTR [rsi+1]
	lea	rax, QWORD PTR is_exitm$[rsp]
	mov	r9, rdi
	mov	QWORD PTR [rsp+40], rax
	mov	rcx, rbx
	mov	DWORD PTR [rsp+32], 0
	call	RunMacro

; 1002 :                     if ( i < 0 ) {

	test	eax, eax
	js	$LN26@ExpandTMac

; 1003 :                         Token_Count = old_tokencount;
; 1004 :                         return( ERROR );
; 1005 :                     }
; 1006 :                     DebugMsg1(("ExpandTMacro(%u): repl >%s()< by >%s<\n", level, sym->name, buffer+len ));
; 1007 :                     strcat( buffer+len, tokenarray[i].tokpos );

	movsxd	rdx, eax
	shl	rdx, 5
	dec	rdi
	npad	1
$LL43@ExpandTMac:
	cmp	BYTE PTR [rdi+1], 0
	lea	rdi, QWORD PTR [rdi+1]
	jne	SHORT $LL43@ExpandTMac
	mov	rbx, QWORD PTR tokenarray$[rsp]
	xor	ecx, ecx
	mov	rdx, QWORD PTR [rdx+rbx+24]
	npad	7
$LL44@ExpandTMac:
	movzx	eax, BYTE PTR [rdx+rcx]
	mov	BYTE PTR [rdi+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL44@ExpandTMac

; 1008 :                     strcpy( outbuf, buffer );

	lea	rax, QWORD PTR buffer$[rsp]
	mov	rdx, rbp
	sub	rdx, rax
	lea	rcx, QWORD PTR buffer$[rsp]
	npad	1
$LL15@ExpandTMac:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rdx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL15@ExpandTMac

; 1009 :                     expanded = TRUE;
; 1010 :                     /* is i to be decremented here? */
; 1011 :                     break;

	mov	rcx, QWORD PTR outbuf$[rsp]
	mov	rdi, QWORD PTR tv485[rsp]
	mov	edx, DWORD PTR tv495[rsp]
	jmp	$LL2@ExpandTMac
$LN24@ExpandTMac:

; 1013 :                     char *p;
; 1014 :                     len = tokenarray[i].tokpos - outbuf;

	mov	rcx, QWORD PTR outbuf$[rsp]
	mov	rsi, QWORD PTR tokenarray$[rsp]

; 1015 :                     memcpy( buffer, outbuf, len );

	mov	rdx, rcx
	shl	rbp, 5
	mov	eax, DWORD PTR [rsi+rbp+24]
	sub	eax, ecx
	lea	rcx, QWORD PTR buffer$[rsp]
	movsxd	rdi, eax
	mov	r8, rdi
	call	memcpy

; 1016 :                     //GetLiteralValue( buffer+len, sym->string_ptr );
; 1017 :                     strcpy( buffer+len, sym->string_ptr );

	mov	rcx, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR buffer$[rsp]
	add	rdi, rdx
	mov	rdx, rdi
$LL16@ExpandTMac:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL16@ExpandTMac

; 1018 :                     DebugMsg1(("ExpandTMacro(>%s<, %u): calling ExpandTMacro, value >%s<\n", sym->name, level, buffer+len ));
; 1019 :                     if ( ERROR == ExpandTMacro( buffer + len, tokenarray, equmode, level+1 ) ) {

	mov	r9d, DWORD PTR level$[rsp]
	mov	rdx, rsi
	mov	r8d, DWORD PTR equmode$[rsp]
	inc	r9d
	mov	rcx, rdi
	call	ExpandTMacro
	cmp	eax, -1
	je	$LN26@ExpandTMac

; 1022 :                     }
; 1023 :                     DebugMsg1(("ExpandTMacro(%u): repl >%s< by >%s<\n", level, sym->name, buffer+len ));
; 1024 :                     //if ( level || ( tokenarray[i+1].token != T_FINAL && tokenarray[i+1].token != T_COMMA ))
; 1025 :                         p = tokenarray[i].tokpos + sym->name_size;

	movzx	edx, BYTE PTR [rbx+72]
	mov	rbx, QWORD PTR tokenarray$[rsp]
	add	rdx, QWORD PTR [rbx+rbp+24]

; 1026 :                     //else
; 1027 :                     //    p = tokenarray[i+1].tokpos;
; 1028 :                     strcat( buffer+len, p );

	dec	rdi
	npad	4
$LL41@ExpandTMac:
	cmp	BYTE PTR [rdi+1], 0
	lea	rdi, QWORD PTR [rdi+1]
	jne	SHORT $LL41@ExpandTMac
	xor	ecx, ecx
	npad	4
$LL42@ExpandTMac:
	movzx	eax, BYTE PTR [rdx+rcx]
	mov	BYTE PTR [rdi+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL42@ExpandTMac

; 1029 :                     strcpy( outbuf, buffer );

	mov	rdx, QWORD PTR outbuf$[rsp]
	lea	rax, QWORD PTR buffer$[rsp]
	sub	rdx, rax
	lea	rcx, QWORD PTR buffer$[rsp]
	npad	12
$LL17@ExpandTMac:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rdx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL17@ExpandTMac

; 995  :                 /* expand macro functions */
; 996  :                 if ( sym && sym->state == SYM_MACRO &&
; 997  :                     sym->isdefined == TRUE && sym->isfunc == TRUE &&
; 998  :                     tokenarray[i+1].token == T_OP_BRACKET && equmode == FALSE ) {

	mov	rcx, QWORD PTR outbuf$[rsp]
	mov	rdi, QWORD PTR tv485[rsp]
	mov	edx, DWORD PTR tv495[rsp]
	jmp	$LL2@ExpandTMac
$LN26@ExpandTMac:

; 1020 :                         Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$1$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax

; 1021 :                         return( ERROR );

	or	eax, -1
	jmp	$LN50@ExpandTMac
ExpandTMacro ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
ExpandLiterals PROC

; 1355 : {

$LN20:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1356 :     int cnt = 0;
; 1357 :     int idx;
; 1358 :     /* count non-empty literals */
; 1359 :     for ( idx = i; idx < Token_Count; idx++ ) {

	mov	r9d, DWORD PTR ModuleInfo+496
	xor	r8d, r8d
	movsxd	rbx, ecx
	mov	rdi, rdx
	cmp	ebx, r9d
	jge	SHORT $LN8@ExpandLite
	mov	QWORD PTR [rsp+48], rsi
	lea	rax, QWORD PTR [rdx+1]
	mov	rsi, rbx
	shl	rsi, 5
	add	rax, rsi
	sub	r9d, ebx
	mov	edx, r9d
$LL12@ExpandLite:

; 1360 :         if ( tokenarray[idx].token == T_STRING &&
; 1361 :             tokenarray[idx].stringlen &&

	cmp	BYTE PTR [rax-1], 9
	jne	SHORT $LN14@ExpandLite
	cmp	DWORD PTR [rax+15], 0
	je	SHORT $LN14@ExpandLite
	movzx	ecx, BYTE PTR [rax]
	cmp	cl, 60					; 0000003cH
	je	SHORT $LN13@ExpandLite
	cmp	cl, 123					; 0000007bH
	jne	SHORT $LN14@ExpandLite
$LN13@ExpandLite:

; 1362 :             ( tokenarray[idx].string_delim == '<' || tokenarray[idx].string_delim == '{' ) ) {
; 1363 :             cnt++;

	inc	r8d
$LN14@ExpandLite:

; 1356 :     int cnt = 0;
; 1357 :     int idx;
; 1358 :     /* count non-empty literals */
; 1359 :     for ( idx = i; idx < Token_Count; idx++ ) {

	add	rax, 32					; 00000020H
	sub	rdx, 1
	jne	SHORT $LL12@ExpandLite

; 1364 :         }
; 1365 :     }
; 1366 :     /* if non-empty literals are found, expand the line. if the line
; 1367 :      * was expanded, re-tokenize it.
; 1368 :      */
; 1369 :     if ( cnt ) {

	test	r8d, r8d
	je	SHORT $LN18@ExpandLite

; 1370 :         if ( ExpandText( tokenarray[i].tokpos, tokenarray, FALSE ) == STRING_EXPANDED )

	mov	rcx, QWORD PTR [rsi+rdi+24]
	xor	r8d, r8d
	mov	rdx, rdi
	call	ExpandText
	cmp	eax, 1
	jne	SHORT $LN18@ExpandLite

; 1371 :             Tokenize( tokenarray[i].tokpos, i, tokenarray, TOK_RESCAN );

	mov	rcx, QWORD PTR [rsi+rdi+24]
	mov	r9d, eax
	mov	r8, rdi
	mov	edx, ebx
	call	Tokenize
$LN18@ExpandLite:
	mov	rsi, QWORD PTR [rsp+48]
$LN8@ExpandLite:

; 1372 :     }
; 1373 : 
; 1374 : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ExpandLiterals ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
string$ = 96
tokenarray$ = 104
count$ = 112
ExpandLine PROC

; 1382 : {

$LN102:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 1383 :     int count;
; 1384 :     unsigned int bracket_flags; /* flags */
; 1385 :     int flags;
; 1386 :     int lvl;
; 1387 :     int i;
; 1388 :     int j;
; 1389 :     ret_code rc;
; 1390 :     struct asym *sym;
; 1391 : 
; 1392 :     /* filter certain conditions.
; 1393 :      * bracket_flags: for (preprocessor) directives that expect a literal
; 1394 :      * parameter, the expanded argument has to be enclosed in '<>' again.
; 1395 :      */
; 1396 :     DebugMsg1(( "ExpandLine(>%s<) enter\n", string ));
; 1397 :     for ( lvl = 0; lvl < MAX_TEXTMACRO_NESTING; lvl++ ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	xor	ebx, ebx
	mov	r13d, ebx
	mov	rsi, rdx
	mov	r12, rcx
$LN99@ExpandLine:

; 1398 :         bracket_flags = 0;
; 1399 :         count = 0;

	mov	DWORD PTR count$[rsp], ebx
	mov	r10d, 1
	lea	r11, OFFSET FLAT:__ImageBase
	mov	edi, ebx
	mov	edx, ebx

; 1400 :         rc = NOT_ERROR;

	mov	ebp, ebx

; 1401 :         i = ( Token_Count > 2 && ( tokenarray[1].token == T_COLON || tokenarray[1].token == T_DBL_COLON ) && tokenarray[2].token == T_DIRECTIVE ) ? 2 : 0;

	cmp	r8d, 2
	jle	SHORT $LN53@ExpandLine
	movzx	eax, BYTE PTR [rsi+32]
	cmp	al, 58					; 0000003aH
	je	SHORT $LN52@ExpandLine
	cmp	al, 13
	jne	SHORT $LN53@ExpandLine
$LN52@ExpandLine:
	cmp	BYTE PTR [rsi+64], 3
	jne	SHORT $LN53@ExpandLine
	mov	ebx, 2
$LN53@ExpandLine:

; 1402 :         if ( tokenarray[i].token == T_DIRECTIVE ) {

	mov	r15, rbx
	mov	r14d, ebx
	shl	r15, 5
	add	r15, rsi
	cmp	BYTE PTR [r15], 3
	jne	$LN14@ExpandLine

; 1403 :             flags = GetValueSp( tokenarray[i].tokval );

	mov	r9d, DWORD PTR [r15+16]
	lea	rax, QWORD PTR [r9+r9*2]
	mov	ecx, DWORD PTR SpecialTable[r11+rax*4]

; 1404 :             if ( flags & DF_STRPARM ) {

	test	cl, 2
	je	$LN16@ExpandLine

; 1405 :                 bracket_flags = -1;

	or	edi, -1					; ffffffffH

; 1406 :                 /* v2.08 handle .ERRDEF and .ERRNDEF here. Previously
; 1407 :                  * expansion for these directives was handled in condasm.asm,
; 1408 :                  * and the directives were flagged as DF_NOEXPAND.
; 1409 :                  */
; 1410 :                 if ( tokenarray[i].dirtype == DRT_ERRDIR ) {

	cmp	BYTE PTR [r15+1], 10
	jne	SHORT $LN93@ExpandLine
	lea	eax, DWORD PTR [r9-360]
	cmp	eax, 1
	ja	SHORT $LN93@ExpandLine

; 1411 :                     if (tokenarray[i].tokval == T_DOT_ERRDEF || tokenarray[i].tokval == T_DOT_ERRNDEF ) {
; 1412 :                         if ( i )

	test	ebx, ebx
	je	SHORT $LN56@ExpandLine

; 1413 :                             rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	xor	eax, eax
	lea	rdx, QWORD PTR count$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	r9d, r10d
	mov	r8, rsi
	mov	DWORD PTR [rsp+32], eax
	mov	rcx, r12
	call	ExpandToken
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	ebp, eax
$LN56@ExpandLine:

; 1414 :                         while ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA ) i++;

	movzx	eax, BYTE PTR [r15]
	test	al, al
	je	SHORT $LN89@ExpandLine
	npad	6
$LL5@ExpandLine:
	cmp	al, 44					; 0000002cH
	je	SHORT $LN89@ExpandLine
	inc	rbx
	inc	r14d
	mov	rax, rbx
	shl	rax, 5
	movzx	eax, BYTE PTR [rax+rsi]
	test	al, al
	jne	SHORT $LL5@ExpandLine
$LN89@ExpandLine:

; 1415 :                         count = i; /* don't expand the symbol name */

	mov	edx, r14d
$LN97@ExpandLine:

; 1428 :                 count = 2;

	mov	DWORD PTR count$[rsp], edx
$LN93@ExpandLine:
	mov	r14d, 1
$LN94@ExpandLine:
	xor	ebx, ebx
$LN58@ExpandLine:

; 1498 :                 }
; 1499 :             }
; 1500 : #endif
; 1501 :         }
; 1502 :         /* scan the line from left to right for (text) macros.
; 1503 :          * it's currently not quite correct. a macro proc should only
; 1504 :          * be evaluated in the following cases:
; 1505 :          * 1. it is the first token of a line
; 1506 :          * 2. it is the second token, and the first one is an ID
; 1507 :          * 3. it is the third token, the first one is an ID and
; 1508 :          *    the second is a ':' or '::'.
; 1509 :          */
; 1510 :         while ( count < Token_Count ) {

	cmp	edx, r8d
	jge	SHORT $LN13@ExpandLine
	npad	3
$LL12@ExpandLine:

; 1511 :             int tmp;
; 1512 :             int addbrackets;
; 1513 :             addbrackets = bracket_flags & 1;

	mov	eax, edi
	and	eax, 1

; 1514 :             if ( bracket_flags != -1 )

	cmp	edi, -1					; ffffffffH
	je	SHORT $LN44@ExpandLine

; 1515 :                 bracket_flags = bracket_flags >> 1;

	shr	edi, 1
$LN44@ExpandLine:

; 1516 :             tmp = ExpandToken( string, &count, tokenarray, Token_Count, addbrackets, FALSE );

	mov	r9d, r8d
	mov	DWORD PTR [rsp+40], ebx
	mov	r8, rsi
	mov	DWORD PTR [rsp+32], eax
	lea	rdx, QWORD PTR count$[rsp]
	mov	rcx, r12
	call	ExpandToken

; 1517 :             if( tmp < NOT_ERROR ) /* ERROR or EMPTY? */

	test	eax, eax
	js	$LN1@ExpandLine

; 1518 :                 return( tmp );
; 1519 :             if ( tmp == STRING_EXPANDED )
; 1520 :                 rc = STRING_EXPANDED;
; 1521 :             if ( tokenarray[count].token == T_COMMA )

	movsxd	rcx, DWORD PTR count$[rsp]
	cmp	eax, 1
	mov	rax, rcx
	cmove	ebp, r14d
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	jne	SHORT $LN47@ExpandLine

; 1522 :                 count++;

	inc	ecx
	mov	DWORD PTR count$[rsp], ecx
$LN47@ExpandLine:

; 1498 :                 }
; 1499 :             }
; 1500 : #endif
; 1501 :         }
; 1502 :         /* scan the line from left to right for (text) macros.
; 1503 :          * it's currently not quite correct. a macro proc should only
; 1504 :          * be evaluated in the following cases:
; 1505 :          * 1. it is the first token of a line
; 1506 :          * 2. it is the second token, and the first one is an ID
; 1507 :          * 3. it is the third token, the first one is an ID and
; 1508 :          *    the second is a ':' or '::'.
; 1509 :          */
; 1510 :         while ( count < Token_Count ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	cmp	ecx, r8d
	jl	SHORT $LL12@ExpandLine
$LN13@ExpandLine:

; 1523 :         }
; 1524 :         if( rc == STRING_EXPANDED ) {

	cmp	ebp, 1
	jne	$LN84@ExpandLine

; 1525 :             DebugMsg1(( "ExpandLine(%s): expansion occured, retokenize\n", string ));
; 1526 :             Token_Count = Tokenize( string, 0, tokenarray, TOK_RESCAN | TOK_LINE );

	lea	r9d, QWORD PTR [rbp+4]
$LN95@ExpandLine:
	mov	r8, rsi
	xor	edx, edx
	mov	rcx, r12
	call	Tokenize
	inc	r13d
	mov	DWORD PTR ModuleInfo+496, eax
	mov	r8d, eax
	cmp	r13d, 20
	jge	$LN98@ExpandLine

; 1383 :     int count;
; 1384 :     unsigned int bracket_flags; /* flags */
; 1385 :     int flags;
; 1386 :     int lvl;
; 1387 :     int i;
; 1388 :     int j;
; 1389 :     ret_code rc;
; 1390 :     struct asym *sym;
; 1391 : 
; 1392 :     /* filter certain conditions.
; 1393 :      * bracket_flags: for (preprocessor) directives that expect a literal
; 1394 :      * parameter, the expanded argument has to be enclosed in '<>' again.
; 1395 :      */
; 1396 :     DebugMsg1(( "ExpandLine(>%s<) enter\n", string ));
; 1397 :     for ( lvl = 0; lvl < MAX_TEXTMACRO_NESTING; lvl++ ) {

	jmp	$LN99@ExpandLine
$LN16@ExpandLine:

; 1416 :                     }
; 1417 :                 }
; 1418 :             } else if ( flags & DF_NOEXPAND ) {

	test	cl, 4
	je	$LN93@ExpandLine
$LN60@ExpandLine:

; 1419 :                 /* [ELSE]IF[N]DEF, ECHO, FOR[C]
; 1420 :                  * .[NO|X]CREF, INCLUDE */
; 1421 :                 /* don't expand arguments */
; 1422 :                 return( NOT_ERROR );

	xor	eax, eax

; 1493 :                 if( rc == ERROR || rc == EMPTY )
; 1494 :                     return( rc );

	jmp	$LN1@ExpandLine
$LN14@ExpandLine:

; 1423 :             }
; 1424 :         } else if ( Token_Count > 1 && tokenarray[1].token == T_DIRECTIVE ) {

	cmp	r8d, 1
	jle	$LN23@ExpandLine
	cmp	BYTE PTR [rsi+32], 3
	jne	$LN23@ExpandLine

; 1425 :             switch ( tokenarray[1].dirtype ) {

	movzx	eax, BYTE PTR [rsi+33]
	add	eax, -4
	cmp	eax, 43					; 0000002bH
	ja	$LN93@ExpandLine
	cdqe
	movzx	eax, BYTE PTR $LN85@ExpandLine[r11+rax]
	mov	ecx, DWORD PTR $LN86@ExpandLine[r11+rax*4]
	add	rcx, r11
	jmp	rcx
$LN25@ExpandLine:

; 1426 :             case DRT_CATSTR:
; 1427 :                 bracket_flags = -1;

	or	edi, -1					; ffffffffH

; 1428 :                 count = 2;

	mov	edx, 2

; 1429 :                 break;

	jmp	$LN97@ExpandLine
$LN26@ExpandLine:

; 1430 :             case DRT_SUBSTR:
; 1431 :                 /* syntax: name SUBSTR <literal>, pos [, size] */
; 1432 :                 bracket_flags = 0x1;

	mov	r14d, 1

; 1433 :                 count = 2;

	mov	edx, 2
	mov	edi, r14d
	mov	DWORD PTR count$[rsp], edx

; 1434 :                 break;

	jmp	$LN94@ExpandLine
$LN27@ExpandLine:

; 1435 :             case DRT_SIZESTR:
; 1436 :                 /* syntax: label SIZESTR literal */
; 1437 :                 rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	xor	ebx, ebx
	lea	rdx, QWORD PTR count$[rsp]
	mov	r14d, 1
	mov	DWORD PTR [rsp+40], ebx
	mov	r9d, r14d
	mov	DWORD PTR [rsp+32], ebx
	mov	r8, rsi
	mov	rcx, r12
	call	ExpandToken

; 1438 :                 bracket_flags = 0x1;
; 1439 :                 count = 2;

	mov	edx, 2
	mov	ebp, eax
	mov	DWORD PTR count$[rsp], edx
	mov	edi, r14d
$LN88@ExpandLine:

; 1440 :                 break;

	mov	r8d, DWORD PTR ModuleInfo+496
	jmp	$LN58@ExpandLine
$LN28@ExpandLine:

; 1441 :             case DRT_INSTR:
; 1442 :                 /* syntax: label INSTR [number,] literal, literal */
; 1443 :                 rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	xor	ebx, ebx
	lea	rdx, QWORD PTR count$[rsp]
	mov	r14d, 1
	mov	DWORD PTR [rsp+40], ebx
	mov	r9d, r14d
	mov	DWORD PTR [rsp+32], ebx
	mov	r8, rsi
	mov	rcx, r12
	call	ExpandToken

; 1444 :                 /* check if the optional <number> argument is given */
; 1445 :                 for ( i = 2, count = 0, j = 0; i < Token_Count; i++ ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	ebp, eax
	mov	ecx, ebx
	mov	r9d, ebx
	cmp	r8d, 2
	jle	SHORT $LN10@ExpandLine

; 1441 :             case DRT_INSTR:
; 1442 :                 /* syntax: label INSTR [number,] literal, literal */
; 1443 :                 rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	lea	eax, DWORD PTR [r8-2]
	mov	r10d, eax
	lea	rdx, QWORD PTR [rsi+64]
	npad	2
$LL66@ExpandLine:

; 1446 :                     if ( tokenarray[i].token == T_OP_BRACKET )

	movzx	eax, BYTE PTR [rdx]
	cmp	al, 40					; 00000028H
	jne	SHORT $LN67@ExpandLine

; 1447 :                         count++;

	inc	ecx
	jmp	SHORT $LN69@ExpandLine
$LN67@ExpandLine:

; 1448 :                     else if ( tokenarray[i].token == T_CL_BRACKET )

	cmp	al, 41					; 00000029H
	jne	SHORT $LN68@ExpandLine

; 1449 :                         count--;

	dec	ecx
	jmp	SHORT $LN69@ExpandLine
$LN68@ExpandLine:

; 1450 :                     else if ( tokenarray[i].token == T_COMMA && count == 0 )

	cmp	al, 44					; 0000002cH
	jne	SHORT $LN69@ExpandLine
	test	ecx, ecx
	jne	SHORT $LN69@ExpandLine

; 1451 :                         j++;

	inc	r9d
$LN69@ExpandLine:

; 1444 :                 /* check if the optional <number> argument is given */
; 1445 :                 for ( i = 2, count = 0, j = 0; i < Token_Count; i++ ) {

	add	rdx, 32					; 00000020H
	sub	r10, r14
	jne	SHORT $LL66@ExpandLine
$LN10@ExpandLine:

; 1452 :                 }
; 1453 : 
; 1454 :                 bracket_flags = ( ( j > 1 ) ? 0x6 : 0x3 );

	cmp	r9d, r14d
	mov	edi, 3
	mov	eax, 6

; 1455 :                 count = 2;

	mov	edx, 2
	cmovg	edi, eax
	mov	DWORD PTR count$[rsp], edx

; 1456 :                 break;

	jmp	$LN58@ExpandLine
$LN34@ExpandLine:

; 1457 :             case DRT_MACRO:
; 1458 :                 sym = SymSearch( tokenarray[0].string_ptr );

	mov	rcx, QWORD PTR [rsi+8]
	call	SymFind

; 1459 :                 /* don't expand macro DEFINITIONs!
; 1460 :                  * the name is an exception, if it's not the macro itself
; 1461 :                  */
; 1462 :                 if ( sym && sym->state != SYM_MACRO )

	test	rax, rax
	je	$LN84@ExpandLine
	cmp	DWORD PTR [rax+32], 9
	je	$LN84@ExpandLine

; 1463 :                     rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	xor	ebx, ebx
	lea	rdx, QWORD PTR count$[rsp]
	mov	DWORD PTR [rsp+40], ebx
	mov	r8, rsi
	mov	rcx, r12
	mov	DWORD PTR [rsp+32], ebx
	lea	r9d, QWORD PTR [rbx+1]
	call	ExpandToken
	mov	ebp, eax

; 1464 :                 count = Token_Count; /* stop further expansion */
; 1465 :                 break;
; 1466 :             case DRT_EQU:
; 1467 :                 /* EQU is a special case. If the - expanded - expression is
; 1468 :                  * a number, then the value for EQU is numeric. Else the
; 1469 :                  * expression isn't expanded at all. This effectively makes it
; 1470 :                  * impossible to expand EQU lines here.
; 1471 :                  */
; 1472 : #if 0 /* v2.09: EQU should NEVER be expanded here. See regression test equate20.aso */
; 1473 :                 sym = SymSearch( tokenarray[0].string_ptr );
; 1474 :                 if ( sym == NULL || sym->state == SYM_TMACRO )
; 1475 : #endif
; 1476 :                     return( NOT_ERROR );
; 1477 :             }
; 1478 :         } else {

	jmp	$LN13@ExpandLine
$LN23@ExpandLine:

; 1479 :             /* v2.08: expand the very first token and then ... */
; 1480 :             rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	xor	ebx, ebx
	lea	rdx, QWORD PTR count$[rsp]
	mov	r14d, 1
	mov	DWORD PTR [rsp+40], ebx
	mov	r9d, r14d
	mov	DWORD PTR [rsp+32], ebx
	mov	r8, rsi
	mov	rcx, r12
	call	ExpandToken
	mov	ebp, eax

; 1481 :             if( rc == ERROR || rc == EMPTY )

	cmp	eax, -1
	je	$LN1@ExpandLine
	cmp	eax, -2
	je	$LN1@ExpandLine

; 1482 :                 return( rc );
; 1483 :             if ( rc == STRING_EXPANDED ) {

	cmp	eax, r14d
	jne	SHORT $LN39@ExpandLine

; 1484 :                 /* ... fully retokenize - the expansion might have revealed a conditional
; 1485 :                  * assembly directive
; 1486 :                  */
; 1487 :                 Token_Count = Tokenize( string, 0, tokenarray, TOK_DEFAULT );

	xor	r9d, r9d

; 1488 :                 continue;

	jmp	$LN95@ExpandLine
$LN39@ExpandLine:

; 1489 :             }
; 1490 : #if 1 /* v2.10. see regression test equate27.asm */
; 1491 :             if ( count == 1 && tokenarray[0].token == T_ID && tokenarray[1].token == T_ID ) {

	mov	edx, DWORD PTR count$[rsp]
	cmp	edx, r14d
	jne	$LN88@ExpandLine
	cmp	BYTE PTR [rsi], 8
	jne	$LN88@ExpandLine
	cmp	BYTE PTR [rsi+32], 8
	jne	$LN88@ExpandLine

; 1492 :                 rc = ExpandToken( string, &count, tokenarray, 2, FALSE, FALSE );

	mov	DWORD PTR [rsp+40], ebx
	lea	rdx, QWORD PTR count$[rsp]
	mov	r9d, 2
	mov	DWORD PTR [rsp+32], ebx
	mov	r8, rsi
	mov	rcx, r12
	call	ExpandToken
	mov	ebp, eax
	add	eax, 2
	cmp	eax, r14d
	jbe	SHORT $LN50@ExpandLine

; 1495 :                 if ( rc == STRING_EXPANDED ) {

	cmp	ebp, r14d
	jne	SHORT $LN87@ExpandLine

; 1496 :                     Token_Count = Tokenize( string, 0, tokenarray, TOK_DEFAULT );

	xor	r9d, r9d

; 1497 :                     continue;

	jmp	$LN95@ExpandLine
$LN87@ExpandLine:
	mov	edx, DWORD PTR count$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	jmp	$LN58@ExpandLine
$LN84@ExpandLine:

; 1527 :         } else
; 1528 :             break;
; 1529 :     } /* end for() */
; 1530 :     if ( lvl == MAX_TEXTMACRO_NESTING ) {

	cmp	r13d, 20
$LN98@ExpandLine:
	jne	SHORT $LN50@ExpandLine

; 1531 :         return( EmitError( MACRO_NESTING_LEVEL_TOO_DEEP ) );

	mov	ecx, 101				; 00000065H
	call	EmitError
	jmp	SHORT $LN1@ExpandLine
$LN50@ExpandLine:

; 1532 :     }
; 1533 :     DebugMsg1(( "ExpandLine(>%s<) exit, rc=%u, token_count=%u\n", string, rc, Token_Count ));
; 1534 :     return( rc );

	mov	eax, ebp
$LN1@ExpandLine:

; 1535 : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN86@ExpandLine:
	DD	$LN34@ExpandLine
	DD	$LN25@ExpandLine
	DD	$LN26@ExpandLine
	DD	$LN28@ExpandLine
	DD	$LN27@ExpandLine
	DD	$LN60@ExpandLine
	DD	$LN93@ExpandLine
$LN85@ExpandLine:
	DB	0
	DB	1
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
ExpandLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
line$ = 96
k$ = 104
i$ = 104
tokenarray$ = 112
addbrackets$ = 120
equmode$ = 128
ExpandLineItems PROC

; 1317 : {

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 1318 :     int k;
; 1319 :     int lvl;
; 1320 :     int tmp;
; 1321 :     ret_code rc;
; 1322 : 
; 1323 :     for ( lvl = 0; ; lvl++ ) {

	mov	r12d, DWORD PTR equmode$[rsp]
	xor	esi, esi
	mov	eax, DWORD PTR ModuleInfo+496
	mov	r15d, r9d
	mov	rdi, r8
	mov	r14d, edx
	mov	rbp, rcx
	lea	r13d, QWORD PTR [rsi+1]
	npad	4
$LL4@ExpandLine:

; 1324 :         rc = NOT_ERROR;

	xor	ebx, ebx

; 1325 :         for( k = i; k < Token_Count; ) {

	mov	DWORD PTR k$[rsp], r14d
	cmp	r14d, eax
	jge	SHORT $LN3@ExpandLine
	npad	4
$LL5@ExpandLine:

; 1326 :             tmp = ExpandToken( line, &k, tokenarray, Token_Count, addbrackets, equmode );

	mov	DWORD PTR [rsp+40], r12d
	lea	rdx, QWORD PTR k$[rsp]
	mov	r9d, eax
	mov	DWORD PTR [rsp+32], r15d
	mov	r8, rdi
	mov	rcx, rbp
	call	ExpandToken

; 1327 :             if ( tmp == ERROR )

	cmp	eax, -1
	je	SHORT $LN3@ExpandLine

; 1328 :                 return( lvl );
; 1329 :             if ( tmp == STRING_EXPANDED )
; 1330 :                 rc = STRING_EXPANDED;
; 1331 :             if ( tokenarray[k].token == T_COMMA )

	movsxd	rcx, DWORD PTR k$[rsp]
	cmp	eax, r13d
	mov	rax, rcx
	cmove	ebx, r13d
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 44			; 0000002cH
	jne	SHORT $LN10@ExpandLine

; 1332 :                 k++;

	inc	ecx
	mov	DWORD PTR k$[rsp], ecx
$LN10@ExpandLine:

; 1325 :         for( k = i; k < Token_Count; ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	ecx, eax
	jl	SHORT $LL5@ExpandLine

; 1333 :         }
; 1334 :         if ( rc == NOT_ERROR )

	test	ebx, ebx
	je	SHORT $LN3@ExpandLine

; 1335 :             break;
; 1336 :         /* expansion happened, re-tokenize and continue! */
; 1337 :         Token_Count = Tokenize( line, i, tokenarray, TOK_RESCAN );

	mov	r9d, r13d
	mov	r8, rdi
	mov	edx, r14d
	mov	rcx, rbp
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 1338 :         if ( lvl == MAX_TEXTMACRO_NESTING ) {

	cmp	esi, 20
	je	SHORT $LN19@ExpandLine

; 1318 :     int k;
; 1319 :     int lvl;
; 1320 :     int tmp;
; 1321 :     ret_code rc;
; 1322 : 
; 1323 :     for ( lvl = 0; ; lvl++ ) {

	inc	esi
	jmp	SHORT $LL4@ExpandLine
$LN19@ExpandLine:

; 1339 :             EmitError( MACRO_NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 101				; 00000065H
	call	EmitError
$LN3@ExpandLine:

; 1340 :             break;
; 1341 :         }
; 1342 :     }
; 1343 :     return( lvl );
; 1344 : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	eax, esi
	mov	rsi, QWORD PTR [rsp+120]
	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
ExpandLineItems ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
lvl$1$ = 48
tv701 = 52
old_tokencount$1$ = 56
$T1 = 64
old_stringbufferend$1$ = 72
sp$ = 80
line$ = 320
tokenarray$ = 328
substitute$ = 336
is_exitm$ = 344
ExpandText PROC

; 821  : {

$LN103:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 248				; 000000f8H

; 822  :     char *pSrc;
; 823  :     char *pDst;
; 824  :     char *pIdent;
; 825  :     int  lvl;
; 826  :     bool is_exitm;
; 827  :     int old_tokencount = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496

; 828  :     char *old_stringbufferend = StringBufferEnd;
; 829  :     char quoted_string = 0;
; 830  :     char macro_proc = FALSE;

	xor	sil, sil
	mov	DWORD PTR old_tokencount$1$[rsp], eax
	xor	r13b, r13b
	mov	rax, QWORD PTR ModuleInfo+488
	mov	edi, r8d
	mov	QWORD PTR old_stringbufferend$1$[rsp], rax

; 831  :     //char *pStart;
; 832  :     ret_code rc;
; 833  :     struct asym *sym;
; 834  :     char *sp[MAX_TEXTMACRO_NESTING];
; 835  : 
; 836  :         DebugMsg1(("ExpandText(line=>%s<, subst=%u ) enter\n", line, substitute ));
; 837  :     sp[0] = line;
; 838  :     pDst = StringBufferEnd;

	mov	r14, rax

; 839  :     StringBufferEnd += MAX_LINE_LEN;

	add	rax, 1024				; 00000400H
	mov	DWORD PTR tv701[rsp], esi

; 840  :     rc = NOT_ERROR;

	xor	r10d, r10d
	mov	QWORD PTR sp$[rsp], rcx
	mov	r12d, r10d

; 841  :     for ( lvl = 0; lvl >= 0; lvl-- ) {

	mov	DWORD PTR lvl$1$[rsp], r10d
	mov	ebp, r10d
	mov	QWORD PTR $T1[rsp], r10
	mov	r15d, r10d
	mov	QWORD PTR ModuleInfo+488, rax
$LL4@ExpandText:

; 842  :         pSrc = sp[lvl];

	mov	rbx, QWORD PTR sp$[rsp+r15*8]

; 843  :         while ( *pSrc ) {

	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	$LN2@ExpandText
$LL5@ExpandText:

; 844  :             if( is_valid_id_first_char( *pSrc ) && ( substitute != 0 || quoted_string == 0 ) ) {

	movsx	ecx, al
	call	isalpha
	test	eax, eax
	jne	SHORT $LN17@ExpandText
	movzx	ecx, BYTE PTR [rbx]
	lea	eax, DWORD PTR [rcx-36]
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN87@ExpandText
	movsx	rax, al
	mov	rdx, 576460752706076673			; 0800000018000001H
	bt	rdx, rax
	jb	SHORT $LN17@ExpandText
$LN87@ExpandText:
	cmp	cl, 46					; 0000002eH
	jne	SHORT $LN15@ExpandText
	test	BYTE PTR ModuleInfo+408, 16
	je	SHORT $LN15@ExpandText
$LN17@ExpandText:
	test	edi, edi
	jne	SHORT $LN18@ExpandText
	test	r13b, r13b
	je	SHORT $LN18@ExpandText
$LN15@ExpandText:

; 933  :                         break;
; 934  :                     }
; 935  :                 }
; 936  :             } else {
; 937  :                 if ( *pSrc == '"' || *pSrc == '\'' ) {

	movzx	ecx, BYTE PTR [rbx]
	cmp	cl, 34					; 00000022H
	je	SHORT $LN45@ExpandText
	cmp	cl, 39					; 00000027H
	jne	SHORT $LN48@ExpandText
$LN45@ExpandText:

; 938  :                     if ( quoted_string == 0 )

	test	r13b, r13b
	jne	SHORT $LN46@ExpandText

; 941  :                         quoted_string = 0;
; 942  :                 }
; 943  :                 *pDst++ = *pSrc++;

	mov	BYTE PTR [r14], cl
	movzx	r13d, cl
	inc	r14
	inc	rbx
	jmp	$LN43@ExpandText
$LN46@ExpandText:

; 939  :                         quoted_string = *pSrc;
; 940  :                     else if ( *pSrc == quoted_string )

	cmp	cl, r13b
	movzx	eax, r13b
	mov	edx, 0
	cmove	eax, edx
	movzx	r13d, al
$LN48@ExpandText:

; 941  :                         quoted_string = 0;
; 942  :                 }
; 943  :                 *pDst++ = *pSrc++;

	mov	BYTE PTR [r14], cl
	inc	r14
	inc	rbx
	jmp	$LN43@ExpandText
$LN18@ExpandText:

; 845  :                 pIdent = pDst;

	mov	rsi, r14
	npad	7
$LL9@ExpandText:

; 846  :                 do {
; 847  :                     *pDst++ = *pSrc++;

	movzx	eax, BYTE PTR [rbx]
	inc	rbx
	mov	BYTE PTR [r14], al
	inc	r14

; 848  :                 } while ( is_valid_id_char( *pSrc ));

	movsx	ecx, BYTE PTR [rbx]
	call	isalnum
	test	eax, eax
	jne	SHORT $LL9@ExpandText
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LL9@ExpandText
	cmp	al, 64					; 00000040H
	je	SHORT $LL9@ExpandText
	cmp	al, 36					; 00000024H
	je	SHORT $LL9@ExpandText
	cmp	al, 63					; 0000003fH
	je	SHORT $LL9@ExpandText

; 849  :                 *pDst = NULLC;
; 850  :                 sym = SymSearch( pIdent );

	mov	rcx, rsi
	mov	BYTE PTR [r14], 0
	call	SymFind
	mov	rbp, rax

; 851  : #ifdef DEBUG_OUT
; 852  :                 if ( sym && ( sym->state == SYM_TMACRO || sym->state == SYM_MACRO ) ) {
; 853  :                     DebugMsg1(( "ExpandText: symbol found: %s, %s, defined=%u, *pDst-1=%c\n", sym->name, sym->state == SYM_TMACRO ? "SYM_TMACRO" : "SYM_MACRO", sym->isdefined, *(pDst-1) ));
; 854  :                 }
; 855  : #endif
; 856  :                 if ( sym && sym->isdefined == TRUE ) {

	test	rax, rax
	je	$LN97@ExpandText
	test	BYTE PTR [rax+40], 2
	je	$LN97@ExpandText

; 857  :                     if ( sym->state == SYM_TMACRO ) {

	mov	eax, DWORD PTR [rax+32]
	cmp	eax, 10
	jne	$LN20@ExpandText

; 858  :                         /* v2.08: no expansion inside quoted strings without & */
; 859  :                         if ( quoted_string && *(pIdent-1) != '&' && *pSrc != '&' )

	test	r13b, r13b
	je	SHORT $LN22@ExpandText
	cmp	BYTE PTR [rsi-1], 38			; 00000026H
	je	SHORT $LN22@ExpandText
	cmp	BYTE PTR [rbx], 38			; 00000026H
	jne	$LN97@ExpandText
$LN22@ExpandText:

; 860  :                             continue;
; 861  :                         if ( substitute ) {

	test	edi, edi
	je	SHORT $LN23@ExpandText

; 862  :                             if ( *(pIdent-1) == '&' )

	cmp	BYTE PTR [rsi-1], 38			; 00000026H
	lea	rax, QWORD PTR [rsi-1]
	cmove	rsi, rax

; 863  :                                 pIdent--;
; 864  :                             if ( *pSrc == '&' )

	cmp	BYTE PTR [rbx], 38			; 00000026H
	jne	SHORT $LN27@ExpandText

; 865  :                                 pSrc++;

	inc	rbx

; 866  :                         } else if ( pIdent > old_stringbufferend && *(pIdent-1) == '%' )

	jmp	SHORT $LN27@ExpandText
$LN23@ExpandText:
	cmp	rsi, QWORD PTR old_stringbufferend$1$[rsp]
	jbe	SHORT $LN27@ExpandText
	cmp	BYTE PTR [rsi-1], 37			; 00000025H
	lea	rax, QWORD PTR [rsi-1]
	cmove	rsi, rax
$LN27@ExpandText:

; 867  :                                 pIdent--;
; 868  : 
; 869  :                         sp[lvl++] = pSrc;

	inc	DWORD PTR lvl$1$[rsp]

; 870  :                         pSrc = StringBufferEnd;
; 871  :                         //StringBufferEnd = GetAlignedPointer( pSrc, GetLiteralValue( pSrc, sym->string_ptr ) );
; 872  :                         strcpy( pSrc, sym->string_ptr );

	mov	rcx, QWORD PTR [rbp+16]
	mov	QWORD PTR sp$[rsp+r15*8], rbx
	inc	r15
	mov	rbx, QWORD PTR ModuleInfo+488
	mov	QWORD PTR $T1[rsp], r15
	mov	rdx, rbx
	npad	7
$LL55@ExpandText:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL55@ExpandText

; 873  :                         StringBufferEnd = GetAlignedPointer( pSrc, strlen( pSrc ) );

	or	rax, -1
$LL94@ExpandText:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL94@ExpandText
	add	rax, 8

; 874  :                         DebugMsg1(("ExpandText: %s replaced by >%s<\n", sym->name, pSrc ));
; 875  :                         pDst = pIdent;

	mov	r14, rsi
	and	rax, -8
	add	rax, rbx
	mov	QWORD PTR ModuleInfo+488, rax

; 876  :                         rc = STRING_EXPANDED;

	mov	eax, 1
	mov	r12d, eax
$LN98@ExpandText:
	mov	ebp, DWORD PTR lvl$1$[rsp]
$LN100@ExpandText:
	mov	esi, DWORD PTR tv701[rsp]
$LN42@ExpandText:

; 928  :                         macro_proc = TRUE;
; 929  :                     }
; 930  :                     if ( lvl == MAX_TEXTMACRO_NESTING ) {

	cmp	r15, 20
	jne	$LN43@ExpandText

; 931  :                         DebugMsg(("ExpandText(line=>%s<) error exit\n", line));
; 932  :                         EmitError( MACRO_NESTING_LEVEL_TOO_DEEP );

	lea	ecx, QWORD PTR [r15+81]
	call	EmitError
$LN2@ExpandText:

; 841  :     for ( lvl = 0; lvl >= 0; lvl-- ) {

	dec	ebp
	sub	r15, 1
	mov	DWORD PTR lvl$1$[rsp], ebp
	mov	QWORD PTR $T1[rsp], r15
	js	$LN91@ExpandText
	mov	edi, DWORD PTR substitute$[rsp]
	jmp	$LL4@ExpandText
$LN20@ExpandText:

; 877  :                     } else if ( sym->state == SYM_MACRO && sym->isfunc == TRUE ) {

	cmp	eax, 9
	jne	$LN28@ExpandText
	test	BYTE PTR [rbp+44], 2
	je	$LN28@ExpandText

; 878  :                         /* expand macro functions. */
; 879  :                         char *p = pSrc;
; 880  :                         int i;
; 881  :                         while ( isspace(*p) ) p++;

	movsx	ecx, BYTE PTR [rbx]
	mov	rdi, rbx
	call	isspace
	test	eax, eax
	je	SHORT $LN11@ExpandText
	npad	7
$LL10@ExpandText:
	movsx	ecx, BYTE PTR [rdi+1]
	inc	rdi
	call	isspace
	test	eax, eax
	jne	SHORT $LL10@ExpandText
$LN11@ExpandText:

; 882  :                         /* no macro function invokation if the '(' is missing! */
; 883  :                         if ( *p == '(' ) {

	cmp	BYTE PTR [rdi], 40			; 00000028H
	jne	SHORT $LN98@ExpandText

; 884  :                             int j;
; 885  :                             int cnt;
; 886  :                             i = Token_Count + 1;

	mov	r15d, DWORD PTR ModuleInfo+496

; 887  :                             Token_Count = Tokenize( p, i, tokenarray, TOK_RESCAN );

	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	inc	r15d
	mov	edx, r15d
	mov	rcx, rdi
	call	Tokenize

; 888  :                             for ( j = i, cnt = 0; j < Token_Count; j++ ) {

	mov	rdi, QWORD PTR tokenarray$[rsp]
	mov	r9d, eax
	xor	r10d, r10d
	mov	DWORD PTR ModuleInfo+496, eax
	mov	r8d, r15d
	mov	eax, r10d
	cmp	r15d, r9d
	jge	SHORT $LN89@ExpandText
	movsxd	rdx, r15d
	shl	rdx, 5
	add	rdx, rdi
$LL14@ExpandText:

; 889  :                                 if ( tokenarray[j].token == T_OP_BRACKET )

	movzx	ecx, BYTE PTR [rdx]
	cmp	cl, 40					; 00000028H
	jne	SHORT $LN31@ExpandText

; 890  :                                     cnt++;

	inc	eax
	jmp	SHORT $LN12@ExpandText
$LN31@ExpandText:

; 891  :                                 else if ( tokenarray[j].token == T_CL_BRACKET ) {

	cmp	cl, 41					; 00000029H
	jne	SHORT $LN12@ExpandText

; 892  :                                     cnt--;

	sub	eax, 1

; 893  :                                     if ( cnt == 0 ) {

	je	SHORT $LN68@ExpandText
$LN12@ExpandText:

; 888  :                             for ( j = i, cnt = 0; j < Token_Count; j++ ) {

	inc	r8d
	add	rdx, 32					; 00000020H
	cmp	r8d, r9d
	jl	SHORT $LL14@ExpandText
	jmp	SHORT $LN89@ExpandText
$LN68@ExpandText:

; 894  :                                         j++;

	inc	r8d
$LN89@ExpandText:

; 895  :                                         break;
; 896  :                                     }
; 897  :                                 }
; 898  :                             }
; 899  :                             /* don't substitute inside quoted strings if there's no '&' */
; 900  :                             if ( quoted_string && *(pIdent-1) != '&' && tokenarray[j].token != '&' ) {

	test	r13b, r13b
	je	SHORT $LN35@ExpandText
	cmp	BYTE PTR [rsi-1], 38			; 00000026H
	je	SHORT $LN35@ExpandText
	movsxd	rax, r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 38			; 00000026H
	je	SHORT $LN35@ExpandText

; 901  :                                 Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$1$[rsp]

; 902  :                                 continue;

	mov	r15, QWORD PTR $T1[rsp]
	mov	DWORD PTR ModuleInfo+496, eax
$LN97@ExpandText:
	mov	esi, DWORD PTR tv701[rsp]
	mov	ebp, DWORD PTR lvl$1$[rsp]
$LN43@ExpandText:

; 843  :         while ( *pSrc ) {

	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	$LN2@ExpandText
	mov	edi, DWORD PTR substitute$[rsp]
	jmp	$LL5@ExpandText
$LN35@ExpandText:

; 903  :                             }
; 904  :                             if ( substitute ) {

	mov	ebx, DWORD PTR substitute$[rsp]
	test	ebx, ebx
	je	SHORT $LN36@ExpandText

; 905  :                                 if ( *(pIdent-1) == '&' )

	cmp	BYTE PTR [rsi-1], 38			; 00000026H
	jne	SHORT $LN39@ExpandText

; 906  :                                     pIdent--;

	dec	rsi

; 907  :                             } else if ( pIdent > old_stringbufferend && *(pIdent-1) == '%' )

	jmp	SHORT $LN39@ExpandText
$LN36@ExpandText:
	cmp	rsi, QWORD PTR old_stringbufferend$1$[rsp]
	jbe	SHORT $LN39@ExpandText
	cmp	BYTE PTR [rsi-1], 37			; 00000025H
	lea	rax, QWORD PTR [rsi-1]
	cmove	rsi, rax
$LN39@ExpandText:

; 908  :                                 pIdent--;
; 909  :                             //*StringBufferEnd = NULLC;
; 910  :                             i = RunMacro( (struct dsym *)sym, i, tokenarray, pDst, 0, &is_exitm );

	lea	rax, QWORD PTR is_exitm$[rsp]
	mov	r9, r14
	mov	QWORD PTR [rsp+40], rax
	mov	r8, rdi
	mov	edx, r15d
	mov	DWORD PTR [rsp+32], r10d
	mov	rcx, rbp
	call	RunMacro

; 911  :                             Token_Count = old_tokencount;

	mov	ecx, DWORD PTR old_tokencount$1$[rsp]
	mov	DWORD PTR ModuleInfo+496, ecx

; 912  :                             DebugMsg1(( "ExpandText: back from RunMacro(%s), rc=%u, text returned=>%s<, rest=>%s<\n", sym->name, i, pDst, i >= 0 ? tokenarray[i].tokpos : "" ));
; 913  :                             if ( i == -1 ) {

	cmp	eax, -1
	je	$LN69@ExpandText

; 915  :                             }
; 916  :                             pSrc = tokenarray[i-1].tokpos + strlen( tokenarray[i-1].string_ptr );

	movsxd	rdx, eax
	shl	rdx, 5
	or	rax, -1
	mov	rcx, QWORD PTR [rdx+rdi-24]
	npad	3
$LL93@ExpandText:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL93@ExpandText
	add	rax, QWORD PTR [rdx+rdi-8]

; 917  :                             if ( substitute && *pSrc == '&' )

	test	ebx, ebx
	je	SHORT $LN41@ExpandText
	cmp	BYTE PTR [rax], 38			; 00000026H
	jne	SHORT $LN41@ExpandText

; 918  :                                 pSrc++;

	inc	rax
$LN41@ExpandText:

; 919  :                             sp[lvl++] = pSrc;

	mov	r15, QWORD PTR $T1[rsp]
	mov	ebp, DWORD PTR lvl$1$[rsp]

; 920  :                             pSrc = StringBufferEnd;

	mov	rbx, QWORD PTR ModuleInfo+488
	inc	ebp
	mov	DWORD PTR lvl$1$[rsp], ebp
	mov	QWORD PTR sp$[rsp+r15*8], rax
	inc	r15
	mov	QWORD PTR $T1[rsp], r15

; 921  :                             cnt = strlen( pDst );

	or	rax, -1
$LL92@ExpandText:
	inc	rax
	cmp	BYTE PTR [r14+rax], 0
	jne	SHORT $LL92@ExpandText

; 922  :                             memcpy( pSrc, pDst, cnt + 1 );

	inc	eax
	mov	rdx, r14
	movsxd	rdi, eax
	mov	rcx, rbx
	mov	r8, rdi
	call	memcpy

; 923  :                             StringBufferEnd = GetAlignedPointer( pSrc, cnt );

	lea	rax, QWORD PTR [rdi+7]

; 924  :                             pDst = pIdent;

	mov	r14, rsi
	and	rax, -8
	add	rax, rbx
	mov	QWORD PTR ModuleInfo+488, rax

; 925  :                             rc = STRING_EXPANDED;

	mov	eax, 1
	mov	r12d, eax

; 926  :                         }

	jmp	$LN100@ExpandText
$LN28@ExpandText:

; 927  :                     } else if ( sym->state == SYM_MACRO ) {

	mov	esi, DWORD PTR tv701[rsp]
	cmp	eax, 9
	mov	ebp, DWORD PTR lvl$1$[rsp]
	mov	eax, 1
	movzx	esi, sil
	cmove	esi, eax
	mov	DWORD PTR tv701[rsp], esi
	jmp	$LN42@ExpandText
$LN69@ExpandText:

; 914  :                                 return( ERROR );

	or	eax, -1
	jmp	$LN1@ExpandText
$LN91@ExpandText:

; 944  :             }
; 945  :         } /* end while */
; 946  :     }
; 947  :     *pDst++ = NULLC;
; 948  : 
; 949  :     StringBufferEnd = old_stringbufferend;

	mov	rcx, QWORD PTR old_stringbufferend$1$[rsp]
	mov	BYTE PTR [r14], 0
	mov	QWORD PTR ModuleInfo+488, rcx

; 950  :     if ( rc == STRING_EXPANDED ) {

	cmp	r12d, 1
	jne	SHORT $LN49@ExpandText

; 951  :         memcpy( line, StringBufferEnd, pDst - StringBufferEnd );

	sub	r14, rcx
	mov	rdx, rcx
	mov	rcx, QWORD PTR line$[rsp]
	lea	r8, QWORD PTR [r14+1]
	call	memcpy
$LN49@ExpandText:

; 952  :         DebugMsg1(("ExpandText: expanded line=>%s<\n", line));
; 953  :     }
; 954  :     if ( substitute ) {

	cmp	DWORD PTR substitute$[rsp], 0
	je	SHORT $LN52@ExpandText

; 955  :         if ( rc == STRING_EXPANDED ) {

	cmp	r12d, 1
	jne	SHORT $LN86@ExpandText

; 956  :             Token_Count = Tokenize( tokenarray[0].tokpos, 0, tokenarray, TOK_RESCAN );

	mov	rbx, QWORD PTR tokenarray$[rsp]
	mov	r9d, r12d
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, QWORD PTR [rbx+24]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 959  :             return( ExpandLine( tokenarray[0].tokpos, tokenarray ) );

	mov	rdx, rbx
	mov	rcx, QWORD PTR [rbx+24]
	call	ExpandLine
	jmp	SHORT $LN1@ExpandText
$LN86@ExpandText:

; 957  :         }
; 958  :         if ( rc == STRING_EXPANDED || macro_proc ) {

	test	sil, sil
	je	SHORT $LN52@ExpandText

; 959  :             return( ExpandLine( tokenarray[0].tokpos, tokenarray ) );

	mov	rbx, QWORD PTR tokenarray$[rsp]
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rbx+24]
	call	ExpandLine
	jmp	SHORT $LN1@ExpandText
$LN52@ExpandText:

; 960  :         }
; 961  :     }
; 962  :     return( rc );

	mov	eax, r12d
$LN1@ExpandText:

; 963  : }

	add	rsp, 248				; 000000f8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ExpandText ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
i$ = 0
inside_literal$1$ = 4
parmidx$1$ = 8
inside_angle_brackets$1$ = 12
oldifnesting$1$ = 16
tmp$1$ = 16
cnt_opnum$1$ = 16
ptr$1$ = 24
cntgoto$1$ = 32
skipcomma$1$ = 32
parm_end_delim$1$ = 36
bracket_level$1$ = 40
varargcnt$1$ = 44
currparm$1$ = 48
is_exitm2$1 = 56
info$1$ = 64
$T2 = 72
tv2799 = 80
old_tokencount$1$ = 88
savedStringBuffer$1$ = 96
mi$ = 104
tv2789 = 152
currparm$ = 152
tmpbuf$3 = 160
oldstat$4 = 160
opndx$ = 208
buffer$5 = 320
buffer$6 = 320
macro$ = 1392
idx$ = 1400
tokenarray$ = 1408
out$ = 1416
mflags$ = 1424
is_exitm$ = 1432
RunMacro PROC

; 131  : {

$LN436:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 1400				; 00000578H
	lea	rbp, QWORD PTR [rsp+48]

; 132  :     char        *currparm;
; 133  :     char        *savedStringBuffer = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488

; 134  :     int         i;
; 135  :     //int         start = idx-1;
; 136  :     int         parmidx;
; 137  :     int         skipcomma;
; 138  :     int         varargcnt;
; 139  :     int         bracket_level = -1;/* () level (needed for macro functions) */

	or	esi, -1

; 140  :     int         parm_end_delim;   /* parameter end delimiter */
; 141  :     //char        addprefix;
; 142  :     char        *ptr;
; 143  :     char        *parmstrings;
; 144  :     struct macro_info *info;
; 145  :     struct srcline    *lnode;
; 146  :     struct asym       *sym;
; 147  :     struct expr       opndx;
; 148  :     struct macro_instance mi;
; 149  : 
; 150  :     DebugMsg1(("RunMacro(%s, idx=%u src=>%s< ) enter, lvl=%u, locals=%04u\n", macro->sym.name, idx, tokenarray[idx].tokpos, MacroLevel, MacroLocals ));
; 151  : 
; 152  :     if ( MacroLevel == MAX_MACRO_NESTING ) {

	cmp	BYTE PTR MacroLevel, 40			; 00000028H
	mov	rdi, r8
	movsxd	rbx, edx
	mov	rdx, rcx
	mov	QWORD PTR savedStringBuffer$1$[rbp], rax
	mov	DWORD PTR bracket_level$1$[rbp], esi
	jne	SHORT $LN40@RunMacro

; 153  :         EmitError( NESTING_LEVEL_TOO_DEEP );

	lea	ecx, QWORD PTR [rsi+101]
	call	EmitError

; 154  :         return( -1 );

	or	eax, esi

; 791  : }

	lea	rsp, QWORD PTR [rbp+1352]
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN40@RunMacro:

; 155  :     }
; 156  :     mi.parm_array = NULL;
; 157  :     info = macro->e.macroinfo;

	mov	r8, QWORD PTR [rdx+96]
	xor	r10d, r10d

; 158  : #ifdef DEBUG_OUT
; 159  :     info->count++;
; 160  : #endif
; 161  : 
; 162  :     /* invokation of macro functions requires params enclosed in "()" */
; 163  : 
; 164  :     parm_end_delim = T_FINAL;
; 165  :     if ( macro->sym.isfunc ) {

	test	BYTE PTR [rdx+44], 2
	mov	ecx, r10d
	mov	QWORD PTR mi$[rbp+24], rcx
	mov	QWORD PTR info$1$[rbp], r8
	mov	DWORD PTR parm_end_delim$1$[rbp], r10d
	je	SHORT $LN41@RunMacro

; 166  :         if ( tokenarray[idx].token == T_OP_BRACKET ) { /* should be always true */

	mov	rax, rbx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 40			; 00000028H
	jne	SHORT $LN42@RunMacro

; 167  :             idx++;

	inc	ebx

; 168  :             parm_end_delim = T_CL_BRACKET;

	mov	DWORD PTR parm_end_delim$1$[rbp], 41	; 00000029H

; 169  :             bracket_level = 1;

	mov	esi, 1
	mov	DWORD PTR idx$[rbp], ebx
	mov	DWORD PTR bracket_level$1$[rbp], esi
$LN42@RunMacro:

; 170  :         }
; 171  :         *out = NULLC; /* v2.08: init return value buffer */

	mov	BYTE PTR [r9], cl
$LN41@RunMacro:

; 172  :     }
; 173  :     /* v2.08: if macro is purged, return "void" */
; 174  :     if ( macro->sym.purged ) {

	movzx	edx, BYTE PTR [rdx+44]
	test	dl, 16
	je	SHORT $LN43@RunMacro

; 175  :         if ( bracket_level > 0 ) {

	test	esi, esi
	jle	SHORT $LN44@RunMacro
	movsxd	rax, ebx
	shl	rax, 5
	add	rax, rdi
	npad	7
$LL4@RunMacro:
	movzx	ecx, BYTE PTR [rax]

; 176  :             for( ; bracket_level && tokenarray[idx].token != T_FINAL; idx++ )

	test	cl, cl
	je	$LN163@RunMacro

; 177  :                 if ( tokenarray[idx].token == T_OP_BRACKET )

	cmp	cl, 40					; 00000028H
	jne	SHORT $LN46@RunMacro

; 178  :                     bracket_level++;

	inc	esi
	jmp	SHORT $LN2@RunMacro
$LN46@RunMacro:

; 179  :                 else if ( tokenarray[idx].token == T_CL_BRACKET )

	cmp	cl, 41					; 00000029H
	jne	SHORT $LN2@RunMacro

; 180  :                     bracket_level--;

	dec	esi
$LN2@RunMacro:

; 176  :             for( ; bracket_level && tokenarray[idx].token != T_FINAL; idx++ )

	inc	ebx
	add	rax, 32					; 00000020H
	test	esi, esi
	jne	SHORT $LL4@RunMacro

; 770  : 
; 771  :         /* don't use tokenarray from here on, it's invalid after PopInputStatus() */
; 772  : 
; 773  : #if FASTMEM==0
; 774  :         /* v2.06: free "old" macro line data if macro has been changed
; 775  :          * and isn't in use anymore */
; 776  :         if ( mi.startline != info->data && ( !MacroInUse( macro ) ) ) {
; 777  :             struct srcline  *curr;
; 778  :             struct srcline  *next;
; 779  :             DebugMsg1(("RunMacro(%s): macro has been changed, releasing old lines\n", macro->sym.name ));
; 780  :             for( curr = mi.startline ; curr; curr = next ) {
; 781  :                 next = curr->next;
; 782  :                 LclFree( curr );
; 783  :             }
; 784  :         }
; 785  : #endif
; 786  :     } /* end if */
; 787  : 
; 788  :     DebugMsg1(("RunMacro(%s) exit, MacroLevel=%u\n", macro->sym.name, MacroLevel ));
; 789  : 
; 790  :     return( idx );

	mov	eax, ebx

; 791  : }

	lea	rsp, QWORD PTR [rbp+1352]
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN44@RunMacro:

; 181  :         } else
; 182  :             idx = Token_Count;

	mov	ebx, DWORD PTR ModuleInfo+496

; 770  : 
; 771  :         /* don't use tokenarray from here on, it's invalid after PopInputStatus() */
; 772  : 
; 773  : #if FASTMEM==0
; 774  :         /* v2.06: free "old" macro line data if macro has been changed
; 775  :          * and isn't in use anymore */
; 776  :         if ( mi.startline != info->data && ( !MacroInUse( macro ) ) ) {
; 777  :             struct srcline  *curr;
; 778  :             struct srcline  *next;
; 779  :             DebugMsg1(("RunMacro(%s): macro has been changed, releasing old lines\n", macro->sym.name ));
; 780  :             for( curr = mi.startline ; curr; curr = next ) {
; 781  :                 next = curr->next;
; 782  :                 LclFree( curr );
; 783  :             }
; 784  :         }
; 785  : #endif
; 786  :     } /* end if */
; 787  : 
; 788  :     DebugMsg1(("RunMacro(%s) exit, MacroLevel=%u\n", macro->sym.name, MacroLevel ));
; 789  : 
; 790  :     return( idx );

	mov	eax, ebx

; 791  : }

	lea	rsp, QWORD PTR [rbp+1352]
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN43@RunMacro:

; 183  :         DebugMsg1(("RunMacro(%s) exit, macro is purged\n", macro->sym.name ));
; 184  :         return( idx );
; 185  :     }
; 186  : 
; 187  :     DebugMsg1(( "RunMacro(%s): params=>%s< parmcnt=%u vararg=%u\n", macro->sym.name, tokenarray[idx].tokpos, info->parmcnt, macro->sym.mac_vararg ));
; 188  : 
; 189  :     if ( info->parmcnt ) {

	movzx	eax, WORD PTR [r8]
	test	ax, ax
	je	SHORT $LN403@RunMacro

; 190  :         mi.parm_array = (char **)myalloca( info->parmcnt * sizeof( char * ) + PARMSTRINGSIZE );

	movzx	eax, ax
	lea	rax, QWORD PTR [rax*8+2048]
	lea	rcx, QWORD PTR [rax+15]
	cmp	rcx, rax
	ja	SHORT $LN402@RunMacro
	mov	rcx, 1152921504606846960		; 0ffffffffffffff0H
$LN402@RunMacro:
	and	rcx, -16
	mov	rax, rcx
	call	__chkstk
	sub	rsp, rcx

; 191  :         parmstrings = (char *)(mi.parm_array + info->parmcnt);

	xor	r10d, r10d
	lea	rcx, QWORD PTR [rsp+48]
	mov	QWORD PTR mi$[rbp+24], rcx
	movzx	eax, WORD PTR [r8]
	lea	r9, QWORD PTR [rcx+rax*8]
	jmp	SHORT $LN425@RunMacro
$LN403@RunMacro:
	mov	r9, QWORD PTR currparm$[rbp]
$LN425@RunMacro:
	mov	QWORD PTR currparm$1$[rbp], r9

; 192  :         /* init the macro arguments pointer */
; 193  :         currparm = parmstrings;
; 194  :     }
; 195  : 
; 196  :     /* now get all the parameters from the original src line.
; 197  :      * macro parameters are expanded if
; 198  :      * - it is a macro function call            or
; 199  :      * - the expansion operator (%) is found
; 200  :      */
; 201  : 
; 202  :     parmidx = 0;

	mov	r8d, r10d
	mov	DWORD PTR parmidx$1$[rbp], r10d

; 203  : #if MACROLABEL
; 204  :     if ( macro->sym.label ) {

	test	dl, 4
	je	SHORT $LN50@RunMacro

; 205  :         if ( mflags & MF_LABEL ) {

	test	BYTE PTR mflags$[rbp], 1
	je	SHORT $LN51@RunMacro

; 206  :             i = strlen( tokenarray[0].string_ptr );

	mov	rdx, QWORD PTR [rdi+8]
	or	rax, -1
	npad	2
$LL401@RunMacro:
	inc	rax
	cmp	BYTE PTR [rdx+rax], 0
	jne	SHORT $LL401@RunMacro
	mov	DWORD PTR i$[rbp], eax

; 207  :             mi.parm_array[parmidx] = currparm;

	mov	QWORD PTR [rcx], r9

; 208  :             memcpy( currparm, tokenarray[0].string_ptr, i+1 );

	mov	rcx, r9
	mov	eax, DWORD PTR i$[rbp]
	mov	rdx, QWORD PTR [rdi+8]
	inc	eax
	movsxd	r8, eax
	call	memcpy

; 209  :             currparm = GetAlignedPointer( currparm, i );

	mov	r9, QWORD PTR currparm$1$[rbp]
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	movsxd	rcx, eax
	add	rcx, 7
	and	rcx, -8
	add	r9, rcx
	mov	QWORD PTR currparm$1$[rbp], r9

; 210  :         } else

	xor	r10d, r10d
	jmp	SHORT $LN52@RunMacro
$LN51@RunMacro:

; 211  :             mi.parm_array[parmidx] = "";

	lea	rax, OFFSET FLAT:$SG11072
	mov	QWORD PTR [rcx], rax
$LN52@RunMacro:

; 212  :         parmidx++;

	mov	r8d, 1
	mov	DWORD PTR parmidx$1$[rbp], r8d
$LN50@RunMacro:

; 213  :     }
; 214  : #endif
; 215  : 
; 216  :     *is_exitm = FALSE;

	mov	rax, QWORD PTR is_exitm$[rbp]

; 217  : 
; 218  :     /* v2.08: allow T_FINAL to be chained, lastidx==0 is true final */
; 219  :     tokenarray[Token_Count].lastidx = 0;
; 220  : 
; 221  :     for( varargcnt = 0, skipcomma = 0; parmidx < info->parmcnt; parmidx++ ) {

	mov	rcx, QWORD PTR info$1$[rbp]
	mov	DWORD PTR varargcnt$1$[rbp], r10d
	mov	DWORD PTR skipcomma$1$[rbp], r10d
	mov	BYTE PTR [rax], 0
	movsxd	rax, DWORD PTR ModuleInfo+496
	shl	rax, 5
	mov	DWORD PTR [rax+rdi+16], r10d
	movzx	edx, WORD PTR [rcx]

; 306  :                             }
; 307  :                             continue;
; 308  :                         }
; 309  :                         /* count brackets */
; 310  :                         if ( parm_end_delim == T_CL_BRACKET )

	movsxd	r10, DWORD PTR parm_end_delim$1$[rbp]
	mov	QWORD PTR tv2789[rbp], r10
	cmp	r8d, edx
	jge	$LN407@RunMacro
	movsxd	r11, r8d
	mov	QWORD PTR $T2[rbp], r11
	npad	5
$LL7@RunMacro:

; 222  : 
; 223  :         /* v2.09: don't skip comma if it was the last argument.
; 224  :          * this will a) make a trailing comma trigger warning 'too many arguments...'
; 225  :          * and b), argument handling of FOR loop is significantly simplified.
; 226  :          */
; 227  :         if ( tokenarray[idx].token == T_COMMA && skipcomma )

	movsxd	rax, ebx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 44			; 0000002cH
	jne	SHORT $LN53@RunMacro
	cmp	DWORD PTR skipcomma$1$[rbp], 0
	je	SHORT $LN53@RunMacro

; 228  :             idx++;

	inc	ebx
	mov	DWORD PTR idx$[rbp], ebx
$LN53@RunMacro:

; 229  :         skipcomma = 1;
; 230  : 
; 231  :         if ( tokenarray[idx].token == T_FINAL ||
; 232  :             tokenarray[idx].token == parm_end_delim ||

	movsxd	rax, ebx
	shl	rax, 5
	mov	DWORD PTR skipcomma$1$[rbp], 1
	movzx	ecx, BYTE PTR [rax+rdi]
	test	cl, cl
	je	$LN422@RunMacro
	movzx	eax, cl
	cmp	eax, r10d
	je	$LN422@RunMacro
	cmp	cl, 44					; 0000002cH
	jne	SHORT $LN54@RunMacro
	mov	r10, QWORD PTR macro$[rbp]
	test	BYTE PTR [r10+44], 1
	je	$LN57@RunMacro
	lea	eax, DWORD PTR [rdx-1]
	cmp	r8d, eax
	jne	$LN57@RunMacro
$LN54@RunMacro:

; 247  :                 DebugMsg1(("RunMacro(%s.%u): curr (=def) parameter value=>%s<\n", macro->sym.name, parmidx, mi.parm_array[parmidx] ? parmidx, mi.parm_array[parmidx] : "NULL" ));
; 248  :             }
; 249  : 
; 250  :         } else {
; 251  :             int  inside_literal = 0;
; 252  :             int  inside_angle_brackets = 0;
; 253  :             int  old_tokencount = Token_Count;

	mov	r10d, DWORD PTR ModuleInfo+496
	xor	edx, edx
	xor	ecx, ecx
	mov	DWORD PTR inside_literal$1$[rbp], edx
	mov	DWORD PTR inside_angle_brackets$1$[rbp], ecx

; 254  : 
; 255  :             *currparm = NULLC;
; 256  : 
; 257  :             DebugMsg1(( "RunMacro(%s.%u), >%s<\n", macro->sym.name, parmidx, tokenarray[idx].tokpos ));
; 258  : 
; 259  :             for( ptr = currparm; ( tokenarray[idx].token != T_FINAL && tokenarray[idx].token != T_COMMA ) || inside_literal; idx++ ) {

	mov	rsi, r9
	mov	BYTE PTR [r9], cl
	mov	DWORD PTR old_tokencount$1$[rbp], r10d
	mov	QWORD PTR ptr$1$[rbp], r9
	npad	13
$LL10@RunMacro:
	movsxd	rax, ebx
	shl	rax, 5
	add	rdi, rax
	movzx	eax, BYTE PTR [rdi]
	test	al, al
	je	SHORT $LN63@RunMacro
	cmp	al, 44					; 0000002cH
	jne	SHORT $LN62@RunMacro
$LN63@RunMacro:
	test	edx, edx
	je	$LN323@RunMacro
$LN62@RunMacro:

; 260  : 
; 261  :                 /* if were're inside a literal, go up one level and continue scanning the argument */
; 262  :                 if ( tokenarray[idx].token == T_FINAL ) {

	test	al, al
	jne	SHORT $LN64@RunMacro

; 263  :                     idx = tokenarray[idx].lastidx; /* restore token index */

	movsxd	rbx, DWORD PTR [rdi+16]

; 264  :                     inside_literal--;

	dec	edx

; 265  :                     if ( tokenarray[idx].string_delim == '<' )

	mov	rdi, QWORD PTR tokenarray$[rbp]
	mov	rax, rbx
	shl	rax, 5
	mov	DWORD PTR inside_literal$1$[rbp], edx
	cmp	BYTE PTR [rax+rdi+1], 60		; 0000003cH
	jne	SHORT $LN65@RunMacro

; 266  :                         inside_angle_brackets = 0;

	xor	ecx, ecx
	inc	ebx
	mov	DWORD PTR inside_angle_brackets$1$[rbp], ecx
	mov	DWORD PTR idx$[rbp], ebx
	jmp	SHORT $LL10@RunMacro
$LN65@RunMacro:

; 267  :                     else {
; 268  :                         *ptr++ = '}';

	mov	BYTE PTR [rsi], 125			; 0000007dH
	inc	rsi
	inc	ebx
	mov	QWORD PTR ptr$1$[rbp], rsi
	mov	DWORD PTR idx$[rbp], ebx
	jmp	SHORT $LL10@RunMacro
$LN64@RunMacro:

; 269  :                     }
; 270  :                     continue;
; 271  :                 }
; 272  : 
; 273  :                 if ( tokenarray[idx].token == T_PERCENT ) {

	cmp	al, 37					; 00000025H
	jne	$LN67@RunMacro

; 274  :                     int max;
; 275  :                     int cnt;
; 276  :                     int cnt_opnum;
; 277  :                     /* expansion of macro parameters.
; 278  :                      * if the token behind % is not a text macro or macro function
; 279  :                      * the expression will be always expanded and evaluated.
; 280  :                      * Else it is expanded, but only evaluated if
; 281  :                      */
; 282  :                     idx++;
; 283  :                     while ( tokenarray[idx].token == T_PERCENT ) idx++;

	mov	rdi, QWORD PTR tokenarray$[rbp]
	inc	ebx
	movsxd	rcx, ebx
	shl	rcx, 5
	add	rcx, rdi
	mov	DWORD PTR idx$[rbp], ebx
	cmp	BYTE PTR [rcx], al
	jne	SHORT $LN12@RunMacro
	npad	9
$LL11@RunMacro:
	inc	ebx
	lea	rcx, QWORD PTR [rcx+32]
	cmp	BYTE PTR [rcx], 37			; 00000025H
	je	SHORT $LL11@RunMacro
	mov	DWORD PTR idx$[rbp], ebx
$LN12@RunMacro:

; 284  :                     i = idx;
; 285  :                     cnt_opnum = 1;
; 286  :                     if ( tokenarray[i].token == T_ID ) {

	movsxd	rax, ebx
	mov	edx, ebx
	shl	rax, 5
	add	rax, rdi
	mov	DWORD PTR i$[rbp], ebx
	mov	DWORD PTR cnt_opnum$1$[rbp], 1
	mov	QWORD PTR tv2799[rbp], rax
	cmp	BYTE PTR [rax], 8
	jne	SHORT $LN69@RunMacro

; 287  :                         sym = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rax+8]
	call	SymFind

; 288  :                         if ( sym && sym->isdefined &&

	test	rax, rax
	je	SHORT $LN404@RunMacro
	test	BYTE PTR [rax+40], 2
	je	SHORT $LN404@RunMacro
	mov	ecx, DWORD PTR [rax+32]
	movsxd	rdx, DWORD PTR i$[rbp]
	cmp	ecx, 10
	je	SHORT $LN70@RunMacro
	cmp	ecx, 9
	jne	SHORT $LN69@RunMacro
	test	BYTE PTR [rax+44], 2
	je	SHORT $LN69@RunMacro
	lea	rax, QWORD PTR [rdx+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 40			; 00000028H
	jne	SHORT $LN69@RunMacro
$LN70@RunMacro:

; 289  :                             ( sym->state == SYM_TMACRO ||
; 290  :                              ( sym->state == SYM_MACRO && sym->isfunc == TRUE && tokenarray[i+1].token == T_OP_BRACKET ) ) )
; 291  :                             cnt_opnum = 0;

	mov	DWORD PTR cnt_opnum$1$[rbp], 0
	jmp	SHORT $LN69@RunMacro
$LN404@RunMacro:
	mov	edx, DWORD PTR i$[rbp]
$LN69@RunMacro:

; 292  :                     }
; 293  : 
; 294  :                     for( cnt = 0; tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA; i++ ) {

	movsxd	rax, edx
	xor	ebx, ebx
	shl	rax, 5
	lea	rcx, QWORD PTR [rax+rdi]
	movzx	eax, BYTE PTR [rax+rdi]
	test	al, al
	je	$LN320@RunMacro
	mov	rsi, QWORD PTR tv2789[rbp]
$LL15@RunMacro:
	cmp	al, 44					; 0000002cH
	je	$LN409@RunMacro

; 295  :                         if ( is_valid_id_first_char( *tokenarray[i].string_ptr )) {

	mov	rax, QWORD PTR [rcx+8]
	movsx	ecx, BYTE PTR [rax]
	call	isalpha
	movsxd	rdx, DWORD PTR i$[rbp]
	test	eax, eax
	jne	SHORT $LN72@RunMacro
	mov	r8, rdx
	shl	r8, 5
	add	r8, rdi
	mov	rax, QWORD PTR [r8+8]
	movzx	ecx, BYTE PTR [rax]
	lea	eax, DWORD PTR [rcx-36]
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN389@RunMacro
	movsx	rax, al
	mov	r9, 576460752706076673			; 0800000018000001H
	bt	r9, rax
	jb	SHORT $LN72@RunMacro
$LN389@RunMacro:
	cmp	cl, 46					; 0000002eH
	jne	SHORT $LN71@RunMacro
	test	BYTE PTR ModuleInfo+408, 16
	jne	SHORT $LN72@RunMacro
$LN71@RunMacro:

; 306  :                             }
; 307  :                             continue;
; 308  :                         }
; 309  :                         /* count brackets */
; 310  :                         if ( parm_end_delim == T_CL_BRACKET )

	cmp	rsi, 41					; 00000029H
	jne	SHORT $LN80@RunMacro

; 311  :                             if ( tokenarray[i].token == T_OP_BRACKET )

	movzx	eax, BYTE PTR [r8]
	cmp	al, 40					; 00000028H
	jne	SHORT $LN78@RunMacro

; 312  :                                 cnt++;

	inc	ebx
	jmp	SHORT $LN80@RunMacro
$LN78@RunMacro:

; 313  :                             else if ( tokenarray[i].token == T_CL_BRACKET ) {

	cmp	al, 41					; 00000029H
	jne	SHORT $LN80@RunMacro

; 314  :                                 if ( cnt == 0 )

	test	ebx, ebx
	je	$LN409@RunMacro

; 315  :                                     break;
; 316  :                                 cnt--;

	dec	ebx
$LN80@RunMacro:

; 317  :                             }
; 318  : 
; 319  :                         /* stop if undelimited string occurs (need to scan for '!') */
; 320  :                         if ( tokenarray[i].token == T_STRING && tokenarray[i].string_delim == NULLC )

	movzx	ecx, BYTE PTR [r8]
	cmp	cl, 9
	jne	SHORT $LN82@RunMacro
	cmp	BYTE PTR [r8+1], 0
	je	SHORT $LN409@RunMacro
$LN82@RunMacro:
	lea	eax, DWORD PTR [rcx-37]
	test	al, 246					; 000000f6H
	jne	SHORT $LN391@RunMacro
	cmp	cl, 45					; 0000002dH
	jne	SHORT $LN13@RunMacro
$LN391@RunMacro:

; 321  :                             break;
; 322  : 
; 323  :                         /* names dot and amp are ok */
; 324  :                         if ( tokenarray[i].token == T_DOT || tokenarray[i].token == '&' || tokenarray[i].token == '%' )
; 325  :                             ;
; 326  :                         else
; 327  :                             cnt_opnum++; /* anything else will trigger numeric evaluation */

	inc	DWORD PTR cnt_opnum$1$[rbp]

; 328  :                     }

	jmp	SHORT $LN13@RunMacro
$LN72@RunMacro:

; 296  :                             if ( tokenarray[i+1].token == T_OP_BRACKET ) {

	lea	rax, QWORD PTR [rdx+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 40			; 00000028H
	jne	SHORT $LN13@RunMacro

; 297  :                                 int cnt2;
; 298  :                                 i += 2;

	add	edx, 2

; 299  :                                 for ( cnt2 = 1;cnt2 && tokenarray[i].token != T_FINAL; i++ ) {

	mov	eax, 1
	mov	DWORD PTR i$[rbp], edx
	npad	11
$LL18@RunMacro:
	movsxd	rcx, edx
	shl	rcx, 5
	movzx	r8d, BYTE PTR [rcx+rdi]
	test	r8b, r8b
	je	SHORT $LN17@RunMacro

; 300  :                                     if ( tokenarray[i].token == T_OP_BRACKET )

	cmp	r8b, 40					; 00000028H
	jne	SHORT $LN74@RunMacro

; 301  :                                         cnt2++;

	inc	eax
	jmp	SHORT $LN16@RunMacro
$LN74@RunMacro:

; 302  :                                     else if ( tokenarray[i].token == T_CL_BRACKET )

	cmp	r8b, 41					; 00000029H
	jne	SHORT $LN16@RunMacro

; 303  :                                         cnt2--;

	dec	eax
$LN16@RunMacro:

; 299  :                                 for ( cnt2 = 1;cnt2 && tokenarray[i].token != T_FINAL; i++ ) {

	inc	edx
	mov	DWORD PTR i$[rbp], edx
	test	eax, eax
	jne	SHORT $LL18@RunMacro
$LN17@RunMacro:

; 304  :                                 }
; 305  :                                 i--;

	dec	edx
$LN13@RunMacro:

; 292  :                     }
; 293  : 
; 294  :                     for( cnt = 0; tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA; i++ ) {

	inc	edx
	movsxd	rax, edx
	shl	rax, 5
	mov	DWORD PTR i$[rbp], edx
	lea	rcx, QWORD PTR [rax+rdi]
	movzx	eax, BYTE PTR [rax+rdi]
	test	al, al
	jne	$LL15@RunMacro
$LN409@RunMacro:
	mov	rsi, QWORD PTR ptr$1$[rbp]
$LN320@RunMacro:

; 329  : 
; 330  :                     if ( i == idx ) { /* no items except %? */

	mov	ebx, DWORD PTR idx$[rbp]
	cmp	edx, ebx
	jne	SHORT $LN86@RunMacro

; 331  :                         idx--;

	mov	r8d, DWORD PTR parmidx$1$[rbp]
	dec	ebx
	mov	ecx, DWORD PTR inside_angle_brackets$1$[rbp]
	inc	ebx
	mov	edx, DWORD PTR inside_literal$1$[rbp]
	mov	DWORD PTR idx$[rbp], ebx
	jmp	$LL10@RunMacro
$LN86@RunMacro:

; 332  :                         continue;
; 333  :                     }
; 334  : 
; 335  :                     cnt = tokenarray[i].tokpos - tokenarray[idx].tokpos;

	movsxd	rax, edx
	shl	rax, 5
	mov	edi, DWORD PTR [rax+rdi+24]
	mov	rax, QWORD PTR tv2799[rbp]
	sub	edi, DWORD PTR [rax+24]

; 336  :                     while ( isspace( *(tokenarray[idx].tokpos+cnt-1) ) ) cnt--;

	mov	rax, QWORD PTR [rax+24]
	movsxd	rbx, edi
	movsx	ecx, BYTE PTR [rbx+rax-1]
	call	isspace
	test	eax, eax
	je	SHORT $LN20@RunMacro
	mov	rsi, QWORD PTR tv2799[rbp]
	npad	4
$LL19@RunMacro:
	mov	rax, QWORD PTR [rsi+24]
	lea	rbx, QWORD PTR [rbx-1]
	dec	edi
	movsx	ecx, BYTE PTR [rbx+rax-1]
	call	isspace
	test	eax, eax
	jne	SHORT $LL19@RunMacro
	mov	rsi, QWORD PTR ptr$1$[rbp]
$LN20@RunMacro:

; 337  :                     memcpy( ptr, tokenarray[idx].tokpos, cnt );

	mov	rax, QWORD PTR tv2799[rbp]
	mov	rcx, rsi
	movsxd	rbx, edi
	mov	r8, rbx
	mov	rdx, QWORD PTR [rax+24]
	call	memcpy

; 338  :                     *(ptr+cnt) = NULLC;
; 339  :                     if ( ExpandText( ptr, tokenarray, FALSE ) == ERROR ) {

	mov	rdi, QWORD PTR tokenarray$[rbp]
	xor	r8d, r8d
	mov	rdx, rdi
	mov	BYTE PTR [rbx+rsi], 0
	mov	rcx, rsi
	call	ExpandText
	cmp	eax, -1
	je	$LN322@RunMacro

; 342  :                     }
; 343  :                     idx = i - 1;

	mov	ebx, DWORD PTR i$[rbp]
	dec	ebx

; 344  :                     if ( cnt_opnum ) {

	cmp	DWORD PTR cnt_opnum$1$[rbp], 0
	mov	DWORD PTR idx$[rbp], ebx
	je	$LN88@RunMacro

; 345  :                         /* convert numeric expression into a string */
; 346  :                         max = Tokenize( ptr, Token_Count+1, tokenarray, TOK_RESCAN );

	mov	edx, DWORD PTR ModuleInfo+496
	mov	r9d, 1
	inc	edx
	mov	r8, rdi
	mov	rcx, rsi
	call	Tokenize

; 347  :                         i = Token_Count + 1;

	mov	ecx, DWORD PTR ModuleInfo+496

; 348  :                         DebugMsg1(( "RunMacro(%s.%u), num expansion: >%s<\n", macro->sym.name, parmidx, ptr ));
; 349  :                         /* the % operator won't accept forward references.
; 350  :                          * v2.09: flag EXPF_NOUNDEF set.
; 351  :                          */
; 352  :                         if ( EvalOperand( &i, tokenarray, max, &opndx, EXPF_NOUNDEF ) == ERROR )

	lea	r9, QWORD PTR opndx$[rbp]
	inc	ecx
	mov	BYTE PTR [rsp+32], 2
	mov	DWORD PTR i$[rbp], ecx
	mov	r8d, eax
	lea	rcx, QWORD PTR i$[rbp]
	mov	rdx, rdi
	mov	ebx, eax
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN89@RunMacro

; 353  :                             opndx.llvalue = 0;

	xor	ecx, ecx
	mov	QWORD PTR opndx$[rbp], rcx
	jmp	SHORT $LN91@RunMacro
$LN89@RunMacro:

; 354  :                         else if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rbp+60], 0
	je	SHORT $LN405@RunMacro

; 355  :                             EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 356  :                             opndx.llvalue = 0;

	xor	ecx, ecx
	mov	QWORD PTR opndx$[rbp], rcx
	jmp	SHORT $LN91@RunMacro
$LN405@RunMacro:
	mov	rcx, QWORD PTR opndx$[rbp]
$LN91@RunMacro:

; 357  :                         }
; 358  :                         DebugMsg1(( "RunMacro(%s.%u): num expansion, opndx.type=%d, value=%d\n", macro->sym.name, parmidx, opndx.type, opndx.value ));
; 359  :                         /* v2.08: accept constant and copy any stuff that's following */
; 360  :                         myltoa( opndx.uvalue, StringBufferEnd, ModuleInfo.radix, opndx.hvalue < 0, FALSE );

	movzx	r11d, BYTE PTR ModuleInfo+396
	mov	rax, rcx
	mov	r10, QWORD PTR ModuleInfo+488
	shr	rax, 32					; 00000020H
	test	eax, eax
	jns	$LN284@RunMacro
	mov	BYTE PTR [r10], 45			; 0000002dH
	inc	r10
	neg	ecx
$LN286@RunMacro:
	mov	BYTE PTR tmpbuf$3[rbp+33], 0
	lea	r9, QWORD PTR tmpbuf$3[rbp+33]
	test	ecx, ecx
	je	SHORT $LN282@RunMacro
	lea	rdi, OFFSET FLAT:__digits
	npad	1
$LL283@RunMacro:
	xor	edx, edx
	mov	eax, ecx
	div	r11d
	dec	r9
	mov	ecx, eax
	movzx	r8d, BYTE PTR [rdx+rdi]
	mov	BYTE PTR [r9], r8b
	test	eax, eax
	jne	SHORT $LL283@RunMacro
	mov	rdi, QWORD PTR tokenarray$[rbp]
$LN282@RunMacro:
	lea	r8, QWORD PTR tmpbuf$3[rbp+34]
	mov	rdx, r9
	sub	r8, r9
	mov	rcx, r10
	call	memcpy
$LN280@RunMacro:

; 361  :                         //ptr += strlen( ptr );
; 362  :                         if ( i != max ) {

	movsxd	rax, DWORD PTR i$[rbp]
	cmp	eax, ebx
	je	SHORT $LN92@RunMacro

; 363  :                             /* the evaluator was unable to evaluate the full expression. the rest
; 364  :                              * has to be "copied" */
; 365  :                             DebugMsg1(( "RunMacro(%s.%u): num expansion, additional token=%s\n", macro->sym.name, parmidx, tokenarray[i].tokpos ));
; 366  :                             /* just copy won't work, since <>-literals aren't handled correctly then */
; 367  :                             //EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );
; 368  :                             strcat( StringBufferEnd, tokenarray[i].tokpos );

	mov	rcx, QWORD PTR ModuleInfo+488
	mov	r8, rax
	shl	r8, 5
	dec	rcx
	npad	3
$LL399@RunMacro:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL399@RunMacro
	mov	r8, QWORD PTR [r8+rdi+24]
	xor	edx, edx
	npad	15
$LL400@RunMacro:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL400@RunMacro
$LN92@RunMacro:

; 369  :                         }
; 370  :                         strcpy( ptr, StringBufferEnd );

	mov	rcx, QWORD PTR ModuleInfo+488
	mov	rdx, rsi
	npad	6
$LL165@RunMacro:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL165@RunMacro
	mov	ebx, DWORD PTR idx$[rbp]
$LN88@RunMacro:

; 371  :                     }
; 372  :                     ptr += strlen( ptr );

	or	rax, -1
	npad	5
$LL398@RunMacro:
	inc	rax
	cmp	BYTE PTR [rsi+rax], 0
	jne	SHORT $LL398@RunMacro
	mov	r8d, DWORD PTR parmidx$1$[rbp]
	add	rsi, rax
	mov	ecx, DWORD PTR inside_angle_brackets$1$[rbp]
	inc	ebx
	mov	edx, DWORD PTR inside_literal$1$[rbp]
	mov	DWORD PTR idx$[rbp], ebx
	mov	QWORD PTR ptr$1$[rbp], rsi
	jmp	$LL10@RunMacro

; 357  :                         }
; 358  :                         DebugMsg1(( "RunMacro(%s.%u): num expansion, opndx.type=%d, value=%d\n", macro->sym.name, parmidx, opndx.type, opndx.value ));
; 359  :                         /* v2.08: accept constant and copy any stuff that's following */
; 360  :                         myltoa( opndx.uvalue, StringBufferEnd, ModuleInfo.radix, opndx.hvalue < 0, FALSE );

$LN284@RunMacro:
	test	ecx, ecx
	jne	$LN286@RunMacro
	mov	WORD PTR [r10], 48			; 00000030H
	jmp	$LN280@RunMacro
$LN67@RunMacro:

; 373  :                     /**/myassert( ptr < parmstrings + PARMSTRINGSIZE );
; 374  :                     continue;
; 375  :                 }
; 376  : 
; 377  :                 if ( tokenarray[idx].token == T_STRING && tokenarray[idx].string_delim == '{' ) {

	cmp	al, 9
	jne	SHORT $LN93@RunMacro
	cmp	BYTE PTR [rdi+1], 123			; 0000007bH
	jne	SHORT $LN93@RunMacro

; 378  :                     char *p = tokenarray[idx].string_ptr;

	mov	rcx, QWORD PTR [rdi+8]

; 379  :                     int tmp = idx;
; 380  :                     /* copy the '{' */
; 381  :                     *ptr++ = '{';
; 382  :                     /* the string must be tokenized */
; 383  :                     inside_literal++;

	inc	edx

; 384  :                     idx = Token_Count;
; 385  :                     Token_Count = Tokenize( p, idx + 1, tokenarray, TOK_RESCAN | TOK_NOCURLBRACES );

	mov	rdi, QWORD PTR tokenarray$[rbp]
	mov	r9d, 3
	mov	DWORD PTR inside_literal$1$[rbp], edx
	mov	r8, rdi
	mov	BYTE PTR [rsi], 123			; 0000007bH
	inc	rsi
	mov	edx, DWORD PTR ModuleInfo+496
	mov	DWORD PTR idx$[rbp], edx
	inc	edx
	mov	QWORD PTR ptr$1$[rbp], rsi
	call	Tokenize

; 386  :                     tokenarray[Token_Count].lastidx = tmp;

	movsxd	rcx, eax
	shl	rcx, 5
	mov	DWORD PTR ModuleInfo+496, eax
	mov	DWORD PTR [rcx+rdi+16], ebx

; 387  :                     continue;

	jmp	$LN427@RunMacro
$LN93@RunMacro:

; 388  :                 }
; 389  : 
; 390  :                 if ( inside_angle_brackets == 0 ) {

	test	ecx, ecx
	jne	$LN108@RunMacro

; 391  :                     /* track brackets for macro functions; exit if one more ')' than '(' is found */
; 392  :                     if ( bracket_level > 0 ) {

	mov	ecx, DWORD PTR bracket_level$1$[rbp]
	test	ecx, ecx
	jle	$LN99@RunMacro

; 393  :                         if ( tokenarray[idx].token == T_OP_BRACKET ) {

	cmp	al, 40					; 00000028H
	jne	SHORT $LN96@RunMacro

; 394  :                             bracket_level++;

	inc	ecx
	mov	DWORD PTR bracket_level$1$[rbp], ecx
	jmp	$LN108@RunMacro
$LN96@RunMacro:

; 395  :                         } else if ( tokenarray[idx].token == T_CL_BRACKET ) {

	cmp	al, 41					; 00000029H
	jne	$LN99@RunMacro

; 396  :                             bracket_level--;

	sub	ecx, 1
	mov	DWORD PTR bracket_level$1$[rbp], ecx

; 397  :                             if ( bracket_level == 0 )

	jne	$LN108@RunMacro
$LN323@RunMacro:

; 502  : 
; 503  :             } /* end for */
; 504  : 
; 505  :             *ptr = NULLC;
; 506  : 
; 507  :             /* restore input status values */
; 508  :             Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$1$[rbp]

; 509  :             StringBufferEnd = savedStringBuffer;
; 510  : 
; 511  :             /* store the macro argument in the parameter array */
; 512  :             if (  macro->sym.mac_vararg && ( parmidx == info->parmcnt - 1 ) ) {

	mov	r10, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR info$1$[rbp]
	mov	BYTE PTR [rsi], 0
	mov	DWORD PTR ModuleInfo+496, eax
	mov	rax, QWORD PTR savedStringBuffer$1$[rbp]
	mov	QWORD PTR ModuleInfo+488, rax
	test	BYTE PTR [r10+44], 1
	je	$LN114@RunMacro
	movzx	eax, WORD PTR [rdx]
	dec	eax
	cmp	r8d, eax
	jne	$LN114@RunMacro

; 513  :                 if ( varargcnt == 0 )

	cmp	DWORD PTR varargcnt$1$[rbp], 0

; 514  :                     mi.parm_array[parmidx] = currparm;

	mov	r9, QWORD PTR currparm$1$[rbp]
	mov	r11, QWORD PTR $T2[rbp]
	jne	SHORT $LN116@RunMacro
	mov	rax, QWORD PTR mi$[rbp+24]
	mov	QWORD PTR [rax+r11*8], r9
$LN116@RunMacro:

; 515  :                 DebugMsg1(("RunMacro(%s.%u[%u]): curr parameter value=>%s<\n", macro->sym.name, parmidx, varargcnt, currparm ));
; 516  :                 currparm = ( macro->sym.predefined ? GetAlignedPointer( currparm, ptr - currparm ) : ptr );

	movzx	ecx, BYTE PTR [r10+40]
	shr	cl, 5
	and	cl, 1
	je	$LN167@RunMacro
	sub	rsi, r9
	add	rsi, 8
	and	rsi, -8
	add	r9, rsi
	jmp	$LN429@RunMacro
$LN99@RunMacro:

; 398  :                                 break;
; 399  :                         }
; 400  :                     }
; 401  : 
; 402  :                     /* if there's a literal enclosed in <>, remove the delimiters and
; 403  :                      * tokenize the item (Token_Count must be adjusted, since RunMacro()
; 404  :                      * might be called later!)
; 405  :                      */
; 406  :                     if ( tokenarray[idx].token == T_STRING && tokenarray[idx].string_delim == '<' && inside_angle_brackets == 0 ) {

	cmp	al, 9
	jne	$LN100@RunMacro
	cmp	BYTE PTR [rdi+1], 60			; 0000003cH
	jne	$LN108@RunMacro

; 407  :                         char *p;
; 408  :                         int tmp;
; 409  :                         int size;
; 410  : #if 1
; 411  :                         if ( !strchr( tokenarray[idx].string_ptr, '%' ) ) {

	mov	rcx, QWORD PTR [rdi+8]
	mov	edx, 37					; 00000025H
	call	strchr
	test	rax, rax
	jne	SHORT $LN101@RunMacro

; 412  :                             memcpy( ptr, tokenarray[idx].string_ptr, tokenarray[idx].stringlen );

	mov	r8d, DWORD PTR [rdi+16]
	mov	rcx, rsi
	mov	rdx, QWORD PTR [rdi+8]
	call	memcpy

; 413  :                             ptr += tokenarray[idx].stringlen;

	mov	eax, DWORD PTR [rdi+16]
	add	rsi, rax
	mov	QWORD PTR ptr$1$[rbp], rsi
$LN411@RunMacro:

; 414  :                             continue;

	mov	rdi, QWORD PTR tokenarray$[rbp]
	inc	ebx
	mov	r8d, DWORD PTR parmidx$1$[rbp]
	mov	ecx, DWORD PTR inside_angle_brackets$1$[rbp]
	mov	edx, DWORD PTR inside_literal$1$[rbp]
	mov	DWORD PTR idx$[rbp], ebx
	jmp	$LL10@RunMacro
$LN101@RunMacro:

; 415  :                         }
; 416  : #endif
; 417  :                         tmp = idx;
; 418  :                         size = tokenarray[idx+1].tokpos - (tokenarray[idx].tokpos+1);

	mov	esi, DWORD PTR [rdi+56]
	sub	esi, DWORD PTR [rdi+24]

; 419  :                         p = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	dec	esi

; 420  :                         memcpy( p, tokenarray[idx].tokpos+1, size );

	mov	rdx, QWORD PTR [rdi+24]
	mov	rcx, rax
	mov	DWORD PTR tmp$1$[rbp], ebx
	inc	rdx
	movsxd	rbx, esi
	mov	rdi, rax
	mov	r8, rbx
	call	memcpy

; 421  :                         while ( *(p+size-1) != '>' ) size--;

	lea	rax, QWORD PTR [rdi-1]
	add	rax, rbx
	cmp	BYTE PTR [rax], 62			; 0000003eH
	je	SHORT $LN22@RunMacro
$LL21@RunMacro:
	dec	esi
	lea	rax, QWORD PTR [rax-1]
	cmp	BYTE PTR [rax], 62			; 0000003eH
	jne	SHORT $LL21@RunMacro
$LN22@RunMacro:

; 422  :                         *(p+size-1) = NULLC;
; 423  :                         StringBufferEnd = GetAlignedPointer( p, size );
; 424  :                         //strcpy( tmpline, tokenarray[idx].string_ptr );
; 425  :                         /* the string must be tokenized */
; 426  :                         inside_literal++;
; 427  :                         inside_angle_brackets = 1;
; 428  :                         idx = Token_Count;
; 429  :                         Token_Count = Tokenize( p, idx + 1, tokenarray, TOK_RESCAN );

	mov	rbx, QWORD PTR tokenarray$[rbp]
	mov	r9d, 1
	inc	DWORD PTR inside_literal$1$[rbp]
	mov	r8, rbx
	movsxd	rax, esi
	mov	DWORD PTR inside_angle_brackets$1$[rbp], 1
	mov	BYTE PTR [rax+rdi-1], 0
	lea	eax, DWORD PTR [rsi+1]
	movsxd	rsi, DWORD PTR ModuleInfo+496
	movsxd	rcx, eax
	add	rcx, 7
	mov	DWORD PTR idx$[rbp], esi
	and	rcx, -8
	add	rcx, rdi
	lea	edx, DWORD PTR [rsi+1]
	mov	QWORD PTR ModuleInfo+488, rcx
	mov	rcx, rdi
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 430  :                         tokenarray[Token_Count].lastidx = tmp;
; 431  :                         /* copy spaces located before the first token */
; 432  :                         memcpy( ptr, p, tokenarray[idx+1].tokpos - p );

	mov	rdx, rdi
	movsxd	rcx, eax
	mov	eax, DWORD PTR tmp$1$[rbp]
	shl	rcx, 5
	mov	DWORD PTR [rcx+rbx+16], eax
	mov	rax, rsi
	mov	rsi, QWORD PTR ptr$1$[rbp]
	shl	rax, 5
	mov	rcx, rsi
	add	rbx, rax
	mov	r8, QWORD PTR [rbx+56]
	sub	r8, rdi
	call	memcpy

; 433  :                         ptr += tokenarray[idx+1].tokpos - p;

	mov	rax, QWORD PTR [rbx+56]
	sub	rax, rdi
$LN428@RunMacro:

; 470  :                                     ptr += i;

	add	rsi, rax
	mov	QWORD PTR ptr$1$[rbp], rsi
$LN413@RunMacro:
	mov	rdi, QWORD PTR tokenarray$[rbp]
$LN427@RunMacro:
	mov	ebx, DWORD PTR idx$[rbp]
	mov	r8d, DWORD PTR parmidx$1$[rbp]

; 254  : 
; 255  :             *currparm = NULLC;
; 256  : 
; 257  :             DebugMsg1(( "RunMacro(%s.%u), >%s<\n", macro->sym.name, parmidx, tokenarray[idx].tokpos ));
; 258  : 
; 259  :             for( ptr = currparm; ( tokenarray[idx].token != T_FINAL && tokenarray[idx].token != T_COMMA ) || inside_literal; idx++ ) {

	inc	ebx
	mov	ecx, DWORD PTR inside_angle_brackets$1$[rbp]
	mov	edx, DWORD PTR inside_literal$1$[rbp]
	mov	DWORD PTR idx$[rbp], ebx
	jmp	$LL10@RunMacro
$LN100@RunMacro:

; 434  :                         continue;
; 435  :                     }
; 436  :                     /* macros functions must be expanded always.
; 437  :                      * text macros are expanded only selectively
; 438  :                      */
; 439  :                     if ( tokenarray[idx].token == T_ID ) {

	cmp	al, 8
	jne	$LN108@RunMacro

; 440  :                         if ( sym = SymSearch( tokenarray[idx].string_ptr ) ) {

	mov	rcx, QWORD PTR [rdi+8]
	call	SymFind
	mov	rbx, rax
	test	rax, rax
	je	$LN419@RunMacro

; 441  :                             if ( sym->state == SYM_MACRO && sym->isdefined == TRUE &&
; 442  :                                 sym->isfunc == TRUE && tokenarray[idx+1].token == T_OP_BRACKET ) {

	mov	eax, DWORD PTR [rax+32]
	cmp	eax, 9
	jne	$LN104@RunMacro
	test	BYTE PTR [rbx+40], 2
	je	$LN104@RunMacro
	test	BYTE PTR [rbx+44], 2
	je	$LN104@RunMacro
	cmp	BYTE PTR [rdi+32], 40			; 00000028H
	jne	$LN104@RunMacro

; 443  :                                 bool is_exitm2;
; 444  :                                 //int oldidx = idx;
; 445  :                                 idx = RunMacro( (struct dsym *)sym, idx+1, tokenarray, ptr, 0, &is_exitm2 );

	mov	edx, DWORD PTR idx$[rbp]
	lea	rax, QWORD PTR is_exitm2$1[rbp]
	mov	rdi, QWORD PTR tokenarray$[rbp]
	inc	edx
	mov	QWORD PTR [rsp+40], rax
	mov	r8, rdi
	mov	r9, rsi
	mov	DWORD PTR [rsp+32], 0
	mov	rcx, rbx
	call	RunMacro
	movsxd	rbx, eax

; 446  :                                 if ( idx < 0 ) {

	test	eax, eax
	js	$LN324@RunMacro

; 448  :                                     return( idx );
; 449  :                                 }
; 450  :                                 ptr += strlen( ptr );

	or	rax, -1
$LL397@RunMacro:
	inc	rax
	cmp	BYTE PTR [rsi+rax], 0
	jne	SHORT $LL397@RunMacro
	add	rsi, rax

; 451  :                                 /* copy spaces behind macro function call */
; 452  :                                 if ( tokenarray[idx].token != T_FINAL && tokenarray[idx].token != T_COMMA ) {

	mov	rax, rbx
	shl	rax, 5
	mov	QWORD PTR ptr$1$[rbp], rsi
	lea	rdx, QWORD PTR [rax+rdi]
	movzx	eax, BYTE PTR [rax+rdi]
	test	al, al
	je	SHORT $LN107@RunMacro
	cmp	al, 44					; 0000002cH
	je	SHORT $LN107@RunMacro

; 453  :                                     i = tokenarray[idx].tokpos - ( tokenarray[idx-1].tokpos + 1 );

	mov	eax, DWORD PTR [rdx+24]

; 454  :                                     memcpy( ptr, tokenarray[idx-1].tokpos + 1, i );

	mov	rcx, rsi
	sub	eax, DWORD PTR [rdx-8]
	mov	rdx, QWORD PTR [rdx-8]
	dec	eax
	movsxd	r8, eax
	inc	rdx
	mov	DWORD PTR i$[rbp], eax
	call	memcpy

; 455  :                                     ptr += i;

	movsxd	rax, DWORD PTR i$[rbp]
	add	rsi, rax
	mov	QWORD PTR ptr$1$[rbp], rsi
$LN107@RunMacro:

; 456  :                                 }
; 457  :                                 idx--; /* adjust token index */

	mov	r8d, DWORD PTR parmidx$1$[rbp]
	dec	ebx
	mov	ecx, DWORD PTR inside_angle_brackets$1$[rbp]
	inc	ebx
	mov	edx, DWORD PTR inside_literal$1$[rbp]
	mov	DWORD PTR idx$[rbp], ebx
	jmp	$LL10@RunMacro
$LN104@RunMacro:

; 458  :                                 /**/myassert( ptr < parmstrings + PARMSTRINGSIZE );
; 459  :                                 continue;
; 460  :                             } else if ( sym->state == SYM_TMACRO && sym->isdefined == TRUE &&

	cmp	eax, 10
	jne	$LN419@RunMacro
	test	BYTE PTR [rbx+40], 2
	je	$LN419@RunMacro
	mov	rax, QWORD PTR macro$[rbp]
	test	BYTE PTR [rax+40], 32			; 00000020H
	je	$LN419@RunMacro
	mov	rax, QWORD PTR info$1$[rbp]
	mov	ecx, DWORD PTR parmidx$1$[rbp]
	movzx	eax, WORD PTR [rax+2]
	bt	eax, ecx
	jae	$LN419@RunMacro

; 461  :                                        ( macro->sym.predefined && ( info->autoexp & ( 1 << parmidx ) ) ) ) {
; 462  :                                 //GetLiteralValue( ptr, sym->string_ptr );
; 463  :                                 strcpy( ptr, sym->string_ptr );

	mov	rcx, QWORD PTR [rbx+16]
	mov	rdx, rsi
	npad	2
$LL166@RunMacro:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL166@RunMacro

; 464  :                                 ExpandTMacro( ptr, tokenarray, FALSE, 0 );

	mov	rdx, QWORD PTR tokenarray$[rbp]
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rcx, rsi
	call	ExpandTMacro

; 465  :                                 ptr += strlen( ptr );

	or	rax, -1
	npad	6
$LL396@RunMacro:
	inc	rax
	cmp	BYTE PTR [rsi+rax], 0
	jne	SHORT $LL396@RunMacro
	add	rsi, rax
	movzx	eax, BYTE PTR [rdi+32]
	mov	QWORD PTR ptr$1$[rbp], rsi

; 466  :                                 /* copy spaces behind text macro */
; 467  :                                 if ( tokenarray[idx+1].token != T_FINAL && tokenarray[idx+1].token != T_COMMA ) {

	test	al, al
	je	$LN413@RunMacro
	cmp	al, 44					; 0000002cH
	je	$LN413@RunMacro

; 468  :                                     i = tokenarray[idx+1].tokpos - ( tokenarray[idx].tokpos + sym->name_size );

	movzx	eax, BYTE PTR [rbx+72]
	mov	ecx, DWORD PTR [rdi+56]
	sub	ecx, eax
	sub	ecx, DWORD PTR [rdi+24]
	mov	DWORD PTR i$[rbp], ecx

; 469  :                                     memcpy( ptr, tokenarray[idx].tokpos + sym->name_size, i );

	movzx	edx, BYTE PTR [rbx+72]
	add	rdx, QWORD PTR [rdi+24]
	movsxd	r8, ecx
	mov	rcx, rsi
	call	memcpy

; 470  :                                     ptr += i;

	movsxd	rax, DWORD PTR i$[rbp]

; 471  :                                 }
; 472  :                                 /**/myassert( ptr < parmstrings + PARMSTRINGSIZE );
; 473  :                                 continue;

	jmp	$LN428@RunMacro
$LN419@RunMacro:
	mov	ebx, DWORD PTR idx$[rbp]
$LN108@RunMacro:

; 474  :                             }
; 475  :                         }
; 476  :                     }
; 477  :                 }
; 478  :                 /* get length of item */
; 479  :                 i = tokenarray[idx+1].tokpos - tokenarray[idx].tokpos;

	mov	edx, DWORD PTR [rdi+56]
	sub	edx, DWORD PTR [rdi+24]

; 480  :                 if ( !inside_literal && ( tokenarray[idx+1].token == T_COMMA ||

	mov	eax, DWORD PTR inside_literal$1$[rbp]
	mov	DWORD PTR i$[rbp], edx
	test	eax, eax
	jne	SHORT $LN24@RunMacro
	movzx	eax, BYTE PTR [rdi+32]
	cmp	al, 44					; 0000002cH
	je	SHORT $LN311@RunMacro
	movzx	eax, al
	cmp	eax, DWORD PTR parm_end_delim$1$[rbp]
	jne	SHORT $LN24@RunMacro
$LN311@RunMacro:

; 481  :                     tokenarray[idx+1].token == parm_end_delim ) ) {
; 482  :                     while ( isspace( *(tokenarray[idx].tokpos+i-1 ) ) ) i--;

	mov	rax, QWORD PTR [rdi+24]
	movsxd	rcx, edx
	movsx	ecx, BYTE PTR [rcx+rax-1]
	call	isspace
	test	eax, eax
	je	SHORT $LN406@RunMacro
	npad	6
$LL23@RunMacro:
	mov	eax, DWORD PTR i$[rbp]
	dec	eax
	mov	DWORD PTR i$[rbp], eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rdi+24]
	movsx	ecx, BYTE PTR [rcx+rax-1]
	call	isspace
	test	eax, eax
	jne	SHORT $LL23@RunMacro
$LN406@RunMacro:
	mov	edx, DWORD PTR i$[rbp]
$LN24@RunMacro:

; 483  :                 }
; 484  :                 /* the literal character operator ! is valid for macro arguments */
; 485  :                 if ( tokenarray[idx].token == T_STRING && tokenarray[idx].string_delim == NULLC ) {

	cmp	BYTE PTR [rdi], 9
	jne	SHORT $LN112@RunMacro
	cmp	BYTE PTR [rdi+1], 0
	jne	SHORT $LN112@RunMacro

; 486  :                     char *p;
; 487  :                     char *end;
; 488  :                     DebugMsg1(("RunMacro(%s.%u): undelimited string >%s<, watching '!'\n", macro->sym.name, parmidx, tokenarray[idx].string_ptr ));
; 489  :                     p = tokenarray[idx].tokpos;

	mov	rcx, QWORD PTR [rdi+24]

; 490  :                     end = p + i;

	movsxd	r8, edx
	add	r8, rcx

; 491  :                     /**/myassert( ( ptr + i ) < parmstrings + PARMSTRINGSIZE );
; 492  :                     for ( ; p < end; p++ ) {

	cmp	rcx, r8
	jae	$LN411@RunMacro
	npad	2
$LL27@RunMacro:

; 493  :                         if ( *p == '!' )

	cmp	BYTE PTR [rcx], 33			; 00000021H
	jne	SHORT $LN113@RunMacro

; 494  :                             p++;

	inc	rcx
$LN113@RunMacro:

; 495  :                         *ptr++ = *p;

	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	mov	BYTE PTR [rsi], al
	inc	rsi
	cmp	rcx, r8
	jb	SHORT $LL27@RunMacro

; 496  :                     }
; 497  :                     continue;

	mov	rdi, QWORD PTR tokenarray$[rbp]
	inc	ebx
	mov	r8d, DWORD PTR parmidx$1$[rbp]
	mov	ecx, DWORD PTR inside_angle_brackets$1$[rbp]
	mov	edx, DWORD PTR inside_literal$1$[rbp]
	mov	DWORD PTR idx$[rbp], ebx
	mov	QWORD PTR ptr$1$[rbp], rsi
	jmp	$LL10@RunMacro
$LN112@RunMacro:

; 498  :                 }
; 499  :                 /**/myassert( ( ptr + i ) < parmstrings + PARMSTRINGSIZE );
; 500  :                 memcpy( ptr, tokenarray[idx].tokpos, i );

	movsxd	r8, edx
	mov	rcx, rsi
	mov	rdx, QWORD PTR [rdi+24]
	call	memcpy

; 501  :                 ptr += i;

	movsxd	rax, DWORD PTR i$[rbp]
	mov	rdi, QWORD PTR tokenarray$[rbp]
	add	rsi, rax
	mov	r8d, DWORD PTR parmidx$1$[rbp]
	inc	ebx
	mov	ecx, DWORD PTR inside_angle_brackets$1$[rbp]
	mov	edx, DWORD PTR inside_literal$1$[rbp]
	mov	DWORD PTR idx$[rbp], ebx
	mov	QWORD PTR ptr$1$[rbp], rsi
	jmp	$LL10@RunMacro
$LN167@RunMacro:

; 515  :                 DebugMsg1(("RunMacro(%s.%u[%u]): curr parameter value=>%s<\n", macro->sym.name, parmidx, varargcnt, currparm ));
; 516  :                 currparm = ( macro->sym.predefined ? GetAlignedPointer( currparm, ptr - currparm ) : ptr );

	mov	r9, rsi
$LN429@RunMacro:

; 517  :                 /* v2.08: Masm swallows the last trailing comma */
; 518  :                 //if ( tokenarray[idx].token == T_COMMA ) {
; 519  :                 if ( tokenarray[idx].token == T_COMMA ) {

	mov	rdi, QWORD PTR tokenarray$[rbp]
	movsxd	rax, ebx
	shl	rax, 5
	mov	QWORD PTR currparm$1$[rbp], r9
	cmp	BYTE PTR [rax+rdi], 44			; 0000002cH
	jne	SHORT $LN117@RunMacro

; 520  :                     idx++;

	inc	ebx

; 521  :                     if ( macro->sym.isfunc == FALSE || tokenarray[idx].token != parm_end_delim ) {

	test	BYTE PTR [r10+44], 2
	mov	DWORD PTR idx$[rbp], ebx
	je	SHORT $LN119@RunMacro
	movsxd	rax, ebx
	shl	rax, 5
	movzx	eax, BYTE PTR [rax+rdi]
	cmp	eax, DWORD PTR parm_end_delim$1$[rbp]
	je	SHORT $LN118@RunMacro
$LN119@RunMacro:

; 522  :                         parmidx--;

	dec	r8d
	dec	r11

; 523  :                         if ( !macro->sym.predefined ) {

	test	cl, cl
	jne	SHORT $LN120@RunMacro

; 524  :                             *currparm++ = ',';

	mov	BYTE PTR [r9], 44			; 0000002cH
	inc	r9
	mov	QWORD PTR currparm$1$[rbp], r9
$LN120@RunMacro:

; 525  :                         }
; 526  :                         *currparm = NULLC;

	mov	BYTE PTR [r9], 0
$LN118@RunMacro:

; 527  :                     }
; 528  :                     skipcomma = 0;

	mov	DWORD PTR skipcomma$1$[rbp], 0
$LN117@RunMacro:

; 529  :                 }
; 530  :                 varargcnt++;

	inc	DWORD PTR varargcnt$1$[rbp]
	jmp	SHORT $LN5@RunMacro
$LN114@RunMacro:

; 531  :             } else if ( *currparm ) {

	mov	r9, QWORD PTR currparm$1$[rbp]

; 532  :                 mi.parm_array[parmidx] = currparm;

	mov	rax, QWORD PTR mi$[rbp+24]
	mov	r11, QWORD PTR $T2[rbp]

; 535  :             } else {

	mov	rdi, QWORD PTR tokenarray$[rbp]
	cmp	BYTE PTR [r9], 0
	je	SHORT $LN121@RunMacro

; 532  :                 mi.parm_array[parmidx] = currparm;

	sub	rsi, r9
	mov	QWORD PTR [rax+r11*8], r9

; 533  :                 DebugMsg1(("RunMacro(%s.%u): curr parameter value=>%s<\n", macro->sym.name, parmidx, currparm ));
; 534  :                 currparm = GetAlignedPointer( currparm, ptr - currparm );

	add	rsi, 8
	and	rsi, -8
	add	r9, rsi
	mov	QWORD PTR currparm$1$[rbp], r9

; 535  :             } else {

	jmp	SHORT $LN5@RunMacro
$LN121@RunMacro:

; 536  :                 mi.parm_array[parmidx] = "";

	lea	rcx, OFFSET FLAT:$SG11143
	jmp	SHORT $LN430@RunMacro
$LN422@RunMacro:
	mov	r10, QWORD PTR macro$[rbp]
$LN57@RunMacro:

; 233  :             ( tokenarray[idx].token == T_COMMA &&
; 234  :              ( macro->sym.mac_vararg == FALSE || parmidx != info->parmcnt - 1 ) ) ) {
; 235  : 
; 236  :             /* it's a blank parm */
; 237  :             if( info->parmlist[parmidx].required ) {

	mov	rdx, QWORD PTR info$1$[rbp]
	mov	rcx, r11
	shl	rcx, 4
	mov	rax, QWORD PTR [rdx+8]
	test	BYTE PTR [rcx+rax+8], 1
	jne	$LN325@RunMacro

; 244  :             }
; 245  :             if ( varargcnt == 0 ) {

	cmp	DWORD PTR varargcnt$1$[rbp], 0
	jne	SHORT $LN5@RunMacro

; 246  :                 mi.parm_array[parmidx] = info->parmlist[parmidx].deflt;

	mov	rcx, QWORD PTR [rcx+rax]
	mov	rax, QWORD PTR mi$[rbp+24]
$LN430@RunMacro:
	mov	QWORD PTR [rax+r11*8], rcx
$LN5@RunMacro:

; 217  : 
; 218  :     /* v2.08: allow T_FINAL to be chained, lastidx==0 is true final */
; 219  :     tokenarray[Token_Count].lastidx = 0;
; 220  : 
; 221  :     for( varargcnt = 0, skipcomma = 0; parmidx < info->parmcnt; parmidx++ ) {

	movzx	edx, WORD PTR [rdx]
	inc	r8d
	inc	r11
	mov	DWORD PTR parmidx$1$[rbp], r8d
	mov	QWORD PTR $T2[rbp], r11
	cmp	r8d, edx
	jge	SHORT $LN394@RunMacro
	mov	r10d, DWORD PTR parm_end_delim$1$[rbp]
	jmp	$LL7@RunMacro
$LN322@RunMacro:

; 340  :                         StringBufferEnd = savedStringBuffer;

	mov	rax, QWORD PTR savedStringBuffer$1$[rbp]
	mov	QWORD PTR ModuleInfo+488, rax

; 341  :                         return(-1);

	or	eax, -1

; 791  : }

	lea	rsp, QWORD PTR [rbp+1352]
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN324@RunMacro:

; 447  :                                     StringBufferEnd = savedStringBuffer;

	mov	rax, QWORD PTR savedStringBuffer$1$[rbp]
	mov	QWORD PTR ModuleInfo+488, rax

; 770  : 
; 771  :         /* don't use tokenarray from here on, it's invalid after PopInputStatus() */
; 772  : 
; 773  : #if FASTMEM==0
; 774  :         /* v2.06: free "old" macro line data if macro has been changed
; 775  :          * and isn't in use anymore */
; 776  :         if ( mi.startline != info->data && ( !MacroInUse( macro ) ) ) {
; 777  :             struct srcline  *curr;
; 778  :             struct srcline  *next;
; 779  :             DebugMsg1(("RunMacro(%s): macro has been changed, releasing old lines\n", macro->sym.name ));
; 780  :             for( curr = mi.startline ; curr; curr = next ) {
; 781  :                 next = curr->next;
; 782  :                 LclFree( curr );
; 783  :             }
; 784  :         }
; 785  : #endif
; 786  :     } /* end if */
; 787  : 
; 788  :     DebugMsg1(("RunMacro(%s) exit, MacroLevel=%u\n", macro->sym.name, MacroLevel ));
; 789  : 
; 790  :     return( idx );

	mov	eax, ebx

; 791  : }

	lea	rsp, QWORD PTR [rbp+1352]
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN394@RunMacro:

; 725  :                                     ( is_valid_id_char(*(ptr+len) ) == FALSE ) ) {
; 726  :                                     /* label found! */
; 727  :                                     break;
; 728  :                                 }
; 729  :                             }
; 730  :                         }
; 731  :                         if ( !lnode ) {

	mov	esi, DWORD PTR bracket_level$1$[rbp]
$LN407@RunMacro:

; 537  :                 DebugMsg1(("RunMacro(%s.%u): curr parameter value=><\n", macro->sym.name, parmidx ));
; 538  :             }
; 539  :         } /*end if */
; 540  :     } /* end for  */
; 541  : 
; 542  :     /* for macro functions, check for the terminating ')' */
; 543  :     if ( bracket_level >= 0 ) {

	test	esi, esi
	js	$LN123@RunMacro

; 544  :         if ( tokenarray[idx].token != T_CL_BRACKET ) {

	movsxd	rcx, ebx
	shl	rcx, 5
	add	rcx, rdi
	cmp	BYTE PTR [rcx], 41			; 00000029H
	je	$LN127@RunMacro

; 545  :             for ( i = idx; idx < Token_Count && tokenarray[idx].token != T_CL_BRACKET; idx++ );

	cmp	ebx, DWORD PTR ModuleInfo+496
	movsxd	rax, ebx
	mov	DWORD PTR i$[rbp], eax
	jge	SHORT $LN431@RunMacro
$LL30@RunMacro:
	cmp	BYTE PTR [rcx], 41			; 00000029H
	je	SHORT $LN29@RunMacro
	inc	ebx
	add	rcx, 32					; 00000020H
	cmp	ebx, DWORD PTR ModuleInfo+496
	jl	SHORT $LL30@RunMacro
$LN29@RunMacro:

; 546  :             if ( idx == Token_Count ) {

	cmp	ebx, DWORD PTR ModuleInfo+496
$LN431@RunMacro:
	jne	SHORT $LN126@RunMacro

; 547  :                 DebugMsg1(("RunMacro(%s): missing ')'\n", macro->sym.name));
; 548  :                 EmitError( MISSING_RIGHT_PARENTHESIS );

	mov	ecx, 244				; 000000f4H
	call	EmitError

; 549  :                 return( -1 );

	or	eax, -1

; 791  : }

	lea	rsp, QWORD PTR [rbp+1352]
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN325@RunMacro:

; 238  :                 DebugMsg1(( "RunMacro(%s.%u), parameter %u required >%s<\n", macro->sym.name, parmidx, parmidx, tokenarray[idx].tokpos ));
; 239  :                 if ( *macro->sym.name == NULLC )

	mov	rdx, QWORD PTR [r10+8]
	cmp	BYTE PTR [rdx], 0
	jne	SHORT $LN59@RunMacro

; 240  :                     EmitErr( MISSING_MACRO_ARGUMENT_2, macro->sym.value + 1 );

	mov	edx, DWORD PTR [r10+16]
	mov	ecx, 87					; 00000057H
	inc	edx
	call	EmitErr

; 243  :                 return( -1 );

	or	eax, -1

; 791  : }

	lea	rsp, QWORD PTR [rbp+1352]
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN59@RunMacro:

; 241  :                 else
; 242  :                     EmitErr( MISSING_MACRO_ARGUMENT, macro->sym.name, parmidx + 1 );

	inc	r8d
	mov	ecx, 220				; 000000dcH
	call	EmitErr

; 243  :                 return( -1 );

	or	eax, -1

; 791  : }

	lea	rsp, QWORD PTR [rbp+1352]
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN126@RunMacro:

; 550  :             } else {
; 551  :                 DebugMsg1(("RunMacro(%s): expected ')', found >%s<\n", macro->sym.name, tokenarray[i].tokpos ));
; 552  :                 /* v2.09: changed to a warning only (Masm-compatible) */
; 553  :                 EmitWarn( 1, TOO_MANY_ARGUMENTS_IN_MACRO_CALL, macro->sym.name, tokenarray[i].tokpos );

	mov	r9, rax
	mov	edx, 149				; 00000095H
	mov	rax, QWORD PTR macro$[rbp]
	mov	ecx, 1
	shl	r9, 5
	mov	r8, QWORD PTR [rax+8]
	mov	r9, QWORD PTR [r9+rdi+24]
	call	EmitWarn
$LN127@RunMacro:

; 554  :             }
; 555  :         }
; 556  :         idx++;

	inc	ebx
	mov	DWORD PTR idx$[rbp], ebx
$LN424@RunMacro:
	mov	esi, DWORD PTR mflags$[rbp]
$LN129@RunMacro:

; 566  :         //return( -1 );
; 567  :     }
; 568  : 
; 569  :     /* a predefined macro func with a function address? */
; 570  : 
; 571  :     if ( macro->sym.predefined == TRUE && macro->sym.func_ptr != NULL ) {

	mov	rdx, QWORD PTR macro$[rbp]
	test	BYTE PTR [rdx+40], 32			; 00000020H
	je	SHORT $LN130@RunMacro
	mov	rax, QWORD PTR [rdx+16]
	test	rax, rax
	je	SHORT $LN130@RunMacro

; 572  :         mi.parmcnt = varargcnt;

	mov	ecx, DWORD PTR varargcnt$1$[rbp]

; 573  :         macro->sym.func_ptr( &mi, out, tokenarray );

	mov	r8, rdi
	mov	rdx, QWORD PTR out$[rbp]
	mov	DWORD PTR mi$[rbp+40], ecx
	lea	rcx, QWORD PTR mi$[rbp]
	call	rax

; 574  :         *is_exitm = TRUE;

	mov	rax, QWORD PTR is_exitm$[rbp]
	mov	BYTE PTR [rax], 1

; 770  : 
; 771  :         /* don't use tokenarray from here on, it's invalid after PopInputStatus() */
; 772  : 
; 773  : #if FASTMEM==0
; 774  :         /* v2.06: free "old" macro line data if macro has been changed
; 775  :          * and isn't in use anymore */
; 776  :         if ( mi.startline != info->data && ( !MacroInUse( macro ) ) ) {
; 777  :             struct srcline  *curr;
; 778  :             struct srcline  *next;
; 779  :             DebugMsg1(("RunMacro(%s): macro has been changed, releasing old lines\n", macro->sym.name ));
; 780  :             for( curr = mi.startline ; curr; curr = next ) {
; 781  :                 next = curr->next;
; 782  :                 LclFree( curr );
; 783  :             }
; 784  :         }
; 785  : #endif
; 786  :     } /* end if */
; 787  : 
; 788  :     DebugMsg1(("RunMacro(%s) exit, MacroLevel=%u\n", macro->sym.name, MacroLevel ));
; 789  : 
; 790  :     return( idx );

	mov	eax, ebx

; 791  : }

	lea	rsp, QWORD PTR [rbp+1352]
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN123@RunMacro:

; 557  :     //} else if ( tokenarray[idx].token != T_FINAL && *macro->sym.name != NULLC ) { /* v2.08: changed */
; 558  :     } else if ( tokenarray[idx].token != T_FINAL ) {

	movsxd	rax, ebx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 0
	je	SHORT $LN424@RunMacro

; 559  :         DebugMsg1(("RunMacro(%s): expected T_FINAL, found >%s<, parmidx=%u\n", macro->sym.name, tokenarray[idx].tokpos, parmidx ));
; 560  :         /* v2.05: changed to a warning. That's what Masm does */
; 561  :         /* v2.09: don't emit a warning if it's a FOR directive
; 562  :          * (in this case, the caller knows better what to do ).
; 563  :          */
; 564  :         if ( !(mflags & MF_IGNARGS) )

	mov	esi, DWORD PTR mflags$[rbp]
	test	sil, 4
	jne	SHORT $LN129@RunMacro

; 565  :             EmitWarn( 1, TOO_MANY_ARGUMENTS_IN_MACRO_CALL, macro->sym.name, tokenarray[idx].tokpos );

	mov	r9, QWORD PTR [rax+rdi+24]
	mov	edx, 149				; 00000095H
	mov	rax, QWORD PTR macro$[rbp]
	mov	ecx, 1
	mov	r8, QWORD PTR [rax+8]
	call	EmitWarn
	jmp	$LN129@RunMacro
$LN130@RunMacro:

; 575  :         return( idx );
; 576  :     }
; 577  : 
; 578  : #if 0
; 579  :     /* check if a (code) label before the macro is to be written
; 580  :      * v2.08: this is the wrong place, because the label is written
; 581  :      * AFTER possible macro functions in the arguments are evaluated.
; 582  :      * Hence this functionality has been moved to ExpandToken().
; 583  :      */
; 584  :     addprefix = FALSE;
; 585  :     if ( macro->sym.isfunc == FALSE && 
; 586  : #if MACROLABEL
; 587  :         macro->sym.label == FALSE &&
; 588  : #endif
; 589  :         label >= 0 && start > label )
; 590  :         addprefix = TRUE;
; 591  : #endif
; 592  : 
; 593  :     mi.localstart = MacroLocals;

	mov	ecx, DWORD PTR MacroLocals

; 594  :     MacroLocals += info->localcnt; /* adjust global variable MacroLocals */

	mov	r8, QWORD PTR info$1$[rbp]
	mov	DWORD PTR mi$[rbp+16], ecx
	movzx	eax, WORD PTR [r8+2]
	add	ecx, eax
	mov	DWORD PTR MacroLocals, ecx

; 595  : 
; 596  :     /* avoid to use values stored in struct macro_info directly. A macro
; 597  :      * may be redefined within the macro! Hence copy all values that are
; 598  :      * needed later in the while loop to macro_instance!
; 599  :      */
; 600  :     mi.startline = info->data;

	mov	rcx, QWORD PTR [r8+16]
	mov	QWORD PTR mi$[rbp+8], rcx

; 601  :     mi.currline = NULL;

	mov	QWORD PTR mi$[rbp], 0

; 602  :     mi.parmcnt = info->parmcnt;

	movzx	eax, WORD PTR [r8]
	mov	DWORD PTR mi$[rbp+40], eax

; 603  : 
; 604  :     /* v2.03: no processing if macro has no lines */
; 605  :     /* v2.08: addprefix is obsolete */
; 606  :     //if ( mi.currline || addprefix ) {
; 607  :     if ( mi.startline ) {

	test	rcx, rcx
	je	$LN163@RunMacro

; 608  :         struct input_status oldstat;
; 609  :         int oldifnesting;
; 610  :         int cntgoto;
; 611  : 
; 612  :         DebugMsg1(("RunMacro(%s): enter assembly loop, macro level=%u\n", macro->sym.name, MacroLevel+1 ));
; 613  :         /* v2.04: this listing is too excessive */
; 614  :         //if ( ModuleInfo.list && ( ModuleInfo.list_macro == LM_LISTMACROALL || MacroLevel == 0 ) )
; 615  :         //if ( MacroLevel == 0 && macro->sym.isfunc == FALSE && *macro->sym.name )
; 616  :         if ( macro->sym.isfunc == FALSE && *macro->sym.name )

	test	BYTE PTR [rdx+44], 2
	jne	SHORT $LN132@RunMacro
	mov	rax, QWORD PTR [rdx+8]
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN132@RunMacro

; 617  :             LstWriteSrcLine();

	call	LstWriteSrcLine
$LN132@RunMacro:

; 618  :         if ( !( mflags & MF_NOSAVE ) )

	and	esi, 2
	mov	DWORD PTR mflags$[rbp], esi
	jne	SHORT $LN133@RunMacro

; 619  :             tokenarray = PushInputStatus( &oldstat );

	lea	rcx, QWORD PTR oldstat$4[rbp]
	call	PushInputStatus
	mov	rdi, rax
	mov	QWORD PTR tokenarray$[rbp], rax
$LN133@RunMacro:

; 620  : 
; 621  :         /*
; 622  :          * move the macro instance onto the file stack!
; 623  :          * Also reset the current linenumber!
; 624  :          */
; 625  :         mi.macro = &macro->sym;

	mov	rax, QWORD PTR macro$[rbp]

; 626  :         PushMacro( &mi );

	lea	rcx, QWORD PTR mi$[rbp]
	mov	QWORD PTR mi$[rbp+32], rax
	call	PushMacro

; 627  :         MacroLevel++;

	inc	BYTE PTR MacroLevel

; 628  :         oldifnesting = GetIfNestLevel(); /* v2.10 */

	call	GetIfNestLevel
	mov	ebx, eax
	mov	DWORD PTR oldifnesting$1$[rbp], eax

; 629  :         cntgoto = 0; /* v2.10 */

	xor	esi, esi
$LN434@RunMacro:
	mov	DWORD PTR cntgoto$1$[rbp], esi
$LN162@RunMacro:

; 630  :         /* Run the assembler until we hit EXITM or ENDM.
; 631  :          * Also handle GOTO and macro label lines!
; 632  :          * v2.08 no need anymore to check the queue level
; 633  :          * v2.11 GetPreprocessedLine() replaced by GetTextLine()
; 634  :          * and PreprocessLine().
; 635  :          */
; 636  : 
; 637  :         while ( GetTextLine( CurrSource ) ) {

	mov	rcx, QWORD PTR ModuleInfo+464
	call	GetTextLine
	test	rax, rax
	je	$LN295@RunMacro

; 638  :             if ( PreprocessLine( CurrSource, tokenarray ) == 0 )

	mov	rcx, QWORD PTR ModuleInfo+464
	mov	rdx, rdi
	call	PreprocessLine
	test	eax, eax
	je	SHORT $LN162@RunMacro

; 639  :                 continue;
; 640  :             /* skip macro label lines */
; 641  :             if ( tokenarray[0].token == T_COLON ) {

	movzx	eax, BYTE PTR [rdi]
	cmp	al, 58					; 0000003aH
	jne	SHORT $LN135@RunMacro

; 642  :                 /* v2.05: emit the error msg here, not in StoreMacro() */
; 643  :                 if ( tokenarray[1].token != T_ID )

	cmp	BYTE PTR [rdi+32], 8
	je	SHORT $LN136@RunMacro

; 644  :                     EmitErr( SYNTAX_ERROR_EX, tokenarray[0].tokpos );

	mov	rdx, QWORD PTR [rdi+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN162@RunMacro
$LN136@RunMacro:

; 645  :                 else if ( tokenarray[2].token != T_FINAL )

	cmp	BYTE PTR [rdi+64], 0
	je	SHORT $LN162@RunMacro

; 646  :                     EmitErr( SYNTAX_ERROR_EX, tokenarray[2].tokpos );

	mov	rdx, QWORD PTR [rdi+88]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 647  :                 continue;

	jmp	SHORT $LN162@RunMacro
$LN135@RunMacro:

; 648  :             }
; 649  : 
; 650  :             if ( tokenarray[0].token == T_DIRECTIVE ) {

	cmp	al, 3
	jne	$LN154@RunMacro

; 651  :                 if ( tokenarray[0].tokval == T_EXITM ) {

	mov	eax, DWORD PTR [rdi+16]
	cmp	eax, 397				; 0000018dH
	je	$LN327@RunMacro

; 700  :                     break;
; 701  : #if 0 /* won't happen anymore */
; 702  :                 } else if ( tokenarray[0].tokval == T_ENDM ) {
; 703  :                     DebugMsg1(("RunMacro(%s): ENDM\n", macro->sym.name ));
; 704  :                     break;
; 705  : #endif
; 706  :                 } else if ( tokenarray[0].tokval == T_GOTO ) {

	cmp	eax, 399				; 0000018fH
	jne	$LN154@RunMacro

; 707  :                     if ( tokenarray[1].token != T_FINAL ) {

	cmp	BYTE PTR [rdi+32], 0
	je	$LN155@RunMacro

; 708  :                         int len = strlen( tokenarray[1].string_ptr );

	mov	rax, QWORD PTR [rdi+40]
	or	rcx, -1
	npad	2
$LL395@RunMacro:
	inc	rcx
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL395@RunMacro

; 709  :                         DebugMsg1(("RunMacro(%s): GOTO %s, MacroLevel=%u\n", macro->sym.name, tokenarray[1].string_ptr, MacroLevel ));
; 710  :                         /* search for the destination line */
; 711  :                         for( i = 1, lnode = mi.startline; lnode != NULL; lnode = lnode->next, i++ ) {

	mov	rdi, QWORD PTR mi$[rbp+8]
	mov	eax, 1
	mov	DWORD PTR i$[rbp], eax
	test	rdi, rdi
	je	$LN328@RunMacro

; 708  :                         int len = strlen( tokenarray[1].string_ptr );

	movsxd	rsi, ecx
$LL37@RunMacro:

; 712  :                             ptr = lnode->line;
; 713  :                             //DebugMsg(("RunMacro(%s): GOTO, scan line >%s< for label >%s<\n", macro->sym.name, ptr, line));
; 714  :                             if ( *ptr == ':' ) {

	cmp	BYTE PTR [rdi+9], 58			; 0000003aH
	lea	rbx, QWORD PTR [rdi+9]
	jne	$LN35@RunMacro

; 715  :                                 if ( lnode->ph_count ) {

	cmp	BYTE PTR [rdi+8], 0
	je	SHORT $LN158@RunMacro

; 716  :                                     fill_placeholders( StringBufferEnd, lnode->line, mi.parmcnt, mi.localstart, mi.parm_array );

	mov	rax, QWORD PTR mi$[rbp+24]
	mov	rdx, rbx
	mov	r9d, DWORD PTR mi$[rbp+16]
	mov	r8d, DWORD PTR mi$[rbp+40]
	mov	rcx, QWORD PTR ModuleInfo+488
	mov	QWORD PTR [rsp+32], rax
	call	fill_placeholders

; 717  :                                     ptr = StringBufferEnd;

	mov	rbx, QWORD PTR ModuleInfo+488
$LN158@RunMacro:

; 718  :                                 }
; 719  :                                 ptr++;
; 720  :                                 while( isspace( *ptr )) ptr++;

	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	je	SHORT $LN39@RunMacro
$LL38@RunMacro:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL38@RunMacro
$LN39@RunMacro:

; 721  :                                 DebugMsg1(("RunMacro(%s): GOTO, line=>%s<\n", macro->sym.name, ptr ));
; 722  :                                 /* macro labels are always case-insensitive! */
; 723  :                                 //if ( ( SymCmpFunc( ptr, tokenarray[1].string_ptr, len ) == 0 ) &&
; 724  :                                 if ( ( _memicmp( ptr, tokenarray[1].string_ptr, len ) == 0 ) &&

	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	r8, rsi
	mov	rcx, rbx
	mov	rdx, QWORD PTR [rax+40]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN408@RunMacro
	movsx	ecx, BYTE PTR [rsi+rbx]
	call	isalnum
	test	eax, eax
	jne	SHORT $LN408@RunMacro
	movzx	eax, BYTE PTR [rsi+rbx]
	sub	al, 36					; 00000024H
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN388@RunMacro
	mov	rcx, 576460752706076673			; 0800000018000001H
	bt	rcx, rax
	jae	SHORT $LN388@RunMacro
$LN408@RunMacro:
	mov	eax, DWORD PTR i$[rbp]
$LN35@RunMacro:

; 709  :                         DebugMsg1(("RunMacro(%s): GOTO %s, MacroLevel=%u\n", macro->sym.name, tokenarray[1].string_ptr, MacroLevel ));
; 710  :                         /* search for the destination line */
; 711  :                         for( i = 1, lnode = mi.startline; lnode != NULL; lnode = lnode->next, i++ ) {

	mov	rdi, QWORD PTR [rdi]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
	test	rdi, rdi
	jne	$LL37@RunMacro
$LN328@RunMacro:

; 732  :                             /* v2.05: display error msg BEFORE SkipMacro()! */
; 733  :                             DebugMsg1(("RunMacro(%s): GOTO, label >%s< not found!\n", macro->sym.name, tokenarray[1].string_ptr ));
; 734  :                             EmitErr( MACRO_LABEL_NOT_DEFINED, tokenarray[1].string_ptr );

	mov	rdi, QWORD PTR tokenarray$[rbp]
	mov	ecx, 264				; 00000108H
	mov	rdx, QWORD PTR [rdi+40]

; 743  :                         }
; 744  :                     } else {

	jmp	SHORT $LN433@RunMacro
$LN388@RunMacro:

; 735  :                         } else {
; 736  :                             DebugMsg1(("RunMacro(%s): GOTO, found label >%s<\n", macro->sym.name, ptr));
; 737  :                             /* v2.10: rewritten, "if"-nesting-level handling added */
; 738  :                             mi.currline = lnode;
; 739  :                             SetLineNumber( i );

	mov	ecx, DWORD PTR i$[rbp]
	mov	QWORD PTR mi$[rbp], rdi
	call	SetLineNumber

; 740  :                             SetIfNestLevel( oldifnesting );

	mov	ebx, DWORD PTR oldifnesting$1$[rbp]
	mov	ecx, ebx
	call	SetIfNestLevel

; 741  :                             cntgoto++;

	mov	esi, DWORD PTR cntgoto$1$[rbp]

; 742  :                             continue;

	mov	rdi, QWORD PTR tokenarray$[rbp]
	inc	esi
	jmp	$LN434@RunMacro
$LN154@RunMacro:

; 748  :                     break;
; 749  :                 }
; 750  :             }
; 751  :             ParseLine( tokenarray );

	mov	rcx, rdi
	call	ParseLine

; 752  :             if ( Options.preprocessor_stdout == TRUE )

	cmp	BYTE PTR Options+125, 1
	jne	$LN162@RunMacro

; 753  :                 WritePreprocessedLine( CurrSource );

	mov	rcx, QWORD PTR ModuleInfo+464
	call	WritePreprocessedLine
	jmp	$LN162@RunMacro
$LN155@RunMacro:

; 745  :                         EmitErr( SYNTAX_ERROR_EX, tokenarray->tokpos );

	mov	rdx, QWORD PTR [rdi+24]
	mov	ecx, 209				; 000000d1H
$LN433@RunMacro:
	call	EmitErr

; 746  :                     }
; 747  :                     SkipMacro( tokenarray );

	lea	rcx, QWORD PTR buffer$6[rbp]
	call	GetTextLine
	test	rax, rax
	je	$LN295@RunMacro
	npad	7
$LL294@RunMacro:
	xor	r9d, r9d
	lea	rcx, QWORD PTR buffer$6[rbp]
	mov	r8, rdi
	xor	edx, edx
	call	Tokenize
	lea	rcx, QWORD PTR buffer$6[rbp]
	call	GetTextLine
	test	rax, rax
	jne	SHORT $LL294@RunMacro
	jmp	$LN295@RunMacro
$LN327@RunMacro:

; 652  :                     if ( ModuleInfo.list && ModuleInfo.list_macro == LM_LISTMACROALL )

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN142@RunMacro
	cmp	DWORD PTR ModuleInfo+400, 2
	jne	SHORT $LN142@RunMacro

; 653  :                         LstWriteSrcLine();

	call	LstWriteSrcLine
$LN142@RunMacro:

; 654  :                     if ( tokenarray[1].token != T_FINAL ) {

	movzx	eax, BYTE PTR [rdi+32]
	lea	rcx, QWORD PTR [rdi+32]
	test	al, al
	je	$LN151@RunMacro

; 655  :                         /* v2.05: display error if there's more than 1 argument or
; 656  :                          * the argument isn't a text item
; 657  :                          */
; 658  :                         if ( tokenarray[1].token != T_STRING || tokenarray[1].string_delim != '<' )

	cmp	al, 9
	jne	$LN146@RunMacro
	cmp	BYTE PTR [rdi+33], 60			; 0000003cH
	jne	$LN146@RunMacro

; 660  :                         else if ( Token_Count > 2 )

	cmp	DWORD PTR ModuleInfo+496, 2
	jle	SHORT $LN147@RunMacro

; 661  :                             EmitErr( SYNTAX_ERROR_EX, tokenarray[2].tokpos );

	mov	rdx, QWORD PTR [rdi+88]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN151@RunMacro
$LN147@RunMacro:

; 662  :                         else if ( out ) { /* return value buffer may be NULL ( loop directives ) */

	mov	r9, QWORD PTR out$[rbp]
	test	r9, r9
	je	$LN151@RunMacro

; 663  : 
; 664  :                             /* v2.08a: the <>-literal behind EXITM is handled specifically,
; 665  :                              * macro operator '!' within the literal is only handled
; 666  :                              * if it contains a placeholder (macro argument, macro local ).
; 667  :                              *
; 668  :                              * v2.09: handle '!' inside literal if ANY expansion occurred.
; 669  :                              * To determine text macro or macro function expansion,
; 670  :                              * check if there's a literal in the original line.
; 671  :                              */
; 672  :                             if ( mi.currline->ph_count || *(mi.currline->line+(tokenarray[1].tokpos-CurrSource)) != '<' ) {

	mov	rcx, QWORD PTR mi$[rbp]
	cmp	BYTE PTR [rcx+8], 0
	jne	SHORT $LN152@RunMacro
	mov	rdx, QWORD PTR [rdi+56]
	mov	rax, rdx
	sub	rax, QWORD PTR ModuleInfo+464
	cmp	BYTE PTR [rax+rcx+9], 60		; 0000003cH
	jne	SHORT $LN152@RunMacro

; 675  :                                 /* since the string_ptr member has the !-operator stripped, it
; 676  :                                  * cannot be used. To get the original value of the literal,
; 677  :                                  * use tokpos.
; 678  :                                  */
; 679  :                                 int len;
; 680  :                                 len = tokenarray[2].tokpos - (tokenarray[1].tokpos+1);

	mov	edi, DWORD PTR [rdi+88]

; 681  :                                 memcpy( out, tokenarray[1].tokpos+1, len );

	mov	rcx, r9
	mov	rax, QWORD PTR tokenarray$[rbp]
	sub	edi, DWORD PTR [rax+56]
	dec	edi
	movsxd	rbx, edi
	inc	rdx
	mov	r8, rbx
	call	memcpy

; 682  :                                 while( *(out+len-1) != '>' ) len--;

	mov	rcx, QWORD PTR out$[rbp]
	lea	rax, QWORD PTR [rcx-1]
	add	rax, rbx
	cmp	BYTE PTR [rax], 62			; 0000003eH
	je	SHORT $LN34@RunMacro
$LL33@RunMacro:
	dec	edi
	lea	rax, QWORD PTR [rax-1]
	cmp	BYTE PTR [rax], 62			; 0000003eH
	jne	SHORT $LL33@RunMacro
$LN34@RunMacro:

; 683  :                                 *(out+len-1) = NULLC;

	mov	ebx, DWORD PTR oldifnesting$1$[rbp]
	movsxd	rax, edi
	mov	rdi, QWORD PTR tokenarray$[rbp]
	mov	BYTE PTR [rax+rcx-1], 0
	jmp	SHORT $LN151@RunMacro
$LN152@RunMacro:

; 673  :                                 memcpy( out, tokenarray[1].string_ptr, tokenarray[1].stringlen + 1 );

	mov	r8d, DWORD PTR [rdi+48]
	mov	rcx, r9
	mov	rdx, QWORD PTR [rdi+40]
	inc	r8d
	call	memcpy

; 674  :                             } else {

	jmp	SHORT $LN151@RunMacro
$LN146@RunMacro:

; 659  :                             TextItemError( &tokenarray[1] );

	call	TextItemError
$LN151@RunMacro:

; 684  :                             }
; 685  :                         }
; 686  :                     }
; 687  :                     DebugMsg1(("RunMacro(%s): EXITM, result=>%s<\n", macro->sym.name, out ? out : "NULL" ));
; 688  : 
; 689  :                     /* v2.10: if a goto had occured, rescan the full macro to ensure that
; 690  :                      * the "if"-nesting level is ok.
; 691  :                      */
; 692  :                     if ( cntgoto ) {

	test	esi, esi
	je	SHORT $LN316@RunMacro

; 693  :                         mi.currline = NULL;
; 694  :                         SetLineNumber( 0 );

	xor	ecx, ecx
	mov	QWORD PTR mi$[rbp], 0
	call	SetLineNumber

; 695  :                         SetIfNestLevel( oldifnesting );

	mov	ecx, ebx
	call	SetIfNestLevel
$LN316@RunMacro:

; 696  :                     }
; 697  : 
; 698  :                     SkipMacro( tokenarray );

	lea	rcx, QWORD PTR buffer$5[rbp]
	call	GetTextLine
	test	rax, rax
	je	SHORT $LN291@RunMacro
	npad	8
$LL290@RunMacro:
	xor	r9d, r9d
	lea	rcx, QWORD PTR buffer$5[rbp]
	mov	r8, rdi
	xor	edx, edx
	call	Tokenize
	lea	rcx, QWORD PTR buffer$5[rbp]
	call	GetTextLine
	test	rax, rax
	jne	SHORT $LL290@RunMacro
$LN291@RunMacro:

; 699  :                     *is_exitm = TRUE;

	mov	rax, QWORD PTR is_exitm$[rbp]
	mov	BYTE PTR [rax], 1

; 746  :                     }
; 747  :                     SkipMacro( tokenarray );

$LN295@RunMacro:

; 754  : 
; 755  :             /* the macro might contain an END directive.
; 756  :              * v2.08: this doesn't mean the macro is to be cancelled.
; 757  :              * Masm continues to run it and the assembly is stopped
; 758  :              * when the top source level is reached again.
; 759  :              */
; 760  :             //if ( ModuleInfo.EndDirFound ) {
; 761  :             //    SkipMacro( tokenarray );
; 762  :             //    *is_exitm = TRUE; /* force loop exit */
; 763  :             //    break;
; 764  :             //}
; 765  :         } /* end while */
; 766  : 
; 767  :         MacroLevel--;

	dec	BYTE PTR MacroLevel

; 768  :         if ( !(mflags & MF_NOSAVE ) )

	cmp	DWORD PTR mflags$[rbp], 0
	jne	SHORT $LN414@RunMacro

; 769  :             PopInputStatus( &oldstat );

	lea	rcx, QWORD PTR oldstat$4[rbp]
	call	PopInputStatus
$LN414@RunMacro:
	mov	ebx, DWORD PTR idx$[rbp]
$LN163@RunMacro:

; 770  : 
; 771  :         /* don't use tokenarray from here on, it's invalid after PopInputStatus() */
; 772  : 
; 773  : #if FASTMEM==0
; 774  :         /* v2.06: free "old" macro line data if macro has been changed
; 775  :          * and isn't in use anymore */
; 776  :         if ( mi.startline != info->data && ( !MacroInUse( macro ) ) ) {
; 777  :             struct srcline  *curr;
; 778  :             struct srcline  *next;
; 779  :             DebugMsg1(("RunMacro(%s): macro has been changed, releasing old lines\n", macro->sym.name ));
; 780  :             for( curr = mi.startline ; curr; curr = next ) {
; 781  :                 next = curr->next;
; 782  :                 LclFree( curr );
; 783  :             }
; 784  :         }
; 785  : #endif
; 786  :     } /* end if */
; 787  : 
; 788  :     DebugMsg1(("RunMacro(%s) exit, MacroLevel=%u\n", macro->sym.name, MacroLevel ));
; 789  : 
; 790  :     return( idx );

	mov	eax, ebx

; 791  : }

	lea	rsp, QWORD PTR [rbp+1352]
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
RunMacro ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
tmpbuf$ = 32
value$ = 96
buffer$ = 104
radix$ = 112
sign$ = 120
addzero$ = 128
myltoa	PROC

; 54   : {

$LN16:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rbx, rdx
	mov	r10d, ecx

; 55   :     char   *p;
; 56   :     char   *dst = buffer;

	mov	r11, rdx

; 57   :     char   tmpbuf[34];
; 58   : 
; 59   : #ifdef DEBUG_OUT
; 60   :     uint_32 saved_value = value;
; 61   : #endif
; 62   :     if ( sign ) {

	test	r9b, r9b
	je	SHORT $LN5@myltoa

; 63   :         *dst++ = '-';

	mov	BYTE PTR [rdx], 45			; 0000002dH
	lea	r11, QWORD PTR [rdx+1]

; 64   :          value = 0 - value;

	neg	r10d
$LN7@myltoa:

; 67   :         *dst = NULLC;
; 68   :         return( buffer );
; 69   :     }
; 70   :     for ( p = &tmpbuf[33], *p = NULLC; value; value = value / radix )

	mov	BYTE PTR tmpbuf$[rsp+33], 0
	lea	r9, QWORD PTR tmpbuf$[rsp+33]
	test	r10d, r10d
	je	SHORT $LN3@myltoa
	mov	QWORD PTR [rsp+96], rdi
	lea	rdi, OFFSET FLAT:__digits
	npad	7
$LL4@myltoa:

; 71   :         *(--p) = __digits[value % radix];

	xor	edx, edx
	mov	eax, r10d
	div	r8d
	dec	r9
	mov	r10d, eax
	movzx	eax, BYTE PTR [rdx+rdi]
	mov	BYTE PTR [r9], al
	test	r10d, r10d
	jne	SHORT $LL4@myltoa
	mov	rdi, QWORD PTR [rsp+96]
$LN3@myltoa:

; 72   :     if ( addzero && ( *p > '9') ) /* v2: add a leading '0' if first digit is alpha */

	cmp	BYTE PTR addzero$[rsp], 0
	je	SHORT $LN8@myltoa
	cmp	BYTE PTR [r9], 57			; 00000039H
	jle	SHORT $LN8@myltoa

; 73   :         *dst++ = '0';

	mov	BYTE PTR [r11], 48			; 00000030H
	inc	r11
$LN8@myltoa:

; 74   :     memcpy( dst, p, &tmpbuf[33] + 1 - p );

	lea	r8, QWORD PTR tmpbuf$[rsp+34]
	mov	rdx, r9
	sub	r8, r9
	mov	rcx, r11
	call	memcpy

; 75   :     DebugMsg1(("myltoa( value=%" I32_SPEC "Xh, out=%s, radix=%u, sign=%u, %u)\n", saved_value, buffer, radix, sign, addzero ));
; 76   :     return( buffer );

	mov	rax, rbx

; 77   : }

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
$LN5@myltoa:

; 65   :     } else if ( value == 0 ) {

	test	ecx, ecx
	jne	SHORT $LN7@myltoa

; 66   :         *dst++ = '0';

	mov	WORD PTR [rdx], 48			; 00000030H

; 75   :     DebugMsg1(("myltoa( value=%" I32_SPEC "Xh, out=%s, radix=%u, sign=%u, %u)\n", saved_value, buffer, radix, sign, addzero ));
; 76   :     return( buffer );

	mov	rax, rbx

; 77   : }

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
myltoa	ENDP
_TEXT	ENDS
END
