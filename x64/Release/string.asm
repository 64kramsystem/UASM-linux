; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11212 DB	'@CatStr', 00H
$SG11213 DB	'@InStr', 00H
	ORG $+1
$SG11214 DB	'@SizeStr', 00H
	ORG $+7
$SG11215 DB	'@SubStr', 00H
_DATA	ENDS
PUBLIC	SetTextMacro
PUBLIC	AddPredefinedText
PUBLIC	TextItemError
PUBLIC	StringInit
PUBLIC	CatStrDir
PUBLIC	SubStrDir
PUBLIC	SizeStrDir
PUBLIC	InStrDir
EXTRN	isspace:PROC
EXTRN	strstr:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	myltoa:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymCreate:PROC
EXTRN	SymFind:PROC
EXTRN	sym_remove_table:PROC
EXTRN	EvalOperand:PROC
EXTRN	CreateVariable:PROC
EXTRN	Tokenize:PROC
EXTRN	CreateMacro:PROC
EXTRN	SkipSavedState:PROC
EXTRN	LstWrite:PROC
EXTRN	memcpy:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	SymTables:BYTE
pdata	SEGMENT
$pdata$SetTextMacro DD imagerel $LN25
	DD	imagerel $LN25+55
	DD	imagerel $unwind$SetTextMacro
$pdata$0$SetTextMacro DD imagerel $LN25+55
	DD	imagerel $LN25+95
	DD	imagerel $chain$0$SetTextMacro
$pdata$1$SetTextMacro DD imagerel $LN25+95
	DD	imagerel $LN25+176
	DD	imagerel $chain$1$SetTextMacro
$pdata$2$SetTextMacro DD imagerel $LN25+176
	DD	imagerel $LN25+303
	DD	imagerel $chain$2$SetTextMacro
$pdata$AddPredefinedText DD imagerel $LN5
	DD	imagerel $LN5+67
	DD	imagerel $unwind$AddPredefinedText
$pdata$TextItemError DD imagerel $LN9
	DD	imagerel $LN9+100
	DD	imagerel $unwind$TextItemError
$pdata$StringInit DD imagerel $LN24
	DD	imagerel $LN24+490
	DD	imagerel $unwind$StringInit
$pdata$CatStrDir DD imagerel $LN42
	DD	imagerel $LN42+121
	DD	imagerel $unwind$CatStrDir
$pdata$1$CatStrDir DD imagerel $LN42+121
	DD	imagerel $LN42+171
	DD	imagerel $chain$1$CatStrDir
$pdata$2$CatStrDir DD imagerel $LN42+171
	DD	imagerel $LN42+279
	DD	imagerel $chain$2$CatStrDir
$pdata$3$CatStrDir DD imagerel $LN42+279
	DD	imagerel $LN42+316
	DD	imagerel $chain$3$CatStrDir
$pdata$4$CatStrDir DD imagerel $LN42+316
	DD	imagerel $LN42+489
	DD	imagerel $chain$4$CatStrDir
$pdata$5$CatStrDir DD imagerel $LN42+489
	DD	imagerel $LN42+565
	DD	imagerel $chain$5$CatStrDir
$pdata$SubStrDir DD imagerel $LN31
	DD	imagerel $LN31+58
	DD	imagerel $unwind$SubStrDir
$pdata$1$SubStrDir DD imagerel $LN31+58
	DD	imagerel $LN31+124
	DD	imagerel $chain$1$SubStrDir
$pdata$2$SubStrDir DD imagerel $LN31+124
	DD	imagerel $LN31+188
	DD	imagerel $chain$2$SubStrDir
$pdata$3$SubStrDir DD imagerel $LN31+188
	DD	imagerel $LN31+273
	DD	imagerel $chain$3$SubStrDir
$pdata$4$SubStrDir DD imagerel $LN31+273
	DD	imagerel $LN31+281
	DD	imagerel $chain$4$SubStrDir
$pdata$5$SubStrDir DD imagerel $LN31+281
	DD	imagerel $LN31+308
	DD	imagerel $chain$5$SubStrDir
$pdata$7$SubStrDir DD imagerel $LN31+308
	DD	imagerel $LN31+690
	DD	imagerel $chain$7$SubStrDir
$pdata$8$SubStrDir DD imagerel $LN31+690
	DD	imagerel $LN31+709
	DD	imagerel $chain$8$SubStrDir
$pdata$SizeStrDir DD imagerel $LN9
	DD	imagerel $LN9+135
	DD	imagerel $unwind$SizeStrDir
$pdata$InStrDir DD imagerel $LN22
	DD	imagerel $LN22+303
	DD	imagerel $unwind$InStrDir
$pdata$0$InStrDir DD imagerel $LN22+303
	DD	imagerel $LN22+396
	DD	imagerel $chain$0$InStrDir
$pdata$2$InStrDir DD imagerel $LN22+396
	DD	imagerel $LN22+476
	DD	imagerel $chain$2$InStrDir
$pdata$3$InStrDir DD imagerel $LN22+476
	DD	imagerel $LN22+552
	DD	imagerel $chain$3$InStrDir
$pdata$4$InStrDir DD imagerel $LN22+552
	DD	imagerel $LN22+593
	DD	imagerel $chain$4$InStrDir
$pdata$5$InStrDir DD imagerel $LN22+593
	DD	imagerel $LN22+618
	DD	imagerel $chain$5$InStrDir
$pdata$CatStrFunc DD imagerel CatStrFunc
	DD	imagerel CatStrFunc+35
	DD	imagerel $unwind$CatStrFunc
$pdata$1$CatStrFunc DD imagerel CatStrFunc+35
	DD	imagerel CatStrFunc+137
	DD	imagerel $chain$1$CatStrFunc
$pdata$2$CatStrFunc DD imagerel CatStrFunc+137
	DD	imagerel CatStrFunc+159
	DD	imagerel $chain$2$CatStrFunc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetNumber DD imagerel GetNumber
	DD	imagerel GetNumber+171
	DD	imagerel $unwind$GetNumber
pdata	ENDS
pdata	SEGMENT
$pdata$InStrFunc DD imagerel InStrFunc
	DD	imagerel InStrFunc+230
	DD	imagerel $unwind$InStrFunc
$pdata$SizeStrFunc DD imagerel SizeStrFunc
	DD	imagerel SizeStrFunc+74
	DD	imagerel $unwind$SizeStrFunc
$pdata$SubStrFunc DD imagerel SubStrFunc
	DD	imagerel SubStrFunc+368
	DD	imagerel $unwind$SubStrFunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetNumber DD 071201H
	DD	0176412H
	DD	0163412H
	DD	0140112H
	DD	0700bH
xdata	ENDS
xdata	SEGMENT
$unwind$SetTextMacro DD 060f01H
	DD	08540fH
	DD	07340fH
	DD	0600b320fH
$chain$0$SetTextMacro DD 020521H
	DD	067405H
	DD	imagerel $LN25
	DD	imagerel $LN25+55
	DD	imagerel $unwind$SetTextMacro
$chain$1$SetTextMacro DD 021H
	DD	imagerel $LN25
	DD	imagerel $LN25+55
	DD	imagerel $unwind$SetTextMacro
$chain$2$SetTextMacro DD 020021H
	DD	067400H
	DD	imagerel $LN25
	DD	imagerel $LN25+55
	DD	imagerel $unwind$SetTextMacro
$unwind$AddPredefinedText DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$TextItemError DD 020601H
	DD	030023206H
$unwind$StringInit DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$CatStrDir DD 040b01H
	DD	09340bH
	DD	0e007320bH
$chain$1$CatStrDir DD 040a21H
	DD	08740aH
	DD	065405H
	DD	imagerel $LN42
	DD	imagerel $LN42+121
	DD	imagerel $unwind$CatStrDir
$chain$2$CatStrDir DD 020521H
	DD	076405H
	DD	imagerel $LN42+121
	DD	imagerel $LN42+171
	DD	imagerel $chain$1$CatStrDir
$chain$3$CatStrDir DD 021H
	DD	imagerel $LN42+121
	DD	imagerel $LN42+171
	DD	imagerel $chain$1$CatStrDir
$chain$4$CatStrDir DD 021H
	DD	imagerel $LN42
	DD	imagerel $LN42+121
	DD	imagerel $unwind$CatStrDir
$chain$5$CatStrDir DD 040021H
	DD	087400H
	DD	065400H
	DD	imagerel $LN42
	DD	imagerel $LN42+121
	DD	imagerel $unwind$CatStrDir
$unwind$SubStrDir DD 040d01H
	DD	015010dH
	DD	06004e006H
$chain$1$SubStrDir DD 041321H
	DD	014f413H
	DD	01a5404H
	DD	imagerel $LN31
	DD	imagerel $LN31+58
	DD	imagerel $unwind$SubStrDir
$chain$2$SubStrDir DD 020821H
	DD	0193408H
	DD	imagerel $LN31+58
	DD	imagerel $LN31+124
	DD	imagerel $chain$1$SubStrDir
$chain$3$SubStrDir DD 020821H
	DD	01b7408H
	DD	imagerel $LN31+124
	DD	imagerel $LN31+188
	DD	imagerel $chain$2$SubStrDir
$chain$4$SubStrDir DD 021H
	DD	imagerel $LN31+124
	DD	imagerel $LN31+188
	DD	imagerel $chain$2$SubStrDir
$chain$5$SubStrDir DD 021H
	DD	imagerel $LN31+58
	DD	imagerel $LN31+124
	DD	imagerel $chain$1$SubStrDir
$chain$7$SubStrDir DD 080021H
	DD	014f400H
	DD	01b7400H
	DD	01a5400H
	DD	0193400H
	DD	imagerel $LN31
	DD	imagerel $LN31+58
	DD	imagerel $unwind$SubStrDir
$chain$8$SubStrDir DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+58
	DD	imagerel $unwind$SubStrDir
$unwind$SizeStrDir DD 010401H
	DD	04204H
$unwind$InStrDir DD 051101H
	DD	0193411H
	DD	0140111H
	DD	0600aH
$chain$0$InStrDir DD 020821H
	DD	0175408H
	DD	imagerel $LN22
	DD	imagerel $LN22+303
	DD	imagerel $unwind$InStrDir
$chain$2$InStrDir DD 020021H
	DD	0175400H
	DD	imagerel $LN22
	DD	imagerel $LN22+303
	DD	imagerel $unwind$InStrDir
$chain$3$InStrDir DD 020821H
	DD	0187408H
	DD	imagerel $LN22+396
	DD	imagerel $LN22+476
	DD	imagerel $chain$2$InStrDir
$chain$4$InStrDir DD 021H
	DD	imagerel $LN22+396
	DD	imagerel $LN22+476
	DD	imagerel $chain$2$InStrDir
$chain$5$InStrDir DD 021H
	DD	imagerel $LN22
	DD	imagerel $LN22+303
	DD	imagerel $unwind$InStrDir
$unwind$CatStrFunc DD 061001H
	DD	096410H
	DD	085410H
	DD	0e00c3210H
$chain$1$CatStrFunc DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel CatStrFunc
	DD	imagerel CatStrFunc+35
	DD	imagerel $unwind$CatStrFunc
$chain$2$CatStrFunc DD 021H
	DD	imagerel CatStrFunc
	DD	imagerel CatStrFunc+35
	DD	imagerel $unwind$CatStrFunc
$unwind$InStrFunc DD 060f01H
	DD	0a640fH
	DD	09340fH
	DD	0700b520fH
$unwind$SizeStrFunc DD 010401H
	DD	06204H
$unwind$SubStrFunc DD 0b1901H
	DD	01c5419H
	DD	01b3419H
	DD	0140119H
	DD	0e010f012H
	DD	0700cd00eH
	DD	0600bH
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
opndx$1 = 48
i$2 = 208
sizereq$3 = 208
pos$ = 208
mi$ = 208
buffer$ = 216
tokenarray$ = 224
SubStrFunc PROC

; 719  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 160				; 000000a0H

; 720  :     int pos;
; 721  :     int size;
; 722  :     char *src = mi->parm_array[0];

	mov	rax, QWORD PTR [rcx+24]
	mov	r15, rdx

; 723  : 
; 724  :     DebugMsg1(("@SubStr( %s, %s, %s)\n",
; 725  :               src ? src : "",
; 726  :               mi->parm_array[1] ? mi->parm_array[1] : "",
; 727  :               mi->parm_array[2] ? mi->parm_array[2] : "" ));
; 728  : 
; 729  :     if ( GetNumber( mi->parm_array[1], &pos, tokenarray ) == ERROR )

	mov	edx, DWORD PTR ModuleInfo+496
	mov	r13, rcx
	mov	ebp, 1
	inc	edx
	mov	r9d, ebp
	mov	r14, r8
	mov	rbx, QWORD PTR [rax+8]
	mov	rsi, QWORD PTR [rax]
	mov	rcx, rbx
	call	Tokenize
	mov	edx, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$1[rsp]
	inc	edx
	mov	BYTE PTR [rsp+32], 2
	mov	DWORD PTR i$2[rsp], edx
	lea	rcx, QWORD PTR i$2[rsp]
	mov	rdx, r14
	mov	r8d, eax
	call	EvalOperand
	cmp	eax, -1
	je	$LN16@SubStrFunc
	cmp	DWORD PTR opndx$1[rsp+60], 0
	jne	SHORT $LN14@SubStrFunc
	movsxd	rax, DWORD PTR i$2[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+r14], 0
	jne	SHORT $LN14@SubStrFunc
	mov	edi, DWORD PTR opndx$1[rsp]
	jmp	SHORT $LN2@SubStrFunc
$LN14@SubStrFunc:
	mov	rdx, rbx
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	cmp	eax, -1
	je	$LN16@SubStrFunc
	mov	edi, DWORD PTR pos$[rsp]
$LN2@SubStrFunc:

; 731  : 
; 732  :     if ( pos <= 0 ) {

	test	edi, edi
	jg	SHORT $LN3@SubStrFunc

; 733  :         /* Masm doesn't check if index is < 0;
; 734  :          * might cause an "internal assembler error".
; 735  :          * v2.09: negative index no longer silently changed to 1.
; 736  :          */
; 737  :         if ( pos ) {

	je	SHORT $LN4@SubStrFunc
$LN18@SubStrFunc:

; 738  :             return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, pos ) );

	mov	edx, edi
	mov	ecx, 206				; 000000ceH
	call	EmitErr
	jmp	$LN1@SubStrFunc
$LN4@SubStrFunc:

; 739  :         }
; 740  :         DebugMsg(( "@SubStr(): index value 0 changed to 1\n", pos ));
; 741  :         pos = 1;

	mov	edi, ebp
$LN3@SubStrFunc:

; 742  :     }
; 743  : 
; 744  :     size = strlen( src );

	or	rbx, -1
$LL17@SubStrFunc:
	inc	rbx
	cmp	BYTE PTR [rsi+rbx], 0
	jne	SHORT $LL17@SubStrFunc

; 745  :     if ( pos > size ) {

	cmp	edi, ebx
	jg	SHORT $LN18@SubStrFunc

; 746  :         return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, pos ) );
; 747  :     }
; 748  : 
; 749  :     size = size - pos + 1;
; 750  : 
; 751  :     if ( mi->parm_array[2] ) {

	mov	rcx, QWORD PTR [r13+24]
	sub	ebp, edi
	add	ebx, ebp
	mov	rcx, QWORD PTR [rcx+16]
	test	rcx, rcx
	je	SHORT $LN6@SubStrFunc

; 752  :         int sizereq;
; 753  :         if ( GetNumber( mi->parm_array[2], &sizereq, tokenarray ) == ERROR )

	mov	r8, r14
	lea	rdx, QWORD PTR sizereq$3[rsp]
	call	GetNumber
	cmp	eax, -1
	je	SHORT $LN16@SubStrFunc

; 754  :             return( ERROR );
; 755  :         if ( sizereq < 0 ) {

	mov	eax, DWORD PTR sizereq$3[rsp]
	test	eax, eax
	jns	SHORT $LN8@SubStrFunc

; 756  :             return( EmitError( COUNT_MUST_BE_POSITIVE_OR_ZERO ) );

	mov	ecx, 208				; 000000d0H
	call	EmitError
	jmp	SHORT $LN1@SubStrFunc
$LN8@SubStrFunc:

; 757  :         }
; 758  :         if ( sizereq > size ) {

	cmp	eax, ebx
	jle	SHORT $LN9@SubStrFunc

; 759  :             return( EmitError( COUNT_VALUE_TOO_LARGE ) );

	mov	ecx, 207				; 000000cfH
	call	EmitError
	jmp	SHORT $LN1@SubStrFunc
$LN9@SubStrFunc:

; 760  :         }
; 761  :         size = sizereq;

	mov	ebx, eax
$LN6@SubStrFunc:

; 762  :     }
; 763  : #if 1
; 764  :     memcpy( buffer, src + pos - 1, size );

	movsxd	rax, edi
	lea	rdx, QWORD PTR [rsi-1]
	movsxd	rbx, ebx
	add	rdx, rax
	mov	r8, rbx
	mov	rcx, r15
	call	memcpy

; 765  :     *(buffer+size) = NULLC;
; 766  : #else
; 767  :     for( src += pos - 1; size; size-- )
; 768  :         *buffer++ = *src++;
; 769  :     *buffer = NULLC;
; 770  : #endif
; 771  :     return( NOT_ERROR );

	xor	eax, eax
	mov	BYTE PTR [rbx+r15], 0
	jmp	SHORT $LN1@SubStrFunc
$LN16@SubStrFunc:

; 730  :         return( ERROR );

	or	eax, -1
$LN1@SubStrFunc:

; 772  : }

	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	ret	0
SubStrFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
mi$ = 64
buffer$ = 72
tokenarray$ = 80
SizeStrFunc PROC

; 702  : {

	sub	rsp, 56					; 00000038H

; 703  :     DebugMsg1(("@SizeStr(%s)\n", mi->parm_array[0] ? mi->parm_array[0] : "" ));
; 704  :     if ( mi->parm_array[0] )

	mov	rax, QWORD PTR [rcx+24]
	mov	r9, QWORD PTR [rax]
	test	r9, r9
	je	SHORT $LN2@SizeStrFun

; 705  :         myltoa( strlen( mi->parm_array[0] ), buffer, ModuleInfo. radix, FALSE, TRUE );

	movzx	r8d, BYTE PTR ModuleInfo+396
	or	rcx, -1
	npad	4
$LL5@SizeStrFun:
	inc	rcx
	cmp	BYTE PTR [r9+rcx], 0
	jne	SHORT $LL5@SizeStrFun
	xor	r9d, r9d
	mov	BYTE PTR [rsp+32], 1
	call	myltoa

; 708  :         buffer[1] = NULLC;
; 709  :     }
; 710  :     return( NOT_ERROR );

	xor	eax, eax

; 711  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN2@SizeStrFun:

; 706  :     else {
; 707  :         buffer[0] = '0';

	mov	WORD PTR [rdx], 48			; 00000030H

; 708  :         buffer[1] = NULLC;
; 709  :     }
; 710  :     return( NOT_ERROR );

	xor	eax, eax

; 711  : }

	add	rsp, 56					; 00000038H
	ret	0
SizeStrFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
pos$ = 64
mi$ = 64
buffer$ = 72
tokenarray$ = 80
InStrFunc PROC

; 654  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 655  :     int pos = 1;
; 656  :     char *p;
; 657  :     uint_32 found;
; 658  : 
; 659  :     DebugMsg1(("@InStr( %s, %s, %s)\n",
; 660  :               mi->parm_array[0] ? mi->parm_array[0] : "",
; 661  :               mi->parm_array[1] ? mi->parm_array[1] : "",
; 662  :               mi->parm_array[2] ? mi->parm_array[2] : "" ));
; 663  : 
; 664  :     /* init buffer with "0" */
; 665  :     *buffer = '0';

	mov	WORD PTR [rdx], 48			; 00000030H
	mov	rdi, rcx

; 666  :     *(buffer+1) = NULLC;
; 667  : 
; 668  :     if ( mi->parm_array[0] ) {

	mov	rax, QWORD PTR [rcx+24]
	mov	ebx, 1
	mov	rsi, rdx
	mov	DWORD PTR pos$[rsp], ebx
	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN4@InStrFunc

; 669  :         if ( GetNumber( mi->parm_array[0], &pos, tokenarray ) == ERROR )

	lea	rdx, QWORD PTR pos$[rsp]
	call	GetNumber
	cmp	eax, -1
	jne	SHORT $LN3@InStrFunc

; 670  :             return( ERROR );

	or	rax, -1

; 688  :         }
; 689  :     }
; 690  : 
; 691  :     DebugMsg1(( "@InStr()=>%s<\n", buffer ));
; 692  : 
; 693  :     return( NOT_ERROR );
; 694  : }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN3@InStrFunc:

; 671  :         if ( pos == 0 ) {

	mov	eax, DWORD PTR pos$[rsp]
	test	eax, eax
	cmove	eax, ebx
	mov	ebx, eax
$LN4@InStrFunc:

; 672  :             /* adjust index 0. Masm also accepts 0 (and any negative index),
; 673  :              * but the result will always be 0 then */
; 674  :             DebugMsg(( "@InStr(): index value is 0, changed to 1\n" ));
; 675  :             pos++;
; 676  :         }
; 677  :     }
; 678  : 
; 679  :     if ( pos > strlen( mi->parm_array[1] ) ) {

	mov	rdx, QWORD PTR [rdi+24]
	or	rax, -1
	movsxd	r8, ebx
	mov	rcx, QWORD PTR [rdx+8]
	npad	4
$LL9@InStrFunc:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL9@InStrFunc
	cmp	r8, rax
	jbe	SHORT $LN5@InStrFunc

; 680  :         return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, pos ) );

	mov	edx, ebx
	mov	ecx, 206				; 000000ceH

; 688  :         }
; 689  :     }
; 690  : 
; 691  :     DebugMsg1(( "@InStr()=>%s<\n", buffer ));
; 692  : 
; 693  :     return( NOT_ERROR );
; 694  : }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi

; 680  :         return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, pos ) );

	jmp	EmitErr
$LN5@InStrFunc:

; 681  :     }
; 682  :     /* v2.08: if() added, empty searchstr is to return 0 */
; 683  :     if ( *(mi->parm_array[2]) != NULLC ) {

	mov	rdx, QWORD PTR [rdx+16]
	cmp	BYTE PTR [rdx], 0
	je	SHORT $LN7@InStrFunc

; 684  :         p = strstr( mi->parm_array[1] + pos - 1, mi->parm_array[2] );

	dec	rcx
	add	rcx, r8
	call	strstr

; 685  :         if ( p ) {

	test	rax, rax
	je	SHORT $LN7@InStrFunc

; 686  :             found = p - mi->parm_array[1] + 1;
; 687  :             myltoa( found, buffer, ModuleInfo.radix, FALSE, TRUE );

	mov	rcx, QWORD PTR [rdi+24]
	xor	r9d, r9d
	movzx	r8d, BYTE PTR ModuleInfo+396
	mov	rdx, rsi
	mov	BYTE PTR [rsp+32], 1
	sub	eax, DWORD PTR [rcx+8]
	lea	ecx, DWORD PTR [rax+1]
	call	myltoa
$LN7@InStrFunc:

; 688  :         }
; 689  :     }
; 690  : 
; 691  :     DebugMsg1(( "@InStr()=>%s<\n", buffer ));
; 692  : 
; 693  :     return( NOT_ERROR );
; 694  : }

	mov	rbx, QWORD PTR [rsp+72]
	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
InStrFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
;	COMDAT GetNumber
_TEXT	SEGMENT
opndx$ = 48
string$ = 176
pi$ = 184
tokenarray$ = 192
i$ = 200
GetNumber PROC						; COMDAT

; 629  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 160				; 000000a0H
	mov	rsi, rdx

; 630  :     struct expr opndx;
; 631  :     int i;
; 632  :     int last;
; 633  : 
; 634  :     last = Tokenize( string, Token_Count+1, tokenarray, TOK_RESCAN );

	mov	r9d, 1
	mov	edx, DWORD PTR ModuleInfo+496
	mov	rbx, r8
	inc	edx
	mov	rdi, rcx
	call	Tokenize

; 635  :     i = Token_Count+1;

	mov	r9d, DWORD PTR ModuleInfo+496

; 636  :     if( EvalOperand( &i, tokenarray, last, &opndx, EXPF_NOUNDEF ) == ERROR ) {

	lea	rcx, QWORD PTR i$[rsp]
	inc	r9d
	mov	BYTE PTR [rsp+32], 2
	mov	DWORD PTR i$[rsp], r9d
	mov	r8d, eax
	lea	r9, QWORD PTR opndx$[rsp]
	mov	rdx, rbx
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN2@GetNumber

; 637  :         return( ERROR );

	or	eax, eax
	jmp	SHORT $LN1@GetNumber
$LN2@GetNumber:

; 638  :     }
; 639  :     /* v2.11: string constants are accepted ( although hardly useful ) */
; 640  :     //if( opndx.kind != EXPR_CONST || opndx.quoted_string != NULL || tokenarray[i].token != T_FINAL ) {
; 641  :     if( opndx.kind != EXPR_CONST || tokenarray[i].token != T_FINAL ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN4@GetNumber
	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rbx], 0
	jne	SHORT $LN4@GetNumber

; 643  :     }
; 644  :     *pi = opndx.value;

	mov	eax, DWORD PTR opndx$[rsp]
	mov	DWORD PTR [rsi], eax

; 645  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@GetNumber
$LN4@GetNumber:

; 642  :         return( EmitErr( SYNTAX_ERROR_EX, string ) );

	mov	rdx, rdi
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN1@GetNumber:

; 646  : }

	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
GetNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
mi$ = 48
buffer$ = 56
tokenarray$ = 64
CatStrFunc PROC

; 602  : {

	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	r14
	sub	rsp, 32					; 00000020H

; 603  : #ifdef DEBUG_OUT
; 604  :     int cnt = 0;
; 605  : #endif
; 606  :     int i;
; 607  :     char *p;
; 608  : 
; 609  :     DebugMsg1(("@CatStr( %s )\n", mi->parm_array[0] ? mi->parm_array[0] : "NULL" ));
; 610  : 
; 611  :     for ( p = mi->parm_array[0]; mi->parmcnt; mi->parmcnt-- ) {

	cmp	DWORD PTR [rcx+40], 0
	mov	r14, rdx
	mov	rax, QWORD PTR [rcx+24]
	mov	rbp, rcx
	mov	rsi, QWORD PTR [rax]
	je	SHORT $LN11@CatStrFunc
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rdi
	npad	3
$LL4@CatStrFunc:

; 612  :         DebugMsg1(("@CatStr.%u: >%s<\n", cnt++, p ));
; 613  :         i = strlen( p );

	or	rbx, -1
$LL10@CatStrFunc:
	inc	rbx
	cmp	BYTE PTR [rsi+rbx], 0
	jne	SHORT $LL10@CatStrFunc

; 614  :         memcpy( buffer, p, i );

	movsxd	rdi, ebx
	mov	rdx, rsi
	mov	r8, rdi
	mov	rcx, r14
	call	memcpy

; 615  :         p = GetAlignedPointer( p, i );

	lea	eax, DWORD PTR [rbx+1]

; 616  :         buffer += i;

	add	r14, rdi
	movsxd	rcx, eax
	add	rcx, 7
	and	rcx, -8
	add	rsi, rcx
	add	DWORD PTR [rbp+40], -1			; ffffffffH
	jne	SHORT $LL4@CatStrFunc

; 617  :     }
; 618  :     *buffer = NULLC;
; 619  :     return( NOT_ERROR );

	mov	rdi, QWORD PTR [rsp+56]
	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+48]
	mov	BYTE PTR [r14], 0

; 620  : }

	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN11@CatStrFunc:
	mov	rbp, QWORD PTR [rsp+64]
	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+72]
	mov	BYTE PTR [rdx], 0
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
CatStrFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
opndx$ = 48
i$ = 176
tokenarray$ = 184
InStrDir PROC

; 496  : {

$LN22:
	mov	QWORD PTR [rsp+32], rbx
	mov	DWORD PTR [rsp+8], ecx
	push	rsi
	sub	rsp, 160				; 000000a0H

; 497  :     struct asym *sym;
; 498  :     int sizestr;
; 499  :     int j;
; 500  :     /* int commas; */
; 501  :     char *src;
; 502  :     char *p;
; 503  :     char *q;
; 504  :     char *string1;
; 505  :     struct expr opndx;
; 506  :     int start = 1;

	mov	esi, 1
	mov	rbx, rdx

; 507  :     int strpos;
; 508  : 
; 509  :     DebugMsg1(("InStrDir entry\n"));
; 510  :     DebugCmd( instrcnt++ );
; 511  : 
; 512  :     if ( i != 1) {

	cmp	ecx, esi
	je	SHORT $LN2@InStrDir

; 513  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbx+8]
	call	EmitErr

; 594  : }

	mov	rbx, QWORD PTR [rsp+200]
	add	rsp, 160				; 000000a0H
	pop	rsi
	ret	0
$LN2@InStrDir:

; 514  :     }
; 515  : #if 0 /* this is checked in ParseLine() */
; 516  :     if ( tokenarray[0].token != T_ID ) {
; 517  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );
; 518  :     }
; 519  : #endif
; 520  : 
; 521  :     i++; /* go past INSTR */

	mov	ecx, 2
	mov	DWORD PTR i$[rsp], ecx

; 522  : 
; 523  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	cmp	BYTE PTR [rdx+64], 9
	jne	SHORT $LN4@InStrDir
	cmp	BYTE PTR [rdx+65], 60			; 0000003cH
	je	$LN3@InStrDir
$LN4@InStrDir:

; 524  :         /* v2.11: flag NOUNDEF added - no forward reference accepted */
; 525  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	mov	BYTE PTR [rsp+32], cl
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN5@InStrDir

; 526  :             return( ERROR );

	or	eax, eax

; 594  : }

	mov	rbx, QWORD PTR [rsp+200]
	add	rsp, 160				; 000000a0H
	pop	rsi
	ret	0
$LN5@InStrDir:

; 527  :         if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN6@InStrDir

; 528  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 594  : }

	mov	rbx, QWORD PTR [rsp+200]
	add	rsp, 160				; 000000a0H
	pop	rsi
	ret	0
$LN6@InStrDir:

; 529  :         }
; 530  :         start = opndx.value;

	mov	esi, DWORD PTR opndx$[rsp]

; 531  :         if ( start <= 0 ) {

	test	esi, esi
	jg	SHORT $LN7@InStrDir

; 532  :             /* v2.05: don't change the value. if it's invalid, the result
; 533  :              * is to be 0. Emit a level 3 warning instead.
; 534  :              */
; 535  :             //start = 1;
; 536  :             EmitWarn( 3, POSITIVE_VALUE_EXPECTED );

	mov	edx, 175				; 000000afH
	mov	ecx, 3
	call	EmitWarn
$LN7@InStrDir:

; 537  :         }
; 538  :         if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, rcx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 44			; 0000002cH
	je	SHORT $LN8@InStrDir

; 539  :             return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rbx+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr

; 594  : }

	mov	rbx, QWORD PTR [rsp+200]
	add	rsp, 160				; 000000a0H
	pop	rsi
	ret	0
$LN8@InStrDir:

; 540  :         }
; 541  :         i++; /* skip comma */

	inc	ecx
	mov	DWORD PTR i$[rsp], ecx
$LN3@InStrDir:

; 542  :     }
; 543  : 
; 544  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	r8, ecx
	shl	r8, 5
	add	r8, rbx
	cmp	BYTE PTR [r8], 9
	jne	$LN10@InStrDir
	cmp	BYTE PTR [r8+1], 60			; 0000003cH
	jne	$LN10@InStrDir

; 546  :     }
; 547  : 
; 548  :     /* to compare the strings, the "visible" format is needed, since
; 549  :      * the possible '!' operators inside the strings is optional and
; 550  :      * must be ignored.
; 551  :      */
; 552  :     //src = StringBufferEnd;
; 553  :     //sizestr = GetLiteralValue( src, tokenarray[i].string_ptr );
; 554  :     src = tokenarray[i].string_ptr;
; 555  :     sizestr = tokenarray[i].stringlen;

	mov	r9d, DWORD PTR [r8+16]
	mov	QWORD PTR [rsp+184], rbp
	mov	rbp, QWORD PTR [r8+8]

; 556  :     DebugMsg1(("InStrDir: first string >%s< \n", src ));
; 557  : 
; 558  :     if ( start > sizestr ) {

	cmp	esi, r9d
	jle	SHORT $LN11@InStrDir

; 559  :         return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, start ) );

	mov	edx, esi
	mov	ecx, 206				; 000000ceH
	call	EmitErr
	jmp	SHORT $LN19@InStrDir
$LN11@InStrDir:

; 560  :     }
; 561  :     p = src + start - 1;
; 562  : 
; 563  :     i++;

	inc	ecx

; 564  :     if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rdx, ecx
	shl	rdx, 5
	mov	DWORD PTR i$[rsp], ecx
	cmp	BYTE PTR [rdx+rbx], 44			; 0000002cH
	je	SHORT $LN12@InStrDir

; 565  :         return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rbx+24]
	mov	ecx, 39					; 00000027H
$LN20@InStrDir:
	call	EmitErr
$LN19@InStrDir:
	mov	rbp, QWORD PTR [rsp+184]

; 594  : }

	mov	rbx, QWORD PTR [rsp+200]
	add	rsp, 160				; 000000a0H
	pop	rsi
	ret	0
$LN12@InStrDir:

; 566  :     }
; 567  :     i++;

	inc	ecx

; 568  : 
; 569  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rdx, ecx
	shl	rdx, 5
	add	rdx, rbx
	mov	DWORD PTR i$[rsp], ecx
	cmp	BYTE PTR [rdx], 9
	jne	$LN14@InStrDir
	cmp	BYTE PTR [rdx+1], 60			; 0000003cH
	jne	$LN14@InStrDir

; 571  :     }
; 572  :     //q = GetAlignedPointer( src, sizestr );
; 573  :     //j = GetLiteralValue( q, tokenarray[i].string_ptr );
; 574  :     q = tokenarray[i].string_ptr;

	mov	r10, QWORD PTR [rdx+8]

; 575  :     j = tokenarray[i].stringlen;
; 576  :     DebugMsg1(("InStrDir: second string >%s< \n", q ));
; 577  :     i++;

	inc	ecx
	mov	r8d, DWORD PTR [rdx+16]

; 578  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, ecx
	shl	rdx, 5
	mov	DWORD PTR i$[rsp], ecx
	cmp	BYTE PTR [rdx+rbx], 0
	je	SHORT $LN15@InStrDir

; 579  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rbx+8]
	mov	ecx, 209				; 000000d1H
	jmp	SHORT $LN20@InStrDir
$LN15@InStrDir:
	mov	QWORD PTR [rsp+192], rdi

; 580  :     }
; 581  : 
; 582  :     strpos = 0;

	xor	edi, edi

; 583  :     /* v2.05: check for start > 0 added */
; 584  :     /* v2.08: check for j > 0 added */
; 585  :     if ( ( start > 0 ) && ( sizestr >= j ) && j && ( string1 = strstr( p, q ) ))

	test	esi, esi
	jle	SHORT $LN16@InStrDir
	cmp	r9d, r8d
	jl	SHORT $LN16@InStrDir
	test	r8d, r8d
	je	SHORT $LN16@InStrDir
	movsxd	rcx, esi
	mov	rdx, r10
	dec	rcx
	add	rcx, rbp
	call	strstr
	test	rax, rax
	je	SHORT $LN16@InStrDir

; 586  :         strpos = string1 - src + 1;

	mov	edi, eax
	sub	edi, ebp
	inc	edi
$LN16@InStrDir:

; 587  : 
; 588  :     if ( sym = CreateVariable( tokenarray[0].string_ptr, strpos ) ) {

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, edi
	call	CreateVariable
	mov	rdi, QWORD PTR [rsp+192]
	test	rax, rax
	je	SHORT $LN17@InStrDir

; 589  :         DebugMsg1(("InStrDir(%s) exit, value=%u\n", tokenarray[0].string_ptr, strpos));
; 590  :         LstWrite( LSTTYPE_EQUATE, 0, sym );

	xor	edx, edx
	mov	r8, rax
	lea	ecx, QWORD PTR [rdx+2]
	call	LstWrite

; 591  :         return ( NOT_ERROR );

	xor	eax, eax
	jmp	$LN19@InStrDir
$LN17@InStrDir:

; 592  :     }
; 593  :     return( ERROR );

	or	eax, -1
	jmp	$LN19@InStrDir
$LN14@InStrDir:

; 570  :         return( TextItemError( &tokenarray[i] ) );

	mov	rcx, rdx
	call	TextItemError
	jmp	$LN19@InStrDir
$LN10@InStrDir:

; 545  :         return( TextItemError( &tokenarray[i] ) );

	mov	rcx, r8
	call	TextItemError

; 594  : }

	mov	rbx, QWORD PTR [rsp+200]
	add	rsp, 160				; 000000a0H
	pop	rsi
	ret	0
InStrDir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
SizeStrDir PROC

; 454  : {

$LN9:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 455  :     struct asym *sym;
; 456  :     int sizestr;
; 457  : 
; 458  :     DebugMsg1(("SizeStrDir entry\n"));
; 459  :     DebugCmd( sizstrcnt++ );
; 460  : 
; 461  :     if ( i != 1 ) {

	cmp	ecx, 1
	je	SHORT $LN2@SizeStrDir

; 462  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rax+8]

; 486  : 
; 487  : }

	add	rsp, 40					; 00000028H

; 462  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jmp	EmitErr
$LN2@SizeStrDir:

; 463  :     }
; 464  : #if 0 /* this is checked in ParseLine() */
; 465  :     if ( tokenarray[0].token != T_ID ) {
; 466  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );
; 467  :     }
; 468  : #endif
; 469  :     if ( tokenarray[2].token != T_STRING || tokenarray[2].string_delim != '<' ) {

	cmp	BYTE PTR [rdx+64], 9
	lea	rcx, QWORD PTR [rdx+64]
	jne	SHORT $LN4@SizeStrDir
	cmp	BYTE PTR [rdx+65], 60			; 0000003cH
	jne	SHORT $LN4@SizeStrDir

; 471  :     }
; 472  :     if ( Token_Count > 3 ) {

	cmp	DWORD PTR ModuleInfo+496, 3
	jle	SHORT $LN5@SizeStrDir

; 473  :         DebugMsg(("SizeStrDir: syntax error, name=%s, Token_Count=%u\n", tokenarray[0].string_ptr, Token_Count));
; 474  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[3].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+104]
	mov	ecx, 209				; 000000d1H

; 486  : 
; 487  : }

	add	rsp, 40					; 00000028H

; 473  :         DebugMsg(("SizeStrDir: syntax error, name=%s, Token_Count=%u\n", tokenarray[0].string_ptr, Token_Count));
; 474  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[3].string_ptr ) );

	jmp	EmitErr
$LN5@SizeStrDir:

; 475  :     }
; 476  : 
; 477  :     //sizestr = GetLiteralValue( StringBufferEnd, tokenarray[2].string_ptr );
; 478  :     sizestr = tokenarray[2].stringlen;
; 479  : 
; 480  :     if ( sym = CreateVariable( tokenarray[0].string_ptr, sizestr ) ) {

	mov	edx, DWORD PTR [rdx+80]
	mov	rcx, QWORD PTR [rax+8]
	call	CreateVariable
	test	rax, rax
	je	SHORT $LN6@SizeStrDir

; 481  :         DebugMsg1(("SizeStrDir(%s) exit, value=%u\n", tokenarray[0].string_ptr, sizestr));
; 482  :         LstWrite( LSTTYPE_EQUATE, 0, sym );

	xor	edx, edx
	mov	r8, rax
	lea	ecx, QWORD PTR [rdx+2]
	call	LstWrite

; 483  :         return( NOT_ERROR );

	xor	eax, eax

; 486  : 
; 487  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@SizeStrDir:

; 484  :     }
; 485  :     return( ERROR );

	or	eax, -1

; 486  : 
; 487  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@SizeStrDir:
	add	rsp, 40					; 00000028H

; 470  :         return( TextItemError( &tokenarray[2] ) );

	jmp	TextItemError
SizeStrDir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
opndx$ = 48
i$ = 192
tokenarray$ = 200
SubStrDir PROC

; 276  : {

$LN31:
	mov	rax, rsp
	push	rsi
	push	r14
	sub	rsp, 168				; 000000a8H

; 277  :     struct asym         *sym;
; 278  :     char                *name;
; 279  :     char                *p;
; 280  :     //char                *newvalue;
; 281  :     int                 pos;
; 282  :     int                 size;
; 283  :     int                 cnt;
; 284  :     bool                chksize;
; 285  :     struct expr         opndx;
; 286  : 
; 287  :     DebugMsg1(("SubStrDir enter\n"));
; 288  :     DebugCmd( substrcnt++ );
; 289  : 
; 290  :     /* at least 5 items are needed
; 291  :      * 0  1      2      3 4    5   6
; 292  :      * ID SUBSTR SRC_ID , POS [, LENGTH]
; 293  :      */
; 294  : #if 0 /* can't happen */
; 295  :     if ( i != 1 ) {
; 296  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );
; 297  :     }
; 298  :     if ( tokenarray[0].token != T_ID ) {
; 299  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );
; 300  :     }
; 301  : #endif
; 302  :     name = tokenarray[0].string_ptr;

	mov	r14, QWORD PTR [rdx+8]

; 303  : 
; 304  :     i++; /* go past SUBSTR */

	inc	ecx

; 305  : 
; 306  :     /* third item must be a string */
; 307  : 
; 308  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	r8, ecx
	mov	rsi, rdx
	shl	r8, 5
	add	r8, rdx
	mov	DWORD PTR [rax+8], ecx
	cmp	BYTE PTR [r8], 9
	jne	$LN3@SubStrDir
	cmp	BYTE PTR [r8+1], 60			; 0000003cH
	jne	$LN3@SubStrDir

; 311  :     }
; 312  :     p = tokenarray[i].string_ptr;
; 313  :     cnt = tokenarray[i].stringlen;
; 314  : 
; 315  :     i++;

	inc	ecx
	mov	QWORD PTR [rax+24], rbp
	mov	ebp, DWORD PTR [r8+16]

; 316  :     DebugMsg1(("SubStrDir(%s): src=>%s<\n", name, p));
; 317  : 
; 318  :     if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rdx, ecx
	shl	rdx, 5
	mov	QWORD PTR [rax-24], r15
	mov	r15, QWORD PTR [r8+8]
	mov	DWORD PTR [rax+8], ecx
	cmp	BYTE PTR [rdx+rsi], 44			; 0000002cH
	je	SHORT $LN4@SubStrDir

; 319  :         return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rsi+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	$LN26@SubStrDir
$LN4@SubStrDir:

; 320  :     }
; 321  :     i++;
; 322  : 
; 323  :     /* get pos, must be a numeric value and > 0 */
; 324  :     /* v2.11: flag NOUNDEF added - no forward ref possible */
; 325  : 
; 326  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	inc	ecx
	mov	QWORD PTR [rsp+200], rbx
	mov	DWORD PTR i$[rsp], ecx
	mov	rdx, rsi
	lea	rcx, QWORD PTR i$[rsp]
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN5@SubStrDir

; 327  :         DebugMsg(("SubStrDir(%s): invalid pos value\n", name));
; 328  :         return( ERROR );

	or	eax, eax
	jmp	SHORT $LN27@SubStrDir
$LN5@SubStrDir:

; 329  :     }
; 330  : 
; 331  :     /* v2.04: "string" constant allowed as second argument */
; 332  :     //if ( opndx.kind != EXPR_CONST || opndx.string != NULL ) {
; 333  :     if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN6@SubStrDir

; 334  :         DebugMsg(("SubStrDir(%s): pos value is not a constant\n", name));
; 335  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	SHORT $LN27@SubStrDir
$LN6@SubStrDir:
	mov	QWORD PTR [rsp+216], rdi

; 336  :     }
; 337  : 
; 338  :     /* pos is expected to be 1-based */
; 339  :     pos = opndx.value;

	mov	edi, DWORD PTR opndx$[rsp]

; 340  :     if ( pos <= 0 ) {

	test	edi, edi
	jg	SHORT $LN7@SubStrDir

; 341  :         return( EmitError( POSITIVE_VALUE_EXPECTED ) );

	mov	ecx, 175				; 000000afH
	call	EmitError
	jmp	SHORT $LN28@SubStrDir
$LN7@SubStrDir:

; 342  :     }
; 343  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rax, rcx
	shl	rax, 5
	lea	rdx, QWORD PTR [rax+rsi]
	movzx	eax, BYTE PTR [rax+rsi]
	test	al, al
	je	$LN8@SubStrDir

; 344  :         if ( tokenarray[i].token != T_COMMA ) {

	cmp	al, 44					; 0000002cH
	je	SHORT $LN10@SubStrDir

; 345  :             return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+24]
	mov	ecx, 39					; 00000027H
$LN29@SubStrDir:

; 362  :             DebugMsg(("SubStrDir(%s): additional items found\n", name));
; 363  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	call	EmitErr
$LN28@SubStrDir:
	mov	rdi, QWORD PTR [rsp+216]
$LN27@SubStrDir:
	mov	rbx, QWORD PTR [rsp+200]
$LN26@SubStrDir:
	mov	rbp, QWORD PTR [rsp+208]
	mov	r15, QWORD PTR [rsp+160]

; 447  : }

	add	rsp, 168				; 000000a8H
	pop	r14
	pop	rsi
	ret	0
$LN10@SubStrDir:

; 346  :         }
; 347  :         i++;
; 348  :         /* get size, must be a constant */
; 349  :         /* v2.11: flag NOUNDEF added - no forward ref possible */
; 350  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	inc	ecx
	mov	BYTE PTR [rsp+32], 2
	mov	DWORD PTR i$[rsp], ecx
	mov	rdx, rsi
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN11@SubStrDir

; 351  :             DebugMsg(("SubStrDir(%s): invalid size value\n", name));
; 352  :             return( ERROR );

	or	eax, eax
	jmp	SHORT $LN28@SubStrDir
$LN11@SubStrDir:

; 353  :         }
; 354  :         /* v2.04: string constant ok */
; 355  :         //if ( opndx.kind != EXPR_CONST || opndx.string != NULL ) {
; 356  :         if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN12@SubStrDir

; 357  :             DebugMsg(("SubStrDir(%s): size value is not a constant\n", name));
; 358  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	SHORT $LN28@SubStrDir
$LN12@SubStrDir:

; 359  :         }
; 360  :         size = opndx.value;
; 361  :         if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	mov	ebx, DWORD PTR opndx$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 0
	je	SHORT $LN13@SubStrDir

; 362  :             DebugMsg(("SubStrDir(%s): additional items found\n", name));
; 363  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rax+rsi+8]
	mov	ecx, 209				; 000000d1H
	jmp	$LN29@SubStrDir
$LN13@SubStrDir:

; 364  :         }
; 365  :         if ( size < 0 ) {

	test	ebx, ebx
	jns	SHORT $LN14@SubStrDir

; 366  :             return( EmitError( COUNT_MUST_BE_POSITIVE_OR_ZERO ) );

	mov	ecx, 208				; 000000d0H
	call	EmitError
	jmp	$LN28@SubStrDir
$LN14@SubStrDir:

; 367  :         }
; 368  :         chksize = TRUE;

	mov	al, 1

; 369  :     } else {

	jmp	SHORT $LN9@SubStrDir
$LN8@SubStrDir:

; 370  :         size = -1;

	or	ebx, -1

; 371  :         chksize = FALSE;

	xor	al, al
$LN9@SubStrDir:

; 372  :     }
; 373  : #if 0
; 374  :     cnt = pos;
; 375  :     /* position p to start of substring */
; 376  :     for ( pos--; pos > 0 && *p ; pos--, p++ )
; 377  :         if ( *p == '!' && *(p+1) != NULLC )
; 378  :             p++;
; 379  :     if ( *p == NULLC ) {
; 380  :         return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, cnt ) );
; 381  :     }
; 382  :     if ( *p == '!' && *(p+1) != NULLC )
; 383  :         p++;
; 384  :     for ( newvalue = p, cnt = size; *p && cnt; cnt--, p++ )
; 385  :         if ( *p == '!' && *(p+1) != NULLC )
; 386  :             p++;
; 387  :     /* v2.04: check added */
; 388  :     if ( chksize && cnt ) {
; 389  :         return( EmitError( COUNT_VALUE_TOO_LARGE ) );
; 390  :     }
; 391  :     size = p - newvalue;
; 392  :     p = newvalue;
; 393  : #else
; 394  :     if ( pos > cnt ) {

	cmp	edi, ebp
	jle	SHORT $LN15@SubStrDir

; 395  :         return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, pos ) );

	mov	edx, edi
	mov	ecx, 206				; 000000ceH
	call	EmitErr
	jmp	$LN28@SubStrDir
$LN15@SubStrDir:

; 396  :     }
; 397  :     if ( chksize && (pos+size-1) > cnt )  {

	test	al, al
	je	SHORT $LN16@SubStrDir
	lea	eax, DWORD PTR [rdi-1]
	add	eax, ebx
	cmp	eax, ebp
	jle	SHORT $LN16@SubStrDir

; 398  :         return( EmitError( COUNT_VALUE_TOO_LARGE ) );

	mov	ecx, 207				; 000000cfH
	call	EmitError
	jmp	$LN28@SubStrDir
$LN16@SubStrDir:

; 399  :     }
; 400  :     p += pos - 1;

	lea	eax, DWORD PTR [rdi-1]
	movsxd	rcx, eax
	add	r15, rcx

; 401  :     if ( size == -1 )

	cmp	ebx, -1
	jne	SHORT $LN17@SubStrDir

; 402  :         size = cnt - pos + 1;

	mov	ebx, ebp
	sub	ebx, edi
	inc	ebx
$LN17@SubStrDir:

; 403  : #endif
; 404  : 
; 405  :     sym = SymSearch( name );

	mov	rcx, r14
	call	SymFind
	mov	rdi, rax

; 406  : 
; 407  :     /* if we've never seen it before, put it in */
; 408  :     if( sym == NULL ) {

	test	rax, rax
	jne	SHORT $LN18@SubStrDir

; 409  :         sym = SymCreate( name );

	mov	rcx, r14
	call	SymCreate
	mov	rdi, rax
$LN22@SubStrDir:

; 424  :     }
; 425  : 
; 426  :     sym->state = SYM_TMACRO;
; 427  :     sym->isdefined = TRUE;

	or	BYTE PTR [rdi+40], 2

; 428  : 
; 429  : #if FASTMEM==0
; 430  :     if ( sym->string_ptr )
; 431  :         LclFree( sym->string_ptr );
; 432  :     sym->string_ptr = (char *)LclAlloc( size + 1 );
; 433  : #else
; 434  :     if ( sym->total_size < ( size + 1 ) ) {

	lea	esi, DWORD PTR [rbx+1]
	mov	DWORD PTR [rdi+32], 10
	cmp	DWORD PTR [rdi+56], esi
	jae	SHORT $LN23@SubStrDir

; 435  :         LclFree( sym->string_ptr );
; 436  :         sym->string_ptr = LclAlloc ( size + 1 );

	movsxd	rcx, esi
	call	LclAlloc
	mov	QWORD PTR [rdi+16], rax

; 437  :         sym->total_size = size + 1;

	mov	DWORD PTR [rdi+56], esi
$LN23@SubStrDir:

; 438  :     }
; 439  : #endif
; 440  :     memcpy( sym->string_ptr, p, size );

	mov	rcx, QWORD PTR [rdi+16]
	mov	rdx, r15
	movsxd	rbx, ebx
	mov	r8, rbx
	call	memcpy

; 441  :     *(sym->string_ptr + size) = NULLC;

	mov	rax, QWORD PTR [rdi+16]

; 442  :     DebugMsg1(("SubStrDir(%s): result=>%s<\n", sym->name, sym->string_ptr ));
; 443  : 
; 444  :     LstWrite( LSTTYPE_TMACRO, 0, sym );

	xor	edx, edx
	mov	r8, rdi
	lea	ecx, QWORD PTR [rdx+3]
	mov	BYTE PTR [rbx+rax], 0
	call	LstWrite

; 445  : 
; 446  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN28@SubStrDir
$LN18@SubStrDir:

; 410  :     } else if( sym->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [rax+32]
	test	eax, eax
	jne	SHORT $LN20@SubStrDir

; 411  :         /* it was referenced before being defined. This is
; 412  :          * a bad idea for preprocessor text items, because it
; 413  :          * will require a full second pass!
; 414  :          */
; 415  :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	rdx, rdi
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table

; 416  : #if FASTPASS
; 417  :         SkipSavedState();

	call	SkipSavedState

; 418  :         EmitWarn( 2, TEXT_MACRO_USED_PRIOR_TO_DEFINITION, sym->name );

	mov	r8, QWORD PTR [rdi+8]
	mov	edx, 236				; 000000ecH
	mov	ecx, 2
	call	EmitWarn
	jmp	SHORT $LN22@SubStrDir
$LN20@SubStrDir:

; 419  : #endif
; 420  :     } else if( sym->state != SYM_TMACRO ) {

	cmp	eax, 10
	je	$LN22@SubStrDir

; 421  :         /* it is defined as something incompatible, get out */
; 422  :         DebugMsg(( "SubStrDir(%s) error, incompatible type\n", sym->name));
; 423  :         return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rdi+8]
	mov	ecx, 143				; 0000008fH
	jmp	$LN29@SubStrDir
$LN3@SubStrDir:

; 309  :         DebugMsg(("SubStrDir: error, no text item\n"));
; 310  :         return( TextItemError( &tokenarray[i] ) );

	mov	rcx, r8
	call	TextItemError

; 447  : }

	add	rsp, 168				; 000000a8H
	pop	r14
	pop	rsi
	ret	0
SubStrDir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
CatStrDir PROC

; 75   : {

$LN42:
	mov	QWORD PTR [rsp+32], rbx
	push	r14
	sub	rsp, 32					; 00000020H

; 94   : 
; 95   :     /* v2.08: don't copy to temp buffer */
; 96   :     //*StringBufferEnd = NULLC;
; 97   :     /* check correct syntax and length of items */
; 98   :     for ( count = 0; i < Token_Count; ) {

	mov	r9d, DWORD PTR ModuleInfo+496
	inc	ecx
	xor	ebx, ebx
	mov	r14, rdx
	cmp	ecx, r9d
	jge	SHORT $LN3@CatStrDir

; 76   :     struct asym *sym;
; 77   :     int count;
; 78   :     char *p;
; 79   :     /* struct expr opndx; */
; 80   : 
; 81   :     DebugMsg1(("CatStrDir(%u) enter\n", i ));
; 82   :     DebugCmd( catstrcnt++ );
; 83   : 
; 84   : #if 0 /* can't happen */
; 85   :     /* syntax must be <id> CATSTR textitem[,textitem,...] */
; 86   :     if ( i != 1 ) {
; 87   :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );
; 88   :     }
; 89   :     if ( tokenarray[0].token != T_ID ) {
; 90   :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );
; 91   :     }
; 92   : #endif
; 93   :     i++; /* go past CATSTR/TEXTEQU */

	movsxd	r8, ecx
	shl	r8, 5
	add	r8, rdx
	npad	8
$LL2@CatStrDir:

; 99   :         DebugMsg1(("CatStrDir(%s): item[%u]=%s delim=0x%x\n", tokenarray[0].string_ptr, i, tokenarray[i].string_ptr, tokenarray[i].string_delim ));
; 100  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	cmp	BYTE PTR [r8], 9
	jne	$LN9@CatStrDir
	cmp	BYTE PTR [r8+1], 60			; 0000003cH
	jne	$LN9@CatStrDir

; 103  :         }
; 104  :         /* v2.08: using tokenarray.stringlen is not quite correct, since some chars
; 105  :          * are stored in 2 bytes (!) */
; 106  :         if ( ( count + tokenarray[i].stringlen ) >= MAX_LINE_LEN ) {

	mov	eax, DWORD PTR [r8+16]
	add	ebx, eax
	cmp	ebx, 1024				; 00000400H
	jae	$LN29@CatStrDir

; 109  :         }
; 110  :         /* v2.08: don't copy to temp buffer */
; 111  :         //strcpy( StringBufferEnd + count, tokenarray[i].string_ptr );
; 112  :         count = count + tokenarray[i].stringlen;
; 113  :         i++;

	movzx	eax, BYTE PTR [r8+32]
	inc	ecx

; 114  :         if ( ( tokenarray[i].token != T_COMMA ) &&

	cmp	al, 44					; 0000002cH
	je	SHORT $LN11@CatStrDir
	test	al, al
	jne	$LN30@CatStrDir
$LN11@CatStrDir:

; 117  :         }
; 118  :         i++;

	inc	ecx
	add	r8, 64					; 00000040H
	cmp	ecx, r9d
	jl	SHORT $LL2@CatStrDir
$LN3@CatStrDir:

; 119  :     }
; 120  : 
; 121  :     sym = SymSearch( tokenarray[0].string_ptr );

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+64], rdi
	call	SymFind
	mov	rdi, rax

; 122  :     if ( sym == NULL ) {

	mov	ebp, 2
	test	rax, rax
	jne	$LN12@CatStrDir

; 123  :         sym = SymCreate( tokenarray[0].string_ptr );

	mov	rcx, QWORD PTR [r14+8]
	call	SymCreate
	mov	rdi, rax
$LN16@CatStrDir:

; 139  :     }
; 140  : 
; 141  : 
; 142  :     sym->state = SYM_TMACRO;
; 143  :     sym->isdefined = TRUE;

	or	BYTE PTR [rdi+40], bpl

; 144  : #if FASTMEM==0
; 145  :     if ( sym->string_ptr )
; 146  :         LclFree( sym->string_ptr );
; 147  :     sym->string_ptr = (char *)LclAlloc( count + 1 );
; 148  : #else
; 149  :     /* v2.08: reuse string space if fastmem is on */
; 150  :     if ( sym->total_size < ( count+1 ) ) {

	inc	ebx
	mov	QWORD PTR [rsp+56], rsi
	mov	DWORD PTR [rdi+32], 10
	cmp	DWORD PTR [rdi+56], ebx
	jae	SHORT $LN17@CatStrDir

; 151  :         LclFree( sym->string_ptr ); /* is a noop if fastmem is on */
; 152  :         sym->string_ptr = (char *)LclAlloc( count + 1 );

	movsxd	rcx, ebx
	call	LclAlloc
	mov	QWORD PTR [rdi+16], rax

; 153  :         sym->total_size = count + 1;

	mov	DWORD PTR [rdi+56], ebx
$LN17@CatStrDir:

; 154  :     }
; 155  : #endif
; 156  :     /* v2.08: don't use temp buffer */
; 157  :     //memcpy( sym->string_ptr, StringBufferEnd, count + 1 );
; 158  :     for ( i = 2, p = sym->string_ptr; i < Token_Count; i += 2 ) {

	cmp	DWORD PTR ModuleInfo+496, ebp
	mov	rsi, QWORD PTR [rdi+16]
	jle	SHORT $LN6@CatStrDir
	lea	rbx, QWORD PTR [r14+80]
	npad	5
$LL7@CatStrDir:

; 159  :         memcpy( p, tokenarray[i].string_ptr, tokenarray[i].stringlen );

	mov	r8d, DWORD PTR [rbx]
	mov	rcx, rsi
	mov	rdx, QWORD PTR [rbx-8]
	call	memcpy

; 160  :         p += tokenarray[i].stringlen;

	mov	eax, DWORD PTR [rbx]
	lea	rbx, QWORD PTR [rbx+64]
	add	rsi, rax
	add	ebp, 2
	cmp	ebp, DWORD PTR ModuleInfo+496
	jl	SHORT $LL7@CatStrDir
$LN6@CatStrDir:

; 161  :     }
; 162  :     *p = NULLC;

	mov	BYTE PTR [rsi], 0

; 163  :     DebugMsg1(("CatStrDir(%s) (new) value: >%s<\n", sym->name, sym->string_ptr ));
; 164  : 
; 165  :     if ( ModuleInfo.list )

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	mov	rsi, QWORD PTR [rsp+56]
	je	SHORT $LN18@CatStrDir

; 166  :         LstWrite( LSTTYPE_TMACRO, 0, sym );

	xor	edx, edx
	mov	r8, rdi
	lea	ecx, QWORD PTR [rdx+3]
	call	LstWrite
$LN18@CatStrDir:

; 167  : 
; 168  :     return( NOT_ERROR );

	xor	eax, eax
$LN39@CatStrDir:
	mov	rbp, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+64]

; 169  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN30@CatStrDir:

; 115  :             ( tokenarray[i].token != T_FINAL ) ) {
; 116  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r14+8]

; 169  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14

; 115  :             ( tokenarray[i].token != T_FINAL ) ) {
; 116  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jmp	EmitErr
$LN29@CatStrDir:

; 107  :             DebugMsg(("CatStrDir: error, literal too long: %u + %u >= %u\n", count, tokenarray[i].stringlen, MAX_LINE_LEN ));
; 108  :             return( EmitError( STRING_OR_TEXT_LITERAL_TOO_LONG ) );

	mov	ecx, 155				; 0000009bH

; 169  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14

; 107  :             DebugMsg(("CatStrDir: error, literal too long: %u + %u >= %u\n", count, tokenarray[i].stringlen, MAX_LINE_LEN ));
; 108  :             return( EmitError( STRING_OR_TEXT_LITERAL_TOO_LONG ) );

	jmp	EmitError
$LN9@CatStrDir:

; 101  :             DebugMsg(("CatStrDir: error, not a <>-literal: %s\n", tokenarray[i].tokpos ));
; 102  :             return( TextItemError( &tokenarray[i] ) );

	movsxd	rbx, ecx
	shl	rbx, 5
	add	rbx, rdx
	movzx	ecx, BYTE PTR [rbx]
	cmp	cl, 9
	jne	SHORT $LN21@CatStrDir
	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax], 60			; 0000003cH
	jne	SHORT $LN21@CatStrDir
	mov	ecx, 216				; 000000d8H

; 169  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14

; 101  :             DebugMsg(("CatStrDir: error, not a <>-literal: %s\n", tokenarray[i].tokpos ));
; 102  :             return( TextItemError( &tokenarray[i] ) );

	jmp	EmitError
$LN21@CatStrDir:
	cmp	cl, 8
	jne	SHORT $LN23@CatStrDir
	mov	rcx, QWORD PTR [rbx+8]
	call	SymFind
	test	rax, rax
	je	SHORT $LN24@CatStrDir
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN23@CatStrDir
$LN24@CatStrDir:
	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 102				; 00000066H

; 169  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14

; 101  :             DebugMsg(("CatStrDir: error, not a <>-literal: %s\n", tokenarray[i].tokpos ));
; 102  :             return( TextItemError( &tokenarray[i] ) );

	jmp	EmitErr
$LN23@CatStrDir:
	mov	ecx, 144				; 00000090H

; 169  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14

; 101  :             DebugMsg(("CatStrDir: error, not a <>-literal: %s\n", tokenarray[i].tokpos ));
; 102  :             return( TextItemError( &tokenarray[i] ) );

	jmp	EmitError
$LN12@CatStrDir:

; 124  :         DebugMsg1(( "CatStrDir: new symbol %s created\n", sym->name));
; 125  :     } else if( sym->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [rax+32]
	test	eax, eax
	jne	SHORT $LN14@CatStrDir

; 126  :         /* v2.01: symbol has been used already. Using
; 127  :          * a textmacro before it has been defined is
; 128  :          * somewhat problematic.
; 129  :          */
; 130  :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	rdx, rdi
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table

; 131  : #if FASTPASS
; 132  :         SkipSavedState(); /* further passes must be FULL! */

	call	SkipSavedState

; 133  : #endif
; 134  :         EmitWarn( 2, TEXT_MACRO_USED_PRIOR_TO_DEFINITION, sym->name );

	mov	r8, QWORD PTR [rdi+8]
	mov	edx, 236				; 000000ecH
	mov	ecx, ebp
	call	EmitWarn
	jmp	$LN16@CatStrDir
$LN14@CatStrDir:

; 135  :     } else if( sym->state != SYM_TMACRO ) {

	cmp	eax, 10
	je	$LN16@CatStrDir

; 136  :         /* it is defined as something else, get out */
; 137  :         DebugMsg(( "CatStrDir(%s) exit, symbol redefinition\n", sym->name));
; 138  :         return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rdi+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN39@CatStrDir
CatStrDir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
StringInit PROC

; 779  : {

$LN24:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 780  :     int i;
; 781  :     struct dsym *macro;
; 782  : 
; 783  :     DebugMsg(( "StringInit() enter\n" ));
; 784  : 
; 785  : #ifdef DEBUG_OUT
; 786  :     catstrcnt = 0;
; 787  :     substrcnt = 0;
; 788  :     sizstrcnt = 0;
; 789  :     instrcnt = 0;
; 790  :     equcnt = 0;
; 791  : #endif
; 792  : 
; 793  :     /* add @CatStr() macro func */
; 794  : 
; 795  :     macro = CreateMacro( "@CatStr" );

	lea	rcx, OFFSET FLAT:$SG11212
	call	CreateMacro
	mov	rbx, rax

; 796  :     macro->sym.isdefined = TRUE;
; 797  :     macro->sym.predefined = TRUE;
; 798  :     macro->sym.func_ptr = CatStrFunc;
; 799  :     macro->sym.isfunc = TRUE;
; 800  :     /* v2.08: @CatStr() changed to VARARG */
; 801  :     macro->sym.mac_vararg = TRUE;
; 802  :     macro->e.macroinfo->parmcnt = 1;

	mov	esi, 1
	or	BYTE PTR [rax+40], 34			; 00000022H
	lea	rax, OFFSET FLAT:CatStrFunc
	mov	rcx, QWORD PTR [rbx+96]
	or	BYTE PTR [rbx+44], 3
	mov	QWORD PTR [rbx+16], rax
	mov	WORD PTR [rcx], si

; 803  :     macro->e.macroinfo->parmlist = LclAlloc( sizeof( struct mparm_list ) * 1 );

	lea	ecx, QWORD PTR [rsi+15]
	call	LclAlloc
	mov	rcx, QWORD PTR [rbx+96]

; 804  :     macro->e.macroinfo->parmlist[0].deflt = NULL;

	xor	ebp, ebp
	mov	QWORD PTR [rcx+8], rax
	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rbp

; 805  :     macro->e.macroinfo->parmlist[0].required = FALSE;

	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+8]
	and	BYTE PTR [rcx+8], 254			; 000000feH

; 806  : 
; 807  :     /* add @InStr() macro func */
; 808  : 
; 809  :     macro = CreateMacro( "@InStr" );

	lea	rcx, OFFSET FLAT:$SG11213
	call	CreateMacro
	mov	rbx, rax

; 810  :     macro->sym.isdefined = TRUE;
; 811  :     macro->sym.predefined = TRUE;
; 812  :     macro->sym.func_ptr = InStrFunc;
; 813  :     macro->sym.isfunc = TRUE;
; 814  :     macro->e.macroinfo->parmcnt = 3;

	mov	edi, 3
	or	BYTE PTR [rax+40], 34			; 00000022H
	lea	rax, OFFSET FLAT:InStrFunc
	mov	rcx, QWORD PTR [rbx+96]
	or	BYTE PTR [rbx+44], 2
	mov	QWORD PTR [rbx+16], rax
	mov	WORD PTR [rcx], di

; 815  :     macro->e.macroinfo->autoexp = 1; /* param 1 (pos) is expanded */

	mov	rcx, QWORD PTR [rbx+96]
	mov	WORD PTR [rcx+2], si

; 816  :     macro->e.macroinfo->parmlist = LclAlloc(sizeof( struct mparm_list) * 3);

	lea	ecx, QWORD PTR [rsi+47]
	call	LclAlloc
	mov	rcx, QWORD PTR [rbx+96]
	mov	QWORD PTR [rcx+8], rax

; 817  :     for (i = 0; i < 3; i++) {
; 818  :         macro->e.macroinfo->parmlist[i].deflt = NULL;

	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rbp

; 819  :         //macro->e.macroinfo->parmlist[i].label = parmnames[i];
; 820  :         macro->e.macroinfo->parmlist[i].required = (i != 0);

	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+8]
	and	BYTE PTR [rcx+8], 254			; 000000feH
	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+16], rbp
	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+8]
	or	BYTE PTR [rcx+24], sil
	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+32], rbp

; 821  :     }
; 822  : 
; 823  :     /* add @SizeStr() macro func */
; 824  : 
; 825  :     macro = CreateMacro( "@SizeStr" );

	lea	rcx, OFFSET FLAT:$SG11214
	mov	rax, QWORD PTR [rbx+96]
	mov	rdx, QWORD PTR [rax+8]
	or	BYTE PTR [rdx+40], sil
	call	CreateMacro
	mov	rbx, rax

; 826  :     macro->sym.isdefined = TRUE;
; 827  :     macro->sym.predefined = TRUE;
; 828  :     macro->sym.func_ptr = SizeStrFunc;
; 829  :     macro->sym.isfunc = TRUE;
; 830  :     macro->e.macroinfo->parmcnt = 1;
; 831  :     macro->e.macroinfo->parmlist = LclAlloc(sizeof( struct mparm_list));

	lea	ecx, QWORD PTR [rsi+15]
	or	BYTE PTR [rax+40], 34			; 00000022H
	lea	rax, OFFSET FLAT:SizeStrFunc
	mov	rdx, QWORD PTR [rbx+96]
	or	BYTE PTR [rbx+44], 2
	mov	QWORD PTR [rbx+16], rax
	mov	WORD PTR [rdx], si
	call	LclAlloc
	mov	rcx, QWORD PTR [rbx+96]
	mov	QWORD PTR [rcx+8], rax

; 832  :     macro->e.macroinfo->parmlist[0].deflt = NULL;

	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rbp

; 833  :     //macro->e.macroinfo->parmlist[0].label = parmnames[0];
; 834  :     /* macro->e.macroinfo->parmlist[0].required = TRUE; */
; 835  :     /* the string parameter is NOT required, '@SizeStr()' is valid */
; 836  :     macro->e.macroinfo->parmlist[0].required = FALSE;

	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+8]
	and	BYTE PTR [rcx+8], 254			; 000000feH

; 837  : 
; 838  :     /* add @SubStr() macro func */
; 839  : 
; 840  :     macro = CreateMacro( "@SubStr" );

	lea	rcx, OFFSET FLAT:$SG11215
	call	CreateMacro
	mov	rbx, rax

; 841  :     macro->sym.isdefined = TRUE;
; 842  :     macro->sym.predefined = TRUE;

	or	BYTE PTR [rax+40], 34			; 00000022H

; 843  :     macro->sym.func_ptr = SubStrFunc;

	lea	rax, OFFSET FLAT:SubStrFunc

; 844  :     macro->sym.isfunc = TRUE;

	or	BYTE PTR [rbx+44], 2
	mov	QWORD PTR [rbx+16], rax

; 845  :     macro->e.macroinfo->parmcnt = 3;

	mov	rdx, QWORD PTR [rbx+96]

; 846  :     macro->e.macroinfo->autoexp = 2 + 4; /* param 2 (pos) and 3 (size) are expanded */
; 847  :     macro->e.macroinfo->parmlist = LclAlloc(sizeof( struct mparm_list) * 3);

	lea	ecx, QWORD PTR [rsi+47]
	mov	eax, 6
	mov	WORD PTR [rdx], di
	mov	rdx, QWORD PTR [rbx+96]
	mov	WORD PTR [rdx+2], ax
	call	LclAlloc
	mov	rcx, QWORD PTR [rbx+96]
	mov	QWORD PTR [rcx+8], rax

; 848  :     for (i = 0; i < 3; i++) {
; 849  :         macro->e.macroinfo->parmlist[i].deflt = NULL;

	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rbp

; 850  :         //macro->e.macroinfo->parmlist[i].label = parmnames[i];
; 851  :         macro->e.macroinfo->parmlist[i].required = (i < 2);

	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+8]
	or	BYTE PTR [rcx+8], sil
	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+16], rbp
	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+8]
	or	BYTE PTR [rcx+24], sil
	mov	rax, QWORD PTR [rbx+96]

; 852  :     }
; 853  : 
; 854  :     return;
; 855  : }

	mov	rsi, QWORD PTR [rsp+64]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+32], rbp
	mov	rax, QWORD PTR [rbx+96]
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rcx, QWORD PTR [rax+8]
	and	BYTE PTR [rcx+40], 254			; 000000feH
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
StringInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
item$ = 48
TextItemError PROC

; 53   : {

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 54   :     if ( item->token == T_STRING && *item->string_ptr == '<' ) {

	movzx	ecx, BYTE PTR [rcx]
	cmp	cl, 9
	jne	SHORT $LN2@TextItemEr
	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax], 60			; 0000003cH
	jne	SHORT $LN2@TextItemEr

; 55   :         return( EmitError( MISSING_ANGLE_BRACKET_OR_BRACE_IN_LITERAL ) );

	mov	ecx, 216				; 000000d8H

; 65   : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 62   :         }
; 63   :     }
; 64   :     return( EmitError( TEXT_ITEM_REQUIRED ) );

	jmp	EmitError
$LN2@TextItemEr:

; 56   :     }
; 57   :     /* v2.05: better error msg if (text) symbol isn't defined */
; 58   :     if ( item->token == T_ID ) {

	cmp	cl, 8
	jne	SHORT $LN4@TextItemEr

; 59   :         struct asym *sym = SymSearch( item->string_ptr );

	mov	rcx, QWORD PTR [rbx+8]
	call	SymFind

; 60   :         if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rax, rax
	je	SHORT $LN5@TextItemEr
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN4@TextItemEr
$LN5@TextItemEr:

; 61   :             return( EmitErr( SYMBOL_NOT_DEFINED, item->string_ptr ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 102				; 00000066H

; 65   : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 61   :             return( EmitErr( SYMBOL_NOT_DEFINED, item->string_ptr ) );

	jmp	EmitErr
$LN4@TextItemEr:

; 62   :         }
; 63   :     }
; 64   :     return( EmitError( TEXT_ITEM_REQUIRED ) );

	mov	ecx, 144				; 00000090H

; 65   : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 62   :         }
; 63   :     }
; 64   :     return( EmitError( TEXT_ITEM_REQUIRED ) );

	jmp	EmitError
TextItemError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
name$ = 48
value$ = 56
AddPredefinedText PROC

; 254  : {

$LN5:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 255  :     struct asym *sym;
; 256  : 
; 257  :     DebugMsg1(("AddPredefinedText(%s): >%s<\n", name, value ));
; 258  :     /* v2.08: ignore previous setting */
; 259  :     if ( NULL == ( sym = SymSearch( name ) ) )

	call	SymFind
	test	rax, rax
	jne	SHORT $LN2@AddPredefi

; 260  :         sym = SymCreate( name );

	mov	rcx, rbx
	call	SymCreate
$LN2@AddPredefi:

; 261  :     sym->state = SYM_TMACRO;
; 262  :     sym->isdefined = TRUE;
; 263  :     sym->predefined = TRUE;

	or	BYTE PTR [rax+40], 34			; 00000022H

; 264  :     sym->string_ptr = (char *)value;
; 265  :     /* to ensure that a new buffer is used if the string is modified */
; 266  :     sym->total_size = 0;
; 267  :     return( sym );
; 268  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rax+32], 10
	mov	QWORD PTR [rax+16], rdi
	mov	DWORD PTR [rax+56], 0
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
AddPredefinedText ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
tokenarray$ = 48
sym$ = 56
name$ = 64
value$ = 72
SetTextMacro PROC

; 179  : {

$LN25:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rbp, r9
	mov	rsi, rdx
	mov	rbx, rcx

; 180  :     int count;
; 181  :     //char *p;
; 182  : 
; 183  :     DebugCmd( equcnt++ );
; 184  : 
; 185  :     if ( sym == NULL )

	test	rdx, rdx
	jne	SHORT $LN5@SetTextMac

; 186  :         sym = SymCreate( name );

	mov	rcx, r8
	call	SymCreate
	mov	rsi, rax
$LN9@SetTextMac:

; 200  :     }
; 201  : 
; 202  :     sym->state = SYM_TMACRO;
; 203  :     sym->isdefined = TRUE;

	or	BYTE PTR [rsi+40], 2
	mov	DWORD PTR [rsi+32], 10

; 204  : 
; 205  :     if ( tokenarray[2].token == T_STRING && tokenarray[2].string_delim == '<' ) {

	cmp	BYTE PTR [rbx+64], 9
	mov	QWORD PTR [rsp+48], rdi
	jne	SHORT $LN10@SetTextMac
	cmp	BYTE PTR [rbx+65], 60			; 0000003cH
	jne	SHORT $LN10@SetTextMac

; 206  : 
; 207  :         /* the simplest case: value is a literal. define a text macro! */
; 208  :         /* just ONE literal is allowed */
; 209  :         if ( tokenarray[3].token != T_FINAL ) {

	cmp	BYTE PTR [rbx+96], 0
	je	SHORT $LN12@SetTextMac

; 210  :             EmitErr( SYNTAX_ERROR_EX, tokenarray[3].tokpos );

	mov	rdx, QWORD PTR [rbx+120]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 211  :             return( NULL );

	xor	eax, eax
	jmp	$LN23@SetTextMac
$LN5@SetTextMac:

; 187  :     else if ( sym->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [rdx+32]
	test	eax, eax
	jne	SHORT $LN7@SetTextMac

; 188  :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table

; 189  : #if FASTPASS
; 190  :         /* the text macro was referenced before being defined.
; 191  :          * this is valid usage, but it requires a full second pass.
; 192  :          * just simply deactivate the fastpass feature for this module!
; 193  :          */
; 194  :         SkipSavedState();

	call	SkipSavedState

; 195  : #endif
; 196  :         EmitWarn( 2, TEXT_MACRO_USED_PRIOR_TO_DEFINITION, sym->name );

	mov	r8, QWORD PTR [rsi+8]
	mov	edx, 236				; 000000ecH
	mov	ecx, 2
	call	EmitWarn
	jmp	SHORT $LN9@SetTextMac
$LN7@SetTextMac:

; 197  :     } else if ( sym->state != SYM_TMACRO ) {

	cmp	eax, 10
	je	SHORT $LN9@SetTextMac

; 198  :         EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, r8
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 199  :         return( NULL );

	xor	eax, eax

; 243  : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN12@SetTextMac:

; 212  :         }
; 213  :         value = tokenarray[2].string_ptr;

	mov	rbp, QWORD PTR [rbx+72]

; 214  :         count = tokenarray[2].stringlen;

	mov	ebx, DWORD PTR [rbx+80]

; 215  :     } else {

	jmp	SHORT $LN22@SetTextMac
$LN10@SetTextMac:

; 216  :         /*
; 217  :          * the original source is used, since the tokenizer has
; 218  :          * deleted some information.
; 219  :          */
; 220  :         //while ( isspace( *value ) ) value++; /* probably obsolete */
; 221  :         count = strlen( value );

	or	rbx, -1
	npad	3
$LL21@SetTextMac:
	inc	rbx
	cmp	BYTE PTR [rbx+rbp], 0
	jne	SHORT $LL21@SetTextMac
	movsxd	rdi, ebx

; 222  :         /* skip trailing spaces */
; 223  :         for ( ; count; count-- )

	test	ebx, ebx
	je	SHORT $LN22@SetTextMac
$LL4@SetTextMac:

; 224  :             if ( isspace( *( value + count - 1 ) ) == FALSE )

	movsx	ecx, BYTE PTR [rdi+rbp-1]
	call	isspace
	test	eax, eax
	je	SHORT $LN22@SetTextMac

; 222  :         /* skip trailing spaces */
; 223  :         for ( ; count; count-- )

	dec	ebx
	sub	rdi, 1
	jne	SHORT $LL4@SetTextMac
$LN22@SetTextMac:

; 225  :                 break;
; 226  :     }
; 227  : #if FASTMEM==0
; 228  :     if ( sym->string_ptr )
; 229  :         LclFree( sym->string_ptr );
; 230  :     sym->string_ptr = (char *)LclAlloc( count + 1 );
; 231  : #else
; 232  :     if ( sym->total_size < ( count + 1 ) ) {

	lea	edi, DWORD PTR [rbx+1]
	cmp	DWORD PTR [rsi+56], edi
	jae	SHORT $LN14@SetTextMac

; 233  :         LclFree( sym->string_ptr ); /* is a noop if fastmem is on */
; 234  :         sym->string_ptr = (char *)LclAlloc( count + 1 );

	movsxd	rcx, edi
	call	LclAlloc
	mov	QWORD PTR [rsi+16], rax

; 235  :         sym->total_size = count + 1;

	mov	DWORD PTR [rsi+56], edi
$LN14@SetTextMac:

; 236  :     }
; 237  : #endif
; 238  :     memcpy( sym->string_ptr, value, count );

	mov	rcx, QWORD PTR [rsi+16]
	mov	rdx, rbp
	movsxd	rbx, ebx
	mov	r8, rbx
	call	memcpy

; 239  :     *(sym->string_ptr + count) = NULLC;

	mov	rax, QWORD PTR [rsi+16]
	mov	BYTE PTR [rbx+rax], 0

; 240  : 
; 241  :     DebugMsg1(( "SetTextMacro(%s): value is >%s<, exit\n", sym->name, sym->string_ptr ));
; 242  :     return( sym );

	mov	rax, rsi
$LN23@SetTextMac:

; 243  : }

	mov	rdi, QWORD PTR [rsp+48]
	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
SetTextMacro ENDP
_TEXT	ENDS
END
