; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	Options
PUBLIC	DefaultDir
_BSS	SEGMENT
$SG11541 DB	01H DUP (?)
	ALIGN	4

$SG11573 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	8

DefaultDir DQ	04H DUP (?)
_BSS	ENDS
CONST	SEGMENT
cmdl_options DQ	FLAT:$SG11347
	DD	00H
	ORG $+4
	DQ	FLAT:Set_h
	DQ	FLAT:$SG11348
	DD	00H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11349
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Cp
	DQ	FLAT:$SG11350
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Cu
	DQ	FLAT:$SG11351
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Cx
	DQ	FLAT:$SG11352
	DD	02H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11353
	DD	00H
	ORG $+4
	DQ	FLAT:Set_c
	DQ	FLAT:$SG11354
	DD	00H
	ORG $+4
	DQ	FLAT:Set_D
	DQ	FLAT:$SG11355
	DD	0303H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11356
	DD	03H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11357
	DD	00H
	ORG $+4
	DQ	FLAT:Set_EP
	DQ	FLAT:$SG11358
	DD	0cH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11359
	DD	00H
	ORG $+4
	DQ	FLAT:Set_e
	DQ	FLAT:$SG11360
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fd
	DQ	FLAT:$SG11361
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fi
	DQ	FLAT:$SG11362
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fl
	DQ	FLAT:$SG11363
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fo
	DQ	FLAT:$SG11364
	DD	00H
	ORG $+4
	DQ	FLAT:Set_FPx
	DQ	FLAT:$SG11365
	DD	01H
	ORG $+4
	DQ	FLAT:Set_FPx
	DQ	FLAT:$SG11366
	DD	02H
	ORG $+4
	DQ	FLAT:Set_fp
	DQ	FLAT:$SG11367
	DD	03H
	ORG $+4
	DQ	FLAT:Set_fp
	DQ	FLAT:$SG11368
	DD	04H
	ORG $+4
	DQ	FLAT:Set_fp
	DQ	FLAT:$SG11369
	DD	01H
	ORG $+4
	DQ	FLAT:Set_fp
	DQ	FLAT:$SG11370
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fw
	DQ	FLAT:$SG11371
	DD	04H
	ORG $+4
	DQ	FLAT:Set_G
	DQ	FLAT:$SG11372
	DD	01H
	ORG $+4
	DQ	FLAT:Set_G
	DQ	FLAT:$SG11373
	DD	07H
	ORG $+4
	DQ	FLAT:Set_G
	DQ	FLAT:$SG11374
	DD	03H
	ORG $+4
	DQ	FLAT:Set_G
	DQ	FLAT:$SG11375
	DD	00H
	ORG $+4
	DQ	FLAT:Set_h
	DQ	FLAT:$SG11376
	DD	00H
	ORG $+4
	DQ	FLAT:Set_I
	DQ	FLAT:$SG11377
	DD	03H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11378
	DD	07H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11379
	DD	06H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11380
	DD	05H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11381
	DD	04H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11382
	DD	02H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11383
	DD	01H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11384
	DD	0100H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11385
	DD	08H
	ORG $+4
	DQ	FLAT:Set_n
	DQ	FLAT:$SG11386
	DD	07H
	ORG $+4
	DQ	FLAT:Set_n
	DQ	FLAT:$SG11387
	DD	05H
	ORG $+4
	DQ	FLAT:Set_n
	DQ	FLAT:$SG11388
	DD	00H
	ORG $+4
	DQ	FLAT:Set_nologo
	DQ	FLAT:$SG11389
	DD	06H
	ORG $+4
	DQ	FLAT:Set_n
	DQ	FLAT:$SG11390
	DD	01H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11391
	DD	0200H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11392
	DD	00H
	ORG $+4
	DQ	FLAT:Set_q
	DQ	FLAT:$SG11393
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Sa
	DQ	FLAT:$SG11394
	DD	089H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11395
	DD	083H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11396
	DD	088H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11397
	DD	082H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11398
	DD	08bH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11399
	DD	00H
	ORG $+4
	DQ	FLAT:Set_WX
	DQ	FLAT:$SG11400
	DD	00H
	ORG $+4
	DQ	FLAT:Set_W
	DQ	FLAT:$SG11401
	DD	0302H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11402
	DD	00H
	ORG $+4
	DQ	FLAT:Set_w
	DQ	FLAT:$SG11403
	DD	08cH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11404
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Zd
	DQ	FLAT:$SG11405
	DD	08aH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11406
	DD	080H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11407
	DD	02H
	ORG $+4
	DQ	FLAT:Set_Zi
	DQ	FLAT:$SG11408
	DD	07eH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11409
	DD	07fH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11410
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Zp
	DQ	FLAT:$SG11411
	DD	00H
	ORG $+4
	DQ	FLAT:Set_zcm
	DQ	FLAT:$SG11412
	DD	075H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11413
	DD	00H
	ORG $+4
	DQ	FLAT:Set_zf
	DQ	FLAT:$SG11414
	DD	01H
	ORG $+4
	DQ	FLAT:Set_zf
	DQ	FLAT:$SG11415
	DD	070H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11416
	DD	071H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11417
	DD	072H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11418
	DD	073H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11419
	DD	074H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11420
	DD	0acH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11421
	DD	01H
	ORG $+4
	DQ	FLAT:Set_zt
	DQ	FLAT:$SG11422
	DD	02H
	ORG $+4
	DQ	FLAT:Set_zt
	DQ	FLAT:$SG11423
	DD	00H
	ORG $+4
	DQ	FLAT:Set_zt
	DQ	FLAT:$SG11424
	DD	081H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11425
	DD	077H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11426
	DD	078H
	ORG $+4
	DQ	FLAT:Set_True
CONST	ENDS
_DATA	SEGMENT
$SG11283 DB	'W', 00H
	ORG $+2
$SG11347 DB	'?', 00H
	ORG $+2
$SG11348 DB	'bin', 00H
$SG11349 DB	'Cp', 00H
	ORG $+1
$SG11350 DB	'Cu', 00H
	ORG $+1
$SG11351 DB	'Cx', 00H
	ORG $+1
$SG11352 DB	'coff', 00H
	ORG $+3
$SG11353 DB	'c', 00H
	ORG $+2
$SG11354 DB	'D^$', 00H
$SG11355 DB	'elf64', 00H
	ORG $+2
$SG11356 DB	'elf', 00H
$SG11357 DB	'EP', 00H
	ORG $+1
$SG11358 DB	'eq', 00H
	ORG $+1
$SG11359 DB	'e=#', 00H
$SG11360 DB	'Fd=@', 00H
	ORG $+3
$SG11361 DB	'Fi=^@', 00H
	ORG $+2
$SG11362 DB	'Fl=@', 00H
	ORG $+3
$SG11363 DB	'Fo=^@', 00H
	ORG $+2
$SG11364 DB	'FPi87', 00H
	ORG $+2
$SG11365 DB	'FPi', 00H
$SG11366 DB	'fp0', 00H
$SG11367 DB	'fp2', 00H
$SG11368 DB	'fp3', 00H
$SG11369 DB	'fpc', 00H
$SG11370 DB	'Fw=^@', 00H
	ORG $+2
$SG11371 DB	'Gc', 00H
	ORG $+1
$SG11372 DB	'Gd', 00H
	ORG $+1
$SG11373 DB	'Gr', 00H
	ORG $+1
$SG11374 DB	'Gz', 00H
	ORG $+1
$SG11375 DB	'h', 00H
	ORG $+2
$SG11376 DB	'I=^@', 00H
	ORG $+3
$SG11377 DB	'mc', 00H
	ORG $+1
$SG11378 DB	'mf', 00H
	ORG $+1
$SG11379 DB	'mh', 00H
	ORG $+1
$SG11380 DB	'ml', 00H
	ORG $+1
$SG11381 DB	'mm', 00H
	ORG $+1
$SG11382 DB	'ms', 00H
	ORG $+1
$SG11383 DB	'mt', 00H
	ORG $+1
$SG11384 DB	'mz', 00H
	ORG $+1
$SG11385 DB	'nc=$', 00H
	ORG $+3
$SG11386 DB	'nd=$', 00H
	ORG $+3
$SG11387 DB	'nm=$', 00H
	ORG $+3
$SG11388 DB	'nologo', 00H
	ORG $+1
$SG11389 DB	'nt=$', 00H
	ORG $+3
$SG11390 DB	'omf', 00H
$SG11391 DB	'pe', 00H
	ORG $+1
$SG11392 DB	'q', 00H
	ORG $+2
$SG11393 DB	'Sa', 00H
	ORG $+1
$SG11394 DB	'Sf', 00H
	ORG $+1
$SG11395 DB	'Sg', 00H
	ORG $+1
$SG11396 DB	'Sn', 00H
	ORG $+1
$SG11397 DB	'Sx', 00H
	ORG $+1
$SG11398 DB	'safeseh', 00H
$SG11399 DB	'WX', 00H
	ORG $+1
$SG11400 DB	'W=#', 00H
$SG11401 DB	'win64', 00H
	ORG $+2
$SG11402 DB	'w', 00H
	ORG $+2
$SG11403 DB	'X', 00H
	ORG $+2
$SG11404 DB	'Zd', 00H
	ORG $+1
$SG11405 DB	'Zf', 00H
	ORG $+1
$SG11406 DB	'Zg', 00H
	ORG $+1
$SG11407 DB	'Zi=#', 00H
	ORG $+3
$SG11408 DB	'Zm', 00H
	ORG $+1
$SG11409 DB	'Zne', 00H
$SG11410 DB	'Zp=#', 00H
	ORG $+3
$SG11411 DB	'zcm', 00H
$SG11412 DB	'zcw', 00H
$SG11413 DB	'zf0', 00H
$SG11414 DB	'zf1', 00H
$SG11415 DB	'zlc', 00H
$SG11416 DB	'zld', 00H
$SG11417 DB	'zlf', 00H
$SG11418 DB	'zlp', 00H
$SG11419 DB	'zls', 00H
$SG11420 DB	'Zs', 00H
	ORG $+1
$SG11421 DB	'zt0', 00H
$SG11422 DB	'zt1', 00H
$SG11423 DB	'zt2', 00H
$SG11424 DB	'Zv8', 00H
$SG11425 DB	'zze', 00H
$SG11426 DB	'zzs', 00H
$SG11473 DB	'rb', 00H
	ORG $+1
Options	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	00H
	DD	032H
	DB	00H
	DB	02H
	DB	00H
	ORG $+1
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	01H
	DD	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	ORG $+3
$SG11206 DB	'Zi', 00H
	ORG $+1
$SG11215 DB	'Zp', 00H
_DATA	ENDS
PUBLIC	ParseCmdline
PUBLIC	CmdlineFini
EXTRN	isspace:PROC
EXTRN	isalnum:PROC
EXTRN	fclose:PROC
EXTRN	fopen:PROC
EXTRN	fread:PROC
EXTRN	fseek:PROC
EXTRN	ftell:PROC
EXTRN	rewind:PROC
EXTRN	exit:PROC
EXTRN	getenv:PROC
EXTRN	Fatal:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	ErrnoStr:PROC
EXTRN	PrintUsage:PROC
EXTRN	MemAlloc:PROC
EXTRN	MemFree:PROC
EXTRN	GetFNamePart:PROC
EXTRN	banner_printed:BYTE
EXTRN	__ImageBase:BYTE
_BSS	SEGMENT
OptValue DD	01H DUP (?)
	ALIGN	8

OptName	DQ	01H DUP (?)
cmdsave	DQ	0fH DUP (?)
cmdbuffers DQ	0fH DUP (?)
rspidx	DD	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$ParseCmdline DD imagerel $LN116
	DD	imagerel $LN116+885
	DD	imagerel $unwind$ParseCmdline
$pdata$CmdlineFini DD imagerel $LN34
	DD	imagerel $LN34+169
	DD	imagerel $unwind$CmdlineFini
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$queue_item DD imagerel queue_item
	DD	imagerel queue_item+151
	DD	imagerel $unwind$queue_item
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_fname DD imagerel get_fname
	DD	imagerel get_fname+354
	DD	imagerel $unwind$get_fname
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_option_n_name DD imagerel set_option_n_name
	DD	imagerel set_option_n_name+172
	DD	imagerel $unwind$set_option_n_name
pdata	ENDS
pdata	SEGMENT
$pdata$Set_Fd DD imagerel Set_Fd
	DD	imagerel Set_Fd+177
	DD	imagerel $unwind$Set_Fd
$pdata$Set_Fl DD imagerel Set_Fl
	DD	imagerel Set_Fl+33
	DD	imagerel $unwind$Set_Fl
$pdata$Set_h DD	imagerel Set_h
	DD	imagerel Set_h+20
	DD	imagerel $unwind$Set_h
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetNameToken DD imagerel GetNameToken
	DD	imagerel GetNameToken+219
	DD	imagerel $unwind$GetNameToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReadParamFile DD imagerel ReadParamFile
	DD	imagerel ReadParamFile+79
	DD	imagerel $unwind$ReadParamFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ReadParamFile DD imagerel ReadParamFile+79
	DD	imagerel ReadParamFile+176
	DD	imagerel $chain$0$ReadParamFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ReadParamFile DD imagerel ReadParamFile+176
	DD	imagerel ReadParamFile+254
	DD	imagerel $chain$1$ReadParamFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getnextcmdstring DD imagerel getnextcmdstring
	DD	imagerel getnextcmdstring+19
	DD	imagerel $unwind$getnextcmdstring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$getnextcmdstring DD imagerel getnextcmdstring+19
	DD	imagerel getnextcmdstring+85
	DD	imagerel $chain$0$getnextcmdstring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$getnextcmdstring DD imagerel getnextcmdstring+85
	DD	imagerel getnextcmdstring+131
	DD	imagerel $chain$1$getnextcmdstring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ProcessOption DD imagerel ProcessOption
	DD	imagerel ProcessOption+341
	DD	imagerel $unwind$ProcessOption
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ProcessOption DD imagerel ProcessOption+341
	DD	imagerel ProcessOption+516
	DD	imagerel $chain$3$ProcessOption
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ProcessOption DD imagerel ProcessOption+516
	DD	imagerel ProcessOption+527
	DD	imagerel $chain$4$ProcessOption
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$ProcessOption DD imagerel ProcessOption+527
	DD	imagerel ProcessOption+1163
	DD	imagerel $chain$5$ProcessOption
pdata	ENDS
CONST	SEGMENT
cpuoption DD	00H
	DD	010H
	DD	020H
	DD	030H
	DD	040H
	DD	050H
	DD	060H
	DD	0160H
	DD	0560H
	DD	0d60H
	DD	070H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$ProcessOption DD 080021H
	DD	04f400H
	DD	0ce400H
	DD	0b6400H
	DD	0a5400H
	DD	imagerel ProcessOption
	DD	imagerel ProcessOption+341
	DD	imagerel $unwind$ProcessOption
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ProcessOption DD 021H
	DD	imagerel ProcessOption
	DD	imagerel ProcessOption+341
	DD	imagerel $unwind$ProcessOption
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ProcessOption DD 081621H
	DD	04f416H
	DD	0ce411H
	DD	0b640cH
	DD	0a5405H
	DD	imagerel ProcessOption
	DD	imagerel ProcessOption+341
	DD	imagerel $unwind$ProcessOption
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ProcessOption DD 050b01H
	DD	0d007420bH
	DD	07003c005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$getnextcmdstring DD 021H
	DD	imagerel getnextcmdstring
	DD	imagerel getnextcmdstring+19
	DD	imagerel $unwind$getnextcmdstring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$getnextcmdstring DD 020521H
	DD	043405H
	DD	imagerel getnextcmdstring
	DD	imagerel getnextcmdstring+19
	DD	imagerel $unwind$getnextcmdstring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getnextcmdstring DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ReadParamFile DD 021H
	DD	imagerel ReadParamFile
	DD	imagerel ReadParamFile+79
	DD	imagerel $unwind$ReadParamFile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ReadParamFile DD 020521H
	DD	065405H
	DD	imagerel ReadParamFile
	DD	imagerel ReadParamFile+79
	DD	imagerel $unwind$ReadParamFile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReadParamFile DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetNameToken DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_option_n_name DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_fname DD 050d01H
	DD	028340dH
	DD	026010dH
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$queue_item DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
xdata	SEGMENT
$unwind$ParseCmdline DD 0d5501H
	DD	02af455H
	DD	02d641bH
	DD	02c541bH
	DD	02b341bH
	DD	026011bH
	DD	0c012e014H
	DD	07010H
$unwind$CmdlineFini DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$Set_Fd DD 030901H
	DD	0260109H
	DD	03002H
$unwind$Set_Fl DD 010401H
	DD	04204H
$unwind$Set_h DD 010401H
	DD	04204H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
;	COMDAT ProcessOption
_TEXT	SEGMENT
cmdline$ = 80
buffer$ = 88
ProcessOption PROC					; COMDAT

; 824  : {

	push	rbx
	push	rdi
	push	r12
	push	r13
	sub	rsp, 40					; 00000028H

; 825  :     int   i;
; 826  :     int   j;
; 827  :     const char *p = *cmdline;

	mov	rbx, QWORD PTR [rcx]
	mov	r12, rdx
	mov	r13, rcx

; 828  :     const char *opt;
; 829  :     //char  c;
; 830  : 
; 831  :     DebugMsg(("ProcessOption(%s)\n", p ));
; 832  : 
; 833  :     /* numeric option (-0, -1, ... ) handled separately since
; 834  :      * the value can be >= 10.
; 835  :      */
; 836  :     if ( *p >= '0' && *p <= '9' ) {

	movzx	r8d, BYTE PTR [rbx]
	lea	eax, DWORD PTR [r8-48]
	cmp	al, 9
	ja	$LN16@ProcessOpt

; 837  :         p = GetNumber( p );

	xor	r10d, r10d
	mov	rdx, rbx
	mov	DWORD PTR OptValue, r10d
$LL35@ProcessOpt:
	cmp	r8b, 57					; 00000039H
	jg	SHORT $LN34@ProcessOpt
	inc	rdx
	movsx	eax, r8b
	lea	ecx, DWORD PTR [r10+r10*4]
	lea	r10d, DWORD PTR [rcx-24]
	movzx	r8d, BYTE PTR [rdx]
	lea	r10d, DWORD PTR [rax+r10*2]
	cmp	r8b, 48					; 00000030H
	jge	SHORT $LL35@ProcessOpt
$LN34@ProcessOpt:
	mov	DWORD PTR OptValue, r10d

; 838  :         if ( OptValue < sizeof(cpuoption)/sizeof(cpuoption[0]) ) {

	cmp	r10d, 11
	jae	$LN16@ProcessOpt

; 839  :             p = GetNameToken( buffer, p, 16, 0 ); /* get optional 'p' */

	cmp	BYTE PTR [rdx], 34			; 00000022H
	mov	r9d, 16
	mov	r8, r12
	je	SHORT $LN109@ProcessOpt
$is_quote$163:
	test	r9d, r9d
	je	SHORT $LN39@ProcessOpt
	movzx	ecx, BYTE PTR [rdx]
	test	cl, cl
	je	SHORT $LN39@ProcessOpt
	cmp	cl, 32					; 00000020H
	je	SHORT $LN39@ProcessOpt
	cmp	cl, 9
	je	SHORT $LN39@ProcessOpt
	lea	eax, DWORD PTR [rcx-45]
	test	al, 253					; 000000fdH
	je	SHORT $LN39@ProcessOpt
	mov	BYTE PTR [r8], cl
	inc	rdx
	inc	r8
	dec	r9d
	jmp	SHORT $is_quote$163
$LN109@ProcessOpt:
	inc	rdx
$LL40@ProcessOpt:
	movzx	eax, BYTE PTR [rdx]
	test	al, al
	je	SHORT $LN39@ProcessOpt
	cmp	al, 34					; 00000022H
	je	SHORT $LN110@ProcessOpt
	cmp	al, 92					; 0000005cH
	jne	SHORT $LN47@ProcessOpt
	cmp	BYTE PTR [rdx+1], 34			; 00000022H
	lea	rax, QWORD PTR [rdx+1]
	cmove	rdx, rax
$LN47@ProcessOpt:
	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	mov	BYTE PTR [r8], al
	inc	r8
	sub	r9d, 1
	jne	SHORT $LL40@ProcessOpt

; 894  :                         if ( p == NULL ) {

	jmp	SHORT $LN39@ProcessOpt
$LN110@ProcessOpt:

; 839  :             p = GetNameToken( buffer, p, 16, 0 ); /* get optional 'p' */

	inc	rdx
$LN39@ProcessOpt:
	mov	BYTE PTR [r8], 0

; 840  :             *cmdline = p;
; 841  :             SetCpuCmdline( cpuoption[OptValue], buffer );

	lea	rdi, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [r13], rdx
	mov	eax, DWORD PTR Options+164
	mov	edx, DWORD PTR cpuoption[rdi+r10*4]
	and	eax, -65529				; ffffffffffff0007H
	or	edx, eax
	mov	DWORD PTR Options+164, edx
	movzx	eax, BYTE PTR [r12]
	test	al, al
	je	$LN1@ProcessOpt
	npad	6
$LL61@ProcessOpt:
	cmp	al, 112					; 00000070H
	jne	SHORT $LN62@ProcessOpt
	cmp	edx, 32					; 00000020H
	jl	SHORT $LN62@ProcessOpt
	inc	r12
	or	edx, 8
	mov	DWORD PTR Options+164, edx
	movzx	eax, BYTE PTR [r12]
	test	al, al
	jne	SHORT $LL61@ProcessOpt

; 912  :     return;
; 913  : }

	add	rsp, 40					; 00000028H
	pop	r13
	pop	r12
	pop	rdi
	pop	rbx
	ret	0

; 840  :             *cmdline = p;
; 841  :             SetCpuCmdline( cpuoption[OptValue], buffer );

$LN62@ProcessOpt:
	mov	r8, r12
	mov	edx, 134				; 00000086H
	mov	ecx, 1

; 912  :     return;
; 913  : }

	add	rsp, 40					; 00000028H
	pop	r13
	pop	r12
	pop	rdi
	pop	rbx

; 840  :             *cmdline = p;
; 841  :             SetCpuCmdline( cpuoption[OptValue], buffer );

	jmp	EmitWarn
$LN16@ProcessOpt:
	mov	QWORD PTR [rsp+80], rbp

; 842  :             return;
; 843  :         }
; 844  :         p = *cmdline; /* v2.11: restore option pointer */
; 845  :     }
; 846  :     for( i = 0; i < ( sizeof(cmdl_options) / sizeof(cmdl_options[0]) ); i++ ) {

	xor	ebp, ebp
	mov	QWORD PTR [rsp+88], rsi
	mov	QWORD PTR [rsp+96], r14
	mov	QWORD PTR [rsp+32], r15
	lea	r15, OFFSET FLAT:cmdl_options
$LL4@ProcessOpt:

; 847  :         //DebugMsg(("ProcessOption(%s): %s\n", p, opt ));
; 848  :         if( *p == *cmdl_options[i].name ) {

	mov	r14, QWORD PTR [r15]
	movzx	eax, BYTE PTR [r14]
	cmp	BYTE PTR [rbx], al
	jne	SHORT $LN2@ProcessOpt

; 849  :             for ( opt = cmdl_options[i].name+1, j = 1 ; isalnum(*opt) && *opt == p[j]; opt++, j++ );

	movsx	ecx, BYTE PTR [r14+1]
	inc	r14
	mov	esi, 1
	call	isalnum
	test	eax, eax
	je	SHORT $LN157@ProcessOpt
	lea	rdi, QWORD PTR [rbx+1]
$LL7@ProcessOpt:
	movzx	eax, BYTE PTR [rdi]
	cmp	BYTE PTR [r14], al
	jne	SHORT $LN157@ProcessOpt
	movsx	ecx, BYTE PTR [r14+1]
	inc	r14
	inc	rdi
	inc	esi
	call	isalnum
	test	eax, eax
	jne	SHORT $LL7@ProcessOpt
$LN157@ProcessOpt:

; 850  :             /* make sure end of option is reached */
; 851  :             if ( isalnum(*opt) )

	movsx	ecx, BYTE PTR [r14]
	call	isalnum
	test	eax, eax
	je	SHORT $LN18@ProcessOpt
$LN2@ProcessOpt:

; 842  :             return;
; 843  :         }
; 844  :         p = *cmdline; /* v2.11: restore option pointer */
; 845  :     }
; 846  :     for( i = 0; i < ( sizeof(cmdl_options) / sizeof(cmdl_options[0]) ); i++ ) {

	inc	ebp
	add	r15, 24
	movsxd	rax, ebp
	cmp	rax, 80					; 00000050H
	jb	SHORT $LL4@ProcessOpt
$opt_error_exit$164:

; 897  :                         }
; 898  :                     }
; 899  :                     break;
; 900  :                 default:
; 901  :                     /* internal error: unknown format of option item! */
; 902  :                     DebugMsg(( "ProcessOption: unknown option specifier: %s\n", opt ));
; 903  :                     /**/myassert( 0 );
; 904  :                     break;
; 905  :                 }
; 906  :             }
; 907  :         }
; 908  :     }
; 909  : opt_error_exit:
; 910  :     EmitWarn( 1, INVALID_CMDLINE_OPTION, *cmdline - 1 );

	mov	r8, QWORD PTR [r13]
	mov	edx, 109				; 0000006dH
	dec	r8
	lea	ecx, QWORD PTR [rdx-108]
	call	EmitWarn

; 911  :     *cmdline = "";

	lea	rax, OFFSET FLAT:$SG11541
	mov	QWORD PTR [r13], rax
$LN161@ProcessOpt:
	mov	r14, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+80]
	mov	r15, QWORD PTR [rsp+32]
$LN1@ProcessOpt:

; 912  :     return;
; 913  : }

	add	rsp, 40					; 00000028H
	pop	r13
	pop	r12
	pop	rdi
	pop	rbx
	ret	0
$LN18@ProcessOpt:

; 852  :                 continue;
; 853  :             p += j;
; 854  :             OptValue = cmdl_options[i].value;

	mov	r11d, DWORD PTR rspidx
	lea	rdi, OFFSET FLAT:__ImageBase
	movsxd	rax, esi
	add	rbx, rax
	movsxd	rax, ebp
	lea	rbp, OFFSET FLAT:cmdl_options
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rsi, QWORD PTR [rcx*8]
	mov	eax, DWORD PTR [rsi+rbp+8]
	mov	DWORD PTR OptValue, eax
$LL10@ProcessOpt:

; 857  :                 switch ( *opt ) {

	movsx	r9, BYTE PTR [r14]
	mov	rax, r9
	cmp	r9d, 94					; 0000005eH
	ja	$LN8@ProcessOpt
	movzx	eax, BYTE PTR $LN154@ProcessOpt[rdi+rax]
	mov	ecx, DWORD PTR $LN155@ProcessOpt[rdi+rax*4]
	add	rcx, rdi
	jmp	rcx
$LN21@ProcessOpt:

; 865  :                     break;
; 866  :                 case '#':             /* collect a number */
; 867  :                     if( *p >= '0' && *p <= '9' )

	movzx	edx, BYTE PTR [rbx]
	lea	eax, DWORD PTR [rdx-48]
	cmp	al, 9
	ja	$LN8@ProcessOpt

; 868  :                         p = GetNumber( p );

	xor	eax, eax
	mov	DWORD PTR OptValue, eax
	npad	2
$LL68@ProcessOpt:
	cmp	dl, 57					; 00000039H
	jg	SHORT $LN67@ProcessOpt
	lea	ecx, DWORD PTR [rax+rax*4]
	inc	rbx
	movsx	eax, dl
	movzx	edx, BYTE PTR [rbx]
	lea	eax, DWORD PTR [rax+rcx*2]
	add	eax, -48				; ffffffd0H
	cmp	dl, 48					; 00000030H
	jge	SHORT $LL68@ProcessOpt
$LN67@ProcessOpt:
	mov	DWORD PTR OptValue, eax
	inc	r14
	jmp	SHORT $LL10@ProcessOpt
$LN23@ProcessOpt:

; 869  :                     break;
; 870  :                 case '$':      /* collect an identifer+value */
; 871  :                 case '@':      /* collect a filename */
; 872  :                     OptName = buffer;
; 873  : #if 0  /* v2.05: removed */
; 874  :                     if ( rspidx )
; 875  :                         p = GetNameToken( buffer, p, FILENAME_MAX - 1, *opt );
; 876  :                     else {
; 877  :                         j = strlen( p );
; 878  :                         memcpy( buffer, p, (j >= FILENAME_MAX) ? FILENAME_MAX : j + 1 );
; 879  :                         p += j;
; 880  :                     }
; 881  : #else
; 882  :                     /* v2.10: spaces in filename now handled inside GetNameToken() */
; 883  :                     p = GetNameToken( buffer, p, FILENAME_MAX - 1, *opt );

	xor	r10b, r10b
	mov	QWORD PTR OptName, r12
	cmp	BYTE PTR [rbx], 34			; 00000022H
	mov	r8d, 259				; 00000103H
	mov	rdx, r12
	je	SHORT $LN114@ProcessOpt
	npad	1
$is_quote$165:
	test	r8d, r8d
	je	$LN72@ProcessOpt
	movzx	ecx, BYTE PTR [rbx]
	test	cl, cl
	je	$LN72@ProcessOpt
	cmp	cl, 32					; 00000020H
	je	SHORT $LN83@ProcessOpt
	cmp	cl, 9
	jne	SHORT $LN82@ProcessOpt
$LN83@ProcessOpt:
	test	r11d, r11d
	jne	$LN72@ProcessOpt
	cmp	r9b, 64					; 00000040H
	jne	SHORT $LN72@ProcessOpt
$LN82@ProcessOpt:
	test	r9b, r9b
	jne	SHORT $LN86@ProcessOpt
	lea	eax, DWORD PTR [rcx-45]
	test	al, 253					; 000000fdH
	je	SHORT $LN72@ProcessOpt
$LN86@ProcessOpt:
	cmp	cl, 61					; 0000003dH
	jne	SHORT $LN89@ProcessOpt
	cmp	r9b, 36					; 00000024H
	jne	SHORT $LN89@ProcessOpt
	test	r10b, r10b
	jne	SHORT $LN89@ProcessOpt
	inc	rbx
	mov	BYTE PTR [rdx], cl
	inc	rdx
	mov	r10b, 1
	movzx	ecx, BYTE PTR [rbx]
	cmp	cl, 34					; 00000022H
	je	SHORT $LN114@ProcessOpt
$LN89@ProcessOpt:
	mov	BYTE PTR [rdx], cl
	inc	rbx
	inc	rdx
	dec	r8d
	jmp	SHORT $is_quote$165
$LN114@ProcessOpt:
	inc	rbx
	test	r8d, r8d
	je	SHORT $LN72@ProcessOpt
$LL73@ProcessOpt:
	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	SHORT $LN72@ProcessOpt
	cmp	al, 34					; 00000022H
	je	SHORT $LN115@ProcessOpt
	cmp	al, 92					; 0000005cH
	jne	SHORT $LN80@ProcessOpt
	cmp	BYTE PTR [rbx+1], 34			; 00000022H
	lea	rax, QWORD PTR [rbx+1]
	cmove	rbx, rax
$LN80@ProcessOpt:
	movzx	eax, BYTE PTR [rbx]
	inc	rbx
	mov	BYTE PTR [rdx], al
	inc	rdx
	sub	r8d, 1
	jne	SHORT $LL73@ProcessOpt
	mov	BYTE PTR [rdx], r8b
	inc	r14
	jmp	$LL10@ProcessOpt
$LN115@ProcessOpt:
	inc	rbx
$LN72@ProcessOpt:
	mov	BYTE PTR [rdx], 0
	inc	r14
	jmp	$LL10@ProcessOpt
$LN24@ProcessOpt:

; 884  : #endif
; 885  :                     break;
; 886  :                 case '=':    /* collect an optional '=' */
; 887  :                     if ( *p == '=' || *p == '#' )

	movzx	eax, BYTE PTR [rbx]
	cmp	al, 61					; 0000003dH
	je	SHORT $LN26@ProcessOpt
	cmp	al, 35					; 00000023H
	jne	SHORT $LN8@ProcessOpt
$LN26@ProcessOpt:

; 888  :                         p++;

	inc	rbx
	inc	r14
	jmp	$LL10@ProcessOpt
$LN103@ProcessOpt:

; 889  :                     break;
; 890  :                 case '^':    /* skip spaces before argument */
; 891  :                     while ( isspace(*p) ) p++;

	movsx	ecx, BYTE PTR [rbx]
	call	isspace
	test	eax, eax
	je	SHORT $LN14@ProcessOpt
	npad	8
$LL13@ProcessOpt:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL13@ProcessOpt
$LN14@ProcessOpt:

; 892  :                     if ( *p == NULLC ) {

	cmp	BYTE PTR [rbx], 0
	jne	SHORT $LN156@ProcessOpt

; 893  :                         p = getnextcmdstring( cmdline );

	mov	rcx, r13
	call	getnextcmdstring
	mov	rbx, rax

; 894  :                         if ( p == NULL ) {

	test	rax, rax
	je	SHORT $LN116@ProcessOpt
$LN156@ProcessOpt:
	mov	r11d, DWORD PTR rspidx
$LN8@ProcessOpt:

; 855  :             //DebugMsg(("ProcessOption(%s): Option found\n", p ));
; 856  :             for( ;; opt++) {

	inc	r14
	jmp	$LL10@ProcessOpt
$LN116@ProcessOpt:

; 895  :                             EmitWarn( 1, MISSING_ARGUMENT_FOR_CMDLINE_OPTION );

	mov	edx, 251				; 000000fbH
	mov	ecx, 1
	call	EmitWarn

; 896  :                             return;

	jmp	$LN161@ProcessOpt
$LN19@ProcessOpt:

; 858  :                 //case '*': /* don't know what this is supposed to do? */
; 859  :                 case NULLC:
; 860  :                     if ( !IsOptionDelimiter( *p ) )

	movzx	eax, BYTE PTR [rbx]
	cmp	al, 47					; 0000002fH
	ja	$opt_error_exit$164
	mov	rcx, 175926155411969			; 0000a00100000201H
	bt	rcx, rax
	jae	$opt_error_exit$164

; 861  :                         goto opt_error_exit;
; 862  :                     *cmdline = p;

	mov	QWORD PTR [r13], rbx

; 863  :                     cmdl_options[i].function();

	call	QWORD PTR [rsi+rbp+16]

; 864  :                     return; /* option processed successfully */

	jmp	$LN161@ProcessOpt
$LN155@ProcessOpt:

; 912  :     return;
; 913  : }

	DD	$LN19@ProcessOpt
	DD	$LN21@ProcessOpt
	DD	$LN23@ProcessOpt
	DD	$LN24@ProcessOpt
	DD	$LN103@ProcessOpt
	DD	$LN8@ProcessOpt
$LN154@ProcessOpt:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
ProcessOption ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
;	COMDAT GetNumber
_TEXT	SEGMENT
p$ = 8
GetNumber PROC						; COMDAT

; 807  : {

	mov	r8, rcx

; 808  :     OptValue = 0;

	xor	ecx, ecx
	mov	DWORD PTR OptValue, ecx

; 809  :     for( ;*p >= '0' && *p <= '9'; p++ )

	movzx	eax, BYTE PTR [r8]
	cmp	al, 48					; 00000030H
	jl	SHORT $LN10@GetNumber
$LL4@GetNumber:
	cmp	al, 57					; 00000039H
	jg	SHORT $LN10@GetNumber

; 810  :         OptValue = OptValue * 10 + *p - '0';

	lea	edx, DWORD PTR [rcx+rcx*4]
	inc	r8
	movsx	ecx, al
	movzx	eax, BYTE PTR [r8]
	lea	ecx, DWORD PTR [rcx+rdx*2]
	add	ecx, -48				; ffffffd0H
	mov	DWORD PTR OptValue, ecx
	cmp	al, 48					; 00000030H
	jge	SHORT $LL4@GetNumber
$LN10@GetNumber:

; 811  :     return( p );

	mov	rax, r8

; 812  : }

	ret	0
GetNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
;	COMDAT getnextcmdstring
_TEXT	SEGMENT
cmdline$ = 48
getnextcmdstring PROC					; COMDAT

; 788  : {

	sub	rsp, 40					; 00000028H

; 789  :     const char **src;
; 790  :     const char **dst;
; 791  : 
; 792  :     /* something onto the response file stack? */
; 793  :     if ( rspidx ) {

	mov	edx, DWORD PTR rspidx
	mov	r8, rcx
	test	edx, edx
	je	SHORT $LN5@getnextcmd

; 794  :         rspidx--;

	dec	edx
	mov	QWORD PTR [rsp+32], rbx

; 795  :         if ( cmdbuffers[rspidx] )

	movsxd	rax, edx
	lea	rbx, OFFSET FLAT:__ImageBase
	mov	DWORD PTR rspidx, edx
	mov	rcx, QWORD PTR cmdbuffers[rbx+rax*8]
	test	rcx, rcx
	je	SHORT $LN6@getnextcmd

; 796  :             MemFree( (void *)cmdbuffers[rspidx] );

	call	MemFree
	mov	edx, DWORD PTR rspidx
$LN6@getnextcmd:

; 797  :         return( cmdsave[rspidx] );

	movsxd	rax, edx
	mov	rax, QWORD PTR cmdsave[rbx+rax*8]
	mov	rbx, QWORD PTR [rsp+32]

; 803  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN5@getnextcmd:

; 798  :     }
; 799  :     for ( dst = cmdline, src = cmdline+1; *src; )

	mov	rdx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+8]
	test	rdx, rdx
	je	SHORT $LN3@getnextcmd
$LL2@getnextcmd:

; 800  :         *dst++ = *src++;

	add	rax, 8
	mov	QWORD PTR [rcx], rdx
	add	rcx, 8
	mov	rdx, QWORD PTR [rax]
	test	rdx, rdx
	jne	SHORT $LL2@getnextcmd
$LN3@getnextcmd:

; 801  :     *dst = *src;

	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 802  :     return( *cmdline );

	mov	rax, QWORD PTR [r8]

; 803  : }

	add	rsp, 40					; 00000028H
	ret	0
getnextcmdstring ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
;	COMDAT ReadParamFile
_TEXT	SEGMENT
name$ = 48
ReadParamFile PROC					; COMDAT

; 735  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 736  :     char        *env;
; 737  :     char        *str;
; 738  :     FILE        *file;
; 739  :     int         len;
; 740  :     char        ch;
; 741  : 
; 742  :     DebugMsg(("ReadParamFile(%s) enter\n"));
; 743  :     env = NULL;
; 744  :     file = fopen( name, "rb" );

	lea	rdx, OFFSET FLAT:$SG11473
	mov	rbx, rcx
	xor	edi, edi
	call	fopen
	mov	rsi, rax

; 745  :     if( file == NULL ) {

	test	rax, rax
	jne	SHORT $LN4@ReadParamF

; 746  :         /* v2.10: changed to fatal error */
; 747  :         //EmitErr( CANNOT_OPEN_FILE, name, ErrnoStr() );
; 748  :         Fatal( CANNOT_OPEN_FILE, name, ErrnoStr() );

	call	ErrnoStr
	mov	r8, rax
	lea	ecx, QWORD PTR [rdi+106]
	mov	rdx, rbx
	call	Fatal
$LN16@ReadParamF:

; 749  :         return( NULL );

	xor	eax, eax

; 782  : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@ReadParamF:

; 750  :     }
; 751  :     len = 0;
; 752  :     if ( fseek( file, 0, SEEK_END ) == 0 ) {

	xor	edx, edx
	mov	QWORD PTR [rsp+48], rbp
	mov	rcx, rax
	mov	ebp, edi
	lea	r8d, QWORD PTR [rdx+2]
	call	fseek
	test	eax, eax
	jne	SHORT $LN5@ReadParamF

; 753  :         len = ftell( file );

	mov	rcx, rsi
	call	ftell

; 754  :         rewind( file );

	mov	rcx, rsi
	movsxd	rbp, eax
	call	rewind

; 755  :         env = MemAlloc( len + 1 );

	lea	eax, DWORD PTR [rbp+1]
	movsxd	rcx, eax
	call	MemAlloc

; 756  : #if defined(__GNUC__) /* gcc warns if return value of fread() is "ignored" */
; 757  :         if ( fread( env, 1, len, file ) );
; 758  : #else
; 759  :         fread( env, 1, len, file );

	mov	r9, rsi
	mov	r8, rbp
	mov	edx, 1
	mov	rcx, rax
	mov	rdi, rax
	call	fread

; 760  : #endif
; 761  :         env[len] = NULLC;

	mov	BYTE PTR [rbp+rdi], 0
$LN5@ReadParamF:

; 762  :     }
; 763  :     fclose( file );

	mov	rcx, rsi
	call	fclose

; 764  :     if ( len == 0)

	test	ebp, ebp
	mov	rbp, QWORD PTR [rsp+48]
	je	SHORT $LN16@ReadParamF

; 765  :         return( NULL );
; 766  :     /* zip through characters changing \r, \n etc into ' ' */
; 767  :     str = env;
; 768  :     while( *str ) {

	cmp	BYTE PTR [rdi], 0
	mov	rax, rdi
	je	SHORT $LN3@ReadParamF
$LL2@ReadParamF:

; 769  :         ch = *str;

	movzx	ecx, BYTE PTR [rax]

; 770  :         if( ch == '\r' || ch == '\n' ) {

	cmp	cl, 13
	je	SHORT $LN8@ReadParamF
	cmp	cl, 10
	jne	SHORT $LN7@ReadParamF
$LN8@ReadParamF:

; 771  :             *str = ' ';

	mov	BYTE PTR [rax], 32			; 00000020H
$LN7@ReadParamF:

; 772  :         }
; 773  : #if HANDLECTRLZ
; 774  :         if( ch == 0x1A ) {      /* if end of file */

	cmp	cl, 26
	je	SHORT $LN12@ReadParamF

; 776  :             break;
; 777  :         }
; 778  : #endif
; 779  :         ++str;

	inc	rax
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LL2@ReadParamF

; 780  :     }
; 781  :     return( env );

	mov	rax, rdi

; 782  : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN12@ReadParamF:

; 775  :             *str = '\0';        /* - mark end of str */

	mov	BYTE PTR [rax], 0
$LN3@ReadParamF:

; 782  : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rax, rdi
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ReadParamFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
;	COMDAT GetNameToken
_TEXT	SEGMENT
dst$ = 8
str$ = 16
max$ = 24
type$ = 32
GetNameToken PROC					; COMDAT

; 680  : {

	mov	QWORD PTR [rsp+8], rbx

; 681  :     bool equatefound = FALSE;

	xor	r11b, r11b
	mov	r10d, r8d

; 682  : 
; 683  :     DebugMsg(("GetNameToken( %s, %u, '%c' ) enter, rspidx=%u\n", str, max, type, rspidx ));
; 684  :     //while( isspace( *str ) ) ++str;  /* no spaces allowed! */
; 685  : is_quote:
; 686  :     if( *str == '"' ) {

	cmp	BYTE PTR [rdx], 34			; 00000022H
	je	SHORT $LN29@GetNameTok
	mov	ebx, DWORD PTR rspidx
$is_quote$38:

; 698  :         }
; 699  :     } else {
; 700  :         for( ; max; max-- ) {

	test	r10d, r10d
	je	$LN3@GetNameTok

; 701  :             /* v2.10: don't stop for white spaces */
; 702  :             //if ( *str == NULLC || *str == ' ' || *str == '\t' )
; 703  :             if ( *str == NULLC )

	movzx	r8d, BYTE PTR [rdx]
	test	r8b, r8b
	je	$LN3@GetNameTok

; 704  :                 break;
; 705  :             /* v2.10: don't stop for white spaces if filename is expected and true cmdline is parsed */
; 706  :             if ( ( *str == ' ' || *str == '\t' ) && ( rspidx || type != '@' ) )

	cmp	r8b, 32					; 00000020H
	je	SHORT $LN14@GetNameTok
	cmp	r8b, 9
	jne	SHORT $LN13@GetNameTok
$LN14@GetNameTok:
	test	ebx, ebx
	jne	$LN3@GetNameTok
	cmp	r9b, 64					; 00000040H
	jne	$LN3@GetNameTok
$LN13@GetNameTok:

; 707  :                 break;
; 708  :             if ( type == 0 )

	test	r9b, r9b
	jne	SHORT $LN17@GetNameTok
	lea	eax, DWORD PTR [r8-45]
	test	al, 253					; 000000fdH
	je	SHORT $LN3@GetNameTok
$LN17@GetNameTok:

; 709  :                 if ( *str == '-'
; 710  : #if SWITCHCHAR
; 711  :                     || *str == '/'
; 712  : #endif
; 713  :                    )
; 714  :                     break;
; 715  :             if ( *str == '=' && type == '$' && equatefound == FALSE ) {

	cmp	r8b, 61					; 0000003dH
	jne	SHORT $LN20@GetNameTok
	cmp	r9b, 36					; 00000024H
	jne	SHORT $LN20@GetNameTok
	test	r11b, r11b
	jne	SHORT $LN20@GetNameTok

; 716  :                 equatefound = TRUE;
; 717  :                 *dst++ = *str++;

	inc	rdx
	mov	BYTE PTR [rcx], r8b
	inc	rcx
	mov	r11b, 1

; 718  :                 if (*str == '"')

	movzx	r8d, BYTE PTR [rdx]
	cmp	r8b, 34					; 00000022H
	je	SHORT $LN29@GetNameTok
$LN20@GetNameTok:

; 719  :                     goto is_quote;
; 720  :             }
; 721  :             *dst++ = *str++;

	mov	BYTE PTR [rcx], r8b
	inc	rdx
	inc	rcx
	dec	r10d
	jmp	SHORT $is_quote$38
$LN29@GetNameTok:

; 687  :         ++str;

	inc	rdx

; 688  :         for( ; max && *str; max-- ) {

	test	r10d, r10d
	je	SHORT $LN3@GetNameTok
$LL4@GetNameTok:
	movzx	eax, BYTE PTR [rdx]
	test	al, al
	je	SHORT $LN3@GetNameTok

; 689  :             if ( *str == '"' ) {

	cmp	al, 34					; 00000022H
	je	SHORT $LN30@GetNameTok

; 691  :                 break;
; 692  :             }
; 693  :             /* handle the \" case */
; 694  :             if ( *str == '\\' && *(str+1) == '"' ) {

	cmp	al, 92					; 0000005cH
	jne	SHORT $LN11@GetNameTok
	cmp	BYTE PTR [rdx+1], 34			; 00000022H
	lea	rax, QWORD PTR [rdx+1]
	cmove	rdx, rax
$LN11@GetNameTok:

; 695  :                 ++str;
; 696  :             }
; 697  :             *dst++ = *str++;

	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	mov	BYTE PTR [rcx], al
	inc	rcx
	sub	r10d, 1
	jne	SHORT $LL4@GetNameTok

; 722  :         }
; 723  :     }
; 724  :     *dst = NULLC;

	mov	BYTE PTR [rcx], r10b

; 725  :     return( str );

	mov	rax, rdx

; 726  : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
$LN30@GetNameTok:

; 690  :                 ++str;

	inc	rdx
$LN3@GetNameTok:

; 726  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rax, rdx
	mov	BYTE PTR [rcx], 0
	ret	0
GetNameToken ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_h	PROC

; 467  : static void OPTQUAL Set_h( void ) {  PrintUsage();  exit(1); }

	sub	rsp, 40					; 00000028H
	call	PrintUsage
	mov	ecx, 1
	call	exit
	int	3
$LN3@Set_h:
Set_h	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_zt	PROC

; 465  : static void OPTQUAL Set_zt( void ) { Options.stdcall_decoration = OptValue; }

	movzx	eax, BYTE PTR OptValue
	mov	BYTE PTR Options+118, al
	ret	0
Set_zt	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_zf	PROC

; 462  : static void OPTQUAL Set_zf( void )  { Options.fctype = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+168, eax
	ret	0
Set_zf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_zcm	PROC

; 460  : static void OPTQUAL Set_zcm( void ) { Options.no_cdecl_decoration = FALSE; }

	mov	BYTE PTR Options+117, 0
	ret	0
Set_zcm	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_ofmt PROC

; 456  :     Options.output_format = OptValue & 0xff;

	mov	ecx, DWORD PTR OptValue
	movzx	eax, cl

; 457  :     Options.sub_format = OptValue >> 8;

	shr	ecx, 8
	mov	DWORD PTR Options+148, ecx
	mov	DWORD PTR Options+144, eax

; 458  : }

	ret	0
Set_ofmt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_W	PROC

; 447  :     if ( OptValue <= 4 )

	mov	eax, DWORD PTR OptValue
	cmp	eax, 4
	ja	SHORT $LN2@Set_W

; 448  :         Options.warning_level = OptValue;

	mov	BYTE PTR Options+13, al

; 451  : }

	ret	0
$LN2@Set_W:

; 449  :     else
; 450  :         EmitWarn( 1, INVALID_CMDLINE_VALUE, "W" );

	lea	r8, OFFSET FLAT:$SG11283
	mov	edx, 195				; 000000c3H
	mov	ecx, 1
	jmp	EmitWarn
Set_W	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_w	PROC

; 442  : static void OPTQUAL Set_w( void ) { Set_WX(); Options.warning_level = 0; }

	mov	WORD PTR Options+13, 256		; 00000100H
	ret	0
Set_w	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_WX	PROC

; 440  : static void OPTQUAL Set_WX( void ) { Options.warning_error = TRUE; }

	mov	BYTE PTR Options+14, 1
	ret	0
Set_WX	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_n	PROC

; 434  : static void OPTQUAL Set_n( void ) { set_option_n_name( OptValue, OptName ); }

	mov	rdx, QWORD PTR OptName
	mov	ecx, DWORD PTR OptValue
	jmp	set_option_n_name
Set_n	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_m	PROC

; 433  : static void OPTQUAL Set_m( void ) { Options.model = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+160, eax
	ret	0
Set_m	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_True PROC

; 429  :     char *p = ((char *)&Options) + OptValue;

	mov	eax, DWORD PTR OptValue
	lea	rcx, OFFSET FLAT:Options

; 430  :     *p = TRUE;

	mov	BYTE PTR [rax+rcx], 1

; 431  : }

	ret	0
Set_True ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Sa	PROC

; 421  :     Options.listif = TRUE;

	mov	WORD PTR Options+130, 257		; 00000101H

; 422  :     Options.list_generated_code = TRUE;
; 423  :     Options.list_macro = LM_LISTMACROALL;

	mov	DWORD PTR Options+132, 2

; 424  : }

	ret	0
Set_Sa	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_G	PROC

; 416  : static void OPTQUAL Set_G( void ) { Options.langtype = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+156, eax
	ret	0
Set_G	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_FPx	PROC

; 415  : static void OPTQUAL Set_FPx( void ) { Options.floating_point = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+4, eax
	ret	0
Set_FPx	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_fp	PROC

; 414  : static void OPTQUAL Set_fp( void ) { Options.cpu &= ~P_FPU_MASK; Options.cpu = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+164, eax
	ret	0
Set_fp	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Fo	PROC

; 412  : static void OPTQUAL Set_Fo( void ) { get_fname( OPTN_OBJ_FN, GetAFileName() ); }

	mov	rdx, QWORD PTR OptName
	mov	ecx, 1
	jmp	get_fname
Set_Fo	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Fl	PROC

; 411  : static void OPTQUAL Set_Fl( void ) { get_fname( OPTN_LST_FN, GetAFileName() ); Options.write_listing = TRUE;}

	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR OptName
	mov	ecx, 2
	call	get_fname
	mov	BYTE PTR Options+121, 1
	add	rsp, 40					; 00000028H
	ret	0
Set_Fl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Fw	PROC

; 410  : static void OPTQUAL Set_Fw( void ) { get_fname( OPTN_ERR_FN, GetAFileName() ); }

	mov	rdx, QWORD PTR OptName
	mov	ecx, 3
	jmp	get_fname
Set_Fw	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
name$1 = 32
Set_Fd	PROC

; 408  : static void OPTQUAL Set_Fd( void ) { get_fname( OPTN_LNKDEF_FN, GetAFileName() ); Options.write_impdef = TRUE;}

	push	rbx
	sub	rsp, 304				; 00000130H
	mov	rbx, QWORD PTR OptName
	mov	rcx, rbx
	call	GetFNamePart
	cmp	BYTE PTR [rax], 0
	je	$LN19@Set_Fd
	lea	rcx, QWORD PTR name$1[rsp]
	mov	BYTE PTR name$1[rsp], 0
	dec	rcx
	npad	2
$LL17@Set_Fd:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL17@Set_Fd
	xor	edx, edx
	npad	4
$LL18@Set_Fd:
	movzx	eax, BYTE PTR [rbx+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL18@Set_Fd
	mov	rcx, QWORD PTR Options+48
	test	rcx, rcx
	je	SHORT $LN8@Set_Fd
	call	MemFree
$LN8@Set_Fd:
	lea	rax, QWORD PTR name$1[rsp]
	or	rcx, -1
	npad	7
$LL16@Set_Fd:
	inc	rcx
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL16@Set_Fd
	inc	rcx
	call	MemAlloc
	mov	QWORD PTR Options+48, rax
	lea	rdx, QWORD PTR name$1[rsp]
	npad	3
$LL12@Set_Fd:
	movzx	ecx, BYTE PTR [rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL12@Set_Fd
$LN19@Set_Fd:
	mov	BYTE PTR Options+122, 1
	add	rsp, 304				; 00000130H
	pop	rbx
	ret	0
Set_Fd	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_EP	PROC

; 405  : static void OPTQUAL Set_EP( void ) { Options.preprocessor_stdout = TRUE; Set_q(); }

	mov	BYTE PTR Options+125, 1
	mov	BYTE PTR banner_printed, 1
	mov	BYTE PTR Options, 1
	ret	0
Set_EP	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_q	PROC

; 404  : static void OPTQUAL Set_q( void )      { Set_nologo(); Options.quiet = TRUE; }

	mov	BYTE PTR banner_printed, 1
	mov	BYTE PTR Options, 1
	ret	0
Set_q	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_nologo PROC

; 403  : static void OPTQUAL Set_nologo( void ) { banner_printed = TRUE; }

	mov	BYTE PTR banner_printed, 1
	ret	0
Set_nologo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_e	PROC

; 401  : static void OPTQUAL Set_e( void ) { Options.error_limit = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+8, eax
	ret	0
Set_e	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_I	PROC

; 399  : static void OPTQUAL Set_I( void )  { queue_item( OPTQ_INCPATH,  GetAFileName() ); }

	mov	rdx, QWORD PTR OptName
	mov	ecx, 2
	jmp	queue_item
Set_I	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Fi	PROC

; 398  : static void OPTQUAL Set_Fi( void ) { queue_item( OPTQ_FINCLUDE, GetAFileName() ); }

	mov	rdx, QWORD PTR OptName
	xor	ecx, ecx
	jmp	queue_item
Set_Fi	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_D	PROC

; 397  : static void OPTQUAL Set_D( void )  { queue_item( OPTQ_MACRO,    GetAFileName() ); }

	mov	rdx, QWORD PTR OptName
	mov	ecx, 1
	jmp	queue_item
Set_D	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Zp	PROC

; 387  :     uint_8 power;
; 388  :     for ( power = 0; (1 << power) <= MAX_STRUCT_ALIGN; power++ )

	mov	edx, DWORD PTR OptValue
	xor	cl, cl
	mov	eax, 1
	npad	3
$LL4@Set_Zp:

; 389  :         if ( ( 1 << power ) == OptValue ) {

	cmp	eax, edx
	je	SHORT $LN8@Set_Zp

; 387  :     uint_8 power;
; 388  :     for ( power = 0; (1 << power) <= MAX_STRUCT_ALIGN; power++ )

	inc	cl
	mov	eax, 1
	shl	eax, cl
	cmp	eax, 32					; 00000020H
	jle	SHORT $LL4@Set_Zp

; 391  :             return;
; 392  :         }
; 393  :     EmitWarn( 1, INVALID_CMDLINE_VALUE, "Zp" );

	lea	r8, OFFSET FLAT:$SG11215
	mov	edx, 195				; 000000c3H
	mov	ecx, 1
	jmp	EmitWarn
$LN8@Set_Zp:

; 390  :             Options.fieldalign = power;

	mov	BYTE PTR Options+152, cl

; 394  :     return;
; 395  : }

	ret	0
Set_Zp	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Zi	PROC

; 375  :     Set_Zd();
; 376  :     Options.debug_symbols = CV_SIGNATURE;
; 377  :     /* v2.10: added optional numeric argument for -Zi */
; 378  :     if ( OptValue <= CVEX_MAX )

	mov	eax, DWORD PTR OptValue
	mov	WORD PTR Options+1, 257			; 00000101H
	cmp	eax, 3
	ja	SHORT $LN2@Set_Zi

; 379  :         Options.debug_ext = OptValue;

	mov	BYTE PTR Options+3, al

; 382  : }

	ret	0
$LN2@Set_Zi:

; 380  :     else
; 381  :         EmitWarn( 1, INVALID_CMDLINE_VALUE, "Zi" );

	lea	r8, OFFSET FLAT:$SG11206
	mov	edx, 195				; 000000c3H
	mov	ecx, 1
	jmp	EmitWarn
Set_Zi	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Zd	PROC

; 372  : static void OPTQUAL Set_Zd( void ) { Options.line_numbers = TRUE; }

	mov	BYTE PTR Options+1, 1
	ret	0
Set_Zd	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Cx	PROC

; 370  : static void OPTQUAL Set_Cx( void ) { Options.case_sensitive = FALSE;  Options.convert_uppercase = FALSE; }

	mov	WORD PTR Options+123, 0
	ret	0
Set_Cx	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Cu	PROC

; 369  : static void OPTQUAL Set_Cu( void ) { Options.case_sensitive = FALSE;  Options.convert_uppercase = TRUE;  }

	mov	WORD PTR Options+123, 256		; 00000100H
	ret	0
Set_Cu	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Cp	PROC

; 368  : static void OPTQUAL Set_Cp( void ) { Options.case_sensitive = TRUE;   Options.convert_uppercase = FALSE; }

	mov	WORD PTR Options+123, 1
	ret	0
Set_Cp	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_c	PROC

; 362  : static void OPTQUAL Set_c( void ) { }

	ret	0
Set_c	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
;	COMDAT set_option_n_name
_TEXT	SEGMENT
idx$ = 48
name$ = 56
set_option_n_name PROC					; COMDAT

; 343  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 344  :     if ( *name != '.' && !is_valid_id_char( *name ) ) {

	movzx	eax, BYTE PTR [rdx]
	mov	rbx, rdx
	movsxd	rdi, ecx
	cmp	al, 46					; 0000002eH
	je	SHORT $LN2@set_option
	movsx	ecx, al
	call	isalnum
	test	eax, eax
	jne	SHORT $LN2@set_option
	movzx	eax, BYTE PTR [rbx]
	sub	al, 36					; 00000024H
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN9@set_option
	mov	rcx, 576460752706076673			; 0800000018000001H
	bt	rcx, rax
	jb	SHORT $LN2@set_option
$LN9@set_option:

; 345  :         EmitError( N_OPTION_NEEDS_A_NAME_PARAMETER );

	mov	ecx, 234				; 000000eaH

; 354  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 345  :         EmitError( N_OPTION_NEEDS_A_NAME_PARAMETER );

	jmp	EmitError
$LN2@set_option:

; 346  :         return;
; 347  :     }
; 348  : 
; 349  :     if( Options.names[idx] != NULL ) {

	lea	rcx, OFFSET FLAT:Options+16
	lea	rdi, QWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN3@set_option

; 350  :         MemFree( Options.names[idx] );

	call	MemFree
$LN3@set_option:

; 351  :     }
; 352  :     Options.names[idx] = MemAlloc( strlen( name ) + 1 );

	or	rcx, -1
	npad	4
$LL11@set_option:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], 0
	jne	SHORT $LL11@set_option
	inc	rcx
	call	MemAlloc
	mov	QWORD PTR [rdi], rax
	npad	12
$LL5@set_option:

; 353  :     strcpy( Options.names[idx], name );

	movzx	ecx, BYTE PTR [rbx]
	lea	rbx, QWORD PTR [rbx+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL5@set_option

; 354  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
set_option_n_name ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
;	COMDAT get_fname
_TEXT	SEGMENT
name$ = 32
type$ = 320
token$ = 328
get_fname PROC						; COMDAT

; 287  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 304				; 00000130H
	movsxd	rdi, ecx
	mov	rbx, rdx

; 288  :     const char  *pName;
; 289  :     char        name [ FILENAME_MAX ];
; 290  : 
; 291  :     DebugMsg(("get_fname( type=%u, >%s< ) enter\n", type, token ));
; 292  :     //_splitpath( token, drive, dir, fname, ext );
; 293  :     pName = GetFNamePart( token );

	mov	rcx, rdx
	call	GetFNamePart

; 294  :     /*
; 295  :      * If name's ending with a '\' (or '/' in Unix), it's supposed
; 296  :      * to be a directory name only.
; 297  :      */
; 298  :     if( *pName == NULLC ) {

	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN2@get_fname

; 299  :         DebugMsg(("get_fname(%u, >%s< ) name is empty or a directory\n", type, token ));
; 300  :         /* v2.10: ensure type is < NUM_FILE_TYPES */
; 301  :         if ( type < NUM_FILE_TYPES ) {

	cmp	edi, 4
	jge	$LN1@get_fname

; 302  :             if ( DefaultDir[type] )

	mov	rax, rdi
	lea	r8, OFFSET FLAT:__ImageBase
	lea	rdi, QWORD PTR DefaultDir[r8]
	mov	rcx, QWORD PTR [rdi+rax*8]
	lea	rdi, QWORD PTR [rdi+rax*8]
	test	rcx, rcx
	je	SHORT $LN4@get_fname

; 303  :                 MemFree( DefaultDir[type]);

	call	MemFree
$LN4@get_fname:

; 304  :             DefaultDir[type] = MemAlloc( strlen( token ) + 1 );

	or	rcx, -1
$LL23@get_fname:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], 0
	jne	SHORT $LL23@get_fname
	inc	rcx
	call	MemAlloc
	mov	QWORD PTR [rdi], rax
	npad	12
$LL8@get_fname:

; 305  :             strcpy( DefaultDir[type], token );

	movzx	ecx, BYTE PTR [rbx]
	lea	rbx, QWORD PTR [rbx+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL8@get_fname

; 333  : }

	mov	rbx, QWORD PTR [rsp+320]
	add	rsp, 304				; 00000130H
	pop	rdi
	ret	0
$LN2@get_fname:

; 306  :         }
; 307  :         return;
; 308  :     }
; 309  :     /* v2.10: ensure type is < NUM_FILE_TYPES */
; 310  :     //if ( drive[0] == NULLC && dir[0] == NULLC && type < NUM_FILE_TYPES && DefaultDir[type] ) {
; 311  :     name[0] = NULLC;

	mov	BYTE PTR name$[rsp], 0

; 312  :     if ( pName == token && type < NUM_FILE_TYPES && DefaultDir[type] ) {

	lea	r8, OFFSET FLAT:__ImageBase
	cmp	rax, rbx
	jne	SHORT $LN5@get_fname
	cmp	edi, 4
	jge	SHORT $LN5@get_fname
	mov	rcx, QWORD PTR DefaultDir[r8+rdi*8]
	test	rcx, rcx
	je	SHORT $LN5@get_fname

; 313  :         DebugMsg(("get_fname: default drive+dir used: %s\n" ));
; 314  :         //_splitpath( DefaultDir[type], drive, dir, NULL, NULL );
; 315  :         strcpy( name, DefaultDir[type] );

	lea	rdx, QWORD PTR name$[rsp]
	sub	rdx, rcx
	npad	3
$LL9@get_fname:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rdx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL9@get_fname
$LN5@get_fname:

; 316  :     }
; 317  :     strcat( name, token );

	lea	rcx, QWORD PTR name$[rsp]
	dec	rcx
$LL21@get_fname:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL21@get_fname
	xor	edx, edx
	npad	14
$LL22@get_fname:
	movzx	eax, BYTE PTR [rbx+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL22@get_fname

; 318  : #if 0 /* v2.12: extension will be set in SetFileNames() */
; 319  :     if( type && type < NUM_FILE_TYPES ) {
; 320  :         char *pExt = GetExtPart( name );
; 321  :         if ( *pExt == NULLC ) {
; 322  :             *pExt++ = '.';
; 323  :             strcpy( pExt, DefaultExt[type-1] );
; 324  :         }
; 325  :     }
; 326  : #endif
; 327  :     //_makepath( name, drive, dir, fname, pExt );
; 328  :     if( Options.names[type] != NULL ) {

	lea	rbx, QWORD PTR Options[r8+16]
	mov	rcx, QWORD PTR [rbx+rdi*8]
	lea	rbx, QWORD PTR [rbx+rdi*8]
	test	rcx, rcx
	je	SHORT $LN6@get_fname

; 329  :         MemFree( Options.names[type] );

	call	MemFree
$LN6@get_fname:

; 330  :     }
; 331  :     Options.names[type] = MemAlloc( strlen( name ) + 1 );

	lea	rax, QWORD PTR name$[rsp]
	or	rcx, -1
$LL20@get_fname:
	inc	rcx
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL20@get_fname
	inc	rcx
	call	MemAlloc
	mov	QWORD PTR [rbx], rax

; 332  :     strcpy( Options.names[type], name );

	lea	rdx, QWORD PTR name$[rsp]
	npad	6
$LL10@get_fname:
	movzx	ecx, BYTE PTR [rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL10@get_fname
$LN1@get_fname:

; 333  : }

	mov	rbx, QWORD PTR [rsp+320]
	add	rsp, 304				; 00000130H
	pop	rdi
	ret	0
get_fname ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
;	COMDAT queue_item
_TEXT	SEGMENT
i$ = 48
string$ = 56
queue_item PROC						; COMDAT

; 263  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, ecx
	mov	rbx, rdx

; 264  :     struct qitem *p;
; 265  :     struct qitem *q;
; 266  : 
; 267  :     DebugMsg(("queue_item(%u, %s) enter\n", i, string));
; 268  :     p = MemAlloc( sizeof(struct qitem) + strlen( string ) );

	or	rcx, -1
$LL16@queue_item:
	inc	rcx
	cmp	BYTE PTR [rdx+rcx], 0
	jne	SHORT $LL16@queue_item
	add	rcx, 16
	call	MemAlloc

; 269  :     p->next = NULL;
; 270  :     strcpy( p->value, string );

	mov	rdx, rax
	mov	r8, rax
	sub	rdx, rbx
	mov	QWORD PTR [rax], 0
	npad	10
$LL8@queue_item:
	movzx	ecx, BYTE PTR [rbx]
	mov	BYTE PTR [rdx+rbx+8], cl
	lea	rbx, QWORD PTR [rbx+1]
	test	cl, cl
	jne	SHORT $LL8@queue_item

; 271  :     q = Options.queues[i];

	lea	rcx, OFFSET FLAT:Options+88
	lea	rdx, QWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rcx+rdi*8]

; 272  :     if ( q ) {

	test	rcx, rcx
	je	SHORT $LN5@queue_item

; 273  :         for ( ; q->next; q = q->next );

	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	SHORT $LN3@queue_item
	npad	5
$LL4@queue_item:
	mov	rcx, rax
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL4@queue_item
$LN3@queue_item:

; 274  :         q->next = p;

	mov	QWORD PTR [rcx], r8

; 277  :     return;
; 278  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN5@queue_item:

; 275  :     } else
; 276  :         Options.queues[i] = p;

	mov	QWORD PTR [rdx], rax

; 277  :     return;
; 278  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
queue_item ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
;	COMDAT SetCpuCmdline
_TEXT	SEGMENT
value$ = 8
parm$ = 16
SetCpuCmdline PROC					; COMDAT

; 228  : 
; 229  :     Options.cpu &= ~(P_CPU_MASK | P_EXT_MASK | P_PM);

	mov	eax, DWORD PTR Options+164
	and	eax, -65529				; ffffffffffff0007H

; 230  :     Options.cpu |= value;

	or	eax, ecx
	mov	DWORD PTR Options+164, eax

; 231  : 
; 232  :     for( ; *parm ; parm++ ) {

	movzx	ecx, BYTE PTR [rdx]
	test	cl, cl
	je	SHORT $LN3@SetCpuCmdl
	npad	6
$LL4@SetCpuCmdl:

; 233  :         if( *parm == 'p' && Options.cpu >= P_286 ) {

	cmp	cl, 112					; 00000070H
	jne	SHORT $LN5@SetCpuCmdl
	cmp	eax, 32					; 00000020H
	jl	SHORT $LN5@SetCpuCmdl

; 234  :             Options.cpu |= P_PM;      /* set privileged mode */

	inc	rdx
	or	eax, 8
	mov	DWORD PTR Options+164, eax
	movzx	ecx, BYTE PTR [rdx]
	test	cl, cl
	jne	SHORT $LL4@SetCpuCmdl

; 252  :             break;
; 253  :         }
; 254  :     }
; 255  : }

	ret	0
$LN5@SetCpuCmdl:

; 235  : #if MANGLERSUPP
; 236  :         } else if( *parm == '"' ) {       /* set default mangler */
; 237  :             char *dest;
; 238  :             parm++;
; 239  :             dest = strchr( parm, '"' );
; 240  :             if( Options.names[OPTN_DEFNAME_MANGLER] != NULL ) {
; 241  :                 MemFree( Options.names[OPTN_DEFNAME_MANGLER );
; 242  :             }
; 243  :             Options.names[OPTN_DEFNAME_MANGLER = MemAlloc( dest - parm + 1 );
; 244  :             dest = Options.names[OPTN_DEFNAME_MANGLER];
; 245  :             for( ; *parm != '"'; dest++, parm++ ) {
; 246  :                 *dest = *parm;
; 247  :             }
; 248  :             *dest = NULLC;
; 249  : #endif
; 250  :         } else {
; 251  :             EmitWarn( 1, CPU_OPTION_INVALID, parm );

	mov	r8, rdx
	mov	ecx, 1
	mov	edx, 134				; 00000086H
	jmp	EmitWarn
$LN3@SetCpuCmdl:

; 252  :             break;
; 253  :         }
; 254  :     }
; 255  : }

	ret	0
SetCpuCmdline ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
CmdlineFini PROC

; 1064 : {

$LN34:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1065 :     int i;
; 1066 :     DebugMsg(("CmdLineFini enter\n" ));
; 1067 :     for ( i = 0; i < NUM_FILE_TYPES; i++ ) {

	lea	rbx, OFFSET FLAT:DefaultDir
	mov	edi, 4
	xor	esi, esi
$LL4@CmdlineFin:

; 1068 :         if ( DefaultDir[i] != NULL ) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN2@CmdlineFin

; 1069 :             MemFree( DefaultDir[i] );

	call	MemFree

; 1070 :             DefaultDir[i] = NULL;

	mov	QWORD PTR [rbx], rsi
$LN2@CmdlineFin:

; 1065 :     int i;
; 1066 :     DebugMsg(("CmdLineFini enter\n" ));
; 1067 :     for ( i = 0; i < NUM_FILE_TYPES; i++ ) {

	add	rbx, 8
	sub	rdi, 1
	jne	SHORT $LL4@CmdlineFin

; 1071 :         }
; 1072 :     }
; 1073 :     for ( i = 0; i < OPTN_LAST; i++ )

	lea	rbx, OFFSET FLAT:Options+16
	mov	edi, 9
$LL7@CmdlineFin:

; 1074 :         if ( Options.names[i] != NULL ) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN5@CmdlineFin

; 1075 :             MemFree( Options.names[i] );

	call	MemFree

; 1076 :             Options.names[i] = NULL;

	mov	QWORD PTR [rbx], rsi
$LN5@CmdlineFin:

; 1071 :         }
; 1072 :     }
; 1073 :     for ( i = 0; i < OPTN_LAST; i++ )

	add	rbx, 8
	sub	rdi, 1
	jne	SHORT $LL7@CmdlineFin

; 1077 :         }
; 1078 :     for ( i = 0; i < OPTQ_LAST; i++ ) {

	lea	rdi, OFFSET FLAT:Options+88
	lea	rbp, OFFSET FLAT:Options+112
$LL10@CmdlineFin:

; 1079 :         struct qitem *p;
; 1080 :         struct qitem *q;
; 1081 :         for ( q = Options.queues[i]; q; ) {

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN12@CmdlineFin
$LL11@CmdlineFin:

; 1082 :             p = q->next;

	mov	rbx, QWORD PTR [rcx]

; 1083 :             MemFree( q );

	call	MemFree

; 1084 :             q = p;

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL11@CmdlineFin
$LN12@CmdlineFin:

; 1085 :         }
; 1086 :         Options.queues[i] = NULL;

	mov	QWORD PTR [rdi], rsi
	add	rdi, 8
	cmp	rdi, rbp
	jl	SHORT $LL10@CmdlineFin

; 1087 :     }
; 1088 :     DebugMsg(("CmdLineFini exit\n" ));
; 1089 :     return;
; 1090 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CmdlineFini ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
paramfile$ = 32
cmdline$ = 336
pCntArgs$ = 344
ParseCmdline PROC

; 967  : {

$LN116:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r14
	sub	rsp, 304				; 00000130H

; 968  :     int i;
; 969  :     const char *str = *cmdline;

	mov	rbx, QWORD PTR [rcx]
	lea	rdi, OFFSET FLAT:Options+16
	mov	rbp, rdx
	mov	r14, rcx
	mov	esi, 4
	xor	r12d, r12d
$LL4@ParseCmdli:

; 973  :         if ( Options.names[i] != NULL ) {

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN2@ParseCmdli

; 974  :             MemFree( Options.names[i] );

	call	MemFree

; 975  :             Options.names[i] = NULL;

	mov	QWORD PTR [rdi], r12
$LN2@ParseCmdli:

; 970  :     char paramfile[FILENAME_MAX];
; 971  : 
; 972  :     for ( i = 0; i < NUM_FILE_TYPES; i++ )

	add	rdi, 8
	sub	rsi, 1
	jne	SHORT $LL4@ParseCmdli

; 976  :         }
; 977  : 
; 978  :     /* enable next line if debug log is to be active, but -dt cannot be set */
; 979  :     //Set_dt();
; 980  : 
; 981  :     for( ; str; ) {

	mov	QWORD PTR [rsp+336], r15
	test	rbx, rbx
	je	$LN6@ParseCmdli
	mov	r8d, DWORD PTR rspidx
	lea	r15, OFFSET FLAT:__ImageBase
	mov	edi, 259				; 00000103H
	or	rsi, -1
	npad	11
$LL5@ParseCmdli:

; 982  :         switch( *str ) {

	movsx	rax, BYTE PTR [rbx]
	cmp	eax, 64					; 00000040H
	ja	$LN21@ParseCmdli
	movzx	eax, BYTE PTR $LN110@ParseCmdli[r15+rax]
	mov	ecx, DWORD PTR $LN111@ParseCmdli[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN11@ParseCmdli:

; 983  :         case ' ':
; 984  :         case '\t':
; 985  :             str++;

	inc	rbx

; 986  :             break;

	jmp	$LN8@ParseCmdli
$LN12@ParseCmdli:

; 987  :         case NULLC:
; 988  :             str = getnextcmdstring( cmdline );

	mov	rcx, r14
	call	getnextcmdstring

; 989  :             break;

	mov	r8d, DWORD PTR rspidx
	mov	rbx, rax
	jmp	$LN8@ParseCmdli
$LN13@ParseCmdli:

; 990  :         case '-':
; 991  : #if SWITCHCHAR
; 992  :         case '/':
; 993  : #endif
; 994  :             str++;

	inc	rbx

; 995  :             *cmdline = str;
; 996  :             ProcessOption( cmdline, paramfile );

	lea	rdx, QWORD PTR paramfile$[rsp]
	mov	rcx, r14
	mov	QWORD PTR [r14], rbx
	call	ProcessOption

; 997  :             (*pCntArgs)++;

	inc	DWORD PTR [rbp]

; 998  :             str = *cmdline;

	mov	rbx, QWORD PTR [r14]

; 999  :             break;

	mov	r8d, DWORD PTR rspidx
	jmp	$LN8@ParseCmdli
$LN14@ParseCmdli:

; 1000 :         case '@':
; 1001 :             if ( rspidx >= MAX_RSP_NESTING ) {

	cmp	r8d, 15
	jge	$LN84@ParseCmdli

; 1005 :             }
; 1006 :             str++;

	inc	rbx

; 1007 : #if 1 /* v2.06: was '0' in v2.05, now '1' again since it didn't work with quoted names */
; 1008 :             /* todo: might be unnecessary since v.2.10, since GetNameToken() handles spaces inside filenames differently */
; 1009 :             if ( rspidx ) {

	test	r8d, r8d
	je	SHORT $LN16@ParseCmdli

; 1010 :                 cmdsave[rspidx] = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );

	cmp	BYTE PTR [rbx], 34			; 00000022H
	lea	rcx, QWORD PTR paramfile$[rsp]
	mov	edx, edi
	je	SHORT $LN82@ParseCmdli
$is_quote$117:
	test	edx, edx
	je	SHORT $LN28@ParseCmdli
	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	SHORT $LN28@ParseCmdli
	cmp	al, 32					; 00000020H
	je	SHORT $LN28@ParseCmdli
	cmp	al, 9
	je	SHORT $LN28@ParseCmdli
	mov	BYTE PTR [rcx], al
	inc	rbx
	inc	rcx
	dec	edx
	jmp	SHORT $is_quote$117
$LN82@ParseCmdli:
	inc	rbx
$LL29@ParseCmdli:
	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	SHORT $LN28@ParseCmdli
	cmp	al, 34					; 00000022H
	je	SHORT $LN83@ParseCmdli
	cmp	al, 92					; 0000005cH
	jne	SHORT $LN36@ParseCmdli
	cmp	BYTE PTR [rbx+1], 34			; 00000022H
	lea	rax, QWORD PTR [rbx+1]
	cmove	rbx, rax
$LN36@ParseCmdli:
	movzx	eax, BYTE PTR [rbx]
	inc	rbx
	mov	BYTE PTR [rcx], al
	inc	rcx
	sub	edx, 1
	jne	SHORT $LL29@ParseCmdli
	movsxd	rax, r8d
	mov	BYTE PTR [rcx], r12b
	mov	QWORD PTR cmdsave[r15+rax*8], rbx

; 1011 :             } else {

	jmp	SHORT $LN17@ParseCmdli
$LN83@ParseCmdli:

; 1010 :                 cmdsave[rspidx] = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );

	inc	rbx
$LN28@ParseCmdli:
	movsxd	rax, r8d
	mov	BYTE PTR [rcx], r12b
	mov	QWORD PTR cmdsave[r15+rax*8], rbx

; 1011 :             } else {

	jmp	SHORT $LN17@ParseCmdli
$LN16@ParseCmdli:

; 1012 :                 strcpy( paramfile, str ); /* fixme: no overflow check */

	lea	rdx, QWORD PTR paramfile$[rsp]
	mov	rcx, rbx
	sub	rdx, rbx
$LL25@ParseCmdli:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rdx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL25@ParseCmdli

; 1013 :                 cmdsave[rspidx] = str + strlen(str);

	mov	rax, rsi
$LL109@ParseCmdli:
	inc	rax
	cmp	BYTE PTR [rbx+rax], r12b
	jne	SHORT $LL109@ParseCmdli
	add	rax, rbx
	mov	QWORD PTR cmdsave, rax
$LN17@ParseCmdli:

; 1014 :             }
; 1015 : #else
; 1016 :             cmdsave[rspidx] = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );
; 1017 : #endif
; 1018 :             cmdbuffers[rspidx] = NULL;

	movsxd	rax, r8d
	mov	QWORD PTR cmdbuffers[r15+rax*8], r12

; 1019 :             str = NULL;
; 1020 :             if ( paramfile[0] )

	cmp	BYTE PTR paramfile$[rsp], r12b
	je	SHORT $LN107@ParseCmdli

; 1021 :                 str = getenv( paramfile );

	lea	rcx, QWORD PTR paramfile$[rsp]
	call	getenv
	mov	rbx, rax

; 1022 :             if( str == NULL ) {

	test	rax, rax
	je	SHORT $LN107@ParseCmdli

; 1027 :                     break;

	mov	r8d, DWORD PTR rspidx
$LN20@ParseCmdli:

; 1028 :                 }
; 1029 :             }
; 1030 :             rspidx++;

	inc	r8d
	mov	DWORD PTR rspidx, r8d
$LN8@ParseCmdli:

; 976  :         }
; 977  : 
; 978  :     /* enable next line if debug log is to be active, but -dt cannot be set */
; 979  :     //Set_dt();
; 980  : 
; 981  :     for( ; str; ) {

	test	rbx, rbx
	jne	$LL5@ParseCmdli
$LN6@ParseCmdli:

; 1055 :         }
; 1056 :     }
; 1057 :     *cmdline = str;

	mov	QWORD PTR [r14], rbx
$LN114@ParseCmdli:

; 1058 :     return( NULL );

	xor	eax, eax
$LN1@ParseCmdli:
	mov	r15, QWORD PTR [rsp+336]

; 1059 : }

	lea	r11, QWORD PTR [rsp+304]
	mov	rbx, QWORD PTR [r11+40]
	mov	rbp, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	r12
	pop	rdi
	ret	0
$LN107@ParseCmdli:

; 1023 :                 str = ReadParamFile( paramfile );

	lea	rcx, QWORD PTR paramfile$[rsp]
	call	ReadParamFile

; 1024 :                 cmdbuffers[rspidx] = str;

	movsxd	r8, DWORD PTR rspidx
	mov	rbx, rax
	mov	QWORD PTR cmdbuffers[r15+r8*8], rax

; 1025 :                 if ( str == NULL ) {

	test	rax, rax
	jne	SHORT $LN20@ParseCmdli

; 1026 :                     str = cmdsave[rspidx];

	mov	rbx, QWORD PTR cmdsave[r15+r8*8]

; 1027 :                     break;

	jmp	SHORT $LN8@ParseCmdli
$LN84@ParseCmdli:

; 1002 :                 EmitErr( NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 100				; 00000064H
	call	EmitErr

; 1003 :                 *cmdline = "";

	lea	rax, OFFSET FLAT:$SG11573
	mov	QWORD PTR [r14], rax

; 1004 :                 return( NULL );

	jmp	SHORT $LN114@ParseCmdli
$LN21@ParseCmdli:

; 1031 :             break;
; 1032 :         default: /* collect  file name */
; 1033 : #if BUILD_TARGET
; 1034 :             set_default_build_target();
; 1035 : #endif
; 1036 : #if 1 /* v2.06: activated (was removed in v2.05). Needed for quoted filenames */
; 1037 :             if ( rspidx ) {

	test	r8d, r8d
	je	$LL22@ParseCmdli

; 1038 :                 str = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );

	cmp	BYTE PTR [rbx], 34			; 00000022H
	lea	rcx, QWORD PTR paramfile$[rsp]
	je	SHORT $LN88@ParseCmdli
$is_quote$118:
	test	edi, edi
	je	SHORT $LN49@ParseCmdli
	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	SHORT $LN49@ParseCmdli
	cmp	al, 32					; 00000020H
	je	SHORT $LN49@ParseCmdli
	cmp	al, 9
	je	SHORT $LN49@ParseCmdli
	mov	BYTE PTR [rcx], al
	inc	rbx
	inc	rcx
	dec	edi
	jmp	SHORT $is_quote$118
$LN88@ParseCmdli:
	inc	rbx
$LL50@ParseCmdli:
	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	SHORT $LN49@ParseCmdli
	cmp	al, 34					; 00000022H
	je	SHORT $LN89@ParseCmdli
	cmp	al, 92					; 0000005cH
	jne	SHORT $LN57@ParseCmdli
	cmp	BYTE PTR [rbx+1], 34			; 00000022H
	lea	rax, QWORD PTR [rbx+1]
	cmove	rbx, rax
$LN57@ParseCmdli:
	movzx	eax, BYTE PTR [rbx]
	inc	rbx
	mov	BYTE PTR [rcx], al
	inc	rcx
	sub	edi, 1
	jne	SHORT $LL50@ParseCmdli
	mov	BYTE PTR [rcx], r12b

; 1039 :                 get_fname( OPTN_ASM_FN, paramfile );

	lea	rdx, QWORD PTR paramfile$[rsp]
	xor	ecx, ecx
	call	get_fname

; 1045 :             }
; 1046 : #else
; 1047 :             str = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );
; 1048 :             Options.names[ASM] = MemAlloc( strlen( paramfile ) + 1 );
; 1049 :             strcpy( Options.names[ASM], paramfile );
; 1050 : #endif
; 1051 :             DebugMsg(("ParseCmdLine: file=>%s< rest=>%s<\n", Options.names[ASM], str ? str : "NULL" ));
; 1052 :             (*pCntArgs)++;

	inc	DWORD PTR [rbp]

; 1053 :             *cmdline = str;

	mov	QWORD PTR [r14], rbx

; 1054 :             return( Options.names[ASM] );

	mov	rax, QWORD PTR Options+16
	jmp	$LN1@ParseCmdli
$LN89@ParseCmdli:

; 1038 :                 str = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );

	inc	rbx
$LN49@ParseCmdli:
	mov	BYTE PTR [rcx], r12b

; 1039 :                 get_fname( OPTN_ASM_FN, paramfile );

	lea	rdx, QWORD PTR paramfile$[rsp]
	xor	ecx, ecx
	call	get_fname

; 1045 :             }
; 1046 : #else
; 1047 :             str = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );
; 1048 :             Options.names[ASM] = MemAlloc( strlen( paramfile ) + 1 );
; 1049 :             strcpy( Options.names[ASM], paramfile );
; 1050 : #endif
; 1051 :             DebugMsg(("ParseCmdLine: file=>%s< rest=>%s<\n", Options.names[ASM], str ? str : "NULL" ));
; 1052 :             (*pCntArgs)++;

	inc	DWORD PTR [rbp]

; 1053 :             *cmdline = str;

	mov	QWORD PTR [r14], rbx

; 1054 :             return( Options.names[ASM] );

	mov	rax, QWORD PTR Options+16
	jmp	$LN1@ParseCmdli
$LL22@ParseCmdli:

; 1040 :             } else {
; 1041 :                 int len;
; 1042 :                 len = strlen( str );

	inc	rsi
	cmp	BYTE PTR [rbx+rsi], r12b
	jne	SHORT $LL22@ParseCmdli

; 1043 :                 get_fname( OPTN_ASM_FN, str );

	mov	rdx, rbx
	xor	ecx, ecx
	call	get_fname

; 1044 :                 str += len;

	movsxd	rax, esi
	add	rbx, rax

; 1045 :             }
; 1046 : #else
; 1047 :             str = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );
; 1048 :             Options.names[ASM] = MemAlloc( strlen( paramfile ) + 1 );
; 1049 :             strcpy( Options.names[ASM], paramfile );
; 1050 : #endif
; 1051 :             DebugMsg(("ParseCmdLine: file=>%s< rest=>%s<\n", Options.names[ASM], str ? str : "NULL" ));
; 1052 :             (*pCntArgs)++;

	inc	DWORD PTR [rbp]

; 1053 :             *cmdline = str;

	mov	QWORD PTR [r14], rbx

; 1054 :             return( Options.names[ASM] );

	mov	rax, QWORD PTR Options+16
	jmp	$LN1@ParseCmdli
	npad	3
$LN111@ParseCmdli:

; 1059 : }

	DD	$LN12@ParseCmdli
	DD	$LN11@ParseCmdli
	DD	$LN13@ParseCmdli
	DD	$LN14@ParseCmdli
	DD	$LN21@ParseCmdli
$LN110@ParseCmdli:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
ParseCmdline ENDP
_TEXT	ENDS
END
