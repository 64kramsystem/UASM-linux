; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
CONST	SEGMENT
optiontab DQ	FLAT:$SG11261
	DQ	FLAT:SetDotName
	DQ	FLAT:$SG11262
	DQ	FLAT:SetNoDotName
	DQ	FLAT:$SG11263
	DQ	FLAT:SetM510
	DQ	FLAT:$SG11264
	DQ	FLAT:SetNoM510
	DQ	FLAT:$SG11265
	DQ	FLAT:SetScoped
	DQ	FLAT:$SG11266
	DQ	FLAT:SetNoScoped
	DQ	FLAT:$SG11267
	DQ	FLAT:SetOldStructs
	DQ	FLAT:$SG11268
	DQ	FLAT:SetNoOldStructs
	DQ	FLAT:$SG11269
	DQ	FLAT:SetEmulator
	DQ	FLAT:$SG11270
	DQ	FLAT:SetNoEmulator
	DQ	FLAT:$SG11271
	DQ	FLAT:SetLJmp
	DQ	FLAT:$SG11272
	DQ	FLAT:SetNoLJmp
	DQ	FLAT:$SG11273
	DQ	FLAT:Unsupported
	DQ	FLAT:$SG11274
	DQ	FLAT:SetNoReadonly
	DQ	FLAT:$SG11275
	DQ	FLAT:Unsupported
	DQ	FLAT:$SG11276
	DQ	FLAT:SetNoOldmacros
	DQ	FLAT:$SG11277
	DQ	FLAT:Unsupported
	DQ	FLAT:$SG11278
	DQ	FLAT:SetExpr32
	DQ	FLAT:$SG11279
	DQ	FLAT:SetNoSignExt
	DQ	FLAT:$SG11280
	DQ	FLAT:SetCaseMap
	DQ	FLAT:$SG11281
	DQ	FLAT:SetProc
	DQ	FLAT:$SG11282
	DQ	FLAT:SetPrologue
	DQ	FLAT:$SG11283
	DQ	FLAT:SetEpilogue
	DQ	FLAT:$SG11284
	DQ	FLAT:SetLanguage
	DQ	FLAT:$SG11285
	DQ	FLAT:SetNoKeyword
	DQ	FLAT:$SG11286
	DQ	FLAT:SetSetIF2
	DQ	FLAT:$SG11287
	DQ	FLAT:SetOffset
	DQ	FLAT:$SG11288
	DQ	FLAT:SetSegment
	DQ	FLAT:$SG11289
	DQ	FLAT:SetFieldAlign
	DQ	FLAT:$SG11290
	DQ	FLAT:SetProcAlign
	DQ	FLAT:$SG11291
	DQ	FLAT:SetMZ
	DQ	FLAT:$SG11292
	DQ	FLAT:SetFrame
	DQ	FLAT:$SG11293
	DQ	FLAT:SetElf
	DQ	FLAT:$SG11294
	DQ	FLAT:SetRenameKey
	DQ	FLAT:$SG11295
	DQ	FLAT:SetWin64
	DQ	FLAT:$SG11296
	DQ	FLAT:SetDllImport
	DQ	FLAT:$SG11297
	DQ	FLAT:SetCodeView
	DQ	FLAT:$SG11298
	DQ	FLAT:SetStackBase
	DQ	FLAT:$SG11299
	DQ	FLAT:SetEvex
	DQ	FLAT:$SG11300
	DQ	FLAT:SetZeroLocals
	DQ	FLAT:$SG11301
	DQ	FLAT:SetSwitchStile
CONST	ENDS
_DATA	SEGMENT
$SG11264 DB	'NOM510', 00H
	ORG $+1
$SG11265 DB	'SCOPED', 00H
	ORG $+1
$SG11266 DB	'NOSCOPED', 00H
	ORG $+3
$SG11272 DB	'NOLJMP', 00H
	ORG $+1
$SG11291 DB	'MZ', 00H
	ORG $+1
$SG11267 DB	'OLDSTRUCTS', 00H
	ORG $+1
$SG11293 DB	'ELF', 00H
$SG11268 DB	'NOOLDSTRUCTS', 00H
	ORG $+3
$SG11269 DB	'EMULATOR', 00H
	ORG $+3
$SG11277 DB	'EXPR16', 00H
	ORG $+1
$SG10824 DB	'ALL', 00H
$SG11270 DB	'NOEMULATOR', 00H
	ORG $+1
$SG11271 DB	'LJMP', 00H
	ORG $+3
$SG11278 DB	'EXPR32', 00H
	ORG $+5
$SG11273 DB	'READONLY', 00H
	ORG $+7
$SG11274 DB	'NOREADONLY', 00H
	ORG $+5
$SG11275 DB	'OLDMACROS', 00H
	ORG $+6
$SG11276 DB	'NOOLDMACROS', 00H
	ORG $+4
$SG11279 DB	'NOSIGNEXTEND', 00H
	ORG $+3
$SG11280 DB	'CASEMAP', 00H
$SG11281 DB	'PROC', 00H
	ORG $+3
$SG11282 DB	'PROLOGUE', 00H
	ORG $+7
$SG11283 DB	'EPILOGUE', 00H
	ORG $+7
$SG11284 DB	'LANGUAGE', 00H
	ORG $+7
$SG11285 DB	'NOKEYWORD', 00H
	ORG $+2
$SG11286 DB	'SETIF2', 00H
	ORG $+1
$SG11287 DB	'OFFSET', 00H
	ORG $+5
$SG11288 DB	'SEGMENT', 00H
$SG11289 DB	'FIELDALIGN', 00H
	ORG $+5
$SG11290 DB	'PROCALIGN', 00H
	ORG $+2
$SG11292 DB	'FRAME', 00H
	ORG $+6
$SG11294 DB	'RENAMEKEYWORD', 00H
	ORG $+2
$SG11295 DB	'WIN64', 00H
	ORG $+2
$SG11296 DB	'DLLIMPORT', 00H
	ORG $+6
$SG11297 DB	'CODEVIEW', 00H
	ORG $+7
$SG11298 DB	'STACKBASE', 00H
	ORG $+2
$SG11299 DB	'EVEX', 00H
	ORG $+7
$SG11300 DB	'ZEROLOCALS', 00H
	ORG $+5
$SG11301 DB	'SWITCHSTYLE', 00H
$SG10818 DB	'NONE', 00H
	ORG $+7
$SG10821 DB	'NOTPUBLIC', 00H
	ORG $+2
$SG10967 DB	'TRUE', 00H
	ORG $+3
$SG10969 DB	'FALSE', 00H
	ORG $+2
$SG10982 DB	'NONE', 00H
	ORG $+7
$SG10985 DB	'PROLOGUEDEF', 00H
$SG10998 DB	'NONE', 00H
	ORG $+7
$SG11001 DB	'EPILOGUEDEF', 00H
$SG11011 DB	'GROUP', 00H
	ORG $+2
$SG11014 DB	'FLAT', 00H
	ORG $+7
$SG11017 DB	'SEGMENT', 00H
$SG11030 DB	'PRIVATE', 00H
$SG11032 DB	'EXPORT', 00H
	ORG $+1
$SG11048 DB	'USE16', 00H
	ORG $+2
$SG11051 DB	'USE32', 00H
	ORG $+2
$SG11054 DB	'USE64', 00H
	ORG $+2
$SG11135 DB	'AUTO', 00H
	ORG $+3
$SG11137 DB	'NOAUTO', 00H
	ORG $+1
$SG11147 DB	'CSTYLE', 00H
	ORG $+1
$SG11149 DB	'ASMSTYLE', 00H
	ORG $+3
$SG11205 DB	'__imp_', 00H
	ORG $+1
$SG11206 DB	'_imp_', 00H
	ORG $+2
$SG11217 DB	'NONE', 00H
	ORG $+7
$SG11247 DB	'@StackBase', 00H
	ORG $+5
$SG11248 DB	'@ProcStatus', 00H
	ORG $+4
$SG11261 DB	'DOTNAME', 00H
$SG11262 DB	'NODOTNAME', 00H
	ORG $+2
$SG11263 DB	'M510', 00H
_DATA	ENDS
PUBLIC	OptionDirective
EXTRN	isspace:PROC
EXTRN	_stricmp:PROC
EXTRN	_strupr:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	SetMasm510:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymSetCmpFunc:PROC
EXTRN	GetLangType:PROC
EXTRN	FindResWord:PROC
EXTRN	IsKeywordDisabled:PROC
EXTRN	DisableKeyword:PROC
EXTRN	RenameKeyword:PROC
EXTRN	EvalOperand:PROC
EXTRN	EmitConstError:PROC
EXTRN	CreateVariable:PROC
EXTRN	UpdateStackBase:PROC
EXTRN	UpdateProcStatus:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SpecialTable:BYTE
EXTRN	sym_Interface:QWORD
EXTRN	__ImageBase:BYTE
pdata	SEGMENT
$pdata$SetEvex DD imagerel SetEvex
	DD	imagerel SetEvex+143
	DD	imagerel $unwind$SetEvex
$pdata$SetZeroLocals DD imagerel SetZeroLocals
	DD	imagerel SetZeroLocals+143
	DD	imagerel $unwind$SetZeroLocals
$pdata$SetCaseMap DD imagerel SetCaseMap
	DD	imagerel SetCaseMap+224
	DD	imagerel $unwind$SetCaseMap
$pdata$SetM510 DD imagerel SetM510
	DD	imagerel SetM510+18
	DD	imagerel $unwind$SetM510
$pdata$SetNoM510 DD imagerel SetNoM510
	DD	imagerel SetNoM510+18
	DD	imagerel $unwind$SetNoM510
$pdata$SetNoKeyword DD imagerel SetNoKeyword
	DD	imagerel SetNoKeyword+121
	DD	imagerel $unwind$SetNoKeyword
$pdata$2$SetNoKeyword DD imagerel SetNoKeyword+121
	DD	imagerel SetNoKeyword+358
	DD	imagerel $chain$2$SetNoKeyword
$pdata$4$SetNoKeyword DD imagerel SetNoKeyword+358
	DD	imagerel SetNoKeyword+370
	DD	imagerel $chain$4$SetNoKeyword
$pdata$5$SetNoKeyword DD imagerel SetNoKeyword+370
	DD	imagerel SetNoKeyword+395
	DD	imagerel $chain$5$SetNoKeyword
$pdata$SetLanguage DD imagerel SetLanguage
	DD	imagerel SetLanguage+144
	DD	imagerel $unwind$SetLanguage
$pdata$SetSetIF2 DD imagerel SetSetIF2
	DD	imagerel SetSetIF2+115
	DD	imagerel $unwind$SetSetIF2
$pdata$SetPrologue DD imagerel SetPrologue
	DD	imagerel SetPrologue+216
	DD	imagerel $unwind$SetPrologue
$pdata$SetEpilogue DD imagerel SetEpilogue
	DD	imagerel SetEpilogue+216
	DD	imagerel $unwind$SetEpilogue
$pdata$SetOffset DD imagerel SetOffset
	DD	imagerel SetOffset+215
	DD	imagerel $unwind$SetOffset
$pdata$SetProc DD imagerel SetProc
	DD	imagerel SetProc+162
	DD	imagerel $unwind$SetProc
$pdata$SetSegment DD imagerel SetSegment
	DD	imagerel SetSegment+289
	DD	imagerel $unwind$SetSegment
$pdata$SetFieldAlign DD imagerel SetFieldAlign
	DD	imagerel SetFieldAlign+183
	DD	imagerel $unwind$SetFieldAlign
$pdata$SetProcAlign DD imagerel SetProcAlign
	DD	imagerel SetProcAlign+183
	DD	imagerel $unwind$SetProcAlign
$pdata$SetMZ DD	imagerel SetMZ
	DD	imagerel SetMZ+431
	DD	imagerel $unwind$SetMZ
$pdata$SetFrame DD imagerel SetFrame
	DD	imagerel SetFrame+115
	DD	imagerel $unwind$SetFrame
$pdata$SetSwitchStile DD imagerel SetSwitchStile
	DD	imagerel SetSwitchStile+115
	DD	imagerel $unwind$SetSwitchStile
$pdata$SetElf DD imagerel SetElf
	DD	imagerel SetElf+165
	DD	imagerel $unwind$SetElf
$pdata$SetRenameKey DD imagerel SetRenameKey
	DD	imagerel SetRenameKey+85
	DD	imagerel $unwind$SetRenameKey
$pdata$0$SetRenameKey DD imagerel SetRenameKey+85
	DD	imagerel SetRenameKey+137
	DD	imagerel $chain$0$SetRenameKey
$pdata$3$SetRenameKey DD imagerel SetRenameKey+137
	DD	imagerel SetRenameKey+199
	DD	imagerel $chain$3$SetRenameKey
$pdata$5$SetRenameKey DD imagerel SetRenameKey+199
	DD	imagerel SetRenameKey+237
	DD	imagerel $chain$5$SetRenameKey
$pdata$6$SetRenameKey DD imagerel SetRenameKey+237
	DD	imagerel SetRenameKey+288
	DD	imagerel $chain$6$SetRenameKey
$pdata$SetWin64 DD imagerel SetWin64
	DD	imagerel SetWin64+225
	DD	imagerel $unwind$SetWin64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IncludeDll DD imagerel IncludeDll
	DD	imagerel IncludeDll+30
	DD	imagerel $unwind$IncludeDll
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$IncludeDll DD imagerel IncludeDll+30
	DD	imagerel IncludeDll+192
	DD	imagerel $chain$0$IncludeDll
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$IncludeDll DD imagerel IncludeDll+192
	DD	imagerel IncludeDll+206
	DD	imagerel $chain$2$IncludeDll
pdata	ENDS
pdata	SEGMENT
$pdata$SetDllImport DD imagerel SetDllImport
	DD	imagerel SetDllImport+127
	DD	imagerel $unwind$SetDllImport
$pdata$SetCodeView DD imagerel SetCodeView
	DD	imagerel SetCodeView+118
	DD	imagerel $unwind$SetCodeView
$pdata$SetStackBase DD imagerel SetStackBase
	DD	imagerel SetStackBase+229
	DD	imagerel $unwind$SetStackBase
$pdata$OptionDirective DD imagerel $LN37
	DD	imagerel $LN37+394
	DD	imagerel $unwind$OptionDirective
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$IncludeDll DD 020021H
	DD	067400H
	DD	imagerel IncludeDll
	DD	imagerel IncludeDll+30
	DD	imagerel $unwind$IncludeDll
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$IncludeDll DD 020521H
	DD	067405H
	DD	imagerel IncludeDll
	DD	imagerel IncludeDll+30
	DD	imagerel $unwind$IncludeDll
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IncludeDll DD 020601H
	DD	030023206H
xdata	ENDS
xdata	SEGMENT
$unwind$SetEvex DD 030b01H
	DD	014010bH
	DD	03004H
$unwind$SetZeroLocals DD 030b01H
	DD	014010bH
	DD	03004H
$unwind$SetCaseMap DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$SetM510 DD 010401H
	DD	04204H
$unwind$SetNoM510 DD 010401H
	DD	04204H
$unwind$SetNoKeyword DD 040b01H
	DD	09540bH
	DD	0e007320bH
$chain$2$SetNoKeyword DD 061321H
	DD	087413H
	DD	07640eH
	DD	063405H
	DD	imagerel SetNoKeyword
	DD	imagerel SetNoKeyword+121
	DD	imagerel $unwind$SetNoKeyword
$chain$4$SetNoKeyword DD 060021H
	DD	087400H
	DD	076400H
	DD	063400H
	DD	imagerel SetNoKeyword
	DD	imagerel SetNoKeyword+121
	DD	imagerel $unwind$SetNoKeyword
$chain$5$SetNoKeyword DD 021H
	DD	imagerel SetNoKeyword
	DD	imagerel SetNoKeyword+121
	DD	imagerel $unwind$SetNoKeyword
$unwind$SetLanguage DD 040a01H
	DD	07340aH
	DD	07006320aH
$unwind$SetSetIF2 DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$SetPrologue DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$SetEpilogue DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$SetOffset DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$SetProc DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$SetSegment DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$SetFieldAlign DD 030b01H
	DD	014010bH
	DD	03004H
$unwind$SetProcAlign DD 030b01H
	DD	014010bH
	DD	03004H
$unwind$SetMZ DD 091501H
	DD	01a5415H
	DD	0193415H
	DD	0140115H
	DD	0700ce00eH
	DD	0600bH
$unwind$SetFrame DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$SetSwitchStile DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$SetElf DD 030b01H
	DD	014010bH
	DD	03004H
$unwind$SetRenameKey DD 040b01H
	DD	08740bH
	DD	0e007320bH
$chain$0$SetRenameKey DD 020521H
	DD	076405H
	DD	imagerel SetRenameKey
	DD	imagerel SetRenameKey+85
	DD	imagerel $unwind$SetRenameKey
$chain$3$SetRenameKey DD 040521H
	DD	063405H
	DD	076400H
	DD	imagerel SetRenameKey
	DD	imagerel SetRenameKey+85
	DD	imagerel $unwind$SetRenameKey
$chain$5$SetRenameKey DD 040021H
	DD	076400H
	DD	063400H
	DD	imagerel SetRenameKey
	DD	imagerel SetRenameKey+85
	DD	imagerel $unwind$SetRenameKey
$chain$6$SetRenameKey DD 021H
	DD	imagerel SetRenameKey
	DD	imagerel SetRenameKey+85
	DD	imagerel $unwind$SetRenameKey
$unwind$SetWin64 DD 030901H
	DD	0140109H
	DD	03002H
$unwind$SetDllImport DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$SetCodeView DD 030b01H
	DD	014010bH
	DD	03004H
$unwind$SetStackBase DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$OptionDirective DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
OptionDirective PROC

; 972  : {

$LN37:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 973  :     int idx = -1;
; 974  : 
; 975  :     DebugMsg1(( "OPTION directive enter, option=%s\n", tokenarray[i+1].string_ptr ));
; 976  : 
; 977  :     i++; /* skip OPTION directive */

	lea	r8d, DWORD PTR [rcx+1]
	or	ebx, -1

; 978  :     while ( tokenarray[i].token != T_FINAL ) {

	movsxd	rcx, r8d
	mov	rdi, rdx
	shl	rcx, 5
	add	rcx, rdx
	mov	DWORD PTR i$[rsp], r8d
	cmp	BYTE PTR [rcx], 0
	je	$LN26@OptionDire
	lea	rbp, OFFSET FLAT:optiontab
	npad	3
$LL2@OptionDire:

; 979  :         _strupr( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rcx+8]
	call	_strupr

; 981  :             if ( 0 == strcmp( tokenarray[i].string_ptr, optiontab[idx].name ) )

	movsxd	r8, DWORD PTR i$[rsp]
	xor	ebx, ebx
	mov	rax, r8
	xor	r11d, r11d
	shl	rax, 5
	mov	r10, rbp
	mov	rsi, QWORD PTR [rax+rdi+8]
$LL6@OptionDire:
	mov	r9, QWORD PTR [r10]
	mov	rax, rsi
	sub	r9, rsi
	npad	5
$LL34@OptionDire:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r9]
	sub	edx, ecx
	jne	SHORT $LN35@OptionDire
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL34@OptionDire
$LN35@OptionDire:
	test	edx, edx
	je	SHORT $LN20@OptionDire

; 980  :         for ( idx = 0; idx < TABITEMS; idx++ ) {

	inc	ebx
	inc	r11
	movsxd	rax, ebx
	add	r10, 16
	cmp	rax, 41					; 00000029H
	jb	SHORT $LL6@OptionDire
$LN20@OptionDire:

; 982  :                 break;
; 983  :         }
; 984  :         if ( idx >= TABITEMS )

	movsxd	rax, ebx
	cmp	rax, 41					; 00000029H
	jae	$LN26@OptionDire

; 985  :             break;
; 986  :         i++;

	inc	r8d
	mov	DWORD PTR i$[rsp], r8d

; 987  :         /* v2.06: check for colon separator here */
; 988  :         if ( idx >= NOARGOPTS ) {

	cmp	ebx, 19
	jl	SHORT $LN12@OptionDire

; 989  :             if ( tokenarray[i].token != T_COLON ) {

	movsxd	rax, r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 58			; 0000003aH
	jne	$LN22@OptionDire

; 991  :             }
; 992  :             i++;

	inc	r8d

; 993  :             /* there must be something after the colon */
; 994  :             if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rax, r8d
	shl	rax, 5
	mov	DWORD PTR i$[rsp], r8d
	cmp	BYTE PTR [rax+rdi], 0
	je	SHORT $LN23@OptionDire

; 997  :             }
; 998  :             /* reject option if -Zne is set */
; 999  :             if ( idx >= MASMOPTS && Options.strict_masm_compat ) {

	cmp	ebx, 28
	jl	SHORT $LN12@OptionDire
	cmp	BYTE PTR Options+127, 0
	jne	SHORT $LN23@OptionDire
$LN12@OptionDire:

; 1000 :                 i -= 2;
; 1001 :                 break;
; 1002 :             }
; 1003 :         }
; 1004 :         if ( optiontab[idx].func( &i, tokenarray ) == ERROR )

	add	r11, r11
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rdi
	call	QWORD PTR [rbp+r11*8+8]
	cmp	eax, -1
	je	SHORT $LN25@OptionDire

; 1006 :         if ( tokenarray[i].token != T_COMMA )

	movsxd	r8, DWORD PTR i$[rsp]
	mov	rax, r8
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 44			; 0000002cH
	jne	SHORT $LN26@OptionDire

; 1007 :             break;
; 1008 :         i++;

	inc	r8d
	movsxd	rcx, r8d
	shl	rcx, 5
	add	rcx, rdi
	mov	DWORD PTR i$[rsp], r8d
	cmp	BYTE PTR [rcx], 0
	jne	$LL2@OptionDire
$LN26@OptionDire:

; 1009 :     }
; 1010 :     if ( idx >= TABITEMS  || tokenarray[i].token != T_FINAL ) {

	movsxd	rax, ebx
	cmp	rax, 41					; 00000029H
	jae	SHORT $LN16@OptionDire
	movsxd	rax, r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 0
	jne	SHORT $LN16@OptionDire

; 1013 :     }
; 1014 :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@OptionDire
$LN23@OptionDire:

; 995  :                 i -= 2; /* position back to option identifier */

	sub	r8d, 2
	mov	DWORD PTR i$[rsp], r8d

; 996  :                 break;

	jmp	SHORT $LN26@OptionDire
$LN22@OptionDire:

; 990  :                 return( EmitError( COLON_EXPECTED ) );

	mov	ecx, 84					; 00000054H
	call	EmitError
	jmp	SHORT $LN1@OptionDire
$LN25@OptionDire:

; 1005 :             return( ERROR );

	or	eax, -1
	jmp	SHORT $LN1@OptionDire
$LN16@OptionDire:

; 1011 :         DebugMsg(( "option syntax error: >%s<\n", tokenarray[i].tokpos ));
; 1012 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rdx, r8d
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+24]
	call	EmitErr
$LN1@OptionDire:

; 1015 : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
OptionDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 8
tokenarray$ = 16
Unsupported PROC

; 883  : {

	mov	rax, rdx

; 884  :     return( EmitErr( NOT_SUPPORTED, tokenarray[(*pi)-2].tokpos ) );

	movsxd	rdx, DWORD PTR [rcx]
	shl	rdx, 5
	mov	ecx, 72					; 00000048H
	mov	rdx, QWORD PTR [rdx+rax-40]
	jmp	EmitErr
Unsupported ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetStackBase PROC

; 857  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 858  :     int i = *pi;

	movsxd	rdi, DWORD PTR [rcx]
	mov	rbx, rcx

; 859  : 
; 860  :     if ( tokenarray[i].token != T_REG ) {

	mov	r8, rdi
	shl	r8, 5
	cmp	BYTE PTR [r8+rdx], 2
	je	SHORT $LN2@SetStackBa

; 861  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [r8+rdx+8]
	mov	ecx, 209				; 000000d1H

; 878  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 861  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jmp	EmitErr
$LN2@SetStackBa:

; 862  :     }
; 863  :     if ( !( GetSflagsSp( tokenarray[i].tokval ) & SFR_IREG ) ) {

	mov	ecx, DWORD PTR [r8+rdx+16]
	lea	rdx, OFFSET FLAT:__ImageBase
	lea	rax, QWORD PTR [rcx+rcx*2]
	test	BYTE PTR SpecialTable[rdx+rax*4+4], 32	; 00000020H
	jne	SHORT $LN3@SetStackBa

; 864  :         return( EmitError( MUST_BE_INDEX_OR_BASE_REGISTER ) );

	mov	ecx, 33					; 00000021H

; 878  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 864  :         return( EmitError( MUST_BE_INDEX_OR_BASE_REGISTER ) );

	jmp	EmitError
$LN3@SetStackBa:

; 865  :     }
; 866  :     ModuleInfo.basereg[ModuleInfo.Ofssize] = tokenarray[i].tokval;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	DWORD PTR ModuleInfo[rdx+rax*4+500], ecx

; 867  :     if ( !ModuleInfo.g.StackBase ) {

	cmp	QWORD PTR ModuleInfo+272, 0
	jne	SHORT $LN4@SetStackBa

; 868  :         ModuleInfo.g.StackBase = CreateVariable( "@StackBase", 0 );

	xor	edx, edx
	lea	rcx, OFFSET FLAT:$SG11247
	call	CreateVariable
	mov	QWORD PTR ModuleInfo+272, rax

; 869  :         ModuleInfo.g.StackBase->predefined = TRUE;
; 870  :         ModuleInfo.g.StackBase->sfunc_ptr = UpdateStackBase;

	lea	rcx, OFFSET FLAT:UpdateStackBase

; 871  :         ModuleInfo.g.ProcStatus = CreateVariable( "@ProcStatus", 0 );

	xor	edx, edx
	or	BYTE PTR [rax+40], 32			; 00000020H
	mov	rax, QWORD PTR ModuleInfo+272
	mov	QWORD PTR [rax+64], rcx
	lea	rcx, OFFSET FLAT:$SG11248
	call	CreateVariable
	mov	QWORD PTR ModuleInfo+280, rax

; 872  :         ModuleInfo.g.ProcStatus->predefined = TRUE;
; 873  :         ModuleInfo.g.ProcStatus->sfunc_ptr = UpdateProcStatus;

	lea	rcx, OFFSET FLAT:UpdateProcStatus
	or	BYTE PTR [rax+40], 32			; 00000020H
	mov	rax, QWORD PTR ModuleInfo+280
	mov	QWORD PTR [rax+64], rcx
$LN4@SetStackBa:

; 874  :     }
; 875  :     i++;

	lea	eax, DWORD PTR [rdi+1]

; 876  :     *pi = i;

	mov	DWORD PTR [rbx], eax

; 877  :     return( NOT_ERROR );

	xor	eax, eax

; 878  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetStackBase ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
opnd$ = 48
i$ = 176
pi$ = 176
tokenarray$ = 184
SetCodeView PROC

; 834  : {

	mov	r11, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 835  :     int i = *pi;

	mov	eax, DWORD PTR [rcx]

; 836  :     struct expr opnd;
; 837  : 
; 838  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opnd, 0 ) == ERROR )

	lea	r9, QWORD PTR [r11-120]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rbx, rcx
	lea	rcx, QWORD PTR [r11+8]
	mov	DWORD PTR [r11+8], eax
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN2@SetCodeVie

; 839  :         return( ERROR );

	or	eax, eax

; 847  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN2@SetCodeVie:

; 840  :     if ( opnd.kind == EXPR_CONST ) {

	cmp	DWORD PTR opnd$[rsp+60], 0
	jne	SHORT $LN3@SetCodeVie

; 841  :         ModuleInfo.cv_opt = opnd.value;

	movzx	eax, BYTE PTR opnd$[rsp]
	mov	BYTE PTR ModuleInfo+427, al

; 844  :     }
; 845  :     *pi = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR [rbx], eax

; 846  :     return( NOT_ERROR );

	xor	eax, eax

; 847  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN3@SetCodeVie:

; 842  :     } else {
; 843  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 847  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
SetCodeView ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetDllImport PROC

; 808  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 809  :     int i = *pi;

	movsxd	rbx, DWORD PTR [rcx]
	mov	rdi, rcx

; 810  : 
; 811  :     /* used for COFF only */
; 812  :     //if ( Options.output_format != OFORMAT_COFF ) {
; 813  :     //    SkipOption( pi, tokenarray );
; 814  :     //    return( NOT_ERROR);
; 815  :     //}
; 816  : 
; 817  :     if ( tokenarray[i].token == T_ID &&

	mov	rsi, rbx
	shl	rsi, 5
	add	rsi, rdx
	cmp	BYTE PTR [rsi], 8
	jne	SHORT $LN2@SetDllImpo
	mov	rcx, QWORD PTR [rsi+8]
	lea	rdx, OFFSET FLAT:$SG11217
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN2@SetDllImpo

; 818  :         ( _stricmp( tokenarray[i].string_ptr, "NONE" ) == 0 ) ) {
; 819  :         ModuleInfo.CurrDll = NULL;

	mov	QWORD PTR ModuleInfo+336, 0

; 820  :         i++;

	jmp	SHORT $LN5@SetDllImpo
$LN2@SetDllImpo:

; 821  :     } else if ( tokenarray[i].token == T_STRING && tokenarray[i].string_delim == '<' ) {

	cmp	BYTE PTR [rsi], 9
	jne	SHORT $LN7@SetDllImpo
	cmp	BYTE PTR [rsi+1], 60			; 0000003cH
	jne	SHORT $LN7@SetDllImpo

; 822  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN5@SetDllImpo

; 823  :             ModuleInfo.CurrDll = IncludeDll( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rsi+8]
	call	IncludeDll
	mov	QWORD PTR ModuleInfo+336, rax
$LN5@SetDllImpo:

; 824  :         i++;

	inc	ebx
$LN7@SetDllImpo:

; 825  :     }
; 826  :     *pi = i;
; 827  :     return( NOT_ERROR );
; 828  : }

	mov	rsi, QWORD PTR [rsp+56]
	xor	eax, eax
	mov	DWORD PTR [rdi], ebx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetDllImport ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
;	COMDAT IncludeDll
_TEXT	SEGMENT
name$ = 48
IncludeDll PROC						; COMDAT

; 779  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 780  :     struct dll_desc **q;
; 781  :     struct dll_desc *node;
; 782  : 
; 783  :     /* allow a zero-sized name! */
; 784  :     if ( *name == NULLC )

	cmp	BYTE PTR [rcx], 0
	mov	rbx, rcx
	jne	SHORT $LN5@IncludeDll

; 785  :         return( NULL );

	xor	eax, eax

; 804  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@IncludeDll:

; 786  : 
; 787  :     for ( q = &ModuleInfo.g.DllQueue; *q ; q = &(*q)->next ) {

	cmp	QWORD PTR ModuleInfo+80, 0
	mov	QWORD PTR [rsp+48], rdi
	lea	rdi, OFFSET FLAT:ModuleInfo+80
	je	SHORT $LN3@IncludeDll
	npad	4
$LL4@IncludeDll:

; 788  :         if ( _stricmp( (*q)->name, name ) == 0 )

	mov	rcx, QWORD PTR [rdi]
	mov	rdx, rbx
	add	rcx, 12
	call	_stricmp
	test	eax, eax
	je	SHORT $LN11@IncludeDll

; 786  : 
; 787  :     for ( q = &ModuleInfo.g.DllQueue; *q ; q = &(*q)->next ) {

	mov	rdi, QWORD PTR [rdi]
	cmp	QWORD PTR [rdi], 0
	jne	SHORT $LL4@IncludeDll
$LN3@IncludeDll:

; 790  :     }
; 791  :     node = LclAlloc( sizeof( struct dll_desc ) + strlen( name ) );

	or	rcx, -1
$LL17@IncludeDll:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], 0
	jne	SHORT $LL17@IncludeDll
	add	rcx, 16
	call	LclAlloc
	mov	r8, rax

; 792  :     node->next = NULL;

	xor	eax, eax

; 793  :     node->cnt = 0;
; 794  :     strcpy( node->name, name );

	mov	rdx, r8
	sub	rdx, rbx
	mov	QWORD PTR [r8], rax
	mov	DWORD PTR [r8+8], eax
	npad	12
$LL8@IncludeDll:
	movzx	ecx, BYTE PTR [rbx]
	mov	BYTE PTR [rdx+rbx+12], cl
	lea	rbx, QWORD PTR [rbx+1]
	test	cl, cl
	jne	SHORT $LL8@IncludeDll

; 795  :     *q = node;

	mov	QWORD PTR [rdi], r8

; 796  : 
; 797  : #if AMD64_SUPPORT
; 798  :     ModuleInfo.g.imp_prefix = ( ( ModuleInfo.defOfssize == USE64 ) ? "__imp_" : "_imp_" );

	lea	rcx, OFFSET FLAT:$SG11205
	cmp	BYTE PTR ModuleInfo+405, 2
	lea	rax, OFFSET FLAT:$SG11206
	mov	rdi, QWORD PTR [rsp+48]
	cmove	rax, rcx
	mov	QWORD PTR ModuleInfo+88, rax

; 799  : #else
; 800  :     ModuleInfo.g.imp_prefix = "_imp_";
; 801  : #endif
; 802  : 
; 803  :     return( node );

	mov	rax, r8

; 804  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN11@IncludeDll:

; 789  :             return( *q );

	mov	rax, QWORD PTR [rdi]
	mov	rdi, QWORD PTR [rsp+48]

; 804  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
IncludeDll ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
opndx$ = 48
i$ = 176
pi$ = 176
tokenarray$ = 184
SetWin64 PROC

; 749  : {

	push	rbx
	sub	rsp, 160				; 000000a0H

; 750  :     int i = *pi;
; 751  :     struct expr opndx;
; 752  : 
; 753  :     /* if -win64 isn't set, skip the option */
; 754  :     /* v2.09: skip option if Ofssize != USE64 */
; 755  :     if ( ModuleInfo.defOfssize != USE64 ) {

	cmp	BYTE PTR ModuleInfo+405, 2
	mov	r10, rdx
	movsxd	rax, DWORD PTR [rcx]
	mov	rbx, rcx
	mov	DWORD PTR i$[rsp], eax
	je	SHORT $LN2@SetWin64

; 756  :         SkipOption( pi, tokenarray );

	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 0
	je	SHORT $LN16@SetWin64
	npad	4
$LL9@SetWin64:
	movsxd	rdx, DWORD PTR [rbx]
	mov	rax, rdx
	shl	rax, 5
	cmp	BYTE PTR [rax+r10], 44			; 0000002cH
	je	SHORT $LN16@SetWin64
	lea	eax, DWORD PTR [rdx+1]
	movsxd	rcx, eax
	shl	rcx, 5
	mov	DWORD PTR [rbx], eax
	cmp	BYTE PTR [rcx+r10], 0
	jne	SHORT $LL9@SetWin64
$LN16@SetWin64:

; 757  :         return( NOT_ERROR);

	xor	eax, eax

; 772  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN2@SetWin64:

; 758  :     }
; 759  : 
; 760  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN3@SetWin64

; 761  :         return( ERROR );

	or	eax, eax

; 772  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN3@SetWin64:

; 762  :     if ( opndx.kind == EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN4@SetWin64

; 763  :         if ( opndx.llvalue & ( ~W64F_ALL ) ) {

	mov	rax, QWORD PTR opndx$[rsp]
	test	rax, -16
	je	SHORT $LN6@SetWin64

; 764  :             return( EmitConstError( &opndx ) );

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError

; 772  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN6@SetWin64:

; 765  :         }
; 766  :         ModuleInfo.win64_flags = opndx.value;

	mov	BYTE PTR ModuleInfo+413, al

; 769  :     }
; 770  :     *pi = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR [rbx], eax

; 771  :     return( NOT_ERROR );

	xor	eax, eax

; 772  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN4@SetWin64:

; 767  :     } else {
; 768  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 772  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
SetWin64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetRenameKey PROC

; 704  : {

	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 705  :     int i = *pi;

	movsxd	rdi, DWORD PTR [rcx]
	mov	r8, rdx

; 706  :     //struct ReservedWord *resw;
; 707  :     unsigned index;
; 708  :     char *oldname;
; 709  : 
; 710  : #if 0 /* v2.11: allow temporary renaming of keywords */
; 711  :     /* do nothing if pass > 1 */
; 712  :     if( Parse_Pass != PASS_1 ) {
; 713  :         SkipOption( pi, tokenarray );
; 714  :         return( NOT_ERROR );
; 715  :     }
; 716  : #endif
; 717  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' )  {

	mov	rdx, rdi
	mov	r14, rcx
	shl	rdx, 5
	add	rdx, r8
	cmp	BYTE PTR [rdx], 9
	jne	$LN3@SetRenameK
	cmp	BYTE PTR [rdx+1], 60			; 0000003cH
	jne	$LN3@SetRenameK

; 719  :     }
; 720  :     oldname = tokenarray[i].string_ptr;

	mov	rcx, QWORD PTR [rdx+8]

; 721  :     i++;

	inc	edi

; 722  :     /* v2.06: syntax changed */
; 723  :     //if ( tokenarray[i].token != T_COMMA ) {
; 724  :     if ( tokenarray[i].token != T_DIRECTIVE || tokenarray[i].dirtype != DRT_EQUALSGN ) {

	movsxd	rdx, edi
	shl	rdx, 5
	cmp	BYTE PTR [rdx+r8], 3
	jne	$LN5@SetRenameK
	cmp	BYTE PTR [rdx+r8+1], 48			; 00000030H
	jne	$LN5@SetRenameK

; 727  :     }
; 728  :     i++;

	mov	QWORD PTR [rsp+56], rsi
	inc	edi

; 729  :     if ( tokenarray[i].token != T_ID )  {

	movsxd	rsi, edi
	shl	rsi, 5
	add	rsi, r8
	cmp	BYTE PTR [rsi], 8
	je	SHORT $LN6@SetRenameK

; 730  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rsi+24]
	mov	ecx, 209				; 000000d1H
	mov	rsi, QWORD PTR [rsp+56]

; 743  : }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 730  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	jmp	EmitErr
$LN6@SetRenameK:
	mov	QWORD PTR [rsp+48], rbx

; 731  :     }
; 732  : 
; 733  :     /* todo: if MAX_ID_LEN can be > 255, then check size,
; 734  :      * since a reserved word's size must be <= 255 */
; 735  :     index = FindResWord( oldname, strlen( oldname ) );

	or	rbx, -1
	mov	rdx, rbx
$LL10@SetRenameK:
	inc	rdx
	cmp	BYTE PTR [rcx+rdx], 0
	jne	SHORT $LL10@SetRenameK
	call	FindResWord

; 736  :     if ( index == 0 ) {

	test	eax, eax
	jne	SHORT $LN7@SetRenameK

; 737  :         return( EmitError( RESERVED_WORD_EXPECTED ) );

	mov	ecx, 158				; 0000009eH
	call	EmitError
$LN12@SetRenameK:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]

; 743  : }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN7@SetRenameK:

; 738  :     }
; 739  :     RenameKeyword( index, tokenarray[i].string_ptr, strlen( tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rsi+8]
	npad	5
$LL9@SetRenameK:
	inc	rbx
	cmp	BYTE PTR [rdx+rbx], 0
	jne	SHORT $LL9@SetRenameK
	mov	r8, rbx
	mov	ecx, eax
	call	RenameKeyword

; 740  :     i++;

	lea	eax, DWORD PTR [rdi+1]

; 741  :     *pi = i;

	mov	DWORD PTR [r14], eax

; 742  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN12@SetRenameK
$LN5@SetRenameK:

; 725  :         //EmitError( EXPECTING_COMMA );
; 726  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+r8+24]
	mov	ecx, 209				; 000000d1H

; 743  : }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 725  :         //EmitError( EXPECTING_COMMA );
; 726  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	jmp	EmitErr
$LN3@SetRenameK:

; 718  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+24]
	mov	ecx, 209				; 000000d1H

; 743  : }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 718  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	jmp	EmitErr
SetRenameKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
opndx$ = 48
i$ = 176
pi$ = 176
tokenarray$ = 184
SetElf	PROC

; 678  : {

	mov	r11, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 679  :     int i = *pi;

	mov	eax, DWORD PTR [rcx]

; 680  :     struct expr opndx;
; 681  : 
; 682  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	lea	r9, QWORD PTR [r11-120]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rbx, rcx
	lea	rcx, QWORD PTR [r11+8]
	mov	DWORD PTR [r11+8], eax
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN2@SetElf

; 683  :         return( ERROR );

	or	eax, eax

; 695  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN2@SetElf:

; 684  :     if ( opndx.kind == EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN3@SetElf

; 685  :         if ( opndx.llvalue > 0xFF ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	rax, 255				; 000000ffH
	jbe	SHORT $LN5@SetElf

; 686  :             return( EmitConstError( &opndx ) );

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError

; 695  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN5@SetElf:

; 687  :         }
; 688  :         if ( Options.output_format == OFORMAT_ELF )

	cmp	DWORD PTR Options+144, 3
	movzx	ecx, BYTE PTR ModuleInfo+412
	movzx	eax, al
	cmove	ecx, eax

; 692  :     }
; 693  :     *pi = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	BYTE PTR ModuleInfo+412, cl
	mov	DWORD PTR [rbx], eax

; 694  :     return( NOT_ERROR );

	xor	eax, eax

; 695  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN3@SetElf:

; 689  :             ModuleInfo.elf_osabi = opndx.value;
; 690  :     } else {
; 691  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 695  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
SetElf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetSwitchStile PROC

; 660  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 661  :   int i = *pi;

	movsxd	rbx, DWORD PTR [rcx]
	mov	rdi, rcx

; 662  : 
; 663  :   if (0 == _stricmp(tokenarray[i].string_ptr, "CSTYLE")) {

	mov	rsi, rbx
	shl	rsi, 5
	add	rsi, rdx
	lea	rdx, OFFSET FLAT:$SG11147
	mov	rcx, QWORD PTR [rsi+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN2@SetSwitchS

; 664  :     ModuleInfo.switch_style = 1;

	or	DWORD PTR ModuleInfo+408, 524288	; 00080000H

; 665  :     i++;
; 666  :   }

	jmp	SHORT $LN7@SetSwitchS
$LN2@SetSwitchS:

; 667  :   else if (0 == _stricmp(tokenarray[i].string_ptr, "ASMSTYLE")) {

	mov	rcx, QWORD PTR [rsi+8]
	lea	rdx, OFFSET FLAT:$SG11149
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN6@SetSwitchS

; 668  :     ModuleInfo.switch_style = 0;

	and	DWORD PTR ModuleInfo+408, -524289	; fff7ffffH
$LN7@SetSwitchS:

; 669  :     i++;

	inc	ebx
$LN6@SetSwitchS:

; 670  :   }
; 671  :   *pi = i;
; 672  :   return(NOT_ERROR);
; 673  : }

	mov	rsi, QWORD PTR [rsp+56]
	xor	eax, eax
	mov	DWORD PTR [rdi], ebx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetSwitchStile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetFrame PROC

; 644  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 645  :     int i = *pi;

	movsxd	rbx, DWORD PTR [rcx]
	mov	rdi, rcx

; 646  : 
; 647  :     if ( 0 == _stricmp( tokenarray[i].string_ptr, "AUTO" ) ) {

	mov	rsi, rbx
	shl	rsi, 5
	add	rsi, rdx
	lea	rdx, OFFSET FLAT:$SG11135
	mov	rcx, QWORD PTR [rsi+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN2@SetFrame

; 648  :         ModuleInfo.frame_auto = 1;

	or	DWORD PTR ModuleInfo+408, 131072	; 00020000H

; 649  :         i++;

	jmp	SHORT $LN7@SetFrame
$LN2@SetFrame:

; 650  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "NOAUTO" ) ) {

	mov	rcx, QWORD PTR [rsi+8]
	lea	rdx, OFFSET FLAT:$SG11137
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN6@SetFrame

; 651  :         ModuleInfo.frame_auto = 0;

	and	DWORD PTR ModuleInfo+408, -131073	; fffdffffH
$LN7@SetFrame:

; 652  :         i++;

	inc	ebx
$LN6@SetFrame:

; 653  :     }
; 654  :     *pi = i;
; 655  :     return( NOT_ERROR );
; 656  : }

	mov	rsi, QWORD PTR [rsp+56]
	xor	eax, eax
	mov	DWORD PTR [rdi], ebx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetFrame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
opndx$ = 48
i$ = 192
pi$ = 192
tokenarray$ = 200
SetMZ	PROC

; 588  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 160				; 000000a0H

; 589  :     int i = *pi;

	mov	eax, DWORD PTR [rcx]
	lea	rdi, OFFSET FLAT:ModuleInfo+412
	mov	DWORD PTR i$[rsp], eax
	lea	r14, OFFSET FLAT:ModuleInfo+420
	mov	rbx, rdx
	mov	rsi, rcx
	mov	rbp, 288247968337764352			; 0400100000002000H
	npad	4
$LL4@SetMZ:

; 595  :         int k;
; 596  :         for ( k = i; tokenarray[k].token != T_FINAL; k++ )

	movsxd	r9, eax
	mov	r8, r9
	shl	r8, 5
	cmp	BYTE PTR [r8+rbx], 0
	je	SHORT $LN47@SetMZ
	mov	rcx, r9
	shl	rcx, 5
	movzx	edx, BYTE PTR [rcx+rbx]
	npad	4
$LL7@SetMZ:
	cmp	dl, 58					; 0000003aH
	ja	SHORT $LN43@SetMZ
	bt	rbp, rdx
	jb	SHORT $LN47@SetMZ
$LN43@SetMZ:
	inc	r9
	inc	eax
	mov	rcx, r9
	shl	rcx, 5
	movzx	edx, BYTE PTR [rcx+rbx]
	test	dl, dl
	jne	SHORT $LL7@SetMZ
$LN47@SetMZ:

; 597  :             if ( tokenarray[k].token == T_COMMA ||
; 598  :                 tokenarray[k].token == T_COLON ||
; 599  :                 tokenarray[k].token == T_DBL_COLON )
; 600  :                 break;
; 601  :         if ( EvalOperand( &i, tokenarray, k, &opndx, 0 ) == ERROR )

	lea	r9, QWORD PTR opndx$[rsp]
	mov	BYTE PTR [rsp+32], 0
	mov	r8d, eax
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rbx
	call	EvalOperand
	cmp	eax, -1
	je	$LN32@SetMZ

; 603  :         if ( opndx.kind == EXPR_EMPTY ) {

	mov	eax, DWORD PTR opndx$[rsp+60]
	cmp	eax, -2
	je	SHORT $LN46@SetMZ

; 604  :         } else if ( opndx.kind == EXPR_CONST ) {

	test	eax, eax
	jne	$LN16@SetMZ

; 605  :             if ( opndx.value64 > 0xFFFF ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	rax, 65535				; 0000ffffH
	jg	$LN33@SetMZ

; 607  :             }
; 608  :             if ( ModuleInfo.sub_format == SFORMAT_MZ )

	cmp	DWORD PTR ModuleInfo+372, 1
	jne	SHORT $LN46@SetMZ

; 609  :                 *(parms + j) = opndx.value;

	mov	WORD PTR [rdi], ax
$LN46@SetMZ:

; 612  :         }
; 613  :         if ( tokenarray[i].token == T_COLON )

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, rax
	shl	rcx, 5
	movzx	edx, BYTE PTR [rcx+rbx]
	cmp	dl, 58					; 0000003aH
	jne	SHORT $LN20@SetMZ

; 614  :             i++;

	inc	eax
	jmp	SHORT $LN48@SetMZ
$LN20@SetMZ:

; 615  :         else if ( tokenarray[i].token == T_DBL_COLON ) {

	cmp	dl, 13
	jne	SHORT $LN2@SetMZ

; 616  :             i++;

	inc	eax

; 617  :             j++;

	add	rdi, 2
$LN48@SetMZ:

; 616  :             i++;

	mov	DWORD PTR i$[rsp], eax
$LN2@SetMZ:

; 590  :     int j;
; 591  :     uint_16 *parms;
; 592  :     struct expr opndx;
; 593  : 
; 594  :     for ( j = 0, parms = (uint_16 *)&ModuleInfo.mz_data ; j < 4; j++ ) {

	add	rdi, 2
	cmp	rdi, r14
	jl	$LL4@SetMZ

; 618  :         }
; 619  :     }
; 620  : 
; 621  :     /* ensure data integrity of the params */
; 622  :     if ( ModuleInfo.sub_format == SFORMAT_MZ ) {

	cmp	DWORD PTR ModuleInfo+372, 1
	jne	SHORT $LN26@SetMZ

; 623  :         if ( ModuleInfo.mz_data.ofs_fixups < 0x1E )

	cmp	WORD PTR ModuleInfo+412, 30
	jae	SHORT $LN24@SetMZ

; 624  :             ModuleInfo.mz_data.ofs_fixups = 0x1E;

	mov	ecx, 30
	mov	WORD PTR ModuleInfo+412, cx
$LN24@SetMZ:

; 625  : 
; 626  :         for( j = 16; j < ModuleInfo.mz_data.alignment; j <<= 1 );

	movzx	edx, WORD PTR ModuleInfo+414
	mov	ecx, 16
	cmp	ecx, edx
	jge	SHORT $LN49@SetMZ
	npad	3
$LL10@SetMZ:
	add	ecx, ecx
	cmp	ecx, edx
	jl	SHORT $LL10@SetMZ
$LN49@SetMZ:

; 627  :         if( j != ModuleInfo.mz_data.alignment )

	je	SHORT $LN25@SetMZ

; 628  :             EmitError( INVALID_HEADER_ALIGNMENT );

	mov	ecx, 205				; 000000cdH
	call	EmitError
	mov	eax, DWORD PTR i$[rsp]
$LN25@SetMZ:

; 629  : 
; 630  :         if ( ModuleInfo.mz_data.heapmax < ModuleInfo.mz_data.heapmin )

	movzx	edx, WORD PTR ModuleInfo+418
	cmp	dx, WORD PTR ModuleInfo+416
	cmovb	dx, WORD PTR ModuleInfo+416
	mov	WORD PTR ModuleInfo+418, dx
$LN26@SetMZ:

; 631  :             ModuleInfo.mz_data.heapmax = ModuleInfo.mz_data.heapmin;
; 632  :     }
; 633  :     *pi = i;

	mov	DWORD PTR [rsi], eax

; 634  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@SetMZ
$LN33@SetMZ:

; 606  :                 return( EmitConstError( &opndx ) );

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	SHORT $LN1@SetMZ
$LN16@SetMZ:

; 610  :         } else {
; 611  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	SHORT $LN1@SetMZ
$LN32@SetMZ:

; 602  :             return( ERROR );

	or	eax, -1
$LN1@SetMZ:

; 635  : }

	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+40]
	mov	rbp, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
SetMZ	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
opndx$ = 48
i$ = 176
pi$ = 176
tokenarray$ = 184
SetProcAlign PROC

; 562  : {

	mov	r11, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 563  :     int i = *pi;

	mov	eax, DWORD PTR [rcx]

; 564  :     int temp, temp2;
; 565  :     struct expr opndx;
; 566  : 
; 567  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	lea	r9, QWORD PTR [r11-120]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rbx, rcx
	lea	rcx, QWORD PTR [r11+8]
	mov	DWORD PTR [r11+8], eax
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN5@SetProcAli

; 568  :         return( ERROR );

	or	eax, eax

; 582  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN5@SetProcAli:

; 569  :     if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN6@SetProcAli

; 570  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 582  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN6@SetProcAli:

; 571  :     }
; 572  :     if( opndx.value > MAX_STRUCT_ALIGN ) {

	mov	edx, DWORD PTR opndx$[rsp]
	cmp	edx, 32					; 00000020H
	jle	SHORT $LN7@SetProcAli

; 573  :         EmitError( STRUCT_ALIGN_TOO_HIGH );

	mov	ecx, 214				; 000000d6H
	call	EmitError
	mov	edx, DWORD PTR opndx$[rsp]
$LN7@SetProcAli:

; 574  :     }
; 575  :     for( temp = 1, temp2 = 0; temp < opndx.value ; temp <<= 1, temp2++ );

	mov	eax, 1
	xor	ecx, ecx
	cmp	eax, edx
	jge	SHORT $LN14@SetProcAli
	npad	7
$LL4@SetProcAli:
	add	eax, eax
	inc	ecx
	cmp	eax, edx
	jl	SHORT $LL4@SetProcAli
$LN14@SetProcAli:

; 576  :     if( temp != opndx.value ) {

	je	SHORT $LN8@SetProcAli

; 577  :         return( EmitErr( POWER_OF_2, opndx.value ) );

	mov	ecx, 129				; 00000081H
	call	EmitErr

; 582  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN8@SetProcAli:

; 578  :     }
; 579  :     ModuleInfo.procalign = temp2;
; 580  :     *pi = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	BYTE PTR ModuleInfo+399, cl
	mov	DWORD PTR [rbx], eax

; 581  :     return( NOT_ERROR );

	xor	eax, eax

; 582  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
SetProcAlign ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
opndx$ = 48
i$ = 176
pi$ = 176
tokenarray$ = 184
SetFieldAlign PROC

; 534  : {

	mov	r11, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 535  :     int i = *pi;

	mov	eax, DWORD PTR [rcx]

; 536  :     unsigned temp, temp2;
; 537  :     struct expr opndx;
; 538  : 
; 539  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	lea	r9, QWORD PTR [r11-120]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rbx, rcx
	lea	rcx, QWORD PTR [r11+8]
	mov	DWORD PTR [r11+8], eax
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN5@SetFieldAl

; 540  :         return( ERROR );

	or	eax, eax

; 554  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN5@SetFieldAl:

; 541  :     if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN6@SetFieldAl

; 542  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 554  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN6@SetFieldAl:

; 543  :     }
; 544  :     if( opndx.uvalue > MAX_STRUCT_ALIGN ) {

	mov	edx, DWORD PTR opndx$[rsp]
	cmp	edx, 32					; 00000020H
	jbe	SHORT $LN7@SetFieldAl

; 545  :         return( EmitError( STRUCT_ALIGN_TOO_HIGH ) );

	mov	ecx, 214				; 000000d6H
	call	EmitError

; 554  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN7@SetFieldAl:

; 546  :     }
; 547  :     for( temp = 1, temp2 = 0; temp < opndx.uvalue ; temp <<= 1, temp2++ );

	mov	eax, 1
	xor	ecx, ecx
	cmp	eax, edx
	jae	SHORT $LN14@SetFieldAl
	npad	2
$LL4@SetFieldAl:
	add	eax, eax
	inc	ecx
	cmp	eax, edx
	jb	SHORT $LL4@SetFieldAl
$LN14@SetFieldAl:

; 548  :     if( temp != opndx.uvalue ) {

	je	SHORT $LN8@SetFieldAl

; 549  :         return( EmitErr( POWER_OF_2, opndx.value ) );

	mov	ecx, 129				; 00000081H
	call	EmitErr

; 554  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN8@SetFieldAl:

; 550  :     }
; 551  :     ModuleInfo.fieldalign = temp2;
; 552  :     *pi = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	BYTE PTR ModuleInfo+397, cl
	mov	DWORD PTR [rbx], eax

; 553  :     return( NOT_ERROR );

	xor	eax, eax

; 554  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
SetFieldAlign ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetSegment PROC

; 503  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 504  :     int i = *pi;

	movsxd	rsi, DWORD PTR [rcx]
	mov	rdi, rcx

; 505  : 
; 506  :     if ( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_FLAT ) {

	mov	rax, rsi
	shl	rax, 5
	lea	rbx, QWORD PTR [rax+rdx]
	movzx	eax, BYTE PTR [rax+rdx]
	cmp	al, 7
	jne	SHORT $LN2@SetSegment
	cmp	DWORD PTR [rbx+16], 261			; 00000105H
	jne	SHORT $LN6@SetSegment

; 507  : #if AMD64_SUPPORT
; 508  :         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_64 )

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 112				; 00000070H
	setge	al
	inc	al
	mov	BYTE PTR ModuleInfo+405, al

; 523  :     }
; 524  :     i++;

	lea	eax, DWORD PTR [rsi+1]

; 525  :     *pi = i;

	mov	DWORD PTR [rcx], eax

; 526  :     return( NOT_ERROR );

	xor	eax, eax

; 527  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@SetSegment:

; 509  :             ModuleInfo.defOfssize = USE64;
; 510  :         else
; 511  : #endif
; 512  :             ModuleInfo.defOfssize = USE32;
; 513  :     } else if ( tokenarray[i].token == T_ID && _stricmp( tokenarray[i].string_ptr, "USE16" ) == 0) {

	cmp	al, 8
	jne	SHORT $LN6@SetSegment
	mov	rcx, QWORD PTR [rbx+8]
	lea	rdx, OFFSET FLAT:$SG11048
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN6@SetSegment

; 514  :         ModuleInfo.defOfssize = USE16;

	mov	BYTE PTR ModuleInfo+405, al

; 523  :     }
; 524  :     i++;

	lea	eax, DWORD PTR [rsi+1]

; 525  :     *pi = i;

	mov	DWORD PTR [rdi], eax

; 526  :     return( NOT_ERROR );

	xor	eax, eax

; 527  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@SetSegment:

; 515  :     } else if ( tokenarray[i].token == T_ID && _stricmp( tokenarray[i].string_ptr, "USE32" ) == 0) {

	cmp	BYTE PTR [rbx], 8
	jne	SHORT $LN10@SetSegment
	mov	rcx, QWORD PTR [rbx+8]
	lea	rdx, OFFSET FLAT:$SG11051
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN8@SetSegment

; 523  :     }
; 524  :     i++;

	lea	eax, DWORD PTR [rsi+1]
	mov	BYTE PTR ModuleInfo+405, 1

; 525  :     *pi = i;

	mov	DWORD PTR [rdi], eax

; 526  :     return( NOT_ERROR );

	xor	eax, eax

; 527  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN8@SetSegment:

; 516  :         ModuleInfo.defOfssize = USE32;
; 517  : #if AMD64_SUPPORT
; 518  :     } else if ( tokenarray[i].token == T_ID && _stricmp( tokenarray[i].string_ptr, "USE64" ) == 0) {

	cmp	BYTE PTR [rbx], 8
	jne	SHORT $LN10@SetSegment
	mov	rcx, QWORD PTR [rbx+8]
	lea	rdx, OFFSET FLAT:$SG11054
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN10@SetSegment

; 523  :     }
; 524  :     i++;

	lea	eax, DWORD PTR [rsi+1]
	mov	BYTE PTR ModuleInfo+405, 2

; 525  :     *pi = i;

	mov	DWORD PTR [rdi], eax

; 526  :     return( NOT_ERROR );

	xor	eax, eax

; 527  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN10@SetSegment:

; 519  :         ModuleInfo.defOfssize = USE64;
; 520  : #endif
; 521  :     } else {
; 522  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 209				; 000000d1H

; 527  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 519  :         ModuleInfo.defOfssize = USE64;
; 520  : #endif
; 521  :     } else {
; 522  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jmp	EmitErr
SetSegment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetProc	PROC

; 469  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 470  :     int i = *pi;

	movsxd	rbx, DWORD PTR [rcx]
	mov	rsi, rcx

; 471  : 
; 472  :     switch ( tokenarray[i].token ) {

	mov	rax, rbx
	shl	rax, 5
	lea	rdi, QWORD PTR [rax+rdx]
	movzx	eax, BYTE PTR [rax+rdx]
	cmp	al, 3
	je	SHORT $LN8@SetProc
	cmp	al, 8
	jne	SHORT $LN9@SetProc

; 473  :     case T_ID:
; 474  :         if ( 0 == _stricmp( tokenarray[i].string_ptr, "PRIVATE" ) ) {

	mov	rcx, QWORD PTR [rdi+8]
	lea	rdx, OFFSET FLAT:$SG11030
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN5@SetProc

; 475  :             ModuleInfo.procs_private = TRUE;
; 476  :             ModuleInfo.procs_export = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -9					; fffffff7H
	or	eax, 4
	mov	DWORD PTR ModuleInfo+408, eax

; 477  :             i++;

	jmp	SHORT $LN11@SetProc
$LN5@SetProc:

; 478  :         } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "EXPORT" ) ) {

	mov	rcx, QWORD PTR [rdi+8]
	lea	rdx, OFFSET FLAT:$SG11032
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN9@SetProc

; 479  :             ModuleInfo.procs_private = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -5					; fffffffbH

; 480  :             ModuleInfo.procs_export = TRUE;

	or	eax, 8
	mov	DWORD PTR ModuleInfo+408, eax

; 481  :             i++;
; 482  :         }
; 483  :         break;

	jmp	SHORT $LN11@SetProc
$LN8@SetProc:

; 484  :     case T_DIRECTIVE: /* word PUBLIC is a directive */
; 485  :         if ( tokenarray[i].tokval == T_PUBLIC ) {

	cmp	DWORD PTR [rdi+16], 431			; 000001afH
	jne	SHORT $LN9@SetProc

; 486  :             ModuleInfo.procs_private = FALSE;
; 487  :             ModuleInfo.procs_export = FALSE;

	and	DWORD PTR ModuleInfo+408, -13		; fffffff3H
$LN11@SetProc:

; 488  :             i++;

	inc	ebx
$LN9@SetProc:

; 489  :         }
; 490  :         break;
; 491  :     }
; 492  :     *pi = i;

	mov	DWORD PTR [rsi], ebx

; 493  :     return( NOT_ERROR );

	xor	eax, eax

; 494  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetProc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetOffset PROC

; 448  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 449  :     int i = *pi;

	movsxd	rsi, DWORD PTR [rcx]
	mov	rdi, rcx

; 450  : 
; 451  :     if ( 0 == _stricmp( tokenarray[i].string_ptr, "GROUP" ) ) {

	mov	rbx, rsi
	shl	rbx, 5
	add	rbx, rdx
	lea	rdx, OFFSET FLAT:$SG11011
	mov	rcx, QWORD PTR [rbx+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN2@SetOffset

; 452  :         ModuleInfo.offsettype = OT_GROUP;

	mov	DWORD PTR ModuleInfo+384, eax

; 459  :     }
; 460  :     i++;

	lea	eax, DWORD PTR [rsi+1]

; 461  :     *pi = i;

	mov	DWORD PTR [rdi], eax

; 462  :     return( NOT_ERROR );

	xor	eax, eax

; 463  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@SetOffset:

; 453  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "FLAT" ) ) {

	mov	rcx, QWORD PTR [rbx+8]
	lea	rdx, OFFSET FLAT:$SG11014
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN4@SetOffset

; 459  :     }
; 460  :     i++;

	lea	eax, DWORD PTR [rsi+1]
	mov	DWORD PTR ModuleInfo+384, 1

; 461  :     *pi = i;

	mov	DWORD PTR [rdi], eax

; 462  :     return( NOT_ERROR );

	xor	eax, eax

; 463  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@SetOffset:

; 454  :         ModuleInfo.offsettype = OT_FLAT;
; 455  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "SEGMENT" ) ) {

	mov	rcx, QWORD PTR [rbx+8]
	lea	rdx, OFFSET FLAT:$SG11017
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN6@SetOffset

; 459  :     }
; 460  :     i++;

	lea	eax, DWORD PTR [rsi+1]
	mov	DWORD PTR ModuleInfo+384, 2

; 461  :     *pi = i;

	mov	DWORD PTR [rdi], eax

; 462  :     return( NOT_ERROR );

	xor	eax, eax

; 463  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@SetOffset:

; 456  :         ModuleInfo.offsettype = OT_SEGMENT;
; 457  :     } else {
; 458  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 209				; 000000d1H

; 463  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 456  :         ModuleInfo.offsettype = OT_SEGMENT;
; 457  :     } else {
; 458  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jmp	EmitErr
SetOffset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetEpilogue PROC

; 416  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 417  :     int i = *pi;

	movsxd	rsi, DWORD PTR [rcx]
	mov	rdi, rcx

; 418  : 
; 419  :     if ( tokenarray[i].token != T_ID ) {

	mov	rbx, rsi
	shl	rbx, 5
	add	rbx, rdx
	cmp	BYTE PTR [rbx], 8
	je	SHORT $LN2@SetEpilogu

; 420  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rbx+24]
	mov	ecx, 209				; 000000d1H

; 435  :     }
; 436  : 
; 437  :     i++;
; 438  :     *pi = i;
; 439  :     return( NOT_ERROR );
; 440  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 420  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	jmp	EmitErr
$LN2@SetEpilogu:

; 421  :     }
; 422  :     if ( ModuleInfo.proc_epilogue ) {

	mov	QWORD PTR ModuleInfo+328, 0

; 423  :         LclFree( ModuleInfo.proc_epilogue );
; 424  :         ModuleInfo.proc_epilogue = NULL;
; 425  :     }
; 426  : 
; 427  :     if ( 0 == _stricmp( tokenarray[i].string_ptr, "NONE" ) ) {

	lea	rdx, OFFSET FLAT:$SG10998
	mov	rcx, QWORD PTR [rbx+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN4@SetEpilogu

; 428  :         ModuleInfo.epiloguemode = PEM_NONE;

	mov	BYTE PTR ModuleInfo+425, 2
	jmp	SHORT $LN7@SetEpilogu
$LN4@SetEpilogu:

; 429  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "EPILOGUEDEF" ) ) {

	mov	rcx, QWORD PTR [rbx+8]
	lea	rdx, OFFSET FLAT:$SG11001
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN6@SetEpilogu

; 430  :         ModuleInfo.epiloguemode = PEM_DEFAULT;

	mov	BYTE PTR ModuleInfo+425, al

; 431  :     } else {

	jmp	SHORT $LN7@SetEpilogu
$LN6@SetEpilogu:

; 432  :         ModuleInfo.epiloguemode = PEM_MACRO;

	mov	BYTE PTR ModuleInfo+425, 1

; 433  :         ModuleInfo.proc_epilogue = LclAlloc( strlen( tokenarray[i].string_ptr ) + 1);

	or	rcx, -1
	mov	rax, QWORD PTR [rbx+8]
$LL13@SetEpilogu:
	inc	rcx
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL13@SetEpilogu
	inc	rcx
	call	LclAlloc
	mov	QWORD PTR ModuleInfo+328, rax

; 434  :         strcpy( ModuleInfo.proc_epilogue, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rbx+8]
$LL9@SetEpilogu:
	movzx	ecx, BYTE PTR [rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL9@SetEpilogu
$LN7@SetEpilogu:

; 435  :     }
; 436  : 
; 437  :     i++;
; 438  :     *pi = i;
; 439  :     return( NOT_ERROR );
; 440  : }

	mov	rbx, QWORD PTR [rsp+48]
	lea	eax, DWORD PTR [rsi+1]
	mov	rsi, QWORD PTR [rsp+56]
	mov	DWORD PTR [rdi], eax
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetEpilogue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetPrologue PROC

; 384  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 385  :     int i = *pi;

	movsxd	rsi, DWORD PTR [rcx]
	mov	rdi, rcx

; 386  : 
; 387  :     if ( tokenarray[i].token != T_ID ) {

	mov	rbx, rsi
	shl	rbx, 5
	add	rbx, rdx
	cmp	BYTE PTR [rbx], 8
	je	SHORT $LN2@SetPrologu

; 388  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rbx+24]
	mov	ecx, 209				; 000000d1H

; 402  :     }
; 403  : 
; 404  :     i++;
; 405  :     *pi = i;
; 406  :     return( NOT_ERROR );
; 407  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 388  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	jmp	EmitErr
$LN2@SetPrologu:

; 389  :     }
; 390  :     if ( ModuleInfo.proc_prologue ) {

	mov	QWORD PTR ModuleInfo+320, 0

; 391  :         LclFree( ModuleInfo.proc_prologue );
; 392  :         ModuleInfo.proc_prologue = NULL;
; 393  :     }
; 394  :     if ( 0 == _stricmp( tokenarray[i].string_ptr, "NONE" ) ) {

	lea	rdx, OFFSET FLAT:$SG10982
	mov	rcx, QWORD PTR [rbx+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN4@SetPrologu

; 395  :         ModuleInfo.prologuemode = PEM_NONE;

	mov	BYTE PTR ModuleInfo+424, 2
	jmp	SHORT $LN7@SetPrologu
$LN4@SetPrologu:

; 396  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "PROLOGUEDEF" ) ) {

	mov	rcx, QWORD PTR [rbx+8]
	lea	rdx, OFFSET FLAT:$SG10985
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN6@SetPrologu

; 397  :         ModuleInfo.prologuemode = PEM_DEFAULT;

	mov	BYTE PTR ModuleInfo+424, al

; 398  :     } else {

	jmp	SHORT $LN7@SetPrologu
$LN6@SetPrologu:

; 399  :         ModuleInfo.prologuemode = PEM_MACRO;

	mov	BYTE PTR ModuleInfo+424, 1

; 400  :         ModuleInfo.proc_prologue = LclAlloc( strlen( tokenarray[i].string_ptr ) + 1);

	or	rcx, -1
	mov	rax, QWORD PTR [rbx+8]
$LL13@SetPrologu:
	inc	rcx
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL13@SetPrologu
	inc	rcx
	call	LclAlloc
	mov	QWORD PTR ModuleInfo+320, rax

; 401  :         strcpy( ModuleInfo.proc_prologue, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rbx+8]
$LL9@SetPrologu:
	movzx	ecx, BYTE PTR [rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL9@SetPrologu
$LN7@SetPrologu:

; 402  :     }
; 403  : 
; 404  :     i++;
; 405  :     *pi = i;
; 406  :     return( NOT_ERROR );
; 407  : }

	mov	rbx, QWORD PTR [rsp+48]
	lea	eax, DWORD PTR [rsi+1]
	mov	rsi, QWORD PTR [rsp+56]
	mov	DWORD PTR [rdi], eax
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetPrologue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetSetIF2 PROC

; 351  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 352  :     int i = *pi;

	movsxd	rbx, DWORD PTR [rcx]
	mov	rdi, rcx

; 353  : 
; 354  :     if ( 0 == _stricmp( tokenarray[i].string_ptr, "TRUE" ) ) {

	mov	rsi, rbx
	shl	rsi, 5
	add	rsi, rdx
	lea	rdx, OFFSET FLAT:$SG10967
	mov	rcx, QWORD PTR [rsi+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN2@SetSetIF2

; 355  :         ModuleInfo.setif2 = TRUE;

	or	DWORD PTR ModuleInfo+408, 1024		; 00000400H

; 356  :         i++;

	jmp	SHORT $LN7@SetSetIF2
$LN2@SetSetIF2:

; 357  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "FALSE" ) ) {

	mov	rcx, QWORD PTR [rsi+8]
	lea	rdx, OFFSET FLAT:$SG10969
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN6@SetSetIF2

; 358  :         ModuleInfo.setif2 = FALSE;

	and	DWORD PTR ModuleInfo+408, -1025		; fffffbffH
$LN7@SetSetIF2:

; 359  :         i++;

	inc	ebx
$LN6@SetSetIF2:

; 360  :     }
; 361  :     *pi = i;
; 362  :     return( NOT_ERROR );
; 363  : }

	mov	rsi, QWORD PTR [rsp+56]
	xor	eax, eax
	mov	DWORD PTR [rdi], ebx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetSetIF2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 48
pi$ = 48
tokenarray$ = 56
SetLanguage PROC

; 328  : {

	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 329  :     int i = *pi;

	movsxd	r8, DWORD PTR [rcx]
	mov	rbx, rdx

; 330  :     //lang_type langtype;
; 331  :     //int language = ERROR;
; 332  : 
; 333  :     if ( tokenarray[i].token == T_RES_ID ) {

	mov	rax, r8
	mov	DWORD PTR i$[rsp], r8d
	shl	rax, 5
	mov	rdi, rcx
	cmp	BYTE PTR [rax+rdx], 7
	jne	SHORT $LN3@SetLanguag

; 334  :         if ( GetLangType( &i, tokenarray, &ModuleInfo.langtype ) == NOT_ERROR ) {

	lea	r8, OFFSET FLAT:ModuleInfo+364
	lea	rcx, QWORD PTR i$[rsp]
	call	GetLangType
	test	eax, eax
	jne	SHORT $LN6@SetLanguag

; 335  :             /* update @Interface assembly time variable */
; 336  :             if ( ModuleInfo.model != MODEL_NONE && sym_Interface )

	cmp	DWORD PTR ModuleInfo+360, eax
	je	SHORT $LN4@SetLanguag
	mov	rcx, QWORD PTR sym_Interface
	test	rcx, rcx
	je	SHORT $LN4@SetLanguag

; 337  :                 sym_Interface->value = ModuleInfo.langtype;

	mov	eax, DWORD PTR ModuleInfo+364
	mov	DWORD PTR [rcx+16], eax
$LN4@SetLanguag:

; 338  :             *pi = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR [rdi], eax

; 339  :             return( NOT_ERROR );

	xor	eax, eax

; 343  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@SetLanguag:

; 339  :             return( NOT_ERROR );

	mov	r8d, DWORD PTR i$[rsp]
$LN3@SetLanguag:

; 340  :         }
; 341  :     }
; 342  :     return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rdx, r8d
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbx+24]
	call	EmitErr

; 343  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetLanguage ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetNoKeyword PROC

; 280  : {

	mov	QWORD PTR [rsp+32], rbp
	push	r14
	sub	rsp, 32					; 00000020H

; 281  :     int i = *pi;

	movsxd	rbp, DWORD PTR [rcx]
	mov	r8, rdx

; 282  :     //struct ReservedWord *resw;
; 283  :     unsigned index;
; 284  :     char *p;
; 285  : 
; 286  :     if( Parse_Pass != PASS_1 ) {
; 287  :         SkipOption( pi, tokenarray );

	mov	rax, rbp
	mov	r14, rcx
	shl	rax, 5
	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN12@SetNoKeywo
	cmp	BYTE PTR [rax+rdx], 0
	je	SHORT $LN49@SetNoKeywo
	npad	6
$LL24@SetNoKeywo:
	movsxd	rdx, DWORD PTR [r14]
	mov	rax, rdx
	shl	rax, 5
	cmp	BYTE PTR [rax+r8], 44			; 0000002cH
	je	SHORT $LN49@SetNoKeywo
	lea	eax, DWORD PTR [rdx+1]
	movsxd	rcx, eax
	shl	rcx, 5
	mov	DWORD PTR [r14], eax
	cmp	BYTE PTR [rcx+r8], 0
	jne	SHORT $LL24@SetNoKeywo
$LN49@SetNoKeywo:

; 288  :         return( NOT_ERROR);

	xor	eax, eax

; 322  : }

	mov	rbp, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN12@SetNoKeywo:

; 289  :     }
; 290  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	add	rdx, rax
	cmp	BYTE PTR [rdx], 9
	jne	$LN14@SetNoKeywo
	cmp	BYTE PTR [rdx+1], 60			; 0000003cH
	jne	$LN14@SetNoKeywo

; 292  :     }
; 293  :     for ( p = tokenarray[i].string_ptr; *p; ) {

	mov	QWORD PTR [rsp+48], rbx
	mov	rbx, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsp+56], rsi
	mov	QWORD PTR [rsp+64], rdi
	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	$LN48@SetNoKeywo
$LL2@SetNoKeywo:

; 294  :         while ( isspace( *p ) ) p++;

	movsx	ecx, al
	call	isspace
	test	eax, eax
	je	SHORT $LN6@SetNoKeywo
$LL5@SetNoKeywo:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL5@SetNoKeywo
$LN6@SetNoKeywo:

; 295  :         if ( *p ) {

	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	SHORT $LN31@SetNoKeywo

; 296  :             char *p2 = p;

	mov	rsi, rbx
	npad	3
$LL9@SetNoKeywo:

; 300  :                 if ( isspace( *p ) || *p == ',' )

	movsx	ecx, al
	call	isspace
	test	eax, eax
	jne	SHORT $LN32@SetNoKeywo
	cmp	BYTE PTR [rbx], 44			; 0000002cH
	je	SHORT $LN32@SetNoKeywo

; 297  :             unsigned char cnt;
; 298  :             //struct instr_item *instruct;
; 299  :             for ( ;*p; p++ ) {

	movzx	eax, BYTE PTR [rbx+1]
	inc	rbx
	test	al, al
	jne	SHORT $LL9@SetNoKeywo
$LN32@SetNoKeywo:

; 301  :                     break;
; 302  :             }
; 303  :             cnt = p - p2;

	movzx	edi, bl

; 304  :             /* todo: if MAX_ID_LEN can be > 255, then check size,
; 305  :              * since a reserved word's size must be <= 255
; 306  :              */
; 307  :             index = FindResWord( p2, cnt );

	mov	rcx, rsi
	sub	dil, sil
	movzx	edx, dil
	call	FindResWord

; 308  :             if ( index != 0 )

	test	eax, eax
	je	SHORT $LN18@SetNoKeywo

; 309  :                 DisableKeyword( index );

	mov	ecx, eax
	call	DisableKeyword
	jmp	SHORT $LN31@SetNoKeywo
$LN18@SetNoKeywo:

; 310  :             else {
; 311  :                 if ( IsKeywordDisabled( p2, cnt ) ) {

	movzx	edx, dil
	mov	rcx, rsi
	call	IsKeywordDisabled
	test	al, al
	jne	SHORT $LN33@SetNoKeywo
$LN31@SetNoKeywo:

; 313  :                 }
; 314  :             }
; 315  :         }
; 316  :         while ( isspace(*p) ) p++;

	movsx	ecx, BYTE PTR [rbx]
	call	isspace
	test	eax, eax
	je	SHORT $LN11@SetNoKeywo
	npad	9
$LL10@SetNoKeywo:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL10@SetNoKeywo
$LN11@SetNoKeywo:

; 317  :         if (*p == ',') p++;

	cmp	BYTE PTR [rbx], 44			; 0000002cH
	jne	SHORT $LN21@SetNoKeywo
	inc	rbx
$LN21@SetNoKeywo:

; 292  :     }
; 293  :     for ( p = tokenarray[i].string_ptr; *p; ) {

	movzx	eax, BYTE PTR [rbx]
	test	al, al
	jne	$LL2@SetNoKeywo
$LN48@SetNoKeywo:

; 318  :     }
; 319  :     i++;

	lea	eax, DWORD PTR [rbp+1]

; 320  :     *pi = i;

	mov	DWORD PTR [r14], eax

; 321  :     return( NOT_ERROR );

	xor	eax, eax
$LN52@SetNoKeywo:
	mov	rsi, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+64]

; 322  : }

	mov	rbp, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN33@SetNoKeywo:

; 312  :                     return( EmitError( RESERVED_WORD_EXPECTED ) );

	mov	ecx, 158				; 0000009eH
	call	EmitError
	jmp	SHORT $LN52@SetNoKeywo
$LN14@SetNoKeywo:

; 291  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+24]
	mov	ecx, 209				; 000000d1H

; 322  : }

	mov	rbp, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14

; 291  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	jmp	EmitErr
SetNoKeyword ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
;	COMDAT SkipOption
_TEXT	SEGMENT
pi$ = 8
tokenarray$ = 16
SkipOption PROC						; COMDAT

; 270  :     while ( tokenarray[*pi].token != T_FINAL &&

	movsxd	rax, DWORD PTR [rcx]
	mov	r9, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 0
	je	SHORT $LN3@SkipOption
$LL2@SkipOption:
	movsxd	r8, DWORD PTR [r9]
	mov	rax, r8
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 44			; 0000002cH
	je	SHORT $LN3@SkipOption

; 271  :            tokenarray[*pi].token != T_COMMA )
; 272  :         (*pi)++;

	lea	eax, DWORD PTR [r8+1]
	movsxd	rcx, eax
	shl	rcx, 5
	mov	DWORD PTR [r9], eax
	cmp	BYTE PTR [rcx+rdx], 0
	jne	SHORT $LL2@SkipOption
$LN3@SkipOption:

; 273  : }

	ret	0
SkipOption ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 8
tokenarray$ = 16
SetNoSignExt PROC

; 263  :     ModuleInfo.NoSignExtend = TRUE;

	or	DWORD PTR ModuleInfo+408, 262144	; 00040000H

; 264  :     return( NOT_ERROR );

	xor	eax, eax

; 265  : }

	ret	0
SetNoSignExt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 8
tokenarray$ = 16
SetExpr32 PROC

; 256  :     /* default, nothing to do */
; 257  :     return( NOT_ERROR );

	xor	eax, eax

; 258  : }

	ret	0
SetExpr32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 8
tokenarray$ = 16
SetNoOldmacros PROC

; 247  :     /* default, nothing to do */
; 248  :     return( NOT_ERROR );

	xor	eax, eax

; 249  : }

	ret	0
SetNoOldmacros ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 8
tokenarray$ = 16
SetNoReadonly PROC

; 238  :     /* default, nothing to do */
; 239  :     return( NOT_ERROR );

	xor	eax, eax

; 240  : }

	ret	0
SetNoReadonly ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 8
tokenarray$ = 16
SetNoLJmp PROC

; 229  :     ModuleInfo.ljmp = FALSE;

	and	DWORD PTR ModuleInfo+408, -33		; ffffffdfH

; 230  :     return( NOT_ERROR );

	xor	eax, eax

; 231  : }

	ret	0
SetNoLJmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 8
tokenarray$ = 16
SetLJmp	PROC

; 220  :     ModuleInfo.ljmp = TRUE;

	or	DWORD PTR ModuleInfo+408, 32		; 00000020H

; 221  :     return( NOT_ERROR );

	xor	eax, eax

; 222  : }

	ret	0
SetLJmp	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 8
tokenarray$ = 16
SetNoEmulator PROC

; 211  :     ModuleInfo.emulator = FALSE;

	and	DWORD PTR ModuleInfo+408, -513		; fffffdffH

; 212  :     return( NOT_ERROR );

	xor	eax, eax

; 213  : }

	ret	0
SetNoEmulator ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 8
tokenarray$ = 16
SetEmulator PROC

; 202  :     ModuleInfo.emulator = TRUE;

	or	DWORD PTR ModuleInfo+408, 512		; 00000200H

; 203  :     return( NOT_ERROR );

	xor	eax, eax

; 204  : }

	ret	0
SetEmulator ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 8
tokenarray$ = 16
SetNoOldStructs PROC

; 193  :     ModuleInfo.oldstructs = FALSE;

	and	DWORD PTR ModuleInfo+408, -257		; fffffeffH

; 194  :     return( NOT_ERROR );

	xor	eax, eax

; 195  : }

	ret	0
SetNoOldStructs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 8
tokenarray$ = 16
SetOldStructs PROC

; 184  :     ModuleInfo.oldstructs = TRUE;

	or	DWORD PTR ModuleInfo+408, 256		; 00000100H

; 185  :     return( NOT_ERROR );

	xor	eax, eax

; 186  : }

	ret	0
SetOldStructs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 8
tokenarray$ = 16
SetNoScoped PROC

; 175  :     ModuleInfo.scoped = FALSE;

	and	DWORD PTR ModuleInfo+408, -129		; ffffff7fH

; 176  :     return( NOT_ERROR );

	xor	eax, eax

; 177  : }

	ret	0
SetNoScoped ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 8
tokenarray$ = 16
SetScoped PROC

; 166  :     ModuleInfo.scoped = TRUE;

	or	DWORD PTR ModuleInfo+408, 128		; 00000080H

; 167  :     return( NOT_ERROR );

	xor	eax, eax

; 168  : }

	ret	0
SetScoped ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetNoM510 PROC

; 156  : {

	sub	rsp, 40					; 00000028H

; 157  :     SetMasm510(FALSE);

	xor	ecx, ecx
	call	SetMasm510

; 158  :     return( NOT_ERROR );

	xor	eax, eax

; 159  : }

	add	rsp, 40					; 00000028H
	ret	0
SetNoM510 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetM510	PROC

; 147  : {

	sub	rsp, 40					; 00000028H

; 148  :     SetMasm510( TRUE );

	mov	cl, 1
	call	SetMasm510

; 149  :     return( NOT_ERROR );

	xor	eax, eax

; 150  : }

	add	rsp, 40					; 00000028H
	ret	0
SetM510	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetCaseMap PROC

; 118  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 119  :     int i = *pi;

	movsxd	rsi, DWORD PTR [rcx]
	mov	rdi, rcx

; 120  :     if ( tokenarray[i].token == T_ID ) {

	mov	rbx, rsi
	shl	rbx, 5
	add	rbx, rdx
	cmp	BYTE PTR [rbx], 8
	jne	$LN2@SetCaseMap

; 121  :         if ( 0 == _stricmp( tokenarray[i].string_ptr, "NONE" ) ) {

	mov	rcx, QWORD PTR [rbx+8]
	lea	rdx, OFFSET FLAT:$SG10818
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN4@SetCaseMap

; 122  :             ModuleInfo.case_sensitive = TRUE;        /* -Cx */
; 123  :             ModuleInfo.convert_uppercase = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -3					; fffffffdH
	or	eax, 1
	jmp	SHORT $LN11@SetCaseMap
$LN4@SetCaseMap:

; 124  :         } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "NOTPUBLIC" ) ) {

	mov	rcx, QWORD PTR [rbx+8]
	lea	rdx, OFFSET FLAT:$SG10821
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN6@SetCaseMap

; 125  :             ModuleInfo.case_sensitive = FALSE;       /* -Cp */
; 126  :             ModuleInfo.convert_uppercase = FALSE;

	and	DWORD PTR ModuleInfo+408, -4		; fffffffcH

; 130  :         } else {
; 131  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );
; 132  :         }
; 133  :         DebugMsg1(("SetCaseMap(%s) ok\n", tokenarray[i].string_ptr ));
; 134  :         i++;
; 135  :         SymSetCmpFunc();

	call	SymSetCmpFunc
	lea	eax, DWORD PTR [rsi+1]

; 138  :     }
; 139  :     *pi = i;

	mov	DWORD PTR [rdi], eax

; 140  :     return( NOT_ERROR );

	xor	eax, eax

; 141  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@SetCaseMap:

; 127  :         } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "ALL" ) ) {

	mov	rcx, QWORD PTR [rbx+8]
	lea	rdx, OFFSET FLAT:$SG10824
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN2@SetCaseMap

; 128  :             ModuleInfo.case_sensitive = FALSE;       /* -Cu */

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -2					; fffffffeH

; 129  :             ModuleInfo.convert_uppercase = TRUE;

	or	eax, 2
$LN11@SetCaseMap:
	mov	DWORD PTR ModuleInfo+408, eax

; 130  :         } else {
; 131  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );
; 132  :         }
; 133  :         DebugMsg1(("SetCaseMap(%s) ok\n", tokenarray[i].string_ptr ));
; 134  :         i++;
; 135  :         SymSetCmpFunc();

	call	SymSetCmpFunc
	lea	eax, DWORD PTR [rsi+1]

; 138  :     }
; 139  :     *pi = i;

	mov	DWORD PTR [rdi], eax

; 140  :     return( NOT_ERROR );

	xor	eax, eax

; 141  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@SetCaseMap:

; 136  :     } else {
; 137  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rbx+24]
	mov	ecx, 209				; 000000d1H

; 141  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 136  :     } else {
; 137  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	jmp	EmitErr
SetCaseMap ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 8
tokenarray$ = 16
SetNoDotName PROC

; 110  :     ModuleInfo.dotname = FALSE;

	and	DWORD PTR ModuleInfo+408, -17		; ffffffefH

; 111  :     return( NOT_ERROR );

	xor	eax, eax

; 112  : }

	ret	0
SetNoDotName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 8
tokenarray$ = 16
SetDotName PROC

; 101  :     ModuleInfo.dotname = TRUE;

	or	DWORD PTR ModuleInfo+408, 16

; 102  :     return( NOT_ERROR );

	xor	eax, eax

; 103  : }

	ret	0
SetDotName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
opndx$ = 48
i$ = 176
pi$ = 176
tokenarray$ = 184
SetZeroLocals PROC

; 78   : {

	mov	r11, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 79   : 	int i = *pi;

	mov	eax, DWORD PTR [rcx]

; 80   : 	struct expr opndx;
; 81   : 
; 82   : 	if (EvalOperand(&i, tokenarray, Token_Count, &opndx, 0) == ERROR)

	lea	r9, QWORD PTR [r11-120]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rbx, rcx
	lea	rcx, QWORD PTR [r11+8]
	mov	DWORD PTR [r11+8], eax
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN2@SetZeroLoc

; 83   : 		return(ERROR);

	or	eax, eax

; 95   : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN2@SetZeroLoc:

; 84   : 	if (opndx.kind == EXPR_CONST) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN3@SetZeroLoc

; 85   : 		if (opndx.llvalue > 1) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	rax, 1
	jbe	SHORT $LN5@SetZeroLoc

; 86   : 			return(EmitConstError(&opndx));

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError

; 95   : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN5@SetZeroLoc:

; 87   : 		}
; 88   : 		ZEROLOCALS = opndx.llvalue;

	mov	BYTE PTR ZEROLOCALS, al

; 92   : 	}
; 93   : 	*pi = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR [rbx], eax

; 94   : 	return(NOT_ERROR);

	xor	eax, eax

; 95   : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN3@SetZeroLoc:

; 89   : 	}
; 90   : 	else {
; 91   : 		return(EmitError(CONSTANT_EXPECTED));

	mov	ecx, 65					; 00000041H
	call	EmitError

; 95   : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
SetZeroLocals ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
opndx$ = 48
i$ = 176
pi$ = 176
tokenarray$ = 184
SetEvex	PROC

; 37   : {

	mov	r11, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 38   : 	int i = *pi;

	mov	eax, DWORD PTR [rcx]

; 39   : 	struct expr opndx;
; 40   : 
; 41   : 	if (EvalOperand(&i, tokenarray, Token_Count, &opndx, 0) == ERROR)

	lea	r9, QWORD PTR [r11-120]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rbx, rcx
	lea	rcx, QWORD PTR [r11+8]
	mov	DWORD PTR [r11+8], eax
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN2@SetEvex

; 42   : 		return(ERROR);

	or	eax, eax

; 54   : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN2@SetEvex:

; 43   : 	if (opndx.kind == EXPR_CONST) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN3@SetEvex

; 44   : 		if (opndx.llvalue > 1) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	rax, 1
	jbe	SHORT $LN5@SetEvex

; 45   : 			return(EmitConstError(&opndx));

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError

; 54   : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN5@SetEvex:

; 46   : 		}
; 47   : 		evex = opndx.llvalue;

	mov	BYTE PTR evex, al

; 51   : 	}
; 52   : 	*pi = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR [rbx], eax

; 53   : 	return(NOT_ERROR);

	xor	eax, eax

; 54   : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN3@SetEvex:

; 48   : 	}
; 49   : 	else {
; 50   : 		return(EmitError(CONSTANT_EXPECTED));

	mov	ecx, 65					; 00000041H
	call	EmitError

; 54   : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
SetEvex	ENDP
_TEXT	ENDS
END
