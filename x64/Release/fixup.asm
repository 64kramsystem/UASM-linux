; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	Frame_Type:BYTE
COMM	Frame_Datum:WORD
_DATA	ENDS
PUBLIC	CreateFixup
PUBLIC	SetFixupFrame
PUBLIC	FreeFixup
PUBLIC	store_fixup
EXTRN	LclAlloc:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	GetSegIdx:PROC
EXTRN	GetGroup:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
pdata	SEGMENT
$pdata$CreateFixup DD imagerel $LN7
	DD	imagerel $LN7+188
	DD	imagerel $unwind$CreateFixup
$pdata$SetFixupFrame DD imagerel $LN15
	DD	imagerel $LN15+182
	DD	imagerel $unwind$SetFixupFrame
pdata	ENDS
xdata	SEGMENT
$unwind$CreateFixup DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$SetFixupFrame DD 020e01H
	DD	0300a320eH
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\fixup.c
_TEXT	SEGMENT
fixup$ = 8
seg$ = 16
pdata$ = 24
store_fixup PROC

; 197  :     //struct fixup     *fixup;
; 198  : 
; 199  :     //fixup = CodeInfo->InsFixup[index];
; 200  : 
; 201  :     //CodeInfo->data[index] = CodeInfo->data[index] - fixup->sym->offset;
; 202  :     //fixup->offset = CodeInfo->data[index];
; 203  :     fixup->offset = *pdata;

	mov	eax, DWORD PTR [r8]
	mov	r9, rcx
	mov	DWORD PTR [rcx+16], eax

; 204  : 
; 205  : #ifdef DEBUG_OUT
; 206  :     if ( fixup->sym )
; 207  :         DebugMsg1(("store_fixup: type=%u, loc=%s.%" I32_SPEC "X, target=%s(%" I32_SPEC "X+% " I32_SPEC "X)\n",
; 208  :                 fixup->type, seg->sym.name, fixup->locofs, fixup->sym->name, fixup->sym->offset, fixup->offset ));
; 209  :     else
; 210  :         DebugMsg1(("store_fixup: type=%u, loc=%s.%" I32_SPEC "X, target=%" I32_SPEC "X\n",
; 211  :                 fixup->type, seg->sym.name, fixup->locofs, fixup->offset));
; 212  : #endif
; 213  : 
; 214  :     fixup->nextrlc = NULL;

	mov	QWORD PTR [rcx+8], 0

; 215  : #if 0
; 216  :     /* v2.07: no error checks here! store_fixup() is called only if pass > 1
; 217  :      * and as long as write_to_file is true! This check is now done in
; 218  :      * codegen() and data_item().
; 219  :      */
; 220  :     if ( ( 1 << fixup->type ) & ModuleInfo.fmtopt->invalid_fixup_type ) {
; 221  :         EmitErr( UNSUPPORTED_FIXUP_TYPE,
; 222  :                ModuleInfo.fmtopt->formatname,
; 223  :                fixup->sym ? fixup->sym->name : szNull );
; 224  :         return( ERROR );
; 225  :     }
; 226  : #endif
; 227  :     if ( Options.output_format == OFORMAT_OMF ) {

	mov	eax, DWORD PTR Options+144
	cmp	eax, 1
	jne	SHORT $LN2@store_fixu

; 228  : 
; 229  :         /* for OMF, the target's offset is stored at the fixup's location. */
; 230  :         if( fixup->type != FIX_SEG && fixup->sym ) {

	cmp	DWORD PTR [rcx+24], 8
	je	SHORT $LN13@store_fixu
	mov	rax, QWORD PTR [rcx+56]
	test	rax, rax
	je	SHORT $LN13@store_fixu

; 231  :             *pdata += fixup->sym->offset;

	mov	eax, DWORD PTR [rax+16]
	add	DWORD PTR [r8], eax

; 232  :         }
; 233  : 
; 234  :     } else {

	jmp	SHORT $LN13@store_fixu
$LN2@store_fixu:

; 235  : 
; 236  : #if ELF_SUPPORT
; 237  :         if ( Options.output_format == OFORMAT_ELF ) {

	cmp	eax, 3
	jne	SHORT $LN12@store_fixu

; 238  :             /* v2.07: inline addend for ELF32 only.
; 239  :              * Also, in 64-bit, pdata may be a int_64 pointer (FIX_OFF64)!
; 240  :              */
; 241  : #if AMD64_SUPPORT
; 242  :             if ( ModuleInfo.defOfssize == USE64 ) {

	cmp	BYTE PTR ModuleInfo+405, 2
	je	SHORT $LN12@store_fixu

; 243  : #if 0
; 244  :                 /* this won't work currently because fixup.offset may have to
; 245  :                  * save *(int_64) pdata, but it is 32-bit only!
; 246  :                  */
; 247  :                 if ( fixup->type == FIX_OFF64 )
; 248  :                     *(int_64 *)pdata = 0;
; 249  :                 else
; 250  :                     *pdata = 0;
; 251  : #endif
; 252  :             } else
; 253  : #endif
; 254  :             if ( fixup->type == FIX_RELOFF32 )

	mov	eax, DWORD PTR [rcx+24]
	cmp	eax, 3
	jne	SHORT $LN8@store_fixu

; 255  :                 *pdata = -4;

	mov	DWORD PTR [r8], -4
	jmp	SHORT $LN12@store_fixu
$LN8@store_fixu:

; 256  : #if GNURELOCS /* v2.04: added */
; 257  :             else if ( fixup->type == FIX_RELOFF16 )

	cmp	eax, 2
	jne	SHORT $LN10@store_fixu

; 258  :                 *pdata = -2;

	mov	DWORD PTR [r8], -2
	jmp	SHORT $LN12@store_fixu
$LN10@store_fixu:

; 259  :             else if ( fixup->type == FIX_RELOFF8 )

	cmp	eax, 1
	jne	SHORT $LN12@store_fixu

; 260  :                 *pdata = -1;

	mov	DWORD PTR [r8], -1
$LN12@store_fixu:

; 261  : #endif
; 262  :         }
; 263  : #endif
; 264  : #if DJGPP_SUPPORT
; 265  :         /* Djgpp's COFF variant needs special handling for
; 266  :          * - at least - relative and direct 32-bit offsets.
; 267  :          */
; 268  :         if ( fixup->sym && ModuleInfo.sub_format == SFORMAT_DJGPP ) {
; 269  :             if ( fixup->type == FIX_RELOFF32 ) { /* probably also for 16-bit */
; 270  :                 *pdata -= ( fixup->locofs + 4 );
; 271  :             } else if ( fixup->type == FIX_OFF32 ) {
; 272  :                 *pdata += fixup->sym->offset;
; 273  :                 fixup->offset += fixup->sym->offset; /* ok? */
; 274  :                 fixup->segment = fixup->sym->segment;/* ok? */
; 275  :             }
; 276  :         } else
; 277  : #endif
; 278  :         /* special handling for assembly time variables needed */
; 279  :         if ( fixup->sym && fixup->sym->variable ) {

	mov	rax, QWORD PTR [rcx+56]
	test	rax, rax
	je	SHORT $LN13@store_fixu
	test	BYTE PTR [rax+40], 64			; 00000040H
	je	SHORT $LN13@store_fixu

; 280  :             /* add symbol's offset to the fixup location and fixup's offset */
; 281  :             *pdata += fixup->sym->offset;

	mov	eax, DWORD PTR [rax+16]
	add	DWORD PTR [r8], eax

; 282  :             fixup->offset         += fixup->sym->offset;

	mov	rcx, QWORD PTR [rcx+56]
	mov	eax, DWORD PTR [rcx+16]
	add	DWORD PTR [r9+16], eax

; 283  :             /* and save symbol's segment in fixup */
; 284  :             fixup->segment_var = fixup->sym->segment;

	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [r9+40], rax
$LN13@store_fixu:

; 285  :         }
; 286  : #if 0   /* fixup without symbol: this is to be resolved internally! */
; 287  :         else if ( fixup->sym == NULL && fixup->frame == EMPTY ) {
; 288  :             DebugMsg(("store_fixup: fixup skipped, symbol=0, no frame\n" ));
; 289  :             return( NOT_ERROR );
; 290  :         }
; 291  : #endif
; 292  :     }
; 293  :     if( seg->e.seginfo->FixupList.head == NULL ) {

	mov	rax, QWORD PTR [rdx+96]
	cmp	QWORD PTR [rax+40], 0
	jne	SHORT $LN14@store_fixu

; 294  :         seg->e.seginfo->FixupList.tail = seg->e.seginfo->FixupList.head = fixup;

	mov	QWORD PTR [rax+40], r9

; 297  :         seg->e.seginfo->FixupList.tail = fixup;

	mov	rax, QWORD PTR [rdx+96]
	mov	QWORD PTR [rax+48], r9

; 298  :     }
; 299  :     return;
; 300  : }

	ret	0
$LN14@store_fixu:

; 295  :     } else {
; 296  :         seg->e.seginfo->FixupList.tail->nextrlc = fixup;

	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR [rax+8], r9

; 297  :         seg->e.seginfo->FixupList.tail = fixup;

	mov	rax, QWORD PTR [rdx+96]
	mov	QWORD PTR [rax+48], r9

; 298  :     }
; 299  :     return;
; 300  : }

	ret	0
store_fixup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\fixup.c
_TEXT	SEGMENT
fixup$ = 8
FreeFixup PROC

; 120  :     struct dsym *dir;
; 121  :     struct fixup *fixup2;
; 122  : 
; 123  :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN3@FreeFixup

; 124  :         dir = fixup->def_seg;

	mov	rax, QWORD PTR [rcx+48]

; 125  :         if ( dir ) {

	test	rax, rax
	je	SHORT $LN3@FreeFixup

; 126  :             if ( fixup == dir->e.seginfo->FixupList.head ) {

	mov	r8, QWORD PTR [rax+96]
	mov	rdx, QWORD PTR [r8+40]
	cmp	rcx, rdx
	jne	SHORT $LN7@FreeFixup

; 127  :                 dir->e.seginfo->FixupList.head = fixup->nextrlc;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [r8+40], rax

; 132  :                         break;
; 133  :                     }
; 134  :                 }
; 135  :             }
; 136  :         }
; 137  :     }
; 138  :     LclFree( fixup );
; 139  : }

	ret	0
$LN7@FreeFixup:

; 128  :             } else {
; 129  :                 for ( fixup2 = dir->e.seginfo->FixupList.head; fixup2; fixup2 = fixup2->nextrlc ) {

	test	rdx, rdx
	je	SHORT $LN3@FreeFixup
	npad	3
$LL4@FreeFixup:

; 130  :                     if ( fixup2->nextrlc == fixup ) {

	mov	rax, QWORD PTR [rdx+8]
	cmp	rax, rcx
	je	SHORT $LN12@FreeFixup

; 128  :             } else {
; 129  :                 for ( fixup2 = dir->e.seginfo->FixupList.head; fixup2; fixup2 = fixup2->nextrlc ) {

	mov	rdx, rax
	test	rax, rax
	jne	SHORT $LL4@FreeFixup

; 132  :                         break;
; 133  :                     }
; 134  :                 }
; 135  :             }
; 136  :         }
; 137  :     }
; 138  :     LclFree( fixup );
; 139  : }

	ret	0
$LN12@FreeFixup:

; 131  :                         fixup2->nextrlc = fixup->nextrlc;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+8], rax
$LN3@FreeFixup:

; 132  :                         break;
; 133  :                     }
; 134  :                 }
; 135  :             }
; 136  :         }
; 137  :     }
; 138  :     LclFree( fixup );
; 139  : }

	ret	0
FreeFixup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\fixup.c
_TEXT	SEGMENT
sym$ = 48
ign_grp$ = 56
SetFixupFrame PROC

; 150  : {

$LN15:

; 151  :     struct dsym *grp;
; 152  : 
; 153  :     if( sym ) {

	test	rcx, rcx
	je	$LN12@SetFixupFr
	push	rbx
	sub	rsp, 32					; 00000020H

; 154  :         switch ( sym->state ) {

	mov	eax, DWORD PTR [rcx+32]
	mov	rbx, rcx
	test	eax, eax
	jle	$LN8@SetFixupFr
	cmp	eax, 2
	jle	SHORT $LN5@SetFixupFr
	cmp	eax, 3
	je	SHORT $LN9@SetFixupFr
	cmp	eax, 4
	jne	$LN8@SetFixupFr

; 170  :             break;
; 171  :         case SYM_GRP:
; 172  :             Frame_Type = FRAME_GRP;

	mov	BYTE PTR Frame_Type, 1

; 173  :             Frame_Datum = ((struct dsym *)sym)->e.grpinfo->grp_idx;

	mov	rax, QWORD PTR [rcx+96]
	movzx	ecx, WORD PTR [rax+8]
	mov	WORD PTR Frame_Datum, cx

; 174  :             break;
; 175  : #ifdef DEBUG_OUT
; 176  :         case SYM_UNDEFINED:
; 177  :         case SYM_STACK:
; 178  :             break;
; 179  :         default:
; 180  :             DebugMsg(("SetFixupFrame(%s): unexpected state=%u\n", sym->name, sym->state ));
; 181  :             /**/myassert( 0 );
; 182  :             break;
; 183  : #endif
; 184  :         }
; 185  :     }
; 186  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN9@SetFixupFr:

; 164  :                 }
; 165  :             }
; 166  :             break;
; 167  :         case SYM_SEG:
; 168  :             Frame_Type = FRAME_SEG;

	mov	BYTE PTR Frame_Type, 0

; 169  :             Frame_Datum = GetSegIdx( sym->segment );

	mov	rcx, QWORD PTR [rcx+24]
	call	GetSegIdx
	mov	WORD PTR Frame_Datum, ax

; 174  :             break;
; 175  : #ifdef DEBUG_OUT
; 176  :         case SYM_UNDEFINED:
; 177  :         case SYM_STACK:
; 178  :             break;
; 179  :         default:
; 180  :             DebugMsg(("SetFixupFrame(%s): unexpected state=%u\n", sym->name, sym->state ));
; 181  :             /**/myassert( 0 );
; 182  :             break;
; 183  : #endif
; 184  :         }
; 185  :     }
; 186  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@SetFixupFr:

; 155  :         case SYM_INTERNAL:
; 156  :         case SYM_EXTERNAL:
; 157  :             if( sym->segment != NULL ) {

	cmp	QWORD PTR [rcx+24], 0
	je	SHORT $LN8@SetFixupFr

; 158  :                 if( ign_grp == FALSE && ( grp = (struct dsym *)GetGroup( sym ) ) ) {

	test	dl, dl
	jne	SHORT $LN7@SetFixupFr
	call	GetGroup
	test	rax, rax
	je	SHORT $LN7@SetFixupFr

; 159  :                     Frame_Type = FRAME_GRP;

	mov	BYTE PTR Frame_Type, 1

; 160  :                     Frame_Datum = grp->e.grpinfo->grp_idx;

	mov	rax, QWORD PTR [rax+96]
	movzx	ecx, WORD PTR [rax+8]
	mov	WORD PTR Frame_Datum, cx

; 174  :             break;
; 175  : #ifdef DEBUG_OUT
; 176  :         case SYM_UNDEFINED:
; 177  :         case SYM_STACK:
; 178  :             break;
; 179  :         default:
; 180  :             DebugMsg(("SetFixupFrame(%s): unexpected state=%u\n", sym->name, sym->state ));
; 181  :             /**/myassert( 0 );
; 182  :             break;
; 183  : #endif
; 184  :         }
; 185  :     }
; 186  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN7@SetFixupFr:

; 161  :                 } else {
; 162  :                     Frame_Type = FRAME_SEG;

	mov	BYTE PTR Frame_Type, 0

; 163  :                     Frame_Datum = GetSegIdx( sym->segment );

	mov	rcx, QWORD PTR [rbx+24]
	call	GetSegIdx
	mov	WORD PTR Frame_Datum, ax
$LN8@SetFixupFr:

; 174  :             break;
; 175  : #ifdef DEBUG_OUT
; 176  :         case SYM_UNDEFINED:
; 177  :         case SYM_STACK:
; 178  :             break;
; 179  :         default:
; 180  :             DebugMsg(("SetFixupFrame(%s): unexpected state=%u\n", sym->name, sym->state ));
; 181  :             /**/myassert( 0 );
; 182  :             break;
; 183  : #endif
; 184  :         }
; 185  :     }
; 186  : }

	add	rsp, 32					; 00000020H
	pop	rbx
$LN12@SetFixupFr:
	ret	0
SetFixupFrame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\fixup.c
_TEXT	SEGMENT
sym$ = 48
type$ = 56
option$ = 64
CreateFixup PROC

; 61   : {

$LN7:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	esi, r8d

; 62   : #ifdef DEBUG_OUT
; 63   :     static uint_32 cnt = 0;
; 64   : #endif
; 65   :     struct fixup     *fixup;
; 66   : 
; 67   :     fixup = LclAlloc( sizeof( struct fixup ) );

	mov	ecx, 64					; 00000040H
	mov	ebp, edx
	call	LclAlloc

; 68   : #ifdef TRMEM
; 69   :     fixup->marker = 'XF';
; 70   :     DebugMsg1(("CreateFixup, pass=%u: fix=%p sym=%s\n", Parse_Pass+1, fixup, sym ? sym->name : "NULL" ));
; 71   : #endif
; 72   : 
; 73   :     /* add the fixup to the symbol's linked list (used for backpatch)
; 74   :      * this is done for pass 1 only.
; 75   :      */
; 76   :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	rbx, rax
	jne	SHORT $LN4@CreateFixu

; 77   : #ifdef DEBUG_OUT
; 78   :         if ( Options.nobackpatch == FALSE )
; 79   : #endif
; 80   :         if ( sym ) { /* changed v1.96 */

	test	rdi, rdi
	je	SHORT $LN3@CreateFixu

; 81   :             fixup->nextbp = sym->bp_fixup;

	mov	r9, QWORD PTR [rdi+88]
	mov	QWORD PTR [rax], r9

; 82   :             sym->bp_fixup = fixup;

	mov	QWORD PTR [rdi+88], rax
$LN3@CreateFixu:

; 83   :         }
; 84   :         /* v2.03: in pass one, create a linked list of
; 85   :          * fixup locations for a segment. This is to improve
; 86   :          * backpatching, because it allows to adjust fixup locations
; 87   :          * after a distance has changed from short to near
; 88   :          */
; 89   : #ifdef DEBUG_OUT
; 90   :         if ( Options.nobackpatch == FALSE )
; 91   : #endif
; 92   :         if ( CurrSeg ) {

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	je	SHORT $LN4@CreateFixu

; 93   :             fixup->nextrlc = CurrSeg->e.seginfo->FixupList.head;

	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR [rax+40]
	mov	QWORD PTR [rbx+8], rcx

; 94   :             CurrSeg->e.seginfo->FixupList.head = fixup;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	mov	QWORD PTR [rcx+40], rbx
$LN4@CreateFixu:

; 95   :         }
; 96   :     }
; 97   :     /* initialize locofs member with current offset.
; 98   :      * It's unlikely to be the final location, but sufficiently exact for backpatching.
; 99   :      */
; 100  :     fixup->locofs = GetCurrOffset();

	call	GetCurrOffset
	mov	DWORD PTR [rbx+20], eax

; 101  :     fixup->offset = 0;

	xor	eax, eax
	mov	DWORD PTR [rbx+16], eax

; 102  :     fixup->type = type;
; 103  :     fixup->option = option;
; 104  :     fixup->flags = 0;

	mov	WORD PTR [rbx+32], ax
	mov	DWORD PTR [rbx+24], ebp

; 105  :     fixup->frame_type = Frame_Type;     /* this is just a guess */
; 106  :     fixup->frame_datum = Frame_Datum;
; 107  :     fixup->def_seg = CurrSeg;           /* may be NULL (END directive) */
; 108  :     fixup->sym = sym;
; 109  : 
; 110  :     DebugMsg1(("CreateFixup(sym=%s type=%u, opt=%u) cnt=%" I32_SPEC "X, loc=%" I32_SPEC "Xh\n",
; 111  :         sym ? sym->name : "NULL", type, option, ++cnt, fixup->locofs ));
; 112  :     return( fixup );
; 113  : }

	mov	rbp, QWORD PTR [rsp+56]
	mov	DWORD PTR [rbx+28], esi
	movzx	eax, BYTE PTR Frame_Type
	mov	rsi, QWORD PTR [rsp+64]
	mov	BYTE PTR [rbx+40], al
	movzx	eax, WORD PTR Frame_Datum
	mov	WORD PTR [rbx+42], ax
	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rbx+48], rax
	mov	rax, rbx
	mov	QWORD PTR [rbx+56], rdi
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CreateFixup ENDP
_TEXT	ENDS
END
