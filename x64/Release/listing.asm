; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG11459 DB	01H DUP (?)
$SG11475 DB	01H DUP (?)
$SG11544 DB	01H DUP (?)
$SG11557 DB	01H DUP (?)
$SG11583 DB	01H DUP (?)
$SG11585 DB	01H DUP (?)
$SG11599 DB	01H DUP (?)
$SG11618 DB	01H DUP (?)
$SG11628 DB	01H DUP (?)
$SG11648 DB	01H DUP (?)
$SG11717 DB	01H DUP (?)
$SG11740 DB	01H DUP (?)
$SG11744 DB	01H DUP (?)
$SG11745 DB	01H DUP (?)
$SG11751 DB	01H DUP (?)
$SG11766 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
COMM	list_pos:DWORD
_DATA	ENDS
_BSS	SEGMENT
$SG11230 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG11359 DB	'%08X', 00H
	ORG $+3
$SG11370 DB	'%02X', 00H
	ORG $+3
$SG11372 DB	'%02X', 00H
	ORG $+3
$SG11375 DB	'%08X', 00H
	ORG $+3
$SG11379 DB	'%-25I64X', 00H
	ORG $+3
$SG11380 DB	'%-25X', 00H
	ORG $+2
$SG11386 DB	'%08X', 00H
	ORG $+3
$SG11390 DB	'%08X', 00H
	ORG $+3
$SG11393 DB	0dH, 0aH, 00H
	ORG $+1
$SG11399 DB	'%u', 00H
	ORG $+1
$SG11405 DB	0dH, 0aH, 00H
	ORG $+1
$SG11406 DB	0dH, 0aH, 00H
	ORG $+1
$SG11421 DB	0dH, 0aH, 00H
	ORG $+1
$SG11441 DB	'%u', 00H
	ORG $+1
$SG11452 DB	'?', 00H
	ORG $+2
$SG11460 DB	'%s %s        %s', 00H
$SG11499 DB	'%s %s ', 00H
	ORG $+1
$SG11511 DB	'?', 00H
	ORG $+2
$SG11517 DB	'?', 00H
	ORG $+2
$SG11545 DB	' ', 00H
	ORG $+2
$SG11558 DB	' ', 00H
	ORG $+2
$SG11550 DB	'%s %s        %8X (%u)', 00H
	ORG $+2
$SG11551 DB	'%s %s        %8X', 00H
	ORG $+3
$SG11560 DB	'%s', 00H
	ORG $+1
$SG11552 DB	'%s %s        %8X', 00H
	ORG $+3
$SG11588 DB	'?', 00H
	ORG $+2
$SG11559 DB	'%s %s        %8X   ', 00H
$SG11562 DB	'[%u]', 00H
	ORG $+3
$SG11590 DB	'?', 00H
	ORG $+2
$SG11584 DB	'%s %s      %6X  %7X', 00H
$SG11602 DB	' ', 00H
	ORG $+2
$SG11589 DB	'  %s %s      %6X  %7X  %016I64X %s', 00H
	ORG $+1
$SG11604 DB	' ', 00H
	ORG $+2
$SG11591 DB	'  %s %s      %6X  %7X  %08X %s', 00H
	ORG $+1
$SG11605 DB	' ', 00H
	ORG $+2
$SG11664 DB	' ', 00H
	ORG $+2
$SG11606 DB	'%s %s    %8u  %s', 00H
	ORG $+3
$SG11722 DB	'%0*X ', 00H
	ORG $+2
$SG11729 DB	'*%-8s ', 00H
	ORG $+1
$SG11733 DB	'%s', 00H
	ORG $+1
$SG11619 DB	'%s %s        ', 00H
	ORG $+2
$SG11622 DB	'32 Bit   %08X ', 00H
	ORG $+1
$SG11625 DB	'64 Bit   %08X ', 00H
	ORG $+1
$SG11626 DB	'16 Bit   %04X     ', 00H
	ORG $+1
$SG11735 DB	'  ', 00H
	ORG $+1
$SG11627 DB	'%-7s %-8s', 00H
	ORG $+2
$SG11629 DB	'''%s''', 00H
	ORG $+3
$SG11730 DB	'%-9s ', 00H
	ORG $+2
$SG11748 DB	'%s[%u]', 00H
	ORG $+1
$SG11791 DB	'%s ', 00H
$SG11649 DB	'%s %s        %s', 00H
$SG11720 DB	'%s %s        P %-6s %08X %-8s ', 00H
	ORG $+1
$SG11721 DB	'%s %s        P %-6s %04X     %-8s ', 00H
	ORG $+1
$SG11725 DB	'%-9s', 00H
	ORG $+3
$SG11728 DB	'%-9s', 00H
	ORG $+3
$SG11771 DB	'%s[%u]', 00H
	ORG $+1
$SG11795 DB	'%s ', 00H
$SG11732 DB	'(%.8s) ', 00H
$SG11743 DB	'  %s %s        %-17s %s', 00H
$SG11754 DB	'  %s %s        L %-6s %08X %s', 00H
	ORG $+2
$SG11755 DB	'  %s %s        L %-6s %04X     %s', 00H
	ORG $+2
$SG11772 DB	'%-10s ', 00H
	ORG $+1
$SG11799 DB	'%s ', 00H
$SG11768 DB	'%s %s        ', 00H
	ORG $+2
$SG11775 DB	'%-10s ', 00H
	ORG $+1
$SG11776 DB	'%-10s ', 00H
	ORG $+1
$SG11779 DB	' %8Xh ', 00H
	ORG $+1
$SG11784 DB	' %I64Xh ', 00H
	ORG $+3
$SG11788 DB	' %8Xh ', 00H
	ORG $+1
$SG11801 DB	'%s ', 00H
$SG11787 DB	'-%08Xh ', 00H
$SG11789 DB	' %8Xh ', 00H
	ORG $+1
$SG11793 DB	'%s=%u ', 00H
	ORG $+1
$SG11798 DB	'*%s ', 00H
	ORG $+3
$SG11802 DB	'%s', 00H
	ORG $+1
$SG11201 DB	'Far', 00H
$SG11804 DB	'%s %s        %s   %s', 00H
	ORG $+3
$SG11806 DB	'%s %s        %s  %s', 00H
$SG11188 DB	'Byte', 00H
	ORG $+3
$SG11189 DB	'Word', 00H
	ORG $+3
$SG11190 DB	'DWord', 00H
	ORG $+2
$SG11191 DB	'FWord', 00H
	ORG $+2
$SG11192 DB	'QWord', 00H
	ORG $+2
$SG11193 DB	'TByte', 00H
	ORG $+2
$SG11194 DB	'Para', 00H
	ORG $+3
$SG11198 DB	'Near16', 00H
	ORG $+1
$SG11213 DB	'Ptr', 00H
$SG11195 DB	'XmmWord', 00H
$SG11196 DB	'Page', 00H
	ORG $+3
$SG11197 DB	'Near', 00H
	ORG $+3
$SG11199 DB	'Near32', 00H
	ORG $+1
$SG11200 DB	'Near64', 00H
	ORG $+1
$SG11202 DB	'Far16', 00H
	ORG $+2
$SG11203 DB	'Far32', 00H
	ORG $+2
$SG11204 DB	'Far64', 00H
	ORG $+2
$SG11205 DB	'L Near', 00H
	ORG $+1
$SG11206 DB	'L Near16', 00H
	ORG $+3
$SG11209 DB	'L Far', 00H
	ORG $+2
$SG11216 DB	'Number', 00H
	ORG $+1
$SG11227 DB	'Abs', 00H
$SG11207 DB	'L Near32', 00H
	ORG $+3
$SG11218 DB	'Stack', 00H
	ORG $+2
$SG11219 DB	'Public', 00H
	ORG $+1
$SG11231 DB	'C', 00H
	ORG $+2
$SG11208 DB	'L Near64', 00H
	ORG $+3
$SG11220 DB	'Common', 00H
	ORG $+5
$SG11210 DB	'L Far16', 00H
$SG11211 DB	'L Far32', 00H
$SG11212 DB	'L Far64', 00H
$SG11214 DB	'Proc', 00H
	ORG $+3
$SG11215 DB	'Func', 00H
	ORG $+3
$SG11217 DB	'Private', 00H
$SG11221 DB	'External', 00H
	ORG $+7
$SG11222 DB	'Undefined', 00H
	ORG $+2
$SG11223 DB	'GROUP', 00H
	ORG $+2
$SG11224 DB	'No Seg', 00H
	ORG $+1
$SG11225 DB	'Text', 00H
	ORG $+3
$SG11226 DB	'Alias', 00H
	ORG $+2
$SG11228 DB	'COMM', 00H
	ORG $+3
$SG11229 DB	'VARARG', 00H
	ORG $+5
$SG11232 DB	'SYSCALL', 00H
$SG11233 DB	'STDCALL', 00H
$SG11234 DB	'PASCAL', 00H
	ORG $+1
$SG11235 DB	'FORTRAN', 00H
$SG11236 DB	'BASIC', 00H
	ORG $+2
$SG11237 DB	'FASTCALL', 00H
	ORG $+7
$SG11238 DB	'Macros:', 00H
$SG11239 DB	'                N a m e                 Type', 00H
	ORG $+3
$SG11240 DB	'Structures and Unions:', 00H
	ORG $+1
$SG11241 DB	'                N a m e                 Size/Ofs   Type', 00H
$SG11242 DB	'Records:', 00H
	ORG $+3
$SG11244 DB	'Types:', 00H
	ORG $+5
$SG11243 DB	'                N a m e                 Width   # fields'
	DB	0aH, '                                        Shift   Width   '
	DB	' Mask   Initial', 00H
	ORG $+7
$SG11245 DB	'                N a m e                 Size    Attr', 00H
	ORG $+3
$SG11246 DB	'Segments and Groups:', 00H
	ORG $+3
$SG11248 DB	'Procedures, parameters and locals:', 00H
	ORG $+5
$SG11247 DB	'                N a m e                 Size     Length '
	DB	'  Align   Combine Class', 00H
$SG11249 DB	'                N a m e                 Type     Value  '
	DB	'  Segment  Length', 00H
	ORG $+6
$SG11250 DB	'Symbols:', 00H
	ORG $+7
$SG11251 DB	'                N a m e                 Type       Value'
	DB	'     Attr', 00H
_DATA	ENDS
CONST	SEGMENT
maccap	DW	032H
	DW	033H
	DW	00H
	ORG $+2
strcap	DW	034H
	DW	035H
	DW	00H
	ORG $+2
reccap	DW	036H
	DW	037H
	DW	00H
	ORG $+2
tdcap	DW	038H
	DW	039H
	DW	00H
	ORG $+2
segcap	DW	03aH
	DW	03bH
	DW	00H
	ORG $+2
prccap	DW	03cH
	DW	03dH
	DW	00H
	ORG $+2
cr	DW	00H
	DW	00H
	ORG $+4
	DQ	FLAT:maccap
	DQ	FLAT:log_macro
	DW	01H
	DW	00H
	ORG $+4
	DQ	FLAT:strcap
	DQ	FLAT:log_struct
	DW	02H
	DW	00H
	ORG $+4
	DQ	FLAT:reccap
	DQ	FLAT:log_record
	DW	03H
	DW	00H
	ORG $+4
	DQ	FLAT:tdcap
	DQ	FLAT:log_typedef
	DW	04H
	DW	00H
	ORG $+4
	DQ	FLAT:segcap
	DQ	FLAT:log_segment
	DW	05H
	DW	01H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:log_group
	DW	06H
	DW	00H
	ORG $+4
	DQ	FLAT:prccap
	DQ	FLAT:log_proc
dots	DB	' . . . . . . . . . . . . . . . .', 00H
	ORG $+3
szCount	DB	'count', 00H
	ORG $+6
szFmtProcStk DB	'  %s %s        %-17s %s %c %04X', 00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	sprintf
PUBLIC	LstInit
PUBLIC	LstWrite
PUBLIC	LstWriteSrcLine
PUBLIC	LstWriteCRef
PUBLIC	LstPrintf
PUBLIC	LstNL
PUBLIC	LstSetPosition
PUBLIC	ListingDirective
PUBLIC	ListMacroDirective
EXTRN	fseek:PROC
EXTRN	fwrite:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	qsort:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	MemAlloc:PROC
EXTRN	MemFree:PROC
EXTRN	SymLookup:PROC
EXTRN	SymGetAll:PROC
EXTRN	SymGetCount:PROC
EXTRN	GetResWName:PROC
EXTRN	GetSymOfssize:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	get_curr_srcfile:PROC
EXTRN	GetFName:PROC
EXTRN	MsgGetEx:PROC
EXTRN	memset:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	MacroLevel:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	LineStoreCurr:QWORD
EXTRN	UseSavedState:BYTE
EXTRN	CurrStruct:QWORD
EXTRN	LastCodeBufSize:DWORD
EXTRN	__ImageBase:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

?prefix@?1??log_struct@@9@9 DD 01H DUP (?)		; `log_struct'::`2'::prefix
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vfprintf DD imagerel $LN6
	DD	imagerel $LN6+67
	DD	imagerel $unwind$vfprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN8
	DD	imagerel $LN8+90
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$LstInit DD imagerel $LN13
	DD	imagerel $LN13+32
	DD	imagerel $unwind$LstInit
$pdata$0$LstInit DD imagerel $LN13+32
	DD	imagerel $LN13+196
	DD	imagerel $chain$0$LstInit
$pdata$1$LstInit DD imagerel $LN13+196
	DD	imagerel $LN13+229
	DD	imagerel $chain$1$LstInit
$pdata$LstWrite DD imagerel $LN123
	DD	imagerel $LN123+1676
	DD	imagerel $unwind$LstWrite
$pdata$LstWriteCRef DD imagerel $LN104
	DD	imagerel $LN104+39
	DD	imagerel $unwind$LstWriteCRef
$pdata$0$LstWriteCRef DD imagerel $LN104+39
	DD	imagerel $LN104+45
	DD	imagerel $chain$0$LstWriteCRef
$pdata$7$LstWriteCRef DD imagerel $LN104+45
	DD	imagerel $LN104+578
	DD	imagerel $chain$7$LstWriteCRef
$pdata$8$LstWriteCRef DD imagerel $LN104+578
	DD	imagerel $LN104+650
	DD	imagerel $chain$8$LstWriteCRef
$pdata$9$LstWriteCRef DD imagerel $LN104+650
	DD	imagerel $LN104+822
	DD	imagerel $chain$9$LstWriteCRef
$pdata$10$LstWriteCRef DD imagerel $LN104+822
	DD	imagerel $LN104+890
	DD	imagerel $chain$10$LstWriteCRef
$pdata$11$LstWriteCRef DD imagerel $LN104+890
	DD	imagerel $LN104+941
	DD	imagerel $chain$11$LstWriteCRef
$pdata$12$LstWriteCRef DD imagerel $LN104+941
	DD	imagerel $LN104+988
	DD	imagerel $chain$12$LstWriteCRef
$pdata$LstPrintf DD imagerel $LN9
	DD	imagerel $LN9+38
	DD	imagerel $unwind$LstPrintf
$pdata$0$LstPrintf DD imagerel $LN9+38
	DD	imagerel $LN9+90
	DD	imagerel $chain$0$LstPrintf
$pdata$1$LstPrintf DD imagerel $LN9+90
	DD	imagerel $LN9+96
	DD	imagerel $chain$1$LstPrintf
$pdata$LstNL DD	imagerel $LN5
	DD	imagerel $LN5+49
	DD	imagerel $unwind$LstNL
$pdata$LstSetPosition DD imagerel $LN5
	DD	imagerel $LN5+79
	DD	imagerel $unwind$LstSetPosition
$pdata$log_macro DD imagerel log_macro
	DD	imagerel log_macro+114
	DD	imagerel $unwind$log_macro
$pdata$log_struct DD imagerel log_struct
	DD	imagerel log_struct+615
	DD	imagerel $unwind$log_struct
$pdata$log_record DD imagerel log_record
	DD	imagerel log_record+155
	DD	imagerel $unwind$log_record
$pdata$0$log_record DD imagerel log_record+155
	DD	imagerel log_record+386
	DD	imagerel $chain$0$log_record
$pdata$1$log_record DD imagerel log_record+386
	DD	imagerel log_record+402
	DD	imagerel $chain$1$log_record
$pdata$log_typedef DD imagerel log_typedef
	DD	imagerel log_typedef+556
	DD	imagerel $unwind$log_typedef
$pdata$log_segment DD imagerel log_segment
	DD	imagerel log_segment+422
	DD	imagerel $unwind$log_segment
$pdata$log_group DD imagerel log_group
	DD	imagerel log_group+207
	DD	imagerel $unwind$log_group
$pdata$log_proc DD imagerel log_proc
	DD	imagerel log_proc+378
	DD	imagerel $unwind$log_proc
$pdata$1$log_proc DD imagerel log_proc+378
	DD	imagerel log_proc+531
	DD	imagerel $chain$1$log_proc
$pdata$2$log_proc DD imagerel log_proc+531
	DD	imagerel log_proc+1653
	DD	imagerel $chain$2$log_proc
$pdata$3$log_proc DD imagerel log_proc+1653
	DD	imagerel log_proc+1681
	DD	imagerel $chain$3$log_proc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_seg_align DD imagerel get_seg_align
	DD	imagerel get_seg_align+181
	DD	imagerel $unwind$get_seg_align
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetMemtypeString DD imagerel GetMemtypeString
	DD	imagerel GetMemtypeString+153
	DD	imagerel $unwind$GetMemtypeString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$GetMemtypeString DD imagerel GetMemtypeString+153
	DD	imagerel GetMemtypeString+208
	DD	imagerel $chain$0$GetMemtypeString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$GetMemtypeString DD imagerel GetMemtypeString+208
	DD	imagerel GetMemtypeString+287
	DD	imagerel $chain$2$GetMemtypeString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$GetMemtypeString DD imagerel GetMemtypeString+287
	DD	imagerel GetMemtypeString+398
	DD	imagerel $chain$3$GetMemtypeString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$GetMemtypeString DD imagerel GetMemtypeString+398
	DD	imagerel GetMemtypeString+410
	DD	imagerel $chain$4$GetMemtypeString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$GetMemtypeString DD imagerel GetMemtypeString+410
	DD	imagerel GetMemtypeString+430
	DD	imagerel $chain$5$GetMemtypeString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$GetMemtypeString DD imagerel GetMemtypeString+430
	DD	imagerel GetMemtypeString+575
	DD	imagerel $chain$6$GetMemtypeString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_proc_type DD imagerel get_proc_type
	DD	imagerel get_proc_type+118
	DD	imagerel $unwind$get_proc_type
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$log_symbol DD imagerel log_symbol
	DD	imagerel log_symbol+624
	DD	imagerel $unwind$log_symbol
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$LstCaption DD imagerel LstCaption
	DD	imagerel LstCaption+176
	DD	imagerel $unwind$LstCaption
pdata	ENDS
pdata	SEGMENT
$pdata$ListingDirective DD imagerel $LN52
	DD	imagerel $LN52+604
	DD	imagerel $unwind$ListingDirective
pdata	ENDS
CONST	SEGMENT
	ORG $+8
strings	DQ	FLAT:$SG11188
	DQ	FLAT:$SG11189
	DQ	FLAT:$SG11190
	DQ	FLAT:$SG11191
	DQ	FLAT:$SG11192
	DQ	FLAT:$SG11193
	DQ	FLAT:$SG11194
	DQ	FLAT:$SG11195
	DQ	FLAT:$SG11196
	DQ	FLAT:$SG11197
	DQ	FLAT:$SG11198
	DQ	FLAT:$SG11199
	DQ	FLAT:$SG11200
	DQ	FLAT:$SG11201
	DQ	FLAT:$SG11202
	DQ	FLAT:$SG11203
	DQ	FLAT:$SG11204
	DQ	FLAT:$SG11205
	DQ	FLAT:$SG11206
	DQ	FLAT:$SG11207
	DQ	FLAT:$SG11208
	DQ	FLAT:$SG11209
	DQ	FLAT:$SG11210
	DQ	FLAT:$SG11211
	DQ	FLAT:$SG11212
	DQ	FLAT:$SG11213
	DQ	FLAT:$SG11214
	DQ	FLAT:$SG11215
	DQ	FLAT:$SG11216
	DQ	FLAT:$SG11217
	DQ	FLAT:$SG11218
	DQ	FLAT:$SG11219
	DQ	FLAT:$SG11220
	DQ	FLAT:$SG11221
	DQ	FLAT:$SG11222
	DQ	FLAT:$SG11223
	DQ	FLAT:$SG11224
	DQ	FLAT:$SG11225
	DQ	FLAT:$SG11226
	DQ	FLAT:$SG11227
	DQ	FLAT:$SG11228
	DQ	FLAT:$SG11229
	DQ	FLAT:$SG11230
	DQ	FLAT:$SG11231
	DQ	FLAT:$SG11232
	DQ	FLAT:$SG11233
	DQ	FLAT:$SG11234
	DQ	FLAT:$SG11235
	DQ	FLAT:$SG11236
	DQ	FLAT:$SG11237
	DQ	FLAT:$SG11238
	DQ	FLAT:$SG11239
	DQ	FLAT:$SG11240
	DQ	FLAT:$SG11241
	DQ	FLAT:$SG11242
	DQ	FLAT:$SG11243
	DQ	FLAT:$SG11244
	DQ	FLAT:$SG11245
	DQ	FLAT:$SG11246
	DQ	FLAT:$SG11247
	DQ	FLAT:$SG11248
	DQ	FLAT:$SG11249
	DQ	FLAT:$SG11250
	DQ	FLAT:$SG11251
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$LstCaption DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$log_symbol DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_proc_type DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$GetMemtypeString DD 021H
	DD	imagerel GetMemtypeString
	DD	imagerel GetMemtypeString+153
	DD	imagerel $unwind$GetMemtypeString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$GetMemtypeString DD 020021H
	DD	076400H
	DD	imagerel GetMemtypeString
	DD	imagerel GetMemtypeString+153
	DD	imagerel $unwind$GetMemtypeString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$GetMemtypeString DD 021H
	DD	imagerel GetMemtypeString
	DD	imagerel GetMemtypeString+153
	DD	imagerel $unwind$GetMemtypeString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$GetMemtypeString DD 020021H
	DD	087400H
	DD	imagerel GetMemtypeString+153
	DD	imagerel GetMemtypeString+208
	DD	imagerel $chain$0$GetMemtypeString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$GetMemtypeString DD 040e21H
	DD	08740eH
	DD	065405H
	DD	imagerel GetMemtypeString+153
	DD	imagerel GetMemtypeString+208
	DD	imagerel $chain$0$GetMemtypeString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$GetMemtypeString DD 020521H
	DD	076405H
	DD	imagerel GetMemtypeString
	DD	imagerel GetMemtypeString+153
	DD	imagerel $unwind$GetMemtypeString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetMemtypeString DD 040b01H
	DD	09340bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_seg_align DD 020601H
	DD	030023206H
xdata	ENDS
xdata	SEGMENT
$unwind$LstInit DD 010401H
	DD	04204H
$chain$0$LstInit DD 020521H
	DD	043405H
	DD	imagerel $LN13
	DD	imagerel $LN13+32
	DD	imagerel $unwind$LstInit
$chain$1$LstInit DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+32
	DD	imagerel $unwind$LstInit
$unwind$LstWrite DD 0250b1b01H
	DD	012341bH
	DD	092102315H
	DD	0e00af00cH
	DD	0c006d008H
	DD	060037004H
	DD	05002H
$unwind$LstWriteCRef DD 020a01H
	DD	017010aH
$chain$0$LstWriteCRef DD 020421H
	DD	0183404H
	DD	imagerel $LN104
	DD	imagerel $LN104+39
	DD	imagerel $unwind$LstWriteCRef
$chain$7$LstWriteCRef DD 0e2521H
	DD	012f425H
	DD	013e41eH
	DD	014d414H
	DD	015c410H
	DD	016740cH
	DD	01a6408H
	DD	0195404H
	DD	imagerel $LN104+39
	DD	imagerel $LN104+45
	DD	imagerel $chain$0$LstWriteCRef
$chain$8$LstWriteCRef DD 0a0021H
	DD	012f400H
	DD	013e400H
	DD	014d400H
	DD	015c400H
	DD	0167400H
	DD	imagerel $LN104+39
	DD	imagerel $LN104+45
	DD	imagerel $chain$0$LstWriteCRef
$chain$9$LstWriteCRef DD 080021H
	DD	012f400H
	DD	013e400H
	DD	014d400H
	DD	015c400H
	DD	imagerel $LN104+39
	DD	imagerel $LN104+45
	DD	imagerel $chain$0$LstWriteCRef
$chain$10$LstWriteCRef DD 060021H
	DD	012f400H
	DD	013e400H
	DD	014d400H
	DD	imagerel $LN104+39
	DD	imagerel $LN104+45
	DD	imagerel $chain$0$LstWriteCRef
$chain$11$LstWriteCRef DD 040021H
	DD	012f400H
	DD	014d400H
	DD	imagerel $LN104
	DD	imagerel $LN104+39
	DD	imagerel $unwind$LstWriteCRef
$chain$12$LstWriteCRef DD 021H
	DD	imagerel $LN104
	DD	imagerel $LN104+39
	DD	imagerel $unwind$LstWriteCRef
$unwind$LstPrintf DD 021901H
	DD	030157219H
$chain$0$LstPrintf DD 020521H
	DD	076405H
	DD	imagerel $LN9
	DD	imagerel $LN9+38
	DD	imagerel $unwind$LstPrintf
$chain$1$LstPrintf DD 021H
	DD	imagerel $LN9
	DD	imagerel $LN9+38
	DD	imagerel $unwind$LstPrintf
$unwind$LstNL DD 010401H
	DD	04204H
$unwind$LstSetPosition DD 010401H
	DD	04204H
$unwind$log_macro DD 010401H
	DD	04204H
$unwind$log_struct DD 064c01H
	DD	0b644cH
	DD	0700d5211H
	DD	0300b500cH
$unwind$log_record DD 060f01H
	DD	0c640fH
	DD	0b340fH
	DD	0700b720fH
$chain$0$log_record DD 020521H
	DD	0a5405H
	DD	imagerel log_record
	DD	imagerel log_record+155
	DD	imagerel $unwind$log_record
$chain$1$log_record DD 021H
	DD	imagerel log_record
	DD	imagerel log_record+155
	DD	imagerel $unwind$log_record
$unwind$log_typedef DD 040a01H
	DD	08340aH
	DD	07006520aH
$unwind$log_segment DD 040a01H
	DD	0a340aH
	DD	07006720aH
$unwind$log_group DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$log_proc DD 060c01H
	DD	0e008b20cH
	DD	07004c006H
	DD	030025003H
$chain$1$log_proc DD 041021H
	DD	015f410H
	DD	0136408H
	DD	imagerel log_proc
	DD	imagerel log_proc+378
	DD	imagerel $unwind$log_proc
$chain$2$log_proc DD 020821H
	DD	014d408H
	DD	imagerel log_proc+378
	DD	imagerel log_proc+531
	DD	imagerel $chain$1$log_proc
$chain$3$log_proc DD 021H
	DD	imagerel log_proc+378
	DD	imagerel log_proc+531
	DD	imagerel $chain$1$log_proc
$unwind$ListingDirective DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vfprintf DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
i$ = 8
tokenarray$ = 16
ListMacroDirective PROC

; 1249 :     if ( tokenarray[i+1].token != T_FINAL ) {

	movsxd	r8, ecx
	lea	rax, QWORD PTR [r8+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 0
	je	SHORT $LN2@ListMacroD

; 1250 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].string_ptr ) );

	mov	rdx, QWORD PTR [rax+rdx+8]
	mov	ecx, 209				; 000000d1H
	jmp	EmitErr
$LN2@ListMacroD:

; 1251 :     }
; 1252 : 
; 1253 :     ModuleInfo.list_macro = GetSflagsSp( tokenarray[i].tokval );

	shl	r8, 5
	mov	eax, DWORD PTR [r8+rdx+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, OFFSET FLAT:SpecialTable+4
	mov	eax, DWORD PTR [rax+rcx*4]
	mov	DWORD PTR ModuleInfo+400, eax

; 1254 : 
; 1255 :     return( NOT_ERROR );

	xor	eax, eax

; 1256 : }

	ret	0
ListMacroDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
ListingDirective PROC

; 1160 : {

$LN52:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rbx, ecx
	mov	rsi, rdx

; 1161 :     int directive = tokenarray[i].tokval;

	mov	rax, rbx

; 1162 :     i++;

	inc	ebx
	shl	rax, 5
	movsxd	rdi, ebx
	mov	eax, DWORD PTR [rax+rdx+16]

; 1163 : 
; 1164 :     switch ( directive ) {

	add	eax, -294				; fffffffffffffedaH
	cmp	eax, 11
	ja	$LN24@ListingDir
	lea	rcx, OFFSET FLAT:__ImageBase
	cdqe
	mov	edx, DWORD PTR $LN48@ListingDir[rcx+rax*4]
	add	rdx, rcx
	jmp	rdx
$LN9@ListingDir:

; 1165 :     case T_DOT_LIST:
; 1166 :         if ( CurrFile[LST] )

	cmp	QWORD PTR ModuleInfo+112, 0
	je	$LN8@ListingDir

; 1167 :             ModuleInfo.list = TRUE;

	or	DWORD PTR ModuleInfo+408, 2048		; 00000800H

; 1168 :         break;

	jmp	$LN8@ListingDir
$LN11@ListingDir:

; 1169 :     case T_DOT_CREF:
; 1170 :         ModuleInfo.cref = TRUE;

	or	DWORD PTR ModuleInfo+408, 4096		; 00001000H

; 1171 :         break;

	jmp	$LN8@ListingDir
$LN12@ListingDir:

; 1172 :     case T_DOT_NOLIST:
; 1173 :     case T_DOT_XLIST:
; 1174 :         ModuleInfo.list = FALSE;

	and	DWORD PTR ModuleInfo+408, -2049		; fffff7ffH

; 1175 :         break;

	jmp	$LN8@ListingDir
$LN13@ListingDir:

; 1176 :     case T_DOT_NOCREF:
; 1177 :     case T_DOT_XCREF:
; 1178 :         if ( i == Token_Count ) {

	cmp	ebx, DWORD PTR ModuleInfo+496
	jne	SHORT $LN46@ListingDir

; 1179 :             ModuleInfo.cref = FALSE;

	and	DWORD PTR ModuleInfo+408, -4097		; ffffefffH

; 1180 :             break;

	jmp	$LN8@ListingDir
$LN46@ListingDir:

; 1181 :         }
; 1182 :         do {
; 1183 :             struct asym *sym;
; 1184 :             if ( tokenarray[i].token != T_ID ) {

	shl	rdi, 5
	add	rdi, rsi
$LL6@ListingDir:
	cmp	BYTE PTR [rdi], 8
	jne	SHORT $LN32@ListingDir

; 1186 :             }
; 1187 :             /* the name may be a forward reference. In this case it will
; 1188 :              * be created here.
; 1189 :              * v2.11: function call cannot fail. no need for checks.
; 1190 :              */
; 1191 :             sym = SymLookup( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rdi+8]
	call	SymLookup

; 1192 :             sym->list = FALSE;
; 1193 :             i++;

	inc	ebx
	add	rdi, 32					; 00000020H
	and	BYTE PTR [rax+41], 254			; 000000feH

; 1194 :             if ( i < Token_Count ) {

	mov	ecx, DWORD PTR ModuleInfo+496
	cmp	ebx, ecx
	jge	$LN8@ListingDir

; 1195 :                 if ( tokenarray[i].token != T_COMMA )

	cmp	BYTE PTR [rdi], 44			; 0000002cH
	jne	SHORT $LN34@ListingDir

; 1197 : 
; 1198 :                 /* if there's nothing after the comma, don't increment */
; 1199 :                 if ( i < ( Token_Count - 1 ) )

	lea	eax, DWORD PTR [rcx-1]
	cmp	ebx, eax
	jge	SHORT $LN4@ListingDir

; 1200 :                     i++;

	inc	ebx
	add	rdi, 32					; 00000020H
$LN4@ListingDir:

; 1201 :             }
; 1202 :         } while ( i < Token_Count );

	cmp	ebx, ecx
	jl	SHORT $LL6@ListingDir
	jmp	$LN8@ListingDir
$LN34@ListingDir:

; 1196 :                     return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rdx, ebx
	mov	ecx, 39					; 00000027H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]

; 1239 :     }
; 1240 : 
; 1241 :     return( NOT_ERROR );
; 1242 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1196 :                     return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	jmp	EmitErr
$LN32@ListingDir:

; 1185 :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rdx, ebx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]

; 1239 :     }
; 1240 : 
; 1241 :     return( NOT_ERROR );
; 1242 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1185 :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	jmp	EmitErr
$LN19@ListingDir:

; 1203 :         break;
; 1204 :     case T_DOT_LISTALL: /* list false conditionals and generated code */
; 1205 :         if ( CurrFile[LST] )

	cmp	QWORD PTR ModuleInfo+112, 0

; 1206 :             ModuleInfo.list = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	je	SHORT $LN20@ListingDir
	bts	eax, 11
$LN20@ListingDir:

; 1207 :         ModuleInfo.list_generated_code = TRUE;

	bts	eax, 14

; 1208 :         /* fall through */
; 1209 :     case T_DOT_LISTIF:
; 1210 :     case T_DOT_LFCOND: /* .LFCOND is synonym for .LISTIF */
; 1211 :         ModuleInfo.listif = TRUE;

	bts	eax, 13
	mov	DWORD PTR ModuleInfo+408, eax

; 1212 :         break;

	jmp	$LN8@ListingDir
$LN50@ListingDir:

; 1207 :         ModuleInfo.list_generated_code = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408

; 1208 :         /* fall through */
; 1209 :     case T_DOT_LISTIF:
; 1210 :     case T_DOT_LFCOND: /* .LFCOND is synonym for .LISTIF */
; 1211 :         ModuleInfo.listif = TRUE;

	bts	eax, 13
	mov	DWORD PTR ModuleInfo+408, eax

; 1212 :         break;

	jmp	$LN8@ListingDir
$LN22@ListingDir:

; 1213 :     case T_DOT_NOLISTIF:
; 1214 :     case T_DOT_SFCOND: /* .SFCOND is synonym for .NOLISTIF */
; 1215 :         ModuleInfo.listif = FALSE;

	and	DWORD PTR ModuleInfo+408, -8193		; ffffdfffH

; 1216 :         break;

	jmp	SHORT $LN8@ListingDir
$LN23@ListingDir:

; 1217 :     case T_DOT_TFCOND: /* .TFCOND toggles .LFCOND, .SFCOND */
; 1218 :         ModuleInfo.listif = !ModuleInfo.listif;

	mov	ecx, DWORD PTR ModuleInfo+408
	mov	eax, ecx
	not	eax
	xor	eax, ecx
	and	eax, 8192				; 00002000H
	xor	ecx, eax
	mov	DWORD PTR ModuleInfo+408, ecx

; 1219 :         break;

	jmp	SHORT $LN8@ListingDir
$LN24@ListingDir:

; 1220 :     case T_PAGE:
; 1221 :     default: /* TITLE, SUBTITLE, SUBTTL */
; 1222 :         /* tiny checks to ensure that these directives
; 1223 :          aren't used as code labels or struct fields */
; 1224 :         if ( tokenarray[i].token == T_COLON )

	shl	rdi, 5
	cmp	BYTE PTR [rdi+rsi], 58			; 0000003aH
	je	SHORT $LN8@ListingDir

; 1225 :             break;
; 1226 :         /* this isn't really Masm-compatible, but ensures we don't get
; 1227 :          * struct fields with names page, title, subtitle, subttl.
; 1228 :          */
; 1229 :         if( CurrStruct ) {

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN26@ListingDir

; 1230 :             return( EmitError( STATEMENT_NOT_ALLOWED_INSIDE_STRUCTURE_DEFINITION ) );

	mov	ecx, 141				; 0000008dH

; 1239 :     }
; 1240 : 
; 1241 :     return( NOT_ERROR );
; 1242 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1230 :             return( EmitError( STATEMENT_NOT_ALLOWED_INSIDE_STRUCTURE_DEFINITION ) );

	jmp	EmitError
$LN26@ListingDir:

; 1231 :         }
; 1232 :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN31@ListingDir

; 1233 :             EmitWarn( 4, DIRECTIVE_IGNORED, tokenarray[i-1].string_ptr );

	mov	r8, QWORD PTR [rdi+rsi-24]
	mov	edx, 128				; 00000080H
	lea	ecx, QWORD PTR [rdx-124]
	call	EmitWarn
$LN31@ListingDir:

; 1234 :         while ( tokenarray[i].token != T_FINAL) i++;

	cmp	BYTE PTR [rdi+rsi], 0
	je	SHORT $LN8@ListingDir
	lea	rax, QWORD PTR [rdi+rsi]
$LL7@ListingDir:
	inc	ebx
	lea	rax, QWORD PTR [rax+32]
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LL7@ListingDir
$LN8@ListingDir:

; 1235 :     }
; 1236 : 
; 1237 :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, ebx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 0
	je	SHORT $LN28@ListingDir

; 1238 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rax+rsi+8]
	mov	ecx, 209				; 000000d1H

; 1239 :     }
; 1240 : 
; 1241 :     return( NOT_ERROR );
; 1242 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1238 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jmp	EmitErr
$LN28@ListingDir:

; 1239 :     }
; 1240 : 
; 1241 :     return( NOT_ERROR );
; 1242 : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
	npad	3
$LN48@ListingDir:
	DD	$LN11@ListingDir
	DD	$LN50@ListingDir
	DD	$LN9@ListingDir
	DD	$LN19@ListingDir
	DD	$LN50@ListingDir
	DD	$LN13@ListingDir
	DD	$LN12@ListingDir
	DD	$LN22@ListingDir
	DD	$LN22@ListingDir
	DD	$LN23@ListingDir
	DD	$LN13@ListingDir
	DD	$LN12@ListingDir
ListingDirective ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
p1$ = 8
p2$ = 16
compare_syms PROC

; 1037 :     return( strcmp( (*(struct asym * *)p1)->name, (*(struct asym * *)p2)->name ) );

	mov	r8, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [r8+8]
	mov	rax, QWORD PTR [rax+8]
	sub	rdx, rax
$LL3@compare_sy:
	movzx	ecx, BYTE PTR [rax]
	cmp	cl, BYTE PTR [rax+rdx]
	jne	SHORT $LN5@compare_sy
	inc	rax
	test	cl, cl
	jne	SHORT $LL3@compare_sy
	xor	eax, eax

; 1038 : }

	ret	0
$LN5@compare_sy:

; 1037 :     return( strcmp( (*(struct asym * *)p1)->name, (*(struct asym * *)p2)->name ) );

	sbb	eax, eax
	or	eax, 1

; 1038 : }

	ret	0
compare_syms ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
;	COMDAT LstCaption
_TEXT	SEGMENT
caption$ = 48
prefNL$ = 56
LstCaption PROC						; COMDAT

; 1026 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, edx
	mov	rdi, rcx

; 1027 :     for (; prefNL; prefNL--)

	test	edx, edx
	je	SHORT $LN3@LstCaption
	mov	r9, QWORD PTR ModuleInfo+112
	npad	6
$LL4@LstCaption:

; 1028 :         LstNL();

	test	r9, r9
	je	SHORT $LN2@LstCaption
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
	mov	r9, QWORD PTR ModuleInfo+112
$LN2@LstCaption:

; 1027 :     for (; prefNL; prefNL--)

	sub	ebx, 1
	jne	SHORT $LL4@LstCaption
$LN3@LstCaption:

; 1029 :     LstPrintf( caption );

	mov	rcx, rdi
	call	LstPrintf

; 1030 :     LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN13@LstCaption
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite

; 1031 :     LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	add	DWORD PTR list_pos, 2
	test	r9, r9
	je	SHORT $LN13@LstCaption
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN13@LstCaption:

; 1032 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
LstCaption ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
;	COMDAT log_symbol
_TEXT	SEGMENT
sym$ = 64
log_symbol PROC						; COMDAT

; 949  : {

	push	rbx
	sub	rsp, 48					; 00000030H

; 950  :     int i = sym->name_size;

	movzx	eax, BYTE PTR [rcx+72]
	mov	rbx, rcx

; 951  :     const char *pdots;
; 952  :     //char buffer[MAX_LINE_LEN];
; 953  : 
; 954  :     pdots = ((i >= DOTSMAX) ? "" : dots + i + 1 );

	cmp	eax, 32					; 00000020H
	jl	SHORT $LN26@log_symbol
	lea	r8, OFFSET FLAT:$SG11766
	jmp	SHORT $LN27@log_symbol
$LN26@log_symbol:
	mov	r8, rax
	lea	rax, OFFSET FLAT:dots+1
	add	r8, rax
$LN27@log_symbol:

; 955  : 
; 956  :     switch ( sym->state ) {

	mov	eax, DWORD PTR [rcx+32]
	test	eax, eax
	js	$LN36@log_symbol
	cmp	eax, 2
	jle	SHORT $LN4@log_symbol
	cmp	eax, 8
	je	SHORT $LN24@log_symbol
	cmp	eax, 10
	jne	$LN36@log_symbol

; 1010 :         break;
; 1011 :     case SYM_TMACRO:
; 1012 :         //GetLiteralValue( buffer, sym->string_ptr );
; 1013 :         //strcpy( buffer, sym->string_ptr );
; 1014 :         LstPrintf( "%s %s        %s   %s", sym->name, pdots, strings[LS_TEXT], sym->string_ptr );

	mov	rax, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG11804
	mov	r9, QWORD PTR strings+296
	mov	QWORD PTR [rsp+32], rax
	call	LstPrintf

; 1020 :         break;
; 1021 :     }
; 1022 : }

	add	rsp, 48					; 00000030H
	pop	rbx

; 1015 :         LstNL();

	jmp	LstNL
$LN24@log_symbol:

; 1016 :         break;
; 1017 :     case SYM_ALIAS:
; 1018 :         LstPrintf( "%s %s        %s  %s", sym->name, pdots, strings[LS_ALIAS], sym->substitute->name );

	mov	rax, QWORD PTR [rcx+16]
	mov	r9, QWORD PTR strings+304
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, OFFSET FLAT:$SG11806
	call	LstPrintf

; 1019 :         LstNL();

	jmp	$LN43@log_symbol
$LN4@log_symbol:

; 957  :     case SYM_UNDEFINED:
; 958  :     case SYM_INTERNAL:
; 959  :     case SYM_EXTERNAL:
; 960  :         LstPrintf( "%s %s        ", sym->name, pdots );

	mov	rdx, QWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG11768
	call	LstPrintf

; 961  : 
; 962  :         if ( sym->isarray ) {

	test	BYTE PTR [rbx+41], 2
	je	SHORT $LN5@log_symbol

; 963  :             i = sprintf( StringBufferEnd, "%s[%u]", GetMemtypeString( sym, NULL ), sym->total_length );

	xor	edx, edx
	mov	rcx, rbx
	call	GetMemtypeString
	mov	r9d, DWORD PTR [rbx+64]
	lea	rdx, OFFSET FLAT:$SG11771
	mov	rcx, QWORD PTR ModuleInfo+488
	mov	r8, rax
	call	sprintf

; 964  :             LstPrintf( "%-10s ", StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	lea	rcx, OFFSET FLAT:$SG11772
	jmp	SHORT $LN44@log_symbol
$LN5@log_symbol:

; 965  :         } else if ( sym->state == SYM_EXTERNAL && sym->iscomm == TRUE ) {

	cmp	DWORD PTR [rbx+32], 2
	jne	SHORT $LN7@log_symbol
	test	BYTE PTR [rbx+47], 4
	je	SHORT $LN7@log_symbol

; 966  :             LstPrintf( "%-10s ", strings[LS_COMM] );

	mov	rdx, QWORD PTR strings+320
	lea	rcx, OFFSET FLAT:$SG11775

; 967  :         } else

	jmp	SHORT $LN44@log_symbol
$LN7@log_symbol:

; 968  :             LstPrintf( "%-10s ", GetMemtypeString( sym, NULL ) );

	xor	edx, edx
	mov	rcx, rbx
	call	GetMemtypeString
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11776
$LN44@log_symbol:
	call	LstPrintf

; 969  : 
; 970  :         /* print value */
; 971  :         /* v2.07: MT_ABS is obsolete */
; 972  :         //if ( sym->mem_type == MT_ABS )
; 973  :         if ( sym->state == SYM_EXTERNAL && sym->iscomm == TRUE )

	cmp	DWORD PTR [rbx+32], 2
	jne	SHORT $LN9@log_symbol
	test	BYTE PTR [rbx+47], 4
	je	SHORT $LN9@log_symbol

; 974  :             LstPrintf( " %8" I32_SPEC "Xh ", sym->total_size / sym->total_length );

	mov	eax, DWORD PTR [rbx+56]
	lea	rcx, OFFSET FLAT:$SG11779
	xor	edx, edx
	div	DWORD PTR [rbx+64]
	mov	edx, eax
	jmp	SHORT $LN45@log_symbol
$LN9@log_symbol:

; 975  :         else if ( sym->mem_type == MT_EMPTY ) { /* also check segment? might be != NULL for equates (var = offset x) */

	cmp	DWORD PTR [rbx+36], 192			; 000000c0H

; 977  :                 LstPrintf( " %" I64_SPEC "Xh ", sym->uvalue, sym->value3264 );

	mov	edx, DWORD PTR [rbx+16]
	jne	SHORT $LN11@log_symbol

; 976  :             if ( sym->value3264 != 0 && sym->value3264 != -1 )

	mov	ecx, DWORD PTR [rbx+56]
	lea	eax, DWORD PTR [rcx+1]
	cmp	eax, 1
	jbe	SHORT $LN13@log_symbol

; 977  :                 LstPrintf( " %" I64_SPEC "Xh ", sym->uvalue, sym->value3264 );

	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:$SG11784
	call	LstPrintf
	jmp	SHORT $LN12@log_symbol
$LN13@log_symbol:

; 978  :             else if ( sym->value3264 < 0 )

	test	ecx, ecx
	jns	SHORT $LN15@log_symbol

; 979  :                 LstPrintf( "-%08" I32_SPEC "Xh ", 0 - sym->uvalue );

	neg	edx
	lea	rcx, OFFSET FLAT:$SG11787
	jmp	SHORT $LN45@log_symbol
$LN15@log_symbol:

; 980  :             else
; 981  :                 LstPrintf( " %8" I32_SPEC "Xh ", sym->offset );

	lea	rcx, OFFSET FLAT:$SG11788

; 982  :         } else

	jmp	SHORT $LN45@log_symbol
$LN11@log_symbol:

; 983  :             LstPrintf( " %8" I32_SPEC "Xh ", sym->offset );

	lea	rcx, OFFSET FLAT:$SG11789
$LN45@log_symbol:
	call	LstPrintf
$LN12@log_symbol:

; 984  : 
; 985  :         /* print segment */
; 986  :         //if ( sym->mem_type == MT_ABS || sym->state == SYM_UNDEFINED )
; 987  :         //    ;
; 988  :         //else
; 989  :         if ( sym->segment )

	mov	rdx, QWORD PTR [rbx+24]
	test	rdx, rdx
	je	SHORT $LN17@log_symbol

; 990  :             LstPrintf( "%s ", get_sym_seg_name( sym ) );

	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG11791
	call	LstPrintf
$LN17@log_symbol:

; 991  : 
; 992  : #ifdef DEBUG_OUT
; 993  :         if ( sym->fwdref )
; 994  :             LstPrintf( "(F) " );
; 995  : #endif
; 996  :         if ( sym->state == SYM_EXTERNAL && sym->iscomm == TRUE )

	cmp	DWORD PTR [rbx+32], 2
	jne	SHORT $LN18@log_symbol
	test	BYTE PTR [rbx+47], 4
	je	SHORT $LN18@log_symbol

; 997  :             LstPrintf( "%s=%u ", szCount, sym->total_length );

	mov	r8d, DWORD PTR [rbx+64]
	lea	rdx, OFFSET FLAT:szCount
	lea	rcx, OFFSET FLAT:$SG11793
	call	LstPrintf
$LN18@log_symbol:

; 998  : 
; 999  :         if( sym->ispublic )

	test	BYTE PTR [rbx+40], 128			; 00000080H
	je	SHORT $LN19@log_symbol

; 1000 :             LstPrintf( "%s ", strings[LS_PUBLIC] );

	mov	rdx, QWORD PTR strings+248
	lea	rcx, OFFSET FLAT:$SG11795
	call	LstPrintf
$LN19@log_symbol:

; 1001 : 
; 1002 :         if ( sym->state == SYM_EXTERNAL ) {

	mov	eax, DWORD PTR [rbx+32]
	cmp	eax, 2
	jne	SHORT $LN20@log_symbol

; 1003 :             LstPrintf( sym->weak ? "*%s " : "%s ", strings[LS_EXTERNAL] );

	movzx	eax, BYTE PTR [rbx+47]
	lea	rdx, OFFSET FLAT:$SG11798
	and	al, 8
	lea	rcx, OFFSET FLAT:$SG11799
	cmovne	rcx, rdx
	mov	rdx, QWORD PTR strings+264
	jmp	SHORT $LN46@log_symbol
$LN20@log_symbol:

; 1004 :         } else if ( sym->state == SYM_UNDEFINED ) {

	test	eax, eax
	jne	SHORT $LN22@log_symbol

; 1005 :             LstPrintf( "%s ", strings[LS_UNDEFINED] );

	mov	rdx, QWORD PTR strings+272
	lea	rcx, OFFSET FLAT:$SG11801
$LN46@log_symbol:
	call	LstPrintf
$LN22@log_symbol:

; 1006 :         }
; 1007 : 
; 1008 :         LstPrintf( "%s", GetLanguage( sym ) );

	movsxd	rax, DWORD PTR [rbx+76]
	cmp	eax, 7
	jg	SHORT $LN33@log_symbol
	lea	rdx, OFFSET FLAT:strings+336
	mov	rdx, QWORD PTR [rdx+rax*8]
	jmp	SHORT $LN32@log_symbol
$LN33@log_symbol:
	lea	rdx, OFFSET FLAT:$SG11517
$LN32@log_symbol:
	lea	rcx, OFFSET FLAT:$SG11802
	call	LstPrintf
$LN43@log_symbol:

; 1009 :         LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN36@log_symbol
	mov	r8d, 2
	lea	rcx, OFFSET FLAT:$SG11421
	lea	edx, QWORD PTR [r8-1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN36@log_symbol:

; 1020 :         break;
; 1021 :     }
; 1022 : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
log_symbol ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
;	COMDAT get_sym_seg_name
_TEXT	SEGMENT
sym$ = 8
get_sym_seg_name PROC					; COMDAT

; 786  :     if( sym->segment ) {

	mov	rax, QWORD PTR [rcx+24]
	test	rax, rax
	je	SHORT $LN2@get_sym_se

; 787  :         return( sym->segment->name );

	mov	rax, QWORD PTR [rax+8]

; 790  :     }
; 791  : }

	ret	0
$LN2@get_sym_se:

; 788  :     } else {
; 789  :         return( strings[LS_NOSEG] );

	mov	rax, QWORD PTR strings+288

; 790  :     }
; 791  : }

	ret	0
get_sym_seg_name ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
;	COMDAT get_proc_type
_TEXT	SEGMENT
sym$ = 48
get_proc_type PROC					; COMDAT

; 765  : {

	sub	rsp, 40					; 00000028H

; 766  :     /* if there's no segment associated with the symbol,
; 767  :      add the symbol's offset size to the distance */
; 768  :     switch( sym->mem_type ) {

	mov	edx, DWORD PTR [rcx+36]
	sub	edx, 129				; 00000081H
	je	SHORT $LN4@get_proc_t
	cmp	edx, 1
	je	SHORT $LN6@get_proc_t

; 779  :     }
; 780  :     return( " " );

	lea	rax, OFFSET FLAT:$SG11664

; 781  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@get_proc_t:

; 774  :     case MT_FAR:
; 775  :         if ( sym->segment == NULL ) {

	cmp	QWORD PTR [rcx+24], 0
	jne	SHORT $LN7@get_proc_t

; 776  :             return( strings[LS_FAR16 + GetSymOfssize( sym )] );

	call	GetSymOfssize
	cdqe
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax*8+112]

; 781  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@get_proc_t:

; 777  :         }
; 778  :         return( strings[LS_FAR] );

	mov	rax, QWORD PTR strings+104

; 781  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@get_proc_t:

; 769  :     case MT_NEAR:
; 770  :         if ( sym->segment == NULL ) {

	cmp	QWORD PTR [rcx+24], 0
	jne	SHORT $LN5@get_proc_t

; 771  :             return( strings[LS_NEAR16 + GetSymOfssize( sym )] );

	call	GetSymOfssize
	cdqe
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax*8+80]

; 781  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN5@get_proc_t:

; 772  :         }
; 773  :         return( strings[LS_NEAR] );

	mov	rax, QWORD PTR strings+72

; 781  : }

	add	rsp, 40					; 00000028H
	ret	0
get_proc_type ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
;	COMDAT GetLanguage
_TEXT	SEGMENT
sym$ = 8
GetLanguage PROC					; COMDAT

; 566  :     if ( sym->langtype <= 7 )

	movsxd	rax, DWORD PTR [rcx+76]
	cmp	eax, 7
	jg	SHORT $LN2@GetLanguag

; 567  :         return( strings[sym->langtype + LS_VOID] );

	lea	rcx, OFFSET FLAT:strings+336
	mov	rax, QWORD PTR [rcx+rax*8]

; 569  : }

	ret	0
$LN2@GetLanguag:

; 568  :     return( "?" );

	lea	rax, OFFSET FLAT:$SG11517

; 569  : }

	ret	0
GetLanguage ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
;	COMDAT GetMemtypeString
_TEXT	SEGMENT
sym$ = 48
buffer$ = 56
GetMemtypeString PROC					; COMDAT

; 495  : {

	mov	QWORD PTR [rsp+32], rbx
	push	r14
	sub	rsp, 32					; 00000020H

; 496  :     const char *p;
; 497  :     enum memtype mem_type;
; 498  : 
; 499  :     if ( (sym->mem_type & MT_SPECIAL) == 0 )

	mov	eax, DWORD PTR [rcx+36]
	mov	r14, rdx
	mov	rbx, rcx
	test	al, al
	jns	SHORT $LN34@GetMemtype
	mov	edx, 195				; 000000c3H
	npad	3
$LL29@GetMemtype:

; 501  : 
; 502  :     /* v2.05: improve display of stack vars */
; 503  :     mem_type = sym->mem_type;
; 504  :     if ( sym->state == SYM_STACK && sym->is_ptr )

	cmp	DWORD PTR [rbx+32], 5
	jne	SHORT $LN8@GetMemtype
	cmp	BYTE PTR [rbx+45], 0
	cmovne	eax, edx
$LN8@GetMemtype:

; 505  :         mem_type = MT_PTR;
; 506  : 
; 507  :     switch ( mem_type ) {

	sub	eax, 129				; 00000081H
	je	$LN21@GetMemtype
	sub	eax, 1
	je	$LN19@GetMemtype
	sub	eax, 62					; 0000003eH
	je	$LN25@GetMemtype
	sub	eax, 3
	je	SHORT $LN9@GetMemtype
	cmp	eax, 1
	jne	SHORT $LN47@GetMemtype

; 545  :     case MT_TYPE:
; 546  :         if ( *(sym->type->name) )  /* there are a lot of unnamed types */

	mov	rcx, QWORD PTR [rbx+80]
	mov	rax, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rax], 0
	jne	$LN1@GetMemtype

; 547  :             return( sym->type->name );
; 548  :         /* v2.04: changed */
; 549  :         //return( strings[LS_PTR] );
; 550  :         return( GetMemtypeString( sym->type, buffer ) );

	mov	eax, DWORD PTR [rcx+36]
	mov	rbx, rcx
	test	al, al
	js	SHORT $LL29@GetMemtype
$LN34@GetMemtype:

; 500  :         return( SimpleTypeString( sym->mem_type ) );

	mov	ecx, DWORD PTR [rbx+36]

; 561  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14

; 500  :         return( SimpleTypeString( sym->mem_type ) );

	jmp	SimpleTypeString
$LN47@GetMemtype:

; 554  : #ifdef DEBUG_OUT /* v2.11: obsolete */
; 555  :     case MT_PROC:
; 556  :         printf("GetMemtypeString: found mem_type=MT_PROC for sym=%s\n", sym->name );
; 557  :         break;
; 558  : #endif
; 559  :     }
; 560  :     return("?");

	lea	rax, OFFSET FLAT:$SG11511

; 561  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN9@GetMemtype:

; 508  :     case MT_PTR:
; 509  : #if AMD64_SUPPORT
; 510  :         if ( sym->Ofssize == USE64 )

	movzx	eax, BYTE PTR [rbx+44]
	mov	QWORD PTR [rsp+56], rsi
	cmp	al, 2
	jne	SHORT $LN10@GetMemtype

; 511  :             p = strings[LS_NEAR];

	mov	rsi, QWORD PTR strings+72
	jmp	SHORT $LN13@GetMemtype
$LN10@GetMemtype:

; 512  :         else
; 513  : #endif
; 514  :             if ( sym->isfar )

	test	BYTE PTR [rbx+47], 16

; 515  :                 p = strings[LS_FAR16 + sym->Ofssize];

	lea	rcx, OFFSET FLAT:strings
	movzx	eax, al
	je	SHORT $LN12@GetMemtype
	mov	rsi, QWORD PTR [rcx+rax*8+112]
	jmp	SHORT $LN13@GetMemtype
$LN12@GetMemtype:

; 516  :             else
; 517  :                 p = strings[LS_NEAR16 + sym->Ofssize];

	mov	rsi, QWORD PTR [rcx+rax*8+80]
$LN13@GetMemtype:

; 518  : 
; 519  :         if ( buffer ) { /* Currently, 'buffer' is only != NULL for typedefs */

	test	r14, r14
	je	$LN14@GetMemtype

; 520  :             int i;
; 521  :             char *b2 = buffer;
; 522  :             /* v2.10: improved pointer TYPEDEF display */
; 523  :             for ( i = sym->is_ptr; i; i-- ) {

	mov	QWORD PTR [rsp+48], rbp
	movzx	ebp, BYTE PTR [rbx+45]
	mov	QWORD PTR [rsp+64], rdi
	mov	rdi, r14
	test	ebp, ebp
	je	SHORT $LN5@GetMemtype
	npad	11
$LL6@GetMemtype:

; 524  :                 b2 += sprintf( b2, "%s %s ", p, strings[LS_PTR] );

	mov	r9, QWORD PTR strings+200
	lea	rdx, OFFSET FLAT:$SG11499
	mov	r8, rsi
	mov	rcx, rdi
	call	sprintf
	movsxd	rcx, eax
	add	rdi, rcx
	sub	ebp, 1
	jne	SHORT $LL6@GetMemtype
$LN5@GetMemtype:

; 525  :             }
; 526  :             /* v2.05: added. */
; 527  :             if ( sym->state == SYM_TYPE && sym->typekind == TYPE_TYPEDEF ) {

	cmp	DWORD PTR [rbx+32], 7
	mov	rbp, QWORD PTR [rsp+48]
	jne	SHORT $LN18@GetMemtype
	cmp	BYTE PTR [rbx+66], 3
	jne	SHORT $LN18@GetMemtype

; 528  :                 //strcat( buffer, " ");
; 529  :                 if ( sym->target_type )

	mov	rcx, QWORD PTR [rbx+48]
	test	rcx, rcx
	je	SHORT $LN16@GetMemtype

; 530  :                     strcpy( b2, sym->target_type->name );

	mov	rcx, QWORD PTR [rcx+8]
	npad	14
$LL27@GetMemtype:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdi], al
	lea	rdi, QWORD PTR [rdi+1]
	test	al, al
	jne	SHORT $LL27@GetMemtype
	jmp	SHORT $LN18@GetMemtype
$LN16@GetMemtype:

; 531  :                 else if ( ( sym->ptr_memtype & MT_SPECIAL ) == 0 )

	movzx	eax, BYTE PTR [rbx+46]
	test	al, al
	js	SHORT $LN18@GetMemtype

; 532  :                     strcpy( b2, SimpleTypeString( sym->ptr_memtype ) );

	movzx	ecx, al
	call	SimpleTypeString
	npad	13
$LL28@GetMemtype:
	movzx	ecx, BYTE PTR [rax]
	lea	rax, QWORD PTR [rax+1]
	mov	BYTE PTR [rdi], cl
	lea	rdi, QWORD PTR [rdi+1]
	test	cl, cl
	jne	SHORT $LL28@GetMemtype
$LN18@GetMemtype:
	mov	rdi, QWORD PTR [rsp+64]

; 533  :             }
; 534  :             return( buffer );

	mov	rax, r14
	mov	rsi, QWORD PTR [rsp+56]
$LN1@GetMemtype:

; 561  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN14@GetMemtype:

; 535  :         }
; 536  :         return( p );

	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+56]

; 561  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN25@GetMemtype:

; 551  :     //case MT_ABS: /* v2.07: MT_ABS is obsolete */
; 552  :     case MT_EMPTY: /* number, via EQU or = directive */
; 553  :         return( strings[LS_NUMBER] );

	mov	rax, QWORD PTR strings+224

; 561  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN19@GetMemtype:

; 537  :     case MT_FAR:
; 538  :         if ( sym->segment )

	cmp	QWORD PTR [rbx+24], 0
	je	SHORT $LN20@GetMemtype

; 539  :             return( strings[LS_LFAR] );

	mov	rax, QWORD PTR strings+168

; 561  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN20@GetMemtype:

; 540  :         return( strings[LS_LFAR16 + GetSymOfssize( sym )] );

	mov	rcx, rbx
	call	GetSymOfssize
	cdqe
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax*8+176]

; 561  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN21@GetMemtype:

; 541  :     case MT_NEAR:
; 542  :         if ( sym->segment )

	cmp	QWORD PTR [rbx+24], 0
	je	SHORT $LN22@GetMemtype

; 543  :             return( strings[LS_LNEAR] );

	mov	rax, QWORD PTR strings+136

; 561  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN22@GetMemtype:

; 544  :         return( strings[LS_LNEAR16 + GetSymOfssize( sym )] );

	mov	rcx, rbx
	call	GetSymOfssize

; 561  : }

	mov	rbx, QWORD PTR [rsp+72]
	lea	rcx, OFFSET FLAT:strings
	cdqe
	mov	rax, QWORD PTR [rcx+rax*8+144]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
GetMemtypeString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
;	COMDAT SimpleTypeString
_TEXT	SEGMENT
mem_type$ = 8
SimpleTypeString PROC					; COMDAT

; 475  :     int size = ( mem_type & MT_SIZE_MASK ) + 1;

	and	ecx, 31

; 476  :     switch ( size ) {

	cmp	ecx, 15
	ja	SHORT $LN2@SimpleType
	movsxd	rax, ecx
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN12@SimpleType[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN4@SimpleType:

; 477  :     case 1: return( strings[LS_BYTE] );

	mov	rax, QWORD PTR strings

; 486  : }

	ret	0
$LN5@SimpleType:

; 478  :     case 2: return( strings[LS_WORD] );

	mov	rax, QWORD PTR strings+8

; 486  : }

	ret	0
$LN6@SimpleType:

; 479  :     case 4: return( strings[LS_DWORD] );

	mov	rax, QWORD PTR strings+16

; 486  : }

	ret	0
$LN7@SimpleType:

; 480  :     case 6: return( strings[LS_FWORD] );

	mov	rax, QWORD PTR strings+24

; 486  : }

	ret	0
$LN8@SimpleType:

; 481  :     case 8: return( strings[LS_QWORD] );

	mov	rax, QWORD PTR strings+32

; 486  : }

	ret	0
$LN9@SimpleType:

; 482  :     case 10:return( strings[LS_TBYTE] );

	mov	rax, QWORD PTR strings+40

; 486  : }

	ret	0
$LN10@SimpleType:

; 483  :     case 16:return( strings[LS_OWORD] );

	mov	rax, QWORD PTR strings+56

; 486  : }

	ret	0
$LN2@SimpleType:

; 484  :     }
; 485  :     return( "" );

	lea	rax, OFFSET FLAT:$SG11475

; 486  : }

	ret	0
	npad	2
$LN12@SimpleType:
	DD	$LN4@SimpleType
	DD	$LN5@SimpleType
	DD	$LN2@SimpleType
	DD	$LN6@SimpleType
	DD	$LN2@SimpleType
	DD	$LN7@SimpleType
	DD	$LN2@SimpleType
	DD	$LN8@SimpleType
	DD	$LN2@SimpleType
	DD	$LN9@SimpleType
	DD	$LN2@SimpleType
	DD	$LN2@SimpleType
	DD	$LN2@SimpleType
	DD	$LN2@SimpleType
	DD	$LN2@SimpleType
	DD	$LN10@SimpleType
SimpleTypeString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
;	COMDAT get_seg_combine
_TEXT	SEGMENT
seg$ = 8
get_seg_combine PROC					; COMDAT

; 446  :     switch( seg->combine ) {

	movzx	edx, BYTE PTR [rcx+108]
	and	edx, 7
	je	SHORT $LN4@get_seg_co
	sub	edx, 2
	je	SHORT $LN6@get_seg_co
	sub	edx, 3
	je	SHORT $LN5@get_seg_co
	cmp	edx, 1
	je	SHORT $LN7@get_seg_co

; 452  :     }
; 453  :     return( "?" );

	lea	rax, OFFSET FLAT:$SG11452

; 454  : }

	ret	0
$LN7@get_seg_co:

; 450  :     /* v2.06: added */
; 451  :     case COMB_COMMON:     return( strings[LS_COMMON]  );

	mov	rax, QWORD PTR strings+256

; 454  : }

	ret	0
$LN5@get_seg_co:

; 448  :     case COMB_STACK:      return( strings[LS_STACK]   );

	mov	rax, QWORD PTR strings+240

; 454  : }

	ret	0
$LN6@get_seg_co:

; 449  :     case COMB_ADDOFF:     return( strings[LS_PUBLIC]  );

	mov	rax, QWORD PTR strings+248

; 454  : }

	ret	0
$LN4@get_seg_co:

; 447  :     case COMB_INVALID:    return( strings[LS_PRIVATE] );

	mov	rax, QWORD PTR strings+232

; 454  : }

	ret	0
get_seg_combine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
;	COMDAT get_seg_align
_TEXT	SEGMENT
seg$ = 48
buffer$ = 56
get_seg_align PROC					; COMDAT

; 427  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 428  :     switch( seg->alignment ) {

	movzx	ecx, BYTE PTR [rcx+106]
	mov	rbx, rdx
	cmp	ecx, 3
	jg	SHORT $LN13@get_seg_al
	je	SHORT $LN7@get_seg_al
	mov	r8d, ecx
	test	ecx, ecx
	je	SHORT $LN4@get_seg_al
	sub	r8d, 1
	je	SHORT $LN5@get_seg_al
	cmp	r8d, 1
	jne	SHORT $LN11@get_seg_al

; 431  :     case 2:    return( strings[LS_DWORD] );

	mov	rax, QWORD PTR strings+16

; 440  :     }
; 441  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@get_seg_al:

; 430  :     case 1:    return( strings[LS_WORD]  );

	mov	rax, QWORD PTR strings+8

; 440  :     }
; 441  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@get_seg_al:

; 429  :     case 0:    return( strings[LS_BYTE]  );

	mov	rax, QWORD PTR strings

; 440  :     }
; 441  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN7@get_seg_al:

; 432  :     case 3:    return( strings[LS_QWORD] );

	mov	rax, QWORD PTR strings+32

; 440  :     }
; 441  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN13@get_seg_al:

; 428  :     switch( seg->alignment ) {

	cmp	ecx, 4
	je	SHORT $LN8@get_seg_al
	cmp	ecx, 8
	je	SHORT $LN9@get_seg_al
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN10@get_seg_al
$LN11@get_seg_al:

; 437  :     default:
; 438  :         sprintf( buffer, "%u", 1 << seg->alignment );

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:$SG11441
	shl	r8d, cl
	mov	rcx, rbx
	call	sprintf

; 439  :         return( buffer );

	mov	rax, rbx

; 440  :     }
; 441  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN10@get_seg_al:

; 435  :     case MAX_SEGALIGNMENT:
; 436  :                return( strings[LS_ABS]   );

	mov	rax, QWORD PTR strings+312

; 440  :     }
; 441  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN9@get_seg_al:

; 434  :     case 8:    return( strings[LS_PAGE]  );

	mov	rax, QWORD PTR strings+64

; 440  :     }
; 441  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN8@get_seg_al:

; 433  :     case 4:    return( strings[LS_PARA]  );

	mov	rax, QWORD PTR strings+48

; 440  :     }
; 441  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
get_seg_align ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
buffer$1 = 64
l$2$ = 144
tv66 = 144
sym$ = 144
log_proc PROC

; 797  : {

	push	rbx
	push	rbp
	push	rdi
	push	r12
	push	r14
	sub	rsp, 96					; 00000060H

; 798  :     struct dsym *f;
; 799  :     struct dsym *l;
; 800  :     const char *p;
; 801  :     struct dsym *dir = (struct dsym *)sym;
; 802  :     int i = sym->name_size;

	movzx	ebx, BYTE PTR [rcx+72]
	mov	rbp, rcx

; 803  :     char Ofssize = GetSymOfssize( sym );

	call	GetSymOfssize
	mov	DWORD PTR tv66[rsp], eax
	mov	r12d, eax

; 804  :     const char *pdots;
; 805  : 
; 806  :     pdots = (( i >= DOTSMAX ) ? "" : dots + i + 1 );

	cmp	ebx, 32					; 00000020H
	jl	SHORT $LN44@log_proc
	lea	rbx, OFFSET FLAT:$SG11717
	jmp	SHORT $LN45@log_proc
$LN44@log_proc:
	lea	rax, OFFSET FLAT:dots+1
	add	rbx, rax
$LN45@log_proc:

; 807  :     if ( Ofssize )

	test	r12b, r12b
	lea	rax, OFFSET FLAT:$SG11721
	lea	r14, OFFSET FLAT:$SG11720
	cmove	r14, rax

; 808  :         p = "%s %s        P %-6s %08" I32_SPEC "X %-8s ";
; 809  :     else
; 810  :         p = "%s %s        P %-6s %04" I32_SPEC "X     %-8s ";
; 811  :     LstPrintf( p,

	mov	rax, QWORD PTR [rbp+24]
	test	rax, rax
	je	SHORT $LN62@log_proc
	mov	rdi, QWORD PTR [rax+8]
	jmp	SHORT $LN63@log_proc
$LN62@log_proc:
	mov	rdi, QWORD PTR strings+288
$LN63@log_proc:
	mov	rcx, rbp
	call	get_proc_type
	mov	rdx, QWORD PTR [rbp+8]
	mov	r9, rax
	mov	eax, DWORD PTR [rbp+16]
	mov	r8, rbx
	mov	QWORD PTR [rsp+40], rdi
	mov	rcx, r14
	mov	DWORD PTR [rsp+32], eax
	call	LstPrintf

; 812  :               sym->name,
; 813  :               pdots,
; 814  :               get_proc_type( sym ),
; 815  :               sym->offset,
; 816  :               get_sym_seg_name( sym ));
; 817  : 
; 818  :     /* externals (PROTO) don't have a size. Masm always prints 0000 or 00000000 */
; 819  :     LstPrintf( "%0*" I32_SPEC "X ", Ofssize > USE16 ? 8 : 4, sym->state == SYM_INTERNAL ? sym->total_size : 0 );

	xor	edi, edi
	cmp	DWORD PTR [rbp+32], 1
	jne	SHORT $LN46@log_proc
	mov	r8d, DWORD PTR [rbp+56]
	jmp	SHORT $LN47@log_proc
$LN46@log_proc:
	mov	r8d, edi
$LN47@log_proc:
	mov	edx, 4
	lea	rcx, OFFSET FLAT:$SG11722
	mov	eax, 8
	test	r12b, r12b
	cmovg	edx, eax
	call	LstPrintf

; 820  : 
; 821  : #ifdef DEBUG_OUT
; 822  :     if ( sym->fwdref )
; 823  :         LstPrintf( "(F) " );
; 824  : #endif
; 825  :     if( sym->ispublic ) {

	test	BYTE PTR [rbp+40], 128			; 00000080H
	je	SHORT $LN25@log_proc

; 826  :         LstPrintf( "%-9s", strings[LS_PUBLIC] );

	mov	rdx, QWORD PTR strings+248
	lea	rcx, OFFSET FLAT:$SG11725
	jmp	SHORT $LN135@log_proc
$LN25@log_proc:

; 827  :     } else if ( sym->state == SYM_INTERNAL ) {

	cmp	DWORD PTR [rbp+32], 1
	jne	SHORT $LN27@log_proc

; 828  :         LstPrintf( "%-9s", strings[LS_PRIVATE] );

	mov	rdx, QWORD PTR strings+232
	lea	rcx, OFFSET FLAT:$SG11728

; 829  :     } else {

	jmp	SHORT $LN135@log_proc
$LN27@log_proc:

; 830  :         LstPrintf( sym->weak ? "*%-8s " : "%-9s ", strings[LS_EXTERNAL] );

	movzx	eax, BYTE PTR [rbp+47]
	lea	rdx, OFFSET FLAT:$SG11729
	and	al, 8
	lea	rcx, OFFSET FLAT:$SG11730
	cmovne	rcx, rdx
	mov	rdx, QWORD PTR strings+264
	call	LstPrintf

; 831  : #if DLLIMPORT
; 832  :         if ( sym->dll )

	mov	rdx, QWORD PTR [rbp+56]
	test	rdx, rdx
	je	SHORT $LN29@log_proc

; 833  :             LstPrintf( "(%.8s) ", sym->dll->name );

	add	rdx, 12
	lea	rcx, OFFSET FLAT:$SG11732
$LN135@log_proc:
	call	LstPrintf
$LN29@log_proc:

; 834  : #endif
; 835  :     }
; 836  : 
; 837  :     LstPrintf( "%s", GetLanguage( sym ) );

	movsxd	rax, DWORD PTR [rbp+76]
	lea	rcx, OFFSET FLAT:strings
	cmp	eax, 7
	jg	SHORT $LN66@log_proc
	mov	rdx, QWORD PTR [rcx+rax*8+336]
	jmp	SHORT $LN65@log_proc
$LN66@log_proc:
	lea	rdx, OFFSET FLAT:$SG11517
$LN65@log_proc:
	lea	rcx, OFFSET FLAT:$SG11733
	call	LstPrintf

; 838  :     LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN69@log_proc
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN69@log_proc:

; 839  :     /* for PROTOs, list optional altname */
; 840  :     if ( sym->state == SYM_EXTERNAL && sym->altname ) {

	cmp	DWORD PTR [rbp+32], 2
	mov	QWORD PTR [rsp+152], rsi
	mov	QWORD PTR [rsp+168], r15
	jne	SHORT $LN76@log_proc
	mov	rsi, QWORD PTR [rbp+64]
	test	rsi, rsi
	je	SHORT $LN76@log_proc

; 841  :         struct asym *sym2 = sym->altname;
; 842  :         LstPrintf( "  ");

	lea	rcx, OFFSET FLAT:$SG11735
	call	LstPrintf

; 843  :         LstPrintf( p,

	mov	rax, QWORD PTR [rsi+24]
	test	rax, rax
	je	SHORT $LN72@log_proc
	mov	r15, QWORD PTR [rax+8]
	jmp	SHORT $LN73@log_proc
$LN72@log_proc:
	mov	r15, QWORD PTR strings+288
$LN73@log_proc:
	mov	rcx, rsi
	call	get_proc_type
	mov	rdx, QWORD PTR [rsi+8]
	lea	r8, QWORD PTR [rbx+2]
	mov	r9, rax
	mov	QWORD PTR [rsp+40], r15
	mov	eax, DWORD PTR [rsi+16]
	mov	rcx, r14
	mov	DWORD PTR [rsp+32], eax
	call	LstPrintf

; 844  :                   sym2->name,
; 845  :                   pdots+2,
; 846  :                   get_proc_type( sym2 ),
; 847  :                   sym2->offset,
; 848  :                   get_sym_seg_name( sym2 ));
; 849  :         LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN76@log_proc
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN76@log_proc:

; 850  :     }
; 851  :     /* for PROCs, list parameters and locals */
; 852  :     if ( sym->state == SYM_INTERNAL ) {

	cmp	DWORD PTR [rbp+32], 1
	jne	$LN18@log_proc

; 853  : 
; 854  :         /* print the procedure's parameters */
; 855  :         if ( sym->langtype == LANG_C ||
; 856  :             sym->langtype == LANG_SYSCALL ||
; 857  :             sym->langtype == LANG_STDCALL ||

	mov	ecx, DWORD PTR [rbp+76]
	mov	QWORD PTR [rsp+160], r13
	mov	r13d, 43				; 0000002bH
	lea	eax, DWORD PTR [rcx-1]
	cmp	eax, 2
	jbe	$LN34@log_proc
	cmp	ecx, 7
	je	$LN34@log_proc

; 881  :             }
; 882  :         } else {
; 883  :             for ( f = dir->e.procinfo->paralist; f; f = f->nextparam ) {

	mov	rax, QWORD PTR [rbp+96]
	mov	rdi, QWORD PTR [rax+8]
	test	rdi, rdi
	je	$LN6@log_proc
	lea	r14, OFFSET FLAT:$SG11744
	lea	r12, OFFSET FLAT:dots+3
	npad	11
$LL13@log_proc:

; 884  :                 i = f->sym.name_size;

	movzx	eax, BYTE PTR [rdi+72]

; 885  :                 pdots = (( i >= DOTSMAX-2 ) ? "" : dots + i + 1 + 2 );

	mov	rsi, r14
	cmp	eax, 30
	jge	SHORT $LN53@log_proc
	lea	rsi, QWORD PTR [r12+rax]
$LN53@log_proc:

; 886  :                 LstPrintf( szFmtProcStk, f->sym.name, pdots, GetMemtypeString( &f->sym, NULL ),

	mov	rax, QWORD PTR [rbp+96]
	xor	edx, edx
	movzx	ecx, WORD PTR [rax+86]
	call	GetResWName
	xor	edx, edx
	mov	rcx, rdi
	mov	rbx, rax
	call	GetMemtypeString
	mov	ecx, DWORD PTR [rdi+16]
	mov	r9, rax
	mov	rdx, QWORD PTR [rdi+8]
	mov	r8, rsi
	mov	DWORD PTR [rsp+48], ecx
	lea	rcx, OFFSET FLAT:szFmtProcStk
	mov	DWORD PTR [rsp+40], r13d
	mov	QWORD PTR [rsp+32], rbx
	call	LstPrintf

; 887  : #if STACKBASESUPP
; 888  :                           GetResWName( dir->e.procinfo->basereg, NULL ),
; 889  : #else
; 890  :                           GetResWName( basereg[Ofssize], NULL ),
; 891  : #endif
; 892  :                           '+', f->sym.offset );
; 893  :                 LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN11@log_proc
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN11@log_proc:

; 881  :             }
; 882  :         } else {
; 883  :             for ( f = dir->e.procinfo->paralist; f; f = f->nextparam ) {

	mov	rdi, QWORD PTR [rdi+112]
	test	rdi, rdi
	jne	$LL13@log_proc

; 853  : 
; 854  :         /* print the procedure's parameters */
; 855  :         if ( sym->langtype == LANG_C ||
; 856  :             sym->langtype == LANG_SYSCALL ||
; 857  :             sym->langtype == LANG_STDCALL ||

	jmp	$LN136@log_proc
$LN34@log_proc:

; 858  :             sym->langtype == LANG_FASTCALL ) {
; 859  :             int cnt;
; 860  :             /* position f2 to last param */
; 861  :             for ( cnt = 0, f = dir->e.procinfo->paralist; f; f = f->nextparam )

	mov	rax, QWORD PTR [rbp+96]
	mov	rcx, QWORD PTR [rax+8]
	test	rcx, rcx
	je	$LN6@log_proc
	npad	2
$LL4@log_proc:
	mov	rcx, QWORD PTR [rcx+112]

; 862  :                 cnt++;

	inc	edi
	test	rcx, rcx
	jne	SHORT $LL4@log_proc

; 863  :             for ( ; cnt; cnt-- ) {

	test	edi, edi
	je	$LN6@log_proc
	lea	r15, OFFSET FLAT:$SG11740
	lea	r12, OFFSET FLAT:dots+3
$LL7@log_proc:

; 864  :                 int curr;
; 865  :                 for ( curr = 1,f = dir->e.procinfo->paralist; curr < cnt;f = f->nextparam, curr++ );

	mov	rax, QWORD PTR [rbp+96]
	mov	rbx, QWORD PTR [rax+8]
	cmp	edi, 1
	jle	SHORT $LN9@log_proc
	lea	ecx, DWORD PTR [rdi-1]
$LL10@log_proc:
	mov	rbx, QWORD PTR [rbx+112]
	sub	rcx, 1
	jne	SHORT $LL10@log_proc
$LN9@log_proc:

; 866  :                 i = f->sym.name_size;

	movzx	eax, BYTE PTR [rbx+72]

; 867  :                 pdots = (( i >= DOTSMAX-2 ) ? "" : dots + i + 1 + 2 );

	mov	rsi, r15
	cmp	eax, 30
	jge	SHORT $LN49@log_proc
	lea	rsi, QWORD PTR [r12+rax]
$LN49@log_proc:

; 868  :                 /* FASTCALL: parameter may be a text macro (=register name) */
; 869  :                 if ( f->sym.state == SYM_TMACRO )

	cmp	DWORD PTR [rbx+32], 10
	jne	SHORT $LN35@log_proc

; 870  :                     LstPrintf( "  %s %s        %-17s %s", f->sym.name, pdots, GetMemtypeString( &f->sym, NULL ), f->sym.string_ptr );

	xor	edx, edx
	mov	rcx, rbx
	call	GetMemtypeString
	mov	rdx, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG11743
	mov	r9, rax
	mov	r8, rsi
	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rsp+32], rax
	call	LstPrintf
	jmp	SHORT $LN36@log_proc
$LN35@log_proc:

; 871  :                 else
; 872  :                     LstPrintf( szFmtProcStk, f->sym.name, pdots,

	test	BYTE PTR [rbx+47], 32			; 00000020H
	je	SHORT $LN50@log_proc
	mov	r14, QWORD PTR strings+328
	jmp	SHORT $LN51@log_proc
$LN50@log_proc:
	xor	edx, edx
	mov	rcx, rbx
	call	GetMemtypeString
	mov	r14, rax
$LN51@log_proc:
	mov	rcx, QWORD PTR [rbp+96]
	xor	edx, edx
	movzx	ecx, WORD PTR [rcx+86]
	call	GetResWName
	mov	ecx, DWORD PTR [rbx+16]
	mov	r9, r14
	mov	rdx, QWORD PTR [rbx+8]
	mov	r8, rsi
	mov	DWORD PTR [rsp+48], ecx
	lea	rcx, OFFSET FLAT:szFmtProcStk
	mov	DWORD PTR [rsp+40], r13d
	mov	QWORD PTR [rsp+32], rax
	call	LstPrintf
$LN36@log_proc:

; 873  :                             f->sym.is_vararg ? strings[LS_VARARG] : GetMemtypeString( &f->sym, NULL ),
; 874  : #if STACKBASESUPP
; 875  :                               GetResWName( dir->e.procinfo->basereg, NULL ),
; 876  : #else
; 877  :                               GetResWName( basereg[Ofssize], NULL ),
; 878  : #endif
; 879  :                             '+', f->sym.offset );
; 880  :                 LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN5@log_proc
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN5@log_proc:

; 863  :             for ( ; cnt; cnt-- ) {

	sub	edi, 1
	jne	$LL7@log_proc
$LN136@log_proc:
	mov	r12d, DWORD PTR tv66[rsp]
$LN6@log_proc:

; 894  :             }
; 895  :         }
; 896  : 
; 897  :         /* print the procedure's locals */
; 898  :         for ( l = dir->e.procinfo->locallist; l; l = l->nextlocal ) {

	mov	rax, QWORD PTR [rbp+96]
	mov	rdi, QWORD PTR [rax+16]
	test	rdi, rdi
	je	$LN15@log_proc
	lea	r15, OFFSET FLAT:$SG11745
	lea	r12, OFFSET FLAT:dots+3
	npad	10
$LL16@log_proc:

; 899  :             char buffer[32];
; 900  :             i = l->sym.name_size;

	movzx	eax, BYTE PTR [rdi+72]

; 901  :             pdots = (( i >= DOTSMAX-2 ) ? "" : dots + i + 1 + 2);

	mov	r14, r15
	cmp	eax, 30
	jge	SHORT $LN55@log_proc
	lea	r14, QWORD PTR [r12+rax]
$LN55@log_proc:

; 902  :             if ( l->sym.isarray )
; 903  :                 sprintf( buffer, "%s[%" I32_SPEC "u]", GetMemtypeString(&l->sym, NULL), l->sym.total_length );

	xor	edx, edx
	mov	rcx, rdi
	test	BYTE PTR [rdi+41], 2
	je	SHORT $LN37@log_proc
	call	GetMemtypeString
	mov	r9d, DWORD PTR [rdi+64]
	lea	rdx, OFFSET FLAT:$SG11748
	mov	r8, rax
	lea	rcx, QWORD PTR buffer$1[rsp]
	call	sprintf
	jmp	SHORT $LN38@log_proc
$LN37@log_proc:

; 904  :             else
; 905  :                 strcpy( buffer, GetMemtypeString( &l->sym, NULL ) );

	call	GetMemtypeString
	lea	rdx, QWORD PTR buffer$1[rsp]
	sub	rdx, rax
	npad	9
$LL56@log_proc:
	movzx	ecx, BYTE PTR [rax]
	mov	BYTE PTR [rax+rdx], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL56@log_proc
$LN38@log_proc:

; 906  :             LstPrintf( szFmtProcStk, l->sym.name, pdots, buffer,

	mov	eax, DWORD PTR [rdi+16]
	mov	esi, eax
	test	eax, eax
	jns	SHORT $LN58@log_proc
	neg	esi
$LN58@log_proc:
	test	eax, eax
	mov	ebx, 45					; 0000002dH
	mov	rax, QWORD PTR [rbp+96]
	cmovns	ebx, r13d
	xor	edx, edx
	movzx	ecx, WORD PTR [rax+86]
	call	GetResWName
	mov	rdx, QWORD PTR [rdi+8]
	lea	r9, QWORD PTR buffer$1[rsp]
	mov	DWORD PTR [rsp+48], esi
	lea	rcx, OFFSET FLAT:szFmtProcStk
	mov	DWORD PTR [rsp+40], ebx
	mov	r8, r14
	mov	QWORD PTR [rsp+32], rax
	call	LstPrintf

; 907  : #if STACKBASESUPP
; 908  :                       GetResWName( dir->e.procinfo->basereg, NULL ),
; 909  :                       l->sym.offset >= 0 ? '+' : '-', l->sym.offset >= 0 ? l->sym.offset : - l->sym.offset );
; 910  : #else
; 911  :                       GetResWName( basereg[Ofssize], NULL ),
; 912  :                       '-', - l->sym.offset );
; 913  : #endif
; 914  :             LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN14@log_proc
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN14@log_proc:

; 894  :             }
; 895  :         }
; 896  : 
; 897  :         /* print the procedure's locals */
; 898  :         for ( l = dir->e.procinfo->locallist; l; l = l->nextlocal ) {

	mov	rdi, QWORD PTR [rdi+112]
	test	rdi, rdi
	jne	$LL16@log_proc
	mov	r12d, DWORD PTR tv66[rsp]
$LN15@log_proc:

; 915  :         }
; 916  : 
; 917  :         for ( l = dir->e.procinfo->labellist; l ; l = l->e.nextll ) {

	mov	rax, QWORD PTR [rbp+96]
	mov	r14, QWORD PTR [rax+24]
	mov	QWORD PTR l$2$[rsp], r14
	test	r14, r14
	je	$LN134@log_proc
	lea	r15, OFFSET FLAT:$SG11751
	lea	r13, OFFSET FLAT:$SG11755
	npad	4
$LL19@log_proc:

; 918  :             struct dsym *l2;
; 919  :             for ( l2 = l; l2; l2 = (struct dsym *)l2->sym.nextitem ) {

	mov	rbx, r14
	test	r14, r14
	je	$LN17@log_proc
	lea	r14, OFFSET FLAT:dots+3
$LL22@log_proc:

; 920  :                 /* filter params and locals! */
; 921  :                 if ( l2->sym.state == SYM_STACK || l2->sym.state == SYM_TMACRO )

	mov	eax, DWORD PTR [rbx+32]
	cmp	eax, 5
	je	$LN20@log_proc
	cmp	eax, 10
	je	$LN20@log_proc

; 922  :                     continue;
; 923  :                 i = l2->sym.name_size;

	movzx	eax, BYTE PTR [rbx+72]

; 924  :                 pdots = (( i >= DOTSMAX-2 ) ? "" : dots + i + 1 + 2);

	mov	rdi, r15
	cmp	eax, 30
	jge	SHORT $LN60@log_proc
	lea	rdi, QWORD PTR [r14+rax]
$LN60@log_proc:

; 925  :                 if ( Ofssize )
; 926  :                     p = "  %s %s        L %-6s %08" I32_SPEC "X %s";
; 927  :                 else
; 928  :                     p = "  %s %s        L %-6s %04" I32_SPEC "X     %s";
; 929  :                 LstPrintf( p,

	mov	rdx, QWORD PTR [rbx+24]
	lea	rsi, OFFSET FLAT:$SG11754
	test	r12b, r12b
	cmove	rsi, r13
	test	rdx, rdx
	je	SHORT $LN88@log_proc
	mov	rbp, QWORD PTR [rdx+8]
	jmp	SHORT $LN89@log_proc
$LN88@log_proc:
	mov	rbp, QWORD PTR strings+288
$LN89@log_proc:
	mov	ecx, DWORD PTR [rbx+36]
	sub	ecx, 129				; 00000081H
	je	SHORT $LN94@log_proc
	cmp	ecx, 1
	je	SHORT $LN96@log_proc
	lea	r9, OFFSET FLAT:$SG11664
	jmp	SHORT $LN91@log_proc
$LN96@log_proc:
	test	rdx, rdx
	jne	SHORT $LN97@log_proc
	mov	rcx, rbx
	call	GetSymOfssize
	movsxd	rcx, eax
	lea	rax, OFFSET FLAT:strings
	mov	r9, QWORD PTR [rax+rcx*8+112]
	jmp	SHORT $LN91@log_proc
$LN97@log_proc:
	mov	r9, QWORD PTR strings+104
	jmp	SHORT $LN91@log_proc
$LN94@log_proc:
	test	rdx, rdx
	jne	SHORT $LN95@log_proc
	mov	rcx, rbx
	call	GetSymOfssize
	movsxd	rcx, eax
	lea	rax, OFFSET FLAT:strings
	mov	r9, QWORD PTR [rax+rcx*8+80]
	jmp	SHORT $LN91@log_proc
$LN95@log_proc:
	mov	r9, QWORD PTR strings+72
$LN91@log_proc:
	mov	eax, DWORD PTR [rbx+16]
	mov	r8, rdi
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, rsi
	mov	QWORD PTR [rsp+40], rbp
	mov	DWORD PTR [rsp+32], eax
	call	LstPrintf

; 930  :                           l2->sym.name,
; 931  :                           pdots,
; 932  :                           get_proc_type( &l2->sym ),
; 933  :                           l2->sym.offset,
; 934  :                           get_sym_seg_name( &l2->sym ));
; 935  : #ifdef DEBUG_OUT
; 936  :                 if ( l2->sym.fwdref )
; 937  :                     LstPrintf( " (F)" );
; 938  : #endif
; 939  :                 LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN20@log_proc
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN20@log_proc:

; 918  :             struct dsym *l2;
; 919  :             for ( l2 = l; l2; l2 = (struct dsym *)l2->sym.nextitem ) {

	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	$LL22@log_proc
	mov	r14, QWORD PTR l$2$[rsp]
$LN17@log_proc:

; 915  :         }
; 916  : 
; 917  :         for ( l = dir->e.procinfo->labellist; l ; l = l->e.nextll ) {

	mov	r14, QWORD PTR [r14+96]
	mov	QWORD PTR l$2$[rsp], r14
	test	r14, r14
	jne	$LL19@log_proc
$LN134@log_proc:
	mov	r13, QWORD PTR [rsp+160]
$LN18@log_proc:
	mov	r15, QWORD PTR [rsp+168]
	mov	rsi, QWORD PTR [rsp+152]

; 940  :             }
; 941  :         }
; 942  :     }
; 943  : }

	add	rsp, 96					; 00000060H
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
log_proc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
grp$ = 48
segs$ = 56
log_group PROC

; 742  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 743  :     unsigned i;
; 744  :     const char *pdots;
; 745  :     struct seg_item *curr;
; 746  : 
; 747  :     i = grp->name_size;

	movzx	eax, BYTE PTR [rcx+72]
	mov	rbx, rdx
	mov	rdi, rcx

; 748  :     pdots = (( i >= DOTSMAX ) ? "" : dots + i + 1);

	cmp	eax, 32					; 00000020H
	jb	SHORT $LN11@log_group
	lea	r8, OFFSET FLAT:$SG11648
	jmp	SHORT $LN12@log_group
$LN11@log_group:
	mov	r8, rax
	lea	rax, OFFSET FLAT:dots+1
	add	r8, rax
$LN12@log_group:

; 749  :     LstPrintf( "%s %s        %s", grp->name, pdots, strings[LS_GROUP] );

	mov	rdx, QWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG11649
	mov	r9, QWORD PTR strings+280
	call	LstPrintf

; 750  :     LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN14@log_group
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN14@log_group:

; 751  : 
; 752  :     /* the FLAT groups is always empty */
; 753  :     if ( grp == (struct asym *)ModuleInfo.flat_grp ) {

	cmp	rdi, QWORD PTR ModuleInfo+440
	jne	SHORT $LN8@log_group

; 754  :         for( ; segs; segs = segs->next ) {

	test	rbx, rbx
	je	SHORT $LN6@log_group
	npad	4
$LL4@log_group:

; 755  :             log_segment( (struct asym *)segs, grp );

	mov	rdx, rdi
	mov	rcx, rbx
	call	log_segment
	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	SHORT $LL4@log_group

; 760  :         }
; 761  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN8@log_group:

; 756  :         }
; 757  :     } else
; 758  :         for( curr = ((struct dsym *)grp)->e.grpinfo->seglist; curr; curr = curr->next ) {

	mov	rax, QWORD PTR [rdi+96]
	mov	rbx, QWORD PTR [rax]
	test	rbx, rbx
	je	SHORT $LN6@log_group
	npad	5
$LL7@log_group:

; 759  :             log_segment( (struct asym *)curr->seg, grp );

	mov	rcx, QWORD PTR [rbx+8]
	mov	rdx, rdi
	call	log_segment
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL7@log_group
$LN6@log_group:

; 760  :         }
; 761  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
log_group ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
buffer$ = 32
sym$ = 80
group$ = 88
log_segment PROC

; 710  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H

; 711  :     char buffer[32];
; 712  :     struct seg_info *seg = ((struct dsym *)sym)->e.seginfo;

	mov	rdi, QWORD PTR [rcx+96]
	mov	rbx, rcx

; 713  : 
; 714  :     if( seg->group == group ) {

	cmp	QWORD PTR [rdi], rdx
	jne	$LN34@log_segmen

; 715  :         int i = sym->name_size;

	movzx	eax, BYTE PTR [rcx+72]

; 716  :         const char *pdots;
; 717  :         pdots = (( i >= DOTSMAX ) ? "" : dots + i + 1);

	cmp	eax, 32					; 00000020H
	jl	SHORT $LN8@log_segmen
	lea	r8, OFFSET FLAT:$SG11618
	jmp	SHORT $LN9@log_segmen
$LN8@log_segmen:
	mov	r8, rax
	lea	rax, OFFSET FLAT:dots+1
	add	r8, rax
$LN9@log_segmen:

; 718  :         LstPrintf( "%s %s        ", sym->name, pdots );

	mov	rdx, QWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG11619
	call	LstPrintf

; 719  :         if( seg->Ofssize == USE32 ) {

	movzx	eax, BYTE PTR [rdi+104]
	cmp	al, 1
	jne	SHORT $LN3@log_segmen

; 720  :             //LstPrintf( "32 Bit   %08" I32_SPEC "X ", seg->current_loc );
; 721  :             LstPrintf( "32 Bit   %08" I32_SPEC "X ", sym->max_offset );

	lea	rcx, OFFSET FLAT:$SG11622
	jmp	SHORT $LN36@log_segmen
$LN3@log_segmen:

; 722  : #if AMD64_SUPPORT
; 723  :         } else if( seg->Ofssize == USE64 ) {
; 724  :             LstPrintf( "64 Bit   %08" I32_SPEC "X ", sym->max_offset );

	lea	rcx, OFFSET FLAT:$SG11625
	cmp	al, 2
	je	SHORT $LN36@log_segmen

; 725  : #endif
; 726  :         } else {
; 727  :             //LstPrintf( "16 Bit   %04" I32_SPEC "X     ", seg->current_loc );
; 728  :             LstPrintf( "16 Bit   %04" I32_SPEC "X     ", sym->max_offset );

	lea	rcx, OFFSET FLAT:$SG11626
$LN36@log_segmen:
	mov	edx, DWORD PTR [rbx+56]
	call	LstPrintf

; 729  :         }
; 730  :         LstPrintf( "%-7s %-8s", get_seg_align( seg, buffer ), get_seg_combine( seg ) );

	movzx	ecx, BYTE PTR [rdi+108]
	and	ecx, 7
	je	SHORT $LN15@log_segmen
	sub	ecx, 2
	je	SHORT $LN17@log_segmen
	sub	ecx, 3
	je	SHORT $LN16@log_segmen
	cmp	ecx, 1
	je	SHORT $LN18@log_segmen
	lea	rbx, OFFSET FLAT:$SG11452
	jmp	SHORT $LN12@log_segmen
$LN18@log_segmen:
	mov	rbx, QWORD PTR strings+256
	jmp	SHORT $LN12@log_segmen
$LN16@log_segmen:
	mov	rbx, QWORD PTR strings+240
	jmp	SHORT $LN12@log_segmen
$LN17@log_segmen:
	mov	rbx, QWORD PTR strings+248
	jmp	SHORT $LN12@log_segmen
$LN15@log_segmen:
	mov	rbx, QWORD PTR strings+232
$LN12@log_segmen:
	movzx	ecx, BYTE PTR [rdi+106]
	cmp	ecx, 3
	jg	SHORT $LN32@log_segmen
	je	SHORT $LN26@log_segmen
	mov	edx, ecx
	test	ecx, ecx
	je	SHORT $LN23@log_segmen
	sub	edx, 1
	je	SHORT $LN24@log_segmen
	cmp	edx, 1
	jne	SHORT $LN30@log_segmen
	mov	rdx, QWORD PTR strings+16
	jmp	SHORT $LN20@log_segmen
$LN24@log_segmen:
	mov	rdx, QWORD PTR strings+8
	jmp	SHORT $LN20@log_segmen
$LN23@log_segmen:
	mov	rdx, QWORD PTR strings
	jmp	SHORT $LN20@log_segmen
$LN26@log_segmen:
	mov	rdx, QWORD PTR strings+32
	jmp	SHORT $LN20@log_segmen
$LN32@log_segmen:
	cmp	ecx, 4
	je	SHORT $LN27@log_segmen
	cmp	ecx, 8
	je	SHORT $LN28@log_segmen
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN29@log_segmen
$LN30@log_segmen:
	mov	r8d, 1
	lea	rdx, OFFSET FLAT:$SG11441
	shl	r8d, cl
	lea	rcx, QWORD PTR buffer$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buffer$[rsp]
	jmp	SHORT $LN20@log_segmen
$LN29@log_segmen:
	mov	rdx, QWORD PTR strings+312
	jmp	SHORT $LN20@log_segmen
$LN28@log_segmen:
	mov	rdx, QWORD PTR strings+64
	jmp	SHORT $LN20@log_segmen
$LN27@log_segmen:
	mov	rdx, QWORD PTR strings+48
$LN20@log_segmen:
	mov	r8, rbx
	lea	rcx, OFFSET FLAT:$SG11627
	call	LstPrintf

; 731  :         LstPrintf( "'%s'", seg->clsym ? seg->clsym->name : "" );

	mov	rdx, QWORD PTR [rdi+80]
	test	rdx, rdx
	je	SHORT $LN10@log_segmen
	mov	rdx, QWORD PTR [rdx+8]
	jmp	SHORT $LN11@log_segmen
$LN10@log_segmen:
	lea	rdx, OFFSET FLAT:$SG11628
$LN11@log_segmen:
	lea	rcx, OFFSET FLAT:$SG11629
	call	LstPrintf

; 732  : #if 0
; 733  :         if ( group != NULL )
; 734  :             LstPrintf( " %s", group->name );
; 735  : #endif
; 736  :         LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN34@log_segmen
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN34@log_segmen:

; 737  :     }
; 738  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
log_segment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
sym$ = 64
log_typedef PROC

; 676  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 677  :     //struct dsym         *dir = (struct dsym *)sym;
; 678  :     //struct struct_info  *si = dir->e.structinfo;
; 679  :     char *p;
; 680  :     int i = sym->name_size;

	movzx	eax, BYTE PTR [rcx+72]
	mov	rbx, rcx

; 681  :     const char *pdots;
; 682  :     //char buffer[256];
; 683  : 
; 684  :     pdots = (( i >= DOTSMAX ) ? "" : dots + i + 1 );

	cmp	eax, 32					; 00000020H
	jl	SHORT $LN6@log_typede
	lea	rdi, OFFSET FLAT:$SG11599
	jmp	SHORT $LN7@log_typede
$LN6@log_typede:
	mov	rdi, rax
	lea	rax, OFFSET FLAT:dots+1
	add	rdi, rax
$LN7@log_typede:

; 685  :     p = StringBufferEnd;

	mov	r9, QWORD PTR ModuleInfo+488

; 686  :     *p = NULLC;

	mov	BYTE PTR [r9], 0

; 687  :     if ( sym->mem_type == MT_PROC && sym->target_type ) { /* typedef proto? */

	cmp	DWORD PTR [rcx+36], 128			; 00000080H
	jne	$LN2@log_typede
	cmp	QWORD PTR [rcx+48], 0
	je	$LN2@log_typede

; 688  :         strcat( p, strings[LS_PROC] );

	lea	rcx, QWORD PTR [r9-1]
$LL26@log_typede:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL26@log_typede
	mov	r8, QWORD PTR strings+208
	xor	edx, edx
	npad	10
$LL27@log_typede:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL27@log_typede

; 689  :         strcat( p, " " );

	lea	rcx, QWORD PTR [r9-1]
$LL24@log_typede:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL24@log_typede
	lea	r8, OFFSET FLAT:$SG11602
	xor	edx, edx
	npad	9
$LL25@log_typede:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL25@log_typede

; 690  :         if ( *sym->target_type->name ) {  /* the name may be "" */

	mov	rax, QWORD PTR [rbx+48]
	mov	r8, QWORD PTR [rax+8]
	cmp	BYTE PTR [r8], 0
	je	SHORT $LN4@log_typede

; 691  :             strcat( p, sym->target_type->name );

	lea	rcx, QWORD PTR [r9-1]
$LL22@log_typede:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL22@log_typede
	xor	edx, edx
	npad	2
$LL23@log_typede:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL23@log_typede

; 692  :             strcat( p," ");

	lea	rcx, QWORD PTR [r9-1]
$LL20@log_typede:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL20@log_typede
	lea	r8, OFFSET FLAT:$SG11604
	xor	edx, edx
	npad	9
$LL21@log_typede:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL21@log_typede
$LN4@log_typede:

; 693  :         }
; 694  :         /* v2.11: target_type has state SYM_TYPE (since v2.09).
; 695  :          * This state isn't handled properly by GetSymOfsSize(), which is called by GetMemtypeString(),
; 696  :          * so get the strings here.
; 697  :          */
; 698  :         //strcat( p, GetMemtypeString( sym->target_type, NULL ) );
; 699  :         strcat( p, strings[( sym->target_type->mem_type == MT_NEAR ? LS_LNEAR16 : LS_LFAR16 ) + sym->Ofssize ] );

	mov	rax, QWORD PTR [rbx+48]
	lea	r10, OFFSET FLAT:strings
	mov	ecx, 18
	mov	r8d, 22
	cmp	DWORD PTR [rax+36], 129			; 00000081H
	movzx	eax, BYTE PTR [rbx+44]
	cmove	r8d, ecx
	lea	rcx, QWORD PTR [r9-1]
	add	r8, rax
	npad	4
$LL18@log_typede:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL18@log_typede
	mov	r8, QWORD PTR [r10+r8*8]
	xor	edx, edx
$LL19@log_typede:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL19@log_typede

; 700  :         strcat( p," " );

	lea	rcx, QWORD PTR [r9-1]
$LL16@log_typede:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL16@log_typede
	lea	r8, OFFSET FLAT:$SG11605
	xor	edx, edx
	npad	9
$LL17@log_typede:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL17@log_typede

; 701  :         strcat( p, GetLanguage( sym->target_type ) );

	mov	rax, QWORD PTR [rbx+48]
	movsxd	rcx, DWORD PTR [rax+76]
	cmp	ecx, 7
	jg	SHORT $LN9@log_typede
	mov	r8, QWORD PTR [r10+rcx*8+336]
	jmp	SHORT $LN8@log_typede
$LN9@log_typede:
	lea	r8, OFFSET FLAT:$SG11517
$LN8@log_typede:
	lea	rcx, QWORD PTR [r9-1]
$LL14@log_typede:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL14@log_typede
	xor	edx, edx
	npad	2
$LL15@log_typede:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL15@log_typede

; 702  :     } else

	jmp	SHORT $LN3@log_typede
$LN2@log_typede:

; 703  :         p = (char *)GetMemtypeString( sym, p );

	mov	rdx, r9
	call	GetMemtypeString
	mov	r9, rax
$LN3@log_typede:

; 704  :     LstPrintf( "%s %s    %8" I32_SPEC "u  %s", sym->name, pdots, sym->total_size, p );

	mov	rdx, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG11606
	mov	QWORD PTR [rsp+32], r9
	mov	r8, rdi
	mov	r9d, DWORD PTR [rbx+56]
	call	LstPrintf

; 705  :     LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN12@log_typede
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN12@log_typede:

; 706  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
log_typedef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
sym$ = 80
log_record PROC

; 634  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 635  : #if AMD64_SUPPORT
; 636  :     uint_64         mask;
; 637  : #else
; 638  :     uint_32         mask;
; 639  : #endif
; 640  :     struct dsym     *dir = (struct dsym *)sym;
; 641  :     struct struct_info *si = dir->e.structinfo;
; 642  :     struct sfield   *f;
; 643  :     int i = sym->name_size;

	movzx	eax, BYTE PTR [rcx+72]

; 644  :     const char *pdots;
; 645  : 
; 646  :     pdots = ((i >= DOTSMAX) ? "" : dots + i + 1 );

	lea	rsi, OFFSET FLAT:dots+1
	mov	rbx, QWORD PTR [rcx+96]
	mov	rdi, rcx
	lea	r8, OFFSET FLAT:$SG11583
	cmp	eax, 32					; 00000020H
	jge	SHORT $LN15@log_record
	lea	r8, QWORD PTR [rsi+rax]
$LN15@log_record:

; 647  :     for( i = 0,f = si->head; f; f = f->next,i++ );

	mov	rax, QWORD PTR [rbx]
	xor	ecx, ecx
	test	rax, rax
	je	SHORT $LN3@log_record
	npad	5
$LL4@log_record:
	mov	rax, QWORD PTR [rax+96]
	inc	ecx
	test	rax, rax
	jne	SHORT $LL4@log_record
$LN3@log_record:

; 648  :     LstPrintf( "%s %s      %6" I32_SPEC "X  %7X", sym->name, pdots, sym->total_size*8, i );

	mov	r9d, DWORD PTR [rdi+56]
	mov	rdx, QWORD PTR [rdi+8]
	mov	DWORD PTR [rsp+32], ecx
	lea	rcx, OFFSET FLAT:$SG11584
	shl	r9d, 3
	call	LstPrintf

; 649  :     LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN23@log_record
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN23@log_record:

; 650  :     for( f = si->head; f; f = f->next ) {

	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	je	$LN6@log_record
	mov	QWORD PTR [rsp+80], rbp
	lea	rbp, OFFSET FLAT:$SG11585
	npad	9
$LL7@log_record:

; 651  :         i = f->sym.name_size + 2;

	movzx	eax, BYTE PTR [rbx+72]
	add	eax, 2

; 652  :         pdots = ((i >= DOTSMAX) ? "" : dots + i + 1 );

	cmp	eax, 32					; 00000020H
	jl	SHORT $LN16@log_record
	mov	r10, rbp
	jmp	SHORT $LN17@log_record
$LN16@log_record:
	movsxd	r10, eax
	add	r10, rsi
$LN17@log_record:

; 653  :         for ( i = f->sym.offset, mask = 0; i < f->sym.offset + f->sym.total_size; i++ )

	mov	r9d, DWORD PTR [rbx+16]
	xor	edx, edx
	mov	r11d, DWORD PTR [rbx+56]
	mov	eax, r9d
	lea	r8d, DWORD PTR [r9+r11]
	cmp	r9d, r8d
	jae	SHORT $LN9@log_record
	npad	3
$LL10@log_record:

; 654  : #if AMD64_SUPPORT
; 655  : #if defined(LLONG_MAX) || defined(__GNUC__) || defined(__TINYC__)
; 656  :             mask |= 1ULL << i;

	movsxd	rcx, eax
	inc	eax
	bts	rdx, rcx
	cmp	eax, r8d
	jb	SHORT $LL10@log_record
$LN9@log_record:

; 657  : #else
; 658  :             mask |= 1i64 << i;
; 659  : #endif
; 660  :         if ( sym->total_size > 4 )

	cmp	DWORD PTR [rdi+56], 4

; 661  :             LstPrintf( "  %s %s      %6" I32_SPEC "X  %7" I32_SPEC "X  %016" I64_SPEC "X %s", f->sym.name, pdots, f->sym.offset, f->sym.total_size, mask, f->ivalue[0] ? f->ivalue : "?" );

	lea	rax, QWORD PTR [rbx+104]
	mov	r8, r10
	jbe	SHORT $LN11@log_record
	cmp	BYTE PTR [rax], 0
	lea	rcx, OFFSET FLAT:$SG11588
	cmovne	rcx, rax
	mov	QWORD PTR [rsp+48], rcx
	lea	rcx, OFFSET FLAT:$SG11589
	mov	QWORD PTR [rsp+40], rdx
	jmp	SHORT $LN40@log_record
$LN11@log_record:

; 662  :         else
; 663  :             LstPrintf( "  %s %s      %6" I32_SPEC "X  %7" I32_SPEC "X  %08" I32_SPEC "X %s", f->sym.name, pdots, f->sym.offset, f->sym.total_size, (uint_32)mask, f->ivalue[0] ? f->ivalue : "?" );

	cmp	BYTE PTR [rax], 0
	lea	rcx, OFFSET FLAT:$SG11590
	cmovne	rcx, rax
	mov	QWORD PTR [rsp+48], rcx
	lea	rcx, OFFSET FLAT:$SG11591
	mov	DWORD PTR [rsp+40], edx
$LN40@log_record:
	mov	rdx, QWORD PTR [rbx+8]
	mov	DWORD PTR [rsp+32], r11d
	call	LstPrintf

; 664  : #else
; 665  :             mask |= 1 << i;
; 666  :         LstPrintf( "  %s %s      %6" I32_SPEC "X  %7" I32_SPEC "X  %08" I32_SPEC "X %s", f->sym.name, pdots, f->sym.offset, f->sym.total_size, mask, f->ivalue[0] ? f->ivalue : "?" );
; 667  : #endif
; 668  :         LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN5@log_record
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN5@log_record:

; 650  :     for( f = si->head; f; f = f->next ) {

	mov	rbx, QWORD PTR [rbx+96]
	test	rbx, rbx
	jne	$LL7@log_record
	mov	rbp, QWORD PTR [rsp+80]
$LN6@log_record:

; 669  :     }
; 670  : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
log_record ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
sym$ = 80
name$ = 88
ofs$ = 96
log_struct PROC

; 575  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rdi
	sub	rsp, 48					; 00000030H

; 576  :     unsigned      i;
; 577  :     struct dsym   *dir;
; 578  :     const char    *pdots;
; 579  :     struct struct_info *si;
; 580  :     struct sfield *f;
; 581  :     static int    prefix = 0;
; 582  : 
; 583  :     dir = (struct dsym *)sym;
; 584  : 
; 585  :     /* filter typedefs and records */
; 586  :     //if ( dir->sym.typekind != TYPE_STRUCT &&
; 587  :     //     dir->sym.typekind != TYPE_UNION )
; 588  :     //    return;
; 589  : 
; 590  :     si = dir->e.structinfo;

	mov	rbp, QWORD PTR [rcx+96]
	mov	rdi, rdx
	mov	r8, rcx

; 591  : 
; 592  :     if ( !name )

	test	rdx, rdx
	jne	SHORT $LN11@log_struct

; 593  :         name = sym->name;

	mov	rdi, QWORD PTR [rcx+8]
$LN11@log_struct:

; 594  :     i = strlen ( name );

	or	rdx, -1
	npad	8
$LL44@log_struct:
	inc	rdx
	cmp	BYTE PTR [rdi+rdx], 0
	jne	SHORT $LL44@log_struct

; 595  :     pdots = (( (i+prefix) >= DOTSMAX) ? "" : dots + i + prefix + 1 );

	movsxd	rcx, DWORD PTR ?prefix@?1??log_struct@@9@9
	lea	r9, OFFSET FLAT:dots+1
	mov	QWORD PTR [rsp+88], rsi
	lea	eax, DWORD PTR [rcx+rdx]
	cmp	eax, 32					; 00000020H
	jb	SHORT $LN22@log_struct
	lea	rsi, OFFSET FLAT:$SG11544
	jmp	SHORT $LN23@log_struct
$LN22@log_struct:
	mov	esi, edx
	add	rsi, rcx
	add	rsi, r9
$LN23@log_struct:

; 596  :     for ( i = 0; i < prefix; i++ )

	xor	ebx, ebx
	test	ecx, ecx
	je	SHORT $LN48@log_struct
	npad	5
$LL4@log_struct:

; 597  :         LstPrintf(" ");

	lea	rcx, OFFSET FLAT:$SG11545
	call	LstPrintf
	mov	ecx, DWORD PTR ?prefix@?1??log_struct@@9@9
	inc	ebx
	cmp	ebx, ecx
	jb	SHORT $LL4@log_struct

; 598  :     if ( prefix == 0 )

	mov	r8, QWORD PTR sym$[rsp]
	test	ecx, ecx
	jne	SHORT $LN12@log_struct
$LN48@log_struct:

; 599  :         if ( dir->e.structinfo->alignment > 1)

	mov	rax, QWORD PTR [r8+96]

; 600  :             LstPrintf( "%s %s        %8" I32_SPEC "X (%u)", name, pdots, sym->total_size, si->alignment );

	mov	rdx, rdi
	mov	r9d, DWORD PTR [r8+56]
	mov	r8, rsi
	cmp	BYTE PTR [rax+16], 1
	jbe	SHORT $LN14@log_struct
	movzx	eax, BYTE PTR [rbp+16]
	lea	rcx, OFFSET FLAT:$SG11550
	mov	DWORD PTR [rsp+32], eax
	call	LstPrintf
	mov	ebx, DWORD PTR ofs$[rsp]
	jmp	SHORT $LN13@log_struct
$LN14@log_struct:

; 601  :         else
; 602  :             LstPrintf( "%s %s        %8" I32_SPEC "X", name, pdots, sym->total_size );

	lea	rcx, OFFSET FLAT:$SG11551
	call	LstPrintf
	mov	ebx, DWORD PTR ofs$[rsp]
	jmp	SHORT $LN13@log_struct
$LN12@log_struct:

; 603  :     else
; 604  :         LstPrintf( "%s %s        %8" I32_SPEC "X", name, pdots, sym->offset + ofs);

	mov	r9d, DWORD PTR [r8+16]
	lea	rcx, OFFSET FLAT:$SG11552
	mov	ebx, DWORD PTR ofs$[rsp]
	mov	r8, rsi
	add	r9d, ebx
	mov	rdx, rdi
	call	LstPrintf
$LN13@log_struct:

; 605  :     LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN27@log_struct
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN27@log_struct:

; 606  :     prefix += 2;

	mov	ecx, DWORD PTR ?prefix@?1??log_struct@@9@9

; 607  :     for( f = si->head; f; f = f->next ) {

	mov	rdi, QWORD PTR [rbp]
	add	ecx, 2
	mov	DWORD PTR ?prefix@?1??log_struct@@9@9, ecx
	test	rdi, rdi
	je	$LN45@log_struct
	mov	rbp, QWORD PTR sym$[rsp]
	npad	9
$LL7@log_struct:

; 608  :         /* recursion if an embedded struct occurs */
; 609  :         /* v2.09: field init_dir removed */
; 610  :         //if ( f->sym->mem_type == MT_TYPE && f->init_dir == NULL ) {
; 611  :         if ( f->sym.mem_type == MT_TYPE && f->ivalue[0] == NULLC ) {

	mov	edx, DWORD PTR [rdi+36]
	cmp	edx, 196				; 000000c4H
	jne	SHORT $LN16@log_struct
	cmp	BYTE PTR [rdi+104], 0
	jne	SHORT $LN16@log_struct

; 612  :             log_struct( f->sym.type, f->sym.name, f->sym.offset + ofs );

	mov	r8d, DWORD PTR [rdi+16]
	mov	rdx, QWORD PTR [rdi+8]
	add	r8d, ebx
	mov	rcx, QWORD PTR [rdi+80]
	call	log_struct

; 613  :         } else {

	jmp	$LN46@log_struct
$LN16@log_struct:

; 614  :             /* don't list unstructured fields without name */
; 615  :             /* but do list them if they are structured */
; 616  :             if (*(f->sym.name) || (f->sym.mem_type == MT_TYPE)) {

	mov	rax, QWORD PTR [rdi+8]
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN19@log_struct
	cmp	edx, 196				; 000000c4H
	jne	$LN5@log_struct
$LN19@log_struct:

; 617  :                 i = f->sym.name_size + prefix;

	movzx	eax, BYTE PTR [rdi+72]
	add	eax, ecx

; 618  :                 pdots = ((i >= DOTSMAX) ? "" : dots + i + 1 );

	cmp	eax, 32					; 00000020H
	jb	SHORT $LN24@log_struct
	lea	rsi, OFFSET FLAT:$SG11557
	jmp	SHORT $LN25@log_struct
$LN24@log_struct:
	mov	esi, eax
	lea	rax, OFFSET FLAT:dots+1
	add	rsi, rax
$LN25@log_struct:

; 619  :                 for ( i = 0; i < prefix; i++ )

	xor	ebx, ebx
	test	ecx, ecx
	je	SHORT $LN9@log_struct
	npad	11
$LL10@log_struct:

; 620  :                     LstPrintf(" ");

	lea	rcx, OFFSET FLAT:$SG11558
	call	LstPrintf
	inc	ebx
	cmp	ebx, DWORD PTR ?prefix@?1??log_struct@@9@9
	jb	SHORT $LL10@log_struct
$LN9@log_struct:

; 621  :                 LstPrintf( "%s %s        %8" I32_SPEC "X   ", f->sym.name, pdots, f->sym.offset + sym->offset + ofs);

	mov	r9d, DWORD PTR [rdi+16]
	lea	rcx, OFFSET FLAT:$SG11559
	add	r9d, DWORD PTR [rbp+16]
	mov	r8, rsi
	mov	ebx, DWORD PTR ofs$[rsp]
	add	r9d, ebx
	mov	rdx, QWORD PTR [rdi+8]
	call	LstPrintf

; 622  :                 LstPrintf( "%s", GetMemtypeString( &f->sym, NULL ) );

	xor	edx, edx
	mov	rcx, rdi
	call	GetMemtypeString
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11560
	call	LstPrintf

; 623  :                 if ( f->sym.isarray )

	test	BYTE PTR [rdi+41], 2
	je	SHORT $LN20@log_struct

; 624  :                     LstPrintf( "[%u]",f->sym.total_length );

	mov	edx, DWORD PTR [rdi+64]
	lea	rcx, OFFSET FLAT:$SG11562
	call	LstPrintf
$LN20@log_struct:

; 625  :                 LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN46@log_struct
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN46@log_struct:
	mov	ecx, DWORD PTR ?prefix@?1??log_struct@@9@9
$LN5@log_struct:

; 607  :     for( f = si->head; f; f = f->next ) {

	mov	rdi, QWORD PTR [rdi+96]
	test	rdi, rdi
	jne	$LL7@log_struct
$LN45@log_struct:
	mov	rsi, QWORD PTR [rsp+88]

; 626  :             }
; 627  :         }
; 628  :     }
; 629  :     prefix -= 2;

	sub	ecx, 2
	mov	DWORD PTR ?prefix@?1??log_struct@@9@9, ecx

; 630  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
log_struct ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
sym$ = 48
log_macro PROC

; 458  : {

	sub	rsp, 40					; 00000028H

; 459  :     int i = sym->name_size;
; 460  :     const char *pdots;
; 461  :     const char *type = (sym->isfunc) ? strings[LS_FUNC] : strings[LS_PROC];

	movzx	eax, BYTE PTR [rcx+44]
	mov	r9, QWORD PTR strings+208
	and	al, 2
	movzx	edx, BYTE PTR [rcx+72]
	cmovne	r9, QWORD PTR strings+216

; 462  : 
; 463  :     pdots = ((i >= DOTSMAX) ? "" : dots + i + 1 );

	cmp	edx, 32					; 00000020H
	jl	SHORT $LN5@log_macro
	lea	r8, OFFSET FLAT:$SG11459
	jmp	SHORT $LN6@log_macro
$LN5@log_macro:
	lea	r8, OFFSET FLAT:dots+1
	add	r8, rdx
$LN6@log_macro:

; 464  :     LstPrintf( "%s %s        %s", sym->name, pdots ,type );

	mov	rdx, QWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG11460
	call	LstPrintf

; 465  : #ifdef DEBUG_OUT
; 466  :     LstPrintf( " %5lu", ((struct dsym *)sym)->e.macroinfo->count );
; 467  : #endif
; 468  :     LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN8@log_macro
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN8@log_macro:

; 469  :     return;
; 470  : }

	add	rsp, 40					; 00000028H
	ret	0
log_macro ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
LstSetPosition PROC

; 416  : {

$LN5:
	sub	rsp, 40					; 00000028H

; 417  :     if( CurrFile[LST] && ( Parse_Pass > PASS_1 ) && UseSavedState && ModuleInfo.GeneratedCode == 0 ) {

	mov	rcx, QWORD PTR ModuleInfo+112
	test	rcx, rcx
	je	SHORT $LN2@LstSetPosi
	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN2@LstSetPosi
	cmp	BYTE PTR UseSavedState, 0
	je	SHORT $LN2@LstSetPosi
	cmp	DWORD PTR ModuleInfo+456, 0
	jne	SHORT $LN2@LstSetPosi

; 418  :         list_pos = LineStoreCurr->list_pos;

	mov	rax, QWORD PTR LineStoreCurr

; 419  :         fseek( CurrFile[LST], list_pos, SEEK_SET );

	xor	r8d, r8d
	mov	edx, DWORD PTR [rax+12]
	mov	DWORD PTR list_pos, edx
	call	fseek

; 420  :         ModuleInfo.line_flags |= LOF_SKIPPOS;

	or	BYTE PTR ModuleInfo+398, 2
$LN2@LstSetPosi:

; 421  :     }
; 422  : }

	add	rsp, 40					; 00000028H
	ret	0
LstSetPosition ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
LstNL	PROC

; 401  : {

$LN5:
	sub	rsp, 40					; 00000028H

; 402  :     if( CurrFile[LST] ) {

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN2@LstNL

; 403  :         fwrite( NLSTR, 1, NLSIZ, CurrFile[LST] );

	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite

; 404  :         list_pos += NLSIZ;

	add	DWORD PTR list_pos, 2
$LN2@LstNL:

; 405  :     }
; 406  : }

	add	rsp, 40					; 00000028H
	ret	0
LstNL	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
format$ = 80
LstPrintf PROC

; 389  : {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	sub	rsp, 64					; 00000040H

; 390  :     va_list     args;
; 391  : 
; 392  :     if( CurrFile[LST] ) {

	cmp	QWORD PTR ModuleInfo+112, 0
	mov	rbx, rcx
	je	SHORT $LN2@LstPrintf

; 393  :         va_start( args, format );

	mov	QWORD PTR [rsp+56], rsi
	lea	rsi, QWORD PTR format$[rsp+8]

; 394  :         list_pos += vfprintf( CurrFile[LST], format, args );

	call	__local_stdio_printf_options
	mov	rdx, QWORD PTR ModuleInfo+112
	xor	r9d, r9d
	mov	r8, rbx
	mov	QWORD PTR [rsp+32], rsi
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf
	add	DWORD PTR list_pos, eax
	mov	rsi, QWORD PTR [rsp+56]
$LN2@LstPrintf:

; 395  :         va_end( args );
; 396  :     }
; 397  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
LstPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
queues$ = 32
LstWriteCRef PROC

; 1044 : {

$LN104:
	mov	rax, rsp
	sub	rsp, 184				; 000000b8H

; 1045 :     struct asym     **syms;
; 1046 :     struct dsym     *dir;
; 1047 :     struct struct_info *si;
; 1048 :     int             idx;
; 1049 :     uint_32         i;
; 1050 :     uint_32         SymCount;
; 1051 :     struct qdesc    queues[LQ_LAST];
; 1052 : 
; 1053 :     /* no point going through the motions if lst file isn't open */
; 1054 :     if( CurrFile[LST] == NULL || Options.no_symbol_listing == TRUE ) {

	mov	rcx, QWORD PTR ModuleInfo+112
	test	rcx, rcx
	je	$LN22@LstWriteCR
	cmp	BYTE PTR Options+136, 1
	je	$LN22@LstWriteCR

; 1055 :         return;
; 1056 :     }
; 1057 : 
; 1058 :     /* go to EOF */
; 1059 :     fseek( CurrFile[LST], 0, SEEK_END );

	mov	QWORD PTR [rax+8], rbx
	xor	edx, edx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax-8], rdi
	mov	QWORD PTR [rax-16], r12
	mov	QWORD PTR [rax-24], r13
	mov	r13d, 2
	mov	QWORD PTR [rax-32], r14
	mov	r8d, r13d
	mov	QWORD PTR [rax-40], r15
	call	fseek

; 1060 : 
; 1061 :     SymCount = SymGetCount();

	call	SymGetCount
	mov	r12d, eax

; 1062 :     syms = MemAlloc( SymCount * sizeof( struct asym * ) );

	mov	r14d, eax
	lea	rcx, QWORD PTR [r12*8]
	call	MemAlloc

; 1063 :     SymGetAll( syms );

	mov	rcx, rax
	mov	r15, rax
	call	SymGetAll

; 1064 : 
; 1065 :     DebugMsg(("LstWriteCRef: calling qsort\n"));
; 1066 :     /* sort 'em */
; 1067 :     qsort( syms, SymCount, sizeof( struct asym * ), compare_syms );

	lea	r9, OFFSET FLAT:compare_syms
	mov	edx, r12d
	lea	r8d, QWORD PTR [r13+6]
	mov	rcx, r15
	call	qsort

; 1068 : 
; 1069 :     memset( queues, 0, sizeof( queues ) );

	xor	edx, edx
	lea	r8d, QWORD PTR [r13+110]
	lea	rcx, QWORD PTR queues$[rsp]
	call	memset

; 1070 :     for( i = 0; i < SymCount; ++i ) {

	lea	r11, OFFSET FLAT:__ImageBase
	test	r12d, r12d
	je	$LN3@LstWriteCR
	mov	rdx, r15
	mov	r10d, r12d
	npad	10
$LL4@LstWriteCR:

; 1071 :         struct qdesc *q;
; 1072 :         if ( syms[i]->list == FALSE )

	mov	r8, QWORD PTR [rdx]
	movzx	r9d, BYTE PTR [r8+41]
	test	r9b, 1
	je	$LN2@LstWriteCR

; 1073 :             continue;
; 1074 :         switch (syms[i]->state) {

	mov	eax, DWORD PTR [r8+32]
	dec	eax
	cmp	eax, 8
	ja	$LN2@LstWriteCR
	cdqe
	mov	ecx, DWORD PTR $LN102@LstWriteCR[r11+rax*4]
	add	rcx, r11
	jmp	rcx
$LN24@LstWriteCR:

; 1075 :         case SYM_TYPE:
; 1076 :             si = ((struct dsym *)syms[i])->e.structinfo;
; 1077 :             switch ( syms[i]->typekind ) {

	movzx	eax, BYTE PTR [r8+66]
	test	al, al
	je	SHORT $LN2@LstWriteCR
	cmp	al, r13b
	jbe	SHORT $LN27@LstWriteCR
	cmp	al, 3
	je	SHORT $LN26@LstWriteCR
	cmp	al, 4
	jne	SHORT $LN2@LstWriteCR

; 1078 :             case TYPE_RECORD:  idx = LQ_RECORDS; break;

	mov	rax, r13
	jmp	SHORT $LN5@LstWriteCR
$LN26@LstWriteCR:

; 1079 :             case TYPE_TYPEDEF: idx = LQ_TYPEDEFS;break;

	mov	eax, 3
	jmp	SHORT $LN5@LstWriteCR
$LN27@LstWriteCR:

; 1080 :             case TYPE_STRUCT:
; 1081 :             case TYPE_UNION:   idx = LQ_STRUCTS ;break;

	mov	eax, 1

; 1082 : #ifdef DEBUG_OUT
; 1083 :             default:           idx = LQ_UNDEF_TYPES ;break;
; 1084 : #else
; 1085 :             default: continue; /* skip "undefined" types */
; 1086 : #endif
; 1087 :             }
; 1088 :             break;

	jmp	SHORT $LN5@LstWriteCR
$LN29@LstWriteCR:

; 1089 :         case SYM_MACRO:
; 1090 :             idx = LQ_MACROS;

	xor	eax, eax

; 1091 :             break;

	jmp	SHORT $LN5@LstWriteCR
$LN30@LstWriteCR:

; 1092 :         case SYM_SEG:
; 1093 :             idx = LQ_SEGS;

	mov	eax, 4

; 1094 :             break;

	jmp	SHORT $LN5@LstWriteCR
$LN31@LstWriteCR:

; 1095 :         case SYM_GRP:
; 1096 :             idx = LQ_GRPS;

	mov	eax, 5

; 1097 :             break;

	jmp	SHORT $LN5@LstWriteCR
$LN32@LstWriteCR:

; 1098 :         case SYM_INTERNAL:
; 1099 :         case SYM_EXTERNAL: /* v2.04: added, since PROTOs are now externals */
; 1100 :             if ( syms[i]->isproc ) {

	test	r9b, 8
	je	SHORT $LN2@LstWriteCR

; 1101 :                 idx = LQ_PROCS;

	mov	eax, 6
$LN5@LstWriteCR:

; 1102 :                 break;
; 1103 :             }
; 1104 :             /* no break */
; 1105 :         default:
; 1106 :             continue;
; 1107 :         }
; 1108 :         q = &queues[idx];

	shl	rax, 4
	lea	rcx, QWORD PTR queues$[rsp]
	add	rcx, rax

; 1109 :         if( q->head == NULL ) {

	cmp	QWORD PTR [rcx], 0
	jne	SHORT $LN35@LstWriteCR

; 1110 :             q->head = syms[i];

	mov	QWORD PTR [rcx], r8

; 1111 :         } else {

	jmp	SHORT $LN36@LstWriteCR
$LN35@LstWriteCR:

; 1112 :             ((struct dsym *)q->tail)->next = (struct dsym *)syms[i];

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+104], r8
$LN36@LstWriteCR:

; 1113 :         }
; 1114 :         q->tail = syms[i];

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx+8], rax

; 1115 :         ((struct dsym *)syms[i])->next = NULL;

	mov	QWORD PTR [rax+104], 0
$LN2@LstWriteCR:

; 1070 :     for( i = 0; i < SymCount; ++i ) {

	add	rdx, 8
	sub	r10, 1
	jne	$LL4@LstWriteCR
$LN3@LstWriteCR:

; 1116 :     }
; 1117 :     for ( idx = 0; idx < ( sizeof( cr ) / sizeof(cr[0] ) ); idx++ ) {

	mov	rbp, QWORD PTR queues$[rsp+64]
	lea	rbx, OFFSET FLAT:cr
	xor	esi, esi
$LL11@LstWriteCR:

; 1118 :         if ( queues[cr[idx].type].head ) {

	movsx	rax, WORD PTR [rbx]
	shl	rax, 4
	cmp	QWORD PTR queues$[rsp+rax], 0
	je	$LN9@LstWriteCR

; 1119 :             if ( cr[idx].capitems ) {

	mov	rdi, QWORD PTR [rbx+8]
	test	rdi, rdi
	je	SHORT $LN13@LstWriteCR

; 1120 :                 const short *ps;
; 1121 :                 for ( ps = cr[idx].capitems; *ps; ps++ ) {

	movzx	eax, WORD PTR [rdi]
	test	ax, ax
	je	SHORT $LN13@LstWriteCR
	lea	rbp, OFFSET FLAT:__ImageBase
	npad	4
$LL14@LstWriteCR:

; 1122 :                     //if ( *ps == -1 )
; 1123 :                     //    LstNL();
; 1124 :                     //else
; 1125 :                         LstCaption( strings[ *ps ], ps == cr[idx].capitems ? 2 : 0 );

	xor	edx, edx
	movsx	rcx, ax
	cmp	rdi, QWORD PTR [rbx+8]
	cmove	edx, r13d
	mov	rcx, QWORD PTR strings[rbp+rcx*8]
	call	LstCaption
	add	rdi, r13
	movzx	eax, WORD PTR [rdi]
	test	ax, ax
	jne	SHORT $LL14@LstWriteCR
	mov	rbp, QWORD PTR queues$[rsp+64]
$LN13@LstWriteCR:

; 1126 :                 }
; 1127 :             }
; 1128 :             for( dir = queues[cr[idx].type].head; dir ; dir = dir->next ) {

	movsx	rax, WORD PTR [rbx]
	add	rax, rax
	mov	rdi, QWORD PTR queues$[rsp+rax*8]
	test	rdi, rdi
	je	SHORT $LN9@LstWriteCR
	npad	4
$LL17@LstWriteCR:

; 1129 :                 cr[idx].function( &dir->sym, ( cr[idx].flags & PRF_ADDSEG ) ? queues[LQ_SEGS].head : NULL, 0 );

	movzx	eax, BYTE PTR [rbx+2]
	xor	edx, edx
	and	al, 1
	mov	rcx, rdi
	cmovne	rdx, rbp
	xor	r8d, r8d
	call	QWORD PTR [rbx+16]
	mov	rdi, QWORD PTR [rdi+104]
	test	rdi, rdi
	jne	SHORT $LL17@LstWriteCR
$LN9@LstWriteCR:

; 1116 :     }
; 1117 :     for ( idx = 0; idx < ( sizeof( cr ) / sizeof(cr[0] ) ); idx++ ) {

	inc	esi
	add	rbx, 24
	movsxd	rax, esi
	cmp	rax, 7
	jb	$LL11@LstWriteCR

; 1130 :             }
; 1131 :         }
; 1132 :     }
; 1133 : 
; 1134 :     /* write out symbols */
; 1135 :     LstCaption( strings[ LS_TXT_SYMBOLS ], 2 );

	mov	rdi, QWORD PTR strings+496
	mov	ebx, r13d
	mov	r9, QWORD PTR ModuleInfo+112
	mov	rsi, QWORD PTR [rsp+208]
	mov	rbp, QWORD PTR [rsp+200]
$LL46@LstWriteCR:
	test	r9, r9
	je	SHORT $LN44@LstWriteCR
	mov	r8, r13
	lea	rcx, OFFSET FLAT:$SG11421
	mov	edx, 1
	call	fwrite
	add	DWORD PTR list_pos, r13d
	mov	r9, QWORD PTR ModuleInfo+112
$LN44@LstWriteCR:
	sub	ebx, 1
	jne	SHORT $LL46@LstWriteCR
	mov	rcx, rdi
	call	LstPrintf
	mov	r9, QWORD PTR ModuleInfo+112
	mov	rdi, QWORD PTR [rsp+176]
	test	r9, r9
	je	SHORT $LN55@LstWriteCR
	mov	r8, r13
	lea	edx, QWORD PTR [rbx+1]
	lea	rcx, OFFSET FLAT:$SG11421
	call	fwrite
	mov	r9, QWORD PTR ModuleInfo+112
	add	DWORD PTR list_pos, r13d
	test	r9, r9
	je	SHORT $LN55@LstWriteCR
	mov	r8, r13
	lea	edx, QWORD PTR [rbx+1]
	lea	rcx, OFFSET FLAT:$SG11421
	call	fwrite
	add	DWORD PTR list_pos, r13d
$LN55@LstWriteCR:

; 1136 :     LstCaption( strings[ LS_TXT_SYMCAP ], 0 );

	mov	rcx, QWORD PTR strings+504
	call	LstPrintf
	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN69@LstWriteCR
	mov	r8, r13
	lea	rcx, OFFSET FLAT:$SG11421
	mov	edx, 1
	call	fwrite
	mov	r9, QWORD PTR ModuleInfo+112
	add	DWORD PTR list_pos, r13d
	test	r9, r9
	je	SHORT $LN69@LstWriteCR
	mov	r8, r13
	lea	rcx, OFFSET FLAT:$SG11421
	mov	edx, 1
	call	fwrite
	add	DWORD PTR list_pos, r13d
	mov	r9, QWORD PTR ModuleInfo+112
$LN69@LstWriteCR:

; 1137 :     for( i = 0; i < SymCount; ++i ) {

	test	r12d, r12d
	mov	r12, QWORD PTR [rsp+168]
	je	SHORT $LN19@LstWriteCR
	mov	rbx, r15
	npad	7
$LL20@LstWriteCR:
	mov	rcx, QWORD PTR [rbx]

; 1138 :         if ( syms[i]->list == TRUE && syms[i]->isproc == FALSE ) {

	movzx	eax, BYTE PTR [rcx+41]
	test	al, 1
	je	SHORT $LN18@LstWriteCR
	test	al, 8
	jne	SHORT $LN18@LstWriteCR

; 1139 :             DebugMsg(("LstWriteCRef: log_symbol( %s )\n", syms[i]->name ));
; 1140 :             log_symbol( syms[i] );

	call	log_symbol
$LN18@LstWriteCR:

; 1137 :     for( i = 0; i < SymCount; ++i ) {

	add	rbx, 8
	sub	r14, 1
	jne	SHORT $LL20@LstWriteCR
	mov	r9, QWORD PTR ModuleInfo+112
$LN19@LstWriteCR:
	mov	r14, QWORD PTR [rsp+152]
	mov	rbx, QWORD PTR [rsp+192]

; 1141 :         }
; 1142 : #ifdef DEBUG_OUT
; 1143 :         else
; 1144 :             DebugMsg(("LstWriteCRef: %s suppressed\n", syms[i]->name ));
; 1145 : #endif
; 1146 :     }
; 1147 :     LstNL();

	test	r9, r9
	je	SHORT $LN72@LstWriteCR
	mov	r8, r13
	lea	rcx, OFFSET FLAT:$SG11421
	mov	edx, 1
	call	fwrite
	add	DWORD PTR list_pos, r13d
$LN72@LstWriteCR:

; 1148 : 
; 1149 :     /* free the sorted symbols */
; 1150 :     DebugMsg(("LstWriteCRef: free sorted symbols\n"));
; 1151 :     MemFree( syms );

	mov	rcx, r15
	call	MemFree
	mov	r15, QWORD PTR [rsp+144]
	mov	r13, QWORD PTR [rsp+160]
$LN22@LstWriteCR:

; 1152 : }

	add	rsp, 184				; 000000b8H
	ret	0
	npad	3
$LN102@LstWriteCR:
	DD	$LN32@LstWriteCR
	DD	$LN32@LstWriteCR
	DD	$LN30@LstWriteCR
	DD	$LN31@LstWriteCR
	DD	$LN2@LstWriteCR
	DD	$LN2@LstWriteCR
	DD	$LN24@LstWriteCR
	DD	$LN2@LstWriteCR
	DD	$LN29@LstWriteCR
LstWriteCRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
LstWriteSrcLine PROC

; 384  :     LstWrite( LSTTYPE_MACRO, 0, NULL );

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+5]
	jmp	LstWrite
LstWriteSrcLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
ll$ = 0
type$ = 112
oldofs$ = 120
srcfile$1$ = 128
value$ = 128
pSrcline$1$ = 136
LstWrite PROC

; 141  : {

$LN123:
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	lea	rbp, QWORD PTR [rsp+32]
	mov	esi, edx
	mov	QWORD PTR [rbp+112], rbx

; 142  :     uint_32 newofs;
; 143  :     struct asym *sym = value;
; 144  :     int     len;
; 145  :     int     len2;
; 146  :     int     idx;
; 147  :     int     srcfile;
; 148  :     char    *p1;
; 149  :     char    *p2;
; 150  :     char    *pSrcline;
; 151  :     struct lstleft *pll;
; 152  :     struct lstleft ll;
; 153  :     //char    buffer2[MAX_LINE_LEN]; /* stores text macro value */
; 154  : 
; 155  :     if ( ModuleInfo.list == FALSE || CurrFile[LST] == NULL || ( ModuleInfo.line_flags & LOF_LISTED ) )

	mov	edx, DWORD PTR ModuleInfo+408
	mov	rbx, r8
	movsxd	r14, ecx
	bt	edx, 11
	jae	$LN19@LstWrite
	mov	rcx, QWORD PTR ModuleInfo+112
	test	rcx, rcx
	je	$LN19@LstWrite
	movzx	eax, BYTE PTR ModuleInfo+398
	test	al, 1
	jne	$LN19@LstWrite

; 156  :         return;
; 157  :     if ( ModuleInfo.GeneratedCode && ( ModuleInfo.list_generated_code == FALSE ) )

	mov	r8d, DWORD PTR ModuleInfo+456
	test	r8d, r8d
	je	SHORT $LN20@LstWrite
	bt	edx, 14
	jae	$LN19@LstWrite
$LN20@LstWrite:

; 158  :         return;
; 159  :     if ( MacroLevel ) {

	cmp	BYTE PTR MacroLevel, 0
	je	SHORT $LN23@LstWrite

; 160  :         switch ( ModuleInfo.list_macro ) {

	cmp	DWORD PTR ModuleInfo+400, 0
	je	$LN19@LstWrite
$LN23@LstWrite:

; 161  :         case LM_NOLISTMACRO:
; 162  :             return;
; 163  :         case LM_LISTMACRO:
; 164  :             /* todo: filter certain macro lines */
; 165  :             break;
; 166  :         }
; 167  :     }
; 168  : 
; 169  :     ModuleInfo.line_flags |= LOF_LISTED;
; 170  : 
; 171  :     DebugMsg1(("LstWrite( %u, %" I32_SPEC "u ): enter [ pos=%" I32_SPEC "u, GeneratedCode=%u, MacroLevel=%u ]\n", type, oldofs, list_pos, ModuleInfo.GeneratedCode, MacroLevel ));
; 172  :     pSrcline = CurrSource;

	mov	rdi, QWORD PTR ModuleInfo+464
	or	al, 1

; 173  : #if FASTPASS
; 174  :     if ( ( Parse_Pass > PASS_1 ) && UseSavedState ) {

	or	r15, -1
	mov	BYTE PTR ModuleInfo+398, al
	xor	r12d, r12d
	mov	QWORD PTR pSrcline$1$[rbp], rdi
	cmp	DWORD PTR Parse_Pass, r12d
	jbe	SHORT $LN24@LstWrite
	cmp	BYTE PTR UseSavedState, r12b
	je	SHORT $LN24@LstWrite

; 175  :         if ( ModuleInfo.GeneratedCode == 0 ) {

	test	r8d, r8d
	jne	SHORT $LN95@LstWrite

; 176  :             if ( !( ModuleInfo.line_flags & LOF_SKIPPOS ) )

	mov	rdx, QWORD PTR LineStoreCurr
	test	al, 2
	jne	SHORT $LN94@LstWrite

; 177  :                 list_pos = LineStoreCurr->list_pos;

	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR list_pos, eax
$LN94@LstWrite:

; 178  : #if USELSLINE /* either use CurrSource + CurrComment or LineStoreCurr->line (see assemble.c, OnePass() */
; 179  :             pSrcline = LineStoreCurr->line;
; 180  :             if ( ModuleInfo.CurrComment ) { /* if comment was removed, readd it! */

	cmp	QWORD PTR ModuleInfo+472, r12
	lea	rdi, QWORD PTR [rdx+16]
	mov	QWORD PTR pSrcline$1$[rbp], rdi
	je	SHORT $LN95@LstWrite

; 181  :                 *( LineStoreCurr->line + strlen( LineStoreCurr->line ) ) = ';';

	mov	rax, r15
	npad	5
$LL93@LstWrite:
	cmp	BYTE PTR [rdi+rax+1], r12b
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL93@LstWrite
	mov	BYTE PTR [rax+rdx+16], 59		; 0000003bH

; 182  :                 ModuleInfo.CurrComment = NULL;

	mov	rcx, QWORD PTR ModuleInfo+112
	mov	QWORD PTR ModuleInfo+472, r12
$LN95@LstWrite:

; 183  :             }
; 184  : #endif
; 185  :             DebugMsg1(("LstWrite: Pass=%u, stored pos=%" I32_SPEC "u\n", Parse_Pass+1, list_pos ));
; 186  :         }
; 187  :         fseek( CurrFile[LST], list_pos, SEEK_SET );

	mov	edx, DWORD PTR list_pos
	xor	r8d, r8d
	call	fseek
$LN24@LstWrite:

; 188  :     }
; 189  : #endif
; 190  : 
; 191  :     ll.next = NULL;
; 192  :     memset( ll.buffer, ' ', sizeof( ll.buffer ) );

	mov	r13, 2314885530818453536		; 2020202020202020H
	mov	QWORD PTR ll$[rbp], r12
	mov	QWORD PTR ll$[rbp+8], r13
	mov	QWORD PTR ll$[rbp+16], r13
	mov	QWORD PTR ll$[rbp+24], r13
	mov	QWORD PTR ll$[rbp+32], r13

; 193  :     srcfile = get_curr_srcfile();

	call	get_curr_srcfile
	mov	DWORD PTR srcfile$1$[rbp], eax
	mov	r12d, eax

; 194  : 
; 195  :     switch ( type ) {

	cmp	r14d, 8
	ja	$LN55@LstWrite
	lea	rax, OFFSET FLAT:__ImageBase
	mov	edx, DWORD PTR $LN92@LstWrite[rax+r14*4]
	add	rdx, rax
	jmp	rdx
$LN28@LstWrite:

; 196  :     case LSTTYPE_DATA:
; 197  :         if ( Parse_Pass == PASS_1 && Options.first_pass_listing == FALSE ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN29@LstWrite
	cmp	BYTE PTR Options+137, 0
	je	$LN105@LstWrite
$LN29@LstWrite:

; 198  :             break;
; 199  :         }
; 200  :         /* no break */
; 201  :     case LSTTYPE_CODE:
; 202  :         newofs = GetCurrOffset();

	call	GetCurrOffset

; 203  :         sprintf( ll.buffer, "%08" I32_SPEC "X", oldofs );

	mov	r8d, esi
	lea	rdx, OFFSET FLAT:$SG11359
	lea	rcx, QWORD PTR ll$[rbp+8]
	mov	r12d, eax
	call	sprintf

; 204  :         ll.buffer[OFSSIZE] = ' ';
; 205  : 
; 206  :         if ( CurrSeg == NULL )

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	BYTE PTR ll$[rbp+16], 32		; 00000020H
	test	rcx, rcx
	je	SHORT $LN103@LstWrite

; 207  :             break;
; 208  :         //if ( write_to_file == FALSE )
; 209  :         if ( Options.first_pass_listing ) {

	cmp	BYTE PTR Options+137, 0
	je	SHORT $LN32@LstWrite

; 210  :             if ( Parse_Pass > PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN35@LstWrite
$LN103@LstWrite:

; 229  :             }
; 230  :             break;

	mov	r12d, DWORD PTR srcfile$1$[rbp]
$LN120@LstWrite:
	mov	rdi, QWORD PTR pSrcline$1$[rbp]
$LN101@LstWrite:

; 315  :         }
; 316  :         break;
; 317  :     }
; 318  : 
; 319  : #if FASTPASS
; 320  :     if ( Parse_Pass == PASS_1 || UseSavedState == FALSE ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	$LN59@LstWrite
	cmp	BYTE PTR UseSavedState, 0
	je	$LN59@LstWrite

; 330  :             ll.buffer[30] = 'C';
; 331  :         }
; 332  : #ifdef DEBUG_OUT
; 333  :         ll.last = NULLC;
; 334  : #endif
; 335  : #if FASTPASS
; 336  :     } else {
; 337  :         idx = OFSSIZE + 2 + 2 * CODEBYTES;

	mov	ebx, 28
	jmp	$LN62@LstWrite
$LN32@LstWrite:

; 211  :                 break;
; 212  : #ifdef DEBUG_OUT
; 213  :         } else if ( Options.max_passes == 1 ) {
; 214  :             ; /* write a listing in pass 1 */
; 215  : #endif
; 216  :         } else if ( Parse_Pass == PASS_1 )  /* changed v1.96 */

	cmp	DWORD PTR Parse_Pass, 0
	je	$LN121@LstWrite
$LN35@LstWrite:

; 217  :             break;
; 218  : 
; 219  :         len = CODEBYTES;
; 220  :         p2 = ll.buffer + OFSSIZE + 2;
; 221  : 
; 222  :         if ( CurrSeg->e.seginfo->CodeBuffer == NULL ||

	mov	rax, QWORD PTR [rcx+96]
	lea	rbx, QWORD PTR ll$[rbp+18]
	mov	edi, 9
	cmp	QWORD PTR [rax+16], 0
	je	$LN72@LstWrite
	test	BYTE PTR [rax+107], 32			; 00000020H
	je	$LN72@LstWrite

; 231  :         }
; 232  : 
; 233  :         /* OMF hold just a small buffer for one LEDATA record */
; 234  :         /* if it has been flushed, use LastCodeBufSize */
; 235  :         idx = (CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc)

	mov	r14d, DWORD PTR [rax+12]
	sub	r14d, DWORD PTR [rax+8]
	sub	r14d, r12d
	add	r14d, esi

; 236  :             - (newofs - oldofs);
; 237  :         if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+144, 1
	jne	SHORT $LN38@LstWrite

; 238  :             /* v2.11: additional check to make the hack more robust [ test case:  db 800000h dup (0) ] */
; 239  :             if ( ( idx+LastCodeBufSize ) < 0 )

	mov	edx, DWORD PTR LastCodeBufSize
	lea	eax, DWORD PTR [rdx+r14]
	test	eax, eax
	js	$LN103@LstWrite

; 240  :                 break; /* just exit. The code bytes area will remain empty */
; 241  :             while ( idx < 0 && len ) {

	movsxd	r13, r14d
	test	r14d, r14d
	jns	SHORT $LN71@LstWrite
	npad	5
$LL8@LstWrite:
	test	edi, edi
	je	SHORT $LN71@LstWrite

; 242  :                 sprintf( p2, "%02X", CurrSeg->e.seginfo->CodeBuffer[idx+LastCodeBufSize] );

	mov	rax, QWORD PTR [rcx+96]
	movsxd	rcx, edx
	mov	rdx, QWORD PTR [rax+16]
	add	rdx, rcx
	mov	rcx, rbx
	movzx	r8d, BYTE PTR [rdx+r13]
	lea	rdx, OFFSET FLAT:$SG11370
	call	sprintf
	mov	rcx, QWORD PTR ModuleInfo+432

; 243  :                 p2 += 2;

	add	rbx, 2

; 244  :                 idx++;

	inc	r14d

; 245  :                 oldofs++;

	inc	esi

; 246  :                 len--;

	dec	edi
	add	r13, 1
	jns	SHORT $LN71@LstWrite

; 240  :                 break; /* just exit. The code bytes area will remain empty */
; 241  :             while ( idx < 0 && len ) {

	mov	edx, DWORD PTR LastCodeBufSize
	jmp	SHORT $LL8@LstWrite
$LN38@LstWrite:

; 247  :             }
; 248  :         } else if (idx < 0)

	test	r14d, r14d
	mov	r9d, 0
	cmovs	r14d, r9d
$LN71@LstWrite:

; 249  :             idx = 0;
; 250  : 
; 251  :         while ( oldofs < newofs && len ) {

	cmp	esi, r12d
	jae	SHORT $LN116@LstWrite
	movsxd	r14, r14d
	npad	5
$LL10@LstWrite:
	test	edi, edi
	je	SHORT $LN116@LstWrite

; 252  :             sprintf( p2, "%02X", CurrSeg->e.seginfo->CodeBuffer[idx] );

	mov	rax, QWORD PTR [rcx+96]
	lea	rdx, OFFSET FLAT:$SG11372
	mov	rcx, QWORD PTR [rax+16]
	movzx	r8d, BYTE PTR [rcx+r14]
	mov	rcx, rbx
	call	sprintf

; 253  :             p2 += 2;

	add	rbx, 2

; 254  :             idx++;

	inc	r14

; 255  :             oldofs++;

	inc	esi

; 256  :             len--;

	dec	edi
	cmp	esi, r12d
	jae	SHORT $LN116@LstWrite

; 249  :             idx = 0;
; 250  : 
; 251  :         while ( oldofs < newofs && len ) {

	mov	rcx, QWORD PTR ModuleInfo+432
	jmp	SHORT $LL10@LstWrite
$LN116@LstWrite:

; 257  :         }
; 258  :         *p2 = ' ';

	mov	BYTE PTR [rbx], 32			; 00000020H

; 259  :         break;

	jmp	$LN103@LstWrite
$LN72@LstWrite:

; 223  :             CurrSeg->e.seginfo->written == FALSE ) {
; 224  :             while ( oldofs < newofs && len ) {

	cmp	esi, r12d
	jae	$LN103@LstWrite
	npad	6
$LL6@LstWrite:
	test	edi, edi
	je	$LN103@LstWrite

; 225  :                 *p2++ = '0';

	mov	WORD PTR [rbx], 12336			; 00003030H

; 226  :                 *p2++ = '0';
; 227  :                 oldofs++;

	inc	esi
	add	rbx, 2

; 228  :                 len--;

	dec	edi
	cmp	esi, r12d
	jb	SHORT $LL6@LstWrite

; 229  :             }
; 230  :             break;

	jmp	$LN103@LstWrite
$LN121@LstWrite:
	mov	r12d, DWORD PTR srcfile$1$[rbp]
$LN105@LstWrite:
	mov	rdi, QWORD PTR pSrcline$1$[rbp]
$LN59@LstWrite:

; 321  : #endif
; 322  :         idx = sizeof( ll.buffer );
; 323  :         if ( ModuleInfo.GeneratedCode )

	cmp	DWORD PTR ModuleInfo+456, 0
	mov	ecx, 42					; 0000002aH
	movzx	eax, BYTE PTR ll$[rbp+36]
	mov	ebx, 32					; 00000020H
	cmovne	eax, ecx
	mov	BYTE PTR ll$[rbp+36], al

; 324  :             ll.buffer[28] = '*';
; 325  :         if ( MacroLevel ) {

	movzx	eax, BYTE PTR MacroLevel
	test	al, al
	je	SHORT $LN61@LstWrite

; 326  :             len = sprintf( &ll.buffer[29], "%u", MacroLevel );

	movzx	r8d, al
	lea	rdx, OFFSET FLAT:$SG11399
	lea	rcx, QWORD PTR ll$[rbp+37]
	call	sprintf

; 327  :             ll.buffer[29+len] = ' ';

	movsxd	rcx, eax
	mov	BYTE PTR ll$[rbp+rcx+37], bl
$LN61@LstWrite:

; 328  :         }
; 329  :         if ( srcfile != ModuleInfo.srcfile ) {

	movzx	eax, BYTE PTR ll$[rbp+38]
	mov	ecx, 67					; 00000043H
	cmp	r12d, DWORD PTR ModuleInfo+428
	cmovne	eax, ecx
	mov	BYTE PTR ll$[rbp+38], al
$LN62@LstWrite:

; 338  : #ifdef DEBUG_OUT
; 339  :         ll.buffer[idx] = NULLC;
; 340  : #endif
; 341  :     }
; 342  : #endif
; 343  :     fwrite( ll.buffer, 1, idx, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	lea	rcx, QWORD PTR ll$[rbp+8]
	movsxd	r8, ebx
	mov	edx, 1
	call	fwrite

; 344  : 
; 345  :     len = strlen( pSrcline );

	mov	rdx, r15
	npad	1
$LL91@LstWrite:
	inc	rdx
	cmp	BYTE PTR [rdi+rdx], 0
	jne	SHORT $LL91@LstWrite

; 346  :     len2 = ( ModuleInfo.CurrComment ? strlen( ModuleInfo.CurrComment ) : 0 );

	mov	r10, QWORD PTR ModuleInfo+472
	test	r10, r10
	je	$LN68@LstWrite
	npad	7
$LL90@LstWrite:
	inc	r15
	cmp	BYTE PTR [r10+r15], 0
	jne	SHORT $LL90@LstWrite
	jmp	$LN69@LstWrite
$LN42@LstWrite:

; 260  :     case LSTTYPE_EQUATE:
; 261  :         /* v2.10: display current offset if equate is an alias for a label in this segment */
; 262  :         idx = 1;
; 263  :         if ( sym->segment && sym->segment == &CurrSeg->sym ) {

	mov	rax, QWORD PTR [rbx+24]
	mov	ecx, 1
	test	rax, rax
	je	SHORT $LN43@LstWrite
	cmp	rax, QWORD PTR ModuleInfo+432
	jne	SHORT $LN43@LstWrite

; 264  :             sprintf( ll.buffer, "%08" I32_SPEC "X", GetCurrOffset() );

	call	GetCurrOffset
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG11375
	lea	rcx, QWORD PTR ll$[rbp+8]
	call	sprintf

; 265  :             idx = 10;

	mov	ecx, 10
$LN43@LstWrite:

; 266  :         }
; 267  :         ll.buffer[idx] = '=';

	movsxd	rax, ecx
	mov	BYTE PTR ll$[rbp+rax+8], 61		; 0000003dH

; 268  : #if AMD64_SUPPORT
; 269  :         if ( sym->value3264 != 0 && ( sym->value3264 != -1 || sym->value >= 0 ) )

	movsxd	rax, DWORD PTR [rbx+56]
	test	eax, eax
	je	SHORT $LN44@LstWrite
	cmp	eax, -1
	jne	SHORT $LN46@LstWrite
	cmp	DWORD PTR [rbx+16], 0
	jl	SHORT $LN44@LstWrite
$LN46@LstWrite:

; 270  :             sprintf( &ll.buffer[idx+2], "%-" PREFFMTSTR I64_SPEC "X", (uint_64)sym->value + ( (uint_64)sym->value3264 << 32 ) );

	mov	r8, rax
	lea	rdx, QWORD PTR ll$[rbp+8]
	movsxd	rax, DWORD PTR [rbx+16]
	shl	r8, 32					; 00000020H
	add	r8, rax
	lea	eax, DWORD PTR [rcx+2]
	movsxd	rcx, eax
	add	rcx, rdx
	lea	rdx, OFFSET FLAT:$SG11379
	call	sprintf

; 274  :         ll.buffer[28] = ' ';

	mov	BYTE PTR ll$[rbp+36], 32		; 00000020H

; 275  :         break;

	jmp	$LN120@LstWrite
$LN44@LstWrite:

; 271  :         else
; 272  : #endif
; 273  :             sprintf( &ll.buffer[idx+2], "%-" PREFFMTSTR I32_SPEC "X", sym->value );

	mov	r8d, DWORD PTR [rbx+16]
	lea	eax, DWORD PTR [rcx+2]
	movsxd	rcx, eax
	lea	rdx, QWORD PTR ll$[rbp+8]
	add	rcx, rdx
	lea	rdx, OFFSET FLAT:$SG11380
	call	sprintf

; 274  :         ll.buffer[28] = ' ';

	mov	BYTE PTR ll$[rbp+36], 32		; 00000020H

; 275  :         break;

	jmp	$LN120@LstWrite
$LN47@LstWrite:

; 276  :     case LSTTYPE_TMACRO:
; 277  :         ll.buffer[1] = '=';
; 278  :         //GetLiteralValue( buffer2, sym->string_ptr );
; 279  :         //strcpy( buffer2, sym->string_ptr );
; 280  :         for ( p1 = sym->string_ptr, p2 = &ll.buffer[3], pll = &ll; *p1; ) {

	mov	rdx, QWORD PTR [rbx+16]
	lea	rcx, QWORD PTR ll$[rbp+11]
	mov	BYTE PTR ll$[rbp+9], 61			; 0000003dH
	lea	r8, QWORD PTR ll$[rbp]
	cmp	BYTE PTR [rdx], 0
	je	$LN120@LstWrite
	xor	r9d, r9d
$LL12@LstWrite:

; 281  :             if ( p2 >= &pll->buffer[28] ) {

	lea	rax, QWORD PTR [r8+36]
	cmp	rcx, rax
	jb	SHORT $LN48@LstWrite

; 282  :                 struct lstleft *next = myalloca( sizeof( struct lstleft ) );

	mov	eax, DWORD PTR [rsp]
	sub	rsp, 48					; 00000030H
	lea	rcx, QWORD PTR [rsp+32]
	mov	eax, DWORD PTR [rcx]

; 283  :                 pll->next = next;

	mov	QWORD PTR [r8], rcx

; 284  :                 pll = next;

	mov	r8, rcx

; 285  :                 pll->next = NULL;

	mov	QWORD PTR [rcx], r9

; 286  :                 memset( pll->buffer, ' ', sizeof( pll->buffer) );

	mov	QWORD PTR [rcx+8], r13
	mov	QWORD PTR [rcx+16], r13
	mov	QWORD PTR [rcx+24], r13
	mov	QWORD PTR [rcx+32], r13

; 287  :                 p2 = &pll->buffer[3];

	add	rcx, 11
$LN48@LstWrite:

; 288  :             }
; 289  :             *p2++ = *p1++;

	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	mov	BYTE PTR [rcx], al
	inc	rcx
	cmp	BYTE PTR [rdx], r9b
	jne	SHORT $LL12@LstWrite

; 290  :         }
; 291  :         break;

	jmp	$LN120@LstWrite
$LN49@LstWrite:

; 292  :     case LSTTYPE_MACROLINE:
; 293  :         ll.buffer[1] = '>';

	mov	BYTE PTR ll$[rbp+9], 62			; 0000003eH

; 294  :         pSrcline = value;

	mov	rdi, rbx

; 295  :         break;

	jmp	$LN101@LstWrite
$LN50@LstWrite:

; 296  :     case LSTTYPE_LABEL:
; 297  :         oldofs = GetCurrOffset();

	call	GetCurrOffset
	mov	esi, eax
$LN51@LstWrite:

; 298  :         /* no break */
; 299  :     case LSTTYPE_STRUCT:
; 300  :         sprintf( ll.buffer, "%08" I32_SPEC "X", oldofs );

	mov	r8d, esi
	lea	rdx, OFFSET FLAT:$SG11386
	lea	rcx, QWORD PTR ll$[rbp+8]
	call	sprintf

; 301  :         ll.buffer[8] = ' ';

	mov	BYTE PTR ll$[rbp+16], 32		; 00000020H

; 302  :         break;

	jmp	$LN120@LstWrite
$LN52@LstWrite:

; 303  :     case LSTTYPE_DIRECTIVE:
; 304  :         if ( CurrSeg || value ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN54@LstWrite
	test	rbx, rbx
	je	$LN120@LstWrite
$LN54@LstWrite:

; 305  :             sprintf( ll.buffer, "%08" I32_SPEC "X", oldofs );

	mov	r8d, esi
	lea	rdx, OFFSET FLAT:$SG11390
	lea	rcx, QWORD PTR ll$[rbp+8]
	call	sprintf

; 306  :             ll.buffer[8] = ' ';

	mov	BYTE PTR ll$[rbp+16], 32		; 00000020H

; 307  :         }
; 308  :         break;

	jmp	$LN120@LstWrite
$LN55@LstWrite:

; 309  :     default: /* LSTTYPE_MACRO */
; 310  :         if ( *pSrcline == NULLC && ModuleInfo.CurrComment == NULL && srcfile == ModuleInfo.srcfile ) {

	cmp	BYTE PTR [rdi], 0
	jne	$LN120@LstWrite
	cmp	QWORD PTR ModuleInfo+472, 0
	jne	$LN120@LstWrite
	cmp	r12d, DWORD PTR ModuleInfo+428
	jne	$LN120@LstWrite

; 311  :             DebugMsg1(("LstWrite: type=%u, writing CRLF\n", type ));
; 312  :             fwrite( NLSTR, 1, NLSIZ, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	lea	rcx, OFFSET FLAT:$SG11393
	mov	edx, 1
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite

; 313  :             list_pos += NLSIZ;

	add	DWORD PTR list_pos, 2

; 314  :             return;

	jmp	$LN19@LstWrite
$LN68@LstWrite:

; 346  :     len2 = ( ModuleInfo.CurrComment ? strlen( ModuleInfo.CurrComment ) : 0 );

	xor	eax, eax
	mov	r15d, eax
$LN69@LstWrite:

; 347  : 
; 348  :     list_pos += sizeof( ll.buffer ) + len + len2 + NLSIZ;

	mov	eax, DWORD PTR list_pos
	lea	ecx, DWORD PTR [r15+rdx]
	add	eax, 34					; 00000022H
	add	ecx, eax

; 349  :     DebugMsg1(("LstWrite: writing (%u b) >%s< [%u/%u], new pos=%" I32_SPEC "u\n", idx, ll.buffer, len, len2, list_pos ));
; 350  : 
; 351  :     /* write source and comment part */
; 352  : #if FASTPASS
; 353  :     if ( Parse_Pass == PASS_1 || UseSavedState == FALSE ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	DWORD PTR list_pos, ecx
	je	SHORT $LN64@LstWrite
	cmp	BYTE PTR UseSavedState, 0
	jne	SHORT $LN63@LstWrite
$LN64@LstWrite:

; 354  : #endif
; 355  :         if ( len )

	test	edx, edx
	je	SHORT $LN65@LstWrite

; 356  :             fwrite( pSrcline, 1, len, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	mov	rcx, rdi
	movsxd	r8, edx
	mov	edx, 1
	call	fwrite
	mov	r10, QWORD PTR ModuleInfo+472
$LN65@LstWrite:

; 357  :         if ( len2 ) {

	test	r15d, r15d
	je	SHORT $LN66@LstWrite

; 358  :             fwrite( ModuleInfo.CurrComment, 1, len2, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	mov	edx, 1
	movsxd	r8, r15d
	mov	rcx, r10
	call	fwrite
$LN66@LstWrite:

; 359  :             DebugMsg1(("LstWrite: writing (%u b) >%s%s<\n", len + len2 + NLSIZ, pSrcline, ModuleInfo.CurrComment ));
; 360  :         }
; 361  : #ifdef DEBUG_OUT
; 362  :         else DebugMsg1(("LstWrite: writing (%u b) >%s<\n", len + NLSIZ, pSrcline ));
; 363  : #endif
; 364  :         fwrite( NLSTR, 1, NLSIZ, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	lea	rcx, OFFSET FLAT:$SG11405
	mov	edx, 1
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
$LN63@LstWrite:

; 365  : #if FASTPASS
; 366  :     }
; 367  : #endif
; 368  : 
; 369  :     /* write optional additional lines.
; 370  :      * currently works in pass one only.
; 371  :      */
; 372  :     for ( pll = ll.next; pll; pll = pll->next ) {

	mov	rbx, QWORD PTR ll$[rbp]
	test	rbx, rbx
	je	SHORT $LN19@LstWrite
	npad	14
$LL17@LstWrite:

; 373  :         fwrite( pll->buffer, 1, 32, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	lea	rcx, QWORD PTR [rbx+8]
	mov	edx, 1
	lea	r8d, QWORD PTR [rdx+31]
	call	fwrite

; 374  :         fwrite( NLSTR, 1, NLSIZ, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	lea	rcx, OFFSET FLAT:$SG11406
	mov	edx, 1
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite

; 375  :         list_pos += 32 + NLSIZ;

	add	DWORD PTR list_pos, 34			; 00000022H
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL17@LstWrite
$LN19@LstWrite:

; 376  :         DebugMsg1(("LstWrite: additional line >%s<, new pos=%" I32_SPEC "u\n", pll->buffer, list_pos ));
; 377  :     }
; 378  :     return;
; 379  : }

	mov	rbx, QWORD PTR [rbp+112]
	lea	rsp, QWORD PTR [rbp+48]
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN92@LstWrite:
	DD	$LN28@LstWrite
	DD	$LN29@LstWrite
	DD	$LN42@LstWrite
	DD	$LN47@LstWrite
	DD	$LN52@LstWrite
	DD	$LN55@LstWrite
	DD	$LN51@LstWrite
	DD	$LN50@LstWrite
	DD	$LN49@LstWrite
LstWrite ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
LstInit	PROC

; 1260 : {

$LN13:
	sub	rsp, 40					; 00000028H

; 1261 :     const struct fname_item *fn;
; 1262 :     const char *buffer;
; 1263 : 
; 1264 :     list_pos = 0;
; 1265 :     if( Options.write_listing ) {

	cmp	BYTE PTR Options+121, 0
	mov	DWORD PTR list_pos, 0
	je	$LN8@LstInit

; 1266 :         int namelen;
; 1267 :         buffer = MsgGetEx( MSG_HJWASM );

	mov	ecx, 2
	mov	QWORD PTR [rsp+32], rbx
	call	MsgGetEx

; 1268 :         list_pos = strlen( buffer );

	or	rbx, -1
	mov	rcx, rbx
$LL11@LstInit:
	inc	rcx
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL11@LstInit

; 1269 :         fwrite( buffer, 1, list_pos, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	mov	edx, 1
	mov	DWORD PTR list_pos, ecx
	mov	r8d, ecx
	mov	rcx, rax
	call	fwrite

; 1270 :         LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN5@LstInit
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN5@LstInit:

; 1271 :         fn = GetFName( ModuleInfo.srcfile );

	mov	ecx, DWORD PTR ModuleInfo+428
	call	GetFName

; 1272 :         namelen = strlen( fn->fname );

	mov	rcx, QWORD PTR [rax]
	npad	3
$LL10@LstInit:
	inc	rbx
	cmp	BYTE PTR [rcx+rbx], 0
	jne	SHORT $LL10@LstInit

; 1273 :         fwrite( fn->fname, 1, namelen, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	mov	edx, 1
	movsxd	r8, ebx
	call	fwrite

; 1274 :         list_pos += namelen;

	add	DWORD PTR list_pos, ebx

; 1275 :         LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	mov	rbx, QWORD PTR [rsp+32]
	test	r9, r9
	je	SHORT $LN8@LstInit
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11421
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN8@LstInit:

; 1276 :     }
; 1277 : 
; 1278 : }

	add	rsp, 40					; 00000028H
	ret	0
LstInit	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rdi, rcx

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rbx
	mov	QWORD PTR [rsp+40], rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], 0
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf
	test	eax, eax
	cmovs	eax, ebx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbx
	mov	r9, rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, rbx
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf

; 1459 :     #pragma warning(pop)
; 1460 : }

	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ebx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_Locale$ = 88
_ArgList$ = 96
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR _ArgList$[rsp]
	or	rcx, 1
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rbx
	call	__stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;
; 1391 : }

	mov	rbx, QWORD PTR [rsp+64]
	or	ecx, -1
	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ecx
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT vfprintf
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_ArgList$ = 80
vfprintf PROC						; COMDAT

; 652  : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r8
	mov	rdi, rdx
	mov	rsi, rcx

; 653  :     return _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 654  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
vfprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 640  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
