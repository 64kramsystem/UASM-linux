; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG11919 DB	01H DUP (?)
$SG11979 DB	01H DUP (?)
$SG11984 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
CONST	SEGMENT
szdrectve DB	'.drectve', 00H
	ORG $+7
isFeat00 DB	'@feat.00'
	DD	01H
	DW	0ffffH
	DW	00H
	DB	03H
	DB	00H
CONST	ENDS
_DATA	SEGMENT
$SG11412 DB	'.debug$S', 00H
	ORG $+7
$SG11413 DB	'.debug$T', 00H
	ORG $+3
$SG11488 DB	'/%u', 00H
$SG11501 DB	'CONST', 00H
	ORG $+2
$SG11628 DB	'.file', 00H
	ORG $+2
$SG11651 DB	'.file', 00H
	ORG $+2
$SG11664 DB	'.bf', 00H
$SG11669 DB	'.lf', 00H
$SG11671 DB	'.ef', 00H
	ORG $+4
$SG11928 DB	'-export:%s ', 00H
	ORG $+4
$SG11929 DB	'-export:%s=%s ', 00H
	ORG $+1
$SG11932 DB	'-defaultlib:"%s" ', 00H
	ORG $+6
$SG11933 DB	'-defaultlib:%s ', 00H
$SG11935 DB	'-entry:%s ', 00H
	ORG $+5
$SG11938 DB	'-import:', 00H
	ORG $+7
$SG11985 DB	'.sxdata', 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	sprintf
PUBLIC	coff_init
EXTRN	_time64:PROC
EXTRN	fseek:PROC
EXTRN	fwrite:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	strchr:PROC
EXTRN	strncpy:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	WriteError:PROC
EXTRN	ConvertSectionName:PROC
EXTRN	LclAlloc:PROC
EXTRN	Mangle:PROC
EXTRN	CreateIntSegment:PROC
EXTRN	GetSegIdx:PROC
EXTRN	AddPublicData:PROC
EXTRN	GetFName:PROC
EXTRN	cv_write_debug_tables:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	SymTables:BYTE
EXTRN	__ImageBase:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

CRC32Table DD	0100H DUP (?)
?init@?1??CRC32Comdat@@9@9 DB 01H DUP (?)		; `CRC32Comdat'::`2'::init
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN8
	DD	imagerel $LN8+90
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Coff_AllocString DD imagerel Coff_AllocString
	DD	imagerel Coff_AllocString+121
	DD	imagerel $unwind$Coff_AllocString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$coff_write_section_table DD imagerel coff_write_section_table
	DD	imagerel coff_write_section_table+57
	DD	imagerel $unwind$coff_write_section_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$coff_write_section_table DD imagerel coff_write_section_table+57
	DD	imagerel coff_write_section_table+907
	DD	imagerel $chain$3$coff_write_section_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$coff_write_section_table DD imagerel coff_write_section_table+907
	DD	imagerel coff_write_section_table+923
	DD	imagerel $chain$4$coff_write_section_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetFileAuxEntries DD imagerel GetFileAuxEntries
	DD	imagerel GetFileAuxEntries+90
	DD	imagerel $unwind$GetFileAuxEntries
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CRC32Comdat DD imagerel CRC32Comdat
	DD	imagerel CRC32Comdat+110
	DD	imagerel $unwind$CRC32Comdat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$coff_write_symbols DD imagerel coff_write_symbols
	DD	imagerel coff_write_symbols+2919
	DD	imagerel $unwind$coff_write_symbols
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetStartLabel DD imagerel GetStartLabel
	DD	imagerel GetStartLabel+306
	DD	imagerel $unwind$GetStartLabel
pdata	ENDS
pdata	SEGMENT
$pdata$coff_flushfunc DD imagerel coff_flushfunc
	DD	imagerel coff_flushfunc+51
	DD	imagerel $unwind$coff_flushfunc
$pdata$2$coff_flushfunc DD imagerel coff_flushfunc+51
	DD	imagerel coff_flushfunc+140
	DD	imagerel $chain$2$coff_flushfunc
$pdata$3$coff_flushfunc DD imagerel coff_flushfunc+140
	DD	imagerel coff_flushfunc+188
	DD	imagerel $chain$3$coff_flushfunc
$pdata$4$coff_flushfunc DD imagerel coff_flushfunc+188
	DD	imagerel coff_flushfunc+219
	DD	imagerel $chain$4$coff_flushfunc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetSymbolIndices DD imagerel SetSymbolIndices
	DD	imagerel SetSymbolIndices+287
	DD	imagerel $unwind$SetSymbolIndices
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$SetSymbolIndices DD imagerel SetSymbolIndices+287
	DD	imagerel SetSymbolIndices+468
	DD	imagerel $chain$1$SetSymbolIndices
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$SetSymbolIndices DD imagerel SetSymbolIndices+468
	DD	imagerel SetSymbolIndices+487
	DD	imagerel $chain$2$SetSymbolIndices
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$coff_write_fixups DD imagerel coff_write_fixups
	DD	imagerel coff_write_fixups+139
	DD	imagerel $unwind$coff_write_fixups
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$coff_write_fixups DD imagerel coff_write_fixups+139
	DD	imagerel coff_write_fixups+529
	DD	imagerel $chain$0$coff_write_fixups
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$coff_write_fixups DD imagerel coff_write_fixups+529
	DD	imagerel coff_write_fixups+664
	DD	imagerel $chain$1$coff_write_fixups
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$coff_write_data DD imagerel coff_write_data
	DD	imagerel coff_write_data+163
	DD	imagerel $unwind$coff_write_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$coff_write_data DD imagerel coff_write_data+163
	DD	imagerel coff_write_data+694
	DD	imagerel $chain$2$coff_write_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$coff_write_data DD imagerel coff_write_data+694
	DD	imagerel coff_write_data+712
	DD	imagerel $chain$3$coff_write_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$coff_create_drectve DD imagerel coff_create_drectve
	DD	imagerel coff_create_drectve+220
	DD	imagerel $unwind$coff_create_drectve
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$coff_create_drectve DD imagerel coff_create_drectve+220
	DD	imagerel coff_create_drectve+231
	DD	imagerel $chain$0$coff_create_drectve
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$coff_create_drectve DD imagerel coff_create_drectve+231
	DD	imagerel coff_create_drectve+751
	DD	imagerel $chain$1$coff_create_drectve
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$coff_create_drectve DD imagerel coff_create_drectve+751
	DD	imagerel coff_create_drectve+1194
	DD	imagerel $chain$2$coff_create_drectve
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$coff_create_drectve DD imagerel coff_create_drectve+1194
	DD	imagerel coff_create_drectve+1219
	DD	imagerel $chain$3$coff_create_drectve
pdata	ENDS
pdata	SEGMENT
$pdata$coff_write_module DD imagerel coff_write_module
	DD	imagerel coff_write_module+15
	DD	imagerel $unwind$coff_write_module
$pdata$1$coff_write_module DD imagerel coff_write_module+15
	DD	imagerel coff_write_module+25
	DD	imagerel $chain$1$coff_write_module
$pdata$2$coff_write_module DD imagerel coff_write_module+25
	DD	imagerel coff_write_module+29
	DD	imagerel $chain$2$coff_write_module
$pdata$3$coff_write_module DD imagerel coff_write_module+29
	DD	imagerel coff_write_module+83
	DD	imagerel $chain$3$coff_write_module
$pdata$4$coff_write_module DD imagerel coff_write_module+83
	DD	imagerel coff_write_module+95
	DD	imagerel $chain$4$coff_write_module
$pdata$6$coff_write_module DD imagerel coff_write_module+95
	DD	imagerel coff_write_module+252
	DD	imagerel $chain$6$coff_write_module
$pdata$7$coff_write_module DD imagerel coff_write_module+252
	DD	imagerel coff_write_module+392
	DD	imagerel $chain$7$coff_write_module
$pdata$8$coff_write_module DD imagerel coff_write_module+392
	DD	imagerel coff_write_module+635
	DD	imagerel $chain$8$coff_write_module
$pdata$9$coff_write_module DD imagerel coff_write_module+635
	DD	imagerel coff_write_module+689
	DD	imagerel $chain$9$coff_write_module
$pdata$10$coff_write_module DD imagerel coff_write_module+689
	DD	imagerel coff_write_module+836
	DD	imagerel $chain$10$coff_write_module
$pdata$11$coff_write_module DD imagerel coff_write_module+836
	DD	imagerel coff_write_module+852
	DD	imagerel $chain$11$coff_write_module
pdata	ENDS
CONST	SEGMENT
	ORG $+6
SymDebName DQ	FLAT:$SG11412
	DQ	FLAT:$SG11413
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$coff_create_drectve DD 021H
	DD	imagerel coff_create_drectve
	DD	imagerel coff_create_drectve+220
	DD	imagerel $unwind$coff_create_drectve
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$coff_create_drectve DD 021H
	DD	imagerel coff_create_drectve+220
	DD	imagerel coff_create_drectve+231
	DD	imagerel $chain$0$coff_create_drectve
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$coff_create_drectve DD 020821H
	DD	04be408H
	DD	imagerel coff_create_drectve+220
	DD	imagerel coff_create_drectve+231
	DD	imagerel $chain$0$coff_create_drectve
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$coff_create_drectve DD 020821H
	DD	04a3408H
	DD	imagerel coff_create_drectve
	DD	imagerel coff_create_drectve+220
	DD	imagerel $unwind$coff_create_drectve
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$coff_create_drectve DD 091601H
	DD	04d6416H
	DD	04c5416H
	DD	0460116H
	DD	0c00df00fH
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$coff_write_data DD 021H
	DD	imagerel coff_write_data
	DD	imagerel coff_write_data+163
	DD	imagerel $unwind$coff_write_data
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$coff_write_data DD 061521H
	DD	04e415H
	DD	05d40aH
	DD	0f5405H
	DD	imagerel coff_write_data
	DD	imagerel coff_write_data+163
	DD	imagerel $unwind$coff_write_data
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$coff_write_data DD 060c01H
	DD	0f008520cH
	DD	07004c006H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$coff_write_fixups DD 021H
	DD	imagerel coff_write_fixups
	DD	imagerel coff_write_fixups+139
	DD	imagerel $unwind$coff_write_fixups
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$coff_write_fixups DD 020521H
	DD	0ec405H
	DD	imagerel coff_write_fixups
	DD	imagerel coff_write_fixups+139
	DD	imagerel $unwind$coff_write_fixups
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$coff_write_fixups DD 081801H
	DD	0f0145218H
	DD	0d010e012H
	DD	0600d700eH
	DD	0300b500cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$SetSymbolIndices DD 021H
	DD	imagerel SetSymbolIndices
	DD	imagerel SetSymbolIndices+287
	DD	imagerel $unwind$SetSymbolIndices
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$SetSymbolIndices DD 020521H
	DD	0ce405H
	DD	imagerel SetSymbolIndices
	DD	imagerel SetSymbolIndices+287
	DD	imagerel $unwind$SetSymbolIndices
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetSymbolIndices DD 08da01H
	DD	0b74daH
	DD	0f008320cH
	DD	06004d006H
	DD	030025003H
xdata	ENDS
xdata	SEGMENT
$unwind$coff_flushfunc DD 040a01H
	DD	0f006320aH
	DD	05002e004H
$chain$2$coff_flushfunc DD 061321H
	DD	0a7413H
	DD	09640eH
	DD	083405H
	DD	imagerel coff_flushfunc
	DD	imagerel coff_flushfunc+51
	DD	imagerel $unwind$coff_flushfunc
$chain$3$coff_flushfunc DD 020021H
	DD	096400H
	DD	imagerel coff_flushfunc
	DD	imagerel coff_flushfunc+51
	DD	imagerel $unwind$coff_flushfunc
$chain$4$coff_flushfunc DD 021H
	DD	imagerel coff_flushfunc
	DD	imagerel coff_flushfunc+51
	DD	imagerel $unwind$coff_flushfunc
$unwind$coff_write_module DD 030f01H
	DD	01e010fH
	DD	05004H
$chain$1$coff_write_module DD 040a21H
	DD	022740aH
	DD	0203404H
	DD	imagerel coff_write_module
	DD	imagerel coff_write_module+15
	DD	imagerel $unwind$coff_write_module
$chain$2$coff_write_module DD 020421H
	DD	01dc404H
	DD	imagerel coff_write_module+15
	DD	imagerel coff_write_module+25
	DD	imagerel $chain$1$coff_write_module
$chain$3$coff_write_module DD 020421H
	DD	01af404H
	DD	imagerel coff_write_module+25
	DD	imagerel coff_write_module+29
	DD	imagerel $chain$2$coff_write_module
$chain$4$coff_write_module DD 020821H
	DD	0216408H
	DD	imagerel coff_write_module+29
	DD	imagerel coff_write_module+83
	DD	imagerel $chain$3$coff_write_module
$chain$6$coff_write_module DD 041721H
	DD	01be417H
	DD	01cd408H
	DD	imagerel coff_write_module+83
	DD	imagerel coff_write_module+95
	DD	imagerel $chain$4$coff_write_module
$chain$7$coff_write_module DD 020021H
	DD	01be400H
	DD	imagerel coff_write_module+83
	DD	imagerel coff_write_module+95
	DD	imagerel $chain$4$coff_write_module
$chain$8$coff_write_module DD 021H
	DD	imagerel coff_write_module+29
	DD	imagerel coff_write_module+83
	DD	imagerel $chain$3$coff_write_module
$chain$9$coff_write_module DD 021H
	DD	imagerel coff_write_module+25
	DD	imagerel coff_write_module+29
	DD	imagerel $chain$2$coff_write_module
$chain$10$coff_write_module DD 021H
	DD	imagerel coff_write_module+15
	DD	imagerel coff_write_module+25
	DD	imagerel $chain$1$coff_write_module
$chain$11$coff_write_module DD 021H
	DD	imagerel coff_write_module
	DD	imagerel coff_write_module+15
	DD	imagerel $unwind$coff_write_module
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetStartLabel DD 050d01H
	DD	026340dH
	DD	024010dH
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$coff_write_symbols DD 0b1c01H
	DD	032341cH
	DD	02a011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CRC32Comdat DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetFileAuxEntries DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$coff_write_section_table DD 021H
	DD	imagerel coff_write_section_table
	DD	imagerel coff_write_section_table+57
	DD	imagerel $unwind$coff_write_section_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$coff_write_section_table DD 081321H
	DD	02ad413H
	DD	033c40cH
	DD	0326408H
	DD	0313404H
	DD	imagerel coff_write_section_table
	DD	imagerel coff_write_section_table+57
	DD	imagerel $unwind$coff_write_section_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$coff_write_section_table DD 061401H
	DD	02b0114H
	DD	0e007f009H
	DD	050047005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Coff_AllocString DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
ifh$ = 48
cm$ = 80
modinfo$ = 256
coff_write_module PROC

; 1359 : {

	mov	rax, rsp
	push	rbp
	lea	rbp, QWORD PTR [rax-95]
	sub	rsp, 240				; 000000f0H
	mov	QWORD PTR [rax+8], rbx

; 1360 :     struct stringitem  *pName;
; 1361 :     struct coffmod cm;
; 1362 :     struct IMAGE_FILE_HEADER ifh;
; 1363 : 
; 1364 :     DebugMsg(("coff_write_module: enter, sections=%u\n", modinfo->g.num_segs ));
; 1365 : 
; 1366 :     memset( &cm, 0, sizeof( cm ) );

	xor	edx, edx
	mov	QWORD PTR [rax+24], rdi
	mov	QWORD PTR [rax-16], r12
	mov	QWORD PTR [rax-40], r15
	mov	r15, rcx
	lea	r8d, QWORD PTR [rdx+120]
	lea	rcx, QWORD PTR cm$[rbp-153]
	call	memset

; 1367 :     //directives = NULL;
; 1368 :     //LongNames.head = NULL;
; 1369 :     cm.LongNames.size = sizeof( uint_32 );
; 1370 : 
; 1371 :     /* get value for .file symbol */
; 1372 :     cm.dot_file_value = CurrFName[ASM];

	mov	rax, QWORD PTR ModuleInfo+128

; 1373 : #if 0 /* v2.09: always add the name in CurrFName[ASM] */
; 1374 :     cm.dot_file_value += strlen( dot_file_value );
; 1375 :     while ( cm.dot_file_value > CurrFName[ASM] &&
; 1376 :            *(cm.dot_file_value-1) != '/' &&
; 1377 :            *(cm.dot_file_value-1) != '\\') cm.dot_file_value--;
; 1378 : #endif
; 1379 : 
; 1380 :     /* it might be necessary to add "internal" sections:
; 1381 :      * - .debug$S and .debug$T sections if -Zi was set
; 1382 :      * - .sxdata section if .SAFESEH was used
; 1383 :      * - .drectve section if start label, exports or includelibs are used
; 1384 :      */
; 1385 : 
; 1386 :     /* if -Zi is set, add .debug$S and .debug$T sections */
; 1387 :     if ( Options.debug_symbols ) {

	xor	r12d, r12d
	cmp	BYTE PTR Options+2, r12b
	mov	QWORD PTR cm$[rbp-129], rax
	mov	DWORD PTR cm$[rbp-41], 4
	je	$LN6@coff_write

; 1388 :         int i;
; 1389 :         for ( i = 0; i < DBGS_MAX; i++ ) {

	mov	QWORD PTR [rsp+264], rsi
	lea	rbx, QWORD PTR cm$[rbp-105]
	mov	QWORD PTR [rsp+224], r13
	lea	rsi, OFFSET FLAT:SymDebName
	mov	QWORD PTR [rsp+216], r14
	lea	r13, OFFSET FLAT:coff_flushfunc
	mov	r14d, r12d
	mov	edi, r12d
$LL4@coff_write:

; 1390 :             if ( NULL == ( cm.SymDeb[i].seg = (struct dsym *)CreateIntSegment( SymDebName[i], "", 0, USE32, TRUE ) ) )

	mov	rcx, QWORD PTR [rsi]
	lea	rdx, OFFSET FLAT:$SG11979
	mov	r9b, 1
	mov	BYTE PTR [rsp+32], 1
	xor	r8d, r8d
	call	CreateIntSegment
	mov	QWORD PTR [rbx], rax
	test	rax, rax
	je	SHORT $LN38@coff_write

; 1391 :                 break;
; 1392 :             DebugMsg(("coff_write_module: %s section added\n", SymDebName[i] ));
; 1393 :             cm.SymDeb[i].seg->e.seginfo->characteristics = (IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE) >> 24;

	mov	rax, QWORD PTR [rax+96]
	inc	r14d

; 1394 :             /* use the source line buffer as code buffer. It isn't needed anymore */
; 1395 :             cm.SymDeb[i].seg->e.seginfo->CodeBuffer = CurrSource + i * SIZE_CV_SEGBUF;

	movsxd	rdx, edi
	add	rsi, 8
	add	edi, 1200				; 000004b0H
	mov	BYTE PTR [rax+105], 66			; 00000042H
	mov	rax, QWORD PTR [rbx]
	add	rdx, QWORD PTR ModuleInfo+464
	mov	rcx, QWORD PTR [rax+96]
	mov	QWORD PTR [rcx+16], rdx

; 1396 :             cm.SymDeb[i].seg->e.seginfo->flushfunc = coff_flushfunc;

	mov	rax, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rax+96]
	mov	QWORD PTR [rcx+32], r13

; 1397 :             cm.SymDeb[i].q.head = NULL;

	mov	QWORD PTR [rbx+8], r12
	add	rbx, 24
	cmp	edi, 2400				; 00000960H
	jl	SHORT $LL4@coff_write
$LN38@coff_write:
	mov	r13, QWORD PTR [rsp+224]

; 1398 :         }
; 1399 :         if ( i == DBGS_MAX ) {

	cmp	r14d, 2
	jne	$LN57@coff_write

; 1400 :             cv_write_debug_tables( cm.SymDeb[DBGS_SYMBOLS].seg, cm.SymDeb[DBGS_TYPES].seg, &cm );

	mov	rdx, QWORD PTR cm$[rbp-81]
	lea	r8, QWORD PTR cm$[rbp-153]
	mov	rcx, QWORD PTR cm$[rbp-105]
	call	cv_write_debug_tables
	lea	rsi, QWORD PTR cm$[rbp-105]
	mov	r14d, 2
	npad	9
$LL7@coff_write:

; 1405 :                 uint_8 *src;
; 1406 :                 uint_8 *dst;
; 1407 :                 if ( cm.SymDeb[i].seg->sym.max_offset ) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+56]
	test	ecx, ecx
	je	SHORT $LN5@coff_write

; 1408 :                     cm.SymDeb[i].seg->e.seginfo->CodeBuffer = LclAlloc( cm.SymDeb[i].seg->sym.max_offset );

	call	LclAlloc
	mov	rcx, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rdx+16], rax

; 1409 :                     dst = cm.SymDeb[i].seg->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [rsi]

; 1410 :                     for ( src = cm.SymDeb[i].q.head; src; src = ((struct qditem *)src)->next ) {

	mov	rbx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rax+96]
	mov	rdi, QWORD PTR [rcx+16]
	test	rbx, rbx
	je	SHORT $LN5@coff_write
	npad	1
$LL10@coff_write:

; 1411 :                         memcpy( dst, src + sizeof( struct qditem ), ((struct qditem *)src)->size );

	mov	r8d, DWORD PTR [rbx+8]
	lea	rdx, QWORD PTR [rbx+16]
	mov	rcx, rdi
	call	memcpy

; 1412 :                         dst += ((struct qditem *)src)->size;

	mov	eax, DWORD PTR [rbx+8]
	mov	rbx, QWORD PTR [rbx]
	add	rdi, rax
	test	rbx, rbx
	jne	SHORT $LL10@coff_write
$LN5@coff_write:

; 1401 :             /* the contents have been written in queues. now
; 1402 :              * copy all queue items in ONE buffer.
; 1403 :              */
; 1404 :             for ( i = 0; i < DBGS_MAX; i++ ) {

	add	rsi, 24
	sub	r14, 1
	jne	SHORT $LL7@coff_write
$LN57@coff_write:
	mov	rsi, QWORD PTR [rsp+264]
	mov	r14, QWORD PTR [rsp+216]
$LN6@coff_write:

; 1413 :                         /* fixme: free the queue items if FASTMEM==0 */
; 1414 :                     }
; 1415 :                 }
; 1416 :             }
; 1417 :         }
; 1418 :     }
; 1419 : 
; 1420 :     /* if safeSEH procs are defined, add a .sxdata section */
; 1421 :     if ( modinfo->g.SafeSEHQueue.head ) {

	cmp	QWORD PTR [r15+48], r12
	je	SHORT $LN22@coff_write

; 1422 :         struct qnode *sehp;
; 1423 :         unsigned cnt = 0;
; 1424 :         if ( cm.sxdata = (struct dsym *)CreateIntSegment( ".sxdata", "", MAX_SEGALIGNMENT, modinfo->Ofssize, FALSE ) ) {

	movzx	r9d, BYTE PTR [r15+404]
	lea	rdx, OFFSET FLAT:$SG11984
	mov	ebx, r12d
	lea	rcx, OFFSET FLAT:$SG11985
	mov	r8b, 255				; 000000ffH
	mov	BYTE PTR [rsp+32], bl
	call	CreateIntSegment
	mov	QWORD PTR cm$[rbp-145], rax
	test	rax, rax
	je	SHORT $LN22@coff_write

; 1425 :             cm.sxdata->e.seginfo->info = TRUE;

	mov	rax, QWORD PTR [rax+96]
	or	BYTE PTR [rax+107], 2

; 1426 :             /* calc the size for this segment */
; 1427 :             for( sehp = modinfo->g.SafeSEHQueue.head; sehp ; sehp = sehp->next, cnt++ );

	mov	rax, QWORD PTR [r15+48]
	test	rax, rax
	je	SHORT $LN12@coff_write
	npad	3
$LL13@coff_write:
	mov	rax, QWORD PTR [rax]
	inc	ebx
	test	rax, rax
	jne	SHORT $LL13@coff_write
$LN12@coff_write:

; 1428 :             cm.sxdata->sym.max_offset = cnt*4;

	mov	rax, QWORD PTR cm$[rbp-145]
	lea	ecx, DWORD PTR [rbx*4]
	mov	DWORD PTR [rax+56], ecx

; 1429 :             cm.sxdata->e.seginfo->CodeBuffer = LclAlloc( cnt*4 );

	call	LclAlloc
	mov	rcx, QWORD PTR cm$[rbp-145]
	mov	rdx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rdx+16], rax
$LN22@coff_write:

; 1430 :             DebugMsg(("coff_write_module: .sxdata section added, size=%u\n", cnt*4));
; 1431 :         }
; 1432 :     }
; 1433 : 
; 1434 :     /* create .drectve section if necessary */
; 1435 :     coff_create_drectve( modinfo, &cm );

	lea	rdx, QWORD PTR cm$[rbp-153]
	mov	rcx, r15
	call	coff_create_drectve

; 1436 : 
; 1437 :     /* v2.11: removed, max_offset has been set already */
; 1438 :     //if ( directives )
; 1439 :     //    directives->sym.max_offset = size_drectve;
; 1440 : 
; 1441 : #if AMD64_SUPPORT
; 1442 :     if ( modinfo->defOfssize == USE64 )

	cmp	BYTE PTR [r15+405], 2

; 1443 :         ifh.Machine = IMAGE_FILE_MACHINE_AMD64;

	mov	ecx, 34404				; 00008664H

; 1444 :     else
; 1445 : #endif
; 1446 :         ifh.Machine = IMAGE_FILE_MACHINE_I386;

	mov	eax, 332				; 0000014cH
	cmove	ax, cx

; 1447 :     ifh.NumberOfSections = modinfo->g.num_segs;
; 1448 : #if 0 //def __UNIX__
; 1449 :     time((int_32 *)&ifh.TimeDateStamp);
; 1450 : #else
; 1451 :     time((time_t *)&ifh.TimeDateStamp);

	lea	rcx, QWORD PTR ifh$[rbp-149]
	mov	WORD PTR ifh$[rbp-153], ax
	movzx	eax, WORD PTR [r15+8]
	mov	WORD PTR ifh$[rbp-151], ax
	call	_time64

; 1452 : #endif
; 1453 :     ifh.SizeOfOptionalHeader = 0;
; 1454 :     ifh.Characteristics = 0;
; 1455 : 
; 1456 :     /* position behind coff file header */
; 1457 :     fseek( CurrFile[OBJ], sizeof( ifh ), SEEK_SET );

	mov	rcx, QWORD PTR ModuleInfo+104
	xor	r8d, r8d
	mov	DWORD PTR ifh$[rbp-137], r12d
	lea	edx, QWORD PTR [r8+20]
	call	fseek

; 1458 : 
; 1459 :     coff_write_section_table( modinfo, &cm );

	lea	rdx, QWORD PTR cm$[rbp-153]
	mov	rcx, r15
	call	coff_write_section_table

; 1460 :     coff_write_data( modinfo, &cm );

	lea	rdx, QWORD PTR cm$[rbp-153]
	mov	rcx, r15
	call	coff_write_data

; 1461 :     /* v2.12: check that calculated sizes are identical to those that have been written */
; 1462 :     /*myassert( cm.start_symtab == ( cm.start_data + cm.size_data ) );*/
; 1463 : 
; 1464 :     ifh.NumberOfSymbols = coff_write_symbols( modinfo, &cm );

	lea	rdx, QWORD PTR cm$[rbp-153]
	mov	rcx, r15
	call	coff_write_symbols
	mov	r15, QWORD PTR [rsp+208]
	mov	DWORD PTR ifh$[rbp-141], eax

; 1465 :     ifh.PointerToSymbolTable = ( ifh.NumberOfSymbols ? cm.start_data + cm.size_data : 0 );

	test	eax, eax
	je	SHORT $LN29@coff_write
	mov	ecx, DWORD PTR cm$[rbp-121]
	add	ecx, DWORD PTR cm$[rbp-117]
	mov	DWORD PTR ifh$[rbp-145], ecx
	jmp	SHORT $LN30@coff_write
$LN29@coff_write:
	mov	DWORD PTR ifh$[rbp-145], r12d
$LN30@coff_write:

; 1466 : 
; 1467 :     /* the string table is ALWAYS written, even if no strings are defined */
; 1468 :     DebugMsg(("coff_write_module: string_table size=%u\n", cm.LongNames.size ));
; 1469 :     if ( fwrite( &cm.LongNames.size, 1, sizeof( cm.LongNames.size ), CurrFile[OBJ] ) != sizeof( cm.LongNames.size ) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR cm$[rbp-41]
	mov	edx, 1
	lea	r8d, QWORD PTR [rdx+3]
	call	fwrite
	mov	r12, QWORD PTR [rsp+232]
	cmp	rax, 4
	je	SHORT $LN25@coff_write

; 1470 :         WriteError();

	call	WriteError
$LN25@coff_write:

; 1471 :     for ( pName = cm.LongNames.head; pName; pName = pName->next ) {

	mov	rdi, QWORD PTR cm$[rbp-57]
	test	rdi, rdi
	je	SHORT $LN15@coff_write
	npad	1
$LL16@coff_write:

; 1472 :         int i = strlen( pName->string ) + 1;

	lea	rcx, QWORD PTR [rdi+8]
	or	rax, -1
	npad	8
$LL54@coff_write:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL54@coff_write

; 1473 :         if ( fwrite( pName->string, 1, i, CurrFile[OBJ] ) != i )

	mov	r9, QWORD PTR ModuleInfo+104
	inc	eax
	movsxd	rbx, eax
	mov	edx, 1
	mov	r8, rbx
	call	fwrite
	cmp	rax, rbx
	je	SHORT $LN14@coff_write

; 1474 :             WriteError();

	call	WriteError
$LN14@coff_write:

; 1471 :     for ( pName = cm.LongNames.head; pName; pName = pName->next ) {

	mov	rdi, QWORD PTR [rdi]
	test	rdi, rdi
	jne	SHORT $LL16@coff_write
$LN15@coff_write:

; 1475 :     }
; 1476 : #if FASTMEM==0
; 1477 :     for ( ; cm.LongNames.head; ) {
; 1478 :         pName = cm.LongNames.head;
; 1479 :         cm.LongNames.head = cm.LongNames.head->next;
; 1480 :         LclFree( pName );
; 1481 :     }
; 1482 : #endif
; 1483 :     /* finally write the COFF file header */
; 1484 :     fseek( CurrFile[OBJ], 0, SEEK_SET);

	mov	rcx, QWORD PTR ModuleInfo+104
	xor	r8d, r8d
	xor	edx, edx
	call	fseek

; 1485 :     if ( fwrite( &ifh, 1, sizeof( ifh ), CurrFile[OBJ] ) != sizeof( ifh ) ) {

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR ifh$[rbp-153]
	mov	edx, 1
	lea	r8d, QWORD PTR [rdx+19]
	call	fwrite
	mov	rdi, QWORD PTR [rsp+272]
	mov	rbx, QWORD PTR [rsp+256]
	cmp	rax, 20
	je	SHORT $LN55@coff_write

; 1486 :         DebugMsg(("coff_write_module: error writing file header\n"));
; 1487 :         WriteError();

	call	WriteError
$LN55@coff_write:

; 1488 :     }
; 1489 : 
; 1490 :     DebugMsg(("coff_write_module: exit\n"));
; 1491 :     return( NOT_ERROR );

	xor	eax, eax

; 1492 : }

	add	rsp, 240				; 000000f0H
	pop	rbp
	ret	0
coff_write_module ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
;	COMDAT coff_create_drectve
_TEXT	SEGMENT
buffer$ = 48
temp$1 = 304
modinfo$ = 592
cm$ = 600
coff_create_drectve PROC				; COMDAT

; 1221 : {

	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r15
	sub	rsp, 560				; 00000230H

; 1222 :     struct dsym *exp;
; 1223 : #if DLLIMPORT
; 1224 :     struct dsym *imp = NULL;
; 1225 : #endif
; 1226 :     char buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 1227 : 
; 1228 :     /* does a proc exist with the EXPORT attribute? */
; 1229 :     for( exp = SymTables[TAB_PROC].head; exp != NULL; exp = exp->nextproc ) {

	mov	rbp, QWORD PTR SymTables+64
	xor	esi, esi
	mov	r12, rdx
	mov	r15, rcx
	mov	edi, esi
	test	rbp, rbp
	je	SHORT $LN120@coff_creat
	npad	4
$LL4@coff_creat:

; 1230 :         if( exp->e.procinfo->isexport )

	mov	rax, QWORD PTR [rbp+96]
	test	BYTE PTR [rax+84], 4
	jne	SHORT $LN120@coff_creat

; 1222 :     struct dsym *exp;
; 1223 : #if DLLIMPORT
; 1224 :     struct dsym *imp = NULL;
; 1225 : #endif
; 1226 :     char buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 1227 : 
; 1228 :     /* does a proc exist with the EXPORT attribute? */
; 1229 :     for( exp = SymTables[TAB_PROC].head; exp != NULL; exp = exp->nextproc ) {

	mov	rbp, QWORD PTR [rbp+112]
	test	rbp, rbp
	jne	SHORT $LL4@coff_creat
$LN120@coff_creat:

; 1231 :             break;
; 1232 :     }
; 1233 : #if DLLIMPORT
; 1234 :     /* check if an impdef record is there */
; 1235 :     if ( Options.write_impdef && !Options.names[OPTN_LNKDEF_FN] )

	cmp	BYTE PTR Options+122, sil
	je	SHORT $LN121@coff_creat
	cmp	QWORD PTR Options+48, rsi
	jne	SHORT $LN121@coff_creat

; 1236 :         for ( imp = SymTables[TAB_EXT].head; imp; imp = imp->next )

	mov	rdi, QWORD PTR SymTables+16
	test	rdi, rdi
	je	SHORT $LN121@coff_creat
$LL7@coff_creat:

; 1237 :             if ( imp->sym.isproc && ( imp->sym.weak == FALSE || imp->sym.iat_used == TRUE ) )

	test	BYTE PTR [rdi+41], 8
	je	SHORT $LN5@coff_creat
	test	BYTE PTR [rdi+47], 8
	je	SHORT $LN29@coff_creat
	test	BYTE PTR [rdi+40], 8
	je	SHORT $LN5@coff_creat
$LN29@coff_creat:

; 1238 :                 if ( imp->sym.dll && *imp->sym.dll->name )

	mov	rax, QWORD PTR [rdi+56]
	test	rax, rax
	je	SHORT $LN5@coff_creat
	cmp	BYTE PTR [rax+12], sil
	jne	SHORT $LN121@coff_creat
$LN5@coff_creat:

; 1236 :         for ( imp = SymTables[TAB_EXT].head; imp; imp = imp->next )

	mov	rdi, QWORD PTR [rdi+104]
	test	rdi, rdi
	jne	SHORT $LL7@coff_creat
$LN121@coff_creat:

; 1239 :                     break;
; 1240 : #endif
; 1241 :     /* add a .drectve section if
; 1242 :      - a start_label is defined    and/or
; 1243 :      - a library is included       and/or
; 1244 :      - a proc is exported          and/or
; 1245 :      - impdefs are to be written (-Zd)
; 1246 :      */
; 1247 :     if ( modinfo->g.start_label != NULL ||
; 1248 :         modinfo->g.LibQueue.head != NULL ||
; 1249 : #if DLLIMPORT
; 1250 :         imp != NULL ||

	cmp	QWORD PTR [rcx+208], rsi
	jne	SHORT $LN32@coff_creat
	cmp	QWORD PTR [rcx+64], rsi
	jne	SHORT $LN32@coff_creat
	test	rdi, rdi
	jne	SHORT $LN32@coff_creat
	test	rbp, rbp
	je	$LN24@coff_creat
$LN32@coff_creat:

; 1251 : #endif
; 1252 :         exp != NULL ) {
; 1253 :         if ( cm->directives = (struct dsym *)CreateIntSegment( szdrectve, "", MAX_SEGALIGNMENT, modinfo->Ofssize, FALSE ) ) {

	movzx	r9d, BYTE PTR [rcx+404]
	lea	rdx, OFFSET FLAT:$SG11919
	lea	rcx, OFFSET FLAT:szdrectve
	mov	BYTE PTR [rsp+32], sil
	mov	r8b, 255				; 000000ffH
	call	CreateIntSegment
	mov	QWORD PTR [r12], rax
	test	rax, rax
	je	$LN24@coff_creat

; 1254 :             struct dsym *tmp;
; 1255 :             int size = 0;
; 1256 :             struct qitem *q;
; 1257 :             uint_8 *p;
; 1258 :             cm->directives->e.seginfo->info = TRUE;

	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rsp+592], rbx

; 1259 :             DebugMsg(("coff_create_drectve: %s section added\n", szdrectve));
; 1260 : 
; 1261 :             /* calc the size for this segment */
; 1262 :             /* 1. exports */
; 1263 :             for( tmp = exp; tmp ; tmp = tmp->nextproc ) {

	mov	rbx, rbp
	mov	QWORD PTR [rsp+600], r14
	mov	r14d, esi
	or	BYTE PTR [rax+107], 2
	test	rbp, rbp
	je	SHORT $LN9@coff_creat
	npad	5
$LL10@coff_creat:

; 1264 :                 if( tmp->e.procinfo->isexport ) {

	mov	rax, QWORD PTR [rbx+96]
	test	BYTE PTR [rax+84], 4
	je	SHORT $LN8@coff_creat

; 1265 :                     size += Mangle( &tmp->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbx
	call	Mangle

; 1266 :                     size += sizeof("-export:");

	add	r14d, 9
	add	r14d, eax

; 1267 :                     if ( Options.no_export_decoration == TRUE )

	cmp	BYTE PTR Options+119, 1
	jne	SHORT $LN8@coff_creat

; 1268 :                         size += tmp->sym.name_size + 1;

	movzx	eax, BYTE PTR [rbx+72]
	inc	r14d
	add	r14d, eax
$LN8@coff_creat:

; 1259 :             DebugMsg(("coff_create_drectve: %s section added\n", szdrectve));
; 1260 : 
; 1261 :             /* calc the size for this segment */
; 1262 :             /* 1. exports */
; 1263 :             for( tmp = exp; tmp ; tmp = tmp->nextproc ) {

	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL10@coff_creat
$LN9@coff_creat:

; 1269 :                 }
; 1270 :             }
; 1271 :             /* 2. defaultlibs */
; 1272 :             for( q = modinfo->g.LibQueue.head; q ; q = q->next ) {

	mov	rbx, QWORD PTR [r15+64]
	test	rbx, rbx
	je	SHORT $LN12@coff_creat
	npad	13
$LL13@coff_creat:

; 1273 :                 size += strlen( q->value ) + sizeof("-defaultlib:");

	lea	rcx, QWORD PTR [rbx+8]
	or	rax, -1
	npad	8
$LL119@coff_creat:
	inc	rax
	cmp	BYTE PTR [rcx+rax], sil
	jne	SHORT $LL119@coff_creat
	add	r14d, 13
	add	r14d, eax

; 1274 :                 /* if the name isn't enclosed in double quotes and contains
; 1275 :                  a space, add 2 bytes to enclose it */
; 1276 :                 if ( *q->value != '"' && strchr( q->value, ' ') )

	cmp	BYTE PTR [rcx], 34			; 00000022H
	je	SHORT $LN11@coff_creat
	mov	edx, 32					; 00000020H
	call	strchr
	test	rax, rax
	je	SHORT $LN11@coff_creat

; 1277 :                     size += 2;

	add	r14d, 2
$LN11@coff_creat:

; 1269 :                 }
; 1270 :             }
; 1271 :             /* 2. defaultlibs */
; 1272 :             for( q = modinfo->g.LibQueue.head; q ; q = q->next ) {

	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL13@coff_creat
$LN12@coff_creat:

; 1278 :             }
; 1279 :             /* 3. start label */
; 1280 :             size += GetStartLabel( buffer, TRUE );

	mov	dl, 1
	lea	rcx, QWORD PTR buffer$[rsp]
	call	GetStartLabel
	add	r14d, eax

; 1281 : #if DLLIMPORT
; 1282 :             /* 4. impdefs */
; 1283 :             for( tmp = imp; tmp ; tmp = tmp->next ) {

	mov	rbx, rdi
	test	rdi, rdi
	je	SHORT $LN15@coff_creat
$LL16@coff_creat:

; 1284 :                 if ( tmp->sym.isproc && ( tmp->sym.weak == FALSE || tmp->sym.iat_used == TRUE ) &&
; 1285 :                     tmp->sym.dll && *tmp->sym.dll->name ) {

	test	BYTE PTR [rbx+41], 8
	je	SHORT $LN14@coff_creat
	test	BYTE PTR [rbx+47], 8
	je	SHORT $LN38@coff_creat
	test	BYTE PTR [rbx+40], 8
	je	SHORT $LN14@coff_creat
$LN38@coff_creat:
	mov	rax, QWORD PTR [rbx+56]
	test	rax, rax
	je	SHORT $LN14@coff_creat
	cmp	BYTE PTR [rax+12], sil
	je	SHORT $LN14@coff_creat

; 1286 :                     /* format is:
; 1287 :                      * "-import:<mangled_name>=<module_name>.<unmangled_name>" or
; 1288 :                      * "-import:<mangled_name>=<module_name>"
; 1289 :                      */
; 1290 :                     size += sizeof("-import:");
; 1291 :                     size += Mangle( &tmp->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbx
	call	Mangle
	lea	edx, DWORD PTR [rax+9]

; 1292 :                     size += 1 + strlen( tmp->sym.dll->name );

	mov	rax, QWORD PTR [rbx+56]
	add	edx, r14d
	or	rcx, -1
$LL118@coff_creat:
	cmp	BYTE PTR [rax+rcx+13], sil
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL118@coff_creat

; 1293 :                     size += 1 + tmp->sym.name_size;

	movzx	eax, BYTE PTR [rbx+72]
	lea	r14d, DWORD PTR [rcx+2]
	add	eax, edx
	add	r14d, eax
$LN14@coff_creat:

; 1281 : #if DLLIMPORT
; 1282 :             /* 4. impdefs */
; 1283 :             for( tmp = imp; tmp ; tmp = tmp->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	SHORT $LL16@coff_creat
$LN15@coff_creat:

; 1294 :                 }
; 1295 :             }
; 1296 : #endif
; 1297 :             cm->directives->sym.max_offset = size;

	mov	rax, QWORD PTR [r12]
	mov	DWORD PTR [rax+56], r14d

; 1298 :             /* v2.09: allocate 1 byte more, because sprintf() is used, which
; 1299 :              * adds a NULLC.
; 1300 :              */
; 1301 :             //directives->e.seginfo->CodeBuffer = LclAlloc( size );
; 1302 :             cm->directives->e.seginfo->CodeBuffer = LclAlloc( size + 1 );

	lea	eax, DWORD PTR [r14+1]
	movsxd	rcx, eax
	call	LclAlloc
	mov	rcx, QWORD PTR [r12]
	mov	rdx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rdx+16], rax

; 1303 :             p = cm->directives->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [r12]
	mov	rbx, QWORD PTR [rax+96]
	mov	rbx, QWORD PTR [rbx+16]

; 1304 : 
; 1305 :             /* copy the data */
; 1306 : 
; 1307 :             /* 1. exports */
; 1308 :             for( tmp = exp; tmp ; tmp = tmp->nextproc ) {

	test	rbp, rbp
	je	SHORT $LN18@coff_creat
$LL19@coff_creat:

; 1309 :                 if( tmp->e.procinfo->isexport ) {

	mov	rax, QWORD PTR [rbp+96]
	test	BYTE PTR [rax+84], 4
	je	SHORT $LN17@coff_creat

; 1310 :                     Mangle( &tmp->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbp
	call	Mangle

; 1311 :                     if ( Options.no_export_decoration == FALSE )

	cmp	BYTE PTR Options+119, sil

; 1312 :                         p += sprintf( (char *)p, "-export:%s ", buffer );

	mov	rcx, rbx
	jne	SHORT $LN40@coff_creat
	lea	r8, QWORD PTR buffer$[rsp]
	lea	rdx, OFFSET FLAT:$SG11928
	call	sprintf
	jmp	SHORT $LN129@coff_creat
$LN40@coff_creat:

; 1313 :                     else
; 1314 :                         p += sprintf( (char *)p, "-export:%s=%s ", tmp->sym.name, buffer );

	mov	r8, QWORD PTR [rbp+8]
	lea	r9, QWORD PTR buffer$[rsp]
	lea	rdx, OFFSET FLAT:$SG11929
	call	sprintf
$LN129@coff_creat:
	movsxd	rcx, eax
	add	rbx, rcx
$LN17@coff_creat:

; 1304 : 
; 1305 :             /* copy the data */
; 1306 : 
; 1307 :             /* 1. exports */
; 1308 :             for( tmp = exp; tmp ; tmp = tmp->nextproc ) {

	mov	rbp, QWORD PTR [rbp+112]
	test	rbp, rbp
	jne	SHORT $LL19@coff_creat
$LN18@coff_creat:

; 1315 :                 }
; 1316 :             }
; 1317 :             /* 2. libraries */
; 1318 :             for( q = modinfo->g.LibQueue.head; q ; q = q->next ) {

	mov	r14, QWORD PTR [r15+64]
	test	r14, r14
	je	SHORT $LN21@coff_creat
$LL22@coff_creat:

; 1319 :                 if ( *q->value != '"' && strchr( q->value, ' ' ) )

	cmp	BYTE PTR [r14+8], 34			; 00000022H
	je	SHORT $LN42@coff_creat
	mov	edx, 32					; 00000020H
	lea	rcx, QWORD PTR [r14+8]
	call	strchr

; 1320 :                     p += sprintf( (char *)p,"-defaultlib:\"%s\" ", (char *)q->value );

	lea	rdx, OFFSET FLAT:$SG11932
	test	rax, rax
	jne	SHORT $LN130@coff_creat
$LN42@coff_creat:

; 1321 :                 else
; 1322 :                     p += sprintf( (char *)p,"-defaultlib:%s ", (char *)q->value );

	lea	rdx, OFFSET FLAT:$SG11933
$LN130@coff_creat:
	lea	r8, QWORD PTR [r14+8]
	mov	rcx, rbx
	call	sprintf
	mov	r14, QWORD PTR [r14]
	movsxd	rcx, eax
	add	rbx, rcx
	test	r14, r14
	jne	SHORT $LL22@coff_creat
$LN21@coff_creat:
	mov	r14, QWORD PTR [rsp+600]

; 1323 :             }
; 1324 :             /* 3. entry */
; 1325 :             if ( modinfo->g.start_label ) {

	cmp	QWORD PTR [r15+208], rsi
	je	$LN44@coff_creat

; 1326 :                 GetStartLabel( buffer, FALSE );

	mov	rcx, QWORD PTR ModuleInfo+208
	test	rcx, rcx
	je	$LN55@coff_creat
	lea	rdx, QWORD PTR temp$1[rsp]
	call	Mangle
	cmp	BYTE PTR Options+120, sil
	je	SHORT $LN52@coff_creat
	npad	11
$LL60@coff_creat:
	movzx	eax, BYTE PTR temp$1[rsp+rsi]
	mov	BYTE PTR buffer$[rsp+rsi], al
	lea	rsi, QWORD PTR [rsi+1]
	test	al, al
	jne	SHORT $LL60@coff_creat
	jmp	SHORT $LN55@coff_creat
$LN52@coff_creat:
	mov	rcx, QWORD PTR ModuleInfo+208
	mov	eax, DWORD PTR [rcx+76]
	dec	eax
	cmp	eax, 2
	jbe	SHORT $LL54@coff_creat
	mov	rax, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rax], 95			; 0000005fH
	je	SHORT $LL56@coff_creat
$LL61@coff_creat:
	movzx	eax, BYTE PTR temp$1[rsp+rsi]
	mov	BYTE PTR buffer$[rsp+rsi], al
	lea	rsi, QWORD PTR [rsi+1]
	test	al, al
	jne	SHORT $LL61@coff_creat
	jmp	SHORT $LN55@coff_creat
	npad	10
$LL56@coff_creat:
	movzx	eax, BYTE PTR temp$1[rsp+rsi+1]
	mov	BYTE PTR buffer$[rsp+rsi], al
	lea	rsi, QWORD PTR [rsi+1]
	test	al, al
	jne	SHORT $LL56@coff_creat
	jmp	SHORT $LN55@coff_creat
	npad	10
$LL54@coff_creat:
	movzx	eax, BYTE PTR temp$1[rsp+rsi+1]
	mov	BYTE PTR buffer$[rsp+rsi], al
	lea	rsi, QWORD PTR [rsi+1]
	test	al, al
	jne	SHORT $LL54@coff_creat
$LN55@coff_creat:

; 1327 :                 p += sprintf( (char *)p, "-entry:%s ", buffer );

	lea	r8, QWORD PTR buffer$[rsp]
	mov	rcx, rbx
	lea	rdx, OFFSET FLAT:$SG11935
	call	sprintf
	movsxd	rcx, eax
	add	rbx, rcx
$LN44@coff_creat:

; 1328 :             }
; 1329 : #if DLLIMPORT
; 1330 :             /* 4. impdefs */
; 1331 :             for( tmp = imp; tmp ; tmp = tmp->next ) {

	test	rdi, rdi
	je	$LN128@coff_creat
	lea	rsi, OFFSET FLAT:$SG11938
	npad	2
$LL25@coff_creat:

; 1332 :                 if ( tmp->sym.isproc && ( tmp->sym.weak == FALSE || tmp->sym.iat_used == TRUE ) &&
; 1333 :                     tmp->sym.dll && *tmp->sym.dll->name ) {

	test	BYTE PTR [rdi+41], 8
	je	$LN23@coff_creat
	test	BYTE PTR [rdi+47], 8
	je	SHORT $LN46@coff_creat
	test	BYTE PTR [rdi+40], 8
	je	$LN23@coff_creat
$LN46@coff_creat:
	mov	rax, QWORD PTR [rdi+56]
	test	rax, rax
	je	$LN23@coff_creat
	cmp	BYTE PTR [rax+12], 0
	je	$LN23@coff_creat

; 1334 :                     strcpy( p, "-import:" );

	mov	rdx, rbx
	mov	rcx, rsi
	sub	rdx, rsi
	npad	6
$LL48@coff_creat:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL48@coff_creat

; 1335 :                     p += 8;

	add	rbx, 8

; 1336 :                     p += Mangle( &tmp->sym, p );

	mov	rcx, rdi
	mov	rdx, rbx
	call	Mangle
	movsxd	rcx, eax
	add	rbx, rcx

; 1337 :                     *p++ = '=';

	mov	BYTE PTR [rbx], 61			; 0000003dH
	inc	rbx

; 1338 :                     strcpy( p, tmp->sym.dll->name );

	mov	rcx, QWORD PTR [rdi+56]
	mov	rdx, rbx
	add	rcx, 12
	npad	12
$LL49@coff_creat:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL49@coff_creat

; 1339 :                     p += strlen( p );

	or	rax, -1
$LL117@coff_creat:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL117@coff_creat
	add	rbx, rax

; 1340 :                     *p++ = '.';

	mov	BYTE PTR [rbx], 46			; 0000002eH
	inc	rbx

; 1341 :                     memcpy( p, tmp->sym.name, tmp->sym.name_size );

	movzx	r8d, BYTE PTR [rdi+72]
	mov	rcx, rbx
	mov	rdx, QWORD PTR [rdi+8]
	call	memcpy

; 1342 :                     p += tmp->sym.name_size;

	movzx	eax, BYTE PTR [rdi+72]
	add	rbx, rax

; 1343 :                     *p++ = ' ';

	mov	BYTE PTR [rbx], 32			; 00000020H
	inc	rbx
$LN23@coff_creat:

; 1328 :             }
; 1329 : #if DLLIMPORT
; 1330 :             /* 4. impdefs */
; 1331 :             for( tmp = imp; tmp ; tmp = tmp->next ) {

	mov	rdi, QWORD PTR [rdi+104]
	test	rdi, rdi
	jne	$LL25@coff_creat
$LN128@coff_creat:
	mov	rbx, QWORD PTR [rsp+592]
$LN24@coff_creat:

; 1344 :                 }
; 1345 :             }
; 1346 : #endif
; 1347 :             /**/myassert( size == p - cm->directives->e.seginfo->CodeBuffer );
; 1348 :             //size_drectve = p - directives->e.seginfo->CodeBuffer; /* v2.11:removed */
; 1349 :         }
; 1350 :     }
; 1351 : }

	lea	r11, QWORD PTR [rsp+560]
	mov	rbp, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r15
	pop	r12
	pop	rdi
	ret	0
coff_create_drectve ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
;	COMDAT coff_write_data
_TEXT	SEGMENT
offset$ = 96
modinfo$ = 96
index$ = 104
cm$ = 104
il$1 = 112
coff_write_data PROC					; COMDAT

; 1053 : {

	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r15
	sub	rsp, 48					; 00000030H

; 1054 :     struct dsym *section;
; 1055 :     uint_32 offset = 0; /* offset within section contents */

	xor	r12d, r12d
	mov	r15, rdx
	mov	edi, r12d
	mov	rbx, rcx

; 1056 :     int i;
; 1057 :     uint_32 index;
; 1058 : 
; 1059 :     DebugMsg(("coff_write_data(%s): enter\n", modinfo->name ));
; 1060 : 
; 1061 :     /* v2.11: removed. max_offset has been set already */
; 1062 :     //if ( directives )
; 1063 :     //    directives->sym.max_offset = size_drectve;
; 1064 : 
; 1065 :     /* calc the current index for the COFF symbol table */
; 1066 :     index = SetSymbolIndices( modinfo, cm );

	call	SetSymbolIndices

; 1067 : 
; 1068 :     /* fill the SafeSEH array */
; 1069 :     if ( modinfo->g.SafeSEHQueue.head ) {

	mov	r8, QWORD PTR [rbx+48]
	mov	DWORD PTR index$[rsp], eax
	test	r8, r8
	je	SHORT $LN3@coff_write

; 1070 :         struct qnode *sehp;
; 1071 :         struct qnode *sehp2;
; 1072 :         uint_32 *pdw;
; 1073 :         for( sehp = modinfo->g.SafeSEHQueue.head, pdw = (uint_32 *)cm->sxdata->e.seginfo->CodeBuffer; sehp ; sehp = sehp2 ) {

	mov	rax, QWORD PTR [r15+8]
	mov	rcx, QWORD PTR [rax+96]
	mov	r9, QWORD PTR [rcx+16]
	npad	10
$LL4@coff_write:

; 1074 :             sehp2 = sehp->next;
; 1075 :             DebugMsg(("coff_write_data: .sxdata value=%08Xh\n", ((struct asym *)sehp->elmt)->ext_idx));
; 1076 :             *pdw++ = ((struct asym *)sehp->elmt)->ext_idx;

	mov	rax, QWORD PTR [r8+8]
	lea	r9, QWORD PTR [r9+4]
	mov	rdx, QWORD PTR [r8]
	mov	r8, rdx
	mov	ecx, DWORD PTR [rax+88]
	mov	DWORD PTR [r9-4], ecx
	test	rdx, rdx
	jne	SHORT $LL4@coff_write
$LN3@coff_write:

; 1077 :             LclFree( sehp );
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 : #if HELPSYMS==0
; 1082 :     for( i = 0, section = SymTables[TAB_SEG].head; section ; i++, section = section->next ) {

	mov	rsi, QWORD PTR SymTables+32
	mov	ecx, r12d
	test	rsi, rsi
	je	$LN47@coff_write
	npad	3
$LL7@coff_write:

; 1083 :         section->sym.ext_idx = cm->sectionstart + i;

	mov	edx, DWORD PTR [r15+44]
	add	edx, ecx
	mov	DWORD PTR [rsi+88], edx

; 1084 :         if ( Options.no_section_aux_entry == FALSE )

	cmp	BYTE PTR Options+116, dil
	jne	SHORT $LN5@coff_write

; 1085 :             section->sym.ext_idx += i;

	lea	eax, DWORD PTR [rdx+rcx]
	mov	DWORD PTR [rsi+88], eax
$LN5@coff_write:

; 1077 :             LclFree( sehp );
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 : #if HELPSYMS==0
; 1082 :     for( i = 0, section = SymTables[TAB_SEG].head; section ; i++, section = section->next ) {

	mov	rsi, QWORD PTR [rsi+104]
	inc	ecx
	test	rsi, rsi
	jne	SHORT $LL7@coff_write
	mov	rsi, QWORD PTR SymTables+32

; 1086 :     }
; 1087 : #endif
; 1088 : 
; 1089 :     /* now scan the section's relocations. If a relocation refers to
; 1090 :      a symbol which is not public/external, it must be added to the
; 1091 :      symbol table. If the symbol is an assembly time variable, a helper
; 1092 :      symbol - name is $$<offset:6> is to be added.
; 1093 :      */
; 1094 : 
; 1095 :     for( section = SymTables[TAB_SEG].head; section ; section = section->next ) {

	test	rsi, rsi
	je	$LN47@coff_write
	mov	QWORD PTR [rsp+120], rbp
	mov	QWORD PTR [rsp+40], r13
	mov	r13d, 32767				; 00007fffH
	mov	QWORD PTR [rsp+32], r14
	npad	8
$LL10@coff_write:

; 1096 :         uint_32 size;
; 1097 :         size = section->sym.max_offset;
; 1098 : #ifdef DEBUG_OUT
; 1099 :         if ( section->e.seginfo->CodeBuffer )
; 1100 :             DebugMsg(("coff_write_data(%s, %Xh): size=%X, written=%X, content=[%02X %02X ...]\n",
; 1101 :                       section->sym.name, offset, size - section->e.seginfo->start_loc, section->e.seginfo->bytes_written, *(section->e.seginfo->CodeBuffer), *(section->e.seginfo->CodeBuffer+1)));
; 1102 :         else
; 1103 :             DebugMsg(("coff_write_data(%s, %Xh): size=%X, buffer=NULL\n",
; 1104 :                       section->sym.name, offset, size - section->e.seginfo->start_loc ));
; 1105 : #endif
; 1106 : 
; 1107 :         /* don't write section data for bss and uninitialized stack segments */
; 1108 :         if ( section->e.seginfo->combine == COMB_STACK && section->e.seginfo->bytes_written == 0 )

	mov	rcx, QWORD PTR [rsi+96]
	mov	ebx, DWORD PTR [rsi+56]
	movzx	eax, BYTE PTR [rcx+108]
	and	al, 7
	cmp	al, 5
	jne	SHORT $LN16@coff_write
	cmp	DWORD PTR [rcx+24], r12d
	je	$LN8@coff_write
$LN16@coff_write:

; 1109 :             continue;
; 1110 :         if ( section->e.seginfo->segtype == SEGTYPE_BSS )

	cmp	DWORD PTR [rcx+72], 3
	je	$LN8@coff_write

; 1111 :             continue;
; 1112 : 
; 1113 :         if ( size ) {

	test	ebx, ebx
	je	$LN18@coff_write

; 1114 :             offset += size;

	add	edi, ebx
	mov	DWORD PTR offset$[rsp], edi

; 1115 :             if ((offset & 1) && section->e.seginfo->FixupList.head ) {

	test	dil, 1
	je	SHORT $LN19@coff_write
	cmp	QWORD PTR [rcx+40], r12
	je	SHORT $LN19@coff_write

; 1116 :                 offset++;

	inc	edi
	mov	DWORD PTR offset$[rsp], edi

; 1117 :                 size++;

	inc	ebx
$LN19@coff_write:

; 1118 :             }
; 1119 :             if ( section->e.seginfo->CodeBuffer == NULL ) {

	cmp	QWORD PTR [rcx+16], r12
	jne	SHORT $LN20@coff_write

; 1120 :                 fseek( CurrFile[OBJ], size, SEEK_CUR );

	mov	rcx, QWORD PTR ModuleInfo+104
	mov	r8d, 1
	mov	edx, ebx
	call	fseek

; 1121 :             } else {

	jmp	SHORT $LN23@coff_write
$LN20@coff_write:

; 1122 :                 /* if there was an ORG, the buffer content will
; 1123 :                  * start with the ORG address. The bytes from
; 1124 :                  * 0 - ORG must be written by moving the file pointer!
; 1125 :                  */
; 1126 :                 if ( section->e.seginfo->start_loc ) {

	mov	edx, DWORD PTR [rcx+8]
	test	edx, edx
	je	SHORT $LN22@coff_write

; 1127 :                     fseek( CurrFile[OBJ], section->e.seginfo->start_loc, SEEK_CUR );

	mov	rcx, QWORD PTR ModuleInfo+104
	mov	r8d, 1
	call	fseek

; 1128 :                     size -= section->e.seginfo->start_loc;

	mov	rcx, QWORD PTR [rsi+96]
	sub	ebx, DWORD PTR [rcx+8]
$LN22@coff_write:

; 1129 :                 }
; 1130 : 
; 1131 :                 if ( fwrite( section->e.seginfo->CodeBuffer, 1, size, CurrFile[OBJ] ) != size )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	r8, rbx
	mov	rcx, QWORD PTR [rcx+16]
	mov	edx, 1
	call	fwrite
	cmp	rax, rbx
	je	SHORT $LN23@coff_write

; 1132 :                     WriteError();

	call	WriteError
$LN23@coff_write:

; 1133 :             }
; 1134 : 
; 1135 :             coff_write_fixups( section, &offset, &index );

	lea	r8, QWORD PTR index$[rsp]
	mov	rcx, rsi
	lea	rdx, QWORD PTR offset$[rsp]
	call	coff_write_fixups
	mov	edi, DWORD PTR offset$[rsp]
$LN18@coff_write:

; 1136 :         } /* end if (size) */
; 1137 : 
; 1138 :         /* v2.07: the following block has beem moved outside of "if(size)" block,
; 1139 :          * because it may happen that a segment has size 0 and still debug info.
; 1140 :          * In any case it's important to initialize section->e.seginfo->num_linnums
; 1141 :          */
; 1142 :         /* write line number data. The peculiarity of COFF (compared to OMF) is
; 1143 :          * that line numbers are always relative to a function start.
; 1144 :          *
; 1145 :          * an item with line number 0 has a special meaning - it contains a reference
; 1146 :          * ( a symbol table index ) to the function whose line numbers are to follow.
; 1147 :          * this item is to be followed by an item with line number 32767, which then
; 1148 :          * tells the function's start offset ( undocumented! ).
; 1149 :          *
; 1150 :          */
; 1151 :         if( Options.line_numbers && section->e.seginfo->LinnumQueue ) {

	cmp	BYTE PTR Options+1, r12b
	je	$LN8@coff_write
	mov	rax, QWORD PTR [rsi+96]
	mov	rbx, QWORD PTR [rax+56]
	test	rbx, rbx
	je	$LN8@coff_write

; 1152 :             IMAGE_LINENUMBER il;
; 1153 :             struct line_num_info *lni;
; 1154 :             struct asym *last;
; 1155 :             uint_32 line_numbers = 0;
; 1156 :             last = NULL;
; 1157 :             lni = (struct line_num_info *)((struct qdesc *)section->e.seginfo->LinnumQueue)->head;

	mov	rbx, QWORD PTR [rbx]
	mov	r14d, r12d
	mov	rbp, r12

; 1158 :             DebugMsg(("coff_write_data(%s): writing linnum data\n", section->sym.name ));
; 1159 :             for( ; lni; lni = lni->next ) {

	test	rbx, rbx
	je	$LN12@coff_write
	npad	5
$LL13@coff_write:

; 1160 :                 DebugMsg(("coff_write_data(%s, %Xh): linnum, #=%u, %s=%X, sym=%s\n",
; 1161 :                           section->sym.name, offset, lni->number, lni->number ? "ofs" : "idx", lni->offset, lni->number ? "NULL" : lni->sym->name ));
; 1162 :                 if ( lni->number == 0 ) {

	cmp	DWORD PTR [rbx+8], r12d
	jne	SHORT $LN25@coff_write

; 1163 :                     last = lni->sym;
; 1164 :                     if ( cm->lastproc )

	mov	rcx, QWORD PTR [r15+16]
	mov	rbp, QWORD PTR [rbx+16]
	test	rcx, rcx
	je	SHORT $LN27@coff_write

; 1165 :                         cm->lastproc->debuginfo->next_proc = lni->sym->ext_idx;

	mov	rcx, QWORD PTR [rcx+64]
	mov	eax, DWORD PTR [rbp+88]
	mov	DWORD PTR [rcx+16], eax
$LN27@coff_write:

; 1166 :                     cm->lastproc = lni->sym;

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [r15+16], rax

; 1167 :                     lni->sym->debuginfo->next_proc = 0;

	mov	rax, QWORD PTR [rbx+16]
	mov	rcx, QWORD PTR [rax+64]
	mov	DWORD PTR [rcx+16], r12d

; 1168 :                     il.Linenumber = 0;

	mov	WORD PTR il$1[rsp+4], r12w

; 1169 : #ifdef DEBUG_OUT
; 1170 :                     /* if symbol table index is 0, then the proc wasn't added
; 1171 :                      * to the "publics" queue in AddLinnumDataRef().
; 1172 :                      */
; 1173 :                     if ( lni->sym->ext_idx == 0 ) {
; 1174 :                         DebugMsg(("coff_write_data(%s, %Xh): error, %s has symbol table index 0\n",
; 1175 :                                   section->sym.name, offset, lni->sym->name ));
; 1176 :                     }
; 1177 : #endif
; 1178 :                     il.Type.SymbolTableIndex = lni->sym->ext_idx;

	mov	rax, QWORD PTR [rbx+16]
	mov	ecx, DWORD PTR [rax+88]
	mov	DWORD PTR il$1[rsp], ecx

; 1179 :                     lni->sym->debuginfo->start_line = lni->line_number;

	mov	rax, QWORD PTR [rbx+16]
	mov	edx, DWORD PTR [rbx+12]
	and	edx, 1048575				; 000fffffH
	mov	rcx, QWORD PTR [rax+64]
	mov	DWORD PTR [rcx], edx

; 1180 :                     //((struct dsym *)lni->sym)->e.procinfo->file = lni->file;
; 1181 :                     lni->sym->debuginfo->ln_fileofs = cm->start_data + offset;

	mov	rax, QWORD PTR [rbx+16]
	mov	edx, DWORD PTR [r15+32]
	add	edx, edi
	mov	rcx, QWORD PTR [rax+64]
	mov	DWORD PTR [rcx+8], edx

; 1182 :                     DebugMsg(("coff_write_data(%s, %Xh): proc %s start_line=%u\n",
; 1183 :                               section->sym.name, offset, lni->sym->name, lni->sym->debuginfo->start_line ));
; 1184 :                 } else {

	jmp	SHORT $LN26@coff_write
$LN25@coff_write:

; 1185 :                     /**/myassert( last != NULL );
; 1186 :                     il.Linenumber = lni->number - last->debuginfo->start_line;

	mov	rax, QWORD PTR [rbp+64]
	movzx	ecx, WORD PTR [rbx+8]
	sub	cx, WORD PTR [rax]
	mov	WORD PTR il$1[rsp+4], cx

; 1187 :                     /* if current line number - start line number is 0,
; 1188 :                      * generate a "32767" line number item.
; 1189 :                      */
; 1190 :                     if ( il.Linenumber == 0 )

	jne	SHORT $LN28@coff_write

; 1191 :                         il.Linenumber = 0x7FFF;

	mov	WORD PTR il$1[rsp+4], r13w
$LN28@coff_write:

; 1192 :                     il.Type.VirtualAddress = lni->offset;

	mov	eax, DWORD PTR [rbx+12]
	mov	DWORD PTR il$1[rsp], eax
$LN26@coff_write:

; 1193 :                 }
; 1194 :                 /* v2.11: last is always != NULL */
; 1195 :                 //if ( last ) {
; 1196 :                     last->debuginfo->line_numbers++;

	mov	rax, QWORD PTR [rbp+64]

; 1197 :                     last->debuginfo->end_line = lni->number;
; 1198 :                 //}
; 1199 :                 if ( fwrite( &il, 1, sizeof(il), CurrFile[OBJ] ) != sizeof(il) )

	mov	edx, 1
	inc	WORD PTR [rax+12]
	lea	r8d, QWORD PTR [rdx+5]
	mov	rcx, QWORD PTR [rbp+64]
	mov	eax, DWORD PTR [rbx+8]
	mov	DWORD PTR [rcx+4], eax
	lea	rcx, QWORD PTR il$1[rsp]
	mov	r9, QWORD PTR ModuleInfo+104
	call	fwrite
	cmp	rax, 6
	je	SHORT $LN29@coff_write

; 1200 :                     WriteError();

	call	WriteError
$LN29@coff_write:

; 1158 :             DebugMsg(("coff_write_data(%s): writing linnum data\n", section->sym.name ));
; 1159 :             for( ; lni; lni = lni->next ) {

	mov	rbx, QWORD PTR [rbx]

; 1201 :                 offset += sizeof(il);

	add	edi, 6

; 1202 :                 line_numbers++;

	inc	r14d
	test	rbx, rbx
	jne	$LL13@coff_write
$LN12@coff_write:

; 1203 :             } /* end for */
; 1204 :             section->e.seginfo->num_linnums = line_numbers;

	mov	rax, QWORD PTR [rsi+96]
	mov	DWORD PTR [rax+56], r14d
$LN8@coff_write:

; 1086 :     }
; 1087 : #endif
; 1088 : 
; 1089 :     /* now scan the section's relocations. If a relocation refers to
; 1090 :      a symbol which is not public/external, it must be added to the
; 1091 :      symbol table. If the symbol is an assembly time variable, a helper
; 1092 :      symbol - name is $$<offset:6> is to be added.
; 1093 :      */
; 1094 : 
; 1095 :     for( section = SymTables[TAB_SEG].head; section ; section = section->next ) {

	mov	rsi, QWORD PTR [rsi+104]
	test	rsi, rsi
	jne	$LL10@coff_write

; 1209 : 
; 1210 :     DebugMsg(("coff_write_data: exit, size of sections=%Xh\n", cm->size_data ));
; 1211 : 
; 1212 :     return( NOT_ERROR );

	mov	r14, QWORD PTR [rsp+32]
	xor	eax, eax
	mov	r13, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+120]
	mov	DWORD PTR [r15+36], edi

; 1213 : }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN47@coff_write:

; 1205 :         } /* end if (Options.line_numbers...) */
; 1206 :     } /* end for */
; 1207 : 
; 1208 :     cm->size_data = offset;

	mov	DWORD PTR [r15+36], r12d

; 1209 : 
; 1210 :     DebugMsg(("coff_write_data: exit, size of sections=%Xh\n", cm->size_data ));
; 1211 : 
; 1212 :     return( NOT_ERROR );

	xor	eax, eax

; 1213 : }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
coff_write_data ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
;	COMDAT coff_write_fixups
_TEXT	SEGMENT
ir$ = 32
section$ = 112
poffset$ = 120
pindex$ = 128
coff_write_fixups PROC					; COMDAT

; 893  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 894  :     uint_32 offset = *poffset;
; 895  :     uint_32 index = *pindex;
; 896  :     struct fixup *fix;
; 897  :     IMAGE_RELOCATION ir;
; 898  : 
; 899  :     /* v2.10: handle the reloc-overflow-case */
; 900  :     if ( section->e.seginfo->num_relocs > 0xffff ) {

	mov	rax, QWORD PTR [rcx+96]
	xor	ebx, ebx
	mov	ebp, DWORD PTR [rdx]
	mov	r14, r8
	mov	edi, DWORD PTR [r8]
	mov	r15, rdx
	mov	rsi, rcx
	mov	eax, DWORD PTR [rax+64]
	lea	r13d, QWORD PTR [rbx+10]
	cmp	eax, 65535				; 0000ffffH
	jbe	SHORT $LN9@coff_write

; 901  :         DebugMsg(("coff_write_fixups(%s): enter, num_relocs=%" I32_SPEC "u\n", section->sym.name, section->e.seginfo->num_relocs ));
; 902  :         ir.VirtualAddress = section->e.seginfo->num_relocs + 1;
; 903  :         ir.SymbolTableIndex = 0;
; 904  :         ir.Type = IMAGE_REL_I386_ABSOLUTE; /* doesn't matter if 32- or 64-bit */
; 905  :         if ( fwrite( &ir, 1, sizeof(ir), CurrFile[OBJ] ) != sizeof(ir) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	edx, QWORD PTR [rbx+1]
	inc	eax
	mov	DWORD PTR ir$[rsp+4], ebx
	mov	r8d, r13d
	mov	DWORD PTR ir$[rsp], eax
	lea	rcx, QWORD PTR ir$[rsp]
	mov	WORD PTR ir$[rsp+8], bx
	call	fwrite
	cmp	rax, r13
	je	SHORT $LN10@coff_write

; 906  :             WriteError();

	call	WriteError
$LN10@coff_write:

; 907  :         offset += sizeof( ir );

	add	ebp, r13d
$LN9@coff_write:

; 908  :     }
; 909  :     /* reset counter */
; 910  :     section->e.seginfo->num_relocs = 0;

	mov	rax, QWORD PTR [rsi+96]
	mov	DWORD PTR [rax+64], ebx

; 911  : 
; 912  :     for ( fix = section->e.seginfo->FixupList.head; fix ; fix = fix->nextrlc ) {

	mov	rbx, QWORD PTR [rsi+96]
	mov	rbx, QWORD PTR [rbx+40]
	test	rbx, rbx
	je	$LN42@coff_write
	mov	r8d, 2
	mov	QWORD PTR [rsp+112], r12
	lea	r12, OFFSET FLAT:__ImageBase
	lea	r10d, QWORD PTR [r8+1]
	lea	r9d, QWORD PTR [r8+9]
	lea	r11d, QWORD PTR [r8+18]
	lea	r14d, QWORD PTR [r8-1]
	lea	r15d, QWORD PTR [r8+4]
	npad	5
$LL4@coff_write:

; 913  : #if AMD64_SUPPORT
; 914  :         if ( section->e.seginfo->Ofssize == USE64 ) {

	mov	rax, QWORD PTR [rsi+96]

; 915  :             switch ( fix->type ) {

	movsxd	rdx, DWORD PTR [rbx+24]
	cmp	BYTE PTR [rax+104], 2
	jne	SHORT $LN11@coff_write
	cmp	edx, 13
	ja	$LN29@coff_write
	mov	ecx, DWORD PTR $LN41@coff_write[r12+rdx*4]
	add	rcx, r12
	jmp	rcx
$LN14@coff_write:

; 916  :             case FIX_VOID:
; 917  :                 continue;
; 918  :             case FIX_RELOFF32: /* 32bit offset */
; 919  :                 /* translated to IMAGE_REL_AMD64_REL32_[1|2|3|4|5] */
; 920  :                 ir.Type = IMAGE_REL_AMD64_REL32 + (fix->addbytes - 4);

	movzx	eax, BYTE PTR [rbx+32]
	mov	WORD PTR ir$[rsp+8], ax

; 921  :                 break;

	jmp	SHORT $LN7@coff_write
$LN16@coff_write:

; 922  :             case FIX_OFF32: /* 32bit offset */
; 923  :                 ir.Type = IMAGE_REL_AMD64_ADDR32;
; 924  :                 break;
; 925  : #if IMAGERELSUPP
; 926  :             case FIX_OFF32_IMGREL:
; 927  :                 ir.Type = IMAGE_REL_AMD64_ADDR32NB;

	mov	WORD PTR ir$[rsp+8], r10w

; 928  :                 break;

	jmp	SHORT $LN7@coff_write
$LN11@coff_write:

; 929  : #endif
; 930  : #if SECTIONRELSUPP
; 931  :             case FIX_OFF32_SECREL:
; 932  :                 ir.Type = IMAGE_REL_AMD64_SECREL;
; 933  :                 break;
; 934  : #endif
; 935  :             case FIX_OFF64: /* 64bit offset */
; 936  :                 ir.Type = IMAGE_REL_AMD64_ADDR64;
; 937  :                 break;
; 938  :             case FIX_SEG: /* segment fixup */
; 939  :                 ir.Type = IMAGE_REL_AMD64_SECTION; /* ??? */
; 940  :                 break;
; 941  : #if 0 /* not supported by COFF64! shouldn't reach this point */
; 942  :             case FIX_RELOFF8:
; 943  :             case FIX_RELOFF16:
; 944  :             case FIX_OFF8:
; 945  :             case FIX_OFF16:
; 946  :             case FIX_HIBYTE:
; 947  :             case FIX_PTR16: /* 16bit far pointer */
; 948  :             case FIX_PTR32: /* 32bit far pointer */
; 949  : #endif
; 950  :             default:
; 951  :                 DebugMsg(("coff_write_fixups(%s, %Xh): reloc loc=%X type=%u idx=%u sym=%s\n",
; 952  :                           section->sym.name, offset, fix->locofs, fix->type, fix->sym->ext_idx, fix->sym->name));
; 953  :                 EmitErr( UNKNOWN_FIXUP_TYPE, fix->type, section->sym.name, fix->locofs );
; 954  :                 continue; /* v2.03: skip this fixup */
; 955  :                 //break;
; 956  :             }
; 957  :         } else
; 958  : #endif
; 959  :             switch ( fix->type ) {

	cmp	edx, 13
	ja	$LN29@coff_write
	mov	ecx, DWORD PTR $LN40@coff_write[r12+rdx*4]
	add	rcx, r12
	jmp	rcx
$LN22@coff_write:

; 960  :             case FIX_VOID:
; 961  :                 continue;
; 962  :             case FIX_RELOFF16: /* 16bit offset */
; 963  :                 ir.Type = IMAGE_REL_I386_REL16;

	mov	WORD PTR ir$[rsp+8], r8w

; 964  :                 break;

	jmp	SHORT $LN7@coff_write
$LN23@coff_write:

; 965  :             case FIX_OFF16: /* 16bit offset */
; 966  :                 ir.Type = IMAGE_REL_I386_DIR16;

	mov	WORD PTR ir$[rsp+8], r14w

; 967  :                 break;

	jmp	SHORT $LN7@coff_write
$LN24@coff_write:

; 968  :             case FIX_RELOFF32: /* 32bit offset */
; 969  :                 ir.Type = IMAGE_REL_I386_REL32;

	mov	WORD PTR ir$[rsp+8], r11w

; 970  :                 break;

	jmp	SHORT $LN7@coff_write
$LN25@coff_write:

; 971  :             case FIX_OFF32: /* 32bit offset */
; 972  :                 ir.Type = IMAGE_REL_I386_DIR32;

	mov	WORD PTR ir$[rsp+8], r15w

; 973  :                 break;

	jmp	SHORT $LN7@coff_write
$LN26@coff_write:

; 974  : #if IMAGERELSUPP
; 975  :             case FIX_OFF32_IMGREL:
; 976  :                 ir.Type = IMAGE_REL_I386_DIR32NB;

	mov	eax, 7
	mov	WORD PTR ir$[rsp+8], ax

; 977  :                 break;

	jmp	SHORT $LN7@coff_write
$LN27@coff_write:

; 978  : #endif
; 979  : #if SECTIONRELSUPP
; 980  :             case FIX_OFF32_SECREL:
; 981  :                 ir.Type = IMAGE_REL_I386_SECREL;

	mov	WORD PTR ir$[rsp+8], r9w

; 982  :                 break;

	jmp	SHORT $LN7@coff_write
$LN28@coff_write:

; 983  : #endif
; 984  :             case FIX_SEG: /* segment fixup */
; 985  :                 ir.Type = IMAGE_REL_I386_SECTION; /* ??? */

	mov	WORD PTR ir$[rsp+8], r13w
$LN7@coff_write:

; 998  :                 continue; /* v2.03: skip this fixup */
; 999  :                 //break;
; 1000 :             }
; 1001 :         /* if it's not EXTERNAL/PUBLIC, add symbol */
; 1002 :         /* if it's an assembly time variable, create helper symbol */
; 1003 :         if ( fix->sym->variable == TRUE ) {

	mov	rax, QWORD PTR [rbx+56]
	movzx	edx, BYTE PTR [rax+40]
	test	dl, 64					; 00000040H
	je	SHORT $LN30@coff_write

; 1004 : #if HELPSYMS
; 1005 :             struct asym *sym;
; 1006 :             char buffer[12];
; 1007 :             sprintf( buffer, "$$%06X", fix->offset );
; 1008 :             sym = SymAlloc( buffer );
; 1009 :             sym->state = fix->sym->state;
; 1010 :             sym->mem_type = fix->sym->mem_type;
; 1011 :             sym->offset = fix->offset;
; 1012 :             sym->segment = fix->segment;
; 1013 :             sym->variable = TRUE; /* storage class LABEL */
; 1014 :             fix->sym = sym;
; 1015 :             AddPublicData( fix->sym );
; 1016 :             fix->sym->idx = index++;
; 1017 : #else
; 1018 :             /* just use the segment entry. This approach requires
; 1019 :              * that the offset is stored inline at the reloc location
; 1020 :              * (patch in fixup.c)
; 1021 :              */
; 1022 :             fix->sym = fix->segment_var;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR [rbx+56], rax

; 1023 : #endif
; 1024 :         } else if (( fix->sym->state == SYM_INTERNAL ) &&

	jmp	SHORT $LN33@coff_write
$LN30@coff_write:

; 1025 :                    fix->sym->included == FALSE &&

	cmp	DWORD PTR [rax+32], r14d
	jne	SHORT $LN33@coff_write
	movzx	ecx, BYTE PTR [rax+41]
	test	cl, 64					; 00000040H
	jne	SHORT $LN33@coff_write
	test	dl, dl
	js	SHORT $LN33@coff_write

; 1026 :                    fix->sym->ispublic == FALSE ) {
; 1027 :             fix->sym->included = TRUE;

	or	cl, 64					; 00000040H
	mov	BYTE PTR [rax+41], cl

; 1028 :             AddPublicData( fix->sym );

	mov	rcx, QWORD PTR [rbx+56]
	call	AddPublicData

; 1029 :             DebugMsg(("coff_write_fixups(%s, %Xh): %s added to symbol table, idx=%u\n",
; 1030 :                       section->sym.name, offset, fix->sym->name, index ));
; 1031 :             fix->sym->ext_idx = index++;

	mov	rax, QWORD PTR [rbx+56]
	mov	DWORD PTR [rax+88], edi
	inc	edi

; 1032 :             if ( Options.line_numbers && fix->sym->isproc )

	cmp	BYTE PTR Options+1, 0
	je	SHORT $LN33@coff_write
	mov	rax, QWORD PTR [rbx+56]
	test	BYTE PTR [rax+41], 8
	je	SHORT $LN33@coff_write

; 1033 :                 index += 6;

	add	edi, r15d
$LN33@coff_write:

; 1034 :         }
; 1035 :         ir.VirtualAddress = fix->locofs;

	mov	eax, DWORD PTR [rbx+20]

; 1036 :         ir.SymbolTableIndex = fix->sym->ext_idx;
; 1037 :         if ( fwrite( &ir, 1, sizeof(ir), CurrFile[OBJ] ) != sizeof(ir) )

	mov	r8, r13
	mov	r9, QWORD PTR ModuleInfo+104
	mov	rdx, r14
	mov	DWORD PTR ir$[rsp], eax
	mov	rax, QWORD PTR [rbx+56]
	mov	ecx, DWORD PTR [rax+88]
	mov	DWORD PTR ir$[rsp+4], ecx
	lea	rcx, QWORD PTR ir$[rsp]
	call	fwrite
	cmp	rax, r13
	je	SHORT $LN34@coff_write

; 1038 :             WriteError();

	call	WriteError
$LN34@coff_write:

; 1039 :         DebugMsg(("coff_write_fixups(%s, %Xh): reloc loc=%X type=%u idx=%u sym=%s\n",
; 1040 :                   section->sym.name, offset, ir.VirtualAddress, ir.Type, ir.SymbolTableIndex, fix->sym->name));
; 1041 :         offset += sizeof( ir );
; 1042 :         section->e.seginfo->num_relocs++;

	mov	rax, QWORD PTR [rsi+96]
	add	ebp, r13d
	inc	DWORD PTR [rax+64]

; 1043 :     } /* end for */

	jmp	SHORT $LN44@coff_write
$LN29@coff_write:

; 986  :                 break;
; 987  : #if 0
; 988  :             case FIX_OFF8:
; 989  :             case FIX_RELOFF8:
; 990  :             case FIX_HIBYTE:
; 991  :             case FIX_PTR16: /* 16bit far pointer */
; 992  :             case FIX_PTR32: /* 32bit far pointer */
; 993  : #endif
; 994  :             default:
; 995  :                 DebugMsg(("coff_write_fixups(%s, %Xh): reloc loc=%X type=%u idx=%u sym=%s\n",
; 996  :                           section->sym.name, offset, fix->locofs, fix->type, fix->sym->ext_idx, fix->sym->name));
; 997  :                 EmitErr( UNKNOWN_FIXUP_TYPE, fix->type, section->sym.name, fix->locofs );

	mov	r9d, DWORD PTR [rbx+20]
	mov	ecx, 196				; 000000c4H
	mov	r8, QWORD PTR [rsi+8]
	call	EmitErr
$LN44@coff_write:
	mov	r8d, 2
	lea	r9d, QWORD PTR [r8+9]
	lea	r10d, QWORD PTR [r8+1]
	lea	r11d, QWORD PTR [r8+18]
$LN2@coff_write:

; 911  : 
; 912  :     for ( fix = section->e.seginfo->FixupList.head; fix ; fix = fix->nextrlc ) {

	mov	rbx, QWORD PTR [rbx+8]
	test	rbx, rbx
	jne	$LL4@coff_write

; 1044 :     DebugMsg(("coff_write_fixups(%s): exit, num_relocs=%" I32_SPEC "u\n", section->sym.name, section->e.seginfo->num_relocs ));
; 1045 :     *poffset = offset;

	mov	r15, QWORD PTR poffset$[rsp]

; 1046 :     *pindex = index;

	mov	r14, QWORD PTR pindex$[rsp]
	mov	r12, QWORD PTR [rsp+112]
$LN42@coff_write:

; 1044 :     DebugMsg(("coff_write_fixups(%s): exit, num_relocs=%" I32_SPEC "u\n", section->sym.name, section->e.seginfo->num_relocs ));
; 1045 :     *poffset = offset;

	mov	DWORD PTR [r15], ebp

; 1046 :     *pindex = index;

	mov	DWORD PTR [r14], edi

; 1047 : }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
	npad	2
$LN41@coff_write:
	DD	$LN2@coff_write
	DD	$LN29@coff_write
	DD	$LN29@coff_write
	DD	$LN14@coff_write
	DD	$LN29@coff_write
	DD	$LN29@coff_write
	DD	$LN22@coff_write
	DD	$LN23@coff_write
	DD	$LN28@coff_write
	DD	$LN29@coff_write
	DD	$LN29@coff_write
	DD	$LN29@coff_write
	DD	$LN16@coff_write
	DD	$LN27@coff_write
$LN40@coff_write:
	DD	$LN2@coff_write
	DD	$LN29@coff_write
	DD	$LN22@coff_write
	DD	$LN24@coff_write
	DD	$LN29@coff_write
	DD	$LN23@coff_write
	DD	$LN25@coff_write
	DD	$LN29@coff_write
	DD	$LN28@coff_write
	DD	$LN29@coff_write
	DD	$LN29@coff_write
	DD	$LN29@coff_write
	DD	$LN26@coff_write
	DD	$LN27@coff_write
coff_write_fixups ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
;	COMDAT SetSymbolIndices
_TEXT	SEGMENT
tv137 = 80
tv129 = 80
lastfproc$ = 80
ModuleInfo$ = 80
cm$ = 88
SetSymbolIndices PROC					; COMDAT

; 812  : {

	push	rbx
	push	rbp
	push	rsi
	push	r13
	push	r15
	sub	rsp, 32					; 00000020H

; 813  :     struct qnode *q;
; 814  :     struct dsym  *curr;
; 815  :     struct asym  *sym;
; 816  :     uint_32 index;
; 817  :     uint_32 i;
; 818  :     struct asym *lastfproc;
; 819  :     unsigned lastfile = 0;

	xor	r15d, r15d

; 820  : 
; 821  :     index = 0;
; 822  :     cm->lastproc = NULL;
; 823  :     cm->start_files = 0;  /* v2.11: added */
; 824  : 
; 825  : #if COMPID
; 826  :     index++;
; 827  : #endif
; 828  :     /* add absolute symbol @@feat.00 if -SAFESEH is set */
; 829  :     if ( Options.safeseh )

	xor	ebx, ebx
	mov	QWORD PTR [rdx+16], r15
	mov	eax, 1
	mov	DWORD PTR [rdx+40], r15d
	mov	rbp, rdx
	cmp	BYTE PTR Options+139, bl
	mov	rsi, rcx

; 830  :         index++;
; 831  : 
; 832  :     /* count AUX entries for .file. Depends on sizeof filename */
; 833  : 
; 834  :     if ( Options.no_file_entry == FALSE ) {

	mov	r13, -2049638230412172401		; e38e38e38e38e38fH
	cmovne	ebx, eax
	cmp	BYTE PTR Options+114, r15b
	jne	SHORT $LN13@SetSymbolI

; 835  :         i = strlen( cm->dot_file_value );

	mov	rcx, QWORD PTR [rdx+24]
	or	rax, -1
	npad	8
$LL41@SetSymbolI:
	inc	rax
	cmp	BYTE PTR [rcx+rax], r15b
	jne	SHORT $LL41@SetSymbolI

; 836  :         index += i / sizeof( IMAGE_AUX_SYMBOL ) + 1;

	mov	ecx, eax
	lea	ebx, DWORD PTR [rbx+1]
	mov	rax, r13
	mul	rcx
	shr	rdx, 4
	lea	rax, QWORD PTR [rdx+rdx*8]
	add	rax, rax
	lea	ebx, DWORD PTR [rbx+rdx]
	sub	rcx, rax

; 837  :         if ( i % sizeof( IMAGE_AUX_SYMBOL ) )

	je	SHORT $LN13@SetSymbolI

; 838  :             index++;

	inc	ebx
$LN13@SetSymbolI:

; 839  :     }
; 840  : 
; 841  :     /* add entries for sections */
; 842  : 
; 843  :     cm->sectionstart = index;

	mov	DWORD PTR [rbp+44], ebx

; 844  :     index += ModuleInfo->g.num_segs;

	mov	eax, DWORD PTR [rsi+8]
	add	ebx, eax

; 845  :     if ( Options.no_section_aux_entry == FALSE )

	cmp	BYTE PTR Options+116, r15b
	jne	SHORT $LN14@SetSymbolI

; 846  :         index += ModuleInfo->g.num_segs;

	add	ebx, eax
$LN14@SetSymbolI:

; 847  : 
; 848  :     /* count externals and protos */
; 849  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ; curr = curr->next ) {

	mov	rax, QWORD PTR SymTables+16
	test	rax, rax
	je	SHORT $LN3@SetSymbolI
	npad	8
$LL4@SetSymbolI:

; 850  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE )

	movzx	edx, BYTE PTR [rax+47]
	movzx	ecx, dl
	shr	cl, 2
	and	cl, 1
	jne	SHORT $LN15@SetSymbolI
	test	dl, 8
	jne	SHORT $LN2@SetSymbolI
$LN15@SetSymbolI:

; 851  :             continue;
; 852  :         curr->sym.ext_idx = index++;

	mov	DWORD PTR [rax+88], ebx
	inc	ebx

; 853  :         /* weak externals need an additional aux entry */
; 854  :         if ( curr->sym.iscomm == FALSE && curr->sym.altname )

	test	cl, cl
	jne	SHORT $LN2@SetSymbolI
	cmp	QWORD PTR [rax+64], r15
	je	SHORT $LN2@SetSymbolI

; 855  :             index++;

	inc	ebx
$LN2@SetSymbolI:

; 847  : 
; 848  :     /* count externals and protos */
; 849  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ; curr = curr->next ) {

	mov	rax, QWORD PTR [rax+104]
	test	rax, rax
	jne	SHORT $LL4@SetSymbolI
$LN3@SetSymbolI:

; 856  :     }
; 857  : 
; 858  : #if STATIC_PROCS
; 859  :     /* v2.04: count private procedures (will become static symbols) */
; 860  :     if ( Options.no_static_procs == FALSE )

	cmp	BYTE PTR Options+115, r15b
	mov	QWORD PTR [rsp+88], rdi
	jne	SHORT $LN6@SetSymbolI

; 861  :         for( curr = SymTables[TAB_PROC].head ; curr != NULL ; curr = curr->nextproc )

	mov	rdi, QWORD PTR SymTables+64
	test	rdi, rdi
	je	SHORT $LN6@SetSymbolI
$LL7@SetSymbolI:

; 862  :             if ( curr->sym.state == SYM_INTERNAL && curr->sym.ispublic == FALSE && curr->sym.included == FALSE ) {

	cmp	DWORD PTR [rdi+32], 1
	jne	SHORT $LN5@SetSymbolI
	test	BYTE PTR [rdi+40], 128			; 00000080H
	jne	SHORT $LN5@SetSymbolI
	movzx	eax, BYTE PTR [rdi+41]
	test	al, 64					; 00000040H
	jne	SHORT $LN5@SetSymbolI

; 863  :                 curr->sym.included = TRUE;

	or	al, 64					; 00000040H

; 864  :                 AddPublicData( &curr->sym );

	mov	rcx, rdi
	mov	BYTE PTR [rdi+41], al
	call	AddPublicData
$LN5@SetSymbolI:

; 861  :         for( curr = SymTables[TAB_PROC].head ; curr != NULL ; curr = curr->nextproc )

	mov	rdi, QWORD PTR [rdi+112]
	test	rdi, rdi
	jne	SHORT $LL7@SetSymbolI
$LN6@SetSymbolI:

; 865  :             }
; 866  : #endif
; 867  :     /* count items in public queue */
; 868  :     for ( q = ModuleInfo->g.PubQueue.head; q; q = q->next ) {

	mov	rsi, QWORD PTR [rsi+16]
	test	rsi, rsi
	je	$LN42@SetSymbolI
	mov	QWORD PTR [rsp+96], r14
	mov	r14, QWORD PTR lastfproc$[rsp]
	npad	7
$LL10@SetSymbolI:

; 869  :         sym = q->sym;
; 870  :         /* if line numbers are on, co, add 6 entries for procs */
; 871  :         if ( Options.line_numbers && sym->isproc ) {

	cmp	BYTE PTR Options+1, 0
	mov	rdi, QWORD PTR [rsi+8]
	je	$LN19@SetSymbolI
	test	BYTE PTR [rdi+41], 8
	je	SHORT $LN19@SetSymbolI

; 872  :             if (  sym->debuginfo->file != lastfile ) {

	mov	rax, QWORD PTR [rdi+64]
	movzx	ecx, WORD PTR [rax+14]
	cmp	ecx, r15d
	je	SHORT $LN21@SetSymbolI

; 873  :                 if ( cm->start_files == 0 )

	cmp	DWORD PTR [rbp+40], 0
	jne	SHORT $LN22@SetSymbolI

; 874  :                     cm->start_files = index;

	mov	DWORD PTR [rbp+40], ebx
	jmp	SHORT $LN23@SetSymbolI
$LN22@SetSymbolI:

; 875  :                 else
; 876  :                     lastfproc->debuginfo->next_file = index;

	mov	rax, QWORD PTR [r14+64]
	mov	DWORD PTR [rax+20], ebx
$LN23@SetSymbolI:

; 877  :                 lastfproc = sym;
; 878  :                 index += 1 + GetFileAuxEntries( sym->debuginfo->file, NULL );

	mov	rax, QWORD PTR [rdi+64]
	mov	r14, rdi
	movzx	ecx, WORD PTR [rax+14]
	call	GetFName
	mov	rcx, QWORD PTR [rax]
	or	rax, -1
	npad	3
$LL40@SetSymbolI:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL40@SetSymbolI
	mov	ecx, eax
	mov	rax, r13
	mul	rcx
	shr	rdx, 4
	lea	rax, QWORD PTR [rdx+rdx*8]
	add	rax, rax
	sub	rcx, rax
	mov	eax, 0
	setne	al
	inc	eax
	add	eax, edx
	add	ebx, eax

; 879  :                 lastfile = sym->debuginfo->file;

	mov	rax, QWORD PTR [rdi+64]
	movzx	r15d, WORD PTR [rax+14]
$LN21@SetSymbolI:

; 880  :             }
; 881  :             sym->ext_idx = index++;

	mov	DWORD PTR [rdi+88], ebx

; 882  :             index += 6;

	add	ebx, 7

; 883  :         } else

	jmp	SHORT $LN8@SetSymbolI
$LN19@SetSymbolI:

; 884  :             sym->ext_idx = index++;

	mov	DWORD PTR [rdi+88], ebx
	inc	ebx
$LN8@SetSymbolI:

; 865  :             }
; 866  : #endif
; 867  :     /* count items in public queue */
; 868  :     for ( q = ModuleInfo->g.PubQueue.head; q; q = q->next ) {

	mov	rsi, QWORD PTR [rsi]
	test	rsi, rsi
	jne	$LL10@SetSymbolI
	mov	r14, QWORD PTR [rsp+96]
$LN42@SetSymbolI:

; 885  :     }
; 886  :     return( index );

	mov	eax, ebx
	mov	rdi, QWORD PTR [rsp+88]

; 887  : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r13
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
SetSymbolIndices ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
seg$ = 64
curr$ = 72
size$ = 80
pv$ = 88
coff_flushfunc PROC

; 778  : {

	push	rbp
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 779  :     unsigned currsize = curr - seg->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [rcx+96]
	mov	r14d, edx
	mov	r15, r9
	mov	rbp, rcx
	sub	r14d, DWORD PTR [rax+16]

; 780  :     struct coffmod *cm;
; 781  :     int i;
; 782  :     uint_8 *p;
; 783  : 
; 784  :     if ( ( currsize + size ) > SIZE_CV_SEGBUF ) {

	lea	eax, DWORD PTR [r14+r8]
	cmp	eax, 1200				; 000004b0H
	jbe	$LN2@coff_flush

; 785  :         if ( currsize ) {

	test	r14d, r14d
	je	$LN3@coff_flush

; 786  :             p = LclAlloc( currsize + sizeof( struct qditem ) );

	mov	QWORD PTR [rsp+64], rbx
	lea	rcx, QWORD PTR [r14+16]
	mov	QWORD PTR [rsp+72], rsi
	mov	QWORD PTR [rsp+80], rdi
	call	LclAlloc

; 787  :             ((struct qditem *)p)->next = NULL;

	xor	edi, edi

; 788  :             ((struct qditem *)p)->size = currsize;
; 789  :             memcpy( p + sizeof( struct qditem ), seg->e.seginfo->CodeBuffer, currsize );

	mov	r8d, r14d
	mov	rsi, rax
	mov	QWORD PTR [rax], rdi
	lea	rcx, QWORD PTR [rax+16]
	mov	DWORD PTR [rax+8], r14d
	mov	rdx, QWORD PTR [rbp+96]
	mov	rdx, QWORD PTR [rdx+16]
	call	memcpy

; 790  :             cm = pv;
; 791  :             i = ( seg == cm->SymDeb[DBGS_TYPES].seg ? DBGS_TYPES : DBGS_SYMBOLS );

	cmp	rbp, QWORD PTR [r15+72]
	mov	rbx, QWORD PTR [rsp+64]
	sete	dil

; 792  :             if ( cm->SymDeb[i].q.head == NULL )

	movsxd	rcx, edi
	mov	rdi, QWORD PTR [rsp+80]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	cmp	QWORD PTR [r15+rdx*8+56], 0
	jne	SHORT $LN4@coff_flush

; 793  :                 cm->SymDeb[i].q.head = cm->SymDeb[i].q.tail = p;

	mov	QWORD PTR [r15+rdx*8+56], rsi
	jmp	SHORT $LN7@coff_flush
$LN4@coff_flush:

; 794  :             else {
; 795  :                 ((struct qditem *)(cm->SymDeb[i].q.tail))->next = p;

	mov	rax, QWORD PTR [r15+rdx*8+64]
	mov	QWORD PTR [rax], rsi
$LN7@coff_flush:

; 796  :                 cm->SymDeb[i].q.tail = p;

	mov	QWORD PTR [r15+rdx*8+64], rsi

; 797  :             }
; 798  :             seg->e.seginfo->current_loc = seg->e.seginfo->start_loc + currsize;

	mov	rdx, QWORD PTR [rbp+96]
	mov	rsi, QWORD PTR [rsp+72]
	mov	ecx, DWORD PTR [rdx+8]
	add	ecx, r14d
	mov	DWORD PTR [rdx+12], ecx

; 799  :             seg->e.seginfo->start_loc = seg->e.seginfo->current_loc;

	mov	rcx, QWORD PTR [rbp+96]
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rcx+8], eax
$LN3@coff_flush:

; 800  :         }
; 801  :         return( seg->e.seginfo->CodeBuffer );

	mov	rax, QWORD PTR [rbp+96]
	mov	rax, QWORD PTR [rax+16]

; 804  : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rbp
	ret	0
$LN2@coff_flush:

; 802  :     }
; 803  :     return( curr );

	mov	rax, rdx

; 804  : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rbp
	ret	0
coff_flushfunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
;	COMDAT GetStartLabel
_TEXT	SEGMENT
temp$ = 32
buffer$ = 304
msg$ = 312
GetStartLabel PROC					; COMDAT

; 747  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 288				; 00000120H
	mov	rbx, rcx
	movzx	edi, dl

; 748  :     int size = 0;
; 749  :     char temp[ MAX_ID_LEN + MANGLE_BYTES + 1 ];
; 750  : 
; 751  :     if ( ModuleInfo.g.start_label ) {

	mov	rcx, QWORD PTR ModuleInfo+208
	test	rcx, rcx
	je	$LN29@GetStartLa

; 752  :         Mangle( ModuleInfo.g.start_label, temp );

	lea	rdx, QWORD PTR temp$[rsp]
	call	Mangle

; 753  :         if ( Options.entry_decorated )

	cmp	BYTE PTR Options+120, 0
	je	SHORT $LN3@GetStartLa

; 754  :             strcpy( buffer, temp );

	lea	rax, QWORD PTR temp$[rsp]
	mov	rcx, rbx
	sub	rcx, rax
	lea	rdx, QWORD PTR temp$[rsp]
	npad	10
$LL11@GetStartLa:
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL11@GetStartLa
	jmp	$LN6@GetStartLa
$LN3@GetStartLa:
	mov	rcx, QWORD PTR ModuleInfo+208
	mov	eax, DWORD PTR [rcx+76]
	dec	eax
	cmp	eax, 2
	jbe	SHORT $LN5@GetStartLa

; 755  :         else {
; 756  :             if ( ModuleInfo.g.start_label->langtype != LANG_C &&
; 757  :                 ModuleInfo.g.start_label->langtype != LANG_STDCALL &&
; 758  :                 ModuleInfo.g.start_label->langtype != LANG_SYSCALL ) {
; 759  :                 if ( *ModuleInfo.g.start_label->name != '_' ) {

	mov	r8, QWORD PTR [rcx+8]
	cmp	BYTE PTR [r8], 95			; 0000005fH
	je	SHORT $LN7@GetStartLa

; 760  :                     if ( msg && ( ModuleInfo.fctype != FCT_WIN64 ) )

	test	dil, dil
	je	SHORT $LN9@GetStartLa
	cmp	DWORD PTR ModuleInfo+376, 2
	je	SHORT $LN9@GetStartLa

; 761  :                         EmitWarn( 2, LEADING_UNDERSCORE_REQUIRED_FOR_START_LABEL, ModuleInfo.g.start_label->name );

	mov	edx, 194				; 000000c2H
	mov	ecx, 2
	call	EmitWarn
$LN9@GetStartLa:

; 762  :                     strcpy( buffer, temp );

	lea	rax, QWORD PTR temp$[rsp]
	mov	rdx, rbx
	sub	rdx, rax
	lea	rcx, QWORD PTR temp$[rsp]
	npad	5
$LL12@GetStartLa:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rdx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL12@GetStartLa

; 763  :                 } else {

	jmp	SHORT $LN6@GetStartLa
$LN7@GetStartLa:

; 764  :                     strcpy( buffer, temp+1 );

	lea	rax, QWORD PTR temp$[rsp+1]
	mov	rdx, rbx
	sub	rdx, rax
	lea	rcx, QWORD PTR temp$[rsp+1]
$LL13@GetStartLa:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rdx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL13@GetStartLa

; 765  :                 }
; 766  :             } else

	jmp	SHORT $LN6@GetStartLa
$LN5@GetStartLa:

; 767  :                 strcpy( buffer, temp+1 );

	lea	rax, QWORD PTR temp$[rsp+1]
	mov	rdx, rbx
	sub	rdx, rax
	lea	rcx, QWORD PTR temp$[rsp+1]
$LL14@GetStartLa:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rdx+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL14@GetStartLa
$LN6@GetStartLa:

; 768  :         }
; 769  :         size = strlen( buffer ) + 8; // 8 == size of " -entry:"

	or	rax, -1
$LL28@GetStartLa:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL28@GetStartLa
	add	eax, 8

; 772  : }

	mov	rbx, QWORD PTR [rsp+304]
	add	rsp, 288				; 00000120H
	pop	rdi
	ret	0
$LN29@GetStartLa:

; 770  :     }
; 771  :     return( size );

	xor	eax, eax

; 772  : }

	mov	rbx, QWORD PTR [rsp+304]
	add	rsp, 288				; 00000120H
	pop	rdi
	ret	0
GetStartLabel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
;	COMDAT coff_write_symbols
_TEXT	SEGMENT
is$ = 32
ias$ = 56
buffer$ = 80
modinfo$ = 400
cm$ = 408
lastfile$1$ = 416
tv927 = 424
tv158 = 424
coff_write_symbols PROC					; COMDAT

; 418  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-80]
	sub	rsp, 336				; 00000150H

; 419  :     uint_32     cntSymbols = 0;

	xor	r13d, r13d
	mov	r14, rdx

; 420  :     struct dsym *curr;
; 421  :     struct asym *sym;
; 422  :     struct qnode *q;
; 423  :     char        *p;
; 424  :     unsigned    len;
; 425  :     unsigned    i;
; 426  :     IMAGE_SYMBOL is;
; 427  :     IMAGE_AUX_SYMBOL ias;
; 428  :     unsigned    lastfile = 0;
; 429  :     char        buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 430  : 
; 431  :     DebugMsg(("coff_write_symbols: enter\n"));
; 432  : 
; 433  : #if COMPID
; 434  :     /* write "@comp.id" entry */
; 435  :     if ( fwrite( &isCompId, 1, sizeof(IMAGE_SYMBOL), CurrFile[OBJ] ) != sizeof(IMAGE_SYMBOL) )
; 436  :         WriteError();
; 437  :     cntSymbols++;
; 438  : #endif
; 439  :     /* "@feat.00" entry (for SafeSEH) */
; 440  :     if ( Options.safeseh ) {

	cmp	BYTE PTR Options+139, r13b
	mov	r15d, r13d
	mov	DWORD PTR lastfile$1$[rbp-256], r13d
	lea	esi, QWORD PTR [r13+1]
	je	SHORT $LN20@coff_write

; 441  :         if ( fwrite( &isFeat00, 1, sizeof(IMAGE_SYMBOL), CurrFile[OBJ] ) != sizeof(IMAGE_SYMBOL) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	r8d, QWORD PTR [r13+18]
	mov	edx, esi
	lea	rcx, OFFSET FLAT:isFeat00
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN21@coff_write

; 442  :             WriteError();

	call	WriteError
$LN21@coff_write:

; 443  :         cntSymbols++;

	mov	r15d, esi
$LN20@coff_write:

; 444  :     }
; 445  : 
; 446  :     /* .file item (optionally disabled by -zlf) */
; 447  : 
; 448  :     if ( Options.no_file_entry == FALSE ) {

	cmp	BYTE PTR Options+114, r13b
	mov	rdi, -2049638230412172401		; e38e38e38e38e38fH
	jne	$LN22@coff_write

; 449  :         strncpy( is.N.ShortName, ".file", IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG11628
	lea	rcx, QWORD PTR is$[rsp]
	call	strncpy

; 450  :         is.Value = ( Options.line_numbers ? cm->start_files : 0 );  /* index of next .file entry */

	cmp	BYTE PTR Options+1, r13b
	je	SHORT $LN70@coff_write
	mov	eax, DWORD PTR [r14+40]
	mov	DWORD PTR is$[rsp+8], eax
	jmp	SHORT $LN71@coff_write
$LN70@coff_write:
	mov	DWORD PTR is$[rsp+8], r13d
$LN71@coff_write:

; 451  :         is.SectionNumber = (uint_16)IMAGE_SYM_DEBUG;
; 452  :         is.Type = IMAGE_SYM_TYPE_NULL;
; 453  :         is.StorageClass = IMAGE_SYM_CLASS_FILE;
; 454  : 
; 455  :         p = cm->dot_file_value;

	mov	rbx, QWORD PTR [r14+24]

; 456  :         i = strlen( p );

	or	rax, -1
	mov	DWORD PTR is$[rsp+12], 65534		; 0000fffeH
	mov	BYTE PTR is$[rsp+16], 103		; 00000067H
	npad	5
$LL174@coff_write:
	inc	rax
	cmp	BYTE PTR [rbx+rax], r13b
	jne	SHORT $LL174@coff_write

; 457  :         is.NumberOfAuxSymbols = i / sizeof(IMAGE_AUX_SYMBOL) + (i % sizeof(IMAGE_AUX_SYMBOL) ? 1 : 0);
; 458  :         if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	r8d, 18
	mov	ecx, eax
	mov	rax, rdi
	mul	rcx
	shr	rdx, 4
	lea	rax, QWORD PTR [rdx+rdx*8]
	add	rax, rax
	sub	rcx, rax
	lea	rcx, QWORD PTR is$[rsp]
	setne	al
	add	al, dl
	mov	rdx, rsi
	mov	BYTE PTR is$[rsp+17], al
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN23@coff_write

; 459  :             WriteError();

	call	WriteError
$LN23@coff_write:

; 460  : 
; 461  :         for ( i = is.NumberOfAuxSymbols;i;i--, p += sizeof(IMAGE_AUX_SYMBOL) ) {

	movzx	eax, BYTE PTR is$[rsp+17]
	mov	edi, eax
	test	al, al
	je	SHORT $LN3@coff_write
	npad	8
$LL4@coff_write:

; 462  :             strncpy( ias.File.Name, p, sizeof(IMAGE_AUX_SYMBOL) );

	mov	r8d, 18
	lea	rcx, QWORD PTR ias$[rsp]
	mov	rdx, rbx
	call	strncpy

; 463  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR ias$[rsp]
	mov	r8d, 18
	mov	rdx, rsi
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN2@coff_write

; 464  :                 WriteError();

	call	WriteError
$LN2@coff_write:

; 460  : 
; 461  :         for ( i = is.NumberOfAuxSymbols;i;i--, p += sizeof(IMAGE_AUX_SYMBOL) ) {

	add	rbx, 18
	add	edi, -1					; ffffffffH
	jne	SHORT $LL4@coff_write
	movzx	eax, BYTE PTR is$[rsp+17]
$LN3@coff_write:

; 465  :         }
; 466  :         cntSymbols += is.NumberOfAuxSymbols + 1;

	movzx	eax, al
	inc	r15d
	add	r15d, eax
$LN22@coff_write:

; 467  :     }
; 468  : 
; 469  :     /* next are section entries */
; 470  : 
; 471  :     for( i = 1, curr = SymTables[TAB_SEG].head; curr; curr = curr->next, i++ ) {

	mov	rdi, QWORD PTR SymTables+32
	mov	r12d, esi
	test	rdi, rdi
	je	$LN6@coff_write
$LL7@coff_write:

; 472  :         /* v2.07: prefer ALIAS name if defined */
; 473  :         p = ( curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ConvertSectionName( &curr->sym, NULL, buffer ) );

	mov	rax, QWORD PTR [rdi+96]
	mov	rbx, QWORD PTR [rax+96]
	test	rbx, rbx
	jne	SHORT $LN73@coff_write
	lea	r8, QWORD PTR buffer$[rsp]
	xor	edx, edx
	mov	rcx, rdi
	call	ConvertSectionName
	mov	rbx, rax
$LN73@coff_write:

; 474  :         len = strlen( p );

	or	rcx, -1
$LL173@coff_write:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], r13b
	jne	SHORT $LL173@coff_write

; 475  :         if ( len <= IMAGE_SIZEOF_SHORT_NAME )

	cmp	ecx, 8
	ja	SHORT $LN25@coff_write

; 476  :             strncpy( is.N.ShortName, p, IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rcx, QWORD PTR is$[rsp]
	mov	rdx, rbx
	call	strncpy
	jmp	SHORT $LN26@coff_write
$LN25@coff_write:

; 477  :         else {
; 478  :             is.N.Name.Short = 0;
; 479  :             is.N.Name.Long = Coff_AllocString( cm, p, len );

	mov	esi, DWORD PTR [r14+112]
	mov	DWORD PTR is$[rsp], r13d
	lea	eax, DWORD PTR [rsi+1]
	add	eax, ecx
	movsxd	rcx, ecx
	add	rcx, 16
	mov	DWORD PTR [r14+112], eax
	call	LclAlloc
	mov	rdx, rax
	mov	QWORD PTR [rax], r13
	sub	rax, rbx
	npad	1
$LL82@coff_write:
	movzx	ecx, BYTE PTR [rbx]
	mov	BYTE PTR [rbx+rax+8], cl
	lea	rbx, QWORD PTR [rbx+1]
	test	cl, cl
	jne	SHORT $LL82@coff_write
	cmp	QWORD PTR [r14+96], r13
	je	SHORT $LN79@coff_write
	mov	rax, QWORD PTR [r14+104]
	mov	QWORD PTR [rax], rdx
	jmp	SHORT $LN177@coff_write
$LN79@coff_write:
	mov	QWORD PTR [r14+96], rdx
$LN177@coff_write:
	mov	DWORD PTR is$[rsp+4], esi
	mov	esi, 1
	mov	QWORD PTR [r14+104], rdx
$LN26@coff_write:

; 480  :         }
; 481  :         is.Value = 0;
; 482  :         is.SectionNumber = i;
; 483  :         is.Type = IMAGE_SYM_TYPE_NULL;
; 484  :         is.StorageClass = IMAGE_SYM_CLASS_STATIC;
; 485  :         is.NumberOfAuxSymbols = 0;
; 486  :         if ( Options.no_section_aux_entry == FALSE )
; 487  :             is.NumberOfAuxSymbols = 1;
; 488  : 
; 489  :         DebugMsg(("coff_write_symbols(%u, SECT): %s, type=%x, stgcls=%x\n", cntSymbols, curr->sym.name, is.Type, is.StorageClass ));
; 490  : 
; 491  :         if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR is$[rsp]
	xor	al, al
	mov	DWORD PTR is$[rsp+8], r13d
	cmp	BYTE PTR Options+116, r13b
	mov	r8d, 18
	movzx	eax, al
	mov	rdx, rsi
	cmove	eax, esi
	mov	WORD PTR is$[rsp+12], r12w
	mov	BYTE PTR is$[rsp+17], al
	mov	WORD PTR is$[rsp+14], r13w
	mov	BYTE PTR is$[rsp+16], 3
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN28@coff_write

; 492  :             WriteError();

	call	WriteError
$LN28@coff_write:

; 493  :         cntSymbols++;

	inc	r15d

; 494  : 
; 495  :         /* write the auxiliary symbol record for sections.
; 496  :          * may be suppressed with option -zls.
; 497  :          */
; 498  :         if ( Options.no_section_aux_entry == FALSE 
; 499  : #if COMDATSUPP
; 500  :             || curr->e.seginfo->comdat_selection

	cmp	BYTE PTR Options+116, r13b
	je	SHORT $LN30@coff_write
	mov	rax, QWORD PTR [rdi+96]
	test	BYTE PTR [rax+108], 56			; 00000038H
	je	$LN5@coff_write
$LN30@coff_write:

; 501  : #endif
; 502  :             ) {
; 503  :             ias.Section.Length = curr->sym.max_offset;

	mov	eax, DWORD PTR [rdi+56]

; 504  :             /* v2.10: check for overflow */
; 505  :             //ias.Section.NumberOfRelocations = curr->e.seginfo->num_relocs;
; 506  :             ias.Section.NumberOfRelocations = ( curr->e.seginfo->num_relocs > 0xffff ? 0xffff : (uint_16)curr->e.seginfo->num_relocs );

	mov	ecx, 65535				; 0000ffffH
	mov	DWORD PTR ias$[rsp], eax
	mov	rax, QWORD PTR [rdi+96]
	cmp	DWORD PTR [rax+64], ecx
	jbe	SHORT $LN74@coff_write
	mov	WORD PTR ias$[rsp+4], cx
	jmp	SHORT $LN75@coff_write
$LN74@coff_write:
	movzx	eax, WORD PTR [rax+64]
	mov	WORD PTR ias$[rsp+4], ax
$LN75@coff_write:

; 507  :             if ( Options.line_numbers )

	cmp	BYTE PTR Options+1, r13b
	je	SHORT $LN31@coff_write

; 508  :                 ias.Section.NumberOfLinenumbers = curr->e.seginfo->num_linnums;

	mov	rax, QWORD PTR [rdi+96]
	movzx	ecx, WORD PTR [rax+56]
	mov	WORD PTR ias$[rsp+6], cx
	jmp	SHORT $LN32@coff_write
$LN31@coff_write:

; 509  :             else
; 510  :                 ias.Section.NumberOfLinenumbers = 0;

	mov	WORD PTR ias$[rsp+6], r13w
$LN32@coff_write:

; 511  :             /* CheckSum, Number and Selection are for COMDAT sections only */
; 512  : #if COMDATSUPP
; 513  :             if ( curr->e.seginfo->comdat_selection ) {

	mov	rbx, QWORD PTR [rdi+96]
	test	BYTE PTR [rbx+108], 56			; 00000038H
	je	$LN33@coff_write

; 514  :                 ias.Section.CheckSum = CRC32Comdat( curr->e.seginfo->CodeBuffer, curr->sym.max_offset, 0 );

	mov	esi, DWORD PTR [rdi+56]
	mov	r11d, r13d
	cmp	BYTE PTR ?init@?1??CRC32Comdat@@9@9, r11b
	mov	rbx, QWORD PTR [rbx+16]
	jne	SHORT $LN87@coff_write
	mov	BYTE PTR ?init@?1??CRC32Comdat@@9@9, 1
	call	InitCRC32
$LN87@coff_write:
	test	rbx, rbx
	je	SHORT $LN85@coff_write
	test	esi, esi
	je	SHORT $LN85@coff_write
	lea	rdx, OFFSET FLAT:CRC32Table
	npad	9
$LL86@coff_write:
	movzx	eax, BYTE PTR [rbx]
	lea	rbx, QWORD PTR [rbx+1]
	movzx	ecx, r11b
	xor	rcx, rax
	mov	eax, r11d
	shr	eax, 8
	mov	r11d, DWORD PTR [rdx+rcx*4]
	xor	r11d, eax
	add	esi, -1					; ffffffffH
	jne	SHORT $LL86@coff_write
$LN85@coff_write:
	mov	DWORD PTR ias$[rsp+8], r11d

; 515  :                 ias.Section.Number = curr->e.seginfo->comdat_number;
; 516  :                 ias.Section.Selection = curr->e.seginfo->comdat_selection;
; 517  :             } else {

	mov	esi, 1
	mov	rax, QWORD PTR [rdi+96]
	movzx	ecx, WORD PTR [rax+88]
	mov	WORD PTR ias$[rsp+12], cx
	mov	rax, QWORD PTR [rdi+96]
	movzx	ecx, BYTE PTR [rax+108]
	shr	cl, 3
	and	cl, 7
	mov	BYTE PTR ias$[rsp+14], cl
	jmp	SHORT $LN34@coff_write
$LN33@coff_write:

; 518  : #endif
; 519  :                 ias.Section.CheckSum = 0;

	mov	DWORD PTR ias$[rsp+8], r13d

; 520  :                 ias.Section.Number = 0;

	mov	WORD PTR ias$[rsp+12], r13w

; 521  :                 ias.Section.Selection = 0;

	mov	BYTE PTR ias$[rsp+14], r13b
$LN34@coff_write:

; 522  : #if COMDATSUPP
; 523  :             };
; 524  : #endif
; 525  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR ias$[rsp]
	mov	r8d, 18
	mov	rdx, rsi
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN35@coff_write

; 526  :                 WriteError();

	call	WriteError
$LN35@coff_write:

; 527  :             DebugMsg(("coff_write_symbols(%u, SECT): %s, AUX, relocs=%u, linnums=%u\n", cntSymbols, curr->sym.name, ias.Section.NumberOfRelocations, ias.Section.NumberOfLinenumbers ));
; 528  :             cntSymbols++;

	inc	r15d
$LN5@coff_write:

; 467  :     }
; 468  : 
; 469  :     /* next are section entries */
; 470  : 
; 471  :     for( i = 1, curr = SymTables[TAB_SEG].head; curr; curr = curr->next, i++ ) {

	mov	rdi, QWORD PTR [rdi+104]
	inc	r12d
	test	rdi, rdi
	jne	$LL7@coff_write
$LN6@coff_write:

; 529  :         }
; 530  :     }
; 531  : 
; 532  :     /* third are externals + communals ( + protos [since v2.01] ) */
; 533  : 
; 534  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+16
	mov	edi, 2
	lea	r12d, QWORD PTR [rdi+1]
	test	rbx, rbx
	je	$LN9@coff_write
	npad	4
$LL10@coff_write:

; 535  :         /* skip "weak" (=unused) externdefs */
; 536  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE ) {

	movzx	eax, BYTE PTR [rbx+47]
	test	al, 4
	jne	SHORT $LN36@coff_write
	test	al, 8
	jne	$LN8@coff_write
$LN36@coff_write:

; 537  :             DebugMsg(("coff_write_symbols(EXT+COMM): %s skipped, used=%u, comm=%u, weak=%u\n", curr->sym.name, curr->sym.used, curr->sym.iscomm, curr->sym.weak ));
; 538  :             continue;
; 539  :         }
; 540  :         len = Mangle( &curr->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbx
	call	Mangle

; 541  : 
; 542  :         is.Type = CoffGetType(&curr->sym);

	test	BYTE PTR [rbx+41], 8
	movzx	ecx, r13w
	movsxd	rdx, eax
	mov	eax, 32					; 00000020H
	cmovne	cx, ax
	mov	WORD PTR is$[rsp+14], cx

; 543  :         is.StorageClass = CoffGetClass(&curr->sym);

	cmp	DWORD PTR [rbx+32], 2
	jne	SHORT $LN94@coff_write
	test	BYTE PTR [rbx+47], 4
	jne	SHORT $LN96@coff_write
	cmp	QWORD PTR [rbx+64], r13
	je	SHORT $LN96@coff_write
	mov	eax, 105				; 00000069H
	jmp	SHORT $LN93@coff_write
$LN96@coff_write:
	mov	eax, edi
	jmp	SHORT $LN93@coff_write
$LN94@coff_write:
	test	BYTE PTR [rbx+40], 128			; 00000080H
	je	SHORT $LN98@coff_write
	movzx	eax, di
	jmp	SHORT $LN93@coff_write
$LN98@coff_write:
	cmp	DWORD PTR [rbx+36], 129			; 00000081H
	jne	SHORT $LN100@coff_write
	test	BYTE PTR [rbx+41], 8
	jne	SHORT $LN100@coff_write
	mov	eax, 6
	jmp	SHORT $LN93@coff_write
$LN100@coff_write:
	movzx	eax, r12w
$LN93@coff_write:
	mov	BYTE PTR is$[rsp+16], al

; 544  : 
; 545  :         DebugMsg(("coff_write_symbols(%u, EXT+COMM): %s, type=%x, stgcls=%x\n", cntSymbols, curr->sym.name, is.Type, is.StorageClass ));
; 546  : 
; 547  :         /* for COMMUNALs, store their size in the Value field */
; 548  :         if (curr->sym.iscomm == TRUE)

	test	BYTE PTR [rbx+47], 4
	je	SHORT $LN37@coff_write

; 549  :             is.Value = curr->sym.total_size;

	mov	eax, DWORD PTR [rbx+56]
	jmp	SHORT $LN178@coff_write
$LN37@coff_write:

; 550  :         else
; 551  :             is.Value = curr->sym.offset; /* is always 0 */

	mov	eax, DWORD PTR [rbx+16]
$LN178@coff_write:
	mov	DWORD PTR is$[rsp+8], eax

; 552  :         is.SectionNumber = IMAGE_SYM_UNDEFINED;

	mov	WORD PTR is$[rsp+12], r13w

; 553  :         is.NumberOfAuxSymbols = (( curr->sym.iscomm == FALSE && curr->sym.altname ) ? 1 : 0 );

	test	BYTE PTR [rbx+47], 4
	jne	SHORT $LN76@coff_write
	cmp	QWORD PTR [rbx+64], r13
	mov	BYTE PTR is$[rsp+17], 1
	jne	SHORT $LN77@coff_write
$LN76@coff_write:
	mov	BYTE PTR is$[rsp+17], r13b
$LN77@coff_write:

; 554  : 
; 555  :         if ( len <= IMAGE_SIZEOF_SHORT_NAME )

	cmp	edx, 8
	ja	SHORT $LN39@coff_write

; 556  :             strncpy( is.N.ShortName, buffer, IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR is$[rsp]
	call	strncpy
	jmp	SHORT $LN40@coff_write
$LN39@coff_write:

; 557  :         else {
; 558  :             is.N.Name.Short = 0;
; 559  :             is.N.Name.Long = Coff_AllocString( cm, buffer, len );

	mov	edi, DWORD PTR [r14+112]
	lea	rcx, QWORD PTR [rdx+16]
	mov	DWORD PTR is$[rsp], r13d
	lea	eax, DWORD PTR [rdi+1]
	add	eax, edx
	mov	DWORD PTR [r14+112], eax
	call	LclAlloc
	mov	r8, rax
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, r8
	mov	QWORD PTR [rax], r13
	lea	rax, QWORD PTR buffer$[rsp]
	sub	rcx, rax
	lea	rax, QWORD PTR [rcx+8]
	npad	5
$LL106@coff_write:
	movzx	ecx, BYTE PTR [rdx]
	mov	BYTE PTR [rdx+rax], cl
	lea	rdx, QWORD PTR [rdx+1]
	test	cl, cl
	jne	SHORT $LL106@coff_write
	cmp	QWORD PTR [r14+96], r13
	je	SHORT $LN103@coff_write
	mov	rax, QWORD PTR [r14+104]
	mov	QWORD PTR [rax], r8
	jmp	SHORT $LN179@coff_write
$LN103@coff_write:
	mov	QWORD PTR [r14+96], r8
$LN179@coff_write:
	mov	DWORD PTR is$[rsp+4], edi
	mov	edi, 2
	mov	QWORD PTR [r14+104], r8
$LN40@coff_write:

; 560  :         }
; 561  :         if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR is$[rsp]
	mov	r8d, 18
	mov	rdx, rsi
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN41@coff_write

; 562  :             WriteError();

	call	WriteError
$LN41@coff_write:

; 563  :         cntSymbols++;

	inc	r15d

; 564  : 
; 565  :         /* for weak externals, write the auxiliary record */
; 566  :         if ( curr->sym.iscomm == FALSE && curr->sym.altname ) {

	test	BYTE PTR [rbx+47], 4
	jne	SHORT $LN8@coff_write
	cmp	QWORD PTR [rbx+64], r13
	je	SHORT $LN8@coff_write

; 567  :             memset( &ias, 0, sizeof(ias) );
; 568  :             ias.Sym.TagIndex = curr->sym.altname->ext_idx;
; 569  :             /* v2.10: weak externals defined via "extern sym (altsym) ..."
; 570  :              * are to have characteristics IMAGE_WEAK_EXTERN_SEARCH_LIBRARY.
; 571  :              */
; 572  :             //ias.Sym.Misc.TotalSize = IMAGE_WEAK_EXTERN_SEARCH_ALIAS;
; 573  :             ias.Sym.Misc.TotalSize = IMAGE_WEAK_EXTERN_SEARCH_LIBRARY;
; 574  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	r9, QWORD PTR ModuleInfo+104
	xor	eax, eax
	mov	QWORD PTR ias$[rsp], rax
	mov	r8d, 18
	mov	QWORD PTR ias$[rsp+8], rax
	mov	rdx, rsi
	mov	WORD PTR ias$[rsp+16], ax
	mov	rax, QWORD PTR [rbx+64]
	mov	ecx, DWORD PTR [rax+88]
	mov	DWORD PTR ias$[rsp], ecx
	lea	rcx, QWORD PTR ias$[rsp]
	mov	DWORD PTR ias$[rsp+4], edi
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN43@coff_write

; 575  :                 WriteError();

	call	WriteError
$LN43@coff_write:

; 576  :             cntSymbols++;

	inc	r15d
$LN8@coff_write:

; 529  :         }
; 530  :     }
; 531  : 
; 532  :     /* third are externals + communals ( + protos [since v2.01] ) */
; 533  : 
; 534  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	$LL10@coff_write
$LN9@coff_write:

; 577  :         }
; 578  :     }
; 579  : 
; 580  :     /* publics and internal symbols. The internal symbols have
; 581  :      * been written to the "public" queue inside coff_write_data().
; 582  :      */
; 583  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	r13, QWORD PTR ModuleInfo+16
	test	r13, r13
	je	$LN176@coff_write
	mov	edi, DWORD PTR lastfile$1$[rbp-256]
	npad	3
$LL13@coff_write:

; 584  :         sym = q->sym;

	mov	rsi, QWORD PTR [r13+8]

; 585  :         len = Mangle( sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rsi
	call	Mangle

; 586  : #ifdef DEBUG_OUT
; 587  :         if ( sym->state == SYM_INTERNAL && sym->isproc == TRUE && Options.line_numbers )
; 588  :             DebugMsg(("coff_write_symbols(%u): %s, file=%u\n", cntSymbols, sym->name, sym->debuginfo->file ));
; 589  : #endif
; 590  :         if ( Options.line_numbers &&
; 591  :             sym->isproc &&

	cmp	BYTE PTR Options+1, 0
	movsxd	r12, eax
	je	$LN44@coff_write
	test	BYTE PTR [rsi+41], 8
	je	$LN44@coff_write
	mov	rcx, QWORD PTR [rsi+64]
	movzx	edx, WORD PTR [rcx+14]
	cmp	edx, edi
	je	$LN44@coff_write

; 592  :             sym->debuginfo->file != lastfile ) {
; 593  :             lastfile = sym->debuginfo->file;

	mov	DWORD PTR lastfile$1$[rbp-256], edx

; 594  :             strncpy( is.N.ShortName, ".file", IMAGE_SIZEOF_SHORT_NAME );

	lea	rcx, QWORD PTR is$[rsp]
	lea	rdx, OFFSET FLAT:$SG11651
	mov	r8d, 8
	call	strncpy

; 595  :             is.SectionNumber = (uint_16)IMAGE_SYM_DEBUG;

	mov	DWORD PTR is$[rsp+12], 65534		; 0000fffeH

; 596  :             is.Type = IMAGE_SYM_TYPE_NULL;
; 597  :             is.StorageClass = IMAGE_SYM_CLASS_FILE;

	mov	BYTE PTR is$[rsp+16], 103		; 00000067H

; 598  :             is.NumberOfAuxSymbols = GetFileAuxEntries( sym->debuginfo->file, &p );

	mov	rax, QWORD PTR [rsi+64]
	movzx	ecx, WORD PTR [rax+14]
	call	GetFName
	mov	rbx, QWORD PTR [rax]
	or	rax, -1
	npad	7
$LL172@coff_write:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL172@coff_write

; 599  :             is.Value = sym->debuginfo->next_file;
; 600  :             if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	ecx, eax
	mov	rax, -2049638230412172401		; e38e38e38e38e38fH
	mul	rcx
	shr	rdx, 4
	lea	rax, QWORD PTR [rdx+rdx*8]
	add	rax, rax
	sub	rcx, rax
	setne	al
	add	al, dl
	mov	edx, 1
	mov	BYTE PTR is$[rsp+17], al
	mov	rax, QWORD PTR [rsi+64]
	lea	r8d, QWORD PTR [rdx+17]
	mov	ecx, DWORD PTR [rax+20]
	mov	DWORD PTR is$[rsp+8], ecx
	lea	rcx, QWORD PTR is$[rsp]
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN45@coff_write

; 601  :                 WriteError();

	call	WriteError
$LN45@coff_write:

; 602  : 
; 603  :             for ( i = is.NumberOfAuxSymbols; i; i--, p += sizeof(IMAGE_AUX_SYMBOL) ) {

	movzx	eax, BYTE PTR is$[rsp+17]
	mov	edi, eax
	test	al, al
	je	SHORT $LN15@coff_write
	npad	6
$LL16@coff_write:

; 604  :                 strncpy( ias.File.Name, p, sizeof(IMAGE_AUX_SYMBOL) );

	mov	r8d, 18
	lea	rcx, QWORD PTR ias$[rsp]
	mov	rdx, rbx
	call	strncpy

; 605  :                 if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR ias$[rsp]
	mov	edx, 1
	lea	r8d, QWORD PTR [rdx+17]
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN14@coff_write

; 606  :                     WriteError();

	call	WriteError
$LN14@coff_write:

; 602  : 
; 603  :             for ( i = is.NumberOfAuxSymbols; i; i--, p += sizeof(IMAGE_AUX_SYMBOL) ) {

	add	rbx, 18
	add	edi, -1					; ffffffffH
	jne	SHORT $LL16@coff_write
	movzx	eax, BYTE PTR is$[rsp+17]
$LN15@coff_write:
	mov	edi, DWORD PTR lastfile$1$[rbp-256]

; 607  :             }
; 608  :             cntSymbols += is.NumberOfAuxSymbols + 1;

	inc	r15d
	movzx	eax, al
	add	r15d, eax
$LN44@coff_write:

; 609  :         }
; 610  :         is.Type = CoffGetType( sym );

	xor	ebx, ebx
	mov	ecx, 32					; 00000020H
	test	BYTE PTR [rsi+41], 8
	movzx	eax, bx
	cmovne	ax, cx
	mov	WORD PTR is$[rsp+14], ax

; 611  :         is.StorageClass = CoffGetClass( sym );

	cmp	DWORD PTR [rsi+32], 2
	jne	SHORT $LN114@coff_write
	test	BYTE PTR [rsi+47], 4
	jne	SHORT $LN116@coff_write
	cmp	QWORD PTR [rsi+64], rbx
	je	SHORT $LN116@coff_write
	lea	eax, QWORD PTR [rbx+105]
	jmp	SHORT $LN113@coff_write
$LN114@coff_write:
	test	BYTE PTR [rsi+40], 128			; 00000080H
	je	SHORT $LN118@coff_write
$LN116@coff_write:
	mov	eax, 2
	jmp	SHORT $LN113@coff_write
$LN118@coff_write:
	cmp	DWORD PTR [rsi+36], 129			; 00000081H
	jne	SHORT $LN120@coff_write
	test	BYTE PTR [rsi+41], 8
	mov	eax, 6
	je	SHORT $LN113@coff_write
$LN120@coff_write:
	mov	eax, 3
$LN113@coff_write:
	mov	BYTE PTR is$[rsp+16], al

; 612  :         is.Value = sym->offset;

	mov	eax, DWORD PTR [rsi+16]
	mov	DWORD PTR is$[rsp+8], eax

; 613  : #if 1 /* v2.07: changed - to make MT_ABS obsolete */
; 614  :         if ( sym->state == SYM_INTERNAL ) {

	cmp	DWORD PTR [rsi+32], 1
	jne	SHORT $LN47@coff_write

; 615  :             if ( sym->segment )

	mov	rcx, QWORD PTR [rsi+24]
	test	rcx, rcx
	je	SHORT $LN49@coff_write

; 616  :                 is.SectionNumber = GetSegIdx( sym->segment );

	call	GetSegIdx
	mov	WORD PTR is$[rsp+12], ax
	jmp	SHORT $LN48@coff_write
$LN49@coff_write:

; 617  :             else
; 618  :                 is.SectionNumber = (uint_16)IMAGE_SYM_ABSOLUTE;

	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR is$[rsp+12], ax

; 619  :         } else

	jmp	SHORT $LN48@coff_write
$LN47@coff_write:

; 620  :             is.SectionNumber = IMAGE_SYM_UNDEFINED;

	mov	WORD PTR is$[rsp+12], bx
$LN48@coff_write:

; 621  : #else
; 622  :         if ( sym->state == SYM_EXTERNAL )
; 623  :             is.SectionNumber = IMAGE_SYM_UNDEFINED;
; 624  :         else if ( sym->mem_type == MT_ABS )
; 625  :             is.SectionNumber = IMAGE_SYM_ABSOLUTE;
; 626  :         else if ( sym->segment )
; 627  :             is.SectionNumber = GetSegIdx( sym->segment );
; 628  :         else
; 629  :             is.SectionNumber = IMAGE_SYM_UNDEFINED;
; 630  : #endif
; 631  :         is.NumberOfAuxSymbols = 0;

	xor	cl, cl

; 632  :         if ( Options.line_numbers && sym->isproc )

	cmp	BYTE PTR Options+1, cl
	mov	BYTE PTR is$[rsp+17], cl
	je	SHORT $LN51@coff_write
	movzx	eax, BYTE PTR [rsi+41]
	and	al, 8
	movzx	ecx, cl
	mov	eax, 1
	cmovne	ecx, eax
	mov	BYTE PTR is$[rsp+17], cl
$LN51@coff_write:

; 633  :             is.NumberOfAuxSymbols++;
; 634  : 
; 635  :         if ( len <= IMAGE_SIZEOF_SHORT_NAME )

	cmp	r12d, 8
	ja	SHORT $LN52@coff_write

; 636  :             strncpy( is.N.ShortName, buffer, IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR is$[rsp]
	call	strncpy
	jmp	SHORT $LN53@coff_write
$LN52@coff_write:

; 637  :         else {
; 638  :             is.N.Name.Short = 0;

	mov	DWORD PTR is$[rsp], ebx

; 639  :             is.N.Name.Long = Coff_AllocString( cm, buffer, len );

	lea	rcx, QWORD PTR [r12+16]
	mov	ebx, DWORD PTR [r14+112]
	lea	eax, DWORD PTR [rbx+1]
	add	eax, r12d
	mov	DWORD PTR [r14+112], eax
	call	LclAlloc
	mov	r8, rax
	lea	rdx, QWORD PTR buffer$[rsp]
	xor	eax, eax
	mov	rcx, r8
	mov	QWORD PTR [r8], rax
	lea	rax, QWORD PTR buffer$[rsp]
	sub	rcx, rax
	lea	rax, QWORD PTR [rcx+8]
	npad	8
$LL126@coff_write:
	movzx	ecx, BYTE PTR [rdx]
	mov	BYTE PTR [rdx+rax], cl
	lea	rdx, QWORD PTR [rdx+1]
	test	cl, cl
	jne	SHORT $LL126@coff_write
	cmp	QWORD PTR [r14+96], 0
	je	SHORT $LN123@coff_write
	mov	rax, QWORD PTR [r14+104]
	mov	QWORD PTR [rax], r8
	jmp	SHORT $LN180@coff_write
$LN123@coff_write:
	mov	QWORD PTR [r14+96], r8
$LN180@coff_write:
	mov	DWORD PTR is$[rsp+4], ebx
	xor	ebx, ebx
	mov	QWORD PTR [r14+104], r8
$LN53@coff_write:

; 640  :         }
; 641  : 
; 642  :         DebugMsg(("coff_write_symbols(%u, PUB+INT): %s, ofs=%X, type=%X, stgcls=%X\n", cntSymbols, buffer, is.Value, is.Type, is.StorageClass ));
; 643  : 
; 644  :         if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR is$[rsp]
	mov	r12d, 1
	mov	r8d, 18
	mov	edx, r12d
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN54@coff_write

; 645  :             WriteError();

	call	WriteError
$LN54@coff_write:

; 646  :         cntSymbols++;

	inc	r15d

; 647  :         if ( Options.line_numbers && sym->isproc ) {

	cmp	BYTE PTR Options+1, 0
	je	$LN11@coff_write
	test	BYTE PTR [rsi+41], 8
	je	$LN11@coff_write

; 648  :             /* write:
; 649  :              * 1.   the aux for the proc
; 650  :              * 2+3. a .bf record with 1 aux
; 651  :              * 4.   a .lf record with 0 aux
; 652  :              * 5+6. a .ef record with 1 aux
; 653  :              */
; 654  :             ias.Sym.TagIndex = cntSymbols+1;
; 655  :             ias.Sym.Misc.TotalSize = sym->total_size;
; 656  :             ias.Sym.FcnAry.Function.PointerToLinenumber = sym->debuginfo->ln_fileofs;
; 657  :             ias.Sym.FcnAry.Function.PointerToNextFunction = sym->debuginfo->next_proc;
; 658  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	eax, DWORD PTR [r15+1]
	mov	DWORD PTR ias$[rsp], eax
	mov	r8d, 18
	mov	eax, DWORD PTR [rsi+56]
	mov	rdx, r12
	mov	DWORD PTR ias$[rsp+4], eax
	mov	rax, QWORD PTR [rsi+64]
	mov	ecx, DWORD PTR [rax+8]
	mov	DWORD PTR ias$[rsp+8], ecx
	mov	rax, QWORD PTR [rsi+64]
	mov	ecx, DWORD PTR [rax+16]
	mov	DWORD PTR ias$[rsp+12], ecx
	lea	rcx, QWORD PTR ias$[rsp]
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN56@coff_write

; 659  :                 WriteError();

	call	WriteError
$LN56@coff_write:

; 660  : 
; 661  :             strncpy( is.N.ShortName, ".bf", IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG11664
	lea	rcx, QWORD PTR is$[rsp]
	call	strncpy

; 662  :             is.Type = IMAGE_SYM_TYPE_NULL;
; 663  :             is.NumberOfAuxSymbols = 1;
; 664  :             is.StorageClass = IMAGE_SYM_CLASS_FUNCTION;
; 665  :             if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR is$[rsp]
	mov	r8d, 18
	mov	DWORD PTR is$[rsp+14], 23396352		; 01650000H
	mov	rdx, r12
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN57@coff_write

; 666  :                 WriteError();

	call	WriteError
$LN57@coff_write:

; 667  :             ias.Sym.TagIndex = 0;

	mov	DWORD PTR ias$[rsp], ebx

; 668  :             ias.Sym.Misc.LnSz.Linenumber = sym->debuginfo->start_line;

	mov	rax, QWORD PTR [rsi+64]
	movzx	ecx, WORD PTR [rax]
	mov	WORD PTR ias$[rsp+4], cx

; 669  :             if ( sym->debuginfo->next_proc )

	mov	rax, QWORD PTR [rsi+64]
	mov	eax, DWORD PTR [rax+16]
	test	eax, eax
	je	SHORT $LN58@coff_write

; 670  :                 ias.Sym.FcnAry.Function.PointerToNextFunction = sym->debuginfo->next_proc + 2;

	add	eax, 2
	mov	DWORD PTR ias$[rsp+12], eax
	jmp	SHORT $LN59@coff_write
$LN58@coff_write:

; 671  :             else
; 672  :                 ias.Sym.FcnAry.Function.PointerToNextFunction = 0;

	mov	DWORD PTR ias$[rsp+12], ebx
$LN59@coff_write:

; 673  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR ias$[rsp]
	mov	r8d, 18
	mov	rdx, r12
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN60@coff_write

; 674  :                 WriteError();

	call	WriteError
$LN60@coff_write:

; 675  : 
; 676  :             strncpy( is.N.ShortName, ".lf", IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG11669
	lea	rcx, QWORD PTR is$[rsp]
	call	strncpy

; 677  :             is.Type = IMAGE_SYM_TYPE_NULL;
; 678  :             is.NumberOfAuxSymbols = 0;
; 679  :             is.StorageClass = IMAGE_SYM_CLASS_FUNCTION;
; 680  :             is.Value = sym->debuginfo->line_numbers;
; 681  :             if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	r8d, 18
	mov	DWORD PTR is$[rsp+14], 6619136		; 00650000H
	mov	rdx, r12
	mov	rax, QWORD PTR [rsi+64]
	movzx	ecx, WORD PTR [rax+12]
	mov	DWORD PTR is$[rsp+8], ecx
	lea	rcx, QWORD PTR is$[rsp]
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN61@coff_write

; 682  :                 WriteError();

	call	WriteError
$LN61@coff_write:

; 683  : 
; 684  :             strncpy( is.N.ShortName, ".ef", IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG11671
	lea	rcx, QWORD PTR is$[rsp]
	call	strncpy

; 685  :             is.Type = IMAGE_SYM_TYPE_NULL;
; 686  :             is.NumberOfAuxSymbols = 1;
; 687  :             is.StorageClass = IMAGE_SYM_CLASS_FUNCTION;
; 688  :             is.Value = sym->offset + sym->total_size;
; 689  :             if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR is$[rsp]
	mov	DWORD PTR is$[rsp+14], 23396352		; 01650000H
	mov	r8d, 18
	mov	eax, DWORD PTR [rsi+56]
	mov	rdx, r12
	add	eax, DWORD PTR [rsi+16]
	mov	DWORD PTR is$[rsp+8], eax
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN62@coff_write

; 690  :                 WriteError();

	call	WriteError
$LN62@coff_write:

; 691  :             ias.Sym.TagIndex = 0;
; 692  :             ias.Sym.Misc.LnSz.Linenumber = sym->debuginfo->end_line;
; 693  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	r8d, 18
	mov	DWORD PTR ias$[rsp], ebx
	mov	rdx, r12
	mov	rax, QWORD PTR [rsi+64]
	movzx	ecx, WORD PTR [rax+4]
	mov	WORD PTR ias$[rsp+4], cx
	lea	rcx, QWORD PTR ias$[rsp]
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN63@coff_write

; 694  :                 WriteError();

	call	WriteError
$LN63@coff_write:

; 695  : 
; 696  :             cntSymbols += 6;

	add	r15d, 6
$LN11@coff_write:

; 577  :         }
; 578  :     }
; 579  : 
; 580  :     /* publics and internal symbols. The internal symbols have
; 581  :      * been written to the "public" queue inside coff_write_data().
; 582  :      */
; 583  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	r13, QWORD PTR [r13]
	test	r13, r13
	jne	$LL13@coff_write
	jmp	SHORT $LN12@coff_write
$LN176@coff_write:
	mov	r12d, 1
$LN12@coff_write:

; 697  :         }
; 698  :     }
; 699  : 
; 700  :     /* aliases. A weak external entry with 1 aux entry is created.
; 701  :      */
; 702  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+80
	test	rbx, rbx
	je	$LN175@coff_write
	xor	esi, esi
	npad	5
$LL19@coff_write:

; 703  :         struct asym * sym;
; 704  : 
; 705  :         len = Mangle( &curr->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbx
	call	Mangle
	movsxd	rcx, eax

; 706  : 
; 707  :         if ( len <= IMAGE_SIZEOF_SHORT_NAME )

	cmp	ecx, 8
	ja	SHORT $LN64@coff_write

; 708  :             strncpy( is.N.ShortName, buffer, IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR is$[rsp]
	call	strncpy
	jmp	SHORT $LN65@coff_write
$LN64@coff_write:

; 709  :         else {
; 710  :             is.N.Name.Short = 0;
; 711  :             is.N.Name.Long = Coff_AllocString( cm, buffer, len );

	mov	edi, DWORD PTR [r14+112]
	mov	DWORD PTR is$[rsp], esi
	lea	eax, DWORD PTR [rdi+1]
	add	eax, ecx
	add	rcx, 16
	mov	DWORD PTR [r14+112], eax
	call	LclAlloc
	mov	rdx, rax
	lea	r8, QWORD PTR buffer$[rsp]
	mov	rcx, rdx
	sub	rcx, r8
	mov	QWORD PTR [rax], rsi
	lea	rax, QWORD PTR buffer$[rsp]
	lea	r8, QWORD PTR [rcx+8]
$LL131@coff_write:
	movzx	ecx, BYTE PTR [rax]
	mov	BYTE PTR [rax+r8], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL131@coff_write
	cmp	QWORD PTR [r14+96], rsi
	je	SHORT $LN128@coff_write
	mov	rax, QWORD PTR [r14+104]
	mov	QWORD PTR [rax], rdx
	jmp	SHORT $LN181@coff_write
$LN128@coff_write:
	mov	QWORD PTR [r14+96], rdx
$LN181@coff_write:
	mov	QWORD PTR [r14+104], rdx
	mov	DWORD PTR is$[rsp+4], edi
$LN65@coff_write:

; 712  :         }
; 713  : 
; 714  :         is.Value = 0;
; 715  :         is.SectionNumber = IMAGE_SYM_UNDEFINED;
; 716  :         is.Type = IMAGE_SYM_TYPE_NULL;
; 717  :         is.StorageClass = IMAGE_SYM_CLASS_WEAK_EXTERNAL;
; 718  :         is.NumberOfAuxSymbols = 1;
; 719  : 
; 720  :         DebugMsg(("coff_write_symbols(%u, ALIAS): symbol %s, ofs=%X\n", cntSymbols, buffer, is.Value ));
; 721  : 
; 722  :         if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR is$[rsp]
	mov	r8d, 18
	mov	QWORD PTR is$[rsp+8], rsi
	mov	rdx, r12
	mov	WORD PTR is$[rsp+16], 361		; 00000169H
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN66@coff_write

; 723  :             WriteError();

	call	WriteError
$LN66@coff_write:

; 724  :         cntSymbols++;
; 725  : 
; 726  :         memset( &ias, 0, sizeof(ias) );

	xor	eax, eax
	mov	QWORD PTR ias$[rsp], rax
	mov	QWORD PTR ias$[rsp+8], rax
	mov	WORD PTR ias$[rsp+16], ax

; 727  : 
; 728  :         /* v2.04b: adjusted to new field <substitute> */
; 729  :         //sym = SymSearch( curr->sym.string_ptr );
; 730  :         sym = curr->sym.substitute;

	mov	rax, QWORD PTR [rbx+16]

; 731  :         if (sym)

	test	rax, rax
	je	SHORT $LN67@coff_write

; 732  :             ias.Sym.TagIndex = sym->ext_idx;

	mov	eax, DWORD PTR [rax+88]
	mov	DWORD PTR ias$[rsp], eax
$LN67@coff_write:

; 733  : 
; 734  :         ias.Sym.Misc.TotalSize = IMAGE_WEAK_EXTERN_SEARCH_ALIAS;
; 735  :         if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR ias$[rsp]
	mov	eax, 3
	mov	rdx, r12
	mov	DWORD PTR ias$[rsp+4], eax
	lea	r8d, QWORD PTR [rax+15]
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN68@coff_write

; 736  :             WriteError();

	call	WriteError
$LN68@coff_write:

; 697  :         }
; 698  :     }
; 699  : 
; 700  :     /* aliases. A weak external entry with 1 aux entry is created.
; 701  :      */
; 702  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+104]

; 737  :         cntSymbols++;

	add	r15d, 2
	test	rbx, rbx
	jne	$LL19@coff_write
$LN175@coff_write:

; 738  : 
; 739  :     }
; 740  : 
; 741  :     DebugMsg(("coff_write_symbols: exit cntSymbols=%u\n", cntSymbols ));
; 742  :     return( cntSymbols );

	mov	eax, r15d

; 743  : }

	mov	rbx, QWORD PTR [rsp+400]
	add	rsp, 336				; 00000150H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
coff_write_symbols ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
;	COMDAT CRC32Comdat
_TEXT	SEGMENT
lpBuffer$ = 48
dwBufLen$ = 56
dwCRC$ = 64
CRC32Comdat PROC					; COMDAT

; 388  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 389  :     static bool init = FALSE;
; 390  :     uint_8 byt;
; 391  : 
; 392  :     if ( !init ) {

	cmp	BYTE PTR ?init@?1??CRC32Comdat@@9@9, 0
	mov	r11d, r8d
	mov	edi, edx
	mov	rbx, rcx
	jne	SHORT $LN5@CRC32Comda

; 393  :         init = TRUE;

	mov	BYTE PTR ?init@?1??CRC32Comdat@@9@9, 1

; 394  :         InitCRC32();

	call	InitCRC32
$LN5@CRC32Comda:

; 395  :     }
; 396  :     if ( lpBuffer ) /* v2.11: lpBuffer may be NULL ( uninitialized data segs ) */

	test	rbx, rbx
	je	SHORT $LN12@CRC32Comda

; 397  :         for ( ; dwBufLen; dwBufLen-- ) {

	test	edi, edi
	je	SHORT $LN12@CRC32Comda
	lea	rdx, OFFSET FLAT:CRC32Table
	npad	9
$LL4@CRC32Comda:

; 398  :             byt = *lpBuffer++;

	movzx	eax, BYTE PTR [rbx]
	lea	rbx, QWORD PTR [rbx+1]

; 399  :             byt = byt ^ (uint_8)dwCRC;
; 400  :             dwCRC = dwCRC >> 8;
; 401  :             dwCRC = dwCRC ^ CRC32Table[byt];

	movzx	ecx, r11b
	xor	rcx, rax
	mov	eax, r11d
	shr	eax, 8
	mov	r11d, DWORD PTR [rdx+rcx*4]
	xor	r11d, eax
	add	edi, -1					; ffffffffH
	jne	SHORT $LL4@CRC32Comda
$LN12@CRC32Comda:

; 402  :         }
; 403  :     return( dwCRC );

	mov	eax, r11d

; 404  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CRC32Comdat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
;	COMDAT InitCRC32
_TEXT	SEGMENT
InitCRC32 PROC						; COMDAT

; 376  :     int i,j;
; 377  :     uint_32 crc;
; 378  :     for ( i = 0; i < 256; i++ ) {

	xor	r9d, r9d
	lea	r10, OFFSET FLAT:CRC32Table
	npad	6
$LL4@InitCRC32:

; 379  :         for ( j = 0, crc = i; j < 8; j++ ) {
; 380  :             crc = ( crc >> 1 ) ^ (0xEDB88320 * ( crc & 1 ) );

	mov	eax, r9d
	lea	r10, QWORD PTR [r10+4]
	and	eax, 1
	imul	ecx, eax, -306674912			; edb88320H
	mov	eax, r9d
	shr	eax, 1
	inc	r9d
	xor	ecx, eax
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	imul	edx, eax, -306674912			; edb88320H
	xor	edx, ecx
	mov	eax, edx
	shr	edx, 1
	and	eax, 1
	imul	ecx, eax, -306674912			; edb88320H
	xor	ecx, edx
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	imul	edx, eax, -306674912			; edb88320H
	xor	edx, ecx
	mov	eax, edx
	shr	edx, 1
	and	eax, 1
	imul	ecx, eax, -306674912			; edb88320H
	xor	ecx, edx
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	imul	edx, eax, -306674912			; edb88320H
	xor	edx, ecx
	mov	eax, edx
	shr	edx, 1
	and	eax, 1
	imul	r8d, eax, -306674912			; edb88320H
	xor	r8d, edx
	mov	eax, r8d
	shr	r8d, 1
	and	eax, 1
	imul	ecx, eax, -306674912			; edb88320H
	xor	ecx, r8d

; 381  :         }
; 382  :         CRC32Table[i] = crc;

	mov	DWORD PTR [r10-4], ecx
	cmp	r9d, 256				; 00000100H
	jl	$LL4@InitCRC32

; 383  :     }
; 384  : }

	ret	0
InitCRC32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
;	COMDAT GetFileAuxEntries
_TEXT	SEGMENT
file$ = 48
tv76 = 56
fname$ = 56
GetFileAuxEntries PROC					; COMDAT

; 356  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 357  :     const struct fname_item *curr;
; 358  :     unsigned len;
; 359  :     curr = GetFName( file );

	movzx	ecx, cx
	mov	rbx, rdx
	call	GetFName

; 360  :     if ( fname )

	test	rbx, rbx
	je	SHORT $LN2@GetFileAux

; 361  :         *fname = curr->fname;

	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rbx], rcx
$LN2@GetFileAux:

; 362  :     len = strlen( curr->fname );

	mov	rcx, QWORD PTR [rax]
	or	rax, -1
$LL4@GetFileAux:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL4@GetFileAux

; 363  :     /**/myassert( len ); /* name length must be > 0 */
; 364  :     return ( len / sizeof( IMAGE_AUX_SYMBOL ) + ( len % sizeof( IMAGE_AUX_SYMBOL ) ? 1 : 0 ) );

	mov	ecx, eax
	mov	rax, -2049638230412172401		; e38e38e38e38e38fH
	mul	rcx
	shr	rdx, 4
	lea	rax, QWORD PTR [rdx+rdx*8]
	add	rax, rax
	sub	rcx, rax
	mov	eax, 0
	setne	al
	add	rax, rdx

; 365  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
GetFileAuxEntries ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
;	COMDAT CoffGetClass
_TEXT	SEGMENT
sym$ = 8
CoffGetClass PROC					; COMDAT

; 333  :     if ( sym->state == SYM_EXTERNAL )

	cmp	DWORD PTR [rcx+32], 2
	jne	SHORT $LN2@CoffGetCla

; 334  :         if ( sym->iscomm == FALSE && sym->altname )

	test	BYTE PTR [rcx+47], 4
	jne	SHORT $LN4@CoffGetCla
	cmp	QWORD PTR [rcx+64], 0
	je	SHORT $LN4@CoffGetCla

; 335  :             return( IMAGE_SYM_CLASS_WEAK_EXTERNAL );

	mov	eax, 105				; 00000069H

; 350  : }

	ret	0
$LN4@CoffGetCla:

; 336  :         else
; 337  :             return( IMAGE_SYM_CLASS_EXTERNAL );

	mov	eax, 2

; 350  : }

	ret	0
$LN2@CoffGetCla:

; 338  :     else if ( sym->ispublic == TRUE )

	test	BYTE PTR [rcx+40], 128			; 00000080H
	jne	SHORT $LN4@CoffGetCla

; 339  :         return( IMAGE_SYM_CLASS_EXTERNAL );
; 340  : #if HELPSYMS
; 341  :     else if ( sym->variable == TRUE ) /* assembly time variable in fixup */
; 342  :         return( IMAGE_SYM_CLASS_LABEL );
; 343  : #endif
; 344  :     /* v2.09: don't declare private procs as label */
; 345  :     //else if ( sym->mem_type == MT_NEAR )/* added v2.0 */
; 346  :     else if ( sym->mem_type == MT_NEAR && sym->isproc == FALSE )

	cmp	DWORD PTR [rcx+36], 129			; 00000081H
	jne	SHORT $LN8@CoffGetCla
	test	BYTE PTR [rcx+41], 8

; 347  :         return( IMAGE_SYM_CLASS_LABEL );

	mov	eax, 6
	je	SHORT $LN1@CoffGetCla
$LN8@CoffGetCla:

; 348  : 
; 349  :     return( IMAGE_SYM_CLASS_STATIC );

	mov	eax, 3
$LN1@CoffGetCla:

; 350  : }

	ret	0
CoffGetClass ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
;	COMDAT CoffGetType
_TEXT	SEGMENT
sym$ = 8
CoffGetType PROC					; COMDAT

; 308  :     if ( sym->isproc )

	test	BYTE PTR [rcx+41], 8
	je	SHORT $LN2@CoffGetTyp

; 309  :         return( 0x20 );

	mov	eax, 32					; 00000020H

; 325  : }

	ret	0
$LN2@CoffGetTyp:

; 310  : 
; 311  : #if 0
; 312  :     switch (sym->mem_type) {
; 313  :     case MT_BYTE:
; 314  :     case MT_SBYTE:
; 315  :         return( IMAGE_SYM_TYPE_BYTE );
; 316  :     case MT_WORD:
; 317  :     case MT_SWORD:
; 318  :         return( IMAGE_SYM_TYPE_WORD );
; 319  :     case MT_DWORD:
; 320  :     case MT_SDWORD:
; 321  :         return( IMAGE_SYM_TYPE_DWORD );
; 322  :     }
; 323  : #endif
; 324  :     return( IMAGE_SYM_TYPE_NULL );

	xor	eax, eax

; 325  : }

	ret	0
CoffGetType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
;	COMDAT coff_write_section_table
_TEXT	SEGMENT
ish$ = 32
buffer$ = 80
segtype$ = 384
modinfo$ = 384
cm$ = 392
coff_write_section_table PROC				; COMDAT

; 148  : {

	mov	r11, rsp
	push	rbp
	push	rdi
	push	r14
	push	r15
	lea	rbp, QWORD PTR [r11-120]
	sub	rsp, 344				; 00000158H

; 149  :     struct dsym  *curr;
; 150  :     struct fixup *fix;
; 151  :     uint_32      fileoffset; /* calculated file offset for section data, relocs and linenumber info */
; 152  :     unsigned     len;
; 153  :     char         *secname;
; 154  :     //struct omf_rec  *objr;
; 155  :     //char        *p;
; 156  :     //uint        size_relocs = 0;
; 157  :     enum seg_type segtype;
; 158  :     struct IMAGE_SECTION_HEADER ish;
; 159  :     char buffer[MAX_ID_LEN+1];
; 160  : 
; 161  :     DebugMsg(("coff_write_section_table: enter, sections=%u\n", modinfo->g.num_segs ));
; 162  : 
; 163  :     fileoffset = sizeof( struct IMAGE_FILE_HEADER ) + modinfo->g.num_segs * sizeof( struct IMAGE_SECTION_HEADER );

	mov	eax, DWORD PTR [rcx+8]
	mov	r15, rdx
	lea	ecx, DWORD PTR [rax+rax*4]
	lea	r14d, DWORD PTR [rcx*8+20]

; 164  :     cm->start_data = fileoffset;

	mov	DWORD PTR [rdx+32], r14d

; 165  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdi, QWORD PTR SymTables+32
	test	rdi, rdi
	je	$LN67@coff_write
	mov	QWORD PTR [r11+16], rbx
	mov	QWORD PTR [r11+24], rsi
	mov	QWORD PTR [r11+32], r12
	xor	r12d, r12d
	mov	QWORD PTR [r11-40], r13
	mov	r13d, 65535				; 0000ffffH
	npad	14
$LL4@coff_write:

; 166  : 
; 167  :         /* v2.04: can't happen */
; 168  :         //if( curr->sym.state != SYM_SEG ) {
; 169  :         //    EmitErr( SEGMENT_NOT_DEFINED, curr->sym.name );
; 170  :         //    continue;
; 171  :         //}
; 172  :         segtype = SEGTYPE_UNDEF;

	mov	DWORD PTR segtype$[rbp-256], r12d

; 173  :         /* v2.07: prefer ALIAS name if defined. */
; 174  :         secname = ( curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ConvertSectionName( &curr->sym, &segtype, buffer ) );

	mov	rax, QWORD PTR [rdi+96]
	mov	rbx, QWORD PTR [rax+96]
	test	rbx, rbx
	jne	SHORT $LN38@coff_write
	lea	r8, QWORD PTR buffer$[rsp]
	mov	rcx, rdi
	lea	rdx, QWORD PTR segtype$[rbp-256]
	call	ConvertSectionName
	mov	rbx, rax
$LN38@coff_write:

; 175  :         len = strlen( secname );

	or	rcx, -1
	npad	1
$LL66@coff_write:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], r12b
	jne	SHORT $LL66@coff_write

; 176  :         /* if section name is longer than 8 chars, a '/' is stored,
; 177  :          followed by a number in ascii which is the offset for the string table
; 178  :          */
; 179  :         if ( len <= IMAGE_SIZEOF_SHORT_NAME )

	cmp	ecx, 8
	ja	SHORT $LN8@coff_write

; 180  :             strncpy( ish.Name, secname, IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rcx, QWORD PTR ish$[rsp]
	mov	rdx, rbx
	call	strncpy
	jmp	SHORT $LN9@coff_write
$LN8@coff_write:

; 181  :         else
; 182  :             sprintf( ish.Name, "/%u", Coff_AllocString( cm, secname, len ) );

	mov	esi, DWORD PTR [r15+112]
	lea	eax, DWORD PTR [rsi+1]
	add	eax, ecx
	movsxd	rcx, ecx
	add	rcx, 16
	mov	DWORD PTR [r15+112], eax
	call	LclAlloc
	mov	rdx, rax
	mov	r8, rax
	sub	rdx, rbx
	mov	QWORD PTR [rax], r12
	npad	8
$LL43@coff_write:
	movzx	ecx, BYTE PTR [rbx]
	mov	BYTE PTR [rdx+rbx+8], cl
	lea	rbx, QWORD PTR [rbx+1]
	test	cl, cl
	jne	SHORT $LL43@coff_write
	cmp	QWORD PTR [r15+96], r12
	je	SHORT $LN40@coff_write
	mov	rax, QWORD PTR [r15+104]
	mov	QWORD PTR [rax], r8
	mov	QWORD PTR [r15+104], r8
	jmp	SHORT $LN41@coff_write
$LN40@coff_write:
	mov	QWORD PTR [r15+104], rax
	mov	QWORD PTR [r15+96], rax
$LN41@coff_write:
	mov	r8d, esi
	lea	rdx, OFFSET FLAT:$SG11488
	lea	rcx, QWORD PTR ish$[rsp]
	call	sprintf
$LN9@coff_write:

; 183  : 
; 184  :         /* v2.04: what is the old line supposed to do? */
; 185  :         //ish.Misc.PhysicalAddress = fileoffset - (size_relocs + sizeof(struct IMAGE_FILE_HEADER) + ModuleInfo->g.num_segs * sizeof(struct IMAGE_SECTION_HEADER));
; 186  :         ish.Misc.PhysicalAddress = 0;

	mov	QWORD PTR ish$[rsp+8], r12

; 187  :         ish.VirtualAddress = 0;
; 188  :         ish.SizeOfRawData = curr->sym.max_offset;
; 189  :         ish.PointerToRawData = ( ish.SizeOfRawData ? fileoffset : 0 );

	mov	r11d, r12d
	mov	esi, DWORD PTR [rdi+56]

; 190  :         ish.PointerToRelocations = 0;
; 191  :         ish.PointerToLinenumbers = 0;
; 192  :         ish.NumberOfRelocations = 0;
; 193  :         ish.NumberOfLinenumbers = 0;
; 194  :         ish.Characteristics = 0;

	mov	edx, r12d
	test	esi, esi
	mov	DWORD PTR ish$[rsp+16], esi
	mov	QWORD PTR ish$[rsp+24], r12
	cmovne	r11d, r14d
	mov	DWORD PTR ish$[rsp+32], r12d
	mov	DWORD PTR ish$[rsp+20], r11d
	mov	DWORD PTR ish$[rsp+36], edx

; 195  : 
; 196  :         /* set field Characteristics; optionally reset PointerToRawData/SizeOfRawData */
; 197  :         if ( curr->e.seginfo->info ) {

	mov	rax, QWORD PTR [rdi+96]
	test	BYTE PTR [rax+107], 2
	je	SHORT $LN10@coff_write

; 198  :             /* v2.09: set "remove" flag for .drectve section, as it was done in v2.06 and earlier */
; 199  :             if ( curr == cm->directives )

	cmp	rdi, QWORD PTR [r15]
	mov	edx, 576				; 00000240H
	mov	eax, 2560				; 00000a00H
	cmove	edx, eax

; 200  :                 ish.Characteristics = ( IMAGE_SCN_LNK_INFO | IMAGE_SCN_LNK_REMOVE );
; 201  :             else
; 202  :                 ish.Characteristics = ( IMAGE_SCN_LNK_INFO | IMAGE_SCN_CNT_INITIALIZED_DATA );
; 203  :         } else {

	jmp	$LN68@coff_write
$LN10@coff_write:

; 204  :             if ( curr->e.seginfo->alignment != MAX_SEGALIGNMENT ) /* ABS not possible */

	movzx	eax, BYTE PTR [rax+106]
	cmp	al, 255					; 000000ffH
	je	SHORT $LN14@coff_write

; 205  :                 ish.Characteristics |= (uint_32)(curr->e.seginfo->alignment + 1) << 20;

	movzx	edx, al
	inc	edx
	shl	edx, 20
	mov	DWORD PTR ish$[rsp+36], edx
$LN14@coff_write:

; 206  : #if COMDATSUPP
; 207  :             if ( curr->e.seginfo->comdat_selection )

	mov	rax, QWORD PTR [rdi+96]
	test	BYTE PTR [rax+108], 56			; 00000038H
	je	SHORT $LN15@coff_write

; 208  :                 ish.Characteristics |= IMAGE_SCN_LNK_COMDAT;

	bts	edx, 12
	mov	DWORD PTR ish$[rsp+36], edx
$LN15@coff_write:

; 209  : #endif
; 210  :             if ( curr->e.seginfo->segtype == SEGTYPE_CODE ) {

	mov	r10, QWORD PTR [rdi+96]
	mov	ebx, DWORD PTR [r10+72]
	cmp	ebx, 1
	jne	SHORT $LN16@coff_write

; 211  :                 ish.Characteristics |= IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ;

	or	edx, 1610612768				; 60000020H
	jmp	$LN68@coff_write
$LN16@coff_write:

; 212  :             } else if ( curr->e.seginfo->readonly ) {

	test	BYTE PTR [r10+107], 1
	je	SHORT $LN18@coff_write

; 213  :                 ish.Characteristics |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;

	or	edx, 1073741888				; 40000040H
	jmp	$LN68@coff_write
$LN18@coff_write:

; 214  :             } else if ( curr->e.seginfo->clsym && strcmp( curr->e.seginfo->clsym->name, "CONST" ) == 0 ) {

	mov	rax, QWORD PTR [r10+80]
	test	rax, rax
	je	SHORT $LN20@coff_write
	mov	rax, QWORD PTR [rax+8]
	lea	r9, OFFSET FLAT:$SG11501
	sub	r9, rax
	npad	1
$LL64@coff_write:
	movzx	r8d, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r9]
	sub	r8d, ecx
	jne	SHORT $LN65@coff_write
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL64@coff_write
$LN65@coff_write:
	test	r8d, r8d
	jne	SHORT $LN20@coff_write

; 215  :                 ish.Characteristics |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;

	or	edx, 1073741888				; 40000040H
	jmp	SHORT $LN68@coff_write
$LN20@coff_write:

; 216  :             } else if ( curr->e.seginfo->segtype == SEGTYPE_BSS || segtype == SEGTYPE_BSS ) {

	cmp	ebx, 3
	je	SHORT $LN24@coff_write
	cmp	DWORD PTR segtype$[rbp-256], 3
	je	SHORT $LN24@coff_write

; 224  :             } else if ( curr->e.seginfo->combine == COMB_STACK && curr->e.seginfo->bytes_written == 0 ) {

	movzx	eax, BYTE PTR [r10+108]
	and	al, 7
	cmp	al, 5
	jne	SHORT $LN25@coff_write
	cmp	DWORD PTR [r10+24], r12d
	jne	SHORT $LN25@coff_write

; 225  :                 ish.Characteristics |= IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;
; 226  :                 ish.SizeOfRawData = 0;

	mov	esi, r12d
	mov	QWORD PTR ish$[rsp+16], r12

; 227  :                 ish.PointerToRawData = 0;
; 228  :             } else

	jmp	SHORT $LN69@coff_write
$LN25@coff_write:

; 229  :                 ish.Characteristics |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	or	edx, -1073741760			; c0000040H
	jmp	SHORT $LN68@coff_write
$LN24@coff_write:

; 217  :                 /* v2.12: if segtype is bss, ensure that seginfo->segtype is also bss; else
; 218  :                  * the segment might be written in coff_write_data().
; 219  :                  */
; 220  :                 curr->e.seginfo->segtype = SEGTYPE_BSS;

	mov	DWORD PTR [r10+72], 3

; 221  :                 ish.Characteristics |= IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	mov	edx, DWORD PTR ish$[rsp+36]

; 222  :                 /* ish.SizeOfRawData = 0; */
; 223  :                 ish.PointerToRawData = 0;

	mov	esi, DWORD PTR ish$[rsp+16]
	mov	DWORD PTR ish$[rsp+20], r12d
$LN69@coff_write:
	mov	r11d, r12d
	or	edx, -1073741696			; c0000080H
$LN68@coff_write:

; 230  :         }
; 231  : 
; 232  :         /* manual characteristics set? */
; 233  :         if ( curr->e.seginfo->characteristics ) {

	mov	DWORD PTR ish$[rsp+36], edx
	mov	rax, QWORD PTR [rdi+96]
	cmp	BYTE PTR [rax+105], r12b
	je	SHORT $LN27@coff_write

; 234  :             ish.Characteristics &= 0x1FFFFFF; /* clear the IMAGE_SCN_MEM flags */

	and	edx, 33554431				; 01ffffffH
	mov	DWORD PTR ish$[rsp+36], edx

; 235  :             ish.Characteristics |= (uint_32)(curr->e.seginfo->characteristics & 0xFE) << 24;

	mov	rax, QWORD PTR [rdi+96]
	movzx	ecx, BYTE PTR [rax+105]
	and	ecx, -2					; fffffffeH
	shl	ecx, 24
	or	edx, ecx
	mov	DWORD PTR ish$[rsp+36], edx
$LN27@coff_write:

; 236  :             /* the INFO bit (bit 0) needs special handling! */
; 237  :             //if ( curr->e.seginfo->characteristics & 1 )
; 238  :             //    ish.Characteristics |= IMAGE_SCN_LNK_INFO;
; 239  :         }
; 240  : 
; 241  :         if ( ish.PointerToRawData )

	test	r11d, r11d
	je	SHORT $LN28@coff_write

; 242  :             fileoffset += ish.SizeOfRawData;

	add	r14d, esi
$LN28@coff_write:

; 243  : 
; 244  :         /* set fields PointerToRelocations/NumberOfRelocations; update 'fileoffset'.
; 245  :          * v2.10: don't use the 16-bit NumberOfRelocations member to count relocs!
; 246  :          * if the true number of relocs doesn't fit in 16-bits, set the appropriate
; 247  :          * flag in the section header!
; 248  :          */
; 249  :         if ( curr->e.seginfo->FixupList.head ) {

	mov	rax, QWORD PTR [rdi+96]
	mov	rax, QWORD PTR [rax+40]
	test	rax, rax
	je	SHORT $LN33@coff_write
$LL7@coff_write:

; 251  :                 //printf("segment %s, reloc.sym=%s\n", curr->sym.name, fix->sym ? fix->sym : "NULL" );
; 252  :                 if ( fix->sym == NULL ) {

	cmp	QWORD PTR [rax+56], r12
	jne	SHORT $LN30@coff_write

; 253  : #if AMD64_SUPPORT
; 254  :                     if ( fix->type == FIX_RELOFF32 ) {

	cmp	DWORD PTR [rax+24], 3
	jne	SHORT $LN31@coff_write

; 255  :                         uint_32 *cp = (uint_32 *)( curr->e.seginfo->CodeBuffer + (fix->locofs - curr->e.seginfo->start_loc ));

	mov	rdx, QWORD PTR [rdi+96]
	mov	r8d, DWORD PTR [rax+20]

; 256  :                         uint_32 src = fix->locofs + fix->addbytes;

	movzx	ecx, BYTE PTR [rax+32]

; 257  :                         (*cp) -= src;

	add	ecx, DWORD PTR [rax+20]
	sub	r8d, DWORD PTR [rdx+8]
	add	r8, QWORD PTR [rdx+16]
	sub	DWORD PTR [r8], ecx
$LN31@coff_write:

; 258  :                     }
; 259  : #endif
; 260  :                     fix->type = FIX_VOID;

	mov	DWORD PTR [rax+24], r12d

; 261  :                     continue;

	jmp	SHORT $LN5@coff_write
$LN30@coff_write:

; 262  :                 }
; 263  :                 curr->e.seginfo->num_relocs++;

	mov	rcx, QWORD PTR [rdi+96]
	inc	DWORD PTR [rcx+64]
$LN5@coff_write:

; 250  :             for ( fix = curr->e.seginfo->FixupList.head; fix ; fix = fix->nextrlc ) {

	mov	rax, QWORD PTR [rax+8]
	test	rax, rax
	jne	SHORT $LL7@coff_write

; 264  :             }
; 265  :             fileoffset = (fileoffset + 1) & ~1;

	lea	edx, DWORD PTR [r14+1]
	and	edx, -2					; fffffffeH

; 266  :             ish.PointerToRelocations = fileoffset;

	mov	DWORD PTR ish$[rsp+24], edx

; 267  :             /* v2.10: handle the "relocs overflow"-case */
; 268  :             fileoffset += curr->e.seginfo->num_relocs * sizeof( IMAGE_RELOCATION );

	mov	r8, QWORD PTR [rdi+96]
	mov	ecx, DWORD PTR [r8+64]
	lea	eax, DWORD PTR [rcx+rcx*4]
	lea	r14d, DWORD PTR [rdx+rax*2]

; 269  :             if ( curr->e.seginfo->num_relocs <= 0xffff ) {

	cmp	ecx, r13d
	ja	SHORT $LN32@coff_write

; 270  :                 ish.NumberOfRelocations =  (uint_16)curr->e.seginfo->num_relocs;

	mov	WORD PTR ish$[rsp+32], cx

; 271  :             } else {

	jmp	SHORT $LN33@coff_write
$LN32@coff_write:

; 272  :                 DebugMsg(( "coff_write_section_table(%s): %" I32_SPEC "u fixups (more than 0xffff!)!\n", curr->sym.name, curr->e.seginfo->num_relocs ));
; 273  :                 ish.NumberOfRelocations =  0xffff;
; 274  :                 ish.Characteristics |= IMAGE_SCN_LNK_NRELOC_OVFL;

	or	DWORD PTR ish$[rsp+36], 16777216	; 01000000H

; 275  :                 /* add 1 relocation - the true number of relocations is stored in the first relocation item */
; 276  :                 fileoffset += sizeof( IMAGE_RELOCATION );

	add	r14d, 10
	mov	WORD PTR ish$[rsp+32], r13w
$LN33@coff_write:

; 277  :             }
; 278  :             //printf( "segment %s has %u relocs\n", curr->sym.name, curr->e.seginfo->num_relocs );
; 279  :         }
; 280  : 
; 281  :         /* set fields PointerToLinenumbers/NumberOfLinenumbers; update 'fileoffset' */
; 282  : 
; 283  :         if ( curr->e.seginfo->LinnumQueue ) {

	mov	rax, QWORD PTR [rdi+96]
	cmp	QWORD PTR [rax+56], r12
	je	SHORT $LN34@coff_write

; 284  :             ish.PointerToLinenumbers = fileoffset;

	mov	DWORD PTR ish$[rsp+28], r14d

; 285  :             ish.NumberOfLinenumbers = GetLinnumItems( curr->e.seginfo->LinnumQueue );

	mov	edx, r12d
	mov	rax, QWORD PTR [rdi+96]
	mov	rcx, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	SHORT $LN46@coff_write
	npad	8
$LL47@coff_write:
	mov	rax, QWORD PTR [rax]
	inc	edx
	test	rax, rax
	jne	SHORT $LL47@coff_write
$LN46@coff_write:

; 286  :             fileoffset += ish.NumberOfLinenumbers * sizeof( IMAGE_LINENUMBER );

	movzx	eax, dx
	mov	WORD PTR ish$[rsp+34], dx
	lea	ecx, DWORD PTR [rax+rax*2]
	lea	r14d, DWORD PTR [r14+rcx*2]
$LN34@coff_write:

; 287  :         }
; 288  : 
; 289  :         DebugMsg(( "coff_write_section_table(%s): name=%.8s Fixups=%u, Linnums=%u\n", curr->sym.name, ish.Name, ish.NumberOfRelocations, ish.NumberOfLinenumbers ));
; 290  :         if ( fwrite( &ish, 1, sizeof( ish ), CurrFile[OBJ] ) != sizeof( ish ) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR ish$[rsp]
	mov	edx, 1
	lea	r8d, QWORD PTR [rdx+39]
	call	fwrite
	cmp	rax, 40					; 00000028H
	je	SHORT $LN2@coff_write

; 291  :             WriteError();

	call	WriteError
$LN2@coff_write:

; 165  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdi, QWORD PTR [rdi+104]
	test	rdi, rdi
	jne	$LL4@coff_write
	mov	r13, QWORD PTR [rsp+336]
	mov	r12, QWORD PTR [rsp+408]
	mov	rsi, QWORD PTR [rsp+400]
	mov	rbx, QWORD PTR [rsp+392]
$LN67@coff_write:

; 292  :     }
; 293  : #ifdef DEBUG_OUT
; 294  :     cm->start_symtab = fileoffset;
; 295  : #endif
; 296  :     DebugMsg(("coff_write_section_table: exit\n"));
; 297  :     return( NOT_ERROR );

	xor	eax, eax

; 298  : }

	add	rsp, 344				; 00000158H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
coff_write_section_table ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
;	COMDAT GetLinnumItems
_TEXT	SEGMENT
q$ = 8
GetLinnumItems PROC					; COMDAT

; 137  :     unsigned i;
; 138  :     struct line_num_info *curr;
; 139  : 
; 140  :     for ( i = 0, curr = q->head; curr; i++, curr = curr->next );

	mov	rcx, QWORD PTR [rcx]
	xor	eax, eax
	test	rcx, rcx
	je	SHORT $LN10@GetLinnumI
	npad	6
$LL4@GetLinnumI:
	mov	rcx, QWORD PTR [rcx]
	inc	eax
	test	rcx, rcx
	jne	SHORT $LL4@GetLinnumI
$LN10@GetLinnumI:

; 141  :     return( i );
; 142  : }

	ret	0
GetLinnumItems ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
;	COMDAT Coff_AllocString
_TEXT	SEGMENT
cm$ = 48
string$ = 56
len$ = 64
Coff_AllocString PROC					; COMDAT

; 115  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 116  :     struct stringitem *name;
; 117  :     uint_32 oldsize = cm->LongNames.size;

	mov	esi, DWORD PTR [rcx+112]

; 118  : 
; 119  :     cm->LongNames.size += len + 1;

	lea	eax, DWORD PTR [r8+1]
	mov	rdi, rcx
	add	eax, esi
	mov	DWORD PTR [rcx+112], eax
	mov	rbx, rdx

; 120  :     name = LclAlloc( len + sizeof( struct stringitem ) );

	movsxd	rcx, r8d
	add	rcx, 16
	call	LclAlloc
	mov	rdx, rax

; 121  :     name->next = NULL;

	mov	QWORD PTR [rax], 0

; 122  :     strcpy( name->string, string );

	sub	rax, rbx
	npad	6
$LL5@Coff_Alloc:
	movzx	ecx, BYTE PTR [rbx]
	mov	BYTE PTR [rax+rbx+8], cl
	lea	rbx, QWORD PTR [rbx+1]
	test	cl, cl
	jne	SHORT $LL5@Coff_Alloc

; 123  :     if ( cm->LongNames.head ) {

	cmp	QWORD PTR [rdi+96], 0

; 128  :     }
; 129  :     return( oldsize );

	mov	eax, esi
	je	SHORT $LN2@Coff_Alloc

; 124  :         cm->LongNames.tail->next = name;

	mov	rcx, QWORD PTR [rdi+104]
	mov	QWORD PTR [rcx], rdx

; 125  :         cm->LongNames.tail = name;
; 126  :     } else {

	jmp	SHORT $LN9@Coff_Alloc
$LN2@Coff_Alloc:

; 127  :         cm->LongNames.head = cm->LongNames.tail = name;

	mov	QWORD PTR [rdi+96], rdx
$LN9@Coff_Alloc:

; 130  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	QWORD PTR [rdi+104], rdx
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Coff_AllocString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
modinfo$ = 8
coff_init PROC

; 1497 :     modinfo->g.WriteModule = coff_write_module;

	lea	rax, OFFSET FLAT:coff_write_module
	mov	QWORD PTR [rcx+288], rax

; 1498 :     return;
; 1499 : }

	ret	0
coff_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rdi, rcx

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rbx
	mov	QWORD PTR [rsp+40], rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], 0
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf
	test	eax, eax
	cmovs	eax, ebx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbx
	mov	r9, rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, rbx
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf

; 1459 :     #pragma warning(pop)
; 1460 : }

	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ebx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_Locale$ = 88
_ArgList$ = 96
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR _ArgList$[rsp]
	or	rcx, 1
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rbx
	call	__stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;
; 1391 : }

	mov	rbx, QWORD PTR [rsp+64]
	or	ecx, -1
	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ecx
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\time.h
;	COMDAT time
_TEXT	SEGMENT
_Time$ = 8
time	PROC						; COMDAT

; 535  :             return _time64(_Time);

	jmp	_time64
time	ENDP
_TEXT	ENDS
END
