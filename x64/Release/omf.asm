; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG12370 DB	01H DUP (?)
$SG12608 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	LastCodeBufSize:DWORD
_DATA	ENDS
CONST	SEGMENT
SymDebParm DQ	FLAT:$SG12160
	DQ	FLAT:$SG12161
	DQ	FLAT:$SG12162
	DQ	FLAT:$SG12163
CONST	ENDS
_DATA	SEGMENT
$SG12362 DB	01H, 00H
	ORG $+2
$SG12695 DB	01H, 'CV', 00H
$SG12160 DB	'$$SYMBOLS', 00H
	ORG $+2
$SG12161 DB	'DEBSYM', 00H
	ORG $+5
$SG12162 DB	'$$TYPES', 00H
$SG12163 DB	'DEBTYP', 00H
_DATA	ENDS
PUBLIC	omf_init
PUBLIC	omf_set_filepos
PUBLIC	omf_OutSelect
PUBLIC	omf_FlushCurrSeg
PUBLIC	omf_check_flush
PUBLIC	omf_GetGrpIdx
EXTRN	_localtime64:PROC
EXTRN	_stat64i32:PROC
EXTRN	_fileno:PROC
EXTRN	fseek:PROC
EXTRN	ftell:PROC
EXTRN	_strupr:PROC
EXTRN	EmitWarn:PROC
EXTRN	SizeFromMemtype:PROC
EXTRN	GetSymOfssize:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	CreateIntSegment:PROC
EXTRN	GetSegIdx:PROC
EXTRN	GetGroup:PROC
EXTRN	Mangle:PROC
EXTRN	omf_write_record:PROC
EXTRN	OmfFixGenFix:PROC
EXTRN	OmfFixGenFixModend:PROC
EXTRN	GetFName:PROC
EXTRN	_chsize:PROC
EXTRN	cv_write_debug_tables:PROC
EXTRN	SortSegments:PROC
EXTRN	memcpy:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	write_to_file:BYTE
EXTRN	SymTables:BYTE
EXTRN	LinnumQueue:BYTE
_BSS	SEGMENT
	ALIGN	4

seg_pos	DD	01H DUP (?)
public_pos DD	01H DUP (?)
end_of_header DD 01H DUP (?)
startitem DD	01H DUP (?)
startext DD	01H DUP (?)
ln_srcfile DD	01H DUP (?)
ln_is32	DB	01H DUP (?)
	ALIGN	4

ln_size	DW	01H DUP (?)
	ALIGN	8

SymDebSeg DQ	02H DUP (?)
?sel_start@?1??omf_OutSelect@@9@9 DD 01H DUP (?)	; `omf_OutSelect'::`2'::sel_start
_BSS	ENDS
pdata	SEGMENT
$pdata$omf_OutSelect DD imagerel $LN36
	DD	imagerel $LN36+123
	DD	imagerel $unwind$omf_OutSelect
$pdata$0$omf_OutSelect DD imagerel $LN36+123
	DD	imagerel $LN36+415
	DD	imagerel $chain$0$omf_OutSelect
$pdata$1$omf_OutSelect DD imagerel $LN36+415
	DD	imagerel $LN36+421
	DD	imagerel $chain$1$omf_OutSelect
$pdata$omf_FlushCurrSeg DD imagerel $LN5
	DD	imagerel $LN5+51
	DD	imagerel $unwind$omf_FlushCurrSeg
$pdata$omf_check_flush DD imagerel $LN16
	DD	imagerel $LN16+273
	DD	imagerel $unwind$omf_check_flush
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$timet2dostime DD imagerel timet2dostime
	DD	imagerel timet2dostime+107
	DD	imagerel $unwind$timet2dostime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PutData DD imagerel PutData
	DD	imagerel PutData+42
	DD	imagerel $unwind$PutData
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PutName DD imagerel PutName
	DD	imagerel PutName+57
	DD	imagerel $unwind$PutName
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_linnum DD imagerel omf_write_linnum
	DD	imagerel omf_write_linnum+202
	DD	imagerel $unwind$omf_write_linnum
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_fixupp DD imagerel omf_write_fixupp
	DD	imagerel omf_write_fixupp+61
	DD	imagerel $unwind$omf_write_fixupp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$omf_write_fixupp DD imagerel omf_write_fixupp+61
	DD	imagerel omf_write_fixupp+240
	DD	imagerel $chain$1$omf_write_fixupp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$omf_write_fixupp DD imagerel omf_write_fixupp+240
	DD	imagerel omf_write_fixupp+262
	DD	imagerel $chain$2$omf_write_fixupp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_ledata DD imagerel omf_write_ledata
	DD	imagerel omf_write_ledata+60
	DD	imagerel $unwind$omf_write_ledata
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$omf_write_ledata DD imagerel omf_write_ledata+60
	DD	imagerel omf_write_ledata+505
	DD	imagerel $chain$2$omf_write_ledata
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$omf_write_ledata DD imagerel omf_write_ledata+505
	DD	imagerel omf_write_ledata+822
	DD	imagerel $chain$3$omf_write_ledata
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$omf_write_ledata DD imagerel omf_write_ledata+822
	DD	imagerel omf_write_ledata+846
	DD	imagerel $chain$4$omf_write_ledata
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$omf_write_ledata DD imagerel omf_write_ledata+846
	DD	imagerel omf_write_ledata+867
	DD	imagerel $chain$5$omf_write_ledata
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_theadr DD imagerel omf_write_theadr
	DD	imagerel omf_write_theadr+112
	DD	imagerel $unwind$omf_write_theadr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_end_of_pass1 DD imagerel omf_end_of_pass1
	DD	imagerel omf_end_of_pass1+54
	DD	imagerel $unwind$omf_end_of_pass1
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_dosseg DD imagerel omf_write_dosseg
	DD	imagerel omf_write_dosseg+52
	DD	imagerel $unwind$omf_write_dosseg
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_lib DD imagerel omf_write_lib
	DD	imagerel omf_write_lib+16
	DD	imagerel $unwind$omf_write_lib
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$omf_write_lib DD imagerel omf_write_lib+16
	DD	imagerel omf_write_lib+113
	DD	imagerel $chain$1$omf_write_lib
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$omf_write_lib DD imagerel omf_write_lib+113
	DD	imagerel omf_write_lib+118
	DD	imagerel $chain$2$omf_write_lib
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_export DD imagerel omf_write_export
	DD	imagerel omf_write_export+22
	DD	imagerel $unwind$omf_write_export
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$omf_write_export DD imagerel omf_write_export+22
	DD	imagerel omf_write_export+322
	DD	imagerel $chain$3$omf_write_export
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$omf_write_export DD imagerel omf_write_export+322
	DD	imagerel omf_write_export+328
	DD	imagerel $chain$4$omf_write_export
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_grpdef DD imagerel omf_write_grpdef
	DD	imagerel omf_write_grpdef+29
	DD	imagerel $unwind$omf_write_grpdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$omf_write_grpdef DD imagerel omf_write_grpdef+29
	DD	imagerel omf_write_grpdef+325
	DD	imagerel $chain$0$omf_write_grpdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$omf_write_grpdef DD imagerel omf_write_grpdef+325
	DD	imagerel omf_write_grpdef+336
	DD	imagerel $chain$1$omf_write_grpdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_segdef DD imagerel omf_write_segdef
	DD	imagerel omf_write_segdef+29
	DD	imagerel $unwind$omf_write_segdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$omf_write_segdef DD imagerel omf_write_segdef+29
	DD	imagerel omf_write_segdef+423
	DD	imagerel $chain$1$omf_write_segdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$omf_write_segdef DD imagerel omf_write_segdef+423
	DD	imagerel omf_write_segdef+434
	DD	imagerel $chain$2$omf_write_segdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_lnames DD imagerel omf_write_lnames
	DD	imagerel omf_write_lnames+322
	DD	imagerel $unwind$omf_write_lnames
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_extdef DD imagerel omf_write_extdef
	DD	imagerel omf_write_extdef+22
	DD	imagerel $unwind$omf_write_extdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$omf_write_extdef DD imagerel omf_write_extdef+22
	DD	imagerel omf_write_extdef+41
	DD	imagerel $chain$0$omf_write_extdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$omf_write_extdef DD imagerel omf_write_extdef+41
	DD	imagerel omf_write_extdef+211
	DD	imagerel $chain$2$omf_write_extdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$omf_write_extdef DD imagerel omf_write_extdef+211
	DD	imagerel omf_write_extdef+533
	DD	imagerel $chain$4$omf_write_extdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$omf_write_extdef DD imagerel omf_write_extdef+533
	DD	imagerel omf_write_extdef+565
	DD	imagerel $chain$5$omf_write_extdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$omf_write_extdef DD imagerel omf_write_extdef+565
	DD	imagerel omf_write_extdef+791
	DD	imagerel $chain$6$omf_write_extdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$omf_write_extdef DD imagerel omf_write_extdef+791
	DD	imagerel omf_write_extdef+842
	DD	imagerel $chain$7$omf_write_extdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$omf_write_extdef DD imagerel omf_write_extdef+842
	DD	imagerel omf_write_extdef+895
	DD	imagerel $chain$8$omf_write_extdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_comdef DD imagerel omf_write_comdef
	DD	imagerel omf_write_comdef+46
	DD	imagerel $unwind$omf_write_comdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$omf_write_comdef DD imagerel omf_write_comdef+46
	DD	imagerel omf_write_comdef+846
	DD	imagerel $chain$3$omf_write_comdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$omf_write_comdef DD imagerel omf_write_comdef+846
	DD	imagerel omf_write_comdef+864
	DD	imagerel $chain$4$omf_write_comdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetFileTimeStamp DD imagerel GetFileTimeStamp
	DD	imagerel GetFileTimeStamp+35
	DD	imagerel $unwind$GetFileTimeStamp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_autodep DD imagerel omf_write_autodep
	DD	imagerel omf_write_autodep+48
	DD	imagerel $unwind$omf_write_autodep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$omf_write_autodep DD imagerel omf_write_autodep+48
	DD	imagerel omf_write_autodep+354
	DD	imagerel $chain$3$omf_write_autodep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$omf_write_autodep DD imagerel omf_write_autodep+354
	DD	imagerel omf_write_autodep+410
	DD	imagerel $chain$4$omf_write_autodep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_alias DD imagerel omf_write_alias
	DD	imagerel omf_write_alias+27
	DD	imagerel $unwind$omf_write_alias
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$omf_write_alias DD imagerel omf_write_alias+27
	DD	imagerel omf_write_alias+238
	DD	imagerel $chain$3$omf_write_alias
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$omf_write_alias DD imagerel omf_write_alias+238
	DD	imagerel omf_write_alias+247
	DD	imagerel $chain$4$omf_write_alias
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_pubdef DD imagerel omf_write_pubdef
	DD	imagerel omf_write_pubdef+25
	DD	imagerel $unwind$omf_write_pubdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$omf_write_pubdef DD imagerel omf_write_pubdef+25
	DD	imagerel omf_write_pubdef+622
	DD	imagerel $chain$6$omf_write_pubdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$omf_write_pubdef DD imagerel omf_write_pubdef+622
	DD	imagerel omf_write_pubdef+631
	DD	imagerel $chain$7$omf_write_pubdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_modend DD imagerel omf_write_modend
	DD	imagerel omf_write_modend+144
	DD	imagerel $unwind$omf_write_modend
pdata	ENDS
pdata	SEGMENT
$pdata$omf_cv_flushfunc DD imagerel omf_cv_flushfunc
	DD	imagerel omf_cv_flushfunc+78
	DD	imagerel $unwind$omf_cv_flushfunc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$omf_write_header_dbgcv DD imagerel omf_write_header_dbgcv
	DD	imagerel omf_write_header_dbgcv+181
	DD	imagerel $unwind$omf_write_header_dbgcv
pdata	ENDS
pdata	SEGMENT
$pdata$omf_write_module DD imagerel omf_write_module
	DD	imagerel omf_write_module+200
	DD	imagerel $unwind$omf_write_module
$pdata$omf_write_header_initial DD imagerel omf_write_header_initial
	DD	imagerel omf_write_header_initial+301
	DD	imagerel $unwind$omf_write_header_initial
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_header_dbgcv DD 081401H
	DD	0106414H
	DD	0f5414H
	DD	0e3414H
	DD	07010b214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_modend DD 060f01H
	DD	0f640fH
	DD	0e340fH
	DD	0700bb20fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$omf_write_pubdef DD 021H
	DD	imagerel omf_write_pubdef
	DD	imagerel omf_write_pubdef+25
	DD	imagerel $unwind$omf_write_pubdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$omf_write_pubdef DD 0e3221H
	DD	0af432H
	DD	0bd425H
	DD	0cc416H
	DD	0d7412H
	DD	013640eH
	DD	0125408H
	DD	0113404H
	DD	imagerel omf_write_pubdef
	DD	imagerel omf_write_pubdef+25
	DD	imagerel $unwind$omf_write_pubdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_pubdef DD 020901H
	DD	0e005d209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$omf_write_alias DD 021H
	DD	imagerel omf_write_alias
	DD	imagerel omf_write_alias+27
	DD	imagerel $unwind$omf_write_alias
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$omf_write_alias DD 081021H
	DD	06de410H
	DD	06c740cH
	DD	06b6408H
	DD	06a5404H
	DD	imagerel omf_write_alias
	DD	imagerel omf_write_alias+27
	DD	imagerel $unwind$omf_write_alias
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_alias DD 030b01H
	DD	068010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$omf_write_autodep DD 021H
	DD	imagerel omf_write_autodep
	DD	imagerel omf_write_autodep+48
	DD	imagerel $unwind$omf_write_autodep
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$omf_write_autodep DD 081c21H
	DD	010e41cH
	DD	011d412H
	DD	012c408H
	DD	01a3404H
	DD	imagerel omf_write_autodep
	DD	imagerel omf_write_autodep+48
	DD	imagerel $unwind$omf_write_autodep
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_autodep DD 060f01H
	DD	013010fH
	DD	07006f008H
	DD	050046005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetFileTimeStamp DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$omf_write_comdef DD 021H
	DD	imagerel omf_write_comdef
	DD	imagerel omf_write_comdef+46
	DD	imagerel $unwind$omf_write_comdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$omf_write_comdef DD 081021H
	DD	0ace410H
	DD	0b4c40cH
	DD	0b36408H
	DD	0b23404H
	DD	imagerel omf_write_comdef
	DD	imagerel omf_write_comdef+46
	DD	imagerel $unwind$omf_write_comdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_comdef DD 061701H
	DD	0ad0117H
	DD	0d007f009H
	DD	050047005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$omf_write_extdef DD 0a0021H
	DD	0aae400H
	DD	0abc400H
	DD	0b37400H
	DD	0b26400H
	DD	0b13400H
	DD	imagerel omf_write_extdef
	DD	imagerel omf_write_extdef+22
	DD	imagerel $unwind$omf_write_extdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$omf_write_extdef DD 021H
	DD	imagerel omf_write_extdef
	DD	imagerel omf_write_extdef+22
	DD	imagerel $unwind$omf_write_extdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$omf_write_extdef DD 021H
	DD	imagerel omf_write_extdef+22
	DD	imagerel omf_write_extdef+41
	DD	imagerel $chain$0$omf_write_extdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$omf_write_extdef DD 021H
	DD	imagerel omf_write_extdef+41
	DD	imagerel omf_write_extdef+211
	DD	imagerel $chain$2$omf_write_extdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$omf_write_extdef DD 041021H
	DD	0aae410H
	DD	0b26408H
	DD	imagerel omf_write_extdef+41
	DD	imagerel omf_write_extdef+211
	DD	imagerel $chain$2$omf_write_extdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$omf_write_extdef DD 040c21H
	DD	0abc40cH
	DD	0b37404H
	DD	imagerel omf_write_extdef+22
	DD	imagerel omf_write_extdef+41
	DD	imagerel $chain$0$omf_write_extdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$omf_write_extdef DD 020421H
	DD	0b13404H
	DD	imagerel omf_write_extdef
	DD	imagerel omf_write_extdef+22
	DD	imagerel $unwind$omf_write_extdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_extdef DD 051601H
	DD	0ac0116H
	DD	0d006f008H
	DD	05004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_lnames DD 0b1b01H
	DD	090641bH
	DD	08f541bH
	DD	08e341bH
	DD	08a011bH
	DD	0e012f014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$omf_write_segdef DD 021H
	DD	imagerel omf_write_segdef
	DD	imagerel omf_write_segdef+29
	DD	imagerel $unwind$omf_write_segdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$omf_write_segdef DD 040a21H
	DD	0e740aH
	DD	0d6405H
	DD	imagerel omf_write_segdef
	DD	imagerel omf_write_segdef+29
	DD	imagerel $unwind$omf_write_segdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_segdef DD 040d01H
	DD	0f340dH
	DD	05006920dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$omf_write_grpdef DD 021H
	DD	imagerel omf_write_grpdef
	DD	imagerel omf_write_grpdef+29
	DD	imagerel $unwind$omf_write_grpdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$omf_write_grpdef DD 020521H
	DD	0c7405H
	DD	imagerel omf_write_grpdef
	DD	imagerel omf_write_grpdef+29
	DD	imagerel $unwind$omf_write_grpdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_grpdef DD 040d01H
	DD	0d340dH
	DD	05006920dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$omf_write_export DD 021H
	DD	imagerel omf_write_export
	DD	imagerel omf_write_export+22
	DD	imagerel $unwind$omf_write_export
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$omf_write_export DD 081721H
	DD	0e7417H
	DD	0d6412H
	DD	0c540dH
	DD	0fe405H
	DD	imagerel omf_write_export
	DD	imagerel omf_write_export+22
	DD	imagerel $unwind$omf_write_export
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_export DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$omf_write_lib DD 021H
	DD	imagerel omf_write_lib
	DD	imagerel omf_write_lib+16
	DD	imagerel $unwind$omf_write_lib
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$omf_write_lib DD 040a21H
	DD	0a740aH
	DD	0c3405H
	DD	imagerel omf_write_lib
	DD	imagerel omf_write_lib+16
	DD	imagerel $unwind$omf_write_lib
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_lib DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_dosseg DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_end_of_pass1 DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_theadr DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$omf_write_ledata DD 021H
	DD	imagerel omf_write_ledata
	DD	imagerel omf_write_ledata+60
	DD	imagerel $unwind$omf_write_ledata
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$omf_write_ledata DD 021H
	DD	imagerel omf_write_ledata+60
	DD	imagerel omf_write_ledata+505
	DD	imagerel $chain$2$omf_write_ledata
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$omf_write_ledata DD 020821H
	DD	015c408H
	DD	imagerel omf_write_ledata+60
	DD	imagerel omf_write_ledata+505
	DD	imagerel $chain$2$omf_write_ledata
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$omf_write_ledata DD 060f21H
	DD	017f40fH
	DD	016e408H
	DD	0147404H
	DD	imagerel omf_write_ledata
	DD	imagerel omf_write_ledata+60
	DD	imagerel $unwind$omf_write_ledata
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_ledata DD 041001H
	DD	06006f210H
	DD	050043005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$omf_write_fixupp DD 021H
	DD	imagerel omf_write_fixupp
	DD	imagerel omf_write_fixupp+61
	DD	imagerel $unwind$omf_write_fixupp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$omf_write_fixupp DD 040a21H
	DD	0ff40aH
	DD	0e6405H
	DD	imagerel omf_write_fixupp
	DD	imagerel omf_write_fixupp+61
	DD	imagerel $unwind$omf_write_fixupp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_fixupp DD 081301H
	DD	0115413H
	DD	0103413H
	DD	0e00f9213H
	DD	0700bc00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$omf_write_linnum DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PutName DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PutData DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timet2dostime DD 010901H
	DD	04209H
xdata	ENDS
xdata	SEGMENT
$unwind$omf_OutSelect DD 020901H
	DD	05002b209H
$chain$0$omf_OutSelect DD 020521H
	DD	0e3405H
	DD	imagerel $LN36
	DD	imagerel $LN36+123
	DD	imagerel $unwind$omf_OutSelect
$chain$1$omf_OutSelect DD 021H
	DD	imagerel $LN36
	DD	imagerel $LN36+123
	DD	imagerel $unwind$omf_OutSelect
$unwind$omf_FlushCurrSeg DD 010401H
	DD	04204H
$unwind$omf_check_flush DD 04c701H
	DD	0674c7H
	DD	030023206H
$unwind$omf_cv_flushfunc DD 020601H
	DD	030023206H
$unwind$omf_write_module DD 020601H
	DD	030023206H
$unwind$omf_write_header_initial DD 010401H
	DD	0a204H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
obj$1 = 32
obj$2 = 32
modinfo$ = 96
omf_write_header_initial PROC

; 1618 : {

	sub	rsp, 88					; 00000058H

; 1619 :     uint_16 ext_idx;
; 1620 : 
; 1621 :     if ( write_to_file == FALSE )

	cmp	BYTE PTR write_to_file, 0
	je	$LN22@omf_write_

; 1622 :         return( NOT_ERROR );
; 1623 : 
; 1624 :     omf_write_theadr( CurrFName[ASM] ); /* write THEADR record, main src filename */

	mov	rcx, QWORD PTR ModuleInfo+128
	call	omf_write_theadr

; 1625 :     /* v2.11: coment record "ms extensions present" now written here */
; 1626 :     if ( Options.debug_symbols ) /* -Zi option set? */

	cmp	BYTE PTR Options+2, 0
	je	SHORT $LN3@omf_write_

; 1627 :         omf_write_header_dbgcv();

	call	omf_write_header_dbgcv
$LN3@omf_write_:

; 1628 :     /* if( Options.no_dependencies == FALSE ) */
; 1629 :     if( Options.line_numbers )

	cmp	BYTE PTR Options+1, 0
	je	SHORT $LN4@omf_write_

; 1630 :         omf_write_autodep(); /* write dependency COMENT records ( known by Borland & OW ) */

	call	omf_write_autodep
$LN4@omf_write_:

; 1631 :     if( ModuleInfo.segorder == SEGORDER_DOSSEG )

	mov	eax, DWORD PTR ModuleInfo+380
	cmp	eax, 1
	jne	SHORT $LN5@omf_write_

; 1632 :         omf_write_dosseg(); /* write dosseg COMENT records */

	lea	rax, OFFSET FLAT:$SG12370
	mov	QWORD PTR obj$2[rsp], 0
	lea	rcx, QWORD PTR obj$2[rsp]
	mov	QWORD PTR obj$2[rsp+8], rax
	mov	WORD PTR obj$2[rsp+16], 136		; 00000088H
	mov	WORD PTR obj$2[rsp+20], 40576		; 00009e80H
	call	omf_write_record
	jmp	SHORT $LN7@omf_write_
$LN5@omf_write_:

; 1633 :     else if( ModuleInfo.segorder == SEGORDER_ALPHA )

	cmp	eax, 2
	jne	SHORT $LN7@omf_write_

; 1634 :         SortSegments( 1 );

	lea	ecx, QWORD PTR [rax-1]
	call	SortSegments
$LN7@omf_write_:

; 1635 :     omf_write_lib(); /* write default lib COMENT records */

	call	omf_write_lib

; 1636 :     omf_write_lnames(); /* write LNAMES records */

	call	omf_write_lnames

; 1637 : 
; 1638 :     /* write SEGDEF records. Since these records contain the segment's length,
; 1639 :      * the records have to be written again after the final assembly pass.
; 1640 :      * hence the start position of those records has to be saved.
; 1641 :      */
; 1642 :     seg_pos = ftell( CurrFile[OBJ] );

	mov	rcx, QWORD PTR ModuleInfo+104
	call	ftell
	mov	DWORD PTR seg_pos, eax

; 1643 :     omf_write_segdef();

	call	omf_write_segdef

; 1644 :     omf_write_grpdef(); /* write GRPDEF records */

	call	omf_write_grpdef

; 1645 :     ext_idx = omf_write_extdef(); /* write EXTDEF records */

	call	omf_write_extdef

; 1646 :     startext = omf_write_comdef( ext_idx ); /* write COMDEF records */

	movzx	ecx, ax
	call	omf_write_comdef
	movzx	eax, ax
	mov	DWORD PTR startext, eax

; 1647 :     omf_write_alias(); /* write ALIAS records */

	call	omf_write_alias

; 1648 : 
; 1649 :     /* write PUBDEF records. Since the final value of offsets isn't known after
; 1650 :      * the first pass, this has to be called again after the final pass.
; 1651 :      */
; 1652 :     public_pos = ftell( CurrFile[OBJ] );

	mov	rcx, QWORD PTR ModuleInfo+104
	call	ftell
	mov	DWORD PTR public_pos, eax

; 1653 :     omf_write_pubdef();

	call	omf_write_pubdef

; 1654 :     omf_write_export(); /* write export COMENT records */

	call	omf_write_export

; 1655 : 
; 1656 :     /* (optionally) write end-of-pass-one COMENT record
; 1657 :      * v2.10: don't write record if starting address is present.
; 1658 :      * the TIS OMF spec v1.1. warns that this
; 1659 :      * comment record is NOT to be present if
; 1660 :      * the MODEND record contains a starting address!
; 1661 :      */
; 1662 :     if ( !ModuleInfo.g.start_fixup )

	cmp	QWORD PTR ModuleInfo+208, 0
	jne	SHORT $LN16@omf_write_

; 1663 :         omf_end_of_pass1();

	lea	rax, OFFSET FLAT:$SG12362
	mov	QWORD PTR obj$1[rsp], 1
	lea	rcx, QWORD PTR obj$1[rsp]
	mov	QWORD PTR obj$1[rsp+8], rax
	mov	WORD PTR obj$1[rsp+16], 136		; 00000088H
	mov	WORD PTR obj$1[rsp+20], 41472		; 0000a200H
	call	omf_write_record
$LN16@omf_write_:

; 1664 :     end_of_header = ftell( CurrFile[OBJ] );

	mov	rcx, QWORD PTR ModuleInfo+104
	call	ftell
	mov	DWORD PTR end_of_header, eax
$LN22@omf_write_:

; 1665 :     return( NOT_ERROR );

	xor	eax, eax

; 1666 : }

	add	rsp, 88					; 00000058H
	ret	0
omf_write_header_initial ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
modinfo$ = 48
omf_write_module PROC

; 1563 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 1564 : #if TRUNCATE
; 1565 :     int fh;
; 1566 :     uint_32 size;
; 1567 : #endif
; 1568 :     /* -if Zi is set, write symbols and types */
; 1569 :     if ( Options.debug_symbols )

	cmp	BYTE PTR Options+2, 0
	mov	rbx, rcx
	je	SHORT $LN5@omf_write_

; 1570 :         omf_write_debug_tables();

	mov	rcx, QWORD PTR SymDebSeg
	test	rcx, rcx
	je	SHORT $LN5@omf_write_
	mov	rdx, QWORD PTR SymDebSeg+8
	test	rdx, rdx
	je	SHORT $LN5@omf_write_
	mov	r8, QWORD PTR [rcx+96]
	mov	rax, QWORD PTR ModuleInfo+464
	mov	QWORD PTR [r8+16], rax
	mov	r8, QWORD PTR ModuleInfo+464
	mov	rax, QWORD PTR [rdx+96]
	add	r8, 1024				; 00000400H
	mov	QWORD PTR [rax+16], r8
	xor	r8d, r8d
	call	cv_write_debug_tables
$LN5@omf_write_:

; 1571 :     omf_write_modend( modinfo->g.start_fixup, modinfo->g.start_displ );

	mov	edx, DWORD PTR [rbx+216]
	mov	rcx, QWORD PTR [rbx+208]
	call	omf_write_modend

; 1572 : #if FASTMEM==0
; 1573 :     LclFree( modinfo->g.start_fixup );
; 1574 : #endif
; 1575 : 
; 1576 : #if TRUNCATE
; 1577 :     /* under some very rare conditions, the object
; 1578 :      * module might become shorter! Hence the file
; 1579 :      * must be truncated now. The problem is that there
; 1580 :      * is no stream function for this task.
; 1581 :      * the final solution will be to save the segment contents
; 1582 :      * in buffers and write the object module once everything
; 1583 :      * is done ( as it is done for the other formats already).
; 1584 :      * v2.03: most likely no longer necessary, since the file
; 1585 :      * won't become shorter anymore.
; 1586 :      */
; 1587 :     size = ftell( CurrFile[OBJ] );

	mov	rcx, QWORD PTR ModuleInfo+104
	call	ftell

; 1588 : #if defined(__UNIX__) || defined(__CYGWIN__) || defined(__DJGPP__)
; 1589 :     fh = fileno( CurrFile[OBJ] );
; 1590 :     if ( ftruncate( fh, size ) ); /* gcc warns if return value of ftruncate() is "ignored" */
; 1591 : #elif defined(__BORLANDC__)
; 1592 :     fh = _fileno( CurrFile[OBJ] );
; 1593 :     chsize( fh, size );
; 1594 : #else
; 1595 :     fh = _fileno( CurrFile[OBJ] );

	mov	rcx, QWORD PTR ModuleInfo+104
	mov	ebx, eax
	call	_fileno

; 1596 :     _chsize( fh, size );

	mov	edx, ebx
	mov	ecx, eax
	call	_chsize

; 1597 : #endif
; 1598 : 
; 1599 : #endif
; 1600 : 
; 1601 :     /* write SEGDEF records. Since these records contain the segment's length,
; 1602 :      * the records have to be written again after the final assembly pass.
; 1603 :      */
; 1604 :     fseek( CurrFile[OBJ] , seg_pos, SEEK_SET );

	mov	edx, DWORD PTR seg_pos
	xor	r8d, r8d
	mov	rcx, QWORD PTR ModuleInfo+104
	call	fseek

; 1605 :     omf_write_segdef();

	call	omf_write_segdef

; 1606 :     /* write PUBDEF records. Since the final value of offsets isn't known after
; 1607 :      * the first pass, this has to be called again after the final pass.
; 1608 :      */
; 1609 :     fseek( CurrFile[OBJ], public_pos, SEEK_SET);

	mov	edx, DWORD PTR public_pos
	xor	r8d, r8d
	mov	rcx, QWORD PTR ModuleInfo+104
	call	fseek

; 1610 :     omf_write_pubdef();

	call	omf_write_pubdef

; 1611 :     return( NOT_ERROR );

	xor	eax, eax

; 1612 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
omf_write_module ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_debug_tables
_TEXT	SEGMENT
omf_write_debug_tables PROC				; COMDAT

; 1548 :     if ( SymDebSeg[DBGS_SYMBOLS] && SymDebSeg[DBGS_TYPES] ) {

	mov	rcx, QWORD PTR SymDebSeg
	test	rcx, rcx
	je	SHORT $LN2@omf_write_
	mov	rdx, QWORD PTR SymDebSeg+8
	test	rdx, rdx
	je	SHORT $LN2@omf_write_

; 1549 :         SymDebSeg[DBGS_SYMBOLS]->e.seginfo->CodeBuffer = CurrSource;

	mov	r8, QWORD PTR [rcx+96]
	mov	rax, QWORD PTR ModuleInfo+464
	mov	QWORD PTR [r8+16], rax

; 1550 :         SymDebSeg[DBGS_TYPES]->e.seginfo->CodeBuffer = CurrSource + 1024;

	mov	r8, QWORD PTR ModuleInfo+464
	mov	rax, QWORD PTR [rdx+96]
	add	r8, 1024				; 00000400H
	mov	QWORD PTR [rax+16], r8

; 1551 :         cv_write_debug_tables( SymDebSeg[DBGS_SYMBOLS], SymDebSeg[DBGS_TYPES], NULL );

	xor	r8d, r8d
	jmp	cv_write_debug_tables
$LN2@omf_write_:

; 1552 :     }
; 1553 : }

	ret	0
omf_write_debug_tables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_header_dbgcv
_TEXT	SEGMENT
obj$ = 48
omf_write_header_dbgcv PROC				; COMDAT

; 1525 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 96					; 00000060H

; 1526 :     int i;
; 1527 :     struct omf_rec obj;
; 1528 : 
; 1529 :     omf_InitRec( &obj, CMD_COMENT );
; 1530 :     obj.d.coment.attr = 0x00;
; 1531 :     obj.d.coment.cmt_class = CMT_MS_OMF; /* MS extensions present */
; 1532 :     AttachData( &obj, "\001CV", 3 );

	lea	rax, OFFSET FLAT:$SG12695
	mov	QWORD PTR obj$[rsp], 3

; 1533 :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	QWORD PTR obj$[rsp+8], rax
	mov	WORD PTR obj$[rsp+16], 136		; 00000088H
	mov	WORD PTR obj$[rsp+20], 41216		; 0000a100H
	call	omf_write_record
	lea	rdi, OFFSET FLAT:SymDebSeg
	mov	esi, 2
	lea	rbx, OFFSET FLAT:SymDebParm
	lea	rbp, OFFSET FLAT:omf_cv_flushfunc
	npad	5
$LL4@omf_write_:

; 1535 :         if ( SymDebSeg[i] = (struct dsym *)CreateIntSegment( SymDebParm[i].name, SymDebParm[i].cname, 0, USE32, TRUE ) ) {

	mov	rdx, QWORD PTR [rbx+8]
	mov	r9b, 1
	mov	rcx, QWORD PTR [rbx]
	xor	r8d, r8d
	mov	BYTE PTR [rsp+32], 1
	call	CreateIntSegment
	mov	QWORD PTR [rdi], rax
	test	rax, rax
	je	SHORT $LN2@omf_write_

; 1536 :             SymDebSeg[i]->e.seginfo->force32 = TRUE; /* without this a 32-bit segdef is emitted only if segsize > 64kB */

	mov	rcx, QWORD PTR [rax+96]
	or	BYTE PTR [rcx+107], 4

; 1537 :             SymDebSeg[i]->e.seginfo->flushfunc = omf_cv_flushfunc;

	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rax+32], rbp
$LN2@omf_write_:

; 1534 :     for ( i = 0; i < DBGS_MAX; i++ ) {

	add	rbx, 16
	add	rdi, 8
	sub	rsi, 1
	jne	SHORT $LL4@omf_write_

; 1538 :         }
; 1539 :     }
; 1540 :     return;
; 1541 : }

	mov	rbx, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
omf_write_header_dbgcv ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
seg$ = 48
curr$ = 56
size$ = 64
pv$ = 72
omf_cv_flushfunc PROC

; 1506 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 1507 :     uint_8 *buffer = seg->e.seginfo->CodeBuffer;

	mov	r9, QWORD PTR [rcx+96]
	mov	r10, rcx
	mov	rbx, QWORD PTR [r9+16]

; 1508 : 
; 1509 :     if ( ( curr - buffer ) && ( ( curr - buffer ) + size ) > ( 1024 - 8 ) ) {

	cmp	rdx, rbx
	je	SHORT $LN2@omf_cv_flu
	mov	r8d, r8d
	sub	r8, rbx
	add	r8, rdx
	cmp	r8, 1016				; 000003f8H
	jle	SHORT $LN2@omf_cv_flu

; 1510 :         seg->e.seginfo->current_loc = seg->e.seginfo->start_loc + ( curr - buffer );

	mov	ecx, DWORD PTR [r9+8]
	sub	ecx, ebx
	add	ecx, edx
	mov	DWORD PTR [r9+12], ecx

; 1511 :         omf_write_ledata( seg );

	mov	rcx, r10
	call	omf_write_ledata

; 1512 :         return( buffer );

	mov	rax, rbx

; 1515 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@omf_cv_flu:

; 1513 :     }
; 1514 :     return( curr );

	mov	rax, rdx

; 1515 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
omf_cv_flushfunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_modend
_TEXT	SEGMENT
buffer$ = 32
obj$ = 48
fixup$ = 112
displ$ = 120
omf_write_modend PROC					; COMDAT

; 1481 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 96					; 00000060H

; 1482 :     struct omf_rec  obj;
; 1483 :     uint_8 buffer[FIX_GEN_MODEND_MAX];
; 1484 : 
; 1485 :     DebugMsg(("omf_write_modend( fixup=%p, displ=%" I32_SPEC "X)\n", fixup, displ ));
; 1486 : 
; 1487 :     omf_InitRec( &obj, CMD_MODEND );

	xor	ebx, ebx
	mov	WORD PTR obj$[rsp+16], 138		; 0000008aH
	mov	QWORD PTR obj$[rsp], rbx
	mov	esi, edx
	mov	QWORD PTR obj$[rsp+8], rbx
	mov	rdi, rcx

; 1488 : 
; 1489 :     if( fixup == NULL ) {

	test	rcx, rcx
	jne	SHORT $LN2@omf_write_

; 1490 :         obj.d.modend.main_module = FALSE;

	mov	WORD PTR obj$[rsp+20], bx

; 1491 :         obj.d.modend.start_addrs = FALSE;
; 1492 :     } else {

	jmp	SHORT $LN3@omf_write_
$LN2@omf_write_:

; 1493 :         obj.d.modend.start_addrs = TRUE;
; 1494 :         obj.d.modend.main_module = TRUE;
; 1495 :         obj.is_32 = ( GetSymOfssize( fixup->sym ) > USE16 ? 1 : 0 ); /* USE16 or USE32 */

	mov	rcx, QWORD PTR [rcx+56]
	mov	WORD PTR obj$[rsp+20], 257		; 00000101H
	call	GetSymOfssize
	test	eax, eax

; 1496 :         AttachData( &obj, buffer, 0 );

	mov	DWORD PTR obj$[rsp], ebx
	lea	rcx, QWORD PTR buffer$[rsp]

; 1497 :         obj.length = OmfFixGenFixModend( fixup, buffer, displ, obj.is_32 ? FIX_GEN_MS386 : FIX_GEN_INTEL );

	mov	r8d, esi
	setg	al
	mov	QWORD PTR obj$[rsp+8], rcx
	test	al, al
	mov	BYTE PTR obj$[rsp+17], al
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rdi
	setne	bl
	mov	r9d, ebx
	call	OmfFixGenFixModend
	mov	DWORD PTR obj$[rsp], eax
$LN3@omf_write_:

; 1498 :     }
; 1499 :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 1500 : }

	mov	rbx, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
omf_write_modend ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_pubdef
_TEXT	SEGMENT
obj$1 = 32
obj$2 = 32
curr32$3 = 128
curr_seg$4 = 128
omf_write_pubdef PROC					; COMDAT

; 1369 : {

	mov	rax, rsp
	push	r14
	sub	rsp, 112				; 00000070H

; 1370 :     struct qnode        *q;
; 1371 : 
; 1372 :     DebugMsg1(("omf_write_pub enter\n"));
; 1373 : 
; 1374 :     /* v2.07: struct pubdef_data has been modified to match
; 1375 :      * the data to be written to the object module more closely.
; 1376 :      * This fixed a possible overrun if too many publics were written.
; 1377 :      * v2.11: now the data matches exactly the OMF PUBDEF record
; 1378 :      * and is just attached.
; 1379 :      */
; 1380 : 
; 1381 :     q = ModuleInfo.g.PubQueue.head;

	mov	r14, QWORD PTR ModuleInfo+16

; 1382 :     while ( q ) {

	test	r14, r14
	je	$LN40@omf_write_
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rbp
	xor	ebp, ebp
	mov	QWORD PTR [rax+32], rsi
	mov	QWORD PTR [rax-16], rdi
	mov	QWORD PTR [rax-24], r12
	mov	r12, QWORD PTR curr_seg$4[rsp]
	lea	edx, QWORD PTR [rbp+4]
	mov	QWORD PTR [rax-32], r13
	movzx	r13d, BYTE PTR curr32$3[rsp]
	mov	QWORD PTR [rax-40], r15
	npad	5
$LL2@omf_write_:

; 1383 :         struct asym     *curr_seg;
; 1384 :         uint_8          *data;
; 1385 :         unsigned        size;
; 1386 :         uint_8          curr32;
; 1387 :         uint_8          is32;
; 1388 : 
; 1389 :         for ( size = 0, data = StringBufferEnd; q; q = q->next ) {

	mov	rbx, QWORD PTR ModuleInfo+488
	mov	esi, ebp
	test	r14, r14
	je	$LN13@omf_write_
$LL6@omf_write_:

; 1390 :             unsigned    recsize;
; 1391 :             unsigned    len;
; 1392 :             struct asym *sym;
; 1393 :             sym = q->sym;

	mov	rdi, QWORD PTR [r14+8]

; 1394 : #if COMDATSUPP
; 1395 :             /* COMDAT symbol? Then write an LNAME record */
; 1396 :             if ( sym->segment && ((struct dsym *)sym->segment)->e.seginfo->comdat_selection ) {

	mov	rcx, QWORD PTR [rdi+24]
	test	rcx, rcx
	je	$LN7@omf_write_
	mov	rax, QWORD PTR [rcx+96]
	test	BYTE PTR [rax+108], 56			; 00000038H
	je	$LN7@omf_write_

; 1397 :                 struct dsym *seg = (struct dsym *)sym->segment;
; 1398 :                 if ( seg->e.seginfo->comdat_idx == 0 ) {

	cmp	WORD PTR [rax+88], 0
	mov	rdx, rax
	jne	$LN4@omf_write_

; 1399 :                     struct omf_rec obj;
; 1400 :                     seg->e.seginfo->comdat_idx = ++startitem;

	mov	eax, DWORD PTR startitem
	inc	eax

; 1401 :                     seg->sym.used = sym->used;
; 1402 :                     omf_InitRec( &obj, CMD_LNAMES );

	mov	QWORD PTR obj$2[rsp], 0
	mov	WORD PTR [rdx+88], ax
	mov	DWORD PTR startitem, eax
	movzx	eax, BYTE PTR [rdi+40]
	xor	al, BYTE PTR [rcx+40]
	and	al, 1
	mov	QWORD PTR obj$2[rsp+8], rbp
	xor	BYTE PTR [rcx+40], al

; 1403 :                     len = Mangle( sym, StringBufferEnd + 1 );

	mov	rcx, rdi
	mov	rdx, QWORD PTR ModuleInfo+488
	inc	rdx
	mov	WORD PTR obj$2[rsp+16], 150		; 00000096H
	call	Mangle

; 1404 :                     *StringBufferEnd = len;

	mov	rcx, QWORD PTR ModuleInfo+488
	mov	edi, eax
	mov	BYTE PTR [rcx], al

; 1405 :                     if ( ModuleInfo.case_sensitive == FALSE )

	test	BYTE PTR ModuleInfo+408, 1
	jne	SHORT $LN10@omf_write_

; 1406 :                         _strupr( StringBufferEnd + 1 );

	mov	rcx, QWORD PTR ModuleInfo+488
	inc	rcx
	call	_strupr
$LN10@omf_write_:

; 1407 :                     AttachData( &obj, StringBufferEnd, len + 1 );

	mov	rcx, QWORD PTR ModuleInfo+488
	lea	eax, DWORD PTR [rdi+1]
	mov	QWORD PTR obj$2[rsp+8], rcx

; 1408 :                     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$2[rsp]
	mov	DWORD PTR obj$2[rsp], eax
	call	omf_write_record

; 1409 :                 } else if ( Parse_Pass == PASS_1 ) {
; 1410 :                     /* ??? */
; 1411 :                 }
; 1412 :                 continue;

	jmp	$LN4@omf_write_
$LN7@omf_write_:

; 1413 :             }
; 1414 : #endif
; 1415 :             /* for constants, Masm checks if the value will fit in a 16-bit field,
; 1416 :              * either signed ( -32768 ... 32767 ) or unsigned ( 0 ... 65635 ).
; 1417 :              * As a result, the following code:
; 1418 :              * E1 equ 32768
; 1419 :              * E2 equ -32768
; 1420 :              * PUBLIC E1, E2
; 1421 :              * will store both equates with value 8000h in the 16-bit PUBDEF record!!!
; 1422 :              * HJWasm behaves differently, resulting in negative values to be stored as 32-bit.
; 1423 :              */
; 1424 : #if 1
; 1425 :             is32 = ( sym->offset > 0xffffUL ? 1 : 0 );

	cmp	DWORD PTR [rdi+16], 65535		; 0000ffffH
	seta	bpl

; 1433 :             /* exit loop if segment or offset magnitude changes, or record becomes too big */
; 1434 :             if( size && ( sym->segment != curr_seg || is32 != curr32 || recsize > MAX_PUB_LENGTH ) )

	test	esi, esi
	je	SHORT $LN12@omf_write_
	cmp	rcx, r12
	jne	$LN41@omf_write_
	cmp	bpl, r13b
	jne	$LN41@omf_write_

; 1426 : #else
; 1427 :             is32 = ( sym->offset > 0xffff || sym->offset < -32768 ? 1 : 0 ); /* this is what Masm does */
; 1428 : #endif
; 1429 :             /* check if public fits in current record yet.
; 1430 :              * 4 bytes omf record overhead, 4 for base info, 1+1+4/2 for name_size, type & offset
; 1431 :              */
; 1432 :             recsize = size + sym->name_size + MANGLE_BYTES + 4+4+1+1+( is32 ? 4 : 2 );

	movzx	ecx, BYTE PTR [rdi+72]
	test	bpl, bpl
	mov	eax, 2
	cmovne	eax, edx
	add	ecx, 18
	add	eax, esi
	add	ecx, eax

; 1433 :             /* exit loop if segment or offset magnitude changes, or record becomes too big */
; 1434 :             if( size && ( sym->segment != curr_seg || is32 != curr32 || recsize > MAX_PUB_LENGTH ) )

	cmp	ecx, 1024				; 00000400H
	ja	SHORT $LN41@omf_write_
$LN12@omf_write_:

; 1435 :                 break;
; 1436 :             len = Mangle( sym, data + 1 );

	lea	rdx, QWORD PTR [rbx+1]
	mov	rcx, rdi
	call	Mangle

; 1437 : #if MAX_ID_LEN > MAX_ID_LEN_OMF
; 1438 :             if ( len > 255 )
; 1439 :                 len = 255; /* length is 1 byte only */
; 1440 : #endif
; 1441 :             if ( ModuleInfo.convert_uppercase )

	test	BYTE PTR ModuleInfo+408, 2
	mov	r15d, eax
	je	SHORT $LN14@omf_write_

; 1442 :                 _strupr( data + 1 );

	lea	rcx, QWORD PTR [rbx+1]
	call	_strupr
$LN14@omf_write_:

; 1443 :             curr_seg = sym->segment;

	mov	r12, QWORD PTR [rdi+24]

; 1444 :             curr32 = is32;
; 1445 : 
; 1446 :             *data = len;
; 1447 :             data += len + 1;

	lea	ecx, DWORD PTR [r15+1]
	mov	BYTE PTR [rbx], r15b
	movzx	r13d, bpl
	add	rbx, rcx

; 1448 :             if ( curr32 ) {

	test	bpl, bpl
	je	SHORT $LN15@omf_write_

; 1449 :                 *(uint_32 *)data = sym->offset;

	mov	eax, DWORD PTR [rdi+16]
	mov	DWORD PTR [rbx], eax

; 1450 :                 data += sizeof( uint_32 );

	add	rbx, 4

; 1451 :             } else {

	jmp	SHORT $LN16@omf_write_
$LN15@omf_write_:

; 1452 :                 *(uint_16 *)data = sym->offset;

	movzx	eax, WORD PTR [rdi+16]
	mov	WORD PTR [rbx], ax

; 1453 :                 data += sizeof( uint_16 );

	add	rbx, 2
$LN16@omf_write_:

; 1454 :             }
; 1455 :             *data++ = 0; /* type field */

	mov	BYTE PTR [rbx], 0
	inc	rbx

; 1456 :             size = (char *)data - StringBufferEnd;

	mov	esi, ebx
	sub	esi, DWORD PTR ModuleInfo+488
	xor	ebp, ebp
$LN4@omf_write_:

; 1383 :         struct asym     *curr_seg;
; 1384 :         uint_8          *data;
; 1385 :         unsigned        size;
; 1386 :         uint_8          curr32;
; 1387 :         uint_8          is32;
; 1388 : 
; 1389 :         for ( size = 0, data = StringBufferEnd; q; q = q->next ) {

	mov	r14, QWORD PTR [r14]
	mov	edx, 4
	test	r14, r14
	jne	$LL6@omf_write_
$LN41@omf_write_:
	xor	ebp, ebp
$LN13@omf_write_:

; 1457 :         }
; 1458 :         if ( size ) {

	test	esi, esi
	je	SHORT $LN17@omf_write_

; 1459 :             struct omf_rec      obj;
; 1460 :             omf_InitRec( &obj, CMD_PUBDEF );
; 1461 :             AttachData( &obj, StringBufferEnd, size );

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR obj$1[rsp+8], rax
	mov	DWORD PTR obj$1[rsp+4], ebp
	mov	BYTE PTR obj$1[rsp+16], 144		; 00000090H
	mov	DWORD PTR obj$1[rsp], esi

; 1462 :             obj.is_32 = curr32;

	mov	BYTE PTR obj$1[rsp+17], r13b

; 1463 :             if( curr_seg == NULL ) { /* absolute symbol, no segment */

	test	r12, r12
	jne	SHORT $LN18@omf_write_

; 1464 :                 obj.d.pubdef.base.grp_idx = 0;

	mov	DWORD PTR obj$1[rsp+20], r12d

; 1465 :                 obj.d.pubdef.base.seg_idx = 0;
; 1466 :             } else {

	jmp	SHORT $LN32@omf_write_
$LN18@omf_write_:

; 1467 :                 obj.d.pubdef.base.seg_idx = GetSegIdx( curr_seg );

	mov	rcx, r12
	call	GetSegIdx

; 1468 :                 obj.d.pubdef.base.grp_idx = omf_GetGrpIdx( GetGroup( curr_seg ) );

	mov	rcx, r12
	mov	WORD PTR obj$1[rsp+22], ax
	call	GetGroup
	test	rax, rax
	je	SHORT $LN31@omf_write_
	mov	rax, QWORD PTR [rax+96]
	movzx	ecx, WORD PTR [rax+8]
	mov	WORD PTR obj$1[rsp+20], cx
	jmp	SHORT $LN32@omf_write_
$LN31@omf_write_:
	mov	WORD PTR obj$1[rsp+20], bp
$LN32@omf_write_:

; 1469 :             }
; 1470 :             obj.d.pubdef.base.frame = 0;
; 1471 :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$1[rsp]
	mov	WORD PTR obj$1[rsp+24], bp
	call	omf_write_record
$LN17@omf_write_:

; 1382 :     while ( q ) {

	mov	edx, 4
	test	r14, r14
	jne	$LL2@omf_write_
	mov	r15, QWORD PTR [rsp+80]
	mov	r13, QWORD PTR [rsp+88]
	mov	r12, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+152]
	mov	rbp, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [rsp+136]
$LN40@omf_write_:

; 1472 :         }
; 1473 :     }
; 1474 : 
; 1475 :     DebugMsg1(("omf_write_pub exit\n"));
; 1476 :     return( NOT_ERROR );

	xor	eax, eax

; 1477 : }

	add	rsp, 112				; 00000070H
	pop	r14
	ret	0
omf_write_pubdef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_alias
_TEXT	SEGMENT
obj$ = 32
tmp$ = 80
buff$ = 336
omf_write_alias PROC					; COMDAT

; 1318 : {

	mov	rax, rsp
	push	rbx
	sub	rsp, 832				; 00000340H

; 1319 :     struct omf_rec      obj;
; 1320 :     char                *p;
; 1321 :     uint_8              len1;
; 1322 :     uint_8              len2;
; 1323 :     //bool                first = TRUE;
; 1324 :     struct dsym         *curr;
; 1325 :     char                tmp[MAX_ID_LEN + MANGLE_BYTES + 1];
; 1326 :     unsigned char       buff[2*MAX_ID_LEN_OMF + 2];
; 1327 : 
; 1328 :     for( curr = SymTables[TAB_ALIAS].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+80
	test	rbx, rbx
	je	$LN3@omf_write_
	mov	QWORD PTR [rax+8], rbp
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	mov	QWORD PTR [rax+32], r14
	xor	r14d, r14d
	npad	2
$LL4@omf_write_:

; 1329 : 
; 1330 :         /* output an alias record for this alias */
; 1331 :         /* v2.10: use the decorated names */
; 1332 :         //len1 = curr->sym.name_size;
; 1333 :         len1 = Mangle( &curr->sym, tmp );

	lea	rdx, QWORD PTR tmp$[rsp]
	mov	rcx, rbx
	call	Mangle

; 1334 : #if MAX_ID_LEN > MAX_ID_LEN_OMF
; 1335 :         if ( len1 > MAX_ID_LEN_OMF )
; 1336 :             len1 = MAX_ID_LEN_OMF;
; 1337 : #endif
; 1338 :         p = buff;
; 1339 :         *p++ = len1;
; 1340 :         memcpy( p, tmp, len1 );

	movzx	edi, al
	lea	rdx, QWORD PTR tmp$[rsp]
	mov	ebp, eax
	lea	rcx, QWORD PTR buff$[rsp+1]
	mov	r8d, edi
	mov	BYTE PTR buff$[rsp], bpl
	call	memcpy

; 1341 :         p += len1;
; 1342 : 
; 1343 :         //len2 = curr->sym.substitute->name_size;
; 1344 :         len2 = Mangle( curr->sym.substitute, tmp );

	mov	rcx, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR tmp$[rsp]
	call	Mangle
	mov	esi, eax

; 1345 : #if MAX_ID_LEN > MAX_ID_LEN_OMF
; 1346 :         if ( len2 > MAX_ID_LEN_OMF )
; 1347 :             len2 = MAX_ID_LEN_OMF;
; 1348 : #endif
; 1349 :         *p++ = len2;

	lea	rcx, QWORD PTR buff$[rsp+rdi+2]

; 1350 :         memcpy( p, tmp, len2 );

	movzx	r8d, al
	lea	rdx, QWORD PTR tmp$[rsp]
	mov	BYTE PTR buff$[rsp+rdi+1], sil
	call	memcpy

; 1351 : 
; 1352 :         omf_InitRec( &obj, CMD_ALIAS );
; 1353 :         AttachData( &obj, buff, len1 + len2 + 2 );

	lea	rax, QWORD PTR buff$[rsp]
	movzx	ecx, sil
	add	ecx, 2
	mov	QWORD PTR obj$[rsp+8], rax
	movzx	eax, bpl
	add	ecx, eax
	mov	DWORD PTR obj$[rsp+4], r14d
	mov	DWORD PTR obj$[rsp], ecx

; 1354 :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	WORD PTR obj$[rsp+16], 198		; 000000c6H
	call	omf_write_record
	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	$LL4@omf_write_
	mov	r14, QWORD PTR [rsp+872]
	mov	rdi, QWORD PTR [rsp+864]
	mov	rsi, QWORD PTR [rsp+856]
	mov	rbp, QWORD PTR [rsp+848]
$LN3@omf_write_:

; 1355 :         //first = FALSE;
; 1356 :     }
; 1357 : }

	add	rsp, 832				; 00000340H
	pop	rbx
	ret	0
omf_write_alias ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_autodep
_TEXT	SEGMENT
obj$ = 32
statbuf$1 = 80
dt$2 = 192
x$ = 200
omf_write_autodep PROC					; COMDAT

; 1279 : {

	mov	rax, rsp
	push	rbp
	push	rsi
	push	rdi
	push	r15
	sub	rsp, 152				; 00000098H

; 1280 :     struct omf_rec  obj;
; 1281 :     struct fname_item *curr;
; 1282 :     char            *p = StringBufferEnd;

	mov	rsi, QWORD PTR ModuleInfo+488

; 1283 :     unsigned int    len;
; 1284 :     unsigned        idx;
; 1285 : 
; 1286 :     DebugMsg(("omf_write_autodep() enter\n"));
; 1287 :     for( idx = 0, curr = ModuleInfo.g.FNames; idx < ModuleInfo.g.cnt_fnames; idx++, curr++ ) {

	xor	r15d, r15d
	cmp	DWORD PTR ModuleInfo+168, r15d
	mov	ebp, r15d
	mov	rdi, QWORD PTR ModuleInfo+160
	jbe	$LN3@omf_write_
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax-40], r12
	mov	r12d, 255				; 000000ffH
	mov	QWORD PTR [rax-48], r13
	mov	r13d, 512				; 00000200H
	mov	QWORD PTR [rax-56], r14
	npad	4
$LL4@omf_write_:

; 1288 :         omf_InitRec( &obj, CMD_COMENT );

	mov	QWORD PTR obj$[rsp], r15

; 1289 :         obj.d.coment.attr = CMT_TNP;
; 1290 :         obj.d.coment.cmt_class = CMT_DEPENDENCY; /* 0xE9 */
; 1291 : 
; 1292 :         len = strlen( curr->fname );

	or	rbx, -1
	mov	QWORD PTR obj$[rsp+8], r15
	mov	WORD PTR obj$[rsp+16], 136		; 00000088H
	mov	WORD PTR obj$[rsp+20], 59776		; 0000e980H
	mov	rcx, QWORD PTR [rdi]
	npad	1
$LL26@omf_write_:
	inc	rbx
	cmp	BYTE PTR [rcx+rbx], r15b
	jne	SHORT $LL26@omf_write_

; 1293 : #if MAX_STRING_LEN > 255
; 1294 :         if ( len > 255 )

	cmp	ebx, r12d

; 1295 :             len = 255; /* length is 1 byte only */
; 1296 : #endif
; 1297 :         /* v2.11: field mtime removed, timestamp read when needed */
; 1298 :         //*((time_t *)p) = timet2dostime( curr->mtime );
; 1299 :         *((time_t *)p) = timet2dostime( GetFileTimeStamp( curr->fname ) );

	lea	rdx, QWORD PTR statbuf$1[rsp]
	cmova	ebx, r12d
	call	_stat64i32
	mov	rcx, QWORD PTR statbuf$1[rsp+32]
	test	eax, eax
	cmovne	rcx, r15
	mov	QWORD PTR x$[rsp], rcx
	lea	rcx, QWORD PTR x$[rsp]
	call	_localtime64
	movzx	ecx, r13w
	movzx	edx, WORD PTR [rax+20]
	add	dx, 48					; 00000030H
	movzx	r8d, dx
	imul	r8d, ecx
	movzx	ecx, WORD PTR [rax+16]
	inc	cx
	shl	cx, 5
	or	r8w, cx
	movzx	ecx, WORD PTR [rax+8]
	or	r8w, WORD PTR [rax+12]
	shl	cx, 6
	or	cx, WORD PTR [rax+4]
	mov	eax, DWORD PTR [rax]
	cdq
	shl	cx, 5
	sub	eax, edx
	mov	WORD PTR dt$2[rsp+2], r8w
	sar	eax, 1
	or	cx, ax

; 1300 :         *(p + 4) = (unsigned char)len;
; 1301 :         memcpy( p + 5, curr->fname, len );

	mov	r8d, ebx
	mov	WORD PTR dt$2[rsp], cx
	lea	rcx, QWORD PTR [rsi+5]
	mov	rax, QWORD PTR dt$2[rsp]
	mov	QWORD PTR [rsi], rax
	mov	BYTE PTR [rsi+4], bl
	mov	rdx, QWORD PTR [rdi]
	call	memcpy

; 1302 :         AttachData( &obj, (uint_8 *)p, len + 5 );

	lea	eax, DWORD PTR [rbx+5]
	mov	QWORD PTR obj$[rsp+8], rsi

; 1303 :         DebugMsg(("omf_write_autodep(): write record: file=%s, time=%X\n", curr->fname, *((time_t *)p) ));
; 1304 :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR obj$[rsp], eax
	call	omf_write_record
	inc	ebp
	add	rdi, 8
	cmp	ebp, DWORD PTR ModuleInfo+168
	jb	$LL4@omf_write_
	mov	r14, QWORD PTR [rsp+128]
	mov	r13, QWORD PTR [rsp+136]
	mov	r12, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [rsp+208]
$LN3@omf_write_:

; 1305 :     }
; 1306 :     /* one NULL dependency record must be on the end */
; 1307 :     omf_InitRec( &obj, CMD_COMENT );
; 1308 :     obj.d.coment.attr = CMT_TNP;
; 1309 :     obj.d.coment.cmt_class = CMT_DEPENDENCY;
; 1310 :     AttachData( &obj, (uint_8 *)"", 0 );

	lea	rax, OFFSET FLAT:$SG12608
	mov	QWORD PTR obj$[rsp], r15

; 1311 :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	QWORD PTR obj$[rsp+8], rax
	mov	WORD PTR obj$[rsp+16], 136		; 00000088H
	mov	WORD PTR obj$[rsp+20], 59776		; 0000e980H
	call	omf_write_record

; 1312 :     DebugMsg(("omf_write_autodep() exit\n"));
; 1313 :     return( NOT_ERROR );

	xor	eax, eax

; 1314 : }

	add	rsp, 152				; 00000098H
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
omf_write_autodep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT GetFileTimeStamp
_TEXT	SEGMENT
statbuf$ = 32
filename$ = 96
GetFileTimeStamp PROC					; COMDAT

; 1263 : {

	sub	rsp, 88					; 00000058H

; 1264 :     struct _stat statbuf;
; 1265 : 
; 1266 :     if( _stat( filename, &statbuf ) != 0 ) {

	lea	rdx, QWORD PTR statbuf$[rsp]
	call	_stat64i32
	mov	rcx, QWORD PTR statbuf$[rsp+32]
	xor	edx, edx
	test	eax, eax
	cmovne	rcx, rdx
	mov	rax, rcx

; 1267 :         DebugMsg(("GetFileTimeStamp(%s): _stat() did return 0\n", filename ));
; 1268 :         return( 0 );
; 1269 :     }
; 1270 :     return( statbuf.st_mtime );
; 1271 : }

	add	rsp, 88					; 00000058H
	ret	0
GetFileTimeStamp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_comdef
_TEXT	SEGMENT
number$ = 32
obj$ = 48
buffer$ = 96
data$ = 352
index$ = 1424
omf_write_comdef PROC					; COMDAT

; 1179 : {

	mov	rax, rsp
	push	rbp
	push	rdi
	push	r13
	push	r15
	lea	rbp, QWORD PTR [rax-1160]
	sub	rsp, 1384				; 00000568H

; 1180 :     struct omf_rec obj;
; 1181 :     struct dsym    *curr;
; 1182 :     unsigned    num;
; 1183 :     unsigned    recsize;
; 1184 :     unsigned    numsize;
; 1185 :     unsigned    symsize;
; 1186 :     uint_32     varsize;
; 1187 :     unsigned    start = 0; /* record's start index (not used) */
; 1188 :     char        buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 1189 :     char        data[MAX_EXT_LENGTH];
; 1190 :     char        number[16];
; 1191 : 
; 1192 :     DebugMsg1(("omf_write_comdef enter\n"));
; 1193 :     curr = SymTables[TAB_EXT].head;

	mov	rdi, QWORD PTR SymTables+16
	xor	r13d, r13d
	movzx	r15d, cx

; 1194 :     while ( curr ) {

	test	rdi, rdi
	je	$LN107@omf_write_
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], r12
	mov	QWORD PTR [rax-40], r14
	npad	2
$LL2@omf_write_:

; 1195 :         for( num = 0, recsize = 0; curr != NULL ; curr = curr->next ) {

	xor	r12d, r12d
	xor	esi, esi
	test	rdi, rdi
	je	$LN106@omf_write_
	npad	2
$LL6@omf_write_:

; 1196 :             if ( curr->sym.iscomm == FALSE )

	test	BYTE PTR [rdi+47], 4
	je	$LN4@omf_write_

; 1197 :                 continue;
; 1198 :             symsize = Mangle( &curr->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rdi
	call	Mangle

; 1199 : #if MAX_ID_LEN > 255
; 1200 :             if ( symsize > 255 )
; 1201 :                 symsize = 255; /* length is 1 byte only */
; 1202 : #endif
; 1203 :             /* v2.11: case mapping was missing */
; 1204 :             if ( ModuleInfo.convert_uppercase )

	test	BYTE PTR ModuleInfo+408, 2
	mov	r14d, eax
	je	SHORT $LN8@omf_write_

; 1205 :                 _strupr( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	_strupr
$LN8@omf_write_:

; 1206 : 
; 1207 :             varsize = SizeFromMemtype( curr->sym.mem_type, ModuleInfo.Ofssize, curr->sym.type );

	movzx	edx, BYTE PTR ModuleInfo+404
	mov	r8, QWORD PTR [rdi+80]
	mov	ecx, DWORD PTR [rdi+36]
	call	SizeFromMemtype

; 1208 : 
; 1209 :             /**/ myassert( index );
; 1210 :             curr->sym.ext_idx = index++; /* v2.09: set external index here */

	movzx	ecx, r15w
	mov	r8d, eax
	inc	r15w
	mov	DWORD PTR [rdi+88], ecx

; 1211 : 
; 1212 :             DebugMsg1(("omf_write_comdef: %s, size=%u, sym.total_size=%u, sym.total_length=%u, sym.isfar=%u\n",
; 1213 :                       curr->sym.name, varsize, curr->sym.total_size, curr->sym.total_length, curr->sym.isfar ));
; 1214 :             if ( varsize == 0 )

	test	eax, eax
	jne	SHORT $LN9@omf_write_

; 1215 :                 varsize = curr->sym.total_size / curr->sym.total_length;

	mov	eax, DWORD PTR [rdi+56]
	xor	edx, edx
	div	DWORD PTR [rdi+64]
	mov	r8d, eax
$LN9@omf_write_:

; 1216 : 
; 1217 :             numsize = 1;
; 1218 :             if ( curr->sym.isfar == TRUE ) {

	test	BYTE PTR [rdi+47], 16

; 1219 :                 number[0] = COMDEF_FAR;  /* 0x61 */
; 1220 :                 numsize += put_comdef_number( &number[1], curr->sym.total_length );

	lea	rdx, QWORD PTR number$[rsp+1]
	mov	ecx, DWORD PTR [rdi+64]
	je	$LN10@omf_write_
	mov	BYTE PTR number$[rsp], 97		; 00000061H
	cmp	ecx, 128				; 00000080H
	jae	SHORT $LN27@omf_write_
	mov	r10d, 1
	jmp	SHORT $LN31@omf_write_
$LN27@omf_write_:
	cmp	ecx, 65535				; 0000ffffH
	ja	SHORT $LN29@omf_write_
	mov	r10d, 3
	jmp	SHORT $LN31@omf_write_
$LN29@omf_write_:
	xor	r10d, r10d
	cmp	ecx, 16777215				; 00ffffffH
	seta	r10b
	add	r10d, 4
$LN31@omf_write_:
	mov	eax, r10d
	sub	eax, 1
	je	SHORT $LN21@omf_write_
	sub	eax, 2
	je	SHORT $LN22@omf_write_
	sub	eax, 1
	je	SHORT $LN23@omf_write_
	cmp	eax, 1
	je	SHORT $LN24@omf_write_
	cmp	r10d, 1
	jbe	SHORT $LN19@omf_write_
	jmp	SHORT $LN103@omf_write_
$LN24@omf_write_:
	mov	BYTE PTR number$[rsp+1], 136		; 00000088H
	jmp	SHORT $LN112@omf_write_
$LN23@omf_write_:
	mov	BYTE PTR number$[rsp+1], 132		; 00000084H
	jmp	SHORT $LN112@omf_write_
$LN22@omf_write_:
	mov	BYTE PTR number$[rsp+1], 129		; 00000081H
$LN112@omf_write_:
	lea	rdx, QWORD PTR number$[rsp+2]
$LN103@omf_write_:
	lea	r9d, DWORD PTR [r10-1]
$LL86@omf_write_:
	mov	BYTE PTR [rdx], cl
	lea	rdx, QWORD PTR [rdx+1]
	shr	ecx, 8
	sub	r9, 1
	jne	SHORT $LL86@omf_write_
	jmp	SHORT $LN19@omf_write_
$LN21@omf_write_:
	mov	BYTE PTR number$[rsp+1], cl
$LN19@omf_write_:
	lea	ebx, DWORD PTR [r10+1]

; 1221 :                 numsize += put_comdef_number( &number[numsize], varsize );

	lea	rax, QWORD PTR number$[rsp]
	add	rax, rbx
	cmp	r8d, 128				; 00000080H
	jae	SHORT $LN46@omf_write_
	mov	r9d, 1
	jmp	SHORT $LN50@omf_write_
$LN46@omf_write_:
	cmp	r8d, 65535				; 0000ffffH
	ja	SHORT $LN48@omf_write_
	mov	r9d, 3
	jmp	SHORT $LN50@omf_write_
$LN48@omf_write_:
	xor	r9d, r9d
	cmp	r8d, 16777215				; 00ffffffH
	seta	r9b
	add	r9d, 4
$LN50@omf_write_:
	mov	ecx, r9d
	sub	ecx, 1
	je	SHORT $LN40@omf_write_
	sub	ecx, 2
	je	SHORT $LN41@omf_write_
	sub	ecx, 1
	je	SHORT $LN42@omf_write_
	cmp	ecx, 1
	je	SHORT $LN43@omf_write_
	cmp	r9d, 1
	jbe	SHORT $LN38@omf_write_
	jmp	SHORT $LN104@omf_write_
$LN43@omf_write_:
	mov	BYTE PTR [rax], 136			; 00000088H
	jmp	SHORT $LN113@omf_write_
$LN42@omf_write_:
	mov	BYTE PTR [rax], 132			; 00000084H
	jmp	SHORT $LN113@omf_write_
$LN41@omf_write_:
	mov	BYTE PTR [rax], 129			; 00000081H
$LN113@omf_write_:
	inc	rax
$LN104@omf_write_:
	lea	edx, DWORD PTR [r9-1]
	npad	8
$LL88@omf_write_:
	mov	BYTE PTR [rax], r8b
	lea	rax, QWORD PTR [rax+1]
	shr	r8d, 8
	sub	rdx, 1
	jne	SHORT $LL88@omf_write_
	add	ebx, r9d

; 1222 :                 DebugMsg(("omf_write_comdef: numsize=%u, length=%u, varsize=%u\n",
; 1223 :                           numsize, curr->sym.total_length, varsize ));
; 1224 :             } else {

	jmp	$LN11@omf_write_

; 1221 :                 numsize += put_comdef_number( &number[numsize], varsize );

$LN40@omf_write_:
	mov	BYTE PTR [rax], r8b
$LN38@omf_write_:
	add	ebx, r9d

; 1222 :                 DebugMsg(("omf_write_comdef: numsize=%u, length=%u, varsize=%u\n",
; 1223 :                           numsize, curr->sym.total_length, varsize ));
; 1224 :             } else {

	jmp	$LN11@omf_write_
$LN10@omf_write_:

; 1225 :                 number[0] = COMDEF_NEAR; /* 0x62 */
; 1226 :                 numsize += put_comdef_number( &number[1], curr->sym.total_length * varsize );

	imul	ecx, r8d
	mov	BYTE PTR number$[rsp], 98		; 00000062H
	cmp	ecx, 128				; 00000080H
	jae	SHORT $LN65@omf_write_
	mov	r9d, 1
	jmp	SHORT $LN69@omf_write_
$LN65@omf_write_:
	cmp	ecx, 65535				; 0000ffffH
	ja	SHORT $LN67@omf_write_
	mov	r9d, 3
	jmp	SHORT $LN69@omf_write_
$LN67@omf_write_:
	xor	r9d, r9d
	cmp	ecx, 16777215				; 00ffffffH
	seta	r9b
	add	r9d, 4
$LN69@omf_write_:
	mov	eax, r9d
	sub	eax, 1
	je	SHORT $LN59@omf_write_
	sub	eax, 2
	je	SHORT $LN60@omf_write_
	sub	eax, 1
	je	SHORT $LN61@omf_write_
	cmp	eax, 1
	je	SHORT $LN62@omf_write_
	cmp	r9d, 1
	jbe	SHORT $LN57@omf_write_
	jmp	SHORT $LN105@omf_write_
$LN62@omf_write_:
	mov	BYTE PTR number$[rsp+1], 136		; 00000088H
	jmp	SHORT $LN114@omf_write_
$LN61@omf_write_:
	mov	BYTE PTR number$[rsp+1], 132		; 00000084H
	jmp	SHORT $LN114@omf_write_
$LN60@omf_write_:
	mov	BYTE PTR number$[rsp+1], 129		; 00000081H
$LN114@omf_write_:
	lea	rdx, QWORD PTR number$[rsp+2]
$LN105@omf_write_:
	lea	r8d, DWORD PTR [r9-1]
	npad	7
$LL90@omf_write_:
	mov	BYTE PTR [rdx], cl
	lea	rdx, QWORD PTR [rdx+1]
	shr	ecx, 8
	sub	r8, 1
	jne	SHORT $LL90@omf_write_
	jmp	SHORT $LN57@omf_write_
$LN59@omf_write_:
	mov	BYTE PTR number$[rsp+1], cl
$LN57@omf_write_:
	lea	ebx, DWORD PTR [r9+1]
$LN11@omf_write_:

; 1227 :                 DebugMsg1(("omf_write_comdef: numsize=%u, value=%u\n",
; 1228 :                           numsize, curr->sym.total_length * varsize ));
; 1229 :             }
; 1230 :             /* make sure the record's size doesn't exceed 1024.
; 1231 :              * 2 = 1 (name len) + 1 (type index)
; 1232 :              */
; 1233 :             if ( ( recsize + symsize + numsize + 2 ) > MAX_EXT_LENGTH )

	lea	eax, DWORD PTR [rbx+r14]
	lea	ecx, DWORD PTR [rsi+2]
	add	ecx, eax
	cmp	ecx, 1020				; 000003fcH
	ja	SHORT $LN81@omf_write_

; 1234 :                 break;
; 1235 : 
; 1236 :             /* copy name ( including size prefix ), type, number */
; 1237 :             data[recsize++] = (char)symsize;

	mov	BYTE PTR data$[rbp+rsi-256], r14b

; 1238 :             memcpy( data + recsize, buffer, symsize );

	lea	rcx, QWORD PTR data$[rbp-256]
	inc	esi
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	eax, esi
	mov	r8, r14
	add	rcx, rax
	call	memcpy

; 1239 :             recsize += symsize;

	add	esi, r14d

; 1240 :             data[recsize++] = 0;      /* for the type index */
; 1241 :             memcpy( data + recsize, number, numsize );

	mov	r8d, ebx
	lea	rcx, QWORD PTR data$[rbp-256]
	lea	rdx, QWORD PTR number$[rsp]
	mov	BYTE PTR data$[rbp+rsi-256], 0
	inc	esi
	mov	eax, esi
	add	rcx, rax
	call	memcpy

; 1242 :             recsize += numsize;

	add	esi, ebx

; 1243 : 
; 1244 :             num++;

	inc	r12d
$LN4@omf_write_:

; 1195 :         for( num = 0, recsize = 0; curr != NULL ; curr = curr->next ) {

	mov	rdi, QWORD PTR [rdi+104]
	test	rdi, rdi
	jne	$LL6@omf_write_
$LN81@omf_write_:

; 1245 : 
; 1246 :         } /* end for */
; 1247 : 
; 1248 :         if( num > 0 ) {

	test	r12d, r12d
	je	SHORT $LN13@omf_write_

; 1249 :             omf_InitRec( &obj, CMD_COMDEF );
; 1250 :             obj.d.comdef.first_idx = start; /* unused */
; 1251 :             AttachData( &obj, (uint_8 *)data, recsize );

	lea	rax, QWORD PTR data$[rbp-256]
	mov	DWORD PTR obj$[rsp+4], 0

; 1252 :             obj.d.comdef.num_names = num; /* unused */
; 1253 :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	QWORD PTR obj$[rsp+8], rax
	mov	WORD PTR obj$[rsp+16], 176		; 000000b0H
	mov	WORD PTR obj$[rsp+20], r13w
	mov	DWORD PTR obj$[rsp], esi
	mov	WORD PTR obj$[rsp+22], r12w
	call	omf_write_record

; 1254 :             start += num;

	add	r13d, r12d
$LN13@omf_write_:

; 1194 :     while ( curr ) {

	test	rdi, rdi
	jne	$LL2@omf_write_
$LN106@omf_write_:
	mov	r12, QWORD PTR [rsp+1440]

; 1255 :         }
; 1256 :     }
; 1257 :     DebugMsg1(("omf_write_comdef exit\n"));
; 1258 :     return( index );

	movzx	eax, r15w
	mov	rsi, QWORD PTR [rsp+1432]
	mov	rbx, QWORD PTR [rsp+1424]
	mov	r14, QWORD PTR [rsp+1376]

; 1259 : }

	add	rsp, 1384				; 00000568H
	pop	r15
	pop	r13
	pop	rdi
	pop	rbp
	ret	0
$LN107@omf_write_:

; 1255 :         }
; 1256 :     }
; 1257 :     DebugMsg1(("omf_write_comdef exit\n"));
; 1258 :     return( index );

	movzx	eax, r15w

; 1259 : }

	add	rsp, 1384				; 00000568H
	pop	r15
	pop	r13
	pop	rdi
	pop	rbp
	ret	0
omf_write_comdef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT put_comdef_number
_TEXT	SEGMENT
buffer$ = 8
value$ = 16
put_comdef_number PROC					; COMDAT

; 1149 : {

	mov	rax, rcx

; 1150 :     unsigned i;
; 1151 :     unsigned symsize;
; 1152 : 
; 1153 :     symsize = get_size_of_comdef_number( value );

	cmp	edx, 128				; 00000080H
	jae	SHORT $LN13@put_comdef
	mov	r8d, 1
	jmp	SHORT $LN17@put_comdef
$LN13@put_comdef:
	cmp	edx, 65535				; 0000ffffH
	ja	SHORT $LN15@put_comdef
	mov	r8d, 3
	jmp	SHORT $LN17@put_comdef
$LN15@put_comdef:
	xor	r8d, r8d
	cmp	edx, 16777215				; 00ffffffH
	seta	r8b
	add	r8d, 4
$LN17@put_comdef:

; 1154 :     switch( symsize ) {

	mov	ecx, r8d
	sub	ecx, 1
	je	SHORT $LN7@put_comdef
	sub	ecx, 2
	je	SHORT $LN8@put_comdef
	sub	ecx, 1
	je	SHORT $LN9@put_comdef
	cmp	ecx, 1
	jne	SHORT $LN2@put_comdef

; 1158 :     case 5:  *buffer++ = COMDEF_LEAF_4;  break; /* 0x88 */

	mov	BYTE PTR [rax], 136			; 00000088H
	inc	rax
	jmp	SHORT $LN2@put_comdef
$LN9@put_comdef:

; 1157 :     case 4:  *buffer++ = COMDEF_LEAF_3;  break; /* 0x84 */

	mov	BYTE PTR [rax], 132			; 00000084H
	inc	rax
	jmp	SHORT $LN26@put_comdef
$LN8@put_comdef:

; 1156 :     case 3:  *buffer++ = COMDEF_LEAF_2;  break; /* 0x81 */

	mov	BYTE PTR [rax], 129			; 00000081H
	inc	rax
	jmp	SHORT $LN26@put_comdef
$LN7@put_comdef:

; 1155 :     case 1:  *buffer = value; break;

	mov	BYTE PTR [rax], dl
$LN2@put_comdef:

; 1159 :     }
; 1160 : 
; 1161 :     for( i = 1; i < symsize; i++ ) {

	cmp	r8d, 1
	jbe	SHORT $LN27@put_comdef
$LN26@put_comdef:
	lea	r9d, DWORD PTR [r8-1]
	npad	1
$LL22@put_comdef:

; 1162 :         *buffer++ = value % ( UCHAR_MAX + 1 );

	mov	BYTE PTR [rax], dl
	lea	rax, QWORD PTR [rax+1]

; 1163 :         value >>= 8;

	shr	edx, 8
	sub	r9, 1
	jne	SHORT $LL22@put_comdef
$LN27@put_comdef:

; 1164 :     }
; 1165 :     return( symsize );

	mov	eax, r8d

; 1166 : }

	ret	0
put_comdef_number ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT get_size_of_comdef_number
_TEXT	SEGMENT
value$ = 8
get_size_of_comdef_number PROC				; COMDAT

; 1130 :     /* The spec allows up to 128 in a one byte size field, but lots
; 1131 :        of software has problems with that, so we'll restrict ourselves
; 1132 :        to 127.
; 1133 :     */
; 1134 :     if( value < 128 ) {

	cmp	ecx, 128				; 00000080H
	jae	SHORT $LN2@get_size_o

; 1135 :         return( 1 );    /* 1 byte value */

	mov	eax, 1

; 1139 :         return( 4 );    /* 1 byte flag + 3 byte value */
; 1140 :     } else { /* if( value <= ULONG_MAX ) */
; 1141 :         return( 5 );    /* 1 byte flag + 4 byte value */
; 1142 :     }
; 1143 : }

	ret	0
$LN2@get_size_o:

; 1136 :     } else if( value <= USHRT_MAX ) {

	cmp	ecx, 65535				; 0000ffffH
	ja	SHORT $LN4@get_size_o

; 1137 :         return( 3 );    /* 1 byte flag + 2 byte value */

	mov	eax, 3

; 1139 :         return( 4 );    /* 1 byte flag + 3 byte value */
; 1140 :     } else { /* if( value <= ULONG_MAX ) */
; 1141 :         return( 5 );    /* 1 byte flag + 4 byte value */
; 1142 :     }
; 1143 : }

	ret	0
$LN4@get_size_o:

; 1138 :     } else if( value <= THREE_BYTE_MAX ) {

	xor	eax, eax
	cmp	ecx, 16777215				; 00ffffffH
	seta	al
	add	eax, 4

; 1139 :         return( 4 );    /* 1 byte flag + 3 byte value */
; 1140 :     } else { /* if( value <= ULONG_MAX ) */
; 1141 :         return( 5 );    /* 1 byte flag + 4 byte value */
; 1142 :     }
; 1143 : }

	ret	0
get_size_of_comdef_number ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_extdef
_TEXT	SEGMENT
obj$ = 32
buffer$ = 80
data$ = 336
tv675 = 1408
omf_write_extdef PROC					; COMDAT

; 1035 : {

	mov	rax, rsp
	push	rbp
	push	r13
	push	r15
	lea	rbp, QWORD PTR [rax-1144]
	sub	rsp, 1376				; 00000560H
	mov	QWORD PTR [rax+16], rbx

; 1036 :     struct omf_rec obj;
; 1037 :     struct asym *sym;
; 1038 :     struct dsym *symext;
; 1039 :     unsigned    rec_size;
; 1040 :     unsigned    len;
; 1041 :     struct readext r;
; 1042 :     char        data[MAX_EXT_LENGTH];
; 1043 :     unsigned char buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 1044 : 
; 1045 :     DebugMsg1(("omf_write_extdef enter\n"));
; 1046 : 
; 1047 :     r.p = SymTables[TAB_EXT].head;
; 1048 :     r.index = 1;
; 1049 :     r.method = 0;
; 1050 :     obj.d.extdef.first_idx = 0;

	xor	r13d, r13d
	mov	rbx, QWORD PTR SymTables+16
	mov	ecx, 1
	mov	QWORD PTR [rax+32], rdi
	movzx	r15d, cx
	mov	QWORD PTR [rax-32], r12
	xor	r12b, r12b
	mov	DWORD PTR tv675[rbp-256], r15d
	mov	WORD PTR obj$[rsp+20], r13w

; 1051 : 
; 1052 :     /* scan the EXTERN/EXTERNDEF items */
; 1053 : 
; 1054 :     sym = GetExt( &r );

	test	rbx, rbx
	je	SHORT $LN91@omf_write_
	npad	6
$LL20@omf_write_:
	test	BYTE PTR [rbx+47], 4
	lea	rdi, QWORD PTR [rbx]
	mov	rbx, QWORD PTR [rbx+104]
	jne	SHORT $LN28@omf_write_
	mov	rax, QWORD PTR [rdi+64]
	test	rax, rax
	je	SHORT $LN28@omf_write_
	test	BYTE PTR [rax+41], 64			; 00000040H
	je	SHORT $LN67@omf_write_
$LN28@omf_write_:
	test	rbx, rbx
	jne	SHORT $LL20@omf_write_
$LN91@omf_write_:
	mov	rbx, QWORD PTR SymTables+16
	movzx	r12d, cl
	test	rbx, rbx
	je	$LN96@omf_write_
	npad	11
$LL23@omf_write_:
	mov	rdi, rbx
	mov	rbx, QWORD PTR [rbx+104]
	test	BYTE PTR [rdi+47], 12
	je	SHORT $LN29@omf_write_
	test	rbx, rbx
	jne	SHORT $LL23@omf_write_

; 1066 : 
; 1067 :             if( rec_size + len + 2 >= MAX_EXT_LENGTH ) {

	jmp	$LN96@omf_write_
$LN67@omf_write_:

; 1051 : 
; 1052 :     /* scan the EXTERN/EXTERNDEF items */
; 1053 : 
; 1054 :     sym = GetExt( &r );

	mov	WORD PTR [rax+90], cx
	mov	rax, QWORD PTR [rdi+64]
	or	BYTE PTR [rax+41], 64			; 00000040H
	mov	rdi, QWORD PTR [rdi+64]
	jmp	SHORT $LN99@omf_write_
$LN29@omf_write_:
	mov	WORD PTR [rdi+88], cx
$LN99@omf_write_:
	mov	r15d, 2
	mov	DWORD PTR tv675[rbp-256], r15d

; 1055 :     while ( sym ) {

	test	rdi, rdi
	je	$LN96@omf_write_
	mov	QWORD PTR [rsp+1424], rsi
	mov	QWORD PTR [rsp+1360], r14
$LL2@omf_write_:

; 1056 :         for ( rec_size = 0, obj.d.extdef.num_names = 0; sym; sym = GetExt( &r ) ) {

	mov	WORD PTR obj$[rsp+22], r13w
	mov	r14d, r13d
	test	rdi, rdi
	je	$LN98@omf_write_
	npad	11
$LL32@omf_write_:

; 1057 :             //DebugMsg(("omf_write_extdef: %s, weak=%u, used=%u\n", curr->sym.name, curr->sym.weak, curr->sym.used ));
; 1058 :             DebugMsg1(("omf_write_extdef: %s\n", sym->name));
; 1059 :             len = Mangle( sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rdi
	call	Mangle

; 1060 : #if MAX_ID_LEN > 255
; 1061 :             if ( len > 255 )
; 1062 :                 len = 255; /* length is 1 byte only */
; 1063 : #endif
; 1064 :             if ( ModuleInfo.convert_uppercase )

	test	BYTE PTR ModuleInfo+408, 2
	mov	esi, eax
	je	SHORT $LN13@omf_write_

; 1065 :                 _strupr( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	_strupr
$LN13@omf_write_:

; 1066 : 
; 1067 :             if( rec_size + len + 2 >= MAX_EXT_LENGTH ) {

	lea	eax, DWORD PTR [r14+2]
	add	eax, esi
	cmp	eax, 1020				; 000003fcH
	jae	$LN94@omf_write_

; 1068 :                 break;
; 1069 :             }
; 1070 :             obj.d.extdef.num_names++;

	inc	WORD PTR obj$[rsp+22]

; 1071 : 
; 1072 :             data[rec_size++] = (char)len;
; 1073 :             memcpy( data + rec_size, buffer, len );

	lea	rcx, QWORD PTR data$[rbp-256]
	mov	eax, r14d
	lea	rdx, QWORD PTR buffer$[rsp]
	inc	r14d
	mov	r8, rsi
	mov	BYTE PTR data$[rbp+rax-256], sil
	mov	eax, r14d
	add	rcx, rax
	call	memcpy

; 1074 :             rec_size += len;

	add	r14d, esi

; 1075 :             data[rec_size++] = 0;      /* for the type index */

	mov	eax, r14d
	mov	BYTE PTR data$[rbp+r14-256], r13b
	inc	r14d
	test	r12b, r12b
	jne	SHORT $LN39@omf_write_

; 1056 :         for ( rec_size = 0, obj.d.extdef.num_names = 0; sym; sym = GetExt( &r ) ) {

	test	rbx, rbx
	je	SHORT $LN92@omf_write_
$LL33@omf_write_:
	test	BYTE PTR [rbx+47], 4
	lea	rcx, QWORD PTR [rbx]
	mov	rbx, QWORD PTR [rbx+104]
	jne	SHORT $LN41@omf_write_
	mov	rax, QWORD PTR [rcx+64]
	test	rax, rax
	je	SHORT $LN41@omf_write_
	test	BYTE PTR [rax+41], 64			; 00000040H
	je	$LN68@omf_write_
$LN41@omf_write_:
	test	rbx, rbx
	jne	SHORT $LL33@omf_write_
$LN92@omf_write_:
	mov	rbx, QWORD PTR SymTables+16
	mov	r12b, 1
$LN39@omf_write_:
	test	rbx, rbx
	je	SHORT $LN90@omf_write_
	npad	10
$LL36@omf_write_:
	mov	rdi, rbx
	mov	rbx, QWORD PTR [rbx+104]
	test	BYTE PTR [rdi+47], 12
	je	$LN42@omf_write_
	test	rbx, rbx
	jne	SHORT $LL36@omf_write_
$LN90@omf_write_:
	mov	rdi, r13
$LN94@omf_write_:

; 1076 :         }
; 1077 :         if ( rec_size ) {

	test	r14d, r14d
	je	SHORT $LN15@omf_write_

; 1078 :             DebugMsg1(("omf_write_extdef: write record, names=%u, size=%u, MAX=%u\n", obj.d.extdef.num_names, rec_size, MAX_EXT_LENGTH ));
; 1079 :             omf_InitRec( &obj, CMD_EXTDEF );
; 1080 :             AttachData( &obj, (uint_8 *)data, rec_size );

	lea	rax, QWORD PTR data$[rbp-256]
	mov	DWORD PTR obj$[rsp+4], r13d

; 1081 :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	QWORD PTR obj$[rsp+8], rax
	mov	WORD PTR obj$[rsp+16], 140		; 0000008cH
	mov	DWORD PTR obj$[rsp], r14d
	call	omf_write_record

; 1082 :             obj.d.extdef.first_idx += obj.d.extdef.num_names;

	movzx	eax, WORD PTR obj$[rsp+22]
	add	WORD PTR obj$[rsp+20], ax
$LN15@omf_write_:

; 1055 :     while ( sym ) {

	test	rdi, rdi
	jne	$LL2@omf_write_
$LN98@omf_write_:
	mov	rsi, QWORD PTR [rsp+1424]
	mov	r14, QWORD PTR [rsp+1360]
$LN96@omf_write_:

; 1083 :         }
; 1084 :     }
; 1085 : 
; 1086 :     /* v2.04: write WKEXT coment records.
; 1087 :      * those items are defined via "EXTERN (altname)" syntax.
; 1088 :      * After the records have been written, the indices in
; 1089 :      * altname are no longer needed.
; 1090 :      */
; 1091 : 
; 1092 :     for ( symext = SymTables[TAB_EXT].head; symext; symext = symext->next ) {

	mov	rbx, QWORD PTR SymTables+16
	mov	r12, QWORD PTR [rsp+1368]
	mov	rdi, QWORD PTR [rsp+1432]
	test	rbx, rbx
	je	$LN8@omf_write_
	mov	r15d, 1
	npad	5
$LL9@omf_write_:

; 1093 :         if ( symext->sym.iscomm == FALSE && symext->sym.altname ) {

	test	BYTE PTR [rbx+47], 4
	jne	$LN7@omf_write_
	cmp	QWORD PTR [rbx+64], r13
	je	$LN7@omf_write_

; 1094 :             omf_InitRec( &obj, CMD_COMENT );
; 1095 :             obj.d.coment.attr = CMT_TNP;
; 1096 :             obj.d.coment.cmt_class = CMT_WKEXT;
; 1097 :             AttachData( &obj, buffer, 4 );

	lea	rcx, QWORD PTR buffer$[rsp]
	mov	eax, r13d
	mov	DWORD PTR obj$[rsp+4], eax
	mov	QWORD PTR obj$[rsp+8], rcx
	mov	WORD PTR obj$[rsp+16], 136		; 00000088H
	mov	WORD PTR obj$[rsp+20], 43136		; 0000a880H
	mov	DWORD PTR obj$[rsp], 4

; 1098 :             PutIndex( &obj, symext->sym.ext_idx1 );

	movzx	ecx, WORD PTR [rbx+88]
	cmp	ecx, 127				; 0000007fH
	jbe	SHORT $LN54@omf_write_
	mov	eax, ecx
	shr	eax, 8
	or	al, 128					; 00000080H
	mov	BYTE PTR buffer$[rsp], al
	mov	eax, r15d
	mov	DWORD PTR obj$[rsp+4], eax
$LN54@omf_write_:
	mov	BYTE PTR buffer$[rsp+rax], cl
	mov	ecx, DWORD PTR obj$[rsp+4]
	inc	ecx
	mov	DWORD PTR obj$[rsp+4], ecx

; 1099 :             PutIndex( &obj, symext->sym.altname->ext_idx2 );

	mov	rax, QWORD PTR [rbx+64]
	movzx	r8d, WORD PTR [rax+90]
	cmp	r8d, 127				; 0000007fH
	jbe	SHORT $LN57@omf_write_
	mov	rax, QWORD PTR obj$[rsp+8]
	mov	edx, r8d
	shr	edx, 8
	or	dl, 128					; 00000080H
	mov	BYTE PTR [rcx+rax], dl
	mov	ecx, DWORD PTR obj$[rsp+4]
	inc	ecx
	mov	DWORD PTR obj$[rsp+4], ecx
$LN57@omf_write_:
	mov	rax, QWORD PTR obj$[rsp+8]
	mov	BYTE PTR [rcx+rax], r8b

; 1100 :             TruncRec( &obj );
; 1101 :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	eax, DWORD PTR obj$[rsp+4]
	inc	eax
	mov	DWORD PTR obj$[rsp+4], eax
	mov	DWORD PTR obj$[rsp], eax
	call	omf_write_record
$LN7@omf_write_:

; 1083 :         }
; 1084 :     }
; 1085 : 
; 1086 :     /* v2.04: write WKEXT coment records.
; 1087 :      * those items are defined via "EXTERN (altname)" syntax.
; 1088 :      * After the records have been written, the indices in
; 1089 :      * altname are no longer needed.
; 1090 :      */
; 1091 : 
; 1092 :     for ( symext = SymTables[TAB_EXT].head; symext; symext = symext->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	$LL9@omf_write_
	mov	r15d, DWORD PTR tv675[rbp-256]
$LN8@omf_write_:

; 1102 :         }
; 1103 :     }
; 1104 :     /* v2.05: reset the indices - this must be done only after ALL WKEXT
; 1105 :      * records have been written!
; 1106 :      */
; 1107 :     for ( symext = SymTables[TAB_EXT].head; symext; symext = symext->next ) {

	mov	rcx, QWORD PTR SymTables+16
	mov	rbx, QWORD PTR [rsp+1416]
	test	rcx, rcx
	je	SHORT $LN93@omf_write_
$LL12@omf_write_:

; 1108 :             /* v2.09: don't touch the index if the alternate name is an external
; 1109 :              * - else an invalid object file will be created!
; 1110 :              */
; 1111 :         if ( symext->sym.iscomm == FALSE && symext->sym.altname && symext->sym.altname->state != SYM_EXTERNAL )

	test	BYTE PTR [rcx+47], 4
	jne	SHORT $LN10@omf_write_
	mov	rdx, QWORD PTR [rcx+64]
	test	rdx, rdx
	je	SHORT $LN10@omf_write_
	cmp	DWORD PTR [rdx+32], 2
	je	SHORT $LN10@omf_write_

; 1112 :             symext->sym.altname->ext_idx = 0;

	mov	DWORD PTR [rdx+88], r13d
$LN10@omf_write_:

; 1102 :         }
; 1103 :     }
; 1104 :     /* v2.05: reset the indices - this must be done only after ALL WKEXT
; 1105 :      * records have been written!
; 1106 :      */
; 1107 :     for ( symext = SymTables[TAB_EXT].head; symext; symext = symext->next ) {

	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL12@omf_write_
$LN93@omf_write_:

; 1113 :     }
; 1114 :     /* v2.09: write COMM items here. This allows to handle
; 1115 :      * the external index field entirely in omf.c
; 1116 :      * v2.11: removed again, since omf_write_extdef() is no
; 1117 :      * longer called externally.
; 1118 :      */
; 1119 :     //omf_write_comdef( r.index );
; 1120 : 
; 1121 :     DebugMsg1(("omf_write_extdef exit, index=%u\n", r.index ));
; 1122 :     return( r.index );

	movzx	eax, r15w

; 1123 : }

	add	rsp, 1376				; 00000560H
	pop	r15
	pop	r13
	pop	rbp
	ret	0
$LN68@omf_write_:

; 1056 :         for ( rec_size = 0, obj.d.extdef.num_names = 0; sym; sym = GetExt( &r ) ) {

	mov	WORD PTR [rax+90], r15w
	inc	r15w
	mov	rax, QWORD PTR [rcx+64]
	or	BYTE PTR [rax+41], 64			; 00000040H
	mov	rdi, QWORD PTR [rcx+64]
	jmp	SHORT $LN100@omf_write_
$LN42@omf_write_:
	mov	WORD PTR [rdi+88], r15w
	inc	r15w
$LN100@omf_write_:
	mov	DWORD PTR tv675[rbp-256], r15d
	test	rdi, rdi
	jne	$LL32@omf_write_
	jmp	$LN94@omf_write_
omf_write_extdef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT GetExt
_TEXT	SEGMENT
r$ = 8
GetExt	PROC						; COMDAT

; 998  :     struct asym *sym;
; 999  :     if ( r->method == 0 ) {

	cmp	BYTE PTR [rcx+10], 0
	jne	SHORT $LN8@GetExt

; 1000 :         for ( ; r->p; ) {

	cmp	QWORD PTR [rcx], 0
$LN22@GetExt:
	je	SHORT $LN21@GetExt

; 1001 :             sym = (struct asym *)r->p;

	mov	r8, QWORD PTR [rcx]

; 1002 :             r->p = r->p->next;

	mov	rdx, QWORD PTR [r8+104]
	mov	QWORD PTR [rcx], rdx

; 1003 :             if ( sym->iscomm == TRUE )

	test	BYTE PTR [r8+47], 4
	jne	SHORT $LN10@GetExt

; 1004 :                 continue;
; 1005 :             if ( sym->altname && sym->altname->included == FALSE ) {

	mov	rax, QWORD PTR [r8+64]
	test	rax, rax
	je	SHORT $LN10@GetExt
	test	BYTE PTR [rax+41], 64			; 00000040H
	je	SHORT $LN16@GetExt
$LN10@GetExt:

; 1000 :         for ( ; r->p; ) {

	test	rdx, rdx
	jmp	SHORT $LN22@GetExt
$LN16@GetExt:

; 1006 :                 /**/ myassert( r->index ); /* overflow occured? */
; 1007 :                 sym->altname->ext_idx2 = r->index++;

	mov	rdx, rax
	movzx	eax, WORD PTR [rcx+8]
	mov	WORD PTR [rdx+90], ax
	inc	WORD PTR [rcx+8]

; 1008 :                 sym->altname->included = TRUE;

	mov	rax, QWORD PTR [r8+64]
	or	BYTE PTR [rax+41], 64			; 00000040H

; 1009 :                 return( sym->altname );

	mov	rax, QWORD PTR [r8+64]

; 1026 : }

	ret	0
$LN21@GetExt:

; 1010 :             }
; 1011 :         }
; 1012 :         r->method++;

	mov	BYTE PTR [rcx+10], 1

; 1013 :         r->p = SymTables[TAB_EXT].head;

	mov	rax, QWORD PTR SymTables+16
	mov	QWORD PTR [rcx], rax
$LN8@GetExt:

; 1014 :     }
; 1015 :     for ( ; r->p; ) {

	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN6@GetExt
	npad	15
$LL5@GetExt:

; 1016 :         sym = (struct asym *)r->p;

	mov	rax, QWORD PTR [rcx]

; 1017 :         r->p = r->p->next;

	mov	rdx, QWORD PTR [rax+104]
	mov	QWORD PTR [rcx], rdx
	test	BYTE PTR [rax+47], 12

; 1018 :         if ( sym->iscomm == TRUE || sym->weak == TRUE )

	je	SHORT $LN11@GetExt

; 1014 :     }
; 1015 :     for ( ; r->p; ) {

	test	rdx, rdx
	jne	SHORT $LL5@GetExt
$LN6@GetExt:

; 1022 :         //r->p->sym.included = TRUE;
; 1023 :         return( sym );
; 1024 :     }
; 1025 :     return( NULL );

	xor	eax, eax

; 1026 : }

	ret	0
$LN11@GetExt:

; 1019 :             continue;
; 1020 :         /**/ myassert( r->index ); /* overflow occured? */
; 1021 :         sym->ext_idx1 = r->index++;

	movzx	edx, WORD PTR [rcx+8]
	mov	WORD PTR [rax+88], dx
	inc	WORD PTR [rcx+8]

; 1026 : }

	ret	0
GetExt	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_lnames
_TEXT	SEGMENT
obj$ = 32
buffer$ = 80
omf_write_lnames PROC					; COMDAT

; 923  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 1104				; 00000450H

; 924  :     int         size;
; 925  :     int         items;
; 926  :     unsigned char *p;
; 927  :     //void        *pv = NULL;
; 928  :     struct qnode *curr;
; 929  :     struct asym *sym;
; 930  :     struct omf_rec obj;
; 931  :     unsigned char buffer[MAX_LNAME_SIZE];
; 932  : 
; 933  :     DebugMsg1(("omf_write_lnames() enter\n"));
; 934  :     p = buffer;
; 935  :     *p++ = NULLC; /* start with the NULL entry */
; 936  :     items = 1;
; 937  :     startitem = 1;
; 938  : 
; 939  :     for ( curr = ModuleInfo.g.LnameQueue.head; ; curr = curr->next ) {

	mov	r14, QWORD PTR ModuleInfo+32
	lea	rsi, QWORD PTR buffer$[rsp+1]
	mov	edi, 1
	mov	BYTE PTR buffer$[rsp], 0
	mov	ebp, edi
	mov	DWORD PTR startitem, edi
	xor	r15d, r15d
	npad	4
$LL4@omf_write_:

; 940  :         //sym = GetLnameData( &pv );
; 941  :         sym = ( curr ? (struct asym *)(curr->elmt) : NULL );

	test	r14, r14
	je	SHORT $LN16@omf_write_
	mov	rbx, QWORD PTR [r14+8]
	jmp	SHORT $LN17@omf_write_
$LN16@omf_write_:
	mov	rbx, r15
$LN17@omf_write_:

; 942  :         size = p - buffer;

	lea	rax, QWORD PTR buffer$[rsp]
	mov	edx, esi
	sub	edx, eax

; 943  :         /* v2.04: changed extra bytes from 1 to 4 (CMD, RECLEN, CHKSUM) */
; 944  :         //if ( sym == NULL || ( ( size + sym->name_size + 1 ) > MAX_LNAME_SIZE )) {
; 945  :         if ( sym == NULL || ( ( size + sym->name_size + 4 ) > MAX_LNAME_SIZE )) {

	test	rbx, rbx
	je	SHORT $LN8@omf_write_
	movzx	eax, BYTE PTR [rbx+72]
	lea	ecx, DWORD PTR [rdx+4]
	add	ecx, eax
	cmp	ecx, 1024				; 00000400H
	jle	SHORT $LN7@omf_write_
$LN8@omf_write_:

; 946  :             if( size ) {

	test	edx, edx
	je	SHORT $LN9@omf_write_

; 947  :                 omf_InitRec( &obj, CMD_LNAMES );
; 948  :                 /* first_idx and num_names are NOT
; 949  :                  * written to the LNAMES record!
; 950  :                  * In fact, they aren't used at all.
; 951  :                  */
; 952  :                 obj.d.lnames.first_idx = startitem;
; 953  :                 obj.d.lnames.num_names = items;
; 954  :                 AttachData( &obj, buffer, size );

	lea	rax, QWORD PTR buffer$[rsp]
	mov	DWORD PTR obj$[rsp+4], r15d

; 955  :                 omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	QWORD PTR obj$[rsp+8], rax
	mov	WORD PTR obj$[rsp+16], 150		; 00000096H
	mov	WORD PTR obj$[rsp+20], bp
	mov	WORD PTR obj$[rsp+22], di
	mov	DWORD PTR obj$[rsp], edx
	call	omf_write_record

; 956  :                 startitem = items;

	mov	ebp, edi
	mov	DWORD PTR startitem, edi
$LN9@omf_write_:

; 957  :             }
; 958  :             if ( sym == NULL )

	test	rbx, rbx
	je	SHORT $LN24@omf_write_

; 959  :                 break;
; 960  :             p = buffer;

	lea	rsi, QWORD PTR buffer$[rsp]
$LN7@omf_write_:

; 961  :         }
; 962  :         *p++ = (char)sym->name_size;

	movzx	eax, BYTE PTR [rbx+72]
	mov	BYTE PTR [rsi], al
	inc	rsi

; 963  :         /* copy 1 byte more - the NULLC - for _strupr() */
; 964  :         memcpy( p, sym->name, sym->name_size + 1 );

	movzx	eax, BYTE PTR [rbx+72]
	mov	rcx, rsi
	mov	rdx, QWORD PTR [rbx+8]
	inc	eax
	movsxd	r8, eax
	call	memcpy

; 965  :         /* lnames are converted for casemaps ALL and NOTPUBLIC */
; 966  :         if ( ModuleInfo.case_sensitive == FALSE )

	test	BYTE PTR ModuleInfo+408, 1
	jne	SHORT $LN11@omf_write_

; 967  :             _strupr( p );

	mov	rcx, rsi
	call	_strupr
	mov	ebp, DWORD PTR startitem
$LN11@omf_write_:

; 968  :         DebugMsg1(("omf_write_lnames: %u=%s\n", items, p ));
; 969  :         p += sym->name_size; /* overwrite the null char */

	movzx	eax, BYTE PTR [rbx+72]

; 970  :         items++;

	inc	edi

; 971  :         /* v2.12: lname_idx fields now set in OMF only */
; 972  :         switch ( sym->state ) {

	mov	ecx, DWORD PTR [rbx+32]
	add	rsi, rax
	sub	ecx, 3
	je	SHORT $LN12@omf_write_
	cmp	ecx, 1
	je	SHORT $LN13@omf_write_

; 975  :         default:      sym->class_lname_idx = items;                       break;

	mov	DWORD PTR [rbx+16], edi
	mov	r14, QWORD PTR [r14]
	jmp	$LL4@omf_write_
$LN13@omf_write_:

; 974  :         case SYM_GRP: ((struct dsym *)sym)->e.grpinfo->lname_idx = items; break;

	mov	rax, QWORD PTR [rbx+96]
	mov	DWORD PTR [rax+12], edi
	mov	r14, QWORD PTR [r14]
	jmp	$LL4@omf_write_
$LN12@omf_write_:

; 973  :         case SYM_SEG: ((struct dsym *)sym)->e.seginfo->lname_idx = items; break;

	mov	rax, QWORD PTR [rbx+96]
	mov	DWORD PTR [rax+76], edi
	mov	r14, QWORD PTR [r14]
	jmp	$LL4@omf_write_
$LN24@omf_write_:

; 976  :         }
; 977  :     };
; 978  : 
; 979  :     DebugMsg1(("omf_write_lnames() exit, items=%u\n", items ));
; 980  : }

	lea	r11, QWORD PTR [rsp+1104]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
omf_write_lnames ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_segdef
_TEXT	SEGMENT
obj$ = 32
buffer$1 = 96
omf_write_segdef PROC					; COMDAT

; 855  : {

	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	mov	rbp, rsp
	sub	rsp, 80					; 00000050H

; 856  :     struct dsym    *curr;
; 857  :     struct omf_rec obj;
; 858  : 
; 859  :     DebugMsg1(("omf_write_segdef enter\n"));
; 860  : 
; 861  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	test	rbx, rbx
	je	$LN3@omf_write_
	mov	QWORD PTR [rsp+104], rsi
	mov	QWORD PTR [rsp+112], rdi
	xor	edi, edi
	lea	esi, QWORD PTR [rdi+1]
	npad	4
$LL4@omf_write_:

; 862  : 
; 863  : #if COMDATSUPP
; 864  :         if ( curr->e.seginfo->comdat_selection )

	mov	rax, QWORD PTR [rbx+96]
	test	BYTE PTR [rax+108], 56			; 00000038H
	jne	$LN2@omf_write_

; 865  :             continue;
; 866  : #endif
; 867  :         omf_InitRec( &obj, CMD_SEGDEF );

	mov	QWORD PTR obj$[rbp-80], rdi
	mov	QWORD PTR obj$[rbp-72], rdi
	mov	WORD PTR obj$[rbp-64], 152		; 00000098H

; 868  :         if ( curr->e.seginfo->Ofssize > USE16 ) {

	mov	rax, QWORD PTR [rbx+96]
	cmp	BYTE PTR [rax+104], dil
	jbe	SHORT $LN6@omf_write_

; 869  :             obj.is_32 = ( ( curr->e.seginfo->force32 || ( curr->sym.max_offset >= 0x10000 ) ) ? 1 : 0 );

	test	BYTE PTR [rax+107], 4
	jne	SHORT $LN10@omf_write_
	cmp	DWORD PTR [rbx+56], 65536		; 00010000H
	jl	SHORT $LN6@omf_write_
$LN10@omf_write_:
	mov	BYTE PTR obj$[rbp-63], sil

; 870  :         } else {

	jmp	SHORT $LN7@omf_write_
$LN6@omf_write_:

; 871  :             obj.is_32 = 0;

	mov	BYTE PTR obj$[rbp-63], dil
$LN7@omf_write_:

; 872  :         }
; 873  : 
; 874  :         obj.d.segdef.idx             = curr->e.seginfo->seg_idx;

	mov	rax, QWORD PTR [rbx+96]
	movzx	ecx, WORD PTR [rax+68]
	mov	WORD PTR obj$[rbp-60], cx

; 875  :         obj.d.segdef.use_32          = ( curr->e.seginfo->Ofssize > USE16 ? 1 : 0 );

	mov	rax, QWORD PTR [rbx+96]
	cmp	BYTE PTR [rax+104], dil
	seta	BYTE PTR obj$[rbp-58]

; 876  :         obj.d.segdef.align           = get_omfalign( curr->e.seginfo->alignment );

	mov	rax, QWORD PTR [rbx+96]
	movzx	ecx, BYTE PTR [rax+106]
	sub	ecx, esi
	je	SHORT $LN19@omf_write_
	sub	ecx, esi
	je	SHORT $LN20@omf_write_
	sub	ecx, 2
	je	SHORT $LN21@omf_write_
	sub	ecx, 4
	je	SHORT $LN22@omf_write_
	cmp	ecx, 247				; 000000f7H
	je	SHORT $LN23@omf_write_
	movzx	eax, sil
	jmp	SHORT $LN16@omf_write_
$LN23@omf_write_:
	xor	al, al
	jmp	SHORT $LN16@omf_write_
$LN22@omf_write_:
	mov	al, 4
	jmp	SHORT $LN16@omf_write_
$LN21@omf_write_:
	mov	al, 3
	jmp	SHORT $LN16@omf_write_
$LN20@omf_write_:
	mov	al, 5
	jmp	SHORT $LN16@omf_write_
$LN19@omf_write_:
	mov	al, 2
$LN16@omf_write_:
	mov	BYTE PTR obj$[rbp-57], al

; 877  :         obj.d.segdef.combine         = curr->e.seginfo->combine;

	mov	rax, QWORD PTR [rbx+96]
	movzx	ecx, BYTE PTR [rax+108]
	and	cl, 7
	mov	BYTE PTR obj$[rbp-56], cl

; 878  :         obj.d.segdef.abs.frame       = curr->e.seginfo->abs_frame;

	mov	rax, QWORD PTR [rbx+96]
	movzx	ecx, WORD PTR [rax+88]
	mov	WORD PTR obj$[rbp-52], cx

; 879  :         obj.d.segdef.abs.offset      = curr->e.seginfo->abs_offset;

	mov	rax, QWORD PTR [rbx+96]
	mov	ecx, DWORD PTR [rax+96]
	mov	DWORD PTR obj$[rbp-48], ecx

; 880  :         obj.d.segdef.seg_length      = curr->sym.max_offset;

	mov	eax, DWORD PTR [rbx+56]
	mov	DWORD PTR obj$[rbp-44], eax

; 881  :         obj.d.segdef.seg_lname_idx   = curr->e.seginfo->lname_idx;

	mov	rax, QWORD PTR [rbx+96]
	movzx	ecx, WORD PTR [rax+76]
	mov	WORD PTR obj$[rbp-40], cx

; 882  :         obj.d.segdef.class_lname_idx = ( curr->e.seginfo->clsym ? curr->e.seginfo->clsym->class_lname_idx : 1 );

	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rax+80]
	test	rcx, rcx
	je	SHORT $LN12@omf_write_
	movzx	eax, WORD PTR [rcx+16]
	mov	WORD PTR obj$[rbp-38], ax
	jmp	SHORT $LN13@omf_write_
$LN12@omf_write_:
	mov	WORD PTR obj$[rbp-38], si
$LN13@omf_write_:

; 883  :         obj.d.segdef.ovl_lname_idx   = 1;
; 884  : 
; 885  :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rbp-80]
	mov	WORD PTR obj$[rbp-36], si
	call	omf_write_record

; 886  :         DebugMsg1(("omf_write_segdef(%s): len=%" I32_SPEC "X use32=%u align=%u comb=%u seg_lname=%u class_lname=%u ovl_lname=%u\n",
; 887  :                   curr->sym.name,
; 888  :                   obj.d.segdef.seg_length,
; 889  :                   obj.d.segdef.use_32,
; 890  :                   obj.d.segdef.align,
; 891  :                   obj.d.segdef.combine,
; 892  :                   obj.d.segdef.seg_lname_idx,
; 893  :                   obj.d.segdef.class_lname_idx,
; 894  :                   obj.d.segdef.ovl_lname_idx
; 895  :                  ));
; 896  :         /* write a comment for the linker.
; 897  :          * this is something not done by Masm, it has
; 898  :          * been inherited from Wasm.
; 899  :          */
; 900  :         if( curr->e.seginfo->segtype == SEGTYPE_CODE && Options.no_opt_farcall == FALSE ) {

	mov	rax, QWORD PTR [rbx+96]
	cmp	DWORD PTR [rax+72], esi
	jne	SHORT $LN2@omf_write_
	cmp	BYTE PTR Options+113, dil
	jne	SHORT $LN2@omf_write_

; 901  :             uint_8 buffer[4];
; 902  :             omf_InitRec( &obj, CMD_COMENT );
; 903  :             obj.d.coment.attr = CMT_TNP;
; 904  :             obj.d.coment.cmt_class = CMT_LINKER_DIRECTIVE;
; 905  :             AttachData( &obj, buffer, 3 );

	lea	rax, QWORD PTR buffer$1[rbp-80]
	mov	WORD PTR obj$[rbp-64], 136		; 00000088H
	mov	QWORD PTR obj$[rbp-72], rax

; 906  :             Put8( &obj, LDIR_OPT_FAR_CALLS );

	mov	ecx, esi
	mov	DWORD PTR obj$[rbp-76], ecx
	mov	WORD PTR obj$[rbp-60], 65152		; 0000fe80H
	mov	DWORD PTR obj$[rbp-80], 3

; 907  :             PutIndex( &obj, curr->e.seginfo->seg_idx );

	mov	rax, QWORD PTR [rbx+96]
	mov	BYTE PTR buffer$1[rbp-80], 79		; 0000004fH
	mov	edx, DWORD PTR [rax+68]
	cmp	edx, 127				; 0000007fH
	jbe	SHORT $LN32@omf_write_
	mov	eax, edx
	mov	ecx, 2
	shr	eax, 8
	or	al, 128					; 00000080H
	mov	DWORD PTR obj$[rbp-76], ecx
	mov	BYTE PTR buffer$1[rbp-79], al
$LN32@omf_write_:
	mov	eax, ecx

; 908  :             /* v2.04: added. cut off the 3. byte if not needed */
; 909  :             TruncRec( &obj );
; 910  :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rbp-80]
	mov	BYTE PTR buffer$1[rbp+rax-80], dl
	mov	eax, DWORD PTR obj$[rbp-76]
	inc	eax
	mov	DWORD PTR obj$[rbp-76], eax
	mov	DWORD PTR obj$[rbp-80], eax
	call	omf_write_record
$LN2@omf_write_:

; 856  :     struct dsym    *curr;
; 857  :     struct omf_rec obj;
; 858  : 
; 859  :     DebugMsg1(("omf_write_segdef enter\n"));
; 860  : 
; 861  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	$LL4@omf_write_
	mov	rdi, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+104]
$LN3@omf_write_:

; 911  :         }
; 912  :     }
; 913  :     DebugMsg1(("omf_write_segdef exit\n"));
; 914  : }

	mov	rbx, QWORD PTR [rsp+120]
	add	rsp, 80					; 00000050H
	pop	rbp
	ret	0
omf_write_segdef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_grpdef
_TEXT	SEGMENT
grp$ = 32
omf_write_grpdef PROC					; COMDAT

; 783  : {

	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	mov	rbp, rsp
	sub	rsp, 80					; 00000050H

; 784  :     struct dsym     *curr;
; 785  :     struct dsym     *segminfo;
; 786  :     struct seg_item *seg;
; 787  :     struct omf_rec  grp;
; 788  :     //char            writeseg;
; 789  : 
; 790  :     DebugMsg1(("omf_write_grpdef enter\n"));
; 791  :     //line_num = LineNumber;
; 792  : 
; 793  :     /* size of group records may exceed 1024! */
; 794  :     for( curr = SymTables[TAB_GRP].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+48
	test	rbx, rbx
	je	$LN3@omf_write_
	mov	QWORD PTR [rsp+96], rdi
	xor	edi, edi
	npad	12
$LL4@omf_write_:

; 795  : 
; 796  :         omf_InitRec( &grp, CMD_GRPDEF );
; 797  : 
; 798  :         grp.d.grpdef.idx = curr->e.grpinfo->grp_idx;
; 799  : 
; 800  :         /* we might need:
; 801  :          * - 1 or 2 bytes for the group name index
; 802  :          * - 2 or 3 bytes for each segment in the group
; 803  :          */
; 804  :         AttachData( &grp, StringBufferEnd, 2 + 3 * curr->e.grpinfo->numseg );

	mov	r8, QWORD PTR ModuleInfo+488
	mov	edx, edi
	mov	DWORD PTR grp$[rbp-80], edi
	mov	QWORD PTR grp$[rbp-72], rdi
	mov	DWORD PTR grp$[rbp-76], edx
	mov	WORD PTR grp$[rbp-64], 154		; 0000009aH
	mov	rax, QWORD PTR [rbx+96]
	movzx	ecx, WORD PTR [rax+8]
	mov	WORD PTR grp$[rbp-60], cx
	mov	rax, QWORD PTR [rbx+96]
	mov	ecx, DWORD PTR [rax+16]
	mov	QWORD PTR grp$[rbp-72], r8
	lea	ecx, DWORD PTR [rcx+rcx*2]
	add	ecx, 2
	mov	DWORD PTR grp$[rbp-80], ecx

; 805  :         /* v2.01: the LName index of the group may be > 0xff */
; 806  :         /* v2.03: use the group index directly */
; 807  :         PutIndex( &grp, curr->e.grpinfo->lname_idx );

	mov	rax, QWORD PTR [rbx+96]
	mov	ecx, DWORD PTR [rax+12]
	cmp	ecx, 127				; 0000007fH
	jbe	SHORT $LN15@omf_write_
	mov	eax, ecx
	shr	eax, 8
	or	al, 128					; 00000080H
	mov	BYTE PTR [r8], al
	mov	edx, DWORD PTR grp$[rbp-76]
	mov	r8, QWORD PTR grp$[rbp-72]
	inc	edx
	mov	DWORD PTR grp$[rbp-76], edx
$LN15@omf_write_:
	mov	eax, edx
	mov	BYTE PTR [rax+r8], cl
	mov	ecx, DWORD PTR grp$[rbp-76]
	inc	ecx
	mov	DWORD PTR grp$[rbp-76], ecx

; 808  : 
; 809  :         for( seg = curr->e.grpinfo->seglist; seg; seg = seg->next ) {

	mov	rax, QWORD PTR [rbx+96]
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	je	$LN6@omf_write_
	npad	7
$LL7@omf_write_:

; 810  :             //writeseg = TRUE;
; 811  :             segminfo = (struct dsym *)(seg->seg);

	mov	r8, QWORD PTR [rax+8]

; 812  :             Put8( &grp, GRP_SEGIDX );

	mov	edx, ecx
	mov	rcx, QWORD PTR grp$[rbp-72]
	mov	BYTE PTR [rdx+rcx], 255			; 000000ffH
	mov	edx, DWORD PTR grp$[rbp-76]
	inc	edx
	mov	DWORD PTR grp$[rbp-76], edx

; 813  :             PutIndex( &grp, segminfo->e.seginfo->seg_idx );

	mov	rcx, QWORD PTR [r8+96]
	mov	r9d, DWORD PTR [rcx+68]
	cmp	r9d, 127				; 0000007fH
	jbe	SHORT $LN20@omf_write_
	mov	rcx, QWORD PTR grp$[rbp-72]
	mov	r8d, r9d
	shr	r8d, 8
	or	r8b, 128				; 00000080H
	mov	BYTE PTR [rdx+rcx], r8b
	mov	edx, DWORD PTR grp$[rbp-76]
	inc	edx
	mov	DWORD PTR grp$[rbp-76], edx
$LN20@omf_write_:
	mov	rcx, QWORD PTR grp$[rbp-72]
	mov	BYTE PTR [rdx+rcx], r9b
	mov	ecx, DWORD PTR grp$[rbp-76]
	inc	ecx
	mov	DWORD PTR grp$[rbp-76], ecx

; 814  :             /* truncate the group record if it comes near output buffer limit! */
; 815  :             if ( grp.curoff > OBJ_BUFFER_SIZE - 10 ) {

	cmp	ecx, 4070				; 00000fe6H
	ja	SHORT $LN24@omf_write_

; 808  : 
; 809  :         for( seg = curr->e.grpinfo->seglist; seg; seg = seg->next ) {

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL7@omf_write_

; 814  :             /* truncate the group record if it comes near output buffer limit! */
; 815  :             if ( grp.curoff > OBJ_BUFFER_SIZE - 10 ) {

	jmp	SHORT $LN6@omf_write_
$LN24@omf_write_:

; 816  :                 EmitWarn( 2, GROUP_DEFINITION_TOO_LARGE, curr->sym.name );

	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 266				; 0000010aH
	mov	ecx, 2
	call	EmitWarn
	mov	ecx, DWORD PTR grp$[rbp-76]
$LN6@omf_write_:

; 817  :                 break;
; 818  :             }
; 819  :         }
; 820  :         TruncRec( &grp );

	mov	DWORD PTR grp$[rbp-80], ecx

; 821  :         omf_write_record( &grp );

	lea	rcx, QWORD PTR grp$[rbp-80]
	call	omf_write_record
	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	$LL4@omf_write_
	mov	rdi, QWORD PTR [rsp+96]
$LN3@omf_write_:

; 822  :     }
; 823  :     DebugMsg1(("omf_write_grpdef exit\n"));
; 824  : }

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 80					; 00000050H
	pop	rbp
	ret	0
omf_write_grpdef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_export
_TEXT	SEGMENT
obj$ = 32
omf_write_export PROC					; COMDAT

; 717  : {

	push	rbx
	sub	rsp, 80					; 00000050H

; 718  :     uint_8      parmcnt;
; 719  :     struct dsym *dir;
; 720  :     struct dsym *parm;
; 721  :     struct omf_rec obj;
; 722  :     int         len;
; 723  :     uint_8      *data;
; 724  : 
; 725  : #if DLLIMPORT && WRITEIMPDEF /* writing import records in OMF not supported yet */
; 726  :     omf_write_import();
; 727  : #endif
; 728  : 
; 729  :     for( dir = SymTables[TAB_PROC].head; dir != NULL; dir = dir->nextproc ) {

	mov	rbx, QWORD PTR SymTables+64
	test	rbx, rbx
	je	$LN3@omf_write_
	mov	QWORD PTR [rsp+120], r14
	xor	r14d, r14d
	mov	QWORD PTR [rsp+96], rbp
	mov	QWORD PTR [rsp+104], rsi
	mov	QWORD PTR [rsp+112], rdi
	npad	3
$LL4@omf_write_:

; 730  :         if( dir->e.procinfo->isexport ) {

	mov	rax, QWORD PTR [rbx+96]
	test	BYTE PTR [rax+84], 4
	je	$LN2@omf_write_

; 731  : 
; 732  :             omf_InitRec( &obj, CMD_COMENT );
; 733  :             obj.d.coment.attr = 0x00;
; 734  :             obj.d.coment.cmt_class = CMT_OMF_EXT;
; 735  :             data = StringBufferEnd;
; 736  : 
; 737  :             /* structure of EXPDEF "comment":
; 738  :              * type          db CMT_EXT_EXPDEF (=02)
; 739  :              * exported_flag db ?
; 740  :              * ex_name_len   db ?
; 741  :              * exported_name db ex_name_len dup (?)
; 742  :              * int_name_len  db 0     ;always 0
; 743  :              * ;internal_name db int_name_len dup (?)
; 744  :              * ;ordinal      dw ?     ;optional
; 745  :              */
; 746  :             if ( Options.no_export_decoration == FALSE )

	cmp	BYTE PTR Options+119, r14b
	mov	rsi, QWORD PTR ModuleInfo+488
	mov	QWORD PTR obj$[rsp], r14
	mov	QWORD PTR obj$[rsp+8], r14
	mov	WORD PTR obj$[rsp+16], 136		; 00000088H

; 747  :                 len = Mangle( &dir->sym, data+3 );

	lea	rdi, QWORD PTR [rsi+3]
	mov	WORD PTR obj$[rsp+20], 40960		; 0000a000H
	jne	SHORT $LN9@omf_write_
	mov	rdx, rdi
	mov	rcx, rbx
	call	Mangle
	mov	ebp, eax
	jmp	SHORT $LN10@omf_write_
$LN9@omf_write_:

; 748  :             else {
; 749  :                 strcpy( data+3, dir->sym.name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	r8, rdi
$LL13@omf_write_:
	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	mov	BYTE PTR [r8], al
	lea	r8, QWORD PTR [r8+1]
	test	al, al
	jne	SHORT $LL13@omf_write_

; 750  :                 len = dir->sym.name_size;

	movzx	ebp, BYTE PTR [rbx+72]
$LN10@omf_write_:

; 751  :             }
; 752  :             /* v2.11: case mapping was missing */
; 753  :             if ( ModuleInfo.convert_uppercase )

	test	BYTE PTR ModuleInfo+408, 2
	je	SHORT $LN11@omf_write_

; 754  :                 _strupr( data+3 );

	mov	rcx, rdi
	call	_strupr
$LN11@omf_write_:

; 755  : #if MAX_ID_LEN > 255
; 756  :             if ( len > 255 )
; 757  :                 len = 255; /* restrict name to 255 chars */
; 758  : #endif
; 759  :             AttachData( &obj, data, len + 4 );

	mov	QWORD PTR obj$[rsp+8], rsi
	lea	eax, DWORD PTR [rbp+4]
	mov	DWORD PTR obj$[rsp], eax

; 760  :             Put8( &obj, CMT_EXT_EXPDEF );
; 761  :             /* write the "Exported Flag" byte:
; 762  :              * bits 0-4: parameter count
; 763  :              * bit 5: no data (entry doesn't use initialized data )
; 764  :              * bit 6: resident (name should be kept resident)
; 765  :              * bit 7: ordinal ( if 1, 2 byte index must follow name)
; 766  :              */
; 767  :             for ( parm = dir->e.procinfo->paralist, parmcnt = 0; parm; parm = parm->nextparam, parmcnt++ );

	xor	dl, dl
	mov	eax, DWORD PTR obj$[rsp+4]
	mov	BYTE PTR [rax+rsi], 2
	mov	ecx, DWORD PTR obj$[rsp+4]
	inc	ecx
	mov	DWORD PTR obj$[rsp+4], ecx
	mov	rax, QWORD PTR [rbx+96]
	mov	rax, QWORD PTR [rax+8]
	test	rax, rax
	je	SHORT $LN6@omf_write_
$LL7@omf_write_:
	mov	rax, QWORD PTR [rax+112]
	inc	dl
	test	rax, rax
	jne	SHORT $LL7@omf_write_
$LN6@omf_write_:

; 768  :             parmcnt &= 0x1F; /* ensure bits 5-7 are still 0 */
; 769  :             Put8( &obj, parmcnt ); /* v2.01: changed from fix 0x00 */

	mov	rax, QWORD PTR obj$[rsp+8]
	and	dl, 31
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR obj$[rsp+4]
	inc	eax
	mov	DWORD PTR obj$[rsp+4], eax

; 770  :             Put8( &obj, len );

	mov	ecx, eax
	mov	rax, QWORD PTR obj$[rsp+8]
	mov	BYTE PTR [rcx+rax], bpl

; 771  :             obj.curoff += len;

	mov	ecx, DWORD PTR obj$[rsp+4]

; 772  :             Put8( &obj, 0 );

	mov	rax, QWORD PTR obj$[rsp+8]
	inc	ecx
	add	ecx, ebp
	mov	DWORD PTR obj$[rsp+4], ecx
	mov	BYTE PTR [rcx+rax], r14b

; 773  :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	inc	DWORD PTR obj$[rsp+4]
	call	omf_write_record
$LN2@omf_write_:

; 718  :     uint_8      parmcnt;
; 719  :     struct dsym *dir;
; 720  :     struct dsym *parm;
; 721  :     struct omf_rec obj;
; 722  :     int         len;
; 723  :     uint_8      *data;
; 724  : 
; 725  : #if DLLIMPORT && WRITEIMPDEF /* writing import records in OMF not supported yet */
; 726  :     omf_write_import();
; 727  : #endif
; 728  : 
; 729  :     for( dir = SymTables[TAB_PROC].head; dir != NULL; dir = dir->nextproc ) {

	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	$LL4@omf_write_
	mov	r14, QWORD PTR [rsp+120]
	mov	rdi, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+96]
$LN3@omf_write_:

; 774  :         }
; 775  :     }
; 776  : }

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
omf_write_export ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_lib
_TEXT	SEGMENT
obj$ = 32
omf_write_lib PROC					; COMDAT

; 643  : {

	sub	rsp, 88					; 00000058H

; 644  :     struct omf_rec      obj;
; 645  :     struct qitem        *curr;
; 646  :     struct qitem        *next;
; 647  :     char                *name;
; 648  : 
; 649  :     DebugMsg1(("omf_write_lib() enter\n"));
; 650  :     for( curr = ModuleInfo.g.LibQueue.head; curr; curr = next ) {

	mov	rcx, QWORD PTR ModuleInfo+64
	test	rcx, rcx
	je	SHORT $LN3@omf_write_
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+80], rdi
	xor	edi, edi
	npad	4
$LL4@omf_write_:

; 651  :         next = curr->next;

	mov	rbx, QWORD PTR [rcx]

; 652  :         name = curr->value;

	add	rcx, 8

; 653  :         omf_InitRec( &obj, CMD_COMENT );
; 654  :         obj.d.coment.attr = CMT_TNP;
; 655  :         obj.d.coment.cmt_class = CMT_DEFAULT_LIBRARY;
; 656  :         AttachData( &obj, (uint_8 *)name, strlen( name ) );

	or	rax, -1
	mov	QWORD PTR obj$[rsp], rdi
	mov	QWORD PTR obj$[rsp+8], rdi
	mov	WORD PTR obj$[rsp+16], 136		; 00000088H
	mov	WORD PTR obj$[rsp+20], 40832		; 00009f80H
$LL14@omf_write_:
	inc	rax
	cmp	BYTE PTR [rcx+rax], dil
	jne	SHORT $LL14@omf_write_
	mov	QWORD PTR obj$[rsp+8], rcx

; 657  :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR obj$[rsp], eax
	call	omf_write_record
	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL4@omf_write_
	mov	rdi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+96]
$LN3@omf_write_:

; 658  :     }
; 659  :     DebugMsg1(("omf_write_lib() exit\n"));
; 660  : }

	add	rsp, 88					; 00000058H
	ret	0
omf_write_lib ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_dosseg
_TEXT	SEGMENT
obj$ = 32
omf_write_dosseg PROC					; COMDAT

; 631  : {

	sub	rsp, 88					; 00000058H

; 632  :     struct omf_rec obj;
; 633  : 
; 634  :     omf_InitRec( &obj, CMD_COMENT );

	xor	ecx, ecx
	mov	WORD PTR obj$[rsp+16], 136		; 00000088H

; 635  :     obj.d.coment.attr = CMT_TNP;
; 636  :     obj.d.coment.cmt_class = CMT_DOSSEG;
; 637  :     AttachData( &obj, (uint_8 *)"", 0 );

	mov	QWORD PTR obj$[rsp], rcx
	lea	rax, OFFSET FLAT:$SG12370

; 638  :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	WORD PTR obj$[rsp+20], 40576		; 00009e80H
	mov	QWORD PTR obj$[rsp+8], rax
	call	omf_write_record

; 639  : }

	add	rsp, 88					; 00000058H
	ret	0
omf_write_dosseg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_end_of_pass1
_TEXT	SEGMENT
obj$ = 32
omf_end_of_pass1 PROC					; COMDAT

; 606  : {

	sub	rsp, 88					; 00000058H

; 607  :     struct omf_rec obj;
; 608  : 
; 609  :     omf_InitRec( &obj, CMD_COMENT );
; 610  :     obj.d.coment.attr = 0x00;
; 611  :     obj.d.coment.cmt_class = CMT_MS_END_PASS_1;
; 612  :     AttachData( &obj, (uint_8 *)"\x001", 1 );

	lea	rax, OFFSET FLAT:$SG12362
	mov	QWORD PTR obj$[rsp], 1

; 613  :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	QWORD PTR obj$[rsp+8], rax
	mov	WORD PTR obj$[rsp+16], 136		; 00000088H
	mov	WORD PTR obj$[rsp+20], 41472		; 0000a200H
	call	omf_write_record

; 614  : }

	add	rsp, 88					; 00000058H
	ret	0
omf_end_of_pass1 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_theadr
_TEXT	SEGMENT
obj$ = 32
name$ = 96
omf_write_theadr PROC					; COMDAT

; 525  : {

	push	rbx
	sub	rsp, 80					; 00000050H
	mov	r9, rcx

; 526  :     struct omf_rec obj;
; 527  :     unsigned    len;
; 528  :     //const struct fname_item *fn;
; 529  : 
; 530  :     DebugMsg1(("omf_write_theadr(%s) enter\n", name));
; 531  : 
; 532  :     omf_InitRec( &obj, CMD_THEADR );

	mov	DWORD PTR obj$[rsp+4], 0
	mov	WORD PTR obj$[rsp+16], 128		; 00000080H

; 533  : 
; 534  :     /* v2.08: use the name given at the cmdline, that's what Masm does.
; 535  :      * Masm emits either a relative or a full path, depending on what
; 536  :      * was given as filename!
; 537  :      */
; 538  :     len = strlen( name );

	or	rax, -1
	npad	4
$LL11@omf_write_:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL11@omf_write_

; 539  :     AttachData( &obj, StringBufferEnd, len + 1 );

	mov	rdx, QWORD PTR ModuleInfo+488
	lea	ecx, DWORD PTR [rax+1]

; 540  :     PutName( &obj, name, len );

	mov	ebx, eax
	mov	QWORD PTR obj$[rsp+8], rdx
	mov	r8d, ebx
	mov	DWORD PTR obj$[rsp], ecx
	mov	BYTE PTR [rdx], bl
	mov	rdx, r9
	mov	eax, DWORD PTR obj$[rsp+4]
	inc	eax
	mov	ecx, eax
	add	rcx, QWORD PTR obj$[rsp+8]
	mov	DWORD PTR obj$[rsp+4], eax
	call	memcpy
	add	DWORD PTR obj$[rsp+4], ebx

; 541  :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 542  : 
; 543  :     DebugMsg1(("omf_write_theadr() exit\n"));
; 544  : }

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
omf_write_theadr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_ledata
_TEXT	SEGMENT
obj$ = 32
obj$1 = 80
obj$2 = 80
seg$ = 160
omf_write_ledata PROC					; COMDAT

; 421  : {

	mov	r11, rsp
	push	rbp
	push	rbx
	push	rsi
	mov	rbp, rsp
	sub	rsp, 128				; 00000080H

; 422  :     struct omf_rec  obj;
; 423  :     int_32          size;
; 424  : 
; 425  :     size = seg->e.seginfo->current_loc - seg->e.seginfo->start_loc;

	mov	rax, QWORD PTR [rcx+96]
	mov	rsi, rcx
	mov	ebx, DWORD PTR [rax+12]
	sub	ebx, DWORD PTR [rax+8]

; 426  :     DebugMsg1(( "omf_write_ledata enter, buffer=%p start ofs=%" I32_SPEC "X, size=%" I32_SPEC "X\n",
; 427  :               seg->e.seginfo->CodeBuffer, seg->e.seginfo->start_loc, size ));
; 428  :     if( size > 0 && write_to_file == TRUE ) {

	test	ebx, ebx
	jle	$LN11@omf_write_
	cmp	BYTE PTR write_to_file, 1
	jne	$LN11@omf_write_

; 429  :         LastCodeBufSize = size;

	mov	DWORD PTR LastCodeBufSize, ebx

; 430  : #if COMDATSUPP
; 431  :         if ( seg->e.seginfo->comdat_selection ) {

	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [r11+8], rdi
	mov	QWORD PTR [r11+24], r14

; 432  :             /* if the COMDAT symbol has been referenced in a FIXUPP,
; 433  :              * a CEXTDEF has to be written.
; 434  :              */
; 435  :             if ( seg->sym.used ) {

	xor	r14d, r14d
	mov	QWORD PTR [r11+32], r15
	test	BYTE PTR [rcx+108], 56			; 00000038H
	je	$LN3@omf_write_
	test	BYTE PTR [rsi+40], 1
	lea	edi, QWORD PTR [r14+4]
	je	$LN6@omf_write_

; 436  :                 omf_InitRec( &obj, CMD_CEXTDEF );
; 437  :                 AttachData( &obj, StringBufferEnd, 2 * sizeof( uint_16 ) );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	eax, r14d
	mov	DWORD PTR obj$[rbp-124], eax
	mov	QWORD PTR obj$[rbp-120], rdx
	mov	WORD PTR obj$[rbp-112], 188		; 000000bcH
	mov	DWORD PTR obj$[rbp-128], edi

; 438  :                 PutIndex( &obj, seg->e.seginfo->comdat_idx ); /* Index */

	movzx	r8d, WORD PTR [rcx+88]
	cmp	r8d, 127				; 0000007fH
	jbe	SHORT $LN18@omf_write_
	mov	eax, r8d
	shr	eax, 8
	or	al, 128					; 00000080H
	mov	BYTE PTR [rdx], al
	mov	eax, DWORD PTR obj$[rbp-124]
	mov	rdx, QWORD PTR obj$[rbp-120]
	inc	eax
	mov	DWORD PTR obj$[rbp-124], eax
$LN18@omf_write_:
	mov	BYTE PTR [rax+rdx], r8b
	mov	eax, DWORD PTR obj$[rbp-124]
	inc	eax
	mov	DWORD PTR obj$[rbp-124], eax

; 439  :                 PutIndex( &obj, 0 ); /* Type */

	mov	ecx, eax
	mov	rax, QWORD PTR obj$[rbp-120]
	mov	BYTE PTR [rcx+rax], r14b

; 440  :                 TruncRec( &obj );
; 441  :                 omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rbp-128]
	mov	eax, DWORD PTR obj$[rbp-124]
	inc	eax
	mov	DWORD PTR obj$[rbp-124], eax
	mov	DWORD PTR obj$[rbp-128], eax
	call	omf_write_record

; 442  :                 if ( seg->e.seginfo->seg_idx == 0 )

	mov	rcx, QWORD PTR [rsi+96]
	cmp	DWORD PTR [rcx+68], r14d
	jne	SHORT $LN6@omf_write_

; 443  :                     seg->e.seginfo->seg_idx = startext++;

	mov	eax, DWORD PTR startext
	mov	DWORD PTR [rcx+68], eax
	inc	eax
	mov	DWORD PTR startext, eax
$LN6@omf_write_:

; 444  :             }
; 445  : 
; 446  :             omf_InitRec( &obj, CMD_COMDAT );
; 447  :             AttachData( &obj, seg->e.seginfo->CodeBuffer, size );

	mov	rdx, QWORD PTR [rsi+96]
	xor	cl, cl
	mov	QWORD PTR obj$[rbp-128], r14

; 448  :             if( seg->e.seginfo->start_loc > 0xffffUL )

	mov	r15d, 1
	mov	QWORD PTR obj$[rbp-120], r14
	mov	WORD PTR obj$[rbp-112], 194		; 000000c2H
	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR obj$[rbp-120], rax
	mov	DWORD PTR obj$[rbp-128], ebx
	cmp	DWORD PTR [rdx+8], 65535		; 0000ffffH
	movzx	eax, cl
	cmova	eax, r15d

; 449  :                 obj.is_32 = 1;
; 450  :             obj.d.comdat.flags = 0;

	mov	BYTE PTR obj$[rbp-108], cl
	mov	BYTE PTR obj$[rbp-111], al

; 451  :             /* low 4-bits is allocation type */
; 452  :             if ( seg->e.seginfo->segtype == SEGTYPE_CODE ) {

	cmp	DWORD PTR [rdx+72], r15d
	jne	SHORT $LN8@omf_write_

; 453  :                 obj.d.comdat.attributes = ( ModuleInfo.model == MODEL_FLAT ? COMDAT_CODE32 : COMDAT_FAR_CODE );

	cmp	DWORD PTR ModuleInfo+360, 7
	mov	eax, r15d
	mov	ecx, 3
	cmove	eax, ecx

; 454  :             } else {

	jmp	SHORT $LN102@omf_write_
$LN8@omf_write_:

; 455  :                 obj.d.comdat.attributes = ( ModuleInfo.model == MODEL_FLAT ? COMDAT_DATA32 : COMDAT_FAR_DATA );

	cmp	DWORD PTR ModuleInfo+360, 7
	mov	eax, 2
	cmove	eax, edi
$LN102@omf_write_:
	mov	BYTE PTR obj$[rbp-107], al

; 456  :             }
; 457  :             obj.d.comdat.align = get_omfalign( seg->e.seginfo->alignment );

	movzx	ecx, BYTE PTR [rdx+106]
	sub	ecx, r15d
	je	SHORT $LN30@omf_write_
	sub	ecx, r15d
	je	SHORT $LN31@omf_write_
	sub	ecx, 2
	je	SHORT $LN32@omf_write_
	sub	ecx, edi
	je	SHORT $LN33@omf_write_
	cmp	ecx, 247				; 000000f7H
	je	SHORT $LN34@omf_write_
	movzx	eax, r15b
	jmp	SHORT $LN27@omf_write_
$LN34@omf_write_:
	xor	al, al
	jmp	SHORT $LN27@omf_write_
$LN33@omf_write_:
	movzx	eax, dil
	jmp	SHORT $LN27@omf_write_
$LN32@omf_write_:
	mov	al, 3
	jmp	SHORT $LN27@omf_write_
$LN31@omf_write_:
	mov	al, 5
	jmp	SHORT $LN27@omf_write_
$LN30@omf_write_:
	mov	al, 2
$LN27@omf_write_:
	mov	BYTE PTR obj$[rbp-106], al

; 458  :             obj.d.comdat.offset = seg->e.seginfo->start_loc;

	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR obj$[rbp-104], eax

; 459  :             obj.d.comdat.type_idx = 0;

	mov	WORD PTR obj$[rbp-100], r14w

; 460  :             obj.d.comdat.public_lname_idx = seg->e.seginfo->comdat_idx;

	movzx	eax, WORD PTR [rdx+88]
	mov	WORD PTR obj$[rbp-92], ax

; 461  :             /* todo: error if comdat_idx is 0 */
; 462  :         } else {

	jmp	SHORT $LN10@omf_write_
$LN3@omf_write_:

; 463  : #endif
; 464  :             omf_InitRec( &obj, CMD_LEDATA );

	mov	QWORD PTR obj$[rbp-128], r14
	xor	dl, dl
	mov	QWORD PTR obj$[rbp-120], r14

; 465  :             AttachData( &obj, seg->e.seginfo->CodeBuffer, size );
; 466  :             obj.d.ledata.idx = seg->e.seginfo->seg_idx;
; 467  :             obj.d.ledata.offset = seg->e.seginfo->start_loc;
; 468  :             if( obj.d.ledata.offset > 0xffffUL )

	mov	r15d, 1
	mov	WORD PTR obj$[rbp-112], 160		; 000000a0H
	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR obj$[rbp-120], rax
	mov	DWORD PTR obj$[rbp-128], ebx
	movzx	eax, WORD PTR [rcx+68]
	mov	WORD PTR obj$[rbp-108], ax
	mov	ecx, DWORD PTR [rcx+8]
	cmp	ecx, 65535				; 0000ffffH
	movzx	eax, dl
	cmova	eax, r15d
	mov	DWORD PTR obj$[rbp-104], ecx
	mov	BYTE PTR obj$[rbp-111], al
$LN10@omf_write_:

; 469  :                 obj.is_32 = 1;
; 470  : #if COMDATSUPP
; 471  :         }
; 472  : #endif
; 473  :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rbp-128]
	call	omf_write_record

; 474  : 
; 475  :         /* process Fixup, if any */
; 476  :         if( seg->e.seginfo->FixupList.head != NULL ) {

	mov	rbx, QWORD PTR [rsi+96]
	mov	rbx, QWORD PTR [rbx+40]
	test	rbx, rbx
	je	$LN101@omf_write_

; 477  : #if FASTMEM==0
; 478  :             struct fixup *fix;
; 479  :             struct fixup *next;
; 480  : #endif
; 481  :             omf_write_fixupp( seg, 0 );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	QWORD PTR [rsp+168], r12
	mov	r12d, 1096				; 00000448H
	npad	9
$LL41@omf_write_:
	mov	rdi, rdx
	mov	ecx, r14d
	test	rbx, rbx
	je	SHORT $LN94@omf_write_
	npad	5
$LL45@omf_write_:
	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 10
	ja	SHORT $LN49@omf_write_
	bt	r12d, eax
	jb	SHORT $LN43@omf_write_
$LN49@omf_write_:
	cmp	ecx, 1009				; 000003f1H
	ja	SHORT $LN82@omf_write_
	mov	rax, QWORD PTR [rsi+96]
	xor	r9d, r9d
	mov	r8, rdi
	mov	rcx, rbx
	mov	edx, DWORD PTR [rax+8]
	call	OmfFixGenFix
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	eax, eax
	add	rdi, rax
	mov	ecx, edi
	sub	ecx, edx
$LN43@omf_write_:
	mov	rbx, QWORD PTR [rbx+8]
	test	rbx, rbx
	jne	SHORT $LL45@omf_write_
$LN82@omf_write_:
	test	ecx, ecx
	je	SHORT $LN53@omf_write_
	mov	DWORD PTR obj$2[rbp-128], ecx
	lea	rcx, QWORD PTR obj$2[rbp-128]
	mov	DWORD PTR obj$2[rbp-124], r14d
	mov	WORD PTR obj$2[rbp-112], 156		; 0000009cH
	mov	QWORD PTR obj$2[rbp-120], rdx
	call	omf_write_record
	mov	rdx, QWORD PTR ModuleInfo+488
$LN53@omf_write_:
	test	rbx, rbx
	jne	SHORT $LL41@omf_write_
$LN94@omf_write_:

; 482  :             omf_write_fixupp( seg, 1 );

	mov	rax, QWORD PTR [rsi+96]
	mov	rbx, QWORD PTR [rax+40]
	test	rbx, rbx
	je	$LN98@omf_write_
	npad	1
$LL60@omf_write_:
	mov	rdi, rdx
	mov	ecx, r14d
	test	rbx, rbx
	je	SHORT $LN98@omf_write_
	npad	5
$LL64@omf_write_:
	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 10
	ja	SHORT $LN62@omf_write_
	bt	r12d, eax
	jae	SHORT $LN62@omf_write_
	cmp	ecx, 1009				; 000003f1H
	ja	SHORT $LN83@omf_write_
	mov	rax, QWORD PTR [rsi+96]
	mov	r9d, r15d
	mov	r8, rdi
	mov	rcx, rbx
	mov	edx, DWORD PTR [rax+8]
	call	OmfFixGenFix
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	eax, eax
	add	rdi, rax
	mov	ecx, edi
	sub	ecx, edx
$LN62@omf_write_:
	mov	rbx, QWORD PTR [rbx+8]
	test	rbx, rbx
	jne	SHORT $LL64@omf_write_
$LN83@omf_write_:
	test	ecx, ecx
	je	SHORT $LN72@omf_write_
	mov	DWORD PTR obj$1[rbp-128], ecx
	lea	rcx, QWORD PTR obj$1[rbp-128]
	mov	DWORD PTR obj$1[rbp-124], r14d
	mov	WORD PTR obj$1[rbp-112], 412		; 0000019cH
	mov	QWORD PTR obj$1[rbp-120], rdx
	call	omf_write_record
	mov	rdx, QWORD PTR ModuleInfo+488
$LN72@omf_write_:
	test	rbx, rbx
	jne	SHORT $LL60@omf_write_
$LN98@omf_write_:

; 483  : #if FASTMEM==0
; 484  :             for( fix = seg->e.seginfo->FixupList.head; fix; ) {
; 485  :                 next = fix->nextrlc;
; 486  :                 LclFree( fix );
; 487  :                 fix = next;
; 488  :             }
; 489  : #endif
; 490  :             seg->e.seginfo->FixupList.head = seg->e.seginfo->FixupList.tail = NULL;

	mov	rax, QWORD PTR [rsi+96]
	mov	r12, QWORD PTR [rsp+168]
	mov	QWORD PTR [rax+48], r14
	mov	rax, QWORD PTR [rsi+96]
	mov	QWORD PTR [rax+40], r14
$LN101@omf_write_:
	mov	r14, QWORD PTR [rsp+176]
	mov	rdi, QWORD PTR [rsp+160]
	mov	r15, QWORD PTR [rsp+184]
$LN11@omf_write_:

; 491  :         }
; 492  :     }
; 493  :     seg->e.seginfo->start_loc = seg->e.seginfo->current_loc;

	mov	rcx, QWORD PTR [rsi+96]
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rcx+8], eax

; 494  : }

	add	rsp, 128				; 00000080H
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
omf_write_ledata ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT get_omfalign
_TEXT	SEGMENT
alignment$ = 8
get_omfalign PROC					; COMDAT

; 829  :     switch ( alignment ) {

	movzx	edx, cl
	sub	edx, 1
	je	SHORT $LN4@get_omfali
	sub	edx, 1
	je	SHORT $LN5@get_omfali
	sub	edx, 2
	je	SHORT $LN6@get_omfali
	sub	edx, 4
	je	SHORT $LN7@get_omfali
	cmp	edx, 247				; 000000f7H
	je	SHORT $LN8@get_omfali

; 841  :     }
; 842  :     /* value 0 is byte alignment, anything elso is "unexpected" */
; 843  :     /**/myassert( alignment == 0 );
; 844  :     return( SEGDEF_ALIGN_BYTE );

	mov	al, 1

; 845  : }

	ret	0
$LN8@get_omfali:

; 834  : #if PAGE4K /* PharLab peculiarity; this is invalid for MS OMF */
; 835  :     case 12:
; 836  :         if ( Parse_Pass == PASS_1 )
; 837  :             EmitWarn( 2, NO_4KPAGE_ALIGNED_SEGMENTS_IN_MS386 );
; 838  :         return( SEGDEF_ALIGN_4KPAGE );
; 839  : #endif
; 840  :     case MAX_SEGALIGNMENT: return( SEGDEF_ALIGN_ABS );

	xor	al, al

; 845  : }

	ret	0
$LN7@get_omfali:

; 833  :     case  8:  return( SEGDEF_ALIGN_PAGE );

	mov	al, 4

; 845  : }

	ret	0
$LN6@get_omfali:

; 832  :     case  4:  return( SEGDEF_ALIGN_PARA );

	mov	al, 3

; 845  : }

	ret	0
$LN5@get_omfali:

; 831  :     case  2:  return( SEGDEF_ALIGN_DWORD );

	mov	al, 5

; 845  : }

	ret	0
$LN4@get_omfali:

; 830  :     case  1:  return( SEGDEF_ALIGN_WORD );

	mov	al, 2

; 845  : }

	ret	0
get_omfalign ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_fixupp
_TEXT	SEGMENT
obj$ = 32
seg$ = 112
is32$ = 120
omf_write_fixupp PROC					; COMDAT

; 381  : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rdi
	push	r12
	push	r14
	sub	rsp, 80					; 00000050H

; 382  :     uint_8 *data;
; 383  :     unsigned size;
; 384  :     struct fixup *fix;
; 385  :     enum fixup_types type = ( is32 ? FIX_GEN_MS386 : FIX_GEN_INTEL );
; 386  :     struct omf_rec  obj;
; 387  : 
; 388  :     fix = seg->e.seginfo->FixupList.head;

	mov	rbx, QWORD PTR [rcx+96]
	xor	r12d, r12d
	test	dl, dl
	mov	r14d, r12d
	movzx	edi, dl
	mov	rbp, rcx
	setne	r14b
	mov	rbx, QWORD PTR [rbx+40]

; 389  :     while ( fix ) {

	test	rbx, rbx
	je	$LN31@omf_write_
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	QWORD PTR [rsp+112], rsi
	mov	QWORD PTR [rsp+120], r15
	mov	r15d, 1096				; 00000448H
	npad	3
$LL2@omf_write_:

; 390  :         for( data = StringBufferEnd, size = 0; fix; fix = fix->nextrlc ) {

	mov	rsi, rdx
	mov	ecx, r12d
	test	rbx, rbx
	je	$LN33@omf_write_
	npad	1
$LL6@omf_write_:

; 391  :             switch( fix->type ) {

	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 10
	ja	SHORT $LN29@omf_write_
	bt	r15d, eax
	jae	SHORT $LN29@omf_write_

; 392  :             case FIX_RELOFF32:
; 393  :             case FIX_OFF32:
; 394  :             case FIX_PTR32:
; 395  :                 if ( !is32 ) continue;

	test	dil, dil
	je	SHORT $LN4@omf_write_
	jmp	SHORT $LN10@omf_write_
$LN29@omf_write_:

; 396  :                 break;
; 397  :             default:
; 398  :                 if ( is32 ) continue;

	test	dil, dil
	jne	SHORT $LN4@omf_write_
$LN10@omf_write_:

; 399  :                 break;
; 400  :             }
; 401  :             if ( size > 1020 - FIX_GEN_MAX )

	cmp	ecx, 1009				; 000003f1H
	ja	SHORT $LN22@omf_write_

; 402  :                 break;
; 403  :             data += OmfFixGenFix( fix, seg->e.seginfo->start_loc, data, type );

	mov	rax, QWORD PTR [rbp+96]
	mov	r9d, r14d
	mov	r8, rsi
	mov	rcx, rbx
	mov	edx, DWORD PTR [rax+8]
	call	OmfFixGenFix

; 404  :             size = (char *)data - StringBufferEnd;

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	eax, eax
	add	rsi, rax
	mov	ecx, esi
	sub	ecx, edx
$LN4@omf_write_:

; 390  :         for( data = StringBufferEnd, size = 0; fix; fix = fix->nextrlc ) {

	mov	rbx, QWORD PTR [rbx+8]
	test	rbx, rbx
	jne	SHORT $LL6@omf_write_
$LN22@omf_write_:

; 405  :         }
; 406  :         if ( size ) {

	test	ecx, ecx
	je	SHORT $LN14@omf_write_

; 407  :             omf_InitRec( &obj, CMD_FIXUPP );
; 408  :             obj.is_32 = is32;
; 409  :             AttachData( &obj, StringBufferEnd, size );

	mov	DWORD PTR obj$[rsp], ecx

; 410  :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR obj$[rsp+4], r12d
	mov	BYTE PTR obj$[rsp+16], 156		; 0000009cH
	mov	BYTE PTR obj$[rsp+17], dil
	mov	QWORD PTR obj$[rsp+8], rdx
	call	omf_write_record
	mov	rdx, QWORD PTR ModuleInfo+488
$LN14@omf_write_:

; 389  :     while ( fix ) {

	test	rbx, rbx
	jne	$LL2@omf_write_
$LN33@omf_write_:
	mov	rsi, QWORD PTR [rsp+112]
	mov	r15, QWORD PTR [rsp+120]
$LN31@omf_write_:

; 411  :         }
; 412  :     }
; 413  : }

	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	r12
	pop	rdi
	ret	0
omf_write_fixupp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_write_linnum
_TEXT	SEGMENT
obj$ = 32
is32$ = 96
omf_write_linnum PROC					; COMDAT

; 348  : {

	push	rbx
	sub	rsp, 80					; 00000050H

; 349  :     unsigned             ofssize = ( is32 ? sizeof( uint_32) : sizeof( uint_16 ) );
; 350  :     unsigned             size;
; 351  :     uint_8               *data;
; 352  :     struct line_num_info *node;
; 353  :     struct line_num_info *next;
; 354  :     struct omf_rec       obj;
; 355  : 
; 356  :     for( node = LinnumQueue.head, data = StringBufferEnd; node; node = next ) {

	mov	r8, QWORD PTR LinnumQueue
	test	cl, cl
	mov	eax, 4
	mov	r9d, 2
	cmovne	r9d, eax
	movzx	r10d, cl
	mov	rax, QWORD PTR ModuleInfo+488
	mov	rdx, rax
	test	r8, r8
	je	SHORT $LN3@omf_write_
$LL4@omf_write_:

; 357  :         next = node->next;
; 358  :         *(uint_16 *)data = node->number;

	movzx	eax, WORD PTR [r8+8]
	mov	rcx, QWORD PTR [r8]
	mov	WORD PTR [rdx], ax

; 359  :         data += sizeof( uint_16 );

	add	rdx, 2

; 360  :         *(uint_32 *)data = node->offset;

	mov	eax, DWORD PTR [r8+12]
	mov	r8, rcx
	mov	DWORD PTR [rdx], eax

; 361  :         data += ofssize;

	add	rdx, r9
	test	rcx, rcx
	jne	SHORT $LL4@omf_write_

; 349  :     unsigned             ofssize = ( is32 ? sizeof( uint_32) : sizeof( uint_16 ) );
; 350  :     unsigned             size;
; 351  :     uint_8               *data;
; 352  :     struct line_num_info *node;
; 353  :     struct line_num_info *next;
; 354  :     struct omf_rec       obj;
; 355  : 
; 356  :     for( node = LinnumQueue.head, data = StringBufferEnd; node; node = next ) {

	mov	rax, QWORD PTR ModuleInfo+488
$LN3@omf_write_:

; 362  :         LclFree( node );
; 363  :     }
; 364  :     LinnumQueue.head = NULL;

	xor	ebx, ebx
	mov	QWORD PTR LinnumQueue, rbx

; 365  : 
; 366  :     size = (char *)data - StringBufferEnd;

	sub	edx, eax

; 367  :     if( size ) {

	je	SHORT $LN5@omf_write_

; 368  :         omf_InitRec( &obj, CMD_LINNUM );
; 369  :         obj.is_32 = is32;
; 370  :         AttachData( &obj, StringBufferEnd, size );
; 371  :         obj.d.linnum.base.grp_idx = omf_GetGrpIdx( GetGroup( &CurrSeg->sym ) ); /* fixme ? */

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	DWORD PTR obj$[rsp+4], ebx
	mov	BYTE PTR obj$[rsp+16], 148		; 00000094H
	mov	BYTE PTR obj$[rsp+17], r10b
	mov	QWORD PTR obj$[rsp+8], rax
	mov	DWORD PTR obj$[rsp], edx
	call	GetGroup
	test	rax, rax
	je	SHORT $LN13@omf_write_
	mov	rax, QWORD PTR [rax+96]
	movzx	ecx, WORD PTR [rax+8]
	mov	WORD PTR obj$[rsp+20], cx
	jmp	SHORT $LN14@omf_write_
$LN13@omf_write_:
	mov	WORD PTR obj$[rsp+20], bx
$LN14@omf_write_:

; 372  :         obj.d.linnum.base.seg_idx = CurrSeg->e.seginfo->seg_idx;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	movzx	eax, WORD PTR [rcx+68]

; 373  :         obj.d.linnum.base.frame = 0; /* field not used here */
; 374  :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	WORD PTR obj$[rsp+22], ax
	mov	WORD PTR obj$[rsp+24], bx
	call	omf_write_record
$LN5@omf_write_:

; 375  :     }
; 376  :     return;
; 377  : }

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
omf_write_linnum ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
sym$ = 8
omf_GetGrpIdx PROC

; 277  :     return( sym ? ((struct dsym *)sym)->e.grpinfo->grp_idx : 0 );

	test	rcx, rcx
	je	SHORT $LN3@omf_GetGrp
	mov	rax, QWORD PTR [rcx+96]
	mov	eax, DWORD PTR [rax+8]

; 278  : }

	ret	0
$LN3@omf_GetGrp:

; 277  :     return( sym ? ((struct dsym *)sym)->e.grpinfo->grp_idx : 0 );

	xor	eax, eax

; 278  : }

	ret	0
omf_GetGrpIdx ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT AttachData
_TEXT	SEGMENT
objr$ = 8
data$ = 16
len$ = 24
AttachData PROC						; COMDAT

; 257  : /**/myassert( objr->data == NULL );
; 258  :     objr->data = data;

	mov	QWORD PTR [rcx+8], rdx

; 259  :     objr->length = len;

	mov	DWORD PTR [rcx], r8d

; 260  : }

	ret	0
AttachData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT PutName
_TEXT	SEGMENT
objr$ = 48
name$ = 56
len$ = 64
PutName	PROC						; COMDAT

; 242  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 243  :     /**/myassert( objr != NULL && objr->data != NULL );
; 244  : #if MAX_ID_LEN > MAX_ID_LEN_OMF
; 245  :     if ( len > MAX_ID_LEN_OMF ) {
; 246  :         EmitWarn( 1, IDENTIFIER_TOO_LONG );
; 247  :         len = MAX_ID_LEN_OMF;
; 248  :     }
; 249  : #endif
; 250  :     objr->data[objr->curoff++] = len;

	mov	r9d, DWORD PTR [rcx+4]
	mov	rbx, rcx
	mov	rax, QWORD PTR [rcx+8]
	mov	rdi, r8
	mov	BYTE PTR [r9+rax], dil
	inc	DWORD PTR [rcx+4]
	mov	ecx, DWORD PTR [rcx+4]

; 251  :     PutData( objr, (uint_8 *)name, len );

	add	rcx, QWORD PTR [rbx+8]
	call	memcpy
	add	DWORD PTR [rbx+4], edi

; 252  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
PutName	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT PutData
_TEXT	SEGMENT
objr$ = 48
data$ = 56
len$ = 64
PutData	PROC						; COMDAT

; 234  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rdi, r8

; 235  :     /**/myassert( objr != NULL && objr->data != NULL );
; 236  :     memcpy( objr->data + objr->curoff, data, len );

	mov	ecx, DWORD PTR [rcx+4]
	add	rcx, QWORD PTR [rbx+8]
	call	memcpy

; 237  :     objr->curoff += len;

	add	DWORD PTR [rbx+4], edi

; 238  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
PutData	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT PutIndex
_TEXT	SEGMENT
objr$ = 8
idx$ = 16
PutIndex PROC						; COMDAT

; 224  : {

	mov	r10, rcx

; 225  : /**/myassert( objr != NULL && objr->data != NULL && idx <= 0x7FFF );
; 226  :     if( idx > 0x7f ) {

	cmp	edx, 127				; 0000007fH
	jbe	SHORT $LN2@PutIndex

; 227  :         objr->data[objr->curoff++] = ( idx >> 8 ) | 0x80;

	mov	r8d, DWORD PTR [rcx+4]
	mov	r9d, edx
	mov	rax, QWORD PTR [rcx+8]
	shr	r9d, 8
	or	r9b, 128				; 00000080H
	mov	BYTE PTR [r8+rax], r9b
	inc	DWORD PTR [rcx+4]
$LN2@PutIndex:

; 228  :     }
; 229  :     objr->data[objr->curoff++] = idx & 0xff;

	mov	ecx, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR [r10+8]
	mov	BYTE PTR [rcx+rax], dl
	inc	DWORD PTR [r10+4]

; 230  : }

	ret	0
PutIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT Put32
_TEXT	SEGMENT
objr$ = 8
value$ = 16
Put32	PROC						; COMDAT

; 195  : /**/myassert( objr != NULL && objr->data != NULL );
; 196  : 
; 197  :     WriteU32( objr->data + objr->curoff, value );

	mov	r8d, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR [rcx+8]
	mov	DWORD PTR [r8+rax], edx

; 198  :     objr->curoff += sizeof( uint_32 );

	add	DWORD PTR [rcx+4], 4

; 199  : }

	ret	0
Put32	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT Put16
_TEXT	SEGMENT
objr$ = 8
value$ = 16
Put16	PROC						; COMDAT

; 186  : /**/myassert( objr != NULL && objr->data != NULL );
; 187  : 
; 188  :     WriteU16( objr->data + objr->curoff, value );

	mov	r8d, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR [rcx+8]
	mov	WORD PTR [r8+rax], dx

; 189  :     objr->curoff += sizeof( uint_16 );

	add	DWORD PTR [rcx+4], 2

; 190  : }

	ret	0
Put16	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT Put8
_TEXT	SEGMENT
objr$ = 8
value$ = 16
Put8	PROC						; COMDAT

; 179  : /**/myassert( objr != NULL && objr->data != NULL );
; 180  :     objr->data[ objr->curoff++ ] = value;

	mov	r8d, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR [rcx+8]
	mov	BYTE PTR [r8+rax], dl
	inc	DWORD PTR [rcx+4]

; 181  : }

	ret	0
Put8	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT timet2dostime
_TEXT	SEGMENT
x$ = 48
dt$ = 56
timet2dostime PROC					; COMDAT

; 162  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 163  :     struct tm *    ltime;
; 164  :     union DOS_DATETIME dt;
; 165  : 
; 166  :     ltime = localtime( &x );

	lea	rcx, QWORD PTR x$[rsp]
	call	_localtime64

; 167  :     dt.dos.date = (( ltime->tm_year - 80 ) << DATE_YEAR_B )

	mov	ecx, 512				; 00000200H
	movzx	edx, WORD PTR [rax+20]
	add	dx, 48					; 00000030H
	movzx	r8d, dx
	imul	r8d, ecx
	movzx	ecx, WORD PTR [rax+16]
	inc	cx
	shl	cx, 5
	or	r8w, cx

; 168  :              | (( ltime->tm_mon + 1 ) << DATE_MON_B )
; 169  :              | (( ltime->tm_mday ) << DATE_DAY_B );
; 170  :     dt.dos.time = (( ltime->tm_hour ) << TIME_HOUR_B )

	movzx	ecx, WORD PTR [rax+8]
	or	r8w, WORD PTR [rax+12]
	shl	cx, 6
	or	cx, WORD PTR [rax+4]
	mov	eax, DWORD PTR [rax]
	cdq
	shl	cx, 5
	sub	eax, edx
	mov	WORD PTR dt$[rsp+2], r8w
	sar	eax, 1
	or	cx, ax
	mov	WORD PTR dt$[rsp], cx

; 171  :              | (( ltime->tm_min ) << TIME_MIN_B )
; 172  :              | (( ltime->tm_sec / 2 ) << TIME_SEC_B );
; 173  :     return( dt.timet );

	mov	rax, QWORD PTR dt$[rsp]

; 174  : }

	add	rsp, 40					; 00000028H
	ret	0
timet2dostime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
;	COMDAT omf_InitRec
_TEXT	SEGMENT
obj$ = 8
command$ = 16
omf_InitRec PROC					; COMDAT

; 151  :     obj->length = 0;

	xor	eax, eax

; 152  :     obj->curoff = 0;
; 153  :     obj->data = NULL;
; 154  :     obj->command = command;

	mov	BYTE PTR [rcx+16], dl
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 155  :     obj->is_32 = 0;

	mov	BYTE PTR [rcx+17], al

; 156  :     DebugMsg1(("omf_InitRec(%p, %X)\n", obj, command ));
; 157  :     return;
; 158  : }

	ret	0
omf_InitRec ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
curr$ = 48
omf_check_flush PROC

; 562  : {

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H

; 563  :     uint_8 is_32;
; 564  :     uint_16 size;
; 565  : #if MULTIHDR
; 566  :     if ( curr->srcfile != ln_srcfile ) {

	mov	eax, DWORD PTR ln_srcfile
	mov	rbx, rcx
	cmp	DWORD PTR [rcx+16], eax
	je	SHORT $LN2@omf_check_

; 567  :         if ( LinnumQueue.head )

	cmp	QWORD PTR LinnumQueue, 0
	je	SHORT $LN10@omf_check_

; 568  :             omf_FlushCurrSeg();

	mov	rcx, QWORD PTR ModuleInfo+432
	call	omf_write_ledata
	cmp	BYTE PTR Options+1, 0
	je	SHORT $LN10@omf_check_
	movzx	ecx, BYTE PTR ln_is32
	call	omf_write_linnum
	xor	eax, eax
	mov	WORD PTR ln_size, ax
$LN10@omf_check_:

; 569  :         /* todo: for Borland, there's a COMENT ( CMT_SRCFILE ) that could be written
; 570  :          * instead of THEADR.
; 571  :          */
; 572  :         omf_write_theadr( GetFName( curr->srcfile )->fname );

	mov	ecx, DWORD PTR [rbx+16]
	call	GetFName
	mov	rcx, QWORD PTR [rax]
	call	omf_write_theadr

; 573  :         ln_srcfile = curr->srcfile;

	mov	eax, DWORD PTR [rbx+16]
	mov	DWORD PTR ln_srcfile, eax

; 597  :     return;
; 598  : };

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@omf_check_:

; 574  :         return;
; 575  :     }
; 576  : #endif
; 577  :     /* if there's a change in offset magnitude ( 16 -> 32 or 32 -> 16 ),
; 578  :      * do flush ( Masm compatible ).
; 579  :      */
; 580  :     is_32 = ( curr->offset > 0xffff ? TRUE : FALSE );

	cmp	DWORD PTR [rcx+12], 65535		; 0000ffffH
	seta	bl

; 581  :     if ( ln_is32 != is_32 ) {

	cmp	BYTE PTR ln_is32, bl
	je	SHORT $LN4@omf_check_

; 582  :         if ( LinnumQueue.head )

	cmp	QWORD PTR LinnumQueue, 0
	je	SHORT $LN13@omf_check_

; 583  :             omf_FlushCurrSeg();

	mov	rcx, QWORD PTR ModuleInfo+432
	call	omf_write_ledata
	cmp	BYTE PTR Options+1, 0
	je	SHORT $LN13@omf_check_
	movzx	ecx, BYTE PTR ln_is32
	call	omf_write_linnum
	xor	eax, eax
	mov	WORD PTR ln_size, ax
$LN13@omf_check_:

; 584  :         ln_is32 = is_32;

	mov	BYTE PTR ln_is32, bl

; 597  :     return;
; 598  : };

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@omf_check_:

; 585  :         return;
; 586  :     }
; 587  :     /* line number item consists of 16-bit line# and 16- or 32-bit offset */
; 588  :     size = sizeof( uint_16 ) + ( is_32 ? sizeof( uint_32 ) : sizeof( uint_16 ) );
; 589  :     /* if the size of the linnum data exceeds 1016,
; 590  :      * do flush ( Masm compatible ).
; 591  :      */
; 592  :     if ( ln_size + size > 1024 - 8 ) {

	movzx	edx, WORD PTR ln_size
	test	bl, bl
	mov	QWORD PTR [rsp+48], rdi
	mov	eax, 4
	mov	edi, 2
	cmovne	di, ax
	add	di, 2
	movzx	ecx, di
	add	ecx, edx
	cmp	ecx, 1016				; 000003f8H
	jle	SHORT $LN7@omf_check_

; 593  :         if ( LinnumQueue.head )

	cmp	QWORD PTR LinnumQueue, 0
	je	SHORT $LN7@omf_check_

; 594  :             omf_FlushCurrSeg();

	call	omf_FlushCurrSeg
	movzx	edx, WORD PTR ln_size
$LN7@omf_check_:

; 595  :     }
; 596  :     ln_size += size;

	add	dx, di
	mov	rdi, QWORD PTR [rsp+48]
	mov	WORD PTR ln_size, dx

; 597  :     return;
; 598  : };

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
omf_check_flush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
omf_FlushCurrSeg PROC

; 503  : {

$LN5:
	sub	rsp, 40					; 00000028H

; 504  :     //unsigned i;
; 505  :     //unsigned size;
; 506  : 
; 507  :     DebugMsg1(( "omf_FlushCurrSeg() enter, CurrSeg=%s, currsrc=%u\n", CurrSeg ? CurrSeg->sym.name : "NULL", get_curr_srcfile() ));
; 508  : 
; 509  :     omf_write_ledata( CurrSeg );

	mov	rcx, QWORD PTR ModuleInfo+432
	call	omf_write_ledata

; 510  :     /* add line numbers if debugging info is desired */
; 511  :     //if( write_to_file && Options.line_numbers ) {
; 512  :     if( Options.line_numbers ) {

	cmp	BYTE PTR Options+1, 0
	je	SHORT $LN2@omf_FlushC

; 513  :         omf_write_linnum( ln_is32 );

	movzx	ecx, BYTE PTR ln_is32
	call	omf_write_linnum

; 514  :         ln_size = 0;

	xor	eax, eax
	mov	WORD PTR ln_size, ax
$LN2@omf_FlushC:

; 515  :     }
; 516  :     //if ( Options.no_comment_data_in_code_records == FALSE )
; 517  :     //    omf_OutSelect( FALSE );
; 518  :     return;
; 519  : }

	add	rsp, 40					; 00000028H
	ret	0
omf_FlushCurrSeg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
buffer$ = 32
obj$ = 48
is_data$ = 112
omf_OutSelect PROC

; 286  : {

$LN36:
	push	rbp
	mov	rbp, rsp
	sub	rsp, 96					; 00000060H

; 287  :     struct omf_rec      obj;
; 288  :     uint_32             currofs;
; 289  :     int                 sel_idx;
; 290  :     static uint_32      sel_start;  /* start offset of data items */
; 291  :     unsigned char       buffer[12]; /* max is 11 ( see below ) */
; 292  : 
; 293  :     if( is_data ) {
; 294  :         /* do nothing if it isn't the first data item or
; 295  :          * if current segment isn't code
; 296  :          */
; 297  :         if( CurrSeg->e.seginfo->data_in_code ||

	mov	rax, QWORD PTR ModuleInfo+432
	test	cl, cl
	mov	rcx, QWORD PTR [rax+96]
	je	SHORT $LN2@omf_OutSel
	test	BYTE PTR [rcx+107], 8
	jne	$LN7@omf_OutSel
	cmp	DWORD PTR [rcx+72], 1
	jne	$LN7@omf_OutSel

; 298  :            ( CurrSeg->e.seginfo->segtype != SEGTYPE_CODE ) )
; 299  :             return;
; 300  :         sel_start = GetCurrOffset();

	call	GetCurrOffset
	mov	DWORD PTR ?sel_start@?1??omf_OutSelect@@9@9, eax

; 301  :         CurrSeg->e.seginfo->data_in_code = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	or	BYTE PTR [rcx+107], 8

; 331  :         }
; 332  :     }
; 333  : }

	add	rsp, 96					; 00000060H
	pop	rbp
	ret	0
$LN2@omf_OutSel:

; 302  :         DebugMsg(("omf_OutSelect: data in code segment (%s), starting at %" I32_SPEC "X\n", CurrSeg->sym.name, sel_start ));
; 303  :     } else if ( CurrSeg->e.seginfo->data_in_code ) { /* data items written? */

	movzx	eax, BYTE PTR [rcx+107]
	test	al, 8
	je	$LN7@omf_OutSel

; 304  :         
; 305  :         CurrSeg->e.seginfo->data_in_code = FALSE;

	and	al, 247					; 000000f7H
	mov	BYTE PTR [rcx+107], al

; 306  : 
; 307  :         if( write_to_file == TRUE ) {

	cmp	BYTE PTR write_to_file, 1
	jne	$LN7@omf_OutSel

; 308  :             omf_InitRec( &obj, CMD_COMENT );
; 309  :             obj.d.coment.attr = CMT_TNP;
; 310  :             obj.d.coment.cmt_class = CMT_DISASM_DIRECTIVE;
; 311  : 
; 312  :             sel_idx = GetSegIdx( &CurrSeg->sym );

	mov	rcx, QWORD PTR ModuleInfo+432
	xor	eax, eax
	mov	QWORD PTR obj$[rbp-96], rax
	mov	QWORD PTR obj$[rbp-88], rax
	mov	QWORD PTR [rsp+112], rbx
	mov	WORD PTR obj$[rbp-80], 136		; 00000088H
	mov	WORD PTR obj$[rbp-76], 64896		; 0000fd80H
	call	GetSegIdx
	mov	ebx, eax

; 313  : 
; 314  :             //AllocData( objr, 11 );  /* 11 = 1 + 2 + 4 + 4 */
; 315  :             AttachData( &obj, buffer, 11 );  /* 11 = 1 + 2 + 4 + 4 */

	mov	DWORD PTR obj$[rbp-96], 11
	lea	rax, QWORD PTR buffer$[rbp-96]
	mov	QWORD PTR obj$[rbp-88], rax

; 316  :             currofs = GetCurrOffset();

	call	GetCurrOffset

; 317  :             DebugMsg(("omf_OutSelect: writing coment record about data in code: start=%" I32_SPEC "X curofs=%" I32_SPEC "X\n", sel_start, currofs ));
; 318  :             if( ( sel_start > 0xffffUL ) || ( currofs > 0xffffUL ) ) {

	mov	r9d, DWORD PTR ?sel_start@?1??omf_OutSelect@@9@9
	mov	r8d, eax
	cmp	r9d, 65535				; 0000ffffH
	ja	SHORT $LN10@omf_OutSel
	cmp	eax, 65535				; 0000ffffH
	ja	SHORT $LN10@omf_OutSel

; 323  :             } else {
; 324  :                 Put8( &obj, DDIR_SCAN_TABLE );

	mov	edx, DWORD PTR obj$[rbp-92]
	mov	rcx, QWORD PTR obj$[rbp-88]
	mov	BYTE PTR [rdx+rcx], 115			; 00000073H
	mov	ecx, DWORD PTR obj$[rbp-92]
	inc	ecx
	mov	DWORD PTR obj$[rbp-92], ecx

; 325  :                 PutIndex( &obj, sel_idx );

	cmp	ebx, 127				; 0000007fH
	jbe	SHORT $LN28@omf_OutSel
	mov	rax, QWORD PTR obj$[rbp-88]
	mov	edx, ebx
	shr	edx, 8
	or	dl, 128					; 00000080H
	mov	BYTE PTR [rcx+rax], dl
	mov	ecx, DWORD PTR obj$[rbp-92]
	inc	ecx
	mov	DWORD PTR obj$[rbp-92], ecx
$LN28@omf_OutSel:
	mov	rax, QWORD PTR obj$[rbp-88]
	mov	BYTE PTR [rcx+rax], bl
	mov	eax, DWORD PTR obj$[rbp-92]
	inc	eax
	mov	DWORD PTR obj$[rbp-92], eax

; 326  :                 Put16( &obj, sel_start );

	mov	ecx, eax
	mov	rax, QWORD PTR obj$[rbp-88]
	mov	WORD PTR [rcx+rax], r9w
	mov	eax, DWORD PTR obj$[rbp-92]
	add	eax, 2
	mov	DWORD PTR obj$[rbp-92], eax

; 327  :                 Put16( &obj, currofs );

	mov	ecx, eax
	mov	rax, QWORD PTR obj$[rbp-88]
	mov	WORD PTR [rcx+rax], r8w
	mov	eax, DWORD PTR obj$[rbp-92]
	add	eax, 2
	jmp	SHORT $LN34@omf_OutSel
$LN10@omf_OutSel:

; 319  :                 Put8( &obj, DDIR_SCAN_TABLE_32 );

	mov	ecx, DWORD PTR obj$[rbp-92]
	mov	rax, QWORD PTR obj$[rbp-88]
	mov	BYTE PTR [rcx+rax], 83			; 00000053H
	mov	eax, DWORD PTR obj$[rbp-92]
	inc	eax
	mov	DWORD PTR obj$[rbp-92], eax

; 320  :                 PutIndex( &obj, sel_idx );

	cmp	ebx, 127				; 0000007fH
	jbe	SHORT $LN19@omf_OutSel
	mov	ecx, eax
	mov	edx, ebx
	mov	rax, QWORD PTR obj$[rbp-88]
	shr	edx, 8
	or	dl, 128					; 00000080H
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR obj$[rbp-92]
	inc	eax
	mov	DWORD PTR obj$[rbp-92], eax
$LN19@omf_OutSel:
	mov	ecx, eax
	mov	rax, QWORD PTR obj$[rbp-88]
	mov	BYTE PTR [rcx+rax], bl
	mov	eax, DWORD PTR obj$[rbp-92]
	inc	eax
	mov	DWORD PTR obj$[rbp-92], eax

; 321  :                 Put32( &obj, sel_start );

	mov	ecx, eax
	mov	rax, QWORD PTR obj$[rbp-88]
	mov	DWORD PTR [rcx+rax], r9d
	mov	eax, DWORD PTR obj$[rbp-92]
	add	eax, 4
	mov	DWORD PTR obj$[rbp-92], eax

; 322  :                 Put32( &obj, currofs );

	mov	ecx, eax
	mov	rax, QWORD PTR obj$[rbp-88]
	mov	DWORD PTR [rcx+rax], r8d
	mov	eax, DWORD PTR obj$[rbp-92]
	add	eax, 4
$LN34@omf_OutSel:

; 328  :             }
; 329  :             TruncRec( &obj );
; 330  :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rbp-96]
	mov	DWORD PTR obj$[rbp-92], eax
	mov	DWORD PTR obj$[rbp-96], eax
	call	omf_write_record
	mov	rbx, QWORD PTR [rsp+112]
$LN7@omf_OutSel:

; 331  :         }
; 332  :     }
; 333  : }

	add	rsp, 96					; 00000060H
	pop	rbp
	ret	0
omf_OutSelect ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
omf_set_filepos PROC

; 623  :     DebugMsg1(( "omf_set_filepos: reset file pos to %X\n", end_of_header ));
; 624  : #if MULTIHDR
; 625  : #endif
; 626  :     fseek( CurrFile[OBJ], end_of_header, SEEK_SET );

	mov	edx, DWORD PTR end_of_header
	xor	r8d, r8d
	mov	rcx, QWORD PTR ModuleInfo+104
	jmp	fseek
omf_set_filepos ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
modinfo$ = 8
omf_init PROC

; 1673 :     DebugMsg(("omf_init enter\n"));
; 1674 :     modinfo->g.WriteModule = omf_write_module;

	lea	rax, OFFSET FLAT:omf_write_module
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx+288], rax

; 1675 :     modinfo->g.Pass1Checks = omf_write_header_initial;

	lea	rax, OFFSET FLAT:omf_write_header_initial
	mov	QWORD PTR [rcx+304], rax

; 1676 :     SymDebSeg[DBGS_SYMBOLS] = NULL;
; 1677 :     SymDebSeg[DBGS_TYPES] = NULL;
; 1678 : #if MULTIHDR
; 1679 :     ln_srcfile = modinfo->srcfile;

	mov	eax, DWORD PTR [rcx+428]
	mov	DWORD PTR ln_srcfile, eax

; 1680 : #endif
; 1681 :     ln_size = 0;

	xor	eax, eax
	mov	WORD PTR ln_size, ax
	movdqu	XMMWORD PTR SymDebSeg, xmm0

; 1682 :     return;
; 1683 : }

	ret	0
omf_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\time.h
;	COMDAT localtime
_TEXT	SEGMENT
_Time$ = 8
localtime PROC						; COMDAT

; 509  :             #pragma warning(push)
; 510  :             #pragma warning(disable: 4996)
; 511  :             return _localtime64(_Time);

	jmp	_localtime64
localtime ENDP
_TEXT	ENDS
END
