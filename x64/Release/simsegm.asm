; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG10929 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG10869 DB	'_TEXT', 00H
	ORG $+2
$SG10870 DB	'STACK', 00H
	ORG $+2
$SG10871 DB	'_DATA', 00H
	ORG $+2
$SG10872 DB	'_BSS', 00H
	ORG $+3
$SG10873 DB	'FAR_DATA', 00H
	ORG $+3
$SG10875 DB	'CONST', 00H
	ORG $+2
$SG10880 DB	'BSS', 00H
$SG10874 DB	'FAR_BSS', 00H
$SG10877 DB	'CODE', 00H
	ORG $+3
$SG10878 DB	'STACK', 00H
	ORG $+2
$SG10879 DB	'DATA', 00H
	ORG $+3
$SG10881 DB	'FAR_DATA', 00H
	ORG $+3
$SG10883 DB	'CONST', 00H
	ORG $+2
$SG10885 DB	'PUBLIC', 00H
	ORG $+5
$SG10882 DB	'FAR_BSS', 00H
$SG10886 DB	'STACK', 00H
	ORG $+2
$SG10887 DB	'PUBLIC', 00H
	ORG $+1
$SG10888 DB	'PUBLIC', 00H
	ORG $+1
$SG10889 DB	'PRIVATE', 00H
$SG10890 DB	'PRIVATE', 00H
$SG10891 DB	'PUBLIC', 00H
	ORG $+1
$SG10908 DB	'%s %r %s', 00H
	ORG $+3
$SG10913 DB	'%s %r', 00H
	ORG $+2
$SG10927 DB	'WORD', 00H
	ORG $+3
$SG10928 DB	'PARA', 00H
	ORG $+3
$SG10933 DB	'FLAT', 00H
	ORG $+3
$SG10934 DB	'USE32', 00H
	ORG $+2
$SG10937 DB	'DWORD', 00H
	ORG $+2
$SG10938 DB	'PARA', 00H
	ORG $+7
$SG10943 DB	'%s %r %s %s %s ''%s''', 00H
$SG10948 DB	'%s %r', 00H
	ORG $+2
$SG10952 DB	'%s %r', 00H
	ORG $+2
$SG10954 DB	'%s %r', 00H
	ORG $+2
$SG10959 DB	'%s %r', 00H
	ORG $+2
$SG10998 DB	'FLAT', 00H
	ORG $+7
$SG11000 DB	'%r %r:%s', 00H
	ORG $+7
$SG11002 DB	'ORG 0%xh', 00H
	ORG $+7
$SG11006 DB	'%r %r:ERROR', 00H
	ORG $+4
$SG11010 DB	'%r %r:ERROR', 00H
	ORG $+4
$SG11026 DB	'%s %r %s', 00H
	ORG $+3
$SG11029 DB	', %s', 00H
_DATA	ENDS
CONST	SEGMENT
SegmNamesDef DQ	FLAT:$SG10869
	DQ	FLAT:$SG10870
	DQ	FLAT:$SG10871
	DQ	FLAT:$SG10872
	DQ	FLAT:$SG10873
	DQ	FLAT:$SG10874
	DQ	FLAT:$SG10875
CONST	ENDS
PUBLIC	SimGetSegName
PUBLIC	GetCodeClass
PUBLIC	ModelSimSegmInit
PUBLIC	ModelSimSegmExit
PUBLIC	SetModelDefaultSegNames
PUBLIC	SimplifiedSegDir
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymFind:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	RunLineQueue:PROC
EXTRN	EvalOperand:PROC
EXTRN	LstWrite:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SpecialTable:BYTE
EXTRN	szDgroup:BYTE
EXTRN	__ImageBase:BYTE
_BSS	SEGMENT
	ALIGN	8

SegmNames DQ	07H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$ModelSimSegmInit DD imagerel $LN21
	DD	imagerel $LN21+296
	DD	imagerel $unwind$ModelSimSegmInit
$pdata$ModelSimSegmExit DD imagerel $LN9
	DD	imagerel $LN9+52
	DD	imagerel $unwind$ModelSimSegmExit
$pdata$SetModelDefaultSegNames DD imagerel $LN26
	DD	imagerel $LN26+181
	DD	imagerel $unwind$SetModelDefaultSegNames
$pdata$0$SetModelDefaultSegNames DD imagerel $LN26+181
	DD	imagerel $LN26+272
	DD	imagerel $chain$0$SetModelDefaultSegNames
$pdata$1$SetModelDefaultSegNames DD imagerel $LN26+272
	DD	imagerel $LN26+407
	DD	imagerel $chain$1$SetModelDefaultSegNames
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetSimSeg DD imagerel SetSimSeg
	DD	imagerel SetSimSeg+428
	DD	imagerel $unwind$SetSimSeg
pdata	ENDS
pdata	SEGMENT
$pdata$SimplifiedSegDir DD imagerel $LN55
	DD	imagerel $LN55+71
	DD	imagerel $unwind$SimplifiedSegDir
$pdata$1$SimplifiedSegDir DD imagerel $LN55+71
	DD	imagerel $LN55+768
	DD	imagerel $chain$1$SimplifiedSegDir
$pdata$2$SimplifiedSegDir DD imagerel $LN55+768
	DD	imagerel $LN55+796
	DD	imagerel $chain$2$SimplifiedSegDir
pdata	ENDS
CONST	SEGMENT
SegmClass DQ	FLAT:$SG10877
	DQ	FLAT:$SG10878
	DQ	FLAT:$SG10879
	DQ	FLAT:$SG10880
	DQ	FLAT:$SG10881
	DQ	FLAT:$SG10882
	DQ	FLAT:$SG10883
SegmCombine DQ	FLAT:$SG10885
	DQ	FLAT:$SG10886
	DQ	FLAT:$SG10887
	DQ	FLAT:$SG10888
	DQ	FLAT:$SG10889
	DQ	FLAT:$SG10890
	DQ	FLAT:$SG10891
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetSimSeg DD 0cb501H
	DD	0ec4b5H
	DD	0105416H
	DD	0f3416H
	DD	0f0127216H
	DD	0d00ee010H
	DD	0600b700cH
xdata	ENDS
xdata	SEGMENT
$unwind$ModelSimSegmInit DD 020601H
	DD	030029206H
$unwind$ModelSimSegmExit DD 010401H
	DD	04204H
$unwind$SetModelDefaultSegNames DD 020601H
	DD	070023206H
$chain$0$SetModelDefaultSegNames DD 020521H
	DD	063405H
	DD	imagerel $LN26
	DD	imagerel $LN26+181
	DD	imagerel $unwind$SetModelDefaultSegNames
$chain$1$SetModelDefaultSegNames DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+181
	DD	imagerel $unwind$SetModelDefaultSegNames
$unwind$SimplifiedSegDir DD 040d01H
	DD	015010dH
	DD	030056006H
$chain$1$SimplifiedSegDir DD 041621H
	DD	014e416H
	DD	0197408H
	DD	imagerel $LN55
	DD	imagerel $LN55+71
	DD	imagerel $unwind$SimplifiedSegDir
$chain$2$SimplifiedSegDir DD 021H
	DD	imagerel $LN55
	DD	imagerel $LN55+71
	DD	imagerel $unwind$SimplifiedSegDir
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_TEXT	SEGMENT
opndx$ = 48
i$ = 192
tokenarray$ = 200
init$ = 208
SimplifiedSegDir PROC

; 176  : {

$LN55:
	mov	DWORD PTR [rsp+8], ecx
	push	rbx
	push	rsi
	sub	rsp, 168				; 000000a8H
	mov	rsi, rdx

; 177  :     const char  *name = NULL;

	xor	ebx, ebx

; 178  :     char        init;
; 179  :     int         type;
; 180  :     struct expr opndx;
; 181  : 
; 182  :     DebugMsg1(("SimplifiedSegDir(%s) enter\n", tokenarray[i].string_ptr ));
; 183  : 
; 184  :     LstWrite( LSTTYPE_DIRECTIVE, 0, NULL );

	xor	r8d, r8d
	xor	edx, edx
	lea	ecx, QWORD PTR [rbx+4]
	call	LstWrite

; 185  : 
; 186  :     if( ModuleInfo.model == MODEL_NONE ) {

	cmp	DWORD PTR ModuleInfo+360, ebx
	jne	SHORT $LN4@Simplified

; 187  :         EmitError( MODEL_IS_NOT_DECLARED );

	lea	ecx, QWORD PTR [rbx+96]
	call	EmitError

; 188  :         return( ERROR );

	or	eax, -1

; 282  : }

	add	rsp, 168				; 000000a8H
	pop	rsi
	pop	rbx
	ret	0
$LN4@Simplified:

; 189  :     }
; 190  : 
; 191  :     //type = tokenarray[i].value;
; 192  :     type = GetSflagsSp( tokenarray[i].tokval );

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	rax, rdx
	mov	QWORD PTR [rsp+200], rdi
	shl	rax, 5

; 193  :     i++; /* get past the directive token */

	inc	edx
	mov	QWORD PTR [rsp+160], r14
	lea	r14, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR [rax+rsi+16]
	mov	DWORD PTR i$[rsp], edx
	lea	rcx, QWORD PTR [rax+rax*2]
	movsxd	rdi, DWORD PTR SpecialTable[r14+rcx*4+4]

; 194  : 
; 195  :     if( type == SIM_STACK ) {

	cmp	edi, 1
	jne	SHORT $LN5@Simplified

; 196  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	mov	rdx, rsi
	mov	BYTE PTR [rsp+32], bl
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	je	$LN53@Simplified

; 197  :             return( ERROR );
; 198  :         if( opndx.kind == EXPR_EMPTY )

	mov	eax, DWORD PTR opndx$[rsp+60]
	cmp	eax, -2
	jne	SHORT $LN8@Simplified

; 199  :             opndx.value = DEFAULT_STACK_SIZE;

	mov	DWORD PTR opndx$[rsp], 1024		; 00000400H
$LN49@Simplified:
	mov	edx, DWORD PTR i$[rsp]
	jmp	SHORT $LN11@Simplified
$LN8@Simplified:

; 200  :         else if( opndx.kind != EXPR_CONST ) {

	test	eax, eax
	je	SHORT $LN49@Simplified

; 201  :             EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 202  :             return( ERROR );

	or	eax, -1
	jmp	$LN52@Simplified
$LN5@Simplified:

; 203  :         }
; 204  :     } else {
; 205  :         /* Masm accepts a name argument for .CODE and .FARDATA[?] only.
; 206  :          * HJWasm also accepts this for .DATA[?] and .CONST unless
; 207  :          * option -Zne is set.
; 208  :          */
; 209  :         if( tokenarray[i].token == T_ID &&

	movsxd	rcx, edx
	shl	rcx, 5
	cmp	BYTE PTR [rcx+rsi], 8
	jne	SHORT $LN11@Simplified
	test	edi, -6					; fffffffaH
	jne	SHORT $LN44@Simplified
	cmp	edi, 1
	jne	SHORT $LN13@Simplified
$LN44@Simplified:
	cmp	BYTE PTR Options+127, bl
	jne	SHORT $LN11@Simplified
	lea	eax, DWORD PTR [rdi-2]
	test	eax, -6					; fffffffaH
	jne	SHORT $LN11@Simplified
	cmp	edi, 7
	je	SHORT $LN11@Simplified
$LN13@Simplified:

; 210  :            ( type == SIM_CODE || type == SIM_FARDATA || type == SIM_FARDATA_UN
; 211  :             || ( Options.strict_masm_compat == FALSE &&
; 212  :                 ( type == SIM_DATA || type == SIM_DATA_UN || type == SIM_CONST )))) {
; 213  :             name = tokenarray[i].string_ptr;

	mov	rbx, QWORD PTR [rcx+rsi+8]

; 214  :             i++;

	inc	edx
	mov	DWORD PTR i$[rsp], edx
$LN11@Simplified:

; 215  :         }
; 216  :     }
; 217  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, edx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 0
	je	SHORT $LN14@Simplified

; 218  :         EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rax+rsi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN53@Simplified:

; 219  :         return( ERROR );

	or	eax, -1
	jmp	$LN52@Simplified
$LN14@Simplified:

; 220  :     }
; 221  : 
; 222  :     if( type != SIM_STACK )

	cmp	edi, 1
	je	SHORT $LN34@Simplified

; 223  :         close_currseg();  /* emit a "xxx ENDS" line to close current seg */

	mov	rdx, QWORD PTR ModuleInfo+432
	test	rdx, rdx
	je	SHORT $LN34@Simplified
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG10913
	mov	r8d, 437				; 000001b5H
	call	AddLineQueueX
$LN34@Simplified:

; 224  : 
; 225  :     if ( name == NULL )

	test	rbx, rbx
	jne	SHORT $LN50@Simplified

; 226  :         init = ( ModuleInfo.simseg_init & ( 1 << type ) );

	mov	ecx, edi
	mov	esi, 1
	shl	sil, cl
	and	sil, BYTE PTR ModuleInfo+420
	jmp	SHORT $LN16@Simplified
$LN50@Simplified:
	movzx	esi, BYTE PTR init$[rsp]
$LN16@Simplified:

; 227  : 
; 228  :     switch( type ) {

	cmp	edi, 6
	ja	$LN31@Simplified
	mov	ecx, DWORD PTR $LN48@Simplified[r14+rdi*4]
	add	rcx, r14
	jmp	rcx
$LN17@Simplified:

; 229  :     case SIM_CODE: /* .code */
; 230  :         SetSimSeg( SIM_CODE, name );

	mov	rdx, rbx
	xor	ecx, ecx
	call	SetSimSeg

; 231  : 
; 232  :         if( ModuleInfo.model == MODEL_TINY ) {

	mov	eax, DWORD PTR ModuleInfo+360
	cmp	eax, 1
	jne	SHORT $LN18@Simplified

; 233  :             /* v2.05: add the named code segment to DGROUP */
; 234  :             if ( name )

	test	rbx, rbx
	je	SHORT $LN20@Simplified

; 235  :                 AddToDgroup( SIM_CODE, name );

	mov	rdx, rbx
	xor	ecx, ecx
	call	AddToDgroup
$LN20@Simplified:

; 236  :             name = szDgroup;

	lea	rbx, OFFSET FLAT:szDgroup
	jmp	SHORT $LN23@Simplified
$LN18@Simplified:

; 237  :         } else if( ModuleInfo.model == MODEL_FLAT ) {

	cmp	eax, 7
	jne	SHORT $LN21@Simplified

; 238  :             name = "FLAT";

	lea	rbx, OFFSET FLAT:$SG10998

; 239  :         } else {

	jmp	SHORT $LN23@Simplified
$LN21@Simplified:

; 240  :             if( name == NULL )

	test	rbx, rbx
	cmove	rbx, QWORD PTR SegmNames
$LN23@Simplified:

; 241  :                 name = SegmNames[SIM_CODE];
; 242  :         }
; 243  :         AddLineQueueX( "%r %r:%s", T_ASSUME, T_CS, name );

	mov	r9, rbx
	lea	rcx, OFFSET FLAT:$SG11000
	mov	edx, 439				; 000001b7H
	mov	r8d, 26
	call	AddLineQueueX

; 244  :         break;

	jmp	$LN31@Simplified
$LN24@Simplified:

; 245  :     case SIM_STACK: /* .stack */
; 246  :         /* if code is generated which does "emit" bytes,
; 247  :          * the original source line has to be saved.
; 248  :          * v2.05: must not be done after LstWrite() has been called!
; 249  :          * Also, there are no longer bytes "emitted".
; 250  :          */
; 251  :         //FStoreLine();
; 252  :         SetSimSeg( SIM_STACK, NULL );

	xor	edx, edx
	lea	ecx, QWORD PTR [rdx+1]
	call	SetSimSeg

; 253  :         AddLineQueueX( "ORG 0%xh", opndx.value );

	mov	edx, DWORD PTR opndx$[rsp]
	lea	rcx, OFFSET FLAT:$SG11002
	call	AddLineQueueX

; 254  :         EndSimSeg( SIM_STACK );

	mov	rdx, QWORD PTR SegmNames+8
	lea	rcx, OFFSET FLAT:$SG10959
	mov	r8d, 437				; 000001b5H
	call	AddLineQueueX

; 255  :         /* add stack to dgroup for some segmented models */
; 256  :         if ( !init )

	test	sil, sil
	jne	$LN31@Simplified

; 257  :             if ( ModuleInfo.distance != STACK_FAR )

	cmp	DWORD PTR ModuleInfo+356, 1
	je	$LN31@Simplified

; 258  :                 AddToDgroup( SIM_STACK, NULL );

	cmp	DWORD PTR ModuleInfo+360, 7
	je	$LN31@Simplified
	mov	eax, DWORD PTR Options+144
	add	eax, -2					; fffffffeH
	cmp	eax, 1
	jbe	SHORT $LN31@Simplified
	mov	r9, QWORD PTR SegmNames+8
	lea	rdx, OFFSET FLAT:szDgroup
	mov	r8d, 438				; 000001b6H
	lea	rcx, OFFSET FLAT:$SG10908
	call	AddLineQueueX

; 259  :         break;

	jmp	SHORT $LN31@Simplified
$LN27@Simplified:

; 260  :     case SIM_DATA:    /* .data  */
; 261  :     case SIM_DATA_UN: /* .data? */
; 262  :     case SIM_CONST:   /* .const */
; 263  :         SetSimSeg( type, name );

	mov	rdx, rbx
	mov	ecx, edi
	call	SetSimSeg

; 264  :         AddLineQueueX( "%r %r:ERROR", T_ASSUME, T_CS );

	mov	edx, 439				; 000001b7H
	lea	rcx, OFFSET FLAT:$SG11006
	mov	r8d, 26
	call	AddLineQueueX

; 265  :         if ( name || (!init) )

	test	rbx, rbx
	jne	SHORT $LN29@Simplified
	test	sil, sil
	jne	SHORT $LN31@Simplified
$LN29@Simplified:

; 266  :             AddToDgroup( type, name );

	mov	rdx, rbx
	mov	ecx, edi
	call	AddToDgroup

; 267  :         break;

	jmp	SHORT $LN31@Simplified
$LN30@Simplified:

; 268  :     case SIM_FARDATA:     /* .fardata  */
; 269  :     case SIM_FARDATA_UN:  /* .fardata? */
; 270  :         SetSimSeg( type, name );

	mov	rdx, rbx
	mov	ecx, edi
	call	SetSimSeg

; 271  :         AddLineQueueX( "%r %r:ERROR", T_ASSUME, T_CS );

	mov	edx, 439				; 000001b7H
	lea	rcx, OFFSET FLAT:$SG11010
	mov	r8d, 26
	call	AddLineQueueX
$LN31@Simplified:

; 272  :         break;
; 273  :     default: /* shouldn't happen */
; 274  :         /**/myassert( 0 );
; 275  :         break;
; 276  :     }
; 277  : 
; 278  :     RunLineQueue();

	call	RunLineQueue

; 279  : 
; 280  :     DebugMsg1(("SimplifiedSegDir exit\n"));
; 281  :     return( NOT_ERROR );

	xor	eax, eax
$LN52@Simplified:
	mov	rdi, QWORD PTR [rsp+200]
	mov	r14, QWORD PTR [rsp+160]

; 282  : }

	add	rsp, 168				; 000000a8H
	pop	rsi
	pop	rbx
	ret	0
	npad	3
$LN48@Simplified:
	DD	$LN17@Simplified
	DD	$LN24@Simplified
	DD	$LN27@Simplified
	DD	$LN27@Simplified
	DD	$LN30@Simplified
	DD	$LN30@Simplified
	DD	$LN27@Simplified
SimplifiedSegDir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
;	COMDAT EndSimSeg
_TEXT	SEGMENT
segm$ = 8
EndSimSeg PROC						; COMDAT

; 166  :     AddLineQueueX( "%s %r", SegmNames[segm], T_ENDS );

	movsxd	rdx, ecx
	lea	rax, OFFSET FLAT:SegmNames
	mov	r8d, 437				; 000001b5H
	lea	rcx, OFFSET FLAT:$SG10959
	mov	rdx, QWORD PTR [rax+rdx*8]
	jmp	AddLineQueueX
EndSimSeg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
;	COMDAT SetSimSeg
_TEXT	SEGMENT
segm$ = 112
name$ = 120
SetSimSeg PROC						; COMDAT

; 97   : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H

; 98   :     char *pAlign = "WORD";
; 99   :     char *pAlignSt = "PARA";
; 100  :     char *pUse = "";
; 101  :     struct asym *sym;
; 102  :     const char *pFmt;
; 103  :     const char *pClass;
; 104  : 
; 105  :     if ( ModuleInfo.defOfssize > USE16 ) {

	cmp	BYTE PTR ModuleInfo+405, 0
	lea	rdi, OFFSET FLAT:$SG10927
	movsxd	rbx, ecx
	lea	r15, OFFSET FLAT:$SG10929
	lea	rcx, OFFSET FLAT:$SG10928
	mov	rbp, rdx
	jbe	SHORT $LN2@SetSimSeg

; 106  :         if ( ModuleInfo.model == MODEL_FLAT )

	cmp	DWORD PTR ModuleInfo+360, 7
	lea	rax, OFFSET FLAT:$SG10934

; 107  :             pUse = "FLAT";
; 108  :         else
; 109  :             pUse = "USE32";
; 110  :         if (( ModuleInfo.curr_cpu & P_CPU_MASK ) <= P_386 )

	lea	rcx, OFFSET FLAT:$SG10938
	lea	r15, OFFSET FLAT:$SG10933
	cmovne	r15, rax
	lea	rdi, OFFSET FLAT:$SG10937
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	cmovg	rdi, rcx

; 111  :             pAlign = "DWORD";
; 112  :         else
; 113  :             pAlign = "PARA";
; 114  :         pAlignSt = pAlign;

	mov	rcx, rdi
$LN2@SetSimSeg:

; 115  :     }
; 116  : 
; 117  :     if ( segm == SIM_CODE )

	lea	r13, OFFSET FLAT:__ImageBase
	test	ebx, ebx
	jne	SHORT $LN7@SetSimSeg

; 118  :         pClass = GetCodeClass();

	mov	rax, QWORD PTR Options+80
	mov	r14, QWORD PTR SegmClass
	test	rax, rax
	cmovne	r14, rax
	jmp	SHORT $LN9@SetSimSeg
$LN7@SetSimSeg:

; 119  :     else
; 120  :         pClass = SegmClass[segm];

	mov	r14, QWORD PTR SegmClass[r13+rbx*8]
	cmp	ebx, 1
	je	SHORT $LN10@SetSimSeg
	lea	eax, DWORD PTR [rbx-4]
	cmp	eax, 1
	ja	SHORT $LN9@SetSimSeg
$LN10@SetSimSeg:

; 121  : 
; 122  :     if ( segm == SIM_STACK || segm == SIM_FARDATA || segm == SIM_FARDATA_UN )
; 123  :         pAlign = pAlignSt;

	mov	rdi, rcx
$LN9@SetSimSeg:
	mov	QWORD PTR [rsp+112], r12

; 124  : 
; 125  :     pFmt = "%s %r %s %s %s '%s'";

	lea	rsi, OFFSET FLAT:$SG10943

; 126  :     if ( name == NULL ) {

	test	rdx, rdx
	jne	SHORT $LN11@SetSimSeg

; 127  :         name = SegmNames[segm];
; 128  :         if ( ModuleInfo.simseg_init & ( 1 << segm ) )

	movzx	eax, BYTE PTR ModuleInfo+420
	mov	ecx, ebx
	mov	rbp, QWORD PTR SegmNames[r13+rbx*8]
	mov	r12d, 1
	shl	r12d, cl
	test	eax, r12d
	je	SHORT $LN13@SetSimSeg

; 129  :             pFmt = "%s %r";

	lea	rsi, OFFSET FLAT:$SG10948
	jmp	SHORT $LN18@SetSimSeg
$LN13@SetSimSeg:

; 130  :         else {
; 131  :             ModuleInfo.simseg_init |= ( 1 << segm );

	bts	eax, ebx

; 132  :             /* v2.05: if segment exists already, use the current attribs.
; 133  :              * This allows a better mix of full and simplified segment
; 134  :              * directives. Masm behaves differently: the attributes
; 135  :              * of the simplified segment directives have highest priority.
; 136  :              */
; 137  :             if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	BYTE PTR ModuleInfo+420, al
	jne	SHORT $LN26@SetSimSeg

; 138  :                 sym = SymSearch( name );

	mov	rcx, rbp
	call	SymFind

; 139  :                 /* v2.12: check 'isdefined' member instead of 'lname_idx' */
; 140  :                 //if ( sym && sym->state == SYM_SEG && ((struct dsym *)sym)->e.seginfo->lname_idx != 0 )
; 141  :                 if ( sym && sym->state == SYM_SEG && sym->isdefined == TRUE )

	test	rax, rax
	je	SHORT $LN26@SetSimSeg
	cmp	DWORD PTR [rax+32], 3
	jne	SHORT $LN26@SetSimSeg
	test	BYTE PTR [rax+40], 2
	je	SHORT $LN26@SetSimSeg

; 142  :                     ModuleInfo.simseg_defd |= ( 1 << segm );

	movzx	eax, BYTE PTR ModuleInfo+421
	bts	eax, ebx
	mov	BYTE PTR ModuleInfo+421, al
	jmp	SHORT $LN16@SetSimSeg
$LN26@SetSimSeg:
	movzx	eax, BYTE PTR ModuleInfo+421
$LN16@SetSimSeg:

; 143  :             }
; 144  :             if ( ModuleInfo.simseg_defd & ( 1 << segm ) )

	test	al, r12b
	je	SHORT $LN18@SetSimSeg

; 145  :                 pFmt = "%s %r";

	lea	rsi, OFFSET FLAT:$SG10952

; 146  :         }
; 147  :     } else {

	jmp	SHORT $LN18@SetSimSeg
$LN11@SetSimSeg:

; 148  :         sym = SymSearch( name );

	mov	rcx, rdx
	call	SymFind

; 149  :         /* v2.04: testing for state SYM_SEG isn't enough. The segment
; 150  :          * might have been "defined" by a GROUP directive. Additional
; 151  :          * check for segment's lname index is needed.
; 152  :          * v2.12: check 'isdefined' member instead of 'lname_idx'
; 153  :          */
; 154  :         //if ( sym && sym->state == SYM_SEG )
; 155  :         //if ( sym && sym->state == SYM_SEG && ((struct dsym *)sym)->e.seginfo->lname_idx != 0 )
; 156  :         if ( sym && sym->state == SYM_SEG && sym->isdefined == TRUE )

	test	rax, rax
	je	SHORT $LN18@SetSimSeg
	cmp	DWORD PTR [rax+32], 3
	jne	SHORT $LN18@SetSimSeg
	movzx	eax, BYTE PTR [rax+40]
	lea	rdx, OFFSET FLAT:$SG10954
	and	al, 2
	cmove	rdx, rsi
	mov	rsi, rdx
$LN18@SetSimSeg:

; 157  :             pFmt = "%s %r";
; 158  :     }
; 159  :     AddLineQueueX( pFmt, name, T_SEGMENT, pAlign, pUse, SegmCombine[segm], pClass );

	mov	rax, QWORD PTR SegmCombine[r13+rbx*8]
	mov	r9, rdi
	mov	QWORD PTR [rsp+48], r14
	mov	r8d, 436				; 000001b4H
	mov	QWORD PTR [rsp+40], rax
	mov	rdx, rbp
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], r15
	call	AddLineQueueX
	mov	r12, QWORD PTR [rsp+112]

; 160  :     return;
; 161  : }

	mov	rbx, QWORD PTR [rsp+120]
	mov	rbp, QWORD PTR [rsp+128]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	ret	0
SetSimSeg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
;	COMDAT close_currseg
_TEXT	SEGMENT
close_currseg PROC					; COMDAT

; 85   :     if ( CurrSeg ) {

	mov	rdx, QWORD PTR ModuleInfo+432
	test	rdx, rdx
	je	SHORT $LN2@close_curr

; 86   :         DebugMsg1(("close_currseg: current seg=%s\n", CurrSeg->sym.name));
; 87   :         AddLineQueueX( "%s %r", CurrSeg->sym.name, T_ENDS );

	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG10913
	mov	r8d, 437				; 000001b5H
	jmp	AddLineQueueX
$LN2@close_curr:

; 88   :     }
; 89   : }

	ret	0
close_currseg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
;	COMDAT AddToDgroup
_TEXT	SEGMENT
segm$ = 8
name$ = 16
AddToDgroup PROC					; COMDAT

; 63   :     /* no DGROUP for FLAT or COFF/ELF */
; 64   :     if( ModuleInfo.model == MODEL_FLAT
; 65   : #if COFF_SUPPORT
; 66   :        || Options.output_format == OFORMAT_COFF
; 67   : #endif
; 68   : #if ELF_SUPPORT
; 69   :        || Options.output_format == OFORMAT_ELF

	cmp	DWORD PTR ModuleInfo+360, 7
	je	SHORT $LN3@AddToDgrou
	mov	eax, DWORD PTR Options+144
	add	eax, -2					; fffffffeH
	cmp	eax, 1
	jbe	SHORT $LN3@AddToDgrou

; 70   : #endif
; 71   :       )
; 72   :         return;
; 73   : 
; 74   :     if( name == NULL )

	test	rdx, rdx
	jne	SHORT $LN4@AddToDgrou

; 75   :         name = SegmNames[segm];

	movsxd	rax, ecx
	lea	rdx, OFFSET FLAT:SegmNames
	mov	rdx, QWORD PTR [rdx+rax*8]
$LN4@AddToDgrou:

; 76   : 
; 77   :     AddLineQueueX( "%s %r %s", szDgroup, T_GROUP, name );

	mov	r9, rdx
	lea	rcx, OFFSET FLAT:$SG10908
	lea	rdx, OFFSET FLAT:szDgroup
	mov	r8d, 438				; 000001b6H
	jmp	AddLineQueueX
$LN3@AddToDgrou:

; 78   : }

	ret	0
AddToDgroup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_TEXT	SEGMENT
SetModelDefaultSegNames PROC

; 291  : {

$LN26:
	push	rdi
	sub	rsp, 32					; 00000020H

; 292  :     /* init segment names with default values */
; 293  :     memcpy( SegmNames, SegmNamesDef, sizeof(SegmNames) );

	movups	xmm0, XMMWORD PTR SegmNamesDef

; 294  : 
; 295  :     /* option -nt set? */
; 296  :     if( Options.names[OPTN_TEXT_SEG] ) {

	mov	rax, QWORD PTR Options+64
	or	rdi, -1
	movups	xmm1, XMMWORD PTR SegmNamesDef+16
	movups	XMMWORD PTR SegmNames, xmm0
	movups	xmm0, XMMWORD PTR SegmNamesDef+32
	movups	XMMWORD PTR SegmNames+16, xmm1
	movsd	xmm1, QWORD PTR SegmNamesDef+48
	movsd	QWORD PTR SegmNames+48, xmm1
	movups	XMMWORD PTR SegmNames+32, xmm0
	test	rax, rax
	je	SHORT $LN2@SetModelDe

; 297  :         SegmNames[SIM_CODE] = LclAlloc( strlen( Options.names[OPTN_TEXT_SEG] ) + 1 );

	mov	rcx, rdi
$LL24@SetModelDe:
	inc	rcx
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL24@SetModelDe
	inc	rcx
	call	LclAlloc

; 298  :         strcpy( SegmNames[SIM_CODE], Options.names[OPTN_TEXT_SEG] );

	mov	rdx, QWORD PTR Options+64
	mov	QWORD PTR SegmNames, rax
	npad	14
$LL7@SetModelDe:
	movzx	ecx, BYTE PTR [rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL7@SetModelDe

; 299  :     } else {

	jmp	$LN4@SetModelDe
$LN2@SetModelDe:

; 300  :         if ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) {

	mov	ecx, DWORD PTR ModuleInfo+360
	mov	eax, 1
	shl	eax, cl
	test	al, 112					; 00000070H
	je	$LN4@SetModelDe

; 301  :             /* for some models, the code segment contains the module name */
; 302  :             SegmNames[SIM_CODE] = LclAlloc( strlen( SegmNamesDef[SIM_CODE] ) + strlen( ModuleInfo.name ) + 1 );

	mov	rcx, QWORD PTR SegmNamesDef
	mov	rax, rdi
	mov	QWORD PTR [rsp+48], rbx
	npad	6
$LL23@SetModelDe:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL23@SetModelDe
	lea	rbx, OFFSET FLAT:ModuleInfo+512
	mov	rcx, rdi
$LL22@SetModelDe:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], 0
	jne	SHORT $LL22@SetModelDe
	inc	rax
	add	rcx, rax
	call	LclAlloc
	mov	QWORD PTR SegmNames, rax
	npad	2
$LL8@SetModelDe:

; 303  :             strcpy( SegmNames[SIM_CODE], ModuleInfo.name );

	movzx	ecx, BYTE PTR [rbx]
	lea	rbx, QWORD PTR [rbx+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL8@SetModelDe

; 304  :             strcat( SegmNames[SIM_CODE], SegmNamesDef[SIM_CODE] );

	mov	rcx, QWORD PTR SegmNames
	mov	rbx, QWORD PTR [rsp+48]
	dec	rcx
$LL20@SetModelDe:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL20@SetModelDe
	mov	r8, QWORD PTR SegmNamesDef
	xor	edx, edx
	npad	13
$LL21@SetModelDe:
	movzx	eax, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rcx+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL21@SetModelDe
$LN4@SetModelDe:

; 305  :         }
; 306  :     }
; 307  : 
; 308  :     /* option -nd set? */
; 309  :     if ( Options.names[OPTN_DATA_SEG] ) {

	mov	rax, QWORD PTR Options+72
	test	rax, rax
	je	SHORT $LN5@SetModelDe
	npad	4
$LL19@SetModelDe:

; 310  :         SegmNames[SIM_DATA] = LclAlloc( strlen( Options.names[OPTN_DATA_SEG] ) + 1 );

	cmp	BYTE PTR [rax+rdi+1], 0
	lea	rdi, QWORD PTR [rdi+1]
	jne	SHORT $LL19@SetModelDe
	lea	rcx, QWORD PTR [rdi+1]
	call	LclAlloc

; 311  :         strcpy( SegmNames[SIM_DATA], Options.names[OPTN_DATA_SEG] );

	mov	rdx, QWORD PTR Options+72
	mov	QWORD PTR SegmNames+16, rax
	npad	14
$LL9@SetModelDe:
	movzx	ecx, BYTE PTR [rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL9@SetModelDe
$LN5@SetModelDe:

; 312  :     }
; 313  :     return;
; 314  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetModelDefaultSegNames ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_TEXT	SEGMENT
ModelSimSegmExit PROC

; 361  : {

$LN9:
	sub	rsp, 40					; 00000028H

; 362  :     /* a model is set. Close current segment if one is open. */
; 363  :     if ( CurrSeg ) {

	mov	rdx, QWORD PTR ModuleInfo+432
	test	rdx, rdx
	je	SHORT $LN2@ModelSimSe

; 364  :         close_currseg();

	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG10913
	mov	r8d, 437				; 000001b5H
	call	AddLineQueueX

; 366  :     }
; 367  : }

	add	rsp, 40					; 00000028H

; 365  :         RunLineQueue();

	jmp	RunLineQueue
$LN2@ModelSimSe:

; 366  :     }
; 367  : }

	add	rsp, 40					; 00000028H
	ret	0
ModelSimSegmExit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_TEXT	SEGMENT
buffer$ = 48
model$ = 96
ModelSimSegmInit PROC

; 323  : {

$LN21:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	ebx, ecx

; 324  :     char buffer[20];
; 325  : 
; 326  :     ModuleInfo.simseg_init = 0; /* v2.09: reset init flags */

	mov	BYTE PTR ModuleInfo+420, 0

; 327  :     /* v2.09: execute always, to make a proper listing if fastpass is off */
; 328  :     //if ( Parse_Pass == PASS_1 ) {
; 329  :         DebugMsg1(("ModelSimSegmInit() enter, pass one\n" ));
; 330  :         /* create default code segment (_TEXT) */
; 331  :         SetSimSeg( SIM_CODE, NULL );

	xor	ecx, ecx
	xor	edx, edx
	call	SetSimSeg

; 332  :         EndSimSeg( SIM_CODE );

	mov	rdx, QWORD PTR SegmNames
	lea	rcx, OFFSET FLAT:$SG10959
	mov	r8d, 437				; 000001b5H
	call	AddLineQueueX

; 333  : 
; 334  :         /* create default data segment (_DATA) */
; 335  :         SetSimSeg( SIM_DATA, NULL ) ;

	xor	edx, edx
	lea	ecx, QWORD PTR [rdx+2]
	call	SetSimSeg

; 336  :         EndSimSeg( SIM_DATA );

	mov	rdx, QWORD PTR SegmNames+16
	lea	rcx, OFFSET FLAT:$SG10959
	mov	r8d, 437				; 000001b5H
	call	AddLineQueueX

; 337  : 
; 338  :         /* create DGROUP for BIN/OMF if model isn't FLAT */
; 339  :         if( model != MODEL_FLAT &&

	cmp	ebx, 7
	je	$LN18@ModelSimSe
	cmp	DWORD PTR Options+144, 1
	ja	$LN18@ModelSimSe

; 340  :            ( Options.output_format == OFORMAT_OMF
; 341  : #if BIN_SUPPORT
; 342  :             || Options.output_format == OFORMAT_BIN
; 343  : #endif
; 344  :            )) {
; 345  :             strcpy( buffer, "%s %r %s" );

	xor	ecx, ecx
	lea	rdx, OFFSET FLAT:$SG11026
	npad	13
$LL7@ModelSimSe:
	movzx	eax, BYTE PTR [rcx+rdx]
	mov	BYTE PTR buffer$[rsp+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL7@ModelSimSe

; 346  :             if( model == MODEL_TINY ) {

	cmp	ebx, 1
	jne	SHORT $LN4@ModelSimSe

; 347  :                 strcat( buffer, ", %s" );

	lea	rax, QWORD PTR buffer$[rsp]
	dec	rax
	npad	3
$LL16@ModelSimSe:
	cmp	BYTE PTR [rax+1], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL16@ModelSimSe
	lea	r8, OFFSET FLAT:$SG11029
	xor	edx, edx
	npad	13
$LL17@ModelSimSe:
	movzx	ecx, BYTE PTR [r8+rdx]
	mov	BYTE PTR [rax+rdx], cl
	lea	rdx, QWORD PTR [rdx+1]
	test	cl, cl
	jne	SHORT $LL17@ModelSimSe

; 348  :                 AddLineQueueX( buffer, szDgroup, T_GROUP, SegmNames[SIM_CODE], SegmNames[SIM_DATA] );

	mov	rax, QWORD PTR SegmNames+16
	lea	rdx, OFFSET FLAT:szDgroup
	mov	r9, QWORD PTR SegmNames
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r8d, 438				; 000001b6H
	mov	QWORD PTR [rsp+32], rax
	call	AddLineQueueX

; 351  :         }
; 352  :         DebugMsg1(("ModelSimSegmInit() exit\n" ));
; 353  :     //}
; 354  :     return( NOT_ERROR );

	xor	eax, eax

; 355  : }

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
$LN4@ModelSimSe:

; 349  :             } else
; 350  :                 AddLineQueueX( buffer, szDgroup, T_GROUP, SegmNames[SIM_DATA] );

	mov	r9, QWORD PTR SegmNames+16
	lea	rdx, OFFSET FLAT:szDgroup
	mov	r8d, 438				; 000001b6H
	lea	rcx, QWORD PTR buffer$[rsp]
	call	AddLineQueueX
$LN18@ModelSimSe:

; 351  :         }
; 352  :         DebugMsg1(("ModelSimSegmInit() exit\n" ));
; 353  :     //}
; 354  :     return( NOT_ERROR );

	xor	eax, eax

; 355  : }

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
ModelSimSegmInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_TEXT	SEGMENT
GetCodeClass PROC

; 51   :     /* option -nc set? */
; 52   :     if ( Options.names[OPTN_CODE_CLASS] )

	mov	rcx, QWORD PTR Options+80
	mov	rax, QWORD PTR SegmClass
	test	rcx, rcx
	cmovne	rax, rcx

; 53   :         return( Options.names[OPTN_CODE_CLASS] );
; 54   : 
; 55   :     return( SegmClass[SIM_CODE] );
; 56   : }

	ret	0
GetCodeClass ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_TEXT	SEGMENT
segno$ = 8
SimGetSegName PROC

; 45   :     return( SegmNames[segno] );

	movsxd	rax, ecx
	lea	rcx, OFFSET FLAT:SegmNames
	mov	rax, QWORD PTR [rcx+rax*8]

; 46   : }

	ret	0
SimGetSegName ENDP
_TEXT	ENDS
END
