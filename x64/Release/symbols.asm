; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

EXTRN	ModuleInfo:BYTE
EXTRN	FileCur:QWORD
EXTRN	LineCur:QWORD
EXTRN	symCurSeg:QWORD
EXTRN	UpdateLineNumber:PROC
EXTRN	UpdateWordSize:PROC
EXTRN	UpdateCurPC:PROC
_DATA	SEGMENT
COMM	SymCmpFunc:QWORD
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
szDate	DB	0cH DUP (?)
szTime	DB	0cH DUP (?)
symPC	DQ	01H DUP (?)
$SG11067 DB	01H DUP (?)
	ALIGN	4

$SG11131 DB	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
tmtab	DQ	FLAT:$SG11060
	DQ	FLAT:$SG11061
	DQ	0000000000000000H
	DQ	FLAT:$SG11062
	DQ	FLAT:szDate
	DQ	0000000000000000H
	DQ	FLAT:$SG11063
	DQ	FLAT:szTime
	DQ	0000000000000000H
	DQ	FLAT:$SG11064
	DQ	FLAT:ModuleInfo+512
	DQ	0000000000000000H
	DQ	FLAT:$SG11065
	DQ	0000000000000000H
	DQ	FLAT:FileCur
	DQ	FLAT:$SG11066
	DQ	FLAT:$SG11067
	DQ	FLAT:symCurSeg
eqtab	DQ	FLAT:$SG11081
	DD	0d7H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:$SG11082
	DD	0d4H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:$SG11083
	DD	00H
	ORG $+4
	DQ	FLAT:UpdateCurPC
	DQ	FLAT:symPC
	DQ	FLAT:$SG11084
	DD	00H
	ORG $+4
	DQ	FLAT:UpdateLineNumber
	DQ	FLAT:LineCur
	DQ	FLAT:$SG11085
	DD	00H
	ORG $+4
	DQ	FLAT:UpdateWordSize
	DQ	0000000000000000H
CONST	ENDS
_DATA	SEGMENT
$SG11359 DB	'__m128', 00H
	ORG $+1
$SG11360 DB	'__m256', 00H
	ORG $+1
$SG11060 DB	'@Version', 00H
	ORG $+3
$SG11061 DB	'800', 00H
$SG11062 DB	'@Date', 00H
	ORG $+2
$SG11063 DB	'@Time', 00H
	ORG $+2
$SG11064 DB	'@FileName', 00H
	ORG $+2
$SG11083 DB	'$', 00H
	ORG $+2
$SG11065 DB	'@FileCur', 00H
	ORG $+3
$SG11084 DB	'@Line', 00H
	ORG $+6
$SG11066 DB	'@CurSeg', 00H
$SG11081 DB	'__HJWASM__', 00H
	ORG $+5
$SG11082 DB	'__JWASM__', 00H
	ORG $+6
$SG11085 DB	'@WordSize', 00H
	ORG $+6
$SG11257 DB	'%02u/%02u/%02u', 00H
	ORG $+1
$SG11258 DB	'%02u:%02u:%02u', 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	sprintf
PUBLIC	SymAlloc
PUBLIC	SymFree
PUBLIC	SymCreate
PUBLIC	SymLCreate
PUBLIC	SymAddGlobal
PUBLIC	SymAddLocal
PUBLIC	SymLookup
PUBLIC	SymLookupLocal
PUBLIC	SymFind
PUBLIC	SymFindDeclare
PUBLIC	SymInit
PUBLIC	SymFini
PUBLIC	SymPassInit
PUBLIC	SymMakeAllSymbolsPublic
PUBLIC	SymGetAll
PUBLIC	SymEnum
PUBLIC	SymGetCount
PUBLIC	SymSetCmpFunc
PUBLIC	SymClearLocal
PUBLIC	SymSetLocal
PUBLIC	SymGetLocal
PUBLIC	SymSimd
EXTRN	memcmp:PROC
EXTRN	_localtime64:PROC
EXTRN	_time64:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	_memicmp:PROC
EXTRN	strncmp:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	LclAlloc:PROC
EXTRN	DeleteGroup:PROC
EXTRN	AddPublicData:PROC
EXTRN	ReleaseMacroData:PROC
EXTRN	DeleteType:PROC
EXTRN	DeleteProc:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	UseSavedState:BYTE
EXTRN	CurrProc:QWORD
EXTRN	__ImageBase:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	8

gsym_table DQ	01f49H DUP (?)
lsym_table DQ	07fH DUP (?)
gsym	DQ	01H DUP (?)
lsym	DQ	01H DUP (?)
SymCount DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN8
	DD	imagerel $LN8+90
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$SymAlloc DD imagerel $LN9
	DD	imagerel $LN9+201
	DD	imagerel $unwind$SymAlloc
$pdata$SymCreate DD imagerel $LN5
	DD	imagerel $LN5+70
	DD	imagerel $unwind$SymCreate
$pdata$SymLCreate DD imagerel $LN5
	DD	imagerel $LN5+70
	DD	imagerel $unwind$SymLCreate
$pdata$SymAddGlobal DD imagerel $LN5
	DD	imagerel $LN5+77
	DD	imagerel $unwind$SymAddGlobal
$pdata$SymAddLocal DD imagerel $LN6
	DD	imagerel $LN6+145
	DD	imagerel $unwind$SymAddLocal
$pdata$SymLookup DD imagerel $LN6
	DD	imagerel $LN6+49
	DD	imagerel $unwind$SymLookup
$pdata$SymLookupLocal DD imagerel $LN9
	DD	imagerel $LN9+111
	DD	imagerel $unwind$SymLookupLocal
$pdata$SymFind DD imagerel $LN35
	DD	imagerel $LN35+398
	DD	imagerel $unwind$SymFind
$pdata$SymFindDeclare DD imagerel $LN35
	DD	imagerel $LN35+391
	DD	imagerel $unwind$SymFindDeclare
$pdata$SymInit DD imagerel $LN30
	DD	imagerel $LN30+466
	DD	imagerel $unwind$SymInit
$pdata$SymMakeAllSymbolsPublic DD imagerel $LN19
	DD	imagerel $LN19+122
	DD	imagerel $unwind$SymMakeAllSymbolsPublic
$pdata$SymSetLocal DD imagerel $LN22
	DD	imagerel $LN22+154
	DD	imagerel $unwind$SymSetLocal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$free_ext DD imagerel free_ext
	DD	imagerel free_ext+172
	DD	imagerel $unwind$free_ext
pdata	ENDS
pdata	SEGMENT
$pdata$SymSimd DD imagerel $LN69
	DD	imagerel $LN69+31
	DD	imagerel $unwind$SymSimd
$pdata$3$SymSimd DD imagerel $LN69+31
	DD	imagerel $LN69+1317
	DD	imagerel $chain$3$SymSimd
$pdata$4$SymSimd DD imagerel $LN69+1317
	DD	imagerel $LN69+1323
	DD	imagerel $chain$4$SymSimd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$free_ext DD 020601H
	DD	030023206H
xdata	ENDS
xdata	SEGMENT
$unwind$SymAlloc DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$SymCreate DD 020601H
	DD	030023206H
$unwind$SymLCreate DD 020601H
	DD	030023206H
$unwind$SymAddGlobal DD 020601H
	DD	030023206H
$unwind$SymAddLocal DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$SymLookup DD 020601H
	DD	030023206H
$unwind$SymLookupLocal DD 020601H
	DD	030023206H
$unwind$SymFind DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
$unwind$SymFindDeclare DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
$unwind$SymInit DD 060f01H
	DD	0a640fH
	DD	09340fH
	DD	0700b520fH
$unwind$SymMakeAllSymbolsPublic DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$SymSetLocal DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$SymSimd DD 020601H
	DD	070023206H
$chain$3$SymSimd DD 082521H
	DD	09e425H
	DD	08641cH
	DD	07540aH
	DD	063405H
	DD	imagerel $LN69
	DD	imagerel $LN69+31
	DD	imagerel $unwind$SymSimd
$chain$4$SymSimd DD 021H
	DD	imagerel $LN69
	DD	imagerel $LN69+31
	DD	imagerel $unwind$SymSimd
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 48
SymSimd	PROC

; 769  : {

$LN69:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 770  :   struct sfield *pMember = sym->e.structinfo->head;

	mov	rcx, QWORD PTR [rcx+96]
	mov	rax, QWORD PTR [rcx]

; 771  :   if (pMember == NULL && sym->sym.typekind != TYPE_UNION) return;

	test	rax, rax
	jne	SHORT $LN4@SymSimd
	cmp	BYTE PTR [rdi+66], 2
	jne	$LN51@SymSimd
$LN4@SymSimd:
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp

; 772  :   int memberCount = 0;

	xor	ebp, ebp

; 773  :   sym->e.structinfo->isHomogenous = 1;

	mov	BYTE PTR [rcx+20], 1

; 774  : 
; 775  :   int vtotal = sym->sym.total_size;

	mov	r8d, DWORD PTR [rdi+56]

; 776  :   int msize = pMember->sym.total_size;

	mov	edx, DWORD PTR [rax+56]
	mov	QWORD PTR [rsp+64], rsi

; 777  :   enum memtype ctype = pMember->sym.mem_type;

	movsxd	rsi, DWORD PTR [rax+36]
	mov	QWORD PTR [rsp+72], r14
$LL2@SymSimd:

; 778  :   enum memtype htype = pMember->sym.mem_type;
; 779  : 
; 780  :   while (pMember)
; 781  :   {
; 782  :     if (pMember->sym.total_size != msize && pMember->sym.mem_type != ctype && sym->e.structinfo->isHomogenous == 1)

	cmp	DWORD PTR [rax+56], edx
	je	SHORT $LN5@SymSimd
	cmp	DWORD PTR [rax+36], esi
	je	SHORT $LN5@SymSimd
	mov	rcx, QWORD PTR [rdi+96]
	cmp	BYTE PTR [rcx+20], 1
	jne	SHORT $LN5@SymSimd

; 783  :     {
; 784  :       sym->e.structinfo->isHomogenous = 0;

	mov	BYTE PTR [rcx+20], 0
$LN5@SymSimd:

; 785  :     }
; 786  :     pMember = pMember->next;

	mov	rax, QWORD PTR [rax+96]

; 787  :     memberCount = memberCount + 1;

	inc	ebp
	test	rax, rax
	jne	SHORT $LL2@SymSimd

; 788  :   }
; 789  : 
; 790  : 
; 791  :   sym->e.structinfo->memberCount = memberCount;

	mov	rax, QWORD PTR [rdi+96]

; 792  :   if (vtotal == 0x20 && sym->e.structinfo->isHomogenous == 1 && ((sym->sym.typekind == TYPE_UNION) || 

	mov	r14d, 1
	mov	DWORD PTR [rax+24], ebp
	cmp	r8d, 32					; 00000020H
	jne	SHORT $LN6@SymSimd
	mov	rdx, QWORD PTR [rdi+96]
	cmp	BYTE PTR [rdx+20], r14b
	jne	$LN10@SymSimd
	cmp	BYTE PTR [rdi+66], 2
	je	SHORT $LN9@SymSimd
	cmp	esi, 39					; 00000027H
	ja	SHORT $LN58@SymSimd
	mov	rcx, 584115552257			; 0000008800000001H
	bt	rcx, rsi
	jb	SHORT $LN9@SymSimd
$LN58@SymSimd:
	xor	ecx, ecx
	cmp	esi, 3
	sete	cl
	xor	eax, eax
	cmp	esi, r14d
	sete	al
	or	ecx, eax
	jne	SHORT $LN9@SymSimd
	cmp	esi, 7
	jne	SHORT $LN10@SymSimd
$LN9@SymSimd:

; 793  :     (htype == MT_REAL4 || htype == MT_REAL8 || htype == MT_BYTE || htype == MT_WORD | htype == MT_DWORD || htype == MT_QWORD)))  
; 794  :     sym->e.structinfo->stype = MM256;

	mov	DWORD PTR [rdx+16], 2
	jmp	SHORT $LN10@SymSimd
$LN6@SymSimd:

; 795  :   else if (vtotal == 0x10 && sym->e.structinfo->isHomogenous == 1 && ((sym->sym.typekind == TYPE_UNION) ||

	cmp	r8d, 16
	jne	SHORT $LN10@SymSimd
	mov	rdx, QWORD PTR [rdi+96]
	cmp	BYTE PTR [rdx+20], r14b
	jne	SHORT $LN10@SymSimd
	cmp	BYTE PTR [rdi+66], 2
	je	SHORT $LN12@SymSimd
	cmp	esi, 39					; 00000027H
	ja	SHORT $LN60@SymSimd
	mov	rcx, 584115552257			; 0000008800000001H
	bt	rcx, rsi
	jb	SHORT $LN12@SymSimd
$LN60@SymSimd:
	xor	ecx, ecx
	cmp	esi, 3
	sete	cl
	xor	eax, eax
	cmp	esi, r14d
	sete	al
	or	ecx, eax
	jne	SHORT $LN12@SymSimd
	cmp	esi, 7
	jne	SHORT $LN10@SymSimd
$LN12@SymSimd:

; 796  :     (htype == MT_REAL4 || htype == MT_REAL8 || htype == MT_BYTE || htype == MT_WORD | htype == MT_DWORD || htype == MT_QWORD)))
; 797  :     sym->e.structinfo->stype = MM128;

	mov	DWORD PTR [rdx+16], r14d
$LN10@SymSimd:

; 798  : #if EVEXSUPP
; 799  :   else if (vtotal == 0x40 && sym->e.structinfo->isHomogenous == 1 && ((sym->sym.typekind == TYPE_UNION) ||
; 800  :     (htype == MT_REAL4 || htype == MT_REAL8 || htype == MT_BYTE || htype == MT_WORD | htype == MT_DWORD || htype == MT_QWORD)))
; 801  :     sym->e.structinfo->stype = MM512;
; 802  : #endif
; 803  : 
; 804  :   // Ensure unions of multiple MM128 or MM256 types default to a 4/8 member float arrangement.
; 805  :   if (sym->sym.typekind == TYPE_UNION && sym->e.structinfo->isHomogenous == 1)

	cmp	BYTE PTR [rdi+66], 2
	jne	SHORT $LN15@SymSimd
	mov	rax, QWORD PTR [rdi+96]
	cmp	BYTE PTR [rax+20], r14b
	jne	SHORT $LN15@SymSimd

; 806  :   {
; 807  : 	  if (sym->e.structinfo->stype == MM128) {

	cmp	DWORD PTR [rax+16], r14d
	jne	SHORT $LN14@SymSimd

; 808  : 		  memberCount = 4;

	mov	ebp, 4

; 809  : 		  sym->e.structinfo->memberCount = memberCount;

	mov	DWORD PTR [rax+24], ebp
$LN14@SymSimd:

; 810  : 	  }
; 811  : 	  if (sym->e.structinfo->stype == MM256) {

	mov	rax, QWORD PTR [rdi+96]
	cmp	DWORD PTR [rax+16], 2
	jne	SHORT $LN15@SymSimd

; 812  : 		  memberCount = 8;

	mov	ebp, 8

; 813  : 		  sym->e.structinfo->memberCount = memberCount;

	mov	DWORD PTR [rax+24], ebp
$LN15@SymSimd:

; 814  : 	  }
; 815  :   }
; 816  : 
; 817  :        sym->e.structinfo->isHFA = 0;

	mov	rax, QWORD PTR [rdi+96]
	mov	BYTE PTR [rax+22], 0

; 818  :        if ((memberCount >= 1 && memberCount <= 4) && (htype == MT_REAL4 || htype == MT_REAL8) && sym->e.structinfo->isHomogenous == 1)

	lea	eax, DWORD PTR [rbp-1]
	cmp	eax, 3
	ja	SHORT $LN16@SymSimd
	lea	eax, DWORD PTR [rsi-35]
	test	eax, -5					; fffffffbH
	jne	SHORT $LN16@SymSimd
	mov	rax, QWORD PTR [rdi+96]
	cmp	BYTE PTR [rax+20], r14b
	jne	SHORT $LN16@SymSimd

; 819  :        {
; 820  :               sym->e.structinfo->isHFA = 1;

	mov	BYTE PTR [rax+22], r14b

; 821  : 			  sym->e.structinfo->stype = NOVEC;

	mov	rax, QWORD PTR [rdi+96]
	mov	DWORD PTR [rax+16], 0
$LN16@SymSimd:

; 822  :        }
; 823  : 
; 824  : 	   // Due to vectorcall convention, __m128 which is technically also an HFA (4 floats) must be marked as nonHFA.
; 825  : 	   // And consequently any structure with name __m128/__m256/__m512 must be marked as non-HFA. (This is a bit ugly, but it's the only way to ensure the types are correctly handled by invoke/proc).
; 826  : 
; 827  : 	   int c0 = strncmp(sym->sym.name, "__m128", 6);

	mov	rcx, QWORD PTR [rdi+8]
	lea	rdx, OFFSET FLAT:$SG11359
	mov	r8d, 6
	call	strncmp

; 828  : 	   int c1 = strncmp(sym->sym.name, "__m256", 6);

	mov	rcx, QWORD PTR [rdi+8]
	lea	rdx, OFFSET FLAT:$SG11360
	mov	r8d, 6
	mov	ebx, eax
	call	strncmp

; 829  : #if EVEXSUPP
; 830  : 	   int c2 = strncmp(sym->sym.name, "__m512", 6);
; 831  : #endif
; 832  : 	   if (c0 == 0)

	test	ebx, ebx
	jne	SHORT $LN18@SymSimd

; 833  : 	   {
; 834  : 		   sym->e.structinfo->isHFA = 0;

	mov	rax, QWORD PTR [rdi+96]
	mov	BYTE PTR [rax+22], bl

; 835  : 		   sym->e.structinfo->stype = MM128;

	mov	rax, QWORD PTR [rdi+96]
	mov	DWORD PTR [rax+16], r14d

; 836  : 	   }

	jmp	SHORT $LN20@SymSimd
$LN18@SymSimd:

; 837  : 	   else if (c1 == 0)

	test	eax, eax
	jne	SHORT $LN20@SymSimd

; 838  : 	   {
; 839  : 		   sym->e.structinfo->isHFA = 0;

	mov	rax, QWORD PTR [rdi+96]
	mov	BYTE PTR [rax+22], 0

; 840  : 		   sym->e.structinfo->stype = MM256;

	mov	rax, QWORD PTR [rdi+96]
	mov	DWORD PTR [rax+16], 2
$LN20@SymSimd:

; 841  : 	   }
; 842  : #if EVEXSUPP
; 843  : 	   else if (c2 == 0)
; 844  : 	   {
; 845  : 		   sym->e.structinfo->isHFA = 0;
; 846  : 		   sym->e.structinfo->stype = MM512;
; 847  : 	   }
; 848  : #endif
; 849  : 
; 850  : 	   sym->e.structinfo->isHVA = 0;

	mov	rax, QWORD PTR [rdi+96]
	mov	BYTE PTR [rax+21], 0

; 851  : 	   if (memberCount == 4 && sym->e.structinfo->isHomogenous == 1 && htype == MT_TYPE && sym->sym.typekind != TYPE_UNION)

	cmp	ebp, 4
	jne	$LN21@SymSimd
	mov	rbx, QWORD PTR [rdi+96]
	cmp	BYTE PTR [rbx+20], r14b
	jne	$LN66@SymSimd
	cmp	esi, 196				; 000000c4H
	jne	$LN66@SymSimd
	cmp	BYTE PTR [rdi+66], 2
	je	$LN66@SymSimd

; 852  : 	   {
; 853  : 		   pMember = sym->e.structinfo->head;

	mov	r11, QWORD PTR [rbx]

; 854  : 		   uint_8 member1Valid = 0;

	xor	r10b, r10b

; 855  : 		   uint_8 member2Valid = 0;

	xor	r9b, r9b

; 856  : 		   uint_8 member3Valid = 0;

	xor	r8b, r8b

; 857  : 		   uint_8 member4Valid = 0;

	xor	dl, dl

; 858  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member1Valid = 1;

	mov	rax, QWORD PTR [r11+80]
	test	rax, rax
	je	SHORT $LN23@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	r10d, r10b
	cmp	DWORD PTR [rax+16], r14d
	cmove	r10d, r14d
$LN23@SymSimd:

; 859  : 		   pMember = pMember->next;

	mov	rcx, QWORD PTR [r11+96]

; 860  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member2Valid = 1;

	mov	rax, QWORD PTR [rcx+80]
	test	rax, rax
	je	SHORT $LN24@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	r9d, r9b
	cmp	DWORD PTR [rax+16], r14d
	cmove	r9d, r14d
$LN24@SymSimd:

; 861  : 		   pMember = pMember->next;

	mov	rcx, QWORD PTR [rcx+96]

; 862  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member3Valid = 1;

	mov	rax, QWORD PTR [rcx+80]
	test	rax, rax
	je	SHORT $LN25@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	r8d, r8b
	cmp	DWORD PTR [rax+16], r14d
	cmove	r8d, r14d
$LN25@SymSimd:

; 863  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR [rcx+96]

; 864  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member4Valid = 1;

	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	je	SHORT $LN26@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	edx, dl
	cmp	DWORD PTR [rax+16], r14d
	cmove	edx, r14d
$LN26@SymSimd:

; 865  : 
; 866  : 		   pMember = sym->e.structinfo->head;
; 867  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member1Valid = 1;

	mov	rax, QWORD PTR [r11+80]
	test	rax, rax
	je	SHORT $LN27@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	r10d, r10b
	cmp	DWORD PTR [rax+16], 2
	cmove	r10d, r14d
$LN27@SymSimd:

; 868  : 		   pMember = pMember->next;

	mov	r11, QWORD PTR [r11+96]

; 869  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member2Valid = 1;

	mov	rax, QWORD PTR [r11+80]
	test	rax, rax
	je	SHORT $LN28@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	r9d, r9b
	cmp	DWORD PTR [rax+16], 2
	cmove	r9d, r14d
$LN28@SymSimd:

; 870  : 		   pMember = pMember->next;

	mov	r11, QWORD PTR [r11+96]

; 871  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member3Valid = 1;

	mov	rax, QWORD PTR [r11+80]
	test	rax, rax
	je	SHORT $LN29@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	r8d, r8b
	cmp	DWORD PTR [rax+16], 2
	cmove	r8d, r14d
$LN29@SymSimd:

; 872  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR [r11+96]

; 873  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member4Valid = 1;

	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	je	SHORT $LN30@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	edx, dl
	cmp	DWORD PTR [rax+16], 2
	cmove	edx, r14d
$LN30@SymSimd:

; 874  : 
; 875  : 		   if (member1Valid == 1 && member2Valid == 1 && member3Valid == 1 && member4Valid == 1)

	cmp	r10b, r14b
	jne	$LN66@SymSimd
	cmp	r9b, r14b
	jne	$LN66@SymSimd
	cmp	r8b, r14b
	jne	$LN66@SymSimd
	cmp	dl, r14b
	jne	$LN66@SymSimd

; 876  : 		   {
; 877  : 			   sym->e.structinfo->isHVA = 1;

	mov	BYTE PTR [rbx+21], r14b

; 878  : 		   }
; 879  : 	   }

	jmp	$LN66@SymSimd
$LN21@SymSimd:

; 880  : 	   else if (memberCount == 3 && sym->e.structinfo->isHomogenous == 1 && htype == MT_TYPE && sym->sym.typekind != TYPE_UNION)

	cmp	ebp, 3
	jne	$LN32@SymSimd
	mov	r11, QWORD PTR [rdi+96]
	cmp	BYTE PTR [r11+20], r14b
	jne	$LN66@SymSimd
	cmp	esi, 196				; 000000c4H
	jne	$LN66@SymSimd
	cmp	BYTE PTR [rdi+66], 2
	je	$LN66@SymSimd

; 881  : 	   {
; 882  : 		   pMember = sym->e.structinfo->head;

	mov	r10, QWORD PTR [r11]

; 883  : 		   uint_8 member1Valid = 0;

	xor	r9b, r9b

; 884  : 		   uint_8 member2Valid = 0;

	xor	r8b, r8b

; 885  : 		   uint_8 member3Valid = 0;

	xor	dl, dl

; 886  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member1Valid = 1;

	mov	rax, QWORD PTR [r10+80]
	test	rax, rax
	je	SHORT $LN34@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	r9d, r9b
	cmp	DWORD PTR [rax+16], r14d
	cmove	r9d, r14d
$LN34@SymSimd:

; 887  : 		   pMember = pMember->next;

	mov	rcx, QWORD PTR [r10+96]

; 888  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member2Valid = 1;

	mov	rax, QWORD PTR [rcx+80]
	test	rax, rax
	je	SHORT $LN35@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	r8d, r8b
	cmp	DWORD PTR [rax+16], r14d
	cmove	r8d, r14d
$LN35@SymSimd:

; 889  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR [rcx+96]

; 890  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member3Valid = 1;

	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	je	SHORT $LN36@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	edx, dl
	cmp	DWORD PTR [rax+16], r14d
	cmove	edx, r14d
$LN36@SymSimd:

; 891  : 
; 892  : 		   pMember = sym->e.structinfo->head;
; 893  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member1Valid = 1;

	mov	rax, QWORD PTR [r10+80]
	test	rax, rax
	je	SHORT $LN37@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	r9d, r9b
	cmp	DWORD PTR [rax+16], 2
	cmove	r9d, r14d
$LN37@SymSimd:

; 894  : 		   pMember = pMember->next;
; 895  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member2Valid = 1;

	mov	rax, QWORD PTR [rcx+80]
	test	rax, rax
	je	SHORT $LN38@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	r8d, r8b
	cmp	DWORD PTR [rax+16], 2
	cmove	r8d, r14d
$LN38@SymSimd:

; 896  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR [rcx+96]

; 897  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member3Valid = 1;

	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	je	SHORT $LN39@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	edx, dl
	cmp	DWORD PTR [rax+16], 2
	cmove	edx, r14d
$LN39@SymSimd:

; 898  : 
; 899  : 		   if (member1Valid == 1 && member2Valid == 1 && member3Valid == 1)

	cmp	r9b, r14b
	jne	$LN66@SymSimd
	cmp	r8b, r14b
	jne	$LN66@SymSimd
	cmp	dl, r14b
	jne	$LN66@SymSimd

; 900  : 		   {
; 901  : 			   sym->e.structinfo->isHVA = 1;

	mov	BYTE PTR [r11+21], r14b

; 902  : 		   }
; 903  : 	   }

	jmp	$LN66@SymSimd
$LN32@SymSimd:

; 904  : 	   else if (memberCount == 2 && sym->e.structinfo->isHomogenous == 1 && htype == MT_TYPE && sym->sym.typekind != TYPE_UNION)

	cmp	ebp, 2
	jne	$LN41@SymSimd
	mov	r10, QWORD PTR [rdi+96]
	cmp	BYTE PTR [r10+20], r14b
	jne	$LN66@SymSimd
	cmp	esi, 196				; 000000c4H
	jne	$LN66@SymSimd
	cmp	BYTE PTR [rdi+66], bpl
	je	$LN66@SymSimd

; 905  : 	   {
; 906  : 		   pMember = sym->e.structinfo->head;

	mov	r9, QWORD PTR [r10]

; 907  : 		   uint_8 member1Valid = 0;

	xor	r8b, r8b

; 908  : 		   uint_8 member2Valid = 0;

	xor	dl, dl

; 909  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member1Valid = 1;

	mov	rax, QWORD PTR [r9+80]
	test	rax, rax
	je	SHORT $LN43@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	r8d, r8b
	cmp	DWORD PTR [rax+16], r14d
	cmove	r8d, r14d
$LN43@SymSimd:

; 910  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR [r9+96]

; 911  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member2Valid = 1;

	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	je	SHORT $LN44@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	edx, dl
	cmp	DWORD PTR [rax+16], r14d
	cmove	edx, r14d
$LN44@SymSimd:

; 912  : 
; 913  : 		   pMember = sym->e.structinfo->head;
; 914  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member1Valid = 1;

	mov	rax, QWORD PTR [r9+80]
	test	rax, rax
	je	SHORT $LN45@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	r8d, r8b
	cmp	DWORD PTR [rax+16], 2
	cmove	r8d, r14d
$LN45@SymSimd:

; 915  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR [r9+96]

; 916  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member2Valid = 1;

	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	je	SHORT $LN46@SymSimd
	mov	rax, QWORD PTR [rax+96]
	movzx	edx, dl
	cmp	DWORD PTR [rax+16], 2
	cmove	edx, r14d
$LN46@SymSimd:

; 917  : 
; 918  : 		   if (member1Valid == 1 && member2Valid == 1)

	cmp	r8b, r14b
	jne	SHORT $LN66@SymSimd
	cmp	dl, r14b
	jne	SHORT $LN66@SymSimd

; 919  : 		   {
; 920  : 			   sym->e.structinfo->isHVA = 1;

	mov	BYTE PTR [r10+21], r14b

; 921  : 		   }
; 922  : 	   }

	jmp	SHORT $LN66@SymSimd
$LN41@SymSimd:

; 923  : 	   else if (memberCount == 1 && sym->e.structinfo->isHomogenous == 1 && htype == MT_TYPE && sym->sym.typekind != TYPE_UNION)

	cmp	ebp, r14d
	jne	SHORT $LN66@SymSimd
	mov	r8, QWORD PTR [rdi+96]
	cmp	BYTE PTR [r8+20], r14b
	jne	SHORT $LN66@SymSimd
	cmp	esi, 196				; 000000c4H
	jne	SHORT $LN66@SymSimd
	cmp	BYTE PTR [rdi+66], 2
	je	SHORT $LN66@SymSimd

; 924  : 	   {
; 925  : 		   pMember = sym->e.structinfo->head;

	mov	rax, QWORD PTR [r8]

; 926  : 		   uint_8 member1Valid = 0;

	xor	cl, cl

; 927  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member1Valid = 1;

	mov	rdx, QWORD PTR [rax+80]
	test	rdx, rdx
	je	SHORT $LN50@SymSimd
	mov	rax, QWORD PTR [rdx+96]
	movzx	ecx, cl
	cmp	DWORD PTR [rax+16], r14d
	cmove	ecx, r14d

; 928  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member1Valid = 1;

	test	rdx, rdx
	je	SHORT $LN50@SymSimd
	cmp	DWORD PTR [rax+16], 2
	je	SHORT $LN57@SymSimd
$LN50@SymSimd:

; 929  : 		   if (member1Valid == 1)

	cmp	cl, r14b
	jne	SHORT $LN66@SymSimd
$LN57@SymSimd:

; 930  : 		   {
; 931  : 			   sym->e.structinfo->isHVA = 1;

	mov	BYTE PTR [r8+21], r14b
$LN66@SymSimd:
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
	mov	r14, QWORD PTR [rsp+72]
$LN51@SymSimd:

; 932  : 		   }
; 933  : 	   }
; 934  : 		#ifdef DEBUG_OUT	   
; 935  : 			printf("Symbol VectorCall Settings: %s isHomogenous:%u isHFA:%u isHVA:%u MMType:%u memberCount:%u\n", sym->sym.name, sym->e.structinfo->isHomogenous, sym->e.structinfo->isHFA, sym->e.structinfo->isHVA, sym->e.structinfo->stype, sym->e.structinfo->memberCount);
; 936  : 		#endif
; 937  : 
; 938  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SymSimd	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
;	COMDAT free_ext
_TEXT	SEGMENT
sym$ = 48
free_ext PROC						; COMDAT

; 396  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 397  :     DebugMsg(("free_ext: item=%p name=%s state=%u\n", sym, sym->name, sym->state ));
; 398  :     switch( sym->state ) {

	mov	eax, DWORD PTR [rcx+32]
	mov	rbx, rcx
	dec	eax
	cmp	eax, 9
	ja	SHORT $LN13@free_ext
	lea	rcx, OFFSET FLAT:__ImageBase
	cdqe
	mov	edx, DWORD PTR $LN16@free_ext[rcx+rax*4]
	add	rdx, rcx
	jmp	rdx
$LN4@free_ext:

; 399  :     case SYM_INTERNAL:
; 400  :         if ( sym->isproc )

	test	BYTE PTR [rbx+41], 8
	je	SHORT $LN13@free_ext

; 401  :             DeleteProc( (struct dsym *)sym );

	mov	rcx, rbx

; 430  :         LclFree( ((struct dsym *)sym)->e.macroinfo );
; 431  :         break;
; 432  :     case SYM_TMACRO:
; 433  :         if ( sym->predefined == FALSE )
; 434  :             LclFree( sym->string_ptr );
; 435  :         break;
; 436  : #ifdef DEBUG_OUT 
; 437  :     case SYM_STACK:
; 438  :         /* to be removed, this can't happen anymore. */
; 439  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) { 
; 440  :             DebugMsg(( "free_ext: case SYM_STACK, sym=%s with private type\n", sym->name ));
; 441  :             /* symbol has a "private" type */
; 442  :             SymFree( sym->type );
; 443  :         }
; 444  :         break;
; 445  : #endif
; 446  :     }
; 447  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 401  :             DeleteProc( (struct dsym *)sym );

	jmp	DeleteProc
$LN6@free_ext:

; 402  :         break;
; 403  :     case SYM_EXTERNAL:
; 404  :         if ( sym->isproc )

	test	BYTE PTR [rbx+41], 8
	je	SHORT $LN7@free_ext

; 405  :             DeleteProc( (struct dsym *)sym );

	mov	rcx, rbx
	call	DeleteProc
$LN7@free_ext:

; 406  :         sym->first_size = 0;

	mov	DWORD PTR [rbx+44], 0

; 430  :         LclFree( ((struct dsym *)sym)->e.macroinfo );
; 431  :         break;
; 432  :     case SYM_TMACRO:
; 433  :         if ( sym->predefined == FALSE )
; 434  :             LclFree( sym->string_ptr );
; 435  :         break;
; 436  : #ifdef DEBUG_OUT 
; 437  :     case SYM_STACK:
; 438  :         /* to be removed, this can't happen anymore. */
; 439  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) { 
; 440  :             DebugMsg(( "free_ext: case SYM_STACK, sym=%s with private type\n", sym->name ));
; 441  :             /* symbol has a "private" type */
; 442  :             SymFree( sym->type );
; 443  :         }
; 444  :         break;
; 445  : #endif
; 446  :     }
; 447  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN10@free_ext:

; 407  :         /* The altname field may contain a symbol (if weak == FALSE).
; 408  :          * However, this is an independant item and must not be released here
; 409  :          */
; 410  : #ifdef DEBUG_OUT /* to be removed, this can't happen anymore. */
; 411  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) {
; 412  :             DebugMsg(( "free_ext: external with private type: %s\n", sym->name ));
; 413  :             SymFree( sym->type );
; 414  :         }
; 415  : #endif
; 416  :         break;
; 417  :     case SYM_SEG:
; 418  :         if ( ((struct dsym *)sym)->e.seginfo->internal )
; 419  :             LclFree( ((struct dsym *)sym)->e.seginfo->CodeBuffer );
; 420  :         LclFree( ((struct dsym *)sym)->e.seginfo );
; 421  :         break;
; 422  :     case SYM_GRP:
; 423  :         DeleteGroup( (struct dsym *)sym );

	mov	rcx, rbx

; 430  :         LclFree( ((struct dsym *)sym)->e.macroinfo );
; 431  :         break;
; 432  :     case SYM_TMACRO:
; 433  :         if ( sym->predefined == FALSE )
; 434  :             LclFree( sym->string_ptr );
; 435  :         break;
; 436  : #ifdef DEBUG_OUT 
; 437  :     case SYM_STACK:
; 438  :         /* to be removed, this can't happen anymore. */
; 439  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) { 
; 440  :             DebugMsg(( "free_ext: case SYM_STACK, sym=%s with private type\n", sym->name ));
; 441  :             /* symbol has a "private" type */
; 442  :             SymFree( sym->type );
; 443  :         }
; 444  :         break;
; 445  : #endif
; 446  :     }
; 447  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 407  :         /* The altname field may contain a symbol (if weak == FALSE).
; 408  :          * However, this is an independant item and must not be released here
; 409  :          */
; 410  : #ifdef DEBUG_OUT /* to be removed, this can't happen anymore. */
; 411  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) {
; 412  :             DebugMsg(( "free_ext: external with private type: %s\n", sym->name ));
; 413  :             SymFree( sym->type );
; 414  :         }
; 415  : #endif
; 416  :         break;
; 417  :     case SYM_SEG:
; 418  :         if ( ((struct dsym *)sym)->e.seginfo->internal )
; 419  :             LclFree( ((struct dsym *)sym)->e.seginfo->CodeBuffer );
; 420  :         LclFree( ((struct dsym *)sym)->e.seginfo );
; 421  :         break;
; 422  :     case SYM_GRP:
; 423  :         DeleteGroup( (struct dsym *)sym );

	jmp	DeleteGroup
$LN11@free_ext:

; 424  :         break;
; 425  :     case SYM_TYPE:
; 426  :         DeleteType( (struct dsym *)sym );

	mov	rcx, rbx

; 430  :         LclFree( ((struct dsym *)sym)->e.macroinfo );
; 431  :         break;
; 432  :     case SYM_TMACRO:
; 433  :         if ( sym->predefined == FALSE )
; 434  :             LclFree( sym->string_ptr );
; 435  :         break;
; 436  : #ifdef DEBUG_OUT 
; 437  :     case SYM_STACK:
; 438  :         /* to be removed, this can't happen anymore. */
; 439  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) { 
; 440  :             DebugMsg(( "free_ext: case SYM_STACK, sym=%s with private type\n", sym->name ));
; 441  :             /* symbol has a "private" type */
; 442  :             SymFree( sym->type );
; 443  :         }
; 444  :         break;
; 445  : #endif
; 446  :     }
; 447  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 424  :         break;
; 425  :     case SYM_TYPE:
; 426  :         DeleteType( (struct dsym *)sym );

	jmp	DeleteType
$LN12@free_ext:

; 427  :         break;
; 428  :     case SYM_MACRO:
; 429  :         ReleaseMacroData( (struct dsym *)sym );

	mov	rcx, rbx

; 430  :         LclFree( ((struct dsym *)sym)->e.macroinfo );
; 431  :         break;
; 432  :     case SYM_TMACRO:
; 433  :         if ( sym->predefined == FALSE )
; 434  :             LclFree( sym->string_ptr );
; 435  :         break;
; 436  : #ifdef DEBUG_OUT 
; 437  :     case SYM_STACK:
; 438  :         /* to be removed, this can't happen anymore. */
; 439  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) { 
; 440  :             DebugMsg(( "free_ext: case SYM_STACK, sym=%s with private type\n", sym->name ));
; 441  :             /* symbol has a "private" type */
; 442  :             SymFree( sym->type );
; 443  :         }
; 444  :         break;
; 445  : #endif
; 446  :     }
; 447  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 427  :         break;
; 428  :     case SYM_MACRO:
; 429  :         ReleaseMacroData( (struct dsym *)sym );

	jmp	ReleaseMacroData
$LN13@free_ext:

; 430  :         LclFree( ((struct dsym *)sym)->e.macroinfo );
; 431  :         break;
; 432  :     case SYM_TMACRO:
; 433  :         if ( sym->predefined == FALSE )
; 434  :             LclFree( sym->string_ptr );
; 435  :         break;
; 436  : #ifdef DEBUG_OUT 
; 437  :     case SYM_STACK:
; 438  :         /* to be removed, this can't happen anymore. */
; 439  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) { 
; 440  :             DebugMsg(( "free_ext: case SYM_STACK, sym=%s with private type\n", sym->name ));
; 441  :             /* symbol has a "private" type */
; 442  :             SymFree( sym->type );
; 443  :         }
; 444  :         break;
; 445  : #endif
; 446  :     }
; 447  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
	npad	1
$LN16@free_ext:
	DD	$LN4@free_ext
	DD	$LN6@free_ext
	DD	$LN13@free_ext
	DD	$LN10@free_ext
	DD	$LN13@free_ext
	DD	$LN13@free_ext
	DD	$LN11@free_ext
	DD	$LN13@free_ext
	DD	$LN12@free_ext
	DD	$LN13@free_ext
free_ext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
;	COMDAT hashpjw
_TEXT	SEGMENT
s$ = 8
hashpjw	PROC						; COMDAT

; 149  : {

	mov	r9, rcx

; 150  :     unsigned h;
; 151  :     unsigned g;
; 152  : 
; 153  : #if HASH_MAGNITUDE==12
; 154  :     for( h = 0; *s; ++s ) {
; 155  :         h = (h << 4) + (*s | ' ');
; 156  :         g = h & ~0x0fff;
; 157  :         h ^= g;
; 158  :         h ^= g >> 12;
; 159  :     }
; 160  : #else
; 161  :     for( h = 0; *s; ++s ) {

	xor	eax, eax
	movzx	ecx, BYTE PTR [rcx]
	test	cl, cl
	je	SHORT $LN10@hashpjw
	npad	4
$LL4@hashpjw:

; 162  :         h = (h << 5) + (*s | ' ');

	movsx	r8d, cl
	lea	r9, QWORD PTR [r9+1]
	shl	eax, 5
	or	r8d, 32					; 00000020H
	add	eax, r8d

; 163  :         g = h & ~0x7fff;

	mov	edx, eax
	and	edx, -32768				; ffff8000H

; 164  :         h ^= g;
; 165  :         h ^= g >> 15;

	mov	ecx, edx
	shr	ecx, 15
	xor	ecx, edx
	xor	eax, ecx
	movzx	ecx, BYTE PTR [r9]
	test	cl, cl
	jne	SHORT $LL4@hashpjw
$LN10@hashpjw:

; 166  :     }
; 167  : #endif
; 168  :     return( h );
; 169  : }

	ret	0
hashpjw	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
proc$ = 8
SymGetLocal PROC

; 192  :     int i;
; 193  :     struct dsym  **l = &((struct dsym *)proc)->e.procinfo->labellist;

	mov	r8, QWORD PTR [rcx+96]
	lea	rax, OFFSET FLAT:lsym_table
	add	r8, 24
	mov	edx, 127				; 0000007fH
$LL4@SymGetLoca:

; 196  :         if ( lsym_table[i] ) {

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN2@SymGetLoca

; 197  :             *l = (struct dsym *)lsym_table[i];

	mov	QWORD PTR [r8], rcx

; 198  :             l = &(*l)->e.nextll;

	lea	r8, QWORD PTR [rcx+96]
$LN2@SymGetLoca:

; 194  : 
; 195  :     for ( i = 0; i < LHASH_TABLE_SIZE; i++ ) {

	add	rax, 8
	sub	rdx, 1
	jne	SHORT $LL4@SymGetLoca

; 199  :         }
; 200  :     }
; 201  :     *l = NULL;

	mov	QWORD PTR [r8], rdx

; 202  : 
; 203  :     return;
; 204  : }

	ret	0
SymGetLocal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
proc$ = 48
SymSetLocal PROC

; 214  : {

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 215  :     int i;
; 216  :     struct dsym *l;
; 217  : 
; 218  :     SymClearLocal();

	lea	rdi, OFFSET FLAT:lsym_table
	mov	rcx, rdi
	xor	edx, edx
	mov	r8d, 1016				; 000003f8H
	call	memset

; 219  :     for ( l = ((struct dsym *)proc)->e.procinfo->labellist; l; l = l->e.nextll ) {

	mov	rax, QWORD PTR [rbx+96]
	mov	r9, QWORD PTR [rax+24]
	test	r9, r9
	je	SHORT $LN3@SymSetLoca
$LL4@SymSetLoca:

; 220  :         DebugMsg1(("SymSetLocal(%s): label=%s\n", proc->name, l->sym.name ));
; 221  :         i = hashpjw( l->sym.name ) % LHASH_TABLE_SIZE;

	mov	r8, QWORD PTR [r9+8]
	xor	ecx, ecx
	movzx	eax, BYTE PTR [r8]
	test	al, al
	je	SHORT $LN10@SymSetLoca
	npad	1
$LL11@SymSetLoca:
	movsx	edx, al
	lea	r8, QWORD PTR [r8+1]
	or	edx, 32					; 00000020H
	shl	ecx, 5
	add	ecx, edx
	mov	edx, ecx
	and	edx, -32768				; ffff8000H
	mov	eax, edx
	shr	eax, 15
	xor	eax, edx
	xor	ecx, eax
	movzx	eax, BYTE PTR [r8]
	test	al, al
	jne	SHORT $LL11@SymSetLoca
$LN10@SymSetLoca:
	mov	eax, 33818641				; 02040811H
	mul	ecx
	mov	eax, ecx
	sub	eax, edx
	shr	eax, 1
	add	eax, edx
	shr	eax, 6
	imul	eax, eax, 127				; 0000007fH
	sub	ecx, eax

; 222  :         lsym_table[i] = &l->sym;

	movsxd	rax, ecx
	mov	QWORD PTR [rdi+rax*8], r9
	mov	r9, QWORD PTR [r9+96]
	test	r9, r9
	jne	SHORT $LL4@SymSetLoca
$LN3@SymSetLoca:

; 223  :     }
; 224  :     return;
; 225  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SymSetLocal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
SymClearLocal PROC

; 183  :     memset( &lsym_table, 0, sizeof( lsym_table ) );

	xor	edx, edx
	lea	rcx, OFFSET FLAT:lsym_table
	mov	r8d, 1016				; 000003f8H
	jmp	memset
SymClearLocal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
SymSetCmpFunc PROC

; 174  :     SymCmpFunc = ( ModuleInfo.case_sensitive == TRUE ? memcmp : (StrCmpFunc)_memicmp );

	mov	eax, DWORD PTR ModuleInfo+408
	lea	rcx, OFFSET FLAT:_memicmp
	and	al, 1
	lea	rdx, OFFSET FLAT:memcmp
	cmovne	rcx, rdx
	mov	QWORD PTR SymCmpFunc, rcx

; 175  :     return;
; 176  : }

	ret	0
SymSetCmpFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
SymGetCount PROC

; 726  :     return( SymCount );

	mov	eax, DWORD PTR SymCount

; 727  : }

	ret	0
SymGetCount ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 8
pi$ = 16
SymEnum	PROC

; 753  :     if ( sym == NULL ) {

	test	rcx, rcx
	jne	SHORT $LN4@SymEnum

; 754  :         *pi = 0;

	mov	DWORD PTR [rdx], ecx

; 755  :         sym = gsym_table[*pi];

	mov	rax, QWORD PTR gsym_table

; 756  :     } else {

	jmp	SHORT $LN7@SymEnum
$LN4@SymEnum:

; 757  :         sym = sym->nextitem;

	mov	rax, QWORD PTR [rcx]
$LN7@SymEnum:

; 758  :     }
; 759  : 
; 760  :     /* v2.10: changed from for() to while() */
; 761  :     while( sym == NULL && *pi < GHASH_TABLE_SIZE - 1 )

	test	rax, rax
	jne	SHORT $LN11@SymEnum
	lea	r8, OFFSET FLAT:gsym_table
	npad	1
$LL2@SymEnum:
	mov	ecx, DWORD PTR [rdx]
	cmp	ecx, 8008				; 00001f48H
	jge	SHORT $LN11@SymEnum

; 762  :         sym = gsym_table[++(*pi)];

	lea	eax, DWORD PTR [rcx+1]
	movsxd	rcx, eax
	mov	DWORD PTR [rdx], eax
	mov	rax, QWORD PTR [r8+rcx*8]
	test	rax, rax
	je	SHORT $LL2@SymEnum
$LN11@SymEnum:

; 763  : 
; 764  :     //printf("sym=%X, i=%u\n", sym, *pi );
; 765  :     return( sym );
; 766  : }

	ret	0
SymEnum	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
syms$ = 8
SymGetAll PROC

; 734  :     struct asym         *sym;
; 735  :     unsigned            i, j;
; 736  : 
; 737  :     /* copy symbols to table */
; 738  :     for( i = j = 0; i < GHASH_TABLE_SIZE; i++ ) {

	xor	r8d, r8d
	lea	r9, OFFSET FLAT:gsym_table
	mov	r10d, 8009				; 00001f49H
$LL4@SymGetAll:

; 739  :         for( sym = gsym_table[i]; sym; sym = sym->nextitem ) {

	mov	rax, QWORD PTR [r9]
	test	rax, rax
	je	SHORT $LN2@SymGetAll
	npad	8
$LL7@SymGetAll:

; 740  :             syms[j++] = sym;

	mov	QWORD PTR [rcx+r8*8], rax
	inc	r8d
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL7@SymGetAll
$LN2@SymGetAll:

; 734  :     struct asym         *sym;
; 735  :     unsigned            i, j;
; 736  : 
; 737  :     /* copy symbols to table */
; 738  :     for( i = j = 0; i < GHASH_TABLE_SIZE; i++ ) {

	add	r9, 8
	sub	r10, 1
	jne	SHORT $LL4@SymGetAll

; 741  :         }
; 742  :     }
; 743  :     return;
; 744  : }

	ret	0
SymGetAll ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
SymMakeAllSymbolsPublic PROC

; 559  : {

$LN19:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 560  :     int i;
; 561  :     struct asym  *sym;
; 562  : 
; 563  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	lea	rdi, OFFSET FLAT:gsym_table
	lea	rsi, OFFSET FLAT:gsym_table+64072
	npad	3
$LL4@SymMakeAll:

; 564  :         for( sym = gsym_table[i]; sym; sym = sym->nextitem ) {

	mov	rbx, QWORD PTR [rdi]
	test	rbx, rbx
	je	SHORT $LN2@SymMakeAll
$LL7@SymMakeAll:

; 565  :             if ( sym->state == SYM_INTERNAL &&
; 566  :                 /* v2.07: MT_ABS is obsolete */
; 567  :                 //sym->mem_type != MT_ABS &&  /* no EQU or '=' constants */
; 568  :                 sym->isequate == FALSE &&     /* no EQU or '=' constants */
; 569  :                 sym->predefined == FALSE && /* no predefined symbols ($) */
; 570  :                 sym->included == FALSE && /* v2.09: symbol already added to public queue? */
; 571  :                 //sym->scoped == FALSE && /* v2.09: no procs that are marked as "private" */
; 572  :                 sym->name[1] != '&' && /* v2.10: no @@ code labels */

	cmp	DWORD PTR [rbx+32], 1
	jne	SHORT $LN5@SymMakeAll
	movzx	ecx, BYTE PTR [rbx+40]
	test	cl, 48					; 00000030H
	jne	SHORT $LN5@SymMakeAll
	test	BYTE PTR [rbx+41], 64			; 00000040H
	jne	SHORT $LN5@SymMakeAll
	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax+1], 38			; 00000026H
	je	SHORT $LN5@SymMakeAll
	test	cl, cl
	js	SHORT $LN5@SymMakeAll

; 573  :                 sym->ispublic == FALSE ) {
; 574  :                 sym->ispublic = TRUE;

	or	cl, 128					; 00000080H
	mov	BYTE PTR [rbx+40], cl

; 575  :                 AddPublicData( sym );

	mov	rcx, rbx
	call	AddPublicData
$LN5@SymMakeAll:

; 564  :         for( sym = gsym_table[i]; sym; sym = sym->nextitem ) {

	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL7@SymMakeAll
$LN2@SymMakeAll:

; 560  :     int i;
; 561  :     struct asym  *sym;
; 562  : 
; 563  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	add	rdi, 8
	cmp	rdi, rsi
	jl	SHORT $LL4@SymMakeAll

; 576  :             }
; 577  :         }
; 578  :     }
; 579  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SymMakeAllSymbolsPublic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
pass$ = 8
SymPassInit PROC

; 690  :     unsigned            i;
; 691  : 
; 692  :     if ( pass == PASS_1 )

	test	ecx, ecx
	je	SHORT $LN3@SymPassIni

; 693  :         return;
; 694  : 
; 695  : #if FASTPASS
; 696  :     /* No need to reset the "defined" flag if FASTPASS is on.
; 697  :      * Because then the source lines will come from the line store,
; 698  :      * where inactive conditional lines are NOT contained.
; 699  :      */
; 700  :     if ( UseSavedState )

	cmp	BYTE PTR UseSavedState, 0
	jne	SHORT $LN3@SymPassIni

; 701  :         return;
; 702  : #endif
; 703  :     /* mark as "undefined":
; 704  :      * - SYM_INTERNAL - internals
; 705  :      * - SYM_MACRO - macros
; 706  :      * - SYM_TMACRO - text macros
; 707  :      */
; 708  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	lea	rdx, OFFSET FLAT:gsym_table
	mov	r8d, 8009				; 00001f49H
	npad	6
$LL4@SymPassIni:

; 709  :         struct asym *sym;
; 710  :         for( sym = gsym_table[i]; sym; sym = sym->nextitem ) {

	mov	rax, QWORD PTR [rdx]
	test	rax, rax
	je	SHORT $LN2@SymPassIni
	npad	8
$LL7@SymPassIni:

; 711  :             if ( sym->predefined == FALSE ) {

	movzx	ecx, BYTE PTR [rax+40]
	test	cl, 32					; 00000020H
	jne	SHORT $LN5@SymPassIni

; 712  :                 /* v2.04: all symbol's "defined" flag is now reset. */
; 713  :                 // if ( sym->state == SYM_TMACRO ||
; 714  :                 //    sym->state == SYM_MACRO  ||
; 715  :                 //    sym->state == SYM_INTERNAL ) {
; 716  :                     sym->isdefined = FALSE;

	and	cl, 253					; 000000fdH
	mov	BYTE PTR [rax+40], cl
$LN5@SymPassIni:

; 709  :         struct asym *sym;
; 710  :         for( sym = gsym_table[i]; sym; sym = sym->nextitem ) {

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL7@SymPassIni
$LN2@SymPassIni:

; 701  :         return;
; 702  : #endif
; 703  :     /* mark as "undefined":
; 704  :      * - SYM_INTERNAL - internals
; 705  :      * - SYM_MACRO - macros
; 706  :      * - SYM_TMACRO - text macros
; 707  :      */
; 708  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	add	rdx, 8
	sub	r8, 1
	jne	SHORT $LL4@SymPassIni
$LN3@SymPassIni:

; 717  :                 //}
; 718  :             }
; 719  :         }
; 720  :     }
; 721  : }

	ret	0
SymPassInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
SymFini	PROC

; 588  : #if FASTMEM==0 || defined( DEBUG_OUT )
; 589  :     unsigned i;
; 590  : #endif
; 591  : 
; 592  : #ifdef DEBUG_OUT
; 593  :     if ( Options.dump_symbols_hash ) {
; 594  :         for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {
; 595  :             struct asym  *sym = gsym_table[i];
; 596  :             if ( sym ) {
; 597  :                 printf("%4u ", i );
; 598  :                 for( ; sym; sym = sym->nextitem ) {
; 599  :                     printf("%-16s ", sym->name );
; 600  :                 }
; 601  :                 printf("\n" );
; 602  :             }
; 603  :         }
; 604  :     }
; 605  :     DumpSymbols();
; 606  : #endif
; 607  : 
; 608  : #if FASTMEM==0 || defined( DEBUG_OUT )
; 609  :     /* free the symbol table */
; 610  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {
; 611  :         struct asym  *sym;
; 612  :         struct asym  *next;
; 613  :         for( sym = gsym_table[i]; sym; ) {
; 614  :             next = sym->nextitem;
; 615  :             SymFree( sym );
; 616  :             SymCount--;
; 617  :             sym = next;
; 618  :         }
; 619  :     }
; 620  :     /**/myassert( SymCount == 0 );
; 621  : #endif
; 622  : 
; 623  : }

	ret	0
SymFini	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
time_of_day$ = 64
SymInit	PROC

; 629  : {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 630  :     struct asym *sym;
; 631  :     int i;
; 632  :     time_t    time_of_day;
; 633  :     struct tm *now;
; 634  : 
; 635  :     DebugMsg(("SymInit() enter\n"));
; 636  :     SymCount = 0;
; 637  : 
; 638  :     /* v2.11: ensure CurrProc is NULL - might be a problem if multiple files are assembled */
; 639  :     CurrProc = NULL;
; 640  : 
; 641  :     memset( gsym_table, 0, sizeof(gsym_table) );

	xor	edx, edx
	mov	DWORD PTR SymCount, 0
	mov	r8d, 64072				; 0000fa48H
	mov	QWORD PTR CurrProc, 0
	lea	rcx, OFFSET FLAT:gsym_table
	call	memset

; 642  : 
; 643  :     time_of_day = time( NULL );

	xor	ecx, ecx
	call	_time64

; 644  :     now = localtime( &time_of_day );

	lea	rcx, QWORD PTR time_of_day$[rsp]
	mov	QWORD PTR time_of_day$[rsp], rax
	call	_localtime64
	mov	rbx, rax

; 645  : #if USESTRFTIME
; 646  :     strftime( szDate, 9, szDateFmt, now );
; 647  :     strftime( szTime, 9, szTimeFmt, now );
; 648  : #else
; 649  :     sprintf( szDate, "%02u/%02u/%02u", now->tm_mon + 1, now->tm_mday, now->tm_year % 100 );

	mov	r9d, DWORD PTR [rax+20]
	mov	eax, 1374389535				; 51eb851fH
	mov	r8d, DWORD PTR [rbx+16]
	imul	r9d
	inc	r8d
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31
	add	edx, ecx
	imul	ecx, edx, 100				; 00000064H
	lea	rdx, OFFSET FLAT:$SG11257
	sub	r9d, ecx
	lea	rcx, OFFSET FLAT:szDate
	mov	DWORD PTR [rsp+32], r9d
	mov	r9d, DWORD PTR [rbx+12]
	call	sprintf

; 650  :     sprintf( szTime, "%02u:%02u:%02u", now->tm_hour, now->tm_min, now->tm_sec );

	mov	eax, DWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:$SG11258
	mov	r9d, DWORD PTR [rbx+4]
	lea	rcx, OFFSET FLAT:szTime
	mov	r8d, DWORD PTR [rbx+8]
	mov	DWORD PTR [rsp+32], eax
	call	sprintf

; 651  : #endif
; 652  : 
; 653  :     for( i = 0; i < sizeof(tmtab) / sizeof(tmtab[0]); i++ ) {

	xor	esi, esi
	lea	rbx, OFFSET FLAT:tmtab+8
	npad	6
$LL4@SymInit:

; 654  :         sym = SymCreate( tmtab[i].name );

	mov	rdi, QWORD PTR [rbx-8]
	mov	rcx, rdi
	call	SymFind
	test	rax, rax
	je	SHORT $LN16@SymInit
	mov	rdx, rdi
	mov	ecx, 56					; 00000038H
	call	EmitErr
	xor	eax, eax
	jmp	SHORT $LN15@SymInit
$LN16@SymInit:
	mov	rcx, rdi
	call	SymAlloc
	mov	rcx, QWORD PTR gsym
	inc	DWORD PTR SymCount
	mov	QWORD PTR [rcx], rax
$LN15@SymInit:

; 655  :         sym->state = SYM_TMACRO;
; 656  :         sym->isdefined = TRUE;
; 657  :         sym->predefined = TRUE;

	or	BYTE PTR [rax+40], 34			; 00000022H
	mov	DWORD PTR [rax+32], 10

; 658  :         sym->string_ptr = tmtab[i].value;

	mov	rcx, QWORD PTR [rbx]
	mov	QWORD PTR [rax+16], rcx
	mov	rcx, QWORD PTR [rbx+8]

; 659  :         if ( tmtab[i].store )

	test	rcx, rcx
	je	SHORT $LN2@SymInit

; 660  :             *tmtab[i].store = sym;

	mov	QWORD PTR [rcx], rax
$LN2@SymInit:

; 651  : #endif
; 652  : 
; 653  :     for( i = 0; i < sizeof(tmtab) / sizeof(tmtab[0]); i++ ) {

	inc	esi
	add	rbx, 24
	movsxd	rax, esi
	cmp	rax, 6
	jb	SHORT $LL4@SymInit

; 661  :     }
; 662  : 
; 663  :     for( i = 0; i < sizeof(eqtab) / sizeof(eqtab[0]); i++ ) {

	xor	esi, esi
	lea	rbx, OFFSET FLAT:eqtab+8
$LL7@SymInit:

; 664  :         sym = SymCreate( eqtab[i].name );

	mov	rdi, QWORD PTR [rbx-8]
	mov	rcx, rdi
	call	SymFind
	test	rax, rax
	je	SHORT $LN19@SymInit
	mov	rdx, rdi
	mov	ecx, 56					; 00000038H
	call	EmitErr
	xor	eax, eax
	jmp	SHORT $LN18@SymInit
$LN19@SymInit:
	mov	rcx, rdi
	call	SymAlloc
	mov	rcx, QWORD PTR gsym
	inc	DWORD PTR SymCount
	mov	QWORD PTR [rcx], rax
$LN18@SymInit:

; 665  :         sym->state = SYM_INTERNAL;
; 666  :         /* v2.07: MT_ABS is obsolete */
; 667  :         //sym->mem_type = MT_ABS;
; 668  :         sym->isdefined = TRUE;
; 669  :         sym->predefined = TRUE;

	or	BYTE PTR [rax+40], 34			; 00000022H
	mov	DWORD PTR [rax+32], 1

; 670  :         sym->offset = eqtab[i].value;

	mov	ecx, DWORD PTR [rbx]
	mov	DWORD PTR [rax+16], ecx

; 671  :         sym->sfunc_ptr = eqtab[i].sfunc_ptr;

	mov	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rax+64], rcx
	mov	rcx, QWORD PTR [rbx+16]

; 672  :         //sym->variable = TRUE; /* if fixup must be created */
; 673  :         if ( eqtab[i].store )

	test	rcx, rcx
	je	SHORT $LN5@SymInit

; 674  :             *eqtab[i].store = sym;

	mov	QWORD PTR [rcx], rax
$LN5@SymInit:

; 661  :     }
; 662  : 
; 663  :     for( i = 0; i < sizeof(eqtab) / sizeof(eqtab[0]); i++ ) {

	inc	esi
	add	rbx, 32					; 00000020H
	movsxd	rcx, esi
	cmp	rcx, 5
	jb	SHORT $LL7@SymInit

; 675  :     }
; 676  :     sym->list   = FALSE; /* @WordSize should not be listed */

	and	BYTE PTR [rax+41], 254			; 000000feH

; 677  :     /* $ is an address (usually). Also, don't add it to the list */
; 678  :     symPC->variable = TRUE;

	mov	rax, QWORD PTR symPC

; 679  :     symPC->list     = FALSE;
; 680  :     LineCur->list   = FALSE;
; 681  : 
; 682  :     DebugMsg(("SymInit() exit\n"));
; 683  :     return;
; 684  : 
; 685  : }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	or	BYTE PTR [rax+40], 64			; 00000040H
	mov	rax, QWORD PTR symPC
	and	BYTE PTR [rax+41], 254			; 000000feH
	mov	rax, QWORD PTR LineCur
	and	BYTE PTR [rax+41], 254			; 000000feH
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SymInit	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
name$ = 48
SymFindDeclare PROC

; 299  : {

$LN35:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx

; 300  : 	int i;
; 301  : 	int len;
; 302  : 
; 303  : 	len = strlen(name);

	or	rbx, -1
	npad	4
$LL33@SymFindDec:
	inc	rbx
	cmp	BYTE PTR [rcx+rbx], 0
	jne	SHORT $LL33@SymFindDec

; 304  : 	i = hashpjw(name);

	movzx	eax, BYTE PTR [rcx]
	xor	edi, edi
	mov	rdx, rcx
	test	al, al
	je	SHORT $LN14@SymFindDec
	npad	11
$LL15@SymFindDec:
	movsx	ecx, al
	lea	rdx, QWORD PTR [rdx+1]
	or	ecx, 32					; 00000020H
	shl	edi, 5
	add	edi, ecx
	mov	ecx, edi
	and	ecx, -32768				; ffff8000H
	mov	eax, ecx
	shr	eax, 15
	xor	eax, ecx
	xor	edi, eax
	movzx	eax, BYTE PTR [rdx]
	test	al, al
	jne	SHORT $LL15@SymFindDec
$LN14@SymFindDec:

; 305  : 
; 306  : 	if (CurrProc) {

	cmp	QWORD PTR CurrProc, 0
	lea	r14, OFFSET FLAT:__ImageBase
	je	SHORT $LN31@SymFindDec

; 307  : 		for (lsym = &lsym_table[i % LHASH_TABLE_SIZE]; *lsym; lsym = &((*lsym)->nextitem)) {

	mov	eax, -2130574327			; ffffffff81020409H
	mov	ecx, edi
	imul	edi
	add	edx, edi
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	eax, edx, 127				; 0000007fH
	sub	ecx, eax
	movsxd	rax, ecx
	lea	rcx, QWORD PTR lsym_table[r14]
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR lsym, rcx
	test	rdx, rdx
	je	SHORT $LN31@SymFindDec
$LL4@SymFindDec:

; 308  : 			if (len == (*lsym)->name_size && SYMCMP(name, (*lsym)->name, len) == 0) {

	movzx	eax, BYTE PTR [rdx+72]
	cmp	ebx, eax
	jne	SHORT $LN2@SymFindDec
	mov	rdx, QWORD PTR [rdx+8]
	mov	rcx, rsi
	movsxd	r8, ebx
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	$LN20@SymFindDec
	mov	rcx, QWORD PTR lsym
$LN2@SymFindDec:

; 307  : 		for (lsym = &lsym_table[i % LHASH_TABLE_SIZE]; *lsym; lsym = &((*lsym)->nextitem)) {

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR lsym, rcx
	mov	rdx, QWORD PTR [rcx]
	test	rdx, rdx
	jne	SHORT $LL4@SymFindDec
$LN31@SymFindDec:

; 311  : 			}
; 312  : 		}
; 313  : 	}
; 314  : 
; 315  : 	for (gsym = &gsym_table[i % GHASH_TABLE_SIZE]; *gsym; gsym = &((*gsym)->nextitem)) {

	mov	eax, -2098415161			; ffffffff82ecb9c7H
	lea	rcx, QWORD PTR gsym_table[r14]
	imul	edi
	add	edx, edi
	sar	edx, 12
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	eax, edx, 8009				; 00001f49H
	sub	edi, eax
	movsxd	rax, edi
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR gsym, rcx
	test	rdx, rdx
	je	SHORT $LN32@SymFindDec
$LL7@SymFindDec:

; 316  : 		if (len == (*gsym)->name_size && SYMCMP(name, (*gsym)->name, len) == 0) {

	movzx	eax, BYTE PTR [rdx+72]
	cmp	ebx, eax
	jne	SHORT $LN5@SymFindDec
	mov	rdx, QWORD PTR [rdx+8]
	mov	rcx, rsi
	movsxd	r8, ebx
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN21@SymFindDec
	mov	rcx, QWORD PTR gsym
$LN5@SymFindDec:

; 311  : 			}
; 312  : 		}
; 313  : 	}
; 314  : 
; 315  : 	for (gsym = &gsym_table[i % GHASH_TABLE_SIZE]; *gsym; gsym = &((*gsym)->nextitem)) {

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR gsym, rcx
	mov	rdx, QWORD PTR [rcx]
	test	rdx, rdx
	jne	SHORT $LL7@SymFindDec
$LN32@SymFindDec:

; 319  : 		}
; 320  : 	}
; 321  : 
; 322  : 	return(NULL);

	xor	eax, eax
$LN1@SymFindDec:

; 323  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN20@SymFindDec:

; 309  : 				DebugMsg1(("SymFind(%s): found in local table, state=%u, local=%u\n", name, (*lsym)->state, (*lsym)->scoped));
; 310  : 				return(*lsym);

	mov	rax, QWORD PTR lsym
	mov	rax, QWORD PTR [rax]
	jmp	SHORT $LN1@SymFindDec
$LN21@SymFindDec:

; 317  : 			DebugMsg1(("SymFind(%s): found, state=%u memtype=%X lang=%u\n", name, (*gsym)->state, (*gsym)->mem_type, (*gsym)->langtype));
; 318  : 			return(*gsym);

	mov	rax, QWORD PTR gsym
	mov	rax, QWORD PTR [rax]
	jmp	SHORT $LN1@SymFindDec
SymFindDeclare ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
name$ = 48
SymFind	PROC

; 263  : {

$LN35:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx

; 264  :     int i;
; 265  :     int len;
; 266  : 
; 267  :     len = strlen( name );

	or	rbx, -1
	npad	4
$LL33@SymFind:
	inc	rbx
	cmp	BYTE PTR [rcx+rbx], 0
	jne	SHORT $LL33@SymFind

; 268  :     i = hashpjw( name );

	movzx	eax, BYTE PTR [rcx]
	xor	edi, edi
	mov	rdx, rcx
	test	al, al
	je	SHORT $LN14@SymFind
	npad	11
$LL15@SymFind:
	movsx	ecx, al
	lea	rdx, QWORD PTR [rdx+1]
	or	ecx, 32					; 00000020H
	shl	edi, 5
	add	edi, ecx
	mov	ecx, edi
	and	ecx, -32768				; ffff8000H
	mov	eax, ecx
	shr	eax, 15
	xor	eax, ecx
	xor	edi, eax
	movzx	eax, BYTE PTR [rdx]
	test	al, al
	jne	SHORT $LL15@SymFind
$LN14@SymFind:

; 269  : 
; 270  :     if ( CurrProc ) {

	cmp	QWORD PTR CurrProc, 0
	lea	r14, OFFSET FLAT:__ImageBase
	je	SHORT $LN31@SymFind

; 271  :         for( lsym = &lsym_table[ i % LHASH_TABLE_SIZE ]; *lsym; lsym = &((*lsym)->nextitem ) ) {

	mov	eax, -2130574327			; ffffffff81020409H
	mov	ecx, edi
	imul	edi
	add	edx, edi
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	eax, edx, 127				; 0000007fH
	sub	ecx, eax
	movsxd	rax, ecx
	lea	rcx, QWORD PTR lsym_table[r14]
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR lsym, rcx
	test	rdx, rdx
	je	SHORT $LN31@SymFind
$LL4@SymFind:

; 272  :             if ( len == (*lsym)->name_size && SYMCMP( name, (*lsym)->name, len ) == 0 ) {

	movzx	eax, BYTE PTR [rdx+72]
	cmp	ebx, eax
	jne	SHORT $LN2@SymFind
	mov	rdx, QWORD PTR [rdx+8]
	mov	rcx, rsi
	movsxd	r8, ebx
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	$LN20@SymFind
	mov	rcx, QWORD PTR lsym
$LN2@SymFind:

; 271  :         for( lsym = &lsym_table[ i % LHASH_TABLE_SIZE ]; *lsym; lsym = &((*lsym)->nextitem ) ) {

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR lsym, rcx
	mov	rdx, QWORD PTR [rcx]
	test	rdx, rdx
	jne	SHORT $LL4@SymFind
$LN31@SymFind:

; 276  :             }
; 277  :         }
; 278  :     }
; 279  : 
; 280  :     for( gsym = &gsym_table[ i % GHASH_TABLE_SIZE ]; *gsym; gsym = &((*gsym)->nextitem ) ) {

	mov	eax, -2098415161			; ffffffff82ecb9c7H
	lea	rcx, QWORD PTR gsym_table[r14]
	imul	edi
	add	edx, edi
	sar	edx, 12
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	eax, edx, 8009				; 00001f49H
	sub	edi, eax
	movsxd	rax, edi
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR gsym, rcx
	test	rdx, rdx
	je	SHORT $LN32@SymFind
$LL7@SymFind:

; 281  :         if ( len == (*gsym)->name_size && SYMCMP( name, (*gsym)->name, len ) == 0 ) {

	movzx	eax, BYTE PTR [rdx+72]
	cmp	ebx, eax
	jne	SHORT $LN5@SymFind
	mov	rdx, QWORD PTR [rdx+8]
	mov	rcx, rsi
	movsxd	r8, ebx
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN21@SymFind
	mov	rcx, QWORD PTR gsym
$LN5@SymFind:

; 276  :             }
; 277  :         }
; 278  :     }
; 279  : 
; 280  :     for( gsym = &gsym_table[ i % GHASH_TABLE_SIZE ]; *gsym; gsym = &((*gsym)->nextitem ) ) {

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR gsym, rcx
	mov	rdx, QWORD PTR [rcx]
	test	rdx, rdx
	jne	SHORT $LL7@SymFind
$LN32@SymFind:

; 284  :         }
; 285  :     }
; 286  : 
; 287  :     return( NULL );

	xor	eax, eax
$LN1@SymFind:

; 288  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN20@SymFind:

; 273  :                 DebugMsg1(("SymFind(%s): found in local table, state=%u, local=%u\n", name, (*lsym)->state, (*lsym)->scoped ));  			
; 274  : 				(*lsym)->used = TRUE;

	mov	rax, QWORD PTR lsym
	mov	rcx, QWORD PTR [rax]
	or	BYTE PTR [rcx+40], 1

; 275  :                 return( *lsym );

	mov	rax, QWORD PTR [rax]
	jmp	SHORT $LN1@SymFind
$LN21@SymFind:

; 282  :             DebugMsg1(("SymFind(%s): found, state=%u memtype=%X lang=%u\n", name, (*gsym)->state, (*gsym)->mem_type, (*gsym)->langtype ));
; 283  :             return( *gsym );

	mov	rax, QWORD PTR gsym
	mov	rax, QWORD PTR [rax]
	jmp	SHORT $LN1@SymFind
SymFind	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
name$ = 48
SymLookupLocal PROC

; 361  : {

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 362  :     //struct asym      **sym_ptr;
; 363  :     struct asym      *sym;
; 364  : 
; 365  :     sym = SymFind( name );

	call	SymFind
	mov	rdx, rax

; 366  :     if ( sym == NULL ) {

	test	rax, rax
	jne	SHORT $LN2@SymLookupL

; 367  :         sym = SymAlloc( name );

	mov	rcx, rbx
	call	SymAlloc

; 368  :         sym->scoped = TRUE;
; 369  :         /* add the label to the local hash table */
; 370  :         //sym->next = *lsym;
; 371  :         *lsym = sym;

	mov	rcx, QWORD PTR lsym
	or	BYTE PTR [rax+40], 4
	mov	QWORD PTR [rcx], rax

; 390  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@SymLookupL:

; 372  :         DebugMsg1(("SymLookupLocal(%s): local symbol created in %s\n", name, CurrProc->sym.name));
; 373  :     } else if( sym->state == SYM_UNDEFINED && sym->scoped == FALSE ) {

	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN4@SymLookupL
	test	BYTE PTR [rax+40], 4
	jne	SHORT $LN4@SymLookupL

; 374  :         /* if the label was defined due to a FORWARD reference,
; 375  :          * its scope is to be changed from global to local.
; 376  :          */
; 377  :         /* remove the label from the global hash table */
; 378  :         *gsym = sym->nextitem;

	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR gsym

; 379  :         SymCount--;

	dec	DWORD PTR SymCount
	mov	QWORD PTR [rax], rcx

; 380  :         sym->scoped = TRUE;
; 381  :         /* add the label to the local hash table */
; 382  :         //sym->next = *lsym;
; 383  :         sym->nextitem = NULL;
; 384  :         *lsym = sym;

	mov	rax, QWORD PTR lsym
	or	BYTE PTR [rdx+40], 4
	mov	QWORD PTR [rdx], 0
	mov	QWORD PTR [rax], rdx

; 385  :         DebugMsg1(("SymLookupLocal(%s): label moved into %s's local namespace\n", sym->name, CurrProc->sym.name ));
; 386  :     }
; 387  : 
; 388  :     DebugMsg1(("SymLookupLocal(%s): found, state=%u, defined=%u\n", name, sym->state, sym->isdefined));
; 389  :     return( sym );

	mov	rax, rdx
$LN4@SymLookupL:

; 390  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
SymLookupLocal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
name$ = 48
SymLookup PROC

; 339  : {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 340  :     struct asym      *sym;
; 341  : 
; 342  :     sym = SymFind( name );

	call	SymFind

; 343  :     if( sym == NULL ) {

	test	rax, rax
	jne	SHORT $LN4@SymLookup

; 344  :         sym = SymAlloc( name );

	mov	rcx, rbx
	call	SymAlloc

; 345  :         DebugMsg1(("SymLookup(%s): created new symbol, CurrProc=%s\n", name, CurrProc ? CurrProc->sym.name : "NULL" ));
; 346  :         //sym->next = *gsym;
; 347  :         *gsym = sym;

	mov	rcx, QWORD PTR gsym

; 348  :         ++SymCount;

	inc	DWORD PTR SymCount
	mov	QWORD PTR [rcx], rax
$LN4@SymLookup:

; 349  :     }
; 350  : 
; 351  :     DebugMsg1(("SymLookup(%s): found, state=%u, defined=%u\n", name, sym->state, sym->isdefined));
; 352  : 
; 353  :     return( sym );
; 354  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
SymLookup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 48
name$ = 56
SymAddLocal PROC

; 483  : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	rbx, rdx

; 484  :     struct asym *sym2;
; 485  :     /* v2.10: ignore symbols with state SYM_UNDEFINED! */
; 486  :     //if( SymFind( name ) ) {
; 487  :     if( ( sym2 = SymFind( name ) ) && sym2->state != SYM_UNDEFINED ) {

	mov	rcx, rdx
	call	SymFind
	test	rax, rax
	je	SHORT $LN2@SymAddLoca
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN2@SymAddLoca

; 488  :         /* shouldn't happen */
; 489  :         EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	rdx, rbx
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 490  :         return( NULL );

	xor	eax, eax

; 500  :     return( sym );
; 501  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@SymAddLoca:

; 491  :     }
; 492  : #if FASTMEM==0
; 493  :     if ( sym->name_size ) LclFree( sym->name );
; 494  : #endif
; 495  :     sym->name_size = strlen( name );

	or	rax, -1
$LL4@SymAddLoca:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL4@SymAddLoca

; 496  :     sym->name = LclAlloc( sym->name_size + 1 );

	movzx	ecx, al
	inc	ecx
	mov	BYTE PTR [rdi+72], al
	movsxd	rcx, ecx
	call	LclAlloc

; 497  :     memcpy( sym->name, name, sym->name_size + 1 );

	movzx	ecx, BYTE PTR [rdi+72]
	mov	rdx, rbx
	inc	ecx
	mov	QWORD PTR [rdi+8], rax
	movsxd	r8, ecx
	mov	rcx, rax
	call	memcpy

; 498  :     sym->nextitem = NULL;
; 499  :     *lsym = sym;

	mov	rax, QWORD PTR lsym

; 500  :     return( sym );
; 501  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi], 0
	mov	QWORD PTR [rax], rdi
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SymAddLocal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 48
SymAddGlobal PROC

; 510  : {

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 511  :     if( SymFind( sym->name ) ) {

	mov	rcx, QWORD PTR [rcx+8]
	call	SymFind
	test	rax, rax
	je	SHORT $LN2@SymAddGlob

; 512  :         EmitErr( SYMBOL_ALREADY_DEFINED, sym->name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 513  :         return( NULL );

	xor	eax, eax

; 519  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@SymAddGlob:

; 514  :     }
; 515  :     sym->nextitem = NULL;
; 516  :     *gsym = sym;

	mov	rax, QWORD PTR gsym

; 517  :     SymCount++;

	inc	DWORD PTR SymCount
	mov	QWORD PTR [rbx], 0
	mov	QWORD PTR [rax], rbx

; 518  :     return( sym );

	mov	rax, rbx

; 519  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
SymAddGlobal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
name$ = 48
SymLCreate PROC

; 543  : {

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 544  :     struct asym *sym;
; 545  : 
; 546  :     /* v2.10: ignore symbols with state SYM_UNDEFINED */
; 547  :     //if( SymFind( name ) ) {
; 548  :     if( ( sym = SymFindDeclare( name ) ) && sym->state != SYM_UNDEFINED ) {

	call	SymFindDeclare
	test	rax, rax
	je	SHORT $LN2@SymLCreate
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN2@SymLCreate

; 549  :         EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	rdx, rbx
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 550  :         return( NULL );

	xor	eax, eax

; 554  :     return( sym );
; 555  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@SymLCreate:

; 551  :     }
; 552  :     sym = SymAlloc( name );

	mov	rcx, rbx
	call	SymAlloc

; 553  :     *lsym = sym;

	mov	rcx, QWORD PTR lsym
	mov	QWORD PTR [rcx], rax

; 554  :     return( sym );
; 555  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
SymLCreate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
name$ = 48
SymCreate PROC

; 524  : {

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 525  :     struct asym *sym;
; 526  : 
; 527  :     if( SymFind( name ) ) {

	call	SymFind
	test	rax, rax
	je	SHORT $LN2@SymCreate

; 528  :         EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	rdx, rbx
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 529  :         return( NULL );

	xor	eax, eax

; 534  :     return( sym );
; 535  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@SymCreate:

; 530  :     }
; 531  :     sym = SymAlloc( name );

	mov	rcx, rbx
	call	SymAlloc

; 532  :     *gsym = sym;

	mov	rcx, QWORD PTR gsym

; 533  :     SymCount++;

	inc	DWORD PTR SymCount
	mov	QWORD PTR [rcx], rax

; 534  :     return( sym );
; 535  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
SymCreate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 8
SymFree	PROC

; 458  :     //DebugMsg(("SymFree: free %X, name=%s, state=%X\n", sym, sym->name, sym->state));
; 459  :     free_ext( sym );

	jmp	free_ext
SymFree	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
name$ = 48
SymAlloc PROC

; 229  : {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx

; 230  :     int len = strlen( name );

	or	rbx, -1
$LL6@SymAlloc:
	inc	rbx
	cmp	BYTE PTR [rcx+rbx], 0
	jne	SHORT $LL6@SymAlloc

; 231  :     struct asym *sym;
; 232  : 
; 233  :     sym = LclAlloc( sizeof( struct dsym ) );

	mov	ecx, 120				; 00000078H
	call	LclAlloc

; 234  :     memset( sym, 0, sizeof( struct dsym ) );

	xor	edx, edx
	mov	rcx, rax
	mov	rdi, rax
	lea	r8d, QWORD PTR [rdx+120]
	call	memset

; 235  : #if 1
; 236  :     /* the tokenizer ensures that identifiers are within limits, so
; 237  :      * this check probably is redundant */
; 238  :     if( len > MAX_ID_LEN ) {

	cmp	ebx, 247				; 000000f7H
	jle	SHORT $LN2@SymAlloc

; 239  :         EmitError( IDENTIFIER_TOO_LONG );

	mov	ecx, 70					; 00000046H
	call	EmitError

; 240  :         len = MAX_ID_LEN;

	mov	ebx, 247				; 000000f7H
$LN2@SymAlloc:

; 241  :     }
; 242  : #endif
; 243  :     sym->name_size = len;

	mov	BYTE PTR [rdi+72], bl

; 244  :     sym->list = ModuleInfo.cref;

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 12
	xor	al, BYTE PTR [rdi+41]
	and	al, 1

; 245  :     sym->mem_type = MT_EMPTY;

	mov	DWORD PTR [rdi+36], 192			; 000000c0H
	xor	BYTE PTR [rdi+41], al

; 246  :     if ( len ) {

	test	ebx, ebx
	je	SHORT $LN3@SymAlloc

; 247  :         sym->name = LclAlloc( len + 1 );

	lea	eax, DWORD PTR [rbx+1]
	movsxd	rcx, eax
	call	LclAlloc

; 248  :         memcpy( sym->name, name, len );

	movsxd	rbx, ebx
	mov	rdx, rsi
	mov	r8, rbx
	mov	QWORD PTR [rdi+8], rax
	mov	rcx, rax
	call	memcpy

; 249  :         sym->name[len] = NULLC;

	mov	rax, QWORD PTR [rdi+8]
	mov	BYTE PTR [rbx+rax], 0

; 250  :     } else
; 251  :         sym->name = "";
; 252  :     return( sym );

	mov	rax, rdi

; 253  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@SymAlloc:
	mov	rbx, QWORD PTR [rsp+48]
	lea	rax, OFFSET FLAT:$SG11131
	mov	rsi, QWORD PTR [rsp+56]
	mov	QWORD PTR [rdi+8], rax
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SymAlloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rdi, rcx

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	call	__local_stdio_printf_options
	mov	r9, rbx
	mov	QWORD PTR [rsp+40], rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], 0
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf
	test	eax, eax
	cmovs	eax, ebx

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbx
	mov	r9, rsi
	or	rbx, -1
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, rbx
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vsprintf

; 1459 :     #pragma warning(pop)
; 1460 : }

	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ebx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_Locale$ = 88
_ArgList$ = 96
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	r9, rdi
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR _ArgList$[rsp]
	or	rcx, 1
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rbx
	call	__stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;
; 1391 : }

	mov	rbx, QWORD PTR [rsp+64]
	or	ecx, -1
	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ecx
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\time.h
;	COMDAT time
_TEXT	SEGMENT
_Time$ = 8
time	PROC						; COMDAT

; 535  :             return _time64(_Time);

	jmp	_time64
time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\time.h
;	COMDAT localtime
_TEXT	SEGMENT
_Time$ = 8
localtime PROC						; COMDAT

; 509  :             #pragma warning(push)
; 510  :             #pragma warning(disable: 4996)
; 511  :             return _localtime64(_Time);

	jmp	_localtime64
localtime ENDP
_TEXT	ENDS
END
