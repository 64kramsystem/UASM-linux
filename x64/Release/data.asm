; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG11452 DB	01H DUP (?)
$SG11455 DB	01H DUP (?)
$SG11458 DB	01H DUP (?)
$SG11500 DB	01H DUP (?)
$SG11504 DB	01H DUP (?)
$SG11511 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG11240 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG11402 DB	'(', 00H
	ORG $+2
$SG11412 DB	')', 00H
	ORG $+2
$SG11422 DB	'BSS', 00H
$SG11423 DB	'AT', 00H
_DATA	ENDS
PUBLIC	data_dir
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	FillDataBytes:PROC
EXTRN	OutputBytes:PROC
EXTRN	SymLookup:PROC
EXTRN	SizeFromMemtype:PROC
EXTRN	sym_remove_table:PROC
EXTRN	sym_ext2int:PROC
EXTRN	set_frame:PROC
EXTRN	set_frame2:PROC
EXTRN	EvalOperand:PROC
EXTRN	EmitConstError:PROC
EXTRN	CreateFixup:PROC
EXTRN	BackPatch:PROC
EXTRN	LstWrite:PROC
EXTRN	SetSymSegOfs:PROC
EXTRN	GetSymOfssize:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	SetCurrOffset:PROC
EXTRN	CreateStructField:PROC
EXTRN	UpdateStructSize:PROC
EXTRN	StoreLine:PROC
EXTRN	Tokenize:PROC
EXTRN	ExpandLiterals:PROC
EXTRN	omf_OutSelect:PROC
EXTRN	atofloat:PROC
EXTRN	segm_override:PROC
EXTRN	memset:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	write_to_file:BYTE
EXTRN	SymTables:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	CurrStruct:QWORD
EXTRN	StoreState:BYTE
EXTRN	UseSavedState:BYTE
EXTRN	SegOverride:QWORD
EXTRN	szNull:BYTE
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$data_item DD imagerel data_item
	DD	imagerel data_item+3468
	DD	imagerel $unwind$data_item
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InitializeArray DD imagerel InitializeArray
	DD	imagerel InitializeArray+668
	DD	imagerel $unwind$InitializeArray
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InitStructuredVar DD imagerel InitStructuredVar
	DD	imagerel InitStructuredVar+185
	DD	imagerel $unwind$InitStructuredVar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$InitStructuredVar DD imagerel InitStructuredVar+185
	DD	imagerel InitStructuredVar+589
	DD	imagerel $chain$0$InitStructuredVar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$InitStructuredVar DD imagerel InitStructuredVar+589
	DD	imagerel InitStructuredVar+629
	DD	imagerel $chain$1$InitStructuredVar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$InitStructuredVar DD imagerel InitStructuredVar+629
	DD	imagerel InitStructuredVar+1284
	DD	imagerel $chain$2$InitStructuredVar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$InitStructuredVar DD imagerel InitStructuredVar+1284
	DD	imagerel InitStructuredVar+1435
	DD	imagerel $chain$3$InitStructuredVar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$output_float DD imagerel output_float
	DD	imagerel output_float+147
	DD	imagerel $unwind$output_float
pdata	ENDS
pdata	SEGMENT
$pdata$data_dir DD imagerel $LN68
	DD	imagerel $LN68+126
	DD	imagerel $unwind$data_dir
$pdata$1$data_dir DD imagerel $LN68+126
	DD	imagerel $LN68+404
	DD	imagerel $chain$1$data_dir
$pdata$3$data_dir DD imagerel $LN68+404
	DD	imagerel $LN68+924
	DD	imagerel $chain$3$data_dir
$pdata$4$data_dir DD imagerel $LN68+924
	DD	imagerel $LN68+944
	DD	imagerel $chain$4$data_dir
$pdata$6$data_dir DD imagerel $LN68+944
	DD	imagerel $LN68+1265
	DD	imagerel $chain$6$data_dir
$pdata$7$data_dir DD imagerel $LN68+1265
	DD	imagerel $LN68+1284
	DD	imagerel $chain$7$data_dir
pdata	ENDS
xdata	SEGMENT
$unwind$data_dir DD 050a01H
	DD	0f006c20aH
	DD	050037004H
	DD	03002H
$chain$1$data_dir DD 041021H
	DD	0bd410H
	DD	0cc405H
	DD	imagerel $LN68
	DD	imagerel $LN68+126
	DD	imagerel $unwind$data_dir
$chain$3$data_dir DD 042321H
	DD	0ae423H
	DD	0136408H
	DD	imagerel $LN68+126
	DD	imagerel $LN68+404
	DD	imagerel $chain$1$data_dir
$chain$4$data_dir DD 021H
	DD	imagerel $LN68+126
	DD	imagerel $LN68+404
	DD	imagerel $chain$1$data_dir
$chain$6$data_dir DD 080021H
	DD	0ae400H
	DD	0bd400H
	DD	0cc400H
	DD	0136400H
	DD	imagerel $LN68
	DD	imagerel $LN68+126
	DD	imagerel $unwind$data_dir
$chain$7$data_dir DD 040021H
	DD	0bd400H
	DD	0cc400H
	DD	imagerel $LN68
	DD	imagerel $LN68+126
	DD	imagerel $unwind$data_dir
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$output_float DD 040a01H
	DD	0c340aH
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$InitStructuredVar DD 021H
	DD	imagerel InitStructuredVar
	DD	imagerel InitStructuredVar+185
	DD	imagerel $unwind$InitStructuredVar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$InitStructuredVar DD 020021H
	DD	0237400H
	DD	imagerel InitStructuredVar
	DD	imagerel InitStructuredVar+185
	DD	imagerel $unwind$InitStructuredVar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$InitStructuredVar DD 021H
	DD	imagerel InitStructuredVar
	DD	imagerel InitStructuredVar+185
	DD	imagerel $unwind$InitStructuredVar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$InitStructuredVar DD 020821H
	DD	0237408H
	DD	imagerel InitStructuredVar
	DD	imagerel InitStructuredVar+185
	DD	imagerel $unwind$InitStructuredVar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$InitStructuredVar DD 051401H
	DD	01c0114H
	DD	030076008H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$InitializeArray DD 0a1401H
	DD	0143414H
	DD	0f0109214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$data_item DD 072301H
	DD	0253423H
	DD	01e0123H
	DD	060167017H
	DD	05015H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\data.c
_TEXT	SEGMENT
old_offset$ = 144
currofs$ = 144
i$ = 144
tokenarray$ = 152
type_sym$ = 160
tv648 = 168
data_dir PROC

; 1135 : {

$LN68:
	push	rbx
	push	rbp
	push	rdi
	push	r15
	sub	rsp, 104				; 00000068H

; 1136 :     uint_32             no_of_bytes;
; 1137 :     struct asym         *sym = NULL;

	xor	r10d, r10d
	movsxd	r15, ecx
	mov	rdi, r8
	mov	rbp, rdx

; 1138 :     uint_32             old_offset;
; 1139 :     uint_32             currofs; /* for LST output */
; 1140 :     enum memtype        mem_type;
; 1141 :     bool                is_float = FALSE;

	xor	r8b, r8b
	mov	ebx, r10d
	mov	DWORD PTR tv648[rsp], r8d

; 1142 :     int                 idx;
; 1143 :     char                *name;
; 1144 : 
; 1145 :     DebugMsg1(("data_dir( i=%u, type=%s ) enter\n", i, type_sym ? type_sym->name : "NULL" ));
; 1146 : 
; 1147 :     /* v2.05: the previous test in parser.c wasn't fool-proved */
; 1148 :     if ( i > 1 && ModuleInfo.m510 == FALSE ) {

	cmp	r15d, 1
	jle	SHORT $LN4@data_dir
	test	BYTE PTR ModuleInfo+408, 64		; 00000040H
	jne	SHORT $LN4@data_dir

; 1149 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, r15
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbp+8]

; 1374 : }

	add	rsp, 104				; 00000068H
	pop	r15
	pop	rdi
	pop	rbp
	pop	rbx

; 1149 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jmp	EmitErr
$LN4@data_dir:

; 1150 :     }
; 1151 :     if( tokenarray[i+1].token == T_FINAL ) {

	lea	rax, QWORD PTR [r15+1]
	mov	rcx, r15
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], bl
	jne	SHORT $LN5@data_dir

; 1152 :         DebugMsg(("data_dir: missing initializer\n"));
; 1153 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	shl	rcx, 5
	mov	rdx, QWORD PTR [rcx+rdx+24]
	mov	ecx, 209				; 000000d1H

; 1374 : }

	add	rsp, 104				; 00000068H
	pop	r15
	pop	rdi
	pop	rbp
	pop	rbx

; 1152 :         DebugMsg(("data_dir: missing initializer\n"));
; 1153 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	jmp	EmitErr
$LN5@data_dir:
	mov	QWORD PTR [rsp+96], r12

; 1154 :     }
; 1155 : 
; 1156 :     /* set values for mem_type and no_of_bytes */
; 1157 :     if ( type_sym ) {

	mov	r11d, 1
	mov	QWORD PTR [rsp+88], r13
	test	rdi, rdi
	je	SHORT $LN6@data_dir

; 1158 :         /* if the parser found a TYPE id, type_sym is != NULL */
; 1159 :         //DebugMsg1(("data_dir: arbitrary type %s, calling SymSearch\n", type_sym->name ));
; 1160 :         //type_sym = SymSearch( tokenarray[i].string_ptr );
; 1161 :         mem_type = MT_TYPE;
; 1162 :         if ( type_sym->typekind != TYPE_TYPEDEF &&

	cmp	BYTE PTR [rdi+66], 3
	mov	r12d, 196				; 000000c4H
	je	SHORT $LN8@data_dir
	cmp	DWORD PTR [rdi+56], ebx
	je	SHORT $LN9@data_dir
	mov	rax, QWORD PTR [rdi+96]
	test	BYTE PTR [rax+17], 4
	je	SHORT $LN8@data_dir
$LN9@data_dir:

; 1163 :              ( type_sym->total_size == 0 || ((struct dsym *)type_sym)->e.structinfo->OrgInside == TRUE ) ) {
; 1164 :             return( EmitError( STRUCT_CANNOT_BE_INSTANCED ) );

	mov	ecx, 215				; 000000d7H
	call	EmitError
	jmp	$LN62@data_dir
$LN8@data_dir:

; 1165 :         }
; 1166 : 
; 1167 :         /* v2.09: expand literals inside <> or {}.
; 1168 :          * Previously this was done inside InitStructuredVar()
; 1169 :          */
; 1170 : #if FASTPASS
; 1171 :         if ( Parse_Pass == PASS_1 || UseSavedState == FALSE )

	mov	eax, DWORD PTR Parse_Pass
	test	eax, eax
	je	SHORT $LN11@data_dir
	cmp	BYTE PTR UseSavedState, bl
	jne	SHORT $LN10@data_dir
$LN11@data_dir:

; 1172 : #endif
; 1173 :             ExpandLiterals( i+1, tokenarray );

	lea	ecx, DWORD PTR [r15+1]
	call	ExpandLiterals
	mov	eax, DWORD PTR Parse_Pass
	xor	r10d, r10d
$LN10@data_dir:

; 1174 : 
; 1175 :         no_of_bytes = type_sym->total_size;

	mov	r13d, DWORD PTR [rdi+56]

; 1176 :         if ( no_of_bytes == 0 ) {

	test	r13d, r13d
	jne	$LN19@data_dir

; 1177 :             DebugMsg(("data_dir: size of arbitrary type is 0!\n"));
; 1178 :             /* a void type is not valid */
; 1179 :             if ( type_sym->typekind == TYPE_TYPEDEF ) {

	cmp	BYTE PTR [rdi+66], 3
	jne	$LN19@data_dir

; 1180 :                 return( EmitErr( INVALID_TYPE_FOR_DATA_DECLARATION, type_sym->name ) );

	mov	rdx, QWORD PTR [rdi+8]
	mov	ecx, 160				; 000000a0H
	call	EmitErr
	jmp	$LN62@data_dir
$LN6@data_dir:

; 1181 :             }
; 1182 :         }
; 1183 :     } else {
; 1184 :         /* it's either a predefined type or a data directive. For types, the index
; 1185 :          into the simpletype table is in <bytval>, for data directives
; 1186 :          the index is found in <sflags>.
; 1187 :          * v2.06: SimpleType is obsolete. Use token index directly!
; 1188 :          */
; 1189 : 
; 1190 :         if ( tokenarray[i].token == T_STYPE ) {

	shl	rcx, 5
	lea	r9, OFFSET FLAT:SpecialTable
	add	rdx, rcx
	movzx	eax, BYTE PTR [rdx]
	cmp	al, 6
	jne	SHORT $LN14@data_dir

; 1191 :             //idx = tokenarray[i].bytval;
; 1192 :             idx = tokenarray[i].tokval;

	mov	eax, DWORD PTR [rdx+16]
	jmp	SHORT $LN17@data_dir
$LN14@data_dir:

; 1193 :         } else if ( tokenarray[i].token == T_DIRECTIVE &&

	cmp	al, 3
	jne	$LN16@data_dir
	cmp	BYTE PTR [rdx+1], 8
	jne	$LN16@data_dir

; 1194 :                    ( tokenarray[i].dirtype == DRT_DATADIR )) {
; 1195 :             idx = GetSflagsSp( tokenarray[i].tokval );

	mov	eax, DWORD PTR [rdx+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR [r9+rcx*4+4]
$LN17@data_dir:

; 1198 :         }
; 1199 :         mem_type = GetMemtypeSp( idx );

	cdqe
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	r12d, BYTE PTR [r9+rcx*4+10]

; 1200 :         /* types NEAR[16|32], FAR[16|32] and PROC are invalid here */
; 1201 :         //if ( ( SimpleType[idx].mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS ) {
; 1202 :         if ( ( mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS ) {

	mov	eax, r12d
	and	eax, 192				; 000000c0H
	cmp	al, -128				; ffffffffffffff80H
	jne	SHORT $LN18@data_dir

; 1203 :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN62@data_dir
$LN18@data_dir:

; 1204 :         }
; 1205 :         no_of_bytes = (mem_type & MT_SIZE_MASK) + 1;
; 1206 :         if ( mem_type & MT_FLOAT )

	movzx	eax, r12b
	movzx	r8d, r8b
	mov	r13d, r12d
	and	r13d, 31
	inc	r13d
	and	al, 32					; 00000020H
	mov	eax, DWORD PTR Parse_Pass
	cmovne	r8d, r11d
	mov	DWORD PTR tv648[rsp], r8d
$LN19@data_dir:

; 1207 :             is_float = TRUE;
; 1208 :     }
; 1209 : 
; 1210 :     /* if i == 1, there's a (data) label at pos 0.
; 1211 :      * (note: if -Zm is set, a code label may be at pos 0, and
; 1212 :      * i is 2 then.)
; 1213 :      */
; 1214 :     name = ( ( i == 1 ) ? tokenarray[0].string_ptr : NULL );

	mov	QWORD PTR [rsp+152], rsi
	cmp	r15d, 1
	jne	SHORT $LN54@data_dir
	mov	rsi, QWORD PTR [rbp+8]
	jmp	SHORT $LN55@data_dir
$LN54@data_dir:
	mov	rsi, r10
$LN55@data_dir:

; 1215 : 
; 1216 :     /* in a struct declaration? */
; 1217 :     if( CurrStruct ) {

	cmp	QWORD PTR CurrStruct, rbx
	mov	QWORD PTR [rsp+80], r14
	je	SHORT $LN20@data_dir

; 1218 : 
; 1219 :         /* structure parsing is done in the first pass only */
; 1220 :         if( Parse_Pass == PASS_1 ) {

	test	eax, eax
	jne	SHORT $LN22@data_dir

; 1221 : 
; 1222 :             /* current offset isn't necessarily the fields start offset */
; 1223 :             //currofs = CurrStruct->sym.offset;
; 1224 : 
; 1225 :             if (!(sym = CreateStructField( i, tokenarray, name, mem_type, type_sym, no_of_bytes ))) {

	mov	DWORD PTR [rsp+40], r13d
	mov	r9d, r12d
	mov	r8, rsi
	mov	QWORD PTR [rsp+32], rdi
	mov	rdx, rbp
	mov	ecx, r15d
	call	CreateStructField
	mov	rbx, rax
	test	rax, rax
	je	$LN65@data_dir

; 1226 :                 return ( ERROR );
; 1227 :             }
; 1228 : #if FASTPASS
; 1229 :             if ( StoreState ) FStoreLine(0);

	cmp	BYTE PTR StoreState, 0
	je	SHORT $LN26@data_dir
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN26@data_dir
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
$LN26@data_dir:

; 1230 : #endif
; 1231 :             currofs = sym->offset;

	mov	r14d, DWORD PTR [rbx+16]

; 1232 :             sym->isdata = TRUE; /* 'first_size' is valid */

	or	BYTE PTR [rbx+41], 4

; 1233 :             DebugMsg1(("data_dir: %s, CreateStructField called, ofs=%d\n", sym->name, sym->offset ));
; 1234 :         } else { /* v2.04: else branch added */

	jmp	$LN48@data_dir
$LN22@data_dir:

; 1235 :             sym = &CurrStruct->e.structinfo->tail->sym;

	mov	rax, QWORD PTR CurrStruct
	mov	rcx, QWORD PTR [rax+96]
	mov	rbx, QWORD PTR [rcx+8]

; 1236 :             currofs = sym->offset;
; 1237 :             CurrStruct->e.structinfo->tail = CurrStruct->e.structinfo->tail->next;

	mov	rax, QWORD PTR [rbx+96]
	mov	r14d, DWORD PTR [rbx+16]
	mov	QWORD PTR [rcx+8], rax

; 1238 :         }
; 1239 : 
; 1240 :     } else {

	jmp	$LN48@data_dir
$LN20@data_dir:

; 1241 : 
; 1242 :         if( CurrSeg == NULL ) {

	cmp	QWORD PTR ModuleInfo+432, rbx
	jne	SHORT $LN28@data_dir

; 1243 :             return( EmitError( MUST_BE_IN_SEGMENT_BLOCK ) );

	mov	ecx, 82					; 00000052H
	call	EmitError
	jmp	$LN64@data_dir
$LN28@data_dir:

; 1244 :         }
; 1245 : 
; 1246 :         FStoreLine(0);

	test	eax, eax
	jne	SHORT $LN29@data_dir
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
$LN29@data_dir:

; 1247 : 
; 1248 :         if ( ModuleInfo.CommentDataInCode )

	cmp	BYTE PTR ModuleInfo+423, bl
	je	SHORT $LN31@data_dir

; 1249 :             omf_OutSelect( TRUE );

	mov	cl, 1
	call	omf_OutSelect
$LN31@data_dir:

; 1250 : 
; 1251 :         if ( ModuleInfo.list ) {

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN60@data_dir

; 1252 :             currofs = GetCurrOffset();

	call	GetCurrOffset
	mov	r14d, eax
	jmp	SHORT $LN32@data_dir
$LN60@data_dir:
	mov	r14d, DWORD PTR currofs$[rsp]
$LN32@data_dir:

; 1253 :         }
; 1254 : 
; 1255 :         /* is a label accociated with the data definition? */
; 1256 :         if( name ) {

	test	rsi, rsi
	je	$LN33@data_dir

; 1257 :             /* get/create the label. */
; 1258 :             DebugMsg1(("data_dir: calling SymLookup(%s)\n", name ));
; 1259 :             sym = SymLookup( name );

	mov	rcx, rsi
	call	SymLookup

; 1260 :             /* v2.11: cannot fail */
; 1261 :             //if( sym == NULL ) {
; 1262 :             //    DebugMsg(("data_dir exit, error: invalid label name\n"));
; 1263 :             //    return( ERROR );
; 1264 :             //}
; 1265 : 
; 1266 :             if( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	rbx, rax
	jne	$LN34@data_dir

; 1267 : 
; 1268 :                 if ( sym->state == SYM_EXTERNAL && sym->weak == TRUE && sym->isproc == FALSE ) { /* EXTERNDEF? */

	mov	eax, DWORD PTR [rax+32]
	cmp	eax, 2
	jne	SHORT $LN36@data_dir
	test	BYTE PTR [rbx+47], 8
	je	SHORT $LN36@data_dir
	test	BYTE PTR [rbx+41], 8
	jne	SHORT $LN36@data_dir

; 1269 : 
; 1270 :                     //if ( checktypes( sym, mem_type, type_sym ) == ERROR )
; 1271 :                     //    return( ERROR );
; 1272 :                     /* v2.0: display error and continue! */
; 1273 :                     checktypes( sym, mem_type, type_sym );

	mov	r8, rdi
	mov	edx, r12d
	mov	rcx, rbx
	call	checktypes

; 1274 :                     /* remove the external info */
; 1275 :                     sym_ext2int( sym );

	mov	rcx, rbx
	call	sym_ext2int

; 1276 :                     sym->total_size = 0;

	xor	eax, eax
	mov	DWORD PTR [rbx+56], eax

; 1277 :                     sym->total_length = 0;

	mov	DWORD PTR [rbx+64], eax

; 1278 :                     sym->first_length = 0;

	mov	DWORD PTR [rbx+48], eax
	jmp	SHORT $LN40@data_dir
$LN36@data_dir:

; 1279 : 
; 1280 :                 } else if( sym->state == SYM_UNDEFINED ) {

	test	eax, eax
	jne	SHORT $LN38@data_dir

; 1281 : 
; 1282 :                     sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table

; 1283 :                     sym->state = SYM_INTERNAL;
; 1284 : #if 1
; 1285 :                     /* v2.11: Set the symbol's langtype. It may have been set
; 1286 :                      * by a PUBLIC directive, so take care not to overwrite it.
; 1287 :                      * Problem: Masm doesn't do this - might be a bug.
; 1288 :                      */
; 1289 :                     if ( sym->langtype == LANG_NONE )

	cmp	DWORD PTR [rbx+76], 0
	mov	eax, 1
	mov	DWORD PTR [rbx+32], eax
	jne	SHORT $LN40@data_dir

; 1290 :                         sym->langtype = ModuleInfo.langtype;

	mov	eax, DWORD PTR ModuleInfo+364
	mov	DWORD PTR [rbx+76], eax
$LN40@data_dir:

; 1312 :                 }
; 1313 :                 /* add the label to the linked list attached to curr segment */
; 1314 :                 /* this allows to reduce the number of passes (see Fixup.c) */
; 1315 :                 ((struct dsym *)sym)->next = (struct dsym *)CurrSeg->e.seginfo->label_list;

	mov	rax, QWORD PTR ModuleInfo+432

; 1316 :                 CurrSeg->e.seginfo->label_list = sym;
; 1317 : 
; 1318 :             } else {

	mov	esi, DWORD PTR old_offset$[rsp]
	mov	rcx, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rcx+32]
	mov	QWORD PTR [rbx+104], rax
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	mov	QWORD PTR [rcx+32], rbx
	jmp	$label_defined$69
$LN38@data_dir:

; 1291 : #endif
; 1292 :                 } else if ( sym->state == SYM_INTERNAL) {

	cmp	eax, 1
	jne	SHORT $LN41@data_dir

; 1293 : 
; 1294 :                     /* accept a symbol "redefinition" if addresses and types
; 1295 :                      * do match.
; 1296 :                      */
; 1297 :                     if ( sym->segment != (struct asym *)CurrSeg ||

	mov	rax, QWORD PTR ModuleInfo+432
	cmp	QWORD PTR [rbx+24], rax
	jne	SHORT $LN44@data_dir
	call	GetCurrOffset
	cmp	DWORD PTR [rbx+16], eax
	jne	SHORT $LN44@data_dir

; 1300 :                     }
; 1301 :                     /* check for symbol type conflict */
; 1302 :                     if ( checktypes( sym, mem_type, type_sym ) == ERROR )

	mov	r8, rdi
	mov	edx, r12d
	mov	rcx, rbx
	call	checktypes
	cmp	eax, -1
	je	$LN65@data_dir

; 1303 :                         return( ERROR );
; 1304 :                     /* v2.09: reset size and length ( might have been set by LABEL directive ) */
; 1305 :                     sym->total_size = 0;
; 1306 :                     sym->total_length = 0;
; 1307 :                     goto label_defined; /* don't relink the label */

	mov	esi, DWORD PTR old_offset$[rsp]
	xor	eax, eax
	mov	DWORD PTR [rbx+56], eax
	mov	DWORD PTR [rbx+64], eax
	jmp	SHORT $label_defined$69
$LN44@data_dir:

; 1298 :                         sym->offset != GetCurrOffset() ) {
; 1299 :                         return( EmitErr( SYMBOL_ALREADY_DEFINED, name ) );

	mov	rdx, rsi
	mov	ecx, 56					; 00000038H
$LN66@data_dir:

; 1308 : 
; 1309 :                 } else {
; 1310 :                     DebugMsg(("data_dir(%s): error, symbol redefinition, state=%X\n", sym->name, sym->state ));
; 1311 :                     return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	call	EmitErr
$LN64@data_dir:
	mov	r14, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+152]
$LN62@data_dir:
	mov	r12, QWORD PTR [rsp+96]
	mov	r13, QWORD PTR [rsp+88]

; 1374 : }

	add	rsp, 104				; 00000068H
	pop	r15
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN41@data_dir:

; 1308 : 
; 1309 :                 } else {
; 1310 :                     DebugMsg(("data_dir(%s): error, symbol redefinition, state=%X\n", sym->name, sym->state ));
; 1311 :                     return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 143				; 0000008fH
	jmp	SHORT $LN66@data_dir
$LN34@data_dir:

; 1319 :                 old_offset = sym->offset;

	mov	esi, DWORD PTR [rax+16]
$label_defined$69:

; 1320 :             }
; 1321 :         label_defined:
; 1322 :             SetSymSegOfs( sym );

	mov	rcx, rbx
	call	SetSymSegOfs

; 1323 :             if( Parse_Pass != PASS_1 && sym->offset != old_offset ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN46@data_dir
	cmp	DWORD PTR [rbx+16], esi
	mov	ecx, 1
	movzx	eax, BYTE PTR ModuleInfo+422
	cmovne	eax, ecx
	mov	BYTE PTR ModuleInfo+422, al
$LN46@data_dir:

; 1324 : #ifdef DEBUG_OUT
; 1325 :                 if ( !ModuleInfo.PhaseError )
; 1326 :                     DebugMsg(("data_dir: Phase error, pass %u, sym >%s< first time, new=%X != old=%X\n", Parse_Pass+1, sym->name, sym->offset, old_offset));
; 1327 : #endif
; 1328 :                 ModuleInfo.PhaseError = TRUE;
; 1329 :             }
; 1330 :             sym->isdefined = TRUE;

	or	BYTE PTR [rbx+40], 2

; 1331 :             sym->isdata = TRUE; /* 'first_size' is valid */
; 1332 :             sym->mem_type = mem_type;
; 1333 :             sym->type = type_sym;
; 1334 : 
; 1335 :             /* backpatch for data items? Yes, if the item is defined
; 1336 :              * in a code segment then its offset may change!
; 1337 :              */
; 1338 :             BackPatch( sym );

	mov	rcx, rbx
	or	BYTE PTR [rbx+41], 4
	mov	DWORD PTR [rbx+36], r12d
	mov	QWORD PTR [rbx+80], rdi
	call	BackPatch
$LN33@data_dir:

; 1339 :         }
; 1340 : 
; 1341 :         if ( type_sym ) {

	test	rdi, rdi
	je	SHORT $LN48@data_dir

; 1342 :             while ( type_sym->mem_type == MT_TYPE )

	cmp	DWORD PTR [rdi+36], 196			; 000000c4H
	jne	SHORT $LN3@data_dir
	npad	3
$LL2@data_dir:

; 1343 :                 type_sym = type_sym->type;

	mov	rdi, QWORD PTR [rdi+80]
	cmp	DWORD PTR [rdi+36], 196			; 000000c4H
	je	SHORT $LL2@data_dir
$LN3@data_dir:

; 1344 :             /* if it is just a type alias, skip the arbitrary type */
; 1345 :             if ( type_sym->typekind == TYPE_TYPEDEF )

	cmp	BYTE PTR [rdi+66], 3
	mov	eax, 0
	cmove	rdi, rax
$LN48@data_dir:

; 1346 :                 type_sym = NULL;
; 1347 :         }
; 1348 : 
; 1349 :     }
; 1350 : 
; 1351 :     i++;
; 1352 :     if ( data_item( &i, tokenarray, sym, no_of_bytes, type_sym, 1, CurrStruct != NULL, is_float, TRUE, Token_Count ) == ERROR ) {

	mov	eax, DWORD PTR ModuleInfo+496
	inc	r15d
	cmp	QWORD PTR CurrStruct, 0
	mov	r9d, r13d
	mov	DWORD PTR [rsp+72], eax
	mov	r8, rbx
	mov	eax, DWORD PTR tv648[rsp]
	setne	cl
	mov	BYTE PTR [rsp+64], 1
	mov	rdx, rbp
	mov	BYTE PTR [rsp+56], al
	mov	eax, 1
	mov	BYTE PTR [rsp+48], cl
	lea	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	QWORD PTR [rsp+32], rdi
	mov	DWORD PTR i$[rsp], r15d
	call	data_item
	cmp	eax, -1
	jne	SHORT $LN49@data_dir
$LN65@data_dir:

; 1353 :         DebugMsg(("data_dir: error in data_item()\n"));
; 1354 :         return( ERROR );

	or	eax, -1
	jmp	$LN64@data_dir
$LN49@data_dir:

; 1355 :     }
; 1356 : 
; 1357 :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rbp], 0
	je	SHORT $LN50@data_dir

; 1358 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rax+rbp+24]
	mov	ecx, 209				; 000000d1H
	jmp	$LN66@data_dir
$LN50@data_dir:

; 1359 :     }
; 1360 : 
; 1361 :     /* v2.06: update struct size after ALL items have been processed */
; 1362 :     if ( CurrStruct )

	mov	rax, QWORD PTR CurrStruct
	test	rax, rax
	je	SHORT $LN51@data_dir

; 1363 :         UpdateStructSize( sym );

	mov	rcx, rbx
	call	UpdateStructSize
	mov	rax, QWORD PTR CurrStruct
$LN51@data_dir:

; 1364 : 
; 1365 :     if ( ModuleInfo.list )

	test	DWORD PTR ModuleInfo+408, 2048		; 00000800H
	je	SHORT $LN52@data_dir

; 1366 :         LstWrite( CurrStruct ? LSTTYPE_STRUCT : LSTTYPE_DATA, currofs, sym );

	neg	rax
	mov	r8, rbx
	mov	edx, r14d
	sbb	ecx, ecx
	and	ecx, 6
	call	LstWrite
$LN52@data_dir:

; 1367 : 
; 1368 :     DebugMsg1(("data_dir: exit, no error, label=%s, is_array=%u Curr%s.ofs=%X\n",
; 1369 :                sym ? sym->name : "NULL",
; 1370 :                sym ? sym->isarray : 0,
; 1371 :                CurrStruct ? "Struct" : "Seg",
; 1372 :                CurrStruct ? CurrStruct->sym.offset : CurrSeg->sym.offset ));
; 1373 :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN64@data_dir
$LN16@data_dir:

; 1196 :         } else {
; 1197 :             return( EmitErr( INVALID_TYPE_FOR_DATA_DECLARATION, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 160				; 000000a0H
	call	EmitErr
	jmp	$LN62@data_dir
data_dir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\data.c
;	COMDAT checktypes
_TEXT	SEGMENT
sym$ = 8
mem_type$ = 16
type_sym$ = 24
checktypes PROC						; COMDAT

; 1100 :     /* for EXTERNDEF, check type changes */
; 1101 :     if ( sym->mem_type != MT_EMPTY ) {

	mov	r9d, DWORD PTR [rcx+36]
	cmp	r9d, 192				; 000000c0H
	je	SHORT $LN7@checktypes

; 1102 :         enum memtype mem_type2 = sym->mem_type;
; 1103 :         const struct asym *tmp;
; 1104 :         /* skip alias types */
; 1105 :         tmp = type_sym;
; 1106 :         while ( mem_type == MT_TYPE ) {

	cmp	edx, 196				; 000000c4H
	jne	SHORT $LN3@checktypes
	npad	11
$LL2@checktypes:

; 1107 :             mem_type = tmp->mem_type;

	mov	edx, DWORD PTR [r8+36]

; 1108 :             tmp = tmp->type;

	mov	r8, QWORD PTR [r8+80]
	cmp	edx, 196				; 000000c4H
	je	SHORT $LL2@checktypes
$LN3@checktypes:

; 1109 :         }
; 1110 :         tmp = sym;

	mov	rax, rcx

; 1111 :         while ( mem_type2 == MT_TYPE ) {

	cmp	r9d, 196				; 000000c4H
	jne	SHORT $LN5@checktypes
	npad	4
$LL4@checktypes:

; 1112 :             mem_type2 = tmp->mem_type;

	mov	r9d, DWORD PTR [rax+36]

; 1113 :             tmp = tmp->type;

	mov	rax, QWORD PTR [rax+80]
	cmp	r9d, 196				; 000000c4H
	je	SHORT $LL4@checktypes
$LN5@checktypes:

; 1114 :         }
; 1115 :         if ( mem_type2 != mem_type ) {

	cmp	r9d, edx
	je	SHORT $LN7@checktypes

; 1116 :             DebugMsg(("checktypes: memtype conflict: %u - %u\n", mem_type2, mem_type ));
; 1117 :             return( EmitErr( SYMBOL_TYPE_CONFLICT, sym->name ) );

	mov	rdx, QWORD PTR [rcx+8]
	mov	ecx, 136				; 00000088H
	jmp	EmitErr
$LN7@checktypes:

; 1118 :         }
; 1119 :     }
; 1120 :     return( NOT_ERROR );

	xor	eax, eax

; 1121 : }

	ret	0
checktypes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\data.c
;	COMDAT output_float
_TEXT	SEGMENT
buffer$ = 48
opnd$ = 96
size$ = 104
output_float PROC					; COMDAT

; 422  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rbx, rcx
	mov	edi, edx

; 423  :     /* v2.07: buffer extended to max size of a data item (=32).
; 424  :      * test case: XMMWORD REAL10 ptr 1.0
; 425  :      */
; 426  :     //char buffer[12];
; 427  :     char buffer[32];
; 428  : 
; 429  :     if ( opnd->mem_type != MT_EMPTY ) {

	mov	ecx, DWORD PTR [rcx+64]
	cmp	ecx, 192				; 000000c0H
	je	SHORT $LN2@output_flo

; 430  :         int i;
; 431  :         memset( buffer, 0, sizeof( buffer ) );

	xor	eax, eax

; 432  :         i = SizeFromMemtype( opnd->mem_type, USE_EMPTY, NULL );

	xor	r8d, r8d
	mov	edx, 254				; 000000feH
	mov	QWORD PTR buffer$[rsp], rax
	mov	QWORD PTR buffer$[rsp+8], rax
	mov	QWORD PTR buffer$[rsp+16], rax
	mov	QWORD PTR buffer$[rsp+24], rax
	call	SizeFromMemtype
	mov	r8d, eax

; 433  :         if ( i > size )

	cmp	eax, edi
	jbe	SHORT $LN4@output_flo

; 434  :             EmitErr( INITIALIZER_OUT_OF_RANGE );

	mov	ecx, 55					; 00000037H
	call	EmitErr
	jmp	SHORT $LN3@output_flo
$LN2@output_flo:

; 435  :         else {
; 436  :             atofloat( buffer, opnd->float_tok->string_ptr, i , opnd->negative, opnd->float_tok->floattype );
; 437  :         }
; 438  :     } else {
; 439  :         atofloat( buffer, opnd->float_tok->string_ptr, size, opnd->negative, opnd->float_tok->floattype );

	mov	r8d, edi
$LN4@output_flo:
	mov	rdx, QWORD PTR [rbx+16]
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r9d, DWORD PTR [rbx+72]
	shr	r9d, 5
	and	r9b, 1
	movzx	eax, BYTE PTR [rdx+1]
	mov	rdx, QWORD PTR [rdx+8]
	mov	BYTE PTR [rsp+32], al
	call	atofloat
$LN3@output_flo:

; 440  :     }
; 441  :     OutputDataBytes( buffer, size );

	xor	r8d, r8d
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	edx, edi
	call	OutputBytes

; 442  :     return;
; 443  : }

	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
output_float ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\data.c
;	COMDAT little_endian
_TEXT	SEGMENT
src$ = 8
len$ = 16
little_endian PROC					; COMDAT

; 406  :     /* v2.06: input and output buffer must be different! */
; 407  :     char *dst = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	r9, rax

; 408  : 
; 409  :     for( ; len > 1; dst++, src++, len-- ) {

	cmp	edx, 1
	jbe	SHORT $LN3@little_end
	npad	1
$LL4@little_end:

; 410  :         len--;

	dec	edx

; 411  :         *dst = *(src + len);

	movzx	eax, BYTE PTR [rdx+rcx]
	mov	BYTE PTR [r9], al

; 412  :         *(dst + len) = *src;

	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	mov	BYTE PTR [rdx+r9], al
	inc	r9
	dec	edx
	cmp	edx, 1
	ja	SHORT $LL4@little_end

; 408  : 
; 409  :     for( ; len > 1; dst++, src++, len-- ) {

	mov	rax, QWORD PTR ModuleInfo+488
$LN3@little_end:

; 413  :     }
; 414  :     if ( len )

	test	edx, edx
	je	SHORT $LN11@little_end

; 415  :         *dst = *src;

	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [r9], al

; 416  : 
; 417  :     return( StringBufferEnd );

	mov	rax, QWORD PTR ModuleInfo+488
$LN11@little_end:

; 418  : }

	ret	0
little_endian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\data.c
;	COMDAT InitStructuredVar
_TEXT	SEGMENT
no_of_bytes$1$ = 80
j$1 = 80
j$2 = 84
old_tokencount$1$ = 88
dwRecInit$ = 96
old_stringbufferend$1$ = 104
opndx$ = 112
is_record_set$1$ = 256
j$3 = 256
is_record_set$ = 256
index$ = 256
i$ = 264
tokenarray$ = 264
symtype$ = 272
embedded$ = 280
InitStructuredVar PROC					; COMDAT

; 190  : {

	mov	QWORD PTR [rsp+24], r8
	push	rbp
	push	rbx
	push	rsi
	lea	rbp, QWORD PTR [rsp-71]
	sub	rsp, 224				; 000000e0H

; 191  :     //char            *ptr;
; 192  :     struct sfield   *f;
; 193  :     int_32          nextofs;
; 194  :     int             i;
; 195  :     int             old_tokencount = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	r11, r8
	mov	DWORD PTR old_tokencount$1$[rbp-153], eax
	mov	rsi, rdx

; 196  :     char            *old_stringbufferend = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488

; 197  :     int             lvl;
; 198  : #if AMD64_SUPPORT
; 199  :     uint_64         dwRecInit;
; 200  : #else
; 201  :     uint_32         dwRecInit;
; 202  : #endif
; 203  :     bool            is_record_set;
; 204  :     struct expr     opndx;
; 205  :     //char            line[MAX_LINE_LEN];
; 206  : 
; 207  :     DebugMsg1(("InitStructuredVar(%s) enter, total_size=%" I32_SPEC "u, init=>%s<, embedded=%s, alignm=%u\n",
; 208  :               symtype->sym.name, symtype->sym.total_size, tokenarray[index].string_ptr, embedded ? embedded->name : "NULL", symtype->e.structinfo->alignment ));
; 209  : 
; 210  :     /**/myassert( symtype->sym.state == SYM_TYPE && symtype->sym.typekind != TYPE_TYPEDEF );
; 211  : 
; 212  :     if ( tokenarray[index].token == T_STRING ) {

	mov	ebx, 1
	mov	QWORD PTR old_stringbufferend$1$[rbp-153], rax
	movsxd	rax, ecx
	shl	rax, 5
	lea	rcx, QWORD PTR [rax+rdx]
	movzx	eax, BYTE PTR [rax+rdx]
	cmp	al, 9
	jne	SHORT $LN12@InitStruct

; 213  :         /* v2.08: no special handling of {}-literals anymore */
; 214  :         if ( tokenarray[index].string_delim != '<' &&

	movzx	eax, BYTE PTR [rcx+1]
	cmp	al, 60					; 0000003cH
	je	SHORT $LN14@InitStruct
	cmp	al, 123					; 0000007bH
	je	SHORT $LN14@InitStruct

; 215  :             tokenarray[index].string_delim != '{' ) {
; 216  :             return( EmitError( MISSING_ANGLE_BRACKET_OR_BRACE_IN_LITERAL ) );

	mov	ecx, 216				; 000000d8H
	call	EmitError

; 397  : }

	add	rsp, 224				; 000000e0H
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN14@InitStruct:

; 217  :         }
; 218  :         i = Token_Count + 1;

	mov	edx, DWORD PTR ModuleInfo+496

; 219  :         //strcpy( line, tokenarray[index].string_ptr );
; 220  :         Token_Count = Tokenize( tokenarray[index].string_ptr, i, tokenarray, TOK_RESCAN );

	mov	r9d, ebx
	mov	rcx, QWORD PTR [rcx+8]
	inc	edx
	mov	r8, rsi
	mov	DWORD PTR i$[rbp-153], edx
	call	Tokenize

; 221  :         /* once Token_Count has been modified, don't exit without
; 222  :          * restoring this value!
; 223  :          */
; 224  :         index++;

	mov	r10d, DWORD PTR i$[rbp-153]
	mov	r11, QWORD PTR symtype$[rbp-153]
	mov	DWORD PTR ModuleInfo+496, eax
	jmp	SHORT $LN16@InitStruct
$LN12@InitStruct:

; 225  : 
; 226  :     } else if ( embedded &&

	test	r9, r9
	je	$LN71@InitStruct
	cmp	al, 44					; 0000002cH
	je	SHORT $LN17@InitStruct
	test	al, al
	je	SHORT $LN17@InitStruct

; 230  :     } else {
; 231  :         return( EmitErr( INITIALIZER_MUST_BE_A_STRING_OR_SINGLE_ITEM, embedded ? embedded->name : "" ) );

	mov	rdx, QWORD PTR [r9+8]
	jmp	$LN72@InitStruct
$LN17@InitStruct:

; 227  :                 ( tokenarray[index].token == T_COMMA ||
; 228  :                  tokenarray[index].token == T_FINAL)) {
; 229  :         i = Token_Count;

	mov	r10d, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rbp-153], r10d
$LN16@InitStruct:

; 232  :     }
; 233  :     if ( symtype->sym.typekind == TYPE_RECORD ) {

	xor	r8d, r8d
	mov	QWORD PTR [rsp+280], rdi
	cmp	BYTE PTR [r11+66], 4
	jne	SHORT $LN272@InitStruct

; 234  :         dwRecInit = 0;

	mov	QWORD PTR dwRecInit$[rbp-153], r8

; 235  :         is_record_set = FALSE;

	xor	dl, dl
	jmp	SHORT $LN283@InitStruct
$LN272@InitStruct:
	movzx	edx, BYTE PTR is_record_set$[rbp-153]
$LN283@InitStruct:

; 236  :     }
; 237  : 
; 238  :     /* scan the STRUCT/UNION/RECORD's members */
; 239  :     for( f = symtype->e.structinfo->head; f != NULL; f = f->next ) {

	mov	rax, QWORD PTR [r11+96]
	mov	BYTE PTR is_record_set$1$[rbp-153], dl
	mov	rdi, QWORD PTR [rax]
	test	rdi, rdi
	je	$LN278@InitStruct
	npad	9
$LL4@InitStruct:

; 240  : 
; 241  :         DebugMsg1(("InitStructuredVar(%s) field=%s ofs=%" I32_SPEC "u total_size=%" I32_SPEC "u total_len=%" I32_SPEC "u value=>%s< >%s<\n",
; 242  :                   symtype->sym.name,
; 243  :                   f->sym.name,
; 244  :                   f->sym.offset,
; 245  :                   f->sym.total_size,
; 246  :                   f->sym.total_length,
; 247  :                   //f->initializer ? f->initializer : "NULL",
; 248  :                   f->ivalue, tokenarray[i].tokpos ));
; 249  : 
; 250  :         /* is it a RECORD field? */
; 251  :         if ( f->sym.mem_type == MT_BITS ) {

	mov	r9d, DWORD PTR [rdi+36]
	cmp	r9d, 193				; 000000c1H
	jne	$LN19@InitStruct

; 252  :             if ( tokenarray[i].token == T_COMMA || tokenarray[i].token == T_FINAL ) {

	movsxd	rax, r10d
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+rsi]
	cmp	cl, 44					; 0000002cH
	je	SHORT $LN23@InitStruct
	test	cl, cl
	je	SHORT $LN23@InitStruct

; 262  :                 }
; 263  :             } else {
; 264  :                 EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 );

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	rcx, QWORD PTR i$[rbp-153]

; 265  :                 is_record_set = TRUE;

	jmp	SHORT $LN284@InitStruct
$LN23@InitStruct:

; 253  :                 if ( f->ivalue[0] ) {

	cmp	BYTE PTR [rdi+104], 0
	lea	rcx, QWORD PTR [rdi+104]
	je	SHORT $LN24@InitStruct

; 254  :                     int j = Token_Count + 1;

	mov	edx, DWORD PTR ModuleInfo+496

; 255  :                     int max_item = Tokenize( f->ivalue, j, tokenarray, TOK_RESCAN );

	mov	r9d, ebx
	inc	edx
	mov	r8, rsi
	mov	DWORD PTR j$3[rbp-153], edx
	call	Tokenize

; 256  :                     EvalOperand( &j, tokenarray, max_item, &opndx, 0 );

	mov	r8d, eax
	lea	rcx, QWORD PTR j$3[rbp-153]
$LN284@InitStruct:
	lea	r9, QWORD PTR opndx$[rbp-153]
	mov	BYTE PTR [rsp+32], 0
	mov	rdx, rsi
	call	EvalOperand

; 266  :             }
; 267  :             if ( opndx.kind != EXPR_CONST || opndx.quoted_string != NULL )

	cmp	DWORD PTR opndx$[rbp-93], 0
	mov	BYTE PTR is_record_set$1$[rbp-153], 1
	jne	SHORT $LN27@InitStruct
	cmp	QWORD PTR opndx$[rbp-137], 0
	jne	SHORT $LN27@InitStruct

; 261  :                     opndx.quoted_string = NULL;

	mov	r10d, DWORD PTR i$[rbp-153]
	jmp	SHORT $LN26@InitStruct
$LN27@InitStruct:

; 268  :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError
	mov	r10d, DWORD PTR i$[rbp-153]
	jmp	SHORT $LN26@InitStruct
$LN24@InitStruct:

; 257  :                     is_record_set = TRUE;
; 258  :                 } else {
; 259  :                     opndx.value = 0;

	mov	DWORD PTR opndx$[rbp-153], r8d

; 260  :                     opndx.kind = EXPR_CONST;

	mov	DWORD PTR opndx$[rbp-93], r8d

; 261  :                     opndx.quoted_string = NULL;

	mov	QWORD PTR opndx$[rbp-137], r8
$LN26@InitStruct:

; 269  : 
; 270  :             /* fixme: max bits in 64-bit is 64 - see MAXRECBITS! */
; 271  :             if ( f->sym.total_size < 32 ) {

	mov	ecx, DWORD PTR [rdi+56]
	cmp	ecx, 32					; 00000020H
	jae	SHORT $LN29@InitStruct

; 272  :                 uint_32 dwMax = (1 << f->sym.total_size);

	mov	eax, ebx
	shl	eax, cl

; 273  :                 if ( opndx.value >= dwMax )

	cmp	DWORD PTR opndx$[rbp-153], eax
	jb	SHORT $LN29@InitStruct

; 274  :                     EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, f->sym.name );

	mov	rdx, QWORD PTR [rdi+8]
	mov	ecx, 172				; 000000acH
	call	EmitErr
	mov	r10d, DWORD PTR i$[rbp-153]
$LN29@InitStruct:

; 275  :             }
; 276  : #if AMD64_SUPPORT
; 277  :             dwRecInit |= opndx.llvalue << f->sym.offset;

	mov	ecx, DWORD PTR [rdi+16]
	mov	rax, QWORD PTR opndx$[rbp-153]
	shl	rax, cl
	or	QWORD PTR dwRecInit$[rbp-153], rax
	jmp	$LN51@InitStruct
$LN19@InitStruct:

; 278  : #else
; 279  :             dwRecInit |= opndx.value << f->sym.offset;
; 280  : #endif
; 281  : 
; 282  :         //} else if ( f->init_dir == NULL ) {  /* embedded struct? */
; 283  :         } else if ( f->ivalue[0] == NULLC ) {  /* embedded struct? */

	cmp	BYTE PTR [rdi+104], 0
	jne	SHORT $LN30@InitStruct

; 284  : 
; 285  :             InitStructuredVar( i, tokenarray, (struct dsym *)f->sym.type, &f->sym );

	mov	r8, QWORD PTR [rdi+80]
	mov	r9, rdi
	mov	rdx, rsi
	mov	ecx, r10d
	call	InitStructuredVar

; 286  :             if ( tokenarray[i].token == T_STRING )

	movsxd	r10, DWORD PTR i$[rbp-153]
	mov	rax, r10
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 9
	jne	$LN51@InitStruct

; 287  :                 i++;

	inc	r10d
	mov	DWORD PTR i$[rbp-153], r10d

; 288  : 
; 289  :         } else if ( f->sym.isarray &&

	jmp	$LN51@InitStruct
$LN30@InitStruct:

; 290  :                     tokenarray[i].token != T_FINAL &&

	test	BYTE PTR [rdi+41], 2
	je	SHORT $LN33@InitStruct
	movsxd	rax, r10d
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+rsi]
	test	cl, cl
	je	SHORT $LN33@InitStruct
	cmp	cl, 44					; 0000002cH
	je	SHORT $LN33@InitStruct

; 291  :                     tokenarray[i].token != T_COMMA ) {
; 292  :             if ( ERROR == InitializeArray( f, &i, tokenarray ) )

	mov	r8, rsi
	lea	rdx, QWORD PTR i$[rbp-153]
	mov	rcx, rdi
	call	InitializeArray

; 293  :                 break;
; 294  : 
; 295  :         } else if ( f->sym.total_size == f->sym.total_length &&

	mov	r10d, DWORD PTR i$[rbp-153]
	cmp	eax, -1
	jne	$LN51@InitStruct
	mov	r11, QWORD PTR symtype$[rbp-153]
$LN282@InitStruct:
	movzx	edx, BYTE PTR is_record_set$1$[rbp-153]
$LN278@InitStruct:

; 367  :                 }
; 368  :         }
; 369  :     }  /* end for */
; 370  : 
; 371  :     if ( symtype->sym.typekind == TYPE_RECORD ) {

	cmp	BYTE PTR [r11+66], 4
	mov	rdi, QWORD PTR [rsp+280]
	jne	$LN68@InitStruct

; 372  :         int no_of_bytes;
; 373  :         switch ( symtype->sym.mem_type ) {

	mov	ecx, DWORD PTR [r11+36]
	test	ecx, ecx
	je	$LN63@InitStruct
	sub	ecx, 1
	je	$LN64@InitStruct
	cmp	ecx, 6
	je	$LN65@InitStruct

; 378  : #endif
; 379  :         default: no_of_bytes = 4;

	mov	eax, 4
	jmp	$LN10@InitStruct
$LN33@InitStruct:

; 296  :                    tokenarray[i].token == T_STRING &&
; 297  :                    tokenarray[i].stringlen > 1 &&

	mov	eax, DWORD PTR [rdi+64]
	cmp	DWORD PTR [rdi+56], eax
	jne	SHORT $LN36@InitStruct
	movsxd	rax, r10d
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 9
	jne	SHORT $LN36@InitStruct
	cmp	DWORD PTR [rax+rsi+16], 1
	jbe	SHORT $LN36@InitStruct
	movzx	ecx, BYTE PTR [rax+rsi+1]
	cmp	cl, 34					; 00000022H
	je	SHORT $LN38@InitStruct
	cmp	cl, 39					; 00000027H
	jne	SHORT $LN36@InitStruct
$LN38@InitStruct:

; 298  :                    ( tokenarray[i].string_delim == '"' ||
; 299  :                     tokenarray[i].string_delim == '\'' ) ) {
; 300  :             /* v2.07: it's a byte type, but no array, string initializer must have true length 1 */
; 301  :             EmitError( STRING_OR_TEXT_LITERAL_TOO_LONG );

	mov	ecx, 155				; 0000009bH
	call	EmitError

; 302  :             i++;

	mov	r10d, DWORD PTR i$[rbp-153]
	inc	r10d
	mov	DWORD PTR i$[rbp-153], r10d

; 303  :         } else {

	jmp	$LN51@InitStruct
$LN36@InitStruct:

; 304  :             //struct asym *sym;
; 305  :             uint_32 no_of_bytes = SizeFromMemtype( f->sym.mem_type, USE_EMPTY, f->sym.type );

	mov	r8, QWORD PTR [rdi+80]
	mov	edx, 254				; 000000feH
	mov	ecx, r9d
	call	SizeFromMemtype

; 306  : 
; 307  :             /* v2.09: check for empty <> or {} string if a struct/union is embedded */
; 308  :             //for ( sym = f->sym->type; sym && sym->type; sym = sym->type );
; 309  : 
; 310  :             if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_COMMA ) {

	movsxd	r8, DWORD PTR i$[rbp-153]
	mov	ebx, eax
	mov	rcx, r8
	mov	DWORD PTR no_of_bytes$1$[rbp-153], eax
	shl	rcx, 5
	lea	r9, QWORD PTR [rcx+rsi]
	movzx	ecx, BYTE PTR [rcx+rsi]
	test	cl, cl
	je	$LN41@InitStruct
	cmp	cl, 44					; 0000002cH
	je	$LN41@InitStruct

; 316  :             } else {
; 317  :                 char c;
; 318  :                 int j = i;
; 319  :                 /* ignore commas enclosed in () ( might occur inside DUP argument! ).
; 320  :                  */
; 321  :                 for ( lvl = 0, c = 0; tokenarray[i].token != T_FINAL; i++ ) {

	xor	edx, edx
	mov	DWORD PTR j$1[rbp-153], r8d
	xor	r10b, r10b
	mov	r11, r8
$LL7@InitStruct:

; 322  :                     if ( tokenarray[i].token == T_OP_BRACKET )

	cmp	cl, 40					; 00000028H
	jne	SHORT $LN42@InitStruct

; 323  :                         lvl++;

	inc	edx
	jmp	SHORT $LN5@InitStruct
$LN42@InitStruct:

; 324  :                     else if ( tokenarray[i].token == T_CL_BRACKET )

	cmp	cl, 41					; 00000029H
	jne	SHORT $LN44@InitStruct

; 325  :                         lvl--;

	dec	edx
	jmp	SHORT $LN5@InitStruct
$LN44@InitStruct:

; 326  :                     else if ( lvl == 0 && tokenarray[i].token == T_COMMA )

	test	edx, edx
	jne	SHORT $LN46@InitStruct
	cmp	cl, 44					; 0000002cH
	je	SHORT $LN259@InitStruct
$LN46@InitStruct:

; 327  :                         break;
; 328  :                     else if ( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_DUP )

	cmp	cl, 7
	jne	SHORT $LN5@InitStruct
	cmp	DWORD PTR [r9+16], 259			; 00000103H
	jne	SHORT $LN5@InitStruct

; 329  :                         c++; /* v2.08: check added */

	inc	r10b
$LN5@InitStruct:

; 316  :             } else {
; 317  :                 char c;
; 318  :                 int j = i;
; 319  :                 /* ignore commas enclosed in () ( might occur inside DUP argument! ).
; 320  :                  */
; 321  :                 for ( lvl = 0, c = 0; tokenarray[i].token != T_FINAL; i++ ) {

	inc	r8d
	movsxd	rax, r8d
	shl	rax, 5
	lea	r9, QWORD PTR [rax+rsi]
	mov	DWORD PTR i$[rbp-153], r8d
	movzx	ecx, BYTE PTR [r9]
	test	cl, cl
	jne	SHORT $LL7@InitStruct
$LN259@InitStruct:

; 330  :                 }
; 331  :                 if ( c ) {

	test	r10b, r10b
	je	SHORT $LN49@InitStruct

; 332  :                     EmitErr( INITIALIZER_MUST_BE_A_STRING_OR_SINGLE_ITEM, tokenarray[j].tokpos );

	mov	rdx, r11
	mov	ecx, 152				; 00000098H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	call	EmitErr

; 333  :                 } else

	jmp	$LN285@InitStruct
$LN49@InitStruct:

; 334  :                     if ( ERROR == data_item( &j, tokenarray, NULL, no_of_bytes, f->sym.type, 1, FALSE, f->sym.mem_type & MT_FLOAT, FALSE, i ) ) {

	movzx	eax, BYTE PTR [rdi+36]
	lea	rcx, QWORD PTR j$1[rbp-153]
	mov	DWORD PTR [rsp+72], r8d
	and	al, 32					; 00000020H
	mov	BYTE PTR [rsp+64], 0
	mov	r9d, ebx
	mov	BYTE PTR [rsp+56], al
	xor	r8d, r8d
	mov	rax, QWORD PTR [rdi+80]
	mov	rdx, rsi
	mov	BYTE PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 1
	mov	QWORD PTR [rsp+32], rax
	call	data_item
	cmp	eax, -1
	jne	SHORT $LN285@InitStruct

; 335  :                         EmitErr( INVALID_DATA_INITIALIZER, f->sym.name );

	mov	rdx, QWORD PTR [rdi+8]
	mov	ecx, 231				; 000000e7H
	call	EmitErr
	jmp	SHORT $LN285@InitStruct
$LN41@InitStruct:

; 311  :                 int tc = Token_Count;

	mov	ebx, DWORD PTR ModuleInfo+496

; 312  :                 int j = Token_Count+1;
; 313  :                 Token_Count = Tokenize( f->ivalue, j, tokenarray, TOK_RESCAN );

	lea	rcx, QWORD PTR [rdi+104]
	mov	r9d, 1
	mov	r8, rsi
	lea	edx, DWORD PTR [rbx+1]
	mov	DWORD PTR j$2[rbp-153], edx
	call	Tokenize

; 314  :                 data_item( &j, tokenarray, NULL, no_of_bytes, f->sym.type, 1, FALSE, f->sym.mem_type & MT_FLOAT, FALSE, Token_Count );

	mov	r9d, DWORD PTR no_of_bytes$1$[rbp-153]
	xor	r8d, r8d
	mov	DWORD PTR [rsp+72], eax
	mov	rdx, rsi
	mov	BYTE PTR [rsp+64], 0
	mov	DWORD PTR ModuleInfo+496, eax
	movzx	ecx, BYTE PTR [rdi+36]
	mov	rax, QWORD PTR [rdi+80]
	and	cl, 32					; 00000020H
	mov	BYTE PTR [rsp+56], cl
	lea	rcx, QWORD PTR j$2[rbp-153]
	mov	BYTE PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 1
	mov	QWORD PTR [rsp+32], rax
	call	data_item

; 315  :                 Token_Count = tc;

	mov	DWORD PTR ModuleInfo+496, ebx
$LN285@InitStruct:
	mov	r10d, DWORD PTR i$[rbp-153]
	mov	ebx, 1
$LN51@InitStruct:

; 336  :                     }
; 337  :             }
; 338  :         }
; 339  :         /* Add padding bytes if necessary (never inside RECORDS!).
; 340  :          * f->next == NULL : it's the last field of the struct/union/record
; 341  :          */
; 342  :         if ( symtype->sym.typekind != TYPE_RECORD ) {

	mov	r11, QWORD PTR symtype$[rbp-153]
	movzx	eax, BYTE PTR [r11+66]
	cmp	al, 4
	je	SHORT $LN56@InitStruct

; 343  :             if ( f->next == NULL || symtype->sym.typekind == TYPE_UNION )

	mov	rcx, QWORD PTR [rdi+96]
	test	rcx, rcx
	je	SHORT $LN55@InitStruct
	cmp	al, 2
	je	SHORT $LN55@InitStruct

; 345  :             else
; 346  :                 nextofs = f->next->sym.offset;

	mov	edx, DWORD PTR [rcx+16]
	jmp	SHORT $LN54@InitStruct
$LN55@InitStruct:

; 344  :                 nextofs = symtype->sym.total_size;

	mov	edx, DWORD PTR [r11+56]
$LN54@InitStruct:

; 347  : 
; 348  :             if ( f->sym.offset + f->sym.total_size < nextofs ) {

	mov	ecx, DWORD PTR [rdi+56]
	mov	r8d, DWORD PTR [rdi+16]
	lea	eax, DWORD PTR [r8+rcx]
	cmp	eax, edx
	jae	SHORT $LN56@InitStruct

; 349  :                 DebugMsg1(("InitStructuredVar: padding, field=%s ofs=%" I32_SPEC "X total=%" I32_SPEC "X nextofs=%" I32_SPEC "X\n",
; 350  :                           f->sym.name, f->sym.offset, f->sym.total_size, nextofs ));
; 351  :                 SetCurrOffset( CurrSeg, nextofs - (f->sym.offset + f->sym.total_size), TRUE, TRUE );

	sub	edx, r8d
	mov	r9b, 1
	sub	edx, ecx
	movzx	r8d, r9b
	mov	rcx, QWORD PTR ModuleInfo+432
	call	SetCurrOffset
	mov	r10d, DWORD PTR i$[rbp-153]
	mov	r11, QWORD PTR symtype$[rbp-153]
$LN56@InitStruct:

; 352  :             }
; 353  :         }
; 354  :         /* for a union, just the first field is initialized */
; 355  :         if ( symtype->sym.typekind == TYPE_UNION )

	cmp	BYTE PTR [r11+66], 2
	je	$LN282@InitStruct

; 356  :             break;
; 357  : 
; 358  :         if ( f->next != NULL ) {

	cmp	QWORD PTR [rdi+96], 0
	je	SHORT $LN2@InitStruct

; 359  : 
; 360  :             if ( tokenarray[i].token != T_FINAL )

	movsxd	rax, r10d
	shl	rax, 5
	lea	rdx, QWORD PTR [rax+rsi]
	movzx	eax, BYTE PTR [rax+rsi]
	test	al, al
	je	SHORT $LN2@InitStruct

; 361  :                 if ( tokenarray[i].token == T_COMMA )

	cmp	al, 44					; 0000002cH
	jne	SHORT $LN60@InitStruct

; 362  :                     i++;

	inc	r10d
	mov	DWORD PTR i$[rbp-153], r10d
	jmp	SHORT $LN2@InitStruct
$LN60@InitStruct:

; 363  :                 else {
; 364  :                     EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );

	mov	rdx, QWORD PTR [rdx+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 365  :                     while ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA )

	movsxd	r10, DWORD PTR i$[rbp-153]
	mov	rax, r10
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+rsi]
	test	cl, cl
	je	SHORT $LN280@InitStruct
	npad	3
$LL8@InitStruct:
	cmp	cl, 44					; 0000002cH
	je	SHORT $LN280@InitStruct

; 366  :                         i++;

	inc	r10d
	movsxd	rax, r10d
	shl	rax, 5
	mov	DWORD PTR i$[rbp-153], r10d
	movzx	ecx, BYTE PTR [rax+rsi]
	test	cl, cl
	jne	SHORT $LL8@InitStruct
$LN280@InitStruct:
	mov	r11, QWORD PTR symtype$[rbp-153]
$LN2@InitStruct:

; 236  :     }
; 237  : 
; 238  :     /* scan the STRUCT/UNION/RECORD's members */
; 239  :     for( f = symtype->e.structinfo->head; f != NULL; f = f->next ) {

	mov	rdi, QWORD PTR [rdi+96]
	test	rdi, rdi
	je	$LN282@InitStruct
	xor	r8d, r8d
	jmp	$LL4@InitStruct
$LN65@InitStruct:

; 376  : #if AMD64_SUPPORT
; 377  :         case MT_QWORD: no_of_bytes = 8; break;

	mov	eax, 8
	jmp	SHORT $LN10@InitStruct
$LN64@InitStruct:

; 374  :         case MT_BYTE: no_of_bytes = 1; break;
; 375  :         case MT_WORD: no_of_bytes = 2; break;

	mov	eax, 2
	jmp	SHORT $LN10@InitStruct
$LN63@InitStruct:
	mov	eax, 1
$LN10@InitStruct:

; 380  :         }
; 381  :         if ( is_record_set )

	test	dl, dl

; 382  :             OutputDataBytes( (uint_8 *)&dwRecInit, no_of_bytes );

	mov	edx, eax
	je	SHORT $LN67@InitStruct
	xor	r8d, r8d
	lea	rcx, QWORD PTR dwRecInit$[rbp-153]
	call	OutputBytes
	jmp	SHORT $LN286@InitStruct
$LN67@InitStruct:

; 383  :         else
; 384  :             SetCurrOffset( CurrSeg, no_of_bytes, TRUE, TRUE );

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	r9b, 1
	movzx	r8d, r9b
	call	SetCurrOffset
$LN286@InitStruct:
	mov	r10d, DWORD PTR i$[rbp-153]
$LN68@InitStruct:

; 385  :     }
; 386  : 
; 387  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, r10d
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 0
	je	SHORT $LN69@InitStruct

; 388  :         DebugMsg1(("InitStructuredVar(%s): error, i=%u token=%s\n", symtype->sym.name, i, tokenarray[i].string_ptr ));
; 389  :         EmitErr( TOO_MANY_INITIAL_VALUES_FOR_STRUCTURE, tokenarray[i].tokpos );

	mov	rdx, QWORD PTR [rax+rsi+24]
	mov	ecx, 153				; 00000099H
	call	EmitErr
$LN69@InitStruct:

; 390  :     }
; 391  : 
; 392  :     /* restore token status */
; 393  :     Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$1$[rbp-153]
	mov	DWORD PTR ModuleInfo+496, eax

; 394  :     StringBufferEnd = old_stringbufferend;

	mov	rax, QWORD PTR old_stringbufferend$1$[rbp-153]
	mov	QWORD PTR ModuleInfo+488, rax

; 395  :     DebugMsg1(("InitStructuredVar(%s) exit, current ofs=%" I32_SPEC "X\n", symtype->sym.name, GetCurrOffset() ));
; 396  :     return( NOT_ERROR );

	xor	eax, eax

; 397  : }

	add	rsp, 224				; 000000e0H
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN71@InitStruct:

; 230  :     } else {
; 231  :         return( EmitErr( INITIALIZER_MUST_BE_A_STRING_OR_SINGLE_ITEM, embedded ? embedded->name : "" ) );

	lea	rdx, OFFSET FLAT:$SG11240
$LN72@InitStruct:
	mov	ecx, 152				; 00000098H
	call	EmitErr

; 397  : }

	add	rsp, 224				; 000000e0H
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
InitStructuredVar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\data.c
;	COMDAT InitializeArray
_TEXT	SEGMENT
lvl$ = 144
f$ = 144
j$ = 152
pi$ = 152
tokenarray$ = 160
InitializeArray PROC					; COMDAT

; 74   : {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H

; 75   :     uint_32 oldofs;
; 76   :     uint_32 no_of_bytes;
; 77   :     int  i = *pi;

	movsxd	r12, DWORD PTR [rdx]
	mov	rbp, r8
	mov	rbx, rdx
	mov	rdi, rcx

; 78   :     int  j;
; 79   :     int  lvl;
; 80   :     int old_tokencount;
; 81   :     char bArray;
; 82   :     ret_code rc;
; 83   : 
; 84   :     oldofs = GetCurrOffset();

	call	GetCurrOffset

; 85   :     no_of_bytes = SizeFromMemtype( f->sym.mem_type, USE_EMPTY, f->sym.type );

	mov	r8, QWORD PTR [rdi+80]
	mov	edx, 254				; 000000feH
	mov	ecx, DWORD PTR [rdi+36]
	mov	r13d, eax
	call	SizeFromMemtype

; 86   : 
; 87   :     DebugMsg1(("InitializeArray(%s) enter, items=%" I32_SPEC "u size=%" I32_SPEC "u mem_type=%xh type=%s currofs=%" I32_SPEC "X [%s]\n",
; 88   :                f->sym.name, f->sym.total_length, no_of_bytes, f->sym.mem_type,
; 89   :                f->sym.type ? f->sym.type->name : "NULL", oldofs, tokenarray[i].tokpos ));
; 90   : 
; 91   :     /* If current item is a literal enclosed in <> or {}, just use this
; 92   :      * item. Else, use all items until a comma or EOL is found.
; 93   :      */
; 94   : 
; 95   :     if ( tokenarray[i].token != T_STRING ||

	mov	r9, r12
	mov	r15d, eax
	shl	r9, 5
	movzx	edx, BYTE PTR [r9+rbp]
	lea	rsi, QWORD PTR [r9+rbp]
	cmp	dl, 9
	jne	$LN7@Initialize
	movzx	ecx, BYTE PTR [rsi+1]
	cmp	cl, 60					; 0000003cH
	je	SHORT $LN5@Initialize
	cmp	cl, 123					; 0000007bH
	jne	$LN7@Initialize
$LN5@Initialize:

; 130  :         }
; 131  : 
; 132  :     } else {
; 133  : 
; 134  :         /* initializer is a literal */
; 135  :         (*pi)++;

	inc	DWORD PTR [rbx]

; 136  :         old_tokencount = Token_Count;
; 137  :         j = Token_Count + 1;
; 138  :         /* if the string is empty, use the default initializer */
; 139  :         if ( tokenarray[i].stringlen == 0 ) {
; 140  :             Token_Count = Tokenize( (char *)f->ivalue, j, tokenarray, TOK_RESCAN );

	lea	rcx, QWORD PTR [rdi+104]
	cmp	DWORD PTR [rsi+16], 0
	mov	r9d, 1
	mov	ebx, DWORD PTR ModuleInfo+496
	mov	r8, rbp
	lea	edx, DWORD PTR [rbx+1]
	mov	DWORD PTR j$[rsp], edx
	je	SHORT $LN38@Initialize

; 141  :         } else {
; 142  :             Token_Count = Tokenize( tokenarray[i].string_ptr, j, tokenarray, TOK_RESCAN );

	mov	rcx, QWORD PTR [rsi+8]
$LN38@Initialize:
	call	Tokenize
	mov	ecx, eax
	mov	DWORD PTR ModuleInfo+496, eax

; 143  :         }
; 144  :         rc = data_item( &j, tokenarray, NULL, no_of_bytes, f->sym.type, 1, FALSE, f->sym.mem_type & MT_FLOAT, FALSE, Token_Count );

	movzx	eax, BYTE PTR [rdi+36]
	mov	r9d, r15d
	mov	DWORD PTR [rsp+72], ecx
	and	al, 32					; 00000020H
	mov	BYTE PTR [rsp+64], 0
	lea	rcx, QWORD PTR j$[rsp]
	mov	BYTE PTR [rsp+56], al
	xor	r8d, r8d
	mov	rax, QWORD PTR [rdi+80]
	mov	rdx, rbp
	mov	BYTE PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 1
	mov	QWORD PTR [rsp+32], rax
	call	data_item

; 145  :         Token_Count = old_tokencount;

	mov	DWORD PTR ModuleInfo+496, ebx
	jmp	$LN39@Initialize
$LN7@Initialize:

; 96   :          ( tokenarray[i].string_delim != '<' &&
; 97   :            tokenarray[i].string_delim != '{' )) {
; 98   : 
; 99   :         /* scan for comma or final. Ignore commas inside DUP argument */
; 100  :         for( j = i, lvl = 0, bArray = FALSE; tokenarray[j].token != T_FINAL; j++ ) {

	xor	r14d, r14d
	mov	DWORD PTR j$[rsp], r12d
	xor	r9b, r9b
	mov	ecx, r14d
	mov	DWORD PTR lvl$[rsp], ecx
	mov	r8d, r12d
	test	dl, dl
	je	SHORT $LN37@Initialize
	mov	rdx, rsi
	npad	7
$LL4@Initialize:

; 101  :             if ( tokenarray[j].token == T_OP_BRACKET )

	movzx	eax, BYTE PTR [rdx]
	cmp	al, 40					; 00000028H
	jne	SHORT $LN8@Initialize

; 102  :                 lvl++;

	inc	ecx
	mov	DWORD PTR lvl$[rsp], ecx
	jmp	SHORT $LN2@Initialize
$LN8@Initialize:

; 103  :             else if ( tokenarray[j].token == T_CL_BRACKET )

	cmp	al, 41					; 00000029H
	jne	SHORT $LN10@Initialize

; 104  :                 lvl--;

	dec	ecx
	mov	DWORD PTR lvl$[rsp], ecx
	jmp	SHORT $LN2@Initialize
$LN10@Initialize:

; 105  :             else if ( lvl == 0 && tokenarray[j].token == T_COMMA )

	test	ecx, ecx
	jne	SHORT $LN12@Initialize
	cmp	al, 44					; 0000002cH
	je	SHORT $LN37@Initialize
$LN12@Initialize:

; 106  :                 break;
; 107  :             else if ( tokenarray[j].token == T_RES_ID && tokenarray[j].tokval == T_DUP )

	cmp	al, 7
	jne	SHORT $LN14@Initialize
	cmp	DWORD PTR [rdx+16], 259			; 00000103H
	je	SHORT $LN17@Initialize
$LN14@Initialize:

; 108  :                 bArray = TRUE;
; 109  :             else if ( no_of_bytes == 1 && tokenarray[j].token == T_STRING &&

	cmp	r15d, 1
	jne	SHORT $LN2@Initialize
	cmp	al, 9
	jne	SHORT $LN2@Initialize
	movzx	eax, BYTE PTR [rdx+1]
	cmp	al, 34					; 00000022H
	je	SHORT $LN17@Initialize
	cmp	al, 39					; 00000027H
	jne	SHORT $LN2@Initialize
$LN17@Initialize:

; 110  :                      ( tokenarray[j].string_delim == '"' || tokenarray[j].string_delim == '\'' ))
; 111  :                 bArray = TRUE;

	mov	r9b, 1
$LN2@Initialize:

; 96   :          ( tokenarray[i].string_delim != '<' &&
; 97   :            tokenarray[i].string_delim != '{' )) {
; 98   : 
; 99   :         /* scan for comma or final. Ignore commas inside DUP argument */
; 100  :         for( j = i, lvl = 0, bArray = FALSE; tokenarray[j].token != T_FINAL; j++ ) {

	inc	r8d
	movsxd	rax, r8d
	shl	rax, 5
	mov	DWORD PTR j$[rsp], r8d
	cmp	BYTE PTR [rax+rbp], r14b
	lea	rdx, QWORD PTR [rax+rbp]
	jne	SHORT $LL4@Initialize
$LN37@Initialize:

; 112  :         }
; 113  :         *pi = j;

	mov	DWORD PTR [rbx], r8d

; 114  : 
; 115  :         if ( bArray == FALSE ) {

	test	r9b, r9b
	jne	SHORT $LN18@Initialize

; 116  :             DebugMsg1(("InitializeArray(%s): error, array init requires DUP, string or literal\n", f->sym.name ));
; 117  :             return( EmitErr( INITIALIZER_MUST_BE_A_STRING_OR_SINGLE_ITEM, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rsi+24]
	mov	ecx, 152				; 00000098H
	call	EmitErr
	jmp	$LN1@Initialize
$LN18@Initialize:

; 118  :         }
; 119  : 
; 120  :         lvl = tokenarray[j].tokpos - tokenarray[i].tokpos;

	movsxd	rax, r8d
	shl	rax, 5
	mov	ecx, DWORD PTR [rax+rbp+24]
	sub	ecx, DWORD PTR [rsi+24]
	mov	DWORD PTR lvl$[rsp], ecx

; 121  : 
; 122  :         /* v2.07: accept an "empty" quoted string as array initializer for byte arrays */
; 123  :         if ( lvl == 2 &&
; 124  :             f->sym.total_size == f->sym.total_length &&

	cmp	ecx, 2
	jne	SHORT $LN19@Initialize
	mov	eax, DWORD PTR [rdi+64]
	cmp	DWORD PTR [rdi+56], eax
	jne	SHORT $LN19@Initialize
	movzx	eax, BYTE PTR [rsi+1]
	cmp	al, 34					; 00000022H
	je	SHORT $LN20@Initialize
	cmp	al, 39					; 00000027H
	je	SHORT $LN20@Initialize
$LN19@Initialize:

; 125  :             ( tokenarray[i].string_delim == '"' || tokenarray[i].string_delim == '\'' ) )
; 126  :             rc = NOT_ERROR;
; 127  :         else {
; 128  :             lvl = i; /* i must remain the start index */
; 129  :             rc = data_item( &lvl, tokenarray, NULL, no_of_bytes, f->sym.type, 1, FALSE, f->sym.mem_type & MT_FLOAT, FALSE, j );

	movzx	eax, BYTE PTR [rdi+36]
	lea	rcx, QWORD PTR lvl$[rsp]
	mov	DWORD PTR [rsp+72], r8d
	and	al, 32					; 00000020H
	mov	BYTE PTR [rsp+64], r14b
	mov	r9d, r15d
	mov	BYTE PTR [rsp+56], al
	xor	r8d, r8d
	mov	rax, QWORD PTR [rdi+80]
	mov	rdx, rbp
	mov	BYTE PTR [rsp+48], r14b
	mov	DWORD PTR [rsp+40], 1
	mov	QWORD PTR [rsp+32], rax
	mov	DWORD PTR lvl$[rsp], r12d
	call	data_item
$LN39@Initialize:
	mov	r14d, eax
$LN20@Initialize:

; 146  :     }
; 147  : 
; 148  :     /* get size of array items */
; 149  :     no_of_bytes = GetCurrOffset() - oldofs ;

	call	GetCurrOffset

; 150  :     DebugMsg1(("InitializeArray(%s): new offset=%X\n", f->sym.name, no_of_bytes + oldofs ));
; 151  : 
; 152  :     if ( no_of_bytes > f->sym.total_size ) {

	mov	edx, DWORD PTR [rdi+56]
	mov	ecx, eax
	sub	ecx, r13d
	cmp	ecx, edx
	jbe	SHORT $LN40@Initialize

; 153  :         DebugMsg1(("InitializeArray(%s): error, cursize=%u total_size=%u\n", f->sym.name, no_of_bytes, f->sym.total_size ));
; 154  :         EmitErr( TOO_MANY_INITIAL_VALUES_FOR_ARRAY, tokenarray[i].tokpos );

	mov	rdx, QWORD PTR [rsi+24]
	mov	ecx, 154				; 0000009aH
	call	EmitErr

; 155  :         rc = ERROR;

	or	r14d, -1
	jmp	SHORT $LN28@Initialize
$LN40@Initialize:

; 156  :     } else if ( no_of_bytes < f->sym.total_size ) {

	jae	SHORT $LN28@Initialize

; 157  :         char filler = NULLC;
; 158  :         DebugMsg1(("InitializeArray: remaining bytes=%" I32_SPEC "u\n", f->sym.total_size - no_of_bytes ));
; 159  :         if ( CurrSeg && CurrSeg->e.seginfo->segtype == SEGTYPE_BSS )

	mov	r10, QWORD PTR ModuleInfo+432
	xor	r8b, r8b
	test	r10, r10
	je	SHORT $LN27@Initialize
	mov	rax, QWORD PTR [r10+96]
	cmp	DWORD PTR [rax+72], 3
	jne	SHORT $LN27@Initialize

; 160  :             SetCurrOffset( CurrSeg, f->sym.total_size - no_of_bytes, TRUE, TRUE );

	mov	r9b, 1
	sub	edx, ecx
	movzx	r8d, r9b
	mov	rcx, r10
	call	SetCurrOffset
	jmp	SHORT $LN28@Initialize
$LN27@Initialize:

; 161  :         else {
; 162  :             /* v2.07: if element size is 1 and a string is used as initial value,
; 163  :              * pad array with spaces!
; 164  :              */
; 165  :             if ( f->sym.total_size == f->sym.total_length &&

	cmp	edx, DWORD PTR [rdi+64]
	jne	SHORT $LN29@Initialize
	movzx	eax, BYTE PTR [rdi+104]
	cmp	al, 34					; 00000022H
	je	SHORT $LN30@Initialize
	cmp	al, 39					; 00000027H
	jne	SHORT $LN29@Initialize
$LN30@Initialize:

; 166  :                 ( f->ivalue[0] == '"' || f->ivalue[0] == '\'' ) )
; 167  :                 filler = ' ';

	mov	r8b, 32					; 00000020H
$LN29@Initialize:

; 168  :             FillDataBytes( filler, f->sym.total_size - no_of_bytes );

	sub	edx, ecx
	movzx	ecx, r8b
	call	FillDataBytes
$LN28@Initialize:

; 169  :         }
; 170  :     }
; 171  : 
; 172  :     DebugMsg1(("InitializeArray(%s) exit, curr ofs=%X\n", f->sym.name, GetCurrOffset() ));
; 173  :     return( rc );

	mov	eax, r14d
$LN1@Initialize:

; 174  : }

	mov	rbx, QWORD PTR [rsp+160]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
InitializeArray ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\data.c
;	COMDAT data_item
_TEXT	SEGMENT
i$ = 80
total$1$ = 84
initwarn$1$ = 88
opndx$ = 96
buffer$1 = 208
start_pos$ = 272
tokenarray$ = 280
sym$ = 288
no_of_bytes$ = 296
type_sym$ = 304
fixup_type$ = 312
dup$ = 312
inside_struct$ = 320
is_float$ = 328
first$ = 336
end$ = 344
data_item PROC						; COMDAT

; 472  : {

	mov	QWORD PTR [rsp+32], rbx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	lea	rbp, QWORD PTR [rsp-23]
	sub	rsp, 240				; 000000f0H

; 473  :     int                 i;
; 474  :     int                 string_len;
; 475  :     uint_32             total = 0;

	xor	eax, eax
	mov	esi, r9d
	mov	r11d, eax
	mov	DWORD PTR total$1$[rsp], eax

; 476  :     bool                initwarn = FALSE;

	mov	BYTE PTR initwarn$1$[rsp], al
	mov	rbx, r8

; 477  :     //unsigned int        count;
; 478  :     uint_8              *pchar;
; 479  :     char                tmp;
; 480  :     enum fixup_types    fixup_type;
; 481  :     struct fixup        *fixup;
; 482  :     struct expr         opndx;
; 483  : 
; 484  :     DebugMsg1(("data_item( idx=%u [%s], label=%s, no_of_bytes=%" I32_SPEC "u, type=%s, dup=%" I32_SPEC "Xh, inside_struct=%u, is_float=%u ) enter\n",
; 485  :                *start_pos, tokenarray[*start_pos].tokpos, sym ? sym->name : "NULL",
; 486  :                no_of_bytes, type_sym ? type_sym->name : "NULL",
; 487  :                dup, inside_struct, is_float ));
; 488  : 
; 489  :     for ( ; dup; dup-- ) {

	mov	eax, DWORD PTR dup$[rbp-217]
	mov	r8, rdx
	test	eax, eax
	je	$LN250@data_item
	mov	edi, DWORD PTR fixup_type$[rbp-217]
	npad	9
$LL4@data_item:

; 490  :     i = *start_pos;

	mov	r10d, DWORD PTR [rcx]
	mov	DWORD PTR i$[rsp], r10d
	npad	8
$next_item$265:

; 491  : next_item:  /* <--- continue scan if a comma has been detected */
; 492  :     /* since v1.94, the expression evaluator won't handle strings
; 493  :      * enclosed in <> or {}. That is, in previous versions syntax
; 494  :      * "mov eax,<1>" was accepted, now it's rejected.
; 495  :      */
; 496  :     if ( tokenarray[i].token == T_STRING && ( tokenarray[i].string_delim == '<'  || tokenarray[i].string_delim == '{' ) ) {

	movsxd	rax, r10d
	shl	rax, 5
	add	r8, rax
	movzx	ecx, BYTE PTR [r8]
	cmp	cl, 9
	jne	$LN22@data_item
	movzx	eax, BYTE PTR [r8+1]
	cmp	al, 60					; 0000003cH
	je	SHORT $LN21@data_item
	cmp	al, 123					; 0000007bH
	jne	$LN22@data_item
$LN21@data_item:

; 497  :         if( type_sym ) {

	mov	rdx, QWORD PTR type_sym$[rbp-217]
	test	rdx, rdx
	je	$LN22@data_item

; 498  :             DebugMsg1(("data_item(%s): literal/brace found: >%s<, inside_struct=%u, no_of_bytes=%" I32_SPEC "u, curr_ofs=%" I32_SPEC "X\n",
; 499  :                        type_sym->name, tokenarray[i].string_ptr, inside_struct, no_of_bytes, GetCurrOffset()));
; 500  : 
; 501  :             /* it's either a real data item - then inside_struct is FALSE -
; 502  :              * or a structure FIELD of arbitrary type.
; 503  :              *
; 504  :              * v2.10: regression in v2.09: alias types weren't skipped for InitStructuredVar()
; 505  :              */
; 506  :             while ( type_sym->type ) type_sym = type_sym->type;

	mov	rax, QWORD PTR [rdx+80]
	test	rax, rax
	je	SHORT $LN6@data_item
	npad	2
$LL5@data_item:
	mov	QWORD PTR type_sym$[rbp-217], rax
	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	jne	SHORT $LL5@data_item
	mov	rbx, QWORD PTR sym$[rbp-217]
	mov	rdx, QWORD PTR type_sym$[rbp-217]
$LN6@data_item:

; 507  :             if( inside_struct == FALSE ) {

	cmp	BYTE PTR inside_struct$[rbp-217], 0
	jne	SHORT $LN23@data_item

; 508  :                 if ( InitStructuredVar( i, tokenarray, (struct dsym *)type_sym, NULL ) == ERROR )

	mov	r8, rdx
	xor	r9d, r9d
	mov	rdx, QWORD PTR tokenarray$[rbp-217]
	mov	ecx, r10d
	call	InitStructuredVar
	cmp	eax, -1
	je	$LN203@data_item

; 509  :                     return( ERROR );
; 510  :             } else {

	jmp	SHORT $LN261@data_item
$LN23@data_item:

; 511  :                 /* v2.09: emit a warning if a TYPEDEF member is a simple type,
; 512  :                  * but is initialized with a literal.
; 513  :                  * Note: Masm complains about such literals only if the struct is instanced OR -Fl is set.
; 514  :                  * fixme: the best solution is to always set type_sym to NULL if
; 515  :                  * the type is a TYPEDEF. if the item is a struct member, then
; 516  :                  * sym is ALWAYS != NULL and the symbol's type can be gained from there.
; 517  :                  * v2.10: aliases are now already skipped here ( see above ).
; 518  :                  */
; 519  :                 //while ( type_sym->type ) /* skip alias types */
; 520  :                 //    type_sym = type_sym->type;
; 521  :                 if( type_sym->typekind == TYPE_TYPEDEF && Parse_Pass == PASS_1 )

	cmp	BYTE PTR [rdx+66], 3
	jne	SHORT $LN26@data_item
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN26@data_item

; 522  :                     EmitWarn( 2, COUNT_MUST_BE_POSITIVE_OR_ZERO, tokenarray[i].tokpos );

	mov	r8, QWORD PTR [r8+24]
	mov	edx, 208				; 000000d0H
	mov	ecx, 2
	call	EmitWarn
$LN261@data_item:
	mov	r11d, DWORD PTR total$1$[rsp]
	mov	r10d, DWORD PTR i$[rsp]
$LN26@data_item:

; 523  :             }
; 524  : 
; 525  :             total++;

	inc	r11d

; 526  :             i++;

	inc	r10d
	mov	DWORD PTR total$1$[rsp], r11d
	mov	DWORD PTR i$[rsp], r10d

; 527  :             goto item_done;

	jmp	$LN256@data_item
$LN22@data_item:

; 528  : #if 0 /* v2.08: just let EvalOperand() emit 'Unexpected literal...' error */
; 529  :         } else {
; 530  :             DebugMsg(("data_item: invalid string initializer >%s<\n", tokenarray[i].tokpos ));
; 531  :             /* Masm accepts invalid initializer strings if they are actually never used
; 532  :              * for initialization.
; 533  :              */
; 534  :             if( inside_struct && Parse_Pass == PASS_1 ) {
; 535  :                 EmitWarn( 2, UNEXPECTED_LITERAL_FOUND_IN_EXPRESSION, tokenarray[i].tokpos );
; 536  :                 tokenarray[i].token = T_QUESTION_MARK;
; 537  :             }
; 538  : #endif
; 539  :         }
; 540  :     }
; 541  : 
; 542  :     if ( tokenarray[i].token == T_QUESTION_MARK )

	cmp	cl, 63					; 0000003fH
	jne	SHORT $LN27@data_item

; 543  :         opndx.kind = EXPR_EMPTY;

	mov	r8d, -2
	mov	DWORD PTR opndx$[rbp-157], r8d
	jmp	SHORT $LN29@data_item
$LN27@data_item:

; 544  :     else
; 545  :         if ( EvalOperand( &i, tokenarray, end, &opndx, 0 ) == ERROR )

	mov	r8d, DWORD PTR end$[rbp-217]
	lea	r9, QWORD PTR opndx$[rbp-217]
	mov	rdx, QWORD PTR tokenarray$[rbp-217]
	lea	rcx, QWORD PTR i$[rsp]
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1
	je	$LN203@data_item
	mov	r10d, DWORD PTR i$[rsp]
	mov	r8d, DWORD PTR opndx$[rbp-157]
	mov	r11d, DWORD PTR total$1$[rsp]
$LN29@data_item:

; 547  : 
; 548  :     //DebugMsg(("data_item, EvalOperand() returned, opndx.kind=%u\n", opndx.kind ));
; 549  : 
; 550  :     /* handle DUP operator */
; 551  : 
; 552  :     if ( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_DUP ) {

	mov	rcx, QWORD PTR tokenarray$[rbp-217]
	movsxd	rdx, r10d
	shl	rdx, 5
	add	rdx, rcx
	movzx	r9d, BYTE PTR [rdx]
	cmp	r9b, 7
	jne	$LN30@data_item
	cmp	DWORD PTR [rdx+16], 259			; 00000103H
	jne	$LN30@data_item

; 553  :         /* v2.03: db 'AB' dup (0) is valid syntax! */
; 554  :         //if ( opndx.kind != EXPR_CONST || opndx.string != NULL ) {
; 555  :         if ( opndx.kind != EXPR_CONST ) {

	test	r8d, r8d
	jne	$LN205@data_item

; 563  :         }
; 564  :         /* max dup is 0x7fffffff */
; 565  :         if ( opndx.value < 0 ) {

	cmp	DWORD PTR opndx$[rbp-217], r8d
	jl	$LN206@data_item

; 567  :         }
; 568  :         i++;

	inc	r10d

; 569  :         if( tokenarray[i].token != T_OP_BRACKET ) {

	mov	r8, rcx
	movsxd	rax, r10d
	shl	rax, 5
	mov	DWORD PTR i$[rsp], r10d
	cmp	BYTE PTR [rax+rcx], 40			; 00000028H
	jne	$LN207@data_item

; 572  :         }
; 573  :         i++;

	inc	r10d
	mov	DWORD PTR i$[rsp], r10d

; 574  : 
; 575  :         if ( sym )

	test	rbx, rbx
	je	SHORT $LN36@data_item

; 576  :             sym->isarray = TRUE;

	or	BYTE PTR [rbx+41], 2
$LN36@data_item:

; 577  : 
; 578  :         if ( opndx.value == 0 ) {

	cmp	DWORD PTR opndx$[rbp-217], 0
	jne	SHORT $LN37@data_item

; 579  :             int level = 1;
; 580  :             for ( ; tokenarray[i].token != T_FINAL; i++ ) {

	movsxd	rax, r10d
	mov	edx, 1
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+r8]
	test	cl, cl
	je	$LN43@data_item
$LL9@data_item:

; 581  :                 if ( tokenarray[i].token == T_OP_BRACKET )

	cmp	cl, 40					; 00000028H
	jne	SHORT $LN39@data_item

; 582  :                     level++;

	inc	edx
	jmp	SHORT $LN41@data_item
$LN39@data_item:

; 583  :                 else if ( tokenarray[i].token == T_CL_BRACKET )

	cmp	cl, 41					; 00000029H
	jne	SHORT $LN41@data_item

; 584  :                     level--;

	dec	edx
$LN41@data_item:

; 585  :                 if ( level == 0 )

	test	edx, edx
	je	SHORT $LN43@data_item

; 579  :             int level = 1;
; 580  :             for ( ; tokenarray[i].token != T_FINAL; i++ ) {

	inc	r10d
	movsxd	rax, r10d
	shl	rax, 5
	mov	DWORD PTR i$[rsp], r10d
	movzx	ecx, BYTE PTR [rax+r8]
	test	cl, cl
	jne	SHORT $LL9@data_item

; 586  :                     break;
; 587  :             }
; 588  :         } else {

	jmp	SHORT $LN43@data_item
$LN37@data_item:

; 589  :             DebugMsg1(("data_item(%s): op DUP, count=%" I32_SPEC "Xh, calling data_item()\n", sym ? sym->name : "NULL", opndx.uvalue ));
; 590  :             if ( data_item( &i, tokenarray, sym, no_of_bytes, type_sym, opndx.uvalue, inside_struct, is_float, first, end ) == ERROR ) {

	mov	eax, DWORD PTR end$[rbp-217]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rbp-217]
	mov	r9d, esi
	mov	DWORD PTR [rsp+72], eax
	mov	r8, rbx
	movzx	eax, BYTE PTR first$[rbp-217]
	mov	BYTE PTR [rsp+64], al
	movzx	eax, BYTE PTR is_float$[rbp-217]
	mov	BYTE PTR [rsp+56], al
	movzx	eax, BYTE PTR inside_struct$[rbp-217]
	mov	BYTE PTR [rsp+48], al
	mov	eax, DWORD PTR opndx$[rbp-217]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR type_sym$[rbp-217]
	mov	QWORD PTR [rsp+32], rax
	call	data_item
	cmp	eax, -1
	je	$LN203@data_item
	mov	r10d, DWORD PTR i$[rsp]
	mov	r8, QWORD PTR tokenarray$[rbp-217]
$LN43@data_item:

; 591  :                 DebugMsg(("data_item(%s): op DUP, count=%" I32_SPEC "Xh, returned with error\n", sym ? sym->name : "NULL", opndx.uvalue ));
; 592  :                 return( ERROR );
; 593  :             }
; 594  :         }
; 595  :         if( tokenarray[i].token != T_CL_BRACKET ) {

	movsxd	rax, r10d
	shl	rax, 5
	cmp	BYTE PTR [rax+r8], 41			; 00000029H
	jne	$LN209@data_item

; 598  :         }
; 599  :         /* v2.09: SIZE and LENGTH actually don't return values for "first initializer, but
; 600  :          * the "first dimension" values
; 601  :          * v2.11: fixme: if the first dimension is 0 ( opndx.value == 0),
; 602  :          * Masm ignores the expression - may be a Masm bug!
; 603  :          */
; 604  :         if ( sym && first && Parse_Pass == PASS_1 ) {

	test	rbx, rbx
	je	SHORT $LN45@data_item
	cmp	BYTE PTR first$[rbp-217], 0
	je	SHORT $LN45@data_item
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN45@data_item

; 605  :             sym->first_size = opndx.value * no_of_bytes;

	mov	ecx, DWORD PTR opndx$[rbp-217]
	mov	eax, ecx
	imul	eax, esi

; 606  :             sym->first_length = opndx.value;

	mov	DWORD PTR [rbx+48], ecx

; 607  :             first = FALSE;

	mov	BYTE PTR first$[rbp-217], 0
	mov	DWORD PTR [rbx+44], eax
$LN45@data_item:

; 608  :         }
; 609  : 
; 610  :         i++;
; 611  :         goto item_done;

	mov	r11d, DWORD PTR total$1$[rsp]
	inc	r10d
	mov	DWORD PTR i$[rsp], r10d
	jmp	$item_done$266
$LN30@data_item:

; 612  :     }
; 613  :     /* a STRUCT/UNION/RECORD data item needs a literal as initializer */
; 614  :     /* v2.06: changed */
; 615  :     //if( type_sym != NULL && inside_struct == FALSE ) {
; 616  :     //if( type_sym != NULL && type_sym->typekind != TYPE_TYPEDEF ) {
; 617  :     if( type_sym ) {

	mov	rax, QWORD PTR type_sym$[rbp-217]
	test	rax, rax
	je	SHORT $LN47@data_item

; 618  :         /* v2.10: use a temp symbol, so the original type name can be displayed in the error msg. */
; 619  :         const struct asym *tmp = type_sym;

	mov	rcx, rax

; 620  :         /* v2.10: check if target type is a struct/union/record; if yes, it's an error. */
; 621  :         while ( tmp->type ) tmp = tmp->type;

	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	je	SHORT $LN11@data_item
	npad	10
$LL10@data_item:
	mov	rcx, rax
	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	jne	SHORT $LL10@data_item
$LN11@data_item:

; 622  :         if ( tmp->typekind != TYPE_TYPEDEF ) {

	cmp	BYTE PTR [rcx+66], 3
	jne	$LN210@data_item
$LN47@data_item:

; 625  :         }
; 626  :     }
; 627  : 
; 628  :     /* handle '?' */
; 629  :     if ( opndx.kind == EXPR_EMPTY && tokenarray[i].token == T_QUESTION_MARK ) {

	cmp	r8d, -2
	jne	SHORT $LN48@data_item
	cmp	r9b, 63					; 0000003fH
	jne	SHORT $LN48@data_item

; 630  :         DebugMsg1(("data_item: ? found, curr_ofs=%X\n", GetCurrOffset()));
; 631  :         opndx.uvalue = no_of_bytes;

	mov	DWORD PTR opndx$[rbp-217], esi

; 632  :         /* tiny optimization for uninitialized arrays */
; 633  :         if ( tokenarray[i+1].token != T_COMMA && i == *start_pos ) {

	cmp	BYTE PTR [rdx+32], 44			; 0000002cH
	je	SHORT $LN49@data_item
	mov	rax, QWORD PTR start_pos$[rbp-217]
	cmp	r10d, DWORD PTR [rax]
	jne	SHORT $LN49@data_item

; 634  :             opndx.uvalue *= dup;

	mov	ecx, DWORD PTR dup$[rbp-217]
	mov	eax, esi
	imul	eax, ecx

; 635  :             total += dup;

	add	r11d, ecx

; 636  :             dup = 1; /* force loop exit */

	mov	DWORD PTR dup$[rbp-217], 1
	mov	DWORD PTR opndx$[rbp-217], eax

; 637  :         } else {

	jmp	SHORT $LN262@data_item
$LN49@data_item:

; 638  :             total++;

	inc	r11d
$LN262@data_item:

; 639  :         }
; 640  :         if( !inside_struct ) {

	cmp	BYTE PTR inside_struct$[rbp-217], 0
	mov	DWORD PTR total$1$[rsp], r11d
	jne	SHORT $LN51@data_item

; 641  :             SetCurrOffset( CurrSeg, opndx.uvalue, TRUE, TRUE );

	mov	edx, DWORD PTR opndx$[rbp-217]
	mov	r9b, 1
	mov	rcx, QWORD PTR ModuleInfo+432
	movzx	r8d, r9b
	call	SetCurrOffset
	mov	r10d, DWORD PTR i$[rsp]
	mov	r11d, DWORD PTR total$1$[rsp]
$LN51@data_item:

; 642  :         }
; 643  :         i++;

	inc	r10d
	mov	DWORD PTR i$[rsp], r10d

; 644  :         goto item_done;

	jmp	$LN256@data_item
$LN48@data_item:

; 645  :     }
; 646  : 
; 647  :     /* warn about initialized data in BSS/AT segments */
; 648  :     if ( Parse_Pass == PASS_2 &&
; 649  :         inside_struct == FALSE  &&
; 650  :         // CurrSeg != NULL &&  /* this is already ensured to be true */
; 651  :         (CurrSeg->e.seginfo->segtype == SEGTYPE_BSS ||
; 652  :          CurrSeg->e.seginfo->segtype == SEGTYPE_ABS) &&

	cmp	DWORD PTR Parse_Pass, 1
	movzx	ecx, BYTE PTR inside_struct$[rbp-217]
	jne	SHORT $LN52@data_item
	test	cl, cl
	jne	SHORT $LN52@data_item
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+96]
	mov	edx, DWORD PTR [rcx+72]
	lea	eax, DWORD PTR [rdx-3]
	test	eax, -3					; fffffffdH
	jne	SHORT $LN258@data_item
	cmp	BYTE PTR initwarn$1$[rsp], 0
	jne	SHORT $LN258@data_item

; 653  :         initwarn == FALSE ) {
; 654  :         EmitWarn( 2,

	cmp	edx, 3
	lea	rax, OFFSET FLAT:$SG11422
	lea	r8, OFFSET FLAT:$SG11423
	mov	edx, 184				; 000000b8H
	cmove	r8, rax
	mov	ecx, 2
	call	EmitWarn

; 655  :                  INITIALIZED_DATA_NOT_SUPPORTED_IN_SEGMENT,
; 656  :                  (CurrSeg->e.seginfo->segtype == SEGTYPE_BSS) ? "BSS" : "AT" );
; 657  :         initwarn = TRUE;

	mov	r10d, DWORD PTR i$[rsp]
	mov	r8d, DWORD PTR opndx$[rbp-157]
	mov	BYTE PTR initwarn$1$[rsp], 1
$LN258@data_item:
	movzx	ecx, BYTE PTR inside_struct$[rbp-217]
$LN52@data_item:

; 658  :     };
; 659  : 
; 660  :     switch( opndx.kind ) {

	cmp	r8d, -2
	je	$LN54@data_item
	test	r8d, r8d
	je	$LN59@data_item
	cmp	r8d, 1
	je	$LN84@data_item
	cmp	r8d, 2
	je	$LN162@data_item
	cmp	r8d, 3
	jne	$LN211@data_item

; 668  :     case EXPR_FLOAT:
; 669  :         DebugMsg1(("data_item.FLOAT: >%s<, inside_struct=%u, no_of_bytes=%u, curr_ofs=%X\n",
; 670  :                    opndx.float_tok->string_ptr, inside_struct, no_of_bytes, GetCurrOffset()));
; 671  :         if (!inside_struct)

	test	cl, cl
	jne	SHORT $LN58@data_item

; 672  :             output_float( &opndx, no_of_bytes );

	mov	ecx, DWORD PTR opndx$[rbp-153]
	cmp	ecx, 192				; 000000c0H
	je	SHORT $LN185@data_item
	xor	eax, eax
	xor	r8d, r8d
	mov	edx, 254				; 000000feH
	mov	QWORD PTR buffer$1[rbp-217], rax
	mov	QWORD PTR buffer$1[rbp-209], rax
	mov	QWORD PTR buffer$1[rbp-201], rax
	mov	QWORD PTR buffer$1[rbp-193], rax
	call	SizeFromMemtype
	mov	r8d, eax
	cmp	eax, esi
	jbe	SHORT $LN187@data_item
	mov	ecx, 55					; 00000037H
	call	EmitErr
	jmp	SHORT $LN186@data_item
$LN185@data_item:
	mov	r8d, esi
$LN187@data_item:
	mov	rdx, QWORD PTR opndx$[rbp-201]
	lea	rcx, QWORD PTR buffer$1[rbp-217]
	mov	r9d, DWORD PTR opndx$[rbp-145]
	shr	r9d, 5
	and	r9b, 1
	movzx	eax, BYTE PTR [rdx+1]
	mov	rdx, QWORD PTR [rdx+8]
	mov	BYTE PTR [rsp+32], al
	call	atofloat
$LN186@data_item:
	xor	r8d, r8d
	lea	rcx, QWORD PTR buffer$1[rbp-217]
	mov	edx, esi
	call	OutputBytes
$LN248@data_item:
	mov	r10d, DWORD PTR i$[rsp]
$LN58@data_item:

; 673  :         total++;

	mov	r11d, DWORD PTR total$1$[rsp]
	inc	r11d
	mov	DWORD PTR total$1$[rsp], r11d

; 674  :         break;

	jmp	$LN256@data_item
$LN84@data_item:

; 773  :         }
; 774  :         break;
; 775  :     case EXPR_ADDR:
; 776  :         /* since a fixup will be created, 8 bytes is max.
; 777  :          * there's no way to define an initialized tbyte "far64" address,
; 778  :          * because there's no fixup available for the selector part.
; 779  :          */
; 780  :         if ( no_of_bytes > sizeof(uint_64) ) {

	cmp	esi, 8
	jbe	SHORT $LN85@data_item

; 781  :             EmitErr( INVALID_DATA_INITIALIZER, sym ? sym->name : "" );

	test	rbx, rbx
	je	SHORT $LN174@data_item
	mov	rdx, QWORD PTR [rbx+8]
	jmp	SHORT $LN175@data_item
$LN174@data_item:
	lea	rdx, OFFSET FLAT:$SG11458
$LN175@data_item:
	mov	ecx, 231				; 000000e7H
	call	EmitErr

; 782  :             break;

	mov	r10d, DWORD PTR i$[rsp]
	mov	r11d, DWORD PTR total$1$[rsp]
	jmp	$LN256@data_item
$LN85@data_item:

; 783  :         }
; 784  :         /* indirect addressing (incl. stack variables) is invalid */
; 785  :         if ( opndx.indirect == TRUE ) {

	test	BYTE PTR opndx$[rbp-145], 1
	je	SHORT $LN86@data_item
$LN162@data_item:

; 786  :             DebugMsg(("data_item.ADDR: error, indirect=%u, sym=%X\n", opndx.indirect, opndx.sym ));
; 787  :             EmitError( INVALID_USE_OF_REGISTER );

	mov	ecx, 170				; 000000aaH
	call	EmitError

; 788  :             break;

	mov	r10d, DWORD PTR i$[rsp]
	mov	r11d, DWORD PTR total$1$[rsp]
	jmp	$LN256@data_item
$LN86@data_item:

; 789  :         }
; 790  : #if AMD64_SUPPORT
; 791  :         if ( ModuleInfo.Ofssize != USE64 )

	cmp	BYTE PTR ModuleInfo+404, 2
	je	SHORT $LN88@data_item

; 792  : #endif
; 793  :             if ( opndx.hvalue && ( opndx.hvalue != -1 || opndx.value >= 0 ) ) {

	mov	eax, DWORD PTR opndx$[rbp-213]
	test	eax, eax
	je	SHORT $LN88@data_item
	cmp	eax, -1
	jne	$LN89@data_item
	cmp	DWORD PTR opndx$[rbp-217], 0
	jge	$LN89@data_item
$LN88@data_item:

; 800  :             }
; 801  : 
; 802  :         if ( is_float ) {

	cmp	BYTE PTR is_float$[rbp-217], 0
	je	SHORT $LN90@data_item

; 803  :             DebugMsg(("data_item.ADDR: error, is_float=%u\n", is_float ));
; 804  :             EmitError( MUST_USE_FLOAT_INITIALIZER );

	mov	ecx, 212				; 000000d4H
	call	EmitError

; 805  :             break;

	mov	r10d, DWORD PTR i$[rsp]
	mov	r11d, DWORD PTR total$1$[rsp]
	jmp	$LN256@data_item
$LN90@data_item:

; 806  :         }
; 807  : 
; 808  :         total++;

	mov	r11d, DWORD PTR total$1$[rsp]
	inc	r11d
	mov	DWORD PTR total$1$[rsp], r11d

; 809  :         /* for STRUCT fields, don't emit anything! */
; 810  :         if ( inside_struct ) {

	test	cl, cl
	jne	$LN256@data_item

; 811  :             break;
; 812  :         }
; 813  : 
; 814  :         /* determine what type of fixup is to be created */
; 815  : 
; 816  :         switch ( opndx.instr ) {

	mov	eax, DWORD PTR opndx$[rbp-161]
	add	eax, -230				; ffffffffffffff1aH
	cmp	eax, 14
	ja	$LN115@data_item
	lea	rdx, OFFSET FLAT:__ImageBase
	cdqe
	mov	ecx, DWORD PTR $LN242@data_item[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN92@data_item:

; 817  :         case T_SEG:
; 818  :             if ( no_of_bytes < 2 ) {

	cmp	esi, 2
	jae	SHORT $LN93@data_item

; 819  :                 DebugMsg(("data_item.ADDR: error, a SEG wont fit in a BYTE\n" ));
; 820  :                 EmitError( MAGNITUDE_TOO_LARGE_FOR_SPECIFIED_SIZE );

	mov	ecx, 76					; 0000004cH
	call	EmitError
$LN93@data_item:

; 821  :             }
; 822  :             fixup_type = FIX_SEG;

	mov	edi, 8

; 823  :             break;

	jmp	$LN260@data_item
$LN94@data_item:

; 824  :         case T_OFFSET:
; 825  :             switch ( no_of_bytes ) {

	mov	eax, esi
	sub	eax, 1
	je	SHORT $LN95@data_item
	sub	eax, 1
	je	$LN245@data_item
	cmp	eax, 6
	jne	SHORT $LN100@data_item

; 835  :                 }
; 836  :                 break;
; 837  :             case 2:
; 838  :                 fixup_type = FIX_OFF16;
; 839  :                 break;
; 840  : #if AMD64_SUPPORT
; 841  :             case 8:
; 842  :                 if ( ModuleInfo.Ofssize == USE64 ) {

	cmp	BYTE PTR ModuleInfo+404, 2
	jne	SHORT $LN100@data_item

; 843  :                     fixup_type = FIX_OFF64;

	lea	edi, QWORD PTR [rax+1]

; 844  :                     break;

	jmp	$LN260@data_item
$LN100@data_item:

; 845  :                 }
; 846  : #endif
; 847  :             default:
; 848  :                 if ( opndx.sym && ( GetSymOfssize(opndx.sym) == USE16 ) )

	mov	rax, QWORD PTR opndx$[rbp-137]
	test	rax, rax
	je	$LN243@data_item
	mov	rcx, rax
	call	GetSymOfssize
	test	eax, eax
	jne	$LN243@data_item

; 849  :                     fixup_type = FIX_OFF16;

	jmp	$LN245@data_item
$LN95@data_item:

; 826  :             case 1:
; 827  :                 /* forward reference? */
; 828  :                 if ( Parse_Pass == PASS_1 && opndx.sym && opndx.sym->state == SYM_UNDEFINED ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN96@data_item
	mov	rax, QWORD PTR opndx$[rbp-137]
	test	rax, rax
	je	SHORT $LN96@data_item
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN96@data_item

; 829  :                     DebugMsg(("data_item.ADDR: forward reference + OFFSET operator + DB -> may become error in Pass 2\n" ));
; 830  :                     fixup_type = FIX_VOID; /* v2.10: was regression in v2.09 */

	xor	ecx, ecx
	mov	edi, ecx

; 831  :                 } else {

	jmp	$LN156@data_item
$LN96@data_item:

; 832  :                     DebugMsg(("data_item.ADDR: error, an offset wont fit in a BYTE\n" ));
; 833  :                     EmitError( OFFSET_MAGNITUDE_TOO_LARGE );

	mov	ecx, 57					; 00000039H
	call	EmitError
$LN108@data_item:

; 834  :                     fixup_type = FIX_OFF8;

	mov	edi, 4

; 850  :                 else
; 851  :                     fixup_type = FIX_OFF32;
; 852  :                 break;
; 853  :             }
; 854  :             break;

	jmp	$LN260@data_item
$LN104@data_item:

; 855  : #if IMAGERELSUPP
; 856  :         case T_IMAGEREL:
; 857  :             if ( no_of_bytes < sizeof(uint_32) ) {

	cmp	esi, 4
	jae	SHORT $LN105@data_item

; 858  :                 DebugMsg(("data_item.ADDR: IMAGEREL, error, size=%u (should be 4)\n", no_of_bytes ));
; 859  :                 EmitError( OFFSET_MAGNITUDE_TOO_LARGE );

	mov	ecx, 57					; 00000039H
	call	EmitError
$LN105@data_item:

; 860  :             }
; 861  :             fixup_type = FIX_OFF32_IMGREL;

	mov	edi, 12

; 862  :             break;

	jmp	$LN260@data_item
$LN106@data_item:

; 863  : #endif
; 864  : #if SECTIONRELSUPP
; 865  :         case T_SECTIONREL:
; 866  :             if ( no_of_bytes < sizeof(uint_32) ) {

	cmp	esi, 4
	jae	SHORT $LN107@data_item

; 867  :                 DebugMsg(("data_item.ADDR: SECTIONREL, error, size=%u (should be 4)\n", no_of_bytes ));
; 868  :                 EmitError( OFFSET_MAGNITUDE_TOO_LARGE );

	mov	ecx, 57					; 00000039H
	call	EmitError
$LN107@data_item:

; 869  :             }
; 870  :             fixup_type = FIX_OFF32_SECREL;

	mov	edi, 13

; 871  :             break;

	jmp	$LN260@data_item
$LN109@data_item:

; 872  : #endif
; 873  :         case T_LOW:
; 874  :             fixup_type = FIX_OFF8; /* OMF, BIN + GNU-ELF only */
; 875  :             break;
; 876  :         case T_HIGH:
; 877  :             DebugMsg(("data_item.ADDR: HIGH detected\n"));
; 878  :             fixup_type = FIX_HIBYTE; /* OMF only */

	mov	edi, 11

; 879  :             break;

	jmp	$LN260@data_item
$LN110@data_item:

; 880  :         case T_LOWWORD:
; 881  :             fixup_type = FIX_OFF16;

	mov	edi, 5

; 882  :             if ( no_of_bytes < 2 ) {

	cmp	esi, 2
$LN263@data_item:
	jae	$LN260@data_item

; 883  :                 EmitError( MAGNITUDE_TOO_LARGE_FOR_SPECIFIED_SIZE );

	mov	ecx, 76					; 0000004cH
	call	EmitError

; 884  :                 break;

	jmp	$LN260@data_item
$LN112@data_item:

; 885  :             }
; 886  :             break;
; 887  : #if LOHI32
; 888  :         case T_HIGH32:
; 889  :             /* no break */
; 890  : #endif
; 891  :         case T_HIGHWORD:
; 892  :             fixup_type = FIX_VOID;

	xor	eax, eax
	mov	edi, eax

; 893  :             EmitError( CONSTANT_EXPECTED );

	lea	ecx, QWORD PTR [rax+65]
	call	EmitError

; 894  :             break;

	jmp	$LN260@data_item
$LN113@data_item:

; 895  : #if LOHI32
; 896  :         case T_LOW32:
; 897  :             fixup_type = FIX_OFF32;

	mov	edi, 6

; 898  :             if ( no_of_bytes < 4 ) {

	cmp	esi, 4

; 899  :                 EmitError( MAGNITUDE_TOO_LARGE_FOR_SPECIFIED_SIZE );
; 900  :                 break;

	jmp	SHORT $LN263@data_item
$LN115@data_item:

; 901  :             }
; 902  :             break;
; 903  : #endif
; 904  :         default:
; 905  :             /* size < 2 can work with T_LOW|T_HIGH operator only */
; 906  :             if ( no_of_bytes < 2 ) {

	cmp	esi, 2
	jae	SHORT $LN118@data_item

; 907  :                 /* forward reference? */
; 908  :                 if ( Parse_Pass == PASS_1 && opndx.sym && opndx.sym->state == SYM_UNDEFINED )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN117@data_item
	mov	rax, QWORD PTR opndx$[rbp-137]
	test	rax, rax
	je	SHORT $LN119@data_item
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN118@data_item
$LN117@data_item:

; 909  :                     ;
; 910  :                 else {
; 911  :                     /* v2.08: accept 1-byte absolute externals */
; 912  :                     if ( opndx.sym && opndx.sym->state == SYM_EXTERNAL && opndx.is_abs == TRUE ) {

	mov	rax, QWORD PTR opndx$[rbp-137]
	test	rax, rax
	je	SHORT $LN119@data_item
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN119@data_item
	test	BYTE PTR opndx$[rbp-145], 4
	jne	$LN108@data_item
$LN119@data_item:

; 913  :                     } else {
; 914  :                         DebugMsg(("data_item.ADDR: error, no of bytes=%u\n", no_of_bytes ));
; 915  :                         EmitError( MAGNITUDE_TOO_LARGE_FOR_SPECIFIED_SIZE );

	mov	ecx, 76					; 0000004cH
	call	EmitError

; 916  :                     }
; 917  :                     fixup_type = FIX_OFF8;

	mov	edi, 4

; 918  :                     break;

	jmp	$LN260@data_item
$LN118@data_item:

; 919  :                 }
; 920  :             }
; 921  :             /* if the symbol references a segment or group,
; 922  :              then generate a segment fixup.
; 923  :              */
; 924  :             if ( opndx.sym && (opndx.sym->state == SYM_SEG || opndx.sym->state == SYM_GRP ) ) {

	mov	rax, QWORD PTR opndx$[rbp-137]
	test	rax, rax
	je	SHORT $LN121@data_item
	mov	eax, DWORD PTR [rax+32]
	sub	eax, 3
	cmp	eax, 1
	ja	SHORT $LN121@data_item

; 925  :                 fixup_type = FIX_SEG;

	mov	edi, 8

; 926  :                 break;

	jmp	$LN260@data_item
$LN121@data_item:

; 927  :             }
; 928  : 
; 929  :             switch ( no_of_bytes ) {

	cmp	esi, 2
	je	$LN123@data_item
	cmp	esi, 4
	je	SHORT $LN130@data_item
	cmp	esi, 6
	je	SHORT $LN146@data_item

; 1014 :             default:
; 1015 :                 /* Masm generates
; 1016 :                  * off32 if curr segment is 32bit
; 1017 :                  * ptr16 if curr segment is 16bit
; 1018 :                  * HJWasm additionally accepts a FAR32 PTR override
; 1019 :                  * and generates a ptr32 fixup then */
; 1020 :                 if ( opndx.explicit == TRUE && opndx.mem_type == MT_FAR && opndx.Ofssize == USE32 )

	test	BYTE PTR opndx$[rbp-145], 2
	je	SHORT $LN151@data_item
	cmp	DWORD PTR opndx$[rbp-153], 130		; 00000082H
	jne	SHORT $LN151@data_item
	cmp	BYTE PTR opndx$[rbp-148], 1
	jne	SHORT $LN151@data_item

; 1021 :                     fixup_type = FIX_PTR32;

	mov	edi, 10
	jmp	$LN260@data_item
$LN151@data_item:

; 1022 :                 else if( ModuleInfo.Ofssize == USE32 )

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	SHORT $LN153@data_item
$LN243@data_item:

; 1023 :                     fixup_type = FIX_OFF32;

	mov	edi, 6
	jmp	$LN260@data_item
$LN153@data_item:

; 1024 : #if AMD64_SUPPORT
; 1025 :                 else if( ModuleInfo.Ofssize == USE64 )

	cmp	BYTE PTR ModuleInfo+404, 2
	mov	edi, 9
	mov	eax, 7
	cmove	edi, eax

; 1026 :                     fixup_type = FIX_OFF64;
; 1027 : #endif
; 1028 :                 else
; 1029 :                     fixup_type = FIX_PTR16;

	jmp	$LN260@data_item
$LN146@data_item:
	mov	eax, DWORD PTR Options+144
	mov	edi, 6
	add	eax, -2					; fffffffeH
	cmp	eax, 1
	mov	eax, 10
	cmova	edi, eax

; 992  : #endif
; 993  :                             fixup_type = FIX_PTR16;
; 994  :                     else
; 995  :                         fixup_type = FIX_OFF32;
; 996  :                 }
; 997  :                 break;
; 998  :             case 6:
; 999  :                 /* Masm generates a PTR32 fixup in OMF!
; 1000 :                  * and a DIR32 fixup in COFF.
; 1001 :                  */
; 1002 :                 /* COFF/ELF has no far fixups */
; 1003 : #if COFF_SUPPORT || ELF_SUPPORT
; 1004 :                 if ( Options.output_format == OFORMAT_COFF
; 1005 : #if ELF_SUPPORT
; 1006 :                     || Options.output_format == OFORMAT_ELF
; 1007 : #endif
; 1008 :                    ) {
; 1009 :                     fixup_type = FIX_OFF32;
; 1010 :                 } else
; 1011 : #endif
; 1012 :                     fixup_type = FIX_PTR32;
; 1013 :                 break;

	jmp	$LN260@data_item
$LN130@data_item:

; 949  :                 break;
; 950  :             case 4:
; 951  :                 /* masm generates:
; 952  :                  * off32 if curr segment is 32bit,
; 953  :                  * ptr16 if curr segment is 16bit,
; 954  :                  * and ignores type overrides.
; 955  :                  * if it's a NEAR external, size is 16, and
; 956  :                  * format isn't OMF, error 'symbol type conflict'
; 957  :                  * is displayed
; 958  :                  */
; 959  :                 if ( opndx.explicit == TRUE ) {

	test	BYTE PTR opndx$[rbp-145], 2
	je	SHORT $LN131@data_item

; 960  :                     if ( opndx.mem_type == MT_FAR ) {

	mov	eax, DWORD PTR opndx$[rbp-153]
	cmp	eax, 130				; 00000082H
	jne	SHORT $LN133@data_item
	movzx	eax, BYTE PTR opndx$[rbp-148]
	add	al, 2
	test	al, 253					; 000000fdH
	je	SHORT $LN135@data_item

; 961  :                         if ( opndx.Ofssize != USE_EMPTY && opndx.Ofssize != USE16 ) {
; 962  :                             DebugMsg(("data_item.ADDR: error, FAR32 won't fit in a DWORD\n" ));
; 963  :                             EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" );

	mov	rax, QWORD PTR opndx$[rbp-137]
	test	rax, rax
	je	SHORT $LN180@data_item
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 172				; 000000acH
	call	EmitErr

; 964  :                         }
; 965  :                         fixup_type = FIX_PTR16;

	mov	edi, 9
	jmp	$LN260@data_item
$LN180@data_item:

; 961  :                         if ( opndx.Ofssize != USE_EMPTY && opndx.Ofssize != USE16 ) {
; 962  :                             DebugMsg(("data_item.ADDR: error, FAR32 won't fit in a DWORD\n" ));
; 963  :                             EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" );

	lea	rdx, OFFSET FLAT:$SG11511
	mov	ecx, 172				; 000000acH
	call	EmitErr
$LN135@data_item:

; 964  :                         }
; 965  :                         fixup_type = FIX_PTR16;

	mov	edi, 9
	jmp	$LN260@data_item
$LN133@data_item:

; 966  :                     } else if ( opndx.mem_type == MT_NEAR ) {

	cmp	eax, 129				; 00000081H
	jne	$LN260@data_item

; 967  :                         if ( opndx.Ofssize == USE16 )

	cmp	BYTE PTR opndx$[rbp-148], 0
	jne	$LN100@data_item

; 968  :                             fixup_type = FIX_OFF16;

	jmp	$LN245@data_item
$LN131@data_item:

; 969  :                         else if ( opndx.sym && ( GetSymOfssize( opndx.sym ) == USE16 ) )
; 970  :                             fixup_type = FIX_OFF16;
; 971  :                         else
; 972  :                             fixup_type = FIX_OFF32;
; 973  :                     }
; 974  :                 } else {
; 975  :                     /* what's done if code size is 16 is Masm-compatible.
; 976  :                      * It's not very smart, however.
; 977  :                      * A better strategy is to choose fixup type depending
; 978  :                      * on the symbol's offset size.
; 979  :                      */
; 980  :                     //if ( opndx.sym && ( GetSymOfssize( opndx.sym ) == USE16 ) )
; 981  :                     if ( ModuleInfo.Ofssize == USE16 )

	cmp	BYTE PTR ModuleInfo+404, 0
	jne	$LN243@data_item

; 982  : #if COFF_SUPPORT || ELF_SUPPORT
; 983  :                         if ( opndx.mem_type == MT_NEAR &&

	cmp	DWORD PTR opndx$[rbp-153], 129		; 00000081H
	jne	SHORT $LN135@data_item
	mov	eax, DWORD PTR Options+144
	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	SHORT $LN135@data_item

; 984  :                             ( Options.output_format == OFORMAT_COFF
; 985  : #if ELF_SUPPORT
; 986  :                              || Options.output_format == OFORMAT_ELF
; 987  : #endif
; 988  :                             )) {
; 989  :                             fixup_type = FIX_OFF16;
; 990  :                             EmitErr( SYMBOL_TYPE_CONFLICT, sym->name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 136				; 00000088H
	mov	edi, 5
	call	EmitErr

; 991  :                         } else

	jmp	$LN260@data_item
$LN123@data_item:

; 930  :             case 2:
; 931  :                 /* accept "near16" override, else complain
; 932  :                  * if symbol's offset is 32bit */
; 933  :                 /* v2.06: if condition changed */
; 934  :                 //if ( opndx.explicit == TRUE && opndx.mem_type == MT_NEAR && opndx.Ofssize == USE16 )
; 935  :                 if ( opndx.explicit == TRUE ) {

	test	BYTE PTR opndx$[rbp-145], 2
	je	SHORT $LN124@data_item

; 936  :                     if ( SizeFromMemtype( opndx.mem_type, opndx.Ofssize, opndx.type ) > no_of_bytes ) {

	movzx	edx, BYTE PTR opndx$[rbp-148]
	mov	r8, QWORD PTR opndx$[rbp-121]
	mov	ecx, DWORD PTR opndx$[rbp-153]
	call	SizeFromMemtype
	cmp	eax, 2
	jbe	SHORT $LN245@data_item

; 937  :                         DebugMsg(("data_item.ADDR: error, memtype %X wont fit in a WORD\n", opndx.mem_type));
; 938  :                         EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" );

	mov	rax, QWORD PTR opndx$[rbp-137]
	test	rax, rax
	je	SHORT $LN176@data_item
	mov	rdx, QWORD PTR [rax+8]
	jmp	SHORT $LN179@data_item
$LN176@data_item:
	lea	rdx, OFFSET FLAT:$SG11500

; 939  :                     };

	jmp	SHORT $LN179@data_item
$LN124@data_item:

; 940  :                 } else if ( opndx.sym && opndx.sym->state == SYM_EXTERNAL && opndx.is_abs == TRUE ) {

	mov	rax, QWORD PTR opndx$[rbp-137]
	test	rax, rax
	je	SHORT $LN245@data_item
	mov	ecx, DWORD PTR [rax+32]
	cmp	ecx, 2
	jne	SHORT $LN127@data_item
	test	BYTE PTR opndx$[rbp-145], 4
	jne	SHORT $LN245@data_item
$LN127@data_item:

; 941  :                     /* v2.07a: accept ABSolute externals (regression in v2.07) */
; 942  :                 } else if ( opndx.sym &&
; 943  :                            opndx.sym->state != SYM_UNDEFINED &&

	test	ecx, ecx
	je	SHORT $LN245@data_item
	mov	rcx, QWORD PTR opndx$[rbp-137]
	call	GetSymOfssize
	test	eax, eax
	jle	SHORT $LN245@data_item

; 944  :                            ( GetSymOfssize(opndx.sym) > USE16 ) ) {
; 945  :                     DebugMsg(("data_item.ADDR: error, a 32bit offset (%s) wont fit in a WORD\n", opndx.sym->name));
; 946  :                     EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" );

	mov	rax, QWORD PTR opndx$[rbp-137]
	test	rax, rax
	je	SHORT $LN178@data_item
	mov	rdx, QWORD PTR [rax+8]
	jmp	SHORT $LN179@data_item
$LN178@data_item:
	lea	rdx, OFFSET FLAT:$SG11504
$LN179@data_item:
	mov	ecx, 172				; 000000acH
	call	EmitErr
$LN245@data_item:

; 947  :                 }
; 948  :                 fixup_type = FIX_OFF16;

	mov	edi, 5
$LN260@data_item:
	xor	ecx, ecx
$LN156@data_item:

; 1030 :             }
; 1031 :             break;
; 1032 :         } /* end switch ( opndx.instr ) */
; 1033 : 
; 1034 :         /* v2.07: fixup type check moved here */
; 1035 :         if ( ( 1 << fixup_type ) & ModuleInfo.fmtopt->invalid_fixup_type ) {

	mov	rdx, QWORD PTR ModuleInfo+344
	movsx	eax, WORD PTR [rdx+8]
	bt	eax, edi
	jb	$LN212@data_item

; 1037 :                     ModuleInfo.fmtopt->formatname,
; 1038 :                     opndx.sym ? opndx.sym->name : szNull ) );
; 1039 :         }
; 1040 :         fixup = NULL;
; 1041 :         if ( write_to_file ) {

	cmp	BYTE PTR write_to_file, 0
	mov	rax, rcx
	je	SHORT $LN158@data_item

; 1042 :             /* there might be a segment override:
; 1043 :              * a segment, a group or a segment register.
; 1044 :              * Init var SegOverride, it's used inside set_frame()
; 1045 :              */
; 1046 :             SegOverride = NULL;

	mov	QWORD PTR SegOverride, rcx

; 1047 :             segm_override( &opndx, NULL );

	xor	edx, edx
	lea	rcx, QWORD PTR opndx$[rbp-217]
	call	segm_override

; 1048 : 
; 1049 :             /* set global vars Frame and Frame_Datum */
; 1050 :             /* opndx.sym may be NULL, then SegOverride is set. */
; 1051 :             if ( ModuleInfo.offsettype == OT_SEGMENT &&

	cmp	DWORD PTR ModuleInfo+384, 2
	jne	SHORT $LN159@data_item
	mov	eax, DWORD PTR opndx$[rbp-161]
	cmp	eax, 241				; 000000f1H
	je	SHORT $LN161@data_item
	cmp	eax, 244				; 000000f4H
	jne	SHORT $LN159@data_item
$LN161@data_item:

; 1052 :                 ( opndx.instr == T_OFFSET || opndx.instr == T_SEG ))
; 1053 :                 set_frame2( opndx.sym );

	mov	rcx, QWORD PTR opndx$[rbp-137]
	call	set_frame2
	jmp	SHORT $LN160@data_item
$LN159@data_item:

; 1054 :             else
; 1055 :                 set_frame( opndx.sym );

	mov	rcx, QWORD PTR opndx$[rbp-137]
	call	set_frame
$LN160@data_item:

; 1056 :             /* uses Frame and Frame_Datum  */
; 1057 :             fixup = CreateFixup( opndx.sym, fixup_type, OPTJ_NONE );

	mov	rcx, QWORD PTR opndx$[rbp-137]
	xor	r8d, r8d
	mov	edx, edi
	call	CreateFixup
$LN158@data_item:

; 1058 :             //store_fixup( fixup, &opndx.value ); /* may fail, but ignore error! */
; 1059 :         }
; 1060 :         OutputBytes( (unsigned char *)&opndx.value, no_of_bytes, fixup );

	mov	r8, rax
	lea	rcx, QWORD PTR opndx$[rbp-217]
	mov	edx, esi
	call	OutputBytes

; 1061 :         break;

	mov	r10d, DWORD PTR i$[rsp]
	mov	r11d, DWORD PTR total$1$[rsp]
	jmp	$LN256@data_item
$LN59@data_item:

; 675  :     case EXPR_CONST:
; 676  :         if ( is_float ) {

	cmp	BYTE PTR is_float$[rbp-217], 0
	jne	$LN213@data_item

; 678  :         }
; 679  : 
; 680  :         /* a string returned by the evaluator (enclosed in quotes!)? */
; 681  : 
; 682  :         if ( opndx.quoted_string ) {

	mov	rdx, QWORD PTR opndx$[rbp-201]
	test	rdx, rdx
	je	$LN61@data_item

; 683  :             DebugMsg1(("data_item.CONST: string found: >%s<, inside_struct=%u, no_of_bytes=%u, curr_ofs=%X\n",
; 684  :                        opndx.quoted_string->string_ptr, inside_struct, no_of_bytes, GetCurrOffset()));
; 685  :             pchar = (uint_8 *)opndx.quoted_string->string_ptr + 1;

	mov	r9, QWORD PTR [rdx+8]

; 686  :             string_len = opndx.quoted_string->stringlen; /* this is the length without quotes */

	mov	ebx, DWORD PTR [rdx+16]
	inc	r9

; 687  : 
; 688  :             /* v2.07: check for empty string for ALL types */
; 689  :             if ( string_len == 0 ) {

	test	ebx, ebx
	jne	SHORT $LN251@data_item

; 690  :                 if ( inside_struct ) {

	test	cl, cl
	je	$LN64@data_item

; 691  :                     /* when the struct is declared, it's no error -
; 692  :                      * but won't be accepted when the struct is instanced.
; 693  :                      * v2.07: don't modify string_len! Instead
; 694  :                      * mark field as array!
; 695  :                      */
; 696  :                     //string_len = 1;
; 697  :                     sym->isarray = TRUE;

	mov	rax, QWORD PTR sym$[rbp-217]
	or	BYTE PTR [rax+41], 2
	jmp	SHORT $LN65@data_item
$LN251@data_item:
	mov	rax, QWORD PTR sym$[rbp-217]
$LN65@data_item:

; 700  :                 }
; 701  :             }
; 702  :             /* a string is only regarded as an array if item size is 1 */
; 703  :             /* else it is regarded as ONE item */
; 704  :             if( no_of_bytes != 1 ) {

	cmp	esi, 1
	je	SHORT $LN67@data_item

; 705  :                 if( string_len > no_of_bytes ) {

	cmp	ebx, esi
	ja	$LN214@data_item
$LN67@data_item:

; 711  :                 total++;

	mov	r11d, DWORD PTR total$1$[rsp]
	test	rax, rax
	je	SHORT $LN247@data_item

; 707  :                 }
; 708  :             }
; 709  : 
; 710  :             if( sym && Parse_Pass == PASS_1 && string_len > 0 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN247@data_item
	test	ebx, ebx
	jle	SHORT $LN247@data_item

; 711  :                 total++;

	inc	r11d
	mov	DWORD PTR total$1$[rsp], r11d

; 712  :                 if ( no_of_bytes == 1 && string_len > 1 ) {

	cmp	esi, 1
	jne	SHORT $LN247@data_item
	cmp	ebx, esi
	jle	SHORT $LN247@data_item

; 713  :                     total += ( string_len - 1 );
; 714  :                     sym->isarray = TRUE; /* v2.07: added */

	or	BYTE PTR [rax+41], 2
	dec	r11d
	add	r11d, ebx

; 715  :                     if ( first ) {

	cmp	BYTE PTR first$[rbp-217], 0
	mov	DWORD PTR total$1$[rsp], r11d
	je	SHORT $LN247@data_item

; 716  :                         sym->first_length = 1;

	mov	DWORD PTR [rax+48], esi

; 717  :                         sym->first_size = 1;

	mov	DWORD PTR [rax+44], esi

; 718  :                         first = FALSE; /* avoid to touch first_xxx fields below */

	mov	BYTE PTR first$[rbp-217], 0
$LN247@data_item:

; 719  :                     }
; 720  :                 }
; 721  :             }
; 722  : 
; 723  :             if( !inside_struct ) {

	test	cl, cl
	jne	SHORT $LN252@data_item

; 724  :                 /* anything bigger than a byte must be stored in little-endian
; 725  :                  * format -- LSB first */
; 726  :                 if ( string_len > 1 && no_of_bytes > 1 )

	cmp	ebx, 1
	jle	SHORT $LN72@data_item
	cmp	esi, 1
	jbe	SHORT $LN72@data_item

; 727  :                     pchar = little_endian( (const char *)pchar, string_len );

	mov	r8, QWORD PTR ModuleInfo+488
	mov	edx, ebx
	cmp	ebx, 1
	jbe	SHORT $LN192@data_item
	npad	7
$LL193@data_item:
	dec	edx
	movzx	eax, BYTE PTR [r9+rdx]
	mov	BYTE PTR [r8], al
	movzx	eax, BYTE PTR [r9]
	inc	r9
	mov	BYTE PTR [r8+rdx], al
	inc	r8
	dec	edx
	cmp	edx, 1
	ja	SHORT $LL193@data_item
$LN192@data_item:
	test	edx, edx
	je	SHORT $LN194@data_item
	movzx	eax, BYTE PTR [r9]
	mov	BYTE PTR [r8], al
$LN194@data_item:
	mov	r9, QWORD PTR ModuleInfo+488
$LN72@data_item:

; 728  :                 OutputDataBytes( pchar, string_len );

	xor	r8d, r8d
	mov	edx, ebx
	mov	rcx, r9
	call	OutputBytes

; 729  :                 if ( no_of_bytes > string_len )

	cmp	esi, ebx
	jbe	SHORT $LN249@data_item

; 730  :                     FillDataBytes( 0, no_of_bytes - string_len );

	mov	edx, esi
	xor	ecx, ecx
	sub	edx, ebx
	call	FillDataBytes
$LN249@data_item:

; 731  :             }
; 732  :         } else {

	mov	r10d, DWORD PTR i$[rsp]
	mov	r11d, DWORD PTR total$1$[rsp]
$LN252@data_item:
	mov	rbx, QWORD PTR sym$[rbp-217]
$LN256@data_item:
	mov	r8, QWORD PTR tokenarray$[rbp-217]
$item_done$266:

; 1068 :     } /* end switch (opndx.kind) */
; 1069 : item_done:
; 1070 :     if( sym && first && Parse_Pass == PASS_1 ) {

	test	rbx, rbx
	je	SHORT $LN164@data_item
	cmp	BYTE PTR first$[rbp-217], 0
	je	SHORT $LN164@data_item
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN164@data_item

; 1071 :         sym->first_length = total;
; 1072 :         sym->first_size = total * no_of_bytes;

	mov	eax, r11d
	mov	DWORD PTR [rbx+48], r11d
	imul	eax, esi
	mov	DWORD PTR [rbx+44], eax
$LN164@data_item:

; 1073 :     }
; 1074 :     if( i < end && tokenarray[i].token == T_COMMA ) {

	cmp	r10d, DWORD PTR end$[rbp-217]
	jge	$LN2@data_item
	movsxd	rax, r10d
	shl	rax, 5
	cmp	BYTE PTR [rax+r8], 44			; 0000002cH
	jne	$LN2@data_item

; 1075 :         i++;

	inc	r10d

; 1076 :         if ( tokenarray[i].token != T_FINAL &&

	movsxd	rax, r10d
	shl	rax, 5
	mov	DWORD PTR i$[rsp], r10d
	movzx	ecx, BYTE PTR [rax+r8]
	test	cl, cl
	je	$LN2@data_item
	cmp	cl, 41					; 00000029H
	je	$LN2@data_item

; 1077 :             tokenarray[i].token != T_CL_BRACKET ) {
; 1078 :             first = FALSE;

	mov	BYTE PTR first$[rbp-217], 0

; 1079 :             if ( sym )

	test	rbx, rbx
	je	$next_item$265

; 1080 :                 sym->isarray = TRUE;

	or	BYTE PTR [rbx+41], 2

; 1081 :             goto next_item;

	jmp	$next_item$265
$LN61@data_item:

; 733  :             /* it's NOT a string */
; 734  :             DebugMsg1(("data_item.CONST: const found, value=%" I32_SPEC "Xh, no_of_bytes=%u, curr_ofs=%" I32_SPEC "X\n", opndx.value, no_of_bytes, GetCurrOffset()));
; 735  :             if( !inside_struct ) {

	test	cl, cl
	jne	$LN58@data_item

; 736  :                 /* the evaluator cannot handle types with size > 16.
; 737  :                  * so if a (simple) type is larger ( YMMWORD? ),
; 738  :                  * clear anything which is above.
; 739  :                  */
; 740  :                 if ( no_of_bytes > 16 ) {

	cmp	esi, 16
	jbe	SHORT $LN75@data_item

; 741  :                     OutputDataBytes( opndx.chararray, 16 );

	xor	r8d, r8d
	lea	rcx, QWORD PTR opndx$[rbp-217]
	lea	edx, QWORD PTR [r8+16]
	call	OutputBytes

; 742  :                     tmp = ( opndx.chararray[15] < 0x80 ? 0 : 0xFF );

	cmp	BYTE PTR opndx$[rbp-202], 128		; 00000080H

; 743  :                     FillDataBytes( tmp, no_of_bytes - 16 );

	lea	edx, DWORD PTR [rsi-16]
	mov	ecx, 0
	mov	eax, 255				; 000000ffH
	cmovb	eax, ecx
	movzx	ecx, al
	call	FillDataBytes
	mov	r11d, DWORD PTR total$1$[rsp]
	mov	r10d, DWORD PTR i$[rsp]
	inc	r11d
	mov	DWORD PTR total$1$[rsp], r11d
	jmp	$LN256@data_item
$LN75@data_item:

; 744  :                 } else {
; 745  :                     /* v2.06: TBYTE/OWORD/XMMWORD: extend a negative value to 16-byte */
; 746  :                     if ( no_of_bytes > sizeof( int_64 ) ) {

	cmp	esi, 8
	jbe	SHORT $LN78@data_item

; 747  :                         if ( opndx.negative && opndx.value64 < 0 && opndx.hlvalue == 0 )

	test	BYTE PTR opndx$[rbp-145], 32		; 00000020H
	je	SHORT $LN78@data_item
	cmp	QWORD PTR opndx$[rbp-217], 0
	jge	SHORT $LN78@data_item
	mov	rax, QWORD PTR opndx$[rbp-209]
	mov	rcx, -1
	test	rax, rax
	cmove	rax, rcx
	mov	QWORD PTR opndx$[rbp-209], rax
$LN78@data_item:

; 748  :                             opndx.hlvalue = -1;
; 749  :                     }
; 750  :                     OutputDataBytes( opndx.chararray, no_of_bytes );

	xor	r8d, r8d
	lea	rcx, QWORD PTR opndx$[rbp-217]
	mov	edx, esi
	call	OutputBytes

; 751  :                     /* check that there's no significant data left
; 752  :                      * which hasn't been emitted.
; 753  :                      */
; 754  :                     /* v2.06: rewritten, now more rigid and checks
; 755  :                      * 1-8 and 10 bytes instead of just 1-4.
; 756  :                      */
; 757  :                     if ( no_of_bytes <= sizeof( int_64 ) ) {

	cmp	esi, 8
	ja	SHORT $LN79@data_item

; 758  :                         tmp = ( opndx.chararray[7] < 0x80 ? 0 : 0xFF );

	cmp	BYTE PTR opndx$[rbp-210], 128		; 00000080H

; 759  :                         memset( opndx.chararray, tmp, no_of_bytes );

	lea	rcx, QWORD PTR opndx$[rbp-217]
	mov	r8, rsi
	sbb	edx, edx
	neg	edx
	dec	edx
	call	memset
	mov	rax, QWORD PTR opndx$[rbp-217]
	inc	rax
	test	rax, -2
	je	$LN248@data_item

; 760  :                         if ( opndx.llvalue != 0 && opndx.llvalue != -1 ) {
; 761  :                             DebugMsg(("data_item.CONST: error, unhandled data is %" I64_SPEC "X_%016" I64_SPEC "X\n", opndx.hlvalue, opndx.llvalue));
; 762  :                             return( EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" ) );

	mov	rax, QWORD PTR opndx$[rbp-137]
	test	rax, rax
	je	$LN170@data_item
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 172				; 000000acH
	call	EmitErr
	jmp	$LN1@data_item
$LN79@data_item:

; 763  :                         }
; 764  :                     } else if ( no_of_bytes == 10 ) {

	cmp	esi, 10
	jne	$LN248@data_item
	mov	rax, QWORD PTR opndx$[rbp-209]
	add	rax, -65536				; ffffffffffff0000H
	cmp	rax, -131072				; fffffffffffe0000H
	jbe	$LN216@data_item

; 768  :                         }
; 769  :                     }
; 770  :                 }
; 771  :             }
; 772  :             total++;

	mov	r11d, DWORD PTR total$1$[rsp]
	mov	r10d, DWORD PTR i$[rsp]
	inc	r11d
	mov	DWORD PTR total$1$[rsp], r11d
	jmp	$LN256@data_item
$LN2@data_item:

; 477  :     //unsigned int        count;
; 478  :     uint_8              *pchar;
; 479  :     char                tmp;
; 480  :     enum fixup_types    fixup_type;
; 481  :     struct fixup        *fixup;
; 482  :     struct expr         opndx;
; 483  : 
; 484  :     DebugMsg1(("data_item( idx=%u [%s], label=%s, no_of_bytes=%" I32_SPEC "u, type=%s, dup=%" I32_SPEC "Xh, inside_struct=%u, is_float=%u ) enter\n",
; 485  :                *start_pos, tokenarray[*start_pos].tokpos, sym ? sym->name : "NULL",
; 486  :                no_of_bytes, type_sym ? type_sym->name : "NULL",
; 487  :                dup, inside_struct, is_float ));
; 488  : 
; 489  :     for ( ; dup; dup-- ) {

	add	DWORD PTR dup$[rbp-217], -1		; ffffffffH
	mov	rcx, QWORD PTR start_pos$[rbp-217]
	je	$LN3@data_item
	jmp	$LL4@data_item
$LN209@data_item:

; 596  :             DebugMsg(("data_item: error 'missing ')', exit\n"));
; 597  :             return( EmitErr( EXPECTED, ")" ) );

	lea	rdx, OFFSET FLAT:$SG11412
	mov	ecx, 230				; 000000e6H
	call	EmitErr
	jmp	$LN1@data_item
$LN207@data_item:

; 570  :             DebugMsg(("data_item error, missing '('\n"));
; 571  :             return( EmitErr( EXPECTED, "(" ) );

	lea	rdx, OFFSET FLAT:$SG11402
	mov	ecx, 230				; 000000e6H
	call	EmitErr
	jmp	$LN1@data_item
$LN206@data_item:

; 566  :             return( EmitError( COUNT_MUST_BE_POSITIVE_OR_ZERO ) );

	mov	ecx, 208				; 000000d0H
	call	EmitError
	jmp	$LN1@data_item
$LN205@data_item:

; 556  :             DebugMsg(("data_item, error, unexpected kind=%u of DUP's first operand\n", opndx.kind ));
; 557  :             /* v2.09: emit a better error msg if a forward ref was used */
; 558  :             if ( opndx.sym && opndx.sym->state == SYM_UNDEFINED )

	mov	rdx, QWORD PTR opndx$[rbp-137]
	test	rdx, rdx
	je	SHORT $LN32@data_item
	cmp	DWORD PTR [rdx+32], 0
	jne	SHORT $LN32@data_item

; 559  :                 EmitErr( SYMBOL_NOT_DEFINED, opndx.sym->name );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr

; 562  :             return( ERROR );

	or	rax, -1
	jmp	$LN1@data_item
$LN32@data_item:

; 560  :             else
; 561  :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError
$LN203@data_item:

; 562  :             return( ERROR );

	or	rax, -1
	jmp	$LN1@data_item
$LN210@data_item:

; 623  :             DebugMsg1(("data_item: error, type=%s needs literal, >%s<\n", type_sym->name, tokenarray[i].tokpos ));
; 624  :             return( EmitErr( STRUCTURE_IMPROPERLY_INITIALIZED, type_sym->name ) );

	mov	rax, QWORD PTR type_sym$[rbp-217]
	mov	ecx, 229				; 000000e5H
	mov	rdx, QWORD PTR [rax+8]
	call	EmitErr
	jmp	$LN1@data_item
$LN211@data_item:

; 1062 :     case EXPR_REG:
; 1063 :         EmitError( INVALID_USE_OF_REGISTER );
; 1064 :         break;
; 1065 :     default: /* unknown opndx.kind, shouldn't happen */
; 1066 :         DebugMsg(("data_item: error, opndx.kind=%u\n", opndx.kind ));
; 1067 :         return( EmitError( SYNTAX_ERROR ) );

	mov	ecx, 45					; 0000002dH
	call	EmitError
	jmp	$LN1@data_item
$LN89@data_item:

; 794  :                 /* v2.05: compared to Masm, the above is too restrictive.
; 795  :                  * the line below might be better.
; 796  :                  */
; 797  :                 //if ( opndx.hvalue != 0 && ( opndx.hvalue != -1 || opndx.value == 0 ) ) {
; 798  :                 DebugMsg(("data_item.ADDR: displacement doesn't fit in 32 bits: %" I64_SPEC "X\n", opndx.value64 ));
; 799  :                 return( EmitConstError( &opndx ) );

	lea	rcx, QWORD PTR opndx$[rbp-217]
	call	EmitConstError
	jmp	$LN1@data_item
$LN212@data_item:

; 1036 :             return( EmitErr( UNSUPPORTED_FIXUP_TYPE,

	mov	rax, QWORD PTR opndx$[rbp-137]
	test	rax, rax
	je	SHORT $LN182@data_item
	mov	r8, QWORD PTR [rax+8]
	add	rdx, 10
	mov	ecx, 197				; 000000c5H
	call	EmitErr
	jmp	$LN1@data_item
$LN182@data_item:
	lea	r8, OFFSET FLAT:szNull
	add	rdx, 10
	mov	ecx, 197				; 000000c5H
	call	EmitErr
	jmp	$LN1@data_item
$LN64@data_item:

; 698  :                 } else {
; 699  :                     return( EmitError( EMPTY_STRING ) ); /* MASM doesn't like "" */

	mov	ecx, 163				; 000000a3H
	call	EmitError
	jmp	$LN1@data_item
$LN214@data_item:

; 706  :                     return( EmitError( INITIALIZER_OUT_OF_RANGE ) );

	mov	ecx, 55					; 00000037H
	call	EmitError
	jmp	$LN1@data_item
$LN170@data_item:

; 760  :                         if ( opndx.llvalue != 0 && opndx.llvalue != -1 ) {
; 761  :                             DebugMsg(("data_item.CONST: error, unhandled data is %" I64_SPEC "X_%016" I64_SPEC "X\n", opndx.hlvalue, opndx.llvalue));
; 762  :                             return( EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" ) );

	lea	rdx, OFFSET FLAT:$SG11452
	mov	ecx, 172				; 000000acH
	call	EmitErr
	jmp	$LN1@data_item
$LN216@data_item:

; 765  :                         //if ( opndx.hlvalue > 0xffff ) {
; 766  :                         if ( opndx.hlvalue > 0xffff && opndx.hlvalue < -0xffff ) {
; 767  :                             return( EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" ) );

	mov	rax, QWORD PTR opndx$[rbp-137]
	test	rax, rax
	je	SHORT $LN172@data_item
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 172				; 000000acH
	call	EmitErr
	jmp	SHORT $LN1@data_item
$LN172@data_item:
	lea	rdx, OFFSET FLAT:$SG11455
	mov	ecx, 172				; 000000acH
	call	EmitErr
	jmp	SHORT $LN1@data_item
$LN213@data_item:

; 677  :             return( EmitError( MUST_USE_FLOAT_INITIALIZER ) );

	mov	ecx, 212				; 000000d4H
	call	EmitError
	jmp	SHORT $LN1@data_item
$LN54@data_item:

; 661  :     case EXPR_EMPTY:
; 662  :         DebugMsg(("data_item.EMPTY: idx=%u, tokenarray.token=%X\n", i, tokenarray[i].token));
; 663  :         if ( tokenarray[i].token != T_FINAL )

	mov	rcx, QWORD PTR tokenarray$[rbp-217]
	movsxd	rax, r10d
	shl	rax, 5
	cmp	BYTE PTR [rax+rcx], 0
	je	SHORT $LN55@data_item

; 664  :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );

	mov	rdx, QWORD PTR [rax+rcx+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	or	rax, -1
	jmp	SHORT $LN1@data_item
$LN55@data_item:

; 665  :         else
; 666  :             EmitError( SYNTAX_ERROR );

	mov	ecx, 45					; 0000002dH
	call	EmitError

; 667  :         return( ERROR );

	or	rax, -1
	jmp	SHORT $LN1@data_item
$LN250@data_item:

; 546  :             return( ERROR );

	mov	r10d, DWORD PTR i$[rsp]
$LN3@data_item:

; 1082 :         }
; 1083 :     }
; 1084 : 
; 1085 :     } /* end for */
; 1086 : 
; 1087 :     if( sym && Parse_Pass == PASS_1 ) {

	test	rbx, rbx
	je	SHORT $LN168@data_item
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN168@data_item

; 1088 :         sym->total_length += total;

	add	DWORD PTR [rbx+64], r11d

; 1089 :         sym->total_size += total * no_of_bytes;

	imul	r11d, esi
	add	DWORD PTR [rbx+56], r11d
$LN168@data_item:

; 1090 :     }
; 1091 : 
; 1092 :     *start_pos = i;

	mov	DWORD PTR [rcx], r10d

; 1093 :     DebugMsg1(("data_item: exit, no error, i=%d\n", i));
; 1094 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@data_item:

; 1095 : }

	mov	rbx, QWORD PTR [rsp+296]
	add	rsp, 240				; 000000f0H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
	npad	1
$LN242@data_item:
	DD	$LN109@data_item
	DD	$LN112@data_item
	DD	$LN112@data_item
	DD	$LN104@data_item
	DD	$LN115@data_item
	DD	$LN115@data_item
	DD	$LN108@data_item
	DD	$LN113@data_item
	DD	$LN110@data_item
	DD	$LN115@data_item
	DD	$LN115@data_item
	DD	$LN94@data_item
	DD	$LN115@data_item
	DD	$LN106@data_item
	DD	$LN92@data_item
data_item ENDP
_TEXT	ENDS
END
