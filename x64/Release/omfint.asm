; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG7749	DB	'omfint.c', 00H
	ORG $+7
$SG7856	DB	'omfint.c', 00H
_DATA	ENDS
PUBLIC	omf_write_record
EXTRN	fwrite:PROC
EXTRN	Fatal:PROC
EXTRN	WriteError:PROC
EXTRN	__chkstk:PROC
EXTRN	memcpy:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	__ImageBase:BYTE
pdata	SEGMENT
$pdata$omf_write_record DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$omf_write_record
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$safeWrite DD imagerel safeWrite
	DD	imagerel safeWrite+52
	DD	imagerel $unwind$safeWrite
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$WEndRec DD imagerel WEndRec
	DD	imagerel WEndRec+331
	DD	imagerel $unwind$WEndRec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PutMem DD imagerel PutMem
	DD	imagerel PutMem+92
	DD	imagerel $unwind$PutMem
pdata	ENDS
pdata	SEGMENT
$pdata$writeMisc DD imagerel writeMisc
	DD	imagerel writeMisc+99
	DD	imagerel $unwind$writeMisc
$pdata$writeMisc32 DD imagerel writeMisc32
	DD	imagerel writeMisc32+102
	DD	imagerel $unwind$writeMisc32
$pdata$writeComent DD imagerel writeComent
	DD	imagerel writeComent+129
	DD	imagerel $unwind$writeComent
$pdata$writeSegdef DD imagerel writeSegdef
	DD	imagerel writeSegdef+293
	DD	imagerel $unwind$writeSegdef
$pdata$writeLedata DD imagerel writeLedata
	DD	imagerel writeLedata+178
	DD	imagerel $unwind$writeLedata
$pdata$writeTheadr DD imagerel writeTheadr
	DD	imagerel writeTheadr+99
	DD	imagerel $unwind$writeTheadr
$pdata$writeModend DD imagerel writeModend
	DD	imagerel writeModend+161
	DD	imagerel $unwind$writeModend
$pdata$writePubdef DD imagerel writePubdef
	DD	imagerel writePubdef+125
	DD	imagerel $unwind$writePubdef
$pdata$writeLinnum DD imagerel writeLinnum
	DD	imagerel writeLinnum+124
	DD	imagerel $unwind$writeLinnum
$pdata$writeComdat DD imagerel writeComdat
	DD	imagerel writeComdat+277
	DD	imagerel $unwind$writeComdat
$pdata$writeLinsym DD imagerel writeLinsym
	DD	imagerel writeLinsym+160
	DD	imagerel $unwind$writeLinsym
$pdata$writeUnexp DD imagerel writeUnexp
	DD	imagerel writeUnexp+34
	DD	imagerel $unwind$writeUnexp
pdata	ENDS
CONST	SEGMENT
myFuncs	DQ	FLAT:writeUnexp
	DQ	FLAT:writeMisc
	DQ	FLAT:writeMisc32
	DQ	FLAT:writeSegdef
	DQ	FLAT:writeLedata
	DQ	FLAT:writeComent
	DQ	FLAT:writeTheadr
	DQ	FLAT:writeModend
	DQ	FLAT:writePubdef
	DQ	FLAT:writeLinnum
	DQ	FLAT:writeComdat
	DQ	FLAT:writeLinsym
func_index DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	05H
	DB	07H
	DB	01H
	DB	00H
	DB	08H
	DB	00H
	DB	09H
	DB	01H
	DB	03H
	DB	01H
	DB	02H
	DB	00H
	DB	04H
	DB	04H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	02H
	DB	01H
	DB	08H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	0aH
	DB	0bH
	DB	01H
	DB	02H
	DB	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PutMem DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WEndRec DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$safeWrite DD 020601H
	DD	030023206H
xdata	ENDS
xdata	SEGMENT
$unwind$omf_write_record DD 020d01H
	DD	0205010dH
$unwind$writeMisc DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$writeMisc32 DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$writeComent DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$writeSegdef DD 010401H
	DD	04204H
$unwind$writeLedata DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$writeTheadr DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$writeModend DD 043401H
	DD	067434H
	DD	030023206H
$unwind$writePubdef DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$writeLinnum DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$writeComdat DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$writeLinsym DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$writeUnexp DD 010401H
	DD	04204H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeUnexp PROC

; 456  : {

	sub	rsp, 40					; 00000028H

; 457  :     DebugMsg(("unexpected OMF record type 0x%02X\n", objr->command ));
; 458  :     Fatal( INTERNAL_ERROR, __FILE__, __LINE__ );

	mov	r8d, 458				; 000001caH
	lea	rdx, OFFSET FLAT:$SG7856
	mov	ecx, 110				; 0000006eH
	call	Fatal

; 459  :     /* this is never reached, since Fatal() won't return */
; 460  :     return( 0 );

	xor	eax, eax

; 461  : }

	add	rsp, 40					; 00000028H
	ret	0
writeUnexp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeLinsym PROC

; 440  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 441  : 
; 442  :     /**/myassert( objr->command == CMD_LINSYM );
; 443  : 
; 444  :     WBegRec( out, CMD_LINSYM + objr->is_32 );

	movzx	eax, BYTE PTR [rdx+17]
	mov	rbx, rcx
	mov	DWORD PTR [rcx], 0
	sub	al, 60					; 0000003cH
	mov	BYTE PTR [rcx+4], al

; 445  :     PutByte( out, objr->d.linsym.flags );

	movzx	eax, BYTE PTR [rdx+20]
	mov	BYTE PTR [rcx+7], al
	inc	DWORD PTR [rcx]

; 446  :     PutIndex( out, objr->d.linsym.public_lname_idx );

	movzx	r8d, WORD PTR [rdx+22]
	mov	eax, DWORD PTR [rcx]
	cmp	r8w, 127				; 0000007fH
	jbe	SHORT $LN10@writeLinsy
	movzx	ecx, r8w
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [rax+rbx+7], cl
	inc	DWORD PTR [rbx]
	mov	eax, DWORD PTR [rbx]
$LN10@writeLinsy:
	mov	BYTE PTR [rax+rbx+7], r8b

; 447  :     PutMem( out, objr->data, objr->length );

	mov	eax, 4079				; 00000fefH
	inc	DWORD PTR [rbx]
	mov	ecx, DWORD PTR [rbx]
	mov	edi, DWORD PTR [rdx]
	sub	eax, ecx
	cmp	edi, eax
	ja	SHORT $LN15@writeLinsy
	mov	rdx, QWORD PTR [rdx+8]
	mov	eax, ecx
	lea	rcx, QWORD PTR [rbx+7]
	mov	r8d, edi
	add	rcx, rax
	call	memcpy
	add	DWORD PTR [rbx], edi
	jmp	SHORT $LN16@writeLinsy
$LN15@writeLinsy:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG7749
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN16@writeLinsy:

; 448  :     WEndRec( out );

	mov	rcx, rbx
	call	WEndRec

; 449  :     return( 0 );
; 450  : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
writeLinsym ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeComdat PROC

; 412  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 413  :     /**/myassert( objr->command == CMD_COMDAT );
; 414  : 
; 415  :     /* write CMD_COMDAT/CMD_COMD32 */
; 416  :     WBegRec( out, objr->command + objr->is_32 );

	movzx	eax, BYTE PTR [rdx+16]
	mov	rbx, rcx
	add	al, BYTE PTR [rdx+17]
	mov	r10, rdx
	mov	DWORD PTR [rcx], 0
	mov	BYTE PTR [rcx+4], al

; 417  :     PutByte( out, objr->d.comdat.flags );

	movzx	eax, BYTE PTR [rdx+20]
	mov	BYTE PTR [rcx+7], al
	inc	DWORD PTR [rcx]
	mov	r8d, DWORD PTR [rcx]

; 418  :     PutByte( out, objr->d.comdat.attributes );

	movzx	eax, BYTE PTR [rdx+21]
	mov	BYTE PTR [r8+rcx+7], al
	inc	DWORD PTR [rcx]
	mov	ecx, DWORD PTR [rcx]

; 419  :     PutByte( out, objr->d.comdat.align );

	movzx	eax, BYTE PTR [rdx+22]
	mov	BYTE PTR [rcx+rbx+7], al
	inc	DWORD PTR [rbx]

; 420  :     if( objr->is_32 ) {

	cmp	BYTE PTR [rdx+17], 0
	mov	eax, DWORD PTR [rbx]

; 421  :         PutDword( out, objr->d.comdat.offset );

	mov	ecx, eax
	je	SHORT $LN2@writeComda
	mov	eax, DWORD PTR [rdx+24]
	mov	DWORD PTR [rcx+rbx+7], eax
	add	DWORD PTR [rbx], 4

; 422  :     } else {

	jmp	SHORT $LN16@writeComda
$LN2@writeComda:

; 423  :         PutWord( out, objr->d.comdat.offset );

	movzx	eax, WORD PTR [rdx+24]
	mov	WORD PTR [rcx+rbx+7], ax
	add	DWORD PTR [rbx], 2
$LN16@writeComda:

; 424  :     }
; 425  :     PutIndex( out, objr->d.comdat.type_idx );

	movzx	edx, WORD PTR [rdx+28]
	cmp	dx, 127					; 0000007fH
	jbe	SHORT $LN21@writeComda
	mov	eax, DWORD PTR [rbx]
	movzx	ecx, dx
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [rax+rbx+7], cl
	inc	DWORD PTR [rbx]
$LN21@writeComda:
	mov	eax, DWORD PTR [rbx]
	mov	BYTE PTR [rax+rbx+7], dl
	inc	DWORD PTR [rbx]

; 426  :     if( ( objr->d.comdat.attributes & COMDAT_ALLOC_MASK ) == COMDAT_EXPLICIT ) {

	test	BYTE PTR [r10+21], 15
	jne	SHORT $LN4@writeComda

; 427  :         PutBase( out, &objr->d.comdat.base );

	lea	rdx, QWORD PTR [r10+30]
	mov	rcx, rbx
	call	PutBase
$LN4@writeComda:

; 428  :     }
; 429  :     PutIndex( out, objr->d.comdat.public_lname_idx );

	movzx	edx, WORD PTR [r10+36]
	cmp	dx, 127					; 0000007fH
	jbe	SHORT $LN28@writeComda
	mov	eax, DWORD PTR [rbx]
	movzx	ecx, dx
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [rax+rbx+7], cl
	inc	DWORD PTR [rbx]
$LN28@writeComda:
	mov	eax, DWORD PTR [rbx]
	mov	BYTE PTR [rax+rbx+7], dl

; 430  :     /* record is already in ms omf format */
; 431  :     PutMem( out, objr->data, objr->length );

	mov	eax, 4079				; 00000fefH
	inc	DWORD PTR [rbx]
	mov	ecx, DWORD PTR [rbx]
	mov	edi, DWORD PTR [r10]
	sub	eax, ecx
	cmp	edi, eax
	ja	SHORT $LN33@writeComda
	mov	rdx, QWORD PTR [r10+8]
	mov	eax, ecx
	lea	rcx, QWORD PTR [rbx+7]
	mov	r8d, edi
	add	rcx, rax
	call	memcpy
	add	DWORD PTR [rbx], edi
	jmp	SHORT $LN34@writeComda
$LN33@writeComda:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG7749
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN34@writeComda:

; 432  :     WEndRec( out );

	mov	rcx, rbx
	call	WEndRec

; 433  :     return( 0 );
; 434  : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
writeComdat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeLinnum PROC

; 393  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 394  : 
; 395  :     /**/myassert( objr->command == CMD_LINNUM );
; 396  : 
; 397  :     WBegRec( out, CMD_LINNUM + objr->is_32 );

	movzx	eax, BYTE PTR [rdx+17]
	mov	r10, rdx
	sub	al, 108					; 0000006cH
	mov	DWORD PTR [rcx], 0

; 398  :     PutBase( out, &objr->d.linnum.base );

	add	rdx, 20
	mov	BYTE PTR [rcx+4], al
	mov	rbx, rcx
	call	PutBase

; 399  :     PutMem( out, objr->data, objr->length );

	mov	ecx, DWORD PTR [rbx]
	mov	eax, 4079				; 00000fefH
	mov	edi, DWORD PTR [r10]
	sub	eax, ecx
	cmp	edi, eax
	ja	SHORT $LN6@writeLinnu
	mov	rdx, QWORD PTR [r10+8]
	mov	eax, ecx
	lea	rcx, QWORD PTR [rbx+7]
	mov	r8d, edi
	add	rcx, rax
	call	memcpy
	add	DWORD PTR [rbx], edi
	jmp	SHORT $LN7@writeLinnu
$LN6@writeLinnu:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG7749
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN7@writeLinnu:

; 400  :     WEndRec( out );

	mov	rcx, rbx
	call	WEndRec

; 401  :     return( 0 );
; 402  : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
writeLinnum ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writePubdef PROC

; 381  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 382  :     /**/myassert( objr->command == CMD_PUBDEF || objr->command == CMD_LPUBDEF );
; 383  : 
; 384  :     WBegRec( out, objr->command + objr->is_32 );

	movzx	eax, BYTE PTR [rdx+17]
	mov	r10, rdx
	add	al, BYTE PTR [rdx+16]
	mov	rbx, rcx

; 385  :     PutBase( out, &objr->d.pubdef.base );

	add	rdx, 20
	mov	BYTE PTR [rcx+4], al
	mov	DWORD PTR [rcx], 0
	call	PutBase

; 386  :     PutMem( out, objr->data, objr->length );

	mov	ecx, DWORD PTR [rbx]
	mov	eax, 4079				; 00000fefH
	mov	edi, DWORD PTR [r10]
	sub	eax, ecx
	cmp	edi, eax
	ja	SHORT $LN6@writePubde
	mov	rdx, QWORD PTR [r10+8]
	mov	eax, ecx
	lea	rcx, QWORD PTR [rbx+7]
	mov	r8d, edi
	add	rcx, rax
	call	memcpy
	add	DWORD PTR [rbx], edi
	jmp	SHORT $LN7@writePubde
$LN6@writePubde:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG7749
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN7@writePubde:

; 387  :     WEndRec( out );

	mov	rcx, rbx
	call	WEndRec

; 388  :     return( 0 );
; 389  : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
writePubdef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
;	COMDAT PutBase
_TEXT	SEGMENT
out$ = 8
base$ = 16
PutBase	PROC						; COMDAT

; 371  : {

	mov	r9, rcx

; 372  :     PutIndex( out, base->grp_idx );

	movzx	ecx, WORD PTR [rdx]
	cmp	cx, 127					; 0000007fH
	jbe	SHORT $LN7@PutBase
	mov	eax, DWORD PTR [r9]
	movzx	r8d, cx
	shr	r8w, 8
	or	r8b, 128				; 00000080H
	mov	BYTE PTR [rax+r9+7], r8b
	inc	DWORD PTR [r9]
$LN7@PutBase:
	mov	eax, DWORD PTR [r9]
	mov	BYTE PTR [rax+r9+7], cl
	inc	DWORD PTR [r9]

; 373  :     PutIndex( out, base->seg_idx );

	movzx	r8d, WORD PTR [rdx+2]
	mov	eax, DWORD PTR [r9]
	cmp	r8w, 127				; 0000007fH
	jbe	SHORT $LN14@PutBase
	movzx	ecx, r8w
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [rax+r9+7], cl
	inc	DWORD PTR [r9]
	mov	eax, DWORD PTR [r9]
$LN14@PutBase:
	mov	BYTE PTR [rax+r9+7], r8b
	inc	DWORD PTR [r9]

; 374  :     if( base->grp_idx == 0 && base->seg_idx == 0 ) {

	cmp	WORD PTR [rdx], 0
	jne	SHORT $LN18@PutBase
	cmp	WORD PTR [rdx+2], 0
	jne	SHORT $LN18@PutBase

; 375  :         PutWord( out, base->frame );

	mov	ecx, DWORD PTR [r9]
	movzx	eax, WORD PTR [rdx+4]
	mov	WORD PTR [rcx+r9+7], ax
	add	DWORD PTR [r9], 2
$LN18@PutBase:

; 376  :     }
; 377  : }

	ret	0
PutBase	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeModend PROC

; 336  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 337  :     int     is32;
; 338  :     //uint_8  is_log;
; 339  :     uint_8  mtype;
; 340  : 
; 341  :     /**/myassert( objr->command == CMD_MODEND );
; 342  : 
; 343  :     is32 = ( ( objr->is_32 && objr->d.modend.start_addrs ) ? TRUE : FALSE );

	cmp	BYTE PTR [rdx+17], 0
	mov	rbx, rcx
	je	SHORT $LN5@writeModen
	cmp	BYTE PTR [rdx+21], 0
	je	SHORT $LN5@writeModen
	mov	eax, 1
	jmp	SHORT $LN6@writeModen
$LN5@writeModen:
	xor	eax, eax
$LN6@writeModen:

; 344  :     WBegRec( out, CMD_MODEND + is32 );

	sub	al, 118					; 00000076H
	mov	DWORD PTR [rcx], 0
	mov	BYTE PTR [rcx+4], al

; 345  :     /* first byte is Module Type:
; 346  :      * bit 7: 1=main program module
; 347  :      * bit 6: 1=contains start address
; 348  :      * bit 5: Segment bit ( according to OMF, this bit should be 1 )
; 349  :      * bit 1-4: must be 0
; 350  :      * bit 0: start address contains relocatable address ( according to OMF, this bit should be 1 )
; 351  :      * Masm does set bit 0, but does not set bit 5!
; 352  :      */
; 353  :     mtype = objr->d.modend.main_module ? 0x80 : 0;

	movzx	eax, BYTE PTR [rdx+20]
	neg	al
	mov	QWORD PTR [rsp+48], rdi
	sbb	cl, cl
	and	cl, 128					; 00000080H

; 354  :     if( objr->d.modend.start_addrs ) {

	cmp	BYTE PTR [rdx+21], 0
	je	SHORT $LN2@writeModen

; 355  :         //is_log = objr->d.modend.is_logical;
; 356  :         //mtype |= 0x40 | is_log;
; 357  :         mtype |= 0x41;

	or	cl, 65					; 00000041H

; 358  :         PutByte( out, mtype );
; 359  :         PutMem( out, objr->data, objr->length );

	mov	eax, 4079				; 00000fefH
	mov	BYTE PTR [rbx+7], cl
	inc	DWORD PTR [rbx]
	mov	ecx, DWORD PTR [rbx]
	mov	edi, DWORD PTR [rdx]
	sub	eax, ecx
	cmp	edi, eax
	ja	SHORT $LN12@writeModen
	mov	rdx, QWORD PTR [rdx+8]
	mov	eax, ecx
	lea	rcx, QWORD PTR [rbx+7]
	mov	r8d, edi
	add	rcx, rax
	call	memcpy
	add	DWORD PTR [rbx], edi
	jmp	SHORT $LN15@writeModen
$LN12@writeModen:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG7749
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal

; 360  :     } else

	jmp	SHORT $LN15@writeModen
$LN2@writeModen:

; 361  :         PutByte( out, mtype );

	mov	BYTE PTR [rbx+7], cl
	inc	DWORD PTR [rbx]
$LN15@writeModen:

; 362  : 
; 363  :     WEndRec( out );

	mov	rcx, rbx
	call	WEndRec
	mov	rdi, QWORD PTR [rsp+48]

; 364  :     return( 0 );

	xor	eax, eax

; 365  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
writeModend ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeTheadr PROC

; 328  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 329  :     /**/myassert( objr->command == CMD_THEADR );
; 330  : 
; 331  :     return( writeMisc( out, objr ) );

	movzx	eax, BYTE PTR [rdx+16]
	mov	rbx, rcx
	mov	BYTE PTR [rcx+4], al
	mov	DWORD PTR [rcx], 0
	mov	edi, DWORD PTR [rdx]
	cmp	edi, 4079				; 00000fefH
	ja	SHORT $LN8@writeThead
	mov	rdx, QWORD PTR [rdx+8]
	mov	r8d, edi
	add	rcx, 7
	call	memcpy
	add	DWORD PTR [rbx], edi
	jmp	SHORT $LN9@writeThead
$LN8@writeThead:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG7749
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN9@writeThead:
	mov	rcx, rbx
	call	WEndRec

; 332  : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
writeTheadr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeLedata PROC

; 311  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 312  :     /**/myassert( objr->command == CMD_LEDATA || objr->command == CMD_LIDATA );
; 313  : 
; 314  :     WBegRec( out, objr->command + objr->is_32 );

	movzx	eax, BYTE PTR [rdx+16]
	mov	rbx, rcx
	add	al, BYTE PTR [rdx+17]
	mov	BYTE PTR [rcx+4], al
	mov	DWORD PTR [rcx], 0

; 315  :     PutIndex( out, objr->d.ledata.idx );

	movzx	ecx, WORD PTR [rdx+20]
	cmp	cx, 127					; 0000007fH
	jbe	SHORT $LN10@writeLedat
	movzx	eax, cx
	shr	ax, 8
	or	al, 128					; 00000080H
	mov	BYTE PTR [rbx+7], al
	inc	DWORD PTR [rbx]
$LN10@writeLedat:
	mov	eax, DWORD PTR [rbx]
	mov	BYTE PTR [rax+rbx+7], cl
	inc	DWORD PTR [rbx]

; 316  :     if( objr->is_32 ) {

	cmp	BYTE PTR [rdx+17], 0
	mov	eax, DWORD PTR [rbx]

; 317  :         PutDword( out, objr->d.ledata.offset );

	mov	ecx, eax
	je	SHORT $LN2@writeLedat
	mov	eax, DWORD PTR [rdx+24]
	mov	DWORD PTR [rcx+rbx+7], eax
	add	DWORD PTR [rbx], 4

; 318  :     } else {

	jmp	SHORT $LN16@writeLedat
$LN2@writeLedat:

; 319  :         PutWord( out, objr->d.ledata.offset );

	movzx	eax, WORD PTR [rdx+24]
	mov	WORD PTR [rcx+rbx+7], ax
	add	DWORD PTR [rbx], 2
$LN16@writeLedat:

; 320  :     }
; 321  :     PutMem( out, objr->data, objr->length );

	mov	ecx, DWORD PTR [rbx]
	mov	eax, 4079				; 00000fefH
	mov	edi, DWORD PTR [rdx]
	sub	eax, ecx
	cmp	edi, eax
	ja	SHORT $LN19@writeLedat
	mov	rdx, QWORD PTR [rdx+8]
	mov	eax, ecx
	lea	rcx, QWORD PTR [rbx+7]
	mov	r8d, edi
	add	rcx, rax
	call	memcpy
	add	DWORD PTR [rbx], edi
	jmp	SHORT $LN20@writeLedat
$LN19@writeLedat:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG7749
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN20@writeLedat:

; 322  :     WEndRec( out );

	mov	rcx, rbx
	call	WEndRec

; 323  :     return( 0 );
; 324  : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
writeLedata ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeSegdef PROC

; 215  : {

	sub	rsp, 40					; 00000028H

; 216  :     int         is32;
; 217  :     uint_8      acbp;
; 218  :     uint_8      align;
; 219  : 
; 220  :     /**/myassert( objr->command == CMD_SEGDEF );
; 221  : 
; 222  :     //is32 = objr->d.segdef.use_32;
; 223  :     is32 = objr->is_32;

	movzx	r9d, BYTE PTR [rdx+17]
	mov	r8, rcx

; 224  :     WBegRec( out, CMD_SEGDEF + is32 );

	mov	DWORD PTR [rcx], 0
	lea	eax, DWORD PTR [r9-104]
	mov	BYTE PTR [rcx+4], al

; 225  : 
; 226  :     /* ACBP: bits=AAACCCBP
; 227  :      * AAA=alignment
; 228  :      * CCC=combination
; 229  :      * B=big
; 230  :      * P=32bit
; 231  :      */
; 232  :     acbp = ( objr->d.segdef.combine << 2 ) | objr->d.segdef.use_32;
; 233  :     align = objr->d.segdef.align;

	movzx	ecx, BYTE PTR [rdx+23]

; 234  : #if 1
; 235  :     acbp |= align << 5;

	movzx	eax, cl
	shl	al, 3
	or	al, BYTE PTR [rdx+24]
	shl	al, 2
	or	al, BYTE PTR [rdx+22]

; 236  : #else
; 237  :     switch( align ) {
; 238  :     case SEGDEF_ALIGN_ABS:      acbp |= ALIGN_ABS << 5;     break;
; 239  :     case SEGDEF_ALIGN_BYTE:     acbp |= ALIGN_BYTE << 5;    break;
; 240  :     case SEGDEF_ALIGN_WORD:     acbp |= ALIGN_WORD << 5;    break;
; 241  :     case SEGDEF_ALIGN_PARA:     acbp |= ALIGN_PARA << 5;    break;
; 242  :     case SEGDEF_ALIGN_PAGE:     acbp |= ALIGN_PAGE << 5;    break;
; 243  :     case SEGDEF_ALIGN_DWORD:    acbp |= ALIGN_DWORD << 5;   break;
; 244  : #if PAGE4K
; 245  :     case SEGDEF_ALIGN_4KPAGE:   acbp |= ALIGN_4KPAGE << 5;  break;
; 246  : #endif
; 247  :     default: /**/myassert( 0 );
; 248  :     }
; 249  : #endif
; 250  :     /* set BIG bit. should also be done for 32-bit segments
; 251  :      * if their size is exactly 4 GB. Currently HJWasm won't
; 252  :      * support segments with size 4 GB.
; 253  :      */
; 254  :     if( is32 == 0 && objr->d.segdef.seg_length == 0x10000 ) {

	test	r9d, r9d
	jne	SHORT $LN2@writeSegde
	cmp	DWORD PTR [rdx+36], 65536		; 00010000H
	jne	SHORT $LN2@writeSegde

; 255  :         acbp |= 0x02;

	or	al, 2
$LN2@writeSegde:

; 256  :     }
; 257  : 
; 258  :     /* the segdef record is small (16bit: size 6 - 9 ):
; 259  :      * - byte acbp
; 260  :      * - word (32bit:dword) length
; 261  :      * - index seg name
; 262  :      * - index class name
; 263  :      * - index ovl name
; 264  :      * ABS segdefs are 3 bytes longer
; 265  :     */
; 266  : 
; 267  :     PutByte( out, acbp );

	mov	BYTE PTR [r8+7], al
	inc	DWORD PTR [r8]
	mov	eax, DWORD PTR [r8]

; 268  :     if( align == SEGDEF_ALIGN_ABS ) {

	test	cl, cl
	jne	SHORT $LN13@writeSegde

; 269  :         /* absolut segment has frame=word and offset=byte
; 270  :          * it isn't fixupp physical reference
; 271  :          * and doesn't depend on segment size (16/32bit)
; 272  :          */
; 273  :         PutWord( out, objr->d.segdef.abs.frame );

	mov	ecx, eax
	movzx	eax, WORD PTR [rdx+28]
	mov	WORD PTR [rcx+r8+7], ax
	add	DWORD PTR [r8], 2

; 274  :         PutByte( out, objr->d.segdef.abs.offset );

	movzx	eax, BYTE PTR [rdx+32]
	mov	ecx, DWORD PTR [r8]
	mov	BYTE PTR [rcx+r8+7], al
	inc	DWORD PTR [r8]
	mov	eax, DWORD PTR [r8]
$LN13@writeSegde:

; 275  :     }
; 276  :     if( is32 ) {
; 277  :         PutDword( out, objr->d.segdef.seg_length );

	mov	ecx, eax
	test	r9d, r9d
	je	SHORT $LN4@writeSegde
	mov	eax, DWORD PTR [rdx+36]
	mov	DWORD PTR [rcx+r8+7], eax
	add	DWORD PTR [r8], 4

; 278  :     } else {

	jmp	SHORT $LN17@writeSegde
$LN4@writeSegde:

; 279  :         PutWord( out, objr->d.segdef.seg_length );

	movzx	eax, WORD PTR [rdx+36]
	mov	WORD PTR [rcx+r8+7], ax
	add	DWORD PTR [r8], 2
$LN17@writeSegde:

; 280  :     }
; 281  : 
; 282  :     PutIndex( out, objr->d.segdef.seg_lname_idx );

	movzx	r9d, WORD PTR [rdx+40]
	cmp	r9w, 127				; 0000007fH
	jbe	SHORT $LN22@writeSegde
	mov	eax, DWORD PTR [r8]
	movzx	ecx, r9w
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [rax+r8+7], cl
	inc	DWORD PTR [r8]
$LN22@writeSegde:
	mov	eax, DWORD PTR [r8]
	mov	BYTE PTR [rax+r8+7], r9b
	inc	DWORD PTR [r8]

; 283  :     PutIndex( out, objr->d.segdef.class_lname_idx );

	movzx	r9d, WORD PTR [rdx+42]
	mov	eax, DWORD PTR [r8]
	cmp	r9w, 127				; 0000007fH
	jbe	SHORT $LN29@writeSegde
	movzx	ecx, r9w
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [rax+r8+7], cl
	inc	DWORD PTR [r8]
	mov	eax, DWORD PTR [r8]
$LN29@writeSegde:
	mov	BYTE PTR [rax+r8+7], r9b
	inc	DWORD PTR [r8]

; 284  :     PutIndex( out, objr->d.segdef.ovl_lname_idx );

	movzx	r9d, WORD PTR [rdx+44]
	mov	eax, DWORD PTR [r8]
	cmp	r9w, 127				; 0000007fH
	jbe	SHORT $LN36@writeSegde
	movzx	ecx, r9w
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [rax+r8+7], cl
	inc	DWORD PTR [r8]
	mov	eax, DWORD PTR [r8]
$LN36@writeSegde:
	mov	BYTE PTR [rax+r8+7], r9b

; 285  :     //if( objr->d.segdef.access_valid ) {
; 286  :     //    EmitError( ACCESS_CLASSES_NOT_SUPPORTED );
; 287  :     //}
; 288  :     WEndRec( out );

	mov	rcx, r8
	inc	DWORD PTR [r8]
	call	WEndRec

; 289  :     return( 0 );

	xor	eax, eax

; 290  : }

	add	rsp, 40					; 00000028H
	ret	0
writeSegdef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeComent PROC

; 202  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 203  :     /**/myassert( objr->data != NULL );
; 204  : 
; 205  :     WBegRec( out, CMD_COMENT );

	mov	DWORD PTR [rcx], 0
	mov	rbx, rcx
	mov	BYTE PTR [rcx+4], 136			; 00000088H

; 206  :     PutByte( out, objr->d.coment.attr );

	movzx	eax, BYTE PTR [rdx+20]
	mov	BYTE PTR [rcx+7], al
	inc	DWORD PTR [rcx]
	mov	r8d, DWORD PTR [rcx]

; 207  :     PutByte( out, objr->d.coment.cmt_class );

	movzx	eax, BYTE PTR [rdx+21]
	mov	BYTE PTR [r8+rcx+7], al

; 208  :     PutMem( out, objr->data, objr->length );

	mov	eax, 4079				; 00000fefH
	inc	DWORD PTR [rcx]
	mov	ecx, DWORD PTR [rcx]
	mov	edi, DWORD PTR [rdx]
	sub	eax, ecx
	cmp	edi, eax
	ja	SHORT $LN10@writeComen
	mov	rdx, QWORD PTR [rdx+8]
	mov	eax, ecx
	lea	rcx, QWORD PTR [rbx+7]
	mov	r8d, edi
	add	rcx, rax
	call	memcpy
	add	DWORD PTR [rbx], edi
	jmp	SHORT $LN11@writeComen
$LN10@writeComen:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG7749
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN11@writeComen:

; 209  :     WEndRec( out );

	mov	rcx, rbx
	call	WEndRec

; 210  :     return( 0 );
; 211  : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
writeComent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeMisc32 PROC

; 191  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 192  :     /**/myassert( objr->data != NULL );
; 193  : 
; 194  :     WBegRec( out, objr->command | objr->is_32 );

	movzx	eax, BYTE PTR [rdx+17]
	mov	rbx, rcx
	or	al, BYTE PTR [rdx+16]
	mov	BYTE PTR [rcx+4], al
	mov	DWORD PTR [rcx], 0

; 195  :     PutMem( out, objr->data, objr->length );

	mov	edi, DWORD PTR [rdx]
	cmp	edi, 4079				; 00000fefH
	ja	SHORT $LN6@writeMisc3
	mov	rdx, QWORD PTR [rdx+8]
	mov	r8d, edi
	add	rcx, 7
	call	memcpy
	add	DWORD PTR [rbx], edi
	jmp	SHORT $LN7@writeMisc3
$LN6@writeMisc3:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG7749
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN7@writeMisc3:

; 196  :     WEndRec( out );

	mov	rcx, rbx
	call	WEndRec

; 197  :     return( 0 );
; 198  : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
writeMisc32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeMisc PROC

; 178  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 179  :     /**/myassert( objr->data != NULL );
; 180  : 
; 181  :     WBegRec( out, objr->command );

	movzx	eax, BYTE PTR [rdx+16]
	mov	rbx, rcx
	mov	BYTE PTR [rcx+4], al
	mov	DWORD PTR [rcx], 0

; 182  :     PutMem( out, objr->data, objr->length );

	mov	edi, DWORD PTR [rdx]
	cmp	edi, 4079				; 00000fefH
	ja	SHORT $LN6@writeMisc
	mov	rdx, QWORD PTR [rdx+8]
	mov	r8d, edi
	add	rcx, 7
	call	memcpy
	add	DWORD PTR [rbx], edi
	jmp	SHORT $LN7@writeMisc
$LN6@writeMisc:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG7749
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN7@writeMisc:

; 183  :     WEndRec( out );

	mov	rcx, rbx
	call	WEndRec

; 184  :     return( 0 );
; 185  : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
writeMisc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
;	COMDAT PutMem
_TEXT	SEGMENT
out$ = 48
buf$ = 56
length$ = 64
PutMem	PROC						; COMDAT

; 158  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	edi, r8d

; 159  :     /* ensure that there is enough free space in the buffer,
; 160  :      * and also 1 byte left for the chksum!
; 161  :      */
; 162  :     if( length <= OBJ_BUFFER_SIZE - 1 - out->in_buf ) {

	mov	ecx, DWORD PTR [rcx]
	mov	eax, 4079				; 00000fefH
	sub	eax, ecx
	cmp	r8d, eax
	ja	SHORT $LN2@PutMem

; 163  :         memcpy( &out->buffer[ out->in_buf ], buf, length );

	mov	eax, ecx
	mov	r8d, edi
	lea	rcx, QWORD PTR [rbx+7]
	add	rcx, rax
	call	memcpy

; 164  :         out->in_buf += length;

	add	DWORD PTR [rbx], edi

; 169  :     }
; 170  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@PutMem:

; 165  :     } else {
; 166  :         /* this "shouldn't happen". */
; 167  :         DebugMsg(("PutMem: buffer overflow error [length=%u, free=%u]\n", length, OBJ_BUFFER_SIZE - 1 - out->in_buf ));
; 168  :         Fatal( INTERNAL_ERROR, __FILE__, __LINE__ );

	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG7749
	lea	ecx, QWORD PTR [r8-58]

; 169  :     }
; 170  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 165  :     } else {
; 166  :         /* this "shouldn't happen". */
; 167  :         DebugMsg(("PutMem: buffer overflow error [length=%u, free=%u]\n", length, OBJ_BUFFER_SIZE - 1 - out->in_buf ));
; 168  :         Fatal( INTERNAL_ERROR, __FILE__, __LINE__ );

	jmp	Fatal
PutMem	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
;	COMDAT PutDword
_TEXT	SEGMENT
out$ = 8
value$ = 16
PutDword PROC						; COMDAT

; 150  :     WriteU32( out->buffer + out->in_buf, value );

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rax+rcx+7], edx

; 151  :     out->in_buf += sizeof( uint_32 );

	add	DWORD PTR [rcx], 4

; 152  : }

	ret	0
PutDword ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
;	COMDAT PutWord
_TEXT	SEGMENT
out$ = 8
value$ = 16
PutWord	PROC						; COMDAT

; 141  :     WriteU16( out->buffer + out->in_buf, value );

	mov	eax, DWORD PTR [rcx]
	mov	WORD PTR [rax+rcx+7], dx

; 142  :     out->in_buf += sizeof( uint_16 );

	add	DWORD PTR [rcx], 2

; 143  : }

	ret	0
PutWord	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
;	COMDAT PutIndex
_TEXT	SEGMENT
out$ = 8
index$ = 16
PutIndex PROC						; COMDAT

; 130  :     if( index > 0x7f ) {

	cmp	dx, 127					; 0000007fH
	jbe	SHORT $LN4@PutIndex

; 131  :         PutByte( out, 0x80 | ( index >> 8 ) );

	mov	eax, DWORD PTR [rcx]
	movzx	r8d, dx
	shr	r8w, 8
	or	r8b, 128				; 00000080H
	mov	BYTE PTR [rax+rcx+7], r8b
	inc	DWORD PTR [rcx]
$LN4@PutIndex:

; 132  :     }
; 133  :     PutByte( out, index & 0xff );

	mov	eax, DWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx+7], dl
	inc	DWORD PTR [rcx]

; 134  : }

	ret	0
PutIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
;	COMDAT PutByte
_TEXT	SEGMENT
out$ = 8
value$ = 16
PutByte	PROC						; COMDAT

; 122  :     out->buffer[ out->in_buf++ ] = value;

	mov	eax, DWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx+7], dl
	inc	DWORD PTR [rcx]

; 123  : }

	ret	0
PutByte	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
;	COMDAT WEndRec
_TEXT	SEGMENT
out$ = 48
WEndRec	PROC						; COMDAT

; 91   : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 92   :     uint_8  checksum;
; 93   :     uint_8  *p;
; 94   :     uint_8  *end;
; 95   : 
; 96   :     /**/myassert( out && out->cmd );
; 97   : 
; 98   :     out->reclen = out->in_buf + 1; /* add 1 for checksum byte */

	movzx	r8d, WORD PTR [rcx]

; 99   :     checksum = out->cmd + ( out->reclen & 0xff ) + (( out->reclen ) >> 8);
; 100  :     for( p = out->buffer, end = p + out->in_buf; p < end; ) {

	lea	rax, QWORD PTR [rcx+7]
	inc	r8w
	lea	rdi, QWORD PTR [rcx+4]
	mov	WORD PTR [rcx+5], r8w
	xor	edx, edx
	shr	r8w, 8
	mov	rbx, rcx
	add	r8b, BYTE PTR [rcx+5]
	add	r8b, BYTE PTR [rdi]
	mov	ecx, DWORD PTR [rcx]
	add	rcx, rax
	mov	r11, rcx
	sub	r11, rax
	cmp	rax, rcx
	cmova	r11, rdx
	test	r11, r11
	je	SHORT $LN12@WEndRec
	cmp	r11, 32					; 00000020H
	jb	SHORT $LN12@WEndRec
	mov	rcx, r11
	mov	r9, r11
	and	ecx, 31
	xorps	xmm2, xmm2
	sub	r9, rcx
	movdqa	xmm1, xmm2
$LL2@WEndRec:

; 101  :         checksum += *p++;

	movdqu	xmm0, XMMWORD PTR [rax]
	add	rdx, 32					; 00000020H
	paddb	xmm0, xmm2
	movdqa	xmm2, xmm0
	movdqu	xmm0, XMMWORD PTR [rax+16]
	add	rax, 32					; 00000020H
	paddb	xmm0, xmm1
	movdqa	xmm1, xmm0
	cmp	rdx, r9
	jb	SHORT $LL2@WEndRec
	paddb	xmm1, xmm2
	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	paddb	xmm1, xmm0
	movdqa	xmm0, xmm1
	psrldq	xmm0, 4
	paddb	xmm1, xmm0
	movdqa	xmm0, xmm1
	psrldq	xmm0, 2
	paddb	xmm1, xmm0
	movdqa	xmm0, xmm1
	psrldq	xmm0, 1
	paddb	xmm1, xmm0
	movd	ecx, xmm1
	add	r8b, cl
$LN12@WEndRec:
	xor	r10b, r10b
	xor	r9b, r9b
	cmp	rdx, r11
	jae	SHORT $LN16@WEndRec
	mov	rcx, r11
	sub	rcx, rdx

; 99   :     checksum = out->cmd + ( out->reclen & 0xff ) + (( out->reclen ) >> 8);
; 100  :     for( p = out->buffer, end = p + out->in_buf; p < end; ) {

	cmp	rcx, 2
	jb	SHORT $LC17@WEndRec
	mov	rcx, r11
	sub	rcx, rdx
	sub	rcx, 2
	shr	rcx, 1
	inc	rcx
	lea	rdx, QWORD PTR [rdx+rcx*2]
$LL19@WEndRec:

; 101  :         checksum += *p++;

	add	r10b, BYTE PTR [rax]
	add	r9b, BYTE PTR [rax+1]
	add	rax, 2
	sub	rcx, 1
	jne	SHORT $LL19@WEndRec
$LC17@WEndRec:

; 99   :     checksum = out->cmd + ( out->reclen & 0xff ) + (( out->reclen ) >> 8);
; 100  :     for( p = out->buffer, end = p + out->in_buf; p < end; ) {

	cmp	rdx, r11
	jae	SHORT $LN18@WEndRec

; 101  :         checksum += *p++;

	add	r8b, BYTE PTR [rax]
	inc	rax
$LN18@WEndRec:
	add	r9b, r10b
	add	r8b, r9b
$LN16@WEndRec:

; 102  :     }
; 103  :     checksum = - checksum;

	neg	r8b

; 104  :     *p = checksum; /* store chksum in buffer */
; 105  : 
; 106  :     /* write buffer + 4 extra bytes (1 cmd, 2 length, 1 chksum) */
; 107  :     safeWrite( CurrFile[OBJ], &out->cmd, out->in_buf + 4 );

	mov	edx, 1
	mov	BYTE PTR [rax], r8b
	mov	rcx, rdi
	mov	eax, DWORD PTR [rbx]
	mov	r9, QWORD PTR ModuleInfo+104
	add	eax, 4
	mov	r8d, eax
	mov	ebx, eax
	call	fwrite
	cmp	rax, rbx
	je	SHORT $LN7@WEndRec
	call	WriteError
$LN7@WEndRec:

; 108  : 
; 109  : #if 0 //def DEBUG_OUT
; 110  :     p = &out->cmd;
; 111  :     DebugMsg1(("WEndRec: %X %X %X %X\n", *p, *(p+1), *(p+2), *(p+3) ));
; 112  :     //printf( "WEndRec: %X %X %X %X (ofs cmd=%u ofs reclen=%u)\n", *p, *(p+1), *(p+2), *(p+3), offsetof( struct outbuff, cmd ), offsetof( struct outbuff, reclen ) );
; 113  : #endif
; 114  : 
; 115  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
WEndRec	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
;	COMDAT WBegRec
_TEXT	SEGMENT
out$ = 8
command$ = 16
WBegRec	PROC						; COMDAT

; 79   :     out->in_buf = 0;

	mov	DWORD PTR [rcx], 0

; 80   :     out->cmd = command;

	mov	BYTE PTR [rcx+4], dl

; 81   : }

	ret	0
WBegRec	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
;	COMDAT safeWrite
_TEXT	SEGMENT
file$ = 48
buf$ = 56
len$ = 64
safeWrite PROC						; COMDAT

; 56   : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, rdx

; 57   :     if( fwrite( buf, 1, len, file ) != len )

	mov	ebx, r8d
	mov	r9, rcx
	mov	r8d, r8d
	mov	rcx, rax
	mov	edx, 1
	call	fwrite
	cmp	rax, rbx
	je	SHORT $LN2@safeWrite

; 59   : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 58   :         WriteError();

	jmp	WriteError
$LN2@safeWrite:

; 59   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
safeWrite ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 32
objr$ = 4144
omf_write_record PROC

; 522  : {

$LN4:
	mov	eax, 4136				; 00001028H
	call	__chkstk
	sub	rsp, rax

; 523  :     struct outbuff out;
; 524  : 
; 525  :     /**/myassert( objr != NULL && objr->command >= CMD_MIN_CMD && objr->command <= CMD_MAX_CMD + 1 );
; 526  :     DebugMsg1(("omf_write_record( cmd=%X data=%p length=%u )\n", objr->command, objr->data, objr->length ));
; 527  :     myFuncs[ func_index[JUMP_INDEX(objr->command) ] ] ( &out, objr );

	movzx	eax, BYTE PTR [rcx+16]
	lea	r8, OFFSET FLAT:__ImageBase
	add	eax, -128				; ffffffffffffff80H
	movsxd	rdx, eax
	sar	rdx, 1
	movzx	eax, BYTE PTR func_index[rdx+r8]
	mov	rdx, rcx
	lea	rcx, QWORD PTR out$[rsp]
	call	QWORD PTR myFuncs[r8+rax*8]

; 528  : }

	add	rsp, 4136				; 00001028H
	ret	0
omf_write_record ENDP
_TEXT	ENDS
END
