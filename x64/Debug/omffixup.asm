; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG10671 DB	'omffixup.c', 00H
	ORG $+5
$SG10672 DB	'omffixup.c', 00H
	ORG $+5
$SG10673 DB	'omffixup.c', 00H
	ORG $+5
$SG10693 DB	'omf_write_modend(%p): fixup->frame_type/datum=%u/%u, EXT'
	DB	'ERNAL sym=%s', 0aH, 00H
	ORG $+2
$SG10695 DB	'NULL', 00H
	ORG $+3
$SG10696 DB	'OmfFixGenFixModend(%p): fixup->frame_type/datum=%u/%u sy'
	DB	'm->name=%s state=%X segm=%s', 0aH, 00H
	ORG $+3
$SG10697 DB	'omffixup.c', 00H
	ORG $+1
$SG10714 DB	'NULL', 00H
	ORG $+7
$SG10715 DB	'omf_fill_logref: sym=%s, state=%d, fixup->type=%u', 0aH, 00H
	ORG $+5
$SG10718 DB	'omf_fill_logref: sym is NULL, frame_type=%u', 0aH, 00H
	ORG $+3
$SG10722 DB	'omf_fill_logref: sym->state is SYM_UNDEFINED', 0aH, 00H
	ORG $+2
$SG10725 DB	'omf_fill_logref: sym->state is SYM_GRP', 0aH, 00H
$SG10730 DB	'omf_fill_logref: sym->state is SYM_SEG %s', 0aH, 00H
	ORG $+5
$SG10735 DB	'omf_fill_logref: sym->state is SYM_EXTERNAL, fixup->fram'
	DB	'e_type/datum=%u/%u', 0aH, 00H
	ORG $+4
$SG10737 DB	'omffixup.c', 00H
	ORG $+1
$SG10738 DB	'NULL', 00H
	ORG $+7
$SG10771 DB	'omffixup.c', 00H
	ORG $+13
$SG10739 DB	'omf_fill_logref: sym->state is SYM_INTERNAL, sym->segmen'
	DB	't=%s, fixup->frame/datum=%u/%u', 0aH, 00H
$SG10772 DB	'omffixup.c', 00H
	ORG $+5
$SG10773 DB	'omffixup.c', 00H
	ORG $+5
$SG10786 DB	'omffixup.c', 00H
_DATA	ENDS
PUBLIC	OmfFixGenFix
PUBLIC	OmfFixGenFixModend
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitErr:PROC
EXTRN	GetSegIdx:PROC
EXTRN	InternalError:PROC
EXTRN	omf_GetGrpIdx:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	szNull:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$OmfFixGenFix DD imagerel $LN34
	DD	imagerel $LN34+868
	DD	imagerel $unwind$OmfFixGenFix
$pdata$OmfFixGenFixModend DD imagerel $LN12
	DD	imagerel $LN12+617
	DD	imagerel $unwind$OmfFixGenFixModend
$pdata$putIndex DD imagerel putIndex
	DD	imagerel putIndex+85
	DD	imagerel $unwind$putIndex
$pdata$put16 DD	imagerel put16
	DD	imagerel put16+35
	DD	imagerel $unwind$put16
$pdata$put32 DD	imagerel put32
	DD	imagerel put32+32
	DD	imagerel $unwind$put32
$pdata$putFrameDatum DD imagerel putFrameDatum
	DD	imagerel putFrameDatum+93
	DD	imagerel $unwind$putFrameDatum
$pdata$putTargetDatum DD imagerel putTargetDatum
	DD	imagerel putTargetDatum+61
	DD	imagerel $unwind$putTargetDatum
$pdata$TranslateLogref DD imagerel TranslateLogref
	DD	imagerel TranslateLogref+413
	DD	imagerel $unwind$TranslateLogref
$pdata$omf_fill_logref DD imagerel omf_fill_logref
	DD	imagerel omf_fill_logref+1161
	DD	imagerel $unwind$omf_fill_logref
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
xdata	SEGMENT
$unwind$OmfFixGenFix DD 034419H
	DD	012011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$OmfFixGenFixModend DD 034519H
	DD	014011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$putIndex DD 010b01H
	DD	0700bH
$unwind$put16 DD 010b01H
	DD	0700bH
$unwind$put32 DD 010a01H
	DD	0700aH
$unwind$putFrameDatum DD 022801H
	DD	070105214H
$unwind$putTargetDatum DD 022801H
	DD	070103214H
$unwind$TranslateLogref DD 022801H
	DD	070107214H
$unwind$omf_fill_logref DD 022301H
	DD	0700b920fH
xdata	ENDS
CONST	SEGMENT
OmfFixGenFix$rtcName$0 DB 06cH
	DB	072H
	DB	00H
	ORG $+13
OmfFixGenFix$rtcVarDesc DD 038H
	DD	0cH
	DQ	FLAT:OmfFixGenFix$rtcName$0
	ORG $+48
OmfFixGenFix$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:OmfFixGenFix$rtcVarDesc
OmfFixGenFixModend$rtcName$0 DB 06cH
	DB	072H
	DB	00H
	ORG $+5
OmfFixGenFixModend$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:OmfFixGenFixModend$rtcVarDesc
	ORG $+8
OmfFixGenFixModend$rtcVarDesc DD 058H
	DD	0cH
	DQ	FLAT:OmfFixGenFixModend$rtcName$0
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
_TEXT	SEGMENT
sym$ = 32
tv69 = 40
tv73 = 48
tv191 = 56
tv202 = 64
tv214 = 72
fixup$ = 96
lr$ = 104
omf_fill_logref PROC

; 238  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 239  :     struct asym      *sym;
; 240  : 
; 241  :     sym = fixup->sym; /* may be NULL! */

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR sym$[rsp], rax

; 242  : 
; 243  :     DebugMsg1(("omf_fill_logref: sym=%s, state=%d, fixup->type=%u\n",

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN28@omf_fill_l
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN29@omf_fill_l
$LN28@omf_fill_l:
	mov	DWORD PTR tv69[rsp], -1
$LN29@omf_fill_l:
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN30@omf_fill_l
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv73[rsp], rax
	jmp	SHORT $LN31@omf_fill_l
$LN30@omf_fill_l:
	lea	rax, OFFSET FLAT:$SG10714
	mov	QWORD PTR tv73[rsp], rax
$LN31@omf_fill_l:
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r9d, DWORD PTR [rax+24]
	mov	r8d, DWORD PTR tv69[rsp]
	mov	rdx, QWORD PTR tv73[rsp]
	lea	rcx, OFFSET FLAT:$SG10715
	call	DoDebugMsg1

; 244  :                sym ? sym->name : "NULL", sym ? sym->state : -1, fixup->type ));
; 245  : 
; 246  :     /*------------------------------------*/
; 247  :     /* Determine the Target and the Frame */
; 248  :     /*------------------------------------*/
; 249  : 
; 250  :     if( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN2@omf_fill_l

; 251  : 
; 252  :         DebugMsg(("omf_fill_logref: sym is NULL, frame_type=%u\n", fixup->frame_type ));

	mov	rax, QWORD PTR fixup$[rsp]
	movsx	eax, BYTE PTR [rax+40]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG10718
	call	DoDebugMsg

; 253  :         if ( fixup->frame_type == FRAME_NONE ) /* v1.96: nothing to do without a frame */

	mov	rax, QWORD PTR fixup$[rsp]
	movsx	eax, BYTE PTR [rax+40]
	cmp	eax, 6
	jne	SHORT $LN4@omf_fill_l

; 254  :             return( 0 );

	xor	eax, eax
	jmp	$LN1@omf_fill_l
$LN4@omf_fill_l:

; 255  :         lr->target = fixup->frame_type;

	mov	rax, QWORD PTR lr$[rsp]
	mov	rcx, QWORD PTR fixup$[rsp]
	movzx	ecx, BYTE PTR [rcx+40]
	mov	BYTE PTR [rax+5], cl

; 256  :         lr->target_datum = fixup->frame_datum;

	mov	rax, QWORD PTR lr$[rsp]
	mov	rcx, QWORD PTR fixup$[rsp]
	movzx	ecx, WORD PTR [rcx+42]
	mov	WORD PTR [rax+6], cx

; 257  :         lr->frame = FRAME_TARG;

	mov	rax, QWORD PTR lr$[rsp]
	mov	BYTE PTR [rax], 5
	jmp	$LN3@omf_fill_l
$LN2@omf_fill_l:

; 258  : 
; 259  :     } else if( sym->state == SYM_UNDEFINED ) { /* shouldn't happen */

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN5@omf_fill_l

; 260  : 
; 261  :         DebugMsg(("omf_fill_logref: sym->state is SYM_UNDEFINED\n" ));

	lea	rcx, OFFSET FLAT:$SG10722
	call	DoDebugMsg

; 262  :         EmitErr( SYMBOL_NOT_DEFINED, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr

; 263  :         return( 0 );

	xor	eax, eax
	jmp	$LN1@omf_fill_l
	jmp	$LN6@omf_fill_l
$LN5@omf_fill_l:

; 264  : 
; 265  :     } else if( sym->state == SYM_GRP ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 4
	jne	SHORT $LN7@omf_fill_l

; 266  : 
; 267  :         DebugMsg1(("omf_fill_logref: sym->state is SYM_GRP\n" ));

	lea	rcx, OFFSET FLAT:$SG10725
	call	DoDebugMsg1

; 268  :         lr->target = TARGET_GRP;

	mov	rax, QWORD PTR lr$[rsp]
	mov	BYTE PTR [rax+5], 5

; 269  :         lr->target_datum = ((struct dsym *)sym)->e.grpinfo->grp_idx;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR lr$[rsp]
	movzx	eax, WORD PTR [rax+8]
	mov	WORD PTR [rcx+6], ax

; 270  :         if( fixup->frame_type != FRAME_NONE ) {

	mov	rax, QWORD PTR fixup$[rsp]
	movsx	eax, BYTE PTR [rax+40]
	cmp	eax, 6
	je	SHORT $LN9@omf_fill_l

; 271  :             lr->frame = fixup->frame_type;

	mov	rax, QWORD PTR lr$[rsp]
	mov	rcx, QWORD PTR fixup$[rsp]
	movzx	ecx, BYTE PTR [rcx+40]
	mov	BYTE PTR [rax], cl

; 272  :             lr->frame_datum = fixup->frame_datum;

	mov	rax, QWORD PTR lr$[rsp]
	mov	rcx, QWORD PTR fixup$[rsp]
	movzx	ecx, WORD PTR [rcx+42]
	mov	WORD PTR [rax+2], cx

; 273  :         } else {

	jmp	SHORT $LN10@omf_fill_l
$LN9@omf_fill_l:

; 274  :             lr->frame = FRAME_GRP;

	mov	rax, QWORD PTR lr$[rsp]
	mov	BYTE PTR [rax], 1

; 275  :             lr->frame_datum = lr->target_datum;

	mov	rax, QWORD PTR lr$[rsp]
	mov	rcx, QWORD PTR lr$[rsp]
	movzx	ecx, WORD PTR [rcx+6]
	mov	WORD PTR [rax+2], cx
$LN10@omf_fill_l:

; 276  :         }

	jmp	$LN8@omf_fill_l
$LN7@omf_fill_l:

; 277  : 
; 278  :     } else if( sym->state == SYM_SEG ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 3
	jne	SHORT $LN11@omf_fill_l

; 279  : 
; 280  :         DebugMsg1(("omf_fill_logref: sym->state is SYM_SEG %s\n" ));

	lea	rcx, OFFSET FLAT:$SG10730
	call	DoDebugMsg1

; 281  :         lr->target = TARGET_SEG;

	mov	rax, QWORD PTR lr$[rsp]
	mov	BYTE PTR [rax+5], 4

; 282  :         lr->target_datum = GetSegIdx( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSegIdx
	mov	rcx, QWORD PTR lr$[rsp]
	mov	WORD PTR [rcx+6], ax

; 283  :         if( fixup->frame_type != FRAME_NONE ) {

	mov	rax, QWORD PTR fixup$[rsp]
	movsx	eax, BYTE PTR [rax+40]
	cmp	eax, 6
	je	SHORT $LN13@omf_fill_l

; 284  :             lr->frame = fixup->frame_type;

	mov	rax, QWORD PTR lr$[rsp]
	mov	rcx, QWORD PTR fixup$[rsp]
	movzx	ecx, BYTE PTR [rcx+40]
	mov	BYTE PTR [rax], cl

; 285  :             lr->frame_datum = fixup->frame_datum;

	mov	rax, QWORD PTR lr$[rsp]
	mov	rcx, QWORD PTR fixup$[rsp]
	movzx	ecx, WORD PTR [rcx+42]
	mov	WORD PTR [rax+2], cx

; 286  :         } else {

	jmp	SHORT $LN14@omf_fill_l
$LN13@omf_fill_l:

; 287  :             lr->frame = FRAME_SEG;

	mov	rax, QWORD PTR lr$[rsp]
	mov	BYTE PTR [rax], 0

; 288  :             lr->frame_datum = lr->target_datum;

	mov	rax, QWORD PTR lr$[rsp]
	mov	rcx, QWORD PTR lr$[rsp]
	movzx	ecx, WORD PTR [rcx+6]
	mov	WORD PTR [rax+2], cx
$LN14@omf_fill_l:

; 289  :         }
; 290  : 
; 291  :     } else {

	jmp	$LN12@omf_fill_l
$LN11@omf_fill_l:

; 292  : 
; 293  :         /* symbol is a label */
; 294  : 
; 295  :         lr->frame_datum = fixup->frame_datum;

	mov	rax, QWORD PTR lr$[rsp]
	mov	rcx, QWORD PTR fixup$[rsp]
	movzx	ecx, WORD PTR [rcx+42]
	mov	WORD PTR [rax+2], cx

; 296  :         if( sym->state == SYM_EXTERNAL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN15@omf_fill_l

; 297  :             DebugMsg1(("omf_fill_logref: sym->state is SYM_EXTERNAL, fixup->frame_type/datum=%u/%u\n",

	mov	rax, QWORD PTR fixup$[rsp]
	movzx	eax, WORD PTR [rax+42]
	mov	rcx, QWORD PTR fixup$[rsp]
	movsx	ecx, BYTE PTR [rcx+40]
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG10735
	call	DoDebugMsg1

; 298  :                       fixup->frame_type, fixup->frame_datum ));
; 299  :             lr->target = TARGET_EXT;

	mov	rax, QWORD PTR lr$[rsp]
	mov	BYTE PTR [rax+5], 6

; 300  :             lr->target_datum = sym->ext_idx1;

	mov	rax, QWORD PTR lr$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, WORD PTR [rcx+88]
	mov	WORD PTR [rax+6], cx

; 301  : 
; 302  :             if( fixup->frame_type == FRAME_GRP && fixup->frame_datum == 0 ) {

	mov	rax, QWORD PTR fixup$[rsp]
	movsx	eax, BYTE PTR [rax+40]
	cmp	eax, 1
	jne	SHORT $LN17@omf_fill_l
	mov	rax, QWORD PTR fixup$[rsp]
	movzx	eax, WORD PTR [rax+42]
	test	eax, eax
	jne	SHORT $LN17@omf_fill_l

; 303  :                 /* set the frame to the frame of the corresponding segment */
; 304  :                 lr->frame_datum = omf_GetGrpIdx( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	omf_GetGrpIdx
	mov	rcx, QWORD PTR lr$[rsp]
	mov	WORD PTR [rcx+2], ax
$LN17@omf_fill_l:

; 305  :             }
; 306  :         } else {

	jmp	$LN16@omf_fill_l
$LN15@omf_fill_l:

; 307  :             /* must be SYM_INTERNAL */
; 308  :             /**/myassert( sym->state == SYM_INTERNAL );

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN32@omf_fill_l
	mov	DWORD PTR tv191[rsp], 0
	jmp	SHORT $LN33@omf_fill_l
$LN32@omf_fill_l:
	mov	edx, 308				; 00000134H
	lea	rcx, OFFSET FLAT:$SG10737
	call	InternalError
	mov	DWORD PTR tv191[rsp], eax
$LN33@omf_fill_l:

; 309  :             DebugMsg1(("omf_fill_logref: sym->state is SYM_INTERNAL, sym->segment=%s, fixup->frame/datum=%u/%u\n",

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN34@omf_fill_l
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv202[rsp], rax
	jmp	SHORT $LN35@omf_fill_l
$LN34@omf_fill_l:
	lea	rax, OFFSET FLAT:$SG10738
	mov	QWORD PTR tv202[rsp], rax
$LN35@omf_fill_l:
	mov	rax, QWORD PTR fixup$[rsp]
	movzx	eax, WORD PTR [rax+42]
	mov	rcx, QWORD PTR fixup$[rsp]
	movsx	ecx, BYTE PTR [rcx+40]
	mov	r9d, eax
	mov	r8d, ecx
	mov	rdx, QWORD PTR tv202[rsp]
	lea	rcx, OFFSET FLAT:$SG10739
	call	DoDebugMsg1

; 310  :                        sym->segment ? sym->segment->name : "NULL", fixup->frame_type, fixup->frame_datum ));
; 311  :             /* v2.08: don't use info from assembly-time variables */
; 312  :             if ( sym->variable ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@omf_fill_l

; 313  :                 lr->target = ( fixup->frame_type == FRAME_GRP ? TARGET_GRP : TARGET_SEG );

	mov	rax, QWORD PTR fixup$[rsp]
	movsx	eax, BYTE PTR [rax+40]
	cmp	eax, 1
	jne	SHORT $LN36@omf_fill_l
	mov	DWORD PTR tv214[rsp], 5
	jmp	SHORT $LN37@omf_fill_l
$LN36@omf_fill_l:
	mov	DWORD PTR tv214[rsp], 4
$LN37@omf_fill_l:
	mov	rax, QWORD PTR lr$[rsp]
	movzx	ecx, BYTE PTR tv214[rsp]
	mov	BYTE PTR [rax+5], cl

; 314  :                 lr->target_datum = fixup->frame_datum;

	mov	rax, QWORD PTR lr$[rsp]
	mov	rcx, QWORD PTR fixup$[rsp]
	movzx	ecx, WORD PTR [rcx+42]
	mov	WORD PTR [rax+6], cx
	jmp	$LN19@omf_fill_l
$LN18@omf_fill_l:

; 315  :             } else if ( sym->segment == NULL ) { /* shouldn't happen */

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN20@omf_fill_l

; 316  :                 EmitErr( SEGMENT_MISSING_FOR_FIXUP, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 164				; 000000a4H
	call	EmitErr

; 317  :                 return ( 0 );

	xor	eax, eax
	jmp	$LN1@omf_fill_l
	jmp	SHORT $LN21@omf_fill_l
$LN20@omf_fill_l:

; 318  : #if COMDATSUPP
; 319  :             } else if ( ( (struct dsym *)sym->segment)->e.seginfo->comdat_selection ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+108]
	shr	al, 3
	and	al, 7
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@omf_fill_l

; 320  :                 lr->target = TARGET_EXT;

	mov	rax, QWORD PTR lr$[rsp]
	mov	BYTE PTR [rax+5], 6

; 321  :                 lr->target_datum = ((struct dsym *)sym->segment)->e.seginfo->seg_idx;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR lr$[rsp]
	movzx	eax, WORD PTR [rax+68]
	mov	WORD PTR [rcx+6], ax

; 322  :                 lr->frame = FRAME_TARG;

	mov	rax, QWORD PTR lr$[rsp]
	mov	BYTE PTR [rax], 5

; 323  :                 return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@omf_fill_l

; 324  : #endif
; 325  :             } else {

	jmp	SHORT $LN23@omf_fill_l
$LN22@omf_fill_l:

; 326  :                 lr->target = TARGET_SEG;

	mov	rax, QWORD PTR lr$[rsp]
	mov	BYTE PTR [rax+5], 4

; 327  :                 lr->target_datum = GetSegIdx( sym->segment );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	GetSegIdx
	mov	rcx, QWORD PTR lr$[rsp]
	mov	WORD PTR [rcx+6], ax
$LN23@omf_fill_l:
$LN21@omf_fill_l:
$LN19@omf_fill_l:
$LN16@omf_fill_l:

; 328  :             }
; 329  :         }
; 330  : 
; 331  :         if( fixup->frame_type != FRAME_NONE ) {

	mov	rax, QWORD PTR fixup$[rsp]
	movsx	eax, BYTE PTR [rax+40]
	cmp	eax, 6
	je	SHORT $LN24@omf_fill_l

; 332  :             lr->frame = (uint_8)fixup->frame_type;

	mov	rax, QWORD PTR lr$[rsp]
	mov	rcx, QWORD PTR fixup$[rsp]
	movzx	ecx, BYTE PTR [rcx+40]
	mov	BYTE PTR [rax], cl

; 333  :         } else {

	jmp	SHORT $LN25@omf_fill_l
$LN24@omf_fill_l:

; 334  :             lr->frame = FRAME_TARG;

	mov	rax, QWORD PTR lr$[rsp]
	mov	BYTE PTR [rax], 5
$LN25@omf_fill_l:
$LN12@omf_fill_l:
$LN8@omf_fill_l:
$LN6@omf_fill_l:
$LN3@omf_fill_l:

; 335  :         }
; 336  :     }
; 337  : 
; 338  :     /*--------------------*/
; 339  :     /* Optimize the fixup */
; 340  :     /*--------------------*/
; 341  : 
; 342  :     if( lr->frame == ( lr->target - TARGET_SEG ) ) {

	mov	rax, QWORD PTR lr$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR lr$[rsp]
	movzx	ecx, BYTE PTR [rcx+5]
	sub	ecx, 4
	cmp	eax, ecx
	jne	SHORT $LN26@omf_fill_l

; 343  :         lr->frame = FRAME_TARG;

	mov	rax, QWORD PTR lr$[rsp]
	mov	BYTE PTR [rax], 5
$LN26@omf_fill_l:

; 344  :     }
; 345  : 
; 346  :     return( 1 );

	mov	eax, 1
$LN1@omf_fill_l:

; 347  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
omf_fill_logref ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
_TEXT	SEGMENT
p$ = 32
target$ = 40
tv68 = 44
tv73 = 48
tv79 = 52
lr$ = 80
buf$ = 88
type$ = 96
TranslateLogref PROC

; 120  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 121  :     uint_8  *p;
; 122  :     uint_8  target;
; 123  : 
; 124  :     /**/myassert( lr != NULL );

	cmp	QWORD PTR lr$[rsp], 0
	je	SHORT $LN7@TranslateL
	mov	DWORD PTR tv68[rsp], 0
	jmp	SHORT $LN8@TranslateL
$LN7@TranslateL:
	mov	edx, 124				; 0000007cH
	lea	rcx, OFFSET FLAT:$SG10671
	call	InternalError
	mov	DWORD PTR tv68[rsp], eax
$LN8@TranslateL:

; 125  :     /**/myassert( buf != NULL );

	cmp	QWORD PTR buf$[rsp], 0
	je	SHORT $LN9@TranslateL
	mov	DWORD PTR tv73[rsp], 0
	jmp	SHORT $LN10@TranslateL
$LN9@TranslateL:
	mov	edx, 125				; 0000007dH
	lea	rcx, OFFSET FLAT:$SG10672
	call	InternalError
	mov	DWORD PTR tv73[rsp], eax
$LN10@TranslateL:

; 126  :     /**/myassert( type == FIX_GEN_INTEL || type == FIX_GEN_MS386 );

	cmp	DWORD PTR type$[rsp], 0
	je	SHORT $LN11@TranslateL
	cmp	DWORD PTR type$[rsp], 1
	je	SHORT $LN11@TranslateL
	mov	edx, 126				; 0000007eH
	lea	rcx, OFFSET FLAT:$SG10673
	call	InternalError
	mov	DWORD PTR tv79[rsp], eax
	jmp	SHORT $LN12@TranslateL
$LN11@TranslateL:
	mov	DWORD PTR tv79[rsp], 0
$LN12@TranslateL:

; 127  : 
; 128  :     /*
; 129  :      * According to the discussion on p102 of the Intel OMF document, we
; 130  :      * cannot just arbitrarily write fixups without a displacment if their
; 131  :      * displacement field is 0.  So we use the is_secondary field.
; 132  :      */
; 133  :     target = lr->target;

	mov	rax, QWORD PTR lr$[rsp]
	movzx	eax, BYTE PTR [rax+5]
	mov	BYTE PTR target$[rsp], al

; 134  :     if( lr->target_offset == 0 && lr->is_secondary ) {

	mov	rax, QWORD PTR lr$[rsp]
	cmp	DWORD PTR [rax+8], 0
	jne	SHORT $LN2@TranslateL
	mov	rax, QWORD PTR lr$[rsp]
	movzx	eax, BYTE PTR [rax+4]
	test	eax, eax
	je	SHORT $LN2@TranslateL

; 135  :         target |= 0x04; /* P=1 -> no displacement field */

	movzx	eax, BYTE PTR target$[rsp]
	or	eax, 4
	mov	BYTE PTR target$[rsp], al
$LN2@TranslateL:

; 136  :     }
; 137  :     p = buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 138  :     /* write the "Fix Data" field, FfffTPtt:
; 139  :      * F  : 0 = frame method is defined in fff field ( F0-F5)
; 140  :      *      1 = frame is defined by a thread ( won't occur here )
; 141  :      * fff: frame method
; 142  :      * T  : 0 = target is defined by tt
; 143  :      *      1 = target is defined by thread# in tt, P is used as bit 2 for method
; 144  :      * P  : 0 = target displacement field is present
; 145  :      *      1 = no displacement field
; 146  :      * tt : target method
; 147  :      */
; 148  :     *p++ = ( lr->frame << 4 ) | ( target );

	mov	rax, QWORD PTR lr$[rsp]
	movzx	eax, BYTE PTR [rax]
	shl	eax, 4
	movzx	ecx, BYTE PTR target$[rsp]
	or	eax, ecx
	mov	rcx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 149  :     p = putFrameDatum( p, lr->frame, lr->frame_datum );

	mov	rax, QWORD PTR lr$[rsp]
	movzx	r8d, WORD PTR [rax+2]
	mov	rax, QWORD PTR lr$[rsp]
	movzx	edx, BYTE PTR [rax]
	mov	rcx, QWORD PTR p$[rsp]
	call	putFrameDatum
	mov	QWORD PTR p$[rsp], rax

; 150  :     p = putTargetDatum( p, target, lr->target_datum );

	mov	rax, QWORD PTR lr$[rsp]
	movzx	r8d, WORD PTR [rax+6]
	movzx	edx, BYTE PTR target$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	putTargetDatum
	mov	QWORD PTR p$[rsp], rax

; 151  :     if( ( target & 0x04 ) == 0 ) {

	movzx	eax, BYTE PTR target$[rsp]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN3@TranslateL

; 152  :         if( type == FIX_GEN_MS386 ) {

	cmp	DWORD PTR type$[rsp], 1
	jne	SHORT $LN4@TranslateL

; 153  :             p = put32( p, (uint_32)lr->target_offset );

	mov	rax, QWORD PTR lr$[rsp]
	mov	edx, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR p$[rsp]
	call	put32
	mov	QWORD PTR p$[rsp], rax

; 154  :         } else {

	jmp	SHORT $LN5@TranslateL
$LN4@TranslateL:

; 155  :             p = put16( p, (uint_16)lr->target_offset );

	mov	rax, QWORD PTR lr$[rsp]
	movzx	edx, WORD PTR [rax+8]
	mov	rcx, QWORD PTR p$[rsp]
	call	put16
	mov	QWORD PTR p$[rsp], rax
$LN5@TranslateL:
$LN3@TranslateL:

; 156  :         }
; 157  :     }
; 158  :     return( p - buf );

	mov	rax, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	sub	rcx, rax
	mov	rax, rcx

; 159  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
TranslateLogref ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
_TEXT	SEGMENT
p$ = 48
method$ = 56
datum$ = 64
putTargetDatum PROC

; 97   : {

	mov	WORD PTR [rsp+24], r8w
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 98   : #if 0 /* v2.12: HJWasm won't use TARGE_ABSxx; also, it's not defined for FIXUP sub-records */
; 99   :     if( ( method & 0x03 ) == TARGET_ABSWD ) {
; 100  :         return( put16( p, datum ) );
; 101  :     }
; 102  : #endif
; 103  :     return( putIndex( p, datum ) );

	movzx	edx, WORD PTR datum$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	putIndex

; 104  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
putTargetDatum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
_TEXT	SEGMENT
tv65 = 32
p$ = 64
method$ = 72
datum$ = 80
putFrameDatum PROC

; 80   : {

	mov	WORD PTR [rsp+24], r8w
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 81   :     switch( method ) {

	movzx	eax, BYTE PTR method$[rsp]
	mov	BYTE PTR tv65[rsp], al
	cmp	BYTE PTR tv65[rsp], 0
	jb	SHORT $LN2@putFrameDa
	cmp	BYTE PTR tv65[rsp], 2
	jbe	SHORT $LN4@putFrameDa
	jmp	SHORT $LN2@putFrameDa
$LN4@putFrameDa:

; 82   :     case FRAME_SEG:
; 83   :     case FRAME_GRP:
; 84   :     case FRAME_EXT:
; 85   :         return( putIndex( p, datum ) );

	movzx	edx, WORD PTR datum$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	putIndex
	jmp	SHORT $LN1@putFrameDa
$LN2@putFrameDa:

; 86   : #if 0  /* v2.12: FRAME_ABS is invalid according to TIS OMF docs. */
; 87   :     case FRAME_ABS:
; 88   :         return( put16( p, datum ) );
; 89   : #endif
; 90   :     }
; 91   :     /* for FRAME_LOC & FRAME_TARG ( & FRAME_NONE ) there's no datum to write. */
; 92   :     return( p );

	mov	rax, QWORD PTR p$[rsp]
$LN1@putFrameDa:

; 93   : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
putFrameDatum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
_TEXT	SEGMENT
p$ = 16
value$ = 24
put32	PROC

; 73   : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 74   :     WriteU32( p, value );

	mov	rax, QWORD PTR p$[rsp]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax], ecx

; 75   :     return( p + sizeof( uint_32 ) );

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 4

; 76   : }

	pop	rdi
	ret	0
put32	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
_TEXT	SEGMENT
p$ = 16
value$ = 24
put16	PROC

; 66   : {

	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 67   :     WriteU16( p, value );

	mov	rax, QWORD PTR p$[rsp]
	movzx	ecx, WORD PTR value$[rsp]
	mov	WORD PTR [rax], cx

; 68   :     return( p + sizeof( uint_16 ) );

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 2

; 69   : }

	pop	rdi
	ret	0
put16	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
_TEXT	SEGMENT
p$ = 16
index$ = 24
putIndex PROC

; 56   : {

	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 57   :     if( index > 0x7f ) {

	movzx	eax, WORD PTR index$[rsp]
	cmp	eax, 127				; 0000007fH
	jle	SHORT $LN2@putIndex

; 58   :         *p++ = 0x80 | ( index >> 8 );

	movzx	eax, WORD PTR index$[rsp]
	sar	eax, 8
	bts	eax, 7
	mov	rcx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN2@putIndex:

; 59   :     }
; 60   :     *p++ = index;

	mov	rax, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR index$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 61   :     return( p );

	mov	rax, QWORD PTR p$[rsp]

; 62   : }

	pop	rdi
	ret	0
putIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
_TEXT	SEGMENT
sym$ = 64
lr$ = 88
tv94 = 128
tv145 = 136
__$ArrayPad$ = 144
fixup$ = 176
buf$ = 184
displ$ = 192
type$ = 200
OmfFixGenFixModend PROC

; 194  : {

$LN12:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 160				; 000000a0H
	mov	rdi, rsp
	mov	ecx, 40					; 00000028H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+176]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 195  :     struct asym *sym = fixup->sym;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR sym$[rsp], rax

; 196  :     struct logref lr;
; 197  : 
; 198  :     lr.is_secondary = FALSE;

	mov	BYTE PTR lr$[rsp+4], 0

; 199  :     lr.target_offset = sym->offset + displ;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	add	eax, DWORD PTR displ$[rsp]
	mov	DWORD PTR lr$[rsp+8], eax

; 200  : 
; 201  :     lr.frame_datum = fixup->frame_datum;

	mov	rax, QWORD PTR fixup$[rsp]
	movzx	eax, WORD PTR [rax+42]
	mov	WORD PTR lr$[rsp+2], ax

; 202  : 
; 203  :     /* symbol is always a code label (near or far), internal or external */
; 204  :     /* now set Target and Frame */
; 205  : 
; 206  :     if( sym->state == SYM_EXTERNAL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	$LN2@OmfFixGenF

; 207  :         DebugMsg(("omf_write_modend(%p): fixup->frame_type/datum=%u/%u, EXTERNAL sym=%s\n",

	mov	rax, QWORD PTR fixup$[rsp]
	movzx	eax, WORD PTR [rax+42]
	mov	rcx, QWORD PTR fixup$[rsp]
	movsx	ecx, BYTE PTR [rcx+40]
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsp+32], rdx
	mov	r9d, eax
	mov	r8d, ecx
	mov	rdx, QWORD PTR fixup$[rsp]
	lea	rcx, OFFSET FLAT:$SG10693
	call	DoDebugMsg

; 208  :                   fixup, fixup->frame_type, fixup->frame_datum, sym->name));
; 209  : 
; 210  :         lr.target = TARGET_EXT & TARGET_WITH_DISPL;

	mov	BYTE PTR lr$[rsp+5], 2

; 211  :         lr.target_datum = sym->ext_idx1;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, WORD PTR [rax+88]
	mov	WORD PTR lr$[rsp+6], ax

; 212  : 
; 213  :         if( fixup->frame_type == FRAME_GRP && fixup->frame_datum == 0 ) {

	mov	rax, QWORD PTR fixup$[rsp]
	movsx	eax, BYTE PTR [rax+40]
	cmp	eax, 1
	jne	SHORT $LN4@OmfFixGenF
	mov	rax, QWORD PTR fixup$[rsp]
	movzx	eax, WORD PTR [rax+42]
	test	eax, eax
	jne	SHORT $LN4@OmfFixGenF

; 214  :             /* set the frame to the frame of the corresponding segment */
; 215  :             lr.frame_datum = omf_GetGrpIdx( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	omf_GetGrpIdx
	mov	WORD PTR lr$[rsp+2], ax
$LN4@OmfFixGenF:

; 216  :         }
; 217  :     } else { /* SYM_INTERNAL */

	jmp	$LN3@OmfFixGenF
$LN2@OmfFixGenF:

; 218  :         DebugMsg(("OmfFixGenFixModend(%p): fixup->frame_type/datum=%u/%u sym->name=%s state=%X segm=%s\n",

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN8@OmfFixGenF
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv94[rsp], rax
	jmp	SHORT $LN9@OmfFixGenF
$LN8@OmfFixGenF:
	lea	rax, OFFSET FLAT:$SG10695
	mov	QWORD PTR tv94[rsp], rax
$LN9@OmfFixGenF:
	mov	rax, QWORD PTR fixup$[rsp]
	movzx	eax, WORD PTR [rax+42]
	mov	rcx, QWORD PTR fixup$[rsp]
	movsx	ecx, BYTE PTR [rcx+40]
	mov	rdx, QWORD PTR tv94[rsp]
	mov	QWORD PTR [rsp+48], rdx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR [rdx+32]
	mov	DWORD PTR [rsp+40], edx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsp+32], rdx
	mov	r9d, eax
	mov	r8d, ecx
	mov	rdx, QWORD PTR fixup$[rsp]
	lea	rcx, OFFSET FLAT:$SG10696
	call	DoDebugMsg

; 219  :                   fixup, fixup->frame_type, fixup->frame_datum, sym->name, sym->state, sym->segment ? sym->segment->name : "NULL" ));
; 220  :         /**/myassert( sym->state == SYM_INTERNAL );

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN10@OmfFixGenF
	mov	DWORD PTR tv145[rsp], 0
	jmp	SHORT $LN11@OmfFixGenF
$LN10@OmfFixGenF:
	mov	edx, 220				; 000000dcH
	lea	rcx, OFFSET FLAT:$SG10697
	call	InternalError
	mov	DWORD PTR tv145[rsp], eax
$LN11@OmfFixGenF:

; 221  : 
; 222  :         lr.target = TARGET_SEG & TARGET_WITH_DISPL;

	mov	BYTE PTR lr$[rsp+5], 0

; 223  :         lr.target_datum = GetSegIdx( sym->segment );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	GetSegIdx
	mov	WORD PTR lr$[rsp+6], ax
$LN3@OmfFixGenF:

; 224  :     }
; 225  : 
; 226  :     if( fixup->frame_type != FRAME_NONE && fixup->frame_type != FRAME_SEG ) {

	mov	rax, QWORD PTR fixup$[rsp]
	movsx	eax, BYTE PTR [rax+40]
	cmp	eax, 6
	je	SHORT $LN5@OmfFixGenF
	mov	rax, QWORD PTR fixup$[rsp]
	movsx	eax, BYTE PTR [rax+40]
	test	eax, eax
	je	SHORT $LN5@OmfFixGenF

; 227  :         lr.frame = (uint_8)fixup->frame_type;

	mov	rax, QWORD PTR fixup$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	mov	BYTE PTR lr$[rsp], al

; 228  :     } else {

	jmp	SHORT $LN6@OmfFixGenF
$LN5@OmfFixGenF:

; 229  :         lr.frame = FRAME_TARG;

	mov	BYTE PTR lr$[rsp], 5
$LN6@OmfFixGenF:

; 230  :     }
; 231  :     return( TranslateLogref( &lr, buf, type ) );

	mov	r8d, DWORD PTR type$[rsp]
	mov	rdx, QWORD PTR buf$[rsp]
	lea	rcx, QWORD PTR lr$[rsp]
	call	TranslateLogref

; 232  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:OmfFixGenFixModend$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
OmfFixGenFixModend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
_TEXT	SEGMENT
locat1$ = 32
self_relative$ = 33
data_rec_offset$ = 36
lr$ = 56
tv68 = 96
tv73 = 100
tv79 = 104
tv81 = 108
tv86 = 112
tv92 = 116
tv131 = 120
tv139 = 128
tv153 = 132
__$ArrayPad$ = 136
fixup$ = 160
start_loc$ = 168
buf$ = 176
type$ = 184
OmfFixGenFix PROC

; 370  : {

$LN34:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 144				; 00000090H
	mov	rdi, rsp
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+160]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 371  :     uint_8  locat1;
; 372  :     uint_8  self_relative = FALSE;

	mov	BYTE PTR self_relative$[rsp], 0

; 373  :     unsigned data_rec_offset;
; 374  :     struct logref lr;
; 375  : 
; 376  :     /**/myassert( fixup != NULL );

	cmp	QWORD PTR fixup$[rsp], 0
	je	SHORT $LN17@OmfFixGenF
	mov	DWORD PTR tv68[rsp], 0
	jmp	SHORT $LN18@OmfFixGenF
$LN17@OmfFixGenF:
	mov	edx, 376				; 00000178H
	lea	rcx, OFFSET FLAT:$SG10771
	call	InternalError
	mov	DWORD PTR tv68[rsp], eax
$LN18@OmfFixGenF:

; 377  :     /**/myassert( buf != NULL );

	cmp	QWORD PTR buf$[rsp], 0
	je	SHORT $LN19@OmfFixGenF
	mov	DWORD PTR tv73[rsp], 0
	jmp	SHORT $LN20@OmfFixGenF
$LN19@OmfFixGenF:
	mov	edx, 377				; 00000179H
	lea	rcx, OFFSET FLAT:$SG10772
	call	InternalError
	mov	DWORD PTR tv73[rsp], eax
$LN20@OmfFixGenF:

; 378  :     /**/myassert( type == FIX_GEN_INTEL || type == FIX_GEN_MS386 );

	cmp	DWORD PTR type$[rsp], 0
	je	SHORT $LN21@OmfFixGenF
	cmp	DWORD PTR type$[rsp], 1
	je	SHORT $LN21@OmfFixGenF
	mov	edx, 378				; 0000017aH
	lea	rcx, OFFSET FLAT:$SG10773
	call	InternalError
	mov	DWORD PTR tv79[rsp], eax
	jmp	SHORT $LN22@OmfFixGenF
$LN21@OmfFixGenF:
	mov	DWORD PTR tv79[rsp], 0
$LN22@OmfFixGenF:

; 379  : 
; 380  :     lr.is_secondary = TRUE;

	mov	BYTE PTR lr$[rsp+4], 1

; 381  :     lr.target_offset = 0;

	mov	DWORD PTR lr$[rsp+8], 0

; 382  : 
; 383  :     switch( fixup->type ) {

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv81[rsp], eax
	mov	eax, DWORD PTR tv81[rsp]
	dec	eax
	mov	DWORD PTR tv81[rsp], eax
	cmp	DWORD PTR tv81[rsp], 10
	ja	$LN14@OmfFixGenF
	movsxd	rax, DWORD PTR tv81[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN33@OmfFixGenF[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@OmfFixGenF:

; 384  :     case FIX_RELOFF8:
; 385  :         self_relative = TRUE;

	mov	BYTE PTR self_relative$[rsp], 1
$LN5@OmfFixGenF:

; 386  :         /* no break */
; 387  :     case FIX_OFF8:
; 388  :         locat1 = ( LOC_OFFSET_LO << 2 );

	mov	BYTE PTR locat1$[rsp], 0

; 389  :         break;

	jmp	$LN2@OmfFixGenF
$LN6@OmfFixGenF:

; 390  :     case FIX_RELOFF16:
; 391  :         self_relative = TRUE;

	mov	BYTE PTR self_relative$[rsp], 1
$LN7@OmfFixGenF:

; 392  :         /* no break */
; 393  :     case FIX_OFF16:
; 394  :         locat1 = ( fixup->loader_resolved ? LOC_MS_LINK_OFFSET << 2 : LOC_OFFSET << 2 );

	mov	rax, QWORD PTR fixup$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@OmfFixGenF
	mov	DWORD PTR tv86[rsp], 20
	jmp	SHORT $LN24@OmfFixGenF
$LN23@OmfFixGenF:
	mov	DWORD PTR tv86[rsp], 4
$LN24@OmfFixGenF:
	movzx	eax, BYTE PTR tv86[rsp]
	mov	BYTE PTR locat1$[rsp], al

; 395  :         break;

	jmp	$LN2@OmfFixGenF
$LN8@OmfFixGenF:

; 396  :     case FIX_RELOFF32:
; 397  :         self_relative = TRUE;

	mov	BYTE PTR self_relative$[rsp], 1
$LN9@OmfFixGenF:

; 398  :         /* no break */
; 399  :     case FIX_OFF32:
; 400  :         locat1 = ( fixup->loader_resolved ? LOC_MS_LINK_OFFSET_32 << 2 : LOC_MS_OFFSET_32 << 2 );

	mov	rax, QWORD PTR fixup$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN25@OmfFixGenF
	mov	DWORD PTR tv92[rsp], 52			; 00000034H
	jmp	SHORT $LN26@OmfFixGenF
$LN25@OmfFixGenF:
	mov	DWORD PTR tv92[rsp], 36			; 00000024H
$LN26@OmfFixGenF:
	movzx	eax, BYTE PTR tv92[rsp]
	mov	BYTE PTR locat1$[rsp], al

; 401  :         break;

	jmp	SHORT $LN2@OmfFixGenF
$LN10@OmfFixGenF:

; 402  :     case FIX_HIBYTE:
; 403  :         locat1 = ( LOC_OFFSET_HI << 2 );

	mov	BYTE PTR locat1$[rsp], 16

; 404  :         break;

	jmp	SHORT $LN2@OmfFixGenF
$LN11@OmfFixGenF:

; 405  :     case FIX_SEG:
; 406  :         locat1 = ( LOC_BASE << 2 );

	mov	BYTE PTR locat1$[rsp], 8

; 407  :         break;

	jmp	SHORT $LN2@OmfFixGenF
$LN12@OmfFixGenF:

; 408  :     case FIX_PTR16:
; 409  :         locat1 = ( LOC_BASE_OFFSET << 2 );

	mov	BYTE PTR locat1$[rsp], 12

; 410  :         break;

	jmp	SHORT $LN2@OmfFixGenF
$LN13@OmfFixGenF:

; 411  :     case FIX_PTR32:
; 412  :         locat1 = ( LOC_MS_BASE_OFFSET_32 << 2 );

	mov	BYTE PTR locat1$[rsp], 44		; 0000002cH

; 413  :         break;

	jmp	SHORT $LN2@OmfFixGenF
$LN14@OmfFixGenF:

; 414  :     default: /* shouldn't happen. Check for valid fixup has already happened */
; 415  :         EmitErr( UNSUPPORTED_FIXUP_TYPE,

	mov	rax, QWORD PTR fixup$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN27@OmfFixGenF
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv131[rsp], rax
	jmp	SHORT $LN28@OmfFixGenF
$LN27@OmfFixGenF:
	lea	rax, OFFSET FLAT:szNull
	mov	QWORD PTR tv131[rsp], rax
$LN28@OmfFixGenF:
	mov	rax, QWORD PTR ModuleInfo+344
	add	rax, 10
	mov	r8, QWORD PTR tv131[rsp]
	mov	rdx, rax
	mov	ecx, 197				; 000000c5H
	call	EmitErr

; 416  :                ModuleInfo.fmtopt->formatname,
; 417  :                fixup->sym ? fixup->sym->name : szNull );
; 418  :         return( 0 );

	xor	eax, eax
	jmp	$LN1@OmfFixGenF
$LN2@OmfFixGenF:

; 419  :     }
; 420  :     locat1 |= self_relative ? 0x80 : 0xc0; /* bit 7: 1=is a fixup subrecord */

	movzx	eax, BYTE PTR self_relative$[rsp]
	test	eax, eax
	je	SHORT $LN29@OmfFixGenF
	mov	DWORD PTR tv139[rsp], 128		; 00000080H
	jmp	SHORT $LN30@OmfFixGenF
$LN29@OmfFixGenF:
	mov	DWORD PTR tv139[rsp], 192		; 000000c0H
$LN30@OmfFixGenF:
	movzx	eax, BYTE PTR locat1$[rsp]
	or	eax, DWORD PTR tv139[rsp]
	mov	BYTE PTR locat1$[rsp], al

; 421  : 
; 422  :     if ( omf_fill_logref( fixup, &lr ) == 0 )

	lea	rdx, QWORD PTR lr$[rsp]
	mov	rcx, QWORD PTR fixup$[rsp]
	call	omf_fill_logref
	test	eax, eax
	jne	SHORT $LN15@OmfFixGenF

; 423  :         return( 0 );

	xor	eax, eax
	jmp	$LN1@OmfFixGenF
$LN15@OmfFixGenF:

; 424  : 
; 425  :     /* magnitude of fixup's position is 10! */
; 426  :     /**/myassert( fixup->locofs - start_loc < 1024 );

	mov	rax, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR start_loc$[rsp]
	mov	eax, DWORD PTR [rax+20]
	sub	eax, ecx
	cmp	eax, 1024				; 00000400H
	jae	SHORT $LN31@OmfFixGenF
	mov	DWORD PTR tv153[rsp], 0
	jmp	SHORT $LN32@OmfFixGenF
$LN31@OmfFixGenF:
	mov	edx, 426				; 000001aaH
	lea	rcx, OFFSET FLAT:$SG10786
	call	InternalError
	mov	DWORD PTR tv153[rsp], eax
$LN32@OmfFixGenF:

; 427  : 
; 428  :     /* calculate the fixup's position in current LEDATA */
; 429  :     data_rec_offset = fixup->locofs - start_loc;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR start_loc$[rsp]
	mov	eax, DWORD PTR [rax+20]
	sub	eax, ecx
	mov	DWORD PTR data_rec_offset$[rsp], eax

; 430  : 
; 431  :     locat1 |= data_rec_offset >> 8;

	mov	eax, DWORD PTR data_rec_offset$[rsp]
	shr	eax, 8
	movzx	ecx, BYTE PTR locat1$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR locat1$[rsp], al

; 432  :     *buf = locat1;

	mov	rax, QWORD PTR buf$[rsp]
	movzx	ecx, BYTE PTR locat1$[rsp]
	mov	BYTE PTR [rax], cl

; 433  :     *(buf+1) = (uint_8)data_rec_offset;

	mov	rax, QWORD PTR buf$[rsp]
	movzx	ecx, BYTE PTR data_rec_offset$[rsp]
	mov	BYTE PTR [rax+1], cl

; 434  :     return( 2 + TranslateLogref( &lr, buf+2, type ) );

	mov	rax, QWORD PTR buf$[rsp]
	add	rax, 2
	mov	r8d, DWORD PTR type$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR lr$[rsp]
	call	TranslateLogref
	add	eax, 2
$LN1@OmfFixGenF:

; 435  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:OmfFixGenFix$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 144				; 00000090H
	pop	rdi
	ret	0
	npad	2
$LN33@OmfFixGenF:
	DD	$LN4@OmfFixGenF
	DD	$LN6@OmfFixGenF
	DD	$LN8@OmfFixGenF
	DD	$LN5@OmfFixGenF
	DD	$LN7@OmfFixGenF
	DD	$LN9@OmfFixGenF
	DD	$LN14@OmfFixGenF
	DD	$LN11@OmfFixGenF
	DD	$LN12@OmfFixGenF
	DD	$LN13@OmfFixGenF
	DD	$LN10@OmfFixGenF
OmfFixGenFix ENDP
_TEXT	ENDS
END
