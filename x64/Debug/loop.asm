; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG11029 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG11003 DB	'LoopDirective(%s) enter', 0aH, 00H
	ORG $+7
$SG11011 DB	'LoopDirective(%s): invalid argument type %u', 0aH, 00H
	ORG $+3
$SG11016 DB	'LoopDirective(FOR/FORC): token %s is not a valid paramet'
	DB	'er name', 0aH, 00H
	ORG $+7
$SG11028 DB	'LoopDirective(FOR): param string >%s<', 0aH, 00H
	ORG $+1
$SG11030 DB	'LoopDirective(%s): calling StoreMacro', 0aH, 00H
	ORG $+1
$SG11035 DB	'LoopDirective REPT: iteration=%u', 0aH, 00H
	ORG $+6
$SG11037 DB	'LoopDirective WHILE: cnt=%u', 0aH, 00H
	ORG $+3
$SG11047 DB	'LoopDirective FORC: call RunMacro(), cnt=%u, param=>%s<', 0aH
	DB	00H
	ORG $+7
$SG11049 DB	'LoopDirective FOR: full param=>%s<', 0aH, 00H
	ORG $+4
$SG11051 DB	'LoopDirective FOR: cnt=%u, calling RunMacro( param=>%s< '
	DB	')', 0aH, 00H
	ORG $+5
$SG11054 DB	'LoopDirective(%s) exit', 0aH, 00H
_DATA	ENDS
PUBLIC	LoopDirective
EXTRN	__report_rangecheckfailure:PROC
EXTRN	isalpha:PROC
EXTRN	isspace:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	get_curr_srcfile:PROC
EXTRN	EvalOperand:PROC
EXTRN	Tokenize:PROC
EXTRN	RunMacro:PROC
EXTRN	ReleaseMacroData:PROC
EXTRN	StoreMacro:PROC
EXTRN	LstWriteSrcLine:PROC
EXTRN	GetResWName:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$LoopDirective DD imagerel $LN73
	DD	imagerel $LN73+3672
	DD	imagerel $unwind$LoopDirective
pdata	ENDS
xdata	SEGMENT
$unwind$LoopDirective DD 035042719H
	DD	01113316H
	DD	0500a0038H
	DD	imagerel __GSHandlerCheck
	DD	01b0H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\loop.c
_TEXT	SEGMENT
is_exitm$ = 0
buffer$ = 4
count$ = 8
len$ = 12
macro$ = 16
ptr$ = 24
directive$ = 32
tv410 = 36
parmstring$ = 40
tv77 = 48
arg_loc$ = 52
tv198 = 56
ptr2$1 = 64
tv434 = 72
tv534 = 76
tv619 = 80
$T2 = 88
$T3 = 96
macinfo$ = 104
opnd$ = 144
tmpmacro$ = 256
__$ArrayPad$ = 384
i$ = 416
tokenarray$ = 424
LoopDirective PROC

; 26   : {

$LN73:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 448				; 000001c0H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax

; 27   :     int directive = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR directive$[rbp], eax

; 28   :     int arg_loc;
; 29   :     int len;
; 30   :     //int skipcomma;
; 31   :     char *parmstring;
; 32   :     char *ptr;
; 33   :     struct dsym *macro;
; 34   :     bool is_exitm;
; 35   :     struct expr opnd;
; 36   :     struct macro_info macinfo;
; 37   :     struct dsym tmpmacro;
; 38   : #ifdef DEBUG_OUT
; 39   :     uint_32 count = 0;

	mov	DWORD PTR count$[rbp], 0

; 40   : #endif
; 41   :     /* v2.08: use myalloca() to get space to store the argument */
; 42   :     //char line[MAX_LINE_LEN];
; 43   :     char buffer[4];
; 44   : 
; 45   :     DebugMsg1(("LoopDirective(%s) enter\n", GetResWName( directive, NULL ) ));

	xor	edx, edx
	mov	ecx, DWORD PTR directive$[rbp]
	call	GetResWName
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11003
	call	DoDebugMsg1

; 46   : 
; 47   :     i++; /* skip directive */

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax

; 48   :     if ( ModuleInfo.list == TRUE ) LstWriteSrcLine();

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN23@LoopDirect
	call	LstWriteSrcLine
$LN23@LoopDirect:

; 49   : 
; 50   :     switch ( directive ) {

	mov	eax, DWORD PTR directive$[rbp]
	mov	DWORD PTR tv77[rbp], eax
	cmp	DWORD PTR tv77[rbp], 394		; 0000018aH
	jl	$LN31@LoopDirect
	cmp	DWORD PTR tv77[rbp], 395		; 0000018bH
	jle	SHORT $LN25@LoopDirect
	cmp	DWORD PTR tv77[rbp], 396		; 0000018cH
	je	SHORT $LN24@LoopDirect
	jmp	$LN31@LoopDirect
$LN24@LoopDirect:

; 51   :     case T_WHILE:
; 52   :         arg_loc = i;

	mov	eax, DWORD PTR i$[rbp]
	mov	DWORD PTR arg_loc$[rbp], eax
$LN25@LoopDirect:

; 53   :         /* no break */
; 54   :     case T_REPT:
; 55   :     case T_REPEAT:
; 56   :         /* the expression is "critical", that is, no forward
; 57   :          * referenced symbols may be used here!
; 58   :          */
; 59   :         if ( EvalOperand( &i, tokenarray, Token_Count, &opnd, EXPF_NOUNDEF ) == ERROR ) {

	mov	BYTE PTR [rsp+32], 2
	lea	r9, QWORD PTR opnd$[rbp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rbp]
	lea	rcx, QWORD PTR i$[rbp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN26@LoopDirect

; 60   :             opnd.value = 0;

	mov	DWORD PTR opnd$[rbp], 0

; 61   :             i = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rbp], eax
	jmp	$LN27@LoopDirect
$LN26@LoopDirect:

; 62   :         } else if ( opnd.kind != EXPR_CONST ) { /* syntax <REPEAT|WHILE 'A'> is valid! */

	cmp	DWORD PTR opnd$[rbp+60], 0
	je	SHORT $LN28@LoopDirect

; 63   :             DebugMsg(( "LoopDirective(%s): invalid argument type %u\n", GetResWName( directive, NULL ), opnd.kind ));

	xor	edx, edx
	mov	ecx, DWORD PTR directive$[rbp]
	call	GetResWName
	mov	r8d, DWORD PTR opnd$[rbp+60]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11011
	call	DoDebugMsg

; 64   :             EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 65   :             opnd.value = 0;

	mov	DWORD PTR opnd$[rbp], 0
	jmp	SHORT $LN29@LoopDirect
$LN28@LoopDirect:

; 66   :         } else if( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN30@LoopDirect

; 67   :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 68   :             /* v2.09: don't exit, the macro lines must be read first. */
; 69   :             //return( ERROR );
; 70   :             opnd.value = 0;

	mov	DWORD PTR opnd$[rbp], 0
$LN30@LoopDirect:
$LN29@LoopDirect:
$LN27@LoopDirect:

; 71   :         }
; 72   :         break;

	jmp	$LN2@LoopDirect
$LN31@LoopDirect:

; 73   :     default: /* FOR, FORC, IRP, IRPC */
; 74   :         /* get the formal parameter and the argument list */
; 75   :         /* the format parameter will become a macro parameter, so it can
; 76   :          * be a simple T_ID, but also an instruction or something else.
; 77   :          * v2.02: And it can begin with a '.'!
; 78   :          */
; 79   :         if( tokenarray[i].token == T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN32@LoopDirect

; 80   :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i-1].tokpos ) );

	mov	eax, DWORD PTR i$[rbp]
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@LoopDirect
$LN32@LoopDirect:

; 81   :         }
; 82   :         /* v2.02: allow parameter name to begin with a '.' */
; 83   :         //c = *tokenarray[i].string_ptr;
; 84   :         //if( ( is_valid_id_char(c) == FALSE ) || ( isdigit(c) == TRUE ) ) {
; 85   :         if( is_valid_id_first_char( *tokenarray[i].string_ptr ) == FALSE ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isalpha
	test	eax, eax
	jne	$LN64@LoopDirect
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	$LN64@LoopDirect
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN64@LoopDirect
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN64@LoopDirect
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN64@LoopDirect
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN65@LoopDirect
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 4
	and	eax, 1
	cmp	eax, 1
	je	SHORT $LN64@LoopDirect
$LN65@LoopDirect:
	mov	DWORD PTR tv198[rbp], 0
	jmp	SHORT $LN66@LoopDirect
$LN64@LoopDirect:
	mov	DWORD PTR tv198[rbp], 1
$LN66@LoopDirect:
	cmp	DWORD PTR tv198[rbp], 0
	jne	SHORT $LN33@LoopDirect

; 86   :             DebugMsg(( "LoopDirective(FOR/FORC): token %s is not a valid parameter name\n", tokenarray[i].string_ptr ));

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11016
	call	DoDebugMsg

; 87   :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@LoopDirect
$LN33@LoopDirect:

; 88   :         }
; 89   :         arg_loc = i;

	mov	eax, DWORD PTR i$[rbp]
	mov	DWORD PTR arg_loc$[rbp], eax

; 90   :         i++;

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax

; 91   : 
; 92   :         if( directive == T_FORC || directive == T_IRPC ) {

	cmp	DWORD PTR directive$[rbp], 391		; 00000187H
	je	SHORT $LN36@LoopDirect
	cmp	DWORD PTR directive$[rbp], 393		; 00000189H
	jne	$LN34@LoopDirect
$LN36@LoopDirect:

; 93   :             if( tokenarray[i].token != T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN37@LoopDirect

; 94   :                 return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	$LN1@LoopDirect
$LN37@LoopDirect:

; 95   :             }
; 96   :             i++;

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax

; 97   :             /* FORC/IRPC accepts anything as "argument list", even nothing! */
; 98   :             if( tokenarray[i].token == T_STRING && tokenarray[i].string_delim == '<' ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	$LN38@LoopDirect
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	jne	$LN38@LoopDirect

; 99   :                 len = tokenarray[i+1].tokpos - (tokenarray[i].tokpos+1);

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rdx+rcx+24]
	inc	rcx
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR len$[rbp], eax

; 100  :                 parmstring = myalloca( len );

	movsxd	rax, DWORD PTR len$[rbp]
	mov	rcx, rax
	add	rcx, 15
	cmp	rcx, rax
	ja	SHORT $LN72@LoopDirect
	mov	rcx, 1152921504606846960		; 0ffffffffffffff0H
$LN72@LoopDirect:
	and	rcx, -16
	mov	rax, rcx
	call	__chkstk
	sub	rsp, rax
	lea	rax, QWORD PTR [rsp+48]
	mov	QWORD PTR parmstring$[rbp], rax

; 101  :                 //GetLiteralValue( parmstring, tokenarray[i].string_ptr );
; 102  :                 memcpy( parmstring, tokenarray[i].tokpos+1, len );

	movsxd	rax, DWORD PTR len$[rbp]
	movsxd	rcx, DWORD PTR i$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rdx+rcx+24]
	inc	rcx
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR parmstring$[rbp]
	call	memcpy
$LN4@LoopDirect:

; 103  :                 while( *(parmstring+len-1) != '>' ) len--;

	movsxd	rax, DWORD PTR len$[rbp]
	mov	rcx, QWORD PTR parmstring$[rbp]
	movsx	eax, BYTE PTR [rcx+rax-1]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN5@LoopDirect
	mov	eax, DWORD PTR len$[rbp]
	dec	eax
	mov	DWORD PTR len$[rbp], eax
	jmp	SHORT $LN4@LoopDirect
$LN5@LoopDirect:

; 104  :                 *(parmstring+len-1) = NULLC;

	movsxd	rax, DWORD PTR len$[rbp]
	mov	rcx, QWORD PTR parmstring$[rbp]
	mov	BYTE PTR [rcx+rax-1], 0

; 105  :                 /* v2.02: if there's additional stuff behind the <> literal,
; 106  :                  * it's an error!
; 107  :                  */
; 108  :                 if ( tokenarray[i+1].token != T_FINAL )

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN40@LoopDirect

; 109  :                     EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].tokpos );

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN40@LoopDirect:

; 110  :             } else {

	jmp	$LN39@LoopDirect
$LN38@LoopDirect:

; 111  :                 char *ptr2;
; 112  :                 ptr = tokenarray[i].tokpos;

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR ptr$[rbp], rax

; 113  :                 ptr2 = ptr;

	mov	rax, QWORD PTR ptr$[rbp]
	mov	QWORD PTR ptr2$1[rbp], rax
$LN6@LoopDirect:

; 114  :                 /* this is what Masm does: use the string until a space
; 115  :                  * is detected. Anything beyond the space is ignored.
; 116  :                  */
; 117  :                 while ( *ptr2 && ( isspace( *ptr2 ) == FALSE ) )

	mov	rax, QWORD PTR ptr2$1[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN7@LoopDirect
	mov	rax, QWORD PTR ptr2$1[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isspace
	test	eax, eax
	jne	SHORT $LN7@LoopDirect

; 118  :                     ptr2++;

	mov	rax, QWORD PTR ptr2$1[rbp]
	inc	rax
	mov	QWORD PTR ptr2$1[rbp], rax
	jmp	SHORT $LN6@LoopDirect
$LN7@LoopDirect:

; 119  :                 len = ptr2 - ptr;

	mov	rax, QWORD PTR ptr$[rbp]
	mov	rcx, QWORD PTR ptr2$1[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR len$[rbp], eax

; 120  :                 parmstring = myalloca( len + 1 );

	mov	eax, DWORD PTR len$[rbp]
	inc	eax
	cdqe
	mov	rcx, rax
	add	rcx, 15
	cmp	rcx, rax
	ja	SHORT $LN71@LoopDirect
	mov	rcx, 1152921504606846960		; 0ffffffffffffff0H
$LN71@LoopDirect:
	and	rcx, -16
	mov	rax, rcx
	call	__chkstk
	sub	rsp, rax
	lea	rax, QWORD PTR [rsp+48]
	mov	QWORD PTR parmstring$[rbp], rax

; 121  :                 memcpy( parmstring, ptr, len );

	movsxd	rax, DWORD PTR len$[rbp]
	mov	r8, rax
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	rcx, QWORD PTR parmstring$[rbp]
	call	memcpy

; 122  :                 *(parmstring+len) = NULLC;

	movsxd	rax, DWORD PTR len$[rbp]
	mov	rcx, QWORD PTR parmstring$[rbp]
	mov	BYTE PTR [rcx+rax], 0
$LN39@LoopDirect:

; 123  :             }
; 124  :         } else {

	jmp	$LN35@LoopDirect
$LN34@LoopDirect:
$LN8@LoopDirect:

; 125  :             /* for FOR/IRP, skip everything between the name and the comma!
; 126  :              * these items will be stored as (first) macro parameter.
; 127  :              * for example, valid syntax is:
; 128  :              * FOR xxx,<a, ...>
; 129  :              * FOR xxx:REQ,<a, ...>
; 130  :              */
; 131  :             while ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA )

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN9@LoopDirect
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN9@LoopDirect

; 132  :                 i++;

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
	jmp	SHORT $LN8@LoopDirect
$LN9@LoopDirect:

; 133  :             if( tokenarray[i].token != T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN41@LoopDirect

; 134  :                 return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	$LN1@LoopDirect
$LN41@LoopDirect:

; 135  :             }
; 136  :             i++;

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax

; 137  :             /* FOR/IRP accepts a literal enclosed in <> only */
; 138  :             if( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN43@LoopDirect
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN42@LoopDirect
$LN43@LoopDirect:

; 139  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@LoopDirect
$LN42@LoopDirect:

; 140  :             }
; 141  :             /* v2.03: also ensure that the literal is the last item */
; 142  :             if( tokenarray[i+1].token != T_FINAL ) {

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN44@LoopDirect

; 143  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].tokpos ) );

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@LoopDirect
$LN44@LoopDirect:

; 144  :             }
; 145  :             /* v2.08: use myalloca() instead of a fixed-length buffer.
; 146  :              * the loop directives are often nested, they call RunMacro()
; 147  :              * and hence should be careful with stack usage because of JWASMR!
; 148  :              */
; 149  :             //parmstring = myalloca( tokenarray[i].stringlen + 1 );
; 150  :             /* v2.0: use GetLiteralValue() instead of memcpy!!! */
; 151  :             //memcpy( line, tokenarray[i].string_ptr, tokenarray[i].stringlen + 1 );
; 152  :             //GetLiteralValue( parmstring, tokenarray[i].string_ptr );
; 153  :             parmstring = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR parmstring$[rbp], rax

; 154  :             DebugMsg1(("LoopDirective(FOR): param string >%s<\n", parmstring));

	mov	rdx, QWORD PTR parmstring$[rbp]
	lea	rcx, OFFSET FLAT:$SG11028
	call	DoDebugMsg1
$LN35@LoopDirect:

; 155  :         }
; 156  :         /* to run StoreMacro(), tokenarray must be setup correctly. */
; 157  :         /* clear contents beginning with the comma! */
; 158  :         i--;

	mov	eax, DWORD PTR i$[rbp]
	dec	eax
	mov	DWORD PTR i$[rbp], eax

; 159  :         tokenarray[i].token = T_FINAL;

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	BYTE PTR [rcx+rax], 0

; 160  :         Token_Count = i;

	mov	eax, DWORD PTR i$[rbp]
	mov	DWORD PTR ModuleInfo+496, eax

; 161  :         i = arg_loc;

	mov	eax, DWORD PTR arg_loc$[rbp]
	mov	DWORD PTR i$[rbp], eax
$LN2@LoopDirect:

; 162  :     }
; 163  : 
; 164  :     /* now make a temporary macro */
; 165  :     macro = &tmpmacro;

	lea	rax, QWORD PTR tmpmacro$[rbp]
	mov	QWORD PTR macro$[rbp], rax

; 166  :     memset( &tmpmacro, 0, sizeof(tmpmacro) );

	mov	r8d, 120				; 00000078H
	xor	edx, edx
	lea	rcx, QWORD PTR tmpmacro$[rbp]
	call	memset

; 167  :     tmpmacro.sym.name = "";

	lea	rax, OFFSET FLAT:$SG11029
	mov	QWORD PTR tmpmacro$[rbp+8], rax

; 168  :     tmpmacro.e.macroinfo = &macinfo;

	lea	rax, QWORD PTR macinfo$[rbp]
	mov	QWORD PTR tmpmacro$[rbp+96], rax

; 169  :     memset( &macinfo, 0, sizeof(macinfo) );

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	lea	rcx, QWORD PTR macinfo$[rbp]
	call	memset

; 170  :     macinfo.srcfile = get_curr_srcfile();

	call	get_curr_srcfile
	mov	DWORD PTR macinfo$[rbp+28], eax

; 171  : 
; 172  : #if 0 //DEBUG_OUT
; 173  :     if ( directive ==  T_WHILE )
; 174  :         tmpmacro.sym.name = "<WHILE>";
; 175  :     else if ( directive == T_REPEAT || directive == T_REPT )
; 176  :         tmpmacro.sym.name = "<REPT>";
; 177  :     else if ( directive == T_FORC || directive == T_IRPC )
; 178  :         tmpmacro.sym.name = "<FORC>";
; 179  :     else
; 180  :         tmpmacro.sym.name = "<FOR>";
; 181  : #endif
; 182  : 
; 183  :     DebugMsg1(("LoopDirective(%s): calling StoreMacro\n", GetResWName( directive, NULL )));

	xor	edx, edx
	mov	ecx, DWORD PTR directive$[rbp]
	call	GetResWName
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11030
	call	DoDebugMsg1

; 184  :     if( StoreMacro( macro, i, tokenarray, TRUE ) == ERROR ) {

	mov	r9b, 1
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	edx, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR macro$[rbp]
	call	StoreMacro
	cmp	eax, -1
	jne	SHORT $LN45@LoopDirect

; 185  :         ReleaseMacroData( macro );

	mov	rcx, QWORD PTR macro$[rbp]
	call	ReleaseMacroData

; 186  :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@LoopDirect
$LN45@LoopDirect:

; 187  :     }
; 188  :     /* EXITM <> is allowed inside a macro loop.
; 189  :      * This doesn't make the loop a macro function, reset the bit!
; 190  :      */
; 191  :     macro->sym.isfunc = FALSE;

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR macro$[rbp]
	mov	BYTE PTR [rcx+44], al

; 192  : 
; 193  :     /* now run the just created macro in a loop */
; 194  : 
; 195  :     /* don't run the macro if there are no lines (macroinfo->data == NULL)!
; 196  :      * this isn't exactly what Masm does; an empty 'WHILE 1'
; 197  :      * will loop "forever" in Masm,
; 198  :      */
; 199  :     if ( macinfo.data ) /* added in v2.01 */

	cmp	QWORD PTR macinfo$[rbp+16], 0
	je	$LN46@LoopDirect

; 200  :     switch ( directive ) {

	mov	eax, DWORD PTR directive$[rbp]
	mov	DWORD PTR tv410[rbp], eax
	cmp	DWORD PTR tv410[rbp], 391		; 00000187H
	je	$LN52@LoopDirect
	cmp	DWORD PTR tv410[rbp], 393		; 00000189H
	je	$LN52@LoopDirect
	cmp	DWORD PTR tv410[rbp], 393		; 00000189H
	jle	$LN59@LoopDirect
	cmp	DWORD PTR tv410[rbp], 395		; 0000018bH
	jle	SHORT $LN47@LoopDirect
	cmp	DWORD PTR tv410[rbp], 396		; 0000018cH
	je	$LN49@LoopDirect
	jmp	$LN59@LoopDirect
$LN47@LoopDirect:

; 201  :     case T_REPEAT:
; 202  :     case T_REPT:
; 203  :         /* negative repeat counts are accepted and are treated like 0 */
; 204  :         for ( ; macro->sym.value < opnd.value; macro->sym.value++ ) {

	jmp	SHORT $LN14@LoopDirect
$LN12@LoopDirect:
	mov	rax, QWORD PTR macro$[rbp]
	mov	eax, DWORD PTR [rax+16]
	inc	eax
	mov	rcx, QWORD PTR macro$[rbp]
	mov	DWORD PTR [rcx+16], eax
$LN14@LoopDirect:
	mov	rax, QWORD PTR macro$[rbp]
	mov	ecx, DWORD PTR opnd$[rbp]
	cmp	DWORD PTR [rax+16], ecx
	jge	SHORT $LN13@LoopDirect

; 205  :             /* v2.10: Token_Count becomes volatile if MF_NOSAVE is set */
; 206  :             tokenarray[0].token = T_FINAL;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	BYTE PTR [rcx+rax], 0

; 207  :             Token_Count = 0;

	mov	DWORD PTR ModuleInfo+496, 0

; 208  :             //RunMacro( macro, Token_Count, tokenarray, NULL, MF_NOSAVE, &is_exitm );
; 209  :             RunMacro( macro, 0, tokenarray, NULL, MF_NOSAVE, &is_exitm );

	lea	rax, QWORD PTR is_exitm$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 2
	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rbp]
	xor	edx, edx
	mov	rcx, QWORD PTR macro$[rbp]
	call	RunMacro

; 210  :             if ( is_exitm )

	movzx	eax, BYTE PTR is_exitm$[rbp]
	test	eax, eax
	je	SHORT $LN48@LoopDirect

; 211  :                 break;

	jmp	SHORT $LN13@LoopDirect
$LN48@LoopDirect:

; 212  :             DebugMsg1(("LoopDirective REPT: iteration=%" I32_SPEC "u\n", ++count ));

	mov	eax, DWORD PTR count$[rbp]
	inc	eax
	mov	DWORD PTR count$[rbp], eax
	mov	edx, DWORD PTR count$[rbp]
	lea	rcx, OFFSET FLAT:$SG11035
	call	DoDebugMsg1

; 213  :         }

	jmp	$LN12@LoopDirect
$LN13@LoopDirect:

; 214  :         break;

	jmp	$LN10@LoopDirect
$LN49@LoopDirect:
$LN15@LoopDirect:

; 215  :     case T_WHILE:
; 216  :         while ( opnd.kind == EXPR_CONST && opnd.value != 0 ) {

	cmp	DWORD PTR opnd$[rbp+60], 0
	jne	$LN16@LoopDirect
	cmp	DWORD PTR opnd$[rbp], 0
	je	$LN16@LoopDirect

; 217  :             DebugMsg1(("LoopDirective WHILE: cnt=%u\n", count++ ));

	mov	eax, DWORD PTR count$[rbp]
	mov	DWORD PTR tv434[rbp], eax
	mov	edx, DWORD PTR tv434[rbp]
	lea	rcx, OFFSET FLAT:$SG11037
	call	DoDebugMsg1
	mov	eax, DWORD PTR count$[rbp]
	inc	eax
	mov	DWORD PTR count$[rbp], eax

; 218  :             RunMacro( macro, Token_Count, tokenarray, NULL, 0, &is_exitm );

	lea	rax, QWORD PTR is_exitm$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	edx, DWORD PTR ModuleInfo+496
	mov	rcx, QWORD PTR macro$[rbp]
	call	RunMacro

; 219  :             if ( is_exitm )

	movzx	eax, BYTE PTR is_exitm$[rbp]
	test	eax, eax
	je	SHORT $LN50@LoopDirect

; 220  :                 break;

	jmp	SHORT $LN16@LoopDirect
$LN50@LoopDirect:

; 221  :             i = arg_loc;

	mov	eax, DWORD PTR arg_loc$[rbp]
	mov	DWORD PTR i$[rbp], eax

; 222  :             if ( EvalOperand( &i, tokenarray, Token_Count, &opnd, 0 ) == ERROR )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opnd$[rbp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rbp]
	lea	rcx, QWORD PTR i$[rbp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN51@LoopDirect

; 223  :                 break;

	jmp	SHORT $LN16@LoopDirect
$LN51@LoopDirect:

; 224  :             macro->sym.value++;

	mov	rax, QWORD PTR macro$[rbp]
	mov	eax, DWORD PTR [rax+16]
	inc	eax
	mov	rcx, QWORD PTR macro$[rbp]
	mov	DWORD PTR [rcx+16], eax

; 225  :         }

	jmp	$LN15@LoopDirect
$LN16@LoopDirect:

; 226  :         break;

	jmp	$LN10@LoopDirect
$LN52@LoopDirect:

; 227  :     case T_FORC:
; 228  :     case T_IRPC:
; 229  :         for( ptr = parmstring; *ptr; ptr++, macro->sym.value++ ) {

	mov	rax, QWORD PTR parmstring$[rbp]
	mov	QWORD PTR ptr$[rbp], rax
	jmp	SHORT $LN19@LoopDirect
$LN17@LoopDirect:
	mov	rax, QWORD PTR ptr$[rbp]
	inc	rax
	mov	QWORD PTR ptr$[rbp], rax
	mov	rax, QWORD PTR macro$[rbp]
	mov	eax, DWORD PTR [rax+16]
	inc	eax
	mov	rcx, QWORD PTR macro$[rbp]
	mov	DWORD PTR [rcx+16], eax
$LN19@LoopDirect:
	mov	rax, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN18@LoopDirect

; 230  :             tokenarray[0].token = T_STRING;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	BYTE PTR [rcx+rax], 9

; 231  :             tokenarray[0].string_delim = NULLC;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	BYTE PTR [rcx+rax+1], 0

; 232  :             tokenarray[0].string_ptr = buffer;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	lea	rdx, QWORD PTR buffer$[rbp]
	mov	QWORD PTR [rcx+rax+8], rdx

; 233  :             tokenarray[0].tokpos = buffer;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	lea	rdx, QWORD PTR buffer$[rbp]
	mov	QWORD PTR [rcx+rax+24], rdx

; 234  :             tokenarray[1].token = T_FINAL;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	BYTE PTR [rcx+rax], 0

; 235  :             buffer[2] = NULLC;

	mov	eax, 1
	imul	rax, rax, 2
	mov	QWORD PTR $T2[rbp], rax
	cmp	QWORD PTR $T2[rbp], 4
	jae	SHORT $LN67@LoopDirect
	jmp	SHORT $LN68@LoopDirect
$LN67@LoopDirect:
	call	__report_rangecheckfailure
$LN68@LoopDirect:
	mov	rax, QWORD PTR $T2[rbp]
	mov	BYTE PTR buffer$[rbp+rax], 0

; 236  :             Token_Count = 1;

	mov	DWORD PTR ModuleInfo+496, 1

; 237  :             if ( *ptr == '!' ) {

	mov	rax, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN53@LoopDirect

; 238  :                 buffer[0] = *ptr++;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR ptr$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR buffer$[rbp+rax], cl
	mov	rax, QWORD PTR ptr$[rbp]
	inc	rax
	mov	QWORD PTR ptr$[rbp], rax

; 239  :                 buffer[1] = *ptr;

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR ptr$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR buffer$[rbp+rax], cl

; 240  :                 if ( *ptr == NULLC ) /* ensure the macro won't go beyond the 00 */

	mov	rax, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN55@LoopDirect

; 241  :                     ptr--;

	mov	rax, QWORD PTR ptr$[rbp]
	dec	rax
	mov	QWORD PTR ptr$[rbp], rax
$LN55@LoopDirect:

; 242  :                 tokenarray[0].stringlen = 2;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	DWORD PTR [rcx+rax+16], 2

; 243  :                 tokenarray[1].tokpos = buffer+2;

	lea	rax, QWORD PTR buffer$[rbp+2]
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	QWORD PTR [rdx+rcx+24], rax
	jmp	$LN54@LoopDirect
$LN53@LoopDirect:

; 244  :             } else if ( isspace( *ptr ) ) {

	mov	rax, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isspace
	test	eax, eax
	je	SHORT $LN56@LoopDirect

; 245  :                 buffer[0] = '!';

	mov	eax, 1
	imul	rax, rax, 0
	mov	BYTE PTR buffer$[rbp+rax], 33		; 00000021H

; 246  :                 buffer[1] = *ptr;

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR ptr$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR buffer$[rbp+rax], cl

; 247  :                 tokenarray[0].stringlen = 2;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	DWORD PTR [rcx+rax+16], 2

; 248  :                 tokenarray[1].tokpos = buffer+2;

	lea	rax, QWORD PTR buffer$[rbp+2]
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	QWORD PTR [rdx+rcx+24], rax

; 249  :             } else {

	jmp	SHORT $LN57@LoopDirect
$LN56@LoopDirect:

; 250  :                 buffer[0] = *ptr;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR ptr$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR buffer$[rbp+rax], cl

; 251  :                 tokenarray[0].stringlen = 1;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	DWORD PTR [rcx+rax+16], 1

; 252  :                 tokenarray[1].tokpos = buffer+1;

	lea	rax, QWORD PTR buffer$[rbp+1]
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	QWORD PTR [rdx+rcx+24], rax

; 253  :                 buffer[1] = NULLC;

	mov	QWORD PTR $T3[rbp], 1
	cmp	QWORD PTR $T3[rbp], 4
	jae	SHORT $LN69@LoopDirect
	jmp	SHORT $LN70@LoopDirect
$LN69@LoopDirect:
	call	__report_rangecheckfailure
$LN70@LoopDirect:
	mov	rax, QWORD PTR $T3[rbp]
	mov	BYTE PTR buffer$[rbp+rax], 0
$LN57@LoopDirect:
$LN54@LoopDirect:

; 254  :             }
; 255  :             RunMacro( macro, 0, tokenarray, NULL, MF_NOSAVE, &is_exitm );

	lea	rax, QWORD PTR is_exitm$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 2
	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rbp]
	xor	edx, edx
	mov	rcx, QWORD PTR macro$[rbp]
	call	RunMacro

; 256  :             if ( is_exitm )

	movzx	eax, BYTE PTR is_exitm$[rbp]
	test	eax, eax
	je	SHORT $LN58@LoopDirect

; 257  :                 break;

	jmp	SHORT $LN18@LoopDirect
$LN58@LoopDirect:

; 258  :             DebugMsg1(("LoopDirective FORC: call RunMacro(), cnt=%" I32_SPEC "u, param=>%s<\n", count++, buffer ));

	mov	eax, DWORD PTR count$[rbp]
	mov	DWORD PTR tv534[rbp], eax
	lea	r8, QWORD PTR buffer$[rbp]
	mov	edx, DWORD PTR tv534[rbp]
	lea	rcx, OFFSET FLAT:$SG11047
	call	DoDebugMsg1
	mov	eax, DWORD PTR count$[rbp]
	inc	eax
	mov	DWORD PTR count$[rbp], eax

; 259  :         }

	jmp	$LN17@LoopDirect
$LN18@LoopDirect:

; 260  :         break;

	jmp	$LN10@LoopDirect
$LN59@LoopDirect:

; 261  :     default: /* T_FOR, T_IRP */
; 262  :         i = Token_Count + 1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR i$[rbp], eax

; 263  :         Token_Count = Tokenize( parmstring, i, tokenarray, TOK_RESCAN | TOK_NOCURLBRACES );

	mov	r9d, 3
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	edx, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR parmstring$[rbp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 264  :         DebugMsg1(("LoopDirective FOR: full param=>%s<\n", tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11049
	call	DoDebugMsg1

; 265  : 
; 266  :         /* v2.09: if a trailing comma is followed by white space(s), add a blank token */
; 267  :         if ( i != Token_Count && tokenarray[Token_Count-1].token == T_COMMA &&

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rbp], eax
	je	$LN60@LoopDirect
	mov	eax, DWORD PTR ModuleInfo+496
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	$LN60@LoopDirect
	mov	eax, DWORD PTR ModuleInfo+496
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+24]
	movsx	eax, BYTE PTR [rax+1]
	test	eax, eax
	je	$LN60@LoopDirect

; 268  :             *(tokenarray[Token_Count-1].tokpos+1) ) {
; 269  :             tokenarray[Token_Count].token = T_STRING;

	movsxd	rax, DWORD PTR ModuleInfo+496
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	BYTE PTR [rcx+rax], 9

; 270  :             tokenarray[Token_Count].string_delim = NULLC;

	movsxd	rax, DWORD PTR ModuleInfo+496
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	BYTE PTR [rcx+rax+1], 0

; 271  :             tokenarray[Token_Count].stringlen = strlen( tokenarray[Token_Count].tokpos );

	movsxd	rax, DWORD PTR ModuleInfo+496
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rcx+rax+24]
	call	strlen
	movsxd	rcx, DWORD PTR ModuleInfo+496
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	DWORD PTR [rdx+rcx+16], eax

; 272  :             tokenarray[Token_Count+1].tokpos = tokenarray[Token_Count].tokpos + tokenarray[Token_Count].stringlen;

	movsxd	rax, DWORD PTR ModuleInfo+496
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR ModuleInfo+496
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	ecx, DWORD PTR [rdx+rcx+16]
	mov	rdx, QWORD PTR tokenarray$[rbp]
	add	rcx, QWORD PTR [rdx+rax+24]
	mov	rax, rcx
	mov	ecx, DWORD PTR ModuleInfo+496
	inc	ecx
	movsxd	rcx, ecx
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	QWORD PTR [rdx+rcx+24], rax

; 273  :             Token_Count++;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR ModuleInfo+496, eax

; 274  :             tokenarray[Token_Count].token = T_FINAL;

	movsxd	rax, DWORD PTR ModuleInfo+496
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	BYTE PTR [rcx+rax], 0
$LN60@LoopDirect:

; 275  :         }
; 276  : 
; 277  :         /* a FOR/IRP parameter can be a macro function call */
; 278  :         /* that's why the macro calls must be run synchronously */
; 279  :         /* v2.05: reset an optional VARARG attribute for the macro
; 280  :          * parameter.
; 281  :          * take care of a trailing comma, this is to make another
; 282  :          * RunMacro() call with a "blank" argument.
; 283  :          */
; 284  :         macro->sym.mac_vararg = FALSE;

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR macro$[rbp]
	mov	BYTE PTR [rcx+44], al

; 285  :         /* v2.09: flag MF_IGNARGS introduced. This allows RunMacro() to
; 286  :          * parse the full argument and trigger macro expansion if necessary.
; 287  :          * No need anymore to count commas here. */
; 288  :         for( ; i < Token_Count; i++, macro->sym.value++ ) {

	jmp	SHORT $LN22@LoopDirect
$LN20@LoopDirect:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
	mov	rax, QWORD PTR macro$[rbp]
	mov	eax, DWORD PTR [rax+16]
	inc	eax
	mov	rcx, QWORD PTR macro$[rbp]
	mov	DWORD PTR [rcx+16], eax
$LN22@LoopDirect:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rbp], eax
	jge	SHORT $LN21@LoopDirect

; 289  :             DebugMsg1(("LoopDirective FOR: cnt=%" I32_SPEC "u, calling RunMacro( param=>%s< )\n", count++, tokenarray[i].tokpos ));

	mov	eax, DWORD PTR count$[rbp]
	mov	DWORD PTR tv619[rbp], eax
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	edx, DWORD PTR tv619[rbp]
	lea	rcx, OFFSET FLAT:$SG11051
	call	DoDebugMsg1
	mov	eax, DWORD PTR count$[rbp]
	inc	eax
	mov	DWORD PTR count$[rbp], eax

; 290  :             i = RunMacro( macro, i, tokenarray, NULL, MF_IGNARGS, &is_exitm );

	lea	rax, QWORD PTR is_exitm$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 4
	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	edx, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR macro$[rbp]
	call	RunMacro
	mov	DWORD PTR i$[rbp], eax

; 291  :             if ( i < 0 || is_exitm )

	cmp	DWORD PTR i$[rbp], 0
	jl	SHORT $LN62@LoopDirect
	movzx	eax, BYTE PTR is_exitm$[rbp]
	test	eax, eax
	je	SHORT $LN61@LoopDirect
$LN62@LoopDirect:

; 292  :                 break;

	jmp	SHORT $LN21@LoopDirect
$LN61@LoopDirect:

; 293  :         }

	jmp	$LN20@LoopDirect
$LN21@LoopDirect:
$LN10@LoopDirect:
$LN46@LoopDirect:

; 294  :     }
; 295  :     ReleaseMacroData( macro );

	mov	rcx, QWORD PTR macro$[rbp]
	call	ReleaseMacroData

; 296  :     DebugMsg1(("LoopDirective(%s) exit\n", GetResWName( directive, NULL ) ));

	xor	edx, edx
	mov	ecx, DWORD PTR directive$[rbp]
	call	GetResWName
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11054
	call	DoDebugMsg1

; 297  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@LoopDirect:
$LN63@LoopDirect:

; 298  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+400]
	pop	rbp
	ret	0
LoopDirective ENDP
_TEXT	ENDS
END
