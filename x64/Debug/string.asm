; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG11183 DB	01H DUP (?)
$SG11184 DB	01H DUP (?)
$SG11185 DB	01H DUP (?)
$SG11203 DB	01H DUP (?)
$SG11219 DB	01H DUP (?)
$SG11220 DB	01H DUP (?)
$SG11221 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG10982 DB	'CatStrDir(%u) enter', 0aH, 00H
	ORG $+3
$SG10983 DB	'CatStrDir(%s): item[%u]=%s delim=0x%x', 0aH, 00H
	ORG $+1
$SG10986 DB	'CatStrDir: error, not a <>-literal: %s', 0aH, 00H
$SG10988 DB	'CatStrDir: error, literal too long: %u + %u >= %u', 0aH, 00H
	ORG $+5
$SG10992 DB	'CatStrDir: new symbol %s created', 0aH, 00H
	ORG $+6
$SG10996 DB	'CatStrDir(%s) exit, symbol redefinition', 0aH, 00H
	ORG $+7
$SG10998 DB	'CatStrDir(%s) (new) value: >%s<', 0aH, 00H
	ORG $+7
$SG11028 DB	'SetTextMacro(%s): value is >%s<, exit', 0aH, 00H
	ORG $+1
$SG11037 DB	'AddPredefinedText(%s): >%s<', 0aH, 00H
	ORG $+3
$SG11055 DB	'SubStrDir enter', 0aH, 00H
	ORG $+7
$SG11058 DB	'SubStrDir: error, no text item', 0aH, 00H
$SG11059 DB	'SubStrDir(%s): src=>%s<', 0aH, 00H
	ORG $+7
$SG11062 DB	'SubStrDir(%s): invalid pos value', 0aH, 00H
	ORG $+6
$SG11064 DB	'SubStrDir(%s): pos value is not a constant', 0aH, 00H
	ORG $+4
$SG11070 DB	'SubStrDir(%s): invalid size value', 0aH, 00H
	ORG $+5
$SG11072 DB	'SubStrDir(%s): size value is not a constant', 0aH, 00H
	ORG $+3
$SG11074 DB	'SubStrDir(%s): additional items found', 0aH, 00H
	ORG $+1
$SG11084 DB	'SubStrDir(%s) error, incompatible type', 0aH, 00H
$SG11086 DB	'SubStrDir(%s): result=>%s<', 0aH, 00H
	ORG $+4
$SG11095 DB	'SizeStrDir entry', 0aH, 00H
	ORG $+6
$SG11100 DB	'SizeStrDir: syntax error, name=%s, Token_Count=%u', 0aH, 00H
	ORG $+5
$SG11102 DB	'SizeStrDir(%s) exit, value=%u', 0aH, 00H
	ORG $+1
$SG11119 DB	'InStrDir entry', 0aH, 00H
$SG11129 DB	'InStrDir: first string >%s< ', 0aH, 00H
	ORG $+2
$SG11134 DB	'InStrDir: second string >%s< ', 0aH, 00H
	ORG $+1
$SG11138 DB	'InStrDir(%s) exit, value=%u', 0aH, 00H
	ORG $+3
$SG11155 DB	'NULL', 00H
	ORG $+3
$SG11156 DB	'@CatStr( %s )', 0aH, 00H
	ORG $+1
$SG11157 DB	'@CatStr.%u: >%s<', 0aH, 00H
	ORG $+6
$SG11186 DB	'@InStr( %s, %s, %s)', 0aH, 00H
	ORG $+3
$SG11190 DB	'@InStr(): index value is 0, changed to 1', 0aH, 00H
	ORG $+6
$SG11194 DB	'@InStr()=>%s<', 0aH, 00H
	ORG $+1
$SG11204 DB	'@SizeStr(%s)', 0aH, 00H
	ORG $+2
$SG11222 DB	'@SubStr( %s, %s, %s)', 0aH, 00H
	ORG $+2
$SG11226 DB	'@SubStr(): index value 0 changed to 1', 0aH, 00H
	ORG $+1
$SG11250 DB	'StringInit() enter', 0aH, 00H
	ORG $+4
$SG11251 DB	'@CatStr', 00H
$SG11252 DB	'@InStr', 00H
	ORG $+1
$SG11253 DB	'@SizeStr', 00H
	ORG $+7
$SG11254 DB	'@SubStr', 00H
	ORG $+8
$SG11258 DB	'invokation CATSTR=%u SUBSTR=%u SIZESTR=%u INSTR=%u EQU(t'
	DB	'ext)=%u', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	SetTextMacro
PUBLIC	AddPredefinedText
PUBLIC	TextItemError
PUBLIC	StringInit
PUBLIC	StringFini
PUBLIC	CatStrDir
PUBLIC	SubStrDir
PUBLIC	SizeStrDir
PUBLIC	InStrDir
EXTRN	__imp_isspace:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	memcpy:PROC
EXTRN	__imp_strstr:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	myltoa:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymCreate:PROC
EXTRN	SymFind:PROC
EXTRN	sym_remove_table:PROC
EXTRN	EvalOperand:PROC
EXTRN	CreateVariable:PROC
EXTRN	Tokenize:PROC
EXTRN	CreateMacro:PROC
EXTRN	SkipSavedState:PROC
EXTRN	LstWrite:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	SymTables:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

catstrcnt DD	01H DUP (?)
substrcnt DD	01H DUP (?)
sizstrcnt DD	01H DUP (?)
instrcnt DD	01H DUP (?)
equcnt	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$SetTextMacro DD imagerel $LN16
	DD	imagerel $LN16+587
	DD	imagerel $unwind$SetTextMacro
$pdata$AddPredefinedText DD imagerel $LN4
	DD	imagerel $LN4+182
	DD	imagerel $unwind$AddPredefinedText
$pdata$TextItemError DD imagerel $LN7
	DD	imagerel $LN7+160
	DD	imagerel $unwind$TextItemError
$pdata$StringInit DD imagerel $LN13
	DD	imagerel $LN13+1138
	DD	imagerel $unwind$StringInit
$pdata$StringFini DD imagerel $LN4
	DD	imagerel $LN4+90
	DD	imagerel $unwind$StringFini
$pdata$CatStrDir DD imagerel $LN20
	DD	imagerel $LN20+1032
	DD	imagerel $unwind$CatStrDir
$pdata$SubStrDir DD imagerel $LN25
	DD	imagerel $LN25+1411
	DD	imagerel $unwind$SubStrDir
$pdata$SizeStrDir DD imagerel $LN8
	DD	imagerel $LN8+389
	DD	imagerel $unwind$SizeStrDir
$pdata$InStrDir DD imagerel $LN19
	DD	imagerel $LN19+1231
	DD	imagerel $unwind$InStrDir
$pdata$CatStrFunc DD imagerel CatStrFunc
	DD	imagerel CatStrFunc+343
	DD	imagerel $unwind$CatStrFunc
$pdata$GetNumber DD imagerel GetNumber
	DD	imagerel GetNumber+257
	DD	imagerel $unwind$GetNumber
$pdata$InStrFunc DD imagerel InStrFunc
	DD	imagerel InStrFunc+762
	DD	imagerel $unwind$InStrFunc
$pdata$SizeStrFunc DD imagerel SizeStrFunc
	DD	imagerel SizeStrFunc+259
	DD	imagerel $unwind$SizeStrFunc
$pdata$SubStrFunc DD imagerel SubStrFunc
	DD	imagerel SubStrFunc+669
	DD	imagerel $unwind$SubStrFunc
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
SubStrDir$rtcName$0 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	078H
	DB	00H
	ORG $+10
SubStrDir$rtcVarDesc DD 070H
	DD	068H
	DQ	FLAT:SubStrDir$rtcName$0
	ORG $+48
SubStrDir$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:SubStrDir$rtcVarDesc
InStrDir$rtcName$0 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	078H
	DB	00H
	ORG $+2
InStrDir$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:InStrDir$rtcVarDesc
GetNumber$rtcName$0 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	078H
	DB	00H
	ORG $+2
InStrDir$rtcVarDesc DD 070H
	DD	068H
	DQ	FLAT:InStrDir$rtcName$0
	ORG $+48
GetNumber$rtcName$1 DB 069H
	DB	00H
	ORG $+6
GetNumber$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:GetNumber$rtcVarDesc
InStrFunc$rtcName$0 DB 070H
	DB	06fH
	DB	073H
	DB	00H
	ORG $+4
GetNumber$rtcVarDesc DD 0c4H
	DD	04H
	DQ	FLAT:GetNumber$rtcName$1
	DD	040H
	DD	068H
	DQ	FLAT:GetNumber$rtcName$0
	ORG $+96
InStrFunc$rtcVarDesc DD 034H
	DD	04H
	DQ	FLAT:InStrFunc$rtcName$0
	ORG $+48
InStrFunc$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:InStrFunc$rtcVarDesc
SubStrFunc$rtcName$0 DB 070H
	DB	06fH
	DB	073H
	DB	00H
	ORG $+4
SubStrFunc$rtcName$1 DB 073H
	DB	069H
	DB	07aH
	DB	065H
	DB	072H
	DB	065H
	DB	071H
	DB	00H
SubStrFunc$rtcVarDesc DD 044H
	DD	04H
	DQ	FLAT:SubStrFunc$rtcName$1
	DD	024H
	DD	04H
	DQ	FLAT:SubStrFunc$rtcName$0
	ORG $+96
SubStrFunc$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:SubStrFunc$rtcVarDesc
CONST	ENDS
xdata	SEGMENT
$unwind$SetTextMacro DD 022d01H
	DD	070155219H
$unwind$AddPredefinedText DD 022301H
	DD	0700b520fH
$unwind$TextItemError DD 021e01H
	DD	07006520aH
$unwind$StringInit DD 021501H
	DD	070027206H
$unwind$StringFini DD 021501H
	DD	070025206H
$unwind$CatStrDir DD 022101H
	DD	0700a920eH
$unwind$SubStrDir DD 032701H
	DD	01e0111H
	DD	0700aH
$unwind$SizeStrDir DD 022101H
	DD	0700a520eH
$unwind$InStrDir DD 032701H
	DD	01e0111H
	DD	0700aH
$unwind$CatStrFunc DD 022801H
	DD	070107214H
$unwind$GetNumber DD 032e01H
	DD	01c0117H
	DD	07010H
$unwind$InStrFunc DD 022e01H
	DD	07010f217H
$unwind$SizeStrFunc DD 022801H
	DD	070107214H
$unwind$SubStrFunc DD 022b01H
	DD	07010d214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
printf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
printf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:printf$rtcName$0
	ORG $+48
printf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:printf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
pos$ = 36
size$ = 52
src$ = 56
sizereq$5 = 68
tv74 = 88
tv83 = 96
tv86 = 104
mi$ = 128
buffer$ = 136
tokenarray$ = 144
SubStrFunc PROC

; 719  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+128]

; 720  :     int pos;
; 721  :     int size;
; 722  :     char *src = mi->parm_array[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax+rcx]
	mov	QWORD PTR src$[rsp], rax

; 723  : 
; 724  :     DebugMsg1(("@SubStr( %s, %s, %s)\n",

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rax+rcx], 0
	je	SHORT $LN11@SubStrFunc
	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax+rcx]
	mov	QWORD PTR tv74[rsp], rax
	jmp	SHORT $LN12@SubStrFunc
$LN11@SubStrFunc:
	lea	rax, OFFSET FLAT:$SG11219
	mov	QWORD PTR tv74[rsp], rax
$LN12@SubStrFunc:
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rax+rcx], 0
	je	SHORT $LN13@SubStrFunc
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax+rcx]
	mov	QWORD PTR tv83[rsp], rax
	jmp	SHORT $LN14@SubStrFunc
$LN13@SubStrFunc:
	lea	rax, OFFSET FLAT:$SG11220
	mov	QWORD PTR tv83[rsp], rax
$LN14@SubStrFunc:
	cmp	QWORD PTR src$[rsp], 0
	je	SHORT $LN15@SubStrFunc
	mov	rax, QWORD PTR src$[rsp]
	mov	QWORD PTR tv86[rsp], rax
	jmp	SHORT $LN16@SubStrFunc
$LN15@SubStrFunc:
	lea	rax, OFFSET FLAT:$SG11221
	mov	QWORD PTR tv86[rsp], rax
$LN16@SubStrFunc:
	mov	r9, QWORD PTR tv74[rsp]
	mov	r8, QWORD PTR tv83[rsp]
	mov	rdx, QWORD PTR tv86[rsp]
	lea	rcx, OFFSET FLAT:$SG11222
	call	DoDebugMsg1

; 725  :               src ? src : "",
; 726  :               mi->parm_array[1] ? mi->parm_array[1] : "",
; 727  :               mi->parm_array[2] ? mi->parm_array[2] : "" ));
; 728  : 
; 729  :     if ( GetNumber( mi->parm_array[1], &pos, tokenarray ) == ERROR )

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	GetNumber
	cmp	eax, -1
	jne	SHORT $LN2@SubStrFunc

; 730  :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@SubStrFunc
$LN2@SubStrFunc:

; 731  : 
; 732  :     if ( pos <= 0 ) {

	cmp	DWORD PTR pos$[rsp], 0
	jg	SHORT $LN3@SubStrFunc

; 733  :         /* Masm doesn't check if index is < 0;
; 734  :          * might cause an "internal assembler error".
; 735  :          * v2.09: negative index no longer silently changed to 1.
; 736  :          */
; 737  :         if ( pos ) {

	cmp	DWORD PTR pos$[rsp], 0
	je	SHORT $LN4@SubStrFunc

; 738  :             return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, pos ) );

	mov	edx, DWORD PTR pos$[rsp]
	mov	ecx, 206				; 000000ceH
	call	EmitErr
	jmp	$LN1@SubStrFunc
$LN4@SubStrFunc:

; 739  :         }
; 740  :         DebugMsg(( "@SubStr(): index value 0 changed to 1\n", pos ));

	mov	edx, DWORD PTR pos$[rsp]
	lea	rcx, OFFSET FLAT:$SG11226
	call	DoDebugMsg

; 741  :         pos = 1;

	mov	DWORD PTR pos$[rsp], 1
$LN3@SubStrFunc:

; 742  :     }
; 743  : 
; 744  :     size = strlen( src );

	mov	rcx, QWORD PTR src$[rsp]
	call	strlen
	mov	DWORD PTR size$[rsp], eax

; 745  :     if ( pos > size ) {

	mov	eax, DWORD PTR size$[rsp]
	cmp	DWORD PTR pos$[rsp], eax
	jle	SHORT $LN5@SubStrFunc

; 746  :         return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, pos ) );

	mov	edx, DWORD PTR pos$[rsp]
	mov	ecx, 206				; 000000ceH
	call	EmitErr
	jmp	$LN1@SubStrFunc
$LN5@SubStrFunc:

; 747  :     }
; 748  : 
; 749  :     size = size - pos + 1;

	mov	eax, DWORD PTR pos$[rsp]
	mov	ecx, DWORD PTR size$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	inc	eax
	mov	DWORD PTR size$[rsp], eax

; 750  : 
; 751  :     if ( mi->parm_array[2] ) {

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rax+rcx], 0
	je	SHORT $LN6@SubStrFunc

; 752  :         int sizereq;
; 753  :         if ( GetNumber( mi->parm_array[2], &sizereq, tokenarray ) == ERROR )

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR sizereq$5[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	GetNumber
	cmp	eax, -1
	jne	SHORT $LN7@SubStrFunc

; 754  :             return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@SubStrFunc
$LN7@SubStrFunc:

; 755  :         if ( sizereq < 0 ) {

	cmp	DWORD PTR sizereq$5[rsp], 0
	jge	SHORT $LN8@SubStrFunc

; 756  :             return( EmitError( COUNT_MUST_BE_POSITIVE_OR_ZERO ) );

	mov	ecx, 208				; 000000d0H
	call	EmitError
	jmp	SHORT $LN1@SubStrFunc
$LN8@SubStrFunc:

; 757  :         }
; 758  :         if ( sizereq > size ) {

	mov	eax, DWORD PTR size$[rsp]
	cmp	DWORD PTR sizereq$5[rsp], eax
	jle	SHORT $LN9@SubStrFunc

; 759  :             return( EmitError( COUNT_VALUE_TOO_LARGE ) );

	mov	ecx, 207				; 000000cfH
	call	EmitError
	jmp	SHORT $LN1@SubStrFunc
$LN9@SubStrFunc:

; 760  :         }
; 761  :         size = sizereq;

	mov	eax, DWORD PTR sizereq$5[rsp]
	mov	DWORD PTR size$[rsp], eax
$LN6@SubStrFunc:

; 762  :     }
; 763  : #if 1
; 764  :     memcpy( buffer, src + pos - 1, size );

	movsxd	rax, DWORD PTR size$[rsp]
	movsxd	rcx, DWORD PTR pos$[rsp]
	mov	rdx, QWORD PTR src$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx-1]
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memcpy

; 765  :     *(buffer+size) = NULLC;

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 766  : #else
; 767  :     for( src += pos - 1; size; size-- )
; 768  :         *buffer++ = *src++;
; 769  :     *buffer = NULLC;
; 770  : #endif
; 771  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SubStrFunc:

; 772  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:SubStrFunc$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
SubStrFunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
tv71 = 48
tv81 = 56
mi$ = 80
buffer$ = 88
tokenarray$ = 96
SizeStrFunc PROC

; 702  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 703  :     DebugMsg1(("@SizeStr(%s)\n", mi->parm_array[0] ? mi->parm_array[0] : "" ));

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rax+rcx], 0
	je	SHORT $LN5@SizeStrFun
	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax+rcx]
	mov	QWORD PTR tv71[rsp], rax
	jmp	SHORT $LN6@SizeStrFun
$LN5@SizeStrFun:
	lea	rax, OFFSET FLAT:$SG11203
	mov	QWORD PTR tv71[rsp], rax
$LN6@SizeStrFun:
	mov	rdx, QWORD PTR tv71[rsp]
	lea	rcx, OFFSET FLAT:$SG11204
	call	DoDebugMsg1

; 704  :     if ( mi->parm_array[0] )

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rax+rcx], 0
	je	SHORT $LN2@SizeStrFun

; 705  :         myltoa( strlen( mi->parm_array[0] ), buffer, ModuleInfo. radix, FALSE, TRUE );

	movzx	eax, BYTE PTR ModuleInfo+396
	mov	DWORD PTR tv81[rsp], eax
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR mi$[rsp]
	mov	rdx, QWORD PTR [rdx+24]
	mov	rcx, QWORD PTR [rdx+rcx]
	call	strlen
	mov	BYTE PTR [rsp+32], 1
	xor	r9d, r9d
	mov	ecx, DWORD PTR tv81[rsp]
	mov	r8d, ecx
	mov	rdx, QWORD PTR buffer$[rsp]
	mov	ecx, eax
	call	myltoa
	jmp	SHORT $LN3@SizeStrFun
$LN2@SizeStrFun:

; 706  :     else {
; 707  :         buffer[0] = '0';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rcx+rax], 48			; 00000030H

; 708  :         buffer[1] = NULLC;

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rcx+rax], 0
$LN3@SizeStrFun:

; 709  :     }
; 710  :     return( NOT_ERROR );

	xor	eax, eax

; 711  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
SizeStrFunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
pos$ = 52
p$ = 72
found$ = 80
tv71 = 88
tv80 = 96
tv89 = 104
tv140 = 112
tv166 = 120
mi$ = 144
buffer$ = 152
tokenarray$ = 160
InStrFunc PROC

; 654  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rdi, rsp
	mov	ecx, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+144]

; 655  :     int pos = 1;

	mov	DWORD PTR pos$[rsp], 1

; 656  :     char *p;
; 657  :     uint_32 found;
; 658  : 
; 659  :     DebugMsg1(("@InStr( %s, %s, %s)\n",

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rax+rcx], 0
	je	SHORT $LN9@InStrFunc
	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax+rcx]
	mov	QWORD PTR tv71[rsp], rax
	jmp	SHORT $LN10@InStrFunc
$LN9@InStrFunc:
	lea	rax, OFFSET FLAT:$SG11183
	mov	QWORD PTR tv71[rsp], rax
$LN10@InStrFunc:
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rax+rcx], 0
	je	SHORT $LN11@InStrFunc
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax+rcx]
	mov	QWORD PTR tv80[rsp], rax
	jmp	SHORT $LN12@InStrFunc
$LN11@InStrFunc:
	lea	rax, OFFSET FLAT:$SG11184
	mov	QWORD PTR tv80[rsp], rax
$LN12@InStrFunc:
	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rax+rcx], 0
	je	SHORT $LN13@InStrFunc
	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax+rcx]
	mov	QWORD PTR tv89[rsp], rax
	jmp	SHORT $LN14@InStrFunc
$LN13@InStrFunc:
	lea	rax, OFFSET FLAT:$SG11185
	mov	QWORD PTR tv89[rsp], rax
$LN14@InStrFunc:
	mov	r9, QWORD PTR tv71[rsp]
	mov	r8, QWORD PTR tv80[rsp]
	mov	rdx, QWORD PTR tv89[rsp]
	lea	rcx, OFFSET FLAT:$SG11186
	call	DoDebugMsg1

; 660  :               mi->parm_array[0] ? mi->parm_array[0] : "",
; 661  :               mi->parm_array[1] ? mi->parm_array[1] : "",
; 662  :               mi->parm_array[2] ? mi->parm_array[2] : "" ));
; 663  : 
; 664  :     /* init buffer with "0" */
; 665  :     *buffer = '0';

	mov	rax, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rax], 48			; 00000030H

; 666  :     *(buffer+1) = NULLC;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rax+1], 0

; 667  : 
; 668  :     if ( mi->parm_array[0] ) {

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rax+rcx], 0
	je	SHORT $LN2@InStrFunc

; 669  :         if ( GetNumber( mi->parm_array[0], &pos, tokenarray ) == ERROR )

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	GetNumber
	cmp	eax, -1
	jne	SHORT $LN3@InStrFunc

; 670  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@InStrFunc
$LN3@InStrFunc:

; 671  :         if ( pos == 0 ) {

	cmp	DWORD PTR pos$[rsp], 0
	jne	SHORT $LN4@InStrFunc

; 672  :             /* adjust index 0. Masm also accepts 0 (and any negative index),
; 673  :              * but the result will always be 0 then */
; 674  :             DebugMsg(( "@InStr(): index value is 0, changed to 1\n" ));

	lea	rcx, OFFSET FLAT:$SG11190
	call	DoDebugMsg

; 675  :             pos++;

	mov	eax, DWORD PTR pos$[rsp]
	inc	eax
	mov	DWORD PTR pos$[rsp], eax
$LN4@InStrFunc:
$LN2@InStrFunc:

; 676  :         }
; 677  :     }
; 678  : 
; 679  :     if ( pos > strlen( mi->parm_array[1] ) ) {

	movsxd	rax, DWORD PTR pos$[rsp]
	mov	QWORD PTR tv140[rsp], rax
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR mi$[rsp]
	mov	rdx, QWORD PTR [rdx+24]
	mov	rcx, QWORD PTR [rdx+rcx]
	call	strlen
	mov	rcx, QWORD PTR tv140[rsp]
	cmp	rcx, rax
	jbe	SHORT $LN5@InStrFunc

; 680  :         return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, pos ) );

	mov	edx, DWORD PTR pos$[rsp]
	mov	ecx, 206				; 000000ceH
	call	EmitErr
	jmp	$LN1@InStrFunc
$LN5@InStrFunc:

; 681  :     }
; 682  :     /* v2.08: if() added, empty searchstr is to return 0 */
; 683  :     if ( *(mi->parm_array[2]) != NULLC ) {

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax+rcx]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN6@InStrFunc

; 684  :         p = strstr( mi->parm_array[1] + pos - 1, mi->parm_array[2] );

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	edx, 8
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR mi$[rsp]
	mov	r8, QWORD PTR [r8+24]
	movsxd	r9, DWORD PTR pos$[rsp]
	mov	rdx, QWORD PTR [r8+rdx]
	lea	rdx, QWORD PTR [rdx+r9-1]
	mov	QWORD PTR tv166[rsp], rdx
	mov	rdx, QWORD PTR [rcx+rax]
	mov	rax, QWORD PTR tv166[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_strstr
	mov	QWORD PTR p$[rsp], rax

; 685  :         if ( p ) {

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN7@InStrFunc

; 686  :             found = p - mi->parm_array[1] + 1;

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR p$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	inc	rax
	mov	DWORD PTR found$[rsp], eax

; 687  :             myltoa( found, buffer, ModuleInfo.radix, FALSE, TRUE );

	movzx	eax, BYTE PTR ModuleInfo+396
	mov	BYTE PTR [rsp+32], 1
	xor	r9d, r9d
	mov	r8d, eax
	mov	rdx, QWORD PTR buffer$[rsp]
	mov	ecx, DWORD PTR found$[rsp]
	call	myltoa
$LN7@InStrFunc:
$LN6@InStrFunc:

; 688  :         }
; 689  :     }
; 690  : 
; 691  :     DebugMsg1(( "@InStr()=>%s<\n", buffer ));

	mov	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, OFFSET FLAT:$SG11194
	call	DoDebugMsg1

; 692  : 
; 693  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@InStrFunc:

; 694  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:InStrFunc$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 128				; 00000080H
	pop	rdi
	ret	0
InStrFunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
opndx$ = 64
i$ = 196
last$ = 212
string$ = 240
pi$ = 248
tokenarray$ = 256
GetNumber PROC

; 629  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 224				; 000000e0H
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+240]

; 630  :     struct expr opndx;
; 631  :     int i;
; 632  :     int last;
; 633  : 
; 634  :     last = Tokenize( string, Token_Count+1, tokenarray, TOK_RESCAN );

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR string$[rsp]
	call	Tokenize
	mov	DWORD PTR last$[rsp], eax

; 635  :     i = Token_Count+1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 636  :     if( EvalOperand( &i, tokenarray, last, &opndx, EXPF_NOUNDEF ) == ERROR ) {

	mov	BYTE PTR [rsp+32], 2
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR last$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN2@GetNumber

; 637  :         return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@GetNumber
$LN2@GetNumber:

; 638  :     }
; 639  :     /* v2.11: string constants are accepted ( although hardly useful ) */
; 640  :     //if( opndx.kind != EXPR_CONST || opndx.quoted_string != NULL || tokenarray[i].token != T_FINAL ) {
; 641  :     if( opndx.kind != EXPR_CONST || tokenarray[i].token != T_FINAL ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN4@GetNumber
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN3@GetNumber
$LN4@GetNumber:

; 642  :         return( EmitErr( SYNTAX_ERROR_EX, string ) );

	mov	rdx, QWORD PTR string$[rsp]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@GetNumber
$LN3@GetNumber:

; 643  :     }
; 644  :     *pi = opndx.value;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR opndx$[rsp]
	mov	DWORD PTR [rax], ecx

; 645  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@GetNumber:

; 646  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:GetNumber$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 224				; 000000e0H
	pop	rdi
	ret	0
GetNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
cnt$ = 32
i$ = 36
p$ = 40
tv71 = 48
tv85 = 56
mi$ = 80
buffer$ = 88
tokenarray$ = 96
CatStrFunc PROC

; 602  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 603  : #ifdef DEBUG_OUT
; 604  :     int cnt = 0;

	mov	DWORD PTR cnt$[rsp], 0

; 605  : #endif
; 606  :     int i;
; 607  :     char *p;
; 608  : 
; 609  :     DebugMsg1(("@CatStr( %s )\n", mi->parm_array[0] ? mi->parm_array[0] : "NULL" ));

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rax+rcx], 0
	je	SHORT $LN6@CatStrFunc
	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax+rcx]
	mov	QWORD PTR tv71[rsp], rax
	jmp	SHORT $LN7@CatStrFunc
$LN6@CatStrFunc:
	lea	rax, OFFSET FLAT:$SG11155
	mov	QWORD PTR tv71[rsp], rax
$LN7@CatStrFunc:
	mov	rdx, QWORD PTR tv71[rsp]
	lea	rcx, OFFSET FLAT:$SG11156
	call	DoDebugMsg1

; 610  : 
; 611  :     for ( p = mi->parm_array[0]; mi->parmcnt; mi->parmcnt-- ) {

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax+rcx]
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN4@CatStrFunc
$LN2@CatStrFunc:
	mov	rax, QWORD PTR mi$[rsp]
	mov	eax, DWORD PTR [rax+40]
	dec	eax
	mov	rcx, QWORD PTR mi$[rsp]
	mov	DWORD PTR [rcx+40], eax
$LN4@CatStrFunc:
	mov	rax, QWORD PTR mi$[rsp]
	cmp	DWORD PTR [rax+40], 0
	je	$LN3@CatStrFunc

; 612  :         DebugMsg1(("@CatStr.%u: >%s<\n", cnt++, p ));

	mov	eax, DWORD PTR cnt$[rsp]
	mov	DWORD PTR tv85[rsp], eax
	mov	eax, DWORD PTR cnt$[rsp]
	inc	eax
	mov	DWORD PTR cnt$[rsp], eax
	mov	r8, QWORD PTR p$[rsp]
	mov	edx, DWORD PTR tv85[rsp]
	lea	rcx, OFFSET FLAT:$SG11157
	call	DoDebugMsg1

; 613  :         i = strlen( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax

; 614  :         memcpy( buffer, p, i );

	movsxd	rax, DWORD PTR i$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memcpy

; 615  :         p = GetAlignedPointer( p, i );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	add	rax, 7
	and	rax, -8
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 616  :         buffer += i;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR buffer$[rsp], rax

; 617  :     }

	jmp	$LN2@CatStrFunc
$LN3@CatStrFunc:

; 618  :     *buffer = NULLC;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rax], 0

; 619  :     return( NOT_ERROR );

	xor	eax, eax

; 620  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
CatStrFunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
sym$ = 48
sizestr$ = 56
j$ = 60
src$ = 64
p$ = 72
q$ = 80
string1$ = 88
opndx$ = 112
start$ = 228
strpos$ = 232
i$ = 256
tokenarray$ = 264
InStrDir PROC

; 496  : {

$LN19:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 240				; 000000f0H
	mov	rdi, rsp
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+256]

; 497  :     struct asym *sym;
; 498  :     int sizestr;
; 499  :     int j;
; 500  :     /* int commas; */
; 501  :     char *src;
; 502  :     char *p;
; 503  :     char *q;
; 504  :     char *string1;
; 505  :     struct expr opndx;
; 506  :     int start = 1;

	mov	DWORD PTR start$[rsp], 1

; 507  :     int strpos;
; 508  : 
; 509  :     DebugMsg1(("InStrDir entry\n"));

	lea	rcx, OFFSET FLAT:$SG11119
	call	DoDebugMsg1

; 510  :     DebugCmd( instrcnt++ );

	mov	eax, DWORD PTR instrcnt
	inc	eax
	mov	DWORD PTR instrcnt, eax

; 511  : 
; 512  :     if ( i != 1) {

	cmp	DWORD PTR i$[rsp], 1
	je	SHORT $LN2@InStrDir

; 513  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@InStrDir
$LN2@InStrDir:

; 514  :     }
; 515  : #if 0 /* this is checked in ParseLine() */
; 516  :     if ( tokenarray[0].token != T_ID ) {
; 517  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );
; 518  :     }
; 519  : #endif
; 520  : 
; 521  :     i++; /* go past INSTR */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 522  : 
; 523  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN4@InStrDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	$LN3@InStrDir
$LN4@InStrDir:

; 524  :         /* v2.11: flag NOUNDEF added - no forward reference accepted */
; 525  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	BYTE PTR [rsp+32], 2
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN5@InStrDir

; 526  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@InStrDir
$LN5@InStrDir:

; 527  :         if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN6@InStrDir

; 528  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN1@InStrDir
$LN6@InStrDir:

; 529  :         }
; 530  :         start = opndx.value;

	mov	eax, DWORD PTR opndx$[rsp]
	mov	DWORD PTR start$[rsp], eax

; 531  :         if ( start <= 0 ) {

	cmp	DWORD PTR start$[rsp], 0
	jg	SHORT $LN7@InStrDir

; 532  :             /* v2.05: don't change the value. if it's invalid, the result
; 533  :              * is to be 0. Emit a level 3 warning instead.
; 534  :              */
; 535  :             //start = 1;
; 536  :             EmitWarn( 3, POSITIVE_VALUE_EXPECTED );

	mov	edx, 175				; 000000afH
	mov	ecx, 3
	call	EmitWarn
$LN7@InStrDir:

; 537  :         }
; 538  :         if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN8@InStrDir

; 539  :             return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	$LN1@InStrDir
$LN8@InStrDir:

; 540  :         }
; 541  :         i++; /* skip comma */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN3@InStrDir:

; 542  :     }
; 543  : 
; 544  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN10@InStrDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN9@InStrDir
$LN10@InStrDir:

; 545  :         return( TextItemError( &tokenarray[i] ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	TextItemError
	jmp	$LN1@InStrDir
$LN9@InStrDir:

; 546  :     }
; 547  : 
; 548  :     /* to compare the strings, the "visible" format is needed, since
; 549  :      * the possible '!' operators inside the strings is optional and
; 550  :      * must be ignored.
; 551  :      */
; 552  :     //src = StringBufferEnd;
; 553  :     //sizestr = GetLiteralValue( src, tokenarray[i].string_ptr );
; 554  :     src = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR src$[rsp], rax

; 555  :     sizestr = tokenarray[i].stringlen;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR sizestr$[rsp], eax

; 556  :     DebugMsg1(("InStrDir: first string >%s< \n", src ));

	mov	rdx, QWORD PTR src$[rsp]
	lea	rcx, OFFSET FLAT:$SG11129
	call	DoDebugMsg1

; 557  : 
; 558  :     if ( start > sizestr ) {

	mov	eax, DWORD PTR sizestr$[rsp]
	cmp	DWORD PTR start$[rsp], eax
	jle	SHORT $LN11@InStrDir

; 559  :         return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, start ) );

	mov	edx, DWORD PTR start$[rsp]
	mov	ecx, 206				; 000000ceH
	call	EmitErr
	jmp	$LN1@InStrDir
$LN11@InStrDir:

; 560  :     }
; 561  :     p = src + start - 1;

	movsxd	rax, DWORD PTR start$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	lea	rax, QWORD PTR [rcx+rax-1]
	mov	QWORD PTR p$[rsp], rax

; 562  : 
; 563  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 564  :     if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN12@InStrDir

; 565  :         return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	$LN1@InStrDir
$LN12@InStrDir:

; 566  :     }
; 567  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 568  : 
; 569  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN14@InStrDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN13@InStrDir
$LN14@InStrDir:

; 570  :         return( TextItemError( &tokenarray[i] ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	TextItemError
	jmp	$LN1@InStrDir
$LN13@InStrDir:

; 571  :     }
; 572  :     //q = GetAlignedPointer( src, sizestr );
; 573  :     //j = GetLiteralValue( q, tokenarray[i].string_ptr );
; 574  :     q = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR q$[rsp], rax

; 575  :     j = tokenarray[i].stringlen;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR j$[rsp], eax

; 576  :     DebugMsg1(("InStrDir: second string >%s< \n", q ));

	mov	rdx, QWORD PTR q$[rsp]
	lea	rcx, OFFSET FLAT:$SG11134
	call	DoDebugMsg1

; 577  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 578  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN15@InStrDir

; 579  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@InStrDir
$LN15@InStrDir:

; 580  :     }
; 581  : 
; 582  :     strpos = 0;

	mov	DWORD PTR strpos$[rsp], 0

; 583  :     /* v2.05: check for start > 0 added */
; 584  :     /* v2.08: check for j > 0 added */
; 585  :     if ( ( start > 0 ) && ( sizestr >= j ) && j && ( string1 = strstr( p, q ) ))

	cmp	DWORD PTR start$[rsp], 0
	jle	SHORT $LN16@InStrDir
	mov	eax, DWORD PTR j$[rsp]
	cmp	DWORD PTR sizestr$[rsp], eax
	jl	SHORT $LN16@InStrDir
	cmp	DWORD PTR j$[rsp], 0
	je	SHORT $LN16@InStrDir
	mov	rdx, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp_strstr
	mov	QWORD PTR string1$[rsp], rax
	cmp	QWORD PTR string1$[rsp], 0
	je	SHORT $LN16@InStrDir

; 586  :         strpos = string1 - src + 1;

	mov	rax, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR string1$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	inc	rax
	mov	DWORD PTR strpos$[rsp], eax
$LN16@InStrDir:

; 587  : 
; 588  :     if ( sym = CreateVariable( tokenarray[0].string_ptr, strpos ) ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	edx, DWORD PTR strpos$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	CreateVariable
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN17@InStrDir

; 589  :         DebugMsg1(("InStrDir(%s) exit, value=%u\n", tokenarray[0].string_ptr, strpos));

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	r8d, DWORD PTR strpos$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11138
	call	DoDebugMsg1

; 590  :         LstWrite( LSTTYPE_EQUATE, 0, sym );

	mov	r8, QWORD PTR sym$[rsp]
	xor	edx, edx
	mov	ecx, 2
	call	LstWrite

; 591  :         return ( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@InStrDir
$LN17@InStrDir:

; 592  :     }
; 593  :     return( ERROR );

	mov	eax, -1
$LN1@InStrDir:

; 594  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:InStrDir$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 240				; 000000f0H
	pop	rdi
	ret	0
InStrDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
sym$ = 32
sizestr$ = 40
i$ = 64
tokenarray$ = 72
SizeStrDir PROC

; 454  : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+64]

; 455  :     struct asym *sym;
; 456  :     int sizestr;
; 457  : 
; 458  :     DebugMsg1(("SizeStrDir entry\n"));

	lea	rcx, OFFSET FLAT:$SG11095
	call	DoDebugMsg1

; 459  :     DebugCmd( sizstrcnt++ );

	mov	eax, DWORD PTR sizstrcnt
	inc	eax
	mov	DWORD PTR sizstrcnt, eax

; 460  : 
; 461  :     if ( i != 1 ) {

	cmp	DWORD PTR i$[rsp], 1
	je	SHORT $LN2@SizeStrDir

; 462  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@SizeStrDir
$LN2@SizeStrDir:

; 463  :     }
; 464  : #if 0 /* this is checked in ParseLine() */
; 465  :     if ( tokenarray[0].token != T_ID ) {
; 466  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );
; 467  :     }
; 468  : #endif
; 469  :     if ( tokenarray[2].token != T_STRING || tokenarray[2].string_delim != '<' ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN4@SizeStrDir
	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN3@SizeStrDir
$LN4@SizeStrDir:

; 470  :         return( TextItemError( &tokenarray[2] ) );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	TextItemError
	jmp	$LN1@SizeStrDir
$LN3@SizeStrDir:

; 471  :     }
; 472  :     if ( Token_Count > 3 ) {

	cmp	DWORD PTR ModuleInfo+496, 3
	jle	SHORT $LN5@SizeStrDir

; 473  :         DebugMsg(("SizeStrDir: syntax error, name=%s, Token_Count=%u\n", tokenarray[0].string_ptr, Token_Count));

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11100
	call	DoDebugMsg

; 474  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[3].string_ptr ) );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 3
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@SizeStrDir
$LN5@SizeStrDir:

; 475  :     }
; 476  : 
; 477  :     //sizestr = GetLiteralValue( StringBufferEnd, tokenarray[2].string_ptr );
; 478  :     sizestr = tokenarray[2].stringlen;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR sizestr$[rsp], eax

; 479  : 
; 480  :     if ( sym = CreateVariable( tokenarray[0].string_ptr, sizestr ) ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	edx, DWORD PTR sizestr$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	CreateVariable
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN6@SizeStrDir

; 481  :         DebugMsg1(("SizeStrDir(%s) exit, value=%u\n", tokenarray[0].string_ptr, sizestr));

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	r8d, DWORD PTR sizestr$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11102
	call	DoDebugMsg1

; 482  :         LstWrite( LSTTYPE_EQUATE, 0, sym );

	mov	r8, QWORD PTR sym$[rsp]
	xor	edx, edx
	mov	ecx, 2
	call	LstWrite

; 483  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@SizeStrDir
$LN6@SizeStrDir:

; 484  :     }
; 485  :     return( ERROR );

	mov	eax, -1
$LN1@SizeStrDir:

; 486  : 
; 487  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SizeStrDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
sym$ = 48
name$ = 56
p$ = 64
pos$ = 72
size$ = 76
cnt$ = 80
chksize$ = 84
opndx$ = 112
i$ = 256
tokenarray$ = 264
SubStrDir PROC

; 276  : {

$LN25:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 240				; 000000f0H
	mov	rdi, rsp
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+256]

; 277  :     struct asym         *sym;
; 278  :     char                *name;
; 279  :     char                *p;
; 280  :     //char                *newvalue;
; 281  :     int                 pos;
; 282  :     int                 size;
; 283  :     int                 cnt;
; 284  :     bool                chksize;
; 285  :     struct expr         opndx;
; 286  : 
; 287  :     DebugMsg1(("SubStrDir enter\n"));

	lea	rcx, OFFSET FLAT:$SG11055
	call	DoDebugMsg1

; 288  :     DebugCmd( substrcnt++ );

	mov	eax, DWORD PTR substrcnt
	inc	eax
	mov	DWORD PTR substrcnt, eax

; 289  : 
; 290  :     /* at least 5 items are needed
; 291  :      * 0  1      2      3 4    5   6
; 292  :      * ID SUBSTR SRC_ID , POS [, LENGTH]
; 293  :      */
; 294  : #if 0 /* can't happen */
; 295  :     if ( i != 1 ) {
; 296  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );
; 297  :     }
; 298  :     if ( tokenarray[0].token != T_ID ) {
; 299  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );
; 300  :     }
; 301  : #endif
; 302  :     name = tokenarray[0].string_ptr;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR name$[rsp], rax

; 303  : 
; 304  :     i++; /* go past SUBSTR */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 305  : 
; 306  :     /* third item must be a string */
; 307  : 
; 308  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN3@SubStrDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN2@SubStrDir
$LN3@SubStrDir:

; 309  :         DebugMsg(("SubStrDir: error, no text item\n"));

	lea	rcx, OFFSET FLAT:$SG11058
	call	DoDebugMsg

; 310  :         return( TextItemError( &tokenarray[i] ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	TextItemError
	jmp	$LN1@SubStrDir
$LN2@SubStrDir:

; 311  :     }
; 312  :     p = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR p$[rsp], rax

; 313  :     cnt = tokenarray[i].stringlen;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR cnt$[rsp], eax

; 314  : 
; 315  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 316  :     DebugMsg1(("SubStrDir(%s): src=>%s<\n", name, p));

	mov	r8, QWORD PTR p$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11059
	call	DoDebugMsg1

; 317  : 
; 318  :     if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN4@SubStrDir

; 319  :         return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	$LN1@SubStrDir
$LN4@SubStrDir:

; 320  :     }
; 321  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 322  : 
; 323  :     /* get pos, must be a numeric value and > 0 */
; 324  :     /* v2.11: flag NOUNDEF added - no forward ref possible */
; 325  : 
; 326  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR ) {

	mov	BYTE PTR [rsp+32], 2
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN5@SubStrDir

; 327  :         DebugMsg(("SubStrDir(%s): invalid pos value\n", name));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11062
	call	DoDebugMsg

; 328  :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@SubStrDir
$LN5@SubStrDir:

; 329  :     }
; 330  : 
; 331  :     /* v2.04: "string" constant allowed as second argument */
; 332  :     //if ( opndx.kind != EXPR_CONST || opndx.string != NULL ) {
; 333  :     if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN6@SubStrDir

; 334  :         DebugMsg(("SubStrDir(%s): pos value is not a constant\n", name));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11064
	call	DoDebugMsg

; 335  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN1@SubStrDir
$LN6@SubStrDir:

; 336  :     }
; 337  : 
; 338  :     /* pos is expected to be 1-based */
; 339  :     pos = opndx.value;

	mov	eax, DWORD PTR opndx$[rsp]
	mov	DWORD PTR pos$[rsp], eax

; 340  :     if ( pos <= 0 ) {

	cmp	DWORD PTR pos$[rsp], 0
	jg	SHORT $LN7@SubStrDir

; 341  :         return( EmitError( POSITIVE_VALUE_EXPECTED ) );

	mov	ecx, 175				; 000000afH
	call	EmitError
	jmp	$LN1@SubStrDir
$LN7@SubStrDir:

; 342  :     }
; 343  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN8@SubStrDir

; 344  :         if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN10@SubStrDir

; 345  :             return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	$LN1@SubStrDir
$LN10@SubStrDir:

; 346  :         }
; 347  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 348  :         /* get size, must be a constant */
; 349  :         /* v2.11: flag NOUNDEF added - no forward ref possible */
; 350  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR ) {

	mov	BYTE PTR [rsp+32], 2
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN11@SubStrDir

; 351  :             DebugMsg(("SubStrDir(%s): invalid size value\n", name));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11070
	call	DoDebugMsg

; 352  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@SubStrDir
$LN11@SubStrDir:

; 353  :         }
; 354  :         /* v2.04: string constant ok */
; 355  :         //if ( opndx.kind != EXPR_CONST || opndx.string != NULL ) {
; 356  :         if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN12@SubStrDir

; 357  :             DebugMsg(("SubStrDir(%s): size value is not a constant\n", name));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11072
	call	DoDebugMsg

; 358  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN1@SubStrDir
$LN12@SubStrDir:

; 359  :         }
; 360  :         size = opndx.value;

	mov	eax, DWORD PTR opndx$[rsp]
	mov	DWORD PTR size$[rsp], eax

; 361  :         if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN13@SubStrDir

; 362  :             DebugMsg(("SubStrDir(%s): additional items found\n", name));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11074
	call	DoDebugMsg

; 363  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@SubStrDir
$LN13@SubStrDir:

; 364  :         }
; 365  :         if ( size < 0 ) {

	cmp	DWORD PTR size$[rsp], 0
	jge	SHORT $LN14@SubStrDir

; 366  :             return( EmitError( COUNT_MUST_BE_POSITIVE_OR_ZERO ) );

	mov	ecx, 208				; 000000d0H
	call	EmitError
	jmp	$LN1@SubStrDir
$LN14@SubStrDir:

; 367  :         }
; 368  :         chksize = TRUE;

	mov	BYTE PTR chksize$[rsp], 1

; 369  :     } else {

	jmp	SHORT $LN9@SubStrDir
$LN8@SubStrDir:

; 370  :         size = -1;

	mov	DWORD PTR size$[rsp], -1

; 371  :         chksize = FALSE;

	mov	BYTE PTR chksize$[rsp], 0
$LN9@SubStrDir:

; 372  :     }
; 373  : #if 0
; 374  :     cnt = pos;
; 375  :     /* position p to start of substring */
; 376  :     for ( pos--; pos > 0 && *p ; pos--, p++ )
; 377  :         if ( *p == '!' && *(p+1) != NULLC )
; 378  :             p++;
; 379  :     if ( *p == NULLC ) {
; 380  :         return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, cnt ) );
; 381  :     }
; 382  :     if ( *p == '!' && *(p+1) != NULLC )
; 383  :         p++;
; 384  :     for ( newvalue = p, cnt = size; *p && cnt; cnt--, p++ )
; 385  :         if ( *p == '!' && *(p+1) != NULLC )
; 386  :             p++;
; 387  :     /* v2.04: check added */
; 388  :     if ( chksize && cnt ) {
; 389  :         return( EmitError( COUNT_VALUE_TOO_LARGE ) );
; 390  :     }
; 391  :     size = p - newvalue;
; 392  :     p = newvalue;
; 393  : #else
; 394  :     if ( pos > cnt ) {

	mov	eax, DWORD PTR cnt$[rsp]
	cmp	DWORD PTR pos$[rsp], eax
	jle	SHORT $LN15@SubStrDir

; 395  :         return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, pos ) );

	mov	edx, DWORD PTR pos$[rsp]
	mov	ecx, 206				; 000000ceH
	call	EmitErr
	jmp	$LN1@SubStrDir
$LN15@SubStrDir:

; 396  :     }
; 397  :     if ( chksize && (pos+size-1) > cnt )  {

	movzx	eax, BYTE PTR chksize$[rsp]
	test	eax, eax
	je	SHORT $LN16@SubStrDir
	mov	eax, DWORD PTR pos$[rsp]
	mov	ecx, DWORD PTR size$[rsp]
	lea	eax, DWORD PTR [rax+rcx-1]
	cmp	eax, DWORD PTR cnt$[rsp]
	jle	SHORT $LN16@SubStrDir

; 398  :         return( EmitError( COUNT_VALUE_TOO_LARGE ) );

	mov	ecx, 207				; 000000cfH
	call	EmitError
	jmp	$LN1@SubStrDir
$LN16@SubStrDir:

; 399  :     }
; 400  :     p += pos - 1;

	mov	eax, DWORD PTR pos$[rsp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 401  :     if ( size == -1 )

	cmp	DWORD PTR size$[rsp], -1
	jne	SHORT $LN17@SubStrDir

; 402  :         size = cnt - pos + 1;

	mov	eax, DWORD PTR pos$[rsp]
	mov	ecx, DWORD PTR cnt$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	inc	eax
	mov	DWORD PTR size$[rsp], eax
$LN17@SubStrDir:

; 403  : #endif
; 404  : 
; 405  :     sym = SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 406  : 
; 407  :     /* if we've never seen it before, put it in */
; 408  :     if( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN18@SubStrDir

; 409  :         sym = SymCreate( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymCreate
	mov	QWORD PTR sym$[rsp], rax
	jmp	$LN19@SubStrDir
$LN18@SubStrDir:

; 410  :     } else if( sym->state == SYM_UNDEFINED ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN20@SubStrDir

; 411  :         /* it was referenced before being defined. This is
; 412  :          * a bad idea for preprocessor text items, because it
; 413  :          * will require a full second pass!
; 414  :          */
; 415  :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_remove_table

; 416  : #if FASTPASS
; 417  :         SkipSavedState();

	call	SkipSavedState

; 418  :         EmitWarn( 2, TEXT_MACRO_USED_PRIOR_TO_DEFINITION, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 236				; 000000ecH
	mov	ecx, 2
	call	EmitWarn
	jmp	SHORT $LN21@SubStrDir
$LN20@SubStrDir:

; 419  : #endif
; 420  :     } else if( sym->state != SYM_TMACRO ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 10
	je	SHORT $LN22@SubStrDir

; 421  :         /* it is defined as something incompatible, get out */
; 422  :         DebugMsg(( "SubStrDir(%s) error, incompatible type\n", sym->name));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11084
	call	DoDebugMsg

; 423  :         return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@SubStrDir
$LN22@SubStrDir:
$LN21@SubStrDir:
$LN19@SubStrDir:

; 424  :     }
; 425  : 
; 426  :     sym->state = SYM_TMACRO;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+32], 10

; 427  :     sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 428  : 
; 429  : #if FASTMEM==0
; 430  :     if ( sym->string_ptr )
; 431  :         LclFree( sym->string_ptr );
; 432  :     sym->string_ptr = (char *)LclAlloc( size + 1 );
; 433  : #else
; 434  :     if ( sym->total_size < ( size + 1 ) ) {

	mov	eax, DWORD PTR size$[rsp]
	inc	eax
	mov	rcx, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rcx+56], eax
	jae	SHORT $LN23@SubStrDir

; 435  :         LclFree( sym->string_ptr );
; 436  :         sym->string_ptr = LclAlloc ( size + 1 );

	mov	eax, DWORD PTR size$[rsp]
	inc	eax
	cdqe
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 437  :         sym->total_size = size + 1;

	mov	eax, DWORD PTR size$[rsp]
	inc	eax
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+56], eax
$LN23@SubStrDir:

; 438  :     }
; 439  : #endif
; 440  :     memcpy( sym->string_ptr, p, size );

	movsxd	rax, DWORD PTR size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	memcpy

; 441  :     *(sym->string_ptr + size) = NULLC;

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	BYTE PTR [rax+rcx], 0

; 442  :     DebugMsg1(("SubStrDir(%s): result=>%s<\n", sym->name, sym->string_ptr ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11086
	call	DoDebugMsg1

; 443  : 
; 444  :     LstWrite( LSTTYPE_TMACRO, 0, sym );

	mov	r8, QWORD PTR sym$[rsp]
	xor	edx, edx
	mov	ecx, 3
	call	LstWrite

; 445  : 
; 446  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SubStrDir:

; 447  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:SubStrDir$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 240				; 000000f0H
	pop	rdi
	ret	0
SubStrDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
sym$ = 48
count$ = 56
p$ = 64
i$ = 96
tokenarray$ = 104
CatStrDir PROC

; 75   : {

$LN20:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+96]

; 76   :     struct asym *sym;
; 77   :     int count;
; 78   :     char *p;
; 79   :     /* struct expr opndx; */
; 80   : 
; 81   :     DebugMsg1(("CatStrDir(%u) enter\n", i ));

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG10982
	call	DoDebugMsg1

; 82   :     DebugCmd( catstrcnt++ );

	mov	eax, DWORD PTR catstrcnt
	inc	eax
	mov	DWORD PTR catstrcnt, eax

; 83   : 
; 84   : #if 0 /* can't happen */
; 85   :     /* syntax must be <id> CATSTR textitem[,textitem,...] */
; 86   :     if ( i != 1 ) {
; 87   :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );
; 88   :     }
; 89   :     if ( tokenarray[0].token != T_ID ) {
; 90   :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );
; 91   :     }
; 92   : #endif
; 93   :     i++; /* go past CATSTR/TEXTEQU */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 94   : 
; 95   :     /* v2.08: don't copy to temp buffer */
; 96   :     //*StringBufferEnd = NULLC;
; 97   :     /* check correct syntax and length of items */
; 98   :     for ( count = 0; i < Token_Count; ) {

	mov	DWORD PTR count$[rsp], 0
$LN2@CatStrDir:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@CatStrDir

; 99   :         DebugMsg1(("CatStrDir(%s): item[%u]=%s delim=0x%x\n", tokenarray[0].string_ptr, i, tokenarray[i].string_ptr, tokenarray[i].string_delim ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	edx, 32					; 00000020H
	imul	rdx, rdx, 0
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	r9, QWORD PTR [rax+rcx+8]
	mov	r8d, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rdx+8]
	lea	rcx, OFFSET FLAT:$SG10983
	call	DoDebugMsg1

; 100  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN9@CatStrDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN8@CatStrDir
$LN9@CatStrDir:

; 101  :             DebugMsg(("CatStrDir: error, not a <>-literal: %s\n", tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG10986
	call	DoDebugMsg

; 102  :             return( TextItemError( &tokenarray[i] ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	TextItemError
	jmp	$LN1@CatStrDir
$LN8@CatStrDir:

; 103  :         }
; 104  :         /* v2.08: using tokenarray.stringlen is not quite correct, since some chars
; 105  :          * are stored in 2 bytes (!) */
; 106  :         if ( ( count + tokenarray[i].stringlen ) >= MAX_LINE_LEN ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	ecx, DWORD PTR count$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, 600				; 00000258H
	jb	SHORT $LN10@CatStrDir

; 107  :             DebugMsg(("CatStrDir: error, literal too long: %u + %u >= %u\n", count, tokenarray[i].stringlen, MAX_LINE_LEN ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r9d, 600				; 00000258H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8d, DWORD PTR [rcx+rax+16]
	mov	edx, DWORD PTR count$[rsp]
	lea	rcx, OFFSET FLAT:$SG10988
	call	DoDebugMsg

; 108  :             return( EmitError( STRING_OR_TEXT_LITERAL_TOO_LONG ) );

	mov	ecx, 155				; 0000009bH
	call	EmitError
	jmp	$LN1@CatStrDir
$LN10@CatStrDir:

; 109  :         }
; 110  :         /* v2.08: don't copy to temp buffer */
; 111  :         //strcpy( StringBufferEnd + count, tokenarray[i].string_ptr );
; 112  :         count = count + tokenarray[i].stringlen;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	ecx, DWORD PTR count$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR count$[rsp], eax

; 113  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 114  :         if ( ( tokenarray[i].token != T_COMMA ) &&

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN11@CatStrDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN11@CatStrDir

; 115  :             ( tokenarray[i].token != T_FINAL ) ) {
; 116  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@CatStrDir
$LN11@CatStrDir:

; 117  :         }
; 118  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 119  :     }

	jmp	$LN2@CatStrDir
$LN3@CatStrDir:

; 120  : 
; 121  :     sym = SymSearch( tokenarray[0].string_ptr );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 122  :     if ( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN12@CatStrDir

; 123  :         sym = SymCreate( tokenarray[0].string_ptr );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymCreate
	mov	QWORD PTR sym$[rsp], rax

; 124  :         DebugMsg1(( "CatStrDir: new symbol %s created\n", sym->name));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10992
	call	DoDebugMsg1
	jmp	$LN13@CatStrDir
$LN12@CatStrDir:

; 125  :     } else if( sym->state == SYM_UNDEFINED ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN14@CatStrDir

; 126  :         /* v2.01: symbol has been used already. Using
; 127  :          * a textmacro before it has been defined is
; 128  :          * somewhat problematic.
; 129  :          */
; 130  :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_remove_table

; 131  : #if FASTPASS
; 132  :         SkipSavedState(); /* further passes must be FULL! */

	call	SkipSavedState

; 133  : #endif
; 134  :         EmitWarn( 2, TEXT_MACRO_USED_PRIOR_TO_DEFINITION, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 236				; 000000ecH
	mov	ecx, 2
	call	EmitWarn
	jmp	SHORT $LN15@CatStrDir
$LN14@CatStrDir:

; 135  :     } else if( sym->state != SYM_TMACRO ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 10
	je	SHORT $LN16@CatStrDir

; 136  :         /* it is defined as something else, get out */
; 137  :         DebugMsg(( "CatStrDir(%s) exit, symbol redefinition\n", sym->name));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10996
	call	DoDebugMsg

; 138  :         return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@CatStrDir
$LN16@CatStrDir:
$LN15@CatStrDir:
$LN13@CatStrDir:

; 139  :     }
; 140  : 
; 141  : 
; 142  :     sym->state = SYM_TMACRO;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+32], 10

; 143  :     sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 144  : #if FASTMEM==0
; 145  :     if ( sym->string_ptr )
; 146  :         LclFree( sym->string_ptr );
; 147  :     sym->string_ptr = (char *)LclAlloc( count + 1 );
; 148  : #else
; 149  :     /* v2.08: reuse string space if fastmem is on */
; 150  :     if ( sym->total_size < ( count+1 ) ) {

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	rcx, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rcx+56], eax
	jae	SHORT $LN17@CatStrDir

; 151  :         LclFree( sym->string_ptr ); /* is a noop if fastmem is on */
; 152  :         sym->string_ptr = (char *)LclAlloc( count + 1 );

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	cdqe
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 153  :         sym->total_size = count + 1;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+56], eax
$LN17@CatStrDir:

; 154  :     }
; 155  : #endif
; 156  :     /* v2.08: don't use temp buffer */
; 157  :     //memcpy( sym->string_ptr, StringBufferEnd, count + 1 );
; 158  :     for ( i = 2, p = sym->string_ptr; i < Token_Count; i += 2 ) {

	mov	DWORD PTR i$[rsp], 2
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN7@CatStrDir
$LN5@CatStrDir:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 2
	mov	DWORD PTR i$[rsp], eax
$LN7@CatStrDir:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN6@CatStrDir

; 159  :         memcpy( p, tokenarray[i].string_ptr, tokenarray[i].stringlen );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8d, eax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	mov	rcx, QWORD PTR p$[rsp]
	call	memcpy

; 160  :         p += tokenarray[i].stringlen;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 161  :     }

	jmp	SHORT $LN5@CatStrDir
$LN6@CatStrDir:

; 162  :     *p = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 0

; 163  :     DebugMsg1(("CatStrDir(%s) (new) value: >%s<\n", sym->name, sym->string_ptr ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10998
	call	DoDebugMsg1

; 164  : 
; 165  :     if ( ModuleInfo.list )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN18@CatStrDir

; 166  :         LstWrite( LSTTYPE_TMACRO, 0, sym );

	mov	r8, QWORD PTR sym$[rsp]
	xor	edx, edx
	mov	ecx, 3
	call	LstWrite
$LN18@CatStrDir:

; 167  : 
; 168  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@CatStrDir:

; 169  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
CatStrDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
StringFini PROC

; 859  : {

$LN4:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 860  :     if ( Options.quiet == FALSE )

	movzx	eax, BYTE PTR Options
	test	eax, eax
	jne	SHORT $LN2@StringFini

; 861  :         printf("invokation CATSTR=%u SUBSTR=%u SIZESTR=%u INSTR=%u EQU(text)=%u\n", catstrcnt, substrcnt, sizstrcnt, instrcnt, equcnt );

	mov	eax, DWORD PTR equcnt
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR instrcnt
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR sizstrcnt
	mov	r8d, DWORD PTR substrcnt
	mov	edx, DWORD PTR catstrcnt
	lea	rcx, OFFSET FLAT:$SG11258
	call	printf
$LN2@StringFini:

; 862  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
StringFini ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
i$ = 32
macro$ = 40
tv169 = 48
tv249 = 52
StringInit PROC

; 779  : {

$LN13:
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 780  :     int i;
; 781  :     struct dsym *macro;
; 782  : 
; 783  :     DebugMsg(( "StringInit() enter\n" ));

	lea	rcx, OFFSET FLAT:$SG11250
	call	DoDebugMsg

; 784  : 
; 785  : #ifdef DEBUG_OUT
; 786  :     catstrcnt = 0;

	mov	DWORD PTR catstrcnt, 0

; 787  :     substrcnt = 0;

	mov	DWORD PTR substrcnt, 0

; 788  :     sizstrcnt = 0;

	mov	DWORD PTR sizstrcnt, 0

; 789  :     instrcnt = 0;

	mov	DWORD PTR instrcnt, 0

; 790  :     equcnt = 0;

	mov	DWORD PTR equcnt, 0

; 791  : #endif
; 792  : 
; 793  :     /* add @CatStr() macro func */
; 794  : 
; 795  :     macro = CreateMacro( "@CatStr" );

	lea	rcx, OFFSET FLAT:$SG11251
	call	CreateMacro
	mov	QWORD PTR macro$[rsp], rax

; 796  :     macro->sym.isdefined = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+40], al

; 797  :     macro->sym.predefined = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+40], al

; 798  :     macro->sym.func_ptr = CatStrFunc;

	mov	rax, QWORD PTR macro$[rsp]
	lea	rcx, OFFSET FLAT:CatStrFunc
	mov	QWORD PTR [rax+16], rcx

; 799  :     macro->sym.isfunc = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	or	al, 2
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+44], al

; 800  :     /* v2.08: @CatStr() changed to VARARG */
; 801  :     macro->sym.mac_vararg = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	or	al, 1
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+44], al

; 802  :     macro->e.macroinfo->parmcnt = 1;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 1
	mov	WORD PTR [rax], cx

; 803  :     macro->e.macroinfo->parmlist = LclAlloc( sizeof( struct mparm_list ) * 1 );

	mov	ecx, 16
	call	LclAlloc
	mov	rcx, QWORD PTR macro$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx+8], rax

; 804  :     macro->e.macroinfo->parmlist[0].deflt = NULL;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax+rcx], 0

; 805  :     macro->e.macroinfo->parmlist[0].required = FALSE;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+rcx+8]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR macro$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	rcx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rcx+rdx+8], al

; 806  : 
; 807  :     /* add @InStr() macro func */
; 808  : 
; 809  :     macro = CreateMacro( "@InStr" );

	lea	rcx, OFFSET FLAT:$SG11252
	call	CreateMacro
	mov	QWORD PTR macro$[rsp], rax

; 810  :     macro->sym.isdefined = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+40], al

; 811  :     macro->sym.predefined = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+40], al

; 812  :     macro->sym.func_ptr = InStrFunc;

	mov	rax, QWORD PTR macro$[rsp]
	lea	rcx, OFFSET FLAT:InStrFunc
	mov	QWORD PTR [rax+16], rcx

; 813  :     macro->sym.isfunc = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	or	al, 2
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+44], al

; 814  :     macro->e.macroinfo->parmcnt = 3;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 3
	mov	WORD PTR [rax], cx

; 815  :     macro->e.macroinfo->autoexp = 1; /* param 1 (pos) is expanded */

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 1
	mov	WORD PTR [rax+2], cx

; 816  :     macro->e.macroinfo->parmlist = LclAlloc(sizeof( struct mparm_list) * 3);

	mov	ecx, 48					; 00000030H
	call	LclAlloc
	mov	rcx, QWORD PTR macro$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx+8], rax

; 817  :     for (i = 0; i < 3; i++) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@StringInit
$LN2@StringInit:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@StringInit:
	cmp	DWORD PTR i$[rsp], 3
	jge	SHORT $LN3@StringInit

; 818  :         macro->e.macroinfo->parmlist[i].deflt = NULL;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax+rcx], 0

; 819  :         //macro->e.macroinfo->parmlist[i].label = parmnames[i];
; 820  :         macro->e.macroinfo->parmlist[i].required = (i != 0);

	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN9@StringInit
	mov	DWORD PTR tv169[rsp], 1
	jmp	SHORT $LN10@StringInit
$LN9@StringInit:
	mov	DWORD PTR tv169[rsp], 0
$LN10@StringInit:
	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	mov	rax, QWORD PTR [rax+8]
	movzx	edx, BYTE PTR tv169[rsp]
	and	dl, 1
	movzx	eax, BYTE PTR [rax+rcx+8]
	and	al, 254					; 000000feH
	or	al, dl
	mov	rcx, QWORD PTR macro$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	movsxd	rdx, DWORD PTR i$[rsp]
	imul	rdx, rdx, 16
	mov	rcx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rcx+rdx+8], al

; 821  :     }

	jmp	$LN2@StringInit
$LN3@StringInit:

; 822  : 
; 823  :     /* add @SizeStr() macro func */
; 824  : 
; 825  :     macro = CreateMacro( "@SizeStr" );

	lea	rcx, OFFSET FLAT:$SG11253
	call	CreateMacro
	mov	QWORD PTR macro$[rsp], rax

; 826  :     macro->sym.isdefined = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+40], al

; 827  :     macro->sym.predefined = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+40], al

; 828  :     macro->sym.func_ptr = SizeStrFunc;

	mov	rax, QWORD PTR macro$[rsp]
	lea	rcx, OFFSET FLAT:SizeStrFunc
	mov	QWORD PTR [rax+16], rcx

; 829  :     macro->sym.isfunc = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	or	al, 2
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+44], al

; 830  :     macro->e.macroinfo->parmcnt = 1;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 1
	mov	WORD PTR [rax], cx

; 831  :     macro->e.macroinfo->parmlist = LclAlloc(sizeof( struct mparm_list));

	mov	ecx, 16
	call	LclAlloc
	mov	rcx, QWORD PTR macro$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx+8], rax

; 832  :     macro->e.macroinfo->parmlist[0].deflt = NULL;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax+rcx], 0

; 833  :     //macro->e.macroinfo->parmlist[0].label = parmnames[0];
; 834  :     /* macro->e.macroinfo->parmlist[0].required = TRUE; */
; 835  :     /* the string parameter is NOT required, '@SizeStr()' is valid */
; 836  :     macro->e.macroinfo->parmlist[0].required = FALSE;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+rcx+8]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR macro$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	rcx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rcx+rdx+8], al

; 837  : 
; 838  :     /* add @SubStr() macro func */
; 839  : 
; 840  :     macro = CreateMacro( "@SubStr" );

	lea	rcx, OFFSET FLAT:$SG11254
	call	CreateMacro
	mov	QWORD PTR macro$[rsp], rax

; 841  :     macro->sym.isdefined = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+40], al

; 842  :     macro->sym.predefined = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+40], al

; 843  :     macro->sym.func_ptr = SubStrFunc;

	mov	rax, QWORD PTR macro$[rsp]
	lea	rcx, OFFSET FLAT:SubStrFunc
	mov	QWORD PTR [rax+16], rcx

; 844  :     macro->sym.isfunc = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	or	al, 2
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+44], al

; 845  :     macro->e.macroinfo->parmcnt = 3;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 3
	mov	WORD PTR [rax], cx

; 846  :     macro->e.macroinfo->autoexp = 2 + 4; /* param 2 (pos) and 3 (size) are expanded */

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 6
	mov	WORD PTR [rax+2], cx

; 847  :     macro->e.macroinfo->parmlist = LclAlloc(sizeof( struct mparm_list) * 3);

	mov	ecx, 48					; 00000030H
	call	LclAlloc
	mov	rcx, QWORD PTR macro$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx+8], rax

; 848  :     for (i = 0; i < 3; i++) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@StringInit
$LN5@StringInit:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@StringInit:
	cmp	DWORD PTR i$[rsp], 3
	jge	SHORT $LN6@StringInit

; 849  :         macro->e.macroinfo->parmlist[i].deflt = NULL;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax+rcx], 0

; 850  :         //macro->e.macroinfo->parmlist[i].label = parmnames[i];
; 851  :         macro->e.macroinfo->parmlist[i].required = (i < 2);

	cmp	DWORD PTR i$[rsp], 2
	jge	SHORT $LN11@StringInit
	mov	DWORD PTR tv249[rsp], 1
	jmp	SHORT $LN12@StringInit
$LN11@StringInit:
	mov	DWORD PTR tv249[rsp], 0
$LN12@StringInit:
	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	mov	rax, QWORD PTR [rax+8]
	movzx	edx, BYTE PTR tv249[rsp]
	and	dl, 1
	movzx	eax, BYTE PTR [rax+rcx+8]
	and	al, 254					; 000000feH
	or	al, dl
	mov	rcx, QWORD PTR macro$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	movsxd	rdx, DWORD PTR i$[rsp]
	imul	rdx, rdx, 16
	mov	rcx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rcx+rdx+8], al

; 852  :     }

	jmp	$LN5@StringInit
$LN6@StringInit:

; 853  : 
; 854  :     return;
; 855  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
StringInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
sym$1 = 32
item$ = 64
TextItemError PROC

; 53   : {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 54   :     if ( item->token == T_STRING && *item->string_ptr == '<' ) {

	mov	rax, QWORD PTR item$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 9
	jne	SHORT $LN2@TextItemEr
	mov	rax, QWORD PTR item$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN2@TextItemEr

; 55   :         return( EmitError( MISSING_ANGLE_BRACKET_OR_BRACE_IN_LITERAL ) );

	mov	ecx, 216				; 000000d8H
	call	EmitError
	jmp	SHORT $LN1@TextItemEr
$LN2@TextItemEr:

; 56   :     }
; 57   :     /* v2.05: better error msg if (text) symbol isn't defined */
; 58   :     if ( item->token == T_ID ) {

	mov	rax, QWORD PTR item$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 8
	jne	SHORT $LN3@TextItemEr

; 59   :         struct asym *sym = SymSearch( item->string_ptr );

	mov	rax, QWORD PTR item$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	SymFind
	mov	QWORD PTR sym$1[rsp], rax

; 60   :         if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	cmp	QWORD PTR sym$1[rsp], 0
	je	SHORT $LN5@TextItemEr
	mov	rax, QWORD PTR sym$1[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN4@TextItemEr
$LN5@TextItemEr:

; 61   :             return( EmitErr( SYMBOL_NOT_DEFINED, item->string_ptr ) );

	mov	rax, QWORD PTR item$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr
	jmp	SHORT $LN1@TextItemEr
$LN4@TextItemEr:
$LN3@TextItemEr:

; 62   :         }
; 63   :     }
; 64   :     return( EmitError( TEXT_ITEM_REQUIRED ) );

	mov	ecx, 144				; 00000090H
	call	EmitError
$LN1@TextItemEr:

; 65   : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
TextItemError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
sym$ = 32
name$ = 64
value$ = 72
AddPredefinedText PROC

; 254  : {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 255  :     struct asym *sym;
; 256  : 
; 257  :     DebugMsg1(("AddPredefinedText(%s): >%s<\n", name, value ));

	mov	r8, QWORD PTR value$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11037
	call	DoDebugMsg1

; 258  :     /* v2.08: ignore previous setting */
; 259  :     if ( NULL == ( sym = SymSearch( name ) ) )

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN2@AddPredefi

; 260  :         sym = SymCreate( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymCreate
	mov	QWORD PTR sym$[rsp], rax
$LN2@AddPredefi:

; 261  :     sym->state = SYM_TMACRO;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+32], 10

; 262  :     sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 263  :     sym->predefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 264  :     sym->string_ptr = (char *)value;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR value$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 265  :     /* to ensure that a new buffer is used if the string is modified */
; 266  :     sym->total_size = 0;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+56], 0

; 267  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]

; 268  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
AddPredefinedText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
_TEXT	SEGMENT
count$ = 32
tokenarray$ = 64
sym$ = 72
name$ = 80
value$ = 88
SetTextMacro PROC

; 179  : {

$LN16:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 180  :     int count;
; 181  :     //char *p;
; 182  : 
; 183  :     DebugCmd( equcnt++ );

	mov	eax, DWORD PTR equcnt
	inc	eax
	mov	DWORD PTR equcnt, eax

; 184  : 
; 185  :     if ( sym == NULL )

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN5@SetTextMac

; 186  :         sym = SymCreate( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymCreate
	mov	QWORD PTR sym$[rsp], rax
	jmp	SHORT $LN6@SetTextMac
$LN5@SetTextMac:

; 187  :     else if ( sym->state == SYM_UNDEFINED ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN7@SetTextMac

; 188  :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_remove_table

; 189  : #if FASTPASS
; 190  :         /* the text macro was referenced before being defined.
; 191  :          * this is valid usage, but it requires a full second pass.
; 192  :          * just simply deactivate the fastpass feature for this module!
; 193  :          */
; 194  :         SkipSavedState();

	call	SkipSavedState

; 195  : #endif
; 196  :         EmitWarn( 2, TEXT_MACRO_USED_PRIOR_TO_DEFINITION, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 236				; 000000ecH
	mov	ecx, 2
	call	EmitWarn
	jmp	SHORT $LN8@SetTextMac
$LN7@SetTextMac:

; 197  :     } else if ( sym->state != SYM_TMACRO ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 10
	je	SHORT $LN9@SetTextMac

; 198  :         EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 199  :         return( NULL );

	xor	eax, eax
	jmp	$LN1@SetTextMac
$LN9@SetTextMac:
$LN8@SetTextMac:
$LN6@SetTextMac:

; 200  :     }
; 201  : 
; 202  :     sym->state = SYM_TMACRO;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+32], 10

; 203  :     sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 204  : 
; 205  :     if ( tokenarray[2].token == T_STRING && tokenarray[2].string_delim == '<' ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	$LN10@SetTextMac
	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN10@SetTextMac

; 206  : 
; 207  :         /* the simplest case: value is a literal. define a text macro! */
; 208  :         /* just ONE literal is allowed */
; 209  :         if ( tokenarray[3].token != T_FINAL ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 3
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN12@SetTextMac

; 210  :             EmitErr( SYNTAX_ERROR_EX, tokenarray[3].tokpos );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 3
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 211  :             return( NULL );

	xor	eax, eax
	jmp	$LN1@SetTextMac
$LN12@SetTextMac:

; 212  :         }
; 213  :         value = tokenarray[2].string_ptr;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR value$[rsp], rax

; 214  :         count = tokenarray[2].stringlen;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR count$[rsp], eax

; 215  :     } else {

	jmp	SHORT $LN11@SetTextMac
$LN10@SetTextMac:

; 216  :         /*
; 217  :          * the original source is used, since the tokenizer has
; 218  :          * deleted some information.
; 219  :          */
; 220  :         //while ( isspace( *value ) ) value++; /* probably obsolete */
; 221  :         count = strlen( value );

	mov	rcx, QWORD PTR value$[rsp]
	call	strlen
	mov	DWORD PTR count$[rsp], eax

; 222  :         /* skip trailing spaces */
; 223  :         for ( ; count; count-- )

	jmp	SHORT $LN4@SetTextMac
$LN2@SetTextMac:
	mov	eax, DWORD PTR count$[rsp]
	dec	eax
	mov	DWORD PTR count$[rsp], eax
$LN4@SetTextMac:
	cmp	DWORD PTR count$[rsp], 0
	je	SHORT $LN3@SetTextMac

; 224  :             if ( isspace( *( value + count - 1 ) ) == FALSE )

	movsxd	rax, DWORD PTR count$[rsp]
	mov	rcx, QWORD PTR value$[rsp]
	movsx	eax, BYTE PTR [rcx+rax-1]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	jne	SHORT $LN13@SetTextMac

; 225  :                 break;

	jmp	SHORT $LN3@SetTextMac
$LN13@SetTextMac:
	jmp	SHORT $LN2@SetTextMac
$LN3@SetTextMac:
$LN11@SetTextMac:

; 226  :     }
; 227  : #if FASTMEM==0
; 228  :     if ( sym->string_ptr )
; 229  :         LclFree( sym->string_ptr );
; 230  :     sym->string_ptr = (char *)LclAlloc( count + 1 );
; 231  : #else
; 232  :     if ( sym->total_size < ( count + 1 ) ) {

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	rcx, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rcx+56], eax
	jae	SHORT $LN14@SetTextMac

; 233  :         LclFree( sym->string_ptr ); /* is a noop if fastmem is on */
; 234  :         sym->string_ptr = (char *)LclAlloc( count + 1 );

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	cdqe
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 235  :         sym->total_size = count + 1;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+56], eax
$LN14@SetTextMac:

; 236  :     }
; 237  : #endif
; 238  :     memcpy( sym->string_ptr, value, count );

	movsxd	rax, DWORD PTR count$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR value$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	memcpy

; 239  :     *(sym->string_ptr + count) = NULLC;

	movsxd	rax, DWORD PTR count$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	BYTE PTR [rax+rcx], 0

; 240  : 
; 241  :     DebugMsg1(( "SetTextMacro(%s): value is >%s<, exit\n", sym->name, sym->string_ptr ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11028
	call	DoDebugMsg1

; 242  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]
$LN1@SetTextMac:

; 243  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SetTextMacro ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Format$ = 96
printf	PROC						; COMDAT

; 950  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 957  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:printf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
	push	rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	rdi
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
