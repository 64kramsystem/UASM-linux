; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	stackreg
_DATA	SEGMENT
COMM	procidx:DWORD
COMM	CurrProcLine:DWORD
COMM	XYZMMsize:DWORD
COMM	ProcStatus:DWORD
COMM	StackAdj:DWORD
COMM	StackAdjHigh:DWORD
_DATA	ENDS
_BSS	SEGMENT
$SG11656 DB	01H DUP (?)
$SG11681 DB	01H DUP (?)
$SG11682 DB	01H DUP (?)
$SG11694 DB	01H DUP (?)
$SG11697 DB	01H DUP (?)
$SG11726 DB	01H DUP (?)
$SG12829 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG11857 DB	01H DUP (?)
$SG11975 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	CurrProc:QWORD
COMM	sym_ReservedStack:QWORD
_DATA	ENDS
_BSS	SEGMENT
$SG12230 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG12347 DB	'mov [%r+%u], %r', 00H
$SG12348 DB	'%r %r, %u', 00H
	ORG $+6
$SG11378 DB	'sub %r, %d', 00H
	ORG $+1
$SG11379 DB	'%r %d', 00H
	ORG $+2
$SG11425 DB	'::', 00H
	ORG $+1
$SG11381 DB	'sub %r, %d + %s', 00H
$SG11382 DB	'%r %d + %s', 00H
	ORG $+1
$SG12479 DB	'cld', 00H
$SG12421 DB	'write_win64_default_prologue enter', 0aH, 00H
$SG12547 DB	'%r', 00H
	ORG $+1
$SG12427 DB	'write_win64_default_prologue: no frame register needed', 0aH
	DB	00H
$SG12428 DB	'push %r', 00H
$SG12429 DB	'%r %r', 00H
	ORG $+2
$SG12430 DB	'mov %r, %r', 00H
	ORG $+1
$SG12037 DB	'dw', 00H
	ORG $+1
$SG12431 DB	'%r %r, 0', 00H
	ORG $+3
$SG12443 DB	'%r %r', 00H
	ORG $+2
$SG11428 DB	'%s::%s', 00H
	ORG $+1
$SG12039 DB	',', 00H
	ORG $+2
$SG12441 DB	'push %r', 00H
$SG12449 DB	'push %r', 00H
$SG12451 DB	'%r %r', 00H
	ORG $+2
$SG11430 DB	'watc_pcheck(%s.%s): size=%u ptr=%u far=%u reg=%s', 0aH, 00H
	ORG $+2
$SG12472 DB	'dec %r', 00H
	ORG $+1
$SG12042 DB	'dw', 00H
	ORG $+1
$SG12461 DB	'write_win64_default_prologue: localsize=%u resstack=%u', 0aH
	DB	00H
$SG11438 DB	'%d%c', 00H
	ORG $+3
$SG12471 DB	'mov %r, %u', 00H
	ORG $+5
$SG12473 DB	'mov byte ptr [%r + %r], 0', 00H
	ORG $+6
$SG12474 DB	'dw 0F875h', 00H
	ORG $+6
$SG12475 DB	'push %r', 00H
$SG12476 DB	'push %r', 00H
$SG12477 DB	'xor %r, %r', 00H
	ORG $+5
$SG12478 DB	'mov %r, %u', 00H
	ORG $+5
$SG12480 DB	'lea %r, [%r+16]', 00H
$SG11456 DB	'%d%c', 00H
	ORG $+3
$SG12481 DB	'rep stosb', 00H
	ORG $+2
$SG12482 DB	'pop %r', 00H
	ORG $+1
$SG12483 DB	'pop %r', 00H
	ORG $+5
$SG12494 DB	'vmovdqu [%r+%u+%s], %r', 00H
	ORG $+1
$SG12495 DB	'%r %r, %u+%s', 00H
	ORG $+3
$SG12497 DB	'vmovdqu [%r+%u+%s], %r', 00H
	ORG $+1
$SG12498 DB	'%r %r, %u+%s', 00H
	ORG $+3
$SG12502 DB	'vmovdqu [%r+%u], %r', 00H
	ORG $+4
$SG12503 DB	'%r %r, %u', 00H
	ORG $+6
$SG12505 DB	'vmovdqu [%r+%u], %r', 00H
	ORG $+4
$SG12506 DB	'%r %r, %u', 00H
	ORG $+6
$SG12514 DB	'lea %r,[%r + %d]', 00H
	ORG $+7
$SG12516 DB	'mov [%r + %d], %r', 00H
	ORG $+6
$SG12524 DB	'mov [%r + %d], %r', 00H
	ORG $+6
$SG12533 DB	'vmovss dword ptr [rsp+%d],%r', 00H
	ORG $+3
$SG12536 DB	'vmovsd qword ptr [rsp+%d],%r', 00H
	ORG $+3
$SG12540 DB	'vmovups oword ptr [rsp+%d],%r', 00H
	ORG $+2
$SG12541 DB	'vmovups oword ptr [rsp+%d],%r', 00H
	ORG $+2
$SG12545 DB	'vmovups ymmword ptr [rsp+%d],%r', 00H
$SG12546 DB	'vmovups ymmword ptr [rsp+%d],%r', 00H
$SG11531 DB	'LocalDir(%u) entry', 0aH, 00H
	ORG $+4
$SG11536 DB	'LocalDir: item=%s', 0aH, 00H
	ORG $+5
$SG11540 DB	'LocalDir: SymLCreate( %s ) failed', 0aH, 00H
	ORG $+5
$SG12573 DB	'push %r', 00H
$SG12574 DB	'mov %r, %r', 00H
	ORG $+5
$SG12578 DB	'push %r', 00H
$SG12579 DB	'sub %r, %d + %s', 00H
$SG11555 DB	'NULL', 00H
	ORG $+3
$SG11556 DB	'LocalDir: memtype=%X, type=%s, size=%u*%u', 0aH, 00H
	ORG $+5
$SG12584 DB	'add %r, %d', 00H
	ORG $+5
$SG12585 DB	'sub %r, %d', 00H
	ORG $+5
$SG12587 DB	'push %r', 00H
$SG12588 DB	'mov %r, %s', 00H
	ORG $+5
$SG12589 DB	'mov %r, %r', 00H
	ORG $+5
$SG12591 DB	'push %r', 00H
$SG12654 DB	'SetLocalOffsets(%s): cntxmm=%u cntstd=%u start=%u align='
	DB	'%u localsize=%u', 0aH, 00H
	ORG $+7
$SG12661 DB	'SetLocalOffsets(%s): offset of %s (size=%u) set to %d', 0aH
	DB	00H
	ORG $+1
$SG12666 DB	'SetLocalOffsets(%s): localsize=%u after processing local'
	DB	's', 0aH, 00H
	ORG $+5
$SG12672 DB	'SetLocalOffsets(%s): FPO, adjusting offsets', 0aH, 00H
	ORG $+3
$SG12673 DB	'SetLocalOffsets(%s): FPO, offset for %s %4d -> %4d', 0aH
	DB	00H
	ORG $+4
$SG12674 DB	'SetLocalOffsets(%s): FPO, offset for %s %4d -> %4d', 0aH
	DB	00H
	ORG $+4
$SG12677 DB	'SetLocalOffsets(%s): final localsize=%u', 0aH, 00H
	ORG $+7
$SG11657 DB	'ParseParams: name missing/invalid for parameter %u, i=%u'
	DB	0aH, 00H
	ORG $+6
$SG12687 DB	'write_prologue(%s): default prologue', 0aH, 00H
	ORG $+2
$SG12690 DB	'write_prologue(%s): prologue is NULL', 0aH, 00H
	ORG $+2
$SG12691 DB	'write_prologue(%s): userdefined prologue %s', 0aH, 00H
	ORG $+3
$SG11672 DB	'ParseParams: %s defined already, state=%u, local=%u', 0aH
	DB	00H
	ORG $+3
$SG11683 DB	'ParseParams: old-new memtype=%X-%X type=%X(%s)-%X(%s) fa'
	DB	'r=%u-%u ind=%u-%u ofss=%d-%d pmt=%X-%X', 0aH, 00H
$SG12709 DB	'pop %r', 00H
	ORG $+1
$SG11685 DB	'ParseParams: calling SymAddLocal(%s, %s)', 0aH, 00H
	ORG $+2
$SG12712 DB	'pop %r', 00H
	ORG $+5
$SG11693 DB	'ParseParams: different param count', 0aH, 00H
	ORG $+4
$SG11699 DB	'ParseParams: SymLCreate(%s) failed', 0aH, 00H
	ORG $+4
$SG12740 DB	'write_win64_default_epilogue(%s): %u xmm registers to re'
	DB	'store', 0aH, 00H
	ORG $+1
$SG12746 DB	'write_win64_default_epilogue(%s): restore %s, offset=%d', 0aH
	DB	00H
	ORG $+7
$SG11722 DB	'ParseParams: error, cntParam=%u, found %s', 0aH, 00H
	ORG $+5
$SG12749 DB	'vmovdqu %r, [%r + %u + %s]', 00H
	ORG $+5
$SG11725 DB	'ParseParams: a param is left over, cntParam=%u', 0aH, 00H
$SG12750 DB	'vmovdqu %r, [%r + %u]', 00H
	ORG $+2
$SG12758 DB	'add %r, %d + %s', 00H
$SG12759 DB	'add %r, %d + %s', 00H
$SG11735 DB	'ParseParams: parm=%s, ofs=%u, size=%d', 0aH, 00H
	ORG $+1
$SG12760 DB	'add %r, %d', 00H
	ORG $+5
$SG12770 DB	'mov %r, [%r+%u]', 00H
$SG12773 DB	'pop %r', 00H
	ORG $+1
$SG12783 DB	'add %r, %d + %s', 00H
$SG12785 DB	'pop %r', 00H
	ORG $+1
$SG12791 DB	'leave', 00H
	ORG $+2
$SG12796 DB	'add %r, %d', 00H
	ORG $+5
$SG12798 DB	'mov %r, %r', 00H
	ORG $+1
$SG12799 DB	'pop %r', 00H
	ORG $+5
$SG11793 DB	'ParseProc: error, memtype changed, old-new memtype=%X-%X'
	DB	', ofssize=%X-%X', 0aH, 00H
	ORG $+7
$SG11801 DB	'ParseProc: error, language changed, %u - %u', 0aH, 00H
	ORG $+3
$SG12830 DB	'%s, 0%XH, 0%XH, 0%XH, <<%s>>, <%s>', 00H
	ORG $+5
$SG11807 DB	'PRIVATE', 00H
$SG12832 DB	'option epilogue:none', 0aH, 00H
	ORG $+2
$SG11812 DB	'PUBLIC', 00H
	ORG $+1
$SG11814 DB	'EXPORT', 00H
	ORG $+1
$SG11815 DB	'ParseProc(%s): EXPORT detected', 0aH, 00H
$SG12848 DB	'RetInstr() enter', 0aH, 00H
	ORG $+6
$SG11827 DB	'FORCEFRAME', 00H
	ORG $+5
$SG12854 DB	'RetInstr() exit', 0aH, 00H
	ORG $+3
$SG11830 DB	'LOADDS', 00H
	ORG $+5
$SG12855 DB	'RetInstr() exit', 0aH, 00H
	ORG $+3
$SG12867 DB	'%d%c', 00H
	ORG $+3
$SG11843 DB	'USES', 00H
	ORG $+7
$SG11845 DB	'ParseProc: USES found in PROTO', 0aH, 00H
$SG12871 DB	'%d%c', 00H
	ORG $+3
$SG12872 DB	'RetInstr() exit', 0aH, 00H
	ORG $+7
$SG11848 DB	'ParseProc: no registers for regslist', 0aH, 00H
	ORG $+2
$SG11853 DB	'ParseProc(%s): i=%u, Token_Count=%u, CurrWordSize=%u', 0aH
	DB	00H
	ORG $+2
$SG11862 DB	'ParseProc(%s): memtype=%Xh parasize=%u', 0aH, 00H
$SG11908 DB	'DeleteProc(%s) enter', 0aH, 00H
	ORG $+2
$SG11911 DB	'DeleteProc(%s): free %s [next=%p]', 0aH, 00H
	ORG $+5
$SG11915 DB	'DeleteProc(%s): free %p (%s) [next=%p]', 0aH, 00H
$SG11947 DB	'@Line', 00H
	ORG $+2
$SG11948 DB	'@ProcLine', 00H
	ORG $+6
$SG11949 DB	'ProcDir enter, curr ofs=%X', 0aH, 00H
$SG11973 DB	'proc.c', 00H
	ORG $+5
$SG11976 DB	'phase error ', 00H
	ORG $+3
$SG11977 DB	'ProcDir(%s): %spass %u, old ofs=%X, new ofs=%X', 0aH, 00H
$SG12006 DB	'CopyPrototype(%s,src=%s): ofssize=%u', 0aH, 00H
	ORG $+2
$SG12026 DB	'.xdata', 00H
	ORG $+1
$SG12031 DB	'%s %r', 00H
	ORG $+2
$SG12032 DB	'%s %r align(%u) flat read ''DATA''', 00H
	ORG $+7
$SG12033 DB	'$xdatasym label near', 00H
	ORG $+3
$SG12035 DB	'db %ut + (0%xh shl 3), %ut, %ut, 0%xh + (0%xh shl 4)', 00H
	ORG $+3
$SG12038 DB	'%s 0%xh', 00H
$SG12043 DB	'%r 4', 00H
	ORG $+3
$SG12045 DB	'dd %r %s', 00H
	ORG $+3
$SG12046 DB	'%r 8', 00H
	ORG $+3
$SG12047 DB	'%s %r', 00H
	ORG $+2
$SG12050 DB	'.pdata', 00H
	ORG $+5
$SG12051 DB	'.pdata$%04u', 00H
$SG12054 DB	'%s %r', 00H
	ORG $+6
$SG12055 DB	'%s %r align(%u) flat read ''DATA''', 00H
	ORG $+7
$SG12056 DB	'dd %r %s, %r %s+0%xh, %r $xdatasym+0%xh', 00H
$SG12057 DB	'%s %r', 00H
	ORG $+2
$SG12083 DB	'NULL', 00H
	ORG $+3
$SG12105 DB	'NULL', 00H
	ORG $+3
$SG12084 DB	'ProcFini(%s): unmatched block nesting error, proc->seg=%'
	DB	's, CurrSeg=%s', 0aH, 00H
	ORG $+1
$SG12089 DB	'ProcFini(%s): localsize=%u ReservedStack=%u', 0aH, 00H
	ORG $+3
$SG12091 DB	'ProcFini(%s): FPO, offset for %s %8d -> %8d', 0aH, 00H
	ORG $+3
$SG12092 DB	'ProcFini(%s): FPO, offset for %s %8d -> %8d', 0aH, 00H
	ORG $+3
$SG12106 DB	'EndpDir(%s) enter, curr ofs=% X, CurrProc=%s', 0aH, 00H
	ORG $+2
$SG12111 DB	'@ProcLine', 00H
	ORG $+6
$SG12132 DB	'ExcFrameDirective(%s) enter', 0aH, 00H
	ORG $+3
$SG12151 DB	'ExcFrameDirective: UWOP_ALLOC_SMALL, size=%Xh', 0aH, 00H
	ORG $+1
$SG12156 DB	'CODE', 00H
	ORG $+3
$SG12149 DB	'ExcFrameDirective: UWOP_ALLOC_LARGE, operation info 1, s'
	DB	'ize=%Xh', 0aH, 00H
	ORG $+7
$SG12188 DB	'ExcFrameDirective() exit, ok', 0aH, 00H
	ORG $+2
$SG12227 DB	'option prologue:none', 0aH, 00H
	ORG $+2
$SG12150 DB	'ExcFrameDirective: UWOP_ALLOC_LARGE, operation info 0, s'
	DB	'ize=%Xh', 0aH, 00H
	ORG $+7
$SG12194 DB	'ProcCheckOpen: unmatched block nesting error, CurrProc=%'
	DB	's', 0aH, 00H
	ORG $+5
$SG12231 DB	' (%s, 0%XH, 0%XH, 0%XH, <<%s>>, <%s>)', 00H
	ORG $+2
$SG12232 DB	'write_userdef_prologue: macro %s returned >%s<', 0aH, 00H
$SG12262 DB	'movsd qword ptr[%r+%u], %r', 00H
	ORG $+5
$SG12264 DB	'movss dword ptr[%r+%u], %r', 00H
	ORG $+5
$SG12269 DB	'mov [%r+%u], %r', 00H
$SG12270 DB	'mov [%r+%u], %r', 00H
$SG12275 DB	'movq [%r+%u], %r', 00H
	ORG $+7
$SG12277 DB	'mov [%r+%u], %r', 00H
$SG12278 DB	'mov [%r+%u], %r', 00H
$SG12283 DB	'movq [%r+%u], %r', 00H
	ORG $+7
$SG12284 DB	'mov [%r+%u], %r', 00H
$SG12285 DB	'mov [%r+%u], %r', 00H
_DATA	ENDS
CONST	SEGMENT
ms32_regs16 DD	09H
	DD	0bH
	DD	0cH
win64_nvgpr DW	0f0e8H
	ORG $+2
ms32_regs32 DD	012H
	DD	013H
ms32_maxreg DD	03H
	DD	02H
watc_regs8 DD	01H
	DD	03H
	DD	04H
	DD	02H
watc_regs16 DD	09H
	DD	0bH
	DD	0cH
	DD	0aH
watc_regs32 DD	011H
	DD	013H
	DD	014H
	DD	012H
watc_regs_qw DD	09H
	DD	0cH
	DD	0aH
	DD	0bH
ms64_regs DD	074H
	DD	075H
	DD	07bH
	DD	07cH
win64_nvxmm DW	0ffc0H
	ORG $+6
fastcall_tab DQ	FLAT:ms32_pcheck
	DQ	FLAT:ms32_return
	DQ	FLAT:watc_pcheck
	DQ	FLAT:watc_return
	DQ	FLAT:ms64_pcheck
	DQ	FLAT:ms64_return
vectorcall_tab DQ FLAT:ms32_pcheck
	DQ	FLAT:ms32_return
	DQ	FLAT:watc_pcheck
	DQ	FLAT:watc_return
	DQ	FLAT:ms64_pcheck
	DQ	FLAT:ms64_return
stackreg DD	0dH
	DD	015H
	DD	077H
	ORG $+4
fmtstk0	DQ	FLAT:$SG11378
	DQ	FLAT:$SG11379
fmtstk1	DQ	FLAT:$SG11381
	DQ	FLAT:$SG11382
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	ParseProc
PUBLIC	CreateProc
PUBLIC	DeleteProc
PUBLIC	CopyPrototype
PUBLIC	RetInstr
PUBLIC	write_prologue
PUBLIC	ProcInit
PUBLIC	ProcCheckOpen
PUBLIC	LocalDir
PUBLIC	UpdateStackBase
PUBLIC	UpdateProcStatus
PUBLIC	ProcDir
PUBLIC	EndpDir
PUBLIC	ExcFrameDirective
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__acrt_iob_func:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	atoi:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strcat:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	_stricmp:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	AddLinnumDataRef:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymAlloc:PROC
EXTRN	SymFree:PROC
EXTRN	SymCreate:PROC
EXTRN	SymLCreate:PROC
EXTRN	SymAddLocal:PROC
EXTRN	SymFind:PROC
EXTRN	SymClearLocal:PROC
EXTRN	SymSetLocal:PROC
EXTRN	SymGetLocal:PROC
EXTRN	SizeFromMemtype:PROC
EXTRN	SizeFromRegister:PROC
EXTRN	GetLangType:PROC
EXTRN	sym_add_table:PROC
EXTRN	sym_remove_table:PROC
EXTRN	sym_ext2int:PROC
EXTRN	ParseLine:PROC
EXTRN	SetSymSegOfs:PROC
EXTRN	GetSymOfssize:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	GetSegIdx:PROC
EXTRN	SimGetSegName:PROC
EXTRN	AddPublicData:PROC
EXTRN	BackPatch:PROC
EXTRN	GetLineNumber:PROC
EXTRN	get_curr_srcfile:PROC
EXTRN	AddLineQueue:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	RunLineQueue:PROC
EXTRN	Tokenize:PROC
EXTRN	EvalOperand:PROC
EXTRN	EmitConstError:PROC
EXTRN	GetQualifiedType:PROC
EXTRN	RunMacro:PROC
EXTRN	SkipSavedState:PROC
EXTRN	LstWrite:PROC
EXTRN	LstSetPosition:PROC
EXTRN	AlignCurrOffset:PROC
EXTRN	InternalError:PROC
EXTRN	GetResWName:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SymCmpFunc:QWORD
EXTRN	SymTables:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	LineStoreCurr:QWORD
EXTRN	UseSavedState:BYTE
EXTRN	szDgroup:BYTE
EXTRN	list_pos:DWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	8

ProcStack DQ	01H DUP (?)
endprolog_found DB 01H DUP (?)
	ALIGN	4

unw_segs_defined DB 01H DUP (?)
	ALIGN	4

unw_info DD	01H DUP (?)
unw_code DW	0102H DUP (?)
?regname@?1??watc_pcheck@@9@9 DB 040H DUP (?)		; `watc_pcheck'::`2'::regname
?regist@?1??watc_pcheck@@9@9 DB 020H DUP (?)		; `watc_pcheck'::`2'::regist
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$ParseProc DD imagerel $LN93
	DD	imagerel $LN93+4261
	DD	imagerel $unwind$ParseProc
$pdata$CreateProc DD imagerel $LN18
	DD	imagerel $LN18+628
	DD	imagerel $unwind$CreateProc
$pdata$DeleteProc DD imagerel $LN14
	DD	imagerel $LN14+304
	DD	imagerel $unwind$DeleteProc
$pdata$CopyPrototype DD imagerel $LN12
	DD	imagerel $LN12+476
	DD	imagerel $unwind$CopyPrototype
$pdata$RetInstr DD imagerel $LN28
	DD	imagerel $LN28+941
	DD	imagerel $unwind$RetInstr
$pdata$write_prologue DD imagerel $LN12
	DD	imagerel $LN12+335
	DD	imagerel $unwind$write_prologue
$pdata$ProcInit DD imagerel $LN5
	DD	imagerel $LN5+178
	DD	imagerel $unwind$ProcInit
$pdata$ProcCheckOpen DD imagerel $LN5
	DD	imagerel $LN5+77
	DD	imagerel $unwind$ProcCheckOpen
$pdata$ms32_pcheck DD imagerel ms32_pcheck
	DD	imagerel ms32_pcheck+390
	DD	imagerel $unwind$ms32_pcheck
$pdata$ms32_return DD imagerel ms32_return
	DD	imagerel ms32_return+187
	DD	imagerel $unwind$ms32_return
$pdata$watc_pcheck DD imagerel watc_pcheck
	DD	imagerel watc_pcheck+1293
	DD	imagerel $unwind$watc_pcheck
$pdata$watc_return DD imagerel watc_return
	DD	imagerel watc_return+176
	DD	imagerel $unwind$watc_return
$pdata$pushitem DD imagerel pushitem
	DD	imagerel pushitem+87
	DD	imagerel $unwind$pushitem
$pdata$popitem DD imagerel popitem
	DD	imagerel popitem+69
	DD	imagerel $unwind$popitem
$pdata$push_proc DD imagerel push_proc
	DD	imagerel push_proc+50
	DD	imagerel $unwind$push_proc
$pdata$pop_proc DD imagerel pop_proc
	DD	imagerel pop_proc+35
	DD	imagerel $unwind$pop_proc
$pdata$LocalDir DD imagerel $LN44
	DD	imagerel $LN44+1496
	DD	imagerel $unwind$LocalDir
$pdata$UpdateProcStatus DD imagerel $LN5
	DD	imagerel $LN5+58
	DD	imagerel $unwind$UpdateProcStatus
$pdata$ParseParams DD imagerel ParseParams
	DD	imagerel ParseParams+4907
	DD	imagerel $unwind$ParseParams
$pdata$ProcDir DD imagerel $LN42
	DD	imagerel $LN42+1788
	DD	imagerel $unwind$ProcDir
$pdata$WriteSEHData DD imagerel WriteSEHData
	DD	imagerel WriteSEHData+1144
	DD	imagerel $unwind$WriteSEHData
$pdata$SetLocalOffsets DD imagerel SetLocalOffsets
	DD	imagerel SetLocalOffsets+2108
	DD	imagerel $unwind$SetLocalOffsets
$pdata$ProcFini DD imagerel ProcFini
	DD	imagerel ProcFini+982
	DD	imagerel $unwind$ProcFini
$pdata$EndpDir DD imagerel $LN9
	DD	imagerel $LN9+309
	DD	imagerel $unwind$EndpDir
$pdata$ExcFrameDirective DD imagerel $LN59
	DD	imagerel $LN59+2944
	DD	imagerel $unwind$ExcFrameDirective
$pdata$write_userdef_prologue DD imagerel write_userdef_prologue
	DD	imagerel write_userdef_prologue+1016
	DD	imagerel $unwind$write_userdef_prologue
$pdata$win64_SaveRegParams DD imagerel win64_SaveRegParams
	DD	imagerel win64_SaveRegParams+1360
	DD	imagerel $unwind$win64_SaveRegParams
$pdata$win64_StoreRegHome DD imagerel win64_StoreRegHome
	DD	imagerel win64_StoreRegHome+1078
	DD	imagerel $unwind$win64_StoreRegHome
$pdata$write_win64_default_prologue DD imagerel write_win64_default_prologue
	DD	imagerel write_win64_default_prologue+4961
	DD	imagerel $unwind$write_win64_default_prologue
$pdata$write_default_prologue DD imagerel write_default_prologue
	DD	imagerel write_default_prologue+1130
	DD	imagerel $unwind$write_default_prologue
$pdata$pop_register DD imagerel pop_register
	DD	imagerel pop_register+344
	DD	imagerel $unwind$pop_register
$pdata$write_win64_default_epilogue DD imagerel write_win64_default_epilogue
	DD	imagerel write_win64_default_epilogue+1352
	DD	imagerel $unwind$write_win64_default_epilogue
$pdata$write_default_epilogue DD imagerel write_default_epilogue
	DD	imagerel write_default_epilogue+658
	DD	imagerel $unwind$write_default_epilogue
$pdata$write_userdef_epilogue DD imagerel write_userdef_epilogue
	DD	imagerel write_userdef_epilogue+895
	DD	imagerel $unwind$write_userdef_epilogue
pdata	ENDS
xdata	SEGMENT
$unwind$ParseProc DD 021a01H
	DD	011011aH
$unwind$CreateProc DD 011301H
	DD	08213H
$unwind$DeleteProc DD 010901H
	DD	08209H
$unwind$CopyPrototype DD 010e01H
	DD	0820eH
$unwind$RetInstr DD 022719H
	DD	08f0115H
	DD	imagerel __GSHandlerCheck
	DD	0460H
$unwind$write_prologue DD 010901H
	DD	06209H
$unwind$ProcInit DD 010401H
	DD	02204H
$unwind$ProcCheckOpen DD 010401H
	DD	04204H
$unwind$ms32_pcheck DD 012219H
	DD	0c213H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$ms32_return DD 010e01H
	DD	0620eH
$unwind$watc_pcheck DD 021601H
	DD	0110116H
$unwind$watc_return DD 010e01H
	DD	0620eH
$unwind$pushitem DD 010e01H
	DD	0620eH
$unwind$popitem DD 010901H
	DD	04209H
$unwind$push_proc DD 010901H
	DD	04209H
$unwind$pop_proc DD 010401H
	DD	04204H
$unwind$LocalDir DD 021001H
	DD	0210110H
$unwind$UpdateProcStatus DD 010e01H
	DD	0220eH
$unwind$ParseParams DD 031b01H
	DD	02c011bH
	DD	03014H
$unwind$ProcDir DD 021001H
	DD	0110110H
$unwind$WriteSEHData DD 021e19H
	DD	027010cH
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$SetLocalOffsets DD 020c01H
	DD	013010cH
$unwind$ProcFini DD 010901H
	DD	08209H
$unwind$EndpDir DD 010d01H
	DD	0620dH
$unwind$ExcFrameDirective DD 021001H
	DD	0190110H
$unwind$write_userdef_prologue DD 021e19H
	DD	0a5010cH
	DD	imagerel __GSHandlerCheck
	DD	0510H
$unwind$win64_SaveRegParams DD 010901H
	DD	08209H
$unwind$win64_StoreRegHome DD 010901H
	DD	08209H
$unwind$write_win64_default_prologue DD 021e19H
	DD	01b010cH
	DD	imagerel __GSHandlerCheck
	DD	0c8H
$unwind$write_default_prologue DD 010401H
	DD	08204H
$unwind$pop_register DD 010901H
	DD	06209H
$unwind$write_win64_default_epilogue DD 010901H
	DD	0c209H
$unwind$write_default_epilogue DD 010401H
	DD	06204H
$unwind$write_userdef_epilogue DD 022219H
	DD	0a50110H
	DD	imagerel __GSHandlerCheck
	DD	0510H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
flags$ = 64
cnt$1 = 68
p$ = 72
info$ = 80
is_exitm$ = 88
i$ = 92
tv91 = 96
tv130 = 100
tv137 = 104
tv141 = 108
dir$ = 112
regs$ = 120
tv167 = 128
reglst$ = 144
buffer$ = 272
__$ArrayPad$ = 1296
flag_iret$ = 1328
tokenarray$ = 1336
write_userdef_epilogue PROC

; 3571 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 1320				; 00000528H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3572 :     uint_16 *regs;
; 3573 :     int i;
; 3574 :     char *p;
; 3575 :     bool is_exitm;
; 3576 :     struct proc_info   *info;
; 3577 :     int flags = CurrProc->sym.langtype; /* set bits 0-2 */

	mov	rax, QWORD PTR CurrProc
	mov	eax, DWORD PTR [rax+76]
	mov	DWORD PTR flags$[rsp], eax

; 3578 :     struct dsym *dir;
; 3579 :     char reglst[128];
; 3580 :     char buffer[MAX_LINE_LEN]; /* stores string for RunMacro() */
; 3581 : 
; 3582 :     dir = (struct dsym *)SymSearch( ModuleInfo.proc_epilogue );

	mov	rcx, QWORD PTR ModuleInfo+328
	call	SymFind
	mov	QWORD PTR dir$[rsp], rax

; 3583 :     if (dir == NULL ||
; 3584 :         dir->sym.state != SYM_MACRO ||

	cmp	QWORD PTR dir$[rsp], 0
	je	SHORT $LN6@write_user
	mov	rax, QWORD PTR dir$[rsp]
	cmp	DWORD PTR [rax+32], 9
	jne	SHORT $LN6@write_user
	mov	rax, QWORD PTR dir$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN5@write_user
$LN6@write_user:

; 3585 :         dir->sym.isfunc == TRUE ) {
; 3586 :         return( EmitErr( EPILOGUE_MUST_BE_MACRO_PROC, ModuleInfo.proc_epilogue ) );

	mov	rdx, QWORD PTR ModuleInfo+328
	mov	ecx, 157				; 0000009dH
	call	EmitErr
	jmp	$LN1@write_user
$LN5@write_user:

; 3587 :     }
; 3588 : 
; 3589 :     info = CurrProc->e.procinfo;

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR info$[rsp], rax

; 3590 : 
; 3591 : #if AMD64_SUPPORT
; 3592 :     /* to be compatible with ML64, translate FASTCALL to 0 (not 7) */
; 3593 :     if ( CurrProc->sym.langtype == LANG_FASTCALL && ModuleInfo.fctype == FCT_WIN64 )

	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+76], 7
	jne	SHORT $LN7@write_user
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN7@write_user

; 3594 :         flags = 0;

	mov	DWORD PTR flags$[rsp], 0
$LN7@write_user:

; 3595 : #endif
; 3596 :     if ( CurrProc->sym.langtype == LANG_C ||
; 3597 :          CurrProc->sym.langtype == LANG_SYSCALL ||

	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+76], 1
	je	SHORT $LN9@write_user
	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+76], 2
	je	SHORT $LN9@write_user
	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+76], 7
	jne	SHORT $LN8@write_user
$LN9@write_user:

; 3598 :          CurrProc->sym.langtype == LANG_FASTCALL)
; 3599 :         flags |= 0x10;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 16
	mov	DWORD PTR flags$[rsp], eax
$LN8@write_user:

; 3600 : 
; 3601 :     flags |= ( CurrProc->sym.mem_type == MT_FAR ? 0x20 : 0 );

	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN14@write_user
	mov	DWORD PTR tv91[rsp], 32			; 00000020H
	jmp	SHORT $LN15@write_user
$LN14@write_user:
	mov	DWORD PTR tv91[rsp], 0
$LN15@write_user:
	mov	eax, DWORD PTR tv91[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR flags$[rsp], eax

; 3602 :     flags |= ( CurrProc->sym.ispublic ? 0 : 0x40 );

	mov	rax, QWORD PTR CurrProc
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@write_user
	mov	DWORD PTR tv130[rsp], 0
	jmp	SHORT $LN17@write_user
$LN16@write_user:
	mov	DWORD PTR tv130[rsp], 64		; 00000040H
$LN17@write_user:
	mov	eax, DWORD PTR tv130[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR flags$[rsp], eax

; 3603 :     /* v2.11: set bit 7, the export flag */
; 3604 :     flags |= ( info->isexport ? 0x80 : 0 );

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@write_user
	mov	DWORD PTR tv137[rsp], 128		; 00000080H
	jmp	SHORT $LN19@write_user
$LN18@write_user:
	mov	DWORD PTR tv137[rsp], 0
$LN19@write_user:
	mov	eax, DWORD PTR tv137[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR flags$[rsp], eax

; 3605 :     flags |= flag_iret ? 0x100 : 0;  /* bit 8: 1 if IRET    */

	movzx	eax, BYTE PTR flag_iret$[rsp]
	test	eax, eax
	je	SHORT $LN20@write_user
	mov	DWORD PTR tv141[rsp], 256		; 00000100H
	jmp	SHORT $LN21@write_user
$LN20@write_user:
	mov	DWORD PTR tv141[rsp], 0
$LN21@write_user:
	mov	eax, DWORD PTR tv141[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR flags$[rsp], eax

; 3606 : 
; 3607 :     p = reglst;

	lea	rax, QWORD PTR reglst$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 3608 :     if ( info->regslist ) {

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN10@write_user

; 3609 :         int cnt = *info->regslist;

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR cnt$1[rsp], eax

; 3610 :         regs = info->regslist + cnt;

	movsxd	rax, DWORD PTR cnt$1[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR regs$[rsp], rax

; 3611 :         for ( ; cnt; regs--, cnt-- ) {

	jmp	SHORT $LN4@write_user
$LN2@write_user:
	mov	rax, QWORD PTR regs$[rsp]
	sub	rax, 2
	mov	QWORD PTR regs$[rsp], rax
	mov	eax, DWORD PTR cnt$1[rsp]
	dec	eax
	mov	DWORD PTR cnt$1[rsp], eax
$LN4@write_user:
	cmp	DWORD PTR cnt$1[rsp], 0
	je	SHORT $LN3@write_user

; 3612 :             GetResWName( *regs, p );

	mov	rax, QWORD PTR regs$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	rdx, QWORD PTR p$[rsp]
	mov	ecx, eax
	call	GetResWName

; 3613 :             p += strlen( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 3614 :             if ( cnt != 1 )

	cmp	DWORD PTR cnt$1[rsp], 1
	je	SHORT $LN11@write_user

; 3615 :                 *p++ = ',';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 44			; 0000002cH
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN11@write_user:

; 3616 :         }

	jmp	SHORT $LN2@write_user
$LN3@write_user:
$LN10@write_user:

; 3617 :     }
; 3618 :     *p = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 0

; 3619 :     //strcat( reglst, ">" );
; 3620 : 
; 3621 :     /* v2.07: make the numeric arguments more Masm-compatible */
; 3622 :     //sprintf( buffer,"%s %s, %02XH, %02XH, %02XH, <<%s>>, <%s>", ModuleInfo.proc_epilogue,
; 3623 :     sprintf( buffer,"%s, 0%XH, 0%XH, 0%XH, <<%s>>, <%s>",

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN22@write_user
	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv167[rsp], rax
	jmp	SHORT $LN23@write_user
$LN22@write_user:
	lea	rax, OFFSET FLAT:$SG12829
	mov	QWORD PTR tv167[rsp], rax
$LN23@write_user:
	mov	rax, QWORD PTR tv167[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR reglst$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR flags$[rsp]
	mov	rax, QWORD PTR CurrProc
	mov	r8, QWORD PTR [rax+8]
	lea	rdx, OFFSET FLAT:$SG12830
	lea	rcx, QWORD PTR buffer$[rsp]
	call	sprintf

; 3624 :             CurrProc->sym.name, flags, info->parasize, info->localsize,
; 3625 :             reglst, info->prologuearg ? info->prologuearg : "" );
; 3626 :     i = Token_Count + 1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 3627 :     Tokenize( buffer, i, tokenarray, TOK_RESCAN );

	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	Tokenize

; 3628 : 
; 3629 :     /* if -EP is on, emit "epilogue: none" */
; 3630 :     if ( Options.preprocessor_stdout )

	movzx	eax, BYTE PTR Options+141
	test	eax, eax
	je	SHORT $LN12@write_user

; 3631 :         printf( "option epilogue:none\n" );

	lea	rcx, OFFSET FLAT:$SG12832
	call	printf
$LN12@write_user:

; 3632 : 
; 3633 :     RunMacro( dir, i, tokenarray, NULL, 0, &is_exitm );

	lea	rax, QWORD PTR is_exitm$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	call	RunMacro

; 3634 :     Token_Count = i - 1;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR ModuleInfo+496, eax

; 3635 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@write_user:

; 3636 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1320				; 00000528H
	ret	0
write_userdef_epilogue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
resstack$ = 32
info$ = 40
write_default_epilogue PROC

; 3482 : {

	sub	rsp, 56					; 00000038H

; 3483 :     struct proc_info   *info;
; 3484 : #if AMD64_SUPPORT
; 3485 :     int resstack = 0;

	mov	DWORD PTR resstack$[rsp], 0

; 3486 : #endif
; 3487 : 
; 3488 :     info = CurrProc->e.procinfo;

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR info$[rsp], rax

; 3489 : 
; 3490 : #if AMD64_SUPPORT
; 3491 :     if ( info->isframe ) {

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@write_defa

; 3492 :         if ( ModuleInfo.frame_auto )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 17
	and	eax, 1
	test	eax, eax
	je	SHORT $LN3@write_defa

; 3493 :             write_win64_default_epilogue( info );

	mov	rcx, QWORD PTR info$[rsp]
	call	write_win64_default_epilogue
$LN3@write_defa:

; 3494 :         return;

	jmp	$LN1@write_defa
$LN2@write_defa:

; 3495 :     }
; 3496 :     if ( ModuleInfo.Ofssize == USE64 && ModuleInfo.fctype == FCT_WIN64 && ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) ) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	SHORT $LN4@write_defa
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN4@write_defa
	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 2
	test	eax, eax
	je	SHORT $LN4@write_defa

; 3497 :         resstack  = sym_ReservedStack->value;

	mov	rax, QWORD PTR sym_ReservedStack
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR resstack$[rsp], eax

; 3498 :         /* if no framepointer was pushed, add 8 to align stack on OWORD
; 3499 :          * v2.12: obsolete; localsize contains correct value.
; 3500 :          */
; 3501 :         //if( !(info->localsize || info->stackparam || info->has_vararg || info->forceframe ))
; 3502 :         //    AddLineQueueX( "add %r, 8 + %s", stackreg[ModuleInfo.Ofssize], sym_ReservedStack->name );
; 3503 :         //else
; 3504 :         AddLineQueueX( "add %r, %d + %s", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize, sym_ReservedStack->name );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	mov	rdx, QWORD PTR sym_ReservedStack
	mov	r9, QWORD PTR [rdx+8]
	mov	rdx, QWORD PTR info$[rsp]
	mov	r8d, DWORD PTR [rdx+36]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12783
	call	AddLineQueueX
$LN4@write_defa:

; 3505 :     }
; 3506 : #endif
; 3507 : 
; 3508 :     /* Pop the registers */
; 3509 :     pop_register( CurrProc->e.procinfo->regslist );

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR [rax]
	call	pop_register

; 3510 : 
; 3511 :     if ( info->loadds ) {

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@write_defa

; 3512 :         AddLineQueueX( "pop %r", T_DS );

	mov	edx, 28
	lea	rcx, OFFSET FLAT:$SG12785
	call	AddLineQueueX
$LN5@write_defa:

; 3513 :     }
; 3514 : 
; 3515 :     if( ( info->locallist == NULL ) &&
; 3516 :        info->stackparam == FALSE &&
; 3517 :        info->has_vararg == FALSE &&
; 3518 : #if AMD64_SUPPORT
; 3519 :        resstack == 0 &&

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN6@write_defa
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@write_defa
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@write_defa
	cmp	DWORD PTR resstack$[rsp], 0
	jne	SHORT $LN6@write_defa
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@write_defa

; 3520 : #endif
; 3521 :        info->forceframe == FALSE )
; 3522 :         return;

	jmp	$LN1@write_defa
$LN6@write_defa:

; 3523 : 
; 3524 :     /* restore registers e/sp and e/bp.
; 3525 :      * emit either "leave" or "mov e/sp,e/bp, pop e/bp".
; 3526 :      */
; 3527 : #if AMD64_SUPPORT
; 3528 :     if( !(info->locallist || info->stackparam || info->has_vararg || info->forceframe ))

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN7@write_defa
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@write_defa
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@write_defa
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@write_defa

; 3529 :         ;

	jmp	$LN8@write_defa
$LN7@write_defa:

; 3530 :     else
; 3531 : #endif
; 3532 :     if( info->pe_type ) {

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@write_defa

; 3533 :         AddLineQueue( "leave" );

	lea	rcx, OFFSET FLAT:$SG12791
	call	AddLineQueue

; 3534 :     } else  {

	jmp	$LN10@write_defa
$LN9@write_defa:

; 3535 : #if STACKBASESUPP
; 3536 :         if ( info->fpo ) {

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@write_defa

; 3537 : #if AMD64_SUPPORT
; 3538 :             if ( ModuleInfo.Ofssize == USE64 && ModuleInfo.fctype == FCT_WIN64 && ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) )

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	SHORT $LN12@write_defa
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN12@write_defa
	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 2
	test	eax, eax
	je	SHORT $LN12@write_defa

; 3539 :                 ;

	jmp	SHORT $LN13@write_defa
$LN12@write_defa:

; 3540 :             else
; 3541 : #endif
; 3542 :             if ( info->localsize )

	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+36], 0
	je	SHORT $LN14@write_defa

; 3543 :                 AddLineQueueX( "add %r, %d", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	mov	rdx, QWORD PTR info$[rsp]
	mov	r8d, DWORD PTR [rdx+36]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12796
	call	AddLineQueueX
$LN14@write_defa:
$LN13@write_defa:

; 3544 :             return;

	jmp	SHORT $LN1@write_defa
$LN11@write_defa:

; 3545 :         }
; 3546 : #endif
; 3547 :         /*
; 3548 :          MOV [E|R]SP, [E|R]BP
; 3549 :          POP [E|R]BP
; 3550 :          */
; 3551 :         if( info->localsize != 0 ) {

	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+36], 0
	je	SHORT $LN15@write_defa

; 3552 : #if STACKBASESUPP
; 3553 :             AddLineQueueX( "mov %r, %r", stackreg[ModuleInfo.Ofssize], info->basereg );

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+130]
	movzx	ecx, BYTE PTR ModuleInfo+404
	lea	rdx, OFFSET FLAT:stackreg
	mov	r8d, eax
	mov	edx, DWORD PTR [rdx+rcx*4]
	lea	rcx, OFFSET FLAT:$SG12798
	call	AddLineQueueX
$LN15@write_defa:

; 3554 : #else
; 3555 :             AddLineQueueX( "mov %r, %r", stackreg[ModuleInfo.Ofssize], basereg[ModuleInfo.Ofssize] );
; 3556 : #endif
; 3557 :         }
; 3558 : #if STACKBASESUPP
; 3559 :         AddLineQueueX( "pop %r", info->basereg );

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+130]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12799
	call	AddLineQueueX
$LN10@write_defa:
$LN8@write_defa:
$LN1@write_defa:

; 3560 : #else
; 3561 :         AddLineQueueX( "pop %r", basereg[ModuleInfo.Ofssize] );
; 3562 : #endif
; 3563 :     }
; 3564 : }

	add	rsp, 56					; 00000038H
	ret	0
write_default_epilogue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
i$1 = 48
regs$2 = 56
cnt$3 = 64
cnt$4 = 68
regist$5 = 72
stackSize$6 = 80
gprzize$7 = 84
anysize$ = 88
i$8 = 92
info$ = 112
write_win64_default_epilogue PROC

; 3308 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 3309 :   int anysize;
; 3310 : #if STACKBASESUPP
; 3311 :     /* v2.12: obsolete */
; 3312 :     //if ( GetRegNo( info->basereg ) == 4 || ( info->parasize == 0 && info->locallist == NULL ) )
; 3313 :     //    sizestd = 8;
; 3314 : #endif
; 3315 :     /* restore non-volatile xmm registers */
; 3316 :     if ( info->regslist ) {

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN11@write_win6

; 3317 :         uint_16 *regs;
; 3318 :         int cnt;
; 3319 :         int i;
; 3320 :         
; 3321 : 
; 3322 :         /* v2.12: space for xmm saves is now included in localsize
; 3323 :          * so first thing to do is to count the xmm regs that were saved
; 3324 :          */
; 3325 :         for( regs = info->regslist, cnt = *regs++, i = 0; cnt; cnt--, regs++ )

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR regs$2[rsp], rax
	mov	rax, QWORD PTR regs$2[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR cnt$3[rsp], eax
	mov	rax, QWORD PTR regs$2[rsp]
	add	rax, 2
	mov	QWORD PTR regs$2[rsp], rax
	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@write_win6
$LN2@write_win6:
	mov	eax, DWORD PTR cnt$3[rsp]
	dec	eax
	mov	DWORD PTR cnt$3[rsp], eax
	mov	rax, QWORD PTR regs$2[rsp]
	add	rax, 2
	mov	QWORD PTR regs$2[rsp], rax
$LN4@write_win6:
	cmp	DWORD PTR cnt$3[rsp], 0
	je	SHORT $LN3@write_win6

; 3326 :                 if (( GetValueSp( *regs ) & OP_XMM )||( GetValueSp( *regs ) & OP_YMM )

	mov	rax, QWORD PTR regs$2[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN13@write_win6
	mov	rax, QWORD PTR regs$2[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN12@write_win6
$LN13@write_win6:

; 3327 : #if EVEXSUPP    
; 3328 :                   || ( GetValueSp( *regs ) & OP_ZMM )
; 3329 : #endif
; 3330 :                 )i++;

	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN12@write_win6:
	jmp	SHORT $LN2@write_win6
$LN3@write_win6:

; 3331 : 
; 3332 :         DebugMsg1(("write_win64_default_epilogue(%s): %u xmm registers to restore\n", CurrProc->sym.name , i ));

	mov	r8d, DWORD PTR i$1[rsp]
	mov	rax, QWORD PTR CurrProc
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12740
	call	DoDebugMsg1

; 3333 : 
; 3334 :         if ( i ) {

	cmp	DWORD PTR i$1[rsp], 0
	je	$LN14@write_win6

; 3335 :             if (info->locallist)

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN15@write_win6

; 3336 :               i = (info->localsize - i * XYZMMsize) & ~(16 - 1);

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, DWORD PTR XYZMMsize
	mov	rcx, QWORD PTR info$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	sub	ecx, eax
	mov	eax, ecx
	and	eax, -16				; fffffff0H
	mov	DWORD PTR i$1[rsp], eax
	jmp	SHORT $LN16@write_win6
$LN15@write_win6:

; 3337 :             else
; 3338 :             i = ( info->localsize) & ~(16-1);

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, -16				; fffffff0H
	mov	DWORD PTR i$1[rsp], eax
$LN16@write_win6:

; 3339 :             for( regs = info->regslist, cnt = *regs++; cnt; cnt--, regs++ ) {

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR regs$2[rsp], rax
	mov	rax, QWORD PTR regs$2[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR cnt$3[rsp], eax
	mov	rax, QWORD PTR regs$2[rsp]
	add	rax, 2
	mov	QWORD PTR regs$2[rsp], rax
	jmp	SHORT $LN7@write_win6
$LN5@write_win6:
	mov	eax, DWORD PTR cnt$3[rsp]
	dec	eax
	mov	DWORD PTR cnt$3[rsp], eax
	mov	rax, QWORD PTR regs$2[rsp]
	add	rax, 2
	mov	QWORD PTR regs$2[rsp], rax
$LN7@write_win6:
	cmp	DWORD PTR cnt$3[rsp], 0
	je	$LN6@write_win6

; 3340 :                 if (( GetValueSp( *regs ) & OP_XMM )||( GetValueSp( *regs ) & OP_YMM )

	mov	rax, QWORD PTR regs$2[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN18@write_win6
	mov	rax, QWORD PTR regs$2[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	$LN17@write_win6
$LN18@write_win6:

; 3341 : #if EVEXSUPP    
; 3342 :                   || ( GetValueSp( *regs ) & OP_ZMM )
; 3343 : #endif
; 3344 :                 ){
; 3345 :                     DebugMsg1(("write_win64_default_epilogue(%s): restore %s, offset=%d\n", CurrProc->sym.name , GetResWName( *regs, NULL ), i ));

	mov	rax, QWORD PTR regs$2[rsp]
	movzx	eax, WORD PTR [rax]
	xor	edx, edx
	mov	ecx, eax
	call	GetResWName
	mov	r9d, DWORD PTR i$1[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR CurrProc
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12746
	call	DoDebugMsg1

; 3346 :                     //AddLineQueueX( "movdqa %r, [%r+%u]", *regist, stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize + sizexmm );
; 3347 :                     /* v2.11: use @ReservedStack only if option win64:2 is set */
; 3348 :                     if (ModuleInfo.win64_flags & W64F_AUTOSTACKSP){

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 2
	test	eax, eax
	je	SHORT $LN19@write_win6

; 3349 :                         AddLineQueueX("vmovdqu %r, [%r + %u + %s]", *regs, stackreg[ModuleInfo.Ofssize], NUMQUAL i, sym_ReservedStack->name);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	mov	rdx, QWORD PTR regs$2[rsp]
	movzx	edx, WORD PTR [rdx]
	mov	r8, QWORD PTR sym_ReservedStack
	mov	r8, QWORD PTR [r8+8]
	mov	QWORD PTR [rsp+32], r8
	mov	r9d, DWORD PTR i$1[rsp]
	mov	r8d, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12749
	call	AddLineQueueX

; 3350 :                     }

	jmp	SHORT $LN20@write_win6
$LN19@write_win6:

; 3351 :                     else{
; 3352 :                         AddLineQueueX("vmovdqu %r, [%r + %u]", *regs, stackreg[ModuleInfo.Ofssize], NUMQUAL i );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	mov	rdx, QWORD PTR regs$2[rsp]
	movzx	edx, WORD PTR [rdx]
	mov	r9d, DWORD PTR i$1[rsp]
	mov	r8d, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12750
	call	AddLineQueueX
$LN20@write_win6:

; 3353 :                     }
; 3354 :                     i += XYZMMsize;

	mov	eax, DWORD PTR XYZMMsize
	mov	ecx, DWORD PTR i$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$1[rsp], eax
$LN17@write_win6:

; 3355 :                 }
; 3356 :             }

	jmp	$LN5@write_win6
$LN6@write_win6:
$LN14@write_win6:
$LN11@write_win6:

; 3357 :         }
; 3358 :     }
; 3359 : 
; 3360 :     if (ModuleInfo.fctype == FCT_WIN64 && (ModuleInfo.win64_flags & W64F_AUTOSTACKSP)){

	cmp	DWORD PTR ModuleInfo+376, 2
	jne	$LN21@write_win6
	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 2
	test	eax, eax
	je	$LN21@write_win6

; 3361 :       if (ModuleInfo.win64_flags & W64F_HABRAN){

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	je	$LN23@write_win6

; 3362 :         anysize = info->localsize + sym_ReservedStack->value + info->xmmsize;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	rcx, QWORD PTR sym_ReservedStack
	add	eax, DWORD PTR [rcx+16]
	mov	rcx, QWORD PTR info$[rsp]
	add	eax, DWORD PTR [rcx+112]
	mov	DWORD PTR anysize$[rsp], eax

; 3363 :         if (info->vecused) anysize += info->vsize;

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+80]
	test	eax, eax
	je	SHORT $LN25@write_win6
	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+44]
	mov	ecx, DWORD PTR anysize$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR anysize$[rsp], eax
$LN25@write_win6:

; 3364 : 		if (anysize)

	cmp	DWORD PTR anysize$[rsp], 0
	je	SHORT $LN26@write_win6

; 3365 : 		{
; 3366 : 			int stackSize = info->localsize + info->vsize + info->xmmsize;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	rcx, QWORD PTR info$[rsp]
	add	eax, DWORD PTR [rcx+44]
	mov	rcx, QWORD PTR info$[rsp]
	add	eax, DWORD PTR [rcx+112]
	mov	DWORD PTR stackSize$6[rsp], eax

; 3367 : 			if ((stackSize & 7) != 0) stackSize = (stackSize + 7)&(-8);

	mov	eax, DWORD PTR stackSize$6[rsp]
	and	eax, 7
	test	eax, eax
	je	SHORT $LN27@write_win6
	mov	eax, DWORD PTR stackSize$6[rsp]
	add	eax, 7
	and	eax, -8
	mov	DWORD PTR stackSize$6[rsp], eax
$LN27@write_win6:

; 3368 : 			AddLineQueueX("add %r, %d + %s", stackreg[ModuleInfo.Ofssize], NUMQUAL stackSize, sym_ReservedStack->name);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	mov	rdx, QWORD PTR sym_ReservedStack
	mov	r9, QWORD PTR [rdx+8]
	mov	r8d, DWORD PTR stackSize$6[rsp]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12758
	call	AddLineQueueX
$LN26@write_win6:

; 3369 : 		}
; 3370 :       }

	jmp	SHORT $LN24@write_win6
$LN23@write_win6:

; 3371 :         else
; 3372 :           AddLineQueueX("add %r, %d + %s", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize + info->xmmsize, sym_ReservedStack->name);

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	rcx, QWORD PTR info$[rsp]
	add	eax, DWORD PTR [rcx+112]
	movzx	ecx, BYTE PTR ModuleInfo+404
	lea	rdx, OFFSET FLAT:stackreg
	mov	r8, QWORD PTR sym_ReservedStack
	mov	r9, QWORD PTR [r8+8]
	mov	r8d, eax
	mov	edx, DWORD PTR [rdx+rcx*4]
	lea	rcx, OFFSET FLAT:$SG12759
	call	AddLineQueueX
$LN24@write_win6:

; 3373 :     }

	jmp	SHORT $LN22@write_win6
$LN21@write_win6:

; 3374 :     else
; 3375 :         AddLineQueueX( "add %r, %d", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	mov	rdx, QWORD PTR info$[rsp]
	mov	r8d, DWORD PTR [rdx+36]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12760
	call	AddLineQueueX
$LN22@write_win6:

; 3376 :     pop_register( CurrProc->e.procinfo->regslist );

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR [rax]
	call	pop_register

; 3377 : #if STACKBASESUPP
; 3378 :     if (ModuleInfo.win64_flags & W64F_HABRAN){

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	je	$LN28@write_win6

; 3379 :       /* restore non-volatile registers from shadow space */
; 3380 :       if (info->regslist) {

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN29@write_win6

; 3381 :         uint_16 *regist = info->regslist;

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR regist$5[rsp], rax

; 3382 :         int cnt;
; 3383 :         if (ModuleInfo.win64_flags){

	movzx	eax, BYTE PTR ModuleInfo+413
	test	eax, eax
	je	$LN30@write_win6

; 3384 :           int i = 0;

	mov	DWORD PTR i$8[rsp], 0

; 3385 :           int gprzize = 0;

	mov	DWORD PTR gprzize$7[rsp], 0

; 3386 :           for (cnt = *regist++; cnt; cnt--, regist++)

	mov	rax, QWORD PTR regist$5[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR cnt$4[rsp], eax
	mov	rax, QWORD PTR regist$5[rsp]
	add	rax, 2
	mov	QWORD PTR regist$5[rsp], rax
	jmp	SHORT $LN10@write_win6
$LN8@write_win6:
	mov	eax, DWORD PTR cnt$4[rsp]
	dec	eax
	mov	DWORD PTR cnt$4[rsp], eax
	mov	rax, QWORD PTR regist$5[rsp]
	add	rax, 2
	mov	QWORD PTR regist$5[rsp], rax
$LN10@write_win6:
	cmp	DWORD PTR cnt$4[rsp], 0
	je	$LN9@write_win6

; 3387 :           {
; 3388 :                 if (( GetValueSp( *regist ) & OP_XMM )||( GetValueSp( *regist ) & OP_YMM )

	mov	rax, QWORD PTR regist$5[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN33@write_win6
	mov	rax, QWORD PTR regist$5[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN31@write_win6
$LN33@write_win6:

; 3389 : #if EVEXSUPP    
; 3390 :                   || ( GetValueSp( *regist ) & OP_ZMM )
; 3391 : #endif
; 3392 :                 ) continue;

	jmp	SHORT $LN8@write_win6
	jmp	SHORT $LN32@write_win6
$LN31@write_win6:

; 3393 :             else {
; 3394 :               gprzize += 8;

	mov	eax, DWORD PTR gprzize$7[rsp]
	add	eax, 8
	mov	DWORD PTR gprzize$7[rsp], eax

; 3395 :               if (gprzize <= 0x20)

	cmp	DWORD PTR gprzize$7[rsp], 32		; 00000020H
	jg	SHORT $LN34@write_win6

; 3396 :               {
; 3397 :                 if (info->home_used[i] == 0){

	movsxd	rax, DWORD PTR i$8[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+116]
	test	eax, eax
	jne	SHORT $LN35@write_win6

; 3398 :                   AddLineQueueX("mov %r, [%r+%u]", *regist, stackreg[ModuleInfo.Ofssize], NUMQUAL gprzize);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	mov	rdx, QWORD PTR regist$5[rsp]
	movzx	edx, WORD PTR [rdx]
	mov	r9d, DWORD PTR gprzize$7[rsp]
	mov	r8d, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12770
	call	AddLineQueueX

; 3399 :                 }

	jmp	SHORT $LN36@write_win6
$LN35@write_win6:

; 3400 :                 else {
; 3401 :                   cnt++; regist--;

	mov	eax, DWORD PTR cnt$4[rsp]
	inc	eax
	mov	DWORD PTR cnt$4[rsp], eax
	mov	rax, QWORD PTR regist$5[rsp]
	sub	rax, 2
	mov	QWORD PTR regist$5[rsp], rax
$LN36@write_win6:

; 3402 :                 }
; 3403 :                 i++;

	mov	eax, DWORD PTR i$8[rsp]
	inc	eax
	mov	DWORD PTR i$8[rsp], eax
$LN34@write_win6:
$LN32@write_win6:

; 3404 :               }
; 3405 :             }
; 3406 :           }

	jmp	$LN8@write_win6
$LN9@write_win6:
$LN30@write_win6:
$LN29@write_win6:
$LN28@write_win6:

; 3407 :         }
; 3408 :       }
; 3409 :     }
; 3410 :     //if ( !info->fpo )
; 3411 :     if ( GetRegNo( info->basereg ) != 4 && ( info->parasize != 0 || info->locallist != NULL ) )

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+130]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	cmp	eax, 4
	je	SHORT $LN37@write_win6
	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN38@write_win6
	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN37@write_win6
$LN38@write_win6:

; 3412 :         AddLineQueueX( "pop %r", info->basereg );

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+130]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12773
	call	AddLineQueueX
$LN37@write_win6:

; 3413 : #else
; 3414 :     AddLineQueueX( "pop %r", basereg[ModuleInfo.Ofssize] );
; 3415 : #endif
; 3416 : 
; 3417 :     return;
; 3418 : }

	add	rsp, 104				; 00000068H
	ret	0
write_win64_default_epilogue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
cnt$ = 32
regist$ = 64
pop_register PROC

; 3265 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3266 :     int cnt;
; 3267 :     if( regist == NULL )

	cmp	QWORD PTR regist$[rsp], 0
	jne	SHORT $LN8@pop_regist

; 3268 :         return;

	jmp	$LN1@pop_regist
$LN8@pop_regist:

; 3269 :     cnt = *regist;

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR cnt$[rsp], eax

; 3270 :     regist += cnt;

	movsxd	rax, DWORD PTR cnt$[rsp]
	mov	rcx, QWORD PTR regist$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR regist$[rsp], rax

; 3271 :     if (ModuleInfo.win64_flags & W64F_HABRAN)

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	je	$LN9@pop_regist

; 3272 :     {
; 3273 :       for (cnt = CurrProc->e.procinfo->pushed_reg; cnt; cnt--, regist--) {

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+104]
	mov	DWORD PTR cnt$[rsp], eax
	jmp	SHORT $LN4@pop_regist
$LN2@pop_regist:
	mov	eax, DWORD PTR cnt$[rsp]
	dec	eax
	mov	DWORD PTR cnt$[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	sub	rax, 2
	mov	QWORD PTR regist$[rsp], rax
$LN4@pop_regist:
	cmp	DWORD PTR cnt$[rsp], 0
	je	SHORT $LN3@pop_regist

; 3274 :         /* don't "pop" xmm registers */
; 3275 :                 if (( GetValueSp( *regist ) & OP_XMM )||( GetValueSp( *regist ) & OP_YMM )

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN12@pop_regist
	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN11@pop_regist
$LN12@pop_regist:

; 3276 : #if EVEXSUPP    
; 3277 :                   || ( GetValueSp( *regist ) & OP_ZMM )
; 3278 : #endif
; 3279 :                 )
; 3280 : {
; 3281 :           cnt++;

	mov	eax, DWORD PTR cnt$[rsp]
	inc	eax
	mov	DWORD PTR cnt$[rsp], eax

; 3282 :           continue;

	jmp	SHORT $LN2@pop_regist
$LN11@pop_regist:

; 3283 :         }
; 3284 :         AddLineQueueX("pop %r", *regist);

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12709
	call	AddLineQueueX

; 3285 :       }

	jmp	SHORT $LN2@pop_regist
$LN3@pop_regist:

; 3286 :     }

	jmp	SHORT $LN10@pop_regist
$LN9@pop_regist:

; 3287 :     else {
; 3288 :       for (; cnt; cnt--, regist--) {

	jmp	SHORT $LN7@pop_regist
$LN5@pop_regist:
	mov	eax, DWORD PTR cnt$[rsp]
	dec	eax
	mov	DWORD PTR cnt$[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	sub	rax, 2
	mov	QWORD PTR regist$[rsp], rax
$LN7@pop_regist:
	cmp	DWORD PTR cnt$[rsp], 0
	je	SHORT $LN6@pop_regist

; 3289 :         /* don't "pop" xmm registers */
; 3290 :                 if (( GetValueSp( *regist ) & OP_XMM )||( GetValueSp( *regist ) & OP_YMM )

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN14@pop_regist
	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN13@pop_regist
$LN14@pop_regist:

; 3291 : #if EVEXSUPP    
; 3292 :                   || ( GetValueSp( *regist ) & OP_ZMM )
; 3293 : #endif
; 3294 :                 )continue;

	jmp	SHORT $LN5@pop_regist
$LN13@pop_regist:

; 3295 :         AddLineQueueX("pop %r", *regist);

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12712
	call	AddLineQueueX

; 3296 :       }

	jmp	SHORT $LN5@pop_regist
$LN6@pop_regist:
$LN10@pop_regist:
$LN1@pop_regist:

; 3297 :     }
; 3298 : 
; 3299 : }

	add	rsp, 56					; 00000038H
	ret	0
pop_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
oldlinenumbers$ = 32
cnt$ = 36
resstack$ = 40
tv226 = 44
info$ = 48
regist$ = 56
write_default_prologue PROC

; 2891 : {

	sub	rsp, 72					; 00000048H

; 2892 :     struct proc_info    *info;
; 2893 :     uint_16             *regist;
; 2894 :     uint_8              oldlinenumbers;
; 2895 :     int                 cnt;
; 2896 : #if AMD64_SUPPORT
; 2897 :     int                 resstack = 0;

	mov	DWORD PTR resstack$[rsp], 0

; 2898 : #endif
; 2899 : 
; 2900 :     info = CurrProc->e.procinfo;

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR info$[rsp], rax

; 2901 : 
; 2902 : #if AMD64_SUPPORT
; 2903 :     if ( info->isframe ) {

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@write_defa

; 2904 :         //DebugMsg(("write_default_prologue: isframe\n"));
; 2905 :         if ( ModuleInfo.frame_auto ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 17
	and	eax, 1
	test	eax, eax
	je	SHORT $LN9@write_defa

; 2906 :             write_win64_default_prologue( info );

	mov	rcx, QWORD PTR info$[rsp]
	call	write_win64_default_prologue

; 2907 :             /* v2.11: line queue is now run here */
; 2908 :             goto runqueue;

	jmp	$runqueue$32
$LN9@write_defa:

; 2909 :         }
; 2910 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@write_defa
$LN8@write_defa:

; 2911 :     }
; 2912 :     if ( ModuleInfo.Ofssize == USE64 && ModuleInfo.fctype == FCT_WIN64 && ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) )

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	SHORT $LN10@write_defa
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN10@write_defa
	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 2
	test	eax, eax
	je	SHORT $LN10@write_defa

; 2913 :         resstack = sym_ReservedStack->value;

	mov	rax, QWORD PTR sym_ReservedStack
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR resstack$[rsp], eax
$LN10@write_defa:

; 2914 : #endif
; 2915 :     /* default processing. if no params/locals are defined, continue */
; 2916 :     if( info->forceframe == FALSE &&
; 2917 :        info->localsize == 0 &&
; 2918 :        info->stackparam == FALSE &&
; 2919 :        info->has_vararg == FALSE &&
; 2920 : #if AMD64_SUPPORT
; 2921 :        resstack == 0 &&

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@write_defa
	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+36], 0
	jne	SHORT $LN11@write_defa
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@write_defa
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@write_defa
	cmp	DWORD PTR resstack$[rsp], 0
	jne	SHORT $LN11@write_defa
	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN11@write_defa

; 2922 : #endif
; 2923 :        info->regslist == NULL )
; 2924 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@write_defa
$LN11@write_defa:

; 2925 : 
; 2926 :     /* v2.11: now done in write_prologue() */
; 2927 :     //info->localsize = ROUND_UP( info->localsize, CurrWordSize );
; 2928 :     regist = info->regslist;

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR regist$[rsp], rax

; 2929 : 
; 2930 : #if AMD64_SUPPORT
; 2931 :     /* initialize shadow space for register params */
; 2932 :     if ( ModuleInfo.Ofssize == USE64 &&
; 2933 :         CurrProc->sym.langtype == LANG_FASTCALL &&
; 2934 :         ModuleInfo.fctype == FCT_WIN64 &&

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	SHORT $LN12@write_defa
	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+76], 7
	jne	SHORT $LN12@write_defa
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN12@write_defa
	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 1
	test	eax, eax
	je	SHORT $LN12@write_defa

; 2935 :         ( ModuleInfo.win64_flags & W64F_SAVEREGPARAMS ) )
; 2936 :         win64_SaveRegParams( info );

	mov	rcx, QWORD PTR info$[rsp]
	call	win64_SaveRegParams
$LN12@write_defa:

; 2937 : #endif
; 2938 :     if( info->locallist || info->stackparam || info->has_vararg || info->forceframe ) {

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN14@write_defa
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@write_defa
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@write_defa
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@write_defa
$LN14@write_defa:

; 2939 : 
; 2940 :         /* write 80386 prolog code
; 2941 :          * PUSH [E|R]BP
; 2942 :          * MOV  [E|R]BP, [E|R]SP
; 2943 :          * SUB  [E|R]SP, localsize
; 2944 :          */
; 2945 : #if STACKBASESUPP
; 2946 :         if ( !info->fpo ) {

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN15@write_defa

; 2947 :             AddLineQueueX( "push %r", info->basereg );

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+130]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12573
	call	AddLineQueueX

; 2948 :             AddLineQueueX( "mov %r, %r", info->basereg, stackreg[ModuleInfo.Ofssize] );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	mov	rdx, QWORD PTR info$[rsp]
	movzx	edx, WORD PTR [rdx+130]
	mov	r8d, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12574
	call	AddLineQueueX
$LN15@write_defa:
$LN13@write_defa:

; 2949 :         }
; 2950 : #else
; 2951 :         AddLineQueueX( "push %r", basereg[ModuleInfo.Ofssize] );
; 2952 :         AddLineQueueX( "mov %r, %r", basereg[ModuleInfo.Ofssize], stackreg[ModuleInfo.Ofssize] );
; 2953 : #endif
; 2954 :     }
; 2955 : #if AMD64_SUPPORT
; 2956 :     if( resstack ) {

	cmp	DWORD PTR resstack$[rsp], 0
	je	$LN16@write_defa

; 2957 :         /* in this case, push the USES registers BEFORE the stack space is reserved */
; 2958 :         if ( regist ) {

	cmp	QWORD PTR regist$[rsp], 0
	je	SHORT $LN18@write_defa

; 2959 :             for( cnt = *regist++; cnt; cnt--, regist++ )

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR cnt$[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax
	jmp	SHORT $LN4@write_defa
$LN2@write_defa:
	mov	eax, DWORD PTR cnt$[rsp]
	dec	eax
	mov	DWORD PTR cnt$[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax
$LN4@write_defa:
	cmp	DWORD PTR cnt$[rsp], 0
	je	SHORT $LN3@write_defa

; 2960 :                 AddLineQueueX( "push %r", *regist );

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12578
	call	AddLineQueueX
	jmp	SHORT $LN2@write_defa
$LN3@write_defa:

; 2961 :             regist = NULL;

	mov	QWORD PTR regist$[rsp], 0
$LN18@write_defa:

; 2962 :         }
; 2963 :         /* if no framepointer was pushed, add 8 to align stack on OWORD.
; 2964 :          * v2.12: obsolete, localsize contains correct value in this case.
; 2965 :          */
; 2966 :         //if( !(info->localsize || info->stackparam || info->has_vararg || info->forceframe ))
; 2967 :         //    AddLineQueueX( "sub %r, 8 + %s", stackreg[ModuleInfo.Ofssize], sym_ReservedStack->name );
; 2968 :         //else
; 2969 :         AddLineQueueX( "sub %r, %d + %s", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize, sym_ReservedStack->name );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	mov	rdx, QWORD PTR sym_ReservedStack
	mov	r9, QWORD PTR [rdx+8]
	mov	rdx, QWORD PTR info$[rsp]
	mov	r8d, DWORD PTR [rdx+36]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12579
	call	AddLineQueueX

; 2970 :     } else

	jmp	SHORT $LN17@write_defa
$LN16@write_defa:

; 2971 : #endif
; 2972 :     if( info->localsize  ) {

	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+36], 0
	je	SHORT $LN19@write_defa

; 2973 :         /* using ADD and the 2-complement has one advantage:
; 2974 :          * it will generate short instructions up to a size of 128.
; 2975 :          * with SUB, short instructions work up to 127 only.
; 2976 :          */
; 2977 :         if ( Options.masm_compat_gencode || info->localsize == 128 )

	movzx	eax, BYTE PTR Options+144
	test	eax, eax
	jne	SHORT $LN22@write_defa
	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+36], 128			; 00000080H
	jne	SHORT $LN20@write_defa
$LN22@write_defa:

; 2978 :             AddLineQueueX( "add %r, %d", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	mov	rdx, QWORD PTR info$[rsp]
	mov	r8d, DWORD PTR [rdx+36]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12584
	call	AddLineQueueX
	jmp	SHORT $LN21@write_defa
$LN20@write_defa:

; 2979 :         else
; 2980 :             AddLineQueueX( "sub %r, %d", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	mov	rdx, QWORD PTR info$[rsp]
	mov	r8d, DWORD PTR [rdx+36]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12585
	call	AddLineQueueX
$LN21@write_defa:
$LN19@write_defa:
$LN17@write_defa:

; 2981 :     }
; 2982 : 
; 2983 :     if ( info->loadds ) {

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@write_defa

; 2984 :         AddLineQueueX( "push %r", T_DS );

	mov	edx, 28
	lea	rcx, OFFSET FLAT:$SG12587
	call	AddLineQueueX

; 2985 :         AddLineQueueX( "mov %r, %s", T_AX, szDgroup );

	lea	r8, OFFSET FLAT:szDgroup
	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12588
	call	AddLineQueueX

; 2986 :         AddLineQueueX( "mov %r, %r", T_DS, ModuleInfo.Ofssize ? T_EAX : T_AX );

	movzx	eax, BYTE PTR ModuleInfo+404
	test	eax, eax
	je	SHORT $LN30@write_defa
	mov	DWORD PTR tv226[rsp], 17
	jmp	SHORT $LN31@write_defa
$LN30@write_defa:
	mov	DWORD PTR tv226[rsp], 9
$LN31@write_defa:
	mov	r8d, DWORD PTR tv226[rsp]
	mov	edx, 28
	lea	rcx, OFFSET FLAT:$SG12589
	call	AddLineQueueX
$LN23@write_defa:

; 2987 :     }
; 2988 : 
; 2989 :     /* Push the GPR registers of the USES clause */
; 2990 :     if ( regist ) {

	cmp	QWORD PTR regist$[rsp], 0
	je	SHORT $LN24@write_defa

; 2991 :         for( cnt = *regist++; cnt; cnt--, regist++ ) {

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR cnt$[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax
	jmp	SHORT $LN7@write_defa
$LN5@write_defa:
	mov	eax, DWORD PTR cnt$[rsp]
	dec	eax
	mov	DWORD PTR cnt$[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax
$LN7@write_defa:
	cmp	DWORD PTR cnt$[rsp], 0
	je	SHORT $LN6@write_defa

; 2992 :             AddLineQueueX( "push %r", *regist );

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12591
	call	AddLineQueueX

; 2993 :         }

	jmp	SHORT $LN5@write_defa
$LN6@write_defa:
$LN24@write_defa:
$runqueue$32:

; 2994 :     }
; 2995 : 
; 2996 : #if AMD64_SUPPORT
; 2997 : runqueue:
; 2998 : #endif
; 2999 : 
; 3000 : #if FASTPASS
; 3001 :     /* special case: generated code runs BEFORE the line.*/
; 3002 :     if ( ModuleInfo.list && UseSavedState )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN25@write_defa
	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	je	SHORT $LN25@write_defa

; 3003 :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN26@write_defa

; 3004 :             info->prolog_list_pos = list_pos;

	mov	rax, QWORD PTR info$[rsp]
	mov	ecx, DWORD PTR list_pos
	mov	DWORD PTR [rax+124], ecx
	jmp	SHORT $LN27@write_defa
$LN26@write_defa:

; 3005 :         else
; 3006 :             list_pos = info->prolog_list_pos;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+124]
	mov	DWORD PTR list_pos, eax
$LN27@write_defa:
$LN25@write_defa:

; 3007 : #endif
; 3008 :     /* line number debug info also needs special treatment
; 3009 :      * because current line number is the first true src line
; 3010 :      * IN the proc.
; 3011 :      */
; 3012 :     oldlinenumbers = Options.line_numbers;

	movzx	eax, BYTE PTR Options+1
	mov	BYTE PTR oldlinenumbers$[rsp], al

; 3013 :     Options.line_numbers = FALSE; /* temporarily disable line numbers */

	mov	BYTE PTR Options+1, 0

; 3014 :     RunLineQueue();

	call	RunLineQueue

; 3015 :     Options.line_numbers = oldlinenumbers;

	movzx	eax, BYTE PTR oldlinenumbers$[rsp]
	mov	BYTE PTR Options+1, al

; 3016 : 
; 3017 : #if FASTPASS
; 3018 :     if ( ModuleInfo.list && UseSavedState && (Parse_Pass > PASS_1))

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN28@write_defa
	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	je	SHORT $LN28@write_defa
	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN28@write_defa

; 3019 :          LineStoreCurr->list_pos = list_pos;

	mov	rax, QWORD PTR LineStoreCurr
	mov	ecx, DWORD PTR list_pos
	mov	DWORD PTR [rax+12], ecx
$LN28@write_defa:

; 3020 : #endif
; 3021 : 
; 3022 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@write_defa:

; 3023 : }

	add	rsp, 72					; 00000048H
	ret	0
write_default_prologue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
xreg$ = 48
i$ = 52
xsize$ = 56
n$ = 60
j$ = 64
regist$ = 72
vsize$ = 80
ymmflag$ = 84
stackSize$ = 88
cntxmm$ = 92
vectstart$ = 96
resstack$ = 100
j$1 = 104
m$ = 108
tv679 = 112
pp$2 = 120
xmmflag$ = 128
cnt$ = 132
cnt$3 = 136
cnt$4 = 140
tv68 = 144
tv871 = 148
tv891 = 152
tv964 = 156
tv987 = 160
tv288 = 168
ppfmt$ = 176
$T5 = 184
xyused$ = 192
__$ArrayPad$ = 200
info$ = 224
write_win64_default_prologue PROC

; 2467 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 216				; 000000d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2468 :     uint_16             *regist;
; 2469 :     const char * const  *ppfmt;
; 2470 :     struct    dsym      *param;
; 2471 :     int                 cntxmm;
; 2472 :     unsigned char xyused[6];  /* flags for used sse registers in vectorcall */
; 2473 :     unsigned char       xreg;
; 2474 :     unsigned char       xsize;
; 2475 :     unsigned char       xmmflag = 1;

	mov	BYTE PTR xmmflag$[rsp], 1

; 2476 :     unsigned char       ymmflag = 0;

	mov	BYTE PTR ymmflag$[rsp], 0

; 2477 : #if EVEXSUPP
; 2478 :     unsigned char       zmmflag = 0;
; 2479 : #endif
; 2480 :     int                 vsize = 0;

	mov	DWORD PTR vsize$[rsp], 0

; 2481 :     int                 vectstart = 0;

	mov	DWORD PTR vectstart$[rsp], 0

; 2482 :     int                 n;
; 2483 :     int                 m;
; 2484 :     int                 i;
; 2485 :     int                 j;
; 2486 :     int                 cnt;
; 2487 :     int                 homestart;
; 2488 :     int                 stackSize;
; 2489 :     int                 resstack = ( ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) ? sym_ReservedStack->value : 0 );

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 2
	test	eax, eax
	je	SHORT $LN131@write_win6
	mov	rax, QWORD PTR sym_ReservedStack
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv68[rsp], eax
	jmp	SHORT $LN132@write_win6
$LN131@write_win6:
	mov	DWORD PTR tv68[rsp], 0
$LN132@write_win6:
	mov	eax, DWORD PTR tv68[rsp]
	mov	DWORD PTR resstack$[rsp], eax

; 2490 : 
; 2491 :     DebugMsg1(("write_win64_default_prologue enter\n"));

	lea	rcx, OFFSET FLAT:$SG12421
	call	DoDebugMsg1

; 2492 :     memset(xyused, 0, 6);

	mov	r8d, 6
	xor	edx, edx
	lea	rcx, QWORD PTR xyused$[rsp]
	call	memset

; 2493 :     info->vecused = 0;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+80], 0

; 2494 :     XYZMMsize = 16;

	mov	DWORD PTR XYZMMsize, 16

; 2495 :     if ( ModuleInfo.win64_flags & W64F_SAVEREGPARAMS )

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 1
	test	eax, eax
	je	SHORT $LN45@write_win6

; 2496 :         win64_SaveRegParams( info );

	mov	rcx, QWORD PTR info$[rsp]
	call	win64_SaveRegParams
$LN45@write_win6:

; 2497 :     if (ModuleInfo.win64_flags & W64F_HABRAN) 

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	je	SHORT $LN46@write_win6

; 2498 :       win64_StoreRegHome(info);

	mov	rcx, QWORD PTR info$[rsp]
	call	win64_StoreRegHome
$LN46@write_win6:

; 2499 :     /*
; 2500 :      * PUSH RBP
; 2501 :      * .PUSHREG RBP
; 2502 :      * MOV RBP, RSP
; 2503 :      * .SETFRAME RBP, 0
; 2504 :      */
; 2505 : 
; 2506 : #if STACKBASESUPP
; 2507 :     /* info->locallist tells whether there are local variables ( info->localsize doesn't! ) */
; 2508 :     if ( info->fpo || ( info->parasize == 0 && info->locallist == NULL ) ) {

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN49@write_win6
	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN47@write_win6
	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN47@write_win6
$LN49@write_win6:

; 2509 :         DebugMsg1(("write_win64_default_prologue: no frame register needed\n"));

	lea	rcx, OFFSET FLAT:$SG12427
	call	DoDebugMsg1

; 2510 :         //sizestd += 8; /* v2.12: obsolete */
; 2511 :     } else {

	jmp	$LN48@write_win6
$LN47@write_win6:

; 2512 :         AddLineQueueX( "push %r", info->basereg );

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+130]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12428
	call	AddLineQueueX

; 2513 :         AddLineQueueX( "%r %r", T_DOT_PUSHREG, info->basereg );

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+130]
	mov	r8d, eax
	mov	edx, 417				; 000001a1H
	lea	rcx, OFFSET FLAT:$SG12429
	call	AddLineQueueX

; 2514 :         AddLineQueueX( "mov %r, %r", info->basereg, T_RSP );

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+130]
	mov	r8d, 119				; 00000077H
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12430
	call	AddLineQueueX

; 2515 :         AddLineQueueX( "%r %r, 0", T_DOT_SETFRAME, info->basereg );

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+130]
	mov	r8d, eax
	mov	edx, 421				; 000001a5H
	lea	rcx, OFFSET FLAT:$SG12431
	call	AddLineQueueX
$LN48@write_win6:

; 2516 :     }
; 2517 : #else
; 2518 :     AddLineQueueX( "push %r", basereg[USE64] );
; 2519 :     AddLineQueueX( "%r %r", T_DOT_PUSHREG, basereg[USE64] );
; 2520 :     AddLineQueueX( "mov %r, %r", basereg[USE64], T_RSP );
; 2521 :     AddLineQueueX( "%r %r, 0", T_DOT_SETFRAME, basereg[USE64] );
; 2522 : #endif
; 2523 :     if (ModuleInfo.win64_flags & W64F_HABRAN){

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	je	$LN50@write_win6

; 2524 :       cntxmm = 0;

	mov	DWORD PTR cntxmm$[rsp], 0

; 2525 :       if (info->regslist) {

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN52@write_win6

; 2526 :         n = 0;

	mov	DWORD PTR n$[rsp], 0

; 2527 :         info->pushed_reg = 0; /*count of pushed registers */

	mov	rax, QWORD PTR info$[rsp]
	mov	DWORD PTR [rax+104], 0

; 2528 :         regist = info->regslist;

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR regist$[rsp], rax

; 2529 :         for (cnt = *regist++; cnt; cnt--, regist++) {

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR cnt$[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax
	jmp	SHORT $LN4@write_win6
$LN2@write_win6:
	mov	eax, DWORD PTR cnt$[rsp]
	dec	eax
	mov	DWORD PTR cnt$[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax
$LN4@write_win6:
	cmp	DWORD PTR cnt$[rsp], 0
	je	$LN3@write_win6

; 2530 :           if (GetValueSp(*regist) & OP_XMM){

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN53@write_win6

; 2531 :             cntxmm += 1;

	mov	eax, DWORD PTR cntxmm$[rsp]
	inc	eax
	mov	DWORD PTR cntxmm$[rsp], eax

; 2532 :           }

	jmp	$LN54@write_win6
$LN53@write_win6:

; 2533 :           else if (GetValueSp(*regist) & OP_YMM){

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN55@write_win6

; 2534 :             cntxmm += 1;

	mov	eax, DWORD PTR cntxmm$[rsp]
	inc	eax
	mov	DWORD PTR cntxmm$[rsp], eax

; 2535 :             ymmflag = 1;

	mov	BYTE PTR ymmflag$[rsp], 1

; 2536 :           }

	jmp	$LN56@write_win6
$LN55@write_win6:

; 2537 : #if EVEXSUPP    
; 2538 :           else if (GetValueSp(*regist) & OP_ZMM){
; 2539 :             cntxmm += 1;
; 2540 :             zmmflag = 1;
; 2541 :           }
; 2542 : #endif
; 2543 :           else {
; 2544 :             if (n < info->stored_reg) n++;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+100]
	cmp	DWORD PTR n$[rsp], eax
	jge	SHORT $LN57@write_win6
	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax
	jmp	$LN58@write_win6
$LN57@write_win6:

; 2545 :             else{
; 2546 :               info->pushed_reg += 1;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+104]
	inc	eax
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+104], eax

; 2547 :               AddLineQueueX("push %r", *regist);

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12441
	call	AddLineQueueX

; 2548 :               if ((1 << GetRegNo(*regist)) & win64_nvgpr) {

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	ecx, 1
	mov	DWORD PTR tv871[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv871[rsp]
	shl	eax, cl
	movzx	ecx, WORD PTR win64_nvgpr
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN59@write_win6

; 2549 :                 AddLineQueueX("%r %r", T_DOT_PUSHREG, *regist);

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	r8d, eax
	mov	edx, 417				; 000001a1H
	lea	rcx, OFFSET FLAT:$SG12443
	call	AddLineQueueX
$LN59@write_win6:
$LN58@write_win6:
$LN56@write_win6:
$LN54@write_win6:

; 2550 :               }
; 2551 :             }
; 2552 :           }
; 2553 :         } /* end for */

	jmp	$LN2@write_win6
$LN3@write_win6:
$LN52@write_win6:

; 2554 :       }
; 2555 :     }

	jmp	$LN51@write_win6
$LN50@write_win6:

; 2556 :     else{
; 2557 :       /* after the "push rbp", the stack is xmmword aligned */
; 2558 :       /* Push the registers */
; 2559 :       cntxmm = 0;

	mov	DWORD PTR cntxmm$[rsp], 0

; 2560 :       if (info->regslist) {

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN60@write_win6

; 2561 :         int cnt;
; 2562 :         regist = info->regslist;

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR regist$[rsp], rax

; 2563 :         for (cnt = *regist++; cnt; cnt--, regist++) {

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR cnt$3[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax
	jmp	SHORT $LN7@write_win6
$LN5@write_win6:
	mov	eax, DWORD PTR cnt$3[rsp]
	dec	eax
	mov	DWORD PTR cnt$3[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax
$LN7@write_win6:
	cmp	DWORD PTR cnt$3[rsp], 0
	je	$LN6@write_win6

; 2564 :           if (GetValueSp(*regist) & OP_XMM)

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN61@write_win6

; 2565 :             cntxmm += 1;

	mov	eax, DWORD PTR cntxmm$[rsp]
	inc	eax
	mov	DWORD PTR cntxmm$[rsp], eax
	jmp	$LN62@write_win6
$LN61@write_win6:

; 2566 :           else if (GetValueSp(*regist) & OP_YMM){

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN63@write_win6

; 2567 :             cntxmm += 1;

	mov	eax, DWORD PTR cntxmm$[rsp]
	inc	eax
	mov	DWORD PTR cntxmm$[rsp], eax

; 2568 :             ymmflag = 1;

	mov	BYTE PTR ymmflag$[rsp], 1

; 2569 :           }

	jmp	SHORT $LN64@write_win6
$LN63@write_win6:

; 2570 : #if EVEXSUPP    
; 2571 :           else if (GetValueSp(*regist) & OP_ZMM){
; 2572 :             cntxmm += 1;
; 2573 :             zmmflag = 1;
; 2574 :           }
; 2575 : #endif
; 2576 :           else {
; 2577 :             AddLineQueueX("push %r", *regist);

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12449
	call	AddLineQueueX

; 2578 :             if ((1 << GetRegNo(*regist)) & win64_nvgpr) {

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	ecx, 1
	mov	DWORD PTR tv891[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv891[rsp]
	shl	eax, cl
	movzx	ecx, WORD PTR win64_nvgpr
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN65@write_win6

; 2579 :               AddLineQueueX("%r %r", T_DOT_PUSHREG, *regist);

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	r8d, eax
	mov	edx, 417				; 000001a1H
	lea	rcx, OFFSET FLAT:$SG12451
	call	AddLineQueueX
$LN65@write_win6:
$LN64@write_win6:
$LN62@write_win6:

; 2580 :             }
; 2581 :           }
; 2582 :         } /* end for */

	jmp	$LN5@write_win6
$LN6@write_win6:
$LN60@write_win6:
$LN51@write_win6:

; 2583 :       }
; 2584 :     }
; 2585 : #if EVEXSUPP   
; 2586 :     if (zmmflag) XYZMMsize = 64;
; 2587 :     else
; 2588 : #endif
; 2589 :     if (ymmflag) XYZMMsize = 32;

	movzx	eax, BYTE PTR ymmflag$[rsp]
	test	eax, eax
	je	SHORT $LN66@write_win6
	mov	DWORD PTR XYZMMsize, 32			; 00000020H
	jmp	SHORT $LN67@write_win6
$LN66@write_win6:

; 2590 :     else XYZMMsize = 16;

	mov	DWORD PTR XYZMMsize, 16
$LN67@write_win6:

; 2591 :     /* v2.11: now done in write_prologue() */
; 2592 :     if (ModuleInfo.win64_flags & W64F_HABRAN){

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	je	$LN68@write_win6

; 2593 :       if (Parse_Pass && sym_ReservedStack->hasinvoke == 0) resstack = 0;

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN69@write_win6
	mov	rax, QWORD PTR sym_ReservedStack
	cmp	DWORD PTR [rax+16], 0
	jne	SHORT $LN69@write_win6
	mov	DWORD PTR resstack$[rsp], 0
$LN69@write_win6:

; 2594 :       if (!(info->locallist) && !(resstack)) info->localsize = 0;

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN70@write_win6
	cmp	DWORD PTR resstack$[rsp], 0
	jne	SHORT $LN70@write_win6
	mov	rax, QWORD PTR info$[rsp]
	mov	DWORD PTR [rax+36], 0
$LN70@write_win6:

; 2595 :       if ((info->localsize == 0) && (cntxmm)){

	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+36], 0
	jne	SHORT $LN71@write_win6
	cmp	DWORD PTR cntxmm$[rsp], 0
	je	SHORT $LN71@write_win6

; 2596 :         CurrProc->e.procinfo->xmmsize = cntxmm * XYZMMsize;

	mov	eax, DWORD PTR cntxmm$[rsp]
	imul	eax, DWORD PTR XYZMMsize
	mov	rcx, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+112], eax

; 2597 :         if ((info->pushed_reg & 1) == 0)

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+104]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN72@write_win6

; 2598 :         info->localsize = 8;

	mov	rax, QWORD PTR info$[rsp]
	mov	DWORD PTR [rax+36], 8
$LN72@write_win6:
$LN71@write_win6:
$LN68@write_win6:

; 2599 :       }
; 2600 :     }
; 2601 :     if (( info->locallist + resstack) || info->vecused)  {

	movsxd	rax, DWORD PTR resstack$[rsp]
	imul	rax, rax, 120				; 00000078H
	mov	rcx, QWORD PTR info$[rsp]
	add	rax, QWORD PTR [rcx+16]
	test	rax, rax
	jne	SHORT $LN74@write_win6
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+80]
	test	eax, eax
	je	$LN73@write_win6
$LN74@write_win6:

; 2602 :         DebugMsg1(("write_win64_default_prologue: localsize=%u resstack=%u\n", info->localsize, resstack ));

	mov	r8d, DWORD PTR resstack$[rsp]
	mov	rax, QWORD PTR info$[rsp]
	mov	edx, DWORD PTR [rax+36]
	lea	rcx, OFFSET FLAT:$SG12461
	call	DoDebugMsg1

; 2603 :         if (ModuleInfo.win64_flags & W64F_HABRAN){

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	je	$LN75@write_win6

; 2604 :           if (((info->pushed_reg & 1) && (info->localsize & 0xF)) ||

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+104]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN78@write_win6
	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 15
	test	eax, eax
	jne	SHORT $LN77@write_win6
$LN78@write_win6:
	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+104]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN76@write_win6
	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 15
	test	eax, eax
	jne	SHORT $LN76@write_win6
	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+104]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN76@write_win6
	cmp	DWORD PTR cntxmm$[rsp], 0
	jne	SHORT $LN76@write_win6
$LN77@write_win6:

; 2605 :             ((!(info->pushed_reg & 1)) && (!(info->localsize & 0xF))) && (!(info->pushed_reg & 1)) && (!(cntxmm))){
; 2606 :             info->localsize += 8;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	add	eax, 8
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 2607 :             if (CurrProc->sym.langtype == LANG_VECTORCALL){

	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+76], 8
	jne	SHORT $LN79@write_win6

; 2608 :               vectstart = 0 ;

	mov	DWORD PTR vectstart$[rsp], 0
$LN79@write_win6:
$LN76@write_win6:
$LN75@write_win6:

; 2609 :             }
; 2610 :           }
; 2611 :         }
; 2612 :           /*
; 2613 :          * SUB  RSP, localsize
; 2614 :          * .ALLOCSTACK localsize
; 2615 :          */
; 2616 :         
; 2617 :         ppfmt = ( resstack ? fmtstk1 : fmtstk0 );

	cmp	DWORD PTR resstack$[rsp], 0
	je	SHORT $LN133@write_win6
	lea	rax, OFFSET FLAT:fmtstk1
	mov	QWORD PTR tv288[rsp], rax
	jmp	SHORT $LN134@write_win6
$LN133@write_win6:
	lea	rax, OFFSET FLAT:fmtstk0
	mov	QWORD PTR tv288[rsp], rax
$LN134@write_win6:
	mov	rax, QWORD PTR tv288[rsp]
	mov	QWORD PTR ppfmt$[rsp], rax

; 2618 : #if STACKPROBE
; 2619 : 		if (info->localsize + resstack > 0x1000) {
; 2620 : 			AddLineQueueX(*(ppfmt + 2), T_RAX, NUMQUAL info->localsize, sym_ReservedStack->name);
; 2621 : 			AddLineQueue("externdef __chkstk:PROC");
; 2622 : 			AddLineQueue("call __chkstk");
; 2623 : 			AddLineQueueX("mov %r, %r", T_RSP, T_RAX);
; 2624 : 		}
; 2625 : 		else
; 2626 : #endif
; 2627 : 			stackSize = info->localsize + info->vsize + info->xmmsize;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	rcx, QWORD PTR info$[rsp]
	add	eax, DWORD PTR [rcx+44]
	mov	rcx, QWORD PTR info$[rsp]
	add	eax, DWORD PTR [rcx+112]
	mov	DWORD PTR stackSize$[rsp], eax

; 2628 : 
; 2629 : 		if ((stackSize & 7) != 0) stackSize = (stackSize + 7)&(-8);

	mov	eax, DWORD PTR stackSize$[rsp]
	and	eax, 7
	test	eax, eax
	je	SHORT $LN80@write_win6
	mov	eax, DWORD PTR stackSize$[rsp]
	add	eax, 7
	and	eax, -8
	mov	DWORD PTR stackSize$[rsp], eax
$LN80@write_win6:

; 2630 :             AddLineQueueX( *(ppfmt+0), T_RSP, NUMQUAL stackSize, sym_ReservedStack->name );

	mov	rax, QWORD PTR sym_ReservedStack
	mov	r9, QWORD PTR [rax+8]
	mov	r8d, DWORD PTR stackSize$[rsp]
	mov	edx, 119				; 00000077H
	mov	rax, QWORD PTR ppfmt$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	AddLineQueueX

; 2631 :         AddLineQueueX( *(ppfmt+1), T_DOT_ALLOCSTACK, NUMQUAL stackSize, sym_ReservedStack->name );

	mov	rax, QWORD PTR sym_ReservedStack
	mov	r9, QWORD PTR [rax+8]
	mov	r8d, DWORD PTR stackSize$[rsp]
	mov	edx, 414				; 0000019eH
	mov	rax, QWORD PTR ppfmt$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	AddLineQueueX

; 2632 : 		    /* Handle ZEROLOCALS option */
; 2633 : 		    if (ZEROLOCALS && info->localsize) 

	movzx	eax, BYTE PTR ZEROLOCALS
	test	eax, eax
	je	$LN81@write_win6
	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+36], 0
	je	$LN81@write_win6

; 2634 : 		    {
; 2635 : 			    if (info->localsize <= 128) 

	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+36], 128			; 00000080H
	ja	SHORT $LN82@write_win6

; 2636 : 			    {
; 2637 : 				    AddLineQueueX("mov %r, %u", T_EAX, info->localsize);

	mov	rax, QWORD PTR info$[rsp]
	mov	r8d, DWORD PTR [rax+36]
	mov	edx, 17
	lea	rcx, OFFSET FLAT:$SG12471
	call	AddLineQueueX

; 2638 : 				    AddLineQueueX("dec %r", T_EAX);

	mov	edx, 17
	lea	rcx, OFFSET FLAT:$SG12472
	call	AddLineQueueX

; 2639 : 				    AddLineQueueX("mov byte ptr [%r + %r], 0", T_RSP, T_RAX);

	mov	r8d, 115				; 00000073H
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12473
	call	AddLineQueueX

; 2640 : 				    AddLineQueueX("dw 0F875h");

	lea	rcx, OFFSET FLAT:$SG12474
	call	AddLineQueueX

; 2641 : 			    }

	jmp	$LN83@write_win6
$LN82@write_win6:

; 2642 : 			    else
; 2643 : 			    {
; 2644 : 				    AddLineQueueX("push %r", T_RDI);

	mov	edx, 122				; 0000007aH
	lea	rcx, OFFSET FLAT:$SG12475
	call	AddLineQueueX

; 2645 : 				    AddLineQueueX("push %r", T_RCX);

	mov	edx, 116				; 00000074H
	lea	rcx, OFFSET FLAT:$SG12476
	call	AddLineQueueX

; 2646 : 				    AddLineQueueX("xor %r, %r", T_EAX, T_EAX);

	mov	r8d, 17
	mov	edx, 17
	lea	rcx, OFFSET FLAT:$SG12477
	call	AddLineQueueX

; 2647 : 				    AddLineQueueX("mov %r, %u", T_ECX, info->localsize);

	mov	rax, QWORD PTR info$[rsp]
	mov	r8d, DWORD PTR [rax+36]
	mov	edx, 18
	lea	rcx, OFFSET FLAT:$SG12478
	call	AddLineQueueX

; 2648 : 				    AddLineQueueX("cld");

	lea	rcx, OFFSET FLAT:$SG12479
	call	AddLineQueueX

; 2649 : 				    AddLineQueueX("lea %r, [%r+16]", T_RDI, T_RSP);

	mov	r8d, 119				; 00000077H
	mov	edx, 122				; 0000007aH
	lea	rcx, OFFSET FLAT:$SG12480
	call	AddLineQueueX

; 2650 : 				    AddLineQueueX("rep stosb");

	lea	rcx, OFFSET FLAT:$SG12481
	call	AddLineQueueX

; 2651 : 				    AddLineQueueX("pop %r", T_RCX);

	mov	edx, 116				; 00000074H
	lea	rcx, OFFSET FLAT:$SG12482
	call	AddLineQueueX

; 2652 : 				    AddLineQueueX("pop %r", T_RDI);

	mov	edx, 122				; 0000007aH
	lea	rcx, OFFSET FLAT:$SG12483
	call	AddLineQueueX
$LN83@write_win6:
$LN81@write_win6:

; 2653 : 			    }
; 2654 : 		    }
; 2655 :         /* save xmm registers */
; 2656 :         if ( cntxmm ) {

	cmp	DWORD PTR cntxmm$[rsp], 0
	je	$LN84@write_win6

; 2657 :             int cnt;
; 2658 :             regist = info->regslist;

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR regist$[rsp], rax

; 2659 :             if (info->locallist)

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN85@write_win6

; 2660 :               i = (info->localsize - cntxmm * XYZMMsize) & ~(16 - 1);

	mov	eax, DWORD PTR cntxmm$[rsp]
	imul	eax, DWORD PTR XYZMMsize
	mov	rcx, QWORD PTR info$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	sub	ecx, eax
	mov	eax, ecx
	and	eax, -16				; fffffff0H
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN86@write_win6
$LN85@write_win6:

; 2661 :             else
; 2662 :               i = info->localsize  & ~(16 - 1);

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, -16				; fffffff0H
	mov	DWORD PTR i$[rsp], eax
$LN86@write_win6:

; 2663 : 
; 2664 :             for( cnt = *regist++; cnt; cnt--, regist++ ) {

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR cnt$4[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax
	jmp	SHORT $LN10@write_win6
$LN8@write_win6:
	mov	eax, DWORD PTR cnt$4[rsp]
	dec	eax
	mov	DWORD PTR cnt$4[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax
$LN10@write_win6:
	cmp	DWORD PTR cnt$4[rsp], 0
	je	$LN9@write_win6

; 2665 :                 if (( GetValueSp( *regist ) & OP_XMM )||( GetValueSp( *regist ) & OP_YMM )

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN88@write_win6
	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	$LN87@write_win6
$LN88@write_win6:

; 2666 : #if EVEXSUPP    
; 2667 :                   || ( GetValueSp( *regist ) & OP_ZMM )
; 2668 : #endif
; 2669 :                 ){
; 2670 :                     if ( resstack ) {

	cmp	DWORD PTR resstack$[rsp], 0
	je	$LN89@write_win6

; 2671 :                         if ( ( 1 << GetRegNo( *regist ) ) & win64_nvxmm )  {

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	ecx, 1
	mov	DWORD PTR tv964[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv964[rsp]
	shl	eax, cl
	movzx	ecx, WORD PTR win64_nvxmm
	and	eax, ecx
	test	eax, eax
	je	$LN91@write_win6

; 2672 :                           if (GetValueSp(*regist) & OP_XMM){

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN92@write_win6

; 2673 :                             AddLineQueueX( "vmovdqu [%r+%u+%s], %r", T_RSP, NUMQUAL i, sym_ReservedStack->name, *regist );

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR sym_ReservedStack
	mov	r9, QWORD PTR [rax+8]
	mov	r8d, DWORD PTR i$[rsp]
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12494
	call	AddLineQueueX

; 2674 :                             AddLineQueueX("%r %r, %u+%s", T_DOT_SAVEXMM128, *regist, NUMQUAL i, sym_ReservedStack->name);

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR sym_ReservedStack
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, DWORD PTR i$[rsp]
	mov	r8d, eax
	mov	edx, 419				; 000001a3H
	lea	rcx, OFFSET FLAT:$SG12495
	call	AddLineQueueX

; 2675 :                             i += XYZMMsize;

	mov	eax, DWORD PTR XYZMMsize
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$[rsp], eax

; 2676 :                           }

	jmp	$LN93@write_win6
$LN92@write_win6:

; 2677 :                           else if (GetValueSp(*regist) & OP_YMM){

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN94@write_win6

; 2678 :                             AddLineQueueX( "vmovdqu [%r+%u+%s], %r", T_RSP, NUMQUAL i, sym_ReservedStack->name, *regist );

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR sym_ReservedStack
	mov	r9, QWORD PTR [rax+8]
	mov	r8d, DWORD PTR i$[rsp]
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12497
	call	AddLineQueueX

; 2679 :                             AddLineQueueX("%r %r, %u+%s", T_DOT_SAVEYMM256, *regist, NUMQUAL i, sym_ReservedStack->name);

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR sym_ReservedStack
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, DWORD PTR i$[rsp]
	mov	r8d, eax
	mov	edx, 420				; 000001a4H
	lea	rcx, OFFSET FLAT:$SG12498
	call	AddLineQueueX

; 2680 :                             i += XYZMMsize;

	mov	eax, DWORD PTR XYZMMsize
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$[rsp], eax
$LN94@write_win6:
$LN93@write_win6:
$LN91@write_win6:

; 2681 :                           }
; 2682 : #if EVEXSUPP    
; 2683 :                           else (GetValueSp(*regist) & OP_ZMM){
; 2684 :                             AddLineQueueX( "vmovdqu [%r+%u+%s], %r", T_RSP, NUMQUAL i, sym_ReservedStack->name, *regist );
; 2685 :                             AddLineQueueX("%r %r, %u+%s", T_DOT_SAVEZMM512, *regist, NUMQUAL i, sym_ReservedStack->name);
; 2686 :                             i += XYZMMsize;
; 2687 :                           }
; 2688 : #endif
; 2689 :                         }
; 2690 :                     } else {

	jmp	$LN90@write_win6
$LN89@write_win6:

; 2691 :                         if ( ( 1 << GetRegNo( *regist ) ) & win64_nvxmm )  {

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	ecx, 1
	mov	DWORD PTR tv987[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv987[rsp]
	shl	eax, cl
	movzx	ecx, WORD PTR win64_nvxmm
	and	eax, ecx
	test	eax, eax
	je	$LN95@write_win6

; 2692 :                           if (GetValueSp(*regist) & OP_XMM){

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN96@write_win6

; 2693 :                             AddLineQueueX("vmovdqu [%r+%u], %r", T_RSP, NUMQUAL i, *regist);

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	r9d, eax
	mov	r8d, DWORD PTR i$[rsp]
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12502
	call	AddLineQueueX

; 2694 :                             AddLineQueueX("%r %r, %u", T_DOT_SAVEXMM128, *regist, NUMQUAL i);

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	r9d, DWORD PTR i$[rsp]
	mov	r8d, eax
	mov	edx, 419				; 000001a3H
	lea	rcx, OFFSET FLAT:$SG12503
	call	AddLineQueueX

; 2695 :                             i += XYZMMsize;

	mov	eax, DWORD PTR XYZMMsize
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$[rsp], eax

; 2696 :                           }

	jmp	SHORT $LN97@write_win6
$LN96@write_win6:

; 2697 :                           else if (GetValueSp(*regist) & OP_YMM){

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN98@write_win6

; 2698 :                             AddLineQueueX("vmovdqu [%r+%u], %r", T_RSP, NUMQUAL i, *regist);

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	r9d, eax
	mov	r8d, DWORD PTR i$[rsp]
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12505
	call	AddLineQueueX

; 2699 :                             AddLineQueueX("%r %r, %u", T_DOT_SAVEYMM256, *regist, NUMQUAL i);

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	r9d, DWORD PTR i$[rsp]
	mov	r8d, eax
	mov	edx, 420				; 000001a4H
	lea	rcx, OFFSET FLAT:$SG12506
	call	AddLineQueueX

; 2700 :                             i += XYZMMsize;

	mov	eax, DWORD PTR XYZMMsize
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$[rsp], eax
$LN98@write_win6:
$LN97@write_win6:
$LN95@write_win6:
$LN90@write_win6:
$LN87@write_win6:

; 2701 :                           }
; 2702 : #if EVEXSUPP    
; 2703 :                           else (GetValueSp(*regist) & OP_ZMM){
; 2704 :                             AddLineQueueX( "vmovdqu [%r+%u+%s], %r", T_RSP, NUMQUAL i, *regist );
; 2705 :                             AddLineQueueX("%r %r, %u+%s", T_DOT_SAVEZMM512, *regist, NUMQUAL i);
; 2706 :                             i += XYZMMsize;
; 2707 :                           }
; 2708 : #endif
; 2709 :                         }
; 2710 :                     }
; 2711 :                 }
; 2712 :             }

	jmp	$LN8@write_win6
$LN9@write_win6:
$LN84@write_win6:

; 2713 :         }
; 2714 :     /* For VECTORCALL save vectors in the space provided */
; 2715 :         if (CurrProc->sym.langtype == LANG_VECTORCALL){

	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+76], 8
	jne	$LN99@write_win6

; 2716 :           vectstart = info->localsize  + info->xmmsize & ~(16 - 1);

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	rcx, QWORD PTR info$[rsp]
	add	eax, DWORD PTR [rcx+112]
	and	eax, -16				; fffffff0H
	mov	DWORD PTR vectstart$[rsp], eax

; 2717 :           if (info->vecused){

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+80]
	test	eax, eax
	je	$LN100@write_win6

; 2718 :             if (info->vecregs){

	mov	rax, QWORD PTR info$[rsp]
	add	rax, 56					; 00000038H
	test	rax, rax
	je	$LN101@write_win6

; 2719 :               for (n = 0, m = 0, xsize = 0; n < 6; n++){

	mov	DWORD PTR n$[rsp], 0
	mov	DWORD PTR m$[rsp], 0
	mov	BYTE PTR xsize$[rsp], 0
	jmp	SHORT $LN13@write_win6
$LN11@write_win6:
	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax
$LN13@write_win6:
	cmp	DWORD PTR n$[rsp], 6
	jge	$LN12@write_win6

; 2720 :                 xreg = info->vecregs[n];

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+56]
	mov	BYTE PTR xreg$[rsp], al

; 2721 :                 if (xreg == 1 && info->vecregsize[n] < 16)

	movzx	eax, BYTE PTR xreg$[rsp]
	cmp	eax, 1
	jne	SHORT $LN102@write_win6
	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+62]
	cmp	eax, 16
	jge	SHORT $LN102@write_win6

; 2722 :                   continue;//REAL4, FLOAT and REAL8 are stored in homespace

	jmp	SHORT $LN11@write_win6
	jmp	$LN103@write_win6
$LN102@write_win6:

; 2723 :                 else if (xreg)

	movzx	eax, BYTE PTR xreg$[rsp]
	test	eax, eax
	je	$LN104@write_win6

; 2724 : 				{  
; 2725 :                   AddLineQueueX("lea %r,[%r + %d]", T_RAX,T_RSP,vectstart  + xsize );

	movzx	eax, BYTE PTR xsize$[rsp]
	mov	ecx, DWORD PTR vectstart$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	r9d, eax
	mov	r8d, 119				; 00000077H
	mov	edx, 115				; 00000073H
	lea	rcx, OFFSET FLAT:$SG12514
	call	AddLineQueueX

; 2726 :                   stackSize = info->localsize + resstack + info->vsize + info->xmmsize + 8 + info->pushed_reg * 8  + n * 8;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	add	eax, DWORD PTR resstack$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	add	eax, DWORD PTR [rcx+44]
	mov	rcx, QWORD PTR info$[rsp]
	add	eax, DWORD PTR [rcx+112]
	mov	rcx, QWORD PTR info$[rsp]
	mov	ecx, DWORD PTR [rcx+104]
	lea	eax, DWORD PTR [rax+rcx*8+8]
	mov	ecx, DWORD PTR n$[rsp]
	lea	eax, DWORD PTR [rax+rcx*8]
	mov	DWORD PTR stackSize$[rsp], eax

; 2727 :                   if ((stackSize & 7) != 0) stackSize = (stackSize + 7)&(-8);

	mov	eax, DWORD PTR stackSize$[rsp]
	and	eax, 7
	test	eax, eax
	je	SHORT $LN106@write_win6
	mov	eax, DWORD PTR stackSize$[rsp]
	add	eax, 7
	and	eax, -8
	mov	DWORD PTR stackSize$[rsp], eax
$LN106@write_win6:

; 2728 :                   AddLineQueueX("mov [%r + %d], %r", T_RSP, stackSize, T_RAX);

	mov	r9d, 115				; 00000073H
	mov	r8d, DWORD PTR stackSize$[rsp]
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12516
	call	AddLineQueueX

; 2729 :                   xsize += info->vecregsize[n] * xreg;

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+62]
	movzx	ecx, BYTE PTR xreg$[rsp]
	imul	eax, ecx
	movzx	ecx, BYTE PTR xsize$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR xsize$[rsp], al

; 2730 :                 }

	jmp	$LN105@write_win6
$LN104@write_win6:

; 2731 : 				else if (info->vregs[n] != 0 && xreg == 0 && n < 4) /* JPH */

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+68]
	test	eax, eax
	je	$LN107@write_win6
	movzx	eax, BYTE PTR xreg$[rsp]
	test	eax, eax
	jne	$LN107@write_win6
	cmp	DWORD PTR n$[rsp], 4
	jge	$LN107@write_win6

; 2732 : 				{
; 2733 : 					struct dsym *pp = info->paralist;

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR pp$2[rsp], rax

; 2734 : 					int j = 0;

	mov	DWORD PTR j$1[rsp], 0

; 2735 : 					for (j = 0; j < n; j++)

	mov	DWORD PTR j$1[rsp], 0
	jmp	SHORT $LN16@write_win6
$LN14@write_win6:
	mov	eax, DWORD PTR j$1[rsp]
	inc	eax
	mov	DWORD PTR j$1[rsp], eax
$LN16@write_win6:
	mov	eax, DWORD PTR n$[rsp]
	cmp	DWORD PTR j$1[rsp], eax
	jge	SHORT $LN15@write_win6

; 2736 : 					{
; 2737 : 						if(pp) pp = pp->nextparam;

	cmp	QWORD PTR pp$2[rsp], 0
	je	SHORT $LN108@write_win6
	mov	rax, QWORD PTR pp$2[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR pp$2[rsp], rax
$LN108@write_win6:

; 2738 : 					}

	jmp	SHORT $LN14@write_win6
$LN15@write_win6:

; 2739 : 					if (pp)

	cmp	QWORD PTR pp$2[rsp], 0
	je	$LN109@write_win6

; 2740 : 					{
; 2741 : 							if (pp->sym.ttype)

	mov	rax, QWORD PTR pp$2[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	$LN110@write_win6

; 2742 : 							{
; 2743 : 								if (pp->sym.ttype->e.structinfo->isHFA == 1 || pp->sym.ttype->e.structinfo->isHVA == 1 || pp->sym.ttype->e.structinfo->stype == MM128 || pp->sym.ttype->e.structinfo->stype == MM256)

	mov	rax, QWORD PTR pp$2[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+22]
	cmp	eax, 1
	je	SHORT $LN112@write_win6
	mov	rax, QWORD PTR pp$2[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+21]
	cmp	eax, 1
	je	SHORT $LN112@write_win6
	mov	rax, QWORD PTR pp$2[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 1
	je	SHORT $LN112@write_win6
	mov	rax, QWORD PTR pp$2[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 2
	jne	$LN111@write_win6
$LN112@write_win6:

; 2744 : 								{
; 2745 : 									stackSize = info->localsize + resstack + info->vsize + info->xmmsize + 8 + info->pushed_reg * 8 + n * 8;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	add	eax, DWORD PTR resstack$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	add	eax, DWORD PTR [rcx+44]
	mov	rcx, QWORD PTR info$[rsp]
	add	eax, DWORD PTR [rcx+112]
	mov	rcx, QWORD PTR info$[rsp]
	mov	ecx, DWORD PTR [rcx+104]
	lea	eax, DWORD PTR [rax+rcx*8+8]
	mov	ecx, DWORD PTR n$[rsp]
	lea	eax, DWORD PTR [rax+rcx*8]
	mov	DWORD PTR stackSize$[rsp], eax

; 2746 : 									if ((stackSize & 7) != 0) stackSize = (stackSize + 7)&(-8);

	mov	eax, DWORD PTR stackSize$[rsp]
	and	eax, 7
	test	eax, eax
	je	SHORT $LN113@write_win6
	mov	eax, DWORD PTR stackSize$[rsp]
	add	eax, 7
	and	eax, -8
	mov	DWORD PTR stackSize$[rsp], eax
$LN113@write_win6:

; 2747 : 									AddLineQueueX("mov [%r + %d], %r", T_RSP, stackSize, ms64_regs[n]);

	movsxd	rax, DWORD PTR n$[rsp]
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	r9d, DWORD PTR [rcx+rax*4]
	mov	r8d, DWORD PTR stackSize$[rsp]
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12524
	call	AddLineQueueX

; 2748 : 									//xsize += 8;
; 2749 : 									xsize += info->vecregsize[n] * xreg;

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+62]
	movzx	ecx, BYTE PTR xreg$[rsp]
	imul	eax, ecx
	movzx	ecx, BYTE PTR xsize$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR xsize$[rsp], al
$LN111@write_win6:
$LN110@write_win6:
$LN109@write_win6:
$LN107@write_win6:
$LN105@write_win6:
$LN103@write_win6:

; 2750 : 								}
; 2751 : 							}
; 2752 : 					}
; 2753 : 				}
; 2754 :               }

	jmp	$LN11@write_win6
$LN12@write_win6:

; 2755 :               /* set available registers to zero including the ones that are greater than 1 */
; 2756 :               for (i = 0; i < 6; i++){

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN19@write_win6
$LN17@write_win6:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN19@write_win6:
	cmp	DWORD PTR i$[rsp], 6
	jge	$LN18@write_win6

; 2757 :                 if (info->vecregs[i] == 1) xyused[i] = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+56]
	cmp	eax, 1
	jne	SHORT $LN114@write_win6
	movsxd	rax, DWORD PTR i$[rsp]
	mov	BYTE PTR xyused$[rsp+rax], 1
	jmp	SHORT $LN115@write_win6
$LN114@write_win6:

; 2758 :                 else if ((info->vecregs[i] >= 1) && (xyused[i] != 1))

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+56]
	cmp	eax, 1
	jl	SHORT $LN116@write_win6
	movsxd	rax, DWORD PTR i$[rsp]
	movzx	eax, BYTE PTR xyused$[rsp+rax]
	cmp	eax, 1
	je	SHORT $LN116@write_win6

; 2759 :                   xyused[i] = 0;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	QWORD PTR $T5[rsp], rax
	cmp	QWORD PTR $T5[rsp], 6
	jae	SHORT $LN135@write_win6
	jmp	SHORT $LN136@write_win6
$LN135@write_win6:
	call	__report_rangecheckfailure
$LN136@write_win6:
	mov	rax, QWORD PTR $T5[rsp]
	mov	BYTE PTR xyused$[rsp+rax], 0
$LN116@write_win6:
$LN115@write_win6:

; 2760 :               }

	jmp	$LN17@write_win6
$LN18@write_win6:

; 2761 :               for (n = 0, m = 0; n < 6; n++){

	mov	DWORD PTR n$[rsp], 0
	mov	DWORD PTR m$[rsp], 0
	jmp	SHORT $LN22@write_win6
$LN20@write_win6:
	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax
$LN22@write_win6:
	cmp	DWORD PTR n$[rsp], 6
	jge	$LN21@write_win6

; 2762 :                 xreg = info->vecregs[n];       // it can be 0, 1, 2 or 4 eg: 0, 4, 0, 2, 0, 0

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+56]
	mov	BYTE PTR xreg$[rsp], al

; 2763 :                 xsize = info->vecregsize[n];   // xmm = 16, ymm = 32 or zmm = 64

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+62]
	mov	BYTE PTR xsize$[rsp], al

; 2764 :                 m += xreg;

	movzx	eax, BYTE PTR xreg$[rsp]
	mov	ecx, DWORD PTR m$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR m$[rsp], eax

; 2765 :                 if (m > 6) break;              // max 6 AVX registers

	cmp	DWORD PTR m$[rsp], 6
	jle	SHORT $LN117@write_win6
	jmp	$LN21@write_win6
$LN117@write_win6:

; 2766 :                 if (xreg == 1 && info->vecregsize[n] < 16)

	movzx	eax, BYTE PTR xreg$[rsp]
	cmp	eax, 1
	jne	SHORT $LN118@write_win6
	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+62]
	cmp	eax, 16
	jge	SHORT $LN118@write_win6

; 2767 :                   continue;                    //REAL4, FLOAT and REAL8 are stored in homespace

	jmp	$LN20@write_win6
	jmp	$LN119@write_win6
$LN118@write_win6:

; 2768 :                 else if (xreg){

	movzx	eax, BYTE PTR xreg$[rsp]
	test	eax, eax
	je	$LN120@write_win6

; 2769 :                   switch (xsize){

	movzx	eax, BYTE PTR xsize$[rsp]
	mov	BYTE PTR tv679[rsp], al
	cmp	BYTE PTR tv679[rsp], 4
	je	SHORT $LN121@write_win6
	cmp	BYTE PTR tv679[rsp], 8
	je	$LN122@write_win6
	cmp	BYTE PTR tv679[rsp], 16
	je	$LN124@write_win6
	cmp	BYTE PTR tv679[rsp], 32			; 00000020H
	je	$LN127@write_win6
	jmp	$LN23@write_win6
$LN121@write_win6:

; 2770 :                     case 4:
; 2771 :                       //if (xreg == 2){
; 2772 :                       //  /* this can only happen if there is 2 real4 */
; 2773 :                       //  AddLineQueueX("vmovsd qword ptr [rsp+%d],%r", vsize + vectstart, T_XMM0 + n);
; 2774 :                       //  vsize += 8;
; 2775 :                       //  }
; 2776 :                       //else{
; 2777 :                         for (i = 0, j = 0; i < xreg; i++){

	mov	DWORD PTR i$[rsp], 0
	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN27@write_win6
$LN25@write_win6:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN27@write_win6:
	movzx	eax, BYTE PTR xreg$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN26@write_win6
$LN28@write_win6:

; 2778 :                           while (xyused[j] != 0) j++;

	movsxd	rax, DWORD PTR j$[rsp]
	movzx	eax, BYTE PTR xyused$[rsp+rax]
	test	eax, eax
	je	SHORT $LN29@write_win6
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
	jmp	SHORT $LN28@write_win6
$LN29@write_win6:

; 2779 :                           AddLineQueueX("vmovss dword ptr [rsp+%d],%r", vsize + vectstart, T_XMM0 + j);

	mov	eax, DWORD PTR j$[rsp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR vectstart$[rsp]
	mov	edx, DWORD PTR vsize$[rsp]
	add	edx, ecx
	mov	ecx, edx
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG12533
	call	AddLineQueueX

; 2780 :                           xyused[j] = 1;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	BYTE PTR xyused$[rsp+rax], 1

; 2781 :                           vsize += 4;

	mov	eax, DWORD PTR vsize$[rsp]
	add	eax, 4
	mov	DWORD PTR vsize$[rsp], eax

; 2782 :                           }

	jmp	SHORT $LN25@write_win6
$LN26@write_win6:

; 2783 :                         //}
; 2784 :                       break;

	jmp	$LN23@write_win6
$LN122@write_win6:

; 2785 :                     case 8:
; 2786 :                       if (xreg <= 3){

	movzx	eax, BYTE PTR xreg$[rsp]
	cmp	eax, 3
	jg	$LN123@write_win6

; 2787 :                         for (i = 0, j = 0; i < xreg; i++){

	mov	DWORD PTR i$[rsp], 0
	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN32@write_win6
$LN30@write_win6:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN32@write_win6:
	movzx	eax, BYTE PTR xreg$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN31@write_win6
$LN33@write_win6:

; 2788 :                           while (xyused[j] != 0) j++;

	movsxd	rax, DWORD PTR j$[rsp]
	movzx	eax, BYTE PTR xyused$[rsp+rax]
	test	eax, eax
	je	SHORT $LN34@write_win6
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
	jmp	SHORT $LN33@write_win6
$LN34@write_win6:

; 2789 :                           AddLineQueueX("vmovsd qword ptr [rsp+%d],%r", vsize + vectstart, T_XMM0 + j);

	mov	eax, DWORD PTR j$[rsp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR vectstart$[rsp]
	mov	edx, DWORD PTR vsize$[rsp]
	add	edx, ecx
	mov	ecx, edx
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG12536
	call	AddLineQueueX

; 2790 :                           xyused[j] = 1;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	BYTE PTR xyused$[rsp+rax], 1

; 2791 :                           vsize += 8;

	mov	eax, DWORD PTR vsize$[rsp]
	add	eax, 8
	mov	DWORD PTR vsize$[rsp], eax

; 2792 :                           }

	jmp	SHORT $LN30@write_win6
$LN31@write_win6:
$LN123@write_win6:

; 2793 :                         }
; 2794 :                       /* this can only happen if there is 8 real8 */
; 2795 : #if EVEXSUPP
; 2796 :                       else {
; 2797 :                         AddLineQueueX("vmovups ymmword ptr [rsp+%d],%r",vsize + vectstart , T_YMM0 + n);
; 2798 :                         vsize += 64;
; 2799 :                         xyused[n] = 1;
; 2800 :                     }
; 2801 : #endif
; 2802 :                     break;

	jmp	$LN23@write_win6
$LN124@write_win6:

; 2803 :                   case 16:
; 2804 :                     if (xreg == 1){

	movzx	eax, BYTE PTR xreg$[rsp]
	cmp	eax, 1
	jne	SHORT $LN125@write_win6

; 2805 :                         AddLineQueueX("vmovups oword ptr [rsp+%d],%r",vsize + vectstart , T_XMM0 + n);

	mov	eax, DWORD PTR n$[rsp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR vectstart$[rsp]
	mov	edx, DWORD PTR vsize$[rsp]
	add	edx, ecx
	mov	ecx, edx
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG12540
	call	AddLineQueueX

; 2806 :                       xyused[n] = 1;

	movsxd	rax, DWORD PTR n$[rsp]
	mov	BYTE PTR xyused$[rsp+rax], 1

; 2807 :                       vsize += 16;

	mov	eax, DWORD PTR vsize$[rsp]
	add	eax, 16
	mov	DWORD PTR vsize$[rsp], eax

; 2808 :                     }

	jmp	$LN126@write_win6
$LN125@write_win6:

; 2809 :                     else{
; 2810 :                       for (i = 0, j = 0; i < xreg; i++){

	mov	DWORD PTR i$[rsp], 0
	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN37@write_win6
$LN35@write_win6:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN37@write_win6:
	movzx	eax, BYTE PTR xreg$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN36@write_win6
$LN38@write_win6:

; 2811 :                         while (xyused[j] != 0) j++;

	movsxd	rax, DWORD PTR j$[rsp]
	movzx	eax, BYTE PTR xyused$[rsp+rax]
	test	eax, eax
	je	SHORT $LN39@write_win6
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
	jmp	SHORT $LN38@write_win6
$LN39@write_win6:

; 2812 :                           AddLineQueueX("vmovups oword ptr [rsp+%d],%r",vsize + vectstart , T_XMM0 + j);

	mov	eax, DWORD PTR j$[rsp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR vectstart$[rsp]
	mov	edx, DWORD PTR vsize$[rsp]
	add	edx, ecx
	mov	ecx, edx
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG12541
	call	AddLineQueueX

; 2813 :                         xyused[j] = 1;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	BYTE PTR xyused$[rsp+rax], 1

; 2814 :                         vsize += 16;

	mov	eax, DWORD PTR vsize$[rsp]
	add	eax, 16
	mov	DWORD PTR vsize$[rsp], eax

; 2815 :                       }

	jmp	SHORT $LN35@write_win6
$LN36@write_win6:
$LN126@write_win6:

; 2816 :                     }
; 2817 :                     break;

	jmp	$LN23@write_win6
$LN127@write_win6:

; 2818 :                   case 32:
; 2819 :                     if (xreg == 1){

	movzx	eax, BYTE PTR xreg$[rsp]
	cmp	eax, 1
	jne	SHORT $LN128@write_win6

; 2820 :                         AddLineQueueX("vmovups ymmword ptr [rsp+%d],%r",vsize + vectstart  , T_YMM0 + n);

	mov	eax, DWORD PTR n$[rsp]
	add	eax, 56					; 00000038H
	mov	ecx, DWORD PTR vectstart$[rsp]
	mov	edx, DWORD PTR vsize$[rsp]
	add	edx, ecx
	mov	ecx, edx
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG12545
	call	AddLineQueueX

; 2821 :                       xyused[n] = 1;

	movsxd	rax, DWORD PTR n$[rsp]
	mov	BYTE PTR xyused$[rsp+rax], 1

; 2822 :                       vsize += 32;

	mov	eax, DWORD PTR vsize$[rsp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR vsize$[rsp], eax

; 2823 :                     }

	jmp	$LN129@write_win6
$LN128@write_win6:

; 2824 :                     else{
; 2825 :                       for (i = 0, j = 0; i < xreg; i++){

	mov	DWORD PTR i$[rsp], 0
	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN42@write_win6
$LN40@write_win6:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN42@write_win6:
	movzx	eax, BYTE PTR xreg$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN41@write_win6
$LN43@write_win6:

; 2826 :                         while (xyused[j] != 0) j++;

	movsxd	rax, DWORD PTR j$[rsp]
	movzx	eax, BYTE PTR xyused$[rsp+rax]
	test	eax, eax
	je	SHORT $LN44@write_win6
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
	jmp	SHORT $LN43@write_win6
$LN44@write_win6:

; 2827 :                           AddLineQueueX("vmovups ymmword ptr [rsp+%d],%r",vsize + vectstart , T_YMM0 + j);

	mov	eax, DWORD PTR j$[rsp]
	add	eax, 56					; 00000038H
	mov	ecx, DWORD PTR vectstart$[rsp]
	mov	edx, DWORD PTR vsize$[rsp]
	add	edx, ecx
	mov	ecx, edx
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG12546
	call	AddLineQueueX

; 2828 :                         xyused[j] = 1;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	BYTE PTR xyused$[rsp+rax], 1

; 2829 :                         vsize += 32;

	mov	eax, DWORD PTR vsize$[rsp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR vsize$[rsp], eax

; 2830 :                       }

	jmp	SHORT $LN40@write_win6
$LN41@write_win6:
$LN129@write_win6:
$LN23@write_win6:
$LN120@write_win6:
$LN119@write_win6:

; 2831 :                     }
; 2832 :                     break;
; 2833 : #if EVEXSUPP 
; 2834 :                   case 64: 
; 2835 :                     if (xreg == 1){
; 2836 :                         AddLineQueueX("vmovups zmmword ptr [rsp+%d],%r",vsize + vectstart + xsize, T_ZMM0 + n);
; 2837 :                       xyused[n] = 1;
; 2838 :                       vsize += 64;
; 2839 :                     }
; 2840 :                     else{
; 2841 :                       for (i=0,j=0; i < xreg; i++){
; 2842 :                         while (xyused[j] != 0) j++;
; 2843 :                           AddLineQueueX("vmovups zmmword ptr [rsp+%d],%r", vsize + vectstart + xsize, T_ZMM0 + j);
; 2844 :                         xyused[j] = 1;
; 2845 :                         vsize += 64;
; 2846 :                       }
; 2847 :                     }
; 2848 :                     break;
; 2849 : #endif
; 2850 :                   }
; 2851 :                 }
; 2852 :               }

	jmp	$LN20@write_win6
$LN21@write_win6:
$LN101@write_win6:
$LN100@write_win6:
$LN99@write_win6:
$LN73@write_win6:

; 2853 :             }
; 2854 :           }
; 2855 :         }
; 2856 :     }
; 2857 :     AddLineQueueX( "%r", T_DOT_ENDPROLOG );

	mov	edx, 415				; 0000019fH
	lea	rcx, OFFSET FLAT:$SG12547
	call	AddLineQueueX
$LN130@write_win6:

; 2858 : 
; 2859 :     /* v2.11: linequeue is now run in write_default_prologue() */
; 2860 :     return;
; 2861 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 216				; 000000d8H
	ret	0
write_win64_default_prologue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
i$ = 32
freeshadow$ = 36
cnt$ = 40
grcount$ = 44
sizestd$ = 48
regist$ = 56
info$ = 80
win64_StoreRegHome PROC

; 2382 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2383 :   int			       i = 0;

	mov	DWORD PTR i$[rsp], 0

; 2384 :   int			       cnt;
; 2385 :   int            grcount = 0;

	mov	DWORD PTR grcount$[rsp], 0

; 2386 :   int			       sizestd = 0;

	mov	DWORD PTR sizestd$[rsp], 0

; 2387 :   int            freeshadow = 4;

	mov	DWORD PTR freeshadow$[rsp], 4

; 2388 :   uint_16        *regist;
; 2389 :   info->stored_reg = 0;

	mov	rax, QWORD PTR info$[rsp]
	mov	DWORD PTR [rax+100], 0

; 2390 :   if (info->regslist) {

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN26@win64_Stor

; 2391 :     for (regist = info->regslist, cnt = *regist++; cnt; cnt--, regist++, i++) {

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR regist$[rsp], rax
	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR cnt$[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax
	jmp	SHORT $LN4@win64_Stor
$LN2@win64_Stor:
	mov	eax, DWORD PTR cnt$[rsp]
	dec	eax
	mov	DWORD PTR cnt$[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@win64_Stor:
	cmp	DWORD PTR cnt$[rsp], 0
	je	SHORT $LN3@win64_Stor

; 2392 :       if ((GetValueSp(*regist) & OP_YMM)||(GetValueSp(*regist) & OP_XMM)

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN29@win64_Stor
	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN27@win64_Stor
$LN29@win64_Stor:

; 2393 : #if EVEXSUPP    
; 2394 :                   || ( GetValueSp( *regist ) & OP_ZMM )
; 2395 : #endif
; 2396 :         )continue;

	jmp	SHORT $LN2@win64_Stor
	jmp	SHORT $LN28@win64_Stor
$LN27@win64_Stor:

; 2397 :       else ++grcount;                                       //find how many general registers to save

	mov	eax, DWORD PTR grcount$[rsp]
	inc	eax
	mov	DWORD PTR grcount$[rsp], eax
$LN28@win64_Stor:

; 2398 :     }

	jmp	SHORT $LN2@win64_Stor
$LN3@win64_Stor:

; 2399 :     //for (i = 0, freeshadow = 0; i<4; i++){                  
; 2400 :     //  if (info->home_used[i] == 0) ++freeshadow;
; 2401 :     //}
; 2402 :     freeshadow -= info->home_taken;                         //find out how many free shadows

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+108]
	mov	ecx, DWORD PTR freeshadow$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR freeshadow$[rsp], eax

; 2403 :     if (freeshadow){                                        //skip if all shadow spaces are taken  

	cmp	DWORD PTR freeshadow$[rsp], 0
	je	$LN30@win64_Stor

; 2404 :       if (grcount == 1) memset(info->home_used, 1, 4);      //1 register only? don't store it, push it to prevent 'sub rsp,...8'

	cmp	DWORD PTR grcount$[rsp], 1
	jne	SHORT $LN31@win64_Stor
	mov	rax, QWORD PTR info$[rsp]
	add	rax, 116				; 00000074H
	mov	r8d, 4
	mov	edx, 1
	mov	rcx, rax
	call	memset
	jmp	$LN32@win64_Stor
$LN31@win64_Stor:

; 2405 :       else if (grcount == 2 && freeshadow >= 2){            //store only one egister, another push to prevent 'sub rsp,...8'

	cmp	DWORD PTR grcount$[rsp], 2
	jne	SHORT $LN33@win64_Stor
	cmp	DWORD PTR freeshadow$[rsp], 2
	jl	SHORT $LN33@win64_Stor

; 2406 :         for (i = 0; i<4; i++){

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@win64_Stor
$LN5@win64_Stor:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@win64_Stor:
	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN6@win64_Stor

; 2407 :           if (info->home_used[i] == 0) break;               //we need only one space   

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+116]
	test	eax, eax
	jne	SHORT $LN35@win64_Stor
	jmp	SHORT $LN6@win64_Stor
$LN35@win64_Stor:

; 2408 :         }

	jmp	SHORT $LN5@win64_Stor
$LN6@win64_Stor:

; 2409 :         for (++i; i<4; i++)                                 //the rest of free spaces render as taken

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN10@win64_Stor
$LN8@win64_Stor:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@win64_Stor:
	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN9@win64_Stor

; 2410 :           info->home_used[i] = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+116], 1
	jmp	SHORT $LN8@win64_Stor
$LN9@win64_Stor:

; 2411 :       }

	jmp	$LN34@win64_Stor
$LN33@win64_Stor:

; 2412 :       else if (grcount == 3){                               //3 registers?

	cmp	DWORD PTR grcount$[rsp], 3
	jne	$LN36@win64_Stor

; 2413 :         if (freeshadow == 1) memset(info->home_used, 1, 4); //if only 1 free shadow, don't store it, push them

	cmp	DWORD PTR freeshadow$[rsp], 1
	jne	SHORT $LN38@win64_Stor
	mov	rax, QWORD PTR info$[rsp]
	add	rax, 116				; 00000074H
	mov	r8d, 4
	mov	edx, 1
	mov	rcx, rax
	call	memset
$LN38@win64_Stor:

; 2414 :         if (freeshadow >= 3){                               //enen if there is enough space we will store only two

	cmp	DWORD PTR freeshadow$[rsp], 3
	jl	$LN39@win64_Stor

; 2415 :           for (i = 0; i<4; i++){                            //the third one we will push to keep uneven stack 

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN13@win64_Stor
$LN11@win64_Stor:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN13@win64_Stor:
	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN12@win64_Stor

; 2416 :             if (info->home_used[i] == 0) break;             //found first availible

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+116]
	test	eax, eax
	jne	SHORT $LN40@win64_Stor
	jmp	SHORT $LN12@win64_Stor
$LN40@win64_Stor:

; 2417 :           }

	jmp	SHORT $LN11@win64_Stor
$LN12@win64_Stor:

; 2418 :           for (++i; i<4; i++){

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN16@win64_Stor
$LN14@win64_Stor:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN16@win64_Stor:
	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN15@win64_Stor

; 2419 :             if (info->home_used[i] == 0) break;            //found second availible

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+116]
	test	eax, eax
	jne	SHORT $LN41@win64_Stor
	jmp	SHORT $LN15@win64_Stor
$LN41@win64_Stor:

; 2420 :           }

	jmp	SHORT $LN14@win64_Stor
$LN15@win64_Stor:

; 2421 :           for (++i; i<4; i++)

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN19@win64_Stor
$LN17@win64_Stor:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN19@win64_Stor:
	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN18@win64_Stor

; 2422 :             info->home_used[i] = 1;                        //render the rest of the shadow spaces as taken

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+116], 1
	jmp	SHORT $LN17@win64_Stor
$LN18@win64_Stor:
$LN39@win64_Stor:

; 2423 :         }
; 2424 :       }

	jmp	$LN37@win64_Stor
$LN36@win64_Stor:

; 2425 :       else if (grcount == 4 && freeshadow == 4){          //easy case

	cmp	DWORD PTR grcount$[rsp], 4
	jne	SHORT $LN42@win64_Stor
	cmp	DWORD PTR freeshadow$[rsp], 4
	jne	SHORT $LN42@win64_Stor

; 2426 :         info->home_used[3] = 1;                           //render the last shadow spaces as taken

	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+116], 1

; 2427 :       }                                                   //remember the first space is 0 than 1, 2 and 3 follow 

	jmp	SHORT $LN43@win64_Stor
$LN42@win64_Stor:

; 2428 :       else if (grcount > 4){                              //if more registars than spaces

	cmp	DWORD PTR grcount$[rsp], 4
	jle	SHORT $LN44@win64_Stor

; 2429 :         freeshadow = grcount - freeshadow;                //find out how many we can store

	mov	eax, DWORD PTR freeshadow$[rsp]
	mov	ecx, DWORD PTR grcount$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR freeshadow$[rsp], eax

; 2430 :         if (!(freeshadow & 1)){                           //if it is even number

	mov	eax, DWORD PTR freeshadow$[rsp]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN45@win64_Stor

; 2431 :           for (i = 0; i<4; i++){                          //than we have to disable one space

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN22@win64_Stor
$LN20@win64_Stor:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN22@win64_Stor:
	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN21@win64_Stor

; 2432 :             if (info->home_used[i] == 0) break;           //find the first free space 

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+116]
	test	eax, eax
	jne	SHORT $LN46@win64_Stor
	jmp	SHORT $LN21@win64_Stor
$LN46@win64_Stor:

; 2433 :           }

	jmp	SHORT $LN20@win64_Stor
$LN21@win64_Stor:

; 2434 :           info->home_used[i] = 1;                         //and render it as taken

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+116], 1
$LN45@win64_Stor:
$LN44@win64_Stor:
$LN43@win64_Stor:
$LN37@win64_Stor:
$LN34@win64_Stor:
$LN32@win64_Stor:
$LN30@win64_Stor:

; 2435 :         }
; 2436 :       }
; 2437 :     }
; 2438 :     for (i = 0, regist = info->regslist, cnt = *regist++; cnt; cnt--, regist++, i++) {

	mov	DWORD PTR i$[rsp], 0
	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR regist$[rsp], rax
	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR cnt$[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax
	jmp	SHORT $LN25@win64_Stor
$LN23@win64_Stor:
	mov	eax, DWORD PTR cnt$[rsp]
	dec	eax
	mov	DWORD PTR cnt$[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN25@win64_Stor:
	cmp	DWORD PTR cnt$[rsp], 0
	je	$LN24@win64_Stor

; 2439 :       if ((GetValueSp(*regist) & OP_YMM)||(GetValueSp(*regist) & OP_XMM)

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN49@win64_Stor
	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN47@win64_Stor
$LN49@win64_Stor:

; 2440 : #if EVEXSUPP    
; 2441 :                   || ( GetValueSp( *regist ) & OP_ZMM )
; 2442 : #endif
; 2443 :         )continue;

	jmp	SHORT $LN23@win64_Stor
	jmp	$LN48@win64_Stor
$LN47@win64_Stor:

; 2444 :       else {
; 2445 :         sizestd += 8;

	mov	eax, DWORD PTR sizestd$[rsp]
	add	eax, 8
	mov	DWORD PTR sizestd$[rsp], eax

; 2446 :         if (i < 4)

	cmp	DWORD PTR i$[rsp], 4
	jge	$LN50@win64_Stor

; 2447 :         {
; 2448 :           if (info->home_used[i] == 0){

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+116]
	test	eax, eax
	jne	SHORT $LN51@win64_Stor

; 2449 :             AddLineQueueX("mov [%r+%u], %r", T_RSP, NUMQUAL sizestd, *regist);

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	r9d, eax
	mov	r8d, DWORD PTR sizestd$[rsp]
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12347
	call	AddLineQueueX

; 2450 :             AddLineQueueX("%r %r, %u", T_DOT_SAVEREG, *regist, NUMQUAL sizestd);

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	r9d, DWORD PTR sizestd$[rsp]
	mov	r8d, eax
	mov	edx, 418				; 000001a2H
	lea	rcx, OFFSET FLAT:$SG12348
	call	AddLineQueueX

; 2451 :             info->stored_reg++;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+100]
	inc	eax
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+100], eax

; 2452 :           }

	jmp	SHORT $LN52@win64_Stor
$LN51@win64_Stor:

; 2453 :           else {
; 2454 :             cnt++; regist--;

	mov	eax, DWORD PTR cnt$[rsp]
	inc	eax
	mov	DWORD PTR cnt$[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	sub	rax, 2
	mov	QWORD PTR regist$[rsp], rax
$LN52@win64_Stor:
$LN50@win64_Stor:
$LN48@win64_Stor:

; 2455 :           }
; 2456 :         }
; 2457 :       }
; 2458 :     }/* end for */

	jmp	$LN23@win64_Stor
$LN24@win64_Stor:
$LN26@win64_Stor:

; 2459 :   }
; 2460 :   return;
; 2461 : }

	add	rsp, 72					; 00000048H
	ret	0
win64_StoreRegHome ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
i$ = 32
param$ = 40
regist$1 = 48
info$ = 80
win64_SaveRegParams PROC

; 2286 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2287 : 	int i;
; 2288 : 	struct dsym *param;
; 2289 : 	if (ModuleInfo.win64_flags & W64F_HABRAN) {

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	je	$LN11@win64_Save

; 2290 : 		int			   cnt;
; 2291 : 		uint_16        *regist;
; 2292 : 		info->home_taken = 0;

	mov	rax, QWORD PTR info$[rsp]
	mov	DWORD PTR [rax+108], 0

; 2293 : 		memset(info->home_used, 0, 6);

	mov	rax, QWORD PTR info$[rsp]
	add	rax, 116				; 00000074H
	mov	r8d, 6
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 2294 : 		if (info->regslist)

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN13@win64_Save

; 2295 : 			regist = info->regslist;

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR regist$1[rsp], rax
$LN13@win64_Save:

; 2296 : 		if (CurrProc->sym.langtype == LANG_VECTORCALL) {

	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+76], 8
	jne	$LN14@win64_Save

; 2297 : 			for (i = 0, param = info->paralist; param && (i < 6); i++) {

	mov	DWORD PTR i$[rsp], 0
	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR param$[rsp], rax
	jmp	SHORT $LN4@win64_Save
$LN2@win64_Save:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@win64_Save:
	cmp	QWORD PTR param$[rsp], 0
	je	$LN3@win64_Save
	cmp	DWORD PTR i$[rsp], 6
	jge	$LN3@win64_Save

; 2298 : 				/* v2.05: save XMMx if type is float/double */
; 2299 : 				if (param->sym.is_vararg == FALSE) {

	mov	rax, QWORD PTR param$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	$LN16@win64_Save

; 2300 : 					if ((param->sym.mem_type & MT_FLOAT) && param->sym.used) {  // added  && param->sym.used

	mov	rax, QWORD PTR param$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	$LN18@win64_Save
	mov	rax, QWORD PTR param$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN18@win64_Save

; 2301 : 						if (param->sym.mem_type == MT_REAL8)

	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+36], 39			; 00000027H
	jne	SHORT $LN20@win64_Save

; 2302 : 							AddLineQueueX("movsd qword ptr[%r+%u], %r", T_RSP, 8 + i * 8, T_XMM0 + i);

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR i$[rsp]
	lea	ecx, DWORD PTR [rcx*8+8]
	mov	r9d, eax
	mov	r8d, ecx
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12262
	call	AddLineQueueX
	jmp	SHORT $LN21@win64_Save
$LN20@win64_Save:

; 2303 : 						else if (param->sym.mem_type == MT_REAL4)

	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+36], 35			; 00000023H
	jne	SHORT $LN22@win64_Save

; 2304 : 							AddLineQueueX("movss dword ptr[%r+%u], %r", T_RSP, 8 + i * 8, T_XMM0 + i);

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR i$[rsp]
	lea	ecx, DWORD PTR [rcx*8+8]
	mov	r9d, eax
	mov	r8d, ecx
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12264
	call	AddLineQueueX
$LN22@win64_Save:
$LN21@win64_Save:

; 2305 : 						info->home_used[i] = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+116], 1

; 2306 : 						++info->home_taken;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+108]
	inc	eax
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+108], eax

; 2307 : 					}

	jmp	$LN19@win64_Save
$LN18@win64_Save:

; 2308 : 					else if ((param->sym.mem_type == MT_TYPE) && param->sym.used) 

	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN23@win64_Save
	mov	rax, QWORD PTR param$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@win64_Save

; 2309 : 					{
; 2310 : //						if(info->vecregs[i] == 0)
; 2311 : 	//						AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);
; 2312 : 						info->home_used[i] = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+116], 1

; 2313 : 						++info->home_taken;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+108]
	inc	eax
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+108], eax

; 2314 : 						info->vecused = TRUE;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+80], 1

; 2315 : 					}

	jmp	$LN24@win64_Save
$LN23@win64_Save:

; 2316 : 					else {
; 2317 : 						if (((param->sym.mem_type != MT_TYPE) && param->sym.used) &&
; 2318 : 							(param->sym.mem_type <= MT_QWORD) && param->sym.used) {   //here as well   

	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	je	$LN25@win64_Save
	mov	rax, QWORD PTR param$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN25@win64_Save
	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+36], 7
	jg	SHORT $LN25@win64_Save
	mov	rax, QWORD PTR param$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN25@win64_Save

; 2319 : 							if (i < 4) {

	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN26@win64_Save

; 2320 : 								AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	edx, DWORD PTR i$[rsp]
	lea	edx, DWORD PTR [rdx*8+8]
	mov	r9d, DWORD PTR [rcx+rax*4]
	mov	r8d, edx
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12269
	call	AddLineQueueX

; 2321 : 								info->home_used[i] = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+116], 1

; 2322 : 								++info->home_taken;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+108]
	inc	eax
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+108], eax
$LN26@win64_Save:
$LN25@win64_Save:
$LN24@win64_Save:
$LN19@win64_Save:

; 2323 : 							}
; 2324 : 						}
; 2325 : 					}
; 2326 : 					param = param->nextparam;

	mov	rax, QWORD PTR param$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR param$[rsp], rax

; 2327 : 				}

	jmp	SHORT $LN17@win64_Save
$LN16@win64_Save:

; 2328 : 				else { /* v2.09: else branch added */
; 2329 : 					AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	edx, DWORD PTR i$[rsp]
	lea	edx, DWORD PTR [rdx*8+8]
	mov	r9d, DWORD PTR [rcx+rax*4]
	mov	r8d, edx
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12270
	call	AddLineQueueX

; 2330 : 					info->home_used[i] = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+116], 1

; 2331 : 					++info->home_taken;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+108]
	inc	eax
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+108], eax
$LN17@win64_Save:

; 2332 : 				}
; 2333 : 			}

	jmp	$LN2@win64_Save
$LN3@win64_Save:

; 2334 : 		}

	jmp	$LN15@win64_Save
$LN14@win64_Save:

; 2335 : 		else {
; 2336 : 			for (i = 0, param = info->paralist; param && (i < 4); i++) {

	mov	DWORD PTR i$[rsp], 0
	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR param$[rsp], rax
	jmp	SHORT $LN7@win64_Save
$LN5@win64_Save:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@win64_Save:
	cmp	QWORD PTR param$[rsp], 0
	je	$LN6@win64_Save
	cmp	DWORD PTR i$[rsp], 4
	jge	$LN6@win64_Save

; 2337 : 				/* v2.05: save XMMx if type is float/double */
; 2338 : 				if (param->sym.is_vararg == FALSE) {

	mov	rax, QWORD PTR param$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	$LN27@win64_Save

; 2339 : 					if ((param->sym.mem_type & MT_FLOAT) && param->sym.used) {  // added  && param->sym.used

	mov	rax, QWORD PTR param$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN29@win64_Save
	mov	rax, QWORD PTR param$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN29@win64_Save

; 2340 : 						AddLineQueueX("movq [%r+%u], %r", T_RSP, 8 + i * 8, T_XMM0 + i);

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR i$[rsp]
	lea	ecx, DWORD PTR [rcx*8+8]
	mov	r9d, eax
	mov	r8d, ecx
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12275
	call	AddLineQueueX

; 2341 : 						info->home_used[i] = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+116], 1

; 2342 : 						++info->home_taken;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+108]
	inc	eax
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+108], eax

; 2343 : 					}

	jmp	SHORT $LN30@win64_Save
$LN29@win64_Save:

; 2344 : 					else {
; 2345 : 						if (param->sym.used) {                                    //here as well 

	mov	rax, QWORD PTR param$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN31@win64_Save

; 2346 : 							AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	edx, DWORD PTR i$[rsp]
	lea	edx, DWORD PTR [rdx*8+8]
	mov	r9d, DWORD PTR [rcx+rax*4]
	mov	r8d, edx
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12277
	call	AddLineQueueX

; 2347 : 							info->home_used[i] = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+116], 1

; 2348 : 							++info->home_taken;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+108]
	inc	eax
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+108], eax
$LN31@win64_Save:
$LN30@win64_Save:

; 2349 : 						}
; 2350 : 					}
; 2351 : 					param = param->nextparam;

	mov	rax, QWORD PTR param$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR param$[rsp], rax

; 2352 : 				}

	jmp	SHORT $LN28@win64_Save
$LN27@win64_Save:

; 2353 : 				else { /* v2.09: else branch added */
; 2354 : 					AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	edx, DWORD PTR i$[rsp]
	lea	edx, DWORD PTR [rdx*8+8]
	mov	r9d, DWORD PTR [rcx+rax*4]
	mov	r8d, edx
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12278
	call	AddLineQueueX

; 2355 : 					info->home_used[i] = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+116], 1

; 2356 : 					++info->home_taken;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+108]
	inc	eax
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+108], eax
$LN28@win64_Save:

; 2357 : 				}
; 2358 : 			}

	jmp	$LN5@win64_Save
$LN6@win64_Save:
$LN15@win64_Save:

; 2359 : 		}
; 2360 : 	}

	jmp	$LN12@win64_Save
$LN11@win64_Save:

; 2361 : 	else {
; 2362 : 		for (i = 0, param = info->paralist; param && (i < 4); i++) {

	mov	DWORD PTR i$[rsp], 0
	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR param$[rsp], rax
	jmp	SHORT $LN10@win64_Save
$LN8@win64_Save:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@win64_Save:
	cmp	QWORD PTR param$[rsp], 0
	je	$LN9@win64_Save
	cmp	DWORD PTR i$[rsp], 4
	jge	$LN9@win64_Save

; 2363 : 			/* v2.05: save XMMx if type is float/double */
; 2364 : 			if (param->sym.is_vararg == FALSE) {

	mov	rax, QWORD PTR param$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN32@win64_Save

; 2365 : 				if (param->sym.mem_type & MT_FLOAT)

	mov	rax, QWORD PTR param$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN34@win64_Save

; 2366 : 					AddLineQueueX("movq [%r+%u], %r", T_RSP, 8 + i * 8, T_XMM0 + i);

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR i$[rsp]
	lea	ecx, DWORD PTR [rcx*8+8]
	mov	r9d, eax
	mov	r8d, ecx
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12283
	call	AddLineQueueX
	jmp	SHORT $LN35@win64_Save
$LN34@win64_Save:

; 2367 : 				else
; 2368 : 					AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	edx, DWORD PTR i$[rsp]
	lea	edx, DWORD PTR [rdx*8+8]
	mov	r9d, DWORD PTR [rcx+rax*4]
	mov	r8d, edx
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12284
	call	AddLineQueueX
$LN35@win64_Save:

; 2369 : 				param = param->nextparam;

	mov	rax, QWORD PTR param$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR param$[rsp], rax

; 2370 : 			}

	jmp	SHORT $LN33@win64_Save
$LN32@win64_Save:

; 2371 : 			else { /* v2.09: else branch added */
; 2372 : 				AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	edx, DWORD PTR i$[rsp]
	lea	edx, DWORD PTR [rdx*8+8]
	mov	r9d, DWORD PTR [rcx+rax*4]
	mov	r8d, edx
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG12285
	call	AddLineQueueX
$LN33@win64_Save:

; 2373 : 			}
; 2374 : 		}

	jmp	$LN8@win64_Save
$LN9@win64_Save:
$LN12@win64_Save:

; 2375 : 	}
; 2376 : 	return;
; 2377 : }

	add	rsp, 72					; 00000048H
	ret	0
win64_SaveRegParams ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
flags$ = 64
len$ = 68
info$ = 72
p$ = 80
is_exitm$ = 88
i$ = 92
regs$ = 96
tv81 = 104
tv88 = 108
tv95 = 112
curr$1 = 120
dir$ = 128
tv164 = 136
reglst$ = 144
buffer$ = 272
__$ArrayPad$ = 1296
tokenarray$ = 1328
write_userdef_prologue PROC

; 2194 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1320				; 00000528H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2195 :     int                 len;
; 2196 :     int                 i;
; 2197 :     struct proc_info    *info;
; 2198 :     char                *p;
; 2199 :     bool                is_exitm;
; 2200 :     struct dsym         *dir;
; 2201 :     //int                 align = CurrWordSize;
; 2202 :     int                 flags = CurrProc->sym.langtype; /* set bits 0-2 */

	mov	rax, QWORD PTR CurrProc
	mov	eax, DWORD PTR [rax+76]
	mov	DWORD PTR flags$[rsp], eax

; 2203 :     uint_16             *regs;
; 2204 :     char                reglst[128];
; 2205 :     char                buffer[MAX_LINE_LEN];
; 2206 : 	struct asym         *cline;
; 2207 : 	int                 curline;
; 2208 : 
; 2209 : #if FASTPASS
; 2210 :     if ( Parse_Pass > PASS_1 && UseSavedState )

	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN8@write_user
	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	je	SHORT $LN8@write_user

; 2211 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@write_user
$LN8@write_user:

; 2212 : #endif
; 2213 : 
; 2214 :     info = CurrProc->e.procinfo;

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR info$[rsp], rax

; 2215 :     /* v2.11: now done in write_prologue() */
; 2216 :     //info->localsize = ROUND_UP( info->localsize, CurrWordSize );
; 2217 : #if AMD64_SUPPORT
; 2218 :     /* to be compatible with ML64, translate FASTCALL to 0 (not 7) */
; 2219 :     if ( CurrProc->sym.langtype == LANG_FASTCALL && ModuleInfo.fctype == FCT_WIN64 )

	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+76], 7
	jne	SHORT $LN9@write_user
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN9@write_user

; 2220 :         flags = 0;

	mov	DWORD PTR flags$[rsp], 0
$LN9@write_user:

; 2221 : #endif
; 2222 :     /* set bit 4 if the caller restores (E)SP */
; 2223 :     if ( CurrProc->sym.langtype == LANG_C ||
; 2224 :         CurrProc->sym.langtype == LANG_SYSCALL ||

	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+76], 1
	je	SHORT $LN11@write_user
	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+76], 2
	je	SHORT $LN11@write_user
	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+76], 7
	jne	SHORT $LN10@write_user
$LN11@write_user:

; 2225 :         CurrProc->sym.langtype == LANG_FASTCALL )
; 2226 :         flags |= 0x10;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 16
	mov	DWORD PTR flags$[rsp], eax
$LN10@write_user:

; 2227 : 
; 2228 :     /* set bit 5 if proc is far */
; 2229 :     /* set bit 6 if proc is private */
; 2230 :     /* v2.11: set bit 7 if proc is export */
; 2231 :     flags |= ( CurrProc->sym.mem_type == MT_FAR ? 0x20 : 0 );

	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN19@write_user
	mov	DWORD PTR tv81[rsp], 32			; 00000020H
	jmp	SHORT $LN20@write_user
$LN19@write_user:
	mov	DWORD PTR tv81[rsp], 0
$LN20@write_user:
	mov	eax, DWORD PTR tv81[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR flags$[rsp], eax

; 2232 :     flags |= ( CurrProc->sym.ispublic ? 0 : 0x40 );

	mov	rax, QWORD PTR CurrProc
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN21@write_user
	mov	DWORD PTR tv88[rsp], 0
	jmp	SHORT $LN22@write_user
$LN21@write_user:
	mov	DWORD PTR tv88[rsp], 64			; 00000040H
$LN22@write_user:
	mov	eax, DWORD PTR tv88[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR flags$[rsp], eax

; 2233 :     flags |= ( info->isexport ? 0x80 : 0 );

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@write_user
	mov	DWORD PTR tv95[rsp], 128		; 00000080H
	jmp	SHORT $LN24@write_user
$LN23@write_user:
	mov	DWORD PTR tv95[rsp], 0
$LN24@write_user:
	mov	eax, DWORD PTR tv95[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR flags$[rsp], eax

; 2234 : 
; 2235 :     dir = (struct dsym *)SymSearch( ModuleInfo.proc_prologue );

	mov	rcx, QWORD PTR ModuleInfo+320
	call	SymFind
	mov	QWORD PTR dir$[rsp], rax

; 2236 :     if ( dir == NULL || dir->sym.state != SYM_MACRO || dir->sym.isfunc != TRUE ) {

	cmp	QWORD PTR dir$[rsp], 0
	je	SHORT $LN13@write_user
	mov	rax, QWORD PTR dir$[rsp]
	cmp	DWORD PTR [rax+32], 9
	jne	SHORT $LN13@write_user
	mov	rax, QWORD PTR dir$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	je	SHORT $LN12@write_user
$LN13@write_user:

; 2237 :         return( EmitError( PROLOGUE_MUST_BE_MACRO_FUNC ) );

	mov	ecx, 156				; 0000009cH
	call	EmitError
	jmp	$LN1@write_user
$LN12@write_user:

; 2238 :     }
; 2239 : 
; 2240 :     /* if -EP is on, emit "prologue: none" */
; 2241 :     if ( Options.preprocessor_stdout )

	movzx	eax, BYTE PTR Options+141
	test	eax, eax
	je	SHORT $LN14@write_user

; 2242 :         printf( "option prologue:none\n" );

	lea	rcx, OFFSET FLAT:$SG12227
	call	printf
$LN14@write_user:

; 2243 : 
; 2244 :     p = reglst;

	lea	rax, QWORD PTR reglst$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 2245 :     if ( info->regslist ) {

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN15@write_user

; 2246 :         regs = info->regslist;

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR regs$[rsp], rax

; 2247 :         for ( len = *regs++; len; len--, regs++ ) {

	mov	rax, QWORD PTR regs$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR len$[rsp], eax
	mov	rax, QWORD PTR regs$[rsp]
	add	rax, 2
	mov	QWORD PTR regs$[rsp], rax
	jmp	SHORT $LN4@write_user
$LN2@write_user:
	mov	eax, DWORD PTR len$[rsp]
	dec	eax
	mov	DWORD PTR len$[rsp], eax
	mov	rax, QWORD PTR regs$[rsp]
	add	rax, 2
	mov	QWORD PTR regs$[rsp], rax
$LN4@write_user:
	cmp	DWORD PTR len$[rsp], 0
	je	SHORT $LN3@write_user

; 2248 :             GetResWName( *regs, p );

	mov	rax, QWORD PTR regs$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	rdx, QWORD PTR p$[rsp]
	mov	ecx, eax
	call	GetResWName

; 2249 :             p += strlen( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 2250 :             if ( len > 1 )

	cmp	DWORD PTR len$[rsp], 1
	jle	SHORT $LN16@write_user

; 2251 :                 *p++ = ',';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 44			; 0000002cH
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN16@write_user:

; 2252 :         }

	jmp	SHORT $LN2@write_user
$LN3@write_user:
$LN15@write_user:

; 2253 :     }
; 2254 :     *p = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 0

; 2255 : 
; 2256 :     /* v2.07: make this work with radix != 10 */
; 2257 :     /* leave a space at pos 0 of buffer, because the buffer is used for
; 2258 :      * both macro arguments and EXITM return value.
; 2259 :      */
; 2260 :     sprintf( buffer," (%s, 0%XH, 0%XH, 0%XH, <<%s>>, <%s>)",

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN25@write_user
	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv164[rsp], rax
	jmp	SHORT $LN26@write_user
$LN25@write_user:
	lea	rax, OFFSET FLAT:$SG12230
	mov	QWORD PTR tv164[rsp], rax
$LN26@write_user:
	mov	rax, QWORD PTR tv164[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR reglst$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR flags$[rsp]
	mov	rax, QWORD PTR CurrProc
	mov	r8, QWORD PTR [rax+8]
	lea	rdx, OFFSET FLAT:$SG12231
	lea	rcx, QWORD PTR buffer$[rsp]
	call	sprintf

; 2261 :              CurrProc->sym.name, flags, info->parasize, info->localsize,
; 2262 :             reglst, info->prologuearg ? info->prologuearg : "" );
; 2263 :     i = Token_Count + 1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 2264 :     Token_Count = Tokenize( buffer, i, tokenarray, TOK_RESCAN );

	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 2265 : 
; 2266 :     RunMacro( dir, i, tokenarray, buffer, 0, &is_exitm );

	lea	rax, QWORD PTR is_exitm$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR buffer$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	call	RunMacro

; 2267 :     Token_Count = i - 1;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR ModuleInfo+496, eax

; 2268 :     DebugMsg(("write_userdef_prologue: macro %s returned >%s<\n", ModuleInfo.proc_prologue, buffer ));

	lea	r8, QWORD PTR buffer$[rsp]
	mov	rdx, QWORD PTR ModuleInfo+320
	lea	rcx, OFFSET FLAT:$SG12232
	call	DoDebugMsg

; 2269 : 
; 2270 :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN17@write_user

; 2271 :         struct dsym *curr;
; 2272 :         len = atoi( buffer ) - info->localsize;

	lea	rcx, QWORD PTR buffer$[rsp]
	call	atoi
	mov	rcx, QWORD PTR info$[rsp]
	sub	eax, DWORD PTR [rcx+36]
	mov	DWORD PTR len$[rsp], eax

; 2273 :         for ( curr = info->locallist; curr; curr = curr->nextlocal ) {

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR curr$1[rsp], rax
	jmp	SHORT $LN7@write_user
$LN5@write_user:
	mov	rax, QWORD PTR curr$1[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$1[rsp], rax
$LN7@write_user:
	cmp	QWORD PTR curr$1[rsp], 0
	je	SHORT $LN6@write_user

; 2274 :             curr->sym.offset -= len;

	mov	rax, QWORD PTR curr$1[rsp]
	mov	ecx, DWORD PTR len$[rsp]
	mov	eax, DWORD PTR [rax+16]
	sub	eax, ecx
	mov	rcx, QWORD PTR curr$1[rsp]
	mov	DWORD PTR [rcx+16], eax

; 2275 :         }

	jmp	SHORT $LN5@write_user
$LN6@write_user:
$LN17@write_user:

; 2276 :     }
; 2277 : 	
; 2278 :     return ( NOT_ERROR );

	xor	eax, eax
$LN1@write_user:

; 2279 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1320				; 00000528H
	ret	0
write_userdef_prologue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
puc$ = 48
ofs$ = 56
reg$ = 57
oldcodes$ = 58
token$ = 60
tv140 = 64
tv401 = 68
size$ = 72
opndx$ = 80
i$ = 208
tokenarray$ = 216
ExcFrameDirective PROC

; 1906 : {

$LN59:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 200				; 000000c8H

; 1907 :     struct expr opndx;
; 1908 :     int token;
; 1909 :     unsigned int size;
; 1910 :     uint_8 oldcodes = unw_info.CountOfCodes;

	movzx	eax, BYTE PTR unw_info+2
	mov	BYTE PTR oldcodes$[rsp], al

; 1911 :     uint_8 reg;
; 1912 :     uint_8 ofs;
; 1913 :     UNWIND_CODE *puc;
; 1914 : 
; 1915 :     DebugMsg1(("ExcFrameDirective(%s) enter\n", tokenarray[i].string_ptr ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG12132
	call	DoDebugMsg1

; 1916 :     /* v2.05: accept directives for windows only */
; 1917 : 	if (Options.output_format != OFORMAT_COFF && Options.output_format != OFORMAT_ELF /* John Hankinson 2016-02-10 Added elf win64 hack */
; 1918 : #if PE_SUPPORT
; 1919 :         && ModuleInfo.sub_format != SFORMAT_PE

	cmp	DWORD PTR Options+160, 2
	je	SHORT $LN6@ExcFrameDi
	cmp	DWORD PTR Options+160, 3
	je	SHORT $LN6@ExcFrameDi
	cmp	DWORD PTR ModuleInfo+372, 2
	je	SHORT $LN6@ExcFrameDi

; 1920 : #endif
; 1921 :        ) {
; 1922 :         return( EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, GetResWName( tokenarray[i].tokval, NULL ) ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	xor	edx, edx
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+16]
	call	GetResWName
	mov	rdx, rax
	mov	ecx, 224				; 000000e0H
	call	EmitErr
	jmp	$LN1@ExcFrameDi
$LN6@ExcFrameDi:

; 1923 :     }
; 1924 :     if ( CurrProc == NULL || endprolog_found == TRUE ) {

	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN8@ExcFrameDi
	movzx	eax, BYTE PTR endprolog_found
	cmp	eax, 1
	jne	SHORT $LN7@ExcFrameDi
$LN8@ExcFrameDi:

; 1925 :         return( EmitError( ENDPROLOG_FOUND_BEFORE_EH_DIRECTIVES ) );

	mov	ecx, 255				; 000000ffH
	call	EmitError
	jmp	$LN1@ExcFrameDi
$LN7@ExcFrameDi:

; 1926 :     }
; 1927 :     if ( CurrProc->e.procinfo->isframe == FALSE ) {

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN9@ExcFrameDi

; 1928 :         return( EmitError( MISSING_FRAME_IN_PROC ) );

	mov	ecx, 256				; 00000100H
	call	EmitError
	jmp	$LN1@ExcFrameDi
$LN9@ExcFrameDi:

; 1929 :     }
; 1930 : 
; 1931 :     puc = &unw_code[unw_info.CountOfCodes];

	movzx	eax, BYTE PTR unw_info+2
	lea	rcx, OFFSET FLAT:unw_code
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR puc$[rsp], rax

; 1932 : 
; 1933 :     ofs = GetCurrOffset() - CurrProc->sym.offset;

	call	GetCurrOffset
	mov	rcx, QWORD PTR CurrProc
	sub	eax, DWORD PTR [rcx+16]
	mov	BYTE PTR ofs$[rsp], al

; 1934 :     token = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR token$[rsp], eax

; 1935 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1936 : 
; 1937 :     /* note: since the codes will be written from "right to left",
; 1938 :      * the opcode item has to be written last!
; 1939 :      */
; 1940 : 
; 1941 :     switch ( token ) {

	mov	eax, DWORD PTR token$[rsp]
	mov	DWORD PTR tv140[rsp], eax
	mov	eax, DWORD PTR tv140[rsp]
	sub	eax, 414				; 0000019eH
	mov	DWORD PTR tv140[rsp], eax
	cmp	DWORD PTR tv140[rsp], 7
	ja	$LN2@ExcFrameDi
	movsxd	rax, DWORD PTR tv140[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN58@ExcFrameDi[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN10@ExcFrameDi:

; 1942 :     case T_DOT_ALLOCSTACK: /* syntax: .ALLOCSTACK size */
; 1943 :         if ( ERROR == EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN11@ExcFrameDi

; 1944 :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExcFrameDi
$LN11@ExcFrameDi:

; 1945 :         if ( opndx.kind == EXPR_ADDR && opndx.sym->state == SYM_UNDEFINED ) /* v2.11: allow forward references */

	cmp	DWORD PTR opndx$[rsp+60], 1
	jne	SHORT $LN12@ExcFrameDi
	mov	rax, QWORD PTR opndx$[rsp+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN12@ExcFrameDi

; 1946 :              ;

	jmp	SHORT $LN13@ExcFrameDi
$LN12@ExcFrameDi:

; 1947 :         else if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN14@ExcFrameDi

; 1948 :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN1@ExcFrameDi
$LN14@ExcFrameDi:
$LN13@ExcFrameDi:

; 1949 :         }
; 1950 :         /* v2.11: check added */
; 1951 :         if ( opndx.hvalue ) {

	cmp	DWORD PTR opndx$[rsp+4], 0
	je	SHORT $LN15@ExcFrameDi

; 1952 :             return( EmitConstError( &opndx ) );

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	$LN1@ExcFrameDi
$LN15@ExcFrameDi:

; 1953 :         }
; 1954 :         if ( opndx.uvalue == 0 ) {

	cmp	DWORD PTR opndx$[rsp], 0
	jne	SHORT $LN16@ExcFrameDi

; 1955 :             return( EmitError( NONZERO_VALUE_EXPECTED ) );

	mov	ecx, 258				; 00000102H
	call	EmitError
	jmp	$LN1@ExcFrameDi
$LN16@ExcFrameDi:

; 1956 :         }
; 1957 :         if ( opndx.value & 7 ) {

	mov	eax, DWORD PTR opndx$[rsp]
	and	eax, 7
	test	eax, eax
	je	SHORT $LN17@ExcFrameDi

; 1958 :             return( EmitError( BAD_ALIGNMENT_FOR_OFFSET_IN_UNWIND_CODE ) );

	mov	ecx, 257				; 00000101H
	call	EmitError
	jmp	$LN1@ExcFrameDi
$LN17@ExcFrameDi:

; 1959 :         }
; 1960 :         //opndx.value -= 8; /* v2.11: subtract 8 only for UWOP_ALLOC_SMALL! */
; 1961 :         if ( opndx.uvalue > 16*8 ) {

	cmp	DWORD PTR opndx$[rsp], 128		; 00000080H
	jbe	$LN18@ExcFrameDi

; 1962 :             if ( opndx.uvalue >= 65536*8 ) {

	cmp	DWORD PTR opndx$[rsp], 524288		; 00080000H
	jb	SHORT $LN20@ExcFrameDi

; 1963 :                 /* allocation size 512k - 4G-8 */
; 1964 :                 /* v2.11: value is stored UNSCALED in 2 WORDs! */
; 1965 :                 puc->FrameOffset = ( opndx.uvalue >> 16 );

	mov	eax, DWORD PTR opndx$[rsp]
	shr	eax, 16
	mov	rcx, QWORD PTR puc$[rsp]
	mov	WORD PTR [rcx], ax

; 1966 :                 puc++;

	mov	rax, QWORD PTR puc$[rsp]
	add	rax, 2
	mov	QWORD PTR puc$[rsp], rax

; 1967 :                 puc->FrameOffset = opndx.uvalue & 0xFFFF;

	mov	eax, DWORD PTR opndx$[rsp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR puc$[rsp]
	mov	WORD PTR [rcx], ax

; 1968 :                 puc++;

	mov	rax, QWORD PTR puc$[rsp]
	add	rax, 2
	mov	QWORD PTR puc$[rsp], rax

; 1969 :                 unw_info.CountOfCodes += 2;

	movzx	eax, BYTE PTR unw_info+2
	add	eax, 2
	mov	BYTE PTR unw_info+2, al

; 1970 :                 puc->OpInfo = 1;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	and	al, 15
	or	al, 16
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 1971 :                 DebugMsg1(("ExcFrameDirective: UWOP_ALLOC_LARGE, operation info 1, size=%Xh\n", opndx.value ));

	mov	edx, DWORD PTR opndx$[rsp]
	lea	rcx, OFFSET FLAT:$SG12149
	call	DoDebugMsg1

; 1972 :             } else {

	jmp	SHORT $LN21@ExcFrameDi
$LN20@ExcFrameDi:

; 1973 :                 /* allocation size 128+8 - 512k-8 */
; 1974 :                 puc->FrameOffset = ( opndx.uvalue >> 3 );

	mov	eax, DWORD PTR opndx$[rsp]
	shr	eax, 3
	mov	rcx, QWORD PTR puc$[rsp]
	mov	WORD PTR [rcx], ax

; 1975 :                 puc++;

	mov	rax, QWORD PTR puc$[rsp]
	add	rax, 2
	mov	QWORD PTR puc$[rsp], rax

; 1976 :                 unw_info.CountOfCodes++;

	movzx	eax, BYTE PTR unw_info+2
	inc	al
	mov	BYTE PTR unw_info+2, al

; 1977 :                 puc->OpInfo = 0;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	and	al, 15
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 1978 :                 DebugMsg1(("ExcFrameDirective: UWOP_ALLOC_LARGE, operation info 0, size=%Xh\n", opndx.value ));

	mov	edx, DWORD PTR opndx$[rsp]
	lea	rcx, OFFSET FLAT:$SG12150
	call	DoDebugMsg1
$LN21@ExcFrameDi:

; 1979 :             }
; 1980 :             puc->UnwindOp = UWOP_ALLOC_LARGE;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	and	al, 240					; 000000f0H
	or	al, 1
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 1981 :         } else {

	jmp	SHORT $LN19@ExcFrameDi
$LN18@ExcFrameDi:

; 1982 :             /* allocation size 8-128 bytes */
; 1983 :             puc->UnwindOp = UWOP_ALLOC_SMALL;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	and	al, 240					; 000000f0H
	or	al, 2
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 1984 :             /* v2.11: subtract 8 only for UWOP_ALLOC_SMALL! */
; 1985 :             //puc->OpInfo = ( opndx.value >> 3 );
; 1986 :             puc->OpInfo = ( (opndx.uvalue - 8 ) >> 3 );

	mov	eax, DWORD PTR opndx$[rsp]
	sub	eax, 8
	shr	eax, 3
	and	al, 15
	shl	al, 4
	mov	rcx, QWORD PTR puc$[rsp]
	movzx	ecx, BYTE PTR [rcx+1]
	and	cl, 15
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 1987 :             DebugMsg1(("ExcFrameDirective: UWOP_ALLOC_SMALL, size=%Xh\n", opndx.value ));

	mov	edx, DWORD PTR opndx$[rsp]
	lea	rcx, OFFSET FLAT:$SG12151
	call	DoDebugMsg1
$LN19@ExcFrameDi:

; 1988 :         }
; 1989 :         puc->CodeOffset = ofs;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	ecx, BYTE PTR ofs$[rsp]
	mov	BYTE PTR [rax], cl

; 1990 :         unw_info.CountOfCodes++;

	movzx	eax, BYTE PTR unw_info+2
	inc	al
	mov	BYTE PTR unw_info+2, al

; 1991 :         break;

	jmp	$LN2@ExcFrameDi
$LN22@ExcFrameDi:

; 1992 :     case T_DOT_ENDPROLOG: /* syntax: .ENDPROLOG */
; 1993 :         opndx.value = GetCurrOffset() - CurrProc->sym.offset;

	call	GetCurrOffset
	mov	rcx, QWORD PTR CurrProc
	sub	eax, DWORD PTR [rcx+16]
	mov	DWORD PTR opndx$[rsp], eax

; 1994 :         if ( opndx.uvalue > 255 ) {

	cmp	DWORD PTR opndx$[rsp], 255		; 000000ffH
	jbe	SHORT $LN23@ExcFrameDi

; 1995 :             return( EmitError( SIZE_OF_PROLOG_TOO_BIG ) );

	mov	ecx, 259				; 00000103H
	call	EmitError
	jmp	$LN1@ExcFrameDi
$LN23@ExcFrameDi:

; 1996 :         }
; 1997 :         unw_info.SizeOfProlog = (uint_8)opndx.uvalue;

	movzx	eax, BYTE PTR opndx$[rsp]
	mov	BYTE PTR unw_info+1, al

; 1998 :         endprolog_found = TRUE;

	mov	BYTE PTR endprolog_found, 1

; 1999 :         break;

	jmp	$LN2@ExcFrameDi
$LN24@ExcFrameDi:

; 2000 :     case T_DOT_PUSHFRAME: /* syntax: .PUSHFRAME [code] */
; 2001 :         puc->CodeOffset = ofs;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	ecx, BYTE PTR ofs$[rsp]
	mov	BYTE PTR [rax], cl

; 2002 :         puc->UnwindOp = UWOP_PUSH_MACHFRAME;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	and	al, 240					; 000000f0H
	or	al, 10
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 2003 :         puc->OpInfo = 0;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	and	al, 15
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 2004 :         if ( tokenarray[i].token == T_ID && (_stricmp( tokenarray[i].string_ptr, "CODE") == 0 ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN25@ExcFrameDi
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG12156
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN25@ExcFrameDi

; 2005 :             puc->OpInfo = 1;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	and	al, 15
	or	al, 16
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 2006 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN25@ExcFrameDi:

; 2007 :         }
; 2008 :         unw_info.CountOfCodes++;

	movzx	eax, BYTE PTR unw_info+2
	inc	al
	mov	BYTE PTR unw_info+2, al

; 2009 :         break;

	jmp	$LN2@ExcFrameDi
$LN26@ExcFrameDi:

; 2010 :     case T_DOT_PUSHREG: /* syntax: .PUSHREG r64 */
; 2011 :         if ( tokenarray[i].token != T_REG || !( GetValueSp( tokenarray[i].tokval ) & OP_R64 ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	jne	SHORT $LN28@ExcFrameDi
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN27@ExcFrameDi
$LN28@ExcFrameDi:

; 2012 :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ExcFrameDi
$LN27@ExcFrameDi:

; 2013 :         }
; 2014 :         puc->CodeOffset = ofs;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	ecx, BYTE PTR ofs$[rsp]
	mov	BYTE PTR [rax], cl

; 2015 :         puc->UnwindOp = UWOP_PUSH_NONVOL;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	and	al, 240					; 000000f0H
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 2016 :         puc->OpInfo = GetRegNo( tokenarray[i].tokval );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	and	al, 15
	shl	al, 4
	mov	rcx, QWORD PTR puc$[rsp]
	movzx	ecx, BYTE PTR [rcx+1]
	and	cl, 15
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 2017 :         unw_info.CountOfCodes++;

	movzx	eax, BYTE PTR unw_info+2
	inc	al
	mov	BYTE PTR unw_info+2, al

; 2018 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 2019 :         break;

	jmp	$LN2@ExcFrameDi
$LN29@ExcFrameDi:

; 2020 :     case T_DOT_SAVEREG:    /* syntax: .SAVEREG r64, offset       */
; 2021 :     case T_DOT_SAVEXMM128: /* syntax: .SAVEXMM128 xmmreg, offset */
; 2022 :     case T_DOT_SAVEYMM256: /* syntax: .SAVEYMM256 ymmreg, offset */
; 2023 : #if EVEXSUPP
; 2024 :     case T_DOT_SAVEZMM512: /* syntax: .SAVEXMM512 zmmreg, offset */
; 2025 : #endif
; 2026 :     case T_DOT_SETFRAME:   /* syntax: .SETFRAME r64, offset      */
; 2027 :         if ( tokenarray[i].token != T_REG ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	je	SHORT $LN30@ExcFrameDi

; 2028 :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ExcFrameDi
$LN30@ExcFrameDi:

; 2029 :         }
; 2030 :         if ( token == T_DOT_SAVEXMM128 ) {

	cmp	DWORD PTR token$[rsp], 419		; 000001a3H
	jne	SHORT $LN31@ExcFrameDi

; 2031 :             if ( !( GetValueSp( tokenarray[i].tokval ) & OP_XMM ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN33@ExcFrameDi

; 2032 :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ExcFrameDi
$LN33@ExcFrameDi:

; 2033 :             }
; 2034 :         } 

	jmp	$LN32@ExcFrameDi
$LN31@ExcFrameDi:

; 2035 :         else if (token == T_DOT_SAVEYMM256) {

	cmp	DWORD PTR token$[rsp], 420		; 000001a4H
	jne	SHORT $LN34@ExcFrameDi

; 2036 :           if (!(GetValueSp(tokenarray[i].tokval) & OP_YMM)) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN36@ExcFrameDi

; 2037 :             return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ExcFrameDi
$LN36@ExcFrameDi:

; 2038 :           }
; 2039 :         }

	jmp	SHORT $LN35@ExcFrameDi
$LN34@ExcFrameDi:

; 2040 : #if EVEXSUPP
; 2041 :         else if (token == T_DOT_SAVEZMM512) {
; 2042 :           if (!(GetValueSp(tokenarray[i].tokval) & OP_ZMM)) {
; 2043 :             return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr));
; 2044 :           }
; 2045 :         }
; 2046 : #endif
; 2047 :         else {
; 2048 :             if ( !( GetValueSp( tokenarray[i].tokval ) & OP_R64 ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN37@ExcFrameDi

; 2049 :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ExcFrameDi
$LN37@ExcFrameDi:
$LN35@ExcFrameDi:
$LN32@ExcFrameDi:

; 2050 :             }
; 2051 :         }
; 2052 :         reg = GetRegNo( tokenarray[i].tokval );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR reg$[rsp], al

; 2053 :         // here is the problem
; 2054 :         if ( token == T_DOT_SAVEREG || token == T_DOT_SAVEXMM128 || token == T_DOT_SAVEYMM256

	cmp	DWORD PTR token$[rsp], 418		; 000001a2H
	je	SHORT $LN40@ExcFrameDi
	cmp	DWORD PTR token$[rsp], 419		; 000001a3H
	je	SHORT $LN40@ExcFrameDi
	cmp	DWORD PTR token$[rsp], 420		; 000001a4H
	jne	SHORT $LN38@ExcFrameDi
$LN40@ExcFrameDi:

; 2055 : #if EVEXSUPP
; 2056 :           || token == T_DOT_SAVEZMM512
; 2057 : #endif   
; 2058 :           )
; 2059 :             size = 8;

	mov	DWORD PTR size$[rsp], 8
	jmp	SHORT $LN39@ExcFrameDi
$LN38@ExcFrameDi:

; 2060 :         else
; 2061 :             size = 16;

	mov	DWORD PTR size$[rsp], 16
$LN39@ExcFrameDi:

; 2062 : 
; 2063 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 2064 :         if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN41@ExcFrameDi

; 2065 :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ExcFrameDi
$LN41@ExcFrameDi:

; 2066 :         }
; 2067 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 2068 :         if ( ERROR == EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN42@ExcFrameDi

; 2069 :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExcFrameDi
$LN42@ExcFrameDi:

; 2070 :         if ( opndx.kind == EXPR_ADDR && opndx.sym->state == SYM_UNDEFINED ) /* v2.11: allow forward references */

	cmp	DWORD PTR opndx$[rsp+60], 1
	jne	SHORT $LN43@ExcFrameDi
	mov	rax, QWORD PTR opndx$[rsp+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN43@ExcFrameDi

; 2071 :              ;

	jmp	SHORT $LN44@ExcFrameDi
$LN43@ExcFrameDi:

; 2072 :         else if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN45@ExcFrameDi

; 2073 :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN1@ExcFrameDi
$LN45@ExcFrameDi:
$LN44@ExcFrameDi:

; 2074 :         }
; 2075 :         if ( opndx.value & (size - 1) ) {

	mov	eax, DWORD PTR size$[rsp]
	dec	eax
	mov	ecx, DWORD PTR opndx$[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	SHORT $LN46@ExcFrameDi

; 2076 :             return( EmitError( BAD_ALIGNMENT_FOR_OFFSET_IN_UNWIND_CODE ) );

	mov	ecx, 257				; 00000101H
	call	EmitError
	jmp	$LN1@ExcFrameDi
$LN46@ExcFrameDi:

; 2077 :         }
; 2078 :         switch ( token ) {

	mov	eax, DWORD PTR token$[rsp]
	mov	DWORD PTR tv401[rsp], eax
	cmp	DWORD PTR tv401[rsp], 418		; 000001a2H
	je	SHORT $LN47@ExcFrameDi
	cmp	DWORD PTR tv401[rsp], 418		; 000001a2H
	jle	$LN4@ExcFrameDi
	cmp	DWORD PTR tv401[rsp], 420		; 000001a4H
	jle	$LN50@ExcFrameDi
	cmp	DWORD PTR tv401[rsp], 421		; 000001a5H
	je	$LN53@ExcFrameDi
	jmp	$LN4@ExcFrameDi
$LN47@ExcFrameDi:

; 2079 :         case T_DOT_SAVEREG:
; 2080 :             puc->OpInfo = reg;

	movzx	eax, BYTE PTR reg$[rsp]
	and	al, 15
	shl	al, 4
	mov	rcx, QWORD PTR puc$[rsp]
	movzx	ecx, BYTE PTR [rcx+1]
	and	cl, 15
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 2081 :             if ( opndx.value > 65536 * size ) {

	imul	eax, DWORD PTR size$[rsp], 65536	; 00010000H
	cmp	DWORD PTR opndx$[rsp], eax
	jbe	SHORT $LN48@ExcFrameDi

; 2082 :                 puc->FrameOffset = ( opndx.value >> 19 );

	mov	eax, DWORD PTR opndx$[rsp]
	sar	eax, 19
	mov	rcx, QWORD PTR puc$[rsp]
	mov	WORD PTR [rcx], ax

; 2083 :                 puc++;

	mov	rax, QWORD PTR puc$[rsp]
	add	rax, 2
	mov	QWORD PTR puc$[rsp], rax

; 2084 :                 puc->FrameOffset = ( opndx.value >> 3 );

	mov	eax, DWORD PTR opndx$[rsp]
	sar	eax, 3
	mov	rcx, QWORD PTR puc$[rsp]
	mov	WORD PTR [rcx], ax

; 2085 :                 puc++;

	mov	rax, QWORD PTR puc$[rsp]
	add	rax, 2
	mov	QWORD PTR puc$[rsp], rax

; 2086 :                 puc->UnwindOp = UWOP_SAVE_NONVOL_FAR;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	and	al, 240					; 000000f0H
	or	al, 5
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 2087 :                 unw_info.CountOfCodes += 3;

	movzx	eax, BYTE PTR unw_info+2
	add	eax, 3
	mov	BYTE PTR unw_info+2, al

; 2088 :             } else {

	jmp	SHORT $LN49@ExcFrameDi
$LN48@ExcFrameDi:

; 2089 :                 puc->FrameOffset = ( opndx.value >> 3 );

	mov	eax, DWORD PTR opndx$[rsp]
	sar	eax, 3
	mov	rcx, QWORD PTR puc$[rsp]
	mov	WORD PTR [rcx], ax

; 2090 :                 puc++;

	mov	rax, QWORD PTR puc$[rsp]
	add	rax, 2
	mov	QWORD PTR puc$[rsp], rax

; 2091 :                 puc->UnwindOp = UWOP_SAVE_NONVOL;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	and	al, 240					; 000000f0H
	or	al, 4
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 2092 :                 unw_info.CountOfCodes += 2;

	movzx	eax, BYTE PTR unw_info+2
	add	eax, 2
	mov	BYTE PTR unw_info+2, al
$LN49@ExcFrameDi:

; 2093 :             }
; 2094 :             puc->CodeOffset = ofs;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	ecx, BYTE PTR ofs$[rsp]
	mov	BYTE PTR [rax], cl

; 2095 :             puc->OpInfo = reg;

	movzx	eax, BYTE PTR reg$[rsp]
	and	al, 15
	shl	al, 4
	mov	rcx, QWORD PTR puc$[rsp]
	movzx	ecx, BYTE PTR [rcx+1]
	and	cl, 15
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 2096 :             break;

	jmp	$LN4@ExcFrameDi
$LN50@ExcFrameDi:

; 2097 :         case T_DOT_SAVEXMM128:
; 2098 :         case T_DOT_SAVEYMM256:
; 2099 :             if ( opndx.value > 65536 * size ) {

	imul	eax, DWORD PTR size$[rsp], 65536	; 00010000H
	cmp	DWORD PTR opndx$[rsp], eax
	jbe	SHORT $LN51@ExcFrameDi

; 2100 :                 puc->FrameOffset = ( opndx.value >> 20 );

	mov	eax, DWORD PTR opndx$[rsp]
	sar	eax, 20
	mov	rcx, QWORD PTR puc$[rsp]
	mov	WORD PTR [rcx], ax

; 2101 :                 puc++;

	mov	rax, QWORD PTR puc$[rsp]
	add	rax, 2
	mov	QWORD PTR puc$[rsp], rax

; 2102 :                 puc->FrameOffset = ( opndx.value >> 4 );

	mov	eax, DWORD PTR opndx$[rsp]
	sar	eax, 4
	mov	rcx, QWORD PTR puc$[rsp]
	mov	WORD PTR [rcx], ax

; 2103 :                 puc++;

	mov	rax, QWORD PTR puc$[rsp]
	add	rax, 2
	mov	QWORD PTR puc$[rsp], rax

; 2104 :                 puc->UnwindOp = UWOP_SAVE_XMM128_FAR;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	and	al, 240					; 000000f0H
	or	al, 9
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 2105 :                 unw_info.CountOfCodes += 3;

	movzx	eax, BYTE PTR unw_info+2
	add	eax, 3
	mov	BYTE PTR unw_info+2, al

; 2106 :             } else {

	jmp	SHORT $LN52@ExcFrameDi
$LN51@ExcFrameDi:

; 2107 :                 puc->FrameOffset = ( opndx.value >> 4 );

	mov	eax, DWORD PTR opndx$[rsp]
	sar	eax, 4
	mov	rcx, QWORD PTR puc$[rsp]
	mov	WORD PTR [rcx], ax

; 2108 :                 puc++;

	mov	rax, QWORD PTR puc$[rsp]
	add	rax, 2
	mov	QWORD PTR puc$[rsp], rax

; 2109 :                 puc->UnwindOp = UWOP_SAVE_XMM128;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	and	al, 240					; 000000f0H
	or	al, 8
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 2110 :                 unw_info.CountOfCodes += 2;

	movzx	eax, BYTE PTR unw_info+2
	add	eax, 2
	mov	BYTE PTR unw_info+2, al
$LN52@ExcFrameDi:

; 2111 :             }
; 2112 :             puc->CodeOffset = ofs;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	ecx, BYTE PTR ofs$[rsp]
	mov	BYTE PTR [rax], cl

; 2113 :             puc->OpInfo = reg;

	movzx	eax, BYTE PTR reg$[rsp]
	and	al, 15
	shl	al, 4
	mov	rcx, QWORD PTR puc$[rsp]
	movzx	ecx, BYTE PTR [rcx+1]
	and	cl, 15
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 2114 :             break;

	jmp	$LN4@ExcFrameDi
$LN53@ExcFrameDi:

; 2115 :         //case T_DOT_SAVEYMM256:
; 2116 :         //    if ( opndx.value > 65536 * size ) {
; 2117 :         //        puc->FrameOffset = ( opndx.value >> 20 );
; 2118 :         //        puc++;
; 2119 :         //        puc->FrameOffset = ( opndx.value >> 4 );
; 2120 :         //        puc++;
; 2121 :         //        puc->UnwindOp = UWOP_SAVE_YMM256_FAR;
; 2122 :         //        unw_info.CountOfCodes += 3;
; 2123 :         //    } else {
; 2124 :         //        puc->FrameOffset = ( opndx.value >> 4 );
; 2125 :         //        puc++;
; 2126 :         //        puc->UnwindOp = UWOP_SAVE_YMM256;
; 2127 :         //        unw_info.CountOfCodes += 2;
; 2128 :         //    }
; 2129 :         //    puc->CodeOffset = ofs;
; 2130 :         //    puc->OpInfo = reg;
; 2131 :         //    break;
; 2132 : #if EVEXSUPP
; 2133 :         case T_DOT_SAVEZMM512:
; 2134 :             if ( opndx.value > 65536 * size ) {
; 2135 :                 puc->FrameOffset = ( opndx.value >> 20 );
; 2136 :                 puc++;
; 2137 :                 puc->FrameOffset = ( opndx.value >> 4 );
; 2138 :                 puc++;
; 2139 :                 puc->UnwindOp = UWOP_SAVE_ZMM512_FAR;
; 2140 :                 unw_info.CountOfCodes += 3;
; 2141 :             } else {
; 2142 :                 puc->FrameOffset = ( opndx.value >> 4 );
; 2143 :                 puc++;
; 2144 :                 puc->UnwindOp = UWOP_SAVE_ZMM512;
; 2145 :                 unw_info.CountOfCodes += 2;
; 2146 :             }
; 2147 :             puc->CodeOffset = ofs;
; 2148 :             puc->OpInfo = reg;
; 2149 :             break;
; 2150 : #endif
; 2151 : 
; 2152 :         case T_DOT_SETFRAME:
; 2153 :             if ( opndx.uvalue > 240 ) {

	cmp	DWORD PTR opndx$[rsp], 240		; 000000f0H
	jbe	SHORT $LN54@ExcFrameDi

; 2154 :                 return( EmitConstError( &opndx ) );

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	$LN1@ExcFrameDi
$LN54@ExcFrameDi:

; 2155 :             }
; 2156 :             unw_info.FrameRegister = reg;

	movzx	eax, BYTE PTR reg$[rsp]
	and	al, 15
	movzx	ecx, BYTE PTR unw_info+3
	and	cl, 240					; 000000f0H
	or	cl, al
	movzx	eax, cl
	mov	BYTE PTR unw_info+3, al

; 2157 :             unw_info.FrameOffset = ( opndx.uvalue >> 4 );

	mov	eax, DWORD PTR opndx$[rsp]
	shr	eax, 4
	and	al, 15
	shl	al, 4
	movzx	ecx, BYTE PTR unw_info+3
	and	cl, 15
	or	cl, al
	movzx	eax, cl
	mov	BYTE PTR unw_info+3, al

; 2158 :             puc->CodeOffset = ofs;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	ecx, BYTE PTR ofs$[rsp]
	mov	BYTE PTR [rax], cl

; 2159 :             puc->UnwindOp = UWOP_SET_FPREG;

	mov	rax, QWORD PTR puc$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	and	al, 240					; 000000f0H
	or	al, 3
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 2160 :             //puc->OpInfo = ( opndx.uvalue >> 4 );
; 2161 :             puc->OpInfo = reg;

	movzx	eax, BYTE PTR reg$[rsp]
	and	al, 15
	shl	al, 4
	mov	rcx, QWORD PTR puc$[rsp]
	movzx	ecx, BYTE PTR [rcx+1]
	and	cl, 15
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR puc$[rsp]
	mov	BYTE PTR [rcx+1], al

; 2162 :             unw_info.CountOfCodes++;

	movzx	eax, BYTE PTR unw_info+2
	inc	al
	mov	BYTE PTR unw_info+2, al
$LN4@ExcFrameDi:
$LN2@ExcFrameDi:

; 2163 :             break;
; 2164 :         }
; 2165 :         break;
; 2166 :     }
; 2167 :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN55@ExcFrameDi

; 2168 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@ExcFrameDi
$LN55@ExcFrameDi:

; 2169 :     }
; 2170 :     /* v2.11: check if the table of codes has been exceeded */
; 2171 :     if ( oldcodes > unw_info.CountOfCodes ) {

	movzx	eax, BYTE PTR oldcodes$[rsp]
	movzx	ecx, BYTE PTR unw_info+2
	cmp	eax, ecx
	jle	SHORT $LN56@ExcFrameDi

; 2172 :         return( EmitErr( TOO_MANY_UNWIND_CODES_IN_FRAME_PROC ) );

	mov	ecx, 210				; 000000d2H
	call	EmitErr
	jmp	SHORT $LN1@ExcFrameDi
$LN56@ExcFrameDi:

; 2173 :     }
; 2174 :     DebugMsg1(("ExcFrameDirective() exit, ok\n" ));

	lea	rcx, OFFSET FLAT:$SG12188
	call	DoDebugMsg1

; 2175 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@ExcFrameDi:

; 2176 : }

	add	rsp, 200				; 000000c8H
	ret	0
	npad	2
$LN58@ExcFrameDi:
	DD	$LN10@ExcFrameDi
	DD	$LN22@ExcFrameDi
	DD	$LN24@ExcFrameDi
	DD	$LN26@ExcFrameDi
	DD	$LN29@ExcFrameDi
	DD	$LN29@ExcFrameDi
	DD	$LN29@ExcFrameDi
	DD	$LN29@ExcFrameDi
ExcFrameDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
tv66 = 32
procline$ = 40
i$ = 64
tokenarray$ = 72
EndpDir	PROC

; 1870 : {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 1871 : 	struct asym*        procline;
; 1872 : 
; 1873 : 	DebugMsg1(("EndpDir(%s) enter, curr ofs=% " I32_SPEC "X, CurrProc=%s\n", tokenarray[0].string_ptr, GetCurrOffset(), CurrProc ? CurrProc->sym.name : "NULL" ));

	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN7@EndpDir
	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN8@EndpDir
$LN7@EndpDir:
	lea	rax, OFFSET FLAT:$SG12105
	mov	QWORD PTR tv66[rsp], rax
$LN8@EndpDir:
	call	GetCurrOffset
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 0
	mov	r9, QWORD PTR tv66[rsp]
	mov	r8d, eax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	lea	rcx, OFFSET FLAT:$SG12106
	call	DoDebugMsg1

; 1874 :     if( i != 1 || tokenarray[2].token != T_FINAL ) {

	cmp	DWORD PTR i$[rsp], 1
	jne	SHORT $LN3@EndpDir
	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN2@EndpDir
$LN3@EndpDir:

; 1875 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@EndpDir
$LN2@EndpDir:

; 1876 :     }
; 1877 :     /* v2.10: "+ 1" added to CurrProc->sym.name_size */
; 1878 :     if( CurrProc &&

	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN4@EndpDir
	mov	rax, QWORD PTR CurrProc
	movzx	eax, BYTE PTR [rax+72]
	inc	eax
	cdqe
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 0
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	mov	rax, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rax+8]
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	jne	SHORT $LN4@EndpDir

; 1879 :        ( SymCmpFunc(CurrProc->sym.name, tokenarray[0].string_ptr, CurrProc->sym.name_size + 1 ) == 0 ) ) {
; 1880 :      
; 1881 : 		/* Reset the current source code line relating to the PROC */
; 1882 : 		procline = SymFind("@ProcLine");

	lea	rcx, OFFSET FLAT:$SG12111
	call	SymFind
	mov	QWORD PTR procline$[rsp], rax

; 1883 : 		procline->value = 0;

	mov	rax, QWORD PTR procline$[rsp]
	mov	DWORD PTR [rax+16], 0

; 1884 : 
; 1885 : 		ProcFini( CurrProc );

	mov	rcx, QWORD PTR CurrProc
	call	ProcFini

; 1886 :     } else {

	jmp	SHORT $LN5@EndpDir
$LN4@EndpDir:

; 1887 :         return( EmitErr( UNMATCHED_BLOCK_NESTING, tokenarray[0].string_ptr ) );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 142				; 0000008eH
	call	EmitErr
	jmp	SHORT $LN1@EndpDir
$LN5@EndpDir:

; 1888 :     }
; 1889 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@EndpDir:

; 1890 : }

	add	rsp, 56					; 00000038H
	ret	0
EndpDir	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
curr$ = 48
tv73 = 56
proc$ = 80
ProcFini PROC

; 1794 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1795 :     struct dsym *curr;
; 1796 :     /* v2.06: emit an error if current segment isn't equal to
; 1797 :      * the one of the matching PROC directive. Close the proc anyway!
; 1798 :      */
; 1799 :     if ( proc->sym.segment == &CurrSeg->sym ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR proc$[rsp]
	cmp	QWORD PTR [rcx+24], rax
	jne	SHORT $LN14@ProcFini

; 1800 :         proc->sym.total_size = GetCurrOffset() - proc->sym.offset;

	call	GetCurrOffset
	mov	rcx, QWORD PTR proc$[rsp]
	sub	eax, DWORD PTR [rcx+16]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	DWORD PTR [rcx+56], eax

; 1801 :     } else {

	jmp	$LN15@ProcFini
$LN14@ProcFini:

; 1802 :         DebugMsg1(("ProcFini(%s): unmatched block nesting error, proc->seg=%s, CurrSeg=%s\n",

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN27@ProcFini
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv73[rsp], rax
	jmp	SHORT $LN28@ProcFini
$LN27@ProcFini:
	lea	rax, OFFSET FLAT:$SG12083
	mov	QWORD PTR tv73[rsp], rax
$LN28@ProcFini:
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	r9, QWORD PTR tv73[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12084
	call	DoDebugMsg1

; 1803 :                    proc->sym.name, proc->sym.segment->name, CurrSeg ? CurrSeg->sym.name : "NULL" ));
; 1804 :         EmitErr( UNMATCHED_BLOCK_NESTING, proc->sym.name );

	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 142				; 0000008eH
	call	EmitErr

; 1805 :         proc->sym.total_size = CurrProc->sym.segment->offset - proc->sym.offset;

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	eax, DWORD PTR [rax+16]
	sub	eax, ecx
	mov	rcx, QWORD PTR proc$[rsp]
	mov	DWORD PTR [rcx+56], eax
$LN15@ProcFini:

; 1806 :     }
; 1807 : 
; 1808 :     /* v2.03: for W3+, check for unused params and locals */
; 1809 :     if ( Options.warning_level > 2 && Parse_Pass == PASS_1 ) {

	movzx	eax, BYTE PTR Options+13
	cmp	eax, 2
	jle	$LN16@ProcFini
	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN16@ProcFini

; 1810 :         for ( curr = proc->e.procinfo->paralist; curr; curr = curr->nextparam ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@ProcFini
$LN2@ProcFini:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN4@ProcFini:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@ProcFini

; 1811 :             if ( curr->sym.used == FALSE )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN17@ProcFini

; 1812 :                 EmitWarn( 3, PROCEDURE_ARGUMENT_OR_LOCAL_NOT_REFERENCED, curr->sym.name );

	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 266				; 0000010aH
	mov	ecx, 3
	call	EmitWarn
$LN17@ProcFini:

; 1813 :         }

	jmp	SHORT $LN2@ProcFini
$LN3@ProcFini:

; 1814 :         for ( curr = proc->e.procinfo->locallist; curr; curr = curr->nextlocal ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN7@ProcFini
$LN5@ProcFini:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN7@ProcFini:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN6@ProcFini

; 1815 :             if ( curr->sym.used == FALSE )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@ProcFini

; 1816 :                 EmitWarn( 3, PROCEDURE_ARGUMENT_OR_LOCAL_NOT_REFERENCED, curr->sym.name );

	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 266				; 0000010aH
	mov	ecx, 3
	call	EmitWarn
$LN18@ProcFini:

; 1817 :         }

	jmp	SHORT $LN5@ProcFini
$LN6@ProcFini:
$LN16@ProcFini:

; 1818 :     }
; 1819 : #if AMD64_SUPPORT
; 1820 :     /* save stack space reserved for INVOKE if OPTION WIN64:2 is set */
; 1821 :     if ( Parse_Pass == PASS_1 &&
; 1822 :         ModuleInfo.fctype == FCT_WIN64 &&

	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN19@ProcFini
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	$LN19@ProcFini
	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 2
	test	eax, eax
	je	$LN19@ProcFini

; 1823 :         ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) ) {
; 1824 : 		proc->e.procinfo->ReservedStack = sym_ReservedStack->value;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR sym_ReservedStack
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax+96], ecx

; 1825 :         DebugMsg1(("ProcFini(%s): localsize=%u ReservedStack=%u\n", proc->sym.name, proc->e.procinfo->localsize, proc->e.procinfo->ReservedStack ));

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	r9d, DWORD PTR [rax+96]
	mov	r8d, DWORD PTR [rcx+36]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12089
	call	DoDebugMsg1

; 1826 : #if STACKBASESUPP
; 1827 :         if ( proc->e.procinfo->fpo ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN20@ProcFini

; 1828 :             for ( curr = proc->e.procinfo->locallist; curr; curr = curr->nextlocal ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN10@ProcFini
$LN8@ProcFini:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN10@ProcFini:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN9@ProcFini

; 1829 :                 DebugMsg1(("ProcFini(%s): FPO, offset for %s %8d -> %8d\n", proc->sym.name, curr->sym.name, curr->sym.offset, curr->sym.offset + proc->e.procinfo->ReservedStack ));

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	add	ecx, DWORD PTR [rax+96]
	mov	eax, ecx
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR curr$[rsp]
	mov	r9d, DWORD PTR [rax+16]
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12091
	call	DoDebugMsg1

; 1830 :                 curr->sym.offset += proc->e.procinfo->ReservedStack;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	add	ecx, DWORD PTR [rax+96]
	mov	eax, ecx
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 1831 :             }

	jmp	SHORT $LN8@ProcFini
$LN9@ProcFini:

; 1832 :             for ( curr = proc->e.procinfo->paralist; curr; curr = curr->nextparam ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN13@ProcFini
$LN11@ProcFini:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN13@ProcFini:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN12@ProcFini

; 1833 :                 DebugMsg1(("ProcFini(%s): FPO, offset for %s %8d -> %8d\n", proc->sym.name, curr->sym.name, curr->sym.offset, curr->sym.offset + proc->e.procinfo->ReservedStack ));

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	add	ecx, DWORD PTR [rax+96]
	mov	eax, ecx
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR curr$[rsp]
	mov	r9d, DWORD PTR [rax+16]
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12092
	call	DoDebugMsg1

; 1834 :                 curr->sym.offset += proc->e.procinfo->ReservedStack;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	add	ecx, DWORD PTR [rax+96]
	mov	eax, ecx
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 1835 :             }

	jmp	SHORT $LN11@ProcFini
$LN12@ProcFini:
$LN20@ProcFini:
$LN19@ProcFini:

; 1836 :         }
; 1837 : #endif
; 1838 :     }
; 1839 : 
; 1840 :     /* create the .pdata and .xdata stuff */
; 1841 :     if ( proc->e.procinfo->isframe ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN21@ProcFini

; 1842 : #if FASTPASS
; 1843 :         LstSetPosition(); /* needed if generated code is done BEFORE the line is listed */

	call	LstSetPosition

; 1844 : #endif
; 1845 :         WriteSEHData( proc );

	mov	rcx, QWORD PTR proc$[rsp]
	call	WriteSEHData
$LN21@ProcFini:

; 1846 :     }
; 1847 : #endif
; 1848 :     if ( ModuleInfo.list )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN22@ProcFini

; 1849 :         LstWrite( LSTTYPE_LABEL, 0, NULL );

	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, 7
	call	LstWrite
$LN22@ProcFini:

; 1850 : 
; 1851 :     /* create the list of locals */
; 1852 :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN23@ProcFini

; 1853 :         /* in case the procedure is empty, init addresses of local variables ( for proper listing ) */
; 1854 :         if( ProcStatus & PRST_PROLOGUE_NOT_DONE )

	mov	eax, DWORD PTR ProcStatus
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN24@ProcFini

; 1855 :             SetLocalOffsets( CurrProc->e.procinfo );

	mov	rax, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rax+96]
	call	SetLocalOffsets
$LN24@ProcFini:

; 1856 :         SymGetLocal( (struct asym *)CurrProc );

	mov	rcx, QWORD PTR CurrProc
	call	SymGetLocal
$LN23@ProcFini:

; 1857 :     }
; 1858 : 
; 1859 :     CurrProc = pop_proc();

	call	pop_proc
	mov	QWORD PTR CurrProc, rax

; 1860 :     if ( CurrProc )

	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN25@ProcFini

; 1861 :         SymSetLocal( (struct asym *)CurrProc );  /* restore local symbol table */

	mov	rcx, QWORD PTR CurrProc
	call	SymSetLocal
$LN25@ProcFini:

; 1862 : 
; 1863 :     ProcStatus = 0; /* in case there was an empty PROC/ENDP pair */

	mov	DWORD PTR ProcStatus, 0

; 1864 : }

	add	rsp, 72					; 00000048H
	ret	0
ProcFini ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
curr$ = 64
ymmflag$ = 72
cntstd$ = 76
xmmflag$ = 80
cntxmm$ = 84
rspalign$ = 88
start$ = 92
align$ = 96
itemsize$1 = 100
cnt$ = 104
cnt$2 = 108
localadj$3 = 112
paramadj$4 = 116
regist$ = 120
regs$5 = 128
tv219 = 136
n$6 = 140
info$ = 160
SetLocalOffsets PROC

; 3038 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 3039 :     struct dsym *curr;
; 3040 : #if AMD64_SUPPORT || STACKBASESUPP
; 3041 :     int         cntxmm = 0;

	mov	DWORD PTR cntxmm$[rsp], 0

; 3042 :     int         cntstd = 0;

	mov	DWORD PTR cntstd$[rsp], 0

; 3043 :     int         start = 0;

	mov	DWORD PTR start$[rsp], 0

; 3044 :     uint_16             *regist;
; 3045 :     int                 cnt;
; 3046 : 
; 3047 : #endif
; 3048 : #if AMD64_SUPPORT
; 3049 :     unsigned char       xmmflag = 1;

	mov	BYTE PTR xmmflag$[rsp], 1

; 3050 :     unsigned char       ymmflag = 0;

	mov	BYTE PTR ymmflag$[rsp], 0

; 3051 :     int         rspalign = FALSE;

	mov	DWORD PTR rspalign$[rsp], 0

; 3052 : #endif
; 3053 :     int         align = CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	DWORD PTR align$[rsp], eax

; 3054 : #if EVEXSUPP
; 3055 :     unsigned char       zmmflag = 0;
; 3056 : #endif
; 3057 :     //if ( Parse_Pass != PASS_1 ) /* everything is done in pass 1 */
; 3058 :     //    return;
; 3059 : 
; 3060 : #if AMD64_SUPPORT
; 3061 :     regist = info->regslist;

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR regist$[rsp], rax

; 3062 :     if ( info->isframe || ( ModuleInfo.fctype == FCT_WIN64 && ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) ) ) {

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@SetLocalOf
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN17@SetLocalOf
	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 2
	test	eax, eax
	je	SHORT $LN17@SetLocalOf
$LN18@SetLocalOf:

; 3063 :         rspalign = TRUE;

	mov	DWORD PTR rspalign$[rsp], 1

; 3064 :         if ( ModuleInfo.win64_flags & W64F_STACKALIGN16 )

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 4
	test	eax, eax
	je	SHORT $LN19@SetLocalOf

; 3065 :             align = 16;

	mov	DWORD PTR align$[rsp], 16
$LN19@SetLocalOf:
$LN17@SetLocalOf:

; 3066 :     }
; 3067 : #endif
; 3068 : #if AMD64_SUPPORT || STACKBASESUPP
; 3069 :     /* in 64-bit, if the FRAME attribute is set, the space for the registers
; 3070 :      * saved by the USES clause is located ABOVE the local variables!
; 3071 :      * v2.09: if stack space is to be reserved for INVOKE ( option WIN64:2 ),
; 3072 :      * the registers are also saved ABOVE the local variables.
; 3073 :      */
; 3074 :     if (info->regslist){

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN20@SetLocalOf

; 3075 :       for (cnt = *regist++; cnt; cnt--, regist++) {

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR cnt$[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax
	jmp	SHORT $LN4@SetLocalOf
$LN2@SetLocalOf:
	mov	eax, DWORD PTR cnt$[rsp]
	dec	eax
	mov	DWORD PTR cnt$[rsp], eax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax
$LN4@SetLocalOf:
	cmp	DWORD PTR cnt$[rsp], 0
	je	SHORT $LN3@SetLocalOf

; 3076 :         if (GetValueSp(*regist) & OP_XMM)

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN21@SetLocalOf

; 3077 :           xmmflag = 1;

	mov	BYTE PTR xmmflag$[rsp], 1
	jmp	SHORT $LN22@SetLocalOf
$LN21@SetLocalOf:

; 3078 :         else if (GetValueSp(*regist) & OP_YMM){

	mov	rax, QWORD PTR regist$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN23@SetLocalOf

; 3079 :           ymmflag = 1;

	mov	BYTE PTR ymmflag$[rsp], 1
$LN23@SetLocalOf:
$LN22@SetLocalOf:

; 3080 :         }
; 3081 : #if EVEXSUPP    
; 3082 :         else if (GetValueSp(*regist) & OP_ZMM){
; 3083 :           zmmflag = 1;
; 3084 :         }
; 3085 : #endif
; 3086 :       }

	jmp	SHORT $LN2@SetLocalOf
$LN3@SetLocalOf:
$LN20@SetLocalOf:

; 3087 :     }
; 3088 :     if (ymmflag) XYZMMsize = 32;

	movzx	eax, BYTE PTR ymmflag$[rsp]
	test	eax, eax
	je	SHORT $LN24@SetLocalOf
	mov	DWORD PTR XYZMMsize, 32			; 00000020H
	jmp	SHORT $LN25@SetLocalOf
$LN24@SetLocalOf:

; 3089 :     else XYZMMsize = 16;

	mov	DWORD PTR XYZMMsize, 16
$LN25@SetLocalOf:

; 3090 : 
; 3091 :     if (
; 3092 : #if STACKBASESUPP
; 3093 :         info->fpo
; 3094 : #endif
; 3095 : #if AMD64_SUPPORT
; 3096 :         || rspalign

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN27@SetLocalOf
	cmp	DWORD PTR rspalign$[rsp], 0
	je	$LN26@SetLocalOf
$LN27@SetLocalOf:

; 3097 : #endif
; 3098 :        ) {
; 3099 :         /* count registers to be saved ABOVE local variables.
; 3100 :          * v2.06: the list may contain xmm registers, which have size 16!
; 3101 :          */
; 3102 :         if ( info->regslist ) {

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN28@SetLocalOf

; 3103 :             int         cnt;
; 3104 :             uint_16     *regs;
; 3105 :             for( regs = info->regslist, cnt = *regs++; cnt; cnt--, regs++ )

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR regs$5[rsp], rax
	mov	rax, QWORD PTR regs$5[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR cnt$2[rsp], eax
	mov	rax, QWORD PTR regs$5[rsp]
	add	rax, 2
	mov	QWORD PTR regs$5[rsp], rax
	jmp	SHORT $LN7@SetLocalOf
$LN5@SetLocalOf:
	mov	eax, DWORD PTR cnt$2[rsp]
	dec	eax
	mov	DWORD PTR cnt$2[rsp], eax
	mov	rax, QWORD PTR regs$5[rsp]
	add	rax, 2
	mov	QWORD PTR regs$5[rsp], rax
$LN7@SetLocalOf:
	cmp	DWORD PTR cnt$2[rsp], 0
	je	SHORT $LN6@SetLocalOf

; 3106 :                 if (( GetValueSp( *regs ) & OP_XMM )||( GetValueSp( *regs ) & OP_YMM )

	mov	rax, QWORD PTR regs$5[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN31@SetLocalOf
	mov	rax, QWORD PTR regs$5[rsp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN29@SetLocalOf
$LN31@SetLocalOf:

; 3107 : #if EVEXSUPP    
; 3108 :                   || ( GetValueSp( *regs ) & OP_ZMM )
; 3109 : #endif
; 3110 :                 )cntxmm++;

	mov	eax, DWORD PTR cntxmm$[rsp]
	inc	eax
	mov	DWORD PTR cntxmm$[rsp], eax
	jmp	SHORT $LN30@SetLocalOf
$LN29@SetLocalOf:

; 3111 :                 else
; 3112 :                   cntstd++;

	mov	eax, DWORD PTR cntstd$[rsp]
	inc	eax
	mov	DWORD PTR cntstd$[rsp], eax
$LN30@SetLocalOf:
	jmp	SHORT $LN5@SetLocalOf
$LN6@SetLocalOf:
$LN28@SetLocalOf:

; 3113 :         }        
; 3114 :         /* in case there's no frame register, adjust start offset. */
; 3115 :         if ( info->parasize == 0 && info->locallist == NULL  )

	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN32@SetLocalOf
	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN32@SetLocalOf

; 3116 :             start = CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	DWORD PTR start$[rsp], eax
$LN32@SetLocalOf:

; 3117 :         if (info->fpo && !(ModuleInfo.win64_flags & W64F_HABRAN)) start = CurrWordSize;

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN33@SetLocalOf
	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	jne	SHORT $LN33@SetLocalOf
	movzx	eax, BYTE PTR ModuleInfo+406
	mov	DWORD PTR start$[rsp], eax
$LN33@SetLocalOf:

; 3118 : #if AMD64_SUPPORT
; 3119 :         if (ModuleInfo.win64_flags & W64F_HABRAN){

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	je	SHORT $LN34@SetLocalOf

; 3120 :          // info->localsize += start;
; 3121 :           cntstd = info->pushed_reg;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+104]
	mov	DWORD PTR cntstd$[rsp], eax

; 3122 :           if (rspalign && cntxmm) {

	cmp	DWORD PTR rspalign$[rsp], 0
	je	SHORT $LN36@SetLocalOf
	cmp	DWORD PTR cntxmm$[rsp], 0
	je	SHORT $LN36@SetLocalOf

; 3123 :               if (!(cntstd & 1)) info->localsize += 8;

	mov	eax, DWORD PTR cntstd$[rsp]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN37@SetLocalOf
	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	add	eax, 8
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+36], eax
$LN37@SetLocalOf:

; 3124 :               info->localsize += XYZMMsize * cntxmm;

	mov	eax, DWORD PTR XYZMMsize
	imul	eax, DWORD PTR cntxmm$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	add	eax, DWORD PTR [rcx+36]
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+36], eax
$LN36@SetLocalOf:

; 3125 :               }
; 3126 :            }

	jmp	SHORT $LN35@SetLocalOf
$LN34@SetLocalOf:

; 3127 :         else 
; 3128 :         {
; 3129 :           if (rspalign) {

	cmp	DWORD PTR rspalign$[rsp], 0
	je	SHORT $LN38@SetLocalOf

; 3130 :             info->localsize = start + cntstd * CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	ecx, DWORD PTR cntstd$[rsp]
	imul	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR start$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 3131 :             if (cntxmm) {

	cmp	DWORD PTR cntxmm$[rsp], 0
	je	SHORT $LN39@SetLocalOf

; 3132 :               info->localsize += XYZMMsize * cntxmm;

	mov	eax, DWORD PTR XYZMMsize
	imul	eax, DWORD PTR cntxmm$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	add	eax, DWORD PTR [rcx+36]
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 3133 :               info->localsize = ROUND_UP(info->localsize, 16);

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	add	eax, 15
	and	eax, -16				; fffffff0H
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+36], eax
$LN39@SetLocalOf:
$LN38@SetLocalOf:
$LN35@SetLocalOf:

; 3134 :             }
; 3135 :           }
; 3136 :         }
; 3137 : #endif
; 3138 :         DebugMsg1(("SetLocalOffsets(%s): cntxmm=%u cntstd=%u start=%u align=%u localsize=%u\n", CurrProc->sym.name, cntxmm, cntstd, start, align, info->localsize ));

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR align$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR start$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR cntstd$[rsp]
	mov	r8d, DWORD PTR cntxmm$[rsp]
	mov	rax, QWORD PTR CurrProc
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12654
	call	DoDebugMsg1
$LN26@SetLocalOf:

; 3139 :     }
; 3140 : #endif
; 3141 : 
; 3142 :     /* scan the locals list and set member sym.offset */
; 3143 :     for( curr = info->locallist; curr; curr = curr->nextlocal ) {

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN10@SetLocalOf
$LN8@SetLocalOf:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN10@SetLocalOf:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN9@SetLocalOf

; 3144 :         uint_32 itemsize = ( curr->sym.total_size == 0 ? 0 : curr->sym.total_size / curr->sym.total_length );

	mov	rax, QWORD PTR curr$[rsp]
	cmp	DWORD PTR [rax+56], 0
	jne	SHORT $LN58@SetLocalOf
	mov	DWORD PTR tv219[rsp], 0
	jmp	SHORT $LN59@SetLocalOf
$LN58@SetLocalOf:
	xor	edx, edx
	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	rcx, QWORD PTR curr$[rsp]
	div	DWORD PTR [rcx+64]
	mov	DWORD PTR tv219[rsp], eax
$LN59@SetLocalOf:
	mov	eax, DWORD PTR tv219[rsp]
	mov	DWORD PTR itemsize$1[rsp], eax

; 3145 :         if (ModuleInfo.win64_flags & W64F_HABRAN){

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	je	SHORT $LN40@SetLocalOf

; 3146 :           int n = 0;

	mov	DWORD PTR n$6[rsp], 0

; 3147 :           if (curr->sym.isarray) n = curr->sym.total_size & 0x7;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN41@SetLocalOf
	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+56]
	and	eax, 7
	mov	DWORD PTR n$6[rsp], eax
$LN41@SetLocalOf:

; 3148 :           curr->sym.offset = info->localsize + n; //that works

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	add	eax, DWORD PTR n$6[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+16], eax
$LN40@SetLocalOf:

; 3149 :         }
; 3150 :         info->localsize += curr->sym.total_size;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	rcx, QWORD PTR curr$[rsp]
	add	eax, DWORD PTR [rcx+56]
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 3151 :         if ( itemsize > align )

	mov	eax, DWORD PTR align$[rsp]
	cmp	DWORD PTR itemsize$1[rsp], eax
	jbe	SHORT $LN42@SetLocalOf

; 3152 :             info->localsize = ROUND_UP( info->localsize, align );

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	ecx, DWORD PTR align$[rsp]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	ecx, DWORD PTR align$[rsp]
	dec	ecx
	not	ecx
	and	eax, ecx
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+36], eax
	jmp	SHORT $LN43@SetLocalOf
$LN42@SetLocalOf:

; 3153 :         else if ( itemsize ) /* v2.04: skip if size == 0 */

	cmp	DWORD PTR itemsize$1[rsp], 0
	je	SHORT $LN44@SetLocalOf

; 3154 :             info->localsize = ROUND_UP( info->localsize, itemsize );

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	ecx, DWORD PTR itemsize$1[rsp]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	ecx, DWORD PTR itemsize$1[rsp]
	dec	ecx
	not	ecx
	and	eax, ecx
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+36], eax
$LN44@SetLocalOf:
$LN43@SetLocalOf:

; 3155 :         if (!(ModuleInfo.win64_flags & W64F_HABRAN))

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	jne	SHORT $LN45@SetLocalOf

; 3156 :         curr->sym.offset = - info->localsize;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	neg	eax
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+16], eax
$LN45@SetLocalOf:

; 3157 :         DebugMsg1(("SetLocalOffsets(%s): offset of %s (size=%u) set to %d\n", CurrProc->sym.name, curr->sym.name, curr->sym.total_size, curr->sym.offset));

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR curr$[rsp]
	mov	r9d, DWORD PTR [rax+56]
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR CurrProc
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12661
	call	DoDebugMsg1

; 3158 :     }

	jmp	$LN8@SetLocalOf
$LN9@SetLocalOf:

; 3159 : 
; 3160 :     /* v2.11: localsize must be rounded before offset adjustment if fpo */
; 3161 :     if (!(ModuleInfo.win64_flags & W64F_HABRAN))

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	jne	SHORT $LN46@SetLocalOf

; 3162 :     info->localsize = ROUND_UP( info->localsize, CurrWordSize );

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	rcx, QWORD PTR info$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	lea	eax, DWORD PTR [rcx+rax-1]
	movzx	ecx, BYTE PTR ModuleInfo+406
	dec	ecx
	not	ecx
	and	eax, ecx
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+36], eax
$LN46@SetLocalOf:

; 3163 : #if AMD64_SUPPORT
; 3164 :     /* RSP 16-byte alignment? */
; 3165 :     if ( rspalign ) {

	cmp	DWORD PTR rspalign$[rsp], 0
	je	SHORT $LN47@SetLocalOf

; 3166 :       if (ModuleInfo.win64_flags & W64F_HABRAN)info->localsize = ROUND_UP(info->localsize, 8);

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	je	SHORT $LN48@SetLocalOf
	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	add	eax, 7
	and	eax, -8					; fffffff8H
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+36], eax
	jmp	SHORT $LN49@SetLocalOf
$LN48@SetLocalOf:

; 3167 :       else  info->localsize = ROUND_UP( info->localsize, 16 );

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	add	eax, 15
	and	eax, -16				; fffffff0H
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+36], eax
$LN49@SetLocalOf:
$LN47@SetLocalOf:

; 3168 :     }
; 3169 : #endif
; 3170 : 
; 3171 :     DebugMsg1(("SetLocalOffsets(%s): localsize=%u after processing locals\n", CurrProc->sym.name, info->localsize ));

	mov	rax, QWORD PTR info$[rsp]
	mov	r8d, DWORD PTR [rax+36]
	mov	rax, QWORD PTR CurrProc
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12666
	call	DoDebugMsg1

; 3172 : 
; 3173 : #if STACKBASESUPP
; 3174 :     /* v2.11: recalculate offsets for params and locals if there's no frame pointer.
; 3175 :      * Problem in 64-bit: option win64:2 triggers the "stack space reservation" feature -
; 3176 :      * but the final value of this space is known at the procedure's END only.
; 3177 :      * Hence in this case the values calculated below are "preliminary".
; 3178 :      */
; 3179 :     if (info->fpo) {

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN50@SetLocalOf

; 3180 :       unsigned localadj;
; 3181 :       unsigned paramadj;
; 3182 : #if AMD64_SUPPORT
; 3183 :       if (rspalign) {

	cmp	DWORD PTR rspalign$[rsp], 0
	je	SHORT $LN51@SetLocalOf

; 3184 :         localadj = info->localsize;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR localadj$3[rsp], eax

; 3185 :         if (!(ModuleInfo.win64_flags & W64F_HABRAN))

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	jne	SHORT $LN53@SetLocalOf

; 3186 :           paramadj = info->localsize - CurrWordSize - start;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	rcx, QWORD PTR info$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	sub	ecx, eax
	mov	eax, ecx
	sub	eax, DWORD PTR start$[rsp]
	mov	DWORD PTR paramadj$4[rsp], eax
$LN53@SetLocalOf:

; 3187 :       }

	jmp	SHORT $LN52@SetLocalOf
$LN51@SetLocalOf:

; 3188 :       else 
; 3189 :       {
; 3190 : #endif
; 3191 :         localadj = info->localsize + cntstd * CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	ecx, DWORD PTR cntstd$[rsp]
	imul	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR info$[rsp]
	add	eax, DWORD PTR [rcx+36]
	mov	DWORD PTR localadj$3[rsp], eax

; 3192 :         paramadj = info->localsize + cntstd * CurrWordSize - CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	ecx, DWORD PTR cntstd$[rsp]
	imul	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR info$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	add	ecx, eax
	mov	eax, ecx
	movzx	ecx, BYTE PTR ModuleInfo+406
	sub	eax, ecx
	mov	DWORD PTR paramadj$4[rsp], eax
$LN52@SetLocalOf:

; 3193 : #if AMD64_SUPPORT
; 3194 :       }
; 3195 : #endif
; 3196 :       if (!(ModuleInfo.win64_flags & W64F_HABRAN)){

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	jne	$LN54@SetLocalOf

; 3197 :         DebugMsg1(("SetLocalOffsets(%s): FPO, adjusting offsets\n", CurrProc->sym.name));

	mov	rax, QWORD PTR CurrProc
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12672
	call	DoDebugMsg1

; 3198 :         /* subtract CurrWordSize value for params, since no space is required to save the frame pointer value */
; 3199 :         for (curr = info->locallist; curr; curr = curr->nextlocal) {

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN13@SetLocalOf
$LN11@SetLocalOf:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN13@SetLocalOf:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN12@SetLocalOf

; 3200 :           DebugMsg1(("SetLocalOffsets(%s): FPO, offset for %s %4d -> %4d\n", CurrProc->sym.name, curr->sym.name, curr->sym.offset, curr->sym.offset + localadj));

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+16]
	add	eax, DWORD PTR localadj$3[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR curr$[rsp]
	mov	r9d, DWORD PTR [rax+16]
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR CurrProc
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12673
	call	DoDebugMsg1

; 3201 :           curr->sym.offset += localadj;

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+16]
	add	eax, DWORD PTR localadj$3[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 3202 :         }

	jmp	SHORT $LN11@SetLocalOf
$LN12@SetLocalOf:

; 3203 :         for (curr = info->paralist; curr; curr = curr->nextparam) {

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN16@SetLocalOf
$LN14@SetLocalOf:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN16@SetLocalOf:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN15@SetLocalOf

; 3204 :           DebugMsg1(("SetLocalOffsets(%s): FPO, offset for %s %4d -> %4d\n", CurrProc->sym.name, curr->sym.name, curr->sym.offset, curr->sym.offset + paramadj));

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+16]
	add	eax, DWORD PTR paramadj$4[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR curr$[rsp]
	mov	r9d, DWORD PTR [rax+16]
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR CurrProc
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12674
	call	DoDebugMsg1

; 3205 :           curr->sym.offset += paramadj;

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+16]
	add	eax, DWORD PTR paramadj$4[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 3206 :         }

	jmp	SHORT $LN14@SetLocalOf
$LN15@SetLocalOf:
$LN54@SetLocalOf:
$LN50@SetLocalOf:

; 3207 :       }
; 3208 :     }
; 3209 : #endif
; 3210 : 
; 3211 : #if AMD64_SUPPORT
; 3212 :     /* v2.12: if the space used for register saves has been added to localsize,
; 3213 :      * the part that covers "pushed" GPRs has to be subtracted now, before prologue code is generated.
; 3214 :      */
; 3215 :     if (!(ModuleInfo.win64_flags & W64F_HABRAN)){

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	jne	SHORT $LN55@SetLocalOf

; 3216 :       if (rspalign) {

	cmp	DWORD PTR rspalign$[rsp], 0
	je	SHORT $LN56@SetLocalOf

; 3217 :         info->localsize -= cntstd * 8 + start;

	mov	eax, DWORD PTR start$[rsp]
	mov	ecx, DWORD PTR cntstd$[rsp]
	lea	eax, DWORD PTR [rax+rcx*8]
	mov	rcx, QWORD PTR info$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	sub	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 3218 :         DebugMsg1(("SetLocalOffsets(%s): final localsize=%u\n", CurrProc->sym.name, info->localsize));

	mov	rax, QWORD PTR info$[rsp]
	mov	r8d, DWORD PTR [rax+36]
	mov	rax, QWORD PTR CurrProc
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12677
	call	DoDebugMsg1
$LN56@SetLocalOf:
$LN55@SetLocalOf:

; 3219 :       }
; 3220 :     }
; 3221 : #endif
; 3222 : }

	add	rsp, 152				; 00000098H
	ret	0
SetLocalOffsets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
olddotname$ = 64
i$ = 68
segname$ = 72
xdataofs$ = 80
simplespec$ = 84
tv129 = 88
tv147 = 92
pfx$1 = 96
xdata$ = 104
$T2 = 112
$T3 = 120
tv261 = 128
segnamebuff$ = 136
buffer$ = 160
__$ArrayPad$ = 288
proc$ = 320
WriteSEHData PROC

; 1694 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 312				; 00000138H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1695 :     struct dsym *xdata;
; 1696 :     char *segname = ".xdata";

	lea	rax, OFFSET FLAT:$SG12026
	mov	QWORD PTR segname$[rsp], rax

; 1697 :     int i;
; 1698 :     int simplespec;
; 1699 :     uint_8 olddotname;
; 1700 :     uint_32 xdataofs = 0;

	mov	DWORD PTR xdataofs$[rsp], 0

; 1701 :     char segnamebuff[12];
; 1702 :     char buffer[128];
; 1703 : 
; 1704 : 	/* 2016-02-10 John Hankinson - Don't bother writing SEH data for ELF64 Win64 ABI hack */
; 1705 : 	if (Options.output_format == OFORMAT_ELF)

	cmp	DWORD PTR Options+160, 3
	jne	SHORT $LN5@WriteSEHDa

; 1706 : 	return;

	jmp	$LN1@WriteSEHDa
$LN5@WriteSEHDa:

; 1707 : 
; 1708 :     if ( endprolog_found == FALSE ) {

	movzx	eax, BYTE PTR endprolog_found
	test	eax, eax
	jne	SHORT $LN6@WriteSEHDa

; 1709 :         EmitErr( MISSING_ENDPROLOG, proc->sym.name );

	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 260				; 00000104H
	call	EmitErr
$LN6@WriteSEHDa:

; 1710 :     }
; 1711 :     if ( unw_segs_defined )

	movzx	eax, BYTE PTR unw_segs_defined
	test	eax, eax
	je	SHORT $LN7@WriteSEHDa

; 1712 :         AddLineQueueX("%s %r", segname, T_SEGMENT );

	mov	r8d, 441				; 000001b9H
	mov	rdx, QWORD PTR segname$[rsp]
	lea	rcx, OFFSET FLAT:$SG12031
	call	AddLineQueueX
	jmp	SHORT $LN8@WriteSEHDa
$LN7@WriteSEHDa:

; 1713 :     else {
; 1714 :         AddLineQueueX("%s %r align(%u) flat read 'DATA'", segname, T_SEGMENT, 8 );

	mov	r9d, 8
	mov	r8d, 441				; 000001b9H
	mov	rdx, QWORD PTR segname$[rsp]
	lea	rcx, OFFSET FLAT:$SG12032
	call	AddLineQueueX

; 1715 :         AddLineQueue("$xdatasym label near");

	lea	rcx, OFFSET FLAT:$SG12033
	call	AddLineQueue
$LN8@WriteSEHDa:

; 1716 :     }
; 1717 :     xdataofs = 0;

	mov	DWORD PTR xdataofs$[rsp], 0

; 1718 :     xdata = (struct dsym *)SymSearch( segname );

	mov	rcx, QWORD PTR segname$[rsp]
	call	SymFind
	mov	QWORD PTR xdata$[rsp], rax

; 1719 :     if ( xdata ) {

	cmp	QWORD PTR xdata$[rsp], 0
	je	SHORT $LN9@WriteSEHDa

; 1720 :         /* v2.11: changed offset to max_offset.
; 1721 :          * However, value structinfo.current_loc might even be better.
; 1722 :          */
; 1723 :         xdataofs = xdata->sym.max_offset;

	mov	rax, QWORD PTR xdata$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR xdataofs$[rsp], eax
$LN9@WriteSEHDa:

; 1724 :     }
; 1725 : 
; 1726 :     /* write the .xdata stuff (a UNWIND_INFO entry )
; 1727 :      * v2.11: 't'-suffix added to ensure the values are correct if radix is != 10.
; 1728 :      */
; 1729 :     AddLineQueueX( "db %ut + (0%xh shl 3), %ut, %ut, 0%xh + (0%xh shl 4)",

	movzx	eax, BYTE PTR unw_info+3
	shr	al, 4
	and	al, 15
	movzx	eax, al
	movzx	ecx, BYTE PTR unw_info+3
	and	cl, 15
	movzx	ecx, cl
	movzx	edx, BYTE PTR unw_info+2
	movzx	r8d, BYTE PTR unw_info+1
	movzx	r9d, BYTE PTR unw_info
	shr	r9b, 3
	and	r9b, 31
	movzx	r9d, r9b
	mov	DWORD PTR tv129[rsp], r9d
	mov	DWORD PTR [rsp+48], eax
	mov	DWORD PTR [rsp+40], ecx
	mov	DWORD PTR [rsp+32], edx
	mov	r9d, r8d
	mov	eax, DWORD PTR tv129[rsp]
	mov	r8d, eax
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG12035
	call	AddLineQueueX

; 1730 :             UNW_VERSION, unw_info.Flags, unw_info.SizeOfProlog,
; 1731 :             unw_info.CountOfCodes, unw_info.FrameRegister, unw_info.FrameOffset );
; 1732 :     if ( unw_info.CountOfCodes ) {

	movzx	eax, BYTE PTR unw_info+2
	test	eax, eax
	je	$LN10@WriteSEHDa

; 1733 :         char *pfx = "dw";

	lea	rax, OFFSET FLAT:$SG12037
	mov	QWORD PTR pfx$1[rsp], rax

; 1734 :         buffer[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 128			; 00000080H
	jae	SHORT $LN19@WriteSEHDa
	jmp	SHORT $LN20@WriteSEHDa
$LN19@WriteSEHDa:
	call	__report_rangecheckfailure
$LN20@WriteSEHDa:
	mov	rax, QWORD PTR $T2[rsp]
	mov	BYTE PTR buffer$[rsp+rax], 0

; 1735 :         /* write the codes from right to left */
; 1736 :         for ( i = unw_info.CountOfCodes; i ; i-- ) {

	movzx	eax, BYTE PTR unw_info+2
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN4@WriteSEHDa
$LN2@WriteSEHDa:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@WriteSEHDa:
	cmp	DWORD PTR i$[rsp], 0
	je	$LN3@WriteSEHDa

; 1737 :             /* v2.11: use field FrameOffset */
; 1738 :             //sprintf( buffer + strlen( buffer ), "%s 0%xh", pfx, unw_code[i-1] );
; 1739 :             sprintf( buffer + strlen( buffer ), "%s 0%xh", pfx, unw_code[i-1].FrameOffset );

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	lea	rcx, OFFSET FLAT:unw_code
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	DWORD PTR tv147[rsp], eax
	lea	rcx, QWORD PTR buffer$[rsp]
	call	strlen
	lea	rax, QWORD PTR buffer$[rsp+rax]
	mov	ecx, DWORD PTR tv147[rsp]
	mov	r9d, ecx
	mov	r8, QWORD PTR pfx$1[rsp]
	lea	rdx, OFFSET FLAT:$SG12038
	mov	rcx, rax
	call	sprintf

; 1740 :             pfx = ",";

	lea	rax, OFFSET FLAT:$SG12039
	mov	QWORD PTR pfx$1[rsp], rax

; 1741 :             if ( i == 1 || strlen( buffer ) > 72 ) {

	cmp	DWORD PTR i$[rsp], 1
	je	SHORT $LN12@WriteSEHDa
	lea	rcx, QWORD PTR buffer$[rsp]
	call	strlen
	cmp	rax, 72					; 00000048H
	jbe	SHORT $LN11@WriteSEHDa
$LN12@WriteSEHDa:

; 1742 :                 AddLineQueue( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	AddLineQueue

; 1743 :                 buffer[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	QWORD PTR $T3[rsp], rax
	cmp	QWORD PTR $T3[rsp], 128			; 00000080H
	jae	SHORT $LN21@WriteSEHDa
	jmp	SHORT $LN22@WriteSEHDa
$LN21@WriteSEHDa:
	call	__report_rangecheckfailure
$LN22@WriteSEHDa:
	mov	rax, QWORD PTR $T3[rsp]
	mov	BYTE PTR buffer$[rsp+rax], 0

; 1744 :                 pfx = "dw";

	lea	rax, OFFSET FLAT:$SG12042
	mov	QWORD PTR pfx$1[rsp], rax
$LN11@WriteSEHDa:

; 1745 :             }
; 1746 :         }

	jmp	$LN2@WriteSEHDa
$LN3@WriteSEHDa:
$LN10@WriteSEHDa:

; 1747 :     }
; 1748 :     /* make sure the unwind codes array has an even number of entries */
; 1749 :     AddLineQueueX( "%r 4", T_ALIGN );

	mov	edx, 439				; 000001b7H
	lea	rcx, OFFSET FLAT:$SG12043
	call	AddLineQueueX

; 1750 : 
; 1751 :     if ( proc->e.procinfo->exc_handler ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN13@WriteSEHDa

; 1752 :         AddLineQueueX( "dd %r %s", T_IMAGEREL, proc->e.procinfo->exc_handler->name );

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+88]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 233				; 000000e9H
	lea	rcx, OFFSET FLAT:$SG12045
	call	AddLineQueueX

; 1753 :         AddLineQueueX( "%r 8", T_ALIGN );

	mov	edx, 439				; 000001b7H
	lea	rcx, OFFSET FLAT:$SG12046
	call	AddLineQueueX
$LN13@WriteSEHDa:

; 1754 :     }
; 1755 :     AddLineQueueX( "%s %r", segname, T_ENDS );

	mov	r8d, 442				; 000001baH
	mov	rdx, QWORD PTR segname$[rsp]
	lea	rcx, OFFSET FLAT:$SG12047
	call	AddLineQueueX

; 1756 : 
; 1757 :     /* v2.07: ensure that .pdata items are sorted */
; 1758 :     if ( 0 == strcmp( SimGetSegName( SIM_CODE ), proc->sym.segment->name ) ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv261[rsp], rax
	xor	ecx, ecx
	call	SimGetSegName
	mov	rcx, QWORD PTR tv261[rsp]
	mov	rdx, QWORD PTR [rcx+8]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN14@WriteSEHDa

; 1759 :         segname = ".pdata";

	lea	rax, OFFSET FLAT:$SG12050
	mov	QWORD PTR segname$[rsp], rax

; 1760 :         simplespec = ( unw_segs_defined & 1 );

	movzx	eax, BYTE PTR unw_segs_defined
	and	eax, 1
	mov	DWORD PTR simplespec$[rsp], eax

; 1761 :         unw_segs_defined = 3;

	mov	BYTE PTR unw_segs_defined, 3

; 1762 :     } else {

	jmp	SHORT $LN15@WriteSEHDa
$LN14@WriteSEHDa:

; 1763 :         segname = segnamebuff;

	lea	rax, QWORD PTR segnamebuff$[rsp]
	mov	QWORD PTR segname$[rsp], rax

; 1764 :         sprintf( segname, ".pdata$%04u", GetSegIdx( proc->sym.segment ) );

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	GetSegIdx
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG12051
	mov	rcx, QWORD PTR segname$[rsp]
	call	sprintf

; 1765 :         simplespec = 0;

	mov	DWORD PTR simplespec$[rsp], 0

; 1766 :         unw_segs_defined |= 2;

	movzx	eax, BYTE PTR unw_segs_defined
	or	eax, 2
	mov	BYTE PTR unw_segs_defined, al
$LN15@WriteSEHDa:

; 1767 :     }
; 1768 : 
; 1769 :     if ( simplespec )

	cmp	DWORD PTR simplespec$[rsp], 0
	je	SHORT $LN16@WriteSEHDa

; 1770 :         AddLineQueueX( "%s %r", segname, T_SEGMENT );

	mov	r8d, 441				; 000001b9H
	mov	rdx, QWORD PTR segname$[rsp]
	lea	rcx, OFFSET FLAT:$SG12054
	call	AddLineQueueX
	jmp	SHORT $LN17@WriteSEHDa
$LN16@WriteSEHDa:

; 1771 :     else
; 1772 :         AddLineQueueX( "%s %r align(%u) flat read 'DATA'", segname, T_SEGMENT, 4 );

	mov	r9d, 4
	mov	r8d, 441				; 000001b9H
	mov	rdx, QWORD PTR segname$[rsp]
	lea	rcx, OFFSET FLAT:$SG12055
	call	AddLineQueueX
$LN17@WriteSEHDa:

; 1773 :     /* write the .pdata stuff ( type IMAGE_RUNTIME_FUNCTION_ENTRY )*/
; 1774 :     AddLineQueueX( "dd %r %s, %r %s+0%xh, %r $xdatasym+0%xh",

	mov	eax, DWORD PTR xdataofs$[rsp]
	mov	DWORD PTR [rsp+56], eax
	mov	DWORD PTR [rsp+48], 233			; 000000e9H
	mov	rax, QWORD PTR proc$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 233				; 000000e9H
	mov	rax, QWORD PTR proc$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 233				; 000000e9H
	lea	rcx, OFFSET FLAT:$SG12056
	call	AddLineQueueX

; 1775 :                   T_IMAGEREL, proc->sym.name,
; 1776 :                   T_IMAGEREL, proc->sym.name, proc->sym.total_size,
; 1777 :                   T_IMAGEREL, xdataofs );
; 1778 :     AddLineQueueX("%s %r", segname, T_ENDS );

	mov	r8d, 442				; 000001baH
	mov	rdx, QWORD PTR segname$[rsp]
	lea	rcx, OFFSET FLAT:$SG12057
	call	AddLineQueueX

; 1779 :     olddotname = ModuleInfo.dotname;

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 4
	and	eax, 1
	mov	BYTE PTR olddotname$[rsp], al

; 1780 :     ModuleInfo.dotname = TRUE; /* set OPTION DOTNAME because .pdata and .xdata */

	mov	eax, DWORD PTR ModuleInfo+408
	or	eax, 16
	mov	DWORD PTR ModuleInfo+408, eax

; 1781 :     RunLineQueue();

	call	RunLineQueue

; 1782 :     ModuleInfo.dotname = olddotname;

	movzx	eax, BYTE PTR olddotname$[rsp]
	and	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR ModuleInfo+408
	and	ecx, -17				; ffffffefH
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax
$LN1@WriteSEHDa:
$LN18@WriteSEHDa:

; 1783 :     return;
; 1784 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 312				; 00000138H
	ret	0
WriteSEHData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
sym$ = 48
is_global$ = 56
oldpubstate$ = 57
ofs$ = 60
tv152 = 64
tv312 = 68
tv371 = 72
name$ = 80
tv266 = 88
tv282 = 96
procline$ = 104
cline$ = 112
i$ = 144
tokenarray$ = 152
ProcDir	PROC

; 1453 : {

$LN42:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 136				; 00000088H

; 1454 :     struct asym         *sym;
; 1455 :     unsigned int        ofs;
; 1456 :     char                *name;
; 1457 :     bool                oldpubstate;
; 1458 :     bool                is_global;
; 1459 : 	struct asym*        cline;
; 1460 : 	struct asym*        procline;
; 1461 : 
; 1462 : 	/* Store the current source code line relating to the PROC */
; 1463 : 	cline = SymFind("@Line");

	lea	rcx, OFFSET FLAT:$SG11947
	call	SymFind
	mov	QWORD PTR cline$[rsp], rax

; 1464 : 	procline = SymFind("@ProcLine");

	lea	rcx, OFFSET FLAT:$SG11948
	call	SymFind
	mov	QWORD PTR procline$[rsp], rax

; 1465 : 	procline->value = cline->value;

	mov	rax, QWORD PTR procline$[rsp]
	mov	rcx, QWORD PTR cline$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax+16], ecx

; 1466 : 
; 1467 :     DebugMsg1(("ProcDir enter, curr ofs=%X\n", GetCurrOffset() ));

	call	GetCurrOffset
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11949
	call	DoDebugMsg1

; 1468 :     if( i != 1 ) {

	cmp	DWORD PTR i$[rsp], 1
	je	SHORT $LN2@ProcDir

; 1469 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ProcDir
$LN2@ProcDir:

; 1470 :     }
; 1471 :     /* v2.04b: check was missing */
; 1472 :     if( CurrSeg == NULL ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN3@ProcDir

; 1473 :         return( EmitError( MUST_BE_IN_SEGMENT_BLOCK ) );

	mov	ecx, 82					; 00000052H
	call	EmitError
	jmp	$LN1@ProcDir
$LN3@ProcDir:

; 1474 :     }
; 1475 : 
; 1476 :     name = tokenarray[0].string_ptr;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR name$[rsp], rax

; 1477 : 
; 1478 :     if( CurrProc != NULL ) {

	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN4@ProcDir

; 1479 : 
; 1480 :         /* this is not needed for HJWasm, but Masm will reject nested
; 1481 :          * procs if there are params, locals or used registers.
; 1482 :          */
; 1483 :         if ( CurrProc->e.procinfo->paralist ||
; 1484 : #if AMD64_SUPPORT
; 1485 :             CurrProc->e.procinfo->isframe ||
; 1486 : #endif
; 1487 :             CurrProc->e.procinfo->locallist ||

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+8], 0
	jne	SHORT $LN6@ProcDir
	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@ProcDir
	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN6@ProcDir
	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN5@ProcDir
$LN6@ProcDir:

; 1488 :             CurrProc->e.procinfo->regslist ) {
; 1489 :             return( EmitErr( CANNOT_NEST_PROCEDURES, name ) );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 93					; 0000005dH
	call	EmitErr
	jmp	$LN1@ProcDir
$LN5@ProcDir:

; 1490 :         }
; 1491 :         /* nested procs ... push currproc on a stack */
; 1492 :         push_proc( CurrProc );

	mov	rcx, QWORD PTR CurrProc
	call	push_proc
$LN4@ProcDir:

; 1493 :     }
; 1494 : 
; 1495 : 
; 1496 :     if ( ModuleInfo.procalign ) {

	movzx	eax, BYTE PTR ModuleInfo+399
	test	eax, eax
	je	SHORT $LN7@ProcDir

; 1497 :         AlignCurrOffset( ModuleInfo.procalign );

	movzx	eax, BYTE PTR ModuleInfo+399
	mov	ecx, eax
	call	AlignCurrOffset
$LN7@ProcDir:

; 1498 :     }
; 1499 : 
; 1500 :     i++; /* go past PROC */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1501 : 
; 1502 :     sym = SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 1503 : 
; 1504 :     if( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN8@ProcDir

; 1505 : 
; 1506 :         oldpubstate = sym ? sym->ispublic : FALSE;

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN32@ProcDir
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	mov	DWORD PTR tv152[rsp], eax
	jmp	SHORT $LN33@ProcDir
$LN32@ProcDir:
	mov	DWORD PTR tv152[rsp], 0
$LN33@ProcDir:
	movzx	eax, BYTE PTR tv152[rsp]
	mov	BYTE PTR oldpubstate$[rsp], al

; 1507 :         if( sym == NULL || sym->state == SYM_UNDEFINED ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN12@ProcDir
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN10@ProcDir
$LN12@ProcDir:

; 1508 :             sym = CreateProc( sym, name, SYM_INTERNAL );

	mov	r8d, 1
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateProc
	mov	QWORD PTR sym$[rsp], rax

; 1509 :             is_global = FALSE;

	mov	BYTE PTR is_global$[rsp], 0
	jmp	$LN11@ProcDir
$LN10@ProcDir:

; 1510 :         } else if ( sym->state == SYM_EXTERNAL && sym->weak == TRUE ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	$LN13@ProcDir
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN13@ProcDir

; 1511 :             /* PROTO or EXTERNDEF item */
; 1512 :             is_global = TRUE;

	mov	BYTE PTR is_global$[rsp], 1

; 1513 :             if ( sym->isproc == TRUE  ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN15@ProcDir

; 1514 :                 /* don't create the procinfo extension; it exists already */
; 1515 :                 procidx++; /* v2.04: added */

	mov	eax, DWORD PTR procidx
	inc	eax
	mov	DWORD PTR procidx, eax

; 1516 :                 if ( Options.line_numbers ) {

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	SHORT $LN17@ProcDir

; 1517 :                     sym->debuginfo = LclAlloc( sizeof( struct debug_info ) );

	mov	ecx, 24
	call	LclAlloc
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+64], rax

; 1518 :                     sym->debuginfo->file = get_curr_srcfile();

	call	get_curr_srcfile
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	mov	WORD PTR [rcx+14], ax
$LN17@ProcDir:

; 1519 :                 }
; 1520 :             } else {

	jmp	SHORT $LN16@ProcDir
$LN15@ProcDir:

; 1521 :                 /* it's a simple EXTERNDEF. Create a PROC item!
; 1522 :                  * this will be SYM_INTERNAL */
; 1523 :                 /* v2.03: don't call dir_free(), it'll clear field Ofssize */
; 1524 :                 //dir_free( (struct dsym *)sym );
; 1525 :                 sym = CreateProc( sym, name, SYM_INTERNAL );

	mov	r8d, 1
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateProc
	mov	QWORD PTR sym$[rsp], rax
$LN16@ProcDir:

; 1526 :             }
; 1527 :         } else {

	jmp	SHORT $LN14@ProcDir
$LN13@ProcDir:

; 1528 :             /* Masm won't reject a redefinition if "certain" parameters
; 1529 :              * won't change. However, in a lot of cases one gets "internal assembler error".
; 1530 :              * Hence this "feature" isn't active in hjwasm.
; 1531 :              */
; 1532 :             //} else if ( sym->state != SYM_INTERNAL || sym->isproc != TRUE ||
; 1533 :             //           sym->offset != GetCurrOffset() || sym->segment != &CurrSeg->sym ) {
; 1534 :             return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@ProcDir
$LN14@ProcDir:
$LN11@ProcDir:

; 1535 :         }
; 1536 :         SetSymSegOfs( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	SetSymSegOfs

; 1537 : 
; 1538 :         SymClearLocal();

	call	SymClearLocal

; 1539 : 
; 1540 : #if STACKBASESUPP
; 1541 :         /* v2.11: added. Note that fpo flag is only set if there ARE params! */
; 1542 :         ((struct dsym *)sym)->e.procinfo->basereg = ModuleInfo.basereg[ModuleInfo.Ofssize];

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:ModuleInfo+500
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rdx+96]
	movzx	eax, WORD PTR [rcx+rax*4]
	mov	WORD PTR [rdx+130], ax

; 1543 : #endif
; 1544 :         /* CurrProc must be set, it's used inside SymFind() and SymLCreate()! */
; 1545 :         CurrProc = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR CurrProc, rax

; 1546 :         if( ParseProc( (struct dsym *)sym, i, tokenarray, TRUE, ModuleInfo.langtype ) == ERROR ) {

	mov	eax, DWORD PTR ModuleInfo+364
	mov	DWORD PTR [rsp+32], eax
	mov	r9b, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	ParseProc
	cmp	eax, -1
	jne	SHORT $LN18@ProcDir

; 1547 :             CurrProc = NULL;

	mov	QWORD PTR CurrProc, 0

; 1548 :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@ProcDir
$LN18@ProcDir:

; 1549 :         }
; 1550 :         /* v2.04: added */
; 1551 :         if ( is_global && Options.masm8_proc_visibility )

	movzx	eax, BYTE PTR is_global$[rsp]
	test	eax, eax
	je	SHORT $LN19@ProcDir
	movzx	eax, BYTE PTR Options+145
	test	eax, eax
	je	SHORT $LN19@ProcDir

; 1552 :             sym->ispublic = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al
$LN19@ProcDir:

; 1553 : 
; 1554 :         /* if there was a PROTO (or EXTERNDEF name:PROTO ...),
; 1555 :          * change symbol to SYM_INTERNAL!
; 1556 :          */
; 1557 :         if ( sym->state == SYM_EXTERNAL && sym->isproc == TRUE ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	$LN20@ProcDir
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN20@ProcDir

; 1558 :             sym_ext2int( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	sym_ext2int

; 1559 :             /* v2.11: added ( may be better to call CreateProc() - currently not possible ) */
; 1560 :             if ( SymTables[TAB_PROC].head == NULL )

	mov	eax, 16
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:SymTables
	cmp	QWORD PTR [rcx+rax], 0
	jne	SHORT $LN21@ProcDir

; 1561 :                 SymTables[TAB_PROC].head = (struct dsym *)sym;

	mov	eax, 16
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+rax], rdx
	jmp	SHORT $LN22@ProcDir
$LN21@ProcDir:

; 1562 :             else {
; 1563 :                 SymTables[TAB_PROC].tail->nextproc = (struct dsym *)sym;

	mov	eax, 16
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+112], rcx
$LN22@ProcDir:

; 1564 :             }
; 1565 :             SymTables[TAB_PROC].tail = (struct dsym *)sym;

	mov	eax, 16
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+rax+8], rdx
$LN20@ProcDir:

; 1566 :         }
; 1567 : 
; 1568 :         /* v2.11: sym->isproc is set inside ParseProc() */
; 1569 :         //sym->isproc = TRUE;
; 1570 : #if STACKBASESUPP
; 1571 :         /* v2.11: Note that fpo flag is only set if there ARE params ( or locals )! */
; 1572 :         if ( CurrProc->e.procinfo->paralist && GetRegNo( CurrProc->e.procinfo->basereg ) == 4 )

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN23@ProcDir
	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, WORD PTR [rax+130]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	cmp	eax, 4
	jne	SHORT $LN23@ProcDir

; 1573 :             CurrProc->e.procinfo->fpo = TRUE;

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+128], al
$LN23@ProcDir:

; 1574 : #endif
; 1575 :         if( sym->ispublic == TRUE && oldpubstate == FALSE )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN24@ProcDir
	movzx	eax, BYTE PTR oldpubstate$[rsp]
	test	eax, eax
	jne	SHORT $LN24@ProcDir

; 1576 :             AddPublicData( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	AddPublicData
$LN24@ProcDir:

; 1577 : 
; 1578 :         /* v2.04: add the proc to the list of labels attached to curr segment.
; 1579 :          * this allows to reduce the number of passes (see fixup.c)
; 1580 :          */
; 1581 :         ((struct dsym *)sym)->next = (struct dsym *)CurrSeg->e.seginfo->label_list;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR [rcx+104], rax

; 1582 :         CurrSeg->e.seginfo->label_list = sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+32], rcx

; 1583 : 
; 1584 :     } else {

	jmp	$LN9@ProcDir
$LN8@ProcDir:

; 1585 :         /**/myassert( sym != NULL );

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN34@ProcDir
	mov	DWORD PTR tv266[rsp], 0
	jmp	SHORT $LN35@ProcDir
$LN34@ProcDir:
	mov	edx, 1585				; 00000631H
	lea	rcx, OFFSET FLAT:$SG11973
	call	InternalError
	mov	DWORD PTR tv266[rsp], eax
$LN35@ProcDir:

; 1586 : 
; 1587 :         procidx++;

	mov	eax, DWORD PTR procidx
	inc	eax
	mov	DWORD PTR procidx, eax

; 1588 :         sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 1589 : 
; 1590 :         SymSetLocal( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	SymSetLocal

; 1591 : 
; 1592 :         /* it's necessary to check for a phase error here
; 1593 :          as it is done in LabelCreate() and data_dir()!
; 1594 :          */
; 1595 :         ofs = GetCurrOffset();

	call	GetCurrOffset
	mov	DWORD PTR ofs$[rsp], eax

; 1596 : 
; 1597 :         if ( ofs != sym->offset) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR ofs$[rsp], eax
	je	SHORT $LN25@ProcDir

; 1598 :             DebugMsg(("ProcDir(%s): %spass %u, old ofs=%" I32_SPEC "X, new ofs=%" I32_SPEC "X\n",

	movzx	eax, BYTE PTR ModuleInfo+422
	test	eax, eax
	je	SHORT $LN36@ProcDir
	lea	rax, OFFSET FLAT:$SG11975
	mov	QWORD PTR tv282[rsp], rax
	jmp	SHORT $LN37@ProcDir
$LN36@ProcDir:
	lea	rax, OFFSET FLAT:$SG11976
	mov	QWORD PTR tv282[rsp], rax
$LN37@ProcDir:
	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	ecx, DWORD PTR ofs$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, eax
	mov	r8, QWORD PTR tv282[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11977
	call	DoDebugMsg

; 1599 :                     sym->name,
; 1600 :                     ModuleInfo.PhaseError ? "" : "phase error ",
; 1601 :                     Parse_Pass+1, sym->offset, ofs ));
; 1602 :             sym->offset = ofs;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR ofs$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 1603 :             ModuleInfo.PhaseError = TRUE;

	mov	BYTE PTR ModuleInfo+422, 1
$LN25@ProcDir:

; 1604 :         }
; 1605 :         CurrProc = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR CurrProc, rax

; 1606 : #if AMD64_SUPPORT
; 1607 :         /* check if the exception handler set by FRAME is defined */
; 1608 :         if ( CurrProc->e.procinfo->isframe &&
; 1609 :             CurrProc->e.procinfo->exc_handler &&

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN26@ProcDir
	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN26@ProcDir
	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+88]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN26@ProcDir

; 1610 :             CurrProc->e.procinfo->exc_handler->state == SYM_UNDEFINED ) {
; 1611 :             EmitErr( SYMBOL_NOT_DEFINED, CurrProc->e.procinfo->exc_handler->name );

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+88]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr
$LN26@ProcDir:
$LN9@ProcDir:

; 1612 :         }
; 1613 : #endif
; 1614 :     }
; 1615 : 
; 1616 :     /* v2.11: init @ProcStatus - prologue not written yet, optionally set FPO flag */
; 1617 : #if STACKBASESUPP
; 1618 :     ProcStatus = PRST_PROLOGUE_NOT_DONE | ( CurrProc->e.procinfo->fpo ? PRST_FPO : 0 );

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN38@ProcDir
	mov	DWORD PTR tv312[rsp], 4
	jmp	SHORT $LN39@ProcDir
$LN38@ProcDir:
	mov	DWORD PTR tv312[rsp], 0
$LN39@ProcDir:
	mov	eax, DWORD PTR tv312[rsp]
	bts	eax, 7
	mov	DWORD PTR ProcStatus, eax

; 1619 :     StackAdj = 0;  /* init @StackBase to 0 */

	mov	DWORD PTR StackAdj, 0

; 1620 :     StackAdjHigh = 0;

	mov	DWORD PTR StackAdjHigh, 0

; 1621 : #else
; 1622 :     ProcStatus = PRST_PROLOGUE_NOT_DONE;
; 1623 : #endif
; 1624 : 
; 1625 : #if AMD64_SUPPORT
; 1626 :     if ( CurrProc->e.procinfo->isframe ) {

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN27@ProcDir

; 1627 :         endprolog_found = FALSE;

	mov	BYTE PTR endprolog_found, 0

; 1628 :         /* v2.11: clear all fields */
; 1629 :         memset( &unw_info, 0, sizeof( unw_info ) );

	mov	r8d, 4
	xor	edx, edx
	lea	rcx, OFFSET FLAT:unw_info
	call	memset

; 1630 :         if ( CurrProc->e.procinfo->exc_handler )

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN28@ProcDir

; 1631 :             unw_info.Flags = UNW_FLAG_FHANDLER;

	movzx	eax, BYTE PTR unw_info
	and	al, 7
	or	al, 24
	mov	BYTE PTR unw_info, al
$LN28@ProcDir:
$LN27@ProcDir:

; 1632 :     }
; 1633 : #endif
; 1634 : 
; 1635 :     sym->asmpass = Parse_Pass;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR Parse_Pass
	mov	BYTE PTR [rax+46], cl

; 1636 :     if ( ModuleInfo.list )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN29@ProcDir

; 1637 :         LstWrite( LSTTYPE_LABEL, 0, NULL );

	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, 7
	call	LstWrite
$LN29@ProcDir:

; 1638 : 
; 1639 :     if( Options.line_numbers ) {

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	SHORT $LN30@ProcDir

; 1640 : #if COFF_SUPPORT
; 1641 :         AddLinnumDataRef( get_curr_srcfile(), Options.output_format == OFORMAT_COFF ? 0 : GetLineNumber() );

	cmp	DWORD PTR Options+160, 2
	jne	SHORT $LN40@ProcDir
	mov	DWORD PTR tv371[rsp], 0
	jmp	SHORT $LN41@ProcDir
$LN40@ProcDir:
	call	GetLineNumber
	mov	DWORD PTR tv371[rsp], eax
$LN41@ProcDir:
	call	get_curr_srcfile
	mov	edx, DWORD PTR tv371[rsp]
	mov	ecx, eax
	call	AddLinnumDataRef
$LN30@ProcDir:

; 1642 : #else
; 1643 :         AddLinnumDataRef( get_curr_srcfile(), GetLineNumber() );
; 1644 : #endif
; 1645 :     }
; 1646 : 
; 1647 :     BackPatch( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	BackPatch

; 1648 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@ProcDir:

; 1649 : }

	add	rsp, 136				; 00000088H
	ret	0
ProcDir	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
paracurr$ = 128
paranode$ = 136
cntParam$ = 144
is_vararg$ = 148
init_done$ = 149
on$1 = 150
oo$2 = 151
offset$ = 152
ti$ = 160
tv528 = 192
name$ = 200
tv192 = 208
curr$ = 212
to$3 = 216
tn$4 = 224
tv254 = 232
tv260 = 236
fcint$ = 240
tv510 = 244
tv520 = 248
tv594 = 252
sym$ = 256
l$5 = 264
tv901 = 272
tv175 = 276
tv753 = 280
tv896 = 284
tv243 = 288
tv314 = 296
tv303 = 304
tv315 = 312
tv321 = 320
tv661 = 328
tv662 = 336
proc$ = 368
i$ = 376
tokenarray$ = 384
IsPROC$ = 392
ParseParams PROC

; 635  : {

	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 352				; 00000160H

; 636  :     char            *name;
; 637  :     struct asym     *sym;
; 638  :     int             cntParam;
; 639  :     int             offset;
; 640  :     //int             rcnt = 0;
; 641  :     int             fcint = 0;

	mov	DWORD PTR fcint$[rsp], 0

; 642  :     struct qualified_type ti;
; 643  :     bool            is_vararg;
; 644  :     bool            init_done;
; 645  :     struct dsym     *paranode;
; 646  :     struct dsym     *paracurr;
; 647  :     int             curr;
; 648  : 
; 649  :     /*
; 650  :      * find "first" parameter ( that is, the first to be pushed in INVOKE ).
; 651  :      */
; 652  :     if (proc->sym.langtype == LANG_C ||
; 653  :         proc->sym.langtype == LANG_SYSCALL ||
; 654  : #if AMD64_SUPPORT
; 655  :         ( proc->sym.langtype == LANG_FASTCALL && ModuleInfo.Ofssize != USE64 ) ||
; 656  :         ( proc->sym.langtype == LANG_VECTORCALL && ModuleInfo.Ofssize != USE64 ) ||

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 1
	je	SHORT $LN37@ParseParam
	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 2
	je	SHORT $LN37@ParseParam
	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 7
	jne	SHORT $LN38@ParseParam
	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	SHORT $LN37@ParseParam
$LN38@ParseParam:
	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 8
	jne	SHORT $LN39@ParseParam
	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	SHORT $LN37@ParseParam
$LN39@ParseParam:
	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 3
	jne	SHORT $LN35@ParseParam
$LN37@ParseParam:

; 657  : #else
; 658  :         proc->sym.langtype == LANG_FASTCALL ||
; 659  :         proc->sym.langtype == LANG_VECTORCALL ||
; 660  : #endif
; 661  :         proc->sym.langtype == LANG_STDCALL)
; 662  :         for ( paracurr = proc->e.procinfo->paralist; paracurr && paracurr->nextparam; paracurr = paracurr->nextparam );

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR paracurr$[rsp], rax
	jmp	SHORT $LN4@ParseParam
$LN2@ParseParam:
	mov	rax, QWORD PTR paracurr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR paracurr$[rsp], rax
$LN4@ParseParam:
	cmp	QWORD PTR paracurr$[rsp], 0
	je	SHORT $LN3@ParseParam
	mov	rax, QWORD PTR paracurr$[rsp]
	cmp	QWORD PTR [rax+112], 0
	je	SHORT $LN3@ParseParam
	jmp	SHORT $LN2@ParseParam
$LN3@ParseParam:
	jmp	SHORT $LN36@ParseParam
$LN35@ParseParam:

; 663  :     else
; 664  :         paracurr = proc->e.procinfo->paralist;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR paracurr$[rsp], rax
$LN36@ParseParam:

; 665  : 
; 666  :     /* v2.11: proc_info.init_done has been removed, sym.isproc flag is used instead */
; 667  :     init_done = proc->sym.isproc;

	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	mov	BYTE PTR init_done$[rsp], al

; 668  :     //if (proc->sym.langtype == 8)__debugbreak();
; 669  :     for( cntParam = 0 ; tokenarray[i].token != T_FINAL ; cntParam++ ) {

	mov	DWORD PTR cntParam$[rsp], 0
	jmp	SHORT $LN7@ParseParam
$LN5@ParseParam:
	mov	eax, DWORD PTR cntParam$[rsp]
	inc	eax
	mov	DWORD PTR cntParam$[rsp], eax
$LN7@ParseParam:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN6@ParseParam

; 670  : 
; 671  :         if ( tokenarray[i].token == T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN40@ParseParam

; 672  :             name = tokenarray[i++].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR name$[rsp], rax
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	$LN41@ParseParam
$LN40@ParseParam:

; 673  :         } else if ( IsPROC == FALSE && tokenarray[i].token == T_COLON ) {

	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	jne	SHORT $LN42@ParseParam
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN42@ParseParam

; 674  :             if ( paracurr )

	cmp	QWORD PTR paracurr$[rsp], 0
	je	SHORT $LN44@ParseParam

; 675  :                 name = paracurr->sym.name;

	mov	rax, QWORD PTR paracurr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR name$[rsp], rax
	jmp	SHORT $LN45@ParseParam
$LN44@ParseParam:

; 676  :             else
; 677  :                 name = "";

	lea	rax, OFFSET FLAT:$SG11656
	mov	QWORD PTR name$[rsp], rax
$LN45@ParseParam:

; 678  :         } else {

	jmp	SHORT $LN43@ParseParam
$LN42@ParseParam:

; 679  :             /* PROC needs a parameter name, PROTO accepts <void> also */
; 680  :             DebugMsg(("ParseParams: name missing/invalid for parameter %u, i=%u\n", cntParam+1, i));

	mov	eax, DWORD PTR cntParam$[rsp]
	inc	eax
	mov	r8d, DWORD PTR i$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11657
	call	DoDebugMsg

; 681  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ParseParam
$LN43@ParseParam:
$LN41@ParseParam:

; 682  :         }
; 683  : 
; 684  :         ti.symtype = NULL;

	mov	QWORD PTR ti$[rsp+8], 0

; 685  :         ti.is_ptr = 0;

	mov	BYTE PTR ti$[rsp+20], 0

; 686  :         ti.ptr_memtype = MT_EMPTY;

	mov	DWORD PTR ti$[rsp+24], 192		; 000000c0H

; 687  :         /* v2.02: init is_far depending on memory model */
; 688  :         //ti.is_far = FALSE;
; 689  :         if ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) )

	mov	eax, DWORD PTR ModuleInfo+360
	mov	ecx, 1
	mov	DWORD PTR tv753[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv753[rsp]
	shl	eax, cl
	and	eax, 104				; 00000068H
	test	eax, eax
	je	SHORT $LN46@ParseParam

; 690  :             ti.is_far = TRUE;

	mov	BYTE PTR ti$[rsp+21], 1
	jmp	SHORT $LN47@ParseParam
$LN46@ParseParam:

; 691  :         else
; 692  :             ti.is_far = FALSE;

	mov	BYTE PTR ti$[rsp+21], 0
$LN47@ParseParam:

; 693  :         ti.Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	BYTE PTR ti$[rsp+22], al

; 694  :         ti.size = CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	DWORD PTR ti$[rsp], eax

; 695  : 
; 696  :         is_vararg = FALSE;

	mov	BYTE PTR is_vararg$[rsp], 0

; 697  : 
; 698  :         /* read colon. It's optional for PROC.
; 699  :          * Masm also allows a missing colon for PROTO - if there's
; 700  :          * just one parameter. Probably a Masm bug.
; 701  :          * HJWasm always require a colon for PROTO.
; 702  :          */
; 703  :         if( tokenarray[i].token != T_COLON ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN48@ParseParam

; 704  :             if ( IsPROC == FALSE ) {

	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	jne	SHORT $LN50@ParseParam

; 705  :                 return( EmitError( COLON_EXPECTED ) );

	mov	ecx, 84					; 00000054H
	call	EmitError
	jmp	$LN1@ParseParam
$LN50@ParseParam:

; 706  :             }
; 707  :             switch ( ti.Ofssize ) {

	movzx	eax, BYTE PTR ti$[rsp+22]
	mov	BYTE PTR tv175[rsp], al
	cmp	BYTE PTR tv175[rsp], 0
	je	SHORT $LN51@ParseParam
	jmp	SHORT $LN52@ParseParam
$LN51@ParseParam:

; 708  :             case USE16:
; 709  :                 ti.mem_type = MT_WORD; break;

	mov	DWORD PTR ti$[rsp+16], 1
	jmp	SHORT $LN8@ParseParam
$LN52@ParseParam:

; 710  : #if AMD64_SUPPORT
; 711  :                 /* v2.08: default size for arguments is DWORD in 64-bit ( Win64 ) */
; 712  :                 //case USE64: ti.mem_type = MT_QWORD; break;
; 713  : #endif
; 714  :             default:
; 715  :                 ti.mem_type = MT_DWORD; break;

	mov	DWORD PTR ti$[rsp+16], 3
$LN8@ParseParam:

; 716  :             }
; 717  :         } else {

	jmp	$LN49@ParseParam
$LN48@ParseParam:

; 718  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 719  :             if (( tokenarray[i].token == T_RES_ID ) && ( tokenarray[i].tokval == T_VARARG )) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 7
	jne	$LN53@ParseParam
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 262		; 00000106H
	jne	$LN53@ParseParam

; 720  :                 switch( proc->sym.langtype ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	eax, DWORD PTR [rax+76]
	mov	DWORD PTR tv192[rsp], eax
	cmp	DWORD PTR tv192[rsp], 0
	je	SHORT $LN55@ParseParam
	cmp	DWORD PTR tv192[rsp], 2
	jle	SHORT $LN10@ParseParam
	cmp	DWORD PTR tv192[rsp], 6
	jle	SHORT $LN55@ParseParam
	jmp	SHORT $LN10@ParseParam
$LN55@ParseParam:

; 721  :                 case LANG_NONE:
; 722  :                 case LANG_BASIC:
; 723  :                 case LANG_FORTRAN:
; 724  :                 case LANG_PASCAL:
; 725  :                 case LANG_STDCALL:
; 726  :                     return( EmitError( VARARG_REQUIRES_C_CALLING_CONVENTION ) );

	mov	ecx, 94					; 0000005eH
	call	EmitError
	jmp	$LN1@ParseParam
$LN10@ParseParam:

; 727  :                 }
; 728  :                 /* v2.05: added check */
; 729  :                 if ( tokenarray[i+1].token != T_FINAL )

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN56@ParseParam

; 730  :                     EmitError( VARARG_PARAMETER_MUST_BE_LAST );

	mov	ecx, 147				; 00000093H
	call	EmitError
	jmp	SHORT $LN57@ParseParam
$LN56@ParseParam:

; 731  :                 else
; 732  :                     is_vararg = TRUE;

	mov	BYTE PTR is_vararg$[rsp], 1
$LN57@ParseParam:

; 733  :                 ti.mem_type = MT_EMPTY;

	mov	DWORD PTR ti$[rsp+16], 192		; 000000c0H

; 734  :                 ti.size = 0;

	mov	DWORD PTR ti$[rsp], 0

; 735  :                 i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 736  :             } else {

	jmp	SHORT $LN54@ParseParam
$LN53@ParseParam:

; 737  :                 if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	GetQualifiedType
	cmp	eax, -1
	jne	SHORT $LN58@ParseParam

; 738  :                     return( ERROR );

	mov	eax, -1
	jmp	$LN1@ParseParam
$LN58@ParseParam:
$LN54@ParseParam:
$LN49@ParseParam:

; 739  :             }
; 740  :         }
; 741  : 
; 742  :         /* check if parameter name is defined already */
; 743  :         if (( IsPROC ) && ( sym = SymSearch( name ) ) && sym->state != SYM_UNDEFINED ) {

	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	je	$LN59@ParseParam
	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN59@ParseParam
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN59@ParseParam

; 744  :             DebugMsg(("ParseParams: %s defined already, state=%u, local=%u\n", sym->name, sym->state, sym->scoped ));

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	mov	r9d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+32]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11672
	call	DoDebugMsg

; 745  :             return( EmitErr( SYMBOL_REDEFINITION, name ) );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@ParseParam
$LN59@ParseParam:

; 746  :         }
; 747  : 
; 748  :         /* redefinition? */
; 749  :         if ( paracurr ) {

	cmp	QWORD PTR paracurr$[rsp], 0
	je	$LN60@ParseParam

; 750  : #if 0 /* was active till v2.04 */
; 751  :             int newsize = ti.size;
; 752  :             int oldsize;
; 753  : 
; 754  :             /* check size only (so UINT <-> DWORD wont cause an error) */
; 755  :             if ( paracurr->sym.type )
; 756  :                 oldsize = paracurr->sym.total_size;
; 757  :             else if ( paracurr->sym.mem_type == MT_EMPTY )
; 758  :                 oldsize = 0;
; 759  :             else if ( paracurr->sym.mem_type == MT_PTR )
; 760  :                 oldsize = SizeFromMemtype( paracurr->sym.isfar ? MT_FAR : MT_NEAR, paracurr->sym.Ofssize, NULL );
; 761  :             else
; 762  :                 oldsize = SizeFromMemtype( paracurr->sym.mem_type, paracurr->sym.Ofssize, paracurr->sym.type );
; 763  :             if ( oldsize != newsize ) {
; 764  :                 DebugMsg(("ParseParams: old memtype=%u, new memtype=%u\n", paracurr->sym.mem_type, ti.mem_type));
; 765  :                 EmitErr( CONFLICTING_PARAMETER_DEFINITION, name );
; 766  :                 //return( ERROR );
; 767  :             }
; 768  :             /* the parameter type used in PROC has highest priority! */
; 769  :             if ( IsPROC ) {
; 770  :                 if ( ti.symtype ) {
; 771  :                     paracurr->sym.type = ti.symtype;
; 772  :                     paracurr->sym.mem_type = MT_TYPE;
; 773  :                 } else
; 774  :                     paracurr->sym.mem_type = ti.mem_type;
; 775  :             }
; 776  : #else
; 777  :             struct asym *to;
; 778  :             struct asym *tn;
; 779  :             char oo;
; 780  :             char on;
; 781  :             for( tn = ti.symtype; tn && tn->type; tn = tn->type );

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR tn$4[rsp], rax
	jmp	SHORT $LN14@ParseParam
$LN12@ParseParam:
	mov	rax, QWORD PTR tn$4[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR tn$4[rsp], rax
$LN14@ParseParam:
	cmp	QWORD PTR tn$4[rsp], 0
	je	SHORT $LN13@ParseParam
	mov	rax, QWORD PTR tn$4[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN13@ParseParam
	jmp	SHORT $LN12@ParseParam
$LN13@ParseParam:

; 782  :             /* v2.12: don't assume pointer type if mem_type is != MT_TYPE!
; 783  :              * regression test proc9.asm.
; 784  :              */
; 785  :             //to = ( paracurr->sym.mem_type == MT_TYPE ) ? paracurr->sym.type : paracurr->sym.target_type;
; 786  :             if ( paracurr->sym.mem_type == MT_TYPE )

	mov	rax, QWORD PTR paracurr$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN62@ParseParam

; 787  :                 to = paracurr->sym.type;

	mov	rax, QWORD PTR paracurr$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR to$3[rsp], rax
	jmp	SHORT $LN63@ParseParam
$LN62@ParseParam:

; 788  :             else
; 789  :                 to = ( paracurr->sym.mem_type == MT_PTR ? paracurr->sym.target_type : NULL );

	mov	rax, QWORD PTR paracurr$[rsp]
	cmp	DWORD PTR [rax+36], 195			; 000000c3H
	jne	SHORT $LN114@ParseParam
	mov	rax, QWORD PTR paracurr$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv243[rsp], rax
	jmp	SHORT $LN115@ParseParam
$LN114@ParseParam:
	mov	QWORD PTR tv243[rsp], 0
$LN115@ParseParam:
	mov	rax, QWORD PTR tv243[rsp]
	mov	QWORD PTR to$3[rsp], rax
$LN63@ParseParam:

; 790  :             for( ; to && to->type; to = to->type );

	jmp	SHORT $LN17@ParseParam
$LN15@ParseParam:
	mov	rax, QWORD PTR to$3[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR to$3[rsp], rax
$LN17@ParseParam:
	cmp	QWORD PTR to$3[rsp], 0
	je	SHORT $LN16@ParseParam
	mov	rax, QWORD PTR to$3[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN16@ParseParam
	jmp	SHORT $LN15@ParseParam
$LN16@ParseParam:

; 791  :             oo = ( paracurr->sym.Ofssize != USE_EMPTY ) ? paracurr->sym.Ofssize : ModuleInfo.Ofssize;

	mov	rax, QWORD PTR paracurr$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	cmp	eax, 254				; 000000feH
	je	SHORT $LN116@ParseParam
	mov	rax, QWORD PTR paracurr$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	DWORD PTR tv254[rsp], eax
	jmp	SHORT $LN117@ParseParam
$LN116@ParseParam:
	movzx	eax, BYTE PTR ModuleInfo+404
	mov	DWORD PTR tv254[rsp], eax
$LN117@ParseParam:
	movzx	eax, BYTE PTR tv254[rsp]
	mov	BYTE PTR oo$2[rsp], al

; 792  :             on = ( ti.Ofssize != USE_EMPTY ) ? ti.Ofssize : ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ti$[rsp+22]
	cmp	eax, 254				; 000000feH
	je	SHORT $LN118@ParseParam
	movzx	eax, BYTE PTR ti$[rsp+22]
	mov	DWORD PTR tv260[rsp], eax
	jmp	SHORT $LN119@ParseParam
$LN118@ParseParam:
	movzx	eax, BYTE PTR ModuleInfo+404
	mov	DWORD PTR tv260[rsp], eax
$LN119@ParseParam:
	movzx	eax, BYTE PTR tv260[rsp]
	mov	BYTE PTR on$1[rsp], al

; 793  :             if ( ti.mem_type != paracurr->sym.mem_type ||
; 794  :                 ( ti.mem_type == MT_TYPE && tn != to ) ||

	mov	rax, QWORD PTR paracurr$[rsp]
	mov	eax, DWORD PTR [rax+36]
	cmp	DWORD PTR ti$[rsp+16], eax
	jne	$LN65@ParseParam
	cmp	DWORD PTR ti$[rsp+16], 196		; 000000c4H
	jne	SHORT $LN66@ParseParam
	mov	rax, QWORD PTR to$3[rsp]
	cmp	QWORD PTR tn$4[rsp], rax
	jne	SHORT $LN65@ParseParam
$LN66@ParseParam:
	cmp	DWORD PTR ti$[rsp+16], 195		; 000000c3H
	jne	$LN64@ParseParam
	movzx	eax, BYTE PTR ti$[rsp+21]
	mov	rcx, QWORD PTR paracurr$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	shr	cl, 4
	and	cl, 1
	movzx	ecx, cl
	cmp	eax, ecx
	jne	SHORT $LN67@ParseParam
	movsx	eax, BYTE PTR on$1[rsp]
	movsx	ecx, BYTE PTR oo$2[rsp]
	cmp	eax, ecx
	jne	SHORT $LN67@ParseParam
	mov	rax, QWORD PTR paracurr$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	cmp	DWORD PTR ti$[rsp+24], eax
	jne	SHORT $LN67@ParseParam
	mov	rax, QWORD PTR to$3[rsp]
	cmp	QWORD PTR tn$4[rsp], rax
	je	$LN64@ParseParam
$LN67@ParseParam:
$LN65@ParseParam:

; 795  :                 ( ti.mem_type == MT_PTR &&
; 796  :                  ( ti.is_far != paracurr->sym.isfar ||
; 797  :                   on != oo ||
; 798  :                   ti.ptr_memtype != paracurr->sym.ptr_memtype ||
; 799  :                   tn != to ))) {
; 800  :                 DebugMsg(("ParseParams: old-new memtype=%X-%X type=%X(%s)-%X(%s) far=%u-%u ind=%u-%u ofss=%d-%d pmt=%X-%X\n",

	cmp	QWORD PTR ti$[rsp+8], 0
	je	SHORT $LN120@ParseParam
	mov	rax, QWORD PTR ti$[rsp+8]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv303[rsp], rax
	jmp	SHORT $LN121@ParseParam
$LN120@ParseParam:
	lea	rax, OFFSET FLAT:$SG11681
	mov	QWORD PTR tv303[rsp], rax
$LN121@ParseParam:
	mov	rax, QWORD PTR paracurr$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN124@ParseParam
	mov	rax, QWORD PTR paracurr$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv315[rsp], rax
	jmp	SHORT $LN125@ParseParam
$LN124@ParseParam:
	mov	rax, QWORD PTR paracurr$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN122@ParseParam
	mov	rax, QWORD PTR paracurr$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv314[rsp], rax
	jmp	SHORT $LN123@ParseParam
$LN122@ParseParam:
	lea	rax, OFFSET FLAT:$SG11682
	mov	QWORD PTR tv314[rsp], rax
$LN123@ParseParam:
	mov	rax, QWORD PTR tv314[rsp]
	mov	QWORD PTR tv315[rsp], rax
$LN125@ParseParam:
	mov	rax, QWORD PTR paracurr$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN126@ParseParam
	mov	rax, QWORD PTR paracurr$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR tv321[rsp], rax
	jmp	SHORT $LN127@ParseParam
$LN126@ParseParam:
	mov	rax, QWORD PTR paracurr$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv321[rsp], rax
$LN127@ParseParam:
	mov	rax, QWORD PTR paracurr$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	movzx	ecx, BYTE PTR ti$[rsp+22]
	mov	rdx, QWORD PTR paracurr$[rsp]
	movzx	edx, BYTE PTR [rdx+44]
	movzx	r8d, BYTE PTR ti$[rsp+20]
	mov	r9, QWORD PTR paracurr$[rsp]
	movzx	r9d, BYTE PTR [r9+45]
	movzx	r10d, BYTE PTR ti$[rsp+21]
	mov	r11, QWORD PTR paracurr$[rsp]
	movzx	r11d, BYTE PTR [r11+47]
	shr	r11b, 4
	and	r11b, 1
	movzx	r11d, r11b
	mov	ebx, DWORD PTR ti$[rsp+24]
	mov	DWORD PTR [rsp+112], ebx
	mov	DWORD PTR [rsp+104], eax
	mov	DWORD PTR [rsp+96], ecx
	mov	DWORD PTR [rsp+88], edx
	mov	DWORD PTR [rsp+80], r8d
	mov	DWORD PTR [rsp+72], r9d
	mov	DWORD PTR [rsp+64], r10d
	mov	DWORD PTR [rsp+56], r11d
	mov	rax, QWORD PTR tv303[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv315[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv321[rsp]
	mov	r8d, DWORD PTR ti$[rsp+16]
	mov	rax, QWORD PTR paracurr$[rsp]
	mov	edx, DWORD PTR [rax+36]
	lea	rcx, OFFSET FLAT:$SG11683
	call	DoDebugMsg

; 801  :                           paracurr->sym.mem_type, ti.mem_type, 
; 802  :                           (paracurr->sym.mem_type == MT_TYPE) ? paracurr->sym.type : paracurr->sym.target_type,
; 803  :                           (paracurr->sym.mem_type == MT_TYPE) ? paracurr->sym.type->name : paracurr->sym.target_type ? paracurr->sym.target_type->name : "",
; 804  :                           ti.symtype, ti.symtype ? ti.symtype->name : "",
; 805  :                           paracurr->sym.isfar, ti.is_far,
; 806  :                           paracurr->sym.is_ptr, ti.is_ptr,
; 807  :                           paracurr->sym.Ofssize, ti.Ofssize,
; 808  :                           paracurr->sym.ptr_memtype, ti.ptr_memtype ));
; 809  :                 EmitErr( CONFLICTING_PARAMETER_DEFINITION, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 137				; 00000089H
	call	EmitErr
$LN64@ParseParam:

; 810  :                 //return( ERROR );
; 811  :             }
; 812  : #endif
; 813  :             if ( IsPROC ) {

	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	je	SHORT $LN68@ParseParam

; 814  :                 DebugMsg1(("ParseParams: calling SymAddLocal(%s, %s)\n", paracurr->sym.name, name ));

	mov	r8, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR paracurr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11685
	call	DoDebugMsg1

; 815  :                 /* it has been checked already that the name isn't found - SymAddLocal() shouldn't fail */
; 816  :                 SymAddLocal( &paracurr->sym, name );

	mov	rax, QWORD PTR paracurr$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, rax
	call	SymAddLocal
$LN68@ParseParam:

; 817  :             }
; 818  :             /* set paracurr to next parameter */
; 819  :             if ( proc->sym.langtype == LANG_C ||
; 820  :                 proc->sym.langtype == LANG_SYSCALL ||
; 821  : #if AMD64_SUPPORT
; 822  :                 ( proc->sym.langtype == LANG_FASTCALL && ti.Ofssize != USE64 ) ||
; 823  :                 ( proc->sym.langtype == LANG_VECTORCALL && ti.Ofssize != USE64) ||

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 1
	je	SHORT $LN71@ParseParam
	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 2
	je	SHORT $LN71@ParseParam
	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 7
	jne	SHORT $LN72@ParseParam
	movzx	eax, BYTE PTR ti$[rsp+22]
	cmp	eax, 2
	jne	SHORT $LN71@ParseParam
$LN72@ParseParam:
	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 8
	jne	SHORT $LN73@ParseParam
	movzx	eax, BYTE PTR ti$[rsp+22]
	cmp	eax, 2
	jne	SHORT $LN71@ParseParam
$LN73@ParseParam:
	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 3
	jne	SHORT $LN69@ParseParam
$LN71@ParseParam:

; 824  : #else
; 825  :                 proc->sym.langtype == LANG_FASTCALL ||
; 826  : #endif
; 827  :                 proc->sym.langtype == LANG_STDCALL) {
; 828  :                 struct dsym *l;
; 829  :                 for (l = proc->e.procinfo->paralist;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR l$5[rsp], rax
	jmp	SHORT $LN20@ParseParam
$LN18@ParseParam:

; 831  :                      l = l->nextparam );

	mov	rax, QWORD PTR l$5[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR l$5[rsp], rax
$LN20@ParseParam:

; 830  :                      l && ( l->nextparam != paracurr );

	cmp	QWORD PTR l$5[rsp], 0
	je	SHORT $LN19@ParseParam
	mov	rax, QWORD PTR l$5[rsp]
	mov	rcx, QWORD PTR paracurr$[rsp]
	cmp	QWORD PTR [rax+112], rcx
	je	SHORT $LN19@ParseParam

; 831  :                      l = l->nextparam );

	jmp	SHORT $LN18@ParseParam
$LN19@ParseParam:

; 832  :                 paracurr = l;

	mov	rax, QWORD PTR l$5[rsp]
	mov	QWORD PTR paracurr$[rsp], rax

; 833  :             } else

	jmp	SHORT $LN70@ParseParam
$LN69@ParseParam:

; 834  :                 paracurr = paracurr->nextparam;

	mov	rax, QWORD PTR paracurr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR paracurr$[rsp], rax
$LN70@ParseParam:

; 835  : 
; 836  :         //} else if ( proc->e.procinfo->init_done == TRUE ) {
; 837  :         } else if ( init_done == TRUE ) {

	jmp	$LN61@ParseParam
$LN60@ParseParam:
	movzx	eax, BYTE PTR init_done$[rsp]
	cmp	eax, 1
	jne	SHORT $LN74@ParseParam

; 838  :             /* second definition has more parameters than first */
; 839  :             DebugMsg(("ParseParams: different param count\n"));

	lea	rcx, OFFSET FLAT:$SG11693
	call	DoDebugMsg

; 840  :             return( EmitErr( CONFLICTING_PARAMETER_DEFINITION, "" ) );

	lea	rdx, OFFSET FLAT:$SG11694
	mov	ecx, 137				; 00000089H
	call	EmitErr
	jmp	$LN1@ParseParam

; 841  :         } else {

	jmp	$LN75@ParseParam
$LN74@ParseParam:

; 842  :             if ( IsPROC ) {

	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	je	SHORT $LN76@ParseParam

; 843  :                 paranode = (struct dsym *)SymLCreate( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymLCreate
	mov	QWORD PTR paranode$[rsp], rax

; 844  :             } else

	jmp	SHORT $LN77@ParseParam
$LN76@ParseParam:

; 845  :                 paranode = (struct dsym *)SymAlloc( "" );/* for PROTO, no param name needed */

	lea	rcx, OFFSET FLAT:$SG11697
	call	SymAlloc
	mov	QWORD PTR paranode$[rsp], rax
$LN77@ParseParam:

; 846  : 
; 847  :             if( paranode == NULL ) { /* error msg has been displayed already */

	cmp	QWORD PTR paranode$[rsp], 0
	jne	SHORT $LN78@ParseParam

; 848  :                 DebugMsg(("ParseParams: SymLCreate(%s) failed\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11699
	call	DoDebugMsg

; 849  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@ParseParam
$LN78@ParseParam:

; 850  :             }
; 851  :             paranode->sym.isdefined = TRUE;

	mov	rax, QWORD PTR paranode$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR paranode$[rsp]
	mov	BYTE PTR [rcx+40], al

; 852  :             paranode->sym.mem_type = ti.mem_type;

	mov	rax, QWORD PTR paranode$[rsp]
	mov	ecx, DWORD PTR ti$[rsp+16]
	mov	DWORD PTR [rax+36], ecx

; 853  :             if ( ti.mem_type == MT_TYPE ) {

	cmp	DWORD PTR ti$[rsp+16], 196		; 000000c4H
	jne	$LN79@ParseParam

; 854  :                 paranode->sym.type = ti.symtype;

	mov	rax, QWORD PTR paranode$[rsp]
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rax+80], rcx

; 855  :                 /* this is where vectors are intercepted  and writen to the proc */
; 856  :                 if (proc->sym.langtype == LANG_VECTORCALL){

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 8
	jne	$LN81@ParseParam

; 857  :                     proc->e.procinfo->vecregsize[cntParam] = ti.symtype->max_mbr_size;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movsxd	rcx, DWORD PTR cntParam$[rsp]
	mov	rdx, QWORD PTR ti$[rsp+8]
	movzx	edx, BYTE PTR [rdx+48]
	mov	BYTE PTR [rax+rcx+62], dl

; 858  :                     proc->e.procinfo->vecregs[cntParam] = ti.size / ti.symtype->max_mbr_size;

	xor	edx, edx
	mov	eax, DWORD PTR ti$[rsp]
	mov	rcx, QWORD PTR ti$[rsp+8]
	div	DWORD PTR [rcx+48]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	movsxd	rdx, DWORD PTR cntParam$[rsp]
	mov	BYTE PTR [rcx+rdx+56], al

; 859  :                     proc->e.procinfo->vsize += ti.size;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+44]
	add	eax, DWORD PTR ti$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+44], eax

; 860  :                     ti.size = MT_QWORD;

	mov	DWORD PTR ti$[rsp], 7
$LN81@ParseParam:

; 861  :                   }
; 862  :             } else {

	jmp	$LN80@ParseParam
$LN79@ParseParam:

; 863  :                 paranode->sym.target_type = ti.symtype;

	mov	rax, QWORD PTR paranode$[rsp]
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rax+48], rcx

; 864  :                     /* this is where vectors are intercepted  and writen to the proc */
; 865  :                     if (proc->sym.langtype == LANG_VECTORCALL){

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 8
	jne	$LN82@ParseParam

; 866  :                       if (ti.mem_type == MT_REAL4 || ti.mem_type == MT_REAL8 ||
; 867  :                         ti.mem_type == MT_OWORD || ti.mem_type == MT_YMMWORD) {

	cmp	DWORD PTR ti$[rsp+16], 35		; 00000023H
	je	SHORT $LN84@ParseParam
	cmp	DWORD PTR ti$[rsp+16], 39		; 00000027H
	je	SHORT $LN84@ParseParam
	cmp	DWORD PTR ti$[rsp+16], 15
	je	SHORT $LN84@ParseParam
	cmp	DWORD PTR ti$[rsp+16], 31
	jne	SHORT $LN83@ParseParam
$LN84@ParseParam:

; 868  :                         proc->e.procinfo->vecregsize[cntParam] = ti.size;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movsxd	rcx, DWORD PTR cntParam$[rsp]
	movzx	edx, BYTE PTR ti$[rsp]
	mov	BYTE PTR [rax+rcx+62], dl

; 869  :                         proc->e.procinfo->vecregs[cntParam] = 1;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movsxd	rcx, DWORD PTR cntParam$[rsp]
	mov	BYTE PTR [rax+rcx+56], 1

; 870  :                         if (ti.size >= 16) proc->e.procinfo->vsize += ti.size;

	cmp	DWORD PTR ti$[rsp], 16
	jl	SHORT $LN85@ParseParam
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+44]
	add	eax, DWORD PTR ti$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+44], eax
$LN85@ParseParam:

; 871  :                         ti.size = MT_QWORD;

	mov	DWORD PTR ti$[rsp], 7
$LN83@ParseParam:
$LN82@ParseParam:
$LN80@ParseParam:

; 872  :                       }
; 873  :                  }
; 874  :             }
; 875  : 
; 876  :             /* v2.05: moved BEFORE fastcall_tab() */
; 877  :             paranode->sym.isfar   = ti.is_far;

	movzx	eax, BYTE PTR ti$[rsp+21]
	and	al, 1
	shl	al, 4
	mov	rcx, QWORD PTR paranode$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 239					; 000000efH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR paranode$[rsp]
	mov	BYTE PTR [rcx+47], al

; 878  :             paranode->sym.Ofssize = ti.Ofssize;

	mov	rax, QWORD PTR paranode$[rsp]
	movzx	ecx, BYTE PTR ti$[rsp+22]
	mov	BYTE PTR [rax+44], cl

; 879  :             paranode->sym.is_ptr  = ti.is_ptr;

	mov	rax, QWORD PTR paranode$[rsp]
	movzx	ecx, BYTE PTR ti$[rsp+20]
	mov	BYTE PTR [rax+45], cl

; 880  :             paranode->sym.ptr_memtype = ti.ptr_memtype;

	mov	rax, QWORD PTR paranode$[rsp]
	movzx	ecx, BYTE PTR ti$[rsp+24]
	mov	BYTE PTR [rax+46], cl

; 881  :             paranode->sym.is_vararg = is_vararg;

	movzx	eax, BYTE PTR is_vararg$[rsp]
	and	al, 1
	shl	al, 5
	mov	rcx, QWORD PTR paranode$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 223					; 000000dfH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR paranode$[rsp]
	mov	BYTE PTR [rcx+47], al

; 882  :             if ( proc->sym.langtype == LANG_FASTCALL &&

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 7
	jne	SHORT $LN86@ParseParam
	movsxd	rax, DWORD PTR ModuleInfo+376
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:fastcall_tab
	mov	QWORD PTR tv661[rsp], rcx
	lea	r8, QWORD PTR fcint$[rsp]
	mov	rdx, QWORD PTR paranode$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rbx, QWORD PTR tv661[rsp]
	call	QWORD PTR [rbx+rax]
	test	eax, eax
	je	SHORT $LN86@ParseParam

; 883  :                 fastcall_tab[ModuleInfo.fctype].paramcheck( proc, paranode, &fcint ) ) {
; 884  :             }

	jmp	SHORT $LN87@ParseParam
$LN86@ParseParam:

; 885  :             else if ( proc->sym.langtype == LANG_VECTORCALL &&

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 8
	jne	SHORT $LN88@ParseParam
	movsxd	rax, DWORD PTR ModuleInfo+376
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:vectorcall_tab
	mov	QWORD PTR tv662[rsp], rcx
	lea	r8, QWORD PTR fcint$[rsp]
	mov	rdx, QWORD PTR paranode$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rbx, QWORD PTR tv662[rsp]
	call	QWORD PTR [rbx+rax]
	test	eax, eax
	je	SHORT $LN88@ParseParam

; 886  :                 vectorcall_tab[ModuleInfo.fctype].paramcheck( proc, paranode, &fcint ) ) {
; 887  :             } 

	jmp	SHORT $LN89@ParseParam
$LN88@ParseParam:

; 888  :             else {
; 889  :                 paranode->sym.state = SYM_STACK;

	mov	rax, QWORD PTR paranode$[rsp]
	mov	DWORD PTR [rax+32], 5
$LN89@ParseParam:
$LN87@ParseParam:

; 890  :             }
; 891  : 
; 892  :             paranode->sym.total_length = 1; /* v2.04: added */

	mov	rax, QWORD PTR paranode$[rsp]
	mov	DWORD PTR [rax+64], 1

; 893  :             paranode->sym.total_size = ti.size;

	mov	rax, QWORD PTR paranode$[rsp]
	mov	ecx, DWORD PTR ti$[rsp]
	mov	DWORD PTR [rax+56], ecx

; 894  : 
; 895  :             if( paranode->sym.is_vararg == FALSE )

	mov	rax, QWORD PTR paranode$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	$LN90@ParseParam

; 896  :                 /* v2.11: CurrWordSize does reflect the default parameter size only for PROCs.
; 897  :                  * For PROTOs and TYPEs use member seg_ofssize.
; 898  :                  */
; 899  :                 //proc->e.procinfo->parasize += ROUND_UP( ti.size, CurrWordSize );
; 900  :                 proc->e.procinfo->parasize += ROUND_UP( ti.size, IsPROC ? CurrWordSize : ( 2 << proc->sym.seg_ofssize ) );

	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	je	SHORT $LN128@ParseParam
	movzx	eax, BYTE PTR ModuleInfo+406
	mov	DWORD PTR tv510[rsp], eax
	jmp	SHORT $LN129@ParseParam
$LN128@ParseParam:
	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	and	al, 3
	movzx	eax, al
	mov	ecx, 2
	mov	DWORD PTR tv896[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv896[rsp]
	shl	eax, cl
	mov	DWORD PTR tv510[rsp], eax
$LN129@ParseParam:
	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	je	SHORT $LN130@ParseParam
	movzx	eax, BYTE PTR ModuleInfo+406
	mov	DWORD PTR tv520[rsp], eax
	jmp	SHORT $LN131@ParseParam
$LN130@ParseParam:
	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	and	al, 3
	movzx	eax, al
	mov	ecx, 2
	mov	DWORD PTR tv901[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv901[rsp]
	shl	eax, cl
	mov	DWORD PTR tv520[rsp], eax
$LN131@ParseParam:
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR ti$[rsp]
	mov	edx, DWORD PTR tv510[rsp]
	lea	ecx, DWORD PTR [rcx+rdx-1]
	mov	edx, DWORD PTR tv520[rsp]
	dec	edx
	not	edx
	and	ecx, edx
	add	ecx, DWORD PTR [rax+32]
	mov	eax, ecx
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+32], eax
$LN90@ParseParam:

; 901  : 
; 902  :             /* v2.05: the PROC's vararg flag has been set already */
; 903  :             //proc->e.procinfo->is_vararg |= paranode->sym.is_vararg;
; 904  : 
; 905  :             /* Parameters usually are stored in "push" order.
; 906  :              * However, for Win64, it's better to store them
; 907  :              * the "natural" way from left to right, since the
; 908  :              * arguments aren't "pushed".
; 909  :              */
; 910  : 
; 911  :             switch( proc->sym.langtype ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	eax, DWORD PTR [rax+76]
	mov	DWORD PTR tv528[rsp], eax
	cmp	DWORD PTR tv528[rsp], 4
	jl	$LN98@ParseParam
	cmp	DWORD PTR tv528[rsp], 6
	jle	SHORT $LN91@ParseParam
	cmp	DWORD PTR tv528[rsp], 6
	jle	$LN98@ParseParam
	cmp	DWORD PTR tv528[rsp], 8
	jle	$LN95@ParseParam
	jmp	$LN98@ParseParam
$LN91@ParseParam:
$left_to_right$134:

; 912  :             case LANG_BASIC:
; 913  :             case LANG_FORTRAN:
; 914  :             case LANG_PASCAL:
; 915  :             left_to_right:
; 916  :                 paranode->nextparam = NULL;

	mov	rax, QWORD PTR paranode$[rsp]
	mov	QWORD PTR [rax+112], 0

; 917  :                 if( proc->e.procinfo->paralist == NULL ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+8], 0
	jne	SHORT $LN92@ParseParam

; 918  :                     proc->e.procinfo->paralist = paranode;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR paranode$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 919  :                 } else {

	jmp	SHORT $LN93@ParseParam
$LN92@ParseParam:

; 920  :                     for( paracurr = proc->e.procinfo->paralist;; paracurr = paracurr->nextparam ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR paracurr$[rsp], rax
	jmp	SHORT $LN25@ParseParam
$LN23@ParseParam:
	mov	rax, QWORD PTR paracurr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR paracurr$[rsp], rax
$LN25@ParseParam:

; 921  :                         if( paracurr->nextparam == NULL ) {

	mov	rax, QWORD PTR paracurr$[rsp]
	cmp	QWORD PTR [rax+112], 0
	jne	SHORT $LN94@ParseParam

; 922  :                             break;

	jmp	SHORT $LN24@ParseParam
$LN94@ParseParam:

; 923  :                         }
; 924  :                     }

	jmp	SHORT $LN23@ParseParam
$LN24@ParseParam:

; 925  :                     paracurr->nextparam = paranode;

	mov	rax, QWORD PTR paracurr$[rsp]
	mov	rcx, QWORD PTR paranode$[rsp]
	mov	QWORD PTR [rax+112], rcx

; 926  :                     paracurr = NULL;

	mov	QWORD PTR paracurr$[rsp], 0
$LN93@ParseParam:

; 927  :                 }
; 928  :                 break;

	jmp	SHORT $LN21@ParseParam
$LN95@ParseParam:

; 929  :             case LANG_FASTCALL:
; 930  :             case LANG_VECTORCALL:
; 931  : #if AMD64_SUPPORT
; 932  :                 if ( ti.Ofssize == USE64 )

	movzx	eax, BYTE PTR ti$[rsp+22]
	cmp	eax, 2
	jne	SHORT $LN96@ParseParam

; 933  :                     goto left_to_right;

	jmp	$left_to_right$134
$LN96@ParseParam:

; 934  : #endif
; 935  :                 /* v2.07: MS fastcall 16-bit is PASCAL! */
; 936  :                 if ( ti.Ofssize == USE16 && ModuleInfo.fctype == FCT_MSC )

	movzx	eax, BYTE PTR ti$[rsp+22]
	test	eax, eax
	jne	SHORT $LN97@ParseParam
	cmp	DWORD PTR ModuleInfo+376, 0
	jne	SHORT $LN97@ParseParam

; 937  :                     goto left_to_right;

	jmp	$left_to_right$134
$LN97@ParseParam:
$LN98@ParseParam:

; 938  :             default:
; 939  :                 paranode->nextparam = proc->e.procinfo->paralist;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR paranode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+112], rax

; 940  :                 proc->e.procinfo->paralist = paranode;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR paranode$[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN21@ParseParam:
$LN75@ParseParam:
$LN61@ParseParam:

; 941  :                 break;
; 942  :             }
; 943  :         }
; 944  :         if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN99@ParseParam

; 945  :             if( tokenarray[i].token != T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN100@ParseParam

; 946  :                 DebugMsg(("ParseParams: error, cntParam=%u, found %s\n", cntParam, tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	edx, DWORD PTR cntParam$[rsp]
	lea	rcx, OFFSET FLAT:$SG11722
	call	DoDebugMsg

; 947  :                 return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	$LN1@ParseParam
$LN100@ParseParam:

; 948  :             }
; 949  :             i++;    /* go past comma */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN99@ParseParam:

; 950  :         }
; 951  :     } /* end for */

	jmp	$LN5@ParseParam
$LN6@ParseParam:

; 952  :     //if (proc->sym.langtype == LANG_VECTORCALL)__debugbreak();
; 953  :     //if ( proc->e.procinfo->init_done == TRUE ) {
; 954  :     if ( init_done == TRUE ) {

	movzx	eax, BYTE PTR init_done$[rsp]
	cmp	eax, 1
	jne	SHORT $LN101@ParseParam

; 955  :         if ( paracurr ) {

	cmp	QWORD PTR paracurr$[rsp], 0
	je	SHORT $LN102@ParseParam

; 956  :             /* first definition has more parameters than second */
; 957  :             DebugMsg(("ParseParams: a param is left over, cntParam=%u\n", cntParam));

	mov	edx, DWORD PTR cntParam$[rsp]
	lea	rcx, OFFSET FLAT:$SG11725
	call	DoDebugMsg

; 958  :             return( EmitErr( CONFLICTING_PARAMETER_DEFINITION, "" ) );

	lea	rdx, OFFSET FLAT:$SG11726
	mov	ecx, 137				; 00000089H
	call	EmitErr
	jmp	$LN1@ParseParam
$LN102@ParseParam:
$LN101@ParseParam:

; 959  :         }
; 960  :     }
; 961  : 
; 962  :     if ( IsPROC ) {

	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	je	$LN103@ParseParam

; 963  :         /* calc starting offset for parameters,
; 964  :          * offset from [E|R]BP : return addr + old [E|R]BP
; 965  :          * NEAR: 2 * wordsize, FAR: 3 * wordsize
; 966  :          *         NEAR  FAR
; 967  :          *-------------------------
; 968  :          * USE16   +4    +6
; 969  :          * USE32   +8    +12
; 970  :          * USE64   +16   +24
; 971  :          * without frame pointer:
; 972  :          * USE16   +2    +4
; 973  :          * USE32   +4    +8
; 974  :          * USE64   +8    +16
; 975  :          */
; 976  :         offset = ( ( 2 + ( proc->sym.mem_type == MT_FAR ? 1 : 0 ) ) * CurrWordSize );

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN132@ParseParam
	mov	DWORD PTR tv594[rsp], 1
	jmp	SHORT $LN133@ParseParam
$LN132@ParseParam:
	mov	DWORD PTR tv594[rsp], 0
$LN133@ParseParam:
	mov	eax, DWORD PTR tv594[rsp]
	add	eax, 2
	movzx	ecx, BYTE PTR ModuleInfo+406
	imul	eax, ecx
	mov	DWORD PTR offset$[rsp], eax

; 977  : 
; 978  :         /* now calculate the [E|R]BP offsets */
; 979  : 
; 980  : #if AMD64_SUPPORT
; 981  :         if ( ModuleInfo.Ofssize == USE64)  {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	$LN104@ParseParam

; 982  :           if (proc->sym.langtype == LANG_FASTCALL || proc->sym.langtype == LANG_VECTORCALL ){

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 7
	je	SHORT $LN107@ParseParam
	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 8
	jne	$LN106@ParseParam
$LN107@ParseParam:

; 983  :             for (paranode = proc->e.procinfo->paralist; paranode; paranode = paranode->nextparam)

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR paranode$[rsp], rax
	jmp	SHORT $LN28@ParseParam
$LN26@ParseParam:
	mov	rax, QWORD PTR paranode$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR paranode$[rsp], rax
$LN28@ParseParam:
	cmp	QWORD PTR paranode$[rsp], 0
	je	$LN27@ParseParam

; 984  :               if (paranode->sym.state == SYM_TMACRO) /* register param */

	mov	rax, QWORD PTR paranode$[rsp]
	cmp	DWORD PTR [rax+32], 10
	jne	SHORT $LN108@ParseParam

; 985  :                 ;

	jmp	$LN109@ParseParam
$LN108@ParseParam:

; 986  :               else {
; 987  :                 paranode->sym.offset = offset;

	mov	rax, QWORD PTR paranode$[rsp]
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 988  :                 proc->e.procinfo->stackparam = TRUE;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+128], al

; 989  :                 offset += ROUND_UP(paranode->sym.total_size, CurrWordSize);

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	rcx, QWORD PTR paranode$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	lea	eax, DWORD PTR [rcx+rax-1]
	movzx	ecx, BYTE PTR ModuleInfo+406
	dec	ecx
	not	ecx
	and	eax, ecx
	mov	ecx, DWORD PTR offset$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR offset$[rsp], eax

; 990  :                 /* set isparam var for W64F_HABRAN */
; 991  :                 if (ModuleInfo.win64_flags & W64F_HABRAN) paranode->sym.isparam = TRUE;

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	je	SHORT $LN110@ParseParam
	mov	rax, QWORD PTR paranode$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR paranode$[rsp]
	mov	BYTE PTR [rcx+41], al
$LN110@ParseParam:
$LN109@ParseParam:

; 992  :               }

	jmp	$LN26@ParseParam
$LN27@ParseParam:
$LN106@ParseParam:

; 993  :           }
; 994  :         } else

	jmp	$LN105@ParseParam
$LN104@ParseParam:

; 995  : #endif
; 996  :         for ( ; cntParam; cntParam-- ) {

	jmp	SHORT $LN31@ParseParam
$LN29@ParseParam:
	mov	eax, DWORD PTR cntParam$[rsp]
	dec	eax
	mov	DWORD PTR cntParam$[rsp], eax
$LN31@ParseParam:
	cmp	DWORD PTR cntParam$[rsp], 0
	je	$LN30@ParseParam

; 997  :             for ( curr = 1, paranode = proc->e.procinfo->paralist; curr < cntParam;paranode = paranode->nextparam, curr++ );

	mov	DWORD PTR curr$[rsp], 1
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR paranode$[rsp], rax
	jmp	SHORT $LN34@ParseParam
$LN32@ParseParam:
	mov	rax, QWORD PTR paranode$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR paranode$[rsp], rax
	mov	eax, DWORD PTR curr$[rsp]
	inc	eax
	mov	DWORD PTR curr$[rsp], eax
$LN34@ParseParam:
	mov	eax, DWORD PTR cntParam$[rsp]
	cmp	DWORD PTR curr$[rsp], eax
	jge	SHORT $LN33@ParseParam
	jmp	SHORT $LN32@ParseParam
$LN33@ParseParam:

; 998  :             DebugMsg1(("ParseParams: parm=%s, ofs=%u, size=%d\n", paranode->sym.name, offset, paranode->sym.total_size));

	mov	rax, QWORD PTR paranode$[rsp]
	mov	r9d, DWORD PTR [rax+56]
	mov	r8d, DWORD PTR offset$[rsp]
	mov	rax, QWORD PTR paranode$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11735
	call	DoDebugMsg1

; 999  :             if ( paranode->sym.state == SYM_TMACRO ) /* register param? */

	mov	rax, QWORD PTR paranode$[rsp]
	cmp	DWORD PTR [rax+32], 10
	jne	SHORT $LN111@ParseParam

; 1000 :                 ;

	jmp	SHORT $LN112@ParseParam
$LN111@ParseParam:

; 1001 :             else {
; 1002 :                 paranode->sym.offset = offset;

	mov	rax, QWORD PTR paranode$[rsp]
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 1003 :                 proc->e.procinfo->stackparam = TRUE;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+128], al

; 1004 :                 offset += ROUND_UP( paranode->sym.total_size, CurrWordSize );

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	rcx, QWORD PTR paranode$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	lea	eax, DWORD PTR [rcx+rax-1]
	movzx	ecx, BYTE PTR ModuleInfo+406
	dec	ecx
	not	ecx
	and	eax, ecx
	mov	ecx, DWORD PTR offset$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR offset$[rsp], eax
$LN112@ParseParam:

; 1005 :             }
; 1006 :         }

	jmp	$LN29@ParseParam
$LN30@ParseParam:
$LN105@ParseParam:
$LN103@ParseParam:

; 1007 :     }
; 1008 :     return ( NOT_ERROR );

	xor	eax, eax
$LN1@ParseParam:

; 1009 : }

	add	rsp, 352				; 00000160H
	pop	rbx
	ret	0
ParseParams ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
tv66 = 0
sym$ = 32
opnd$ = 40
UpdateProcStatus PROC

; 623  : {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 624  :     sym->value = ( CurrProc ? ProcStatus : 0 );

	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN3@UpdateProc
	mov	eax, DWORD PTR ProcStatus
	mov	DWORD PTR tv66[rsp], eax
	jmp	SHORT $LN4@UpdateProc
$LN3@UpdateProc:
	mov	DWORD PTR tv66[rsp], 0
$LN4@UpdateProc:
	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR tv66[rsp]
	mov	DWORD PTR [rax+16], ecx

; 625  : }

	add	rsp, 24
	ret	0
UpdateProcStatus ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
sym$ = 8
opnd$ = 16
UpdateStackBase PROC

; 610  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 611  :     if ( opnd ) {

	cmp	QWORD PTR opnd$[rsp], 0
	je	SHORT $LN2@UpdateStac

; 612  :         StackAdj = opnd->uvalue;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR StackAdj, eax

; 613  :         StackAdjHigh = opnd->hvalue;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR StackAdjHigh, eax
$LN2@UpdateStac:

; 614  :     }
; 615  :     sym->value = StackAdj;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR StackAdj
	mov	DWORD PTR [rax+16], ecx

; 616  :     sym->value3264 = StackAdjHigh;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR StackAdjHigh
	mov	DWORD PTR [rax+56], ecx

; 617  : }

	ret	0
UpdateStackBase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
local$ = 48
j$1 = 56
info$ = 64
ti$ = 72
curr$ = 104
tv306 = 112
tv160 = 116
name$ = 120
tv230 = 128
opndx$2 = 144
i$ = 272
tokenarray$ = 280
LocalDir PROC

; 445  : {

$LN44:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 264				; 00000108H

; 446  :     char        *name;
; 447  :     struct dsym *local;
; 448  :     struct dsym *curr;
; 449  :     struct proc_info *info;
; 450  :     //int         size;
; 451  :     //int         idx;
; 452  :     struct qualified_type ti;
; 453  : 
; 454  :     if ( Parse_Pass != PASS_1 ) /* everything is done in pass 1 */

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN13@LocalDir

; 455  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@LocalDir
$LN13@LocalDir:

; 456  : 
; 457  :     DebugMsg1(("LocalDir(%u) entry\n", i));

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11531
	call	DoDebugMsg1

; 458  : 
; 459  :     if( !( ProcStatus & PRST_PROLOGUE_NOT_DONE ) || CurrProc == NULL ) {

	mov	eax, DWORD PTR ProcStatus
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN15@LocalDir
	cmp	QWORD PTR CurrProc, 0
	jne	SHORT $LN14@LocalDir
$LN15@LocalDir:

; 460  :         return( EmitError( PROC_MACRO_MUST_PRECEDE_LOCAL ) );

	mov	ecx, 92					; 0000005cH
	call	EmitError
	jmp	$LN1@LocalDir
$LN14@LocalDir:

; 461  :     }
; 462  :     info = CurrProc->e.procinfo;

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR info$[rsp], rax

; 463  : #if STACKBASESUPP
; 464  :     /* ensure the fpo bit is set - it's too late to set it in write_prologue().
; 465  :      * Note that the fpo bit is set only IF there are locals or arguments.
; 466  :      * fixme: what if pass > 1?
; 467  :      */
; 468  :     if ( GetRegNo( info->basereg ) == 4 ) {

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+130]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	cmp	eax, 4
	jne	SHORT $LN16@LocalDir

; 469  :         info->fpo = TRUE;

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+128], al

; 470  :         ProcStatus |= PRST_FPO;

	mov	eax, DWORD PTR ProcStatus
	or	eax, 4
	mov	DWORD PTR ProcStatus, eax
$LN16@LocalDir:

; 471  :     }
; 472  : #endif
; 473  : 
; 474  :     i++; /* go past LOCAL */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@LocalDir:

; 475  : 
; 476  :     do  {
; 477  :         if( tokenarray[i].token != T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN17@LocalDir

; 478  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@LocalDir
$LN17@LocalDir:

; 479  :         }
; 480  :         name = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR name$[rsp], rax

; 481  : 
; 482  :         DebugMsg1(("LocalDir: item=%s\n", tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11536
	call	DoDebugMsg1

; 483  : 
; 484  :         ti.symtype = NULL;

	mov	QWORD PTR ti$[rsp+8], 0

; 485  :         ti.is_ptr = 0;

	mov	BYTE PTR ti$[rsp+20], 0

; 486  :         ti.ptr_memtype = MT_EMPTY;

	mov	DWORD PTR ti$[rsp+24], 192		; 000000c0H

; 487  :         if ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) )

	mov	eax, DWORD PTR ModuleInfo+360
	mov	ecx, 1
	mov	DWORD PTR tv306[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv306[rsp]
	shl	eax, cl
	and	eax, 104				; 00000068H
	test	eax, eax
	je	SHORT $LN18@LocalDir

; 488  :             ti.is_far = TRUE;

	mov	BYTE PTR ti$[rsp+21], 1
	jmp	SHORT $LN19@LocalDir
$LN18@LocalDir:

; 489  :         else
; 490  :             ti.is_far = FALSE;

	mov	BYTE PTR ti$[rsp+21], 0
$LN19@LocalDir:

; 491  :         ti.Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	BYTE PTR ti$[rsp+22], al

; 492  : 
; 493  : #if 0
; 494  :         /* since v1.95 a local hash table is used. No need to search the
; 495  :          * symbol before SymLCreate() is called. SymLCreate() will display
; 496  :          * an error if the symbol is already defined.
; 497  :          */
; 498  :         if ((local = (struct dsym *)SymSearch( name )) && local->sym.state != SYM_UNDEFINED ) {
; 499  :             return( EmitErr( SYMBOL_ALREADY_DEFINED, name ) );
; 500  :         }
; 501  : #endif
; 502  :         local = (struct dsym *)SymLCreate( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymLCreate
	mov	QWORD PTR local$[rsp], rax

; 503  :         if( !local ) { /* if it failed, an error msg has been written already */

	cmp	QWORD PTR local$[rsp], 0
	jne	SHORT $LN20@LocalDir

; 504  :             DebugMsg(("LocalDir: SymLCreate( %s ) failed\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11540
	call	DoDebugMsg

; 505  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@LocalDir
$LN20@LocalDir:

; 506  :         }
; 507  :         if (ModuleInfo.win64_flags & W64F_HABRAN) local->sym.isparam = FALSE; //clear isparam var, added  by habran

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	je	SHORT $LN21@LocalDir
	mov	rax, QWORD PTR local$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	and	al, 127					; 0000007fH
	mov	rcx, QWORD PTR local$[rsp]
	mov	BYTE PTR [rcx+41], al
$LN21@LocalDir:

; 508  :         local->sym.state = SYM_STACK;

	mov	rax, QWORD PTR local$[rsp]
	mov	DWORD PTR [rax+32], 5

; 509  :         local->sym.isdefined = TRUE;

	mov	rax, QWORD PTR local$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR local$[rsp]
	mov	BYTE PTR [rcx+40], al

; 510  :         local->sym.total_length = 1; /* v2.04: added */

	mov	rax, QWORD PTR local$[rsp]
	mov	DWORD PTR [rax+64], 1

; 511  :         switch ( ti.Ofssize ) {

	movzx	eax, BYTE PTR ti$[rsp+22]
	mov	BYTE PTR tv160[rsp], al
	cmp	BYTE PTR tv160[rsp], 0
	je	SHORT $LN22@LocalDir
	jmp	SHORT $LN23@LocalDir
$LN22@LocalDir:

; 512  :         case USE16:
; 513  :             local->sym.mem_type = MT_WORD;

	mov	rax, QWORD PTR local$[rsp]
	mov	DWORD PTR [rax+36], 1

; 514  :             ti.size = sizeof( uint_16 );

	mov	DWORD PTR ti$[rsp], 2

; 515  :             break;

	jmp	SHORT $LN5@LocalDir
$LN23@LocalDir:

; 516  : #if AMD64_SUPPORT
; 517  :             /* v2.08: default type for locals in 64-bit is still DWORD (at least in Win64) */
; 518  :             //case USE64: local->sym.mem_type = MT_QWORD; break;
; 519  :             //ti.size = sizeof( uint_64 );
; 520  : #endif
; 521  :         default: 
; 522  :             local->sym.mem_type = MT_DWORD;

	mov	rax, QWORD PTR local$[rsp]
	mov	DWORD PTR [rax+36], 3

; 523  :             ti.size = sizeof( uint_32 );

	mov	DWORD PTR ti$[rsp], 4
$LN5@LocalDir:

; 524  :             break;
; 525  :         }
; 526  : 
; 527  :         i++; /* go past name */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 528  : 
; 529  :         /* get the optional index factor: local name[xx]:... */
; 530  :         if( tokenarray[i].token == T_OP_SQ_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 91					; 0000005bH
	jne	$LN24@LocalDir

; 531  :             int j;
; 532  :             struct expr opndx;
; 533  :             i++; /* go past '[' */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 534  :             /* scan for comma or colon. this isn't really necessary,
; 535  :              * but will prevent the expression evaluator from emitting
; 536  :              * confusing error messages.
; 537  :              */
; 538  :             for ( j = i; j < Token_Count; j++ )

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR j$1[rsp], eax
	jmp	SHORT $LN9@LocalDir
$LN7@LocalDir:
	mov	eax, DWORD PTR j$1[rsp]
	inc	eax
	mov	DWORD PTR j$1[rsp], eax
$LN9@LocalDir:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR j$1[rsp], eax
	jge	SHORT $LN8@LocalDir

; 539  :                 if ( tokenarray[j].token == T_COMMA ||

	movsxd	rax, DWORD PTR j$1[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN26@LocalDir
	movsxd	rax, DWORD PTR j$1[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN25@LocalDir
$LN26@LocalDir:

; 540  :                     tokenarray[j].token == T_COLON)
; 541  :                     break;

	jmp	SHORT $LN8@LocalDir
$LN25@LocalDir:
	jmp	SHORT $LN7@LocalDir
$LN8@LocalDir:

; 542  :             if ( ERROR == EvalOperand( &i, tokenarray, j, &opndx, 0 ) )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$2[rsp]
	mov	r8d, DWORD PTR j$1[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN27@LocalDir

; 543  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@LocalDir
$LN27@LocalDir:

; 544  :             if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$2[rsp+60], 0
	je	SHORT $LN28@LocalDir

; 545  :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 546  :                 opndx.value = 1;

	mov	DWORD PTR opndx$2[rsp], 1
$LN28@LocalDir:

; 547  :             }
; 548  :             /* zero is allowed as value! */
; 549  :             local->sym.total_length = opndx.value;

	mov	rax, QWORD PTR local$[rsp]
	mov	ecx, DWORD PTR opndx$2[rsp]
	mov	DWORD PTR [rax+64], ecx

; 550  :             local->sym.isarray = TRUE;

	mov	rax, QWORD PTR local$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	or	al, 2
	mov	rcx, QWORD PTR local$[rsp]
	mov	BYTE PTR [rcx+41], al

; 551  :             if( tokenarray[i].token == T_CL_SQ_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 93					; 0000005dH
	jne	SHORT $LN29@LocalDir

; 552  :                 i++; /* go past ']' */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 553  :             } else {

	jmp	SHORT $LN30@LocalDir
$LN29@LocalDir:

; 554  :                 EmitError( EXPECTED_CL_SQ_BRACKET );

	mov	ecx, 111				; 0000006fH
	call	EmitError
$LN30@LocalDir:
$LN24@LocalDir:

; 555  :             }
; 556  :         }
; 557  : 
; 558  :         /* get the optional type: local name[xx]:type  */
; 559  :         if( tokenarray[i].token == T_COLON ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	$LN31@LocalDir

; 560  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 561  : 
; 562  :             if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	GetQualifiedType
	cmp	eax, -1
	jne	SHORT $LN32@LocalDir

; 563  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@LocalDir
$LN32@LocalDir:

; 564  : 
; 565  :             local->sym.mem_type = ti.mem_type;

	mov	rax, QWORD PTR local$[rsp]
	mov	ecx, DWORD PTR ti$[rsp+16]
	mov	DWORD PTR [rax+36], ecx

; 566  :             if ( ti.mem_type == MT_TYPE ) {

	cmp	DWORD PTR ti$[rsp+16], 196		; 000000c4H
	jne	SHORT $LN33@LocalDir

; 567  :                 local->sym.type = ti.symtype;

	mov	rax, QWORD PTR local$[rsp]
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rax+80], rcx

; 568  :             } else {

	jmp	SHORT $LN34@LocalDir
$LN33@LocalDir:

; 569  :                 local->sym.target_type = ti.symtype;

	mov	rax, QWORD PTR local$[rsp]
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rax+48], rcx
$LN34@LocalDir:

; 570  :             }
; 571  :             DebugMsg1(("LocalDir: memtype=%X, type=%s, size=%u*%u\n",

	cmp	QWORD PTR ti$[rsp+8], 0
	je	SHORT $LN42@LocalDir
	mov	rax, QWORD PTR ti$[rsp+8]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv230[rsp], rax
	jmp	SHORT $LN43@LocalDir
$LN42@LocalDir:
	lea	rax, OFFSET FLAT:$SG11555
	mov	QWORD PTR tv230[rsp], rax
$LN43@LocalDir:
	mov	rax, QWORD PTR local$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR ti$[rsp]
	mov	r8, QWORD PTR tv230[rsp]
	mov	rax, QWORD PTR local$[rsp]
	mov	edx, DWORD PTR [rax+36]
	lea	rcx, OFFSET FLAT:$SG11556
	call	DoDebugMsg1
$LN31@LocalDir:

; 572  :                        local->sym.mem_type,
; 573  :                        ti.symtype ? ti.symtype->name : "NULL",
; 574  :                        ti.size, local->sym.total_length ));
; 575  :         }
; 576  :         local->sym.is_ptr  = ti.is_ptr;

	mov	rax, QWORD PTR local$[rsp]
	movzx	ecx, BYTE PTR ti$[rsp+20]
	mov	BYTE PTR [rax+45], cl

; 577  :         local->sym.isfar   = ti.is_far;

	movzx	eax, BYTE PTR ti$[rsp+21]
	and	al, 1
	shl	al, 4
	mov	rcx, QWORD PTR local$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 239					; 000000efH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR local$[rsp]
	mov	BYTE PTR [rcx+47], al

; 578  :         local->sym.Ofssize = ti.Ofssize;

	mov	rax, QWORD PTR local$[rsp]
	movzx	ecx, BYTE PTR ti$[rsp+22]
	mov	BYTE PTR [rax+44], cl

; 579  :         local->sym.ptr_memtype = ti.ptr_memtype;

	mov	rax, QWORD PTR local$[rsp]
	movzx	ecx, BYTE PTR ti$[rsp+24]
	mov	BYTE PTR [rax+46], cl

; 580  :         local->sym.total_size = ti.size * local->sym.total_length;

	mov	rax, QWORD PTR local$[rsp]
	mov	ecx, DWORD PTR ti$[rsp]
	imul	ecx, DWORD PTR [rax+64]
	mov	eax, ecx
	mov	rcx, QWORD PTR local$[rsp]
	mov	DWORD PTR [rcx+56], eax

; 581  : 
; 582  :         /* v2.12: address calculation is now done in SetLocalOffsets() */
; 583  : 
; 584  :         if( info->locallist == NULL ) {

	mov	rax, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN35@LocalDir

; 585  :             info->locallist = local;

	mov	rax, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR local$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 586  :         } else {

	jmp	SHORT $LN36@LocalDir
$LN35@LocalDir:

; 587  :             for( curr = info->locallist; curr->nextlocal ; curr = curr->nextlocal );

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN12@LocalDir
$LN10@LocalDir:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN12@LocalDir:
	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+112], 0
	je	SHORT $LN11@LocalDir
	jmp	SHORT $LN10@LocalDir
$LN11@LocalDir:

; 588  :             curr->nextlocal = local;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR local$[rsp]
	mov	QWORD PTR [rax+112], rcx
$LN36@LocalDir:

; 589  :         }
; 590  : 
; 591  :         if ( tokenarray[i].token != T_FINAL )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN37@LocalDir

; 592  :             if ( tokenarray[i].token == T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN38@LocalDir

; 593  :                 if ( (i + 1) < Token_Count )

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cmp	eax, DWORD PTR ModuleInfo+496
	jge	SHORT $LN40@LocalDir

; 594  :                     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN40@LocalDir:

; 595  :             } else {

	jmp	SHORT $LN39@LocalDir
$LN38@LocalDir:

; 596  :                 return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	SHORT $LN1@LocalDir
$LN39@LocalDir:
$LN37@LocalDir:

; 597  :             }
; 598  : 
; 599  :     } while ( i < Token_Count );

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jl	$LN4@LocalDir

; 600  : 
; 601  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@LocalDir:

; 602  : }

	add	rsp, 264				; 00000108H
	ret	0
LocalDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
pop_proc PROC

; 429  : {

	sub	rsp, 40					; 00000028H

; 430  :     if( ProcStack == NULL )

	cmp	QWORD PTR ProcStack, 0
	jne	SHORT $LN2@pop_proc

; 431  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@pop_proc
$LN2@pop_proc:

; 432  :     return( (struct dsym *)popitem( &ProcStack ) );

	lea	rcx, OFFSET FLAT:ProcStack
	call	popitem
$LN1@pop_proc:

; 433  : }

	add	rsp, 40					; 00000028H
	ret	0
pop_proc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
proc$ = 48
push_proc PROC

; 420  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 421  :     if ( Parse_Pass == PASS_1 ) /* get the locals stored so far */

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN2@push_proc

; 422  :         SymGetLocal( (struct asym *)proc );

	mov	rcx, QWORD PTR proc$[rsp]
	call	SymGetLocal
$LN2@push_proc:

; 423  :     pushitem( &ProcStack, proc );

	mov	rdx, QWORD PTR proc$[rsp]
	lea	rcx, OFFSET FLAT:ProcStack
	call	pushitem

; 424  :     return;
; 425  : }

	add	rsp, 40					; 00000028H
	ret	0
push_proc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
stack$ = 0
node$ = 8
elmt$ = 16
stk$ = 48
popitem	PROC

; 389  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 390  :     void        **stack = stk;

	mov	rax, QWORD PTR stk$[rsp]
	mov	QWORD PTR stack$[rsp], rax

; 391  :     struct qnode *node;
; 392  :     void        *elmt;
; 393  : 
; 394  :     node = (struct qnode *)(*stack);

	mov	rax, QWORD PTR stack$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR node$[rsp], rax

; 395  :     *stack = node->next;

	mov	rax, QWORD PTR stack$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 396  :     elmt = (void *)node->elmt;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR elmt$[rsp], rax

; 397  :     LclFree( node );
; 398  :     return( elmt );

	mov	rax, QWORD PTR elmt$[rsp]

; 399  : }

	add	rsp, 40					; 00000028H
	ret	0
popitem	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
node$ = 32
stack$ = 40
stk$ = 64
elmt$ = 72
pushitem PROC

; 377  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 378  :     void      **stack = stk;

	mov	rax, QWORD PTR stk$[rsp]
	mov	QWORD PTR stack$[rsp], rax

; 379  :     struct qnode *node;
; 380  : 
; 381  :     node = LclAlloc( sizeof( struct qnode ));

	mov	ecx, 16
	call	LclAlloc
	mov	QWORD PTR node$[rsp], rax

; 382  :     node->next = *stack;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR stack$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 383  :     node->elmt = elmt;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR elmt$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 384  :     *stack = node;

	mov	rax, QWORD PTR stack$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax], rcx

; 385  : }

	add	rsp, 56					; 00000038H
	ret	0
pushitem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
proc$ = 8
buffer$ = 16
ms64_return PROC

; 369  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 370  :     /* nothing to do, the caller cleans the stack */
; 371  :     return;
; 372  : }

	ret	0
ms64_return ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
proc$ = 8
paranode$ = 16
used$ = 24
ms64_pcheck PROC

; 358  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 359  :     /* since the parameter names refer the stack-backup locations,
; 360  :      * there's nothing to do here!
; 361  :      * That is, if a parameter's size is > 8, it has to be changed
; 362  :      * to a pointer. This is to be done yet.
; 363  :      */
; 364  :     return( 0 );

	xor	eax, eax

; 365  : }

	ret	0
ms64_pcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
value$ = 32
tv77 = 36
tv81 = 40
proc$ = 64
buffer$ = 72
watc_return PROC

; 296  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 297  :     int value;
; 298  :     value = 4 * CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	shl	eax, 2
	mov	DWORD PTR value$[rsp], eax

; 299  :     if( proc->e.procinfo->has_vararg == FALSE && proc->e.procinfo->parasize > value )

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@watc_retur
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR value$[rsp]
	cmp	DWORD PTR [rax+32], ecx
	jbe	SHORT $LN2@watc_retur

; 300  :         sprintf( buffer + strlen( buffer ), "%d%c", proc->e.procinfo->parasize - value, ModuleInfo.radix != 10 ? 't' : NULLC );

	movzx	eax, BYTE PTR ModuleInfo+396
	cmp	eax, 10
	je	SHORT $LN4@watc_retur
	mov	DWORD PTR tv77[rsp], 116		; 00000074H
	jmp	SHORT $LN5@watc_retur
$LN4@watc_retur:
	mov	DWORD PTR tv77[rsp], 0
$LN5@watc_retur:
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR value$[rsp]
	mov	eax, DWORD PTR [rax+32]
	sub	eax, ecx
	mov	DWORD PTR tv81[rsp], eax
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strlen
	mov	rcx, QWORD PTR buffer$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r9d, DWORD PTR tv77[rsp]
	mov	ecx, DWORD PTR tv81[rsp]
	mov	r8d, ecx
	lea	rdx, OFFSET FLAT:$SG11438
	mov	rcx, rax
	call	sprintf
$LN2@watc_retur:

; 301  :     return;
; 302  : }

	add	rsp, 56					; 00000038H
	ret	0
watc_return ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
Ofssize$ = 64
firstreg$ = 68
size$ = 72
newflg$ = 76
shift$ = 80
tv134 = 84
tv88 = 88
tv91 = 92
$T1 = 96
tv271 = 104
tv209 = 112
proc$ = 144
paranode$ = 152
used$ = 160
watc_pcheck PROC

; 215  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 216  :     static char regname[64];
; 217  :     static char regist[32];
; 218  :     int newflg;
; 219  :     int shift;
; 220  :     int firstreg;
; 221  :     uint_8 Ofssize = GetSymOfssize( &proc->sym );

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, rax
	call	GetSymOfssize
	mov	BYTE PTR Ofssize$[rsp], al

; 222  :     int size = SizeFromMemtype( paranode->sym.mem_type, paranode->sym.Ofssize, paranode->sym.type );

	mov	rax, QWORD PTR paranode$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	rcx, QWORD PTR paranode$[rsp]
	mov	r8, QWORD PTR [rcx+80]
	mov	edx, eax
	mov	rax, QWORD PTR paranode$[rsp]
	mov	ecx, DWORD PTR [rax+36]
	call	SizeFromMemtype
	mov	DWORD PTR size$[rsp], eax

; 223  : 
; 224  :     /* v2.05: VARARG procs don't have register params */
; 225  :     if ( proc->e.procinfo->has_vararg )

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@watc_pchec

; 226  :         return( 0 );

	xor	eax, eax
	jmp	$LN1@watc_pchec
$LN10@watc_pchec:

; 227  : 
; 228  :     if ( size != 1 && size != 2 && size != 4 && size != 8 )

	cmp	DWORD PTR size$[rsp], 1
	je	SHORT $LN11@watc_pchec
	cmp	DWORD PTR size$[rsp], 2
	je	SHORT $LN11@watc_pchec
	cmp	DWORD PTR size$[rsp], 4
	je	SHORT $LN11@watc_pchec
	cmp	DWORD PTR size$[rsp], 8
	je	SHORT $LN11@watc_pchec

; 229  :         return( 0 );

	xor	eax, eax
	jmp	$LN1@watc_pchec
$LN11@watc_pchec:

; 230  : 
; 231  :     /* v2.05: rewritten. The old code didn't allow to "fill holes" */
; 232  :     if ( size == 8 ) {

	cmp	DWORD PTR size$[rsp], 8
	jne	SHORT $LN12@watc_pchec

; 233  :         newflg = Ofssize ? 3 : 15;

	movzx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	je	SHORT $LN30@watc_pchec
	mov	DWORD PTR tv88[rsp], 3
	jmp	SHORT $LN31@watc_pchec
$LN30@watc_pchec:
	mov	DWORD PTR tv88[rsp], 15
$LN31@watc_pchec:
	mov	eax, DWORD PTR tv88[rsp]
	mov	DWORD PTR newflg$[rsp], eax

; 234  :         shift = Ofssize ? 2 : 4;

	movzx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	je	SHORT $LN32@watc_pchec
	mov	DWORD PTR tv91[rsp], 2
	jmp	SHORT $LN33@watc_pchec
$LN32@watc_pchec:
	mov	DWORD PTR tv91[rsp], 4
$LN33@watc_pchec:
	mov	eax, DWORD PTR tv91[rsp]
	mov	DWORD PTR shift$[rsp], eax
	jmp	SHORT $LN13@watc_pchec
$LN12@watc_pchec:

; 235  :     } else if ( size == 4 && Ofssize == USE16 ) {

	cmp	DWORD PTR size$[rsp], 4
	jne	SHORT $LN14@watc_pchec
	movzx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	jne	SHORT $LN14@watc_pchec

; 236  :         newflg = 3;

	mov	DWORD PTR newflg$[rsp], 3

; 237  :         shift = 2;

	mov	DWORD PTR shift$[rsp], 2

; 238  :     } else {

	jmp	SHORT $LN15@watc_pchec
$LN14@watc_pchec:

; 239  :         newflg = 1;

	mov	DWORD PTR newflg$[rsp], 1

; 240  :         shift = 1;

	mov	DWORD PTR shift$[rsp], 1
$LN15@watc_pchec:
$LN13@watc_pchec:

; 241  :     }
; 242  : 
; 243  :     /* scan if there's a free register (pair/quadrupel) */
; 244  :     for ( firstreg = 0; firstreg < 4 && (newflg & *used ); newflg <<= shift, firstreg += shift );

	mov	DWORD PTR firstreg$[rsp], 0
	jmp	SHORT $LN4@watc_pchec
$LN2@watc_pchec:
	mov	eax, DWORD PTR shift$[rsp]
	movzx	ecx, al
	mov	eax, DWORD PTR newflg$[rsp]
	shl	eax, cl
	mov	DWORD PTR newflg$[rsp], eax
	mov	eax, DWORD PTR shift$[rsp]
	mov	ecx, DWORD PTR firstreg$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR firstreg$[rsp], eax
$LN4@watc_pchec:
	cmp	DWORD PTR firstreg$[rsp], 4
	jge	SHORT $LN3@watc_pchec
	mov	rax, QWORD PTR used$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	ecx, DWORD PTR newflg$[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	SHORT $LN3@watc_pchec
	jmp	SHORT $LN2@watc_pchec
$LN3@watc_pchec:

; 245  :     if ( firstreg >= 4 ) /* exit if nothing is free */

	cmp	DWORD PTR firstreg$[rsp], 4
	jl	SHORT $LN16@watc_pchec

; 246  :         return( 0 );

	xor	eax, eax
	jmp	$LN1@watc_pchec
$LN16@watc_pchec:

; 247  : 
; 248  :     paranode->sym.state = SYM_TMACRO;

	mov	rax, QWORD PTR paranode$[rsp]
	mov	DWORD PTR [rax+32], 10

; 249  :     switch ( size ) {

	mov	eax, DWORD PTR size$[rsp]
	mov	DWORD PTR tv134[rsp], eax
	cmp	DWORD PTR tv134[rsp], 1
	je	SHORT $LN17@watc_pchec
	cmp	DWORD PTR tv134[rsp], 2
	je	SHORT $LN18@watc_pchec
	cmp	DWORD PTR tv134[rsp], 4
	je	SHORT $LN19@watc_pchec
	cmp	DWORD PTR tv134[rsp], 8
	je	$LN22@watc_pchec
	jmp	$LN5@watc_pchec
$LN17@watc_pchec:

; 250  :     case 1:
; 251  :         paranode->sym.regist[0] = watc_regs8[firstreg];

	movsxd	rax, DWORD PTR firstreg$[rsp]
	lea	rcx, OFFSET FLAT:watc_regs8
	mov	edx, 2
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR paranode$[rsp]
	movzx	eax, WORD PTR [rcx+rax*4]
	mov	WORD PTR [r8+rdx+48], ax

; 252  :         break;

	jmp	$LN5@watc_pchec
$LN18@watc_pchec:

; 253  :     case 2:
; 254  :         paranode->sym.regist[0] = watc_regs16[firstreg];

	movsxd	rax, DWORD PTR firstreg$[rsp]
	lea	rcx, OFFSET FLAT:watc_regs16
	mov	edx, 2
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR paranode$[rsp]
	movzx	eax, WORD PTR [rcx+rax*4]
	mov	WORD PTR [r8+rdx+48], ax

; 255  :         break;

	jmp	$LN5@watc_pchec
$LN19@watc_pchec:

; 256  :     case 4:
; 257  :         if ( Ofssize ) {

	movzx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	je	SHORT $LN20@watc_pchec

; 258  :             paranode->sym.regist[0] = watc_regs32[firstreg];

	movsxd	rax, DWORD PTR firstreg$[rsp]
	lea	rcx, OFFSET FLAT:watc_regs32
	mov	edx, 2
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR paranode$[rsp]
	movzx	eax, WORD PTR [rcx+rax*4]
	mov	WORD PTR [r8+rdx+48], ax

; 259  :         } else {

	jmp	SHORT $LN21@watc_pchec
$LN20@watc_pchec:

; 260  :             paranode->sym.regist[0] = watc_regs16[firstreg];

	movsxd	rax, DWORD PTR firstreg$[rsp]
	lea	rcx, OFFSET FLAT:watc_regs16
	mov	edx, 2
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR paranode$[rsp]
	movzx	eax, WORD PTR [rcx+rax*4]
	mov	WORD PTR [r8+rdx+48], ax

; 261  :             paranode->sym.regist[1] = watc_regs16[firstreg+1];

	mov	eax, DWORD PTR firstreg$[rsp]
	inc	eax
	cdqe
	lea	rcx, OFFSET FLAT:watc_regs16
	mov	edx, 2
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR paranode$[rsp]
	movzx	eax, WORD PTR [rcx+rax*4]
	mov	WORD PTR [r8+rdx+48], ax
$LN21@watc_pchec:

; 262  :         }
; 263  :         break;

	jmp	$LN5@watc_pchec
$LN22@watc_pchec:

; 264  :     case 8:
; 265  :         if ( Ofssize ) {

	movzx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	je	SHORT $LN23@watc_pchec

; 266  :             paranode->sym.regist[0] = watc_regs32[firstreg];

	movsxd	rax, DWORD PTR firstreg$[rsp]
	lea	rcx, OFFSET FLAT:watc_regs32
	mov	edx, 2
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR paranode$[rsp]
	movzx	eax, WORD PTR [rcx+rax*4]
	mov	WORD PTR [r8+rdx+48], ax

; 267  :             paranode->sym.regist[1] = watc_regs32[firstreg+1];

	mov	eax, DWORD PTR firstreg$[rsp]
	inc	eax
	cdqe
	lea	rcx, OFFSET FLAT:watc_regs32
	mov	edx, 2
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR paranode$[rsp]
	movzx	eax, WORD PTR [rcx+rax*4]
	mov	WORD PTR [r8+rdx+48], ax

; 268  :         } else {

	jmp	$LN24@watc_pchec
$LN23@watc_pchec:

; 269  :             /* the AX:BX:CX:DX sequence is for 16-bit only.
; 270  :              * fixme: no support for codeview debug info yet;
; 271  :              * the S_REGISTER record supports max 2 registers only.
; 272  :              */
; 273  :             for( firstreg = 0, regname[0] = NULLC; firstreg < 4; firstreg++ ) {

	mov	DWORD PTR firstreg$[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 64			; 00000040H
	jae	SHORT $LN34@watc_pchec
	jmp	SHORT $LN35@watc_pchec
$LN34@watc_pchec:
	call	__report_rangecheckfailure
$LN35@watc_pchec:
	lea	rax, OFFSET FLAT:?regname@?1??watc_pcheck@@9@9
	mov	rcx, QWORD PTR $T1[rsp]
	mov	BYTE PTR [rax+rcx], 0
	jmp	SHORT $LN9@watc_pchec
$LN7@watc_pchec:
	mov	eax, DWORD PTR firstreg$[rsp]
	inc	eax
	mov	DWORD PTR firstreg$[rsp], eax
$LN9@watc_pchec:
	cmp	DWORD PTR firstreg$[rsp], 4
	jge	SHORT $LN8@watc_pchec

; 274  :                 GetResWName( watc_regs_qw[firstreg], regname + strlen( regname ) );

	lea	rcx, OFFSET FLAT:?regname@?1??watc_pcheck@@9@9
	call	strlen
	lea	rcx, OFFSET FLAT:?regname@?1??watc_pcheck@@9@9
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR firstreg$[rsp]
	lea	rdx, OFFSET FLAT:watc_regs_qw
	mov	QWORD PTR tv271[rsp], rdx
	mov	rdx, rax
	mov	rax, QWORD PTR tv271[rsp]
	mov	ecx, DWORD PTR [rax+rcx*4]
	call	GetResWName

; 275  :                 if ( firstreg != 3 )

	cmp	DWORD PTR firstreg$[rsp], 3
	je	SHORT $LN25@watc_pchec

; 276  :                     strcat( regname, "::");

	lea	rdx, OFFSET FLAT:$SG11425
	lea	rcx, OFFSET FLAT:?regname@?1??watc_pcheck@@9@9
	call	strcat
$LN25@watc_pchec:

; 277  :             }

	jmp	SHORT $LN7@watc_pchec
$LN8@watc_pchec:
$LN24@watc_pchec:
$LN5@watc_pchec:

; 278  :         }
; 279  :     }
; 280  :     if ( paranode->sym.regist[1] ) {

	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR paranode$[rsp]
	movzx	eax, WORD PTR [rcx+rax+48]
	test	eax, eax
	je	SHORT $LN26@watc_pchec

; 281  :         sprintf( regname, "%s::%s",

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR paranode$[rsp]
	movzx	eax, WORD PTR [rcx+rax+48]
	xor	edx, edx
	mov	ecx, eax
	call	GetResWName
	mov	QWORD PTR tv209[rsp], rax
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR paranode$[rsp]
	movzx	ecx, WORD PTR [rdx+rcx+48]
	lea	rdx, OFFSET FLAT:?regist@?1??watc_pcheck@@9@9
	call	GetResWName
	mov	rcx, QWORD PTR tv209[rsp]
	mov	r9, rcx
	mov	r8, rax
	lea	rdx, OFFSET FLAT:$SG11428
	lea	rcx, OFFSET FLAT:?regname@?1??watc_pcheck@@9@9
	call	sprintf
	jmp	SHORT $LN27@watc_pchec
$LN26@watc_pchec:

; 282  :                 GetResWName( paranode->sym.regist[1], regist ),
; 283  :                 GetResWName( paranode->sym.regist[0], NULL ) );
; 284  :     } else if ( paranode->sym.regist[0] ) {

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR paranode$[rsp]
	movzx	eax, WORD PTR [rcx+rax+48]
	test	eax, eax
	je	SHORT $LN28@watc_pchec

; 285  :         GetResWName( paranode->sym.regist[0], regname );

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR paranode$[rsp]
	movzx	eax, WORD PTR [rcx+rax+48]
	lea	rdx, OFFSET FLAT:?regname@?1??watc_pcheck@@9@9
	mov	ecx, eax
	call	GetResWName
$LN28@watc_pchec:
$LN27@watc_pchec:

; 286  :     }
; 287  :     *used |= newflg;

	mov	rax, QWORD PTR used$[rsp]
	mov	ecx, DWORD PTR newflg$[rsp]
	mov	eax, DWORD PTR [rax]
	or	eax, ecx
	mov	rcx, QWORD PTR used$[rsp]
	mov	DWORD PTR [rcx], eax

; 288  :     paranode->sym.string_ptr = LclAlloc( strlen( regname ) + 1 );

	lea	rcx, OFFSET FLAT:?regname@?1??watc_pcheck@@9@9
	call	strlen
	inc	rax
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR paranode$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 289  :     strcpy( paranode->sym.string_ptr, regname );

	lea	rdx, OFFSET FLAT:?regname@?1??watc_pcheck@@9@9
	mov	rax, QWORD PTR paranode$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	strcpy

; 290  :     DebugMsg(("watc_pcheck(%s.%s): size=%u ptr=%u far=%u reg=%s\n", proc->sym.name, paranode->sym.name, size, paranode->sym.is_ptr, paranode->sym.isfar, regname ));

	mov	rax, QWORD PTR paranode$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	mov	rcx, QWORD PTR paranode$[rsp]
	movzx	ecx, BYTE PTR [rcx+45]
	lea	rdx, OFFSET FLAT:?regname@?1??watc_pcheck@@9@9
	mov	QWORD PTR [rsp+48], rdx
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR size$[rsp]
	mov	rax, QWORD PTR paranode$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11430
	call	DoDebugMsg

; 291  :     return( 1 );

	mov	eax, 1
$LN1@watc_pchec:
$LN29@watc_pchec:

; 292  : }

	add	rsp, 136				; 00000088H
	ret	0
watc_pcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
tv75 = 32
tv84 = 36
proc$ = 64
buffer$ = 72
ms32_return PROC

; 334  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 335  :     /* v2.07: changed */
; 336  :     //if( proc->e.procinfo->parasize > ( 2 * CurrWordSize ) )
; 337  :     //    sprintf( buffer + strlen( buffer ), "%d%c", proc->e.procinfo->parasize - (2 * CurrWordSize), ModuleInfo.radix != 10 ? 't' : NULLC );
; 338  :     if( proc->e.procinfo->parasize > ( ms32_maxreg[ModuleInfo.Ofssize] * CurrWordSize ) )

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	ecx, BYTE PTR ModuleInfo+404
	lea	rdx, OFFSET FLAT:ms32_maxreg
	movzx	r8d, BYTE PTR ModuleInfo+406
	mov	ecx, DWORD PTR [rdx+rcx*4]
	imul	ecx, r8d
	cmp	DWORD PTR [rax+32], ecx
	jbe	SHORT $LN2@ms32_retur

; 339  :         sprintf( buffer + strlen( buffer ), "%d%c", proc->e.procinfo->parasize - ( ms32_maxreg[ModuleInfo.Ofssize] * CurrWordSize), ModuleInfo.radix != 10 ? 't' : NULLC );

	movzx	eax, BYTE PTR ModuleInfo+396
	cmp	eax, 10
	je	SHORT $LN4@ms32_retur
	mov	DWORD PTR tv75[rsp], 116		; 00000074H
	jmp	SHORT $LN5@ms32_retur
$LN4@ms32_retur:
	mov	DWORD PTR tv75[rsp], 0
$LN5@ms32_retur:
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	ecx, BYTE PTR ModuleInfo+404
	lea	rdx, OFFSET FLAT:ms32_maxreg
	movzx	r8d, BYTE PTR ModuleInfo+406
	mov	ecx, DWORD PTR [rdx+rcx*4]
	imul	ecx, r8d
	mov	eax, DWORD PTR [rax+32]
	sub	eax, ecx
	mov	DWORD PTR tv84[rsp], eax
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strlen
	mov	rcx, QWORD PTR buffer$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r9d, DWORD PTR tv75[rsp]
	mov	ecx, DWORD PTR tv84[rsp]
	mov	r8d, ecx
	lea	rdx, OFFSET FLAT:$SG11456
	mov	rcx, rax
	call	sprintf
$LN2@ms32_retur:

; 340  :     return;
; 341  : }

	add	rsp, 56					; 00000038H
	ret	0
ms32_return ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
tv90 = 32
tv134 = 36
size$ = 40
regname$ = 48
__$ArrayPad$ = 80
proc$ = 112
paranode$ = 120
used$ = 128
ms32_pcheck PROC

; 314  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 315  :     char regname[32];
; 316  :     int size = SizeFromMemtype( paranode->sym.mem_type, paranode->sym.Ofssize, paranode->sym.type );

	mov	rax, QWORD PTR paranode$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	rcx, QWORD PTR paranode$[rsp]
	mov	r8, QWORD PTR [rcx+80]
	mov	edx, eax
	mov	rax, QWORD PTR paranode$[rsp]
	mov	ecx, DWORD PTR [rax+36]
	call	SizeFromMemtype
	mov	DWORD PTR size$[rsp], eax

; 317  : 
; 318  :     /* v2.07: 16-bit has 3 register params (AX,DX,BX) */
; 319  :     //if ( size > CurrWordSize || *used >= 2 )
; 320  :     if ( size > CurrWordSize || *used >= ms32_maxreg[ModuleInfo.Ofssize] )

	movzx	eax, BYTE PTR ModuleInfo+406
	cmp	DWORD PTR size$[rsp], eax
	jg	SHORT $LN3@ms32_pchec
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:ms32_maxreg
	mov	rdx, QWORD PTR used$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4]
	cmp	DWORD PTR [rdx], eax
	jl	SHORT $LN2@ms32_pchec
$LN3@ms32_pchec:

; 321  :         return( 0 );

	xor	eax, eax
	jmp	$LN1@ms32_pchec
$LN2@ms32_pchec:

; 322  :     paranode->sym.state = SYM_TMACRO;

	mov	rax, QWORD PTR paranode$[rsp]
	mov	DWORD PTR [rax+32], 10

; 323  :     /* v2.10: for codeview debug info, store the register index in the symbol */
; 324  :     paranode->sym.regist[0] = ModuleInfo.Ofssize ? ms32_regs32[*used] : ms32_regs16[*used];

	movzx	eax, BYTE PTR ModuleInfo+404
	test	eax, eax
	je	SHORT $LN5@ms32_pchec
	mov	rax, QWORD PTR used$[rsp]
	movsxd	rax, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:ms32_regs32
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR tv90[rsp], eax
	jmp	SHORT $LN6@ms32_pchec
$LN5@ms32_pchec:
	mov	rax, QWORD PTR used$[rsp]
	movsxd	rax, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:ms32_regs16
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR tv90[rsp], eax
$LN6@ms32_pchec:
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR paranode$[rsp]
	movzx	edx, WORD PTR tv90[rsp]
	mov	WORD PTR [rcx+rax+48], dx

; 325  :     GetResWName( ModuleInfo.Ofssize ? ms32_regs32[*used] : ms32_regs16[*used], regname );

	movzx	eax, BYTE PTR ModuleInfo+404
	test	eax, eax
	je	SHORT $LN7@ms32_pchec
	mov	rax, QWORD PTR used$[rsp]
	movsxd	rax, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:ms32_regs32
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR tv134[rsp], eax
	jmp	SHORT $LN8@ms32_pchec
$LN7@ms32_pchec:
	mov	rax, QWORD PTR used$[rsp]
	movsxd	rax, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:ms32_regs16
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR tv134[rsp], eax
$LN8@ms32_pchec:
	lea	rdx, QWORD PTR regname$[rsp]
	mov	ecx, DWORD PTR tv134[rsp]
	call	GetResWName

; 326  :     paranode->sym.string_ptr = LclAlloc( strlen( regname ) + 1 );

	lea	rcx, QWORD PTR regname$[rsp]
	call	strlen
	inc	rax
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR paranode$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 327  :     strcpy( paranode->sym.string_ptr, regname );

	lea	rdx, QWORD PTR regname$[rsp]
	mov	rax, QWORD PTR paranode$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	strcpy

; 328  :     (*used)++;

	mov	rax, QWORD PTR used$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR used$[rsp]
	mov	DWORD PTR [rcx], eax

; 329  :     return( 1 );

	mov	eax, 1
$LN1@ms32_pchec:

; 330  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
ms32_pcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
ProcCheckOpen PROC

; 2184 : {

$LN5:
	sub	rsp, 40					; 00000028H
$LN2@ProcCheckO:

; 2185 :     while( CurrProc != NULL ) {

	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN3@ProcCheckO

; 2186 :         DebugMsg1(("ProcCheckOpen: unmatched block nesting error, CurrProc=%s\n", CurrProc->sym.name ));

	mov	rax, QWORD PTR CurrProc
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12194
	call	DoDebugMsg1

; 2187 :         EmitErr( UNMATCHED_BLOCK_NESTING, CurrProc->sym.name );

	mov	rax, QWORD PTR CurrProc
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 142				; 0000008eH
	call	EmitErr

; 2188 :         ProcFini( CurrProc );

	mov	rcx, QWORD PTR CurrProc
	call	ProcFini

; 2189 :     }

	jmp	SHORT $LN2@ProcCheckO
$LN3@ProcCheckO:

; 2190 : }

	add	rsp, 40					; 00000028H
	ret	0
ProcCheckOpen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
tv66 = 0
ProcInit PROC

; 3744 : {

$LN5:
	sub	rsp, 24

; 3745 :     ProcStack = NULL;

	mov	QWORD PTR ProcStack, 0

; 3746 :     CurrProc  = NULL;

	mov	QWORD PTR CurrProc, 0

; 3747 :     procidx = 1;

	mov	DWORD PTR procidx, 1

; 3748 :     ProcStatus = 0;

	mov	DWORD PTR ProcStatus, 0

; 3749 :     /* v2.09: reset prolog and epilog mode */
; 3750 :     ModuleInfo.prologuemode = PEM_DEFAULT;

	mov	BYTE PTR ModuleInfo+424, 0

; 3751 :     ModuleInfo.epiloguemode = PEM_DEFAULT;

	mov	BYTE PTR ModuleInfo+425, 0

; 3752 :     /* v2.06: no forward references in INVOKE if -Zne is set */
; 3753 :     ModuleInfo.invoke_exprparm = ( Options.strict_masm_compat ? EXPF_NOUNDEF : 0 );

	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	je	SHORT $LN3@ProcInit
	mov	DWORD PTR tv66[rsp], 2
	jmp	SHORT $LN4@ProcInit
$LN3@ProcInit:
	mov	DWORD PTR tv66[rsp], 0
$LN4@ProcInit:
	movzx	eax, BYTE PTR tv66[rsp]
	mov	BYTE PTR ModuleInfo+426, al

; 3754 : #if STACKBASESUPP
; 3755 :     ModuleInfo.basereg[USE16] = T_BP;

	mov	eax, 4
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+500
	mov	DWORD PTR [rcx+rax], 14

; 3756 :     ModuleInfo.basereg[USE32] = T_EBP;

	mov	eax, 4
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+500
	mov	DWORD PTR [rcx+rax], 22

; 3757 : #if AMD64_SUPPORT
; 3758 :     ModuleInfo.basereg[USE64] = T_RBP;

	mov	eax, 4
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+500
	mov	DWORD PTR [rcx+rax], 120		; 00000078H

; 3759 : #endif
; 3760 : #endif
; 3761 : #if AMD64_SUPPORT
; 3762 :     unw_segs_defined = 0;

	mov	BYTE PTR unw_segs_defined, 0

; 3763 : #endif
; 3764 : }

	add	rsp, 24
	ret	0
ProcInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
tv74 = 32
tokenarray$ = 64
write_prologue PROC

; 3226 : {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3227 :     /* reset @ProcStatus flag */
; 3228 :     ProcStatus &= ~PRST_PROLOGUE_NOT_DONE;

	mov	eax, DWORD PTR ProcStatus
	btr	eax, 7
	mov	DWORD PTR ProcStatus, eax

; 3229 : 
; 3230 : #if AMD64_SUPPORT
; 3231 :     if ( ModuleInfo.fctype == FCT_WIN64 && ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) ) {

	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN2@write_prol
	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 2
	test	eax, eax
	je	SHORT $LN2@write_prol

; 3232 :         /* in pass one init reserved stack with 4*8 to force stack frame creation */
; 3233 :         sym_ReservedStack->value = ( Parse_Pass == PASS_1 ? 4 * sizeof( uint_64 ) : CurrProc->e.procinfo->ReservedStack );

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN10@write_prol
	mov	QWORD PTR tv74[rsp], 32			; 00000020H
	jmp	SHORT $LN11@write_prol
$LN10@write_prol:
	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	movsxd	rax, DWORD PTR [rax+96]
	mov	QWORD PTR tv74[rsp], rax
$LN11@write_prol:
	mov	rax, QWORD PTR sym_ReservedStack
	mov	ecx, DWORD PTR tv74[rsp]
	mov	DWORD PTR [rax+16], ecx

; 3234 :         if (Parse_Pass == PASS_1) sym_ReservedStack->hasinvoke = 0;

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN3@write_prol
	mov	rax, QWORD PTR sym_ReservedStack
	mov	DWORD PTR [rax+16], 0
$LN3@write_prol:
$LN2@write_prol:

; 3235 :     }
; 3236 : #endif
; 3237 :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN4@write_prol

; 3238 :         /* v2.12: calculation of offsets of local variables is done delayed now */
; 3239 :         SetLocalOffsets( CurrProc->e.procinfo );

	mov	rax, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rax+96]
	call	SetLocalOffsets
$LN4@write_prol:

; 3240 :     }
; 3241 :     ProcStatus |= PRST_INSIDE_PROLOGUE;

	mov	eax, DWORD PTR ProcStatus
	or	eax, 1
	mov	DWORD PTR ProcStatus, eax

; 3242 :     /* there are 3 cases:
; 3243 :      * option prologue:NONE           proc_prologue == NULL
; 3244 :      * option prologue:default        *proc_prologue == NULLC
; 3245 :      * option prologue:usermacro      *proc_prologue != NULLC
; 3246 :      */
; 3247 :     if ( ModuleInfo.prologuemode == PEM_DEFAULT ) {

	movzx	eax, BYTE PTR ModuleInfo+424
	test	eax, eax
	jne	SHORT $LN5@write_prol

; 3248 :         DebugMsg1(("write_prologue(%s): default prologue\n", CurrProc->sym.name ));

	mov	rax, QWORD PTR CurrProc
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12687
	call	DoDebugMsg1

; 3249 :         write_default_prologue();

	call	write_default_prologue
	jmp	SHORT $LN6@write_prol
$LN5@write_prol:

; 3250 :     } else if ( ModuleInfo.prologuemode == PEM_NONE ) {

	movzx	eax, BYTE PTR ModuleInfo+424
	cmp	eax, 2
	jne	SHORT $LN7@write_prol

; 3251 :         DebugMsg1(("write_prologue(%s): prologue is NULL\n", CurrProc->sym.name  ));

	mov	rax, QWORD PTR CurrProc
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12690
	call	DoDebugMsg1

; 3252 :     } else {

	jmp	SHORT $LN8@write_prol
$LN7@write_prol:

; 3253 :         DebugMsg1(("write_prologue(%s): userdefined prologue %s\n", CurrProc->sym.name , ModuleInfo.proc_prologue ));

	mov	r8, QWORD PTR ModuleInfo+320
	mov	rax, QWORD PTR CurrProc
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12691
	call	DoDebugMsg1

; 3254 :         write_userdef_prologue( tokenarray );

	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	write_userdef_prologue
$LN8@write_prol:
$LN6@write_prol:

; 3255 :     }
; 3256 :     ProcStatus &= ~PRST_INSIDE_PROLOGUE;

	mov	eax, DWORD PTR ProcStatus
	and	eax, -2
	mov	DWORD PTR ProcStatus, eax

; 3257 :     /* v2.10: for debug info, calculate prologue size */
; 3258 :     CurrProc->e.procinfo->size_prolog = GetCurrOffset() - CurrProc->sym.offset;

	call	GetCurrOffset
	mov	rcx, QWORD PTR CurrProc
	sub	eax, DWORD PTR [rcx+16]
	mov	rcx, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+129], al

; 3259 :     return;
; 3260 : }

	add	rsp, 56					; 00000038H
	ret	0
write_prologue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
is_iret$ = 32
p$ = 40
tv161 = 48
info$ = 56
tv167 = 64
tv187 = 68
rc$ = 72
tv204 = 80
buffer$ = 96
__$ArrayPad$ = 1120
i$ = 1152
tokenarray$ = 1160
count$ = 1168
RetInstr PROC

; 3644 : {

$LN28:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 1144				; 00000478H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3645 :     struct proc_info   *info;
; 3646 :     bool        is_iret = FALSE;

	mov	BYTE PTR is_iret$[rsp], 0

; 3647 :     char        *p;
; 3648 : #ifdef DEBUG_OUT
; 3649 :     ret_code    rc;
; 3650 : #endif
; 3651 :     char        buffer[MAX_LINE_LEN]; /* stores modified RETN/RETF/IRET instruction */
; 3652 : 
; 3653 :     DebugMsg1(( "RetInstr() enter\n" ));

	lea	rcx, OFFSET FLAT:$SG12848
	call	DoDebugMsg1

; 3654 : 
; 3655 : #if AMD64_SUPPORT
; 3656 :     if( tokenarray[i].tokval == T_IRET || tokenarray[i].tokval == T_IRETD || tokenarray[i].tokval == T_IRETQ )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 627		; 00000273H
	je	SHORT $LN5@RetInstr
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 628		; 00000274H
	je	SHORT $LN5@RetInstr
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 1208		; 000004b8H
	jne	SHORT $LN4@RetInstr
$LN5@RetInstr:

; 3657 : #else
; 3658 :     if( tokenarray[i].tokval == T_IRET || tokenarray[i].tokval == T_IRETD )
; 3659 : #endif
; 3660 :         is_iret = TRUE;

	mov	BYTE PTR is_iret$[rsp], 1
$LN4@RetInstr:

; 3661 : 
; 3662 :     if ( ModuleInfo.epiloguemode == PEM_MACRO ) {

	movzx	eax, BYTE PTR ModuleInfo+425
	cmp	eax, 1
	jne	SHORT $LN6@RetInstr

; 3663 : #if FASTPASS
; 3664 :         /* don't run userdefined epilogue macro if pass > 1 */
; 3665 :         if ( UseSavedState ) {

	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	je	SHORT $LN7@RetInstr

; 3666 :             if ( Parse_Pass > PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN8@RetInstr

; 3667 :                 DebugMsg(( "RetInstr() exit\n" ));

	lea	rcx, OFFSET FLAT:$SG12854
	call	DoDebugMsg

; 3668 :                 //return( NOT_ERROR );
; 3669 :                 return( ParseLine( tokenarray ) );

	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	ParseLine
	jmp	$LN1@RetInstr
$LN8@RetInstr:

; 3670 :             }
; 3671 :             /* handle the current line as if it is REPLACED by the macro content */
; 3672 :             *(LineStoreCurr->line) = ';';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR LineStoreCurr
	mov	BYTE PTR [rcx+rax+16], 59		; 0000003bH
$LN7@RetInstr:

; 3673 :         }
; 3674 : #endif
; 3675 : #ifdef DEBUG_OUT
; 3676 :         rc = write_userdef_epilogue( is_iret, tokenarray );

	mov	rdx, QWORD PTR tokenarray$[rsp]
	movzx	ecx, BYTE PTR is_iret$[rsp]
	call	write_userdef_epilogue
	mov	DWORD PTR rc$[rsp], eax

; 3677 :         DebugMsg(( "RetInstr() exit\n" ));

	lea	rcx, OFFSET FLAT:$SG12855
	call	DoDebugMsg

; 3678 :         return( rc );

	mov	eax, DWORD PTR rc$[rsp]
	jmp	$LN1@RetInstr
$LN6@RetInstr:

; 3679 : #else
; 3680 :         return( write_userdef_epilogue( is_iret, tokenarray ) );
; 3681 : #endif
; 3682 :     }
; 3683 : 
; 3684 :     if ( ModuleInfo.list ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN9@RetInstr

; 3685 :         LstWrite( LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL );

	call	GetCurrOffset
	xor	r8d, r8d
	mov	edx, eax
	mov	ecx, 4
	call	LstWrite
$LN9@RetInstr:

; 3686 :     }
; 3687 : 
; 3688 :     strcpy( buffer, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	strcpy

; 3689 :     p = buffer + strlen( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	strlen
	lea	rax, QWORD PTR buffer$[rsp+rax]
	mov	QWORD PTR p$[rsp], rax

; 3690 : 
; 3691 :     write_default_epilogue();

	call	write_default_epilogue

; 3692 : 
; 3693 :     info = CurrProc->e.procinfo;

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR info$[rsp], rax

; 3694 : 
; 3695 :     /* skip this part for IRET */
; 3696 :     if( is_iret == FALSE ) {

	movzx	eax, BYTE PTR is_iret$[rsp]
	test	eax, eax
	jne	SHORT $LN10@RetInstr

; 3697 :         if ( CurrProc->sym.mem_type == MT_FAR )

	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN11@RetInstr

; 3698 :             *p++ = 'f';   /* ret -> retf */

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 102			; 00000066H
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN12@RetInstr
$LN11@RetInstr:

; 3699 :         else
; 3700 :             *p++ = 'n';     /* ret -> retn */

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 110			; 0000006eH
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN12@RetInstr:
$LN10@RetInstr:

; 3701 :     }
; 3702 :     i++; /* skip directive */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 3703 :     if ( info->parasize || ( count != i ) )

	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN14@RetInstr
	mov	eax, DWORD PTR i$[rsp]
	cmp	DWORD PTR count$[rsp], eax
	je	SHORT $LN13@RetInstr
$LN14@RetInstr:

; 3704 :         *p++ = ' ';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN13@RetInstr:

; 3705 :     *p = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 0

; 3706 :     /* RET without argument? Then calculate the value */
; 3707 :     if( is_iret == FALSE && count == i ) {

	movzx	eax, BYTE PTR is_iret$[rsp]
	test	eax, eax
	jne	$LN15@RetInstr
	mov	eax, DWORD PTR i$[rsp]
	cmp	DWORD PTR count$[rsp], eax
	jne	$LN15@RetInstr

; 3708 :         if ( ModuleInfo.epiloguemode != PEM_NONE ) {

	movzx	eax, BYTE PTR ModuleInfo+425
	cmp	eax, 2
	je	$LN17@RetInstr

; 3709 :             switch( CurrProc->sym.langtype ) {

	mov	rax, QWORD PTR CurrProc
	mov	eax, DWORD PTR [rax+76]
	mov	DWORD PTR tv161[rsp], eax
	cmp	DWORD PTR tv161[rsp], 3
	je	$LN21@RetInstr
	cmp	DWORD PTR tv161[rsp], 3
	jle	$LN2@RetInstr
	cmp	DWORD PTR tv161[rsp], 6
	jle	SHORT $LN18@RetInstr
	cmp	DWORD PTR tv161[rsp], 7
	je	SHORT $LN20@RetInstr
	jmp	$LN2@RetInstr
$LN18@RetInstr:

; 3710 :             case LANG_BASIC:
; 3711 :             case LANG_FORTRAN:
; 3712 :             case LANG_PASCAL:
; 3713 :                 if( info->parasize != 0 ) {

	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN19@RetInstr

; 3714 :                     sprintf( p, "%d%c", info->parasize, ModuleInfo.radix != 10 ? 't' : NULLC );

	movzx	eax, BYTE PTR ModuleInfo+396
	cmp	eax, 10
	je	SHORT $LN24@RetInstr
	mov	DWORD PTR tv167[rsp], 116		; 00000074H
	jmp	SHORT $LN25@RetInstr
$LN24@RetInstr:
	mov	DWORD PTR tv167[rsp], 0
$LN25@RetInstr:
	mov	r9d, DWORD PTR tv167[rsp]
	mov	rax, QWORD PTR info$[rsp]
	mov	r8d, DWORD PTR [rax+32]
	lea	rdx, OFFSET FLAT:$SG12867
	mov	rcx, QWORD PTR p$[rsp]
	call	sprintf
$LN19@RetInstr:

; 3715 :                 }
; 3716 :                 break;

	jmp	$LN2@RetInstr
$LN20@RetInstr:

; 3717 :             case LANG_FASTCALL:
; 3718 :                 fastcall_tab[ModuleInfo.fctype].handlereturn( CurrProc, buffer );

	movsxd	rax, DWORD PTR ModuleInfo+376
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:fastcall_tab
	mov	QWORD PTR tv204[rsp], rcx
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR CurrProc
	mov	r8, QWORD PTR tv204[rsp]
	call	QWORD PTR [r8+rax+8]

; 3719 :                 break;

	jmp	SHORT $LN2@RetInstr
$LN21@RetInstr:

; 3720 :             case LANG_STDCALL:
; 3721 :                 if( !info->has_vararg && info->parasize != 0 ) {

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN22@RetInstr
	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN22@RetInstr

; 3722 :                     sprintf( p, "%d%c", info->parasize, ModuleInfo.radix != 10 ? 't' : NULLC  );

	movzx	eax, BYTE PTR ModuleInfo+396
	cmp	eax, 10
	je	SHORT $LN26@RetInstr
	mov	DWORD PTR tv187[rsp], 116		; 00000074H
	jmp	SHORT $LN27@RetInstr
$LN26@RetInstr:
	mov	DWORD PTR tv187[rsp], 0
$LN27@RetInstr:
	mov	r9d, DWORD PTR tv187[rsp]
	mov	rax, QWORD PTR info$[rsp]
	mov	r8d, DWORD PTR [rax+32]
	lea	rdx, OFFSET FLAT:$SG12871
	mov	rcx, QWORD PTR p$[rsp]
	call	sprintf
$LN22@RetInstr:
$LN2@RetInstr:
$LN17@RetInstr:

; 3723 :                 }
; 3724 :                 break;
; 3725 :             }
; 3726 :         }
; 3727 :     } else {

	jmp	SHORT $LN16@RetInstr
$LN15@RetInstr:

; 3728 :         /* v2.04: changed. Now works for both RET nn and IRETx */
; 3729 :         /* v2.06: changed. Now works even if RET has ben "renamed" */
; 3730 :         strcpy( p, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	rcx, QWORD PTR p$[rsp]
	call	strcpy
$LN16@RetInstr:

; 3731 :     }
; 3732 :     AddLineQueue( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	AddLineQueue

; 3733 :     RunLineQueue();

	call	RunLineQueue

; 3734 : 
; 3735 :     DebugMsg1(( "RetInstr() exit\n" ));

	lea	rcx, OFFSET FLAT:$SG12872
	call	DoDebugMsg1

; 3736 : 
; 3737 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@RetInstr:

; 3738 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1144				; 00000478H
	ret	0
RetInstr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
curr$ = 32
oldl$ = 40
newl$ = 48
proc$ = 80
src$ = 88
CopyPrototype PROC

; 1653 : {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1654 :     struct dsym *curr;
; 1655 :     struct dsym *newl;
; 1656 :     struct dsym *oldl;
; 1657 : 
; 1658 :     if ( src->sym.isproc == FALSE )

	mov	rax, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@CopyProtot

; 1659 :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@CopyProtot
$LN8@CopyProtot:

; 1660 :     memcpy(proc->e.procinfo, src->e.procinfo, sizeof( struct proc_info ) );

	mov	r8d, 136				; 00000088H
	mov	rax, QWORD PTR src$[rsp]
	mov	rdx, QWORD PTR [rax+96]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+96]
	call	memcpy

; 1661 :     proc->sym.mem_type = src->sym.mem_type;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	mov	DWORD PTR [rax+36], ecx

; 1662 :     proc->sym.langtype = src->sym.langtype;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	ecx, DWORD PTR [rcx+76]
	mov	DWORD PTR [rax+76], ecx

; 1663 : #if MANGLERSUPP
; 1664 :     proc->sym.mangler  = src->sym.mangler;
; 1665 : #endif
; 1666 :     proc->sym.ispublic   = src->sym.ispublic;

	mov	rax, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	and	al, 1
	shl	al, 7
	mov	rcx, QWORD PTR proc$[rsp]
	movzx	ecx, BYTE PTR [rcx+40]
	and	cl, 127					; 0000007fH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rcx+40], al

; 1667 :     /* we use the PROTO part, not the TYPE part */
; 1668 :     //dir->sym.seg_ofssize = src->sym.Ofssize;
; 1669 :     proc->sym.seg_ofssize = src->sym.seg_ofssize;

	mov	rax, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	and	al, 3
	and	al, 3
	mov	rcx, QWORD PTR proc$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 252					; 000000fcH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rcx+47], al

; 1670 :     proc->sym.isproc = TRUE;

	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	or	al, 8
	mov	rcx, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rcx+41], al

; 1671 :     proc->e.procinfo->paralist = NULL;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rax+8], 0

; 1672 :     for ( curr = src->e.procinfo->paralist; curr; curr = curr->nextparam ) {

	mov	rax, QWORD PTR src$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@CopyProtot
$LN2@CopyProtot:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN4@CopyProtot:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN3@CopyProtot

; 1673 :         newl = LclAlloc( sizeof( struct dsym ) );

	mov	ecx, 120				; 00000078H
	call	LclAlloc
	mov	QWORD PTR newl$[rsp], rax

; 1674 :         memcpy( newl, curr, sizeof( struct dsym ) );

	mov	r8d, 120				; 00000078H
	mov	rdx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR newl$[rsp]
	call	memcpy

; 1675 :         newl->nextparam = NULL;

	mov	rax, QWORD PTR newl$[rsp]
	mov	QWORD PTR [rax+112], 0

; 1676 :         if ( proc->e.procinfo->paralist == NULL)

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+8], 0
	jne	SHORT $LN9@CopyProtot

; 1677 :             proc->e.procinfo->paralist = newl;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR newl$[rsp]
	mov	QWORD PTR [rax+8], rcx
	jmp	SHORT $LN10@CopyProtot
$LN9@CopyProtot:

; 1678 :         else {
; 1679 :             for ( oldl = proc->e.procinfo->paralist; oldl->nextparam; oldl = oldl->nextparam );

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR oldl$[rsp], rax
	jmp	SHORT $LN7@CopyProtot
$LN5@CopyProtot:
	mov	rax, QWORD PTR oldl$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR oldl$[rsp], rax
$LN7@CopyProtot:
	mov	rax, QWORD PTR oldl$[rsp]
	cmp	QWORD PTR [rax+112], 0
	je	SHORT $LN6@CopyProtot
	jmp	SHORT $LN5@CopyProtot
$LN6@CopyProtot:

; 1680 :             oldl->nextparam = newl;

	mov	rax, QWORD PTR oldl$[rsp]
	mov	rcx, QWORD PTR newl$[rsp]
	mov	QWORD PTR [rax+112], rcx
$LN10@CopyProtot:

; 1681 :         }
; 1682 :     }

	jmp	$LN2@CopyProtot
$LN3@CopyProtot:

; 1683 :     DebugMsg1(("CopyPrototype(%s,src=%s): ofssize=%u\n",

	mov	rax, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	and	al, 3
	movzx	eax, al
	mov	r9d, eax
	mov	rax, QWORD PTR src$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12006
	call	DoDebugMsg1

; 1684 :                proc->sym.name, src->sym.name, src->sym.seg_ofssize ));
; 1685 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@CopyProtot:

; 1686 : }

	add	rsp, 72					; 00000048H
	ret	0
CopyPrototype ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
curr$ = 48
next$ = 56
proc$ = 80
DeleteProc PROC

; 1411 : {

$LN14:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1412 :     struct dsym *curr;
; 1413 :     struct dsym *next;
; 1414 : 
; 1415 :     DebugMsg(("DeleteProc(%s) enter\n", proc->sym.name ));

	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11908
	call	DoDebugMsg

; 1416 :     if ( proc->sym.state == SYM_INTERNAL ) {

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	$LN8@DeleteProc

; 1417 : 
; 1418 :         /* delete all local symbols ( params, locals, labels ) */
; 1419 :         for( curr = proc->e.procinfo->labellist; curr; ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR curr$[rsp], rax
$LN2@DeleteProc:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@DeleteProc

; 1420 :             next = curr->e.nextll;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR next$[rsp], rax

; 1421 :             DebugMsg(("DeleteProc(%s): free %s [next=%p]\n", proc->sym.name, curr->sym.name, curr->next ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	r9, QWORD PTR [rax+104]
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11911
	call	DoDebugMsg

; 1422 :             SymFree( &curr->sym );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, rax
	call	SymFree

; 1423 :             curr = next;

	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR curr$[rsp], rax

; 1424 :         }

	jmp	SHORT $LN2@DeleteProc
$LN3@DeleteProc:

; 1425 : 
; 1426 :         if ( proc->e.procinfo->regslist )

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]

; 1427 :             LclFree( proc->e.procinfo->regslist );
; 1428 : 
; 1429 :         if ( proc->e.procinfo->prologuearg )

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]

; 1430 :             LclFree( proc->e.procinfo->prologuearg );
; 1431 : 
; 1432 :         if ( Options.line_numbers && proc->sym.state == SYM_INTERNAL )

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	SHORT $LN12@DeleteProc
	mov	rax, QWORD PTR proc$[rsp]
$LN12@DeleteProc:

; 1433 :             LclFree( proc->sym.debuginfo );
; 1434 : #if FASTMEM==0 || defined(DEBUG_OUT)
; 1435 :     } else {

	jmp	SHORT $LN9@DeleteProc
$LN8@DeleteProc:

; 1436 :         /* PROTOs have just a parameter list, usually without names */
; 1437 :         for( curr = proc->e.procinfo->paralist; curr; ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR curr$[rsp], rax
$LN5@DeleteProc:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN6@DeleteProc

; 1438 :             next = curr->nextparam;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR next$[rsp], rax

; 1439 :             DebugMsg(("DeleteProc(%s): free %p (%s) [next=%p]\n", proc->sym.name, curr, curr->sym.name, curr->next ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR curr$[rsp]
	mov	r9, QWORD PTR [rax+8]
	mov	r8, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11915
	call	DoDebugMsg

; 1440 :             SymFree( &curr->sym );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, rax
	call	SymFree

; 1441 :             curr = next;

	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR curr$[rsp], rax

; 1442 :         }

	jmp	SHORT $LN5@DeleteProc
$LN6@DeleteProc:
$LN9@DeleteProc:

; 1443 : #endif
; 1444 :     }
; 1445 :     LclFree( proc->e.procinfo );
; 1446 :     return;
; 1447 : }

	add	rsp, 72					; 00000048H
	ret	0
DeleteProc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
tv133 = 32
info$1 = 40
tv71 = 48
tv79 = 56
sym$ = 80
name$ = 88
state$ = 96
CreateProc PROC

; 1359 : {

$LN18:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1360 :     if ( sym == NULL )

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN4@CreateProc

; 1361 :         sym = ( *name ? SymCreate( name ) : SymAlloc( name ) );

	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN14@CreateProc
	mov	rcx, QWORD PTR name$[rsp]
	call	SymCreate
	mov	QWORD PTR tv71[rsp], rax
	jmp	SHORT $LN15@CreateProc
$LN14@CreateProc:
	mov	rcx, QWORD PTR name$[rsp]
	call	SymAlloc
	mov	QWORD PTR tv71[rsp], rax
$LN15@CreateProc:
	mov	rax, QWORD PTR tv71[rsp]
	mov	QWORD PTR sym$[rsp], rax
	jmp	SHORT $LN5@CreateProc
$LN4@CreateProc:

; 1362 :     else
; 1363 :         sym_remove_table( ( sym->state == SYM_UNDEFINED ) ? &SymTables[TAB_UNDEF] : &SymTables[TAB_EXT], (struct dsym *)sym );

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN16@CreateProc
	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv79[rsp], rax
	jmp	SHORT $LN17@CreateProc
$LN16@CreateProc:
	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv79[rsp], rax
$LN17@CreateProc:
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR tv79[rsp]
	call	sym_remove_table
$LN5@CreateProc:

; 1364 : 
; 1365 :     if ( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN6@CreateProc

; 1366 :         struct proc_info *info;
; 1367 :         sym->state = state;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR state$[rsp]
	mov	DWORD PTR [rax+32], ecx

; 1368 :         if ( state != SYM_INTERNAL ) {

	cmp	DWORD PTR state$[rsp], 1
	je	SHORT $LN7@CreateProc

; 1369 :             sym->seg_ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	and	al, 3
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 252					; 000000fcH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al
$LN7@CreateProc:

; 1370 :         }
; 1371 :         info = LclAlloc( sizeof( struct proc_info ) );

	mov	ecx, 136				; 00000088H
	call	LclAlloc
	mov	QWORD PTR info$1[rsp], rax

; 1372 :         ((struct dsym *)sym)->e.procinfo = info;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR info$1[rsp]
	mov	QWORD PTR [rax+96], rcx

; 1373 :         info->regslist = NULL;

	mov	rax, QWORD PTR info$1[rsp]
	mov	QWORD PTR [rax], 0

; 1374 :         info->paralist = NULL;

	mov	rax, QWORD PTR info$1[rsp]
	mov	QWORD PTR [rax+8], 0

; 1375 :         info->locallist = NULL;

	mov	rax, QWORD PTR info$1[rsp]
	mov	QWORD PTR [rax+16], 0

; 1376 :         info->labellist = NULL;

	mov	rax, QWORD PTR info$1[rsp]
	mov	QWORD PTR [rax+24], 0

; 1377 :         info->parasize = 0;

	mov	rax, QWORD PTR info$1[rsp]
	mov	DWORD PTR [rax+32], 0

; 1378 :         info->localsize = 0;

	mov	rax, QWORD PTR info$1[rsp]
	mov	DWORD PTR [rax+36], 0

; 1379 :         info->prologuearg = NULL;

	mov	rax, QWORD PTR info$1[rsp]
	mov	QWORD PTR [rax+48], 0

; 1380 :         info->flags = 0;

	mov	rax, QWORD PTR info$1[rsp]
	mov	BYTE PTR [rax+128], 0

; 1381 :         switch ( sym->state ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv133[rsp], eax
	cmp	DWORD PTR tv133[rsp], 1
	je	SHORT $LN8@CreateProc
	cmp	DWORD PTR tv133[rsp], 2
	je	$LN12@CreateProc
	jmp	$LN2@CreateProc
$LN8@CreateProc:

; 1382 :         case SYM_INTERNAL:
; 1383 :             /* v2.04: don't use sym_add_table() and thus
; 1384 :              * free the <next> member field!
; 1385 :              */
; 1386 :             if ( SymTables[TAB_PROC].head == NULL )

	mov	eax, 16
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:SymTables
	cmp	QWORD PTR [rcx+rax], 0
	jne	SHORT $LN9@CreateProc

; 1387 :                 SymTables[TAB_PROC].head = (struct dsym *)sym;

	mov	eax, 16
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+rax], rdx
	jmp	SHORT $LN10@CreateProc
$LN9@CreateProc:

; 1388 :             else {
; 1389 :                 SymTables[TAB_PROC].tail->nextproc = (struct dsym *)sym;

	mov	eax, 16
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+112], rcx
$LN10@CreateProc:

; 1390 :             }
; 1391 :             SymTables[TAB_PROC].tail = (struct dsym *)sym;

	mov	eax, 16
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+rax+8], rdx

; 1392 :             procidx++;

	mov	eax, DWORD PTR procidx
	inc	eax
	mov	DWORD PTR procidx, eax

; 1393 :             if ( Options.line_numbers ) {

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	SHORT $LN11@CreateProc

; 1394 :                 sym->debuginfo = LclAlloc( sizeof( struct debug_info ) );

	mov	ecx, 24
	call	LclAlloc
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+64], rax

; 1395 :                 sym->debuginfo->file = get_curr_srcfile();

	call	get_curr_srcfile
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	mov	WORD PTR [rcx+14], ax
$LN11@CreateProc:

; 1396 :             }
; 1397 :             break;

	jmp	SHORT $LN2@CreateProc
$LN12@CreateProc:

; 1398 :         case SYM_EXTERNAL:
; 1399 :             sym->weak = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	or	al, 8
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 1400 :             sym_add_table( &SymTables[TAB_EXT], (struct dsym *)sym );

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_add_table
$LN2@CreateProc:
$LN6@CreateProc:

; 1401 :             break;
; 1402 :         }
; 1403 :     }
; 1404 :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]

; 1405 : }

	add	rsp, 72					; 00000048H
	ret	0
CreateProc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
_TEXT	SEGMENT
Ofssize$1 = 48
newofssize$ = 49
idx$2 = 52
oldofssize$ = 56
oldpublic$ = 57
cnt$3 = 60
sym$4 = 64
newmemtype$ = 72
j$5 = 76
regist$ = 80
tv141 = 88
tv157 = 92
tv213 = 96
tv219 = 100
tv864 = 104
max$6 = 108
token$ = 112
proc$ = 144
i$ = 152
tokenarray$ = 160
IsPROC$ = 168
langtype$ = 176
ParseProc PROC

; 1030 : {

$LN93:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 1031 :     char            *token;
; 1032 :     uint_16         *regist;
; 1033 :     //int             type;
; 1034 :     //enum lang_type  langtype;
; 1035 :     enum memtype    newmemtype;
; 1036 :     uint_8          newofssize;
; 1037 :     uint_8          oldofssize;
; 1038 : #if FASTPASS
; 1039 :     bool            oldpublic = proc->sym.ispublic;

	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	mov	BYTE PTR oldpublic$[rsp], al

; 1040 : #endif
; 1041 : 
; 1042 :     /* set some default values */
; 1043 : 
; 1044 :     if ( IsPROC ) {

	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	je	$LN11@ParseProc

; 1045 :         proc->e.procinfo->isexport = ModuleInfo.procs_export;

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 3
	and	eax, 1
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	and	al, 1
	shl	al, 2
	movzx	ecx, BYTE PTR [rcx+128]
	and	cl, 251					; 000000fbH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+128], al

; 1046 :         /* don't overwrite a PUBLIC directive for this symbol! */
; 1047 :         if ( ModuleInfo.procs_private == FALSE )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN12@ParseProc

; 1048 :             proc->sym.ispublic = TRUE;

	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rcx+40], al
$LN12@ParseProc:

; 1049 : 
; 1050 :         /* set type of epilog code */
; 1051 : #if STACKBASESUPP
; 1052 :         /* v2.11: if base register isn't [E|R]BP, don't use LEAVE! */
; 1053 :         if ( GetRegNo( proc->e.procinfo->basereg ) != 5 ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, WORD PTR [rax+130]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	cmp	eax, 5
	je	SHORT $LN13@ParseProc

; 1054 :             proc->e.procinfo->pe_type = 0;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+128], al

; 1055 :         } else

	jmp	$LN14@ParseProc
$LN13@ParseProc:

; 1056 : #endif
; 1057 :         if ( Options.masm_compat_gencode ) {

	movzx	eax, BYTE PTR Options+144
	test	eax, eax
	je	SHORT $LN15@ParseProc

; 1058 :             /* v2.07: Masm uses LEAVE if
; 1059 :              * - current code is 32-bit/64-bit or
; 1060 :              * - cpu is .286 or .586+ */
; 1061 :             //proc->e.procinfo->pe_type = ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_286 );
; 1062 :             proc->e.procinfo->pe_type = ( ModuleInfo.Ofssize > USE16 ||

	movzx	eax, BYTE PTR ModuleInfo+404
	test	eax, eax
	jg	SHORT $LN85@ParseProc
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 32					; 00000020H
	je	SHORT $LN85@ParseProc
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 80					; 00000050H
	jge	SHORT $LN85@ParseProc
	mov	DWORD PTR tv141[rsp], 0
	jmp	SHORT $LN86@ParseProc
$LN85@ParseProc:
	mov	DWORD PTR tv141[rsp], 1
$LN86@ParseProc:
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	ecx, BYTE PTR tv141[rsp]
	and	cl, 1
	shl	cl, 1
	movzx	eax, BYTE PTR [rax+128]
	and	al, 253					; 000000fdH
	or	al, cl
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+128], al

; 1063 :                                          ( ModuleInfo.curr_cpu & P_CPU_MASK ) == P_286 ||
; 1064 :                                          ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_586 ) ? 1 : 0;
; 1065 :         } else {

	jmp	SHORT $LN16@ParseProc
$LN15@ParseProc:

; 1066 :             /* use LEAVE for 286, 386 (and x64) */
; 1067 :             proc->e.procinfo->pe_type = ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) == P_286 ||

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 32					; 00000020H
	je	SHORT $LN87@ParseProc
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 112				; 00000070H
	je	SHORT $LN87@ParseProc
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	je	SHORT $LN87@ParseProc
	mov	DWORD PTR tv157[rsp], 0
	jmp	SHORT $LN88@ParseProc
$LN87@ParseProc:
	mov	DWORD PTR tv157[rsp], 1
$LN88@ParseProc:
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	ecx, BYTE PTR tv157[rsp]
	and	cl, 1
	shl	cl, 1
	movzx	eax, BYTE PTR [rax+128]
	and	al, 253					; 000000fdH
	or	al, cl
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+128], al
$LN16@ParseProc:
$LN14@ParseProc:
$LN11@ParseProc:

; 1068 : #if AMD64_SUPPORT
; 1069 :                                          ( ModuleInfo.curr_cpu & P_CPU_MASK ) == P_64 ||
; 1070 : #endif
; 1071 :                                          ( ModuleInfo.curr_cpu & P_CPU_MASK ) == P_386 ) ? 1 : 0;
; 1072 :         }
; 1073 :     }
; 1074 : 
; 1075 : #if MANGLERSUPP
; 1076 :     /* OW name mangling */
; 1077 :     if( tokenarray[i].token == T_STRING && IsPROC ) {
; 1078 :         /* SetMangler() will ignore LANG_NONE */
; 1079 :         SetMangler( &proc->sym, LANG_NONE, tokenarray[i].string_ptr );
; 1080 :         i++;
; 1081 :     }
; 1082 : #endif
; 1083 : 
; 1084 :     /* 1. attribute is <distance> */
; 1085 :     if ( tokenarray[i].token == T_STYPE &&
; 1086 :         tokenarray[i].tokval >= T_NEAR && tokenarray[i].tokval <= T_FAR32 ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 6
	jne	$LN17@ParseProc
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 221		; 000000ddH
	jb	$LN17@ParseProc
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 226		; 000000e2H
	ja	$LN17@ParseProc

; 1087 :         uint_8 Ofssize = GetSflagsSp( tokenarray[i].tokval );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+4]
	mov	BYTE PTR Ofssize$1[rsp], al

; 1088 :         /* v2.06: SimpleType is obsolete */
; 1089 :         /* v2.05: FindStdType() is obsolete */
; 1090 :         //type = tokenarray[i].bytval;
; 1091 :         //type = FindStdType(tokenarray[i].value);
; 1092 :         if ( IsPROC ) {

	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	je	SHORT $LN19@ParseProc

; 1093 :             if ( ( ModuleInfo.Ofssize >= USE32 && Ofssize == USE16 ) ||

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jl	SHORT $LN22@ParseProc
	movzx	eax, BYTE PTR Ofssize$1[rsp]
	test	eax, eax
	je	SHORT $LN21@ParseProc
$LN22@ParseProc:
	movzx	eax, BYTE PTR ModuleInfo+404
	test	eax, eax
	jne	SHORT $LN20@ParseProc
	movzx	eax, BYTE PTR Ofssize$1[rsp]
	cmp	eax, 1
	jne	SHORT $LN20@ParseProc
$LN21@ParseProc:

; 1094 :                 ( ModuleInfo.Ofssize == USE16 && Ofssize == USE32 ) ) {
; 1095 :                 EmitError( DISTANCE_INVALID );

	mov	ecx, 171				; 000000abH
	call	EmitError
$LN20@ParseProc:
$LN19@ParseProc:

; 1096 :             }
; 1097 :         }
; 1098 :         newmemtype = GetMemtypeSp( tokenarray[i].tokval );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	DWORD PTR newmemtype$[rsp], eax

; 1099 :         newofssize = (( Ofssize != USE_EMPTY ) ? Ofssize : ModuleInfo.Ofssize );

	movzx	eax, BYTE PTR Ofssize$1[rsp]
	cmp	eax, 254				; 000000feH
	je	SHORT $LN89@ParseProc
	movzx	eax, BYTE PTR Ofssize$1[rsp]
	mov	DWORD PTR tv213[rsp], eax
	jmp	SHORT $LN90@ParseProc
$LN89@ParseProc:
	movzx	eax, BYTE PTR ModuleInfo+404
	mov	DWORD PTR tv213[rsp], eax
$LN90@ParseProc:
	movzx	eax, BYTE PTR tv213[rsp]
	mov	BYTE PTR newofssize$[rsp], al

; 1100 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1101 :     } else {

	jmp	SHORT $LN18@ParseProc
$LN17@ParseProc:

; 1102 :         newmemtype = ( ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) ? MT_FAR : MT_NEAR );

	mov	eax, DWORD PTR ModuleInfo+360
	mov	ecx, 1
	mov	DWORD PTR tv864[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv864[rsp]
	shl	eax, cl
	and	eax, 112				; 00000070H
	test	eax, eax
	je	SHORT $LN91@ParseProc
	mov	DWORD PTR tv219[rsp], 130		; 00000082H
	jmp	SHORT $LN92@ParseProc
$LN91@ParseProc:
	mov	DWORD PTR tv219[rsp], 129		; 00000081H
$LN92@ParseProc:
	mov	eax, DWORD PTR tv219[rsp]
	mov	DWORD PTR newmemtype$[rsp], eax

; 1103 :         newofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	BYTE PTR newofssize$[rsp], al
$LN18@ParseProc:

; 1104 :     }
; 1105 : 
; 1106 :     /* v2.11: GetSymOfssize() cannot handle SYM_TYPE correctly */
; 1107 :     if ( proc->sym.state == SYM_TYPE )

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN23@ParseProc

; 1108 :         oldofssize = proc->sym.seg_ofssize;

	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	and	al, 3
	mov	BYTE PTR oldofssize$[rsp], al
	jmp	SHORT $LN24@ParseProc
$LN23@ParseProc:

; 1109 :     else
; 1110 :         oldofssize = GetSymOfssize( &proc->sym );

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, rax
	call	GetSymOfssize
	mov	BYTE PTR oldofssize$[rsp], al
$LN24@ParseProc:

; 1111 : 
; 1112 :     /* did the distance attribute change? */
; 1113 :     if ( proc->sym.mem_type != MT_EMPTY &&

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+36], 192			; 000000c0H
	je	$LN25@ParseProc
	mov	rax, QWORD PTR proc$[rsp]
	mov	ecx, DWORD PTR newmemtype$[rsp]
	cmp	DWORD PTR [rax+36], ecx
	jne	SHORT $LN27@ParseProc
	movzx	eax, BYTE PTR oldofssize$[rsp]
	movzx	ecx, BYTE PTR newofssize$[rsp]
	cmp	eax, ecx
	je	SHORT $LN25@ParseProc
$LN27@ParseProc:

; 1114 :         ( proc->sym.mem_type != newmemtype ||
; 1115 :          oldofssize != newofssize ) ) {
; 1116 :         DebugMsg(("ParseProc: error, memtype changed, old-new memtype=%X-%X, ofssize=%X-%X\n", proc->sym.mem_type, newmemtype, proc->sym.Ofssize, newofssize));

	movzx	eax, BYTE PTR newofssize$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	movzx	ecx, BYTE PTR [rcx+44]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, DWORD PTR newmemtype$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	edx, DWORD PTR [rax+36]
	lea	rcx, OFFSET FLAT:$SG11793
	call	DoDebugMsg

; 1117 :         if ( proc->sym.mem_type == MT_NEAR || proc->sym.mem_type == MT_FAR )

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+36], 129			; 00000081H
	je	SHORT $LN30@ParseProc
	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN28@ParseProc
$LN30@ParseProc:

; 1118 :             EmitError( PROC_AND_PROTO_CALLING_CONV_CONFLICT );

	mov	ecx, 138				; 0000008aH
	call	EmitError
	jmp	SHORT $LN29@ParseProc
$LN28@ParseProc:

; 1119 :         else {
; 1120 :             return( EmitErr( SYMBOL_REDEFINITION, proc->sym.name ) );

	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@ParseProc
$LN29@ParseProc:

; 1121 :         }
; 1122 :     } else {

	jmp	SHORT $LN26@ParseProc
$LN25@ParseProc:

; 1123 :         proc->sym.mem_type = newmemtype;

	mov	rax, QWORD PTR proc$[rsp]
	mov	ecx, DWORD PTR newmemtype$[rsp]
	mov	DWORD PTR [rax+36], ecx

; 1124 :         if ( IsPROC == FALSE )

	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	jne	SHORT $LN31@ParseProc

; 1125 :             proc->sym.seg_ofssize = newofssize;

	movzx	eax, BYTE PTR newofssize$[rsp]
	and	al, 3
	mov	rcx, QWORD PTR proc$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 252					; 000000fcH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rcx+47], al
$LN31@ParseProc:
$LN26@ParseProc:

; 1126 :     }
; 1127 : 
; 1128 :     /* 2. attribute is <langtype> */
; 1129 :     /* v2.09: the default language value is now a function argument. This is because
; 1130 :      * EXTERN[DEF] allows to set the language attribute by:
; 1131 :      * EXTERN[DEF] <langtype> <name> PROTO ...
; 1132 :      * ( see CreateProto() in extern.c )
; 1133 :      */
; 1134 :     //langtype = ModuleInfo.langtype; /* set the default value */
; 1135 :     GetLangType( &i, tokenarray, &langtype ); /* optionally overwrite the value */

	lea	r8, QWORD PTR langtype$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	GetLangType

; 1136 :     
; 1137 : 	/* John Hankinson: 2016-02-10 Allows Linux64 to utilise Win64 ABI */
; 1138 : 	#if AMD64_SUPPORT
; 1139 : 	if (Options.output_format == OFORMAT_ELF)

	cmp	DWORD PTR Options+160, 3
	jne	SHORT $LN32@ParseProc

; 1140 : 		langtype = LANG_FASTCALL;

	mov	DWORD PTR langtype$[rsp], 7
$LN32@ParseProc:

; 1141 : 	#endif
; 1142 : 
; 1143 : 	/* has language changed? */
; 1144 :     if ( proc->sym.langtype != LANG_NONE && proc->sym.langtype != langtype ) {

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 0
	je	SHORT $LN33@ParseProc
	mov	rax, QWORD PTR proc$[rsp]
	mov	ecx, DWORD PTR langtype$[rsp]
	cmp	DWORD PTR [rax+76], ecx
	je	SHORT $LN33@ParseProc

; 1145 :         DebugMsg(("ParseProc: error, language changed, %u - %u\n", proc->sym.langtype, langtype ));

	mov	r8d, DWORD PTR langtype$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	edx, DWORD PTR [rax+76]
	lea	rcx, OFFSET FLAT:$SG11801
	call	DoDebugMsg

; 1146 :         EmitError( PROC_AND_PROTO_CALLING_CONV_CONFLICT );

	mov	ecx, 138				; 0000008aH
	call	EmitError

; 1147 :     } else

	jmp	SHORT $LN34@ParseProc
$LN33@ParseProc:

; 1148 :         proc->sym.langtype = langtype;

	mov	rax, QWORD PTR proc$[rsp]
	mov	ecx, DWORD PTR langtype$[rsp]
	mov	DWORD PTR [rax+76], ecx
$LN34@ParseProc:

; 1149 : 
; 1150 : 	/* John Hankinson: 2016-02-10 Allows Linux64 to utilise Win64 ABI */
; 1151 : 	#if AMD64_SUPPORT
; 1152 : 	if (proc->sym.langtype == LANG_NONE && Options.output_format == OFORMAT_ELF)

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 0
	jne	SHORT $LN35@ParseProc
	cmp	DWORD PTR Options+160, 3
	jne	SHORT $LN35@ParseProc

; 1153 : 	{
; 1154 : 		proc->sym.langtype = LANG_FASTCALL;

	mov	rax, QWORD PTR proc$[rsp]
	mov	DWORD PTR [rax+76], 7
$LN35@ParseProc:

; 1155 : 	}
; 1156 : 	#endif
; 1157 : 
; 1158 :     /* 3. attribute is <visibility> */
; 1159 :     /* note that reserved word PUBLIC is a directive! */
; 1160 :     /* PROTO does NOT accept PUBLIC! However,
; 1161 :      * PROTO accepts PRIVATE and EXPORT, but these attributes are just ignored!
; 1162 :      */
; 1163 : 
; 1164 :     if ( tokenarray[i].token == T_ID || tokenarray[i].token == T_DIRECTIVE ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN37@ParseProc
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	$LN36@ParseProc
$LN37@ParseProc:

; 1165 :         token = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR token$[rsp], rax

; 1166 :         if ( _stricmp( token, "PRIVATE") == 0 ) {

	lea	rdx, OFFSET FLAT:$SG11807
	mov	rcx, QWORD PTR token$[rsp]
	call	_stricmp
	test	eax, eax
	jne	$LN38@ParseProc

; 1167 :             if ( IsPROC ) { /* v2.11: ignore PRIVATE for PROTO */

	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	je	SHORT $LN40@ParseProc

; 1168 :                 proc->sym.ispublic = FALSE;

	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 127					; 0000007fH
	mov	rcx, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rcx+40], al

; 1169 : #if FASTPASS
; 1170 :                 /* error if there was a PUBLIC directive! */
; 1171 :                 proc->sym.scoped = TRUE;

	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 4
	mov	rcx, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rcx+40], al

; 1172 :                 if ( oldpublic ) {

	movzx	eax, BYTE PTR oldpublic$[rsp]
	test	eax, eax
	je	SHORT $LN41@ParseProc

; 1173 :                     SkipSavedState(); /* do a full pass-2 scan */

	call	SkipSavedState
$LN41@ParseProc:

; 1174 :                 }
; 1175 : #endif
; 1176 :                 proc->e.procinfo->isexport = FALSE;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 251					; 000000fbH
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+128], al
$LN40@ParseProc:

; 1177 :             }
; 1178 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	$LN39@ParseProc
$LN38@ParseProc:

; 1179 :         } else if ( IsPROC && (_stricmp(token, "PUBLIC") == 0 ) ) {

	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	je	SHORT $LN42@ParseProc
	lea	rdx, OFFSET FLAT:$SG11812
	mov	rcx, QWORD PTR token$[rsp]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN42@ParseProc

; 1180 :             proc->sym.ispublic = TRUE;

	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rcx+40], al

; 1181 :             proc->e.procinfo->isexport = FALSE;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 251					; 000000fbH
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+128], al

; 1182 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	$LN43@ParseProc
$LN42@ParseProc:

; 1183 :         } else if ( _stricmp(token, "EXPORT") == 0 ) {

	lea	rdx, OFFSET FLAT:$SG11814
	mov	rcx, QWORD PTR token$[rsp]
	call	_stricmp
	test	eax, eax
	jne	$LN44@ParseProc

; 1184 :             DebugMsg1(("ParseProc(%s): EXPORT detected\n", proc->sym.name ));

	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11815
	call	DoDebugMsg1

; 1185 :             if ( IsPROC ) { /* v2.11: ignore EXPORT for PROTO */

	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	je	SHORT $LN45@ParseProc

; 1186 :                 proc->sym.ispublic = TRUE;

	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rcx+40], al

; 1187 :                 proc->e.procinfo->isexport = TRUE;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	or	al, 4
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+128], al

; 1188 :                 /* v2.11: no export for 16-bit near */
; 1189 :                 if ( ModuleInfo.Ofssize == USE16 && proc->sym.mem_type == MT_NEAR )

	movzx	eax, BYTE PTR ModuleInfo+404
	test	eax, eax
	jne	SHORT $LN46@ParseProc
	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+36], 129			; 00000081H
	jne	SHORT $LN46@ParseProc

; 1190 :                     EmitErr( EXPORT_MUST_BE_FAR, proc->sym.name );

	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 277				; 00000115H
	call	EmitErr
$LN46@ParseProc:
$LN45@ParseProc:

; 1191 :             }
; 1192 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN44@ParseProc:
$LN43@ParseProc:
$LN39@ParseProc:
$LN36@ParseProc:

; 1193 :         }
; 1194 :     }
; 1195 : 
; 1196 :     /* 4. attribute is <prologuearg>, for PROC only.
; 1197 :      * it must be enclosed in <>
; 1198 :      */
; 1199 :     if ( IsPROC && tokenarray[i].token == T_STRING && tokenarray[i].string_delim == '<' ) {

	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	je	$LN47@ParseProc
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	$LN47@ParseProc
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	jne	$LN47@ParseProc

; 1200 :         int idx = Token_Count + 1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR idx$2[rsp], eax

; 1201 :         int max;
; 1202 :         if ( ModuleInfo.prologuemode == PEM_NONE )

	movzx	eax, BYTE PTR ModuleInfo+424
	cmp	eax, 2
	jne	SHORT $LN48@ParseProc

; 1203 :             ; /* no prologue at all */

	jmp	$LN49@ParseProc
$LN48@ParseProc:

; 1204 :         else if ( ModuleInfo.prologuemode == PEM_MACRO ) {

	movzx	eax, BYTE PTR ModuleInfo+424
	cmp	eax, 1
	jne	SHORT $LN50@ParseProc

; 1205 :             proc->e.procinfo->prologuearg = LclAlloc( tokenarray[i].stringlen + 1 );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	inc	eax
	mov	eax, eax
	mov	ecx, eax
	call	LclAlloc
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx+48], rax

; 1206 :             strcpy( proc->e.procinfo->prologuearg, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rdx+rax+8]
	mov	rcx, QWORD PTR [rcx+48]
	call	strcpy

; 1207 :         } else {

	jmp	$LN51@ParseProc
$LN50@ParseProc:

; 1208 :             /* check the argument. The default prologue
; 1209 :              understands FORCEFRAME and LOADDS only
; 1210 :              */
; 1211 :             max = Tokenize( tokenarray[i].string_ptr, idx, tokenarray, TOK_RESCAN );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR idx$2[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	Tokenize
	mov	DWORD PTR max$6[rsp], eax

; 1212 :             for ( ; idx < max; idx++ ) {

	jmp	SHORT $LN4@ParseProc
$LN2@ParseProc:
	mov	eax, DWORD PTR idx$2[rsp]
	inc	eax
	mov	DWORD PTR idx$2[rsp], eax
$LN4@ParseProc:
	mov	eax, DWORD PTR max$6[rsp]
	cmp	DWORD PTR idx$2[rsp], eax
	jge	$LN3@ParseProc

; 1213 :                 if ( tokenarray[idx].token == T_ID ) {

	movsxd	rax, DWORD PTR idx$2[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN52@ParseProc

; 1214 :                     if ( _stricmp( tokenarray[idx].string_ptr, "FORCEFRAME") == 0 ) {

	movsxd	rax, DWORD PTR idx$2[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG11827
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN54@ParseProc

; 1215 :                         proc->e.procinfo->forceframe = TRUE;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	or	al, 8
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+128], al
	jmp	$LN55@ParseProc
$LN54@ParseProc:

; 1216 : #if AMD64_SUPPORT
; 1217 :                     } else if ( ModuleInfo.Ofssize != USE64 && (_stricmp( tokenarray[idx].string_ptr, "LOADDS") == 0 ) ) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	je	SHORT $LN56@ParseProc
	movsxd	rax, DWORD PTR idx$2[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG11830
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN56@ParseProc

; 1218 : #else
; 1219 :                     } else if ( _stricmp( tokenarray[idx].string_ptr, "LOADDS") == 0 ) {
; 1220 : #endif
; 1221 :                         if ( ModuleInfo.model == MODEL_FLAT ) {

	cmp	DWORD PTR ModuleInfo+360, 7
	jne	SHORT $LN58@ParseProc

; 1222 :                             EmitWarn( 2, LOADDS_IGNORED_IN_FLAT_MODEL );

	mov	edx, 226				; 000000e2H
	mov	ecx, 2
	call	EmitWarn

; 1223 :                         } else

	jmp	SHORT $LN59@ParseProc
$LN58@ParseProc:

; 1224 :                             proc->e.procinfo->loadds = TRUE;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	or	al, 16
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+128], al
$LN59@ParseProc:

; 1225 :                     } else {

	jmp	SHORT $LN57@ParseProc
$LN56@ParseProc:

; 1226 :                         return( EmitErr( UNKNOWN_DEFAULT_PROLOGUE_ARGUMENT, tokenarray[idx].string_ptr ) );

	movsxd	rax, DWORD PTR idx$2[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 225				; 000000e1H
	call	EmitErr
	jmp	$LN1@ParseProc
$LN57@ParseProc:
$LN55@ParseProc:

; 1227 :                     }
; 1228 :                     if ( tokenarray[idx+1].token == T_COMMA && tokenarray[idx+2].token != T_FINAL)

	mov	eax, DWORD PTR idx$2[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN60@ParseProc
	mov	eax, DWORD PTR idx$2[rsp]
	add	eax, 2
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN60@ParseProc

; 1229 :                         idx++;

	mov	eax, DWORD PTR idx$2[rsp]
	inc	eax
	mov	DWORD PTR idx$2[rsp], eax
$LN60@ParseProc:

; 1230 :                 } else {

	jmp	SHORT $LN53@ParseProc
$LN52@ParseProc:

; 1231 :                     return( EmitErr( SYNTAX_ERROR_EX, tokenarray[idx].string_ptr ) );

	movsxd	rax, DWORD PTR idx$2[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ParseProc
$LN53@ParseProc:

; 1232 :                 }
; 1233 :             }

	jmp	$LN2@ParseProc
$LN3@ParseProc:
$LN51@ParseProc:
$LN49@ParseProc:

; 1234 :         }
; 1235 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN47@ParseProc:

; 1236 :     }
; 1237 : 
; 1238 : #if AMD64_SUPPORT
; 1239 :     /* check for optional FRAME[:exc_proc] */
; 1240 :     if ( ModuleInfo.Ofssize == USE64 &&
; 1241 :         IsPROC &&
; 1242 :         tokenarray[i].token == T_RES_ID &&

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	$LN61@ParseProc
	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	je	$LN61@ParseProc
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 7
	jne	$LN61@ParseProc
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 263		; 00000107H
	jne	$LN61@ParseProc

; 1243 :         tokenarray[i].tokval == T_FRAME ) {
; 1244 : 		/* v2.05: don't accept FRAME for ELF  - 2016-02-10 John Hankinson allowed ELF64 to use FRAME/Win64 ABI */
; 1245 : 		if (Options.output_format != OFORMAT_COFF && Options.output_format != OFORMAT_ELF
; 1246 : #if PE_SUPPORT
; 1247 :             && ModuleInfo.sub_format != SFORMAT_PE

	cmp	DWORD PTR Options+160, 2
	je	SHORT $LN62@ParseProc
	cmp	DWORD PTR Options+160, 3
	je	SHORT $LN62@ParseProc
	cmp	DWORD PTR ModuleInfo+372, 2
	je	SHORT $LN62@ParseProc

; 1248 : #endif
; 1249 :            ) {
; 1250 :             return( EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, GetResWName( T_FRAME, NULL ) ) );

	xor	edx, edx
	mov	ecx, 263				; 00000107H
	call	GetResWName
	mov	rdx, rax
	mov	ecx, 224				; 000000e0H
	call	EmitErr
	jmp	$LN1@ParseProc
$LN62@ParseProc:

; 1251 :         }
; 1252 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1253 :         if( tokenarray[i].token == T_COLON ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	$LN63@ParseProc

; 1254 :             struct asym *sym;
; 1255 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1256 :             if ( tokenarray[i].token != T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN65@ParseProc

; 1257 :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ParseProc
$LN65@ParseProc:

; 1258 :             }
; 1259 :             sym = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$4[rsp], rax

; 1260 :             if ( sym == NULL ) {

	cmp	QWORD PTR sym$4[rsp], 0
	jne	SHORT $LN66@ParseProc

; 1261 :                 sym = SymCreate( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymCreate
	mov	QWORD PTR sym$4[rsp], rax

; 1262 :                 sym->state = SYM_UNDEFINED;

	mov	rax, QWORD PTR sym$4[rsp]
	mov	DWORD PTR [rax+32], 0

; 1263 :                 sym->used = TRUE;

	mov	rax, QWORD PTR sym$4[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 1
	mov	rcx, QWORD PTR sym$4[rsp]
	mov	BYTE PTR [rcx+40], al

; 1264 :                 sym_add_table( &SymTables[TAB_UNDEF], (struct dsym *)sym ); /* add UNDEFINED */

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$4[rsp]
	mov	rcx, rax
	call	sym_add_table

; 1265 :             } else if ( sym->state != SYM_UNDEFINED &&

	jmp	SHORT $LN67@ParseProc
$LN66@ParseProc:

; 1266 :                        sym->state != SYM_INTERNAL &&

	mov	rax, QWORD PTR sym$4[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN68@ParseProc
	mov	rax, QWORD PTR sym$4[rsp]
	cmp	DWORD PTR [rax+32], 1
	je	SHORT $LN68@ParseProc
	mov	rax, QWORD PTR sym$4[rsp]
	cmp	DWORD PTR [rax+32], 2
	je	SHORT $LN68@ParseProc

; 1267 :                        sym->state != SYM_EXTERNAL ) {
; 1268 :                 return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rax, QWORD PTR sym$4[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@ParseProc
$LN68@ParseProc:
$LN67@ParseProc:

; 1269 :             }
; 1270 :             proc->e.procinfo->exc_handler = sym;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR sym$4[rsp]
	mov	QWORD PTR [rax+88], rcx

; 1271 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1272 :         } else

	jmp	SHORT $LN64@ParseProc
$LN63@ParseProc:

; 1273 :             proc->e.procinfo->exc_handler = NULL;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rax+88], 0
$LN64@ParseProc:

; 1274 :         proc->e.procinfo->isframe = TRUE;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+128], al
$LN61@ParseProc:

; 1275 :     }
; 1276 : #endif
; 1277 :     /* check for USES */
; 1278 :     if ( tokenarray[i].token == T_ID && _stricmp( tokenarray[i].string_ptr, "USES" ) == 0 ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN69@ParseProc
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG11843
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	_stricmp
	test	eax, eax
	jne	$LN69@ParseProc

; 1279 :         int cnt;
; 1280 :         int j;
; 1281 :         if ( !IsPROC ) {/* not for PROTO! */

	movzx	eax, BYTE PTR IsPROC$[rsp]
	test	eax, eax
	jne	SHORT $LN70@ParseProc

; 1282 :             DebugMsg(("ParseProc: USES found in PROTO\n"));

	lea	rcx, OFFSET FLAT:$SG11845
	call	DoDebugMsg

; 1283 :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN70@ParseProc:

; 1284 :         }
; 1285 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1286 :         /* count register names which follow */
; 1287 :         for ( cnt = 0, j = i; tokenarray[j].token == T_REG; j++, cnt++ );

	mov	DWORD PTR cnt$3[rsp], 0
	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR j$5[rsp], eax
	jmp	SHORT $LN7@ParseProc
$LN5@ParseProc:
	mov	eax, DWORD PTR j$5[rsp]
	inc	eax
	mov	DWORD PTR j$5[rsp], eax
	mov	eax, DWORD PTR cnt$3[rsp]
	inc	eax
	mov	DWORD PTR cnt$3[rsp], eax
$LN7@ParseProc:
	movsxd	rax, DWORD PTR j$5[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	jne	SHORT $LN6@ParseProc
	jmp	SHORT $LN5@ParseProc
$LN6@ParseProc:

; 1288 : 
; 1289 :         if ( cnt == 0 ) {

	cmp	DWORD PTR cnt$3[rsp], 0
	jne	SHORT $LN71@ParseProc

; 1290 :             DebugMsg(("ParseProc: no registers for regslist\n"));

	lea	rcx, OFFSET FLAT:$SG11848
	call	DoDebugMsg

; 1291 :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i-1].tokpos );

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1292 :         } else {

	jmp	$LN72@ParseProc
$LN71@ParseProc:

; 1293 :             regist = LclAlloc( (cnt + 1) * sizeof( uint_16 ) );

	mov	eax, DWORD PTR cnt$3[rsp]
	inc	eax
	cdqe
	shl	rax, 1
	mov	rcx, rax
	call	LclAlloc
	mov	QWORD PTR regist$[rsp], rax

; 1294 :             proc->e.procinfo->regslist = regist;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR regist$[rsp]
	mov	QWORD PTR [rax], rcx

; 1295 :             *regist++ = cnt;

	mov	rax, QWORD PTR regist$[rsp]
	movzx	ecx, WORD PTR cnt$3[rsp]
	mov	WORD PTR [rax], cx
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax

; 1296 :             /* read in registers */
; 1297 :             for( ; tokenarray[i].token == T_REG; i++ ) {

	jmp	SHORT $LN10@ParseProc
$LN8@ParseProc:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@ParseProc:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	jne	SHORT $LN9@ParseProc

; 1298 :                 if ( SizeFromRegister( tokenarray[i].tokval ) == 1 ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+16]
	call	SizeFromRegister
	cmp	eax, 1
	jne	SHORT $LN73@ParseProc

; 1299 :                     EmitError( INVALID_USE_OF_REGISTER );

	mov	ecx, 170				; 000000aaH
	call	EmitError
$LN73@ParseProc:

; 1300 :                 }
; 1301 :                 *regist++ = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR regist$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	movzx	eax, WORD PTR [rdx+rax+16]
	mov	WORD PTR [rcx], ax
	mov	rax, QWORD PTR regist$[rsp]
	add	rax, 2
	mov	QWORD PTR regist$[rsp], rax

; 1302 :             }

	jmp	$LN8@ParseProc
$LN9@ParseProc:
$LN72@ParseProc:
$LN69@ParseProc:

; 1303 :         }
; 1304 :     }
; 1305 : 
; 1306 :     /* the parameters must follow */
; 1307 :     if ( tokenarray[i].token == T_STYPE || tokenarray[i].token == T_RES_ID || tokenarray[i].token == T_DIRECTIVE ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 6
	je	SHORT $LN75@ParseProc
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 7
	je	SHORT $LN75@ParseProc
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	SHORT $LN74@ParseProc
$LN75@ParseProc:

; 1308 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ParseProc
$LN74@ParseProc:

; 1309 :     }
; 1310 : 
; 1311 :     /* skip optional comma */
; 1312 :     if ( tokenarray[i].token == T_COMMA )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN76@ParseProc

; 1313 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN76@ParseProc:

; 1314 : 
; 1315 :     DebugMsg1(("ParseProc(%s): i=%u, Token_Count=%u, CurrWordSize=%u\n", proc->sym.name, i, Token_Count, CurrWordSize ));

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR ModuleInfo+496
	mov	r8d, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11853
	call	DoDebugMsg1

; 1316 : 
; 1317 :     if( i >= Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jl	SHORT $LN77@ParseProc

; 1318 :         /* procedure has no parameters at all */
; 1319 :         if ( proc->e.procinfo->paralist != NULL )

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN79@ParseProc

; 1320 :             EmitErr( CONFLICTING_PARAMETER_DEFINITION, "" );

	lea	rdx, OFFSET FLAT:$SG11857
	mov	ecx, 137				; 00000089H
	call	EmitErr
$LN79@ParseProc:

; 1321 :     } else if( proc->sym.langtype == LANG_NONE ) {

	jmp	$LN78@ParseProc
$LN77@ParseProc:
	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+76], 0
	jne	SHORT $LN80@ParseProc

; 1322 :         EmitError( LANG_MUST_BE_SPECIFIED );

	mov	ecx, 91					; 0000005bH
	call	EmitError

; 1323 :     } else {

	jmp	$LN81@ParseProc
$LN80@ParseProc:

; 1324 :         /* v2.05: set PROC's vararg flag BEFORE params are scanned! */
; 1325 :         if ( tokenarray[Token_Count - 1].token == T_RES_ID &&

	mov	eax, DWORD PTR ModuleInfo+496
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 7
	jne	SHORT $LN82@ParseProc
	mov	eax, DWORD PTR ModuleInfo+496
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 262		; 00000106H
	jne	SHORT $LN82@ParseProc

; 1326 :             tokenarray[Token_Count - 1].tokval == T_VARARG )
; 1327 :             proc->e.procinfo->has_vararg = TRUE;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	or	al, 1
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+128], al
$LN82@ParseProc:

; 1328 :         /* v2.04: removed, comma is checked above already */
; 1329 :         //if( tokenarray[i].token == T_COMMA )
; 1330 :         //    i++;
; 1331 :         if ( ERROR == ParseParams( proc, i, tokenarray, IsPROC ) )

	movzx	r9d, BYTE PTR IsPROC$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	call	ParseParams
$LN81@ParseProc:
$LN78@ParseProc:

; 1332 :             /* do proceed if the parameter scan returns an error */
; 1333 :             ;//return( ERROR );
; 1334 :     }
; 1335 : 
; 1336 :     /* v2.11: isdefined and isproc now set here */
; 1337 :     proc->sym.isdefined = TRUE;

	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rcx+40], al

; 1338 :     proc->sym.isproc = TRUE;

	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	or	al, 8
	mov	rcx, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rcx+41], al

; 1339 :     //proc->e.procinfo->init_done = TRUE;
; 1340 :     DebugMsg1(("ParseProc(%s): memtype=%Xh parasize=%u\n", proc->sym.name, proc->sym.mem_type, proc->e.procinfo->parasize));

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	r9d, DWORD PTR [rax+32]
	mov	rax, QWORD PTR proc$[rsp]
	mov	r8d, DWORD PTR [rax+36]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11862
	call	DoDebugMsg1

; 1341 : 
; 1342 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@ParseProc:

; 1343 : }

	add	rsp, 136				; 00000088H
	ret	0
ParseProc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1788 : }

	add	rsp, 56					; 00000038H
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

	add	rsp, 56					; 00000038H
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	__stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1391 : }

	add	rsp, 72					; 00000048H
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 950  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 957  : }

	add	rsp, 56					; 00000038H
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 640  : }

	add	rsp, 56					; 00000038H
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
