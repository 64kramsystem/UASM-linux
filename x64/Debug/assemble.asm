; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	jmpenv
EXTRN	omf_init:PROC
EXTRN	coff_init:PROC
EXTRN	elf_init:PROC
EXTRN	bin_init:PROC
_BSS	SEGMENT
jmpenv	DB	0100H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	LinnumQueue:BYTE:010H
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
COMM	ModuleInfo:BYTE:0308H
COMM	Parse_Pass:DWORD
COMM	write_to_file:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11773 DB	'_TEXT', 00H
?PrintEmptyLine@?1??WritePreprocessedLine@@9@9 DB 01H	; `WritePreprocessedLine'::`2'::PrintEmptyLine
	ORG $+1
$SG11774 DB	'.text', 00H
	ORG $+2
$SG11775 DB	'_DATA', 00H
	ORG $+2
$SG11776 DB	'.data', 00H
	ORG $+2
$SG11777 DB	'CONST', 00H
	ORG $+2
$SG11778 DB	'.rdata', 00H
	ORG $+1
$SG11779 DB	'_BSS', 00H
	ORG $+3
$SG11780 DB	'.bss', 00H
	ORG $+3
$SG11810 DB	'assemble.c', 00H
	ORG $+1
$SG11902 DB	'w', 00H
	ORG $+2
$SG11813 DB	'OutputByte: segment start loc changed from %Xh to %Xh', 0aH
	DB	00H
	ORG $+1
$SG11829 DB	'assemble.c', 00H
	ORG $+1
$SG11974 DB	'%s', 0aH, 00H
$SG11832 DB	'OutputByte: segment start loc changed from %Xh to %Xh', 0aH
	DB	00H
	ORG $+1
$SG11855 DB	'assemble.c', 00H
	ORG $+1
$SG11976 DB	0aH, 00H
	ORG $+2
$SG11859 DB	'OutputBytes: segment start loc changed from %Xh to %Xh', 0aH
	DB	00H
$SG11897 DB	'WriteModule enter', 0aH, 00H
	ORG $+1
$SG12139 DB	'rb', 00H
	ORG $+1
$SG11904 DB	'WriteModule: ext=%s, isproc=%u, weak=%u', 0aH, 00H
	ORG $+3
$SG12001 DB	'%r %s', 00H
	ORG $+2
$SG12143 DB	'wb', 00H
	ORG $+1
$SG11907 DB	'import ''%s''  %s.%s', 0aH, 00H
$SG12148 DB	'wb', 00H
	ORG $+1
$SG11909 DB	'WriteModule exit', 0aH, 00H
	ORG $+2
$SG12181 DB	'EXE', 00H
$SG11934 DB	'add_cmdline_tmacros enter', 0aH, 00H
	ORG $+1
$SG12182 DB	'BIN', 00H
$SG11935 DB	'add_cmdline_tmacros: found >%s<', 0aH, 00H
	ORG $+3
$SG12183 DB	'obj', 00H
$SG11940 DB	'add_cmdline_tmacros: name >%s< invalid', 0aH, 00H
$SG11951 DB	'add_incpaths: enter', 0aH, 00H
	ORG $+3
$SG11957 DB	'CmdlParamsInit(%u) enter', 0aH, 00H
	ORG $+2
$SG12185 DB	'lst', 00H
$SG11961 DB	'INCLUDE', 00H
$SG11962 DB	'CmdlParamsInit exit', 0aH, 00H
	ORG $+3
$SG11992 DB	'ModulePassInit() enter', 0aH, 00H
$SG12050 DB	'PassOneChecks: undefined symbol %s', 0aH, 00H
$SG12187 DB	'err', 00H
$SG12055 DB	'PassOneChecks: public for weak external skipped: %s', 0aH
	DB	00H
	ORG $+3
$SG12059 DB	'PassOneChecks: undefined segment %s', 0aH, 00H
	ORG $+3
$SG12056 DB	'PassOneChecks: invalid public attribute for %s [state=%u'
	DB	' weak=%u]', 0aH, 00H
	ORG $+1
$SG12271 DB	'%s', 0aH, 00H
$SG12077 DB	'PassOneChecks: removed unused externals: %u', 0aH, 00H
	ORG $+3
$SG12078 DB	'PassOneChecks: forward references:', 0aH, 00H
	ORG $+4
$SG12079 DB	'PassOneChecks: segm=%s, labels=%u forward refs=%u', 0aH, 00H
	ORG $+1
$SG12099 DB	'NULL', 00H
	ORG $+7
$SG12100 DB	'OnePass(%u) segments (current=%s):', 0aH, 00H
	ORG $+4
$SG12101 DB	'OnePass(%u): segm=%-8s typ=%X start=%8X max_ofs=%8X', 0aH
	DB	00H
	ORG $+3
$SG12105 DB	'OnePass(%u) cur/nxt=%X/%X src=%X.%u mlvl=%u: >%s<', 0aH, 00H
	ORG $+5
$SG12107 DB	'OnePass: force include of file: %s', 0aH, 00H
	ORG $+4
$SG12131 DB	'ReswTableInit: disable INCBIN + FASTCALL keywords', 0aH, 00H
	ORG $+5
$SG12138 DB	'open_files() enter', 0aH, 00H
	ORG $+4
$SG12141 DB	'open_files(): cannot open source file, fopen("%s") faile'
	DB	'd', 0aH, 00H
	ORG $+5
$SG12145 DB	'open_files(): cannot open object file, fopen("%s") faile'
	DB	'd', 0aH, 00H
	ORG $+5
$SG12146 DB	'open_files(): output, fopen("%s") ok', 0aH, 00H
	ORG $+2
$SG12203 DB	'SetFilenames("%s") enter', 0aH, 00H
	ORG $+6
$SG12209 DB	'SetFilenames: i=%u >%s<', 0aH, 00H
	ORG $+7
$SG12215 DB	'AssembleInit("%s") enter', 0aH, 00H
	ORG $+6
$SG12216 DB	'AssembleInit() exit', 0aH, 00H
	ORG $+3
$SG12247 DB	'AssembleModule("%s") enter', 0aH, 00H
	ORG $+4
$SG12250 DB	'*************', 0aH, 'pass %u', 0aH, '*************', 0aH
	DB	00H
	ORG $+3
$SG12252 DB	'AssembleModule(%u): errorcnt=%u', 0aH, 00H
	ORG $+7
$SG12253 DB	'AssembleModule(%u): segm=%-8s start=%8X max_ofs=%8X writ'
	DB	'ten=%X', 0aH, 00H
$SG12254 DB	'AssembleModule(%u): PhaseError=%u, prev_written=%X, curr'
	DB	'_written=%X', 0aH, 00H
	ORG $+3
$SG12257 DB	'size shrank from %X to %X in pass %u', 0aH, 00H
	ORG $+2
$SG12258 DB	'AssembleModule(%u): prepare for next pass', 0aH, 00H
	ORG $+5
$SG12269 DB	'AssembleModule: finished, cleanup', 0aH, 00H
	ORG $+5
$SG12273 DB	'AssembleModule exit', 0aH, 00H
_DATA	ENDS
CONST	SEGMENT
formatoptions DQ FLAT:bin_init
	DW	00H
	DB	'BIN', 00H
	ORG $+2
	DQ	FLAT:omf_init
	DW	00H
	DB	'OMF', 00H
	ORG $+2
	DQ	FLAT:coff_init
	DW	0e12H
	DB	'COFF', 00H
	ORG $+1
	DQ	FLAT:elf_init
	DW	0f00H
	DB	'ELF', 00H
	ORG $+2
cst	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11773
	DQ	FLAT:$SG11774
	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11775
	DQ	FLAT:$SG11776
	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11777
	DQ	FLAT:$SG11778
	DB	04H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG11779
	DQ	FLAT:$SG11780
stt	DD	01H
	DD	02H
	DD	02H
	DD	03H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	OutputByte
PUBLIC	OutputBinBytes
PUBLIC	FillDataBytes
PUBLIC	OutputBytes
PUBLIC	AssembleModule
PUBLIC	SetMasm510
PUBLIC	close_files
PUBLIC	ConvertSectionName
PUBLIC	WritePreprocessedLine
PUBLIC	SetCurrOffset
EXTRN	__report_rangecheckfailure:PROC
EXTRN	isalpha:PROC
EXTRN	isdigit:PROC
EXTRN	isspace:PROC
EXTRN	isalnum:PROC
EXTRN	clock:PROC
EXTRN	__acrt_iob_func:PROC
EXTRN	fclose:PROC
EXTRN	fopen:PROC
EXTRN	fwrite:PROC
EXTRN	remove:PROC
EXTRN	rewind:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	_errno:PROC
EXTRN	getenv:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strchr:PROC
EXTRN	strcat:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	strncpy:PROC
EXTRN	_strupr:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	Fatal:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	ErrnoStr:PROC
EXTRN	WriteError:PROC
EXTRN	MemInit:PROC
EXTRN	MemFini:PROC
EXTRN	LclAlloc:PROC
EXTRN	GetLineNumber:PROC
EXTRN	GetFNamePart:PROC
EXTRN	GetExtPart:PROC
EXTRN	SearchFile:PROC
EXTRN	AddStringToIncludePath:PROC
EXTRN	InputInit:PROC
EXTRN	InputPassInit:PROC
EXTRN	InputFini:PROC
EXTRN	ClearSrcStack:PROC
EXTRN	set_curr_srcfile:PROC
EXTRN	GetFName:PROC
EXTRN	SymCreate:PROC
EXTRN	SymFind:PROC
EXTRN	SymInit:PROC
EXTRN	SymFini:PROC
EXTRN	SymPassInit:PROC
EXTRN	SymMakeAllSymbolsPublic:PROC
EXTRN	SymSetCmpFunc:PROC
EXTRN	sym_remove_table:PROC
EXTRN	ParseLine:PROC
EXTRN	ProcessFile:PROC
EXTRN	DisableKeyword:PROC
EXTRN	ResWordsInit:PROC
EXTRN	ResWordsFini:PROC
EXTRN	Tokenize:PROC
EXTRN	CondCheckOpen:PROC
EXTRN	CondInit:PROC
EXTRN	SegmentInit:PROC
EXTRN	SegmentFini:PROC
EXTRN	AssumeInit:PROC
EXTRN	ProcInit:PROC
EXTRN	ExprEvalInit:PROC
EXTRN	HllInit:PROC
EXTRN	HllCheckOpen:PROC
EXTRN	ContextInit:PROC
EXTRN	TypesInit:PROC
EXTRN	LabelInit:PROC
EXTRN	MacroInit:PROC
EXTRN	MacroFini:PROC
EXTRN	FreePubQueue:PROC
EXTRN	store_fixup:PROC
EXTRN	omf_set_filepos:PROC
EXTRN	omf_OutSelect:PROC
EXTRN	omf_FlushCurrSeg:PROC
EXTRN	FastpassInit:PROC
EXTRN	SkipSavedState:PROC
EXTRN	RestoreState:PROC
EXTRN	LstInit:PROC
EXTRN	LstWriteCRef:PROC
EXTRN	LstPrintf:PROC
EXTRN	LstNL:PROC
EXTRN	MsgGetEx:PROC
EXTRN	InternalError:PROC
EXTRN	LinnumInit:PROC
EXTRN	LinnumFini:PROC
EXTRN	QueueDeleteLinnum:PROC
EXTRN	SetCPU:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	RunLineQueue:PROC
EXTRN	Mangle:PROC
EXTRN	DumpInstrStats:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	_setjmp:PROC
EXTRN	Options:BYTE
EXTRN	MacroLevel:BYTE
EXTRN	SymTables:BYTE
EXTRN	LineStoreCurr:QWORD
EXTRN	StoreState:BYTE
EXTRN	UseSavedState:BYTE
EXTRN	LastCodeBufSize:DWORD
EXTRN	DefaultDir:BYTE
EXTRN	ModelToken:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$OutputByte DD imagerel $LN11
	DD	imagerel $LN11+476
	DD	imagerel $unwind$OutputByte
$pdata$OutputBinBytes DD imagerel $LN14
	DD	imagerel $LN14+543
	DD	imagerel $unwind$OutputBinBytes
$pdata$FillDataBytes DD imagerel $LN7
	DD	imagerel $LN7+66
	DD	imagerel $unwind$FillDataBytes
$pdata$OutputBytes DD imagerel $LN11
	DD	imagerel $LN11+517
	DD	imagerel $unwind$OutputBytes
$pdata$AssembleModule DD imagerel $LN31
	DD	imagerel $LN31+1198
	DD	imagerel $unwind$AssembleModule
$pdata$close_files DD imagerel $LN12
	DD	imagerel $LN12+476
	DD	imagerel $unwind$close_files
$pdata$ConvertSectionName DD imagerel $LN13
	DD	imagerel $LN13+444
	DD	imagerel $unwind$ConvertSectionName
$pdata$WritePreprocessedLine DD imagerel $LN11
	DD	imagerel $LN11+163
	DD	imagerel $unwind$WritePreprocessedLine
$pdata$SetCurrOffset DD imagerel $LN15
	DD	imagerel $LN15+296
	DD	imagerel $unwind$SetCurrOffset
$pdata$WriteModule DD imagerel WriteModule
	DD	imagerel WriteModule+676
	DD	imagerel $unwind$WriteModule
$pdata$is_valid_identifier DD imagerel is_valid_identifier
	DD	imagerel is_valid_identifier+304
	DD	imagerel $unwind$is_valid_identifier
$pdata$add_cmdline_tmacros DD imagerel add_cmdline_tmacros
	DD	imagerel add_cmdline_tmacros+475
	DD	imagerel $unwind$add_cmdline_tmacros
$pdata$add_incpaths DD imagerel add_incpaths
	DD	imagerel add_incpaths+88
	DD	imagerel $unwind$add_incpaths
$pdata$CmdlParamsInit DD imagerel CmdlParamsInit
	DD	imagerel CmdlParamsInit+104
	DD	imagerel $unwind$CmdlParamsInit
$pdata$ModulePassInit DD imagerel ModulePassInit
	DD	imagerel ModulePassInit+658
	DD	imagerel $unwind$ModulePassInit
$pdata$PassOneChecks DD imagerel PassOneChecks
	DD	imagerel PassOneChecks+1364
	DD	imagerel $unwind$PassOneChecks
$pdata$OnePass DD imagerel OnePass
	DD	imagerel OnePass+909
	DD	imagerel $unwind$OnePass
$pdata$get_module_name DD imagerel get_module_name
	DD	imagerel get_module_name+386
	DD	imagerel $unwind$get_module_name
$pdata$ModuleInit DD imagerel ModuleInit
	DD	imagerel ModuleInit+239
	DD	imagerel $unwind$ModuleInit
$pdata$ReswTableInit DD imagerel ReswTableInit
	DD	imagerel ReswTableInit+87
	DD	imagerel $unwind$ReswTableInit
$pdata$open_files DD imagerel open_files
	DD	imagerel open_files+482
	DD	imagerel $unwind$open_files
$pdata$GetExt DD imagerel GetExt
	DD	imagerel GetExt+116
	DD	imagerel $unwind$GetExt
$pdata$SetFilenames DD imagerel SetFilenames
	DD	imagerel SetFilenames+615
	DD	imagerel $unwind$SetFilenames
$pdata$AssembleInit DD imagerel AssembleInit
	DD	imagerel AssembleInit+121
	DD	imagerel $unwind$AssembleInit
$pdata$AssembleFini DD imagerel AssembleFini
	DD	imagerel AssembleFini+103
	DD	imagerel $unwind$AssembleFini
pdata	ENDS
xdata	SEGMENT
$unwind$OutputByte DD 010801H
	DD	06208H
$unwind$OutputBinBytes DD 010d01H
	DD	0620dH
$unwind$FillDataBytes DD 010c01H
	DD	0420cH
$unwind$OutputBytes DD 011201H
	DD	06212H
$unwind$AssembleModule DD 020c01H
	DD	011010cH
$unwind$close_files DD 010401H
	DD	04204H
$unwind$ConvertSectionName DD 011301H
	DD	06213H
$unwind$WritePreprocessedLine DD 010901H
	DD	06209H
$unwind$SetCurrOffset DD 011701H
	DD	04217H
$unwind$WriteModule DD 010901H
	DD	0a209H
$unwind$is_valid_identifier DD 010901H
	DD	06209H
$unwind$add_cmdline_tmacros DD 025031919H
	DD	09206230bH
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$add_incpaths DD 010401H
	DD	06204H
$unwind$CmdlParamsInit DD 010801H
	DD	06208H
$unwind$ModulePassInit DD 010401H
	DD	06204H
$unwind$PassOneChecks DD 010401H
	DD	0e204H
$unwind$OnePass DD 010401H
	DD	0c204H
$unwind$get_module_name DD 010401H
	DD	08204H
$unwind$ModuleInit DD 010401H
	DD	06204H
$unwind$ReswTableInit DD 010401H
	DD	04204H
$unwind$open_files DD 010401H
	DD	04204H
$unwind$GetExt DD 010801H
	DD	02208H
$unwind$SetFilenames DD 021e19H
	DD	02f010cH
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$AssembleInit DD 010901H
	DD	04209H
$unwind$AssembleFini DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
i$ = 32
AssembleFini PROC

; 1399 : {

	sub	rsp, 56					; 00000038H

; 1400 :     int i;
; 1401 :     SegmentFini();

	call	SegmentFini

; 1402 :     SymFini();

	call	SymFini

; 1403 :     ResWordsFini();

	call	ResWordsFini

; 1404 : #ifdef DEBUG_OUT
; 1405 :     DumpInstrStats();

	call	DumpInstrStats

; 1406 :     MacroFini();

	call	MacroFini

; 1407 : #endif
; 1408 :     FreePubQueue();

	call	FreePubQueue

; 1409 : #if FASTMEM==0
; 1410 :     FreeLibQueue();
; 1411 :     ContextFini();
; 1412 :     HllFini();
; 1413 : #endif
; 1414 :     InputFini();

	call	InputFini

; 1415 :     close_files();

	call	close_files

; 1416 : 
; 1417 : #if FASTPASS
; 1418 : #if FASTMEM==0
; 1419 :     FreeLineStore();
; 1420 : #endif
; 1421 : #endif
; 1422 : 
; 1423 :     for ( i = 0; i < NUM_FILE_TYPES; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@AssembleFi
$LN2@AssembleFi:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@AssembleFi:
	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN3@AssembleFi

; 1424 :         LclFree( CurrFName[i] );
; 1425 :         /* v2.05: make sure the pointer for ERR is cleared */
; 1426 :         CurrFName[i] = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	QWORD PTR [rcx+rax*8], 0

; 1427 :     }

	jmp	SHORT $LN2@AssembleFi
$LN3@AssembleFi:

; 1428 :     MemFini();

	call	MemFini

; 1429 :     return;
; 1430 : }

	add	rsp, 56					; 00000038H
	ret	0
AssembleFini ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
source$ = 48
AssembleInit PROC

; 1359 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1360 :     DebugMsg(("AssembleInit(\"%s\") enter\n", source ));

	mov	rdx, QWORD PTR source$[rsp]
	lea	rcx, OFFSET FLAT:$SG12215
	call	DoDebugMsg

; 1361 : 
; 1362 :     MemInit();

	call	MemInit

; 1363 :     //start_label   = NULL;
; 1364 :     //start_displ   = 0;
; 1365 :     write_to_file = FALSE;

	mov	BYTE PTR write_to_file, 0

; 1366 :     //GeneratedCode = 0;
; 1367 :     LinnumQueue.head = NULL;

	mov	QWORD PTR LinnumQueue, 0

; 1368 : 
; 1369 :     SetFilenames( source );

	mov	rcx, QWORD PTR source$[rsp]
	call	SetFilenames

; 1370 : 
; 1371 : #if FASTPASS
; 1372 :     FastpassInit();

	call	FastpassInit

; 1373 : #endif
; 1374 :     open_files();

	call	open_files

; 1375 : #if BUILD_TARGET
; 1376 :     get_os_include();
; 1377 : #endif
; 1378 :     ReswTableInit();

	call	ReswTableInit

; 1379 :     SymInit();

	call	SymInit

; 1380 :     InputInit();

	call	InputInit

; 1381 : 
; 1382 :     ModuleInit();

	call	ModuleInit

; 1383 :     CondInit();

	call	CondInit

; 1384 :     ExprEvalInit();

	call	ExprEvalInit

; 1385 :     LstInit();

	call	LstInit

; 1386 : 
; 1387 :     DebugMsg(("AssembleInit() exit\n"));

	lea	rcx, OFFSET FLAT:$SG12216
	call	DoDebugMsg

; 1388 :     return;
; 1389 : }

	add	rsp, 40					; 00000028H
	ret	0
AssembleInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
i$ = 32
ext$ = 40
fn2$1 = 48
$T2 = 56
fn$ = 64
path$ = 80
__$ArrayPad$ = 352
name$ = 384
SetFilenames PROC

; 1311 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 376				; 00000178H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1312 :     int i;
; 1313 :     const char *fn;
; 1314 :     char *ext;
; 1315 :     char path[ FILENAME_MAX ];
; 1316 : 
; 1317 :     DebugMsg(("SetFilenames(\"%s\") enter\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG12203
	call	DoDebugMsg

; 1318 : 
; 1319 :     /* set CurrFName[ASM] */
; 1320 :     CurrFName[ASM] = LclAlloc( strlen( name ) + 1 );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	inc	rax
	mov	rcx, rax
	call	LclAlloc
	mov	ecx, 8
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:ModuleInfo+128
	mov	QWORD PTR [rdx+rcx], rax

; 1321 :     strcpy( CurrFName[ASM], name );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	strcpy

; 1322 : 
; 1323 :     /* set [OBJ], [ERR], [LST] */
; 1324 :     fn = GetFNamePart( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	GetFNamePart
	mov	QWORD PTR fn$[rsp], rax

; 1325 :     for ( i = ASM+1; i < NUM_FILE_TYPES; i++ ) {

	mov	DWORD PTR i$[rsp], 1
	jmp	SHORT $LN4@SetFilenam
$LN2@SetFilenam:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SetFilenam:
	cmp	DWORD PTR i$[rsp], 4
	jge	$LN3@SetFilenam

; 1326 :         if( Options.names[i] == NULL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax*8], 0
	jne	$LN5@SetFilenam

; 1327 :             path[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 260			; 00000104H
	jae	SHORT $LN11@SetFilenam
	jmp	SHORT $LN12@SetFilenam
$LN11@SetFilenam:
	call	__report_rangecheckfailure
$LN12@SetFilenam:
	mov	rax, QWORD PTR $T2[rsp]
	mov	BYTE PTR path$[rsp+rax], 0

; 1328 :             if ( DefaultDir[i])

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN7@SetFilenam

; 1329 :                 strcpy( path, DefaultDir[i] );

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR path$[rsp]
	call	strcpy
$LN7@SetFilenam:

; 1330 :             strcat( path, fn );

	mov	rdx, QWORD PTR fn$[rsp]
	lea	rcx, QWORD PTR path$[rsp]
	call	strcat

; 1331 :             ext = GetExtPart( path );

	lea	rcx, QWORD PTR path$[rsp]
	call	GetExtPart
	mov	QWORD PTR ext$[rsp], rax

; 1332 :             *ext++  = '.';

	mov	rax, QWORD PTR ext$[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH
	mov	rax, QWORD PTR ext$[rsp]
	inc	rax
	mov	QWORD PTR ext$[rsp], rax

; 1333 :             strcpy( ext, GetExt( i ) );

	mov	ecx, DWORD PTR i$[rsp]
	call	GetExt
	mov	rdx, rax
	mov	rcx, QWORD PTR ext$[rsp]
	call	strcpy

; 1334 : 
; 1335 :         } else {

	jmp	$LN6@SetFilenam
$LN5@SetFilenam:

; 1336 :             /* filename has been set by cmdline option -Fo, -Fl or -Fr */
; 1337 :             const char *fn2;
; 1338 :             strcpy( path, Options.names[i] );

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR path$[rsp]
	call	strcpy

; 1339 :             fn2 = GetFNamePart( path );

	lea	rcx, QWORD PTR path$[rsp]
	call	GetFNamePart
	mov	QWORD PTR fn2$1[rsp], rax

; 1340 :             if( *fn2 == NULLC )

	mov	rax, QWORD PTR fn2$1[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN8@SetFilenam

; 1341 :                 strcpy( (char *)fn2, fn );

	mov	rdx, QWORD PTR fn$[rsp]
	mov	rcx, QWORD PTR fn2$1[rsp]
	call	strcpy
$LN8@SetFilenam:

; 1342 :             ext = GetExtPart( fn2 );

	mov	rcx, QWORD PTR fn2$1[rsp]
	call	GetExtPart
	mov	QWORD PTR ext$[rsp], rax

; 1343 :             if( *ext == NULLC ) {

	mov	rax, QWORD PTR ext$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN9@SetFilenam

; 1344 :                 *ext++  = '.';

	mov	rax, QWORD PTR ext$[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH
	mov	rax, QWORD PTR ext$[rsp]
	inc	rax
	mov	QWORD PTR ext$[rsp], rax

; 1345 :                 strcpy( ext, GetExt( i ) );

	mov	ecx, DWORD PTR i$[rsp]
	call	GetExt
	mov	rdx, rax
	mov	rcx, QWORD PTR ext$[rsp]
	call	strcpy
$LN9@SetFilenam:
$LN6@SetFilenam:

; 1346 :             }
; 1347 :         }
; 1348 :         DebugMsg(("SetFilenames: i=%u >%s<\n", i, path ));

	lea	r8, QWORD PTR path$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG12209
	call	DoDebugMsg

; 1349 :         CurrFName[i] = LclAlloc( strlen( path ) + 1 );

	lea	rcx, QWORD PTR path$[rsp]
	call	strlen
	inc	rax
	mov	rcx, rax
	call	LclAlloc
	movsxd	rcx, DWORD PTR i$[rsp]
	lea	rdx, OFFSET FLAT:ModuleInfo+128
	mov	QWORD PTR [rdx+rcx*8], rax

; 1350 :         strcpy( CurrFName[i], path );

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	lea	rdx, QWORD PTR path$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	strcpy

; 1351 :     }

	jmp	$LN2@SetFilenam
$LN3@SetFilenam:
$LN10@SetFilenam:

; 1352 :     return;
; 1353 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 376				; 00000178H
	ret	0
SetFilenames ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
tv64 = 0
type$ = 32
GetExt	PROC

; 1275 : {

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 1276 :     switch ( type ) {

	mov	eax, DWORD PTR type$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 1
	je	SHORT $LN4@GetExt
	cmp	DWORD PTR tv64[rsp], 2
	je	SHORT $LN9@GetExt
	cmp	DWORD PTR tv64[rsp], 3
	je	SHORT $LN10@GetExt
	jmp	SHORT $LN2@GetExt
$LN4@GetExt:

; 1277 :     case OBJ:
; 1278 : #if BIN_SUPPORT
; 1279 :         if ( Options.output_format == OFORMAT_BIN )

	cmp	DWORD PTR Options+160, 0
	jne	SHORT $LN5@GetExt

; 1280 : #if MZ_SUPPORT || PE_SUPPORT
; 1281 :             if ( Options.sub_format == SFORMAT_MZ
; 1282 : #if PE_SUPPORT
; 1283 :                 || Options.sub_format == SFORMAT_PE

	cmp	DWORD PTR Options+164, 1
	je	SHORT $LN8@GetExt
	cmp	DWORD PTR Options+164, 2
	jne	SHORT $LN6@GetExt
$LN8@GetExt:

; 1284 : #endif
; 1285 :                )
; 1286 :                 return( EXE_EXT );

	lea	rax, OFFSET FLAT:$SG12181
	jmp	SHORT $LN1@GetExt
	jmp	SHORT $LN7@GetExt
$LN6@GetExt:

; 1287 :             else
; 1288 : #endif
; 1289 :                 return( BIN_EXT );

	lea	rax, OFFSET FLAT:$SG12182
	jmp	SHORT $LN1@GetExt
$LN7@GetExt:
$LN5@GetExt:

; 1290 : #endif
; 1291 :         return( OBJ_EXT );

	lea	rax, OFFSET FLAT:$SG12183
	jmp	SHORT $LN1@GetExt
$LN9@GetExt:

; 1292 :     case LST:
; 1293 :         return( LST_EXT );

	lea	rax, OFFSET FLAT:$SG12185
	jmp	SHORT $LN1@GetExt
$LN10@GetExt:

; 1294 :     case ERR:
; 1295 :         return( ERR_EXT );

	lea	rax, OFFSET FLAT:$SG12187
	jmp	SHORT $LN1@GetExt
$LN2@GetExt:

; 1296 :     }
; 1297 :     return( NULL );

	xor	eax, eax
$LN1@GetExt:

; 1298 : }

	add	rsp, 24
	ret	0
GetExt	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
open_files PROC

; 1199 : {

	sub	rsp, 40					; 00000028H

; 1200 :     /* open ASM file */
; 1201 :     DebugMsg(("open_files() enter\n" ));

	lea	rcx, OFFSET FLAT:$SG12138
	call	DoDebugMsg

; 1202 : 
; 1203 :     //memset( CurrFile, 0, sizeof( CurrFile ) );
; 1204 :     /* CurrFile[ASM] = fopen( CurrFName[ASM], "r" ); */
; 1205 :     CurrFile[ASM] = fopen( CurrFName[ASM], "rb" );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	lea	rdx, OFFSET FLAT:$SG12139
	mov	rcx, QWORD PTR [rcx+rax]
	call	fopen
	mov	ecx, 8
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR [rdx+rcx], rax

; 1206 :     if( CurrFile[ASM] == NULL ) {

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	jne	SHORT $LN2@open_files

; 1207 :         DebugMsg(("open_files(): cannot open source file, fopen(\"%s\") failed\n", CurrFName[ASM] ));

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12141
	call	DoDebugMsg

; 1208 :         Fatal( CANNOT_OPEN_FILE, CurrFName[ASM], ErrnoStr() );

	call	ErrnoStr
	mov	ecx, 8
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:ModuleInfo+128
	mov	r8, rax
	mov	rdx, QWORD PTR [rdx+rcx]
	mov	ecx, 106				; 0000006aH
	call	Fatal
$LN2@open_files:

; 1209 :     }
; 1210 : 
; 1211 :     /* open OBJ file */
; 1212 :     if ( Options.syntax_check_only == FALSE ) {

	movzx	eax, BYTE PTR Options+188
	test	eax, eax
	jne	$LN3@open_files

; 1213 :         CurrFile[OBJ] = fopen( CurrFName[OBJ], "wb" );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	lea	rdx, OFFSET FLAT:$SG12143
	mov	rcx, QWORD PTR [rcx+rax]
	call	fopen
	mov	ecx, 8
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR [rdx+rcx], rax

; 1214 :         if( CurrFile[OBJ] == NULL ) {

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	jne	SHORT $LN4@open_files

; 1215 :             DebugMsg(("open_files(): cannot open object file, fopen(\"%s\") failed\n", CurrFName[OBJ] ));

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12145
	call	DoDebugMsg

; 1216 :             Fatal( CANNOT_OPEN_FILE, CurrFName[OBJ], ErrnoStr() );

	call	ErrnoStr
	mov	ecx, 8
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:ModuleInfo+128
	mov	r8, rax
	mov	rdx, QWORD PTR [rdx+rcx]
	mov	ecx, 106				; 0000006aH
	call	Fatal
$LN4@open_files:

; 1217 :         }
; 1218 :         DebugMsg(("open_files(): output, fopen(\"%s\") ok\n", CurrFName[OBJ] ));

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12146
	call	DoDebugMsg
$LN3@open_files:

; 1219 :     }
; 1220 : 
; 1221 :     if( Options.write_listing ) {

	movzx	eax, BYTE PTR Options+137
	test	eax, eax
	je	SHORT $LN5@open_files

; 1222 :         CurrFile[LST] = fopen( CurrFName[LST], "wb" );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	lea	rdx, OFFSET FLAT:$SG12148
	mov	rcx, QWORD PTR [rcx+rax]
	call	fopen
	mov	ecx, 8
	imul	rcx, rcx, 2
	lea	rdx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR [rdx+rcx], rax

; 1223 :         if ( CurrFile[LST] == NULL )

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	jne	SHORT $LN6@open_files

; 1224 :             Fatal( CANNOT_OPEN_FILE, CurrFName[LST], ErrnoStr() );

	call	ErrnoStr
	mov	ecx, 8
	imul	rcx, rcx, 2
	lea	rdx, OFFSET FLAT:ModuleInfo+128
	mov	r8, rax
	mov	rdx, QWORD PTR [rdx+rcx]
	mov	ecx, 106				; 0000006aH
	call	Fatal
$LN6@open_files:
$LN5@open_files:

; 1225 :     }
; 1226 :     return;
; 1227 : }

	add	rsp, 40					; 00000028H
	ret	0
open_files ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
ReswTableInit PROC

; 1175 : {

	sub	rsp, 40					; 00000028H

; 1176 :     ResWordsInit();

	call	ResWordsInit

; 1177 :     if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN2@ReswTableI

; 1178 :         /* DebugMsg(("InitAsm: disable IMAGEREL+SECTIONREL\n")); */
; 1179 :         /* for OMF, IMAGEREL and SECTIONREL are disabled */
; 1180 : #if IMAGERELSUPP
; 1181 :         DisableKeyword( T_IMAGEREL );

	mov	ecx, 233				; 000000e9H
	call	DisableKeyword

; 1182 : #endif
; 1183 : #if SECTIONRELSUPP
; 1184 :         DisableKeyword( T_SECTIONREL );

	mov	ecx, 243				; 000000f3H
	call	DisableKeyword
$LN2@ReswTableI:

; 1185 : #endif
; 1186 :     }
; 1187 : 
; 1188 :     if ( Options.strict_masm_compat == TRUE ) {

	movzx	eax, BYTE PTR Options+143
	cmp	eax, 1
	jne	SHORT $LN3@ReswTableI

; 1189 :         DebugMsg(("ReswTableInit: disable INCBIN + FASTCALL keywords\n"));

	lea	rcx, OFFSET FLAT:$SG12131
	call	DoDebugMsg

; 1190 :         DisableKeyword( T_INCBIN );

	mov	ecx, 449				; 000001c1H
	call	DisableKeyword

; 1191 :         DisableKeyword( T_FASTCALL );

	mov	ecx, 270				; 0000010eH
	call	DisableKeyword
$LN3@ReswTableI:

; 1192 :     }
; 1193 : 
; 1194 :     return;
; 1195 : }

	add	rsp, 40					; 00000028H
	ret	0
ReswTableInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
tv70 = 32
tv73 = 36
ModuleInit PROC

; 1149 : {

	sub	rsp, 56					; 00000038H

; 1150 :     ModuleInfo.sub_format = Options.sub_format;

	mov	eax, DWORD PTR Options+164
	mov	DWORD PTR ModuleInfo+372, eax

; 1151 :     ModuleInfo.fmtopt = &formatoptions[Options.output_format];

	movsxd	rax, DWORD PTR Options+160
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:formatoptions
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ModuleInfo+344, rax

; 1152 :     ModuleInfo.CommentDataInCode = (Options.output_format == OFORMAT_OMF &&

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN3@ModuleInit
	movzx	eax, BYTE PTR Options+128
	test	eax, eax
	jne	SHORT $LN3@ModuleInit
	mov	DWORD PTR tv70[rsp], 1
	jmp	SHORT $LN4@ModuleInit
$LN3@ModuleInit:
	mov	DWORD PTR tv70[rsp], 0
$LN4@ModuleInit:
	movzx	eax, BYTE PTR tv70[rsp]
	mov	BYTE PTR ModuleInfo+423, al

; 1153 :                          Options.no_comment_data_in_code_records == FALSE);
; 1154 :     ModuleInfo.g.error_count = 0;

	mov	DWORD PTR ModuleInfo, 0

; 1155 :     ModuleInfo.g.warning_count = 0;

	mov	DWORD PTR ModuleInfo+4, 0

; 1156 :     ModuleInfo.model = MODEL_NONE;

	mov	DWORD PTR ModuleInfo+360, 0

; 1157 :     /* ModuleInfo.distance = STACK_NONE; */
; 1158 :     ModuleInfo.ostype = OPSYS_DOS;

	mov	DWORD PTR ModuleInfo+368, 0

; 1159 :     ModuleInfo.emulator = (Options.floating_point == FPO_EMULATION);

	cmp	DWORD PTR Options+4, 1
	jne	SHORT $LN5@ModuleInit
	mov	DWORD PTR tv73[rsp], 1
	jmp	SHORT $LN6@ModuleInit
$LN5@ModuleInit:
	mov	DWORD PTR tv73[rsp], 0
$LN6@ModuleInit:
	mov	eax, DWORD PTR tv73[rsp]
	and	eax, 1
	shl	eax, 9
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 9
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 1160 :     //ModuleInfo.flatgrp_idx = 0;
; 1161 : 
; 1162 :     get_module_name(); /* set ModuleInfo.name */

	call	get_module_name

; 1163 : 
; 1164 :     /* v2.06: ST_PROC has been removed */
; 1165 :     //SimpleType[ST_PROC].mem_type = MT_NEAR;
; 1166 : 
; 1167 :     memset( SymTables, 0, sizeof( SymTables[0] ) * TAB_LAST );

	mov	r8d, 96					; 00000060H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:SymTables
	call	memset

; 1168 :     ModuleInfo.fmtopt->init( &ModuleInfo );

	lea	rcx, OFFSET FLAT:ModuleInfo
	mov	rax, QWORD PTR ModuleInfo+344
	call	QWORD PTR [rax]

; 1169 : 
; 1170 :     return;
; 1171 : }

	add	rsp, 56					; 00000038H
	ret	0
ModuleInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
p$ = 32
fn$1 = 40
ext$2 = 48
get_module_name PROC

; 1110 : {

	sub	rsp, 72					; 00000048H

; 1111 :     //char dummy[_MAX_EXT];
; 1112 :     char        *p;
; 1113 : 
; 1114 :     /* v2.08: prefer name given by -nm option */
; 1115 :     if ( Options.names[OPTN_MODULE_NAME] ) {

	mov	eax, 8
	imul	rax, rax, 5
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN5@get_module

; 1116 :         strncpy( ModuleInfo.name, Options.names[OPTN_MODULE_NAME], sizeof( ModuleInfo.name ) );

	mov	eax, 8
	imul	rax, rax, 5
	lea	rcx, OFFSET FLAT:Options+32
	mov	r8d, 260				; 00000104H
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:ModuleInfo+512
	call	strncpy

; 1117 :         ModuleInfo.name[ sizeof( ModuleInfo.name ) - 1] = NULLC;

	mov	eax, 1
	imul	rax, rax, 259				; 00000103H
	lea	rcx, OFFSET FLAT:ModuleInfo+512
	mov	BYTE PTR [rcx+rax], 0

; 1118 :     } else {

	jmp	SHORT $LN6@get_module
$LN5@get_module:

; 1119 :         /* v2.12: _splitpath()/_makepath() removed */
; 1120 :         const char *fn = GetFNamePart( CurrFName[ASM] );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rcx, QWORD PTR [rcx+rax]
	call	GetFNamePart
	mov	QWORD PTR fn$1[rsp], rax

; 1121 :         char *ext = GetExtPart( fn );

	mov	rcx, QWORD PTR fn$1[rsp]
	call	GetExtPart
	mov	QWORD PTR ext$2[rsp], rax

; 1122 :         memcpy( ModuleInfo.name, fn, ext - fn );

	mov	rax, QWORD PTR fn$1[rsp]
	mov	rcx, QWORD PTR ext$2[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	rdx, QWORD PTR fn$1[rsp]
	lea	rcx, OFFSET FLAT:ModuleInfo+512
	call	memcpy

; 1123 :         ModuleInfo.name[ ext - fn ] = NULLC;

	mov	rax, QWORD PTR fn$1[rsp]
	mov	rcx, QWORD PTR ext$2[rsp]
	sub	rcx, rax
	mov	rax, rcx
	lea	rcx, OFFSET FLAT:ModuleInfo+512
	mov	BYTE PTR [rcx+rax], 0
$LN6@get_module:

; 1124 :         //_splitpath( CurrFName[ASM], NULL, NULL, ModuleInfo.name, dummy );
; 1125 :     }
; 1126 : 
; 1127 :     _strupr( ModuleInfo.name );

	lea	rcx, OFFSET FLAT:ModuleInfo+512
	call	_strupr

; 1128 :     /* the module name must be a valid identifier, because it's used
; 1129 :      * as part of a segment name in certain memory models.
; 1130 :      */
; 1131 :     for( p = ModuleInfo.name; *p; ++p ) {

	lea	rax, OFFSET FLAT:ModuleInfo+512
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN4@get_module
$LN2@get_module:
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN4@get_module:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@get_module

; 1132 :         if( !( isalnum( *p ) || ( *p == '_' ) || ( *p == '$' )

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isalnum
	test	eax, eax
	jne	SHORT $LN7@get_module
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN7@get_module
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN7@get_module
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN7@get_module
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN7@get_module

; 1133 :             || ( *p == '@' ) || ( *p == '?') ) ) {
; 1134 :             /* it's not a legal character for a symbol name */
; 1135 :             *p = '_';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 95			; 0000005fH
$LN7@get_module:

; 1136 :         }
; 1137 :     }

	jmp	SHORT $LN2@get_module
$LN3@get_module:

; 1138 :     /* first character can't be a digit either */
; 1139 :     if( isdigit( ModuleInfo.name[0] ) ) {

	mov	eax, 1
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+512
	movsx	eax, BYTE PTR [rcx+rax]
	mov	ecx, eax
	call	isdigit
	test	eax, eax
	je	SHORT $LN8@get_module

; 1140 :         ModuleInfo.name[0] = '_';

	mov	eax, 1
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+512
	mov	BYTE PTR [rcx+rax], 95			; 0000005fH
$LN8@get_module:

; 1141 :     }
; 1142 : }

	add	rsp, 72					; 00000048H
	ret	0
get_module_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
tv150 = 64
tv166 = 68
dir$1 = 72
pq$2 = 80
tv75 = 88
OnePass	PROC

; 1000 : {

	sub	rsp, 104				; 00000068H

; 1001 : 
; 1002 :     InputPassInit();

	call	InputPassInit

; 1003 :     ModulePassInit();

	call	ModulePassInit

; 1004 :     SymPassInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	SymPassInit

; 1005 :     LabelInit();

	call	LabelInit

; 1006 :     SegmentInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	SegmentInit

; 1007 :     ContextInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	ContextInit

; 1008 :     ProcInit();

	call	ProcInit

; 1009 :     TypesInit();

	call	TypesInit

; 1010 :     HllInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	HllInit

; 1011 :     MacroInit( Parse_Pass ); /* insert predefined macros */

	mov	ecx, DWORD PTR Parse_Pass
	call	MacroInit

; 1012 :     AssumeInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	AssumeInit

; 1013 :     CmdlParamsInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	CmdlParamsInit

; 1014 : 
; 1015 :     ModuleInfo.EndDirFound = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	btr	eax, 16
	mov	DWORD PTR ModuleInfo+408, eax

; 1016 :     ModuleInfo.PhaseError = FALSE;

	mov	BYTE PTR ModuleInfo+422, 0

; 1017 :     //Modend = FALSE;
; 1018 :     /* LineNumber = 0; */
; 1019 :     LinnumInit();

	call	LinnumInit

; 1020 : 
; 1021 : #ifdef DEBUG_OUT
; 1022 :     if ( Parse_Pass > PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jbe	$LN10@OnePass

; 1023 :         DebugMsg(("OnePass(%u) segments (current=%s):\n", Parse_Pass + 1, CurrSeg ? CurrSeg->sym.name : "NULL" ));

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN18@OnePass
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv75[rsp], rax
	jmp	SHORT $LN19@OnePass
$LN18@OnePass:
	lea	rax, OFFSET FLAT:$SG12099
	mov	QWORD PTR tv75[rsp], rax
$LN19@OnePass:
	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	r8, QWORD PTR tv75[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12100
	call	DoDebugMsg

; 1024 :         {
; 1025 :             struct dsym *dir;
; 1026 :             for( dir = SymTables[TAB_SEG].head; dir; dir = dir->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR dir$1[rsp], rax
	jmp	SHORT $LN4@OnePass
$LN2@OnePass:
	mov	rax, QWORD PTR dir$1[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR dir$1[rsp], rax
$LN4@OnePass:
	cmp	QWORD PTR dir$1[rsp], 0
	je	SHORT $LN3@OnePass

; 1027 :                 DebugMsg(("OnePass(%u): segm=%-8s typ=%X start=%8X max_ofs=%8X\n", Parse_Pass + 1,

	mov	rax, QWORD PTR dir$1[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR dir$1[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	edx, DWORD PTR Parse_Pass
	inc	edx
	mov	r8, QWORD PTR dir$1[rsp]
	mov	r8d, DWORD PTR [r8+56]
	mov	DWORD PTR [rsp+40], r8d
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR [rcx+72]
	mov	rax, QWORD PTR dir$1[rsp]
	mov	r8, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12101
	call	DoDebugMsg

; 1028 :                           dir->sym.name, dir->e.seginfo->segtype, dir->e.seginfo->start_loc, dir->sym.max_offset ));
; 1029 :             }

	jmp	SHORT $LN2@OnePass
$LN3@OnePass:
$LN10@OnePass:

; 1030 :         }
; 1031 :     }
; 1032 : #endif
; 1033 :     /* the functions above might have written something to the line queue */
; 1034 :     if ( is_linequeue_populated() )

	cmp	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN11@OnePass

; 1035 :         RunLineQueue();

	call	RunLineQueue
$LN11@OnePass:

; 1036 : #if FASTPASS
; 1037 :     StoreState = FALSE;

	mov	BYTE PTR StoreState, 0

; 1038 :     if ( Parse_Pass > PASS_1 && UseSavedState == TRUE ) {

	cmp	DWORD PTR Parse_Pass, 0
	jbe	$LN12@OnePass
	movzx	eax, BYTE PTR UseSavedState
	cmp	eax, 1
	jne	$LN12@OnePass

; 1039 :         LineStoreCurr = RestoreState();

	call	RestoreState
	mov	QWORD PTR LineStoreCurr, rax
$LN5@OnePass:

; 1040 :         while ( LineStoreCurr && ModuleInfo.EndDirFound == FALSE ) {

	cmp	QWORD PTR LineStoreCurr, 0
	je	$LN6@OnePass
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 16
	and	eax, 1
	test	eax, eax
	jne	$LN6@OnePass

; 1041 :             /* the source line is modified in Tokenize() if it contains a comment! */
; 1042 : #if USELSLINE==0
; 1043 :             strcpy( CurrSource, LineStoreCurr->line );
; 1044 : #endif
; 1045 :             set_curr_srcfile( LineStoreCurr->srcfile, LineStoreCurr->lineno );

	mov	rax, QWORD PTR LineStoreCurr
	mov	eax, DWORD PTR [rax+8]
	and	eax, 1048575				; 000fffffH
	mov	rcx, QWORD PTR LineStoreCurr
	mov	ecx, DWORD PTR [rcx+8]
	shr	ecx, 20
	and	ecx, 4095				; 00000fffH
	mov	edx, eax
	call	set_curr_srcfile

; 1046 :             /* v2.06: list flags now initialized on the top level */
; 1047 :             ModuleInfo.line_flags = 0;

	mov	BYTE PTR ModuleInfo+398, 0

; 1048 :             MacroLevel = ( LineStoreCurr->srcfile == 0xFFF ? 1 : 0 );

	mov	rax, QWORD PTR LineStoreCurr
	mov	eax, DWORD PTR [rax+8]
	shr	eax, 20
	and	eax, 4095				; 00000fffH
	cmp	eax, 4095				; 00000fffH
	jne	SHORT $LN20@OnePass
	mov	DWORD PTR tv150[rsp], 1
	jmp	SHORT $LN21@OnePass
$LN20@OnePass:
	mov	DWORD PTR tv150[rsp], 0
$LN21@OnePass:
	movzx	eax, BYTE PTR tv150[rsp]
	mov	BYTE PTR MacroLevel, al

; 1049 :             DebugMsg1(("OnePass(%u) cur/nxt=%X/%X src=%X.%u mlvl=%u: >%s<\n", Parse_Pass+1, LineStoreCurr, LineStoreCurr->next, LineStoreCurr->srcfile, LineStoreCurr->lineno, MacroLevel, LineStoreCurr->line ));

	mov	rax, QWORD PTR LineStoreCurr
	add	rax, 16
	movzx	ecx, BYTE PTR MacroLevel
	mov	rdx, QWORD PTR LineStoreCurr
	mov	edx, DWORD PTR [rdx+8]
	and	edx, 1048575				; 000fffffH
	mov	r8, QWORD PTR LineStoreCurr
	mov	r8d, DWORD PTR [r8+8]
	shr	r8d, 20
	and	r8d, 4095				; 00000fffH
	mov	r9d, DWORD PTR Parse_Pass
	inc	r9d
	mov	DWORD PTR tv166[rsp], r9d
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], ecx
	mov	DWORD PTR [rsp+40], edx
	mov	DWORD PTR [rsp+32], r8d
	mov	rax, QWORD PTR LineStoreCurr
	mov	r9, QWORD PTR [rax]
	mov	r8, QWORD PTR LineStoreCurr
	mov	eax, DWORD PTR tv166[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12105
	call	DoDebugMsg1

; 1050 :             ModuleInfo.CurrComment = NULL; /* v2.08: added (var is never reset because GetTextLine() isn't called) */

	mov	QWORD PTR ModuleInfo+472, 0

; 1051 : #if USELSLINE
; 1052 :             if ( Token_Count = Tokenize( LineStoreCurr->line, 0, ModuleInfo.tokenarray, TOK_DEFAULT ) )

	mov	rax, QWORD PTR LineStoreCurr
	add	rax, 16
	xor	r9d, r9d
	mov	r8, QWORD PTR ModuleInfo+480
	xor	edx, edx
	mov	rcx, rax
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax
	cmp	DWORD PTR ModuleInfo+496, 0
	je	SHORT $LN14@OnePass

; 1053 : #else
; 1054 :             if ( Token_Count = Tokenize( CurrSource, 0, ModuleInfo.tokenarray, TOK_DEFAULT ) )
; 1055 : #endif
; 1056 :                 ParseLine( ModuleInfo.tokenarray );

	mov	rcx, QWORD PTR ModuleInfo+480
	call	ParseLine
$LN14@OnePass:

; 1057 :             LineStoreCurr = LineStoreCurr->next;

	mov	rax, QWORD PTR LineStoreCurr
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR LineStoreCurr, rax

; 1058 :         }

	jmp	$LN5@OnePass
$LN6@OnePass:

; 1059 :     } else

	jmp	SHORT $LN13@OnePass
$LN12@OnePass:

; 1060 : #endif
; 1061 :     {
; 1062 :         struct qitem *pq;
; 1063 :         /* v2.11: handle -Fi files here ( previously in CmdlParamsInit ) */
; 1064 :         for ( pq = Options.queues[OPTQ_FINCLUDE]; pq; pq = pq->next ) {

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:Options+104
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR pq$2[rsp], rax
	jmp	SHORT $LN9@OnePass
$LN7@OnePass:
	mov	rax, QWORD PTR pq$2[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pq$2[rsp], rax
$LN9@OnePass:
	cmp	QWORD PTR pq$2[rsp], 0
	je	SHORT $LN8@OnePass

; 1065 :             DebugMsg(("OnePass: force include of file: %s\n", pq->value ));

	mov	rax, QWORD PTR pq$2[rsp]
	add	rax, 8
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12107
	call	DoDebugMsg

; 1066 :             if ( SearchFile( pq->value, TRUE ) )

	mov	rax, QWORD PTR pq$2[rsp]
	add	rax, 8
	mov	dl, 1
	mov	rcx, rax
	call	SearchFile
	test	rax, rax
	je	SHORT $LN15@OnePass

; 1067 :                 ProcessFile( ModuleInfo.tokenarray );

	mov	rcx, QWORD PTR ModuleInfo+480
	call	ProcessFile
$LN15@OnePass:

; 1068 :         }

	jmp	SHORT $LN7@OnePass
$LN8@OnePass:

; 1069 :         ProcessFile( ModuleInfo.tokenarray ); /* process the main source file */

	mov	rcx, QWORD PTR ModuleInfo+480
	call	ProcessFile
$LN13@OnePass:

; 1070 :     }
; 1071 : 
; 1072 :     LinnumFini();

	call	LinnumFini

; 1073 : 
; 1074 :     if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN16@OnePass

; 1075 :         PassOneChecks();

	call	PassOneChecks
$LN16@OnePass:

; 1076 : 
; 1077 :     ClearSrcStack();

	call	ClearSrcStack

; 1078 : 
; 1079 :     return( 1 );

	mov	eax, 1

; 1080 : }

	add	rsp, 104				; 00000068H
	ret	0
OnePass	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
curr$ = 32
q$ = 40
cntUnusedExt$ = 48
j$1 = 52
i$2 = 56
sym$3 = 64
sym$4 = 72
qn$ = 80
fix$5 = 88
next$ = 96
PassOneChecks PROC

; 774  : {

	sub	rsp, 120				; 00000078H

; 775  :     struct dsym *curr;
; 776  :     struct dsym *next;
; 777  :     struct qnode *q;
; 778  :     struct qnode *qn;
; 779  : #ifdef DEBUG_OUT
; 780  :     int cntUnusedExt = 0;

	mov	DWORD PTR cntUnusedExt$[rsp], 0

; 781  : #endif
; 782  : 
; 783  :     /* check for open structures and segments has been done inside the
; 784  :      * END directive handling already
; 785  :      * v2.10: now done for PROCs as well, since procedures
; 786  :      * must be closed BEFORE segments are to be closed.
; 787  :      */
; 788  :     //ProcCheckOpen();
; 789  :     HllCheckOpen();

	call	HllCheckOpen

; 790  :     CondCheckOpen();

	call	CondCheckOpen

; 791  : 
; 792  :     if( ModuleInfo.EndDirFound == FALSE )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 16
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN29@PassOneChe

; 793  :         EmitError( END_DIRECTIVE_REQUIRED );

	mov	ecx, 99					; 00000063H
	call	EmitError
$LN29@PassOneChe:

; 794  : 
; 795  : #ifdef DEBUG_OUT
; 796  :     for ( curr = SymTables[TAB_UNDEF].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@PassOneChe
$LN2@PassOneChe:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@PassOneChe:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@PassOneChe

; 797  :         DebugMsg(("PassOneChecks: undefined symbol %s\n", curr->sym.name ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12050
	call	DoDebugMsg

; 798  :     }

	jmp	SHORT $LN2@PassOneChe
$LN3@PassOneChe:

; 799  : #endif
; 800  :     /* v2.04: check the publics queue.
; 801  :      * - only internal symbols can be public.
; 802  :      * - weak external symbols are filtered ( since v2.11 )
; 803  :      * - anything else is an error
; 804  :      * v2.11: moved here ( from inside the "#if FASTPASS"-block )
; 805  :      * because the loop will now filter weak externals [ this
; 806  :      * was previously done in GetPublicSymbols() ]
; 807  :      */
; 808  :     for( q = ModuleInfo.g.PubQueue.head, qn = (struct qnode *)&ModuleInfo.g.PubQueue ; q; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo+16
	mov	QWORD PTR q$[rsp], rax
	lea	rax, OFFSET FLAT:ModuleInfo+16
	mov	QWORD PTR qn$[rsp], rax
	jmp	SHORT $LN7@PassOneChe
$LN5@PassOneChe:
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$[rsp], rax
$LN7@PassOneChe:
	cmp	QWORD PTR q$[rsp], 0
	je	$LN6@PassOneChe

; 809  : 
; 810  :         if ( q->sym->state == SYM_INTERNAL )

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN30@PassOneChe

; 811  :             qn = q;

	mov	rax, QWORD PTR q$[rsp]
	mov	QWORD PTR qn$[rsp], rax
	jmp	$LN31@PassOneChe
$LN30@PassOneChe:

; 812  :         else if ( q->sym->state == SYM_EXTERNAL && q->sym->weak == TRUE ) {

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN32@PassOneChe
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN32@PassOneChe

; 813  :             DebugMsg(("PassOneChecks: public for weak external skipped: %s\n", q->sym->name ));

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12055
	call	DoDebugMsg

; 814  :             qn->next = q->next;

	mov	rax, QWORD PTR qn$[rsp]
	mov	rcx, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 815  :             LclFree( q );
; 816  :             q = qn;

	mov	rax, QWORD PTR qn$[rsp]
	mov	QWORD PTR q$[rsp], rax

; 817  :         } else {

	jmp	SHORT $LN33@PassOneChe
$LN32@PassOneChe:

; 818  :             DebugMsg(("PassOneChecks: invalid public attribute for %s [state=%u weak=%u]\n", q->sym->name, q->sym->state, q->sym->weak ));

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	mov	rcx, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rdx, QWORD PTR q$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	r9d, eax
	mov	r8d, DWORD PTR [rcx+32]
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG12056
	call	DoDebugMsg

; 819  : #if FASTPASS
; 820  :             SkipSavedState();

	call	SkipSavedState

; 821  : #endif
; 822  :             break;

	jmp	SHORT $LN6@PassOneChe
$LN33@PassOneChe:
$LN31@PassOneChe:

; 823  :         }
; 824  :     }

	jmp	$LN5@PassOneChe
$LN6@PassOneChe:

; 825  : #if FASTPASS
; 826  :     if ( SymTables[TAB_UNDEF].head ) {

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables

; 827  :         /* to force a full second pass in case of missing symbols,
; 828  :          * activate the next line. It was implemented to have proper
; 829  :          * error displays if a forward reference wasn't found.
; 830  :          * However, v1.95 final won't need this anymore, because both
; 831  :          * filename + lineno for every line is known now in pass 2.
; 832  :          */
; 833  :         /* SkipSavedState(); */
; 834  :     }
; 835  : 
; 836  :     /* check if there's an undefined segment reference.
; 837  :      * This segment was an argument to a group definition then.
; 838  :      * Just do a full second pass, the GROUP directive will report
; 839  :      * the error.
; 840  :      */
; 841  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN10@PassOneChe
$LN8@PassOneChe:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN10@PassOneChe:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN9@PassOneChe

; 842  :         if( curr->sym.segment == NULL ) {

	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN35@PassOneChe

; 843  :             DebugMsg(("PassOneChecks: undefined segment %s\n", curr->sym.name ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12059
	call	DoDebugMsg

; 844  :             SkipSavedState();

	call	SkipSavedState

; 845  :             break;

	jmp	SHORT $LN9@PassOneChe
$LN35@PassOneChe:

; 846  :         }
; 847  :     }

	jmp	SHORT $LN8@PassOneChe
$LN9@PassOneChe:

; 848  : #if COFF_SUPPORT
; 849  :     /* if there's an item in the safeseh list which is not an
; 850  :      * internal proc, make a full second pass to emit a proper
; 851  :      * error msg at the .SAFESEH directive
; 852  :      */
; 853  :     for ( q = ModuleInfo.g.SafeSEHQueue.head; q; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo+48
	mov	QWORD PTR q$[rsp], rax
	jmp	SHORT $LN13@PassOneChe
$LN11@PassOneChe:
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$[rsp], rax
$LN13@PassOneChe:
	cmp	QWORD PTR q$[rsp], 0
	je	SHORT $LN12@PassOneChe

; 854  :         if ( q->sym->state != SYM_INTERNAL || q->sym->isproc == FALSE ) {

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN37@PassOneChe
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN36@PassOneChe
$LN37@PassOneChe:

; 855  :             SkipSavedState();

	call	SkipSavedState

; 856  :             break;

	jmp	SHORT $LN12@PassOneChe
$LN36@PassOneChe:

; 857  :         }
; 858  :     }

	jmp	SHORT $LN11@PassOneChe
$LN12@PassOneChe:

; 859  : #endif
; 860  : 
; 861  :     /* scan ALIASes for COFF/ELF */
; 862  : 
; 863  : #if COFF_SUPPORT || ELF_SUPPORT
; 864  :     if ( Options.output_format == OFORMAT_COFF
; 865  : #if ELF_SUPPORT
; 866  :         || Options.output_format == OFORMAT_ELF

	cmp	DWORD PTR Options+160, 2
	je	SHORT $LN39@PassOneChe
	cmp	DWORD PTR Options+160, 3
	jne	$LN38@PassOneChe
$LN39@PassOneChe:

; 867  : #endif
; 868  :        ) {
; 869  :         for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 5
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN16@PassOneChe
$LN14@PassOneChe:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN16@PassOneChe:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN15@PassOneChe

; 870  :             struct asym *sym;
; 871  :             sym = curr->sym.substitute;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR sym$3[rsp], rax

; 872  :             /* check if symbol is external or public */
; 873  :             if ( sym == NULL ||

	cmp	QWORD PTR sym$3[rsp], 0
	je	SHORT $LN41@PassOneChe
	mov	rax, QWORD PTR sym$3[rsp]
	cmp	DWORD PTR [rax+32], 2
	je	SHORT $LN40@PassOneChe
	mov	rax, QWORD PTR sym$3[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN42@PassOneChe
	mov	rax, QWORD PTR sym$3[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN40@PassOneChe
$LN42@PassOneChe:
$LN41@PassOneChe:

; 874  :                 ( sym->state != SYM_EXTERNAL &&
; 875  :                  ( sym->state != SYM_INTERNAL || sym->ispublic == FALSE ))) {
; 876  :                 SkipSavedState();

	call	SkipSavedState

; 877  :                 break;

	jmp	SHORT $LN15@PassOneChe
$LN40@PassOneChe:

; 878  :             }
; 879  :             /* make sure it becomes a strong external */
; 880  :             if ( sym->state == SYM_EXTERNAL )

	mov	rax, QWORD PTR sym$3[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN43@PassOneChe

; 881  :                 sym->used = TRUE;

	mov	rax, QWORD PTR sym$3[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 1
	mov	rcx, QWORD PTR sym$3[rsp]
	mov	BYTE PTR [rcx+40], al
$LN43@PassOneChe:

; 882  :         }

	jmp	SHORT $LN14@PassOneChe
$LN15@PassOneChe:
$LN38@PassOneChe:

; 883  :     }
; 884  : #endif
; 885  : 
; 886  : #endif /* FASTPASS */
; 887  : 
; 888  :     /* scan the EXTERN/EXTERNDEF items */
; 889  : 
; 890  :     for( curr = SymTables[TAB_EXT].head ; curr; curr = next ) {

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN19@PassOneChe
$LN17@PassOneChe:
	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR curr$[rsp], rax
$LN19@PassOneChe:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN18@PassOneChe

; 891  :         next = curr->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR next$[rsp], rax

; 892  :         /* v2.01: externdefs which have been "used" become "strong" */
; 893  :         if ( curr->sym.used )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN44@PassOneChe

; 894  :             curr->sym.weak = FALSE;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	and	al, 247					; 000000f7H
	mov	rcx, QWORD PTR curr$[rsp]
	mov	BYTE PTR [rcx+47], al
$LN44@PassOneChe:

; 895  :         /* remove unused EXTERNDEF/PROTO items from queue. */
; 896  :         if ( curr->sym.weak == TRUE
; 897  : #if DLLIMPORT
; 898  :             && curr->sym.iat_used == FALSE

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN45@PassOneChe
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN45@PassOneChe

; 899  : #endif
; 900  :            ) {
; 901  :             sym_remove_table( &SymTables[TAB_EXT], curr );

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR curr$[rsp]
	mov	rcx, rax
	call	sym_remove_table

; 902  : #ifdef DEBUG_OUT
; 903  :             cntUnusedExt++;

	mov	eax, DWORD PTR cntUnusedExt$[rsp]
	inc	eax
	mov	DWORD PTR cntUnusedExt$[rsp], eax

; 904  : #endif
; 905  :             continue;

	jmp	$LN17@PassOneChe
$LN45@PassOneChe:

; 906  :         }
; 907  : 
; 908  : #if FASTMEM==0
; 909  :         /* v2.05: clear fixup list (used for backpatching in pass one) */
; 910  :         if ( curr->sym.bp_fixup ) {
; 911  :             struct fixup *c;
; 912  :             struct fixup *n;
; 913  :             for( c = curr->sym.bp_fixup ; c; ) {
; 914  :                 n = c->nextbp;
; 915  :                 LclFree( c );
; 916  :                 c = n;
; 917  :             }
; 918  :             curr->sym.bp_fixup = NULL;
; 919  :         }
; 920  : #endif
; 921  : 
; 922  :         if ( curr->sym.iscomm == TRUE )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN46@PassOneChe

; 923  :             continue;

	jmp	$LN17@PassOneChe
$LN46@PassOneChe:

; 924  :         /* optional alternate symbol must be INTERNAL or EXTERNAL.
; 925  :          * COFF ( and ELF? ) also wants internal symbols to be public
; 926  :          * ( which is reasonable, since the linker won't know private
; 927  :          * symbols and hence will search for a symbol of that name
; 928  :          * "elsewhere" ).
; 929  :          */
; 930  : #if FASTPASS
; 931  :         if ( curr->sym.altname ) {

	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+64], 0
	je	SHORT $LN47@PassOneChe

; 932  :             if ( curr->sym.altname->state == SYM_INTERNAL ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+64]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN48@PassOneChe

; 933  : #if COFF_SUPPORT || ELF_SUPPORT
; 934  :                 /* for COFF/ELF, the altname must be public or external */
; 935  :                 if ( curr->sym.altname->ispublic == FALSE &&

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+64]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN50@PassOneChe
	cmp	DWORD PTR Options+160, 2
	je	SHORT $LN51@PassOneChe
	cmp	DWORD PTR Options+160, 3
	jne	SHORT $LN50@PassOneChe
$LN51@PassOneChe:

; 936  :                     ( Options.output_format == OFORMAT_COFF
; 937  : #if ELF_SUPPORT
; 938  :                      || Options.output_format == OFORMAT_ELF
; 939  : #endif
; 940  :                     ) ) {
; 941  :                     SkipSavedState();

	call	SkipSavedState
$LN50@PassOneChe:

; 942  :                 }

	jmp	SHORT $LN49@PassOneChe
$LN48@PassOneChe:

; 943  : #endif
; 944  :             } else if ( curr->sym.altname->state != SYM_EXTERNAL ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+64]
	cmp	DWORD PTR [rax+32], 2
	je	SHORT $LN52@PassOneChe

; 945  :                 /* do not use saved state, scan full source in second pass */
; 946  :                 SkipSavedState();

	call	SkipSavedState
$LN52@PassOneChe:
$LN49@PassOneChe:
$LN47@PassOneChe:

; 947  :             }
; 948  :         }
; 949  : #endif
; 950  :     }

	jmp	$LN17@PassOneChe
$LN18@PassOneChe:

; 951  : 
; 952  : #ifdef DEBUG_OUT
; 953  :     DebugMsg(("PassOneChecks: removed unused externals: %u\n", cntUnusedExt ));

	mov	edx, DWORD PTR cntUnusedExt$[rsp]
	lea	rcx, OFFSET FLAT:$SG12077
	call	DoDebugMsg

; 954  :     DebugMsg(("PassOneChecks: forward references:\n"));

	lea	rcx, OFFSET FLAT:$SG12078
	call	DoDebugMsg

; 955  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN22@PassOneChe
$LN20@PassOneChe:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN22@PassOneChe:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN21@PassOneChe

; 956  :         int i;
; 957  :         int j;
; 958  :         struct asym * sym;
; 959  :         struct fixup * fix;
; 960  :         for ( i = 0, j = 0, sym = curr->e.seginfo->label_list; sym; sym = (struct asym *)((struct dsym *)sym)->next ) {

	mov	DWORD PTR i$2[rsp], 0
	mov	DWORD PTR j$1[rsp], 0
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR sym$4[rsp], rax
	jmp	SHORT $LN25@PassOneChe
$LN23@PassOneChe:
	mov	rax, QWORD PTR sym$4[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR sym$4[rsp], rax
$LN25@PassOneChe:
	cmp	QWORD PTR sym$4[rsp], 0
	je	SHORT $LN24@PassOneChe

; 961  :             i++;

	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax

; 962  :             for ( fix = sym->bp_fixup; fix ; fix = fix->nextbp, j++ );

	mov	rax, QWORD PTR sym$4[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR fix$5[rsp], rax
	jmp	SHORT $LN28@PassOneChe
$LN26@PassOneChe:
	mov	rax, QWORD PTR fix$5[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR fix$5[rsp], rax
	mov	eax, DWORD PTR j$1[rsp]
	inc	eax
	mov	DWORD PTR j$1[rsp], eax
$LN28@PassOneChe:
	cmp	QWORD PTR fix$5[rsp], 0
	je	SHORT $LN27@PassOneChe
	jmp	SHORT $LN26@PassOneChe
$LN27@PassOneChe:

; 963  :         }

	jmp	SHORT $LN23@PassOneChe
$LN24@PassOneChe:

; 964  :         DebugMsg(("PassOneChecks: segm=%s, labels=%u forward refs=%u\n", curr->sym.name, i, j));

	mov	r9d, DWORD PTR j$1[rsp]
	mov	r8d, DWORD PTR i$2[rsp]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12079
	call	DoDebugMsg

; 965  :     }

	jmp	$LN20@PassOneChe
$LN21@PassOneChe:

; 966  : #endif
; 967  : 
; 968  :     if ( ModuleInfo.g.error_count == 0 ) {

	cmp	DWORD PTR ModuleInfo, 0
	jne	SHORT $LN53@PassOneChe

; 969  : 
; 970  :         /* make all symbols of type SYM_INTERNAL, which aren't
; 971  :          a constant, public.  */
; 972  :         if ( Options.all_symbols_public )

	movzx	eax, BYTE PTR Options+154
	test	eax, eax
	je	SHORT $LN54@PassOneChe

; 973  :             SymMakeAllSymbolsPublic();

	call	SymMakeAllSymbolsPublic
$LN54@PassOneChe:

; 974  : 
; 975  :         if ( Options.syntax_check_only == FALSE )

	movzx	eax, BYTE PTR Options+188
	test	eax, eax
	jne	SHORT $LN55@PassOneChe

; 976  :             write_to_file = TRUE;

	mov	BYTE PTR write_to_file, 1
$LN55@PassOneChe:

; 977  : 
; 978  :         if ( ModuleInfo.g.Pass1Checks )

	cmp	QWORD PTR ModuleInfo+304, 0
	je	SHORT $LN56@PassOneChe

; 979  :             ModuleInfo.g.Pass1Checks( &ModuleInfo );

	lea	rcx, OFFSET FLAT:ModuleInfo
	call	QWORD PTR ModuleInfo+304
$LN56@PassOneChe:
$LN53@PassOneChe:

; 980  :     }
; 981  : 
; 982  : 
; 983  :     return;
; 984  : }

	add	rsp, 120				; 00000078H
	ret	0
PassOneChecks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
cpu$ = 32
model$ = 36
curr$ = 40
ModulePassInit PROC

; 641  : {

	sub	rsp, 56					; 00000038H

; 642  :     enum cpu_info cpu = Options.cpu;

	mov	eax, DWORD PTR Options+180
	mov	DWORD PTR cpu$[rsp], eax

; 643  :     enum model_type model = Options.model;

	mov	eax, DWORD PTR Options+176
	mov	DWORD PTR model$[rsp], eax

; 644  : #if DLLIMPORT
; 645  :     struct dsym *curr;
; 646  : #endif
; 647  : 
; 648  :     DebugMsg(( "ModulePassInit() enter\n" ));

	lea	rcx, OFFSET FLAT:$SG11992
	call	DoDebugMsg

; 649  :     /* set default values not affected by the masm 5.1 compat switch */
; 650  :     ModuleInfo.procs_private = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -5					; fffffffbH
	mov	DWORD PTR ModuleInfo+408, eax

; 651  :     ModuleInfo.procs_export = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -9					; fffffff7H
	mov	DWORD PTR ModuleInfo+408, eax

; 652  :     ModuleInfo.offsettype = OT_GROUP;

	mov	DWORD PTR ModuleInfo+384, 0

; 653  :     ModuleInfo.scoped = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 7
	mov	DWORD PTR ModuleInfo+408, eax

; 654  : 
; 655  : 
; 656  : #if FASTPASS
; 657  :     /* v2.03: don't generate the code if fastpass is active */
; 658  :     /* v2.08: query UseSavedState instead of StoreState */
; 659  :     //if ( StoreState == FALSE ) {
; 660  :     if ( UseSavedState == FALSE ) {

	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	jne	$LN5@ModulePass

; 661  : #endif
; 662  :         ModuleInfo.langtype = Options.langtype;

	mov	eax, DWORD PTR Options+172
	mov	DWORD PTR ModuleInfo+364, eax

; 663  :         ModuleInfo.fctype = Options.fctype;

	mov	eax, DWORD PTR Options+184
	mov	DWORD PTR ModuleInfo+376, eax

; 664  : 
; 665  : 		#if AMD64_SUPPORT
; 666  : 		if (Options.output_format == OFORMAT_ELF)

	cmp	DWORD PTR Options+160, 3
	jne	SHORT $LN6@ModulePass

; 667  : 		{
; 668  : 			ModuleInfo.fctype = FCT_WIN64;

	mov	DWORD PTR ModuleInfo+376, 2

; 669  : 			Options.fctype = FCT_WIN64;

	mov	DWORD PTR Options+184, 2
$LN6@ModulePass:

; 670  : 		}
; 671  : 		#endif /* John Hankinson 2016-02-10 force elf64 to use win64 abi */
; 672  : 
; 673  : #if AMD64_SUPPORT
; 674  :         if ( ModuleInfo.sub_format == SFORMAT_64BIT ) {

	cmp	DWORD PTR ModuleInfo+372, 3
	jne	SHORT $LN7@ModulePass

; 675  :             /* v2.06: force cpu to be at least P_64, without side effect to Options.cpu */
; 676  :             if ( ( cpu &  P_CPU_MASK ) < P_64 ) /* enforce cpu to be 64-bit */

	mov	eax, DWORD PTR cpu$[rsp]
	and	eax, 240				; 000000f0H
	cmp	eax, 112				; 00000070H
	jge	SHORT $LN9@ModulePass

; 677  :                 cpu = P_64;

	mov	DWORD PTR cpu$[rsp], 112		; 00000070H
$LN9@ModulePass:

; 678  :             /* ignore -m switch for 64-bit formats.
; 679  :              * there's no other model than FLAT possible.
; 680  :              */
; 681  :             model = MODEL_FLAT;

	mov	DWORD PTR model$[rsp], 7

; 682  :             if ( ModuleInfo.langtype == LANG_NONE && Options.output_format == OFORMAT_COFF )

	cmp	DWORD PTR ModuleInfo+364, 0
	jne	SHORT $LN10@ModulePass
	cmp	DWORD PTR Options+160, 2
	jne	SHORT $LN10@ModulePass

; 683  :                 ModuleInfo.langtype = LANG_FASTCALL;

	mov	DWORD PTR ModuleInfo+364, 7
$LN10@ModulePass:

; 684  :         } else

	jmp	SHORT $LN8@ModulePass
$LN7@ModulePass:

; 685  : #endif
; 686  :             /* if model FLAT is to be set, ensure that cpu is compat. */
; 687  :             if ( model == MODEL_FLAT && ( cpu & P_CPU_MASK ) < P_386 ) /* cpu < 386? */

	cmp	DWORD PTR model$[rsp], 7
	jne	SHORT $LN11@ModulePass
	mov	eax, DWORD PTR cpu$[rsp]
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jge	SHORT $LN11@ModulePass

; 688  :                 cpu = P_386;

	mov	DWORD PTR cpu$[rsp], 48			; 00000030H
$LN11@ModulePass:
$LN8@ModulePass:

; 689  : 
; 690  :         SetCPU( cpu );

	mov	ecx, DWORD PTR cpu$[rsp]
	call	SetCPU

; 691  :         /* table ModelToken starts with MODEL_TINY, which is index 1" */
; 692  :         if ( model != MODEL_NONE )

	cmp	DWORD PTR model$[rsp], 0
	je	SHORT $LN12@ModulePass

; 693  :             AddLineQueueX( "%r %s", T_DOT_MODEL, ModelToken[model - 1] );

	mov	eax, DWORD PTR model$[rsp]
	dec	eax
	cdqe
	lea	rcx, OFFSET FLAT:ModelToken
	mov	r8, QWORD PTR [rcx+rax*8]
	mov	edx, 347				; 0000015bH
	lea	rcx, OFFSET FLAT:$SG12001
	call	AddLineQueueX
$LN12@ModulePass:
$LN5@ModulePass:

; 694  : 
; 695  : #if FASTPASS
; 696  :     }
; 697  : #endif
; 698  : 
; 699  :     SetMasm510( Options.masm51_compat );

	movzx	ecx, BYTE PTR Options+142
	call	SetMasm510

; 700  :     ModuleInfo.defOfssize = USE16;

	mov	BYTE PTR ModuleInfo+405, 0

; 701  :     ModuleInfo.ljmp     = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	or	eax, 32					; 00000020H
	mov	DWORD PTR ModuleInfo+408, eax

; 702  : 
; 703  :     ModuleInfo.list   = Options.write_listing;

	movzx	eax, BYTE PTR Options+137
	and	eax, 1
	shl	eax, 11
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 11
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 704  :     ModuleInfo.cref   = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 12
	mov	DWORD PTR ModuleInfo+408, eax

; 705  :     ModuleInfo.listif = Options.listif;

	movzx	eax, BYTE PTR Options+146
	and	eax, 1
	shl	eax, 13
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 13
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 706  :     ModuleInfo.list_generated_code = Options.list_generated_code;

	movzx	eax, BYTE PTR Options+147
	and	eax, 1
	shl	eax, 14
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 14
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 707  :     ModuleInfo.list_macro = Options.list_macro;

	mov	eax, DWORD PTR Options+148
	mov	DWORD PTR ModuleInfo+400, eax

; 708  : 
; 709  :     ModuleInfo.case_sensitive = Options.case_sensitive;

	movzx	eax, BYTE PTR Options+139
	and	eax, 1
	mov	ecx, DWORD PTR ModuleInfo+408
	and	ecx, -2					; fffffffeH
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 710  :     ModuleInfo.convert_uppercase = Options.convert_uppercase;

	movzx	eax, BYTE PTR Options+140
	and	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR ModuleInfo+408
	and	ecx, -3					; fffffffdH
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 711  :     SymSetCmpFunc();

	call	SymSetCmpFunc

; 712  : 
; 713  :     ModuleInfo.segorder = SEGORDER_SEQ;

	mov	DWORD PTR ModuleInfo+380, 0

; 714  :     ModuleInfo.radix = 10;

	mov	BYTE PTR ModuleInfo+396, 10

; 715  :     ModuleInfo.fieldalign = Options.fieldalign;

	movzx	eax, BYTE PTR Options+168
	mov	BYTE PTR ModuleInfo+397, al

; 716  : #if PROCALIGN
; 717  :     ModuleInfo.procalign = 0;

	mov	BYTE PTR ModuleInfo+399, 0

; 718  : #endif
; 719  : #if DLLIMPORT
; 720  :     /* if OPTION DLLIMPORT was used, reset all iat_used flags */
; 721  :     if ( ModuleInfo.g.DllQueue )

	cmp	QWORD PTR ModuleInfo+80, 0
	je	SHORT $LN13@ModulePass

; 722  :         for ( curr = SymTables[TAB_EXT].head; curr; curr = curr->next )

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@ModulePass
$LN2@ModulePass:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@ModulePass:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@ModulePass

; 723  :             curr->sym.iat_used = FALSE;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 247					; 000000f7H
	mov	rcx, QWORD PTR curr$[rsp]
	mov	BYTE PTR [rcx+40], al
	jmp	SHORT $LN2@ModulePass
$LN3@ModulePass:
$LN13@ModulePass:

; 724  : #endif
; 725  : }

	add	rsp, 56					; 00000038H
	ret	0
ModulePassInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
env$1 = 32
pass$ = 64
CmdlParamsInit PROC

; 521  : {

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 522  :     DebugMsg(("CmdlParamsInit(%u) enter\n", pass));

	mov	edx, DWORD PTR pass$[rsp]
	lea	rcx, OFFSET FLAT:$SG11957
	call	DoDebugMsg

; 523  : 
; 524  : #if BUILD_TARGET
; 525  :     if ( pass == PASS_1 ) {
; 526  :         struct asym *sym;
; 527  :         char *tmp;
; 528  :         char *p;
; 529  : 
; 530  :         _strupr( Options.build_target );
; 531  :         tmp = myalloca( strlen( Options.build_target ) + 5 ); /* null + 4 uscores */
; 532  :         strcpy( tmp, uscores );
; 533  :         strcat( tmp, Options.build_target );
; 534  :         strcat( tmp, uscores );
; 535  : 
; 536  :         /* define target */
; 537  :         sym = CreateVariable( tmp, 0 );
; 538  :         sym->predefined = TRUE;
; 539  : 
; 540  :         p = NULL;
; 541  :         if( _stricmp( Options.build_target, "DOS" ) == 0 ) {
; 542  :             p = "__MSDOS__";
; 543  :         } else if( _stricmp( Options.build_target, "NETWARE" ) == 0 ) {
; 544  :             if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {
; 545  :                 p = "__NETWARE_386__";
; 546  :             } else {
; 547  :                 /* do nothing ... __NETWARE__ already defined */
; 548  :             }
; 549  :         } else if( _stricmp( Options.build_target, "WINDOWS" ) == 0 ) {
; 550  :             if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {
; 551  :                 p = "__WINDOWS_386__";
; 552  :             } else {
; 553  :                 /* do nothing ... __WINDOWS__ already defined */
; 554  :             }
; 555  :         } else if( _stricmp( Options.build_target, "QNX" ) == 0 ) {
; 556  :             p = "__UNIX__";
; 557  :         } else if( _stricmp( Options.build_target, "LINUX" ) == 0 ) {
; 558  :             p = "__UNIX__";
; 559  :         }
; 560  :         if ( p ) {
; 561  :             sym = CreateVariable( p, 0 );
; 562  :             sym->predefined = TRUE;
; 563  :         }
; 564  :     }
; 565  : #endif
; 566  : 
; 567  :     if ( pass == PASS_1 ) {

	cmp	DWORD PTR pass$[rsp], 0
	jne	SHORT $LN2@CmdlParams

; 568  :         char *env;
; 569  :         /* v2.06: this is done in ModulePassInit now */
; 570  :         //SetCPU( Options.cpu );
; 571  :         add_cmdline_tmacros();

	call	add_cmdline_tmacros

; 572  :         add_incpaths();

	call	add_incpaths

; 573  :         if ( Options.ignore_include == FALSE )

	movzx	eax, BYTE PTR Options+156
	test	eax, eax
	jne	SHORT $LN3@CmdlParams

; 574  :             if ( env = getenv( "INCLUDE" ) )

	lea	rcx, OFFSET FLAT:$SG11961
	call	getenv
	mov	QWORD PTR env$1[rsp], rax
	cmp	QWORD PTR env$1[rsp], 0
	je	SHORT $LN4@CmdlParams

; 575  :                 AddStringToIncludePath( env );

	mov	rcx, QWORD PTR env$1[rsp]
	call	AddStringToIncludePath
$LN4@CmdlParams:
$LN3@CmdlParams:
$LN2@CmdlParams:

; 576  :     }
; 577  :     DebugMsg(("CmdlParamsInit exit\n"));

	lea	rcx, OFFSET FLAT:$SG11962
	call	DoDebugMsg

; 578  :     return;
; 579  : }

	add	rsp, 56					; 00000038H
	ret	0
CmdlParamsInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
p$ = 32
add_incpaths PROC

; 508  : {

	sub	rsp, 56					; 00000038H

; 509  :     struct qitem *p;
; 510  :     DebugMsg(("add_incpaths: enter\n"));

	lea	rcx, OFFSET FLAT:$SG11951
	call	DoDebugMsg

; 511  :     for ( p = Options.queues[OPTQ_INCPATH]; p; p = p->next ) {

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:Options+104
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN4@add_incpat
$LN2@add_incpat:
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$[rsp], rax
$LN4@add_incpat:
	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN3@add_incpat

; 512  :         AddStringToIncludePath( p->value );

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	AddStringToIncludePath

; 513  :     }

	jmp	SHORT $LN2@add_incpat
$LN3@add_incpat:

; 514  : }

	add	rsp, 56					; 00000038H
	ret	0
add_incpaths ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
name$ = 0
sym$ = 8
len$ = 16
p$ = 24
value$ = 32
__$ArrayPad$ = 40
add_cmdline_tmacros PROC

; 458  : {

	push	rbp
	sub	rsp, 80					; 00000050H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax

; 459  :     struct qitem *p;
; 460  :     char *name;
; 461  :     char *value;
; 462  :     int len;
; 463  :     struct asym *sym;
; 464  : 
; 465  :     DebugMsg(("add_cmdline_tmacros enter\n"));

	lea	rcx, OFFSET FLAT:$SG11934
	call	DoDebugMsg

; 466  :     for ( p = Options.queues[OPTQ_MACRO]; p; p = p->next ) {

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:Options+104
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR p$[rbp], rax
	jmp	SHORT $LN4@add_cmdlin
$LN2@add_cmdlin:
	mov	rax, QWORD PTR p$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$[rbp], rax
$LN4@add_cmdlin:
	cmp	QWORD PTR p$[rbp], 0
	je	$LN3@add_cmdlin

; 467  :         DebugMsg(("add_cmdline_tmacros: found >%s<\n", p->value));

	mov	rax, QWORD PTR p$[rbp]
	add	rax, 8
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11935
	call	DoDebugMsg

; 468  :         name = p->value;

	mov	rax, QWORD PTR p$[rbp]
	add	rax, 8
	mov	QWORD PTR name$[rbp], rax

; 469  :         value = strchr( name, '=' );

	mov	edx, 61					; 0000003dH
	mov	rcx, QWORD PTR name$[rbp]
	call	strchr
	mov	QWORD PTR value$[rbp], rax

; 470  :         if( value == NULL ) {

	cmp	QWORD PTR value$[rbp], 0
	jne	SHORT $LN5@add_cmdlin

; 471  :             /* v2.06: ensure that 'value' doesn't point to r/o space */
; 472  :             //value = "";
; 473  :             value = name + strlen( name ); /* use the terminating NULL */

	mov	rcx, QWORD PTR name$[rbp]
	call	strlen
	mov	rcx, QWORD PTR name$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR value$[rbp], rax

; 474  :         } else {

	jmp	SHORT $LN6@add_cmdlin
$LN5@add_cmdlin:

; 475  :             len = value - name;

	mov	rax, QWORD PTR name$[rbp]
	mov	rcx, QWORD PTR value$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR len$[rbp], eax

; 476  :             name = (char *)myalloca( len + 1 );

	mov	eax, DWORD PTR len$[rbp]
	inc	eax
	cdqe
	mov	rcx, rax
	add	rcx, 15
	cmp	rcx, rax
	ja	SHORT $LN13@add_cmdlin
	mov	rcx, 1152921504606846960		; 0ffffffffffffff0H
$LN13@add_cmdlin:
	and	rcx, -16
	mov	rax, rcx
	call	__chkstk
	sub	rsp, rax
	lea	rax, QWORD PTR [rsp+32]
	mov	QWORD PTR name$[rbp], rax

; 477  :             memcpy( name, p->value, len );

	movsxd	rax, DWORD PTR len$[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	add	rcx, 8
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR name$[rbp]
	call	memcpy

; 478  :             *(name + len) = NULLC;

	movsxd	rax, DWORD PTR len$[rbp]
	mov	rcx, QWORD PTR name$[rbp]
	mov	BYTE PTR [rcx+rax], 0

; 479  :             value++;

	mov	rax, QWORD PTR value$[rbp]
	inc	rax
	mov	QWORD PTR value$[rbp], rax
$LN6@add_cmdlin:

; 480  :         }
; 481  : 
; 482  :         /* there's no check whether the name is a reserved word!
; 483  :          */
; 484  :         if( is_valid_identifier( name ) == ERROR ) {

	mov	rcx, QWORD PTR name$[rbp]
	call	is_valid_identifier
	cmp	eax, -1
	jne	SHORT $LN7@add_cmdlin

; 485  :             DebugMsg(("add_cmdline_tmacros: name >%s< invalid\n", name ));

	mov	rdx, QWORD PTR name$[rbp]
	lea	rcx, OFFSET FLAT:$SG11940
	call	DoDebugMsg

; 486  :             EmitErr( SYNTAX_ERROR_EX, name );

	mov	rdx, QWORD PTR name$[rbp]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 487  :         } else {

	jmp	SHORT $LN8@add_cmdlin
$LN7@add_cmdlin:

; 488  :             sym = SymSearch( name );

	mov	rcx, QWORD PTR name$[rbp]
	call	SymFind
	mov	QWORD PTR sym$[rbp], rax

; 489  :             if ( sym == NULL ) {

	cmp	QWORD PTR sym$[rbp], 0
	jne	SHORT $LN9@add_cmdlin

; 490  :                 sym = SymCreate( name );

	mov	rcx, QWORD PTR name$[rbp]
	call	SymCreate
	mov	QWORD PTR sym$[rbp], rax

; 491  :                 sym->state = SYM_TMACRO;

	mov	rax, QWORD PTR sym$[rbp]
	mov	DWORD PTR [rax+32], 10
$LN9@add_cmdlin:

; 492  :             }
; 493  :             if ( sym->state == SYM_TMACRO ) {

	mov	rax, QWORD PTR sym$[rbp]
	cmp	DWORD PTR [rax+32], 10
	jne	SHORT $LN10@add_cmdlin

; 494  :                 sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rbp]
	mov	BYTE PTR [rcx+40], al

; 495  :                 sym->predefined = TRUE;

	mov	rax, QWORD PTR sym$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR sym$[rbp]
	mov	BYTE PTR [rcx+40], al

; 496  :                 sym->string_ptr = value;

	mov	rax, QWORD PTR sym$[rbp]
	mov	rcx, QWORD PTR value$[rbp]
	mov	QWORD PTR [rax+16], rcx

; 497  :             } else

	jmp	SHORT $LN11@add_cmdlin
$LN10@add_cmdlin:

; 498  :                 EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	rdx, QWORD PTR name$[rbp]
	mov	ecx, 56					; 00000038H
	call	EmitErr
$LN11@add_cmdlin:
$LN8@add_cmdlin:

; 499  :         }
; 500  :     }

	jmp	$LN2@add_cmdlin
$LN3@add_cmdlin:

; 501  :     return;
; 502  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+48]
	pop	rbp
	ret	0
add_cmdline_tmacros ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
tv78 = 32
tv128 = 36
id$ = 64
is_valid_identifier PROC

; 436  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 437  :     /* special handling of first char of an id: it can't be a digit,
; 438  :      but can be a dot (don't care about ModuleInfo.dotname!). */
; 439  : 
; 440  :     if( is_valid_first_char( *id ) == 0 )

	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isalpha
	test	eax, eax
	jne	SHORT $LN9@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN9@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN9@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN9@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN9@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN9@is_valid_i
	mov	DWORD PTR tv78[rsp], 0
	jmp	SHORT $LN10@is_valid_i
$LN9@is_valid_i:
	mov	DWORD PTR tv78[rsp], 1
$LN10@is_valid_i:
	cmp	DWORD PTR tv78[rsp], 0
	jne	SHORT $LN5@is_valid_i

; 441  :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@is_valid_i
$LN5@is_valid_i:

; 442  :     id++;

	mov	rax, QWORD PTR id$[rsp]
	inc	rax
	mov	QWORD PTR id$[rsp], rax

; 443  :     for( ; *id != NULLC; id++ ) {

	jmp	SHORT $LN4@is_valid_i
$LN2@is_valid_i:
	mov	rax, QWORD PTR id$[rsp]
	inc	rax
	mov	QWORD PTR id$[rsp], rax
$LN4@is_valid_i:
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@is_valid_i

; 444  :         if ( is_valid_id_char( *id ) == FALSE )

	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isalnum
	test	eax, eax
	jne	SHORT $LN11@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN11@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN11@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN11@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN11@is_valid_i
	mov	DWORD PTR tv128[rsp], 0
	jmp	SHORT $LN12@is_valid_i
$LN11@is_valid_i:
	mov	DWORD PTR tv128[rsp], 1
$LN12@is_valid_i:
	cmp	DWORD PTR tv128[rsp], 0
	jne	SHORT $LN6@is_valid_i

; 445  :             return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@is_valid_i
$LN6@is_valid_i:

; 446  :     }

	jmp	$LN2@is_valid_i
$LN3@is_valid_i:

; 447  :     /* don't allow a single dot! */
; 448  :     if ( *(id-1) == '.' )

	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN7@is_valid_i

; 449  :         return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@is_valid_i
$LN7@is_valid_i:

; 450  : 
; 451  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@is_valid_i:

; 452  : }

	add	rsp, 56					; 00000038H
	ret	0
is_valid_identifier ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
size$1 = 48
curr$ = 56
ld$2 = 64
modinfo$ = 96
WriteModule PROC

; 386  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 387  :     struct dsym *curr;
; 388  : 
; 389  :     DebugMsg(("WriteModule enter\n"));

	lea	rcx, OFFSET FLAT:$SG11897
	call	DoDebugMsg

; 390  : 
; 391  :     /* final checks */
; 392  :     /* check limit of segments */
; 393  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@WriteModul
$LN2@WriteModul:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@WriteModul:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@WriteModul

; 394  :         if ( curr->e.seginfo->Ofssize == USE16 && curr->sym.max_offset > 0x10000 ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+104]
	test	eax, eax
	jne	SHORT $LN8@WriteModul
	mov	rax, QWORD PTR curr$[rsp]
	cmp	DWORD PTR [rax+56], 65536		; 00010000H
	jle	SHORT $LN8@WriteModul

; 395  :             if ( Options.output_format == OFORMAT_OMF )

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN9@WriteModul

; 396  :                 EmitErr( SEGMENT_EXCEEDS_64K_LIMIT, curr->sym.name );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 222				; 000000deH
	call	EmitErr
	jmp	SHORT $LN10@WriteModul
$LN9@WriteModul:

; 397  :             else
; 398  :                 EmitWarn( 2, SEGMENT_EXCEEDS_64K_LIMIT, curr->sym.name );

	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 222				; 000000deH
	mov	ecx, 2
	call	EmitWarn
$LN10@WriteModul:
$LN8@WriteModul:

; 399  :         }
; 400  :     }

	jmp	SHORT $LN2@WriteModul
$LN3@WriteModul:

; 401  : 
; 402  :     modinfo->g.WriteModule( modinfo );

	mov	rcx, QWORD PTR modinfo$[rsp]
	mov	rax, QWORD PTR modinfo$[rsp]
	call	QWORD PTR [rax+288]

; 403  : 
; 404  : #if DLLIMPORT
; 405  :     /* is the -Fd option given with a file name? */
; 406  :     if ( Options.names[OPTN_LNKDEF_FN] ) {

	mov	eax, 8
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax], 0
	je	$LN11@WriteModul

; 407  :         FILE *ld;
; 408  :         ld = fopen( Options.names[OPTN_LNKDEF_FN], "w" );

	mov	eax, 8
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:Options+32
	lea	rdx, OFFSET FLAT:$SG11902
	mov	rcx, QWORD PTR [rcx+rax]
	call	fopen
	mov	QWORD PTR ld$2[rsp], rax

; 409  :         if ( ld == NULL ) {

	cmp	QWORD PTR ld$2[rsp], 0
	jne	SHORT $LN12@WriteModul

; 410  :             return( EmitErr( CANNOT_OPEN_FILE, Options.names[OPTN_LNKDEF_FN], ErrnoStr() ) );

	call	ErrnoStr
	mov	ecx, 8
	imul	rcx, rcx, 4
	lea	rdx, OFFSET FLAT:Options+32
	mov	r8, rax
	mov	rdx, QWORD PTR [rdx+rcx]
	mov	ecx, 106				; 0000006aH
	call	EmitErr
	jmp	$LN1@WriteModul
$LN12@WriteModul:

; 411  :         }
; 412  :         for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN7@WriteModul
$LN5@WriteModul:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN7@WriteModul:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN6@WriteModul

; 413  :             DebugMsg(("WriteModule: ext=%s, isproc=%u, weak=%u\n", curr->sym.name, curr->sym.isproc, curr->sym.weak ));

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	mov	rcx, QWORD PTR curr$[rsp]
	movzx	ecx, BYTE PTR [rcx+41]
	shr	cl, 3
	and	cl, 1
	movzx	ecx, cl
	mov	r9d, eax
	mov	r8d, ecx
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11904
	call	DoDebugMsg

; 414  :             if ( curr->sym.isproc && ( curr->sym.weak == FALSE || curr->sym.iat_used ) &&
; 415  :                 curr->sym.dll && *(curr->sym.dll->name) != NULLC ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN13@WriteModul
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@WriteModul
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN13@WriteModul
$LN14@WriteModul:
	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	$LN13@WriteModul
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	ecx, 1
	imul	rcx, rcx, 0
	movsx	eax, BYTE PTR [rax+rcx+12]
	test	eax, eax
	je	SHORT $LN13@WriteModul

; 416  :                 int size;
; 417  :                 Mangle( &curr->sym, StringBufferEnd );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, rax
	call	Mangle

; 418  :                 size = sprintf( CurrSource, "import '%s'  %s.%s\n", StringBufferEnd, curr->sym.dll->name, curr->sym.name );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+56]
	add	rax, 12
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rax
	mov	r8, QWORD PTR ModuleInfo+488
	lea	rdx, OFFSET FLAT:$SG11907
	mov	rcx, QWORD PTR ModuleInfo+464
	call	sprintf
	mov	DWORD PTR size$1[rsp], eax

; 419  :                 if ( fwrite( CurrSource, 1, size, ld ) != size )

	movsxd	rax, DWORD PTR size$1[rsp]
	mov	r9, QWORD PTR ld$2[rsp]
	mov	r8, rax
	mov	edx, 1
	mov	rcx, QWORD PTR ModuleInfo+464
	call	fwrite
	movsxd	rcx, DWORD PTR size$1[rsp]
	cmp	rax, rcx
	je	SHORT $LN15@WriteModul

; 420  :                     WriteError();

	call	WriteError
$LN15@WriteModul:
$LN13@WriteModul:

; 421  :             }
; 422  :         }

	jmp	$LN5@WriteModul
$LN6@WriteModul:

; 423  :         fclose( ld );

	mov	rcx, QWORD PTR ld$2[rsp]
	call	fclose
$LN11@WriteModul:

; 424  :     }
; 425  : #endif
; 426  :     DebugMsg(("WriteModule exit\n"));

	lea	rcx, OFFSET FLAT:$SG11909
	call	DoDebugMsg

; 427  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@WriteModul:

; 428  : }

	add	rsp, 88					; 00000058H
	ret	0
WriteModule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
seg$ = 48
value$ = 56
relative$ = 64
select_data$ = 72
SetCurrOffset PROC

; 338  : {

$LN15:
	mov	BYTE PTR [rsp+32], r9b
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 339  :     if( relative )

	movzx	eax, BYTE PTR relative$[rsp]
	test	eax, eax
	je	SHORT $LN2@SetCurrOff

; 340  :         value += seg->e.seginfo->current_loc;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	mov	ecx, DWORD PTR value$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR value$[rsp], eax
$LN2@SetCurrOff:

; 341  : 
; 342  :     if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN3@SetCurrOff

; 343  :         if ( seg == CurrSeg ) {

	mov	rax, QWORD PTR ModuleInfo+432
	cmp	QWORD PTR seg$[rsp], rax
	jne	SHORT $LN5@SetCurrOff

; 344  :             if ( write_to_file == TRUE )

	movzx	eax, BYTE PTR write_to_file
	cmp	eax, 1
	jne	SHORT $LN6@SetCurrOff

; 345  :                 omf_FlushCurrSeg();

	call	omf_FlushCurrSeg
$LN6@SetCurrOff:

; 346  : 
; 347  :         /* for debugging, tell if data is located in code sections*/
; 348  :             if( select_data )

	movzx	eax, BYTE PTR select_data$[rsp]
	test	eax, eax
	je	SHORT $LN7@SetCurrOff

; 349  :                 if ( ModuleInfo.CommentDataInCode )

	movzx	eax, BYTE PTR ModuleInfo+423
	test	eax, eax
	je	SHORT $LN8@SetCurrOff

; 350  :                     omf_OutSelect( TRUE );

	mov	cl, 1
	call	omf_OutSelect
$LN8@SetCurrOff:
$LN7@SetCurrOff:

; 351  :             LastCodeBufSize = value;

	mov	eax, DWORD PTR value$[rsp]
	mov	DWORD PTR LastCodeBufSize, eax
$LN5@SetCurrOff:

; 352  :         }
; 353  :         seg->e.seginfo->start_loc = value;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 354  :     /* for -bin, if there's an ORG (relative==false) and no initialized data
; 355  :      * has been set yet, set start_loc!
; 356  :      * v1.96: this is now also done for COFF and ELF
; 357  :      */
; 358  :     /* else if ( Options.output_format == OFORMAT_BIN && relative == FALSE ) { */
; 359  :     } else {

	jmp	SHORT $LN4@SetCurrOff
$LN3@SetCurrOff:

; 360  :         if ( write_to_file == FALSE ) {

	movzx	eax, BYTE PTR write_to_file
	test	eax, eax
	jne	SHORT $LN9@SetCurrOff

; 361  :             if ( relative ) {

	movzx	eax, BYTE PTR relative$[rsp]
	test	eax, eax
	je	SHORT $LN10@SetCurrOff

; 362  : #if 0 /* don't include "preceding" uninitialized data */
; 363  :                 if( seg->e.seginfo->current_loc < seg->e.seginfo->start_loc )
; 364  :                     seg->e.seginfo->start_loc = seg->e.seginfo->current_loc;
; 365  : #endif
; 366  :             } else {

	jmp	SHORT $LN11@SetCurrOff
$LN10@SetCurrOff:

; 367  :                 if ( seg->e.seginfo->bytes_written == 0 )

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN12@SetCurrOff

; 368  :                     seg->e.seginfo->start_loc = value;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax+8], ecx
$LN12@SetCurrOff:
$LN11@SetCurrOff:
$LN9@SetCurrOff:
$LN4@SetCurrOff:

; 369  :             }
; 370  :         }
; 371  :     }
; 372  : 
; 373  :     seg->e.seginfo->current_loc = value;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax+12], ecx

; 374  :     seg->e.seginfo->written = FALSE;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	and	al, 223					; 000000dfH
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+107], al

; 375  : 
; 376  :     if( seg->e.seginfo->current_loc > seg->sym.max_offset )

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	cmp	DWORD PTR [rax+12], ecx
	jbe	SHORT $LN13@SetCurrOff

; 377  :         seg->sym.max_offset = seg->e.seginfo->current_loc;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+56], eax
$LN13@SetCurrOff:

; 378  : 
; 379  :     return( NOT_ERROR );

	xor	eax, eax

; 380  : }

	add	rsp, 40					; 00000028H
	ret	0
SetCurrOffset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
p$ = 32
tv74 = 40
string$ = 64
WritePreprocessedLine PROC

; 585  : {

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 586  :     static bool PrintEmptyLine = TRUE;
; 587  :     const char *p;
; 588  : 
; 589  : #if 0 /* v2.08: removed, obsolete */
; 590  :     /* filter some macro specific directives */
; 591  :     if ( tokenarray[0].token == T_DIRECTIVE &&
; 592  :          ( tokenarray[0].tokval == T_ENDM ||
; 593  :            tokenarray[0].tokval == T_EXITM))
; 594  :         return;
; 595  :     /* don't print generated code - with one exception:
; 596  :      if the code was generated as a result of structure initialization,
; 597  :      then do!
; 598  :      */
; 599  :     if ( GeneratedCode )
; 600  :         return;
; 601  : #endif
; 602  :     if ( Token_Count > 0 ) {

	cmp	DWORD PTR ModuleInfo+496, 0
	jle	SHORT $LN5@WritePrepr

; 603  :         /* v2.08: don't print a leading % (this char is no longer filtered) */
; 604  :         for ( p = string; isspace( *p ); p++ );

	mov	rax, QWORD PTR string$[rsp]
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN4@WritePrepr
$LN2@WritePrepr:
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN4@WritePrepr:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isspace
	test	eax, eax
	je	SHORT $LN3@WritePrepr
	jmp	SHORT $LN2@WritePrepr
$LN3@WritePrepr:

; 605  :         printf("%s\n", *p == '%' ? p+1 : string );

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN9@WritePrepr
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR tv74[rsp], rax
	jmp	SHORT $LN10@WritePrepr
$LN9@WritePrepr:
	mov	rax, QWORD PTR string$[rsp]
	mov	QWORD PTR tv74[rsp], rax
$LN10@WritePrepr:
	mov	rdx, QWORD PTR tv74[rsp]
	lea	rcx, OFFSET FLAT:$SG11974
	call	printf

; 606  :         PrintEmptyLine = TRUE;

	mov	BYTE PTR ?PrintEmptyLine@?1??WritePreprocessedLine@@9@9, 1
	jmp	SHORT $LN6@WritePrepr
$LN5@WritePrepr:

; 607  :     } else if ( PrintEmptyLine ) {

	movzx	eax, BYTE PTR ?PrintEmptyLine@?1??WritePreprocessedLine@@9@9
	test	eax, eax
	je	SHORT $LN7@WritePrepr

; 608  :         PrintEmptyLine = FALSE;

	mov	BYTE PTR ?PrintEmptyLine@?1??WritePreprocessedLine@@9@9, 0

; 609  :         printf("\n");

	lea	rcx, OFFSET FLAT:$SG11976
	call	printf
$LN7@WritePrepr:
$LN6@WritePrepr:

; 610  :     }
; 611  : }

	add	rsp, 56					; 00000038H
	ret	0
WritePreprocessedLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
i$ = 32
sym$ = 64
pst$ = 72
buffer$ = 80
ConvertSectionName PROC

; 165  : {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 166  :     int i;
; 167  : 
; 168  :     for ( i = 0; i < sizeof( cst ) / sizeof( cst[0] ); i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@ConvertSec
$LN2@ConvertSec:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@ConvertSec:
	movsxd	rax, DWORD PTR i$[rsp]
	cmp	rax, 4
	jae	$LN3@ConvertSec

; 169  :         if ( memcmp( sym->name, cst[i].src, cst[i].len ) == 0 ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 24
	lea	rdx, OFFSET FLAT:cst
	mov	r8d, eax
	mov	rdx, QWORD PTR [rdx+rcx+8]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcmp
	test	eax, eax
	jne	$LN5@ConvertSec

; 170  :             if ( sym->name[cst[i].len] == NULLC || ( sym->name[cst[i].len] == '$' && ( cst[i].flags & CSF_GRPCHK ) ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN7@ConvertSec
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 36					; 00000024H
	jne	$LN6@ConvertSec
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax+1]
	and	eax, 1
	test	eax, eax
	je	$LN6@ConvertSec
$LN7@ConvertSec:

; 171  : 
; 172  :                 if ( pst ) {

	cmp	QWORD PTR pst$[rsp], 0
	je	SHORT $LN8@ConvertSec

; 173  :                     if ( i == CSI_BSS && ( (struct dsym *)sym)->e.seginfo->bytes_written != 0 )

	cmp	DWORD PTR i$[rsp], 3
	jne	SHORT $LN9@ConvertSec
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+24], 0
	je	SHORT $LN9@ConvertSec

; 174  :                         ; /* don't set segment type to BSS if the segment contains initialized data */

	jmp	SHORT $LN10@ConvertSec
$LN9@ConvertSec:

; 175  :                     else
; 176  :                         *pst = stt[i];

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:stt
	mov	rdx, QWORD PTR pst$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR [rdx], eax
$LN10@ConvertSec:
$LN8@ConvertSec:

; 177  :                 }
; 178  : 
; 179  :                 if ( sym->name[cst[i].len] == NULLC ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN11@ConvertSec

; 180  : #if DJGPP_SUPPORT
; 181  :                     /* DJGPP won't be happy with .rdata segment name */
; 182  :                     if( ModuleInfo.sub_format == SFORMAT_DJGPP && i == CSI_CONST )
; 183  :                         return( ".const" );
; 184  : #endif
; 185  :                     return( (char *)cst[i].dst );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	mov	rax, QWORD PTR [rcx+rax+16]
	jmp	SHORT $LN1@ConvertSec
$LN11@ConvertSec:

; 186  :                 }
; 187  : 
; 188  :                 strcpy( buffer, cst[i].dst );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	mov	rdx, QWORD PTR [rcx+rax+16]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcpy

; 189  :                 strcat( buffer, sym->name+cst[i].len );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR sym$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	rdx, rax
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcat

; 190  :                 return( buffer );

	mov	rax, QWORD PTR buffer$[rsp]
	jmp	SHORT $LN1@ConvertSec
$LN6@ConvertSec:
$LN5@ConvertSec:

; 191  :             }
; 192  :         }
; 193  :     }

	jmp	$LN2@ConvertSec
$LN3@ConvertSec:

; 194  :     return( sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
$LN1@ConvertSec:

; 195  : }

	add	rsp, 56					; 00000038H
	ret	0
ConvertSectionName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
close_files PROC

; 1231 : {

$LN12:
	sub	rsp, 40					; 00000028H

; 1232 :     /* v2.11: no fatal errors anymore if fclose() fails.
; 1233 :      * That's because Fatal() may cause close_files() to be
; 1234 :      * reentered and thus cause an endless loop.
; 1235 :      */
; 1236 : 
; 1237 :     /* close ASM file */
; 1238 :     if( CurrFile[ASM] != NULL ) {

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN2@close_file

; 1239 :         if( fclose( CurrFile[ASM] ) != 0 )

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	fclose
	test	eax, eax
	je	SHORT $LN3@close_file

; 1240 :             EmitErr( CANNOT_CLOSE_FILE, CurrFName[ASM], errno );

	call	_errno
	mov	ecx, 8
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:ModuleInfo+128
	mov	r8d, DWORD PTR [rax]
	mov	rdx, QWORD PTR [rdx+rcx]
	mov	ecx, 107				; 0000006bH
	call	EmitErr
$LN3@close_file:

; 1241 :         CurrFile[ASM] = NULL;

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR [rcx+rax], 0
$LN2@close_file:

; 1242 :     }
; 1243 : 
; 1244 :     /* close OBJ file */
; 1245 :     if ( CurrFile[OBJ] != NULL ) {

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN4@close_file

; 1246 :         if ( fclose( CurrFile[OBJ] ) != 0 )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	fclose
	test	eax, eax
	je	SHORT $LN5@close_file

; 1247 :             EmitErr( CANNOT_CLOSE_FILE, CurrFName[OBJ], errno );

	call	_errno
	mov	ecx, 8
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:ModuleInfo+128
	mov	r8d, DWORD PTR [rax]
	mov	rdx, QWORD PTR [rdx+rcx]
	mov	ecx, 107				; 0000006bH
	call	EmitErr
$LN5@close_file:

; 1248 :         CurrFile[OBJ] = NULL;

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR [rcx+rax], 0
$LN4@close_file:

; 1249 :     }
; 1250 :     /* delete the object module if errors occured */
; 1251 :     if ( Options.syntax_check_only == FALSE &&

	movzx	eax, BYTE PTR Options+188
	test	eax, eax
	jne	SHORT $LN6@close_file
	cmp	DWORD PTR ModuleInfo, 0
	jbe	SHORT $LN6@close_file

; 1252 :         ModuleInfo.g.error_count > 0 ) {
; 1253 :         remove( CurrFName[OBJ] );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rcx, QWORD PTR [rcx+rax]
	call	remove
$LN6@close_file:

; 1254 :     }
; 1255 : 
; 1256 :     if( CurrFile[LST] != NULL ) {

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN7@close_file

; 1257 :         fclose( CurrFile[LST] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	fclose

; 1258 :         CurrFile[LST] = NULL;

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR [rcx+rax], 0
$LN7@close_file:

; 1259 :     }
; 1260 : 
; 1261 :     /* close ERR file */
; 1262 :     if ( CurrFile[ERR] != NULL ) {

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN8@close_file

; 1263 :         fclose( CurrFile[ERR] );

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	fclose

; 1264 :         CurrFile[ERR] = NULL;

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR [rcx+rax], 0
	jmp	SHORT $LN9@close_file
$LN8@close_file:

; 1265 :     } else if ( CurrFName[ERR] )

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN10@close_file

; 1266 :         /* nothing written, delete any existing ERR file */
; 1267 :         remove( CurrFName[ERR] );

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rcx, QWORD PTR [rcx+rax]
	call	remove
$LN10@close_file:
$LN9@close_file:

; 1268 :     return;
; 1269 : }

	add	rsp, 40					; 00000028H
	ret	0
close_files ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
value$ = 8
SetMasm510 PROC

; 617  : {

	mov	BYTE PTR [rsp+8], cl

; 618  :     ModuleInfo.m510 = value;

	movzx	eax, BYTE PTR value$[rsp]
	and	eax, 1
	shl	eax, 6
	mov	ecx, DWORD PTR ModuleInfo+408
	and	ecx, -65				; ffffffbfH
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 619  :     ModuleInfo.oldstructs = value;

	movzx	eax, BYTE PTR value$[rsp]
	and	eax, 1
	shl	eax, 8
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 8
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 620  :     /* ModuleInfo.oldmacros = value; not implemented yet */
; 621  :     ModuleInfo.dotname = value;

	movzx	eax, BYTE PTR value$[rsp]
	and	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR ModuleInfo+408
	and	ecx, -17				; ffffffefH
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 622  :     ModuleInfo.setif2 = value;

	movzx	eax, BYTE PTR value$[rsp]
	and	eax, 1
	shl	eax, 10
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 10
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 623  : 
; 624  :     if ( value ) {

	movzx	eax, BYTE PTR value$[rsp]
	test	eax, eax
	je	SHORT $LN2@SetMasm510

; 625  :         if ( ModuleInfo.model == MODEL_NONE ) {

	cmp	DWORD PTR ModuleInfo+360, 0
	jne	SHORT $LN3@SetMasm510

; 626  :             /* if no model is specified, set OFFSET:SEGMENT */
; 627  :             ModuleInfo.offsettype = OT_SEGMENT;

	mov	DWORD PTR ModuleInfo+384, 2

; 628  :             if ( ModuleInfo.langtype == LANG_NONE ) {

	cmp	DWORD PTR ModuleInfo+364, 0
	jne	SHORT $LN4@SetMasm510

; 629  :                 ModuleInfo.scoped = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	btr	eax, 7
	mov	DWORD PTR ModuleInfo+408, eax

; 630  :                 ModuleInfo.procs_private = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	or	eax, 4
	mov	DWORD PTR ModuleInfo+408, eax
$LN4@SetMasm510:
$LN3@SetMasm510:
$LN2@SetMasm510:

; 631  :             }
; 632  :         }
; 633  :     }
; 634  :     return;
; 635  : }

	ret	0
SetMasm510 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
curr_written$ = 64
seg$ = 72
prev_written$ = 80
tv264 = 84
starttime$ = 88
endtime$ = 92
tv209 = 96
tv211 = 100
tv213 = 104
tv215 = 112
source$ = 144
AssembleModule PROC

; 1436 : {

$LN31:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 1437 :     uint_32       prev_written = -1;

	mov	DWORD PTR prev_written$[rsp], -1	; ffffffffH

; 1438 :     uint_32       curr_written;
; 1439 :     int           starttime;
; 1440 :     int           endtime;
; 1441 :     struct dsym   *seg;
; 1442 : 
; 1443 :     DebugMsg(("AssembleModule(\"%s\") enter\n", source ));

	mov	rdx, QWORD PTR source$[rsp]
	lea	rcx, OFFSET FLAT:$SG12247
	call	DoDebugMsg

; 1444 : 
; 1445 :     memset( &ModuleInfo, 0, sizeof(ModuleInfo) );

	mov	r8d, 776				; 00000308H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:ModuleInfo
	call	memset

; 1446 :     DebugCmd( ModuleInfo.cref = TRUE ); /* enable debug displays */

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 12
	mov	DWORD PTR ModuleInfo+408, eax

; 1447 : 
; 1448 : #if 1 //def __SW_BD
; 1449 :     /* fatal errors during assembly won't terminate the program,
; 1450 :      * just the assembly step.!
; 1451 :      */
; 1452 :     if ( setjmp( jmpenv ) ) {

	lea	rcx, OFFSET FLAT:jmpenv
	mov	rdx, rsp
	call	_setjmp
	test	eax, eax
	je	SHORT $LN11@AssembleMo

; 1453 :         if ( ModuleInfo.g.src_stack )

	cmp	QWORD PTR ModuleInfo+200, 0
	je	SHORT $LN12@AssembleMo

; 1454 :             ClearSrcStack(); /* avoid memory leaks! */

	call	ClearSrcStack
$LN12@AssembleMo:

; 1455 :         goto done;

	jmp	$done$32
$LN11@AssembleMo:

; 1456 :     }
; 1457 : #endif
; 1458 : 
; 1459 :     AssembleInit( source );

	mov	rcx, QWORD PTR source$[rsp]
	call	AssembleInit

; 1460 : 
; 1461 :     starttime = clock();

	call	clock
	mov	DWORD PTR starttime$[rsp], eax

; 1462 : 
; 1463 : #if 0 /* 1=trigger a protection fault */
; 1464 :     seg = NULL;
; 1465 :     seg->sym.state = SYM_UNDEFINED;
; 1466 : #endif
; 1467 : 
; 1468 :     for( Parse_Pass = PASS_1; ; Parse_Pass++ ) {

	mov	DWORD PTR Parse_Pass, 0
	jmp	SHORT $LN4@AssembleMo
$LN2@AssembleMo:
	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	DWORD PTR Parse_Pass, eax
$LN4@AssembleMo:

; 1469 : 
; 1470 :         DebugMsg(( "*************\npass %u\n*************\n", Parse_Pass + 1 ));

	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12250
	call	DoDebugMsg

; 1471 :         OnePass();

	call	OnePass

; 1472 : 
; 1473 :         if( ModuleInfo.g.error_count > 0 ) {

	cmp	DWORD PTR ModuleInfo, 0
	jbe	SHORT $LN13@AssembleMo

; 1474 :             DebugMsg(("AssembleModule(%u): errorcnt=%u\n", Parse_Pass + 1, ModuleInfo.g.error_count ));

	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	r8d, DWORD PTR ModuleInfo
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12252
	call	DoDebugMsg

; 1475 :             break;

	jmp	$LN3@AssembleMo
$LN13@AssembleMo:

; 1476 :         }
; 1477 : 
; 1478 :         /* calculate total size of segments */
; 1479 :         for ( curr_written = 0, seg = SymTables[TAB_SEG].head; seg ; seg = seg->next ) {

	mov	DWORD PTR curr_written$[rsp], 0
	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR seg$[rsp], rax
	jmp	SHORT $LN7@AssembleMo
$LN5@AssembleMo:
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR seg$[rsp], rax
$LN7@AssembleMo:
	cmp	QWORD PTR seg$[rsp], 0
	je	SHORT $LN6@AssembleMo

; 1480 :             /* v2.04: use <max_offset> instead of <bytes_written>
; 1481 :              * (the latter is not always reliable due to backpatching).
; 1482 :              */
; 1483 :             //curr_written += seg->e.seginfo->bytes_written;
; 1484 :             curr_written += seg->sym.max_offset;

	mov	rax, QWORD PTR seg$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	ecx, DWORD PTR curr_written$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR curr_written$[rsp], eax

; 1485 :             DebugMsg(("AssembleModule(%u): segm=%-8s start=%8" I32_SPEC "X max_ofs=%8" I32_SPEC "X written=%" I32_SPEC "X\n",

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	edx, DWORD PTR Parse_Pass
	inc	edx
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR seg$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR [rcx+8]
	mov	rax, QWORD PTR seg$[rsp]
	mov	r8, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12253
	call	DoDebugMsg

; 1486 :                       Parse_Pass + 1, seg->sym.name, seg->e.seginfo->start_loc, seg->sym.max_offset,
; 1487 :                       seg->e.seginfo->bytes_written ));
; 1488 :         }

	jmp	SHORT $LN5@AssembleMo
$LN6@AssembleMo:

; 1489 : 
; 1490 :         /* if there's no phase error and size of segments didn't change, we're done */
; 1491 :         DebugMsg(("AssembleModule(%u): PhaseError=%u, prev_written=%" I32_SPEC "X, curr_written=%" I32_SPEC "X\n", Parse_Pass + 1, ModuleInfo.PhaseError, prev_written, curr_written));

	movzx	eax, BYTE PTR ModuleInfo+422
	mov	ecx, DWORD PTR Parse_Pass
	inc	ecx
	mov	edx, DWORD PTR curr_written$[rsp]
	mov	DWORD PTR [rsp+32], edx
	mov	r9d, DWORD PTR prev_written$[rsp]
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG12254
	call	DoDebugMsg

; 1492 :         if( !ModuleInfo.PhaseError && prev_written == curr_written )

	movzx	eax, BYTE PTR ModuleInfo+422
	test	eax, eax
	jne	SHORT $LN14@AssembleMo
	mov	eax, DWORD PTR curr_written$[rsp]
	cmp	DWORD PTR prev_written$[rsp], eax
	jne	SHORT $LN14@AssembleMo

; 1493 :             break;

	jmp	$LN3@AssembleMo
$LN14@AssembleMo:

; 1494 : 
; 1495 : #ifdef DEBUG_OUT
; 1496 :         if ( curr_written < prev_written && prev_written != -1 ) {

	mov	eax, DWORD PTR prev_written$[rsp]
	cmp	DWORD PTR curr_written$[rsp], eax
	jae	SHORT $LN15@AssembleMo
	cmp	DWORD PTR prev_written$[rsp], -1	; ffffffffH
	je	SHORT $LN15@AssembleMo

; 1497 :             printf( "size shrank from %" I32_SPEC "X to %" I32_SPEC "X in pass %u\n", prev_written, curr_written, Parse_Pass + 1 );

	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	r9d, eax
	mov	r8d, DWORD PTR curr_written$[rsp]
	mov	edx, DWORD PTR prev_written$[rsp]
	lea	rcx, OFFSET FLAT:$SG12257
	call	printf
$LN15@AssembleMo:

; 1498 :         }
; 1499 : #endif
; 1500 : 
; 1501 :         DebugMsg(("AssembleModule(%u): prepare for next pass\n", Parse_Pass + 1));

	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12258
	call	DoDebugMsg

; 1502 :         prev_written = curr_written;

	mov	eax, DWORD PTR curr_written$[rsp]
	mov	DWORD PTR prev_written$[rsp], eax

; 1503 : 
; 1504 :         if ( Parse_Pass % 200 == 199 )

	xor	edx, edx
	mov	eax, DWORD PTR Parse_Pass
	mov	ecx, 200				; 000000c8H
	div	ecx
	mov	eax, edx
	cmp	eax, 199				; 000000c7H
	jne	SHORT $LN16@AssembleMo

; 1505 :             EmitWarn( 2, ASSEMBLY_PASSES, Parse_Pass+1 );

	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	r8d, eax
	mov	edx, 240				; 000000f0H
	mov	ecx, 2
	call	EmitWarn
$LN16@AssembleMo:

; 1506 : #ifdef DEBUG_OUT
; 1507 :         if ( Options.max_passes && Parse_Pass == (Options.max_passes - 1) )

	movzx	eax, WORD PTR Options+20
	test	eax, eax
	je	SHORT $LN17@AssembleMo
	movzx	eax, WORD PTR Options+20
	dec	eax
	cmp	DWORD PTR Parse_Pass, eax
	jne	SHORT $LN17@AssembleMo

; 1508 :             break;

	jmp	$LN3@AssembleMo
$LN17@AssembleMo:

; 1509 : #endif
; 1510 :         if ( Options.line_numbers ) {

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	$LN18@AssembleMo

; 1511 : #if COFF_SUPPORT
; 1512 :             if ( Options.output_format == OFORMAT_COFF ) {

	cmp	DWORD PTR Options+160, 2
	jne	SHORT $LN19@AssembleMo

; 1513 :                 for( seg = SymTables[TAB_SEG].head; seg; seg = seg->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR seg$[rsp], rax
	jmp	SHORT $LN10@AssembleMo
$LN8@AssembleMo:
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR seg$[rsp], rax
$LN10@AssembleMo:
	cmp	QWORD PTR seg$[rsp], 0
	je	SHORT $LN9@AssembleMo

; 1514 :                     if ( seg->e.seginfo->LinnumQueue )

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN21@AssembleMo

; 1515 :                         QueueDeleteLinnum( seg->e.seginfo->LinnumQueue );

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR [rax+56]
	call	QueueDeleteLinnum
$LN21@AssembleMo:

; 1516 :                     seg->e.seginfo->LinnumQueue = NULL;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rax+56], 0

; 1517 :                 }

	jmp	SHORT $LN8@AssembleMo
$LN9@AssembleMo:

; 1518 :             } else {

	jmp	SHORT $LN20@AssembleMo
$LN19@AssembleMo:

; 1519 : #endif
; 1520 :                 QueueDeleteLinnum( &LinnumQueue );

	lea	rcx, OFFSET FLAT:LinnumQueue
	call	QueueDeleteLinnum

; 1521 :                 LinnumQueue.head = NULL;

	mov	QWORD PTR LinnumQueue, 0
$LN20@AssembleMo:
$LN18@AssembleMo:

; 1522 : #if COFF_SUPPORT
; 1523 :             }
; 1524 : #endif
; 1525 :         }
; 1526 : 
; 1527 :         /* set file position of ASM and LST files for next pass */
; 1528 : 
; 1529 :         rewind( CurrFile[ASM] );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	rewind

; 1530 :         if ( write_to_file && Options.output_format == OFORMAT_OMF )

	movzx	eax, BYTE PTR write_to_file
	test	eax, eax
	je	SHORT $LN22@AssembleMo
	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN22@AssembleMo

; 1531 :             omf_set_filepos();

	call	omf_set_filepos
$LN22@AssembleMo:

; 1532 : 
; 1533 : #if FASTPASS
; 1534 :         if ( UseSavedState == FALSE && CurrFile[LST] ) {

	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	jne	SHORT $LN23@AssembleMo
	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN23@AssembleMo

; 1535 : #else
; 1536 :         if ( CurrFile[LST] ) {
; 1537 : #endif
; 1538 :             rewind( CurrFile[LST] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	rewind

; 1539 :             LstInit();

	call	LstInit
$LN23@AssembleMo:

; 1540 :         }
; 1541 :     } /* end for() */

	jmp	$LN2@AssembleMo
$LN3@AssembleMo:

; 1542 : 
; 1543 :     if ( ( Parse_Pass > PASS_1 ) && write_to_file )

	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN24@AssembleMo
	movzx	eax, BYTE PTR write_to_file
	test	eax, eax
	je	SHORT $LN24@AssembleMo

; 1544 :         WriteModule( &ModuleInfo );

	lea	rcx, OFFSET FLAT:ModuleInfo
	call	WriteModule
$LN24@AssembleMo:

; 1545 : 
; 1546 :     if ( ModuleInfo.pCodeBuff ) {
; 1547 :         LclFree( ModuleInfo.pCodeBuff );
; 1548 :     }
; 1549 :     DebugMsg(("AssembleModule: finished, cleanup\n"));

	lea	rcx, OFFSET FLAT:$SG12269
	call	DoDebugMsg

; 1550 : 
; 1551 :     /* Write a symbol listing file (if requested) */
; 1552 :     LstWriteCRef();

	call	LstWriteCRef

; 1553 : 
; 1554 :     endtime = clock(); /* is in ms already */

	call	clock
	mov	DWORD PTR endtime$[rsp], eax

; 1555 : 
; 1556 :     sprintf( CurrSource, MsgGetEx( MSG_ASSEMBLY_RESULTS ),

	mov	eax, DWORD PTR starttime$[rsp]
	mov	ecx, DWORD PTR endtime$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv209[rsp], eax
	mov	ecx, DWORD PTR Parse_Pass
	inc	ecx
	mov	DWORD PTR tv211[rsp], ecx
	call	GetLineNumber
	mov	DWORD PTR tv213[rsp], eax
	mov	ecx, DWORD PTR ModuleInfo+428
	call	GetFName
	mov	QWORD PTR tv215[rsp], rax
	mov	ecx, 1
	call	MsgGetEx
	mov	ecx, DWORD PTR ModuleInfo
	mov	DWORD PTR [rsp+56], ecx
	mov	ecx, DWORD PTR ModuleInfo+4
	mov	DWORD PTR [rsp+48], ecx
	mov	ecx, DWORD PTR tv209[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	ecx, DWORD PTR tv211[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	ecx, DWORD PTR tv213[rsp]
	mov	r9d, ecx
	mov	rcx, QWORD PTR tv215[rsp]
	mov	r8, QWORD PTR [rcx]
	mov	rdx, rax
	mov	rcx, QWORD PTR ModuleInfo+464
	call	sprintf

; 1557 :              GetFName( ModuleInfo.srcfile )->fname,
; 1558 :              GetLineNumber(),
; 1559 :              Parse_Pass + 1,
; 1560 :              endtime - starttime,
; 1561 :              ModuleInfo.g.warning_count,
; 1562 :              ModuleInfo.g.error_count);
; 1563 :     if ( Options.quiet == FALSE )

	movzx	eax, BYTE PTR Options
	test	eax, eax
	jne	SHORT $LN26@AssembleMo

; 1564 :         printf( "%s\n", CurrSource );

	mov	rdx, QWORD PTR ModuleInfo+464
	lea	rcx, OFFSET FLAT:$SG12271
	call	printf
$LN26@AssembleMo:

; 1565 : 
; 1566 :     if ( CurrFile[LST] ) {

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN27@AssembleMo

; 1567 :         LstPrintf( CurrSource );

	mov	rcx, QWORD PTR ModuleInfo+464
	call	LstPrintf

; 1568 :         LstNL();

	call	LstNL
$LN27@AssembleMo:
$done$32:

; 1569 :     }
; 1570 : #if 1 //def __SW_BD
; 1571 : done:
; 1572 : #endif
; 1573 :     AssembleFini();

	call	AssembleFini

; 1574 :     DebugMsg(("AssembleModule exit\n"));

	lea	rcx, OFFSET FLAT:$SG12273
	call	DoDebugMsg

; 1575 :     return( ModuleInfo.g.error_count == 0 );

	cmp	DWORD PTR ModuleInfo, 0
	jne	SHORT $LN29@AssembleMo
	mov	DWORD PTR tv264[rsp], 1
	jmp	SHORT $LN30@AssembleMo
$LN29@AssembleMo:
	mov	DWORD PTR tv264[rsp], 0
$LN30@AssembleMo:
	mov	eax, DWORD PTR tv264[rsp]

; 1576 : }

	add	rsp, 136				; 00000088H
	ret	0
AssembleModule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
idx$1 = 32
tv79 = 36
pbytes$ = 64
len$ = 72
fixup$ = 80
OutputBytes PROC

; 301  : {

$LN11:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 302  :     if( write_to_file == TRUE ) {

	movzx	eax, BYTE PTR write_to_file
	cmp	eax, 1
	jne	$LN2@OutputByte

; 303  :         uint_32 idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	DWORD PTR idx$1[rsp], eax

; 304  : #if 0 /* def DEBUG_OUT */
; 305  :         if ( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc )
; 306  :             _asm int 3;
; 307  : #endif
; 308  :         /**/myassert( CurrSeg->e.seginfo->current_loc >= CurrSeg->e.seginfo->start_loc );

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+12], ecx
	jb	SHORT $LN9@OutputByte
	mov	DWORD PTR tv79[rsp], 0
	jmp	SHORT $LN10@OutputByte
$LN9@OutputByte:
	mov	edx, 308				; 00000134H
	lea	rcx, OFFSET FLAT:$SG11855
	call	InternalError
	mov	DWORD PTR tv79[rsp], eax
$LN10@OutputByte:

; 309  :         if( Options.output_format == OFORMAT_OMF && ((idx + len) > MAX_LEDATA_THRESHOLD ) ) {

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN4@OutputByte
	mov	eax, DWORD PTR len$[rsp]
	mov	ecx, DWORD PTR idx$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, 1014				; 000003f6H
	jbe	SHORT $LN4@OutputByte

; 310  :             omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 311  :             idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	DWORD PTR idx$1[rsp], eax
$LN4@OutputByte:

; 312  :         }
; 313  :         if ( fixup )

	cmp	QWORD PTR fixup$[rsp], 0
	je	SHORT $LN5@OutputByte

; 314  :             store_fixup( fixup, CurrSeg, (int_32 *)pbytes );

	mov	r8, QWORD PTR pbytes$[rsp]
	mov	rdx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR fixup$[rsp]
	call	store_fixup
$LN5@OutputByte:

; 315  :         //DebugMsg(("OutputBytes: buff=%p, idx=%" I32_SPEC "X, byte=%X\n", CurrSeg->e.seginfo->CodeBuffer, idx, *pbytes ));
; 316  :         memcpy( &CurrSeg->e.seginfo->CodeBuffer[idx], pbytes, len );

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	edx, DWORD PTR idx$1[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	add	rcx, rdx
	mov	r8, rax
	mov	rdx, QWORD PTR pbytes$[rsp]
	call	memcpy

; 317  :     }

	jmp	SHORT $LN3@OutputByte
$LN2@OutputByte:

; 318  : #if 1
; 319  :     /* check this in pass 1 only */
; 320  :     else if( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+12], ecx
	jae	SHORT $LN6@OutputByte

; 321  :         DebugMsg(("OutputBytes: segment start loc changed from %" I32_SPEC "Xh to %" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	r8d, DWORD PTR [rax+12]
	mov	edx, DWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG11859
	call	DoDebugMsg

; 322  :                   CurrSeg->e.seginfo->start_loc,
; 323  :                   CurrSeg->e.seginfo->current_loc));
; 324  :         CurrSeg->e.seginfo->start_loc = CurrSeg->e.seginfo->current_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+8], eax
$LN6@OutputByte:
$LN3@OutputByte:

; 325  :     }
; 326  : #endif
; 327  :     CurrSeg->e.seginfo->current_loc += len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	add	eax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+12], eax

; 328  :     CurrSeg->e.seginfo->bytes_written += len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+24]
	add	eax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+24], eax

; 329  :     CurrSeg->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+107], al

; 330  :     if( CurrSeg->e.seginfo->current_loc > CurrSeg->sym.max_offset )

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	ecx, DWORD PTR [rcx+56]
	cmp	DWORD PTR [rax+12], ecx
	jbe	SHORT $LN7@OutputByte

; 331  :         CurrSeg->sym.max_offset = CurrSeg->e.seginfo->current_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+56], eax
$LN7@OutputByte:

; 332  : }

	add	rsp, 56					; 00000038H
	ret	0
OutputBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
byte$ = 48
len$ = 56
FillDataBytes PROC

; 287  : {

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 40					; 00000028H

; 288  :     if ( ModuleInfo.CommentDataInCode )

	movzx	eax, BYTE PTR ModuleInfo+423
	test	eax, eax
	je	SHORT $LN5@FillDataBy

; 289  :         omf_OutSelect( TRUE );

	mov	cl, 1
	call	omf_OutSelect
$LN5@FillDataBy:

; 290  :     for( ; len; len-- )

	jmp	SHORT $LN4@FillDataBy
$LN2@FillDataBy:
	mov	eax, DWORD PTR len$[rsp]
	dec	eax
	mov	DWORD PTR len$[rsp], eax
$LN4@FillDataBy:
	cmp	DWORD PTR len$[rsp], 0
	je	SHORT $LN3@FillDataBy

; 291  :         OutputByte( byte );

	movzx	ecx, BYTE PTR byte$[rsp]
	call	OutputByte
	jmp	SHORT $LN2@FillDataBy
$LN3@FillDataBy:

; 292  : }

	add	rsp, 40					; 00000028H
	ret	0
FillDataBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
idx$1 = 32
i$ = 36
tv84 = 40
pBytes$ = 64
len$ = 72
OutputBinBytes PROC

; 237  : {

$LN14:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 238  : 	int i;
; 239  : 
; 240  : 	if (write_to_file == TRUE) {

	movzx	eax, BYTE PTR write_to_file
	cmp	eax, 1
	jne	$LN5@OutputBinB

; 241  : 		uint_32 idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	DWORD PTR idx$1[rsp], eax

; 242  : #ifdef DEBUG_OUT
; 243  : 		if (CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]

; 244  : 			;//_asm int 3;
; 245  : 		}
; 246  : #endif
; 247  : 		/**/myassert(CurrSeg->e.seginfo->current_loc >= CurrSeg->e.seginfo->start_loc);

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+12], ecx
	jb	SHORT $LN12@OutputBinB
	mov	DWORD PTR tv84[rsp], 0
	jmp	SHORT $LN13@OutputBinB
$LN12@OutputBinB:
	mov	edx, 247				; 000000f7H
	lea	rcx, OFFSET FLAT:$SG11829
	call	InternalError
	mov	DWORD PTR tv84[rsp], eax
$LN13@OutputBinB:

; 248  : 		if (Options.output_format == OFORMAT_OMF && idx >= MAX_LEDATA_THRESHOLD) {

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN8@OutputBinB
	cmp	DWORD PTR idx$1[rsp], 1014		; 000003f6H
	jb	SHORT $LN8@OutputBinB

; 249  : 			omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 250  : 			idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	DWORD PTR idx$1[rsp], eax
$LN8@OutputBinB:

; 251  : 		}
; 252  : 		//DebugMsg(("OutputByte: buff=%p, idx=%" I32_SPEC "X, byte=%X, codebuff[0]=%X\n", CurrSeg->e.seginfo->CodeBuffer, idx, byte, *CurrSeg->e.seginfo->CodeBuffer ));
; 253  : 		for (i = 0; i < len; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@OutputBinB
$LN2@OutputBinB:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@OutputBinB:
	mov	eax, DWORD PTR len$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN3@OutputBinB

; 254  : 		{
; 255  : 			CurrSeg->e.seginfo->CodeBuffer[idx++] = *(pBytes++);

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR idx$1[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rdx, QWORD PTR pBytes$[rsp]
	movzx	edx, BYTE PTR [rdx]
	mov	BYTE PTR [rax+rcx], dl
	mov	eax, DWORD PTR idx$1[rsp]
	inc	eax
	mov	DWORD PTR idx$1[rsp], eax
	mov	rax, QWORD PTR pBytes$[rsp]
	inc	rax
	mov	QWORD PTR pBytes$[rsp], rax

; 256  : 		}

	jmp	SHORT $LN2@OutputBinB
$LN3@OutputBinB:

; 257  : 
; 258  : 	}

	jmp	SHORT $LN6@OutputBinB
$LN5@OutputBinB:

; 259  : #if 1
; 260  : 	/* check this in pass 1 only */
; 261  : 	else if (CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+12], ecx
	jae	SHORT $LN9@OutputBinB

; 262  : 		DebugMsg(("OutputByte: segment start loc changed from %" I32_SPEC "Xh to %" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	r8d, DWORD PTR [rax+12]
	mov	edx, DWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG11832
	call	DoDebugMsg

; 263  : 			CurrSeg->e.seginfo->start_loc,
; 264  : 			CurrSeg->e.seginfo->current_loc));
; 265  : 		CurrSeg->e.seginfo->start_loc = CurrSeg->e.seginfo->current_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+8], eax
$LN9@OutputBinB:
$LN6@OutputBinB:

; 266  : 	}
; 267  : #endif
; 268  : 	CurrSeg->e.seginfo->current_loc+=len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	add	eax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+12], eax

; 269  : 	CurrSeg->e.seginfo->bytes_written+=len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+24]
	add	eax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+24], eax

; 270  : 	CurrSeg->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+107], al

; 271  : 	if (CurrSeg->e.seginfo->current_loc > CurrSeg->sym.max_offset)

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	ecx, DWORD PTR [rcx+56]
	cmp	DWORD PTR [rax+12], ecx
	jbe	SHORT $LN10@OutputBinB

; 272  : 		CurrSeg->sym.max_offset = CurrSeg->e.seginfo->current_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+56], eax
$LN10@OutputBinB:

; 273  : }

	add	rsp, 56					; 00000038H
	ret	0
OutputBinBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
idx$1 = 32
tv84 = 36
byte$ = 64
OutputByte PROC

; 203  : {

$LN11:
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 56					; 00000038H

; 204  :     if( write_to_file == TRUE ) {

	movzx	eax, BYTE PTR write_to_file
	cmp	eax, 1
	jne	$LN2@OutputByte

; 205  :         uint_32 idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	DWORD PTR idx$1[rsp], eax

; 206  : #ifdef DEBUG_OUT
; 207  :         if ( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]

; 208  :             ;//_asm int 3;
; 209  :         }
; 210  : #endif
; 211  :         /**/myassert( CurrSeg->e.seginfo->current_loc >= CurrSeg->e.seginfo->start_loc );

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+12], ecx
	jb	SHORT $LN9@OutputByte
	mov	DWORD PTR tv84[rsp], 0
	jmp	SHORT $LN10@OutputByte
$LN9@OutputByte:
	mov	edx, 211				; 000000d3H
	lea	rcx, OFFSET FLAT:$SG11810
	call	InternalError
	mov	DWORD PTR tv84[rsp], eax
$LN10@OutputByte:

; 212  :         if( Options.output_format == OFORMAT_OMF && idx >= MAX_LEDATA_THRESHOLD ) {

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN5@OutputByte
	cmp	DWORD PTR idx$1[rsp], 1014		; 000003f6H
	jb	SHORT $LN5@OutputByte

; 213  :             omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 214  :             idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	DWORD PTR idx$1[rsp], eax
$LN5@OutputByte:

; 215  :         }
; 216  :         //DebugMsg(("OutputByte: buff=%p, idx=%" I32_SPEC "X, byte=%X, codebuff[0]=%X\n", CurrSeg->e.seginfo->CodeBuffer, idx, byte, *CurrSeg->e.seginfo->CodeBuffer ));
; 217  :         CurrSeg->e.seginfo->CodeBuffer[idx] = byte;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR idx$1[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	edx, BYTE PTR byte$[rsp]
	mov	BYTE PTR [rax+rcx], dl

; 218  :     }

	jmp	SHORT $LN3@OutputByte
$LN2@OutputByte:

; 219  : #if 1
; 220  :     /* check this in pass 1 only */
; 221  :     else if( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+12], ecx
	jae	SHORT $LN6@OutputByte

; 222  :         DebugMsg(("OutputByte: segment start loc changed from %" I32_SPEC "Xh to %" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	r8d, DWORD PTR [rax+12]
	mov	edx, DWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG11813
	call	DoDebugMsg

; 223  :                   CurrSeg->e.seginfo->start_loc,
; 224  :                   CurrSeg->e.seginfo->current_loc));
; 225  :         CurrSeg->e.seginfo->start_loc = CurrSeg->e.seginfo->current_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+8], eax
$LN6@OutputByte:
$LN3@OutputByte:

; 226  :     }
; 227  : #endif
; 228  :     CurrSeg->e.seginfo->current_loc++;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	inc	eax
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+12], eax

; 229  :     CurrSeg->e.seginfo->bytes_written++;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+24]
	inc	eax
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+24], eax

; 230  :     CurrSeg->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+107], al

; 231  :     if( CurrSeg->e.seginfo->current_loc > CurrSeg->sym.max_offset )

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	ecx, DWORD PTR [rcx+56]
	cmp	DWORD PTR [rax+12], ecx
	jbe	SHORT $LN7@OutputByte

; 232  :         CurrSeg->sym.max_offset = CurrSeg->e.seginfo->current_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+56], eax
$LN7@OutputByte:

; 233  : }

	add	rsp, 56					; 00000038H
	ret	0
OutputByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1788 : }

	add	rsp, 56					; 00000038H
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

	add	rsp, 56					; 00000038H
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	__stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1391 : }

	add	rsp, 72					; 00000048H
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 950  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 957  : }

	add	rsp, 56					; 00000038H
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 640  : }

	add	rsp, 56					; 00000038H
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
