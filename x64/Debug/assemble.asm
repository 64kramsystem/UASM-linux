; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	jmpenv
EXTRN	omf_init:PROC
EXTRN	coff_init:PROC
EXTRN	elf_init:PROC
EXTRN	bin_init:PROC
_BSS	SEGMENT
jmpenv	DB	0100H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	LinnumQueue:BYTE:010H
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	ModuleInfo:BYTE:0308H
COMM	Parse_Pass:DWORD
COMM	write_to_file:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11729 DB	'_TEXT', 00H
?PrintEmptyLine@?1??WritePreprocessedLine@@9@9 DB 01H	; `WritePreprocessedLine'::`2'::PrintEmptyLine
	ORG $+1
$SG11730 DB	'.text', 00H
	ORG $+2
$SG11731 DB	'_DATA', 00H
	ORG $+2
$SG11732 DB	'.data', 00H
	ORG $+2
$SG11733 DB	'CONST', 00H
	ORG $+2
$SG11734 DB	'.rdata', 00H
	ORG $+1
$SG11735 DB	'_BSS', 00H
	ORG $+3
$SG11736 DB	'.bss', 00H
	ORG $+3
$SG11766 DB	'assemble.c', 00H
	ORG $+1
$SG11859 DB	'w', 00H
	ORG $+2
$SG11769 DB	'OutputByte: segment start loc changed from %Xh to %Xh', 0aH
	DB	00H
	ORG $+1
$SG11786 DB	'assemble.c', 00H
	ORG $+1
$SG11931 DB	'%s', 0aH, 00H
$SG11789 DB	'OutputByte: segment start loc changed from %Xh to %Xh', 0aH
	DB	00H
	ORG $+1
$SG11812 DB	'assemble.c', 00H
	ORG $+1
$SG11933 DB	0aH, 00H
	ORG $+2
$SG11816 DB	'OutputBytes: segment start loc changed from %Xh to %Xh', 0aH
	DB	00H
$SG11854 DB	'WriteModule enter', 0aH, 00H
	ORG $+1
$SG12095 DB	'rb', 00H
	ORG $+1
$SG11861 DB	'WriteModule: ext=%s, isproc=%u, weak=%u', 0aH, 00H
	ORG $+3
$SG11957 DB	'%r %s', 00H
	ORG $+2
$SG12099 DB	'wb', 00H
	ORG $+1
$SG11864 DB	'import ''%s''  %s.%s', 0aH, 00H
$SG12104 DB	'wb', 00H
	ORG $+1
$SG11866 DB	'WriteModule exit', 0aH, 00H
	ORG $+2
$SG12137 DB	'EXE', 00H
$SG11891 DB	'add_cmdline_tmacros enter', 0aH, 00H
	ORG $+1
$SG12138 DB	'BIN', 00H
$SG11892 DB	'add_cmdline_tmacros: found >%s<', 0aH, 00H
	ORG $+3
$SG12139 DB	'obj', 00H
$SG11897 DB	'add_cmdline_tmacros: name >%s< invalid', 0aH, 00H
$SG11908 DB	'add_incpaths: enter', 0aH, 00H
	ORG $+3
$SG11914 DB	'CmdlParamsInit(%u) enter', 0aH, 00H
	ORG $+2
$SG12141 DB	'lst', 00H
$SG11918 DB	'INCLUDE', 00H
$SG11919 DB	'CmdlParamsInit exit', 0aH, 00H
	ORG $+3
$SG11949 DB	'ModulePassInit() enter', 0aH, 00H
$SG12006 DB	'PassOneChecks: undefined symbol %s', 0aH, 00H
$SG12143 DB	'err', 00H
$SG12011 DB	'PassOneChecks: public for weak external skipped: %s', 0aH
	DB	00H
	ORG $+3
$SG12015 DB	'PassOneChecks: undefined segment %s', 0aH, 00H
	ORG $+3
$SG12012 DB	'PassOneChecks: invalid public attribute for %s [state=%u'
	DB	' weak=%u]', 0aH, 00H
	ORG $+1
$SG12227 DB	'%s', 0aH, 00H
$SG12033 DB	'PassOneChecks: removed unused externals: %u', 0aH, 00H
	ORG $+3
$SG12034 DB	'PassOneChecks: forward references:', 0aH, 00H
	ORG $+4
$SG12035 DB	'PassOneChecks: segm=%s, labels=%u forward refs=%u', 0aH, 00H
	ORG $+1
$SG12055 DB	'NULL', 00H
	ORG $+7
$SG12056 DB	'OnePass(%u) segments (current=%s):', 0aH, 00H
	ORG $+4
$SG12057 DB	'OnePass(%u): segm=%-8s typ=%X start=%8X max_ofs=%8X', 0aH
	DB	00H
	ORG $+3
$SG12061 DB	'OnePass(%u) cur/nxt=%X/%X src=%X.%u mlvl=%u: >%s<', 0aH, 00H
	ORG $+5
$SG12063 DB	'OnePass: force include of file: %s', 0aH, 00H
	ORG $+4
$SG12087 DB	'ReswTableInit: disable INCBIN + FASTCALL keywords', 0aH, 00H
	ORG $+5
$SG12094 DB	'open_files() enter', 0aH, 00H
	ORG $+4
$SG12097 DB	'open_files(): cannot open source file, fopen("%s") faile'
	DB	'd', 0aH, 00H
	ORG $+5
$SG12101 DB	'open_files(): cannot open object file, fopen("%s") faile'
	DB	'd', 0aH, 00H
	ORG $+5
$SG12102 DB	'open_files(): output, fopen("%s") ok', 0aH, 00H
	ORG $+2
$SG12159 DB	'SetFilenames("%s") enter', 0aH, 00H
	ORG $+6
$SG12165 DB	'SetFilenames: i=%u >%s<', 0aH, 00H
	ORG $+7
$SG12171 DB	'AssembleInit("%s") enter', 0aH, 00H
	ORG $+6
$SG12172 DB	'AssembleInit() exit', 0aH, 00H
	ORG $+3
$SG12203 DB	'AssembleModule("%s") enter', 0aH, 00H
	ORG $+4
$SG12206 DB	'*************', 0aH, 'pass %u', 0aH, '*************', 0aH
	DB	00H
	ORG $+3
$SG12208 DB	'AssembleModule(%u): errorcnt=%u', 0aH, 00H
	ORG $+7
$SG12209 DB	'AssembleModule(%u): segm=%-8s start=%8X max_ofs=%8X writ'
	DB	'ten=%X', 0aH, 00H
$SG12210 DB	'AssembleModule(%u): PhaseError=%u, prev_written=%X, curr'
	DB	'_written=%X', 0aH, 00H
	ORG $+3
$SG12213 DB	'size shrank from %X to %X in pass %u', 0aH, 00H
	ORG $+2
$SG12214 DB	'AssembleModule(%u): prepare for next pass', 0aH, 00H
	ORG $+5
$SG12225 DB	'AssembleModule: finished, cleanup', 0aH, 00H
	ORG $+5
$SG12229 DB	'AssembleModule exit', 0aH, 00H
_DATA	ENDS
CONST	SEGMENT
formatoptions DQ FLAT:bin_init
	DW	00H
	DB	'BIN', 00H
	ORG $+2
	DQ	FLAT:omf_init
	DW	00H
	DB	'OMF', 00H
	ORG $+2
	DQ	FLAT:coff_init
	DW	0e12H
	DB	'COFF', 00H
	ORG $+1
	DQ	FLAT:elf_init
	DW	0f00H
	DB	'ELF', 00H
	ORG $+2
cst	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11729
	DQ	FLAT:$SG11730
	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11731
	DQ	FLAT:$SG11732
	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11733
	DQ	FLAT:$SG11734
	DB	04H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG11735
	DQ	FLAT:$SG11736
stt	DD	01H
	DD	02H
	DD	02H
	DD	03H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	OutputByte
PUBLIC	FillDataBytes
PUBLIC	OutputBytes
PUBLIC	AssembleModule
PUBLIC	SetMasm510
PUBLIC	close_files
PUBLIC	ConvertSectionName
PUBLIC	WritePreprocessedLine
PUBLIC	SetCurrOffset
PUBLIC	OutputBinBytes
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isalpha:PROC
EXTRN	__imp_isdigit:PROC
EXTRN	__imp_isspace:PROC
EXTRN	__imp_isalnum:PROC
EXTRN	__imp_clock:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp_remove:PROC
EXTRN	__imp_rewind:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_getenv:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__imp_strchr:PROC
EXTRN	strcat:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	__imp__strupr:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	Fatal:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	ErrnoStr:PROC
EXTRN	WriteError:PROC
EXTRN	MemInit:PROC
EXTRN	MemFini:PROC
EXTRN	LclAlloc:PROC
EXTRN	GetLineNumber:PROC
EXTRN	GetFNamePart:PROC
EXTRN	GetExtPart:PROC
EXTRN	SearchFile:PROC
EXTRN	AddStringToIncludePath:PROC
EXTRN	InputInit:PROC
EXTRN	InputPassInit:PROC
EXTRN	InputFini:PROC
EXTRN	ClearSrcStack:PROC
EXTRN	set_curr_srcfile:PROC
EXTRN	GetFName:PROC
EXTRN	SymCreate:PROC
EXTRN	SymFind:PROC
EXTRN	SymInit:PROC
EXTRN	SymFini:PROC
EXTRN	SymPassInit:PROC
EXTRN	SymMakeAllSymbolsPublic:PROC
EXTRN	SymSetCmpFunc:PROC
EXTRN	sym_remove_table:PROC
EXTRN	ParseLine:PROC
EXTRN	ProcessFile:PROC
EXTRN	DisableKeyword:PROC
EXTRN	ResWordsInit:PROC
EXTRN	ResWordsFini:PROC
EXTRN	Tokenize:PROC
EXTRN	CondCheckOpen:PROC
EXTRN	CondInit:PROC
EXTRN	SegmentInit:PROC
EXTRN	SegmentFini:PROC
EXTRN	AssumeInit:PROC
EXTRN	ProcInit:PROC
EXTRN	ExprEvalInit:PROC
EXTRN	HllInit:PROC
EXTRN	HllCheckOpen:PROC
EXTRN	ContextInit:PROC
EXTRN	TypesInit:PROC
EXTRN	LabelInit:PROC
EXTRN	MacroInit:PROC
EXTRN	MacroFini:PROC
EXTRN	FreePubQueue:PROC
EXTRN	store_fixup:PROC
EXTRN	omf_set_filepos:PROC
EXTRN	omf_OutSelect:PROC
EXTRN	omf_FlushCurrSeg:PROC
EXTRN	FastpassInit:PROC
EXTRN	SkipSavedState:PROC
EXTRN	RestoreState:PROC
EXTRN	LstInit:PROC
EXTRN	LstWriteCRef:PROC
EXTRN	LstPrintf:PROC
EXTRN	LstNL:PROC
EXTRN	MsgGetEx:PROC
EXTRN	InternalError:PROC
EXTRN	LinnumInit:PROC
EXTRN	LinnumFini:PROC
EXTRN	QueueDeleteLinnum:PROC
EXTRN	SetCPU:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	RunLineQueue:PROC
EXTRN	Mangle:PROC
EXTRN	DumpInstrStats:PROC
EXTRN	_RTC_AllocaHelper:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_CheckStackVars2:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	_setjmp:PROC
EXTRN	Options:BYTE
EXTRN	MacroLevel:BYTE
EXTRN	SymTables:BYTE
EXTRN	LineStoreCurr:QWORD
EXTRN	StoreState:BYTE
EXTRN	UseSavedState:BYTE
EXTRN	LastCodeBufSize:DWORD
EXTRN	DefaultDir:BYTE
EXTRN	ModelToken:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$OutputByte DD imagerel $LN11
	DD	imagerel $LN11+498
	DD	imagerel $unwind$OutputByte
$pdata$FillDataBytes DD imagerel $LN7
	DD	imagerel $LN7+88
	DD	imagerel $unwind$FillDataBytes
$pdata$OutputBytes DD imagerel $LN11
	DD	imagerel $LN11+539
	DD	imagerel $unwind$OutputBytes
$pdata$AssembleModule DD imagerel $LN31
	DD	imagerel $LN31+1227
	DD	imagerel $unwind$AssembleModule
$pdata$SetMasm510 DD imagerel $LN6
	DD	imagerel $LN6+197
	DD	imagerel $unwind$SetMasm510
$pdata$close_files DD imagerel $LN12
	DD	imagerel $LN12+502
	DD	imagerel $unwind$close_files
$pdata$ConvertSectionName DD imagerel $LN13
	DD	imagerel $LN13+466
	DD	imagerel $unwind$ConvertSectionName
$pdata$WritePreprocessedLine DD imagerel $LN11
	DD	imagerel $LN11+186
	DD	imagerel $unwind$WritePreprocessedLine
$pdata$SetCurrOffset DD imagerel $LN15
	DD	imagerel $LN15+318
	DD	imagerel $unwind$SetCurrOffset
$pdata$OutputBinBytes DD imagerel $LN14
	DD	imagerel $LN14+565
	DD	imagerel $unwind$OutputBinBytes
$pdata$WriteModule DD imagerel WriteModule
	DD	imagerel WriteModule+701
	DD	imagerel $unwind$WriteModule
$pdata$is_valid_identifier DD imagerel is_valid_identifier
	DD	imagerel is_valid_identifier+328
	DD	imagerel $unwind$is_valid_identifier
$pdata$add_cmdline_tmacros DD imagerel add_cmdline_tmacros
	DD	imagerel add_cmdline_tmacros+564
	DD	imagerel $unwind$add_cmdline_tmacros
$pdata$add_incpaths DD imagerel add_incpaths
	DD	imagerel add_incpaths+106
	DD	imagerel $unwind$add_incpaths
$pdata$CmdlParamsInit DD imagerel CmdlParamsInit
	DD	imagerel CmdlParamsInit+126
	DD	imagerel $unwind$CmdlParamsInit
$pdata$ModulePassInit DD imagerel ModulePassInit
	DD	imagerel ModulePassInit+647
	DD	imagerel $unwind$ModulePassInit
$pdata$PassOneChecks DD imagerel PassOneChecks
	DD	imagerel PassOneChecks+1382
	DD	imagerel $unwind$PassOneChecks
$pdata$OnePass DD imagerel OnePass
	DD	imagerel OnePass+927
	DD	imagerel $unwind$OnePass
$pdata$get_module_name DD imagerel get_module_name
	DD	imagerel get_module_name+408
	DD	imagerel $unwind$get_module_name
$pdata$ModuleInit DD imagerel ModuleInit
	DD	imagerel ModuleInit+257
	DD	imagerel $unwind$ModuleInit
$pdata$ReswTableInit DD imagerel ReswTableInit
	DD	imagerel ReswTableInit+105
	DD	imagerel $unwind$ReswTableInit
$pdata$open_files DD imagerel open_files
	DD	imagerel open_files+503
	DD	imagerel $unwind$open_files
$pdata$GetExt DD imagerel GetExt
	DD	imagerel GetExt+137
	DD	imagerel $unwind$GetExt
$pdata$SetFilenames DD imagerel SetFilenames
	DD	imagerel SetFilenames+676
	DD	imagerel $unwind$SetFilenames
$pdata$AssembleInit DD imagerel AssembleInit
	DD	imagerel AssembleInit+143
	DD	imagerel $unwind$AssembleInit
$pdata$AssembleFini DD imagerel AssembleFini
	DD	imagerel AssembleFini+121
	DD	imagerel $unwind$AssembleFini
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
add_cmdline_tmacros$rtcName$0 DB 05fH
	DB	05fH
	DB	024H
	DB	041H
	DB	06cH
	DB	06cH
	DB	06fH
	DB	063H
	DB	061H
	DB	050H
	DB	061H
	DB	064H
	DB	024H
	DB	00H
	ORG $+2
add_cmdline_tmacros$rtcVarDesc DD 058H
	DD	08H
	DQ	FLAT:add_cmdline_tmacros$rtcName$0
	ORG $+48
add_cmdline_tmacros$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:add_cmdline_tmacros$rtcVarDesc
SetFilenames$rtcName$0 DB 070H
	DB	061H
	DB	074H
	DB	068H
	DB	00H
	ORG $+3
SetFilenames$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:SetFilenames$rtcVarDesc
	ORG $+8
SetFilenames$rtcVarDesc DD 050H
	DD	0104H
	DQ	FLAT:SetFilenames$rtcName$0
CONST	ENDS
xdata	SEGMENT
$unwind$OutputByte DD 021d01H
	DD	070055209H
$unwind$FillDataBytes DD 022101H
	DD	07009320dH
$unwind$OutputBytes DD 022701H
	DD	0700f5213H
$unwind$AssembleModule DD 022401H
	DD	07006f20dH
$unwind$SetMasm510 DD 010501H
	DD	07005H
$unwind$close_files DD 021501H
	DD	070023206H
$unwind$ConvertSectionName DD 022801H
	DD	070105214H
$unwind$WritePreprocessedLine DD 021e01H
	DD	07006520aH
$unwind$SetCurrOffset DD 022c01H
	DD	070143218H
$unwind$OutputBinBytes DD 022201H
	DD	0700a520eH
$unwind$WriteModule DD 021e01H
	DD	07006920aH
$unwind$is_valid_identifier DD 021e01H
	DD	07006520aH
$unwind$add_cmdline_tmacros DD 025052c19H
	DD	010a230fH
	DD	070030011H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	078H
$unwind$add_incpaths DD 021501H
	DD	070025206H
$unwind$CmdlParamsInit DD 021c01H
	DD	070055209H
$unwind$ModulePassInit DD 021501H
	DD	070025206H
$unwind$PassOneChecks DD 021501H
	DD	07002d206H
$unwind$OnePass DD 021501H
	DD	07002b206H
$unwind$get_module_name DD 021501H
	DD	070027206H
$unwind$ModuleInit DD 021501H
	DD	070025206H
$unwind$ReswTableInit DD 021501H
	DD	070023206H
$unwind$open_files DD 021501H
	DD	070023206H
$unwind$GetExt DD 021c01H
	DD	070051209H
$unwind$SetFilenames DD 033619H
	DD	032010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0180H
$unwind$AssembleInit DD 021e01H
	DD	07006320aH
$unwind$AssembleFini DD 021501H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
printf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
printf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:printf$rtcName$0
	ORG $+48
printf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:printf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
i$ = 32
AssembleFini PROC

; 1389 : {

	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1390 :     int i;
; 1391 :     SegmentFini();

	call	SegmentFini

; 1392 :     SymFini();

	call	SymFini

; 1393 :     ResWordsFini();

	call	ResWordsFini

; 1394 : #ifdef DEBUG_OUT
; 1395 :     DumpInstrStats();

	call	DumpInstrStats

; 1396 :     MacroFini();

	call	MacroFini

; 1397 : #endif
; 1398 :     FreePubQueue();

	call	FreePubQueue

; 1399 : #if FASTMEM==0
; 1400 :     FreeLibQueue();
; 1401 :     ContextFini();
; 1402 :     HllFini();
; 1403 : #endif
; 1404 :     InputFini();

	call	InputFini

; 1405 :     close_files();

	call	close_files

; 1406 : 
; 1407 : #if FASTPASS
; 1408 : #if FASTMEM==0
; 1409 :     FreeLineStore();
; 1410 : #endif
; 1411 : #endif
; 1412 : 
; 1413 :     for ( i = 0; i < NUM_FILE_TYPES; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@AssembleFi
$LN2@AssembleFi:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@AssembleFi:
	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN3@AssembleFi

; 1414 :         LclFree( CurrFName[i] );
; 1415 :         /* v2.05: make sure the pointer for ERR is cleared */
; 1416 :         CurrFName[i] = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	QWORD PTR [rcx+rax*8], 0

; 1417 :     }

	jmp	SHORT $LN2@AssembleFi
$LN3@AssembleFi:

; 1418 :     MemFini();

	call	MemFini

; 1419 :     return;
; 1420 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
AssembleFini ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
source$ = 48
AssembleInit PROC

; 1349 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 1350 :     DebugMsg(("AssembleInit(\"%s\") enter\n", source ));

	mov	rdx, QWORD PTR source$[rsp]
	lea	rcx, OFFSET FLAT:$SG12171
	call	DoDebugMsg

; 1351 : 
; 1352 :     MemInit();

	call	MemInit

; 1353 :     //start_label   = NULL;
; 1354 :     //start_displ   = 0;
; 1355 :     write_to_file = FALSE;

	mov	BYTE PTR write_to_file, 0

; 1356 :     //GeneratedCode = 0;
; 1357 :     LinnumQueue.head = NULL;

	mov	QWORD PTR LinnumQueue, 0

; 1358 : 
; 1359 :     SetFilenames( source );

	mov	rcx, QWORD PTR source$[rsp]
	call	SetFilenames

; 1360 : 
; 1361 : #if FASTPASS
; 1362 :     FastpassInit();

	call	FastpassInit

; 1363 : #endif
; 1364 :     open_files();

	call	open_files

; 1365 : #if BUILD_TARGET
; 1366 :     get_os_include();
; 1367 : #endif
; 1368 :     ReswTableInit();

	call	ReswTableInit

; 1369 :     SymInit();

	call	SymInit

; 1370 :     InputInit();

	call	InputInit

; 1371 : 
; 1372 :     ModuleInit();

	call	ModuleInit

; 1373 :     CondInit();

	call	CondInit

; 1374 :     ExprEvalInit();

	call	ExprEvalInit

; 1375 :     LstInit();

	call	LstInit

; 1376 : 
; 1377 :     DebugMsg(("AssembleInit() exit\n"));

	lea	rcx, OFFSET FLAT:$SG12172
	call	DoDebugMsg

; 1378 :     return;
; 1379 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
AssembleInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
i$ = 32
fn$ = 40
ext$ = 48
path$ = 80
fn2$4 = 360
$T5 = 376
__$ArrayPad$ = 384
name$ = 416
SetFilenames PROC

; 1301 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 400				; 00000190H
	mov	rdi, rsp
	mov	ecx, 100				; 00000064H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+416]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1302 :     int i;
; 1303 :     const char *fn;
; 1304 :     char *ext;
; 1305 :     char path[ FILENAME_MAX ];
; 1306 : 
; 1307 :     DebugMsg(("SetFilenames(\"%s\") enter\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG12159
	call	DoDebugMsg

; 1308 : 
; 1309 :     /* set CurrFName[ASM] */
; 1310 :     CurrFName[ASM] = LclAlloc( strlen( name ) + 1 );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	inc	rax
	mov	rcx, rax
	call	LclAlloc
	mov	ecx, 8
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:ModuleInfo+128
	mov	QWORD PTR [rdx+rcx], rax

; 1311 :     strcpy( CurrFName[ASM], name );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	strcpy

; 1312 : 
; 1313 :     /* set [OBJ], [ERR], [LST] */
; 1314 :     fn = GetFNamePart( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	GetFNamePart
	mov	QWORD PTR fn$[rsp], rax

; 1315 :     for ( i = ASM+1; i < NUM_FILE_TYPES; i++ ) {

	mov	DWORD PTR i$[rsp], 1
	jmp	SHORT $LN4@SetFilenam
$LN2@SetFilenam:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SetFilenam:
	cmp	DWORD PTR i$[rsp], 4
	jge	$LN3@SetFilenam

; 1316 :         if( Options.names[i] == NULL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax*8], 0
	jne	$LN5@SetFilenam

; 1317 :             path[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	QWORD PTR $T5[rsp], rax
	cmp	QWORD PTR $T5[rsp], 260			; 00000104H
	jae	SHORT $LN11@SetFilenam
	jmp	SHORT $LN12@SetFilenam
$LN11@SetFilenam:
	call	__report_rangecheckfailure
$LN12@SetFilenam:
	mov	rax, QWORD PTR $T5[rsp]
	mov	BYTE PTR path$[rsp+rax], 0

; 1318 :             if ( DefaultDir[i])

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN7@SetFilenam

; 1319 :                 strcpy( path, DefaultDir[i] );

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR path$[rsp]
	call	strcpy
$LN7@SetFilenam:

; 1320 :             strcat( path, fn );

	mov	rdx, QWORD PTR fn$[rsp]
	lea	rcx, QWORD PTR path$[rsp]
	call	strcat

; 1321 :             ext = GetExtPart( path );

	lea	rcx, QWORD PTR path$[rsp]
	call	GetExtPart
	mov	QWORD PTR ext$[rsp], rax

; 1322 :             *ext++  = '.';

	mov	rax, QWORD PTR ext$[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH
	mov	rax, QWORD PTR ext$[rsp]
	inc	rax
	mov	QWORD PTR ext$[rsp], rax

; 1323 :             strcpy( ext, GetExt( i ) );

	mov	ecx, DWORD PTR i$[rsp]
	call	GetExt
	mov	rdx, rax
	mov	rcx, QWORD PTR ext$[rsp]
	call	strcpy

; 1324 : 
; 1325 :         } else {

	jmp	$LN6@SetFilenam
$LN5@SetFilenam:

; 1326 :             /* filename has been set by cmdline option -Fo, -Fl or -Fr */
; 1327 :             const char *fn2;
; 1328 :             strcpy( path, Options.names[i] );

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR path$[rsp]
	call	strcpy

; 1329 :             fn2 = GetFNamePart( path );

	lea	rcx, QWORD PTR path$[rsp]
	call	GetFNamePart
	mov	QWORD PTR fn2$4[rsp], rax

; 1330 :             if( *fn2 == NULLC )

	mov	rax, QWORD PTR fn2$4[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN8@SetFilenam

; 1331 :                 strcpy( (char *)fn2, fn );

	mov	rdx, QWORD PTR fn$[rsp]
	mov	rcx, QWORD PTR fn2$4[rsp]
	call	strcpy
$LN8@SetFilenam:

; 1332 :             ext = GetExtPart( fn2 );

	mov	rcx, QWORD PTR fn2$4[rsp]
	call	GetExtPart
	mov	QWORD PTR ext$[rsp], rax

; 1333 :             if( *ext == NULLC ) {

	mov	rax, QWORD PTR ext$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN9@SetFilenam

; 1334 :                 *ext++  = '.';

	mov	rax, QWORD PTR ext$[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH
	mov	rax, QWORD PTR ext$[rsp]
	inc	rax
	mov	QWORD PTR ext$[rsp], rax

; 1335 :                 strcpy( ext, GetExt( i ) );

	mov	ecx, DWORD PTR i$[rsp]
	call	GetExt
	mov	rdx, rax
	mov	rcx, QWORD PTR ext$[rsp]
	call	strcpy
$LN9@SetFilenam:
$LN6@SetFilenam:

; 1336 :             }
; 1337 :         }
; 1338 :         DebugMsg(("SetFilenames: i=%u >%s<\n", i, path ));

	lea	r8, QWORD PTR path$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG12165
	call	DoDebugMsg

; 1339 :         CurrFName[i] = LclAlloc( strlen( path ) + 1 );

	lea	rcx, QWORD PTR path$[rsp]
	call	strlen
	inc	rax
	mov	rcx, rax
	call	LclAlloc
	movsxd	rcx, DWORD PTR i$[rsp]
	lea	rdx, OFFSET FLAT:ModuleInfo+128
	mov	QWORD PTR [rdx+rcx*8], rax

; 1340 :         strcpy( CurrFName[i], path );

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	lea	rdx, QWORD PTR path$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	strcpy

; 1341 :     }

	jmp	$LN2@SetFilenam
$LN3@SetFilenam:
$LN10@SetFilenam:

; 1342 :     return;
; 1343 : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:SetFilenames$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 400				; 00000190H
	pop	rdi
	ret	0
SetFilenames ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
tv64 = 0
type$ = 32
GetExt	PROC

; 1265 : {

	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+32]

; 1266 :     switch ( type ) {

	mov	eax, DWORD PTR type$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 1
	je	SHORT $LN4@GetExt
	cmp	DWORD PTR tv64[rsp], 2
	je	SHORT $LN9@GetExt
	cmp	DWORD PTR tv64[rsp], 3
	je	SHORT $LN10@GetExt
	jmp	SHORT $LN2@GetExt
$LN4@GetExt:

; 1267 :     case OBJ:
; 1268 : #if BIN_SUPPORT
; 1269 :         if ( Options.output_format == OFORMAT_BIN )

	cmp	DWORD PTR Options+160, 0
	jne	SHORT $LN5@GetExt

; 1270 : #if MZ_SUPPORT || PE_SUPPORT
; 1271 :             if ( Options.sub_format == SFORMAT_MZ
; 1272 : #if PE_SUPPORT
; 1273 :                 || Options.sub_format == SFORMAT_PE

	cmp	DWORD PTR Options+164, 1
	je	SHORT $LN8@GetExt
	cmp	DWORD PTR Options+164, 2
	jne	SHORT $LN6@GetExt
$LN8@GetExt:

; 1274 : #endif
; 1275 :                )
; 1276 :                 return( EXE_EXT );

	lea	rax, OFFSET FLAT:$SG12137
	jmp	SHORT $LN1@GetExt
	jmp	SHORT $LN7@GetExt
$LN6@GetExt:

; 1277 :             else
; 1278 : #endif
; 1279 :                 return( BIN_EXT );

	lea	rax, OFFSET FLAT:$SG12138
	jmp	SHORT $LN1@GetExt
$LN7@GetExt:
$LN5@GetExt:

; 1280 : #endif
; 1281 :         return( OBJ_EXT );

	lea	rax, OFFSET FLAT:$SG12139
	jmp	SHORT $LN1@GetExt
$LN9@GetExt:

; 1282 :     case LST:
; 1283 :         return( LST_EXT );

	lea	rax, OFFSET FLAT:$SG12141
	jmp	SHORT $LN1@GetExt
$LN10@GetExt:

; 1284 :     case ERR:
; 1285 :         return( ERR_EXT );

	lea	rax, OFFSET FLAT:$SG12143
	jmp	SHORT $LN1@GetExt
$LN2@GetExt:

; 1286 :     }
; 1287 :     return( NULL );

	xor	eax, eax
$LN1@GetExt:

; 1288 : }

	add	rsp, 16
	pop	rdi
	ret	0
GetExt	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
open_files PROC

; 1189 : {

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1190 :     /* open ASM file */
; 1191 :     DebugMsg(("open_files() enter\n" ));

	lea	rcx, OFFSET FLAT:$SG12094
	call	DoDebugMsg

; 1192 : 
; 1193 :     //memset( CurrFile, 0, sizeof( CurrFile ) );
; 1194 :     /* CurrFile[ASM] = fopen( CurrFName[ASM], "r" ); */
; 1195 :     CurrFile[ASM] = fopen( CurrFName[ASM], "rb" );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	lea	rdx, OFFSET FLAT:$SG12095
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_fopen
	mov	ecx, 8
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR [rdx+rcx], rax

; 1196 :     if( CurrFile[ASM] == NULL ) {

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	jne	SHORT $LN2@open_files

; 1197 :         DebugMsg(("open_files(): cannot open source file, fopen(\"%s\") failed\n", CurrFName[ASM] ));

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12097
	call	DoDebugMsg

; 1198 :         Fatal( CANNOT_OPEN_FILE, CurrFName[ASM], ErrnoStr() );

	call	ErrnoStr
	mov	ecx, 8
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:ModuleInfo+128
	mov	r8, rax
	mov	rdx, QWORD PTR [rdx+rcx]
	mov	ecx, 106				; 0000006aH
	call	Fatal
$LN2@open_files:

; 1199 :     }
; 1200 : 
; 1201 :     /* open OBJ file */
; 1202 :     if ( Options.syntax_check_only == FALSE ) {

	movzx	eax, BYTE PTR Options+188
	test	eax, eax
	jne	$LN3@open_files

; 1203 :         CurrFile[OBJ] = fopen( CurrFName[OBJ], "wb" );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	lea	rdx, OFFSET FLAT:$SG12099
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_fopen
	mov	ecx, 8
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR [rdx+rcx], rax

; 1204 :         if( CurrFile[OBJ] == NULL ) {

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	jne	SHORT $LN4@open_files

; 1205 :             DebugMsg(("open_files(): cannot open object file, fopen(\"%s\") failed\n", CurrFName[OBJ] ));

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12101
	call	DoDebugMsg

; 1206 :             Fatal( CANNOT_OPEN_FILE, CurrFName[OBJ], ErrnoStr() );

	call	ErrnoStr
	mov	ecx, 8
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:ModuleInfo+128
	mov	r8, rax
	mov	rdx, QWORD PTR [rdx+rcx]
	mov	ecx, 106				; 0000006aH
	call	Fatal
$LN4@open_files:

; 1207 :         }
; 1208 :         DebugMsg(("open_files(): output, fopen(\"%s\") ok\n", CurrFName[OBJ] ));

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12102
	call	DoDebugMsg
$LN3@open_files:

; 1209 :     }
; 1210 : 
; 1211 :     if( Options.write_listing ) {

	movzx	eax, BYTE PTR Options+137
	test	eax, eax
	je	SHORT $LN5@open_files

; 1212 :         CurrFile[LST] = fopen( CurrFName[LST], "wb" );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	lea	rdx, OFFSET FLAT:$SG12104
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_fopen
	mov	ecx, 8
	imul	rcx, rcx, 2
	lea	rdx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR [rdx+rcx], rax

; 1213 :         if ( CurrFile[LST] == NULL )

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	jne	SHORT $LN6@open_files

; 1214 :             Fatal( CANNOT_OPEN_FILE, CurrFName[LST], ErrnoStr() );

	call	ErrnoStr
	mov	ecx, 8
	imul	rcx, rcx, 2
	lea	rdx, OFFSET FLAT:ModuleInfo+128
	mov	r8, rax
	mov	rdx, QWORD PTR [rdx+rcx]
	mov	ecx, 106				; 0000006aH
	call	Fatal
$LN6@open_files:
$LN5@open_files:

; 1215 :     }
; 1216 :     return;
; 1217 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
open_files ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
ReswTableInit PROC

; 1165 : {

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1166 :     ResWordsInit();

	call	ResWordsInit

; 1167 :     if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN2@ReswTableI

; 1168 :         /* DebugMsg(("InitAsm: disable IMAGEREL+SECTIONREL\n")); */
; 1169 :         /* for OMF, IMAGEREL and SECTIONREL are disabled */
; 1170 : #if IMAGERELSUPP
; 1171 :         DisableKeyword( T_IMAGEREL );

	mov	ecx, 233				; 000000e9H
	call	DisableKeyword

; 1172 : #endif
; 1173 : #if SECTIONRELSUPP
; 1174 :         DisableKeyword( T_SECTIONREL );

	mov	ecx, 243				; 000000f3H
	call	DisableKeyword
$LN2@ReswTableI:

; 1175 : #endif
; 1176 :     }
; 1177 : 
; 1178 :     if ( Options.strict_masm_compat == TRUE ) {

	movzx	eax, BYTE PTR Options+143
	cmp	eax, 1
	jne	SHORT $LN3@ReswTableI

; 1179 :         DebugMsg(("ReswTableInit: disable INCBIN + FASTCALL keywords\n"));

	lea	rcx, OFFSET FLAT:$SG12087
	call	DoDebugMsg

; 1180 :         DisableKeyword( T_INCBIN );

	mov	ecx, 444				; 000001bcH
	call	DisableKeyword

; 1181 :         DisableKeyword( T_FASTCALL );

	mov	ecx, 270				; 0000010eH
	call	DisableKeyword
$LN3@ReswTableI:

; 1182 :     }
; 1183 : 
; 1184 :     return;
; 1185 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ReswTableInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
tv70 = 32
tv73 = 36
ModuleInit PROC

; 1139 : {

	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1140 :     ModuleInfo.sub_format = Options.sub_format;

	mov	eax, DWORD PTR Options+164
	mov	DWORD PTR ModuleInfo+372, eax

; 1141 :     ModuleInfo.fmtopt = &formatoptions[Options.output_format];

	movsxd	rax, DWORD PTR Options+160
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:formatoptions
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ModuleInfo+344, rax

; 1142 :     ModuleInfo.CommentDataInCode = (Options.output_format == OFORMAT_OMF &&

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN3@ModuleInit
	movzx	eax, BYTE PTR Options+128
	test	eax, eax
	jne	SHORT $LN3@ModuleInit
	mov	DWORD PTR tv70[rsp], 1
	jmp	SHORT $LN4@ModuleInit
$LN3@ModuleInit:
	mov	DWORD PTR tv70[rsp], 0
$LN4@ModuleInit:
	movzx	eax, BYTE PTR tv70[rsp]
	mov	BYTE PTR ModuleInfo+423, al

; 1143 :                          Options.no_comment_data_in_code_records == FALSE);
; 1144 :     ModuleInfo.g.error_count = 0;

	mov	DWORD PTR ModuleInfo, 0

; 1145 :     ModuleInfo.g.warning_count = 0;

	mov	DWORD PTR ModuleInfo+4, 0

; 1146 :     ModuleInfo.model = MODEL_NONE;

	mov	DWORD PTR ModuleInfo+360, 0

; 1147 :     /* ModuleInfo.distance = STACK_NONE; */
; 1148 :     ModuleInfo.ostype = OPSYS_DOS;

	mov	DWORD PTR ModuleInfo+368, 0

; 1149 :     ModuleInfo.emulator = (Options.floating_point == FPO_EMULATION);

	cmp	DWORD PTR Options+4, 1
	jne	SHORT $LN5@ModuleInit
	mov	DWORD PTR tv73[rsp], 1
	jmp	SHORT $LN6@ModuleInit
$LN5@ModuleInit:
	mov	DWORD PTR tv73[rsp], 0
$LN6@ModuleInit:
	mov	eax, DWORD PTR tv73[rsp]
	and	eax, 1
	shl	eax, 9
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 9
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 1150 :     //ModuleInfo.flatgrp_idx = 0;
; 1151 : 
; 1152 :     get_module_name(); /* set ModuleInfo.name */

	call	get_module_name

; 1153 : 
; 1154 :     /* v2.06: ST_PROC has been removed */
; 1155 :     //SimpleType[ST_PROC].mem_type = MT_NEAR;
; 1156 : 
; 1157 :     memset( SymTables, 0, sizeof( SymTables[0] ) * TAB_LAST );

	mov	r8d, 96					; 00000060H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:SymTables
	call	memset

; 1158 :     ModuleInfo.fmtopt->init( &ModuleInfo );

	lea	rcx, OFFSET FLAT:ModuleInfo
	mov	rax, QWORD PTR ModuleInfo+344
	call	QWORD PTR [rax]

; 1159 : 
; 1160 :     return;
; 1161 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
ModuleInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
p$ = 32
fn$1 = 40
ext$2 = 48
get_module_name PROC

; 1100 : {

	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1101 :     //char dummy[_MAX_EXT];
; 1102 :     char        *p;
; 1103 : 
; 1104 :     /* v2.08: prefer name given by -nm option */
; 1105 :     if ( Options.names[OPTN_MODULE_NAME] ) {

	mov	eax, 8
	imul	rax, rax, 5
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN5@get_module

; 1106 :         strncpy( ModuleInfo.name, Options.names[OPTN_MODULE_NAME], sizeof( ModuleInfo.name ) );

	mov	eax, 8
	imul	rax, rax, 5
	lea	rcx, OFFSET FLAT:Options+32
	mov	r8d, 260				; 00000104H
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:ModuleInfo+512
	call	QWORD PTR __imp_strncpy

; 1107 :         ModuleInfo.name[ sizeof( ModuleInfo.name ) - 1] = NULLC;

	mov	eax, 1
	imul	rax, rax, 259				; 00000103H
	lea	rcx, OFFSET FLAT:ModuleInfo+512
	mov	BYTE PTR [rcx+rax], 0

; 1108 :     } else {

	jmp	SHORT $LN6@get_module
$LN5@get_module:

; 1109 :         /* v2.12: _splitpath()/_makepath() removed */
; 1110 :         const char *fn = GetFNamePart( CurrFName[ASM] );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rcx, QWORD PTR [rcx+rax]
	call	GetFNamePart
	mov	QWORD PTR fn$1[rsp], rax

; 1111 :         char *ext = GetExtPart( fn );

	mov	rcx, QWORD PTR fn$1[rsp]
	call	GetExtPart
	mov	QWORD PTR ext$2[rsp], rax

; 1112 :         memcpy( ModuleInfo.name, fn, ext - fn );

	mov	rax, QWORD PTR fn$1[rsp]
	mov	rcx, QWORD PTR ext$2[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	rdx, QWORD PTR fn$1[rsp]
	lea	rcx, OFFSET FLAT:ModuleInfo+512
	call	memcpy

; 1113 :         ModuleInfo.name[ ext - fn ] = NULLC;

	mov	rax, QWORD PTR fn$1[rsp]
	mov	rcx, QWORD PTR ext$2[rsp]
	sub	rcx, rax
	mov	rax, rcx
	lea	rcx, OFFSET FLAT:ModuleInfo+512
	mov	BYTE PTR [rcx+rax], 0
$LN6@get_module:

; 1114 :         //_splitpath( CurrFName[ASM], NULL, NULL, ModuleInfo.name, dummy );
; 1115 :     }
; 1116 : 
; 1117 :     _strupr( ModuleInfo.name );

	lea	rcx, OFFSET FLAT:ModuleInfo+512
	call	QWORD PTR __imp__strupr

; 1118 :     /* the module name must be a valid identifier, because it's used
; 1119 :      * as part of a segment name in certain memory models.
; 1120 :      */
; 1121 :     for( p = ModuleInfo.name; *p; ++p ) {

	lea	rax, OFFSET FLAT:ModuleInfo+512
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN4@get_module
$LN2@get_module:
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN4@get_module:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@get_module

; 1122 :         if( !( isalnum( *p ) || ( *p == '_' ) || ( *p == '$' )

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	SHORT $LN7@get_module
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN7@get_module
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN7@get_module
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN7@get_module
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN7@get_module

; 1123 :             || ( *p == '@' ) || ( *p == '?') ) ) {
; 1124 :             /* it's not a legal character for a symbol name */
; 1125 :             *p = '_';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 95			; 0000005fH
$LN7@get_module:

; 1126 :         }
; 1127 :     }

	jmp	SHORT $LN2@get_module
$LN3@get_module:

; 1128 :     /* first character can't be a digit either */
; 1129 :     if( isdigit( ModuleInfo.name[0] ) ) {

	mov	eax, 1
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+512
	movsx	eax, BYTE PTR [rcx+rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isdigit
	test	eax, eax
	je	SHORT $LN8@get_module

; 1130 :         ModuleInfo.name[0] = '_';

	mov	eax, 1
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+512
	mov	BYTE PTR [rcx+rax], 95			; 0000005fH
$LN8@get_module:

; 1131 :     }
; 1132 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
get_module_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
dir$1 = 64
pq$2 = 72
tv75 = 80
tv150 = 88
tv166 = 92
OnePass	PROC

; 990  : {

	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rdi, rsp
	mov	ecx, 24
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 991  : 
; 992  :     InputPassInit();

	call	InputPassInit

; 993  :     ModulePassInit();

	call	ModulePassInit

; 994  :     SymPassInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	SymPassInit

; 995  :     LabelInit();

	call	LabelInit

; 996  :     SegmentInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	SegmentInit

; 997  :     ContextInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	ContextInit

; 998  :     ProcInit();

	call	ProcInit

; 999  :     TypesInit();

	call	TypesInit

; 1000 :     HllInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	HllInit

; 1001 :     MacroInit( Parse_Pass ); /* insert predefined macros */

	mov	ecx, DWORD PTR Parse_Pass
	call	MacroInit

; 1002 :     AssumeInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	AssumeInit

; 1003 :     CmdlParamsInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	CmdlParamsInit

; 1004 : 
; 1005 :     ModuleInfo.EndDirFound = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	btr	eax, 16
	mov	DWORD PTR ModuleInfo+408, eax

; 1006 :     ModuleInfo.PhaseError = FALSE;

	mov	BYTE PTR ModuleInfo+422, 0

; 1007 :     //Modend = FALSE;
; 1008 :     /* LineNumber = 0; */
; 1009 :     LinnumInit();

	call	LinnumInit

; 1010 : 
; 1011 : #ifdef DEBUG_OUT
; 1012 :     if ( Parse_Pass > PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jbe	$LN10@OnePass

; 1013 :         DebugMsg(("OnePass(%u) segments (current=%s):\n", Parse_Pass + 1, CurrSeg ? CurrSeg->sym.name : "NULL" ));

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN18@OnePass
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv75[rsp], rax
	jmp	SHORT $LN19@OnePass
$LN18@OnePass:
	lea	rax, OFFSET FLAT:$SG12055
	mov	QWORD PTR tv75[rsp], rax
$LN19@OnePass:
	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	r8, QWORD PTR tv75[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12056
	call	DoDebugMsg

; 1014 :         {
; 1015 :             struct dsym *dir;
; 1016 :             for( dir = SymTables[TAB_SEG].head; dir; dir = dir->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR dir$1[rsp], rax
	jmp	SHORT $LN4@OnePass
$LN2@OnePass:
	mov	rax, QWORD PTR dir$1[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR dir$1[rsp], rax
$LN4@OnePass:
	cmp	QWORD PTR dir$1[rsp], 0
	je	SHORT $LN3@OnePass

; 1017 :                 DebugMsg(("OnePass(%u): segm=%-8s typ=%X start=%8X max_ofs=%8X\n", Parse_Pass + 1,

	mov	rax, QWORD PTR dir$1[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR dir$1[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	edx, DWORD PTR Parse_Pass
	inc	edx
	mov	r8, QWORD PTR dir$1[rsp]
	mov	r8d, DWORD PTR [r8+56]
	mov	DWORD PTR [rsp+40], r8d
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR [rcx+72]
	mov	rax, QWORD PTR dir$1[rsp]
	mov	r8, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12057
	call	DoDebugMsg

; 1018 :                           dir->sym.name, dir->e.seginfo->segtype, dir->e.seginfo->start_loc, dir->sym.max_offset ));
; 1019 :             }

	jmp	SHORT $LN2@OnePass
$LN3@OnePass:
$LN10@OnePass:

; 1020 :         }
; 1021 :     }
; 1022 : #endif
; 1023 :     /* the functions above might have written something to the line queue */
; 1024 :     if ( is_linequeue_populated() )

	cmp	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN11@OnePass

; 1025 :         RunLineQueue();

	call	RunLineQueue
$LN11@OnePass:

; 1026 : #if FASTPASS
; 1027 :     StoreState = FALSE;

	mov	BYTE PTR StoreState, 0

; 1028 :     if ( Parse_Pass > PASS_1 && UseSavedState == TRUE ) {

	cmp	DWORD PTR Parse_Pass, 0
	jbe	$LN12@OnePass
	movzx	eax, BYTE PTR UseSavedState
	cmp	eax, 1
	jne	$LN12@OnePass

; 1029 :         LineStoreCurr = RestoreState();

	call	RestoreState
	mov	QWORD PTR LineStoreCurr, rax
$LN5@OnePass:

; 1030 :         while ( LineStoreCurr && ModuleInfo.EndDirFound == FALSE ) {

	cmp	QWORD PTR LineStoreCurr, 0
	je	$LN6@OnePass
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 16
	and	eax, 1
	test	eax, eax
	jne	$LN6@OnePass

; 1031 :             /* the source line is modified in Tokenize() if it contains a comment! */
; 1032 : #if USELSLINE==0
; 1033 :             strcpy( CurrSource, LineStoreCurr->line );
; 1034 : #endif
; 1035 :             set_curr_srcfile( LineStoreCurr->srcfile, LineStoreCurr->lineno );

	mov	rax, QWORD PTR LineStoreCurr
	mov	eax, DWORD PTR [rax+8]
	and	eax, 1048575				; 000fffffH
	mov	rcx, QWORD PTR LineStoreCurr
	mov	ecx, DWORD PTR [rcx+8]
	shr	ecx, 20
	and	ecx, 4095				; 00000fffH
	mov	edx, eax
	call	set_curr_srcfile

; 1036 :             /* v2.06: list flags now initialized on the top level */
; 1037 :             ModuleInfo.line_flags = 0;

	mov	BYTE PTR ModuleInfo+398, 0

; 1038 :             MacroLevel = ( LineStoreCurr->srcfile == 0xFFF ? 1 : 0 );

	mov	rax, QWORD PTR LineStoreCurr
	mov	eax, DWORD PTR [rax+8]
	shr	eax, 20
	and	eax, 4095				; 00000fffH
	cmp	eax, 4095				; 00000fffH
	jne	SHORT $LN20@OnePass
	mov	DWORD PTR tv150[rsp], 1
	jmp	SHORT $LN21@OnePass
$LN20@OnePass:
	mov	DWORD PTR tv150[rsp], 0
$LN21@OnePass:
	movzx	eax, BYTE PTR tv150[rsp]
	mov	BYTE PTR MacroLevel, al

; 1039 :             DebugMsg1(("OnePass(%u) cur/nxt=%X/%X src=%X.%u mlvl=%u: >%s<\n", Parse_Pass+1, LineStoreCurr, LineStoreCurr->next, LineStoreCurr->srcfile, LineStoreCurr->lineno, MacroLevel, LineStoreCurr->line ));

	mov	rax, QWORD PTR LineStoreCurr
	add	rax, 16
	movzx	ecx, BYTE PTR MacroLevel
	mov	rdx, QWORD PTR LineStoreCurr
	mov	edx, DWORD PTR [rdx+8]
	and	edx, 1048575				; 000fffffH
	mov	r8, QWORD PTR LineStoreCurr
	mov	r8d, DWORD PTR [r8+8]
	shr	r8d, 20
	and	r8d, 4095				; 00000fffH
	mov	r9d, DWORD PTR Parse_Pass
	inc	r9d
	mov	DWORD PTR tv166[rsp], r9d
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], ecx
	mov	DWORD PTR [rsp+40], edx
	mov	DWORD PTR [rsp+32], r8d
	mov	rax, QWORD PTR LineStoreCurr
	mov	r9, QWORD PTR [rax]
	mov	r8, QWORD PTR LineStoreCurr
	mov	eax, DWORD PTR tv166[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12061
	call	DoDebugMsg1

; 1040 :             ModuleInfo.CurrComment = NULL; /* v2.08: added (var is never reset because GetTextLine() isn't called) */

	mov	QWORD PTR ModuleInfo+472, 0

; 1041 : #if USELSLINE
; 1042 :             if ( Token_Count = Tokenize( LineStoreCurr->line, 0, ModuleInfo.tokenarray, TOK_DEFAULT ) )

	mov	rax, QWORD PTR LineStoreCurr
	add	rax, 16
	xor	r9d, r9d
	mov	r8, QWORD PTR ModuleInfo+480
	xor	edx, edx
	mov	rcx, rax
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax
	cmp	DWORD PTR ModuleInfo+496, 0
	je	SHORT $LN14@OnePass

; 1043 : #else
; 1044 :             if ( Token_Count = Tokenize( CurrSource, 0, ModuleInfo.tokenarray, TOK_DEFAULT ) )
; 1045 : #endif
; 1046 :                 ParseLine( ModuleInfo.tokenarray );

	mov	rcx, QWORD PTR ModuleInfo+480
	call	ParseLine
$LN14@OnePass:

; 1047 :             LineStoreCurr = LineStoreCurr->next;

	mov	rax, QWORD PTR LineStoreCurr
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR LineStoreCurr, rax

; 1048 :         }

	jmp	$LN5@OnePass
$LN6@OnePass:

; 1049 :     } else

	jmp	SHORT $LN13@OnePass
$LN12@OnePass:

; 1050 : #endif
; 1051 :     {
; 1052 :         struct qitem *pq;
; 1053 :         /* v2.11: handle -Fi files here ( previously in CmdlParamsInit ) */
; 1054 :         for ( pq = Options.queues[OPTQ_FINCLUDE]; pq; pq = pq->next ) {

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:Options+104
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR pq$2[rsp], rax
	jmp	SHORT $LN9@OnePass
$LN7@OnePass:
	mov	rax, QWORD PTR pq$2[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pq$2[rsp], rax
$LN9@OnePass:
	cmp	QWORD PTR pq$2[rsp], 0
	je	SHORT $LN8@OnePass

; 1055 :             DebugMsg(("OnePass: force include of file: %s\n", pq->value ));

	mov	rax, QWORD PTR pq$2[rsp]
	add	rax, 8
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12063
	call	DoDebugMsg

; 1056 :             if ( SearchFile( pq->value, TRUE ) )

	mov	rax, QWORD PTR pq$2[rsp]
	add	rax, 8
	mov	dl, 1
	mov	rcx, rax
	call	SearchFile
	test	rax, rax
	je	SHORT $LN15@OnePass

; 1057 :                 ProcessFile( ModuleInfo.tokenarray );

	mov	rcx, QWORD PTR ModuleInfo+480
	call	ProcessFile
$LN15@OnePass:

; 1058 :         }

	jmp	SHORT $LN7@OnePass
$LN8@OnePass:

; 1059 :         ProcessFile( ModuleInfo.tokenarray ); /* process the main source file */

	mov	rcx, QWORD PTR ModuleInfo+480
	call	ProcessFile
$LN13@OnePass:

; 1060 :     }
; 1061 : 
; 1062 :     LinnumFini();

	call	LinnumFini

; 1063 : 
; 1064 :     if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN16@OnePass

; 1065 :         PassOneChecks();

	call	PassOneChecks
$LN16@OnePass:

; 1066 : 
; 1067 :     ClearSrcStack();

	call	ClearSrcStack

; 1068 : 
; 1069 :     return( 1 );

	mov	eax, 1

; 1070 : }

	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
OnePass	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
curr$ = 32
next$ = 40
q$ = 48
qn$ = 56
cntUnusedExt$ = 64
sym$1 = 72
i$2 = 80
j$3 = 84
sym$4 = 88
fix$5 = 96
PassOneChecks PROC

; 764  : {

	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 765  :     struct dsym *curr;
; 766  :     struct dsym *next;
; 767  :     struct qnode *q;
; 768  :     struct qnode *qn;
; 769  : #ifdef DEBUG_OUT
; 770  :     int cntUnusedExt = 0;

	mov	DWORD PTR cntUnusedExt$[rsp], 0

; 771  : #endif
; 772  : 
; 773  :     /* check for open structures and segments has been done inside the
; 774  :      * END directive handling already
; 775  :      * v2.10: now done for PROCs as well, since procedures
; 776  :      * must be closed BEFORE segments are to be closed.
; 777  :      */
; 778  :     //ProcCheckOpen();
; 779  :     HllCheckOpen();

	call	HllCheckOpen

; 780  :     CondCheckOpen();

	call	CondCheckOpen

; 781  : 
; 782  :     if( ModuleInfo.EndDirFound == FALSE )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 16
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN29@PassOneChe

; 783  :         EmitError( END_DIRECTIVE_REQUIRED );

	mov	ecx, 99					; 00000063H
	call	EmitError
$LN29@PassOneChe:

; 784  : 
; 785  : #ifdef DEBUG_OUT
; 786  :     for ( curr = SymTables[TAB_UNDEF].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@PassOneChe
$LN2@PassOneChe:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@PassOneChe:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@PassOneChe

; 787  :         DebugMsg(("PassOneChecks: undefined symbol %s\n", curr->sym.name ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12006
	call	DoDebugMsg

; 788  :     }

	jmp	SHORT $LN2@PassOneChe
$LN3@PassOneChe:

; 789  : #endif
; 790  :     /* v2.04: check the publics queue.
; 791  :      * - only internal symbols can be public.
; 792  :      * - weak external symbols are filtered ( since v2.11 )
; 793  :      * - anything else is an error
; 794  :      * v2.11: moved here ( from inside the "#if FASTPASS"-block )
; 795  :      * because the loop will now filter weak externals [ this
; 796  :      * was previously done in GetPublicSymbols() ]
; 797  :      */
; 798  :     for( q = ModuleInfo.g.PubQueue.head, qn = (struct qnode *)&ModuleInfo.g.PubQueue ; q; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo+16
	mov	QWORD PTR q$[rsp], rax
	lea	rax, OFFSET FLAT:ModuleInfo+16
	mov	QWORD PTR qn$[rsp], rax
	jmp	SHORT $LN7@PassOneChe
$LN5@PassOneChe:
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$[rsp], rax
$LN7@PassOneChe:
	cmp	QWORD PTR q$[rsp], 0
	je	$LN6@PassOneChe

; 799  : 
; 800  :         if ( q->sym->state == SYM_INTERNAL )

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN30@PassOneChe

; 801  :             qn = q;

	mov	rax, QWORD PTR q$[rsp]
	mov	QWORD PTR qn$[rsp], rax
	jmp	$LN31@PassOneChe
$LN30@PassOneChe:

; 802  :         else if ( q->sym->state == SYM_EXTERNAL && q->sym->weak == TRUE ) {

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN32@PassOneChe
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN32@PassOneChe

; 803  :             DebugMsg(("PassOneChecks: public for weak external skipped: %s\n", q->sym->name ));

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12011
	call	DoDebugMsg

; 804  :             qn->next = q->next;

	mov	rax, QWORD PTR qn$[rsp]
	mov	rcx, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 805  :             LclFree( q );
; 806  :             q = qn;

	mov	rax, QWORD PTR qn$[rsp]
	mov	QWORD PTR q$[rsp], rax

; 807  :         } else {

	jmp	SHORT $LN33@PassOneChe
$LN32@PassOneChe:

; 808  :             DebugMsg(("PassOneChecks: invalid public attribute for %s [state=%u weak=%u]\n", q->sym->name, q->sym->state, q->sym->weak ));

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	mov	rcx, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rdx, QWORD PTR q$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	r9d, eax
	mov	r8d, DWORD PTR [rcx+32]
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG12012
	call	DoDebugMsg

; 809  : #if FASTPASS
; 810  :             SkipSavedState();

	call	SkipSavedState

; 811  : #endif
; 812  :             break;

	jmp	SHORT $LN6@PassOneChe
$LN33@PassOneChe:
$LN31@PassOneChe:

; 813  :         }
; 814  :     }

	jmp	$LN5@PassOneChe
$LN6@PassOneChe:

; 815  : #if FASTPASS
; 816  :     if ( SymTables[TAB_UNDEF].head ) {

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables

; 817  :         /* to force a full second pass in case of missing symbols,
; 818  :          * activate the next line. It was implemented to have proper
; 819  :          * error displays if a forward reference wasn't found.
; 820  :          * However, v1.95 final won't need this anymore, because both
; 821  :          * filename + lineno for every line is known now in pass 2.
; 822  :          */
; 823  :         /* SkipSavedState(); */
; 824  :     }
; 825  : 
; 826  :     /* check if there's an undefined segment reference.
; 827  :      * This segment was an argument to a group definition then.
; 828  :      * Just do a full second pass, the GROUP directive will report
; 829  :      * the error.
; 830  :      */
; 831  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN10@PassOneChe
$LN8@PassOneChe:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN10@PassOneChe:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN9@PassOneChe

; 832  :         if( curr->sym.segment == NULL ) {

	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN35@PassOneChe

; 833  :             DebugMsg(("PassOneChecks: undefined segment %s\n", curr->sym.name ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12015
	call	DoDebugMsg

; 834  :             SkipSavedState();

	call	SkipSavedState

; 835  :             break;

	jmp	SHORT $LN9@PassOneChe
$LN35@PassOneChe:

; 836  :         }
; 837  :     }

	jmp	SHORT $LN8@PassOneChe
$LN9@PassOneChe:

; 838  : #if COFF_SUPPORT
; 839  :     /* if there's an item in the safeseh list which is not an
; 840  :      * internal proc, make a full second pass to emit a proper
; 841  :      * error msg at the .SAFESEH directive
; 842  :      */
; 843  :     for ( q = ModuleInfo.g.SafeSEHQueue.head; q; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo+48
	mov	QWORD PTR q$[rsp], rax
	jmp	SHORT $LN13@PassOneChe
$LN11@PassOneChe:
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$[rsp], rax
$LN13@PassOneChe:
	cmp	QWORD PTR q$[rsp], 0
	je	SHORT $LN12@PassOneChe

; 844  :         if ( q->sym->state != SYM_INTERNAL || q->sym->isproc == FALSE ) {

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN37@PassOneChe
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN36@PassOneChe
$LN37@PassOneChe:

; 845  :             SkipSavedState();

	call	SkipSavedState

; 846  :             break;

	jmp	SHORT $LN12@PassOneChe
$LN36@PassOneChe:

; 847  :         }
; 848  :     }

	jmp	SHORT $LN11@PassOneChe
$LN12@PassOneChe:

; 849  : #endif
; 850  : 
; 851  :     /* scan ALIASes for COFF/ELF */
; 852  : 
; 853  : #if COFF_SUPPORT || ELF_SUPPORT
; 854  :     if ( Options.output_format == OFORMAT_COFF
; 855  : #if ELF_SUPPORT
; 856  :         || Options.output_format == OFORMAT_ELF

	cmp	DWORD PTR Options+160, 2
	je	SHORT $LN39@PassOneChe
	cmp	DWORD PTR Options+160, 3
	jne	$LN38@PassOneChe
$LN39@PassOneChe:

; 857  : #endif
; 858  :        ) {
; 859  :         for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 5
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN16@PassOneChe
$LN14@PassOneChe:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN16@PassOneChe:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN15@PassOneChe

; 860  :             struct asym *sym;
; 861  :             sym = curr->sym.substitute;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR sym$1[rsp], rax

; 862  :             /* check if symbol is external or public */
; 863  :             if ( sym == NULL ||

	cmp	QWORD PTR sym$1[rsp], 0
	je	SHORT $LN41@PassOneChe
	mov	rax, QWORD PTR sym$1[rsp]
	cmp	DWORD PTR [rax+32], 2
	je	SHORT $LN40@PassOneChe
	mov	rax, QWORD PTR sym$1[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN42@PassOneChe
	mov	rax, QWORD PTR sym$1[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN40@PassOneChe
$LN42@PassOneChe:
$LN41@PassOneChe:

; 864  :                 ( sym->state != SYM_EXTERNAL &&
; 865  :                  ( sym->state != SYM_INTERNAL || sym->ispublic == FALSE ))) {
; 866  :                 SkipSavedState();

	call	SkipSavedState

; 867  :                 break;

	jmp	SHORT $LN15@PassOneChe
$LN40@PassOneChe:

; 868  :             }
; 869  :             /* make sure it becomes a strong external */
; 870  :             if ( sym->state == SYM_EXTERNAL )

	mov	rax, QWORD PTR sym$1[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN43@PassOneChe

; 871  :                 sym->used = TRUE;

	mov	rax, QWORD PTR sym$1[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 1
	mov	rcx, QWORD PTR sym$1[rsp]
	mov	BYTE PTR [rcx+40], al
$LN43@PassOneChe:

; 872  :         }

	jmp	SHORT $LN14@PassOneChe
$LN15@PassOneChe:
$LN38@PassOneChe:

; 873  :     }
; 874  : #endif
; 875  : 
; 876  : #endif /* FASTPASS */
; 877  : 
; 878  :     /* scan the EXTERN/EXTERNDEF items */
; 879  : 
; 880  :     for( curr = SymTables[TAB_EXT].head ; curr; curr = next ) {

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN19@PassOneChe
$LN17@PassOneChe:
	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR curr$[rsp], rax
$LN19@PassOneChe:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN18@PassOneChe

; 881  :         next = curr->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR next$[rsp], rax

; 882  :         /* v2.01: externdefs which have been "used" become "strong" */
; 883  :         if ( curr->sym.used )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN44@PassOneChe

; 884  :             curr->sym.weak = FALSE;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	and	al, 247					; 000000f7H
	mov	rcx, QWORD PTR curr$[rsp]
	mov	BYTE PTR [rcx+47], al
$LN44@PassOneChe:

; 885  :         /* remove unused EXTERNDEF/PROTO items from queue. */
; 886  :         if ( curr->sym.weak == TRUE
; 887  : #if DLLIMPORT
; 888  :             && curr->sym.iat_used == FALSE

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN45@PassOneChe
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN45@PassOneChe

; 889  : #endif
; 890  :            ) {
; 891  :             sym_remove_table( &SymTables[TAB_EXT], curr );

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR curr$[rsp]
	mov	rcx, rax
	call	sym_remove_table

; 892  : #ifdef DEBUG_OUT
; 893  :             cntUnusedExt++;

	mov	eax, DWORD PTR cntUnusedExt$[rsp]
	inc	eax
	mov	DWORD PTR cntUnusedExt$[rsp], eax

; 894  : #endif
; 895  :             continue;

	jmp	$LN17@PassOneChe
$LN45@PassOneChe:

; 896  :         }
; 897  : 
; 898  : #if FASTMEM==0
; 899  :         /* v2.05: clear fixup list (used for backpatching in pass one) */
; 900  :         if ( curr->sym.bp_fixup ) {
; 901  :             struct fixup *c;
; 902  :             struct fixup *n;
; 903  :             for( c = curr->sym.bp_fixup ; c; ) {
; 904  :                 n = c->nextbp;
; 905  :                 LclFree( c );
; 906  :                 c = n;
; 907  :             }
; 908  :             curr->sym.bp_fixup = NULL;
; 909  :         }
; 910  : #endif
; 911  : 
; 912  :         if ( curr->sym.iscomm == TRUE )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN46@PassOneChe

; 913  :             continue;

	jmp	$LN17@PassOneChe
$LN46@PassOneChe:

; 914  :         /* optional alternate symbol must be INTERNAL or EXTERNAL.
; 915  :          * COFF ( and ELF? ) also wants internal symbols to be public
; 916  :          * ( which is reasonable, since the linker won't know private
; 917  :          * symbols and hence will search for a symbol of that name
; 918  :          * "elsewhere" ).
; 919  :          */
; 920  : #if FASTPASS
; 921  :         if ( curr->sym.altname ) {

	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+64], 0
	je	SHORT $LN47@PassOneChe

; 922  :             if ( curr->sym.altname->state == SYM_INTERNAL ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+64]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN48@PassOneChe

; 923  : #if COFF_SUPPORT || ELF_SUPPORT
; 924  :                 /* for COFF/ELF, the altname must be public or external */
; 925  :                 if ( curr->sym.altname->ispublic == FALSE &&

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+64]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN50@PassOneChe
	cmp	DWORD PTR Options+160, 2
	je	SHORT $LN51@PassOneChe
	cmp	DWORD PTR Options+160, 3
	jne	SHORT $LN50@PassOneChe
$LN51@PassOneChe:

; 926  :                     ( Options.output_format == OFORMAT_COFF
; 927  : #if ELF_SUPPORT
; 928  :                      || Options.output_format == OFORMAT_ELF
; 929  : #endif
; 930  :                     ) ) {
; 931  :                     SkipSavedState();

	call	SkipSavedState
$LN50@PassOneChe:

; 932  :                 }

	jmp	SHORT $LN49@PassOneChe
$LN48@PassOneChe:

; 933  : #endif
; 934  :             } else if ( curr->sym.altname->state != SYM_EXTERNAL ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+64]
	cmp	DWORD PTR [rax+32], 2
	je	SHORT $LN52@PassOneChe

; 935  :                 /* do not use saved state, scan full source in second pass */
; 936  :                 SkipSavedState();

	call	SkipSavedState
$LN52@PassOneChe:
$LN49@PassOneChe:
$LN47@PassOneChe:

; 937  :             }
; 938  :         }
; 939  : #endif
; 940  :     }

	jmp	$LN17@PassOneChe
$LN18@PassOneChe:

; 941  : 
; 942  : #ifdef DEBUG_OUT
; 943  :     DebugMsg(("PassOneChecks: removed unused externals: %u\n", cntUnusedExt ));

	mov	edx, DWORD PTR cntUnusedExt$[rsp]
	lea	rcx, OFFSET FLAT:$SG12033
	call	DoDebugMsg

; 944  :     DebugMsg(("PassOneChecks: forward references:\n"));

	lea	rcx, OFFSET FLAT:$SG12034
	call	DoDebugMsg

; 945  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN22@PassOneChe
$LN20@PassOneChe:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN22@PassOneChe:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN21@PassOneChe

; 946  :         int i;
; 947  :         int j;
; 948  :         struct asym * sym;
; 949  :         struct fixup * fix;
; 950  :         for ( i = 0, j = 0, sym = curr->e.seginfo->label_list; sym; sym = (struct asym *)((struct dsym *)sym)->next ) {

	mov	DWORD PTR i$2[rsp], 0
	mov	DWORD PTR j$3[rsp], 0
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR sym$4[rsp], rax
	jmp	SHORT $LN25@PassOneChe
$LN23@PassOneChe:
	mov	rax, QWORD PTR sym$4[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR sym$4[rsp], rax
$LN25@PassOneChe:
	cmp	QWORD PTR sym$4[rsp], 0
	je	SHORT $LN24@PassOneChe

; 951  :             i++;

	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax

; 952  :             for ( fix = sym->bp_fixup; fix ; fix = fix->nextbp, j++ );

	mov	rax, QWORD PTR sym$4[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR fix$5[rsp], rax
	jmp	SHORT $LN28@PassOneChe
$LN26@PassOneChe:
	mov	rax, QWORD PTR fix$5[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR fix$5[rsp], rax
	mov	eax, DWORD PTR j$3[rsp]
	inc	eax
	mov	DWORD PTR j$3[rsp], eax
$LN28@PassOneChe:
	cmp	QWORD PTR fix$5[rsp], 0
	je	SHORT $LN27@PassOneChe
	jmp	SHORT $LN26@PassOneChe
$LN27@PassOneChe:

; 953  :         }

	jmp	SHORT $LN23@PassOneChe
$LN24@PassOneChe:

; 954  :         DebugMsg(("PassOneChecks: segm=%s, labels=%u forward refs=%u\n", curr->sym.name, i, j));

	mov	r9d, DWORD PTR j$3[rsp]
	mov	r8d, DWORD PTR i$2[rsp]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12035
	call	DoDebugMsg

; 955  :     }

	jmp	$LN20@PassOneChe
$LN21@PassOneChe:

; 956  : #endif
; 957  : 
; 958  :     if ( ModuleInfo.g.error_count == 0 ) {

	cmp	DWORD PTR ModuleInfo, 0
	jne	SHORT $LN53@PassOneChe

; 959  : 
; 960  :         /* make all symbols of type SYM_INTERNAL, which aren't
; 961  :          a constant, public.  */
; 962  :         if ( Options.all_symbols_public )

	movzx	eax, BYTE PTR Options+154
	test	eax, eax
	je	SHORT $LN54@PassOneChe

; 963  :             SymMakeAllSymbolsPublic();

	call	SymMakeAllSymbolsPublic
$LN54@PassOneChe:

; 964  : 
; 965  :         if ( Options.syntax_check_only == FALSE )

	movzx	eax, BYTE PTR Options+188
	test	eax, eax
	jne	SHORT $LN55@PassOneChe

; 966  :             write_to_file = TRUE;

	mov	BYTE PTR write_to_file, 1
$LN55@PassOneChe:

; 967  : 
; 968  :         if ( ModuleInfo.g.Pass1Checks )

	cmp	QWORD PTR ModuleInfo+304, 0
	je	SHORT $LN56@PassOneChe

; 969  :             ModuleInfo.g.Pass1Checks( &ModuleInfo );

	lea	rcx, OFFSET FLAT:ModuleInfo
	call	QWORD PTR ModuleInfo+304
$LN56@PassOneChe:
$LN53@PassOneChe:

; 970  :     }
; 971  : 
; 972  : 
; 973  :     return;
; 974  : }

	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
PassOneChecks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
cpu$ = 32
model$ = 36
curr$ = 40
ModulePassInit PROC

; 640  : {

	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 641  :     enum cpu_info cpu = Options.cpu;

	mov	eax, DWORD PTR Options+180
	mov	DWORD PTR cpu$[rsp], eax

; 642  :     enum model_type model = Options.model;

	mov	eax, DWORD PTR Options+176
	mov	DWORD PTR model$[rsp], eax

; 643  : #if DLLIMPORT
; 644  :     struct dsym *curr;
; 645  : #endif
; 646  : 
; 647  :     DebugMsg(( "ModulePassInit() enter\n" ));

	lea	rcx, OFFSET FLAT:$SG11949
	call	DoDebugMsg

; 648  :     /* set default values not affected by the masm 5.1 compat switch */
; 649  :     ModuleInfo.procs_private = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -5					; fffffffbH
	mov	DWORD PTR ModuleInfo+408, eax

; 650  :     ModuleInfo.procs_export = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -9					; fffffff7H
	mov	DWORD PTR ModuleInfo+408, eax

; 651  :     ModuleInfo.offsettype = OT_GROUP;

	mov	DWORD PTR ModuleInfo+384, 0

; 652  :     ModuleInfo.scoped = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 7
	mov	DWORD PTR ModuleInfo+408, eax

; 653  : 
; 654  : 
; 655  : #if FASTPASS
; 656  :     /* v2.03: don't generate the code if fastpass is active */
; 657  :     /* v2.08: query UseSavedState instead of StoreState */
; 658  :     //if ( StoreState == FALSE ) {
; 659  :     if ( UseSavedState == FALSE ) {

	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	jne	$LN5@ModulePass

; 660  : #endif
; 661  :         ModuleInfo.langtype = Options.langtype;

	mov	eax, DWORD PTR Options+172
	mov	DWORD PTR ModuleInfo+364, eax

; 662  :         ModuleInfo.fctype = Options.fctype;

	mov	eax, DWORD PTR Options+184
	mov	DWORD PTR ModuleInfo+376, eax

; 663  : #if AMD64_SUPPORT
; 664  :         if ( ModuleInfo.sub_format == SFORMAT_64BIT ) {

	cmp	DWORD PTR ModuleInfo+372, 3
	jne	SHORT $LN6@ModulePass

; 665  :             /* v2.06: force cpu to be at least P_64, without side effect to Options.cpu */
; 666  :             if ( ( cpu &  P_CPU_MASK ) < P_64 ) /* enforce cpu to be 64-bit */

	mov	eax, DWORD PTR cpu$[rsp]
	and	eax, 240				; 000000f0H
	cmp	eax, 112				; 00000070H
	jge	SHORT $LN8@ModulePass

; 667  :                 cpu = P_64;

	mov	DWORD PTR cpu$[rsp], 112		; 00000070H
$LN8@ModulePass:

; 668  :             /* ignore -m switch for 64-bit formats.
; 669  :              * there's no other model than FLAT possible.
; 670  :              */
; 671  :             model = MODEL_FLAT;

	mov	DWORD PTR model$[rsp], 7

; 672  :             if ( ModuleInfo.langtype == LANG_NONE && Options.output_format == OFORMAT_COFF )

	cmp	DWORD PTR ModuleInfo+364, 0
	jne	SHORT $LN9@ModulePass
	cmp	DWORD PTR Options+160, 2
	jne	SHORT $LN9@ModulePass

; 673  :                 ModuleInfo.langtype = LANG_FASTCALL;

	mov	DWORD PTR ModuleInfo+364, 7
$LN9@ModulePass:

; 674  :         } else

	jmp	SHORT $LN7@ModulePass
$LN6@ModulePass:

; 675  : #endif
; 676  :             /* if model FLAT is to be set, ensure that cpu is compat. */
; 677  :             if ( model == MODEL_FLAT && ( cpu & P_CPU_MASK ) < P_386 ) /* cpu < 386? */

	cmp	DWORD PTR model$[rsp], 7
	jne	SHORT $LN10@ModulePass
	mov	eax, DWORD PTR cpu$[rsp]
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jge	SHORT $LN10@ModulePass

; 678  :                 cpu = P_386;

	mov	DWORD PTR cpu$[rsp], 48			; 00000030H
$LN10@ModulePass:
$LN7@ModulePass:

; 679  : 
; 680  :         SetCPU( cpu );

	mov	ecx, DWORD PTR cpu$[rsp]
	call	SetCPU

; 681  :         /* table ModelToken starts with MODEL_TINY, which is index 1" */
; 682  :         if ( model != MODEL_NONE )

	cmp	DWORD PTR model$[rsp], 0
	je	SHORT $LN11@ModulePass

; 683  :             AddLineQueueX( "%r %s", T_DOT_MODEL, ModelToken[model - 1] );

	mov	eax, DWORD PTR model$[rsp]
	dec	eax
	cdqe
	lea	rcx, OFFSET FLAT:ModelToken
	mov	r8, QWORD PTR [rcx+rax*8]
	mov	edx, 342				; 00000156H
	lea	rcx, OFFSET FLAT:$SG11957
	call	AddLineQueueX
$LN11@ModulePass:
$LN5@ModulePass:

; 684  : 
; 685  : #if FASTPASS
; 686  :     }
; 687  : #endif
; 688  : 
; 689  :     SetMasm510( Options.masm51_compat );

	movzx	ecx, BYTE PTR Options+142
	call	SetMasm510

; 690  :     ModuleInfo.defOfssize = USE16;

	mov	BYTE PTR ModuleInfo+405, 0

; 691  :     ModuleInfo.ljmp     = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	or	eax, 32					; 00000020H
	mov	DWORD PTR ModuleInfo+408, eax

; 692  : 
; 693  :     ModuleInfo.list   = Options.write_listing;

	movzx	eax, BYTE PTR Options+137
	and	eax, 1
	shl	eax, 11
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 11
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 694  :     ModuleInfo.cref   = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 12
	mov	DWORD PTR ModuleInfo+408, eax

; 695  :     ModuleInfo.listif = Options.listif;

	movzx	eax, BYTE PTR Options+146
	and	eax, 1
	shl	eax, 13
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 13
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 696  :     ModuleInfo.list_generated_code = Options.list_generated_code;

	movzx	eax, BYTE PTR Options+147
	and	eax, 1
	shl	eax, 14
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 14
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 697  :     ModuleInfo.list_macro = Options.list_macro;

	mov	eax, DWORD PTR Options+148
	mov	DWORD PTR ModuleInfo+400, eax

; 698  : 
; 699  :     ModuleInfo.case_sensitive = Options.case_sensitive;

	movzx	eax, BYTE PTR Options+139
	and	eax, 1
	mov	ecx, DWORD PTR ModuleInfo+408
	and	ecx, -2					; fffffffeH
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 700  :     ModuleInfo.convert_uppercase = Options.convert_uppercase;

	movzx	eax, BYTE PTR Options+140
	and	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR ModuleInfo+408
	and	ecx, -3					; fffffffdH
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 701  :     SymSetCmpFunc();

	call	SymSetCmpFunc

; 702  : 
; 703  :     ModuleInfo.segorder = SEGORDER_SEQ;

	mov	DWORD PTR ModuleInfo+380, 0

; 704  :     ModuleInfo.radix = 10;

	mov	BYTE PTR ModuleInfo+396, 10

; 705  :     ModuleInfo.fieldalign = Options.fieldalign;

	movzx	eax, BYTE PTR Options+168
	mov	BYTE PTR ModuleInfo+397, al

; 706  : #if PROCALIGN
; 707  :     ModuleInfo.procalign = 0;

	mov	BYTE PTR ModuleInfo+399, 0

; 708  : #endif
; 709  : #if DLLIMPORT
; 710  :     /* if OPTION DLLIMPORT was used, reset all iat_used flags */
; 711  :     if ( ModuleInfo.g.DllQueue )

	cmp	QWORD PTR ModuleInfo+80, 0
	je	SHORT $LN12@ModulePass

; 712  :         for ( curr = SymTables[TAB_EXT].head; curr; curr = curr->next )

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@ModulePass
$LN2@ModulePass:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@ModulePass:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@ModulePass

; 713  :             curr->sym.iat_used = FALSE;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 247					; 000000f7H
	mov	rcx, QWORD PTR curr$[rsp]
	mov	BYTE PTR [rcx+40], al
	jmp	SHORT $LN2@ModulePass
$LN3@ModulePass:
$LN12@ModulePass:

; 714  : #endif
; 715  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
ModulePassInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
env$1 = 32
pass$ = 64
CmdlParamsInit PROC

; 520  : {

	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+64]

; 521  :     DebugMsg(("CmdlParamsInit(%u) enter\n", pass));

	mov	edx, DWORD PTR pass$[rsp]
	lea	rcx, OFFSET FLAT:$SG11914
	call	DoDebugMsg

; 522  : 
; 523  : #if BUILD_TARGET
; 524  :     if ( pass == PASS_1 ) {
; 525  :         struct asym *sym;
; 526  :         char *tmp;
; 527  :         char *p;
; 528  : 
; 529  :         _strupr( Options.build_target );
; 530  :         tmp = myalloca( strlen( Options.build_target ) + 5 ); /* null + 4 uscores */
; 531  :         strcpy( tmp, uscores );
; 532  :         strcat( tmp, Options.build_target );
; 533  :         strcat( tmp, uscores );
; 534  : 
; 535  :         /* define target */
; 536  :         sym = CreateVariable( tmp, 0 );
; 537  :         sym->predefined = TRUE;
; 538  : 
; 539  :         p = NULL;
; 540  :         if( _stricmp( Options.build_target, "DOS" ) == 0 ) {
; 541  :             p = "__MSDOS__";
; 542  :         } else if( _stricmp( Options.build_target, "NETWARE" ) == 0 ) {
; 543  :             if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {
; 544  :                 p = "__NETWARE_386__";
; 545  :             } else {
; 546  :                 /* do nothing ... __NETWARE__ already defined */
; 547  :             }
; 548  :         } else if( _stricmp( Options.build_target, "WINDOWS" ) == 0 ) {
; 549  :             if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {
; 550  :                 p = "__WINDOWS_386__";
; 551  :             } else {
; 552  :                 /* do nothing ... __WINDOWS__ already defined */
; 553  :             }
; 554  :         } else if( _stricmp( Options.build_target, "QNX" ) == 0 ) {
; 555  :             p = "__UNIX__";
; 556  :         } else if( _stricmp( Options.build_target, "LINUX" ) == 0 ) {
; 557  :             p = "__UNIX__";
; 558  :         }
; 559  :         if ( p ) {
; 560  :             sym = CreateVariable( p, 0 );
; 561  :             sym->predefined = TRUE;
; 562  :         }
; 563  :     }
; 564  : #endif
; 565  : 
; 566  :     if ( pass == PASS_1 ) {

	cmp	DWORD PTR pass$[rsp], 0
	jne	SHORT $LN2@CmdlParams

; 567  :         char *env;
; 568  :         /* v2.06: this is done in ModulePassInit now */
; 569  :         //SetCPU( Options.cpu );
; 570  :         add_cmdline_tmacros();

	call	add_cmdline_tmacros

; 571  :         add_incpaths();

	call	add_incpaths

; 572  :         if ( Options.ignore_include == FALSE )

	movzx	eax, BYTE PTR Options+156
	test	eax, eax
	jne	SHORT $LN3@CmdlParams

; 573  :             if ( env = getenv( "INCLUDE" ) )

	lea	rcx, OFFSET FLAT:$SG11918
	call	QWORD PTR __imp_getenv
	mov	QWORD PTR env$1[rsp], rax
	cmp	QWORD PTR env$1[rsp], 0
	je	SHORT $LN4@CmdlParams

; 574  :                 AddStringToIncludePath( env );

	mov	rcx, QWORD PTR env$1[rsp]
	call	AddStringToIncludePath
$LN4@CmdlParams:
$LN3@CmdlParams:
$LN2@CmdlParams:

; 575  :     }
; 576  :     DebugMsg(("CmdlParamsInit exit\n"));

	lea	rcx, OFFSET FLAT:$SG11919
	call	DoDebugMsg

; 577  :     return;
; 578  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
CmdlParamsInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
p$ = 32
add_incpaths PROC

; 507  : {

	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 508  :     struct qitem *p;
; 509  :     DebugMsg(("add_incpaths: enter\n"));

	lea	rcx, OFFSET FLAT:$SG11908
	call	DoDebugMsg

; 510  :     for ( p = Options.queues[OPTQ_INCPATH]; p; p = p->next ) {

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:Options+104
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN4@add_incpat
$LN2@add_incpat:
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$[rsp], rax
$LN4@add_incpat:
	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN3@add_incpat

; 511  :         AddStringToIncludePath( p->value );

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	AddStringToIncludePath

; 512  :     }

	jmp	SHORT $LN2@add_incpat
$LN3@add_incpat:

; 513  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
add_incpaths ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
p$ = 0
name$ = 8
value$ = 16
len$ = 24
sym$ = 32
__$AllocaPad$$ = 56
tv148 = 72
tv82 = 80
__$ArrayPad$ = 88
add_cmdline_tmacros PROC

; 457  : {

	push	rbp
	push	rdi
	sub	rsp, 136				; 00000088H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 34					; 00000022H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	mov	QWORD PTR __$AllocaPad$$[rbp], 0

; 458  :     struct qitem *p;
; 459  :     char *name;
; 460  :     char *value;
; 461  :     int len;
; 462  :     struct asym *sym;
; 463  : 
; 464  :     DebugMsg(("add_cmdline_tmacros enter\n"));

	lea	rcx, OFFSET FLAT:$SG11891
	call	DoDebugMsg

; 465  :     for ( p = Options.queues[OPTQ_MACRO]; p; p = p->next ) {

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:Options+104
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR p$[rbp], rax
	jmp	SHORT $LN4@add_cmdlin
$LN2@add_cmdlin:
	mov	rax, QWORD PTR p$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$[rbp], rax
$LN4@add_cmdlin:
	cmp	QWORD PTR p$[rbp], 0
	je	$LN3@add_cmdlin

; 466  :         DebugMsg(("add_cmdline_tmacros: found >%s<\n", p->value));

	mov	rax, QWORD PTR p$[rbp]
	add	rax, 8
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11892
	call	DoDebugMsg

; 467  :         name = p->value;

	mov	rax, QWORD PTR p$[rbp]
	add	rax, 8
	mov	QWORD PTR name$[rbp], rax

; 468  :         value = strchr( name, '=' );

	mov	edx, 61					; 0000003dH
	mov	rcx, QWORD PTR name$[rbp]
	call	QWORD PTR __imp_strchr
	mov	QWORD PTR value$[rbp], rax

; 469  :         if( value == NULL ) {

	cmp	QWORD PTR value$[rbp], 0
	jne	SHORT $LN5@add_cmdlin

; 470  :             /* v2.06: ensure that 'value' doesn't point to r/o space */
; 471  :             //value = "";
; 472  :             value = name + strlen( name ); /* use the terminating NULL */

	mov	rcx, QWORD PTR name$[rbp]
	call	strlen
	mov	rcx, QWORD PTR name$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR value$[rbp], rax

; 473  :         } else {

	jmp	$LN6@add_cmdlin
$LN5@add_cmdlin:

; 474  :             len = value - name;

	mov	rax, QWORD PTR name$[rbp]
	mov	rcx, QWORD PTR value$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR len$[rbp], eax

; 475  :             name = (char *)myalloca( len + 1 );

	mov	eax, DWORD PTR len$[rbp]
	inc	eax
	cdqe
	add	rax, 36					; 00000024H
	mov	QWORD PTR tv148[rbp], rax
	mov	rax, QWORD PTR tv148[rbp]
	add	rax, 15
	cmp	rax, QWORD PTR tv148[rbp]
	ja	SHORT $LN13@add_cmdlin
	mov	rax, 1152921504606846960		; 0ffffffffffffff0H
$LN13@add_cmdlin:
	and	rax, -16
	call	__chkstk
	sub	rsp, rax
	lea	rax, QWORD PTR [rsp+32]
	mov	QWORD PTR tv82[rbp], rax
	lea	r8, QWORD PTR __$AllocaPad$$[rbp]
	mov	rdx, QWORD PTR tv148[rbp]
	mov	rcx, QWORD PTR tv82[rbp]
	call	_RTC_AllocaHelper
	add	QWORD PTR tv82[rbp], 32			; 00000020H
	mov	rax, QWORD PTR tv82[rbp]
	mov	QWORD PTR name$[rbp], rax

; 476  :             memcpy( name, p->value, len );

	movsxd	rax, DWORD PTR len$[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	add	rcx, 8
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR name$[rbp]
	call	memcpy

; 477  :             *(name + len) = NULLC;

	movsxd	rax, DWORD PTR len$[rbp]
	mov	rcx, QWORD PTR name$[rbp]
	mov	BYTE PTR [rcx+rax], 0

; 478  :             value++;

	mov	rax, QWORD PTR value$[rbp]
	inc	rax
	mov	QWORD PTR value$[rbp], rax
$LN6@add_cmdlin:

; 479  :         }
; 480  : 
; 481  :         /* there's no check whether the name is a reserved word!
; 482  :          */
; 483  :         if( is_valid_identifier( name ) == ERROR ) {

	mov	rcx, QWORD PTR name$[rbp]
	call	is_valid_identifier
	cmp	eax, -1
	jne	SHORT $LN7@add_cmdlin

; 484  :             DebugMsg(("add_cmdline_tmacros: name >%s< invalid\n", name ));

	mov	rdx, QWORD PTR name$[rbp]
	lea	rcx, OFFSET FLAT:$SG11897
	call	DoDebugMsg

; 485  :             EmitErr( SYNTAX_ERROR_EX, name );

	mov	rdx, QWORD PTR name$[rbp]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 486  :         } else {

	jmp	SHORT $LN8@add_cmdlin
$LN7@add_cmdlin:

; 487  :             sym = SymSearch( name );

	mov	rcx, QWORD PTR name$[rbp]
	call	SymFind
	mov	QWORD PTR sym$[rbp], rax

; 488  :             if ( sym == NULL ) {

	cmp	QWORD PTR sym$[rbp], 0
	jne	SHORT $LN9@add_cmdlin

; 489  :                 sym = SymCreate( name );

	mov	rcx, QWORD PTR name$[rbp]
	call	SymCreate
	mov	QWORD PTR sym$[rbp], rax

; 490  :                 sym->state = SYM_TMACRO;

	mov	rax, QWORD PTR sym$[rbp]
	mov	DWORD PTR [rax+32], 10
$LN9@add_cmdlin:

; 491  :             }
; 492  :             if ( sym->state == SYM_TMACRO ) {

	mov	rax, QWORD PTR sym$[rbp]
	cmp	DWORD PTR [rax+32], 10
	jne	SHORT $LN10@add_cmdlin

; 493  :                 sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rbp]
	mov	BYTE PTR [rcx+40], al

; 494  :                 sym->predefined = TRUE;

	mov	rax, QWORD PTR sym$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR sym$[rbp]
	mov	BYTE PTR [rcx+40], al

; 495  :                 sym->string_ptr = value;

	mov	rax, QWORD PTR sym$[rbp]
	mov	rcx, QWORD PTR value$[rbp]
	mov	QWORD PTR [rax+16], rcx

; 496  :             } else

	jmp	SHORT $LN11@add_cmdlin
$LN10@add_cmdlin:

; 497  :                 EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	rdx, QWORD PTR name$[rbp]
	mov	ecx, 56					; 00000038H
	call	EmitErr
$LN11@add_cmdlin:
$LN8@add_cmdlin:

; 498  :         }
; 499  :     }

	jmp	$LN2@add_cmdlin
$LN3@add_cmdlin:

; 500  :     return;
; 501  : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:add_cmdline_tmacros$rtcFrameData
	mov	r8, QWORD PTR __$AllocaPad$$[rbp]
	call	_RTC_CheckStackVars2
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+104]
	pop	rdi
	pop	rbp
	ret	0
add_cmdline_tmacros ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
tv78 = 32
tv128 = 36
id$ = 64
is_valid_identifier PROC

; 435  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 436  :     /* special handling of first char of an id: it can't be a digit,
; 437  :      but can be a dot (don't care about ModuleInfo.dotname!). */
; 438  : 
; 439  :     if( is_valid_first_char( *id ) == 0 )

	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalpha
	test	eax, eax
	jne	SHORT $LN9@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN9@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN9@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN9@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN9@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN9@is_valid_i
	mov	DWORD PTR tv78[rsp], 0
	jmp	SHORT $LN10@is_valid_i
$LN9@is_valid_i:
	mov	DWORD PTR tv78[rsp], 1
$LN10@is_valid_i:
	cmp	DWORD PTR tv78[rsp], 0
	jne	SHORT $LN5@is_valid_i

; 440  :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@is_valid_i
$LN5@is_valid_i:

; 441  :     id++;

	mov	rax, QWORD PTR id$[rsp]
	inc	rax
	mov	QWORD PTR id$[rsp], rax

; 442  :     for( ; *id != NULLC; id++ ) {

	jmp	SHORT $LN4@is_valid_i
$LN2@is_valid_i:
	mov	rax, QWORD PTR id$[rsp]
	inc	rax
	mov	QWORD PTR id$[rsp], rax
$LN4@is_valid_i:
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@is_valid_i

; 443  :         if ( is_valid_id_char( *id ) == FALSE )

	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	SHORT $LN11@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN11@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN11@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN11@is_valid_i
	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN11@is_valid_i
	mov	DWORD PTR tv128[rsp], 0
	jmp	SHORT $LN12@is_valid_i
$LN11@is_valid_i:
	mov	DWORD PTR tv128[rsp], 1
$LN12@is_valid_i:
	cmp	DWORD PTR tv128[rsp], 0
	jne	SHORT $LN6@is_valid_i

; 444  :             return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@is_valid_i
$LN6@is_valid_i:

; 445  :     }

	jmp	$LN2@is_valid_i
$LN3@is_valid_i:

; 446  :     /* don't allow a single dot! */
; 447  :     if ( *(id-1) == '.' )

	mov	rax, QWORD PTR id$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN7@is_valid_i

; 448  :         return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@is_valid_i
$LN7@is_valid_i:

; 449  : 
; 450  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@is_valid_i:

; 451  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
is_valid_identifier ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
curr$ = 48
ld$1 = 56
size$2 = 64
modinfo$ = 96
WriteModule PROC

; 385  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 386  :     struct dsym *curr;
; 387  : 
; 388  :     DebugMsg(("WriteModule enter\n"));

	lea	rcx, OFFSET FLAT:$SG11854
	call	DoDebugMsg

; 389  : 
; 390  :     /* final checks */
; 391  :     /* check limit of segments */
; 392  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@WriteModul
$LN2@WriteModul:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@WriteModul:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@WriteModul

; 393  :         if ( curr->e.seginfo->Ofssize == USE16 && curr->sym.max_offset > 0x10000 ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+104]
	test	eax, eax
	jne	SHORT $LN8@WriteModul
	mov	rax, QWORD PTR curr$[rsp]
	cmp	DWORD PTR [rax+56], 65536		; 00010000H
	jle	SHORT $LN8@WriteModul

; 394  :             if ( Options.output_format == OFORMAT_OMF )

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN9@WriteModul

; 395  :                 EmitErr( SEGMENT_EXCEEDS_64K_LIMIT, curr->sym.name );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 222				; 000000deH
	call	EmitErr
	jmp	SHORT $LN10@WriteModul
$LN9@WriteModul:

; 396  :             else
; 397  :                 EmitWarn( 2, SEGMENT_EXCEEDS_64K_LIMIT, curr->sym.name );

	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 222				; 000000deH
	mov	ecx, 2
	call	EmitWarn
$LN10@WriteModul:
$LN8@WriteModul:

; 398  :         }
; 399  :     }

	jmp	SHORT $LN2@WriteModul
$LN3@WriteModul:

; 400  : 
; 401  :     modinfo->g.WriteModule( modinfo );

	mov	rcx, QWORD PTR modinfo$[rsp]
	mov	rax, QWORD PTR modinfo$[rsp]
	call	QWORD PTR [rax+288]

; 402  : 
; 403  : #if DLLIMPORT
; 404  :     /* is the -Fd option given with a file name? */
; 405  :     if ( Options.names[OPTN_LNKDEF_FN] ) {

	mov	eax, 8
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax], 0
	je	$LN11@WriteModul

; 406  :         FILE *ld;
; 407  :         ld = fopen( Options.names[OPTN_LNKDEF_FN], "w" );

	mov	eax, 8
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:Options+32
	lea	rdx, OFFSET FLAT:$SG11859
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_fopen
	mov	QWORD PTR ld$1[rsp], rax

; 408  :         if ( ld == NULL ) {

	cmp	QWORD PTR ld$1[rsp], 0
	jne	SHORT $LN12@WriteModul

; 409  :             return( EmitErr( CANNOT_OPEN_FILE, Options.names[OPTN_LNKDEF_FN], ErrnoStr() ) );

	call	ErrnoStr
	mov	ecx, 8
	imul	rcx, rcx, 4
	lea	rdx, OFFSET FLAT:Options+32
	mov	r8, rax
	mov	rdx, QWORD PTR [rdx+rcx]
	mov	ecx, 106				; 0000006aH
	call	EmitErr
	jmp	$LN1@WriteModul
$LN12@WriteModul:

; 410  :         }
; 411  :         for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN7@WriteModul
$LN5@WriteModul:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN7@WriteModul:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN6@WriteModul

; 412  :             DebugMsg(("WriteModule: ext=%s, isproc=%u, weak=%u\n", curr->sym.name, curr->sym.isproc, curr->sym.weak ));

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	mov	rcx, QWORD PTR curr$[rsp]
	movzx	ecx, BYTE PTR [rcx+41]
	shr	cl, 3
	and	cl, 1
	movzx	ecx, cl
	mov	r9d, eax
	mov	r8d, ecx
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11861
	call	DoDebugMsg

; 413  :             if ( curr->sym.isproc && ( curr->sym.weak == FALSE || curr->sym.iat_used ) &&
; 414  :                 curr->sym.dll && *(curr->sym.dll->name) != NULLC ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN13@WriteModul
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@WriteModul
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN13@WriteModul
$LN14@WriteModul:
	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	$LN13@WriteModul
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	ecx, 1
	imul	rcx, rcx, 0
	movsx	eax, BYTE PTR [rax+rcx+12]
	test	eax, eax
	je	SHORT $LN13@WriteModul

; 415  :                 int size;
; 416  :                 Mangle( &curr->sym, StringBufferEnd );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, rax
	call	Mangle

; 417  :                 size = sprintf( CurrSource, "import '%s'  %s.%s\n", StringBufferEnd, curr->sym.dll->name, curr->sym.name );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+56]
	add	rax, 12
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rax
	mov	r8, QWORD PTR ModuleInfo+488
	lea	rdx, OFFSET FLAT:$SG11864
	mov	rcx, QWORD PTR ModuleInfo+464
	call	sprintf
	mov	DWORD PTR size$2[rsp], eax

; 418  :                 if ( fwrite( CurrSource, 1, size, ld ) != size )

	movsxd	rax, DWORD PTR size$2[rsp]
	mov	r9, QWORD PTR ld$1[rsp]
	mov	r8, rax
	mov	edx, 1
	mov	rcx, QWORD PTR ModuleInfo+464
	call	QWORD PTR __imp_fwrite
	movsxd	rcx, DWORD PTR size$2[rsp]
	cmp	rax, rcx
	je	SHORT $LN15@WriteModul

; 419  :                     WriteError();

	call	WriteError
$LN15@WriteModul:
$LN13@WriteModul:

; 420  :             }
; 421  :         }

	jmp	$LN5@WriteModul
$LN6@WriteModul:

; 422  :         fclose( ld );

	mov	rcx, QWORD PTR ld$1[rsp]
	call	QWORD PTR __imp_fclose
$LN11@WriteModul:

; 423  :     }
; 424  : #endif
; 425  :     DebugMsg(("WriteModule exit\n"));

	lea	rcx, OFFSET FLAT:$SG11866
	call	DoDebugMsg

; 426  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@WriteModul:

; 427  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
WriteModule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
idx$1 = 32
i$2 = 36
tv84 = 40
pBytes$ = 64
len$ = 72
OutputBinBytes PROC

; 238  : {

$LN14:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 239  : 
; 240  : 	if (write_to_file == TRUE) {

	movzx	eax, BYTE PTR write_to_file
	cmp	eax, 1
	jne	$LN5@OutputBinB

; 241  : 		uint_32 idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	DWORD PTR idx$1[rsp], eax

; 242  : #ifdef DEBUG_OUT
; 243  : 		if (CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]

; 244  : 			;//_asm int 3;
; 245  : 		}
; 246  : #endif
; 247  : 		/**/myassert(CurrSeg->e.seginfo->current_loc >= CurrSeg->e.seginfo->start_loc);

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+12], ecx
	jb	SHORT $LN12@OutputBinB
	mov	DWORD PTR tv84[rsp], 0
	jmp	SHORT $LN13@OutputBinB
$LN12@OutputBinB:
	mov	edx, 247				; 000000f7H
	lea	rcx, OFFSET FLAT:$SG11786
	call	InternalError
	mov	DWORD PTR tv84[rsp], eax
$LN13@OutputBinB:

; 248  : 		if (Options.output_format == OFORMAT_OMF && idx >= MAX_LEDATA_THRESHOLD) {

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN8@OutputBinB
	cmp	DWORD PTR idx$1[rsp], 1014		; 000003f6H
	jb	SHORT $LN8@OutputBinB

; 249  : 			omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 250  : 			idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	DWORD PTR idx$1[rsp], eax
$LN8@OutputBinB:

; 251  : 		}
; 252  : 		//DebugMsg(("OutputByte: buff=%p, idx=%" I32_SPEC "X, byte=%X, codebuff[0]=%X\n", CurrSeg->e.seginfo->CodeBuffer, idx, byte, *CurrSeg->e.seginfo->CodeBuffer ));
; 253  : 		int i;
; 254  : 		for (i = 0; i < len; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN4@OutputBinB
$LN2@OutputBinB:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN4@OutputBinB:
	mov	eax, DWORD PTR len$[rsp]
	cmp	DWORD PTR i$2[rsp], eax
	jae	SHORT $LN3@OutputBinB

; 255  : 			CurrSeg->e.seginfo->CodeBuffer[idx++] = *(pBytes++);

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR idx$1[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rdx, QWORD PTR pBytes$[rsp]
	movzx	edx, BYTE PTR [rdx]
	mov	BYTE PTR [rax+rcx], dl
	mov	eax, DWORD PTR idx$1[rsp]
	inc	eax
	mov	DWORD PTR idx$1[rsp], eax
	mov	rax, QWORD PTR pBytes$[rsp]
	inc	rax
	mov	QWORD PTR pBytes$[rsp], rax
	jmp	SHORT $LN2@OutputBinB
$LN3@OutputBinB:

; 256  : 
; 257  : 	}

	jmp	SHORT $LN6@OutputBinB
$LN5@OutputBinB:

; 258  : #if 1
; 259  : 	/* check this in pass 1 only */
; 260  : 	else if (CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+12], ecx
	jae	SHORT $LN9@OutputBinB

; 261  : 		DebugMsg(("OutputByte: segment start loc changed from %" I32_SPEC "Xh to %" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	r8d, DWORD PTR [rax+12]
	mov	edx, DWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG11789
	call	DoDebugMsg

; 262  : 			CurrSeg->e.seginfo->start_loc,
; 263  : 			CurrSeg->e.seginfo->current_loc));
; 264  : 		CurrSeg->e.seginfo->start_loc = CurrSeg->e.seginfo->current_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+8], eax
$LN9@OutputBinB:
$LN6@OutputBinB:

; 265  : 	}
; 266  : #endif
; 267  : 	CurrSeg->e.seginfo->current_loc+=len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	add	eax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+12], eax

; 268  : 	CurrSeg->e.seginfo->bytes_written+=len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+24]
	add	eax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+24], eax

; 269  : 	CurrSeg->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+107], al

; 270  : 	if (CurrSeg->e.seginfo->current_loc > CurrSeg->sym.max_offset)

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	ecx, DWORD PTR [rcx+56]
	cmp	DWORD PTR [rax+12], ecx
	jbe	SHORT $LN10@OutputBinB

; 271  : 		CurrSeg->sym.max_offset = CurrSeg->e.seginfo->current_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+56], eax
$LN10@OutputBinB:

; 272  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
OutputBinBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
seg$ = 48
value$ = 56
relative$ = 64
select_data$ = 72
SetCurrOffset PROC

; 337  : {

$LN15:
	mov	BYTE PTR [rsp+32], r9b
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 338  :     if( relative )

	movzx	eax, BYTE PTR relative$[rsp]
	test	eax, eax
	je	SHORT $LN2@SetCurrOff

; 339  :         value += seg->e.seginfo->current_loc;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	mov	ecx, DWORD PTR value$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR value$[rsp], eax
$LN2@SetCurrOff:

; 340  : 
; 341  :     if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN3@SetCurrOff

; 342  :         if ( seg == CurrSeg ) {

	mov	rax, QWORD PTR ModuleInfo+432
	cmp	QWORD PTR seg$[rsp], rax
	jne	SHORT $LN5@SetCurrOff

; 343  :             if ( write_to_file == TRUE )

	movzx	eax, BYTE PTR write_to_file
	cmp	eax, 1
	jne	SHORT $LN6@SetCurrOff

; 344  :                 omf_FlushCurrSeg();

	call	omf_FlushCurrSeg
$LN6@SetCurrOff:

; 345  : 
; 346  :         /* for debugging, tell if data is located in code sections*/
; 347  :             if( select_data )

	movzx	eax, BYTE PTR select_data$[rsp]
	test	eax, eax
	je	SHORT $LN7@SetCurrOff

; 348  :                 if ( ModuleInfo.CommentDataInCode )

	movzx	eax, BYTE PTR ModuleInfo+423
	test	eax, eax
	je	SHORT $LN8@SetCurrOff

; 349  :                     omf_OutSelect( TRUE );

	mov	cl, 1
	call	omf_OutSelect
$LN8@SetCurrOff:
$LN7@SetCurrOff:

; 350  :             LastCodeBufSize = value;

	mov	eax, DWORD PTR value$[rsp]
	mov	DWORD PTR LastCodeBufSize, eax
$LN5@SetCurrOff:

; 351  :         }
; 352  :         seg->e.seginfo->start_loc = value;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 353  :     /* for -bin, if there's an ORG (relative==false) and no initialized data
; 354  :      * has been set yet, set start_loc!
; 355  :      * v1.96: this is now also done for COFF and ELF
; 356  :      */
; 357  :     /* else if ( Options.output_format == OFORMAT_BIN && relative == FALSE ) { */
; 358  :     } else {

	jmp	SHORT $LN4@SetCurrOff
$LN3@SetCurrOff:

; 359  :         if ( write_to_file == FALSE ) {

	movzx	eax, BYTE PTR write_to_file
	test	eax, eax
	jne	SHORT $LN9@SetCurrOff

; 360  :             if ( relative ) {

	movzx	eax, BYTE PTR relative$[rsp]
	test	eax, eax
	je	SHORT $LN10@SetCurrOff

; 361  : #if 0 /* don't include "preceding" uninitialized data */
; 362  :                 if( seg->e.seginfo->current_loc < seg->e.seginfo->start_loc )
; 363  :                     seg->e.seginfo->start_loc = seg->e.seginfo->current_loc;
; 364  : #endif
; 365  :             } else {

	jmp	SHORT $LN11@SetCurrOff
$LN10@SetCurrOff:

; 366  :                 if ( seg->e.seginfo->bytes_written == 0 )

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN12@SetCurrOff

; 367  :                     seg->e.seginfo->start_loc = value;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax+8], ecx
$LN12@SetCurrOff:
$LN11@SetCurrOff:
$LN9@SetCurrOff:
$LN4@SetCurrOff:

; 368  :             }
; 369  :         }
; 370  :     }
; 371  : 
; 372  :     seg->e.seginfo->current_loc = value;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax+12], ecx

; 373  :     seg->e.seginfo->written = FALSE;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	and	al, 223					; 000000dfH
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+107], al

; 374  : 
; 375  :     if( seg->e.seginfo->current_loc > seg->sym.max_offset )

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	cmp	DWORD PTR [rax+12], ecx
	jbe	SHORT $LN13@SetCurrOff

; 376  :         seg->sym.max_offset = seg->e.seginfo->current_loc;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+56], eax
$LN13@SetCurrOff:

; 377  : 
; 378  :     return( NOT_ERROR );

	xor	eax, eax

; 379  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetCurrOffset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
p$ = 32
tv74 = 40
string$ = 64
WritePreprocessedLine PROC

; 584  : {

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 585  :     static bool PrintEmptyLine = TRUE;
; 586  :     const char *p;
; 587  : 
; 588  : #if 0 /* v2.08: removed, obsolete */
; 589  :     /* filter some macro specific directives */
; 590  :     if ( tokenarray[0].token == T_DIRECTIVE &&
; 591  :          ( tokenarray[0].tokval == T_ENDM ||
; 592  :            tokenarray[0].tokval == T_EXITM))
; 593  :         return;
; 594  :     /* don't print generated code - with one exception:
; 595  :      if the code was generated as a result of structure initialization,
; 596  :      then do!
; 597  :      */
; 598  :     if ( GeneratedCode )
; 599  :         return;
; 600  : #endif
; 601  :     if ( Token_Count > 0 ) {

	cmp	DWORD PTR ModuleInfo+496, 0
	jle	SHORT $LN5@WritePrepr

; 602  :         /* v2.08: don't print a leading % (this char is no longer filtered) */
; 603  :         for ( p = string; isspace( *p ); p++ );

	mov	rax, QWORD PTR string$[rsp]
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN4@WritePrepr
$LN2@WritePrepr:
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN4@WritePrepr:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN3@WritePrepr
	jmp	SHORT $LN2@WritePrepr
$LN3@WritePrepr:

; 604  :         printf("%s\n", *p == '%' ? p+1 : string );

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN9@WritePrepr
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR tv74[rsp], rax
	jmp	SHORT $LN10@WritePrepr
$LN9@WritePrepr:
	mov	rax, QWORD PTR string$[rsp]
	mov	QWORD PTR tv74[rsp], rax
$LN10@WritePrepr:
	mov	rdx, QWORD PTR tv74[rsp]
	lea	rcx, OFFSET FLAT:$SG11931
	call	printf

; 605  :         PrintEmptyLine = TRUE;

	mov	BYTE PTR ?PrintEmptyLine@?1??WritePreprocessedLine@@9@9, 1
	jmp	SHORT $LN6@WritePrepr
$LN5@WritePrepr:

; 606  :     } else if ( PrintEmptyLine ) {

	movzx	eax, BYTE PTR ?PrintEmptyLine@?1??WritePreprocessedLine@@9@9
	test	eax, eax
	je	SHORT $LN7@WritePrepr

; 607  :         PrintEmptyLine = FALSE;

	mov	BYTE PTR ?PrintEmptyLine@?1??WritePreprocessedLine@@9@9, 0

; 608  :         printf("\n");

	lea	rcx, OFFSET FLAT:$SG11933
	call	printf
$LN7@WritePrepr:
$LN6@WritePrepr:

; 609  :     }
; 610  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
WritePreprocessedLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
i$ = 32
sym$ = 64
pst$ = 72
buffer$ = 80
ConvertSectionName PROC

; 166  : {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 167  :     int i;
; 168  : 
; 169  :     for ( i = 0; i < sizeof( cst ) / sizeof( cst[0] ); i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@ConvertSec
$LN2@ConvertSec:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@ConvertSec:
	movsxd	rax, DWORD PTR i$[rsp]
	cmp	rax, 4
	jae	$LN3@ConvertSec

; 170  :         if ( memcmp( sym->name, cst[i].src, cst[i].len ) == 0 ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 24
	lea	rdx, OFFSET FLAT:cst
	mov	r8d, eax
	mov	rdx, QWORD PTR [rdx+rcx+8]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcmp
	test	eax, eax
	jne	$LN5@ConvertSec

; 171  :             if ( sym->name[cst[i].len] == NULLC || ( sym->name[cst[i].len] == '$' && ( cst[i].flags & CSF_GRPCHK ) ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN7@ConvertSec
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 36					; 00000024H
	jne	$LN6@ConvertSec
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax+1]
	and	eax, 1
	test	eax, eax
	je	$LN6@ConvertSec
$LN7@ConvertSec:

; 172  : 
; 173  :                 if ( pst ) {

	cmp	QWORD PTR pst$[rsp], 0
	je	SHORT $LN8@ConvertSec

; 174  :                     if ( i == CSI_BSS && ( (struct dsym *)sym)->e.seginfo->bytes_written != 0 )

	cmp	DWORD PTR i$[rsp], 3
	jne	SHORT $LN9@ConvertSec
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+24], 0
	je	SHORT $LN9@ConvertSec

; 175  :                         ; /* don't set segment type to BSS if the segment contains initialized data */

	jmp	SHORT $LN10@ConvertSec
$LN9@ConvertSec:

; 176  :                     else
; 177  :                         *pst = stt[i];

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:stt
	mov	rdx, QWORD PTR pst$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR [rdx], eax
$LN10@ConvertSec:
$LN8@ConvertSec:

; 178  :                 }
; 179  : 
; 180  :                 if ( sym->name[cst[i].len] == NULLC ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN11@ConvertSec

; 181  : #if DJGPP_SUPPORT
; 182  :                     /* DJGPP won't be happy with .rdata segment name */
; 183  :                     if( ModuleInfo.sub_format == SFORMAT_DJGPP && i == CSI_CONST )
; 184  :                         return( ".const" );
; 185  : #endif
; 186  :                     return( (char *)cst[i].dst );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	mov	rax, QWORD PTR [rcx+rax+16]
	jmp	SHORT $LN1@ConvertSec
$LN11@ConvertSec:

; 187  :                 }
; 188  : 
; 189  :                 strcpy( buffer, cst[i].dst );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	mov	rdx, QWORD PTR [rcx+rax+16]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcpy

; 190  :                 strcat( buffer, sym->name+cst[i].len );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR sym$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	rdx, rax
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcat

; 191  :                 return( buffer );

	mov	rax, QWORD PTR buffer$[rsp]
	jmp	SHORT $LN1@ConvertSec
$LN6@ConvertSec:
$LN5@ConvertSec:

; 192  :             }
; 193  :         }
; 194  :     }

	jmp	$LN2@ConvertSec
$LN3@ConvertSec:

; 195  :     return( sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
$LN1@ConvertSec:

; 196  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
ConvertSectionName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
close_files PROC

; 1221 : {

$LN12:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1222 :     /* v2.11: no fatal errors anymore if fclose() fails.
; 1223 :      * That's because Fatal() may cause close_files() to be
; 1224 :      * reentered and thus cause an endless loop.
; 1225 :      */
; 1226 : 
; 1227 :     /* close ASM file */
; 1228 :     if( CurrFile[ASM] != NULL ) {

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN2@close_file

; 1229 :         if( fclose( CurrFile[ASM] ) != 0 )

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_fclose
	test	eax, eax
	je	SHORT $LN3@close_file

; 1230 :             EmitErr( CANNOT_CLOSE_FILE, CurrFName[ASM], errno );

	call	QWORD PTR __imp__errno
	mov	ecx, 8
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:ModuleInfo+128
	mov	r8d, DWORD PTR [rax]
	mov	rdx, QWORD PTR [rdx+rcx]
	mov	ecx, 107				; 0000006bH
	call	EmitErr
$LN3@close_file:

; 1231 :         CurrFile[ASM] = NULL;

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR [rcx+rax], 0
$LN2@close_file:

; 1232 :     }
; 1233 : 
; 1234 :     /* close OBJ file */
; 1235 :     if ( CurrFile[OBJ] != NULL ) {

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN4@close_file

; 1236 :         if ( fclose( CurrFile[OBJ] ) != 0 )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_fclose
	test	eax, eax
	je	SHORT $LN5@close_file

; 1237 :             EmitErr( CANNOT_CLOSE_FILE, CurrFName[OBJ], errno );

	call	QWORD PTR __imp__errno
	mov	ecx, 8
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:ModuleInfo+128
	mov	r8d, DWORD PTR [rax]
	mov	rdx, QWORD PTR [rdx+rcx]
	mov	ecx, 107				; 0000006bH
	call	EmitErr
$LN5@close_file:

; 1238 :         CurrFile[OBJ] = NULL;

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR [rcx+rax], 0
$LN4@close_file:

; 1239 :     }
; 1240 :     /* delete the object module if errors occured */
; 1241 :     if ( Options.syntax_check_only == FALSE &&

	movzx	eax, BYTE PTR Options+188
	test	eax, eax
	jne	SHORT $LN6@close_file
	cmp	DWORD PTR ModuleInfo, 0
	jbe	SHORT $LN6@close_file

; 1242 :         ModuleInfo.g.error_count > 0 ) {
; 1243 :         remove( CurrFName[OBJ] );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_remove
$LN6@close_file:

; 1244 :     }
; 1245 : 
; 1246 :     if( CurrFile[LST] != NULL ) {

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN7@close_file

; 1247 :         fclose( CurrFile[LST] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_fclose

; 1248 :         CurrFile[LST] = NULL;

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR [rcx+rax], 0
$LN7@close_file:

; 1249 :     }
; 1250 : 
; 1251 :     /* close ERR file */
; 1252 :     if ( CurrFile[ERR] != NULL ) {

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN8@close_file

; 1253 :         fclose( CurrFile[ERR] );

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_fclose

; 1254 :         CurrFile[ERR] = NULL;

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR [rcx+rax], 0
	jmp	SHORT $LN9@close_file
$LN8@close_file:

; 1255 :     } else if ( CurrFName[ERR] )

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN10@close_file

; 1256 :         /* nothing written, delete any existing ERR file */
; 1257 :         remove( CurrFName[ERR] );

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_remove
$LN10@close_file:
$LN9@close_file:

; 1258 :     return;
; 1259 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
close_files ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
value$ = 16
SetMasm510 PROC

; 616  : {

$LN6:
	mov	BYTE PTR [rsp+8], cl
	push	rdi

; 617  :     ModuleInfo.m510 = value;

	movzx	eax, BYTE PTR value$[rsp]
	and	eax, 1
	shl	eax, 6
	mov	ecx, DWORD PTR ModuleInfo+408
	and	ecx, -65				; ffffffbfH
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 618  :     ModuleInfo.oldstructs = value;

	movzx	eax, BYTE PTR value$[rsp]
	and	eax, 1
	shl	eax, 8
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 8
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 619  :     /* ModuleInfo.oldmacros = value; not implemented yet */
; 620  :     ModuleInfo.dotname = value;

	movzx	eax, BYTE PTR value$[rsp]
	and	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR ModuleInfo+408
	and	ecx, -17				; ffffffefH
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 621  :     ModuleInfo.setif2 = value;

	movzx	eax, BYTE PTR value$[rsp]
	and	eax, 1
	shl	eax, 10
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 10
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 622  : 
; 623  :     if ( value ) {

	movzx	eax, BYTE PTR value$[rsp]
	test	eax, eax
	je	SHORT $LN2@SetMasm510

; 624  :         if ( ModuleInfo.model == MODEL_NONE ) {

	cmp	DWORD PTR ModuleInfo+360, 0
	jne	SHORT $LN3@SetMasm510

; 625  :             /* if no model is specified, set OFFSET:SEGMENT */
; 626  :             ModuleInfo.offsettype = OT_SEGMENT;

	mov	DWORD PTR ModuleInfo+384, 2

; 627  :             if ( ModuleInfo.langtype == LANG_NONE ) {

	cmp	DWORD PTR ModuleInfo+364, 0
	jne	SHORT $LN4@SetMasm510

; 628  :                 ModuleInfo.scoped = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	btr	eax, 7
	mov	DWORD PTR ModuleInfo+408, eax

; 629  :                 ModuleInfo.procs_private = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	or	eax, 4
	mov	DWORD PTR ModuleInfo+408, eax
$LN4@SetMasm510:
$LN3@SetMasm510:
$LN2@SetMasm510:

; 630  :             }
; 631  :         }
; 632  :     }
; 633  :     return;
; 634  : }

	pop	rdi
	ret	0
SetMasm510 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
prev_written$ = 64
curr_written$ = 68
starttime$ = 72
endtime$ = 76
seg$ = 80
tv209 = 88
tv211 = 92
tv213 = 96
tv215 = 104
tv264 = 112
source$ = 144
AssembleModule PROC

; 1426 : {

$LN31:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rdi, rsp
	mov	ecx, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+144]

; 1427 :     uint_32       prev_written = -1;

	mov	DWORD PTR prev_written$[rsp], -1	; ffffffffH

; 1428 :     uint_32       curr_written;
; 1429 :     int           starttime;
; 1430 :     int           endtime;
; 1431 :     struct dsym   *seg;
; 1432 : 
; 1433 :     DebugMsg(("AssembleModule(\"%s\") enter\n", source ));

	mov	rdx, QWORD PTR source$[rsp]
	lea	rcx, OFFSET FLAT:$SG12203
	call	DoDebugMsg

; 1434 : 
; 1435 :     memset( &ModuleInfo, 0, sizeof(ModuleInfo) );

	mov	r8d, 776				; 00000308H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:ModuleInfo
	call	memset

; 1436 :     DebugCmd( ModuleInfo.cref = TRUE ); /* enable debug displays */

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 12
	mov	DWORD PTR ModuleInfo+408, eax

; 1437 : 
; 1438 : #if 1 //def __SW_BD
; 1439 :     /* fatal errors during assembly won't terminate the program,
; 1440 :      * just the assembly step.!
; 1441 :      */
; 1442 :     if ( setjmp( jmpenv ) ) {

	lea	rcx, OFFSET FLAT:jmpenv
	mov	rdx, rsp
	call	_setjmp
	test	eax, eax
	je	SHORT $LN11@AssembleMo

; 1443 :         if ( ModuleInfo.g.src_stack )

	cmp	QWORD PTR ModuleInfo+200, 0
	je	SHORT $LN12@AssembleMo

; 1444 :             ClearSrcStack(); /* avoid memory leaks! */

	call	ClearSrcStack
$LN12@AssembleMo:

; 1445 :         goto done;

	jmp	$done$32
$LN11@AssembleMo:

; 1446 :     }
; 1447 : #endif
; 1448 : 
; 1449 :     AssembleInit( source );

	mov	rcx, QWORD PTR source$[rsp]
	call	AssembleInit

; 1450 : 
; 1451 :     starttime = clock();

	call	QWORD PTR __imp_clock
	mov	DWORD PTR starttime$[rsp], eax

; 1452 : 
; 1453 : #if 0 /* 1=trigger a protection fault */
; 1454 :     seg = NULL;
; 1455 :     seg->sym.state = SYM_UNDEFINED;
; 1456 : #endif
; 1457 : 
; 1458 :     for( Parse_Pass = PASS_1; ; Parse_Pass++ ) {

	mov	DWORD PTR Parse_Pass, 0
	jmp	SHORT $LN4@AssembleMo
$LN2@AssembleMo:
	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	DWORD PTR Parse_Pass, eax
$LN4@AssembleMo:

; 1459 : 
; 1460 :         DebugMsg(( "*************\npass %u\n*************\n", Parse_Pass + 1 ));

	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12206
	call	DoDebugMsg

; 1461 :         OnePass();

	call	OnePass

; 1462 : 
; 1463 :         if( ModuleInfo.g.error_count > 0 ) {

	cmp	DWORD PTR ModuleInfo, 0
	jbe	SHORT $LN13@AssembleMo

; 1464 :             DebugMsg(("AssembleModule(%u): errorcnt=%u\n", Parse_Pass + 1, ModuleInfo.g.error_count ));

	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	r8d, DWORD PTR ModuleInfo
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12208
	call	DoDebugMsg

; 1465 :             break;

	jmp	$LN3@AssembleMo
$LN13@AssembleMo:

; 1466 :         }
; 1467 : 
; 1468 :         /* calculate total size of segments */
; 1469 :         for ( curr_written = 0, seg = SymTables[TAB_SEG].head; seg ; seg = seg->next ) {

	mov	DWORD PTR curr_written$[rsp], 0
	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR seg$[rsp], rax
	jmp	SHORT $LN7@AssembleMo
$LN5@AssembleMo:
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR seg$[rsp], rax
$LN7@AssembleMo:
	cmp	QWORD PTR seg$[rsp], 0
	je	SHORT $LN6@AssembleMo

; 1470 :             /* v2.04: use <max_offset> instead of <bytes_written>
; 1471 :              * (the latter is not always reliable due to backpatching).
; 1472 :              */
; 1473 :             //curr_written += seg->e.seginfo->bytes_written;
; 1474 :             curr_written += seg->sym.max_offset;

	mov	rax, QWORD PTR seg$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	ecx, DWORD PTR curr_written$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR curr_written$[rsp], eax

; 1475 :             DebugMsg(("AssembleModule(%u): segm=%-8s start=%8" I32_SPEC "X max_ofs=%8" I32_SPEC "X written=%" I32_SPEC "X\n",

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	edx, DWORD PTR Parse_Pass
	inc	edx
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR seg$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR [rcx+8]
	mov	rax, QWORD PTR seg$[rsp]
	mov	r8, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12209
	call	DoDebugMsg

; 1476 :                       Parse_Pass + 1, seg->sym.name, seg->e.seginfo->start_loc, seg->sym.max_offset,
; 1477 :                       seg->e.seginfo->bytes_written ));
; 1478 :         }

	jmp	SHORT $LN5@AssembleMo
$LN6@AssembleMo:

; 1479 : 
; 1480 :         /* if there's no phase error and size of segments didn't change, we're done */
; 1481 :         DebugMsg(("AssembleModule(%u): PhaseError=%u, prev_written=%" I32_SPEC "X, curr_written=%" I32_SPEC "X\n", Parse_Pass + 1, ModuleInfo.PhaseError, prev_written, curr_written));

	movzx	eax, BYTE PTR ModuleInfo+422
	mov	ecx, DWORD PTR Parse_Pass
	inc	ecx
	mov	edx, DWORD PTR curr_written$[rsp]
	mov	DWORD PTR [rsp+32], edx
	mov	r9d, DWORD PTR prev_written$[rsp]
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG12210
	call	DoDebugMsg

; 1482 :         if( !ModuleInfo.PhaseError && prev_written == curr_written )

	movzx	eax, BYTE PTR ModuleInfo+422
	test	eax, eax
	jne	SHORT $LN14@AssembleMo
	mov	eax, DWORD PTR curr_written$[rsp]
	cmp	DWORD PTR prev_written$[rsp], eax
	jne	SHORT $LN14@AssembleMo

; 1483 :             break;

	jmp	$LN3@AssembleMo
$LN14@AssembleMo:

; 1484 : 
; 1485 : #ifdef DEBUG_OUT
; 1486 :         if ( curr_written < prev_written && prev_written != -1 ) {

	mov	eax, DWORD PTR prev_written$[rsp]
	cmp	DWORD PTR curr_written$[rsp], eax
	jae	SHORT $LN15@AssembleMo
	cmp	DWORD PTR prev_written$[rsp], -1	; ffffffffH
	je	SHORT $LN15@AssembleMo

; 1487 :             printf( "size shrank from %" I32_SPEC "X to %" I32_SPEC "X in pass %u\n", prev_written, curr_written, Parse_Pass + 1 );

	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	r9d, eax
	mov	r8d, DWORD PTR curr_written$[rsp]
	mov	edx, DWORD PTR prev_written$[rsp]
	lea	rcx, OFFSET FLAT:$SG12213
	call	printf
$LN15@AssembleMo:

; 1488 :         }
; 1489 : #endif
; 1490 : 
; 1491 :         DebugMsg(("AssembleModule(%u): prepare for next pass\n", Parse_Pass + 1));

	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12214
	call	DoDebugMsg

; 1492 :         prev_written = curr_written;

	mov	eax, DWORD PTR curr_written$[rsp]
	mov	DWORD PTR prev_written$[rsp], eax

; 1493 : 
; 1494 :         if ( Parse_Pass % 200 == 199 )

	xor	edx, edx
	mov	eax, DWORD PTR Parse_Pass
	mov	ecx, 200				; 000000c8H
	div	ecx
	mov	eax, edx
	cmp	eax, 199				; 000000c7H
	jne	SHORT $LN16@AssembleMo

; 1495 :             EmitWarn( 2, ASSEMBLY_PASSES, Parse_Pass+1 );

	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	r8d, eax
	mov	edx, 240				; 000000f0H
	mov	ecx, 2
	call	EmitWarn
$LN16@AssembleMo:

; 1496 : #ifdef DEBUG_OUT
; 1497 :         if ( Options.max_passes && Parse_Pass == (Options.max_passes - 1) )

	movzx	eax, WORD PTR Options+20
	test	eax, eax
	je	SHORT $LN17@AssembleMo
	movzx	eax, WORD PTR Options+20
	dec	eax
	cmp	DWORD PTR Parse_Pass, eax
	jne	SHORT $LN17@AssembleMo

; 1498 :             break;

	jmp	$LN3@AssembleMo
$LN17@AssembleMo:

; 1499 : #endif
; 1500 :         if ( Options.line_numbers ) {

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	$LN18@AssembleMo

; 1501 : #if COFF_SUPPORT
; 1502 :             if ( Options.output_format == OFORMAT_COFF ) {

	cmp	DWORD PTR Options+160, 2
	jne	SHORT $LN19@AssembleMo

; 1503 :                 for( seg = SymTables[TAB_SEG].head; seg; seg = seg->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR seg$[rsp], rax
	jmp	SHORT $LN10@AssembleMo
$LN8@AssembleMo:
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR seg$[rsp], rax
$LN10@AssembleMo:
	cmp	QWORD PTR seg$[rsp], 0
	je	SHORT $LN9@AssembleMo

; 1504 :                     if ( seg->e.seginfo->LinnumQueue )

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN21@AssembleMo

; 1505 :                         QueueDeleteLinnum( seg->e.seginfo->LinnumQueue );

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR [rax+56]
	call	QueueDeleteLinnum
$LN21@AssembleMo:

; 1506 :                     seg->e.seginfo->LinnumQueue = NULL;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rax+56], 0

; 1507 :                 }

	jmp	SHORT $LN8@AssembleMo
$LN9@AssembleMo:

; 1508 :             } else {

	jmp	SHORT $LN20@AssembleMo
$LN19@AssembleMo:

; 1509 : #endif
; 1510 :                 QueueDeleteLinnum( &LinnumQueue );

	lea	rcx, OFFSET FLAT:LinnumQueue
	call	QueueDeleteLinnum

; 1511 :                 LinnumQueue.head = NULL;

	mov	QWORD PTR LinnumQueue, 0
$LN20@AssembleMo:
$LN18@AssembleMo:

; 1512 : #if COFF_SUPPORT
; 1513 :             }
; 1514 : #endif
; 1515 :         }
; 1516 : 
; 1517 :         /* set file position of ASM and LST files for next pass */
; 1518 : 
; 1519 :         rewind( CurrFile[ASM] );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_rewind

; 1520 :         if ( write_to_file && Options.output_format == OFORMAT_OMF )

	movzx	eax, BYTE PTR write_to_file
	test	eax, eax
	je	SHORT $LN22@AssembleMo
	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN22@AssembleMo

; 1521 :             omf_set_filepos();

	call	omf_set_filepos
$LN22@AssembleMo:

; 1522 : 
; 1523 : #if FASTPASS
; 1524 :         if ( UseSavedState == FALSE && CurrFile[LST] ) {

	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	jne	SHORT $LN23@AssembleMo
	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN23@AssembleMo

; 1525 : #else
; 1526 :         if ( CurrFile[LST] ) {
; 1527 : #endif
; 1528 :             rewind( CurrFile[LST] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_rewind

; 1529 :             LstInit();

	call	LstInit
$LN23@AssembleMo:

; 1530 :         }
; 1531 :     } /* end for() */

	jmp	$LN2@AssembleMo
$LN3@AssembleMo:

; 1532 : 
; 1533 :     if ( ( Parse_Pass > PASS_1 ) && write_to_file )

	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN24@AssembleMo
	movzx	eax, BYTE PTR write_to_file
	test	eax, eax
	je	SHORT $LN24@AssembleMo

; 1534 :         WriteModule( &ModuleInfo );

	lea	rcx, OFFSET FLAT:ModuleInfo
	call	WriteModule
$LN24@AssembleMo:

; 1535 : 
; 1536 :     if ( ModuleInfo.pCodeBuff ) {
; 1537 :         LclFree( ModuleInfo.pCodeBuff );
; 1538 :     }
; 1539 :     DebugMsg(("AssembleModule: finished, cleanup\n"));

	lea	rcx, OFFSET FLAT:$SG12225
	call	DoDebugMsg

; 1540 : 
; 1541 :     /* Write a symbol listing file (if requested) */
; 1542 :     LstWriteCRef();

	call	LstWriteCRef

; 1543 : 
; 1544 :     endtime = clock(); /* is in ms already */

	call	QWORD PTR __imp_clock
	mov	DWORD PTR endtime$[rsp], eax

; 1545 : 
; 1546 :     sprintf( CurrSource, MsgGetEx( MSG_ASSEMBLY_RESULTS ),

	mov	eax, DWORD PTR starttime$[rsp]
	mov	ecx, DWORD PTR endtime$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv209[rsp], eax
	mov	ecx, DWORD PTR Parse_Pass
	inc	ecx
	mov	DWORD PTR tv211[rsp], ecx
	call	GetLineNumber
	mov	DWORD PTR tv213[rsp], eax
	mov	ecx, DWORD PTR ModuleInfo+428
	call	GetFName
	mov	QWORD PTR tv215[rsp], rax
	mov	ecx, 1
	call	MsgGetEx
	mov	ecx, DWORD PTR ModuleInfo
	mov	DWORD PTR [rsp+56], ecx
	mov	ecx, DWORD PTR ModuleInfo+4
	mov	DWORD PTR [rsp+48], ecx
	mov	ecx, DWORD PTR tv209[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	ecx, DWORD PTR tv211[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	ecx, DWORD PTR tv213[rsp]
	mov	r9d, ecx
	mov	rcx, QWORD PTR tv215[rsp]
	mov	r8, QWORD PTR [rcx]
	mov	rdx, rax
	mov	rcx, QWORD PTR ModuleInfo+464
	call	sprintf

; 1547 :              GetFName( ModuleInfo.srcfile )->fname,
; 1548 :              GetLineNumber(),
; 1549 :              Parse_Pass + 1,
; 1550 :              endtime - starttime,
; 1551 :              ModuleInfo.g.warning_count,
; 1552 :              ModuleInfo.g.error_count);
; 1553 :     if ( Options.quiet == FALSE )

	movzx	eax, BYTE PTR Options
	test	eax, eax
	jne	SHORT $LN26@AssembleMo

; 1554 :         printf( "%s\n", CurrSource );

	mov	rdx, QWORD PTR ModuleInfo+464
	lea	rcx, OFFSET FLAT:$SG12227
	call	printf
$LN26@AssembleMo:

; 1555 : 
; 1556 :     if ( CurrFile[LST] ) {

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN27@AssembleMo

; 1557 :         LstPrintf( CurrSource );

	mov	rcx, QWORD PTR ModuleInfo+464
	call	LstPrintf

; 1558 :         LstNL();

	call	LstNL
$LN27@AssembleMo:
$done$32:

; 1559 :     }
; 1560 : #if 1 //def __SW_BD
; 1561 : done:
; 1562 : #endif
; 1563 :     AssembleFini();

	call	AssembleFini

; 1564 :     DebugMsg(("AssembleModule exit\n"));

	lea	rcx, OFFSET FLAT:$SG12229
	call	DoDebugMsg

; 1565 :     return( ModuleInfo.g.error_count == 0 );

	cmp	DWORD PTR ModuleInfo, 0
	jne	SHORT $LN29@AssembleMo
	mov	DWORD PTR tv264[rsp], 1
	jmp	SHORT $LN30@AssembleMo
$LN29@AssembleMo:
	mov	DWORD PTR tv264[rsp], 0
$LN30@AssembleMo:
	mov	eax, DWORD PTR tv264[rsp]

; 1566 : }

	add	rsp, 128				; 00000080H
	pop	rdi
	ret	0
AssembleModule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
idx$1 = 32
tv79 = 36
pbytes$ = 64
len$ = 72
fixup$ = 80
OutputBytes PROC

; 300  : {

$LN11:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 301  :     if( write_to_file == TRUE ) {

	movzx	eax, BYTE PTR write_to_file
	cmp	eax, 1
	jne	$LN2@OutputByte

; 302  :         uint_32 idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	DWORD PTR idx$1[rsp], eax

; 303  : #if 0 /* def DEBUG_OUT */
; 304  :         if ( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc )
; 305  :             _asm int 3;
; 306  : #endif
; 307  :         /**/myassert( CurrSeg->e.seginfo->current_loc >= CurrSeg->e.seginfo->start_loc );

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+12], ecx
	jb	SHORT $LN9@OutputByte
	mov	DWORD PTR tv79[rsp], 0
	jmp	SHORT $LN10@OutputByte
$LN9@OutputByte:
	mov	edx, 307				; 00000133H
	lea	rcx, OFFSET FLAT:$SG11812
	call	InternalError
	mov	DWORD PTR tv79[rsp], eax
$LN10@OutputByte:

; 308  :         if( Options.output_format == OFORMAT_OMF && ((idx + len) > MAX_LEDATA_THRESHOLD ) ) {

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN4@OutputByte
	mov	eax, DWORD PTR len$[rsp]
	mov	ecx, DWORD PTR idx$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, 1014				; 000003f6H
	jbe	SHORT $LN4@OutputByte

; 309  :             omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 310  :             idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	DWORD PTR idx$1[rsp], eax
$LN4@OutputByte:

; 311  :         }
; 312  :         if ( fixup )

	cmp	QWORD PTR fixup$[rsp], 0
	je	SHORT $LN5@OutputByte

; 313  :             store_fixup( fixup, CurrSeg, (int_32 *)pbytes );

	mov	r8, QWORD PTR pbytes$[rsp]
	mov	rdx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR fixup$[rsp]
	call	store_fixup
$LN5@OutputByte:

; 314  :         //DebugMsg(("OutputBytes: buff=%p, idx=%" I32_SPEC "X, byte=%X\n", CurrSeg->e.seginfo->CodeBuffer, idx, *pbytes ));
; 315  :         memcpy( &CurrSeg->e.seginfo->CodeBuffer[idx], pbytes, len );

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	edx, DWORD PTR idx$1[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	add	rcx, rdx
	mov	r8, rax
	mov	rdx, QWORD PTR pbytes$[rsp]
	call	memcpy

; 316  :     }

	jmp	SHORT $LN3@OutputByte
$LN2@OutputByte:

; 317  : #if 1
; 318  :     /* check this in pass 1 only */
; 319  :     else if( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+12], ecx
	jae	SHORT $LN6@OutputByte

; 320  :         DebugMsg(("OutputBytes: segment start loc changed from %" I32_SPEC "Xh to %" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	r8d, DWORD PTR [rax+12]
	mov	edx, DWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG11816
	call	DoDebugMsg

; 321  :                   CurrSeg->e.seginfo->start_loc,
; 322  :                   CurrSeg->e.seginfo->current_loc));
; 323  :         CurrSeg->e.seginfo->start_loc = CurrSeg->e.seginfo->current_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+8], eax
$LN6@OutputByte:
$LN3@OutputByte:

; 324  :     }
; 325  : #endif
; 326  :     CurrSeg->e.seginfo->current_loc += len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	add	eax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+12], eax

; 327  :     CurrSeg->e.seginfo->bytes_written += len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+24]
	add	eax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+24], eax

; 328  :     CurrSeg->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+107], al

; 329  :     if( CurrSeg->e.seginfo->current_loc > CurrSeg->sym.max_offset )

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	ecx, DWORD PTR [rcx+56]
	cmp	DWORD PTR [rax+12], ecx
	jbe	SHORT $LN7@OutputByte

; 330  :         CurrSeg->sym.max_offset = CurrSeg->e.seginfo->current_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+56], eax
$LN7@OutputByte:

; 331  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
OutputBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
byte$ = 48
len$ = 56
FillDataBytes PROC

; 286  : {

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	BYTE PTR [rsp+8], cl
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+48]

; 287  :     if ( ModuleInfo.CommentDataInCode )

	movzx	eax, BYTE PTR ModuleInfo+423
	test	eax, eax
	je	SHORT $LN5@FillDataBy

; 288  :         omf_OutSelect( TRUE );

	mov	cl, 1
	call	omf_OutSelect
$LN5@FillDataBy:

; 289  :     for( ; len; len-- )

	jmp	SHORT $LN4@FillDataBy
$LN2@FillDataBy:
	mov	eax, DWORD PTR len$[rsp]
	dec	eax
	mov	DWORD PTR len$[rsp], eax
$LN4@FillDataBy:
	cmp	DWORD PTR len$[rsp], 0
	je	SHORT $LN3@FillDataBy

; 290  :         OutputByte( byte );

	movzx	ecx, BYTE PTR byte$[rsp]
	call	OutputByte
	jmp	SHORT $LN2@FillDataBy
$LN3@FillDataBy:

; 291  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
FillDataBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
_TEXT	SEGMENT
idx$1 = 32
tv84 = 36
byte$ = 64
OutputByte PROC

; 204  : {

$LN11:
	mov	BYTE PTR [rsp+8], cl
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+64]

; 205  :     if( write_to_file == TRUE ) {

	movzx	eax, BYTE PTR write_to_file
	cmp	eax, 1
	jne	$LN2@OutputByte

; 206  :         uint_32 idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	DWORD PTR idx$1[rsp], eax

; 207  : #ifdef DEBUG_OUT
; 208  :         if ( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]

; 209  :             ;//_asm int 3;
; 210  :         }
; 211  : #endif
; 212  :         /**/myassert( CurrSeg->e.seginfo->current_loc >= CurrSeg->e.seginfo->start_loc );

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+12], ecx
	jb	SHORT $LN9@OutputByte
	mov	DWORD PTR tv84[rsp], 0
	jmp	SHORT $LN10@OutputByte
$LN9@OutputByte:
	mov	edx, 212				; 000000d4H
	lea	rcx, OFFSET FLAT:$SG11766
	call	InternalError
	mov	DWORD PTR tv84[rsp], eax
$LN10@OutputByte:

; 213  :         if( Options.output_format == OFORMAT_OMF && idx >= MAX_LEDATA_THRESHOLD ) {

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN5@OutputByte
	cmp	DWORD PTR idx$1[rsp], 1014		; 000003f6H
	jb	SHORT $LN5@OutputByte

; 214  :             omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 215  :             idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	DWORD PTR idx$1[rsp], eax
$LN5@OutputByte:

; 216  :         }
; 217  :         //DebugMsg(("OutputByte: buff=%p, idx=%" I32_SPEC "X, byte=%X, codebuff[0]=%X\n", CurrSeg->e.seginfo->CodeBuffer, idx, byte, *CurrSeg->e.seginfo->CodeBuffer ));
; 218  :         CurrSeg->e.seginfo->CodeBuffer[idx] = byte;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR idx$1[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	edx, BYTE PTR byte$[rsp]
	mov	BYTE PTR [rax+rcx], dl

; 219  :     }

	jmp	SHORT $LN3@OutputByte
$LN2@OutputByte:

; 220  : #if 1
; 221  :     /* check this in pass 1 only */
; 222  :     else if( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+12], ecx
	jae	SHORT $LN6@OutputByte

; 223  :         DebugMsg(("OutputByte: segment start loc changed from %" I32_SPEC "Xh to %" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	r8d, DWORD PTR [rax+12]
	mov	edx, DWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG11769
	call	DoDebugMsg

; 224  :                   CurrSeg->e.seginfo->start_loc,
; 225  :                   CurrSeg->e.seginfo->current_loc));
; 226  :         CurrSeg->e.seginfo->start_loc = CurrSeg->e.seginfo->current_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+8], eax
$LN6@OutputByte:
$LN3@OutputByte:

; 227  :     }
; 228  : #endif
; 229  :     CurrSeg->e.seginfo->current_loc++;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	inc	eax
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+12], eax

; 230  :     CurrSeg->e.seginfo->bytes_written++;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+24]
	inc	eax
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+24], eax

; 231  :     CurrSeg->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+107], al

; 232  :     if( CurrSeg->e.seginfo->current_loc > CurrSeg->sym.max_offset )

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	ecx, DWORD PTR [rcx+56]
	cmp	DWORD PTR [rax+12], ecx
	jbe	SHORT $LN7@OutputByte

; 233  :         CurrSeg->sym.max_offset = CurrSeg->e.seginfo->current_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+56], eax
$LN7@OutputByte:

; 234  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
OutputByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Buffer$ = 96
_Format$ = 104
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1788 : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:sprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp___stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1391 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Format$ = 96
printf	PROC						; COMDAT

; 950  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 957  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:printf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
	push	rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	rdi
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
