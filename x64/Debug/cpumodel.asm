; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	ModelToken
PUBLIC	coff64_fmtopt
PUBLIC	elf64_fmtopt
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	sym_Interface:QWORD
COMM	sym_Cpu:QWORD
_DATA	ENDS
CONST	SEGMENT
ModelToken DQ	FLAT:$SG11136
	DQ	FLAT:$SG11137
	DQ	FLAT:$SG11138
	DQ	FLAT:$SG11139
	DQ	FLAT:$SG11140
	DQ	FLAT:$SG11141
	DQ	FLAT:$SG11142
ModelAttr DQ	FLAT:$SG11147
	DQ	FLAT:$SG11148
	DQ	FLAT:$SG11149
	DQ	FLAT:$SG11150
ModelAttrValue DB 00H
	DB	02H
	DB	01H
	DB	02H
	DB	00H
	DB	04H
	DB	01H
	DB	04H
coff64_fmtopt DQ 0000000000000000H
	DW	0e12H
	DB	'PE32+', 00H
elf64_fmtopt DQ	0000000000000000H
	DW	0f00H
	DB	'ELF64', 00H
CONST	ENDS
_DATA	SEGMENT
$SG11274 DB	'SetCPU(%X) enter', 0aH, 00H
	ORG $+6
$SG11296 DB	'SetCPU: ModuleInfo.curr_cpu=%X, @Cpu=%X', 0aH, 00H
	ORG $+3
$SG11300 DB	'@Cpu', 00H
	ORG $+3
$SG11136 DB	'TINY', 00H
	ORG $+3
$SG11137 DB	'SMALL', 00H
	ORG $+6
$SG11138 DB	'COMPACT', 00H
$SG11139 DB	'MEDIUM', 00H
	ORG $+1
$SG11140 DB	'LARGE', 00H
	ORG $+2
$SG11141 DB	'HUGE', 00H
	ORG $+3
$SG11142 DB	'FLAT', 00H
	ORG $+3
$SG11147 DB	'NEARSTACK', 00H
	ORG $+6
$SG11148 DB	'FARSTACK', 00H
	ORG $+3
$SG11149 DB	'OS_OS2', 00H
	ORG $+1
$SG11150 DB	'OS_DOS', 00H
	ORG $+5
$SG11195 DB	'SetModel() enter (model=%u)', 0aH, 00H
	ORG $+3
$SG11201 DB	'SetModel: FASTCALL type set to WIN64', 0aH, 00H
	ORG $+2
$SG11206 DB	'@CodeSize', 00H
	ORG $+2
$SG11207 DB	'@code', 00H
	ORG $+6
$SG11211 DB	'@DataSize', 00H
	ORG $+2
$SG11212 DB	'FLAT', 00H
	ORG $+3
$SG11213 DB	'@data', 00H
	ORG $+2
$SG11215 DB	'STACK', 00H
	ORG $+2
$SG11216 DB	'@stack', 00H
	ORG $+1
$SG11217 DB	'@Model', 00H
	ORG $+5
$SG11218 DB	'@Interface', 00H
	ORG $+5
$SG11220 DB	'@ReservedStack', 00H
	ORG $+1
$SG11242 DB	'ModelDirective enter', 0aH, 00H
_DATA	ENDS
PUBLIC	ModelDirective
PUBLIC	SetCPU
PUBLIC	CpuDirective
EXTRN	__imp__stricmp:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	GetLangType:PROC
EXTRN	SetOfssize:PROC
EXTRN	DefineFlatGroup:PROC
EXTRN	SimGetSegName:PROC
EXTRN	ModelSimSegmInit:PROC
EXTRN	SetModelDefaultSegNames:PROC
EXTRN	ModelAssumeInit:PROC
EXTRN	CreateVariable:PROC
EXTRN	RunLineQueue:PROC
EXTRN	LstWriteSrcLine:PROC
EXTRN	AddPredefinedText:PROC
EXTRN	DumpResWords:PROC
EXTRN	pe_create_PE_header:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	_RTC_UninitUse:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SpecialTable:BYTE
EXTRN	sym_ReservedStack:QWORD
EXTRN	szDgroup:BYTE
EXTRN	__ImageBase:BYTE
_BSS	SEGMENT
sym_CodeSize DQ	01H DUP (?)
sym_DataSize DQ	01H DUP (?)
sym_Model DQ	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$FindToken DD imagerel FindToken
	DD	imagerel FindToken+126
	DD	imagerel $unwind$FindToken
$pdata$AddPredefinedConstant DD imagerel AddPredefinedConstant
	DD	imagerel AddPredefinedConstant+91
	DD	imagerel $unwind$AddPredefinedConstant
$pdata$SetDefaultOfssize DD imagerel SetDefaultOfssize
	DD	imagerel SetDefaultOfssize+60
	DD	imagerel $unwind$SetDefaultOfssize
$pdata$SetModel DD imagerel SetModel
	DD	imagerel SetModel+636
	DD	imagerel $unwind$SetModel
$pdata$ModelDirective DD imagerel $LN34
	DD	imagerel $LN34+963
	DD	imagerel $unwind$ModelDirective
$pdata$SetCPU DD imagerel $LN35
	DD	imagerel $LN35+949
	DD	imagerel $unwind$SetCPU
$pdata$CpuDirective DD imagerel $LN4
	DD	imagerel $LN4+148
	DD	imagerel $unwind$CpuDirective
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
ModelDirective$rtcName$0 DB 06cH
	DB	061H
	DB	06eH
	DB	067H
	DB	075H
	DB	061H
	DB	067H
	DB	065H
	DB	00H
	ORG $+7
ModelDirective$rtcName$1 DB 064H
	DB	069H
	DB	073H
	DB	074H
	DB	061H
	DB	06eH
	DB	063H
	DB	065H
	DB	00H
	ORG $+3
ModelDirective$rtcName$2 DB 06fH
	DB	073H
	DB	074H
	DB	079H
	DB	070H
	DB	065H
	DB	00H
	ORG $+5
ModelDirective$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:ModelDirective$rtcVarDesc
	ORG $+8
ModelDirective$rtcVarDesc DD 034H
	DD	04H
	DQ	FLAT:ModelDirective$rtcName$0
CONST	ENDS
xdata	SEGMENT
$unwind$FindToken DD 022801H
	DD	070105214H
$unwind$AddPredefinedConstant DD 022201H
	DD	0700a520eH
$unwind$SetDefaultOfssize DD 021c01H
	DD	070053209H
$unwind$SetModel DD 021501H
	DD	070029206H
$unwind$ModelDirective DD 022101H
	DD	0700ab20eH
$unwind$SetCPU DD 021c01H
	DD	070055209H
$unwind$CpuDirective DD 022101H
	DD	0700a520eH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cpumodel.c
_TEXT	SEGMENT
newcpu$ = 32
i$ = 64
tokenarray$ = 72
CpuDirective PROC

; 462  : {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+64]

; 463  :     enum cpu_info newcpu;
; 464  : 
; 465  :     //newcpu = comp_opt( tokenarray[i].tokval );
; 466  :     newcpu = GetSflagsSp( tokenarray[i].tokval );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax+4]
	mov	DWORD PTR newcpu$[rsp], eax

; 467  : 
; 468  : #if DOT_XMMARG
; 469  :     .if ( tokenarray[i].tokval == T_DOT_XMM && tokenarray[i+1].token != T_FINAL ) {
; 470  :         struct expr opndx;
; 471  :         i++;
; 472  :         if ( EvalOperand( &i, Token_Count, &opndx, 0 ) == ERROR )
; 473  :             return( ERROR );
; 474  :         if ( opndx.kind != EXPR_CONST || opndx.value < 1 || opndx.value > 4 ) {
; 475  :             return( EmitConstError( &opndx ) );
; 476  :         }
; 477  :         newcpy &= ~P_SSEALL; 
; 478  :         switch ( opndx.value ) {
; 479  :         case 4: newcpy |= P_SSE4;
; 480  :         case 3: newcpy |= P_SSE3|P_SSSE3;
; 481  :         case 2: newcpy |= P_SSE2;
; 482  :         case 1: newcpy |= P_SSE1; break;
; 483  :         }
; 484  :     } else
; 485  : #endif
; 486  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 487  : 
; 488  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN2@CpuDirecti

; 489  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@CpuDirecti
$LN2@CpuDirecti:

; 490  :     }
; 491  : 
; 492  :     return( SetCPU( newcpu ) );

	mov	ecx, DWORD PTR newcpu$[rsp]
	call	SetCPU
$LN1@CpuDirecti:

; 493  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
CpuDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cpumodel.c
_TEXT	SEGMENT
temp$ = 32
tv130 = 36
tv139 = 40
tv166 = 44
newcpu$ = 64
SetCPU	PROC

; 369  : {

$LN35:
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+64]

; 370  :     int temp;
; 371  : 
; 372  :     DebugMsg1(("SetCPU(%X) enter\n", newcpu ));

	mov	edx, DWORD PTR newcpu$[rsp]
	lea	rcx, OFFSET FLAT:$SG11274
	call	DoDebugMsg1

; 373  :     if ( newcpu == P_86 || ( newcpu & P_CPU_MASK ) ) {

	cmp	DWORD PTR newcpu$[rsp], 0
	je	SHORT $LN7@SetCPU
	mov	eax, DWORD PTR newcpu$[rsp]
	and	eax, 240				; 000000f0H
	test	eax, eax
	je	$LN6@SetCPU
$LN7@SetCPU:

; 374  :         /* reset CPU and EXT bits */
; 375  :         ModuleInfo.curr_cpu &= ~( P_CPU_MASK | P_EXT_MASK | P_PM );

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, -65529				; ffffffffffff0007H
	mov	DWORD PTR ModuleInfo+392, eax

; 376  : 
; 377  :         /* set CPU bits */
; 378  :         ModuleInfo.curr_cpu |= newcpu & ( P_CPU_MASK | P_PM );

	mov	eax, DWORD PTR newcpu$[rsp]
	and	eax, 248				; 000000f8H
	mov	ecx, DWORD PTR ModuleInfo+392
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+392, eax

; 379  : 
; 380  :         /* set default FPU bits if nothing is given and .NO87 not active */
; 381  :         if ( (ModuleInfo.curr_cpu & P_FPU_MASK) != P_NO87 &&

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 7
	cmp	eax, 1
	je	SHORT $LN8@SetCPU
	mov	eax, DWORD PTR newcpu$[rsp]
	and	eax, 7
	test	eax, eax
	jne	SHORT $LN8@SetCPU

; 382  :             ( newcpu & P_FPU_MASK ) == 0 ) {
; 383  :             ModuleInfo.curr_cpu &= ~P_FPU_MASK;

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, -8
	mov	DWORD PTR ModuleInfo+392, eax

; 384  :             if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < P_286 )

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 32					; 00000020H
	jge	SHORT $LN9@SetCPU

; 385  :                 ModuleInfo.curr_cpu |= P_87;

	mov	eax, DWORD PTR ModuleInfo+392
	or	eax, 2
	mov	DWORD PTR ModuleInfo+392, eax
	jmp	SHORT $LN10@SetCPU
$LN9@SetCPU:

; 386  :             else if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < P_386 )

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jge	SHORT $LN11@SetCPU

; 387  :                 ModuleInfo.curr_cpu |= P_287;

	mov	eax, DWORD PTR ModuleInfo+392
	or	eax, 3
	mov	DWORD PTR ModuleInfo+392, eax
	jmp	SHORT $LN12@SetCPU
$LN11@SetCPU:

; 388  :             else
; 389  :                 ModuleInfo.curr_cpu |= P_387;

	mov	eax, DWORD PTR ModuleInfo+392
	or	eax, 4
	mov	DWORD PTR ModuleInfo+392, eax
$LN12@SetCPU:
$LN10@SetCPU:
$LN8@SetCPU:
$LN6@SetCPU:

; 390  :         }
; 391  : 
; 392  :     }
; 393  :     if( newcpu & P_FPU_MASK ) {

	mov	eax, DWORD PTR newcpu$[rsp]
	and	eax, 7
	test	eax, eax
	je	SHORT $LN13@SetCPU

; 394  :         ModuleInfo.curr_cpu &= ~P_FPU_MASK;

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, -8
	mov	DWORD PTR ModuleInfo+392, eax

; 395  :         ModuleInfo.curr_cpu |= (newcpu & P_FPU_MASK);

	mov	eax, DWORD PTR newcpu$[rsp]
	and	eax, 7
	mov	ecx, DWORD PTR ModuleInfo+392
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+392, eax
$LN13@SetCPU:

; 396  :     }
; 397  : #if AMD64_SUPPORT
; 398  :     /* enable MMX, K3D, SSEx for 64bit cpus */
; 399  :     if ( ( newcpu & P_CPU_MASK ) == P_64 )

	mov	eax, DWORD PTR newcpu$[rsp]
	and	eax, 240				; 000000f0H
	cmp	eax, 112				; 00000070H
	jne	SHORT $LN14@SetCPU

; 400  :         ModuleInfo.curr_cpu |= P_EXT_ALL;

	mov	eax, DWORD PTR ModuleInfo+392
	or	eax, 65280				; 0000ff00H
	mov	DWORD PTR ModuleInfo+392, eax
$LN14@SetCPU:

; 401  : #endif
; 402  :     if( newcpu & P_EXT_MASK ) {

	mov	eax, DWORD PTR newcpu$[rsp]
	and	eax, 65280				; 0000ff00H
	test	eax, eax
	je	SHORT $LN15@SetCPU

; 403  :         ModuleInfo.curr_cpu &= ~P_EXT_MASK;

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, -65281				; ffffffffffff00ffH
	mov	DWORD PTR ModuleInfo+392, eax

; 404  :         ModuleInfo.curr_cpu |= (newcpu & P_EXT_MASK);

	mov	eax, DWORD PTR newcpu$[rsp]
	and	eax, 65280				; 0000ff00H
	mov	ecx, DWORD PTR ModuleInfo+392
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+392, eax
$LN15@SetCPU:

; 405  :     }
; 406  : 
; 407  :     /* set the Masm compatible @Cpu value */
; 408  : 
; 409  :     temp = ModuleInfo.curr_cpu & P_CPU_MASK;

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	mov	DWORD PTR temp$[rsp], eax

; 410  :     switch ( temp ) {

	mov	eax, DWORD PTR temp$[rsp]
	mov	DWORD PTR tv130[rsp], eax
	mov	eax, DWORD PTR tv130[rsp]
	sub	eax, 16
	mov	DWORD PTR tv130[rsp], eax
	cmp	DWORD PTR tv130[rsp], 96		; 00000060H
	ja	SHORT $LN22@SetCPU
	movsxd	rax, DWORD PTR tv130[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN33@SetCPU[rcx+rax]
	mov	eax, DWORD PTR $LN34@SetCPU[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN16@SetCPU:

; 411  :     case P_186: ModuleInfo.cpu = M_8086 | M_186; break;

	mov	eax, 3
	mov	WORD PTR ModuleInfo+388, ax
	jmp	SHORT $LN2@SetCPU
$LN17@SetCPU:

; 412  :     case P_286: ModuleInfo.cpu = M_8086 | M_186 | M_286; break;

	mov	eax, 7
	mov	WORD PTR ModuleInfo+388, ax
	jmp	SHORT $LN2@SetCPU
$LN18@SetCPU:

; 413  :     case P_386: ModuleInfo.cpu = M_8086 | M_186 | M_286 | M_386; break;

	mov	eax, 15
	mov	WORD PTR ModuleInfo+388, ax
	jmp	SHORT $LN2@SetCPU
$LN19@SetCPU:

; 414  :     case P_486: ModuleInfo.cpu = M_8086 | M_186 | M_286 | M_386 | M_486; break;

	mov	eax, 31
	mov	WORD PTR ModuleInfo+388, ax
	jmp	SHORT $LN2@SetCPU
$LN20@SetCPU:

; 415  :     case P_586: ModuleInfo.cpu = M_8086 | M_186 | M_286 | M_386 | M_486 | M_586; break;

	mov	eax, 63					; 0000003fH
	mov	WORD PTR ModuleInfo+388, ax
	jmp	SHORT $LN2@SetCPU
$LN21@SetCPU:

; 416  :     /* Masm's .686 directive doesn't set the Pentium flag! A bug? */
; 417  :     //case P_686: ModuleInfo.cpu = M_8086 | M_186 | M_286 | M_386 | M_486 | M_586 | M_686; break;
; 418  : #if AMD64_SUPPORT
; 419  :     case P_64:
; 420  : #endif
; 421  :     case P_686: ModuleInfo.cpu = M_8086 | M_186 | M_286 | M_386 | M_486 | M_686; break;

	mov	eax, 95					; 0000005fH
	mov	WORD PTR ModuleInfo+388, ax
	jmp	SHORT $LN2@SetCPU
$LN22@SetCPU:

; 422  :     default: ModuleInfo.cpu = M_8086; break;

	mov	eax, 1
	mov	WORD PTR ModuleInfo+388, ax
$LN2@SetCPU:

; 423  :     }
; 424  :     if ( ModuleInfo.curr_cpu & P_PM )

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 8
	test	eax, eax
	je	SHORT $LN23@SetCPU

; 425  :         ModuleInfo.cpu = ModuleInfo.cpu | M_PROT;

	movsx	eax, WORD PTR ModuleInfo+388
	bts	eax, 7
	mov	WORD PTR ModuleInfo+388, ax
$LN23@SetCPU:

; 426  : 
; 427  :     temp = ModuleInfo.curr_cpu & P_FPU_MASK;

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 7
	mov	DWORD PTR temp$[rsp], eax

; 428  :     switch (temp) {

	mov	eax, DWORD PTR temp$[rsp]
	mov	DWORD PTR tv139[rsp], eax
	cmp	DWORD PTR tv139[rsp], 2
	je	SHORT $LN24@SetCPU
	cmp	DWORD PTR tv139[rsp], 3
	je	SHORT $LN25@SetCPU
	cmp	DWORD PTR tv139[rsp], 4
	je	SHORT $LN26@SetCPU
	jmp	SHORT $LN4@SetCPU
$LN24@SetCPU:

; 429  :     case P_87:  ModuleInfo.cpu = ModuleInfo.cpu | M_8087;     break;

	movsx	eax, WORD PTR ModuleInfo+388
	bts	eax, 8
	mov	WORD PTR ModuleInfo+388, ax
	jmp	SHORT $LN4@SetCPU
$LN25@SetCPU:

; 430  :     case P_287: ModuleInfo.cpu = ModuleInfo.cpu | M_8087 | M_287; break;

	movsx	eax, WORD PTR ModuleInfo+388
	bts	eax, 8
	bts	eax, 10
	mov	WORD PTR ModuleInfo+388, ax
	jmp	SHORT $LN4@SetCPU
$LN26@SetCPU:

; 431  :     case P_387: ModuleInfo.cpu = ModuleInfo.cpu | M_8087 | M_287 | M_387; break;

	movsx	eax, WORD PTR ModuleInfo+388
	bts	eax, 8
	bts	eax, 10
	bts	eax, 11
	mov	WORD PTR ModuleInfo+388, ax
$LN4@SetCPU:

; 432  :     }
; 433  : 
; 434  :     DebugMsg1(("SetCPU: ModuleInfo.curr_cpu=%X, @Cpu=%X\n", ModuleInfo.curr_cpu, ModuleInfo.cpu ));

	movsx	eax, WORD PTR ModuleInfo+388
	mov	r8d, eax
	mov	edx, DWORD PTR ModuleInfo+392
	lea	rcx, OFFSET FLAT:$SG11296
	call	DoDebugMsg1

; 435  : 
; 436  :     //MakeCPUConstant( newcpu );
; 437  :     if ( ModuleInfo.model == MODEL_NONE )

	cmp	DWORD PTR ModuleInfo+360, 0
	jne	SHORT $LN27@SetCPU

; 438  : #if AMD64_SUPPORT
; 439  :         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK) >= P_64 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 112				; 00000070H
	jl	SHORT $LN28@SetCPU

; 440  :             SetDefaultOfssize( USE64 );

	mov	ecx, 2
	call	SetDefaultOfssize

; 441  :         } else

	jmp	SHORT $LN29@SetCPU
$LN28@SetCPU:

; 442  : #endif
; 443  :             SetDefaultOfssize( ((ModuleInfo.curr_cpu & P_CPU_MASK) >= P_386) ? USE32 : USE16 );

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN31@SetCPU
	mov	DWORD PTR tv166[rsp], 1
	jmp	SHORT $LN32@SetCPU
$LN31@SetCPU:
	mov	DWORD PTR tv166[rsp], 0
$LN32@SetCPU:
	mov	ecx, DWORD PTR tv166[rsp]
	call	SetDefaultOfssize
$LN29@SetCPU:
$LN27@SetCPU:

; 444  : 
; 445  :     /* Set @Cpu */
; 446  :     /* differs from Codeinfo cpu setting */
; 447  : 
; 448  :     sym_Cpu = CreateVariable( "@Cpu", ModuleInfo.cpu );

	movsx	eax, WORD PTR ModuleInfo+388
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11300
	call	CreateVariable
	mov	QWORD PTR sym_Cpu, rax

; 449  : 
; 450  :     return( NOT_ERROR );

	xor	eax, eax

; 451  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN34@SetCPU:
	DD	$LN16@SetCPU
	DD	$LN17@SetCPU
	DD	$LN18@SetCPU
	DD	$LN19@SetCPU
	DD	$LN20@SetCPU
	DD	$LN21@SetCPU
	DD	$LN22@SetCPU
$LN33@SetCPU:
	DB	0
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
SetCPU	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cpumodel.c
_TEXT	SEGMENT
model$ = 32
language$ = 52
distance$ = 68
ostype$ = 72
index$ = 76
init$ = 80
initv$ = 81
$T6 = 82
$T7 = 83
$T8 = 84
tv163 = 88
tv211 = 92
i$ = 112
tokenarray$ = 120
ModelDirective PROC

; 249  : {

$LN34:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rdi, rsp
	mov	ecx, 24
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+112]
	mov	BYTE PTR $T7[rsp], 0
	mov	BYTE PTR $T8[rsp], 0
	mov	BYTE PTR $T6[rsp], 0

; 250  :     enum model_type model;
; 251  :     enum lang_type language;
; 252  :     enum dist_type distance;
; 253  :     enum os_type ostype;
; 254  :     int index;
; 255  :     uint_8 init;
; 256  :     uint_8 initv;
; 257  : 
; 258  :     DebugMsg1(("ModelDirective enter\n"));

	lea	rcx, OFFSET FLAT:$SG11242
	call	DoDebugMsg1

; 259  :     /* v2.03: it may occur that "code" is defined BEFORE the MODEL
; 260  :      * directive (i.e. DB directives in AT-segments). For FASTPASS,
; 261  :      * this may have caused errors because contents of the ModuleInfo
; 262  :      * structure was saved before the .MODEL directive.
; 263  :      */
; 264  :     //if( Parse_Pass != PASS_1 ) {
; 265  :     if( Parse_Pass != PASS_1 && ModuleInfo.model != MODEL_NONE ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN8@ModelDirec
	cmp	DWORD PTR ModuleInfo+360, 0
	je	SHORT $LN8@ModelDirec

; 266  :         /* just set the model with SetModel() if pass is != 1.
; 267  :          * This won't set the language ( which can be modified by
; 268  :          * OPTION LANGUAGE directive ), but the language in ModuleInfo
; 269  :          * isn't needed anymore once pass one is done.
; 270  :          */
; 271  :         SetModel();

	call	SetModel

; 272  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@ModelDirec
$LN8@ModelDirec:

; 273  :     }
; 274  : 
; 275  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 276  :     if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN9@ModelDirec

; 277  :         return( EmitError( EXPECTED_MEMORY_MODEL ) );

	mov	ecx, 246				; 000000f6H
	call	EmitError
	jmp	$LN1@ModelDirec
$LN9@ModelDirec:

; 278  :     }
; 279  :     /* get the model argument */
; 280  :     index = FindToken( tokenarray[i].string_ptr, ModelToken, sizeof( ModelToken )/sizeof( ModelToken[0] ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r8d, 7
	lea	rdx, OFFSET FLAT:ModelToken
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	FindToken
	mov	DWORD PTR index$[rsp], eax

; 281  :     if( index >= 0 ) {

	cmp	DWORD PTR index$[rsp], 0
	jl	SHORT $LN10@ModelDirec

; 282  :         if( ModuleInfo.model != MODEL_NONE ) {

	cmp	DWORD PTR ModuleInfo+360, 0
	je	SHORT $LN12@ModelDirec

; 283  :             //if ( Parse_Pass == PASS_1 ) /* not needed, this code runs in pass one only */
; 284  :             EmitWarn( 2, MODEL_DECLARED_ALREADY );

	mov	edx, 95					; 0000005fH
	mov	ecx, 2
	call	EmitWarn
$LN12@ModelDirec:

; 285  :         }
; 286  :         model = index + 1; /* model is one-base ( 0 is MODEL_NONE ) */

	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	DWORD PTR model$[rsp], eax

; 287  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 288  :     } else {

	jmp	SHORT $LN11@ModelDirec
$LN10@ModelDirec:

; 289  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ModelDirec
$LN11@ModelDirec:

; 290  :     }
; 291  : 
; 292  :     /* get the optional arguments: language, stack distance, os */
; 293  :     init = 0;

	mov	BYTE PTR init$[rsp], 0
$LN2@ModelDirec:

; 294  :     while ( i < ( Token_Count - 1 ) && tokenarray[i].token == T_COMMA ) {

	mov	eax, DWORD PTR ModuleInfo+496
	dec	eax
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@ModelDirec
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	$LN3@ModelDirec

; 295  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 296  :         if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	$LN13@ModelDirec

; 297  :             if ( GetLangType( &i, tokenarray, &language ) == NOT_ERROR ) {

	mov	BYTE PTR $T6[rsp], 1
	lea	r8, QWORD PTR language$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	GetLangType
	test	eax, eax
	jne	SHORT $LN14@ModelDirec

; 298  :                 initv = INIT_LANG;

	mov	BYTE PTR initv$[rsp], 1

; 299  :             } else {

	jmp	$LN15@ModelDirec
$LN14@ModelDirec:

; 300  :                 index = FindToken( tokenarray[i].string_ptr, ModelAttr, sizeof( ModelAttr )/sizeof( ModelAttr[0] ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:ModelAttr
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	FindToken
	mov	DWORD PTR index$[rsp], eax

; 301  :                 if ( index < 0 )

	cmp	DWORD PTR index$[rsp], 0
	jge	SHORT $LN16@ModelDirec

; 302  :                     break;

	jmp	$LN3@ModelDirec
$LN16@ModelDirec:

; 303  :                 initv = ModelAttrValue[index].init;

	movsxd	rax, DWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:ModelAttrValue
	movzx	eax, BYTE PTR [rcx+rax*2+1]
	mov	BYTE PTR initv$[rsp], al

; 304  :                 switch ( initv ) {

	movzx	eax, BYTE PTR initv$[rsp]
	mov	BYTE PTR tv163[rsp], al
	cmp	BYTE PTR tv163[rsp], 2
	je	SHORT $LN17@ModelDirec
	cmp	BYTE PTR tv163[rsp], 4
	je	SHORT $LN19@ModelDirec
	jmp	SHORT $LN4@ModelDirec
$LN17@ModelDirec:

; 305  :                 case INIT_STACK:
; 306  :                     if ( model == MODEL_FLAT ) {

	cmp	DWORD PTR model$[rsp], 7
	jne	SHORT $LN18@ModelDirec

; 307  :                         return( EmitError( INVALID_MODEL_PARAM_FOR_FLAT ) );

	mov	ecx, 200				; 000000c8H
	call	EmitError
	jmp	$LN1@ModelDirec
$LN18@ModelDirec:

; 308  :                     }
; 309  :                     distance = ModelAttrValue[index].value;

	movsxd	rax, DWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:ModelAttrValue
	movzx	eax, BYTE PTR [rcx+rax*2]
	mov	BYTE PTR $T7[rsp], 1
	mov	DWORD PTR distance$[rsp], eax

; 310  :                     break;

	jmp	SHORT $LN4@ModelDirec
$LN19@ModelDirec:

; 311  :                 case INIT_OS:
; 312  :                     ostype = ModelAttrValue[index].value;

	movsxd	rax, DWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:ModelAttrValue
	movzx	eax, BYTE PTR [rcx+rax*2]
	mov	BYTE PTR $T8[rsp], 1
	mov	DWORD PTR ostype$[rsp], eax
$LN4@ModelDirec:

; 313  :                     break;
; 314  :                 }
; 315  :                 i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN15@ModelDirec:

; 316  :             }
; 317  :             /* attribute set already? */
; 318  :             if ( initv & init ) {

	movzx	eax, BYTE PTR initv$[rsp]
	movzx	ecx, BYTE PTR init$[rsp]
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN20@ModelDirec

; 319  :                 i--;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax

; 320  :                 break;

	jmp	SHORT $LN3@ModelDirec
$LN20@ModelDirec:

; 321  :             }
; 322  :             init |= initv;

	movzx	eax, BYTE PTR initv$[rsp]
	movzx	ecx, BYTE PTR init$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR init$[rsp], al
$LN13@ModelDirec:

; 323  :         }
; 324  :     }

	jmp	$LN2@ModelDirec
$LN3@ModelDirec:

; 325  :     /* everything parsed successfully? */
; 326  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN21@ModelDirec

; 327  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ModelDirec
$LN21@ModelDirec:

; 328  :     }
; 329  : 
; 330  :     if ( model == MODEL_FLAT ) {

	cmp	DWORD PTR model$[rsp], 7
	jne	SHORT $LN22@ModelDirec

; 331  :         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK) < P_386 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jge	SHORT $LN23@ModelDirec

; 332  :             return( EmitError( INSTRUCTION_OR_REGISTER_NOT_ACCEPTED_IN_CURRENT_CPU_MODE ) );

	mov	ecx, 30
	call	EmitError
	jmp	$LN1@ModelDirec
$LN23@ModelDirec:

; 333  :         }
; 334  : #if AMD64_SUPPORT
; 335  :         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_64 ) /* cpu 64-bit? */

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 112				; 00000070H
	jl	SHORT $LN24@ModelDirec

; 336  :             switch ( Options.output_format ) {

	mov	eax, DWORD PTR Options+160
	mov	DWORD PTR tv211[rsp], eax
	cmp	DWORD PTR tv211[rsp], 2
	je	SHORT $LN25@ModelDirec
	cmp	DWORD PTR tv211[rsp], 3
	je	SHORT $LN26@ModelDirec
	jmp	SHORT $LN6@ModelDirec
$LN25@ModelDirec:

; 337  :             case OFORMAT_COFF: ModuleInfo.fmtopt = &coff64_fmtopt; break;

	lea	rax, OFFSET FLAT:coff64_fmtopt
	mov	QWORD PTR ModuleInfo+344, rax
	jmp	SHORT $LN6@ModelDirec
$LN26@ModelDirec:

; 338  :             case OFORMAT_ELF:  ModuleInfo.fmtopt = &elf64_fmtopt;  break;

	lea	rax, OFFSET FLAT:elf64_fmtopt
	mov	QWORD PTR ModuleInfo+344, rax
$LN6@ModelDirec:
$LN24@ModelDirec:
$LN22@ModelDirec:

; 339  :             };
; 340  : #endif
; 341  :         /* v2.11: define FLAT symbol is to early here, because defOfssize isn't set yet */
; 342  :         //DefineFlatGroup();
; 343  :     }
; 344  : 
; 345  :     ModuleInfo.model = model;

	mov	eax, DWORD PTR model$[rsp]
	mov	DWORD PTR ModuleInfo+360, eax

; 346  :     if ( init & INIT_LANG )

	movzx	eax, BYTE PTR init$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN27@ModelDirec

; 347  :         ModuleInfo.langtype = language;

	cmp	BYTE PTR $T6[rsp], 0
	jne	SHORT $LN31@ModelDirec
	lea	rcx, OFFSET FLAT:ModelDirective$rtcName$0
	call	_RTC_UninitUse
$LN31@ModelDirec:
	mov	eax, DWORD PTR language$[rsp]
	mov	DWORD PTR ModuleInfo+364, eax
$LN27@ModelDirec:

; 348  :     if ( init & INIT_STACK )

	movzx	eax, BYTE PTR init$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN28@ModelDirec

; 349  :         ModuleInfo.distance = distance;

	cmp	BYTE PTR $T7[rsp], 0
	jne	SHORT $LN32@ModelDirec
	lea	rcx, OFFSET FLAT:ModelDirective$rtcName$1
	call	_RTC_UninitUse
$LN32@ModelDirec:
	mov	eax, DWORD PTR distance$[rsp]
	mov	DWORD PTR ModuleInfo+356, eax
$LN28@ModelDirec:

; 350  :     if ( init & INIT_OS )

	movzx	eax, BYTE PTR init$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN29@ModelDirec

; 351  :         ModuleInfo.ostype = ostype;

	cmp	BYTE PTR $T8[rsp], 0
	jne	SHORT $LN33@ModelDirec
	lea	rcx, OFFSET FLAT:ModelDirective$rtcName$2
	call	_RTC_UninitUse
$LN33@ModelDirec:
	mov	eax, DWORD PTR ostype$[rsp]
	mov	DWORD PTR ModuleInfo+368, eax
$LN29@ModelDirec:

; 352  : 
; 353  :     SetModelDefaultSegNames();

	call	SetModelDefaultSegNames

; 354  :     SetModel();

	call	SetModel

; 355  : 
; 356  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@ModelDirec:

; 357  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:ModelDirective$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
ModelDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cpumodel.c
_TEXT	SEGMENT
value$ = 32
textvalue$ = 40
tv70 = 48
tv196 = 52
tv87 = 56
tv131 = 64
SetModel PROC

; 134  : {

	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 135  :     int         value;
; 136  :     const char  *textvalue;
; 137  :     //struct asym     *sym;
; 138  : 
; 139  :     DebugMsg1(("SetModel() enter (model=%u)\n", ModuleInfo.model ));

	mov	edx, DWORD PTR ModuleInfo+360
	lea	rcx, OFFSET FLAT:$SG11195
	call	DoDebugMsg1

; 140  :     /* if model is set, it disables OT_SEGMENT of -Zm switch */
; 141  :     if ( ModuleInfo.model == MODEL_FLAT ) {

	cmp	DWORD PTR ModuleInfo+360, 7
	jne	SHORT $LN4@SetModel

; 142  :         ModuleInfo.offsettype = OT_FLAT;

	mov	DWORD PTR ModuleInfo+384, 1

; 143  : #if AMD64_SUPPORT
; 144  :         SetDefaultOfssize( ((ModuleInfo.curr_cpu & P_CPU_MASK) >= P_64 ) ? USE64 : USE32 );

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 112				; 00000070H
	jl	SHORT $LN21@SetModel
	mov	DWORD PTR tv70[rsp], 2
	jmp	SHORT $LN22@SetModel
$LN21@SetModel:
	mov	DWORD PTR tv70[rsp], 1
$LN22@SetModel:
	mov	ecx, DWORD PTR tv70[rsp]
	call	SetDefaultOfssize

; 145  :         /* v2.03: if cpu is x64 and language is fastcall,
; 146  :          * set fastcall type to win64.
; 147  :          * This is rather hackish, but currently there's no other possibility
; 148  :          * to enable the win64 ABI from the source.
; 149  :          */
; 150  :         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) == P_64 )

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 112				; 00000070H
	jne	SHORT $LN6@SetModel

; 151  :             if ( ModuleInfo.langtype == LANG_FASTCALL ) {

	cmp	DWORD PTR ModuleInfo+364, 7
	jne	SHORT $LN7@SetModel

; 152  :                 if ( Options.output_format != OFORMAT_ELF ) {

	cmp	DWORD PTR Options+160, 3
	je	SHORT $LN8@SetModel

; 153  :                     DebugMsg(("SetModel: FASTCALL type set to WIN64\n"));

	lea	rcx, OFFSET FLAT:$SG11201
	call	DoDebugMsg

; 154  :                     ModuleInfo.fctype = FCT_WIN64;

	mov	DWORD PTR ModuleInfo+376, 2
$LN8@SetModel:
$LN7@SetModel:
$LN6@SetModel:

; 155  :                 }
; 156  :             }
; 157  : #else
; 158  :         SetDefaultOfssize( USE32 );
; 159  : #endif
; 160  :         /* v2.11: define symbol FLAT - after default offset size has been set! */
; 161  :         DefineFlatGroup();

	call	DefineFlatGroup

; 162  :     } else

	jmp	SHORT $LN5@SetModel
$LN4@SetModel:

; 163  :         ModuleInfo.offsettype = OT_GROUP;

	mov	DWORD PTR ModuleInfo+384, 0
$LN5@SetModel:

; 164  : 
; 165  :     ModelSimSegmInit( ModuleInfo.model ); /* create segments in first pass */

	mov	ecx, DWORD PTR ModuleInfo+360
	call	ModelSimSegmInit

; 166  :     ModelAssumeInit();

	call	ModelAssumeInit

; 167  : 
; 168  :     if ( ModuleInfo.list )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN9@SetModel

; 169  :         LstWriteSrcLine();

	call	LstWriteSrcLine
$LN9@SetModel:

; 170  : 
; 171  :     RunLineQueue();

	call	RunLineQueue

; 172  : 
; 173  :     if ( Parse_Pass != PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN10@SetModel

; 174  :         return;

	jmp	$LN1@SetModel
$LN10@SetModel:

; 175  : 
; 176  :     /* Set @CodeSize */
; 177  :     if ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) {

	mov	eax, DWORD PTR ModuleInfo+360
	mov	ecx, 1
	mov	DWORD PTR tv196[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv196[rsp]
	shl	eax, cl
	and	eax, 112				; 00000070H
	test	eax, eax
	je	SHORT $LN11@SetModel

; 178  :         value = 1;

	mov	DWORD PTR value$[rsp], 1

; 179  :         /* v2.06: SimpleType[] is obsolete */
; 180  :         //SimpleType[ST_PROC].mem_type = MT_FAR;
; 181  :     } else {

	jmp	SHORT $LN12@SetModel
$LN11@SetModel:

; 182  :         value = 0;

	mov	DWORD PTR value$[rsp], 0
$LN12@SetModel:

; 183  :         // SimpleType[ST_PROC].mem_type = MT_NEAR; /* this is default */
; 184  :     }
; 185  :     sym_CodeSize = AddPredefinedConstant( "@CodeSize", value );

	mov	edx, DWORD PTR value$[rsp]
	lea	rcx, OFFSET FLAT:$SG11206
	call	AddPredefinedConstant
	mov	QWORD PTR sym_CodeSize, rax

; 186  :     AddPredefinedText( "@code", SimGetSegName( SIM_CODE ) );

	xor	ecx, ecx
	call	SimGetSegName
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11207
	call	AddPredefinedText

; 187  : 
; 188  :     /* Set @DataSize */
; 189  :     switch( ModuleInfo.model ) {

	mov	eax, DWORD PTR ModuleInfo+360
	mov	DWORD PTR tv87[rsp], eax
	cmp	DWORD PTR tv87[rsp], 3
	je	SHORT $LN13@SetModel
	cmp	DWORD PTR tv87[rsp], 5
	je	SHORT $LN13@SetModel
	cmp	DWORD PTR tv87[rsp], 6
	je	SHORT $LN14@SetModel
	jmp	SHORT $LN15@SetModel
$LN13@SetModel:

; 190  :     case MODEL_COMPACT:
; 191  :     case MODEL_LARGE:
; 192  :         value = 1;

	mov	DWORD PTR value$[rsp], 1

; 193  :         break;

	jmp	SHORT $LN2@SetModel
$LN14@SetModel:

; 194  :     case MODEL_HUGE:
; 195  :         value = 2;

	mov	DWORD PTR value$[rsp], 2

; 196  :         break;

	jmp	SHORT $LN2@SetModel
$LN15@SetModel:

; 197  :     default:
; 198  :         value = 0;

	mov	DWORD PTR value$[rsp], 0
$LN2@SetModel:

; 199  :         break;
; 200  :     }
; 201  :     sym_DataSize = AddPredefinedConstant( "@DataSize", value );

	mov	edx, DWORD PTR value$[rsp]
	lea	rcx, OFFSET FLAT:$SG11211
	call	AddPredefinedConstant
	mov	QWORD PTR sym_DataSize, rax

; 202  : 
; 203  :     textvalue = ( ModuleInfo.model == MODEL_FLAT ? "FLAT" : szDgroup );

	cmp	DWORD PTR ModuleInfo+360, 7
	jne	SHORT $LN23@SetModel
	lea	rax, OFFSET FLAT:$SG11212
	mov	QWORD PTR tv131[rsp], rax
	jmp	SHORT $LN24@SetModel
$LN23@SetModel:
	lea	rax, OFFSET FLAT:szDgroup
	mov	QWORD PTR tv131[rsp], rax
$LN24@SetModel:
	mov	rax, QWORD PTR tv131[rsp]
	mov	QWORD PTR textvalue$[rsp], rax

; 204  :     AddPredefinedText( "@data", textvalue );

	mov	rdx, QWORD PTR textvalue$[rsp]
	lea	rcx, OFFSET FLAT:$SG11213
	call	AddPredefinedText

; 205  : 
; 206  :     if ( ModuleInfo.distance == STACK_FAR )

	cmp	DWORD PTR ModuleInfo+356, 1
	jne	SHORT $LN16@SetModel

; 207  :         textvalue = "STACK";

	lea	rax, OFFSET FLAT:$SG11215
	mov	QWORD PTR textvalue$[rsp], rax
$LN16@SetModel:

; 208  :     AddPredefinedText( "@stack", textvalue );

	mov	rdx, QWORD PTR textvalue$[rsp]
	lea	rcx, OFFSET FLAT:$SG11216
	call	AddPredefinedText

; 209  : 
; 210  : #if 0
; 211  :     AddPredefinedText( "@fardata", ( ModuleInfo.model == MODEL_FLAT ? "FLAT" : SimGetSegName( SIM_FARDATA ) ) );
; 212  :     AddPredefinedText( "@fardata?", ( ModuleInfo.model == MODEL_FLAT ? "FLAT" : SimGetSegName( SIM_FARDATA_UN ) ) );
; 213  : #endif
; 214  : 
; 215  :     /* Set @Model and @Interface */
; 216  : 
; 217  :     sym_Model     = AddPredefinedConstant( "@Model", ModuleInfo.model );

	mov	edx, DWORD PTR ModuleInfo+360
	lea	rcx, OFFSET FLAT:$SG11217
	call	AddPredefinedConstant
	mov	QWORD PTR sym_Model, rax

; 218  :     sym_Interface = AddPredefinedConstant( "@Interface", ModuleInfo.langtype );

	mov	edx, DWORD PTR ModuleInfo+364
	lea	rcx, OFFSET FLAT:$SG11218
	call	AddPredefinedConstant
	mov	QWORD PTR sym_Interface, rax

; 219  : 
; 220  : #if AMD64_SUPPORT
; 221  :     if ( ModuleInfo.defOfssize == USE64 && ModuleInfo.fctype == FCT_WIN64 ) {

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN17@SetModel
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN17@SetModel

; 222  :         sym_ReservedStack = AddPredefinedConstant( "@ReservedStack", 0 );

	xor	edx, edx
	lea	rcx, OFFSET FLAT:$SG11220
	call	AddPredefinedConstant
	mov	QWORD PTR sym_ReservedStack, rax
$LN17@SetModel:

; 223  :     }
; 224  : #endif
; 225  : #if PE_SUPPORT
; 226  :     if ( ModuleInfo.sub_format == SFORMAT_PE )

	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN18@SetModel

; 227  :         pe_create_PE_header();

	call	pe_create_PE_header
$LN18@SetModel:

; 228  : #endif
; 229  : 
; 230  : #ifdef DEBUG_OUT
; 231  :     if ( Options.dump_reswords )

	movzx	eax, BYTE PTR Options+24
	test	eax, eax
	je	SHORT $LN19@SetModel

; 232  :         DumpResWords();

	call	DumpResWords
$LN19@SetModel:
$LN1@SetModel:

; 233  : #endif
; 234  : 
; 235  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
SetModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cpumodel.c
_TEXT	SEGMENT
size$ = 48
SetDefaultOfssize PROC

; 109  : {

	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 110  :     /* outside any segments? */
; 111  :     if( CurrSeg == NULL ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN2@SetDefault

; 112  :         ModuleInfo.defOfssize = size;

	movzx	eax, BYTE PTR size$[rsp]
	mov	BYTE PTR ModuleInfo+405, al
$LN2@SetDefault:

; 113  :     }
; 114  :     return( SetOfssize() );

	call	SetOfssize

; 115  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetDefaultOfssize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cpumodel.c
_TEXT	SEGMENT
sym$ = 32
name$ = 64
value$ = 72
AddPredefinedConstant PROC

; 98   : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 99   :     struct asym *sym = CreateVariable( name, value );

	mov	edx, DWORD PTR value$[rsp]
	mov	rcx, QWORD PTR name$[rsp]
	call	CreateVariable
	mov	QWORD PTR sym$[rsp], rax

; 100  :     if (sym)

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN2@AddPredefi

; 101  :         sym->predefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al
$LN2@AddPredefi:

; 102  :     return(sym);

	mov	rax, QWORD PTR sym$[rsp]

; 103  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
AddPredefinedConstant ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cpumodel.c
_TEXT	SEGMENT
i$ = 32
token$ = 64
table$ = 72
size$ = 80
FindToken PROC

; 86   : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 87   :     int i;
; 88   :     for( i = 0; i < size; i++, table++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@FindToken
$LN2@FindToken:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR table$[rsp]
	add	rax, 8
	mov	QWORD PTR table$[rsp], rax
$LN4@FindToken:
	mov	eax, DWORD PTR size$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@FindToken

; 89   :         if( _stricmp( *table, token ) == 0 ) {

	mov	rdx, QWORD PTR token$[rsp]
	mov	rax, QWORD PTR table$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN5@FindToken

; 90   :             return( i );

	mov	eax, DWORD PTR i$[rsp]
	jmp	SHORT $LN1@FindToken
$LN5@FindToken:

; 91   :         }
; 92   :     }

	jmp	SHORT $LN2@FindToken
$LN3@FindToken:

; 93   :     return( -1 );  /* Not found */

	mov	eax, -1
$LN1@FindToken:

; 94   : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
FindToken ENDP
_TEXT	ENDS
END
