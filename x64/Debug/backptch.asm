; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG10420 DB	'NULL', 00H
	ORG $+3
$SG10421 DB	'NULL', 00H
	ORG $+3
$SG10422 DB	'DoPatch(%u, %s): fixup sym=%s type=%u ofs=%Xh loc=%Xh op'
	DB	't=%u def_seg=%s', 0aH, 00H
	ORG $+3
$SG10425 DB	'NULL', 00H
	ORG $+3
$SG10426 DB	'NULL', 00H
	ORG $+7
$SG10427 DB	'DoPatch: skipped due to seg incompat: %s - %s', 0aH, 00H
	ORG $+1
$SG10431 DB	'DoPatch: Phase error! caused by far call optimization', 0aH
	DB	00H
	ORG $+1
$SG10433 DB	'DoPatch: FIX_RELOFF32/FIX_RELOFF16, return', 0aH, 00H
	ORG $+4
$SG10436 DB	'DoPatch: FIX_OFF8', 0aH, 00H
	ORG $+5
$SG10443 DB	'DoPatch(%u): Phase error, disp=%X, fixup=%s(%X), loc=%X!'
	DB	0aH, 00H
	ORG $+6
$SG10452 DB	'DoPatch: ORG/ALIGN detected, optimization canceled', 0aH
	DB	00H
	ORG $+4
$SG10455 DB	'DoPatch(loc=%X): sym %s, offset changed %X -> %X', 0aH, 00H
	ORG $+6
$SG10459 DB	'for sym=%s fixup loc %X changed to %X', 0aH, 00H
	ORG $+1
$SG10461 DB	'DoPatch: jump out of range, disp=%d', 0aH, 00H
	ORG $+3
$SG10462 DB	'DoPatch, loc=%X: displacement still short: %Xh', 0aH, 00H
$SG10464 DB	'DoPatch: default branch, unhandled fixup type=%u', 0aH, 00H
	ORG $+2
$SG10475 DB	'!NULL!', 00H
	ORG $+5
$SG10476 DB	'BackPatch(%s): location=%s:%X, bp_fixup=%p', 0aH, 00H
	ORG $+4
$SG10478 DB	'BackPatch(%s) exit, new ofs=%X', 0aH, 00H
_DATA	ENDS
PUBLIC	BackPatch
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitWarn:PROC
EXTRN	OutputByte:PROC
EXTRN	FreeFixup:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	_RTC_UninitUse:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
pdata	SEGMENT
$pdata$BackPatch DD imagerel $LN9
	DD	imagerel $LN9+264
	DD	imagerel $unwind$BackPatch
$pdata$DoPatch DD imagerel DoPatch
	DD	imagerel DoPatch+1926
	DD	imagerel $unwind$DoPatch
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
DoPatch$rtcName$0 DB 064H
	DB	069H
	DB	073H
	DB	070H
	DB	00H
	ORG $+3
DoPatch$rtcName$1 DB 06dH
	DB	061H
	DB	078H
	DB	05fH
	DB	064H
	DB	069H
	DB	073H
	DB	070H
	DB	00H
CONST	ENDS
xdata	SEGMENT
$unwind$BackPatch DD 021e01H
	DD	07006920aH
$unwind$DoPatch DD 032901H
	DD	0180112H
	DD	0700bH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\backptch.c
_TEXT	SEGMENT
disp$ = 80
max_disp$ = 84
size$ = 88
seg$ = 96
sym2$ = 104
fixup2$ = 112
$T3 = 120
$T4 = 121
tv68 = 128
tv82 = 136
tv95 = 144
tv133 = 152
tv149 = 160
tv159 = 164
tv369 = 168
tv190 = 172
tv192 = 176
sym$ = 208
fixup$ = 216
DoPatch	PROC

; 54   : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 192				; 000000c0H
	mov	rdi, rsp
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+208]
	mov	BYTE PTR $T3[rsp], 0
	mov	BYTE PTR $T4[rsp], 0

; 55   :     int_32              disp;
; 56   :     int_32              max_disp;
; 57   :     unsigned            size;
; 58   :     struct dsym         *seg;
; 59   : #if LABELOPT
; 60   :     struct asym         *sym2;
; 61   :     struct fixup        *fixup2;
; 62   : #endif
; 63   : 
; 64   :     /* all relative fixups should occure only at first pass and they signal forward references
; 65   :      * they must be removed after patching or skiped ( next processed as normal fixup )
; 66   :      */
; 67   : 
; 68   :     DebugMsg(("DoPatch(%u, %s): fixup sym=%s type=%u ofs=%" I32_SPEC "Xh loc=%" I32_SPEC "Xh opt=%u def_seg=%s\n",

	mov	rax, QWORD PTR fixup$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN52@DoPatch
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv68[rsp], rax
	jmp	SHORT $LN53@DoPatch
$LN52@DoPatch:
	lea	rax, OFFSET FLAT:$SG10420
	mov	QWORD PTR tv68[rsp], rax
$LN53@DoPatch:
	mov	rax, QWORD PTR fixup$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN54@DoPatch
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv82[rsp], rax
	jmp	SHORT $LN55@DoPatch
$LN54@DoPatch:
	lea	rax, OFFSET FLAT:$SG10421
	mov	QWORD PTR tv82[rsp], rax
$LN55@DoPatch:
	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	rcx, QWORD PTR tv68[rsp]
	mov	QWORD PTR [rsp+64], rcx
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rsp+56], ecx
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	mov	DWORD PTR [rsp+48], ecx
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+24]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9, QWORD PTR tv82[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rcx+8]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG10422
	call	DoDebugMsg

; 69   :               Parse_Pass + 1, sym->name,
; 70   :               fixup->sym ? fixup->sym->name : "NULL",
; 71   :               fixup->type,
; 72   :               fixup->offset,
; 73   :               fixup->locofs,
; 74   :               fixup->option,
; 75   :               fixup->def_seg ? fixup->def_seg->sym.name : "NULL" ));
; 76   :     seg = GetSegm( sym );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR seg$[rsp], rax

; 77   :     if( seg == NULL || fixup->def_seg != seg ) {

	cmp	QWORD PTR seg$[rsp], 0
	je	SHORT $LN23@DoPatch
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rcx, QWORD PTR seg$[rsp]
	cmp	QWORD PTR [rax+48], rcx
	je	$LN22@DoPatch
$LN23@DoPatch:

; 78   :         /* if fixup location is in another segment, backpatch is possible, but
; 79   :          * complicated and it's a pretty rare case, so nothing's done.
; 80   :          */
; 81   :         DebugMsg(("DoPatch: skipped due to seg incompat: %s - %s\n",

	cmp	QWORD PTR seg$[rsp], 0
	je	SHORT $LN56@DoPatch
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv95[rsp], rax
	jmp	SHORT $LN57@DoPatch
$LN56@DoPatch:
	lea	rax, OFFSET FLAT:$SG10425
	mov	QWORD PTR tv95[rsp], rax
$LN57@DoPatch:
	mov	rax, QWORD PTR fixup$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN58@DoPatch
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv133[rsp], rax
	jmp	SHORT $LN59@DoPatch
$LN58@DoPatch:
	lea	rax, OFFSET FLAT:$SG10426
	mov	QWORD PTR tv133[rsp], rax
$LN59@DoPatch:
	mov	r8, QWORD PTR tv95[rsp]
	mov	rdx, QWORD PTR tv133[rsp]
	lea	rcx, OFFSET FLAT:$SG10427
	call	DoDebugMsg

; 82   :                   fixup->def_seg ? fixup->def_seg->sym.name : "NULL",
; 83   :                   seg ? seg->sym.name : "NULL" ));
; 84   :         SkipFixup();
; 85   :         return;

	jmp	$LN1@DoPatch
$LN22@DoPatch:

; 86   :     }
; 87   : 
; 88   :     if( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN24@DoPatch

; 89   :         if( sym->mem_type == MT_FAR && fixup->option == OPTJ_CALL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN25@DoPatch
	mov	rax, QWORD PTR fixup$[rsp]
	cmp	DWORD PTR [rax+28], 4
	jne	SHORT $LN25@DoPatch

; 90   :             /* convert near call to push cs + near call,
; 91   :              * (only at first pass) */
; 92   :             DebugMsg(("DoPatch: Phase error! caused by far call optimization\n"));

	lea	rcx, OFFSET FLAT:$SG10431
	call	DoDebugMsg

; 93   :             ModuleInfo.PhaseError = TRUE;

	mov	BYTE PTR ModuleInfo+422, 1

; 94   :             sym->offset++;  /* a PUSH CS will be added */

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	inc	eax
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 95   :             /* todo: insert LABELOPT block here */
; 96   :             OutputByte( 0 ); /* it's pass one, nothing is written */

	xor	ecx, ecx
	call	OutputByte

; 97   :             FreeFixup( fixup );

	mov	rcx, QWORD PTR fixup$[rsp]
	call	FreeFixup

; 98   :             return;

	jmp	$LN1@DoPatch

; 99   :         //} else if( sym->mem_type == MT_NEAR ) {
; 100  :         } else {

	jmp	SHORT $LN26@DoPatch
$LN25@DoPatch:

; 101  :             /* forward reference, only at first pass */
; 102  :             switch( fixup->type ) {

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv149[rsp], eax
	cmp	DWORD PTR tv149[rsp], 2
	jl	SHORT $LN2@DoPatch
	cmp	DWORD PTR tv149[rsp], 3
	jle	SHORT $LN27@DoPatch
	cmp	DWORD PTR tv149[rsp], 4
	je	SHORT $LN28@DoPatch
	jmp	SHORT $LN2@DoPatch
$LN27@DoPatch:

; 103  :             case FIX_RELOFF32:
; 104  :             case FIX_RELOFF16:
; 105  :                 FreeFixup( fixup );

	mov	rcx, QWORD PTR fixup$[rsp]
	call	FreeFixup

; 106  :                 DebugMsg(("DoPatch: FIX_RELOFF32/FIX_RELOFF16, return\n"));

	lea	rcx, OFFSET FLAT:$SG10433
	call	DoDebugMsg

; 107  :                 return;

	jmp	$LN1@DoPatch
$LN28@DoPatch:

; 108  :             case FIX_OFF8:  /* push <forward reference> */
; 109  :                 if ( fixup->option == OPTJ_PUSH ) {

	mov	rax, QWORD PTR fixup$[rsp]
	cmp	DWORD PTR [rax+28], 5
	jne	SHORT $LN29@DoPatch

; 110  :                     size = 1;    /* size increases from 2 to 3/5 */

	mov	DWORD PTR size$[rsp], 1

; 111  :                     DebugMsg(("DoPatch: FIX_OFF8\n"));

	lea	rcx, OFFSET FLAT:$SG10436
	call	DoDebugMsg

; 112  :                     goto patch;

	jmp	$patch$69
$LN29@DoPatch:
$LN2@DoPatch:
$LN26@DoPatch:
$LN24@DoPatch:

; 113  :                 }
; 114  :             }
; 115  :         }
; 116  :     }
; 117  :     size = 0;

	mov	DWORD PTR size$[rsp], 0

; 118  :     switch( fixup->type ) {

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv159[rsp], eax
	cmp	DWORD PTR tv159[rsp], 1
	je	SHORT $LN32@DoPatch
	cmp	DWORD PTR tv159[rsp], 2
	je	SHORT $LN31@DoPatch
	cmp	DWORD PTR tv159[rsp], 3
	je	SHORT $LN30@DoPatch
	jmp	$LN50@DoPatch
$LN30@DoPatch:

; 119  :     case FIX_RELOFF32:
; 120  :         size = 2; /* will be 4 finally */

	mov	DWORD PTR size$[rsp], 2
$LN31@DoPatch:

; 121  :         /* fall through */
; 122  :     case FIX_RELOFF16:
; 123  :         size++; /* will be 2 finally */

	mov	eax, DWORD PTR size$[rsp]
	inc	eax
	mov	DWORD PTR size$[rsp], eax
$LN32@DoPatch:

; 124  :         /* fall through */
; 125  :     case FIX_RELOFF8:
; 126  :         size++;

	mov	eax, DWORD PTR size$[rsp]
	inc	eax
	mov	DWORD PTR size$[rsp], eax

; 127  :         /* calculate the displacement */
; 128  :         // disp = fixup->offset + GetCurrOffset() - fixup->location - size;
; 129  :         disp = fixup->offset + fixup->sym->offset - fixup->locofs - size - 1;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	add	ecx, DWORD PTR [rax+16]
	mov	eax, ecx
	mov	rcx, QWORD PTR fixup$[rsp]
	sub	eax, DWORD PTR [rcx+20]
	sub	eax, DWORD PTR size$[rsp]
	dec	eax
	mov	BYTE PTR $T3[rsp], 1
	mov	DWORD PTR disp$[rsp], eax

; 130  :         max_disp = (1UL << ((size * 8)-1)) - 1;

	mov	eax, DWORD PTR size$[rsp]
	lea	eax, DWORD PTR [rax*8-1]
	mov	ecx, 1
	mov	DWORD PTR tv369[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv369[rsp]
	shl	eax, cl
	dec	eax
	mov	BYTE PTR $T4[rsp], 1
	mov	DWORD PTR max_disp$[rsp], eax

; 131  :         if( disp > max_disp || disp < (-max_disp-1) ) {

	cmp	BYTE PTR $T3[rsp], 0
	jne	SHORT $LN60@DoPatch
	lea	rcx, OFFSET FLAT:DoPatch$rtcName$0
	call	_RTC_UninitUse
$LN60@DoPatch:
	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN61@DoPatch
	lea	rcx, OFFSET FLAT:DoPatch$rtcName$1
	call	_RTC_UninitUse
$LN61@DoPatch:
	mov	eax, DWORD PTR max_disp$[rsp]
	cmp	DWORD PTR disp$[rsp], eax
	jg	SHORT $LN35@DoPatch
	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN62@DoPatch
	lea	rcx, OFFSET FLAT:DoPatch$rtcName$1
	call	_RTC_UninitUse
$LN62@DoPatch:
	cmp	BYTE PTR $T3[rsp], 0
	jne	SHORT $LN63@DoPatch
	lea	rcx, OFFSET FLAT:DoPatch$rtcName$0
	call	_RTC_UninitUse
$LN63@DoPatch:
	mov	eax, DWORD PTR max_disp$[rsp]
	neg	eax
	dec	eax
	cmp	DWORD PTR disp$[rsp], eax
	jge	$LN33@DoPatch
$LN35@DoPatch:
$patch$69:

; 132  :         patch:
; 133  :             DebugMsg(("DoPatch(%u): Phase error, disp=%X, fixup=%s(%X), loc=%X!\n", Parse_Pass + 1, disp, fixup->sym->name, fixup->sym->offset, fixup->locofs ));

	cmp	BYTE PTR $T3[rsp], 0
	jne	SHORT $LN64@DoPatch
	lea	rcx, OFFSET FLAT:DoPatch$rtcName$0
	call	_RTC_UninitUse
$LN64@DoPatch:
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	edx, DWORD PTR Parse_Pass
	inc	edx
	mov	r8, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [r8+20]
	mov	DWORD PTR [rsp+40], r8d
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR [rcx+8]
	mov	r8d, DWORD PTR disp$[rsp]
	lea	rcx, OFFSET FLAT:$SG10443
	call	DoDebugMsg

; 134  :             ModuleInfo.PhaseError = TRUE;

	mov	BYTE PTR ModuleInfo+422, 1

; 135  :             /* ok, the standard case is: there's a forward jump which
; 136  :              * was assumed to be SHORT, but it must be NEAR instead.
; 137  :              */
; 138  :             switch( size ) {

	mov	eax, DWORD PTR size$[rsp]
	mov	DWORD PTR tv190[rsp], eax
	cmp	DWORD PTR tv190[rsp], 1
	je	SHORT $LN36@DoPatch
	cmp	DWORD PTR tv190[rsp], 2
	je	$LN49@DoPatch
	cmp	DWORD PTR tv190[rsp], 4
	je	$LN49@DoPatch
	jmp	$LN6@DoPatch
$LN36@DoPatch:

; 139  :             case 1:
; 140  :                 size = 0;

	mov	DWORD PTR size$[rsp], 0

; 141  :                 switch( fixup->option ) {

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR tv192[rsp], eax
	cmp	DWORD PTR tv192[rsp], 1
	je	SHORT $LN37@DoPatch
	cmp	DWORD PTR tv192[rsp], 2
	je	SHORT $LN38@DoPatch
	cmp	DWORD PTR tv192[rsp], 3
	je	SHORT $LN39@DoPatch
	jmp	SHORT $LN40@DoPatch
$LN37@DoPatch:

; 142  :                 case OPTJ_EXPLICIT:
; 143  : #if 0 /* don't display the error at the destination line! */
; 144  :                     DebugMsg(("DoPatch: jump out of range, disp=%d\n", disp ));
; 145  :                     EmitErr( JUMP_OUT_OF_RANGE, disp - max_disp );
; 146  : #endif
; 147  :                     return;

	jmp	$LN1@DoPatch
$LN38@DoPatch:

; 148  :                 case OPTJ_EXTEND: /* Jxx for 8086 */
; 149  :                     size++;       /* will be 3/5 finally */

	mov	eax, DWORD PTR size$[rsp]
	inc	eax
	mov	DWORD PTR size$[rsp], eax
$LN39@DoPatch:

; 150  :                     /* fall through */
; 151  :                 case OPTJ_JXX: /* Jxx for 386 */
; 152  :                     size++;

	mov	eax, DWORD PTR size$[rsp]
	inc	eax
	mov	DWORD PTR size$[rsp], eax
$LN40@DoPatch:

; 153  :                     /* fall through */
; 154  :                 default: /* normal JMP (and PUSH) */
; 155  :                     // if( CodeInfo->Ofssize ) /* v1.96: don't use CodeInfo here! */
; 156  :                     if( seg->e.seginfo->Ofssize )

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+104]
	test	eax, eax
	je	SHORT $LN41@DoPatch

; 157  :                         size += 2; /* NEAR32 instead of NEAR16 */

	mov	eax, DWORD PTR size$[rsp]
	add	eax, 2
	mov	DWORD PTR size$[rsp], eax
$LN41@DoPatch:

; 158  :                     size++;

	mov	eax, DWORD PTR size$[rsp]
	inc	eax
	mov	DWORD PTR size$[rsp], eax

; 159  : #if LABELOPT
; 160  :                     /* v2.04: if there's an ORG between src and dst, skip
; 161  :                      * the optimization!
; 162  :                      */
; 163  :                     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN42@DoPatch

; 164  :                         for ( fixup2 = seg->e.seginfo->FixupList.head; fixup2; fixup2 = fixup2->nextrlc ) {

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR fixup2$[rsp], rax
	jmp	SHORT $LN12@DoPatch
$LN10@DoPatch:
	mov	rax, QWORD PTR fixup2$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR fixup2$[rsp], rax
$LN12@DoPatch:
	cmp	QWORD PTR fixup2$[rsp], 0
	je	SHORT $LN11@DoPatch

; 165  :                             if ( fixup2->orgoccured ) {

	mov	rax, QWORD PTR fixup2$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN43@DoPatch

; 166  :                                 DebugMsg(("DoPatch: ORG/ALIGN detected, optimization canceled\n" ));

	lea	rcx, OFFSET FLAT:$SG10452
	call	DoDebugMsg

; 167  :                                 return;

	jmp	$LN1@DoPatch
$LN43@DoPatch:

; 168  :                             }
; 169  :                             /* do this check after the check for ORG! */
; 170  :                             if ( fixup2->locofs <= fixup->locofs )

	mov	rax, QWORD PTR fixup2$[rsp]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	cmp	DWORD PTR [rax+20], ecx
	ja	SHORT $LN44@DoPatch

; 171  :                                 break;

	jmp	SHORT $LN11@DoPatch
$LN44@DoPatch:

; 172  :                         }

	jmp	SHORT $LN10@DoPatch
$LN11@DoPatch:
$LN42@DoPatch:

; 173  :                     }
; 174  :                     /* scan the segment's label list and adjust all labels
; 175  :                      * which are between the fixup loc and the current sym.
; 176  :                      * ( PROCs are NOT contained in this list because they
; 177  :                      * use the <next>-field of dsym already!)
; 178  :                      */
; 179  :                     for ( sym2 = seg->e.seginfo->label_list; sym2; sym2 = (struct asym *)((struct dsym *)sym2)->next ) {

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR sym2$[rsp], rax
	jmp	SHORT $LN15@DoPatch
$LN13@DoPatch:
	mov	rax, QWORD PTR sym2$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR sym2$[rsp], rax
$LN15@DoPatch:
	cmp	QWORD PTR sym2$[rsp], 0
	je	SHORT $LN14@DoPatch

; 180  :                         //if ( sym2 == sym )
; 181  :                         //    continue;
; 182  :                         /* v2.0: location is at least 1 byte too low, so
; 183  :                          * use the "<=" operator instead of "<"!
; 184  :                          */
; 185  :                         //if ( sym2->offset < fixup->locofs )
; 186  :                         if ( sym2->offset <= fixup->locofs )

	mov	rax, QWORD PTR sym2$[rsp]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	cmp	DWORD PTR [rax+16], ecx
	ja	SHORT $LN45@DoPatch

; 187  :                             break;

	jmp	SHORT $LN14@DoPatch
$LN45@DoPatch:

; 188  :                         sym2->offset += size;

	mov	rax, QWORD PTR sym2$[rsp]
	mov	eax, DWORD PTR [rax+16]
	add	eax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR sym2$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 189  :                         DebugMsg(("DoPatch(loc=%" I32_SPEC "X): sym %s, offset changed %" I32_SPEC "X -> %" I32_SPEC "X\n", fixup->locofs, sym2->name, sym2->offset - size, sym2->offset));

	mov	rax, QWORD PTR sym2$[rsp]
	mov	ecx, DWORD PTR size$[rsp]
	mov	eax, DWORD PTR [rax+16]
	sub	eax, ecx
	mov	rcx, QWORD PTR sym2$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, eax
	mov	rax, QWORD PTR sym2$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	edx, DWORD PTR [rax+20]
	lea	rcx, OFFSET FLAT:$SG10455
	call	DoDebugMsg

; 190  :                     }

	jmp	SHORT $LN13@DoPatch
$LN14@DoPatch:

; 191  :                     /* v2.03: also adjust fixup locations located between the
; 192  :                      * label reference and the label. This should reduce the
; 193  :                      * number of passes to 2 for not too complex sources.
; 194  :                      */
; 195  :                     if ( Parse_Pass == PASS_1 ) /* v2.04: added, just to be safe */

	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN46@DoPatch

; 196  :                     for ( fixup2 = seg->e.seginfo->FixupList.head; fixup2; fixup2 = fixup2->nextrlc ) {

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR fixup2$[rsp], rax
	jmp	SHORT $LN18@DoPatch
$LN16@DoPatch:
	mov	rax, QWORD PTR fixup2$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR fixup2$[rsp], rax
$LN18@DoPatch:
	cmp	QWORD PTR fixup2$[rsp], 0
	je	SHORT $LN17@DoPatch

; 197  :                         if ( fixup2->sym == sym )

	mov	rax, QWORD PTR fixup2$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+56], rcx
	jne	SHORT $LN47@DoPatch

; 198  :                             continue;

	jmp	SHORT $LN16@DoPatch
$LN47@DoPatch:

; 199  :                         if ( fixup2->locofs <= fixup->locofs )

	mov	rax, QWORD PTR fixup2$[rsp]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	cmp	DWORD PTR [rax+20], ecx
	ja	SHORT $LN48@DoPatch

; 200  :                             break;

	jmp	SHORT $LN17@DoPatch
$LN48@DoPatch:

; 201  :                         fixup2->locofs += size;

	mov	rax, QWORD PTR fixup2$[rsp]
	mov	eax, DWORD PTR [rax+20]
	add	eax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR fixup2$[rsp]
	mov	DWORD PTR [rcx+20], eax

; 202  :                         DebugMsg(("for sym=%s fixup loc %" I32_SPEC "X changed to %" I32_SPEC "X\n", fixup2->sym->name, fixup2->locofs - size, fixup2->locofs ));

	mov	rax, QWORD PTR fixup2$[rsp]
	mov	ecx, DWORD PTR size$[rsp]
	mov	eax, DWORD PTR [rax+20]
	sub	eax, ecx
	mov	rcx, QWORD PTR fixup2$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	rdx, QWORD PTR fixup2$[rsp]
	mov	r9d, DWORD PTR [rdx+20]
	mov	r8d, eax
	mov	rdx, QWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG10459
	call	DoDebugMsg

; 203  :                     }

	jmp	$LN16@DoPatch
$LN17@DoPatch:
$LN46@DoPatch:

; 204  : #else
; 205  :                     DebugMsg(("DoPatch: sym %s, offset changed %" I32_SPEC "X -> %" I32_SPEC "X\n", sym->name, sym->offset, sym->offset + size));
; 206  :                     sym->offset += size;
; 207  : #endif
; 208  :                     /*  it doesn't matter what's actually "written" */
; 209  :                     for ( ; size; size-- )

	jmp	SHORT $LN21@DoPatch
$LN19@DoPatch:
	mov	eax, DWORD PTR size$[rsp]
	dec	eax
	mov	DWORD PTR size$[rsp], eax
$LN21@DoPatch:
	cmp	DWORD PTR size$[rsp], 0
	je	SHORT $LN20@DoPatch

; 210  :                         OutputByte( 0xCC );

	mov	cl, 204					; 000000ccH
	call	OutputByte
	jmp	SHORT $LN19@DoPatch
$LN20@DoPatch:

; 211  :                     break;
; 212  :                 }
; 213  :                 break;

	jmp	SHORT $LN6@DoPatch
$LN49@DoPatch:

; 214  :             case 2:
; 215  :             case 4:
; 216  :                 DebugMsg(("DoPatch: jump out of range, disp=%d\n", disp ));

	cmp	BYTE PTR $T3[rsp], 0
	jne	SHORT $LN65@DoPatch
	lea	rcx, OFFSET FLAT:DoPatch$rtcName$0
	call	_RTC_UninitUse
$LN65@DoPatch:
	mov	edx, DWORD PTR disp$[rsp]
	lea	rcx, OFFSET FLAT:$SG10461
	call	DoDebugMsg

; 217  :                 EmitWarn( 4, JUMP_OUT_OF_RANGE, disp - max_disp );

	cmp	BYTE PTR $T3[rsp], 0
	jne	SHORT $LN66@DoPatch
	lea	rcx, OFFSET FLAT:DoPatch$rtcName$0
	call	_RTC_UninitUse
$LN66@DoPatch:
	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN67@DoPatch
	lea	rcx, OFFSET FLAT:DoPatch$rtcName$1
	call	_RTC_UninitUse
$LN67@DoPatch:
	mov	eax, DWORD PTR max_disp$[rsp]
	mov	ecx, DWORD PTR disp$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	r8d, eax
	mov	edx, 54					; 00000036H
	mov	ecx, 4
	call	EmitWarn
$LN6@DoPatch:

; 218  :                 break;
; 219  :             }
; 220  :         }

	jmp	SHORT $LN34@DoPatch
$LN33@DoPatch:

; 221  : #ifdef DEBUG_OUT
; 222  :         else
; 223  :             DebugMsg(("DoPatch, loc=%" I32_SPEC "X: displacement still short: %Xh\n", fixup->locofs, disp ));

	cmp	BYTE PTR $T3[rsp], 0
	jne	SHORT $LN68@DoPatch
	lea	rcx, OFFSET FLAT:DoPatch$rtcName$0
	call	_RTC_UninitUse
$LN68@DoPatch:
	mov	r8d, DWORD PTR disp$[rsp]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	edx, DWORD PTR [rax+20]
	lea	rcx, OFFSET FLAT:$SG10462
	call	DoDebugMsg
$LN34@DoPatch:

; 224  : #endif
; 225  :         /* v2.04: fixme: is it ok to remove the fixup?
; 226  :          * it might still be needed in a later backpatch.
; 227  :          */
; 228  :         FreeFixup( fixup );

	mov	rcx, QWORD PTR fixup$[rsp]
	call	FreeFixup

; 229  :         break;

	jmp	SHORT $LN4@DoPatch
$LN50@DoPatch:

; 230  :     default:
; 231  :         DebugMsg(("DoPatch: default branch, unhandled fixup type=%u\n", fixup->type ));

	mov	rax, QWORD PTR fixup$[rsp]
	mov	edx, DWORD PTR [rax+24]
	lea	rcx, OFFSET FLAT:$SG10464
	call	DoDebugMsg
$LN4@DoPatch:
$LN1@DoPatch:

; 232  :         SkipFixup();
; 233  :         break;
; 234  :     }
; 235  :     return;
; 236  : }

	add	rsp, 192				; 000000c0H
	pop	rdi
	ret	0
DoPatch	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\backptch.c
_TEXT	SEGMENT
fixup$ = 48
next$ = 56
oldofs$ = 64
tv73 = 72
sym$ = 96
BackPatch PROC

; 249  : {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 250  :     struct fixup     *fixup;
; 251  :     struct fixup     *next;
; 252  : #ifdef DEBUG_OUT
; 253  :     uint_32 oldofs = sym->offset;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR oldofs$[rsp], eax

; 254  : #endif
; 255  : 
; 256  :     DebugMsg1(("BackPatch(%s): location=%s:%X, bp_fixup=%p\n", sym->name, sym->segment ? sym->segment->name : "!NULL!", sym->offset, sym->bp_fixup ));

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN7@BackPatch
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv73[rsp], rax
	jmp	SHORT $LN8@BackPatch
$LN7@BackPatch:
	lea	rax, OFFSET FLAT:$SG10475
	mov	QWORD PTR tv73[rsp], rax
$LN8@BackPatch:
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+16]
	mov	r8, QWORD PTR tv73[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10476
	call	DoDebugMsg1

; 257  : 
; 258  :     for( fixup = sym->bp_fixup; fixup; fixup = next ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR fixup$[rsp], rax
	jmp	SHORT $LN4@BackPatch
$LN2@BackPatch:
	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR fixup$[rsp], rax
$LN4@BackPatch:
	cmp	QWORD PTR fixup$[rsp], 0
	je	SHORT $LN3@BackPatch

; 259  :         next = fixup->nextbp;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR next$[rsp], rax

; 260  :         DoPatch( sym, fixup );

	mov	rdx, QWORD PTR fixup$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	DoPatch

; 261  :     }

	jmp	SHORT $LN2@BackPatch
$LN3@BackPatch:

; 262  :     /* fixme: to clear field bp_fixup may cause memory leaks, since not all fixups are freed here.
; 263  :      * usually no problem, because FASTMEM is true ( that is, LclFree() is a NOP ).
; 264  :      * the problem is that these fixups are in 2 queues, one starts in sym.bp_fixup,
; 265  :      * the other start in CurrSeg.FixupList.
; 266  :      */
; 267  :     sym->bp_fixup = NULL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+88], 0

; 268  : #ifdef DEBUG_OUT
; 269  :     if ( oldofs != sym->offset )

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR oldofs$[rsp], eax
	je	SHORT $LN5@BackPatch

; 270  :         DebugMsg1(("BackPatch(%s) exit, new ofs=%X\n", sym->name, sym->offset ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+16]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10478
	call	DoDebugMsg1
$LN5@BackPatch:

; 271  : #endif
; 272  :     return( NOT_ERROR );

	xor	eax, eax

; 273  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
BackPatch ENDP
_TEXT	ENDS
END
