; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
CONST	SEGMENT
tab_plus_exp DD	00H
	DD	00H
	DD	0a0000000H
	DW	04002H
	ORG $+2
	DD	00H
	DD	00H
	DD	0c8000000H
	DW	04005H
	ORG $+2
	DD	00H
	DD	00H
	DD	09c400000H
	DW	0400cH
	ORG $+2
	DD	00H
	DD	00H
	DD	0bebc2000H
	DW	04019H
	ORG $+2
	DD	00H
	DD	04000000H
	DD	08e1bc9bfH
	DW	04034H
	ORG $+2
	DD	0f0200000H
	DD	02b70b59dH
	DD	09dc5ada8H
	DW	04069H
	ORG $+2
	DD	03cbf6b71H
	DD	0ffcfa6d5H
	DD	0c2781f49H
	DW	040d3H
	ORG $+2
	DD	0c66f336bH
	DD	080e98cdfH
	DD	093ba47c9H
	DW	041a8H
	ORG $+2
	DD	0ddbb9018H
	DD	09df9de8dH
	DD	0aa7eebfbH
	DW	04351H
	ORG $+2
	DD	0cc655c4bH
	DD	0a60e91c6H
	DD	0e319a0aeH
	DW	046a3H
	ORG $+2
	DD	0650d3d17H
	DD	081750c17H
	DD	0c9767586H
	DW	04d48H
	ORG $+2
	DD	0a74d28b1H
	DD	0c53d5de4H
	DD	09e8b3b5dH
	DW	05a92H
	ORG $+2
	DD	0c94c14f7H
	DD	08a20979aH
	DD	0c4605202H
	DW	07525H
	ORG $+2
tab_minus_exp DD 0cccccccdH
	DD	0ccccccccH
	DD	0ccccccccH
	DW	03ffbH
	ORG $+2
	DD	03d70a3d7H
	DD	070a3d70aH
	DD	0a3d70a3dH
	DW	03ff8H
	ORG $+2
	DD	0d3c36113H
	DD	0e219652bH
	DD	0d1b71758H
	DW	03ff1H
	ORG $+2
	DD	0fdc20d2aH
	DD	08461cefcH
	DD	0abcc7711H
	DW	03fe4H
	ORG $+2
	DD	04c2ebe65H
	DD	0c44de15bH
	DD	0e69594beH
	DW	03fc9H
	ORG $+2
	DD	067de18e7H
	DD	0453994baH
	DD	0cfb11eadH
	DW	03f94H
	ORG $+2
	DD	03f2398ccH
	DD	0a539e9a5H
	DD	0a87fea27H
	DW	03f2aH
	ORG $+2
	DD	0ac7cb3d9H
	DD	064bce4a0H
	DD	0ddd0467cH
	DW	03e55H
	ORG $+2
	DD	0fa911122H
	DD	0637a1939H
	DD	0c0314325H
	DW	03cacH
	ORG $+2
	DD	07132d2e4H
	DD	0db23d21cH
	DD	09049ee32H
	DW	0395aH
	ORG $+2
	DD	087a600a6H
	DD	0da57c0bdH
	DD	0a2a682a5H
	DW	032b5H
	ORG $+2
	DD	04925110fH
	DD	034362de4H
	DD	0ceae534fH
	DW	0256bH
	ORG $+2
	DD	02de37e46H
	DD	0d2ce9fdeH
	DD	0a6dd04c8H
	DW	0ad8H
	ORG $+2
CONST	ENDS
PUBLIC	strtotb
EXTRN	__imp_isspace:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$strtotb DD imagerel $LN40
	DD	imagerel $LN40+1135
	DD	imagerel $unwind$strtotb
$pdata$cmp_u96_max DD imagerel cmp_u96_max
	DD	imagerel cmp_u96_max+214
	DD	imagerel $unwind$cmp_u96_max
$pdata$add_check_u96_overflow DD imagerel add_check_u96_overflow
	DD	imagerel add_check_u96_overflow+167
	DD	imagerel $unwind$add_check_u96_overflow
$pdata$bitsize32 DD imagerel bitsize32
	DD	imagerel bitsize32+87
	DD	imagerel $unwind$bitsize32
$pdata$bitsize64 DD imagerel bitsize64
	DD	imagerel bitsize64+105
	DD	imagerel $unwind$bitsize64
$pdata$U96LD DD	imagerel U96LD
	DD	imagerel U96LD+698
	DD	imagerel $unwind$U96LD
$pdata$normalize DD imagerel normalize
	DD	imagerel normalize+688
	DD	imagerel $unwind$normalize
$pdata$add192 DD imagerel add192
	DD	imagerel add192+239
	DD	imagerel $unwind$add192
$pdata$multiply DD imagerel multiply
	DD	imagerel multiply+1043
	DD	imagerel $unwind$multiply
$pdata$TB_create DD imagerel TB_create
	DD	imagerel TB_create+448
	DD	imagerel $unwind$TB_create
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
xdata	SEGMENT
$unwind$strtotb DD 034019H
	DD	0160117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$cmp_u96_max DD 010601H
	DD	07006H
$unwind$add_check_u96_overflow DD 022201H
	DD	0700a520eH
$unwind$bitsize32 DD 021c01H
	DD	070051209H
$unwind$bitsize64 DD 021e01H
	DD	07006120aH
$unwind$U96LD DD 022301H
	DD	0700b720fH
$unwind$normalize DD 021e01H
	DD	07006720aH
$unwind$add192 DD 022801H
	DD	070101214H
$unwind$multiply DD 023a19H
	DD	07010d214H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$TB_create DD 023919H
	DD	0700fd213H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
CONST	SEGMENT
strtotb$rtcName$0 DB 076H
	DB	061H
	DB	06cH
	DB	075H
	DB	065H
	DB	00H
	ORG $+2
strtotb$rtcName$1 DB 076H
	DB	061H
	DB	06cH
	DB	075H
	DB	065H
	DB	05fH
	DB	074H
	DB	06dH
	DB	070H
	DB	00H
	ORG $+6
strtotb$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:strtotb$rtcVarDesc
multiply$rtcName$0 DB 072H
	DB	031H
	DB	00H
	ORG $+5
strtotb$rtcVarDesc DD 078H
	DD	0cH
	DQ	FLAT:strtotb$rtcName$1
	DD	048H
	DD	0cH
	DQ	FLAT:strtotb$rtcName$0
	ORG $+96
multiply$rtcVarDesc DD 038H
	DD	018H
	DQ	FLAT:multiply$rtcName$0
	ORG $+48
multiply$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:multiply$rtcVarDesc
TB_create$rtcName$0 DB 072H
	DB	065H
	DB	073H
	DB	00H
	ORG $+12
TB_create$rtcVarDesc DD 038H
	DD	010H
	DQ	FLAT:TB_create$rtcName$0
	ORG $+48
TB_create$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:TB_create$rtcVarDesc
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
_TEXT	SEGMENT
tabExp$ = 32
i$ = 40
res$ = 56
__$ArrayPad$ = 96
value$ = 128
exponent$ = 136
ld$ = 144
TB_create PROC

; 329  : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+128]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 330  :     const struct ELD *tabExp;
; 331  :     int i;
; 332  :     struct ELD res;
; 333  : 
; 334  :     if( exponent < 0 ) {

	cmp	DWORD PTR exponent$[rsp], 0
	jge	SHORT $LN5@TB_create

; 335  :         exponent = -exponent;

	mov	eax, DWORD PTR exponent$[rsp]
	neg	eax
	mov	DWORD PTR exponent$[rsp], eax

; 336  :         tabExp = tab_minus_exp;

	lea	rax, OFFSET FLAT:tab_minus_exp
	mov	QWORD PTR tabExp$[rsp], rax

; 337  :     } else {

	jmp	SHORT $LN6@TB_create
$LN5@TB_create:

; 338  :         tabExp = tab_plus_exp;

	lea	rax, OFFSET FLAT:tab_plus_exp
	mov	QWORD PTR tabExp$[rsp], rax
$LN6@TB_create:

; 339  :     }
; 340  :     U96LD(value, &res);

	lea	rdx, QWORD PTR res$[rsp]
	mov	rcx, QWORD PTR value$[rsp]
	call	U96LD

; 341  :     for( i = 0; i < MAX_EXP_INDEX; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@TB_create
$LN2@TB_create:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@TB_create:
	cmp	DWORD PTR i$[rsp], 13
	jge	SHORT $LN3@TB_create

; 342  :         if ( exponent & 1 ) {

	mov	eax, DWORD PTR exponent$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@TB_create

; 343  :             multiply(&res, tabExp + i, &res);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR tabExp$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	r8, QWORD PTR res$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR res$[rsp]
	call	multiply
$LN7@TB_create:

; 344  :         }
; 345  :         exponent >>= 1;

	mov	eax, DWORD PTR exponent$[rsp]
	sar	eax, 1
	mov	DWORD PTR exponent$[rsp], eax

; 346  :         if( exponent == 0 ) break;

	cmp	DWORD PTR exponent$[rsp], 0
	jne	SHORT $LN8@TB_create
	jmp	SHORT $LN3@TB_create
$LN8@TB_create:

; 347  :     }

	jmp	SHORT $LN2@TB_create
$LN3@TB_create:

; 348  :     if( exponent != 0 ) {
; 349  :         /* exponent overflow */
; 350  :     }
; 351  :     ld->e = res.e;

	mov	rax, QWORD PTR ld$[rsp]
	movzx	ecx, WORD PTR res$[rsp+12]
	mov	WORD PTR [rax+8], cx

; 352  :     ld->m = res.m32[1] + ((uint_64)res.m32[2] << 32) ;

	mov	eax, 4
	imul	rax, rax, 1
	mov	eax, DWORD PTR res$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	ecx, DWORD PTR res$[rsp+rcx]
	shl	rcx, 32					; 00000020H
	add	rax, rcx
	mov	rcx, QWORD PTR ld$[rsp]
	mov	QWORD PTR [rcx], rax

; 353  :     /* round result */
; 354  :     if( res.m32[0] & 0x80000000U ) {

	mov	eax, 4
	imul	rax, rax, 0
	mov	eax, DWORD PTR res$[rsp+rax]
	and	eax, -2147483648			; 80000000H
	test	eax, eax
	je	SHORT $LN10@TB_create

; 355  :         if( ld->m == MAXUI64 ) {

	mov	rax, QWORD PTR ld$[rsp]
	cmp	QWORD PTR [rax], -1
	jne	SHORT $LN11@TB_create

; 356  :             ld->m = MAXUI64BIT;

	mov	rax, QWORD PTR ld$[rsp]
	mov	rcx, -9223372036854775808		; 8000000000000000H
	mov	QWORD PTR [rax], rcx

; 357  :             ld->e++;

	mov	rax, QWORD PTR ld$[rsp]
	movzx	eax, WORD PTR [rax+8]
	inc	ax
	mov	rcx, QWORD PTR ld$[rsp]
	mov	WORD PTR [rcx+8], ax

; 358  :         } else {

	jmp	SHORT $LN12@TB_create
$LN11@TB_create:

; 359  :             ld->m++;

	mov	rax, QWORD PTR ld$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR ld$[rsp]
	mov	QWORD PTR [rcx], rax
$LN12@TB_create:
$LN10@TB_create:

; 360  :         }
; 361  :     }
; 362  :     return( 0 );

	xor	eax, eax

; 363  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:TB_create$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
TB_create ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
_TEXT	SEGMENT
x1$ = 32
r1$ = 56
exp$ = 84
__$ArrayPad$ = 96
op1$ = 128
op2$ = 136
res$ = 144
multiply PROC

; 283  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+128]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 284  :     uint_64 x1;
; 285  :     union u192 r1;
; 286  :     int_32 exp;
; 287  : 
; 288  :     exp = (int_32)(op1->e & 0x7fff) + (int_32)(op2->e & 0x7fff) - EXPONENT_BIAS + 1;

	mov	rax, QWORD PTR op1$[rsp]
	movzx	eax, WORD PTR [rax+12]
	and	eax, 32767				; 00007fffH
	mov	rcx, QWORD PTR op2$[rsp]
	movzx	ecx, WORD PTR [rcx+12]
	and	ecx, 32767				; 00007fffH
	lea	eax, DWORD PTR [rax+rcx-16382]
	mov	DWORD PTR exp$[rsp], eax

; 289  :     r1.m64[0] = (uint_64)(op1->m32[0]) * (uint_64)(op2->m32[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR op1$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR op2$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx]
	imul	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	QWORD PTR r1$[rsp+rcx], rax

; 290  :     r1.m64[1] = (uint_64)(op1->m32[1]) * (uint_64)(op2->m32[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR op1$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR op2$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx]
	imul	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	QWORD PTR r1$[rsp+rcx], rax

; 291  :     r1.m64[2] = (uint_64)(op1->m32[2]) * (uint_64)(op2->m32[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR op1$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR op2$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx]
	imul	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	QWORD PTR r1$[rsp+rcx], rax

; 292  :     x1 = (uint_64)(op1->m32[1]) * (uint_64)(op2->m32[0]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR op1$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR op2$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx]
	imul	rax, rcx
	mov	QWORD PTR x1$[rsp], rax

; 293  :     add192( &r1, x1, 1 );

	mov	r8d, 1
	mov	rdx, QWORD PTR x1$[rsp]
	lea	rcx, QWORD PTR r1$[rsp]
	call	add192

; 294  :     x1 = (uint_64)(op1->m32[0]) * (uint_64)(op2->m32[1]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR op1$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR op2$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx]
	imul	rax, rcx
	mov	QWORD PTR x1$[rsp], rax

; 295  :     add192( &r1, x1, 1 );

	mov	r8d, 1
	mov	rdx, QWORD PTR x1$[rsp]
	lea	rcx, QWORD PTR r1$[rsp]
	call	add192

; 296  :     x1 = (uint_64)(op1->m32[0]) * (uint_64)(op2->m32[2]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR op1$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR op2$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx]
	imul	rax, rcx
	mov	QWORD PTR x1$[rsp], rax

; 297  :     add192( &r1, x1, 2 );

	mov	r8d, 2
	mov	rdx, QWORD PTR x1$[rsp]
	lea	rcx, QWORD PTR r1$[rsp]
	call	add192

; 298  :     x1 = (uint_64)(op1->m32[2]) * (uint_64)(op2->m32[0]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR op1$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR op2$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx]
	imul	rax, rcx
	mov	QWORD PTR x1$[rsp], rax

; 299  :     add192( &r1, x1, 2 );

	mov	r8d, 2
	mov	rdx, QWORD PTR x1$[rsp]
	lea	rcx, QWORD PTR r1$[rsp]
	call	add192

; 300  :     x1 = (uint_64)(op1->m32[1]) * (uint_64)(op2->m32[2]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR op1$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR op2$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx]
	imul	rax, rcx
	mov	QWORD PTR x1$[rsp], rax

; 301  :     add192( &r1, x1, 3 );

	mov	r8d, 3
	mov	rdx, QWORD PTR x1$[rsp]
	lea	rcx, QWORD PTR r1$[rsp]
	call	add192

; 302  :     x1 = (uint_64)(op1->m32[2]) * (uint_64)(op2->m32[1]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR op1$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR op2$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx]
	imul	rax, rcx
	mov	QWORD PTR x1$[rsp], rax

; 303  :     add192( &r1, x1, 3 );

	mov	r8d, 3
	mov	rdx, QWORD PTR x1$[rsp]
	lea	rcx, QWORD PTR r1$[rsp]
	call	add192

; 304  :     exp += normalize( &r1 );

	lea	rcx, QWORD PTR r1$[rsp]
	call	normalize
	mov	ecx, DWORD PTR exp$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR exp$[rsp], eax

; 305  :     /* round result */
; 306  :     if( r1.m32[2] & 0x80000000U ) {

	mov	eax, 4
	imul	rax, rax, 2
	mov	eax, DWORD PTR r1$[rsp+rax]
	and	eax, -2147483648			; 80000000H
	test	eax, eax
	je	$LN2@multiply

; 307  :         if( r1.m32[5] == 0xffffffffU && r1.m32[4] == 0xffffffffU && r1.m32[3] == 0xffffffffU ) {

	mov	eax, 4
	imul	rax, rax, 5
	cmp	DWORD PTR r1$[rsp+rax], -1		; ffffffffH
	jne	SHORT $LN3@multiply
	mov	eax, 4
	imul	rax, rax, 4
	cmp	DWORD PTR r1$[rsp+rax], -1		; ffffffffH
	jne	SHORT $LN3@multiply
	mov	eax, 4
	imul	rax, rax, 3
	cmp	DWORD PTR r1$[rsp+rax], -1		; ffffffffH
	jne	SHORT $LN3@multiply

; 308  :             r1.m32[3] = 0;

	mov	eax, 4
	imul	rax, rax, 3
	mov	DWORD PTR r1$[rsp+rax], 0

; 309  :             r1.m32[4] = 0;

	mov	eax, 4
	imul	rax, rax, 4
	mov	DWORD PTR r1$[rsp+rax], 0

; 310  :             r1.m32[5] = 0x80000000U;

	mov	eax, 4
	imul	rax, rax, 5
	mov	DWORD PTR r1$[rsp+rax], -2147483648	; 80000000H

; 311  :             exp++;

	mov	eax, DWORD PTR exp$[rsp]
	inc	eax
	mov	DWORD PTR exp$[rsp], eax

; 312  :         } else {

	jmp	SHORT $LN4@multiply
$LN3@multiply:

; 313  :             x1 = 1L;

	mov	QWORD PTR x1$[rsp], 1

; 314  :             add192( &r1, x1, 3 );

	mov	r8d, 3
	mov	rdx, QWORD PTR x1$[rsp]
	lea	rcx, QWORD PTR r1$[rsp]
	call	add192
$LN4@multiply:
$LN2@multiply:

; 315  :         }
; 316  :     }
; 317  :     res->m32[0] = r1.m32[3];

	mov	eax, 4
	imul	rax, rax, 3
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR res$[rsp]
	mov	eax, DWORD PTR r1$[rsp+rax]
	mov	DWORD PTR [rdx+rcx], eax

; 318  :     res->m32[1] = r1.m32[4];

	mov	eax, 4
	imul	rax, rax, 4
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR res$[rsp]
	mov	eax, DWORD PTR r1$[rsp+rax]
	mov	DWORD PTR [rdx+rcx], eax

; 319  :     res->m32[2] = r1.m32[5];

	mov	eax, 4
	imul	rax, rax, 5
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR res$[rsp]
	mov	eax, DWORD PTR r1$[rsp+rax]
	mov	DWORD PTR [rdx+rcx], eax

; 320  :     res->e = exp;

	mov	rax, QWORD PTR res$[rsp]
	movzx	ecx, WORD PTR exp$[rsp]
	mov	WORD PTR [rax+12], cx

; 321  :     return( 0 );

	xor	eax, eax

; 322  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:multiply$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
multiply ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
_TEXT	SEGMENT
cy$ = 0
i$ = 8
res$ = 32
x$ = 40
pos$ = 48
add192	PROC

; 259  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 260  :     uint_64 cy;
; 261  :     int i;
; 262  : 
; 263  :     cy = (uint_32)x;

	mov	eax, DWORD PTR x$[rsp]
	mov	QWORD PTR cy$[rsp], rax

; 264  :     for( i = pos; i < 6; i++ ) {

	mov	eax, DWORD PTR pos$[rsp]
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN4@add192
$LN2@add192:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@add192:
	cmp	DWORD PTR i$[rsp], 6
	jge	SHORT $LN3@add192

; 265  :         cy += res->m32[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR res$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR cy$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cy$[rsp], rax

; 266  :         res->m32[i] = cy;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR res$[rsp]
	mov	edx, DWORD PTR cy$[rsp]
	mov	DWORD PTR [rcx+rax*4], edx

; 267  :         cy >>= 32;

	mov	rax, QWORD PTR cy$[rsp]
	shr	rax, 32					; 00000020H
	mov	QWORD PTR cy$[rsp], rax

; 268  :     }

	jmp	SHORT $LN2@add192
$LN3@add192:

; 269  :     cy = x >> 32;

	mov	rax, QWORD PTR x$[rsp]
	shr	rax, 32					; 00000020H
	mov	QWORD PTR cy$[rsp], rax

; 270  :     for( i = pos + 1; i < 6; i++ ) {

	mov	eax, DWORD PTR pos$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN7@add192
$LN5@add192:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@add192:
	cmp	DWORD PTR i$[rsp], 6
	jge	SHORT $LN6@add192

; 271  :         cy += res->m32[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR res$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR cy$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cy$[rsp], rax

; 272  :         res->m32[i] = cy;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR res$[rsp]
	mov	edx, DWORD PTR cy$[rsp]
	mov	DWORD PTR [rcx+rax*4], edx

; 273  :         cy >>= 32;

	mov	rax, QWORD PTR cy$[rsp]
	shr	rax, 32					; 00000020H
	mov	QWORD PTR cy$[rsp], rax

; 274  :     }

	jmp	SHORT $LN5@add192
$LN6@add192:

; 275  :     return( 0 );

	xor	eax, eax

; 276  : }

	add	rsp, 16
	pop	rdi
	ret	0
add192	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
_TEXT	SEGMENT
shft$ = 32
bs$ = 36
bs1$ = 40
tv161 = 48
tv180 = 56
res$ = 80
normalize PROC

; 222  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 223  :     int shft;
; 224  :     int bs;
; 225  :     int bs1;
; 226  : 
; 227  :     bs = bitsize64( res->m64[2] ) + 128;

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR res$[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	bitsize64
	add	eax, 128				; 00000080H
	mov	DWORD PTR bs$[rsp], eax

; 228  :     if( bs == 128 ) {

	cmp	DWORD PTR bs$[rsp], 128			; 00000080H
	jne	SHORT $LN2@normalize

; 229  :         res->m64[2] = res->m64[1];

	mov	eax, 8
	imul	rax, rax, 1
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR res$[rsp]
	mov	r8, QWORD PTR res$[rsp]
	mov	rax, QWORD PTR [r8+rax]
	mov	QWORD PTR [rdx+rcx], rax

; 230  :         res->m64[1] = res->m64[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR res$[rsp]
	mov	r8, QWORD PTR res$[rsp]
	mov	rax, QWORD PTR [r8+rax]
	mov	QWORD PTR [rdx+rcx], rax

; 231  :         res->m64[0] = 0;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR res$[rsp]
	mov	QWORD PTR [rcx+rax], 0

; 232  :         bs = bitsize64( res->m64[2] ) + 64;

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR res$[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	bitsize64
	add	eax, 64					; 00000040H
	mov	DWORD PTR bs$[rsp], eax
$LN2@normalize:

; 233  :     }
; 234  :     if( bs == 64 ) {

	cmp	DWORD PTR bs$[rsp], 64			; 00000040H
	jne	SHORT $LN3@normalize

; 235  :         res->m64[2] = res->m64[1];

	mov	eax, 8
	imul	rax, rax, 1
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR res$[rsp]
	mov	r8, QWORD PTR res$[rsp]
	mov	rax, QWORD PTR [r8+rax]
	mov	QWORD PTR [rdx+rcx], rax

; 236  :         res->m64[1] = res->m64[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR res$[rsp]
	mov	r8, QWORD PTR res$[rsp]
	mov	rax, QWORD PTR [r8+rax]
	mov	QWORD PTR [rdx+rcx], rax

; 237  :         res->m64[0] = 0;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR res$[rsp]
	mov	QWORD PTR [rcx+rax], 0

; 238  :         bs = bitsize64( res->m64[2] );

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR res$[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	bitsize64
	mov	DWORD PTR bs$[rsp], eax
$LN3@normalize:

; 239  :     }
; 240  :     if( bs == 0 ) {

	cmp	DWORD PTR bs$[rsp], 0
	jne	SHORT $LN4@normalize

; 241  :         return( 0 );

	xor	eax, eax
	jmp	$LN1@normalize
$LN4@normalize:

; 242  :     }
; 243  :     bs1 = bs % 64;

	mov	eax, DWORD PTR bs$[rsp]
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	and	eax, 63					; 0000003fH
	sub	eax, edx
	mov	DWORD PTR bs1$[rsp], eax

; 244  :     if ( bs1 ) {

	cmp	DWORD PTR bs1$[rsp], 0
	je	$LN5@normalize

; 245  :         shft = 64 - bs1;

	mov	eax, 64					; 00000040H
	sub	eax, DWORD PTR bs1$[rsp]
	mov	DWORD PTR shft$[rsp], eax

; 246  :         res->m64[2] <<= shft;

	mov	eax, 8
	imul	rax, rax, 2
	movsxd	rcx, DWORD PTR shft$[rsp]
	mov	rdx, QWORD PTR res$[rsp]
	mov	rax, QWORD PTR [rdx+rax]
	shl	rax, cl
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR res$[rsp]
	mov	QWORD PTR [rdx+rcx], rax

; 247  :         res->m64[2] |= res->m64[1] >> bs1;

	mov	eax, 8
	imul	rax, rax, 2
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	QWORD PTR tv161[rsp], rcx
	mov	edx, DWORD PTR bs1$[rsp]
	mov	r8, QWORD PTR res$[rsp]
	movzx	ecx, dl
	mov	rdx, QWORD PTR tv161[rsp]
	mov	rdx, QWORD PTR [r8+rdx]
	shr	rdx, cl
	mov	rcx, rdx
	mov	rdx, QWORD PTR res$[rsp]
	mov	rax, QWORD PTR [rdx+rax]
	or	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR res$[rsp]
	mov	QWORD PTR [rdx+rcx], rax

; 248  :         res->m64[1] <<= shft;

	mov	eax, 8
	imul	rax, rax, 1
	movsxd	rcx, DWORD PTR shft$[rsp]
	mov	rdx, QWORD PTR res$[rsp]
	mov	rax, QWORD PTR [rdx+rax]
	shl	rax, cl
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR res$[rsp]
	mov	QWORD PTR [rdx+rcx], rax

; 249  :         res->m64[1] |= res->m64[0] >> bs1;

	mov	eax, 8
	imul	rax, rax, 1
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	QWORD PTR tv180[rsp], rcx
	mov	edx, DWORD PTR bs1$[rsp]
	mov	r8, QWORD PTR res$[rsp]
	movzx	ecx, dl
	mov	rdx, QWORD PTR tv180[rsp]
	mov	rdx, QWORD PTR [r8+rdx]
	shr	rdx, cl
	mov	rcx, rdx
	mov	rdx, QWORD PTR res$[rsp]
	mov	rax, QWORD PTR [rdx+rax]
	or	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR res$[rsp]
	mov	QWORD PTR [rdx+rcx], rax

; 250  :         res->m64[0] <<= shft;

	mov	eax, 8
	imul	rax, rax, 0
	movsxd	rcx, DWORD PTR shft$[rsp]
	mov	rdx, QWORD PTR res$[rsp]
	mov	rax, QWORD PTR [rdx+rax]
	shl	rax, cl
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR res$[rsp]
	mov	QWORD PTR [rdx+rcx], rax
$LN5@normalize:

; 251  :     }
; 252  :     return( bs - 192 );

	mov	eax, DWORD PTR bs$[rsp]
	sub	eax, 192				; 000000c0H
$LN1@normalize:

; 253  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
normalize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
_TEXT	SEGMENT
bs$ = 32
shft$ = 36
tv168 = 40
tv186 = 48
op$ = 80
res$ = 88
U96LD	PROC

; 182  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 183  :     int bs;
; 184  :     int shft;
; 185  : 
; 186  :     memcpy( res, op, sizeof( union u96 ) );

	mov	r8d, 12
	mov	rdx, QWORD PTR op$[rsp]
	mov	rcx, QWORD PTR res$[rsp]
	call	memcpy

; 187  :     bs = bitsize32( res->m32[2] ) + 64;

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR res$[rsp]
	mov	ecx, DWORD PTR [rcx+rax]
	call	bitsize32
	add	eax, 64					; 00000040H
	mov	DWORD PTR bs$[rsp], eax

; 188  :     if( bs == 64 ) {

	cmp	DWORD PTR bs$[rsp], 64			; 00000040H
	jne	SHORT $LN2@U96LD

; 189  :         res->m32[2] = res->m32[1];

	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR res$[rsp]
	mov	r8, QWORD PTR res$[rsp]
	mov	eax, DWORD PTR [r8+rax]
	mov	DWORD PTR [rdx+rcx], eax

; 190  :         res->m32[1] = res->m32[0];

	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR res$[rsp]
	mov	r8, QWORD PTR res$[rsp]
	mov	eax, DWORD PTR [r8+rax]
	mov	DWORD PTR [rdx+rcx], eax

; 191  :         res->m32[0] = 0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR res$[rsp]
	mov	DWORD PTR [rcx+rax], 0

; 192  :         bs = bitsize32( res->m32[2] ) + 32;

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR res$[rsp]
	mov	ecx, DWORD PTR [rcx+rax]
	call	bitsize32
	add	eax, 32					; 00000020H
	mov	DWORD PTR bs$[rsp], eax
$LN2@U96LD:

; 193  :     }
; 194  :     if( bs == 32 ) {

	cmp	DWORD PTR bs$[rsp], 32			; 00000020H
	jne	SHORT $LN3@U96LD

; 195  :         res->m32[2] = res->m32[1];

	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR res$[rsp]
	mov	r8, QWORD PTR res$[rsp]
	mov	eax, DWORD PTR [r8+rax]
	mov	DWORD PTR [rdx+rcx], eax

; 196  :         res->m32[1] = res->m32[0];

	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR res$[rsp]
	mov	r8, QWORD PTR res$[rsp]
	mov	eax, DWORD PTR [r8+rax]
	mov	DWORD PTR [rdx+rcx], eax

; 197  :         res->m32[0] = 0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR res$[rsp]
	mov	DWORD PTR [rcx+rax], 0

; 198  :         bs = bitsize32( res->m32[2] );

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR res$[rsp]
	mov	ecx, DWORD PTR [rcx+rax]
	call	bitsize32
	mov	DWORD PTR bs$[rsp], eax
$LN3@U96LD:

; 199  :     }
; 200  :     if( bs == 0 ) {

	cmp	DWORD PTR bs$[rsp], 0
	jne	SHORT $LN4@U96LD

; 201  :         res->e = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR res$[rsp]
	mov	WORD PTR [rcx+12], ax

; 202  :     } else {

	jmp	$LN5@U96LD
$LN4@U96LD:

; 203  :         res->e = bs - 1 + EXPONENT_BIAS;

	mov	eax, DWORD PTR bs$[rsp]
	add	eax, 16382				; 00003ffeH
	mov	rcx, QWORD PTR res$[rsp]
	mov	WORD PTR [rcx+12], ax

; 204  :         bs %= 32;

	mov	eax, DWORD PTR bs$[rsp]
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	mov	DWORD PTR bs$[rsp], eax

; 205  :         if( bs ) {

	cmp	DWORD PTR bs$[rsp], 0
	je	$LN6@U96LD

; 206  :             shft = 32 - bs;

	mov	eax, 32					; 00000020H
	sub	eax, DWORD PTR bs$[rsp]
	mov	DWORD PTR shft$[rsp], eax

; 207  :             res->m32[2] <<= shft;

	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, DWORD PTR shft$[rsp]
	mov	rdx, QWORD PTR res$[rsp]
	mov	eax, DWORD PTR [rdx+rax]
	shl	eax, cl
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR res$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 208  :             res->m32[2] |= res->m32[1] >> bs;

	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	QWORD PTR tv168[rsp], rcx
	mov	edx, DWORD PTR bs$[rsp]
	mov	r8, QWORD PTR res$[rsp]
	movzx	ecx, dl
	mov	rdx, QWORD PTR tv168[rsp]
	mov	edx, DWORD PTR [r8+rdx]
	shr	edx, cl
	mov	ecx, edx
	mov	rdx, QWORD PTR res$[rsp]
	mov	eax, DWORD PTR [rdx+rax]
	or	eax, ecx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR res$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 209  :             res->m32[1] <<= shft;

	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, DWORD PTR shft$[rsp]
	mov	rdx, QWORD PTR res$[rsp]
	mov	eax, DWORD PTR [rdx+rax]
	shl	eax, cl
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR res$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 210  :             res->m32[1] |= res->m32[0] >> bs;

	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	QWORD PTR tv186[rsp], rcx
	mov	edx, DWORD PTR bs$[rsp]
	mov	r8, QWORD PTR res$[rsp]
	movzx	ecx, dl
	mov	rdx, QWORD PTR tv186[rsp]
	mov	edx, DWORD PTR [r8+rdx]
	shr	edx, cl
	mov	ecx, edx
	mov	rdx, QWORD PTR res$[rsp]
	mov	eax, DWORD PTR [rdx+rax]
	or	eax, ecx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR res$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 211  :             res->m32[0] <<= shft;

	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, DWORD PTR shft$[rsp]
	mov	rdx, QWORD PTR res$[rsp]
	mov	eax, DWORD PTR [rdx+rax]
	shl	eax, cl
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR res$[rsp]
	mov	DWORD PTR [rdx+rcx], eax
$LN6@U96LD:
$LN5@U96LD:

; 212  :         }
; 213  :     }
; 214  :     return( 0 );

	xor	eax, eax

; 215  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
U96LD	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
_TEXT	SEGMENT
i$ = 0
x$ = 32
bitsize64 PROC

; 168  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 169  :     int i;
; 170  : 
; 171  :     for( i = 64; i > 0 ; i-- ) {

	mov	DWORD PTR i$[rsp], 64			; 00000040H
	jmp	SHORT $LN4@bitsize64
$LN2@bitsize64:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@bitsize64:
	cmp	DWORD PTR i$[rsp], 0
	jle	SHORT $LN3@bitsize64

; 172  :         if( x & MAXUI64BIT ) break;

	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, QWORD PTR x$[rsp]
	and	rcx, rax
	mov	rax, rcx
	test	rax, rax
	je	SHORT $LN5@bitsize64
	jmp	SHORT $LN3@bitsize64
$LN5@bitsize64:

; 173  :         x <<= 1;

	mov	rax, QWORD PTR x$[rsp]
	shl	rax, 1
	mov	QWORD PTR x$[rsp], rax

; 174  :     }

	jmp	SHORT $LN2@bitsize64
$LN3@bitsize64:

; 175  :     return( i );

	mov	eax, DWORD PTR i$[rsp]

; 176  : }

	add	rsp, 16
	pop	rdi
	ret	0
bitsize64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
_TEXT	SEGMENT
i$ = 0
x$ = 32
bitsize32 PROC

; 154  : {

	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+32]

; 155  :     int i;
; 156  : 
; 157  :     for( i = 32; i > 0 ; i-- ) {

	mov	DWORD PTR i$[rsp], 32			; 00000020H
	jmp	SHORT $LN4@bitsize32
$LN2@bitsize32:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@bitsize32:
	cmp	DWORD PTR i$[rsp], 0
	jle	SHORT $LN3@bitsize32

; 158  :         if( x & 0x80000000U ) break;

	mov	eax, DWORD PTR x$[rsp]
	and	eax, -2147483648			; 80000000H
	test	eax, eax
	je	SHORT $LN5@bitsize32
	jmp	SHORT $LN3@bitsize32
$LN5@bitsize32:

; 159  :         x <<= 1;

	mov	eax, DWORD PTR x$[rsp]
	shl	eax, 1
	mov	DWORD PTR x$[rsp], eax

; 160  :     }

	jmp	SHORT $LN2@bitsize32
$LN3@bitsize32:

; 161  :     return( i );

	mov	eax, DWORD PTR i$[rsp]

; 162  : }

	add	rsp, 16
	pop	rdi
	ret	0
bitsize32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
_TEXT	SEGMENT
cy$ = 32
i$ = 40
x$ = 64
c$ = 72
add_check_u96_overflow PROC

; 133  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 134  :     uint_64 cy;
; 135  :     int i;
; 136  : 
; 137  :     if( cmp_u96_max( x ) > 0 ) {

	mov	rcx, QWORD PTR x$[rsp]
	call	cmp_u96_max
	test	eax, eax
	jle	SHORT $LN5@add_check_

; 138  :         return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@add_check_

; 139  :     } else {

	jmp	SHORT $LN6@add_check_
$LN5@add_check_:

; 140  :         cy = c;

	mov	eax, DWORD PTR c$[rsp]
	mov	QWORD PTR cy$[rsp], rax

; 141  :         for( i = 0; i < 3; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@add_check_
$LN2@add_check_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@add_check_:
	cmp	DWORD PTR i$[rsp], 3
	jge	SHORT $LN3@add_check_

; 142  :             cy += (uint_64)x->m32[i] * 10;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR x$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4]
	imul	rax, rax, 10
	mov	rcx, QWORD PTR cy$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cy$[rsp], rax

; 143  :             x->m32[i] = cy;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR x$[rsp]
	mov	edx, DWORD PTR cy$[rsp]
	mov	DWORD PTR [rcx+rax*4], edx

; 144  :             cy >>= 32;

	mov	rax, QWORD PTR cy$[rsp]
	shr	rax, 32					; 00000020H
	mov	QWORD PTR cy$[rsp], rax

; 145  :         }

	jmp	SHORT $LN2@add_check_
$LN3@add_check_:

; 146  :         return( 0 );

	xor	eax, eax
$LN6@add_check_:
$LN1@add_check_:

; 147  :     }
; 148  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
add_check_u96_overflow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
_TEXT	SEGMENT
x$ = 16
cmp_u96_max PROC

; 110  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 111  :     if( x->m32[2] > 0x19999999UL ) {

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR x$[rsp]
	cmp	DWORD PTR [rcx+rax], 429496729		; 19999999H
	jbe	SHORT $LN2@cmp_u96_ma

; 112  :         return( 1 );

	mov	eax, 1
	jmp	$LN1@cmp_u96_ma
	jmp	$LN3@cmp_u96_ma
$LN2@cmp_u96_ma:

; 113  :     } else if( x->m32[2] < 0x19999999UL ) {

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR x$[rsp]
	cmp	DWORD PTR [rcx+rax], 429496729		; 19999999H
	jae	SHORT $LN4@cmp_u96_ma

; 114  :         return( -1 );

	mov	eax, -1
	jmp	$LN1@cmp_u96_ma
	jmp	$LN5@cmp_u96_ma
$LN4@cmp_u96_ma:

; 115  :     } else if( x->m32[1] > 0x99999999UL ) {

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR x$[rsp]
	cmp	DWORD PTR [rcx+rax], -1717986919	; 99999999H
	jbe	SHORT $LN6@cmp_u96_ma

; 116  :         return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@cmp_u96_ma
	jmp	SHORT $LN7@cmp_u96_ma
$LN6@cmp_u96_ma:

; 117  :     } else if( x->m32[1] < 0x99999999UL ) {

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR x$[rsp]
	cmp	DWORD PTR [rcx+rax], -1717986919	; 99999999H
	jae	SHORT $LN8@cmp_u96_ma

; 118  :         return( -1 );

	mov	eax, -1
	jmp	SHORT $LN1@cmp_u96_ma
	jmp	SHORT $LN9@cmp_u96_ma
$LN8@cmp_u96_ma:

; 119  :     } else if( x->m32[0] > 0x99999998UL ) {

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR x$[rsp]
	cmp	DWORD PTR [rcx+rax], -1717986920	; 99999998H
	jbe	SHORT $LN10@cmp_u96_ma

; 120  :         return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@cmp_u96_ma
	jmp	SHORT $LN11@cmp_u96_ma
$LN10@cmp_u96_ma:

; 121  :     } else if( x->m32[0] < 0x99999998UL ) {

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR x$[rsp]
	cmp	DWORD PTR [rcx+rax], -1717986920	; 99999998H
	jae	SHORT $LN12@cmp_u96_ma

; 122  :         return( -1 );

	mov	eax, -1
	jmp	SHORT $LN1@cmp_u96_ma

; 123  :     } else {

	jmp	SHORT $LN13@cmp_u96_ma
$LN12@cmp_u96_ma:

; 124  :         return( 0 );

	xor	eax, eax
$LN13@cmp_u96_ma:
$LN11@cmp_u96_ma:
$LN9@cmp_u96_ma:
$LN7@cmp_u96_ma:
$LN5@cmp_u96_ma:
$LN3@cmp_u96_ma:
$LN1@cmp_u96_ma:

; 125  :     }
; 126  : }

	pop	rdi
	ret	0
cmp_u96_max ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
_TEXT	SEGMENT
sign$ = 32
exp_sign$ = 36
exp_value$ = 40
overflow$ = 44
exp1$ = 48
exponent$ = 52
exponent_tmp$ = 56
value$ = 72
value_tmp$ = 120
tv70 = 160
tv172 = 164
__$ArrayPad$ = 168
p$ = 192
ld$ = 200
negative$ = 208
strtotb	PROC

; 370  : {

$LN40:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 176				; 000000b0H
	mov	rdi, rsp
	mov	ecx, 44					; 0000002cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+192]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 371  :     int              sign = +1;

	mov	DWORD PTR sign$[rsp], 1

; 372  :     int              exp_sign = +1;

	mov	DWORD PTR exp_sign$[rsp], 1
$LN2@strtotb:

; 373  :     int_32           exp_value;
; 374  :     int              overflow;
; 375  :     int_32           exp1;
; 376  :     int_32           exponent;
; 377  :     int_32           exponent_tmp;
; 378  :     union u96        value;
; 379  :     union u96        value_tmp;
; 380  : 
; 381  :     while ( isspace( *p ) ) p++;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN3@strtotb
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN2@strtotb
$LN3@strtotb:

; 382  :     switch (*p) {

	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv70[rsp], al
	cmp	BYTE PTR tv70[rsp], 43			; 0000002bH
	je	SHORT $LN15@strtotb
	cmp	BYTE PTR tv70[rsp], 45			; 0000002dH
	je	SHORT $LN14@strtotb
	jmp	SHORT $LN16@strtotb
$LN14@strtotb:

; 383  :     case '-':
; 384  :         sign = -1;

	mov	DWORD PTR sign$[rsp], -1
$LN15@strtotb:

; 385  :     case '+':
; 386  :         p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN16@strtotb:

; 387  :     default :
; 388  :         break;
; 389  :     }
; 390  :     if( negative ) {

	movsx	eax, BYTE PTR negative$[rsp]
	test	eax, eax
	je	SHORT $LN17@strtotb

; 391  :         sign = -sign;

	mov	eax, DWORD PTR sign$[rsp]
	neg	eax
	mov	DWORD PTR sign$[rsp], eax
$LN17@strtotb:

; 392  :     }
; 393  :     memset( &value, 0, sizeof( value ) );

	mov	r8d, 12
	xor	edx, edx
	lea	rcx, QWORD PTR value$[rsp]
	call	memset

; 394  :     memset( &value_tmp, 0, sizeof( value_tmp ) );

	mov	r8d, 12
	xor	edx, edx
	lea	rcx, QWORD PTR value_tmp$[rsp]
	call	memset

; 395  :     //exponent = 0;
; 396  :     exp1 = 0;

	mov	DWORD PTR exp1$[rsp], 0

; 397  :     exponent_tmp = 0;

	mov	DWORD PTR exponent_tmp$[rsp], 0

; 398  :     overflow = 0;

	mov	DWORD PTR overflow$[rsp], 0
$LN6@strtotb:

; 399  :     while ( (unsigned int)(*p - '0') < 10u ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	cmp	eax, 10
	jae	$LN7@strtotb

; 400  :         if( overflow ) {

	cmp	DWORD PTR overflow$[rsp], 0
	je	SHORT $LN18@strtotb

; 401  :             exponent_tmp++;

	mov	eax, DWORD PTR exponent_tmp$[rsp]
	inc	eax
	mov	DWORD PTR exponent_tmp$[rsp], eax

; 402  :             exp1++;

	mov	eax, DWORD PTR exp1$[rsp]
	inc	eax
	mov	DWORD PTR exp1$[rsp], eax

; 403  :         } else {

	jmp	$LN19@strtotb
$LN18@strtotb:

; 404  :             if( add_check_u96_overflow( &value_tmp, *p - '0' ) ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	edx, eax
	lea	rcx, QWORD PTR value_tmp$[rsp]
	call	add_check_u96_overflow
	test	eax, eax
	je	SHORT $LN20@strtotb

; 405  :                 overflow = 1;

	mov	DWORD PTR overflow$[rsp], 1

; 406  :                 exponent_tmp++;

	mov	eax, DWORD PTR exponent_tmp$[rsp]
	inc	eax
	mov	DWORD PTR exponent_tmp$[rsp], eax

; 407  :                 exp1++;

	mov	eax, DWORD PTR exp1$[rsp]
	inc	eax
	mov	DWORD PTR exp1$[rsp], eax
	jmp	SHORT $LN21@strtotb
$LN20@strtotb:

; 408  :             } else if( *p != '0' ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	je	SHORT $LN22@strtotb

; 409  :                 memcpy( &value, &value_tmp, sizeof( value ) );

	mov	r8d, 12
	lea	rdx, QWORD PTR value_tmp$[rsp]
	lea	rcx, QWORD PTR value$[rsp]
	call	memcpy

; 410  :                 exp1 = 0;

	mov	DWORD PTR exp1$[rsp], 0
	jmp	SHORT $LN23@strtotb
$LN22@strtotb:

; 411  :             } else if( U96ISNOTZERO(value) ) {

	mov	eax, 4
	imul	rax, rax, 0
	cmp	DWORD PTR value$[rsp+rax], 0
	jne	SHORT $LN25@strtotb
	mov	eax, 4
	imul	rax, rax, 1
	cmp	DWORD PTR value$[rsp+rax], 0
	jne	SHORT $LN25@strtotb
	mov	eax, 4
	imul	rax, rax, 2
	cmp	DWORD PTR value$[rsp+rax], 0
	je	SHORT $LN24@strtotb
$LN25@strtotb:

; 412  :                 exp1++;

	mov	eax, DWORD PTR exp1$[rsp]
	inc	eax
	mov	DWORD PTR exp1$[rsp], eax
$LN24@strtotb:
$LN23@strtotb:
$LN21@strtotb:
$LN19@strtotb:

; 413  :             }
; 414  :         }
; 415  :         p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 416  :     }

	jmp	$LN6@strtotb
$LN7@strtotb:

; 417  :     exponent = exp1;

	mov	eax, DWORD PTR exp1$[rsp]
	mov	DWORD PTR exponent$[rsp], eax

; 418  :     if ( *p == '.' ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	jne	$LN26@strtotb

; 419  :         p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN8@strtotb:

; 420  :         while ( (unsigned int)(*p - '0') < 10u ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	cmp	eax, 10
	jae	SHORT $LN9@strtotb

; 421  :             if( overflow == 0 ) {

	cmp	DWORD PTR overflow$[rsp], 0
	jne	SHORT $LN27@strtotb

; 422  :                 if( add_check_u96_overflow( &value_tmp, *p - '0' ) ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	edx, eax
	lea	rcx, QWORD PTR value_tmp$[rsp]
	call	add_check_u96_overflow
	test	eax, eax
	je	SHORT $LN28@strtotb

; 423  :                     overflow = 1;

	mov	DWORD PTR overflow$[rsp], 1

; 424  :                 } else {

	jmp	SHORT $LN29@strtotb
$LN28@strtotb:

; 425  :                     exponent_tmp--;

	mov	eax, DWORD PTR exponent_tmp$[rsp]
	dec	eax
	mov	DWORD PTR exponent_tmp$[rsp], eax

; 426  :                     if( *p != '0' ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	je	SHORT $LN30@strtotb

; 427  :                         memcpy( &value, &value_tmp, sizeof( value ) );

	mov	r8d, 12
	lea	rdx, QWORD PTR value_tmp$[rsp]
	lea	rcx, QWORD PTR value$[rsp]
	call	memcpy

; 428  :                         exponent = exponent_tmp;

	mov	eax, DWORD PTR exponent_tmp$[rsp]
	mov	DWORD PTR exponent$[rsp], eax
$LN30@strtotb:
$LN29@strtotb:
$LN27@strtotb:

; 429  :                     }
; 430  :                 }
; 431  :             }
; 432  :             p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 433  :         }

	jmp	$LN8@strtotb
$LN9@strtotb:
$LN26@strtotb:

; 434  :     }
; 435  :     exp_value   = 0;

	mov	DWORD PTR exp_value$[rsp], 0

; 436  :     if ( (*p | 0x20) == 'e' ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	or	eax, 32					; 00000020H
	cmp	eax, 101				; 00000065H
	jne	$LN31@strtotb

; 437  :         switch ( *++p ) {

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv172[rsp], al
	cmp	BYTE PTR tv172[rsp], 43			; 0000002bH
	je	SHORT $LN33@strtotb
	cmp	BYTE PTR tv172[rsp], 45			; 0000002dH
	je	SHORT $LN32@strtotb
	cmp	BYTE PTR tv172[rsp], 47			; 0000002fH
	jle	SHORT $LN35@strtotb
	cmp	BYTE PTR tv172[rsp], 57			; 00000039H
	jle	SHORT $LN34@strtotb
	jmp	SHORT $LN35@strtotb
$LN32@strtotb:

; 438  :         case '-':
; 439  :             exp_sign = -1;

	mov	DWORD PTR exp_sign$[rsp], -1
$LN33@strtotb:

; 440  :         case '+': p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 441  :             break;

	jmp	SHORT $LN10@strtotb
$LN34@strtotb:

; 442  :         case '0':
; 443  :         case '1':
; 444  :         case '2':
; 445  :         case '3':
; 446  :         case '4':
; 447  :         case '5':
; 448  :         case '6':
; 449  :         case '7':
; 450  :         case '8':
; 451  :         case '9':
; 452  :             break;

	jmp	SHORT $LN10@strtotb
$LN35@strtotb:

; 453  :         default :
; 454  :             ld->m = 0;

	mov	rax, QWORD PTR ld$[rsp]
	mov	QWORD PTR [rax], 0

; 455  :             ld->e = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR ld$[rsp]
	mov	WORD PTR [rcx+8], ax

; 456  :             SET_SIGN( ld, sign );

	cmp	DWORD PTR sign$[rsp], 0
	jge	SHORT $LN36@strtotb
	mov	rax, QWORD PTR ld$[rsp]
	movzx	eax, WORD PTR [rax+8]
	bts	eax, 15
	mov	rcx, QWORD PTR ld$[rsp]
	mov	WORD PTR [rcx+8], ax
$LN36@strtotb:

; 457  :             return( ld );

	mov	rax, QWORD PTR ld$[rsp]
	jmp	$LN1@strtotb
$LN10@strtotb:
$LN12@strtotb:

; 458  :         }
; 459  :         while ( (unsigned int)(*p - '0') < 10u )

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	cmp	eax, 10
	jae	SHORT $LN13@strtotb

; 460  :             exp_value = 10 * exp_value + (*p++ - '0');

	imul	eax, DWORD PTR exp_value$[rsp], 10
	mov	rcx, QWORD PTR p$[rsp]
	movsx	ecx, BYTE PTR [rcx]
	lea	eax, DWORD PTR [rax+rcx-48]
	mov	DWORD PTR exp_value$[rsp], eax
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN12@strtotb
$LN13@strtotb:

; 461  :         if( exp_sign < 0 )

	cmp	DWORD PTR exp_sign$[rsp], 0
	jge	SHORT $LN37@strtotb

; 462  :             exp_value = -exp_value;

	mov	eax, DWORD PTR exp_value$[rsp]
	neg	eax
	mov	DWORD PTR exp_value$[rsp], eax
$LN37@strtotb:
$LN31@strtotb:

; 463  :     }
; 464  :     exp_value += exponent;

	mov	eax, DWORD PTR exponent$[rsp]
	mov	ecx, DWORD PTR exp_value$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR exp_value$[rsp], eax

; 465  :     TB_create( &value, exp_value, ld );

	mov	r8, QWORD PTR ld$[rsp]
	mov	edx, DWORD PTR exp_value$[rsp]
	lea	rcx, QWORD PTR value$[rsp]
	call	TB_create

; 466  :     SET_SIGN( ld, sign );

	cmp	DWORD PTR sign$[rsp], 0
	jge	SHORT $LN38@strtotb
	mov	rax, QWORD PTR ld$[rsp]
	movzx	eax, WORD PTR [rax+8]
	bts	eax, 15
	mov	rcx, QWORD PTR ld$[rsp]
	mov	WORD PTR [rcx+8], ax
$LN38@strtotb:

; 467  :     return( ld );

	mov	rax, QWORD PTR ld$[rsp]
$LN1@strtotb:

; 468  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:strtotb$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 176				; 000000b0H
	pop	rdi
	ret	0
strtotb	ENDP
_TEXT	ENDS
END
