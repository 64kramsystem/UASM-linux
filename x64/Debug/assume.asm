; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	szDgroup
_DATA	SEGMENT
COMM	SegAssumeTable:BYTE:060H
COMM	StdAssumeTable:BYTE:0100H
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG11096 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG10969 DB	'SetSegAssumeTable', 0aH, 00H
	ORG $+5
$SG10973 DB	'GetSegAssumeTable', 0aH, 00H
	ORG $+5
$SG10983 DB	'SetStdAssumeTable enter', 0aH, 00H
	ORG $+7
$SG10994 DB	'GetStdAssumeTable', 0aH, 00H
	ORG $+5
$SG11023 DB	'%r %r:%r,%r:%r,%r:%r,%r:%r,%r:%s,%r:%s', 00H
	ORG $+1
$SG11031 DB	'%r %r:%s,%r:%s,%r:%s', 00H
	ORG $+3
$SG11032 DB	'%r %r:%s,%r:%s', 00H
	ORG $+1
$SG11071 DB	'AssumeDirective enter, pass=%u', 0aH, 00H
_DATA	ENDS
CONST	SEGMENT
searchtab DD	03H
	DD	02H
	DD	00H
	DD	04H
	DD	05H
	DD	01H
szError	DB	'ERROR', 00H
	ORG $+2
szNothing DB	'NOTHING', 00H
szDgroup DB	'DGROUP', 00H
CONST	ENDS
PUBLIC	AssumeInit
PUBLIC	search_assume
PUBLIC	GetAssume
PUBLIC	GetOverrideAssume
PUBLIC	GetStdAssume
PUBLIC	GetStdAssumeEx
PUBLIC	ModelAssumeInit
PUBLIC	SetSegAssumeTable
PUBLIC	GetSegAssumeTable
PUBLIC	SetStdAssumeTable
PUBLIC	GetStdAssumeTable
PUBLIC	AssumeSaveState
PUBLIC	AssumeDirective
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	OperandSize:PROC
EXTRN	GetGroup:PROC
EXTRN	SimGetSegName:PROC
EXTRN	CreateTypeSymbol:PROC
EXTRN	GetQualifiedType:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	EvalOperand:PROC
EXTRN	StoreLine:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	_RTC_UninitUse:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SpecialTable:BYTE
EXTRN	UseSavedState:BYTE
_BSS	SEGMENT
	ALIGN	8

stdsym	DQ	010H DUP (?)
saved_SegAssumeTable DB 060H DUP (?)
saved_StdAssumeTable DB 0100H DUP (?)
saved_StdTypeInfo DB 0180H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$AssumeInit DD imagerel $LN12
	DD	imagerel $LN12+286
	DD	imagerel $unwind$AssumeInit
$pdata$search_assume DD imagerel $LN19
	DD	imagerel $LN19+497
	DD	imagerel $unwind$search_assume
$pdata$GetAssume DD imagerel $LN11
	DD	imagerel $LN11+288
	DD	imagerel $unwind$GetAssume
$pdata$GetOverrideAssume DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$GetOverrideAssume
$pdata$GetStdAssume DD imagerel $LN6
	DD	imagerel $LN6+115
	DD	imagerel $unwind$GetStdAssume
$pdata$GetStdAssumeEx DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$GetStdAssumeEx
$pdata$ModelAssumeInit DD imagerel $LN14
	DD	imagerel $LN14+429
	DD	imagerel $unwind$ModelAssumeInit
$pdata$SetSegAssumeTable DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$SetSegAssumeTable
$pdata$GetSegAssumeTable DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$GetSegAssumeTable
$pdata$SetStdAssumeTable DD imagerel $LN7
	DD	imagerel $LN7+313
	DD	imagerel $unwind$SetStdAssumeTable
$pdata$GetStdAssumeTable DD imagerel $LN7
	DD	imagerel $LN7+313
	DD	imagerel $unwind$GetStdAssumeTable
$pdata$AssumeSaveState DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$AssumeSaveState
$pdata$AssumeDirective DD imagerel $LN94
	DD	imagerel $LN94+3057
	DD	imagerel $unwind$AssumeDirective
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
	ORG $+1
AssumeDirective$rtcName$0 DB 072H
	DB	065H
	DB	067H
	DB	00H
AssumeDirective$rtcName$1 DB 066H
	DB	06cH
	DB	061H
	DB	067H
	DB	073H
	DB	00H
	ORG $+2
AssumeDirective$rtcName$2 DB 06aH
	DB	00H
	ORG $+2
AssumeDirective$rtcName$3 DB 073H
	DB	065H
	DB	067H
	DB	074H
	DB	061H
	DB	062H
	DB	06cH
	DB	065H
	DB	00H
	ORG $+3
AssumeDirective$rtcName$4 DB 074H
	DB	069H
	DB	00H
	ORG $+1
AssumeDirective$rtcName$5 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	00H
	ORG $+3
AssumeDirective$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:AssumeDirective$rtcVarDesc
	ORG $+8
AssumeDirective$rtcVarDesc DD 0a0H
	DD	068H
	DQ	FLAT:AssumeDirective$rtcName$5
	DD	058H
	DD	020H
	DQ	FLAT:AssumeDirective$rtcName$4
CONST	ENDS
xdata	SEGMENT
$unwind$AssumeInit DD 021c01H
	DD	070055209H
$unwind$search_assume DD 022701H
	DD	0700f5213H
$unwind$GetAssume DD 022d01H
	DD	070155219H
$unwind$GetOverrideAssume DD 010501H
	DD	07005H
$unwind$GetStdAssume DD 010501H
	DD	07005H
$unwind$GetStdAssumeEx DD 010501H
	DD	07005H
$unwind$ModelAssumeInit DD 031801H
	DD	0140109H
	DD	07002H
$unwind$SetSegAssumeTable DD 021e01H
	DD	07006320aH
$unwind$GetSegAssumeTable DD 021e01H
	DD	07006320aH
$unwind$SetStdAssumeTable DD 022301H
	DD	0700b520fH
$unwind$GetStdAssumeTable DD 022301H
	DD	0700b520fH
$unwind$AssumeSaveState DD 021501H
	DD	070023206H
$unwind$AssumeDirective DD 032701H
	DD	0260111H
	DD	0700aH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
reg$ = 48
j$ = 52
size$ = 56
flags$ = 60
info$ = 64
segtable$ = 72
ti$ = 88
opnd$9 = 160
$T10 = 276
$T11 = 277
$T12 = 278
$T13 = 279
tv198 = 280
tv221 = 284
tv252 = 288
tv325 = 292
tv386 = 296
i$ = 320
tokenarray$ = 328
AssumeDirective PROC

; 286  : {

$LN94:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 304				; 00000130H
	mov	rdi, rsp
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+320]
	mov	BYTE PTR $T10[rsp], 0
	mov	BYTE PTR $T11[rsp], 0
	mov	BYTE PTR $T13[rsp], 0
	mov	BYTE PTR $T12[rsp], 0

; 287  :     int             reg;
; 288  :     int             j;
; 289  :     int             size;
; 290  :     uint_32         flags;
; 291  :     struct assume_info *info;
; 292  :     bool            segtable;
; 293  :     struct qualified_type ti;
; 294  : 
; 295  :     DebugMsg1(( "AssumeDirective enter, pass=%u\n", Parse_Pass+1 ));

	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11071
	call	DoDebugMsg1

; 296  : 
; 297  :     for( i++; i < Token_Count; i++ ) {

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN4@AssumeDire
$LN2@AssumeDire:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@AssumeDire:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@AssumeDire

; 298  : 
; 299  :         if( ( tokenarray[i].token == T_ID )
; 300  :             && (0 == _stricmp( tokenarray[i].string_ptr, szNothing )) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN7@AssumeDire
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:szNothing
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN7@AssumeDire

; 301  :             AssumeInit( -1 );

	mov	ecx, -1
	call	AssumeInit

; 302  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 303  :             break;

	jmp	$LN3@AssumeDire
$LN7@AssumeDire:

; 304  :         }
; 305  : 
; 306  :         /*---- get the info ptr for the register ----*/
; 307  : 
; 308  :         info = NULL;

	mov	QWORD PTR info$[rsp], 0

; 309  :         if ( tokenarray[i].token == T_REG ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	jne	$LN8@AssumeDire

; 310  :             reg = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	BYTE PTR $T10[rsp], 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR reg$[rsp], eax

; 311  :             j = GetRegNo( reg );

	cmp	BYTE PTR $T10[rsp], 0
	jne	SHORT $LN61@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$0
	call	_RTC_UninitUse
$LN61@AssumeDire:
	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR $T11[rsp], 1
	mov	DWORD PTR j$[rsp], eax

; 312  :             flags = GetValueSp( reg );

	cmp	BYTE PTR $T10[rsp], 0
	jne	SHORT $LN62@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$0
	call	_RTC_UninitUse
$LN62@AssumeDire:
	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	BYTE PTR $T12[rsp], 1
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR flags$[rsp], eax

; 313  :             if ( flags & OP_SR ) {

	cmp	BYTE PTR $T12[rsp], 0
	jne	SHORT $LN63@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$1
	call	_RTC_UninitUse
$LN63@AssumeDire:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 24576				; 00006000H
	test	eax, eax
	je	SHORT $LN9@AssumeDire

; 314  :                 info = &SegAssumeTable[j];

	cmp	BYTE PTR $T11[rsp], 0
	jne	SHORT $LN64@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$2
	call	_RTC_UninitUse
$LN64@AssumeDire:
	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR info$[rsp], rax

; 315  :                 segtable = TRUE;

	mov	BYTE PTR $T13[rsp], 1
	mov	BYTE PTR segtable$[rsp], 1
	jmp	SHORT $LN10@AssumeDire
$LN9@AssumeDire:

; 316  :             } else if ( flags & OP_R ) {

	cmp	BYTE PTR $T12[rsp], 0
	jne	SHORT $LN65@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$1
	call	_RTC_UninitUse
$LN65@AssumeDire:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 15
	test	eax, eax
	je	SHORT $LN11@AssumeDire

; 317  :                 info = &StdAssumeTable[j];

	cmp	BYTE PTR $T11[rsp], 0
	jne	SHORT $LN66@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$2
	call	_RTC_UninitUse
$LN66@AssumeDire:
	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR info$[rsp], rax

; 318  :                 segtable = FALSE;

	mov	BYTE PTR $T13[rsp], 1
	mov	BYTE PTR segtable$[rsp], 0
$LN11@AssumeDire:
$LN10@AssumeDire:
$LN8@AssumeDire:

; 319  :             }
; 320  :         }
; 321  :         if ( info == NULL ) {

	cmp	QWORD PTR info$[rsp], 0
	jne	SHORT $LN12@AssumeDire

; 322  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@AssumeDire
$LN12@AssumeDire:

; 323  :         }
; 324  : 
; 325  :         if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < GetCpuSp( reg ) ) {

	cmp	BYTE PTR $T10[rsp], 0
	jne	SHORT $LN67@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$0
	call	_RTC_UninitUse
$LN67@AssumeDire:
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	movsxd	rcx, DWORD PTR reg$[rsp]
	imul	rcx, rcx, 12
	lea	rdx, OFFSET FLAT:SpecialTable
	movzx	ecx, WORD PTR [rdx+rcx+8]
	cmp	eax, ecx
	jge	SHORT $LN13@AssumeDire

; 326  :             return( EmitError( INSTRUCTION_OR_REGISTER_NOT_ACCEPTED_IN_CURRENT_CPU_MODE ) );

	mov	ecx, 30
	call	EmitError
	jmp	$LN1@AssumeDire
$LN13@AssumeDire:

; 327  :         }
; 328  : 
; 329  :         i++; /* go past register */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 330  : 
; 331  :         if( tokenarray[i].token != T_COLON ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN14@AssumeDire

; 332  :             return( EmitError( COLON_EXPECTED ) );

	mov	ecx, 84					; 00000054H
	call	EmitError
	jmp	$LN1@AssumeDire
$LN14@AssumeDire:

; 333  :         }
; 334  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 335  : 
; 336  :         if( tokenarray[i].token == T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN15@AssumeDire

; 337  :             return( EmitError( SYNTAX_ERROR ) );

	mov	ecx, 45					; 0000002dH
	call	EmitError
	jmp	$LN1@AssumeDire
$LN15@AssumeDire:

; 338  :         }
; 339  : 
; 340  :         /* check for ERROR and NOTHING */
; 341  : 
; 342  :         if( 0 == _stricmp( tokenarray[i].string_ptr, szError )) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:szError
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	$LN16@AssumeDire

; 343  :             if ( segtable ) {

	cmp	BYTE PTR $T13[rsp], 0
	jne	SHORT $LN68@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$3
	call	_RTC_UninitUse
$LN68@AssumeDire:
	movzx	eax, BYTE PTR segtable$[rsp]
	test	eax, eax
	je	SHORT $LN18@AssumeDire

; 344  :                 info->is_flat = FALSE;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+9], 0

; 345  :                 info->error = TRUE;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+8], 1

; 346  :             } else

	jmp	$LN19@AssumeDire
$LN18@AssumeDire:

; 347  :                 info->error |= (( reg >= T_AH && reg <= T_BH ) ? RH_ERROR : ( flags & OP_R ));

	cmp	BYTE PTR $T10[rsp], 0
	jne	SHORT $LN69@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$0
	call	_RTC_UninitUse
$LN69@AssumeDire:
	cmp	DWORD PTR reg$[rsp], 5
	jl	SHORT $LN53@AssumeDire
	cmp	BYTE PTR $T10[rsp], 0
	jne	SHORT $LN70@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$0
	call	_RTC_UninitUse
$LN70@AssumeDire:
	cmp	DWORD PTR reg$[rsp], 8
	jg	SHORT $LN53@AssumeDire
	mov	DWORD PTR tv198[rsp], 16
	jmp	SHORT $LN54@AssumeDire
$LN53@AssumeDire:
	cmp	BYTE PTR $T12[rsp], 0
	jne	SHORT $LN71@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$1
	call	_RTC_UninitUse
$LN71@AssumeDire:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 15
	mov	DWORD PTR tv198[rsp], eax
$LN54@AssumeDire:
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	or	eax, DWORD PTR tv198[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+8], al
$LN19@AssumeDire:

; 348  :             info->symbol = NULL;

	mov	rax, QWORD PTR info$[rsp]
	mov	QWORD PTR [rax], 0

; 349  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	$LN17@AssumeDire
$LN16@AssumeDire:

; 350  :         } else if( 0 == _stricmp( tokenarray[i].string_ptr, szNothing )) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:szNothing
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	$LN20@AssumeDire

; 351  :             if ( segtable ) {

	cmp	BYTE PTR $T13[rsp], 0
	jne	SHORT $LN72@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$3
	call	_RTC_UninitUse
$LN72@AssumeDire:
	movzx	eax, BYTE PTR segtable$[rsp]
	test	eax, eax
	je	SHORT $LN22@AssumeDire

; 352  :                 info->is_flat = FALSE;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+9], 0

; 353  :                 info->error = FALSE;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+8], 0

; 354  :             } else

	jmp	$LN23@AssumeDire
$LN22@AssumeDire:

; 355  :                 info->error &= ~(( reg >= T_AH && reg <= T_BH ) ? RH_ERROR : ( flags & OP_R ));

	cmp	BYTE PTR $T10[rsp], 0
	jne	SHORT $LN73@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$0
	call	_RTC_UninitUse
$LN73@AssumeDire:
	cmp	DWORD PTR reg$[rsp], 5
	jl	SHORT $LN55@AssumeDire
	cmp	BYTE PTR $T10[rsp], 0
	jne	SHORT $LN74@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$0
	call	_RTC_UninitUse
$LN74@AssumeDire:
	cmp	DWORD PTR reg$[rsp], 8
	jg	SHORT $LN55@AssumeDire
	mov	DWORD PTR tv221[rsp], 16
	jmp	SHORT $LN56@AssumeDire
$LN55@AssumeDire:
	cmp	BYTE PTR $T12[rsp], 0
	jne	SHORT $LN75@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$1
	call	_RTC_UninitUse
$LN75@AssumeDire:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 15
	mov	DWORD PTR tv221[rsp], eax
$LN56@AssumeDire:
	mov	eax, DWORD PTR tv221[rsp]
	not	eax
	mov	rcx, QWORD PTR info$[rsp]
	movzx	ecx, BYTE PTR [rcx+8]
	and	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+8], al
$LN23@AssumeDire:

; 356  :             info->symbol = NULL;

	mov	rax, QWORD PTR info$[rsp]
	mov	QWORD PTR [rax], 0

; 357  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	$LN21@AssumeDire
$LN20@AssumeDire:

; 358  :         } else if ( segtable == FALSE ) {

	cmp	BYTE PTR $T13[rsp], 0
	jne	SHORT $LN76@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$3
	call	_RTC_UninitUse
$LN76@AssumeDire:
	movzx	eax, BYTE PTR segtable$[rsp]
	test	eax, eax
	jne	$LN24@AssumeDire

; 359  : 
; 360  :             /* v2.05: changed to use new GetQualifiedType() function */
; 361  :             ti.size = 0;

	mov	DWORD PTR ti$[rsp], 0

; 362  :             ti.is_ptr = 0;

	mov	BYTE PTR ti$[rsp+20], 0

; 363  :             ti.is_far = FALSE;

	mov	BYTE PTR ti$[rsp+21], 0

; 364  :             ti.mem_type = MT_EMPTY;

	mov	DWORD PTR ti$[rsp+16], 192		; 000000c0H

; 365  :             ti.ptr_memtype = MT_EMPTY;

	mov	DWORD PTR ti$[rsp+24], 192		; 000000c0H

; 366  :             ti.symtype = NULL;

	mov	QWORD PTR ti$[rsp+8], 0

; 367  :             ti.Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	BYTE PTR ti$[rsp+22], al

; 368  :             if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	GetQualifiedType
	cmp	eax, -1
	jne	SHORT $LN26@AssumeDire

; 369  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@AssumeDire
$LN26@AssumeDire:

; 370  : 
; 371  :             /* v2.04: check size of argument! */
; 372  :             size = OperandSize( flags, NULL );

	cmp	BYTE PTR $T12[rsp], 0
	jne	SHORT $LN77@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$1
	call	_RTC_UninitUse
$LN77@AssumeDire:
	xor	edx, edx
	mov	ecx, DWORD PTR flags$[rsp]
	call	OperandSize
	mov	DWORD PTR size$[rsp], eax

; 373  :             if ( ( ti.is_ptr == 0 && size != ti.size ) ||

	movzx	eax, BYTE PTR ti$[rsp+20]
	test	eax, eax
	jne	SHORT $LN29@AssumeDire
	mov	eax, DWORD PTR ti$[rsp]
	cmp	DWORD PTR size$[rsp], eax
	jne	SHORT $LN28@AssumeDire
$LN29@AssumeDire:
	movzx	eax, BYTE PTR ti$[rsp+20]
	test	eax, eax
	jle	SHORT $LN27@AssumeDire
	movzx	eax, BYTE PTR ModuleInfo+406
	cmp	DWORD PTR size$[rsp], eax
	jge	SHORT $LN27@AssumeDire
$LN28@AssumeDire:

; 374  :                 ( ti.is_ptr > 0 && size < CurrWordSize ) ) {
; 375  :                 return( EmitError( TYPE_IS_WRONG_SIZE_FOR_REGISTER ) );

	mov	ecx, 247				; 000000f7H
	call	EmitError
	jmp	$LN1@AssumeDire
$LN27@AssumeDire:

; 376  :             }
; 377  :             info->error &= ~(( reg >= T_AH && reg <= T_BH ) ? RH_ERROR : ( flags & OP_R ));

	cmp	BYTE PTR $T10[rsp], 0
	jne	SHORT $LN78@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$0
	call	_RTC_UninitUse
$LN78@AssumeDire:
	cmp	DWORD PTR reg$[rsp], 5
	jl	SHORT $LN57@AssumeDire
	cmp	BYTE PTR $T10[rsp], 0
	jne	SHORT $LN79@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$0
	call	_RTC_UninitUse
$LN79@AssumeDire:
	cmp	DWORD PTR reg$[rsp], 8
	jg	SHORT $LN57@AssumeDire
	mov	DWORD PTR tv252[rsp], 16
	jmp	SHORT $LN58@AssumeDire
$LN57@AssumeDire:
	cmp	BYTE PTR $T12[rsp], 0
	jne	SHORT $LN80@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$1
	call	_RTC_UninitUse
$LN80@AssumeDire:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 15
	mov	DWORD PTR tv252[rsp], eax
$LN58@AssumeDire:
	mov	eax, DWORD PTR tv252[rsp]
	not	eax
	mov	rcx, QWORD PTR info$[rsp]
	movzx	ecx, BYTE PTR [rcx+8]
	and	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+8], al

; 378  :             if ( stdsym[j] == NULL ) {

	cmp	BYTE PTR $T11[rsp], 0
	jne	SHORT $LN81@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$2
	call	_RTC_UninitUse
$LN81@AssumeDire:
	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	cmp	QWORD PTR [rcx+rax*8], 0
	jne	SHORT $LN30@AssumeDire

; 379  :                 stdsym[j] = CreateTypeSymbol( NULL, "", FALSE );

	cmp	BYTE PTR $T11[rsp], 0
	jne	SHORT $LN82@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$2
	call	_RTC_UninitUse
$LN82@AssumeDire:
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:$SG11096
	xor	ecx, ecx
	call	CreateTypeSymbol
	movsxd	rcx, DWORD PTR j$[rsp]
	lea	rdx, OFFSET FLAT:stdsym
	mov	QWORD PTR [rdx+rcx*8], rax

; 380  :                 stdsym[j]->typekind = TYPE_TYPEDEF;

	cmp	BYTE PTR $T11[rsp], 0
	jne	SHORT $LN83@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$2
	call	_RTC_UninitUse
$LN83@AssumeDire:
	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	BYTE PTR [rax+66], 3
$LN30@AssumeDire:

; 381  :             }
; 382  : 
; 383  :             stdsym[j]->total_size = ti.size;

	cmp	BYTE PTR $T11[rsp], 0
	jne	SHORT $LN84@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$2
	call	_RTC_UninitUse
$LN84@AssumeDire:
	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	ecx, DWORD PTR ti$[rsp]
	mov	DWORD PTR [rax+56], ecx

; 384  :             stdsym[j]->mem_type   = ti.mem_type;

	cmp	BYTE PTR $T11[rsp], 0
	jne	SHORT $LN85@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$2
	call	_RTC_UninitUse
$LN85@AssumeDire:
	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	ecx, DWORD PTR ti$[rsp+16]
	mov	DWORD PTR [rax+36], ecx

; 385  :             stdsym[j]->is_ptr     = ti.is_ptr;

	cmp	BYTE PTR $T11[rsp], 0
	jne	SHORT $LN86@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$2
	call	_RTC_UninitUse
$LN86@AssumeDire:
	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	ecx, BYTE PTR ti$[rsp+20]
	mov	BYTE PTR [rax+45], cl

; 386  :             stdsym[j]->isfar      = ti.is_far;

	cmp	BYTE PTR $T11[rsp], 0
	jne	SHORT $LN87@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$2
	call	_RTC_UninitUse
$LN87@AssumeDire:
	cmp	BYTE PTR $T11[rsp], 0
	jne	SHORT $LN88@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$2
	call	_RTC_UninitUse
$LN88@AssumeDire:
	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	ecx, BYTE PTR ti$[rsp+21]
	and	cl, 1
	shl	cl, 4
	movzx	eax, BYTE PTR [rax+47]
	and	al, 239					; 000000efH
	or	al, cl
	movsxd	rcx, DWORD PTR j$[rsp]
	lea	rdx, OFFSET FLAT:stdsym
	mov	rcx, QWORD PTR [rdx+rcx*8]
	mov	BYTE PTR [rcx+47], al

; 387  :             stdsym[j]->Ofssize    = ti.Ofssize;

	cmp	BYTE PTR $T11[rsp], 0
	jne	SHORT $LN89@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$2
	call	_RTC_UninitUse
$LN89@AssumeDire:
	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	ecx, BYTE PTR ti$[rsp+22]
	mov	BYTE PTR [rax+44], cl

; 388  :             stdsym[j]->ptr_memtype = ti.ptr_memtype; /* added v2.05 rc13 */

	cmp	BYTE PTR $T11[rsp], 0
	jne	SHORT $LN90@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$2
	call	_RTC_UninitUse
$LN90@AssumeDire:
	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	ecx, BYTE PTR ti$[rsp+24]
	mov	BYTE PTR [rax+46], cl

; 389  :             if ( ti.mem_type == MT_TYPE )

	cmp	DWORD PTR ti$[rsp+16], 196		; 000000c4H
	jne	SHORT $LN31@AssumeDire

; 390  :                 stdsym[j]->type = ti.symtype;

	cmp	BYTE PTR $T11[rsp], 0
	jne	SHORT $LN91@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$2
	call	_RTC_UninitUse
$LN91@AssumeDire:
	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rax+80], rcx
	jmp	SHORT $LN32@AssumeDire
$LN31@AssumeDire:

; 391  :             else
; 392  :                 stdsym[j]->target_type = ti.symtype;

	cmp	BYTE PTR $T11[rsp], 0
	jne	SHORT $LN92@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$2
	call	_RTC_UninitUse
$LN92@AssumeDire:
	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rax+48], rcx
$LN32@AssumeDire:

; 393  : 
; 394  :             info->symbol = stdsym[j];

	cmp	BYTE PTR $T11[rsp], 0
	jne	SHORT $LN93@AssumeDire
	lea	rcx, OFFSET FLAT:AssumeDirective$rtcName$2
	call	_RTC_UninitUse
$LN93@AssumeDire:
	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rdx, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR [rdx], rax

; 395  : 
; 396  :         } else { /* segment register */

	jmp	$LN25@AssumeDire
$LN24@AssumeDire:

; 397  :             struct expr opnd;
; 398  : 
; 399  :             /* v2.08: read expression with standard evaluator */
; 400  :             if( EvalOperand( &i, tokenarray, Token_Count, &opnd, 0 ) == ERROR )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opnd$9[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN33@AssumeDire

; 401  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@AssumeDire
$LN33@AssumeDire:

; 402  :             switch ( opnd.kind ) {

	mov	eax, DWORD PTR opnd$9[rsp+60]
	mov	DWORD PTR tv325[rsp], eax
	cmp	DWORD PTR tv325[rsp], 1
	je	SHORT $LN34@AssumeDire
	cmp	DWORD PTR tv325[rsp], 2
	je	$LN47@AssumeDire
	jmp	$LN49@AssumeDire
$LN34@AssumeDire:

; 403  :             case EXPR_ADDR:
; 404  :                 if ( opnd.sym == NULL || opnd.indirect == TRUE || opnd.value ) {

	cmp	QWORD PTR opnd$9[rsp+80], 0
	je	SHORT $LN37@AssumeDire
	mov	eax, DWORD PTR opnd$9[rsp+76]
	and	eax, 1
	cmp	eax, 1
	je	SHORT $LN37@AssumeDire
	cmp	DWORD PTR opnd$9[rsp], 0
	je	SHORT $LN35@AssumeDire
$LN37@AssumeDire:

; 405  :                     return( EmitError( SEGMENT_GROUP_OR_SEGREG_EXPECTED ) );

	mov	ecx, 69					; 00000045H
	call	EmitError
	jmp	$LN1@AssumeDire
	jmp	$LN36@AssumeDire
$LN35@AssumeDire:

; 406  :                 } else if ( opnd.sym->state == SYM_UNDEFINED ) {

	mov	rax, QWORD PTR opnd$9[rsp+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN38@AssumeDire

; 407  :                     /* ensure that directive is rerun in pass 2
; 408  :                      * so an error msg can be emitted.
; 409  :                      */
; 410  :                     FStoreLine( 0 );

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN40@AssumeDire
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR ModuleInfo+464
	call	StoreLine
$LN40@AssumeDire:

; 411  :                     info->symbol = opnd.sym;

	mov	rax, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR opnd$9[rsp+80]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN39@AssumeDire
$LN38@AssumeDire:

; 412  :                 } else if ( ( opnd.sym->state == SYM_SEG || opnd.sym->state == SYM_GRP ) && opnd.instr == EMPTY ) {

	mov	rax, QWORD PTR opnd$9[rsp+80]
	cmp	DWORD PTR [rax+32], 3
	je	SHORT $LN44@AssumeDire
	mov	rax, QWORD PTR opnd$9[rsp+80]
	cmp	DWORD PTR [rax+32], 4
	jne	SHORT $LN42@AssumeDire
$LN44@AssumeDire:
	cmp	DWORD PTR opnd$9[rsp+56], -2
	jne	SHORT $LN42@AssumeDire

; 413  :                     info->symbol = opnd.sym;

	mov	rax, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR opnd$9[rsp+80]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN43@AssumeDire
$LN42@AssumeDire:

; 414  :                 } else if ( opnd.instr == T_SEG ) {

	cmp	DWORD PTR opnd$9[rsp+56], 244		; 000000f4H
	jne	SHORT $LN45@AssumeDire

; 415  :                     info->symbol = opnd.sym->segment;

	mov	rax, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR opnd$9[rsp+80]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax], rcx

; 416  :                 } else {

	jmp	SHORT $LN46@AssumeDire
$LN45@AssumeDire:

; 417  :                     return( EmitError( SEGMENT_GROUP_OR_SEGREG_EXPECTED ) );

	mov	ecx, 69					; 00000045H
	call	EmitError
	jmp	$LN1@AssumeDire
$LN46@AssumeDire:
$LN43@AssumeDire:
$LN39@AssumeDire:
$LN36@AssumeDire:

; 418  :                 }
; 419  :                 info->is_flat = ( info->symbol == &ModuleInfo.flat_grp->sym );

	mov	rax, QWORD PTR ModuleInfo+440
	mov	rcx, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rcx], rax
	jne	SHORT $LN59@AssumeDire
	mov	DWORD PTR tv386[rsp], 1
	jmp	SHORT $LN60@AssumeDire
$LN59@AssumeDire:
	mov	DWORD PTR tv386[rsp], 0
$LN60@AssumeDire:
	mov	rax, QWORD PTR info$[rsp]
	movzx	ecx, BYTE PTR tv386[rsp]
	mov	BYTE PTR [rax+9], cl

; 420  :                 break;

	jmp	$LN5@AssumeDire
$LN47@AssumeDire:

; 421  :             case EXPR_REG:
; 422  :                 if ( GetValueSp( opnd.base_reg->tokval ) & OP_SR ) {

	mov	rax, QWORD PTR opnd$9[rsp+24]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 24576				; 00006000H
	test	eax, eax
	je	SHORT $LN48@AssumeDire

; 423  :                     info->symbol = SegAssumeTable[ GetRegNo( opnd.base_reg->tokval ) ].symbol;

	mov	rax, QWORD PTR opnd$9[rsp+24]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	rdx, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR [rdx], rax

; 424  :                     info->is_flat = SegAssumeTable[ GetRegNo( opnd.base_reg->tokval ) ].is_flat;

	mov	rax, QWORD PTR opnd$9[rsp+24]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	rdx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+9]
	mov	BYTE PTR [rdx+9], al

; 425  :                     break;

	jmp	SHORT $LN5@AssumeDire
$LN48@AssumeDire:
$LN49@AssumeDire:

; 426  :                 }
; 427  :             default:
; 428  :                 return( EmitError( SEGMENT_GROUP_OR_SEGREG_EXPECTED ) );

	mov	ecx, 69					; 00000045H
	call	EmitError
	jmp	SHORT $LN1@AssumeDire
$LN5@AssumeDire:

; 429  :             }
; 430  :             info->error = FALSE;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+8], 0
$LN25@AssumeDire:
$LN21@AssumeDire:
$LN17@AssumeDire:

; 431  :         }
; 432  : 
; 433  :         /* comma expected */
; 434  :         if( i < Token_Count && tokenarray[i].token != T_COMMA )

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN50@AssumeDire
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN50@AssumeDire

; 435  :             break;

	jmp	SHORT $LN3@AssumeDire
$LN50@AssumeDire:

; 436  :     }

	jmp	$LN2@AssumeDire
$LN3@AssumeDire:

; 437  :     if ( i < Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN51@AssumeDire

; 438  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@AssumeDire
$LN51@AssumeDire:

; 439  :     }
; 440  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@AssumeDire:

; 441  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:AssumeDirective$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 304				; 00000130H
	pop	rdi
	ret	0
AssumeDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
AssumeSaveState PROC

; 145  : {

$LN3:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 146  :     GetSegAssumeTable( &saved_SegAssumeTable );

	lea	rcx, OFFSET FLAT:saved_SegAssumeTable
	call	GetSegAssumeTable

; 147  :     GetStdAssumeTable( &saved_StdAssumeTable, saved_StdTypeInfo );

	lea	rdx, OFFSET FLAT:saved_StdTypeInfo
	lea	rcx, OFFSET FLAT:saved_StdAssumeTable
	call	GetStdAssumeTable

; 148  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
AssumeSaveState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
i$ = 32
savedstate$ = 64
ti$ = 72
GetStdAssumeTable PROC

; 127  : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 128  :     int i;
; 129  :     DebugMsg(("GetStdAssumeTable\n" ));

	lea	rcx, OFFSET FLAT:$SG10994
	call	DoDebugMsg

; 130  :     memcpy( savedstate, &StdAssumeTable, sizeof(StdAssumeTable) );

	mov	r8d, 256				; 00000100H
	lea	rdx, OFFSET FLAT:StdAssumeTable
	mov	rcx, QWORD PTR savedstate$[rsp]
	call	memcpy

; 131  :     for ( i = 0; i < NUM_STDREGS; i++, ti++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@GetStdAssu
$LN2@GetStdAssu:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR ti$[rsp]
	add	rax, 24
	mov	QWORD PTR ti$[rsp], rax
$LN4@GetStdAssu:
	cmp	DWORD PTR i$[rsp], 16
	jge	$LN3@GetStdAssu

; 132  :         if ( StdAssumeTable[i].symbol ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	cmp	QWORD PTR [rcx+rax], 0
	je	$LN5@GetStdAssu

; 133  :             ti->type        = StdAssumeTable[i].symbol->type;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR [rcx], rax

; 134  :             ti->target_type = StdAssumeTable[i].symbol->target_type;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR [rcx+8], rax

; 135  :             ti->mem_type    = StdAssumeTable[i].symbol->mem_type;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rcx+16], eax

; 136  :             ti->ptr_memtype = StdAssumeTable[i].symbol->ptr_memtype;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	mov	BYTE PTR [rcx+20], al

; 137  :             ti->is_ptr      = StdAssumeTable[i].symbol->is_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	movzx	eax, BYTE PTR [rax+45]
	mov	BYTE PTR [rcx+21], al
$LN5@GetStdAssu:

; 138  :         }
; 139  :     }

	jmp	$LN2@GetStdAssu
$LN3@GetStdAssu:

; 140  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
GetStdAssumeTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
i$ = 32
savedstate$ = 64
ti$ = 72
SetStdAssumeTable PROC

; 109  : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 110  :     int i;
; 111  : 
; 112  :     DebugMsg(("SetStdAssumeTable enter\n" ));

	lea	rcx, OFFSET FLAT:$SG10983
	call	DoDebugMsg

; 113  :     memcpy( &StdAssumeTable, savedstate, sizeof(StdAssumeTable) );

	mov	r8d, 256				; 00000100H
	mov	rdx, QWORD PTR savedstate$[rsp]
	lea	rcx, OFFSET FLAT:StdAssumeTable
	call	memcpy

; 114  :     for ( i = 0; i < NUM_STDREGS; i++, ti++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@SetStdAssu
$LN2@SetStdAssu:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR ti$[rsp]
	add	rax, 24
	mov	QWORD PTR ti$[rsp], rax
$LN4@SetStdAssu:
	cmp	DWORD PTR i$[rsp], 16
	jge	$LN3@SetStdAssu

; 115  :         if ( StdAssumeTable[i].symbol ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	cmp	QWORD PTR [rcx+rax], 0
	je	$LN5@SetStdAssu

; 116  :             StdAssumeTable[i].symbol->type        = ti->type;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+80], rcx

; 117  :             StdAssumeTable[i].symbol->target_type = ti->target_type;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+48], rcx

; 118  :             StdAssumeTable[i].symbol->mem_type    = ti->mem_type;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax+36], ecx

; 119  :             StdAssumeTable[i].symbol->ptr_memtype = ti->ptr_memtype;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	movzx	ecx, BYTE PTR [rcx+20]
	mov	BYTE PTR [rax+46], cl

; 120  :             StdAssumeTable[i].symbol->is_ptr      = ti->is_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	movzx	ecx, BYTE PTR [rcx+21]
	mov	BYTE PTR [rax+45], cl
$LN5@SetStdAssu:

; 121  :         }
; 122  :     }

	jmp	$LN2@SetStdAssu
$LN3@SetStdAssu:

; 123  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SetStdAssumeTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
savedstate$ = 48
GetSegAssumeTable PROC

; 95   : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 96   :     DebugMsg(("GetSegAssumeTable\n" ));

	lea	rcx, OFFSET FLAT:$SG10973
	call	DoDebugMsg

; 97   :     memcpy( savedstate, &SegAssumeTable, sizeof(SegAssumeTable) );

	mov	r8d, 96					; 00000060H
	lea	rdx, OFFSET FLAT:SegAssumeTable
	mov	rcx, QWORD PTR savedstate$[rsp]
	call	memcpy

; 98   : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
GetSegAssumeTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
savedstate$ = 48
SetSegAssumeTable PROC

; 89   : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 90   :     DebugMsg(("SetSegAssumeTable\n" ));

	lea	rcx, OFFSET FLAT:$SG10969
	call	DoDebugMsg

; 91   :     memcpy( &SegAssumeTable, savedstate, sizeof(SegAssumeTable) );

	mov	r8d, 96					; 00000060H
	mov	rdx, QWORD PTR savedstate$[rsp]
	lea	rcx, OFFSET FLAT:SegAssumeTable
	call	memcpy

; 92   : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetSegAssumeTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
pCS$ = 112
pFSassume$ = 120
pGSassume$ = 128
pFmt$ = 136
tv64 = 144
ModelAssumeInit PROC

; 208  : {

$LN14:
	push	rdi
	sub	rsp, 160				; 000000a0H
	mov	rdi, rsp
	mov	ecx, 40					; 00000028H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 209  :     const char *pCS;
; 210  :     const char *pFSassume = szError;

	lea	rax, OFFSET FLAT:szError
	mov	QWORD PTR pFSassume$[rsp], rax

; 211  :     const char *pGSassume = szError;

	lea	rax, OFFSET FLAT:szError
	mov	QWORD PTR pGSassume$[rsp], rax

; 212  :     const char *pFmt;
; 213  : 
; 214  :     /* Generates codes for assume */
; 215  :     switch( ModuleInfo.model ) {

	mov	eax, DWORD PTR ModuleInfo+360
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 0
	jle	$LN2@ModelAssum
	cmp	DWORD PTR tv64[rsp], 6
	jle	$LN6@ModelAssum
	cmp	DWORD PTR tv64[rsp], 7
	je	SHORT $LN4@ModelAssum
	jmp	$LN2@ModelAssum
$LN4@ModelAssum:

; 216  :     case MODEL_FLAT:
; 217  : #if AMD64_SUPPORT
; 218  :         if ( ModuleInfo.fctype == FCT_WIN64 )

	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN5@ModelAssum

; 219  :             pGSassume = szNothing;

	lea	rax, OFFSET FLAT:szNothing
	mov	QWORD PTR pGSassume$[rsp], rax
$LN5@ModelAssum:

; 220  : #endif
; 221  :         AddLineQueueX( "%r %r:%r,%r:%r,%r:%r,%r:%r,%r:%s,%r:%s",

	mov	rax, QWORD PTR pGSassume$[rsp]
	mov	QWORD PTR [rsp+104], rax
	mov	DWORD PTR [rsp+96], 30
	mov	rax, QWORD PTR pFSassume$[rsp]
	mov	QWORD PTR [rsp+88], rax
	mov	DWORD PTR [rsp+80], 29
	mov	DWORD PTR [rsp+72], 261			; 00000105H
	mov	DWORD PTR [rsp+64], 25
	mov	DWORD PTR [rsp+56], 261			; 00000105H
	mov	DWORD PTR [rsp+48], 27
	mov	DWORD PTR [rsp+40], 261			; 00000105H
	mov	DWORD PTR [rsp+32], 28
	mov	r9d, 261				; 00000105H
	mov	r8d, 26
	mov	edx, 439				; 000001b7H
	lea	rcx, OFFSET FLAT:$SG11023
	call	AddLineQueueX

; 222  :                   T_ASSUME, T_CS, T_FLAT, T_DS, T_FLAT, T_SS, T_FLAT, T_ES, T_FLAT, T_FS, pFSassume, T_GS, pGSassume );
; 223  :         break;

	jmp	$LN2@ModelAssum
$LN6@ModelAssum:

; 224  :     case MODEL_TINY:
; 225  :     case MODEL_SMALL:
; 226  :     case MODEL_COMPACT:
; 227  :     case MODEL_MEDIUM:
; 228  :     case MODEL_LARGE:
; 229  :     case MODEL_HUGE:
; 230  :         /* v2.03: no DGROUP for COFF/ELF */
; 231  : #if COFF_SUPPORT || ELF_SUPPORT
; 232  :         if( Options.output_format == OFORMAT_COFF
; 233  : #if ELF_SUPPORT
; 234  :            || Options.output_format == OFORMAT_ELF

	cmp	DWORD PTR Options+160, 2
	je	SHORT $LN8@ModelAssum
	cmp	DWORD PTR Options+160, 3
	jne	SHORT $LN7@ModelAssum
$LN8@ModelAssum:

; 235  : #endif
; 236  :           )
; 237  :             break;

	jmp	$LN2@ModelAssum
$LN7@ModelAssum:

; 238  : #endif
; 239  :         if ( ModuleInfo.model == MODEL_TINY )

	cmp	DWORD PTR ModuleInfo+360, 1
	jne	SHORT $LN9@ModelAssum

; 240  :             pCS = szDgroup;

	lea	rax, OFFSET FLAT:szDgroup
	mov	QWORD PTR pCS$[rsp], rax
	jmp	SHORT $LN10@ModelAssum
$LN9@ModelAssum:

; 241  :         else
; 242  :             pCS = SimGetSegName( SIM_CODE );

	xor	ecx, ecx
	call	SimGetSegName
	mov	QWORD PTR pCS$[rsp], rax
$LN10@ModelAssum:

; 243  : 
; 244  :         if ( ModuleInfo.distance != STACK_FAR )

	cmp	DWORD PTR ModuleInfo+356, 1
	je	SHORT $LN11@ModelAssum

; 245  :             pFmt = "%r %r:%s,%r:%s,%r:%s";

	lea	rax, OFFSET FLAT:$SG11031
	mov	QWORD PTR pFmt$[rsp], rax
	jmp	SHORT $LN12@ModelAssum
$LN11@ModelAssum:

; 246  :         else
; 247  :             pFmt = "%r %r:%s,%r:%s";

	lea	rax, OFFSET FLAT:$SG11032
	mov	QWORD PTR pFmt$[rsp], rax
$LN12@ModelAssum:

; 248  :         AddLineQueueX( pFmt, T_ASSUME, T_CS, pCS, T_DS, szDgroup, T_SS, szDgroup );

	lea	rax, OFFSET FLAT:szDgroup
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], 27
	lea	rax, OFFSET FLAT:szDgroup
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 28
	mov	r9, QWORD PTR pCS$[rsp]
	mov	r8d, 26
	mov	edx, 439				; 000001b7H
	mov	rcx, QWORD PTR pFmt$[rsp]
	call	AddLineQueueX
$LN2@ModelAssum:

; 249  :         break;
; 250  :     }
; 251  : }

	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
ModelAssumeInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
reg$ = 16
GetStdAssumeEx PROC

; 272  : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	push	rdi

; 273  :     return( StdAssumeTable[reg].symbol );

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]

; 274  : }

	pop	rdi
	ret	0
GetStdAssumeEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
reg$ = 16
GetStdAssume PROC

; 257  : {

$LN6:
	mov	DWORD PTR [rsp+8], ecx
	push	rdi

; 258  :     if ( StdAssumeTable[reg].symbol )

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN2@GetStdAssu

; 259  :         if ( StdAssumeTable[reg].symbol->mem_type == MT_TYPE )

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN3@GetStdAssu

; 260  :             return( StdAssumeTable[reg].symbol->type );

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rax, QWORD PTR [rax+80]
	jmp	SHORT $LN1@GetStdAssu
	jmp	SHORT $LN4@GetStdAssu
$LN3@GetStdAssu:

; 261  :         else
; 262  :             return( StdAssumeTable[reg].symbol->target_type );

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rax, QWORD PTR [rax+48]
	jmp	SHORT $LN1@GetStdAssu
$LN4@GetStdAssu:
$LN2@GetStdAssu:

; 263  :     return ( NULL );

	xor	eax, eax
$LN1@GetStdAssu:

; 264  : }

	pop	rdi
	ret	0
GetStdAssume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
override$ = 16
GetOverrideAssume PROC

; 506  : {

$LN4:
	mov	DWORD PTR [rsp+8], ecx
	push	rdi

; 507  :     if( SegAssumeTable[override].is_flat ) {

	movsxd	rax, DWORD PTR override$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	movzx	eax, BYTE PTR [rcx+rax+9]
	test	eax, eax
	je	SHORT $LN2@GetOverrid

; 508  :         return( (struct asym *)ModuleInfo.flat_grp );

	mov	rax, QWORD PTR ModuleInfo+440
	jmp	SHORT $LN1@GetOverrid
$LN2@GetOverrid:

; 509  :     }
; 510  :     return( SegAssumeTable[override].symbol);

	movsxd	rax, DWORD PTR override$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
$LN1@GetOverrid:

; 511  : 
; 512  : }

	pop	rdi
	ret	0
GetOverrideAssume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
reg$ = 32
override$ = 64
sym$ = 72
def$ = 80
passume$ = 88
GetAssume PROC

; 526  : {

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 527  :     enum assume_segreg  reg;
; 528  : 
; 529  :     if( ( def != ASSUME_NOTHING ) && SegAssumeTable[def].is_flat ) {

	cmp	DWORD PTR def$[rsp], -2
	je	SHORT $LN2@GetAssume
	movsxd	rax, DWORD PTR def$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	movzx	eax, BYTE PTR [rcx+rax+9]
	test	eax, eax
	je	SHORT $LN2@GetAssume

; 530  :         *passume = (struct asym *)ModuleInfo.flat_grp;

	mov	rax, QWORD PTR passume$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+440
	mov	QWORD PTR [rax], rcx

; 531  :         return( def );

	mov	eax, DWORD PTR def$[rsp]
	jmp	$LN1@GetAssume
$LN2@GetAssume:

; 532  :     }
; 533  :     if( override != NULL ) {

	cmp	QWORD PTR override$[rsp], 0
	je	SHORT $LN3@GetAssume

; 534  :         reg = search_assume( override, def, FALSE );

	xor	r8d, r8d
	mov	edx, DWORD PTR def$[rsp]
	mov	rcx, QWORD PTR override$[rsp]
	call	search_assume
	mov	DWORD PTR reg$[rsp], eax
	jmp	SHORT $LN4@GetAssume
$LN3@GetAssume:

; 535  : #if 1 /* v2.10: added */
; 536  :     } else if ( sym->state == SYM_STACK ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 5
	jne	SHORT $LN5@GetAssume

; 537  :         /* stack symbols don't have a segment part.
; 538  :          * In case [R|E]BP is used as base, it doesn't matter.
; 539  :          * However, if option -Zg is set, this isn't true.
; 540  :          */
; 541  :         reg = ASSUME_SS;

	mov	DWORD PTR reg$[rsp], 2

; 542  : #endif
; 543  :     } else {

	jmp	SHORT $LN6@GetAssume
$LN5@GetAssume:

; 544  :         reg = search_assume( sym->segment, def, TRUE );

	mov	r8b, 1
	mov	edx, DWORD PTR def$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	search_assume
	mov	DWORD PTR reg$[rsp], eax
$LN6@GetAssume:
$LN4@GetAssume:

; 545  :     }
; 546  :     if( reg == ASSUME_NOTHING ) {

	cmp	DWORD PTR reg$[rsp], -2
	jne	SHORT $LN7@GetAssume

; 547  :         if( sym && sym->state == SYM_EXTERNAL && sym->segment == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN8@GetAssume
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN8@GetAssume
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN8@GetAssume

; 548  :             reg = def;

	mov	eax, DWORD PTR def$[rsp]
	mov	DWORD PTR reg$[rsp], eax
$LN8@GetAssume:
$LN7@GetAssume:

; 549  :         }
; 550  :     }
; 551  :     if( reg != ASSUME_NOTHING ) {

	cmp	DWORD PTR reg$[rsp], -2
	je	SHORT $LN9@GetAssume

; 552  :         *passume = SegAssumeTable[reg].symbol;

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	rdx, QWORD PTR passume$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR [rdx], rax

; 553  :         return( reg );

	mov	eax, DWORD PTR reg$[rsp]
	jmp	SHORT $LN1@GetAssume
$LN9@GetAssume:

; 554  :     }
; 555  :     *passume = NULL;

	mov	rax, QWORD PTR passume$[rsp]
	mov	QWORD PTR [rax], 0

; 556  :     return( ASSUME_NOTHING );

	mov	eax, -2
$LN1@GetAssume:

; 557  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
GetAssume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
grp$ = 32
sym$ = 64
def$ = 72
search_grps$ = 80
search_assume PROC

; 456  : {

$LN19:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 457  :     struct asym *grp;
; 458  : 
; 459  :     if( sym == NULL )

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN8@search_ass

; 460  :         return( ASSUME_NOTHING );

	mov	eax, -2
	jmp	$LN1@search_ass
$LN8@search_ass:

; 461  : 
; 462  :     grp = GetGroup( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetGroup
	mov	QWORD PTR grp$[rsp], rax

; 463  : 
; 464  :     /* first check the default segment register */
; 465  : 
; 466  :     if( def != ASSUME_NOTHING ) {

	cmp	DWORD PTR def$[rsp], -2
	je	$LN9@search_ass

; 467  :         if( SegAssumeTable[def].symbol == sym )

	movsxd	rax, DWORD PTR def$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	rdx, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rcx+rax], rdx
	jne	SHORT $LN10@search_ass

; 468  :             return( def );

	mov	eax, DWORD PTR def$[rsp]
	jmp	$LN1@search_ass
$LN10@search_ass:

; 469  :         if( search_grps && grp ) {

	movzx	eax, BYTE PTR search_grps$[rsp]
	test	eax, eax
	je	SHORT $LN11@search_ass
	cmp	QWORD PTR grp$[rsp], 0
	je	SHORT $LN11@search_ass

; 470  :             if( SegAssumeTable[def].is_flat && grp == &ModuleInfo.flat_grp->sym )

	movsxd	rax, DWORD PTR def$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	movzx	eax, BYTE PTR [rcx+rax+9]
	test	eax, eax
	je	SHORT $LN12@search_ass
	mov	rax, QWORD PTR ModuleInfo+440
	cmp	QWORD PTR grp$[rsp], rax
	jne	SHORT $LN12@search_ass

; 471  :                 return( def );

	mov	eax, DWORD PTR def$[rsp]
	jmp	$LN1@search_ass
$LN12@search_ass:

; 472  :             if( SegAssumeTable[def].symbol == grp )

	movsxd	rax, DWORD PTR def$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	rdx, QWORD PTR grp$[rsp]
	cmp	QWORD PTR [rcx+rax], rdx
	jne	SHORT $LN13@search_ass

; 473  :                 return( def );

	mov	eax, DWORD PTR def$[rsp]
	jmp	$LN1@search_ass
$LN13@search_ass:
$LN11@search_ass:
$LN9@search_ass:

; 474  :         }
; 475  :     }
; 476  : 
; 477  :     /* now check all segment registers */
; 478  : 
; 479  :     for( def = 0; def < NUM_SEGREGS; def++ ) {

	mov	DWORD PTR def$[rsp], 0
	jmp	SHORT $LN4@search_ass
$LN2@search_ass:
	mov	eax, DWORD PTR def$[rsp]
	inc	eax
	mov	DWORD PTR def$[rsp], eax
$LN4@search_ass:
	cmp	DWORD PTR def$[rsp], 6
	jge	SHORT $LN3@search_ass

; 480  :         if( SegAssumeTable[searchtab[def]].symbol == sym ) {

	movsxd	rax, DWORD PTR def$[rsp]
	lea	rcx, OFFSET FLAT:searchtab
	movsxd	rax, DWORD PTR [rcx+rax*4]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	rdx, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rcx+rax], rdx
	jne	SHORT $LN14@search_ass

; 481  :             return( searchtab[def] );

	movsxd	rax, DWORD PTR def$[rsp]
	lea	rcx, OFFSET FLAT:searchtab
	mov	eax, DWORD PTR [rcx+rax*4]
	jmp	$LN1@search_ass
$LN14@search_ass:

; 482  :         }
; 483  :     }

	jmp	SHORT $LN2@search_ass
$LN3@search_ass:

; 484  : 
; 485  :     /* now check the groups */
; 486  :     if( search_grps && grp )

	movzx	eax, BYTE PTR search_grps$[rsp]
	test	eax, eax
	je	$LN15@search_ass
	cmp	QWORD PTR grp$[rsp], 0
	je	$LN15@search_ass

; 487  :         for( def = 0; def < NUM_SEGREGS; def++ ) {

	mov	DWORD PTR def$[rsp], 0
	jmp	SHORT $LN7@search_ass
$LN5@search_ass:
	mov	eax, DWORD PTR def$[rsp]
	inc	eax
	mov	DWORD PTR def$[rsp], eax
$LN7@search_ass:
	cmp	DWORD PTR def$[rsp], 6
	jge	SHORT $LN6@search_ass

; 488  :             if( SegAssumeTable[searchtab[def]].is_flat && grp == &ModuleInfo.flat_grp->sym )

	movsxd	rax, DWORD PTR def$[rsp]
	lea	rcx, OFFSET FLAT:searchtab
	movsxd	rax, DWORD PTR [rcx+rax*4]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	movzx	eax, BYTE PTR [rcx+rax+9]
	test	eax, eax
	je	SHORT $LN16@search_ass
	mov	rax, QWORD PTR ModuleInfo+440
	cmp	QWORD PTR grp$[rsp], rax
	jne	SHORT $LN16@search_ass

; 489  :                 return( searchtab[def] );

	movsxd	rax, DWORD PTR def$[rsp]
	lea	rcx, OFFSET FLAT:searchtab
	mov	eax, DWORD PTR [rcx+rax*4]
	jmp	SHORT $LN1@search_ass
$LN16@search_ass:

; 490  :             if( SegAssumeTable[searchtab[def]].symbol == grp ) {

	movsxd	rax, DWORD PTR def$[rsp]
	lea	rcx, OFFSET FLAT:searchtab
	movsxd	rax, DWORD PTR [rcx+rax*4]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	rdx, QWORD PTR grp$[rsp]
	cmp	QWORD PTR [rcx+rax], rdx
	jne	SHORT $LN17@search_ass

; 491  :                 return( searchtab[def] );

	movsxd	rax, DWORD PTR def$[rsp]
	lea	rcx, OFFSET FLAT:searchtab
	mov	eax, DWORD PTR [rcx+rax*4]
	jmp	SHORT $LN1@search_ass
$LN17@search_ass:

; 492  :             }
; 493  :         }

	jmp	$LN5@search_ass
$LN6@search_ass:
$LN15@search_ass:

; 494  : 
; 495  :     return( ASSUME_NOTHING );

	mov	eax, -2
$LN1@search_ass:

; 496  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
search_assume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
reg$ = 32
pass$ = 64
AssumeInit PROC

; 153  : {

$LN12:
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+64]

; 154  :     int reg;
; 155  : 
; 156  :     for( reg = 0; reg < NUM_SEGREGS; reg++ ) {

	mov	DWORD PTR reg$[rsp], 0
	jmp	SHORT $LN4@AssumeInit
$LN2@AssumeInit:
	mov	eax, DWORD PTR reg$[rsp]
	inc	eax
	mov	DWORD PTR reg$[rsp], eax
$LN4@AssumeInit:
	cmp	DWORD PTR reg$[rsp], 6
	jge	SHORT $LN3@AssumeInit

; 157  :         SegAssumeTable[reg].symbol = NULL;

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	QWORD PTR [rcx+rax], 0

; 158  :         SegAssumeTable[reg].error = FALSE;

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	BYTE PTR [rcx+rax+8], 0

; 159  :         SegAssumeTable[reg].is_flat = FALSE;

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	BYTE PTR [rcx+rax+9], 0

; 160  :     }

	jmp	SHORT $LN2@AssumeInit
$LN3@AssumeInit:

; 161  : 
; 162  :     /* the GPR assumes are handled somewhat special by masm.
; 163  :      * they aren't reset for each pass - instead they keep their value.
; 164  :      */
; 165  : 
; 166  :     if ( pass <= PASS_1 ) { /* v2.10: just reset assumes in pass one */

	cmp	DWORD PTR pass$[rsp], 0
	jg	SHORT $LN8@AssumeInit

; 167  : 
; 168  :         for( reg = 0; reg < NUM_STDREGS; reg++ ) {

	mov	DWORD PTR reg$[rsp], 0
	jmp	SHORT $LN7@AssumeInit
$LN5@AssumeInit:
	mov	eax, DWORD PTR reg$[rsp]
	inc	eax
	mov	DWORD PTR reg$[rsp], eax
$LN7@AssumeInit:
	cmp	DWORD PTR reg$[rsp], 16
	jge	SHORT $LN6@AssumeInit

; 169  :             StdAssumeTable[reg].symbol = NULL;

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	QWORD PTR [rcx+rax], 0

; 170  :             StdAssumeTable[reg].error = 0;

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	BYTE PTR [rcx+rax+8], 0

; 171  :         }

	jmp	SHORT $LN5@AssumeInit
$LN6@AssumeInit:

; 172  :         if ( pass == PASS_1 )

	cmp	DWORD PTR pass$[rsp], 0
	jne	SHORT $LN9@AssumeInit

; 173  :             memset( &stdsym, 0, sizeof( stdsym ) );

	mov	r8d, 128				; 00000080H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:stdsym
	call	memset
$LN9@AssumeInit:
$LN8@AssumeInit:

; 174  :     }
; 175  : #if FASTPASS
; 176  :     if ( pass > PASS_1 && UseSavedState ) {

	cmp	DWORD PTR pass$[rsp], 0
	jle	SHORT $LN10@AssumeInit
	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	je	SHORT $LN10@AssumeInit

; 177  :         SetSegAssumeTable( &saved_SegAssumeTable );

	lea	rcx, OFFSET FLAT:saved_SegAssumeTable
	call	SetSegAssumeTable

; 178  : #if 0
; 179  :         /* v2.10: this is a weird Masm feature:
; 180  :          * if a GPR is assumed to be a pointer to a struct,
; 181  :          * it isn't reset when a new pass starts.
; 182  :          * see assume11.asm and assume12.asm
; 183  :          */
; 184  :         if ( pass == PASS_2 ) {
; 185  :             struct assume_info *psaved = &saved_StdAssumeTable;
; 186  :             struct stdassume_typeinfo *ptype = &saved_StdTypeInfo;
; 187  :             for ( reg = 0; reg < NUM_STDREGS; reg++, psaved++, ptype++ )
; 188  :                 if ( psaved->symbol == NULL && StdAssumeTable[reg].symbol && StdAssumeTable[reg].symbol->target_type ) {
; 189  :                     psaved->symbol = StdAssumeTable[reg].symbol;
; 190  :                     ptype->type        = psaved->symbol->type;
; 191  :                     ptype->target_type = psaved->symbol->target_type;
; 192  :                     ptype->mem_type    = psaved->symbol->mem_type;
; 193  :                     ptype->ptr_memtype = psaved->symbol->ptr_memtype;
; 194  :                     ptype->is_ptr      = psaved->symbol->is_ptr;
; 195  :                 }
; 196  :         }
; 197  : #endif
; 198  :         SetStdAssumeTable( &saved_StdAssumeTable, saved_StdTypeInfo );

	lea	rdx, OFFSET FLAT:saved_StdTypeInfo
	lea	rcx, OFFSET FLAT:saved_StdAssumeTable
	call	SetStdAssumeTable
$LN10@AssumeInit:

; 199  :     }
; 200  : #endif
; 201  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
AssumeInit ENDP
_TEXT	ENDS
END
