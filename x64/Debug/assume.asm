; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	szDgroup
_DATA	SEGMENT
COMM	SegAssumeTable:BYTE:060H
COMM	StdAssumeTable:BYTE:0100H
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG11142 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG11013 DB	'SetSegAssumeTable', 0aH, 00H
	ORG $+5
$SG11017 DB	'GetSegAssumeTable', 0aH, 00H
	ORG $+5
$SG11027 DB	'SetStdAssumeTable enter', 0aH, 00H
	ORG $+7
$SG11038 DB	'GetStdAssumeTable', 0aH, 00H
	ORG $+5
$SG11067 DB	'%r %r:%r,%r:%r,%r:%r,%r:%r,%r:%s,%r:%s', 00H
	ORG $+1
$SG11075 DB	'%r %r:%s,%r:%s,%r:%s', 00H
	ORG $+3
$SG11076 DB	'%r %r:%s,%r:%s', 00H
	ORG $+1
$SG11117 DB	'AssumeDirective enter, pass=%u', 0aH, 00H
_DATA	ENDS
CONST	SEGMENT
searchtab DD	03H
	DD	02H
	DD	00H
	DD	04H
	DD	05H
	DD	01H
szError	DB	'ERROR', 00H
	ORG $+2
szNothing DB	'NOTHING', 00H
szDgroup DB	'DGROUP', 00H
CONST	ENDS
PUBLIC	AssumeInit
PUBLIC	search_assume
PUBLIC	GetAssume
PUBLIC	GetOverrideAssume
PUBLIC	GetStdAssume
PUBLIC	GetStdAssumeEx
PUBLIC	ModelAssumeInit
PUBLIC	SetSegAssumeTable
PUBLIC	GetSegAssumeTable
PUBLIC	SetStdAssumeTable
PUBLIC	GetStdAssumeTable
PUBLIC	AssumeSaveState
PUBLIC	AssumeDirective
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	_stricmp:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	OperandSize:PROC
EXTRN	GetGroup:PROC
EXTRN	SimGetSegName:PROC
EXTRN	CreateTypeSymbol:PROC
EXTRN	GetQualifiedType:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	EvalOperand:PROC
EXTRN	StoreLine:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SpecialTable:BYTE
EXTRN	UseSavedState:BYTE
_BSS	SEGMENT
	ALIGN	8

stdsym	DQ	010H DUP (?)
saved_SegAssumeTable DB 060H DUP (?)
saved_StdAssumeTable DB 0100H DUP (?)
saved_StdTypeInfo DB 0180H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$AssumeInit DD imagerel $LN12
	DD	imagerel $LN12+265
	DD	imagerel $unwind$AssumeInit
$pdata$search_assume DD imagerel $LN19
	DD	imagerel $LN19+475
	DD	imagerel $unwind$search_assume
$pdata$GetAssume DD imagerel $LN11
	DD	imagerel $LN11+266
	DD	imagerel $unwind$GetAssume
$pdata$ModelAssumeInit DD imagerel $LN14
	DD	imagerel $LN14+405
	DD	imagerel $unwind$ModelAssumeInit
$pdata$SetSegAssumeTable DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$SetSegAssumeTable
$pdata$GetSegAssumeTable DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$GetSegAssumeTable
$pdata$SetStdAssumeTable DD imagerel $LN7
	DD	imagerel $LN7+291
	DD	imagerel $unwind$SetStdAssumeTable
$pdata$GetStdAssumeTable DD imagerel $LN7
	DD	imagerel $LN7+291
	DD	imagerel $unwind$GetStdAssumeTable
$pdata$AssumeSaveState DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$AssumeSaveState
$pdata$AssumeDirective DD imagerel $LN61
	DD	imagerel $LN61+2152
	DD	imagerel $unwind$AssumeDirective
pdata	ENDS
xdata	SEGMENT
$unwind$AssumeInit DD 010801H
	DD	06208H
$unwind$search_assume DD 011201H
	DD	06212H
$unwind$GetAssume DD 011801H
	DD	06218H
$unwind$ModelAssumeInit DD 020701H
	DD	0150107H
$unwind$SetSegAssumeTable DD 010901H
	DD	04209H
$unwind$GetSegAssumeTable DD 010901H
	DD	04209H
$unwind$SetStdAssumeTable DD 010e01H
	DD	0620eH
$unwind$GetStdAssumeTable DD 010e01H
	DD	0620eH
$unwind$AssumeSaveState DD 010401H
	DD	04204H
$unwind$AssumeDirective DD 021001H
	DD	01f0110H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
segtable$ = 48
j$ = 52
info$ = 56
reg$ = 64
flags$ = 68
tv198 = 72
tv221 = 76
size$ = 80
tv252 = 84
tv325 = 88
tv386 = 92
ti$ = 96
opnd$1 = 128
i$ = 256
tokenarray$ = 264
AssumeDirective PROC

; 287  : {

$LN61:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 248				; 000000f8H

; 288  :     int             reg;
; 289  :     int             j;
; 290  :     int             size;
; 291  :     uint_32         flags;
; 292  :     struct assume_info *info;
; 293  :     bool            segtable;
; 294  :     struct qualified_type ti;
; 295  : 
; 296  :     DebugMsg1(( "AssumeDirective enter, pass=%u\n", Parse_Pass+1 ));

	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11117
	call	DoDebugMsg1

; 297  : 
; 298  :     for( i++; i < Token_Count; i++ ) {

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN4@AssumeDire
$LN2@AssumeDire:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@AssumeDire:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@AssumeDire

; 299  : 
; 300  :         if( ( tokenarray[i].token == T_ID )
; 301  :             && (0 == _stricmp( tokenarray[i].string_ptr, szNothing )) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN7@AssumeDire
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:szNothing
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN7@AssumeDire

; 302  :             AssumeInit( -1 );

	mov	ecx, -1
	call	AssumeInit

; 303  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 304  :             break;

	jmp	$LN3@AssumeDire
$LN7@AssumeDire:

; 305  :         }
; 306  : 
; 307  :         /*---- get the info ptr for the register ----*/
; 308  : 
; 309  :         info = NULL;

	mov	QWORD PTR info$[rsp], 0

; 310  :         if ( tokenarray[i].token == T_REG ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	jne	$LN8@AssumeDire

; 311  :             reg = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR reg$[rsp], eax

; 312  :             j = GetRegNo( reg );

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	DWORD PTR j$[rsp], eax

; 313  :             flags = GetValueSp( reg );

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR flags$[rsp], eax

; 314  :             if ( flags & OP_SR ) {

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 24576				; 00006000H
	test	eax, eax
	je	SHORT $LN9@AssumeDire

; 315  :                 info = &SegAssumeTable[j];

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR info$[rsp], rax

; 316  :                 segtable = TRUE;

	mov	BYTE PTR segtable$[rsp], 1
	jmp	SHORT $LN10@AssumeDire
$LN9@AssumeDire:

; 317  :             } else if ( flags & OP_R ) {

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 15
	test	eax, eax
	je	SHORT $LN11@AssumeDire

; 318  :                 info = &StdAssumeTable[j];

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR info$[rsp], rax

; 319  :                 segtable = FALSE;

	mov	BYTE PTR segtable$[rsp], 0
$LN11@AssumeDire:
$LN10@AssumeDire:
$LN8@AssumeDire:

; 320  :             }
; 321  :         }
; 322  :         if ( info == NULL ) {

	cmp	QWORD PTR info$[rsp], 0
	jne	SHORT $LN12@AssumeDire

; 323  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@AssumeDire
$LN12@AssumeDire:

; 324  :         }
; 325  : 
; 326  :         if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < GetCpuSp( reg ) ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	movsxd	rcx, DWORD PTR reg$[rsp]
	imul	rcx, rcx, 12
	lea	rdx, OFFSET FLAT:SpecialTable
	movzx	ecx, WORD PTR [rdx+rcx+8]
	cmp	eax, ecx
	jge	SHORT $LN13@AssumeDire

; 327  :             return( EmitError( INSTRUCTION_OR_REGISTER_NOT_ACCEPTED_IN_CURRENT_CPU_MODE ) );

	mov	ecx, 30
	call	EmitError
	jmp	$LN1@AssumeDire
$LN13@AssumeDire:

; 328  :         }
; 329  : 
; 330  :         i++; /* go past register */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 331  : 
; 332  :         if( tokenarray[i].token != T_COLON ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN14@AssumeDire

; 333  :             return( EmitError( COLON_EXPECTED ) );

	mov	ecx, 84					; 00000054H
	call	EmitError
	jmp	$LN1@AssumeDire
$LN14@AssumeDire:

; 334  :         }
; 335  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 336  : 
; 337  :         if( tokenarray[i].token == T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN15@AssumeDire

; 338  :             return( EmitError( SYNTAX_ERROR ) );

	mov	ecx, 45					; 0000002dH
	call	EmitError
	jmp	$LN1@AssumeDire
$LN15@AssumeDire:

; 339  :         }
; 340  : 
; 341  :         /* check for ERROR and NOTHING */
; 342  : 
; 343  :         if( 0 == _stricmp( tokenarray[i].string_ptr, szError )) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:szError
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN16@AssumeDire

; 344  :             if ( segtable ) {

	movzx	eax, BYTE PTR segtable$[rsp]
	test	eax, eax
	je	SHORT $LN18@AssumeDire

; 345  :                 info->is_flat = FALSE;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+9], 0

; 346  :                 info->error = TRUE;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+8], 1

; 347  :             } else

	jmp	SHORT $LN19@AssumeDire
$LN18@AssumeDire:

; 348  :                 info->error |= (( reg >= T_AH && reg <= T_BH ) ? RH_ERROR : ( flags & OP_R ));

	cmp	DWORD PTR reg$[rsp], 5
	jl	SHORT $LN53@AssumeDire
	cmp	DWORD PTR reg$[rsp], 8
	jg	SHORT $LN53@AssumeDire
	mov	DWORD PTR tv198[rsp], 16
	jmp	SHORT $LN54@AssumeDire
$LN53@AssumeDire:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 15
	mov	DWORD PTR tv198[rsp], eax
$LN54@AssumeDire:
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	or	eax, DWORD PTR tv198[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+8], al
$LN19@AssumeDire:

; 349  :             info->symbol = NULL;

	mov	rax, QWORD PTR info$[rsp]
	mov	QWORD PTR [rax], 0

; 350  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	$LN17@AssumeDire
$LN16@AssumeDire:

; 351  :         } else if( 0 == _stricmp( tokenarray[i].string_ptr, szNothing )) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:szNothing
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN20@AssumeDire

; 352  :             if ( segtable ) {

	movzx	eax, BYTE PTR segtable$[rsp]
	test	eax, eax
	je	SHORT $LN22@AssumeDire

; 353  :                 info->is_flat = FALSE;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+9], 0

; 354  :                 info->error = FALSE;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+8], 0

; 355  :             } else

	jmp	SHORT $LN23@AssumeDire
$LN22@AssumeDire:

; 356  :                 info->error &= ~(( reg >= T_AH && reg <= T_BH ) ? RH_ERROR : ( flags & OP_R ));

	cmp	DWORD PTR reg$[rsp], 5
	jl	SHORT $LN55@AssumeDire
	cmp	DWORD PTR reg$[rsp], 8
	jg	SHORT $LN55@AssumeDire
	mov	DWORD PTR tv221[rsp], 16
	jmp	SHORT $LN56@AssumeDire
$LN55@AssumeDire:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 15
	mov	DWORD PTR tv221[rsp], eax
$LN56@AssumeDire:
	mov	eax, DWORD PTR tv221[rsp]
	not	eax
	mov	rcx, QWORD PTR info$[rsp]
	movzx	ecx, BYTE PTR [rcx+8]
	and	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+8], al
$LN23@AssumeDire:

; 357  :             info->symbol = NULL;

	mov	rax, QWORD PTR info$[rsp]
	mov	QWORD PTR [rax], 0

; 358  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	$LN21@AssumeDire
$LN20@AssumeDire:

; 359  :         } else if ( segtable == FALSE ) {

	movzx	eax, BYTE PTR segtable$[rsp]
	test	eax, eax
	jne	$LN24@AssumeDire

; 360  : 
; 361  :             /* v2.05: changed to use new GetQualifiedType() function */
; 362  :             ti.size = 0;

	mov	DWORD PTR ti$[rsp], 0

; 363  :             ti.is_ptr = 0;

	mov	BYTE PTR ti$[rsp+20], 0

; 364  :             ti.is_far = FALSE;

	mov	BYTE PTR ti$[rsp+21], 0

; 365  :             ti.mem_type = MT_EMPTY;

	mov	DWORD PTR ti$[rsp+16], 192		; 000000c0H

; 366  :             ti.ptr_memtype = MT_EMPTY;

	mov	DWORD PTR ti$[rsp+24], 192		; 000000c0H

; 367  :             ti.symtype = NULL;

	mov	QWORD PTR ti$[rsp+8], 0

; 368  :             ti.Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	BYTE PTR ti$[rsp+22], al

; 369  :             if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	GetQualifiedType
	cmp	eax, -1
	jne	SHORT $LN26@AssumeDire

; 370  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@AssumeDire
$LN26@AssumeDire:

; 371  : 
; 372  :             /* v2.04: check size of argument! */
; 373  :             size = OperandSize( flags, NULL );

	xor	edx, edx
	mov	ecx, DWORD PTR flags$[rsp]
	call	OperandSize
	mov	DWORD PTR size$[rsp], eax

; 374  :             if ( ( ti.is_ptr == 0 && size != ti.size ) ||

	movzx	eax, BYTE PTR ti$[rsp+20]
	test	eax, eax
	jne	SHORT $LN29@AssumeDire
	mov	eax, DWORD PTR ti$[rsp]
	cmp	DWORD PTR size$[rsp], eax
	jne	SHORT $LN28@AssumeDire
$LN29@AssumeDire:
	movzx	eax, BYTE PTR ti$[rsp+20]
	test	eax, eax
	jle	SHORT $LN27@AssumeDire
	movzx	eax, BYTE PTR ModuleInfo+406
	cmp	DWORD PTR size$[rsp], eax
	jge	SHORT $LN27@AssumeDire
$LN28@AssumeDire:

; 375  :                 ( ti.is_ptr > 0 && size < CurrWordSize ) ) {
; 376  :                 return( EmitError( TYPE_IS_WRONG_SIZE_FOR_REGISTER ) );

	mov	ecx, 247				; 000000f7H
	call	EmitError
	jmp	$LN1@AssumeDire
$LN27@AssumeDire:

; 377  :             }
; 378  :             info->error &= ~(( reg >= T_AH && reg <= T_BH ) ? RH_ERROR : ( flags & OP_R ));

	cmp	DWORD PTR reg$[rsp], 5
	jl	SHORT $LN57@AssumeDire
	cmp	DWORD PTR reg$[rsp], 8
	jg	SHORT $LN57@AssumeDire
	mov	DWORD PTR tv252[rsp], 16
	jmp	SHORT $LN58@AssumeDire
$LN57@AssumeDire:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 15
	mov	DWORD PTR tv252[rsp], eax
$LN58@AssumeDire:
	mov	eax, DWORD PTR tv252[rsp]
	not	eax
	mov	rcx, QWORD PTR info$[rsp]
	movzx	ecx, BYTE PTR [rcx+8]
	and	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+8], al

; 379  :             if ( stdsym[j] == NULL ) {

	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	cmp	QWORD PTR [rcx+rax*8], 0
	jne	SHORT $LN30@AssumeDire

; 380  :                 stdsym[j] = CreateTypeSymbol( NULL, "", FALSE );

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:$SG11142
	xor	ecx, ecx
	call	CreateTypeSymbol
	movsxd	rcx, DWORD PTR j$[rsp]
	lea	rdx, OFFSET FLAT:stdsym
	mov	QWORD PTR [rdx+rcx*8], rax

; 381  :                 stdsym[j]->typekind = TYPE_TYPEDEF;

	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	BYTE PTR [rax+66], 3
$LN30@AssumeDire:

; 382  :             }
; 383  : 
; 384  :             stdsym[j]->total_size = ti.size;

	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	ecx, DWORD PTR ti$[rsp]
	mov	DWORD PTR [rax+56], ecx

; 385  :             stdsym[j]->mem_type   = ti.mem_type;

	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	ecx, DWORD PTR ti$[rsp+16]
	mov	DWORD PTR [rax+36], ecx

; 386  :             stdsym[j]->is_ptr     = ti.is_ptr;

	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	ecx, BYTE PTR ti$[rsp+20]
	mov	BYTE PTR [rax+45], cl

; 387  :             stdsym[j]->isfar      = ti.is_far;

	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	ecx, BYTE PTR ti$[rsp+21]
	and	cl, 1
	shl	cl, 4
	movzx	eax, BYTE PTR [rax+47]
	and	al, 239					; 000000efH
	or	al, cl
	movsxd	rcx, DWORD PTR j$[rsp]
	lea	rdx, OFFSET FLAT:stdsym
	mov	rcx, QWORD PTR [rdx+rcx*8]
	mov	BYTE PTR [rcx+47], al

; 388  :             stdsym[j]->Ofssize    = ti.Ofssize;

	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	ecx, BYTE PTR ti$[rsp+22]
	mov	BYTE PTR [rax+44], cl

; 389  :             stdsym[j]->ptr_memtype = ti.ptr_memtype; /* added v2.05 rc13 */

	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	ecx, BYTE PTR ti$[rsp+24]
	mov	BYTE PTR [rax+46], cl

; 390  :             if ( ti.mem_type == MT_TYPE )

	cmp	DWORD PTR ti$[rsp+16], 196		; 000000c4H
	jne	SHORT $LN31@AssumeDire

; 391  :                 stdsym[j]->type = ti.symtype;

	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rax+80], rcx
	jmp	SHORT $LN32@AssumeDire
$LN31@AssumeDire:

; 392  :             else
; 393  :                 stdsym[j]->target_type = ti.symtype;

	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rax+48], rcx
$LN32@AssumeDire:

; 394  : 
; 395  :             info->symbol = stdsym[j];

	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:stdsym
	mov	rdx, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR [rdx], rax

; 396  : 
; 397  :         } else { /* segment register */

	jmp	$LN25@AssumeDire
$LN24@AssumeDire:

; 398  :             struct expr opnd;
; 399  : 
; 400  :             /* v2.08: read expression with standard evaluator */
; 401  :             if( EvalOperand( &i, tokenarray, Token_Count, &opnd, 0 ) == ERROR )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opnd$1[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN33@AssumeDire

; 402  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@AssumeDire
$LN33@AssumeDire:

; 403  :             switch ( opnd.kind ) {

	mov	eax, DWORD PTR opnd$1[rsp+60]
	mov	DWORD PTR tv325[rsp], eax
	cmp	DWORD PTR tv325[rsp], 1
	je	SHORT $LN34@AssumeDire
	cmp	DWORD PTR tv325[rsp], 2
	je	$LN47@AssumeDire
	jmp	$LN49@AssumeDire
$LN34@AssumeDire:

; 404  :             case EXPR_ADDR:
; 405  :                 if ( opnd.sym == NULL || opnd.indirect == TRUE || opnd.value ) {

	cmp	QWORD PTR opnd$1[rsp+80], 0
	je	SHORT $LN37@AssumeDire
	mov	eax, DWORD PTR opnd$1[rsp+72]
	and	eax, 1
	cmp	eax, 1
	je	SHORT $LN37@AssumeDire
	cmp	DWORD PTR opnd$1[rsp], 0
	je	SHORT $LN35@AssumeDire
$LN37@AssumeDire:

; 406  :                     return( EmitError( SEGMENT_GROUP_OR_SEGREG_EXPECTED ) );

	mov	ecx, 69					; 00000045H
	call	EmitError
	jmp	$LN1@AssumeDire
	jmp	$LN36@AssumeDire
$LN35@AssumeDire:

; 407  :                 } else if ( opnd.sym->state == SYM_UNDEFINED ) {

	mov	rax, QWORD PTR opnd$1[rsp+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN38@AssumeDire

; 408  :                     /* ensure that directive is rerun in pass 2
; 409  :                      * so an error msg can be emitted.
; 410  :                      */
; 411  :                     FStoreLine( 0 );

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN40@AssumeDire
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR ModuleInfo+464
	call	StoreLine
$LN40@AssumeDire:

; 412  :                     info->symbol = opnd.sym;

	mov	rax, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR opnd$1[rsp+80]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN39@AssumeDire
$LN38@AssumeDire:

; 413  :                 } else if ( ( opnd.sym->state == SYM_SEG || opnd.sym->state == SYM_GRP ) && opnd.instr == EMPTY ) {

	mov	rax, QWORD PTR opnd$1[rsp+80]
	cmp	DWORD PTR [rax+32], 3
	je	SHORT $LN44@AssumeDire
	mov	rax, QWORD PTR opnd$1[rsp+80]
	cmp	DWORD PTR [rax+32], 4
	jne	SHORT $LN42@AssumeDire
$LN44@AssumeDire:
	cmp	DWORD PTR opnd$1[rsp+56], -2
	jne	SHORT $LN42@AssumeDire

; 414  :                     info->symbol = opnd.sym;

	mov	rax, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR opnd$1[rsp+80]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN43@AssumeDire
$LN42@AssumeDire:

; 415  :                 } else if ( opnd.instr == T_SEG ) {

	cmp	DWORD PTR opnd$1[rsp+56], 244		; 000000f4H
	jne	SHORT $LN45@AssumeDire

; 416  :                     info->symbol = opnd.sym->segment;

	mov	rax, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR opnd$1[rsp+80]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax], rcx

; 417  :                 } else {

	jmp	SHORT $LN46@AssumeDire
$LN45@AssumeDire:

; 418  :                     return( EmitError( SEGMENT_GROUP_OR_SEGREG_EXPECTED ) );

	mov	ecx, 69					; 00000045H
	call	EmitError
	jmp	$LN1@AssumeDire
$LN46@AssumeDire:
$LN43@AssumeDire:
$LN39@AssumeDire:
$LN36@AssumeDire:

; 419  :                 }
; 420  :                 info->is_flat = ( info->symbol == &ModuleInfo.flat_grp->sym );

	mov	rax, QWORD PTR ModuleInfo+440
	mov	rcx, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rcx], rax
	jne	SHORT $LN59@AssumeDire
	mov	DWORD PTR tv386[rsp], 1
	jmp	SHORT $LN60@AssumeDire
$LN59@AssumeDire:
	mov	DWORD PTR tv386[rsp], 0
$LN60@AssumeDire:
	mov	rax, QWORD PTR info$[rsp]
	movzx	ecx, BYTE PTR tv386[rsp]
	mov	BYTE PTR [rax+9], cl

; 421  :                 break;

	jmp	$LN5@AssumeDire
$LN47@AssumeDire:

; 422  :             case EXPR_REG:
; 423  :                 if ( GetValueSp( opnd.base_reg->tokval ) & OP_SR ) {

	mov	rax, QWORD PTR opnd$1[rsp+24]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 24576				; 00006000H
	test	eax, eax
	je	SHORT $LN48@AssumeDire

; 424  :                     info->symbol = SegAssumeTable[ GetRegNo( opnd.base_reg->tokval ) ].symbol;

	mov	rax, QWORD PTR opnd$1[rsp+24]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	rdx, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR [rdx], rax

; 425  :                     info->is_flat = SegAssumeTable[ GetRegNo( opnd.base_reg->tokval ) ].is_flat;

	mov	rax, QWORD PTR opnd$1[rsp+24]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	rdx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+9]
	mov	BYTE PTR [rdx+9], al

; 426  :                     break;

	jmp	SHORT $LN5@AssumeDire
$LN48@AssumeDire:
$LN49@AssumeDire:

; 427  :                 }
; 428  :             default:
; 429  :                 return( EmitError( SEGMENT_GROUP_OR_SEGREG_EXPECTED ) );

	mov	ecx, 69					; 00000045H
	call	EmitError
	jmp	SHORT $LN1@AssumeDire
$LN5@AssumeDire:

; 430  :             }
; 431  :             info->error = FALSE;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+8], 0
$LN25@AssumeDire:
$LN21@AssumeDire:
$LN17@AssumeDire:

; 432  :         }
; 433  : 
; 434  :         /* comma expected */
; 435  :         if( i < Token_Count && tokenarray[i].token != T_COMMA )

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN50@AssumeDire
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN50@AssumeDire

; 436  :             break;

	jmp	SHORT $LN3@AssumeDire
$LN50@AssumeDire:

; 437  :     }

	jmp	$LN2@AssumeDire
$LN3@AssumeDire:

; 438  :     if ( i < Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN51@AssumeDire

; 439  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@AssumeDire
$LN51@AssumeDire:

; 440  :     }
; 441  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@AssumeDire:

; 442  : }

	add	rsp, 248				; 000000f8H
	ret	0
AssumeDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
AssumeSaveState PROC

; 145  : {

$LN3:
	sub	rsp, 40					; 00000028H

; 146  :     GetSegAssumeTable( &saved_SegAssumeTable );

	lea	rcx, OFFSET FLAT:saved_SegAssumeTable
	call	GetSegAssumeTable

; 147  :     GetStdAssumeTable( &saved_StdAssumeTable, saved_StdTypeInfo );

	lea	rdx, OFFSET FLAT:saved_StdTypeInfo
	lea	rcx, OFFSET FLAT:saved_StdAssumeTable
	call	GetStdAssumeTable

; 148  : }

	add	rsp, 40					; 00000028H
	ret	0
AssumeSaveState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
i$ = 32
savedstate$ = 64
ti$ = 72
GetStdAssumeTable PROC

; 127  : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 128  :     int i;
; 129  :     DebugMsg(("GetStdAssumeTable\n" ));

	lea	rcx, OFFSET FLAT:$SG11038
	call	DoDebugMsg

; 130  :     memcpy( savedstate, &StdAssumeTable, sizeof(StdAssumeTable) );

	mov	r8d, 256				; 00000100H
	lea	rdx, OFFSET FLAT:StdAssumeTable
	mov	rcx, QWORD PTR savedstate$[rsp]
	call	memcpy

; 131  :     for ( i = 0; i < NUM_STDREGS; i++, ti++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@GetStdAssu
$LN2@GetStdAssu:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR ti$[rsp]
	add	rax, 24
	mov	QWORD PTR ti$[rsp], rax
$LN4@GetStdAssu:
	cmp	DWORD PTR i$[rsp], 16
	jge	$LN3@GetStdAssu

; 132  :         if ( StdAssumeTable[i].symbol ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	cmp	QWORD PTR [rcx+rax], 0
	je	$LN5@GetStdAssu

; 133  :             ti->type        = StdAssumeTable[i].symbol->type;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR [rcx], rax

; 134  :             ti->target_type = StdAssumeTable[i].symbol->target_type;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR [rcx+8], rax

; 135  :             ti->mem_type    = StdAssumeTable[i].symbol->mem_type;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rcx+16], eax

; 136  :             ti->ptr_memtype = StdAssumeTable[i].symbol->ptr_memtype;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	mov	BYTE PTR [rcx+20], al

; 137  :             ti->is_ptr      = StdAssumeTable[i].symbol->is_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	movzx	eax, BYTE PTR [rax+45]
	mov	BYTE PTR [rcx+21], al
$LN5@GetStdAssu:

; 138  :         }
; 139  :     }

	jmp	$LN2@GetStdAssu
$LN3@GetStdAssu:

; 140  : }

	add	rsp, 56					; 00000038H
	ret	0
GetStdAssumeTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
i$ = 32
savedstate$ = 64
ti$ = 72
SetStdAssumeTable PROC

; 109  : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 110  :     int i;
; 111  : 
; 112  :     DebugMsg(("SetStdAssumeTable enter\n" ));

	lea	rcx, OFFSET FLAT:$SG11027
	call	DoDebugMsg

; 113  :     memcpy( &StdAssumeTable, savedstate, sizeof(StdAssumeTable) );

	mov	r8d, 256				; 00000100H
	mov	rdx, QWORD PTR savedstate$[rsp]
	lea	rcx, OFFSET FLAT:StdAssumeTable
	call	memcpy

; 114  :     for ( i = 0; i < NUM_STDREGS; i++, ti++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@SetStdAssu
$LN2@SetStdAssu:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR ti$[rsp]
	add	rax, 24
	mov	QWORD PTR ti$[rsp], rax
$LN4@SetStdAssu:
	cmp	DWORD PTR i$[rsp], 16
	jge	$LN3@SetStdAssu

; 115  :         if ( StdAssumeTable[i].symbol ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	cmp	QWORD PTR [rcx+rax], 0
	je	$LN5@SetStdAssu

; 116  :             StdAssumeTable[i].symbol->type        = ti->type;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+80], rcx

; 117  :             StdAssumeTable[i].symbol->target_type = ti->target_type;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+48], rcx

; 118  :             StdAssumeTable[i].symbol->mem_type    = ti->mem_type;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax+36], ecx

; 119  :             StdAssumeTable[i].symbol->ptr_memtype = ti->ptr_memtype;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	movzx	ecx, BYTE PTR [rcx+20]
	mov	BYTE PTR [rax+46], cl

; 120  :             StdAssumeTable[i].symbol->is_ptr      = ti->is_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR ti$[rsp]
	movzx	ecx, BYTE PTR [rcx+21]
	mov	BYTE PTR [rax+45], cl
$LN5@SetStdAssu:

; 121  :         }
; 122  :     }

	jmp	$LN2@SetStdAssu
$LN3@SetStdAssu:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
SetStdAssumeTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
savedstate$ = 48
GetSegAssumeTable PROC

; 95   : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 96   :     DebugMsg(("GetSegAssumeTable\n" ));

	lea	rcx, OFFSET FLAT:$SG11017
	call	DoDebugMsg

; 97   :     memcpy( savedstate, &SegAssumeTable, sizeof(SegAssumeTable) );

	mov	r8d, 96					; 00000060H
	lea	rdx, OFFSET FLAT:SegAssumeTable
	mov	rcx, QWORD PTR savedstate$[rsp]
	call	memcpy

; 98   : }

	add	rsp, 40					; 00000028H
	ret	0
GetSegAssumeTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
savedstate$ = 48
SetSegAssumeTable PROC

; 89   : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 90   :     DebugMsg(("SetSegAssumeTable\n" ));

	lea	rcx, OFFSET FLAT:$SG11013
	call	DoDebugMsg

; 91   :     memcpy( &SegAssumeTable, savedstate, sizeof(SegAssumeTable) );

	mov	r8d, 96					; 00000060H
	mov	rdx, QWORD PTR savedstate$[rsp]
	lea	rcx, OFFSET FLAT:SegAssumeTable
	call	memcpy

; 92   : }

	add	rsp, 40					; 00000028H
	ret	0
SetSegAssumeTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
tv64 = 112
pGSassume$ = 120
pCS$ = 128
pFmt$ = 136
pFSassume$ = 144
ModelAssumeInit PROC

; 208  : {

$LN14:
	sub	rsp, 168				; 000000a8H

; 209  :     const char *pCS;
; 210  :     const char *pFSassume = szError;

	lea	rax, OFFSET FLAT:szError
	mov	QWORD PTR pFSassume$[rsp], rax

; 211  :     const char *pGSassume = szError;

	lea	rax, OFFSET FLAT:szError
	mov	QWORD PTR pGSassume$[rsp], rax

; 212  :     const char *pFmt;
; 213  : 
; 214  :     /* Generates codes for assume */
; 215  :     switch( ModuleInfo.model ) {

	mov	eax, DWORD PTR ModuleInfo+360
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 0
	jle	$LN2@ModelAssum
	cmp	DWORD PTR tv64[rsp], 6
	jle	$LN6@ModelAssum
	cmp	DWORD PTR tv64[rsp], 7
	je	SHORT $LN4@ModelAssum
	jmp	$LN2@ModelAssum
$LN4@ModelAssum:

; 216  :     case MODEL_FLAT:
; 217  : #if AMD64_SUPPORT
; 218  :         if ( ModuleInfo.fctype == FCT_WIN64 )

	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN5@ModelAssum

; 219  :             pGSassume = szNothing;

	lea	rax, OFFSET FLAT:szNothing
	mov	QWORD PTR pGSassume$[rsp], rax
$LN5@ModelAssum:

; 220  : #endif
; 221  :         AddLineQueueX( "%r %r:%r,%r:%r,%r:%r,%r:%r,%r:%s,%r:%s",

	mov	rax, QWORD PTR pGSassume$[rsp]
	mov	QWORD PTR [rsp+104], rax
	mov	DWORD PTR [rsp+96], 30
	mov	rax, QWORD PTR pFSassume$[rsp]
	mov	QWORD PTR [rsp+88], rax
	mov	DWORD PTR [rsp+80], 29
	mov	DWORD PTR [rsp+72], 261			; 00000105H
	mov	DWORD PTR [rsp+64], 25
	mov	DWORD PTR [rsp+56], 261			; 00000105H
	mov	DWORD PTR [rsp+48], 27
	mov	DWORD PTR [rsp+40], 261			; 00000105H
	mov	DWORD PTR [rsp+32], 28
	mov	r9d, 261				; 00000105H
	mov	r8d, 26
	mov	edx, 444				; 000001bcH
	lea	rcx, OFFSET FLAT:$SG11067
	call	AddLineQueueX

; 222  :                   T_ASSUME, T_CS, T_FLAT, T_DS, T_FLAT, T_SS, T_FLAT, T_ES, T_FLAT, T_FS, pFSassume, T_GS, pGSassume );
; 223  :         break;

	jmp	$LN2@ModelAssum
$LN6@ModelAssum:

; 224  :     case MODEL_TINY:
; 225  :     case MODEL_SMALL:
; 226  :     case MODEL_COMPACT:
; 227  :     case MODEL_MEDIUM:
; 228  :     case MODEL_LARGE:
; 229  :     case MODEL_HUGE:
; 230  :         /* v2.03: no DGROUP for COFF/ELF */
; 231  : #if COFF_SUPPORT || ELF_SUPPORT
; 232  :         if( Options.output_format == OFORMAT_COFF
; 233  : #if ELF_SUPPORT
; 234  :            || Options.output_format == OFORMAT_ELF

	cmp	DWORD PTR Options+160, 2
	je	SHORT $LN8@ModelAssum
	cmp	DWORD PTR Options+160, 3
	jne	SHORT $LN7@ModelAssum
$LN8@ModelAssum:

; 235  : #endif
; 236  :           )
; 237  :             break;

	jmp	$LN2@ModelAssum
$LN7@ModelAssum:

; 238  : #endif
; 239  :         if ( ModuleInfo.model == MODEL_TINY )

	cmp	DWORD PTR ModuleInfo+360, 1
	jne	SHORT $LN9@ModelAssum

; 240  :             pCS = szDgroup;

	lea	rax, OFFSET FLAT:szDgroup
	mov	QWORD PTR pCS$[rsp], rax
	jmp	SHORT $LN10@ModelAssum
$LN9@ModelAssum:

; 241  :         else
; 242  :             pCS = SimGetSegName( SIM_CODE );

	xor	ecx, ecx
	call	SimGetSegName
	mov	QWORD PTR pCS$[rsp], rax
$LN10@ModelAssum:

; 243  : 
; 244  :         if ( ModuleInfo.distance != STACK_FAR )

	cmp	DWORD PTR ModuleInfo+356, 1
	je	SHORT $LN11@ModelAssum

; 245  :             pFmt = "%r %r:%s,%r:%s,%r:%s";

	lea	rax, OFFSET FLAT:$SG11075
	mov	QWORD PTR pFmt$[rsp], rax
	jmp	SHORT $LN12@ModelAssum
$LN11@ModelAssum:

; 246  :         else
; 247  :             pFmt = "%r %r:%s,%r:%s";

	lea	rax, OFFSET FLAT:$SG11076
	mov	QWORD PTR pFmt$[rsp], rax
$LN12@ModelAssum:

; 248  :         AddLineQueueX( pFmt, T_ASSUME, T_CS, pCS, T_DS, szDgroup, T_SS, szDgroup );

	lea	rax, OFFSET FLAT:szDgroup
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], 27
	lea	rax, OFFSET FLAT:szDgroup
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 28
	mov	r9, QWORD PTR pCS$[rsp]
	mov	r8d, 26
	mov	edx, 444				; 000001bcH
	mov	rcx, QWORD PTR pFmt$[rsp]
	call	AddLineQueueX
$LN2@ModelAssum:

; 249  :         break;
; 250  :     }
; 251  : }

	add	rsp, 168				; 000000a8H
	ret	0
ModelAssumeInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
reg$ = 8
GetStdAssumeEx PROC

; 272  : {

	mov	DWORD PTR [rsp+8], ecx

; 273  :   if (reg >= NUM_STDREGS)

	cmp	DWORD PTR reg$[rsp], 16
	jl	SHORT $LN2@GetStdAssu

; 274  :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@GetStdAssu
$LN2@GetStdAssu:

; 275  :   return(StdAssumeTable[reg].symbol);

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
$LN1@GetStdAssu:

; 276  : }

	ret	0
GetStdAssumeEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
reg$ = 8
GetStdAssume PROC

; 257  : {

	mov	DWORD PTR [rsp+8], ecx

; 258  :     if ( StdAssumeTable[reg].symbol )

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN2@GetStdAssu

; 259  :         if ( StdAssumeTable[reg].symbol->mem_type == MT_TYPE )

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN3@GetStdAssu

; 260  :             return( StdAssumeTable[reg].symbol->type );

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rax, QWORD PTR [rax+80]
	jmp	SHORT $LN1@GetStdAssu
	jmp	SHORT $LN4@GetStdAssu
$LN3@GetStdAssu:

; 261  :         else
; 262  :             return( StdAssumeTable[reg].symbol->target_type );

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
	mov	rax, QWORD PTR [rax+48]
	jmp	SHORT $LN1@GetStdAssu
$LN4@GetStdAssu:
$LN2@GetStdAssu:

; 263  :     return ( NULL );

	xor	eax, eax
$LN1@GetStdAssu:

; 264  : }

	ret	0
GetStdAssume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
override$ = 8
GetOverrideAssume PROC

; 507  : {

	mov	DWORD PTR [rsp+8], ecx

; 508  :     if( SegAssumeTable[override].is_flat ) {

	movsxd	rax, DWORD PTR override$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	movzx	eax, BYTE PTR [rcx+rax+9]
	test	eax, eax
	je	SHORT $LN2@GetOverrid

; 509  :         return( (struct asym *)ModuleInfo.flat_grp );

	mov	rax, QWORD PTR ModuleInfo+440
	jmp	SHORT $LN1@GetOverrid
$LN2@GetOverrid:

; 510  :     }
; 511  :     return( SegAssumeTable[override].symbol);

	movsxd	rax, DWORD PTR override$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	rax, QWORD PTR [rcx+rax]
$LN1@GetOverrid:

; 512  : 
; 513  : }

	ret	0
GetOverrideAssume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
reg$ = 32
override$ = 64
sym$ = 72
def$ = 80
passume$ = 88
GetAssume PROC

; 527  : {

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 528  :     enum assume_segreg  reg;
; 529  : 
; 530  :     if( ( def != ASSUME_NOTHING ) && SegAssumeTable[def].is_flat ) {

	cmp	DWORD PTR def$[rsp], -2
	je	SHORT $LN2@GetAssume
	movsxd	rax, DWORD PTR def$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	movzx	eax, BYTE PTR [rcx+rax+9]
	test	eax, eax
	je	SHORT $LN2@GetAssume

; 531  :         *passume = (struct asym *)ModuleInfo.flat_grp;

	mov	rax, QWORD PTR passume$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+440
	mov	QWORD PTR [rax], rcx

; 532  :         return( def );

	mov	eax, DWORD PTR def$[rsp]
	jmp	$LN1@GetAssume
$LN2@GetAssume:

; 533  :     }
; 534  :     if( override != NULL ) {

	cmp	QWORD PTR override$[rsp], 0
	je	SHORT $LN3@GetAssume

; 535  :         reg = search_assume( override, def, FALSE );

	xor	r8d, r8d
	mov	edx, DWORD PTR def$[rsp]
	mov	rcx, QWORD PTR override$[rsp]
	call	search_assume
	mov	DWORD PTR reg$[rsp], eax
	jmp	SHORT $LN4@GetAssume
$LN3@GetAssume:

; 536  : #if 1 /* v2.10: added */
; 537  :     } else if ( sym->state == SYM_STACK ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 5
	jne	SHORT $LN5@GetAssume

; 538  :         /* stack symbols don't have a segment part.
; 539  :          * In case [R|E]BP is used as base, it doesn't matter.
; 540  :          * However, if option -Zg is set, this isn't true.
; 541  :          */
; 542  :         reg = ASSUME_SS;

	mov	DWORD PTR reg$[rsp], 2

; 543  : #endif
; 544  :     } else {

	jmp	SHORT $LN6@GetAssume
$LN5@GetAssume:

; 545  :         reg = search_assume( sym->segment, def, TRUE );

	mov	r8b, 1
	mov	edx, DWORD PTR def$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	search_assume
	mov	DWORD PTR reg$[rsp], eax
$LN6@GetAssume:
$LN4@GetAssume:

; 546  :     }
; 547  :     if( reg == ASSUME_NOTHING ) {

	cmp	DWORD PTR reg$[rsp], -2
	jne	SHORT $LN7@GetAssume

; 548  :         if( sym && sym->state == SYM_EXTERNAL && sym->segment == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN8@GetAssume
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN8@GetAssume
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN8@GetAssume

; 549  :             reg = def;

	mov	eax, DWORD PTR def$[rsp]
	mov	DWORD PTR reg$[rsp], eax
$LN8@GetAssume:
$LN7@GetAssume:

; 550  :         }
; 551  :     }
; 552  :     if( reg != ASSUME_NOTHING ) {

	cmp	DWORD PTR reg$[rsp], -2
	je	SHORT $LN9@GetAssume

; 553  :         *passume = SegAssumeTable[reg].symbol;

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	rdx, QWORD PTR passume$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR [rdx], rax

; 554  :         return( reg );

	mov	eax, DWORD PTR reg$[rsp]
	jmp	SHORT $LN1@GetAssume
$LN9@GetAssume:

; 555  :     }
; 556  :     *passume = NULL;

	mov	rax, QWORD PTR passume$[rsp]
	mov	QWORD PTR [rax], 0

; 557  :     return( ASSUME_NOTHING );

	mov	eax, -2
$LN1@GetAssume:

; 558  : }

	add	rsp, 56					; 00000038H
	ret	0
GetAssume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
grp$ = 32
sym$ = 64
def$ = 72
search_grps$ = 80
search_assume PROC

; 457  : {

$LN19:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 458  :     struct asym *grp;
; 459  : 
; 460  :     if( sym == NULL )

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN8@search_ass

; 461  :         return( ASSUME_NOTHING );

	mov	eax, -2
	jmp	$LN1@search_ass
$LN8@search_ass:

; 462  : 
; 463  :     grp = GetGroup( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetGroup
	mov	QWORD PTR grp$[rsp], rax

; 464  : 
; 465  :     /* first check the default segment register */
; 466  : 
; 467  :     if( def != ASSUME_NOTHING ) {

	cmp	DWORD PTR def$[rsp], -2
	je	$LN9@search_ass

; 468  :         if( SegAssumeTable[def].symbol == sym )

	movsxd	rax, DWORD PTR def$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	rdx, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rcx+rax], rdx
	jne	SHORT $LN10@search_ass

; 469  :             return( def );

	mov	eax, DWORD PTR def$[rsp]
	jmp	$LN1@search_ass
$LN10@search_ass:

; 470  :         if( search_grps && grp ) {

	movzx	eax, BYTE PTR search_grps$[rsp]
	test	eax, eax
	je	SHORT $LN11@search_ass
	cmp	QWORD PTR grp$[rsp], 0
	je	SHORT $LN11@search_ass

; 471  :             if( SegAssumeTable[def].is_flat && grp == &ModuleInfo.flat_grp->sym )

	movsxd	rax, DWORD PTR def$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	movzx	eax, BYTE PTR [rcx+rax+9]
	test	eax, eax
	je	SHORT $LN12@search_ass
	mov	rax, QWORD PTR ModuleInfo+440
	cmp	QWORD PTR grp$[rsp], rax
	jne	SHORT $LN12@search_ass

; 472  :                 return( def );

	mov	eax, DWORD PTR def$[rsp]
	jmp	$LN1@search_ass
$LN12@search_ass:

; 473  :             if( SegAssumeTable[def].symbol == grp )

	movsxd	rax, DWORD PTR def$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	rdx, QWORD PTR grp$[rsp]
	cmp	QWORD PTR [rcx+rax], rdx
	jne	SHORT $LN13@search_ass

; 474  :                 return( def );

	mov	eax, DWORD PTR def$[rsp]
	jmp	$LN1@search_ass
$LN13@search_ass:
$LN11@search_ass:
$LN9@search_ass:

; 475  :         }
; 476  :     }
; 477  : 
; 478  :     /* now check all segment registers */
; 479  : 
; 480  :     for( def = 0; def < NUM_SEGREGS; def++ ) {

	mov	DWORD PTR def$[rsp], 0
	jmp	SHORT $LN4@search_ass
$LN2@search_ass:
	mov	eax, DWORD PTR def$[rsp]
	inc	eax
	mov	DWORD PTR def$[rsp], eax
$LN4@search_ass:
	cmp	DWORD PTR def$[rsp], 6
	jge	SHORT $LN3@search_ass

; 481  :         if( SegAssumeTable[searchtab[def]].symbol == sym ) {

	movsxd	rax, DWORD PTR def$[rsp]
	lea	rcx, OFFSET FLAT:searchtab
	movsxd	rax, DWORD PTR [rcx+rax*4]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	rdx, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rcx+rax], rdx
	jne	SHORT $LN14@search_ass

; 482  :             return( searchtab[def] );

	movsxd	rax, DWORD PTR def$[rsp]
	lea	rcx, OFFSET FLAT:searchtab
	mov	eax, DWORD PTR [rcx+rax*4]
	jmp	$LN1@search_ass
$LN14@search_ass:

; 483  :         }
; 484  :     }

	jmp	SHORT $LN2@search_ass
$LN3@search_ass:

; 485  : 
; 486  :     /* now check the groups */
; 487  :     if( search_grps && grp )

	movzx	eax, BYTE PTR search_grps$[rsp]
	test	eax, eax
	je	$LN15@search_ass
	cmp	QWORD PTR grp$[rsp], 0
	je	$LN15@search_ass

; 488  :         for( def = 0; def < NUM_SEGREGS; def++ ) {

	mov	DWORD PTR def$[rsp], 0
	jmp	SHORT $LN7@search_ass
$LN5@search_ass:
	mov	eax, DWORD PTR def$[rsp]
	inc	eax
	mov	DWORD PTR def$[rsp], eax
$LN7@search_ass:
	cmp	DWORD PTR def$[rsp], 6
	jge	SHORT $LN6@search_ass

; 489  :             if( SegAssumeTable[searchtab[def]].is_flat && grp == &ModuleInfo.flat_grp->sym )

	movsxd	rax, DWORD PTR def$[rsp]
	lea	rcx, OFFSET FLAT:searchtab
	movsxd	rax, DWORD PTR [rcx+rax*4]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	movzx	eax, BYTE PTR [rcx+rax+9]
	test	eax, eax
	je	SHORT $LN16@search_ass
	mov	rax, QWORD PTR ModuleInfo+440
	cmp	QWORD PTR grp$[rsp], rax
	jne	SHORT $LN16@search_ass

; 490  :                 return( searchtab[def] );

	movsxd	rax, DWORD PTR def$[rsp]
	lea	rcx, OFFSET FLAT:searchtab
	mov	eax, DWORD PTR [rcx+rax*4]
	jmp	SHORT $LN1@search_ass
$LN16@search_ass:

; 491  :             if( SegAssumeTable[searchtab[def]].symbol == grp ) {

	movsxd	rax, DWORD PTR def$[rsp]
	lea	rcx, OFFSET FLAT:searchtab
	movsxd	rax, DWORD PTR [rcx+rax*4]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	rdx, QWORD PTR grp$[rsp]
	cmp	QWORD PTR [rcx+rax], rdx
	jne	SHORT $LN17@search_ass

; 492  :                 return( searchtab[def] );

	movsxd	rax, DWORD PTR def$[rsp]
	lea	rcx, OFFSET FLAT:searchtab
	mov	eax, DWORD PTR [rcx+rax*4]
	jmp	SHORT $LN1@search_ass
$LN17@search_ass:

; 493  :             }
; 494  :         }

	jmp	$LN5@search_ass
$LN6@search_ass:
$LN15@search_ass:

; 495  : 
; 496  :     return( ASSUME_NOTHING );

	mov	eax, -2
$LN1@search_ass:

; 497  : }

	add	rsp, 56					; 00000038H
	ret	0
search_assume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
reg$ = 32
pass$ = 64
AssumeInit PROC

; 153  : {

$LN12:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 154  :     int reg;
; 155  : 
; 156  :     for( reg = 0; reg < NUM_SEGREGS; reg++ ) {

	mov	DWORD PTR reg$[rsp], 0
	jmp	SHORT $LN4@AssumeInit
$LN2@AssumeInit:
	mov	eax, DWORD PTR reg$[rsp]
	inc	eax
	mov	DWORD PTR reg$[rsp], eax
$LN4@AssumeInit:
	cmp	DWORD PTR reg$[rsp], 6
	jge	SHORT $LN3@AssumeInit

; 157  :         SegAssumeTable[reg].symbol = NULL;

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	QWORD PTR [rcx+rax], 0

; 158  :         SegAssumeTable[reg].error = FALSE;

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	BYTE PTR [rcx+rax+8], 0

; 159  :         SegAssumeTable[reg].is_flat = FALSE;

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	BYTE PTR [rcx+rax+9], 0

; 160  :     }

	jmp	SHORT $LN2@AssumeInit
$LN3@AssumeInit:

; 161  : 
; 162  :     /* the GPR assumes are handled somewhat special by masm.
; 163  :      * they aren't reset for each pass - instead they keep their value.
; 164  :      */
; 165  : 
; 166  :     if ( pass <= PASS_1 ) { /* v2.10: just reset assumes in pass one */

	cmp	DWORD PTR pass$[rsp], 0
	jg	SHORT $LN8@AssumeInit

; 167  : 
; 168  :         for( reg = 0; reg < NUM_STDREGS; reg++ ) {

	mov	DWORD PTR reg$[rsp], 0
	jmp	SHORT $LN7@AssumeInit
$LN5@AssumeInit:
	mov	eax, DWORD PTR reg$[rsp]
	inc	eax
	mov	DWORD PTR reg$[rsp], eax
$LN7@AssumeInit:
	cmp	DWORD PTR reg$[rsp], 16
	jge	SHORT $LN6@AssumeInit

; 169  :             StdAssumeTable[reg].symbol = NULL;

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	QWORD PTR [rcx+rax], 0

; 170  :             StdAssumeTable[reg].error = 0;

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	mov	BYTE PTR [rcx+rax+8], 0

; 171  :         }

	jmp	SHORT $LN5@AssumeInit
$LN6@AssumeInit:

; 172  :         if ( pass == PASS_1 )

	cmp	DWORD PTR pass$[rsp], 0
	jne	SHORT $LN9@AssumeInit

; 173  :             memset( &stdsym, 0, sizeof( stdsym ) );

	mov	r8d, 128				; 00000080H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:stdsym
	call	memset
$LN9@AssumeInit:
$LN8@AssumeInit:

; 174  :     }
; 175  : #if FASTPASS
; 176  :     if ( pass > PASS_1 && UseSavedState ) {

	cmp	DWORD PTR pass$[rsp], 0
	jle	SHORT $LN10@AssumeInit
	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	je	SHORT $LN10@AssumeInit

; 177  :         SetSegAssumeTable( &saved_SegAssumeTable );

	lea	rcx, OFFSET FLAT:saved_SegAssumeTable
	call	SetSegAssumeTable

; 178  : #if 0
; 179  :         /* v2.10: this is a weird Masm feature:
; 180  :          * if a GPR is assumed to be a pointer to a struct,
; 181  :          * it isn't reset when a new pass starts.
; 182  :          * see assume11.asm and assume12.asm
; 183  :          */
; 184  :         if ( pass == PASS_2 ) {
; 185  :             struct assume_info *psaved = &saved_StdAssumeTable;
; 186  :             struct stdassume_typeinfo *ptype = &saved_StdTypeInfo;
; 187  :             for ( reg = 0; reg < NUM_STDREGS; reg++, psaved++, ptype++ )
; 188  :                 if ( psaved->symbol == NULL && StdAssumeTable[reg].symbol && StdAssumeTable[reg].symbol->target_type ) {
; 189  :                     psaved->symbol = StdAssumeTable[reg].symbol;
; 190  :                     ptype->type        = psaved->symbol->type;
; 191  :                     ptype->target_type = psaved->symbol->target_type;
; 192  :                     ptype->mem_type    = psaved->symbol->mem_type;
; 193  :                     ptype->ptr_memtype = psaved->symbol->ptr_memtype;
; 194  :                     ptype->is_ptr      = psaved->symbol->is_ptr;
; 195  :                 }
; 196  :         }
; 197  : #endif
; 198  :         SetStdAssumeTable( &saved_StdAssumeTable, saved_StdTypeInfo );

	lea	rdx, OFFSET FLAT:saved_StdTypeInfo
	lea	rcx, OFFSET FLAT:saved_StdAssumeTable
	call	SetStdAssumeTable
$LN10@AssumeInit:

; 199  :     }
; 200  : #endif
; 201  : }

	add	rsp, 56					; 00000038H
	ret	0
AssumeInit ENDP
_TEXT	ENDS
END
