; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG10933 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG10872 DB	'_TEXT', 00H
	ORG $+2
$SG10873 DB	'STACK', 00H
	ORG $+2
$SG10874 DB	'_DATA', 00H
	ORG $+2
$SG10875 DB	'_BSS', 00H
	ORG $+3
$SG10876 DB	'FAR_DATA', 00H
	ORG $+3
$SG10878 DB	'CONST', 00H
	ORG $+2
$SG10883 DB	'BSS', 00H
$SG10877 DB	'FAR_BSS', 00H
$SG10880 DB	'CODE', 00H
	ORG $+3
$SG10881 DB	'STACK', 00H
	ORG $+2
$SG10882 DB	'DATA', 00H
	ORG $+3
$SG10884 DB	'FAR_DATA', 00H
	ORG $+3
$SG10886 DB	'CONST', 00H
	ORG $+2
$SG10888 DB	'PUBLIC', 00H
	ORG $+5
$SG10885 DB	'FAR_BSS', 00H
$SG10889 DB	'STACK', 00H
	ORG $+2
$SG10890 DB	'PUBLIC', 00H
	ORG $+1
$SG10891 DB	'PUBLIC', 00H
	ORG $+1
$SG10892 DB	'PRIVATE', 00H
$SG10893 DB	'PRIVATE', 00H
$SG10894 DB	'PUBLIC', 00H
	ORG $+1
$SG10911 DB	'%s %r %s', 00H
	ORG $+7
$SG10916 DB	'close_currseg: current seg=%s', 0aH, 00H
	ORG $+1
$SG10917 DB	'%s %r', 00H
	ORG $+2
$SG10931 DB	'WORD', 00H
	ORG $+3
$SG10932 DB	'PARA', 00H
	ORG $+3
$SG10937 DB	'FLAT', 00H
	ORG $+3
$SG10938 DB	'USE32', 00H
	ORG $+2
$SG10941 DB	'DWORD', 00H
	ORG $+2
$SG10942 DB	'PARA', 00H
	ORG $+3
$SG10947 DB	'%s %r %s %s %s ''%s''', 00H
$SG10952 DB	'%s %r', 00H
	ORG $+2
$SG10956 DB	'%s %r', 00H
	ORG $+2
$SG10958 DB	'%s %r', 00H
	ORG $+2
$SG10963 DB	'%s %r', 00H
	ORG $+6
$SG10983 DB	'SimplifiedSegDir(%s) enter', 0aH, 00H
$SG11003 DB	'FLAT', 00H
	ORG $+7
$SG11005 DB	'%r %r:%s', 00H
	ORG $+7
$SG11007 DB	'ORG 0%xh', 00H
	ORG $+7
$SG11011 DB	'%r %r:ERROR', 00H
	ORG $+4
$SG11015 DB	'%r %r:ERROR', 00H
	ORG $+4
$SG11017 DB	'simsegm.c', 00H
	ORG $+6
$SG11018 DB	'SimplifiedSegDir exit', 0aH, 00H
	ORG $+1
$SG11031 DB	'ModelSimSegmInit() enter, pass one', 0aH, 00H
	ORG $+4
$SG11034 DB	'%s %r %s', 00H
	ORG $+3
$SG11037 DB	', %s', 00H
	ORG $+7
$SG11038 DB	'ModelSimSegmInit() exit', 0aH, 00H
_DATA	ENDS
CONST	SEGMENT
SegmNamesDef DQ	FLAT:$SG10872
	DQ	FLAT:$SG10873
	DQ	FLAT:$SG10874
	DQ	FLAT:$SG10875
	DQ	FLAT:$SG10876
	DQ	FLAT:$SG10877
	DQ	FLAT:$SG10878
SegmClass DQ	FLAT:$SG10880
	DQ	FLAT:$SG10881
	DQ	FLAT:$SG10882
	DQ	FLAT:$SG10883
	DQ	FLAT:$SG10884
	DQ	FLAT:$SG10885
	DQ	FLAT:$SG10886
SegmCombine DQ	FLAT:$SG10888
	DQ	FLAT:$SG10889
	DQ	FLAT:$SG10890
	DQ	FLAT:$SG10891
	DQ	FLAT:$SG10892
	DQ	FLAT:$SG10893
	DQ	FLAT:$SG10894
CONST	ENDS
PUBLIC	SimGetSegName
PUBLIC	GetCodeClass
PUBLIC	ModelSimSegmInit
PUBLIC	ModelSimSegmExit
PUBLIC	SetModelDefaultSegNames
PUBLIC	SimplifiedSegDir
EXTRN	memcpy:PROC
EXTRN	strcat:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymFind:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	RunLineQueue:PROC
EXTRN	EvalOperand:PROC
EXTRN	LstWrite:PROC
EXTRN	InternalError:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	_RTC_UninitUse:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SpecialTable:BYTE
EXTRN	szDgroup:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
	ALIGN	8

SegmNames DQ	07H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$SimGetSegName DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$SimGetSegName
$pdata$GetCodeClass DD imagerel $LN4
	DD	imagerel $LN4+69
	DD	imagerel $unwind$GetCodeClass
$pdata$ModelSimSegmInit DD imagerel $LN7
	DD	imagerel $LN7+348
	DD	imagerel $unwind$ModelSimSegmInit
$pdata$ModelSimSegmExit DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$ModelSimSegmExit
$pdata$SetModelDefaultSegNames DD imagerel $LN7
	DD	imagerel $LN7+527
	DD	imagerel $unwind$SetModelDefaultSegNames
$pdata$AddToDgroup DD imagerel AddToDgroup
	DD	imagerel AddToDgroup+127
	DD	imagerel $unwind$AddToDgroup
$pdata$close_currseg DD imagerel close_currseg
	DD	imagerel close_currseg+89
	DD	imagerel $unwind$close_currseg
$pdata$SetSimSeg DD imagerel SetSimSeg
	DD	imagerel SetSimSeg+705
	DD	imagerel $unwind$SetSimSeg
$pdata$EndSimSeg DD imagerel EndSimSeg
	DD	imagerel EndSimSeg+68
	DD	imagerel $unwind$EndSimSeg
$pdata$SimplifiedSegDir DD imagerel $LN37
	DD	imagerel $LN37+1128
	DD	imagerel $unwind$SimplifiedSegDir
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
ModelSimSegmInit$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
ModelSimSegmInit$rtcVarDesc DD 038H
	DD	014H
	DQ	FLAT:ModelSimSegmInit$rtcName$0
	ORG $+48
ModelSimSegmInit$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:ModelSimSegmInit$rtcVarDesc
SimplifiedSegDir$rtcName$0 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	078H
	DB	00H
	ORG $+2
SimplifiedSegDir$rtcName$1 DB 069H
	DB	06eH
	DB	069H
	DB	074H
	DB	00H
	ORG $+3
SimplifiedSegDir$rtcVarDesc DD 050H
	DD	068H
	DQ	FLAT:SimplifiedSegDir$rtcName$0
	ORG $+48
SimplifiedSegDir$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:SimplifiedSegDir$rtcVarDesc
CONST	ENDS
xdata	SEGMENT
$unwind$SimGetSegName DD 010501H
	DD	07005H
$unwind$GetCodeClass DD 010201H
	DD	07002H
$unwind$ModelSimSegmInit DD 022e19H
	DD	07005d209H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$ModelSimSegmExit DD 021501H
	DD	070023206H
$unwind$SetModelDefaultSegNames DD 021501H
	DD	070029206H
$unwind$AddToDgroup DD 022101H
	DD	0700a320eH
$unwind$close_currseg DD 021501H
	DD	070023206H
$unwind$SetSimSeg DD 022701H
	DD	0700af211H
$unwind$EndSimSeg DD 021c01H
	DD	070053209H
$unwind$SimplifiedSegDir DD 032701H
	DD	01a0111H
	DD	0700aH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_TEXT	SEGMENT
name$ = 48
init$ = 56
type$ = 60
opndx$ = 80
$T5 = 196
$T6 = 197
tv164 = 200
i$ = 224
tokenarray$ = 232
SimplifiedSegDir PROC

; 176  : {

$LN37:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 208				; 000000d0H
	mov	rdi, rsp
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+224]
	mov	BYTE PTR $T6[rsp], 0
	mov	BYTE PTR $T5[rsp], 0

; 177  :     const char  *name = NULL;

	mov	QWORD PTR name$[rsp], 0

; 178  :     char        init;
; 179  :     int         type;
; 180  :     struct expr opndx;
; 181  : 
; 182  :     DebugMsg1(("SimplifiedSegDir(%s) enter\n", tokenarray[i].string_ptr ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG10983
	call	DoDebugMsg1

; 183  : 
; 184  :     LstWrite( LSTTYPE_DIRECTIVE, 0, NULL );

	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, 4
	call	LstWrite

; 185  : 
; 186  :     if( ModuleInfo.model == MODEL_NONE ) {

	cmp	DWORD PTR ModuleInfo+360, 0
	jne	SHORT $LN4@Simplified

; 187  :         EmitError( MODEL_IS_NOT_DECLARED );

	mov	ecx, 96					; 00000060H
	call	EmitError

; 188  :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@Simplified
$LN4@Simplified:

; 189  :     }
; 190  : 
; 191  :     //type = tokenarray[i].value;
; 192  :     type = GetSflagsSp( tokenarray[i].tokval );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax+4]
	mov	DWORD PTR type$[rsp], eax

; 193  :     i++; /* get past the directive token */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 194  : 
; 195  :     if( type == SIM_STACK ) {

	cmp	DWORD PTR type$[rsp], 1
	jne	SHORT $LN5@Simplified

; 196  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	BYTE PTR $T5[rsp], 1
	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN7@Simplified

; 197  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@Simplified
$LN7@Simplified:

; 198  :         if( opndx.kind == EXPR_EMPTY )

	cmp	DWORD PTR opndx$[rsp+60], -2
	jne	SHORT $LN8@Simplified

; 199  :             opndx.value = DEFAULT_STACK_SIZE;

	mov	BYTE PTR $T5[rsp], 1
	mov	DWORD PTR opndx$[rsp], 1024		; 00000400H
	jmp	SHORT $LN9@Simplified
$LN8@Simplified:

; 200  :         else if( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN10@Simplified

; 201  :             EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 202  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@Simplified
$LN10@Simplified:
$LN9@Simplified:

; 203  :         }
; 204  :     } else {

	jmp	$LN6@Simplified
$LN5@Simplified:

; 205  :         /* Masm accepts a name argument for .CODE and .FARDATA[?] only.
; 206  :          * HJWasm also accepts this for .DATA[?] and .CONST unless
; 207  :          * option -Zne is set.
; 208  :          */
; 209  :         if( tokenarray[i].token == T_ID &&

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN11@Simplified
	cmp	DWORD PTR type$[rsp], 0
	je	SHORT $LN12@Simplified
	cmp	DWORD PTR type$[rsp], 4
	je	SHORT $LN12@Simplified
	cmp	DWORD PTR type$[rsp], 5
	je	SHORT $LN12@Simplified
	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	jne	SHORT $LN11@Simplified
	cmp	DWORD PTR type$[rsp], 2
	je	SHORT $LN13@Simplified
	cmp	DWORD PTR type$[rsp], 3
	je	SHORT $LN13@Simplified
	cmp	DWORD PTR type$[rsp], 6
	jne	SHORT $LN11@Simplified
$LN13@Simplified:
$LN12@Simplified:

; 210  :            ( type == SIM_CODE || type == SIM_FARDATA || type == SIM_FARDATA_UN
; 211  :             || ( Options.strict_masm_compat == FALSE &&
; 212  :                 ( type == SIM_DATA || type == SIM_DATA_UN || type == SIM_CONST )))) {
; 213  :             name = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR name$[rsp], rax

; 214  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN11@Simplified:
$LN6@Simplified:

; 215  :         }
; 216  :     }
; 217  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN14@Simplified

; 218  :         EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 219  :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@Simplified
$LN14@Simplified:

; 220  :     }
; 221  : 
; 222  :     if( type != SIM_STACK )

	cmp	DWORD PTR type$[rsp], 1
	je	SHORT $LN15@Simplified

; 223  :         close_currseg();  /* emit a "xxx ENDS" line to close current seg */

	call	close_currseg
$LN15@Simplified:

; 224  : 
; 225  :     if ( name == NULL )

	cmp	QWORD PTR name$[rsp], 0
	jne	SHORT $LN16@Simplified

; 226  :         init = ( ModuleInfo.simseg_init & ( 1 << type ) );

	movzx	eax, BYTE PTR ModuleInfo+420
	mov	ecx, DWORD PTR type$[rsp]
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	and	eax, ecx
	mov	BYTE PTR $T6[rsp], 1
	mov	BYTE PTR init$[rsp], al
$LN16@Simplified:

; 227  : 
; 228  :     switch( type ) {

	mov	eax, DWORD PTR type$[rsp]
	mov	DWORD PTR tv164[rsp], eax
	cmp	DWORD PTR tv164[rsp], 6
	ja	$LN31@Simplified
	movsxd	rax, DWORD PTR tv164[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN36@Simplified[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN17@Simplified:

; 229  :     case SIM_CODE: /* .code */
; 230  :         SetSimSeg( SIM_CODE, name );

	mov	rdx, QWORD PTR name$[rsp]
	xor	ecx, ecx
	call	SetSimSeg

; 231  : 
; 232  :         if( ModuleInfo.model == MODEL_TINY ) {

	cmp	DWORD PTR ModuleInfo+360, 1
	jne	SHORT $LN18@Simplified

; 233  :             /* v2.05: add the named code segment to DGROUP */
; 234  :             if ( name )

	cmp	QWORD PTR name$[rsp], 0
	je	SHORT $LN20@Simplified

; 235  :                 AddToDgroup( SIM_CODE, name );

	mov	rdx, QWORD PTR name$[rsp]
	xor	ecx, ecx
	call	AddToDgroup
$LN20@Simplified:

; 236  :             name = szDgroup;

	lea	rax, OFFSET FLAT:szDgroup
	mov	QWORD PTR name$[rsp], rax
	jmp	SHORT $LN19@Simplified
$LN18@Simplified:

; 237  :         } else if( ModuleInfo.model == MODEL_FLAT ) {

	cmp	DWORD PTR ModuleInfo+360, 7
	jne	SHORT $LN21@Simplified

; 238  :             name = "FLAT";

	lea	rax, OFFSET FLAT:$SG11003
	mov	QWORD PTR name$[rsp], rax

; 239  :         } else {

	jmp	SHORT $LN22@Simplified
$LN21@Simplified:

; 240  :             if( name == NULL )

	cmp	QWORD PTR name$[rsp], 0
	jne	SHORT $LN23@Simplified

; 241  :                 name = SegmNames[SIM_CODE];

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SegmNames
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR name$[rsp], rax
$LN23@Simplified:
$LN22@Simplified:
$LN19@Simplified:

; 242  :         }
; 243  :         AddLineQueueX( "%r %r:%s", T_ASSUME, T_CS, name );

	mov	r9, QWORD PTR name$[rsp]
	mov	r8d, 26
	mov	edx, 439				; 000001b7H
	lea	rcx, OFFSET FLAT:$SG11005
	call	AddLineQueueX

; 244  :         break;

	jmp	$LN2@Simplified
$LN24@Simplified:

; 245  :     case SIM_STACK: /* .stack */
; 246  :         /* if code is generated which does "emit" bytes,
; 247  :          * the original source line has to be saved.
; 248  :          * v2.05: must not be done after LstWrite() has been called!
; 249  :          * Also, there are no longer bytes "emitted".
; 250  :          */
; 251  :         //FStoreLine();
; 252  :         SetSimSeg( SIM_STACK, NULL );

	xor	edx, edx
	mov	ecx, 1
	call	SetSimSeg

; 253  :         AddLineQueueX( "ORG 0%xh", opndx.value );

	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN33@Simplified
	lea	rcx, OFFSET FLAT:SimplifiedSegDir$rtcName$0
	call	_RTC_UninitUse
$LN33@Simplified:
	mov	edx, DWORD PTR opndx$[rsp]
	lea	rcx, OFFSET FLAT:$SG11007
	call	AddLineQueueX

; 254  :         EndSimSeg( SIM_STACK );

	mov	ecx, 1
	call	EndSimSeg

; 255  :         /* add stack to dgroup for some segmented models */
; 256  :         if ( !init )

	cmp	BYTE PTR $T6[rsp], 0
	jne	SHORT $LN34@Simplified
	lea	rcx, OFFSET FLAT:SimplifiedSegDir$rtcName$1
	call	_RTC_UninitUse
$LN34@Simplified:
	movsx	eax, BYTE PTR init$[rsp]
	test	eax, eax
	jne	SHORT $LN25@Simplified

; 257  :             if ( ModuleInfo.distance != STACK_FAR )

	cmp	DWORD PTR ModuleInfo+356, 1
	je	SHORT $LN26@Simplified

; 258  :                 AddToDgroup( SIM_STACK, NULL );

	xor	edx, edx
	mov	ecx, 1
	call	AddToDgroup
$LN26@Simplified:
$LN25@Simplified:

; 259  :         break;

	jmp	$LN2@Simplified
$LN27@Simplified:

; 260  :     case SIM_DATA:    /* .data  */
; 261  :     case SIM_DATA_UN: /* .data? */
; 262  :     case SIM_CONST:   /* .const */
; 263  :         SetSimSeg( type, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, DWORD PTR type$[rsp]
	call	SetSimSeg

; 264  :         AddLineQueueX( "%r %r:ERROR", T_ASSUME, T_CS );

	mov	r8d, 26
	mov	edx, 439				; 000001b7H
	lea	rcx, OFFSET FLAT:$SG11011
	call	AddLineQueueX

; 265  :         if ( name || (!init) )

	cmp	QWORD PTR name$[rsp], 0
	jne	SHORT $LN29@Simplified
	cmp	BYTE PTR $T6[rsp], 0
	jne	SHORT $LN35@Simplified
	lea	rcx, OFFSET FLAT:SimplifiedSegDir$rtcName$1
	call	_RTC_UninitUse
$LN35@Simplified:
	movsx	eax, BYTE PTR init$[rsp]
	test	eax, eax
	jne	SHORT $LN28@Simplified
$LN29@Simplified:

; 266  :             AddToDgroup( type, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, DWORD PTR type$[rsp]
	call	AddToDgroup
$LN28@Simplified:

; 267  :         break;

	jmp	SHORT $LN2@Simplified
$LN30@Simplified:

; 268  :     case SIM_FARDATA:     /* .fardata  */
; 269  :     case SIM_FARDATA_UN:  /* .fardata? */
; 270  :         SetSimSeg( type, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, DWORD PTR type$[rsp]
	call	SetSimSeg

; 271  :         AddLineQueueX( "%r %r:ERROR", T_ASSUME, T_CS );

	mov	r8d, 26
	mov	edx, 439				; 000001b7H
	lea	rcx, OFFSET FLAT:$SG11015
	call	AddLineQueueX

; 272  :         break;

	jmp	SHORT $LN2@Simplified
$LN31@Simplified:

; 273  :     default: /* shouldn't happen */
; 274  :         /**/myassert( 0 );

	mov	edx, 274				; 00000112H
	lea	rcx, OFFSET FLAT:$SG11017
	call	InternalError
$LN2@Simplified:

; 275  :         break;
; 276  :     }
; 277  : 
; 278  :     RunLineQueue();

	call	RunLineQueue

; 279  : 
; 280  :     DebugMsg1(("SimplifiedSegDir exit\n"));

	lea	rcx, OFFSET FLAT:$SG11018
	call	DoDebugMsg1

; 281  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@Simplified:

; 282  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:SimplifiedSegDir$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 208				; 000000d0H
	pop	rdi
	ret	0
$LN36@Simplified:
	DD	$LN17@Simplified
	DD	$LN24@Simplified
	DD	$LN27@Simplified
	DD	$LN27@Simplified
	DD	$LN30@Simplified
	DD	$LN30@Simplified
	DD	$LN27@Simplified
SimplifiedSegDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_TEXT	SEGMENT
segm$ = 48
EndSimSeg PROC

; 165  : {

	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 166  :     AddLineQueueX( "%s %r", SegmNames[segm], T_ENDS );

	movsxd	rax, DWORD PTR segm$[rsp]
	lea	rcx, OFFSET FLAT:SegmNames
	mov	r8d, 437				; 000001b5H
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, OFFSET FLAT:$SG10963
	call	AddLineQueueX

; 167  :     return;
; 168  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
EndSimSeg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_TEXT	SEGMENT
pAlign$ = 64
pAlignSt$ = 72
pUse$ = 80
sym$ = 88
pFmt$ = 96
pClass$ = 104
tv192 = 112
tv200 = 116
segm$ = 144
name$ = 152
SetSimSeg PROC

; 97   : {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rdi, rsp
	mov	ecx, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+144]

; 98   :     char *pAlign = "WORD";

	lea	rax, OFFSET FLAT:$SG10931
	mov	QWORD PTR pAlign$[rsp], rax

; 99   :     char *pAlignSt = "PARA";

	lea	rax, OFFSET FLAT:$SG10932
	mov	QWORD PTR pAlignSt$[rsp], rax

; 100  :     char *pUse = "";

	lea	rax, OFFSET FLAT:$SG10933
	mov	QWORD PTR pUse$[rsp], rax

; 101  :     struct asym *sym;
; 102  :     const char *pFmt;
; 103  :     const char *pClass;
; 104  : 
; 105  :     if ( ModuleInfo.defOfssize > USE16 ) {

	movzx	eax, BYTE PTR ModuleInfo+405
	test	eax, eax
	jle	SHORT $LN2@SetSimSeg

; 106  :         if ( ModuleInfo.model == MODEL_FLAT )

	cmp	DWORD PTR ModuleInfo+360, 7
	jne	SHORT $LN3@SetSimSeg

; 107  :             pUse = "FLAT";

	lea	rax, OFFSET FLAT:$SG10937
	mov	QWORD PTR pUse$[rsp], rax
	jmp	SHORT $LN4@SetSimSeg
$LN3@SetSimSeg:

; 108  :         else
; 109  :             pUse = "USE32";

	lea	rax, OFFSET FLAT:$SG10938
	mov	QWORD PTR pUse$[rsp], rax
$LN4@SetSimSeg:

; 110  :         if (( ModuleInfo.curr_cpu & P_CPU_MASK ) <= P_386 )

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jg	SHORT $LN5@SetSimSeg

; 111  :             pAlign = "DWORD";

	lea	rax, OFFSET FLAT:$SG10941
	mov	QWORD PTR pAlign$[rsp], rax
	jmp	SHORT $LN6@SetSimSeg
$LN5@SetSimSeg:

; 112  :         else
; 113  :             pAlign = "PARA";

	lea	rax, OFFSET FLAT:$SG10942
	mov	QWORD PTR pAlign$[rsp], rax
$LN6@SetSimSeg:

; 114  :         pAlignSt = pAlign;

	mov	rax, QWORD PTR pAlign$[rsp]
	mov	QWORD PTR pAlignSt$[rsp], rax
$LN2@SetSimSeg:

; 115  :     }
; 116  : 
; 117  :     if ( segm == SIM_CODE )

	cmp	DWORD PTR segm$[rsp], 0
	jne	SHORT $LN7@SetSimSeg

; 118  :         pClass = GetCodeClass();

	call	GetCodeClass
	mov	QWORD PTR pClass$[rsp], rax
	jmp	SHORT $LN8@SetSimSeg
$LN7@SetSimSeg:

; 119  :     else
; 120  :         pClass = SegmClass[segm];

	movsxd	rax, DWORD PTR segm$[rsp]
	lea	rcx, OFFSET FLAT:SegmClass
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR pClass$[rsp], rax
$LN8@SetSimSeg:

; 121  : 
; 122  :     if ( segm == SIM_STACK || segm == SIM_FARDATA || segm == SIM_FARDATA_UN )

	cmp	DWORD PTR segm$[rsp], 1
	je	SHORT $LN10@SetSimSeg
	cmp	DWORD PTR segm$[rsp], 4
	je	SHORT $LN10@SetSimSeg
	cmp	DWORD PTR segm$[rsp], 5
	jne	SHORT $LN9@SetSimSeg
$LN10@SetSimSeg:

; 123  :         pAlign = pAlignSt;

	mov	rax, QWORD PTR pAlignSt$[rsp]
	mov	QWORD PTR pAlign$[rsp], rax
$LN9@SetSimSeg:

; 124  : 
; 125  :     pFmt = "%s %r %s %s %s '%s'";

	lea	rax, OFFSET FLAT:$SG10947
	mov	QWORD PTR pFmt$[rsp], rax

; 126  :     if ( name == NULL ) {

	cmp	QWORD PTR name$[rsp], 0
	jne	$LN11@SetSimSeg

; 127  :         name = SegmNames[segm];

	movsxd	rax, DWORD PTR segm$[rsp]
	lea	rcx, OFFSET FLAT:SegmNames
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR name$[rsp], rax

; 128  :         if ( ModuleInfo.simseg_init & ( 1 << segm ) )

	movzx	eax, BYTE PTR ModuleInfo+420
	mov	ecx, DWORD PTR segm$[rsp]
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN13@SetSimSeg

; 129  :             pFmt = "%s %r";

	lea	rax, OFFSET FLAT:$SG10952
	mov	QWORD PTR pFmt$[rsp], rax
	jmp	$LN14@SetSimSeg
$LN13@SetSimSeg:

; 130  :         else {
; 131  :             ModuleInfo.simseg_init |= ( 1 << segm );

	mov	eax, DWORD PTR segm$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv192[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv192[rsp]
	shl	eax, cl
	movzx	ecx, BYTE PTR ModuleInfo+420
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR ModuleInfo+420, al

; 132  :             /* v2.05: if segment exists already, use the current attribs.
; 133  :              * This allows a better mix of full and simplified segment
; 134  :              * directives. Masm behaves differently: the attributes
; 135  :              * of the simplified segment directives have highest priority.
; 136  :              */
; 137  :             if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN15@SetSimSeg

; 138  :                 sym = SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 139  :                 /* v2.12: check 'isdefined' member instead of 'lname_idx' */
; 140  :                 //if ( sym && sym->state == SYM_SEG && ((struct dsym *)sym)->e.seginfo->lname_idx != 0 )
; 141  :                 if ( sym && sym->state == SYM_SEG && sym->isdefined == TRUE )

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN16@SetSimSeg
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 3
	jne	SHORT $LN16@SetSimSeg
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN16@SetSimSeg

; 142  :                     ModuleInfo.simseg_defd |= ( 1 << segm );

	mov	eax, DWORD PTR segm$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv200[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv200[rsp]
	shl	eax, cl
	movzx	ecx, BYTE PTR ModuleInfo+421
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR ModuleInfo+421, al
$LN16@SetSimSeg:
$LN15@SetSimSeg:

; 143  :             }
; 144  :             if ( ModuleInfo.simseg_defd & ( 1 << segm ) )

	movzx	eax, BYTE PTR ModuleInfo+421
	mov	ecx, DWORD PTR segm$[rsp]
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN17@SetSimSeg

; 145  :                 pFmt = "%s %r";

	lea	rax, OFFSET FLAT:$SG10956
	mov	QWORD PTR pFmt$[rsp], rax
$LN17@SetSimSeg:
$LN14@SetSimSeg:

; 146  :         }
; 147  :     } else {

	jmp	SHORT $LN12@SetSimSeg
$LN11@SetSimSeg:

; 148  :         sym = SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 149  :         /* v2.04: testing for state SYM_SEG isn't enough. The segment
; 150  :          * might have been "defined" by a GROUP directive. Additional
; 151  :          * check for segment's lname index is needed.
; 152  :          * v2.12: check 'isdefined' member instead of 'lname_idx'
; 153  :          */
; 154  :         //if ( sym && sym->state == SYM_SEG )
; 155  :         //if ( sym && sym->state == SYM_SEG && ((struct dsym *)sym)->e.seginfo->lname_idx != 0 )
; 156  :         if ( sym && sym->state == SYM_SEG && sym->isdefined == TRUE )

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN18@SetSimSeg
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 3
	jne	SHORT $LN18@SetSimSeg
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN18@SetSimSeg

; 157  :             pFmt = "%s %r";

	lea	rax, OFFSET FLAT:$SG10958
	mov	QWORD PTR pFmt$[rsp], rax
$LN18@SetSimSeg:
$LN12@SetSimSeg:

; 158  :     }
; 159  :     AddLineQueueX( pFmt, name, T_SEGMENT, pAlign, pUse, SegmCombine[segm], pClass );

	movsxd	rax, DWORD PTR segm$[rsp]
	lea	rcx, OFFSET FLAT:SegmCombine
	mov	rdx, QWORD PTR pClass$[rsp]
	mov	QWORD PTR [rsp+48], rdx
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR pUse$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR pAlign$[rsp]
	mov	r8d, 436				; 000001b4H
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR pFmt$[rsp]
	call	AddLineQueueX

; 160  :     return;
; 161  : }

	add	rsp, 128				; 00000080H
	pop	rdi
	ret	0
SetSimSeg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_TEXT	SEGMENT
close_currseg PROC

; 84   : {

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 85   :     if ( CurrSeg ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN2@close_curr

; 86   :         DebugMsg1(("close_currseg: current seg=%s\n", CurrSeg->sym.name));

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10916
	call	DoDebugMsg1

; 87   :         AddLineQueueX( "%s %r", CurrSeg->sym.name, T_ENDS );

	mov	r8d, 437				; 000001b5H
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10917
	call	AddLineQueueX
$LN2@close_curr:

; 88   :     }
; 89   : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
close_currseg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_TEXT	SEGMENT
segm$ = 48
name$ = 56
AddToDgroup PROC

; 62   : {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 63   :     /* no DGROUP for FLAT or COFF/ELF */
; 64   :     if( ModuleInfo.model == MODEL_FLAT
; 65   : #if COFF_SUPPORT
; 66   :        || Options.output_format == OFORMAT_COFF
; 67   : #endif
; 68   : #if ELF_SUPPORT
; 69   :        || Options.output_format == OFORMAT_ELF

	cmp	DWORD PTR ModuleInfo+360, 7
	je	SHORT $LN3@AddToDgrou
	cmp	DWORD PTR Options+160, 2
	je	SHORT $LN3@AddToDgrou
	cmp	DWORD PTR Options+160, 3
	jne	SHORT $LN2@AddToDgrou
$LN3@AddToDgrou:

; 70   : #endif
; 71   :       )
; 72   :         return;

	jmp	SHORT $LN1@AddToDgrou
$LN2@AddToDgrou:

; 73   : 
; 74   :     if( name == NULL )

	cmp	QWORD PTR name$[rsp], 0
	jne	SHORT $LN4@AddToDgrou

; 75   :         name = SegmNames[segm];

	movsxd	rax, DWORD PTR segm$[rsp]
	lea	rcx, OFFSET FLAT:SegmNames
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR name$[rsp], rax
$LN4@AddToDgrou:

; 76   : 
; 77   :     AddLineQueueX( "%s %r %s", szDgroup, T_GROUP, name );

	mov	r9, QWORD PTR name$[rsp]
	mov	r8d, 438				; 000001b6H
	lea	rdx, OFFSET FLAT:szDgroup
	lea	rcx, OFFSET FLAT:$SG10911
	call	AddLineQueueX
$LN1@AddToDgrou:

; 78   : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
AddToDgroup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_TEXT	SEGMENT
tv83 = 32
tv190 = 40
tv91 = 48
tv140 = 56
tv158 = 64
SetModelDefaultSegNames PROC

; 291  : {

$LN7:
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 292  :     /* init segment names with default values */
; 293  :     memcpy( SegmNames, SegmNamesDef, sizeof(SegmNames) );

	mov	r8d, 56					; 00000038H
	lea	rdx, OFFSET FLAT:SegmNamesDef
	lea	rcx, OFFSET FLAT:SegmNames
	call	memcpy

; 294  : 
; 295  :     /* option -nt set? */
; 296  :     if( Options.names[OPTN_TEXT_SEG] ) {

	mov	eax, 8
	imul	rax, rax, 6
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN2@SetModelDe

; 297  :         SegmNames[SIM_CODE] = LclAlloc( strlen( Options.names[OPTN_TEXT_SEG] ) + 1 );

	mov	eax, 8
	imul	rax, rax, 6
	lea	rcx, OFFSET FLAT:Options+32
	mov	rcx, QWORD PTR [rcx+rax]
	call	strlen
	inc	rax
	mov	rcx, rax
	call	LclAlloc
	mov	ecx, 8
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:SegmNames
	mov	QWORD PTR [rdx+rcx], rax

; 298  :         strcpy( SegmNames[SIM_CODE], Options.names[OPTN_TEXT_SEG] );

	mov	eax, 8
	imul	rax, rax, 6
	lea	rcx, OFFSET FLAT:Options+32
	mov	edx, 8
	imul	rdx, rdx, 0
	mov	QWORD PTR tv83[rsp], rdx
	lea	r8, OFFSET FLAT:SegmNames
	mov	rdx, QWORD PTR [rcx+rax]
	mov	rax, QWORD PTR tv83[rsp]
	mov	rcx, QWORD PTR [r8+rax]
	call	strcpy

; 299  :     } else {

	jmp	$LN3@SetModelDe
$LN2@SetModelDe:

; 300  :         if ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) {

	mov	eax, DWORD PTR ModuleInfo+360
	mov	ecx, 1
	mov	DWORD PTR tv190[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv190[rsp]
	shl	eax, cl
	and	eax, 112				; 00000070H
	test	eax, eax
	je	$LN4@SetModelDe

; 301  :             /* for some models, the code segment contains the module name */
; 302  :             SegmNames[SIM_CODE] = LclAlloc( strlen( SegmNamesDef[SIM_CODE] ) + strlen( ModuleInfo.name ) + 1 );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SegmNamesDef
	mov	rcx, QWORD PTR [rcx+rax]
	call	strlen
	mov	QWORD PTR tv91[rsp], rax
	lea	rcx, OFFSET FLAT:ModuleInfo+512
	call	strlen
	mov	rcx, QWORD PTR tv91[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	rcx, rax
	call	LclAlloc
	mov	ecx, 8
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:SegmNames
	mov	QWORD PTR [rdx+rcx], rax

; 303  :             strcpy( SegmNames[SIM_CODE], ModuleInfo.name );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SegmNames
	lea	rdx, OFFSET FLAT:ModuleInfo+512
	mov	rcx, QWORD PTR [rcx+rax]
	call	strcpy

; 304  :             strcat( SegmNames[SIM_CODE], SegmNamesDef[SIM_CODE] );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SegmNamesDef
	mov	edx, 8
	imul	rdx, rdx, 0
	mov	QWORD PTR tv140[rsp], rdx
	lea	r8, OFFSET FLAT:SegmNames
	mov	rdx, QWORD PTR [rcx+rax]
	mov	rax, QWORD PTR tv140[rsp]
	mov	rcx, QWORD PTR [r8+rax]
	call	strcat
$LN4@SetModelDe:
$LN3@SetModelDe:

; 305  :         }
; 306  :     }
; 307  : 
; 308  :     /* option -nd set? */
; 309  :     if ( Options.names[OPTN_DATA_SEG] ) {

	mov	eax, 8
	imul	rax, rax, 7
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN5@SetModelDe

; 310  :         SegmNames[SIM_DATA] = LclAlloc( strlen( Options.names[OPTN_DATA_SEG] ) + 1 );

	mov	eax, 8
	imul	rax, rax, 7
	lea	rcx, OFFSET FLAT:Options+32
	mov	rcx, QWORD PTR [rcx+rax]
	call	strlen
	inc	rax
	mov	rcx, rax
	call	LclAlloc
	mov	ecx, 8
	imul	rcx, rcx, 2
	lea	rdx, OFFSET FLAT:SegmNames
	mov	QWORD PTR [rdx+rcx], rax

; 311  :         strcpy( SegmNames[SIM_DATA], Options.names[OPTN_DATA_SEG] );

	mov	eax, 8
	imul	rax, rax, 7
	lea	rcx, OFFSET FLAT:Options+32
	mov	edx, 8
	imul	rdx, rdx, 2
	mov	QWORD PTR tv158[rsp], rdx
	lea	r8, OFFSET FLAT:SegmNames
	mov	rdx, QWORD PTR [rcx+rax]
	mov	rax, QWORD PTR tv158[rsp]
	mov	rcx, QWORD PTR [r8+rax]
	call	strcpy
$LN5@SetModelDe:

; 312  :     }
; 313  :     return;
; 314  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
SetModelDefaultSegNames ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_TEXT	SEGMENT
ModelSimSegmExit PROC

; 361  : {

$LN4:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 362  :     /* a model is set. Close current segment if one is open. */
; 363  :     if ( CurrSeg ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN2@ModelSimSe

; 364  :         close_currseg();

	call	close_currseg

; 365  :         RunLineQueue();

	call	RunLineQueue
$LN2@ModelSimSe:

; 366  :     }
; 367  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ModelSimSegmExit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_TEXT	SEGMENT
buffer$ = 56
__$ArrayPad$ = 96
model$ = 128
ModelSimSegmInit PROC

; 323  : {

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+128]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 324  :     char buffer[20];
; 325  : 
; 326  :     ModuleInfo.simseg_init = 0; /* v2.09: reset init flags */

	mov	BYTE PTR ModuleInfo+420, 0

; 327  :     /* v2.09: execute always, to make a proper listing if fastpass is off */
; 328  :     //if ( Parse_Pass == PASS_1 ) {
; 329  :         DebugMsg1(("ModelSimSegmInit() enter, pass one\n" ));

	lea	rcx, OFFSET FLAT:$SG11031
	call	DoDebugMsg1

; 330  :         /* create default code segment (_TEXT) */
; 331  :         SetSimSeg( SIM_CODE, NULL );

	xor	edx, edx
	xor	ecx, ecx
	call	SetSimSeg

; 332  :         EndSimSeg( SIM_CODE );

	xor	ecx, ecx
	call	EndSimSeg

; 333  : 
; 334  :         /* create default data segment (_DATA) */
; 335  :         SetSimSeg( SIM_DATA, NULL ) ;

	xor	edx, edx
	mov	ecx, 2
	call	SetSimSeg

; 336  :         EndSimSeg( SIM_DATA );

	mov	ecx, 2
	call	EndSimSeg

; 337  : 
; 338  :         /* create DGROUP for BIN/OMF if model isn't FLAT */
; 339  :         if( model != MODEL_FLAT &&

	cmp	DWORD PTR model$[rsp], 7
	je	$LN2@ModelSimSe
	cmp	DWORD PTR Options+160, 1
	je	SHORT $LN3@ModelSimSe
	cmp	DWORD PTR Options+160, 0
	jne	$LN2@ModelSimSe
$LN3@ModelSimSe:

; 340  :            ( Options.output_format == OFORMAT_OMF
; 341  : #if BIN_SUPPORT
; 342  :             || Options.output_format == OFORMAT_BIN
; 343  : #endif
; 344  :            )) {
; 345  :             strcpy( buffer, "%s %r %s" );

	lea	rdx, OFFSET FLAT:$SG11034
	lea	rcx, QWORD PTR buffer$[rsp]
	call	strcpy

; 346  :             if( model == MODEL_TINY ) {

	cmp	DWORD PTR model$[rsp], 1
	jne	SHORT $LN4@ModelSimSe

; 347  :                 strcat( buffer, ", %s" );

	lea	rdx, OFFSET FLAT:$SG11037
	lea	rcx, QWORD PTR buffer$[rsp]
	call	strcat

; 348  :                 AddLineQueueX( buffer, szDgroup, T_GROUP, SegmNames[SIM_CODE], SegmNames[SIM_DATA] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SegmNames
	mov	edx, 8
	imul	rdx, rdx, 0
	lea	r8, OFFSET FLAT:SegmNames
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR [r8+rdx]
	mov	r8d, 438				; 000001b6H
	lea	rdx, OFFSET FLAT:szDgroup
	lea	rcx, QWORD PTR buffer$[rsp]
	call	AddLineQueueX

; 349  :             } else

	jmp	SHORT $LN5@ModelSimSe
$LN4@ModelSimSe:

; 350  :                 AddLineQueueX( buffer, szDgroup, T_GROUP, SegmNames[SIM_DATA] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SegmNames
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 438				; 000001b6H
	lea	rdx, OFFSET FLAT:szDgroup
	lea	rcx, QWORD PTR buffer$[rsp]
	call	AddLineQueueX
$LN5@ModelSimSe:
$LN2@ModelSimSe:

; 351  :         }
; 352  :         DebugMsg1(("ModelSimSegmInit() exit\n" ));

	lea	rcx, OFFSET FLAT:$SG11038
	call	DoDebugMsg1

; 353  :     //}
; 354  :     return( NOT_ERROR );

	xor	eax, eax

; 355  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:ModelSimSegmInit$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
ModelSimSegmInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_TEXT	SEGMENT
GetCodeClass PROC

; 50   : {

$LN4:
	push	rdi

; 51   :     /* option -nc set? */
; 52   :     if ( Options.names[OPTN_CODE_CLASS] )

	mov	eax, 8
	imul	rax, rax, 8
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN2@GetCodeCla

; 53   :         return( Options.names[OPTN_CODE_CLASS] );

	mov	eax, 8
	imul	rax, rax, 8
	lea	rcx, OFFSET FLAT:Options+32
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@GetCodeCla
$LN2@GetCodeCla:

; 54   : 
; 55   :     return( SegmClass[SIM_CODE] );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SegmClass
	mov	rax, QWORD PTR [rcx+rax]
$LN1@GetCodeCla:

; 56   : }

	pop	rdi
	ret	0
GetCodeClass ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_TEXT	SEGMENT
segno$ = 16
SimGetSegName PROC

; 44   : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	push	rdi

; 45   :     return( SegmNames[segno] );

	movsxd	rax, DWORD PTR segno$[rsp]
	lea	rcx, OFFSET FLAT:SegmNames
	mov	rax, QWORD PTR [rcx+rax*8]

; 46   : }

	pop	rdi
	ret	0
SimGetSegName ENDP
_TEXT	ENDS
END
