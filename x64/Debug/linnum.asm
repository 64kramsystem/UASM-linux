; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11447 DB	'linnum.c', 00H
	ORG $+7
$SG11448 DB	'$$$%05u', 00H
$SG11449 DB	'NULL', 00H
	ORG $+3
$SG11450 DB	'AddLinnumDataRef(src=%u.%u): CurrProc==NULL, dmyproc=%s '
	DB	'searching proc=%s', 0aH, 00H
	ORG $+5
$SG11453 DB	'AddLinnumDataRef: new proc %s created', 0aH, 00H
	ORG $+1
$SG11460 DB	'AddLinnumDataRef(src=%u.%u) line skipped, lastline=%u', 0aH
	DB	00H
	ORG $+1
$SG11456 DB	'AddLinnumDataRef: CURRPROC=NULL, sym=%s, calling AddLinn'
	DB	'umData(src=%u.%u)', 0aH, 00H
	ORG $+1
$SG11461 DB	'NULL', 00H
	ORG $+7
$SG11469 DB	'AddLinnumDataRef: calling AddLinnumData(src=%u.%u) sym=%'
	DB	's', 0aH, 00H
	ORG $+5
$SG11498 DB	'LinnumFini: last dummy proc size=%Xh', 0aH, 00H
	ORG $+2
$SG11462 DB	'AddLinnumDataRef(src=%u.%u): currofs=%Xh, CurrProc=%s, G'
	DB	'eneratedCode=%u', 0aH, 00H
	ORG $+7
$SG11467 DB	'linnum.c', 00H
	ORG $+7
$SG11473 DB	'AddLinnumDataRef: calling AddLinnumData(src=%u.%u ofs=%X'
	DB	')', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	AddLinnumDataRef
PUBLIC	LinnumInit
PUBLIC	LinnumFini
PUBLIC	QueueDeleteLinnum
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitWarn:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymFind:PROC
EXTRN	GetLineNumber:PROC
EXTRN	SetSymSegOfs:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	TypeFromClassName:PROC
EXTRN	CreateProc:PROC
EXTRN	AddPublicData:PROC
EXTRN	InternalError:PROC
EXTRN	omf_check_flush:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	write_to_file:BYTE
EXTRN	CurrProc:QWORD
EXTRN	LinnumQueue:BYTE
EXTRN	procidx:DWORD
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
dmyproc	DQ	01H DUP (?)
lastLineNumber DD 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$AddLinnumDataRef DD imagerel $LN33
	DD	imagerel $LN33+1749
	DD	imagerel $unwind$AddLinnumDataRef
$pdata$LinnumFini DD imagerel $LN4
	DD	imagerel $LN4+71
	DD	imagerel $unwind$LinnumFini
$pdata$QueueDeleteLinnum DD imagerel $LN13
	DD	imagerel $LN13+136
	DD	imagerel $unwind$QueueDeleteLinnum
$pdata$AddLinnumData DD imagerel AddLinnumData
	DD	imagerel AddLinnumData+302
	DD	imagerel $unwind$AddLinnumData
pdata	ENDS
xdata	SEGMENT
$unwind$AddLinnumDataRef DD 021e19H
	DD	011010fH
	DD	imagerel __GSHandlerCheck
	DD	078H
$unwind$LinnumFini DD 010401H
	DD	04204H
$unwind$QueueDeleteLinnum DD 010901H
	DD	02209H
$unwind$AddLinnumData DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\linnum.c
_TEXT	SEGMENT
q$ = 32
data$ = 64
AddLinnumData PROC

; 40   : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 41   :     struct qdesc *q;
; 42   :    
; 43   : #if COFF_SUPPORT
; 44   :     if ( Options.output_format == OFORMAT_COFF ) {

	cmp	DWORD PTR Options+160, 2
	jne	SHORT $LN2@AddLinnumD

; 45   :         q = (struct qdesc *)CurrSeg->e.seginfo->LinnumQueue;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR q$[rsp], rax

; 46   :         if ( q == NULL ) {

	cmp	QWORD PTR q$[rsp], 0
	jne	SHORT $LN4@AddLinnumD

; 47   :             q = LclAlloc( sizeof( struct qdesc ) );

	mov	ecx, 16
	call	LclAlloc
	mov	QWORD PTR q$[rsp], rax

; 48   :             CurrSeg->e.seginfo->LinnumQueue = q;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR q$[rsp]
	mov	QWORD PTR [rax+56], rcx

; 49   :             q->head = NULL;

	mov	rax, QWORD PTR q$[rsp]
	mov	QWORD PTR [rax], 0
$LN4@AddLinnumD:

; 50   :         }
; 51   :     }

	jmp	SHORT $LN3@AddLinnumD
$LN2@AddLinnumD:

; 52   :     else
; 53   : #endif
; 54   :         q = &LinnumQueue;

	lea	rax, OFFSET FLAT:LinnumQueue
	mov	QWORD PTR q$[rsp], rax
$LN3@AddLinnumD:

; 55   : 
; 56   :     data->next = NULL;

	mov	rax, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax], 0

; 57   :     if ( q->head == NULL)

	mov	rax, QWORD PTR q$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN5@AddLinnumD

; 58   :         q->head = q->tail = data;

	mov	rax, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax], rcx
	jmp	$LN6@AddLinnumD
$LN5@AddLinnumD:

; 59   :     else {
; 60   :       if (ModuleInfo.Ofssize == USE32) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jne	SHORT $LN7@AddLinnumD

; 61   :         if ((q->tail && ((uint_32)q->tail < 0x00FFFFFF))) {

	mov	rax, QWORD PTR q$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN9@AddLinnumD
	mov	rax, QWORD PTR q$[rsp]
	cmp	DWORD PTR [rax+8], 16777215		; 00ffffffH
	jae	SHORT $LN9@AddLinnumD

; 62   :           ((struct line_num_info *)q->tail)->next = data;

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax], rcx

; 63   :           q->tail = data;

	mov	rax, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN9@AddLinnumD:

; 64   :           }
; 65   :         }

	jmp	SHORT $LN8@AddLinnumD
$LN7@AddLinnumD:

; 66   : #if AMD64_SUPPORT
; 67   :       else{
; 68   :         if (q->tail && ((uint_64)q->tail < 0x00007FFFFFFFFFFF)) {

	mov	rax, QWORD PTR q$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN10@AddLinnumD
	mov	rax, QWORD PTR q$[rsp]
	mov	rcx, 140737488355327			; 00007fffffffffffH
	cmp	QWORD PTR [rax+8], rcx
	jae	SHORT $LN10@AddLinnumD

; 69   :           ((struct line_num_info *)q->tail)->next = data;

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax], rcx

; 70   :           q->tail = data;

	mov	rax, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN10@AddLinnumD:
$LN8@AddLinnumD:
$LN6@AddLinnumD:

; 71   :         }
; 72   :       }
; 73   : #endif
; 74   :     }
; 75   : }

	add	rsp, 56					; 00000038H
	ret	0
AddLinnumData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\linnum.c
_TEXT	SEGMENT
curr$ = 0
next$ = 8
queue$ = 32
QueueDeleteLinnum PROC

; 216  : {

$LN13:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 217  :     struct line_num_info    *curr;
; 218  :     struct line_num_info    *next;
; 219  : 
; 220  :     if ( queue == NULL )

	cmp	QWORD PTR queue$[rsp], 0
	jne	SHORT $LN5@QueueDelet

; 221  :         return;

	jmp	SHORT $LN1@QueueDelet
$LN5@QueueDelet:

; 222  :     curr = queue->head;

	mov	rax, QWORD PTR queue$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$[rsp], rax

; 223  :     for( ; curr ; curr = next ) {

	jmp	SHORT $LN4@QueueDelet
$LN2@QueueDelet:
	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR curr$[rsp], rax
$LN4@QueueDelet:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@QueueDelet

; 224  :       if (ModuleInfo.Ofssize == USE32) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jne	SHORT $LN6@QueueDelet

; 225  :           if (((uint_32) curr > 0x00FFFFFF) || ((uint_32)curr < 0x07FFFF))

	cmp	DWORD PTR curr$[rsp], 16777215		; 00ffffffH
	ja	SHORT $LN9@QueueDelet
	cmp	DWORD PTR curr$[rsp], 524287		; 0007ffffH
	jae	SHORT $LN8@QueueDelet
$LN9@QueueDelet:

; 226  :             break;

	jmp	SHORT $LN3@QueueDelet
$LN8@QueueDelet:

; 227  :       }

	jmp	SHORT $LN7@QueueDelet
$LN6@QueueDelet:

; 228  : #if AMD64_SUPPORT
; 229  :       else {
; 230  :         if (((uint_64)curr > 0x00007FFFFFFFFFFF)|| ((uint_64)curr < 0x00007FFFFFFFF))

	mov	rax, 140737488355327			; 00007fffffffffffH
	cmp	QWORD PTR curr$[rsp], rax
	ja	SHORT $LN11@QueueDelet
	mov	rax, 34359738367			; 00000007ffffffffH
	cmp	QWORD PTR curr$[rsp], rax
	jae	SHORT $LN10@QueueDelet
$LN11@QueueDelet:

; 231  :           break;

	jmp	SHORT $LN3@QueueDelet
$LN10@QueueDelet:
$LN7@QueueDelet:

; 232  :       }
; 233  : #endif
; 234  :         next = curr->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR next$[rsp], rax

; 235  :         LclFree( curr );
; 236  :     }

	jmp	SHORT $LN2@QueueDelet
$LN3@QueueDelet:
$LN1@QueueDelet:

; 237  :     return;
; 238  : }

	add	rsp, 24
	ret	0
QueueDeleteLinnum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\linnum.c
_TEXT	SEGMENT
LinnumFini PROC

; 245  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 246  : #if COFF_SUPPORT
; 247  :     if ( dmyproc ) {

	cmp	QWORD PTR dmyproc, 0
	je	SHORT $LN2@LinnumFini

; 248  :         dmyproc->total_size =

	mov	rax, QWORD PTR dmyproc
	mov	rax, QWORD PTR [rax+32]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR dmyproc
	mov	ecx, DWORD PTR [rcx+16]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	rcx, QWORD PTR dmyproc
	mov	DWORD PTR [rcx+64], eax

; 249  :             ((struct dsym *)dmyproc->segment)->e.seginfo->current_loc -
; 250  :             dmyproc->offset;
; 251  :         DebugMsg(("LinnumFini: last dummy proc size=%Xh\n"));

	lea	rcx, OFFSET FLAT:$SG11498
	call	DoDebugMsg
$LN2@LinnumFini:

; 252  :     }
; 253  : #endif
; 254  : }

	add	rsp, 40					; 00000028H
	ret	0
LinnumFini ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\linnum.c
_TEXT	SEGMENT
LinnumInit PROC

; 259  :     lastLineNumber = 0;

	mov	DWORD PTR lastLineNumber, 0

; 260  : #if COFF_SUPPORT
; 261  :     dmyproc = NULL;

	mov	QWORD PTR dmyproc, 0

; 262  : #endif
; 263  : }

	ret	0
LinnumInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\linnum.c
_TEXT	SEGMENT
curr$ = 48
tv310 = 56
tv79 = 60
tv161 = 64
tv226 = 68
tv243 = 72
tv92 = 80
tv198 = 88
tv223 = 96
procname$1 = 104
__$ArrayPad$ = 120
srcfile$ = 144
line_num$ = 152
AddLinnumDataRef PROC

; 85   : {

$LN33:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 86   :     struct line_num_info    *curr;
; 87   : 
; 88   : #if COFF_SUPPORT
; 89   :     /* COFF line number info is related to functions/procedures. Since
; 90   :      * assembly allows code lines outside of procs, "dummy" procs must
; 91   :      * be generated. A dummy proc lasts until
; 92   :      * - a true PROC is detected or
; 93   :      * - the source file changes or
; 94   :      * - the segment/section changes ( added in v2.11 )
; 95   :      */
; 96   :     if ( Options.output_format == OFORMAT_COFF &&
; 97   :         CurrProc == NULL &&

	cmp	DWORD PTR Options+160, 2
	jne	$LN2@AddLinnumD
	cmp	QWORD PTR CurrProc, 0
	jne	$LN2@AddLinnumD
	cmp	QWORD PTR dmyproc, 0
	je	SHORT $LN3@AddLinnumD
	mov	rax, QWORD PTR dmyproc
	mov	rax, QWORD PTR [rax+72]
	movzx	eax, WORD PTR [rax+14]
	cmp	eax, DWORD PTR srcfile$[rsp]
	jne	SHORT $LN3@AddLinnumD
	mov	rax, QWORD PTR dmyproc
	mov	rcx, QWORD PTR ModuleInfo+432
	cmp	QWORD PTR [rax+32], rcx
	je	$LN2@AddLinnumD
$LN3@AddLinnumD:

; 98   :         ( dmyproc == NULL ||
; 99   :         dmyproc->debuginfo->file != srcfile ||
; 100  :         dmyproc->segment != (struct asym *)CurrSeg ) ) {
; 101  :         char procname[12];
; 102  :         if ( dmyproc ) {

	cmp	QWORD PTR dmyproc, 0
	je	SHORT $LN4@AddLinnumD

; 103  :             /**/myassert( dmyproc->segment );

	mov	rax, QWORD PTR dmyproc
	cmp	QWORD PTR [rax+32], 0
	je	SHORT $LN21@AddLinnumD
	mov	DWORD PTR tv79[rsp], 0
	jmp	SHORT $LN22@AddLinnumD
$LN21@AddLinnumD:
	mov	edx, 103				; 00000067H
	lea	rcx, OFFSET FLAT:$SG11447
	call	InternalError
	mov	DWORD PTR tv79[rsp], eax
$LN22@AddLinnumD:

; 104  :             dmyproc->total_size =

	mov	rax, QWORD PTR dmyproc
	mov	rax, QWORD PTR [rax+32]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR dmyproc
	mov	ecx, DWORD PTR [rcx+16]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	rcx, QWORD PTR dmyproc
	mov	DWORD PTR [rcx+64], eax
$LN4@AddLinnumD:

; 105  :                 ((struct dsym *)dmyproc->segment)->e.seginfo->current_loc -
; 106  :                 dmyproc->offset;
; 107  :         }
; 108  :         sprintf( procname, "$$$%05u", procidx );

	mov	r8d, DWORD PTR procidx
	lea	rdx, OFFSET FLAT:$SG11448
	lea	rcx, QWORD PTR procname$1[rsp]
	call	sprintf

; 109  :         DebugMsg1(("AddLinnumDataRef(src=%u.%u): CurrProc==NULL, dmyproc=%s searching proc=%s\n", srcfile, line_num, dmyproc ? dmyproc->name : "NULL", procname ));

	cmp	QWORD PTR dmyproc, 0
	je	SHORT $LN23@AddLinnumD
	mov	rax, QWORD PTR dmyproc
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv92[rsp], rax
	jmp	SHORT $LN24@AddLinnumD
$LN23@AddLinnumD:
	lea	rax, OFFSET FLAT:$SG11449
	mov	QWORD PTR tv92[rsp], rax
$LN24@AddLinnumD:
	lea	rax, QWORD PTR procname$1[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv92[rsp]
	mov	r8d, DWORD PTR line_num$[rsp]
	mov	edx, DWORD PTR srcfile$[rsp]
	lea	rcx, OFFSET FLAT:$SG11450
	call	DoDebugMsg1

; 110  :         dmyproc = SymSearch( procname );

	lea	rcx, QWORD PTR procname$1[rsp]
	call	SymFind
	mov	QWORD PTR dmyproc, rax

; 111  : 
; 112  :         /* in pass 1, create the proc */
; 113  :         if ( dmyproc == NULL ) {

	cmp	QWORD PTR dmyproc, 0
	jne	SHORT $LN5@AddLinnumD

; 114  :             dmyproc = CreateProc( NULL, procname, SYM_INTERNAL );

	mov	r8d, 1
	lea	rdx, QWORD PTR procname$1[rsp]
	xor	ecx, ecx
	call	CreateProc
	mov	QWORD PTR dmyproc, rax

; 115  :             DebugMsg1(("AddLinnumDataRef: new proc %s created\n", procname ));

	lea	rdx, QWORD PTR procname$1[rsp]
	lea	rcx, OFFSET FLAT:$SG11453
	call	DoDebugMsg1

; 116  :             dmyproc->isproc = TRUE; /* flag is usually set inside ParseProc() */

	mov	rax, QWORD PTR dmyproc
	movzx	eax, BYTE PTR [rax+49]
	or	al, 8
	mov	rcx, QWORD PTR dmyproc
	mov	BYTE PTR [rcx+49], al

; 117  :             dmyproc->included = TRUE;

	mov	rax, QWORD PTR dmyproc
	movzx	eax, BYTE PTR [rax+49]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR dmyproc
	mov	BYTE PTR [rcx+49], al

; 118  :             AddPublicData( dmyproc );

	mov	rcx, QWORD PTR dmyproc
	call	AddPublicData

; 119  :         } else

	jmp	SHORT $LN6@AddLinnumD
$LN5@AddLinnumD:

; 120  :             procidx++; /* for passes > 1, adjust procidx */

	mov	eax, DWORD PTR procidx
	inc	eax
	mov	DWORD PTR procidx, eax
$LN6@AddLinnumD:

; 121  : 
; 122  :         /* if the symbols isn't a PROC, the symbol name has been used
; 123  :          * by the user - bad! A warning should be displayed */
; 124  :         if ( dmyproc->isproc == TRUE ) {

	mov	rax, QWORD PTR dmyproc
	movzx	eax, BYTE PTR [rax+49]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN7@AddLinnumD

; 125  :             SetSymSegOfs( dmyproc );

	mov	rcx, QWORD PTR dmyproc
	call	SetSymSegOfs

; 126  :             dmyproc->Ofssize = ModuleInfo.Ofssize;

	mov	rax, QWORD PTR dmyproc
	movzx	ecx, BYTE PTR ModuleInfo+404
	mov	BYTE PTR [rax+52], cl

; 127  :             dmyproc->langtype = ModuleInfo.langtype;

	mov	rax, QWORD PTR dmyproc
	mov	ecx, DWORD PTR ModuleInfo+364
	mov	DWORD PTR [rax+84], ecx

; 128  :             if ( write_to_file == TRUE ) {

	movzx	eax, BYTE PTR write_to_file
	cmp	eax, 1
	jne	$LN8@AddLinnumD

; 129  :                 curr = LclAlloc( sizeof( struct line_num_info ) );

	mov	ecx, 24
	call	LclAlloc
	mov	QWORD PTR curr$[rsp], rax

; 130  :                 curr->sym = dmyproc;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR dmyproc
	mov	QWORD PTR [rax+16], rcx

; 131  :                 curr->line_number = GetLineNumber();

	call	GetLineNumber
	mov	DWORD PTR tv161[rsp], eax
	mov	eax, DWORD PTR tv161[rsp]
	and	eax, 1048575				; 000fffffH
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	and	ecx, -1048576				; fff00000H
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 132  :                 curr->file = srcfile;

	mov	eax, DWORD PTR srcfile$[rsp]
	and	eax, 4095				; 00000fffH
	shl	eax, 20
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	and	ecx, 1048575				; 000fffffH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 133  :                 curr->number = 0;

	mov	rax, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rax+8], 0

; 134  :                 DebugMsg1(("AddLinnumDataRef: CURRPROC=NULL, sym=%s, calling AddLinnumData(src=%u.%u)\n", curr->sym->name, curr->file, curr->line_number ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+12]
	and	eax, 1048575				; 000fffffH
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	shr	ecx, 20
	and	ecx, 4095				; 00000fffH
	mov	rdx, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	r9d, eax
	mov	r8d, ecx
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG11456
	call	DoDebugMsg1

; 135  :                 AddLinnumData( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	AddLinnumData
$LN8@AddLinnumD:
$LN7@AddLinnumD:
$LN2@AddLinnumD:

; 136  :             }
; 137  :         }
; 138  :     }
; 139  : #endif
; 140  : 
; 141  :     if(  line_num && ( write_to_file == FALSE || lastLineNumber == line_num )) {

	cmp	DWORD PTR line_num$[rsp], 0
	je	SHORT $LN9@AddLinnumD
	movzx	eax, BYTE PTR write_to_file
	test	eax, eax
	je	SHORT $LN10@AddLinnumD
	mov	eax, DWORD PTR line_num$[rsp]
	cmp	DWORD PTR lastLineNumber, eax
	jne	SHORT $LN9@AddLinnumD
$LN10@AddLinnumD:

; 142  : #ifdef DEBUG_OUT
; 143  :         if ( write_to_file == TRUE )

	movzx	eax, BYTE PTR write_to_file
	cmp	eax, 1
	jne	SHORT $LN11@AddLinnumD

; 144  :             DebugMsg1(("AddLinnumDataRef(src=%u.%u) line skipped, lastline=%u\n", srcfile, line_num, lastLineNumber ));

	mov	r9d, DWORD PTR lastLineNumber
	mov	r8d, DWORD PTR line_num$[rsp]
	mov	edx, DWORD PTR srcfile$[rsp]
	lea	rcx, OFFSET FLAT:$SG11460
	call	DoDebugMsg1
$LN11@AddLinnumD:

; 145  : #endif
; 146  :         return;

	jmp	$LN1@AddLinnumD
$LN9@AddLinnumD:

; 147  :     }
; 148  :     DebugMsg1(("AddLinnumDataRef(src=%u.%u): currofs=%Xh, CurrProc=%s, GeneratedCode=%u\n", srcfile, line_num, GetCurrOffset(), CurrProc ? CurrProc->sym.name : "NULL", ModuleInfo.GeneratedCode ));

	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN25@AddLinnumD
	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv198[rsp], rax
	jmp	SHORT $LN26@AddLinnumD
$LN25@AddLinnumD:
	lea	rax, OFFSET FLAT:$SG11461
	mov	QWORD PTR tv198[rsp], rax
$LN26@AddLinnumD:
	call	GetCurrOffset
	mov	ecx, DWORD PTR ModuleInfo+456
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR tv198[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, eax
	mov	r8d, DWORD PTR line_num$[rsp]
	mov	edx, DWORD PTR srcfile$[rsp]
	lea	rcx, OFFSET FLAT:$SG11462
	call	DoDebugMsg1

; 149  : 
; 150  :     curr = LclAlloc( sizeof( struct line_num_info ) );

	mov	ecx, 24
	call	LclAlloc
	mov	QWORD PTR curr$[rsp], rax

; 151  :     curr->number = line_num;

	mov	rax, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR line_num$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 152  : #if COFF_SUPPORT
; 153  :     if ( line_num == 0 ) { /* happens for COFF only */

	cmp	DWORD PTR line_num$[rsp], 0
	jne	$LN12@AddLinnumD

; 154  :         /* changed v2.03 (CurrProc might have been NULL) */
; 155  :         /* if ( Options.output_format == OFORMAT_COFF && CurrProc->sym.public == FALSE ) { */
; 156  :         /* v2.09: avoid duplicates, check for pass 1 */
; 157  :         //if ( Options.output_format == OFORMAT_COFF && CurrProc && CurrProc->sym.public == FALSE ) {
; 158  :         if ( Parse_Pass == PASS_1 &&
; 159  :             Options.output_format == OFORMAT_COFF && CurrProc && CurrProc->sym.ispublic == FALSE ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN14@AddLinnumD
	cmp	DWORD PTR Options+160, 2
	jne	SHORT $LN14@AddLinnumD
	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN14@AddLinnumD
	mov	rax, QWORD PTR CurrProc
	movzx	eax, BYTE PTR [rax+48]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@AddLinnumD

; 160  :             CurrProc->sym.included = TRUE;

	mov	rax, QWORD PTR CurrProc
	movzx	eax, BYTE PTR [rax+49]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR CurrProc
	mov	BYTE PTR [rcx+49], al

; 161  :             AddPublicData( (struct asym *)CurrProc );

	mov	rcx, QWORD PTR CurrProc
	call	AddPublicData
$LN14@AddLinnumD:

; 162  :         }
; 163  :         /* changed v2.03 */
; 164  :         /* curr->sym = (struct asym *)CurrProc; */
; 165  :         curr->sym = ( CurrProc ? (struct asym *)CurrProc : dmyproc );

	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN27@AddLinnumD
	mov	rax, QWORD PTR CurrProc
	mov	QWORD PTR tv223[rsp], rax
	jmp	SHORT $LN28@AddLinnumD
$LN27@AddLinnumD:
	mov	rax, QWORD PTR dmyproc
	mov	QWORD PTR tv223[rsp], rax
$LN28@AddLinnumD:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR tv223[rsp]
	mov	QWORD PTR [rax+16], rcx

; 166  :         curr->line_number = GetLineNumber();

	call	GetLineNumber
	mov	DWORD PTR tv226[rsp], eax
	mov	eax, DWORD PTR tv226[rsp]
	and	eax, 1048575				; 000fffffH
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	and	ecx, -1048576				; fff00000H
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 167  :         curr->file        = srcfile;

	mov	eax, DWORD PTR srcfile$[rsp]
	and	eax, 4095				; 00000fffH
	shl	eax, 20
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	and	ecx, 1048575				; 000fffffH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 168  :         /* set the function's size! */
; 169  :         if ( dmyproc ) {

	cmp	QWORD PTR dmyproc, 0
	je	SHORT $LN15@AddLinnumD

; 170  :             /**/myassert( dmyproc->segment );

	mov	rax, QWORD PTR dmyproc
	cmp	QWORD PTR [rax+32], 0
	je	SHORT $LN29@AddLinnumD
	mov	DWORD PTR tv243[rsp], 0
	jmp	SHORT $LN30@AddLinnumD
$LN29@AddLinnumD:
	mov	edx, 170				; 000000aaH
	lea	rcx, OFFSET FLAT:$SG11467
	call	InternalError
	mov	DWORD PTR tv243[rsp], eax
$LN30@AddLinnumD:

; 171  :             dmyproc->total_size =

	mov	rax, QWORD PTR dmyproc
	mov	rax, QWORD PTR [rax+32]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR dmyproc
	mov	ecx, DWORD PTR [rcx+16]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	rcx, QWORD PTR dmyproc
	mov	DWORD PTR [rcx+64], eax

; 172  :                 ((struct dsym *)dmyproc->segment)->e.seginfo->current_loc -
; 173  :                 dmyproc->offset;
; 174  :             dmyproc = NULL;

	mov	QWORD PTR dmyproc, 0
$LN15@AddLinnumD:

; 175  :         }
; 176  :         /* v2.11: write a 0x7fff line item if prologue exists */
; 177  :         if ( CurrProc && CurrProc->e.procinfo->size_prolog ) {

	cmp	QWORD PTR CurrProc, 0
	je	$LN16@AddLinnumD
	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+129]
	test	eax, eax
	je	SHORT $LN16@AddLinnumD

; 178  :             DebugMsg1(("AddLinnumDataRef: calling AddLinnumData(src=%u.%u) sym=%s\n", curr->file, curr->line_number, curr->sym->name ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	and	ecx, 1048575				; 000fffffH
	mov	rdx, QWORD PTR curr$[rsp]
	mov	edx, DWORD PTR [rdx+12]
	shr	edx, 20
	and	edx, 4095				; 00000fffH
	mov	r9, QWORD PTR [rax+8]
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:$SG11469
	call	DoDebugMsg1

; 179  :             AddLinnumData( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	AddLinnumData

; 180  :             curr = LclAlloc( sizeof( struct line_num_info ) );

	mov	ecx, 24
	call	LclAlloc
	mov	QWORD PTR curr$[rsp], rax

; 181  :             curr->number = GetLineNumber();

	call	GetLineNumber
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 182  :             curr->offset = GetCurrOffset();

	call	GetCurrOffset
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 183  :             curr->srcfile = srcfile;

	mov	rax, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR srcfile$[rsp]
	mov	DWORD PTR [rax+16], ecx
$LN16@AddLinnumD:

; 184  :         }
; 185  :     } else {

	jmp	SHORT $LN13@AddLinnumD
$LN12@AddLinnumD:

; 186  : #endif
; 187  :         curr->offset = GetCurrOffset();

	call	GetCurrOffset
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 188  :         curr->srcfile = srcfile;

	mov	rax, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR srcfile$[rsp]
	mov	DWORD PTR [rax+16], ecx
$LN13@AddLinnumD:

; 189  : #if COFF_SUPPORT
; 190  :     }
; 191  : #endif
; 192  :     lastLineNumber = line_num;

	mov	eax, DWORD PTR line_num$[rsp]
	mov	DWORD PTR lastLineNumber, eax

; 193  : 
; 194  :     /* v2.11: added, improved multi source support for CV.
; 195  :      * Also, the size of line number info could have become > 1024,
; 196  :      * ( even > 4096, thus causing an "internal error in omfint.c" )
; 197  :      */
; 198  :     if ( Options.output_format == OFORMAT_OMF )

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN17@AddLinnumD

; 199  :         omf_check_flush( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	omf_check_flush
$LN17@AddLinnumD:

; 200  : 
; 201  :     /* v2.10: warning if line-numbers for segments without class code! */
; 202  :     if ( CurrSeg->e.seginfo->linnum_init == FALSE ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+107]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@AddLinnumD

; 203  :         CurrSeg->e.seginfo->linnum_init = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+104]
	mov	BYTE PTR [rcx+107], al

; 204  :         if ( TypeFromClassName( CurrSeg, CurrSeg->e.seginfo->clsym ) != SEGTYPE_CODE ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	mov	rdx, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR ModuleInfo+432
	call	TypeFromClassName
	cmp	eax, 1
	je	SHORT $LN19@AddLinnumD

; 205  :             EmitWarn( 2, LINNUM_INFO_FOR_SEGMENT_WITHOUT_CLASS_CODE, CurrSeg->sym.name );

	mov	rax, QWORD PTR ModuleInfo+432
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 187				; 000000bbH
	mov	ecx, 2
	call	EmitWarn
$LN19@AddLinnumD:
$LN18@AddLinnumD:

; 206  :         }
; 207  :     }
; 208  :     DebugMsg1(("AddLinnumDataRef: calling AddLinnumData(src=%u.%u ofs=%X)\n", curr->number == 0 ? curr->file : curr->srcfile, curr->number, curr->offset ));

	mov	rax, QWORD PTR curr$[rsp]
	cmp	DWORD PTR [rax+8], 0
	jne	SHORT $LN31@AddLinnumD
	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+12]
	shr	eax, 20
	and	eax, 4095				; 00000fffH
	mov	DWORD PTR tv310[rsp], eax
	jmp	SHORT $LN32@AddLinnumD
$LN31@AddLinnumD:
	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv310[rsp], eax
$LN32@AddLinnumD:
	mov	rax, QWORD PTR curr$[rsp]
	mov	r9d, DWORD PTR [rax+12]
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8d, DWORD PTR [rax+8]
	mov	edx, DWORD PTR tv310[rsp]
	lea	rcx, OFFSET FLAT:$SG11473
	call	DoDebugMsg1

; 209  :     AddLinnumData( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	AddLinnumData
$LN1@AddLinnumD:

; 210  : 
; 211  :     return;
; 212  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
AddLinnumDataRef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1788 : }

	add	rsp, 56					; 00000038H
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

	add	rsp, 56					; 00000038H
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	__stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1391 : }

	add	rsp, 72					; 00000048H
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
