; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11403 DB	'linnum.c', 00H
	ORG $+7
$SG11404 DB	'$$$%05u', 00H
$SG11405 DB	'NULL', 00H
	ORG $+3
$SG11406 DB	'AddLinnumDataRef(src=%u.%u): CurrProc==NULL, dmyproc=%s '
	DB	'searching proc=%s', 0aH, 00H
	ORG $+5
$SG11409 DB	'AddLinnumDataRef: new proc %s created', 0aH, 00H
	ORG $+1
$SG11416 DB	'AddLinnumDataRef(src=%u.%u) line skipped, lastline=%u', 0aH
	DB	00H
	ORG $+1
$SG11412 DB	'AddLinnumDataRef: CURRPROC=NULL, sym=%s, calling AddLinn'
	DB	'umData(src=%u.%u)', 0aH, 00H
	ORG $+1
$SG11417 DB	'NULL', 00H
	ORG $+7
$SG11425 DB	'AddLinnumDataRef: calling AddLinnumData(src=%u.%u) sym=%'
	DB	's', 0aH, 00H
	ORG $+5
$SG11444 DB	'LinnumFini: last dummy proc size=%Xh', 0aH, 00H
	ORG $+2
$SG11418 DB	'AddLinnumDataRef(src=%u.%u): currofs=%Xh, CurrProc=%s, G'
	DB	'eneratedCode=%u', 0aH, 00H
	ORG $+7
$SG11423 DB	'linnum.c', 00H
	ORG $+7
$SG11429 DB	'AddLinnumDataRef: calling AddLinnumData(src=%u.%u ofs=%X'
	DB	')', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	AddLinnumDataRef
PUBLIC	LinnumInit
PUBLIC	LinnumFini
PUBLIC	QueueDeleteLinnum
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitWarn:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymFind:PROC
EXTRN	GetLineNumber:PROC
EXTRN	SetSymSegOfs:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	TypeFromClassName:PROC
EXTRN	CreateProc:PROC
EXTRN	AddPublicData:PROC
EXTRN	InternalError:PROC
EXTRN	omf_check_flush:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	write_to_file:BYTE
EXTRN	CurrProc:QWORD
EXTRN	LinnumQueue:BYTE
EXTRN	procidx:DWORD
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
dmyproc	DQ	01H DUP (?)
lastLineNumber DD 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$AddLinnumDataRef DD imagerel $LN33
	DD	imagerel $LN33+1836
	DD	imagerel $unwind$AddLinnumDataRef
$pdata$LinnumInit DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$LinnumInit
$pdata$LinnumFini DD imagerel $LN4
	DD	imagerel $LN4+89
	DD	imagerel $unwind$LinnumFini
$pdata$QueueDeleteLinnum DD imagerel $LN7
	DD	imagerel $LN7+90
	DD	imagerel $unwind$QueueDeleteLinnum
$pdata$AddLinnumData DD imagerel AddLinnumData
	DD	imagerel AddLinnumData+217
	DD	imagerel $unwind$AddLinnumData
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
xdata	SEGMENT
$unwind$AddLinnumDataRef DD 033819H
	DD	0160110H
	DD	07009H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$LinnumInit DD 010201H
	DD	07002H
$unwind$LinnumFini DD 021501H
	DD	070023206H
$unwind$QueueDeleteLinnum DD 021e01H
	DD	07006120aH
$unwind$AddLinnumData DD 021e01H
	DD	07006520aH
xdata	ENDS
CONST	SEGMENT
AddLinnumDataRef$rtcName$0 DB 070H
	DB	072H
	DB	06fH
	DB	063H
	DB	06eH
	DB	061H
	DB	06dH
	DB	065H
	DB	00H
	ORG $+7
AddLinnumDataRef$rtcVarDesc DD 048H
	DD	0cH
	DQ	FLAT:AddLinnumDataRef$rtcName$0
	ORG $+48
AddLinnumDataRef$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:AddLinnumDataRef$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\linnum.c
_TEXT	SEGMENT
q$ = 32
data$ = 64
AddLinnumData PROC

; 40   : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 41   :     struct qdesc *q;
; 42   : #if COFF_SUPPORT
; 43   :     if ( Options.output_format == OFORMAT_COFF ) {

	cmp	DWORD PTR Options+160, 2
	jne	SHORT $LN2@AddLinnumD

; 44   :         q = (struct qdesc *)CurrSeg->e.seginfo->LinnumQueue;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR q$[rsp], rax

; 45   :         if ( q == NULL ) {

	cmp	QWORD PTR q$[rsp], 0
	jne	SHORT $LN4@AddLinnumD

; 46   :             q = LclAlloc( sizeof( struct qdesc ) );

	mov	ecx, 16
	call	LclAlloc
	mov	QWORD PTR q$[rsp], rax

; 47   :             CurrSeg->e.seginfo->LinnumQueue = q;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR q$[rsp]
	mov	QWORD PTR [rax+56], rcx

; 48   :             q->head = NULL;

	mov	rax, QWORD PTR q$[rsp]
	mov	QWORD PTR [rax], 0
$LN4@AddLinnumD:

; 49   :         }
; 50   :     } else

	jmp	SHORT $LN3@AddLinnumD
$LN2@AddLinnumD:

; 51   : #endif
; 52   :         q = &LinnumQueue;

	lea	rax, OFFSET FLAT:LinnumQueue
	mov	QWORD PTR q$[rsp], rax
$LN3@AddLinnumD:

; 53   : 
; 54   :     data->next = NULL;

	mov	rax, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax], 0

; 55   :     if ( q->head == NULL)

	mov	rax, QWORD PTR q$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN5@AddLinnumD

; 56   :         q->head = q->tail = data;

	mov	rax, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN6@AddLinnumD
$LN5@AddLinnumD:

; 57   :     else {
; 58   :         ((struct line_num_info *)q->tail)->next = data;

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax], rcx

; 59   :         q->tail = data;

	mov	rax, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN6@AddLinnumD:

; 60   :     }
; 61   : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
AddLinnumData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\linnum.c
_TEXT	SEGMENT
curr$ = 0
next$ = 8
queue$ = 32
QueueDeleteLinnum PROC

; 202  : {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 203  :     struct line_num_info    *curr;
; 204  :     struct line_num_info    *next;
; 205  : 
; 206  :     if ( queue == NULL )

	cmp	QWORD PTR queue$[rsp], 0
	jne	SHORT $LN5@QueueDelet

; 207  :         return;

	jmp	SHORT $LN1@QueueDelet
$LN5@QueueDelet:

; 208  :     curr = queue->head;

	mov	rax, QWORD PTR queue$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$[rsp], rax

; 209  :     for( ; curr ; curr = next ) {

	jmp	SHORT $LN4@QueueDelet
$LN2@QueueDelet:
	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR curr$[rsp], rax
$LN4@QueueDelet:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@QueueDelet

; 210  :         next = curr->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR next$[rsp], rax

; 211  :         LclFree( curr );
; 212  :     }

	jmp	SHORT $LN2@QueueDelet
$LN3@QueueDelet:
$LN1@QueueDelet:

; 213  :     return;
; 214  : }

	add	rsp, 16
	pop	rdi
	ret	0
QueueDeleteLinnum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\linnum.c
_TEXT	SEGMENT
LinnumFini PROC

; 221  : {

$LN4:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 222  : #if COFF_SUPPORT
; 223  :     if ( dmyproc ) {

	cmp	QWORD PTR dmyproc, 0
	je	SHORT $LN2@LinnumFini

; 224  :         dmyproc->total_size =

	mov	rax, QWORD PTR dmyproc
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR dmyproc
	mov	ecx, DWORD PTR [rcx+16]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	rcx, QWORD PTR dmyproc
	mov	DWORD PTR [rcx+56], eax

; 225  :             ((struct dsym *)dmyproc->segment)->e.seginfo->current_loc -
; 226  :             dmyproc->offset;
; 227  :         DebugMsg(("LinnumFini: last dummy proc size=%Xh\n"));

	lea	rcx, OFFSET FLAT:$SG11444
	call	DoDebugMsg
$LN2@LinnumFini:

; 228  :     }
; 229  : #endif
; 230  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
LinnumFini ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\linnum.c
_TEXT	SEGMENT
LinnumInit PROC

; 234  : {

$LN3:
	push	rdi

; 235  :     lastLineNumber = 0;

	mov	DWORD PTR lastLineNumber, 0

; 236  : #if COFF_SUPPORT
; 237  :     dmyproc = NULL;

	mov	QWORD PTR dmyproc, 0

; 238  : #endif
; 239  : }

	pop	rdi
	ret	0
LinnumInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\linnum.c
_TEXT	SEGMENT
curr$ = 48
procname$4 = 72
tv79 = 112
tv92 = 120
tv161 = 128
tv198 = 136
tv223 = 144
tv226 = 152
tv243 = 156
tv310 = 160
__$ArrayPad$ = 168
srcfile$ = 192
line_num$ = 200
AddLinnumDataRef PROC

; 71   : {

$LN33:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 176				; 000000b0H
	mov	rdi, rsp
	mov	ecx, 44					; 0000002cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+192]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 72   :     struct line_num_info    *curr;
; 73   : 
; 74   : #if COFF_SUPPORT
; 75   :     /* COFF line number info is related to functions/procedures. Since
; 76   :      * assembly allows code lines outside of procs, "dummy" procs must
; 77   :      * be generated. A dummy proc lasts until
; 78   :      * - a true PROC is detected or
; 79   :      * - the source file changes or
; 80   :      * - the segment/section changes ( added in v2.11 )
; 81   :      */
; 82   :     if ( Options.output_format == OFORMAT_COFF &&
; 83   :         CurrProc == NULL &&

	cmp	DWORD PTR Options+160, 2
	jne	$LN2@AddLinnumD
	cmp	QWORD PTR CurrProc, 0
	jne	$LN2@AddLinnumD
	cmp	QWORD PTR dmyproc, 0
	je	SHORT $LN3@AddLinnumD
	mov	rax, QWORD PTR dmyproc
	mov	rax, QWORD PTR [rax+64]
	movzx	eax, WORD PTR [rax+14]
	cmp	eax, DWORD PTR srcfile$[rsp]
	jne	SHORT $LN3@AddLinnumD
	mov	rax, QWORD PTR dmyproc
	mov	rcx, QWORD PTR ModuleInfo+432
	cmp	QWORD PTR [rax+24], rcx
	je	$LN2@AddLinnumD
$LN3@AddLinnumD:

; 84   :         ( dmyproc == NULL ||
; 85   :         dmyproc->debuginfo->file != srcfile ||
; 86   :         dmyproc->segment != (struct asym *)CurrSeg ) ) {
; 87   :         char procname[12];
; 88   :         if ( dmyproc ) {

	cmp	QWORD PTR dmyproc, 0
	je	SHORT $LN4@AddLinnumD

; 89   :             /**/myassert( dmyproc->segment );

	mov	rax, QWORD PTR dmyproc
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN21@AddLinnumD
	mov	DWORD PTR tv79[rsp], 0
	jmp	SHORT $LN22@AddLinnumD
$LN21@AddLinnumD:
	mov	edx, 89					; 00000059H
	lea	rcx, OFFSET FLAT:$SG11403
	call	InternalError
	mov	DWORD PTR tv79[rsp], eax
$LN22@AddLinnumD:

; 90   :             dmyproc->total_size =

	mov	rax, QWORD PTR dmyproc
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR dmyproc
	mov	ecx, DWORD PTR [rcx+16]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	rcx, QWORD PTR dmyproc
	mov	DWORD PTR [rcx+56], eax
$LN4@AddLinnumD:

; 91   :                 ((struct dsym *)dmyproc->segment)->e.seginfo->current_loc -
; 92   :                 dmyproc->offset;
; 93   :         }
; 94   :         sprintf( procname, "$$$%05u", procidx );

	mov	r8d, DWORD PTR procidx
	lea	rdx, OFFSET FLAT:$SG11404
	lea	rcx, QWORD PTR procname$4[rsp]
	call	sprintf

; 95   :         DebugMsg1(("AddLinnumDataRef(src=%u.%u): CurrProc==NULL, dmyproc=%s searching proc=%s\n", srcfile, line_num, dmyproc ? dmyproc->name : "NULL", procname ));

	cmp	QWORD PTR dmyproc, 0
	je	SHORT $LN23@AddLinnumD
	mov	rax, QWORD PTR dmyproc
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv92[rsp], rax
	jmp	SHORT $LN24@AddLinnumD
$LN23@AddLinnumD:
	lea	rax, OFFSET FLAT:$SG11405
	mov	QWORD PTR tv92[rsp], rax
$LN24@AddLinnumD:
	lea	rax, QWORD PTR procname$4[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv92[rsp]
	mov	r8d, DWORD PTR line_num$[rsp]
	mov	edx, DWORD PTR srcfile$[rsp]
	lea	rcx, OFFSET FLAT:$SG11406
	call	DoDebugMsg1

; 96   :         dmyproc = SymSearch( procname );

	lea	rcx, QWORD PTR procname$4[rsp]
	call	SymFind
	mov	QWORD PTR dmyproc, rax

; 97   : 
; 98   :         /* in pass 1, create the proc */
; 99   :         if ( dmyproc == NULL ) {

	cmp	QWORD PTR dmyproc, 0
	jne	SHORT $LN5@AddLinnumD

; 100  :             dmyproc = CreateProc( NULL, procname, SYM_INTERNAL );

	mov	r8d, 1
	lea	rdx, QWORD PTR procname$4[rsp]
	xor	ecx, ecx
	call	CreateProc
	mov	QWORD PTR dmyproc, rax

; 101  :             DebugMsg1(("AddLinnumDataRef: new proc %s created\n", procname ));

	lea	rdx, QWORD PTR procname$4[rsp]
	lea	rcx, OFFSET FLAT:$SG11409
	call	DoDebugMsg1

; 102  :             dmyproc->isproc = TRUE; /* flag is usually set inside ParseProc() */

	mov	rax, QWORD PTR dmyproc
	movzx	eax, BYTE PTR [rax+41]
	or	al, 8
	mov	rcx, QWORD PTR dmyproc
	mov	BYTE PTR [rcx+41], al

; 103  :             dmyproc->included = TRUE;

	mov	rax, QWORD PTR dmyproc
	movzx	eax, BYTE PTR [rax+41]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR dmyproc
	mov	BYTE PTR [rcx+41], al

; 104  :             AddPublicData( dmyproc );

	mov	rcx, QWORD PTR dmyproc
	call	AddPublicData

; 105  :         } else

	jmp	SHORT $LN6@AddLinnumD
$LN5@AddLinnumD:

; 106  :             procidx++; /* for passes > 1, adjust procidx */

	mov	eax, DWORD PTR procidx
	inc	eax
	mov	DWORD PTR procidx, eax
$LN6@AddLinnumD:

; 107  : 
; 108  :         /* if the symbols isn't a PROC, the symbol name has been used
; 109  :          * by the user - bad! A warning should be displayed */
; 110  :         if ( dmyproc->isproc == TRUE ) {

	mov	rax, QWORD PTR dmyproc
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN7@AddLinnumD

; 111  :             SetSymSegOfs( dmyproc );

	mov	rcx, QWORD PTR dmyproc
	call	SetSymSegOfs

; 112  :             dmyproc->Ofssize = ModuleInfo.Ofssize;

	mov	rax, QWORD PTR dmyproc
	movzx	ecx, BYTE PTR ModuleInfo+404
	mov	BYTE PTR [rax+44], cl

; 113  :             dmyproc->langtype = ModuleInfo.langtype;

	mov	rax, QWORD PTR dmyproc
	mov	ecx, DWORD PTR ModuleInfo+364
	mov	DWORD PTR [rax+76], ecx

; 114  :             if ( write_to_file == TRUE ) {

	movzx	eax, BYTE PTR write_to_file
	cmp	eax, 1
	jne	$LN8@AddLinnumD

; 115  :                 curr = LclAlloc( sizeof( struct line_num_info ) );

	mov	ecx, 24
	call	LclAlloc
	mov	QWORD PTR curr$[rsp], rax

; 116  :                 curr->sym = dmyproc;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR dmyproc
	mov	QWORD PTR [rax+16], rcx

; 117  :                 curr->line_number = GetLineNumber();

	call	GetLineNumber
	mov	DWORD PTR tv161[rsp], eax
	mov	eax, DWORD PTR tv161[rsp]
	and	eax, 1048575				; 000fffffH
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	and	ecx, -1048576				; fff00000H
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 118  :                 curr->file = srcfile;

	mov	eax, DWORD PTR srcfile$[rsp]
	and	eax, 4095				; 00000fffH
	shl	eax, 20
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	and	ecx, 1048575				; 000fffffH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 119  :                 curr->number = 0;

	mov	rax, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rax+8], 0

; 120  :                 DebugMsg1(("AddLinnumDataRef: CURRPROC=NULL, sym=%s, calling AddLinnumData(src=%u.%u)\n", curr->sym->name, curr->file, curr->line_number ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+12]
	and	eax, 1048575				; 000fffffH
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	shr	ecx, 20
	and	ecx, 4095				; 00000fffH
	mov	rdx, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	r9d, eax
	mov	r8d, ecx
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG11412
	call	DoDebugMsg1

; 121  :                 AddLinnumData( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	AddLinnumData
$LN8@AddLinnumD:
$LN7@AddLinnumD:
$LN2@AddLinnumD:

; 122  :             }
; 123  :         }
; 124  :     }
; 125  : #endif
; 126  : 
; 127  :     if(  line_num && ( write_to_file == FALSE || lastLineNumber == line_num )) {

	cmp	DWORD PTR line_num$[rsp], 0
	je	SHORT $LN9@AddLinnumD
	movzx	eax, BYTE PTR write_to_file
	test	eax, eax
	je	SHORT $LN10@AddLinnumD
	mov	eax, DWORD PTR line_num$[rsp]
	cmp	DWORD PTR lastLineNumber, eax
	jne	SHORT $LN9@AddLinnumD
$LN10@AddLinnumD:

; 128  : #ifdef DEBUG_OUT
; 129  :         if ( write_to_file == TRUE )

	movzx	eax, BYTE PTR write_to_file
	cmp	eax, 1
	jne	SHORT $LN11@AddLinnumD

; 130  :             DebugMsg1(("AddLinnumDataRef(src=%u.%u) line skipped, lastline=%u\n", srcfile, line_num, lastLineNumber ));

	mov	r9d, DWORD PTR lastLineNumber
	mov	r8d, DWORD PTR line_num$[rsp]
	mov	edx, DWORD PTR srcfile$[rsp]
	lea	rcx, OFFSET FLAT:$SG11416
	call	DoDebugMsg1
$LN11@AddLinnumD:

; 131  : #endif
; 132  :         return;

	jmp	$LN1@AddLinnumD
$LN9@AddLinnumD:

; 133  :     }
; 134  :     DebugMsg1(("AddLinnumDataRef(src=%u.%u): currofs=%Xh, CurrProc=%s, GeneratedCode=%u\n", srcfile, line_num, GetCurrOffset(), CurrProc ? CurrProc->sym.name : "NULL", ModuleInfo.GeneratedCode ));

	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN25@AddLinnumD
	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv198[rsp], rax
	jmp	SHORT $LN26@AddLinnumD
$LN25@AddLinnumD:
	lea	rax, OFFSET FLAT:$SG11417
	mov	QWORD PTR tv198[rsp], rax
$LN26@AddLinnumD:
	call	GetCurrOffset
	mov	ecx, DWORD PTR ModuleInfo+456
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR tv198[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, eax
	mov	r8d, DWORD PTR line_num$[rsp]
	mov	edx, DWORD PTR srcfile$[rsp]
	lea	rcx, OFFSET FLAT:$SG11418
	call	DoDebugMsg1

; 135  : 
; 136  :     curr = LclAlloc( sizeof( struct line_num_info ) );

	mov	ecx, 24
	call	LclAlloc
	mov	QWORD PTR curr$[rsp], rax

; 137  :     curr->number = line_num;

	mov	rax, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR line_num$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 138  : #if COFF_SUPPORT
; 139  :     if ( line_num == 0 ) { /* happens for COFF only */

	cmp	DWORD PTR line_num$[rsp], 0
	jne	$LN12@AddLinnumD

; 140  :         /* changed v2.03 (CurrProc might have been NULL) */
; 141  :         /* if ( Options.output_format == OFORMAT_COFF && CurrProc->sym.public == FALSE ) { */
; 142  :         /* v2.09: avoid duplicates, check for pass 1 */
; 143  :         //if ( Options.output_format == OFORMAT_COFF && CurrProc && CurrProc->sym.public == FALSE ) {
; 144  :         if ( Parse_Pass == PASS_1 &&
; 145  :             Options.output_format == OFORMAT_COFF && CurrProc && CurrProc->sym.ispublic == FALSE ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN14@AddLinnumD
	cmp	DWORD PTR Options+160, 2
	jne	SHORT $LN14@AddLinnumD
	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN14@AddLinnumD
	mov	rax, QWORD PTR CurrProc
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@AddLinnumD

; 146  :             CurrProc->sym.included = TRUE;

	mov	rax, QWORD PTR CurrProc
	movzx	eax, BYTE PTR [rax+41]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR CurrProc
	mov	BYTE PTR [rcx+41], al

; 147  :             AddPublicData( (struct asym *)CurrProc );

	mov	rcx, QWORD PTR CurrProc
	call	AddPublicData
$LN14@AddLinnumD:

; 148  :         }
; 149  :         /* changed v2.03 */
; 150  :         /* curr->sym = (struct asym *)CurrProc; */
; 151  :         curr->sym = ( CurrProc ? (struct asym *)CurrProc : dmyproc );

	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN27@AddLinnumD
	mov	rax, QWORD PTR CurrProc
	mov	QWORD PTR tv223[rsp], rax
	jmp	SHORT $LN28@AddLinnumD
$LN27@AddLinnumD:
	mov	rax, QWORD PTR dmyproc
	mov	QWORD PTR tv223[rsp], rax
$LN28@AddLinnumD:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR tv223[rsp]
	mov	QWORD PTR [rax+16], rcx

; 152  :         curr->line_number = GetLineNumber();

	call	GetLineNumber
	mov	DWORD PTR tv226[rsp], eax
	mov	eax, DWORD PTR tv226[rsp]
	and	eax, 1048575				; 000fffffH
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	and	ecx, -1048576				; fff00000H
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 153  :         curr->file        = srcfile;

	mov	eax, DWORD PTR srcfile$[rsp]
	and	eax, 4095				; 00000fffH
	shl	eax, 20
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	and	ecx, 1048575				; 000fffffH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 154  :         /* set the function's size! */
; 155  :         if ( dmyproc ) {

	cmp	QWORD PTR dmyproc, 0
	je	SHORT $LN15@AddLinnumD

; 156  :             /**/myassert( dmyproc->segment );

	mov	rax, QWORD PTR dmyproc
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN29@AddLinnumD
	mov	DWORD PTR tv243[rsp], 0
	jmp	SHORT $LN30@AddLinnumD
$LN29@AddLinnumD:
	mov	edx, 156				; 0000009cH
	lea	rcx, OFFSET FLAT:$SG11423
	call	InternalError
	mov	DWORD PTR tv243[rsp], eax
$LN30@AddLinnumD:

; 157  :             dmyproc->total_size =

	mov	rax, QWORD PTR dmyproc
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR dmyproc
	mov	ecx, DWORD PTR [rcx+16]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	rcx, QWORD PTR dmyproc
	mov	DWORD PTR [rcx+56], eax

; 158  :                 ((struct dsym *)dmyproc->segment)->e.seginfo->current_loc -
; 159  :                 dmyproc->offset;
; 160  :             dmyproc = NULL;

	mov	QWORD PTR dmyproc, 0
$LN15@AddLinnumD:

; 161  :         }
; 162  :         /* v2.11: write a 0x7fff line item if prologue exists */
; 163  :         if ( CurrProc && CurrProc->e.procinfo->size_prolog ) {

	cmp	QWORD PTR CurrProc, 0
	je	$LN16@AddLinnumD
	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+85]
	test	eax, eax
	je	SHORT $LN16@AddLinnumD

; 164  :             DebugMsg1(("AddLinnumDataRef: calling AddLinnumData(src=%u.%u) sym=%s\n", curr->file, curr->line_number, curr->sym->name ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	and	ecx, 1048575				; 000fffffH
	mov	rdx, QWORD PTR curr$[rsp]
	mov	edx, DWORD PTR [rdx+12]
	shr	edx, 20
	and	edx, 4095				; 00000fffH
	mov	r9, QWORD PTR [rax+8]
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:$SG11425
	call	DoDebugMsg1

; 165  :             AddLinnumData( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	AddLinnumData

; 166  :             curr = LclAlloc( sizeof( struct line_num_info ) );

	mov	ecx, 24
	call	LclAlloc
	mov	QWORD PTR curr$[rsp], rax

; 167  :             curr->number = GetLineNumber();

	call	GetLineNumber
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 168  :             curr->offset = GetCurrOffset();

	call	GetCurrOffset
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 169  :             curr->srcfile = srcfile;

	mov	rax, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR srcfile$[rsp]
	mov	DWORD PTR [rax+16], ecx
$LN16@AddLinnumD:

; 170  :         }
; 171  :     } else {

	jmp	SHORT $LN13@AddLinnumD
$LN12@AddLinnumD:

; 172  : #endif
; 173  :         curr->offset = GetCurrOffset();

	call	GetCurrOffset
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 174  :         curr->srcfile = srcfile;

	mov	rax, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR srcfile$[rsp]
	mov	DWORD PTR [rax+16], ecx
$LN13@AddLinnumD:

; 175  : #if COFF_SUPPORT
; 176  :     }
; 177  : #endif
; 178  :     lastLineNumber = line_num;

	mov	eax, DWORD PTR line_num$[rsp]
	mov	DWORD PTR lastLineNumber, eax

; 179  : 
; 180  :     /* v2.11: added, improved multi source support for CV.
; 181  :      * Also, the size of line number info could have become > 1024,
; 182  :      * ( even > 4096, thus causing an "internal error in omfint.c" )
; 183  :      */
; 184  :     if ( Options.output_format == OFORMAT_OMF )

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN17@AddLinnumD

; 185  :         omf_check_flush( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	omf_check_flush
$LN17@AddLinnumD:

; 186  : 
; 187  :     /* v2.10: warning if line-numbers for segments without class code! */
; 188  :     if ( CurrSeg->e.seginfo->linnum_init == FALSE ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@AddLinnumD

; 189  :         CurrSeg->e.seginfo->linnum_init = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+107], al

; 190  :         if ( TypeFromClassName( CurrSeg, CurrSeg->e.seginfo->clsym ) != SEGTYPE_CODE ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rdx, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR ModuleInfo+432
	call	TypeFromClassName
	cmp	eax, 1
	je	SHORT $LN19@AddLinnumD

; 191  :             EmitWarn( 2, LINNUM_INFO_FOR_SEGMENT_WITHOUT_CLASS_CODE, CurrSeg->sym.name );

	mov	rax, QWORD PTR ModuleInfo+432
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 188				; 000000bcH
	mov	ecx, 2
	call	EmitWarn
$LN19@AddLinnumD:
$LN18@AddLinnumD:

; 192  :         }
; 193  :     }
; 194  :     DebugMsg1(("AddLinnumDataRef: calling AddLinnumData(src=%u.%u ofs=%X)\n", curr->number == 0 ? curr->file : curr->srcfile, curr->number, curr->offset ));

	mov	rax, QWORD PTR curr$[rsp]
	cmp	DWORD PTR [rax+8], 0
	jne	SHORT $LN31@AddLinnumD
	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+12]
	shr	eax, 20
	and	eax, 4095				; 00000fffH
	mov	DWORD PTR tv310[rsp], eax
	jmp	SHORT $LN32@AddLinnumD
$LN31@AddLinnumD:
	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv310[rsp], eax
$LN32@AddLinnumD:
	mov	rax, QWORD PTR curr$[rsp]
	mov	r9d, DWORD PTR [rax+12]
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8d, DWORD PTR [rax+8]
	mov	edx, DWORD PTR tv310[rsp]
	lea	rcx, OFFSET FLAT:$SG11429
	call	DoDebugMsg1

; 195  :     AddLinnumData( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	AddLinnumData
$LN1@AddLinnumD:

; 196  : 
; 197  :     return;
; 198  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:AddLinnumDataRef$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 176				; 000000b0H
	pop	rdi
	ret	0
AddLinnumDataRef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Buffer$ = 96
_Format$ = 104
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1788 : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:sprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp___stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1391 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
	push	rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	rdi
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
