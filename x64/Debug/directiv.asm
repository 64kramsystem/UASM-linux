; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	IncludeDirective
PUBLIC	StubDir
PUBLIC	SegOrderDirective
PUBLIC	RadixDirective
PUBLIC	AliasDirective
PUBLIC	EchoDirective
PUBLIC	IncBinDirective
PUBLIC	IncludeLibDirective
PUBLIC	NameDirective
PUBLIC	directive_tab
EXTRN	CondAsmDirective:PROC
EXTRN	LoopDirective:PROC
EXTRN	PurgeDirective:PROC
EXTRN	MacroDir:PROC
EXTRN	CatStrDir:PROC
EXTRN	SubStrDir:PROC
EXTRN	EndDirective:PROC
EXTRN	ErrorDirective:PROC
EXTRN	CpuDirective:PROC
EXTRN	ListingDirective:PROC
EXTRN	ListMacroDirective:PROC
EXTRN	SimplifiedSegDir:PROC
EXTRN	HllStartDir:PROC
EXTRN	HllExitDir:PROC
EXTRN	HllEndDir:PROC
EXTRN	StartupExitDirective:PROC
EXTRN	ModelDirective:PROC
EXTRN	SafeSEHDirective:PROC
EXTRN	InStrDir:PROC
EXTRN	SizeStrDir:PROC
EXTRN	ExcFrameDirective:PROC
EXTRN	StructDirective:PROC
EXTRN	TypedefDirective:PROC
EXTRN	RecordDirective:PROC
EXTRN	CommDirective:PROC
EXTRN	ExternDirective:PROC
EXTRN	ExterndefDirective:PROC
EXTRN	ProtoDirective:PROC
EXTRN	PublicDirective:PROC
EXTRN	ProcDir:PROC
EXTRN	EndpDir:PROC
EXTRN	LocalDir:PROC
EXTRN	InvokeDirective:PROC
EXTRN	OrgDirective:PROC
EXTRN	AlignDirective:PROC
EXTRN	SegmentDir:PROC
EXTRN	EndsDir:PROC
EXTRN	GrpDir:PROC
EXTRN	AssumeDirective:PROC
EXTRN	LabelDirective:PROC
EXTRN	EquDirective:PROC
EXTRN	EqualSgnDirective:PROC
EXTRN	OptionDirective:PROC
EXTRN	ContextDirective:PROC
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
directive_tab DQ FLAT:CondAsmDirective
	DQ	FLAT:LoopDirective
	DQ	FLAT:PurgeDirective
	DQ	FLAT:IncludeDirective
	DQ	FLAT:MacroDir
	DQ	FLAT:CatStrDir
	DQ	FLAT:SubStrDir
	DQ	FLAT:StubDir
	DQ	FLAT:StubDir
	DQ	FLAT:EndDirective
	DQ	FLAT:ErrorDirective
	DQ	FLAT:CpuDirective
	DQ	FLAT:ListingDirective
	DQ	FLAT:ListMacroDirective
	DQ	FLAT:SegOrderDirective
	DQ	FLAT:SimplifiedSegDir
	DQ	FLAT:HllStartDir
	DQ	FLAT:HllExitDir
	DQ	FLAT:HllEndDir
	DQ	FLAT:StartupExitDirective
	DQ	FLAT:ModelDirective
	DQ	FLAT:RadixDirective
	DQ	FLAT:SafeSEHDirective
	DQ	FLAT:InStrDir
	DQ	FLAT:SizeStrDir
	DQ	FLAT:ExcFrameDirective
	DQ	FLAT:StructDirective
	DQ	FLAT:TypedefDirective
	DQ	FLAT:RecordDirective
	DQ	FLAT:CommDirective
	DQ	FLAT:ExternDirective
	DQ	FLAT:ExterndefDirective
	DQ	FLAT:ProtoDirective
	DQ	FLAT:PublicDirective
	DQ	FLAT:ProcDir
	DQ	FLAT:EndpDir
	DQ	FLAT:LocalDir
	DQ	FLAT:InvokeDirective
	DQ	FLAT:OrgDirective
	DQ	FLAT:AlignDirective
	DQ	FLAT:SegmentDir
	DQ	FLAT:EndsDir
	DQ	FLAT:GrpDir
	DQ	FLAT:AssumeDirective
	DQ	FLAT:LabelDirective
	DQ	FLAT:AliasDirective
	DQ	FLAT:EchoDirective
	DQ	FLAT:EquDirective
	DQ	FLAT:EqualSgnDirective
	DQ	FLAT:IncBinDirective
	DQ	FLAT:IncludeLibDirective
	DQ	FLAT:NameDirective
	DQ	FLAT:OptionDirective
	DQ	FLAT:ContextDirective
CONST	ENDS
_DATA	SEGMENT
$SG11268 DB	'IncBinDirective enter', 0aH, 00H
	ORG $+1
$SG11290 DB	'IncBinDirective: filename=%s, offset=%u, size=%u', 0aH, 00H
	ORG $+2
$SG11210 DB	'%s', 0aH, 00H
$SG11308 DB	'AliasDirective: first argument is not a literal: %s', 0aH
	DB	00H
	ORG $+3
$SG11311 DB	'AliasDirective: syntax error: %s', 0aH, 00H
	ORG $+6
$SG11314 DB	'AliasDirective: second argument is not a literal: %s', 0aH
	DB	00H
	ORG $+2
$SG11325 DB	'AliasDirective: symbol redefinition', 0aH, 00H
	ORG $+3
$SG11343 DB	'NameDirective: ignored name >%s<', 0aH, 00H
	ORG $+6
$SG11356 DB	'RadixDirective: new radix=%u', 0aH, 00H
	ORG $+2
$SG11221 DB	'IncludeDirective enter', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
EXTRN	__imp_isspace:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp_fseek:PROC
EXTRN	__imp_ftell:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	memcpy:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	__imp__strupr:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	QEnqueue:PROC
EXTRN	OutputBinBytes:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymCreate:PROC
EXTRN	SymFind:PROC
EXTRN	sym_add_table:PROC
EXTRN	sym_remove_table:PROC
EXTRN	ProcessFile:PROC
EXTRN	SearchFile:PROC
EXTRN	Tokenize:PROC
EXTRN	EvalOperand:PROC
EXTRN	LstWriteSrcLine:PROC
EXTRN	omf_OutSelect:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SymTables:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	CurrStruct:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$IncludeDirective DD imagerel $LN12
	DD	imagerel $LN12+400
	DD	imagerel $unwind$IncludeDirective
$pdata$StubDir DD imagerel $LN3
	DD	imagerel $LN3+17
	DD	imagerel $unwind$StubDir
$pdata$SegOrderDirective DD imagerel $LN8
	DD	imagerel $LN8+232
	DD	imagerel $unwind$SegOrderDirective
$pdata$RadixDirective DD imagerel $LN8
	DD	imagerel $LN8+375
	DD	imagerel $unwind$RadixDirective
$pdata$AliasDirective DD imagerel $LN26
	DD	imagerel $LN26+1022
	DD	imagerel $unwind$AliasDirective
$pdata$EchoDirective DD imagerel $LN5
	DD	imagerel $LN5+95
	DD	imagerel $unwind$EchoDirective
$pdata$IncBinDirective DD imagerel $LN25
	DD	imagerel $LN25+1150
	DD	imagerel $unwind$IncBinDirective
$pdata$IncludeLibDirective DD imagerel $LN11
	DD	imagerel $LN11+359
	DD	imagerel $unwind$IncludeLibDirective
$pdata$NameDirective DD imagerel $LN7
	DD	imagerel $LN7+344
	DD	imagerel $unwind$NameDirective
$pdata$IncludeLibrary DD imagerel IncludeLibrary
	DD	imagerel IncludeLibrary+185
	DD	imagerel $unwind$IncludeLibrary
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
RadixDirective$rtcName$0 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	078H
	DB	00H
	ORG $+10
RadixDirective$rtcVarDesc DD 050H
	DD	068H
	DQ	FLAT:RadixDirective$rtcName$0
	ORG $+48
RadixDirective$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:RadixDirective$rtcVarDesc
IncBinDirective$rtcName$0 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	078H
	DB	00H
	ORG $+2
IncBinDirective$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:IncBinDirective$rtcVarDesc
	ORG $+8
IncBinDirective$rtcVarDesc DD 050H
	DD	068H
	DQ	FLAT:IncBinDirective$rtcName$0
CONST	ENDS
xdata	SEGMENT
$unwind$IncludeDirective DD 022101H
	DD	0700a520eH
$unwind$StubDir DD 010a01H
	DD	0700aH
$unwind$SegOrderDirective DD 022101H
	DD	0700a320eH
$unwind$RadixDirective DD 032701H
	DD	01a0111H
	DD	0700aH
$unwind$AliasDirective DD 022101H
	DD	0700a720eH
$unwind$EchoDirective DD 022101H
	DD	0700a320eH
$unwind$IncBinDirective DD 032701H
	DD	01c0111H
	DD	0700aH
$unwind$IncludeLibDirective DD 022101H
	DD	0700a520eH
$unwind$NameDirective DD 022101H
	DD	0700a320eH
$unwind$IncludeLibrary DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
printf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
printf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:printf$rtcName$0
	ORG $+48
printf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:printf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
q$ = 32
name$ = 64
IncludeLibrary PROC

; 108  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 109  :     struct qitem *q;
; 110  : 
; 111  :     /* old approach, <= 1.91: add lib name to global namespace */
; 112  :     /* new approach, >= 1.92: check lib table, if entry is missing, add it */
; 113  :     /* Masm doesn't map cases for the paths. So if there is
; 114  :      * includelib <kernel32.lib>
; 115  :      * includelib <KERNEL32.LIB>
; 116  :      * then 2 defaultlib entries are added. If this is to be changed for
; 117  :      * HJWasm, activate the _stricmp() below.
; 118  :      */
; 119  :     for ( q = ModuleInfo.g.LibQueue.head; q ; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo+64
	mov	QWORD PTR q$[rsp], rax
	jmp	SHORT $LN4@IncludeLib
$LN2@IncludeLib:
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$[rsp], rax
$LN4@IncludeLib:
	cmp	QWORD PTR q$[rsp], 0
	je	SHORT $LN3@IncludeLib

; 120  :         //if ( _stricmp( dir->sym.name, name) == 0)
; 121  :         if ( strcmp( q->value, name ) == 0 )

	mov	rax, QWORD PTR q$[rsp]
	add	rax, 8
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN5@IncludeLib

; 122  :             return( q->value );

	mov	rax, QWORD PTR q$[rsp]
	add	rax, 8
	jmp	SHORT $LN1@IncludeLib
$LN5@IncludeLib:

; 123  :     }

	jmp	SHORT $LN2@IncludeLib
$LN3@IncludeLib:

; 124  :     q = LclAlloc( sizeof( struct qitem ) + strlen( name ) );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	add	rax, 16
	mov	rcx, rax
	call	LclAlloc
	mov	QWORD PTR q$[rsp], rax

; 125  :     strcpy( q->value, name );

	mov	rax, QWORD PTR q$[rsp]
	add	rax, 8
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, rax
	call	strcpy

; 126  :     QEnqueue( &ModuleInfo.g.LibQueue, q );

	mov	rdx, QWORD PTR q$[rsp]
	lea	rcx, OFFSET FLAT:ModuleInfo+64
	call	QEnqueue

; 127  :     return( q->value );

	mov	rax, QWORD PTR q$[rsp]
	add	rax, 8
$LN1@IncludeLib:

; 128  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
IncludeLibrary ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
NameDirective PROC

; 394  : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 395  :     if( Parse_Pass != PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN2@NameDirect

; 396  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@NameDirect
$LN2@NameDirect:

; 397  :     /* if a module name is set with -nm, ignore NAME directive! */
; 398  :     /* v2.08: removed, since Options.names isn't touched at all */
; 399  :     //if( Options.names[OPTN_MODULE_NAME] != NULL )
; 400  :     //    return( NOT_ERROR );
; 401  : 
; 402  :     i++; /* skip directive */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 403  : 
; 404  :     /* improper use of NAME is difficult to see since it is a nop
; 405  :      therefore some syntax checks are implemented:
; 406  :      - no 'name' structs, unions, records, typedefs!
; 407  :      - no 'name' struct fields!
; 408  :      - no 'name' segments!
; 409  :      - no 'name:' label!
; 410  :      */
; 411  :     if ( CurrStruct != NULL ||
; 412  :         ( tokenarray[i].token == T_DIRECTIVE &&
; 413  :          ( tokenarray[i].tokval == T_SEGMENT ||
; 414  :           tokenarray[i].tokval == T_STRUCT  ||
; 415  :           tokenarray[i].tokval == T_STRUC   ||
; 416  :           tokenarray[i].tokval == T_UNION   ||
; 417  :           tokenarray[i].tokval == T_TYPEDEF ||
; 418  :           tokenarray[i].tokval == T_RECORD)) ||

	cmp	QWORD PTR CurrStruct, 0
	jne	$LN4@NameDirect
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	$LN5@NameDirect
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 436		; 000001b4H
	je	$LN4@NameDirect
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 418		; 000001a2H
	je	SHORT $LN4@NameDirect
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 417		; 000001a1H
	je	SHORT $LN4@NameDirect
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 419		; 000001a3H
	je	SHORT $LN4@NameDirect
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 420		; 000001a4H
	je	SHORT $LN4@NameDirect
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 421		; 000001a5H
	je	SHORT $LN4@NameDirect
$LN5@NameDirect:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN3@NameDirect
$LN4@NameDirect:

; 419  :          tokenarray[i].token == T_COLON ) {
; 420  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i-1].tokpos ) );

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@NameDirect
$LN3@NameDirect:

; 421  :     }
; 422  : 
; 423  :     /* don't touch Option fields! if anything at all, ModuleInfo.name may be modified.
; 424  :      * However, since the directive is ignored by Masm, nothing is done.
; 425  :      */
; 426  : //  strncpy( ModuleInfo.name, tokenarray[i].string_ptr, sizeof( ModuleInfo.name ) );
; 427  : //  ModuleInfo.name[ sizeof( ModuleInfo.name ) - 1] = NULLC;
; 428  : //  DebugMsg(("NameDirective: set name to >%s<\n", ModuleInfo.name ));
; 429  :     DebugMsg(("NameDirective: ignored name >%s<\n", tokenarray[i].string_ptr ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11343
	call	DoDebugMsg

; 430  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@NameDirect:

; 431  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
NameDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
name$ = 32
p$1 = 40
i$ = 64
tokenarray$ = 72
IncludeLibDirective PROC

; 150  : {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+64]

; 151  :     char *name;
; 152  :     //struct asym *sym;
; 153  : 
; 154  :     if ( Parse_Pass != PASS_1 ) /* do all work in pass 1 */

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN5@IncludeLib

; 155  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@IncludeLib
$LN5@IncludeLib:

; 156  :     i++; /* skip the directive */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 157  :     /* v2.03: library name may be just a "number" */
; 158  :     //if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_NUM ) {
; 159  :     if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN6@IncludeLib

; 160  :         /* v2.05: Masm doesn't complain if there's no name, so emit a warning only! */
; 161  :         //EmitError( LIBRARY_NAME_MISSING );
; 162  :         //return( ERROR );
; 163  :         EmitWarn( 2, LIBRARY_NAME_MISSING );

	mov	edx, 88					; 00000058H
	mov	ecx, 2
	call	EmitWarn
$LN6@IncludeLib:

; 164  :     }
; 165  : 
; 166  :     if ( tokenarray[i].token == T_STRING && tokenarray[i].string_delim == '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN7@IncludeLib
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN7@IncludeLib

; 167  :         if ( tokenarray[i+1].token != T_FINAL ) {

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN9@IncludeLib

; 168  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].tokpos ) );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@IncludeLib
$LN9@IncludeLib:

; 169  :         }
; 170  :         /* v2.08: use GetLiteralValue() */
; 171  :         //name = StringBufferEnd;
; 172  :         //GetLiteralValue( name, tokenarray[i].string_ptr );
; 173  :         name = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR name$[rsp], rax

; 174  :     } else {

	jmp	SHORT $LN8@IncludeLib
$LN7@IncludeLib:

; 175  :         char *p;
; 176  :         /* regard "everything" behind INCLUDELIB as the library name */
; 177  :         name = tokenarray[i].tokpos;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR name$[rsp], rax

; 178  :         /* remove trailing white spaces */
; 179  :         for ( p = tokenarray[Token_Count].tokpos - 1; p > name && isspace( *p ); *p = NULLC, p-- );

	movsxd	rax, DWORD PTR ModuleInfo+496
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	dec	rax
	mov	QWORD PTR p$1[rsp], rax
	jmp	SHORT $LN4@IncludeLib
$LN2@IncludeLib:
	mov	rax, QWORD PTR p$1[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR p$1[rsp]
	dec	rax
	mov	QWORD PTR p$1[rsp], rax
$LN4@IncludeLib:
	mov	rax, QWORD PTR name$[rsp]
	cmp	QWORD PTR p$1[rsp], rax
	jbe	SHORT $LN3@IncludeLib
	mov	rax, QWORD PTR p$1[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN3@IncludeLib
	jmp	SHORT $LN2@IncludeLib
$LN3@IncludeLib:
$LN8@IncludeLib:

; 180  :     }
; 181  : 
; 182  :     IncludeLibrary( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	IncludeLibrary

; 183  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@IncludeLib:

; 184  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
IncludeLibDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
file$ = 48
fileoffset$ = 56
sizemax$ = 60
opndx$ = 80
sz$ = 196
pBinData$ = 200
result$ = 208
i$ = 240
tokenarray$ = 248
IncBinDirective PROC

; 192  : {

$LN25:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 224				; 000000e0H
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+240]

; 193  :     FILE *file;
; 194  :     //int size;
; 195  :     uint_32 fileoffset = 0; /* fixme: should be uint_64 */

	mov	DWORD PTR fileoffset$[rsp], 0

; 196  :     uint_32 sizemax = -1;

	mov	DWORD PTR sizemax$[rsp], -1		; ffffffffH

; 197  :     struct expr opndx;
; 198  : 	long sz;
; 199  : 	unsigned char* pBinData;
; 200  : 	size_t result = 0;

	mov	QWORD PTR result$[rsp], 0

; 201  : 
; 202  :     DebugMsg(("IncBinDirective enter\n"));

	lea	rcx, OFFSET FLAT:$SG11268
	call	DoDebugMsg

; 203  : 
; 204  :     i++; /* skip the directive */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 205  :     /* v2.03: file name may be just a "number" */
; 206  :     //if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_NUM ) {
; 207  :     if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN2@IncBinDire

; 208  :         return( EmitError( EXPECTED_FILE_NAME ) );

	mov	ecx, 112				; 00000070H
	call	EmitError
	jmp	$LN1@IncBinDire
$LN2@IncBinDire:

; 209  :     }
; 210  : 
; 211  :     if ( tokenarray[i].token == T_STRING ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	$LN3@IncBinDire

; 212  : 
; 213  :         /* v2.08: use string buffer to avoid buffer overflow if string is > FILENAME_MAX */
; 214  :         if ( tokenarray[i].string_delim == '"' || tokenarray[i].string_delim == '\'' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN7@IncBinDire
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN5@IncBinDire
$LN7@IncBinDire:

; 215  :             memcpy( StringBufferEnd, tokenarray[i].string_ptr+1, tokenarray[i].stringlen );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+8]
	inc	rcx
	mov	r8d, eax
	mov	rdx, rcx
	mov	rcx, QWORD PTR ModuleInfo+488
	call	memcpy

; 216  :             StringBufferEnd[tokenarray[i].stringlen] = NULLC;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	rcx, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rcx+rax], 0
	jmp	SHORT $LN6@IncBinDire
$LN5@IncBinDire:

; 217  :         } else if ( tokenarray[i].string_delim == '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN8@IncBinDire

; 218  :             /* v2.08: use GetLiteralValue() instead of strncpy() */
; 219  :             //GetLiteralValue( StringBufferEnd, tokenarray[i].string_ptr );
; 220  :             memcpy( StringBufferEnd, tokenarray[i].string_ptr, tokenarray[i].stringlen+1 );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	inc	eax
	mov	eax, eax
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8d, eax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	mov	rcx, QWORD PTR ModuleInfo+488
	call	memcpy

; 221  :         } else {

	jmp	SHORT $LN9@IncBinDire
$LN8@IncBinDire:

; 222  :             return( EmitError( FILENAME_MUST_BE_ENCLOSED_IN_QUOTES_OR_BRACKETS ) );

	mov	ecx, 241				; 000000f1H
	call	EmitError
	jmp	$LN1@IncBinDire
$LN9@IncBinDire:
$LN6@IncBinDire:

; 223  :         }
; 224  :     } else {

	jmp	SHORT $LN4@IncBinDire
$LN3@IncBinDire:

; 225  :         return( EmitError( FILENAME_MUST_BE_ENCLOSED_IN_QUOTES_OR_BRACKETS ) );

	mov	ecx, 241				; 000000f1H
	call	EmitError
	jmp	$LN1@IncBinDire
$LN4@IncBinDire:

; 226  :     }
; 227  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 228  :     if ( tokenarray[i].token == T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	$LN10@IncBinDire

; 229  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 230  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN11@IncBinDire

; 231  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@IncBinDire
$LN11@IncBinDire:

; 232  :         if ( opndx.kind == EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN12@IncBinDire

; 233  :             fileoffset = opndx.value;

	mov	eax, DWORD PTR opndx$[rsp]
	mov	DWORD PTR fileoffset$[rsp], eax
	jmp	SHORT $LN13@IncBinDire
$LN12@IncBinDire:

; 234  :         } else if ( opndx.kind != EXPR_EMPTY ) {

	cmp	DWORD PTR opndx$[rsp+60], -2
	je	SHORT $LN14@IncBinDire

; 235  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN1@IncBinDire
$LN14@IncBinDire:
$LN13@IncBinDire:

; 236  :         }
; 237  :         if ( tokenarray[i].token == T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN15@IncBinDire

; 238  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 239  :             if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN16@IncBinDire

; 240  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@IncBinDire
$LN16@IncBinDire:

; 241  :             if ( opndx.kind == EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN17@IncBinDire

; 242  :                 sizemax = opndx.value;

	mov	eax, DWORD PTR opndx$[rsp]
	mov	DWORD PTR sizemax$[rsp], eax
	jmp	SHORT $LN18@IncBinDire
$LN17@IncBinDire:

; 243  :             } else if ( opndx.kind != EXPR_EMPTY ) {

	cmp	DWORD PTR opndx$[rsp+60], -2
	je	SHORT $LN19@IncBinDire

; 244  :                 return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN1@IncBinDire
$LN19@IncBinDire:
$LN18@IncBinDire:
$LN15@IncBinDire:
$LN10@IncBinDire:

; 245  :             }
; 246  :         }
; 247  :     }
; 248  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN20@IncBinDire

; 249  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@IncBinDire
$LN20@IncBinDire:

; 250  :     }
; 251  : 
; 252  :     if( CurrSeg == NULL ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN21@IncBinDire

; 253  :         return( EmitError( MUST_BE_IN_SEGMENT_BLOCK ) );

	mov	ecx, 82					; 00000052H
	call	EmitError
	jmp	$LN1@IncBinDire
$LN21@IncBinDire:

; 254  :     }
; 255  : 
; 256  :     /* v2.04: tell assembler that data is emitted */
; 257  :     if ( ModuleInfo.CommentDataInCode )

	movzx	eax, BYTE PTR ModuleInfo+423
	test	eax, eax
	je	SHORT $LN22@IncBinDire

; 258  :         omf_OutSelect( TRUE );

	mov	cl, 1
	call	omf_OutSelect
$LN22@IncBinDire:

; 259  : 
; 260  :     DebugMsg1(("IncBinDirective: filename=%s, offset=%" I32_SPEC "u, size=%" I32_SPEC "u\n", StringBufferEnd, fileoffset, sizemax ));

	mov	r9d, DWORD PTR sizemax$[rsp]
	mov	r8d, DWORD PTR fileoffset$[rsp]
	mov	rdx, QWORD PTR ModuleInfo+488
	lea	rcx, OFFSET FLAT:$SG11290
	call	DoDebugMsg1

; 261  : 
; 262  :     /* try to open the file */
; 263  :     if ( file = SearchFile( StringBufferEnd, FALSE ) ) 

	xor	edx, edx
	mov	rcx, QWORD PTR ModuleInfo+488
	call	SearchFile
	mov	QWORD PTR file$[rsp], rax
	cmp	QWORD PTR file$[rsp], 0
	je	$LN23@IncBinDire

; 264  : 	{
; 265  : 		/* v2.14 : Get File Size */
; 266  : 		fseek( file, 0L, SEEK_END );

	mov	r8d, 2
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rsp]
	call	QWORD PTR __imp_fseek

; 267  : 		sz = ftell( file ) - fileoffset; // sz = total data size to load into segment/section.

	mov	rcx, QWORD PTR file$[rsp]
	call	QWORD PTR __imp_ftell
	sub	eax, DWORD PTR fileoffset$[rsp]
	mov	DWORD PTR sz$[rsp], eax

; 268  : 		fseek( file, 0L, SEEK_SET );

	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rsp]
	call	QWORD PTR __imp_fseek

; 269  : 		pBinData = (unsigned char*)malloc(sz);

	movsxd	rax, DWORD PTR sz$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR pBinData$[rsp], rax

; 270  : 		result = fread(pBinData, sz, 1, file);

	movsxd	rax, DWORD PTR sz$[rsp]
	mov	r9, QWORD PTR file$[rsp]
	mov	r8d, 1
	mov	rdx, rax
	mov	rcx, QWORD PTR pBinData$[rsp]
	call	QWORD PTR __imp_fread
	mov	QWORD PTR result$[rsp], rax

; 271  : 		OutputBinBytes(pBinData, sz);

	mov	edx, DWORD PTR sz$[rsp]
	mov	rcx, QWORD PTR pBinData$[rsp]
	call	OutputBinBytes

; 272  : 
; 273  :         /* transfer file content to the current segment. */
; 274  :         //if ( fileoffset )
; 275  :             //fseek( file, fileoffset, SEEK_SET );  /* fixme: use fseek64() */
; 276  :         //for( ; sizemax; sizemax-- ) {
; 277  :             //int ch = fgetc( file );
; 278  :             //if ( ( ch == EOF ) && feof( file ) )
; 279  :                 //break;
; 280  :             //OutputByte( ch );
; 281  :         //}
; 282  : 		free((void*)pBinData);

	mov	rcx, QWORD PTR pBinData$[rsp]
	call	QWORD PTR __imp_free

; 283  :         fclose( file );

	mov	rcx, QWORD PTR file$[rsp]
	call	QWORD PTR __imp_fclose
$LN23@IncBinDire:

; 284  :     }
; 285  : 
; 286  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@IncBinDire:

; 287  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:IncBinDirective$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 224				; 000000e0H
	pop	rdi
	ret	0
IncBinDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
EchoDirective PROC

; 55   : {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 56   :     if ( Parse_Pass == PASS_1 ) /* display in pass 1 only */

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN2@EchoDirect

; 57   :         if ( Options.preprocessor_stdout == FALSE ) { /* don't print to stdout if -EP is on! */

	movzx	eax, BYTE PTR Options+141
	test	eax, eax
	jne	SHORT $LN3@EchoDirect

; 58   :             printf( "%s\n", tokenarray[i+1].tokpos );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11210
	call	printf
$LN3@EchoDirect:
$LN2@EchoDirect:

; 59   :         }
; 60   :     return( NOT_ERROR );

	xor	eax, eax

; 61   : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
EchoDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
sym$ = 32
subst$ = 40
sym2$1 = 48
i$ = 80
tokenarray$ = 88
AliasDirective PROC

; 306  : {

$LN26:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+80]

; 307  :     //char *tmp;
; 308  :     struct asym *sym;
; 309  :     char *subst;
; 310  : 
; 311  :     i++; /* go past ALIAS */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 312  : 
; 313  :     if ( tokenarray[i].token != T_STRING ||

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN3@AliasDirec
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN2@AliasDirec
$LN3@AliasDirec:

; 314  :         tokenarray[i].string_delim != '<' ) {
; 315  :         DebugMsg(("AliasDirective: first argument is not a literal: %s\n", tokenarray[i].string_ptr ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11308
	call	DoDebugMsg

; 316  :         return( EmitError( TEXT_ITEM_REQUIRED ) );

	mov	ecx, 144				; 00000090H
	call	EmitError
	jmp	$LN1@AliasDirec
$LN2@AliasDirec:

; 317  :     }
; 318  : 
; 319  :     /* check syntax. note that '=' is T_DIRECTIVE && DRT_EQUALSGN */
; 320  :     if ( tokenarray[i+1].token != T_DIRECTIVE ||

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	SHORT $LN5@AliasDirec
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 48					; 00000030H
	je	SHORT $LN4@AliasDirec
$LN5@AliasDirec:

; 321  :         //tokenarray[i+1].tokval != T_EQU ||
; 322  :         tokenarray[i+1].dirtype != DRT_EQUALSGN ) {
; 323  :         DebugMsg(("AliasDirective: syntax error: %s\n", tokenarray[i+1].string_ptr ));

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11311
	call	DoDebugMsg

; 324  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].string_ptr ) );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@AliasDirec
$LN4@AliasDirec:

; 325  :     }
; 326  : 
; 327  :     if ( tokenarray[i+2].token != T_STRING ||

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 2
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN7@AliasDirec
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 2
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN6@AliasDirec
$LN7@AliasDirec:

; 328  :         tokenarray[i+2].string_delim != '<' )  {
; 329  :         DebugMsg(("AliasDirective: second argument is not a literal: %s\n", tokenarray[i+2].string_ptr ));

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 2
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11314
	call	DoDebugMsg

; 330  :         return( EmitError( TEXT_ITEM_REQUIRED ) );

	mov	ecx, 144				; 00000090H
	call	EmitError
	jmp	$LN1@AliasDirec
$LN6@AliasDirec:

; 331  :     }
; 332  :     subst = tokenarray[i+2].string_ptr;

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 2
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR subst$[rsp], rax

; 333  : 
; 334  :     if ( tokenarray[i+3].token != T_FINAL ) {

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 3
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN8@AliasDirec

; 335  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+3].string_ptr ) );

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 3
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@AliasDirec
$LN8@AliasDirec:

; 336  :     }
; 337  : 
; 338  :     /* make sure <alias_name> isn't defined elsewhere */
; 339  :     sym = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 340  :     if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN10@AliasDirec
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	$LN9@AliasDirec
$LN10@AliasDirec:

; 341  :         struct asym *sym2;
; 342  :         /* v2.04b: adjusted to new field <substitute> */
; 343  :         sym2 = SymSearch( subst );

	mov	rcx, QWORD PTR subst$[rsp]
	call	SymFind
	mov	QWORD PTR sym2$1[rsp], rax

; 344  :         if ( sym2 == NULL ) {

	cmp	QWORD PTR sym2$1[rsp], 0
	jne	SHORT $LN11@AliasDirec

; 345  :             sym2 = SymCreate( subst );

	mov	rcx, QWORD PTR subst$[rsp]
	call	SymCreate
	mov	QWORD PTR sym2$1[rsp], rax

; 346  :             sym2->state = SYM_UNDEFINED;

	mov	rax, QWORD PTR sym2$1[rsp]
	mov	DWORD PTR [rax+32], 0

; 347  :             sym_add_table( &SymTables[TAB_UNDEF], (struct dsym *)sym2 );

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym2$1[rsp]
	mov	rcx, rax
	call	sym_add_table

; 348  :         } else if ( sym2->state != SYM_UNDEFINED &&

	jmp	SHORT $LN12@AliasDirec
$LN11@AliasDirec:

; 349  :                    sym2->state != SYM_INTERNAL &&

	mov	rax, QWORD PTR sym2$1[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN13@AliasDirec
	mov	rax, QWORD PTR sym2$1[rsp]
	cmp	DWORD PTR [rax+32], 1
	je	SHORT $LN13@AliasDirec
	mov	rax, QWORD PTR sym2$1[rsp]
	cmp	DWORD PTR [rax+32], 2
	je	SHORT $LN13@AliasDirec

; 350  :                    sym2->state != SYM_EXTERNAL ) {
; 351  :             return( EmitErr( MUST_BE_PUBLIC_OR_EXTERNAL, subst ) );

	mov	rdx, QWORD PTR subst$[rsp]
	mov	ecx, 268				; 0000010cH
	call	EmitErr
	jmp	$LN1@AliasDirec
$LN13@AliasDirec:
$LN12@AliasDirec:

; 352  :         }
; 353  :         if ( sym == NULL )

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN14@AliasDirec

; 354  :             sym = SymCreate( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymCreate
	mov	QWORD PTR sym$[rsp], rax
	jmp	SHORT $LN15@AliasDirec
$LN14@AliasDirec:

; 355  :         else
; 356  :             sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_remove_table
$LN15@AliasDirec:

; 357  : 
; 358  :         sym->state = SYM_ALIAS;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+32], 8

; 359  :         sym->substitute = sym2;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR sym2$1[rsp]
	mov	QWORD PTR [rax+16], rcx

; 360  :         /* v2.10: copy language type of alias */
; 361  :         sym->langtype = sym2->langtype;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR sym2$1[rsp]
	mov	ecx, DWORD PTR [rcx+76]
	mov	DWORD PTR [rax+76], ecx

; 362  :         sym_add_table( &SymTables[TAB_ALIAS], (struct dsym *)sym ); /* add ALIAS */

	mov	eax, 16
	imul	rax, rax, 5
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_add_table

; 363  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@AliasDirec
$LN9@AliasDirec:

; 364  :     }
; 365  :     if ( sym->state != SYM_ALIAS || ( strcmp( sym->substitute->name, subst ) != 0 )) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 8
	jne	SHORT $LN17@AliasDirec
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rdx, QWORD PTR subst$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	strcmp
	test	eax, eax
	je	SHORT $LN16@AliasDirec
$LN17@AliasDirec:

; 366  :         DebugMsg(("AliasDirective: symbol redefinition\n"));

	lea	rcx, OFFSET FLAT:$SG11325
	call	DoDebugMsg

; 367  :         return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@AliasDirec
$LN16@AliasDirec:

; 368  :     }
; 369  : #if COFF_SUPPORT || ELF_SUPPORT
; 370  :     /* for COFF+ELF, make sure <actual_name> is "global" (EXTERNAL or
; 371  :      * public INTERNAL). For OMF, there's no check at all. */
; 372  :     if ( Parse_Pass != PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN18@AliasDirec

; 373  :         if ( Options.output_format == OFORMAT_COFF
; 374  : #if ELF_SUPPORT
; 375  :              || Options.output_format == OFORMAT_ELF

	cmp	DWORD PTR Options+160, 2
	je	SHORT $LN20@AliasDirec
	cmp	DWORD PTR Options+160, 3
	jne	SHORT $LN19@AliasDirec
$LN20@AliasDirec:

; 376  : #endif
; 377  :            ) {
; 378  :             if ( sym->substitute->state == SYM_UNDEFINED ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+16]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN21@AliasDirec

; 379  :                 return( EmitErr( SYMBOL_NOT_DEFINED, subst ) );

	mov	rdx, QWORD PTR subst$[rsp]
	mov	ecx, 102				; 00000066H
	call	EmitErr
	jmp	SHORT $LN1@AliasDirec
	jmp	SHORT $LN22@AliasDirec
$LN21@AliasDirec:

; 380  :             } else if ( sym->substitute->state != SYM_EXTERNAL &&

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+16]
	cmp	DWORD PTR [rax+32], 2
	je	SHORT $LN23@AliasDirec
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+16]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN24@AliasDirec
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN23@AliasDirec
$LN24@AliasDirec:

; 381  :                        ( sym->substitute->state != SYM_INTERNAL || sym->substitute->ispublic == FALSE ) ) {
; 382  :                 return( EmitErr( MUST_BE_PUBLIC_OR_EXTERNAL, subst ) );

	mov	rdx, QWORD PTR subst$[rsp]
	mov	ecx, 268				; 0000010cH
	call	EmitErr
	jmp	SHORT $LN1@AliasDirec
$LN23@AliasDirec:
$LN22@AliasDirec:
$LN19@AliasDirec:
$LN18@AliasDirec:

; 383  :             }
; 384  :         }
; 385  :     }
; 386  : #endif
; 387  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@AliasDirec:

; 388  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
AliasDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
oldradix$ = 48
opndx$ = 80
i$ = 224
tokenarray$ = 232
RadixDirective PROC

; 437  : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 208				; 000000d0H
	mov	rdi, rsp
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+224]

; 438  :     uint_8          oldradix;
; 439  :     struct expr     opndx;
; 440  : 
; 441  :     /* to get the .radix parameter, enforce radix 10 and retokenize! */
; 442  :     oldradix = ModuleInfo.radix;

	movzx	eax, BYTE PTR ModuleInfo+396
	mov	BYTE PTR oldradix$[rsp], al

; 443  :     ModuleInfo.radix = 10;

	mov	BYTE PTR ModuleInfo+396, 10

; 444  :     i++; /* skip directive token */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 445  :     Tokenize( tokenarray[i].tokpos, i, tokenarray, TOK_RESCAN );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+24]
	call	Tokenize

; 446  :     ModuleInfo.radix = oldradix;

	movzx	eax, BYTE PTR oldradix$[rsp]
	mov	BYTE PTR ModuleInfo+396, al

; 447  :     /* v2.11: flag NOUNDEF added - no forward ref possible */
; 448  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR ) {

	mov	BYTE PTR [rsp+32], 2
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN2@RadixDirec

; 449  :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@RadixDirec
$LN2@RadixDirec:

; 450  :     }
; 451  : 
; 452  :     if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN3@RadixDirec

; 453  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN1@RadixDirec
$LN3@RadixDirec:

; 454  :     }
; 455  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN4@RadixDirec

; 456  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@RadixDirec
$LN4@RadixDirec:

; 457  :     }
; 458  :     if ( opndx.value > 16 || opndx.value < 2 || opndx.hvalue != 0 ) {

	cmp	DWORD PTR opndx$[rsp], 16
	jg	SHORT $LN6@RadixDirec
	cmp	DWORD PTR opndx$[rsp], 2
	jl	SHORT $LN6@RadixDirec
	cmp	DWORD PTR opndx$[rsp+4], 0
	je	SHORT $LN5@RadixDirec
$LN6@RadixDirec:

; 459  :         return( EmitError( INVALID_RADIX_TAG ) );

	mov	ecx, 181				; 000000b5H
	call	EmitError
	jmp	SHORT $LN1@RadixDirec
$LN5@RadixDirec:

; 460  :     }
; 461  : 
; 462  :     ModuleInfo.radix = opndx.value;

	movzx	eax, BYTE PTR opndx$[rsp]
	mov	BYTE PTR ModuleInfo+396, al

; 463  :     DebugMsg(("RadixDirective: new radix=%u\n", ModuleInfo.radix ));

	movzx	eax, BYTE PTR ModuleInfo+396
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11356
	call	DoDebugMsg

; 464  : 
; 465  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@RadixDirec:

; 466  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:RadixDirective$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 208				; 000000d0H
	pop	rdi
	ret	0
RadixDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
SegOrderDirective PROC

; 472  : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 473  :     if ( tokenarray[i+1].token != T_FINAL ) {

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN2@SegOrderDi

; 474  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].tokpos ) );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@SegOrderDi
$LN2@SegOrderDi:

; 475  :     }
; 476  : #if COFF_SUPPORT || ELF_SUPPORT || PE_SUPPORT
; 477  :     if ( Options.output_format == OFORMAT_COFF
; 478  : #if ELF_SUPPORT
; 479  :         || Options.output_format == OFORMAT_ELF
; 480  : #endif
; 481  : #if PE_SUPPORT
; 482  :         || ( Options.output_format == OFORMAT_BIN && ModuleInfo.sub_format == SFORMAT_PE )

	cmp	DWORD PTR Options+160, 2
	je	SHORT $LN5@SegOrderDi
	cmp	DWORD PTR Options+160, 3
	je	SHORT $LN5@SegOrderDi
	cmp	DWORD PTR Options+160, 0
	jne	SHORT $LN3@SegOrderDi
	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN3@SegOrderDi
$LN5@SegOrderDi:

; 483  : #endif
; 484  :        ) {
; 485  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN6@SegOrderDi

; 486  :             EmitWarn( 2, NOT_SUPPORTED_WITH_CURR_FORMAT, _strupr( tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__strupr
	mov	r8, rax
	mov	edx, 224				; 000000e0H
	mov	ecx, 2
	call	EmitWarn
$LN6@SegOrderDi:

; 487  :     } else

	jmp	SHORT $LN4@SegOrderDi
$LN3@SegOrderDi:

; 488  : #endif
; 489  :         ModuleInfo.segorder = GetSflagsSp( tokenarray[i].tokval );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax+4]
	mov	DWORD PTR ModuleInfo+380, eax
$LN4@SegOrderDi:

; 490  : 
; 491  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SegOrderDi:

; 492  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SegOrderDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
i$ = 16
tokenarray$ = 24
StubDir	PROC

; 48   : ret_code StubDir( int i, struct asm_tok tokenarray[] ){ return( ERROR ); }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	mov	eax, -1
	pop	rdi
	ret	0
StubDir	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_TEXT	SEGMENT
name$ = 32
p$1 = 40
i$ = 64
tokenarray$ = 72
IncludeDirective PROC

; 70   : {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+64]

; 71   :     char *name;
; 72   : 
; 73   :     DebugMsg1(("IncludeDirective enter\n"));

	lea	rcx, OFFSET FLAT:$SG11221
	call	DoDebugMsg1

; 74   : 
; 75   :     if ( CurrFile[LST] ) {

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN5@IncludeDir

; 76   :         LstWriteSrcLine();

	call	LstWriteSrcLine
$LN5@IncludeDir:

; 77   :     }
; 78   : 
; 79   :     i++; /* skip directive */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 80   :     /* v2.03: allow plain numbers as file name argument */
; 81   :     //if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_NUM ) {
; 82   :     if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN6@IncludeDir

; 83   :         return( EmitError( EXPECTED_FILE_NAME ) );

	mov	ecx, 112				; 00000070H
	call	EmitError
	jmp	$LN1@IncludeDir
$LN6@IncludeDir:

; 84   :     }
; 85   : 
; 86   :     /* if the filename is enclosed in <>, just use this literal */
; 87   : 
; 88   :     if ( tokenarray[i].token == T_STRING && tokenarray[i].string_delim == '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN7@IncludeDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN7@IncludeDir

; 89   :         if ( tokenarray[i+1].token != T_FINAL ) {

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN9@IncludeDir

; 90   :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].tokpos ) );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@IncludeDir
$LN9@IncludeDir:

; 91   :         }
; 92   :         name = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR name$[rsp], rax

; 93   :     } else {

	jmp	SHORT $LN8@IncludeDir
$LN7@IncludeDir:

; 94   :         char *p;
; 95   :         /* if the filename isn't enclosed in <>, use anything that comes
; 96   :          * after INCLUDE - and remove trailing white spaces.
; 97   :          */
; 98   :         name = tokenarray[i].tokpos;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR name$[rsp], rax

; 99   :         for ( p = tokenarray[Token_Count].tokpos - 1; p > name && isspace(*p); *p = NULLC, p-- );

	movsxd	rax, DWORD PTR ModuleInfo+496
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	dec	rax
	mov	QWORD PTR p$1[rsp], rax
	jmp	SHORT $LN4@IncludeDir
$LN2@IncludeDir:
	mov	rax, QWORD PTR p$1[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR p$1[rsp]
	dec	rax
	mov	QWORD PTR p$1[rsp], rax
$LN4@IncludeDir:
	mov	rax, QWORD PTR name$[rsp]
	cmp	QWORD PTR p$1[rsp], rax
	jbe	SHORT $LN3@IncludeDir
	mov	rax, QWORD PTR p$1[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN3@IncludeDir
	jmp	SHORT $LN2@IncludeDir
$LN3@IncludeDir:
$LN8@IncludeDir:

; 100  :     }
; 101  :     if ( SearchFile( name, TRUE ) )

	mov	dl, 1
	mov	rcx, QWORD PTR name$[rsp]
	call	SearchFile
	test	rax, rax
	je	SHORT $LN10@IncludeDir

; 102  :         ProcessFile( tokenarray );   /* v2.11: process the file synchronously */

	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	ProcessFile
$LN10@IncludeDir:

; 103  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@IncludeDir:

; 104  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
IncludeDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Format$ = 96
printf	PROC						; COMDAT

; 950  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 957  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:printf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
	push	rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	rdi
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
