; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	banner_printed
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
banner_printed DB 01H DUP (?)
$SG11032 DB	01H DUP (?)
$SG11052 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG10947 DB	'%u%s. ', 00H
	ORG $+1
$SG10951 DB	'%s, %s', 0aH, 00H
$SG10959 DB	'%-20s %s', 0aH, 00H
	ORG $+2
$SG10987 DB	0aH, 00H
	ORG $+2
$SG10986 DB	'%s A%4u: ', 00H
	ORG $+2
$SG11006 DB	'w', 00H
	ORG $+2
$SG10989 DB	'                           %s', 00H
	ORG $+2
$SG11033 DB	'%s', 0aH, 00H
$SG11053 DB	'%s', 0aH, 00H
$SG11060 DB	'ENOENT', 00H
	ORG $+1
$SG11075 DB	'WriteError occured', 0aH, 00H
$SG11084 DB	'%s', 00H
	ORG $+1
$SG11083 DB	'InternalError enter', 0aH, 00H
_DATA	ENDS
CONST	SEGMENT
usage	DB	'   HJWasm [options] asm-file [options] [asm-file] ... [@'
	DB	'env_var]', 0aH, 0aH, 00H, 'options:', 00H, '-<0|1|..|10>[p]', 00H
	DB	'Set CPU: 0=8086 (default), 1=80186, 2=80286, 3=80386,', 00H, 00H
	DB	'4=80486, 5=Pentium, 6=PPro, 7=P2, 8=P3, 9=P4, 10=x86-64;', 00H
	DB	00H, '<p> allows privileged instructions', 00H, '-c', 00H, 'As'
	DB	'semble without linking (always set)', 00H, '-C<p|u|x>', 00H, 'S'
	DB	'et OPTION CASEMAP: p=NONE, u=ALL, x=NOTPUBLIC (default)', 00H
	DB	'-D<name>[=text]', 00H, 'Define text macro', 00H, '-e<number>', 00H
	DB	'Set error limit number (default=50)', 00H, '-EP', 00H, 'Outpu'
	DB	't preprocessed listing to stdout', 00H, '-eq', 00H, 'don''t d'
	DB	'isplay error messages', 00H, '-Fd[=<file_name>]', 00H, 'Write'
	DB	' import definition file', 00H, '-Fi<file_name>', 00H, 'Force '
	DB	'<file_name> to be included', 00H, '-Fl[=<file_name>]', 00H, 'W'
	DB	'rite listing file', 00H, '-Fo<file_name>', 00H, 'Set object f'
	DB	'ile name', 00H, '-Fw<file_name>', 00H, 'Set errors file name', 00H
	DB	'-FPi', 00H, '80x87 instructions with emulation fixups', 00H, '-'
	DB	'FPi87', 00H, '80x87 instructions (default)', 00H, '-fpc', 00H
	DB	'Disallow floating-point instructions (.NO87)', 00H, '-fp<n>', 00H
	DB	'Set FPU, <n> is: 0=8087 (default), 2=80287, 3=80387', 00H, '-'
	DB	'G<c|d|r|z>', 00H, 'Use Pascal, C, Fastcall or Stdcall calling'
	DB	' convention', 00H, '-I<directory>', 00H, 'Add directory to li'
	DB	'st of include directories', 00H, '-m<t|s|c|m|l|h|f>', 00H, 'S'
	DB	'et memory model:', 00H, 00H, '(Tiny, Small, Compact, Medium, '
	DB	'Large, Huge, Flat)', 00H, '-nc=<name>', 00H, 'Set class name '
	DB	'of code segment', 00H, '-n<d|m|t>=<name>', 00H, 'Set name of '
	DB	'd)ata segment, m)odule or t)ext segment', 00H, '-q, -nologo', 00H
	DB	'Don''t display version and copyright information', 00H, '-Sa', 00H
	DB	'Maximize source listing', 00H, '-safeseh', 00H, 'Assert all e'
	DB	'xception handlers are declared', 00H, '-Sf', 00H, 'Generate f'
	DB	'irst pass listing', 00H, '-Sg', 00H, 'Display generated code '
	DB	'in listing', 00H, '-Sn', 00H, 'Suppress symbol-table listing', 00H
	DB	'-Sx', 00H, 'List false conditionals', 00H, '-w', 00H, 'Same a'
	DB	's /W0 /WX', 00H, '-W<number>', 00H, 'Set warning level number'
	DB	' (default=2, max=4)', 00H, '-WX', 00H, 'Treat all warnings as'
	DB	' errors', 00H, '-X', 00H, 'Ignore INCLUDE environment path', 00H
	DB	'-zcm', 00H, 'C names are decorated with ''_'' prefix (default'
	DB	')', 00H, '-zcw', 00H, 'No name decoration for C symbols', 00H
	DB	'-Zd', 00H, 'Add line number debug info (OMF & COFF only)', 00H
	DB	'-Zf', 00H, 'Make all symbols public', 00H, '-zf<0|1>', 00H, 'S'
	DB	'et FASTCALL type: 0=MS VC style (default),', 00H, 00H, '1=OW '
	DB	'register calling convention', 00H, '-Zg', 00H, 'Generated cod'
	DB	'e is to exactly match Masm''s one', 00H, '-Zi[0|1|2|3]', 00H, 'A'
	DB	'dd symbolic debug info (OMF & COFF): 0=globals', 00H, 00H, '1'
	DB	'= +locals, 2= +types (default), 3= +constants', 00H, '-zlc', 00H
	DB	'No OMF records about data in code', 00H, '-zld', 00H, 'No OMF'
	DB	' records about far call optimization', 00H, '-zl<f|p|s>', 00H
	DB	'Suppress items in COFF symbol table: f=no .file entry,', 00H, 00H
	DB	'p=no static procs, s=no auxiliary entries for sections', 00H, '-'
	DB	'Zm', 00H, 'Masm v5.1 compatibility', 00H, '-Zne', 00H, 'Disab'
	DB	'le syntax extensions not supported by Masm', 00H, '-Zp[n]', 00H
	DB	'Set structure alignment, n=<1|2|4|8|16|32>', 00H, '-Zs', 00H, 'P'
	DB	'erform syntax check only', 00H, '-zt<0|1|2>', 00H, 'Set STDCA'
	DB	'LL symbol decoration: 0=No name decoration,', 00H, 00H, '1=No'
	DB	' ''@size'' suffix for functions, 2=Full (default)', 00H, '-Zv'
	DB	'8', 00H, 'Enable Masm v8+ PROC visibility', 00H, '-zze', 00H, 'N'
	DB	'o name decoration for exported symbols', 00H, '-zzs', 00H, 'S'
	DB	'tore decorated name of start address (COFF only)', 00H, '@env'
	DB	'_var', 00H, 'Environment variable or file containing further '
	DB	'commands', 00H, 'output formats:', 00H, 00H, '-bin', 00H, 'pl'
	DB	'ain binary file', 00H, '-coff', 00H, 'COFF object file', 00H, '-'
	DB	'elf', 00H, '32-bit ELF object file', 00H, '-elf64', 00H, '64-'
	DB	'bit ELF object file', 00H, '-mz', 00H, 'DOS MZ binary file', 00H
	DB	'-omf', 00H, 'OMF object file (default)', 00H, '-pe', 00H, 'PE'
	DB	' binary file, 32/64-bit', 00H, '-win64', 00H, '64-bit COFF ob'
	DB	'ject file', 00H, 'Debug options:', 00H, 00H, '-af', 00H, 'Dis'
	DB	'play all files used in assembly process', 00H, '-ce', 00H, 'C'
	DB	'ause an exception', 00H, '-dm', 00H, 'Display all messages', 00H
	DB	'-dr', 00H, 'Display reserved words', 00H, '-drh', 00H, 'Displ'
	DB	'ay reserved words hash table', 00H, '-ds', 00H, 'Display glob'
	DB	'al symbols', 00H, '-dsh', 00H, 'Display global symbols hash t'
	DB	'able', 00H, '-dt', 00H, 'Display debug trace', 00H, '-ls', 00H
	DB	'Display preprocessed line storage', 00H, '-nbp', 00H, 'Disabl'
	DB	'e backpatching', 00H, '-nfp', 00H, 'Do full subsequent passes'
	DB	' (disables "fastpass")', 00H, '-pm=<n>', 00H, 'Stop assembly '
	DB	'after <n> passes', 00H, '-sp', 00H, 'Skip preprocessor step', 00H
	DB	0aH, 00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	vprintf
PUBLIC	fprintf
PUBLIC	printf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	vsprintf
PUBLIC	sprintf
PUBLIC	DoDebugMsg
PUBLIC	DoDebugMsg1
PUBLIC	Fatal
PUBLIC	EmitError
PUBLIC	EmitErr
PUBLIC	EmitWarn
PUBLIC	PrintNote
PUBLIC	ErrnoStr
PUBLIC	write_logo
PUBLIC	PrintUsage
PUBLIC	WriteError
PUBLIC	InternalError
EXTRN	longjmp:PROC
EXTRN	__acrt_iob_func:PROC
EXTRN	fflush:PROC
EXTRN	fopen:PROC
EXTRN	fwrite:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	_errno:PROC
EXTRN	exit:PROC
EXTRN	strlen:PROC
EXTRN	close_files:PROC
EXTRN	myltoa:PROC
EXTRN	GetLineNumber:PROC
EXTRN	GetCurrSrcPos:PROC
EXTRN	GetTopLine:PROC
EXTRN	MsgGetEx:PROC
EXTRN	LstWrite:PROC
EXTRN	LstPrintf:PROC
EXTRN	LstNL:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	print_source_nesting_structure:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	write_to_file:BYTE
EXTRN	jmpenv:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

?buffer@?1??ErrnoStr@@9@9 DB 020H DUP (?)		; `ErrnoStr'::`2'::buffer
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vprintf DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$vprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vsprintf DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$vsprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$DoDebugMsg DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$DoDebugMsg
$pdata$DoDebugMsg1 DD imagerel $LN6
	DD	imagerel $LN6+192
	DD	imagerel $unwind$DoDebugMsg1
$pdata$Fatal DD	imagerel $LN4
	DD	imagerel $LN4+154
	DD	imagerel $unwind$Fatal
$pdata$EmitError DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$EmitError
$pdata$EmitErr DD imagerel $LN6
	DD	imagerel $LN6+223
	DD	imagerel $unwind$EmitErr
$pdata$EmitWarn DD imagerel $LN8
	DD	imagerel $LN8+243
	DD	imagerel $unwind$EmitWarn
$pdata$PrintNote DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$PrintNote
$pdata$ErrnoStr DD imagerel $LN5
	DD	imagerel $LN5+76
	DD	imagerel $unwind$ErrnoStr
$pdata$write_logo DD imagerel $LN4
	DD	imagerel $LN4+84
	DD	imagerel $unwind$write_logo
$pdata$PrintUsage DD imagerel $LN6
	DD	imagerel $LN6+113
	DD	imagerel $unwind$PrintUsage
$pdata$WriteError DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$WriteError
$pdata$PutMsg DD imagerel PutMsg
	DD	imagerel PutMsg+538
	DD	imagerel $unwind$PutMsg
$pdata$PrtMsg DD imagerel PrtMsg
	DD	imagerel PrtMsg+363
	DD	imagerel $unwind$PrtMsg
$pdata$InternalError DD imagerel $LN3
	DD	imagerel $LN3+198
	DD	imagerel $unwind$InternalError
pdata	ENDS
xdata	SEGMENT
$unwind$DoDebugMsg DD 011801H
	DD	06218H
$unwind$DoDebugMsg1 DD 022d19H
	DD	089011bH
	DD	imagerel __GSHandlerCheck
	DD	0430H
$unwind$Fatal DD 011701H
	DD	06217H
$unwind$EmitError DD 010801H
	DD	04208H
$unwind$EmitErr DD 011701H
	DD	08217H
$unwind$EmitWarn DD 011601H
	DD	08216H
$unwind$PrintNote DD 011701H
	DD	06217H
$unwind$ErrnoStr DD 010401H
	DD	08204H
$unwind$write_logo DD 010401H
	DD	06204H
$unwind$PrintUsage DD 010401H
	DD	06204H
$unwind$WriteError DD 010401H
	DD	04204H
$unwind$PutMsg DD 022c19H
	DD	09b011aH
	DD	imagerel __GSHandlerCheck
	DD	04c0H
$unwind$PrtMsg DD 011601H
	DD	06216H
$unwind$InternalError DD 022219H
	DD	0890110H
	DD	imagerel __GSHandlerCheck
	DD	0430H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vsprintf DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vprintf DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\errmsg.c
_TEXT	SEGMENT
tv75 = 32
buffer$ = 48
__$ArrayPad$ = 1072
file$ = 1104
line$ = 1112
InternalError PROC

; 356  : {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1096				; 00000448H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 357  : #if 1
; 358  :     char buffer[MAX_LINE_LEN];
; 359  :     DebugMsg(("InternalError enter\n"));

	lea	rcx, OFFSET FLAT:$SG11083
	call	DoDebugMsg

; 360  :     ModuleInfo.g.error_count++;

	mov	eax, DWORD PTR ModuleInfo
	inc	eax
	mov	DWORD PTR ModuleInfo, eax

; 361  :     GetCurrSrcPos( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	GetCurrSrcPos

; 362  :     fprintf( errout, "%s", buffer );

	mov	ecx, 1
	call	__acrt_iob_func
	lea	r8, QWORD PTR buffer$[rsp]
	lea	rdx, OFFSET FLAT:$SG11084
	mov	rcx, rax
	call	fprintf

; 363  :     fprintf( errout, MsgGetEx( INTERNAL_ERROR ), file, line );

	mov	ecx, 110				; 0000006eH
	call	MsgGetEx
	mov	QWORD PTR tv75[rsp], rax
	mov	ecx, 1
	call	__acrt_iob_func
	mov	r9d, DWORD PTR line$[rsp]
	mov	r8, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	fprintf

; 364  :     close_files();

	call	close_files

; 365  :     exit( EXIT_FAILURE );

	mov	ecx, 1
	call	exit

; 366  : #else
; 367  :     Fatal( INTERNAL_ERROR, file, line );
; 368  : #endif
; 369  :     return( 0 );

	xor	eax, eax
$LN2@InternalEr:

; 370  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1096				; 00000448H
	ret	0
InternalError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\errmsg.c
_TEXT	SEGMENT
p$1 = 32
severity$ = 64
msgnum$ = 72
args1$ = 80
args2$ = 88
PrtMsg	PROC

; 203  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 204  : #ifndef __SW_BD
; 205  :     write_logo();

	call	write_logo

; 206  : #endif
; 207  :     /* open .err file if not already open and a name is given */
; 208  :     if( CurrFile[ERR] == NULL && CurrFName[ERR] != NULL ) {

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	jne	$LN2@PrtMsg
	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	cmp	QWORD PTR [rcx+rax], 0
	je	$LN2@PrtMsg

; 209  :         CurrFile[ERR] = fopen( CurrFName[ERR], "w" );

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	lea	rdx, OFFSET FLAT:$SG11006
	mov	rcx, QWORD PTR [rcx+rax]
	call	fopen
	mov	ecx, 8
	imul	rcx, rcx, 3
	lea	rdx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR [rdx+rcx], rax

; 210  :         if( CurrFile[ERR] == NULL ) {

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	jne	SHORT $LN3@PrtMsg

; 211  :             /* v2.06: no fatal error anymore if error file cannot be written */
; 212  :             char *p = CurrFName[ERR];

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR p$1[rsp], rax

; 213  :             CurrFName[ERR] = NULL; /* set to NULL before EmitErr()! */

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	QWORD PTR [rcx+rax], 0

; 214  :             Options.no_error_disp = FALSE; /* disable -eq! */

	mov	BYTE PTR Options+12, 0

; 215  :             EmitErr( CANNOT_OPEN_FILE, p, ErrnoStr() );

	call	ErrnoStr
	mov	r8, rax
	mov	rdx, QWORD PTR p$1[rsp]
	mov	ecx, 106				; 0000006aH
	call	EmitErr
$LN3@PrtMsg:
$LN2@PrtMsg:

; 216  :             LclFree( p );
; 217  :         }
; 218  :     }
; 219  : 
; 220  :     /* v2.05: new option -eq */
; 221  :     if ( Options.no_error_disp == FALSE ) {

	movzx	eax, BYTE PTR Options+12
	test	eax, eax
	jne	SHORT $LN4@PrtMsg

; 222  :         PutMsg( errout, severity, msgnum, args1 );

	mov	ecx, 1
	call	__acrt_iob_func
	mov	r9, QWORD PTR args1$[rsp]
	mov	r8d, DWORD PTR msgnum$[rsp]
	mov	edx, DWORD PTR severity$[rsp]
	mov	rcx, rax
	call	PutMsg

; 223  :         fflush( errout );                       /* 27-feb-90 */

	mov	ecx, 1
	call	__acrt_iob_func
	mov	rcx, rax
	call	fflush
$LN4@PrtMsg:

; 224  :     }
; 225  :     if( CurrFile[ERR] ) {

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN5@PrtMsg

; 226  :         //Errfile_Written = TRUE;
; 227  :         PutMsg( CurrFile[ERR], severity, msgnum, args2 );

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR args2$[rsp]
	mov	r8d, DWORD PTR msgnum$[rsp]
	mov	edx, DWORD PTR severity$[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	PutMsg
$LN5@PrtMsg:

; 228  :     }
; 229  : }

	add	rsp, 56					; 00000038H
	ret	0
PrtMsg	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\errmsg.c
_TEXT	SEGMENT
i$ = 32
tv76 = 36
j$ = 40
type$ = 48
pMsg$ = 56
buffer$ = 64
__$ArrayPad$ = 1216
fp$ = 1248
severity$ = 1256
msgnum$ = 1264
args$ = 1272
PutMsg	PROC

; 162  : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1240				; 000004d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 163  :     int             i,j;
; 164  :     const char      *type;
; 165  :     const char      *pMsg;
; 166  :     char            buffer[MAX_LINE_LEN+128];
; 167  : 
; 168  :     if( fp != NULL ) {

	cmp	QWORD PTR fp$[rsp], 0
	je	$LN4@PutMsg

; 169  : 
; 170  :         if ( severity && ( j = GetCurrSrcPos( buffer ) ) ) {

	cmp	DWORD PTR severity$[rsp], 0
	je	SHORT $LN5@PutMsg
	lea	rcx, QWORD PTR buffer$[rsp]
	call	GetCurrSrcPos
	mov	DWORD PTR j$[rsp], eax
	cmp	DWORD PTR j$[rsp], 0
	je	SHORT $LN5@PutMsg

; 171  :             fwrite( buffer, 1, j, fp );

	movsxd	rax, DWORD PTR j$[rsp]
	mov	r9, QWORD PTR fp$[rsp]
	mov	r8, rax
	mov	edx, 1
	lea	rcx, QWORD PTR buffer$[rsp]
	call	fwrite
$LN5@PutMsg:

; 172  :         }
; 173  :         pMsg = MsgGetEx( msgnum );

	mov	ecx, DWORD PTR msgnum$[rsp]
	call	MsgGetEx
	mov	QWORD PTR pMsg$[rsp], rax

; 174  :         switch (severity ) {

	mov	eax, DWORD PTR severity$[rsp]
	mov	DWORD PTR tv76[rsp], eax
	cmp	DWORD PTR tv76[rsp], 1
	je	SHORT $LN6@PutMsg
	cmp	DWORD PTR tv76[rsp], 2
	je	SHORT $LN7@PutMsg
	cmp	DWORD PTR tv76[rsp], 4
	je	SHORT $LN8@PutMsg
	jmp	SHORT $LN9@PutMsg
$LN6@PutMsg:

; 175  :         case 1:  type = MsgGetEx( MSG_FATAL_PREFIX );   break;

	mov	ecx, 6
	call	MsgGetEx
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN2@PutMsg
$LN7@PutMsg:

; 176  :         case 2:  type = MsgGetEx( MSG_ERROR_PREFIX );   break;

	mov	ecx, 4
	call	MsgGetEx
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN2@PutMsg
$LN8@PutMsg:

; 177  :         case 4:  type = MsgGetEx( MSG_WARNING_PREFIX ); break;

	mov	ecx, 5
	call	MsgGetEx
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN2@PutMsg
$LN9@PutMsg:

; 178  :         default:  type = NULL; i = 0; break;

	mov	QWORD PTR type$[rsp], 0
	mov	DWORD PTR i$[rsp], 0
$LN2@PutMsg:

; 179  :         }
; 180  :         if ( type )

	cmp	QWORD PTR type$[rsp], 0
	je	SHORT $LN10@PutMsg

; 181  :             i = sprintf( buffer, "%s A%4u: ", type, severity * 1000 + msgnum );

	imul	eax, DWORD PTR severity$[rsp], 1000	; 000003e8H
	add	eax, DWORD PTR msgnum$[rsp]
	mov	r9d, eax
	mov	r8, QWORD PTR type$[rsp]
	lea	rdx, OFFSET FLAT:$SG10986
	lea	rcx, QWORD PTR buffer$[rsp]
	call	sprintf
	mov	DWORD PTR i$[rsp], eax
$LN10@PutMsg:

; 182  :         i += vsprintf( buffer+i, pMsg, args );

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rax, QWORD PTR buffer$[rsp+rax]
	mov	r8, QWORD PTR args$[rsp]
	mov	rdx, QWORD PTR pMsg$[rsp]
	mov	rcx, rax
	call	vsprintf
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$[rsp], eax

; 183  :         //buffer[i] = NULLC;
; 184  : 
; 185  :         fwrite( buffer, 1, i, fp );

	movsxd	rax, DWORD PTR i$[rsp]
	mov	r9, QWORD PTR fp$[rsp]
	mov	r8, rax
	mov	edx, 1
	lea	rcx, QWORD PTR buffer$[rsp]
	call	fwrite

; 186  :         fwrite( "\n", 1, 1, fp );

	mov	r9, QWORD PTR fp$[rsp]
	mov	r8d, 1
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG10987
	call	fwrite

; 187  : 
; 188  :         /* if in Pass 1, add the error msg to the listing */
; 189  :         if ( CurrFile[LST] &&
; 190  :              severity &&
; 191  :              Parse_Pass == PASS_1 &&

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN11@PutMsg
	cmp	DWORD PTR severity$[rsp], 0
	je	SHORT $LN11@PutMsg
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN11@PutMsg
	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rax, QWORD PTR [rcx+rax]
	cmp	QWORD PTR fp$[rsp], rax
	jne	SHORT $LN11@PutMsg

; 192  :              fp == CurrFile[ERR] ) {
; 193  :             LstWrite( LSTTYPE_DIRECTIVE, GetCurrOffset(), 0 );

	call	GetCurrOffset
	xor	r8d, r8d
	mov	edx, eax
	mov	ecx, 4
	call	LstWrite

; 194  :             /* size of "blank" prefix to be explained! */
; 195  :             LstPrintf( "                           %s", buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, OFFSET FLAT:$SG10989
	call	LstPrintf

; 196  :             LstNL();

	call	LstNL
$LN11@PutMsg:
$LN4@PutMsg:

; 197  :         }
; 198  :     }
; 199  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1240				; 000004d8H
	ret	0
PutMsg	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\errmsg.c
_TEXT	SEGMENT
WriteError PROC

; 346  : {

$LN3:
	sub	rsp, 40					; 00000028H

; 347  :     DebugMsg(("WriteError occured\n"));

	lea	rcx, OFFSET FLAT:$SG11075
	call	DoDebugMsg

; 348  :     Fatal( FILE_WRITE_ERROR, CurrFName[OBJ], errno );

	call	_errno
	mov	ecx, 8
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:ModuleInfo+128
	mov	r8d, DWORD PTR [rax]
	mov	rdx, QWORD PTR [rdx+rcx]
	mov	ecx, 108				; 0000006cH
	call	Fatal

; 349  : };

	add	rsp, 40					; 00000028H
	ret	0
WriteError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\errmsg.c
_TEXT	SEGMENT
p$ = 32
p2$1 = 40
PrintUsage PROC

; 150  : {

$LN6:
	sub	rsp, 56					; 00000038H

; 151  :     const char *p;
; 152  :     write_logo();

	call	write_logo

; 153  :     for ( p = usage; *p != '\n'; ) {

	lea	rax, OFFSET FLAT:usage
	mov	QWORD PTR p$[rsp], rax
$LN2@PrintUsage:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 10
	je	SHORT $LN3@PrintUsage

; 154  :         const char *p2 = p + strlen( p ) + 1;

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR p2$1[rsp], rax

; 155  :         printf("%-20s %s\n", p, p2 );

	mov	r8, QWORD PTR p2$1[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, OFFSET FLAT:$SG10959
	call	printf

; 156  :         p = p2 + strlen( p2 ) + 1;

	mov	rcx, QWORD PTR p2$1[rsp]
	call	strlen
	mov	rcx, QWORD PTR p2$1[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR p$[rsp], rax

; 157  :     }

	jmp	SHORT $LN2@PrintUsage
$LN3@PrintUsage:

; 158  : }

	add	rsp, 56					; 00000038H
	ret	0
PrintUsage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\errmsg.c
_TEXT	SEGMENT
tv67 = 32
write_logo PROC

; 139  : {

$LN4:
	sub	rsp, 56					; 00000038H

; 140  :     if( banner_printed == FALSE ) {

	movsx	eax, BYTE PTR banner_printed
	test	eax, eax
	jne	SHORT $LN2@write_logo

; 141  :         banner_printed = TRUE;

	mov	BYTE PTR banner_printed, 1

; 142  :         printf( "%s, %s\n", MsgGetEx( MSG_HJWASM ), MsgGetEx( MSG_HJWASM2 ) );

	mov	ecx, 3
	call	MsgGetEx
	mov	QWORD PTR tv67[rsp], rax
	mov	ecx, 2
	call	MsgGetEx
	mov	rcx, QWORD PTR tv67[rsp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG10951
	call	printf

; 143  :         return( 4 ); /* return number of lines printed */

	mov	eax, 4
	jmp	SHORT $LN1@write_logo
$LN2@write_logo:

; 144  :     }
; 145  :     return( 0 );

	xor	eax, eax
$LN1@write_logo:

; 146  : }

	add	rsp, 56					; 00000038H
	ret	0
write_logo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\errmsg.c
_TEXT	SEGMENT
tv73 = 48
ErrnoStr PROC

; 299  : {

$LN5:
	sub	rsp, 72					; 00000048H

; 300  :     static char buffer[32];
; 301  :     return( ( errno == ENOENT ) ? "ENOENT" : myltoa( errno, buffer, 10, FALSE, FALSE ) );

	call	_errno
	cmp	DWORD PTR [rax], 2
	jne	SHORT $LN3@ErrnoStr
	lea	rax, OFFSET FLAT:$SG11060
	mov	QWORD PTR tv73[rsp], rax
	jmp	SHORT $LN4@ErrnoStr
$LN3@ErrnoStr:
	call	_errno
	mov	BYTE PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8d, 10
	lea	rdx, OFFSET FLAT:?buffer@?1??ErrnoStr@@9@9
	mov	ecx, DWORD PTR [rax]
	call	myltoa
	mov	QWORD PTR tv73[rsp], rax
$LN4@ErrnoStr:
	mov	rax, QWORD PTR tv73[rsp]

; 302  : }

	add	rsp, 72					; 00000048H
	ret	0
ErrnoStr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\errmsg.c
_TEXT	SEGMENT
args1$ = 32
args2$ = 40
msgnum$ = 64
PrintNote PROC

; 235  : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 236  :     va_list args1, args2;
; 237  : 
; 238  :     va_start( args1, msgnum );

	lea	rax, QWORD PTR msgnum$[rsp+8]
	mov	QWORD PTR args1$[rsp], rax

; 239  :     va_start( args2, msgnum );

	lea	rax, QWORD PTR msgnum$[rsp+8]
	mov	QWORD PTR args2$[rsp], rax

; 240  : 
; 241  :     PrtMsg( 0, msgnum, args1, args2 );

	mov	r9, QWORD PTR args2$[rsp]
	mov	r8, QWORD PTR args1$[rsp]
	mov	edx, DWORD PTR msgnum$[rsp]
	xor	ecx, ecx
	call	PrtMsg

; 242  :     va_end( args1 );

	mov	QWORD PTR args1$[rsp], 0

; 243  :     va_end( args2 );

	mov	QWORD PTR args2$[rsp], 0

; 244  : }

	add	rsp, 56					; 00000038H
	ret	0
PrintNote ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\errmsg.c
_TEXT	SEGMENT
args1$ = 32
args2$ = 40
tv71 = 48
level$ = 80
msgnum$ = 88
EmitWarn PROC

; 275  : {

$LN8:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 72					; 00000048H

; 276  :     va_list args1, args2;
; 277  : 
; 278  :     if( level <= Options.warning_level ) {

	movzx	eax, BYTE PTR Options+13
	cmp	DWORD PTR level$[rsp], eax
	jg	$LN2@EmitWarn

; 279  : #ifdef DEBUG_OUT
; 280  :         printf( "%s\n", ModuleInfo.tokenarray ? ModuleInfo.tokenarray[0].tokpos : "" );

	cmp	QWORD PTR ModuleInfo+480, 0
	je	SHORT $LN6@EmitWarn
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR ModuleInfo+480
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR tv71[rsp], rax
	jmp	SHORT $LN7@EmitWarn
$LN6@EmitWarn:
	lea	rax, OFFSET FLAT:$SG11052
	mov	QWORD PTR tv71[rsp], rax
$LN7@EmitWarn:
	mov	rdx, QWORD PTR tv71[rsp]
	lea	rcx, OFFSET FLAT:$SG11053
	call	printf

; 281  : #endif
; 282  :         va_start( args1, msgnum );

	lea	rax, QWORD PTR msgnum$[rsp+8]
	mov	QWORD PTR args1$[rsp], rax

; 283  :         va_start( args2, msgnum );

	lea	rax, QWORD PTR msgnum$[rsp+8]
	mov	QWORD PTR args2$[rsp], rax

; 284  :         if( !Options.warning_error ) {

	movzx	eax, BYTE PTR Options+14
	test	eax, eax
	jne	SHORT $LN3@EmitWarn

; 285  :             PrtMsg( 4, msgnum, args1, args2 );

	mov	r9, QWORD PTR args2$[rsp]
	mov	r8, QWORD PTR args1$[rsp]
	mov	edx, DWORD PTR msgnum$[rsp]
	mov	ecx, 4
	call	PrtMsg

; 286  :             ModuleInfo.g.warning_count++;

	mov	eax, DWORD PTR ModuleInfo+4
	inc	eax
	mov	DWORD PTR ModuleInfo+4, eax

; 287  :         } else {

	jmp	SHORT $LN4@EmitWarn
$LN3@EmitWarn:

; 288  :             PrtMsg( 2, msgnum, args1, args2 );

	mov	r9, QWORD PTR args2$[rsp]
	mov	r8, QWORD PTR args1$[rsp]
	mov	edx, DWORD PTR msgnum$[rsp]
	mov	ecx, 2
	call	PrtMsg

; 289  :             ModuleInfo.g.error_count++;

	mov	eax, DWORD PTR ModuleInfo
	inc	eax
	mov	DWORD PTR ModuleInfo, eax
$LN4@EmitWarn:

; 290  :         }
; 291  :         va_end( args1 );

	mov	QWORD PTR args1$[rsp], 0

; 292  :         va_end( args2 );

	mov	QWORD PTR args2$[rsp], 0

; 293  :         print_source_nesting_structure();

	call	print_source_nesting_structure
$LN2@EmitWarn:

; 294  :     }
; 295  : }

	add	rsp, 72					; 00000048H
	ret	0
EmitWarn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\errmsg.c
_TEXT	SEGMENT
tv69 = 32
args1$ = 40
args2$ = 48
msgnum$ = 80
EmitErr	PROC

; 248  : {

$LN6:
	mov	DWORD PTR [rsp+8], ecx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 72					; 00000048H

; 249  :     va_list args1, args2;
; 250  : 
; 251  : #ifdef DEBUG_OUT
; 252  :     printf( "%s\n", ModuleInfo.tokenarray ? ModuleInfo.tokenarray[0].tokpos : "" );

	cmp	QWORD PTR ModuleInfo+480, 0
	je	SHORT $LN4@EmitErr
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR ModuleInfo+480
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN5@EmitErr
$LN4@EmitErr:
	lea	rax, OFFSET FLAT:$SG11032
	mov	QWORD PTR tv69[rsp], rax
$LN5@EmitErr:
	mov	rdx, QWORD PTR tv69[rsp]
	lea	rcx, OFFSET FLAT:$SG11033
	call	printf

; 253  : #endif
; 254  :     va_start( args1, msgnum );

	lea	rax, QWORD PTR msgnum$[rsp+8]
	mov	QWORD PTR args1$[rsp], rax

; 255  :     va_start( args2, msgnum );

	lea	rax, QWORD PTR msgnum$[rsp+8]
	mov	QWORD PTR args2$[rsp], rax

; 256  :     PrtMsg( 2, msgnum, args1, args2 );

	mov	r9, QWORD PTR args2$[rsp]
	mov	r8, QWORD PTR args1$[rsp]
	mov	edx, DWORD PTR msgnum$[rsp]
	mov	ecx, 2
	call	PrtMsg

; 257  :     va_end( args1 );

	mov	QWORD PTR args1$[rsp], 0

; 258  :     va_end( args2 );

	mov	QWORD PTR args2$[rsp], 0

; 259  :     ModuleInfo.g.error_count++;

	mov	eax, DWORD PTR ModuleInfo
	inc	eax
	mov	DWORD PTR ModuleInfo, eax

; 260  :     write_to_file = FALSE;

	mov	BYTE PTR write_to_file, 0

; 261  :     print_source_nesting_structure();

	call	print_source_nesting_structure

; 262  :     if( Options.error_limit != -1  &&  ModuleInfo.g.error_count == Options.error_limit+1 )

	cmp	DWORD PTR Options+8, -1
	je	SHORT $LN2@EmitErr
	mov	eax, DWORD PTR Options+8
	inc	eax
	cmp	DWORD PTR ModuleInfo, eax
	jne	SHORT $LN2@EmitErr

; 263  :         Fatal( TOO_MANY_ERRORS );

	mov	ecx, 113				; 00000071H
	call	Fatal
$LN2@EmitErr:

; 264  :     return( ERROR );

	mov	eax, -1

; 265  : }

	add	rsp, 72					; 00000048H
	ret	0
EmitErr	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\errmsg.c
_TEXT	SEGMENT
msgnum$ = 48
EmitError PROC

; 269  : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 270  :     return( EmitErr( msgnum ) );

	mov	ecx, DWORD PTR msgnum$[rsp]
	call	EmitErr

; 271  : }

	add	rsp, 40					; 00000028H
	ret	0
EmitError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\errmsg.c
_TEXT	SEGMENT
args1$ = 32
args2$ = 40
msgnum$ = 64
Fatal	PROC

; 310  : {

$LN4:
	mov	DWORD PTR [rsp+8], ecx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 311  :     va_list     args1, args2;
; 312  : 
; 313  :     /* v2.11: call PrtMsg() instead of PutMsg().
; 314  :      * Makes the fatal error appear in the .ERR and .LST files
; 315  :      */
; 316  :     va_start( args1, msgnum );

	lea	rax, QWORD PTR msgnum$[rsp+8]
	mov	QWORD PTR args1$[rsp], rax

; 317  :     va_start( args2, msgnum );

	lea	rax, QWORD PTR msgnum$[rsp+8]
	mov	QWORD PTR args2$[rsp], rax

; 318  :     PrtMsg( 1, msgnum, args1, args2 );

	mov	r9, QWORD PTR args2$[rsp]
	mov	r8, QWORD PTR args1$[rsp]
	mov	edx, DWORD PTR msgnum$[rsp]
	mov	ecx, 1
	call	PrtMsg

; 319  :     va_end( args1 );

	mov	QWORD PTR args1$[rsp], 0

; 320  :     va_end( args2 );

	mov	QWORD PTR args2$[rsp], 0

; 321  : 
; 322  :     ModuleInfo.g.error_count++;

	mov	eax, DWORD PTR ModuleInfo
	inc	eax
	mov	DWORD PTR ModuleInfo, eax

; 323  :     //write_to_file = FALSE;
; 324  : 
; 325  :     /* setjmp() has been called in AssembleModule().
; 326  :      * if a fatal error happens outside of this function, longjmp()
; 327  :      * is NOT to be used ( out of memory condition, @cmd file open error, ... )
; 328  :      */
; 329  :     if ( CurrFName[ASM] )

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN2@Fatal

; 330  :         longjmp( jmpenv, 2 );

	mov	edx, 2
	lea	rcx, OFFSET FLAT:jmpenv
	call	longjmp
$LN2@Fatal:

; 331  : 
; 332  :     exit(1);

	mov	ecx, 1
	call	exit
$LN3@Fatal:

; 333  : }

	add	rsp, 56					; 00000038H
	ret	0
Fatal	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\errmsg.c
_TEXT	SEGMENT
args$ = 32
tv71 = 40
buffer$ = 48
__$ArrayPad$ = 1072
format$ = 1104
DoDebugMsg1 PROC

; 99   : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 1096				; 00000448H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 100  :     va_list args;
; 101  :     char buffer[MAX_LINE_LEN];
; 102  : 
; 103  :     if( !Options.debug ) return;

	movzx	eax, BYTE PTR Options+15
	test	eax, eax
	jne	SHORT $LN2@DoDebugMsg
	jmp	SHORT $LN1@DoDebugMsg
$LN2@DoDebugMsg:

; 104  : 
; 105  :     if( ModuleInfo.cref == FALSE ) return;

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 12
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN3@DoDebugMsg
	jmp	SHORT $LN1@DoDebugMsg
$LN3@DoDebugMsg:

; 106  : 
; 107  : #ifdef DBGLOGFILE
; 108  :     if ( fdbglog == NULL )
; 109  :         fdbglog = fopen( DBGLOGFILE, "w" );
; 110  : #endif
; 111  :     //if ( CurrFName[ASM] )
; 112  :     if ( ModuleInfo.g.src_stack ) {

	cmp	QWORD PTR ModuleInfo+200, 0
	je	SHORT $LN4@DoDebugMsg

; 113  : #ifdef DBGLOGFILE
; 114  :         fprintf( fdbglog, "%" I32_SPEC "u%s. ", GetLineNumber(), GetTopLine( buffer ) );
; 115  : #else
; 116  :         printf( "%" I32_SPEC "u%s. ", GetLineNumber(), GetTopLine( buffer ) );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	GetTopLine
	mov	QWORD PTR tv71[rsp], rax
	call	GetLineNumber
	mov	rcx, QWORD PTR tv71[rsp]
	mov	r8, rcx
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG10947
	call	printf
$LN4@DoDebugMsg:

; 117  : #endif
; 118  :     }
; 119  :     va_start( args, format );

	lea	rax, QWORD PTR format$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 120  : #ifdef DBGLOGFILE
; 121  :     vfprintf( fdbglog, format, args );
; 122  : #else
; 123  :     vprintf( format, args );

	mov	rdx, QWORD PTR args$[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	vprintf

; 124  : #endif
; 125  :     va_end( args );

	mov	QWORD PTR args$[rsp], 0
$LN1@DoDebugMsg:

; 126  : 
; 127  : #if 0
; 128  : #ifdef DBGLOGFILE
; 129  :     fflush( fdbglog );
; 130  : #else
; 131  :     fflush( stdout );
; 132  : #endif
; 133  : #endif
; 134  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1096				; 00000448H
	ret	0
DoDebugMsg1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\errmsg.c
_TEXT	SEGMENT
args$ = 32
format$ = 64
DoDebugMsg PROC

; 73   : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 74   :     va_list args;
; 75   :     if( !Options.debug ) return;

	movzx	eax, BYTE PTR Options+15
	test	eax, eax
	jne	SHORT $LN2@DoDebugMsg
	jmp	SHORT $LN1@DoDebugMsg
$LN2@DoDebugMsg:

; 76   : 
; 77   :     if( ModuleInfo.cref == FALSE && CurrFName[ASM] != NULL )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 12
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN3@DoDebugMsg
	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN3@DoDebugMsg

; 78   :         return;

	jmp	SHORT $LN1@DoDebugMsg
$LN3@DoDebugMsg:

; 79   : 
; 80   :     va_start( args, format );

	lea	rax, QWORD PTR format$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 81   : #ifdef DBGLOGFILE
; 82   :     if ( fdbglog == NULL )
; 83   :         fdbglog = fopen( DBGLOGFILE, "w" );
; 84   :     vfprintf( fdbglog, format, args );
; 85   : #else
; 86   :     vprintf( format, args );

	mov	rdx, QWORD PTR args$[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	vprintf

; 87   : #endif
; 88   :     va_end( args );

	mov	QWORD PTR args$[rsp], 0
$LN1@DoDebugMsg:

; 89   : #if 0
; 90   : #ifdef DBGLOGFILE
; 91   :     fflush( fdbglog );
; 92   : #else
; 93   :     fflush( stdout );
; 94   : #endif
; 95   : #endif
; 96   : }

	add	rsp, 56					; 00000038H
	ret	0
DoDebugMsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1788 : }

	add	rsp, 56					; 00000038H
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT vsprintf
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_ArgList$ = 80
vsprintf PROC						; COMDAT

; 1473 : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1474 :     #pragma warning(push)
; 1475 :     #pragma warning(disable: 4996) // Deprecation
; 1476 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1477 :     #pragma warning(pop)
; 1478 : }

	add	rsp, 56					; 00000038H
	ret	0
vsprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

	add	rsp, 56					; 00000038H
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	__stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1391 : }

	add	rsp, 72					; 00000048H
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 950  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 957  : }

	add	rsp, 56					; 00000038H
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Stream$ = 64
_Format$ = 72
fprintf	PROC						; COMDAT

; 831  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 832  :     int _Result;
; 833  :     va_list _ArgList;
; 834  :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 835  :     _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Stream$[rsp]
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 836  :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 837  :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 838  : }

	add	rsp, 56					; 00000038H
	ret	0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT vprintf
_TEXT	SEGMENT
_Format$ = 48
_ArgList$ = 56
vprintf	PROC						; COMDAT

; 741  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 742  :     return _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l

; 743  : }

	add	rsp, 40					; 00000028H
	ret	0
vprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 640  : }

	add	rsp, 56					; 00000038H
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
