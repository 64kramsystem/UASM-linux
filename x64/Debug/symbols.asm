; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

EXTRN	ModuleInfo:BYTE
EXTRN	FileCur:QWORD
EXTRN	LineCur:QWORD
EXTRN	symCurSeg:QWORD
EXTRN	UpdateLineNumber:PROC
EXTRN	UpdateWordSize:PROC
EXTRN	UpdateCurPC:PROC
_DATA	SEGMENT
COMM	SymCmpFunc:QWORD
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
szDate	DB	0cH DUP (?)
szTime	DB	0cH DUP (?)
symPC	DQ	01H DUP (?)
$SG11066 DB	01H DUP (?)
	ALIGN	4

$SG11131 DB	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
tmtab	DQ	FLAT:$SG11059
	DQ	FLAT:$SG11060
	DQ	0000000000000000H
	DQ	FLAT:$SG11061
	DQ	FLAT:szDate
	DQ	0000000000000000H
	DQ	FLAT:$SG11062
	DQ	FLAT:szTime
	DQ	0000000000000000H
	DQ	FLAT:$SG11063
	DQ	FLAT:ModuleInfo+512
	DQ	0000000000000000H
	DQ	FLAT:$SG11064
	DQ	0000000000000000H
	DQ	FLAT:FileCur
	DQ	FLAT:$SG11065
	DQ	FLAT:$SG11066
	DQ	FLAT:symCurSeg
eqtab	DQ	FLAT:$SG11080
	DD	0d7H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:$SG11081
	DD	0d4H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:$SG11082
	DD	00H
	ORG $+4
	DQ	FLAT:UpdateCurPC
	DQ	FLAT:symPC
	DQ	FLAT:$SG11083
	DD	00H
	ORG $+4
	DQ	FLAT:UpdateLineNumber
	DQ	FLAT:LineCur
	DQ	FLAT:$SG11084
	DD	00H
	ORG $+4
	DQ	FLAT:UpdateWordSize
	DQ	0000000000000000H
CONST	ENDS
_DATA	SEGMENT
$SG11280 DB	'%4u ', 00H
	ORG $+3
$SG11281 DB	'%-16s ', 00H
	ORG $+1
$SG11282 DB	0aH, 00H
	ORG $+2
$SG11402 DB	'__m128', 00H
	ORG $+1
$SG11060 DB	'800', 00H
$SG11283 DB	'symbols.c', 00H
	ORG $+2
$SG11403 DB	'__m256', 00H
	ORG $+1
$SG11082 DB	'$', 00H
	ORG $+2
$SG11298 DB	'SymInit() enter', 0aH, 00H
	ORG $+3
$SG11465 DB	'Number', 00H
	ORG $+5
$SG11299 DB	'%02u/%02u/%02u', 00H
	ORG $+1
$SG11300 DB	'%02u:%02u:%02u', 00H
	ORG $+1
$SG11303 DB	'SymInit() exit', 0aH, 00H
$SG11474 DB	'Proto', 00H
	ORG $+2
$SG11438 DB	'Symbol VectorCall Settings: %s isHomogenous:%u isHFA:%u '
	DB	'isHVA:%u MMType:%u memberCount:%u', 0aH, 00H
	ORG $+5
$SG11458 DB	'Undefined', 00H
	ORG $+6
$SG11462 DB	'Procedure', 00H
	ORG $+6
$SG11469 DB	'Code Label', 00H
	ORG $+5
$SG11470 DB	'Data Label', 00H
	ORG $+5
$SG11477 DB	'Communal', 00H
	ORG $+7
$SG11480 DB	'Number (ext)', 00H
	ORG $+3
$SG11484 DB	'Code (ext)', 00H
	ORG $+5
$SG11485 DB	'Data (ext)', 00H
	ORG $+5
$SG11487 DB	'Segment', 00H
$SG11489 DB	'Group', 00H
	ORG $+2
$SG11491 DB	'Stack Var', 00H
	ORG $+6
$SG11493 DB	'Struct Field', 00H
	ORG $+3
$SG11496 DB	'Structure', 00H
	ORG $+2
$SG11498 DB	'Union', 00H
	ORG $+6
$SG11500 DB	'Typedef', 00H
$SG11502 DB	'Record', 00H
	ORG $+1
$SG11504 DB	'Undef Type', 00H
	ORG $+1
$SG11506 DB	'Alias', 00H
	ORG $+2
$SG11508 DB	'Macro', 00H
	ORG $+2
$SG11510 DB	'Text', 00H
	ORG $+7
$SG11512 DB	'Unknown', 00H
$SG11513 DB	'%-12s  %16I64X %02X %8p %c %8p %s', 0aH, 00H
	ORG $+5
$SG11531 DB	'DumpSymbols enter', 0aH, 00H
	ORG $+5
$SG11546 DB	'%u items in symbol table, expected %u', 0aH, 00H
	ORG $+1
$SG11533 DB	'   # Addr     Type                     Value MT    Ext  '
	DB	' P  pName   Name', 0aH, 00H
	ORG $+6
$SG11534 DB	'--------------------------------------------------------'
	DB	'------------------------', 0aH, 00H
	ORG $+6
$SG11536 DB	'%4u %8p ', 00H
	ORG $+3
$SG11061 DB	'@Date', 00H
	ORG $+6
$SG11547 DB	'max items in a line=%u, lines with 0/1/<=5/<=10 items=%u'
	DB	'/%u/%u/%u, ', 0aH, 00H
	ORG $+3
$SG11059 DB	'@Version', 00H
	ORG $+3
$SG11062 DB	'@Time', 00H
	ORG $+6
$SG11063 DB	'@FileName', 00H
	ORG $+6
$SG11064 DB	'@FileCur', 00H
	ORG $+7
$SG11065 DB	'@CurSeg', 00H
$SG11080 DB	'__HJWASM__', 00H
	ORG $+5
$SG11081 DB	'__JWASM__', 00H
	ORG $+2
$SG11083 DB	'@Line', 00H
	ORG $+6
$SG11084 DB	'@WordSize', 00H
	ORG $+6
$SG11120 DB	'SymSetLocal(%s): label=%s', 0aH, 00H
	ORG $+5
$SG11146 DB	'SymFind(%s): found in local table, state=%u, local=%u', 0aH
	DB	00H
	ORG $+1
$SG11148 DB	'SymFind(%s): found, state=%u memtype=%X lang=%u', 0aH, 00H
	ORG $+7
$SG11163 DB	'SymFind(%s): found in local table, state=%u, local=%u', 0aH
	DB	00H
	ORG $+1
$SG11165 DB	'SymFind(%s): found, state=%u memtype=%X lang=%u', 0aH, 00H
	ORG $+3
$SG11172 DB	'NULL', 00H
	ORG $+7
$SG11173 DB	'SymLookup(%s): created new symbol, CurrProc=%s', 0aH, 00H
$SG11174 DB	'SymLookup(%s): found, state=%u, defined=%u', 0aH, 00H
	ORG $+4
$SG11183 DB	'SymLookupLocal(%s): local symbol created in %s', 0aH, 00H
$SG11185 DB	'SymLookupLocal(%s): label moved into %s''s local namespa'
	DB	'ce', 0aH, 00H
	ORG $+5
$SG11186 DB	'SymLookupLocal(%s): found, state=%u, defined=%u', 0aH, 00H
	ORG $+7
$SG11199 DB	'free_ext: item=%p name=%s state=%u', 0aH, 00H
	ORG $+4
$SG11205 DB	'free_ext: external with private type: %s', 0aH, 00H
	ORG $+6
$SG11215 DB	'free_ext: case SYM_STACK, sym=%s with private type', 0aH
	DB	00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	SymAlloc
PUBLIC	SymFree
PUBLIC	SymCreate
PUBLIC	SymLCreate
PUBLIC	SymAddGlobal
PUBLIC	SymAddLocal
PUBLIC	SymLookup
PUBLIC	SymLookupLocal
PUBLIC	SymFind
PUBLIC	SymFindDeclare
PUBLIC	SymInit
PUBLIC	SymFini
PUBLIC	SymPassInit
PUBLIC	SymMakeAllSymbolsPublic
PUBLIC	SymGetAll
PUBLIC	SymEnum
PUBLIC	SymGetCount
PUBLIC	SymSetCmpFunc
PUBLIC	SymClearLocal
PUBLIC	SymSetLocal
PUBLIC	SymGetLocal
PUBLIC	SymSimd
EXTRN	_localtime64:PROC
EXTRN	_time64:PROC
EXTRN	__acrt_iob_func:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	_memicmp:PROC
EXTRN	strlen:PROC
EXTRN	strncmp:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	LclAlloc:PROC
EXTRN	DeleteGroup:PROC
EXTRN	AddPublicData:PROC
EXTRN	InternalError:PROC
EXTRN	ReleaseMacroData:PROC
EXTRN	DeleteType:PROC
EXTRN	DeleteProc:PROC
EXTRN	Options:BYTE
EXTRN	UseSavedState:BYTE
EXTRN	CurrProc:QWORD
EXTRN	__ImageBase:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	8

gsym_table DQ	01f49H DUP (?)
lsym_table DQ	07fH DUP (?)
gsym	DQ	01H DUP (?)
lsym	DQ	01H DUP (?)
SymCount DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$localtime DD imagerel localtime
	DD	imagerel localtime+24
	DD	imagerel $unwind$localtime
pdata	ENDS
pdata	SEGMENT
$pdata$time DD	imagerel time
	DD	imagerel time+24
	DD	imagerel $unwind$time
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$SymAlloc DD imagerel $LN6
	DD	imagerel $LN6+253
	DD	imagerel $unwind$SymAlloc
$pdata$SymFree DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$SymFree
$pdata$SymCreate DD imagerel $LN4
	DD	imagerel $LN4+97
	DD	imagerel $unwind$SymCreate
$pdata$SymLCreate DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$SymLCreate
$pdata$SymAddGlobal DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$SymAddGlobal
$pdata$SymAddLocal DD imagerel $LN4
	DD	imagerel $LN4+187
	DD	imagerel $unwind$SymAddLocal
$pdata$SymLookup DD imagerel $LN6
	DD	imagerel $LN6+193
	DD	imagerel $unwind$SymLookup
$pdata$SymLookupLocal DD imagerel $LN6
	DD	imagerel $LN6+315
	DD	imagerel $unwind$SymLookupLocal
$pdata$SymFind DD imagerel $LN12
	DD	imagerel $LN12+500
	DD	imagerel $unwind$SymFind
$pdata$SymFindDeclare DD imagerel $LN12
	DD	imagerel $LN12+467
	DD	imagerel $unwind$SymFindDeclare
$pdata$SymInit DD imagerel $LN11
	DD	imagerel $LN11+734
	DD	imagerel $unwind$SymInit
$pdata$SymFini DD imagerel $LN19
	DD	imagerel $LN19+312
	DD	imagerel $unwind$SymFini
$pdata$SymPassInit DD imagerel $LN12
	DD	imagerel $LN12+147
	DD	imagerel $unwind$SymPassInit
$pdata$SymMakeAllSymbolsPublic DD imagerel $LN10
	DD	imagerel $LN10+256
	DD	imagerel $unwind$SymMakeAllSymbolsPublic
$pdata$SymGetAll DD imagerel $LN9
	DD	imagerel $LN9+122
	DD	imagerel $unwind$SymGetAll
$pdata$SymSetCmpFunc DD imagerel $LN5
	DD	imagerel $LN5+58
	DD	imagerel $unwind$SymSetCmpFunc
$pdata$SymClearLocal DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$SymClearLocal
$pdata$SymSetLocal DD imagerel $LN6
	DD	imagerel $LN6+143
	DD	imagerel $unwind$SymSetLocal
$pdata$SymGetLocal DD imagerel $LN7
	DD	imagerel $LN7+127
	DD	imagerel $unwind$SymGetLocal
$pdata$hashpjw DD imagerel hashpjw
	DD	imagerel hashpjw+118
	DD	imagerel $unwind$hashpjw
$pdata$free_ext DD imagerel free_ext
	DD	imagerel free_ext+448
	DD	imagerel $unwind$free_ext
$pdata$DumpSymbols DD imagerel DumpSymbols
	DD	imagerel DumpSymbols+440
	DD	imagerel $unwind$DumpSymbols
$pdata$SymSimd DD imagerel $LN61
	DD	imagerel $LN61+2672
	DD	imagerel $unwind$SymSimd
$pdata$DumpSymbol DD imagerel DumpSymbol
	DD	imagerel DumpSymbol+864
	DD	imagerel $unwind$DumpSymbol
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
xdata	SEGMENT
$unwind$time DD	010901H
	DD	04209H
$unwind$SymAlloc DD 010901H
	DD	06209H
$unwind$SymFree DD 010901H
	DD	04209H
$unwind$SymCreate DD 010901H
	DD	06209H
$unwind$SymLCreate DD 010901H
	DD	06209H
$unwind$SymAddGlobal DD 010901H
	DD	04209H
$unwind$SymAddLocal DD 010e01H
	DD	0620eH
$unwind$SymLookup DD 010901H
	DD	06209H
$unwind$SymLookupLocal DD 010901H
	DD	06209H
$unwind$SymFind DD 010901H
	DD	08209H
$unwind$SymFindDeclare DD 010901H
	DD	08209H
$unwind$SymInit DD 010401H
	DD	0a204H
$unwind$SymFini DD 010401H
	DD	08204H
$unwind$SymPassInit DD 010801H
	DD	02208H
$unwind$SymMakeAllSymbolsPublic DD 010401H
	DD	06204H
$unwind$SymGetAll DD 010901H
	DD	02209H
$unwind$SymSetCmpFunc DD 010401H
	DD	02204H
$unwind$SymClearLocal DD 010401H
	DD	04204H
$unwind$SymSetLocal DD 010901H
	DD	06209H
$unwind$SymGetLocal DD 010901H
	DD	02209H
$unwind$hashpjw DD 010901H
	DD	02209H
$unwind$free_ext DD 010901H
	DD	06209H
$unwind$DumpSymbols DD 010401H
	DD	0c204H
$unwind$SymSimd DD 020c01H
	DD	013010cH
$unwind$DumpSymbol DD 010901H
	DD	0e209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$localtime DD 010901H
	DD	04209H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
tv133 = 64
tv67 = 68
tv151 = 72
type$ = 80
value$ = 88
dir$ = 96
sym$ = 128
DumpSymbol PROC

; 943  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 944  :     struct dsym *dir = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR dir$[rsp], rax

; 945  :     char        *type;
; 946  :     uint_64     value = sym->uvalue;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	QWORD PTR value$[rsp], rax

; 947  :     //const char  *langtype;
; 948  : 
; 949  :     switch( sym->state ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv67[rsp], eax
	cmp	DWORD PTR tv67[rsp], 10
	ja	$LN38@DumpSymbol
	movsxd	rax, DWORD PTR tv67[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN42@DumpSymbol[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN6@DumpSymbol:

; 950  :     case SYM_UNDEFINED:
; 951  :         type = "Undefined";

	lea	rax, OFFSET FLAT:$SG11458
	mov	QWORD PTR type$[rsp], rax

; 952  :         break;

	jmp	$LN2@DumpSymbol
$LN7@DumpSymbol:

; 953  :     case SYM_INTERNAL:
; 954  :         if ( sym->isproc )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@DumpSymbol

; 955  :             type = "Procedure";

	lea	rax, OFFSET FLAT:$SG11462
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN9@DumpSymbol
$LN8@DumpSymbol:

; 956  :         //else if ( sym->mem_type == MT_ABS )
; 957  :         else if ( sym->segment == NULL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN10@DumpSymbol

; 958  :             type = "Number";

	lea	rax, OFFSET FLAT:$SG11465
	mov	QWORD PTR type$[rsp], rax

; 959  :             value += ((uint_64)(uint_32)sym->value3264) << 32;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+56]
	shl	rax, 32					; 00000020H
	mov	rcx, QWORD PTR value$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR value$[rsp], rax
	jmp	SHORT $LN11@DumpSymbol
$LN10@DumpSymbol:

; 960  :         } else if ( sym->mem_type == MT_NEAR || sym->mem_type == MT_FAR )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 129			; 00000081H
	je	SHORT $LN14@DumpSymbol
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN12@DumpSymbol
$LN14@DumpSymbol:

; 961  :             type = "Code Label";

	lea	rax, OFFSET FLAT:$SG11469
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN13@DumpSymbol
$LN12@DumpSymbol:

; 962  :         else
; 963  :             type = "Data Label";

	lea	rax, OFFSET FLAT:$SG11470
	mov	QWORD PTR type$[rsp], rax
$LN13@DumpSymbol:
$LN11@DumpSymbol:
$LN9@DumpSymbol:

; 964  :         break;

	jmp	$LN2@DumpSymbol
$LN15@DumpSymbol:

; 965  :     case SYM_EXTERNAL:
; 966  :         if ( sym->isproc )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@DumpSymbol

; 967  :             type = "Proto";

	lea	rax, OFFSET FLAT:$SG11474
	mov	QWORD PTR type$[rsp], rax
	jmp	$LN17@DumpSymbol
$LN16@DumpSymbol:

; 968  :         else if ( sym->iscomm )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@DumpSymbol

; 969  :             type = "Communal";

	lea	rax, OFFSET FLAT:$SG11477
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN19@DumpSymbol
$LN18@DumpSymbol:

; 970  :         else if ( sym->mem_type == MT_EMPTY )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 192			; 000000c0H
	jne	SHORT $LN20@DumpSymbol

; 971  :             type = "Number (ext)";

	lea	rax, OFFSET FLAT:$SG11480
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN21@DumpSymbol
$LN20@DumpSymbol:

; 972  :         else if ( sym->mem_type == MT_NEAR || sym->mem_type == MT_FAR )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 129			; 00000081H
	je	SHORT $LN24@DumpSymbol
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN22@DumpSymbol
$LN24@DumpSymbol:

; 973  :             type = "Code (ext)";

	lea	rax, OFFSET FLAT:$SG11484
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN23@DumpSymbol
$LN22@DumpSymbol:

; 974  :         else
; 975  :             type = "Data (ext)";

	lea	rax, OFFSET FLAT:$SG11485
	mov	QWORD PTR type$[rsp], rax
$LN23@DumpSymbol:
$LN21@DumpSymbol:
$LN19@DumpSymbol:
$LN17@DumpSymbol:

; 976  :         break;

	jmp	$LN2@DumpSymbol
$LN25@DumpSymbol:

; 977  :     case SYM_SEG:
; 978  :         type = "Segment";

	lea	rax, OFFSET FLAT:$SG11487
	mov	QWORD PTR type$[rsp], rax

; 979  :         break;

	jmp	$LN2@DumpSymbol
$LN26@DumpSymbol:

; 980  :     case SYM_GRP:
; 981  :         type = "Group";

	lea	rax, OFFSET FLAT:$SG11489
	mov	QWORD PTR type$[rsp], rax

; 982  :         break;

	jmp	$LN2@DumpSymbol
$LN27@DumpSymbol:

; 983  :     case SYM_STACK: /* should never be found in global table */
; 984  :         type = "Stack Var";

	lea	rax, OFFSET FLAT:$SG11491
	mov	QWORD PTR type$[rsp], rax

; 985  :         break;

	jmp	$LN2@DumpSymbol
$LN28@DumpSymbol:

; 986  :     case SYM_STRUCT_FIELD: /* record bitfields are in global namespace! */
; 987  :         type = "Struct Field";

	lea	rax, OFFSET FLAT:$SG11493
	mov	QWORD PTR type$[rsp], rax

; 988  :         break;

	jmp	$LN2@DumpSymbol
$LN29@DumpSymbol:

; 989  :     case SYM_TYPE:
; 990  :         switch ( sym->typekind ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	mov	BYTE PTR tv133[rsp], al
	cmp	BYTE PTR tv133[rsp], 1
	je	SHORT $LN30@DumpSymbol
	cmp	BYTE PTR tv133[rsp], 2
	je	SHORT $LN31@DumpSymbol
	cmp	BYTE PTR tv133[rsp], 3
	je	SHORT $LN32@DumpSymbol
	cmp	BYTE PTR tv133[rsp], 4
	je	SHORT $LN33@DumpSymbol
	jmp	SHORT $LN34@DumpSymbol
$LN30@DumpSymbol:

; 991  :         case TYPE_STRUCT:  type = "Structure"; break;

	lea	rax, OFFSET FLAT:$SG11496
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN4@DumpSymbol
$LN31@DumpSymbol:

; 992  :         case TYPE_UNION:   type = "Union";     break;

	lea	rax, OFFSET FLAT:$SG11498
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN4@DumpSymbol
$LN32@DumpSymbol:

; 993  :         case TYPE_TYPEDEF: type = "Typedef";   break;

	lea	rax, OFFSET FLAT:$SG11500
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN4@DumpSymbol
$LN33@DumpSymbol:

; 994  :         case TYPE_RECORD:  type = "Record";    break;

	lea	rax, OFFSET FLAT:$SG11502
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN4@DumpSymbol
$LN34@DumpSymbol:

; 995  :         default:           type = "Undef Type";break;

	lea	rax, OFFSET FLAT:$SG11504
	mov	QWORD PTR type$[rsp], rax
$LN4@DumpSymbol:

; 996  :         }
; 997  :         break;

	jmp	SHORT $LN2@DumpSymbol
$LN35@DumpSymbol:

; 998  :     case SYM_ALIAS:
; 999  :         type = "Alias";

	lea	rax, OFFSET FLAT:$SG11506
	mov	QWORD PTR type$[rsp], rax

; 1000 :         break;

	jmp	SHORT $LN2@DumpSymbol
$LN36@DumpSymbol:

; 1001 :     case SYM_MACRO:
; 1002 :         type = "Macro";

	lea	rax, OFFSET FLAT:$SG11508
	mov	QWORD PTR type$[rsp], rax

; 1003 :         break;

	jmp	SHORT $LN2@DumpSymbol
$LN37@DumpSymbol:

; 1004 :     case SYM_TMACRO:
; 1005 :         type = "Text";

	lea	rax, OFFSET FLAT:$SG11510
	mov	QWORD PTR type$[rsp], rax

; 1006 :         break;

	jmp	SHORT $LN2@DumpSymbol
$LN38@DumpSymbol:

; 1007 :     //case SYM_CLASS_LNAME: /* never stored in global or local table */
; 1008 :     //    type = "CLASS";
; 1009 :     //    break;
; 1010 :     default:
; 1011 :         type = "Unknown";

	lea	rax, OFFSET FLAT:$SG11512
	mov	QWORD PTR type$[rsp], rax
$LN2@DumpSymbol:

; 1012 :         break;
; 1013 :     }
; 1014 :     printf( "%-12s  %16" I64_SPEC "X %02X %8p %c %8p %s\n", type, value, sym->mem_type, (void*)&(dir->e), sym->ispublic ? 'X' : ' ', (void*)sym->name, (char*)sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN40@DumpSymbol
	mov	DWORD PTR tv151[rsp], 88		; 00000058H
	jmp	SHORT $LN41@DumpSymbol
$LN40@DumpSymbol:
	mov	DWORD PTR tv151[rsp], 32		; 00000020H
$LN41@DumpSymbol:
	mov	rax, QWORD PTR dir$[rsp]
	add	rax, 96					; 00000060H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+56], rcx
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+48], rcx
	mov	ecx, DWORD PTR tv151[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+36]
	mov	r8, QWORD PTR value$[rsp]
	mov	rdx, QWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:$SG11513
	call	printf

; 1015 : }

	add	rsp, 120				; 00000078H
	ret	0
	npad	2
$LN42@DumpSymbol:
	DD	$LN6@DumpSymbol
	DD	$LN7@DumpSymbol
	DD	$LN15@DumpSymbol
	DD	$LN25@DumpSymbol
	DD	$LN26@DumpSymbol
	DD	$LN27@DumpSymbol
	DD	$LN28@DumpSymbol
	DD	$LN29@DumpSymbol
	DD	$LN35@DumpSymbol
	DD	$LN36@DumpSymbol
	DD	$LN37@DumpSymbol
DumpSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
pMember$ = 64
htype$ = 72
member1Valid$1 = 76
member2Valid$2 = 77
member3Valid$3 = 78
member4Valid$4 = 79
member1Valid$5 = 80
member2Valid$6 = 81
member3Valid$7 = 82
member1Valid$8 = 83
member2Valid$9 = 84
member1Valid$10 = 85
memberCount$ = 88
tv136 = 92
tv137 = 96
vtotal$ = 100
tv156 = 104
tv157 = 108
msize$ = 112
ctype$ = 116
c0$ = 120
c1$ = 124
tv443 = 128
sym$ = 160
SymSimd	PROC

; 769  : {

$LN61:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 770  :   struct sfield *pMember = sym->e.structinfo->head;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pMember$[rsp], rax

; 771  :   if (pMember == NULL && sym->sym.typekind != TYPE_UNION) return;

	cmp	QWORD PTR pMember$[rsp], 0
	jne	SHORT $LN4@SymSimd
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	je	SHORT $LN4@SymSimd
	jmp	$LN1@SymSimd
$LN4@SymSimd:

; 772  :   int memberCount = 0;

	mov	DWORD PTR memberCount$[rsp], 0

; 773  :   sym->e.structinfo->isHomogenous = 1;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rax+20], 1

; 774  : 
; 775  :   int vtotal = sym->sym.total_size;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR vtotal$[rsp], eax

; 776  :   int msize = pMember->sym.total_size;

	mov	rax, QWORD PTR pMember$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR msize$[rsp], eax

; 777  :   enum memtype ctype = pMember->sym.mem_type;

	mov	rax, QWORD PTR pMember$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR ctype$[rsp], eax

; 778  :   enum memtype htype = pMember->sym.mem_type;

	mov	rax, QWORD PTR pMember$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR htype$[rsp], eax
$LN2@SymSimd:

; 779  : 
; 780  :   while (pMember)

	cmp	QWORD PTR pMember$[rsp], 0
	je	SHORT $LN3@SymSimd

; 781  :   {
; 782  :     if (pMember->sym.total_size != msize && pMember->sym.mem_type != ctype && sym->e.structinfo->isHomogenous == 1)

	mov	rax, QWORD PTR pMember$[rsp]
	mov	ecx, DWORD PTR msize$[rsp]
	cmp	DWORD PTR [rax+56], ecx
	je	SHORT $LN5@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	ecx, DWORD PTR ctype$[rsp]
	cmp	DWORD PTR [rax+36], ecx
	je	SHORT $LN5@SymSimd
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+20]
	cmp	eax, 1
	jne	SHORT $LN5@SymSimd

; 783  :     {
; 784  :       sym->e.structinfo->isHomogenous = 0;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rax+20], 0
$LN5@SymSimd:

; 785  :     }
; 786  :     pMember = pMember->next;

	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR pMember$[rsp], rax

; 787  :     memberCount = memberCount + 1;

	mov	eax, DWORD PTR memberCount$[rsp]
	inc	eax
	mov	DWORD PTR memberCount$[rsp], eax

; 788  :   }

	jmp	SHORT $LN2@SymSimd
$LN3@SymSimd:

; 789  : 
; 790  : 
; 791  :   sym->e.structinfo->memberCount = memberCount;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR memberCount$[rsp]
	mov	DWORD PTR [rax+24], ecx

; 792  :   if (vtotal == 0x20 && sym->e.structinfo->isHomogenous == 1 && ((sym->sym.typekind == TYPE_UNION) || 

	cmp	DWORD PTR vtotal$[rsp], 32		; 00000020H
	jne	$LN6@SymSimd
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+20]
	cmp	eax, 1
	jne	$LN6@SymSimd
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	je	SHORT $LN8@SymSimd
	cmp	DWORD PTR htype$[rsp], 35		; 00000023H
	je	SHORT $LN9@SymSimd
	cmp	DWORD PTR htype$[rsp], 39		; 00000027H
	je	SHORT $LN9@SymSimd
	cmp	DWORD PTR htype$[rsp], 0
	je	SHORT $LN9@SymSimd
	cmp	DWORD PTR htype$[rsp], 1
	jne	SHORT $LN55@SymSimd
	mov	DWORD PTR tv137[rsp], 1
	jmp	SHORT $LN56@SymSimd
$LN55@SymSimd:
	mov	DWORD PTR tv137[rsp], 0
$LN56@SymSimd:
	cmp	DWORD PTR htype$[rsp], 3
	jne	SHORT $LN53@SymSimd
	mov	DWORD PTR tv136[rsp], 1
	jmp	SHORT $LN54@SymSimd
$LN53@SymSimd:
	mov	DWORD PTR tv136[rsp], 0
$LN54@SymSimd:
	mov	eax, DWORD PTR tv136[rsp]
	mov	ecx, DWORD PTR tv137[rsp]
	or	ecx, eax
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN9@SymSimd
	cmp	DWORD PTR htype$[rsp], 7
	jne	SHORT $LN6@SymSimd
$LN9@SymSimd:
$LN8@SymSimd:

; 793  :     (htype == MT_REAL4 || htype == MT_REAL8 || htype == MT_BYTE || htype == MT_WORD | htype == MT_DWORD || htype == MT_QWORD)))  
; 794  :     sym->e.structinfo->stype = MM256;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+16], 2
	jmp	$LN7@SymSimd
$LN6@SymSimd:

; 795  :   else if (vtotal == 0x10 && sym->e.structinfo->isHomogenous == 1 && ((sym->sym.typekind == TYPE_UNION) ||

	cmp	DWORD PTR vtotal$[rsp], 16
	jne	$LN10@SymSimd
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+20]
	cmp	eax, 1
	jne	$LN10@SymSimd
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	je	SHORT $LN11@SymSimd
	cmp	DWORD PTR htype$[rsp], 35		; 00000023H
	je	SHORT $LN12@SymSimd
	cmp	DWORD PTR htype$[rsp], 39		; 00000027H
	je	SHORT $LN12@SymSimd
	cmp	DWORD PTR htype$[rsp], 0
	je	SHORT $LN12@SymSimd
	cmp	DWORD PTR htype$[rsp], 1
	jne	SHORT $LN59@SymSimd
	mov	DWORD PTR tv157[rsp], 1
	jmp	SHORT $LN60@SymSimd
$LN59@SymSimd:
	mov	DWORD PTR tv157[rsp], 0
$LN60@SymSimd:
	cmp	DWORD PTR htype$[rsp], 3
	jne	SHORT $LN57@SymSimd
	mov	DWORD PTR tv156[rsp], 1
	jmp	SHORT $LN58@SymSimd
$LN57@SymSimd:
	mov	DWORD PTR tv156[rsp], 0
$LN58@SymSimd:
	mov	eax, DWORD PTR tv156[rsp]
	mov	ecx, DWORD PTR tv157[rsp]
	or	ecx, eax
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN12@SymSimd
	cmp	DWORD PTR htype$[rsp], 7
	jne	SHORT $LN10@SymSimd
$LN12@SymSimd:
$LN11@SymSimd:

; 796  :     (htype == MT_REAL4 || htype == MT_REAL8 || htype == MT_BYTE || htype == MT_WORD | htype == MT_DWORD || htype == MT_QWORD)))
; 797  :     sym->e.structinfo->stype = MM128;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+16], 1
$LN10@SymSimd:
$LN7@SymSimd:

; 798  : #if EVEXSUPP
; 799  :   else if (vtotal == 0x40 && sym->e.structinfo->isHomogenous == 1 && ((sym->sym.typekind == TYPE_UNION) ||
; 800  :     (htype == MT_REAL4 || htype == MT_REAL8 || htype == MT_BYTE || htype == MT_WORD | htype == MT_DWORD || htype == MT_QWORD)))
; 801  :     sym->e.structinfo->stype = MM512;
; 802  : #endif
; 803  : 
; 804  :   // Ensure unions of multiple MM128 or MM256 types default to a 4/8 member float arrangement.
; 805  :   if (sym->sym.typekind == TYPE_UNION && sym->e.structinfo->isHomogenous == 1)

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	jne	SHORT $LN13@SymSimd
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+20]
	cmp	eax, 1
	jne	SHORT $LN13@SymSimd

; 806  :   {
; 807  : 	  if (sym->e.structinfo->stype == MM128) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 1
	jne	SHORT $LN14@SymSimd

; 808  : 		  memberCount = 4;

	mov	DWORD PTR memberCount$[rsp], 4

; 809  : 		  sym->e.structinfo->memberCount = memberCount;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR memberCount$[rsp]
	mov	DWORD PTR [rax+24], ecx
$LN14@SymSimd:

; 810  : 	  }
; 811  : 	  if (sym->e.structinfo->stype == MM256) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 2
	jne	SHORT $LN15@SymSimd

; 812  : 		  memberCount = 8;

	mov	DWORD PTR memberCount$[rsp], 8

; 813  : 		  sym->e.structinfo->memberCount = memberCount;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR memberCount$[rsp]
	mov	DWORD PTR [rax+24], ecx
$LN15@SymSimd:
$LN13@SymSimd:

; 814  : 	  }
; 815  :   }
; 816  : 
; 817  :        sym->e.structinfo->isHFA = 0;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rax+22], 0

; 818  :        if ((memberCount >= 1 && memberCount <= 4) && (htype == MT_REAL4 || htype == MT_REAL8) && sym->e.structinfo->isHomogenous == 1)

	cmp	DWORD PTR memberCount$[rsp], 1
	jl	SHORT $LN16@SymSimd
	cmp	DWORD PTR memberCount$[rsp], 4
	jg	SHORT $LN16@SymSimd
	cmp	DWORD PTR htype$[rsp], 35		; 00000023H
	je	SHORT $LN17@SymSimd
	cmp	DWORD PTR htype$[rsp], 39		; 00000027H
	jne	SHORT $LN16@SymSimd
$LN17@SymSimd:
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+20]
	cmp	eax, 1
	jne	SHORT $LN16@SymSimd

; 819  :        {
; 820  :               sym->e.structinfo->isHFA = 1;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rax+22], 1

; 821  : 			  sym->e.structinfo->stype = NOVEC;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+16], 0
$LN16@SymSimd:

; 822  :        }
; 823  : 
; 824  : 	   // Due to vectorcall convention, __m128 which is technically also an HFA (4 floats) must be marked as nonHFA.
; 825  : 	   // And consequently any structure with name __m128/__m256/__m512 must be marked as non-HFA. (This is a bit ugly, but it's the only way to ensure the types are correctly handled by invoke/proc).
; 826  : 
; 827  : 	   int c0 = strncmp(sym->sym.name, "__m128", 6);

	mov	r8d, 6
	lea	rdx, OFFSET FLAT:$SG11402
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	strncmp
	mov	DWORD PTR c0$[rsp], eax

; 828  : 	   int c1 = strncmp(sym->sym.name, "__m256", 6);

	mov	r8d, 6
	lea	rdx, OFFSET FLAT:$SG11403
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	strncmp
	mov	DWORD PTR c1$[rsp], eax

; 829  : #if EVEXSUPP
; 830  : 	   int c2 = strncmp(sym->sym.name, "__m512", 6);
; 831  : #endif
; 832  : 	   if (c0 == 0)

	cmp	DWORD PTR c0$[rsp], 0
	jne	SHORT $LN18@SymSimd

; 833  : 	   {
; 834  : 		   sym->e.structinfo->isHFA = 0;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rax+22], 0

; 835  : 		   sym->e.structinfo->stype = MM128;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+16], 1

; 836  : 	   }

	jmp	SHORT $LN19@SymSimd
$LN18@SymSimd:

; 837  : 	   else if (c1 == 0)

	cmp	DWORD PTR c1$[rsp], 0
	jne	SHORT $LN20@SymSimd

; 838  : 	   {
; 839  : 		   sym->e.structinfo->isHFA = 0;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rax+22], 0

; 840  : 		   sym->e.structinfo->stype = MM256;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+16], 2
$LN20@SymSimd:
$LN19@SymSimd:

; 841  : 	   }
; 842  : #if EVEXSUPP
; 843  : 	   else if (c2 == 0)
; 844  : 	   {
; 845  : 		   sym->e.structinfo->isHFA = 0;
; 846  : 		   sym->e.structinfo->stype = MM512;
; 847  : 	   }
; 848  : #endif
; 849  : 
; 850  : 	   sym->e.structinfo->isHVA = 0;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rax+21], 0

; 851  : 	   if (memberCount == 4 && sym->e.structinfo->isHomogenous == 1 && htype == MT_TYPE && sym->sym.typekind != TYPE_UNION)

	cmp	DWORD PTR memberCount$[rsp], 4
	jne	$LN21@SymSimd
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+20]
	cmp	eax, 1
	jne	$LN21@SymSimd
	cmp	DWORD PTR htype$[rsp], 196		; 000000c4H
	jne	$LN21@SymSimd
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	je	$LN21@SymSimd

; 852  : 	   {
; 853  : 		   pMember = sym->e.structinfo->head;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pMember$[rsp], rax

; 854  : 		   uint_8 member1Valid = 0;

	mov	BYTE PTR member1Valid$1[rsp], 0

; 855  : 		   uint_8 member2Valid = 0;

	mov	BYTE PTR member2Valid$2[rsp], 0

; 856  : 		   uint_8 member3Valid = 0;

	mov	BYTE PTR member3Valid$3[rsp], 0

; 857  : 		   uint_8 member4Valid = 0;

	mov	BYTE PTR member4Valid$4[rsp], 0

; 858  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member1Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN23@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 1
	jne	SHORT $LN23@SymSimd
	mov	BYTE PTR member1Valid$1[rsp], 1
$LN23@SymSimd:

; 859  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR pMember$[rsp], rax

; 860  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member2Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN24@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 1
	jne	SHORT $LN24@SymSimd
	mov	BYTE PTR member2Valid$2[rsp], 1
$LN24@SymSimd:

; 861  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR pMember$[rsp], rax

; 862  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member3Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN25@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 1
	jne	SHORT $LN25@SymSimd
	mov	BYTE PTR member3Valid$3[rsp], 1
$LN25@SymSimd:

; 863  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR pMember$[rsp], rax

; 864  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member4Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN26@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 1
	jne	SHORT $LN26@SymSimd
	mov	BYTE PTR member4Valid$4[rsp], 1
$LN26@SymSimd:

; 865  : 
; 866  : 		   pMember = sym->e.structinfo->head;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pMember$[rsp], rax

; 867  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member1Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN27@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 2
	jne	SHORT $LN27@SymSimd
	mov	BYTE PTR member1Valid$1[rsp], 1
$LN27@SymSimd:

; 868  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR pMember$[rsp], rax

; 869  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member2Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN28@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 2
	jne	SHORT $LN28@SymSimd
	mov	BYTE PTR member2Valid$2[rsp], 1
$LN28@SymSimd:

; 870  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR pMember$[rsp], rax

; 871  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member3Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN29@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 2
	jne	SHORT $LN29@SymSimd
	mov	BYTE PTR member3Valid$3[rsp], 1
$LN29@SymSimd:

; 872  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR pMember$[rsp], rax

; 873  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member4Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN30@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 2
	jne	SHORT $LN30@SymSimd
	mov	BYTE PTR member4Valid$4[rsp], 1
$LN30@SymSimd:

; 874  : 
; 875  : 		   if (member1Valid == 1 && member2Valid == 1 && member3Valid == 1 && member4Valid == 1)

	movzx	eax, BYTE PTR member1Valid$1[rsp]
	cmp	eax, 1
	jne	SHORT $LN31@SymSimd
	movzx	eax, BYTE PTR member2Valid$2[rsp]
	cmp	eax, 1
	jne	SHORT $LN31@SymSimd
	movzx	eax, BYTE PTR member3Valid$3[rsp]
	cmp	eax, 1
	jne	SHORT $LN31@SymSimd
	movzx	eax, BYTE PTR member4Valid$4[rsp]
	cmp	eax, 1
	jne	SHORT $LN31@SymSimd

; 876  : 		   {
; 877  : 			   sym->e.structinfo->isHVA = 1;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rax+21], 1
$LN31@SymSimd:

; 878  : 		   }
; 879  : 	   }

	jmp	$LN22@SymSimd
$LN21@SymSimd:

; 880  : 	   else if (memberCount == 3 && sym->e.structinfo->isHomogenous == 1 && htype == MT_TYPE && sym->sym.typekind != TYPE_UNION)

	cmp	DWORD PTR memberCount$[rsp], 3
	jne	$LN32@SymSimd
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+20]
	cmp	eax, 1
	jne	$LN32@SymSimd
	cmp	DWORD PTR htype$[rsp], 196		; 000000c4H
	jne	$LN32@SymSimd
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	je	$LN32@SymSimd

; 881  : 	   {
; 882  : 		   pMember = sym->e.structinfo->head;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pMember$[rsp], rax

; 883  : 		   uint_8 member1Valid = 0;

	mov	BYTE PTR member1Valid$5[rsp], 0

; 884  : 		   uint_8 member2Valid = 0;

	mov	BYTE PTR member2Valid$6[rsp], 0

; 885  : 		   uint_8 member3Valid = 0;

	mov	BYTE PTR member3Valid$7[rsp], 0

; 886  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member1Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN34@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 1
	jne	SHORT $LN34@SymSimd
	mov	BYTE PTR member1Valid$5[rsp], 1
$LN34@SymSimd:

; 887  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR pMember$[rsp], rax

; 888  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member2Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN35@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 1
	jne	SHORT $LN35@SymSimd
	mov	BYTE PTR member2Valid$6[rsp], 1
$LN35@SymSimd:

; 889  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR pMember$[rsp], rax

; 890  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member3Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN36@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 1
	jne	SHORT $LN36@SymSimd
	mov	BYTE PTR member3Valid$7[rsp], 1
$LN36@SymSimd:

; 891  : 
; 892  : 		   pMember = sym->e.structinfo->head;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pMember$[rsp], rax

; 893  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member1Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN37@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 2
	jne	SHORT $LN37@SymSimd
	mov	BYTE PTR member1Valid$5[rsp], 1
$LN37@SymSimd:

; 894  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR pMember$[rsp], rax

; 895  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member2Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN38@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 2
	jne	SHORT $LN38@SymSimd
	mov	BYTE PTR member2Valid$6[rsp], 1
$LN38@SymSimd:

; 896  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR pMember$[rsp], rax

; 897  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member3Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN39@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 2
	jne	SHORT $LN39@SymSimd
	mov	BYTE PTR member3Valid$7[rsp], 1
$LN39@SymSimd:

; 898  : 
; 899  : 		   if (member1Valid == 1 && member2Valid == 1 && member3Valid == 1)

	movzx	eax, BYTE PTR member1Valid$5[rsp]
	cmp	eax, 1
	jne	SHORT $LN40@SymSimd
	movzx	eax, BYTE PTR member2Valid$6[rsp]
	cmp	eax, 1
	jne	SHORT $LN40@SymSimd
	movzx	eax, BYTE PTR member3Valid$7[rsp]
	cmp	eax, 1
	jne	SHORT $LN40@SymSimd

; 900  : 		   {
; 901  : 			   sym->e.structinfo->isHVA = 1;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rax+21], 1
$LN40@SymSimd:

; 902  : 		   }
; 903  : 	   }

	jmp	$LN33@SymSimd
$LN32@SymSimd:

; 904  : 	   else if (memberCount == 2 && sym->e.structinfo->isHomogenous == 1 && htype == MT_TYPE && sym->sym.typekind != TYPE_UNION)

	cmp	DWORD PTR memberCount$[rsp], 2
	jne	$LN41@SymSimd
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+20]
	cmp	eax, 1
	jne	$LN41@SymSimd
	cmp	DWORD PTR htype$[rsp], 196		; 000000c4H
	jne	$LN41@SymSimd
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	je	$LN41@SymSimd

; 905  : 	   {
; 906  : 		   pMember = sym->e.structinfo->head;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pMember$[rsp], rax

; 907  : 		   uint_8 member1Valid = 0;

	mov	BYTE PTR member1Valid$8[rsp], 0

; 908  : 		   uint_8 member2Valid = 0;

	mov	BYTE PTR member2Valid$9[rsp], 0

; 909  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member1Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN43@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 1
	jne	SHORT $LN43@SymSimd
	mov	BYTE PTR member1Valid$8[rsp], 1
$LN43@SymSimd:

; 910  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR pMember$[rsp], rax

; 911  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member2Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN44@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 1
	jne	SHORT $LN44@SymSimd
	mov	BYTE PTR member2Valid$9[rsp], 1
$LN44@SymSimd:

; 912  : 
; 913  : 		   pMember = sym->e.structinfo->head;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pMember$[rsp], rax

; 914  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member1Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN45@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 2
	jne	SHORT $LN45@SymSimd
	mov	BYTE PTR member1Valid$8[rsp], 1
$LN45@SymSimd:

; 915  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR pMember$[rsp], rax

; 916  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member2Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN46@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 2
	jne	SHORT $LN46@SymSimd
	mov	BYTE PTR member2Valid$9[rsp], 1
$LN46@SymSimd:

; 917  : 
; 918  : 		   if (member1Valid == 1 && member2Valid == 1)

	movzx	eax, BYTE PTR member1Valid$8[rsp]
	cmp	eax, 1
	jne	SHORT $LN47@SymSimd
	movzx	eax, BYTE PTR member2Valid$9[rsp]
	cmp	eax, 1
	jne	SHORT $LN47@SymSimd

; 919  : 		   {
; 920  : 			   sym->e.structinfo->isHVA = 1;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rax+21], 1
$LN47@SymSimd:

; 921  : 		   }
; 922  : 	   }

	jmp	$LN42@SymSimd
$LN41@SymSimd:

; 923  : 	   else if (memberCount == 1 && sym->e.structinfo->isHomogenous == 1 && htype == MT_TYPE && sym->sym.typekind != TYPE_UNION)

	cmp	DWORD PTR memberCount$[rsp], 1
	jne	$LN48@SymSimd
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+20]
	cmp	eax, 1
	jne	$LN48@SymSimd
	cmp	DWORD PTR htype$[rsp], 196		; 000000c4H
	jne	$LN48@SymSimd
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	je	SHORT $LN48@SymSimd

; 924  : 	   {
; 925  : 		   pMember = sym->e.structinfo->head;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pMember$[rsp], rax

; 926  : 		   uint_8 member1Valid = 0;

	mov	BYTE PTR member1Valid$10[rsp], 0

; 927  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member1Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN49@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 1
	jne	SHORT $LN49@SymSimd
	mov	BYTE PTR member1Valid$10[rsp], 1
$LN49@SymSimd:

; 928  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member1Valid = 1;

	mov	rax, QWORD PTR pMember$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN50@SymSimd
	mov	rax, QWORD PTR pMember$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+16], 2
	jne	SHORT $LN50@SymSimd
	mov	BYTE PTR member1Valid$10[rsp], 1
$LN50@SymSimd:

; 929  : 		   if (member1Valid == 1)

	movzx	eax, BYTE PTR member1Valid$10[rsp]
	cmp	eax, 1
	jne	SHORT $LN51@SymSimd

; 930  : 		   {
; 931  : 			   sym->e.structinfo->isHVA = 1;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rax+21], 1
$LN51@SymSimd:
$LN48@SymSimd:
$LN42@SymSimd:
$LN33@SymSimd:
$LN22@SymSimd:

; 932  : 		   }
; 933  : 	   }
; 934  : 		#ifdef DEBUG_OUT	   
; 935  : 			printf("Symbol VectorCall Settings: %s isHomogenous:%u isHFA:%u isHVA:%u MMType:%u memberCount:%u\n", sym->sym.name, sym->e.structinfo->isHomogenous, sym->e.structinfo->isHFA, sym->e.structinfo->isHVA, sym->e.structinfo->stype, sym->e.structinfo->memberCount);

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rdx+96]
	movzx	edx, BYTE PTR [rdx+21]
	mov	r8, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [r8+96]
	movzx	r8d, BYTE PTR [r8+22]
	mov	r9, QWORD PTR sym$[rsp]
	mov	r9, QWORD PTR [r9+96]
	movzx	r9d, BYTE PTR [r9+20]
	mov	DWORD PTR tv443[rsp], r9d
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR [rcx+16]
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], edx
	mov	r9d, r8d
	mov	eax, DWORD PTR tv443[rsp]
	mov	r8d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11438
	call	printf
$LN1@SymSimd:

; 936  : 		#endif
; 937  : 
; 938  : }

	add	rsp, 152				; 00000098H
	ret	0
SymSimd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
curr$ = 48
i$ = 52
count$ = 56
num10$ = 60
num5$ = 64
num1$ = 68
num0$ = 72
max$ = 76
sym$ = 80
DumpSymbols PROC

; 1019 : {

	sub	rsp, 104				; 00000068H

; 1020 :     struct asym         *sym;
; 1021 :     unsigned            i;
; 1022 :     unsigned            count = 0;

	mov	DWORD PTR count$[rsp], 0

; 1023 :     unsigned            max = 0;

	mov	DWORD PTR max$[rsp], 0

; 1024 :     unsigned            num0 = 0;

	mov	DWORD PTR num0$[rsp], 0

; 1025 :     unsigned            num1 = 0;

	mov	DWORD PTR num1$[rsp], 0

; 1026 :     unsigned            num5 = 0;

	mov	DWORD PTR num5$[rsp], 0

; 1027 :     unsigned            num10 = 0;

	mov	DWORD PTR num10$[rsp], 0

; 1028 :     unsigned            curr = 0;

	mov	DWORD PTR curr$[rsp], 0

; 1029 : 
; 1030 :     DebugMsg(("DumpSymbols enter\n"));

	lea	rcx, OFFSET FLAT:$SG11531
	call	DoDebugMsg

; 1031 :     if ( Options.dump_symbols ) {

	movzx	eax, BYTE PTR Options+26
	test	eax, eax
	je	SHORT $LN8@DumpSymbol

; 1032 :         printf( "   # Addr     Type                     Value MT    Ext   P  pName   Name\n" );

	lea	rcx, OFFSET FLAT:$SG11533
	call	printf

; 1033 :         printf( "--------------------------------------------------------------------------------\n" );

	lea	rcx, OFFSET FLAT:$SG11534
	call	printf
$LN8@DumpSymbol:

; 1034 :     }
; 1035 :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@DumpSymbol
$LN2@DumpSymbol:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@DumpSymbol:
	cmp	DWORD PTR i$[rsp], 8009			; 00001f49H
	jae	$LN3@DumpSymbol

; 1036 :         for( sym = gsym_table[i], curr = 0; sym; sym = sym->nextitem ) {

	mov	eax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:gsym_table
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR sym$[rsp], rax
	mov	DWORD PTR curr$[rsp], 0
	jmp	SHORT $LN7@DumpSymbol
$LN5@DumpSymbol:
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sym$[rsp], rax
$LN7@DumpSymbol:
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN6@DumpSymbol

; 1037 :             curr++;

	mov	eax, DWORD PTR curr$[rsp]
	inc	eax
	mov	DWORD PTR curr$[rsp], eax

; 1038 :             if ( Options.dump_symbols ) {

	movzx	eax, BYTE PTR Options+26
	test	eax, eax
	je	SHORT $LN9@DumpSymbol

; 1039 :                 printf("%4u %8p ", i, sym );

	mov	r8, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11536
	call	printf

; 1040 :                 DumpSymbol( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	DumpSymbol
$LN9@DumpSymbol:

; 1041 :             }
; 1042 :         }

	jmp	SHORT $LN5@DumpSymbol
$LN6@DumpSymbol:

; 1043 :         count += curr;

	mov	eax, DWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR count$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR count$[rsp], eax

; 1044 :         if ( curr == 0 )

	cmp	DWORD PTR curr$[rsp], 0
	jne	SHORT $LN10@DumpSymbol

; 1045 :             num0++;

	mov	eax, DWORD PTR num0$[rsp]
	inc	eax
	mov	DWORD PTR num0$[rsp], eax
	jmp	SHORT $LN11@DumpSymbol
$LN10@DumpSymbol:

; 1046 :         else if ( curr == 1 )

	cmp	DWORD PTR curr$[rsp], 1
	jne	SHORT $LN12@DumpSymbol

; 1047 :             num1++;

	mov	eax, DWORD PTR num1$[rsp]
	inc	eax
	mov	DWORD PTR num1$[rsp], eax
	jmp	SHORT $LN13@DumpSymbol
$LN12@DumpSymbol:

; 1048 :         else if ( curr <= 5 )

	cmp	DWORD PTR curr$[rsp], 5
	ja	SHORT $LN14@DumpSymbol

; 1049 :             num5++;

	mov	eax, DWORD PTR num5$[rsp]
	inc	eax
	mov	DWORD PTR num5$[rsp], eax
	jmp	SHORT $LN15@DumpSymbol
$LN14@DumpSymbol:

; 1050 :         else if ( curr <= 10 )

	cmp	DWORD PTR curr$[rsp], 10
	ja	SHORT $LN16@DumpSymbol

; 1051 :             num10++;

	mov	eax, DWORD PTR num10$[rsp]
	inc	eax
	mov	DWORD PTR num10$[rsp], eax
$LN16@DumpSymbol:
$LN15@DumpSymbol:
$LN13@DumpSymbol:
$LN11@DumpSymbol:

; 1052 :         if ( max < curr )

	mov	eax, DWORD PTR curr$[rsp]
	cmp	DWORD PTR max$[rsp], eax
	jae	SHORT $LN17@DumpSymbol

; 1053 :             max = curr;

	mov	eax, DWORD PTR curr$[rsp]
	mov	DWORD PTR max$[rsp], eax
$LN17@DumpSymbol:

; 1054 :     }

	jmp	$LN2@DumpSymbol
$LN3@DumpSymbol:

; 1055 :     if ( Options.quiet == FALSE ) {

	movzx	eax, BYTE PTR Options
	test	eax, eax
	jne	SHORT $LN18@DumpSymbol

; 1056 :         printf( "%u items in symbol table, expected %u\n", count, SymCount );

	mov	r8d, DWORD PTR SymCount
	mov	edx, DWORD PTR count$[rsp]
	lea	rcx, OFFSET FLAT:$SG11546
	call	printf

; 1057 :         printf( "max items in a line=%u, lines with 0/1/<=5/<=10 items=%u/%u/%u/%u, \n", max, num0, num1, num5, num10 );

	mov	eax, DWORD PTR num10$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR num5$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR num1$[rsp]
	mov	r8d, DWORD PTR num0$[rsp]
	mov	edx, DWORD PTR max$[rsp]
	lea	rcx, OFFSET FLAT:$SG11547
	call	printf
$LN18@DumpSymbol:

; 1058 :     }
; 1059 : }

	add	rsp, 104				; 00000068H
	ret	0
DumpSymbols ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
tv71 = 32
sym$ = 64
free_ext PROC

; 396  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 397  :     DebugMsg(("free_ext: item=%p name=%s state=%u\n", sym, sym->name, sym->state ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+32]
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR sym$[rsp]
	lea	rcx, OFFSET FLAT:$SG11199
	call	DoDebugMsg

; 398  :     switch( sym->state ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv71[rsp], eax
	mov	eax, DWORD PTR tv71[rsp]
	dec	eax
	mov	DWORD PTR tv71[rsp], eax
	cmp	DWORD PTR tv71[rsp], 9
	ja	$LN2@free_ext
	movsxd	rax, DWORD PTR tv71[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN19@free_ext[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@free_ext:

; 399  :     case SYM_INTERNAL:
; 400  :         if ( sym->isproc )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@free_ext

; 401  :             DeleteProc( (struct dsym *)sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	DeleteProc
$LN5@free_ext:

; 402  :         break;

	jmp	$LN2@free_ext
$LN6@free_ext:

; 403  :     case SYM_EXTERNAL:
; 404  :         if ( sym->isproc )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@free_ext

; 405  :             DeleteProc( (struct dsym *)sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	DeleteProc
$LN7@free_ext:

; 406  :         sym->first_size = 0;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+44], 0

; 407  :         /* The altname field may contain a symbol (if weak == FALSE).
; 408  :          * However, this is an independant item and must not be released here
; 409  :          */
; 410  : #ifdef DEBUG_OUT /* to be removed, this can't happen anymore. */
; 411  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN8@free_ext
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN8@free_ext

; 412  :             DebugMsg(( "free_ext: external with private type: %s\n", sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11205
	call	DoDebugMsg

; 413  :             SymFree( sym->type );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	SymFree
$LN8@free_ext:

; 414  :         }
; 415  : #endif
; 416  :         break;

	jmp	$LN2@free_ext
$LN9@free_ext:

; 417  :     case SYM_SEG:
; 418  :         if ( ((struct dsym *)sym)->e.seginfo->internal )

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	shr	al, 4
	and	al, 1
	movzx	eax, al

; 419  :             LclFree( ((struct dsym *)sym)->e.seginfo->CodeBuffer );
; 420  :         LclFree( ((struct dsym *)sym)->e.seginfo );
; 421  :         break;

	jmp	SHORT $LN2@free_ext
$LN11@free_ext:

; 422  :     case SYM_GRP:
; 423  :         DeleteGroup( (struct dsym *)sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	DeleteGroup

; 424  :         break;

	jmp	SHORT $LN2@free_ext
$LN12@free_ext:

; 425  :     case SYM_TYPE:
; 426  :         DeleteType( (struct dsym *)sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	DeleteType

; 427  :         break;

	jmp	SHORT $LN2@free_ext
$LN13@free_ext:

; 428  :     case SYM_MACRO:
; 429  :         ReleaseMacroData( (struct dsym *)sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	ReleaseMacroData

; 430  :         LclFree( ((struct dsym *)sym)->e.macroinfo );
; 431  :         break;

	jmp	SHORT $LN2@free_ext
$LN14@free_ext:

; 432  :     case SYM_TMACRO:
; 433  :         if ( sym->predefined == FALSE )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al

; 434  :             LclFree( sym->string_ptr );
; 435  :         break;

	jmp	SHORT $LN2@free_ext
$LN16@free_ext:

; 436  : #ifdef DEBUG_OUT 
; 437  :     case SYM_STACK:
; 438  :         /* to be removed, this can't happen anymore. */
; 439  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) { 

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN17@free_ext
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN17@free_ext

; 440  :             DebugMsg(( "free_ext: case SYM_STACK, sym=%s with private type\n", sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11215
	call	DoDebugMsg

; 441  :             /* symbol has a "private" type */
; 442  :             SymFree( sym->type );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	SymFree
$LN17@free_ext:
$LN2@free_ext:

; 443  :         }
; 444  :         break;
; 445  : #endif
; 446  :     }
; 447  : }

	add	rsp, 56					; 00000038H
	ret	0
	npad	2
$LN19@free_ext:
	DD	$LN4@free_ext
	DD	$LN6@free_ext
	DD	$LN9@free_ext
	DD	$LN11@free_ext
	DD	$LN16@free_ext
	DD	$LN2@free_ext
	DD	$LN12@free_ext
	DD	$LN2@free_ext
	DD	$LN13@free_ext
	DD	$LN14@free_ext
free_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
h$ = 0
g$ = 4
s$ = 32
hashpjw	PROC

; 149  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 150  :     unsigned h;
; 151  :     unsigned g;
; 152  : 
; 153  : #if HASH_MAGNITUDE==12
; 154  :     for( h = 0; *s; ++s ) {
; 155  :         h = (h << 4) + (*s | ' ');
; 156  :         g = h & ~0x0fff;
; 157  :         h ^= g;
; 158  :         h ^= g >> 12;
; 159  :     }
; 160  : #else
; 161  :     for( h = 0; *s; ++s ) {

	mov	DWORD PTR h$[rsp], 0
	jmp	SHORT $LN4@hashpjw
$LN2@hashpjw:
	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR s$[rsp], rax
$LN4@hashpjw:
	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@hashpjw

; 162  :         h = (h << 5) + (*s | ' ');

	mov	eax, DWORD PTR h$[rsp]
	shl	eax, 5
	mov	rcx, QWORD PTR s$[rsp]
	movsx	ecx, BYTE PTR [rcx]
	or	ecx, 32					; 00000020H
	add	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 163  :         g = h & ~0x7fff;

	mov	eax, DWORD PTR h$[rsp]
	and	eax, -32768				; ffff8000H
	mov	DWORD PTR g$[rsp], eax

; 164  :         h ^= g;

	mov	eax, DWORD PTR g$[rsp]
	mov	ecx, DWORD PTR h$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 165  :         h ^= g >> 15;

	mov	eax, DWORD PTR g$[rsp]
	shr	eax, 15
	mov	ecx, DWORD PTR h$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 166  :     }

	jmp	SHORT $LN2@hashpjw
$LN3@hashpjw:

; 167  : #endif
; 168  :     return( h );

	mov	eax, DWORD PTR h$[rsp]

; 169  : }

	add	rsp, 24
	ret	0
hashpjw	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
i$ = 0
l$ = 8
proc$ = 32
SymGetLocal PROC

; 191  : {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 192  :     int i;
; 193  :     struct dsym  **l = &((struct dsym *)proc)->e.procinfo->labellist;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	add	rax, 24
	mov	QWORD PTR l$[rsp], rax

; 194  : 
; 195  :     for ( i = 0; i < LHASH_TABLE_SIZE; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@SymGetLoca
$LN2@SymGetLoca:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SymGetLoca:
	cmp	DWORD PTR i$[rsp], 127			; 0000007fH
	jge	SHORT $LN3@SymGetLoca

; 196  :         if ( lsym_table[i] ) {

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:lsym_table
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN5@SymGetLoca

; 197  :             *l = (struct dsym *)lsym_table[i];

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:lsym_table
	mov	rdx, QWORD PTR l$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR [rdx], rax

; 198  :             l = &(*l)->e.nextll;

	mov	rax, QWORD PTR l$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 96					; 00000060H
	mov	QWORD PTR l$[rsp], rax
$LN5@SymGetLoca:

; 199  :         }
; 200  :     }

	jmp	SHORT $LN2@SymGetLoca
$LN3@SymGetLoca:

; 201  :     *l = NULL;

	mov	rax, QWORD PTR l$[rsp]
	mov	QWORD PTR [rax], 0

; 202  : 
; 203  :     return;
; 204  : }

	add	rsp, 24
	ret	0
SymGetLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
i$ = 32
l$ = 40
proc$ = 64
SymSetLocal PROC

; 214  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 215  :     int i;
; 216  :     struct dsym *l;
; 217  : 
; 218  :     SymClearLocal();

	call	SymClearLocal

; 219  :     for ( l = ((struct dsym *)proc)->e.procinfo->labellist; l; l = l->e.nextll ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR l$[rsp], rax
	jmp	SHORT $LN4@SymSetLoca
$LN2@SymSetLoca:
	mov	rax, QWORD PTR l$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR l$[rsp], rax
$LN4@SymSetLoca:
	cmp	QWORD PTR l$[rsp], 0
	je	SHORT $LN3@SymSetLoca

; 220  :         DebugMsg1(("SymSetLocal(%s): label=%s\n", proc->name, l->sym.name ));

	mov	rax, QWORD PTR l$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11120
	call	DoDebugMsg1

; 221  :         i = hashpjw( l->sym.name ) % LHASH_TABLE_SIZE;

	mov	rax, QWORD PTR l$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	hashpjw
	xor	edx, edx
	mov	ecx, 127				; 0000007fH
	div	ecx
	mov	eax, edx
	mov	DWORD PTR i$[rsp], eax

; 222  :         lsym_table[i] = &l->sym;

	mov	rax, QWORD PTR l$[rsp]
	movsxd	rcx, DWORD PTR i$[rsp]
	lea	rdx, OFFSET FLAT:lsym_table
	mov	QWORD PTR [rdx+rcx*8], rax

; 223  :     }

	jmp	SHORT $LN2@SymSetLoca
$LN3@SymSetLoca:

; 224  :     return;
; 225  : }

	add	rsp, 56					; 00000038H
	ret	0
SymSetLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
SymClearLocal PROC

; 182  : {

$LN3:
	sub	rsp, 40					; 00000028H

; 183  :     memset( &lsym_table, 0, sizeof( lsym_table ) );

	mov	r8d, 1016				; 000003f8H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:lsym_table
	call	memset

; 184  :     return;
; 185  : }

	add	rsp, 40					; 00000028H
	ret	0
SymClearLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
tv66 = 0
SymSetCmpFunc PROC

; 173  : {

$LN5:
	sub	rsp, 24

; 174  :     SymCmpFunc = ( ModuleInfo.case_sensitive == TRUE ? memcmp : (StrCmpFunc)_memicmp );

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN3@SymSetCmpF
	lea	rax, OFFSET FLAT:memcmp
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN4@SymSetCmpF
$LN3@SymSetCmpF:
	lea	rax, OFFSET FLAT:_memicmp
	mov	QWORD PTR tv66[rsp], rax
$LN4@SymSetCmpF:
	mov	rax, QWORD PTR tv66[rsp]
	mov	QWORD PTR SymCmpFunc, rax

; 175  :     return;
; 176  : }

	add	rsp, 24
	ret	0
SymSetCmpFunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
SymGetCount PROC

; 726  :     return( SymCount );

	mov	eax, DWORD PTR SymCount

; 727  : }

	ret	0
SymGetCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 8
pi$ = 16
SymEnum	PROC

; 752  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 753  :     if ( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN4@SymEnum

; 754  :         *pi = 0;

	mov	rax, QWORD PTR pi$[rsp]
	mov	DWORD PTR [rax], 0

; 755  :         sym = gsym_table[*pi];

	mov	rax, QWORD PTR pi$[rsp]
	movsxd	rax, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:gsym_table
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR sym$[rsp], rax

; 756  :     } else {

	jmp	SHORT $LN5@SymEnum
$LN4@SymEnum:

; 757  :         sym = sym->nextitem;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sym$[rsp], rax
$LN5@SymEnum:
$LN2@SymEnum:

; 758  :     }
; 759  : 
; 760  :     /* v2.10: changed from for() to while() */
; 761  :     while( sym == NULL && *pi < GHASH_TABLE_SIZE - 1 )

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN3@SymEnum
	mov	rax, QWORD PTR pi$[rsp]
	cmp	DWORD PTR [rax], 8008			; 00001f48H
	jge	SHORT $LN3@SymEnum

; 762  :         sym = gsym_table[++(*pi)];

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR pi$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR pi$[rsp]
	movsxd	rax, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:gsym_table
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR sym$[rsp], rax
	jmp	SHORT $LN2@SymEnum
$LN3@SymEnum:

; 763  : 
; 764  :     //printf("sym=%X, i=%u\n", sym, *pi );
; 765  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]

; 766  : }

	ret	0
SymEnum	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
i$ = 0
j$ = 4
sym$ = 8
syms$ = 32
SymGetAll PROC

; 733  : {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 734  :     struct asym         *sym;
; 735  :     unsigned            i, j;
; 736  : 
; 737  :     /* copy symbols to table */
; 738  :     for( i = j = 0; i < GHASH_TABLE_SIZE; i++ ) {

	mov	DWORD PTR j$[rsp], 0
	mov	eax, DWORD PTR j$[rsp]
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN4@SymGetAll
$LN2@SymGetAll:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SymGetAll:
	cmp	DWORD PTR i$[rsp], 8009			; 00001f49H
	jae	SHORT $LN3@SymGetAll

; 739  :         for( sym = gsym_table[i]; sym; sym = sym->nextitem ) {

	mov	eax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:gsym_table
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR sym$[rsp], rax
	jmp	SHORT $LN7@SymGetAll
$LN5@SymGetAll:
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sym$[rsp], rax
$LN7@SymGetAll:
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN6@SymGetAll

; 740  :             syms[j++] = sym;

	mov	eax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR syms$[rsp]
	mov	rdx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax

; 741  :         }

	jmp	SHORT $LN5@SymGetAll
$LN6@SymGetAll:

; 742  :     }

	jmp	SHORT $LN2@SymGetAll
$LN3@SymGetAll:

; 743  :     return;
; 744  : }

	add	rsp, 24
	ret	0
SymGetAll ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
i$ = 32
sym$ = 40
SymMakeAllSymbolsPublic PROC

; 559  : {

$LN10:
	sub	rsp, 56					; 00000038H

; 560  :     int i;
; 561  :     struct asym  *sym;
; 562  : 
; 563  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@SymMakeAll
$LN2@SymMakeAll:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SymMakeAll:
	cmp	DWORD PTR i$[rsp], 8009			; 00001f49H
	jge	$LN3@SymMakeAll

; 564  :         for( sym = gsym_table[i]; sym; sym = sym->nextitem ) {

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:gsym_table
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR sym$[rsp], rax
	jmp	SHORT $LN7@SymMakeAll
$LN5@SymMakeAll:
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sym$[rsp], rax
$LN7@SymMakeAll:
	cmp	QWORD PTR sym$[rsp], 0
	je	$LN6@SymMakeAll

; 565  :             if ( sym->state == SYM_INTERNAL &&
; 566  :                 /* v2.07: MT_ABS is obsolete */
; 567  :                 //sym->mem_type != MT_ABS &&  /* no EQU or '=' constants */
; 568  :                 sym->isequate == FALSE &&     /* no EQU or '=' constants */
; 569  :                 sym->predefined == FALSE && /* no predefined symbols ($) */
; 570  :                 sym->included == FALSE && /* v2.09: symbol already added to public queue? */
; 571  :                 //sym->scoped == FALSE && /* v2.09: no procs that are marked as "private" */
; 572  :                 sym->name[1] != '&' && /* v2.10: no @@ code labels */

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	$LN8@SymMakeAll
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@SymMakeAll
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@SymMakeAll
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@SymMakeAll
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN8@SymMakeAll
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@SymMakeAll

; 573  :                 sym->ispublic == FALSE ) {
; 574  :                 sym->ispublic = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 575  :                 AddPublicData( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	AddPublicData
$LN8@SymMakeAll:

; 576  :             }
; 577  :         }

	jmp	$LN5@SymMakeAll
$LN6@SymMakeAll:

; 578  :     }

	jmp	$LN2@SymMakeAll
$LN3@SymMakeAll:

; 579  : }

	add	rsp, 56					; 00000038H
	ret	0
SymMakeAllSymbolsPublic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
i$ = 0
sym$1 = 8
pass$ = 32
SymPassInit PROC

; 689  : {

$LN12:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 690  :     unsigned            i;
; 691  : 
; 692  :     if ( pass == PASS_1 )

	cmp	DWORD PTR pass$[rsp], 0
	jne	SHORT $LN8@SymPassIni

; 693  :         return;

	jmp	SHORT $LN1@SymPassIni
$LN8@SymPassIni:

; 694  : 
; 695  : #if FASTPASS
; 696  :     /* No need to reset the "defined" flag if FASTPASS is on.
; 697  :      * Because then the source lines will come from the line store,
; 698  :      * where inactive conditional lines are NOT contained.
; 699  :      */
; 700  :     if ( UseSavedState )

	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	je	SHORT $LN9@SymPassIni

; 701  :         return;

	jmp	SHORT $LN1@SymPassIni
$LN9@SymPassIni:

; 702  : #endif
; 703  :     /* mark as "undefined":
; 704  :      * - SYM_INTERNAL - internals
; 705  :      * - SYM_MACRO - macros
; 706  :      * - SYM_TMACRO - text macros
; 707  :      */
; 708  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@SymPassIni
$LN2@SymPassIni:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SymPassIni:
	cmp	DWORD PTR i$[rsp], 8009			; 00001f49H
	jae	SHORT $LN3@SymPassIni

; 709  :         struct asym *sym;
; 710  :         for( sym = gsym_table[i]; sym; sym = sym->nextitem ) {

	mov	eax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:gsym_table
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR sym$1[rsp], rax
	jmp	SHORT $LN7@SymPassIni
$LN5@SymPassIni:
	mov	rax, QWORD PTR sym$1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sym$1[rsp], rax
$LN7@SymPassIni:
	cmp	QWORD PTR sym$1[rsp], 0
	je	SHORT $LN6@SymPassIni

; 711  :             if ( sym->predefined == FALSE ) {

	mov	rax, QWORD PTR sym$1[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@SymPassIni

; 712  :                 /* v2.04: all symbol's "defined" flag is now reset. */
; 713  :                 // if ( sym->state == SYM_TMACRO ||
; 714  :                 //    sym->state == SYM_MACRO  ||
; 715  :                 //    sym->state == SYM_INTERNAL ) {
; 716  :                     sym->isdefined = FALSE;

	mov	rax, QWORD PTR sym$1[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR sym$1[rsp]
	mov	BYTE PTR [rcx+40], al
$LN10@SymPassIni:

; 717  :                 //}
; 718  :             }
; 719  :         }

	jmp	SHORT $LN5@SymPassIni
$LN6@SymPassIni:

; 720  :     }

	jmp	SHORT $LN2@SymPassIni
$LN3@SymPassIni:
$LN1@SymPassIni:

; 721  : }

	add	rsp, 24
	ret	0
SymPassInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
i$ = 32
tv93 = 36
sym$1 = 40
sym$2 = 48
next$3 = 56
SymFini	PROC

; 587  : {

$LN19:
	sub	rsp, 72					; 00000048H

; 588  : #if FASTMEM==0 || defined( DEBUG_OUT )
; 589  :     unsigned i;
; 590  : #endif
; 591  : 
; 592  : #ifdef DEBUG_OUT
; 593  :     if ( Options.dump_symbols_hash ) {

	movzx	eax, BYTE PTR Options+27
	test	eax, eax
	je	$LN14@SymFini

; 594  :         for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@SymFini
$LN2@SymFini:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SymFini:
	cmp	DWORD PTR i$[rsp], 8009			; 00001f49H
	jae	SHORT $LN3@SymFini

; 595  :             struct asym  *sym = gsym_table[i];

	mov	eax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:gsym_table
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR sym$1[rsp], rax

; 596  :             if ( sym ) {

	cmp	QWORD PTR sym$1[rsp], 0
	je	SHORT $LN15@SymFini

; 597  :                 printf("%4u ", i );

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11280
	call	printf

; 598  :                 for( ; sym; sym = sym->nextitem ) {

	jmp	SHORT $LN7@SymFini
$LN5@SymFini:
	mov	rax, QWORD PTR sym$1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sym$1[rsp], rax
$LN7@SymFini:
	cmp	QWORD PTR sym$1[rsp], 0
	je	SHORT $LN6@SymFini

; 599  :                     printf("%-16s ", sym->name );

	mov	rax, QWORD PTR sym$1[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11281
	call	printf

; 600  :                 }

	jmp	SHORT $LN5@SymFini
$LN6@SymFini:

; 601  :                 printf("\n" );

	lea	rcx, OFFSET FLAT:$SG11282
	call	printf
$LN15@SymFini:

; 602  :             }
; 603  :         }

	jmp	SHORT $LN2@SymFini
$LN3@SymFini:
$LN14@SymFini:

; 604  :     }
; 605  :     DumpSymbols();

	call	DumpSymbols

; 606  : #endif
; 607  : 
; 608  : #if FASTMEM==0 || defined( DEBUG_OUT )
; 609  :     /* free the symbol table */
; 610  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN10@SymFini
$LN8@SymFini:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@SymFini:
	cmp	DWORD PTR i$[rsp], 8009			; 00001f49H
	jae	SHORT $LN9@SymFini

; 611  :         struct asym  *sym;
; 612  :         struct asym  *next;
; 613  :         for( sym = gsym_table[i]; sym; ) {

	mov	eax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:gsym_table
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR sym$2[rsp], rax
$LN11@SymFini:
	cmp	QWORD PTR sym$2[rsp], 0
	je	SHORT $LN12@SymFini

; 614  :             next = sym->nextitem;

	mov	rax, QWORD PTR sym$2[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR next$3[rsp], rax

; 615  :             SymFree( sym );

	mov	rcx, QWORD PTR sym$2[rsp]
	call	SymFree

; 616  :             SymCount--;

	mov	eax, DWORD PTR SymCount
	dec	eax
	mov	DWORD PTR SymCount, eax

; 617  :             sym = next;

	mov	rax, QWORD PTR next$3[rsp]
	mov	QWORD PTR sym$2[rsp], rax

; 618  :         }

	jmp	SHORT $LN11@SymFini
$LN12@SymFini:

; 619  :     }

	jmp	SHORT $LN8@SymFini
$LN9@SymFini:

; 620  :     /**/myassert( SymCount == 0 );

	cmp	DWORD PTR SymCount, 0
	jne	SHORT $LN17@SymFini
	mov	DWORD PTR tv93[rsp], 0
	jmp	SHORT $LN18@SymFini
$LN17@SymFini:
	mov	edx, 620				; 0000026cH
	lea	rcx, OFFSET FLAT:$SG11283
	call	InternalError
	mov	DWORD PTR tv93[rsp], eax
$LN18@SymFini:

; 621  : #endif
; 622  : 
; 623  : }

	add	rsp, 72					; 00000048H
	ret	0
SymFini	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
i$ = 48
sym$ = 56
now$ = 64
time_of_day$ = 72
SymInit	PROC

; 629  : {

$LN11:
	sub	rsp, 88					; 00000058H

; 630  :     struct asym *sym;
; 631  :     int i;
; 632  :     time_t    time_of_day;
; 633  :     struct tm *now;
; 634  : 
; 635  :     DebugMsg(("SymInit() enter\n"));

	lea	rcx, OFFSET FLAT:$SG11298
	call	DoDebugMsg

; 636  :     SymCount = 0;

	mov	DWORD PTR SymCount, 0

; 637  : 
; 638  :     /* v2.11: ensure CurrProc is NULL - might be a problem if multiple files are assembled */
; 639  :     CurrProc = NULL;

	mov	QWORD PTR CurrProc, 0

; 640  : 
; 641  :     memset( gsym_table, 0, sizeof(gsym_table) );

	mov	r8d, 64072				; 0000fa48H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:gsym_table
	call	memset

; 642  : 
; 643  :     time_of_day = time( NULL );

	xor	ecx, ecx
	call	time
	mov	QWORD PTR time_of_day$[rsp], rax

; 644  :     now = localtime( &time_of_day );

	lea	rcx, QWORD PTR time_of_day$[rsp]
	call	localtime
	mov	QWORD PTR now$[rsp], rax

; 645  : #if USESTRFTIME
; 646  :     strftime( szDate, 9, szDateFmt, now );
; 647  :     strftime( szTime, 9, szTimeFmt, now );
; 648  : #else
; 649  :     sprintf( szDate, "%02u/%02u/%02u", now->tm_mon + 1, now->tm_mday, now->tm_year % 100 );

	mov	rax, QWORD PTR now$[rsp]
	mov	eax, DWORD PTR [rax+20]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	eax, edx
	mov	rcx, QWORD PTR now$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	inc	ecx
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR now$[rsp]
	mov	r9d, DWORD PTR [rax+12]
	mov	r8d, ecx
	lea	rdx, OFFSET FLAT:$SG11299
	lea	rcx, OFFSET FLAT:szDate
	call	sprintf

; 650  :     sprintf( szTime, "%02u:%02u:%02u", now->tm_hour, now->tm_min, now->tm_sec );

	mov	rax, QWORD PTR now$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR now$[rsp]
	mov	r9d, DWORD PTR [rax+4]
	mov	rax, QWORD PTR now$[rsp]
	mov	r8d, DWORD PTR [rax+8]
	lea	rdx, OFFSET FLAT:$SG11300
	lea	rcx, OFFSET FLAT:szTime
	call	sprintf

; 651  : #endif
; 652  : 
; 653  :     for( i = 0; i < sizeof(tmtab) / sizeof(tmtab[0]); i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@SymInit
$LN2@SymInit:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SymInit:
	movsxd	rax, DWORD PTR i$[rsp]
	cmp	rax, 6
	jae	$LN3@SymInit

; 654  :         sym = SymCreate( tmtab[i].name );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:tmtab
	mov	rcx, QWORD PTR [rcx+rax]
	call	SymCreate
	mov	QWORD PTR sym$[rsp], rax

; 655  :         sym->state = SYM_TMACRO;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+32], 10

; 656  :         sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 657  :         sym->predefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 658  :         sym->string_ptr = tmtab[i].value;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:tmtab
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR [rdx+16], rax

; 659  :         if ( tmtab[i].store )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:tmtab
	cmp	QWORD PTR [rcx+rax+16], 0
	je	SHORT $LN8@SymInit

; 660  :             *tmtab[i].store = sym;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:tmtab
	mov	rax, QWORD PTR [rcx+rax+16]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx
$LN8@SymInit:

; 661  :     }

	jmp	$LN2@SymInit
$LN3@SymInit:

; 662  : 
; 663  :     for( i = 0; i < sizeof(eqtab) / sizeof(eqtab[0]); i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@SymInit
$LN5@SymInit:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@SymInit:
	movsxd	rax, DWORD PTR i$[rsp]
	cmp	rax, 5
	jae	$LN6@SymInit

; 664  :         sym = SymCreate( eqtab[i].name );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rcx, OFFSET FLAT:eqtab
	mov	rcx, QWORD PTR [rcx+rax]
	call	SymCreate
	mov	QWORD PTR sym$[rsp], rax

; 665  :         sym->state = SYM_INTERNAL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+32], 1

; 666  :         /* v2.07: MT_ABS is obsolete */
; 667  :         //sym->mem_type = MT_ABS;
; 668  :         sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 669  :         sym->predefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 670  :         sym->offset = eqtab[i].value;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rcx, OFFSET FLAT:eqtab
	mov	rdx, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rcx+rax+8]
	mov	DWORD PTR [rdx+16], eax

; 671  :         sym->sfunc_ptr = eqtab[i].sfunc_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rcx, OFFSET FLAT:eqtab
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rcx+rax+16]
	mov	QWORD PTR [rdx+64], rax

; 672  :         //sym->variable = TRUE; /* if fixup must be created */
; 673  :         if ( eqtab[i].store )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rcx, OFFSET FLAT:eqtab
	cmp	QWORD PTR [rcx+rax+24], 0
	je	SHORT $LN9@SymInit

; 674  :             *eqtab[i].store = sym;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rcx, OFFSET FLAT:eqtab
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx
$LN9@SymInit:

; 675  :     }

	jmp	$LN5@SymInit
$LN6@SymInit:

; 676  :     sym->list   = FALSE; /* @WordSize should not be listed */

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+41], al

; 677  :     /* $ is an address (usually). Also, don't add it to the list */
; 678  :     symPC->variable = TRUE;

	mov	rax, QWORD PTR symPC
	movzx	eax, BYTE PTR [rax+40]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR symPC
	mov	BYTE PTR [rcx+40], al

; 679  :     symPC->list     = FALSE;

	mov	rax, QWORD PTR symPC
	movzx	eax, BYTE PTR [rax+41]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR symPC
	mov	BYTE PTR [rcx+41], al

; 680  :     LineCur->list   = FALSE;

	mov	rax, QWORD PTR LineCur
	movzx	eax, BYTE PTR [rax+41]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR LineCur
	mov	BYTE PTR [rcx+41], al

; 681  : 
; 682  :     DebugMsg(("SymInit() exit\n"));

	lea	rcx, OFFSET FLAT:$SG11303
	call	DoDebugMsg

; 683  :     return;
; 684  : 
; 685  : }

	add	rsp, 88					; 00000058H
	ret	0
SymInit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
len$ = 48
i$ = 52
name$ = 80
SymFindDeclare PROC

; 299  : {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 300  : 	int i;
; 301  : 	int len;
; 302  : 
; 303  : 	len = strlen(name);

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 304  : 	i = hashpjw(name);

	mov	rcx, QWORD PTR name$[rsp]
	call	hashpjw
	mov	DWORD PTR i$[rsp], eax

; 305  : 
; 306  : 	if (CurrProc) {

	cmp	QWORD PTR CurrProc, 0
	je	$LN8@SymFindDec

; 307  : 		for (lsym = &lsym_table[i % LHASH_TABLE_SIZE]; *lsym; lsym = &((*lsym)->nextitem)) {

	mov	eax, DWORD PTR i$[rsp]
	cdq
	mov	ecx, 127				; 0000007fH
	idiv	ecx
	mov	eax, edx
	cdqe
	lea	rcx, OFFSET FLAT:lsym_table
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR lsym, rax
	jmp	SHORT $LN4@SymFindDec
$LN2@SymFindDec:
	mov	rax, QWORD PTR lsym
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR lsym, rax
$LN4@SymFindDec:
	mov	rax, QWORD PTR lsym
	cmp	QWORD PTR [rax], 0
	je	$LN3@SymFindDec

; 308  : 			if (len == (*lsym)->name_size && SYMCMP(name, (*lsym)->name, len) == 0) {

	mov	rax, QWORD PTR lsym
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+72]
	cmp	DWORD PTR len$[rsp], eax
	jne	SHORT $LN9@SymFindDec
	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR lsym
	mov	rcx, QWORD PTR [rcx]
	mov	r8, rax
	mov	rdx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR name$[rsp]
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	jne	SHORT $LN9@SymFindDec

; 309  : 				DebugMsg1(("SymFind(%s): found in local table, state=%u, local=%u\n", name, (*lsym)->state, (*lsym)->scoped));

	mov	rax, QWORD PTR lsym
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	mov	rcx, QWORD PTR lsym
	mov	rcx, QWORD PTR [rcx]
	mov	r9d, eax
	mov	r8d, DWORD PTR [rcx+32]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11163
	call	DoDebugMsg1

; 310  : 				return(*lsym);

	mov	rax, QWORD PTR lsym
	mov	rax, QWORD PTR [rax]
	jmp	$LN1@SymFindDec
$LN9@SymFindDec:

; 311  : 			}
; 312  : 		}

	jmp	$LN2@SymFindDec
$LN3@SymFindDec:
$LN8@SymFindDec:

; 313  : 	}
; 314  : 
; 315  : 	for (gsym = &gsym_table[i % GHASH_TABLE_SIZE]; *gsym; gsym = &((*gsym)->nextitem)) {

	mov	eax, DWORD PTR i$[rsp]
	cdq
	mov	ecx, 8009				; 00001f49H
	idiv	ecx
	mov	eax, edx
	cdqe
	lea	rcx, OFFSET FLAT:gsym_table
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR gsym, rax
	jmp	SHORT $LN7@SymFindDec
$LN5@SymFindDec:
	mov	rax, QWORD PTR gsym
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR gsym, rax
$LN7@SymFindDec:
	mov	rax, QWORD PTR gsym
	cmp	QWORD PTR [rax], 0
	je	$LN6@SymFindDec

; 316  : 		if (len == (*gsym)->name_size && SYMCMP(name, (*gsym)->name, len) == 0) {

	mov	rax, QWORD PTR gsym
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+72]
	cmp	DWORD PTR len$[rsp], eax
	jne	SHORT $LN10@SymFindDec
	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR gsym
	mov	rcx, QWORD PTR [rcx]
	mov	r8, rax
	mov	rdx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR name$[rsp]
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	jne	SHORT $LN10@SymFindDec

; 317  : 			DebugMsg1(("SymFind(%s): found, state=%u memtype=%X lang=%u\n", name, (*gsym)->state, (*gsym)->mem_type, (*gsym)->langtype));

	mov	rax, QWORD PTR gsym
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR gsym
	mov	rcx, QWORD PTR [rcx]
	mov	rdx, QWORD PTR gsym
	mov	rdx, QWORD PTR [rdx]
	mov	eax, DWORD PTR [rax+76]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR [rcx+36]
	mov	r8d, DWORD PTR [rdx+32]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11165
	call	DoDebugMsg1

; 318  : 			return(*gsym);

	mov	rax, QWORD PTR gsym
	mov	rax, QWORD PTR [rax]
	jmp	SHORT $LN1@SymFindDec
$LN10@SymFindDec:

; 319  : 		}
; 320  : 	}

	jmp	$LN5@SymFindDec
$LN6@SymFindDec:

; 321  : 
; 322  : 	return(NULL);

	xor	eax, eax
$LN1@SymFindDec:

; 323  : }

	add	rsp, 72					; 00000048H
	ret	0
SymFindDeclare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
len$ = 48
i$ = 52
name$ = 80
SymFind	PROC

; 263  : {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 264  :     int i;
; 265  :     int len;
; 266  : 
; 267  :     len = strlen( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 268  :     i = hashpjw( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	hashpjw
	mov	DWORD PTR i$[rsp], eax

; 269  : 
; 270  :     if ( CurrProc ) {

	cmp	QWORD PTR CurrProc, 0
	je	$LN8@SymFind

; 271  :         for( lsym = &lsym_table[ i % LHASH_TABLE_SIZE ]; *lsym; lsym = &((*lsym)->nextitem ) ) {

	mov	eax, DWORD PTR i$[rsp]
	cdq
	mov	ecx, 127				; 0000007fH
	idiv	ecx
	mov	eax, edx
	cdqe
	lea	rcx, OFFSET FLAT:lsym_table
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR lsym, rax
	jmp	SHORT $LN4@SymFind
$LN2@SymFind:
	mov	rax, QWORD PTR lsym
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR lsym, rax
$LN4@SymFind:
	mov	rax, QWORD PTR lsym
	cmp	QWORD PTR [rax], 0
	je	$LN3@SymFind

; 272  :             if ( len == (*lsym)->name_size && SYMCMP( name, (*lsym)->name, len ) == 0 ) {

	mov	rax, QWORD PTR lsym
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+72]
	cmp	DWORD PTR len$[rsp], eax
	jne	$LN9@SymFind
	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR lsym
	mov	rcx, QWORD PTR [rcx]
	mov	r8, rax
	mov	rdx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR name$[rsp]
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	jne	SHORT $LN9@SymFind

; 273  :                 DebugMsg1(("SymFind(%s): found in local table, state=%u, local=%u\n", name, (*lsym)->state, (*lsym)->scoped ));  			

	mov	rax, QWORD PTR lsym
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	mov	rcx, QWORD PTR lsym
	mov	rcx, QWORD PTR [rcx]
	mov	r9d, eax
	mov	r8d, DWORD PTR [rcx+32]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11146
	call	DoDebugMsg1

; 274  : 				(*lsym)->used = TRUE;

	mov	rax, QWORD PTR lsym
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 1
	mov	rcx, QWORD PTR lsym
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rcx+40], al

; 275  :                 return( *lsym );

	mov	rax, QWORD PTR lsym
	mov	rax, QWORD PTR [rax]
	jmp	$LN1@SymFind
$LN9@SymFind:

; 276  :             }
; 277  :         }

	jmp	$LN2@SymFind
$LN3@SymFind:
$LN8@SymFind:

; 278  :     }
; 279  : 
; 280  :     for( gsym = &gsym_table[ i % GHASH_TABLE_SIZE ]; *gsym; gsym = &((*gsym)->nextitem ) ) {

	mov	eax, DWORD PTR i$[rsp]
	cdq
	mov	ecx, 8009				; 00001f49H
	idiv	ecx
	mov	eax, edx
	cdqe
	lea	rcx, OFFSET FLAT:gsym_table
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR gsym, rax
	jmp	SHORT $LN7@SymFind
$LN5@SymFind:
	mov	rax, QWORD PTR gsym
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR gsym, rax
$LN7@SymFind:
	mov	rax, QWORD PTR gsym
	cmp	QWORD PTR [rax], 0
	je	$LN6@SymFind

; 281  :         if ( len == (*gsym)->name_size && SYMCMP( name, (*gsym)->name, len ) == 0 ) {

	mov	rax, QWORD PTR gsym
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+72]
	cmp	DWORD PTR len$[rsp], eax
	jne	SHORT $LN10@SymFind
	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR gsym
	mov	rcx, QWORD PTR [rcx]
	mov	r8, rax
	mov	rdx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR name$[rsp]
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	jne	SHORT $LN10@SymFind

; 282  :             DebugMsg1(("SymFind(%s): found, state=%u memtype=%X lang=%u\n", name, (*gsym)->state, (*gsym)->mem_type, (*gsym)->langtype ));

	mov	rax, QWORD PTR gsym
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR gsym
	mov	rcx, QWORD PTR [rcx]
	mov	rdx, QWORD PTR gsym
	mov	rdx, QWORD PTR [rdx]
	mov	eax, DWORD PTR [rax+76]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR [rcx+36]
	mov	r8d, DWORD PTR [rdx+32]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11148
	call	DoDebugMsg1

; 283  :             return( *gsym );

	mov	rax, QWORD PTR gsym
	mov	rax, QWORD PTR [rax]
	jmp	SHORT $LN1@SymFind
$LN10@SymFind:

; 284  :         }
; 285  :     }

	jmp	$LN5@SymFind
$LN6@SymFind:

; 286  : 
; 287  :     return( NULL );

	xor	eax, eax
$LN1@SymFind:

; 288  : }

	add	rsp, 72					; 00000048H
	ret	0
SymFind	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 32
name$ = 64
SymLookupLocal PROC

; 361  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 362  :     //struct asym      **sym_ptr;
; 363  :     struct asym      *sym;
; 364  : 
; 365  :     sym = SymFind( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 366  :     if ( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN2@SymLookupL

; 367  :         sym = SymAlloc( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymAlloc
	mov	QWORD PTR sym$[rsp], rax

; 368  :         sym->scoped = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 4
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 369  :         /* add the label to the local hash table */
; 370  :         //sym->next = *lsym;
; 371  :         *lsym = sym;

	mov	rax, QWORD PTR lsym
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx

; 372  :         DebugMsg1(("SymLookupLocal(%s): local symbol created in %s\n", name, CurrProc->sym.name));

	mov	rax, QWORD PTR CurrProc
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11183
	call	DoDebugMsg1
	jmp	$LN3@SymLookupL
$LN2@SymLookupL:

; 373  :     } else if( sym->state == SYM_UNDEFINED && sym->scoped == FALSE ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	$LN4@SymLookupL
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@SymLookupL

; 374  :         /* if the label was defined due to a FORWARD reference,
; 375  :          * its scope is to be changed from global to local.
; 376  :          */
; 377  :         /* remove the label from the global hash table */
; 378  :         *gsym = sym->nextitem;

	mov	rax, QWORD PTR gsym
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 379  :         SymCount--;

	mov	eax, DWORD PTR SymCount
	dec	eax
	mov	DWORD PTR SymCount, eax

; 380  :         sym->scoped = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 4
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 381  :         /* add the label to the local hash table */
; 382  :         //sym->next = *lsym;
; 383  :         sym->nextitem = NULL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], 0

; 384  :         *lsym = sym;

	mov	rax, QWORD PTR lsym
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx

; 385  :         DebugMsg1(("SymLookupLocal(%s): label moved into %s's local namespace\n", sym->name, CurrProc->sym.name ));

	mov	rax, QWORD PTR CurrProc
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11185
	call	DoDebugMsg1
$LN4@SymLookupL:
$LN3@SymLookupL:

; 386  :     }
; 387  : 
; 388  :     DebugMsg1(("SymLookupLocal(%s): found, state=%u, defined=%u\n", name, sym->state, sym->isdefined));

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	mov	r9d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+32]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11186
	call	DoDebugMsg1

; 389  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]

; 390  : }

	add	rsp, 56					; 00000038H
	ret	0
SymLookupLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 32
tv71 = 40
name$ = 64
SymLookup PROC

; 339  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 340  :     struct asym      *sym;
; 341  : 
; 342  :     sym = SymFind( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 343  :     if( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN2@SymLookup

; 344  :         sym = SymAlloc( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymAlloc
	mov	QWORD PTR sym$[rsp], rax

; 345  :         DebugMsg1(("SymLookup(%s): created new symbol, CurrProc=%s\n", name, CurrProc ? CurrProc->sym.name : "NULL" ));

	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN4@SymLookup
	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv71[rsp], rax
	jmp	SHORT $LN5@SymLookup
$LN4@SymLookup:
	lea	rax, OFFSET FLAT:$SG11172
	mov	QWORD PTR tv71[rsp], rax
$LN5@SymLookup:
	mov	r8, QWORD PTR tv71[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11173
	call	DoDebugMsg1

; 346  :         //sym->next = *gsym;
; 347  :         *gsym = sym;

	mov	rax, QWORD PTR gsym
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx

; 348  :         ++SymCount;

	mov	eax, DWORD PTR SymCount
	inc	eax
	mov	DWORD PTR SymCount, eax
$LN2@SymLookup:

; 349  :     }
; 350  : 
; 351  :     DebugMsg1(("SymLookup(%s): found, state=%u, defined=%u\n", name, sym->state, sym->isdefined));

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	mov	r9d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+32]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11174
	call	DoDebugMsg1

; 352  : 
; 353  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]

; 354  : }

	add	rsp, 56					; 00000038H
	ret	0
SymLookup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym2$ = 32
sym$ = 64
name$ = 72
SymAddLocal PROC

; 483  : {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 484  :     struct asym *sym2;
; 485  :     /* v2.10: ignore symbols with state SYM_UNDEFINED! */
; 486  :     //if( SymFind( name ) ) {
; 487  :     if( ( sym2 = SymFind( name ) ) && sym2->state != SYM_UNDEFINED ) {

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym2$[rsp], rax
	cmp	QWORD PTR sym2$[rsp], 0
	je	SHORT $LN2@SymAddLoca
	mov	rax, QWORD PTR sym2$[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN2@SymAddLoca

; 488  :         /* shouldn't happen */
; 489  :         EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 490  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@SymAddLoca
$LN2@SymAddLoca:

; 491  :     }
; 492  : #if FASTMEM==0
; 493  :     if ( sym->name_size ) LclFree( sym->name );
; 494  : #endif
; 495  :     sym->name_size = strlen( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+72], al

; 496  :     sym->name = LclAlloc( sym->name_size + 1 );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	inc	eax
	cdqe
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 497  :     memcpy( sym->name, name, sym->name_size + 1 );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	inc	eax
	cdqe
	mov	r8, rax
	mov	rdx, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy

; 498  :     sym->nextitem = NULL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], 0

; 499  :     *lsym = sym;

	mov	rax, QWORD PTR lsym
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx

; 500  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]
$LN1@SymAddLoca:

; 501  : }

	add	rsp, 56					; 00000038H
	ret	0
SymAddLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 48
SymAddGlobal PROC

; 510  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 511  :     if( SymFind( sym->name ) ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	SymFind
	test	rax, rax
	je	SHORT $LN2@SymAddGlob

; 512  :         EmitErr( SYMBOL_ALREADY_DEFINED, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 513  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@SymAddGlob
$LN2@SymAddGlob:

; 514  :     }
; 515  :     sym->nextitem = NULL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], 0

; 516  :     *gsym = sym;

	mov	rax, QWORD PTR gsym
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx

; 517  :     SymCount++;

	mov	eax, DWORD PTR SymCount
	inc	eax
	mov	DWORD PTR SymCount, eax

; 518  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]
$LN1@SymAddGlob:

; 519  : }

	add	rsp, 40					; 00000028H
	ret	0
SymAddGlobal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 32
name$ = 64
SymLCreate PROC

; 543  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 544  :     struct asym *sym;
; 545  : 
; 546  :     /* v2.10: ignore symbols with state SYM_UNDEFINED */
; 547  :     //if( SymFind( name ) ) {
; 548  :     if( ( sym = SymFindDeclare( name ) ) && sym->state != SYM_UNDEFINED ) {

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFindDeclare
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN2@SymLCreate
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN2@SymLCreate

; 549  :         EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 550  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@SymLCreate
$LN2@SymLCreate:

; 551  :     }
; 552  :     sym = SymAlloc( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymAlloc
	mov	QWORD PTR sym$[rsp], rax

; 553  :     *lsym = sym;

	mov	rax, QWORD PTR lsym
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx

; 554  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]
$LN1@SymLCreate:

; 555  : }

	add	rsp, 56					; 00000038H
	ret	0
SymLCreate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 32
name$ = 64
SymCreate PROC

; 524  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 525  :     struct asym *sym;
; 526  : 
; 527  :     if( SymFind( name ) ) {

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	test	rax, rax
	je	SHORT $LN2@SymCreate

; 528  :         EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 529  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@SymCreate
$LN2@SymCreate:

; 530  :     }
; 531  :     sym = SymAlloc( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymAlloc
	mov	QWORD PTR sym$[rsp], rax

; 532  :     *gsym = sym;

	mov	rax, QWORD PTR gsym
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx

; 533  :     SymCount++;

	mov	eax, DWORD PTR SymCount
	inc	eax
	mov	DWORD PTR SymCount, eax

; 534  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]
$LN1@SymCreate:

; 535  : }

	add	rsp, 56					; 00000038H
	ret	0
SymCreate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 48
SymFree	PROC

; 457  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 458  :     //DebugMsg(("SymFree: free %X, name=%s, state=%X\n", sym, sym->name, sym->state));
; 459  :     free_ext( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	free_ext

; 460  : #if FASTMEM==0
; 461  :     if ( sym->state != SYM_EXTERNAL ) {
; 462  :         struct fixup *fix;
; 463  :         for( fix = sym->bp_fixup ; fix; ) {
; 464  :             struct fixup *next = fix->nextbp;
; 465  :             DebugMsg(("SymFree: free bp fixup %p\n", fix ));
; 466  :             LclFree( fix );
; 467  :             fix = next;
; 468  :         }
; 469  :     }
; 470  :     if ( sym->name_size ) LclFree( sym->name );
; 471  : #endif
; 472  :     LclFree( sym );
; 473  :     return;
; 474  : }

	add	rsp, 40					; 00000028H
	ret	0
SymFree	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
len$ = 32
sym$ = 40
name$ = 64
SymAlloc PROC

; 229  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 230  :     int len = strlen( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 231  :     struct asym *sym;
; 232  : 
; 233  :     sym = LclAlloc( sizeof( struct dsym ) );

	mov	ecx, 120				; 00000078H
	call	LclAlloc
	mov	QWORD PTR sym$[rsp], rax

; 234  :     memset( sym, 0, sizeof( struct dsym ) );

	mov	r8d, 120				; 00000078H
	xor	edx, edx
	mov	rcx, QWORD PTR sym$[rsp]
	call	memset

; 235  : #if 1
; 236  :     /* the tokenizer ensures that identifiers are within limits, so
; 237  :      * this check probably is redundant */
; 238  :     if( len > MAX_ID_LEN ) {

	cmp	DWORD PTR len$[rsp], 247		; 000000f7H
	jle	SHORT $LN2@SymAlloc

; 239  :         EmitError( IDENTIFIER_TOO_LONG );

	mov	ecx, 70					; 00000046H
	call	EmitError

; 240  :         len = MAX_ID_LEN;

	mov	DWORD PTR len$[rsp], 247		; 000000f7H
$LN2@SymAlloc:

; 241  :     }
; 242  : #endif
; 243  :     sym->name_size = len;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR len$[rsp]
	mov	BYTE PTR [rax+72], cl

; 244  :     sym->list = ModuleInfo.cref;

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 12
	and	eax, 1
	and	al, 1
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+41]
	and	cl, 254					; 000000feH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+41], al

; 245  :     sym->mem_type = MT_EMPTY;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+36], 192			; 000000c0H

; 246  :     if ( len ) {

	cmp	DWORD PTR len$[rsp], 0
	je	SHORT $LN3@SymAlloc

; 247  :         sym->name = LclAlloc( len + 1 );

	mov	eax, DWORD PTR len$[rsp]
	inc	eax
	cdqe
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 248  :         memcpy( sym->name, name, len );

	movsxd	rax, DWORD PTR len$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy

; 249  :         sym->name[len] = NULLC;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rcx+rax], 0

; 250  :     } else

	jmp	SHORT $LN4@SymAlloc
$LN3@SymAlloc:

; 251  :         sym->name = "";

	mov	rax, QWORD PTR sym$[rsp]
	lea	rcx, OFFSET FLAT:$SG11131
	mov	QWORD PTR [rax+8], rcx
$LN4@SymAlloc:

; 252  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]

; 253  : }

	add	rsp, 56					; 00000038H
	ret	0
SymAlloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1788 : }

	add	rsp, 56					; 00000038H
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

	add	rsp, 56					; 00000038H
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	__stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1391 : }

	add	rsp, 72					; 00000048H
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 950  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 957  : }

	add	rsp, 56					; 00000038H
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 640  : }

	add	rsp, 56					; 00000038H
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 534  :         {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 535  :             return _time64(_Time);

	mov	rcx, QWORD PTR _Time$[rsp]
	call	_time64

; 536  :         }

	add	rsp, 40					; 00000028H
	ret	0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\time.h
;	COMDAT localtime
_TEXT	SEGMENT
_Time$ = 48
localtime PROC						; COMDAT

; 508  :         {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 509  :             #pragma warning(push)
; 510  :             #pragma warning(disable: 4996)
; 511  :             return _localtime64(_Time);

	mov	rcx, QWORD PTR _Time$[rsp]
	call	_localtime64

; 512  :             #pragma warning(pop)
; 513  :         }

	add	rsp, 40					; 00000028H
	ret	0
localtime ENDP
_TEXT	ENDS
END
