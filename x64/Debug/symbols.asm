; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

EXTRN	ModuleInfo:BYTE
EXTRN	FileCur:QWORD
EXTRN	LineCur:QWORD
EXTRN	symCurSeg:QWORD
EXTRN	UpdateLineNumber:PROC
EXTRN	UpdateWordSize:PROC
EXTRN	UpdateCurPC:PROC
_DATA	SEGMENT
COMM	SymCmpFunc:QWORD
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
_BSS	SEGMENT
szDate	DB	0cH DUP (?)
szTime	DB	0cH DUP (?)
symPC	DQ	01H DUP (?)
$SG11025 DB	01H DUP (?)
	ALIGN	4

$SG11090 DB	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
tmtab	DQ	FLAT:$SG11018
	DQ	FLAT:$SG11019
	DQ	0000000000000000H
	DQ	FLAT:$SG11020
	DQ	FLAT:szDate
	DQ	0000000000000000H
	DQ	FLAT:$SG11021
	DQ	FLAT:szTime
	DQ	0000000000000000H
	DQ	FLAT:$SG11022
	DQ	FLAT:ModuleInfo+512
	DQ	0000000000000000H
	DQ	FLAT:$SG11023
	DQ	0000000000000000H
	DQ	FLAT:FileCur
	DQ	FLAT:$SG11024
	DQ	FLAT:$SG11025
	DQ	FLAT:symCurSeg
eqtab	DQ	FLAT:$SG11039
	DD	0d5H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:$SG11040
	DD	0d4H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:$SG11041
	DD	00H
	ORG $+4
	DQ	FLAT:UpdateCurPC
	DQ	FLAT:symPC
	DQ	FLAT:$SG11042
	DD	00H
	ORG $+4
	DQ	FLAT:UpdateLineNumber
	DQ	FLAT:LineCur
	DQ	FLAT:$SG11043
	DD	00H
	ORG $+4
	DQ	FLAT:UpdateWordSize
	DQ	0000000000000000H
CONST	ENDS
_DATA	SEGMENT
$SG11301 DB	'Undefined', 00H
	ORG $+6
$SG11305 DB	'Procedure', 00H
	ORG $+2
$SG11308 DB	'Number', 00H
	ORG $+1
$SG11019 DB	'800', 00H
$SG11312 DB	'Code Label', 00H
	ORG $+1
$SG11041 DB	'$', 00H
	ORG $+2
$SG11313 DB	'Data Label', 00H
	ORG $+1
$SG11317 DB	'Proto', 00H
	ORG $+2
$SG11345 DB	'Record', 00H
	ORG $+1
$SG11224 DB	0aH, 00H
	ORG $+2
$SG11320 DB	'Communal', 00H
	ORG $+3
$SG11332 DB	'Group', 00H
	ORG $+2
$SG11223 DB	'%-16s ', 00H
	ORG $+5
$SG11323 DB	'Number (ext)', 00H
	ORG $+3
$SG11327 DB	'Code (ext)', 00H
	ORG $+5
$SG11328 DB	'Data (ext)', 00H
	ORG $+5
$SG11330 DB	'Segment', 00H
$SG11334 DB	'Stack Var', 00H
	ORG $+6
$SG11336 DB	'Struct Field', 00H
	ORG $+3
$SG11339 DB	'Structure', 00H
	ORG $+2
$SG11341 DB	'Union', 00H
	ORG $+6
$SG11343 DB	'Typedef', 00H
$SG11347 DB	'Undef Type', 00H
	ORG $+1
$SG11349 DB	'Alias', 00H
	ORG $+2
$SG11351 DB	'Macro', 00H
	ORG $+2
$SG11353 DB	'Text', 00H
	ORG $+7
$SG11355 DB	'Unknown', 00H
$SG11356 DB	'%-12s  %16I64X %02X %8p %c %8p %s', 0aH, 00H
	ORG $+5
$SG11374 DB	'DumpSymbols enter', 0aH, 00H
	ORG $+5
$SG11376 DB	'   # Addr     Type                     Value MT    Ext  '
	DB	' P  pName   Name', 0aH, 00H
	ORG $+6
$SG11377 DB	'--------------------------------------------------------'
	DB	'------------------------', 0aH, 00H
	ORG $+6
$SG11379 DB	'%4u %8p ', 00H
	ORG $+7
$SG11389 DB	'%u items in symbol table, expected %u', 0aH, 00H
	ORG $+1
$SG11390 DB	'max items in a line=%u, lines with 0/1/<=5/<=10 items=%u'
	DB	'/%u/%u/%u, ', 0aH, 00H
	ORG $+3
$SG11018 DB	'@Version', 00H
	ORG $+3
$SG11020 DB	'@Date', 00H
	ORG $+2
$SG11021 DB	'@Time', 00H
	ORG $+6
$SG11022 DB	'@FileName', 00H
	ORG $+6
$SG11023 DB	'@FileCur', 00H
	ORG $+7
$SG11024 DB	'@CurSeg', 00H
$SG11039 DB	'__HJWASM__', 00H
	ORG $+5
$SG11040 DB	'__JWASM__', 00H
	ORG $+2
$SG11042 DB	'@Line', 00H
	ORG $+6
$SG11043 DB	'@WordSize', 00H
	ORG $+6
$SG11079 DB	'SymSetLocal(%s): label=%s', 0aH, 00H
	ORG $+5
$SG11105 DB	'SymFind(%s): found in local table, state=%u, local=%u', 0aH
	DB	00H
	ORG $+1
$SG11107 DB	'SymFind(%s): found, state=%u memtype=%X lang=%u', 0aH, 00H
	ORG $+3
$SG11114 DB	'NULL', 00H
	ORG $+7
$SG11115 DB	'SymLookup(%s): created new symbol, CurrProc=%s', 0aH, 00H
$SG11116 DB	'SymLookup(%s): found, state=%u, defined=%u', 0aH, 00H
	ORG $+4
$SG11125 DB	'SymLookupLocal(%s): local symbol created in %s', 0aH, 00H
$SG11127 DB	'SymLookupLocal(%s): label moved into %s''s local namespa'
	DB	'ce', 0aH, 00H
	ORG $+5
$SG11128 DB	'SymLookupLocal(%s): found, state=%u, defined=%u', 0aH, 00H
	ORG $+7
$SG11141 DB	'free_ext: item=%p name=%s state=%u', 0aH, 00H
	ORG $+4
$SG11147 DB	'free_ext: external with private type: %s', 0aH, 00H
	ORG $+6
$SG11157 DB	'free_ext: case SYM_STACK, sym=%s with private type', 0aH
	DB	00H
$SG11222 DB	'%4u ', 00H
	ORG $+7
$SG11225 DB	'symbols.c', 00H
	ORG $+6
$SG11240 DB	'SymInit() enter', 0aH, 00H
	ORG $+7
$SG11241 DB	'%02u/%02u/%02u', 00H
	ORG $+1
$SG11242 DB	'%02u:%02u:%02u', 00H
	ORG $+1
$SG11245 DB	'SymInit() exit', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	SymAlloc
PUBLIC	SymFree
PUBLIC	SymCreate
PUBLIC	SymLCreate
PUBLIC	SymAddGlobal
PUBLIC	SymAddLocal
PUBLIC	SymLookup
PUBLIC	SymLookupLocal
PUBLIC	SymFind
PUBLIC	SymInit
PUBLIC	SymFini
PUBLIC	SymPassInit
PUBLIC	SymMakeAllSymbolsPublic
PUBLIC	SymGetAll
PUBLIC	SymEnum
PUBLIC	SymGetCount
PUBLIC	SymSetCmpFunc
PUBLIC	SymClearLocal
PUBLIC	SymSetLocal
PUBLIC	SymGetLocal
EXTRN	__imp__localtime64:PROC
EXTRN	__imp__time64:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__imp__memicmp:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	LclAlloc:PROC
EXTRN	DeleteGroup:PROC
EXTRN	AddPublicData:PROC
EXTRN	InternalError:PROC
EXTRN	ReleaseMacroData:PROC
EXTRN	DeleteType:PROC
EXTRN	DeleteProc:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	_RTC_UninitUse:PROC
EXTRN	Options:BYTE
EXTRN	UseSavedState:BYTE
EXTRN	CurrProc:QWORD
EXTRN	__ImageBase:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	8

gsym_table DQ	01f49H DUP (?)
lsym_table DQ	07fH DUP (?)
gsym	DQ	01H DUP (?)
lsym	DQ	01H DUP (?)
SymCount DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$localtime DD imagerel localtime
	DD	imagerel localtime+47
	DD	imagerel $unwind$localtime
pdata	ENDS
pdata	SEGMENT
$pdata$time DD	imagerel time
	DD	imagerel time+47
	DD	imagerel $unwind$time
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$SymAlloc DD imagerel $LN6
	DD	imagerel $LN6+275
	DD	imagerel $unwind$SymAlloc
$pdata$SymFree DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$SymFree
$pdata$SymCreate DD imagerel $LN4
	DD	imagerel $LN4+119
	DD	imagerel $unwind$SymCreate
$pdata$SymLCreate DD imagerel $LN4
	DD	imagerel $LN4+124
	DD	imagerel $unwind$SymLCreate
$pdata$SymAddGlobal DD imagerel $LN4
	DD	imagerel $LN4+124
	DD	imagerel $unwind$SymAddGlobal
$pdata$SymAddLocal DD imagerel $LN4
	DD	imagerel $LN4+209
	DD	imagerel $unwind$SymAddLocal
$pdata$SymLookup DD imagerel $LN6
	DD	imagerel $LN6+215
	DD	imagerel $unwind$SymLookup
$pdata$SymLookupLocal DD imagerel $LN6
	DD	imagerel $LN6+337
	DD	imagerel $unwind$SymLookupLocal
$pdata$SymFind DD imagerel $LN12
	DD	imagerel $LN12+489
	DD	imagerel $unwind$SymFind
$pdata$SymInit DD imagerel $LN28
	DD	imagerel $LN28+1105
	DD	imagerel $unwind$SymInit
$pdata$SymFini DD imagerel $LN19
	DD	imagerel $LN19+330
	DD	imagerel $unwind$SymFini
$pdata$SymPassInit DD imagerel $LN12
	DD	imagerel $LN12+168
	DD	imagerel $unwind$SymPassInit
$pdata$SymMakeAllSymbolsPublic DD imagerel $LN10
	DD	imagerel $LN10+274
	DD	imagerel $unwind$SymMakeAllSymbolsPublic
$pdata$SymGetAll DD imagerel $LN9
	DD	imagerel $LN9+144
	DD	imagerel $unwind$SymGetAll
$pdata$SymEnum DD imagerel $LN7
	DD	imagerel $LN7+139
	DD	imagerel $unwind$SymEnum
$pdata$SymGetCount DD imagerel $LN3
	DD	imagerel $LN3+10
	DD	imagerel $unwind$SymGetCount
$pdata$SymSetCmpFunc DD imagerel $LN5
	DD	imagerel $LN5+76
	DD	imagerel $unwind$SymSetCmpFunc
$pdata$SymClearLocal DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$SymClearLocal
$pdata$SymSetLocal DD imagerel $LN6
	DD	imagerel $LN6+165
	DD	imagerel $unwind$SymSetLocal
$pdata$SymGetLocal DD imagerel $LN7
	DD	imagerel $LN7+149
	DD	imagerel $unwind$SymGetLocal
$pdata$hashpjw DD imagerel hashpjw
	DD	imagerel hashpjw+140
	DD	imagerel $unwind$hashpjw
$pdata$free_ext DD imagerel free_ext
	DD	imagerel free_ext+468
	DD	imagerel $unwind$free_ext
$pdata$DumpSymbols DD imagerel DumpSymbols
	DD	imagerel DumpSymbols+458
	DD	imagerel $unwind$DumpSymbols
$pdata$DumpSymbol DD imagerel DumpSymbol
	DD	imagerel DumpSymbol+888
	DD	imagerel $unwind$DumpSymbol
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
SymInit$rtcName$0 DB 073H
	DB	079H
	DB	06dH
	DB	00H
	ORG $+4
SymInit$rtcName$1 DB 074H
	DB	069H
	DB	06dH
	DB	065H
	DB	05fH
	DB	06fH
	DB	066H
	DB	05fH
	DB	064H
	DB	061H
	DB	079H
	DB	00H
	ORG $+12
SymInit$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:SymInit$rtcName$1
	ORG $+48
SymInit$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:SymInit$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
printf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
printf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:printf$rtcName$0
	ORG $+48
printf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:printf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
xdata	SEGMENT
$unwind$time DD	021e01H
	DD	07006320aH
$unwind$SymAlloc DD 021e01H
	DD	07006520aH
$unwind$SymFree DD 021e01H
	DD	07006320aH
$unwind$SymCreate DD 021e01H
	DD	07006520aH
$unwind$SymLCreate DD 021e01H
	DD	07006520aH
$unwind$SymAddGlobal DD 021e01H
	DD	07006320aH
$unwind$SymAddLocal DD 022301H
	DD	0700b520fH
$unwind$SymLookup DD 021e01H
	DD	07006520aH
$unwind$SymLookupLocal DD 021e01H
	DD	07006520aH
$unwind$SymFind DD 021e01H
	DD	07006720aH
$unwind$SymInit DD 021501H
	DD	07002d206H
$unwind$SymFini DD 021501H
	DD	070029206H
$unwind$SymPassInit DD 021c01H
	DD	070051209H
$unwind$SymMakeAllSymbolsPublic DD 021501H
	DD	070025206H
$unwind$SymGetAll DD 021e01H
	DD	07006120aH
$unwind$SymEnum DD 010b01H
	DD	0700bH
$unwind$SymGetCount DD 010201H
	DD	07002H
$unwind$SymSetCmpFunc DD 021501H
	DD	070021206H
$unwind$SymClearLocal DD 021501H
	DD	070023206H
$unwind$SymSetLocal DD 021e01H
	DD	07006520aH
$unwind$SymGetLocal DD 021e01H
	DD	07006120aH
$unwind$hashpjw DD 021e01H
	DD	07006120aH
$unwind$free_ext DD 021e01H
	DD	07006520aH
$unwind$DumpSymbols DD 021501H
	DD	07002b206H
$unwind$DumpSymbol DD 022101H
	DD	07006d20aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$localtime DD 021e01H
	DD	07006320aH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
dir$ = 64
type$ = 72
value$ = 80
tv67 = 88
tv133 = 92
tv151 = 96
sym$ = 128
DumpSymbol PROC

; 736  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+128]

; 737  :     struct dsym *dir = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR dir$[rsp], rax

; 738  :     char        *type;
; 739  :     uint_64     value = sym->uvalue;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	QWORD PTR value$[rsp], rax

; 740  :     //const char  *langtype;
; 741  : 
; 742  :     switch( sym->state ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv67[rsp], eax
	cmp	DWORD PTR tv67[rsp], 10
	ja	$LN38@DumpSymbol
	movsxd	rax, DWORD PTR tv67[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN42@DumpSymbol[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN6@DumpSymbol:

; 743  :     case SYM_UNDEFINED:
; 744  :         type = "Undefined";

	lea	rax, OFFSET FLAT:$SG11301
	mov	QWORD PTR type$[rsp], rax

; 745  :         break;

	jmp	$LN2@DumpSymbol
$LN7@DumpSymbol:

; 746  :     case SYM_INTERNAL:
; 747  :         if ( sym->isproc )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@DumpSymbol

; 748  :             type = "Procedure";

	lea	rax, OFFSET FLAT:$SG11305
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN9@DumpSymbol
$LN8@DumpSymbol:

; 749  :         //else if ( sym->mem_type == MT_ABS )
; 750  :         else if ( sym->segment == NULL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN10@DumpSymbol

; 751  :             type = "Number";

	lea	rax, OFFSET FLAT:$SG11308
	mov	QWORD PTR type$[rsp], rax

; 752  :             value += ((uint_64)(uint_32)sym->value3264) << 32;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+56]
	shl	rax, 32					; 00000020H
	mov	rcx, QWORD PTR value$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR value$[rsp], rax
	jmp	SHORT $LN11@DumpSymbol
$LN10@DumpSymbol:

; 753  :         } else if ( sym->mem_type == MT_NEAR || sym->mem_type == MT_FAR )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 129			; 00000081H
	je	SHORT $LN14@DumpSymbol
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN12@DumpSymbol
$LN14@DumpSymbol:

; 754  :             type = "Code Label";

	lea	rax, OFFSET FLAT:$SG11312
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN13@DumpSymbol
$LN12@DumpSymbol:

; 755  :         else
; 756  :             type = "Data Label";

	lea	rax, OFFSET FLAT:$SG11313
	mov	QWORD PTR type$[rsp], rax
$LN13@DumpSymbol:
$LN11@DumpSymbol:
$LN9@DumpSymbol:

; 757  :         break;

	jmp	$LN2@DumpSymbol
$LN15@DumpSymbol:

; 758  :     case SYM_EXTERNAL:
; 759  :         if ( sym->isproc )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@DumpSymbol

; 760  :             type = "Proto";

	lea	rax, OFFSET FLAT:$SG11317
	mov	QWORD PTR type$[rsp], rax
	jmp	$LN17@DumpSymbol
$LN16@DumpSymbol:

; 761  :         else if ( sym->iscomm )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@DumpSymbol

; 762  :             type = "Communal";

	lea	rax, OFFSET FLAT:$SG11320
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN19@DumpSymbol
$LN18@DumpSymbol:

; 763  :         else if ( sym->mem_type == MT_EMPTY )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 192			; 000000c0H
	jne	SHORT $LN20@DumpSymbol

; 764  :             type = "Number (ext)";

	lea	rax, OFFSET FLAT:$SG11323
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN21@DumpSymbol
$LN20@DumpSymbol:

; 765  :         else if ( sym->mem_type == MT_NEAR || sym->mem_type == MT_FAR )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 129			; 00000081H
	je	SHORT $LN24@DumpSymbol
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN22@DumpSymbol
$LN24@DumpSymbol:

; 766  :             type = "Code (ext)";

	lea	rax, OFFSET FLAT:$SG11327
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN23@DumpSymbol
$LN22@DumpSymbol:

; 767  :         else
; 768  :             type = "Data (ext)";

	lea	rax, OFFSET FLAT:$SG11328
	mov	QWORD PTR type$[rsp], rax
$LN23@DumpSymbol:
$LN21@DumpSymbol:
$LN19@DumpSymbol:
$LN17@DumpSymbol:

; 769  :         break;

	jmp	$LN2@DumpSymbol
$LN25@DumpSymbol:

; 770  :     case SYM_SEG:
; 771  :         type = "Segment";

	lea	rax, OFFSET FLAT:$SG11330
	mov	QWORD PTR type$[rsp], rax

; 772  :         break;

	jmp	$LN2@DumpSymbol
$LN26@DumpSymbol:

; 773  :     case SYM_GRP:
; 774  :         type = "Group";

	lea	rax, OFFSET FLAT:$SG11332
	mov	QWORD PTR type$[rsp], rax

; 775  :         break;

	jmp	$LN2@DumpSymbol
$LN27@DumpSymbol:

; 776  :     case SYM_STACK: /* should never be found in global table */
; 777  :         type = "Stack Var";

	lea	rax, OFFSET FLAT:$SG11334
	mov	QWORD PTR type$[rsp], rax

; 778  :         break;

	jmp	$LN2@DumpSymbol
$LN28@DumpSymbol:

; 779  :     case SYM_STRUCT_FIELD: /* record bitfields are in global namespace! */
; 780  :         type = "Struct Field";

	lea	rax, OFFSET FLAT:$SG11336
	mov	QWORD PTR type$[rsp], rax

; 781  :         break;

	jmp	$LN2@DumpSymbol
$LN29@DumpSymbol:

; 782  :     case SYM_TYPE:
; 783  :         switch ( sym->typekind ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	mov	BYTE PTR tv133[rsp], al
	cmp	BYTE PTR tv133[rsp], 1
	je	SHORT $LN30@DumpSymbol
	cmp	BYTE PTR tv133[rsp], 2
	je	SHORT $LN31@DumpSymbol
	cmp	BYTE PTR tv133[rsp], 3
	je	SHORT $LN32@DumpSymbol
	cmp	BYTE PTR tv133[rsp], 4
	je	SHORT $LN33@DumpSymbol
	jmp	SHORT $LN34@DumpSymbol
$LN30@DumpSymbol:

; 784  :         case TYPE_STRUCT:  type = "Structure"; break;

	lea	rax, OFFSET FLAT:$SG11339
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN4@DumpSymbol
$LN31@DumpSymbol:

; 785  :         case TYPE_UNION:   type = "Union";     break;

	lea	rax, OFFSET FLAT:$SG11341
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN4@DumpSymbol
$LN32@DumpSymbol:

; 786  :         case TYPE_TYPEDEF: type = "Typedef";   break;

	lea	rax, OFFSET FLAT:$SG11343
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN4@DumpSymbol
$LN33@DumpSymbol:

; 787  :         case TYPE_RECORD:  type = "Record";    break;

	lea	rax, OFFSET FLAT:$SG11345
	mov	QWORD PTR type$[rsp], rax
	jmp	SHORT $LN4@DumpSymbol
$LN34@DumpSymbol:

; 788  :         default:           type = "Undef Type";break;

	lea	rax, OFFSET FLAT:$SG11347
	mov	QWORD PTR type$[rsp], rax
$LN4@DumpSymbol:

; 789  :         }
; 790  :         break;

	jmp	SHORT $LN2@DumpSymbol
$LN35@DumpSymbol:

; 791  :     case SYM_ALIAS:
; 792  :         type = "Alias";

	lea	rax, OFFSET FLAT:$SG11349
	mov	QWORD PTR type$[rsp], rax

; 793  :         break;

	jmp	SHORT $LN2@DumpSymbol
$LN36@DumpSymbol:

; 794  :     case SYM_MACRO:
; 795  :         type = "Macro";

	lea	rax, OFFSET FLAT:$SG11351
	mov	QWORD PTR type$[rsp], rax

; 796  :         break;

	jmp	SHORT $LN2@DumpSymbol
$LN37@DumpSymbol:

; 797  :     case SYM_TMACRO:
; 798  :         type = "Text";

	lea	rax, OFFSET FLAT:$SG11353
	mov	QWORD PTR type$[rsp], rax

; 799  :         break;

	jmp	SHORT $LN2@DumpSymbol
$LN38@DumpSymbol:

; 800  :     //case SYM_CLASS_LNAME: /* never stored in global or local table */
; 801  :     //    type = "CLASS";
; 802  :     //    break;
; 803  :     default:
; 804  :         type = "Unknown";

	lea	rax, OFFSET FLAT:$SG11355
	mov	QWORD PTR type$[rsp], rax
$LN2@DumpSymbol:

; 805  :         break;
; 806  :     }
; 807  :     printf( "%-12s  %16" I64_SPEC "X %02X %8p %c %8p %s\n", type, value, sym->mem_type, dir->e, sym->ispublic ? 'X' : ' ', sym->name, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN40@DumpSymbol
	mov	DWORD PTR tv151[rsp], 88		; 00000058H
	jmp	SHORT $LN41@DumpSymbol
$LN40@DumpSymbol:
	mov	DWORD PTR tv151[rsp], 32		; 00000020H
$LN41@DumpSymbol:
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR tv151[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+36]
	mov	r8, QWORD PTR value$[rsp]
	mov	rdx, QWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:$SG11356
	call	printf

; 808  : }

	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
	npad	1
$LN42@DumpSymbol:
	DD	$LN6@DumpSymbol
	DD	$LN7@DumpSymbol
	DD	$LN15@DumpSymbol
	DD	$LN25@DumpSymbol
	DD	$LN26@DumpSymbol
	DD	$LN27@DumpSymbol
	DD	$LN28@DumpSymbol
	DD	$LN29@DumpSymbol
	DD	$LN35@DumpSymbol
	DD	$LN36@DumpSymbol
	DD	$LN37@DumpSymbol
DumpSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 48
i$ = 56
count$ = 60
max$ = 64
num0$ = 68
num1$ = 72
num5$ = 76
num10$ = 80
curr$ = 84
DumpSymbols PROC

; 812  : {

	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rdi, rsp
	mov	ecx, 24
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 813  :     struct asym         *sym;
; 814  :     unsigned            i;
; 815  :     unsigned            count = 0;

	mov	DWORD PTR count$[rsp], 0

; 816  :     unsigned            max = 0;

	mov	DWORD PTR max$[rsp], 0

; 817  :     unsigned            num0 = 0;

	mov	DWORD PTR num0$[rsp], 0

; 818  :     unsigned            num1 = 0;

	mov	DWORD PTR num1$[rsp], 0

; 819  :     unsigned            num5 = 0;

	mov	DWORD PTR num5$[rsp], 0

; 820  :     unsigned            num10 = 0;

	mov	DWORD PTR num10$[rsp], 0

; 821  :     unsigned            curr = 0;

	mov	DWORD PTR curr$[rsp], 0

; 822  : 
; 823  :     DebugMsg(("DumpSymbols enter\n"));

	lea	rcx, OFFSET FLAT:$SG11374
	call	DoDebugMsg

; 824  :     if ( Options.dump_symbols ) {

	movzx	eax, BYTE PTR Options+26
	test	eax, eax
	je	SHORT $LN8@DumpSymbol

; 825  :         printf( "   # Addr     Type                     Value MT    Ext   P  pName   Name\n" );

	lea	rcx, OFFSET FLAT:$SG11376
	call	printf

; 826  :         printf( "--------------------------------------------------------------------------------\n" );

	lea	rcx, OFFSET FLAT:$SG11377
	call	printf
$LN8@DumpSymbol:

; 827  :     }
; 828  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@DumpSymbol
$LN2@DumpSymbol:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@DumpSymbol:
	cmp	DWORD PTR i$[rsp], 8009			; 00001f49H
	jae	$LN3@DumpSymbol

; 829  :         for( sym = gsym_table[i], curr = 0; sym; sym = sym->nextitem ) {

	mov	eax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:gsym_table
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR sym$[rsp], rax
	mov	DWORD PTR curr$[rsp], 0
	jmp	SHORT $LN7@DumpSymbol
$LN5@DumpSymbol:
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sym$[rsp], rax
$LN7@DumpSymbol:
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN6@DumpSymbol

; 830  :             curr++;

	mov	eax, DWORD PTR curr$[rsp]
	inc	eax
	mov	DWORD PTR curr$[rsp], eax

; 831  :             if ( Options.dump_symbols ) {

	movzx	eax, BYTE PTR Options+26
	test	eax, eax
	je	SHORT $LN9@DumpSymbol

; 832  :                 printf("%4u %8p ", i, sym );

	mov	r8, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11379
	call	printf

; 833  :                 DumpSymbol( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	DumpSymbol
$LN9@DumpSymbol:

; 834  :             }
; 835  :         }

	jmp	SHORT $LN5@DumpSymbol
$LN6@DumpSymbol:

; 836  :         count += curr;

	mov	eax, DWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR count$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR count$[rsp], eax

; 837  :         if ( curr == 0 )

	cmp	DWORD PTR curr$[rsp], 0
	jne	SHORT $LN10@DumpSymbol

; 838  :             num0++;

	mov	eax, DWORD PTR num0$[rsp]
	inc	eax
	mov	DWORD PTR num0$[rsp], eax
	jmp	SHORT $LN11@DumpSymbol
$LN10@DumpSymbol:

; 839  :         else if ( curr == 1 )

	cmp	DWORD PTR curr$[rsp], 1
	jne	SHORT $LN12@DumpSymbol

; 840  :             num1++;

	mov	eax, DWORD PTR num1$[rsp]
	inc	eax
	mov	DWORD PTR num1$[rsp], eax
	jmp	SHORT $LN13@DumpSymbol
$LN12@DumpSymbol:

; 841  :         else if ( curr <= 5 )

	cmp	DWORD PTR curr$[rsp], 5
	ja	SHORT $LN14@DumpSymbol

; 842  :             num5++;

	mov	eax, DWORD PTR num5$[rsp]
	inc	eax
	mov	DWORD PTR num5$[rsp], eax
	jmp	SHORT $LN15@DumpSymbol
$LN14@DumpSymbol:

; 843  :         else if ( curr <= 10 )

	cmp	DWORD PTR curr$[rsp], 10
	ja	SHORT $LN16@DumpSymbol

; 844  :             num10++;

	mov	eax, DWORD PTR num10$[rsp]
	inc	eax
	mov	DWORD PTR num10$[rsp], eax
$LN16@DumpSymbol:
$LN15@DumpSymbol:
$LN13@DumpSymbol:
$LN11@DumpSymbol:

; 845  :         if ( max < curr )

	mov	eax, DWORD PTR curr$[rsp]
	cmp	DWORD PTR max$[rsp], eax
	jae	SHORT $LN17@DumpSymbol

; 846  :             max = curr;

	mov	eax, DWORD PTR curr$[rsp]
	mov	DWORD PTR max$[rsp], eax
$LN17@DumpSymbol:

; 847  :     }

	jmp	$LN2@DumpSymbol
$LN3@DumpSymbol:

; 848  :     if ( Options.quiet == FALSE ) {

	movzx	eax, BYTE PTR Options
	test	eax, eax
	jne	SHORT $LN18@DumpSymbol

; 849  :         printf( "%u items in symbol table, expected %u\n", count, SymCount );

	mov	r8d, DWORD PTR SymCount
	mov	edx, DWORD PTR count$[rsp]
	lea	rcx, OFFSET FLAT:$SG11389
	call	printf

; 850  :         printf( "max items in a line=%u, lines with 0/1/<=5/<=10 items=%u/%u/%u/%u, \n", max, num0, num1, num5, num10 );

	mov	eax, DWORD PTR num10$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR num5$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR num1$[rsp]
	mov	r8d, DWORD PTR num0$[rsp]
	mov	edx, DWORD PTR max$[rsp]
	lea	rcx, OFFSET FLAT:$SG11390
	call	printf
$LN18@DumpSymbol:

; 851  :     }
; 852  : }

	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
DumpSymbols ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
tv71 = 32
sym$ = 64
free_ext PROC

; 360  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 361  :     DebugMsg(("free_ext: item=%p name=%s state=%u\n", sym, sym->name, sym->state ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+32]
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR sym$[rsp]
	lea	rcx, OFFSET FLAT:$SG11141
	call	DoDebugMsg

; 362  :     switch( sym->state ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv71[rsp], eax
	mov	eax, DWORD PTR tv71[rsp]
	dec	eax
	mov	DWORD PTR tv71[rsp], eax
	cmp	DWORD PTR tv71[rsp], 9
	ja	$LN2@free_ext
	movsxd	rax, DWORD PTR tv71[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN19@free_ext[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@free_ext:

; 363  :     case SYM_INTERNAL:
; 364  :         if ( sym->isproc )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@free_ext

; 365  :             DeleteProc( (struct dsym *)sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	DeleteProc
$LN5@free_ext:

; 366  :         break;

	jmp	$LN2@free_ext
$LN6@free_ext:

; 367  :     case SYM_EXTERNAL:
; 368  :         if ( sym->isproc )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@free_ext

; 369  :             DeleteProc( (struct dsym *)sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	DeleteProc
$LN7@free_ext:

; 370  :         sym->first_size = 0;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+44], 0

; 371  :         /* The altname field may contain a symbol (if weak == FALSE).
; 372  :          * However, this is an independant item and must not be released here
; 373  :          */
; 374  : #ifdef DEBUG_OUT /* to be removed, this can't happen anymore. */
; 375  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN8@free_ext
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN8@free_ext

; 376  :             DebugMsg(( "free_ext: external with private type: %s\n", sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11147
	call	DoDebugMsg

; 377  :             SymFree( sym->type );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	SymFree
$LN8@free_ext:

; 378  :         }
; 379  : #endif
; 380  :         break;

	jmp	$LN2@free_ext
$LN9@free_ext:

; 381  :     case SYM_SEG:
; 382  :         if ( ((struct dsym *)sym)->e.seginfo->internal )

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	shr	al, 4
	and	al, 1
	movzx	eax, al

; 383  :             LclFree( ((struct dsym *)sym)->e.seginfo->CodeBuffer );
; 384  :         LclFree( ((struct dsym *)sym)->e.seginfo );
; 385  :         break;

	jmp	SHORT $LN2@free_ext
$LN11@free_ext:

; 386  :     case SYM_GRP:
; 387  :         DeleteGroup( (struct dsym *)sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	DeleteGroup

; 388  :         break;

	jmp	SHORT $LN2@free_ext
$LN12@free_ext:

; 389  :     case SYM_TYPE:
; 390  :         DeleteType( (struct dsym *)sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	DeleteType

; 391  :         break;

	jmp	SHORT $LN2@free_ext
$LN13@free_ext:

; 392  :     case SYM_MACRO:
; 393  :         ReleaseMacroData( (struct dsym *)sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	ReleaseMacroData

; 394  :         LclFree( ((struct dsym *)sym)->e.macroinfo );
; 395  :         break;

	jmp	SHORT $LN2@free_ext
$LN14@free_ext:

; 396  :     case SYM_TMACRO:
; 397  :         if ( sym->predefined == FALSE )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al

; 398  :             LclFree( sym->string_ptr );
; 399  :         break;

	jmp	SHORT $LN2@free_ext
$LN16@free_ext:

; 400  : #ifdef DEBUG_OUT 
; 401  :     case SYM_STACK:
; 402  :         /* to be removed, this can't happen anymore. */
; 403  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) { 

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN17@free_ext
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN17@free_ext

; 404  :             DebugMsg(( "free_ext: case SYM_STACK, sym=%s with private type\n", sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11157
	call	DoDebugMsg

; 405  :             /* symbol has a "private" type */
; 406  :             SymFree( sym->type );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	SymFree
$LN17@free_ext:
$LN2@free_ext:

; 407  :         }
; 408  :         break;
; 409  : #endif
; 410  :     }
; 411  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN19@free_ext:
	DD	$LN4@free_ext
	DD	$LN6@free_ext
	DD	$LN9@free_ext
	DD	$LN11@free_ext
	DD	$LN16@free_ext
	DD	$LN2@free_ext
	DD	$LN12@free_ext
	DD	$LN2@free_ext
	DD	$LN13@free_ext
	DD	$LN14@free_ext
free_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
h$ = 0
g$ = 4
s$ = 32
hashpjw	PROC

; 149  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 150  :     unsigned h;
; 151  :     unsigned g;
; 152  : 
; 153  : #if HASH_MAGNITUDE==12
; 154  :     for( h = 0; *s; ++s ) {
; 155  :         h = (h << 4) + (*s | ' ');
; 156  :         g = h & ~0x0fff;
; 157  :         h ^= g;
; 158  :         h ^= g >> 12;
; 159  :     }
; 160  : #else
; 161  :     for( h = 0; *s; ++s ) {

	mov	DWORD PTR h$[rsp], 0
	jmp	SHORT $LN4@hashpjw
$LN2@hashpjw:
	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR s$[rsp], rax
$LN4@hashpjw:
	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@hashpjw

; 162  :         h = (h << 5) + (*s | ' ');

	mov	eax, DWORD PTR h$[rsp]
	shl	eax, 5
	mov	rcx, QWORD PTR s$[rsp]
	movsx	ecx, BYTE PTR [rcx]
	or	ecx, 32					; 00000020H
	add	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 163  :         g = h & ~0x7fff;

	mov	eax, DWORD PTR h$[rsp]
	and	eax, -32768				; ffff8000H
	mov	DWORD PTR g$[rsp], eax

; 164  :         h ^= g;

	mov	eax, DWORD PTR g$[rsp]
	mov	ecx, DWORD PTR h$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 165  :         h ^= g >> 15;

	mov	eax, DWORD PTR g$[rsp]
	shr	eax, 15
	mov	ecx, DWORD PTR h$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 166  :     }

	jmp	SHORT $LN2@hashpjw
$LN3@hashpjw:

; 167  : #endif
; 168  :     return( h );

	mov	eax, DWORD PTR h$[rsp]

; 169  : }

	add	rsp, 16
	pop	rdi
	ret	0
hashpjw	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
i$ = 0
l$ = 8
proc$ = 32
SymGetLocal PROC

; 191  : {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 192  :     int i;
; 193  :     struct dsym  **l = &((struct dsym *)proc)->e.procinfo->labellist;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	add	rax, 24
	mov	QWORD PTR l$[rsp], rax

; 194  : 
; 195  :     for ( i = 0; i < LHASH_TABLE_SIZE; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@SymGetLoca
$LN2@SymGetLoca:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SymGetLoca:
	cmp	DWORD PTR i$[rsp], 127			; 0000007fH
	jge	SHORT $LN3@SymGetLoca

; 196  :         if ( lsym_table[i] ) {

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:lsym_table
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN5@SymGetLoca

; 197  :             *l = (struct dsym *)lsym_table[i];

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:lsym_table
	mov	rdx, QWORD PTR l$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR [rdx], rax

; 198  :             l = &(*l)->e.nextll;

	mov	rax, QWORD PTR l$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 96					; 00000060H
	mov	QWORD PTR l$[rsp], rax
$LN5@SymGetLoca:

; 199  :         }
; 200  :     }

	jmp	SHORT $LN2@SymGetLoca
$LN3@SymGetLoca:

; 201  :     *l = NULL;

	mov	rax, QWORD PTR l$[rsp]
	mov	QWORD PTR [rax], 0

; 202  : 
; 203  :     return;
; 204  : }

	add	rsp, 16
	pop	rdi
	ret	0
SymGetLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
i$ = 32
l$ = 40
proc$ = 64
SymSetLocal PROC

; 214  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 215  :     int i;
; 216  :     struct dsym *l;
; 217  : 
; 218  :     SymClearLocal();

	call	SymClearLocal

; 219  :     for ( l = ((struct dsym *)proc)->e.procinfo->labellist; l; l = l->e.nextll ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR l$[rsp], rax
	jmp	SHORT $LN4@SymSetLoca
$LN2@SymSetLoca:
	mov	rax, QWORD PTR l$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR l$[rsp], rax
$LN4@SymSetLoca:
	cmp	QWORD PTR l$[rsp], 0
	je	SHORT $LN3@SymSetLoca

; 220  :         DebugMsg1(("SymSetLocal(%s): label=%s\n", proc->name, l->sym.name ));

	mov	rax, QWORD PTR l$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11079
	call	DoDebugMsg1

; 221  :         i = hashpjw( l->sym.name ) % LHASH_TABLE_SIZE;

	mov	rax, QWORD PTR l$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	hashpjw
	xor	edx, edx
	mov	ecx, 127				; 0000007fH
	div	ecx
	mov	eax, edx
	mov	DWORD PTR i$[rsp], eax

; 222  :         lsym_table[i] = &l->sym;

	mov	rax, QWORD PTR l$[rsp]
	movsxd	rcx, DWORD PTR i$[rsp]
	lea	rdx, OFFSET FLAT:lsym_table
	mov	QWORD PTR [rdx+rcx*8], rax

; 223  :     }

	jmp	SHORT $LN2@SymSetLoca
$LN3@SymSetLoca:

; 224  :     return;
; 225  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SymSetLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
SymClearLocal PROC

; 182  : {

$LN3:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 183  :     memset( &lsym_table, 0, sizeof( lsym_table ) );

	mov	r8d, 1016				; 000003f8H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:lsym_table
	call	memset

; 184  :     return;
; 185  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SymClearLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
tv66 = 0
SymSetCmpFunc PROC

; 173  : {

$LN5:
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 174  :     SymCmpFunc = ( ModuleInfo.case_sensitive == TRUE ? memcmp : (StrCmpFunc)_memicmp );

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN3@SymSetCmpF
	lea	rax, OFFSET FLAT:memcmp
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN4@SymSetCmpF
$LN3@SymSetCmpF:
	mov	rax, QWORD PTR __imp__memicmp
	mov	QWORD PTR tv66[rsp], rax
$LN4@SymSetCmpF:
	mov	rax, QWORD PTR tv66[rsp]
	mov	QWORD PTR SymCmpFunc, rax

; 175  :     return;
; 176  : }

	add	rsp, 16
	pop	rdi
	ret	0
SymSetCmpFunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
SymGetCount PROC

; 689  : {

$LN3:
	push	rdi

; 690  :     return( SymCount );

	mov	eax, DWORD PTR SymCount

; 691  : }

	pop	rdi
	ret	0
SymGetCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 16
pi$ = 24
SymEnum	PROC

; 716  : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 717  :     if ( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN4@SymEnum

; 718  :         *pi = 0;

	mov	rax, QWORD PTR pi$[rsp]
	mov	DWORD PTR [rax], 0

; 719  :         sym = gsym_table[*pi];

	mov	rax, QWORD PTR pi$[rsp]
	movsxd	rax, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:gsym_table
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR sym$[rsp], rax

; 720  :     } else {

	jmp	SHORT $LN5@SymEnum
$LN4@SymEnum:

; 721  :         sym = sym->nextitem;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sym$[rsp], rax
$LN5@SymEnum:
$LN2@SymEnum:

; 722  :     }
; 723  : 
; 724  :     /* v2.10: changed from for() to while() */
; 725  :     while( sym == NULL && *pi < GHASH_TABLE_SIZE - 1 )

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN3@SymEnum
	mov	rax, QWORD PTR pi$[rsp]
	cmp	DWORD PTR [rax], 8008			; 00001f48H
	jge	SHORT $LN3@SymEnum

; 726  :         sym = gsym_table[++(*pi)];

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR pi$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR pi$[rsp]
	movsxd	rax, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:gsym_table
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR sym$[rsp], rax
	jmp	SHORT $LN2@SymEnum
$LN3@SymEnum:

; 727  : 
; 728  :     //printf("sym=%X, i=%u\n", sym, *pi );
; 729  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]

; 730  : }

	pop	rdi
	ret	0
SymEnum	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 0
i$ = 8
j$ = 12
syms$ = 32
SymGetAll PROC

; 697  : {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 698  :     struct asym         *sym;
; 699  :     unsigned            i, j;
; 700  : 
; 701  :     /* copy symbols to table */
; 702  :     for( i = j = 0; i < GHASH_TABLE_SIZE; i++ ) {

	mov	DWORD PTR j$[rsp], 0
	mov	eax, DWORD PTR j$[rsp]
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN4@SymGetAll
$LN2@SymGetAll:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SymGetAll:
	cmp	DWORD PTR i$[rsp], 8009			; 00001f49H
	jae	SHORT $LN3@SymGetAll

; 703  :         for( sym = gsym_table[i]; sym; sym = sym->nextitem ) {

	mov	eax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:gsym_table
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR sym$[rsp], rax
	jmp	SHORT $LN7@SymGetAll
$LN5@SymGetAll:
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sym$[rsp], rax
$LN7@SymGetAll:
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN6@SymGetAll

; 704  :             syms[j++] = sym;

	mov	eax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR syms$[rsp]
	mov	rdx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax

; 705  :         }

	jmp	SHORT $LN5@SymGetAll
$LN6@SymGetAll:

; 706  :     }

	jmp	SHORT $LN2@SymGetAll
$LN3@SymGetAll:

; 707  :     return;
; 708  : }

	add	rsp, 16
	pop	rdi
	ret	0
SymGetAll ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
i$ = 32
sym$ = 40
SymMakeAllSymbolsPublic PROC

; 523  : {

$LN10:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 524  :     int i;
; 525  :     struct asym  *sym;
; 526  : 
; 527  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@SymMakeAll
$LN2@SymMakeAll:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SymMakeAll:
	cmp	DWORD PTR i$[rsp], 8009			; 00001f49H
	jge	$LN3@SymMakeAll

; 528  :         for( sym = gsym_table[i]; sym; sym = sym->nextitem ) {

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:gsym_table
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR sym$[rsp], rax
	jmp	SHORT $LN7@SymMakeAll
$LN5@SymMakeAll:
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sym$[rsp], rax
$LN7@SymMakeAll:
	cmp	QWORD PTR sym$[rsp], 0
	je	$LN6@SymMakeAll

; 529  :             if ( sym->state == SYM_INTERNAL &&
; 530  :                 /* v2.07: MT_ABS is obsolete */
; 531  :                 //sym->mem_type != MT_ABS &&  /* no EQU or '=' constants */
; 532  :                 sym->isequate == FALSE &&     /* no EQU or '=' constants */
; 533  :                 sym->predefined == FALSE && /* no predefined symbols ($) */
; 534  :                 sym->included == FALSE && /* v2.09: symbol already added to public queue? */
; 535  :                 //sym->scoped == FALSE && /* v2.09: no procs that are marked as "private" */
; 536  :                 sym->name[1] != '&' && /* v2.10: no @@ code labels */

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	$LN8@SymMakeAll
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@SymMakeAll
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@SymMakeAll
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@SymMakeAll
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN8@SymMakeAll
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@SymMakeAll

; 537  :                 sym->ispublic == FALSE ) {
; 538  :                 sym->ispublic = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 539  :                 AddPublicData( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	AddPublicData
$LN8@SymMakeAll:

; 540  :             }
; 541  :         }

	jmp	$LN5@SymMakeAll
$LN6@SymMakeAll:

; 542  :     }

	jmp	$LN2@SymMakeAll
$LN3@SymMakeAll:

; 543  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SymMakeAllSymbolsPublic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
i$ = 0
sym$1 = 8
pass$ = 32
SymPassInit PROC

; 653  : {

$LN12:
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+32]

; 654  :     unsigned            i;
; 655  : 
; 656  :     if ( pass == PASS_1 )

	cmp	DWORD PTR pass$[rsp], 0
	jne	SHORT $LN8@SymPassIni

; 657  :         return;

	jmp	SHORT $LN1@SymPassIni
$LN8@SymPassIni:

; 658  : 
; 659  : #if FASTPASS
; 660  :     /* No need to reset the "defined" flag if FASTPASS is on.
; 661  :      * Because then the source lines will come from the line store,
; 662  :      * where inactive conditional lines are NOT contained.
; 663  :      */
; 664  :     if ( UseSavedState )

	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	je	SHORT $LN9@SymPassIni

; 665  :         return;

	jmp	SHORT $LN1@SymPassIni
$LN9@SymPassIni:

; 666  : #endif
; 667  :     /* mark as "undefined":
; 668  :      * - SYM_INTERNAL - internals
; 669  :      * - SYM_MACRO - macros
; 670  :      * - SYM_TMACRO - text macros
; 671  :      */
; 672  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@SymPassIni
$LN2@SymPassIni:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SymPassIni:
	cmp	DWORD PTR i$[rsp], 8009			; 00001f49H
	jae	SHORT $LN3@SymPassIni

; 673  :         struct asym *sym;
; 674  :         for( sym = gsym_table[i]; sym; sym = sym->nextitem ) {

	mov	eax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:gsym_table
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR sym$1[rsp], rax
	jmp	SHORT $LN7@SymPassIni
$LN5@SymPassIni:
	mov	rax, QWORD PTR sym$1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sym$1[rsp], rax
$LN7@SymPassIni:
	cmp	QWORD PTR sym$1[rsp], 0
	je	SHORT $LN6@SymPassIni

; 675  :             if ( sym->predefined == FALSE ) {

	mov	rax, QWORD PTR sym$1[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@SymPassIni

; 676  :                 /* v2.04: all symbol's "defined" flag is now reset. */
; 677  :                 // if ( sym->state == SYM_TMACRO ||
; 678  :                 //    sym->state == SYM_MACRO  ||
; 679  :                 //    sym->state == SYM_INTERNAL ) {
; 680  :                     sym->isdefined = FALSE;

	mov	rax, QWORD PTR sym$1[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR sym$1[rsp]
	mov	BYTE PTR [rcx+40], al
$LN10@SymPassIni:

; 681  :                 //}
; 682  :             }
; 683  :         }

	jmp	SHORT $LN5@SymPassIni
$LN6@SymPassIni:

; 684  :     }

	jmp	SHORT $LN2@SymPassIni
$LN3@SymPassIni:
$LN1@SymPassIni:

; 685  : }

	add	rsp, 16
	pop	rdi
	ret	0
SymPassInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
i$ = 32
sym$1 = 40
sym$2 = 48
next$3 = 56
tv93 = 64
SymFini	PROC

; 551  : {

$LN19:
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 552  : #if FASTMEM==0 || defined( DEBUG_OUT )
; 553  :     unsigned i;
; 554  : #endif
; 555  : 
; 556  : #ifdef DEBUG_OUT
; 557  :     if ( Options.dump_symbols_hash ) {

	movzx	eax, BYTE PTR Options+27
	test	eax, eax
	je	$LN14@SymFini

; 558  :         for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@SymFini
$LN2@SymFini:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SymFini:
	cmp	DWORD PTR i$[rsp], 8009			; 00001f49H
	jae	SHORT $LN3@SymFini

; 559  :             struct asym  *sym = gsym_table[i];

	mov	eax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:gsym_table
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR sym$1[rsp], rax

; 560  :             if ( sym ) {

	cmp	QWORD PTR sym$1[rsp], 0
	je	SHORT $LN15@SymFini

; 561  :                 printf("%4u ", i );

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11222
	call	printf

; 562  :                 for( ; sym; sym = sym->nextitem ) {

	jmp	SHORT $LN7@SymFini
$LN5@SymFini:
	mov	rax, QWORD PTR sym$1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sym$1[rsp], rax
$LN7@SymFini:
	cmp	QWORD PTR sym$1[rsp], 0
	je	SHORT $LN6@SymFini

; 563  :                     printf("%-16s ", sym->name );

	mov	rax, QWORD PTR sym$1[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11223
	call	printf

; 564  :                 }

	jmp	SHORT $LN5@SymFini
$LN6@SymFini:

; 565  :                 printf("\n" );

	lea	rcx, OFFSET FLAT:$SG11224
	call	printf
$LN15@SymFini:

; 566  :             }
; 567  :         }

	jmp	SHORT $LN2@SymFini
$LN3@SymFini:
$LN14@SymFini:

; 568  :     }
; 569  :     DumpSymbols();

	call	DumpSymbols

; 570  : #endif
; 571  : 
; 572  : #if FASTMEM==0 || defined( DEBUG_OUT )
; 573  :     /* free the symbol table */
; 574  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN10@SymFini
$LN8@SymFini:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@SymFini:
	cmp	DWORD PTR i$[rsp], 8009			; 00001f49H
	jae	SHORT $LN9@SymFini

; 575  :         struct asym  *sym;
; 576  :         struct asym  *next;
; 577  :         for( sym = gsym_table[i]; sym; ) {

	mov	eax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:gsym_table
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR sym$2[rsp], rax
$LN11@SymFini:
	cmp	QWORD PTR sym$2[rsp], 0
	je	SHORT $LN12@SymFini

; 578  :             next = sym->nextitem;

	mov	rax, QWORD PTR sym$2[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR next$3[rsp], rax

; 579  :             SymFree( sym );

	mov	rcx, QWORD PTR sym$2[rsp]
	call	SymFree

; 580  :             SymCount--;

	mov	eax, DWORD PTR SymCount
	dec	eax
	mov	DWORD PTR SymCount, eax

; 581  :             sym = next;

	mov	rax, QWORD PTR next$3[rsp]
	mov	QWORD PTR sym$2[rsp], rax

; 582  :         }

	jmp	SHORT $LN11@SymFini
$LN12@SymFini:

; 583  :     }

	jmp	SHORT $LN8@SymFini
$LN9@SymFini:

; 584  :     /**/myassert( SymCount == 0 );

	cmp	DWORD PTR SymCount, 0
	jne	SHORT $LN17@SymFini
	mov	DWORD PTR tv93[rsp], 0
	jmp	SHORT $LN18@SymFini
$LN17@SymFini:
	mov	edx, 584				; 00000248H
	lea	rcx, OFFSET FLAT:$SG11225
	call	InternalError
	mov	DWORD PTR tv93[rsp], eax
$LN18@SymFini:

; 585  : #endif
; 586  : 
; 587  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
SymFini	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 48
i$ = 56
time_of_day$ = 72
now$ = 88
$T5 = 96
SymInit	PROC

; 593  : {

$LN28:
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T5[rsp], 0

; 594  :     struct asym *sym;
; 595  :     int i;
; 596  :     time_t    time_of_day;
; 597  :     struct tm *now;
; 598  : 
; 599  :     DebugMsg(("SymInit() enter\n"));

	lea	rcx, OFFSET FLAT:$SG11240
	call	DoDebugMsg

; 600  :     SymCount = 0;

	mov	DWORD PTR SymCount, 0

; 601  : 
; 602  :     /* v2.11: ensure CurrProc is NULL - might be a problem if multiple files are assembled */
; 603  :     CurrProc = NULL;

	mov	QWORD PTR CurrProc, 0

; 604  : 
; 605  :     memset( gsym_table, 0, sizeof(gsym_table) );

	mov	r8d, 64072				; 0000fa48H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:gsym_table
	call	memset

; 606  : 
; 607  :     time_of_day = time( NULL );

	xor	ecx, ecx
	call	time
	mov	QWORD PTR time_of_day$[rsp], rax

; 608  :     now = localtime( &time_of_day );

	lea	rcx, QWORD PTR time_of_day$[rsp]
	call	localtime
	mov	QWORD PTR now$[rsp], rax

; 609  : #if USESTRFTIME
; 610  :     strftime( szDate, 9, szDateFmt, now );
; 611  :     strftime( szTime, 9, szTimeFmt, now );
; 612  : #else
; 613  :     sprintf( szDate, "%02u/%02u/%02u", now->tm_mon + 1, now->tm_mday, now->tm_year % 100 );

	mov	rax, QWORD PTR now$[rsp]
	mov	eax, DWORD PTR [rax+20]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	eax, edx
	mov	rcx, QWORD PTR now$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	inc	ecx
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR now$[rsp]
	mov	r9d, DWORD PTR [rax+12]
	mov	r8d, ecx
	lea	rdx, OFFSET FLAT:$SG11241
	lea	rcx, OFFSET FLAT:szDate
	call	sprintf

; 614  :     sprintf( szTime, "%02u:%02u:%02u", now->tm_hour, now->tm_min, now->tm_sec );

	mov	rax, QWORD PTR now$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR now$[rsp]
	mov	r9d, DWORD PTR [rax+4]
	mov	rax, QWORD PTR now$[rsp]
	mov	r8d, DWORD PTR [rax+8]
	lea	rdx, OFFSET FLAT:$SG11242
	lea	rcx, OFFSET FLAT:szTime
	call	sprintf

; 615  : #endif
; 616  : 
; 617  :     for( i = 0; i < sizeof(tmtab) / sizeof(tmtab[0]); i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@SymInit
$LN2@SymInit:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SymInit:
	movsxd	rax, DWORD PTR i$[rsp]
	cmp	rax, 6
	jae	$LN3@SymInit

; 618  :         sym = SymCreate( tmtab[i].name );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:tmtab
	mov	rcx, QWORD PTR [rcx+rax]
	call	SymCreate
	mov	BYTE PTR $T5[rsp], 1
	mov	QWORD PTR sym$[rsp], rax

; 619  :         sym->state = SYM_TMACRO;

	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN11@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN11@SymInit:
	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+32], 10

; 620  :         sym->isdefined = TRUE;

	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN12@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN12@SymInit:
	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN13@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN13@SymInit:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 621  :         sym->predefined = TRUE;

	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN14@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN14@SymInit:
	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN15@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN15@SymInit:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 622  :         sym->string_ptr = tmtab[i].value;

	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN16@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN16@SymInit:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:tmtab
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR [rdx+16], rax

; 623  :         if ( tmtab[i].store )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:tmtab
	cmp	QWORD PTR [rcx+rax+16], 0
	je	SHORT $LN8@SymInit

; 624  :             *tmtab[i].store = sym;

	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN17@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN17@SymInit:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:tmtab
	mov	rax, QWORD PTR [rcx+rax+16]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx
$LN8@SymInit:

; 625  :     }

	jmp	$LN2@SymInit
$LN3@SymInit:

; 626  : 
; 627  :     for( i = 0; i < sizeof(eqtab) / sizeof(eqtab[0]); i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@SymInit
$LN5@SymInit:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@SymInit:
	movsxd	rax, DWORD PTR i$[rsp]
	cmp	rax, 5
	jae	$LN6@SymInit

; 628  :         sym = SymCreate( eqtab[i].name );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rcx, OFFSET FLAT:eqtab
	mov	rcx, QWORD PTR [rcx+rax]
	call	SymCreate
	mov	BYTE PTR $T5[rsp], 1
	mov	QWORD PTR sym$[rsp], rax

; 629  :         sym->state = SYM_INTERNAL;

	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN18@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN18@SymInit:
	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+32], 1

; 630  :         /* v2.07: MT_ABS is obsolete */
; 631  :         //sym->mem_type = MT_ABS;
; 632  :         sym->isdefined = TRUE;

	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN19@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN19@SymInit:
	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN20@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN20@SymInit:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 633  :         sym->predefined = TRUE;

	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN21@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN21@SymInit:
	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN22@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN22@SymInit:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 634  :         sym->offset = eqtab[i].value;

	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN23@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN23@SymInit:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rcx, OFFSET FLAT:eqtab
	mov	rdx, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rcx+rax+8]
	mov	DWORD PTR [rdx+16], eax

; 635  :         sym->sfunc_ptr = eqtab[i].sfunc_ptr;

	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN24@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN24@SymInit:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rcx, OFFSET FLAT:eqtab
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rcx+rax+16]
	mov	QWORD PTR [rdx+64], rax

; 636  :         //sym->variable = TRUE; /* if fixup must be created */
; 637  :         if ( eqtab[i].store )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rcx, OFFSET FLAT:eqtab
	cmp	QWORD PTR [rcx+rax+24], 0
	je	SHORT $LN9@SymInit

; 638  :             *eqtab[i].store = sym;

	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN25@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN25@SymInit:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rcx, OFFSET FLAT:eqtab
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx
$LN9@SymInit:

; 639  :     }

	jmp	$LN5@SymInit
$LN6@SymInit:

; 640  :     sym->list   = FALSE; /* @WordSize should not be listed */

	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN26@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN26@SymInit:
	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN27@SymInit
	lea	rcx, OFFSET FLAT:SymInit$rtcName$0
	call	_RTC_UninitUse
$LN27@SymInit:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+41], al

; 641  :     /* $ is an address (usually). Also, don't add it to the list */
; 642  :     symPC->variable = TRUE;

	mov	rax, QWORD PTR symPC
	movzx	eax, BYTE PTR [rax+40]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR symPC
	mov	BYTE PTR [rcx+40], al

; 643  :     symPC->list     = FALSE;

	mov	rax, QWORD PTR symPC
	movzx	eax, BYTE PTR [rax+41]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR symPC
	mov	BYTE PTR [rcx+41], al

; 644  :     LineCur->list   = FALSE;

	mov	rax, QWORD PTR LineCur
	movzx	eax, BYTE PTR [rax+41]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR LineCur
	mov	BYTE PTR [rcx+41], al

; 645  : 
; 646  :     DebugMsg(("SymInit() exit\n"));

	lea	rcx, OFFSET FLAT:$SG11245
	call	DoDebugMsg

; 647  :     return;
; 648  : 
; 649  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:SymInit$rtcFrameData
	call	_RTC_CheckStackVars
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
SymInit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
i$ = 48
len$ = 52
name$ = 80
SymFind	PROC

; 263  : {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 264  :     int i;
; 265  :     int len;
; 266  : 
; 267  :     len = strlen( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 268  :     i = hashpjw( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	hashpjw
	mov	DWORD PTR i$[rsp], eax

; 269  : 
; 270  :     if ( CurrProc ) {

	cmp	QWORD PTR CurrProc, 0
	je	$LN8@SymFind

; 271  :         for( lsym = &lsym_table[ i % LHASH_TABLE_SIZE ]; *lsym; lsym = &((*lsym)->nextitem ) ) {

	mov	eax, DWORD PTR i$[rsp]
	cdq
	mov	ecx, 127				; 0000007fH
	idiv	ecx
	mov	eax, edx
	cdqe
	lea	rcx, OFFSET FLAT:lsym_table
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR lsym, rax
	jmp	SHORT $LN4@SymFind
$LN2@SymFind:
	mov	rax, QWORD PTR lsym
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR lsym, rax
$LN4@SymFind:
	mov	rax, QWORD PTR lsym
	cmp	QWORD PTR [rax], 0
	je	$LN3@SymFind

; 272  :             if ( len == (*lsym)->name_size && SYMCMP( name, (*lsym)->name, len ) == 0 ) {

	mov	rax, QWORD PTR lsym
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+72]
	cmp	DWORD PTR len$[rsp], eax
	jne	SHORT $LN9@SymFind
	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR lsym
	mov	rcx, QWORD PTR [rcx]
	mov	r8, rax
	mov	rdx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR name$[rsp]
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	jne	SHORT $LN9@SymFind

; 273  :                 DebugMsg1(("SymFind(%s): found in local table, state=%u, local=%u\n", name, (*lsym)->state, (*lsym)->scoped ));

	mov	rax, QWORD PTR lsym
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	mov	rcx, QWORD PTR lsym
	mov	rcx, QWORD PTR [rcx]
	mov	r9d, eax
	mov	r8d, DWORD PTR [rcx+32]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11105
	call	DoDebugMsg1

; 274  :                 return( *lsym );

	mov	rax, QWORD PTR lsym
	mov	rax, QWORD PTR [rax]
	jmp	$LN1@SymFind
$LN9@SymFind:

; 275  :             }
; 276  :         }

	jmp	$LN2@SymFind
$LN3@SymFind:
$LN8@SymFind:

; 277  :     }
; 278  : 
; 279  :     for( gsym = &gsym_table[ i % GHASH_TABLE_SIZE ]; *gsym; gsym = &((*gsym)->nextitem ) ) {

	mov	eax, DWORD PTR i$[rsp]
	cdq
	mov	ecx, 8009				; 00001f49H
	idiv	ecx
	mov	eax, edx
	cdqe
	lea	rcx, OFFSET FLAT:gsym_table
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR gsym, rax
	jmp	SHORT $LN7@SymFind
$LN5@SymFind:
	mov	rax, QWORD PTR gsym
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR gsym, rax
$LN7@SymFind:
	mov	rax, QWORD PTR gsym
	cmp	QWORD PTR [rax], 0
	je	$LN6@SymFind

; 280  :         if ( len == (*gsym)->name_size && SYMCMP( name, (*gsym)->name, len ) == 0 ) {

	mov	rax, QWORD PTR gsym
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+72]
	cmp	DWORD PTR len$[rsp], eax
	jne	SHORT $LN10@SymFind
	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR gsym
	mov	rcx, QWORD PTR [rcx]
	mov	r8, rax
	mov	rdx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR name$[rsp]
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	jne	SHORT $LN10@SymFind

; 281  :             DebugMsg1(("SymFind(%s): found, state=%u memtype=%X lang=%u\n", name, (*gsym)->state, (*gsym)->mem_type, (*gsym)->langtype ));

	mov	rax, QWORD PTR gsym
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR gsym
	mov	rcx, QWORD PTR [rcx]
	mov	rdx, QWORD PTR gsym
	mov	rdx, QWORD PTR [rdx]
	mov	eax, DWORD PTR [rax+76]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR [rcx+36]
	mov	r8d, DWORD PTR [rdx+32]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11107
	call	DoDebugMsg1

; 282  :             return( *gsym );

	mov	rax, QWORD PTR gsym
	mov	rax, QWORD PTR [rax]
	jmp	SHORT $LN1@SymFind
$LN10@SymFind:

; 283  :         }
; 284  :     }

	jmp	$LN5@SymFind
$LN6@SymFind:

; 285  : 
; 286  :     return( NULL );

	xor	eax, eax
$LN1@SymFind:

; 287  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
SymFind	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 32
name$ = 64
SymLookupLocal PROC

; 325  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 326  :     //struct asym      **sym_ptr;
; 327  :     struct asym      *sym;
; 328  : 
; 329  :     sym = SymFind( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 330  :     if ( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN2@SymLookupL

; 331  :         sym = SymAlloc( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymAlloc
	mov	QWORD PTR sym$[rsp], rax

; 332  :         sym->scoped = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 4
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 333  :         /* add the label to the local hash table */
; 334  :         //sym->next = *lsym;
; 335  :         *lsym = sym;

	mov	rax, QWORD PTR lsym
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx

; 336  :         DebugMsg1(("SymLookupLocal(%s): local symbol created in %s\n", name, CurrProc->sym.name));

	mov	rax, QWORD PTR CurrProc
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11125
	call	DoDebugMsg1
	jmp	$LN3@SymLookupL
$LN2@SymLookupL:

; 337  :     } else if( sym->state == SYM_UNDEFINED && sym->scoped == FALSE ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	$LN4@SymLookupL
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@SymLookupL

; 338  :         /* if the label was defined due to a FORWARD reference,
; 339  :          * its scope is to be changed from global to local.
; 340  :          */
; 341  :         /* remove the label from the global hash table */
; 342  :         *gsym = sym->nextitem;

	mov	rax, QWORD PTR gsym
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 343  :         SymCount--;

	mov	eax, DWORD PTR SymCount
	dec	eax
	mov	DWORD PTR SymCount, eax

; 344  :         sym->scoped = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 4
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 345  :         /* add the label to the local hash table */
; 346  :         //sym->next = *lsym;
; 347  :         sym->nextitem = NULL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], 0

; 348  :         *lsym = sym;

	mov	rax, QWORD PTR lsym
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx

; 349  :         DebugMsg1(("SymLookupLocal(%s): label moved into %s's local namespace\n", sym->name, CurrProc->sym.name ));

	mov	rax, QWORD PTR CurrProc
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11127
	call	DoDebugMsg1
$LN4@SymLookupL:
$LN3@SymLookupL:

; 350  :     }
; 351  : 
; 352  :     DebugMsg1(("SymLookupLocal(%s): found, state=%u, defined=%u\n", name, sym->state, sym->isdefined));

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	mov	r9d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+32]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11128
	call	DoDebugMsg1

; 353  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]

; 354  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SymLookupLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 32
tv71 = 40
name$ = 64
SymLookup PROC

; 303  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 304  :     struct asym      *sym;
; 305  : 
; 306  :     sym = SymFind( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 307  :     if( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN2@SymLookup

; 308  :         sym = SymAlloc( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymAlloc
	mov	QWORD PTR sym$[rsp], rax

; 309  :         DebugMsg1(("SymLookup(%s): created new symbol, CurrProc=%s\n", name, CurrProc ? CurrProc->sym.name : "NULL" ));

	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN4@SymLookup
	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv71[rsp], rax
	jmp	SHORT $LN5@SymLookup
$LN4@SymLookup:
	lea	rax, OFFSET FLAT:$SG11114
	mov	QWORD PTR tv71[rsp], rax
$LN5@SymLookup:
	mov	r8, QWORD PTR tv71[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11115
	call	DoDebugMsg1

; 310  :         //sym->next = *gsym;
; 311  :         *gsym = sym;

	mov	rax, QWORD PTR gsym
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx

; 312  :         ++SymCount;

	mov	eax, DWORD PTR SymCount
	inc	eax
	mov	DWORD PTR SymCount, eax
$LN2@SymLookup:

; 313  :     }
; 314  : 
; 315  :     DebugMsg1(("SymLookup(%s): found, state=%u, defined=%u\n", name, sym->state, sym->isdefined));

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	mov	r9d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+32]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11116
	call	DoDebugMsg1

; 316  : 
; 317  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]

; 318  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SymLookup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym2$ = 32
sym$ = 64
name$ = 72
SymAddLocal PROC

; 447  : {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 448  :     struct asym *sym2;
; 449  :     /* v2.10: ignore symbols with state SYM_UNDEFINED! */
; 450  :     //if( SymFind( name ) ) {
; 451  :     if( ( sym2 = SymFind( name ) ) && sym2->state != SYM_UNDEFINED ) {

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym2$[rsp], rax
	cmp	QWORD PTR sym2$[rsp], 0
	je	SHORT $LN2@SymAddLoca
	mov	rax, QWORD PTR sym2$[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN2@SymAddLoca

; 452  :         /* shouldn't happen */
; 453  :         EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 454  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@SymAddLoca
$LN2@SymAddLoca:

; 455  :     }
; 456  : #if FASTMEM==0
; 457  :     if ( sym->name_size ) LclFree( sym->name );
; 458  : #endif
; 459  :     sym->name_size = strlen( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+72], al

; 460  :     sym->name = LclAlloc( sym->name_size + 1 );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	inc	eax
	cdqe
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 461  :     memcpy( sym->name, name, sym->name_size + 1 );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	inc	eax
	cdqe
	mov	r8, rax
	mov	rdx, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy

; 462  :     sym->nextitem = NULL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], 0

; 463  :     *lsym = sym;

	mov	rax, QWORD PTR lsym
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx

; 464  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]
$LN1@SymAddLoca:

; 465  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SymAddLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 48
SymAddGlobal PROC

; 474  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 475  :     if( SymFind( sym->name ) ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	SymFind
	test	rax, rax
	je	SHORT $LN2@SymAddGlob

; 476  :         EmitErr( SYMBOL_ALREADY_DEFINED, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 477  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@SymAddGlob
$LN2@SymAddGlob:

; 478  :     }
; 479  :     sym->nextitem = NULL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], 0

; 480  :     *gsym = sym;

	mov	rax, QWORD PTR gsym
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx

; 481  :     SymCount++;

	mov	eax, DWORD PTR SymCount
	inc	eax
	mov	DWORD PTR SymCount, eax

; 482  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]
$LN1@SymAddGlob:

; 483  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SymAddGlobal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 32
name$ = 64
SymLCreate PROC

; 507  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 508  :     struct asym *sym;
; 509  : 
; 510  :     /* v2.10: ignore symbols with state SYM_UNDEFINED */
; 511  :     //if( SymFind( name ) ) {
; 512  :     if( ( sym = SymFind( name ) ) && sym->state != SYM_UNDEFINED ) {

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN2@SymLCreate
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN2@SymLCreate

; 513  :         EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 514  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@SymLCreate
$LN2@SymLCreate:

; 515  :     }
; 516  :     sym = SymAlloc( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymAlloc
	mov	QWORD PTR sym$[rsp], rax

; 517  :     *lsym = sym;

	mov	rax, QWORD PTR lsym
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx

; 518  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]
$LN1@SymLCreate:

; 519  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SymLCreate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 32
name$ = 64
SymCreate PROC

; 488  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 489  :     struct asym *sym;
; 490  : 
; 491  :     if( SymFind( name ) ) {

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	test	rax, rax
	je	SHORT $LN2@SymCreate

; 492  :         EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 493  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@SymCreate
$LN2@SymCreate:

; 494  :     }
; 495  :     sym = SymAlloc( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymAlloc
	mov	QWORD PTR sym$[rsp], rax

; 496  :     *gsym = sym;

	mov	rax, QWORD PTR gsym
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax], rcx

; 497  :     SymCount++;

	mov	eax, DWORD PTR SymCount
	inc	eax
	mov	DWORD PTR SymCount, eax

; 498  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]
$LN1@SymCreate:

; 499  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SymCreate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
sym$ = 48
SymFree	PROC

; 421  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 422  :     //DebugMsg(("SymFree: free %X, name=%s, state=%X\n", sym, sym->name, sym->state));
; 423  :     free_ext( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	free_ext

; 424  : #if FASTMEM==0
; 425  :     if ( sym->state != SYM_EXTERNAL ) {
; 426  :         struct fixup *fix;
; 427  :         for( fix = sym->bp_fixup ; fix; ) {
; 428  :             struct fixup *next = fix->nextbp;
; 429  :             DebugMsg(("SymFree: free bp fixup %p\n", fix ));
; 430  :             LclFree( fix );
; 431  :             fix = next;
; 432  :         }
; 433  :     }
; 434  :     if ( sym->name_size ) LclFree( sym->name );
; 435  : #endif
; 436  :     LclFree( sym );
; 437  :     return;
; 438  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SymFree	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_TEXT	SEGMENT
len$ = 32
sym$ = 40
name$ = 64
SymAlloc PROC

; 229  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 230  :     int len = strlen( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 231  :     struct asym *sym;
; 232  : 
; 233  :     sym = LclAlloc( sizeof( struct dsym ) );

	mov	ecx, 120				; 00000078H
	call	LclAlloc
	mov	QWORD PTR sym$[rsp], rax

; 234  :     memset( sym, 0, sizeof( struct dsym ) );

	mov	r8d, 120				; 00000078H
	xor	edx, edx
	mov	rcx, QWORD PTR sym$[rsp]
	call	memset

; 235  : #if 1
; 236  :     /* the tokenizer ensures that identifiers are within limits, so
; 237  :      * this check probably is redundant */
; 238  :     if( len > MAX_ID_LEN ) {

	cmp	DWORD PTR len$[rsp], 247		; 000000f7H
	jle	SHORT $LN2@SymAlloc

; 239  :         EmitError( IDENTIFIER_TOO_LONG );

	mov	ecx, 70					; 00000046H
	call	EmitError

; 240  :         len = MAX_ID_LEN;

	mov	DWORD PTR len$[rsp], 247		; 000000f7H
$LN2@SymAlloc:

; 241  :     }
; 242  : #endif
; 243  :     sym->name_size = len;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR len$[rsp]
	mov	BYTE PTR [rax+72], cl

; 244  :     sym->list = ModuleInfo.cref;

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 12
	and	eax, 1
	and	al, 1
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+41]
	and	cl, 254					; 000000feH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+41], al

; 245  :     sym->mem_type = MT_EMPTY;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+36], 192			; 000000c0H

; 246  :     if ( len ) {

	cmp	DWORD PTR len$[rsp], 0
	je	SHORT $LN3@SymAlloc

; 247  :         sym->name = LclAlloc( len + 1 );

	mov	eax, DWORD PTR len$[rsp]
	inc	eax
	cdqe
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 248  :         memcpy( sym->name, name, len );

	movsxd	rax, DWORD PTR len$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy

; 249  :         sym->name[len] = NULLC;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rcx+rax], 0

; 250  :     } else

	jmp	SHORT $LN4@SymAlloc
$LN3@SymAlloc:

; 251  :         sym->name = "";

	mov	rax, QWORD PTR sym$[rsp]
	lea	rcx, OFFSET FLAT:$SG11090
	mov	QWORD PTR [rax+8], rcx
$LN4@SymAlloc:

; 252  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]

; 253  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SymAlloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Buffer$ = 96
_Format$ = 104
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1788 : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:sprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp___stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1391 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Format$ = 96
printf	PROC						; COMDAT

; 950  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 957  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:printf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
	push	rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	rdi
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 534  :         {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 535  :             return _time64(_Time);

	mov	rcx, QWORD PTR _Time$[rsp]
	call	QWORD PTR __imp__time64

; 536  :         }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\time.h
;	COMDAT localtime
_TEXT	SEGMENT
_Time$ = 48
localtime PROC						; COMDAT

; 508  :         {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 509  :             #pragma warning(push)
; 510  :             #pragma warning(disable: 4996)
; 511  :             return _localtime64(_Time);

	mov	rcx, QWORD PTR _Time$[rsp]
	call	QWORD PTR __imp__localtime64

; 512  :             #pragma warning(pop)
; 513  :         }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
localtime ENDP
_TEXT	ENDS
END
