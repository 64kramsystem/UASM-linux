; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG11284 DB	01H DUP (?)
$SG11518 DB	01H DUP (?)
$SG11521 DB	01H DUP (?)
$SG11524 DB	01H DUP (?)
$SG11577 DB	01H DUP (?)
$SG11582 DB	01H DUP (?)
$SG11590 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11275 DB	'NULL', 00H
	ORG $+11
$SG11276 DB	'InitStructuredVar(%s) enter, total_size=%u, init=>%s<, e'
	DB	'mbedded=%s, alignm=%u', 0aH, 00H
	ORG $+1
$SG11277 DB	'data.c', 00H
	ORG $+1
$SG11434 DB	'NULL', 00H
	ORG $+3
$SG11286 DB	'InitStructuredVar(%s) field=%s ofs=%u total_size=%u tota'
	DB	'l_len=%u value=>%s< >%s<', 0aH, 00H
	ORG $+6
$SG11339 DB	'InitStructuredVar(%s): error, i=%u token=%s', 0aH, 00H
	ORG $+3
$SG11435 DB	'NULL', 00H
	ORG $+3
$SG11325 DB	'InitStructuredVar: padding, field=%s ofs=%X total=%X nex'
	DB	'tofs=%X', 0aH, 00H
	ORG $+3
$SG11456 DB	'(', 00H
	ORG $+2
$SG11340 DB	'InitStructuredVar(%s) exit, current ofs=%X', 0aH, 00H
$SG11464 DB	'NULL', 00H
	ORG $+7
$SG11436 DB	'data_item( idx=%u [%s], label=%s, no_of_bytes=%u, type=%'
	DB	's, dup=%Xh, inside_struct=%u, is_float=%u ) enter', 0aH, 00H
	ORG $+5
$SG11440 DB	'data_item(%s): literal/brace found: >%s<, inside_struct='
	DB	'%u, no_of_bytes=%u, curr_ofs=%X', 0aH, 00H
	ORG $+3
$SG11471 DB	')', 00H
	ORG $+2
$SG11450 DB	'data_item, error, unexpected kind=%u of DUP''s first ope'
	DB	'rand', 0aH, 00H
	ORG $+3
$SG11455 DB	'data_item error, missing ''(''', 0aH, 00H
	ORG $+2
$SG11465 DB	'data_item(%s): op DUP, count=%Xh, calling data_item()', 0aH
	DB	00H
	ORG $+1
$SG11467 DB	'NULL', 00H
	ORG $+3
$SG11468 DB	'data_item(%s): op DUP, count=%Xh, returned with error', 0aH
	DB	00H
	ORG $+1
$SG11470 DB	'data_item: error ''missing '')'', exit', 0aH, 00H
	ORG $+3
$SG11475 DB	'data_item: error, type=%s needs literal, >%s<', 0aH, 00H
	ORG $+1
$SG11477 DB	'data_item: ? found, curr_ofs=%X', 0aH, 00H
	ORG $+3
$SG11483 DB	'BSS', 00H
$SG11484 DB	'AT', 00H
	ORG $+1
$SG11732 DB	'Seg', 00H
$SG11486 DB	'data_item.EMPTY: idx=%u, tokenarray.token=%X', 0aH, 00H
	ORG $+2
$SG11490 DB	'data_item.FLOAT: >%s<, inside_struct=%u, no_of_bytes=%u,'
	DB	' curr_ofs=%X', 0aH, 00H
	ORG $+2
$SG11532 DB	'data_item.ADDR: error, is_float=%u', 0aH, 00H
	ORG $+4
$SG11496 DB	'data_item.CONST: string found: >%s<, inside_struct=%u, n'
	DB	'o_of_bytes=%u, curr_ofs=%X', 0aH, 00H
$SG11672 DB	'NULL', 00H
	ORG $+7
$SG11508 DB	'data_item.CONST: const found, value=%Xh, no_of_bytes=%u,'
	DB	' curr_ofs=%X', 0aH, 00H
	ORG $+2
$SG11517 DB	'data_item.CONST: error, unhandled data is %I64X_%016I64X'
	DB	0aH, 00H
	ORG $+2
$SG11731 DB	'Struct', 00H
	ORG $+5
$SG11526 DB	'data_item.ADDR: error, indirect=%u, sym=%X', 0aH, 00H
	ORG $+4
$SG11530 DB	'data_item.ADDR: displacement doesn''t fit in 32 bits: %I'
	DB	'64X', 0aH, 00H
	ORG $+4
$SG11536 DB	'data_item.ADDR: error, a SEG wont fit in a BYTE', 0aH, 00H
	ORG $+7
$SG11542 DB	'data_item.ADDR: error, an offset wont fit in a BYTE', 0aH
	DB	00H
	ORG $+3
$SG11541 DB	'data_item.ADDR: forward reference + OFFSET operator + DB'
	DB	' -> may become error in Pass 2', 0aH, 00H
$SG11551 DB	'data_item.ADDR: IMAGEREL, error, size=%u (should be 4)', 0aH
	DB	00H
$SG11554 DB	'data_item.ADDR: SECTIONREL, error, size=%u (should be 4)'
	DB	0aH, 00H
	ORG $+6
$SG11557 DB	'data_item.ADDR: HIGH detected', 0aH, 00H
	ORG $+1
$SG11569 DB	'data_item.ADDR: error, no of bytes=%u', 0aH, 00H
	ORG $+1
$SG11576 DB	'data_item.ADDR: error, memtype %X wont fit in a WORD', 0aH
	DB	00H
	ORG $+2
$SG11581 DB	'data_item.ADDR: error, a 32bit offset (%s) wont fit in a'
	DB	' WORD', 0aH, 00H
	ORG $+1
$SG11589 DB	'data_item.ADDR: error, FAR32 won''t fit in a DWORD', 0aH
	DB	00H
	ORG $+5
$SG11619 DB	'data_item: error, opndx.kind=%u', 0aH, 00H
	ORG $+7
$SG11625 DB	'data_item: exit, no error, i=%d', 0aH, 00H
	ORG $+7
$SG11642 DB	'checktypes: memtype conflict: %u - %u', 0aH, 00H
	ORG $+1
$SG11673 DB	'data_dir( i=%u, type=%s ) enter', 0aH, 00H
	ORG $+7
$SG11676 DB	'data_dir: missing initializer', 0aH, 00H
	ORG $+1
$SG11684 DB	'data_dir: size of arbitrary type is 0!', 0aH, 00H
$SG11700 DB	'data_dir: %s, CreateStructField called, ofs=%d', 0aH, 00H
$SG11707 DB	'data_dir: calling SymLookup(%s)', 0aH, 00H
	ORG $+7
$SG11720 DB	'data_dir(%s): error, symbol redefinition, state=%X', 0aH
	DB	00H
	ORG $+4
$SG11723 DB	'data_dir: Phase error, pass %u, sym >%s< first time, new'
	DB	'=%X != old=%X', 0aH, 00H
	ORG $+1
$SG11727 DB	'data_dir: error in data_item()', 0aH, 00H
$SG11733 DB	'NULL', 00H
	ORG $+3
$SG11734 DB	'data_dir: exit, no error, label=%s, is_array=%u Curr%s.o'
	DB	'fs=%X', 0aH, 00H
	ORG $+1
$SG11193 DB	'NULL', 00H
	ORG $+3
$SG11215 DB	'InitializeArray(%s): new offset=%X', 0aH, 00H
	ORG $+4
$SG11194 DB	'InitializeArray(%s) enter, items=%u size=%u mem_type=%xh'
	DB	' type=%s currofs=%X [%s]', 0aH, 00H
	ORG $+6
$SG11218 DB	'InitializeArray(%s): error, cursize=%u total_size=%u', 0aH
	DB	00H
	ORG $+2
$SG11209 DB	'InitializeArray(%s): error, array init requires DUP, str'
	DB	'ing or literal', 0aH, 00H
$SG11220 DB	'InitializeArray: remaining bytes=%u', 0aH, 00H
	ORG $+3
$SG11225 DB	'InitializeArray(%s) exit, curr ofs=%X', 0aH, 00H
_DATA	ENDS
PUBLIC	data_dir
EXTRN	memset:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	FillDataBytes:PROC
EXTRN	OutputBytes:PROC
EXTRN	SymLookup:PROC
EXTRN	SizeFromMemtype:PROC
EXTRN	sym_remove_table:PROC
EXTRN	sym_ext2int:PROC
EXTRN	set_frame:PROC
EXTRN	set_frame2:PROC
EXTRN	EvalOperand:PROC
EXTRN	EmitConstError:PROC
EXTRN	CreateFixup:PROC
EXTRN	BackPatch:PROC
EXTRN	LstWrite:PROC
EXTRN	SetSymSegOfs:PROC
EXTRN	GetSymOfssize:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	SetCurrOffset:PROC
EXTRN	CreateStructField:PROC
EXTRN	UpdateStructSize:PROC
EXTRN	StoreLine:PROC
EXTRN	Tokenize:PROC
EXTRN	ExpandLiterals:PROC
EXTRN	omf_OutSelect:PROC
EXTRN	atofloat:PROC
EXTRN	InternalError:PROC
EXTRN	segm_override:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	write_to_file:BYTE
EXTRN	SymTables:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	CurrStruct:QWORD
EXTRN	StoreState:BYTE
EXTRN	UseSavedState:BYTE
EXTRN	SegOverride:QWORD
EXTRN	szNull:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$data_item DD imagerel data_item
	DD	imagerel data_item+6140
	DD	imagerel $unwind$data_item
$pdata$InitializeArray DD imagerel InitializeArray
	DD	imagerel InitializeArray+1701
	DD	imagerel $unwind$InitializeArray
$pdata$InitStructuredVar DD imagerel InitStructuredVar
	DD	imagerel InitStructuredVar+2983
	DD	imagerel $unwind$InitStructuredVar
$pdata$little_endian DD imagerel little_endian
	DD	imagerel little_endian+150
	DD	imagerel $unwind$little_endian
$pdata$output_float DD imagerel output_float
	DD	imagerel output_float+274
	DD	imagerel $unwind$output_float
$pdata$checktypes DD imagerel checktypes
	DD	imagerel checktypes+203
	DD	imagerel $unwind$checktypes
$pdata$data_dir DD imagerel $LN71
	DD	imagerel $LN71+2538
	DD	imagerel $unwind$data_dir
pdata	ENDS
xdata	SEGMENT
$unwind$data_item DD 021b01H
	DD	02f011bH
$unwind$InitializeArray DD 021601H
	DD	0110116H
$unwind$InitStructuredVar DD 021a01H
	DD	027011aH
$unwind$little_endian DD 010d01H
	DD	0220dH
$unwind$output_float DD 011c19H
	DD	0c20dH
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$checktypes DD 011201H
	DD	06212H
$unwind$data_dir DD 021501H
	DD	0170115H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\data.c
_TEXT	SEGMENT
sym$ = 80
is_float$ = 88
mem_type$ = 92
no_of_bytes$ = 96
currofs$ = 100
idx$ = 104
old_offset$ = 108
tv369 = 112
tv401 = 116
tv406 = 120
tv416 = 124
name$ = 128
tv66 = 136
tv217 = 144
tv409 = 152
tv420 = 160
i$ = 192
tokenarray$ = 200
type_sym$ = 208
data_dir PROC

; 1135 : {

$LN71:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 184				; 000000b8H

; 1136 :     uint_32             no_of_bytes;
; 1137 :     struct asym         *sym = NULL;

	mov	QWORD PTR sym$[rsp], 0

; 1138 :     uint_32             old_offset;
; 1139 :     uint_32             currofs; /* for LST output */
; 1140 :     enum memtype        mem_type;
; 1141 :     bool                is_float = FALSE;

	mov	BYTE PTR is_float$[rsp], 0

; 1142 :     int                 idx;
; 1143 :     char                *name;
; 1144 : 
; 1145 :     DebugMsg1(("data_dir( i=%u, type=%s ) enter\n", i, type_sym ? type_sym->name : "NULL" ));

	cmp	QWORD PTR type_sym$[rsp], 0
	je	SHORT $LN55@data_dir
	mov	rax, QWORD PTR type_sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN56@data_dir
$LN55@data_dir:
	lea	rax, OFFSET FLAT:$SG11672
	mov	QWORD PTR tv66[rsp], rax
$LN56@data_dir:
	mov	r8, QWORD PTR tv66[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11673
	call	DoDebugMsg1

; 1146 : 
; 1147 :     /* v2.05: the previous test in parser.c wasn't fool-proved */
; 1148 :     if ( i > 1 && ModuleInfo.m510 == FALSE ) {

	cmp	DWORD PTR i$[rsp], 1
	jle	SHORT $LN4@data_dir
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 6
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN4@data_dir

; 1149 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@data_dir
$LN4@data_dir:

; 1150 :     }
; 1151 :     if( tokenarray[i+1].token == T_FINAL ) {

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN5@data_dir

; 1152 :         DebugMsg(("data_dir: missing initializer\n"));

	lea	rcx, OFFSET FLAT:$SG11676
	call	DoDebugMsg

; 1153 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@data_dir
$LN5@data_dir:

; 1154 :     }
; 1155 : 
; 1156 :     /* set values for mem_type and no_of_bytes */
; 1157 :     if ( type_sym ) {

	cmp	QWORD PTR type_sym$[rsp], 0
	je	$LN6@data_dir

; 1158 :         /* if the parser found a TYPE id, type_sym is != NULL */
; 1159 :         //DebugMsg1(("data_dir: arbitrary type %s, calling SymSearch\n", type_sym->name ));
; 1160 :         //type_sym = SymSearch( tokenarray[i].string_ptr );
; 1161 :         mem_type = MT_TYPE;

	mov	DWORD PTR mem_type$[rsp], 196		; 000000c4H

; 1162 :         if ( type_sym->typekind != TYPE_TYPEDEF &&

	mov	rax, QWORD PTR type_sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	je	SHORT $LN8@data_dir
	mov	rax, QWORD PTR type_sym$[rsp]
	cmp	DWORD PTR [rax+56], 0
	je	SHORT $LN9@data_dir
	mov	rax, QWORD PTR type_sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+29]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN8@data_dir
$LN9@data_dir:

; 1163 :              ( type_sym->total_size == 0 || ((struct dsym *)type_sym)->e.structinfo->OrgInside == TRUE ) ) {
; 1164 :             return( EmitError( STRUCT_CANNOT_BE_INSTANCED ) );

	mov	ecx, 215				; 000000d7H
	call	EmitError
	jmp	$LN1@data_dir
$LN8@data_dir:

; 1165 :         }
; 1166 : 
; 1167 :         /* v2.09: expand literals inside <> or {}.
; 1168 :          * Previously this was done inside InitStructuredVar()
; 1169 :          */
; 1170 : #if FASTPASS
; 1171 :         if ( Parse_Pass == PASS_1 || UseSavedState == FALSE )

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN11@data_dir
	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	jne	SHORT $LN10@data_dir
$LN11@data_dir:

; 1172 : #endif
; 1173 :             ExpandLiterals( i+1, tokenarray );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, eax
	call	ExpandLiterals
$LN10@data_dir:

; 1174 : 
; 1175 :         no_of_bytes = type_sym->total_size;

	mov	rax, QWORD PTR type_sym$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR no_of_bytes$[rsp], eax

; 1176 :         if ( no_of_bytes == 0 ) {

	cmp	DWORD PTR no_of_bytes$[rsp], 0
	jne	SHORT $LN12@data_dir

; 1177 :             DebugMsg(("data_dir: size of arbitrary type is 0!\n"));

	lea	rcx, OFFSET FLAT:$SG11684
	call	DoDebugMsg

; 1178 :             /* a void type is not valid */
; 1179 :             if ( type_sym->typekind == TYPE_TYPEDEF ) {

	mov	rax, QWORD PTR type_sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	jne	SHORT $LN13@data_dir

; 1180 :                 return( EmitErr( INVALID_TYPE_FOR_DATA_DECLARATION, type_sym->name ) );

	mov	rax, QWORD PTR type_sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 160				; 000000a0H
	call	EmitErr
	jmp	$LN1@data_dir
$LN13@data_dir:
$LN12@data_dir:

; 1181 :             }
; 1182 :         }
; 1183 :     } else {

	jmp	$LN7@data_dir
$LN6@data_dir:

; 1184 :         /* it's either a predefined type or a data directive. For types, the index
; 1185 :          into the simpletype table is in <bytval>, for data directives
; 1186 :          the index is found in <sflags>.
; 1187 :          * v2.06: SimpleType is obsolete. Use token index directly!
; 1188 :          */
; 1189 : 
; 1190 :         if ( tokenarray[i].token == T_STYPE ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 6
	jne	SHORT $LN14@data_dir

; 1191 :             //idx = tokenarray[i].bytval;
; 1192 :             idx = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR idx$[rsp], eax
	jmp	$LN15@data_dir
$LN14@data_dir:

; 1193 :         } else if ( tokenarray[i].token == T_DIRECTIVE &&

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	SHORT $LN16@data_dir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 8
	jne	SHORT $LN16@data_dir

; 1194 :                    ( tokenarray[i].dirtype == DRT_DATADIR )) {
; 1195 :             idx = GetSflagsSp( tokenarray[i].tokval );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax+4]
	mov	DWORD PTR idx$[rsp], eax

; 1196 :         } else {

	jmp	SHORT $LN17@data_dir
$LN16@data_dir:

; 1197 :             return( EmitErr( INVALID_TYPE_FOR_DATA_DECLARATION, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 160				; 000000a0H
	call	EmitErr
	jmp	$LN1@data_dir
$LN17@data_dir:
$LN15@data_dir:

; 1198 :         }
; 1199 :         mem_type = GetMemtypeSp( idx );

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	DWORD PTR mem_type$[rsp], eax

; 1200 :         /* types NEAR[16|32], FAR[16|32] and PROC are invalid here */
; 1201 :         //if ( ( SimpleType[idx].mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS ) {
; 1202 :         if ( ( mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS ) {

	mov	eax, DWORD PTR mem_type$[rsp]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN18@data_dir

; 1203 :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@data_dir
$LN18@data_dir:

; 1204 :         }
; 1205 :         no_of_bytes = (mem_type & MT_SIZE_MASK) + 1;

	mov	eax, DWORD PTR mem_type$[rsp]
	and	eax, 31
	inc	eax
	mov	DWORD PTR no_of_bytes$[rsp], eax

; 1206 :         if ( mem_type & MT_FLOAT )

	mov	eax, DWORD PTR mem_type$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN19@data_dir

; 1207 :             is_float = TRUE;

	mov	BYTE PTR is_float$[rsp], 1
$LN19@data_dir:
$LN7@data_dir:

; 1208 :     }
; 1209 : 
; 1210 :     /* if i == 1, there's a (data) label at pos 0.
; 1211 :      * (note: if -Zm is set, a code label may be at pos 0, and
; 1212 :      * i is 2 then.)
; 1213 :      */
; 1214 :     name = ( ( i == 1 ) ? tokenarray[0].string_ptr : NULL );

	cmp	DWORD PTR i$[rsp], 1
	jne	SHORT $LN57@data_dir
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR tv217[rsp], rax
	jmp	SHORT $LN58@data_dir
$LN57@data_dir:
	mov	QWORD PTR tv217[rsp], 0
$LN58@data_dir:
	mov	rax, QWORD PTR tv217[rsp]
	mov	QWORD PTR name$[rsp], rax

; 1215 : 
; 1216 :     /* in a struct declaration? */
; 1217 :     if( CurrStruct ) {

	cmp	QWORD PTR CurrStruct, 0
	je	$LN20@data_dir

; 1218 : 
; 1219 :         /* structure parsing is done in the first pass only */
; 1220 :         if( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN22@data_dir

; 1221 : 
; 1222 :             /* current offset isn't necessarily the fields start offset */
; 1223 :             //currofs = CurrStruct->sym.offset;
; 1224 : 
; 1225 :             if (!(sym = CreateStructField( i, tokenarray, name, mem_type, type_sym, no_of_bytes ))) {

	mov	eax, DWORD PTR no_of_bytes$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR type_sym$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR mem_type$[rsp]
	mov	r8, QWORD PTR name$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	CreateStructField
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN24@data_dir

; 1226 :                 return ( ERROR );

	mov	eax, -1
	jmp	$LN1@data_dir
$LN24@data_dir:

; 1227 :             }
; 1228 : #if FASTPASS
; 1229 :             if ( StoreState ) FStoreLine(0);

	movzx	eax, BYTE PTR StoreState
	test	eax, eax
	je	SHORT $LN25@data_dir
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN26@data_dir
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR ModuleInfo+464
	call	StoreLine
$LN26@data_dir:
$LN25@data_dir:

; 1230 : #endif
; 1231 :             currofs = sym->offset;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR currofs$[rsp], eax

; 1232 :             sym->isdata = TRUE; /* 'first_size' is valid */

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	or	al, 4
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+41], al

; 1233 :             DebugMsg1(("data_dir: %s, CreateStructField called, ofs=%d\n", sym->name, sym->offset ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+16]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11700
	call	DoDebugMsg1

; 1234 :         } else { /* v2.04: else branch added */

	jmp	SHORT $LN23@data_dir
$LN22@data_dir:

; 1235 :             sym = &CurrStruct->e.structinfo->tail->sym;

	mov	rax, QWORD PTR CurrStruct
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR sym$[rsp], rax

; 1236 :             currofs = sym->offset;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR currofs$[rsp], eax

; 1237 :             CurrStruct->e.structinfo->tail = CurrStruct->e.structinfo->tail->next;

	mov	rax, QWORD PTR CurrStruct
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR CurrStruct
	mov	rcx, QWORD PTR [rcx+96]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rcx+8], rax
$LN23@data_dir:

; 1238 :         }
; 1239 : 
; 1240 :     } else {

	jmp	$LN21@data_dir
$LN20@data_dir:

; 1241 : 
; 1242 :         if( CurrSeg == NULL ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN28@data_dir

; 1243 :             return( EmitError( MUST_BE_IN_SEGMENT_BLOCK ) );

	mov	ecx, 82					; 00000052H
	call	EmitError
	jmp	$LN1@data_dir
$LN28@data_dir:

; 1244 :         }
; 1245 : 
; 1246 :         FStoreLine(0);

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN29@data_dir
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR ModuleInfo+464
	call	StoreLine
$LN29@data_dir:

; 1247 : 
; 1248 :         if ( ModuleInfo.CommentDataInCode )

	movzx	eax, BYTE PTR ModuleInfo+423
	test	eax, eax
	je	SHORT $LN31@data_dir

; 1249 :             omf_OutSelect( TRUE );

	mov	cl, 1
	call	omf_OutSelect
$LN31@data_dir:

; 1250 : 
; 1251 :         if ( ModuleInfo.list ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN32@data_dir

; 1252 :             currofs = GetCurrOffset();

	call	GetCurrOffset
	mov	DWORD PTR currofs$[rsp], eax
$LN32@data_dir:

; 1253 :         }
; 1254 : 
; 1255 :         /* is a label accociated with the data definition? */
; 1256 :         if( name ) {

	cmp	QWORD PTR name$[rsp], 0
	je	$LN33@data_dir

; 1257 :             /* get/create the label. */
; 1258 :             DebugMsg1(("data_dir: calling SymLookup(%s)\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11707
	call	DoDebugMsg1

; 1259 :             sym = SymLookup( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymLookup
	mov	QWORD PTR sym$[rsp], rax

; 1260 :             /* v2.11: cannot fail */
; 1261 :             //if( sym == NULL ) {
; 1262 :             //    DebugMsg(("data_dir exit, error: invalid label name\n"));
; 1263 :             //    return( ERROR );
; 1264 :             //}
; 1265 : 
; 1266 :             if( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN34@data_dir

; 1267 : 
; 1268 :                 if ( sym->state == SYM_EXTERNAL && sym->weak == TRUE && sym->isproc == FALSE ) { /* EXTERNDEF? */

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN36@data_dir
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN36@data_dir
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN36@data_dir

; 1269 : 
; 1270 :                     //if ( checktypes( sym, mem_type, type_sym ) == ERROR )
; 1271 :                     //    return( ERROR );
; 1272 :                     /* v2.0: display error and continue! */
; 1273 :                     checktypes( sym, mem_type, type_sym );

	mov	r8, QWORD PTR type_sym$[rsp]
	mov	edx, DWORD PTR mem_type$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	checktypes

; 1274 :                     /* remove the external info */
; 1275 :                     sym_ext2int( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	sym_ext2int

; 1276 :                     sym->total_size = 0;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+56], 0

; 1277 :                     sym->total_length = 0;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+64], 0

; 1278 :                     sym->first_length = 0;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+48], 0
	jmp	$LN37@data_dir
$LN36@data_dir:

; 1279 : 
; 1280 :                 } else if( sym->state == SYM_UNDEFINED ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN38@data_dir

; 1281 : 
; 1282 :                     sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_remove_table

; 1283 :                     sym->state = SYM_INTERNAL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+32], 1

; 1284 : #if 1
; 1285 :                     /* v2.11: Set the symbol's langtype. It may have been set
; 1286 :                      * by a PUBLIC directive, so take care not to overwrite it.
; 1287 :                      * Problem: Masm doesn't do this - might be a bug.
; 1288 :                      */
; 1289 :                     if ( sym->langtype == LANG_NONE )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+76], 0
	jne	SHORT $LN40@data_dir

; 1290 :                         sym->langtype = ModuleInfo.langtype;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR ModuleInfo+364
	mov	DWORD PTR [rax+76], ecx
$LN40@data_dir:

; 1291 : #endif
; 1292 :                 } else if ( sym->state == SYM_INTERNAL) {

	jmp	$LN39@data_dir
$LN38@data_dir:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN41@data_dir

; 1293 : 
; 1294 :                     /* accept a symbol "redefinition" if addresses and types
; 1295 :                      * do match.
; 1296 :                      */
; 1297 :                     if ( sym->segment != (struct asym *)CurrSeg ||

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+432
	cmp	QWORD PTR [rax+24], rcx
	jne	SHORT $LN44@data_dir
	call	GetCurrOffset
	mov	rcx, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rcx+16], eax
	je	SHORT $LN43@data_dir
$LN44@data_dir:

; 1298 :                         sym->offset != GetCurrOffset() ) {
; 1299 :                         return( EmitErr( SYMBOL_ALREADY_DEFINED, name ) );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 56					; 00000038H
	call	EmitErr
	jmp	$LN1@data_dir
$LN43@data_dir:

; 1300 :                     }
; 1301 :                     /* check for symbol type conflict */
; 1302 :                     if ( checktypes( sym, mem_type, type_sym ) == ERROR )

	mov	r8, QWORD PTR type_sym$[rsp]
	mov	edx, DWORD PTR mem_type$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	checktypes
	cmp	eax, -1
	jne	SHORT $LN45@data_dir

; 1303 :                         return( ERROR );

	mov	eax, -1
	jmp	$LN1@data_dir
$LN45@data_dir:

; 1304 :                     /* v2.09: reset size and length ( might have been set by LABEL directive ) */
; 1305 :                     sym->total_size = 0;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+56], 0

; 1306 :                     sym->total_length = 0;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+64], 0

; 1307 :                     goto label_defined; /* don't relink the label */

	jmp	SHORT $label_defined$72

; 1308 : 
; 1309 :                 } else {

	jmp	SHORT $LN42@data_dir
$LN41@data_dir:

; 1310 :                     DebugMsg(("data_dir(%s): error, symbol redefinition, state=%X\n", sym->name, sym->state ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+32]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11720
	call	DoDebugMsg

; 1311 :                     return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@data_dir
$LN42@data_dir:
$LN39@data_dir:
$LN37@data_dir:

; 1312 :                 }
; 1313 :                 /* add the label to the linked list attached to curr segment */
; 1314 :                 /* this allows to reduce the number of passes (see Fixup.c) */
; 1315 :                 ((struct dsym *)sym)->next = (struct dsym *)CurrSeg->e.seginfo->label_list;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR [rcx+104], rax

; 1316 :                 CurrSeg->e.seginfo->label_list = sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+32], rcx

; 1317 : 
; 1318 :             } else {

	jmp	SHORT $LN35@data_dir
$LN34@data_dir:

; 1319 :                 old_offset = sym->offset;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR old_offset$[rsp], eax
$LN35@data_dir:
$label_defined$72:

; 1320 :             }
; 1321 :         label_defined:
; 1322 :             SetSymSegOfs( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	SetSymSegOfs

; 1323 :             if( Parse_Pass != PASS_1 && sym->offset != old_offset ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN46@data_dir
	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR old_offset$[rsp]
	cmp	DWORD PTR [rax+16], ecx
	je	SHORT $LN46@data_dir

; 1324 : #ifdef DEBUG_OUT
; 1325 :                 if ( !ModuleInfo.PhaseError )

	movzx	eax, BYTE PTR ModuleInfo+422
	test	eax, eax
	jne	SHORT $LN47@data_dir

; 1326 :                     DebugMsg(("data_dir: Phase error, pass %u, sym >%s< first time, new=%X != old=%X\n", Parse_Pass+1, sym->name, sym->offset, old_offset));

	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	ecx, DWORD PTR old_offset$[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	rcx, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rcx+16]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rcx+8]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11723
	call	DoDebugMsg
$LN47@data_dir:

; 1327 : #endif
; 1328 :                 ModuleInfo.PhaseError = TRUE;

	mov	BYTE PTR ModuleInfo+422, 1
$LN46@data_dir:

; 1329 :             }
; 1330 :             sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 1331 :             sym->isdata = TRUE; /* 'first_size' is valid */

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	or	al, 4
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+41], al

; 1332 :             sym->mem_type = mem_type;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR mem_type$[rsp]
	mov	DWORD PTR [rax+36], ecx

; 1333 :             sym->type = type_sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR type_sym$[rsp]
	mov	QWORD PTR [rax+80], rcx

; 1334 : 
; 1335 :             /* backpatch for data items? Yes, if the item is defined
; 1336 :              * in a code segment then its offset may change!
; 1337 :              */
; 1338 :             BackPatch( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	BackPatch
$LN33@data_dir:

; 1339 :         }
; 1340 : 
; 1341 :         if ( type_sym ) {

	cmp	QWORD PTR type_sym$[rsp], 0
	je	SHORT $LN48@data_dir
$LN2@data_dir:

; 1342 :             while ( type_sym->mem_type == MT_TYPE )

	mov	rax, QWORD PTR type_sym$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN3@data_dir

; 1343 :                 type_sym = type_sym->type;

	mov	rax, QWORD PTR type_sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR type_sym$[rsp], rax
	jmp	SHORT $LN2@data_dir
$LN3@data_dir:

; 1344 :             /* if it is just a type alias, skip the arbitrary type */
; 1345 :             if ( type_sym->typekind == TYPE_TYPEDEF )

	mov	rax, QWORD PTR type_sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	jne	SHORT $LN49@data_dir

; 1346 :                 type_sym = NULL;

	mov	QWORD PTR type_sym$[rsp], 0
$LN49@data_dir:
$LN48@data_dir:
$LN21@data_dir:

; 1347 :         }
; 1348 : 
; 1349 :     }
; 1350 : 
; 1351 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1352 :     if ( data_item( &i, tokenarray, sym, no_of_bytes, type_sym, 1, CurrStruct != NULL, is_float, TRUE, Token_Count ) == ERROR ) {

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN59@data_dir
	mov	DWORD PTR tv369[rsp], 1
	jmp	SHORT $LN60@data_dir
$LN59@data_dir:
	mov	DWORD PTR tv369[rsp], 0
$LN60@data_dir:
	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR [rsp+72], eax
	mov	BYTE PTR [rsp+64], 1
	movzx	eax, BYTE PTR is_float$[rsp]
	mov	BYTE PTR [rsp+56], al
	movzx	eax, BYTE PTR tv369[rsp]
	mov	BYTE PTR [rsp+48], al
	mov	DWORD PTR [rsp+40], 1
	mov	rax, QWORD PTR type_sym$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR no_of_bytes$[rsp]
	mov	r8, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	data_item
	cmp	eax, -1
	jne	SHORT $LN50@data_dir

; 1353 :         DebugMsg(("data_dir: error in data_item()\n"));

	lea	rcx, OFFSET FLAT:$SG11727
	call	DoDebugMsg

; 1354 :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@data_dir
$LN50@data_dir:

; 1355 :     }
; 1356 : 
; 1357 :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN51@data_dir

; 1358 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@data_dir
$LN51@data_dir:

; 1359 :     }
; 1360 : 
; 1361 :     /* v2.06: update struct size after ALL items have been processed */
; 1362 :     if ( CurrStruct )

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN52@data_dir

; 1363 :         UpdateStructSize( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	UpdateStructSize
$LN52@data_dir:

; 1364 : 
; 1365 :     if ( ModuleInfo.list )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN53@data_dir

; 1366 :         LstWrite( CurrStruct ? LSTTYPE_STRUCT : LSTTYPE_DATA, currofs, sym );

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN61@data_dir
	mov	DWORD PTR tv401[rsp], 6
	jmp	SHORT $LN62@data_dir
$LN61@data_dir:
	mov	DWORD PTR tv401[rsp], 0
$LN62@data_dir:
	mov	r8, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR currofs$[rsp]
	mov	ecx, DWORD PTR tv401[rsp]
	call	LstWrite
$LN53@data_dir:

; 1367 : 
; 1368 :     DebugMsg1(("data_dir: exit, no error, label=%s, is_array=%u Curr%s.ofs=%X\n",

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN63@data_dir
	mov	rax, QWORD PTR CurrStruct
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv406[rsp], eax
	jmp	SHORT $LN64@data_dir
$LN63@data_dir:
	mov	rax, QWORD PTR ModuleInfo+432
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv406[rsp], eax
$LN64@data_dir:
	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN65@data_dir
	lea	rax, OFFSET FLAT:$SG11731
	mov	QWORD PTR tv409[rsp], rax
	jmp	SHORT $LN66@data_dir
$LN65@data_dir:
	lea	rax, OFFSET FLAT:$SG11732
	mov	QWORD PTR tv409[rsp], rax
$LN66@data_dir:
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN67@data_dir
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	mov	DWORD PTR tv416[rsp], eax
	jmp	SHORT $LN68@data_dir
$LN67@data_dir:
	mov	DWORD PTR tv416[rsp], 0
$LN68@data_dir:
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN69@data_dir
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv420[rsp], rax
	jmp	SHORT $LN70@data_dir
$LN69@data_dir:
	lea	rax, OFFSET FLAT:$SG11733
	mov	QWORD PTR tv420[rsp], rax
$LN70@data_dir:
	mov	eax, DWORD PTR tv406[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR tv409[rsp]
	mov	r8d, DWORD PTR tv416[rsp]
	mov	rdx, QWORD PTR tv420[rsp]
	lea	rcx, OFFSET FLAT:$SG11734
	call	DoDebugMsg1

; 1369 :                sym ? sym->name : "NULL",
; 1370 :                sym ? sym->isarray : 0,
; 1371 :                CurrStruct ? "Struct" : "Seg",
; 1372 :                CurrStruct ? CurrStruct->sym.offset : CurrSeg->sym.offset ));
; 1373 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@data_dir:

; 1374 : }

	add	rsp, 184				; 000000b8H
	ret	0
data_dir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\data.c
_TEXT	SEGMENT
mem_type2$1 = 32
tmp$2 = 40
sym$ = 64
mem_type$ = 72
type_sym$ = 80
checktypes PROC

; 1099 : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1100 :     /* for EXTERNDEF, check type changes */
; 1101 :     if ( sym->mem_type != MT_EMPTY ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 192			; 000000c0H
	je	$LN6@checktypes

; 1102 :         enum memtype mem_type2 = sym->mem_type;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR mem_type2$1[rsp], eax

; 1103 :         const struct asym *tmp;
; 1104 :         /* skip alias types */
; 1105 :         tmp = type_sym;

	mov	rax, QWORD PTR type_sym$[rsp]
	mov	QWORD PTR tmp$2[rsp], rax
$LN2@checktypes:

; 1106 :         while ( mem_type == MT_TYPE ) {

	cmp	DWORD PTR mem_type$[rsp], 196		; 000000c4H
	jne	SHORT $LN3@checktypes

; 1107 :             mem_type = tmp->mem_type;

	mov	rax, QWORD PTR tmp$2[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR mem_type$[rsp], eax

; 1108 :             tmp = tmp->type;

	mov	rax, QWORD PTR tmp$2[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR tmp$2[rsp], rax

; 1109 :         }

	jmp	SHORT $LN2@checktypes
$LN3@checktypes:

; 1110 :         tmp = sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR tmp$2[rsp], rax
$LN4@checktypes:

; 1111 :         while ( mem_type2 == MT_TYPE ) {

	cmp	DWORD PTR mem_type2$1[rsp], 196		; 000000c4H
	jne	SHORT $LN5@checktypes

; 1112 :             mem_type2 = tmp->mem_type;

	mov	rax, QWORD PTR tmp$2[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR mem_type2$1[rsp], eax

; 1113 :             tmp = tmp->type;

	mov	rax, QWORD PTR tmp$2[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR tmp$2[rsp], rax

; 1114 :         }

	jmp	SHORT $LN4@checktypes
$LN5@checktypes:

; 1115 :         if ( mem_type2 != mem_type ) {

	mov	eax, DWORD PTR mem_type$[rsp]
	cmp	DWORD PTR mem_type2$1[rsp], eax
	je	SHORT $LN7@checktypes

; 1116 :             DebugMsg(("checktypes: memtype conflict: %u - %u\n", mem_type2, mem_type ));

	mov	r8d, DWORD PTR mem_type$[rsp]
	mov	edx, DWORD PTR mem_type2$1[rsp]
	lea	rcx, OFFSET FLAT:$SG11642
	call	DoDebugMsg

; 1117 :             return( EmitErr( SYMBOL_TYPE_CONFLICT, sym->name ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 136				; 00000088H
	call	EmitErr
	jmp	SHORT $LN1@checktypes
$LN7@checktypes:
$LN6@checktypes:

; 1118 :         }
; 1119 :     }
; 1120 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@checktypes:

; 1121 : }

	add	rsp, 56					; 00000038H
	ret	0
checktypes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\data.c
_TEXT	SEGMENT
i$1 = 48
buffer$ = 56
__$ArrayPad$ = 88
opnd$ = 112
size$ = 120
output_float PROC

; 422  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 423  :     /* v2.07: buffer extended to max size of a data item (=32).
; 424  :      * test case: XMMWORD REAL10 ptr 1.0
; 425  :      */
; 426  :     //char buffer[12];
; 427  :     char buffer[32];
; 428  : 
; 429  :     if ( opnd->mem_type != MT_EMPTY ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	je	$LN2@output_flo

; 430  :         int i;
; 431  :         memset( buffer, 0, sizeof( buffer ) );

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 432  :         i = SizeFromMemtype( opnd->mem_type, USE_EMPTY, NULL );

	xor	r8d, r8d
	mov	edx, 254				; 000000feH
	mov	rax, QWORD PTR opnd$[rsp]
	mov	ecx, DWORD PTR [rax+64]
	call	SizeFromMemtype
	mov	DWORD PTR i$1[rsp], eax

; 433  :         if ( i > size )

	mov	eax, DWORD PTR size$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jbe	SHORT $LN4@output_flo

; 434  :             EmitErr( INITIALIZER_OUT_OF_RANGE );

	mov	ecx, 55					; 00000037H
	call	EmitErr
	jmp	SHORT $LN5@output_flo
$LN4@output_flo:

; 435  :         else {
; 436  :             atofloat( buffer, opnd->float_tok->string_ptr, i , opnd->negative, opnd->float_tok->floattype );

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	shr	ecx, 5
	and	ecx, 1
	mov	rdx, QWORD PTR opnd$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR [rsp+32], al
	movzx	r9d, cl
	mov	r8d, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	atofloat
$LN5@output_flo:

; 437  :         }
; 438  :     } else {

	jmp	SHORT $LN3@output_flo
$LN2@output_flo:

; 439  :         atofloat( buffer, opnd->float_tok->string_ptr, size, opnd->negative, opnd->float_tok->floattype );

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	shr	ecx, 5
	and	ecx, 1
	mov	rdx, QWORD PTR opnd$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR [rsp+32], al
	movzx	r9d, cl
	mov	r8d, DWORD PTR size$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	atofloat
$LN3@output_flo:

; 440  :     }
; 441  :     OutputDataBytes( buffer, size );

	xor	r8d, r8d
	mov	edx, DWORD PTR size$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	OutputBytes

; 442  :     return;
; 443  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
output_float ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\data.c
_TEXT	SEGMENT
dst$ = 0
src$ = 32
len$ = 40
little_endian PROC

; 405  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 406  :     /* v2.06: input and output buffer must be different! */
; 407  :     char *dst = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR dst$[rsp], rax

; 408  : 
; 409  :     for( ; len > 1; dst++, src++, len-- ) {

	jmp	SHORT $LN4@little_end
$LN2@little_end:
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
	mov	eax, DWORD PTR len$[rsp]
	dec	eax
	mov	DWORD PTR len$[rsp], eax
$LN4@little_end:
	cmp	DWORD PTR len$[rsp], 1
	jbe	SHORT $LN3@little_end

; 410  :         len--;

	mov	eax, DWORD PTR len$[rsp]
	dec	eax
	mov	DWORD PTR len$[rsp], eax

; 411  :         *dst = *(src + len);

	mov	eax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	mov	rdx, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rcx], al

; 412  :         *(dst + len) = *src;

	mov	eax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	mov	rdx, QWORD PTR src$[rsp]
	movzx	edx, BYTE PTR [rdx]
	mov	BYTE PTR [rcx+rax], dl

; 413  :     }

	jmp	SHORT $LN2@little_end
$LN3@little_end:

; 414  :     if ( len )

	cmp	DWORD PTR len$[rsp], 0
	je	SHORT $LN5@little_end

; 415  :         *dst = *src;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
$LN5@little_end:

; 416  : 
; 417  :     return( StringBufferEnd );

	mov	rax, QWORD PTR ModuleInfo+488

; 418  : }

	add	rsp, 24
	ret	0
little_endian ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\data.c
_TEXT	SEGMENT
i$ = 80
f$ = 88
c$1 = 96
is_record_set$ = 97
lvl$ = 100
no_of_bytes$2 = 104
nextofs$ = 108
tv494 = 112
j$3 = 116
j$4 = 120
no_of_bytes$5 = 124
j$6 = 128
tv90 = 132
max_item$7 = 136
tv612 = 140
dwMax$8 = 144
tc$9 = 148
old_tokencount$ = 152
dwRecInit$ = 160
tv70 = 168
tv170 = 176
old_stringbufferend$ = 184
opndx$ = 192
index$ = 320
tokenarray$ = 328
symtype$ = 336
embedded$ = 344
InitStructuredVar PROC

; 190  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 312				; 00000138H

; 191  :     //char            *ptr;
; 192  :     struct sfield   *f;
; 193  :     int_32          nextofs;
; 194  :     int             i;
; 195  :     int             old_tokencount = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR old_tokencount$[rsp], eax

; 196  :     char            *old_stringbufferend = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR old_stringbufferend$[rsp], rax

; 197  :     int             lvl;
; 198  : #if AMD64_SUPPORT
; 199  :     uint_64         dwRecInit;
; 200  : #else
; 201  :     uint_32         dwRecInit;
; 202  : #endif
; 203  :     bool            is_record_set;
; 204  :     struct expr     opndx;
; 205  :     //char            line[MAX_LINE_LEN];
; 206  : 
; 207  :     DebugMsg1(("InitStructuredVar(%s) enter, total_size=%" I32_SPEC "u, init=>%s<, embedded=%s, alignm=%u\n",

	cmp	QWORD PTR embedded$[rsp], 0
	je	SHORT $LN71@InitStruct
	mov	rax, QWORD PTR embedded$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv70[rsp], rax
	jmp	SHORT $LN72@InitStruct
$LN71@InitStruct:
	lea	rax, OFFSET FLAT:$SG11275
	mov	QWORD PTR tv70[rsp], rax
$LN72@InitStruct:
	mov	rax, QWORD PTR symtype$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+28]
	movsxd	rcx, DWORD PTR index$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR tv70[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	r9, QWORD PTR [rax+rcx+8]
	mov	rax, QWORD PTR symtype$[rsp]
	mov	r8d, DWORD PTR [rax+56]
	mov	rax, QWORD PTR symtype$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11276
	call	DoDebugMsg1

; 208  :               symtype->sym.name, symtype->sym.total_size, tokenarray[index].string_ptr, embedded ? embedded->name : "NULL", symtype->e.structinfo->alignment ));
; 209  : 
; 210  :     /**/myassert( symtype->sym.state == SYM_TYPE && symtype->sym.typekind != TYPE_TYPEDEF );

	mov	rax, QWORD PTR symtype$[rsp]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN73@InitStruct
	mov	rax, QWORD PTR symtype$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	je	SHORT $LN73@InitStruct
	mov	DWORD PTR tv90[rsp], 0
	jmp	SHORT $LN74@InitStruct
$LN73@InitStruct:
	mov	edx, 210				; 000000d2H
	lea	rcx, OFFSET FLAT:$SG11277
	call	InternalError
	mov	DWORD PTR tv90[rsp], eax
$LN74@InitStruct:

; 211  : 
; 212  :     if ( tokenarray[index].token == T_STRING ) {

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	$LN12@InitStruct

; 213  :         /* v2.08: no special handling of {}-literals anymore */
; 214  :         if ( tokenarray[index].string_delim != '<' &&

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN14@InitStruct
	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN14@InitStruct

; 215  :             tokenarray[index].string_delim != '{' ) {
; 216  :             return( EmitError( MISSING_ANGLE_BRACKET_OR_BRACE_IN_LITERAL ) );

	mov	ecx, 216				; 000000d8H
	call	EmitError
	jmp	$LN1@InitStruct
$LN14@InitStruct:

; 217  :         }
; 218  :         i = Token_Count + 1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 219  :         //strcpy( line, tokenarray[index].string_ptr );
; 220  :         Token_Count = Tokenize( tokenarray[index].string_ptr, i, tokenarray, TOK_RESCAN );

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 221  :         /* once Token_Count has been modified, don't exit without
; 222  :          * restoring this value!
; 223  :          */
; 224  :         index++;

	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	DWORD PTR index$[rsp], eax
	jmp	$LN13@InitStruct
$LN12@InitStruct:

; 225  : 
; 226  :     } else if ( embedded &&

	cmp	QWORD PTR embedded$[rsp], 0
	je	SHORT $LN15@InitStruct
	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN17@InitStruct
	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN15@InitStruct
$LN17@InitStruct:

; 227  :                 ( tokenarray[index].token == T_COMMA ||
; 228  :                  tokenarray[index].token == T_FINAL)) {
; 229  :         i = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rsp], eax

; 230  :     } else {

	jmp	SHORT $LN16@InitStruct
$LN15@InitStruct:

; 231  :         return( EmitErr( INITIALIZER_MUST_BE_A_STRING_OR_SINGLE_ITEM, embedded ? embedded->name : "" ) );

	cmp	QWORD PTR embedded$[rsp], 0
	je	SHORT $LN75@InitStruct
	mov	rax, QWORD PTR embedded$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv170[rsp], rax
	jmp	SHORT $LN76@InitStruct
$LN75@InitStruct:
	lea	rax, OFFSET FLAT:$SG11284
	mov	QWORD PTR tv170[rsp], rax
$LN76@InitStruct:
	mov	rdx, QWORD PTR tv170[rsp]
	mov	ecx, 152				; 00000098H
	call	EmitErr
	jmp	$LN1@InitStruct
$LN16@InitStruct:
$LN13@InitStruct:

; 232  :     }
; 233  :     if ( symtype->sym.typekind == TYPE_RECORD ) {

	mov	rax, QWORD PTR symtype$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 4
	jne	SHORT $LN18@InitStruct

; 234  :         dwRecInit = 0;

	mov	QWORD PTR dwRecInit$[rsp], 0

; 235  :         is_record_set = FALSE;

	mov	BYTE PTR is_record_set$[rsp], 0
$LN18@InitStruct:

; 236  :     }
; 237  : 
; 238  :     /* scan the STRUCT/UNION/RECORD's members */
; 239  :     for( f = symtype->e.structinfo->head; f != NULL; f = f->next ) {

	mov	rax, QWORD PTR symtype$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR f$[rsp], rax
	jmp	SHORT $LN4@InitStruct
$LN2@InitStruct:
	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR f$[rsp], rax
$LN4@InitStruct:
	cmp	QWORD PTR f$[rsp], 0
	je	$LN3@InitStruct

; 240  : 
; 241  :         DebugMsg1(("InitStructuredVar(%s) field=%s ofs=%" I32_SPEC "u total_size=%" I32_SPEC "u total_len=%" I32_SPEC "u value=>%s< >%s<\n",

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR f$[rsp]
	add	rcx, 104				; 00000068H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rdx+rax+24]
	mov	QWORD PTR [rsp+56], rax
	mov	QWORD PTR [rsp+48], rcx
	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR f$[rsp]
	mov	r9d, DWORD PTR [rax+16]
	mov	rax, QWORD PTR f$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR symtype$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11286
	call	DoDebugMsg1

; 242  :                   symtype->sym.name,
; 243  :                   f->sym.name,
; 244  :                   f->sym.offset,
; 245  :                   f->sym.total_size,
; 246  :                   f->sym.total_length,
; 247  :                   //f->initializer ? f->initializer : "NULL",
; 248  :                   f->ivalue, tokenarray[i].tokpos ));
; 249  : 
; 250  :         /* is it a RECORD field? */
; 251  :         if ( f->sym.mem_type == MT_BITS ) {

	mov	rax, QWORD PTR f$[rsp]
	cmp	DWORD PTR [rax+36], 193			; 000000c1H
	jne	$LN19@InitStruct

; 252  :             if ( tokenarray[i].token == T_COMMA || tokenarray[i].token == T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN23@InitStruct
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	$LN21@InitStruct
$LN23@InitStruct:

; 253  :                 if ( f->ivalue[0] ) {

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR f$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+104]
	test	eax, eax
	je	SHORT $LN24@InitStruct

; 254  :                     int j = Token_Count + 1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR j$3[rsp], eax

; 255  :                     int max_item = Tokenize( f->ivalue, j, tokenarray, TOK_RESCAN );

	mov	rax, QWORD PTR f$[rsp]
	add	rax, 104				; 00000068H
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR j$3[rsp]
	mov	rcx, rax
	call	Tokenize
	mov	DWORD PTR max_item$7[rsp], eax

; 256  :                     EvalOperand( &j, tokenarray, max_item, &opndx, 0 );

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR max_item$7[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR j$3[rsp]
	call	EvalOperand

; 257  :                     is_record_set = TRUE;

	mov	BYTE PTR is_record_set$[rsp], 1

; 258  :                 } else {

	jmp	SHORT $LN25@InitStruct
$LN24@InitStruct:

; 259  :                     opndx.value = 0;

	mov	DWORD PTR opndx$[rsp], 0

; 260  :                     opndx.kind = EXPR_CONST;

	mov	DWORD PTR opndx$[rsp+60], 0

; 261  :                     opndx.quoted_string = NULL;

	mov	QWORD PTR opndx$[rsp+16], 0
$LN25@InitStruct:

; 262  :                 }
; 263  :             } else {

	jmp	SHORT $LN22@InitStruct
$LN21@InitStruct:

; 264  :                 EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 );

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand

; 265  :                 is_record_set = TRUE;

	mov	BYTE PTR is_record_set$[rsp], 1
$LN22@InitStruct:

; 266  :             }
; 267  :             if ( opndx.kind != EXPR_CONST || opndx.quoted_string != NULL )

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN27@InitStruct
	cmp	QWORD PTR opndx$[rsp+16], 0
	je	SHORT $LN26@InitStruct
$LN27@InitStruct:

; 268  :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError
$LN26@InitStruct:

; 269  : 
; 270  :             /* fixme: max bits in 64-bit is 64 - see MAXRECBITS! */
; 271  :             if ( f->sym.total_size < 32 ) {

	mov	rax, QWORD PTR f$[rsp]
	cmp	DWORD PTR [rax+56], 32			; 00000020H
	jae	SHORT $LN28@InitStruct

; 272  :                 uint_32 dwMax = (1 << f->sym.total_size);

	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	ecx, 1
	mov	DWORD PTR tv612[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv612[rsp]
	shl	eax, cl
	mov	DWORD PTR dwMax$8[rsp], eax

; 273  :                 if ( opndx.value >= dwMax )

	mov	eax, DWORD PTR dwMax$8[rsp]
	cmp	DWORD PTR opndx$[rsp], eax
	jb	SHORT $LN29@InitStruct

; 274  :                     EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, f->sym.name );

	mov	rax, QWORD PTR f$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 172				; 000000acH
	call	EmitErr
$LN29@InitStruct:
$LN28@InitStruct:

; 275  :             }
; 276  : #if AMD64_SUPPORT
; 277  :             dwRecInit |= opndx.llvalue << f->sym.offset;

	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+16]
	movzx	ecx, al
	mov	rax, QWORD PTR opndx$[rsp]
	shl	rax, cl
	mov	rcx, QWORD PTR dwRecInit$[rsp]
	or	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dwRecInit$[rsp], rax
	jmp	$LN20@InitStruct
$LN19@InitStruct:

; 278  : #else
; 279  :             dwRecInit |= opndx.value << f->sym.offset;
; 280  : #endif
; 281  : 
; 282  :         //} else if ( f->init_dir == NULL ) {  /* embedded struct? */
; 283  :         } else if ( f->ivalue[0] == NULLC ) {  /* embedded struct? */

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR f$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+104]
	test	eax, eax
	jne	SHORT $LN30@InitStruct

; 284  : 
; 285  :             InitStructuredVar( i, tokenarray, (struct dsym *)f->sym.type, &f->sym );

	mov	rax, QWORD PTR f$[rsp]
	mov	r9, rax
	mov	rax, QWORD PTR f$[rsp]
	mov	r8, QWORD PTR [rax+80]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	InitStructuredVar

; 286  :             if ( tokenarray[i].token == T_STRING )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN32@InitStruct

; 287  :                 i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN32@InitStruct:

; 288  : 
; 289  :         } else if ( f->sym.isarray &&

	jmp	$LN31@InitStruct
$LN30@InitStruct:

; 290  :                     tokenarray[i].token != T_FINAL &&

	mov	rax, QWORD PTR f$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN33@InitStruct
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN33@InitStruct
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN33@InitStruct

; 291  :                     tokenarray[i].token != T_COMMA ) {
; 292  :             if ( ERROR == InitializeArray( f, &i, tokenarray ) )

	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	call	InitializeArray
	cmp	eax, -1
	jne	SHORT $LN35@InitStruct

; 293  :                 break;

	jmp	$LN3@InitStruct
$LN35@InitStruct:

; 294  : 
; 295  :         } else if ( f->sym.total_size == f->sym.total_length &&

	jmp	$LN34@InitStruct
$LN33@InitStruct:

; 296  :                    tokenarray[i].token == T_STRING &&
; 297  :                    tokenarray[i].stringlen > 1 &&

	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	cmp	DWORD PTR [rax+56], ecx
	jne	$LN36@InitStruct
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN36@InitStruct
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 1
	jbe	SHORT $LN36@InitStruct
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN38@InitStruct
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN36@InitStruct
$LN38@InitStruct:

; 298  :                    ( tokenarray[i].string_delim == '"' ||
; 299  :                     tokenarray[i].string_delim == '\'' ) ) {
; 300  :             /* v2.07: it's a byte type, but no array, string initializer must have true length 1 */
; 301  :             EmitError( STRING_OR_TEXT_LITERAL_TOO_LONG );

	mov	ecx, 155				; 0000009bH
	call	EmitError

; 302  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 303  :         } else {

	jmp	$LN37@InitStruct
$LN36@InitStruct:

; 304  :             //struct asym *sym;
; 305  :             uint_32 no_of_bytes = SizeFromMemtype( f->sym.mem_type, USE_EMPTY, f->sym.type );

	mov	rax, QWORD PTR f$[rsp]
	mov	r8, QWORD PTR [rax+80]
	mov	edx, 254				; 000000feH
	mov	rax, QWORD PTR f$[rsp]
	mov	ecx, DWORD PTR [rax+36]
	call	SizeFromMemtype
	mov	DWORD PTR no_of_bytes$5[rsp], eax

; 306  : 
; 307  :             /* v2.09: check for empty <> or {} string if a struct/union is embedded */
; 308  :             //for ( sym = f->sym->type; sym && sym->type; sym = sym->type );
; 309  : 
; 310  :             if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN41@InitStruct
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	$LN39@InitStruct
$LN41@InitStruct:

; 311  :                 int tc = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR tc$9[rsp], eax

; 312  :                 int j = Token_Count+1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR j$4[rsp], eax

; 313  :                 Token_Count = Tokenize( f->ivalue, j, tokenarray, TOK_RESCAN );

	mov	rax, QWORD PTR f$[rsp]
	add	rax, 104				; 00000068H
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR j$4[rsp]
	mov	rcx, rax
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 314  :                 data_item( &j, tokenarray, NULL, no_of_bytes, f->sym.type, 1, FALSE, f->sym.mem_type & MT_FLOAT, FALSE, Token_Count );

	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 32					; 00000020H
	mov	ecx, DWORD PTR ModuleInfo+496
	mov	DWORD PTR [rsp+72], ecx
	mov	BYTE PTR [rsp+64], 0
	mov	BYTE PTR [rsp+56], al
	mov	BYTE PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 1
	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR no_of_bytes$5[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR j$4[rsp]
	call	data_item

; 315  :                 Token_Count = tc;

	mov	eax, DWORD PTR tc$9[rsp]
	mov	DWORD PTR ModuleInfo+496, eax

; 316  :             } else {

	jmp	$LN40@InitStruct
$LN39@InitStruct:

; 317  :                 char c;
; 318  :                 int j = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR j$6[rsp], eax

; 319  :                 /* ignore commas enclosed in () ( might occur inside DUP argument! ).
; 320  :                  */
; 321  :                 for ( lvl = 0, c = 0; tokenarray[i].token != T_FINAL; i++ ) {

	mov	DWORD PTR lvl$[rsp], 0
	mov	BYTE PTR c$1[rsp], 0
	jmp	SHORT $LN7@InitStruct
$LN5@InitStruct:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@InitStruct:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN6@InitStruct

; 322  :                     if ( tokenarray[i].token == T_OP_BRACKET )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN42@InitStruct

; 323  :                         lvl++;

	mov	eax, DWORD PTR lvl$[rsp]
	inc	eax
	mov	DWORD PTR lvl$[rsp], eax
	jmp	$LN43@InitStruct
$LN42@InitStruct:

; 324  :                     else if ( tokenarray[i].token == T_CL_BRACKET )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN44@InitStruct

; 325  :                         lvl--;

	mov	eax, DWORD PTR lvl$[rsp]
	dec	eax
	mov	DWORD PTR lvl$[rsp], eax
	jmp	SHORT $LN45@InitStruct
$LN44@InitStruct:

; 326  :                     else if ( lvl == 0 && tokenarray[i].token == T_COMMA )

	cmp	DWORD PTR lvl$[rsp], 0
	jne	SHORT $LN46@InitStruct
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN46@InitStruct

; 327  :                         break;

	jmp	SHORT $LN6@InitStruct
	jmp	SHORT $LN47@InitStruct
$LN46@InitStruct:

; 328  :                     else if ( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_DUP )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 7
	jne	SHORT $LN48@InitStruct
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 259		; 00000103H
	jne	SHORT $LN48@InitStruct

; 329  :                         c++; /* v2.08: check added */

	movzx	eax, BYTE PTR c$1[rsp]
	inc	al
	mov	BYTE PTR c$1[rsp], al
$LN48@InitStruct:
$LN47@InitStruct:
$LN45@InitStruct:
$LN43@InitStruct:

; 330  :                 }

	jmp	$LN5@InitStruct
$LN6@InitStruct:

; 331  :                 if ( c ) {

	movsx	eax, BYTE PTR c$1[rsp]
	test	eax, eax
	je	SHORT $LN49@InitStruct

; 332  :                     EmitErr( INITIALIZER_MUST_BE_A_STRING_OR_SINGLE_ITEM, tokenarray[j].tokpos );

	movsxd	rax, DWORD PTR j$6[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 152				; 00000098H
	call	EmitErr

; 333  :                 } else

	jmp	SHORT $LN50@InitStruct
$LN49@InitStruct:

; 334  :                     if ( ERROR == data_item( &j, tokenarray, NULL, no_of_bytes, f->sym.type, 1, FALSE, f->sym.mem_type & MT_FLOAT, FALSE, i ) ) {

	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 32					; 00000020H
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rsp+72], ecx
	mov	BYTE PTR [rsp+64], 0
	mov	BYTE PTR [rsp+56], al
	mov	BYTE PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 1
	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR no_of_bytes$5[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR j$6[rsp]
	call	data_item
	cmp	eax, -1
	jne	SHORT $LN51@InitStruct

; 335  :                         EmitErr( INVALID_DATA_INITIALIZER, f->sym.name );

	mov	rax, QWORD PTR f$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 231				; 000000e7H
	call	EmitErr
$LN51@InitStruct:
$LN50@InitStruct:
$LN40@InitStruct:
$LN37@InitStruct:
$LN34@InitStruct:
$LN31@InitStruct:
$LN20@InitStruct:

; 336  :                     }
; 337  :             }
; 338  :         }
; 339  :         /* Add padding bytes if necessary (never inside RECORDS!).
; 340  :          * f->next == NULL : it's the last field of the struct/union/record
; 341  :          */
; 342  :         if ( symtype->sym.typekind != TYPE_RECORD ) {

	mov	rax, QWORD PTR symtype$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 4
	je	$LN52@InitStruct

; 343  :             if ( f->next == NULL || symtype->sym.typekind == TYPE_UNION )

	mov	rax, QWORD PTR f$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN55@InitStruct
	mov	rax, QWORD PTR symtype$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	jne	SHORT $LN53@InitStruct
$LN55@InitStruct:

; 344  :                 nextofs = symtype->sym.total_size;

	mov	rax, QWORD PTR symtype$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR nextofs$[rsp], eax
	jmp	SHORT $LN54@InitStruct
$LN53@InitStruct:

; 345  :             else
; 346  :                 nextofs = f->next->sym.offset;

	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR nextofs$[rsp], eax
$LN54@InitStruct:

; 347  : 
; 348  :             if ( f->sym.offset + f->sym.total_size < nextofs ) {

	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR f$[rsp]
	add	eax, DWORD PTR [rcx+56]
	cmp	eax, DWORD PTR nextofs$[rsp]
	jae	SHORT $LN56@InitStruct

; 349  :                 DebugMsg1(("InitStructuredVar: padding, field=%s ofs=%" I32_SPEC "X total=%" I32_SPEC "X nextofs=%" I32_SPEC "X\n",

	mov	eax, DWORD PTR nextofs$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR f$[rsp]
	mov	r9d, DWORD PTR [rax+56]
	mov	rax, QWORD PTR f$[rsp]
	mov	r8d, DWORD PTR [rax+16]
	mov	rax, QWORD PTR f$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11325
	call	DoDebugMsg1

; 350  :                           f->sym.name, f->sym.offset, f->sym.total_size, nextofs ));
; 351  :                 SetCurrOffset( CurrSeg, nextofs - (f->sym.offset + f->sym.total_size), TRUE, TRUE );

	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR f$[rsp]
	add	eax, DWORD PTR [rcx+56]
	mov	ecx, DWORD PTR nextofs$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	r9b, 1
	mov	r8b, 1
	mov	edx, eax
	mov	rcx, QWORD PTR ModuleInfo+432
	call	SetCurrOffset
$LN56@InitStruct:
$LN52@InitStruct:

; 352  :             }
; 353  :         }
; 354  :         /* for a union, just the first field is initialized */
; 355  :         if ( symtype->sym.typekind == TYPE_UNION )

	mov	rax, QWORD PTR symtype$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	jne	SHORT $LN57@InitStruct

; 356  :             break;

	jmp	$LN3@InitStruct
$LN57@InitStruct:

; 357  : 
; 358  :         if ( f->next != NULL ) {

	mov	rax, QWORD PTR f$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	$LN58@InitStruct

; 359  : 
; 360  :             if ( tokenarray[i].token != T_FINAL )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN59@InitStruct

; 361  :                 if ( tokenarray[i].token == T_COMMA )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN60@InitStruct

; 362  :                     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN61@InitStruct
$LN60@InitStruct:

; 363  :                 else {
; 364  :                     EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN8@InitStruct:

; 365  :                     while ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN9@InitStruct
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN9@InitStruct

; 366  :                         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN8@InitStruct
$LN9@InitStruct:
$LN61@InitStruct:
$LN59@InitStruct:
$LN58@InitStruct:

; 367  :                 }
; 368  :         }
; 369  :     }  /* end for */

	jmp	$LN2@InitStruct
$LN3@InitStruct:

; 370  : 
; 371  :     if ( symtype->sym.typekind == TYPE_RECORD ) {

	mov	rax, QWORD PTR symtype$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 4
	jne	$LN62@InitStruct

; 372  :         int no_of_bytes;
; 373  :         switch ( symtype->sym.mem_type ) {

	mov	rax, QWORD PTR symtype$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR tv494[rsp], eax
	cmp	DWORD PTR tv494[rsp], 0
	je	SHORT $LN63@InitStruct
	cmp	DWORD PTR tv494[rsp], 1
	je	SHORT $LN64@InitStruct
	cmp	DWORD PTR tv494[rsp], 7
	je	SHORT $LN65@InitStruct
	jmp	SHORT $LN66@InitStruct
$LN63@InitStruct:

; 374  :         case MT_BYTE: no_of_bytes = 1; break;

	mov	DWORD PTR no_of_bytes$2[rsp], 1
	jmp	SHORT $LN10@InitStruct
$LN64@InitStruct:

; 375  :         case MT_WORD: no_of_bytes = 2; break;

	mov	DWORD PTR no_of_bytes$2[rsp], 2
	jmp	SHORT $LN10@InitStruct
$LN65@InitStruct:

; 376  : #if AMD64_SUPPORT
; 377  :         case MT_QWORD: no_of_bytes = 8; break;

	mov	DWORD PTR no_of_bytes$2[rsp], 8
	jmp	SHORT $LN10@InitStruct
$LN66@InitStruct:

; 378  : #endif
; 379  :         default: no_of_bytes = 4;

	mov	DWORD PTR no_of_bytes$2[rsp], 4
$LN10@InitStruct:

; 380  :         }
; 381  :         if ( is_record_set )

	movzx	eax, BYTE PTR is_record_set$[rsp]
	test	eax, eax
	je	SHORT $LN67@InitStruct

; 382  :             OutputDataBytes( (uint_8 *)&dwRecInit, no_of_bytes );

	xor	r8d, r8d
	mov	edx, DWORD PTR no_of_bytes$2[rsp]
	lea	rcx, QWORD PTR dwRecInit$[rsp]
	call	OutputBytes
	jmp	SHORT $LN68@InitStruct
$LN67@InitStruct:

; 383  :         else
; 384  :             SetCurrOffset( CurrSeg, no_of_bytes, TRUE, TRUE );

	mov	r9b, 1
	mov	r8b, 1
	mov	edx, DWORD PTR no_of_bytes$2[rsp]
	mov	rcx, QWORD PTR ModuleInfo+432
	call	SetCurrOffset
$LN68@InitStruct:
$LN62@InitStruct:

; 385  :     }
; 386  : 
; 387  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN69@InitStruct

; 388  :         DebugMsg1(("InitStructuredVar(%s): error, i=%u token=%s\n", symtype->sym.name, i, tokenarray[i].string_ptr ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r9, QWORD PTR [rcx+rax+8]
	mov	r8d, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR symtype$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11339
	call	DoDebugMsg1

; 389  :         EmitErr( TOO_MANY_INITIAL_VALUES_FOR_STRUCTURE, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 153				; 00000099H
	call	EmitErr
$LN69@InitStruct:

; 390  :     }
; 391  : 
; 392  :     /* restore token status */
; 393  :     Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax

; 394  :     StringBufferEnd = old_stringbufferend;

	mov	rax, QWORD PTR old_stringbufferend$[rsp]
	mov	QWORD PTR ModuleInfo+488, rax

; 395  :     DebugMsg1(("InitStructuredVar(%s) exit, current ofs=%" I32_SPEC "X\n", symtype->sym.name, GetCurrOffset() ));

	call	GetCurrOffset
	mov	r8d, eax
	mov	rax, QWORD PTR symtype$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11340
	call	DoDebugMsg1

; 396  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@InitStruct:

; 397  : }

	add	rsp, 312				; 00000138H
	ret	0
InitStructuredVar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\data.c
_TEXT	SEGMENT
j$ = 80
bArray$ = 84
i$ = 88
no_of_bytes$ = 92
filler$1 = 96
lvl$ = 100
rc$ = 104
oldofs$ = 108
old_tokencount$ = 112
tv81 = 120
f$ = 144
pi$ = 152
tokenarray$ = 160
InitializeArray PROC

; 74   : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 75   :     uint_32 oldofs;
; 76   :     uint_32 no_of_bytes;
; 77   :     int  i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 78   :     int  j;
; 79   :     int  lvl;
; 80   :     int old_tokencount;
; 81   :     char bArray;
; 82   :     ret_code rc;
; 83   : 
; 84   :     oldofs = GetCurrOffset();

	call	GetCurrOffset
	mov	DWORD PTR oldofs$[rsp], eax

; 85   :     no_of_bytes = SizeFromMemtype( f->sym.mem_type, USE_EMPTY, f->sym.type );

	mov	rax, QWORD PTR f$[rsp]
	mov	r8, QWORD PTR [rax+80]
	mov	edx, 254				; 000000feH
	mov	rax, QWORD PTR f$[rsp]
	mov	ecx, DWORD PTR [rax+36]
	call	SizeFromMemtype
	mov	DWORD PTR no_of_bytes$[rsp], eax

; 86   : 
; 87   :     DebugMsg1(("InitializeArray(%s) enter, items=%" I32_SPEC "u size=%" I32_SPEC "u mem_type=%xh type=%s currofs=%" I32_SPEC "X [%s]\n",

	mov	rax, QWORD PTR f$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN32@Initialize
	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv81[rsp], rax
	jmp	SHORT $LN33@Initialize
$LN32@Initialize:
	lea	rax, OFFSET FLAT:$SG11193
	mov	QWORD PTR tv81[rsp], rax
$LN33@Initialize:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR [rsp+56], rax
	mov	eax, DWORD PTR oldofs$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR tv81[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR no_of_bytes$[rsp]
	mov	rax, QWORD PTR f$[rsp]
	mov	r8d, DWORD PTR [rax+64]
	mov	rax, QWORD PTR f$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11194
	call	DoDebugMsg1

; 88   :                f->sym.name, f->sym.total_length, no_of_bytes, f->sym.mem_type,
; 89   :                f->sym.type ? f->sym.type->name : "NULL", oldofs, tokenarray[i].tokpos ));
; 90   : 
; 91   :     /* If current item is a literal enclosed in <> or {}, just use this
; 92   :      * item. Else, use all items until a comma or EOL is found.
; 93   :      */
; 94   : 
; 95   :     if ( tokenarray[i].token != T_STRING ||

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN7@Initialize
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	$LN5@Initialize
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 123				; 0000007bH
	je	$LN5@Initialize
$LN7@Initialize:

; 96   :          ( tokenarray[i].string_delim != '<' &&
; 97   :            tokenarray[i].string_delim != '{' )) {
; 98   : 
; 99   :         /* scan for comma or final. Ignore commas inside DUP argument */
; 100  :         for( j = i, lvl = 0, bArray = FALSE; tokenarray[j].token != T_FINAL; j++ ) {

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR j$[rsp], eax
	mov	DWORD PTR lvl$[rsp], 0
	mov	BYTE PTR bArray$[rsp], 0
	jmp	SHORT $LN4@Initialize
$LN2@Initialize:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN4@Initialize:
	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN3@Initialize

; 101  :             if ( tokenarray[j].token == T_OP_BRACKET )

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN8@Initialize

; 102  :                 lvl++;

	mov	eax, DWORD PTR lvl$[rsp]
	inc	eax
	mov	DWORD PTR lvl$[rsp], eax
	jmp	$LN9@Initialize
$LN8@Initialize:

; 103  :             else if ( tokenarray[j].token == T_CL_BRACKET )

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN10@Initialize

; 104  :                 lvl--;

	mov	eax, DWORD PTR lvl$[rsp]
	dec	eax
	mov	DWORD PTR lvl$[rsp], eax
	jmp	$LN11@Initialize
$LN10@Initialize:

; 105  :             else if ( lvl == 0 && tokenarray[j].token == T_COMMA )

	cmp	DWORD PTR lvl$[rsp], 0
	jne	SHORT $LN12@Initialize
	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN12@Initialize

; 106  :                 break;

	jmp	$LN3@Initialize
	jmp	$LN13@Initialize
$LN12@Initialize:

; 107  :             else if ( tokenarray[j].token == T_RES_ID && tokenarray[j].tokval == T_DUP )

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 7
	jne	SHORT $LN14@Initialize
	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 259		; 00000103H
	jne	SHORT $LN14@Initialize

; 108  :                 bArray = TRUE;

	mov	BYTE PTR bArray$[rsp], 1
	jmp	SHORT $LN15@Initialize
$LN14@Initialize:

; 109  :             else if ( no_of_bytes == 1 && tokenarray[j].token == T_STRING &&

	cmp	DWORD PTR no_of_bytes$[rsp], 1
	jne	SHORT $LN16@Initialize
	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN16@Initialize
	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN17@Initialize
	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN16@Initialize
$LN17@Initialize:

; 110  :                      ( tokenarray[j].string_delim == '"' || tokenarray[j].string_delim == '\'' ))
; 111  :                 bArray = TRUE;

	mov	BYTE PTR bArray$[rsp], 1
$LN16@Initialize:
$LN15@Initialize:
$LN13@Initialize:
$LN11@Initialize:
$LN9@Initialize:

; 112  :         }

	jmp	$LN2@Initialize
$LN3@Initialize:

; 113  :         *pi = j;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR j$[rsp]
	mov	DWORD PTR [rax], ecx

; 114  : 
; 115  :         if ( bArray == FALSE ) {

	movsx	eax, BYTE PTR bArray$[rsp]
	test	eax, eax
	jne	SHORT $LN18@Initialize

; 116  :             DebugMsg1(("InitializeArray(%s): error, array init requires DUP, string or literal\n", f->sym.name ));

	mov	rax, QWORD PTR f$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11209
	call	DoDebugMsg1

; 117  :             return( EmitErr( INITIALIZER_MUST_BE_A_STRING_OR_SINGLE_ITEM, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 152				; 00000098H
	call	EmitErr
	jmp	$LN1@Initialize
$LN18@Initialize:

; 118  :         }
; 119  : 
; 120  :         lvl = tokenarray[j].tokpos - tokenarray[i].tokpos;

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR lvl$[rsp], eax

; 121  : 
; 122  :         /* v2.07: accept an "empty" quoted string as array initializer for byte arrays */
; 123  :         if ( lvl == 2 &&
; 124  :             f->sym.total_size == f->sym.total_length &&

	cmp	DWORD PTR lvl$[rsp], 2
	jne	SHORT $LN19@Initialize
	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	cmp	DWORD PTR [rax+56], ecx
	jne	SHORT $LN19@Initialize
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN21@Initialize
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN19@Initialize
$LN21@Initialize:

; 125  :             ( tokenarray[i].string_delim == '"' || tokenarray[i].string_delim == '\'' ) )
; 126  :             rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0
	jmp	SHORT $LN20@Initialize
$LN19@Initialize:

; 127  :         else {
; 128  :             lvl = i; /* i must remain the start index */

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR lvl$[rsp], eax

; 129  :             rc = data_item( &lvl, tokenarray, NULL, no_of_bytes, f->sym.type, 1, FALSE, f->sym.mem_type & MT_FLOAT, FALSE, j );

	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 32					; 00000020H
	mov	ecx, DWORD PTR j$[rsp]
	mov	DWORD PTR [rsp+72], ecx
	mov	BYTE PTR [rsp+64], 0
	mov	BYTE PTR [rsp+56], al
	mov	BYTE PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 1
	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR no_of_bytes$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR lvl$[rsp]
	call	data_item
	mov	DWORD PTR rc$[rsp], eax
$LN20@Initialize:

; 130  :         }
; 131  : 
; 132  :     } else {

	jmp	$LN6@Initialize
$LN5@Initialize:

; 133  : 
; 134  :         /* initializer is a literal */
; 135  :         (*pi)++;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR pi$[rsp]
	mov	DWORD PTR [rcx], eax

; 136  :         old_tokencount = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR old_tokencount$[rsp], eax

; 137  :         j = Token_Count + 1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR j$[rsp], eax

; 138  :         /* if the string is empty, use the default initializer */
; 139  :         if ( tokenarray[i].stringlen == 0 ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 0
	jne	SHORT $LN22@Initialize

; 140  :             Token_Count = Tokenize( (char *)f->ivalue, j, tokenarray, TOK_RESCAN );

	mov	rax, QWORD PTR f$[rsp]
	add	rax, 104				; 00000068H
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR j$[rsp]
	mov	rcx, rax
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 141  :         } else {

	jmp	SHORT $LN23@Initialize
$LN22@Initialize:

; 142  :             Token_Count = Tokenize( tokenarray[i].string_ptr, j, tokenarray, TOK_RESCAN );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax
$LN23@Initialize:

; 143  :         }
; 144  :         rc = data_item( &j, tokenarray, NULL, no_of_bytes, f->sym.type, 1, FALSE, f->sym.mem_type & MT_FLOAT, FALSE, Token_Count );

	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 32					; 00000020H
	mov	ecx, DWORD PTR ModuleInfo+496
	mov	DWORD PTR [rsp+72], ecx
	mov	BYTE PTR [rsp+64], 0
	mov	BYTE PTR [rsp+56], al
	mov	BYTE PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 1
	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR no_of_bytes$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR j$[rsp]
	call	data_item
	mov	DWORD PTR rc$[rsp], eax

; 145  :         Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax
$LN6@Initialize:

; 146  :     }
; 147  : 
; 148  :     /* get size of array items */
; 149  :     no_of_bytes = GetCurrOffset() - oldofs ;

	call	GetCurrOffset
	sub	eax, DWORD PTR oldofs$[rsp]
	mov	DWORD PTR no_of_bytes$[rsp], eax

; 150  :     DebugMsg1(("InitializeArray(%s): new offset=%X\n", f->sym.name, no_of_bytes + oldofs ));

	mov	eax, DWORD PTR oldofs$[rsp]
	mov	ecx, DWORD PTR no_of_bytes$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	r8d, eax
	mov	rax, QWORD PTR f$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11215
	call	DoDebugMsg1

; 151  : 
; 152  :     if ( no_of_bytes > f->sym.total_size ) {

	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+56]
	cmp	DWORD PTR no_of_bytes$[rsp], eax
	jbe	SHORT $LN24@Initialize

; 153  :         DebugMsg1(("InitializeArray(%s): error, cursize=%u total_size=%u\n", f->sym.name, no_of_bytes, f->sym.total_size ));

	mov	rax, QWORD PTR f$[rsp]
	mov	r9d, DWORD PTR [rax+56]
	mov	r8d, DWORD PTR no_of_bytes$[rsp]
	mov	rax, QWORD PTR f$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11218
	call	DoDebugMsg1

; 154  :         EmitErr( TOO_MANY_INITIAL_VALUES_FOR_ARRAY, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 154				; 0000009aH
	call	EmitErr

; 155  :         rc = ERROR;

	mov	DWORD PTR rc$[rsp], -1
	jmp	$LN25@Initialize
$LN24@Initialize:

; 156  :     } else if ( no_of_bytes < f->sym.total_size ) {

	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+56]
	cmp	DWORD PTR no_of_bytes$[rsp], eax
	jae	$LN26@Initialize

; 157  :         char filler = NULLC;

	mov	BYTE PTR filler$1[rsp], 0

; 158  :         DebugMsg1(("InitializeArray: remaining bytes=%" I32_SPEC "u\n", f->sym.total_size - no_of_bytes ));

	mov	rax, QWORD PTR f$[rsp]
	mov	ecx, DWORD PTR no_of_bytes$[rsp]
	mov	eax, DWORD PTR [rax+56]
	sub	eax, ecx
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11220
	call	DoDebugMsg1

; 159  :         if ( CurrSeg && CurrSeg->e.seginfo->segtype == SEGTYPE_BSS )

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN27@Initialize
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 3
	jne	SHORT $LN27@Initialize

; 160  :             SetCurrOffset( CurrSeg, f->sym.total_size - no_of_bytes, TRUE, TRUE );

	mov	rax, QWORD PTR f$[rsp]
	mov	ecx, DWORD PTR no_of_bytes$[rsp]
	mov	eax, DWORD PTR [rax+56]
	sub	eax, ecx
	mov	r9b, 1
	mov	r8b, 1
	mov	edx, eax
	mov	rcx, QWORD PTR ModuleInfo+432
	call	SetCurrOffset
	jmp	SHORT $LN28@Initialize
$LN27@Initialize:

; 161  :         else {
; 162  :             /* v2.07: if element size is 1 and a string is used as initial value,
; 163  :              * pad array with spaces!
; 164  :              */
; 165  :             if ( f->sym.total_size == f->sym.total_length &&

	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	cmp	DWORD PTR [rax+56], ecx
	jne	SHORT $LN29@Initialize
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR f$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+104]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN30@Initialize
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR f$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+104]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN29@Initialize
$LN30@Initialize:

; 166  :                 ( f->ivalue[0] == '"' || f->ivalue[0] == '\'' ) )
; 167  :                 filler = ' ';

	mov	BYTE PTR filler$1[rsp], 32		; 00000020H
$LN29@Initialize:

; 168  :             FillDataBytes( filler, f->sym.total_size - no_of_bytes );

	mov	rax, QWORD PTR f$[rsp]
	mov	ecx, DWORD PTR no_of_bytes$[rsp]
	mov	eax, DWORD PTR [rax+56]
	sub	eax, ecx
	mov	edx, eax
	movzx	ecx, BYTE PTR filler$1[rsp]
	call	FillDataBytes
$LN28@Initialize:
$LN26@Initialize:
$LN25@Initialize:

; 169  :         }
; 170  :     }
; 171  : 
; 172  :     DebugMsg1(("InitializeArray(%s) exit, curr ofs=%X\n", f->sym.name, GetCurrOffset() ));

	call	GetCurrOffset
	mov	r8d, eax
	mov	rax, QWORD PTR f$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11225
	call	DoDebugMsg1

; 173  :     return( rc );

	mov	eax, DWORD PTR rc$[rsp]
$LN1@Initialize:

; 174  : }

	add	rsp, 136				; 00000088H
	ret	0
InitializeArray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\data.c
_TEXT	SEGMENT
i$ = 80
fixup_type$ = 84
total$ = 88
tmp$ = 92
initwarn$ = 93
string_len$ = 96
level$1 = 100
tv358 = 104
tv610 = 108
opndx$ = 112
tv613 = 224
tv666 = 228
tv465 = 232
tv486 = 236
tmp$2 = 240
tv1058 = 248
pchar$ = 256
tv71 = 264
tv76 = 272
tv254 = 280
tv272 = 288
tv354 = 296
tv501 = 304
tv510 = 312
tv519 = 320
tv681 = 328
tv701 = 336
tv715 = 344
tv757 = 352
fixup$ = 360
start_pos$ = 384
tokenarray$ = 392
sym$ = 400
no_of_bytes$ = 408
type_sym$ = 416
dup$ = 424
inside_struct$ = 432
is_float$ = 440
first$ = 448
end$ = 456
data_item PROC

; 472  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 376				; 00000178H

; 473  :     int                 i;
; 474  :     int                 string_len;
; 475  :     uint_32             total = 0;

	mov	DWORD PTR total$[rsp], 0

; 476  :     bool                initwarn = FALSE;

	mov	BYTE PTR initwarn$[rsp], 0

; 477  :     //unsigned int        count;
; 478  :     uint_8              *pchar;
; 479  :     char                tmp;
; 480  :     enum fixup_types    fixup_type;
; 481  :     struct fixup        *fixup;
; 482  :     struct expr         opndx;
; 483  : 
; 484  :     DebugMsg1(("data_item( idx=%u [%s], label=%s, no_of_bytes=%" I32_SPEC "u, type=%s, dup=%" I32_SPEC "Xh, inside_struct=%u, is_float=%u ) enter\n",

	cmp	QWORD PTR type_sym$[rsp], 0
	je	SHORT $LN170@data_item
	mov	rax, QWORD PTR type_sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv71[rsp], rax
	jmp	SHORT $LN171@data_item
$LN170@data_item:
	lea	rax, OFFSET FLAT:$SG11434
	mov	QWORD PTR tv71[rsp], rax
$LN171@data_item:
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN172@data_item
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv76[rsp], rax
	jmp	SHORT $LN173@data_item
$LN172@data_item:
	lea	rax, OFFSET FLAT:$SG11435
	mov	QWORD PTR tv76[rsp], rax
$LN173@data_item:
	movzx	eax, BYTE PTR is_float$[rsp]
	movzx	ecx, BYTE PTR inside_struct$[rsp]
	mov	rdx, QWORD PTR start_pos$[rsp]
	movsxd	rdx, DWORD PTR [rdx]
	imul	rdx, rdx, 32				; 00000020H
	mov	DWORD PTR [rsp+64], eax
	mov	DWORD PTR [rsp+56], ecx
	mov	eax, DWORD PTR dup$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR tv71[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR no_of_bytes$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR tv76[rsp]
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rax+rdx+24]
	mov	rax, QWORD PTR start_pos$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11436
	call	DoDebugMsg1

; 485  :                *start_pos, tokenarray[*start_pos].tokpos, sym ? sym->name : "NULL",
; 486  :                no_of_bytes, type_sym ? type_sym->name : "NULL",
; 487  :                dup, inside_struct, is_float ));
; 488  : 
; 489  :     for ( ; dup; dup-- ) {

	jmp	SHORT $LN4@data_item
$LN2@data_item:
	mov	eax, DWORD PTR dup$[rsp]
	dec	eax
	mov	DWORD PTR dup$[rsp], eax
$LN4@data_item:
	cmp	DWORD PTR dup$[rsp], 0
	je	$LN3@data_item

; 490  :     i = *start_pos;

	mov	rax, QWORD PTR start_pos$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax
$next_item$199:

; 491  : next_item:  /* <--- continue scan if a comma has been detected */
; 492  :     /* since v1.94, the expression evaluator won't handle strings
; 493  :      * enclosed in <> or {}. That is, in previous versions syntax
; 494  :      * "mov eax,<1>" was accepted, now it's rejected.
; 495  :      */
; 496  :     if ( tokenarray[i].token == T_STRING && ( tokenarray[i].string_delim == '<'  || tokenarray[i].string_delim == '{' ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	$LN20@data_item
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN21@data_item
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 123				; 0000007bH
	jne	$LN20@data_item
$LN21@data_item:

; 497  :         if( type_sym ) {

	cmp	QWORD PTR type_sym$[rsp], 0
	je	$LN22@data_item

; 498  :             DebugMsg1(("data_item(%s): literal/brace found: >%s<, inside_struct=%u, no_of_bytes=%" I32_SPEC "u, curr_ofs=%" I32_SPEC "X\n",

	call	GetCurrOffset
	movzx	ecx, BYTE PTR inside_struct$[rsp]
	movsxd	rdx, DWORD PTR i$[rsp]
	imul	rdx, rdx, 32				; 00000020H
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR no_of_bytes$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rax+rdx+8]
	mov	rax, QWORD PTR type_sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11440
	call	DoDebugMsg1
$LN5@data_item:

; 499  :                        type_sym->name, tokenarray[i].string_ptr, inside_struct, no_of_bytes, GetCurrOffset()));
; 500  : 
; 501  :             /* it's either a real data item - then inside_struct is FALSE -
; 502  :              * or a structure FIELD of arbitrary type.
; 503  :              *
; 504  :              * v2.10: regression in v2.09: alias types weren't skipped for InitStructuredVar()
; 505  :              */
; 506  :             while ( type_sym->type ) type_sym = type_sym->type;

	mov	rax, QWORD PTR type_sym$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN6@data_item
	mov	rax, QWORD PTR type_sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR type_sym$[rsp], rax
	jmp	SHORT $LN5@data_item
$LN6@data_item:

; 507  :             if( inside_struct == FALSE ) {

	movzx	eax, BYTE PTR inside_struct$[rsp]
	test	eax, eax
	jne	SHORT $LN23@data_item

; 508  :                 if ( InitStructuredVar( i, tokenarray, (struct dsym *)type_sym, NULL ) == ERROR )

	xor	r9d, r9d
	mov	r8, QWORD PTR type_sym$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	InitStructuredVar
	cmp	eax, -1
	jne	SHORT $LN25@data_item

; 509  :                     return( ERROR );

	mov	eax, -1
	jmp	$LN1@data_item
$LN25@data_item:

; 510  :             } else {

	jmp	SHORT $LN24@data_item
$LN23@data_item:

; 511  :                 /* v2.09: emit a warning if a TYPEDEF member is a simple type,
; 512  :                  * but is initialized with a literal.
; 513  :                  * Note: Masm complains about such literals only if the struct is instanced OR -Fl is set.
; 514  :                  * fixme: the best solution is to always set type_sym to NULL if
; 515  :                  * the type is a TYPEDEF. if the item is a struct member, then
; 516  :                  * sym is ALWAYS != NULL and the symbol's type can be gained from there.
; 517  :                  * v2.10: aliases are now already skipped here ( see above ).
; 518  :                  */
; 519  :                 //while ( type_sym->type ) /* skip alias types */
; 520  :                 //    type_sym = type_sym->type;
; 521  :                 if( type_sym->typekind == TYPE_TYPEDEF && Parse_Pass == PASS_1 )

	mov	rax, QWORD PTR type_sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	jne	SHORT $LN26@data_item
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN26@data_item

; 522  :                     EmitWarn( 2, COUNT_MUST_BE_POSITIVE_OR_ZERO, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	edx, 208				; 000000d0H
	mov	ecx, 2
	call	EmitWarn
$LN26@data_item:
$LN24@data_item:

; 523  :             }
; 524  : 
; 525  :             total++;

	mov	eax, DWORD PTR total$[rsp]
	inc	eax
	mov	DWORD PTR total$[rsp], eax

; 526  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 527  :             goto item_done;

	jmp	$item_done$200
$LN22@data_item:
$LN20@data_item:

; 528  : #if 0 /* v2.08: just let EvalOperand() emit 'Unexpected literal...' error */
; 529  :         } else {
; 530  :             DebugMsg(("data_item: invalid string initializer >%s<\n", tokenarray[i].tokpos ));
; 531  :             /* Masm accepts invalid initializer strings if they are actually never used
; 532  :              * for initialization.
; 533  :              */
; 534  :             if( inside_struct && Parse_Pass == PASS_1 ) {
; 535  :                 EmitWarn( 2, UNEXPECTED_LITERAL_FOUND_IN_EXPRESSION, tokenarray[i].tokpos );
; 536  :                 tokenarray[i].token = T_QUESTION_MARK;
; 537  :             }
; 538  : #endif
; 539  :         }
; 540  :     }
; 541  : 
; 542  :     if ( tokenarray[i].token == T_QUESTION_MARK )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN27@data_item

; 543  :         opndx.kind = EXPR_EMPTY;

	mov	DWORD PTR opndx$[rsp+60], -2
	jmp	SHORT $LN28@data_item
$LN27@data_item:

; 544  :     else
; 545  :         if ( EvalOperand( &i, tokenarray, end, &opndx, 0 ) == ERROR )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR end$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN29@data_item

; 546  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@data_item
$LN29@data_item:
$LN28@data_item:

; 547  : 
; 548  :     //DebugMsg(("data_item, EvalOperand() returned, opndx.kind=%u\n", opndx.kind ));
; 549  : 
; 550  :     /* handle DUP operator */
; 551  : 
; 552  :     if ( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_DUP ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 7
	jne	$LN30@data_item
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 259		; 00000103H
	jne	$LN30@data_item

; 553  :         /* v2.03: db 'AB' dup (0) is valid syntax! */
; 554  :         //if ( opndx.kind != EXPR_CONST || opndx.string != NULL ) {
; 555  :         if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN31@data_item

; 556  :             DebugMsg(("data_item, error, unexpected kind=%u of DUP's first operand\n", opndx.kind ));

	mov	edx, DWORD PTR opndx$[rsp+60]
	lea	rcx, OFFSET FLAT:$SG11450
	call	DoDebugMsg

; 557  :             /* v2.09: emit a better error msg if a forward ref was used */
; 558  :             if ( opndx.sym && opndx.sym->state == SYM_UNDEFINED )

	cmp	QWORD PTR opndx$[rsp+80], 0
	je	SHORT $LN32@data_item
	mov	rax, QWORD PTR opndx$[rsp+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN32@data_item

; 559  :                 EmitErr( SYMBOL_NOT_DEFINED, opndx.sym->name );

	mov	rax, QWORD PTR opndx$[rsp+80]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr
	jmp	SHORT $LN33@data_item
$LN32@data_item:

; 560  :             else
; 561  :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError
$LN33@data_item:

; 562  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@data_item
$LN31@data_item:

; 563  :         }
; 564  :         /* max dup is 0x7fffffff */
; 565  :         if ( opndx.value < 0 ) {

	cmp	DWORD PTR opndx$[rsp], 0
	jge	SHORT $LN34@data_item

; 566  :             return( EmitError( COUNT_MUST_BE_POSITIVE_OR_ZERO ) );

	mov	ecx, 208				; 000000d0H
	call	EmitError
	jmp	$LN1@data_item
$LN34@data_item:

; 567  :         }
; 568  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 569  :         if( tokenarray[i].token != T_OP_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN35@data_item

; 570  :             DebugMsg(("data_item error, missing '('\n"));

	lea	rcx, OFFSET FLAT:$SG11455
	call	DoDebugMsg

; 571  :             return( EmitErr( EXPECTED, "(" ) );

	lea	rdx, OFFSET FLAT:$SG11456
	mov	ecx, 230				; 000000e6H
	call	EmitErr
	jmp	$LN1@data_item
$LN35@data_item:

; 572  :         }
; 573  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 574  : 
; 575  :         if ( sym )

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN36@data_item

; 576  :             sym->isarray = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+41], al
$LN36@data_item:

; 577  : 
; 578  :         if ( opndx.value == 0 ) {

	cmp	DWORD PTR opndx$[rsp], 0
	jne	$LN37@data_item

; 579  :             int level = 1;

	mov	DWORD PTR level$1[rsp], 1

; 580  :             for ( ; tokenarray[i].token != T_FINAL; i++ ) {

	jmp	SHORT $LN9@data_item
$LN7@data_item:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN9@data_item:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN8@data_item

; 581  :                 if ( tokenarray[i].token == T_OP_BRACKET )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN39@data_item

; 582  :                     level++;

	mov	eax, DWORD PTR level$1[rsp]
	inc	eax
	mov	DWORD PTR level$1[rsp], eax
	jmp	SHORT $LN40@data_item
$LN39@data_item:

; 583  :                 else if ( tokenarray[i].token == T_CL_BRACKET )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN41@data_item

; 584  :                     level--;

	mov	eax, DWORD PTR level$1[rsp]
	dec	eax
	mov	DWORD PTR level$1[rsp], eax
$LN41@data_item:
$LN40@data_item:

; 585  :                 if ( level == 0 )

	cmp	DWORD PTR level$1[rsp], 0
	jne	SHORT $LN42@data_item

; 586  :                     break;

	jmp	SHORT $LN8@data_item
$LN42@data_item:

; 587  :             }

	jmp	SHORT $LN7@data_item
$LN8@data_item:

; 588  :         } else {

	jmp	$LN38@data_item
$LN37@data_item:

; 589  :             DebugMsg1(("data_item(%s): op DUP, count=%" I32_SPEC "Xh, calling data_item()\n", sym ? sym->name : "NULL", opndx.uvalue ));

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN174@data_item
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv254[rsp], rax
	jmp	SHORT $LN175@data_item
$LN174@data_item:
	lea	rax, OFFSET FLAT:$SG11464
	mov	QWORD PTR tv254[rsp], rax
$LN175@data_item:
	mov	r8d, DWORD PTR opndx$[rsp]
	mov	rdx, QWORD PTR tv254[rsp]
	lea	rcx, OFFSET FLAT:$SG11465
	call	DoDebugMsg1

; 590  :             if ( data_item( &i, tokenarray, sym, no_of_bytes, type_sym, opndx.uvalue, inside_struct, is_float, first, end ) == ERROR ) {

	mov	eax, DWORD PTR end$[rsp]
	mov	DWORD PTR [rsp+72], eax
	movzx	eax, BYTE PTR first$[rsp]
	mov	BYTE PTR [rsp+64], al
	movzx	eax, BYTE PTR is_float$[rsp]
	mov	BYTE PTR [rsp+56], al
	movzx	eax, BYTE PTR inside_struct$[rsp]
	mov	BYTE PTR [rsp+48], al
	mov	eax, DWORD PTR opndx$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR type_sym$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR no_of_bytes$[rsp]
	mov	r8, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	data_item
	cmp	eax, -1
	jne	SHORT $LN43@data_item

; 591  :                 DebugMsg(("data_item(%s): op DUP, count=%" I32_SPEC "Xh, returned with error\n", sym ? sym->name : "NULL", opndx.uvalue ));

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN176@data_item
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv272[rsp], rax
	jmp	SHORT $LN177@data_item
$LN176@data_item:
	lea	rax, OFFSET FLAT:$SG11467
	mov	QWORD PTR tv272[rsp], rax
$LN177@data_item:
	mov	r8d, DWORD PTR opndx$[rsp]
	mov	rdx, QWORD PTR tv272[rsp]
	lea	rcx, OFFSET FLAT:$SG11468
	call	DoDebugMsg

; 592  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@data_item
$LN43@data_item:
$LN38@data_item:

; 593  :             }
; 594  :         }
; 595  :         if( tokenarray[i].token != T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN44@data_item

; 596  :             DebugMsg(("data_item: error 'missing ')', exit\n"));

	lea	rcx, OFFSET FLAT:$SG11470
	call	DoDebugMsg

; 597  :             return( EmitErr( EXPECTED, ")" ) );

	lea	rdx, OFFSET FLAT:$SG11471
	mov	ecx, 230				; 000000e6H
	call	EmitErr
	jmp	$LN1@data_item
$LN44@data_item:

; 598  :         }
; 599  :         /* v2.09: SIZE and LENGTH actually don't return values for "first initializer, but
; 600  :          * the "first dimension" values
; 601  :          * v2.11: fixme: if the first dimension is 0 ( opndx.value == 0),
; 602  :          * Masm ignores the expression - may be a Masm bug!
; 603  :          */
; 604  :         if ( sym && first && Parse_Pass == PASS_1 ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN45@data_item
	movzx	eax, BYTE PTR first$[rsp]
	test	eax, eax
	je	SHORT $LN45@data_item
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN45@data_item

; 605  :             sym->first_size = opndx.value * no_of_bytes;

	mov	eax, DWORD PTR opndx$[rsp]
	imul	eax, DWORD PTR no_of_bytes$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 606  :             sym->first_length = opndx.value;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR opndx$[rsp]
	mov	DWORD PTR [rax+48], ecx

; 607  :             first = FALSE;

	mov	BYTE PTR first$[rsp], 0
$LN45@data_item:

; 608  :         }
; 609  : 
; 610  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 611  :         goto item_done;

	jmp	$item_done$200
$LN30@data_item:

; 612  :     }
; 613  :     /* a STRUCT/UNION/RECORD data item needs a literal as initializer */
; 614  :     /* v2.06: changed */
; 615  :     //if( type_sym != NULL && inside_struct == FALSE ) {
; 616  :     //if( type_sym != NULL && type_sym->typekind != TYPE_TYPEDEF ) {
; 617  :     if( type_sym ) {

	cmp	QWORD PTR type_sym$[rsp], 0
	je	$LN46@data_item

; 618  :         /* v2.10: use a temp symbol, so the original type name can be displayed in the error msg. */
; 619  :         const struct asym *tmp = type_sym;

	mov	rax, QWORD PTR type_sym$[rsp]
	mov	QWORD PTR tmp$2[rsp], rax
$LN10@data_item:

; 620  :         /* v2.10: check if target type is a struct/union/record; if yes, it's an error. */
; 621  :         while ( tmp->type ) tmp = tmp->type;

	mov	rax, QWORD PTR tmp$2[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN11@data_item
	mov	rax, QWORD PTR tmp$2[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR tmp$2[rsp], rax
	jmp	SHORT $LN10@data_item
$LN11@data_item:

; 622  :         if ( tmp->typekind != TYPE_TYPEDEF ) {

	mov	rax, QWORD PTR tmp$2[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	je	SHORT $LN47@data_item

; 623  :             DebugMsg1(("data_item: error, type=%s needs literal, >%s<\n", type_sym->name, tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	rax, QWORD PTR type_sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11475
	call	DoDebugMsg1

; 624  :             return( EmitErr( STRUCTURE_IMPROPERLY_INITIALIZED, type_sym->name ) );

	mov	rax, QWORD PTR type_sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 229				; 000000e5H
	call	EmitErr
	jmp	$LN1@data_item
$LN47@data_item:
$LN46@data_item:

; 625  :         }
; 626  :     }
; 627  : 
; 628  :     /* handle '?' */
; 629  :     if ( opndx.kind == EXPR_EMPTY && tokenarray[i].token == T_QUESTION_MARK ) {

	cmp	DWORD PTR opndx$[rsp+60], -2
	jne	$LN48@data_item
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 63					; 0000003fH
	jne	$LN48@data_item

; 630  :         DebugMsg1(("data_item: ? found, curr_ofs=%X\n", GetCurrOffset()));

	call	GetCurrOffset
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11477
	call	DoDebugMsg1

; 631  :         opndx.uvalue = no_of_bytes;

	mov	eax, DWORD PTR no_of_bytes$[rsp]
	mov	DWORD PTR opndx$[rsp], eax

; 632  :         /* tiny optimization for uninitialized arrays */
; 633  :         if ( tokenarray[i+1].token != T_COMMA && i == *start_pos ) {

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN49@data_item
	mov	rax, QWORD PTR start_pos$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$[rsp], eax
	jne	SHORT $LN49@data_item

; 634  :             opndx.uvalue *= dup;

	mov	eax, DWORD PTR opndx$[rsp]
	imul	eax, DWORD PTR dup$[rsp]
	mov	DWORD PTR opndx$[rsp], eax

; 635  :             total += dup;

	mov	eax, DWORD PTR dup$[rsp]
	mov	ecx, DWORD PTR total$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR total$[rsp], eax

; 636  :             dup = 1; /* force loop exit */

	mov	DWORD PTR dup$[rsp], 1

; 637  :         } else {

	jmp	SHORT $LN50@data_item
$LN49@data_item:

; 638  :             total++;

	mov	eax, DWORD PTR total$[rsp]
	inc	eax
	mov	DWORD PTR total$[rsp], eax
$LN50@data_item:

; 639  :         }
; 640  :         if( !inside_struct ) {

	movzx	eax, BYTE PTR inside_struct$[rsp]
	test	eax, eax
	jne	SHORT $LN51@data_item

; 641  :             SetCurrOffset( CurrSeg, opndx.uvalue, TRUE, TRUE );

	mov	r9b, 1
	mov	r8b, 1
	mov	edx, DWORD PTR opndx$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+432
	call	SetCurrOffset
$LN51@data_item:

; 642  :         }
; 643  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 644  :         goto item_done;

	jmp	$item_done$200
$LN48@data_item:

; 645  :     }
; 646  : 
; 647  :     /* warn about initialized data in BSS/AT segments */
; 648  :     if ( Parse_Pass == PASS_2 &&
; 649  :         inside_struct == FALSE  &&
; 650  :         // CurrSeg != NULL &&  /* this is already ensured to be true */
; 651  :         (CurrSeg->e.seginfo->segtype == SEGTYPE_BSS ||
; 652  :          CurrSeg->e.seginfo->segtype == SEGTYPE_ABS) &&

	cmp	DWORD PTR Parse_Pass, 1
	jne	$LN52@data_item
	movzx	eax, BYTE PTR inside_struct$[rsp]
	test	eax, eax
	jne	SHORT $LN52@data_item
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 3
	je	SHORT $LN53@data_item
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 5
	jne	SHORT $LN52@data_item
$LN53@data_item:
	movzx	eax, BYTE PTR initwarn$[rsp]
	test	eax, eax
	jne	SHORT $LN52@data_item

; 653  :         initwarn == FALSE ) {
; 654  :         EmitWarn( 2,

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 3
	jne	SHORT $LN178@data_item
	lea	rax, OFFSET FLAT:$SG11483
	mov	QWORD PTR tv354[rsp], rax
	jmp	SHORT $LN179@data_item
$LN178@data_item:
	lea	rax, OFFSET FLAT:$SG11484
	mov	QWORD PTR tv354[rsp], rax
$LN179@data_item:
	mov	r8, QWORD PTR tv354[rsp]
	mov	edx, 184				; 000000b8H
	mov	ecx, 2
	call	EmitWarn

; 655  :                  INITIALIZED_DATA_NOT_SUPPORTED_IN_SEGMENT,
; 656  :                  (CurrSeg->e.seginfo->segtype == SEGTYPE_BSS) ? "BSS" : "AT" );
; 657  :         initwarn = TRUE;

	mov	BYTE PTR initwarn$[rsp], 1
$LN52@data_item:

; 658  :     };
; 659  : 
; 660  :     switch( opndx.kind ) {

	mov	eax, DWORD PTR opndx$[rsp+60]
	mov	DWORD PTR tv358[rsp], eax
	cmp	DWORD PTR tv358[rsp], -2
	je	SHORT $LN54@data_item
	cmp	DWORD PTR tv358[rsp], 0
	je	$LN59@data_item
	cmp	DWORD PTR tv358[rsp], 1
	je	$LN84@data_item
	cmp	DWORD PTR tv358[rsp], 2
	je	$LN162@data_item
	cmp	DWORD PTR tv358[rsp], 3
	je	SHORT $LN57@data_item
	jmp	$LN163@data_item
$LN54@data_item:

; 661  :     case EXPR_EMPTY:
; 662  :         DebugMsg(("data_item.EMPTY: idx=%u, tokenarray.token=%X\n", i, tokenarray[i].token));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	r8d, eax
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11486
	call	DoDebugMsg

; 663  :         if ( tokenarray[i].token != T_FINAL )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN55@data_item

; 664  :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN56@data_item
$LN55@data_item:

; 665  :         else
; 666  :             EmitError( SYNTAX_ERROR );

	mov	ecx, 45					; 0000002dH
	call	EmitError
$LN56@data_item:

; 667  :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@data_item
$LN57@data_item:

; 668  :     case EXPR_FLOAT:
; 669  :         DebugMsg1(("data_item.FLOAT: >%s<, inside_struct=%u, no_of_bytes=%u, curr_ofs=%X\n",

	call	GetCurrOffset
	movzx	ecx, BYTE PTR inside_struct$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR no_of_bytes$[rsp]
	mov	r8d, ecx
	mov	rax, QWORD PTR opndx$[rsp+16]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11490
	call	DoDebugMsg1

; 670  :                    opndx.float_tok->string_ptr, inside_struct, no_of_bytes, GetCurrOffset()));
; 671  :         if (!inside_struct)

	movzx	eax, BYTE PTR inside_struct$[rsp]
	test	eax, eax
	jne	SHORT $LN58@data_item

; 672  :             output_float( &opndx, no_of_bytes );

	mov	edx, DWORD PTR no_of_bytes$[rsp]
	lea	rcx, QWORD PTR opndx$[rsp]
	call	output_float
$LN58@data_item:

; 673  :         total++;

	mov	eax, DWORD PTR total$[rsp]
	inc	eax
	mov	DWORD PTR total$[rsp], eax

; 674  :         break;

	jmp	$LN12@data_item
$LN59@data_item:

; 675  :     case EXPR_CONST:
; 676  :         if ( is_float ) {

	movzx	eax, BYTE PTR is_float$[rsp]
	test	eax, eax
	je	SHORT $LN60@data_item

; 677  :             return( EmitError( MUST_USE_FLOAT_INITIALIZER ) );

	mov	ecx, 212				; 000000d4H
	call	EmitError
	jmp	$LN1@data_item
$LN60@data_item:

; 678  :         }
; 679  : 
; 680  :         /* a string returned by the evaluator (enclosed in quotes!)? */
; 681  : 
; 682  :         if ( opndx.quoted_string ) {

	cmp	QWORD PTR opndx$[rsp+16], 0
	je	$LN61@data_item

; 683  :             DebugMsg1(("data_item.CONST: string found: >%s<, inside_struct=%u, no_of_bytes=%u, curr_ofs=%X\n",

	call	GetCurrOffset
	movzx	ecx, BYTE PTR inside_struct$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR no_of_bytes$[rsp]
	mov	r8d, ecx
	mov	rax, QWORD PTR opndx$[rsp+16]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11496
	call	DoDebugMsg1

; 684  :                        opndx.quoted_string->string_ptr, inside_struct, no_of_bytes, GetCurrOffset()));
; 685  :             pchar = (uint_8 *)opndx.quoted_string->string_ptr + 1;

	mov	rax, QWORD PTR opndx$[rsp+16]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	QWORD PTR pchar$[rsp], rax

; 686  :             string_len = opndx.quoted_string->stringlen; /* this is the length without quotes */

	mov	rax, QWORD PTR opndx$[rsp+16]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR string_len$[rsp], eax

; 687  : 
; 688  :             /* v2.07: check for empty string for ALL types */
; 689  :             if ( string_len == 0 ) {

	cmp	DWORD PTR string_len$[rsp], 0
	jne	SHORT $LN63@data_item

; 690  :                 if ( inside_struct ) {

	movzx	eax, BYTE PTR inside_struct$[rsp]
	test	eax, eax
	je	SHORT $LN64@data_item

; 691  :                     /* when the struct is declared, it's no error -
; 692  :                      * but won't be accepted when the struct is instanced.
; 693  :                      * v2.07: don't modify string_len! Instead
; 694  :                      * mark field as array!
; 695  :                      */
; 696  :                     //string_len = 1;
; 697  :                     sym->isarray = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+41], al

; 698  :                 } else {

	jmp	SHORT $LN65@data_item
$LN64@data_item:

; 699  :                     return( EmitError( EMPTY_STRING ) ); /* MASM doesn't like "" */

	mov	ecx, 163				; 000000a3H
	call	EmitError
	jmp	$LN1@data_item
$LN65@data_item:
$LN63@data_item:

; 700  :                 }
; 701  :             }
; 702  :             /* a string is only regarded as an array if item size is 1 */
; 703  :             /* else it is regarded as ONE item */
; 704  :             if( no_of_bytes != 1 ) {

	cmp	DWORD PTR no_of_bytes$[rsp], 1
	je	SHORT $LN66@data_item

; 705  :                 if( string_len > no_of_bytes ) {

	mov	eax, DWORD PTR no_of_bytes$[rsp]
	cmp	DWORD PTR string_len$[rsp], eax
	jbe	SHORT $LN67@data_item

; 706  :                     return( EmitError( INITIALIZER_OUT_OF_RANGE ) );

	mov	ecx, 55					; 00000037H
	call	EmitError
	jmp	$LN1@data_item
$LN67@data_item:
$LN66@data_item:

; 707  :                 }
; 708  :             }
; 709  : 
; 710  :             if( sym && Parse_Pass == PASS_1 && string_len > 0 ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN68@data_item
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN68@data_item
	cmp	DWORD PTR string_len$[rsp], 0
	jle	SHORT $LN68@data_item

; 711  :                 total++;

	mov	eax, DWORD PTR total$[rsp]
	inc	eax
	mov	DWORD PTR total$[rsp], eax

; 712  :                 if ( no_of_bytes == 1 && string_len > 1 ) {

	cmp	DWORD PTR no_of_bytes$[rsp], 1
	jne	SHORT $LN69@data_item
	cmp	DWORD PTR string_len$[rsp], 1
	jle	SHORT $LN69@data_item

; 713  :                     total += ( string_len - 1 );

	mov	eax, DWORD PTR total$[rsp]
	mov	ecx, DWORD PTR string_len$[rsp]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	DWORD PTR total$[rsp], eax

; 714  :                     sym->isarray = TRUE; /* v2.07: added */

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+41], al

; 715  :                     if ( first ) {

	movzx	eax, BYTE PTR first$[rsp]
	test	eax, eax
	je	SHORT $LN70@data_item

; 716  :                         sym->first_length = 1;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+48], 1

; 717  :                         sym->first_size = 1;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+44], 1

; 718  :                         first = FALSE; /* avoid to touch first_xxx fields below */

	mov	BYTE PTR first$[rsp], 0
$LN70@data_item:
$LN69@data_item:
$LN68@data_item:

; 719  :                     }
; 720  :                 }
; 721  :             }
; 722  : 
; 723  :             if( !inside_struct ) {

	movzx	eax, BYTE PTR inside_struct$[rsp]
	test	eax, eax
	jne	SHORT $LN71@data_item

; 724  :                 /* anything bigger than a byte must be stored in little-endian
; 725  :                  * format -- LSB first */
; 726  :                 if ( string_len > 1 && no_of_bytes > 1 )

	cmp	DWORD PTR string_len$[rsp], 1
	jle	SHORT $LN72@data_item
	cmp	DWORD PTR no_of_bytes$[rsp], 1
	jbe	SHORT $LN72@data_item

; 727  :                     pchar = little_endian( (const char *)pchar, string_len );

	mov	edx, DWORD PTR string_len$[rsp]
	mov	rcx, QWORD PTR pchar$[rsp]
	call	little_endian
	mov	QWORD PTR pchar$[rsp], rax
$LN72@data_item:

; 728  :                 OutputDataBytes( pchar, string_len );

	xor	r8d, r8d
	mov	edx, DWORD PTR string_len$[rsp]
	mov	rcx, QWORD PTR pchar$[rsp]
	call	OutputBytes

; 729  :                 if ( no_of_bytes > string_len )

	mov	eax, DWORD PTR string_len$[rsp]
	cmp	DWORD PTR no_of_bytes$[rsp], eax
	jbe	SHORT $LN73@data_item

; 730  :                     FillDataBytes( 0, no_of_bytes - string_len );

	mov	eax, DWORD PTR string_len$[rsp]
	mov	ecx, DWORD PTR no_of_bytes$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	xor	ecx, ecx
	call	FillDataBytes
$LN73@data_item:
$LN71@data_item:

; 731  :             }
; 732  :         } else {

	jmp	$LN62@data_item
$LN61@data_item:

; 733  :             /* it's NOT a string */
; 734  :             DebugMsg1(("data_item.CONST: const found, value=%" I32_SPEC "Xh, no_of_bytes=%u, curr_ofs=%" I32_SPEC "X\n", opndx.value, no_of_bytes, GetCurrOffset()));

	call	GetCurrOffset
	mov	r9d, eax
	mov	r8d, DWORD PTR no_of_bytes$[rsp]
	mov	edx, DWORD PTR opndx$[rsp]
	lea	rcx, OFFSET FLAT:$SG11508
	call	DoDebugMsg1

; 735  :             if( !inside_struct ) {

	movzx	eax, BYTE PTR inside_struct$[rsp]
	test	eax, eax
	jne	$LN74@data_item

; 736  :                 /* the evaluator cannot handle types with size > 16.
; 737  :                  * so if a (simple) type is larger ( YMMWORD? ),
; 738  :                  * clear anything which is above.
; 739  :                  */
; 740  :                 if ( no_of_bytes > 16 ) {

	cmp	DWORD PTR no_of_bytes$[rsp], 16
	jbe	SHORT $LN75@data_item

; 741  :                     OutputDataBytes( opndx.chararray, 16 );

	xor	r8d, r8d
	mov	edx, 16
	lea	rcx, QWORD PTR opndx$[rsp]
	call	OutputBytes

; 742  :                     tmp = ( opndx.chararray[15] < 0x80 ? 0 : 0xFF );

	mov	eax, 1
	imul	rax, rax, 15
	movzx	eax, BYTE PTR opndx$[rsp+rax]
	cmp	eax, 128				; 00000080H
	jge	SHORT $LN180@data_item
	mov	DWORD PTR tv465[rsp], 0
	jmp	SHORT $LN181@data_item
$LN180@data_item:
	mov	DWORD PTR tv465[rsp], 255		; 000000ffH
$LN181@data_item:
	movzx	eax, BYTE PTR tv465[rsp]
	mov	BYTE PTR tmp$[rsp], al

; 743  :                     FillDataBytes( tmp, no_of_bytes - 16 );

	mov	eax, DWORD PTR no_of_bytes$[rsp]
	sub	eax, 16
	mov	edx, eax
	movzx	ecx, BYTE PTR tmp$[rsp]
	call	FillDataBytes

; 744  :                 } else {

	jmp	$LN76@data_item
$LN75@data_item:

; 745  :                     /* v2.06: TBYTE/OWORD/XMMWORD: extend a negative value to 16-byte */
; 746  :                     if ( no_of_bytes > sizeof( int_64 ) ) {

	mov	eax, DWORD PTR no_of_bytes$[rsp]
	cmp	rax, 8
	jbe	SHORT $LN77@data_item

; 747  :                         if ( opndx.negative && opndx.value64 < 0 && opndx.hlvalue == 0 )

	mov	eax, DWORD PTR opndx$[rsp+72]
	shr	eax, 5
	and	eax, 1
	test	eax, eax
	je	SHORT $LN78@data_item
	cmp	QWORD PTR opndx$[rsp], 0
	jge	SHORT $LN78@data_item
	cmp	QWORD PTR opndx$[rsp+8], 0
	jne	SHORT $LN78@data_item

; 748  :                             opndx.hlvalue = -1;

	mov	QWORD PTR opndx$[rsp+8], -1
$LN78@data_item:
$LN77@data_item:

; 749  :                     }
; 750  :                     OutputDataBytes( opndx.chararray, no_of_bytes );

	xor	r8d, r8d
	mov	edx, DWORD PTR no_of_bytes$[rsp]
	lea	rcx, QWORD PTR opndx$[rsp]
	call	OutputBytes

; 751  :                     /* check that there's no significant data left
; 752  :                      * which hasn't been emitted.
; 753  :                      */
; 754  :                     /* v2.06: rewritten, now more rigid and checks
; 755  :                      * 1-8 and 10 bytes instead of just 1-4.
; 756  :                      */
; 757  :                     if ( no_of_bytes <= sizeof( int_64 ) ) {

	mov	eax, DWORD PTR no_of_bytes$[rsp]
	cmp	rax, 8
	ja	$LN79@data_item

; 758  :                         tmp = ( opndx.chararray[7] < 0x80 ? 0 : 0xFF );

	mov	eax, 1
	imul	rax, rax, 7
	movzx	eax, BYTE PTR opndx$[rsp+rax]
	cmp	eax, 128				; 00000080H
	jge	SHORT $LN182@data_item
	mov	DWORD PTR tv486[rsp], 0
	jmp	SHORT $LN183@data_item
$LN182@data_item:
	mov	DWORD PTR tv486[rsp], 255		; 000000ffH
$LN183@data_item:
	movzx	eax, BYTE PTR tv486[rsp]
	mov	BYTE PTR tmp$[rsp], al

; 759  :                         memset( opndx.chararray, tmp, no_of_bytes );

	mov	eax, DWORD PTR no_of_bytes$[rsp]
	movsx	ecx, BYTE PTR tmp$[rsp]
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, QWORD PTR opndx$[rsp]
	call	memset

; 760  :                         if ( opndx.llvalue != 0 && opndx.llvalue != -1 ) {

	cmp	QWORD PTR opndx$[rsp], 0
	je	SHORT $LN81@data_item
	cmp	QWORD PTR opndx$[rsp], -1
	je	SHORT $LN81@data_item

; 761  :                             DebugMsg(("data_item.CONST: error, unhandled data is %" I64_SPEC "X_%016" I64_SPEC "X\n", opndx.hlvalue, opndx.llvalue));

	mov	r8, QWORD PTR opndx$[rsp]
	mov	rdx, QWORD PTR opndx$[rsp+8]
	lea	rcx, OFFSET FLAT:$SG11517
	call	DoDebugMsg

; 762  :                             return( EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" ) );

	cmp	QWORD PTR opndx$[rsp+80], 0
	je	SHORT $LN184@data_item
	mov	rax, QWORD PTR opndx$[rsp+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv501[rsp], rax
	jmp	SHORT $LN185@data_item
$LN184@data_item:
	lea	rax, OFFSET FLAT:$SG11518
	mov	QWORD PTR tv501[rsp], rax
$LN185@data_item:
	mov	rdx, QWORD PTR tv501[rsp]
	mov	ecx, 172				; 000000acH
	call	EmitErr
	jmp	$LN1@data_item
$LN81@data_item:

; 763  :                         }

	jmp	SHORT $LN80@data_item
$LN79@data_item:

; 764  :                     } else if ( no_of_bytes == 10 ) {

	cmp	DWORD PTR no_of_bytes$[rsp], 10
	jne	SHORT $LN82@data_item

; 765  :                         //if ( opndx.hlvalue > 0xffff ) {
; 766  :                         if ( opndx.hlvalue > 0xffff && opndx.hlvalue < -0xffff ) {

	cmp	QWORD PTR opndx$[rsp+8], 65535		; 0000ffffH
	jbe	SHORT $LN83@data_item
	cmp	QWORD PTR opndx$[rsp+8], -65535		; ffffffffffff0001H
	jae	SHORT $LN83@data_item

; 767  :                             return( EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" ) );

	cmp	QWORD PTR opndx$[rsp+80], 0
	je	SHORT $LN186@data_item
	mov	rax, QWORD PTR opndx$[rsp+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv510[rsp], rax
	jmp	SHORT $LN187@data_item
$LN186@data_item:
	lea	rax, OFFSET FLAT:$SG11521
	mov	QWORD PTR tv510[rsp], rax
$LN187@data_item:
	mov	rdx, QWORD PTR tv510[rsp]
	mov	ecx, 172				; 000000acH
	call	EmitErr
	jmp	$LN1@data_item
$LN83@data_item:
$LN82@data_item:
$LN80@data_item:
$LN76@data_item:
$LN74@data_item:

; 768  :                         }
; 769  :                     }
; 770  :                 }
; 771  :             }
; 772  :             total++;

	mov	eax, DWORD PTR total$[rsp]
	inc	eax
	mov	DWORD PTR total$[rsp], eax
$LN62@data_item:

; 773  :         }
; 774  :         break;

	jmp	$LN12@data_item
$LN84@data_item:

; 775  :     case EXPR_ADDR:
; 776  :         /* since a fixup will be created, 8 bytes is max.
; 777  :          * there's no way to define an initialized tbyte "far64" address,
; 778  :          * because there's no fixup available for the selector part.
; 779  :          */
; 780  :         if ( no_of_bytes > sizeof(uint_64) ) {

	mov	eax, DWORD PTR no_of_bytes$[rsp]
	cmp	rax, 8
	jbe	SHORT $LN85@data_item

; 781  :             EmitErr( INVALID_DATA_INITIALIZER, sym ? sym->name : "" );

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN188@data_item
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv519[rsp], rax
	jmp	SHORT $LN189@data_item
$LN188@data_item:
	lea	rax, OFFSET FLAT:$SG11524
	mov	QWORD PTR tv519[rsp], rax
$LN189@data_item:
	mov	rdx, QWORD PTR tv519[rsp]
	mov	ecx, 231				; 000000e7H
	call	EmitErr

; 782  :             break;

	jmp	$LN12@data_item
$LN85@data_item:

; 783  :         }
; 784  :         /* indirect addressing (incl. stack variables) is invalid */
; 785  :         if ( opndx.indirect == TRUE ) {

	mov	eax, DWORD PTR opndx$[rsp+72]
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN86@data_item

; 786  :             DebugMsg(("data_item.ADDR: error, indirect=%u, sym=%X\n", opndx.indirect, opndx.sym ));

	mov	eax, DWORD PTR opndx$[rsp+72]
	and	eax, 1
	mov	r8, QWORD PTR opndx$[rsp+80]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11526
	call	DoDebugMsg

; 787  :             EmitError( INVALID_USE_OF_REGISTER );

	mov	ecx, 170				; 000000aaH
	call	EmitError

; 788  :             break;

	jmp	$LN12@data_item
$LN86@data_item:

; 789  :         }
; 790  : #if AMD64_SUPPORT
; 791  :         if ( ModuleInfo.Ofssize != USE64 )

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	je	SHORT $LN87@data_item

; 792  : #endif
; 793  :             if ( opndx.hvalue && ( opndx.hvalue != -1 || opndx.value >= 0 ) ) {

	cmp	DWORD PTR opndx$[rsp+4], 0
	je	SHORT $LN88@data_item
	cmp	DWORD PTR opndx$[rsp+4], -1
	jne	SHORT $LN89@data_item
	cmp	DWORD PTR opndx$[rsp], 0
	jl	SHORT $LN88@data_item
$LN89@data_item:

; 794  :                 /* v2.05: compared to Masm, the above is too restrictive.
; 795  :                  * the line below might be better.
; 796  :                  */
; 797  :                 //if ( opndx.hvalue != 0 && ( opndx.hvalue != -1 || opndx.value == 0 ) ) {
; 798  :                 DebugMsg(("data_item.ADDR: displacement doesn't fit in 32 bits: %" I64_SPEC "X\n", opndx.value64 ));

	mov	rdx, QWORD PTR opndx$[rsp]
	lea	rcx, OFFSET FLAT:$SG11530
	call	DoDebugMsg

; 799  :                 return( EmitConstError( &opndx ) );

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	$LN1@data_item
$LN88@data_item:
$LN87@data_item:

; 800  :             }
; 801  : 
; 802  :         if ( is_float ) {

	movzx	eax, BYTE PTR is_float$[rsp]
	test	eax, eax
	je	SHORT $LN90@data_item

; 803  :             DebugMsg(("data_item.ADDR: error, is_float=%u\n", is_float ));

	movzx	eax, BYTE PTR is_float$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11532
	call	DoDebugMsg

; 804  :             EmitError( MUST_USE_FLOAT_INITIALIZER );

	mov	ecx, 212				; 000000d4H
	call	EmitError

; 805  :             break;

	jmp	$LN12@data_item
$LN90@data_item:

; 806  :         }
; 807  : 
; 808  :         total++;

	mov	eax, DWORD PTR total$[rsp]
	inc	eax
	mov	DWORD PTR total$[rsp], eax

; 809  :         /* for STRUCT fields, don't emit anything! */
; 810  :         if ( inside_struct ) {

	movzx	eax, BYTE PTR inside_struct$[rsp]
	test	eax, eax
	je	SHORT $LN91@data_item

; 811  :             break;

	jmp	$LN12@data_item
$LN91@data_item:

; 812  :         }
; 813  : 
; 814  :         /* determine what type of fixup is to be created */
; 815  : 
; 816  :         switch ( opndx.instr ) {

	mov	eax, DWORD PTR opndx$[rsp+56]
	mov	DWORD PTR tv610[rsp], eax
	mov	eax, DWORD PTR tv610[rsp]
	sub	eax, 230				; 000000e6H
	mov	DWORD PTR tv610[rsp], eax
	cmp	DWORD PTR tv610[rsp], 14
	ja	$LN115@data_item
	movsxd	rax, DWORD PTR tv610[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN198@data_item[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN92@data_item:

; 817  :         case T_SEG:
; 818  :             if ( no_of_bytes < 2 ) {

	cmp	DWORD PTR no_of_bytes$[rsp], 2
	jae	SHORT $LN93@data_item

; 819  :                 DebugMsg(("data_item.ADDR: error, a SEG wont fit in a BYTE\n" ));

	lea	rcx, OFFSET FLAT:$SG11536
	call	DoDebugMsg

; 820  :                 EmitError( MAGNITUDE_TOO_LARGE_FOR_SPECIFIED_SIZE );

	mov	ecx, 76					; 0000004cH
	call	EmitError
$LN93@data_item:

; 821  :             }
; 822  :             fixup_type = FIX_SEG;

	mov	DWORD PTR fixup_type$[rsp], 8

; 823  :             break;

	jmp	$LN14@data_item
$LN94@data_item:

; 824  :         case T_OFFSET:
; 825  :             switch ( no_of_bytes ) {

	mov	eax, DWORD PTR no_of_bytes$[rsp]
	mov	DWORD PTR tv613[rsp], eax
	cmp	DWORD PTR tv613[rsp], 1
	je	SHORT $LN95@data_item
	cmp	DWORD PTR tv613[rsp], 2
	je	SHORT $LN98@data_item
	cmp	DWORD PTR tv613[rsp], 8
	je	SHORT $LN99@data_item
	jmp	SHORT $LN101@data_item
$LN95@data_item:

; 826  :             case 1:
; 827  :                 /* forward reference? */
; 828  :                 if ( Parse_Pass == PASS_1 && opndx.sym && opndx.sym->state == SYM_UNDEFINED ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN96@data_item
	cmp	QWORD PTR opndx$[rsp+80], 0
	je	SHORT $LN96@data_item
	mov	rax, QWORD PTR opndx$[rsp+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN96@data_item

; 829  :                     DebugMsg(("data_item.ADDR: forward reference + OFFSET operator + DB -> may become error in Pass 2\n" ));

	lea	rcx, OFFSET FLAT:$SG11541
	call	DoDebugMsg

; 830  :                     fixup_type = FIX_VOID; /* v2.10: was regression in v2.09 */

	mov	DWORD PTR fixup_type$[rsp], 0

; 831  :                 } else {

	jmp	SHORT $LN97@data_item
$LN96@data_item:

; 832  :                     DebugMsg(("data_item.ADDR: error, an offset wont fit in a BYTE\n" ));

	lea	rcx, OFFSET FLAT:$SG11542
	call	DoDebugMsg

; 833  :                     EmitError( OFFSET_MAGNITUDE_TOO_LARGE );

	mov	ecx, 57					; 00000039H
	call	EmitError

; 834  :                     fixup_type = FIX_OFF8;

	mov	DWORD PTR fixup_type$[rsp], 4
$LN97@data_item:

; 835  :                 }
; 836  :                 break;

	jmp	SHORT $LN16@data_item
$LN98@data_item:

; 837  :             case 2:
; 838  :                 fixup_type = FIX_OFF16;

	mov	DWORD PTR fixup_type$[rsp], 5

; 839  :                 break;

	jmp	SHORT $LN16@data_item
$LN99@data_item:

; 840  : #if AMD64_SUPPORT
; 841  :             case 8:
; 842  :                 if ( ModuleInfo.Ofssize == USE64 ) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	SHORT $LN100@data_item

; 843  :                     fixup_type = FIX_OFF64;

	mov	DWORD PTR fixup_type$[rsp], 7

; 844  :                     break;

	jmp	SHORT $LN16@data_item
$LN100@data_item:
$LN101@data_item:

; 845  :                 }
; 846  : #endif
; 847  :             default:
; 848  :                 if ( opndx.sym && ( GetSymOfssize(opndx.sym) == USE16 ) )

	cmp	QWORD PTR opndx$[rsp+80], 0
	je	SHORT $LN102@data_item
	mov	rcx, QWORD PTR opndx$[rsp+80]
	call	GetSymOfssize
	test	eax, eax
	jne	SHORT $LN102@data_item

; 849  :                     fixup_type = FIX_OFF16;

	mov	DWORD PTR fixup_type$[rsp], 5
	jmp	SHORT $LN103@data_item
$LN102@data_item:

; 850  :                 else
; 851  :                     fixup_type = FIX_OFF32;

	mov	DWORD PTR fixup_type$[rsp], 6
$LN103@data_item:
$LN16@data_item:

; 852  :                 break;
; 853  :             }
; 854  :             break;

	jmp	$LN14@data_item
$LN104@data_item:

; 855  : #if IMAGERELSUPP
; 856  :         case T_IMAGEREL:
; 857  :             if ( no_of_bytes < sizeof(uint_32) ) {

	mov	eax, DWORD PTR no_of_bytes$[rsp]
	cmp	rax, 4
	jae	SHORT $LN105@data_item

; 858  :                 DebugMsg(("data_item.ADDR: IMAGEREL, error, size=%u (should be 4)\n", no_of_bytes ));

	mov	edx, DWORD PTR no_of_bytes$[rsp]
	lea	rcx, OFFSET FLAT:$SG11551
	call	DoDebugMsg

; 859  :                 EmitError( OFFSET_MAGNITUDE_TOO_LARGE );

	mov	ecx, 57					; 00000039H
	call	EmitError
$LN105@data_item:

; 860  :             }
; 861  :             fixup_type = FIX_OFF32_IMGREL;

	mov	DWORD PTR fixup_type$[rsp], 12

; 862  :             break;

	jmp	$LN14@data_item
$LN106@data_item:

; 863  : #endif
; 864  : #if SECTIONRELSUPP
; 865  :         case T_SECTIONREL:
; 866  :             if ( no_of_bytes < sizeof(uint_32) ) {

	mov	eax, DWORD PTR no_of_bytes$[rsp]
	cmp	rax, 4
	jae	SHORT $LN107@data_item

; 867  :                 DebugMsg(("data_item.ADDR: SECTIONREL, error, size=%u (should be 4)\n", no_of_bytes ));

	mov	edx, DWORD PTR no_of_bytes$[rsp]
	lea	rcx, OFFSET FLAT:$SG11554
	call	DoDebugMsg

; 868  :                 EmitError( OFFSET_MAGNITUDE_TOO_LARGE );

	mov	ecx, 57					; 00000039H
	call	EmitError
$LN107@data_item:

; 869  :             }
; 870  :             fixup_type = FIX_OFF32_SECREL;

	mov	DWORD PTR fixup_type$[rsp], 13

; 871  :             break;

	jmp	$LN14@data_item
$LN108@data_item:

; 872  : #endif
; 873  :         case T_LOW:
; 874  :             fixup_type = FIX_OFF8; /* OMF, BIN + GNU-ELF only */

	mov	DWORD PTR fixup_type$[rsp], 4

; 875  :             break;

	jmp	$LN14@data_item
$LN109@data_item:

; 876  :         case T_HIGH:
; 877  :             DebugMsg(("data_item.ADDR: HIGH detected\n"));

	lea	rcx, OFFSET FLAT:$SG11557
	call	DoDebugMsg

; 878  :             fixup_type = FIX_HIBYTE; /* OMF only */

	mov	DWORD PTR fixup_type$[rsp], 11

; 879  :             break;

	jmp	$LN14@data_item
$LN110@data_item:

; 880  :         case T_LOWWORD:
; 881  :             fixup_type = FIX_OFF16;

	mov	DWORD PTR fixup_type$[rsp], 5

; 882  :             if ( no_of_bytes < 2 ) {

	cmp	DWORD PTR no_of_bytes$[rsp], 2
	jae	SHORT $LN111@data_item

; 883  :                 EmitError( MAGNITUDE_TOO_LARGE_FOR_SPECIFIED_SIZE );

	mov	ecx, 76					; 0000004cH
	call	EmitError

; 884  :                 break;

	jmp	$LN14@data_item
$LN111@data_item:

; 885  :             }
; 886  :             break;

	jmp	$LN14@data_item
$LN112@data_item:

; 887  : #if LOHI32
; 888  :         case T_HIGH32:
; 889  :             /* no break */
; 890  : #endif
; 891  :         case T_HIGHWORD:
; 892  :             fixup_type = FIX_VOID;

	mov	DWORD PTR fixup_type$[rsp], 0

; 893  :             EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 894  :             break;

	jmp	$LN14@data_item
$LN113@data_item:

; 895  : #if LOHI32
; 896  :         case T_LOW32:
; 897  :             fixup_type = FIX_OFF32;

	mov	DWORD PTR fixup_type$[rsp], 6

; 898  :             if ( no_of_bytes < 4 ) {

	cmp	DWORD PTR no_of_bytes$[rsp], 4
	jae	SHORT $LN114@data_item

; 899  :                 EmitError( MAGNITUDE_TOO_LARGE_FOR_SPECIFIED_SIZE );

	mov	ecx, 76					; 0000004cH
	call	EmitError

; 900  :                 break;

	jmp	$LN14@data_item
$LN114@data_item:

; 901  :             }
; 902  :             break;

	jmp	$LN14@data_item
$LN115@data_item:

; 903  : #endif
; 904  :         default:
; 905  :             /* size < 2 can work with T_LOW|T_HIGH operator only */
; 906  :             if ( no_of_bytes < 2 ) {

	cmp	DWORD PTR no_of_bytes$[rsp], 2
	jae	SHORT $LN116@data_item

; 907  :                 /* forward reference? */
; 908  :                 if ( Parse_Pass == PASS_1 && opndx.sym && opndx.sym->state == SYM_UNDEFINED )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN117@data_item
	cmp	QWORD PTR opndx$[rsp+80], 0
	je	SHORT $LN117@data_item
	mov	rax, QWORD PTR opndx$[rsp+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN117@data_item

; 909  :                     ;

	jmp	SHORT $LN118@data_item
$LN117@data_item:

; 910  :                 else {
; 911  :                     /* v2.08: accept 1-byte absolute externals */
; 912  :                     if ( opndx.sym && opndx.sym->state == SYM_EXTERNAL && opndx.is_abs == TRUE ) {

	cmp	QWORD PTR opndx$[rsp+80], 0
	je	SHORT $LN119@data_item
	mov	rax, QWORD PTR opndx$[rsp+80]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN119@data_item
	mov	eax, DWORD PTR opndx$[rsp+72]
	shr	eax, 2
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN119@data_item

; 913  :                     } else {

	jmp	SHORT $LN120@data_item
$LN119@data_item:

; 914  :                         DebugMsg(("data_item.ADDR: error, no of bytes=%u\n", no_of_bytes ));

	mov	edx, DWORD PTR no_of_bytes$[rsp]
	lea	rcx, OFFSET FLAT:$SG11569
	call	DoDebugMsg

; 915  :                         EmitError( MAGNITUDE_TOO_LARGE_FOR_SPECIFIED_SIZE );

	mov	ecx, 76					; 0000004cH
	call	EmitError
$LN120@data_item:

; 916  :                     }
; 917  :                     fixup_type = FIX_OFF8;

	mov	DWORD PTR fixup_type$[rsp], 4

; 918  :                     break;

	jmp	$LN14@data_item
$LN118@data_item:
$LN116@data_item:

; 919  :                 }
; 920  :             }
; 921  :             /* if the symbol references a segment or group,
; 922  :              then generate a segment fixup.
; 923  :              */
; 924  :             if ( opndx.sym && (opndx.sym->state == SYM_SEG || opndx.sym->state == SYM_GRP ) ) {

	cmp	QWORD PTR opndx$[rsp+80], 0
	je	SHORT $LN121@data_item
	mov	rax, QWORD PTR opndx$[rsp+80]
	cmp	DWORD PTR [rax+32], 3
	je	SHORT $LN122@data_item
	mov	rax, QWORD PTR opndx$[rsp+80]
	cmp	DWORD PTR [rax+32], 4
	jne	SHORT $LN121@data_item
$LN122@data_item:

; 925  :                 fixup_type = FIX_SEG;

	mov	DWORD PTR fixup_type$[rsp], 8

; 926  :                 break;

	jmp	$LN14@data_item
$LN121@data_item:

; 927  :             }
; 928  : 
; 929  :             switch ( no_of_bytes ) {

	mov	eax, DWORD PTR no_of_bytes$[rsp]
	mov	DWORD PTR tv666[rsp], eax
	cmp	DWORD PTR tv666[rsp], 2
	je	SHORT $LN123@data_item
	cmp	DWORD PTR tv666[rsp], 4
	je	$LN130@data_item
	cmp	DWORD PTR tv666[rsp], 6
	je	$LN146@data_item
	jmp	$LN150@data_item
$LN123@data_item:

; 930  :             case 2:
; 931  :                 /* accept "near16" override, else complain
; 932  :                  * if symbol's offset is 32bit */
; 933  :                 /* v2.06: if condition changed */
; 934  :                 //if ( opndx.explicit == TRUE && opndx.mem_type == MT_NEAR && opndx.Ofssize == USE16 )
; 935  :                 if ( opndx.explicit == TRUE ) {

	mov	eax, DWORD PTR opndx$[rsp+72]
	shr	eax, 1
	and	eax, 1
	cmp	eax, 1
	jne	$LN124@data_item

; 936  :                     if ( SizeFromMemtype( opndx.mem_type, opndx.Ofssize, opndx.type ) > no_of_bytes ) {

	movzx	eax, BYTE PTR opndx$[rsp+69]
	mov	r8, QWORD PTR opndx$[rsp+96]
	mov	edx, eax
	mov	ecx, DWORD PTR opndx$[rsp+64]
	call	SizeFromMemtype
	cmp	eax, DWORD PTR no_of_bytes$[rsp]
	jbe	SHORT $LN126@data_item

; 937  :                         DebugMsg(("data_item.ADDR: error, memtype %X wont fit in a WORD\n", opndx.mem_type));

	mov	edx, DWORD PTR opndx$[rsp+64]
	lea	rcx, OFFSET FLAT:$SG11576
	call	DoDebugMsg

; 938  :                         EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" );

	cmp	QWORD PTR opndx$[rsp+80], 0
	je	SHORT $LN190@data_item
	mov	rax, QWORD PTR opndx$[rsp+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv681[rsp], rax
	jmp	SHORT $LN191@data_item
$LN190@data_item:
	lea	rax, OFFSET FLAT:$SG11577
	mov	QWORD PTR tv681[rsp], rax
$LN191@data_item:
	mov	rdx, QWORD PTR tv681[rsp]
	mov	ecx, 172				; 000000acH
	call	EmitErr
$LN126@data_item:

; 939  :                     };

	jmp	$LN125@data_item
$LN124@data_item:

; 940  :                 } else if ( opndx.sym && opndx.sym->state == SYM_EXTERNAL && opndx.is_abs == TRUE ) {

	cmp	QWORD PTR opndx$[rsp+80], 0
	je	SHORT $LN127@data_item
	mov	rax, QWORD PTR opndx$[rsp+80]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN127@data_item
	mov	eax, DWORD PTR opndx$[rsp+72]
	shr	eax, 2
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN127@data_item

; 941  :                     /* v2.07a: accept ABSolute externals (regression in v2.07) */
; 942  :                 } else if ( opndx.sym &&

	jmp	$LN128@data_item
$LN127@data_item:

; 943  :                            opndx.sym->state != SYM_UNDEFINED &&

	cmp	QWORD PTR opndx$[rsp+80], 0
	je	SHORT $LN129@data_item
	mov	rax, QWORD PTR opndx$[rsp+80]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN129@data_item
	mov	rcx, QWORD PTR opndx$[rsp+80]
	call	GetSymOfssize
	test	eax, eax
	jle	SHORT $LN129@data_item

; 944  :                            ( GetSymOfssize(opndx.sym) > USE16 ) ) {
; 945  :                     DebugMsg(("data_item.ADDR: error, a 32bit offset (%s) wont fit in a WORD\n", opndx.sym->name));

	mov	rax, QWORD PTR opndx$[rsp+80]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11581
	call	DoDebugMsg

; 946  :                     EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" );

	cmp	QWORD PTR opndx$[rsp+80], 0
	je	SHORT $LN192@data_item
	mov	rax, QWORD PTR opndx$[rsp+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv701[rsp], rax
	jmp	SHORT $LN193@data_item
$LN192@data_item:
	lea	rax, OFFSET FLAT:$SG11582
	mov	QWORD PTR tv701[rsp], rax
$LN193@data_item:
	mov	rdx, QWORD PTR tv701[rsp]
	mov	ecx, 172				; 000000acH
	call	EmitErr
$LN129@data_item:
$LN128@data_item:
$LN125@data_item:

; 947  :                 }
; 948  :                 fixup_type = FIX_OFF16;

	mov	DWORD PTR fixup_type$[rsp], 5

; 949  :                 break;

	jmp	$LN18@data_item
$LN130@data_item:

; 950  :             case 4:
; 951  :                 /* masm generates:
; 952  :                  * off32 if curr segment is 32bit,
; 953  :                  * ptr16 if curr segment is 16bit,
; 954  :                  * and ignores type overrides.
; 955  :                  * if it's a NEAR external, size is 16, and
; 956  :                  * format isn't OMF, error 'symbol type conflict'
; 957  :                  * is displayed
; 958  :                  */
; 959  :                 if ( opndx.explicit == TRUE ) {

	mov	eax, DWORD PTR opndx$[rsp+72]
	shr	eax, 1
	and	eax, 1
	cmp	eax, 1
	jne	$LN131@data_item

; 960  :                     if ( opndx.mem_type == MT_FAR ) {

	cmp	DWORD PTR opndx$[rsp+64], 130		; 00000082H
	jne	SHORT $LN133@data_item

; 961  :                         if ( opndx.Ofssize != USE_EMPTY && opndx.Ofssize != USE16 ) {

	movzx	eax, BYTE PTR opndx$[rsp+69]
	cmp	eax, 254				; 000000feH
	je	SHORT $LN135@data_item
	movzx	eax, BYTE PTR opndx$[rsp+69]
	test	eax, eax
	je	SHORT $LN135@data_item

; 962  :                             DebugMsg(("data_item.ADDR: error, FAR32 won't fit in a DWORD\n" ));

	lea	rcx, OFFSET FLAT:$SG11589
	call	DoDebugMsg

; 963  :                             EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" );

	cmp	QWORD PTR opndx$[rsp+80], 0
	je	SHORT $LN194@data_item
	mov	rax, QWORD PTR opndx$[rsp+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv715[rsp], rax
	jmp	SHORT $LN195@data_item
$LN194@data_item:
	lea	rax, OFFSET FLAT:$SG11590
	mov	QWORD PTR tv715[rsp], rax
$LN195@data_item:
	mov	rdx, QWORD PTR tv715[rsp]
	mov	ecx, 172				; 000000acH
	call	EmitErr
$LN135@data_item:

; 964  :                         }
; 965  :                         fixup_type = FIX_PTR16;

	mov	DWORD PTR fixup_type$[rsp], 9
	jmp	SHORT $LN134@data_item
$LN133@data_item:

; 966  :                     } else if ( opndx.mem_type == MT_NEAR ) {

	cmp	DWORD PTR opndx$[rsp+64], 129		; 00000081H
	jne	SHORT $LN136@data_item

; 967  :                         if ( opndx.Ofssize == USE16 )

	movzx	eax, BYTE PTR opndx$[rsp+69]
	test	eax, eax
	jne	SHORT $LN137@data_item

; 968  :                             fixup_type = FIX_OFF16;

	mov	DWORD PTR fixup_type$[rsp], 5
	jmp	SHORT $LN138@data_item
$LN137@data_item:

; 969  :                         else if ( opndx.sym && ( GetSymOfssize( opndx.sym ) == USE16 ) )

	cmp	QWORD PTR opndx$[rsp+80], 0
	je	SHORT $LN139@data_item
	mov	rcx, QWORD PTR opndx$[rsp+80]
	call	GetSymOfssize
	test	eax, eax
	jne	SHORT $LN139@data_item

; 970  :                             fixup_type = FIX_OFF16;

	mov	DWORD PTR fixup_type$[rsp], 5
	jmp	SHORT $LN140@data_item
$LN139@data_item:

; 971  :                         else
; 972  :                             fixup_type = FIX_OFF32;

	mov	DWORD PTR fixup_type$[rsp], 6
$LN140@data_item:
$LN138@data_item:
$LN136@data_item:
$LN134@data_item:

; 973  :                     }
; 974  :                 } else {

	jmp	SHORT $LN132@data_item
$LN131@data_item:

; 975  :                     /* what's done if code size is 16 is Masm-compatible.
; 976  :                      * It's not very smart, however.
; 977  :                      * A better strategy is to choose fixup type depending
; 978  :                      * on the symbol's offset size.
; 979  :                      */
; 980  :                     //if ( opndx.sym && ( GetSymOfssize( opndx.sym ) == USE16 ) )
; 981  :                     if ( ModuleInfo.Ofssize == USE16 )

	movzx	eax, BYTE PTR ModuleInfo+404
	test	eax, eax
	jne	SHORT $LN141@data_item

; 982  : #if COFF_SUPPORT || ELF_SUPPORT
; 983  :                         if ( opndx.mem_type == MT_NEAR &&

	cmp	DWORD PTR opndx$[rsp+64], 129		; 00000081H
	jne	SHORT $LN143@data_item
	cmp	DWORD PTR Options+160, 2
	je	SHORT $LN145@data_item
	cmp	DWORD PTR Options+160, 3
	jne	SHORT $LN143@data_item
$LN145@data_item:

; 984  :                             ( Options.output_format == OFORMAT_COFF
; 985  : #if ELF_SUPPORT
; 986  :                              || Options.output_format == OFORMAT_ELF
; 987  : #endif
; 988  :                             )) {
; 989  :                             fixup_type = FIX_OFF16;

	mov	DWORD PTR fixup_type$[rsp], 5

; 990  :                             EmitErr( SYMBOL_TYPE_CONFLICT, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 136				; 00000088H
	call	EmitErr

; 991  :                         } else

	jmp	SHORT $LN144@data_item
$LN143@data_item:

; 992  : #endif
; 993  :                             fixup_type = FIX_PTR16;

	mov	DWORD PTR fixup_type$[rsp], 9
$LN144@data_item:
	jmp	SHORT $LN142@data_item
$LN141@data_item:

; 994  :                     else
; 995  :                         fixup_type = FIX_OFF32;

	mov	DWORD PTR fixup_type$[rsp], 6
$LN142@data_item:
$LN132@data_item:

; 996  :                 }
; 997  :                 break;

	jmp	$LN18@data_item
$LN146@data_item:

; 998  :             case 6:
; 999  :                 /* Masm generates a PTR32 fixup in OMF!
; 1000 :                  * and a DIR32 fixup in COFF.
; 1001 :                  */
; 1002 :                 /* COFF/ELF has no far fixups */
; 1003 : #if COFF_SUPPORT || ELF_SUPPORT
; 1004 :                 if ( Options.output_format == OFORMAT_COFF
; 1005 : #if ELF_SUPPORT
; 1006 :                     || Options.output_format == OFORMAT_ELF

	cmp	DWORD PTR Options+160, 2
	je	SHORT $LN149@data_item
	cmp	DWORD PTR Options+160, 3
	jne	SHORT $LN147@data_item
$LN149@data_item:

; 1007 : #endif
; 1008 :                    ) {
; 1009 :                     fixup_type = FIX_OFF32;

	mov	DWORD PTR fixup_type$[rsp], 6

; 1010 :                 } else

	jmp	SHORT $LN148@data_item
$LN147@data_item:

; 1011 : #endif
; 1012 :                     fixup_type = FIX_PTR32;

	mov	DWORD PTR fixup_type$[rsp], 10
$LN148@data_item:

; 1013 :                 break;

	jmp	SHORT $LN18@data_item
$LN150@data_item:

; 1014 :             default:
; 1015 :                 /* Masm generates
; 1016 :                  * off32 if curr segment is 32bit
; 1017 :                  * ptr16 if curr segment is 16bit
; 1018 :                  * HJWasm additionally accepts a FAR32 PTR override
; 1019 :                  * and generates a ptr32 fixup then */
; 1020 :                 if ( opndx.explicit == TRUE && opndx.mem_type == MT_FAR && opndx.Ofssize == USE32 )

	mov	eax, DWORD PTR opndx$[rsp+72]
	shr	eax, 1
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN151@data_item
	cmp	DWORD PTR opndx$[rsp+64], 130		; 00000082H
	jne	SHORT $LN151@data_item
	movzx	eax, BYTE PTR opndx$[rsp+69]
	cmp	eax, 1
	jne	SHORT $LN151@data_item

; 1021 :                     fixup_type = FIX_PTR32;

	mov	DWORD PTR fixup_type$[rsp], 10
	jmp	SHORT $LN152@data_item
$LN151@data_item:

; 1022 :                 else if( ModuleInfo.Ofssize == USE32 )

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jne	SHORT $LN153@data_item

; 1023 :                     fixup_type = FIX_OFF32;

	mov	DWORD PTR fixup_type$[rsp], 6
	jmp	SHORT $LN154@data_item
$LN153@data_item:

; 1024 : #if AMD64_SUPPORT
; 1025 :                 else if( ModuleInfo.Ofssize == USE64 )

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	SHORT $LN155@data_item

; 1026 :                     fixup_type = FIX_OFF64;

	mov	DWORD PTR fixup_type$[rsp], 7
	jmp	SHORT $LN156@data_item
$LN155@data_item:

; 1027 : #endif
; 1028 :                 else
; 1029 :                     fixup_type = FIX_PTR16;

	mov	DWORD PTR fixup_type$[rsp], 9
$LN156@data_item:
$LN154@data_item:
$LN152@data_item:
$LN18@data_item:
$LN14@data_item:

; 1030 :             }
; 1031 :             break;
; 1032 :         } /* end switch ( opndx.instr ) */
; 1033 : 
; 1034 :         /* v2.07: fixup type check moved here */
; 1035 :         if ( ( 1 << fixup_type ) & ModuleInfo.fmtopt->invalid_fixup_type ) {

	mov	eax, DWORD PTR fixup_type$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv1058[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv1058[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR ModuleInfo+344
	movsx	ecx, WORD PTR [rcx+8]
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN157@data_item

; 1036 :             return( EmitErr( UNSUPPORTED_FIXUP_TYPE,

	cmp	QWORD PTR opndx$[rsp+80], 0
	je	SHORT $LN196@data_item
	mov	rax, QWORD PTR opndx$[rsp+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv757[rsp], rax
	jmp	SHORT $LN197@data_item
$LN196@data_item:
	lea	rax, OFFSET FLAT:szNull
	mov	QWORD PTR tv757[rsp], rax
$LN197@data_item:
	mov	rax, QWORD PTR ModuleInfo+344
	add	rax, 10
	mov	r8, QWORD PTR tv757[rsp]
	mov	rdx, rax
	mov	ecx, 197				; 000000c5H
	call	EmitErr
	jmp	$LN1@data_item
$LN157@data_item:

; 1037 :                     ModuleInfo.fmtopt->formatname,
; 1038 :                     opndx.sym ? opndx.sym->name : szNull ) );
; 1039 :         }
; 1040 :         fixup = NULL;

	mov	QWORD PTR fixup$[rsp], 0

; 1041 :         if ( write_to_file ) {

	movzx	eax, BYTE PTR write_to_file
	test	eax, eax
	je	SHORT $LN158@data_item

; 1042 :             /* there might be a segment override:
; 1043 :              * a segment, a group or a segment register.
; 1044 :              * Init var SegOverride, it's used inside set_frame()
; 1045 :              */
; 1046 :             SegOverride = NULL;

	mov	QWORD PTR SegOverride, 0

; 1047 :             segm_override( &opndx, NULL );

	xor	edx, edx
	lea	rcx, QWORD PTR opndx$[rsp]
	call	segm_override

; 1048 : 
; 1049 :             /* set global vars Frame and Frame_Datum */
; 1050 :             /* opndx.sym may be NULL, then SegOverride is set. */
; 1051 :             if ( ModuleInfo.offsettype == OT_SEGMENT &&

	cmp	DWORD PTR ModuleInfo+384, 2
	jne	SHORT $LN159@data_item
	cmp	DWORD PTR opndx$[rsp+56], 241		; 000000f1H
	je	SHORT $LN161@data_item
	cmp	DWORD PTR opndx$[rsp+56], 244		; 000000f4H
	jne	SHORT $LN159@data_item
$LN161@data_item:

; 1052 :                 ( opndx.instr == T_OFFSET || opndx.instr == T_SEG ))
; 1053 :                 set_frame2( opndx.sym );

	mov	rcx, QWORD PTR opndx$[rsp+80]
	call	set_frame2
	jmp	SHORT $LN160@data_item
$LN159@data_item:

; 1054 :             else
; 1055 :                 set_frame( opndx.sym );

	mov	rcx, QWORD PTR opndx$[rsp+80]
	call	set_frame
$LN160@data_item:

; 1056 :             /* uses Frame and Frame_Datum  */
; 1057 :             fixup = CreateFixup( opndx.sym, fixup_type, OPTJ_NONE );

	xor	r8d, r8d
	mov	edx, DWORD PTR fixup_type$[rsp]
	mov	rcx, QWORD PTR opndx$[rsp+80]
	call	CreateFixup
	mov	QWORD PTR fixup$[rsp], rax
$LN158@data_item:

; 1058 :             //store_fixup( fixup, &opndx.value ); /* may fail, but ignore error! */
; 1059 :         }
; 1060 :         OutputBytes( (unsigned char *)&opndx.value, no_of_bytes, fixup );

	mov	r8, QWORD PTR fixup$[rsp]
	mov	edx, DWORD PTR no_of_bytes$[rsp]
	lea	rcx, QWORD PTR opndx$[rsp]
	call	OutputBytes

; 1061 :         break;

	jmp	SHORT $LN12@data_item
$LN162@data_item:

; 1062 :     case EXPR_REG:
; 1063 :         EmitError( INVALID_USE_OF_REGISTER );

	mov	ecx, 170				; 000000aaH
	call	EmitError

; 1064 :         break;

	jmp	SHORT $LN12@data_item
$LN163@data_item:

; 1065 :     default: /* unknown opndx.kind, shouldn't happen */
; 1066 :         DebugMsg(("data_item: error, opndx.kind=%u\n", opndx.kind ));

	mov	edx, DWORD PTR opndx$[rsp+60]
	lea	rcx, OFFSET FLAT:$SG11619
	call	DoDebugMsg

; 1067 :         return( EmitError( SYNTAX_ERROR ) );

	mov	ecx, 45					; 0000002dH
	call	EmitError
	jmp	$LN1@data_item
$LN12@data_item:
$item_done$200:

; 1068 :     } /* end switch (opndx.kind) */
; 1069 : item_done:
; 1070 :     if( sym && first && Parse_Pass == PASS_1 ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN164@data_item
	movzx	eax, BYTE PTR first$[rsp]
	test	eax, eax
	je	SHORT $LN164@data_item
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN164@data_item

; 1071 :         sym->first_length = total;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR total$[rsp]
	mov	DWORD PTR [rax+48], ecx

; 1072 :         sym->first_size = total * no_of_bytes;

	mov	eax, DWORD PTR total$[rsp]
	imul	eax, DWORD PTR no_of_bytes$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+44], eax
$LN164@data_item:

; 1073 :     }
; 1074 :     if( i < end && tokenarray[i].token == T_COMMA ) {

	mov	eax, DWORD PTR end$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN165@data_item
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN165@data_item

; 1075 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1076 :         if ( tokenarray[i].token != T_FINAL &&

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN166@data_item
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN166@data_item

; 1077 :             tokenarray[i].token != T_CL_BRACKET ) {
; 1078 :             first = FALSE;

	mov	BYTE PTR first$[rsp], 0

; 1079 :             if ( sym )

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN167@data_item

; 1080 :                 sym->isarray = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+41], al
$LN167@data_item:

; 1081 :             goto next_item;

	jmp	$next_item$199
$LN166@data_item:
$LN165@data_item:

; 1082 :         }
; 1083 :     }
; 1084 : 
; 1085 :     } /* end for */

	jmp	$LN2@data_item
$LN3@data_item:

; 1086 : 
; 1087 :     if( sym && Parse_Pass == PASS_1 ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN168@data_item
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN168@data_item

; 1088 :         sym->total_length += total;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+64]
	add	eax, DWORD PTR total$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+64], eax

; 1089 :         sym->total_size += total * no_of_bytes;

	mov	eax, DWORD PTR total$[rsp]
	imul	eax, DWORD PTR no_of_bytes$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	add	eax, DWORD PTR [rcx+56]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+56], eax
$LN168@data_item:

; 1090 :     }
; 1091 : 
; 1092 :     *start_pos = i;

	mov	rax, QWORD PTR start_pos$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 1093 :     DebugMsg1(("data_item: exit, no error, i=%d\n", i));

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11625
	call	DoDebugMsg1

; 1094 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@data_item:

; 1095 : }

	add	rsp, 376				; 00000178H
	ret	0
	npad	2
$LN198@data_item:
	DD	$LN109@data_item
	DD	$LN112@data_item
	DD	$LN112@data_item
	DD	$LN104@data_item
	DD	$LN115@data_item
	DD	$LN115@data_item
	DD	$LN108@data_item
	DD	$LN113@data_item
	DD	$LN110@data_item
	DD	$LN115@data_item
	DD	$LN115@data_item
	DD	$LN94@data_item
	DD	$LN115@data_item
	DD	$LN106@data_item
	DD	$LN92@data_item
data_item ENDP
_TEXT	ENDS
END
