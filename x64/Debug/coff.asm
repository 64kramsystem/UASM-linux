; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
?init@?1??CRC32Comdat@@9@9 DB 01H DUP (?)		; `CRC32Comdat'::`2'::init
$SG11973 DB	01H DUP (?)
$SG12036 DB	01H DUP (?)
$SG12042 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11426 DB	'.debug$S', 00H
	ORG $+7
$SG11427 DB	'.debug$T', 00H
	ORG $+3
$SG11504 DB	'/%u', 00H
$SG11501 DB	'coff_write_section_table: enter, sections=%u', 0aH, 00H
	ORG $+2
$SG11517 DB	'CONST', 00H
	ORG $+2
$SG11530 DB	'coff_write_section_table(%s): %u fixups (more than 0xfff'
	DB	'f!)!', 0aH, 00H
	ORG $+2
$SG11532 DB	'coff_write_section_table(%s): name=%.8s Fixups=%u, Linnu'
	DB	'ms=%u', 0aH, 00H
	ORG $+1
$SG11534 DB	'coff_write_section_table: exit', 0aH, 00H
$SG11563 DB	'coff.c', 00H
	ORG $+1
$SG11645 DB	'coff_write_symbols: enter', 0aH, 00H
	ORG $+1
$SG11649 DB	'.file', 00H
	ORG $+2
$SG11692 DB	'.bf', 00H
$SG11655 DB	'coff_write_symbols(%u, SECT): %s, type=%x, stgcls=%x', 0aH
	DB	00H
	ORG $+2
$SG11664 DB	'coff_write_symbols(%u, SECT): %s, AUX, relocs=%u, linnum'
	DB	's=%u', 0aH, 00H
	ORG $+2
$SG11666 DB	'coff_write_symbols(EXT+COMM): %s skipped, used=%u, comm='
	DB	'%u, weak=%u', 0aH, 00H
	ORG $+3
$SG11667 DB	'coff_write_symbols(%u, EXT+COMM): %s, type=%x, stgcls=%x'
	DB	0aH, 00H
	ORG $+2
$SG11697 DB	'.lf', 00H
$SG11676 DB	'coff_write_symbols(%u): %s, file=%u', 0aH, 00H
	ORG $+3
$SG11678 DB	'.file', 00H
	ORG $+2
$SG11699 DB	'.ef', 00H
	ORG $+4
$SG11688 DB	'coff_write_symbols(%u, PUB+INT): %s, ofs=%X, type=%X, st'
	DB	'gcls=%X', 0aH, 00H
	ORG $+3
$SG11900 DB	'ofs', 00H
$SG11704 DB	'coff_write_symbols(%u, ALIAS): symbol %s, ofs=%X', 0aH, 00H
	ORG $+2
$SG11901 DB	'idx', 00H
$SG11708 DB	'coff_write_symbols: exit cntSymbols=%u', 0aH, 00H
$SG11811 DB	'coff_write_fixups(%s): enter, num_relocs=%u', 0aH, 00H
	ORG $+3
$SG11837 DB	'coff_write_fixups(%s, %Xh): %s added to symbol table, id'
	DB	'x=%u', 0aH, 00H
	ORG $+2
$SG11883 DB	'coff_write_data: .sxdata value=%08Xh', 0aH, 00H
	ORG $+2
$SG11823 DB	'coff_write_fixups(%s, %Xh): reloc loc=%X type=%u idx=%u '
	DB	'sym=%s', 0aH, 00H
$SG11833 DB	'coff_write_fixups(%s, %Xh): reloc loc=%X type=%u idx=%u '
	DB	'sym=%s', 0aH, 00H
$SG11840 DB	'coff_write_fixups(%s, %Xh): reloc loc=%X type=%u idx=%u '
	DB	'sym=%s', 0aH, 00H
$SG11841 DB	'coff_write_fixups(%s): exit, num_relocs=%u', 0aH, 00H
	ORG $+4
$SG11881 DB	'coff_write_data(%s): enter', 0aH, 00H
	ORG $+4
$SG11887 DB	'coff_write_data(%s, %Xh): size=%X, written=%X, content=['
	DB	'%02X %02X ...]', 0aH, 00H
$SG11888 DB	'coff_write_data(%s, %Xh): size=%X, buffer=NULL', 0aH, 00H
$SG11898 DB	'coff_write_data(%s): writing linnum data', 0aH, 00H
	ORG $+2
$SG11899 DB	'NULL', 00H
	ORG $+7
$SG11902 DB	'coff_write_data(%s, %Xh): linnum, #=%u, %s=%X, sym=%s', 0aH
	DB	00H
	ORG $+1
$SG11907 DB	'coff_write_data(%s, %Xh): error, %s has symbol table ind'
	DB	'ex 0', 0aH, 00H
	ORG $+2
$SG11908 DB	'coff_write_data(%s, %Xh): proc %s start_line=%u', 0aH, 00H
	ORG $+3
$SG11909 DB	'coff.c', 00H
	ORG $+5
$SG11912 DB	'coff_write_data: exit, size of sections=%Xh', 0aH, 00H
	ORG $+3
$SG11974 DB	'coff_create_drectve: %s section added', 0aH, 00H
	ORG $+1
$SG11983 DB	'-export:%s ', 00H
	ORG $+4
$SG11984 DB	'-export:%s=%s ', 00H
	ORG $+1
$SG11987 DB	'-defaultlib:"%s" ', 00H
	ORG $+6
$SG11988 DB	'-defaultlib:%s ', 00H
$SG11990 DB	'-entry:%s ', 00H
	ORG $+5
$SG11993 DB	'-import:', 00H
	ORG $+3
$SG11994 DB	'coff.c', 00H
	ORG $+5
$SG12033 DB	'coff_write_module: enter, sections=%u', 0aH, 00H
	ORG $+1
$SG12037 DB	'coff_write_module: %s section added', 0aH, 00H
	ORG $+3
$SG12043 DB	'.sxdata', 00H
$SG12044 DB	'coff_write_module: .sxdata section added, size=%u', 0aH, 00H
	ORG $+5
$SG12047 DB	'coff_write_module: string_table size=%u', 0aH, 00H
	ORG $+7
$SG12051 DB	'coff_write_module: error writing file header', 0aH, 00H
	ORG $+2
$SG12052 DB	'coff_write_module: exit', 0aH, 00H
_DATA	ENDS
CONST	SEGMENT
SymDebName DQ	FLAT:$SG11426
	DQ	FLAT:$SG11427
szdrectve DB	'.drectve', 00H
	ORG $+7
isFeat00 DB	'@feat.00'
	DD	01H
	DW	0ffffH
	DW	00H
	DB	03H
	DB	00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	coff_init
EXTRN	__imp__time64:PROC
EXTRN	__imp_fseek:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__imp_strchr:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	WriteError:PROC
EXTRN	ConvertSectionName:PROC
EXTRN	LclAlloc:PROC
EXTRN	Mangle:PROC
EXTRN	CreateIntSegment:PROC
EXTRN	GetSegIdx:PROC
EXTRN	AddPublicData:PROC
EXTRN	GetFName:PROC
EXTRN	InternalError:PROC
EXTRN	cv_write_debug_tables:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	_RTC_UninitUse:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	SymTables:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
CRC32Table DD	0100H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$time DD	imagerel time
	DD	imagerel time+47
	DD	imagerel $unwind$time
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$coff_init DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$coff_init
$pdata$Coff_AllocString DD imagerel Coff_AllocString
	DD	imagerel Coff_AllocString+215
	DD	imagerel $unwind$Coff_AllocString
$pdata$GetLinnumItems DD imagerel GetLinnumItems
	DD	imagerel GetLinnumItems+92
	DD	imagerel $unwind$GetLinnumItems
$pdata$coff_write_section_table DD imagerel coff_write_section_table
	DD	imagerel coff_write_section_table+1770
	DD	imagerel $unwind$coff_write_section_table
$pdata$CoffGetType DD imagerel CoffGetType
	DD	imagerel CoffGetType+38
	DD	imagerel $unwind$CoffGetType
$pdata$CoffGetClass DD imagerel CoffGetClass
	DD	imagerel CoffGetClass+148
	DD	imagerel $unwind$CoffGetClass
$pdata$GetFileAuxEntries DD imagerel GetFileAuxEntries
	DD	imagerel GetFileAuxEntries+199
	DD	imagerel $unwind$GetFileAuxEntries
$pdata$InitCRC32 DD imagerel InitCRC32
	DD	imagerel InitCRC32+134
	DD	imagerel $unwind$InitCRC32
$pdata$CRC32Comdat DD imagerel CRC32Comdat
	DD	imagerel CRC32Comdat+180
	DD	imagerel $unwind$CRC32Comdat
$pdata$coff_write_symbols DD imagerel coff_write_symbols
	DD	imagerel coff_write_symbols+4346
	DD	imagerel $unwind$coff_write_symbols
$pdata$GetStartLabel DD imagerel GetStartLabel
	DD	imagerel GetStartLabel+373
	DD	imagerel $unwind$GetStartLabel
$pdata$coff_flushfunc DD imagerel coff_flushfunc
	DD	imagerel coff_flushfunc+462
	DD	imagerel $unwind$coff_flushfunc
$pdata$SetSymbolIndices DD imagerel SetSymbolIndices
	DD	imagerel SetSymbolIndices+878
	DD	imagerel $unwind$SetSymbolIndices
$pdata$coff_write_fixups DD imagerel coff_write_fixups
	DD	imagerel coff_write_fixups+1636
	DD	imagerel $unwind$coff_write_fixups
$pdata$coff_write_data DD imagerel coff_write_data
	DD	imagerel coff_write_data+2139
	DD	imagerel $unwind$coff_write_data
$pdata$coff_create_drectve DD imagerel coff_create_drectve
	DD	imagerel coff_create_drectve+2526
	DD	imagerel $unwind$coff_create_drectve
$pdata$coff_write_module DD imagerel coff_write_module
	DD	imagerel coff_write_module+1748
	DD	imagerel $unwind$coff_write_module
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
	ORG $+6
coff_write_section_table$rtcName$0 DB 073H
	DB	065H
	DB	067H
	DB	074H
	DB	079H
	DB	070H
	DB	065H
	DB	00H
coff_write_section_table$rtcName$1 DB 069H
	DB	073H
	DB	068H
	DB	00H
coff_write_section_table$rtcName$2 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+5
coff_write_section_table$rtcVarDesc DD 0c0H
	DD	0f8H
	DQ	FLAT:coff_write_section_table$rtcName$2
	DD	078H
	DD	028H
	DQ	FLAT:coff_write_section_table$rtcName$1
	DD	054H
	DD	04H
	DQ	FLAT:coff_write_section_table$rtcName$0
	ORG $+144
coff_write_section_table$rtcFrameData DD 03H
	DD	00H
	DQ	FLAT:coff_write_section_table$rtcVarDesc
coff_write_symbols$rtcName$0 DB 070H
	DB	00H
	ORG $+2
coff_write_symbols$rtcName$1 DB 069H
	DB	073H
	DB	00H
	ORG $+1
coff_write_symbols$rtcName$2 DB 069H
	DB	061H
	DB	073H
	DB	00H
coff_write_symbols$rtcName$3 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+5
coff_write_symbols$rtcFrameData DD 04H
	DD	00H
	DQ	FLAT:coff_write_symbols$rtcVarDesc
GetStartLabel$rtcName$0 DB 074H
	DB	065H
	DB	06dH
	DB	070H
	DB	00H
	ORG $+3
coff_write_symbols$rtcVarDesc DD 0e0H
	DD	0100H
	DQ	FLAT:coff_write_symbols$rtcName$3
	DD	0a8H
	DD	012H
	DQ	FLAT:coff_write_symbols$rtcName$2
	DD	078H
	DD	012H
	DQ	FLAT:coff_write_symbols$rtcName$1
	DD	058H
	DD	08H
	DQ	FLAT:coff_write_symbols$rtcName$0
	ORG $+192
GetStartLabel$rtcVarDesc DD 040H
	DD	0100H
	DQ	FLAT:GetStartLabel$rtcName$0
	ORG $+48
GetStartLabel$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:GetStartLabel$rtcVarDesc
SetSymbolIndices$rtcName$0 DB 06cH
	DB	061H
	DB	073H
	DB	074H
	DB	066H
	DB	070H
	DB	072H
	DB	06fH
	DB	063H
	DB	00H
	ORG $+2
coff_write_fixups$rtcName$0 DB 069H
	DB	072H
	DB	00H
	ORG $+1
coff_write_fixups$rtcVarDesc DD 058H
	DD	0aH
	DQ	FLAT:coff_write_fixups$rtcName$0
	ORG $+48
coff_write_fixups$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:coff_write_fixups$rtcVarDesc
coff_write_data$rtcName$0 DB 06fH
	DB	066H
	DB	066H
	DB	073H
	DB	065H
	DB	074H
	DB	00H
	ORG $+1
coff_write_data$rtcName$1 DB 069H
	DB	06eH
	DB	064H
	DB	065H
	DB	078H
	DB	00H
	ORG $+2
coff_write_data$rtcName$2 DB 069H
	DB	06cH
	DB	00H
	ORG $+5
coff_write_data$rtcFrameData DD 03H
	DD	00H
	DQ	FLAT:coff_write_data$rtcVarDesc
coff_create_drectve$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
coff_write_data$rtcVarDesc DD 0b4H
	DD	06H
	DQ	FLAT:coff_write_data$rtcName$2
	DD	074H
	DD	04H
	DQ	FLAT:coff_write_data$rtcName$1
	DD	054H
	DD	04H
	DQ	FLAT:coff_write_data$rtcName$0
	ORG $+144
coff_create_drectve$rtcVarDesc DD 050H
	DD	0100H
	DQ	FLAT:coff_create_drectve$rtcName$0
	ORG $+48
coff_create_drectve$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:coff_create_drectve$rtcVarDesc
coff_write_module$rtcName$0 DB 063H
	DB	06dH
	DB	00H
	ORG $+1
coff_write_module$rtcName$1 DB 069H
	DB	066H
	DB	068H
	DB	00H
	ORG $+8
coff_write_module$rtcVarDesc DD 0e8H
	DD	014H
	DQ	FLAT:coff_write_module$rtcName$1
	DD	050H
	DD	080H
	DQ	FLAT:coff_write_module$rtcName$0
	ORG $+96
coff_write_module$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:coff_write_module$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
xdata	SEGMENT
$unwind$time DD	021e01H
	DD	07006320aH
$unwind$coff_init DD 010601H
	DD	07006H
$unwind$Coff_AllocString DD 022801H
	DD	070105214H
$unwind$GetLinnumItems DD 021e01H
	DD	07006120aH
$unwind$coff_write_section_table DD 033b19H
	DD	0400112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	01f0H
$unwind$CoffGetType DD 010601H
	DD	07006H
$unwind$CoffGetClass DD 010601H
	DD	07006H
$unwind$GetFileAuxEntries DD 022301H
	DD	0700b720fH
$unwind$InitCRC32 DD 021501H
	DD	070021206H
$unwind$CRC32Comdat DD 022701H
	DD	0700f5213H
$unwind$coff_write_symbols DD 033b19H
	DD	0440112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0210H
$unwind$GetStartLabel DD 033a19H
	DD	02c0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$coff_flushfunc DD 022d01H
	DD	070159219H
$unwind$SetSymbolIndices DD 022301H
	DD	0700b920fH
$unwind$coff_write_fixups DD 034019H
	DD	0120117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$coff_write_data DD 032901H
	DD	0220112H
	DD	0700bH
$unwind$coff_create_drectve DD 033b19H
	DD	0340112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0190H
$unwind$coff_write_module DD 033619H
	DD	02a010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0148H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
pName$ = 48
cm$ = 80
ifh$ = 232
i$5 = 260
src$6 = 264
dst$7 = 272
sehp$8 = 280
cnt$9 = 288
i$10 = 292
tv80 = 304
tv256 = 312
tv281 = 320
__$ArrayPad$ = 328
modinfo$ = 352
coff_write_module PROC

; 1359 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 336				; 00000150H
	mov	rdi, rsp
	mov	ecx, 84					; 00000054H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+352]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1360 :     struct stringitem  *pName;
; 1361 :     struct coffmod cm;
; 1362 :     struct IMAGE_FILE_HEADER ifh;
; 1363 : 
; 1364 :     DebugMsg(("coff_write_module: enter, sections=%u\n", modinfo->g.num_segs ));

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	edx, DWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12033
	call	DoDebugMsg

; 1365 : 
; 1366 :     memset( &cm, 0, sizeof( cm ) );

	mov	r8d, 128				; 00000080H
	xor	edx, edx
	lea	rcx, QWORD PTR cm$[rsp]
	call	memset

; 1367 :     //directives = NULL;
; 1368 :     //LongNames.head = NULL;
; 1369 :     cm.LongNames.size = sizeof( uint_32 );

	mov	DWORD PTR cm$[rsp+112], 4

; 1370 : 
; 1371 :     /* get value for .file symbol */
; 1372 :     cm.dot_file_value = CurrFName[ASM];

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR cm$[rsp+24], rax

; 1373 : #if 0 /* v2.09: always add the name in CurrFName[ASM] */
; 1374 :     cm.dot_file_value += strlen( dot_file_value );
; 1375 :     while ( cm.dot_file_value > CurrFName[ASM] &&
; 1376 :            *(cm.dot_file_value-1) != '/' &&
; 1377 :            *(cm.dot_file_value-1) != '\\') cm.dot_file_value--;
; 1378 : #endif
; 1379 : 
; 1380 :     /* it might be necessary to add "internal" sections:
; 1381 :      * - .debug$S and .debug$T sections if -Zi was set
; 1382 :      * - .sxdata section if .SAFESEH was used
; 1383 :      * - .drectve section if start label, exports or includelibs are used
; 1384 :      */
; 1385 : 	
; 1386 :     /* if -Zi is set, add .debug$S and .debug$T sections */
; 1387 :     if ( Options.debug_symbols ) {

	movzx	eax, BYTE PTR Options+2
	test	eax, eax
	je	$LN17@coff_write

; 1388 :         int i;
; 1389 :         for ( i = 0; i < DBGS_MAX; i++ ) {

	mov	DWORD PTR i$5[rsp], 0
	jmp	SHORT $LN4@coff_write
$LN2@coff_write:
	mov	eax, DWORD PTR i$5[rsp]
	inc	eax
	mov	DWORD PTR i$5[rsp], eax
$LN4@coff_write:
	cmp	DWORD PTR i$5[rsp], 2
	jge	$LN3@coff_write

; 1390 :             if ( NULL == ( cm.SymDeb[i].seg = (struct dsym *)CreateIntSegment( SymDebName[i], "", 0, USE32, TRUE ) ) )

	movsxd	rax, DWORD PTR i$5[rsp]
	lea	rcx, OFFSET FLAT:SymDebName
	mov	BYTE PTR [rsp+32], 1
	mov	r9b, 1
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:$SG12036
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	CreateIntSegment
	mov	QWORD PTR tv80[rsp], rax
	movsxd	rax, DWORD PTR i$5[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR tv80[rsp]
	mov	QWORD PTR cm$[rsp+rax+48], rcx
	cmp	QWORD PTR tv80[rsp], 0
	jne	SHORT $LN18@coff_write

; 1391 :                 break;

	jmp	$LN3@coff_write
$LN18@coff_write:

; 1392 :             DebugMsg(("coff_write_module: %s section added\n", SymDebName[i] ));

	movsxd	rax, DWORD PTR i$5[rsp]
	lea	rcx, OFFSET FLAT:SymDebName
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, OFFSET FLAT:$SG12037
	call	DoDebugMsg

; 1393 :             cm.SymDeb[i].seg->e.seginfo->characteristics = (IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE) >> 24;

	movsxd	rax, DWORD PTR i$5[rsp]
	imul	rax, rax, 24
	mov	rax, QWORD PTR cm$[rsp+rax+48]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rax+105], 66			; 00000042H

; 1394 :             /* use the source line buffer as code buffer. It isn't needed anymore */
; 1395 :             cm.SymDeb[i].seg->e.seginfo->CodeBuffer = CurrSource + i * SIZE_CV_SEGBUF;

	imul	eax, DWORD PTR i$5[rsp], 1200		; 000004b0H
	cdqe
	mov	rcx, QWORD PTR ModuleInfo+464
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i$5[rsp]
	imul	rcx, rcx, 24
	mov	rcx, QWORD PTR cm$[rsp+rcx+48]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx+16], rax

; 1396 :             cm.SymDeb[i].seg->e.seginfo->flushfunc = coff_flushfunc;

	movsxd	rax, DWORD PTR i$5[rsp]
	imul	rax, rax, 24
	mov	rax, QWORD PTR cm$[rsp+rax+48]
	mov	rax, QWORD PTR [rax+96]
	lea	rcx, OFFSET FLAT:coff_flushfunc
	mov	QWORD PTR [rax+32], rcx

; 1397 :             cm.SymDeb[i].q.head = NULL;

	movsxd	rax, DWORD PTR i$5[rsp]
	imul	rax, rax, 24
	mov	QWORD PTR cm$[rsp+rax+56], 0

; 1398 :         }

	jmp	$LN2@coff_write
$LN3@coff_write:

; 1399 :         if ( i == DBGS_MAX ) {

	cmp	DWORD PTR i$5[rsp], 2
	jne	$LN19@coff_write

; 1400 :             cv_write_debug_tables( cm.SymDeb[DBGS_SYMBOLS].seg, cm.SymDeb[DBGS_TYPES].seg, &cm );

	mov	eax, 24
	imul	rax, rax, 1
	mov	ecx, 24
	imul	rcx, rcx, 0
	lea	r8, QWORD PTR cm$[rsp]
	mov	rdx, QWORD PTR cm$[rsp+rax+48]
	mov	rcx, QWORD PTR cm$[rsp+rcx+48]
	call	cv_write_debug_tables

; 1401 :             /* the contents have been written in queues. now
; 1402 :              * copy all queue items in ONE buffer.
; 1403 :              */
; 1404 :             for ( i = 0; i < DBGS_MAX; i++ ) {

	mov	DWORD PTR i$5[rsp], 0
	jmp	SHORT $LN7@coff_write
$LN5@coff_write:
	mov	eax, DWORD PTR i$5[rsp]
	inc	eax
	mov	DWORD PTR i$5[rsp], eax
$LN7@coff_write:
	cmp	DWORD PTR i$5[rsp], 2
	jge	$LN6@coff_write

; 1405 :                 uint_8 *src;
; 1406 :                 uint_8 *dst;
; 1407 :                 if ( cm.SymDeb[i].seg->sym.max_offset ) {

	movsxd	rax, DWORD PTR i$5[rsp]
	imul	rax, rax, 24
	mov	rax, QWORD PTR cm$[rsp+rax+48]
	cmp	DWORD PTR [rax+56], 0
	je	$LN20@coff_write

; 1408 :                     cm.SymDeb[i].seg->e.seginfo->CodeBuffer = LclAlloc( cm.SymDeb[i].seg->sym.max_offset );

	movsxd	rax, DWORD PTR i$5[rsp]
	imul	rax, rax, 24
	mov	rax, QWORD PTR cm$[rsp+rax+48]
	movsxd	rax, DWORD PTR [rax+56]
	mov	rcx, rax
	call	LclAlloc
	movsxd	rcx, DWORD PTR i$5[rsp]
	imul	rcx, rcx, 24
	mov	rcx, QWORD PTR cm$[rsp+rcx+48]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx+16], rax

; 1409 :                     dst = cm.SymDeb[i].seg->e.seginfo->CodeBuffer;

	movsxd	rax, DWORD PTR i$5[rsp]
	imul	rax, rax, 24
	mov	rax, QWORD PTR cm$[rsp+rax+48]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR dst$7[rsp], rax

; 1410 :                     for ( src = cm.SymDeb[i].q.head; src; src = ((struct qditem *)src)->next ) {

	movsxd	rax, DWORD PTR i$5[rsp]
	imul	rax, rax, 24
	mov	rax, QWORD PTR cm$[rsp+rax+56]
	mov	QWORD PTR src$6[rsp], rax
	jmp	SHORT $LN10@coff_write
$LN8@coff_write:
	mov	rax, QWORD PTR src$6[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR src$6[rsp], rax
$LN10@coff_write:
	cmp	QWORD PTR src$6[rsp], 0
	je	SHORT $LN9@coff_write

; 1411 :                         memcpy( dst, src + sizeof( struct qditem ), ((struct qditem *)src)->size );

	mov	rax, QWORD PTR src$6[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR src$6[rsp]
	add	rcx, 16
	mov	r8d, eax
	mov	rdx, rcx
	mov	rcx, QWORD PTR dst$7[rsp]
	call	memcpy

; 1412 :                         dst += ((struct qditem *)src)->size;

	mov	rax, QWORD PTR src$6[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR dst$7[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dst$7[rsp], rax

; 1413 :                         /* fixme: free the queue items if FASTMEM==0 */
; 1414 :                     }

	jmp	SHORT $LN8@coff_write
$LN9@coff_write:
$LN20@coff_write:

; 1415 :                 }
; 1416 :             }

	jmp	$LN5@coff_write
$LN6@coff_write:
$LN19@coff_write:
$LN17@coff_write:

; 1417 :         }
; 1418 :     }
; 1419 : 
; 1420 :     /* if safeSEH procs are defined, add a .sxdata section */
; 1421 :     if ( modinfo->g.SafeSEHQueue.head ) {

	mov	rax, QWORD PTR modinfo$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	$LN21@coff_write

; 1422 :         struct qnode *sehp;
; 1423 :         unsigned cnt = 0;

	mov	DWORD PTR cnt$9[rsp], 0

; 1424 :         if ( cm.sxdata = (struct dsym *)CreateIntSegment( ".sxdata", "", MAX_SEGALIGNMENT, modinfo->Ofssize, FALSE ) ) {

	mov	BYTE PTR [rsp+32], 0
	mov	rax, QWORD PTR modinfo$[rsp]
	movzx	r9d, BYTE PTR [rax+404]
	mov	r8b, 255				; 000000ffH
	lea	rdx, OFFSET FLAT:$SG12042
	lea	rcx, OFFSET FLAT:$SG12043
	call	CreateIntSegment
	mov	QWORD PTR cm$[rsp+8], rax
	cmp	QWORD PTR cm$[rsp+8], 0
	je	$LN22@coff_write

; 1425 :             cm.sxdata->e.seginfo->info = TRUE;

	mov	rax, QWORD PTR cm$[rsp+8]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 2
	mov	rcx, QWORD PTR cm$[rsp+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+107], al

; 1426 :             /* calc the size for this segment */
; 1427 :             for( sehp = modinfo->g.SafeSEHQueue.head; sehp ; sehp = sehp->next, cnt++ );

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR sehp$8[rsp], rax
	jmp	SHORT $LN13@coff_write
$LN11@coff_write:
	mov	rax, QWORD PTR sehp$8[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sehp$8[rsp], rax
	mov	eax, DWORD PTR cnt$9[rsp]
	inc	eax
	mov	DWORD PTR cnt$9[rsp], eax
$LN13@coff_write:
	cmp	QWORD PTR sehp$8[rsp], 0
	je	SHORT $LN12@coff_write
	jmp	SHORT $LN11@coff_write
$LN12@coff_write:

; 1428 :             cm.sxdata->sym.max_offset = cnt*4;

	mov	eax, DWORD PTR cnt$9[rsp]
	shl	eax, 2
	mov	rcx, QWORD PTR cm$[rsp+8]
	mov	DWORD PTR [rcx+56], eax

; 1429 :             cm.sxdata->e.seginfo->CodeBuffer = LclAlloc( cnt*4 );

	mov	eax, DWORD PTR cnt$9[rsp]
	shl	eax, 2
	mov	eax, eax
	mov	ecx, eax
	call	LclAlloc
	mov	rcx, QWORD PTR cm$[rsp+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx+16], rax

; 1430 :             DebugMsg(("coff_write_module: .sxdata section added, size=%u\n", cnt*4));

	mov	eax, DWORD PTR cnt$9[rsp]
	shl	eax, 2
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12044
	call	DoDebugMsg
$LN22@coff_write:
$LN21@coff_write:

; 1431 :         }
; 1432 :     }
; 1433 : 
; 1434 :     /* create .drectve section if necessary */
; 1435 :     coff_create_drectve( modinfo, &cm );

	lea	rdx, QWORD PTR cm$[rsp]
	mov	rcx, QWORD PTR modinfo$[rsp]
	call	coff_create_drectve

; 1436 : 
; 1437 :     /* v2.11: removed, max_offset has been set already */
; 1438 :     //if ( directives )
; 1439 :     //    directives->sym.max_offset = size_drectve;
; 1440 : 
; 1441 : #if AMD64_SUPPORT
; 1442 :     if ( modinfo->defOfssize == USE64 )

	mov	rax, QWORD PTR modinfo$[rsp]
	movzx	eax, BYTE PTR [rax+405]
	cmp	eax, 2
	jne	SHORT $LN23@coff_write

; 1443 :         ifh.Machine = IMAGE_FILE_MACHINE_AMD64;

	mov	eax, 34404				; 00008664H
	mov	WORD PTR ifh$[rsp], ax
	jmp	SHORT $LN24@coff_write
$LN23@coff_write:

; 1444 :     else
; 1445 : #endif
; 1446 :         ifh.Machine = IMAGE_FILE_MACHINE_I386;

	mov	eax, 332				; 0000014cH
	mov	WORD PTR ifh$[rsp], ax
$LN24@coff_write:

; 1447 :     ifh.NumberOfSections = modinfo->g.num_segs;

	mov	rax, QWORD PTR modinfo$[rsp]
	movzx	eax, WORD PTR [rax+8]
	mov	WORD PTR ifh$[rsp+2], ax

; 1448 : #if 0 //def __UNIX__
; 1449 :     time((int_32 *)&ifh.TimeDateStamp);
; 1450 : #else
; 1451 :     time((time_t *)&ifh.TimeDateStamp);

	lea	rcx, QWORD PTR ifh$[rsp+4]
	call	time

; 1452 : #endif
; 1453 :     ifh.SizeOfOptionalHeader = 0;

	xor	eax, eax
	mov	WORD PTR ifh$[rsp+16], ax

; 1454 :     ifh.Characteristics = 0;

	xor	eax, eax
	mov	WORD PTR ifh$[rsp+18], ax

; 1455 : 
; 1456 :     /* position behind coff file header */
; 1457 :     fseek( CurrFile[OBJ], sizeof( ifh ), SEEK_SET );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	xor	r8d, r8d
	mov	edx, 20
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_fseek

; 1458 : 
; 1459 :     coff_write_section_table( modinfo, &cm );

	lea	rdx, QWORD PTR cm$[rsp]
	mov	rcx, QWORD PTR modinfo$[rsp]
	call	coff_write_section_table

; 1460 :     coff_write_data( modinfo, &cm );

	lea	rdx, QWORD PTR cm$[rsp]
	mov	rcx, QWORD PTR modinfo$[rsp]
	call	coff_write_data

; 1461 :     /* v2.12: check that calculated sizes are identical to those that have been written */
; 1462 :     /*myassert( cm.start_symtab == ( cm.start_data + cm.size_data ) );*/
; 1463 : 
; 1464 :     ifh.NumberOfSymbols = coff_write_symbols( modinfo, &cm );

	lea	rdx, QWORD PTR cm$[rsp]
	mov	rcx, QWORD PTR modinfo$[rsp]
	call	coff_write_symbols
	mov	DWORD PTR ifh$[rsp+12], eax

; 1465 :     ifh.PointerToSymbolTable = ( ifh.NumberOfSymbols ? cm.start_data + cm.size_data : 0 );

	cmp	DWORD PTR ifh$[rsp+12], 0
	je	SHORT $LN29@coff_write
	mov	eax, DWORD PTR cm$[rsp+36]
	mov	ecx, DWORD PTR cm$[rsp+32]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv256[rsp], eax
	jmp	SHORT $LN30@coff_write
$LN29@coff_write:
	mov	DWORD PTR tv256[rsp], 0
$LN30@coff_write:
	mov	eax, DWORD PTR tv256[rsp]
	mov	DWORD PTR ifh$[rsp+8], eax

; 1466 : 
; 1467 :     /* the string table is ALWAYS written, even if no strings are defined */
; 1468 :     DebugMsg(("coff_write_module: string_table size=%u\n", cm.LongNames.size ));

	mov	edx, DWORD PTR cm$[rsp+112]
	lea	rcx, OFFSET FLAT:$SG12047
	call	DoDebugMsg

; 1469 :     if ( fwrite( &cm.LongNames.size, 1, sizeof( cm.LongNames.size ), CurrFile[OBJ] ) != sizeof( cm.LongNames.size ) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 4
	mov	edx, 1
	lea	rcx, QWORD PTR cm$[rsp+112]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 4
	je	SHORT $LN25@coff_write

; 1470 :         WriteError();

	call	WriteError
$LN25@coff_write:

; 1471 :     for ( pName = cm.LongNames.head; pName; pName = pName->next ) {

	mov	rax, QWORD PTR cm$[rsp+96]
	mov	QWORD PTR pName$[rsp], rax
	jmp	SHORT $LN16@coff_write
$LN14@coff_write:
	mov	rax, QWORD PTR pName$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pName$[rsp], rax
$LN16@coff_write:
	cmp	QWORD PTR pName$[rsp], 0
	je	SHORT $LN15@coff_write

; 1472 :         int i = strlen( pName->string ) + 1;

	mov	rax, QWORD PTR pName$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	strlen
	inc	rax
	mov	DWORD PTR i$10[rsp], eax

; 1473 :         if ( fwrite( pName->string, 1, i, CurrFile[OBJ] ) != i )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	movsxd	rdx, DWORD PTR i$10[rsp]
	mov	r8, QWORD PTR pName$[rsp]
	add	r8, 8
	mov	QWORD PTR tv281[rsp], r8
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8, rdx
	mov	edx, 1
	mov	rax, QWORD PTR tv281[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_fwrite
	movsxd	rcx, DWORD PTR i$10[rsp]
	cmp	rax, rcx
	je	SHORT $LN26@coff_write

; 1474 :             WriteError();

	call	WriteError
$LN26@coff_write:

; 1475 :     }

	jmp	$LN14@coff_write
$LN15@coff_write:

; 1476 : #if FASTMEM==0
; 1477 :     for ( ; cm.LongNames.head; ) {
; 1478 :         pName = cm.LongNames.head;
; 1479 :         cm.LongNames.head = cm.LongNames.head->next;
; 1480 :         LclFree( pName );
; 1481 :     }
; 1482 : #endif
; 1483 :     /* finally write the COFF file header */
; 1484 :     fseek( CurrFile[OBJ], 0, SEEK_SET);

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_fseek

; 1485 :     if ( fwrite( &ifh, 1, sizeof( ifh ), CurrFile[OBJ] ) != sizeof( ifh ) ) {

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 20
	mov	edx, 1
	lea	rcx, QWORD PTR ifh$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 20
	je	SHORT $LN27@coff_write

; 1486 :         DebugMsg(("coff_write_module: error writing file header\n"));

	lea	rcx, OFFSET FLAT:$SG12051
	call	DoDebugMsg

; 1487 :         WriteError();

	call	WriteError
$LN27@coff_write:

; 1488 :     }
; 1489 : 
; 1490 :     DebugMsg(("coff_write_module: exit\n"));

	lea	rcx, OFFSET FLAT:$SG12052
	call	DoDebugMsg

; 1491 :     return( NOT_ERROR );

	xor	eax, eax

; 1492 : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:coff_write_module$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 336				; 00000150H
	pop	rdi
	ret	0
coff_write_module ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
exp$ = 48
imp$ = 56
buffer$ = 80
tmp$4 = 344
size$5 = 352
q$6 = 360
p$7 = 368
tv147 = 384
tv394 = 392
__$ArrayPad$ = 400
modinfo$ = 432
cm$ = 440
coff_create_drectve PROC

; 1221 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 416				; 000001a0H
	mov	rdi, rsp
	mov	ecx, 104				; 00000068H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+432]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1222 :     struct dsym *exp;
; 1223 : #if DLLIMPORT
; 1224 :     struct dsym *imp = NULL;

	mov	QWORD PTR imp$[rsp], 0

; 1225 : #endif
; 1226 :     char buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 1227 : 
; 1228 :     /* does a proc exist with the EXPORT attribute? */
; 1229 :     for( exp = SymTables[TAB_PROC].head; exp != NULL; exp = exp->nextproc ) {

	mov	eax, 16
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR exp$[rsp], rax
	jmp	SHORT $LN4@coff_creat
$LN2@coff_creat:
	mov	rax, QWORD PTR exp$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR exp$[rsp], rax
$LN4@coff_creat:
	cmp	QWORD PTR exp$[rsp], 0
	je	SHORT $LN3@coff_creat

; 1230 :         if( exp->e.procinfo->isexport )

	mov	rax, QWORD PTR exp$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+84]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN26@coff_creat

; 1231 :             break;

	jmp	SHORT $LN3@coff_creat
$LN26@coff_creat:

; 1232 :     }

	jmp	SHORT $LN2@coff_creat
$LN3@coff_creat:

; 1233 : #if DLLIMPORT
; 1234 :     /* check if an impdef record is there */
; 1235 :     if ( Options.write_impdef && !Options.names[OPTN_LNKDEF_FN] )

	movzx	eax, BYTE PTR Options+138
	test	eax, eax
	je	$LN27@coff_creat
	mov	eax, 8
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax], 0
	jne	$LN27@coff_creat

; 1236 :         for ( imp = SymTables[TAB_EXT].head; imp; imp = imp->next )

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR imp$[rsp], rax
	jmp	SHORT $LN7@coff_creat
$LN5@coff_creat:
	mov	rax, QWORD PTR imp$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR imp$[rsp], rax
$LN7@coff_creat:
	cmp	QWORD PTR imp$[rsp], 0
	je	SHORT $LN6@coff_creat

; 1237 :             if ( imp->sym.isproc && ( imp->sym.weak == FALSE || imp->sym.iat_used == TRUE ) )

	mov	rax, QWORD PTR imp$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN28@coff_creat
	mov	rax, QWORD PTR imp$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN29@coff_creat
	mov	rax, QWORD PTR imp$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN28@coff_creat
$LN29@coff_creat:

; 1238 :                 if ( imp->sym.dll && *imp->sym.dll->name )

	mov	rax, QWORD PTR imp$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN30@coff_creat
	mov	rax, QWORD PTR imp$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	ecx, 1
	imul	rcx, rcx, 0
	movsx	eax, BYTE PTR [rax+rcx+12]
	test	eax, eax
	je	SHORT $LN30@coff_creat

; 1239 :                     break;

	jmp	SHORT $LN6@coff_creat
$LN30@coff_creat:
$LN28@coff_creat:
	jmp	$LN5@coff_creat
$LN6@coff_creat:
$LN27@coff_creat:

; 1240 : #endif
; 1241 :     /* add a .drectve section if
; 1242 :      - a start_label is defined    and/or
; 1243 :      - a library is included       and/or
; 1244 :      - a proc is exported          and/or
; 1245 :      - impdefs are to be written (-Zd)
; 1246 :      */
; 1247 :     if ( modinfo->g.start_label != NULL ||
; 1248 :         modinfo->g.LibQueue.head != NULL ||
; 1249 : #if DLLIMPORT
; 1250 :         imp != NULL ||

	mov	rax, QWORD PTR modinfo$[rsp]
	cmp	QWORD PTR [rax+208], 0
	jne	SHORT $LN32@coff_creat
	mov	rax, QWORD PTR modinfo$[rsp]
	cmp	QWORD PTR [rax+64], 0
	jne	SHORT $LN32@coff_creat
	cmp	QWORD PTR imp$[rsp], 0
	jne	SHORT $LN32@coff_creat
	cmp	QWORD PTR exp$[rsp], 0
	je	$LN31@coff_creat
$LN32@coff_creat:

; 1251 : #endif
; 1252 :         exp != NULL ) {
; 1253 :         if ( cm->directives = (struct dsym *)CreateIntSegment( szdrectve, "", MAX_SEGALIGNMENT, modinfo->Ofssize, FALSE ) ) {

	mov	BYTE PTR [rsp+32], 0
	mov	rax, QWORD PTR modinfo$[rsp]
	movzx	r9d, BYTE PTR [rax+404]
	mov	r8b, 255				; 000000ffH
	lea	rdx, OFFSET FLAT:$SG11973
	lea	rcx, OFFSET FLAT:szdrectve
	call	CreateIntSegment
	mov	QWORD PTR tv147[rsp], rax
	mov	rax, QWORD PTR cm$[rsp]
	mov	rcx, QWORD PTR tv147[rsp]
	mov	QWORD PTR [rax], rcx
	cmp	QWORD PTR tv147[rsp], 0
	je	$LN33@coff_creat

; 1254 :             struct dsym *tmp;
; 1255 :             int size = 0;

	mov	DWORD PTR size$5[rsp], 0

; 1256 :             struct qitem *q;
; 1257 :             uint_8 *p;
; 1258 :             cm->directives->e.seginfo->info = TRUE;

	mov	rax, QWORD PTR cm$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 2
	mov	rcx, QWORD PTR cm$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+107], al

; 1259 :             DebugMsg(("coff_create_drectve: %s section added\n", szdrectve));

	lea	rdx, OFFSET FLAT:szdrectve
	lea	rcx, OFFSET FLAT:$SG11974
	call	DoDebugMsg

; 1260 : 
; 1261 :             /* calc the size for this segment */
; 1262 :             /* 1. exports */
; 1263 :             for( tmp = exp; tmp ; tmp = tmp->nextproc ) {

	mov	rax, QWORD PTR exp$[rsp]
	mov	QWORD PTR tmp$4[rsp], rax
	jmp	SHORT $LN10@coff_creat
$LN8@coff_creat:
	mov	rax, QWORD PTR tmp$4[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR tmp$4[rsp], rax
$LN10@coff_creat:
	cmp	QWORD PTR tmp$4[rsp], 0
	je	$LN9@coff_creat

; 1264 :                 if( tmp->e.procinfo->isexport ) {

	mov	rax, QWORD PTR tmp$4[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+84]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN34@coff_creat

; 1265 :                     size += Mangle( &tmp->sym, buffer );

	mov	rax, QWORD PTR tmp$4[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rax
	call	Mangle
	mov	ecx, DWORD PTR size$5[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR size$5[rsp], eax

; 1266 :                     size += sizeof("-export:");

	movsxd	rax, DWORD PTR size$5[rsp]
	add	rax, 9
	mov	DWORD PTR size$5[rsp], eax

; 1267 :                     if ( Options.no_export_decoration == TRUE )

	movzx	eax, BYTE PTR Options+135
	cmp	eax, 1
	jne	SHORT $LN35@coff_creat

; 1268 :                         size += tmp->sym.name_size + 1;

	mov	rax, QWORD PTR tmp$4[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	ecx, DWORD PTR size$5[rsp]
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	DWORD PTR size$5[rsp], eax
$LN35@coff_creat:
$LN34@coff_creat:

; 1269 :                 }
; 1270 :             }

	jmp	$LN8@coff_creat
$LN9@coff_creat:

; 1271 :             /* 2. defaultlibs */
; 1272 :             for( q = modinfo->g.LibQueue.head; q ; q = q->next ) {

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR q$6[rsp], rax
	jmp	SHORT $LN13@coff_creat
$LN11@coff_creat:
	mov	rax, QWORD PTR q$6[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$6[rsp], rax
$LN13@coff_creat:
	cmp	QWORD PTR q$6[rsp], 0
	je	SHORT $LN12@coff_creat

; 1273 :                 size += strlen( q->value ) + sizeof("-defaultlib:");

	mov	rax, QWORD PTR q$6[rsp]
	add	rax, 8
	mov	rcx, rax
	call	strlen
	movsxd	rcx, DWORD PTR size$5[rsp]
	lea	rax, QWORD PTR [rcx+rax+13]
	mov	DWORD PTR size$5[rsp], eax

; 1274 :                 /* if the name isn't enclosed in double quotes and contains
; 1275 :                  a space, add 2 bytes to enclose it */
; 1276 :                 if ( *q->value != '"' && strchr( q->value, ' ') )

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR q$6[rsp]
	movsx	eax, BYTE PTR [rcx+rax+8]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN36@coff_creat
	mov	rax, QWORD PTR q$6[rsp]
	add	rax, 8
	mov	edx, 32					; 00000020H
	mov	rcx, rax
	call	QWORD PTR __imp_strchr
	test	rax, rax
	je	SHORT $LN36@coff_creat

; 1277 :                     size += 2;

	mov	eax, DWORD PTR size$5[rsp]
	add	eax, 2
	mov	DWORD PTR size$5[rsp], eax
$LN36@coff_creat:

; 1278 :             }

	jmp	$LN11@coff_creat
$LN12@coff_creat:

; 1279 :             /* 3. start label */
; 1280 :             size += GetStartLabel( buffer, TRUE );

	mov	dl, 1
	lea	rcx, QWORD PTR buffer$[rsp]
	call	GetStartLabel
	mov	ecx, DWORD PTR size$5[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR size$5[rsp], eax

; 1281 : #if DLLIMPORT
; 1282 :             /* 4. impdefs */
; 1283 :             for( tmp = imp; tmp ; tmp = tmp->next ) {

	mov	rax, QWORD PTR imp$[rsp]
	mov	QWORD PTR tmp$4[rsp], rax
	jmp	SHORT $LN16@coff_creat
$LN14@coff_creat:
	mov	rax, QWORD PTR tmp$4[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR tmp$4[rsp], rax
$LN16@coff_creat:
	cmp	QWORD PTR tmp$4[rsp], 0
	je	$LN15@coff_creat

; 1284 :                 if ( tmp->sym.isproc && ( tmp->sym.weak == FALSE || tmp->sym.iat_used == TRUE ) &&
; 1285 :                     tmp->sym.dll && *tmp->sym.dll->name ) {

	mov	rax, QWORD PTR tmp$4[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN37@coff_creat
	mov	rax, QWORD PTR tmp$4[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN38@coff_creat
	mov	rax, QWORD PTR tmp$4[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN37@coff_creat
$LN38@coff_creat:
	mov	rax, QWORD PTR tmp$4[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	$LN37@coff_creat
	mov	rax, QWORD PTR tmp$4[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	ecx, 1
	imul	rcx, rcx, 0
	movsx	eax, BYTE PTR [rax+rcx+12]
	test	eax, eax
	je	$LN37@coff_creat

; 1286 :                     /* format is:
; 1287 :                      * "-import:<mangled_name>=<module_name>.<unmangled_name>" or
; 1288 :                      * "-import:<mangled_name>=<module_name>"
; 1289 :                      */
; 1290 :                     size += sizeof("-import:");

	movsxd	rax, DWORD PTR size$5[rsp]
	add	rax, 9
	mov	DWORD PTR size$5[rsp], eax

; 1291 :                     size += Mangle( &tmp->sym, buffer );

	mov	rax, QWORD PTR tmp$4[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rax
	call	Mangle
	mov	ecx, DWORD PTR size$5[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR size$5[rsp], eax

; 1292 :                     size += 1 + strlen( tmp->sym.dll->name );

	mov	rax, QWORD PTR tmp$4[rsp]
	mov	rax, QWORD PTR [rax+56]
	add	rax, 12
	mov	rcx, rax
	call	strlen
	movsxd	rcx, DWORD PTR size$5[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	DWORD PTR size$5[rsp], eax

; 1293 :                     size += 1 + tmp->sym.name_size;

	mov	rax, QWORD PTR tmp$4[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	ecx, DWORD PTR size$5[rsp]
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	DWORD PTR size$5[rsp], eax
$LN37@coff_creat:

; 1294 :                 }
; 1295 :             }

	jmp	$LN14@coff_creat
$LN15@coff_creat:

; 1296 : #endif
; 1297 :             cm->directives->sym.max_offset = size;

	mov	rax, QWORD PTR cm$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, DWORD PTR size$5[rsp]
	mov	DWORD PTR [rax+56], ecx

; 1298 :             /* v2.09: allocate 1 byte more, because sprintf() is used, which
; 1299 :              * adds a NULLC.
; 1300 :              */
; 1301 :             //directives->e.seginfo->CodeBuffer = LclAlloc( size );
; 1302 :             cm->directives->e.seginfo->CodeBuffer = LclAlloc( size + 1 );

	mov	eax, DWORD PTR size$5[rsp]
	inc	eax
	cdqe
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR cm$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx+16], rax

; 1303 :             p = cm->directives->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR cm$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR p$7[rsp], rax

; 1304 : 
; 1305 :             /* copy the data */
; 1306 : 
; 1307 :             /* 1. exports */
; 1308 :             for( tmp = exp; tmp ; tmp = tmp->nextproc ) {

	mov	rax, QWORD PTR exp$[rsp]
	mov	QWORD PTR tmp$4[rsp], rax
	jmp	SHORT $LN19@coff_creat
$LN17@coff_creat:
	mov	rax, QWORD PTR tmp$4[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR tmp$4[rsp], rax
$LN19@coff_creat:
	cmp	QWORD PTR tmp$4[rsp], 0
	je	$LN18@coff_creat

; 1309 :                 if( tmp->e.procinfo->isexport ) {

	mov	rax, QWORD PTR tmp$4[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+84]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN39@coff_creat

; 1310 :                     Mangle( &tmp->sym, buffer );

	mov	rax, QWORD PTR tmp$4[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rax
	call	Mangle

; 1311 :                     if ( Options.no_export_decoration == FALSE )

	movzx	eax, BYTE PTR Options+135
	test	eax, eax
	jne	SHORT $LN40@coff_creat

; 1312 :                         p += sprintf( (char *)p, "-export:%s ", buffer );

	lea	r8, QWORD PTR buffer$[rsp]
	lea	rdx, OFFSET FLAT:$SG11983
	mov	rcx, QWORD PTR p$7[rsp]
	call	sprintf
	cdqe
	mov	rcx, QWORD PTR p$7[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$7[rsp], rax
	jmp	SHORT $LN41@coff_creat
$LN40@coff_creat:

; 1313 :                     else
; 1314 :                         p += sprintf( (char *)p, "-export:%s=%s ", tmp->sym.name, buffer );

	lea	r9, QWORD PTR buffer$[rsp]
	mov	rax, QWORD PTR tmp$4[rsp]
	mov	r8, QWORD PTR [rax+8]
	lea	rdx, OFFSET FLAT:$SG11984
	mov	rcx, QWORD PTR p$7[rsp]
	call	sprintf
	cdqe
	mov	rcx, QWORD PTR p$7[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$7[rsp], rax
$LN41@coff_creat:
$LN39@coff_creat:

; 1315 :                 }
; 1316 :             }

	jmp	$LN17@coff_creat
$LN18@coff_creat:

; 1317 :             /* 2. libraries */
; 1318 :             for( q = modinfo->g.LibQueue.head; q ; q = q->next ) {

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR q$6[rsp], rax
	jmp	SHORT $LN22@coff_creat
$LN20@coff_creat:
	mov	rax, QWORD PTR q$6[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$6[rsp], rax
$LN22@coff_creat:
	cmp	QWORD PTR q$6[rsp], 0
	je	$LN21@coff_creat

; 1319 :                 if ( *q->value != '"' && strchr( q->value, ' ' ) )

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR q$6[rsp]
	movsx	eax, BYTE PTR [rcx+rax+8]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN42@coff_creat
	mov	rax, QWORD PTR q$6[rsp]
	add	rax, 8
	mov	edx, 32					; 00000020H
	mov	rcx, rax
	call	QWORD PTR __imp_strchr
	test	rax, rax
	je	SHORT $LN42@coff_creat

; 1320 :                     p += sprintf( (char *)p,"-defaultlib:\"%s\" ", (char *)q->value );

	mov	rax, QWORD PTR q$6[rsp]
	add	rax, 8
	mov	r8, rax
	lea	rdx, OFFSET FLAT:$SG11987
	mov	rcx, QWORD PTR p$7[rsp]
	call	sprintf
	cdqe
	mov	rcx, QWORD PTR p$7[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$7[rsp], rax
	jmp	SHORT $LN43@coff_creat
$LN42@coff_creat:

; 1321 :                 else
; 1322 :                     p += sprintf( (char *)p,"-defaultlib:%s ", (char *)q->value );

	mov	rax, QWORD PTR q$6[rsp]
	add	rax, 8
	mov	r8, rax
	lea	rdx, OFFSET FLAT:$SG11988
	mov	rcx, QWORD PTR p$7[rsp]
	call	sprintf
	cdqe
	mov	rcx, QWORD PTR p$7[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$7[rsp], rax
$LN43@coff_creat:

; 1323 :             }

	jmp	$LN20@coff_creat
$LN21@coff_creat:

; 1324 :             /* 3. entry */
; 1325 :             if ( modinfo->g.start_label ) {

	mov	rax, QWORD PTR modinfo$[rsp]
	cmp	QWORD PTR [rax+208], 0
	je	SHORT $LN44@coff_creat

; 1326 :                 GetStartLabel( buffer, FALSE );

	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	GetStartLabel

; 1327 :                 p += sprintf( (char *)p, "-entry:%s ", buffer );

	lea	r8, QWORD PTR buffer$[rsp]
	lea	rdx, OFFSET FLAT:$SG11990
	mov	rcx, QWORD PTR p$7[rsp]
	call	sprintf
	cdqe
	mov	rcx, QWORD PTR p$7[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$7[rsp], rax
$LN44@coff_creat:

; 1328 :             }
; 1329 : #if DLLIMPORT
; 1330 :             /* 4. impdefs */
; 1331 :             for( tmp = imp; tmp ; tmp = tmp->next ) {

	mov	rax, QWORD PTR imp$[rsp]
	mov	QWORD PTR tmp$4[rsp], rax
	jmp	SHORT $LN25@coff_creat
$LN23@coff_creat:
	mov	rax, QWORD PTR tmp$4[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR tmp$4[rsp], rax
$LN25@coff_creat:
	cmp	QWORD PTR tmp$4[rsp], 0
	je	$LN24@coff_creat

; 1332 :                 if ( tmp->sym.isproc && ( tmp->sym.weak == FALSE || tmp->sym.iat_used == TRUE ) &&
; 1333 :                     tmp->sym.dll && *tmp->sym.dll->name ) {

	mov	rax, QWORD PTR tmp$4[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN45@coff_creat
	mov	rax, QWORD PTR tmp$4[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN46@coff_creat
	mov	rax, QWORD PTR tmp$4[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN45@coff_creat
$LN46@coff_creat:
	mov	rax, QWORD PTR tmp$4[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	$LN45@coff_creat
	mov	rax, QWORD PTR tmp$4[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	ecx, 1
	imul	rcx, rcx, 0
	movsx	eax, BYTE PTR [rax+rcx+12]
	test	eax, eax
	je	$LN45@coff_creat

; 1334 :                     strcpy( p, "-import:" );

	lea	rdx, OFFSET FLAT:$SG11993
	mov	rcx, QWORD PTR p$7[rsp]
	call	strcpy

; 1335 :                     p += 8;

	mov	rax, QWORD PTR p$7[rsp]
	add	rax, 8
	mov	QWORD PTR p$7[rsp], rax

; 1336 :                     p += Mangle( &tmp->sym, p );

	mov	rax, QWORD PTR tmp$4[rsp]
	mov	rdx, QWORD PTR p$7[rsp]
	mov	rcx, rax
	call	Mangle
	cdqe
	mov	rcx, QWORD PTR p$7[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$7[rsp], rax

; 1337 :                     *p++ = '=';

	mov	rax, QWORD PTR p$7[rsp]
	mov	BYTE PTR [rax], 61			; 0000003dH
	mov	rax, QWORD PTR p$7[rsp]
	inc	rax
	mov	QWORD PTR p$7[rsp], rax

; 1338 :                     strcpy( p, tmp->sym.dll->name );

	mov	rax, QWORD PTR tmp$4[rsp]
	mov	rax, QWORD PTR [rax+56]
	add	rax, 12
	mov	rdx, rax
	mov	rcx, QWORD PTR p$7[rsp]
	call	strcpy

; 1339 :                     p += strlen( p );

	mov	rcx, QWORD PTR p$7[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$7[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$7[rsp], rax

; 1340 :                     *p++ = '.';

	mov	rax, QWORD PTR p$7[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH
	mov	rax, QWORD PTR p$7[rsp]
	inc	rax
	mov	QWORD PTR p$7[rsp], rax

; 1341 :                     memcpy( p, tmp->sym.name, tmp->sym.name_size );

	mov	rax, QWORD PTR tmp$4[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	r8d, eax
	mov	rax, QWORD PTR tmp$4[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR p$7[rsp]
	call	memcpy

; 1342 :                     p += tmp->sym.name_size;

	mov	rax, QWORD PTR tmp$4[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	rcx, QWORD PTR p$7[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$7[rsp], rax

; 1343 :                     *p++ = ' ';

	mov	rax, QWORD PTR p$7[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
	mov	rax, QWORD PTR p$7[rsp]
	inc	rax
	mov	QWORD PTR p$7[rsp], rax
$LN45@coff_creat:

; 1344 :                 }
; 1345 :             }

	jmp	$LN23@coff_creat
$LN24@coff_creat:

; 1346 : #endif
; 1347 :             /**/myassert( size == p - cm->directives->e.seginfo->CodeBuffer );

	movsxd	rax, DWORD PTR size$5[rsp]
	mov	rcx, QWORD PTR cm$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR p$7[rsp]
	sub	rdx, rcx
	mov	rcx, rdx
	cmp	rax, rcx
	jne	SHORT $LN48@coff_creat
	mov	DWORD PTR tv394[rsp], 0
	jmp	SHORT $LN49@coff_creat
$LN48@coff_creat:
	mov	edx, 1347				; 00000543H
	lea	rcx, OFFSET FLAT:$SG11994
	call	InternalError
	mov	DWORD PTR tv394[rsp], eax
$LN49@coff_creat:
$LN33@coff_creat:
$LN31@coff_creat:

; 1348 :             //size_drectve = p - directives->e.seginfo->CodeBuffer; /* v2.11:removed */
; 1349 :         }
; 1350 :     }
; 1351 : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:coff_create_drectve$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 416				; 000001a0H
	pop	rdi
	ret	0
coff_create_drectve ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
section$ = 64
offset$ = 84
i$ = 100
index$ = 116
sehp$6 = 136
sehp2$7 = 144
pdw$8 = 152
size$9 = 160
il$10 = 180
lni$11 = 200
last$12 = 208
line_numbers$13 = 216
tv348 = 224
tv376 = 232
tv242 = 240
tv248 = 248
tv308 = 256
modinfo$ = 288
cm$ = 296
coff_write_data PROC

; 1053 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 272				; 00000110H
	mov	rdi, rsp
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+288]

; 1054 :     struct dsym *section;
; 1055 :     uint_32 offset = 0; /* offset within section contents */

	mov	DWORD PTR offset$[rsp], 0

; 1056 :     int i;
; 1057 :     uint_32 index;
; 1058 : 
; 1059 :     DebugMsg(("coff_write_data(%s): enter\n", modinfo->name ));

	mov	rax, QWORD PTR modinfo$[rsp]
	add	rax, 512				; 00000200H
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11881
	call	DoDebugMsg

; 1060 : 
; 1061 :     /* v2.11: removed. max_offset has been set already */
; 1062 :     //if ( directives )
; 1063 :     //    directives->sym.max_offset = size_drectve;
; 1064 : 
; 1065 :     /* calc the current index for the COFF symbol table */
; 1066 :     index = SetSymbolIndices( modinfo, cm );

	mov	rdx, QWORD PTR cm$[rsp]
	mov	rcx, QWORD PTR modinfo$[rsp]
	call	SetSymbolIndices
	mov	DWORD PTR index$[rsp], eax

; 1067 : 
; 1068 :     /* fill the SafeSEH array */
; 1069 :     if ( modinfo->g.SafeSEHQueue.head ) {

	mov	rax, QWORD PTR modinfo$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	$LN14@coff_write

; 1070 :         struct qnode *sehp;
; 1071 :         struct qnode *sehp2;
; 1072 :         uint_32 *pdw;
; 1073 :         for( sehp = modinfo->g.SafeSEHQueue.head, pdw = (uint_32 *)cm->sxdata->e.seginfo->CodeBuffer; sehp ; sehp = sehp2 ) {

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR sehp$6[rsp], rax
	mov	rax, QWORD PTR cm$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR pdw$8[rsp], rax
	jmp	SHORT $LN4@coff_write
$LN2@coff_write:
	mov	rax, QWORD PTR sehp2$7[rsp]
	mov	QWORD PTR sehp$6[rsp], rax
$LN4@coff_write:
	cmp	QWORD PTR sehp$6[rsp], 0
	je	SHORT $LN3@coff_write

; 1074 :             sehp2 = sehp->next;

	mov	rax, QWORD PTR sehp$6[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sehp2$7[rsp], rax

; 1075 :             DebugMsg(("coff_write_data: .sxdata value=%08Xh\n", ((struct asym *)sehp->elmt)->ext_idx));

	mov	rax, QWORD PTR sehp$6[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	edx, DWORD PTR [rax+88]
	lea	rcx, OFFSET FLAT:$SG11883
	call	DoDebugMsg

; 1076 :             *pdw++ = ((struct asym *)sehp->elmt)->ext_idx;

	mov	rax, QWORD PTR sehp$6[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR pdw$8[rsp]
	mov	eax, DWORD PTR [rax+88]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR pdw$8[rsp]
	add	rax, 4
	mov	QWORD PTR pdw$8[rsp], rax

; 1077 :             LclFree( sehp );
; 1078 :         }

	jmp	SHORT $LN2@coff_write
$LN3@coff_write:
$LN14@coff_write:

; 1079 :     }
; 1080 : 
; 1081 : #if HELPSYMS==0
; 1082 :     for( i = 0, section = SymTables[TAB_SEG].head; section ; i++, section = section->next ) {

	mov	DWORD PTR i$[rsp], 0
	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR section$[rsp], rax
	jmp	SHORT $LN7@coff_write
$LN5@coff_write:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR section$[rsp], rax
$LN7@coff_write:
	cmp	QWORD PTR section$[rsp], 0
	je	SHORT $LN6@coff_write

; 1083 :         section->sym.ext_idx = cm->sectionstart + i;

	mov	rax, QWORD PTR cm$[rsp]
	mov	eax, DWORD PTR [rax+44]
	add	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR section$[rsp]
	mov	DWORD PTR [rcx+88], eax

; 1084 :         if ( Options.no_section_aux_entry == FALSE )

	movzx	eax, BYTE PTR Options+132
	test	eax, eax
	jne	SHORT $LN15@coff_write

; 1085 :             section->sym.ext_idx += i;

	mov	rax, QWORD PTR section$[rsp]
	mov	eax, DWORD PTR [rax+88]
	add	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR section$[rsp]
	mov	DWORD PTR [rcx+88], eax
$LN15@coff_write:

; 1086 :     }

	jmp	SHORT $LN5@coff_write
$LN6@coff_write:

; 1087 : #endif
; 1088 : 
; 1089 :     /* now scan the section's relocations. If a relocation refers to
; 1090 :      a symbol which is not public/external, it must be added to the
; 1091 :      symbol table. If the symbol is an assembly time variable, a helper
; 1092 :      symbol - name is $$<offset:6> is to be added.
; 1093 :      */
; 1094 : 
; 1095 :     for( section = SymTables[TAB_SEG].head; section ; section = section->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR section$[rsp], rax
	jmp	SHORT $LN10@coff_write
$LN8@coff_write:
	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR section$[rsp], rax
$LN10@coff_write:
	cmp	QWORD PTR section$[rsp], 0
	je	$LN9@coff_write

; 1096 :         uint_32 size;
; 1097 :         size = section->sym.max_offset;

	mov	rax, QWORD PTR section$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR size$9[rsp], eax

; 1098 : #ifdef DEBUG_OUT
; 1099 :         if ( section->e.seginfo->CodeBuffer )

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN16@coff_write

; 1100 :             DebugMsg(("coff_write_data(%s, %Xh): size=%X, written=%X, content=[%02X %02X ...]\n",

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR section$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rcx, QWORD PTR [rcx+16]
	movzx	ecx, BYTE PTR [rcx]
	mov	rdx, QWORD PTR section$[rsp]
	mov	rdx, QWORD PTR [rdx+96]
	mov	r8, QWORD PTR section$[rsp]
	mov	r8, QWORD PTR [r8+96]
	mov	r8d, DWORD PTR [r8+8]
	mov	r9d, DWORD PTR size$9[rsp]
	sub	r9d, r8d
	mov	r8d, r9d
	mov	DWORD PTR [rsp+48], eax
	mov	DWORD PTR [rsp+40], ecx
	mov	eax, DWORD PTR [rdx+24]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, r8d
	mov	r8d, DWORD PTR offset$[rsp]
	mov	rax, QWORD PTR section$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11887
	call	DoDebugMsg
	jmp	SHORT $LN17@coff_write
$LN16@coff_write:

; 1101 :                       section->sym.name, offset, size - section->e.seginfo->start_loc, section->e.seginfo->bytes_written, *(section->e.seginfo->CodeBuffer), *(section->e.seginfo->CodeBuffer+1)));
; 1102 :         else
; 1103 :             DebugMsg(("coff_write_data(%s, %Xh): size=%X, buffer=NULL\n",

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR size$9[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	r9d, eax
	mov	r8d, DWORD PTR offset$[rsp]
	mov	rax, QWORD PTR section$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11888
	call	DoDebugMsg
$LN17@coff_write:

; 1104 :                       section->sym.name, offset, size - section->e.seginfo->start_loc ));
; 1105 : #endif
; 1106 : 
; 1107 :         /* don't write section data for bss and uninitialized stack segments */
; 1108 :         if ( section->e.seginfo->combine == COMB_STACK && section->e.seginfo->bytes_written == 0 )

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+108]
	and	al, 7
	movzx	eax, al
	cmp	eax, 5
	jne	SHORT $LN18@coff_write
	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN18@coff_write

; 1109 :             continue;

	jmp	$LN8@coff_write
$LN18@coff_write:

; 1110 :         if ( section->e.seginfo->segtype == SEGTYPE_BSS )

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 3
	jne	SHORT $LN19@coff_write

; 1111 :             continue;

	jmp	$LN8@coff_write
$LN19@coff_write:

; 1112 : 
; 1113 :         if ( size ) {

	cmp	DWORD PTR size$9[rsp], 0
	je	$LN20@coff_write

; 1114 :             offset += size;

	mov	eax, DWORD PTR size$9[rsp]
	mov	ecx, DWORD PTR offset$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR offset$[rsp], eax

; 1115 :             if ((offset & 1) && section->e.seginfo->FixupList.head ) {

	mov	eax, DWORD PTR offset$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN21@coff_write
	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN21@coff_write

; 1116 :                 offset++;

	mov	eax, DWORD PTR offset$[rsp]
	inc	eax
	mov	DWORD PTR offset$[rsp], eax

; 1117 :                 size++;

	mov	eax, DWORD PTR size$9[rsp]
	inc	eax
	mov	DWORD PTR size$9[rsp], eax
$LN21@coff_write:

; 1118 :             }
; 1119 :             if ( section->e.seginfo->CodeBuffer == NULL ) {

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN22@coff_write

; 1120 :                 fseek( CurrFile[OBJ], size, SEEK_CUR );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r8d, 1
	mov	edx, DWORD PTR size$9[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_fseek

; 1121 :             } else {

	jmp	$LN23@coff_write
$LN22@coff_write:

; 1122 :                 /* if there was an ORG, the buffer content will
; 1123 :                  * start with the ORG address. The bytes from
; 1124 :                  * 0 - ORG must be written by moving the file pointer!
; 1125 :                  */
; 1126 :                 if ( section->e.seginfo->start_loc ) {

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+8], 0
	je	SHORT $LN24@coff_write

; 1127 :                     fseek( CurrFile[OBJ], section->e.seginfo->start_loc, SEEK_CUR );

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 8
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR tv348[rsp], rdx
	mov	r8d, 1
	mov	edx, DWORD PTR [rax+8]
	mov	rax, QWORD PTR tv348[rsp]
	mov	rcx, QWORD PTR [rax+rcx]
	call	QWORD PTR __imp_fseek

; 1128 :                     size -= section->e.seginfo->start_loc;

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR size$9[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR size$9[rsp], eax
$LN24@coff_write:

; 1129 :                 }
; 1130 : 
; 1131 :                 if ( fwrite( section->e.seginfo->CodeBuffer, 1, size, CurrFile[OBJ] ) != size )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	edx, DWORD PTR size$9[rsp]
	mov	r8, QWORD PTR section$[rsp]
	mov	r8, QWORD PTR [r8+96]
	mov	QWORD PTR tv376[rsp], r8
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, edx
	mov	edx, 1
	mov	rax, QWORD PTR tv376[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	QWORD PTR __imp_fwrite
	mov	ecx, DWORD PTR size$9[rsp]
	cmp	rax, rcx
	je	SHORT $LN25@coff_write

; 1132 :                     WriteError();

	call	WriteError
$LN25@coff_write:
$LN23@coff_write:

; 1133 :             }
; 1134 : 
; 1135 :             coff_write_fixups( section, &offset, &index );

	lea	r8, QWORD PTR index$[rsp]
	lea	rdx, QWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR section$[rsp]
	call	coff_write_fixups
$LN20@coff_write:

; 1136 :         } /* end if (size) */
; 1137 : 
; 1138 :         /* v2.07: the following block has beem moved outside of "if(size)" block,
; 1139 :          * because it may happen that a segment has size 0 and still debug info.
; 1140 :          * In any case it's important to initialize section->e.seginfo->num_linnums
; 1141 :          */
; 1142 :         /* write line number data. The peculiarity of COFF (compared to OMF) is
; 1143 :          * that line numbers are always relative to a function start.
; 1144 :          *
; 1145 :          * an item with line number 0 has a special meaning - it contains a reference
; 1146 :          * ( a symbol table index ) to the function whose line numbers are to follow.
; 1147 :          * this item is to be followed by an item with line number 32767, which then
; 1148 :          * tells the function's start offset ( undocumented! ).
; 1149 :          *
; 1150 :          */
; 1151 :         if( Options.line_numbers && section->e.seginfo->LinnumQueue ) {

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	$LN26@coff_write
	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+56], 0
	je	$LN26@coff_write

; 1152 :             IMAGE_LINENUMBER il;
; 1153 :             struct line_num_info *lni;
; 1154 :             struct asym *last;
; 1155 :             uint_32 line_numbers = 0;

	mov	DWORD PTR line_numbers$13[rsp], 0

; 1156 :             last = NULL;

	mov	QWORD PTR last$12[rsp], 0

; 1157 :             lni = (struct line_num_info *)((struct qdesc *)section->e.seginfo->LinnumQueue)->head;

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR lni$11[rsp], rax

; 1158 :             DebugMsg(("coff_write_data(%s): writing linnum data\n", section->sym.name ));

	mov	rax, QWORD PTR section$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11898
	call	DoDebugMsg

; 1159 :             for( ; lni; lni = lni->next ) {

	jmp	SHORT $LN13@coff_write
$LN11@coff_write:
	mov	rax, QWORD PTR lni$11[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR lni$11[rsp], rax
$LN13@coff_write:
	cmp	QWORD PTR lni$11[rsp], 0
	je	$LN12@coff_write

; 1160 :                 DebugMsg(("coff_write_data(%s, %Xh): linnum, #=%u, %s=%X, sym=%s\n",

	mov	rax, QWORD PTR lni$11[rsp]
	cmp	DWORD PTR [rax+8], 0
	je	SHORT $LN34@coff_write
	lea	rax, OFFSET FLAT:$SG11899
	mov	QWORD PTR tv242[rsp], rax
	jmp	SHORT $LN35@coff_write
$LN34@coff_write:
	mov	rax, QWORD PTR lni$11[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv242[rsp], rax
$LN35@coff_write:
	mov	rax, QWORD PTR lni$11[rsp]
	cmp	DWORD PTR [rax+8], 0
	je	SHORT $LN36@coff_write
	lea	rax, OFFSET FLAT:$SG11900
	mov	QWORD PTR tv248[rsp], rax
	jmp	SHORT $LN37@coff_write
$LN36@coff_write:
	lea	rax, OFFSET FLAT:$SG11901
	mov	QWORD PTR tv248[rsp], rax
$LN37@coff_write:
	mov	rax, QWORD PTR tv242[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR lni$11[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR tv248[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR lni$11[rsp]
	mov	r9d, DWORD PTR [rax+8]
	mov	r8d, DWORD PTR offset$[rsp]
	mov	rax, QWORD PTR section$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11902
	call	DoDebugMsg

; 1161 :                           section->sym.name, offset, lni->number, lni->number ? "ofs" : "idx", lni->offset, lni->number ? "NULL" : lni->sym->name ));
; 1162 :                 if ( lni->number == 0 ) {

	mov	rax, QWORD PTR lni$11[rsp]
	cmp	DWORD PTR [rax+8], 0
	jne	$LN27@coff_write

; 1163 :                     last = lni->sym;

	mov	rax, QWORD PTR lni$11[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR last$12[rsp], rax

; 1164 :                     if ( cm->lastproc )

	mov	rax, QWORD PTR cm$[rsp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN29@coff_write

; 1165 :                         cm->lastproc->debuginfo->next_proc = lni->sym->ext_idx;

	mov	rax, QWORD PTR lni$11[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR cm$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR [rcx+64]
	mov	eax, DWORD PTR [rax+88]
	mov	DWORD PTR [rcx+16], eax
$LN29@coff_write:

; 1166 :                     cm->lastproc = lni->sym;

	mov	rax, QWORD PTR cm$[rsp]
	mov	rcx, QWORD PTR lni$11[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 1167 :                     lni->sym->debuginfo->next_proc = 0;

	mov	rax, QWORD PTR lni$11[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rax+64]
	mov	DWORD PTR [rax+16], 0

; 1168 :                     il.Linenumber = 0;

	xor	eax, eax
	mov	WORD PTR il$10[rsp+4], ax

; 1169 : #ifdef DEBUG_OUT
; 1170 :                     /* if symbol table index is 0, then the proc wasn't added
; 1171 :                      * to the "publics" queue in AddLinnumDataRef().
; 1172 :                      */
; 1173 :                     if ( lni->sym->ext_idx == 0 ) {

	mov	rax, QWORD PTR lni$11[rsp]
	mov	rax, QWORD PTR [rax+16]
	cmp	DWORD PTR [rax+88], 0
	jne	SHORT $LN30@coff_write

; 1174 :                         DebugMsg(("coff_write_data(%s, %Xh): error, %s has symbol table index 0\n",

	mov	rax, QWORD PTR lni$11[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	r9, QWORD PTR [rax+8]
	mov	r8d, DWORD PTR offset$[rsp]
	mov	rax, QWORD PTR section$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11907
	call	DoDebugMsg
$LN30@coff_write:

; 1175 :                                   section->sym.name, offset, lni->sym->name ));
; 1176 :                     }
; 1177 : #endif
; 1178 :                     il.Type.SymbolTableIndex = lni->sym->ext_idx;

	mov	rax, QWORD PTR lni$11[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+88]
	mov	DWORD PTR il$10[rsp], eax

; 1179 :                     lni->sym->debuginfo->start_line = lni->line_number;

	mov	rax, QWORD PTR lni$11[rsp]
	mov	eax, DWORD PTR [rax+12]
	and	eax, 1048575				; 000fffffH
	mov	rcx, QWORD PTR lni$11[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR [rcx+64]
	mov	DWORD PTR [rcx], eax

; 1180 :                     //((struct dsym *)lni->sym)->e.procinfo->file = lni->file;
; 1181 :                     lni->sym->debuginfo->ln_fileofs = cm->start_data + offset;

	mov	rax, QWORD PTR cm$[rsp]
	mov	eax, DWORD PTR [rax+32]
	add	eax, DWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR lni$11[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR [rcx+64]
	mov	DWORD PTR [rcx+8], eax

; 1182 :                     DebugMsg(("coff_write_data(%s, %Xh): proc %s start_line=%u\n",

	mov	rax, QWORD PTR lni$11[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rax+64]
	mov	rcx, QWORD PTR lni$11[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR [rcx+8]
	mov	r8d, DWORD PTR offset$[rsp]
	mov	rax, QWORD PTR section$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11908
	call	DoDebugMsg

; 1183 :                               section->sym.name, offset, lni->sym->name, lni->sym->debuginfo->start_line ));
; 1184 :                 } else {

	jmp	$LN28@coff_write
$LN27@coff_write:

; 1185 :                     /**/myassert( last != NULL );

	cmp	QWORD PTR last$12[rsp], 0
	je	SHORT $LN38@coff_write
	mov	DWORD PTR tv308[rsp], 0
	jmp	SHORT $LN39@coff_write
$LN38@coff_write:
	mov	edx, 1185				; 000004a1H
	lea	rcx, OFFSET FLAT:$SG11909
	call	InternalError
	mov	DWORD PTR tv308[rsp], eax
$LN39@coff_write:

; 1186 :                     il.Linenumber = lni->number - last->debuginfo->start_line;

	mov	rax, QWORD PTR last$12[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	rcx, QWORD PTR lni$11[rsp]
	mov	eax, DWORD PTR [rax]
	mov	ecx, DWORD PTR [rcx+8]
	sub	ecx, eax
	mov	eax, ecx
	mov	WORD PTR il$10[rsp+4], ax

; 1187 :                     /* if current line number - start line number is 0,
; 1188 :                      * generate a "32767" line number item.
; 1189 :                      */
; 1190 :                     if ( il.Linenumber == 0 )

	movzx	eax, WORD PTR il$10[rsp+4]
	test	eax, eax
	jne	SHORT $LN31@coff_write

; 1191 :                         il.Linenumber = 0x7FFF;

	mov	eax, 32767				; 00007fffH
	mov	WORD PTR il$10[rsp+4], ax
$LN31@coff_write:

; 1192 :                     il.Type.VirtualAddress = lni->offset;

	mov	rax, QWORD PTR lni$11[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR il$10[rsp], eax
$LN28@coff_write:

; 1193 :                 }
; 1194 :                 /* v2.11: last is always != NULL */
; 1195 :                 //if ( last ) {
; 1196 :                     last->debuginfo->line_numbers++;

	mov	rax, QWORD PTR last$12[rsp]
	mov	rax, QWORD PTR [rax+64]
	movzx	eax, WORD PTR [rax+12]
	inc	ax
	mov	rcx, QWORD PTR last$12[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	mov	WORD PTR [rcx+12], ax

; 1197 :                     last->debuginfo->end_line = lni->number;

	mov	rax, QWORD PTR last$12[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	rcx, QWORD PTR lni$11[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax+4], ecx

; 1198 :                 //}
; 1199 :                 if ( fwrite( &il, 1, sizeof(il), CurrFile[OBJ] ) != sizeof(il) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 6
	mov	edx, 1
	lea	rcx, QWORD PTR il$10[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 6
	je	SHORT $LN32@coff_write

; 1200 :                     WriteError();

	call	WriteError
$LN32@coff_write:

; 1201 :                 offset += sizeof(il);

	mov	eax, DWORD PTR offset$[rsp]
	add	rax, 6
	mov	DWORD PTR offset$[rsp], eax

; 1202 :                 line_numbers++;

	mov	eax, DWORD PTR line_numbers$13[rsp]
	inc	eax
	mov	DWORD PTR line_numbers$13[rsp], eax

; 1203 :             } /* end for */

	jmp	$LN11@coff_write
$LN12@coff_write:

; 1204 :             section->e.seginfo->num_linnums = line_numbers;

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR line_numbers$13[rsp]
	mov	DWORD PTR [rax+56], ecx
$LN26@coff_write:

; 1205 :         } /* end if (Options.line_numbers...) */
; 1206 :     } /* end for */

	jmp	$LN8@coff_write
$LN9@coff_write:

; 1207 : 
; 1208 :     cm->size_data = offset;

	mov	rax, QWORD PTR cm$[rsp]
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rax+36], ecx

; 1209 : 
; 1210 :     DebugMsg(("coff_write_data: exit, size of sections=%Xh\n", cm->size_data ));

	mov	rax, QWORD PTR cm$[rsp]
	mov	edx, DWORD PTR [rax+36]
	lea	rcx, OFFSET FLAT:$SG11912
	call	DoDebugMsg

; 1211 : 
; 1212 :     return( NOT_ERROR );

	xor	eax, eax

; 1213 : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:coff_write_data$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 272				; 00000110H
	pop	rdi
	ret	0
coff_write_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
offset$ = 64
index$ = 68
fix$ = 72
ir$ = 88
tv130 = 128
tv159 = 132
__$ArrayPad$ = 136
section$ = 160
poffset$ = 168
pindex$ = 176
coff_write_fixups PROC

; 893  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 144				; 00000090H
	mov	rdi, rsp
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+160]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 894  :     uint_32 offset = *poffset;

	mov	rax, QWORD PTR poffset$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR offset$[rsp], eax

; 895  :     uint_32 index = *pindex;

	mov	rax, QWORD PTR pindex$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR index$[rsp], eax

; 896  :     struct fixup *fix;
; 897  :     IMAGE_RELOCATION ir;
; 898  : 
; 899  :     /* v2.10: handle the reloc-overflow-case */
; 900  :     if ( section->e.seginfo->num_relocs > 0xffff ) {

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+64], 65535		; 0000ffffH
	jbe	$LN9@coff_write

; 901  :         DebugMsg(("coff_write_fixups(%s): enter, num_relocs=%" I32_SPEC "u\n", section->sym.name, section->e.seginfo->num_relocs ));

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	r8d, DWORD PTR [rax+64]
	mov	rax, QWORD PTR section$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11811
	call	DoDebugMsg

; 902  :         ir.VirtualAddress = section->e.seginfo->num_relocs + 1;

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+64]
	inc	eax
	mov	DWORD PTR ir$[rsp], eax

; 903  :         ir.SymbolTableIndex = 0;

	mov	DWORD PTR ir$[rsp+4], 0

; 904  :         ir.Type = IMAGE_REL_I386_ABSOLUTE; /* doesn't matter if 32- or 64-bit */

	xor	eax, eax
	mov	WORD PTR ir$[rsp+8], ax

; 905  :         if ( fwrite( &ir, 1, sizeof(ir), CurrFile[OBJ] ) != sizeof(ir) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 10
	mov	edx, 1
	lea	rcx, QWORD PTR ir$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 10
	je	SHORT $LN10@coff_write

; 906  :             WriteError();

	call	WriteError
$LN10@coff_write:

; 907  :         offset += sizeof( ir );

	mov	eax, DWORD PTR offset$[rsp]
	add	rax, 10
	mov	DWORD PTR offset$[rsp], eax
$LN9@coff_write:

; 908  :     }
; 909  :     /* reset counter */
; 910  :     section->e.seginfo->num_relocs = 0;

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+64], 0

; 911  : 
; 912  :     for ( fix = section->e.seginfo->FixupList.head; fix ; fix = fix->nextrlc ) {

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR fix$[rsp], rax
	jmp	SHORT $LN4@coff_write
$LN2@coff_write:
	mov	rax, QWORD PTR fix$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR fix$[rsp], rax
$LN4@coff_write:
	cmp	QWORD PTR fix$[rsp], 0
	je	$LN3@coff_write

; 913  : #if AMD64_SUPPORT
; 914  :         if ( section->e.seginfo->Ofssize == USE64 ) {

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+104]
	cmp	eax, 2
	jne	$LN11@coff_write

; 915  :             switch ( fix->type ) {

	mov	rax, QWORD PTR fix$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv130[rsp], eax
	cmp	DWORD PTR tv130[rsp], 13
	ja	SHORT $LN20@coff_write
	movsxd	rax, DWORD PTR tv130[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN37@coff_write[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN13@coff_write:

; 916  :             case FIX_VOID:
; 917  :                 continue;

	jmp	SHORT $LN2@coff_write
$LN14@coff_write:

; 918  :             case FIX_RELOFF32: /* 32bit offset */
; 919  :                 /* translated to IMAGE_REL_AMD64_REL32_[1|2|3|4|5] */
; 920  :                 ir.Type = IMAGE_REL_AMD64_REL32 + (fix->addbytes - 4);

	mov	rax, QWORD PTR fix$[rsp]
	movzx	eax, BYTE PTR [rax+32]
	mov	WORD PTR ir$[rsp+8], ax

; 921  :                 break;

	jmp	$LN5@coff_write
$LN15@coff_write:

; 922  :             case FIX_OFF32: /* 32bit offset */
; 923  :                 ir.Type = IMAGE_REL_AMD64_ADDR32;

	mov	eax, 2
	mov	WORD PTR ir$[rsp+8], ax

; 924  :                 break;

	jmp	$LN5@coff_write
$LN16@coff_write:

; 925  : #if IMAGERELSUPP
; 926  :             case FIX_OFF32_IMGREL:
; 927  :                 ir.Type = IMAGE_REL_AMD64_ADDR32NB;

	mov	eax, 3
	mov	WORD PTR ir$[rsp+8], ax

; 928  :                 break;

	jmp	$LN5@coff_write
$LN17@coff_write:

; 929  : #endif
; 930  : #if SECTIONRELSUPP
; 931  :             case FIX_OFF32_SECREL:
; 932  :                 ir.Type = IMAGE_REL_AMD64_SECREL;

	mov	eax, 11
	mov	WORD PTR ir$[rsp+8], ax

; 933  :                 break;

	jmp	$LN5@coff_write
$LN18@coff_write:

; 934  : #endif
; 935  :             case FIX_OFF64: /* 64bit offset */
; 936  :                 ir.Type = IMAGE_REL_AMD64_ADDR64;

	mov	eax, 1
	mov	WORD PTR ir$[rsp+8], ax

; 937  :                 break;

	jmp	$LN5@coff_write
$LN19@coff_write:

; 938  :             case FIX_SEG: /* segment fixup */
; 939  :                 ir.Type = IMAGE_REL_AMD64_SECTION; /* ??? */

	mov	eax, 10
	mov	WORD PTR ir$[rsp+8], ax

; 940  :                 break;

	jmp	$LN5@coff_write
$LN20@coff_write:

; 941  : #if 0 /* not supported by COFF64! shouldn't reach this point */
; 942  :             case FIX_RELOFF8:
; 943  :             case FIX_RELOFF16:
; 944  :             case FIX_OFF8:
; 945  :             case FIX_OFF16:
; 946  :             case FIX_HIBYTE:
; 947  :             case FIX_PTR16: /* 16bit far pointer */
; 948  :             case FIX_PTR32: /* 32bit far pointer */
; 949  : #endif
; 950  :             default:
; 951  :                 DebugMsg(("coff_write_fixups(%s, %Xh): reloc loc=%X type=%u idx=%u sym=%s\n",

	mov	rax, QWORD PTR fix$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR fix$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR [rcx+88]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR fix$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR fix$[rsp]
	mov	r9d, DWORD PTR [rax+20]
	mov	r8d, DWORD PTR offset$[rsp]
	mov	rax, QWORD PTR section$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11823
	call	DoDebugMsg

; 952  :                           section->sym.name, offset, fix->locofs, fix->type, fix->sym->ext_idx, fix->sym->name));
; 953  :                 EmitErr( UNKNOWN_FIXUP_TYPE, fix->type, section->sym.name, fix->locofs );

	mov	rax, QWORD PTR fix$[rsp]
	mov	r9d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR section$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR fix$[rsp]
	mov	edx, DWORD PTR [rax+24]
	mov	ecx, 196				; 000000c4H
	call	EmitErr

; 954  :                 continue; /* v2.03: skip this fixup */

	jmp	$LN2@coff_write
$LN5@coff_write:

; 955  :                 //break;
; 956  :             }
; 957  :         } else

	jmp	$LN12@coff_write
$LN11@coff_write:

; 958  : #endif
; 959  :             switch ( fix->type ) {

	mov	rax, QWORD PTR fix$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv159[rsp], eax
	cmp	DWORD PTR tv159[rsp], 13
	ja	$LN29@coff_write
	movsxd	rax, DWORD PTR tv159[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN36@coff_write[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN21@coff_write:

; 960  :             case FIX_VOID:
; 961  :                 continue;

	jmp	$LN2@coff_write
$LN22@coff_write:

; 962  :             case FIX_RELOFF16: /* 16bit offset */
; 963  :                 ir.Type = IMAGE_REL_I386_REL16;

	mov	eax, 2
	mov	WORD PTR ir$[rsp+8], ax

; 964  :                 break;

	jmp	$LN7@coff_write
$LN23@coff_write:

; 965  :             case FIX_OFF16: /* 16bit offset */
; 966  :                 ir.Type = IMAGE_REL_I386_DIR16;

	mov	eax, 1
	mov	WORD PTR ir$[rsp+8], ax

; 967  :                 break;

	jmp	$LN7@coff_write
$LN24@coff_write:

; 968  :             case FIX_RELOFF32: /* 32bit offset */
; 969  :                 ir.Type = IMAGE_REL_I386_REL32;

	mov	eax, 20
	mov	WORD PTR ir$[rsp+8], ax

; 970  :                 break;

	jmp	$LN7@coff_write
$LN25@coff_write:

; 971  :             case FIX_OFF32: /* 32bit offset */
; 972  :                 ir.Type = IMAGE_REL_I386_DIR32;

	mov	eax, 6
	mov	WORD PTR ir$[rsp+8], ax

; 973  :                 break;

	jmp	$LN7@coff_write
$LN26@coff_write:

; 974  : #if IMAGERELSUPP
; 975  :             case FIX_OFF32_IMGREL:
; 976  :                 ir.Type = IMAGE_REL_I386_DIR32NB;

	mov	eax, 7
	mov	WORD PTR ir$[rsp+8], ax

; 977  :                 break;

	jmp	$LN7@coff_write
$LN27@coff_write:

; 978  : #endif
; 979  : #if SECTIONRELSUPP
; 980  :             case FIX_OFF32_SECREL:
; 981  :                 ir.Type = IMAGE_REL_I386_SECREL;

	mov	eax, 11
	mov	WORD PTR ir$[rsp+8], ax

; 982  :                 break;

	jmp	$LN7@coff_write
$LN28@coff_write:

; 983  : #endif
; 984  :             case FIX_SEG: /* segment fixup */
; 985  :                 ir.Type = IMAGE_REL_I386_SECTION; /* ??? */

	mov	eax, 10
	mov	WORD PTR ir$[rsp+8], ax

; 986  :                 break;

	jmp	$LN7@coff_write
$LN29@coff_write:

; 987  : #if 0
; 988  :             case FIX_OFF8:
; 989  :             case FIX_RELOFF8:
; 990  :             case FIX_HIBYTE:
; 991  :             case FIX_PTR16: /* 16bit far pointer */
; 992  :             case FIX_PTR32: /* 32bit far pointer */
; 993  : #endif
; 994  :             default:
; 995  :                 DebugMsg(("coff_write_fixups(%s, %Xh): reloc loc=%X type=%u idx=%u sym=%s\n",

	mov	rax, QWORD PTR fix$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR fix$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR [rcx+88]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR fix$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR fix$[rsp]
	mov	r9d, DWORD PTR [rax+20]
	mov	r8d, DWORD PTR offset$[rsp]
	mov	rax, QWORD PTR section$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11833
	call	DoDebugMsg

; 996  :                           section->sym.name, offset, fix->locofs, fix->type, fix->sym->ext_idx, fix->sym->name));
; 997  :                 EmitErr( UNKNOWN_FIXUP_TYPE, fix->type, section->sym.name, fix->locofs );

	mov	rax, QWORD PTR fix$[rsp]
	mov	r9d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR section$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR fix$[rsp]
	mov	edx, DWORD PTR [rax+24]
	mov	ecx, 196				; 000000c4H
	call	EmitErr

; 998  :                 continue; /* v2.03: skip this fixup */

	jmp	$LN2@coff_write
$LN7@coff_write:
$LN12@coff_write:

; 999  :                 //break;
; 1000 :             }
; 1001 :         /* if it's not EXTERNAL/PUBLIC, add symbol */
; 1002 :         /* if it's an assembly time variable, create helper symbol */
; 1003 :         if ( fix->sym->variable == TRUE ) {

	mov	rax, QWORD PTR fix$[rsp]
	mov	rax, QWORD PTR [rax+56]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN30@coff_write

; 1004 : #if HELPSYMS
; 1005 :             struct asym *sym;
; 1006 :             char buffer[12];
; 1007 :             sprintf( buffer, "$$%06X", fix->offset );
; 1008 :             sym = SymAlloc( buffer );
; 1009 :             sym->state = fix->sym->state;
; 1010 :             sym->mem_type = fix->sym->mem_type;
; 1011 :             sym->offset = fix->offset;
; 1012 :             sym->segment = fix->segment;
; 1013 :             sym->variable = TRUE; /* storage class LABEL */
; 1014 :             fix->sym = sym;
; 1015 :             AddPublicData( fix->sym );
; 1016 :             fix->sym->idx = index++;
; 1017 : #else
; 1018 :             /* just use the segment entry. This approach requires
; 1019 :              * that the offset is stored inline at the reloc location
; 1020 :              * (patch in fixup.c)
; 1021 :              */
; 1022 :             fix->sym = fix->segment_var;

	mov	rax, QWORD PTR fix$[rsp]
	mov	rcx, QWORD PTR fix$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	mov	QWORD PTR [rax+56], rcx

; 1023 : #endif
; 1024 :         } else if (( fix->sym->state == SYM_INTERNAL ) &&

	jmp	$LN31@coff_write
$LN30@coff_write:

; 1025 :                    fix->sym->included == FALSE &&

	mov	rax, QWORD PTR fix$[rsp]
	mov	rax, QWORD PTR [rax+56]
	cmp	DWORD PTR [rax+32], 1
	jne	$LN32@coff_write
	mov	rax, QWORD PTR fix$[rsp]
	mov	rax, QWORD PTR [rax+56]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	$LN32@coff_write
	mov	rax, QWORD PTR fix$[rsp]
	mov	rax, QWORD PTR [rax+56]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	$LN32@coff_write

; 1026 :                    fix->sym->ispublic == FALSE ) {
; 1027 :             fix->sym->included = TRUE;

	mov	rax, QWORD PTR fix$[rsp]
	mov	rax, QWORD PTR [rax+56]
	movzx	eax, BYTE PTR [rax+41]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR fix$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	BYTE PTR [rcx+41], al

; 1028 :             AddPublicData( fix->sym );

	mov	rax, QWORD PTR fix$[rsp]
	mov	rcx, QWORD PTR [rax+56]
	call	AddPublicData

; 1029 :             DebugMsg(("coff_write_fixups(%s, %Xh): %s added to symbol table, idx=%u\n",

	mov	rax, QWORD PTR fix$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	ecx, DWORD PTR index$[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9, QWORD PTR [rax+8]
	mov	r8d, DWORD PTR offset$[rsp]
	mov	rax, QWORD PTR section$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11837
	call	DoDebugMsg

; 1030 :                       section->sym.name, offset, fix->sym->name, index ));
; 1031 :             fix->sym->ext_idx = index++;

	mov	rax, QWORD PTR fix$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	ecx, DWORD PTR index$[rsp]
	mov	DWORD PTR [rax+88], ecx
	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	DWORD PTR index$[rsp], eax

; 1032 :             if ( Options.line_numbers && fix->sym->isproc )

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	SHORT $LN33@coff_write
	mov	rax, QWORD PTR fix$[rsp]
	mov	rax, QWORD PTR [rax+56]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN33@coff_write

; 1033 :                 index += 6;

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 6
	mov	DWORD PTR index$[rsp], eax
$LN33@coff_write:
$LN32@coff_write:
$LN31@coff_write:

; 1034 :         }
; 1035 :         ir.VirtualAddress = fix->locofs;

	mov	rax, QWORD PTR fix$[rsp]
	mov	eax, DWORD PTR [rax+20]
	mov	DWORD PTR ir$[rsp], eax

; 1036 :         ir.SymbolTableIndex = fix->sym->ext_idx;

	mov	rax, QWORD PTR fix$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	eax, DWORD PTR [rax+88]
	mov	DWORD PTR ir$[rsp+4], eax

; 1037 :         if ( fwrite( &ir, 1, sizeof(ir), CurrFile[OBJ] ) != sizeof(ir) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 10
	mov	edx, 1
	lea	rcx, QWORD PTR ir$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 10
	je	SHORT $LN34@coff_write

; 1038 :             WriteError();

	call	WriteError
$LN34@coff_write:

; 1039 :         DebugMsg(("coff_write_fixups(%s, %Xh): reloc loc=%X type=%u idx=%u sym=%s\n",

	mov	rax, QWORD PTR fix$[rsp]
	mov	rax, QWORD PTR [rax+56]
	movzx	ecx, WORD PTR ir$[rsp+8]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR ir$[rsp+4]
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR ir$[rsp]
	mov	r8d, DWORD PTR offset$[rsp]
	mov	rax, QWORD PTR section$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11840
	call	DoDebugMsg

; 1040 :                   section->sym.name, offset, ir.VirtualAddress, ir.Type, ir.SymbolTableIndex, fix->sym->name));
; 1041 :         offset += sizeof( ir );

	mov	eax, DWORD PTR offset$[rsp]
	add	rax, 10
	mov	DWORD PTR offset$[rsp], eax

; 1042 :         section->e.seginfo->num_relocs++;

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+64]
	inc	eax
	mov	rcx, QWORD PTR section$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+64], eax

; 1043 :     } /* end for */

	jmp	$LN2@coff_write
$LN3@coff_write:

; 1044 :     DebugMsg(("coff_write_fixups(%s): exit, num_relocs=%" I32_SPEC "u\n", section->sym.name, section->e.seginfo->num_relocs ));

	mov	rax, QWORD PTR section$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	r8d, DWORD PTR [rax+64]
	mov	rax, QWORD PTR section$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11841
	call	DoDebugMsg

; 1045 :     *poffset = offset;

	mov	rax, QWORD PTR poffset$[rsp]
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rax], ecx

; 1046 :     *pindex = index;

	mov	rax, QWORD PTR pindex$[rsp]
	mov	ecx, DWORD PTR index$[rsp]
	mov	DWORD PTR [rax], ecx

; 1047 : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:coff_write_fixups$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 144				; 00000090H
	pop	rdi
	ret	0
	npad	1
$LN37@coff_write:
	DD	$LN13@coff_write
	DD	$LN20@coff_write
	DD	$LN20@coff_write
	DD	$LN14@coff_write
	DD	$LN20@coff_write
	DD	$LN20@coff_write
	DD	$LN15@coff_write
	DD	$LN18@coff_write
	DD	$LN19@coff_write
	DD	$LN20@coff_write
	DD	$LN20@coff_write
	DD	$LN20@coff_write
	DD	$LN16@coff_write
	DD	$LN17@coff_write
$LN36@coff_write:
	DD	$LN21@coff_write
	DD	$LN29@coff_write
	DD	$LN22@coff_write
	DD	$LN24@coff_write
	DD	$LN29@coff_write
	DD	$LN23@coff_write
	DD	$LN25@coff_write
	DD	$LN29@coff_write
	DD	$LN28@coff_write
	DD	$LN29@coff_write
	DD	$LN29@coff_write
	DD	$LN29@coff_write
	DD	$LN26@coff_write
	DD	$LN27@coff_write
coff_write_fixups ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
q$ = 32
curr$ = 40
sym$ = 48
index$ = 56
i$ = 60
lastfproc$ = 64
lastfile$ = 72
$T2 = 76
ModuleInfo$ = 96
cm$ = 104
SetSymbolIndices PROC

; 812  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]
	mov	BYTE PTR $T2[rsp], 0

; 813  :     struct qnode *q;
; 814  :     struct dsym  *curr;
; 815  :     struct asym  *sym;
; 816  :     uint_32 index;
; 817  :     uint_32 i;
; 818  :     struct asym *lastfproc;
; 819  :     unsigned lastfile = 0;

	mov	DWORD PTR lastfile$[rsp], 0

; 820  : 
; 821  :     index = 0;

	mov	DWORD PTR index$[rsp], 0

; 822  :     cm->lastproc = NULL;

	mov	rax, QWORD PTR cm$[rsp]
	mov	QWORD PTR [rax+16], 0

; 823  :     cm->start_files = 0;  /* v2.11: added */

	mov	rax, QWORD PTR cm$[rsp]
	mov	DWORD PTR [rax+40], 0

; 824  : 
; 825  : #if COMPID
; 826  :     index++;
; 827  : #endif
; 828  :     /* add absolute symbol @@feat.00 if -SAFESEH is set */
; 829  :     if ( Options.safeseh )

	movzx	eax, BYTE PTR Options+155
	test	eax, eax
	je	SHORT $LN11@SetSymbolI

; 830  :         index++;

	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	DWORD PTR index$[rsp], eax
$LN11@SetSymbolI:

; 831  : 
; 832  :     /* count AUX entries for .file. Depends on sizeof filename */
; 833  : 
; 834  :     if ( Options.no_file_entry == FALSE ) {

	movzx	eax, BYTE PTR Options+130
	test	eax, eax
	jne	SHORT $LN12@SetSymbolI

; 835  :         i = strlen( cm->dot_file_value );

	mov	rax, QWORD PTR cm$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	strlen
	mov	DWORD PTR i$[rsp], eax

; 836  :         index += i / sizeof( IMAGE_AUX_SYMBOL ) + 1;

	mov	eax, DWORD PTR i$[rsp]
	xor	edx, edx
	mov	ecx, 18
	div	rcx
	mov	ecx, DWORD PTR index$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	DWORD PTR index$[rsp], eax

; 837  :         if ( i % sizeof( IMAGE_AUX_SYMBOL ) )

	mov	eax, DWORD PTR i$[rsp]
	xor	edx, edx
	mov	ecx, 18
	div	rcx
	mov	rax, rdx
	test	rax, rax
	je	SHORT $LN13@SetSymbolI

; 838  :             index++;

	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	DWORD PTR index$[rsp], eax
$LN13@SetSymbolI:
$LN12@SetSymbolI:

; 839  :     }
; 840  : 
; 841  :     /* add entries for sections */
; 842  : 
; 843  :     cm->sectionstart = index;

	mov	rax, QWORD PTR cm$[rsp]
	mov	ecx, DWORD PTR index$[rsp]
	mov	DWORD PTR [rax+44], ecx

; 844  :     index += ModuleInfo->g.num_segs;

	mov	rax, QWORD PTR ModuleInfo$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR index$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR index$[rsp], eax

; 845  :     if ( Options.no_section_aux_entry == FALSE )

	movzx	eax, BYTE PTR Options+132
	test	eax, eax
	jne	SHORT $LN14@SetSymbolI

; 846  :         index += ModuleInfo->g.num_segs;

	mov	rax, QWORD PTR ModuleInfo$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR index$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR index$[rsp], eax
$LN14@SetSymbolI:

; 847  : 
; 848  :     /* count externals and protos */
; 849  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@SetSymbolI
$LN2@SetSymbolI:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@SetSymbolI:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@SetSymbolI

; 850  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN15@SetSymbolI
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN15@SetSymbolI

; 851  :             continue;

	jmp	SHORT $LN2@SetSymbolI
$LN15@SetSymbolI:

; 852  :         curr->sym.ext_idx = index++;

	mov	rax, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR index$[rsp]
	mov	DWORD PTR [rax+88], ecx
	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	DWORD PTR index$[rsp], eax

; 853  :         /* weak externals need an additional aux entry */
; 854  :         if ( curr->sym.iscomm == FALSE && curr->sym.altname )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN16@SetSymbolI
	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+64], 0
	je	SHORT $LN16@SetSymbolI

; 855  :             index++;

	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	DWORD PTR index$[rsp], eax
$LN16@SetSymbolI:

; 856  :     }

	jmp	$LN2@SetSymbolI
$LN3@SetSymbolI:

; 857  : 
; 858  : #if STATIC_PROCS
; 859  :     /* v2.04: count private procedures (will become static symbols) */
; 860  :     if ( Options.no_static_procs == FALSE )

	movzx	eax, BYTE PTR Options+131
	test	eax, eax
	jne	$LN17@SetSymbolI

; 861  :         for( curr = SymTables[TAB_PROC].head ; curr != NULL ; curr = curr->nextproc )

	mov	eax, 16
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN7@SetSymbolI
$LN5@SetSymbolI:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN7@SetSymbolI:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN6@SetSymbolI

; 862  :             if ( curr->sym.state == SYM_INTERNAL && curr->sym.ispublic == FALSE && curr->sym.included == FALSE ) {

	mov	rax, QWORD PTR curr$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN18@SetSymbolI
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@SetSymbolI
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@SetSymbolI

; 863  :                 curr->sym.included = TRUE;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR curr$[rsp]
	mov	BYTE PTR [rcx+41], al

; 864  :                 AddPublicData( &curr->sym );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, rax
	call	AddPublicData
$LN18@SetSymbolI:

; 865  :             }

	jmp	SHORT $LN5@SetSymbolI
$LN6@SetSymbolI:
$LN17@SetSymbolI:

; 866  : #endif
; 867  :     /* count items in public queue */
; 868  :     for ( q = ModuleInfo->g.PubQueue.head; q; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR q$[rsp], rax
	jmp	SHORT $LN10@SetSymbolI
$LN8@SetSymbolI:
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$[rsp], rax
$LN10@SetSymbolI:
	cmp	QWORD PTR q$[rsp], 0
	je	$LN9@SetSymbolI

; 869  :         sym = q->sym;

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR sym$[rsp], rax

; 870  :         /* if line numbers are on, co, add 6 entries for procs */
; 871  :         if ( Options.line_numbers && sym->isproc ) {

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	$LN19@SetSymbolI
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN19@SetSymbolI

; 872  :             if (  sym->debuginfo->file != lastfile ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	movzx	eax, WORD PTR [rax+14]
	cmp	eax, DWORD PTR lastfile$[rsp]
	je	SHORT $LN21@SetSymbolI

; 873  :                 if ( cm->start_files == 0 )

	mov	rax, QWORD PTR cm$[rsp]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN22@SetSymbolI

; 874  :                     cm->start_files = index;

	mov	rax, QWORD PTR cm$[rsp]
	mov	ecx, DWORD PTR index$[rsp]
	mov	DWORD PTR [rax+40], ecx
	jmp	SHORT $LN23@SetSymbolI
$LN22@SetSymbolI:

; 875  :                 else
; 876  :                     lastfproc->debuginfo->next_file = index;

	cmp	BYTE PTR $T2[rsp], 0
	jne	SHORT $LN25@SetSymbolI
	lea	rcx, OFFSET FLAT:SetSymbolIndices$rtcName$0
	call	_RTC_UninitUse
$LN25@SetSymbolI:
	mov	rax, QWORD PTR lastfproc$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	ecx, DWORD PTR index$[rsp]
	mov	DWORD PTR [rax+20], ecx
$LN23@SetSymbolI:

; 877  :                 lastfproc = sym;

	mov	BYTE PTR $T2[rsp], 1
	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR lastfproc$[rsp], rax

; 878  :                 index += 1 + GetFileAuxEntries( sym->debuginfo->file, NULL );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	xor	edx, edx
	movzx	ecx, WORD PTR [rax+14]
	call	GetFileAuxEntries
	mov	ecx, DWORD PTR index$[rsp]
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	DWORD PTR index$[rsp], eax

; 879  :                 lastfile = sym->debuginfo->file;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	movzx	eax, WORD PTR [rax+14]
	mov	DWORD PTR lastfile$[rsp], eax
$LN21@SetSymbolI:

; 880  :             }
; 881  :             sym->ext_idx = index++;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR index$[rsp]
	mov	DWORD PTR [rax+88], ecx
	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	DWORD PTR index$[rsp], eax

; 882  :             index += 6;

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 6
	mov	DWORD PTR index$[rsp], eax

; 883  :         } else

	jmp	SHORT $LN20@SetSymbolI
$LN19@SetSymbolI:

; 884  :             sym->ext_idx = index++;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR index$[rsp]
	mov	DWORD PTR [rax+88], ecx
	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	DWORD PTR index$[rsp], eax
$LN20@SetSymbolI:

; 885  :     }

	jmp	$LN8@SetSymbolI
$LN9@SetSymbolI:

; 886  :     return( index );

	mov	eax, DWORD PTR index$[rsp]

; 887  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
SetSymbolIndices ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
currsize$ = 32
cm$ = 40
i$ = 48
p$ = 56
tv83 = 64
tv89 = 72
seg$ = 96
curr$ = 104
size$ = 112
pv$ = 120
coff_flushfunc PROC

; 778  : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 779  :     unsigned currsize = curr - seg->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR curr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR currsize$[rsp], eax

; 780  :     struct coffmod *cm;
; 781  :     int i;
; 782  :     uint_8 *p;
; 783  : 
; 784  :     if ( ( currsize + size ) > SIZE_CV_SEGBUF ) {

	mov	eax, DWORD PTR size$[rsp]
	mov	ecx, DWORD PTR currsize$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, 1200				; 000004b0H
	jbe	$LN2@coff_flush

; 785  :         if ( currsize ) {

	cmp	DWORD PTR currsize$[rsp], 0
	je	$LN3@coff_flush

; 786  :             p = LclAlloc( currsize + sizeof( struct qditem ) );

	mov	eax, DWORD PTR currsize$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	LclAlloc
	mov	QWORD PTR p$[rsp], rax

; 787  :             ((struct qditem *)p)->next = NULL;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], 0

; 788  :             ((struct qditem *)p)->size = currsize;

	mov	rax, QWORD PTR p$[rsp]
	mov	ecx, DWORD PTR currsize$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 789  :             memcpy( p + sizeof( struct qditem ), seg->e.seginfo->CodeBuffer, currsize );

	mov	eax, DWORD PTR currsize$[rsp]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR p$[rsp]
	add	rdx, 16
	mov	QWORD PTR tv83[rsp], rdx
	mov	r8d, eax
	mov	rdx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR tv83[rsp]
	mov	rcx, rax
	call	memcpy

; 790  :             cm = pv;

	mov	rax, QWORD PTR pv$[rsp]
	mov	QWORD PTR cm$[rsp], rax

; 791  :             i = ( seg == cm->SymDeb[DBGS_TYPES].seg ? DBGS_TYPES : DBGS_SYMBOLS );

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR cm$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	cmp	QWORD PTR seg$[rsp], rax
	jne	SHORT $LN7@coff_flush
	mov	DWORD PTR tv89[rsp], 1
	jmp	SHORT $LN8@coff_flush
$LN7@coff_flush:
	mov	DWORD PTR tv89[rsp], 0
$LN8@coff_flush:
	mov	eax, DWORD PTR tv89[rsp]
	mov	DWORD PTR i$[rsp], eax

; 792  :             if ( cm->SymDeb[i].q.head == NULL )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR cm$[rsp]
	cmp	QWORD PTR [rcx+rax+56], 0
	jne	SHORT $LN4@coff_flush

; 793  :                 cm->SymDeb[i].q.head = cm->SymDeb[i].q.tail = p;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR cm$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+rax+64], rdx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR cm$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+rax+56], rdx
	jmp	SHORT $LN5@coff_flush
$LN4@coff_flush:

; 794  :             else {
; 795  :                 ((struct qditem *)(cm->SymDeb[i].q.tail))->next = p;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR cm$[rsp]
	mov	rax, QWORD PTR [rcx+rax+64]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 796  :                 cm->SymDeb[i].q.tail = p;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR cm$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+rax+64], rdx
$LN5@coff_flush:

; 797  :             }
; 798  :             seg->e.seginfo->current_loc = seg->e.seginfo->start_loc + currsize;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+8]
	add	eax, DWORD PTR currsize$[rsp]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+12], eax

; 799  :             seg->e.seginfo->start_loc = seg->e.seginfo->current_loc;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+8], eax
$LN3@coff_flush:

; 800  :         }
; 801  :         return( seg->e.seginfo->CodeBuffer );

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	jmp	SHORT $LN1@coff_flush
$LN2@coff_flush:

; 802  :     }
; 803  :     return( curr );

	mov	rax, QWORD PTR curr$[rsp]
$LN1@coff_flush:

; 804  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
coff_flushfunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
size$ = 32
temp$ = 64
__$ArrayPad$ = 336
buffer$ = 368
msg$ = 376
GetStartLabel PROC

; 747  : {

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 352				; 00000160H
	mov	rdi, rsp
	mov	ecx, 88					; 00000058H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+368]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 748  :     int size = 0;

	mov	DWORD PTR size$[rsp], 0

; 749  :     char temp[ MAX_ID_LEN + MANGLE_BYTES + 1 ];
; 750  : 
; 751  :     if ( ModuleInfo.g.start_label ) {

	cmp	QWORD PTR ModuleInfo+208, 0
	je	$LN2@GetStartLa

; 752  :         Mangle( ModuleInfo.g.start_label, temp );

	lea	rdx, QWORD PTR temp$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+208
	call	Mangle

; 753  :         if ( Options.entry_decorated )

	movzx	eax, BYTE PTR Options+136
	test	eax, eax
	je	SHORT $LN3@GetStartLa

; 754  :             strcpy( buffer, temp );

	lea	rdx, QWORD PTR temp$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcpy
	jmp	$LN4@GetStartLa
$LN3@GetStartLa:

; 755  :         else {
; 756  :             if ( ModuleInfo.g.start_label->langtype != LANG_C &&
; 757  :                 ModuleInfo.g.start_label->langtype != LANG_STDCALL &&

	mov	rax, QWORD PTR ModuleInfo+208
	cmp	DWORD PTR [rax+76], 1
	je	$LN5@GetStartLa
	mov	rax, QWORD PTR ModuleInfo+208
	cmp	DWORD PTR [rax+76], 3
	je	SHORT $LN5@GetStartLa
	mov	rax, QWORD PTR ModuleInfo+208
	cmp	DWORD PTR [rax+76], 2
	je	SHORT $LN5@GetStartLa

; 758  :                 ModuleInfo.g.start_label->langtype != LANG_SYSCALL ) {
; 759  :                 if ( *ModuleInfo.g.start_label->name != '_' ) {

	mov	rax, QWORD PTR ModuleInfo+208
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN7@GetStartLa

; 760  :                     if ( msg && ( ModuleInfo.fctype != FCT_WIN64 ) )

	movzx	eax, BYTE PTR msg$[rsp]
	test	eax, eax
	je	SHORT $LN9@GetStartLa
	cmp	DWORD PTR ModuleInfo+376, 2
	je	SHORT $LN9@GetStartLa

; 761  :                         EmitWarn( 2, LEADING_UNDERSCORE_REQUIRED_FOR_START_LABEL, ModuleInfo.g.start_label->name );

	mov	rax, QWORD PTR ModuleInfo+208
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 194				; 000000c2H
	mov	ecx, 2
	call	EmitWarn
$LN9@GetStartLa:

; 762  :                     strcpy( buffer, temp );

	lea	rdx, QWORD PTR temp$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcpy

; 763  :                 } else {

	jmp	SHORT $LN8@GetStartLa
$LN7@GetStartLa:

; 764  :                     strcpy( buffer, temp+1 );

	lea	rax, QWORD PTR temp$[rsp+1]
	mov	rdx, rax
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcpy
$LN8@GetStartLa:

; 765  :                 }
; 766  :             } else

	jmp	SHORT $LN6@GetStartLa
$LN5@GetStartLa:

; 767  :                 strcpy( buffer, temp+1 );

	lea	rax, QWORD PTR temp$[rsp+1]
	mov	rdx, rax
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcpy
$LN6@GetStartLa:
$LN4@GetStartLa:

; 768  :         }
; 769  :         size = strlen( buffer ) + 8; // 8 == size of " -entry:"

	mov	rcx, QWORD PTR buffer$[rsp]
	call	strlen
	add	rax, 8
	mov	DWORD PTR size$[rsp], eax
$LN2@GetStartLa:

; 770  :     }
; 771  :     return( size );

	mov	eax, DWORD PTR size$[rsp]

; 772  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:GetStartLabel$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 352				; 00000160H
	pop	rdi
	ret	0
GetStartLabel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
cntSymbols$ = 48
curr$ = 56
sym$ = 64
q$ = 72
p$ = 88
len$ = 100
i$ = 104
is$ = 120
ias$ = 168
lastfile$ = 196
buffer$ = 224
sym$7 = 488
tv84 = 504
tv94 = 508
tv172 = 512
tv218 = 520
tv357 = 524
__$ArrayPad$ = 528
modinfo$ = 560
cm$ = 568
coff_write_symbols PROC

; 418  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 544				; 00000220H
	mov	rdi, rsp
	mov	ecx, 136				; 00000088H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+560]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 419  :     uint_32     cntSymbols = 0;

	mov	DWORD PTR cntSymbols$[rsp], 0

; 420  :     struct dsym *curr;
; 421  :     struct asym *sym;
; 422  :     struct qnode *q;
; 423  :     char        *p;
; 424  :     unsigned    len;
; 425  :     unsigned    i;
; 426  :     IMAGE_SYMBOL is;
; 427  :     IMAGE_AUX_SYMBOL ias;
; 428  :     unsigned    lastfile = 0;

	mov	DWORD PTR lastfile$[rsp], 0

; 429  :     char        buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 430  : 
; 431  :     DebugMsg(("coff_write_symbols: enter\n"));

	lea	rcx, OFFSET FLAT:$SG11645
	call	DoDebugMsg

; 432  : 
; 433  : #if COMPID
; 434  :     /* write "@comp.id" entry */
; 435  :     if ( fwrite( &isCompId, 1, sizeof(IMAGE_SYMBOL), CurrFile[OBJ] ) != sizeof(IMAGE_SYMBOL) )
; 436  :         WriteError();
; 437  :     cntSymbols++;
; 438  : #endif
; 439  :     /* "@feat.00" entry (for SafeSEH) */
; 440  :     if ( Options.safeseh ) {

	movzx	eax, BYTE PTR Options+155
	test	eax, eax
	je	SHORT $LN20@coff_write

; 441  :         if ( fwrite( &isFeat00, 1, sizeof(IMAGE_SYMBOL), CurrFile[OBJ] ) != sizeof(IMAGE_SYMBOL) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, OFFSET FLAT:isFeat00
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN21@coff_write

; 442  :             WriteError();

	call	WriteError
$LN21@coff_write:

; 443  :         cntSymbols++;

	mov	eax, DWORD PTR cntSymbols$[rsp]
	inc	eax
	mov	DWORD PTR cntSymbols$[rsp], eax
$LN20@coff_write:

; 444  :     }
; 445  : 
; 446  :     /* .file item (optionally disabled by -zlf) */
; 447  : 
; 448  :     if ( Options.no_file_entry == FALSE ) {

	movzx	eax, BYTE PTR Options+130
	test	eax, eax
	jne	$LN22@coff_write

; 449  :         strncpy( is.N.ShortName, ".file", IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG11649
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_strncpy

; 450  :         is.Value = ( Options.line_numbers ? cm->start_files : 0 );  /* index of next .file entry */

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	SHORT $LN71@coff_write
	mov	rax, QWORD PTR cm$[rsp]
	mov	eax, DWORD PTR [rax+40]
	mov	DWORD PTR tv84[rsp], eax
	jmp	SHORT $LN72@coff_write
$LN71@coff_write:
	mov	DWORD PTR tv84[rsp], 0
$LN72@coff_write:
	mov	eax, DWORD PTR tv84[rsp]
	mov	DWORD PTR is$[rsp+8], eax

; 451  :         is.SectionNumber = (uint_16)IMAGE_SYM_DEBUG;

	mov	eax, 65534				; 0000fffeH
	mov	WORD PTR is$[rsp+12], ax

; 452  :         is.Type = IMAGE_SYM_TYPE_NULL;

	xor	eax, eax
	mov	WORD PTR is$[rsp+14], ax

; 453  :         is.StorageClass = IMAGE_SYM_CLASS_FILE;

	mov	BYTE PTR is$[rsp+16], 103		; 00000067H

; 454  : 
; 455  :         p = cm->dot_file_value;

	mov	rax, QWORD PTR cm$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR p$[rsp], rax

; 456  :         i = strlen( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax

; 457  :         is.NumberOfAuxSymbols = i / sizeof(IMAGE_AUX_SYMBOL) + (i % sizeof(IMAGE_AUX_SYMBOL) ? 1 : 0);

	mov	eax, DWORD PTR i$[rsp]
	xor	edx, edx
	mov	ecx, 18
	div	rcx
	mov	rax, rdx
	test	rax, rax
	je	SHORT $LN73@coff_write
	mov	DWORD PTR tv94[rsp], 1
	jmp	SHORT $LN74@coff_write
$LN73@coff_write:
	mov	DWORD PTR tv94[rsp], 0
$LN74@coff_write:
	mov	eax, DWORD PTR i$[rsp]
	xor	edx, edx
	mov	ecx, 18
	div	rcx
	movsxd	rcx, DWORD PTR tv94[rsp]
	add	rax, rcx
	mov	BYTE PTR is$[rsp+17], al

; 458  :         if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN23@coff_write

; 459  :             WriteError();

	call	WriteError
$LN23@coff_write:

; 460  : 
; 461  :         for ( i = is.NumberOfAuxSymbols;i;i--, p += sizeof(IMAGE_AUX_SYMBOL) ) {

	movzx	eax, BYTE PTR is$[rsp+17]
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN4@coff_write
$LN2@coff_write:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR p$[rsp]
	add	rax, 18
	mov	QWORD PTR p$[rsp], rax
$LN4@coff_write:
	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN3@coff_write

; 462  :             strncpy( ias.File.Name, p, sizeof(IMAGE_AUX_SYMBOL) );

	mov	r8d, 18
	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, QWORD PTR ias$[rsp]
	call	QWORD PTR __imp_strncpy

; 463  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR ias$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN24@coff_write

; 464  :                 WriteError();

	call	WriteError
$LN24@coff_write:

; 465  :         }

	jmp	SHORT $LN2@coff_write
$LN3@coff_write:

; 466  :         cntSymbols += is.NumberOfAuxSymbols + 1;

	movzx	eax, BYTE PTR is$[rsp+17]
	mov	ecx, DWORD PTR cntSymbols$[rsp]
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	DWORD PTR cntSymbols$[rsp], eax
$LN22@coff_write:

; 467  :     }
; 468  : 
; 469  :     /* next are section entries */
; 470  : 
; 471  :     for( i = 1, curr = SymTables[TAB_SEG].head; curr; curr = curr->next, i++ ) {

	mov	DWORD PTR i$[rsp], 1
	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN7@coff_write
$LN5@coff_write:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@coff_write:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN6@coff_write

; 472  :         /* v2.07: prefer ALIAS name if defined */
; 473  :         p = ( curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ConvertSectionName( &curr->sym, NULL, buffer ) );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN75@coff_write
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR tv172[rsp], rax
	jmp	SHORT $LN76@coff_write
$LN75@coff_write:
	mov	rax, QWORD PTR curr$[rsp]
	lea	r8, QWORD PTR buffer$[rsp]
	xor	edx, edx
	mov	rcx, rax
	call	ConvertSectionName
	mov	QWORD PTR tv172[rsp], rax
$LN76@coff_write:
	mov	rax, QWORD PTR tv172[rsp]
	mov	QWORD PTR p$[rsp], rax

; 474  :         len = strlen( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 475  :         if ( len <= IMAGE_SIZEOF_SHORT_NAME )

	cmp	DWORD PTR len$[rsp], 8
	ja	SHORT $LN25@coff_write

; 476  :             strncpy( is.N.ShortName, p, IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_strncpy
	jmp	SHORT $LN26@coff_write
$LN25@coff_write:

; 477  :         else {
; 478  :             is.N.Name.Short = 0;

	mov	DWORD PTR is$[rsp], 0

; 479  :             is.N.Name.Long = Coff_AllocString( cm, p, len );

	mov	r8d, DWORD PTR len$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR cm$[rsp]
	call	Coff_AllocString
	mov	DWORD PTR is$[rsp+4], eax
$LN26@coff_write:

; 480  :         }
; 481  :         is.Value = 0;

	mov	DWORD PTR is$[rsp+8], 0

; 482  :         is.SectionNumber = i;

	movzx	eax, WORD PTR i$[rsp]
	mov	WORD PTR is$[rsp+12], ax

; 483  :         is.Type = IMAGE_SYM_TYPE_NULL;

	xor	eax, eax
	mov	WORD PTR is$[rsp+14], ax

; 484  :         is.StorageClass = IMAGE_SYM_CLASS_STATIC;

	mov	BYTE PTR is$[rsp+16], 3

; 485  :         is.NumberOfAuxSymbols = 0;

	mov	BYTE PTR is$[rsp+17], 0

; 486  :         if ( Options.no_section_aux_entry == FALSE )

	movzx	eax, BYTE PTR Options+132
	test	eax, eax
	jne	SHORT $LN27@coff_write

; 487  :             is.NumberOfAuxSymbols = 1;

	mov	BYTE PTR is$[rsp+17], 1
$LN27@coff_write:

; 488  : 
; 489  :         DebugMsg(("coff_write_symbols(%u, SECT): %s, type=%x, stgcls=%x\n", cntSymbols, curr->sym.name, is.Type, is.StorageClass ));

	movzx	eax, BYTE PTR is$[rsp+16]
	movzx	ecx, WORD PTR is$[rsp+14]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR cntSymbols$[rsp]
	lea	rcx, OFFSET FLAT:$SG11655
	call	DoDebugMsg

; 490  : 
; 491  :         if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN28@coff_write

; 492  :             WriteError();

	call	WriteError
$LN28@coff_write:

; 493  :         cntSymbols++;

	mov	eax, DWORD PTR cntSymbols$[rsp]
	inc	eax
	mov	DWORD PTR cntSymbols$[rsp], eax

; 494  : 
; 495  :         /* write the auxiliary symbol record for sections.
; 496  :          * may be suppressed with option -zls.
; 497  :          */
; 498  :         if ( Options.no_section_aux_entry == FALSE 
; 499  : #if COMDATSUPP
; 500  :             || curr->e.seginfo->comdat_selection

	movzx	eax, BYTE PTR Options+132
	test	eax, eax
	je	SHORT $LN30@coff_write
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+108]
	shr	al, 3
	and	al, 7
	movzx	eax, al
	test	eax, eax
	je	$LN29@coff_write
$LN30@coff_write:

; 501  : #endif
; 502  :             ) {
; 503  :             ias.Section.Length = curr->sym.max_offset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR ias$[rsp], eax

; 504  :             /* v2.10: check for overflow */
; 505  :             //ias.Section.NumberOfRelocations = curr->e.seginfo->num_relocs;
; 506  :             ias.Section.NumberOfRelocations = ( curr->e.seginfo->num_relocs > 0xffff ? 0xffff : (uint_16)curr->e.seginfo->num_relocs );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+64], 65535		; 0000ffffH
	jbe	SHORT $LN77@coff_write
	mov	DWORD PTR tv218[rsp], 65535		; 0000ffffH
	jmp	SHORT $LN78@coff_write
$LN77@coff_write:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, WORD PTR [rax+64]
	mov	DWORD PTR tv218[rsp], eax
$LN78@coff_write:
	movzx	eax, WORD PTR tv218[rsp]
	mov	WORD PTR ias$[rsp+4], ax

; 507  :             if ( Options.line_numbers )

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	SHORT $LN31@coff_write

; 508  :                 ias.Section.NumberOfLinenumbers = curr->e.seginfo->num_linnums;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, WORD PTR [rax+56]
	mov	WORD PTR ias$[rsp+6], ax
	jmp	SHORT $LN32@coff_write
$LN31@coff_write:

; 509  :             else
; 510  :                 ias.Section.NumberOfLinenumbers = 0;

	xor	eax, eax
	mov	WORD PTR ias$[rsp+6], ax
$LN32@coff_write:

; 511  :             /* CheckSum, Number and Selection are for COMDAT sections only */
; 512  : #if COMDATSUPP
; 513  :             if ( curr->e.seginfo->comdat_selection ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+108]
	shr	al, 3
	and	al, 7
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN33@coff_write

; 514  :                 ias.Section.CheckSum = CRC32Comdat( curr->e.seginfo->CodeBuffer, curr->sym.max_offset, 0 );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	xor	r8d, r8d
	mov	rcx, QWORD PTR curr$[rsp]
	mov	edx, DWORD PTR [rcx+56]
	mov	rcx, QWORD PTR [rax+16]
	call	CRC32Comdat
	mov	DWORD PTR ias$[rsp+8], eax

; 515  :                 ias.Section.Number = curr->e.seginfo->comdat_number;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, WORD PTR [rax+88]
	mov	WORD PTR ias$[rsp+12], ax

; 516  :                 ias.Section.Selection = curr->e.seginfo->comdat_selection;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+108]
	shr	al, 3
	and	al, 7
	mov	BYTE PTR ias$[rsp+14], al

; 517  :             } else {

	jmp	SHORT $LN34@coff_write
$LN33@coff_write:

; 518  : #endif
; 519  :                 ias.Section.CheckSum = 0;

	mov	DWORD PTR ias$[rsp+8], 0

; 520  :                 ias.Section.Number = 0;

	xor	eax, eax
	mov	WORD PTR ias$[rsp+12], ax

; 521  :                 ias.Section.Selection = 0;

	mov	BYTE PTR ias$[rsp+14], 0
$LN34@coff_write:

; 522  : #if COMDATSUPP
; 523  :             };
; 524  : #endif
; 525  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR ias$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN35@coff_write

; 526  :                 WriteError();

	call	WriteError
$LN35@coff_write:

; 527  :             DebugMsg(("coff_write_symbols(%u, SECT): %s, AUX, relocs=%u, linnums=%u\n", cntSymbols, curr->sym.name, ias.Section.NumberOfRelocations, ias.Section.NumberOfLinenumbers ));

	movzx	eax, WORD PTR ias$[rsp+6]
	movzx	ecx, WORD PTR ias$[rsp+4]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR cntSymbols$[rsp]
	lea	rcx, OFFSET FLAT:$SG11664
	call	DoDebugMsg

; 528  :             cntSymbols++;

	mov	eax, DWORD PTR cntSymbols$[rsp]
	inc	eax
	mov	DWORD PTR cntSymbols$[rsp], eax
$LN29@coff_write:

; 529  :         }
; 530  :     }

	jmp	$LN5@coff_write
$LN6@coff_write:

; 531  : 
; 532  :     /* third are externals + communals ( + protos [since v2.01] ) */
; 533  : 
; 534  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN10@coff_write
$LN8@coff_write:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN10@coff_write:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN9@coff_write

; 535  :         /* skip "weak" (=unused) externdefs */
; 536  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN36@coff_write
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN36@coff_write

; 537  :             DebugMsg(("coff_write_symbols(EXT+COMM): %s skipped, used=%u, comm=%u, weak=%u\n", curr->sym.name, curr->sym.used, curr->sym.iscomm, curr->sym.weak ));

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	mov	rcx, QWORD PTR curr$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	shr	cl, 2
	and	cl, 1
	movzx	ecx, cl
	mov	rdx, QWORD PTR curr$[rsp]
	movzx	edx, BYTE PTR [rdx+40]
	and	dl, 1
	movzx	edx, dl
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, edx
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11666
	call	DoDebugMsg

; 538  :             continue;

	jmp	$LN8@coff_write
$LN36@coff_write:

; 539  :         }
; 540  :         len = Mangle( &curr->sym, buffer );

	mov	rax, QWORD PTR curr$[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rax
	call	Mangle
	mov	DWORD PTR len$[rsp], eax

; 541  : 
; 542  :         is.Type = CoffGetType(&curr->sym);

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, rax
	call	CoffGetType
	mov	WORD PTR is$[rsp+14], ax

; 543  :         is.StorageClass = CoffGetClass(&curr->sym);

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, rax
	call	CoffGetClass
	mov	BYTE PTR is$[rsp+16], al

; 544  : 
; 545  :         DebugMsg(("coff_write_symbols(%u, EXT+COMM): %s, type=%x, stgcls=%x\n", cntSymbols, curr->sym.name, is.Type, is.StorageClass ));

	movzx	eax, BYTE PTR is$[rsp+16]
	movzx	ecx, WORD PTR is$[rsp+14]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR cntSymbols$[rsp]
	lea	rcx, OFFSET FLAT:$SG11667
	call	DoDebugMsg

; 546  : 
; 547  :         /* for COMMUNALs, store their size in the Value field */
; 548  :         if (curr->sym.iscomm == TRUE)

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN37@coff_write

; 549  :             is.Value = curr->sym.total_size;

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR is$[rsp+8], eax
	jmp	SHORT $LN38@coff_write
$LN37@coff_write:

; 550  :         else
; 551  :             is.Value = curr->sym.offset; /* is always 0 */

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR is$[rsp+8], eax
$LN38@coff_write:

; 552  :         is.SectionNumber = IMAGE_SYM_UNDEFINED;

	xor	eax, eax
	mov	WORD PTR is$[rsp+12], ax

; 553  :         is.NumberOfAuxSymbols = (( curr->sym.iscomm == FALSE && curr->sym.altname ) ? 1 : 0 );

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN79@coff_write
	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+64], 0
	je	SHORT $LN79@coff_write
	mov	DWORD PTR tv357[rsp], 1
	jmp	SHORT $LN80@coff_write
$LN79@coff_write:
	mov	DWORD PTR tv357[rsp], 0
$LN80@coff_write:
	movzx	eax, BYTE PTR tv357[rsp]
	mov	BYTE PTR is$[rsp+17], al

; 554  : 
; 555  :         if ( len <= IMAGE_SIZEOF_SHORT_NAME )

	cmp	DWORD PTR len$[rsp], 8
	ja	SHORT $LN39@coff_write

; 556  :             strncpy( is.N.ShortName, buffer, IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_strncpy
	jmp	SHORT $LN40@coff_write
$LN39@coff_write:

; 557  :         else {
; 558  :             is.N.Name.Short = 0;

	mov	DWORD PTR is$[rsp], 0

; 559  :             is.N.Name.Long = Coff_AllocString( cm, buffer, len );

	mov	r8d, DWORD PTR len$[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR cm$[rsp]
	call	Coff_AllocString
	mov	DWORD PTR is$[rsp+4], eax
$LN40@coff_write:

; 560  :         }
; 561  :         if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN41@coff_write

; 562  :             WriteError();

	call	WriteError
$LN41@coff_write:

; 563  :         cntSymbols++;

	mov	eax, DWORD PTR cntSymbols$[rsp]
	inc	eax
	mov	DWORD PTR cntSymbols$[rsp], eax

; 564  : 
; 565  :         /* for weak externals, write the auxiliary record */
; 566  :         if ( curr->sym.iscomm == FALSE && curr->sym.altname ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	$LN42@coff_write
	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+64], 0
	je	SHORT $LN42@coff_write

; 567  :             memset( &ias, 0, sizeof(ias) );

	mov	r8d, 18
	xor	edx, edx
	lea	rcx, QWORD PTR ias$[rsp]
	call	memset

; 568  :             ias.Sym.TagIndex = curr->sym.altname->ext_idx;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	eax, DWORD PTR [rax+88]
	mov	DWORD PTR ias$[rsp], eax

; 569  :             /* v2.10: weak externals defined via "extern sym (altsym) ..."
; 570  :              * are to have characteristics IMAGE_WEAK_EXTERN_SEARCH_LIBRARY.
; 571  :              */
; 572  :             //ias.Sym.Misc.TotalSize = IMAGE_WEAK_EXTERN_SEARCH_ALIAS;
; 573  :             ias.Sym.Misc.TotalSize = IMAGE_WEAK_EXTERN_SEARCH_LIBRARY;

	mov	DWORD PTR ias$[rsp+4], 2

; 574  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR ias$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN43@coff_write

; 575  :                 WriteError();

	call	WriteError
$LN43@coff_write:

; 576  :             cntSymbols++;

	mov	eax, DWORD PTR cntSymbols$[rsp]
	inc	eax
	mov	DWORD PTR cntSymbols$[rsp], eax
$LN42@coff_write:

; 577  :         }
; 578  :     }

	jmp	$LN8@coff_write
$LN9@coff_write:

; 579  : 
; 580  :     /* publics and internal symbols. The internal symbols have
; 581  :      * been written to the "public" queue inside coff_write_data().
; 582  :      */
; 583  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo+16
	mov	QWORD PTR q$[rsp], rax
	jmp	SHORT $LN13@coff_write
$LN11@coff_write:
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$[rsp], rax
$LN13@coff_write:
	cmp	QWORD PTR q$[rsp], 0
	je	$LN12@coff_write

; 584  :         sym = q->sym;

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR sym$[rsp], rax

; 585  :         len = Mangle( sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	Mangle
	mov	DWORD PTR len$[rsp], eax

; 586  : #ifdef DEBUG_OUT
; 587  :         if ( sym->state == SYM_INTERNAL && sym->isproc == TRUE && Options.line_numbers )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN44@coff_write
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN44@coff_write
	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	SHORT $LN44@coff_write

; 588  :             DebugMsg(("coff_write_symbols(%u): %s, file=%u\n", cntSymbols, sym->name, sym->debuginfo->file ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	movzx	eax, WORD PTR [rax+14]
	mov	r9d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR cntSymbols$[rsp]
	lea	rcx, OFFSET FLAT:$SG11676
	call	DoDebugMsg
$LN44@coff_write:

; 589  : #endif
; 590  :         if ( Options.line_numbers &&
; 591  :             sym->isproc &&

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	$LN45@coff_write
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN45@coff_write
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	movzx	eax, WORD PTR [rax+14]
	cmp	eax, DWORD PTR lastfile$[rsp]
	je	$LN45@coff_write

; 592  :             sym->debuginfo->file != lastfile ) {
; 593  :             lastfile = sym->debuginfo->file;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	movzx	eax, WORD PTR [rax+14]
	mov	DWORD PTR lastfile$[rsp], eax

; 594  :             strncpy( is.N.ShortName, ".file", IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG11678
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_strncpy

; 595  :             is.SectionNumber = (uint_16)IMAGE_SYM_DEBUG;

	mov	eax, 65534				; 0000fffeH
	mov	WORD PTR is$[rsp+12], ax

; 596  :             is.Type = IMAGE_SYM_TYPE_NULL;

	xor	eax, eax
	mov	WORD PTR is$[rsp+14], ax

; 597  :             is.StorageClass = IMAGE_SYM_CLASS_FILE;

	mov	BYTE PTR is$[rsp+16], 103		; 00000067H

; 598  :             is.NumberOfAuxSymbols = GetFileAuxEntries( sym->debuginfo->file, &p );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	lea	rdx, QWORD PTR p$[rsp]
	movzx	ecx, WORD PTR [rax+14]
	call	GetFileAuxEntries
	mov	BYTE PTR is$[rsp+17], al

; 599  :             is.Value = sym->debuginfo->next_file;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	eax, DWORD PTR [rax+20]
	mov	DWORD PTR is$[rsp+8], eax

; 600  :             if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN46@coff_write

; 601  :                 WriteError();

	call	WriteError
$LN46@coff_write:

; 602  : 
; 603  :             for ( i = is.NumberOfAuxSymbols; i; i--, p += sizeof(IMAGE_AUX_SYMBOL) ) {

	movzx	eax, BYTE PTR is$[rsp+17]
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN16@coff_write
$LN14@coff_write:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR p$[rsp]
	add	rax, 18
	mov	QWORD PTR p$[rsp], rax
$LN16@coff_write:
	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN15@coff_write

; 604  :                 strncpy( ias.File.Name, p, sizeof(IMAGE_AUX_SYMBOL) );

	mov	r8d, 18
	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, QWORD PTR ias$[rsp]
	call	QWORD PTR __imp_strncpy

; 605  :                 if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR ias$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN47@coff_write

; 606  :                     WriteError();

	call	WriteError
$LN47@coff_write:

; 607  :             }

	jmp	SHORT $LN14@coff_write
$LN15@coff_write:

; 608  :             cntSymbols += is.NumberOfAuxSymbols + 1;

	movzx	eax, BYTE PTR is$[rsp+17]
	mov	ecx, DWORD PTR cntSymbols$[rsp]
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	DWORD PTR cntSymbols$[rsp], eax
$LN45@coff_write:

; 609  :         }
; 610  :         is.Type = CoffGetType( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	CoffGetType
	mov	WORD PTR is$[rsp+14], ax

; 611  :         is.StorageClass = CoffGetClass( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	CoffGetClass
	mov	BYTE PTR is$[rsp+16], al

; 612  :         is.Value = sym->offset;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR is$[rsp+8], eax

; 613  : #if 1 /* v2.07: changed - to make MT_ABS obsolete */
; 614  :         if ( sym->state == SYM_INTERNAL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN48@coff_write

; 615  :             if ( sym->segment )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN50@coff_write

; 616  :                 is.SectionNumber = GetSegIdx( sym->segment );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	GetSegIdx
	mov	WORD PTR is$[rsp+12], ax
	jmp	SHORT $LN51@coff_write
$LN50@coff_write:

; 617  :             else
; 618  :                 is.SectionNumber = (uint_16)IMAGE_SYM_ABSOLUTE;

	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR is$[rsp+12], ax
$LN51@coff_write:

; 619  :         } else

	jmp	SHORT $LN49@coff_write
$LN48@coff_write:

; 620  :             is.SectionNumber = IMAGE_SYM_UNDEFINED;

	xor	eax, eax
	mov	WORD PTR is$[rsp+12], ax
$LN49@coff_write:

; 621  : #else
; 622  :         if ( sym->state == SYM_EXTERNAL )
; 623  :             is.SectionNumber = IMAGE_SYM_UNDEFINED;
; 624  :         else if ( sym->mem_type == MT_ABS )
; 625  :             is.SectionNumber = IMAGE_SYM_ABSOLUTE;
; 626  :         else if ( sym->segment )
; 627  :             is.SectionNumber = GetSegIdx( sym->segment );
; 628  :         else
; 629  :             is.SectionNumber = IMAGE_SYM_UNDEFINED;
; 630  : #endif
; 631  :         is.NumberOfAuxSymbols = 0;

	mov	BYTE PTR is$[rsp+17], 0

; 632  :         if ( Options.line_numbers && sym->isproc )

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	SHORT $LN52@coff_write
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN52@coff_write

; 633  :             is.NumberOfAuxSymbols++;

	movzx	eax, BYTE PTR is$[rsp+17]
	inc	al
	mov	BYTE PTR is$[rsp+17], al
$LN52@coff_write:

; 634  : 
; 635  :         if ( len <= IMAGE_SIZEOF_SHORT_NAME )

	cmp	DWORD PTR len$[rsp], 8
	ja	SHORT $LN53@coff_write

; 636  :             strncpy( is.N.ShortName, buffer, IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_strncpy
	jmp	SHORT $LN54@coff_write
$LN53@coff_write:

; 637  :         else {
; 638  :             is.N.Name.Short = 0;

	mov	DWORD PTR is$[rsp], 0

; 639  :             is.N.Name.Long = Coff_AllocString( cm, buffer, len );

	mov	r8d, DWORD PTR len$[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR cm$[rsp]
	call	Coff_AllocString
	mov	DWORD PTR is$[rsp+4], eax
$LN54@coff_write:

; 640  :         }
; 641  : 
; 642  :         DebugMsg(("coff_write_symbols(%u, PUB+INT): %s, ofs=%X, type=%X, stgcls=%X\n", cntSymbols, buffer, is.Value, is.Type, is.StorageClass ));

	movzx	eax, BYTE PTR is$[rsp+16]
	movzx	ecx, WORD PTR is$[rsp+14]
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR is$[rsp+8]
	lea	r8, QWORD PTR buffer$[rsp]
	mov	edx, DWORD PTR cntSymbols$[rsp]
	lea	rcx, OFFSET FLAT:$SG11688
	call	DoDebugMsg

; 643  : 
; 644  :         if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN55@coff_write

; 645  :             WriteError();

	call	WriteError
$LN55@coff_write:

; 646  :         cntSymbols++;

	mov	eax, DWORD PTR cntSymbols$[rsp]
	inc	eax
	mov	DWORD PTR cntSymbols$[rsp], eax

; 647  :         if ( Options.line_numbers && sym->isproc ) {

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	$LN56@coff_write
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN56@coff_write

; 648  :             /* write:
; 649  :              * 1.   the aux for the proc
; 650  :              * 2+3. a .bf record with 1 aux
; 651  :              * 4.   a .lf record with 0 aux
; 652  :              * 5+6. a .ef record with 1 aux
; 653  :              */
; 654  :             ias.Sym.TagIndex = cntSymbols+1;

	mov	eax, DWORD PTR cntSymbols$[rsp]
	inc	eax
	mov	DWORD PTR ias$[rsp], eax

; 655  :             ias.Sym.Misc.TotalSize = sym->total_size;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR ias$[rsp+4], eax

; 656  :             ias.Sym.FcnAry.Function.PointerToLinenumber = sym->debuginfo->ln_fileofs;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR ias$[rsp+8], eax

; 657  :             ias.Sym.FcnAry.Function.PointerToNextFunction = sym->debuginfo->next_proc;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR ias$[rsp+12], eax

; 658  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR ias$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN57@coff_write

; 659  :                 WriteError();

	call	WriteError
$LN57@coff_write:

; 660  : 
; 661  :             strncpy( is.N.ShortName, ".bf", IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG11692
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_strncpy

; 662  :             is.Type = IMAGE_SYM_TYPE_NULL;

	xor	eax, eax
	mov	WORD PTR is$[rsp+14], ax

; 663  :             is.NumberOfAuxSymbols = 1;

	mov	BYTE PTR is$[rsp+17], 1

; 664  :             is.StorageClass = IMAGE_SYM_CLASS_FUNCTION;

	mov	BYTE PTR is$[rsp+16], 101		; 00000065H

; 665  :             if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN58@coff_write

; 666  :                 WriteError();

	call	WriteError
$LN58@coff_write:

; 667  :             ias.Sym.TagIndex = 0;

	mov	DWORD PTR ias$[rsp], 0

; 668  :             ias.Sym.Misc.LnSz.Linenumber = sym->debuginfo->start_line;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR ias$[rsp+4], ax

; 669  :             if ( sym->debuginfo->next_proc )

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	cmp	DWORD PTR [rax+16], 0
	je	SHORT $LN59@coff_write

; 670  :                 ias.Sym.FcnAry.Function.PointerToNextFunction = sym->debuginfo->next_proc + 2;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	eax, DWORD PTR [rax+16]
	add	eax, 2
	mov	DWORD PTR ias$[rsp+12], eax
	jmp	SHORT $LN60@coff_write
$LN59@coff_write:

; 671  :             else
; 672  :                 ias.Sym.FcnAry.Function.PointerToNextFunction = 0;

	mov	DWORD PTR ias$[rsp+12], 0
$LN60@coff_write:

; 673  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR ias$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN61@coff_write

; 674  :                 WriteError();

	call	WriteError
$LN61@coff_write:

; 675  : 
; 676  :             strncpy( is.N.ShortName, ".lf", IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG11697
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_strncpy

; 677  :             is.Type = IMAGE_SYM_TYPE_NULL;

	xor	eax, eax
	mov	WORD PTR is$[rsp+14], ax

; 678  :             is.NumberOfAuxSymbols = 0;

	mov	BYTE PTR is$[rsp+17], 0

; 679  :             is.StorageClass = IMAGE_SYM_CLASS_FUNCTION;

	mov	BYTE PTR is$[rsp+16], 101		; 00000065H

; 680  :             is.Value = sym->debuginfo->line_numbers;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	movzx	eax, WORD PTR [rax+12]
	mov	DWORD PTR is$[rsp+8], eax

; 681  :             if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN62@coff_write

; 682  :                 WriteError();

	call	WriteError
$LN62@coff_write:

; 683  : 
; 684  :             strncpy( is.N.ShortName, ".ef", IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG11699
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_strncpy

; 685  :             is.Type = IMAGE_SYM_TYPE_NULL;

	xor	eax, eax
	mov	WORD PTR is$[rsp+14], ax

; 686  :             is.NumberOfAuxSymbols = 1;

	mov	BYTE PTR is$[rsp+17], 1

; 687  :             is.StorageClass = IMAGE_SYM_CLASS_FUNCTION;

	mov	BYTE PTR is$[rsp+16], 101		; 00000065H

; 688  :             is.Value = sym->offset + sym->total_size;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR sym$[rsp]
	add	eax, DWORD PTR [rcx+56]
	mov	DWORD PTR is$[rsp+8], eax

; 689  :             if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN63@coff_write

; 690  :                 WriteError();

	call	WriteError
$LN63@coff_write:

; 691  :             ias.Sym.TagIndex = 0;

	mov	DWORD PTR ias$[rsp], 0

; 692  :             ias.Sym.Misc.LnSz.Linenumber = sym->debuginfo->end_line;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	movzx	eax, WORD PTR [rax+4]
	mov	WORD PTR ias$[rsp+4], ax

; 693  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR ias$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN64@coff_write

; 694  :                 WriteError();

	call	WriteError
$LN64@coff_write:

; 695  : 
; 696  :             cntSymbols += 6;

	mov	eax, DWORD PTR cntSymbols$[rsp]
	add	eax, 6
	mov	DWORD PTR cntSymbols$[rsp], eax
$LN56@coff_write:

; 697  :         }
; 698  :     }

	jmp	$LN11@coff_write
$LN12@coff_write:

; 699  : 
; 700  :     /* aliases. A weak external entry with 1 aux entry is created.
; 701  :      */
; 702  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 5
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN19@coff_write
$LN17@coff_write:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN19@coff_write:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN18@coff_write

; 703  :         struct asym * sym;
; 704  : 
; 705  :         len = Mangle( &curr->sym, buffer );

	mov	rax, QWORD PTR curr$[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rax
	call	Mangle
	mov	DWORD PTR len$[rsp], eax

; 706  : 
; 707  :         if ( len <= IMAGE_SIZEOF_SHORT_NAME )

	cmp	DWORD PTR len$[rsp], 8
	ja	SHORT $LN65@coff_write

; 708  :             strncpy( is.N.ShortName, buffer, IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_strncpy
	jmp	SHORT $LN66@coff_write
$LN65@coff_write:

; 709  :         else {
; 710  :             is.N.Name.Short = 0;

	mov	DWORD PTR is$[rsp], 0

; 711  :             is.N.Name.Long = Coff_AllocString( cm, buffer, len );

	mov	r8d, DWORD PTR len$[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR cm$[rsp]
	call	Coff_AllocString
	mov	DWORD PTR is$[rsp+4], eax
$LN66@coff_write:

; 712  :         }
; 713  : 
; 714  :         is.Value = 0;

	mov	DWORD PTR is$[rsp+8], 0

; 715  :         is.SectionNumber = IMAGE_SYM_UNDEFINED;

	xor	eax, eax
	mov	WORD PTR is$[rsp+12], ax

; 716  :         is.Type = IMAGE_SYM_TYPE_NULL;

	xor	eax, eax
	mov	WORD PTR is$[rsp+14], ax

; 717  :         is.StorageClass = IMAGE_SYM_CLASS_WEAK_EXTERNAL;

	mov	BYTE PTR is$[rsp+16], 105		; 00000069H

; 718  :         is.NumberOfAuxSymbols = 1;

	mov	BYTE PTR is$[rsp+17], 1

; 719  : 
; 720  :         DebugMsg(("coff_write_symbols(%u, ALIAS): symbol %s, ofs=%X\n", cntSymbols, buffer, is.Value ));

	mov	r9d, DWORD PTR is$[rsp+8]
	lea	r8, QWORD PTR buffer$[rsp]
	mov	edx, DWORD PTR cntSymbols$[rsp]
	lea	rcx, OFFSET FLAT:$SG11704
	call	DoDebugMsg

; 721  : 
; 722  :         if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN67@coff_write

; 723  :             WriteError();

	call	WriteError
$LN67@coff_write:

; 724  :         cntSymbols++;

	mov	eax, DWORD PTR cntSymbols$[rsp]
	inc	eax
	mov	DWORD PTR cntSymbols$[rsp], eax

; 725  : 
; 726  :         memset( &ias, 0, sizeof(ias) );

	mov	r8d, 18
	xor	edx, edx
	lea	rcx, QWORD PTR ias$[rsp]
	call	memset

; 727  : 
; 728  :         /* v2.04b: adjusted to new field <substitute> */
; 729  :         //sym = SymSearch( curr->sym.string_ptr );
; 730  :         sym = curr->sym.substitute;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR sym$7[rsp], rax

; 731  :         if (sym)

	cmp	QWORD PTR sym$7[rsp], 0
	je	SHORT $LN68@coff_write

; 732  :             ias.Sym.TagIndex = sym->ext_idx;

	mov	rax, QWORD PTR sym$7[rsp]
	mov	eax, DWORD PTR [rax+88]
	mov	DWORD PTR ias$[rsp], eax
$LN68@coff_write:

; 733  : 
; 734  :         ias.Sym.Misc.TotalSize = IMAGE_WEAK_EXTERN_SEARCH_ALIAS;

	mov	DWORD PTR ias$[rsp+4], 3

; 735  :         if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 18
	mov	edx, 1
	lea	rcx, QWORD PTR ias$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 18
	je	SHORT $LN69@coff_write

; 736  :             WriteError();

	call	WriteError
$LN69@coff_write:

; 737  :         cntSymbols++;

	mov	eax, DWORD PTR cntSymbols$[rsp]
	inc	eax
	mov	DWORD PTR cntSymbols$[rsp], eax

; 738  : 
; 739  :     }

	jmp	$LN17@coff_write
$LN18@coff_write:

; 740  : 
; 741  :     DebugMsg(("coff_write_symbols: exit cntSymbols=%u\n", cntSymbols ));

	mov	edx, DWORD PTR cntSymbols$[rsp]
	lea	rcx, OFFSET FLAT:$SG11708
	call	DoDebugMsg

; 742  :     return( cntSymbols );

	mov	eax, DWORD PTR cntSymbols$[rsp]

; 743  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:coff_write_symbols$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 544				; 00000220H
	pop	rdi
	ret	0
coff_write_symbols ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
byt$ = 32
lpBuffer$ = 64
dwBufLen$ = 72
dwCRC$ = 80
CRC32Comdat PROC

; 388  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 389  :     static bool init = FALSE;
; 390  :     uint_8 byt;
; 391  : 
; 392  :     if ( !init ) {

	movzx	eax, BYTE PTR ?init@?1??CRC32Comdat@@9@9
	test	eax, eax
	jne	SHORT $LN5@CRC32Comda

; 393  :         init = TRUE;

	mov	BYTE PTR ?init@?1??CRC32Comdat@@9@9, 1

; 394  :         InitCRC32();

	call	InitCRC32
$LN5@CRC32Comda:

; 395  :     }
; 396  :     if ( lpBuffer ) /* v2.11: lpBuffer may be NULL ( uninitialized data segs ) */

	cmp	QWORD PTR lpBuffer$[rsp], 0
	je	SHORT $LN6@CRC32Comda

; 397  :         for ( ; dwBufLen; dwBufLen-- ) {

	jmp	SHORT $LN4@CRC32Comda
$LN2@CRC32Comda:
	mov	eax, DWORD PTR dwBufLen$[rsp]
	dec	eax
	mov	DWORD PTR dwBufLen$[rsp], eax
$LN4@CRC32Comda:
	cmp	DWORD PTR dwBufLen$[rsp], 0
	je	SHORT $LN3@CRC32Comda

; 398  :             byt = *lpBuffer++;

	mov	rax, QWORD PTR lpBuffer$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR byt$[rsp], al
	mov	rax, QWORD PTR lpBuffer$[rsp]
	inc	rax
	mov	QWORD PTR lpBuffer$[rsp], rax

; 399  :             byt = byt ^ (uint_8)dwCRC;

	movzx	eax, BYTE PTR byt$[rsp]
	movzx	ecx, BYTE PTR dwCRC$[rsp]
	xor	eax, ecx
	mov	BYTE PTR byt$[rsp], al

; 400  :             dwCRC = dwCRC >> 8;

	mov	eax, DWORD PTR dwCRC$[rsp]
	shr	eax, 8
	mov	DWORD PTR dwCRC$[rsp], eax

; 401  :             dwCRC = dwCRC ^ CRC32Table[byt];

	movzx	eax, BYTE PTR byt$[rsp]
	lea	rcx, OFFSET FLAT:CRC32Table
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	ecx, DWORD PTR dwCRC$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR dwCRC$[rsp], eax

; 402  :         }

	jmp	SHORT $LN2@CRC32Comda
$LN3@CRC32Comda:
$LN6@CRC32Comda:

; 403  :     return( dwCRC );

	mov	eax, DWORD PTR dwCRC$[rsp]

; 404  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
CRC32Comdat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
i$ = 0
j$ = 4
crc$ = 8
InitCRC32 PROC

; 375  : {

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 376  :     int i,j;
; 377  :     uint_32 crc;
; 378  :     for ( i = 0; i < 256; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@InitCRC32
$LN2@InitCRC32:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@InitCRC32:
	cmp	DWORD PTR i$[rsp], 256			; 00000100H
	jge	SHORT $LN3@InitCRC32

; 379  :         for ( j = 0, crc = i; j < 8; j++ ) {

	mov	DWORD PTR j$[rsp], 0
	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR crc$[rsp], eax
	jmp	SHORT $LN7@InitCRC32
$LN5@InitCRC32:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN7@InitCRC32:
	cmp	DWORD PTR j$[rsp], 8
	jge	SHORT $LN6@InitCRC32

; 380  :             crc = ( crc >> 1 ) ^ (0xEDB88320 * ( crc & 1 ) );

	mov	eax, DWORD PTR crc$[rsp]
	shr	eax, 1
	mov	ecx, DWORD PTR crc$[rsp]
	and	ecx, 1
	imul	ecx, ecx, -306674912			; edb88320H
	xor	eax, ecx
	mov	DWORD PTR crc$[rsp], eax

; 381  :         }

	jmp	SHORT $LN5@InitCRC32
$LN6@InitCRC32:

; 382  :         CRC32Table[i] = crc;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:CRC32Table
	mov	edx, DWORD PTR crc$[rsp]
	mov	DWORD PTR [rcx+rax*4], edx

; 383  :     }

	jmp	SHORT $LN2@InitCRC32
$LN3@InitCRC32:

; 384  : }

	add	rsp, 16
	pop	rdi
	ret	0
InitCRC32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
curr$ = 32
len$ = 40
tv77 = 44
tv83 = 48
file$ = 80
fname$ = 88
GetFileAuxEntries PROC

; 356  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	WORD PTR [rsp+8], cx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, WORD PTR [rsp+80]

; 357  :     const struct fname_item *curr;
; 358  :     unsigned len;
; 359  :     curr = GetFName( file );

	movzx	eax, WORD PTR file$[rsp]
	mov	ecx, eax
	call	GetFName
	mov	QWORD PTR curr$[rsp], rax

; 360  :     if ( fname )

	cmp	QWORD PTR fname$[rsp], 0
	je	SHORT $LN2@GetFileAux

; 361  :         *fname = curr->fname;

	mov	rax, QWORD PTR fname$[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
$LN2@GetFileAux:

; 362  :     len = strlen( curr->fname );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 363  :     /**/myassert( len ); /* name length must be > 0 */

	cmp	DWORD PTR len$[rsp], 0
	je	SHORT $LN4@GetFileAux
	mov	DWORD PTR tv77[rsp], 0
	jmp	SHORT $LN5@GetFileAux
$LN4@GetFileAux:
	mov	edx, 363				; 0000016bH
	lea	rcx, OFFSET FLAT:$SG11563
	call	InternalError
	mov	DWORD PTR tv77[rsp], eax
$LN5@GetFileAux:

; 364  :     return ( len / sizeof( IMAGE_AUX_SYMBOL ) + ( len % sizeof( IMAGE_AUX_SYMBOL ) ? 1 : 0 ) );

	mov	eax, DWORD PTR len$[rsp]
	xor	edx, edx
	mov	ecx, 18
	div	rcx
	mov	rax, rdx
	test	rax, rax
	je	SHORT $LN6@GetFileAux
	mov	DWORD PTR tv83[rsp], 1
	jmp	SHORT $LN7@GetFileAux
$LN6@GetFileAux:
	mov	DWORD PTR tv83[rsp], 0
$LN7@GetFileAux:
	mov	eax, DWORD PTR len$[rsp]
	xor	edx, edx
	mov	ecx, 18
	div	rcx
	movsxd	rcx, DWORD PTR tv83[rsp]
	add	rax, rcx

; 365  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
GetFileAuxEntries ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
sym$ = 16
CoffGetClass PROC

; 332  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 333  :     if ( sym->state == SYM_EXTERNAL )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN2@CoffGetCla

; 334  :         if ( sym->iscomm == FALSE && sym->altname )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@CoffGetCla
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+64], 0
	je	SHORT $LN4@CoffGetCla

; 335  :             return( IMAGE_SYM_CLASS_WEAK_EXTERNAL );

	mov	eax, 105				; 00000069H
	jmp	SHORT $LN1@CoffGetCla
	jmp	SHORT $LN5@CoffGetCla
$LN4@CoffGetCla:

; 336  :         else
; 337  :             return( IMAGE_SYM_CLASS_EXTERNAL );

	mov	eax, 2
	jmp	SHORT $LN1@CoffGetCla
$LN5@CoffGetCla:
	jmp	SHORT $LN3@CoffGetCla
$LN2@CoffGetCla:

; 338  :     else if ( sym->ispublic == TRUE )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN6@CoffGetCla

; 339  :         return( IMAGE_SYM_CLASS_EXTERNAL );

	mov	eax, 2
	jmp	SHORT $LN1@CoffGetCla
	jmp	SHORT $LN7@CoffGetCla
$LN6@CoffGetCla:

; 340  : #if HELPSYMS
; 341  :     else if ( sym->variable == TRUE ) /* assembly time variable in fixup */
; 342  :         return( IMAGE_SYM_CLASS_LABEL );
; 343  : #endif
; 344  :     /* v2.09: don't declare private procs as label */
; 345  :     //else if ( sym->mem_type == MT_NEAR )/* added v2.0 */
; 346  :     else if ( sym->mem_type == MT_NEAR && sym->isproc == FALSE )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 129			; 00000081H
	jne	SHORT $LN8@CoffGetCla
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@CoffGetCla

; 347  :         return( IMAGE_SYM_CLASS_LABEL );

	mov	eax, 6
	jmp	SHORT $LN1@CoffGetCla
$LN8@CoffGetCla:
$LN7@CoffGetCla:
$LN3@CoffGetCla:

; 348  : 
; 349  :     return( IMAGE_SYM_CLASS_STATIC );

	mov	eax, 3
$LN1@CoffGetCla:

; 350  : }

	pop	rdi
	ret	0
CoffGetClass ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
sym$ = 16
CoffGetType PROC

; 307  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 308  :     if ( sym->isproc )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@CoffGetTyp

; 309  :         return( 0x20 );

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN1@CoffGetTyp
$LN2@CoffGetTyp:

; 310  : 
; 311  : #if 0
; 312  :     switch (sym->mem_type) {
; 313  :     case MT_BYTE:
; 314  :     case MT_SBYTE:
; 315  :         return( IMAGE_SYM_TYPE_BYTE );
; 316  :     case MT_WORD:
; 317  :     case MT_SWORD:
; 318  :         return( IMAGE_SYM_TYPE_WORD );
; 319  :     case MT_DWORD:
; 320  :     case MT_SDWORD:
; 321  :         return( IMAGE_SYM_TYPE_DWORD );
; 322  :     }
; 323  : #endif
; 324  :     return( IMAGE_SYM_TYPE_NULL );

	xor	eax, eax
$LN1@CoffGetTyp:

; 325  : }

	pop	rdi
	ret	0
CoffGetType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
curr$ = 48
fix$ = 56
fileoffset$ = 64
len$ = 68
secname$ = 72
segtype$ = 84
ish$ = 120
buffer$ = 192
cp$6 = 456
src$7 = 464
tv88 = 480
tv137 = 488
__$ArrayPad$ = 496
modinfo$ = 528
cm$ = 536
coff_write_section_table PROC

; 148  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 512				; 00000200H
	mov	rdi, rsp
	mov	ecx, 128				; 00000080H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+528]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 149  :     struct dsym  *curr;
; 150  :     struct fixup *fix;
; 151  :     uint_32      fileoffset; /* calculated file offset for section data, relocs and linenumber info */
; 152  :     unsigned     len;
; 153  :     char         *secname;
; 154  :     //struct omf_rec  *objr;
; 155  :     //char        *p;
; 156  :     //uint        size_relocs = 0;
; 157  :     enum seg_type segtype;
; 158  :     struct IMAGE_SECTION_HEADER ish;
; 159  :     char buffer[MAX_ID_LEN+1];
; 160  : 
; 161  :     DebugMsg(("coff_write_section_table: enter, sections=%u\n", modinfo->g.num_segs ));

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	edx, DWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11501
	call	DoDebugMsg

; 162  : 
; 163  :     fileoffset = sizeof( struct IMAGE_FILE_HEADER ) + modinfo->g.num_segs * sizeof( struct IMAGE_SECTION_HEADER );

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	eax, DWORD PTR [rax+8]
	imul	rax, rax, 40				; 00000028H
	add	rax, 20
	mov	DWORD PTR fileoffset$[rsp], eax

; 164  :     cm->start_data = fileoffset;

	mov	rax, QWORD PTR cm$[rsp]
	mov	ecx, DWORD PTR fileoffset$[rsp]
	mov	DWORD PTR [rax+32], ecx

; 165  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@coff_write
$LN2@coff_write:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@coff_write:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN3@coff_write

; 166  : 
; 167  :         /* v2.04: can't happen */
; 168  :         //if( curr->sym.state != SYM_SEG ) {
; 169  :         //    EmitErr( SEGMENT_NOT_DEFINED, curr->sym.name );
; 170  :         //    continue;
; 171  :         //}
; 172  :         segtype = SEGTYPE_UNDEF;

	mov	DWORD PTR segtype$[rsp], 0

; 173  :         /* v2.07: prefer ALIAS name if defined. */
; 174  :         secname = ( curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ConvertSectionName( &curr->sym, &segtype, buffer ) );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN37@coff_write
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR tv88[rsp], rax
	jmp	SHORT $LN38@coff_write
$LN37@coff_write:
	mov	rax, QWORD PTR curr$[rsp]
	lea	r8, QWORD PTR buffer$[rsp]
	lea	rdx, QWORD PTR segtype$[rsp]
	mov	rcx, rax
	call	ConvertSectionName
	mov	QWORD PTR tv88[rsp], rax
$LN38@coff_write:
	mov	rax, QWORD PTR tv88[rsp]
	mov	QWORD PTR secname$[rsp], rax

; 175  :         len = strlen( secname );

	mov	rcx, QWORD PTR secname$[rsp]
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 176  :         /* if section name is longer than 8 chars, a '/' is stored,
; 177  :          followed by a number in ascii which is the offset for the string table
; 178  :          */
; 179  :         if ( len <= IMAGE_SIZEOF_SHORT_NAME )

	cmp	DWORD PTR len$[rsp], 8
	ja	SHORT $LN8@coff_write

; 180  :             strncpy( ish.Name, secname, IMAGE_SIZEOF_SHORT_NAME );

	mov	r8d, 8
	mov	rdx, QWORD PTR secname$[rsp]
	lea	rcx, QWORD PTR ish$[rsp]
	call	QWORD PTR __imp_strncpy
	jmp	SHORT $LN9@coff_write
$LN8@coff_write:

; 181  :         else
; 182  :             sprintf( ish.Name, "/%u", Coff_AllocString( cm, secname, len ) );

	mov	r8d, DWORD PTR len$[rsp]
	mov	rdx, QWORD PTR secname$[rsp]
	mov	rcx, QWORD PTR cm$[rsp]
	call	Coff_AllocString
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG11504
	lea	rcx, QWORD PTR ish$[rsp]
	call	sprintf
$LN9@coff_write:

; 183  : 
; 184  :         /* v2.04: what is the old line supposed to do? */
; 185  :         //ish.Misc.PhysicalAddress = fileoffset - (size_relocs + sizeof(struct IMAGE_FILE_HEADER) + ModuleInfo->g.num_segs * sizeof(struct IMAGE_SECTION_HEADER));
; 186  :         ish.Misc.PhysicalAddress = 0;

	mov	DWORD PTR ish$[rsp+8], 0

; 187  :         ish.VirtualAddress = 0;

	mov	DWORD PTR ish$[rsp+12], 0

; 188  :         ish.SizeOfRawData = curr->sym.max_offset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR ish$[rsp+16], eax

; 189  :         ish.PointerToRawData = ( ish.SizeOfRawData ? fileoffset : 0 );

	cmp	DWORD PTR ish$[rsp+16], 0
	je	SHORT $LN39@coff_write
	mov	eax, DWORD PTR fileoffset$[rsp]
	mov	DWORD PTR tv137[rsp], eax
	jmp	SHORT $LN40@coff_write
$LN39@coff_write:
	mov	DWORD PTR tv137[rsp], 0
$LN40@coff_write:
	mov	eax, DWORD PTR tv137[rsp]
	mov	DWORD PTR ish$[rsp+20], eax

; 190  :         ish.PointerToRelocations = 0;

	mov	DWORD PTR ish$[rsp+24], 0

; 191  :         ish.PointerToLinenumbers = 0;

	mov	DWORD PTR ish$[rsp+28], 0

; 192  :         ish.NumberOfRelocations = 0;

	xor	eax, eax
	mov	WORD PTR ish$[rsp+32], ax

; 193  :         ish.NumberOfLinenumbers = 0;

	xor	eax, eax
	mov	WORD PTR ish$[rsp+34], ax

; 194  :         ish.Characteristics = 0;

	mov	DWORD PTR ish$[rsp+36], 0

; 195  : 
; 196  :         /* set field Characteristics; optionally reset PointerToRawData/SizeOfRawData */
; 197  :         if ( curr->e.seginfo->info ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@coff_write

; 198  :             /* v2.09: set "remove" flag for .drectve section, as it was done in v2.06 and earlier */
; 199  :             if ( curr == cm->directives )

	mov	rax, QWORD PTR cm$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR curr$[rsp], rax
	jne	SHORT $LN12@coff_write

; 200  :                 ish.Characteristics = ( IMAGE_SCN_LNK_INFO | IMAGE_SCN_LNK_REMOVE );

	mov	DWORD PTR ish$[rsp+36], 2560		; 00000a00H
	jmp	SHORT $LN13@coff_write
$LN12@coff_write:

; 201  :             else
; 202  :                 ish.Characteristics = ( IMAGE_SCN_LNK_INFO | IMAGE_SCN_CNT_INITIALIZED_DATA );

	mov	DWORD PTR ish$[rsp+36], 576		; 00000240H
$LN13@coff_write:

; 203  :         } else {

	jmp	$LN11@coff_write
$LN10@coff_write:

; 204  :             if ( curr->e.seginfo->alignment != MAX_SEGALIGNMENT ) /* ABS not possible */

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN14@coff_write

; 205  :                 ish.Characteristics |= (uint_32)(curr->e.seginfo->alignment + 1) << 20;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+106]
	inc	eax
	shl	eax, 20
	mov	ecx, DWORD PTR ish$[rsp+36]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ish$[rsp+36], eax
$LN14@coff_write:

; 206  : #if COMDATSUPP
; 207  :             if ( curr->e.seginfo->comdat_selection )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+108]
	shr	al, 3
	and	al, 7
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@coff_write

; 208  :                 ish.Characteristics |= IMAGE_SCN_LNK_COMDAT;

	mov	eax, DWORD PTR ish$[rsp+36]
	bts	eax, 12
	mov	DWORD PTR ish$[rsp+36], eax
$LN15@coff_write:

; 209  : #endif
; 210  :             if ( curr->e.seginfo->segtype == SEGTYPE_CODE ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 1
	jne	SHORT $LN16@coff_write

; 211  :                 ish.Characteristics |= IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ;

	mov	eax, DWORD PTR ish$[rsp+36]
	or	eax, 1610612768				; 60000020H
	mov	DWORD PTR ish$[rsp+36], eax
	jmp	$LN17@coff_write
$LN16@coff_write:

; 212  :             } else if ( curr->e.seginfo->readonly ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@coff_write

; 213  :                 ish.Characteristics |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;

	mov	eax, DWORD PTR ish$[rsp+36]
	or	eax, 1073741888				; 40000040H
	mov	DWORD PTR ish$[rsp+36], eax
	jmp	$LN19@coff_write
$LN18@coff_write:

; 214  :             } else if ( curr->e.seginfo->clsym && strcmp( curr->e.seginfo->clsym->name, "CONST" ) == 0 ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN20@coff_write
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+80]
	lea	rdx, OFFSET FLAT:$SG11517
	mov	rcx, QWORD PTR [rax+8]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN20@coff_write

; 215  :                 ish.Characteristics |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;

	mov	eax, DWORD PTR ish$[rsp+36]
	or	eax, 1073741888				; 40000040H
	mov	DWORD PTR ish$[rsp+36], eax
	jmp	$LN21@coff_write
$LN20@coff_write:

; 216  :             } else if ( curr->e.seginfo->segtype == SEGTYPE_BSS || segtype == SEGTYPE_BSS ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 3
	je	SHORT $LN24@coff_write
	cmp	DWORD PTR segtype$[rsp], 3
	jne	SHORT $LN22@coff_write
$LN24@coff_write:

; 217  :                 /* v2.12: if segtype is bss, ensure that seginfo->segtype is also bss; else
; 218  :                  * the segment might be written in coff_write_data().
; 219  :                  */
; 220  :                 curr->e.seginfo->segtype = SEGTYPE_BSS;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+72], 3

; 221  :                 ish.Characteristics |= IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	mov	eax, DWORD PTR ish$[rsp+36]
	or	eax, -1073741696			; c0000080H
	mov	DWORD PTR ish$[rsp+36], eax

; 222  :                 /* ish.SizeOfRawData = 0; */
; 223  :                 ish.PointerToRawData = 0;

	mov	DWORD PTR ish$[rsp+20], 0
	jmp	SHORT $LN23@coff_write
$LN22@coff_write:

; 224  :             } else if ( curr->e.seginfo->combine == COMB_STACK && curr->e.seginfo->bytes_written == 0 ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+108]
	and	al, 7
	movzx	eax, al
	cmp	eax, 5
	jne	SHORT $LN25@coff_write
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN25@coff_write

; 225  :                 ish.Characteristics |= IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	mov	eax, DWORD PTR ish$[rsp+36]
	or	eax, -1073741696			; c0000080H
	mov	DWORD PTR ish$[rsp+36], eax

; 226  :                 ish.SizeOfRawData = 0;

	mov	DWORD PTR ish$[rsp+16], 0

; 227  :                 ish.PointerToRawData = 0;

	mov	DWORD PTR ish$[rsp+20], 0

; 228  :             } else

	jmp	SHORT $LN26@coff_write
$LN25@coff_write:

; 229  :                 ish.Characteristics |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	mov	eax, DWORD PTR ish$[rsp+36]
	or	eax, -1073741760			; c0000040H
	mov	DWORD PTR ish$[rsp+36], eax
$LN26@coff_write:
$LN23@coff_write:
$LN21@coff_write:
$LN19@coff_write:
$LN17@coff_write:
$LN11@coff_write:

; 230  :         }
; 231  : 
; 232  :         /* manual characteristics set? */
; 233  :         if ( curr->e.seginfo->characteristics ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+105]
	test	eax, eax
	je	SHORT $LN27@coff_write

; 234  :             ish.Characteristics &= 0x1FFFFFF; /* clear the IMAGE_SCN_MEM flags */

	mov	eax, DWORD PTR ish$[rsp+36]
	and	eax, 33554431				; 01ffffffH
	mov	DWORD PTR ish$[rsp+36], eax

; 235  :             ish.Characteristics |= (uint_32)(curr->e.seginfo->characteristics & 0xFE) << 24;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+105]
	and	eax, 254				; 000000feH
	shl	eax, 24
	mov	ecx, DWORD PTR ish$[rsp+36]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ish$[rsp+36], eax
$LN27@coff_write:

; 236  :             /* the INFO bit (bit 0) needs special handling! */
; 237  :             //if ( curr->e.seginfo->characteristics & 1 )
; 238  :             //    ish.Characteristics |= IMAGE_SCN_LNK_INFO;
; 239  :         }
; 240  : 
; 241  :         if ( ish.PointerToRawData )

	cmp	DWORD PTR ish$[rsp+20], 0
	je	SHORT $LN28@coff_write

; 242  :             fileoffset += ish.SizeOfRawData;

	mov	eax, DWORD PTR ish$[rsp+16]
	mov	ecx, DWORD PTR fileoffset$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR fileoffset$[rsp], eax
$LN28@coff_write:

; 243  : 
; 244  :         /* set fields PointerToRelocations/NumberOfRelocations; update 'fileoffset'.
; 245  :          * v2.10: don't use the 16-bit NumberOfRelocations member to count relocs!
; 246  :          * if the true number of relocs doesn't fit in 16-bits, set the appropriate
; 247  :          * flag in the section header!
; 248  :          */
; 249  :         if ( curr->e.seginfo->FixupList.head ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+40], 0
	je	$LN29@coff_write

; 250  :             for ( fix = curr->e.seginfo->FixupList.head; fix ; fix = fix->nextrlc ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR fix$[rsp], rax
	jmp	SHORT $LN7@coff_write
$LN5@coff_write:
	mov	rax, QWORD PTR fix$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR fix$[rsp], rax
$LN7@coff_write:
	cmp	QWORD PTR fix$[rsp], 0
	je	$LN6@coff_write

; 251  :                 //printf("segment %s, reloc.sym=%s\n", curr->sym.name, fix->sym ? fix->sym : "NULL" );
; 252  :                 if ( fix->sym == NULL ) {

	mov	rax, QWORD PTR fix$[rsp]
	cmp	QWORD PTR [rax+56], 0
	jne	$LN30@coff_write

; 253  : #if AMD64_SUPPORT
; 254  :                     if ( fix->type == FIX_RELOFF32 ) {

	mov	rax, QWORD PTR fix$[rsp]
	cmp	DWORD PTR [rax+24], 3
	jne	SHORT $LN31@coff_write

; 255  :                         uint_32 *cp = (uint_32 *)( curr->e.seginfo->CodeBuffer + (fix->locofs - curr->e.seginfo->start_loc ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR fix$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	edx, DWORD PTR [rdx+20]
	sub	edx, ecx
	mov	ecx, edx
	mov	ecx, ecx
	add	rcx, QWORD PTR [rax+16]
	mov	rax, rcx
	mov	QWORD PTR cp$6[rsp], rax

; 256  :                         uint_32 src = fix->locofs + fix->addbytes;

	mov	rax, QWORD PTR fix$[rsp]
	movzx	eax, BYTE PTR [rax+32]
	mov	rcx, QWORD PTR fix$[rsp]
	add	eax, DWORD PTR [rcx+20]
	mov	DWORD PTR src$7[rsp], eax

; 257  :                         (*cp) -= src;

	mov	rax, QWORD PTR cp$6[rsp]
	mov	ecx, DWORD PTR src$7[rsp]
	mov	eax, DWORD PTR [rax]
	sub	eax, ecx
	mov	rcx, QWORD PTR cp$6[rsp]
	mov	DWORD PTR [rcx], eax
$LN31@coff_write:

; 258  :                     }
; 259  : #endif
; 260  :                     fix->type = FIX_VOID;

	mov	rax, QWORD PTR fix$[rsp]
	mov	DWORD PTR [rax+24], 0

; 261  :                     continue;

	jmp	$LN5@coff_write
$LN30@coff_write:

; 262  :                 }
; 263  :                 curr->e.seginfo->num_relocs++;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+64]
	inc	eax
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+64], eax

; 264  :             }

	jmp	$LN5@coff_write
$LN6@coff_write:

; 265  :             fileoffset = (fileoffset + 1) & ~1;

	mov	eax, DWORD PTR fileoffset$[rsp]
	inc	eax
	and	eax, -2					; fffffffeH
	mov	DWORD PTR fileoffset$[rsp], eax

; 266  :             ish.PointerToRelocations = fileoffset;

	mov	eax, DWORD PTR fileoffset$[rsp]
	mov	DWORD PTR ish$[rsp+24], eax

; 267  :             /* v2.10: handle the "relocs overflow"-case */
; 268  :             fileoffset += curr->e.seginfo->num_relocs * sizeof( IMAGE_RELOCATION );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+64]
	imul	rax, rax, 10
	mov	ecx, DWORD PTR fileoffset$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR fileoffset$[rsp], eax

; 269  :             if ( curr->e.seginfo->num_relocs <= 0xffff ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+64], 65535		; 0000ffffH
	ja	SHORT $LN32@coff_write

; 270  :                 ish.NumberOfRelocations =  (uint_16)curr->e.seginfo->num_relocs;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, WORD PTR [rax+64]
	mov	WORD PTR ish$[rsp+32], ax

; 271  :             } else {

	jmp	SHORT $LN33@coff_write
$LN32@coff_write:

; 272  :                 DebugMsg(( "coff_write_section_table(%s): %" I32_SPEC "u fixups (more than 0xffff!)!\n", curr->sym.name, curr->e.seginfo->num_relocs ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	r8d, DWORD PTR [rax+64]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11530
	call	DoDebugMsg

; 273  :                 ish.NumberOfRelocations =  0xffff;

	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR ish$[rsp+32], ax

; 274  :                 ish.Characteristics |= IMAGE_SCN_LNK_NRELOC_OVFL;

	mov	eax, DWORD PTR ish$[rsp+36]
	bts	eax, 24
	mov	DWORD PTR ish$[rsp+36], eax

; 275  :                 /* add 1 relocation - the true number of relocations is stored in the first relocation item */
; 276  :                 fileoffset += sizeof( IMAGE_RELOCATION );

	mov	eax, DWORD PTR fileoffset$[rsp]
	add	rax, 10
	mov	DWORD PTR fileoffset$[rsp], eax
$LN33@coff_write:
$LN29@coff_write:

; 277  :             }
; 278  :             //printf( "segment %s has %u relocs\n", curr->sym.name, curr->e.seginfo->num_relocs );
; 279  :         }
; 280  : 
; 281  :         /* set fields PointerToLinenumbers/NumberOfLinenumbers; update 'fileoffset' */
; 282  : 
; 283  :         if ( curr->e.seginfo->LinnumQueue ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN34@coff_write

; 284  :             ish.PointerToLinenumbers = fileoffset;

	mov	eax, DWORD PTR fileoffset$[rsp]
	mov	DWORD PTR ish$[rsp+28], eax

; 285  :             ish.NumberOfLinenumbers = GetLinnumItems( curr->e.seginfo->LinnumQueue );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR [rax+56]
	call	GetLinnumItems
	mov	WORD PTR ish$[rsp+34], ax

; 286  :             fileoffset += ish.NumberOfLinenumbers * sizeof( IMAGE_LINENUMBER );

	movzx	eax, WORD PTR ish$[rsp+34]
	imul	rax, rax, 6
	mov	ecx, DWORD PTR fileoffset$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR fileoffset$[rsp], eax
$LN34@coff_write:

; 287  :         }
; 288  : 
; 289  :         DebugMsg(( "coff_write_section_table(%s): name=%.8s Fixups=%u, Linnums=%u\n", curr->sym.name, ish.Name, ish.NumberOfRelocations, ish.NumberOfLinenumbers ));

	movzx	eax, WORD PTR ish$[rsp+34]
	movzx	ecx, WORD PTR ish$[rsp+32]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	lea	r8, QWORD PTR ish$[rsp]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11532
	call	DoDebugMsg

; 290  :         if ( fwrite( &ish, 1, sizeof( ish ), CurrFile[OBJ] ) != sizeof( ish ) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 40					; 00000028H
	mov	edx, 1
	lea	rcx, QWORD PTR ish$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 40					; 00000028H
	je	SHORT $LN35@coff_write

; 291  :             WriteError();

	call	WriteError
$LN35@coff_write:

; 292  :     }

	jmp	$LN2@coff_write
$LN3@coff_write:

; 293  : #ifdef DEBUG_OUT
; 294  :     cm->start_symtab = fileoffset;

	mov	rax, QWORD PTR cm$[rsp]
	mov	ecx, DWORD PTR fileoffset$[rsp]
	mov	DWORD PTR [rax+120], ecx

; 295  : #endif
; 296  :     DebugMsg(("coff_write_section_table: exit\n"));

	lea	rcx, OFFSET FLAT:$SG11534
	call	DoDebugMsg

; 297  :     return( NOT_ERROR );

	xor	eax, eax

; 298  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:coff_write_section_table$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 512				; 00000200H
	pop	rdi
	ret	0
coff_write_section_table ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
i$ = 0
curr$ = 8
q$ = 32
GetLinnumItems PROC

; 136  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 137  :     unsigned i;
; 138  :     struct line_num_info *curr;
; 139  : 
; 140  :     for ( i = 0, curr = q->head; curr; i++, curr = curr->next );

	mov	DWORD PTR i$[rsp], 0
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@GetLinnumI
$LN2@GetLinnumI:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$[rsp], rax
$LN4@GetLinnumI:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@GetLinnumI
	jmp	SHORT $LN2@GetLinnumI
$LN3@GetLinnumI:

; 141  :     return( i );

	mov	eax, DWORD PTR i$[rsp]

; 142  : }

	add	rsp, 16
	pop	rdi
	ret	0
GetLinnumItems ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
name$ = 32
oldsize$ = 40
cm$ = 64
string$ = 72
len$ = 80
Coff_AllocString PROC

; 115  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 116  :     struct stringitem *name;
; 117  :     uint_32 oldsize = cm->LongNames.size;

	mov	rax, QWORD PTR cm$[rsp]
	mov	eax, DWORD PTR [rax+112]
	mov	DWORD PTR oldsize$[rsp], eax

; 118  : 
; 119  :     cm->LongNames.size += len + 1;

	mov	rax, QWORD PTR cm$[rsp]
	mov	eax, DWORD PTR [rax+112]
	mov	ecx, DWORD PTR len$[rsp]
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	rcx, QWORD PTR cm$[rsp]
	mov	DWORD PTR [rcx+112], eax

; 120  :     name = LclAlloc( len + sizeof( struct stringitem ) );

	movsxd	rax, DWORD PTR len$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	LclAlloc
	mov	QWORD PTR name$[rsp], rax

; 121  :     name->next = NULL;

	mov	rax, QWORD PTR name$[rsp]
	mov	QWORD PTR [rax], 0

; 122  :     strcpy( name->string, string );

	mov	rax, QWORD PTR name$[rsp]
	add	rax, 8
	mov	rdx, QWORD PTR string$[rsp]
	mov	rcx, rax
	call	strcpy

; 123  :     if ( cm->LongNames.head ) {

	mov	rax, QWORD PTR cm$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN2@Coff_Alloc

; 124  :         cm->LongNames.tail->next = name;

	mov	rax, QWORD PTR cm$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR name$[rsp]
	mov	QWORD PTR [rax], rcx

; 125  :         cm->LongNames.tail = name;

	mov	rax, QWORD PTR cm$[rsp]
	mov	rcx, QWORD PTR name$[rsp]
	mov	QWORD PTR [rax+104], rcx

; 126  :     } else {

	jmp	SHORT $LN3@Coff_Alloc
$LN2@Coff_Alloc:

; 127  :         cm->LongNames.head = cm->LongNames.tail = name;

	mov	rax, QWORD PTR cm$[rsp]
	mov	rcx, QWORD PTR name$[rsp]
	mov	QWORD PTR [rax+104], rcx
	mov	rax, QWORD PTR cm$[rsp]
	mov	rcx, QWORD PTR name$[rsp]
	mov	QWORD PTR [rax+96], rcx
$LN3@Coff_Alloc:

; 128  :     }
; 129  :     return( oldsize );

	mov	eax, DWORD PTR oldsize$[rsp]

; 130  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
Coff_AllocString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
_TEXT	SEGMENT
modinfo$ = 16
coff_init PROC

; 1496 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 1497 :     modinfo->g.WriteModule = coff_write_module;

	mov	rax, QWORD PTR modinfo$[rsp]
	lea	rcx, OFFSET FLAT:coff_write_module
	mov	QWORD PTR [rax+288], rcx

; 1498 :     return;
; 1499 : }

	pop	rdi
	ret	0
coff_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Buffer$ = 96
_Format$ = 104
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1788 : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:sprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp___stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1391 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
	push	rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	rdi
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 534  :         {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 535  :             return _time64(_Time);

	mov	rcx, QWORD PTR _Time$[rsp]
	call	QWORD PTR __imp__time64

; 536  :         }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
time	ENDP
_TEXT	ENDS
END
