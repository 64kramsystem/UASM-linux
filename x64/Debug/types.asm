; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG11345 DB	01H DUP (?)
$SG11355 DB	01H DUP (?)
$SG11517 DB	01H DUP (?)
$SG11535 DB	01H DUP (?)
$SG11536 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
COMM	CurrStruct:QWORD
_DATA	ENDS
_BSS	SEGMENT
$SG11170 DB	01H DUP (?)
$SG11247 DB	01H DUP (?)
$SG11258 DB	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
szStructure DB	'structure', 00H
	ORG $+2
szRecord DB	'record', 00H
	ORG $+5
szNonUnique DB	'NONUNIQUE', 00H
CONST	ENDS
_DATA	SEGMENT
$SG11270 DB	'EndstructDirective: delete the redefinition of %s', 0aH, 00H
	ORG $+5
$SG11272 DB	'EndstructDirective: new size of restored structure=%u', 0aH
	DB	00H
	ORG $+1
$SG11336 DB	'NULL', 00H
	ORG $+3
$SG11337 DB	'<anonymous>', 00H
$SG11387 DB	'union', 00H
	ORG $+6
$SG11338 DB	'CreateStructField(%s): name=%s, curr ofs=%u, vartype=%s,'
	DB	' size=%u', 0aH, 00H
	ORG $+6
$SG11351 DB	'CreateStructField(%s): initializer=>%s<', 0aH, 00H
	ORG $+7
$SG11352 DB	'CreateStructField(%s): no initializer<', 0aH, 00H
$SG11361 DB	'CreateStructField(%s): align=%u, size=%u, ofs=%u', 0aH, 00H
	ORG $+6
$SG11368 DB	'CreateStructField(%s): max_mbr_size set to %u', 0aH, 00H
	ORG $+1
$SG11388 DB	'struct', 00H
	ORG $+1
$SG11370 DB	'CreateStructField(%s): Masm51 compat on, lookup %s in gl'
	DB	'obal symbol table', 0aH, 00H
	ORG $+5
$SG11389 DB	'UpdateStructSize(%s.%s): %s, curr mbr size=%u curr struc'
	DB	'/union size=%u', 0aH, 00H
$SG11453 DB	'GetQualifiedType: memtype=%X, symtype set by target_type'
	DB	0aH, 00H
	ORG $+6
$SG11462 DB	'GetQualifiedType: invalid type : %s', 0aH, 00H
	ORG $+3
$SG11470 DB	'GetQualifiedType: memtype=%X, symtype set by target_type'
	DB	0aH, 00H
	ORG $+2
$SG11475 DB	'NULL', 00H
	ORG $+7
$SG11505 DB	'TypedefDirective(%d) enter', 0aH, 00H
$SG11160 DB	'NULL', 00H
	ORG $+7
$SG11476 DB	'GetQualifiedType: i=%u, memtype=%Xh, ptr=%u, far=%u, ofs'
	DB	'size=%d, arbtype=%s:%X', 0aH, 00H
$SG11518 DB	'TypedefDirective PROTO, created new unnamed prototype %p'
	DB	0aH, 00H
	ORG $+6
$SG11521 DB	'TypedefDirective PROTO, call ParseProc(sym=%p i=%d, 0)', 0aH
	DB	00H
$SG11523 DB	'TypedefDirective PROTO, ParseProc() returned status ok', 0aH
	DB	00H
$SG11525 DB	'TypedefDirective(%s) ok, mem_type=%Xh, ofssize=%u', 0aH, 00H
	ORG $+5
$SG11543 DB	'TypedefDirective: unexpected token %u, idx=%u', 0aH, 00H
	ORG $+1
$SG11631 DB	'RecordDirective(%s) exit, no error', 0aH, 00H
	ORG $+4
$SG11537 DB	'TypedefDirective: old-new memtype=%X-%X type=%X(%s)-%X(%'
	DB	's) far=%u-%u ind=%u-%u ofss=%d-%d pmt=%X-%X', 0aH, 00H
	ORG $+3
$SG11641 DB	'DeleteType(%s) enter, typekind=%u, memtype=%Xh', 0aH, 00H
$SG11108 DB	'AreStructsEqual: fields don''t match', 0aH, 00H
	ORG $+3
$SG11540 DB	'TypedefDirective(%s) ok, mem_type=MT_TYPE, size=%u, type'
	DB	'=%p type.memtype=%X', 0aH, 00H
	ORG $+3
$SG11541 DB	'TypedefDirective(%s) ok, mem_type=%Xh, size=%u, indirect'
	DB	'ion=%u target=%p', 0aH, 00H
	ORG $+6
$SG11588 DB	'RecordDirective(%d) enter', 0aH, 00H
	ORG $+5
$SG11093 DB	'SearchNameInStruct: ''%s'' found in struct %s', 0aH, 00H
	ORG $+3
$SG11105 DB	'AreStructsEqual(%s) enter', 0aH, 00H
	ORG $+5
$SG11112 DB	'AreStructsEqual: type name of field changed', 0aH, 00H
	ORG $+3
$SG11114 DB	'AreStructsEqual: offset of field %s changed: %u - %u', 0aH
	DB	00H
	ORG $+2
$SG11116 DB	'AreStructsEqual: total_size of field changed', 0aH, 00H
	ORG $+2
$SG11161 DB	'StructDirective(%s) enter, i=%u, CurrStruct=%s', 0aH, 00H
$SG11165 DB	'StructDirective(%s): error: either currstruct or i must '
	DB	'be 0', 0aH, 00H
	ORG $+2
$SG11183 DB	'StructDirective(%s) alignment=%u', 0aH, 00H
	ORG $+6
$SG11187 DB	'StructDirective(%s): error: unexpected token %u >%s<', 0aH
	DB	00H
	ORG $+2
$SG11192 DB	'StructDirective: SymSearch (%s)=%X (curr struct=%X)', 0aH
	DB	00H
	ORG $+3
$SG11193 DB	'StructDirective(%s): SearchNameInStruc()=%X', 0aH, 00H
	ORG $+3
$SG11199 DB	'types.c', 00H
$SG11200 DB	'types.c', 00H
$SG11239 DB	'EndstructDirective(%s), ofs=%u, struct size=%u, max_mbr='
	DB	'%u, alignment=%u', 0aH, 00H
	ORG $+6
$SG11250 DB	'EndstructDirective: names don''t match, i=%u, name=%s - '
	DB	'%s', 0aH, 00H
	ORG $+5
$SG11256 DB	'EndstructDirective:, struct size after final alignment=%'
	DB	'u', 0aH, 00H
_DATA	ENDS
PUBLIC	CreateTypeSymbol
PUBLIC	SearchNameInStruct
PUBLIC	GetQualifiedType
PUBLIC	CreateStructField
PUBLIC	UpdateStructSize
PUBLIC	SetStructCurrentOffset
PUBLIC	AlignInStruct
PUBLIC	TypesInit
PUBLIC	DeleteType
PUBLIC	StructDirective
PUBLIC	EndstructDirective
PUBLIC	TypedefDirective
PUBLIC	RecordDirective
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	_stricmp:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	myltoa:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymAlloc:PROC
EXTRN	SymFree:PROC
EXTRN	SymCreate:PROC
EXTRN	SymAddGlobal:PROC
EXTRN	SymLookup:PROC
EXTRN	SymFind:PROC
EXTRN	SizeFromMemtype:PROC
EXTRN	sym_remove_table:PROC
EXTRN	ParseProc:PROC
EXTRN	CreateProc:PROC
EXTRN	EvalOperand:PROC
EXTRN	LstWrite:PROC
EXTRN	InternalError:PROC
EXTRN	SymSimd:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SymCmpFunc:QWORD
EXTRN	SymTables:BYTE
EXTRN	SpecialTable:BYTE
_BSS	SEGMENT
redef_struct DQ	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$CreateTypeSymbol DD imagerel $LN8
	DD	imagerel $LN8+226
	DD	imagerel $unwind$CreateTypeSymbol
$pdata$SearchNameInStruct DD imagerel $LN15
	DD	imagerel $LN15+409
	DD	imagerel $unwind$SearchNameInStruct
$pdata$GetQualifiedType DD imagerel $LN72
	DD	imagerel $LN72+2535
	DD	imagerel $unwind$GetQualifiedType
$pdata$CreateStructField DD imagerel $LN42
	DD	imagerel $LN42+2050
	DD	imagerel $unwind$CreateStructField
$pdata$UpdateStructSize DD imagerel $LN9
	DD	imagerel $LN9+245
	DD	imagerel $unwind$UpdateStructSize
$pdata$SetStructCurrentOffset DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$SetStructCurrentOffset
$pdata$AlignInStruct DD imagerel $LN5
	DD	imagerel $LN5+107
	DD	imagerel $unwind$AlignInStruct
$pdata$DeleteType DD imagerel $LN7
	DD	imagerel $LN7+123
	DD	imagerel $unwind$DeleteType
$pdata$AreStructsEqual DD imagerel AreStructsEqual
	DD	imagerel AreStructsEqual+363
	DD	imagerel $unwind$AreStructsEqual
$pdata$StructDirective DD imagerel $LN61
	DD	imagerel $LN61+1941
	DD	imagerel $unwind$StructDirective
$pdata$EndstructDirective DD imagerel $LN41
	DD	imagerel $LN41+1458
	DD	imagerel $unwind$EndstructDirective
$pdata$CheckAnonymousStruct DD imagerel CheckAnonymousStruct
	DD	imagerel CheckAnonymousStruct+223
	DD	imagerel $unwind$CheckAnonymousStruct
$pdata$TypedefDirective DD imagerel $LN52
	DD	imagerel $LN52+2545
	DD	imagerel $unwind$TypedefDirective
$pdata$RecordDirective DD imagerel $LN56
	DD	imagerel $LN56+2201
	DD	imagerel $unwind$RecordDirective
pdata	ENDS
xdata	SEGMENT
$unwind$CreateTypeSymbol DD 011301H
	DD	06213H
$unwind$SearchNameInStruct DD 011801H
	DD	08218H
$unwind$GetQualifiedType DD 021601H
	DD	0130116H
$unwind$CreateStructField DD 021a01H
	DD	015011aH
$unwind$UpdateStructSize DD 010901H
	DD	08209H
$unwind$SetStructCurrentOffset DD 010801H
	DD	04208H
$unwind$AlignInStruct DD 010801H
	DD	02208H
$unwind$DeleteType DD 010901H
	DD	06209H
$unwind$AreStructsEqual DD 010e01H
	DD	0620eH
$unwind$StructDirective DD 021001H
	DD	01f0110H
$unwind$EndstructDirective DD 010d01H
	DD	0e20dH
$unwind$CheckAnonymousStruct DD 010901H
	DD	08209H
$unwind$TypedefDirective DD 031101H
	DD	0220111H
	DD	0300aH
$unwind$RecordDirective DD 021001H
	DD	0210110H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
f$ = 48
sym$ = 56
cntBits$ = 64
newr$ = 72
name_loc$ = 80
count$ = 84
len$ = 88
init_loc$ = 92
redef_err$ = 96
oldr$ = 104
tv192 = 112
define$ = 116
name$ = 120
tv334 = 128
opndx$ = 144
i$ = 272
tokenarray$ = 280
RecordDirective PROC

; 1116 : {

$LN56:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 264				; 00000108H

; 1117 :     char *name;
; 1118 :     struct asym *sym;
; 1119 :     struct dsym *newr;
; 1120 :     struct dsym *oldr = NULL;

	mov	QWORD PTR oldr$[rsp], 0

; 1121 :     struct sfield *f;
; 1122 :     int cntBits;
; 1123 :     int define;
; 1124 :     int len;
; 1125 :     int redef_err;
; 1126 :     int count;
; 1127 :     //int value;
; 1128 :     int name_loc;
; 1129 :     int init_loc;
; 1130 :     struct expr opndx;
; 1131 : 
; 1132 :     DebugMsg1(("RecordDirective(%d) enter\n", i));

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11588
	call	DoDebugMsg1

; 1133 :     if ( i != 1 ) {

	cmp	DWORD PTR i$[rsp], 1
	je	SHORT $LN11@RecordDire

; 1134 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@RecordDire
$LN11@RecordDire:

; 1135 :     }
; 1136 : 
; 1137 :     name = tokenarray[0].string_ptr;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR name$[rsp], rax

; 1138 :     sym = SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 1139 :     if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN14@RecordDire
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN12@RecordDire
$LN14@RecordDire:

; 1140 :         sym = CreateTypeSymbol( sym, name, TRUE );

	mov	r8b, 1
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateTypeSymbol
	mov	QWORD PTR sym$[rsp], rax
	jmp	SHORT $LN13@RecordDire
$LN12@RecordDire:

; 1141 :     } else if ( sym->state == SYM_TYPE &&

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN15@RecordDire
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 4
	je	SHORT $LN17@RecordDire
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	test	eax, eax
	jne	SHORT $LN15@RecordDire
$LN17@RecordDire:

; 1142 :                ( sym->typekind == TYPE_RECORD ||
; 1143 :                sym->typekind == TYPE_NONE ) ) {
; 1144 :         /* v2.04: allow redefinition of record and forward references.
; 1145 :          * the record redefinition may have different initial values,
; 1146 :          * but those new values are IGNORED! ( Masm bug? )
; 1147 :          */
; 1148 :         if ( Parse_Pass == PASS_1 && sym->typekind == TYPE_RECORD ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN18@RecordDire
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 4
	jne	SHORT $LN18@RecordDire

; 1149 :             oldr = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR oldr$[rsp], rax

; 1150 :             sym = CreateTypeSymbol( NULL, name, FALSE );

	xor	r8d, r8d
	mov	rdx, QWORD PTR name$[rsp]
	xor	ecx, ecx
	call	CreateTypeSymbol
	mov	QWORD PTR sym$[rsp], rax

; 1151 :             redef_err = 0;

	mov	DWORD PTR redef_err$[rsp], 0
$LN18@RecordDire:

; 1152 :         }
; 1153 :     } else {

	jmp	SHORT $LN16@RecordDire
$LN15@RecordDire:

; 1154 :         return( EmitErr( SYMBOL_REDEFINITION, name ) );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@RecordDire
$LN16@RecordDire:
$LN13@RecordDire:

; 1155 :     }
; 1156 :     sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 1157 : 
; 1158 :     if ( Parse_Pass > PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN19@RecordDire

; 1159 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@RecordDire
$LN19@RecordDire:

; 1160 : 
; 1161 :     newr = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR newr$[rsp], rax

; 1162 :     newr->sym.typekind = TYPE_RECORD;

	mov	rax, QWORD PTR newr$[rsp]
	mov	BYTE PTR [rax+66], 4

; 1163 : 
; 1164 :     i++; /* go past RECORD */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1165 : 
; 1166 :     cntBits = 0; /* counter for total of bits in record */

	mov	DWORD PTR cntBits$[rsp], 0
$LN4@RecordDire:

; 1167 :     /* parse bitfields */
; 1168 :     do {
; 1169 :         if ( tokenarray[i].token != T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN20@RecordDire

; 1170 :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1171 :             break;

	jmp	$LN3@RecordDire
$LN20@RecordDire:

; 1172 :         }
; 1173 :         len = strlen( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 1174 :         if( len > MAX_ID_LEN ) {

	cmp	DWORD PTR len$[rsp], 247		; 000000f7H
	jle	SHORT $LN21@RecordDire

; 1175 :             EmitError( IDENTIFIER_TOO_LONG );

	mov	ecx, 70					; 00000046H
	call	EmitError

; 1176 :             break;

	jmp	$LN3@RecordDire
$LN21@RecordDire:

; 1177 :         }
; 1178 :         name_loc = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR name_loc$[rsp], eax

; 1179 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1180 :         if ( tokenarray[i].token != T_COLON ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN22@RecordDire

; 1181 :             EmitError( COLON_EXPECTED );

	mov	ecx, 84					; 00000054H
	call	EmitError

; 1182 :             break;

	jmp	$LN3@RecordDire
$LN22@RecordDire:

; 1183 :         }
; 1184 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1185 :         /* get width */
; 1186 :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN23@RecordDire

; 1187 :             break;

	jmp	$LN3@RecordDire
$LN23@RecordDire:

; 1188 :         if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN24@RecordDire

; 1189 :             EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 1190 :             opndx.value = 1;

	mov	DWORD PTR opndx$[rsp], 1
$LN24@RecordDire:

; 1191 :         }
; 1192 :         if ( opndx.value == 0 ) {

	cmp	DWORD PTR opndx$[rsp], 0
	jne	SHORT $LN25@RecordDire

; 1193 :             EmitErr( TOO_FEW_BITS_IN_RECORD, tokenarray[name_loc].string_ptr );

	movsxd	rax, DWORD PTR name_loc$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 35					; 00000023H
	call	EmitErr

; 1194 :             break;

	jmp	$LN3@RecordDire
	jmp	SHORT $LN26@RecordDire
$LN25@RecordDire:

; 1195 :         } else if ( ( opndx.value + cntBits ) > MAXRECBITS ) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	SHORT $LN54@RecordDire
	mov	DWORD PTR tv192[rsp], 64		; 00000040H
	jmp	SHORT $LN55@RecordDire
$LN54@RecordDire:
	mov	DWORD PTR tv192[rsp], 32		; 00000020H
$LN55@RecordDire:
	mov	eax, DWORD PTR cntBits$[rsp]
	mov	ecx, DWORD PTR opndx$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, DWORD PTR tv192[rsp]
	jle	SHORT $LN27@RecordDire

; 1196 :             EmitErr( TOO_MANY_BITS_IN_RECORD, tokenarray[name_loc].string_ptr );

	movsxd	rax, DWORD PTR name_loc$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 140				; 0000008cH
	call	EmitErr

; 1197 :             break;

	jmp	$LN3@RecordDire
$LN27@RecordDire:
$LN26@RecordDire:

; 1198 :         }
; 1199 :         count = 0;

	mov	DWORD PTR count$[rsp], 0

; 1200 :         /* is there an initializer? ('=') */
; 1201 :         if ( tokenarray[i].token == T_DIRECTIVE &&

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	$LN28@RecordDire
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 48					; 00000030H
	jne	$LN28@RecordDire

; 1202 :             tokenarray[i].dirtype == DRT_EQUALSGN ) {
; 1203 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1204 :             for( init_loc = i; tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA; i++ );

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR init_loc$[rsp], eax
	jmp	SHORT $LN7@RecordDire
$LN5@RecordDire:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@RecordDire:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN6@RecordDire
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN6@RecordDire
	jmp	SHORT $LN5@RecordDire
$LN6@RecordDire:

; 1205 :             /* no value? */
; 1206 :             if ( init_loc == i ) {

	mov	eax, DWORD PTR i$[rsp]
	cmp	DWORD PTR init_loc$[rsp], eax
	jne	SHORT $LN29@RecordDire

; 1207 :                 EmitErr( SYNTAX_ERROR_EX, tokenarray[name_loc].tokpos );

	movsxd	rax, DWORD PTR name_loc$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1208 :                 break;

	jmp	$LN3@RecordDire
$LN29@RecordDire:

; 1209 :             }
; 1210 :             /* v2.09: initial values of record redefinitions are ignored! */
; 1211 :             if ( oldr == NULL )

	cmp	QWORD PTR oldr$[rsp], 0
	jne	SHORT $LN30@RecordDire

; 1212 :                 count = tokenarray[i].tokpos - tokenarray[init_loc].tokpos;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR init_loc$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR count$[rsp], eax
$LN30@RecordDire:
$LN28@RecordDire:

; 1213 :         }
; 1214 :         /* record field names are global! (Masm design flaw) */
; 1215 :         sym = SymSearch( tokenarray[name_loc].string_ptr );

	movsxd	rax, DWORD PTR name_loc$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 1216 :         define = TRUE;

	mov	DWORD PTR define$[rsp], 1

; 1217 :         if ( oldr ) {

	cmp	QWORD PTR oldr$[rsp], 0
	je	SHORT $LN31@RecordDire

; 1218 :             if ( sym == NULL ||
; 1219 :                 sym->state != SYM_STRUCT_FIELD ||
; 1220 :                 sym->mem_type != MT_BITS ||

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN34@RecordDire
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 6
	jne	SHORT $LN34@RecordDire
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 193			; 000000c1H
	jne	SHORT $LN34@RecordDire
	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], ecx
	je	SHORT $LN33@RecordDire
$LN34@RecordDire:

; 1221 :                 sym->total_size != opndx.value ) {
; 1222 :                 EmitErr( NON_BENIGN_XXX_REDEFINITION, szRecord, tokenarray[name_loc].string_ptr );

	movsxd	rax, DWORD PTR name_loc$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+8]
	lea	rdx, OFFSET FLAT:szRecord
	mov	ecx, 139				; 0000008bH
	call	EmitErr

; 1223 :                 redef_err++;

	mov	eax, DWORD PTR redef_err$[rsp]
	inc	eax
	mov	DWORD PTR redef_err$[rsp], eax

; 1224 :                 define = FALSE; /* v2.06: added */

	mov	DWORD PTR define$[rsp], 0
$LN33@RecordDire:

; 1225 :             }
; 1226 :         } else {

	jmp	SHORT $LN32@RecordDire
$LN31@RecordDire:

; 1227 :             if ( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN35@RecordDire

; 1228 :                 EmitErr( SYMBOL_REDEFINITION, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 1229 :                 break;

	jmp	$LN3@RecordDire
$LN35@RecordDire:
$LN32@RecordDire:

; 1230 :             }
; 1231 :         }
; 1232 : 
; 1233 :         if ( define ) { /* v2.06: don't add field if there was an error */

	cmp	DWORD PTR define$[rsp], 0
	je	$LN36@RecordDire

; 1234 :             cntBits += opndx.value;

	mov	eax, DWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR cntBits$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR cntBits$[rsp], eax

; 1235 :             f = LclAlloc( sizeof( struct sfield ) + count );

	movsxd	rax, DWORD PTR count$[rsp]
	add	rax, 112				; 00000070H
	mov	rcx, rax
	call	LclAlloc
	mov	QWORD PTR f$[rsp], rax

; 1236 :             memset( f, 0, sizeof( struct sfield ) );

	mov	r8d, 112				; 00000070H
	xor	edx, edx
	mov	rcx, QWORD PTR f$[rsp]
	call	memset

; 1237 :             f->sym.name_size = len;

	mov	rax, QWORD PTR f$[rsp]
	movzx	ecx, BYTE PTR len$[rsp]
	mov	BYTE PTR [rax+72], cl

; 1238 :             f->sym.name = LclAlloc( len + 1 );

	mov	eax, DWORD PTR len$[rsp]
	inc	eax
	cdqe
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR f$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1239 :             memcpy( f->sym.name, tokenarray[name_loc].string_ptr, len + 1 );

	mov	eax, DWORD PTR len$[rsp]
	inc	eax
	cdqe
	movsxd	rcx, DWORD PTR name_loc$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy

; 1240 :             f->sym.list = ModuleInfo.cref;

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 12
	and	eax, 1
	and	al, 1
	mov	rcx, QWORD PTR f$[rsp]
	movzx	ecx, BYTE PTR [rcx+41]
	and	cl, 254					; 000000feH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR f$[rsp]
	mov	BYTE PTR [rcx+41], al

; 1241 :             f->sym.state = SYM_STRUCT_FIELD;

	mov	rax, QWORD PTR f$[rsp]
	mov	DWORD PTR [rax+32], 6

; 1242 :             f->sym.mem_type = MT_BITS;

	mov	rax, QWORD PTR f$[rsp]
	mov	DWORD PTR [rax+36], 193			; 000000c1H

; 1243 :             f->sym.total_size = opndx.value;

	mov	rax, QWORD PTR f$[rsp]
	mov	ecx, DWORD PTR opndx$[rsp]
	mov	DWORD PTR [rax+56], ecx

; 1244 :             if ( !oldr ) {

	cmp	QWORD PTR oldr$[rsp], 0
	jne	SHORT $LN37@RecordDire

; 1245 :                 SymAddGlobal( &f->sym );

	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, rax
	call	SymAddGlobal
$LN37@RecordDire:

; 1246 :             }
; 1247 :             f->next = NULL;

	mov	rax, QWORD PTR f$[rsp]
	mov	QWORD PTR [rax+96], 0

; 1248 :             //f->sym = sym;
; 1249 :             f->ivalue[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR f$[rsp]
	mov	BYTE PTR [rcx+rax+104], 0

; 1250 :             //f->init_dir = NULL;
; 1251 :             if( newr->e.structinfo->head == NULL ) {

	mov	rax, QWORD PTR newr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN38@RecordDire

; 1252 :                 newr->e.structinfo->head = newr->e.structinfo->tail = f;

	mov	rax, QWORD PTR newr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR f$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR newr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR f$[rsp]
	mov	QWORD PTR [rax], rcx

; 1253 :             } else {

	jmp	SHORT $LN39@RecordDire
$LN38@RecordDire:

; 1254 :                 newr->e.structinfo->tail->next = f;

	mov	rax, QWORD PTR newr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR f$[rsp]
	mov	QWORD PTR [rax+96], rcx

; 1255 :                 newr->e.structinfo->tail = f;

	mov	rax, QWORD PTR newr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR f$[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN39@RecordDire:

; 1256 :             }
; 1257 :             if ( count ) {

	cmp	DWORD PTR count$[rsp], 0
	je	SHORT $LN40@RecordDire

; 1258 :                 //f->value = LclAlloc( count + 1 );
; 1259 :                 memcpy( f->ivalue, tokenarray[init_loc].tokpos, count );

	movsxd	rax, DWORD PTR count$[rsp]
	movsxd	rcx, DWORD PTR init_loc$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR f$[rsp]
	add	rdx, 104				; 00000068H
	mov	QWORD PTR tv334[rsp], rdx
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+24]
	mov	rax, QWORD PTR tv334[rsp]
	mov	rcx, rax
	call	memcpy

; 1260 :                 f->ivalue[count] = NULLC;

	movsxd	rax, DWORD PTR count$[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	mov	BYTE PTR [rcx+rax+104], 0
$LN40@RecordDire:
$LN36@RecordDire:

; 1261 :             }
; 1262 :         }
; 1263 : 
; 1264 :         if ( i < Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN41@RecordDire

; 1265 :             if ( tokenarray[i].token != T_COMMA || tokenarray[i+1].token == T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN43@RecordDire
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN42@RecordDire
$LN43@RecordDire:

; 1266 :                 EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1267 :                 break;

	jmp	SHORT $LN3@RecordDire
$LN42@RecordDire:

; 1268 :             }
; 1269 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN41@RecordDire:

; 1270 :         }
; 1271 : 
; 1272 :     } while ( i < Token_Count );

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jl	$LN4@RecordDire
$LN3@RecordDire:

; 1273 : 
; 1274 :     /* now calc size in bytes and set the bit positions */
; 1275 : 
; 1276 :     if ( cntBits > 16 ) {

	cmp	DWORD PTR cntBits$[rsp], 16
	jle	SHORT $LN44@RecordDire

; 1277 : #if AMD64_SUPPORT
; 1278 :         if ( cntBits > 32 ) {

	cmp	DWORD PTR cntBits$[rsp], 32		; 00000020H
	jle	SHORT $LN46@RecordDire

; 1279 :             newr->sym.total_size = sizeof( uint_64 );

	mov	rax, QWORD PTR newr$[rsp]
	mov	DWORD PTR [rax+56], 8

; 1280 :             newr->sym.mem_type = MT_QWORD;

	mov	rax, QWORD PTR newr$[rsp]
	mov	DWORD PTR [rax+36], 7

; 1281 :         } else {

	jmp	SHORT $LN47@RecordDire
$LN46@RecordDire:

; 1282 : #endif
; 1283 :             newr->sym.total_size = sizeof( uint_32 );

	mov	rax, QWORD PTR newr$[rsp]
	mov	DWORD PTR [rax+56], 4

; 1284 :             newr->sym.mem_type = MT_DWORD;

	mov	rax, QWORD PTR newr$[rsp]
	mov	DWORD PTR [rax+36], 3
$LN47@RecordDire:

; 1285 : #if AMD64_SUPPORT
; 1286 :         }

	jmp	SHORT $LN45@RecordDire
$LN44@RecordDire:

; 1287 : #endif
; 1288 :     } else if ( cntBits > 8 ) {

	cmp	DWORD PTR cntBits$[rsp], 8
	jle	SHORT $LN48@RecordDire

; 1289 :         newr->sym.total_size = sizeof( uint_16 );

	mov	rax, QWORD PTR newr$[rsp]
	mov	DWORD PTR [rax+56], 2

; 1290 :         newr->sym.mem_type = MT_WORD;

	mov	rax, QWORD PTR newr$[rsp]
	mov	DWORD PTR [rax+36], 1

; 1291 :     } else {

	jmp	SHORT $LN49@RecordDire
$LN48@RecordDire:

; 1292 :         newr->sym.total_size = sizeof( uint_8 );

	mov	rax, QWORD PTR newr$[rsp]
	mov	DWORD PTR [rax+56], 1

; 1293 :         newr->sym.mem_type = MT_BYTE;

	mov	rax, QWORD PTR newr$[rsp]
	mov	DWORD PTR [rax+36], 0
$LN49@RecordDire:
$LN45@RecordDire:

; 1294 :     }
; 1295 :     /* if the BYTE/WORD/DWORD isn't used fully, shift bits to the right! */
; 1296 :     // cntBits = dir->sym.total_size * 8;
; 1297 : 
; 1298 :     /* set the bit position */
; 1299 :     for ( f = newr->e.structinfo->head; f; f = f->next ) {

	mov	rax, QWORD PTR newr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR f$[rsp], rax
	jmp	SHORT $LN10@RecordDire
$LN8@RecordDire:
	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR f$[rsp], rax
$LN10@RecordDire:
	cmp	QWORD PTR f$[rsp], 0
	je	SHORT $LN9@RecordDire

; 1300 :         cntBits = cntBits - f->sym.total_size;

	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	ecx, DWORD PTR cntBits$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR cntBits$[rsp], eax

; 1301 :         f->sym.offset = cntBits;

	mov	rax, QWORD PTR f$[rsp]
	mov	ecx, DWORD PTR cntBits$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 1302 :     }

	jmp	SHORT $LN8@RecordDire
$LN9@RecordDire:

; 1303 :     if ( oldr ) {

	cmp	QWORD PTR oldr$[rsp], 0
	je	SHORT $LN50@RecordDire

; 1304 :         if ( redef_err > 0 ||

	cmp	DWORD PTR redef_err$[rsp], 0
	jg	SHORT $LN52@RecordDire
	mov	rdx, QWORD PTR oldr$[rsp]
	mov	rcx, QWORD PTR newr$[rsp]
	call	AreStructsEqual
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN51@RecordDire
$LN52@RecordDire:

; 1305 :             AreStructsEqual( newr, oldr ) == FALSE )
; 1306 :             EmitErr( NON_BENIGN_XXX_REDEFINITION, szRecord, newr->sym.name );

	mov	rax, QWORD PTR newr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	lea	rdx, OFFSET FLAT:szRecord
	mov	ecx, 139				; 0000008bH
	call	EmitErr
$LN51@RecordDire:

; 1307 :         /* record can be freed, because the record's fields are global items.
; 1308 :          * And initial values of the new definition are ignored!
; 1309 :          */
; 1310 :         SymFree( (struct asym *)newr );

	mov	rcx, QWORD PTR newr$[rsp]
	call	SymFree
$LN50@RecordDire:

; 1311 :     }
; 1312 :     DebugMsg(("RecordDirective(%s) exit, no error\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11631
	call	DoDebugMsg

; 1313 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@RecordDire:

; 1314 : }

	add	rsp, 264				; 00000108H
	ret	0
RecordDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
sym$ = 128
on$1 = 136
oo$2 = 137
ti$ = 144
proto$3 = 176
to$4 = 184
tn$5 = 192
tv240 = 200
tv246 = 204
tv332 = 208
tv422 = 212
name$ = 216
tv229 = 224
tv300 = 232
tv289 = 240
tv301 = 248
tv307 = 256
i$ = 288
tokenarray$ = 296
TypedefDirective PROC

; 969  : {

$LN52:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbx
	sub	rsp, 272				; 00000110H

; 970  :     struct asym         *sym;
; 971  :     char                *name;
; 972  :     struct qualified_type ti;
; 973  : 
; 974  :     DebugMsg1(("TypedefDirective(%d) enter\n", i));

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11505
	call	DoDebugMsg1

; 975  : 
; 976  :     if( i != 1 ) {

	cmp	DWORD PTR i$[rsp], 1
	je	SHORT $LN8@TypedefDir

; 977  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@TypedefDir
$LN8@TypedefDir:

; 978  :     }
; 979  :     name = tokenarray[0].string_ptr;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR name$[rsp], rax

; 980  : 
; 981  :     i++; /* go past TYPEDEF */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 982  : 
; 983  :     sym = SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 984  :     if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN11@TypedefDir
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN9@TypedefDir
$LN11@TypedefDir:

; 985  :         sym = CreateTypeSymbol( sym, name, TRUE );

	mov	r8b, 1
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateTypeSymbol
	mov	QWORD PTR sym$[rsp], rax

; 986  :         if ( sym == NULL )

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN12@TypedefDir

; 987  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@TypedefDir
$LN12@TypedefDir:

; 988  : #if TYPEOPT
; 989  :         /* release the structinfo data extension */
; 990  :         LclFree( ((struct dsym *)sym)->e.structinfo );
; 991  :         ((struct dsym *)sym)->e.structinfo = NULL;
; 992  : #endif
; 993  :     } else {

	jmp	SHORT $LN10@TypedefDir
$LN9@TypedefDir:

; 994  :         /* MASM allows to have the TYPEDEF included multiple times */
; 995  :         /* but the types must be identical! */
; 996  :         if ( ( sym->state != SYM_TYPE ) ||

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN14@TypedefDir
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	je	SHORT $LN13@TypedefDir
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	test	eax, eax
	je	SHORT $LN13@TypedefDir
$LN14@TypedefDir:

; 997  :             ( sym->typekind != TYPE_TYPEDEF &&
; 998  :              sym->typekind != TYPE_NONE ) ) {
; 999  :             return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@TypedefDir
$LN13@TypedefDir:
$LN10@TypedefDir:

; 1000 :         }
; 1001 :     }
; 1002 : 
; 1003 :     sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 1004 :     if ( Parse_Pass > PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN15@TypedefDir

; 1005 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@TypedefDir
$LN15@TypedefDir:

; 1006 :     sym->typekind = TYPE_TYPEDEF;

	mov	rax, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rax+66], 3

; 1007 : 
; 1008 :     /* PROTO is special */
; 1009 :     if ( tokenarray[i].token == T_DIRECTIVE && tokenarray[i].tokval == T_PROTO ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	$LN16@TypedefDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 432		; 000001b0H
	jne	$LN16@TypedefDir

; 1010 :         struct dsym *proto;  /* create a PROTOtype item without name */
; 1011 :         /* v2.04: added check if prototype is set already */
; 1012 :         if ( sym->target_type == NULL && sym->mem_type == MT_EMPTY ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+48], 0
	jne	SHORT $LN17@TypedefDir
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 192			; 000000c0H
	jne	SHORT $LN17@TypedefDir

; 1013 :             proto = (struct dsym *)CreateProc( NULL, "", SYM_TYPE );

	mov	r8d, 7
	lea	rdx, OFFSET FLAT:$SG11517
	xor	ecx, ecx
	call	CreateProc
	mov	QWORD PTR proto$3[rsp], rax

; 1014 :             DebugMsg1(("TypedefDirective PROTO, created new unnamed prototype %p\n", proto ));

	mov	rdx, QWORD PTR proto$3[rsp]
	lea	rcx, OFFSET FLAT:$SG11518
	call	DoDebugMsg1
	jmp	SHORT $LN18@TypedefDir
$LN17@TypedefDir:

; 1015 :         } else if ( sym->mem_type == MT_PROC ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 128			; 00000080H
	jne	SHORT $LN19@TypedefDir

; 1016 :             proto = (struct dsym *)sym->target_type;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR proto$3[rsp], rax

; 1017 :         } else {

	jmp	SHORT $LN20@TypedefDir
$LN19@TypedefDir:

; 1018 :             return( EmitErr( SYMBOL_TYPE_CONFLICT, sym->name ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 136				; 00000088H
	call	EmitErr
	jmp	$LN1@TypedefDir
$LN20@TypedefDir:
$LN18@TypedefDir:

; 1019 :         }
; 1020 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1021 :         DebugMsg1(("TypedefDirective PROTO, call ParseProc(sym=%p i=%d, 0)\n", proto, i));

	mov	r8d, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR proto$3[rsp]
	lea	rcx, OFFSET FLAT:$SG11521
	call	DoDebugMsg1

; 1022 :         if( ParseProc( proto, i, tokenarray, FALSE, ModuleInfo.langtype ) == ERROR )

	mov	eax, DWORD PTR ModuleInfo+364
	mov	DWORD PTR [rsp+32], eax
	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR proto$3[rsp]
	call	ParseProc
	cmp	eax, -1
	jne	SHORT $LN21@TypedefDir

; 1023 :             return ( ERROR );

	mov	eax, -1
	jmp	$LN1@TypedefDir
$LN21@TypedefDir:

; 1024 :         DebugMsg1(("TypedefDirective PROTO, ParseProc() returned status ok\n"));

	lea	rcx, OFFSET FLAT:$SG11523
	call	DoDebugMsg1

; 1025 :         sym->mem_type = MT_PROC;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+36], 128			; 00000080H

; 1026 :         /* v2.11: member isproc was set inside ParseProc() */
; 1027 :         //proto->sym.isproc = TRUE; /* v2.05: added */
; 1028 :         sym->Ofssize = proto->sym.seg_ofssize;

	mov	rax, QWORD PTR proto$3[rsp]
	movzx	eax, BYTE PTR [rax+47]
	and	al, 3
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+44], al

; 1029 :         /* v2.03: set value of field total_size (previously was 0) */
; 1030 :         sym->total_size = ( 2 << sym->Ofssize );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	ecx, 2
	mov	DWORD PTR tv422[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv422[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+56], eax

; 1031 :         if( proto->sym.mem_type != MT_NEAR ) {

	mov	rax, QWORD PTR proto$3[rsp]
	cmp	DWORD PTR [rax+36], 129			; 00000081H
	je	SHORT $LN22@TypedefDir

; 1032 :             sym->isfar = TRUE; /* v2.04: added */

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	or	al, 16
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 1033 :             sym->total_size += 2;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+56]
	add	eax, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+56], eax
$LN22@TypedefDir:

; 1034 :         }
; 1035 :         sym->target_type = (struct asym *)proto;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR proto$3[rsp]
	mov	QWORD PTR [rax+48], rcx

; 1036 :         DebugMsg1(("TypedefDirective(%s) ok, mem_type=%Xh, ofssize=%u\n", sym->name, sym->mem_type, sym->Ofssize ));

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	r9d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+36]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11525
	call	DoDebugMsg1

; 1037 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@TypedefDir
$LN16@TypedefDir:

; 1038 :     }
; 1039 :     ti.size = 0;

	mov	DWORD PTR ti$[rsp], 0

; 1040 :     ti.is_ptr = 0;

	mov	BYTE PTR ti$[rsp+20], 0

; 1041 :     ti.is_far = FALSE;

	mov	BYTE PTR ti$[rsp+21], 0

; 1042 :     ti.mem_type = MT_EMPTY;

	mov	DWORD PTR ti$[rsp+16], 192		; 000000c0H

; 1043 :     ti.ptr_memtype = MT_EMPTY;

	mov	DWORD PTR ti$[rsp+24], 192		; 000000c0H

; 1044 :     ti.symtype = NULL;

	mov	QWORD PTR ti$[rsp+8], 0

; 1045 :     ti.Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	BYTE PTR ti$[rsp+22], al

; 1046 : 
; 1047 :     /* "empty" type is ok for TYPEDEF */
; 1048 :     if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_COMMA )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN25@TypedefDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN23@TypedefDir
$LN25@TypedefDir:

; 1049 :         ;

	jmp	SHORT $LN24@TypedefDir
$LN23@TypedefDir:

; 1050 :     else if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	GetQualifiedType
	cmp	eax, -1
	jne	SHORT $LN26@TypedefDir

; 1051 :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@TypedefDir
$LN26@TypedefDir:
$LN24@TypedefDir:

; 1052 : 
; 1053 :     /* if type did exist already, check for type conflicts
; 1054 :      * v2.05: this code has been rewritten */
; 1055 :     if ( sym->mem_type != MT_EMPTY ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 192			; 000000c0H
	je	$LN27@TypedefDir

; 1056 :         struct asym *to;
; 1057 :         struct asym *tn;
; 1058 :         char oo;
; 1059 :         char on;
; 1060 :         for( tn = ti.symtype; tn && tn->type; tn = tn->type );

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR tn$5[rsp], rax
	jmp	SHORT $LN4@TypedefDir
$LN2@TypedefDir:
	mov	rax, QWORD PTR tn$5[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR tn$5[rsp], rax
$LN4@TypedefDir:
	cmp	QWORD PTR tn$5[rsp], 0
	je	SHORT $LN3@TypedefDir
	mov	rax, QWORD PTR tn$5[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN3@TypedefDir
	jmp	SHORT $LN2@TypedefDir
$LN3@TypedefDir:

; 1061 :         to = ( sym->mem_type == MT_TYPE ) ? sym->type : sym->target_type;

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN36@TypedefDir
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR tv229[rsp], rax
	jmp	SHORT $LN37@TypedefDir
$LN36@TypedefDir:
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv229[rsp], rax
$LN37@TypedefDir:
	mov	rax, QWORD PTR tv229[rsp]
	mov	QWORD PTR to$4[rsp], rax
	jmp	SHORT $LN7@TypedefDir
$LN5@TypedefDir:

; 1062 :         for( ; to && to->type; to = to->type );

	mov	rax, QWORD PTR to$4[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR to$4[rsp], rax
$LN7@TypedefDir:
	cmp	QWORD PTR to$4[rsp], 0
	je	SHORT $LN6@TypedefDir
	mov	rax, QWORD PTR to$4[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN6@TypedefDir
	jmp	SHORT $LN5@TypedefDir
$LN6@TypedefDir:

; 1063 :         oo = ( sym->Ofssize != USE_EMPTY ) ? sym->Ofssize : ModuleInfo.Ofssize;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	cmp	eax, 254				; 000000feH
	je	SHORT $LN38@TypedefDir
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	DWORD PTR tv240[rsp], eax
	jmp	SHORT $LN39@TypedefDir
$LN38@TypedefDir:
	movzx	eax, BYTE PTR ModuleInfo+404
	mov	DWORD PTR tv240[rsp], eax
$LN39@TypedefDir:
	movzx	eax, BYTE PTR tv240[rsp]
	mov	BYTE PTR oo$2[rsp], al

; 1064 :         on = ( ti.Ofssize != USE_EMPTY ) ? ti.Ofssize : ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ti$[rsp+22]
	cmp	eax, 254				; 000000feH
	je	SHORT $LN40@TypedefDir
	movzx	eax, BYTE PTR ti$[rsp+22]
	mov	DWORD PTR tv246[rsp], eax
	jmp	SHORT $LN41@TypedefDir
$LN40@TypedefDir:
	movzx	eax, BYTE PTR ModuleInfo+404
	mov	DWORD PTR tv246[rsp], eax
$LN41@TypedefDir:
	movzx	eax, BYTE PTR tv246[rsp]
	mov	BYTE PTR on$1[rsp], al

; 1065 :         if ( ti.mem_type != sym->mem_type ||
; 1066 :             ( ti.mem_type == MT_TYPE && tn != to ) ||

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+36]
	cmp	DWORD PTR ti$[rsp+16], eax
	jne	$LN29@TypedefDir
	cmp	DWORD PTR ti$[rsp+16], 196		; 000000c4H
	jne	SHORT $LN30@TypedefDir
	mov	rax, QWORD PTR to$4[rsp]
	cmp	QWORD PTR tn$5[rsp], rax
	jne	SHORT $LN29@TypedefDir
$LN30@TypedefDir:
	cmp	DWORD PTR ti$[rsp+16], 195		; 000000c3H
	jne	$LN28@TypedefDir
	movzx	eax, BYTE PTR ti$[rsp+21]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	shr	cl, 4
	and	cl, 1
	movzx	ecx, cl
	cmp	eax, ecx
	jne	SHORT $LN31@TypedefDir
	movsx	eax, BYTE PTR on$1[rsp]
	movsx	ecx, BYTE PTR oo$2[rsp]
	cmp	eax, ecx
	jne	SHORT $LN31@TypedefDir
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	cmp	DWORD PTR ti$[rsp+24], eax
	jne	SHORT $LN31@TypedefDir
	mov	rax, QWORD PTR to$4[rsp]
	cmp	QWORD PTR tn$5[rsp], rax
	je	$LN28@TypedefDir
$LN31@TypedefDir:
$LN29@TypedefDir:

; 1067 :             ( ti.mem_type == MT_PTR &&
; 1068 :              ( ti.is_far != sym->isfar ||
; 1069 :               on != oo ||
; 1070 :               ti.ptr_memtype != sym->ptr_memtype ||
; 1071 :               tn != to ))) {
; 1072 :             DebugMsg(("TypedefDirective: old-new memtype=%X-%X type=%X(%s)-%X(%s) far=%u-%u ind=%u-%u ofss=%d-%d pmt=%X-%X\n",

	cmp	QWORD PTR ti$[rsp+8], 0
	je	SHORT $LN42@TypedefDir
	mov	rax, QWORD PTR ti$[rsp+8]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv289[rsp], rax
	jmp	SHORT $LN43@TypedefDir
$LN42@TypedefDir:
	lea	rax, OFFSET FLAT:$SG11535
	mov	QWORD PTR tv289[rsp], rax
$LN43@TypedefDir:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN46@TypedefDir
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv301[rsp], rax
	jmp	SHORT $LN47@TypedefDir
$LN46@TypedefDir:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN44@TypedefDir
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv300[rsp], rax
	jmp	SHORT $LN45@TypedefDir
$LN44@TypedefDir:
	lea	rax, OFFSET FLAT:$SG11536
	mov	QWORD PTR tv300[rsp], rax
$LN45@TypedefDir:
	mov	rax, QWORD PTR tv300[rsp]
	mov	QWORD PTR tv301[rsp], rax
$LN47@TypedefDir:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN48@TypedefDir
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR tv307[rsp], rax
	jmp	SHORT $LN49@TypedefDir
$LN48@TypedefDir:
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv307[rsp], rax
$LN49@TypedefDir:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	movzx	ecx, BYTE PTR ti$[rsp+22]
	mov	rdx, QWORD PTR sym$[rsp]
	movzx	edx, BYTE PTR [rdx+44]
	movzx	r8d, BYTE PTR ti$[rsp+20]
	mov	r9, QWORD PTR sym$[rsp]
	movzx	r9d, BYTE PTR [r9+45]
	movzx	r10d, BYTE PTR ti$[rsp+21]
	mov	r11, QWORD PTR sym$[rsp]
	movzx	r11d, BYTE PTR [r11+47]
	shr	r11b, 4
	and	r11b, 1
	movzx	r11d, r11b
	mov	ebx, DWORD PTR ti$[rsp+24]
	mov	DWORD PTR [rsp+112], ebx
	mov	DWORD PTR [rsp+104], eax
	mov	DWORD PTR [rsp+96], ecx
	mov	DWORD PTR [rsp+88], edx
	mov	DWORD PTR [rsp+80], r8d
	mov	DWORD PTR [rsp+72], r9d
	mov	DWORD PTR [rsp+64], r10d
	mov	DWORD PTR [rsp+56], r11d
	mov	rax, QWORD PTR tv289[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv301[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv307[rsp]
	mov	r8d, DWORD PTR ti$[rsp+16]
	mov	rax, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR [rax+36]
	lea	rcx, OFFSET FLAT:$SG11537
	call	DoDebugMsg

; 1073 :                       sym->mem_type, ti.mem_type,
; 1074 :                       (sym->mem_type == MT_TYPE) ? sym->type : sym->target_type,
; 1075 :                       (sym->mem_type == MT_TYPE) ? sym->type->name : sym->target_type ? sym->target_type->name : "",
; 1076 :                       ti.symtype, ti.symtype ? ti.symtype->name : "",
; 1077 :                       sym->isfar, ti.is_far,
; 1078 :                       sym->is_ptr, ti.is_ptr,
; 1079 :                       sym->Ofssize, ti.Ofssize,
; 1080 :                       sym->ptr_memtype, ti.ptr_memtype ));
; 1081 :             return( EmitErr( SYMBOL_TYPE_CONFLICT, name ) );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 136				; 00000088H
	call	EmitErr
	jmp	$LN1@TypedefDir
$LN28@TypedefDir:
$LN27@TypedefDir:

; 1082 :         }
; 1083 :     }
; 1084 : 
; 1085 :     sym->mem_type = ti.mem_type;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR ti$[rsp+16]
	mov	DWORD PTR [rax+36], ecx

; 1086 :     sym->Ofssize = ti.Ofssize;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR ti$[rsp+22]
	mov	BYTE PTR [rax+44], cl

; 1087 :     sym->total_size = ti.size;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR ti$[rsp]
	mov	DWORD PTR [rax+56], ecx

; 1088 :     sym->is_ptr = ti.is_ptr;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR ti$[rsp+20]
	mov	BYTE PTR [rax+45], cl

; 1089 :     sym->isfar = ti.is_far;

	movzx	eax, BYTE PTR ti$[rsp+21]
	and	al, 1
	shl	al, 4
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 239					; 000000efH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 1090 :     if ( ti.mem_type == MT_TYPE )

	cmp	DWORD PTR ti$[rsp+16], 196		; 000000c4H
	jne	SHORT $LN32@TypedefDir

; 1091 :         sym->type = ti.symtype;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rax+80], rcx
	jmp	SHORT $LN33@TypedefDir
$LN32@TypedefDir:

; 1092 :     else
; 1093 :         sym->target_type = ti.symtype;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rax+48], rcx
$LN33@TypedefDir:

; 1094 :     sym->ptr_memtype = ti.ptr_memtype;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR ti$[rsp+24]
	mov	BYTE PTR [rax+46], cl

; 1095 :     DebugMsg1(("TypedefDirective(%s) ok, mem_type=MT_TYPE, size=%" I32_SPEC "u, type=%p type.memtype=%X\n",

	cmp	QWORD PTR ti$[rsp+8], 0
	je	SHORT $LN50@TypedefDir
	mov	rax, QWORD PTR ti$[rsp+8]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR tv332[rsp], eax
	jmp	SHORT $LN51@TypedefDir
$LN50@TypedefDir:
	mov	DWORD PTR tv332[rsp], 0
$LN51@TypedefDir:
	mov	eax, DWORD PTR tv332[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r9, QWORD PTR [rax+80]
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+56]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11540
	call	DoDebugMsg1

; 1096 :                sym->name, sym->total_size, sym->type, ti.symtype ? ti.symtype->mem_type : 0 ));
; 1097 : 
; 1098 :     DebugMsg1(("TypedefDirective(%s) ok, mem_type=%Xh, size=%u, indirection=%u target=%p\n", sym->name, sym->mem_type, ti.size, ti.is_ptr, ti.symtype ));

	movzx	eax, BYTE PTR ti$[rsp+20]
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR ti$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+36]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11541
	call	DoDebugMsg1

; 1099 : 
; 1100 :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN34@TypedefDir

; 1101 :         DebugMsg(("TypedefDirective: unexpected token %u, idx=%u\n", tokenarray[i].token, i));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	r8d, DWORD PTR i$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11543
	call	DoDebugMsg

; 1102 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@TypedefDir
$LN34@TypedefDir:

; 1103 :     }
; 1104 : 
; 1105 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@TypedefDir:

; 1106 : }

	add	rsp, 272				; 00000110H
	pop	rbx
	ret	0
TypedefDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
disp$ = 32
f$ = 40
stype$1 = 48
sym$ = 56
type$ = 80
CheckAnonymousStruct PROC

; 518  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 519  :     uint_32 disp;
; 520  :     struct asym  *sym;
; 521  :     struct sfield *f;
; 522  : 
; 523  :     for ( f = type->e.structinfo->head; f; f = f->next ) {

	mov	rax, QWORD PTR type$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR f$[rsp], rax
	jmp	SHORT $LN4@CheckAnony
$LN2@CheckAnony:
	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR f$[rsp], rax
$LN4@CheckAnony:
	cmp	QWORD PTR f$[rsp], 0
	je	$LN3@CheckAnony

; 524  :         if ( *f->sym.name ) {

	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN5@CheckAnony

; 525  :             sym = SearchNameInStruct((struct asym *)CurrStruct, f->sym.name, &disp, 0 );

	xor	r9d, r9d
	lea	r8, QWORD PTR disp$[rsp]
	mov	rax, QWORD PTR f$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR CurrStruct
	call	SearchNameInStruct
	mov	QWORD PTR sym$[rsp], rax

; 526  :             if ( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN7@CheckAnony

; 527  :                 return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	SHORT $LN1@CheckAnony
$LN7@CheckAnony:

; 528  :             }

	jmp	SHORT $LN6@CheckAnony
$LN5@CheckAnony:

; 529  :         } else if ( f->sym.type ) {

	mov	rax, QWORD PTR f$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN8@CheckAnony

; 530  :             struct dsym *stype = (struct dsym *)f->sym.type;

	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR stype$1[rsp], rax

; 531  :             if ( stype->sym.typekind == TYPE_STRUCT ||

	mov	rax, QWORD PTR stype$1[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 1
	je	SHORT $LN10@CheckAnony
	mov	rax, QWORD PTR stype$1[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	jne	SHORT $LN9@CheckAnony
$LN10@CheckAnony:

; 532  :                 stype->sym.typekind == TYPE_UNION ) {
; 533  :             if ( CheckAnonymousStruct( stype ) == ERROR )

	mov	rcx, QWORD PTR stype$1[rsp]
	call	CheckAnonymousStruct
	cmp	eax, -1
	jne	SHORT $LN11@CheckAnony

; 534  :                 return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@CheckAnony
$LN11@CheckAnony:
$LN9@CheckAnony:
$LN8@CheckAnony:
$LN6@CheckAnony:

; 535  :             }
; 536  :         }
; 537  :     }

	jmp	$LN2@CheckAnony
$LN3@CheckAnony:

; 538  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@CheckAnony:

; 539  : }

	add	rsp, 72					; 00000048H
	ret	0
CheckAnonymousStruct ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
size$ = 48
tv239 = 52
min$1 = 56
dir$ = 64
f$2 = 72
tv132 = 80
tv224 = 88
sym$3 = 96
i$ = 128
tokenarray$ = 136
EndstructDirective PROC

; 369  : {

$LN41:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 120				; 00000078H

; 370  :     //char *name;
; 371  :     //unsigned int offset;
; 372  :     unsigned int size;
; 373  :     //struct asym *sym;
; 374  :     //memtype mem_type;
; 375  :     struct dsym *dir;
; 376  : 
; 377  :     dir = CurrStruct; /* cannot be NULL */

	mov	rax, QWORD PTR CurrStruct
	mov	QWORD PTR dir$[rsp], rax

; 378  : 
; 379  :     DebugMsg1(("EndstructDirective(%s), ofs=%" I32_SPEC "u, struct size=%" I32_SPEC "u, max_mbr=%" I32_SPEC "u, alignment=%u\n",

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+28]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR dir$[rsp]
	mov	eax, DWORD PTR [rax+48]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR dir$[rsp]
	mov	r9d, DWORD PTR [rax+56]
	mov	rax, QWORD PTR dir$[rsp]
	mov	r8d, DWORD PTR [rax+16]
	mov	rax, QWORD PTR dir$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11239
	call	DoDebugMsg1

; 380  :               dir->sym.name,
; 381  :               dir->sym.offset,
; 382  :               dir->sym.total_size,
; 383  :               dir->sym.max_mbr_size,
; 384  :               dir->e.structinfo->alignment));
; 385  : 
; 386  :     /* if pass is > 1 just do minimal work */
; 387  :     if ( Parse_Pass > PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN7@EndstructD

; 388  :         CurrStruct->sym.offset = 0;

	mov	rax, QWORD PTR CurrStruct
	mov	DWORD PTR [rax+16], 0

; 389  :         size = CurrStruct->sym.total_size;

	mov	rax, QWORD PTR CurrStruct
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR size$[rsp], eax

; 390  :         CurrStruct = CurrStruct->next;

	mov	rax, QWORD PTR CurrStruct
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR CurrStruct, rax

; 391  :         if ( CurrStruct )

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN8@EndstructD

; 392  :             UpdateStructSize( (struct asym *)dir );

	mov	rcx, QWORD PTR dir$[rsp]
	call	UpdateStructSize
$LN8@EndstructD:

; 393  :         if ( CurrFile[LST] )

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN9@EndstructD

; 394  :             LstWrite( LSTTYPE_STRUCT, size, dir );

	mov	r8, QWORD PTR dir$[rsp]
	mov	edx, DWORD PTR size$[rsp]
	mov	ecx, 6
	call	LstWrite
$LN9@EndstructD:

; 395  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@EndstructD
$LN7@EndstructD:

; 396  :     }
; 397  : 
; 398  :     /* syntax is either "<name> ENDS" (i=1) or "ENDS" (i=0).
; 399  :      * first case must be top level (next=NULL), latter case must NOT be top level (next!=NULL)
; 400  :      */
; 401  :     if ( ( i == 1 && dir->next == NULL ) ||

	cmp	DWORD PTR i$[rsp], 1
	jne	SHORT $LN13@EndstructD
	mov	rax, QWORD PTR dir$[rsp]
	cmp	QWORD PTR [rax+104], 0
	je	SHORT $LN12@EndstructD
$LN13@EndstructD:
	cmp	DWORD PTR i$[rsp], 0
	jne	SHORT $LN10@EndstructD
	mov	rax, QWORD PTR dir$[rsp]
	cmp	QWORD PTR [rax+104], 0
	je	SHORT $LN10@EndstructD
$LN12@EndstructD:

; 402  :         ( i == 0 && dir->next != NULL ) ) {
; 403  :         ;
; 404  :     } else {

	jmp	SHORT $LN11@EndstructD
$LN10@EndstructD:

; 405  :         /* v2.04: error msg improved */
; 406  :         //EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );
; 407  :         return( EmitErr( UNMATCHED_BLOCK_NESTING, i == 1 ? tokenarray[0].string_ptr : "" ) );

	cmp	DWORD PTR i$[rsp], 1
	jne	SHORT $LN37@EndstructD
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR tv132[rsp], rax
	jmp	SHORT $LN38@EndstructD
$LN37@EndstructD:
	lea	rax, OFFSET FLAT:$SG11247
	mov	QWORD PTR tv132[rsp], rax
$LN38@EndstructD:
	mov	rdx, QWORD PTR tv132[rsp]
	mov	ecx, 142				; 0000008eH
	call	EmitErr
	jmp	$LN1@EndstructD
$LN11@EndstructD:

; 408  :     }
; 409  : 
; 410  :     if ( i == 1 ) { /* an global struct ends with <name ENDS> */

	cmp	DWORD PTR i$[rsp], 1
	jne	$LN14@EndstructD

; 411  :         if ( SymCmpFunc( tokenarray[0].string_ptr, dir->sym.name, dir->sym.name_size ) != 0 ) {

	mov	rax, QWORD PTR dir$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 0
	mov	r8d, eax
	mov	rax, QWORD PTR dir$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rax+rcx+8]
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN15@EndstructD

; 412  :             /* names don't match */
; 413  :             DebugMsg(("EndstructDirective: names don't match, i=%u, name=%s - %s\n", i, tokenarray[0].string_ptr, dir->sym.name));

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dir$[rsp]
	mov	r9, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+8]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11250
	call	DoDebugMsg

; 414  :             return( EmitErr( UNMATCHED_BLOCK_NESTING, tokenarray[0].string_ptr ) );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 142				; 0000008eH
	call	EmitErr
	jmp	$LN1@EndstructD
$LN15@EndstructD:
$LN14@EndstructD:

; 415  :         }
; 416  :     }
; 417  : 
; 418  :     i++; /* go past ENDS */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 419  : 
; 420  :     /* v2.07: if ORG was used inside the struct, the struct's size
; 421  :      * has to be calculated now - there may exist negative offsets.
; 422  :      */
; 423  :     if ( dir->e.structinfo->OrgInside ) {

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+29]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@EndstructD

; 424  :         struct sfield *f;
; 425  :         int_32 min = 0;

	mov	DWORD PTR min$1[rsp], 0

; 426  :         for ( f = dir->e.structinfo->head; f; f = f->next )

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR f$2[rsp], rax
	jmp	SHORT $LN4@EndstructD
$LN2@EndstructD:
	mov	rax, QWORD PTR f$2[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR f$2[rsp], rax
$LN4@EndstructD:
	cmp	QWORD PTR f$2[rsp], 0
	je	SHORT $LN3@EndstructD

; 427  :             if ( f->sym.offset < min )

	mov	rax, QWORD PTR f$2[rsp]
	mov	ecx, DWORD PTR min$1[rsp]
	cmp	DWORD PTR [rax+16], ecx
	jge	SHORT $LN17@EndstructD

; 428  :                 min = f->sym.offset;

	mov	rax, QWORD PTR f$2[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR min$1[rsp], eax
$LN17@EndstructD:
	jmp	SHORT $LN2@EndstructD
$LN3@EndstructD:

; 429  :         dir->sym.total_size = dir->sym.total_size - min;

	mov	rax, QWORD PTR dir$[rsp]
	mov	ecx, DWORD PTR min$1[rsp]
	mov	eax, DWORD PTR [rax+56]
	sub	eax, ecx
	mov	rcx, QWORD PTR dir$[rsp]
	mov	DWORD PTR [rcx+56], eax
$LN16@EndstructD:

; 430  :     }
; 431  : 
; 432  :     /* Pad bytes at the end of the structure. */
; 433  : #if 1
; 434  :     /* v2.02: this is to be done in any case, whether -Zg is set or not */
; 435  :     //if ( dir->e.structinfo->alignment > 1 && Options.masm_compat_gencode == FALSE ) {
; 436  :     if ( dir->e.structinfo->alignment > 1 ) {

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+28]
	cmp	eax, 1
	jle	SHORT $LN18@EndstructD

; 437  :         size = dir->sym.max_mbr_size;

	mov	rax, QWORD PTR dir$[rsp]
	mov	eax, DWORD PTR [rax+48]
	mov	DWORD PTR size$[rsp], eax

; 438  :         if ( size == 0 )

	cmp	DWORD PTR size$[rsp], 0
	jne	SHORT $LN19@EndstructD

; 439  :             size++;

	mov	eax, DWORD PTR size$[rsp]
	inc	eax
	mov	DWORD PTR size$[rsp], eax
$LN19@EndstructD:

; 440  :         if ( size > dir->e.structinfo->alignment )

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+28]
	cmp	DWORD PTR size$[rsp], eax
	jbe	SHORT $LN20@EndstructD

; 441  :             size = dir->e.structinfo->alignment;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+28]
	mov	DWORD PTR size$[rsp], eax
$LN20@EndstructD:

; 442  :         dir->sym.total_size = (dir->sym.total_size + size - 1) & (-size);

	mov	rax, QWORD PTR dir$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	ecx, DWORD PTR size$[rsp]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	ecx, DWORD PTR size$[rsp]
	neg	ecx
	and	eax, ecx
	mov	rcx, QWORD PTR dir$[rsp]
	mov	DWORD PTR [rcx+56], eax

; 443  :         DebugMsg1(("EndstructDirective:, struct size after final alignment=%" I32_SPEC "u\n", dir->sym.total_size));

	mov	rax, QWORD PTR dir$[rsp]
	mov	edx, DWORD PTR [rax+56]
	lea	rcx, OFFSET FLAT:$SG11256
	call	DoDebugMsg1
$LN18@EndstructD:

; 444  :     }
; 445  : #endif
; 446  :     dir->e.structinfo->isOpen = FALSE;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+29]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+29], al

; 447  :     dir->sym.isdefined = TRUE;

	mov	rax, QWORD PTR dir$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR dir$[rsp]
	mov	BYTE PTR [rcx+40], al

; 448  : 
; 449  :     /* if there's a negative offset, size will be wrong! */
; 450  :     size = dir->sym.total_size;

	mov	rax, QWORD PTR dir$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR size$[rsp], eax

; 451  : 
; 452  :     /* reset offset, it's just used during the definition */
; 453  :     dir->sym.offset = 0;

	mov	rax, QWORD PTR dir$[rsp]
	mov	DWORD PTR [rax+16], 0

; 454  : 
; 455  :     CurrStruct = dir->next;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR CurrStruct, rax

; 456  :     /* v2.0: add the embedded struct AFTER it has been parsed! */
; 457  :     if ( i == 1 ) {

	cmp	DWORD PTR i$[rsp], 1
	jne	$LN21@EndstructD

; 458  :         struct asym *sym;
; 459  :         /* v2.06: the struct name is needed for checks */
; 460  :         sym = CreateStructField( -1, NULL, *dir->sym.name ? dir->sym.name : NULL, MT_TYPE, &dir->sym, dir->sym.total_size );

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN39@EndstructD
	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv224[rsp], rax
	jmp	SHORT $LN40@EndstructD
$LN39@EndstructD:
	mov	QWORD PTR tv224[rsp], 0
$LN40@EndstructD:
	mov	rax, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rsp+40], ecx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 196				; 000000c4H
	mov	r8, QWORD PTR tv224[rsp]
	xor	edx, edx
	mov	ecx, -1
	call	CreateStructField
	mov	QWORD PTR sym$3[rsp], rax

; 461  :         /* the member name was stored in the type name */
; 462  :         //sym->name = dir->sym.name;
; 463  :         //sym->name_size = strlen( dir->sym.name );
; 464  :         sym->total_size = dir->sym.total_size;

	mov	rax, QWORD PTR sym$3[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax+56], ecx

; 465  :         dir->sym.name = ""; /* the type becomes anonymous */

	mov	rax, QWORD PTR dir$[rsp]
	lea	rcx, OFFSET FLAT:$SG11258
	mov	QWORD PTR [rax+8], rcx

; 466  :         dir->sym.name_size = 0;

	mov	rax, QWORD PTR dir$[rsp]
	mov	BYTE PTR [rax+72], 0
$LN21@EndstructD:

; 467  :     }
; 468  : 
; 469  :     if ( CurrFile[LST] ) {

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN22@EndstructD

; 470  :         LstWrite( LSTTYPE_STRUCT, size, dir );

	mov	r8, QWORD PTR dir$[rsp]
	mov	edx, DWORD PTR size$[rsp]
	mov	ecx, 6
	call	LstWrite
$LN22@EndstructD:

; 471  :     }
; 472  : #if 1
; 473  :     /* to allow direct structure access */
; 474  :     switch ( dir->sym.total_size ) {

	mov	rax, QWORD PTR dir$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR tv239[rsp], eax
	cmp	DWORD PTR tv239[rsp], 1
	je	SHORT $LN23@EndstructD
	cmp	DWORD PTR tv239[rsp], 2
	je	SHORT $LN24@EndstructD
	cmp	DWORD PTR tv239[rsp], 4
	je	SHORT $LN25@EndstructD
	cmp	DWORD PTR tv239[rsp], 6
	je	SHORT $LN26@EndstructD
	cmp	DWORD PTR tv239[rsp], 8
	je	SHORT $LN27@EndstructD
	jmp	SHORT $LN28@EndstructD
$LN23@EndstructD:

; 475  :     case 1:  dir->sym.mem_type = MT_BYTE;   break;

	mov	rax, QWORD PTR dir$[rsp]
	mov	DWORD PTR [rax+36], 0
	jmp	SHORT $LN5@EndstructD
$LN24@EndstructD:

; 476  :     case 2:  dir->sym.mem_type = MT_WORD;   break;

	mov	rax, QWORD PTR dir$[rsp]
	mov	DWORD PTR [rax+36], 1
	jmp	SHORT $LN5@EndstructD
$LN25@EndstructD:

; 477  :     case 4:  dir->sym.mem_type = MT_DWORD;  break;

	mov	rax, QWORD PTR dir$[rsp]
	mov	DWORD PTR [rax+36], 3
	jmp	SHORT $LN5@EndstructD
$LN26@EndstructD:

; 478  :     case 6:  dir->sym.mem_type = MT_FWORD;  break;

	mov	rax, QWORD PTR dir$[rsp]
	mov	DWORD PTR [rax+36], 5
	jmp	SHORT $LN5@EndstructD
$LN27@EndstructD:

; 479  :     case 8:  dir->sym.mem_type = MT_QWORD;  break;

	mov	rax, QWORD PTR dir$[rsp]
	mov	DWORD PTR [rax+36], 7
	jmp	SHORT $LN5@EndstructD
$LN28@EndstructD:

; 480  :     //case 16:  dir->sym.mem_type = MT_OWORD;  break;
; 481  :     default: dir->sym.mem_type = MT_EMPTY;

	mov	rax, QWORD PTR dir$[rsp]
	mov	DWORD PTR [rax+36], 192			; 000000c0H
$LN5@EndstructD:

; 482  :     }
; 483  : #endif
; 484  :     /* reset redefine */
; 485  :     if ( CurrStruct == NULL ) {

	cmp	QWORD PTR CurrStruct, 0
	jne	SHORT $LN29@EndstructD

; 486  :         if ( redef_struct ) {

	cmp	QWORD PTR redef_struct, 0
	je	SHORT $LN31@EndstructD

; 487  :             if ( AreStructsEqual( dir, redef_struct) == FALSE ) {

	mov	rdx, QWORD PTR redef_struct
	mov	rcx, QWORD PTR dir$[rsp]
	call	AreStructsEqual
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN32@EndstructD

; 488  :                 EmitErr( NON_BENIGN_XXX_REDEFINITION, szStructure, dir->sym.name );

	mov	rax, QWORD PTR dir$[rsp]
	mov	r8, QWORD PTR [rax+8]
	lea	rdx, OFFSET FLAT:szStructure
	mov	ecx, 139				; 0000008bH
	call	EmitErr
$LN32@EndstructD:

; 489  :             }
; 490  :             DebugMsg(("EndstructDirective: delete the redefinition of %s\n", dir->sym.name ));

	mov	rax, QWORD PTR dir$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11270
	call	DoDebugMsg

; 491  :             SymFree( (struct asym *)dir );

	mov	rcx, QWORD PTR dir$[rsp]
	call	SymFree

; 492  :             redef_struct = NULL;

	mov	QWORD PTR redef_struct, 0
$LN31@EndstructD:

; 493  :         }
; 494  :     } else {

	jmp	SHORT $LN30@EndstructD
$LN29@EndstructD:

; 495  : 
; 496  :         if ( dir->sym.max_mbr_size > CurrStruct->sym.max_mbr_size )

	mov	rax, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR [rcx+48]
	cmp	DWORD PTR [rax+48], ecx
	jbe	SHORT $LN33@EndstructD

; 497  :             CurrStruct->sym.max_mbr_size = dir->sym.max_mbr_size;

	mov	rax, QWORD PTR CurrStruct
	mov	rcx, QWORD PTR dir$[rsp]
	mov	ecx, DWORD PTR [rcx+48]
	mov	DWORD PTR [rax+48], ecx
$LN33@EndstructD:

; 498  : 
; 499  :         UpdateStructSize( (struct asym *)dir );

	mov	rcx, QWORD PTR dir$[rsp]
	call	UpdateStructSize

; 500  :         DebugMsg1(("EndstructDirective: new size of restored structure=%u\n", CurrStruct->sym.total_size));

	mov	rax, QWORD PTR CurrStruct
	mov	edx, DWORD PTR [rax+56]
	lea	rcx, OFFSET FLAT:$SG11272
	call	DoDebugMsg1
$LN30@EndstructD:

; 501  :     }
; 502  :     //dir->sym.max_mbr_size = 0;
; 503  :     if (dir->sym.state == SYM_TYPE)

	mov	rax, QWORD PTR dir$[rsp]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN34@EndstructD

; 504  :     {  
; 505  :            dir->e.structinfo->isHomogenous = 0;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rax+20], 0

; 506  :            SymSimd(dir);

	mov	rcx, QWORD PTR dir$[rsp]
	call	SymSimd
$LN34@EndstructD:

; 507  :     }
; 508  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN35@EndstructD

; 509  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@EndstructD
$LN35@EndstructD:

; 510  :     }
; 511  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@EndstructD:

; 512  : }

	add	rsp, 120				; 00000078H
	ret	0
EndstructDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
sym$ = 48
typekind$ = 56
name$ = 64
dir$ = 72
power$1 = 80
alignment$ = 84
tv315 = 88
tv69 = 92
tv306 = 96
tv393 = 100
tv269 = 104
tv279 = 108
tv73 = 112
offset$ = 120
opndx$2 = 128
i$ = 256
tokenarray$ = 264
StructDirective PROC

; 169  : {

$LN61:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 248				; 000000f8H

; 170  :     char *name;
; 171  :     unsigned alignment;
; 172  :     uint_32 offset;
; 173  :     uint_8 typekind = ( tokenarray[i].tokval == T_UNION ? TYPE_UNION : TYPE_STRUCT );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 424		; 000001a8H
	jne	SHORT $LN51@StructDire
	mov	DWORD PTR tv69[rsp], 2
	jmp	SHORT $LN52@StructDire
$LN51@StructDire:
	mov	DWORD PTR tv69[rsp], 1
$LN52@StructDire:
	movzx	eax, BYTE PTR tv69[rsp]
	mov	BYTE PTR typekind$[rsp], al

; 174  :     //unsigned int size;
; 175  :     struct asym *sym;
; 176  :     struct dsym *dir;
; 177  : 
; 178  :     DebugMsg1(("StructDirective(%s) enter, i=%u, CurrStruct=%s\n", tokenarray[i].string_ptr, i, CurrStruct ? CurrStruct->sym.name : "NULL" ));

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN53@StructDire
	mov	rax, QWORD PTR CurrStruct
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv73[rsp], rax
	jmp	SHORT $LN54@StructDire
$LN53@StructDire:
	lea	rax, OFFSET FLAT:$SG11160
	mov	QWORD PTR tv73[rsp], rax
$LN54@StructDire:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r9, QWORD PTR tv73[rsp]
	mov	r8d, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11161
	call	DoDebugMsg1

; 179  : 
; 180  :     /* top level structs/unions must have an identifier at pos 0.
; 181  :      * for embedded structs, the directive must be at pos 0,
; 182  :      * an identifier is optional then.
; 183  :      */
; 184  :     if (( CurrStruct == NULL && i != 1 ) ||

	cmp	QWORD PTR CurrStruct, 0
	jne	SHORT $LN9@StructDire
	cmp	DWORD PTR i$[rsp], 1
	jne	SHORT $LN8@StructDire
$LN9@StructDire:
	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN7@StructDire
	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN7@StructDire
$LN8@StructDire:

; 185  :         ( CurrStruct != NULL && i != 0 ) ) {
; 186  :         DebugMsg(("StructDirective(%s): error: either currstruct or i must be 0\n", tokenarray[i].string_ptr ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11165
	call	DoDebugMsg

; 187  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@StructDire
$LN7@StructDire:

; 188  :     }
; 189  : 
; 190  :     alignment = ( 1 << ModuleInfo.fieldalign );

	movzx	eax, BYTE PTR ModuleInfo+397
	mov	ecx, 1
	mov	DWORD PTR tv393[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv393[rsp]
	shl	eax, cl
	mov	DWORD PTR alignment$[rsp], eax

; 191  : 
; 192  :     i++; /* go past STRUCT/UNION */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 193  : 
; 194  :     if ( i == 1 ) { /* embedded struct? */

	cmp	DWORD PTR i$[rsp], 1
	jne	SHORT $LN10@StructDire

; 195  :         /* scan for the optional name */
; 196  : #if ANYNAME
; 197  :         /* the name might be a reserved word!
; 198  :          * Masm won't allow those.
; 199  :          */
; 200  :         //if ( tokenarray[i].token != T_FINAL && is_valid_id_first_char(*(tokenarray[i].string_ptr) ) ) {
; 201  : #else
; 202  :         if ( tokenarray[i].token == T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN12@StructDire

; 203  : #endif
; 204  :             name = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR name$[rsp], rax

; 205  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 206  :         } else {

	jmp	SHORT $LN13@StructDire
$LN12@StructDire:

; 207  :             name = "";

	lea	rax, OFFSET FLAT:$SG11170
	mov	QWORD PTR name$[rsp], rax
$LN13@StructDire:

; 208  :         }
; 209  :     } else {

	jmp	SHORT $LN11@StructDire
$LN10@StructDire:

; 210  :         name = tokenarray[0].string_ptr;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR name$[rsp], rax
$LN11@StructDire:

; 211  :     }
; 212  : 
; 213  :     /* get an optional alignment argument: 1,2,4,8,16 or 32 */
; 214  :     if ( CurrStruct == NULL && tokenarray[i].token != T_FINAL ) {

	cmp	QWORD PTR CurrStruct, 0
	jne	$LN14@StructDire
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN14@StructDire

; 215  :         int power;
; 216  :         struct expr opndx;
; 217  :         /* get the optional alignment parameter.
; 218  :          * forward references aren't accepted, but EXPF_NOUNDEF isn't used here!
; 219  :          */
; 220  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) != ERROR ) {

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$2[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	je	$LN15@StructDire

; 221  :             /* an empty expression is accepted */
; 222  :             if ( opndx.kind == EXPR_EMPTY ) {

	cmp	DWORD PTR opndx$2[rsp+60], -2
	jne	SHORT $LN16@StructDire
	jmp	$LN17@StructDire
$LN16@StructDire:

; 223  :                 ;
; 224  :             } else if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$2[rsp+60], 0
	je	SHORT $LN18@StructDire

; 225  :                 /* v2.09: better error msg */
; 226  :                 if ( opndx.sym && opndx.sym->state == SYM_UNDEFINED )

	cmp	QWORD PTR opndx$2[rsp+80], 0
	je	SHORT $LN20@StructDire
	mov	rax, QWORD PTR opndx$2[rsp+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN20@StructDire

; 227  :                     EmitErr( SYMBOL_NOT_DEFINED, opndx.sym->name );

	mov	rax, QWORD PTR opndx$2[rsp+80]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr
	jmp	SHORT $LN21@StructDire
$LN20@StructDire:

; 228  :                 else
; 229  :                     EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError
$LN21@StructDire:

; 230  :             } else if( opndx.value > MAX_STRUCT_ALIGN ) {

	jmp	SHORT $LN19@StructDire
$LN18@StructDire:
	cmp	DWORD PTR opndx$2[rsp], 32		; 00000020H
	jle	SHORT $LN22@StructDire

; 231  :                 EmitError( STRUCT_ALIGN_TOO_HIGH );

	mov	ecx, 214				; 000000d6H
	call	EmitError

; 232  :             } else {

	jmp	SHORT $LN23@StructDire
$LN22@StructDire:

; 233  :                 for( power = 1; power < opndx.value; power <<= 1 );

	mov	DWORD PTR power$1[rsp], 1
	jmp	SHORT $LN4@StructDire
$LN2@StructDire:
	mov	eax, DWORD PTR power$1[rsp]
	shl	eax, 1
	mov	DWORD PTR power$1[rsp], eax
$LN4@StructDire:
	mov	eax, DWORD PTR opndx$2[rsp]
	cmp	DWORD PTR power$1[rsp], eax
	jge	SHORT $LN3@StructDire
	jmp	SHORT $LN2@StructDire
$LN3@StructDire:

; 234  :                 if( power != opndx.value ) {

	mov	eax, DWORD PTR opndx$2[rsp]
	cmp	DWORD PTR power$1[rsp], eax
	je	SHORT $LN24@StructDire

; 235  :                     EmitErr( POWER_OF_2, opndx.value );

	mov	edx, DWORD PTR opndx$2[rsp]
	mov	ecx, 129				; 00000081H
	call	EmitErr

; 236  :                 } else

	jmp	SHORT $LN25@StructDire
$LN24@StructDire:

; 237  :                     alignment = opndx.value;

	mov	eax, DWORD PTR opndx$2[rsp]
	mov	DWORD PTR alignment$[rsp], eax
$LN25@StructDire:
$LN23@StructDire:
$LN19@StructDire:
$LN17@StructDire:

; 238  :             }
; 239  :             DebugMsg1(("StructDirective(%s) alignment=%u\n", name, alignment));

	mov	r8d, DWORD PTR alignment$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11183
	call	DoDebugMsg1
$LN15@StructDire:

; 240  :         }
; 241  :         /* there might also be the NONUNIQUE parameter */
; 242  :         if ( tokenarray[i].token == T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN26@StructDire

; 243  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 244  :             if ( tokenarray[i].token == T_ID &&

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN27@StructDire
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:szNonUnique
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN27@StructDire

; 245  :                 (_stricmp( tokenarray[i].string_ptr, szNonUnique ) == 0 ) ) {
; 246  :                 /* currently NONUNIQUE is ignored */
; 247  :                 EmitWarn( 2, TOKEN_IGNORED, szNonUnique );

	lea	r8, OFFSET FLAT:szNonUnique
	mov	edx, 250				; 000000faH
	mov	ecx, 2
	call	EmitWarn

; 248  :                 i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN27@StructDire:
$LN26@StructDire:
$LN14@StructDire:

; 249  :             }
; 250  :         }
; 251  :     }
; 252  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN28@StructDire

; 253  :         DebugMsg(("StructDirective(%s): error: unexpected token %u >%s<\n", tokenarray[i].token, tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rdx+rax+24]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG11187
	call	DoDebugMsg

; 254  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@StructDire
$LN28@StructDire:

; 255  :     }
; 256  : 
; 257  :     /* does struct have a name? */
; 258  :     if ( *name ) {

	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN29@StructDire

; 259  :         if ( CurrStruct == NULL ) {

	cmp	QWORD PTR CurrStruct, 0
	jne	SHORT $LN31@StructDire

; 260  :             /* the "top-level" struct is part of the global namespace */
; 261  :             sym = SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 262  :             DebugMsg1(("StructDirective: SymSearch (%s)=%X (curr struct=%X)\n", name, sym, CurrStruct ));

	mov	r9, QWORD PTR CurrStruct
	mov	r8, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11192
	call	DoDebugMsg1

; 263  :         } else {

	jmp	SHORT $LN32@StructDire
$LN31@StructDire:

; 264  :             sym = SearchNameInStruct( (struct asym *)CurrStruct, name, &offset, 0 );

	xor	r9d, r9d
	lea	r8, QWORD PTR offset$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR CurrStruct
	call	SearchNameInStruct
	mov	QWORD PTR sym$[rsp], rax

; 265  :             DebugMsg1(("StructDirective(%s): SearchNameInStruc()=%X\n", name, sym));

	mov	r8, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11193
	call	DoDebugMsg1
$LN32@StructDire:

; 266  :         }
; 267  :     } else {

	jmp	SHORT $LN30@StructDire
$LN29@StructDire:

; 268  :         sym = NULL;   /* anonymous struct */

	mov	QWORD PTR sym$[rsp], 0
$LN30@StructDire:

; 269  :     }
; 270  : 
; 271  :     if ( ModuleInfo.list ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN33@StructDire

; 272  :         if ( CurrStruct )

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN34@StructDire

; 273  :             LstWrite( LSTTYPE_STRUCT, CurrStruct->sym.total_size, NULL );

	xor	r8d, r8d
	mov	rax, QWORD PTR CurrStruct
	mov	edx, DWORD PTR [rax+56]
	mov	ecx, 6
	call	LstWrite
	jmp	SHORT $LN35@StructDire
$LN34@StructDire:

; 274  :         else
; 275  :             LstWrite( LSTTYPE_STRUCT, 0, NULL );

	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, 6
	call	LstWrite
$LN35@StructDire:
$LN33@StructDire:

; 276  :     }
; 277  : 
; 278  :     /* if pass is > 1, update struct stack + CurrStruct.offset and exit */
; 279  :     if ( Parse_Pass > PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jbe	$LN36@StructDire

; 280  :         /* v2.04 changed. the previous implementation was insecure.
; 281  :          * See also change in data.c, behind CreateStructField().
; 282  :          */
; 283  :         if ( CurrStruct ) {

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN37@StructDire

; 284  :             sym = CurrStruct->e.structinfo->tail->sym.type;

	mov	rax, QWORD PTR CurrStruct
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym$[rsp], rax

; 285  :             /**/myassert( sym );

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN55@StructDire
	mov	DWORD PTR tv269[rsp], 0
	jmp	SHORT $LN56@StructDire
$LN55@StructDire:
	mov	edx, 285				; 0000011dH
	lea	rcx, OFFSET FLAT:$SG11199
	call	InternalError
	mov	DWORD PTR tv269[rsp], eax
$LN56@StructDire:

; 286  :             CurrStruct->e.structinfo->tail = CurrStruct->e.structinfo->tail->next;

	mov	rax, QWORD PTR CurrStruct
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR CurrStruct
	mov	rcx, QWORD PTR [rcx+96]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rcx+8], rax
$LN37@StructDire:

; 287  :         }
; 288  :         /**/myassert( sym );

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN57@StructDire
	mov	DWORD PTR tv279[rsp], 0
	jmp	SHORT $LN58@StructDire
$LN57@StructDire:
	mov	edx, 288				; 00000120H
	lea	rcx, OFFSET FLAT:$SG11200
	call	InternalError
	mov	DWORD PTR tv279[rsp], eax
$LN58@StructDire:

; 289  :         dir = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR dir$[rsp], rax

; 290  :         dir->e.structinfo->tail = dir->e.structinfo->head;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx+8], rax

; 291  :         sym->offset = 0;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+16], 0

; 292  :         sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 293  :         ((struct dsym *)sym)->next = CurrStruct;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR CurrStruct
	mov	QWORD PTR [rax+104], rcx

; 294  :         CurrStruct = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR CurrStruct, rax

; 295  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@StructDire
$LN36@StructDire:

; 296  :     }
; 297  : 
; 298  :     if( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN38@StructDire

; 299  : 
; 300  :         /* embedded or global STRUCT? */
; 301  :         if ( CurrStruct == NULL )

	cmp	QWORD PTR CurrStruct, 0
	jne	SHORT $LN40@StructDire

; 302  :             sym = CreateTypeSymbol( NULL, name, TRUE );

	mov	r8b, 1
	mov	rdx, QWORD PTR name$[rsp]
	xor	ecx, ecx
	call	CreateTypeSymbol
	mov	QWORD PTR sym$[rsp], rax
	jmp	SHORT $LN41@StructDire
$LN40@StructDire:

; 303  :         else {
; 304  :             /* an embedded struct is split in an anonymous STRUCT type
; 305  :              * and a struct field with/without name
; 306  :              */
; 307  :             sym = CreateTypeSymbol( NULL, name, FALSE );

	xor	r8d, r8d
	mov	rdx, QWORD PTR name$[rsp]
	xor	ecx, ecx
	call	CreateTypeSymbol
	mov	QWORD PTR sym$[rsp], rax

; 308  :             /* v2: don't create the struct field here. First the
; 309  :              * structure must be read in ( because of alignment issues
; 310  :              */
; 311  :             // sym = CreateStructField( name_loc, -1, MT_TYPE, dir, 0 );
; 312  : 
; 313  :             alignment = CurrStruct->e.structinfo->alignment;

	mov	rax, QWORD PTR CurrStruct
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+28]
	mov	DWORD PTR alignment$[rsp], eax
$LN41@StructDire:

; 314  :         }

	jmp	$LN39@StructDire
$LN38@StructDire:

; 315  : 
; 316  :     } else if( sym->state == SYM_UNDEFINED ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN42@StructDire

; 317  : 
; 318  :         /* forward reference */
; 319  :         CreateTypeSymbol( sym, NULL, CurrStruct == NULL );

	cmp	QWORD PTR CurrStruct, 0
	jne	SHORT $LN59@StructDire
	mov	DWORD PTR tv306[rsp], 1
	jmp	SHORT $LN60@StructDire
$LN59@StructDire:
	mov	DWORD PTR tv306[rsp], 0
$LN60@StructDire:
	movzx	r8d, BYTE PTR tv306[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateTypeSymbol
	jmp	$LN43@StructDire
$LN42@StructDire:

; 320  : 
; 321  :     } else if( sym->state == SYM_TYPE && CurrStruct == NULL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN44@StructDire
	cmp	QWORD PTR CurrStruct, 0
	jne	SHORT $LN44@StructDire

; 322  : 
; 323  :         switch ( sym->typekind ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	mov	BYTE PTR tv315[rsp], al
	cmp	BYTE PTR tv315[rsp], 0
	je	SHORT $LN47@StructDire
	cmp	BYTE PTR tv315[rsp], 0
	jbe	SHORT $LN48@StructDire
	cmp	BYTE PTR tv315[rsp], 2
	jbe	SHORT $LN46@StructDire
	jmp	SHORT $LN48@StructDire
$LN46@StructDire:

; 324  :         case TYPE_STRUCT:
; 325  :         case TYPE_UNION:
; 326  :             /* if a struct is redefined as a union ( or vice versa )
; 327  :              * do accept the directive and just check if the redefinition
; 328  :              * is compatible (usually it isn't) */
; 329  :             redef_struct = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR redef_struct, rax

; 330  :             sym = CreateTypeSymbol( NULL, name, FALSE );

	xor	r8d, r8d
	mov	rdx, QWORD PTR name$[rsp]
	xor	ecx, ecx
	call	CreateTypeSymbol
	mov	QWORD PTR sym$[rsp], rax

; 331  :             break;

	jmp	SHORT $LN5@StructDire
$LN47@StructDire:

; 332  :         case TYPE_NONE:  /* TYPE_NONE is forward reference */
; 333  :             break;

	jmp	SHORT $LN5@StructDire
$LN48@StructDire:

; 334  :         default:
; 335  :             return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@StructDire
$LN5@StructDire:

; 336  :         }
; 337  : 
; 338  :     } else {

	jmp	SHORT $LN45@StructDire
$LN44@StructDire:

; 339  :         return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@StructDire
$LN45@StructDire:
$LN43@StructDire:
$LN39@StructDire:

; 340  :     }
; 341  : 
; 342  :     sym->offset = 0;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+16], 0

; 343  :     sym->typekind = typekind;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR typekind$[rsp]
	mov	BYTE PTR [rax+66], cl

; 344  :     dir = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR dir$[rsp], rax

; 345  :     dir->e.structinfo->alignment = alignment;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	ecx, BYTE PTR alignment$[rsp]
	mov	BYTE PTR [rax+28], cl

; 346  :     dir->e.structinfo->isOpen = TRUE;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+29]
	or	al, 2
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+29], al

; 347  :     if ( CurrStruct )

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN49@StructDire

; 348  :         dir->e.structinfo->isInline = TRUE;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+29]
	or	al, 1
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+29], al
$LN49@StructDire:

; 349  : 
; 350  :     dir->next = CurrStruct;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR CurrStruct
	mov	QWORD PTR [rax+104], rcx

; 351  :     CurrStruct = dir;

	mov	rax, QWORD PTR dir$[rsp]
	mov	QWORD PTR CurrStruct, rax

; 352  : 
; 353  : #if 0 //def DEBUG_OUT
; 354  :     {
; 355  :         struct dsym *struc;
; 356  :         for ( struc = CurrStruct; struc; struc = struc->next ) {
; 357  :             DebugMsg(("StructDirective stack: %X, name=>%s<\n", struc, struc->sym.name ));
; 358  :         }
; 359  :     }
; 360  : #endif
; 361  : 
; 362  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@StructDire:

; 363  : }

	add	rsp, 248				; 000000f8H
	ret	0
StructDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
fnew$ = 32
fold$ = 40
newstr$ = 64
oldstr$ = 72
AreStructsEqual PROC

; 128  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 129  :     struct sfield *fold = oldstr->e.structinfo->head;

	mov	rax, QWORD PTR oldstr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR fold$[rsp], rax

; 130  :     struct sfield *fnew = newstr->e.structinfo->head;

	mov	rax, QWORD PTR newstr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR fnew$[rsp], rax

; 131  : 
; 132  :     DebugMsg(("AreStructsEqual(%s) enter\n", oldstr->sym.name ));

	mov	rax, QWORD PTR oldstr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11105
	call	DoDebugMsg

; 133  : 
; 134  :     /* kind of structs must be identical */
; 135  :     if ( oldstr->sym.typekind != newstr->sym.typekind )

	mov	rax, QWORD PTR oldstr$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	mov	rcx, QWORD PTR newstr$[rsp]
	movzx	ecx, BYTE PTR [rcx+66]
	cmp	eax, ecx
	je	SHORT $LN5@AreStructs

; 136  :         return( FALSE );

	xor	al, al
	jmp	$LN1@AreStructs
$LN5@AreStructs:

; 137  : 
; 138  :     for ( ; fold; fold = fold->next, fnew = fnew->next ) {

	jmp	SHORT $LN4@AreStructs
$LN2@AreStructs:
	mov	rax, QWORD PTR fold$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR fold$[rsp], rax
	mov	rax, QWORD PTR fnew$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR fnew$[rsp], rax
$LN4@AreStructs:
	cmp	QWORD PTR fold$[rsp], 0
	je	$LN3@AreStructs

; 139  :         if ( !fnew ) {

	cmp	QWORD PTR fnew$[rsp], 0
	jne	SHORT $LN6@AreStructs

; 140  :             DebugMsg(("AreStructsEqual: fields don't match\n"));

	lea	rcx, OFFSET FLAT:$SG11108
	call	DoDebugMsg

; 141  :             return( FALSE );

	xor	al, al
	jmp	$LN1@AreStructs
$LN6@AreStructs:

; 142  :         }
; 143  :         /* for global member names, don't check the name if it's "" */
; 144  :         if ( ModuleInfo.oldstructs && *fnew->sym.name == NULLC )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 8
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@AreStructs
	mov	rax, QWORD PTR fnew$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN7@AreStructs

; 145  :             ;

	jmp	SHORT $LN8@AreStructs
$LN7@AreStructs:

; 146  :         else if ( 0 != strcmp( fold->sym.name, fnew->sym.name ) ) {

	mov	rax, QWORD PTR fnew$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR fold$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	strcmp
	test	eax, eax
	je	SHORT $LN9@AreStructs

; 147  :             DebugMsg(("AreStructsEqual: type name of field changed\n"));

	lea	rcx, OFFSET FLAT:$SG11112
	call	DoDebugMsg

; 148  :             return( FALSE );

	xor	al, al
	jmp	SHORT $LN1@AreStructs
$LN9@AreStructs:
$LN8@AreStructs:

; 149  :         }
; 150  :         if ( fold->sym.offset != fnew->sym.offset ) {

	mov	rax, QWORD PTR fold$[rsp]
	mov	rcx, QWORD PTR fnew$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	cmp	DWORD PTR [rax+16], ecx
	je	SHORT $LN10@AreStructs

; 151  :             DebugMsg(("AreStructsEqual: offset of field %s changed: %u - %u\n", fold->sym.name, fold->sym.offset, fnew->sym.offset));

	mov	rax, QWORD PTR fnew$[rsp]
	mov	r9d, DWORD PTR [rax+16]
	mov	rax, QWORD PTR fold$[rsp]
	mov	r8d, DWORD PTR [rax+16]
	mov	rax, QWORD PTR fold$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11114
	call	DoDebugMsg

; 152  :             return( FALSE );

	xor	al, al
	jmp	SHORT $LN1@AreStructs
$LN10@AreStructs:

; 153  :         }
; 154  :         if ( fold->sym.total_size != fnew->sym.total_size ) {

	mov	rax, QWORD PTR fold$[rsp]
	mov	rcx, QWORD PTR fnew$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	cmp	DWORD PTR [rax+56], ecx
	je	SHORT $LN11@AreStructs

; 155  :             DebugMsg(("AreStructsEqual: total_size of field changed\n"));

	lea	rcx, OFFSET FLAT:$SG11116
	call	DoDebugMsg

; 156  :             return( FALSE );

	xor	al, al
	jmp	SHORT $LN1@AreStructs
$LN11@AreStructs:

; 157  :         }
; 158  :     }

	jmp	$LN2@AreStructs
$LN3@AreStructs:

; 159  :     if ( fnew )

	cmp	QWORD PTR fnew$[rsp], 0
	je	SHORT $LN12@AreStructs

; 160  :         return( FALSE );

	xor	al, al
	jmp	SHORT $LN1@AreStructs
$LN12@AreStructs:

; 161  :     return( TRUE );

	mov	al, 1
$LN1@AreStructs:

; 162  : }

	add	rsp, 56					; 00000038H
	ret	0
AreStructsEqual ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
curr$ = 32
next$ = 40
dir$ = 64
DeleteType PROC

; 1318 : {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1319 :     struct sfield      *curr;
; 1320 :     struct sfield      *next;
; 1321 : 
; 1322 :     DebugMsg(("DeleteType(%s) enter, typekind=%u, memtype=%Xh\n", dir->sym.name, dir->sym.typekind, dir->sym.mem_type ));

	mov	rax, QWORD PTR dir$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	mov	rcx, QWORD PTR dir$[rsp]
	mov	r9d, DWORD PTR [rcx+36]
	mov	r8d, eax
	mov	rax, QWORD PTR dir$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11641
	call	DoDebugMsg

; 1323 : #if FASTMEM==0
; 1324 :     /* release prototype in target_type if typedef is PROTO */
; 1325 :     if ( dir->sym.mem_type == MT_PROC ) {
; 1326 :         /* v2.11: change the prototype type to an external, because SymFree()
; 1327 :          * doesn't expect a prototype in a type.
; 1328 :          */
; 1329 :         dir->sym.target_type->state = SYM_EXTERNAL;
; 1330 :         SymFree( dir->sym.target_type );
; 1331 :     }
; 1332 : #endif
; 1333 : #if TYPEOPT
; 1334 :     if ( dir->sym.typekind == TYPE_TYPEDEF )
; 1335 :         return;
; 1336 : #endif
; 1337 :     /* bitfields field names are global, don't free them here! */
; 1338 :     if ( dir->sym.typekind != TYPE_RECORD )

	mov	rax, QWORD PTR dir$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 4
	je	SHORT $LN5@DeleteType

; 1339 :         for( curr = dir->e.structinfo->head; curr != NULL; curr = next ) {

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@DeleteType
$LN2@DeleteType:
	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR curr$[rsp], rax
$LN4@DeleteType:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@DeleteType

; 1340 :             next = curr->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR next$[rsp], rax

; 1341 : #if FASTMEM==0
; 1342 :             if ( curr->sym.name_size ) LclFree( curr->sym.name );
; 1343 : #endif
; 1344 :             LclFree( curr );
; 1345 :         }

	jmp	SHORT $LN2@DeleteType
$LN3@DeleteType:
$LN5@DeleteType:

; 1346 :     LclFree( dir->e.structinfo );
; 1347 :     return;
; 1348 : }

	add	rsp, 56					; 00000038H
	ret	0
DeleteType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
TypesInit PROC

; 49   :     CurrStruct   = NULL;

	mov	QWORD PTR CurrStruct, 0

; 50   :     redef_struct = NULL;

	mov	QWORD PTR redef_struct, 0

; 51   : }

	ret	0
TypesInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
offset$1 = 0
value$ = 32
AlignInStruct PROC

; 748  : {

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 749  :     if ( CurrStruct->sym.typekind != TYPE_UNION ) {

	mov	rax, QWORD PTR CurrStruct
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	je	SHORT $LN2@AlignInStr

; 750  :         int offset;
; 751  :         offset = CurrStruct->sym.offset;

	mov	rax, QWORD PTR CurrStruct
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR offset$1[rsp], eax

; 752  :         offset = (offset + (value - 1)) & (-value);

	mov	eax, DWORD PTR offset$1[rsp]
	mov	ecx, DWORD PTR value$[rsp]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	ecx, DWORD PTR value$[rsp]
	neg	ecx
	and	eax, ecx
	mov	DWORD PTR offset$1[rsp], eax

; 753  :         CurrStruct->sym.offset = offset;

	mov	rax, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR offset$1[rsp]
	mov	DWORD PTR [rax+16], ecx

; 754  :         if ( offset > CurrStruct->sym.total_size )

	mov	rax, QWORD PTR CurrStruct
	mov	eax, DWORD PTR [rax+56]
	cmp	DWORD PTR offset$1[rsp], eax
	jbe	SHORT $LN3@AlignInStr

; 755  :             CurrStruct->sym.total_size = offset;

	mov	rax, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR offset$1[rsp]
	mov	DWORD PTR [rax+56], ecx
$LN3@AlignInStr:
$LN2@AlignInStr:

; 756  :     }
; 757  :     return( NOT_ERROR );

	xor	eax, eax

; 758  : }

	add	rsp, 24
	ret	0
AlignInStruct ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
offset$ = 48
SetStructCurrentOffset PROC

; 788  : {

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 789  :     if ( CurrStruct->sym.typekind == TYPE_UNION ) {

	mov	rax, QWORD PTR CurrStruct
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	jne	SHORT $LN2@SetStructC

; 790  :         return( EmitError( ORG_NOT_ALLOWED_IN_UNIONS ) );

	mov	ecx, 213				; 000000d5H
	call	EmitError
	jmp	SHORT $LN1@SetStructC
$LN2@SetStructC:

; 791  :     }
; 792  :     CurrStruct->sym.offset = offset;

	mov	rax, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 793  :     /* if an ORG is inside the struct, it cannot be instanced anymore */
; 794  :     CurrStruct->e.structinfo->OrgInside = TRUE;

	mov	rax, QWORD PTR CurrStruct
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+29]
	or	al, 4
	mov	rcx, QWORD PTR CurrStruct
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+29], al

; 795  :     if ( offset > (int_32)CurrStruct->sym.total_size )

	mov	rax, QWORD PTR CurrStruct
	mov	eax, DWORD PTR [rax+56]
	cmp	DWORD PTR offset$[rsp], eax
	jle	SHORT $LN3@SetStructC

; 796  :         CurrStruct->sym.total_size = offset;

	mov	rax, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rax+56], ecx
$LN3@SetStructC:

; 797  : 
; 798  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetStructC:

; 799  : }

	add	rsp, 40					; 00000028H
	ret	0
SetStructCurrentOffset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
tv88 = 48
sym$ = 80
UpdateStructSize PROC

; 764  : {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 765  :     if ( CurrStruct->sym.typekind == TYPE_UNION ) {

	mov	rax, QWORD PTR CurrStruct
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	jne	SHORT $LN2@UpdateStru

; 766  :         //if ( no_of_bytes > CurrStruct->sym.total_size )
; 767  :         //    CurrStruct->sym.total_size = no_of_bytes;
; 768  :         if ( sym->total_size > CurrStruct->sym.total_size )

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR [rcx+56]
	cmp	DWORD PTR [rax+56], ecx
	jbe	SHORT $LN4@UpdateStru

; 769  :             CurrStruct->sym.total_size = sym->total_size;

	mov	rax, QWORD PTR CurrStruct
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax+56], ecx
$LN4@UpdateStru:

; 770  :     } else {

	jmp	SHORT $LN3@UpdateStru
$LN2@UpdateStru:

; 771  :         CurrStruct->sym.offset += sym->total_size;

	mov	rax, QWORD PTR CurrStruct
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR sym$[rsp]
	add	eax, DWORD PTR [rcx+56]
	mov	rcx, QWORD PTR CurrStruct
	mov	DWORD PTR [rcx+16], eax

; 772  :         if ( CurrStruct->sym.offset > (int_32)CurrStruct->sym.total_size )

	mov	rax, QWORD PTR CurrStruct
	mov	rcx, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR [rcx+56]
	cmp	DWORD PTR [rax+16], ecx
	jle	SHORT $LN5@UpdateStru

; 773  :             CurrStruct->sym.total_size = CurrStruct->sym.offset;

	mov	rax, QWORD PTR CurrStruct
	mov	rcx, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax+56], ecx
$LN5@UpdateStru:
$LN3@UpdateStru:

; 774  :     }
; 775  :     DebugMsg1(("UpdateStructSize(%s.%s): %s, curr mbr size=%u curr struc/union size=%u\n",

	mov	rax, QWORD PTR CurrStruct
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	jne	SHORT $LN7@UpdateStru
	lea	rax, OFFSET FLAT:$SG11387
	mov	QWORD PTR tv88[rsp], rax
	jmp	SHORT $LN8@UpdateStru
$LN7@UpdateStru:
	lea	rax, OFFSET FLAT:$SG11388
	mov	QWORD PTR tv88[rsp], rax
$LN8@UpdateStru:
	mov	rax, QWORD PTR CurrStruct
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR tv88[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR CurrStruct
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11389
	call	DoDebugMsg1

; 776  :                CurrStruct->sym.name,
; 777  :                sym->name,
; 778  :                CurrStruct->sym.typekind == TYPE_UNION ? "union" : "struct",
; 779  :                sym->total_size,
; 780  :                CurrStruct->sym.total_size));
; 781  :     return;
; 782  : }

	add	rsp, 72					; 00000048H
	ret	0
UpdateStructSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
f$ = 48
offset$ = 56
i$ = 60
len$ = 64
init$ = 72
si$ = 80
gsym$ = 88
sym2$1 = 96
tv174 = 104
dir$2 = 112
tv69 = 120
tv73 = 128
sym$3 = 136
disp$ = 144
loc$ = 176
tokenarray$ = 184
name$ = 192
mem_type$ = 200
vartype$ = 208
size$ = 216
CreateStructField PROC

; 551  : {

$LN42:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 168				; 000000a8H

; 552  :     int_32 offset;
; 553  :     //int count;
; 554  :     int i;
; 555  :     int len;
; 556  :     uint_32 disp;
; 557  :     char *init;
; 558  :     struct struct_info *si;
; 559  :     struct sfield *f;
; 560  :     struct asym  *gsym;
; 561  : 
; 562  :     si = CurrStruct->e.structinfo;

	mov	rax, QWORD PTR CurrStruct
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR si$[rsp], rax

; 563  :     offset = CurrStruct->sym.offset;

	mov	rax, QWORD PTR CurrStruct
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR offset$[rsp], eax

; 564  : 
; 565  :     DebugMsg1(("CreateStructField(%s): name=%s, curr ofs=%" I32_SPEC "u, vartype=%s, size=%" I32_SPEC "u\n",

	cmp	QWORD PTR vartype$[rsp], 0
	je	SHORT $LN36@CreateStru
	mov	rax, QWORD PTR vartype$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN37@CreateStru
$LN36@CreateStru:
	lea	rax, OFFSET FLAT:$SG11336
	mov	QWORD PTR tv69[rsp], rax
$LN37@CreateStru:
	cmp	QWORD PTR name$[rsp], 0
	je	SHORT $LN38@CreateStru
	mov	rax, QWORD PTR name$[rsp]
	mov	QWORD PTR tv73[rsp], rax
	jmp	SHORT $LN39@CreateStru
$LN38@CreateStru:
	lea	rax, OFFSET FLAT:$SG11337
	mov	QWORD PTR tv73[rsp], rax
$LN39@CreateStru:
	mov	eax, DWORD PTR size$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR tv69[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR offset$[rsp]
	mov	r8, QWORD PTR tv73[rsp]
	mov	rax, QWORD PTR CurrStruct
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11338
	call	DoDebugMsg1

; 566  :                CurrStruct->sym.name, name ? name : "<anonymous>", offset,
; 567  :                vartype ? vartype->name : "NULL", size ));
; 568  : 
; 569  :     if ( name ) {

	cmp	QWORD PTR name$[rsp], 0
	je	SHORT $LN8@CreateStru

; 570  :         struct asym  *sym;
; 571  :         len = strlen( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 572  :         if( len > MAX_ID_LEN ) {

	cmp	DWORD PTR len$[rsp], 247		; 000000f7H
	jle	SHORT $LN10@CreateStru

; 573  :             EmitError( IDENTIFIER_TOO_LONG );

	mov	ecx, 70					; 00000046H
	call	EmitError

; 574  :             return( NULL );

	xor	eax, eax
	jmp	$LN1@CreateStru
$LN10@CreateStru:

; 575  :         }
; 576  :         sym = SearchNameInStruct((struct asym *)CurrStruct, name, &disp, 0 );

	xor	r9d, r9d
	lea	r8, QWORD PTR disp$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR CurrStruct
	call	SearchNameInStruct
	mov	QWORD PTR sym$3[rsp], rax

; 577  :         if ( sym ) {

	cmp	QWORD PTR sym$3[rsp], 0
	je	SHORT $LN11@CreateStru

; 578  :             EmitErr( SYMBOL_ALREADY_DEFINED, sym->name );

	mov	rax, QWORD PTR sym$3[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 579  :             return( NULL );

	xor	eax, eax
	jmp	$LN1@CreateStru
$LN11@CreateStru:

; 580  :         }
; 581  :     } else {

	jmp	SHORT $LN9@CreateStru
$LN8@CreateStru:

; 582  :         /* v2.06: check fields of anonymous struct member */
; 583  :         if ( vartype &&

	cmp	QWORD PTR vartype$[rsp], 0
	je	SHORT $LN12@CreateStru
	mov	rax, QWORD PTR vartype$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 1
	je	SHORT $LN13@CreateStru
	mov	rax, QWORD PTR vartype$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	jne	SHORT $LN12@CreateStru
$LN13@CreateStru:

; 584  :             ( vartype->typekind == TYPE_STRUCT ||
; 585  :              vartype->typekind == TYPE_UNION ) ) {
; 586  :             CheckAnonymousStruct( (struct dsym *)vartype );

	mov	rcx, QWORD PTR vartype$[rsp]
	call	CheckAnonymousStruct
$LN12@CreateStru:

; 587  :         }
; 588  :         name = "";

	lea	rax, OFFSET FLAT:$SG11345
	mov	QWORD PTR name$[rsp], rax

; 589  :         len = 0;

	mov	DWORD PTR len$[rsp], 0
$LN9@CreateStru:

; 590  :     }
; 591  : 
; 592  :     if ( loc != -1 ) {

	cmp	DWORD PTR loc$[rsp], -1
	je	$LN14@CreateStru

; 593  : 
; 594  :         //i = strlen( tokenarray[loc].string_ptr ) + 1;
; 595  :         //DebugMsg1(("CreateStructField(%s): type=>%s<\n", CurrStruct->sym.name, tokenarray[loc].string_ptr ));
; 596  :         //f->init_dir = LclAlloc( i );
; 597  :         //memcpy( f->init_dir, tokenarray[loc].string_ptr, i );
; 598  : 
; 599  :         /* now add the value to initialize the struct to */
; 600  : 
; 601  :         /* v2.03: the initializer value may contain assembly time
; 602  :          * variables ( $ inside structs is also one ). It's crucial that
; 603  :          * the variable's CURRENT value is used then.
; 604  :          * v2.08: modified. avoid usage of token->string_ptr,
; 605  :          * and prefer to use token->tokpos.
; 606  :          */
; 607  :         init = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR init$[rsp], rax

; 608  :         for ( i = loc+1; tokenarray[i].token != T_FINAL; i++ ) {

	mov	eax, DWORD PTR loc$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN4@CreateStru
$LN2@CreateStru:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@CreateStru:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN3@CreateStru

; 609  :             if ( tokenarray[i].token == T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN16@CreateStru

; 610  :                 struct asym *sym2 = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym2$1[rsp], rax

; 611  :                 if ( sym2 && sym2->variable ) {

	cmp	QWORD PTR sym2$1[rsp], 0
	je	$LN17@CreateStru
	mov	rax, QWORD PTR sym2$1[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN17@CreateStru

; 612  :                     if ( sym2->predefined && sym2->sfunc_ptr )

	mov	rax, QWORD PTR sym2$1[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@CreateStru
	mov	rax, QWORD PTR sym2$1[rsp]
	cmp	QWORD PTR [rax+64], 0
	je	SHORT $LN18@CreateStru

; 613  :                         sym2->sfunc_ptr( sym2, NULL );

	xor	edx, edx
	mov	rcx, QWORD PTR sym2$1[rsp]
	mov	rax, QWORD PTR sym2$1[rsp]
	call	QWORD PTR [rax+64]
$LN18@CreateStru:

; 614  :                     myltoa( sym2->uvalue, init, ModuleInfo.radix, sym2->value3264 < 0, TRUE );

	mov	rax, QWORD PTR sym2$1[rsp]
	cmp	DWORD PTR [rax+56], 0
	jge	SHORT $LN40@CreateStru
	mov	DWORD PTR tv174[rsp], 1
	jmp	SHORT $LN41@CreateStru
$LN40@CreateStru:
	mov	DWORD PTR tv174[rsp], 0
$LN41@CreateStru:
	movzx	eax, BYTE PTR ModuleInfo+396
	mov	BYTE PTR [rsp+32], 1
	movzx	r9d, BYTE PTR tv174[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR init$[rsp]
	mov	rax, QWORD PTR sym2$1[rsp]
	mov	ecx, DWORD PTR [rax+16]
	call	myltoa

; 615  :                     init += strlen( init );

	mov	rcx, QWORD PTR init$[rsp]
	call	strlen
	mov	rcx, QWORD PTR init$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR init$[rsp], rax

; 616  :                     *init++= ' ';

	mov	rax, QWORD PTR init$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
	mov	rax, QWORD PTR init$[rsp]
	inc	rax
	mov	QWORD PTR init$[rsp], rax

; 617  :                     continue;

	jmp	$LN2@CreateStru
$LN17@CreateStru:
$LN16@CreateStru:

; 618  :                 }
; 619  :             }
; 620  :             memcpy( init, tokenarray[i].tokpos, tokenarray[i+1].tokpos - tokenarray[i].tokpos );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+24]
	mov	rcx, QWORD PTR init$[rsp]
	call	memcpy

; 621  :             init += tokenarray[i+1].tokpos - tokenarray[i].tokpos;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	rcx, QWORD PTR init$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR init$[rsp], rax

; 622  :         }

	jmp	$LN2@CreateStru
$LN3@CreateStru:

; 623  :         *init = NULLC;

	mov	rax, QWORD PTR init$[rsp]
	mov	BYTE PTR [rax], 0

; 624  :         f = LclAlloc( sizeof( struct sfield ) + ( init - StringBufferEnd ) );

	mov	rax, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR init$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	add	rax, 112				; 00000070H
	mov	rcx, rax
	call	LclAlloc
	mov	QWORD PTR f$[rsp], rax

; 625  :         //f->value = LclAlloc( init - StringBufferEnd + 1 );
; 626  :         memset( f, 0, sizeof( struct sfield ) );

	mov	r8d, 112				; 00000070H
	xor	edx, edx
	mov	rcx, QWORD PTR f$[rsp]
	call	memset

; 627  :         strcpy( f->ivalue, StringBufferEnd );

	mov	rax, QWORD PTR f$[rsp]
	add	rax, 104				; 00000068H
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, rax
	call	strcpy

; 628  :         DebugMsg1(("CreateStructField(%s): initializer=>%s<\n", CurrStruct->sym.name, f->ivalue ));

	mov	rax, QWORD PTR f$[rsp]
	add	rax, 104				; 00000068H
	mov	r8, rax
	mov	rax, QWORD PTR CurrStruct
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11351
	call	DoDebugMsg1

; 629  : 
; 630  :     } else {

	jmp	SHORT $LN15@CreateStru
$LN14@CreateStru:

; 631  :         f = LclAlloc( sizeof( struct sfield ) );

	mov	ecx, 112				; 00000070H
	call	LclAlloc
	mov	QWORD PTR f$[rsp], rax

; 632  :         memset( f, 0, sizeof( struct sfield ) );

	mov	r8d, 112				; 00000070H
	xor	edx, edx
	mov	rcx, QWORD PTR f$[rsp]
	call	memset

; 633  :         DebugMsg1(("CreateStructField(%s): no initializer<\n", CurrStruct->sym.name ));

	mov	rax, QWORD PTR CurrStruct
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11352
	call	DoDebugMsg1

; 634  :         //f->init_dir = NULL;
; 635  :         f->ivalue[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR f$[rsp]
	mov	BYTE PTR [rcx+rax+104], 0
$LN15@CreateStru:

; 636  :     }
; 637  : 
; 638  :     /* create the struct field symbol */
; 639  : 
; 640  :     //sym = SymAlloc( name );
; 641  :     f->sym.name_size = len;

	mov	rax, QWORD PTR f$[rsp]
	movzx	ecx, BYTE PTR len$[rsp]
	mov	BYTE PTR [rax+72], cl

; 642  :     if ( len ) {

	cmp	DWORD PTR len$[rsp], 0
	je	SHORT $LN19@CreateStru

; 643  :         f->sym.name = LclAlloc( len + 1 );

	mov	eax, DWORD PTR len$[rsp]
	inc	eax
	cdqe
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR f$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 644  :         memcpy( f->sym.name, name, len );

	movsxd	rax, DWORD PTR len$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy

; 645  :         f->sym.name[len] = NULLC;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rcx+rax], 0

; 646  :     } else

	jmp	SHORT $LN20@CreateStru
$LN19@CreateStru:

; 647  :         f->sym.name = "";

	mov	rax, QWORD PTR f$[rsp]
	lea	rcx, OFFSET FLAT:$SG11355
	mov	QWORD PTR [rax+8], rcx
$LN20@CreateStru:

; 648  :     f->sym.state = SYM_STRUCT_FIELD;

	mov	rax, QWORD PTR f$[rsp]
	mov	DWORD PTR [rax+32], 6

; 649  :     f->sym.list = ModuleInfo.cref;

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 12
	and	eax, 1
	and	al, 1
	mov	rcx, QWORD PTR f$[rsp]
	movzx	ecx, BYTE PTR [rcx+41]
	and	cl, 254					; 000000feH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR f$[rsp]
	mov	BYTE PTR [rcx+41], al

; 650  :     f->sym.isdefined = TRUE;

	mov	rax, QWORD PTR f$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR f$[rsp]
	mov	BYTE PTR [rcx+40], al

; 651  :     f->sym.mem_type = mem_type;

	mov	rax, QWORD PTR f$[rsp]
	mov	ecx, DWORD PTR mem_type$[rsp]
	mov	DWORD PTR [rax+36], ecx

; 652  :     f->sym.type = vartype;

	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR vartype$[rsp]
	mov	QWORD PTR [rax+80], rcx

; 653  :     /* fields total/first_size, total/first_length are set in data_item() */
; 654  :     // sym->total_size = SizeFromMemtype( mem_type, ModuleInfo.Ofssize );
; 655  : 
; 656  :     f->next = NULL;

	mov	rax, QWORD PTR f$[rsp]
	mov	QWORD PTR [rax+96], 0

; 657  :     //f->sym = sym;
; 658  : 
; 659  :     if( si->head == NULL ) {

	mov	rax, QWORD PTR si$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN21@CreateStru

; 660  :         si->head = si->tail = f;

	mov	rax, QWORD PTR si$[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR si$[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	mov	QWORD PTR [rax], rcx

; 661  :     } else {

	jmp	SHORT $LN22@CreateStru
$LN21@CreateStru:

; 662  :         si->tail->next = f;

	mov	rax, QWORD PTR si$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR f$[rsp]
	mov	QWORD PTR [rax+96], rcx

; 663  :         si->tail = f;

	mov	rax, QWORD PTR si$[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN22@CreateStru:

; 664  :     }
; 665  : 
; 666  : #if 1
; 667  :     /* v2.0: for STRUCTs, don't use the struct's size for alignment calculations,
; 668  :      * instead use the size of the "max" member!
; 669  :      */
; 670  :     if ( mem_type == MT_TYPE &&

	cmp	DWORD PTR mem_type$[rsp], 196		; 000000c4H
	jne	SHORT $LN23@CreateStru
	mov	rax, QWORD PTR vartype$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 1
	je	SHORT $LN24@CreateStru
	mov	rax, QWORD PTR vartype$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	jne	SHORT $LN23@CreateStru
$LN24@CreateStru:

; 671  :         ( vartype->typekind == TYPE_STRUCT ||
; 672  :          vartype->typekind == TYPE_UNION ) ) {
; 673  :         size = vartype->max_mbr_size;

	mov	rax, QWORD PTR vartype$[rsp]
	mov	eax, DWORD PTR [rax+48]
	mov	DWORD PTR size$[rsp], eax
$LN23@CreateStru:

; 674  :     }
; 675  : #endif
; 676  :     /* align the field if an alignment argument was given */
; 677  :     if ( si->alignment > 1 ) {

	mov	rax, QWORD PTR si$[rsp]
	movzx	eax, BYTE PTR [rax+28]
	cmp	eax, 1
	jle	$LN25@CreateStru

; 678  :         //enum memtype mt;
; 679  :         //struct dsym *tdir;
; 680  :         DebugMsg1(("CreateStructField(%s): align=%u, size=%u, ofs=%u\n", CurrStruct->sym.name, si->alignment, size, offset ));

	mov	rax, QWORD PTR si$[rsp]
	movzx	eax, BYTE PTR [rax+28]
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR size$[rsp]
	mov	r8d, eax
	mov	rax, QWORD PTR CurrStruct
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11361
	call	DoDebugMsg1

; 681  :         /* if it's the first field to add, use offset of the parent's current field */
; 682  : #if 0
; 683  :         /* v2: removed. An embedded struct is now added AFTER it has
; 684  :          * been parsed. */
; 685  :         if ( offset == 0 && CurrStruct->next ) {
; 686  :             struct dsym *parent = CurrStruct->next;
; 687  :             if ( si->alignment < size )
; 688  :                 parent->e.structinfo->tail->sym->offset =
; 689  :                     (parent->e.structinfo->tail->sym->offset + (si->alignment - 1)) & ( - si->alignment);
; 690  :             else if ( size )
; 691  :                 parent->e.structinfo->tail->sym->offset =
; 692  :                     (parent->e.structinfo->tail->sym->offset + (size - 1)) & (-size);
; 693  :         } else
; 694  : #endif
; 695  :         {
; 696  :             if ( si->alignment < size )

	mov	rax, QWORD PTR si$[rsp]
	movzx	eax, BYTE PTR [rax+28]
	cmp	eax, DWORD PTR size$[rsp]
	jae	SHORT $LN26@CreateStru

; 697  :                 offset = (offset + (si->alignment - 1)) & ( - si->alignment);

	mov	rax, QWORD PTR si$[rsp]
	movzx	eax, BYTE PTR [rax+28]
	mov	ecx, DWORD PTR offset$[rsp]
	lea	eax, DWORD PTR [rcx+rax-1]
	mov	rcx, QWORD PTR si$[rsp]
	movzx	ecx, BYTE PTR [rcx+28]
	neg	ecx
	and	eax, ecx
	mov	DWORD PTR offset$[rsp], eax
	jmp	SHORT $LN27@CreateStru
$LN26@CreateStru:

; 698  :             else if ( size )

	cmp	DWORD PTR size$[rsp], 0
	je	SHORT $LN28@CreateStru

; 699  :                 offset = (offset + (size - 1)) & (-size);

	mov	eax, DWORD PTR offset$[rsp]
	mov	ecx, DWORD PTR size$[rsp]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	ecx, DWORD PTR size$[rsp]
	neg	ecx
	and	eax, ecx
	mov	DWORD PTR offset$[rsp], eax
$LN28@CreateStru:
$LN27@CreateStru:

; 700  :         }
; 701  :         /* adjust the struct's current offset + size.
; 702  :          The field's size is added in UpdateStructSize()
; 703  :          */
; 704  :         if ( CurrStruct->sym.typekind != TYPE_UNION ) {

	mov	rax, QWORD PTR CurrStruct
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	je	SHORT $LN29@CreateStru

; 705  :             CurrStruct->sym.offset = offset;

	mov	rax, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 706  :             if ( offset > CurrStruct->sym.total_size )

	mov	rax, QWORD PTR CurrStruct
	mov	eax, DWORD PTR [rax+56]
	cmp	DWORD PTR offset$[rsp], eax
	jbe	SHORT $LN30@CreateStru

; 707  :                 CurrStruct->sym.total_size = offset;

	mov	rax, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rax+56], ecx
$LN30@CreateStru:
$LN29@CreateStru:
$LN25@CreateStru:

; 708  :         }
; 709  :     }
; 710  :     /* v2.0: for padding, save the max member size */
; 711  :     if ( size > CurrStruct->sym.max_mbr_size ) {

	mov	rax, QWORD PTR CurrStruct
	mov	eax, DWORD PTR [rax+48]
	cmp	DWORD PTR size$[rsp], eax
	jbe	SHORT $LN31@CreateStru

; 712  :         DebugMsg1(("CreateStructField(%s): max_mbr_size set to %u\n", CurrStruct->sym.name, size ));

	mov	r8d, DWORD PTR size$[rsp]
	mov	rax, QWORD PTR CurrStruct
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11368
	call	DoDebugMsg1

; 713  :         CurrStruct->sym.max_mbr_size = size;

	mov	rax, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR size$[rsp]
	mov	DWORD PTR [rax+48], ecx
$LN31@CreateStru:

; 714  :     }
; 715  :     f->sym.offset = offset;

	mov	rax, QWORD PTR f$[rsp]
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 716  : 
; 717  :     /* if -Zm is on, create a global symbol */
; 718  :     if ( ModuleInfo.oldstructs == TRUE && *name != NULLC ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 8
	and	eax, 1
	cmp	eax, 1
	jne	$LN32@CreateStru
	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN32@CreateStru

; 719  :         DebugMsg(("CreateStructField(%s): Masm51 compat on, lookup %s in global symbol table\n", CurrStruct->sym.name, name ));

	mov	r8, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR CurrStruct
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11370
	call	DoDebugMsg

; 720  :         gsym  = SymLookup( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymLookup
	mov	QWORD PTR gsym$[rsp], rax

; 721  :         /* v2.11: cannot fail */
; 722  :         //if ( gsym ) {
; 723  :             if ( gsym->state == SYM_UNDEFINED )

	mov	rax, QWORD PTR gsym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN33@CreateStru

; 724  :                 gsym->state = SYM_STRUCT_FIELD;

	mov	rax, QWORD PTR gsym$[rsp]
	mov	DWORD PTR [rax+32], 6
$LN33@CreateStru:

; 725  :             if ( gsym->state == SYM_STRUCT_FIELD ) {

	mov	rax, QWORD PTR gsym$[rsp]
	cmp	DWORD PTR [rax+32], 6
	jne	$LN34@CreateStru

; 726  :                 struct dsym *dir;
; 727  :                 gsym->mem_type = mem_type;

	mov	rax, QWORD PTR gsym$[rsp]
	mov	ecx, DWORD PTR mem_type$[rsp]
	mov	DWORD PTR [rax+36], ecx

; 728  :                 gsym->type = vartype;

	mov	rax, QWORD PTR gsym$[rsp]
	mov	rcx, QWORD PTR vartype$[rsp]
	mov	QWORD PTR [rax+80], rcx

; 729  :                 gsym->offset = offset; /* added v2.0 */

	mov	rax, QWORD PTR gsym$[rsp]
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 730  :                 /* v2.01: must be the full offset.
; 731  :                  * (there's still a problem if alignment is > 1!)
; 732  :                  */
; 733  :                 for ( dir = CurrStruct->next; dir; dir = dir->next )

	mov	rax, QWORD PTR CurrStruct
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR dir$2[rsp], rax
	jmp	SHORT $LN7@CreateStru
$LN5@CreateStru:
	mov	rax, QWORD PTR dir$2[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR dir$2[rsp], rax
$LN7@CreateStru:
	cmp	QWORD PTR dir$2[rsp], 0
	je	SHORT $LN6@CreateStru

; 734  :                     gsym->offset += dir->sym.offset;

	mov	rax, QWORD PTR gsym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR dir$2[rsp]
	add	eax, DWORD PTR [rcx+16]
	mov	rcx, QWORD PTR gsym$[rsp]
	mov	DWORD PTR [rcx+16], eax
	jmp	SHORT $LN5@CreateStru
$LN6@CreateStru:

; 735  :                 gsym->isdefined = TRUE;

	mov	rax, QWORD PTR gsym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR gsym$[rsp]
	mov	BYTE PTR [rcx+40], al
$LN34@CreateStru:
$LN32@CreateStru:

; 736  :             }
; 737  :         //}
; 738  :     }
; 739  : 
; 740  :     return( &f->sym );

	mov	rax, QWORD PTR f$[rsp]
$LN1@CreateStru:

; 741  : }

	add	rsp, 168				; 000000a8H
	ret	0
CreateStructField ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
i$ = 64
sym$ = 72
tmp$ = 80
Ofssize$1 = 84
type$ = 88
mem_type$ = 92
distance$ = 96
tv131 = 100
tv170 = 104
tv258 = 108
tv419 = 112
tv433 = 116
tv483 = 120
tv439 = 128
pi$ = 160
tokenarray$ = 168
pti$ = 176
GetQualifiedType PROC

; 812  : {

$LN72:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 813  :     int             type;
; 814  :     int             tmp;
; 815  :     enum memtype    mem_type;
; 816  :     int             i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 817  :     int             distance = FALSE;

	mov	DWORD PTR distance$[rsp], 0

; 818  :     struct asym     *sym;
; 819  : 
; 820  :     /* convert PROC token to a type qualifier */
; 821  :     for ( tmp = i; tokenarray[tmp].token != T_FINAL && tokenarray[tmp].token != T_COMMA; tmp++ )

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR tmp$[rsp], eax
	jmp	SHORT $LN4@GetQualifi
$LN2@GetQualifi:
	mov	eax, DWORD PTR tmp$[rsp]
	inc	eax
	mov	DWORD PTR tmp$[rsp], eax
$LN4@GetQualifi:
	movsxd	rax, DWORD PTR tmp$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN3@GetQualifi
	movsxd	rax, DWORD PTR tmp$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	$LN3@GetQualifi

; 822  :         if ( tokenarray[tmp].token == T_DIRECTIVE && tokenarray[tmp].tokval == T_PROC ) {

	movsxd	rax, DWORD PTR tmp$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	SHORT $LN8@GetQualifi
	movsxd	rax, DWORD PTR tmp$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 433		; 000001b1H
	jne	SHORT $LN8@GetQualifi

; 823  :             tokenarray[tmp].token = T_STYPE;

	movsxd	rax, DWORD PTR tmp$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	BYTE PTR [rcx+rax], 6

; 824  :             /* v2.06: avoid to use ST_PROC */
; 825  :             tokenarray[tmp].tokval = ( ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) ? T_FAR : T_NEAR );

	mov	eax, DWORD PTR ModuleInfo+360
	mov	ecx, 1
	mov	DWORD PTR tv483[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv483[rsp]
	shl	eax, cl
	and	eax, 112				; 00000070H
	test	eax, eax
	je	SHORT $LN60@GetQualifi
	mov	DWORD PTR tv131[rsp], 222		; 000000deH
	jmp	SHORT $LN61@GetQualifi
$LN60@GetQualifi:
	mov	DWORD PTR tv131[rsp], 221		; 000000ddH
$LN61@GetQualifi:
	movsxd	rax, DWORD PTR tmp$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR tv131[rsp]
	mov	DWORD PTR [rcx+rax+16], edx
$LN8@GetQualifi:

; 826  :         }

	jmp	$LN2@GetQualifi
$LN3@GetQualifi:

; 827  :     /* with NEAR/FAR, there are several syntax variants allowed:
; 828  :      * 1. NEARxx | FARxx
; 829  :      * 2. PTR NEARxx | FARxx
; 830  :      * 3. NEARxx | FARxx PTR [<type>]
; 831  :      */
; 832  :     /* read qualified type */
; 833  :     for ( type = ERROR; tokenarray[i].token == T_STYPE || tokenarray[i].token == T_BINARY_OPERATOR; i++ ) {

	mov	DWORD PTR type$[rsp], -1
	jmp	SHORT $LN7@GetQualifi
$LN5@GetQualifi:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@GetQualifi:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 6
	je	SHORT $LN9@GetQualifi
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 5
	jne	$LN6@GetQualifi
$LN9@GetQualifi:

; 834  :         if ( tokenarray[i].token == T_STYPE ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 6
	jne	$LN10@GetQualifi

; 835  :             tmp = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR tmp$[rsp], eax

; 836  :             if ( type == ERROR )

	cmp	DWORD PTR type$[rsp], -1
	jne	SHORT $LN12@GetQualifi

; 837  :                 type = tmp;

	mov	eax, DWORD PTR tmp$[rsp]
	mov	DWORD PTR type$[rsp], eax
$LN12@GetQualifi:

; 838  :             mem_type = GetMemtypeSp( tmp );

	movsxd	rax, DWORD PTR tmp$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	DWORD PTR mem_type$[rsp], eax

; 839  :             if ( mem_type == MT_FAR || mem_type == MT_NEAR ) {

	cmp	DWORD PTR mem_type$[rsp], 130		; 00000082H
	je	SHORT $LN15@GetQualifi
	cmp	DWORD PTR mem_type$[rsp], 129		; 00000081H
	jne	$LN13@GetQualifi
$LN15@GetQualifi:

; 840  :                 if ( distance == FALSE ) {

	cmp	DWORD PTR distance$[rsp], 0
	jne	SHORT $LN16@GetQualifi

; 841  :                     uint_8 Ofssize = GetSflagsSp( tmp );

	movsxd	rax, DWORD PTR tmp$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+4]
	mov	BYTE PTR Ofssize$1[rsp], al

; 842  :                     pti->is_far = ( mem_type == MT_FAR );

	cmp	DWORD PTR mem_type$[rsp], 130		; 00000082H
	jne	SHORT $LN62@GetQualifi
	mov	DWORD PTR tv170[rsp], 1
	jmp	SHORT $LN63@GetQualifi
$LN62@GetQualifi:
	mov	DWORD PTR tv170[rsp], 0
$LN63@GetQualifi:
	mov	rax, QWORD PTR pti$[rsp]
	movzx	ecx, BYTE PTR tv170[rsp]
	mov	BYTE PTR [rax+21], cl

; 843  :                     if ( Ofssize != USE_EMPTY )

	movzx	eax, BYTE PTR Ofssize$1[rsp]
	cmp	eax, 254				; 000000feH
	je	SHORT $LN18@GetQualifi

; 844  :                         pti->Ofssize = Ofssize;

	mov	rax, QWORD PTR pti$[rsp]
	movzx	ecx, BYTE PTR Ofssize$1[rsp]
	mov	BYTE PTR [rax+22], cl
$LN18@GetQualifi:

; 845  :                     distance = TRUE;

	mov	DWORD PTR distance$[rsp], 1
	jmp	SHORT $LN17@GetQualifi
$LN16@GetQualifi:

; 846  :                 } else if ( tokenarray[i-1].tokval != T_PTR )

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 258		; 00000102H
	je	SHORT $LN19@GetQualifi

; 847  :                     break;

	jmp	SHORT $LN6@GetQualifi
$LN19@GetQualifi:
$LN17@GetQualifi:

; 848  :             } else {

	jmp	SHORT $LN14@GetQualifi
$LN13@GetQualifi:

; 849  :                 if ( pti->is_ptr )

	mov	rax, QWORD PTR pti$[rsp]
	movzx	eax, BYTE PTR [rax+20]
	test	eax, eax
	je	SHORT $LN20@GetQualifi

; 850  :                     pti->ptr_memtype = mem_type;

	mov	rax, QWORD PTR pti$[rsp]
	mov	ecx, DWORD PTR mem_type$[rsp]
	mov	DWORD PTR [rax+24], ecx
$LN20@GetQualifi:

; 851  :                 i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 852  :                 break;

	jmp	SHORT $LN6@GetQualifi
$LN14@GetQualifi:

; 853  :             }

	jmp	SHORT $LN11@GetQualifi
$LN10@GetQualifi:

; 854  :         } else if ( tokenarray[i].tokval == T_PTR ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 258		; 00000102H
	jne	SHORT $LN21@GetQualifi

; 855  :             /* v2.06: avoid to use ST_PTR */
; 856  :             //type = ST_PTR;
; 857  :             type = EMPTY;

	mov	DWORD PTR type$[rsp], -2

; 858  :             pti->is_ptr++;

	mov	rax, QWORD PTR pti$[rsp]
	movzx	eax, BYTE PTR [rax+20]
	inc	al
	mov	rcx, QWORD PTR pti$[rsp]
	mov	BYTE PTR [rcx+20], al

; 859  :         } else

	jmp	SHORT $LN22@GetQualifi
$LN21@GetQualifi:

; 860  :             break;

	jmp	SHORT $LN6@GetQualifi
$LN22@GetQualifi:
$LN11@GetQualifi:

; 861  :     }

	jmp	$LN5@GetQualifi
$LN6@GetQualifi:

; 862  : 
; 863  :     /* v2.06: don't use ST_PTR anymore! */
; 864  :     //if ( type == ST_PTR ) {
; 865  :     if ( type == EMPTY ) {

	cmp	DWORD PTR type$[rsp], -2
	jne	$LN23@GetQualifi

; 866  :         if ( tokenarray[i].token == T_ID && tokenarray[i-1].tokval == T_PTR ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN24@GetQualifi
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 258		; 00000102H
	jne	$LN24@GetQualifi

; 867  :             pti->symtype = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	rcx, QWORD PTR pti$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 868  :             if ( pti->symtype == NULL || pti->symtype->state == SYM_UNDEFINED )

	mov	rax, QWORD PTR pti$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN27@GetQualifi
	mov	rax, QWORD PTR pti$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN25@GetQualifi
$LN27@GetQualifi:

; 869  :                 pti->symtype = CreateTypeSymbol( pti->symtype, tokenarray[i].string_ptr, TRUE );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r8b, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	rax, QWORD PTR pti$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	CreateTypeSymbol
	mov	rcx, QWORD PTR pti$[rsp]
	mov	QWORD PTR [rcx+8], rax
	jmp	$LN26@GetQualifi
$LN25@GetQualifi:

; 870  :             else if ( pti->symtype->state != SYM_TYPE ) {

	mov	rax, QWORD PTR pti$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	DWORD PTR [rax+32], 7
	je	SHORT $LN28@GetQualifi

; 871  :                 return( EmitErr( INVALID_QUALIFIED_TYPE, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 85					; 00000055H
	call	EmitErr
	jmp	$LN1@GetQualifi

; 872  :             } else {

	jmp	$LN29@GetQualifi
$LN28@GetQualifi:

; 873  :                 sym = pti->symtype;

	mov	rax, QWORD PTR pti$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR sym$[rsp], rax

; 874  :                 /* if it's a typedef, simplify the info */
; 875  :                 if ( sym->typekind == TYPE_TYPEDEF ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	jne	$LN30@GetQualifi

; 876  :                     pti->is_ptr     += sym->is_ptr;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+45]
	mov	rcx, QWORD PTR pti$[rsp]
	movzx	ecx, BYTE PTR [rcx+20]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR pti$[rsp]
	mov	BYTE PTR [rcx+20], al

; 877  :                     if ( sym->is_ptr == 0 ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+45]
	test	eax, eax
	jne	$LN31@GetQualifi

; 878  :                         /* v2.06b: alias types have MT_TYPE, dont use for ptr_memtype! */
; 879  :                         //pti->ptr_memtype = sym->mem_type;
; 880  :                         pti->ptr_memtype = ( sym->mem_type != MT_TYPE ? sym->mem_type : MT_EMPTY );

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	je	SHORT $LN64@GetQualifi
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR tv258[rsp], eax
	jmp	SHORT $LN65@GetQualifi
$LN64@GetQualifi:
	mov	DWORD PTR tv258[rsp], 192		; 000000c0H
$LN65@GetQualifi:
	mov	rax, QWORD PTR pti$[rsp]
	mov	ecx, DWORD PTR tv258[rsp]
	mov	DWORD PTR [rax+24], ecx

; 881  :                         if ( distance == FALSE && pti->is_ptr == 1 &&

	cmp	DWORD PTR distance$[rsp], 0
	jne	SHORT $LN33@GetQualifi
	mov	rax, QWORD PTR pti$[rsp]
	movzx	eax, BYTE PTR [rax+20]
	cmp	eax, 1
	jne	SHORT $LN33@GetQualifi
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 129			; 00000081H
	je	SHORT $LN34@GetQualifi
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 128			; 00000080H
	je	SHORT $LN34@GetQualifi
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN33@GetQualifi
$LN34@GetQualifi:

; 882  :                             ( sym->mem_type == MT_NEAR ||
; 883  :                              sym->mem_type == MT_PROC ||
; 884  :                              sym->mem_type == MT_FAR ) )
; 885  :                             pti->is_far = sym->isfar;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 4
	and	al, 1
	mov	rcx, QWORD PTR pti$[rsp]
	mov	BYTE PTR [rcx+21], al
$LN33@GetQualifi:

; 886  :                             if ( sym->Ofssize != USE_EMPTY )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	cmp	eax, 254				; 000000feH
	je	SHORT $LN35@GetQualifi

; 887  :                                 pti->Ofssize = sym->Ofssize;

	mov	rax, QWORD PTR pti$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+44]
	mov	BYTE PTR [rax+22], cl
$LN35@GetQualifi:

; 888  :                     } else {

	jmp	SHORT $LN32@GetQualifi
$LN31@GetQualifi:

; 889  :                         pti->ptr_memtype = sym->ptr_memtype;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	mov	rcx, QWORD PTR pti$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 890  :                         if ( distance == FALSE && pti->is_ptr == 1 ) {

	cmp	DWORD PTR distance$[rsp], 0
	jne	SHORT $LN36@GetQualifi
	mov	rax, QWORD PTR pti$[rsp]
	movzx	eax, BYTE PTR [rax+20]
	cmp	eax, 1
	jne	SHORT $LN36@GetQualifi

; 891  :                             pti->is_far = sym->isfar;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 4
	and	al, 1
	mov	rcx, QWORD PTR pti$[rsp]
	mov	BYTE PTR [rcx+21], al

; 892  :                             if ( sym->Ofssize != USE_EMPTY )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	cmp	eax, 254				; 000000feH
	je	SHORT $LN37@GetQualifi

; 893  :                                 pti->Ofssize = sym->Ofssize;

	mov	rax, QWORD PTR pti$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+44]
	mov	BYTE PTR [rax+22], cl
$LN37@GetQualifi:
$LN36@GetQualifi:
$LN32@GetQualifi:

; 894  :                         }
; 895  :                     }
; 896  :                     if ( sym->mem_type == MT_TYPE )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN38@GetQualifi

; 897  :                         pti->symtype  = sym->type;

	mov	rax, QWORD PTR pti$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [rax+8], rcx
	jmp	SHORT $LN39@GetQualifi
$LN38@GetQualifi:

; 898  :                     else {
; 899  :                         DebugMsg1(("GetQualifiedType: memtype=%X, symtype set by target_type\n", sym->mem_type ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR [rax+36]
	lea	rcx, OFFSET FLAT:$SG11453
	call	DoDebugMsg1

; 900  :                         pti->symtype  = sym->target_type;

	mov	rax, QWORD PTR pti$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	QWORD PTR [rax+8], rcx
$LN39@GetQualifi:
$LN30@GetQualifi:
$LN29@GetQualifi:
$LN26@GetQualifi:

; 901  :                     }
; 902  :                 }
; 903  :             }
; 904  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN24@GetQualifi:
$LN23@GetQualifi:

; 905  :         }
; 906  :     }
; 907  : 
; 908  :     if( type == ERROR ) {

	cmp	DWORD PTR type$[rsp], -1
	jne	$LN40@GetQualifi

; 909  :         if ( tokenarray[i].token != T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN42@GetQualifi

; 910  :             if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_COMMA )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN45@GetQualifi
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN43@GetQualifi
$LN45@GetQualifi:

; 911  :                 EmitError( QUALIFIED_TYPE_EXPECTED );

	mov	ecx, 86					; 00000056H
	call	EmitError
	jmp	SHORT $LN44@GetQualifi
$LN43@GetQualifi:

; 912  :             else {
; 913  :                 EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 914  :                 i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN44@GetQualifi:

; 915  :             }
; 916  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@GetQualifi
$LN42@GetQualifi:

; 917  :         }
; 918  :         pti->symtype = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	rcx, QWORD PTR pti$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 919  :         if( pti->symtype == NULL || pti->symtype->state != SYM_TYPE ) {

	mov	rax, QWORD PTR pti$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN47@GetQualifi
	mov	rax, QWORD PTR pti$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	DWORD PTR [rax+32], 7
	je	$LN46@GetQualifi
$LN47@GetQualifi:

; 920  :             DebugMsg(("GetQualifiedType: invalid type : %s\n", tokenarray[i].string_ptr ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11462
	call	DoDebugMsg

; 921  :             if ( pti->symtype == NULL || pti->symtype ->state == SYM_UNDEFINED )

	mov	rax, QWORD PTR pti$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN50@GetQualifi
	mov	rax, QWORD PTR pti$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN48@GetQualifi
$LN50@GetQualifi:

; 922  :                 EmitErr( SYMBOL_NOT_DEFINED, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr
	jmp	SHORT $LN49@GetQualifi
$LN48@GetQualifi:

; 923  :             else
; 924  :                 EmitErr( INVALID_QUALIFIED_TYPE, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 85					; 00000055H
	call	EmitErr
$LN49@GetQualifi:

; 925  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@GetQualifi
$LN46@GetQualifi:

; 926  :         }
; 927  :         sym = pti->symtype;

	mov	rax, QWORD PTR pti$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR sym$[rsp], rax

; 928  :         if ( sym->typekind == TYPE_TYPEDEF ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	jne	$LN51@GetQualifi

; 929  :             pti->mem_type = sym->mem_type;

	mov	rax, QWORD PTR pti$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	mov	DWORD PTR [rax+16], ecx

; 930  :             pti->is_far   = sym->isfar;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 4
	and	al, 1
	mov	rcx, QWORD PTR pti$[rsp]
	mov	BYTE PTR [rcx+21], al

; 931  :             pti->is_ptr   = sym->is_ptr;

	mov	rax, QWORD PTR pti$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+45]
	mov	BYTE PTR [rax+20], cl

; 932  :             pti->Ofssize  = sym->Ofssize;

	mov	rax, QWORD PTR pti$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+44]
	mov	BYTE PTR [rax+22], cl

; 933  :             pti->size     = sym->total_size;

	mov	rax, QWORD PTR pti$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax], ecx

; 934  :             pti->ptr_memtype = sym->ptr_memtype;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	mov	rcx, QWORD PTR pti$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 935  :             if ( sym->mem_type == MT_TYPE )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN53@GetQualifi

; 936  :                 pti->symtype  = sym->type;

	mov	rax, QWORD PTR pti$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [rax+8], rcx
	jmp	SHORT $LN54@GetQualifi
$LN53@GetQualifi:

; 937  :             else {
; 938  :                 DebugMsg1(("GetQualifiedType: memtype=%X, symtype set by target_type\n", sym->mem_type ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR [rax+36]
	lea	rcx, OFFSET FLAT:$SG11470
	call	DoDebugMsg1

; 939  :                 pti->symtype  = sym->target_type;

	mov	rax, QWORD PTR pti$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	QWORD PTR [rax+8], rcx
$LN54@GetQualifi:

; 940  :             }
; 941  :         } else {

	jmp	SHORT $LN52@GetQualifi
$LN51@GetQualifi:

; 942  :             pti->mem_type = MT_TYPE;

	mov	rax, QWORD PTR pti$[rsp]
	mov	DWORD PTR [rax+16], 196			; 000000c4H

; 943  :             pti->size = sym->total_size;

	mov	rax, QWORD PTR pti$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax], ecx
$LN52@GetQualifi:

; 944  :         }
; 945  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 946  :     } else {

	jmp	$LN41@GetQualifi
$LN40@GetQualifi:

; 947  :         if ( pti->is_ptr )

	mov	rax, QWORD PTR pti$[rsp]
	movzx	eax, BYTE PTR [rax+20]
	test	eax, eax
	je	SHORT $LN55@GetQualifi

; 948  :             pti->mem_type = MT_PTR;

	mov	rax, QWORD PTR pti$[rsp]
	mov	DWORD PTR [rax+16], 195			; 000000c3H
	jmp	SHORT $LN56@GetQualifi
$LN55@GetQualifi:

; 949  :         else
; 950  :             pti->mem_type = GetMemtypeSp( type );

	movsxd	rax, DWORD PTR type$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	rcx, QWORD PTR pti$[rsp]
	mov	DWORD PTR [rcx+16], eax
$LN56@GetQualifi:

; 951  :         if ( pti->mem_type == MT_PTR )

	mov	rax, QWORD PTR pti$[rsp]
	cmp	DWORD PTR [rax+16], 195			; 000000c3H
	jne	SHORT $LN57@GetQualifi

; 952  :             pti->size = SizeFromMemtype( pti->is_far ? MT_FAR : MT_NEAR, pti->Ofssize, NULL );

	mov	rax, QWORD PTR pti$[rsp]
	movzx	eax, BYTE PTR [rax+21]
	test	eax, eax
	je	SHORT $LN66@GetQualifi
	mov	DWORD PTR tv419[rsp], 130		; 00000082H
	jmp	SHORT $LN67@GetQualifi
$LN66@GetQualifi:
	mov	DWORD PTR tv419[rsp], 129		; 00000081H
$LN67@GetQualifi:
	mov	rax, QWORD PTR pti$[rsp]
	movzx	eax, BYTE PTR [rax+22]
	xor	r8d, r8d
	mov	edx, eax
	mov	ecx, DWORD PTR tv419[rsp]
	call	SizeFromMemtype
	mov	rcx, QWORD PTR pti$[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN58@GetQualifi
$LN57@GetQualifi:

; 953  :         else
; 954  :             pti->size = SizeFromMemtype( pti->mem_type, pti->Ofssize, NULL );

	mov	rax, QWORD PTR pti$[rsp]
	movzx	eax, BYTE PTR [rax+22]
	xor	r8d, r8d
	mov	edx, eax
	mov	rax, QWORD PTR pti$[rsp]
	mov	ecx, DWORD PTR [rax+16]
	call	SizeFromMemtype
	mov	rcx, QWORD PTR pti$[rsp]
	mov	DWORD PTR [rcx], eax
$LN58@GetQualifi:
$LN41@GetQualifi:

; 955  :     }
; 956  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 957  :     DebugMsg1(("GetQualifiedType: i=%u, memtype=%Xh, ptr=%u, far=%u, ofssize=%d, arbtype=%s:%X\n",

	mov	rax, QWORD PTR pti$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN68@GetQualifi
	mov	rax, QWORD PTR pti$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR tv433[rsp], eax
	jmp	SHORT $LN69@GetQualifi
$LN68@GetQualifi:
	mov	DWORD PTR tv433[rsp], 0
$LN69@GetQualifi:
	mov	rax, QWORD PTR pti$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN70@GetQualifi
	mov	rax, QWORD PTR pti$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv439[rsp], rax
	jmp	SHORT $LN71@GetQualifi
$LN70@GetQualifi:
	lea	rax, OFFSET FLAT:$SG11475
	mov	QWORD PTR tv439[rsp], rax
$LN71@GetQualifi:
	mov	rax, QWORD PTR pti$[rsp]
	movzx	eax, BYTE PTR [rax+22]
	mov	rcx, QWORD PTR pti$[rsp]
	movzx	ecx, BYTE PTR [rcx+21]
	mov	rdx, QWORD PTR pti$[rsp]
	movzx	edx, BYTE PTR [rdx+20]
	mov	r8d, DWORD PTR tv433[rsp]
	mov	DWORD PTR [rsp+56], r8d
	mov	r8, QWORD PTR tv439[rsp]
	mov	QWORD PTR [rsp+48], r8
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, edx
	mov	rax, QWORD PTR pti$[rsp]
	mov	r8d, DWORD PTR [rax+16]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11476
	call	DoDebugMsg1

; 958  :                i, pti->mem_type, pti->is_ptr, pti->is_far, pti->Ofssize,
; 959  :                pti->symtype ? pti->symtype->name : "NULL",
; 960  :                pti->symtype ? pti->symtype->mem_type : 0 ));
; 961  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@GetQualifi:

; 962  : }

	add	rsp, 152				; 00000098H
	ret	0
GetQualifiedType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
len$ = 32
fl$ = 40
sym$ = 48
tstruct$ = 80
name$ = 88
poffset$ = 96
level$ = 104
SearchNameInStruct PROC

; 85   : {

$LN15:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 86   :     int len = strlen( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 87   :     struct sfield *fl = ((struct dsym *)tstruct)->e.structinfo->head;

	mov	rax, QWORD PTR tstruct$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR fl$[rsp], rax

; 88   :     struct asym *sym = NULL;

	mov	QWORD PTR sym$[rsp], 0

; 89   : 
; 90   :     //if (ModuleInfo.oldstructs == TRUE) {
; 91   :     //    return( SymSearch( name ) );
; 92   :     //}
; 93   :     if ( level >= MAX_STRUCT_NESTING ) {

	cmp	DWORD PTR level$[rsp], 32		; 00000020H
	jl	SHORT $LN5@SearchName

; 94   :         EmitError( NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 100				; 00000064H
	call	EmitError

; 95   :         return( NULL );

	xor	eax, eax
	jmp	$LN1@SearchName
$LN5@SearchName:

; 96   :     }
; 97   :     level++;

	mov	eax, DWORD PTR level$[rsp]
	inc	eax
	mov	DWORD PTR level$[rsp], eax

; 98   :     for ( ; fl; fl = fl->next ) {

	jmp	SHORT $LN4@SearchName
$LN2@SearchName:
	mov	rax, QWORD PTR fl$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR fl$[rsp], rax
$LN4@SearchName:
	cmp	QWORD PTR fl$[rsp], 0
	je	$LN3@SearchName

; 99   :         /* recursion: if member has no name, check if it is a structure
; 100  :          and scan this structure's fieldlist then */
; 101  :         if ( *( fl->sym.name ) == NULLC ) {

	mov	rax, QWORD PTR fl$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	$LN6@SearchName

; 102  :             /* there are 2 cases: an anonymous inline struct ... */
; 103  :             if ( fl->sym.state == SYM_TYPE ) {

	mov	rax, QWORD PTR fl$[rsp]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN8@SearchName

; 104  :                 if ( sym = SearchNameInStruct( &fl->sym, name, poffset, level ) ) {

	mov	rax, QWORD PTR fl$[rsp]
	mov	r9d, DWORD PTR level$[rsp]
	mov	r8, QWORD PTR poffset$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, rax
	call	SearchNameInStruct
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN10@SearchName

; 105  :                     *poffset += fl->sym.offset;

	mov	rax, QWORD PTR poffset$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR fl$[rsp]
	add	eax, DWORD PTR [rcx+16]
	mov	rcx, QWORD PTR poffset$[rsp]
	mov	DWORD PTR [rcx], eax

; 106  :                     break;

	jmp	$LN3@SearchName
$LN10@SearchName:

; 107  :                 }

	jmp	SHORT $LN9@SearchName
$LN8@SearchName:

; 108  :             /* or an anonymous structured field */
; 109  :             } else if ( fl->sym.mem_type == MT_TYPE ) {

	mov	rax, QWORD PTR fl$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN11@SearchName

; 110  :                 if ( sym = SearchNameInStruct( fl->sym.type, name, poffset, level ) ) {

	mov	r9d, DWORD PTR level$[rsp]
	mov	r8, QWORD PTR poffset$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR fl$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	SearchNameInStruct
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN12@SearchName

; 111  :                     *poffset += fl->sym.offset;

	mov	rax, QWORD PTR poffset$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR fl$[rsp]
	add	eax, DWORD PTR [rcx+16]
	mov	rcx, QWORD PTR poffset$[rsp]
	mov	DWORD PTR [rcx], eax

; 112  :                     break;

	jmp	SHORT $LN3@SearchName
$LN12@SearchName:
$LN11@SearchName:
$LN9@SearchName:

; 113  :                 }
; 114  :             }

	jmp	SHORT $LN7@SearchName
$LN6@SearchName:

; 115  :         } else if ( len == fl->sym.name_size && SymCmpFunc( name, fl->sym.name, len ) == 0 ) {

	mov	rax, QWORD PTR fl$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	cmp	DWORD PTR len$[rsp], eax
	jne	SHORT $LN13@SearchName
	movsxd	rax, DWORD PTR len$[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR fl$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR name$[rsp]
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	jne	SHORT $LN13@SearchName

; 116  :             DebugMsg(("SearchNameInStruct: '%s' found in struct %s\n", name, tstruct->name ));

	mov	rax, QWORD PTR tstruct$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11093
	call	DoDebugMsg

; 117  :             sym = &fl->sym;

	mov	rax, QWORD PTR fl$[rsp]
	mov	QWORD PTR sym$[rsp], rax

; 118  :             break;

	jmp	SHORT $LN3@SearchName
$LN13@SearchName:
$LN7@SearchName:

; 119  :         }
; 120  :     }

	jmp	$LN2@SearchName
$LN3@SearchName:

; 121  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]
$LN1@SearchName:

; 122  : }

	add	rsp, 72					; 00000048H
	ret	0
SearchNameInStruct ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_TEXT	SEGMENT
si$ = 32
tv75 = 40
sym$ = 64
name$ = 72
global$ = 80
CreateTypeSymbol PROC

; 61   : {

$LN8:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 62   :     struct struct_info *si;
; 63   : 
; 64   :     if ( sym )

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN2@CreateType

; 65   :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_remove_table
	jmp	SHORT $LN3@CreateType
$LN2@CreateType:

; 66   :     else
; 67   :         sym = ( global ? SymCreate( name ) : SymAlloc( name ) );

	movzx	eax, BYTE PTR global$[rsp]
	test	eax, eax
	je	SHORT $LN6@CreateType
	mov	rcx, QWORD PTR name$[rsp]
	call	SymCreate
	mov	QWORD PTR tv75[rsp], rax
	jmp	SHORT $LN7@CreateType
$LN6@CreateType:
	mov	rcx, QWORD PTR name$[rsp]
	call	SymAlloc
	mov	QWORD PTR tv75[rsp], rax
$LN7@CreateType:
	mov	rax, QWORD PTR tv75[rsp]
	mov	QWORD PTR sym$[rsp], rax
$LN3@CreateType:

; 68   : 
; 69   :     if ( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN4@CreateType

; 70   :         sym->state = SYM_TYPE;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+32], 7

; 71   :         sym->typekind = TYPE_NONE;

	mov	rax, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rax+66], 0

; 72   :         ((struct dsym *)sym)->e.structinfo = si = LclAlloc( sizeof( struct struct_info ) );

	mov	ecx, 32					; 00000020H
	call	LclAlloc
	mov	QWORD PTR si$[rsp], rax
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR si$[rsp]
	mov	QWORD PTR [rax+96], rcx

; 73   :         si->head = NULL;

	mov	rax, QWORD PTR si$[rsp]
	mov	QWORD PTR [rax], 0

; 74   :         si->tail = NULL;

	mov	rax, QWORD PTR si$[rsp]
	mov	QWORD PTR [rax+8], 0

; 75   :         si->alignment = 0;

	mov	rax, QWORD PTR si$[rsp]
	mov	BYTE PTR [rax+28], 0

; 76   :         si->flags = 0;

	mov	rax, QWORD PTR si$[rsp]
	mov	BYTE PTR [rax+29], 0
$LN4@CreateType:

; 77   :     }
; 78   :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]

; 79   : }

	add	rsp, 56					; 00000038H
	ret	0
CreateTypeSymbol ENDP
_TEXT	ENDS
END
