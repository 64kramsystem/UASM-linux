; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	LineStoreCurr:QWORD
COMM	StoreState:BYTE
COMM	UseSavedState:BYTE
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG10814 DB	'SaveState enter', 0aH, 00H
	ORG $+7
$SG10815 DB	'SaveState exit', 0aH, 00H
$SG10838 DB	'StoreLine(>%s<, lst_position=%u): cur=%X', 0aH, 00H
	ORG $+2
$SG10841 DB	'OUT', 00H
$SG10844 DB	'%s', 0aH, 00H
	ORG $+4
$SG10849 DB	'SkipSavedState enter', 0aH, 00H
	ORG $+2
$SG10856 DB	'SaveVariableState(%s)=%d', 0aH, 00H
	ORG $+6
$SG10867 DB	'RestoreState enter', 0aH, 00H
	ORG $+4
$SG10869 DB	'RestoreState: sym >%s<, value=%Xh (hvalue=%Xh), defined='
	DB	'%u', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	FastpassInit
PUBLIC	StoreLine
PUBLIC	SkipSavedState
PUBLIC	RestoreState
PUBLIC	SaveVariableState
EXTRN	isspace:PROC
EXTRN	isalnum:PROC
EXTRN	__acrt_iob_func:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	memcpy:PROC
EXTRN	_memicmp:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymSetCmpFunc:PROC
EXTRN	GetLineNumber:PROC
EXTRN	get_curr_srcfile:PROC
EXTRN	SetOfssize:PROC
EXTRN	SegmentSaveState:PROC
EXTRN	AssumeSaveState:PROC
EXTRN	ContextSaveState:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	MacroLevel:BYTE
EXTRN	list_pos:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
modstate DB	01e0H DUP (?)
LineStore DB	010H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$StoreLine DD imagerel $LN23
	DD	imagerel $LN23+801
	DD	imagerel $unwind$StoreLine
$pdata$SkipSavedState DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$SkipSavedState
$pdata$RestoreState DD imagerel $LN7
	DD	imagerel $LN7+290
	DD	imagerel $unwind$RestoreState
$pdata$SaveVariableState DD imagerel $LN5
	DD	imagerel $LN5+238
	DD	imagerel $unwind$SaveVariableState
$pdata$SaveState DD imagerel SaveState
	DD	imagerel SaveState+128
	DD	imagerel $unwind$SaveState
pdata	ENDS
xdata	SEGMENT
$unwind$StoreLine DD 011201H
	DD	0a212H
$unwind$SkipSavedState DD 010401H
	DD	04204H
$unwind$RestoreState DD 010401H
	DD	08204H
$unwind$SaveVariableState DD 010901H
	DD	06209H
$unwind$SaveState DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\fastpass.c
_TEXT	SEGMENT
SaveState PROC

; 51   : {

	sub	rsp, 40					; 00000028H

; 52   :     DebugMsg1(("SaveState enter\n" ));

	lea	rcx, OFFSET FLAT:$SG10814
	call	DoDebugMsg1

; 53   :     StoreState = TRUE;

	mov	BYTE PTR StoreState, 1

; 54   :     UseSavedState = TRUE;

	mov	BYTE PTR UseSavedState, 1

; 55   :     modstate.init = TRUE;

	mov	BYTE PTR modstate, 1

; 56   :     modstate.Equ.head = modstate.Equ.tail = NULL;

	mov	QWORD PTR modstate+16, 0
	mov	rax, QWORD PTR modstate+16
	mov	QWORD PTR modstate+8, rax

; 57   : 
; 58   :     memcpy( &modstate.modinfo, (uint_8 *)&ModuleInfo + sizeof( struct module_vars ), sizeof( modstate.modinfo ) );

	lea	rax, OFFSET FLAT:ModuleInfo
	add	rax, 320				; 00000140H
	mov	r8d, 456				; 000001c8H
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:modstate+24
	call	memcpy

; 59   : 
; 60   :     SegmentSaveState();

	call	SegmentSaveState

; 61   :     AssumeSaveState();

	call	AssumeSaveState

; 62   :     ContextSaveState(); /* save pushcontext/popcontext stack */

	call	ContextSaveState

; 63   : 
; 64   :     DebugMsg(( "SaveState exit\n" ));

	lea	rcx, OFFSET FLAT:$SG10815
	call	DoDebugMsg

; 65   : }

	add	rsp, 40					; 00000028H
	ret	0
SaveState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\fastpass.c
_TEXT	SEGMENT
p$ = 32
sym$ = 64
SaveVariableState PROC

; 141  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 142  :     struct equ_item *p;
; 143  : 
; 144  :     DebugMsg1(( "SaveVariableState(%s)=%d\n", sym->name, sym->value ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+16]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10856
	call	DoDebugMsg1

; 145  :     sym->issaved = TRUE; /* don't try to save this symbol (anymore) */

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	or	al, 16
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+41], al

; 146  :     p = LclAlloc( sizeof( struct equ_item ) );

	mov	ecx, 32					; 00000020H
	call	LclAlloc
	mov	QWORD PTR p$[rsp], rax

; 147  :     p->next = NULL;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], 0

; 148  :     p->sym = sym;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 149  :     p->lvalue    = sym->value;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax+16], ecx

; 150  :     p->hvalue    = sym->value3264; /* v2.05: added */

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax+20], ecx

; 151  :     p->mem_type  = sym->mem_type;  /* v2.07: added */

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	mov	DWORD PTR [rax+24], ecx

; 152  :     p->isdefined = sym->isdefined;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	mov	rcx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rcx+28], al

; 153  :     if ( modstate.Equ.tail ) {

	cmp	QWORD PTR modstate+16, 0
	je	SHORT $LN2@SaveVariab

; 154  :         modstate.Equ.tail->next = p;

	mov	rax, QWORD PTR modstate+16
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 155  :         modstate.Equ.tail = p;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR modstate+16, rax

; 156  :     } else {

	jmp	SHORT $LN3@SaveVariab
$LN2@SaveVariab:

; 157  :         modstate.Equ.head = modstate.Equ.tail = p;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR modstate+16, rax
	mov	rax, QWORD PTR modstate+16
	mov	QWORD PTR modstate+8, rax
$LN3@SaveVariab:

; 158  :     }
; 159  : //    printf("state of symbol >%s< saved, value=%u, defined=%u\n", sym->name, sym->value, sym->defined);
; 160  : }

	add	rsp, 56					; 00000038H
	ret	0
SaveVariableState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\fastpass.c
_TEXT	SEGMENT
curr$1 = 48
RestoreState PROC

; 164  : {

$LN7:
	sub	rsp, 72					; 00000048H

; 165  :     DebugMsg1(("RestoreState enter\n"));

	lea	rcx, OFFSET FLAT:$SG10867
	call	DoDebugMsg1

; 166  :     if ( modstate.init ) {

	movzx	eax, BYTE PTR modstate
	test	eax, eax
	je	$LN5@RestoreSta

; 167  :         struct equ_item *curr;
; 168  :         /* restore values of assembly time variables */
; 169  :         for ( curr = modstate.Equ.head; curr; curr = curr->next ) {

	mov	rax, QWORD PTR modstate+8
	mov	QWORD PTR curr$1[rsp], rax
	jmp	SHORT $LN4@RestoreSta
$LN2@RestoreSta:
	mov	rax, QWORD PTR curr$1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$1[rsp], rax
$LN4@RestoreSta:
	cmp	QWORD PTR curr$1[rsp], 0
	je	$LN3@RestoreSta

; 170  :             DebugMsg1(("RestoreState: sym >%s<, value=%Xh (hvalue=%Xh), defined=%u\n", curr->sym->name, curr->lvalue, curr->hvalue, curr->isdefined ));

	mov	rax, QWORD PTR curr$1[rsp]
	movzx	eax, BYTE PTR [rax+28]
	mov	rcx, QWORD PTR curr$1[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR curr$1[rsp]
	mov	r9d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$1[rsp]
	mov	r8d, DWORD PTR [rax+16]
	mov	rdx, QWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG10869
	call	DoDebugMsg1

; 171  :             /* v2.07: MT_ABS is obsolete */
; 172  :             //if ( curr->sym->mem_type == MT_ABS ) {
; 173  :                 curr->sym->value     = curr->lvalue;

	mov	rax, QWORD PTR curr$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR curr$1[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax+16], ecx

; 174  :                 curr->sym->value3264 = curr->hvalue;

	mov	rax, QWORD PTR curr$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR curr$1[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	mov	DWORD PTR [rax+56], ecx

; 175  :                 curr->sym->mem_type  = curr->mem_type; /* v2.07: added */

	mov	rax, QWORD PTR curr$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR curr$1[rsp]
	mov	ecx, DWORD PTR [rcx+24]
	mov	DWORD PTR [rax+36], ecx

; 176  :                 curr->sym->isdefined = curr->isdefined;

	mov	rax, QWORD PTR curr$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR curr$1[rsp]
	movzx	ecx, BYTE PTR [rcx+28]
	and	cl, 1
	shl	cl, 1
	movzx	eax, BYTE PTR [rax+40]
	and	al, 253					; 000000fdH
	or	al, cl
	mov	rcx, QWORD PTR curr$1[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rcx+40], al

; 177  :             //}
; 178  :         }

	jmp	$LN2@RestoreSta
$LN3@RestoreSta:

; 179  :         /* fields in module_vars are not to be restored.
; 180  :          * v2.10: the module_vars fields are not saved either.
; 181  :          */
; 182  :         //memcpy( &modstate.modinfo.g, &ModuleInfo.g, sizeof( ModuleInfo.g ) );
; 183  :         memcpy( (char *)&ModuleInfo + sizeof( struct module_vars ), &modstate.modinfo, sizeof( modstate.modinfo ) );

	lea	rax, OFFSET FLAT:ModuleInfo
	add	rax, 320				; 00000140H
	mov	r8d, 456				; 000001c8H
	lea	rdx, OFFSET FLAT:modstate+24
	mov	rcx, rax
	call	memcpy

; 184  :         SetOfssize();

	call	SetOfssize

; 185  :         SymSetCmpFunc();

	call	SymSetCmpFunc
$LN5@RestoreSta:

; 186  :     }
; 187  : 
; 188  : #if 0
; 189  :     /* v2.05: AFAICS this can't happen anymore. */
; 190  :     if ( LineStore.head == NULL ) {
; 191  :         struct line_item *endl = LclAlloc( sizeof( struct line_item ) + 3 );
; 192  :         endl->next = NULL;
; 193  :         endl->srcfile = 0;
; 194  :         endl->lineno = GetLineNumber();
; 195  :         endl->list_pos = 0;
; 196  :         strcpy( endl->line, "END");
; 197  :         LineStore.head = endl;
; 198  :         DebugMsg(("RestoreState: LineStore.head was NULL !!!\n" ));
; 199  :     }
; 200  : #endif
; 201  :     return( LineStore.head );

	mov	rax, QWORD PTR LineStore

; 202  : }

	add	rsp, 72					; 00000048H
	ret	0
RestoreState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\fastpass.c
_TEXT	SEGMENT
SkipSavedState PROC

; 123  : {

$LN3:
	sub	rsp, 40					; 00000028H

; 124  :     DebugMsg(("SkipSavedState enter\n"));

	lea	rcx, OFFSET FLAT:$SG10849
	call	DoDebugMsg

; 125  :     UseSavedState = FALSE;

	mov	BYTE PTR UseSavedState, 0

; 126  : }

	add	rsp, 40					; 00000028H
	ret	0
SkipSavedState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\fastpass.c
_TEXT	SEGMENT
i$ = 32
j$ = 36
tv139 = 40
tv87 = 44
tv131 = 48
p$ = 56
tv77 = 64
srcline$ = 96
flags$ = 104
lst_position$ = 112
StoreLine PROC

; 69   : {

$LN23:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 70   :     int i,j;
; 71   :     char *p;
; 72   : 
; 73   : #ifdef DEBUG_OUT
; 74   :     if ( Options.nofastpass )

	movzx	eax, BYTE PTR Options+17
	test	eax, eax
	je	SHORT $LN5@StoreLine

; 75   :         return;

	jmp	$LN1@StoreLine
$LN5@StoreLine:

; 76   : #endif
; 77   :     if ( ModuleInfo.GeneratedCode ) /* don't store generated lines! */

	cmp	DWORD PTR ModuleInfo+456, 0
	je	SHORT $LN6@StoreLine

; 78   :         return;

	jmp	$LN1@StoreLine
$LN6@StoreLine:

; 79   :     if ( StoreState == FALSE ) /* line store already started? */

	movzx	eax, BYTE PTR StoreState
	test	eax, eax
	jne	SHORT $LN7@StoreLine

; 80   :         SaveState();

	call	SaveState
$LN7@StoreLine:

; 81   : 
; 82   :     i = strlen( srcline );

	mov	rcx, QWORD PTR srcline$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax

; 83   :     j = ( ( ( flags & 1 ) && ModuleInfo.CurrComment ) ? strlen( ModuleInfo.CurrComment ) : 0 );

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN19@StoreLine
	cmp	QWORD PTR ModuleInfo+472, 0
	je	SHORT $LN19@StoreLine
	mov	rcx, QWORD PTR ModuleInfo+472
	call	strlen
	mov	QWORD PTR tv77[rsp], rax
	jmp	SHORT $LN20@StoreLine
$LN19@StoreLine:
	mov	QWORD PTR tv77[rsp], 0
$LN20@StoreLine:
	mov	eax, DWORD PTR tv77[rsp]
	mov	DWORD PTR j$[rsp], eax

; 84   :     LineStoreCurr = LclAlloc( i + j + sizeof( struct line_item ) );

	mov	eax, DWORD PTR j$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	add	rax, 24
	mov	rcx, rax
	call	LclAlloc
	mov	QWORD PTR LineStoreCurr, rax

; 85   :     LineStoreCurr->next = NULL;

	mov	rax, QWORD PTR LineStoreCurr
	mov	QWORD PTR [rax], 0

; 86   :     LineStoreCurr->lineno = GetLineNumber();

	call	GetLineNumber
	mov	DWORD PTR tv87[rsp], eax
	mov	eax, DWORD PTR tv87[rsp]
	and	eax, 1048575				; 000fffffH
	mov	rcx, QWORD PTR LineStoreCurr
	mov	ecx, DWORD PTR [rcx+8]
	and	ecx, -1048576				; fff00000H
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR LineStoreCurr
	mov	DWORD PTR [rcx+8], eax

; 87   :     if ( MacroLevel ) {

	movzx	eax, BYTE PTR MacroLevel
	test	eax, eax
	je	SHORT $LN8@StoreLine

; 88   :         LineStoreCurr->srcfile = 0xfff;

	mov	rax, QWORD PTR LineStoreCurr
	mov	eax, DWORD PTR [rax+8]
	or	eax, -1048576				; fff00000H
	mov	rcx, QWORD PTR LineStoreCurr
	mov	DWORD PTR [rcx+8], eax

; 89   :     } else {

	jmp	SHORT $LN9@StoreLine
$LN8@StoreLine:

; 90   :         LineStoreCurr->srcfile = get_curr_srcfile();

	call	get_curr_srcfile
	mov	DWORD PTR tv131[rsp], eax
	mov	eax, DWORD PTR tv131[rsp]
	and	eax, 4095				; 00000fffH
	shl	eax, 20
	mov	rcx, QWORD PTR LineStoreCurr
	mov	ecx, DWORD PTR [rcx+8]
	and	ecx, 1048575				; 000fffffH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR LineStoreCurr
	mov	DWORD PTR [rcx+8], eax
$LN9@StoreLine:

; 91   :     }
; 92   :     LineStoreCurr->list_pos = ( lst_position ? lst_position : list_pos );

	cmp	DWORD PTR lst_position$[rsp], 0
	je	SHORT $LN21@StoreLine
	mov	eax, DWORD PTR lst_position$[rsp]
	mov	DWORD PTR tv139[rsp], eax
	jmp	SHORT $LN22@StoreLine
$LN21@StoreLine:
	mov	eax, DWORD PTR list_pos
	mov	DWORD PTR tv139[rsp], eax
$LN22@StoreLine:
	mov	rax, QWORD PTR LineStoreCurr
	mov	ecx, DWORD PTR tv139[rsp]
	mov	DWORD PTR [rax+12], ecx

; 93   :     if ( j ) {

	cmp	DWORD PTR j$[rsp], 0
	je	SHORT $LN10@StoreLine

; 94   :         memcpy( LineStoreCurr->line, srcline, i );

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR LineStoreCurr
	add	rcx, 16
	mov	r8, rax
	mov	rdx, QWORD PTR srcline$[rsp]
	call	memcpy

; 95   :         memcpy( LineStoreCurr->line + i, ModuleInfo.CurrComment, j + 1 );

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	cdqe
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR LineStoreCurr
	lea	rcx, QWORD PTR [rdx+rcx+16]
	mov	r8, rax
	mov	rdx, QWORD PTR ModuleInfo+472
	call	memcpy

; 96   :     } else

	jmp	SHORT $LN11@StoreLine
$LN10@StoreLine:

; 97   :         memcpy( LineStoreCurr->line, srcline, i + 1 );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR LineStoreCurr
	add	rcx, 16
	mov	r8, rax
	mov	rdx, QWORD PTR srcline$[rsp]
	call	memcpy
$LN11@StoreLine:

; 98   : 
; 99   :     DebugMsg1(("StoreLine(>%s<, lst_position=%u): cur=%X\n", LineStoreCurr->line, lst_position, LineStoreCurr ));

	mov	rax, QWORD PTR LineStoreCurr
	add	rax, 16
	mov	r9, QWORD PTR LineStoreCurr
	mov	r8d, DWORD PTR lst_position$[rsp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG10838
	call	DoDebugMsg1

; 100  : 
; 101  :     /* v2.08: don't store % operator at pos 0 */
; 102  :     for ( p = LineStoreCurr->line; *p && isspace(*p); p++ );

	mov	rax, QWORD PTR LineStoreCurr
	add	rax, 16
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN4@StoreLine
$LN2@StoreLine:
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN4@StoreLine:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@StoreLine
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isspace
	test	eax, eax
	je	SHORT $LN3@StoreLine
	jmp	SHORT $LN2@StoreLine
$LN3@StoreLine:

; 103  :     if (*p == '%' && ( _memicmp( p+1, "OUT", 3 ) || is_valid_id_char( *(p+4) ) ) )

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN12@StoreLine
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	r8d, 3
	lea	rdx, OFFSET FLAT:$SG10841
	mov	rcx, rax
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN13@StoreLine
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+4]
	mov	ecx, eax
	call	isalnum
	test	eax, eax
	jne	SHORT $LN14@StoreLine
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+4]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN14@StoreLine
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+4]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN14@StoreLine
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+4]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN14@StoreLine
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+4]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN12@StoreLine
$LN14@StoreLine:
$LN13@StoreLine:

; 104  :         *p = ' ';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
$LN12@StoreLine:

; 105  : 
; 106  : #ifdef DEBUG_OUT
; 107  :     if ( Options.print_linestore )

	movzx	eax, BYTE PTR Options+18
	test	eax, eax
	je	SHORT $LN15@StoreLine

; 108  :         printf("%s\n", LineStoreCurr->line );

	mov	rax, QWORD PTR LineStoreCurr
	add	rax, 16
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG10844
	call	printf
$LN15@StoreLine:

; 109  : #endif
; 110  :     if ( LineStore.head )

	cmp	QWORD PTR LineStore, 0
	je	SHORT $LN16@StoreLine

; 111  :         LineStore.tail->next = LineStoreCurr;

	mov	rax, QWORD PTR LineStore+8
	mov	rcx, QWORD PTR LineStoreCurr
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN17@StoreLine
$LN16@StoreLine:

; 112  :     else
; 113  :         LineStore.head = LineStoreCurr;

	mov	rax, QWORD PTR LineStoreCurr
	mov	QWORD PTR LineStore, rax
$LN17@StoreLine:

; 114  :     LineStore.tail = LineStoreCurr;

	mov	rax, QWORD PTR LineStoreCurr
	mov	QWORD PTR LineStore+8, rax
$LN1@StoreLine:

; 115  : }

	add	rsp, 88					; 00000058H
	ret	0
StoreLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\fastpass.c
_TEXT	SEGMENT
FastpassInit PROC

; 224  :     StoreState = FALSE;

	mov	BYTE PTR StoreState, 0

; 225  :     modstate.init = FALSE;

	mov	BYTE PTR modstate, 0

; 226  :     LineStore.head = NULL;

	mov	QWORD PTR LineStore, 0

; 227  :     LineStore.tail = NULL;

	mov	QWORD PTR LineStore+8, 0

; 228  :     UseSavedState = FALSE;

	mov	BYTE PTR UseSavedState, 0

; 229  : }

	ret	0
FastpassInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 950  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 957  : }

	add	rsp, 56					; 00000038H
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 640  : }

	add	rsp, 56					; 00000038H
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
