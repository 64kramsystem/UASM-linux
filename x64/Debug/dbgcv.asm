; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
CONST	SEGMENT
cv_idx_type DW	012H
	ORG $+2
cv_void	DW	03H
	ORG $+2
cv_abs_type DW	01H
	ORG $+2
?padtab@?1??PadBytes@@9@9 DB 0f1H			; `PadBytes'::`2'::padtab
	DB	0f2H
	DB	0f3H
	ORG $+1
reg64	DB	00H
	DB	02H
	DB	03H
	DB	01H
	DB	07H
	DB	06H
	DB	04H
	DB	05H
CONST	ENDS
_DATA	SEGMENT
$SG11269 DB	'cv_write_symbol(%X): INTERN16=%s typeref=%Xh', 0aH, 00H
	ORG $+2
$SG11272 DB	'TLS', 00H
	ORG $+4
$SG11273 DB	'cv_write_symbol(%X): INTERN32=%s typeref=%Xh', 0aH, 00H
	ORG $+2
$SG11329 DB	'dbgcv.c', 00H
$SG11281 DB	'cv_write_symbol(%X): proc=%s, S_BPREL16, var=%s [memt=%X'
	DB	' typeref=%X]', 0aH, 00H
	ORG $+2
$SG11339 DB	'dbgcv.c', 00H
$SG11289 DB	'cv_write_symbol(%X): proc=%s, S_REGREL32, var=%s [memt=%'
	DB	'X typeref=%X]', 0aH, 00H
	ORG $+1
$SG11345 DB	'dbgcv.c', 00H
$SG11290 DB	'cv_write_symbol(%X): proc=%s, S_BPREL32, var=%s [memt=%X'
	DB	' typeref=%X]', 0aH, 00H
	ORG $+2
$SG11328 DB	'cv_write_debug_tables enter', 0aH, 00H
	ORG $+3
$SG11332 DB	'cv_write_debug_tables: at %X objname=%s', 0aH, 00H
	ORG $+7
$SG11337 DB	'cv_write_debug_tables: at %X compiler=%s', 0aH, 00H
	ORG $+6
$SG11346 DB	'cv_write_debug_tables exit, max type=%Xh', 0aH, 00H
	ORG $+6
$SG10883 DB	'GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X', 0aH, 00H
	ORG $+2
$SG10979 DB	'NULL', 00H
	ORG $+3
$SG10980 DB	'%u cv_write_ptr_type(%Xh, typeref=%X ): name=%s [memt=%X'
	DB	' ptr_memt=%X target_type=%s] reftype=%X', 0aH, 00H
	ORG $+3
$SG11060 DB	'@@%u', 00H
	ORG $+7
$SG11036 DB	'%u cv_memberproc(%Xh, %u): struct=%s MEMBER=%s [memt=%X]'
	DB	', typeref=%X', 0aH, 00H
	ORG $+2
$SG11122 DB	'cv_write_type: %s has typekind=TYPE_NONE, ignored!', 0aH
	DB	00H
	ORG $+4
$SG11118 DB	'%u cv_write_type(%Xh): TYPEDEF=%s target type=%s [kind=%'
	DB	'u memt=%X] not defined yet', 0aH, 00H
	ORG $+4
$SG11120 DB	'%u cv_write_type(%Xh): TYPEDEF=%s typeref=%X', 0aH, 00H
	ORG $+2
$SG11124 DB	'%u cv_write_type(%Xh, ref=%X): UNION=%s', 0aH, 00H
	ORG $+7
$SG11127 DB	'%u cv_write_type(%Xh, ref=%X): STRUCT=%s', 0aH, 00H
	ORG $+6
$SG11130 DB	'__unnamed', 00H
	ORG $+6
$SG11131 DB	'%u cv_write_type(%Xh, ref=%X): FIELDLIST, size=%u', 0aH, 00H
	ORG $+5
$SG11247 DB	'cv_write_symbol(%X): TYPE=%s typeref=%Xh', 0aH, 00H
	ORG $+6
$SG11251 DB	'cv_write_symbol(%X): PROC=%s', 0aH, 00H
	ORG $+2
$SG11259 DB	'cv_write_symbol(%X): LABEL16=%s', 0aH, 00H
	ORG $+7
$SG11260 DB	'cv_write_symbol(%X): LABEL32=%s', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	cv_write_debug_tables
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	memcpy:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	SymEnum:PROC
EXTRN	SizeFromMemtype:PROC
EXTRN	GetSymOfssize:PROC
EXTRN	CreateFixup:PROC
EXTRN	store_fixup:PROC
EXTRN	InternalError:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	_RTC_UninitUse:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	szCVCompiler:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$GetTyperef DD imagerel GetTyperef
	DD	imagerel GetTyperef+1228
	DD	imagerel $unwind$GetTyperef
$pdata$GetCVStructLen DD imagerel GetCVStructLen
	DD	imagerel GetCVStructLen+329
	DD	imagerel $unwind$GetCVStructLen
$pdata$PadBytes DD imagerel PadBytes
	DD	imagerel PadBytes+102
	DD	imagerel $unwind$PadBytes
$pdata$cv_write_bitfield DD imagerel cv_write_bitfield
	DD	imagerel cv_write_bitfield+267
	DD	imagerel $unwind$cv_write_bitfield
$pdata$cv_write_array_type DD imagerel cv_write_array_type
	DD	imagerel cv_write_array_type+475
	DD	imagerel $unwind$cv_write_array_type
$pdata$cv_write_ptr_type DD imagerel cv_write_ptr_type
	DD	imagerel cv_write_ptr_type+989
	DD	imagerel $unwind$cv_write_ptr_type
$pdata$cv_write_type DD imagerel cv_write_type
	DD	imagerel cv_write_type+2798
	DD	imagerel $unwind$cv_write_type
$pdata$cv_cntproc DD imagerel cv_cntproc
	DD	imagerel cv_cntproc+396
	DD	imagerel $unwind$cv_cntproc
$pdata$cv_memberproc DD imagerel cv_memberproc
	DD	imagerel cv_memberproc+1061
	DD	imagerel $unwind$cv_memberproc
$pdata$cv_enum_fields DD imagerel cv_enum_fields
	DD	imagerel cv_enum_fields+483
	DD	imagerel $unwind$cv_enum_fields
$pdata$cv_write_type_procedure DD imagerel cv_write_type_procedure
	DD	imagerel cv_write_type_procedure+551
	DD	imagerel $unwind$cv_write_type_procedure
$pdata$cv_get_register DD imagerel cv_get_register
	DD	imagerel cv_get_register+276
	DD	imagerel $unwind$cv_get_register
$pdata$cv_get_x64_regno DD imagerel cv_get_x64_regno
	DD	imagerel cv_get_x64_regno+100
	DD	imagerel $unwind$cv_get_x64_regno
$pdata$cv_write_symbol DD imagerel cv_write_symbol
	DD	imagerel cv_write_symbol+6353
	DD	imagerel $unwind$cv_write_symbol
$pdata$cv_write_debug_tables DD imagerel $LN38
	DD	imagerel $LN38+1781
	DD	imagerel $unwind$cv_write_debug_tables
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
xdata	SEGMENT
$unwind$GetTyperef DD 022201H
	DD	0700a920eH
$unwind$GetCVStructLen DD 022201H
	DD	0700a520eH
$unwind$PadBytes DD 010b01H
	DD	0700bH
$unwind$cv_write_bitfield DD 022801H
	DD	070103214H
$unwind$cv_write_array_type DD 022e01H
	DD	07016721aH
$unwind$cv_write_ptr_type DD 022601H
	DD	0700bd20fH
$unwind$cv_write_type DD 033b19H
	DD	0180112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$cv_cntproc DD 022d01H
	DD	070157219H
$unwind$cv_memberproc DD 023001H
	DD	07015d219H
$unwind$cv_enum_fields DD 023f19H
	DD	07015d219H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$cv_write_type_procedure DD 022801H
	DD	070107214H
$unwind$cv_get_register DD 021e01H
	DD	07006120aH
$unwind$cv_get_x64_regno DD 010601H
	DD	07006H
$unwind$cv_write_symbol DD 032901H
	DD	0240112H
	DD	0700bH
$unwind$cv_write_debug_tables DD 032e01H
	DD	0180117H
	DD	07010H
xdata	ENDS
CONST	SEGMENT
GetTyperef$rtcName$0 DB 076H
	DB	061H
	DB	06cH
	DB	075H
	DB	065H
	DB	00H
	ORG $+2
GetTyperef$rtcVarDesc DD 024H
	DD	02H
	DQ	FLAT:GetTyperef$rtcName$0
	ORG $+48
GetTyperef$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:GetTyperef$rtcVarDesc
cv_write_type$rtcName$0 DB 073H
	DB	069H
	DB	07aH
	DB	065H
	DB	00H
	ORG $+3
cv_write_type$rtcName$1 DB 074H
	DB	06dH
	DB	070H
	DB	00H
cv_write_type$rtcName$2 DB 063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	00H
	ORG $+6
cv_write_type$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:cv_write_type$rtcVarDesc
cv_enum_fields$rtcName$0 DB 074H
	DB	06dH
	DB	070H
	DB	06eH
	DB	061H
	DB	06dH
	DB	065H
	DB	00H
cv_write_type$rtcVarDesc DD 068H
	DD	0cH
	DQ	FLAT:cv_write_type$rtcName$2
	ORG $+48
cv_enum_fields$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:cv_enum_fields$rtcName$0
	ORG $+48
cv_enum_fields$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:cv_enum_fields$rtcVarDesc
cv_write_symbol$rtcName$0 DB 063H
	DB	06eH
	DB	074H
	DB	00H
cv_write_symbol$rtcName$1 DB 06cH
	DB	06fH
	DB	063H
	DB	061H
	DB	06cH
	DB	073H
	DB	00H
	ORG $+5
cv_write_symbol$rtcVarDesc DD 088H
	DD	010H
	DQ	FLAT:cv_write_symbol$rtcName$1
	DD	068H
	DD	08H
	DQ	FLAT:cv_write_symbol$rtcName$0
	ORG $+96
cv_write_symbol$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:cv_write_symbol$rtcVarDesc
cv_write_debug_tables$rtcName$0 DB 069H
	DB	00H
	ORG $+2
cv_write_debug_tables$rtcName$1 DB 063H
	DB	076H
	DB	00H
	ORG $+1
cv_write_debug_tables$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:cv_write_debug_tables$rtcVarDesc
	ORG $+8
cv_write_debug_tables$rtcVarDesc DD 058H
	DD	030H
	DQ	FLAT:cv_write_debug_tables$rtcName$1
	DD	034H
	DD	04H
	DQ	FLAT:cv_write_debug_tables$rtcName$0
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
sym$ = 32
i$ = 52
len$ = 68
objname$ = 72
cv$ = 88
tv74 = 148
tv174 = 152
tv392 = 156
tv192 = 160
tv402 = 164
tv203 = 168
tv244 = 172
tv252 = 176
tv265 = 180
tv277 = 184
symbols$ = 208
types$ = 216
pv$ = 224
cv_write_debug_tables PROC

; 987  : {

$LN38:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 192				; 000000c0H
	mov	rdi, rsp
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+208]

; 988  :     struct asym *sym;
; 989  :     int        i;
; 990  :     int        len;
; 991  :     char       *objname;
; 992  :     struct dbgcv cv;
; 993  : 
; 994  :     DebugMsg(( "cv_write_debug_tables enter\n"));

	lea	rcx, OFFSET FLAT:$SG11328
	call	DoDebugMsg

; 995  : 
; 996  :     /**/myassert( types && symbols && types->sym.state == SYM_SEG &&  symbols->sym.state == SYM_SEG );

	cmp	QWORD PTR types$[rsp], 0
	je	SHORT $LN24@cv_write_d
	cmp	QWORD PTR symbols$[rsp], 0
	je	SHORT $LN24@cv_write_d
	mov	rax, QWORD PTR types$[rsp]
	cmp	DWORD PTR [rax+32], 3
	jne	SHORT $LN24@cv_write_d
	mov	rax, QWORD PTR symbols$[rsp]
	cmp	DWORD PTR [rax+32], 3
	jne	SHORT $LN24@cv_write_d
	mov	DWORD PTR tv74[rsp], 0
	jmp	SHORT $LN25@cv_write_d
$LN24@cv_write_d:
	mov	edx, 996				; 000003e4H
	lea	rcx, OFFSET FLAT:$SG11329
	call	InternalError
	mov	DWORD PTR tv74[rsp], eax
$LN25@cv_write_d:

; 997  : 
; 998  :     cv.ps = symbols->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR symbols$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR cv$[rsp], rax

; 999  :     cv.symbols = symbols;

	mov	rax, QWORD PTR symbols$[rsp]
	mov	QWORD PTR cv$[rsp+8], rax

; 1000 :     cv.pt = types->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR types$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR cv$[rsp+16], rax

; 1001 :     cv.types   = types;

	mov	rax, QWORD PTR types$[rsp]
	mov	QWORD PTR cv$[rsp+24], rax

; 1002 :     cv.currtype = 0x1000; /* user-defined types start at 0x1000 */

	mov	eax, 4096				; 00001000H
	mov	WORD PTR cv$[rsp+44], ax

; 1003 :     cv.level   = 0;

	mov	DWORD PTR cv$[rsp+40], 0

; 1004 :     cv.param = pv;

	mov	rax, QWORD PTR pv$[rsp]
	mov	QWORD PTR cv$[rsp+32], rax

; 1005 : #if GENPTRTYPE
; 1006 :     cv.ptrtype[0] = 0;
; 1007 :     cv.ptrtype[1] = 0;
; 1008 :     cv.ptrtype[2] = 0;
; 1009 : #endif
; 1010 :     /* init types */
; 1011 :     //memset( pt, 0, 1024 ); /* it's ensured to have at least size 1024 */
; 1012 :     *(uint_32 *)cv.pt = Options.debug_symbols; /* "signature" */

	movzx	eax, BYTE PTR Options+2
	mov	rcx, QWORD PTR cv$[rsp+16]
	mov	DWORD PTR [rcx], eax

; 1013 :     cv.pt += sizeof( uint_32 );

	mov	rax, QWORD PTR cv$[rsp+16]
	add	rax, 4
	mov	QWORD PTR cv$[rsp+16], rax

; 1014 : 
; 1015 :     /* init symbols */
; 1016 :     //memset( ps, 0, 1024 ); /* it's ensured to has at least size 1024 */
; 1017 :     *(uint_32 *)cv.ps = Options.debug_symbols; /* "signature" */

	movzx	eax, BYTE PTR Options+2
	mov	rcx, QWORD PTR cv$[rsp]
	mov	DWORD PTR [rcx], eax

; 1018 :     cv.ps += sizeof(uint_32);

	mov	rax, QWORD PTR cv$[rsp]
	add	rax, 4
	mov	QWORD PTR cv$[rsp], rax

; 1019 : 
; 1020 :     /* 1. symbol record: object name */
; 1021 :     objname = CurrFName[OBJ];

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR objname$[rsp], rax

; 1022 :     for ( i = strlen( objname ); i; i-- )

	mov	rcx, QWORD PTR objname$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN4@cv_write_d
$LN2@cv_write_d:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@cv_write_d:
	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN3@cv_write_d

; 1023 :         if ( *(objname+i-1) == '/' || *(objname+i-1) == '\\' )

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR objname$[rsp]
	movsx	eax, BYTE PTR [rcx+rax-1]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN12@cv_write_d
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR objname$[rsp]
	movsx	eax, BYTE PTR [rcx+rax-1]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN11@cv_write_d
$LN12@cv_write_d:

; 1024 :             break;

	jmp	SHORT $LN3@cv_write_d
$LN11@cv_write_d:
	jmp	SHORT $LN2@cv_write_d
$LN3@cv_write_d:

; 1025 :     objname += i;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR objname$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR objname$[rsp], rax

; 1026 :     len = strlen( objname );

	mov	rcx, QWORD PTR objname$[rsp]
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 1027 :     cv.ps_on->sr.size = sizeof( struct cv_symrec_objname ) - sizeof(uint_16) + 1 + len;

	movsxd	rax, DWORD PTR len$[rsp]
	add	rax, 7
	mov	rcx, QWORD PTR cv$[rsp]
	mov	WORD PTR [rcx], ax

; 1028 :     cv.ps_on->sr.type = S_OBJNAME;

	mov	eax, 9
	mov	rcx, QWORD PTR cv$[rsp]
	mov	WORD PTR [rcx+2], ax

; 1029 :     cv.ps_on->Signature = 1;

	mov	rax, QWORD PTR cv$[rsp]
	mov	DWORD PTR [rax+4], 1

; 1030 :     DebugMsg(( "cv_write_debug_tables: at %X objname=%s\n", GetPos(cv.symbols,cv.ps), objname ));

	mov	rax, QWORD PTR cv$[rsp+8]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	mov	rcx, QWORD PTR cv$[rsp+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR cv$[rsp]
	sub	rdx, rcx
	mov	rcx, rdx
	add	rax, rcx
	mov	r8, QWORD PTR objname$[rsp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11332
	call	DoDebugMsg

; 1031 :     cv.ps += sizeof( struct cv_symrec_objname );

	mov	rax, QWORD PTR cv$[rsp]
	add	rax, 8
	mov	QWORD PTR cv$[rsp], rax

; 1032 :     SetPrefixName( cv.ps, objname, len );

	mov	rax, QWORD PTR cv$[rsp]
	movzx	ecx, BYTE PTR len$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR cv$[rsp]
	inc	rax
	mov	QWORD PTR cv$[rsp], rax
	movsxd	rax, DWORD PTR len$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR objname$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	call	memcpy
	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cv$[rsp], rax

; 1033 : 
; 1034 :     /* 2. symbol record: compiler */
; 1035 :     len = strlen( szCVCompiler );

	lea	rcx, OFFSET FLAT:szCVCompiler
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 1036 :     cv.ps_cp->sr.size = sizeof( struct cv_symrec_compile ) - sizeof(uint_16) + 1 + len;

	movsxd	rax, DWORD PTR len$[rsp]
	add	rax, 7
	mov	rcx, QWORD PTR cv$[rsp]
	mov	WORD PTR [rcx], ax

; 1037 :     cv.ps_cp->sr.type = S_COMPILE;

	mov	eax, 1
	mov	rcx, QWORD PTR cv$[rsp]
	mov	WORD PTR [rcx+2], ax

; 1038 : #if AMD64_SUPPORT
; 1039 :     /* v2.11: use a valid 64-bit value */
; 1040 :     cv.ps_cp->machine = ( ModuleInfo.defOfssize == USE64 ? CV_MACH_AMD64 : ( ModuleInfo.curr_cpu & P_CPU_MASK ) >> 4 );

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN26@cv_write_d
	mov	DWORD PTR tv174[rsp], 208		; 000000d0H
	jmp	SHORT $LN27@cv_write_d
$LN26@cv_write_d:
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	sar	eax, 4
	mov	DWORD PTR tv174[rsp], eax
$LN27@cv_write_d:
	mov	rax, QWORD PTR cv$[rsp]
	movzx	ecx, BYTE PTR tv174[rsp]
	mov	BYTE PTR [rax+4], cl

; 1041 : #else
; 1042 :     cv.ps_cp->machine = ( ModuleInfo.curr_cpu & P_CPU_MASK ) >> 4;
; 1043 : #endif
; 1044 :     /* 0 isnt possible, 1 is 8086 and 80186 */
; 1045 :     if ( cv.ps_cp->machine == 0 )

	mov	rax, QWORD PTR cv$[rsp]
	movzx	eax, BYTE PTR [rax+4]
	test	eax, eax
	jne	SHORT $LN13@cv_write_d

; 1046 :         cv.ps_cp->machine = CV_MACH_8086;

	mov	rax, QWORD PTR cv$[rsp]
	mov	BYTE PTR [rax+4], 1
$LN13@cv_write_d:

; 1047 :     cv.ps_cp->Language = CV_LANG_MASM;

	mov	rax, QWORD PTR cv$[rsp]
	mov	BYTE PTR [rax+5], 3

; 1048 :     cv.ps_cp->flags = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR cv$[rsp]
	mov	WORD PTR [rcx+6], ax

; 1049 :     if ( ModuleInfo.model ) {

	cmp	DWORD PTR ModuleInfo+360, 0
	je	$LN14@cv_write_d

; 1050 :         if ( ModuleInfo.model == MODEL_HUGE )

	cmp	DWORD PTR ModuleInfo+360, 6
	jne	SHORT $LN15@cv_write_d

; 1051 :             cv.ps_cp->AmbientData = CV_AMB_HUGE;

	mov	rax, QWORD PTR cv$[rsp]
	movzx	eax, BYTE PTR [rax+6]
	and	al, 31
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR cv$[rsp]
	mov	BYTE PTR [rcx+6], al
	jmp	SHORT $LN16@cv_write_d
$LN15@cv_write_d:

; 1052 :         else
; 1053 :             cv.ps_cp->AmbientData = ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) ? CV_AMB_FAR : CV_AMB_NEAR );

	mov	eax, DWORD PTR ModuleInfo+360
	mov	ecx, 1
	mov	DWORD PTR tv392[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv392[rsp]
	shl	eax, cl
	and	eax, 104				; 00000068H
	test	eax, eax
	je	SHORT $LN28@cv_write_d
	mov	DWORD PTR tv192[rsp], 1
	jmp	SHORT $LN29@cv_write_d
$LN28@cv_write_d:
	mov	DWORD PTR tv192[rsp], 0
$LN29@cv_write_d:
	movzx	eax, BYTE PTR tv192[rsp]
	and	al, 7
	shl	al, 5
	mov	rcx, QWORD PTR cv$[rsp]
	movzx	ecx, BYTE PTR [rcx+6]
	and	cl, 31
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR cv$[rsp]
	mov	BYTE PTR [rcx+6], al
$LN16@cv_write_d:

; 1054 :         cv.ps_cp->AmbientCode = ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ? CV_AMB_FAR : CV_AMB_NEAR );

	mov	eax, DWORD PTR ModuleInfo+360
	mov	ecx, 1
	mov	DWORD PTR tv402[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv402[rsp]
	shl	eax, cl
	and	eax, 112				; 00000070H
	test	eax, eax
	je	SHORT $LN30@cv_write_d
	mov	DWORD PTR tv203[rsp], 1
	jmp	SHORT $LN31@cv_write_d
$LN30@cv_write_d:
	mov	DWORD PTR tv203[rsp], 0
$LN31@cv_write_d:
	movzx	eax, BYTE PTR tv203[rsp]
	and	al, 7
	mov	rcx, QWORD PTR cv$[rsp]
	movzx	ecx, BYTE PTR [rcx+7]
	and	cl, 248					; 000000f8H
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR cv$[rsp]
	mov	BYTE PTR [rcx+7], al
$LN14@cv_write_d:

; 1055 :     }
; 1056 :     DebugMsg(( "cv_write_debug_tables: at %X compiler=%s\n", GetPos(cv.symbols,cv.ps), szCVCompiler ));

	mov	rax, QWORD PTR cv$[rsp+8]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	mov	rcx, QWORD PTR cv$[rsp+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR cv$[rsp]
	sub	rdx, rcx
	mov	rcx, rdx
	add	rax, rcx
	lea	r8, OFFSET FLAT:szCVCompiler
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11337
	call	DoDebugMsg

; 1057 :     cv.ps += sizeof( struct cv_symrec_compile );

	mov	rax, QWORD PTR cv$[rsp]
	add	rax, 8
	mov	QWORD PTR cv$[rsp], rax

; 1058 :     SetPrefixName( cv.ps, szCVCompiler, len );

	mov	rax, QWORD PTR cv$[rsp]
	movzx	ecx, BYTE PTR len$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR cv$[rsp]
	inc	rax
	mov	QWORD PTR cv$[rsp], rax
	movsxd	rax, DWORD PTR len$[rsp]
	mov	r8, rax
	lea	rdx, OFFSET FLAT:szCVCompiler
	mov	rcx, QWORD PTR cv$[rsp]
	call	memcpy
	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cv$[rsp], rax

; 1059 : 
; 1060 :     /* CurrSeg must be set for store_fixup(); v2.12: obsolete */
; 1061 :     //CurrSeg = symbols;
; 1062 : 
; 1063 :     /* scan symbol table for types */
; 1064 : 
; 1065 :     sym = NULL;

	mov	QWORD PTR sym$[rsp], 0
$LN5@cv_write_d:

; 1066 :     while ( sym = SymEnum( sym, &i ) ) {

	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	SymEnum
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN6@cv_write_d

; 1067 :         if ( sym->state == SYM_TYPE && sym->typekind != TYPE_TYPEDEF && sym->cvtyperef == 0 ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN17@cv_write_d
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	je	SHORT $LN17@cv_write_d
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, WORD PTR [rax+64]
	test	eax, eax
	jne	SHORT $LN17@cv_write_d

; 1068 :             /**/myassert( cv.currtype >= 0x1000 ); /* check for overflow */

	movzx	eax, WORD PTR cv$[rsp+44]
	cmp	eax, 4096				; 00001000H
	jl	SHORT $LN32@cv_write_d
	mov	DWORD PTR tv244[rsp], 0
	jmp	SHORT $LN33@cv_write_d
$LN32@cv_write_d:
	mov	edx, 1068				; 0000042cH
	lea	rcx, OFFSET FLAT:$SG11339
	call	InternalError
	mov	DWORD PTR tv244[rsp], eax
$LN33@cv_write_d:

; 1069 :             cv_write_type( &cv, sym );

	mov	rdx, QWORD PTR sym$[rsp]
	lea	rcx, QWORD PTR cv$[rsp]
	call	cv_write_type
$LN17@cv_write_d:

; 1070 :         }
; 1071 :     }

	jmp	$LN5@cv_write_d
$LN6@cv_write_d:

; 1072 : 
; 1073 :     /* scan symbol table for SYM_TYPE, SYM_INTERNAL */
; 1074 : 
; 1075 :     sym = NULL;

	mov	QWORD PTR sym$[rsp], 0
$LN7@cv_write_d:

; 1076 :     while ( sym = SymEnum( sym, &i ) ) {

	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	SymEnum
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	je	$LN8@cv_write_d

; 1077 :         switch ( sym->state ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv252[rsp], eax
	cmp	DWORD PTR tv252[rsp], 1
	je	SHORT $LN20@cv_write_d
	cmp	DWORD PTR tv252[rsp], 7
	je	SHORT $LN18@cv_write_d
	jmp	$LN9@cv_write_d
$LN18@cv_write_d:

; 1078 :         case SYM_TYPE: /* may create an S_UDT entry in the symbols table */
; 1079 :             if ( Options.debug_ext < CVEX_NORMAL ) /* v2.10: no UDTs for -Zi0 and -Zi1 */

	movzx	eax, BYTE PTR Options+3
	cmp	eax, 2
	jge	SHORT $LN19@cv_write_d

; 1080 :                 break;

	jmp	$LN9@cv_write_d
$LN19@cv_write_d:
$LN20@cv_write_d:

; 1081 :         case SYM_INTERNAL:
; 1082 :             if (
; 1083 : #if EQUATESYMS
; 1084 :                 /* emit constants if -Zi3 */
; 1085 :                 ( Options.debug_ext < CVEX_MAX ? sym->isequate : sym->variable )
; 1086 : #else
; 1087 :                 sym->isequate
; 1088 : #endif
; 1089 :                 || sym->predefined ) { /* EQUates? */

	movzx	eax, BYTE PTR Options+3
	cmp	eax, 3
	jge	SHORT $LN34@cv_write_d
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	mov	DWORD PTR tv265[rsp], eax
	jmp	SHORT $LN35@cv_write_d
$LN34@cv_write_d:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	mov	DWORD PTR tv265[rsp], eax
$LN35@cv_write_d:
	cmp	DWORD PTR tv265[rsp], 0
	jne	SHORT $LN22@cv_write_d
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN21@cv_write_d
$LN22@cv_write_d:

; 1090 :                 break;

	jmp	SHORT $LN9@cv_write_d
$LN21@cv_write_d:

; 1091 :             }
; 1092 :             /**/myassert( cv.currtype >= 0x1000 ); /* check for overflow */

	movzx	eax, WORD PTR cv$[rsp+44]
	cmp	eax, 4096				; 00001000H
	jl	SHORT $LN36@cv_write_d
	mov	DWORD PTR tv277[rsp], 0
	jmp	SHORT $LN37@cv_write_d
$LN36@cv_write_d:
	mov	edx, 1092				; 00000444H
	lea	rcx, OFFSET FLAT:$SG11345
	call	InternalError
	mov	DWORD PTR tv277[rsp], eax
$LN37@cv_write_d:

; 1093 :             cv_write_symbol( &cv, sym );

	mov	rdx, QWORD PTR sym$[rsp]
	lea	rcx, QWORD PTR cv$[rsp]
	call	cv_write_symbol
$LN9@cv_write_d:

; 1094 :             break;
; 1095 :         }
; 1096 :     }

	jmp	$LN7@cv_write_d
$LN8@cv_write_d:

; 1097 : 
; 1098 :     /* final flush for both types and symbols.
; 1099 :      * use 'fictional' size of MAX_LINE_LEN * 2!
; 1100 :      */
; 1101 :     checkflush( cv.types, cv.pt, SIZE_CV_SEGBUF, cv.param );

	mov	rax, QWORD PTR cv$[rsp+24]
	mov	rax, QWORD PTR [rax+96]
	mov	r9, QWORD PTR cv$[rsp+32]
	mov	r8d, 1200				; 000004b0H
	mov	rdx, QWORD PTR cv$[rsp+16]
	mov	rcx, QWORD PTR cv$[rsp+24]
	call	QWORD PTR [rax+32]

; 1102 :     checkflush( cv.symbols, cv.ps, SIZE_CV_SEGBUF, cv.param );

	mov	rax, QWORD PTR cv$[rsp+8]
	mov	rax, QWORD PTR [rax+96]
	mov	r9, QWORD PTR cv$[rsp+32]
	mov	r8d, 1200				; 000004b0H
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR cv$[rsp+8]
	call	QWORD PTR [rax+32]

; 1103 :     types->sym.max_offset = types->e.seginfo->current_loc;

	mov	rax, QWORD PTR types$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR types$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+56], eax

; 1104 :     types->e.seginfo->start_loc = 0; /* required for COFF */

	mov	rax, QWORD PTR types$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+8], 0

; 1105 :     symbols->sym.max_offset = symbols->e.seginfo->current_loc;

	mov	rax, QWORD PTR symbols$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR symbols$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+56], eax

; 1106 :     symbols->e.seginfo->start_loc = 0; /* required for COFF */

	mov	rax, QWORD PTR symbols$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+8], 0

; 1107 : 
; 1108 :     //CurrSeg = NULL;
; 1109 :     //Modend = TRUE;
; 1110 : 
; 1111 :     DebugMsg(( "cv_write_debug_tables exit, max type=%Xh\n", cv.currtype - 1 ));

	movzx	eax, WORD PTR cv$[rsp+44]
	dec	eax
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11346
	call	DoDebugMsg

; 1112 :     return;
; 1113 : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:cv_write_debug_tables$rtcFrameData
	call	_RTC_CheckStackVars
	add	rsp, 192				; 000000c0H
	pop	rdi
	ret	0
cv_write_debug_tables ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
len$ = 48
ofs$ = 52
rlctype$ = 56
Ofssize$ = 60
fixup$ = 64
proc$ = 72
lcl$ = 80
i$ = 88
cnt$ = 104
locals$ = 136
typeref$5 = 164
tmp$6 = 168
typeref$7 = 176
cnt$8 = 180
tv1174 = 184
tv231 = 192
tv277 = 196
tv307 = 200
tv322 = 204
tv352 = 208
tv359 = 212
tv389 = 216
tv421 = 220
tv515 = 224
tv569 = 228
tv578 = 232
tv646 = 240
tv1056 = 248
tv1050 = 256
tv1038 = 264
tv1015 = 272
cv$ = 304
sym$ = 312
cv_write_symbol PROC

; 666  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 288				; 00000120H
	mov	rdi, rsp
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+304]

; 667  :     int        len;
; 668  :     unsigned   ofs;
; 669  :     enum fixup_types rlctype;
; 670  :     uint_8     Ofssize;
; 671  :     struct fixup *fixup;
; 672  :     struct dsym *proc;
; 673  :     struct dsym *lcl;
; 674  :     int        i;
; 675  :     int        cnt[2];
; 676  :     struct     dsym *locals[2];
; 677  : 
; 678  :     Ofssize = GetSymOfssize( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSymOfssize
	mov	BYTE PTR Ofssize$[rsp], al

; 679  :     len = GetCVStructLen( sym, Ofssize );

	movzx	edx, BYTE PTR Ofssize$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	GetCVStructLen
	movzx	eax, ax
	mov	DWORD PTR len$[rsp], eax

; 680  :     cv->ps = checkflush( cv->symbols, cv->ps, 1 + sym->name_size + len, cv->param );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	ecx, DWORD PTR len$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR tv1174[rsp], rcx
	mov	rdx, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [rdx+32]
	mov	r8d, eax
	mov	rax, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR tv1174[rsp]
	call	QWORD PTR [rax+32]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax

; 681  : 
; 682  :     if ( sym->state == SYM_TYPE ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 7
	jne	$LN14@cv_write_s

; 683  :         /* Masm does only generate an UDT for typedefs
; 684  :          * if the underlying type is "used" somewhere.
; 685  :          * example:
; 686  :          * LPSTR typedef ptr BYTE
; 687  :          * will only generate an S_UDT for LPSTR if either
; 688  :          * "LPSTR" or "ptr BYTE" is used in the source.
; 689  :          */
; 690  :         cv->ps_udt->sr.size = sizeof( struct cv_symrec_udt ) - sizeof(uint_16) + 1 + sym->name_size;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	add	rax, 5
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rcx], ax

; 691  :         cv->ps_udt->sr.type = S_UDT;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 4
	mov	WORD PTR [rax+2], cx

; 692  :         /* v2.10: pointer typedefs will now have a cv_typeref */
; 693  :         //if ( sym->typekind != TYPE_TYPEDEF ) {
; 694  :         if ( sym->cvtyperef ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, WORD PTR [rax+64]
	test	eax, eax
	je	SHORT $LN15@cv_write_s

; 695  :             cv->ps_udt->type = sym->cvtyperef;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, WORD PTR [rcx+64]
	mov	WORD PTR [rax+4], cx

; 696  :         } else {

	jmp	SHORT $LN16@cv_write_s
$LN15@cv_write_s:

; 697  :             cv->ps_udt->type = GetTyperef( sym, Ofssize );

	movzx	edx, BYTE PTR Ofssize$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	GetTyperef
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rcx+4], ax
$LN16@cv_write_s:

; 698  :         }
; 699  : 
; 700  :         /* Some typedefs won't get a valid type (<name> TYPEDEF PROTO ...).
; 701  :          * In such cases just skip the type!
; 702  :          */
; 703  :         if ( cv->ps_udt->type == 0 )

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax+4]
	test	eax, eax
	jne	SHORT $LN17@cv_write_s

; 704  :             return;

	jmp	$LN1@cv_write_s
$LN17@cv_write_s:

; 705  : 
; 706  :         DebugMsg(( "cv_write_symbol(%X): TYPE=%s typeref=%Xh\n", GetPos(cv->symbols, cv->ps), sym->name, cv->ps_udt->type ));

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax+4]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+12]
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	rdx, QWORD PTR [rdx+96]
	mov	r8, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	r8, QWORD PTR [r8]
	sub	r8, rdx
	mov	rdx, r8
	add	rcx, rdx
	mov	r9d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:$SG11247
	call	DoDebugMsg

; 707  :         cv->ps += len;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax

; 708  :         SetPrefixName( cv->ps, sym->name, sym->name_size );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+72]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	r8d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	memcpy
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	rcx, QWORD PTR cv$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax

; 709  :         return;

	jmp	$LN1@cv_write_s
$LN14@cv_write_s:

; 710  :     }
; 711  : 
; 712  :     /* rest is SYM_INTERNAL */
; 713  :     /* there are 3 types of INTERNAL symbols:
; 714  :      * - numeric constants ( equates, memtype MT_EMPTY )
; 715  :      * - code labels, memtype == MT_NEAR | MT_FAR
; 716  :      *   - procs
; 717  :      *   - simple labels
; 718  :      * - data labels, memtype != MT_NEAR | MT_FAR
; 719  :      */
; 720  : 
; 721  :     if ( sym->isproc && Options.debug_ext >= CVEX_REDUCED ) { /* v2.10: no locals for -Zi0 */

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN18@cv_write_s
	movzx	eax, BYTE PTR Options+3
	cmp	eax, 1
	jl	$LN18@cv_write_s

; 722  : 
; 723  :         proc = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR proc$[rsp], rax

; 724  : 
; 725  :         /* for PROCs, scan parameters and locals and create their types. */
; 726  : 
; 727  :         /* scan local symbols */
; 728  :         locals[0] = proc->e.procinfo->paralist;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR locals$[rsp+rcx], rax

; 729  :         locals[1] = proc->e.procinfo->locallist;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR locals$[rsp+rcx], rax

; 730  :         for ( i = 0; i < 2; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@cv_write_s
$LN2@cv_write_s:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@cv_write_s:
	cmp	DWORD PTR i$[rsp], 2
	jge	$LN3@cv_write_s

; 731  :             cnt[i] = 0;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	DWORD PTR cnt$[rsp+rax*4], 0

; 732  :             for ( lcl = locals[i]; lcl; lcl = lcl->nextparam ) {

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR locals$[rsp+rax*8]
	mov	QWORD PTR lcl$[rsp], rax
	jmp	SHORT $LN7@cv_write_s
$LN5@cv_write_s:
	mov	rax, QWORD PTR lcl$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR lcl$[rsp], rax
$LN7@cv_write_s:
	cmp	QWORD PTR lcl$[rsp], 0
	je	$LN6@cv_write_s

; 733  :                 cv_typeref typeref;
; 734  :                 cnt[i]++;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	eax, DWORD PTR cnt$[rsp+rax*4]
	inc	eax
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	DWORD PTR cnt$[rsp+rcx*4], eax

; 735  :                 typeref = ( lcl->sym.mem_type == MT_PTR ? cv_write_ptr_type( cv, &lcl->sym ) : GetTyperef( &lcl->sym, Ofssize ) );

	mov	rax, QWORD PTR lcl$[rsp]
	cmp	DWORD PTR [rax+36], 195			; 000000c3H
	jne	SHORT $LN53@cv_write_s
	mov	rax, QWORD PTR lcl$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR cv$[rsp]
	call	cv_write_ptr_type
	movzx	eax, ax
	mov	DWORD PTR tv231[rsp], eax
	jmp	SHORT $LN54@cv_write_s
$LN53@cv_write_s:
	mov	rax, QWORD PTR lcl$[rsp]
	movzx	edx, BYTE PTR Ofssize$[rsp]
	mov	rcx, rax
	call	GetTyperef
	movzx	eax, ax
	mov	DWORD PTR tv231[rsp], eax
$LN54@cv_write_s:
	movzx	eax, WORD PTR tv231[rsp]
	mov	WORD PTR typeref$5[rsp], ax

; 736  :                 if ( lcl->sym.isarray ) {

	mov	rax, QWORD PTR lcl$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@cv_write_s

; 737  :                     cv_write_array_type( cv, &lcl->sym, typeref, Ofssize );

	mov	rax, QWORD PTR lcl$[rsp]
	movzx	r9d, BYTE PTR Ofssize$[rsp]
	movzx	r8d, WORD PTR typeref$5[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR cv$[rsp]
	call	cv_write_array_type

; 738  :                     typeref = cv->currtype - 1;

	mov	rax, QWORD PTR cv$[rsp]
	movzx	eax, WORD PTR [rax+44]
	dec	eax
	mov	WORD PTR typeref$5[rsp], ax
$LN20@cv_write_s:

; 739  :                 }
; 740  :                 lcl->sym.ext_idx1 = typeref;

	mov	rax, QWORD PTR lcl$[rsp]
	movzx	ecx, WORD PTR typeref$5[rsp]
	mov	WORD PTR [rax+88], cx

; 741  :             }

	jmp	$LN5@cv_write_s
$LN6@cv_write_s:

; 742  :         }

	jmp	$LN2@cv_write_s
$LN3@cv_write_s:

; 743  : 
; 744  :         DebugMsg(( "cv_write_symbol(%X): PROC=%s\n", GetPos(cv->symbols, cv->ps), sym->name ));

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR [rdx]
	sub	rdx, rcx
	mov	rcx, rdx
	add	rax, rcx
	mov	rcx, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rcx+8]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11251
	call	DoDebugMsg

; 745  :         if ( Ofssize == USE16 ) {

	movzx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	jne	$LN21@cv_write_s

; 746  :             cv->ps_p16->sr.size = sizeof( struct cv_symrec_lproc16 ) - sizeof(uint_16) + 1 + sym->name_size;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	add	rax, 28
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rcx], ax

; 747  :             cv->ps_p16->sr.type = (sym->ispublic ? S_GPROC16 : S_LPROC16);

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN55@cv_write_s
	mov	DWORD PTR tv277[rsp], 261		; 00000105H
	jmp	SHORT $LN56@cv_write_s
$LN55@cv_write_s:
	mov	DWORD PTR tv277[rsp], 260		; 00000104H
$LN56@cv_write_s:
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	ecx, WORD PTR tv277[rsp]
	mov	WORD PTR [rax+2], cx

; 748  :             cv->ps_p16->pParent = 0;  /* filled by CVPACK */

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	DWORD PTR [rax+4], 0

; 749  :             cv->ps_p16->pEnd = 0;     /* filled by CVPACK */

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	DWORD PTR [rax+8], 0

; 750  :             cv->ps_p16->pNext = 0;    /* filled by CVPACK */

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	DWORD PTR [rax+12], 0

; 751  :             cv->ps_p16->proc_length = sym->total_size;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, WORD PTR [rcx+56]
	mov	WORD PTR [rax+16], cx

; 752  :             cv->ps_p16->debug_start = ((struct dsym *)sym)->e.procinfo->size_prolog;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	movzx	eax, BYTE PTR [rax+85]
	mov	WORD PTR [rcx+18], ax

; 753  :             cv->ps_p16->debug_end = sym->total_size;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, WORD PTR [rcx+56]
	mov	WORD PTR [rax+20], cx

; 754  :             cv->ps_p16->offset = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	xor	ecx, ecx
	mov	WORD PTR [rax+22], cx

; 755  :             cv->ps_p16->segment = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	xor	ecx, ecx
	mov	WORD PTR [rax+24], cx

; 756  :             cv->ps_p16->proctype = cv->currtype; /* typeref LF_PROCEDURE */

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR cv$[rsp]
	movzx	ecx, WORD PTR [rcx+44]
	mov	WORD PTR [rax+26], cx

; 757  :             cv->ps_p16->flags = ( sym->mem_type == MT_FAR ? CV_PROCF_FAR : 0 );

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN57@cv_write_s
	mov	DWORD PTR tv307[rsp], 4
	jmp	SHORT $LN58@cv_write_s
$LN57@cv_write_s:
	mov	DWORD PTR tv307[rsp], 0
$LN58@cv_write_s:
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	ecx, BYTE PTR tv307[rsp]
	mov	BYTE PTR [rax+28], cl

; 758  :             rlctype = FIX_PTR16;

	mov	DWORD PTR rlctype$[rsp], 9

; 759  :             ofs = offsetof( struct cv_symrec_lproc16, offset );

	mov	DWORD PTR ofs$[rsp], 22

; 760  :         } else {

	jmp	$LN22@cv_write_s
$LN21@cv_write_s:

; 761  :             cv->ps_p32->sr.size = sizeof( struct cv_symrec_lproc32 ) - sizeof(uint_16) + 1 + sym->name_size;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	add	rax, 36					; 00000024H
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rcx], ax

; 762  :             cv->ps_p32->sr.type = (sym->ispublic ? S_GPROC32 : S_LPROC32 );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN59@cv_write_s
	mov	DWORD PTR tv322[rsp], 517		; 00000205H
	jmp	SHORT $LN60@cv_write_s
$LN59@cv_write_s:
	mov	DWORD PTR tv322[rsp], 516		; 00000204H
$LN60@cv_write_s:
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	ecx, WORD PTR tv322[rsp]
	mov	WORD PTR [rax+2], cx

; 763  :             cv->ps_p32->pParent = 0; /* filled by CVPACK */

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	DWORD PTR [rax+4], 0

; 764  :             cv->ps_p32->pEnd = 0;    /* filled by CVPACK */

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	DWORD PTR [rax+8], 0

; 765  :             cv->ps_p32->pNext = 0;   /* filled by CVPACK */

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	DWORD PTR [rax+12], 0

; 766  :             cv->ps_p32->proc_length = sym->total_size;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax+16], ecx

; 767  :             cv->ps_p32->debug_start = ((struct dsym *)sym)->e.procinfo->size_prolog;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	movzx	eax, BYTE PTR [rax+85]
	mov	DWORD PTR [rcx+20], eax

; 768  :             cv->ps_p32->debug_end = sym->total_size;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax+24], ecx

; 769  :             cv->ps_p32->offset = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	DWORD PTR [rax+28], 0

; 770  :             cv->ps_p32->segment = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	xor	ecx, ecx
	mov	WORD PTR [rax+32], cx

; 771  :             cv->ps_p32->proctype = cv->currtype; /* typeref LF_PROCEDURE */

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR cv$[rsp]
	movzx	ecx, WORD PTR [rcx+44]
	mov	WORD PTR [rax+34], cx

; 772  : #if STACKBASESUPP
; 773  :             cv->ps_p32->flags = ( ( sym->mem_type == MT_FAR ? CV_PROCF_FAR : 0 ) | ( proc->e.procinfo->fpo ? CV_PROCF_FPO : 0 ) );

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN61@cv_write_s
	mov	DWORD PTR tv352[rsp], 4
	jmp	SHORT $LN62@cv_write_s
$LN61@cv_write_s:
	mov	DWORD PTR tv352[rsp], 0
$LN62@cv_write_s:
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+84]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN63@cv_write_s
	mov	DWORD PTR tv359[rsp], 1
	jmp	SHORT $LN64@cv_write_s
$LN63@cv_write_s:
	mov	DWORD PTR tv359[rsp], 0
$LN64@cv_write_s:
	mov	eax, DWORD PTR tv359[rsp]
	mov	ecx, DWORD PTR tv352[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rcx+36], al

; 774  : #else
; 775  :             cv->ps_p32->flags = ( sym->mem_type == MT_FAR ? CV_PROCF_FAR : 0 );
; 776  : #endif
; 777  :             rlctype = FIX_PTR32;

	mov	DWORD PTR rlctype$[rsp], 10

; 778  :             ofs = offsetof( struct cv_symrec_lproc32, offset );

	mov	DWORD PTR ofs$[rsp], 28
$LN22@cv_write_s:

; 779  :         }
; 780  :         cv_write_type_procedure( cv, sym, cnt[0] );

	mov	eax, 4
	imul	rax, rax, 0
	mov	r8d, DWORD PTR cnt$[rsp+rax]
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	call	cv_write_type_procedure
	jmp	$LN19@cv_write_s
$LN18@cv_write_s:

; 781  : 
; 782  :     } else if ( sym->mem_type == MT_NEAR || sym->mem_type == MT_FAR ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 129			; 00000081H
	je	SHORT $LN25@cv_write_s
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	$LN23@cv_write_s
$LN25@cv_write_s:

; 783  : 
; 784  :         if ( Ofssize == USE16 ) {

	movzx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	jne	$LN26@cv_write_s

; 785  :             cv->ps_l16->sr.size = sizeof( struct cv_symrec_label16 ) - sizeof(uint_16) + 1 + sym->name_size;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	add	rax, 8
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rcx], ax

; 786  :             cv->ps_l16->sr.type = S_LABEL16;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 265				; 00000109H
	mov	WORD PTR [rax+2], cx

; 787  :             cv->ps_l16->offset = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	xor	ecx, ecx
	mov	WORD PTR [rax+4], cx

; 788  :             cv->ps_l16->segment = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	xor	ecx, ecx
	mov	WORD PTR [rax+6], cx

; 789  :             cv->ps_l16->flags = ( sym->mem_type == MT_FAR ? CV_PROCF_FAR : 0 );

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN65@cv_write_s
	mov	DWORD PTR tv389[rsp], 4
	jmp	SHORT $LN66@cv_write_s
$LN65@cv_write_s:
	mov	DWORD PTR tv389[rsp], 0
$LN66@cv_write_s:
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	ecx, BYTE PTR tv389[rsp]
	mov	BYTE PTR [rax+8], cl

; 790  :             rlctype = FIX_PTR16;

	mov	DWORD PTR rlctype$[rsp], 9

; 791  :             ofs = offsetof( struct cv_symrec_label16, offset );

	mov	DWORD PTR ofs$[rsp], 4

; 792  :             DebugMsg(( "cv_write_symbol(%X): LABEL16=%s\n", GetPos(cv->symbols,cv->ps), sym->name ));

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR [rdx]
	sub	rdx, rcx
	mov	rcx, rdx
	add	rax, rcx
	mov	rcx, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rcx+8]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11259
	call	DoDebugMsg

; 793  :         } else {

	jmp	$LN27@cv_write_s
$LN26@cv_write_s:

; 794  :             cv->ps_l32->sr.size = sizeof( struct cv_symrec_label32 ) - sizeof(uint_16) + 1 + sym->name_size;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	add	rax, 10
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rcx], ax

; 795  :             cv->ps_l32->sr.type = S_LABEL32;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 521				; 00000209H
	mov	WORD PTR [rax+2], cx

; 796  :             cv->ps_l32->offset = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	DWORD PTR [rax+4], 0

; 797  :             cv->ps_l32->segment = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	xor	ecx, ecx
	mov	WORD PTR [rax+8], cx

; 798  :             cv->ps_l32->flags = ( sym->mem_type == MT_FAR ? CV_PROCF_FAR : 0 );

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN67@cv_write_s
	mov	DWORD PTR tv421[rsp], 4
	jmp	SHORT $LN68@cv_write_s
$LN67@cv_write_s:
	mov	DWORD PTR tv421[rsp], 0
$LN68@cv_write_s:
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	ecx, BYTE PTR tv421[rsp]
	mov	BYTE PTR [rax+10], cl

; 799  :             rlctype = FIX_PTR32;

	mov	DWORD PTR rlctype$[rsp], 10

; 800  :             ofs = offsetof( struct cv_symrec_label32, offset );

	mov	DWORD PTR ofs$[rsp], 4

; 801  :             DebugMsg(( "cv_write_symbol(%X): LABEL32=%s\n", GetPos(cv->symbols,cv->ps), sym->name ));

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR [rdx]
	sub	rdx, rcx
	mov	rcx, rdx
	add	rax, rcx
	mov	rcx, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rcx+8]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11260
	call	DoDebugMsg
$LN27@cv_write_s:

; 802  :         }

	jmp	$LN24@cv_write_s
$LN23@cv_write_s:

; 803  : #if EQUATESYMS
; 804  :     } else if ( sym->isequate ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN28@cv_write_s

; 805  :         cv->ps_con->sr.size = len - sizeof(uint_16) + 1 + sym->name_size;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+72]
	lea	rax, QWORD PTR [rax+rcx-1]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rcx], ax

; 806  :         cv->ps_con->sr.type = S_CONSTANT;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 3
	mov	WORD PTR [rax+2], cx

; 807  :         cv->ps_con->type = cv_abs_type.uvalue;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	ecx, WORD PTR cv_abs_type
	mov	WORD PTR [rax+4], cx

; 808  :         if ( sym->value >= LF_NUMERIC ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+16], 32768		; 00008000H
	jl	SHORT $LN30@cv_write_s

; 809  :             uint_8 *tmp;
; 810  :             cv->ps_con->value = LF_ULONG;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 32772				; 00008004H
	mov	WORD PTR [rax+6], cx

; 811  :             tmp = (uint_8 *)&cv->ps_con->value;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 6
	mov	QWORD PTR tmp$6[rsp], rax

; 812  :             *(uint_32 *)tmp = sym->value;

	mov	rax, QWORD PTR tmp$6[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax], ecx

; 813  :         } else {

	jmp	SHORT $LN31@cv_write_s
$LN30@cv_write_s:

; 814  :             cv->ps_con->value = sym->value;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax+6], cx
$LN31@cv_write_s:

; 815  :         }
; 816  :         cv->ps += len;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax

; 817  :         SetPrefixName( cv->ps, sym->name, sym->name_size );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+72]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	r8d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	memcpy
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	rcx, QWORD PTR cv$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax

; 818  :         return;

	jmp	$LN1@cv_write_s

; 819  : #endif
; 820  :     } else {

	jmp	$LN29@cv_write_s
$LN28@cv_write_s:

; 821  :         /* v2.10: set S_GDATA[16|32] if symbol is public */
; 822  :         cv_typeref typeref;
; 823  : 
; 824  :         if ( sym->isarray ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN32@cv_write_s

; 825  :             typeref = cv->currtype;

	mov	rax, QWORD PTR cv$[rsp]
	movzx	eax, WORD PTR [rax+44]
	mov	WORD PTR typeref$7[rsp], ax

; 826  :             cv_write_array_type( cv, sym, 0, Ofssize );

	movzx	r9d, BYTE PTR Ofssize$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	call	cv_write_array_type

; 827  :         } else

	jmp	SHORT $LN33@cv_write_s
$LN32@cv_write_s:

; 828  :             typeref = GetTyperef( sym, Ofssize );

	movzx	edx, BYTE PTR Ofssize$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	GetTyperef
	mov	WORD PTR typeref$7[rsp], ax
$LN33@cv_write_s:

; 829  : 
; 830  :         if ( Ofssize == USE16 ) {

	movzx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	jne	$LN34@cv_write_s

; 831  :             cv->ps_d16->sr.size = sizeof( struct cv_symrec_ldata16 ) - sizeof(uint_16) + 1 + sym->name_size;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	add	rax, 9
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rcx], ax

; 832  :             cv->ps_d16->sr.type = (sym->ispublic ? S_GDATA16 : S_LDATA16 );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN69@cv_write_s
	mov	DWORD PTR tv515[rsp], 258		; 00000102H
	jmp	SHORT $LN70@cv_write_s
$LN69@cv_write_s:
	mov	DWORD PTR tv515[rsp], 257		; 00000101H
$LN70@cv_write_s:
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	ecx, WORD PTR tv515[rsp]
	mov	WORD PTR [rax+2], cx

; 833  :             cv->ps_d16->offset = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	xor	ecx, ecx
	mov	WORD PTR [rax+4], cx

; 834  :             cv->ps_d16->segment = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	xor	ecx, ecx
	mov	WORD PTR [rax+6], cx

; 835  :             cv->ps_d16->type = typeref;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	ecx, WORD PTR typeref$7[rsp]
	mov	WORD PTR [rax+8], cx

; 836  :             rlctype = FIX_PTR16;

	mov	DWORD PTR rlctype$[rsp], 9

; 837  :             ofs = offsetof( struct cv_symrec_ldata16, offset );

	mov	DWORD PTR ofs$[rsp], 4

; 838  :             DebugMsg(( "cv_write_symbol(%X): INTERN16=%s typeref=%Xh\n", GetPos(cv->symbols,cv->ps), sym->name, cv->ps_d16->type ));

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax+8]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+12]
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	rdx, QWORD PTR [rdx+96]
	mov	r8, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	r8, QWORD PTR [r8]
	sub	r8, rdx
	mov	rdx, r8
	add	rcx, rdx
	mov	r9d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:$SG11269
	call	DoDebugMsg

; 839  :         } else {

	jmp	$LN35@cv_write_s
$LN34@cv_write_s:

; 840  :             cv->ps_d32->sr.size = sizeof( struct cv_symrec_ldata32 ) - sizeof(uint_16) + 1 + sym->name_size;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	add	rax, 11
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rcx], ax

; 841  : #if CVOSUPP
; 842  :             if ( ( ModuleInfo.cv_opt & CVO_STATICTLS ) && ((struct dsym *)sym->segment)->e.seginfo->clsym &&

	movzx	eax, BYTE PTR ModuleInfo+427
	and	eax, 1
	test	eax, eax
	je	$LN36@cv_write_s
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN36@cv_write_s
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+80]
	lea	rdx, OFFSET FLAT:$SG11272
	mov	rcx, QWORD PTR [rax+8]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN36@cv_write_s

; 843  :                 strcmp( ((struct dsym *)sym->segment)->e.seginfo->clsym->name, "TLS" ) == 0 )
; 844  :                 cv->ps_d32->sr.type = (sym->ispublic ? S_GTHREAD32 : S_LTHREAD32 );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN71@cv_write_s
	mov	DWORD PTR tv569[rsp], 526		; 0000020eH
	jmp	SHORT $LN72@cv_write_s
$LN71@cv_write_s:
	mov	DWORD PTR tv569[rsp], 525		; 0000020dH
$LN72@cv_write_s:
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	ecx, WORD PTR tv569[rsp]
	mov	WORD PTR [rax+2], cx
	jmp	SHORT $LN37@cv_write_s
$LN36@cv_write_s:

; 845  :             else
; 846  : #endif
; 847  :             cv->ps_d32->sr.type = (sym->ispublic ? S_GDATA32 : S_LDATA32 );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN73@cv_write_s
	mov	DWORD PTR tv578[rsp], 514		; 00000202H
	jmp	SHORT $LN74@cv_write_s
$LN73@cv_write_s:
	mov	DWORD PTR tv578[rsp], 513		; 00000201H
$LN74@cv_write_s:
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	ecx, WORD PTR tv578[rsp]
	mov	WORD PTR [rax+2], cx
$LN37@cv_write_s:

; 848  :             cv->ps_d32->offset = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	DWORD PTR [rax+4], 0

; 849  :             cv->ps_d32->segment = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	xor	ecx, ecx
	mov	WORD PTR [rax+8], cx

; 850  :             cv->ps_d32->type = typeref;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	ecx, WORD PTR typeref$7[rsp]
	mov	WORD PTR [rax+10], cx

; 851  :             rlctype = FIX_PTR32;

	mov	DWORD PTR rlctype$[rsp], 10

; 852  :             ofs = offsetof( struct cv_symrec_ldata32, offset );

	mov	DWORD PTR ofs$[rsp], 4

; 853  :             DebugMsg(( "cv_write_symbol(%X): INTERN32=%s typeref=%Xh\n", GetPos(cv->symbols,cv->ps), sym->name, cv->ps_d16->type ));

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax+8]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+12]
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	rdx, QWORD PTR [rdx+96]
	mov	r8, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	r8, QWORD PTR [r8]
	sub	r8, rdx
	mov	rdx, r8
	add	rcx, rdx
	mov	r9d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:$SG11273
	call	DoDebugMsg
$LN35@cv_write_s:
$LN29@cv_write_s:
$LN24@cv_write_s:
$LN19@cv_write_s:

; 854  :         }
; 855  :     }
; 856  :     cv->ps += ofs;

	mov	eax, DWORD PTR ofs$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax

; 857  :     cv->symbols->e.seginfo->current_loc = cv->symbols->e.seginfo->start_loc + ( cv->ps - cv->symbols->e.seginfo->CodeBuffer );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR [rdx]
	sub	rdx, rcx
	mov	rcx, rdx
	add	rax, rcx
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+12], eax

; 858  : #if COFF_SUPPORT
; 859  :     /* v2.10: also handle FIX_PTR16 for COFF */
; 860  :     //if ( rlctype == FIX_PTR32 && Options.output_format == OFORMAT_COFF ) {
; 861  :     if ( Options.output_format == OFORMAT_COFF ) {

	cmp	DWORD PTR Options+160, 2
	jne	$LN38@cv_write_s

; 862  :         /* COFF has no "far" fixups. Instead Masm creates a
; 863  :          * section-relative fixup + a section fixup.
; 864  :          */
; 865  :         fixup = CreateFixup( sym, FIX_OFF32_SECREL, OPTJ_NONE );

	xor	r8d, r8d
	mov	edx, 13
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateFixup
	mov	QWORD PTR fixup$[rsp], rax

; 866  :         fixup->locofs = cv->symbols->e.seginfo->current_loc;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+20], eax

; 867  :         store_fixup( fixup, cv->symbols, (int_32 *)cv->ps );

	mov	rax, QWORD PTR cv$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR fixup$[rsp]
	call	store_fixup

; 868  :         fixup = CreateFixup( sym, FIX_SEG, OPTJ_NONE );

	xor	r8d, r8d
	mov	edx, 8
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateFixup
	mov	QWORD PTR fixup$[rsp], rax

; 869  :         //fixup->locofs += sizeof( int_32 );
; 870  :         fixup->locofs = cv->symbols->e.seginfo->current_loc + ( rlctype == FIX_PTR32 ? sizeof( int_32 ) : sizeof ( int_16 ) );

	cmp	DWORD PTR rlctype$[rsp], 10
	jne	SHORT $LN75@cv_write_s
	mov	QWORD PTR tv646[rsp], 4
	jmp	SHORT $LN76@cv_write_s
$LN75@cv_write_s:
	mov	QWORD PTR tv646[rsp], 2
$LN76@cv_write_s:
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	add	rax, QWORD PTR tv646[rsp]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	DWORD PTR [rcx+20], eax

; 871  :         store_fixup( fixup, cv->symbols, (int_32 *)cv->ps );

	mov	rax, QWORD PTR cv$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR fixup$[rsp]
	call	store_fixup

; 872  :     } else {

	jmp	SHORT $LN39@cv_write_s
$LN38@cv_write_s:

; 873  : #endif
; 874  :         fixup = CreateFixup( sym, rlctype, OPTJ_NONE );

	xor	r8d, r8d
	mov	edx, DWORD PTR rlctype$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateFixup
	mov	QWORD PTR fixup$[rsp], rax

; 875  :         fixup->locofs = cv->symbols->e.seginfo->current_loc;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+20], eax

; 876  :         /* todo: for OMF, delay fixup store until checkflush has been called! */
; 877  :         store_fixup( fixup, cv->symbols, (int_32 *)cv->ps );

	mov	rax, QWORD PTR cv$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR fixup$[rsp]
	call	store_fixup
$LN39@cv_write_s:

; 878  : #if COFF_SUPPORT
; 879  :     }
; 880  : #endif
; 881  :     cv->ps += len - ofs;

	mov	eax, DWORD PTR ofs$[rsp]
	mov	ecx, DWORD PTR len$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	rcx, QWORD PTR cv$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax

; 882  : 
; 883  :     SetPrefixName( cv->ps, sym->name, sym->name_size );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+72]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	r8d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	memcpy
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	rcx, QWORD PTR cv$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax

; 884  : 
; 885  :     /* for PROCs, scan parameters and locals.
; 886  :      * to mark the block's end, write an ENDBLK item.
; 887  :      */
; 888  :     if ( sym->isproc && Options.debug_ext >= CVEX_REDUCED ) { /* v2.10: no locals for -Zi0 */

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN40@cv_write_s
	movzx	eax, BYTE PTR Options+3
	cmp	eax, 1
	jl	$LN40@cv_write_s

; 889  : 
; 890  :         /* scan local symbols again */
; 891  :         for ( i = 0; i < 2 ; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN10@cv_write_s
$LN8@cv_write_s:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@cv_write_s:
	cmp	DWORD PTR i$[rsp], 2
	jge	$LN9@cv_write_s

; 892  :             for ( lcl = locals[i]; lcl; lcl = lcl->nextparam ) {

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR locals$[rsp+rax*8]
	mov	QWORD PTR lcl$[rsp], rax
	jmp	SHORT $LN13@cv_write_s
$LN11@cv_write_s:
	mov	rax, QWORD PTR lcl$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR lcl$[rsp], rax
$LN13@cv_write_s:
	cmp	QWORD PTR lcl$[rsp], 0
	je	$LN12@cv_write_s

; 893  : 
; 894  :                 /* FASTCALL register argument? */
; 895  :                 if ( lcl->sym.state == SYM_TMACRO ) {

	mov	rax, QWORD PTR lcl$[rsp]
	cmp	DWORD PTR [rax+32], 10
	jne	$LN41@cv_write_s

; 896  :                     len = sizeof( struct cv_symrec_register );

	mov	DWORD PTR len$[rsp], 8

; 897  :                     cv->ps = checkflush( cv->symbols, cv->ps, 1 + lcl->sym.name_size + len, cv->param );

	mov	rax, QWORD PTR lcl$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	ecx, DWORD PTR len$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR tv1056[rsp], rcx
	mov	rdx, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [rdx+32]
	mov	r8d, eax
	mov	rax, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR tv1056[rsp]
	call	QWORD PTR [rax+32]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax

; 898  :                     cv->ps_reg->sr.size = sizeof( struct cv_symrec_register ) - sizeof(uint_16) + 1 + lcl->sym.name_size;

	mov	rax, QWORD PTR lcl$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	add	rax, 7
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rcx], ax

; 899  :                     cv->ps_reg->sr.type = S_REGISTER;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 2
	mov	WORD PTR [rax+2], cx

; 900  :                     cv->ps_reg->type = lcl->sym.ext_idx1;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR lcl$[rsp]
	movzx	ecx, WORD PTR [rcx+88]
	mov	WORD PTR [rax+4], cx

; 901  :                     cv->ps_reg->registr = cv_get_register( &lcl->sym );

	mov	rax, QWORD PTR lcl$[rsp]
	mov	rcx, rax
	call	cv_get_register
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rcx+6], ax
	jmp	$LN42@cv_write_s
$LN41@cv_write_s:

; 902  :                 } else if ( Ofssize == USE16 ) {

	movzx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	jne	$LN43@cv_write_s

; 903  :                     len = sizeof( struct cv_symrec_bprel16 );

	mov	DWORD PTR len$[rsp], 8

; 904  :                     cv->ps = checkflush( cv->symbols, cv->ps, 1 + lcl->sym.name_size + len, cv->param );

	mov	rax, QWORD PTR lcl$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	ecx, DWORD PTR len$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR tv1050[rsp], rcx
	mov	rdx, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [rdx+32]
	mov	r8d, eax
	mov	rax, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR tv1050[rsp]
	call	QWORD PTR [rax+32]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax

; 905  :                     cv->ps_br16->sr.size = sizeof( struct cv_symrec_bprel16 ) - sizeof(uint_16) + 1 + lcl->sym.name_size;

	mov	rax, QWORD PTR lcl$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	add	rax, 7
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rcx], ax

; 906  :                     cv->ps_br16->sr.type = S_BPREL16;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 256				; 00000100H
	mov	WORD PTR [rax+2], cx

; 907  :                     cv->ps_br16->offset = lcl->sym.offset;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR lcl$[rsp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax+4], cx

; 908  :                     cv->ps_br16->type = lcl->sym.ext_idx1;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR lcl$[rsp]
	movzx	ecx, WORD PTR [rcx+88]
	mov	WORD PTR [rax+6], cx

; 909  :                     DebugMsg(( "cv_write_symbol(%X): proc=%s, S_BPREL16, var=%s [memt=%X typeref=%X]\n",

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax+6]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+12]
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	rdx, QWORD PTR [rdx+96]
	mov	r8, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	r8, QWORD PTR [r8]
	sub	r8, rdx
	mov	rdx, r8
	add	rcx, rdx
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR lcl$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR lcl$[rsp]
	mov	r9, QWORD PTR [rax+8]
	mov	rax, QWORD PTR proc$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:$SG11281
	call	DoDebugMsg

; 910  :                               GetPos(cv->symbols,cv->ps), proc->sym.name, lcl->sym.name, lcl->sym.mem_type, cv->ps_br16->type ));
; 911  :                 } else {

	jmp	$LN44@cv_write_s
$LN43@cv_write_s:

; 912  : #if STACKBASESUPP || AMD64_SUPPORT
; 913  :                     /* v2.11: use S_REGREL if 64-bit or frame reg != [E|BP */
; 914  :                     if (
; 915  : #if AMD64_SUPPORT
; 916  :                         Ofssize == USE64
; 917  : #if STACKBASESUPP
; 918  :                         || ( GetRegNo( proc->e.procinfo->basereg ) != 5 )

	movzx	eax, BYTE PTR Ofssize$[rsp]
	cmp	eax, 2
	je	SHORT $LN47@cv_write_s
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, WORD PTR [rax+86]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	cmp	eax, 5
	je	$LN45@cv_write_s
$LN47@cv_write_s:

; 919  : #endif
; 920  : #else
; 921  :                         GetRegNo( proc->e.procinfo->basereg ) != 5
; 922  : #endif
; 923  :                        ) {
; 924  : 
; 925  :                         len = sizeof( struct cv_symrec_regrel32 );

	mov	DWORD PTR len$[rsp], 12

; 926  :                         cv->ps = checkflush( cv->symbols, cv->ps, 1 + lcl->sym.name_size + len, cv->param );

	mov	rax, QWORD PTR lcl$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	ecx, DWORD PTR len$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR tv1038[rsp], rcx
	mov	rdx, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [rdx+32]
	mov	r8d, eax
	mov	rax, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR tv1038[rsp]
	call	QWORD PTR [rax+32]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax

; 927  :                         cv->ps_rr32->sr.size = sizeof( struct cv_symrec_regrel32 ) - sizeof(uint_16) + 1 + lcl->sym.name_size;

	mov	rax, QWORD PTR lcl$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	add	rax, 11
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rcx], ax

; 928  :                         cv->ps_rr32->sr.type = S_REGREL32;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 524				; 0000020cH
	mov	WORD PTR [rax+2], cx

; 929  :                         cv->ps_rr32->offset = lcl->sym.offset ;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR lcl$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax+4], ecx

; 930  :                         cv->ps_rr32->type = lcl->sym.ext_idx1;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR lcl$[rsp]
	movzx	ecx, WORD PTR [rcx+88]
	mov	WORD PTR [rax+10], cx

; 931  : #if AMD64_SUPPORT
; 932  :                         //if W64F_HABRAN recalculate parameters pozitions
; 933  :                         if (ModuleInfo.win64_flags & W64F_HABRAN){

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	je	$LN48@cv_write_s

; 934  :                           if (lcl->sym.isparam){

	mov	rax, QWORD PTR lcl$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN49@cv_write_s

; 935  :                             int cnt = proc->e.procinfo->pushed_reg;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR cnt$8[rsp], eax

; 936  :                             cnt = cnt * 8;

	mov	eax, DWORD PTR cnt$8[rsp]
	shl	eax, 3
	mov	DWORD PTR cnt$8[rsp], eax

; 937  :                             cnt += lcl->sym.offset + proc->e.procinfo->localsize + proc->e.procinfo->xmmsize; //pointing to RSP

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR lcl$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	add	ecx, DWORD PTR [rax+36]
	mov	eax, ecx
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	add	eax, DWORD PTR [rcx+72]
	mov	ecx, DWORD PTR cnt$8[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR cnt$8[rsp], eax

; 938  :                             cnt -= 8;     //pointing abowe RSP to the shadow space off RCX RDX R8 R9

	mov	eax, DWORD PTR cnt$8[rsp]
	sub	eax, 8
	mov	DWORD PTR cnt$8[rsp], eax

; 939  :                             cv->ps_rr32->offset = cnt;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, DWORD PTR cnt$8[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN49@cv_write_s:
$LN48@cv_write_s:

; 940  :                           }
; 941  :                         }
; 942  :                         /* x64 register numbers are different */
; 943  :                         if ( SpecialTable[ proc->e.procinfo->basereg ].cpu == P_64 )

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, WORD PTR [rax+86]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, WORD PTR [rcx+rax+8]
	cmp	eax, 112				; 00000070H
	jne	SHORT $LN50@cv_write_s

; 944  :                             cv->ps_rr32->reg = cv_get_x64_regno( proc->e.procinfo->basereg );

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	ecx, WORD PTR [rax+86]
	call	cv_get_x64_regno
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rcx+8], ax
	jmp	SHORT $LN51@cv_write_s
$LN50@cv_write_s:

; 945  :                         else
; 946  : #endif
; 947  :                             cv->ps_rr32->reg = GetRegNo( proc->e.procinfo->basereg ) + CV_REG_START32;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, WORD PTR [rax+86]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	add	eax, 17
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rcx+8], ax
$LN51@cv_write_s:

; 948  :                         DebugMsg(( "cv_write_symbol(%X): proc=%s, S_REGREL32, var=%s [memt=%X typeref=%X]\n",

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax+10]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+12]
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	rdx, QWORD PTR [rdx+96]
	mov	r8, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	r8, QWORD PTR [r8]
	sub	r8, rdx
	mov	rdx, r8
	add	rcx, rdx
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR lcl$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR lcl$[rsp]
	mov	r9, QWORD PTR [rax+8]
	mov	rax, QWORD PTR proc$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:$SG11289
	call	DoDebugMsg

; 949  :                                   GetPos(cv->symbols,cv->ps), proc->sym.name, lcl->sym.name, lcl->sym.mem_type, cv->ps_rr32->type ));
; 950  :                     } else {

	jmp	$LN46@cv_write_s
$LN45@cv_write_s:

; 951  : #endif
; 952  :                         len = sizeof( struct cv_symrec_bprel32 );

	mov	DWORD PTR len$[rsp], 10

; 953  :                         cv->ps = checkflush( cv->symbols, cv->ps, 1 + lcl->sym.name_size + len, cv->param );

	mov	rax, QWORD PTR lcl$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	ecx, DWORD PTR len$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR tv1015[rsp], rcx
	mov	rdx, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [rdx+32]
	mov	r8d, eax
	mov	rax, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR tv1015[rsp]
	call	QWORD PTR [rax+32]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax

; 954  :                         cv->ps_br32->sr.size = sizeof( struct cv_symrec_bprel32 ) - sizeof(uint_16) + 1 + lcl->sym.name_size;

	mov	rax, QWORD PTR lcl$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	add	rax, 9
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rcx], ax

; 955  :                         cv->ps_br32->sr.type = S_BPREL32;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 512				; 00000200H
	mov	WORD PTR [rax+2], cx

; 956  :                         cv->ps_br32->offset = lcl->sym.offset;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR lcl$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax+4], ecx

; 957  :                         cv->ps_br32->type = lcl->sym.ext_idx1;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR lcl$[rsp]
	movzx	ecx, WORD PTR [rcx+88]
	mov	WORD PTR [rax+8], cx

; 958  :                         DebugMsg(( "cv_write_symbol(%X): proc=%s, S_BPREL32, var=%s [memt=%X typeref=%X]\n",

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax+8]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+12]
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	rdx, QWORD PTR [rdx+96]
	mov	r8, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	r8, QWORD PTR [r8]
	sub	r8, rdx
	mov	rdx, r8
	add	rcx, rdx
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR lcl$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR lcl$[rsp]
	mov	r9, QWORD PTR [rax+8]
	mov	rax, QWORD PTR proc$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:$SG11290
	call	DoDebugMsg
$LN46@cv_write_s:
$LN44@cv_write_s:
$LN42@cv_write_s:

; 959  :                                   GetPos(cv->symbols,cv->ps), proc->sym.name, lcl->sym.name, lcl->sym.mem_type, cv->ps_br32->type ));
; 960  : #if STACKBASESUPP || AMD64_SUPPORT
; 961  :                     }
; 962  : #endif
; 963  :                 }
; 964  :                 lcl->sym.ext_idx1 = 0; /* to be safe, clear the temp. used field */

	xor	eax, eax
	mov	rcx, QWORD PTR lcl$[rsp]
	mov	WORD PTR [rcx+88], ax

; 965  :                 cv->ps += len;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax

; 966  :                 SetPrefixName( cv->ps, lcl->sym.name, lcl->sym.name_size );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR lcl$[rsp]
	movzx	ecx, BYTE PTR [rcx+72]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR lcl$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	r8d, eax
	mov	rax, QWORD PTR lcl$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	memcpy
	mov	rax, QWORD PTR lcl$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	rcx, QWORD PTR cv$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax

; 967  :             }

	jmp	$LN11@cv_write_s
$LN12@cv_write_s:

; 968  :         }

	jmp	$LN8@cv_write_s
$LN9@cv_write_s:

; 969  : 
; 970  :         cv->ps = checkflush( cv->symbols, cv->ps, sizeof( struct cv_symrec_endblk ), cv->param );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [rcx+32]
	mov	r8d, 4
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	call	QWORD PTR [rax+32]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax

; 971  :         cv->ps_eb->sr.size = sizeof( struct cv_symrec_endblk ) - sizeof(uint_16);

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 2
	mov	WORD PTR [rax], cx

; 972  :         cv->ps_eb->sr.type = S_ENDBLK;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 6
	mov	WORD PTR [rax+2], cx

; 973  :         cv->ps += sizeof( struct cv_symrec_endblk );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 4
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx], rax
$LN40@cv_write_s:
$LN1@cv_write_s:

; 974  :     }
; 975  :     return;
; 976  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:cv_write_symbol$rtcFrameData
	call	_RTC_CheckStackVars
	add	rsp, 288				; 00000120H
	pop	rdi
	ret	0
cv_write_symbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
regno$ = 16
cv_get_x64_regno PROC

; 647  : {

	mov	WORD PTR [rsp+8], cx
	push	rdi

; 648  :     if ( regno >= T_RAX && regno <= T_RDI )

	movzx	eax, WORD PTR regno$[rsp]
	cmp	eax, 115				; 00000073H
	jl	SHORT $LN2@cv_get_x64
	movzx	eax, WORD PTR regno$[rsp]
	cmp	eax, 122				; 0000007aH
	jg	SHORT $LN2@cv_get_x64

; 649  :         return( reg64[ regno - T_RAX ] + CV_REG_AMD64_START64 );

	movzx	eax, WORD PTR regno$[rsp]
	sub	eax, 115				; 00000073H
	cdqe
	lea	rcx, OFFSET FLAT:reg64
	movzx	eax, BYTE PTR [rcx+rax]
	add	eax, 328				; 00000148H
	jmp	SHORT $LN1@cv_get_x64
$LN2@cv_get_x64:

; 650  :     if ( regno >= T_R8 && regno <= T_R15 )

	movzx	eax, WORD PTR regno$[rsp]
	cmp	eax, 123				; 0000007bH
	jl	SHORT $LN3@cv_get_x64
	movzx	eax, WORD PTR regno$[rsp]
	cmp	eax, 130				; 00000082H
	jg	SHORT $LN3@cv_get_x64

; 651  :         return( regno - T_R8 + CV_REG_AMD64_START64 + 8 );

	movzx	eax, WORD PTR regno$[rsp]
	add	eax, 213				; 000000d5H
	jmp	SHORT $LN1@cv_get_x64
$LN3@cv_get_x64:

; 652  :     /* it's a 32-bit register r8d-r15d */
; 653  :     return( regno - T_R8D + CV_REG_AMD64_START32 );

	movzx	eax, WORD PTR regno$[rsp]
	add	eax, 253				; 000000fdH
$LN1@cv_get_x64:

; 654  : 
; 655  : }

	pop	rdi
	ret	0
cv_get_x64_regno ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
regno$ = 0
rc$ = 4
flags$ = 8
i$ = 12
sym$ = 32
cv_get_register PROC

; 612  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 613  :     uint_16 regno;
; 614  :     uint_16 rc = 0;

	xor	eax, eax
	mov	WORD PTR rc$[rsp], ax

; 615  :     unsigned flags;
; 616  :     int i;
; 617  : 
; 618  :     for ( i = 0; i < 2; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@cv_get_reg
$LN2@cv_get_reg:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@cv_get_reg:
	cmp	DWORD PTR i$[rsp], 2
	jge	$LN3@cv_get_reg

; 619  :         if ( sym->regist[i] ) {

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	eax, WORD PTR [rcx+rax*2+48]
	test	eax, eax
	je	$LN5@cv_get_reg

; 620  :             flags = GetValueSp( sym->regist[i] );

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	eax, WORD PTR [rcx+rax*2+48]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR flags$[rsp], eax

; 621  :             regno = 1 + GetRegNo( sym->regist[i] );

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	eax, WORD PTR [rcx+rax*2+48]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	inc	eax
	mov	WORD PTR regno$[rsp], ax

; 622  :             if ( flags & OP_R16 )

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN6@cv_get_reg

; 623  :                 regno += 8;

	movzx	eax, WORD PTR regno$[rsp]
	add	eax, 8
	mov	WORD PTR regno$[rsp], ax
	jmp	SHORT $LN7@cv_get_reg
$LN6@cv_get_reg:

; 624  :             else if ( flags & OP_R32 )

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN8@cv_get_reg

; 625  :                 regno += 16;

	movzx	eax, WORD PTR regno$[rsp]
	add	eax, 16
	mov	WORD PTR regno$[rsp], ax
	jmp	SHORT $LN9@cv_get_reg
$LN8@cv_get_reg:

; 626  :             else if ( flags & OP_SR )

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 24576				; 00006000H
	test	eax, eax
	je	SHORT $LN10@cv_get_reg

; 627  :                 regno += 24;

	movzx	eax, WORD PTR regno$[rsp]
	add	eax, 24
	mov	WORD PTR regno$[rsp], ax
$LN10@cv_get_reg:
$LN9@cv_get_reg:
$LN7@cv_get_reg:

; 628  :             rc |= regno << ( i * 8 );

	movzx	eax, WORD PTR regno$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	shl	ecx, 3
	shl	eax, cl
	movzx	ecx, WORD PTR rc$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	WORD PTR rc$[rsp], ax
$LN5@cv_get_reg:

; 629  :         }
; 630  :     }

	jmp	$LN2@cv_get_reg
$LN3@cv_get_reg:

; 631  :     return( rc );

	movzx	eax, WORD PTR rc$[rsp]

; 632  : }

	add	rsp, 16
	pop	rdi
	ret	0
cv_get_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
size$ = 32
ptr$ = 40
param$ = 48
tv95 = 56
cv$ = 80
sym$ = 88
cnt$ = 96
cv_write_type_procedure PROC

; 439  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 440  :     int         size;
; 441  :     cv_typeref  *ptr;
; 442  :     struct dsym *param;
; 443  : 
; 444  :     size = sizeof( struct cv_typerec_procedure );

	mov	DWORD PTR size$[rsp], 12

; 445  :     cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [rcx+32]
	mov	r8d, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	call	QWORD PTR [rax+32]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 446  :     cv->pt_pr->tr.size = size - sizeof(uint_16);

	movsxd	rax, DWORD PTR size$[rsp]
	sub	rax, 2
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx], ax

; 447  :     cv->pt_pr->tr.leaf = LF_PROCEDURE;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 8
	mov	WORD PTR [rax+2], cx

; 448  :     cv->pt_pr->rvtype = cv_void.uvalue;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	ecx, WORD PTR cv_void
	mov	WORD PTR [rax+4], cx

; 449  :     cv->pt_pr->call = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	BYTE PTR [rax+6], 0

; 450  :     cv->pt_pr->rsvd = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	BYTE PTR [rax+7], 0

; 451  :     cv->pt_pr->numparams = cnt;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	ecx, WORD PTR cnt$[rsp]
	mov	WORD PTR [rax+8], cx

; 452  :     cv->pt_pr->arglist = ++cv->currtype;

	mov	rax, QWORD PTR cv$[rsp]
	movzx	eax, WORD PTR [rax+44]
	inc	ax
	mov	WORD PTR tv95[rsp], ax
	mov	rax, QWORD PTR cv$[rsp]
	movzx	ecx, WORD PTR tv95[rsp]
	mov	WORD PTR [rax+44], cx
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	ecx, WORD PTR tv95[rsp]
	mov	WORD PTR [rax+10], cx

; 453  :     cv->pt += size;

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	add	rax, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 454  :     size = sizeof( struct cv_typerec_arglist ) + cnt * sizeof( cv_typeref );

	movsxd	rax, DWORD PTR cnt$[rsp]
	lea	rax, QWORD PTR [rax+rax+6]
	mov	DWORD PTR size$[rsp], eax

; 455  :     cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [rcx+32]
	mov	r8d, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	call	QWORD PTR [rax+32]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 456  :     cv->pt_al->tr.size = size - sizeof(uint_16);

	movsxd	rax, DWORD PTR size$[rsp]
	sub	rax, 2
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx], ax

; 457  :     cv->pt_al->tr.leaf = LF_ARGLIST;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 513				; 00000201H
	mov	WORD PTR [rax+2], cx

; 458  :     cv->pt_al->argcount = cnt;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	ecx, WORD PTR cnt$[rsp]
	mov	WORD PTR [rax+4], cx

; 459  :     ptr = (cv_typeref *)(cv->pt + sizeof( struct cv_typerec_arglist ) );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	add	rax, 6
	mov	QWORD PTR ptr$[rsp], rax

; 460  :     /* fixme: order might be wrong ( is "push" order ) */
; 461  :     for ( param = ((struct dsym *)sym)->e.procinfo->paralist; param; param = param->nextparam ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR param$[rsp], rax
	jmp	SHORT $LN4@cv_write_t
$LN2@cv_write_t:
	mov	rax, QWORD PTR param$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR param$[rsp], rax
$LN4@cv_write_t:
	cmp	QWORD PTR param$[rsp], 0
	je	SHORT $LN3@cv_write_t

; 462  :         *ptr++ = param->sym.ext_idx1;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	rcx, QWORD PTR param$[rsp]
	movzx	ecx, WORD PTR [rcx+88]
	mov	WORD PTR [rax], cx
	mov	rax, QWORD PTR ptr$[rsp]
	add	rax, 2
	mov	QWORD PTR ptr$[rsp], rax

; 463  :     }

	jmp	SHORT $LN2@cv_write_t
$LN3@cv_write_t:

; 464  :     cv->pt += size;

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	add	rax, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 465  :     cv->currtype++;

	mov	rax, QWORD PTR cv$[rsp]
	movzx	eax, WORD PTR [rax+44]
	inc	ax
	mov	rcx, QWORD PTR cv$[rsp]
	mov	WORD PTR [rcx+44], ax

; 466  :     return;
; 467  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
cv_write_type_procedure ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
i$ = 32
curr$ = 40
pold$4 = 48
tmpname$5 = 72
__$ArrayPad$ = 96
sym$ = 128
enumfunc$ = 136
cv$ = 144
cc$ = 152
cv_enum_fields PROC

; 408  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+128]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 409  :     unsigned i;
; 410  :     struct sfield  *curr;
; 411  :     for ( curr = sym->e.structinfo->head, i = 0; curr; curr = curr->next ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$[rsp], rax
	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@cv_enum_fi
$LN2@cv_enum_fi:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR curr$[rsp], rax
$LN4@cv_enum_fi:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN3@cv_enum_fi

; 412  :         if ( curr->sym.name_size ) { /* has member a name? */

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	test	eax, eax
	je	SHORT $LN5@cv_enum_fi

; 413  :             enumfunc( sym, &curr->sym, cv, cc );

	mov	rax, QWORD PTR curr$[rsp]
	mov	r9, QWORD PTR cc$[rsp]
	mov	r8, QWORD PTR cv$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR sym$[rsp]
	call	QWORD PTR enumfunc$[rsp]
	jmp	$LN6@cv_enum_fi
$LN5@cv_enum_fi:

; 414  :         } else if ( curr->sym.type ) { /* is member a type (struct, union, record)? */

	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN7@cv_enum_fi

; 415  :             cc->ofs += curr->sym.offset;

	mov	rax, QWORD PTR cc$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR curr$[rsp]
	add	eax, DWORD PTR [rcx+16]
	mov	rcx, QWORD PTR cc$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 416  :             cv_enum_fields( (struct dsym *)curr->sym.type, enumfunc, cv, cc );

	mov	r9, QWORD PTR cc$[rsp]
	mov	r8, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR enumfunc$[rsp]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	cv_enum_fields

; 417  :             cc->ofs -= curr->sym.offset;

	mov	rax, QWORD PTR cc$[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	eax, DWORD PTR [rax+8]
	sub	eax, ecx
	mov	rcx, QWORD PTR cc$[rsp]
	mov	DWORD PTR [rcx+8], eax
	jmp	$LN8@cv_enum_fi
$LN7@cv_enum_fi:

; 418  :         } else if ( sym->sym.typekind == TYPE_UNION ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 2
	jne	$LN9@cv_enum_fi

; 419  :             /* v2.11: include anonymous union members.
; 420  :              * to make the MS debugger work with those members, they must have a name -
; 421  :              * a temporary name is generated below which starts with "@@".
; 422  :              */
; 423  :             char *pold = curr->sym.name;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR pold$4[rsp], rax

; 424  :             char tmpname[8];
; 425  :             curr->sym.name_size = sprintf( tmpname, "@@%u", ++i );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	r8d, DWORD PTR i$[rsp]
	lea	rdx, OFFSET FLAT:$SG11060
	lea	rcx, QWORD PTR tmpname$5[rsp]
	call	sprintf
	mov	rcx, QWORD PTR curr$[rsp]
	mov	BYTE PTR [rcx+72], al

; 426  :             curr->sym.name = tmpname;

	mov	rax, QWORD PTR curr$[rsp]
	lea	rcx, QWORD PTR tmpname$5[rsp]
	mov	QWORD PTR [rax+8], rcx

; 427  :             enumfunc( sym, &curr->sym, cv, cc );

	mov	rax, QWORD PTR curr$[rsp]
	mov	r9, QWORD PTR cc$[rsp]
	mov	r8, QWORD PTR cv$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR sym$[rsp]
	call	QWORD PTR enumfunc$[rsp]

; 428  :             curr->sym.name = pold;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR pold$4[rsp]
	mov	QWORD PTR [rax+8], rcx

; 429  :             curr->sym.name_size = 0;

	mov	rax, QWORD PTR curr$[rsp]
	mov	BYTE PTR [rax+72], 0
$LN9@cv_enum_fi:
$LN8@cv_enum_fi:
$LN6@cv_enum_fi:

; 430  :         }
; 431  :     }

	jmp	$LN2@cv_enum_fi
$LN3@cv_enum_fi:

; 432  :     return;
; 433  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:cv_enum_fields$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
cv_enum_fields ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
offset$ = 64
typelen$ = 68
size$ = 72
tmp$ = 80
tv70 = 88
tv72 = 96
tv195 = 104
type$ = 128
mbr$ = 136
cv$ = 144
cc$ = 152
cv_memberproc PROC

; 359  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+128]

; 360  :     uint_32     offset;
; 361  :     int         typelen;
; 362  :     int         size;
; 363  :     uint_8      *tmp;
; 364  : 
; 365  :     offset = ( type->sym.typekind == TYPE_RECORD ? 0 : mbr->offset + cc->ofs );

	mov	rax, QWORD PTR type$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 4
	jne	SHORT $LN7@cv_memberp
	mov	DWORD PTR tv70[rsp], 0
	jmp	SHORT $LN8@cv_memberp
$LN7@cv_memberp:
	mov	rax, QWORD PTR mbr$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR cc$[rsp]
	add	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR tv70[rsp], eax
$LN8@cv_memberp:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR offset$[rsp], eax

; 366  :     typelen = ( offset >= LF_NUMERIC ? sizeof( uint_32 ) : 0 );

	cmp	DWORD PTR offset$[rsp], 32768		; 00008000H
	jb	SHORT $LN9@cv_memberp
	mov	QWORD PTR tv72[rsp], 4
	jmp	SHORT $LN10@cv_memberp
$LN9@cv_memberp:
	mov	QWORD PTR tv72[rsp], 0
$LN10@cv_memberp:
	mov	eax, DWORD PTR tv72[rsp]
	mov	DWORD PTR typelen$[rsp], eax

; 367  :     size = ( sizeof( struct cv_typerec_member ) + typelen + 1 + mbr->name_size + 3 ) & ~3;

	movsxd	rax, DWORD PTR typelen$[rsp]
	mov	rcx, QWORD PTR mbr$[rsp]
	movzx	ecx, BYTE PTR [rcx+72]
	lea	rax, QWORD PTR [rax+rcx+12]
	and	rax, -4
	mov	DWORD PTR size$[rsp], eax

; 368  :     cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [rcx+32]
	mov	r8d, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	call	QWORD PTR [rax+32]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 369  :     cv->pt_mbr->leaf = LF_MEMBER;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 1030				; 00000406H
	mov	WORD PTR [rax], cx

; 370  :     if ( mbr->isarray ) {

	mov	rax, QWORD PTR mbr$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@cv_memberp

; 371  :         cv->pt_mbr->type = mbr->ext_idx1;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR mbr$[rsp]
	movzx	ecx, WORD PTR [rcx+88]
	mov	WORD PTR [rax+2], cx

; 372  :         mbr->ext_idx1 = 0; /* reset the temporarily used field */

	xor	eax, eax
	mov	rcx, QWORD PTR mbr$[rsp]
	mov	WORD PTR [rcx+88], ax

; 373  :     } else

	jmp	SHORT $LN3@cv_memberp
$LN2@cv_memberp:

; 374  :         cv->pt_mbr->type = GetTyperef( mbr, USE16 );

	xor	edx, edx
	mov	rcx, QWORD PTR mbr$[rsp]
	call	GetTyperef
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx+2], ax
$LN3@cv_memberp:

; 375  : 
; 376  :     cv->pt_mbr->attribute.access = CV_ATTR_ACC_PUBLIC;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+4]
	or	ax, 3
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx+4], ax

; 377  :     cv->pt_mbr->attribute.mprop = CV_ATTR_MPR_VANILLA;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 65507				; 0000ffe3H
	movzx	eax, WORD PTR [rax+4]
	and	ax, cx
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx+4], ax

; 378  :     cv->pt_mbr->attribute.pseudo = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 65503				; 0000ffdfH
	movzx	eax, WORD PTR [rax+4]
	and	ax, cx
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx+4], ax

; 379  :     cv->pt_mbr->attribute.noinherit = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 65471				; 0000ffbfH
	movzx	eax, WORD PTR [rax+4]
	and	ax, cx
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx+4], ax

; 380  :     cv->pt_mbr->attribute.noconstruct = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 65407				; 0000ff7fH
	movzx	eax, WORD PTR [rax+4]
	and	ax, cx
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx+4], ax

; 381  :     cv->pt_mbr->attribute.reserved = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 255				; 000000ffH
	movzx	eax, WORD PTR [rax+4]
	and	ax, cx
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx+4], ax

; 382  :     tmp = cv->pt + sizeof( struct cv_typerec_member );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	add	rax, 8
	mov	QWORD PTR tmp$[rsp], rax

; 383  :     if ( typelen == 0 ) {

	cmp	DWORD PTR typelen$[rsp], 0
	jne	SHORT $LN4@cv_memberp

; 384  :         cv->pt_mbr->offset = offset;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	ecx, WORD PTR offset$[rsp]
	mov	WORD PTR [rax+6], cx

; 385  :     } else {

	jmp	SHORT $LN5@cv_memberp
$LN4@cv_memberp:

; 386  :         cv->pt_mbr->offset = LF_ULONG;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 32772				; 00008004H
	mov	WORD PTR [rax+6], cx

; 387  :         *(uint_32 *)tmp = offset;

	mov	rax, QWORD PTR tmp$[rsp]
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rax], ecx

; 388  :         tmp += sizeof( uint_32 );

	mov	rax, QWORD PTR tmp$[rsp]
	add	rax, 4
	mov	QWORD PTR tmp$[rsp], rax
$LN5@cv_memberp:

; 389  :     }
; 390  :     DebugMsg(( "%u cv_memberproc(%Xh, %u): struct=%s MEMBER=%s [memt=%X], typeref=%X\n", cv->level, GetPos(cv->types, cv->pt), cc->cnt++, type->sym.name, mbr->name, mbr->mem_type, cv->pt_mbr->type ));

	mov	rax, QWORD PTR cc$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv195[rsp], eax
	mov	rax, QWORD PTR cc$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR cc$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+2]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR [rdx+16]
	sub	rdx, rcx
	mov	rcx, rdx
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+24]
	mov	rdx, QWORD PTR [rdx+96]
	mov	edx, DWORD PTR [rdx+12]
	add	rdx, rcx
	mov	rcx, rdx
	mov	DWORD PTR [rsp+56], eax
	mov	rax, QWORD PTR mbr$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR mbr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR type$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR tv195[rsp]
	mov	r8, rcx
	mov	rax, QWORD PTR cv$[rsp]
	mov	edx, DWORD PTR [rax+40]
	lea	rcx, OFFSET FLAT:$SG11036
	call	DoDebugMsg

; 391  :     SetPrefixName( tmp, mbr->name, mbr->name_size );

	mov	rax, QWORD PTR tmp$[rsp]
	mov	rcx, QWORD PTR mbr$[rsp]
	movzx	ecx, BYTE PTR [rcx+72]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR tmp$[rsp]
	inc	rax
	mov	QWORD PTR tmp$[rsp], rax
	mov	rax, QWORD PTR mbr$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	r8d, eax
	mov	rax, QWORD PTR mbr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tmp$[rsp]
	call	memcpy
	mov	rax, QWORD PTR mbr$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	rcx, QWORD PTR tmp$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tmp$[rsp], rax

; 392  :     PadBytes( tmp, cv->types->e.seginfo->CodeBuffer );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR tmp$[rsp]
	call	PadBytes

; 393  :     cv->pt += size;

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	add	rax, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 394  :     return;
; 395  : }

	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
cv_memberproc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
numsize$ = 32
offset$ = 36
tv74 = 40
tv76 = 48
type$ = 80
mbr$ = 88
cv$ = 96
cc$ = 104
cv_cntproc PROC

; 326  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 327  :     int      numsize;
; 328  :     uint_32  offset;
; 329  : 
; 330  :     cc->cnt++;

	mov	rax, QWORD PTR cc$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR cc$[rsp]
	mov	DWORD PTR [rcx], eax

; 331  :     offset = ( type->sym.typekind == TYPE_RECORD ? 0 : mbr->offset + cc->ofs );

	mov	rax, QWORD PTR type$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 4
	jne	SHORT $LN7@cv_cntproc
	mov	DWORD PTR tv74[rsp], 0
	jmp	SHORT $LN8@cv_cntproc
$LN7@cv_cntproc:
	mov	rax, QWORD PTR mbr$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR cc$[rsp]
	add	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR tv74[rsp], eax
$LN8@cv_cntproc:
	mov	eax, DWORD PTR tv74[rsp]
	mov	DWORD PTR offset$[rsp], eax

; 332  :     numsize = ( offset >= LF_NUMERIC ? sizeof( uint_32 ) : 0 );

	cmp	DWORD PTR offset$[rsp], 32768		; 00008000H
	jb	SHORT $LN9@cv_cntproc
	mov	QWORD PTR tv76[rsp], 4
	jmp	SHORT $LN10@cv_cntproc
$LN9@cv_cntproc:
	mov	QWORD PTR tv76[rsp], 0
$LN10@cv_cntproc:
	mov	eax, DWORD PTR tv76[rsp]
	mov	DWORD PTR numsize$[rsp], eax

; 333  :     cc->size += ( sizeof( struct cv_typerec_member ) + numsize + mbr->name_size + 1 + 3 ) & ~3;

	movsxd	rax, DWORD PTR numsize$[rsp]
	mov	rcx, QWORD PTR mbr$[rsp]
	movzx	ecx, BYTE PTR [rcx+72]
	lea	rax, QWORD PTR [rax+rcx+12]
	and	rax, -4
	mov	rcx, QWORD PTR cc$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR cc$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 334  : 
; 335  :     /* field cv_typeref can only be queried from SYM_TYPE items! */
; 336  : 
; 337  :     if ( mbr->mem_type == MT_TYPE && mbr->type->cvtyperef == 0 ) {

	mov	rax, QWORD PTR mbr$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN2@cv_cntproc
	mov	rax, QWORD PTR mbr$[rsp]
	mov	rax, QWORD PTR [rax+80]
	movzx	eax, WORD PTR [rax+64]
	test	eax, eax
	jne	SHORT $LN2@cv_cntproc

; 338  :         cv->level++;

	mov	rax, QWORD PTR cv$[rsp]
	mov	eax, DWORD PTR [rax+40]
	inc	eax
	mov	rcx, QWORD PTR cv$[rsp]
	mov	DWORD PTR [rcx+40], eax

; 339  :         cv_write_type( cv, mbr->type );

	mov	rax, QWORD PTR mbr$[rsp]
	mov	rdx, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR cv$[rsp]
	call	cv_write_type

; 340  :         cv->level--;

	mov	rax, QWORD PTR cv$[rsp]
	mov	eax, DWORD PTR [rax+40]
	dec	eax
	mov	rcx, QWORD PTR cv$[rsp]
	mov	DWORD PTR [rcx+40], eax
	jmp	SHORT $LN3@cv_cntproc
$LN2@cv_cntproc:

; 341  :     } else if ( mbr->mem_type == MT_BITS && mbr->cvtyperef == 0 ) {

	mov	rax, QWORD PTR mbr$[rsp]
	cmp	DWORD PTR [rax+36], 193			; 000000c1H
	jne	SHORT $LN4@cv_cntproc
	mov	rax, QWORD PTR mbr$[rsp]
	movzx	eax, WORD PTR [rax+64]
	test	eax, eax
	jne	SHORT $LN4@cv_cntproc

; 342  :         cv_write_bitfield( cv, type, mbr );

	mov	r8, QWORD PTR mbr$[rsp]
	mov	rdx, QWORD PTR type$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	call	cv_write_bitfield
$LN4@cv_cntproc:
$LN3@cv_cntproc:

; 343  :     }
; 344  :     //DebugMsg(( "%u cv_cntproc(%Xh, %u): struct=%s MEMBER=%s [memt=%X type=%s]\n", cv->level, GetPos(cv->types, cv->pt), cc->cnt++, type->sym.name, mbr->name, mbr->mem_type, mbr->type ? mbr->type->name : "NULL" ));
; 345  :     if ( mbr->isarray ) {

	mov	rax, QWORD PTR mbr$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@cv_cntproc

; 346  :         /* temporarily (mis)use ext_idx1 member to store the type;
; 347  :          * this field usually isn't used by struct fields */
; 348  :         mbr->ext_idx1 = cv->currtype;

	mov	rax, QWORD PTR mbr$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	movzx	ecx, WORD PTR [rcx+44]
	mov	WORD PTR [rax+88], cx

; 349  :         cv_write_array_type( cv, mbr, 0, USE16 );

	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, QWORD PTR mbr$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	call	cv_write_array_type
$LN5@cv_cntproc:

; 350  :     }
; 351  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
cv_cntproc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
type$ = 64
tmp$ = 72
namesize$ = 80
typelen$ = 84
size$ = 88
property$ = 92
count$ = 104
$T6 = 144
$T7 = 145
tv172 = 152
tv176 = 160
tv187 = 164
tv195 = 168
tv339 = 176
__$ArrayPad$ = 184
cv$ = 208
sym$ = 216
cv_write_type PROC

; 475  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 192				; 000000c0H
	mov	rdi, rsp
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+208]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	BYTE PTR $T7[rsp], 0
	mov	BYTE PTR $T6[rsp], 0

; 476  :     struct dsym *type = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR type$[rsp], rax

; 477  :     uint_8      *tmp;
; 478  :     int         namesize;
; 479  :     int         typelen;
; 480  :     int         size;
; 481  :     uint_16     property;
; 482  :     struct cv_counters count;
; 483  : 
; 484  :     /* v2.10: handle typedefs. when the types are enumerated,
; 485  :      * typedefs are ignored.
; 486  :      */
; 487  :     if ( sym->typekind == TYPE_TYPEDEF ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	jne	$LN4@cv_write_t

; 488  :         //if ( sym->is_ptr ) {
; 489  :         if ( sym->mem_type == MT_PTR ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 195			; 000000c3H
	jne	$LN6@cv_write_t

; 490  : #if GENPTRTYPE
; 491  :             /* for untyped void pointers use ONE generic definition */
; 492  :             if ( !sym->isfar ) {
; 493  :                 if ( cv->ptrtype[sym->Ofssize] ) {
; 494  :                     sym->cv_typeref = cv->ptrtype[sym->Ofssize];
; 495  :                     return;
; 496  :                 }
; 497  :                 cv->ptrtype[sym->Ofssize] = cv->currtype;
; 498  :             }
; 499  : #endif
; 500  : #if 1
; 501  :             if ( sym->ptr_memtype != MT_PROC && sym->target_type && sym->target_type->cvtyperef == 0 ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	cmp	eax, 128				; 00000080H
	je	$LN7@cv_write_t
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	$LN7@cv_write_t
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+48]
	movzx	eax, WORD PTR [rax+64]
	test	eax, eax
	jne	$LN7@cv_write_t

; 502  :                 DebugMsg(( "%u cv_write_type(%Xh): TYPEDEF=%s target type=%s [kind=%u memt=%X] not defined yet\n",

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	movzx	ecx, BYTE PTR [rcx+66]
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rdx+48]
	mov	r8, QWORD PTR cv$[rsp]
	mov	r8, QWORD PTR [r8+24]
	mov	r8, QWORD PTR [r8+96]
	mov	r8d, DWORD PTR [r8+12]
	mov	r9, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [r9+24]
	mov	r9, QWORD PTR [r9+96]
	mov	r10, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [r9+16]
	mov	r10, QWORD PTR [r10+16]
	sub	r10, r9
	mov	r9, r10
	add	r8, r9
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rsp+48], eax
	mov	DWORD PTR [rsp+40], ecx
	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r9, QWORD PTR [rax+8]
	mov	rax, QWORD PTR cv$[rsp]
	mov	edx, DWORD PTR [rax+40]
	lea	rcx, OFFSET FLAT:$SG11118
	call	DoDebugMsg

; 503  :                           cv->level, GetPos(cv->types, cv->pt), sym->name, sym->target_type->name, sym->target_type->typekind, sym->target_type->mem_type ));
; 504  :                 //cv->level++;
; 505  :                 //sym->cv_typeref = GetTyperef( sym, sym->Ofssize ); /* to avoid circular references! */
; 506  :                 if ( cv->level == 0 ) /* avoid circles */

	mov	rax, QWORD PTR cv$[rsp]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN8@cv_write_t

; 507  :                     cv_write_type( cv, sym->target_type );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR cv$[rsp]
	call	cv_write_type
$LN8@cv_write_t:
$LN7@cv_write_t:

; 508  :                 //cv->level--;
; 509  :             }
; 510  :             sym->cvtyperef = cv_write_ptr_type( cv, sym );

	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	call	cv_write_ptr_type
	mov	rcx, QWORD PTR sym$[rsp]
	mov	WORD PTR [rcx+64], ax

; 511  :             DebugMsg(( "%u cv_write_type(%Xh): TYPEDEF=%s typeref=%X\n", cv->level, GetPos(cv->types, cv->pt), sym->name, sym->cvtyperef ));

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, WORD PTR [rax+64]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+12]
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+24]
	mov	rdx, QWORD PTR [rdx+96]
	mov	r8, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	r8, QWORD PTR [r8+16]
	sub	r8, rdx
	mov	rdx, r8
	add	rcx, rdx
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r9, QWORD PTR [rax+8]
	mov	r8, rcx
	mov	rax, QWORD PTR cv$[rsp]
	mov	edx, DWORD PTR [rax+40]
	lea	rcx, OFFSET FLAT:$SG11120
	call	DoDebugMsg
$LN6@cv_write_t:

; 512  : #else
; 513  :             sym->cv_typeref = cv->currtype++;
; 514  :             size = ( sizeof( struct cv_typerec_pointer ) + sizeof( uint_32 ) );
; 515  :             cv->pt = checkflush( cv->types, cv->pt, size );
; 516  :             cv->pt_ptr->tr.size = size - sizeof(uint_16);
; 517  :             cv->pt_ptr->tr.leaf = LF_POINTER;
; 518  :             if ( sym->Ofssize == USE16 ) {
; 519  :                 cv->pt_ptr->attribute = ( sym->isfar ? CV_TYPE_POINTER_FAR : CV_TYPE_POINTER_NEAR );
; 520  :             } else {
; 521  :                 cv->pt_ptr->attribute = ( sym->isfar ? CV_TYPE_POINTER_FAR32 : CV_TYPE_POINTER_NEAR32 );
; 522  :             }
; 523  :             cv->pt_ptr->pptype = cv_pvoid.s;
; 524  :             *(uint_32 *)( cv->pt + sizeof( struct cv_typerec_pointer ) ) = 0; /* variant */
; 525  :             DebugMsg(( "%u cv_write_type(%Xh, ref=%X): POINTER, attr=%X\n", cv->level, GetPos(cv->types, cv->pt), cv->currtype-1, cv->pt_ptr->attribute ));
; 526  :             cv->pt += size;
; 527  : #endif
; 528  :         }
; 529  :         return;

	jmp	$LN1@cv_write_t
	jmp	SHORT $LN5@cv_write_t
$LN4@cv_write_t:

; 530  :     } else if ( sym->typekind == TYPE_NONE ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	test	eax, eax
	jne	SHORT $LN9@cv_write_t

; 531  :         DebugMsg(( "cv_write_type: %s has typekind=TYPE_NONE, ignored!\n", sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11122
	call	DoDebugMsg

; 532  :         return;

	jmp	$LN1@cv_write_t
$LN9@cv_write_t:
$LN5@cv_write_t:

; 533  :     }
; 534  : 
; 535  :     typelen = ( sym->total_size >= LF_NUMERIC ? sizeof( uint_32 ) : 0 );

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+56], 32768		; 00008000H
	jb	SHORT $LN16@cv_write_t
	mov	QWORD PTR tv172[rsp], 4
	jmp	SHORT $LN17@cv_write_t
$LN16@cv_write_t:
	mov	QWORD PTR tv172[rsp], 0
$LN17@cv_write_t:
	mov	eax, DWORD PTR tv172[rsp]
	mov	DWORD PTR typelen$[rsp], eax

; 536  : 
; 537  :     property = ( cv->level ? CVTSP_ISNESTED : 0 );

	mov	rax, QWORD PTR cv$[rsp]
	cmp	DWORD PTR [rax+40], 0
	je	SHORT $LN18@cv_write_t
	mov	DWORD PTR tv176[rsp], 8
	jmp	SHORT $LN19@cv_write_t
$LN18@cv_write_t:
	mov	DWORD PTR tv176[rsp], 0
$LN19@cv_write_t:
	movzx	eax, WORD PTR tv176[rsp]
	mov	WORD PTR property$[rsp], ax

; 538  : 
; 539  :     /* Count the member fields. If a member's type is unknown, create it! */
; 540  :     count.cnt = 0;

	mov	DWORD PTR count$[rsp], 0

; 541  :     count.size = 0;

	mov	DWORD PTR count$[rsp+4], 0

; 542  :     count.ofs = 0;

	mov	DWORD PTR count$[rsp+8], 0

; 543  :     cv_enum_fields( type, cv_cntproc, cv, &count );

	lea	r9, QWORD PTR count$[rsp]
	mov	r8, QWORD PTR cv$[rsp]
	lea	rdx, OFFSET FLAT:cv_cntproc
	mov	rcx, QWORD PTR type$[rsp]
	call	cv_enum_fields

; 544  : 
; 545  :     /* WinDbg wants embedded structs to have a name - else it won't allow to "open" it. */
; 546  :     namesize = ( sym->name_size ? sym->name_size : 9 );  /* 9 is sizeof("__unnamed") */

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	test	eax, eax
	je	SHORT $LN20@cv_write_t
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	DWORD PTR tv187[rsp], eax
	jmp	SHORT $LN21@cv_write_t
$LN20@cv_write_t:
	mov	DWORD PTR tv187[rsp], 9
$LN21@cv_write_t:
	mov	eax, DWORD PTR tv187[rsp]
	mov	DWORD PTR namesize$[rsp], eax

; 547  : 
; 548  :     sym->cvtyperef = cv->currtype++;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	movzx	ecx, WORD PTR [rcx+44]
	mov	WORD PTR [rax+64], cx
	mov	rax, QWORD PTR cv$[rsp]
	movzx	eax, WORD PTR [rax+44]
	inc	ax
	mov	rcx, QWORD PTR cv$[rsp]
	mov	WORD PTR [rcx+44], ax

; 549  :     switch ( type->sym.typekind ) {

	mov	rax, QWORD PTR type$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	mov	BYTE PTR tv195[rsp], al
	cmp	BYTE PTR tv195[rsp], 1
	je	$LN12@cv_write_t
	cmp	BYTE PTR tv195[rsp], 2
	je	SHORT $LN10@cv_write_t
	cmp	BYTE PTR tv195[rsp], 4
	je	$LN11@cv_write_t
	jmp	$LN2@cv_write_t
$LN10@cv_write_t:

; 550  :     case TYPE_UNION:
; 551  :         DebugMsg(( "%u cv_write_type(%Xh, ref=%X): UNION=%s\n", cv->level, GetPos(cv->types, cv->pt), sym->cvtyperef, sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, WORD PTR [rax+64]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+12]
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+24]
	mov	rdx, QWORD PTR [rdx+96]
	mov	r8, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	r8, QWORD PTR [r8+16]
	sub	r8, rdx
	mov	rdx, r8
	add	rcx, rdx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsp+32], rdx
	mov	r9d, eax
	mov	r8, rcx
	mov	rax, QWORD PTR cv$[rsp]
	mov	edx, DWORD PTR [rax+40]
	lea	rcx, OFFSET FLAT:$SG11124
	call	DoDebugMsg

; 552  :         size = ( sizeof( struct cv_typerec_union ) + typelen + 1 + namesize + 3 ) & ~3;

	movsxd	rax, DWORD PTR typelen$[rsp]
	movsxd	rcx, DWORD PTR namesize$[rsp]
	lea	rax, QWORD PTR [rax+rcx+16]
	and	rax, -4
	mov	BYTE PTR $T6[rsp], 1
	mov	DWORD PTR size$[rsp], eax

; 553  :         cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	cmp	BYTE PTR $T6[rsp], 0
	jne	SHORT $LN24@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$0
	call	_RTC_UninitUse
$LN24@cv_write_t:
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [rcx+32]
	mov	r8d, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	call	QWORD PTR [rax+32]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 554  :         cv->pt_un->tr.size = size - sizeof(uint_16);

	cmp	BYTE PTR $T6[rsp], 0
	jne	SHORT $LN25@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$0
	call	_RTC_UninitUse
$LN25@cv_write_t:
	movsxd	rax, DWORD PTR size$[rsp]
	sub	rax, 2
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx], ax

; 555  :         cv->pt_un->tr.leaf = LF_UNION;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 6
	mov	WORD PTR [rax+2], cx

; 556  :         cv->pt_un->count = count.cnt;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	ecx, WORD PTR count$[rsp]
	mov	WORD PTR [rax+4], cx

; 557  :         cv->pt_un->field = cv->currtype++;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR cv$[rsp]
	movzx	ecx, WORD PTR [rcx+44]
	mov	WORD PTR [rax+6], cx
	mov	rax, QWORD PTR cv$[rsp]
	movzx	eax, WORD PTR [rax+44]
	inc	ax
	mov	rcx, QWORD PTR cv$[rsp]
	mov	WORD PTR [rcx+44], ax

; 558  :         cv->pt_un->property = property;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	ecx, WORD PTR property$[rsp]
	mov	WORD PTR [rax+8], cx

; 559  :         tmp = (uint_8 *)&cv->pt_un->length;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	add	rax, 10
	mov	BYTE PTR $T7[rsp], 1
	mov	QWORD PTR tmp$[rsp], rax

; 560  :         break;

	jmp	$LN2@cv_write_t
$LN11@cv_write_t:

; 561  :     case TYPE_RECORD:
; 562  :         property |= CVTSP_PACKED; /* is "packed" */

	movzx	eax, WORD PTR property$[rsp]
	or	eax, 1
	mov	WORD PTR property$[rsp], ax
$LN12@cv_write_t:

; 563  :         /* no break */
; 564  :     case TYPE_STRUCT:
; 565  :         DebugMsg(( "%u cv_write_type(%Xh, ref=%X): STRUCT=%s\n", cv->level, GetPos(cv->types, cv->pt), sym->cvtyperef, sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, WORD PTR [rax+64]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+12]
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+24]
	mov	rdx, QWORD PTR [rdx+96]
	mov	r8, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	r8, QWORD PTR [r8+16]
	sub	r8, rdx
	mov	rdx, r8
	add	rcx, rdx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsp+32], rdx
	mov	r9d, eax
	mov	r8, rcx
	mov	rax, QWORD PTR cv$[rsp]
	mov	edx, DWORD PTR [rax+40]
	lea	rcx, OFFSET FLAT:$SG11127
	call	DoDebugMsg

; 566  :         size = ( sizeof( struct cv_typerec_structure ) + typelen + 1 + namesize + 3 ) & ~3;

	movsxd	rax, DWORD PTR typelen$[rsp]
	movsxd	rcx, DWORD PTR namesize$[rsp]
	lea	rax, QWORD PTR [rax+rcx+20]
	and	rax, -4
	mov	BYTE PTR $T6[rsp], 1
	mov	DWORD PTR size$[rsp], eax

; 567  :         cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	cmp	BYTE PTR $T6[rsp], 0
	jne	SHORT $LN26@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$0
	call	_RTC_UninitUse
$LN26@cv_write_t:
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [rcx+32]
	mov	r8d, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	call	QWORD PTR [rax+32]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 568  :         cv->pt_st->tr.size = size - sizeof(uint_16);

	cmp	BYTE PTR $T6[rsp], 0
	jne	SHORT $LN27@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$0
	call	_RTC_UninitUse
$LN27@cv_write_t:
	movsxd	rax, DWORD PTR size$[rsp]
	sub	rax, 2
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx], ax

; 569  :         cv->pt_st->tr.leaf = LF_STRUCTURE;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 5
	mov	WORD PTR [rax+2], cx

; 570  :         cv->pt_st->count = count.cnt;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	ecx, WORD PTR count$[rsp]
	mov	WORD PTR [rax+4], cx

; 571  :         cv->pt_st->field = cv->currtype++;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR cv$[rsp]
	movzx	ecx, WORD PTR [rcx+44]
	mov	WORD PTR [rax+6], cx
	mov	rax, QWORD PTR cv$[rsp]
	movzx	eax, WORD PTR [rax+44]
	inc	ax
	mov	rcx, QWORD PTR cv$[rsp]
	mov	WORD PTR [rcx+44], ax

; 572  :         cv->pt_st->property = property;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	ecx, WORD PTR property$[rsp]
	mov	WORD PTR [rax+8], cx

; 573  :         cv->pt_st->dList = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	xor	ecx, ecx
	mov	WORD PTR [rax+10], cx

; 574  :         cv->pt_st->vshape = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	xor	ecx, ecx
	mov	WORD PTR [rax+12], cx

; 575  :         tmp = (uint_8 *)&cv->pt_st->length;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	add	rax, 14
	mov	BYTE PTR $T7[rsp], 1
	mov	QWORD PTR tmp$[rsp], rax
$LN2@cv_write_t:

; 576  :         break;
; 577  :     }
; 578  :     if ( typelen ) {

	cmp	DWORD PTR typelen$[rsp], 0
	je	SHORT $LN13@cv_write_t

; 579  :         ((struct leaf32 *)tmp)->leaf = LF_ULONG;

	cmp	BYTE PTR $T7[rsp], 0
	jne	SHORT $LN28@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$1
	call	_RTC_UninitUse
$LN28@cv_write_t:
	mov	eax, 32772				; 00008004H
	mov	rcx, QWORD PTR tmp$[rsp]
	mov	WORD PTR [rcx], ax

; 580  :         ((struct leaf32 *)tmp)->value32 = sym->total_size;

	cmp	BYTE PTR $T7[rsp], 0
	jne	SHORT $LN29@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$1
	call	_RTC_UninitUse
$LN29@cv_write_t:
	mov	rax, QWORD PTR tmp$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax+4], ecx

; 581  :         tmp += sizeof( struct leaf32 );

	cmp	BYTE PTR $T7[rsp], 0
	jne	SHORT $LN30@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$1
	call	_RTC_UninitUse
$LN30@cv_write_t:
	mov	rax, QWORD PTR tmp$[rsp]
	add	rax, 8
	mov	BYTE PTR $T7[rsp], 1
	mov	QWORD PTR tmp$[rsp], rax

; 582  :     } else {

	jmp	SHORT $LN14@cv_write_t
$LN13@cv_write_t:

; 583  :         *(uint_16 *)tmp = sym->total_size;

	cmp	BYTE PTR $T7[rsp], 0
	jne	SHORT $LN31@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$1
	call	_RTC_UninitUse
$LN31@cv_write_t:
	mov	rax, QWORD PTR tmp$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, WORD PTR [rcx+56]
	mov	WORD PTR [rax], cx

; 584  :         tmp += sizeof( uint_16 );

	cmp	BYTE PTR $T7[rsp], 0
	jne	SHORT $LN32@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$1
	call	_RTC_UninitUse
$LN32@cv_write_t:
	mov	rax, QWORD PTR tmp$[rsp]
	add	rax, 2
	mov	BYTE PTR $T7[rsp], 1
	mov	QWORD PTR tmp$[rsp], rax
$LN14@cv_write_t:

; 585  :     }
; 586  :     SetPrefixName( tmp, sym->name_size ? sym->name : "__unnamed", namesize );

	cmp	BYTE PTR $T7[rsp], 0
	jne	SHORT $LN33@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$1
	call	_RTC_UninitUse
$LN33@cv_write_t:
	mov	rax, QWORD PTR tmp$[rsp]
	movzx	ecx, BYTE PTR namesize$[rsp]
	mov	BYTE PTR [rax], cl
	cmp	BYTE PTR $T7[rsp], 0
	jne	SHORT $LN34@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$1
	call	_RTC_UninitUse
$LN34@cv_write_t:
	mov	rax, QWORD PTR tmp$[rsp]
	inc	rax
	mov	BYTE PTR $T7[rsp], 1
	mov	QWORD PTR tmp$[rsp], rax
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	test	eax, eax
	je	SHORT $LN22@cv_write_t
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv339[rsp], rax
	jmp	SHORT $LN23@cv_write_t
$LN22@cv_write_t:
	lea	rax, OFFSET FLAT:$SG11130
	mov	QWORD PTR tv339[rsp], rax
$LN23@cv_write_t:
	cmp	BYTE PTR $T7[rsp], 0
	jne	SHORT $LN35@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$1
	call	_RTC_UninitUse
$LN35@cv_write_t:
	movsxd	rax, DWORD PTR namesize$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR tv339[rsp]
	mov	rcx, QWORD PTR tmp$[rsp]
	call	memcpy
	cmp	BYTE PTR $T7[rsp], 0
	jne	SHORT $LN36@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$1
	call	_RTC_UninitUse
$LN36@cv_write_t:
	movsxd	rax, DWORD PTR namesize$[rsp]
	mov	rcx, QWORD PTR tmp$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR $T7[rsp], 1
	mov	QWORD PTR tmp$[rsp], rax

; 587  : 
; 588  :     PadBytes( tmp, cv->types->e.seginfo->CodeBuffer );

	cmp	BYTE PTR $T7[rsp], 0
	jne	SHORT $LN37@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$1
	call	_RTC_UninitUse
$LN37@cv_write_t:
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR tmp$[rsp]
	call	PadBytes

; 589  :     cv->pt += size;

	cmp	BYTE PTR $T6[rsp], 0
	jne	SHORT $LN38@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$0
	call	_RTC_UninitUse
$LN38@cv_write_t:
	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	add	rax, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 590  : 
; 591  :     /* write the fieldlist record */
; 592  :     cv->pt = checkflush( cv->types, cv->pt, sizeof( struct cv_typerec_fieldlist ), cv->param );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [rcx+32]
	mov	r8d, 4
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	call	QWORD PTR [rax+32]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 593  :     size = sizeof( struct cv_typerec_fieldlist) + count.size;

	mov	eax, DWORD PTR count$[rsp+4]
	add	rax, 4
	mov	BYTE PTR $T6[rsp], 1
	mov	DWORD PTR size$[rsp], eax

; 594  :     cv->pt_fl->tr.size = size - sizeof(uint_16);

	cmp	BYTE PTR $T6[rsp], 0
	jne	SHORT $LN39@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$0
	call	_RTC_UninitUse
$LN39@cv_write_t:
	movsxd	rax, DWORD PTR size$[rsp]
	sub	rax, 2
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx], ax

; 595  :     cv->pt_fl->tr.leaf = LF_FIELDLIST;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 516				; 00000204H
	mov	WORD PTR [rax+2], cx

; 596  :     DebugMsg(( "%u cv_write_type(%Xh, ref=%X): FIELDLIST, size=%u\n", cv->level, GetPos(cv->types, cv->pt), cv->currtype-1, size ));

	cmp	BYTE PTR $T6[rsp], 0
	jne	SHORT $LN40@cv_write_t
	lea	rcx, OFFSET FLAT:cv_write_type$rtcName$0
	call	_RTC_UninitUse
$LN40@cv_write_t:
	mov	rax, QWORD PTR cv$[rsp]
	movzx	eax, WORD PTR [rax+44]
	dec	eax
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+12]
	mov	rdx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+24]
	mov	rdx, QWORD PTR [rdx+96]
	mov	r8, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	r8, QWORD PTR [r8+16]
	sub	r8, rdx
	mov	rdx, r8
	add	rcx, rdx
	mov	edx, DWORD PTR size$[rsp]
	mov	DWORD PTR [rsp+32], edx
	mov	r9d, eax
	mov	r8, rcx
	mov	rax, QWORD PTR cv$[rsp]
	mov	edx, DWORD PTR [rax+40]
	lea	rcx, OFFSET FLAT:$SG11131
	call	DoDebugMsg

; 597  :     cv->pt += sizeof( struct cv_typerec_fieldlist );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	add	rax, 4
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 598  : 
; 599  :     /* add the struct's members to the fieldlist. */
; 600  :     count.ofs = 0;

	mov	DWORD PTR count$[rsp+8], 0

; 601  : #ifdef DEBUG_OUT
; 602  :     count.cnt = 0;

	mov	DWORD PTR count$[rsp], 0

; 603  : #endif
; 604  :     cv_enum_fields( type, cv_memberproc, cv, &count );

	lea	r9, QWORD PTR count$[rsp]
	mov	r8, QWORD PTR cv$[rsp]
	lea	rdx, OFFSET FLAT:cv_memberproc
	mov	rcx, QWORD PTR type$[rsp]
	call	cv_enum_fields
$LN1@cv_write_t:

; 605  :     return;
; 606  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:cv_write_type$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 192				; 000000c0H
	pop	rdi
	ret	0
cv_write_type ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
size$ = 80
tmpmt$1 = 84
tv137 = 88
tv146 = 92
tv194 = 96
tv228 = 104
cv$ = 128
sym$ = 136
cv_write_ptr_type PROC

; 267  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+128]

; 268  :     int size = ( sizeof( struct cv_typerec_pointer ) + sizeof( uint_32 ) );

	mov	DWORD PTR size$[rsp], 12

; 269  : 
; 270  :     /* for untyped pointers & for function pointers don't create a type, just
; 271  :      * return a void ptr.
; 272  :      */
; 273  :     if ( ( sym->ptr_memtype == MT_EMPTY && sym->target_type == NULL ) || sym->ptr_memtype == MT_PROC )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	cmp	eax, 192				; 000000c0H
	jne	SHORT $LN4@cv_write_p
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN3@cv_write_p
$LN4@cv_write_p:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN2@cv_write_p
$LN3@cv_write_p:

; 274  :         return( GetTyperef( sym, sym->Ofssize ) );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	edx, BYTE PTR [rax+44]
	mov	rcx, QWORD PTR sym$[rsp]
	call	GetTyperef
	jmp	$LN1@cv_write_p
$LN2@cv_write_p:

; 275  : 
; 276  :     cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [rcx+32]
	mov	r8d, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	call	QWORD PTR [rax+32]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 277  :     cv->pt_ptr->tr.size = size - sizeof(uint_16);

	movsxd	rax, DWORD PTR size$[rsp]
	sub	rax, 2
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx], ax

; 278  :     cv->pt_ptr->tr.leaf = LF_POINTER;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 2
	mov	WORD PTR [rax+2], cx

; 279  :     if ( sym->Ofssize == USE16 ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	test	eax, eax
	jne	SHORT $LN5@cv_write_p

; 280  :         cv->pt_ptr->attribute = ( sym->isfar ? CV_TYPE_PTRTYPE_FAR : CV_TYPE_PTRTYPE_NEAR );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@cv_write_p
	mov	DWORD PTR tv137[rsp], 1
	jmp	SHORT $LN15@cv_write_p
$LN14@cv_write_p:
	mov	DWORD PTR tv137[rsp], 0
$LN15@cv_write_p:
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	ecx, WORD PTR tv137[rsp]
	mov	WORD PTR [rax+4], cx

; 281  :     } else {

	jmp	SHORT $LN6@cv_write_p
$LN5@cv_write_p:

; 282  :         cv->pt_ptr->attribute = ( sym->isfar ? CV_TYPE_PTRTYPE_FAR32 : CV_TYPE_PTRTYPE_NEAR32 );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@cv_write_p
	mov	DWORD PTR tv146[rsp], 11
	jmp	SHORT $LN17@cv_write_p
$LN16@cv_write_p:
	mov	DWORD PTR tv146[rsp], 10
$LN17@cv_write_p:
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	ecx, WORD PTR tv146[rsp]
	mov	WORD PTR [rax+4], cx
$LN6@cv_write_p:

; 283  :     }
; 284  :     /* if indirection is > 1, define an untyped pointer - to be improved */
; 285  :     if ( sym->is_ptr > 1 ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+45]
	cmp	eax, 1
	jle	SHORT $LN7@cv_write_p

; 286  :         cv->pt_ptr->type = GetTyperef( sym, sym->Ofssize );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	edx, BYTE PTR [rax+44]
	mov	rcx, QWORD PTR sym$[rsp]
	call	GetTyperef
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx+6], ax
	jmp	$LN8@cv_write_p
$LN7@cv_write_p:

; 287  :     } else if ( sym->target_type ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN9@cv_write_p

; 288  :         /* the target's typeref must have been set here */
; 289  :         if ( sym->target_type->cvtyperef )

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+48]
	movzx	eax, WORD PTR [rax+64]
	test	eax, eax
	je	SHORT $LN11@cv_write_p

; 290  :             cv->pt_ptr->type = sym->target_type->cvtyperef;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	movzx	eax, WORD PTR [rax+64]
	mov	WORD PTR [rcx+6], ax
	jmp	SHORT $LN12@cv_write_p
$LN11@cv_write_p:

; 291  :         else
; 292  :             cv->pt_ptr->type = GetTyperef( sym, sym->Ofssize );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	edx, BYTE PTR [rax+44]
	mov	rcx, QWORD PTR sym$[rsp]
	call	GetTyperef
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx+6], ax
$LN12@cv_write_p:

; 293  :     } else { /* pointer to simple type */

	jmp	SHORT $LN10@cv_write_p
$LN9@cv_write_p:

; 294  :         enum memtype tmpmt = sym->mem_type; /* the target type is tmp. copied to mem_type */

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR tmpmt$1[rsp], eax

; 295  :         sym->mem_type = sym->ptr_memtype;   /* thus GetTyperef() can be used */

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 296  :         cv->pt_ptr->type = GetTyperef( sym, sym->Ofssize );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	edx, BYTE PTR [rax+44]
	mov	rcx, QWORD PTR sym$[rsp]
	call	GetTyperef
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx+6], ax

; 297  :         sym->mem_type = tmpmt;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR tmpmt$1[rsp]
	mov	DWORD PTR [rax+36], ecx
$LN10@cv_write_p:
$LN8@cv_write_p:

; 298  :     }
; 299  :     *(uint_32 *)( cv->pt + sizeof( struct cv_typerec_pointer ) ) = 0; /* variant */

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	DWORD PTR [rax+8], 0

; 300  :     DebugMsg(( "%u cv_write_ptr_type(%Xh, typeref=%X ): name=%s [memt=%X ptr_memt=%X target_type=%s] reftype=%X\n",

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN18@cv_write_p
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv194[rsp], rax
	jmp	SHORT $LN19@cv_write_p
$LN18@cv_write_p:
	lea	rax, OFFSET FLAT:$SG10979
	mov	QWORD PTR tv194[rsp], rax
$LN19@cv_write_p:
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+6]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+46]
	mov	rdx, QWORD PTR cv$[rsp]
	movzx	edx, WORD PTR [rdx+44]
	mov	r8, QWORD PTR cv$[rsp]
	mov	r8, QWORD PTR [r8+24]
	mov	r8, QWORD PTR [r8+96]
	mov	r8d, DWORD PTR [r8+12]
	mov	r9, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [r9+24]
	mov	r9, QWORD PTR [r9+96]
	mov	r10, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [r9+16]
	mov	r10, QWORD PTR [r10+16]
	sub	r10, r9
	mov	r9, r10
	add	r8, r9
	mov	DWORD PTR [rsp+64], eax
	mov	rax, QWORD PTR tv194[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], ecx
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, edx
	mov	rax, QWORD PTR cv$[rsp]
	mov	edx, DWORD PTR [rax+40]
	lea	rcx, OFFSET FLAT:$SG10980
	call	DoDebugMsg

; 301  :               cv->level, GetPos(cv->types, cv->pt), cv->currtype, sym->name, sym->mem_type, sym->ptr_memtype, sym->target_type ? sym->target_type->name : "NULL", cv->pt_ptr->type ));
; 302  :     cv->pt += size;

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	add	rax, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 303  :     return( cv->currtype++ );

	mov	rax, QWORD PTR cv$[rsp]
	movzx	eax, WORD PTR [rax+44]
	mov	WORD PTR tv228[rsp], ax
	mov	rax, QWORD PTR cv$[rsp]
	movzx	eax, WORD PTR [rax+44]
	inc	ax
	mov	rcx, QWORD PTR cv$[rsp]
	mov	WORD PTR [rcx+44], ax
	movzx	eax, WORD PTR tv228[rsp]
$LN1@cv_write_p:

; 304  : }

	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
cv_write_ptr_type ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
tmp$ = 32
typelen$ = 40
size$ = 44
tv66 = 48
tv134 = 56
cv$ = 80
sym$ = 88
elemtype$ = 96
Ofssize$ = 104
cv_write_array_type PROC

; 234  : {

	mov	BYTE PTR [rsp+32], r9b
	mov	WORD PTR [rsp+24], r8w
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 235  :     uint_8      *tmp;
; 236  :     int         typelen;
; 237  :     int         size;
; 238  : 
; 239  :     typelen = ( sym->total_size >= LF_NUMERIC ? sizeof( uint_32 ) : 0 );

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+56], 32768		; 00008000H
	jb	SHORT $LN5@cv_write_a
	mov	QWORD PTR tv66[rsp], 4
	jmp	SHORT $LN6@cv_write_a
$LN5@cv_write_a:
	mov	QWORD PTR tv66[rsp], 0
$LN6@cv_write_a:
	mov	eax, DWORD PTR tv66[rsp]
	mov	DWORD PTR typelen$[rsp], eax

; 240  :     size = ( sizeof( struct cv_typerec_array ) + 2 + typelen + 1 + 3 ) & ~3;

	movsxd	rax, DWORD PTR typelen$[rsp]
	add	rax, 16
	and	rax, -4
	mov	DWORD PTR size$[rsp], eax

; 241  :     cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [rcx+32]
	mov	r8d, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	call	QWORD PTR [rax+32]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 242  :     cv->pt_ar->tr.size = size - sizeof(uint_16);

	movsxd	rax, DWORD PTR size$[rsp]
	sub	rax, 2
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx], ax

; 243  :     cv->pt_ar->tr.leaf = LF_ARRAY;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 3
	mov	WORD PTR [rax+2], cx

; 244  :     cv->pt_ar->elemtype = ( elemtype ? elemtype : GetTyperef( sym, Ofssize ) );

	movzx	eax, WORD PTR elemtype$[rsp]
	test	eax, eax
	je	SHORT $LN7@cv_write_a
	movzx	eax, WORD PTR elemtype$[rsp]
	mov	DWORD PTR tv134[rsp], eax
	jmp	SHORT $LN8@cv_write_a
$LN7@cv_write_a:
	movzx	edx, BYTE PTR Ofssize$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	GetTyperef
	movzx	eax, ax
	mov	DWORD PTR tv134[rsp], eax
$LN8@cv_write_a:
	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	ecx, WORD PTR tv134[rsp]
	mov	WORD PTR [rax+4], cx

; 245  :     cv->pt_ar->idxtype = cv_idx_type.uvalue; /* ok? */

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	ecx, WORD PTR cv_idx_type
	mov	WORD PTR [rax+6], cx

; 246  :     tmp = cv->pt + sizeof( struct cv_typerec_array );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	add	rax, 10
	mov	QWORD PTR tmp$[rsp], rax

; 247  :     if ( typelen ) {

	cmp	DWORD PTR typelen$[rsp], 0
	je	SHORT $LN2@cv_write_a

; 248  :         cv->pt_ar->length = LF_ULONG;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 32772				; 00008004H
	mov	WORD PTR [rax+8], cx

; 249  :         *(uint_32 *)tmp = sym->total_size;

	mov	rax, QWORD PTR tmp$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax], ecx

; 250  :         tmp += sizeof( uint_32 );

	mov	rax, QWORD PTR tmp$[rsp]
	add	rax, 4
	mov	QWORD PTR tmp$[rsp], rax

; 251  :     } else {

	jmp	SHORT $LN3@cv_write_a
$LN2@cv_write_a:

; 252  :         cv->pt_ar->length = sym->total_size;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, WORD PTR [rcx+56]
	mov	WORD PTR [rax+8], cx
$LN3@cv_write_a:

; 253  :     }
; 254  :     *tmp++ = NULLC; /* the array type name is empty */

	mov	rax, QWORD PTR tmp$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR tmp$[rsp]
	inc	rax
	mov	QWORD PTR tmp$[rsp], rax

; 255  :     PadBytes( tmp, cv->types->e.seginfo->CodeBuffer );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR tmp$[rsp]
	call	PadBytes

; 256  :     cv->pt += size;

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	add	rax, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 257  :     cv->currtype++;

	mov	rax, QWORD PTR cv$[rsp]
	movzx	eax, WORD PTR [rax+44]
	inc	ax
	mov	rcx, QWORD PTR cv$[rsp]
	mov	WORD PTR [rcx+44], ax

; 258  :     return;
; 259  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
cv_write_array_type ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
cv$ = 48
type$ = 56
sym$ = 64
cv_write_bitfield PROC

; 216  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 217  :     cv->pt = checkflush( cv->types, cv->pt, sizeof( struct cv_typerec_bitfield ), cv->param );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	r9, QWORD PTR [rcx+32]
	mov	r8d, 8
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rdx, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	call	QWORD PTR [rax+32]
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 218  :     sym->cvtyperef = cv->currtype++;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR cv$[rsp]
	movzx	ecx, WORD PTR [rcx+44]
	mov	WORD PTR [rax+64], cx
	mov	rax, QWORD PTR cv$[rsp]
	movzx	eax, WORD PTR [rax+44]
	inc	ax
	mov	rcx, QWORD PTR cv$[rsp]
	mov	WORD PTR [rcx+44], ax

; 219  :     cv->pt_bf->tr.size = sizeof( struct cv_typerec_bitfield ) - sizeof(uint_16);

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 6
	mov	WORD PTR [rax], cx

; 220  :     cv->pt_bf->tr.leaf = LF_BITFIELD;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 518				; 00000206H
	mov	WORD PTR [rax+2], cx

; 221  :     cv->pt_bf->length = sym->total_size;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+56]
	mov	BYTE PTR [rax+4], cl

; 222  :     cv->pt_bf->position = sym->offset;

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+16]
	mov	BYTE PTR [rax+5], cl

; 223  :     cv->pt_bf->type = GetTyperef( (struct asym *)type, USE16 );

	xor	edx, edx
	mov	rcx, QWORD PTR type$[rsp]
	call	GetTyperef
	mov	rcx, QWORD PTR cv$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	WORD PTR [rcx+6], ax

; 224  :     cv->pt += sizeof( struct cv_typerec_bitfield );

	mov	rax, QWORD PTR cv$[rsp]
	mov	rax, QWORD PTR [rax+16]
	add	rax, 8
	mov	rcx, QWORD PTR cv$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 225  :     return;
; 226  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
cv_write_bitfield ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
curr$ = 16
base$ = 24
PadBytes PROC

; 206  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
$LN2@PadBytes:

; 207  :     static const char padtab[] = { LF_PAD1, LF_PAD2, LF_PAD3 };
; 208  :     while( ( curr - base ) & 3 )

	mov	rax, QWORD PTR base$[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	and	rax, 3
	test	rax, rax
	je	SHORT $LN3@PadBytes

; 209  :         *curr++ = padtab[3-((curr - base) & 3)];

	mov	rax, QWORD PTR base$[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	and	rax, 3
	mov	ecx, 3
	sub	rcx, rax
	mov	rax, rcx
	lea	rcx, OFFSET FLAT:?padtab@?1??PadBytes@@9@9
	mov	rdx, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [rdx], al
	mov	rax, QWORD PTR curr$[rsp]
	inc	rax
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN2@PadBytes
$LN3@PadBytes:

; 210  : }

	pop	rdi
	ret	0
PadBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
len$ = 0
tv65 = 4
tv75 = 8
tv83 = 16
tv92 = 24
tv130 = 32
sym$ = 64
Ofssize$ = 72
GetCVStructLen PROC

; 173  : {

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 174  :     uint_16 len;
; 175  :     switch ( sym->state ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 7
	je	SHORT $LN4@GetCVStruc
	jmp	SHORT $LN5@GetCVStruc
$LN4@GetCVStruc:

; 176  :     case SYM_TYPE:
; 177  :         len = sizeof( struct cv_symrec_udt );

	mov	eax, 6
	mov	WORD PTR len$[rsp], ax

; 178  :         break;

	jmp	$LN2@GetCVStruc
$LN5@GetCVStruc:

; 179  :     default:
; 180  :         if ( sym->isproc && Options.debug_ext >= CVEX_REDUCED ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@GetCVStruc
	movzx	eax, BYTE PTR Options+3
	cmp	eax, 1
	jl	SHORT $LN6@GetCVStruc

; 181  :             len = ( Ofssize == USE16 ? sizeof( struct cv_symrec_lproc16 ) : sizeof( struct cv_symrec_lproc32 ) );

	movzx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	jne	SHORT $LN14@GetCVStruc
	mov	QWORD PTR tv75[rsp], 29
	jmp	SHORT $LN15@GetCVStruc
$LN14@GetCVStruc:
	mov	QWORD PTR tv75[rsp], 37			; 00000025H
$LN15@GetCVStruc:
	movzx	eax, WORD PTR tv75[rsp]
	mov	WORD PTR len$[rsp], ax
	jmp	$LN7@GetCVStruc
$LN6@GetCVStruc:

; 182  :         } else if ( sym->mem_type == MT_NEAR || sym->mem_type == MT_FAR ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 129			; 00000081H
	je	SHORT $LN10@GetCVStruc
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN8@GetCVStruc
$LN10@GetCVStruc:

; 183  :             len = ( Ofssize == USE16 ? sizeof( struct cv_symrec_label16 ) : sizeof( struct cv_symrec_label32 ) );

	movzx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	jne	SHORT $LN16@GetCVStruc
	mov	QWORD PTR tv83[rsp], 9
	jmp	SHORT $LN17@GetCVStruc
$LN16@GetCVStruc:
	mov	QWORD PTR tv83[rsp], 11
$LN17@GetCVStruc:
	movzx	eax, WORD PTR tv83[rsp]
	mov	WORD PTR len$[rsp], ax
	jmp	SHORT $LN9@GetCVStruc
$LN8@GetCVStruc:

; 184  : #if EQUATESYMS
; 185  :         } else if ( sym->isequate ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@GetCVStruc

; 186  :             len = sizeof( struct cv_symrec_constant ) + ( sym->value >= LF_NUMERIC ? 2 : 0 );

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+16], 32768		; 00008000H
	jl	SHORT $LN18@GetCVStruc
	mov	DWORD PTR tv92[rsp], 2
	jmp	SHORT $LN19@GetCVStruc
$LN18@GetCVStruc:
	mov	DWORD PTR tv92[rsp], 0
$LN19@GetCVStruc:
	movsxd	rax, DWORD PTR tv92[rsp]
	add	rax, 8
	mov	WORD PTR len$[rsp], ax

; 187  : #endif
; 188  :         } else {

	jmp	SHORT $LN12@GetCVStruc
$LN11@GetCVStruc:

; 189  :             len = ( Ofssize == USE16 ? sizeof( struct cv_symrec_ldata16 ) : sizeof( struct cv_symrec_ldata32 ) );

	movzx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	jne	SHORT $LN20@GetCVStruc
	mov	QWORD PTR tv130[rsp], 10
	jmp	SHORT $LN21@GetCVStruc
$LN20@GetCVStruc:
	mov	QWORD PTR tv130[rsp], 12
$LN21@GetCVStruc:
	movzx	eax, WORD PTR tv130[rsp]
	mov	WORD PTR len$[rsp], ax
$LN12@GetCVStruc:
$LN9@GetCVStruc:
$LN7@GetCVStruc:
$LN2@GetCVStruc:

; 190  :         }
; 191  :     }
; 192  :     return( len );

	movzx	eax, WORD PTR len$[rsp]

; 193  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
GetCVStructLen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
_TEXT	SEGMENT
value$ = 36
size$4 = 52
tv79 = 56
tv128 = 60
tv150 = 64
tv156 = 68
tv162 = 72
tv173 = 76
sym$ = 96
Ofssize$ = 104
GetTyperef PROC

; 92   : {

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 93   :     union cv_typeref_u value = { CV_PDS_SPECIAL_NO_TYPE, 0, CV_PDT_SPECIAL, CV_PDM_DIRECT, 0 };

	xor	eax, eax
	mov	WORD PTR value$[rsp], ax

; 94   : 
; 95   :     if ( ( sym->mem_type & MT_SPECIAL ) == 0 ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	$LN13@GetTyperef

; 96   :         int size = SizeFromMemtype( sym->mem_type, Ofssize, sym->type );

	movzx	eax, BYTE PTR Ofssize$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rcx+80]
	mov	edx, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rax+36]
	call	SizeFromMemtype
	mov	DWORD PTR size$4[rsp], eax

; 97   :         if ( sym->mem_type & MT_FLOAT ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	$LN15@GetTyperef

; 98   :             value.s.type = CV_PDT_REAL;

	mov	eax, 65295				; 0000ff0fH
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	or	ax, 64					; 00000040H
	mov	WORD PTR value$[rsp], ax

; 99   :             switch ( size ) {

	mov	eax, DWORD PTR size$4[rsp]
	mov	DWORD PTR tv79[rsp], eax
	cmp	DWORD PTR tv79[rsp], 4
	je	SHORT $LN17@GetTyperef
	cmp	DWORD PTR tv79[rsp], 8
	je	SHORT $LN18@GetTyperef
	cmp	DWORD PTR tv79[rsp], 10
	je	SHORT $LN19@GetTyperef
	jmp	SHORT $LN2@GetTyperef
$LN17@GetTyperef:

; 100  :             case 4:  value.s.size = CV_PDS_REAL_32BIT; break;

	mov	eax, 65528				; 0000fff8H
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	mov	WORD PTR value$[rsp], ax
	jmp	SHORT $LN2@GetTyperef
$LN18@GetTyperef:

; 101  :             case 8:  value.s.size = CV_PDS_REAL_64BIT; break;

	mov	eax, 65528				; 0000fff8H
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	or	ax, 1
	mov	WORD PTR value$[rsp], ax
	jmp	SHORT $LN2@GetTyperef
$LN19@GetTyperef:

; 102  :             case 10: value.s.size = CV_PDS_REAL_80BIT; break;

	mov	eax, 65528				; 0000fff8H
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	or	ax, 2
	mov	WORD PTR value$[rsp], ax
$LN2@GetTyperef:

; 103  :             }
; 104  :         } else if ( size <= 8 ) {

	jmp	$LN16@GetTyperef
$LN15@GetTyperef:
	cmp	DWORD PTR size$4[rsp], 8
	jg	$LN20@GetTyperef

; 105  :             if ( sym->mem_type & MT_SIGNED )

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN22@GetTyperef

; 106  :                 value.s.type = CV_PDT_SIGNED_INTEGRAL;

	mov	eax, 65295				; 0000ff0fH
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	or	ax, 16
	mov	WORD PTR value$[rsp], ax
	jmp	SHORT $LN23@GetTyperef
$LN22@GetTyperef:

; 107  :             else
; 108  :                 value.s.type = CV_PDT_UNSIGNED_INTEGRAL;

	mov	eax, 65295				; 0000ff0fH
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	or	ax, 32					; 00000020H
	mov	WORD PTR value$[rsp], ax
$LN23@GetTyperef:

; 109  :             switch ( size ) {

	mov	eax, DWORD PTR size$4[rsp]
	mov	DWORD PTR tv128[rsp], eax
	cmp	DWORD PTR tv128[rsp], 1
	je	SHORT $LN24@GetTyperef
	cmp	DWORD PTR tv128[rsp], 2
	je	SHORT $LN25@GetTyperef
	cmp	DWORD PTR tv128[rsp], 4
	je	SHORT $LN26@GetTyperef
	cmp	DWORD PTR tv128[rsp], 6
	je	SHORT $LN28@GetTyperef
	cmp	DWORD PTR tv128[rsp], 8
	je	SHORT $LN27@GetTyperef
	jmp	$LN4@GetTyperef
$LN24@GetTyperef:

; 110  :             case 1:  value.s.size = CV_PDS_INTEGRAL_1BYTE; break;

	mov	eax, 65528				; 0000fff8H
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	mov	WORD PTR value$[rsp], ax
	jmp	$LN4@GetTyperef
$LN25@GetTyperef:

; 111  :             case 2:  value.s.size = CV_PDS_INTEGRAL_2BYTE; break;

	mov	eax, 65528				; 0000fff8H
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	or	ax, 1
	mov	WORD PTR value$[rsp], ax
	jmp	$LN4@GetTyperef
$LN26@GetTyperef:

; 112  :             case 4:  value.s.size = CV_PDS_INTEGRAL_4BYTE; break;

	mov	eax, 65528				; 0000fff8H
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	or	ax, 2
	mov	WORD PTR value$[rsp], ax
	jmp	SHORT $LN4@GetTyperef
$LN27@GetTyperef:

; 113  :             case 8:  value.s.size = CV_PDS_INTEGRAL_8BYTE; break;

	mov	eax, 65528				; 0000fff8H
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	or	ax, 3
	mov	WORD PTR value$[rsp], ax
	jmp	SHORT $LN4@GetTyperef
$LN28@GetTyperef:

; 114  :             case 6: /* v2.11: added ( FWORD ) */
; 115  :                 value.s.type = CV_PDT_SPECIAL;

	mov	eax, 65295				; 0000ff0fH
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	mov	WORD PTR value$[rsp], ax

; 116  :                 value.s.size = CV_PDS_SPECIAL_VOID;

	mov	eax, 65528				; 0000fff8H
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	or	ax, 3
	mov	WORD PTR value$[rsp], ax

; 117  :                 value.s.mode = CV_PDM_FAR32PTR;

	mov	eax, 63743				; 0000f8ffH
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	mov	ecx, 1280				; 00000500H
	or	ax, cx
	mov	WORD PTR value$[rsp], ax
$LN4@GetTyperef:

; 118  :                 break;
; 119  :             }
; 120  :         } else { /* v2.11: branch added */

	jmp	SHORT $LN21@GetTyperef
$LN20@GetTyperef:

; 121  :             /* problem: there's no integral size > 8 bytes.
; 122  :              * Masm v8+ sets 79h (=?) for 16-byte and 3h (=void) for 32-byte.
; 123  :              * jwasm sets uint64, which allows to view at least
; 124  :              * the lower 8 bytes.
; 125  :              */
; 126  :             value.s.type = CV_PDT_REAL_INT_VALUE;

	mov	eax, 65295				; 0000ff0fH
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	or	ax, 112					; 00000070H
	mov	WORD PTR value$[rsp], ax

; 127  :             value.s.size = CV_PDS_REAL_INT_UINT64;

	movzx	eax, WORD PTR value$[rsp]
	or	ax, 7
	mov	WORD PTR value$[rsp], ax
$LN21@GetTyperef:
$LN16@GetTyperef:

; 128  :         }
; 129  :     } else {

	jmp	$LN14@GetTyperef
$LN13@GetTyperef:

; 130  :         switch ( sym->mem_type ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR tv150[rsp], eax
	cmp	DWORD PTR tv150[rsp], 129		; 00000081H
	je	$LN35@GetTyperef
	cmp	DWORD PTR tv150[rsp], 130		; 00000082H
	je	$LN36@GetTyperef
	cmp	DWORD PTR tv150[rsp], 193		; 000000c1H
	je	$LN33@GetTyperef
	cmp	DWORD PTR tv150[rsp], 195		; 000000c3H
	je	SHORT $LN29@GetTyperef
	cmp	DWORD PTR tv150[rsp], 196		; 000000c4H
	je	$LN37@GetTyperef
	jmp	$LN6@GetTyperef
$LN29@GetTyperef:

; 131  :         //case MT_ABS:  break;  /* v2.07: MT_ABS obsolete */
; 132  :         case MT_PTR:
; 133  :             /* v2.10 */
; 134  :             value.s.size = CV_PDS_SPECIAL_VOID;

	mov	eax, 65528				; 0000fff8H
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	or	ax, 3
	mov	WORD PTR value$[rsp], ax

; 135  :             value.s.type = CV_PDT_SPECIAL;

	mov	eax, 65295				; 0000ff0fH
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	mov	WORD PTR value$[rsp], ax

; 136  :             switch ( sym->Ofssize ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	BYTE PTR tv156[rsp], al
	cmp	BYTE PTR tv156[rsp], 0
	je	SHORT $LN30@GetTyperef
	cmp	BYTE PTR tv156[rsp], 1
	je	SHORT $LN31@GetTyperef
	cmp	BYTE PTR tv156[rsp], 2
	je	$LN32@GetTyperef
	jmp	$LN8@GetTyperef
$LN30@GetTyperef:

; 137  :             case USE16:
; 138  :                 value.s.mode = ( sym->isfar ? CV_PDM_FARPTR : CV_PDM_NEARPTR );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN40@GetTyperef
	mov	DWORD PTR tv162[rsp], 2
	jmp	SHORT $LN41@GetTyperef
$LN40@GetTyperef:
	mov	DWORD PTR tv162[rsp], 1
$LN41@GetTyperef:
	movzx	eax, WORD PTR tv162[rsp]
	and	ax, 7
	shl	ax, 8
	mov	ecx, 63743				; 0000f8ffH
	movzx	edx, WORD PTR value$[rsp]
	and	dx, cx
	movzx	ecx, dx
	or	cx, ax
	movzx	eax, cx
	mov	WORD PTR value$[rsp], ax

; 139  :                 break;

	jmp	SHORT $LN8@GetTyperef
$LN31@GetTyperef:

; 140  :             case USE32:
; 141  :                 value.s.mode = ( sym->isfar ? CV_PDM_FAR32PTR : CV_PDM_NEAR32PTR );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN42@GetTyperef
	mov	DWORD PTR tv173[rsp], 5
	jmp	SHORT $LN43@GetTyperef
$LN42@GetTyperef:
	mov	DWORD PTR tv173[rsp], 4
$LN43@GetTyperef:
	movzx	eax, WORD PTR tv173[rsp]
	and	ax, 7
	shl	ax, 8
	mov	ecx, 63743				; 0000f8ffH
	movzx	edx, WORD PTR value$[rsp]
	and	dx, cx
	movzx	ecx, dx
	or	cx, ax
	movzx	eax, cx
	mov	WORD PTR value$[rsp], ax

; 142  :                 break;

	jmp	SHORT $LN8@GetTyperef
$LN32@GetTyperef:

; 143  : #if AMD64_SUPPORT
; 144  :             case USE64:
; 145  :                 value.s.mode = CV_PDM_NEAR64PTR;

	mov	eax, 63743				; 0000f8ffH
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	mov	ecx, 1536				; 00000600H
	or	ax, cx
	mov	WORD PTR value$[rsp], ax
$LN8@GetTyperef:

; 146  :                 break;
; 147  : #endif
; 148  :             }
; 149  :             break;

	jmp	$LN6@GetTyperef
$LN33@GetTyperef:

; 150  :         case MT_BITS:
; 151  :             if ( sym->cvtyperef )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, WORD PTR [rax+64]
	test	eax, eax
	je	SHORT $LN34@GetTyperef

; 152  :                 return( sym->cvtyperef );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, WORD PTR [rax+64]
	jmp	$LN1@GetTyperef
$LN34@GetTyperef:

; 153  :             break;

	jmp	$LN6@GetTyperef
$LN35@GetTyperef:

; 154  :         case MT_NEAR: value.s.mode = CV_PDM_NEARPTR; break;

	mov	eax, 63743				; 0000f8ffH
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	mov	ecx, 256				; 00000100H
	or	ax, cx
	mov	WORD PTR value$[rsp], ax
	jmp	$LN6@GetTyperef
$LN36@GetTyperef:

; 155  :         case MT_FAR:  value.s.mode = CV_PDM_FARPTR; break;

	mov	eax, 63743				; 0000f8ffH
	movzx	ecx, WORD PTR value$[rsp]
	and	cx, ax
	movzx	eax, cx
	mov	ecx, 512				; 00000200H
	or	ax, cx
	mov	WORD PTR value$[rsp], ax
	jmp	SHORT $LN6@GetTyperef
$LN37@GetTyperef:

; 156  :         case MT_TYPE:
; 157  :             for ( sym = sym->type; sym->type; sym = sym->type );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym$[rsp], rax
	jmp	SHORT $LN12@GetTyperef
$LN10@GetTyperef:
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym$[rsp], rax
$LN12@GetTyperef:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN11@GetTyperef
	jmp	SHORT $LN10@GetTyperef
$LN11@GetTyperef:

; 158  :             if ( sym->cvtyperef )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, WORD PTR [rax+64]
	test	eax, eax
	je	SHORT $LN38@GetTyperef

; 159  :                 return( sym->cvtyperef );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, WORD PTR [rax+64]
	jmp	SHORT $LN1@GetTyperef
$LN38@GetTyperef:

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+36]
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+32]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10883
	call	DoDebugMsg

; 161  :             return( GetTyperef( sym, Ofssize ) );

	movzx	edx, BYTE PTR Ofssize$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	GetTyperef
	jmp	SHORT $LN1@GetTyperef
$LN6@GetTyperef:
$LN14@GetTyperef:

; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	movzx	eax, WORD PTR value$[rsp]
$LN1@GetTyperef:

; 167  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:GetTyperef$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
GetTyperef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Buffer$ = 96
_Format$ = 104
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1788 : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:sprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp___stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1391 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
	push	rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	rdi
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
