; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG11879 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
CONST	SEGMENT
mzdata	DW	01eH
	DW	010H
	DW	00H
	DW	0ffffH
szCaption DB	'Binary Map:', 00H
edataname DB	'.edata', 00H
	ORG $+5
szCaption2 DB	'Segment                  Pos(file)     RVA  Size(fil) Si'
	DB	'ze(mem)', 00H
szSep	DB	'--------------------------------------------------------'
	DB	'-------', 00H
szHeader DB	'<header>', 00H
	ORG $+7
szSegLine DB	'%-24s %8X %8X %9X %9X', 00H
	ORG $+2
szTotal	DB	'%-42s %9X %9X', 00H
	ORG $+2
dosseg_order DD	01H
	DD	00H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
flat_order DD	06H
	DD	01H
	DD	07H
	DD	02H
	DD	03H
	DD	09H
	DD	08H
	ORG $+4
hdrattr	DB	'read public ''HDR''', 00H
	ORG $+6
edataattr DB	'FLAT read public alias(''.rdata'') ''DATA''', 00H
idataname DB	'.idata$', 00H
idataattr DB	'FLAT read public alias(''.rdata'') ''DATA''', 00H
mzcode	DB	'db ''MZ''', 00H, 'dw 80h, 1, 0, 4', 00H, 'dw 0, -1, 0, 0'
	DB	'B8h', 00H, 'dw 0, 0, 0, 40h', 00H, 'org 40h', 00H, 'push cs', 00H
	DB	'pop ds', 00H, 'mov dx,@F - 40h', 00H, 'mov ah,9', 00H, 'int 2'
	DB	'1h', 00H, 'mov ax,4C01h', 00H, 'int 21h', 00H, '@@:', 00H, 'd'
	DB	'b ''This is a PE executable'',0Dh,0Ah,''$''', 00H
	ORG $+12
pe32def	DD	04550H
	DW	014cH
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DW	0e0H
	DW	010fH
	DW	010bH
	DB	05H
	DB	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0400000H
	DD	01000H
	DD	0200H
	DW	04H
	DW	00H
	DW	00H
	DW	00H
	DW	04H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	03H
	DW	00H
	DD	0100000H
	DD	01000H
	DD	0100000H
	DD	01000H
	DD	00H
	DD	010H
	ORG $+128
	ORG $+8
pe64def	DD	04550H
	DW	08664H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DW	0f0H
	DW	012fH
	DW	020bH
	DB	05H
	DB	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DQ	0000000000400000H
	DD	01000H
	DD	0200H
	DW	04H
	DW	00H
	DW	00H
	DW	00H
	DW	04H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	03H
	DW	00H
	DQ	0000000000100000H
	DQ	0000000000001000H
	DQ	0000000000100000H
	DQ	0000000000001000H
	DD	00H
	DD	010H
	ORG $+128
CONST	ENDS
_DATA	SEGMENT
$SG12325 DB	'.hdr$1', 00H
	ORG $+1
$SG12326 DB	'.hdr$2', 00H
	ORG $+1
$SG12327 DB	'.hdr$3', 00H
	ORG $+1
$SG12331 DB	'pe_set_values: .reloc section required', 0aH, 00H
$SG12332 DB	'RELOC', 00H
	ORG $+2
$SG12333 DB	'.reloc', 00H
	ORG $+1
$SG12335 DB	'pe_set_values: searching segment types %Xh', 0aH, 00H
	ORG $+4
$SG12340 DB	'pe_set_values: section %s, start ofs=%Xh, size=%Xh, file'
	DB	' ofs=%Xh', 0aH, 00H
	ORG $+6
$SG12361 DB	'pe_set_values: warning: not start label found', 0aH, 00H
	ORG $+1
$SG12370 DB	'.rsrc', 00H
	ORG $+2
$SG12356 DB	'pe_set_values: object %.8s, VA=%X size=%X phys ofs/size='
	DB	'%Xh/%Xh', 0aH, 00H
	ORG $+3
$SG12372 DB	'.reloc', 00H
	ORG $+1
$SG12503 DB	' ', 00H
	ORG $+2
$SG12366 DB	'.idata$2', 00H
	ORG $+3
$SG12378 DB	'.pdata', 00H
	ORG $+1
$SG11995 DB	'HDR', 00H
$SG12367 DB	'.idata$3', 00H
	ORG $+3
$SG11945 DB	'.hdr$1', 00H
	ORG $+1
$SG12026 DB	'HDR', 00H
$SG12368 DB	'.idata$5', 00H
	ORG $+3
$SG12374 DB	'.tls', 00H
	ORG $+3
$SG11949 DB	'.hdr$', 00H
	ORG $+2
$SG11952 DB	'%s1 %r', 00H
	ORG $+5
$SG12438 DB	'bin_write_module: enter', 0aH, 00H
	ORG $+7
$SG12441 DB	'bin_write_module: MZ format, fixups=%u, sizehdr=%X', 0aH
	DB	00H
	ORG $+4
$SG12449 DB	'bin_write_module: .DOSSEG active', 0aH, 00H
	ORG $+6
$SG12450 DB	'bin_write_module: searching segment types %Xh', 0aH, 00H
	ORG $+1
$SG12454 DB	'bin_write_module: .ALPHA active', 0aH, 00H
	ORG $+7
$SG12452 DB	'bin_write_module: section %s, start ofs=%Xh, size=%Xh, f'
	DB	'ile ofs=%Xh', 0aH, 00H
	ORG $+3
$SG12455 DB	'NULL', 00H
	ORG $+3
$SG12456 DB	'bin_write_module(%s): start ofs=%Xh, size=%Xh, file ofs='
	DB	'%Xh, grp=%s', 0aH, 00H
	ORG $+3
$SG12457 DB	'bin_write_module: all CalcOffset() done', 0aH, 00H
	ORG $+7
$SG12465 DB	'bin_write_module: MZ, sizetotal=%Xh sizeheap=%Xh', 0aH, 00H
	ORG $+6
$SG12471 DB	'bin_write_module: MZ, stack=%Xh ofs=%Xh', 0aH, 00H
	ORG $+7
$SG12474 DB	'bin_write_module, start_label: offs=%Xh, seg.offs=%Xh, g'
	DB	'roup.offs=%Xh', 0aH, 00H
	ORG $+1
$SG12477 DB	'bin_write_module, ModuleInfo->start_label=%p', 0aH, 00H
	ORG $+2
$SG12478 DB	'bin_write_module: MZ, mzdata ofs_fixups=%Xh, alignment=%'
	DB	'Xh', 0aH, 00H
$SG11951 DB	'.hdr$', 00H
	ORG $+6
$SG12482 DB	'bin_write_module(%s): type=%u written=%X max=%X start=%X'
	DB	' fileofs=%X', 0aH, 00H
	ORG $+3
$SG12484 DB	'bin_write_module(%s): ABS segment not written', 0aH, 00H
	ORG $+1
$SG12496 DB	'bin_write_module(%s): nothing written', 0aH, 00H
	ORG $+1
$SG12491 DB	'bin_write_module(%s): segment not written, size=% Xh siz'
	DB	'emem=%X', 0aH, 00H
	ORG $+7
$SG12504 DB	'bin_write_module: exit', 0aH, 00H
$SG12494 DB	'bin_write_module(%s): write %Xh bytes at offset %Xh, ini'
	DB	'tialized bytes=%u, buffer=%p', 0aH, 00H
	ORG $+2
$SG12516 DB	'CheckExternal: error, %s weak=%u', 0aH, 00H
	ORG $+6
$SG11735 DB	'CalcOffset(%s): abs seg, offset=%Xh', 0aH, 00H
	ORG $+3
$SG11741 DB	'CalcOffset(%s): fileofs=%Xh, ofs=%Xh', 0aH, 00H
	ORG $+2
$SG11746 DB	'CalcOffset(%s): fileofs=%Xh, alignbytes=%u, ofs=%Xh, gro'
	DB	'up=%s, grp.ofs=%Xh', 0aH, 00H
	ORG $+4
$SG11758 DB	'CalcOffset(%s) exit: seg.fileofs=%Xh, seg.start_offset=%'
	DB	'Xh, endofs=%Xh fileofs=%Xh rva=%Xh', 0aH, 00H
	ORG $+4
$SG11780 DB	'GetSegRelocs( %p ) enter', 0aH, 00H
	ORG $+6
$SG11784 DB	'GetSegRelocs: found seg-related fixup at %s.%X', 0aH, 00H
$SG11790 DB	'GetSegRelocs: locofs=%X fileofs=%X segofs=%X grpofs=%X, '
	DB	'fixup value: %X %X', 0aH, 00H
	ORG $+4
$SG11791 DB	'GetSegRelocs()=%u', 0aH, 00H
	ORG $+5
$SG11816 DB	'GetImageSize(%s): fileofs=%Xh, max_offs=%Xh start=%Xh', 0aH
	DB	00H
	ORG $+1
$SG11818 DB	'GetImageSize(%u)=%Xh', 0aH, 00H
	ORG $+2
$SG11857 DB	'DoFixup(%s) enter, segment start ofs=%Xh', 0aH, 00H
	ORG $+6
$SG11869 DB	'DoFixup(%s): SECREL, primary seg=%s, start_offset=%X', 0aH
	DB	00H
	ORG $+2
$SG11863 DB	'DoFixup(%s, %04X, %s): variable, fixup->segment=%Xh fixu'
	DB	'p->offset=%Xh, fixup->sym->offset=%Xh', 0aH, 00H
	ORG $+1
$SG11865 DB	'DoFixup(%s): IMGREL, loc=%X value=%X seg.start=%X images'
	DB	'tart=%X', 0aH, 00H
	ORG $+7
$SG11870 DB	'DoFixup(%s): SECREL, loc=%X, value=%X', 0aH, 00H
	ORG $+1
$SG11872 DB	'DoFixup(%s): RELOFFx, loc=%X, sym=%s, [start_offset=%Xh,'
	DB	' fixup->offset=%Xh, fixup->sym->offset=%Xh', 0aH, 00H
$SG11954 DB	'.hdr$1', 00H
	ORG $+5
$SG11878 DB	'DoFixup(%s): loc=%04X, sym=%s, target->start_offset=%Xh,'
	DB	' fixup->offset=%Xh, fixup->sym->offset=%Xh', 0aH, 00H
$SG11965 DB	'.hdr$2', 00H
	ORG $+5
$SG11880 DB	'DoFixup(%s, %04X, %s): target segment=0, fixup->offset=%'
	DB	'Xh, fixup->sym->offset=%Xh', 0aH, 00H
	ORG $+4
$SG11882 DB	'DoFixup(%s, %04X): FIX_RELOFF8, value=%Xh, *target=%Xh', 0aH
	DB	00H
$SG11884 DB	'DoFixup(%s, %04X): FIX_RELOFF16, value=%Xh, *target=%Xh', 0aH
	DB	00H
	ORG $+7
$SG11887 DB	'DoFixup(%s, %04X): FIX_RELOFF32, value=%Xh, *target=%Xh', 0aH
	DB	00H
	ORG $+7
$SG11889 DB	'DoFixup(%s, %04X): FIX_OFF8, value=%Xh, *target=%Xh', 0aH
	DB	00H
	ORG $+3
$SG11893 DB	'DoFixup(%s, %04X): FIX_OFF32, value=%Xh, *target=%Xh', 0aH
	DB	00H
	ORG $+2
$SG11891 DB	'DoFixup(%s, %04X): FIX_OFF16, value=%Xh, target=%p *targ'
	DB	'et=%Xh', 0aH, 00H
$SG11895 DB	'DoFixup(%s, %04X): FIX_OFF32_IMGREL, value=%Xh, *target='
	DB	'%Xh', 0aH, 00H
	ORG $+3
$SG11897 DB	'DoFixup(%s, %04X): FIX_OFF32_SECREL, value=%Xh, *target='
	DB	'%Xh', 0aH, 00H
	ORG $+3
$SG11901 DB	'DoFixup(%s, %04X): FIX_OFF64, value=%Xh, *target=%I64Xh', 0aH
	DB	00H
	ORG $+7
$SG11903 DB	'DoFixup(%s, %04X): FIX_HIBYTE, value=%Xh, *target=%Xh', 0aH
	DB	00H
	ORG $+1
$SG11907 DB	'DoFixup(%s, %04X): FIX_SEG frame=%u, ', 00H
	ORG $+2
$SG11910 DB	'GROUP symbol, offset=%Xh codeptr=%p', 0aH, 00H
	ORG $+3
$SG11913 DB	'SEGMENT symbol, start_offset=%Xh', 0aH, 00H
	ORG $+6
$SG11916 DB	'group.offset=%Xh', 0aH, 00H
	ORG $+6
$SG11917 DB	'segment.offset=%Xh', 0aH, 00H
	ORG $+4
$SG11921 DB	'DoFixup(%s, %04X): FIX_PTR16, seg->start=%Xh', 0aH, 00H
	ORG $+2
$SG11927 DB	'DoFixup(%s, %04X): FIX_PTR32', 0aH, 00H
	ORG $+2
$SG11931 DB	'DoFixup(%s, %04X): invalid fixup %u', 0aH, 00H
	ORG $+3
$SG11943 DB	'pe_create_MZ_header enter', 0aH, 00H
	ORG $+5
$SG11947 DB	'pe_create_MZ_header: generate code', 0aH, 00H
	ORG $+4
$SG11948 DB	'%r DOTNAME', 00H
	ORG $+5
$SG11950 DB	'%s1 %r USE16 %r %s', 00H
	ORG $+5
$SG11968 DB	'set_file_flags(%s, %X): value=%X', 0aH, 00H
	ORG $+6
$SG11987 DB	'pe_create_PE_header enter', 0aH, 00H
	ORG $+1
$SG11992 DB	'.hdr$2', 00H
	ORG $+1
$SG11996 DB	'.hdr$2', 00H
	ORG $+5
$SG11998 DB	'@pe_file_flags', 00H
	ORG $+1
$SG12000 DB	'pe_create_PE_header: CreateVariable(@pe_file_flags)=%X ['
	DB	'value=%X]', 0aH, 00H
	ORG $+5
$SG12022 DB	'pe_create_section table enter', 0aH, 00H
	ORG $+1
$SG12024 DB	'.hdr$3', 00H
	ORG $+1
$SG12027 DB	'.hdr$3', 00H
	ORG $+1
$SG12035 DB	'CONST', 00H
	ORG $+2
$SG12039 DB	'.rsrc', 00H
	ORG $+2
$SG12042 DB	'.reloc', 00H
	ORG $+1
$SG12043 DB	'pe_create_section_table: searching type %u', 0aH, 00H
	ORG $+4
$SG12044 DB	'pe_create_section_table: section %s, type=%u, size=%X', 0aH
	DB	00H
	ORG $+1
$SG12047 DB	'pe_create_section_table: %s, type=%u is object %u', 0aH, 00H
	ORG $+5
$SG12049 DB	'pe_create_section_table: items in object table: %u', 0aH
	DB	00H
	ORG $+4
$SG12097 DB	'pe_emit_export_data enter', 0aH, 00H
	ORG $+5
$SG12100 DB	'%r DOTNAME', 00H
	ORG $+5
$SG12101 DB	'%s %r %r %s', 00H
$SG12110 DB	'DW %u', 00H
	ORG $+6
$SG12102 DB	'DD 0, 0%xh, 0, %r @%s_name, %u, %u, %u, %r @%s_func, %r '
	DB	'@%s_names, %r @%s_nameord', 00H
	ORG $+6
$SG12104 DB	'@%s_func %r DWORD', 00H
	ORG $+6
$SG12106 DB	'DD %r %s', 00H
	ORG $+7
$SG12107 DB	'@%s_names %r DWORD', 00H
	ORG $+5
$SG12108 DB	'DD %r @%s', 00H
	ORG $+6
$SG12109 DB	'@%s_nameord %r WORD', 00H
	ORG $+4
$SG12113 DB	'@%s_name DB ''%s'',0', 00H
	ORG $+5
$SG12115 DB	'@%s DB ''%s'',0', 00H
	ORG $+2
$SG12116 DB	'%s %r', 00H
	ORG $+2
$SG12141 DB	'ALIGN(8)', 00H
	ORG $+7
$SG12142 DB	'ALIGN(4)', 00H
	ORG $+7
$SG12143 DB	'pe_emit_import_data enter', 0aH, 00H
	ORG $+5
$SG12146 DB	'@LPPROC %r %r %r', 00H
	ORG $+7
$SG12147 DB	'%r DOTNAME', 00H
	ORG $+5
$SG12149 DB	'%s2 %r %r %s', 00H
	ORG $+3
$SG12150 DB	'DD %r @%s_ilt, 0, 0, %r @%s_name, %r @%s_iat', 00H
	ORG $+3
$SG12151 DB	'%s2 %r', 00H
	ORG $+1
$SG12152 DB	'%s4 %r %s %s', 00H
	ORG $+3
$SG12153 DB	'@%s_ilt label %r', 00H
	ORG $+7
$SG12155 DB	'@LPPROC %r @%s_name', 00H
	ORG $+4
$SG12156 DB	'@LPPROC 0', 00H
	ORG $+2
$SG12157 DB	'%s4 %r', 00H
	ORG $+5
$SG12158 DB	'%s5 %r %s %s', 00H
	ORG $+3
$SG12159 DB	'@%s_iat label %r', 00H
	ORG $+7
$SG12161 DB	'%s%s @LPPROC %r @%s_name', 00H
	ORG $+7
$SG12162 DB	'@LPPROC 0', 00H
	ORG $+2
$SG12163 DB	'%s5 %r', 00H
	ORG $+5
$SG12164 DB	'%s6 %r %r %s', 00H
	ORG $+3
$SG12166 DB	'@%s_name dw 0', 00H
	ORG $+2
$SG12167 DB	'db ''%s'',0', 00H
	ORG $+2
$SG12168 DB	'even', 00H
	ORG $+7
$SG12171 DB	'@%s_%s_name db ''%s.%s'',0', 00H
	ORG $+7
$SG12172 DB	'@%s_name db ''%s'',0', 00H
	ORG $+1
$SG12173 DB	'even', 00H
	ORG $+3
$SG12174 DB	'%s6 %r', 00H
	ORG $+5
$SG12176 DB	'%s3 %r %r %s', 00H
	ORG $+3
$SG12177 DB	'DD 0, 0, 0, 0, 0', 00H
	ORG $+3
$SG12178 DB	'%s3 %r', 00H
	ORG $+1
$SG12202 DB	'CONST', 00H
_DATA	ENDS
PUBLIC	bin_init
PUBLIC	pe_create_PE_header
EXTRN	_time64:PROC
EXTRN	fseek:PROC
EXTRN	ftell:PROC
EXTRN	fwrite:PROC
EXTRN	qsort:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strchr:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	strncpy:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	WriteError:PROC
EXTRN	ConvertSectionName:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymFind:PROC
EXTRN	LstPrintf:PROC
EXTRN	LstNL:PROC
EXTRN	AddLineQueue:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	RunLineQueue:PROC
EXTRN	Mangle:PROC
EXTRN	CreateIntSegment:PROC
EXTRN	CreateVariable:PROC
EXTRN	SortSegments:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SymTables:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$time DD	imagerel time
	DD	imagerel time+24
	DD	imagerel $unwind$time
$pdata$bin_init DD imagerel $LN7
	DD	imagerel $LN7+136
	DD	imagerel $unwind$bin_init
$pdata$pe_create_PE_header DD imagerel $LN13
	DD	imagerel $LN13+584
	DD	imagerel $unwind$pe_create_PE_header
$pdata$CalcOffset DD imagerel CalcOffset
	DD	imagerel CalcOffset+1029
	DD	imagerel $unwind$CalcOffset
$pdata$GetSegRelocs DD imagerel GetSegRelocs
	DD	imagerel GetSegRelocs+738
	DD	imagerel $unwind$GetSegRelocs
$pdata$GetImageSize DD imagerel GetImageSize
	DD	imagerel GetImageSize+437
	DD	imagerel $unwind$GetImageSize
$pdata$DoFixup DD imagerel DoFixup
	DD	imagerel DoFixup+3632
	DD	imagerel $unwind$DoFixup
$pdata$pe_create_MZ_header DD imagerel pe_create_MZ_header
	DD	imagerel pe_create_MZ_header+326
	DD	imagerel $unwind$pe_create_MZ_header
$pdata$set_file_flags DD imagerel set_file_flags
	DD	imagerel set_file_flags+141
	DD	imagerel $unwind$set_file_flags
$pdata$pe_create_section_table DD imagerel pe_create_section_table
	DD	imagerel pe_create_section_table+895
	DD	imagerel $unwind$pe_create_section_table
$pdata$compare_exp DD imagerel compare_exp
	DD	imagerel compare_exp+40
	DD	imagerel $unwind$compare_exp
$pdata$pe_emit_export_data DD imagerel pe_emit_export_data
	DD	imagerel pe_emit_export_data+1179
	DD	imagerel $unwind$pe_emit_export_data
$pdata$pe_emit_import_data DD imagerel pe_emit_import_data
	DD	imagerel pe_emit_import_data+1356
	DD	imagerel $unwind$pe_emit_import_data
$pdata$get_bit DD imagerel get_bit
	DD	imagerel get_bit+50
	DD	imagerel $unwind$get_bit
$pdata$pe_get_characteristics DD imagerel pe_get_characteristics
	DD	imagerel pe_get_characteristics+322
	DD	imagerel $unwind$pe_get_characteristics
$pdata$pe_set_base_relocs DD imagerel pe_set_base_relocs
	DD	imagerel pe_set_base_relocs+812
	DD	imagerel $unwind$pe_set_base_relocs
$pdata$pe_set_values DD imagerel pe_set_values
	DD	imagerel pe_set_values+3410
	DD	imagerel $unwind$pe_set_values
$pdata$pe_enddirhook DD imagerel pe_enddirhook
	DD	imagerel pe_enddirhook+53
	DD	imagerel $unwind$pe_enddirhook
$pdata$bin_write_module DD imagerel bin_write_module
	DD	imagerel bin_write_module+3485
	DD	imagerel $unwind$bin_write_module
$pdata$bin_check_external DD imagerel bin_check_external
	DD	imagerel bin_check_external+169
	DD	imagerel $unwind$bin_check_external
pdata	ENDS
xdata	SEGMENT
$unwind$time DD	010901H
	DD	04209H
$unwind$bin_init DD 010901H
	DD	06209H
$unwind$pe_create_PE_header DD 010401H
	DD	0a204H
$unwind$CalcOffset DD 010e01H
	DD	0c20eH
$unwind$GetSegRelocs DD 010901H
	DD	0e209H
$unwind$GetImageSize DD 010801H
	DD	0a208H
$unwind$DoFixup DD 021101H
	DD	0170111H
$unwind$pe_create_MZ_header DD 010901H
	DD	08209H
$unwind$set_file_flags DD 010e01H
	DD	0620eH
$unwind$pe_create_section_table DD 010401H
	DD	0a204H
$unwind$compare_exp DD 010e01H
	DD	0420eH
$unwind$pe_emit_export_data DD 075041c19H
	DD	0109730eH
	DD	05002001aH
	DD	imagerel __GSHandlerCheck
	DD	0c8H
$unwind$pe_emit_import_data DD 020701H
	DD	0110107H
$unwind$get_bit DD 010801H
	DD	02208H
$unwind$pe_get_characteristics DD 010901H
	DD	06209H
$unwind$pe_set_base_relocs DD 010901H
	DD	0c209H
$unwind$pe_set_values DD 021e19H
	DD	043010cH
	DD	imagerel __GSHandlerCheck
	DD	0200H
$unwind$pe_enddirhook DD 010901H
	DD	04209H
$unwind$bin_write_module DD 045052419H
	DD	010e4313H
	DD	070070021H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
$unwind$bin_check_external DD 010901H
	DD	06209H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
curr$ = 32
modinfo$ = 64
bin_check_external PROC

; 1820 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1821 :     struct dsym *curr;
; 1822 :     for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next )

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@bin_check_
$LN2@bin_check_:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@bin_check_:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@bin_check_

; 1823 :         if( curr->sym.weak == FALSE || curr->sym.used == TRUE ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@bin_check_
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN5@bin_check_
$LN6@bin_check_:

; 1824 :             DebugMsg(("CheckExternal: error, %s weak=%u\n", curr->sym.name, curr->sym.weak ));

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	mov	r8d, eax
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12516
	call	DoDebugMsg

; 1825 :             return( EmitErr( FORMAT_DOESNT_SUPPORT_EXTERNALS, curr->sym.name ) );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 201				; 000000c9H
	call	EmitErr
	jmp	SHORT $LN1@bin_check_
$LN5@bin_check_:

; 1826 :         }

	jmp	SHORT $LN2@bin_check_
$LN3@bin_check_:

; 1827 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@bin_check_:

; 1828 : }

	add	rsp, 56					; 00000038H
	ret	0
bin_check_external ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
curr$ = 0
size$ = 8
pMZ$ = 16
sizeheap$ = 24
reloccnt$ = 28
sizetotal$ = 32
i$ = 36
addr$1 = 40
addr$2 = 44
stack$ = 48
first$ = 56
tv263 = 60
tv280 = 64
tv317 = 68
tv335 = 72
tv469 = 76
sizemem$ = 80
tv495 = 84
dir$3 = 88
hdrbuf$ = 96
cp$ = 104
tv84 = 152
tv254 = 156
tv209 = 160
tmp$4 = 168
tv628 = 176
__$ArrayPad$ = 184
modinfo$ = 224
bin_write_module PROC

; 1513 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+64]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax

; 1514 :     struct dsym *curr;
; 1515 :     uint_32 size;
; 1516 :     uint_32 sizetotal;
; 1517 :     //const enum seg_type *segtype;
; 1518 :     int i;
; 1519 :     int first;
; 1520 :     uint_32 sizeheap;
; 1521 : #if MZ_SUPPORT
; 1522 :     struct IMAGE_DOS_HEADER *pMZ;
; 1523 :     uint_16 reloccnt;
; 1524 :     uint_32 sizemem;
; 1525 :     struct dsym *stack = NULL;

	mov	QWORD PTR stack$[rbp], 0

; 1526 :     uint_8  *hdrbuf;
; 1527 : #endif
; 1528 :     struct calc_param cp = { TRUE, 0 };

	mov	BYTE PTR cp$[rbp], 1
	mov	BYTE PTR cp$[rbp+1], 0
	lea	rax, QWORD PTR cp$[rbp+4]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 44					; 0000002cH
	rep stosb

; 1529 : 
; 1530 :     DebugMsg(("bin_write_module: enter\n" ));

	lea	rcx, OFFSET FLAT:$SG12438
	call	DoDebugMsg

; 1531 : 
; 1532 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rbp], rax
	jmp	SHORT $LN4@bin_write_
$LN2@bin_write_:
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rbp], rax
$LN4@bin_write_:
	cmp	QWORD PTR curr$[rbp], 0
	je	SHORT $LN3@bin_write_

; 1533 :         /* reset the offset fields of segments */
; 1534 :         /* it was used to store the size in there */
; 1535 :         curr->e.seginfo->start_offset = 0;

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+12], 0

; 1536 :         /* set STACK segment type */
; 1537 :         if ( curr->e.seginfo->combine == COMB_STACK )

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+108]
	and	al, 7
	movzx	eax, al
	cmp	eax, 5
	jne	SHORT $LN30@bin_write_

; 1538 :             curr->e.seginfo->segtype = SEGTYPE_STACK;

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+72], 4
$LN30@bin_write_:

; 1539 :     }

	jmp	SHORT $LN2@bin_write_
$LN3@bin_write_:

; 1540 : 
; 1541 :     /* calculate size of header */
; 1542 :     switch( modinfo->sub_format ) {

	mov	rax, QWORD PTR modinfo$[rbp]
	mov	eax, DWORD PTR [rax+372]
	mov	DWORD PTR tv84[rbp], eax
	cmp	DWORD PTR tv84[rbp], 1
	je	SHORT $LN31@bin_write_
	jmp	SHORT $LN32@bin_write_
$LN31@bin_write_:

; 1543 : #if MZ_SUPPORT
; 1544 :     case SFORMAT_MZ:
; 1545 :         reloccnt = GetSegRelocs( NULL );

	xor	ecx, ecx
	call	GetSegRelocs
	mov	WORD PTR reloccnt$[rbp], ax

; 1546 :         cp.sizehdr = (reloccnt * 4 + modinfo->mz_data.ofs_fixups + (modinfo->mz_data.alignment - 1)) & ~(modinfo->mz_data.alignment-1);

	movzx	eax, WORD PTR reloccnt$[rbp]
	mov	rcx, QWORD PTR modinfo$[rbp]
	movzx	ecx, WORD PTR [rcx+412]
	lea	eax, DWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR modinfo$[rbp]
	movzx	ecx, WORD PTR [rcx+414]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	rcx, QWORD PTR modinfo$[rbp]
	movzx	ecx, WORD PTR [rcx+414]
	dec	ecx
	not	ecx
	and	eax, ecx
	mov	DWORD PTR cp$[rbp+8], eax

; 1547 :         DebugMsg(("bin_write_module: MZ format, fixups=%u, sizehdr=%" I32_SPEC "X\n", reloccnt, cp.sizehdr ));

	movzx	eax, WORD PTR reloccnt$[rbp]
	mov	r8d, DWORD PTR cp$[rbp+8]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12441
	call	DoDebugMsg

; 1548 :         break;

	jmp	SHORT $LN5@bin_write_
$LN32@bin_write_:

; 1549 : #endif
; 1550 :     default:
; 1551 :         cp.sizehdr = 0;

	mov	DWORD PTR cp$[rbp+8], 0
$LN5@bin_write_:

; 1552 :     }
; 1553 :     cp.fileoffset = cp.sizehdr;

	mov	eax, DWORD PTR cp$[rbp+8]
	mov	DWORD PTR cp$[rbp+4], eax

; 1554 : 
; 1555 :     if ( cp.sizehdr ) {

	cmp	DWORD PTR cp$[rbp+8], 0
	je	SHORT $LN33@bin_write_

; 1556 :         hdrbuf = LclAlloc( cp.sizehdr );

	mov	eax, DWORD PTR cp$[rbp+8]
	mov	ecx, eax
	call	LclAlloc
	mov	QWORD PTR hdrbuf$[rbp], rax

; 1557 :         memset( hdrbuf, 0, cp.sizehdr );

	mov	eax, DWORD PTR cp$[rbp+8]
	mov	r8d, eax
	xor	edx, edx
	mov	rcx, QWORD PTR hdrbuf$[rbp]
	call	memset
$LN33@bin_write_:

; 1558 :     }
; 1559 :     cp.entryoffset = -1;

	mov	DWORD PTR cp$[rbp+12], -1		; ffffffffH

; 1560 : 
; 1561 :     /* set starting offsets for all sections */
; 1562 : 
; 1563 : #if PE_SUPPORT
; 1564 :     cp.rva = 0;

	mov	DWORD PTR cp$[rbp+28], 0

; 1565 :     if ( modinfo->sub_format == SFORMAT_PE ) {

	mov	rax, QWORD PTR modinfo$[rbp]
	cmp	DWORD PTR [rax+372], 2
	jne	SHORT $LN34@bin_write_

; 1566 :         if ( ModuleInfo.model == MODEL_NONE ) {

	cmp	DWORD PTR ModuleInfo+360, 0
	jne	SHORT $LN36@bin_write_

; 1567 :             return( EmitErr( MODEL_IS_NOT_DECLARED ) );

	mov	ecx, 96					; 00000060H
	call	EmitErr
	jmp	$LN1@bin_write_
$LN36@bin_write_:

; 1568 :         }
; 1569 :         pe_set_values( &cp );

	lea	rcx, QWORD PTR cp$[rbp]
	call	pe_set_values

; 1570 :     } else

	jmp	$LN35@bin_write_
$LN34@bin_write_:

; 1571 : #endif
; 1572 :     if ( modinfo->segorder == SEGORDER_DOSSEG ) {

	mov	rax, QWORD PTR modinfo$[rbp]
	cmp	DWORD PTR [rax+380], 1
	jne	$LN37@bin_write_

; 1573 :         DebugMsg(("bin_write_module: .DOSSEG active\n" ));

	lea	rcx, OFFSET FLAT:$SG12449
	call	DoDebugMsg

; 1574 :         /* for .DOSSEG, regroup segments (CODE, UNDEF, DATA, BSS) */
; 1575 :         for ( i = 0 ; i < SIZE_DOSSEG; i++ ) {

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN9@bin_write_
$LN7@bin_write_:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN9@bin_write_:
	movsxd	rax, DWORD PTR i$[rbp]
	cmp	rax, 6
	jae	$LN8@bin_write_

; 1576 :             DebugMsg(("bin_write_module: searching segment types %Xh\n", dosseg_order[i] ));

	movsxd	rax, DWORD PTR i$[rbp]
	lea	rcx, OFFSET FLAT:dosseg_order
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12450
	call	DoDebugMsg

; 1577 :             for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rbp], rax
	jmp	SHORT $LN12@bin_write_
$LN10@bin_write_:
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rbp], rax
$LN12@bin_write_:
	cmp	QWORD PTR curr$[rbp], 0
	je	SHORT $LN11@bin_write_

; 1578 :                 if ( curr->e.seginfo->segtype != dosseg_order[i] )

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	movsxd	rcx, DWORD PTR i$[rbp]
	lea	rdx, OFFSET FLAT:dosseg_order
	mov	ecx, DWORD PTR [rdx+rcx*4]
	cmp	DWORD PTR [rax+72], ecx
	je	SHORT $LN39@bin_write_

; 1579 :                     continue;

	jmp	SHORT $LN10@bin_write_
$LN39@bin_write_:

; 1580 :                 CalcOffset( curr, &cp );

	lea	rdx, QWORD PTR cp$[rbp]
	mov	rcx, QWORD PTR curr$[rbp]
	call	CalcOffset

; 1581 :                 DebugMsg(("bin_write_module: section %s, start ofs=%" I32_SPEC "Xh, size=%" I32_SPEC "Xh, file ofs=%" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rbp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR curr$[rbp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	edx, DWORD PTR [rdx+56]
	sub	edx, ecx
	mov	ecx, edx
	mov	rdx, QWORD PTR curr$[rbp]
	mov	rdx, QWORD PTR [rdx+96]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, DWORD PTR [rdx+12]
	mov	rax, QWORD PTR curr$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12452
	call	DoDebugMsg

; 1582 :                           curr->sym.name, curr->e.seginfo->start_offset, curr->sym.max_offset - curr->e.seginfo->start_loc, curr->e.seginfo->fileoffset ));
; 1583 :             }

	jmp	$LN10@bin_write_
$LN11@bin_write_:

; 1584 :         }

	jmp	$LN7@bin_write_
$LN8@bin_write_:

; 1585 :         SortSegments( 0 );

	xor	ecx, ecx
	call	SortSegments

; 1586 :     } else { /* segment order .SEQ (default) and .ALPHA */

	jmp	$LN38@bin_write_
$LN37@bin_write_:

; 1587 :         
; 1588 :         if ( modinfo->segorder == SEGORDER_ALPHA ) {

	mov	rax, QWORD PTR modinfo$[rbp]
	cmp	DWORD PTR [rax+380], 2
	jne	SHORT $LN40@bin_write_

; 1589 :             DebugMsg(("bin_write_module: .ALPHA active\n" ));

	lea	rcx, OFFSET FLAT:$SG12454
	call	DoDebugMsg

; 1590 :             SortSegments( 1 );

	mov	ecx, 1
	call	SortSegments
$LN40@bin_write_:

; 1591 :         }
; 1592 :         for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rbp], rax
	jmp	SHORT $LN15@bin_write_
$LN13@bin_write_:
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rbp], rax
$LN15@bin_write_:
	cmp	QWORD PTR curr$[rbp], 0
	je	$LN14@bin_write_

; 1593 :             /* ignore absolute segments */
; 1594 :             CalcOffset( curr, &cp );

	lea	rdx, QWORD PTR cp$[rbp]
	mov	rcx, QWORD PTR curr$[rbp]
	call	CalcOffset

; 1595 :             DebugMsg(("bin_write_module(%s): start ofs=%" I32_SPEC "Xh, size=%" I32_SPEC "Xh, file ofs=%" I32_SPEC "Xh, grp=%s\n",

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN77@bin_write_
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv209[rbp], rax
	jmp	SHORT $LN78@bin_write_
$LN77@bin_write_:
	lea	rax, OFFSET FLAT:$SG12455
	mov	QWORD PTR tv209[rbp], rax
$LN78@bin_write_:
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rbp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR curr$[rbp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	edx, DWORD PTR [rdx+56]
	sub	edx, ecx
	mov	ecx, edx
	mov	rdx, QWORD PTR curr$[rbp]
	mov	rdx, QWORD PTR [rdx+96]
	mov	rdi, QWORD PTR tv209[rbp]
	mov	QWORD PTR [rsp+40], rdi
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, DWORD PTR [rdx+12]
	mov	rax, QWORD PTR curr$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12456
	call	DoDebugMsg

; 1596 :                       curr->sym.name, curr->e.seginfo->start_offset, curr->sym.max_offset - curr->e.seginfo->start_loc, curr->e.seginfo->fileoffset, (curr->e.seginfo->group ? curr->e.seginfo->group->name : "NULL" )));
; 1597 :         }

	jmp	$LN13@bin_write_
$LN14@bin_write_:
$LN38@bin_write_:
$LN35@bin_write_:

; 1598 :     }
; 1599 :     DebugMsg(("bin_write_module: all CalcOffset() done\n" ));

	lea	rcx, OFFSET FLAT:$SG12457
	call	DoDebugMsg

; 1600 : 
; 1601 :     /* handle relocs */
; 1602 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rbp], rax
	jmp	SHORT $LN18@bin_write_
$LN16@bin_write_:
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rbp], rax
$LN18@bin_write_:
	cmp	QWORD PTR curr$[rbp], 0
	je	SHORT $LN17@bin_write_

; 1603 :         /* v2.04: scan ALL fixups! */
; 1604 :         //if ( DoFixup( curr ) == ERROR )
; 1605 :         //    return( ERROR );
; 1606 :         DoFixup( curr, &cp );

	lea	rdx, QWORD PTR cp$[rbp]
	mov	rcx, QWORD PTR curr$[rbp]
	call	DoFixup

; 1607 : #if MZ_SUPPORT
; 1608 :         if ( stack == NULL &&

	cmp	QWORD PTR stack$[rbp], 0
	jne	SHORT $LN41@bin_write_
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+108]
	and	al, 7
	movzx	eax, al
	cmp	eax, 5
	jne	SHORT $LN41@bin_write_

; 1609 :             curr->e.seginfo->combine == COMB_STACK )
; 1610 :             stack = curr;

	mov	rax, QWORD PTR curr$[rbp]
	mov	QWORD PTR stack$[rbp], rax
$LN41@bin_write_:

; 1611 : #endif
; 1612 :     }

	jmp	SHORT $LN16@bin_write_
$LN17@bin_write_:

; 1613 :     /* v2.04: return if any errors occured during fixup handling */
; 1614 :     if ( modinfo->g.error_count )

	mov	rax, QWORD PTR modinfo$[rbp]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN42@bin_write_

; 1615 :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@bin_write_
$LN42@bin_write_:

; 1616 : 
; 1617 :     /* for plain binaries make sure the start label is at
; 1618 :      * the beginning of the first segment */
; 1619 :     if ( modinfo->sub_format == SFORMAT_NONE ) {

	mov	rax, QWORD PTR modinfo$[rbp]
	cmp	DWORD PTR [rax+372], 0
	jne	SHORT $LN43@bin_write_

; 1620 :         if ( modinfo->g.start_label ) {

	mov	rax, QWORD PTR modinfo$[rbp]
	cmp	QWORD PTR [rax+208], 0
	je	SHORT $LN44@bin_write_

; 1621 :             if ( cp.entryoffset == -1 || cp.entryseg != modinfo->g.start_label->segment ) {

	cmp	DWORD PTR cp$[rbp+12], -1		; ffffffffH
	je	SHORT $LN46@bin_write_
	mov	rax, QWORD PTR modinfo$[rbp]
	mov	rax, QWORD PTR [rax+208]
	mov	rax, QWORD PTR [rax+24]
	cmp	QWORD PTR cp$[rbp+16], rax
	je	SHORT $LN45@bin_write_
$LN46@bin_write_:

; 1622 :                 return( EmitError( START_LABEL_INVALID ) );

	mov	ecx, 202				; 000000caH
	call	EmitError
	jmp	$LN1@bin_write_
$LN45@bin_write_:
$LN44@bin_write_:
$LN43@bin_write_:

; 1623 :             }
; 1624 :         }
; 1625 :     }
; 1626 : 
; 1627 :     sizetotal = GetImageSize( FALSE );

	xor	ecx, ecx
	call	GetImageSize
	mov	DWORD PTR sizetotal$[rbp], eax

; 1628 : 
; 1629 :     /* for MZ|PE format, initialize the header */
; 1630 : 
; 1631 :     switch ( modinfo->sub_format ) {

	mov	rax, QWORD PTR modinfo$[rbp]
	mov	eax, DWORD PTR [rax+372]
	mov	DWORD PTR tv254[rbp], eax
	cmp	DWORD PTR tv254[rbp], 1
	je	SHORT $LN47@bin_write_
	jmp	$LN19@bin_write_
$LN47@bin_write_:

; 1632 : #if MZ_SUPPORT
; 1633 :     case SFORMAT_MZ:
; 1634 :         /* set fields in MZ header */
; 1635 :         pMZ = (struct IMAGE_DOS_HEADER *)hdrbuf;

	mov	rax, QWORD PTR hdrbuf$[rbp]
	mov	QWORD PTR pMZ$[rbp], rax

; 1636 :         pMZ->e_magic   = 'M' + ('Z' << 8);

	mov	eax, 23117				; 00005a4dH
	mov	rcx, QWORD PTR pMZ$[rbp]
	mov	WORD PTR [rcx], ax

; 1637 :         pMZ->e_cblp    = sizetotal % 512; /* bytes last page */

	xor	edx, edx
	mov	eax, DWORD PTR sizetotal$[rbp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	eax, edx
	mov	rcx, QWORD PTR pMZ$[rbp]
	mov	WORD PTR [rcx+2], ax

; 1638 :         pMZ->e_cp      = sizetotal / 512 + (sizetotal % 512 ? 1 : 0); /* pages */

	xor	edx, edx
	mov	eax, DWORD PTR sizetotal$[rbp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	eax, edx
	test	eax, eax
	je	SHORT $LN79@bin_write_
	mov	DWORD PTR tv263[rbp], 1
	jmp	SHORT $LN80@bin_write_
$LN79@bin_write_:
	mov	DWORD PTR tv263[rbp], 0
$LN80@bin_write_:
	xor	edx, edx
	mov	eax, DWORD PTR sizetotal$[rbp]
	mov	ecx, 512				; 00000200H
	div	ecx
	add	eax, DWORD PTR tv263[rbp]
	mov	rcx, QWORD PTR pMZ$[rbp]
	mov	WORD PTR [rcx+4], ax

; 1639 :         pMZ->e_crlc    = reloccnt;

	mov	rax, QWORD PTR pMZ$[rbp]
	movzx	ecx, WORD PTR reloccnt$[rbp]
	mov	WORD PTR [rax+6], cx

; 1640 :         pMZ->e_cparhdr = cp.sizehdr >> 4; /* size header in paras */

	mov	eax, DWORD PTR cp$[rbp+8]
	shr	eax, 4
	mov	rcx, QWORD PTR pMZ$[rbp]
	mov	WORD PTR [rcx+8], ax

; 1641 :         sizeheap = GetImageSize( TRUE ) - sizetotal;

	mov	cl, 1
	call	GetImageSize
	sub	eax, DWORD PTR sizetotal$[rbp]
	mov	DWORD PTR sizeheap$[rbp], eax

; 1642 :         DebugMsg(( "bin_write_module: MZ, sizetotal=%" I32_SPEC "Xh sizeheap=%" I32_SPEC "Xh\n", sizetotal, sizeheap ));

	mov	r8d, DWORD PTR sizeheap$[rbp]
	mov	edx, DWORD PTR sizetotal$[rbp]
	lea	rcx, OFFSET FLAT:$SG12465
	call	DoDebugMsg

; 1643 :         pMZ->e_minalloc = sizeheap / 16 + ((sizeheap % 16) ? 1 : 0); /* heap min */

	xor	edx, edx
	mov	eax, DWORD PTR sizeheap$[rbp]
	mov	ecx, 16
	div	ecx
	mov	eax, edx
	test	eax, eax
	je	SHORT $LN81@bin_write_
	mov	DWORD PTR tv280[rbp], 1
	jmp	SHORT $LN82@bin_write_
$LN81@bin_write_:
	mov	DWORD PTR tv280[rbp], 0
$LN82@bin_write_:
	xor	edx, edx
	mov	eax, DWORD PTR sizeheap$[rbp]
	mov	ecx, 16
	div	ecx
	add	eax, DWORD PTR tv280[rbp]
	mov	rcx, QWORD PTR pMZ$[rbp]
	mov	WORD PTR [rcx+10], ax

; 1644 :         if ( pMZ->e_minalloc < modinfo->mz_data.heapmin )

	mov	rax, QWORD PTR pMZ$[rbp]
	movzx	eax, WORD PTR [rax+10]
	mov	rcx, QWORD PTR modinfo$[rbp]
	movzx	ecx, WORD PTR [rcx+416]
	cmp	eax, ecx
	jge	SHORT $LN48@bin_write_

; 1645 :             pMZ->e_minalloc = modinfo->mz_data.heapmin;

	mov	rax, QWORD PTR pMZ$[rbp]
	mov	rcx, QWORD PTR modinfo$[rbp]
	movzx	ecx, WORD PTR [rcx+416]
	mov	WORD PTR [rax+10], cx
$LN48@bin_write_:

; 1646 :         pMZ->e_maxalloc = modinfo->mz_data.heapmax; /* heap max */

	mov	rax, QWORD PTR pMZ$[rbp]
	mov	rcx, QWORD PTR modinfo$[rbp]
	movzx	ecx, WORD PTR [rcx+418]
	mov	WORD PTR [rax+12], cx

; 1647 :         if ( pMZ->e_maxalloc < pMZ->e_minalloc )

	mov	rax, QWORD PTR pMZ$[rbp]
	movzx	eax, WORD PTR [rax+12]
	mov	rcx, QWORD PTR pMZ$[rbp]
	movzx	ecx, WORD PTR [rcx+10]
	cmp	eax, ecx
	jge	SHORT $LN49@bin_write_

; 1648 :             pMZ->e_maxalloc = pMZ->e_minalloc;

	mov	rax, QWORD PTR pMZ$[rbp]
	mov	rcx, QWORD PTR pMZ$[rbp]
	movzx	ecx, WORD PTR [rcx+10]
	mov	WORD PTR [rax+12], cx
$LN49@bin_write_:

; 1649 : 
; 1650 :         /* set stack if there's one defined */
; 1651 : 
; 1652 :         if ( stack ) {

	cmp	QWORD PTR stack$[rbp], 0
	je	$LN50@bin_write_

; 1653 :             uint_32 addr = stack->e.seginfo->start_offset;

	mov	rax, QWORD PTR stack$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR addr$1[rbp], eax

; 1654 :             if ( stack->e.seginfo->group )

	mov	rax, QWORD PTR stack$[rbp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN52@bin_write_

; 1655 :                 addr += stack->e.seginfo->group->offset;

	mov	rax, QWORD PTR stack$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+16]
	mov	ecx, DWORD PTR addr$1[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR addr$1[rbp], eax
$LN52@bin_write_:

; 1656 :             DebugMsg(("bin_write_module: MZ, stack=%" I32_SPEC "Xh ofs=%" I32_SPEC "Xh\n", addr, stack->sym.max_offset ));

	mov	rax, QWORD PTR stack$[rbp]
	mov	r8d, DWORD PTR [rax+56]
	mov	edx, DWORD PTR addr$1[rbp]
	lea	rcx, OFFSET FLAT:$SG12471
	call	DoDebugMsg

; 1657 :             pMZ->e_ss = (addr >> 4) + ((addr & 0xF) ? 1 : 0); /* SS */

	mov	eax, DWORD PTR addr$1[rbp]
	and	eax, 15
	test	eax, eax
	je	SHORT $LN83@bin_write_
	mov	DWORD PTR tv317[rbp], 1
	jmp	SHORT $LN84@bin_write_
$LN83@bin_write_:
	mov	DWORD PTR tv317[rbp], 0
$LN84@bin_write_:
	mov	eax, DWORD PTR addr$1[rbp]
	shr	eax, 4
	add	eax, DWORD PTR tv317[rbp]
	mov	rcx, QWORD PTR pMZ$[rbp]
	mov	WORD PTR [rcx+14], ax

; 1658 :             /* v2.11: changed sym.offset to sym.max_offset */
; 1659 :             pMZ->e_sp = stack->sym.max_offset; /* SP */

	mov	rax, QWORD PTR pMZ$[rbp]
	mov	rcx, QWORD PTR stack$[rbp]
	movzx	ecx, WORD PTR [rcx+56]
	mov	WORD PTR [rax+16], cx

; 1660 :         } else {

	jmp	SHORT $LN51@bin_write_
$LN50@bin_write_:

; 1661 :             EmitWarn( 2, NO_STACK );

	mov	edx, 204				; 000000ccH
	mov	ecx, 2
	call	EmitWarn
$LN51@bin_write_:

; 1662 :         }
; 1663 :         pMZ->e_csum = 0; /* checksum */

	xor	eax, eax
	mov	rcx, QWORD PTR pMZ$[rbp]
	mov	WORD PTR [rcx+18], ax

; 1664 : 
; 1665 :         /* set entry CS:IP if defined */
; 1666 : 
; 1667 :         if ( modinfo->g.start_label ) {

	mov	rax, QWORD PTR modinfo$[rbp]
	cmp	QWORD PTR [rax+208], 0
	je	$LN53@bin_write_

; 1668 :             uint_32 addr;
; 1669 :             curr = (struct dsym *)modinfo->g.start_label->segment;

	mov	rax, QWORD PTR modinfo$[rbp]
	mov	rax, QWORD PTR [rax+208]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR curr$[rbp], rax

; 1670 :             DebugMsg(("bin_write_module, start_label: offs=%" I32_SPEC "Xh, seg.offs=%" I32_SPEC "Xh, group.offs=%" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN85@bin_write_
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv335[rbp], eax
	jmp	SHORT $LN86@bin_write_
$LN85@bin_write_:
	mov	DWORD PTR tv335[rbp], 0
$LN86@bin_write_:
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR modinfo$[rbp]
	mov	rcx, QWORD PTR [rcx+208]
	mov	r9d, DWORD PTR tv335[rbp]
	mov	r8d, DWORD PTR [rax+12]
	mov	edx, DWORD PTR [rcx+16]
	lea	rcx, OFFSET FLAT:$SG12474
	call	DoDebugMsg

; 1671 :                       modinfo->g.start_label->offset, curr->e.seginfo->start_offset, curr->e.seginfo->group ? curr->e.seginfo->group->offset : 0 ));
; 1672 :             if ( curr->e.seginfo->group ) {

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN55@bin_write_

; 1673 :                 addr = curr->e.seginfo->group->offset;

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR addr$2[rbp], eax

; 1674 :                 pMZ->e_ip = (addr & 0xF ) + curr->e.seginfo->start_offset + modinfo->g.start_label->offset; /* IP */

	mov	eax, DWORD PTR addr$2[rbp]
	and	eax, 15
	mov	rcx, QWORD PTR curr$[rbp]
	mov	rcx, QWORD PTR [rcx+96]
	add	eax, DWORD PTR [rcx+12]
	mov	rcx, QWORD PTR modinfo$[rbp]
	mov	rcx, QWORD PTR [rcx+208]
	add	eax, DWORD PTR [rcx+16]
	mov	rcx, QWORD PTR pMZ$[rbp]
	mov	WORD PTR [rcx+20], ax

; 1675 :                 pMZ->e_cs = addr >> 4; /* CS */

	mov	eax, DWORD PTR addr$2[rbp]
	shr	eax, 4
	mov	rcx, QWORD PTR pMZ$[rbp]
	mov	WORD PTR [rcx+22], ax

; 1676 :             } else {

	jmp	SHORT $LN56@bin_write_
$LN55@bin_write_:

; 1677 :                 addr = curr->e.seginfo->start_offset;

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR addr$2[rbp], eax

; 1678 :                 pMZ->e_ip = (addr & 0xF ) + modinfo->g.start_label->offset; /* IP */

	mov	eax, DWORD PTR addr$2[rbp]
	and	eax, 15
	mov	rcx, QWORD PTR modinfo$[rbp]
	mov	rcx, QWORD PTR [rcx+208]
	add	eax, DWORD PTR [rcx+16]
	mov	rcx, QWORD PTR pMZ$[rbp]
	mov	WORD PTR [rcx+20], ax

; 1679 :                 pMZ->e_cs = addr >> 4; /* CS */

	mov	eax, DWORD PTR addr$2[rbp]
	shr	eax, 4
	mov	rcx, QWORD PTR pMZ$[rbp]
	mov	WORD PTR [rcx+22], ax
$LN56@bin_write_:

; 1680 :             }
; 1681 :         } else {

	jmp	SHORT $LN54@bin_write_
$LN53@bin_write_:

; 1682 :             DebugMsg(("bin_write_module, ModuleInfo->start_label=%p\n", modinfo->g.start_label ));

	mov	rax, QWORD PTR modinfo$[rbp]
	mov	rdx, QWORD PTR [rax+208]
	lea	rcx, OFFSET FLAT:$SG12477
	call	DoDebugMsg

; 1683 :             EmitWarn( 2, NO_START_LABEL );

	mov	edx, 203				; 000000cbH
	mov	ecx, 2
	call	EmitWarn
$LN54@bin_write_:

; 1684 :         }
; 1685 :         pMZ->e_lfarlc = modinfo->mz_data.ofs_fixups;

	mov	rax, QWORD PTR pMZ$[rbp]
	mov	rcx, QWORD PTR modinfo$[rbp]
	movzx	ecx, WORD PTR [rcx+412]
	mov	WORD PTR [rax+24], cx

; 1686 :         DebugMsg(("bin_write_module: MZ, mzdata ofs_fixups=%Xh, alignment=%Xh\n", modinfo->mz_data.ofs_fixups, modinfo->mz_data.alignment ));

	mov	rax, QWORD PTR modinfo$[rbp]
	movzx	eax, WORD PTR [rax+414]
	mov	rcx, QWORD PTR modinfo$[rbp]
	movzx	ecx, WORD PTR [rcx+412]
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG12478
	call	DoDebugMsg

; 1687 :         GetSegRelocs( (uint_16 *)( hdrbuf + pMZ->e_lfarlc ) );

	mov	rax, QWORD PTR pMZ$[rbp]
	movzx	eax, WORD PTR [rax+24]
	mov	rcx, QWORD PTR hdrbuf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	GetSegRelocs
$LN19@bin_write_:

; 1688 :         break;
; 1689 : #endif
; 1690 :     }
; 1691 : 
; 1692 : #if SECTORMAP
; 1693 :     if( CurrFile[LST] ) {

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN57@bin_write_

; 1694 :         /* go to EOF */
; 1695 :         fseek( CurrFile[LST], 0, SEEK_END );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r8d, 2
	xor	edx, edx
	mov	rcx, QWORD PTR [rcx+rax]
	call	fseek

; 1696 :         LstNL();

	call	LstNL

; 1697 :         LstNL();

	call	LstNL

; 1698 :         LstPrintf( szCaption );

	lea	rcx, OFFSET FLAT:szCaption
	call	LstPrintf

; 1699 :         LstNL();

	call	LstNL

; 1700 :         LstNL();

	call	LstNL

; 1701 :         LstPrintf( szCaption2 );

	lea	rcx, OFFSET FLAT:szCaption2
	call	LstPrintf

; 1702 :         LstNL();

	call	LstNL

; 1703 :         LstPrintf( szSep );

	lea	rcx, OFFSET FLAT:szSep
	call	LstPrintf

; 1704 :         LstNL();

	call	LstNL
$LN57@bin_write_:

; 1705 :     }
; 1706 : #endif
; 1707 : 
; 1708 :     if ( cp.sizehdr ) {

	cmp	DWORD PTR cp$[rbp+8], 0
	je	SHORT $LN58@bin_write_

; 1709 :         if ( fwrite( hdrbuf, 1, cp.sizehdr, CurrFile[OBJ] ) != cp.sizehdr )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	edx, DWORD PTR cp$[rbp+8]
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, edx
	mov	edx, 1
	mov	rcx, QWORD PTR hdrbuf$[rbp]
	call	fwrite
	mov	ecx, DWORD PTR cp$[rbp+8]
	cmp	rax, rcx
	je	SHORT $LN59@bin_write_

; 1710 :             WriteError();

	call	WriteError
$LN59@bin_write_:

; 1711 : #if SECTORMAP
; 1712 :         LstPrintf( szSegLine, szHeader, 0, 0, cp.sizehdr, 0 );

	mov	QWORD PTR [rsp+40], 0
	mov	eax, DWORD PTR cp$[rbp+8]
	mov	DWORD PTR [rsp+32], eax
	xor	r9d, r9d
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:szHeader
	lea	rcx, OFFSET FLAT:szSegLine
	call	LstPrintf

; 1713 :         LstNL();

	call	LstNL
$LN58@bin_write_:

; 1714 : #endif
; 1715 :         LclFree( hdrbuf );
; 1716 :     }
; 1717 : 
; 1718 : #ifdef DEBUG_OUT
; 1719 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rbp], rax
	jmp	SHORT $LN23@bin_write_
$LN21@bin_write_:
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rbp], rax
$LN23@bin_write_:
	cmp	QWORD PTR curr$[rbp], 0
	je	SHORT $LN22@bin_write_

; 1720 :         DebugMsg(("bin_write_module(%s): type=%u written=%" I32_SPEC "X max=%" I32_SPEC "X start=%" I32_SPEC "X fileofs=%" I32_SPEC "X\n",

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rbp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR curr$[rbp]
	mov	rdx, QWORD PTR [rdx+96]
	mov	rdi, QWORD PTR curr$[rbp]
	mov	rdi, QWORD PTR [rdi+96]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR curr$[rbp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR [rdx+24]
	mov	r8d, DWORD PTR [rdi+72]
	mov	rax, QWORD PTR curr$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12482
	call	DoDebugMsg

; 1721 :                 curr->sym.name, curr->e.seginfo->segtype,
; 1722 :                 curr->e.seginfo->bytes_written,
; 1723 :                 curr->sym.max_offset,
; 1724 :                 curr->e.seginfo->start_loc,
; 1725 :                 curr->e.seginfo->fileoffset ));
; 1726 :     }

	jmp	SHORT $LN21@bin_write_
$LN22@bin_write_:

; 1727 : #endif
; 1728 : 
; 1729 :     /* write sections */
; 1730 :     for( curr = SymTables[TAB_SEG].head, first = TRUE; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rbp], rax
	mov	DWORD PTR first$[rbp], 1
	jmp	SHORT $LN26@bin_write_
$LN24@bin_write_:
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rbp], rax
$LN26@bin_write_:
	cmp	QWORD PTR curr$[rbp], 0
	je	$LN25@bin_write_

; 1731 :         if ( curr->e.seginfo->segtype == SEGTYPE_ABS ) {

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 5
	jne	SHORT $LN60@bin_write_

; 1732 :             DebugMsg(("bin_write_module(%s): ABS segment not written\n", curr->sym.name ));

	mov	rax, QWORD PTR curr$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12484
	call	DoDebugMsg

; 1733 :             continue;

	jmp	SHORT $LN24@bin_write_
$LN60@bin_write_:

; 1734 :         }
; 1735 : #if PE_SUPPORT
; 1736 :         if ( ModuleInfo.sub_format == SFORMAT_PE &&

	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN61@bin_write_
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 3
	je	SHORT $LN63@bin_write_
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN61@bin_write_
$LN63@bin_write_:

; 1737 :             ( curr->e.seginfo->segtype == SEGTYPE_BSS || curr->e.seginfo->info ) )
; 1738 :             size = 0;

	mov	DWORD PTR size$[rbp], 0
	jmp	SHORT $LN62@bin_write_
$LN61@bin_write_:

; 1739 :         else
; 1740 : #endif
; 1741 :             /* v2.05: changed */
; 1742 :             size = curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rbp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR [rcx+56]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR size$[rbp], eax
$LN62@bin_write_:

; 1743 :         //size = sizemem;
; 1744 :         sizemem = first ? size : curr->sym.max_offset;

	cmp	DWORD PTR first$[rbp], 0
	je	SHORT $LN87@bin_write_
	mov	eax, DWORD PTR size$[rbp]
	mov	DWORD PTR tv469[rbp], eax
	jmp	SHORT $LN88@bin_write_
$LN87@bin_write_:
	mov	rax, QWORD PTR curr$[rbp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR tv469[rbp], eax
$LN88@bin_write_:
	mov	eax, DWORD PTR tv469[rbp]
	mov	DWORD PTR sizemem$[rbp], eax

; 1745 :         /* if no bytes have been written to the segment, check if there's
; 1746 :          * any further segments with bytes set. If no, skip write! */
; 1747 :         if ( curr->e.seginfo->bytes_written == 0 ) {

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN64@bin_write_

; 1748 :             struct dsym *dir;
; 1749 :             for ( dir = curr->next; dir; dir = dir->next )

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR dir$3[rbp], rax
	jmp	SHORT $LN29@bin_write_
$LN27@bin_write_:
	mov	rax, QWORD PTR dir$3[rbp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR dir$3[rbp], rax
$LN29@bin_write_:
	cmp	QWORD PTR dir$3[rbp], 0
	je	SHORT $LN28@bin_write_

; 1750 :                 if ( dir->e.seginfo->bytes_written )

	mov	rax, QWORD PTR dir$3[rbp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+24], 0
	je	SHORT $LN65@bin_write_

; 1751 :                     break;

	jmp	SHORT $LN28@bin_write_
$LN65@bin_write_:
	jmp	SHORT $LN27@bin_write_
$LN28@bin_write_:

; 1752 :             if ( !dir ) {

	cmp	QWORD PTR dir$3[rbp], 0
	jne	SHORT $LN66@bin_write_

; 1753 :                 DebugMsg(("bin_write_module(%s): segment not written, size=% " I32_SPEC "Xh sizemem=%" I32_SPEC "X\n",

	mov	r9d, DWORD PTR sizemem$[rbp]
	mov	r8d, DWORD PTR size$[rbp]
	mov	rax, QWORD PTR curr$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12491
	call	DoDebugMsg

; 1754 :                           curr->sym.name, size, sizemem ));
; 1755 :                 size = 0;

	mov	DWORD PTR size$[rbp], 0
$LN66@bin_write_:
$LN64@bin_write_:

; 1756 :             }
; 1757 :         }
; 1758 : #if SECTORMAP
; 1759 :         /* v2.05: changed
; 1760 :          * print name, fileoffset, objoffset, filesize, memsize
; 1761 :          */
; 1762 :         //LstPrintf( szSegLine, curr->sym.name, curr->e.seginfo->fileoffset, curr->e.seginfo->start_offset + curr->e.seginfo->start_loc, size, sizemem );
; 1763 :         LstPrintf( szSegLine, curr->sym.name, curr->e.seginfo->fileoffset, first ? curr->e.seginfo->start_offset + curr->e.seginfo->start_loc : curr->e.seginfo->start_offset, size, sizemem );

	cmp	DWORD PTR first$[rbp], 0
	je	SHORT $LN89@bin_write_
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rbp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	eax, DWORD PTR [rax+12]
	add	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR tv495[rbp], eax
	jmp	SHORT $LN90@bin_write_
$LN89@bin_write_:
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR tv495[rbp], eax
$LN90@bin_write_:
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR sizemem$[rbp]
	mov	DWORD PTR [rsp+40], ecx
	mov	ecx, DWORD PTR size$[rbp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR tv495[rbp]
	mov	r8d, DWORD PTR [rax+56]
	mov	rax, QWORD PTR curr$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:szSegLine
	call	LstPrintf

; 1764 :         LstNL();

	call	LstNL

; 1765 : #endif
; 1766 :         if ( size != 0 && curr->e.seginfo->CodeBuffer ) {

	cmp	DWORD PTR size$[rbp], 0
	je	$LN67@bin_write_
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+16], 0
	je	$LN67@bin_write_

; 1767 :             DebugMsg(("bin_write_module(%s): write %" I32_SPEC "Xh bytes at offset %" I32_SPEC "Xh, initialized bytes=%" I32_SPEC "u, buffer=%p\n",

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rbp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR curr$[rbp]
	mov	rdx, QWORD PTR [rdx+96]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR [rcx+24]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR [rdx+56]
	mov	r8d, DWORD PTR size$[rbp]
	mov	rax, QWORD PTR curr$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12494
	call	DoDebugMsg

; 1768 :                       curr->sym.name, size, curr->e.seginfo->fileoffset, curr->e.seginfo->bytes_written, curr->e.seginfo->CodeBuffer ));
; 1769 :             fseek( CurrFile[OBJ], curr->e.seginfo->fileoffset, SEEK_SET );

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 8
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR tv628[rbp], rdx
	xor	r8d, r8d
	mov	edx, DWORD PTR [rax+56]
	mov	rax, QWORD PTR tv628[rbp]
	mov	rcx, QWORD PTR [rax+rcx]
	call	fseek

; 1770 : #ifdef __I86__
; 1771 :             if ( hfwrite( curr->e.seginfo->CodeBuffer, 1, size, CurrFile[OBJ] ) != size )
; 1772 :                 WriteError();
; 1773 : #else
; 1774 :             if ( fwrite( curr->e.seginfo->CodeBuffer, 1, size, CurrFile[OBJ] ) != size )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	edx, DWORD PTR size$[rbp]
	mov	rdi, QWORD PTR curr$[rbp]
	mov	rdi, QWORD PTR [rdi+96]
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, edx
	mov	edx, 1
	mov	rcx, QWORD PTR [rdi+16]
	call	fwrite
	mov	ecx, DWORD PTR size$[rbp]
	cmp	rax, rcx
	je	SHORT $LN69@bin_write_

; 1775 :                 WriteError();

	call	WriteError
$LN69@bin_write_:

; 1776 : #endif
; 1777 :         }

	jmp	SHORT $LN68@bin_write_
$LN67@bin_write_:

; 1778 : #ifdef DEBUG_OUT
; 1779 :         else DebugMsg(("bin_write_module(%s): nothing written\n", curr->sym.name ));

	mov	rax, QWORD PTR curr$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12496
	call	DoDebugMsg
$LN68@bin_write_:

; 1780 : #endif
; 1781 :         first = FALSE;

	mov	DWORD PTR first$[rbp], 0

; 1782 :     }

	jmp	$LN24@bin_write_
$LN25@bin_write_:

; 1783 : #if PE_SUPPORT && RAWSIZE_ROUND
; 1784 :     if ( modinfo->sub_format == SFORMAT_PE ) {

	mov	rax, QWORD PTR modinfo$[rbp]
	cmp	DWORD PTR [rax+372], 2
	jne	$LN70@bin_write_

; 1785 :         size = ftell( CurrFile[OBJ] );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	ftell
	mov	DWORD PTR size$[rbp], eax

; 1786 :         if ( size & ( cp.rawpagesize - 1 ) ) {

	mov	eax, DWORD PTR cp$[rbp+40]
	dec	eax
	mov	ecx, DWORD PTR size$[rbp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	$LN71@bin_write_

; 1787 :             char *tmp;
; 1788 :             size = cp.rawpagesize - ( size & ( cp.rawpagesize - 1 ) );

	mov	eax, DWORD PTR cp$[rbp+40]
	dec	eax
	mov	ecx, DWORD PTR size$[rbp]
	and	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR cp$[rbp+40]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR size$[rbp], eax

; 1789 :             tmp = myalloca( size );

	mov	eax, DWORD PTR size$[rbp]
	mov	ecx, eax
	add	rcx, 15
	cmp	rcx, rax
	ja	SHORT $LN91@bin_write_
	mov	rcx, 1152921504606846960		; 0ffffffffffffff0H
$LN91@bin_write_:
	and	rcx, -16
	mov	rax, rcx
	call	__chkstk
	sub	rsp, rax
	lea	rax, QWORD PTR [rsp+64]
	mov	QWORD PTR tmp$4[rbp], rax

; 1790 :             memset( tmp, 0, size );

	mov	eax, DWORD PTR size$[rbp]
	mov	r8d, eax
	xor	edx, edx
	mov	rcx, QWORD PTR tmp$4[rbp]
	call	memset

; 1791 :             fwrite( tmp, 1, size, CurrFile[OBJ] );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	edx, DWORD PTR size$[rbp]
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, edx
	mov	edx, 1
	mov	rcx, QWORD PTR tmp$4[rbp]
	call	fwrite
$LN71@bin_write_:
$LN70@bin_write_:

; 1792 :         }
; 1793 :     }
; 1794 : #endif
; 1795 : #if SECTORMAP
; 1796 :     LstPrintf( szSep );

	lea	rcx, OFFSET FLAT:szSep
	call	LstPrintf

; 1797 :     LstNL();

	call	LstNL

; 1798 : #if MZ_SUPPORT
; 1799 :     if ( modinfo->sub_format == SFORMAT_MZ )

	mov	rax, QWORD PTR modinfo$[rbp]
	cmp	DWORD PTR [rax+372], 1
	jne	SHORT $LN72@bin_write_

; 1800 :         sizeheap += sizetotal - cp.sizehdr;

	mov	eax, DWORD PTR cp$[rbp+8]
	mov	ecx, DWORD PTR sizetotal$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR sizeheap$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR sizeheap$[rbp], eax
	jmp	SHORT $LN73@bin_write_
$LN72@bin_write_:

; 1801 :     else
; 1802 : #endif
; 1803 : #if PE_SUPPORT
; 1804 :     if ( modinfo->sub_format == SFORMAT_PE )

	mov	rax, QWORD PTR modinfo$[rbp]
	cmp	DWORD PTR [rax+372], 2
	jne	SHORT $LN74@bin_write_

; 1805 :         sizeheap = cp.rva;

	mov	eax, DWORD PTR cp$[rbp+28]
	mov	DWORD PTR sizeheap$[rbp], eax
	jmp	SHORT $LN75@bin_write_
$LN74@bin_write_:

; 1806 :     else
; 1807 : #endif
; 1808 :         sizeheap = GetImageSize( TRUE );

	mov	cl, 1
	call	GetImageSize
	mov	DWORD PTR sizeheap$[rbp], eax
$LN75@bin_write_:
$LN73@bin_write_:

; 1809 :     LstPrintf( szTotal, " ", sizetotal, sizeheap );

	mov	r9d, DWORD PTR sizeheap$[rbp]
	mov	r8d, DWORD PTR sizetotal$[rbp]
	lea	rdx, OFFSET FLAT:$SG12503
	lea	rcx, OFFSET FLAT:szTotal
	call	LstPrintf

; 1810 :     LstNL();

	call	LstNL

; 1811 : #endif
; 1812 :     DebugMsg(("bin_write_module: exit\n"));

	lea	rcx, OFFSET FLAT:$SG12504
	call	DoDebugMsg

; 1813 : 
; 1814 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@bin_write_:

; 1815 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
bin_write_module ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
modinfo$ = 48
pe_enddirhook PROC

; 1495 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1496 :     pe_create_MZ_header( modinfo );

	mov	rcx, QWORD PTR modinfo$[rsp]
	call	pe_create_MZ_header

; 1497 :     //pe_create_PE_header(); /* the PE header is created when the .MODEL directive is found */
; 1498 :     pe_emit_export_data();

	call	pe_emit_export_data

; 1499 :     if ( modinfo->g.DllQueue )

	mov	rax, QWORD PTR modinfo$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN2@pe_enddirh

; 1500 :         pe_emit_import_data();

	call	pe_emit_import_data
$LN2@pe_enddirh:

; 1501 :     pe_create_section_table();

	call	pe_create_section_table

; 1502 :     return( NOT_ERROR );

	xor	eax, eax

; 1503 : }

	add	rsp, 40					; 00000028H
	ret	0
pe_enddirhook ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
curr$ = 48
i$ = 56
section$ = 64
ph32$ = 72
sizeimg$ = 80
datadir$ = 88
ph64$ = 96
reloc$ = 104
ff$ = 112
codesize$ = 116
codebase$ = 120
sizehdr$ = 124
datasize$ = 128
database$ = 132
objtab$ = 136
tv181 = 144
tv187 = 148
malign$ = 152
tv265 = 156
align$1 = 160
pehdr$ = 168
size$2 = 176
tv702 = 180
falign$ = 184
mzhdr$ = 192
tv293 = 200
idata_null$3 = 208
idata_iat$4 = 216
tv527 = 224
tv534 = 232
fh$ = 240
secname$ = 248
buffer$ = 256
__$ArrayPad$ = 512
cp$ = 544
pe_set_values PROC

; 1232 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 536				; 00000218H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1233 :     int i;
; 1234 :     int falign;
; 1235 :     int malign;
; 1236 :     uint_16 ff;
; 1237 :     uint_32 codebase = 0;

	mov	DWORD PTR codebase$[rsp], 0

; 1238 :     uint_32 database = 0;

	mov	DWORD PTR database$[rsp], 0

; 1239 :     uint_32 codesize = 0;

	mov	DWORD PTR codesize$[rsp], 0

; 1240 :     uint_32 datasize = 0;

	mov	DWORD PTR datasize$[rsp], 0

; 1241 :     uint_32 sizehdr  = 0;

	mov	DWORD PTR sizehdr$[rsp], 0

; 1242 :     uint_32 sizeimg  = 0;

	mov	DWORD PTR sizeimg$[rsp], 0

; 1243 :     struct dsym *curr;
; 1244 :     struct dsym *mzhdr;
; 1245 :     struct dsym *pehdr;
; 1246 :     struct dsym *objtab;
; 1247 :     struct dsym *reloc = NULL;

	mov	QWORD PTR reloc$[rsp], 0

; 1248 :     struct IMAGE_PE_HEADER32 *ph32;
; 1249 : #if AMD64_SUPPORT
; 1250 :     struct IMAGE_PE_HEADER64 *ph64;
; 1251 : #endif
; 1252 :     struct IMAGE_FILE_HEADER *fh;
; 1253 :     struct IMAGE_SECTION_HEADER *section;
; 1254 :     struct IMAGE_DATA_DIRECTORY *datadir;
; 1255 :     char *secname;
; 1256 :     char buffer[MAX_ID_LEN+1];
; 1257 : 
; 1258 :     mzhdr  = ( struct dsym *)SymSearch( hdrname "1" );

	lea	rcx, OFFSET FLAT:$SG12325
	call	SymFind
	mov	QWORD PTR mzhdr$[rsp], rax

; 1259 :     pehdr  = ( struct dsym *)SymSearch( hdrname "2" );

	lea	rcx, OFFSET FLAT:$SG12326
	call	SymFind
	mov	QWORD PTR pehdr$[rsp], rax

; 1260 :     objtab = ( struct dsym *)SymSearch( hdrname "3" );

	lea	rcx, OFFSET FLAT:$SG12327
	call	SymFind
	mov	QWORD PTR objtab$[rsp], rax

; 1261 : 
; 1262 :     /* make sure all header objects are in FLAT group */
; 1263 :     mzhdr->e.seginfo->group = &ModuleInfo.flat_grp->sym;

	mov	rax, QWORD PTR ModuleInfo+440
	mov	rcx, QWORD PTR mzhdr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx], rax

; 1264 : #if AMD64_SUPPORT
; 1265 :     if ( ModuleInfo.defOfssize == USE64 ) {

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN14@pe_set_val

; 1266 :         ph64 = ( struct IMAGE_PE_HEADER64 *)pehdr->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR pehdr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR ph64$[rsp], rax

; 1267 :         ff = ph64->FileHeader.Characteristics;

	mov	rax, QWORD PTR ph64$[rsp]
	movzx	eax, WORD PTR [rax+22]
	mov	WORD PTR ff$[rsp], ax

; 1268 :     } else {

	jmp	SHORT $LN15@pe_set_val
$LN14@pe_set_val:

; 1269 : #endif
; 1270 :         ph32 = ( struct IMAGE_PE_HEADER32 *)pehdr->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR pehdr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR ph32$[rsp], rax

; 1271 :         ff = ph32->FileHeader.Characteristics;

	mov	rax, QWORD PTR ph32$[rsp]
	movzx	eax, WORD PTR [rax+22]
	mov	WORD PTR ff$[rsp], ax
$LN15@pe_set_val:

; 1272 : #if AMD64_SUPPORT
; 1273 :     }
; 1274 : #endif
; 1275 :     if ( !( ff & IMAGE_FILE_RELOCS_STRIPPED ) ) {

	movzx	eax, WORD PTR ff$[rsp]
	and	eax, 1
	test	eax, eax
	jne	$LN16@pe_set_val

; 1276 :         DebugMsg(("pe_set_values: .reloc section required\n" ));

	lea	rcx, OFFSET FLAT:$SG12331
	call	DoDebugMsg

; 1277 :         reloc = (struct dsym *)CreateIntSegment( ".reloc", "RELOC", 2, ModuleInfo.defOfssize, TRUE );

	mov	BYTE PTR [rsp+32], 1
	movzx	r9d, BYTE PTR ModuleInfo+405
	mov	r8b, 2
	lea	rdx, OFFSET FLAT:$SG12332
	lea	rcx, OFFSET FLAT:$SG12333
	call	CreateIntSegment
	mov	QWORD PTR reloc$[rsp], rax

; 1278 :         if ( reloc ) {

	cmp	QWORD PTR reloc$[rsp], 0
	je	$LN17@pe_set_val

; 1279 :             reloc->e.seginfo->group = &ModuleInfo.flat_grp->sym;

	mov	rax, QWORD PTR ModuleInfo+440
	mov	rcx, QWORD PTR reloc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx], rax

; 1280 :             reloc->e.seginfo->combine = COMB_ADDOFF;  /* PUBLIC */

	mov	rax, QWORD PTR reloc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+108]
	and	al, 248					; 000000f8H
	or	al, 2
	mov	rcx, QWORD PTR reloc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+108], al

; 1281 :             reloc->e.seginfo->segtype = SEGTYPE_RELOC;

	mov	rax, QWORD PTR reloc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+72], 8

; 1282 :             reloc->e.seginfo->characteristics = ((IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ) >> 24 );

	mov	rax, QWORD PTR reloc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rax+105], 66			; 00000042H

; 1283 :             /* make sure the section isn't empty ( true size will be calculated later ) */
; 1284 :             reloc->sym.max_offset = sizeof( struct IMAGE_BASE_RELOCATION );

	mov	rax, QWORD PTR reloc$[rsp]
	mov	DWORD PTR [rax+56], 8

; 1285 :             reloc->e.seginfo->bytes_written = reloc->sym.max_offset;

	mov	rax, QWORD PTR reloc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR reloc$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax+24], ecx

; 1286 :             /* clear the additionally allocated entry in object table */
; 1287 :             memset( objtab->e.seginfo->CodeBuffer + objtab->sym.max_offset, 0, sizeof( struct IMAGE_SECTION_HEADER ) );

	mov	rax, QWORD PTR objtab$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR objtab$[rsp]
	movsxd	rcx, DWORD PTR [rcx+56]
	add	rcx, QWORD PTR [rax+16]
	mov	rax, rcx
	mov	r8d, 40					; 00000028H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 1288 :             objtab->sym.max_offset += sizeof( struct IMAGE_SECTION_HEADER );

	mov	rax, QWORD PTR objtab$[rsp]
	movsxd	rax, DWORD PTR [rax+56]
	add	rax, 40					; 00000028H
	mov	rcx, QWORD PTR objtab$[rsp]
	mov	DWORD PTR [rcx+56], eax
$LN17@pe_set_val:
$LN16@pe_set_val:

; 1289 :         }
; 1290 :     }
; 1291 : 
; 1292 : 
; 1293 :     /* sort: header, executable, readable, read-write segments, resources, relocs */
; 1294 :     for ( i = 0; i < SIZE_PEFLAT; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@pe_set_val
$LN2@pe_set_val:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@pe_set_val:
	movsxd	rax, DWORD PTR i$[rsp]
	cmp	rax, 7
	jae	$LN3@pe_set_val

; 1295 :         DebugMsg(("pe_set_values: searching segment types %Xh\n", flat_order[i] ));

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:flat_order
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12335
	call	DoDebugMsg

; 1296 :         for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN7@pe_set_val
$LN5@pe_set_val:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN7@pe_set_val:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN6@pe_set_val

; 1297 :             if ( curr->e.seginfo->segtype == flat_order[i] ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movsxd	rcx, DWORD PTR i$[rsp]
	lea	rdx, OFFSET FLAT:flat_order
	mov	ecx, DWORD PTR [rdx+rcx*4]
	cmp	DWORD PTR [rax+72], ecx
	jne	SHORT $LN18@pe_set_val

; 1298 :                 curr->e.seginfo->lname_idx = i;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax+76], ecx
$LN18@pe_set_val:

; 1299 :             }
; 1300 :         }

	jmp	SHORT $LN5@pe_set_val
$LN6@pe_set_val:

; 1301 : 
; 1302 :     }

	jmp	$LN2@pe_set_val
$LN3@pe_set_val:

; 1303 :     SortSegments( 2 );

	mov	ecx, 2
	call	SortSegments

; 1304 :     falign = get_bit( GHF( OptionalHeader.FileAlignment ) );

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN52@pe_set_val
	mov	rax, QWORD PTR ph64$[rsp]
	mov	eax, DWORD PTR [rax+60]
	mov	DWORD PTR tv181[rsp], eax
	jmp	SHORT $LN53@pe_set_val
$LN52@pe_set_val:
	mov	rax, QWORD PTR ph32$[rsp]
	mov	eax, DWORD PTR [rax+60]
	mov	DWORD PTR tv181[rsp], eax
$LN53@pe_set_val:
	mov	ecx, DWORD PTR tv181[rsp]
	call	get_bit
	mov	DWORD PTR falign$[rsp], eax

; 1305 :     malign = GHF( OptionalHeader.SectionAlignment );

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN54@pe_set_val
	mov	rax, QWORD PTR ph64$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR tv187[rsp], eax
	jmp	SHORT $LN55@pe_set_val
$LN54@pe_set_val:
	mov	rax, QWORD PTR ph32$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR tv187[rsp], eax
$LN55@pe_set_val:
	mov	eax, DWORD PTR tv187[rsp]
	mov	DWORD PTR malign$[rsp], eax

; 1306 : 
; 1307 :     /* assign RVAs to sections */
; 1308 : 
; 1309 :     for ( curr = SymTables[TAB_SEG].head, i = -1; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	mov	DWORD PTR i$[rsp], -1
	jmp	SHORT $LN10@pe_set_val
$LN8@pe_set_val:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN10@pe_set_val:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN9@pe_set_val

; 1310 :         if ( curr->e.seginfo->lname_idx == SEGTYPE_ERROR || curr->e.seginfo->lname_idx != i ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+76], 10
	je	SHORT $LN21@pe_set_val
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR i$[rsp]
	cmp	DWORD PTR [rax+76], ecx
	je	SHORT $LN19@pe_set_val
$LN21@pe_set_val:

; 1311 :             i = curr->e.seginfo->lname_idx;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+76]
	mov	DWORD PTR i$[rsp], eax

; 1312 :             cp->alignment = falign;

	mov	rax, QWORD PTR cp$[rsp]
	movzx	ecx, BYTE PTR falign$[rsp]
	mov	BYTE PTR [rax+1], cl

; 1313 :             cp->rva = (cp->rva + (malign - 1)) & (~(malign-1));

	mov	rax, QWORD PTR cp$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	ecx, DWORD PTR malign$[rsp]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	ecx, DWORD PTR malign$[rsp]
	dec	ecx
	not	ecx
	and	eax, ecx
	mov	rcx, QWORD PTR cp$[rsp]
	mov	DWORD PTR [rcx+28], eax

; 1314 :         } else {

	jmp	SHORT $LN20@pe_set_val
$LN19@pe_set_val:

; 1315 :             uint_32 align = 1 << curr->e.seginfo->alignment;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+106]
	mov	ecx, 1
	mov	DWORD PTR tv702[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv702[rsp]
	shl	eax, cl
	mov	DWORD PTR align$1[rsp], eax

; 1316 :             cp->alignment = 0;

	mov	rax, QWORD PTR cp$[rsp]
	mov	BYTE PTR [rax+1], 0

; 1317 :             cp->rva = (cp->rva + (align - 1)) & (~(align-1));

	mov	rax, QWORD PTR cp$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	ecx, DWORD PTR align$1[rsp]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	ecx, DWORD PTR align$1[rsp]
	dec	ecx
	not	ecx
	and	eax, ecx
	mov	rcx, QWORD PTR cp$[rsp]
	mov	DWORD PTR [rcx+28], eax
$LN20@pe_set_val:

; 1318 :         }
; 1319 :         CalcOffset( curr, cp );

	mov	rdx, QWORD PTR cp$[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	call	CalcOffset

; 1320 :         DebugMsg(("pe_set_values: section %s, start ofs=%" I32_SPEC "Xh, size=%" I32_SPEC "Xh, file ofs=%" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	edx, DWORD PTR [rdx+56]
	sub	edx, ecx
	mov	ecx, edx
	mov	rdx, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rdx+96]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, DWORD PTR [rdx+12]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12340
	call	DoDebugMsg

; 1321 :                   curr->sym.name, curr->e.seginfo->start_offset, curr->sym.max_offset - curr->e.seginfo->start_loc, curr->e.seginfo->fileoffset ));
; 1322 :     }

	jmp	$LN8@pe_set_val
$LN9@pe_set_val:

; 1323 : 
; 1324 :     if ( reloc ) {

	cmp	QWORD PTR reloc$[rsp], 0
	je	SHORT $LN22@pe_set_val

; 1325 :         pe_set_base_relocs( reloc );

	mov	rcx, QWORD PTR reloc$[rsp]
	call	pe_set_base_relocs

; 1326 :         cp->rva = reloc->e.seginfo->start_offset + reloc->sym.max_offset;

	mov	rax, QWORD PTR reloc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	mov	rcx, QWORD PTR reloc$[rsp]
	add	eax, DWORD PTR [rcx+56]
	mov	rcx, QWORD PTR cp$[rsp]
	mov	DWORD PTR [rcx+28], eax
$LN22@pe_set_val:

; 1327 :     }
; 1328 : 
; 1329 :     sizeimg = cp->rva;

	mov	rax, QWORD PTR cp$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR sizeimg$[rsp], eax

; 1330 : 
; 1331 :     /* set e_lfanew of dosstub to start of PE header */
; 1332 :     if ( mzhdr->sym.max_offset >= 0x40 )

	mov	rax, QWORD PTR mzhdr$[rsp]
	cmp	DWORD PTR [rax+56], 64			; 00000040H
	jl	SHORT $LN23@pe_set_val

; 1333 :         ((struct IMAGE_DOS_HEADER *)mzhdr->e.seginfo->CodeBuffer)->e_lfanew = pehdr->e.seginfo->fileoffset;

	mov	rax, QWORD PTR pehdr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR mzhdr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rcx, QWORD PTR [rcx+16]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rcx+60], eax
$LN23@pe_set_val:

; 1334 : 
; 1335 :     /* set number of sections in PE file header (doesn't matter if it's 32- or 64-bit) */
; 1336 :     fh = &((struct IMAGE_PE_HEADER32 *)pehdr->e.seginfo->CodeBuffer)->FileHeader;

	mov	rax, QWORD PTR pehdr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	add	rax, 4
	mov	QWORD PTR fh$[rsp], rax

; 1337 :     fh->NumberOfSections = objtab->sym.max_offset / sizeof( struct IMAGE_SECTION_HEADER );

	mov	rax, QWORD PTR objtab$[rsp]
	movsxd	rax, DWORD PTR [rax+56]
	xor	edx, edx
	mov	ecx, 40					; 00000028H
	div	rcx
	mov	rcx, QWORD PTR fh$[rsp]
	mov	WORD PTR [rcx+2], ax

; 1338 : 
; 1339 : #if RAWSIZE_ROUND
; 1340 :     cp->rawpagesize = ( ModuleInfo.defOfssize == USE64 ? ph64->OptionalHeader.FileAlignment : ph32->OptionalHeader.FileAlignment );

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN56@pe_set_val
	mov	rax, QWORD PTR ph64$[rsp]
	mov	eax, DWORD PTR [rax+60]
	mov	DWORD PTR tv265[rsp], eax
	jmp	SHORT $LN57@pe_set_val
$LN56@pe_set_val:
	mov	rax, QWORD PTR ph32$[rsp]
	mov	eax, DWORD PTR [rax+60]
	mov	DWORD PTR tv265[rsp], eax
$LN57@pe_set_val:
	mov	rax, QWORD PTR cp$[rsp]
	mov	ecx, DWORD PTR tv265[rsp]
	mov	DWORD PTR [rax+40], ecx

; 1341 : #endif
; 1342 : 
; 1343 :     /* fill object table values */
; 1344 :     section = (struct IMAGE_SECTION_HEADER *)objtab->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR objtab$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR section$[rsp], rax

; 1345 :     for( curr = SymTables[TAB_SEG].head, i = -1; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	mov	DWORD PTR i$[rsp], -1
	jmp	SHORT $LN13@pe_set_val
$LN11@pe_set_val:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN13@pe_set_val:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN12@pe_set_val

; 1346 :         if ( curr->e.seginfo->segtype == SEGTYPE_HDR )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 6
	jne	SHORT $LN24@pe_set_val

; 1347 :             continue;

	jmp	SHORT $LN11@pe_set_val
$LN24@pe_set_val:

; 1348 :         if ( curr->sym.max_offset == 0 ) /* ignore empty sections */

	mov	rax, QWORD PTR curr$[rsp]
	cmp	DWORD PTR [rax+56], 0
	jne	SHORT $LN25@pe_set_val

; 1349 :             continue;

	jmp	SHORT $LN11@pe_set_val
$LN25@pe_set_val:

; 1350 :         if ( curr->e.seginfo->lname_idx != i ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR i$[rsp]
	cmp	DWORD PTR [rax+76], ecx
	je	$LN26@pe_set_val

; 1351 :             i = curr->e.seginfo->lname_idx;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+76]
	mov	DWORD PTR i$[rsp], eax

; 1352 :             secname = ( curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ConvertSectionName( &curr->sym, NULL, buffer ) );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN58@pe_set_val
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR tv293[rsp], rax
	jmp	SHORT $LN59@pe_set_val
$LN58@pe_set_val:
	mov	rax, QWORD PTR curr$[rsp]
	lea	r8, QWORD PTR buffer$[rsp]
	xor	edx, edx
	mov	rcx, rax
	call	ConvertSectionName
	mov	QWORD PTR tv293[rsp], rax
$LN59@pe_set_val:
	mov	rax, QWORD PTR tv293[rsp]
	mov	QWORD PTR secname$[rsp], rax

; 1353 :             strncpy( section->Name, secname, sizeof ( section->Name ) );

	mov	rax, QWORD PTR section$[rsp]
	mov	r8d, 8
	mov	rdx, QWORD PTR secname$[rsp]
	mov	rcx, rax
	call	strncpy

; 1354 :             if ( curr->e.seginfo->segtype != SEGTYPE_BSS )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 3
	je	SHORT $LN27@pe_set_val

; 1355 :                 section->PointerToRawData = curr->e.seginfo->fileoffset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR section$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rcx+20], eax
$LN27@pe_set_val:

; 1356 :             section->VirtualAddress = curr->e.seginfo->start_offset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR section$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+12], eax

; 1357 :             /* file offset of first section in object table defines SizeOfHeader */
; 1358 :             if ( sizehdr == 0 )

	cmp	DWORD PTR sizehdr$[rsp], 0
	jne	SHORT $LN28@pe_set_val

; 1359 :                 sizehdr = curr->e.seginfo->fileoffset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR sizehdr$[rsp], eax
$LN28@pe_set_val:
$LN26@pe_set_val:

; 1360 :         }
; 1361 :         section->Characteristics |= pe_get_characteristics( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	pe_get_characteristics
	mov	rcx, QWORD PTR section$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR section$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 1362 :         if ( curr->e.seginfo->segtype != SEGTYPE_BSS ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 3
	je	SHORT $LN29@pe_set_val

; 1363 :             section->SizeOfRawData += curr->sym.max_offset;

	mov	rax, QWORD PTR section$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR curr$[rsp]
	add	eax, DWORD PTR [rcx+56]
	mov	rcx, QWORD PTR section$[rsp]
	mov	DWORD PTR [rcx+16], eax
$LN29@pe_set_val:

; 1364 :         }
; 1365 : 
; 1366 :         /* v2.10: this calculation is not correct */
; 1367 :         //section->Misc.VirtualSize += curr->sym.max_offset;
; 1368 :         section->Misc.VirtualSize = curr->sym.max_offset + ( curr->e.seginfo->start_offset - section->VirtualAddress );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR section$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	rcx, QWORD PTR curr$[rsp]
	add	eax, DWORD PTR [rcx+56]
	mov	rcx, QWORD PTR section$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 1369 : 
; 1370 :         if ( curr->next == NULL || curr->next->e.seginfo->lname_idx != i ) {

	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+104], 0
	je	SHORT $LN31@pe_set_val
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR i$[rsp]
	cmp	DWORD PTR [rax+76], ecx
	je	$LN30@pe_set_val
$LN31@pe_set_val:

; 1371 : #if RAWSIZE_ROUND /* AntiVir TR/Crypt.XPACK Gen */
; 1372 :             section->SizeOfRawData += cp->rawpagesize - 1;

	mov	rax, QWORD PTR cp$[rsp]
	mov	eax, DWORD PTR [rax+40]
	mov	rcx, QWORD PTR section$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	rcx, QWORD PTR section$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 1373 :             section->SizeOfRawData &= ~(cp->rawpagesize - 1);

	mov	rax, QWORD PTR cp$[rsp]
	mov	eax, DWORD PTR [rax+40]
	dec	eax
	not	eax
	mov	rcx, QWORD PTR section$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	and	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR section$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 1374 : #endif
; 1375 :             if ( section->Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

	mov	rax, QWORD PTR section$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 536870912				; 20000000H
	test	eax, eax
	je	SHORT $LN32@pe_set_val

; 1376 :                 if ( codebase == 0 )

	cmp	DWORD PTR codebase$[rsp], 0
	jne	SHORT $LN33@pe_set_val

; 1377 :                     codebase = section->VirtualAddress;

	mov	rax, QWORD PTR section$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR codebase$[rsp], eax
$LN33@pe_set_val:

; 1378 :                 codesize += section->SizeOfRawData;

	mov	rax, QWORD PTR section$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	ecx, DWORD PTR codesize$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR codesize$[rsp], eax
$LN32@pe_set_val:

; 1379 :             }
; 1380 :             if ( section->Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA ) {

	mov	rax, QWORD PTR section$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN34@pe_set_val

; 1381 :                 if ( database == 0 )

	cmp	DWORD PTR database$[rsp], 0
	jne	SHORT $LN35@pe_set_val

; 1382 :                     database = section->VirtualAddress;

	mov	rax, QWORD PTR section$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR database$[rsp], eax
$LN35@pe_set_val:

; 1383 :                 datasize += section->SizeOfRawData;

	mov	rax, QWORD PTR section$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	ecx, DWORD PTR datasize$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR datasize$[rsp], eax
$LN34@pe_set_val:
$LN30@pe_set_val:

; 1384 :             }
; 1385 :         }
; 1386 :         if ( curr->next && curr->next->e.seginfo->lname_idx != i ) {

	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+104], 0
	je	SHORT $LN36@pe_set_val
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR i$[rsp]
	cmp	DWORD PTR [rax+76], ecx
	je	SHORT $LN36@pe_set_val

; 1387 :             DebugMsg(("pe_set_values: object %.8s, VA=%" I32_SPEC "X size=%" I32_SPEC "X phys ofs/size=%" I32_SPEC "Xh/%" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR section$[rsp]
	mov	rcx, QWORD PTR section$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR section$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	mov	DWORD PTR [rsp+32], ecx
	mov	rcx, QWORD PTR section$[rsp]
	mov	r9d, DWORD PTR [rcx+8]
	mov	rcx, QWORD PTR section$[rsp]
	mov	r8d, DWORD PTR [rcx+12]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12356
	call	DoDebugMsg

; 1388 :                   section->Name, section->VirtualAddress, section->Misc.VirtualSize, section->PointerToRawData, section->SizeOfRawData ));
; 1389 :             section++;

	mov	rax, QWORD PTR section$[rsp]
	add	rax, 40					; 00000028H
	mov	QWORD PTR section$[rsp], rax
$LN36@pe_set_val:

; 1390 :         }
; 1391 :     }

	jmp	$LN11@pe_set_val
$LN12@pe_set_val:

; 1392 : 
; 1393 : 
; 1394 :     if ( ModuleInfo.g.start_label ) {

	cmp	QWORD PTR ModuleInfo+208, 0
	je	SHORT $LN37@pe_set_val

; 1395 : #if AMD64_SUPPORT
; 1396 :         if ( ModuleInfo.defOfssize == USE64 )

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN39@pe_set_val

; 1397 :             ph64->OptionalHeader.AddressOfEntryPoint = ((struct dsym *)ModuleInfo.g.start_label->segment)->e.seginfo->start_offset + ModuleInfo.g.start_label->offset;

	mov	rax, QWORD PTR ModuleInfo+208
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	mov	rcx, QWORD PTR ModuleInfo+208
	add	eax, DWORD PTR [rcx+16]
	mov	rcx, QWORD PTR ph64$[rsp]
	mov	DWORD PTR [rcx+40], eax
	jmp	SHORT $LN40@pe_set_val
$LN39@pe_set_val:

; 1398 :         else
; 1399 : #endif
; 1400 :             ph32->OptionalHeader.AddressOfEntryPoint = ((struct dsym *)ModuleInfo.g.start_label->segment)->e.seginfo->start_offset + ModuleInfo.g.start_label->offset;

	mov	rax, QWORD PTR ModuleInfo+208
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	mov	rcx, QWORD PTR ModuleInfo+208
	add	eax, DWORD PTR [rcx+16]
	mov	rcx, QWORD PTR ph32$[rsp]
	mov	DWORD PTR [rcx+40], eax
$LN40@pe_set_val:

; 1401 :     } else {

	jmp	SHORT $LN38@pe_set_val
$LN37@pe_set_val:

; 1402 :         DebugMsg(("pe_set_values: warning: not start label found\n" ));

	lea	rcx, OFFSET FLAT:$SG12361
	call	DoDebugMsg

; 1403 :         EmitWarn( 2, NO_START_LABEL );

	mov	edx, 203				; 000000cbH
	mov	ecx, 2
	call	EmitWarn
$LN38@pe_set_val:

; 1404 :     }
; 1405 : 
; 1406 : #if AMD64_SUPPORT
; 1407 :     if ( ModuleInfo.defOfssize == USE64 ) {

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN41@pe_set_val

; 1408 : #if IMGSIZE_ROUND
; 1409 :         /* round up the SizeOfImage field to page boundary */
; 1410 :         sizeimg = ( sizeimg + ph64->OptionalHeader.SectionAlignment - 1 ) & ~(ph64->OptionalHeader.SectionAlignment - 1);

	mov	rax, QWORD PTR ph64$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	ecx, DWORD PTR sizeimg$[rsp]
	lea	eax, DWORD PTR [rcx+rax-1]
	mov	rcx, QWORD PTR ph64$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	dec	ecx
	not	ecx
	and	eax, ecx
	mov	DWORD PTR sizeimg$[rsp], eax

; 1411 : #endif
; 1412 :         ph64->OptionalHeader.SizeOfCode = codesize;

	mov	rax, QWORD PTR ph64$[rsp]
	mov	ecx, DWORD PTR codesize$[rsp]
	mov	DWORD PTR [rax+28], ecx

; 1413 :         ph64->OptionalHeader.BaseOfCode = codebase;

	mov	rax, QWORD PTR ph64$[rsp]
	mov	ecx, DWORD PTR codebase$[rsp]
	mov	DWORD PTR [rax+44], ecx

; 1414 :         ph64->OptionalHeader.SizeOfImage = sizeimg;

	mov	rax, QWORD PTR ph64$[rsp]
	mov	ecx, DWORD PTR sizeimg$[rsp]
	mov	DWORD PTR [rax+80], ecx

; 1415 :         ph64->OptionalHeader.SizeOfHeaders = sizehdr;

	mov	rax, QWORD PTR ph64$[rsp]
	mov	ecx, DWORD PTR sizehdr$[rsp]
	mov	DWORD PTR [rax+84], ecx

; 1416 :         datadir = &ph64->OptionalHeader.DataDirectory[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR ph64$[rsp]
	lea	rax, QWORD PTR [rcx+rax+136]
	mov	QWORD PTR datadir$[rsp], rax

; 1417 :     } else {

	jmp	$LN42@pe_set_val
$LN41@pe_set_val:

; 1418 : #endif
; 1419 : #if IMGSIZE_ROUND
; 1420 :         /* round up the SizeOfImage field to page boundary */
; 1421 :         sizeimg = ( sizeimg + ph32->OptionalHeader.SectionAlignment - 1 ) & ~(ph32->OptionalHeader.SectionAlignment - 1);

	mov	rax, QWORD PTR ph32$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	ecx, DWORD PTR sizeimg$[rsp]
	lea	eax, DWORD PTR [rcx+rax-1]
	mov	rcx, QWORD PTR ph32$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	dec	ecx
	not	ecx
	and	eax, ecx
	mov	DWORD PTR sizeimg$[rsp], eax

; 1422 : #endif
; 1423 :         ph32->OptionalHeader.SizeOfCode = codesize;

	mov	rax, QWORD PTR ph32$[rsp]
	mov	ecx, DWORD PTR codesize$[rsp]
	mov	DWORD PTR [rax+28], ecx

; 1424 :         ph32->OptionalHeader.SizeOfInitializedData = datasize;

	mov	rax, QWORD PTR ph32$[rsp]
	mov	ecx, DWORD PTR datasize$[rsp]
	mov	DWORD PTR [rax+32], ecx

; 1425 :         ph32->OptionalHeader.BaseOfCode = codebase;

	mov	rax, QWORD PTR ph32$[rsp]
	mov	ecx, DWORD PTR codebase$[rsp]
	mov	DWORD PTR [rax+44], ecx

; 1426 :         ph32->OptionalHeader.BaseOfData = database;

	mov	rax, QWORD PTR ph32$[rsp]
	mov	ecx, DWORD PTR database$[rsp]
	mov	DWORD PTR [rax+48], ecx

; 1427 :         ph32->OptionalHeader.SizeOfImage = sizeimg;

	mov	rax, QWORD PTR ph32$[rsp]
	mov	ecx, DWORD PTR sizeimg$[rsp]
	mov	DWORD PTR [rax+80], ecx

; 1428 :         ph32->OptionalHeader.SizeOfHeaders = sizehdr;

	mov	rax, QWORD PTR ph32$[rsp]
	mov	ecx, DWORD PTR sizehdr$[rsp]
	mov	DWORD PTR [rax+84], ecx

; 1429 :         datadir = &ph32->OptionalHeader.DataDirectory[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR ph32$[rsp]
	lea	rax, QWORD PTR [rcx+rax+120]
	mov	QWORD PTR datadir$[rsp], rax
$LN42@pe_set_val:

; 1430 : #if AMD64_SUPPORT
; 1431 :     }
; 1432 : #endif
; 1433 : 
; 1434 :     /* set export directory data dir value */
; 1435 :     if ( curr = (struct dsym *)SymSearch( edataname ) ) {

	lea	rcx, OFFSET FLAT:edataname
	call	SymFind
	mov	QWORD PTR curr$[rsp], rax
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN43@pe_set_val

; 1436 :         datadir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = curr->e.seginfo->start_offset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR datadir$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rdx+rcx], eax

; 1437 :         datadir[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = curr->sym.max_offset;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR datadir$[rsp]
	mov	rdx, QWORD PTR curr$[rsp]
	mov	edx, DWORD PTR [rdx+56]
	mov	DWORD PTR [rcx+rax+4], edx
$LN43@pe_set_val:

; 1438 :     }
; 1439 : 
; 1440 :     /* set import directory and IAT data dir value */
; 1441 :     if ( curr = (struct dsym *)SymSearch( ".idata$" IMPDIRSUF ) ) {

	lea	rcx, OFFSET FLAT:$SG12366
	call	SymFind
	mov	QWORD PTR curr$[rsp], rax
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN44@pe_set_val

; 1442 :         struct dsym *idata_null;
; 1443 :         struct dsym *idata_iat;
; 1444 :         uint_32 size;
; 1445 :         idata_null = (struct dsym *)SymSearch( ".idata$" IMPNDIRSUF ); /* final NULL import directory entry */

	lea	rcx, OFFSET FLAT:$SG12367
	call	SymFind
	mov	QWORD PTR idata_null$3[rsp], rax

; 1446 :         idata_iat = (struct dsym *)SymSearch( ".idata$" IMPIATSUF ); /* IAT entries */

	lea	rcx, OFFSET FLAT:$SG12368
	call	SymFind
	mov	QWORD PTR idata_iat$4[rsp], rax

; 1447 :         size = idata_null->e.seginfo->start_offset + idata_null->sym.max_offset - curr->e.seginfo->start_offset;

	mov	rax, QWORD PTR idata_null$3[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	mov	rcx, QWORD PTR idata_null$3[rsp]
	add	eax, DWORD PTR [rcx+56]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	sub	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR size$2[rsp], eax

; 1448 :         datadir[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = curr->e.seginfo->start_offset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR datadir$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rdx+rcx], eax

; 1449 :         datadir[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = size;

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR datadir$[rsp]
	mov	edx, DWORD PTR size$2[rsp]
	mov	DWORD PTR [rcx+rax+4], edx

; 1450 :         datadir[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress = idata_iat->e.seginfo->start_offset;

	mov	rax, QWORD PTR idata_iat$4[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR datadir$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rdx+rcx], eax

; 1451 :         datadir[IMAGE_DIRECTORY_ENTRY_IAT].Size = idata_iat->sym.max_offset;

	mov	eax, 8
	imul	rax, rax, 12
	mov	rcx, QWORD PTR datadir$[rsp]
	mov	rdx, QWORD PTR idata_iat$4[rsp]
	mov	edx, DWORD PTR [rdx+56]
	mov	DWORD PTR [rcx+rax+4], edx
$LN44@pe_set_val:

; 1452 :     }
; 1453 : 
; 1454 :     /* set resource directory data dir value */
; 1455 :     if ( curr = (struct dsym *)SymSearch(".rsrc") ) {

	lea	rcx, OFFSET FLAT:$SG12370
	call	SymFind
	mov	QWORD PTR curr$[rsp], rax
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN45@pe_set_val

; 1456 :         datadir[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = curr->e.seginfo->start_offset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR datadir$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rdx+rcx], eax

; 1457 :         datadir[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = curr->sym.max_offset;

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR datadir$[rsp]
	mov	rdx, QWORD PTR curr$[rsp]
	mov	edx, DWORD PTR [rdx+56]
	mov	DWORD PTR [rcx+rax+4], edx
$LN45@pe_set_val:

; 1458 :     }
; 1459 : 
; 1460 :     /* set relocation data dir value */
; 1461 :     if ( curr = (struct dsym *)SymSearch(".reloc") ) {

	lea	rcx, OFFSET FLAT:$SG12372
	call	SymFind
	mov	QWORD PTR curr$[rsp], rax
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN46@pe_set_val

; 1462 :         datadir[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = curr->e.seginfo->start_offset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR datadir$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rdx+rcx], eax

; 1463 :         datadir[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = curr->sym.max_offset;

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR datadir$[rsp]
	mov	rdx, QWORD PTR curr$[rsp]
	mov	edx, DWORD PTR [rdx+56]
	mov	DWORD PTR [rcx+rax+4], edx
$LN46@pe_set_val:

; 1464 :     }
; 1465 : 
; 1466 :     /* fixme: TLS entry is not written because there exists a segment .tls, but
; 1467 :      * because a _tls_used symbol is found ( type: IMAGE_THREAD_DIRECTORY )
; 1468 :      */
; 1469 :     if ( curr = (struct dsym *)SymSearch(".tls") ) {

	lea	rcx, OFFSET FLAT:$SG12374
	call	SymFind
	mov	QWORD PTR curr$[rsp], rax
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN47@pe_set_val

; 1470 :         datadir[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = curr->e.seginfo->start_offset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR datadir$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rdx+rcx], eax

; 1471 :         datadir[IMAGE_DIRECTORY_ENTRY_TLS].Size = curr->sym.max_offset;

	mov	eax, 8
	imul	rax, rax, 9
	mov	rcx, QWORD PTR datadir$[rsp]
	mov	rdx, QWORD PTR curr$[rsp]
	mov	edx, DWORD PTR [rdx+56]
	mov	DWORD PTR [rcx+rax+4], edx
$LN47@pe_set_val:

; 1472 :     }
; 1473 : 
; 1474 : #if AMD64_SUPPORT
; 1475 :     if ( ModuleInfo.defOfssize == USE64 ) {

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	$LN48@pe_set_val

; 1476 :         if ( curr = (struct dsym *)SymSearch( ".pdata" ) ) {

	lea	rcx, OFFSET FLAT:$SG12378
	call	SymFind
	mov	QWORD PTR curr$[rsp], rax
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN50@pe_set_val

; 1477 :             datadir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress = curr->e.seginfo->start_offset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR datadir$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rdx+rcx], eax

; 1478 :             datadir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size = curr->sym.max_offset;

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR datadir$[rsp]
	mov	rdx, QWORD PTR curr$[rsp]
	mov	edx, DWORD PTR [rdx+56]
	mov	DWORD PTR [rcx+rax+4], edx
$LN50@pe_set_val:

; 1479 :         }
; 1480 :         cp->imagebase64 = GHF( OptionalHeader.ImageBase );

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN60@pe_set_val
	mov	rax, QWORD PTR ph64$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv527[rsp], rax
	jmp	SHORT $LN61@pe_set_val
$LN60@pe_set_val:
	mov	rax, QWORD PTR ph32$[rsp]
	mov	eax, DWORD PTR [rax+52]
	mov	QWORD PTR tv527[rsp], rax
$LN61@pe_set_val:
	mov	rax, QWORD PTR cp$[rsp]
	mov	rcx, QWORD PTR tv527[rsp]
	mov	QWORD PTR [rax+32], rcx

; 1481 :     } else

	jmp	SHORT $LN49@pe_set_val
$LN48@pe_set_val:

; 1482 : #endif
; 1483 :         cp->imagebase = GHF( OptionalHeader.ImageBase );

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN62@pe_set_val
	mov	rax, QWORD PTR ph64$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv534[rsp], rax
	jmp	SHORT $LN63@pe_set_val
$LN62@pe_set_val:
	mov	rax, QWORD PTR ph32$[rsp]
	mov	eax, DWORD PTR [rax+52]
	mov	QWORD PTR tv534[rsp], rax
$LN63@pe_set_val:
	mov	rax, QWORD PTR cp$[rsp]
	mov	ecx, DWORD PTR tv534[rsp]
	mov	DWORD PTR [rax+32], ecx
$LN49@pe_set_val:

; 1484 : 
; 1485 :     /* remove .hdr$1 from FLAT group again */
; 1486 :     //mzhdr->e.seginfo->group = NULL;
; 1487 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 536				; 00000218H
	ret	0
pe_set_values ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
cnt1$ = 32
curr$ = 40
fixup$ = 48
baserel$ = 56
currloc$ = 64
ftype$ = 68
prel$ = 72
cnt2$ = 80
tv153 = 84
tv77 = 88
currpage$ = 92
reloc$ = 112
pe_set_base_relocs PROC

; 1126 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 1127 :     int cnt1 = 0;

	mov	DWORD PTR cnt1$[rsp], 0

; 1128 :     int cnt2 = 0;

	mov	DWORD PTR cnt2$[rsp], 0

; 1129 :     int ftype;
; 1130 :     uint_32 currpage = -1;

	mov	DWORD PTR currpage$[rsp], -1		; ffffffffH

; 1131 :     uint_32 currloc;
; 1132 :     struct dsym *curr;
; 1133 :     struct fixup *fixup;
; 1134 :     struct IMAGE_BASE_RELOCATION *baserel;
; 1135 :     uint_16 *prel;
; 1136 : 
; 1137 :     for ( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@pe_set_bas
$LN2@pe_set_bas:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@pe_set_bas:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN3@pe_set_bas

; 1138 :         if ( curr->e.seginfo->segtype == SEGTYPE_HDR )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 6
	jne	SHORT $LN18@pe_set_bas

; 1139 :             continue;

	jmp	SHORT $LN2@pe_set_bas
$LN18@pe_set_bas:

; 1140 :         for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR fixup$[rsp], rax
	jmp	SHORT $LN7@pe_set_bas
$LN5@pe_set_bas:
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR fixup$[rsp], rax
$LN7@pe_set_bas:
	cmp	QWORD PTR fixup$[rsp], 0
	je	SHORT $LN6@pe_set_bas

; 1141 :             switch ( fixup->type ) {

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv77[rsp], eax
	cmp	DWORD PTR tv77[rsp], 5
	jl	SHORT $LN22@pe_set_bas
	cmp	DWORD PTR tv77[rsp], 7
	jle	SHORT $LN19@pe_set_bas
	jmp	SHORT $LN22@pe_set_bas
$LN19@pe_set_bas:

; 1142 :             case FIX_OFF16:
; 1143 :             case FIX_OFF32:
; 1144 : #if AMD64_SUPPORT
; 1145 :             case FIX_OFF64:
; 1146 : #endif
; 1147 :                 currloc = curr->e.seginfo->start_offset + ( fixup->locofs & 0xFFFFF000 );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	and	ecx, -4096				; fffff000H
	add	ecx, DWORD PTR [rax+12]
	mov	eax, ecx
	mov	DWORD PTR currloc$[rsp], eax

; 1148 :                 if ( currloc != currpage ) {

	mov	eax, DWORD PTR currpage$[rsp]
	cmp	DWORD PTR currloc$[rsp], eax
	je	SHORT $LN20@pe_set_bas

; 1149 :                     currpage = currloc;

	mov	eax, DWORD PTR currloc$[rsp]
	mov	DWORD PTR currpage$[rsp], eax

; 1150 :                     cnt2++;

	mov	eax, DWORD PTR cnt2$[rsp]
	inc	eax
	mov	DWORD PTR cnt2$[rsp], eax

; 1151 :                     if ( cnt1 & 1 )

	mov	eax, DWORD PTR cnt1$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN21@pe_set_bas

; 1152 :                         cnt1++;

	mov	eax, DWORD PTR cnt1$[rsp]
	inc	eax
	mov	DWORD PTR cnt1$[rsp], eax
$LN21@pe_set_bas:
$LN20@pe_set_bas:

; 1153 :                 }
; 1154 :                 cnt1++;

	mov	eax, DWORD PTR cnt1$[rsp]
	inc	eax
	mov	DWORD PTR cnt1$[rsp], eax
$LN22@pe_set_bas:

; 1155 :                 break;
; 1156 :             //case FIX_RELOFF08: /* needs no base reloc */
; 1157 :             //case FIX_RELOFF16: /* needs no base reloc */
; 1158 :             //case FIX_RELOFF32: /* needs no base reloc */
; 1159 :             //case FIX_OFF08:    /* needs no base reloc */
; 1160 :             //case FIX_OFF32_IMGREL: /* needs no base reloc */
; 1161 :             //case FIX_OFF32_SECREL: /* needs no base reloc */
; 1162 :             //case FIX_SEG:   /* segmented fixups have caused an error already */
; 1163 :             //case FIX_PTR16: /* segmented fixups have caused an error already */
; 1164 :             //case FIX_PTR32: /* segmented fixups have caused an error already */
; 1165 :             //case FIX_HIBYTE: /* is an error */
; 1166 :             default:
; 1167 :                 break;
; 1168 :             }
; 1169 :         }

	jmp	$LN5@pe_set_bas
$LN6@pe_set_bas:

; 1170 :     }

	jmp	$LN2@pe_set_bas
$LN3@pe_set_bas:

; 1171 :     reloc->sym.max_offset = cnt2 * sizeof( struct IMAGE_BASE_RELOCATION ) + cnt1 * sizeof( uint_16 );

	movsxd	rax, DWORD PTR cnt2$[rsp]
	movsxd	rcx, DWORD PTR cnt1$[rsp]
	shl	rcx, 1
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	rcx, QWORD PTR reloc$[rsp]
	mov	DWORD PTR [rcx+56], eax

; 1172 :     reloc->e.seginfo->CodeBuffer = LclAlloc( reloc->sym.max_offset );

	mov	rax, QWORD PTR reloc$[rsp]
	movsxd	rax, DWORD PTR [rax+56]
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR reloc$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx+16], rax

; 1173 : 
; 1174 :     baserel = (struct IMAGE_BASE_RELOCATION *)reloc->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR reloc$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR baserel$[rsp], rax

; 1175 :     prel = (uint_16 *)((uint_8 *)baserel + sizeof ( struct IMAGE_BASE_RELOCATION ));

	mov	rax, QWORD PTR baserel$[rsp]
	add	rax, 8
	mov	QWORD PTR prel$[rsp], rax

; 1176 : 
; 1177 :     baserel->VirtualAddress = -1;

	mov	rax, QWORD PTR baserel$[rsp]
	mov	DWORD PTR [rax], -1			; ffffffffH

; 1178 :     for ( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN12@pe_set_bas
$LN10@pe_set_bas:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN12@pe_set_bas:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN11@pe_set_bas

; 1179 :         if ( curr->e.seginfo->segtype == SEGTYPE_HDR )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 6
	jne	SHORT $LN23@pe_set_bas

; 1180 :             continue;

	jmp	SHORT $LN10@pe_set_bas
$LN23@pe_set_bas:

; 1181 :         for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR fixup$[rsp], rax
	jmp	SHORT $LN15@pe_set_bas
$LN13@pe_set_bas:
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR fixup$[rsp], rax
$LN15@pe_set_bas:
	cmp	QWORD PTR fixup$[rsp], 0
	je	$LN14@pe_set_bas

; 1182 :             switch ( fixup->type ) {

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv153[rsp], eax
	cmp	DWORD PTR tv153[rsp], 5
	je	SHORT $LN24@pe_set_bas
	cmp	DWORD PTR tv153[rsp], 6
	je	SHORT $LN25@pe_set_bas
	cmp	DWORD PTR tv153[rsp], 7
	je	SHORT $LN26@pe_set_bas
	jmp	SHORT $LN27@pe_set_bas
$LN24@pe_set_bas:

; 1183 :             case FIX_OFF16: ftype = IMAGE_REL_BASED_LOW; break;

	mov	DWORD PTR ftype$[rsp], 2
	jmp	SHORT $LN16@pe_set_bas
$LN25@pe_set_bas:

; 1184 :             case FIX_OFF32: ftype = IMAGE_REL_BASED_HIGHLOW; break;

	mov	DWORD PTR ftype$[rsp], 3
	jmp	SHORT $LN16@pe_set_bas
$LN26@pe_set_bas:

; 1185 : #if AMD64_SUPPORT
; 1186 :             case FIX_OFF64: ftype = IMAGE_REL_BASED_DIR64; break;

	mov	DWORD PTR ftype$[rsp], 10
	jmp	SHORT $LN16@pe_set_bas
$LN27@pe_set_bas:

; 1187 : #endif
; 1188 :             default: ftype = 0;

	mov	DWORD PTR ftype$[rsp], 0
$LN16@pe_set_bas:

; 1189 :             }
; 1190 :             if ( ftype ) {

	cmp	DWORD PTR ftype$[rsp], 0
	je	$LN28@pe_set_bas

; 1191 :                 currloc = curr->e.seginfo->start_offset + ( fixup->locofs & 0xFFFFF000 );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	and	ecx, -4096				; fffff000H
	add	ecx, DWORD PTR [rax+12]
	mov	eax, ecx
	mov	DWORD PTR currloc$[rsp], eax

; 1192 :                 if ( currloc != baserel->VirtualAddress ) {

	mov	rax, QWORD PTR baserel$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR currloc$[rsp], eax
	je	SHORT $LN29@pe_set_bas

; 1193 :                     if ( baserel->VirtualAddress != -1 ) {

	mov	rax, QWORD PTR baserel$[rsp]
	cmp	DWORD PTR [rax], -1			; ffffffffH
	je	SHORT $LN30@pe_set_bas

; 1194 :                         /* address of relocation header must be DWORD aligned */
; 1195 :                         if ( baserel->SizeOfBlock & 2 ) {

	mov	rax, QWORD PTR baserel$[rsp]
	mov	eax, DWORD PTR [rax+4]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN31@pe_set_bas

; 1196 :                             *prel++ = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR prel$[rsp]
	mov	WORD PTR [rcx], ax
	mov	rax, QWORD PTR prel$[rsp]
	add	rax, 2
	mov	QWORD PTR prel$[rsp], rax

; 1197 :                             baserel->SizeOfBlock += sizeof( uint_16 );

	mov	rax, QWORD PTR baserel$[rsp]
	mov	eax, DWORD PTR [rax+4]
	add	rax, 2
	mov	rcx, QWORD PTR baserel$[rsp]
	mov	DWORD PTR [rcx+4], eax
$LN31@pe_set_bas:

; 1198 :                         }
; 1199 :                         baserel = (struct IMAGE_BASE_RELOCATION *)prel;

	mov	rax, QWORD PTR prel$[rsp]
	mov	QWORD PTR baserel$[rsp], rax

; 1200 :                         prel += 4; /* 4*2 = sizeof( struct IMAGE_BASE_RELOCATION ) */

	mov	rax, QWORD PTR prel$[rsp]
	add	rax, 8
	mov	QWORD PTR prel$[rsp], rax
$LN30@pe_set_bas:

; 1201 :                     }
; 1202 :                     baserel->VirtualAddress = currloc;

	mov	rax, QWORD PTR baserel$[rsp]
	mov	ecx, DWORD PTR currloc$[rsp]
	mov	DWORD PTR [rax], ecx

; 1203 :                     baserel->SizeOfBlock = sizeof( struct IMAGE_BASE_RELOCATION );

	mov	rax, QWORD PTR baserel$[rsp]
	mov	DWORD PTR [rax+4], 8
$LN29@pe_set_bas:

; 1204 :                 }
; 1205 :                 *prel++ = ( fixup->locofs & 0xfff ) | ( ftype << 12 );

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+20]
	and	eax, 4095				; 00000fffH
	mov	ecx, DWORD PTR ftype$[rsp]
	shl	ecx, 12
	or	eax, ecx
	mov	rcx, QWORD PTR prel$[rsp]
	mov	WORD PTR [rcx], ax
	mov	rax, QWORD PTR prel$[rsp]
	add	rax, 2
	mov	QWORD PTR prel$[rsp], rax

; 1206 :                 baserel->SizeOfBlock += sizeof( uint_16 );

	mov	rax, QWORD PTR baserel$[rsp]
	mov	eax, DWORD PTR [rax+4]
	add	rax, 2
	mov	rcx, QWORD PTR baserel$[rsp]
	mov	DWORD PTR [rcx+4], eax
$LN28@pe_set_bas:

; 1207 :             }
; 1208 :         }

	jmp	$LN13@pe_set_bas
$LN14@pe_set_bas:

; 1209 :     }

	jmp	$LN10@pe_set_bas
$LN11@pe_set_bas:

; 1210 : }

	add	rsp, 104				; 00000068H
	ret	0
pe_set_base_relocs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
result$ = 32
seg$ = 64
pe_get_characteristics PROC

; 1092 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1093 :     uint_32 result = 0;

	mov	DWORD PTR result$[rsp], 0

; 1094 :     //if ( seg->e.seginfo->alignment != MAX_SEGALIGNMENT ) /* ABS not possible */
; 1095 :     //    result |= (uint_32)(seg->e.seginfo->alignment + 1) << 20;
; 1096 : 
; 1097 :     if ( seg->e.seginfo->segtype == SEGTYPE_CODE ) {

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 1
	jne	SHORT $LN2@pe_get_cha

; 1098 :         result |= IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ;

	mov	eax, DWORD PTR result$[rsp]
	or	eax, 1610612768				; 60000020H
	mov	DWORD PTR result$[rsp], eax
	jmp	$LN3@pe_get_cha
$LN2@pe_get_cha:

; 1099 :     } else if ( seg->e.seginfo->segtype == SEGTYPE_BSS ) {

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 3
	jne	SHORT $LN4@pe_get_cha

; 1100 :         result |= IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	mov	eax, DWORD PTR result$[rsp]
	or	eax, -1073741696			; c0000080H
	mov	DWORD PTR result$[rsp], eax
	jmp	$LN5@pe_get_cha
$LN4@pe_get_cha:

; 1101 :         /* ish.SizeOfRawData = 0; */
; 1102 :         //ish.PointerToRawData = 0;
; 1103 :     } else if ( seg->e.seginfo->combine == COMB_STACK && seg->e.seginfo->bytes_written == 0 ) {

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+108]
	and	al, 7
	movzx	eax, al
	cmp	eax, 5
	jne	SHORT $LN6@pe_get_cha
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN6@pe_get_cha

; 1104 :         result |= IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	mov	eax, DWORD PTR result$[rsp]
	or	eax, -1073741696			; c0000080H
	mov	DWORD PTR result$[rsp], eax
	jmp	SHORT $LN7@pe_get_cha
$LN6@pe_get_cha:

; 1105 :         //ish.SizeOfRawData = 0;
; 1106 :         //ish.PointerToRawData = 0;
; 1107 :     } else if ( seg->e.seginfo->readonly ) {

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@pe_get_cha

; 1108 :         result |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;

	mov	eax, DWORD PTR result$[rsp]
	or	eax, 1073741888				; 40000040H
	mov	DWORD PTR result$[rsp], eax
	jmp	SHORT $LN9@pe_get_cha
$LN8@pe_get_cha:

; 1109 :     } else if ( seg->e.seginfo->clsym && strcmp( seg->e.seginfo->clsym->name, "CONST" ) == 0 ) {

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN10@pe_get_cha
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+80]
	lea	rdx, OFFSET FLAT:$SG12202
	mov	rcx, QWORD PTR [rax+8]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN10@pe_get_cha

; 1110 :         result |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;

	mov	eax, DWORD PTR result$[rsp]
	or	eax, 1073741888				; 40000040H
	mov	DWORD PTR result$[rsp], eax

; 1111 :     } else

	jmp	SHORT $LN11@pe_get_cha
$LN10@pe_get_cha:

; 1112 :         result |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	mov	eax, DWORD PTR result$[rsp]
	or	eax, -1073741760			; c0000040H
	mov	DWORD PTR result$[rsp], eax
$LN11@pe_get_cha:
$LN9@pe_get_cha:
$LN7@pe_get_cha:
$LN5@pe_get_cha:
$LN3@pe_get_cha:

; 1113 : 
; 1114 :     /* manual characteristics set? */
; 1115 :     if ( seg->e.seginfo->characteristics ) {

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+105]
	test	eax, eax
	je	SHORT $LN12@pe_get_cha

; 1116 :         result &= 0x1FFFFFF; /* clear the IMAGE_SCN_MEM flags */

	mov	eax, DWORD PTR result$[rsp]
	and	eax, 33554431				; 01ffffffH
	mov	DWORD PTR result$[rsp], eax

; 1117 :         result |= (uint_32)(seg->e.seginfo->characteristics & 0xFE) << 24;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+105]
	and	eax, 254				; 000000feH
	shl	eax, 24
	mov	ecx, DWORD PTR result$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR result$[rsp], eax
$LN12@pe_get_cha:

; 1118 :     }
; 1119 :     return( result );

	mov	eax, DWORD PTR result$[rsp]

; 1120 : }

	add	rsp, 56					; 00000038H
	ret	0
pe_get_characteristics ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
rc$ = 0
value$ = 32
get_bit	PROC

; 1081 : {

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 1082 :     int rc = -1;

	mov	DWORD PTR rc$[rsp], -1
$LN2@get_bit:

; 1083 :     while( value ) {

	cmp	DWORD PTR value$[rsp], 0
	je	SHORT $LN3@get_bit

; 1084 :         value = (value >> 1);

	mov	eax, DWORD PTR value$[rsp]
	sar	eax, 1
	mov	DWORD PTR value$[rsp], eax

; 1085 :         rc++;

	mov	eax, DWORD PTR rc$[rsp]
	inc	eax
	mov	DWORD PTR rc$[rsp], eax

; 1086 :     }

	jmp	SHORT $LN2@get_bit
$LN3@get_bit:

; 1087 :     return( rc );

	mov	eax, DWORD PTR rc$[rsp]

; 1088 : }

	add	rsp, 24
	ret	0
get_bit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
curr$1 = 64
p$ = 72
pdot$2 = 80
tv66 = 88
type$ = 92
ptrtype$ = 96
tv69 = 104
align$ = 112
tv263 = 120
pe_emit_import_data PROC

; 991  : {

	sub	rsp, 136				; 00000088H

; 992  :     struct dll_desc *p;
; 993  :     int type = 0;

	mov	DWORD PTR type$[rsp], 0

; 994  : #if AMD64_SUPPORT
; 995  :     int ptrtype = ( ModuleInfo.defOfssize == USE64 ? T_QWORD : T_DWORD );

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN24@pe_emit_im
	mov	DWORD PTR tv66[rsp], 213		; 000000d5H
	jmp	SHORT $LN25@pe_emit_im
$LN24@pe_emit_im:
	mov	DWORD PTR tv66[rsp], 209		; 000000d1H
$LN25@pe_emit_im:
	mov	eax, DWORD PTR tv66[rsp]
	mov	DWORD PTR ptrtype$[rsp], eax

; 996  :     char *align = ( ModuleInfo.defOfssize == USE64 ? "ALIGN(8)" : "ALIGN(4)" );

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN26@pe_emit_im
	lea	rax, OFFSET FLAT:$SG12141
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN27@pe_emit_im
$LN26@pe_emit_im:
	lea	rax, OFFSET FLAT:$SG12142
	mov	QWORD PTR tv69[rsp], rax
$LN27@pe_emit_im:
	mov	rax, QWORD PTR tv69[rsp]
	mov	QWORD PTR align$[rsp], rax

; 997  : #else
; 998  :     int ptrtype = T_DWORD;
; 999  :     char *align = "DWORD";
; 1000 : #endif
; 1001 : 
; 1002 :     DebugMsg(("pe_emit_import_data enter\n" ));

	lea	rcx, OFFSET FLAT:$SG12143
	call	DoDebugMsg

; 1003 :     for ( p = ModuleInfo.g.DllQueue; p; p = p->next ) {

	mov	rax, QWORD PTR ModuleInfo+80
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN4@pe_emit_im
$LN2@pe_emit_im:
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$[rsp], rax
$LN4@pe_emit_im:
	cmp	QWORD PTR p$[rsp], 0
	je	$LN3@pe_emit_im

; 1004 :         if ( p->cnt ) {

	mov	rax, QWORD PTR p$[rsp]
	cmp	DWORD PTR [rax+8], 0
	je	$LN14@pe_emit_im

; 1005 :             struct dsym *curr;
; 1006 :             char *pdot;
; 1007 :             if ( !type ) {

	cmp	DWORD PTR type$[rsp], 0
	jne	SHORT $LN15@pe_emit_im

; 1008 :                 type = 1;

	mov	DWORD PTR type$[rsp], 1

; 1009 :                 AddLineQueueX( "@LPPROC %r %r %r", T_TYPEDEF, T_PTR, T_PROC );

	mov	r9d, 433				; 000001b1H
	mov	r8d, 258				; 00000102H
	mov	edx, 425				; 000001a9H
	lea	rcx, OFFSET FLAT:$SG12146
	call	AddLineQueueX

; 1010 :                 AddLineQueueX( "%r DOTNAME", T_OPTION );

	mov	edx, 452				; 000001c4H
	lea	rcx, OFFSET FLAT:$SG12147
	call	AddLineQueueX
$LN15@pe_emit_im:

; 1011 :             }
; 1012 : 
; 1013 :             /* avoid . in IDs */
; 1014 :             if ( pdot = strchr( p->name, '.') )

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 12
	mov	edx, 46					; 0000002eH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR pdot$2[rsp], rax
	cmp	QWORD PTR pdot$2[rsp], 0
	je	SHORT $LN16@pe_emit_im

; 1015 :                 *pdot = '_';

	mov	rax, QWORD PTR pdot$2[rsp]
	mov	BYTE PTR [rax], 95			; 0000005fH
$LN16@pe_emit_im:

; 1016 : 
; 1017 :             /* import directory entry */
; 1018 :             AddLineQueueX( "%s" IMPDIRSUF " %r %r %s", idataname, T_SEGMENT, T_DWORD, idataattr );

	lea	rax, OFFSET FLAT:idataattr
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 209				; 000000d1H
	mov	r8d, 441				; 000001b9H
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12149
	call	AddLineQueueX

; 1019 :             AddLineQueueX( "DD %r @%s_ilt, 0, 0, %r @%s_name, %r @%s_iat", T_IMAGEREL, p->name, T_IMAGEREL, p->name, T_IMAGEREL, p->name );

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 12
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, 12
	mov	rdx, QWORD PTR p$[rsp]
	add	rdx, 12
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR [rsp+40], 233			; 000000e9H
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, 233				; 000000e9H
	mov	r8, rdx
	mov	edx, 233				; 000000e9H
	lea	rcx, OFFSET FLAT:$SG12150
	call	AddLineQueueX

; 1020 :             AddLineQueueX( "%s" IMPDIRSUF " %r", idataname, T_ENDS );

	mov	r8d, 442				; 000001baH
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12151
	call	AddLineQueueX

; 1021 : 
; 1022 :             /* emit ILT */
; 1023 :             AddLineQueueX( "%s" IMPILTSUF " %r %s %s", idataname, T_SEGMENT, align, idataattr );

	lea	rax, OFFSET FLAT:idataattr
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR align$[rsp]
	mov	r8d, 441				; 000001b9H
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12152
	call	AddLineQueueX

; 1024 :             AddLineQueueX( "@%s_ilt label %r", p->name, ptrtype );

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 12
	mov	r8d, DWORD PTR ptrtype$[rsp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12153
	call	AddLineQueueX

; 1025 :             for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$1[rsp], rax
	jmp	SHORT $LN7@pe_emit_im
$LN5@pe_emit_im:
	mov	rax, QWORD PTR curr$1[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$1[rsp], rax
$LN7@pe_emit_im:
	cmp	QWORD PTR curr$1[rsp], 0
	je	SHORT $LN6@pe_emit_im

; 1026 :                 if ( curr->sym.iat_used && curr->sym.dll == p ) {

	mov	rax, QWORD PTR curr$1[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@pe_emit_im
	mov	rax, QWORD PTR curr$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	cmp	QWORD PTR [rax+56], rcx
	jne	SHORT $LN17@pe_emit_im

; 1027 :                     AddLineQueueX( "@LPPROC %r @%s_name", T_IMAGEREL, curr->sym.name );

	mov	rax, QWORD PTR curr$1[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 233				; 000000e9H
	lea	rcx, OFFSET FLAT:$SG12155
	call	AddLineQueueX
$LN17@pe_emit_im:

; 1028 :                 }
; 1029 :             }

	jmp	SHORT $LN5@pe_emit_im
$LN6@pe_emit_im:

; 1030 :             /* ILT termination entry */
; 1031 :             AddLineQueueX( "@LPPROC 0" );

	lea	rcx, OFFSET FLAT:$SG12156
	call	AddLineQueueX

; 1032 :             AddLineQueueX( "%s" IMPILTSUF " %r", idataname, T_ENDS );

	mov	r8d, 442				; 000001baH
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12157
	call	AddLineQueueX

; 1033 : 
; 1034 :             /* emit IAT */
; 1035 :             AddLineQueueX( "%s" IMPIATSUF " %r %s %s", idataname, T_SEGMENT, align, idataattr );

	lea	rax, OFFSET FLAT:idataattr
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR align$[rsp]
	mov	r8d, 441				; 000001b9H
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12158
	call	AddLineQueueX

; 1036 :             AddLineQueueX( "@%s_iat label %r", p->name, ptrtype );

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 12
	mov	r8d, DWORD PTR ptrtype$[rsp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12159
	call	AddLineQueueX

; 1037 : 
; 1038 :             for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$1[rsp], rax
	jmp	SHORT $LN10@pe_emit_im
$LN8@pe_emit_im:
	mov	rax, QWORD PTR curr$1[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$1[rsp], rax
$LN10@pe_emit_im:
	cmp	QWORD PTR curr$1[rsp], 0
	je	SHORT $LN9@pe_emit_im

; 1039 :                 if ( curr->sym.iat_used && curr->sym.dll == p ) {

	mov	rax, QWORD PTR curr$1[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@pe_emit_im
	mov	rax, QWORD PTR curr$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	cmp	QWORD PTR [rax+56], rcx
	jne	SHORT $LN18@pe_emit_im

; 1040 :                     Mangle( &curr->sym, StringBufferEnd );

	mov	rax, QWORD PTR curr$1[rsp]
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, rax
	call	Mangle

; 1041 :                     AddLineQueueX( "%s%s @LPPROC %r @%s_name", ModuleInfo.g.imp_prefix, StringBufferEnd, T_IMAGEREL, curr->sym.name );

	mov	rax, QWORD PTR curr$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 233				; 000000e9H
	mov	r8, QWORD PTR ModuleInfo+488
	mov	rdx, QWORD PTR ModuleInfo+88
	lea	rcx, OFFSET FLAT:$SG12161
	call	AddLineQueueX
$LN18@pe_emit_im:

; 1042 :                 }
; 1043 :             }

	jmp	SHORT $LN8@pe_emit_im
$LN9@pe_emit_im:

; 1044 :             /* IAT termination entry */
; 1045 :             AddLineQueueX( "@LPPROC 0" );

	lea	rcx, OFFSET FLAT:$SG12162
	call	AddLineQueueX

; 1046 :             AddLineQueueX( "%s" IMPIATSUF " %r", idataname, T_ENDS );

	mov	r8d, 442				; 000001baH
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12163
	call	AddLineQueueX

; 1047 : 
; 1048 :             /* emit name table */
; 1049 :             AddLineQueueX( "%s" IMPSTRSUF " %r %r %s", idataname, T_SEGMENT, T_WORD, idataattr );

	lea	rax, OFFSET FLAT:idataattr
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 207				; 000000cfH
	mov	r8d, 441				; 000001b9H
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12164
	call	AddLineQueueX

; 1050 :             for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$1[rsp], rax
	jmp	SHORT $LN13@pe_emit_im
$LN11@pe_emit_im:
	mov	rax, QWORD PTR curr$1[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$1[rsp], rax
$LN13@pe_emit_im:
	cmp	QWORD PTR curr$1[rsp], 0
	je	SHORT $LN12@pe_emit_im

; 1051 :                 if ( curr->sym.iat_used && curr->sym.dll == p ) {

	mov	rax, QWORD PTR curr$1[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@pe_emit_im
	mov	rax, QWORD PTR curr$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	cmp	QWORD PTR [rax+56], rcx
	jne	SHORT $LN19@pe_emit_im

; 1052 :                     AddLineQueueX( "@%s_name dw 0", curr->sym.name );

	mov	rax, QWORD PTR curr$1[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12166
	call	AddLineQueueX

; 1053 :                     AddLineQueueX( "db '%s',0", curr->sym.name );

	mov	rax, QWORD PTR curr$1[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12167
	call	AddLineQueueX

; 1054 :                     AddLineQueue( "even" );

	lea	rcx, OFFSET FLAT:$SG12168
	call	AddLineQueue
$LN19@pe_emit_im:

; 1055 :                 }
; 1056 :             }

	jmp	SHORT $LN11@pe_emit_im
$LN12@pe_emit_im:

; 1057 :             /* dll name table entry */
; 1058 :             if ( pdot ) {

	cmp	QWORD PTR pdot$2[rsp], 0
	je	SHORT $LN20@pe_emit_im

; 1059 :                 *pdot = NULLC;

	mov	rax, QWORD PTR pdot$2[rsp]
	mov	BYTE PTR [rax], 0

; 1060 :                 AddLineQueueX( "@%s_%s_name db '%s.%s',0", p->name, pdot+1, p->name, pdot+1 );

	mov	rax, QWORD PTR pdot$2[rsp]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, 12
	mov	rdx, QWORD PTR pdot$2[rsp]
	inc	rdx
	mov	r8, QWORD PTR p$[rsp]
	add	r8, 12
	mov	QWORD PTR tv263[rsp], r8
	mov	QWORD PTR [rsp+32], rax
	mov	r9, rcx
	mov	r8, rdx
	mov	rax, QWORD PTR tv263[rsp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12171
	call	AddLineQueueX

; 1061 :                 *pdot = '.';  /* restore '.' in dll name */

	mov	rax, QWORD PTR pdot$2[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH

; 1062 :             } else

	jmp	SHORT $LN21@pe_emit_im
$LN20@pe_emit_im:

; 1063 :                 AddLineQueueX( "@%s_name db '%s',0", p->name, p->name );

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 12
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, 12
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:$SG12172
	call	AddLineQueueX
$LN21@pe_emit_im:

; 1064 : 
; 1065 :             AddLineQueue( "even" );

	lea	rcx, OFFSET FLAT:$SG12173
	call	AddLineQueue

; 1066 :             AddLineQueueX( "%s" IMPSTRSUF " %r", idataname, T_ENDS );

	mov	r8d, 442				; 000001baH
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12174
	call	AddLineQueueX
$LN14@pe_emit_im:

; 1067 : 
; 1068 :         }
; 1069 :     }

	jmp	$LN2@pe_emit_im
$LN3@pe_emit_im:

; 1070 :     if ( is_linequeue_populated() ) {

	cmp	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN22@pe_emit_im

; 1071 :         /* import directory NULL entry */
; 1072 :         AddLineQueueX( "%s" IMPNDIRSUF " %r %r %s", idataname, T_SEGMENT, T_DWORD, idataattr );

	lea	rax, OFFSET FLAT:idataattr
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 209				; 000000d1H
	mov	r8d, 441				; 000001b9H
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12176
	call	AddLineQueueX

; 1073 :         AddLineQueueX( "DD 0, 0, 0, 0, 0" );

	lea	rcx, OFFSET FLAT:$SG12177
	call	AddLineQueueX

; 1074 :         AddLineQueueX( "%s" IMPNDIRSUF " %r", idataname, T_ENDS );

	mov	r8d, 442				; 000001baH
	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG12178
	call	AddLineQueueX

; 1075 :         RunLineQueue();

	call	RunLineQueue
$LN22@pe_emit_im:

; 1076 :     }
; 1077 : }

	add	rsp, 136				; 00000088H
	ret	0
pe_emit_import_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
i$ = 0
curr$ = 8
cnt$ = 16
name$ = 24
fname$ = 32
pexp$ = 40
pitems$ = 48
timedate$ = 56
tv234 = 64
tv245 = 72
tv197 = 80
__$ArrayPad$ = 88
pe_emit_export_data PROC

; 899  : {

	push	rbp
	sub	rsp, 208				; 000000d0H
	lea	rbp, QWORD PTR [rsp+112]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax

; 900  :     struct dsym *curr;
; 901  :     int_32 timedate;
; 902  :     int cnt;
; 903  :     int i;
; 904  :     char *name;
; 905  :     char *fname;
; 906  :     struct expitem *pitems;
; 907  :     struct expitem *pexp;
; 908  : 
; 909  :     DebugMsg(("pe_emit_export_data enter\n" ));

	lea	rcx, OFFSET FLAT:$SG12097
	call	DoDebugMsg

; 910  :     for( curr = SymTables[TAB_PROC].head, cnt = 0; curr; curr = curr->nextproc ) {

	mov	eax, 16
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rbp], rax
	mov	DWORD PTR cnt$[rbp], 0
	jmp	SHORT $LN4@pe_emit_ex
$LN2@pe_emit_ex:
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rbp], rax
$LN4@pe_emit_ex:
	cmp	QWORD PTR curr$[rbp], 0
	je	SHORT $LN3@pe_emit_ex

; 911  :         if( curr->e.procinfo->isexport )

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@pe_emit_ex

; 912  :             cnt++;

	mov	eax, DWORD PTR cnt$[rbp]
	inc	eax
	mov	DWORD PTR cnt$[rbp], eax
$LN23@pe_emit_ex:

; 913  :     }

	jmp	SHORT $LN2@pe_emit_ex
$LN3@pe_emit_ex:

; 914  :     if ( cnt ) {

	cmp	DWORD PTR cnt$[rbp], 0
	je	$LN24@pe_emit_ex

; 915  :         name = ModuleInfo.name;

	lea	rax, OFFSET FLAT:ModuleInfo+512
	mov	QWORD PTR name$[rbp], rax

; 916  :         AddLineQueueX( "%r DOTNAME", T_OPTION );

	mov	edx, 452				; 000001c4H
	lea	rcx, OFFSET FLAT:$SG12100
	call	AddLineQueueX

; 917  :         /* create .edata segment */
; 918  :         AddLineQueueX( "%s %r %r %s", edataname, T_SEGMENT, T_DWORD, edataattr );

	lea	rax, OFFSET FLAT:edataattr
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 209				; 000000d1H
	mov	r8d, 441				; 000001b9H
	lea	rdx, OFFSET FLAT:edataname
	lea	rcx, OFFSET FLAT:$SG12101
	call	AddLineQueueX

; 919  : #if 0 //def __UNIX__
; 920  :         time( &timedate );
; 921  : #else
; 922  :         time( (time_t *)&timedate );

	lea	rcx, QWORD PTR timedate$[rbp]
	call	time

; 923  : #endif
; 924  :         /* create export directory: Characteristics, Timedate, MajMin, Name, Base, ... */
; 925  :         AddLineQueueX( "DD 0, 0%xh, 0, %r @%s_name, %u, %u, %u, %r @%s_func, %r @%s_names, %r @%s_nameord",

	mov	rax, QWORD PTR name$[rbp]
	mov	QWORD PTR [rsp+96], rax
	mov	DWORD PTR [rsp+88], 233			; 000000e9H
	mov	rax, QWORD PTR name$[rbp]
	mov	QWORD PTR [rsp+80], rax
	mov	DWORD PTR [rsp+72], 233			; 000000e9H
	mov	rax, QWORD PTR name$[rbp]
	mov	QWORD PTR [rsp+64], rax
	mov	DWORD PTR [rsp+56], 233			; 000000e9H
	mov	eax, DWORD PTR cnt$[rbp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR cnt$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], 1
	mov	r9, QWORD PTR name$[rbp]
	mov	r8d, 233				; 000000e9H
	mov	edx, DWORD PTR timedate$[rbp]
	lea	rcx, OFFSET FLAT:$SG12102
	call	AddLineQueueX

; 926  :                       timedate, T_IMAGEREL, name, 1, cnt, cnt, T_IMAGEREL, name, T_IMAGEREL, name, T_IMAGEREL, name );
; 927  : 
; 928  :         /* the name pointer table must be in ascending order!
; 929  :          * so we have to fill an array of exports and sort it.
; 930  :          */
; 931  :         pitems = (struct expitem *)myalloca( cnt * sizeof( struct expitem ) );

	movsxd	rax, DWORD PTR cnt$[rbp]
	imul	rax, rax, 16
	mov	rcx, rax
	add	rcx, 15
	cmp	rcx, rax
	ja	SHORT $LN33@pe_emit_ex
	mov	rcx, 1152921504606846960		; 0ffffffffffffff0H
$LN33@pe_emit_ex:
	and	rcx, -16
	mov	rax, rcx
	call	__chkstk
	sub	rsp, rax
	lea	rax, QWORD PTR [rsp+112]
	mov	QWORD PTR pitems$[rbp], rax

; 932  :         for( curr = SymTables[TAB_PROC].head, pexp = pitems, i = 0; curr; curr = curr->nextproc ) {

	mov	eax, 16
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rbp], rax
	mov	rax, QWORD PTR pitems$[rbp]
	mov	QWORD PTR pexp$[rbp], rax
	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN7@pe_emit_ex
$LN5@pe_emit_ex:
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rbp], rax
$LN7@pe_emit_ex:
	cmp	QWORD PTR curr$[rbp], 0
	je	SHORT $LN6@pe_emit_ex

; 933  :             if( curr->e.procinfo->isexport ) {

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN25@pe_emit_ex

; 934  :                 pexp->name = curr->sym.name;

	mov	rax, QWORD PTR pexp$[rbp]
	mov	rcx, QWORD PTR curr$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 935  :                 pexp->idx  = i++;

	mov	rax, QWORD PTR pexp$[rbp]
	mov	ecx, DWORD PTR i$[rbp]
	mov	DWORD PTR [rax+8], ecx
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax

; 936  :                 pexp++;

	mov	rax, QWORD PTR pexp$[rbp]
	add	rax, 16
	mov	QWORD PTR pexp$[rbp], rax
$LN25@pe_emit_ex:

; 937  :             }
; 938  :         }

	jmp	SHORT $LN5@pe_emit_ex
$LN6@pe_emit_ex:

; 939  :         qsort( pitems, cnt, sizeof( struct expitem ), compare_exp );

	movsxd	rax, DWORD PTR cnt$[rbp]
	lea	r9, OFFSET FLAT:compare_exp
	mov	r8d, 16
	mov	rdx, rax
	mov	rcx, QWORD PTR pitems$[rbp]
	call	qsort

; 940  : 
; 941  :         /* emit export address table.
; 942  :          * would be possible to just use the array of sorted names,
; 943  :          * but we want to emit the EAT being sorted by address.
; 944  :          */
; 945  :         AddLineQueueX( "@%s_func %r DWORD", name, T_LABEL );

	mov	r8d, 436				; 000001b4H
	mov	rdx, QWORD PTR name$[rbp]
	lea	rcx, OFFSET FLAT:$SG12104
	call	AddLineQueueX

; 946  :         for( curr = SymTables[TAB_PROC].head; curr; curr = curr->nextproc ) {

	mov	eax, 16
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rbp], rax
	jmp	SHORT $LN10@pe_emit_ex
$LN8@pe_emit_ex:
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rbp], rax
$LN10@pe_emit_ex:
	cmp	QWORD PTR curr$[rbp], 0
	je	SHORT $LN9@pe_emit_ex

; 947  :             if( curr->e.procinfo->isexport )

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN26@pe_emit_ex

; 948  :                 AddLineQueueX( "DD %r %s", T_IMAGEREL, curr->sym.name );

	mov	rax, QWORD PTR curr$[rbp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 233				; 000000e9H
	lea	rcx, OFFSET FLAT:$SG12106
	call	AddLineQueueX
$LN26@pe_emit_ex:

; 949  :         }

	jmp	SHORT $LN8@pe_emit_ex
$LN9@pe_emit_ex:

; 950  : 
; 951  :         /* emit the name pointer table */
; 952  :         AddLineQueueX( "@%s_names %r DWORD", name, T_LABEL );

	mov	r8d, 436				; 000001b4H
	mov	rdx, QWORD PTR name$[rbp]
	lea	rcx, OFFSET FLAT:$SG12107
	call	AddLineQueueX

; 953  :         for ( i = 0; i < cnt; i++ )

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN13@pe_emit_ex
$LN11@pe_emit_ex:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN13@pe_emit_ex:
	mov	eax, DWORD PTR cnt$[rbp]
	cmp	DWORD PTR i$[rbp], eax
	jge	SHORT $LN12@pe_emit_ex

; 954  :             AddLineQueueX( "DD %r @%s", T_IMAGEREL, (pitems+i)->name );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR pitems$[rbp]
	mov	r8, QWORD PTR [rcx+rax]
	mov	edx, 233				; 000000e9H
	lea	rcx, OFFSET FLAT:$SG12108
	call	AddLineQueueX
	jmp	SHORT $LN11@pe_emit_ex
$LN12@pe_emit_ex:

; 955  : 
; 956  :         /* ordinal table. each ordinal is an index into the export address table */
; 957  :         AddLineQueueX( "@%s_nameord %r WORD", name, T_LABEL );

	mov	r8d, 436				; 000001b4H
	mov	rdx, QWORD PTR name$[rbp]
	lea	rcx, OFFSET FLAT:$SG12109
	call	AddLineQueueX

; 958  :         for( i = 0; i < cnt; i++ ) {

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN16@pe_emit_ex
$LN14@pe_emit_ex:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN16@pe_emit_ex:
	mov	eax, DWORD PTR cnt$[rbp]
	cmp	DWORD PTR i$[rbp], eax
	jge	SHORT $LN15@pe_emit_ex

; 959  :             AddLineQueueX( "DW %u", (pitems+i)->idx );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR pitems$[rbp]
	mov	edx, DWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG12110
	call	AddLineQueueX

; 960  :         }

	jmp	SHORT $LN14@pe_emit_ex
$LN15@pe_emit_ex:

; 961  :         /* v2.10: name+ext of dll */
; 962  :         //AddLineQueueX( "@%s_name DB '%s',0", name, name );
; 963  :         for ( fname = CurrFName[OBJ] + strlen( CurrFName[OBJ] ); fname > CurrFName[OBJ]; fname-- )

	mov	eax, 8
	imul	rax, rax, 1
	mov	QWORD PTR tv197[rbp], rax
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	QWORD PTR tv245[rbp], rcx
	mov	edx, 8
	imul	rdx, rdx, 1
	lea	r8, OFFSET FLAT:ModuleInfo+128
	mov	rcx, QWORD PTR [r8+rdx]
	call	strlen
	mov	rdx, QWORD PTR tv245[rbp]
	mov	rcx, QWORD PTR tv197[rbp]
	add	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR fname$[rbp], rax
	jmp	SHORT $LN19@pe_emit_ex
$LN17@pe_emit_ex:
	mov	rax, QWORD PTR fname$[rbp]
	dec	rax
	mov	QWORD PTR fname$[rbp], rax
$LN19@pe_emit_ex:
	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rax, QWORD PTR [rcx+rax]
	cmp	QWORD PTR fname$[rbp], rax
	jbe	SHORT $LN18@pe_emit_ex

; 964  :             if ( *fname == '/' || *fname == '\\' || *fname == ':' )

	mov	rax, QWORD PTR fname$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN28@pe_emit_ex
	mov	rax, QWORD PTR fname$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN28@pe_emit_ex
	mov	rax, QWORD PTR fname$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN27@pe_emit_ex
$LN28@pe_emit_ex:

; 965  :                 break;

	jmp	SHORT $LN18@pe_emit_ex
$LN27@pe_emit_ex:
	jmp	SHORT $LN17@pe_emit_ex
$LN18@pe_emit_ex:

; 966  :         AddLineQueueX( "@%s_name DB '%s',0", name, fname );

	mov	r8, QWORD PTR fname$[rbp]
	mov	rdx, QWORD PTR name$[rbp]
	lea	rcx, OFFSET FLAT:$SG12113
	call	AddLineQueueX

; 967  : 
; 968  :         for( curr = SymTables[TAB_PROC].head; curr; curr = curr->nextproc ) {

	mov	eax, 16
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rbp], rax
	jmp	SHORT $LN22@pe_emit_ex
$LN20@pe_emit_ex:
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rbp], rax
$LN22@pe_emit_ex:
	cmp	QWORD PTR curr$[rbp], 0
	je	SHORT $LN21@pe_emit_ex

; 969  :             if( curr->e.procinfo->isexport ) {

	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN29@pe_emit_ex

; 970  :                 Mangle( &curr->sym, StringBufferEnd );

	mov	rax, QWORD PTR curr$[rbp]
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, rax
	call	Mangle

; 971  :                 AddLineQueueX( "@%s DB '%s',0", curr->sym.name, Options.no_export_decoration ? curr->sym.name : StringBufferEnd );

	movzx	eax, BYTE PTR Options+135
	test	eax, eax
	je	SHORT $LN31@pe_emit_ex
	mov	rax, QWORD PTR curr$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv234[rbp], rax
	jmp	SHORT $LN32@pe_emit_ex
$LN31@pe_emit_ex:
	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR tv234[rbp], rax
$LN32@pe_emit_ex:
	mov	r8, QWORD PTR tv234[rbp]
	mov	rax, QWORD PTR curr$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12115
	call	AddLineQueueX
$LN29@pe_emit_ex:

; 972  :             }
; 973  :         }

	jmp	SHORT $LN20@pe_emit_ex
$LN21@pe_emit_ex:

; 974  :         /* exit .edata segment */
; 975  :         AddLineQueueX( "%s %r", edataname, T_ENDS );

	mov	r8d, 442				; 000001baH
	lea	rdx, OFFSET FLAT:edataname
	lea	rcx, OFFSET FLAT:$SG12116
	call	AddLineQueueX

; 976  :         RunLineQueue();

	call	RunLineQueue
$LN24@pe_emit_ex:

; 977  :     }
; 978  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
pe_emit_export_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
p1$ = 48
p2$ = 56
compare_exp PROC

; 893  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 894  :     return( strcmp( ((struct expitem *)p1)->name, ((struct expitem *)p2)->name ) );

	mov	rax, QWORD PTR p2$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR p1$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	strcmp

; 895  : }

	add	rsp, 40					; 00000028H
	ret	0
compare_exp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
objs$ = 48
i$ = 52
bCreated$ = 56
curr$ = 64
objtab$ = 72
pe_create_section_table PROC

; 804  : {

	sub	rsp, 88					; 00000058H

; 805  :     int i;
; 806  :     struct dsym *objtab;
; 807  :     struct dsym *curr;
; 808  :     int bCreated = FALSE;

	mov	DWORD PTR bCreated$[rsp], 0

; 809  :     int objs;
; 810  : 
; 811  :     DebugMsg(("pe_create_section table enter\n" ));

	lea	rcx, OFFSET FLAT:$SG12022
	call	DoDebugMsg

; 812  :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN11@pe_create_

; 813  :         objtab = ( struct dsym *)SymSearch( hdrname "3" );

	lea	rcx, OFFSET FLAT:$SG12024
	call	SymFind
	mov	QWORD PTR objtab$[rsp], rax

; 814  :         if ( !objtab ) {

	cmp	QWORD PTR objtab$[rsp], 0
	jne	SHORT $LN12@pe_create_

; 815  :             bCreated = TRUE;

	mov	DWORD PTR bCreated$[rsp], 1

; 816  :             objtab = (struct dsym *)CreateIntSegment( hdrname "3", "HDR", 2, ModuleInfo.defOfssize, TRUE );

	mov	BYTE PTR [rsp+32], 1
	movzx	r9d, BYTE PTR ModuleInfo+405
	mov	r8b, 2
	lea	rdx, OFFSET FLAT:$SG12026
	lea	rcx, OFFSET FLAT:$SG12027
	call	CreateIntSegment
	mov	QWORD PTR objtab$[rsp], rax

; 817  :             objtab->e.seginfo->group = &ModuleInfo.flat_grp->sym;

	mov	rax, QWORD PTR ModuleInfo+440
	mov	rcx, QWORD PTR objtab$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx], rax

; 818  :             objtab->e.seginfo->combine = COMB_ADDOFF;  /* PUBLIC */

	mov	rax, QWORD PTR objtab$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+108]
	and	al, 248					; 000000f8H
	or	al, 2
	mov	rcx, QWORD PTR objtab$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+108], al
$LN12@pe_create_:

; 819  :         }
; 820  :         objtab->e.seginfo->segtype = SEGTYPE_HDR;

	mov	rax, QWORD PTR objtab$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+72], 6

; 821  : 
; 822  :         if ( !bCreated )

	cmp	DWORD PTR bCreated$[rsp], 0
	jne	SHORT $LN13@pe_create_

; 823  :             return;

	jmp	$LN1@pe_create_
$LN13@pe_create_:

; 824  : 
; 825  :         /* before objects can be counted, the segment types
; 826  :          * SEGTYPE_CDATA ( for readonly segments ) &
; 827  :          * SEGTYPE_RSRC ( for resource segments )
; 828  :          * SEGTYPE_RELOC ( for relocations )
; 829  :          * must be set  - also, init lname_idx field
; 830  :          */
; 831  :         for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@pe_create_
$LN2@pe_create_:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@pe_create_:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN3@pe_create_

; 832  :             curr->e.seginfo->lname_idx = SEGTYPE_ERROR; /* use the highest index possible */

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+76], 10

; 833  :             if ( curr->e.seginfo->segtype == SEGTYPE_DATA ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 2
	jne	$LN14@pe_create_

; 834  :                 if ( curr->e.seginfo->readonly || curr->e.seginfo->characteristics == CHAR_READONLY )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@pe_create_
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+105]
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN16@pe_create_
$LN18@pe_create_:

; 835  :                     curr->e.seginfo->segtype = SEGTYPE_CDATA;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+72], 7
	jmp	SHORT $LN17@pe_create_
$LN16@pe_create_:

; 836  :                 else if ( curr->e.seginfo->clsym && strcmp( curr->e.seginfo->clsym->name, "CONST" ) == 0 )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN19@pe_create_
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+80]
	lea	rdx, OFFSET FLAT:$SG12035
	mov	rcx, QWORD PTR [rax+8]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN19@pe_create_

; 837  :                     curr->e.seginfo->segtype = SEGTYPE_CDATA;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+72], 7
$LN19@pe_create_:
$LN17@pe_create_:

; 838  :             } else if ( curr->e.seginfo->segtype == SEGTYPE_UNDEF ) {

	jmp	$LN15@pe_create_
$LN14@pe_create_:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 0
	jne	SHORT $LN20@pe_create_

; 839  :                 if ( ( memcmp( curr->sym.name, ".rsrc", 5 ) == 0 ) &&

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG12039
	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcmp
	test	eax, eax
	jne	SHORT $LN21@pe_create_
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax+5]
	test	eax, eax
	je	SHORT $LN23@pe_create_
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax+5]
	cmp	eax, 36					; 00000024H
	jne	SHORT $LN21@pe_create_
$LN23@pe_create_:

; 840  :                     ( *(curr->sym.name+5) == NULLC || *(curr->sym.name+5) == '$' ) )
; 841  :                     curr->e.seginfo->segtype = SEGTYPE_RSRC;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+72], 9
	jmp	SHORT $LN22@pe_create_
$LN21@pe_create_:

; 842  :                 else if ( strcmp( curr->sym.name, ".reloc" ) == 0 )

	lea	rdx, OFFSET FLAT:$SG12042
	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN24@pe_create_

; 843  :                     curr->e.seginfo->segtype = SEGTYPE_RELOC;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+72], 8
$LN24@pe_create_:
$LN22@pe_create_:
$LN20@pe_create_:
$LN15@pe_create_:

; 844  :             }
; 845  :         }

	jmp	$LN2@pe_create_
$LN3@pe_create_:

; 846  : 
; 847  :         /* count objects ( without header types ) */
; 848  :         for ( i = 1, objs = 0; i < SIZE_PEFLAT; i++ ) {

	mov	DWORD PTR i$[rsp], 1
	mov	DWORD PTR objs$[rsp], 0
	jmp	SHORT $LN7@pe_create_
$LN5@pe_create_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@pe_create_:
	movsxd	rax, DWORD PTR i$[rsp]
	cmp	rax, 7
	jae	$LN6@pe_create_

; 849  :             DebugMsg(("pe_create_section_table: searching type %u\n", flat_order[i] ));

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:flat_order
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12043
	call	DoDebugMsg

; 850  :             for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN10@pe_create_
$LN8@pe_create_:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN10@pe_create_:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN9@pe_create_

; 851  :                 DebugMsg(("pe_create_section_table: section %s, type=%u, size=%X\n", curr->sym.name, curr->e.seginfo->segtype, curr->sym.max_offset ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	r9d, DWORD PTR [rcx+56]
	mov	r8d, DWORD PTR [rax+72]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12044
	call	DoDebugMsg

; 852  :                 if ( curr->e.seginfo->segtype != flat_order[i] )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movsxd	rcx, DWORD PTR i$[rsp]
	lea	rdx, OFFSET FLAT:flat_order
	mov	ecx, DWORD PTR [rdx+rcx*4]
	cmp	DWORD PTR [rax+72], ecx
	je	SHORT $LN25@pe_create_

; 853  :                     continue;

	jmp	SHORT $LN8@pe_create_
$LN25@pe_create_:

; 854  :                 if ( curr->sym.max_offset ) {

	mov	rax, QWORD PTR curr$[rsp]
	cmp	DWORD PTR [rax+56], 0
	je	SHORT $LN26@pe_create_

; 855  :                     DebugMsg(("pe_create_section_table: %s, type=%u is object %u\n", curr->sym.name, curr->e.seginfo->segtype, objs ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	r9d, DWORD PTR objs$[rsp]
	mov	r8d, DWORD PTR [rax+72]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12047
	call	DoDebugMsg

; 856  :                     objs++;

	mov	eax, DWORD PTR objs$[rsp]
	inc	eax
	mov	DWORD PTR objs$[rsp], eax

; 857  :                     break;

	jmp	SHORT $LN9@pe_create_
$LN26@pe_create_:

; 858  :                 }
; 859  :             }

	jmp	$LN8@pe_create_
$LN9@pe_create_:

; 860  :         }

	jmp	$LN5@pe_create_
$LN6@pe_create_:

; 861  :         if ( objs ) {

	cmp	DWORD PTR objs$[rsp], 0
	je	SHORT $LN27@pe_create_

; 862  :             DebugMsg(("pe_create_section_table: items in object table: %u\n", objs ));

	mov	edx, DWORD PTR objs$[rsp]
	lea	rcx, OFFSET FLAT:$SG12049
	call	DoDebugMsg

; 863  :             objtab->sym.max_offset = sizeof(struct IMAGE_SECTION_HEADER) * objs;

	movsxd	rax, DWORD PTR objs$[rsp]
	imul	rax, rax, 40				; 00000028H
	mov	rcx, QWORD PTR objtab$[rsp]
	mov	DWORD PTR [rcx+56], eax

; 864  :             /* alloc space for 1 more section (.reloc) */
; 865  :             objtab->e.seginfo->CodeBuffer = LclAlloc( objtab->sym.max_offset + sizeof(struct IMAGE_SECTION_HEADER) );

	mov	rax, QWORD PTR objtab$[rsp]
	movsxd	rax, DWORD PTR [rax+56]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR objtab$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx+16], rax
$LN27@pe_create_:
$LN11@pe_create_:
$LN1@pe_create_:

; 866  :         }
; 867  :     }
; 868  : }

	add	rsp, 88					; 00000058H
	ret	0
pe_create_section_table ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
pehdr$ = 32
pe$ = 40
sym$ = 64
opnd$ = 72
set_file_flags PROC

; 728  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 729  :     struct dsym *pehdr;
; 730  :     struct IMAGE_PE_HEADER32 *pe;
; 731  : 
; 732  :     pehdr = ( struct dsym *)SymSearch( hdrname "2" );

	lea	rcx, OFFSET FLAT:$SG11965
	call	SymFind
	mov	QWORD PTR pehdr$[rsp], rax

; 733  :     if ( !pehdr )

	cmp	QWORD PTR pehdr$[rsp], 0
	jne	SHORT $LN2@set_file_f

; 734  :         return;

	jmp	SHORT $LN1@set_file_f
$LN2@set_file_f:

; 735  :     pe = (struct IMAGE_PE_HEADER32 *)pehdr->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR pehdr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR pe$[rsp], rax

; 736  : 
; 737  :     if ( opnd ) /* set the value? */

	cmp	QWORD PTR opnd$[rsp], 0
	je	SHORT $LN3@set_file_f

; 738  :         pe->FileHeader.Characteristics = opnd->value;

	mov	rax, QWORD PTR pe$[rsp]
	mov	rcx, QWORD PTR opnd$[rsp]
	movzx	ecx, WORD PTR [rcx]
	mov	WORD PTR [rax+22], cx
$LN3@set_file_f:

; 739  : 
; 740  :     sym->value = pe->FileHeader.Characteristics;

	mov	rax, QWORD PTR pe$[rsp]
	movzx	eax, WORD PTR [rax+22]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 741  :     DebugMsg(("set_file_flags(%s, %X): value=%X\n", sym->name, opnd, sym->value ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+16]
	mov	r8, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11968
	call	DoDebugMsg
$LN1@set_file_f:

; 742  : }

	add	rsp, 56					; 00000038H
	ret	0
set_file_flags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
p$ = 48
sym$ = 56
modinfo$ = 80
pe_create_MZ_header PROC

; 704  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 705  :     const char *p;
; 706  :     struct asym *sym;
; 707  : 
; 708  :     DebugMsg(("pe_create_MZ_header enter\n" ));

	lea	rcx, OFFSET FLAT:$SG11943
	call	DoDebugMsg

; 709  :     if ( Parse_Pass == PASS_1 && SymSearch( hdrname "1" ) == NULL )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN5@pe_create_
	lea	rcx, OFFSET FLAT:$SG11945
	call	SymFind
	test	rax, rax
	jne	SHORT $LN5@pe_create_

; 710  :         modinfo->g.pe_flags |= PEF_MZHDR;

	mov	rax, QWORD PTR modinfo$[rsp]
	movzx	eax, BYTE PTR [rax+312]
	or	eax, 1
	mov	rcx, QWORD PTR modinfo$[rsp]
	mov	BYTE PTR [rcx+312], al
$LN5@pe_create_:

; 711  :     if ( modinfo->g.pe_flags & PEF_MZHDR ) {

	mov	rax, QWORD PTR modinfo$[rsp]
	movzx	eax, BYTE PTR [rax+312]
	and	eax, 1
	test	eax, eax
	je	$LN6@pe_create_

; 712  :         DebugMsg(("pe_create_MZ_header: generate code\n" ));

	lea	rcx, OFFSET FLAT:$SG11947
	call	DoDebugMsg

; 713  :         AddLineQueueX("%r DOTNAME", T_OPTION );

	mov	edx, 452				; 000001c4H
	lea	rcx, OFFSET FLAT:$SG11948
	call	AddLineQueueX

; 714  :         AddLineQueueX("%s1 %r USE16 %r %s", hdrname, T_SEGMENT, T_WORD, hdrattr );

	lea	rax, OFFSET FLAT:hdrattr
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 207				; 000000cfH
	mov	r8d, 441				; 000001b9H
	lea	rdx, OFFSET FLAT:$SG11949
	lea	rcx, OFFSET FLAT:$SG11950
	call	AddLineQueueX

; 715  :         for( p = mzcode; p < mzcode + sizeof( mzcode ); p += strlen( p ) + 1 )

	lea	rax, OFFSET FLAT:mzcode
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN4@pe_create_
$LN2@pe_create_:
	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR p$[rsp], rax
$LN4@pe_create_:
	lea	rax, OFFSET FLAT:mzcode
	add	rax, 180				; 000000b4H
	cmp	QWORD PTR p$[rsp], rax
	jae	SHORT $LN3@pe_create_

; 716  :             AddLineQueue( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	AddLineQueue
	jmp	SHORT $LN2@pe_create_
$LN3@pe_create_:

; 717  :         AddLineQueueX("%s1 %r", hdrname, T_ENDS );

	mov	r8d, 442				; 000001baH
	lea	rdx, OFFSET FLAT:$SG11951
	lea	rcx, OFFSET FLAT:$SG11952
	call	AddLineQueueX

; 718  :         RunLineQueue();

	call	RunLineQueue

; 719  :         if ( ( sym = SymSearch( hdrname "1" ) ) && sym->state == SYM_SEG )

	lea	rcx, OFFSET FLAT:$SG11954
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN7@pe_create_
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 3
	jne	SHORT $LN7@pe_create_

; 720  :            (( struct dsym *)sym)->e.seginfo->segtype = SEGTYPE_HDR;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+72], 6
$LN7@pe_create_:
$LN6@pe_create_:

; 721  :     }
; 722  : }

	add	rsp, 72					; 00000048H
	ret	0
pe_create_MZ_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
value$ = 64
fixup$ = 72
codeptr$ = 80
seg$ = 88
offset$ = 96
tv154 = 100
tv309 = 104
segfirst$1 = 112
namlen$2 = 120
tv295 = 124
tv480 = 128
tv546 = 132
tv580 = 136
tmp$ = 144
tv301 = 152
value64$ = 160
curr$ = 192
cp$ = 200
DoFixup	PROC

; 439  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 440  :     union genptr codeptr;
; 441  :     struct dsym *seg;
; 442  :     uint_32 value;
; 443  : #if PE_SUPPORT && AMD64_SUPPORT
; 444  :     uint_64 value64;
; 445  : #endif
; 446  :     uint_32 offset;  /* v2.07 */
; 447  :     struct fixup *fixup;
; 448  :     char *tmp;
; 449  : 
; 450  :     if ( curr->e.seginfo->segtype == SEGTYPE_ABS )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 5
	jne	SHORT $LN12@DoFixup

; 451  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@DoFixup
$LN12@DoFixup:

; 452  : 
; 453  :     DebugMsg(("DoFixup(%s) enter, segment start ofs=%" I32_SPEC "Xh\n", curr->sym.name, curr->e.seginfo->start_offset ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	r8d, DWORD PTR [rax+12]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11857
	call	DoDebugMsg

; 454  :     for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR fixup$[rsp], rax
	jmp	SHORT $LN4@DoFixup
$LN2@DoFixup:
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR fixup$[rsp], rax
$LN4@DoFixup:
	cmp	QWORD PTR fixup$[rsp], 0
	je	$LN3@DoFixup

; 455  :         codeptr.db = curr->e.seginfo->CodeBuffer +

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	edx, DWORD PTR [rdx+20]
	sub	edx, ecx
	mov	ecx, edx
	mov	ecx, ecx
	add	rcx, QWORD PTR [rax+16]
	mov	rax, rcx
	mov	QWORD PTR codeptr$[rsp], rax

; 456  :             ( fixup->locofs - curr->e.seginfo->start_loc );
; 457  : 
; 458  :         //if ( fixup->sym && fixup->sym->segment ) { /* v2.08: changed */
; 459  :         if ( fixup->sym && ( fixup->sym->segment || fixup->sym->variable ) ) {

	mov	rax, QWORD PTR fixup$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	$LN13@DoFixup
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN15@DoFixup
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN13@DoFixup
$LN15@DoFixup:

; 460  :             /* assembly time variable (also $ symbol) in reloc? */
; 461  :             /* v2.07: moved inside if-block, using new local var "offset" */
; 462  :             if ( fixup->sym->variable ) {

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@DoFixup

; 463  :                 seg = (struct dsym *)fixup->segment_var;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR seg$[rsp], rax

; 464  :                 offset = 0;

	mov	DWORD PTR offset$[rsp], 0

; 465  :                 DebugMsg(("DoFixup(%s, %04" I32_SPEC "X, %s): variable, fixup->segment=%Xh fixup->offset=%" I32_SPEC "Xh, fixup->sym->offset=%" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR seg$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11863
	call	DoDebugMsg

; 466  :                           curr->sym.name, fixup->locofs, fixup->sym->name, seg, fixup->offset, fixup->sym->offset ));
; 467  :             } else {

	jmp	SHORT $LN17@DoFixup
$LN16@DoFixup:

; 468  :                 seg = (struct dsym *)fixup->sym->segment;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR seg$[rsp], rax

; 469  :                 offset = fixup->sym->offset;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR offset$[rsp], eax
$LN17@DoFixup:

; 470  :             }
; 471  :             /* the offset result consists of
; 472  :              * - the symbol's offset
; 473  :              * - the fixup's offset (usually the displacement )
; 474  :              * - the segment/group offset in the image
; 475  :              */
; 476  :             switch ( fixup->type ) {

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv154[rsp], eax
	cmp	DWORD PTR tv154[rsp], 0
	jle	$LN23@DoFixup
	cmp	DWORD PTR tv154[rsp], 3
	jle	$LN22@DoFixup
	cmp	DWORD PTR tv154[rsp], 12
	je	SHORT $LN18@DoFixup
	cmp	DWORD PTR tv154[rsp], 13
	je	SHORT $LN19@DoFixup
	jmp	$LN23@DoFixup
$LN18@DoFixup:

; 477  :             case FIX_OFF32_IMGREL:
; 478  :                 value = ( fixup->offset + offset + seg->e.seginfo->start_offset ) - cp->imagestart;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+16]
	add	eax, DWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	add	eax, DWORD PTR [rcx+12]
	mov	rcx, QWORD PTR cp$[rsp]
	sub	eax, DWORD PTR [rcx+24]
	mov	DWORD PTR value$[rsp], eax

; 479  :                 DebugMsg(("DoFixup(%s): IMGREL, loc=%" I32_SPEC "X value=%" I32_SPEC "X seg.start=%" I32_SPEC "X imagestart=%" I32_SPEC "X\n",

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR cp$[rsp]
	mov	ecx, DWORD PTR [rcx+24]
	mov	DWORD PTR [rsp+40], ecx
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR value$[rsp]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11865
	call	DoDebugMsg

; 480  :                           curr->sym.name, fixup->locofs, value, seg->e.seginfo->start_offset, cp->imagestart ));
; 481  :                 break;

	jmp	$LN5@DoFixup
$LN19@DoFixup:

; 482  :             case FIX_OFF32_SECREL:
; 483  :                 value = ( fixup->offset + offset ) - seg->e.seginfo->start_loc;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+16]
	add	eax, DWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	sub	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR value$[rsp], eax

; 484  :                 /* check if symbol's segment name contains a '$'.
; 485  :                  * If yes, search the segment without suffix.
; 486  :                  */
; 487  :                 if ( tmp = strchr( seg->sym.name, '$' ) ) {

	mov	edx, 36					; 00000024H
	mov	rax, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	strchr
	mov	QWORD PTR tmp$[rsp], rax
	cmp	QWORD PTR tmp$[rsp], 0
	je	$LN20@DoFixup

; 488  :                     int namlen = tmp - seg->sym.name;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tmp$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR namlen$2[rsp], eax

; 489  :                     struct dsym *segfirst;
; 490  :                     for( segfirst = SymTables[TAB_SEG].head; segfirst; segfirst = segfirst->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR segfirst$1[rsp], rax
	jmp	SHORT $LN9@DoFixup
$LN7@DoFixup:
	mov	rax, QWORD PTR segfirst$1[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR segfirst$1[rsp], rax
$LN9@DoFixup:
	cmp	QWORD PTR segfirst$1[rsp], 0
	je	$LN8@DoFixup

; 491  :                         if ( segfirst->sym.name_size == namlen &&

	mov	rax, QWORD PTR segfirst$1[rsp]
	movzx	eax, BYTE PTR [rax+72]
	cmp	eax, DWORD PTR namlen$2[rsp]
	jne	SHORT $LN21@DoFixup
	movsxd	rax, DWORD PTR namlen$2[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR seg$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR segfirst$1[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcmp
	test	eax, eax
	jne	SHORT $LN21@DoFixup

; 492  :                             ( memcmp( segfirst->sym.name, seg->sym.name, namlen ) == 0 ) ) {
; 493  :                             value = ( fixup->offset + offset + seg->e.seginfo->start_offset ) - segfirst->e.seginfo->start_offset;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+16]
	add	eax, DWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	add	eax, DWORD PTR [rcx+12]
	mov	rcx, QWORD PTR segfirst$1[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	sub	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR value$[rsp], eax

; 494  :                             DebugMsg(("DoFixup(%s): SECREL, primary seg=%s, start_offset=%" I32_SPEC "X\n",

	mov	rax, QWORD PTR segfirst$1[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	r9d, DWORD PTR [rax+12]
	mov	rax, QWORD PTR segfirst$1[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11869
	call	DoDebugMsg

; 495  :                                       curr->sym.name, segfirst->sym.name, segfirst->e.seginfo->start_offset ));
; 496  :                             break;

	jmp	SHORT $LN8@DoFixup
$LN21@DoFixup:

; 497  :                         }
; 498  :                     }

	jmp	$LN7@DoFixup
$LN8@DoFixup:
$LN20@DoFixup:

; 499  :                 }
; 500  :                 DebugMsg(("DoFixup(%s): SECREL, loc=%" I32_SPEC "X, value=%" I32_SPEC "X\n",

	mov	r9d, DWORD PTR value$[rsp]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11870
	call	DoDebugMsg

; 501  :                         curr->sym.name, fixup->locofs, value ));
; 502  :                 break;

	jmp	$LN5@DoFixup
$LN22@DoFixup:

; 503  :             case FIX_RELOFF8:
; 504  :             case FIX_RELOFF16:
; 505  :             case FIX_RELOFF32:
; 506  :                 /* v1.96: special handling for "relative" fixups */
; 507  :                 value = seg->e.seginfo->start_offset + fixup->offset + offset;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	mov	rcx, QWORD PTR fixup$[rsp]
	add	eax, DWORD PTR [rcx+16]
	add	eax, DWORD PTR offset$[rsp]
	mov	DWORD PTR value$[rsp], eax

; 508  :                 DebugMsg(("DoFixup(%s): RELOFFx, loc=%" I32_SPEC "X, sym=%s, [start_offset=%" I32_SPEC "Xh, fixup->offset=%" I32_SPEC "Xh, fixup->sym->offset=%" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	edx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rsp+48], edx
	mov	rdx, QWORD PTR fixup$[rsp]
	mov	edx, DWORD PTR [rdx+16]
	mov	DWORD PTR [rsp+40], edx
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11872
	call	DoDebugMsg

; 509  :                         curr->sym.name, fixup->locofs, fixup->sym->name, seg->e.seginfo->start_offset, fixup->offset, offset ));
; 510  :                 break;

	jmp	$LN5@DoFixup
$LN23@DoFixup:

; 511  :             default:
; 512  :                 /* v2.01: don't use group if fixup explicitely refers the segment! */
; 513  :                 //if ( seg->e.seginfo->group ) {
; 514  :                 if ( seg->e.seginfo->group && fixup->frame_type != FRAME_SEG ) {

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax], 0
	je	$LN24@DoFixup
	mov	rax, QWORD PTR fixup$[rsp]
	movsx	eax, BYTE PTR [rax+40]
	test	eax, eax
	je	SHORT $LN24@DoFixup

; 515  :                     value = (seg->e.seginfo->group->offset & 0xF) + seg->e.seginfo->start_offset + fixup->offset + offset;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 15
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	add	eax, DWORD PTR [rcx+12]
	mov	rcx, QWORD PTR fixup$[rsp]
	add	eax, DWORD PTR [rcx+16]
	add	eax, DWORD PTR offset$[rsp]
	mov	DWORD PTR value$[rsp], eax

; 516  : #if PE_SUPPORT
; 517  :                     if ( ModuleInfo.sub_format == SFORMAT_PE ) {

	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN26@DoFixup

; 518  : #if AMD64_SUPPORT
; 519  :                         if ( curr->e.seginfo->Ofssize == USE64 )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+104]
	cmp	eax, 2
	jne	SHORT $LN27@DoFixup

; 520  :                             value64 = value + cp->imagebase64;

	mov	eax, DWORD PTR value$[rsp]
	mov	rcx, QWORD PTR cp$[rsp]
	add	rax, QWORD PTR [rcx+32]
	mov	QWORD PTR value64$[rsp], rax
$LN27@DoFixup:

; 521  : #endif
; 522  :                         value += cp->imagebase;

	mov	rax, QWORD PTR cp$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	ecx, DWORD PTR value$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR value$[rsp], eax
$LN26@DoFixup:

; 523  :                     }
; 524  : #endif
; 525  :                 } else

	jmp	SHORT $LN25@DoFixup
$LN24@DoFixup:

; 526  :                     value = (seg->e.seginfo->start_offset & 0xF) + fixup->offset + offset;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	and	eax, 15
	mov	rcx, QWORD PTR fixup$[rsp]
	add	eax, DWORD PTR [rcx+16]
	add	eax, DWORD PTR offset$[rsp]
	mov	DWORD PTR value$[rsp], eax
$LN25@DoFixup:

; 527  : 
; 528  :                 DebugMsg(("DoFixup(%s): loc=%04" I32_SPEC "X, sym=%s, target->start_offset=%" I32_SPEC "Xh, fixup->offset=%" I32_SPEC "Xh, fixup->sym->offset=%" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	edx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rsp+48], edx
	mov	rdx, QWORD PTR fixup$[rsp]
	mov	edx, DWORD PTR [rdx+16]
	mov	DWORD PTR [rsp+40], edx
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11878
	call	DoDebugMsg
$LN5@DoFixup:

; 529  :                         curr->sym.name, fixup->locofs, fixup->sym->name, seg->e.seginfo->start_offset, fixup->offset, offset ));
; 530  :                 break;
; 531  :             }
; 532  : 
; 533  :         } else {

	jmp	$LN14@DoFixup
$LN13@DoFixup:

; 534  :             /* v2.10: member segment_var is for assembly-time variables only */
; 535  :             //seg = (struct dsym *)fixup->segment_var;
; 536  :             seg = NULL;

	mov	QWORD PTR seg$[rsp], 0

; 537  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X, %s): target segment=0, fixup->offset=%" I32_SPEC "Xh, fixup->sym->offset=%" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR fixup$[rsp]
	cmp	DWORD PTR [rax+16], 0
	je	SHORT $LN62@DoFixup
	mov	eax, DWORD PTR offset$[rsp]
	mov	DWORD PTR tv295[rsp], eax
	jmp	SHORT $LN63@DoFixup
$LN62@DoFixup:
	mov	DWORD PTR tv295[rsp], 0
$LN63@DoFixup:
	mov	rax, QWORD PTR fixup$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN64@DoFixup
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv301[rsp], rax
	jmp	SHORT $LN65@DoFixup
$LN64@DoFixup:
	lea	rax, OFFSET FLAT:$SG11879
	mov	QWORD PTR tv301[rsp], rax
$LN65@DoFixup:
	mov	eax, DWORD PTR tv295[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR tv301[rsp]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11880
	call	DoDebugMsg

; 538  :                       curr->sym.name, fixup->locofs, fixup->sym ? fixup->sym->name : "", fixup->offset ? offset : 0 ));
; 539  :             value = 0;

	mov	DWORD PTR value$[rsp], 0
$LN14@DoFixup:

; 540  :         }
; 541  : 
; 542  :         switch ( fixup->type ) {

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv309[rsp], eax
	mov	eax, DWORD PTR tv309[rsp]
	dec	eax
	mov	DWORD PTR tv309[rsp], eax
	cmp	DWORD PTR tv309[rsp], 12
	ja	$LN60@DoFixup
	movsxd	rax, DWORD PTR tv309[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN72@DoFixup[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN28@DoFixup:

; 543  :         case FIX_RELOFF8:
; 544  :             //*codeptr.db += (value - fixup->locofs + 1) & 0xff;
; 545  :             /* changed in v1.95 */
; 546  :             *codeptr.db += (value - (fixup->locofs + curr->e.seginfo->start_offset) - 1) & 0xff;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	add	ecx, DWORD PTR [rax+12]
	mov	eax, ecx
	mov	ecx, DWORD PTR value$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	dec	eax
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR codeptr$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	BYTE PTR [rcx], al

; 547  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_RELOFF8, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.db ));

	mov	rax, QWORD PTR codeptr$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR value$[rsp]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11882
	call	DoDebugMsg

; 548  :             break;

	jmp	$LN10@DoFixup
$LN29@DoFixup:

; 549  :         case FIX_RELOFF16:
; 550  :             //*codeptr.dw += (value - fixup->locofs + 2) & 0xffff;
; 551  :             /* changed in v1.95 */
; 552  :             *codeptr.dw += (value - (fixup->locofs + curr->e.seginfo->start_offset) - 2) & 0xffff;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	add	ecx, DWORD PTR [rax+12]
	mov	eax, ecx
	mov	ecx, DWORD PTR value$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sub	eax, 2
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR codeptr$[rsp]
	movzx	ecx, WORD PTR [rcx]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	WORD PTR [rcx], ax

; 553  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_RELOFF16, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dw ));

	mov	rax, QWORD PTR codeptr$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR value$[rsp]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11884
	call	DoDebugMsg

; 554  :             break;

	jmp	$LN10@DoFixup
$LN30@DoFixup:

; 555  :         case FIX_RELOFF32:
; 556  : #if AMD64_SUPPORT
; 557  :             /* adjust the location for EIP-related offsets if USE64 */
; 558  :             if ( curr->e.seginfo->Ofssize == USE64 ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+104]
	cmp	eax, 2
	jne	SHORT $LN31@DoFixup

; 559  :                 fixup->locofs += fixup->addbytes - 4;

	mov	rax, QWORD PTR fixup$[rsp]
	movzx	eax, BYTE PTR [rax+32]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	lea	eax, DWORD PTR [rax+rcx-4]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	DWORD PTR [rcx+20], eax
$LN31@DoFixup:

; 560  :             }
; 561  : #endif
; 562  :             //*codeptr.dd += (value - fixup->locofs + 4);
; 563  :             /* changed in v1.95 */
; 564  :             *codeptr.dd += (value - (fixup->locofs + curr->e.seginfo->start_offset) - 4);

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	add	ecx, DWORD PTR [rax+12]
	mov	eax, ecx
	mov	ecx, DWORD PTR value$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	ecx, DWORD PTR [rcx]
	lea	eax, DWORD PTR [rax+rcx-4]
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	DWORD PTR [rcx], eax

; 565  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_RELOFF32, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dd ));

	mov	rax, QWORD PTR codeptr$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR value$[rsp]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11887
	call	DoDebugMsg

; 566  :             break;

	jmp	$LN10@DoFixup
$LN32@DoFixup:

; 567  :         case FIX_OFF8:
; 568  :             *codeptr.db = value & 0xff;

	mov	eax, DWORD PTR value$[rsp]
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	BYTE PTR [rcx], al

; 569  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF8, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.db ));

	mov	rax, QWORD PTR codeptr$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR value$[rsp]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11889
	call	DoDebugMsg

; 570  :             break;

	jmp	$LN10@DoFixup
$LN33@DoFixup:

; 571  :         case FIX_OFF16:
; 572  :             *codeptr.dw = value & 0xffff;

	mov	eax, DWORD PTR value$[rsp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	WORD PTR [rcx], ax

; 573  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF16, value=%" I32_SPEC "Xh, target=%p *target=%Xh\n", curr->sym.name, fixup->locofs, value, codeptr, *codeptr.dw ));

	mov	rax, QWORD PTR codeptr$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR codeptr$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR value$[rsp]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11891
	call	DoDebugMsg

; 574  :             break;

	jmp	$LN10@DoFixup
$LN34@DoFixup:

; 575  :         case FIX_OFF32:
; 576  :             *codeptr.dd = value;

	mov	rax, QWORD PTR codeptr$[rsp]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax], ecx

; 577  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF32, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dd ));

	mov	rax, QWORD PTR codeptr$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR value$[rsp]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11893
	call	DoDebugMsg

; 578  :             break;

	jmp	$LN10@DoFixup
$LN35@DoFixup:

; 579  :         case FIX_OFF32_IMGREL:
; 580  :             *codeptr.dd = value;

	mov	rax, QWORD PTR codeptr$[rsp]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax], ecx

; 581  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF32_IMGREL, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dd ));

	mov	rax, QWORD PTR codeptr$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR value$[rsp]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11895
	call	DoDebugMsg

; 582  :             break;

	jmp	$LN10@DoFixup
$LN36@DoFixup:

; 583  :         case FIX_OFF32_SECREL:
; 584  :             *codeptr.dd = value;

	mov	rax, QWORD PTR codeptr$[rsp]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax], ecx

; 585  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF32_SECREL, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dd ));

	mov	rax, QWORD PTR codeptr$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR value$[rsp]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11897
	call	DoDebugMsg

; 586  :             break;

	jmp	$LN10@DoFixup
$LN37@DoFixup:

; 587  : #if AMD64_SUPPORT
; 588  :         case FIX_OFF64:
; 589  : #if PE_SUPPORT
; 590  :             if ( ModuleInfo.sub_format == SFORMAT_PE && curr->e.seginfo->Ofssize == USE64 )

	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN38@DoFixup
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+104]
	cmp	eax, 2
	jne	SHORT $LN38@DoFixup

; 591  :                 *codeptr.dq = value64;

	mov	rax, QWORD PTR codeptr$[rsp]
	mov	rcx, QWORD PTR value64$[rsp]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN39@DoFixup
$LN38@DoFixup:

; 592  :             else
; 593  : #endif
; 594  :                 *codeptr.dq = value;

	mov	eax, DWORD PTR value$[rsp]
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	QWORD PTR [rcx], rax
$LN39@DoFixup:

; 595  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF64, value=%" I32_SPEC "Xh, *target=%" I64_SPEC "Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dq ));

	mov	rax, QWORD PTR codeptr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR value$[rsp]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11901
	call	DoDebugMsg

; 596  :             break;

	jmp	$LN10@DoFixup
$LN40@DoFixup:

; 597  : #endif
; 598  :         case FIX_HIBYTE:
; 599  :             *codeptr.db = (value >> 8) & 0xff;

	mov	eax, DWORD PTR value$[rsp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	BYTE PTR [rcx], al

; 600  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_HIBYTE, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.db ));

	mov	rax, QWORD PTR codeptr$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR value$[rsp]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11903
	call	DoDebugMsg

; 601  :             break;

	jmp	$LN10@DoFixup
$LN41@DoFixup:

; 602  :         case FIX_SEG:
; 603  :             /* absolute segments are ok */
; 604  :             if ( fixup->sym &&
; 605  :                 fixup->sym->state == SYM_SEG &&

	mov	rax, QWORD PTR fixup$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN42@DoFixup
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	cmp	DWORD PTR [rax+32], 3
	jne	SHORT $LN42@DoFixup
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 5
	jne	SHORT $LN42@DoFixup

; 606  :                 ((struct dsym *)fixup->sym)->e.seginfo->segtype == SEGTYPE_ABS ) {
; 607  :                 *codeptr.dw = ((struct dsym *)fixup->sym)->e.seginfo->abs_frame;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR codeptr$[rsp]
	movzx	eax, WORD PTR [rax+88]
	mov	WORD PTR [rcx], ax

; 608  :                 break;

	jmp	$LN10@DoFixup
$LN42@DoFixup:

; 609  :             }
; 610  : #if MZ_SUPPORT
; 611  :             if ( ModuleInfo.sub_format == SFORMAT_MZ ) {

	cmp	DWORD PTR ModuleInfo+372, 1
	jne	$LN43@DoFixup

; 612  :                 DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_SEG frame=%u, ", curr->sym.name, fixup->locofs, fixup->frame_type ));

	mov	rax, QWORD PTR fixup$[rsp]
	movsx	eax, BYTE PTR [rax+40]
	mov	r9d, eax
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11907
	call	DoDebugMsg

; 613  :                 if ( fixup->sym->state == SYM_GRP ) {

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	cmp	DWORD PTR [rax+32], 4
	jne	SHORT $LN44@DoFixup

; 614  :                     seg = (struct dsym *)fixup->sym;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR seg$[rsp], rax

; 615  :                     *codeptr.dw = seg->sym.offset >> 4;

	mov	rax, QWORD PTR seg$[rsp]
	mov	eax, DWORD PTR [rax+16]
	sar	eax, 4
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	WORD PTR [rcx], ax

; 616  :                     DebugMsg(("GROUP symbol, offset=%" I32_SPEC "Xh codeptr=%p\n", seg->sym.offset, codeptr ));

	mov	r8, QWORD PTR codeptr$[rsp]
	mov	rax, QWORD PTR seg$[rsp]
	mov	edx, DWORD PTR [rax+16]
	lea	rcx, OFFSET FLAT:$SG11910
	call	DoDebugMsg
	jmp	$LN45@DoFixup
$LN44@DoFixup:

; 617  :                 } else if ( fixup->sym->state == SYM_SEG ) {

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	cmp	DWORD PTR [rax+32], 3
	jne	SHORT $LN46@DoFixup

; 618  :                     /* v2.04: added */
; 619  :                     seg = (struct dsym *)fixup->sym;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR seg$[rsp], rax

; 620  :                     *codeptr.dw = ( seg->e.seginfo->start_offset + ( seg->e.seginfo->group ? seg->e.seginfo->group->offset : 0 ) ) >> 4;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN66@DoFixup
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv480[rsp], eax
	jmp	SHORT $LN67@DoFixup
$LN66@DoFixup:
	mov	DWORD PTR tv480[rsp], 0
$LN67@DoFixup:
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	add	eax, DWORD PTR tv480[rsp]
	shr	eax, 4
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	WORD PTR [rcx], ax

; 621  :                     DebugMsg(("SEGMENT symbol, start_offset=%" I32_SPEC "Xh\n", seg->e.seginfo->start_offset ));

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	edx, DWORD PTR [rax+12]
	lea	rcx, OFFSET FLAT:$SG11913
	call	DoDebugMsg
	jmp	SHORT $LN47@DoFixup
$LN46@DoFixup:

; 622  :                 //} else if ( seg->e.seginfo->group ) {
; 623  :                 } else if ( fixup->frame_type == FRAME_GRP ) {

	mov	rax, QWORD PTR fixup$[rsp]
	movsx	eax, BYTE PTR [rax+40]
	cmp	eax, 1
	jne	SHORT $LN48@DoFixup

; 624  :                     /* v2.04: changed */
; 625  :                     //*codeptr.dw = (seg->e.seginfo->start_offset + seg->e.seginfo->group->offset) >> 4;
; 626  :                     *codeptr.dw = seg->e.seginfo->group->offset >> 4;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+16]
	sar	eax, 4
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	WORD PTR [rcx], ax

; 627  :                     DebugMsg(("group.offset=%" I32_SPEC "Xh\n", seg->e.seginfo->group->offset ));

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	edx, DWORD PTR [rax+16]
	lea	rcx, OFFSET FLAT:$SG11916
	call	DoDebugMsg

; 628  :                 } else {

	jmp	SHORT $LN49@DoFixup
$LN48@DoFixup:

; 629  :                     *codeptr.dw = seg->e.seginfo->start_offset >> 4;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	shr	eax, 4
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	WORD PTR [rcx], ax

; 630  :                     DebugMsg(("segment.offset=%" I32_SPEC "Xh\n", seg->e.seginfo->start_offset ));

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	edx, DWORD PTR [rax+12]
	lea	rcx, OFFSET FLAT:$SG11917
	call	DoDebugMsg
$LN49@DoFixup:
$LN47@DoFixup:
$LN45@DoFixup:

; 631  :                 }
; 632  :                 break;

	jmp	$LN10@DoFixup
$LN43@DoFixup:
$LN50@DoFixup:

; 633  :             }
; 634  : #endif
; 635  :         case FIX_PTR16:
; 636  : #if 1
; 637  :             /* v2.10: absolute segments are ok */
; 638  :             if ( seg && seg->e.seginfo->segtype == SEGTYPE_ABS ) {

	cmp	QWORD PTR seg$[rsp], 0
	je	SHORT $LN51@DoFixup
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 5
	jne	SHORT $LN51@DoFixup

; 639  :                 *codeptr.dw = value & 0xffff;

	mov	eax, DWORD PTR value$[rsp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	WORD PTR [rcx], ax

; 640  :                 codeptr.dw++;

	mov	rax, QWORD PTR codeptr$[rsp]
	add	rax, 2
	mov	QWORD PTR codeptr$[rsp], rax

; 641  :                 *codeptr.dw = seg->e.seginfo->abs_frame;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR codeptr$[rsp]
	movzx	eax, WORD PTR [rax+88]
	mov	WORD PTR [rcx], ax

; 642  :                 break;

	jmp	$LN10@DoFixup
$LN51@DoFixup:

; 643  :             }
; 644  : #endif
; 645  : #if MZ_SUPPORT
; 646  :             if ( ModuleInfo.sub_format == SFORMAT_MZ ) {

	cmp	DWORD PTR ModuleInfo+372, 1
	jne	$LN52@DoFixup

; 647  :                 DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_PTR16, seg->start=%Xh\n", curr->sym.name, fixup->locofs, seg->e.seginfo->start_offset ));

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	r9d, DWORD PTR [rax+12]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11921
	call	DoDebugMsg

; 648  :                 *codeptr.dw = value & 0xffff;

	mov	eax, DWORD PTR value$[rsp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	WORD PTR [rcx], ax

; 649  :                 codeptr.dw++;

	mov	rax, QWORD PTR codeptr$[rsp]
	add	rax, 2
	mov	QWORD PTR codeptr$[rsp], rax

; 650  :                 //if ( seg->e.seginfo->group ) { /* v2.04: changed */
; 651  :                 if ( fixup->frame_type == FRAME_GRP ) {

	mov	rax, QWORD PTR fixup$[rsp]
	movsx	eax, BYTE PTR [rax+40]
	cmp	eax, 1
	jne	SHORT $LN53@DoFixup

; 652  :                     /* v2.04: changed */
; 653  :                     //*codeptr.dw = (seg->e.seginfo->start_offset + seg->e.seginfo->group->offset) >> 4;
; 654  :                     *codeptr.dw = seg->e.seginfo->group->offset >> 4;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+16]
	sar	eax, 4
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	WORD PTR [rcx], ax

; 655  :                 } else {

	jmp	SHORT $LN54@DoFixup
$LN53@DoFixup:

; 656  :                     /* v2.05: changed */
; 657  :                     //*codeptr.dw = seg->e.seginfo->start_offset >> 4;
; 658  :                     *codeptr.dw = ( seg->e.seginfo->start_offset + ( seg->e.seginfo->group ? seg->e.seginfo->group->offset : 0 ) ) >> 4;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN68@DoFixup
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv546[rsp], eax
	jmp	SHORT $LN69@DoFixup
$LN68@DoFixup:
	mov	DWORD PTR tv546[rsp], 0
$LN69@DoFixup:
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	add	eax, DWORD PTR tv546[rsp]
	shr	eax, 4
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	WORD PTR [rcx], ax
$LN54@DoFixup:

; 659  :                 }
; 660  :                 break;

	jmp	$LN10@DoFixup
$LN52@DoFixup:
$LN55@DoFixup:

; 661  :             }
; 662  : #endif
; 663  :         case FIX_PTR32:
; 664  : #if 1
; 665  :             /* v2.10: absolute segments are ok */
; 666  :             if ( seg && seg->e.seginfo->segtype == SEGTYPE_ABS ) {

	cmp	QWORD PTR seg$[rsp], 0
	je	SHORT $LN56@DoFixup
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 5
	jne	SHORT $LN56@DoFixup

; 667  :                 *codeptr.dd = value;

	mov	rax, QWORD PTR codeptr$[rsp]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax], ecx

; 668  :                 codeptr.dd++;

	mov	rax, QWORD PTR codeptr$[rsp]
	add	rax, 4
	mov	QWORD PTR codeptr$[rsp], rax

; 669  :                 *codeptr.dw = seg->e.seginfo->abs_frame;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR codeptr$[rsp]
	movzx	eax, WORD PTR [rax+88]
	mov	WORD PTR [rcx], ax

; 670  :                 break;

	jmp	$LN10@DoFixup
$LN56@DoFixup:

; 671  :             }
; 672  : #endif
; 673  : #if MZ_SUPPORT
; 674  :             if ( ModuleInfo.sub_format == SFORMAT_MZ ) {

	cmp	DWORD PTR ModuleInfo+372, 1
	jne	$LN57@DoFixup

; 675  :                 DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_PTR32\n", curr->sym.name, fixup->locofs ));

	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11927
	call	DoDebugMsg

; 676  :                 *codeptr.dd = value;

	mov	rax, QWORD PTR codeptr$[rsp]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax], ecx

; 677  :                 codeptr.dd++;

	mov	rax, QWORD PTR codeptr$[rsp]
	add	rax, 4
	mov	QWORD PTR codeptr$[rsp], rax

; 678  :                 //if (seg->e.seginfo->group ) { /* v2.04: changed */
; 679  :                 if ( fixup->frame_type == FRAME_GRP ) {

	mov	rax, QWORD PTR fixup$[rsp]
	movsx	eax, BYTE PTR [rax+40]
	cmp	eax, 1
	jne	SHORT $LN58@DoFixup

; 680  :                     /* v2.04: changed */
; 681  :                     //*codeptr.dw = (seg->e.seginfo->start_offset + seg->e.seginfo->group->offset) >> 4;
; 682  :                     *codeptr.dw = seg->e.seginfo->group->offset >> 4;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+16]
	sar	eax, 4
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	WORD PTR [rcx], ax

; 683  :                 } else {

	jmp	SHORT $LN59@DoFixup
$LN58@DoFixup:

; 684  :                     /* v2.05: changed */
; 685  :                     //*codeptr.dw = seg->e.seginfo->start_offset >> 4;
; 686  :                     *codeptr.dw = ( seg->e.seginfo->start_offset + ( seg->e.seginfo->group ? seg->e.seginfo->group->offset : 0 ) ) >> 4;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN70@DoFixup
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv580[rsp], eax
	jmp	SHORT $LN71@DoFixup
$LN70@DoFixup:
	mov	DWORD PTR tv580[rsp], 0
$LN71@DoFixup:
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	add	eax, DWORD PTR tv580[rsp]
	shr	eax, 4
	mov	rcx, QWORD PTR codeptr$[rsp]
	mov	WORD PTR [rcx], ax
$LN59@DoFixup:

; 687  :                 }
; 688  :                 break;

	jmp	SHORT $LN10@DoFixup
$LN57@DoFixup:
$LN60@DoFixup:

; 689  :             }
; 690  : #endif
; 691  :         default:
; 692  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): invalid fixup %u\n", curr->sym.name, fixup->locofs, fixup->type ));

	mov	rax, QWORD PTR fixup$[rsp]
	mov	r9d, DWORD PTR [rax+24]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11931
	call	DoDebugMsg

; 693  :             EmitErr( INVALID_FIXUP_TYPE, ModuleInfo.fmtopt->formatname, fixup->type, curr->sym.name, fixup->locofs );

	mov	rax, QWORD PTR ModuleInfo+344
	add	rax, 10
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	mov	DWORD PTR [rsp+32], ecx
	mov	rcx, QWORD PTR curr$[rsp]
	mov	r9, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rcx+24]
	mov	rdx, rax
	mov	ecx, 198				; 000000c6H
	call	EmitErr
$LN10@DoFixup:

; 694  :             //return( ERROR );
; 695  :         }
; 696  :     }

	jmp	$LN2@DoFixup
$LN3@DoFixup:

; 697  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@DoFixup:

; 698  : }

	add	rsp, 184				; 000000b8H
	ret	0
	npad	3
$LN72@DoFixup:
	DD	$LN28@DoFixup
	DD	$LN29@DoFixup
	DD	$LN30@DoFixup
	DD	$LN32@DoFixup
	DD	$LN33@DoFixup
	DD	$LN34@DoFixup
	DD	$LN37@DoFixup
	DD	$LN41@DoFixup
	DD	$LN50@DoFixup
	DD	$LN55@DoFixup
	DD	$LN40@DoFixup
	DD	$LN35@DoFixup
	DD	$LN36@DoFixup
DoFixup	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
first$ = 48
tmp$1 = 52
size$ = 56
vsize$ = 60
curr$ = 64
dir$2 = 72
memimage$ = 96
GetImageSize PROC

; 388  : {

	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 88					; 00000058H

; 389  :     struct dsym *curr;
; 390  :     bool first;
; 391  :     uint_32 vsize = 0;

	mov	DWORD PTR vsize$[rsp], 0

; 392  :     uint_32 size = 0;

	mov	DWORD PTR size$[rsp], 0

; 393  : 
; 394  :     for( curr = SymTables[TAB_SEG].head, first = TRUE; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	mov	BYTE PTR first$[rsp], 1
	jmp	SHORT $LN4@GetImageSi
$LN2@GetImageSi:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@GetImageSi:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN3@GetImageSi

; 395  :         uint_32 tmp;
; 396  :         if ( curr->e.seginfo->segtype == SEGTYPE_ABS || curr->e.seginfo->info )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 5
	je	SHORT $LN9@GetImageSi
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@GetImageSi
$LN9@GetImageSi:

; 397  :             continue;

	jmp	SHORT $LN2@GetImageSi
$LN8@GetImageSi:

; 398  :         if ( memimage == FALSE ) {

	movzx	eax, BYTE PTR memimage$[rsp]
	test	eax, eax
	jne	SHORT $LN10@GetImageSi

; 399  :             if ( curr->e.seginfo->bytes_written == 0 ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN11@GetImageSi

; 400  :                 struct dsym *dir;
; 401  :                 for ( dir = curr->next; dir; dir = dir->next )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR dir$2[rsp], rax
	jmp	SHORT $LN7@GetImageSi
$LN5@GetImageSi:
	mov	rax, QWORD PTR dir$2[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR dir$2[rsp], rax
$LN7@GetImageSi:
	cmp	QWORD PTR dir$2[rsp], 0
	je	SHORT $LN6@GetImageSi

; 402  :                     if ( dir->e.seginfo->bytes_written )

	mov	rax, QWORD PTR dir$2[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+24], 0
	je	SHORT $LN12@GetImageSi

; 403  :                         break;

	jmp	SHORT $LN6@GetImageSi
$LN12@GetImageSi:
	jmp	SHORT $LN5@GetImageSi
$LN6@GetImageSi:

; 404  :                 if ( !dir )

	cmp	QWORD PTR dir$2[rsp], 0
	jne	SHORT $LN13@GetImageSi

; 405  :                     break; /* done, skip rest of segments! */

	jmp	$LN3@GetImageSi
$LN13@GetImageSi:
$LN11@GetImageSi:
$LN10@GetImageSi:

; 406  :             }
; 407  :         }
; 408  :         tmp = curr->e.seginfo->fileoffset + (curr->sym.max_offset - curr->e.seginfo->start_loc );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	edx, DWORD PTR [rdx+56]
	sub	edx, ecx
	mov	ecx, edx
	add	ecx, DWORD PTR [rax+56]
	mov	eax, ecx
	mov	DWORD PTR tmp$1[rsp], eax

; 409  :         if ( first == FALSE )

	movzx	eax, BYTE PTR first$[rsp]
	test	eax, eax
	jne	SHORT $LN14@GetImageSi

; 410  :             vsize += curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR vsize$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vsize$[rsp], eax
$LN14@GetImageSi:

; 411  :         if ( memimage )

	movzx	eax, BYTE PTR memimage$[rsp]
	test	eax, eax
	je	SHORT $LN15@GetImageSi

; 412  :             tmp += vsize;

	mov	eax, DWORD PTR vsize$[rsp]
	mov	ecx, DWORD PTR tmp$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tmp$1[rsp], eax
$LN15@GetImageSi:

; 413  :         DebugMsg(("GetImageSize(%s): fileofs=%" I32_SPEC "Xh, max_offs=%" I32_SPEC "Xh start=%" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR curr$[rsp]
	mov	r9d, DWORD PTR [rax+56]
	mov	r8d, DWORD PTR [rcx+56]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11816
	call	DoDebugMsg

; 414  :                   curr->sym.name, curr->e.seginfo->fileoffset, curr->sym.max_offset, curr->e.seginfo->start_loc ));
; 415  :         if ( size < tmp )

	mov	eax, DWORD PTR tmp$1[rsp]
	cmp	DWORD PTR size$[rsp], eax
	jae	SHORT $LN16@GetImageSi

; 416  :             size = tmp;

	mov	eax, DWORD PTR tmp$1[rsp]
	mov	DWORD PTR size$[rsp], eax
$LN16@GetImageSi:

; 417  :         first = FALSE;

	mov	BYTE PTR first$[rsp], 0

; 418  :     }

	jmp	$LN2@GetImageSi
$LN3@GetImageSi:

; 419  :     DebugMsg(("GetImageSize(%u)=%" I32_SPEC "Xh\n", memimage, size ));

	movzx	eax, BYTE PTR memimage$[rsp]
	mov	r8d, DWORD PTR size$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11818
	call	DoDebugMsg

; 420  :     return( size );

	mov	eax, DWORD PTR size$[rsp]

; 421  : }

	add	rsp, 88					; 00000058H
	ret	0
GetImageSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
valueseg$ = 64
valueofs$ = 68
loc$ = 72
count$ = 76
tv79 = 80
tv172 = 84
curr$ = 88
fixup$ = 96
pDst$ = 128
GetSegRelocs PROC

; 324  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 325  :     struct dsym *curr;
; 326  :     int count = 0;

	mov	DWORD PTR count$[rsp], 0

; 327  :     uint_16 valueofs;
; 328  :     uint_16 valueseg;
; 329  :     uint_32 loc;
; 330  :     struct fixup *fixup;
; 331  : 
; 332  :     DebugMsg(("GetSegRelocs( %p ) enter\n", pDst ));

	mov	rdx, QWORD PTR pDst$[rsp]
	lea	rcx, OFFSET FLAT:$SG11780
	call	DoDebugMsg

; 333  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@GetSegRelo
$LN2@GetSegRelo:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@GetSegRelo:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN3@GetSegRelo

; 334  :         if ( curr->e.seginfo->segtype == SEGTYPE_ABS )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 5
	jne	SHORT $LN12@GetSegRelo

; 335  :             continue;

	jmp	SHORT $LN2@GetSegRelo
$LN12@GetSegRelo:

; 336  :         for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR fixup$[rsp], rax
	jmp	SHORT $LN7@GetSegRelo
$LN5@GetSegRelo:
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR fixup$[rsp], rax
$LN7@GetSegRelo:
	cmp	QWORD PTR fixup$[rsp], 0
	je	$LN6@GetSegRelo

; 337  :             switch ( fixup->type ) {

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv79[rsp], eax
	cmp	DWORD PTR tv79[rsp], 8
	jl	$LN8@GetSegRelo
	cmp	DWORD PTR tv79[rsp], 10
	jle	SHORT $LN13@GetSegRelo
	jmp	$LN8@GetSegRelo
$LN13@GetSegRelo:

; 338  :             case FIX_PTR32:
; 339  :             case FIX_PTR16:
; 340  :             case FIX_SEG:
; 341  :                 /* ignore fixups for absolute segments */
; 342  :                 if ( fixup->sym && fixup->sym->segment && ((struct dsym *)fixup->sym->segment)->e.seginfo->segtype == SEGTYPE_ABS )

	mov	rax, QWORD PTR fixup$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN14@GetSegRelo
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN14@GetSegRelo
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 5
	jne	SHORT $LN14@GetSegRelo

; 343  :                     break;

	jmp	$LN8@GetSegRelo
$LN14@GetSegRelo:

; 344  :                 DebugMsg(("GetSegRelocs: found seg-related fixup at %s.%" I32_SPEC "X\n", curr->sym.name, fixup->locofs ));

	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11784
	call	DoDebugMsg

; 345  :                 count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax

; 346  :                 if ( pDst ) {

	cmp	QWORD PTR pDst$[rsp], 0
	je	$LN15@GetSegRelo

; 347  :                     /* v2.04: fixed */
; 348  :                     loc = fixup->locofs + ( curr->e.seginfo->start_offset & 0xf );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	and	eax, 15
	mov	rcx, QWORD PTR fixup$[rsp]
	add	eax, DWORD PTR [rcx+20]
	mov	DWORD PTR loc$[rsp], eax

; 349  :                     valueseg = curr->e.seginfo->start_offset >> 4;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+12]
	shr	eax, 4
	mov	WORD PTR valueseg$[rsp], ax

; 350  :                     if ( curr->e.seginfo->group ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN16@GetSegRelo

; 351  :                         loc += curr->e.seginfo->group->offset & 0xf;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 15
	mov	ecx, DWORD PTR loc$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR loc$[rsp], eax

; 352  :                         valueseg += curr->e.seginfo->group->offset >> 4;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+16]
	sar	eax, 4
	movzx	ecx, WORD PTR valueseg$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	WORD PTR valueseg$[rsp], ax
$LN16@GetSegRelo:

; 353  :                     }
; 354  :                     if ( fixup->type == FIX_PTR16 )

	mov	rax, QWORD PTR fixup$[rsp]
	cmp	DWORD PTR [rax+24], 9
	jne	SHORT $LN17@GetSegRelo

; 355  :                         loc += 2;

	mov	eax, DWORD PTR loc$[rsp]
	add	eax, 2
	mov	DWORD PTR loc$[rsp], eax
	jmp	SHORT $LN18@GetSegRelo
$LN17@GetSegRelo:

; 356  :                     else if ( fixup->type == FIX_PTR32 )

	mov	rax, QWORD PTR fixup$[rsp]
	cmp	DWORD PTR [rax+24], 10
	jne	SHORT $LN19@GetSegRelo

; 357  :                         loc += 4;

	mov	eax, DWORD PTR loc$[rsp]
	add	eax, 4
	mov	DWORD PTR loc$[rsp], eax
$LN19@GetSegRelo:
$LN18@GetSegRelo:
$LN10@GetSegRelo:

; 358  : 
; 359  :                     /* offset may be > 64 kB */
; 360  :                     while ( loc >= 0x10000 ) {

	cmp	DWORD PTR loc$[rsp], 65536		; 00010000H
	jb	SHORT $LN11@GetSegRelo

; 361  :                         loc -= 16;

	mov	eax, DWORD PTR loc$[rsp]
	sub	eax, 16
	mov	DWORD PTR loc$[rsp], eax

; 362  :                         valueseg++;

	movzx	eax, WORD PTR valueseg$[rsp]
	inc	ax
	mov	WORD PTR valueseg$[rsp], ax

; 363  :                     };

	jmp	SHORT $LN10@GetSegRelo
$LN11@GetSegRelo:

; 364  : 
; 365  :                     valueofs = loc;

	movzx	eax, WORD PTR loc$[rsp]
	mov	WORD PTR valueofs$[rsp], ax

; 366  :                     DebugMsg(("GetSegRelocs: locofs=%" I32_SPEC "X fileofs=%" I32_SPEC "X segofs=%" I32_SPEC "X grpofs=%" I32_SPEC "X, fixup value: %X %X\n",

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN21@GetSegRelo
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv172[rsp], eax
	jmp	SHORT $LN22@GetSegRelo
$LN21@GetSegRelo:
	mov	DWORD PTR tv172[rsp], 0
$LN22@GetSegRelo:
	movzx	eax, WORD PTR valueseg$[rsp]
	movzx	ecx, WORD PTR valueofs$[rsp]
	mov	rdx, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rdx+96]
	mov	r8, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [r8+96]
	mov	DWORD PTR [rsp+48], eax
	mov	DWORD PTR [rsp+40], ecx
	mov	eax, DWORD PTR tv172[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR [rdx+12]
	mov	r8d, DWORD PTR [r8+56]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	edx, DWORD PTR [rax+20]
	lea	rcx, OFFSET FLAT:$SG11790
	call	DoDebugMsg

; 367  :                               fixup->locofs, curr->e.seginfo->fileoffset, curr->e.seginfo->start_offset, curr->e.seginfo->group ? curr->e.seginfo->group->offset: 0, valueofs, valueseg ));
; 368  :                     *pDst++ = valueofs;

	mov	rax, QWORD PTR pDst$[rsp]
	movzx	ecx, WORD PTR valueofs$[rsp]
	mov	WORD PTR [rax], cx
	mov	rax, QWORD PTR pDst$[rsp]
	add	rax, 2
	mov	QWORD PTR pDst$[rsp], rax

; 369  :                     *pDst++ = valueseg;

	mov	rax, QWORD PTR pDst$[rsp]
	movzx	ecx, WORD PTR valueseg$[rsp]
	mov	WORD PTR [rax], cx
	mov	rax, QWORD PTR pDst$[rsp]
	add	rax, 2
	mov	QWORD PTR pDst$[rsp], rax
$LN15@GetSegRelo:
$LN8@GetSegRelo:

; 370  :                 }
; 371  :                 break;
; 372  :             }
; 373  :         }

	jmp	$LN5@GetSegRelo
$LN6@GetSegRelo:

; 374  :     }

	jmp	$LN2@GetSegRelo
$LN3@GetSegRelo:

; 375  :     DebugMsg(("GetSegRelocs()=%u\n", count ));

	mov	edx, DWORD PTR count$[rsp]
	lea	rcx, OFFSET FLAT:$SG11791
	call	DoDebugMsg

; 376  :     return( count );

	mov	eax, DWORD PTR count$[rsp]

; 377  : }

	add	rsp, 120				; 00000078H
	ret	0
GetSegRelocs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
offset$ = 64
align$ = 68
alignbytes$ = 72
tv297 = 76
tv301 = 80
grp$ = 88
curr$ = 112
cp$ = 120
CalcOffset PROC

; 209  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 210  :     uint_32 align;
; 211  :     uint_32 alignbytes;
; 212  :     uint_32 offset;
; 213  :     struct dsym *grp;
; 214  : 
; 215  :     if ( curr->e.seginfo->segtype == SEGTYPE_ABS ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 5
	jne	SHORT $LN2@CalcOffset

; 216  :         curr->e.seginfo->start_offset = curr->e.seginfo->abs_frame << 4;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, WORD PTR [rax+88]
	shl	eax, 4
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+12], eax

; 217  :         DebugMsg(("CalcOffset(%s): abs seg, offset=%" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	r8d, DWORD PTR [rax+12]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11735
	call	DoDebugMsg

; 218  :                   curr->sym.name, curr->e.seginfo->start_offset ));
; 219  :         return;

	jmp	$LN1@CalcOffset
	jmp	SHORT $LN3@CalcOffset
$LN2@CalcOffset:

; 220  :     } else if ( curr->e.seginfo->info )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@CalcOffset

; 221  :         return;

	jmp	$LN1@CalcOffset
$LN4@CalcOffset:
$LN3@CalcOffset:

; 222  : 
; 223  :     grp = (struct dsym *)curr->e.seginfo->group;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR grp$[rsp], rax

; 224  :     if ( cp->alignment > curr->e.seginfo->alignment )

	mov	rax, QWORD PTR cp$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	movzx	ecx, BYTE PTR [rcx+106]
	cmp	eax, ecx
	jle	SHORT $LN5@CalcOffset

; 225  :         align = 1 << cp->alignment;

	mov	rax, QWORD PTR cp$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	ecx, 1
	mov	DWORD PTR tv297[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv297[rsp]
	shl	eax, cl
	mov	DWORD PTR align$[rsp], eax
	jmp	SHORT $LN6@CalcOffset
$LN5@CalcOffset:

; 226  :     else
; 227  :         align = 1 << curr->e.seginfo->alignment;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+106]
	mov	ecx, 1
	mov	DWORD PTR tv301[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv301[rsp]
	shl	eax, cl
	mov	DWORD PTR align$[rsp], eax
$LN6@CalcOffset:

; 228  :     //alignbytes = ((offset + (align - 1)) & (-align)) - offset;
; 229  :     alignbytes = ((cp->fileoffset + (align - 1)) & (-align)) - cp->fileoffset;

	mov	rax, QWORD PTR cp$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	ecx, DWORD PTR align$[rsp]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	ecx, DWORD PTR align$[rsp]
	neg	ecx
	and	eax, ecx
	mov	rcx, QWORD PTR cp$[rsp]
	sub	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR alignbytes$[rsp], eax

; 230  :     cp->fileoffset += alignbytes;

	mov	rax, QWORD PTR cp$[rsp]
	mov	eax, DWORD PTR [rax+4]
	add	eax, DWORD PTR alignbytes$[rsp]
	mov	rcx, QWORD PTR cp$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 231  : 
; 232  :     if ( grp == NULL ) {

	cmp	QWORD PTR grp$[rsp], 0
	jne	SHORT $LN7@CalcOffset

; 233  :         offset = cp->fileoffset - cp->sizehdr;  // + alignbytes;

	mov	rax, QWORD PTR cp$[rsp]
	mov	rcx, QWORD PTR cp$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+4]
	sub	eax, ecx
	mov	DWORD PTR offset$[rsp], eax

; 234  :         DebugMsg(("CalcOffset(%s): fileofs=%" I32_SPEC "Xh, ofs=%" I32_SPEC "Xh\n", curr->sym.name, cp->fileoffset, offset ));

	mov	r9d, DWORD PTR offset$[rsp]
	mov	rax, QWORD PTR cp$[rsp]
	mov	r8d, DWORD PTR [rax+4]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11741
	call	DoDebugMsg

; 235  :     } else {

	jmp	$LN8@CalcOffset
$LN7@CalcOffset:

; 236  : #if PE_SUPPORT
; 237  :         if ( ModuleInfo.sub_format == SFORMAT_PE )

	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN9@CalcOffset

; 238  :             offset = cp->rva;

	mov	rax, QWORD PTR cp$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR offset$[rsp], eax
	jmp	SHORT $LN10@CalcOffset
$LN9@CalcOffset:

; 239  :         else
; 240  : #endif
; 241  :             if ( grp->sym.total_size == 0 ) {

	mov	rax, QWORD PTR grp$[rsp]
	cmp	DWORD PTR [rax+56], 0
	jne	SHORT $LN11@CalcOffset

; 242  :                 grp->sym.offset = cp->fileoffset - cp->sizehdr;

	mov	rax, QWORD PTR cp$[rsp]
	mov	rcx, QWORD PTR cp$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+4]
	sub	eax, ecx
	mov	rcx, QWORD PTR grp$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 243  :                 offset = 0;

	mov	DWORD PTR offset$[rsp], 0

; 244  :             } else

	jmp	SHORT $LN12@CalcOffset
$LN11@CalcOffset:

; 245  :                 offset = grp->sym.total_size + alignbytes;

	mov	rax, QWORD PTR grp$[rsp]
	mov	eax, DWORD PTR [rax+56]
	add	eax, DWORD PTR alignbytes$[rsp]
	mov	DWORD PTR offset$[rsp], eax
$LN12@CalcOffset:
$LN10@CalcOffset:

; 246  :         DebugMsg(("CalcOffset(%s): fileofs=%" I32_SPEC "Xh, alignbytes=%" I32_SPEC "u, ofs=%" I32_SPEC "Xh, group=%s, grp.ofs=%" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR grp$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR grp$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR alignbytes$[rsp]
	mov	rax, QWORD PTR cp$[rsp]
	mov	r8d, DWORD PTR [rax+4]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11746
	call	DoDebugMsg
$LN8@CalcOffset:

; 247  :                   curr->sym.name, cp->fileoffset, alignbytes, offset, grp->sym.name, grp->sym.offset ));
; 248  :     }
; 249  : 
; 250  :     /* v2.04: added */
; 251  :     /* v2.05: this addition did mess sample Win32_5.asm, because the
; 252  :      * "empty" alignment sections are now added to <fileoffset>.
; 253  :      * todo: VA in binary map is displayed wrong.
; 254  :      */
; 255  :     if ( cp->first == FALSE ) {

	mov	rax, QWORD PTR cp$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN13@CalcOffset

; 256  :         /* v2.05: do the reset more carefully.
; 257  :          * Do reset start_loc only if
; 258  :          * - segment is in a group and
; 259  :          * - group isn't FLAT or segment's name contains '$'
; 260  :          */
; 261  :         if ( grp && ( grp != ModuleInfo.flat_grp ||

	cmp	QWORD PTR grp$[rsp], 0
	je	SHORT $LN14@CalcOffset
	mov	rax, QWORD PTR ModuleInfo+440
	cmp	QWORD PTR grp$[rsp], rax
	jne	SHORT $LN15@CalcOffset
	mov	edx, 36					; 00000024H
	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	strchr
	test	rax, rax
	je	SHORT $LN14@CalcOffset
$LN15@CalcOffset:

; 262  :                      strchr( curr->sym.name, '$' ) ) )
; 263  :             curr->e.seginfo->start_loc = 0;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+8], 0
$LN14@CalcOffset:
$LN13@CalcOffset:

; 264  :     }
; 265  : 
; 266  :     curr->e.seginfo->fileoffset = cp->fileoffset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR cp$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	mov	DWORD PTR [rax+56], ecx

; 267  :     curr->e.seginfo->start_offset = offset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rax+12], ecx

; 268  : 
; 269  :     //if ( cp->first && ModuleInfo.sub_format == SFORMAT_NONE ) {
; 270  :     if ( ModuleInfo.sub_format == SFORMAT_NONE ) {

	cmp	DWORD PTR ModuleInfo+372, 0
	jne	SHORT $LN16@CalcOffset

; 271  :         cp->fileoffset += curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR [rcx+56]
	sub	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR cp$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	rcx, QWORD PTR cp$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 272  :         if ( cp->first )

	mov	rax, QWORD PTR cp$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN18@CalcOffset

; 273  :             cp->imagestart = curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR cp$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rcx+24], eax
$LN18@CalcOffset:

; 274  :         /* there's no real entry address for BIN, therefore the
; 275  :          start label must be at the very beginning of the file */
; 276  :         if ( cp->entryoffset == -1 ) {

	mov	rax, QWORD PTR cp$[rsp]
	cmp	DWORD PTR [rax+12], -1			; ffffffffH
	jne	SHORT $LN19@CalcOffset

; 277  :             cp->entryoffset = offset;

	mov	rax, QWORD PTR cp$[rsp]
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rax+12], ecx

; 278  :             cp->entryseg = (struct asym *)curr;

	mov	rax, QWORD PTR cp$[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	QWORD PTR [rax+16], rcx
$LN19@CalcOffset:

; 279  :         }
; 280  :     } else {

	jmp	SHORT $LN17@CalcOffset
$LN16@CalcOffset:

; 281  :         /* v2.05: changed, removed */
; 282  :         //curr->e.seginfo->fileoffset += curr->e.seginfo->start_loc;
; 283  :         //fileoffset += curr->sym.max_offset;
; 284  : #if PE_SUPPORT
; 285  :         cp->rva += curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR [rcx+56]
	sub	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR cp$[rsp]
	add	eax, DWORD PTR [rcx+28]
	mov	rcx, QWORD PTR cp$[rsp]
	mov	DWORD PTR [rcx+28], eax

; 286  :         if ( curr->e.seginfo->segtype == SEGTYPE_BSS )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 3
	jne	SHORT $LN20@CalcOffset

; 287  :             ;

	jmp	SHORT $LN21@CalcOffset
$LN20@CalcOffset:

; 288  :         else
; 289  : #endif
; 290  :         cp->fileoffset += curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR [rcx+56]
	sub	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR cp$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	rcx, QWORD PTR cp$[rsp]
	mov	DWORD PTR [rcx+4], eax
$LN21@CalcOffset:
$LN17@CalcOffset:

; 291  :     }
; 292  : 
; 293  :     //offset += curr->sym.max_offset - curr->e.seginfo->start_loc;
; 294  :     offset += curr->sym.max_offset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	ecx, DWORD PTR offset$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR offset$[rsp], eax

; 295  :     if ( grp ) {

	cmp	QWORD PTR grp$[rsp], 0
	je	SHORT $LN22@CalcOffset

; 296  :         //grp->sym.total_size = offset + curr->e.seginfo->start_loc;
; 297  :         grp->sym.total_size = offset;

	mov	rax, QWORD PTR grp$[rsp]
	mov	ecx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rax+56], ecx

; 298  :         /* v2.07: for 16-bit groups, ensure that it fits in 64 kB */
; 299  :         if ( grp->sym.total_size > 0x10000 && grp->sym.Ofssize == USE16 ) {

	mov	rax, QWORD PTR grp$[rsp]
	cmp	DWORD PTR [rax+56], 65536		; 00010000H
	jbe	SHORT $LN23@CalcOffset
	mov	rax, QWORD PTR grp$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	test	eax, eax
	jne	SHORT $LN23@CalcOffset

; 300  :             EmitWarn( 2, GROUP_EXCEEDS_64K, grp->sym.name );

	mov	rax, QWORD PTR grp$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 276				; 00000114H
	mov	ecx, 2
	call	EmitWarn
$LN23@CalcOffset:
$LN22@CalcOffset:

; 301  :         }
; 302  :     }
; 303  : #if PE_SUPPORT
; 304  :     DebugMsg(("CalcOffset(%s) exit: seg.fileofs=%" I32_SPEC "Xh, seg.start_offset=%" I32_SPEC "Xh, endofs=%" I32_SPEC "Xh fileofs=%" I32_SPEC "Xh rva=%" I32_SPEC "Xh\n",

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rdx, QWORD PTR cp$[rsp]
	mov	edx, DWORD PTR [rdx+28]
	mov	DWORD PTR [rsp+48], edx
	mov	rdx, QWORD PTR cp$[rsp]
	mov	edx, DWORD PTR [rdx+4]
	mov	DWORD PTR [rsp+40], edx
	mov	edx, DWORD PTR offset$[rsp]
	mov	DWORD PTR [rsp+32], edx
	mov	r9d, DWORD PTR [rax+12]
	mov	r8d, DWORD PTR [rcx+56]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11758
	call	DoDebugMsg

; 305  :               curr->sym.name, curr->e.seginfo->fileoffset, curr->e.seginfo->start_offset, offset, cp->fileoffset, cp->rva ));
; 306  : #else
; 307  :     DebugMsg(("CalcOffset(%s) exit: seg.fileofs=%" I32_SPEC "Xh, seg.start_offset=%" I32_SPEC "Xh, endofs=%" I32_SPEC "Xh fileofs=%" I32_SPEC "Xh\n",
; 308  :               curr->sym.name, curr->e.seginfo->fileoffset, curr->e.seginfo->start_offset, offset, cp->fileoffset ));
; 309  : #endif
; 310  : 
; 311  :     cp->first = FALSE;

	mov	rax, QWORD PTR cp$[rsp]
	mov	BYTE PTR [rax], 0
$LN1@CalcOffset:

; 312  :     return;
; 313  : }

	add	rsp, 104				; 00000068H
	ret	0
CalcOffset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
size$ = 48
tv165 = 52
pehdr$ = 56
sym$ = 64
p$ = 72
pe_create_PE_header PROC

; 746  : {

$LN13:
	sub	rsp, 88					; 00000058H

; 747  :     struct asym *sym;
; 748  :     struct dsym *pehdr;
; 749  :     int size;
; 750  :     void *p;
; 751  : 
; 752  :     DebugMsg(("pe_create_PE_header enter\n" ));

	lea	rcx, OFFSET FLAT:$SG11987
	call	DoDebugMsg

; 753  :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN2@pe_create_

; 754  :         if ( ModuleInfo.model != MODEL_FLAT ) {

	cmp	DWORD PTR ModuleInfo+360, 7
	je	SHORT $LN3@pe_create_

; 755  :             EmitError( MODEL_MUST_BE_FLAT );

	mov	ecx, 211				; 000000d3H
	call	EmitError
$LN3@pe_create_:

; 756  :         }
; 757  : #if AMD64_SUPPORT
; 758  :         if ( ModuleInfo.defOfssize == USE64 ) {

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN4@pe_create_

; 759  :             size = sizeof( struct IMAGE_PE_HEADER64 );

	mov	DWORD PTR size$[rsp], 264		; 00000108H

; 760  :             p = (void *)&pe64def;

	lea	rax, OFFSET FLAT:pe64def
	mov	QWORD PTR p$[rsp], rax

; 761  :         } else {

	jmp	SHORT $LN5@pe_create_
$LN4@pe_create_:

; 762  : #endif
; 763  :             size = sizeof( struct IMAGE_PE_HEADER32 );

	mov	DWORD PTR size$[rsp], 248		; 000000f8H

; 764  :             p = (void *)&pe32def;

	lea	rax, OFFSET FLAT:pe32def
	mov	QWORD PTR p$[rsp], rax
$LN5@pe_create_:

; 765  : #if AMD64_SUPPORT
; 766  :         }
; 767  : #endif
; 768  :         pehdr = ( struct dsym *)SymSearch( hdrname "2" );

	lea	rcx, OFFSET FLAT:$SG11992
	call	SymFind
	mov	QWORD PTR pehdr$[rsp], rax

; 769  :         if ( pehdr == NULL ) {

	cmp	QWORD PTR pehdr$[rsp], 0
	jne	$LN6@pe_create_

; 770  :             pehdr = (struct dsym *)CreateIntSegment( hdrname "2", "HDR", 2, ModuleInfo.defOfssize, TRUE );

	mov	BYTE PTR [rsp+32], 1
	movzx	r9d, BYTE PTR ModuleInfo+405
	mov	r8b, 2
	lea	rdx, OFFSET FLAT:$SG11995
	lea	rcx, OFFSET FLAT:$SG11996
	call	CreateIntSegment
	mov	QWORD PTR pehdr$[rsp], rax

; 771  :             pehdr->e.seginfo->group = &ModuleInfo.flat_grp->sym;

	mov	rax, QWORD PTR ModuleInfo+440
	mov	rcx, QWORD PTR pehdr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx], rax

; 772  :             pehdr->e.seginfo->combine = COMB_ADDOFF;  /* PUBLIC */

	mov	rax, QWORD PTR pehdr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+108]
	and	al, 248					; 000000f8H
	or	al, 2
	mov	rcx, QWORD PTR pehdr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+108], al

; 773  :             pehdr->e.seginfo->characteristics = (IMAGE_SCN_MEM_READ >> 24);

	mov	rax, QWORD PTR pehdr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rax+105], 64			; 00000040H

; 774  :             pehdr->e.seginfo->readonly = 1;

	mov	rax, QWORD PTR pehdr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 1
	mov	rcx, QWORD PTR pehdr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+107], al

; 775  :             pehdr->e.seginfo->bytes_written = size; /* ensure that ORG won't set start_loc (assemble.c, SetCurrOffset) */

	mov	rax, QWORD PTR pehdr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR size$[rsp]
	mov	DWORD PTR [rax+24], ecx

; 776  :             pehdr->sym.max_offset = size;

	mov	rax, QWORD PTR pehdr$[rsp]
	mov	ecx, DWORD PTR size$[rsp]
	mov	DWORD PTR [rax+56], ecx

; 777  :         } else {

	jmp	SHORT $LN7@pe_create_
$LN6@pe_create_:

; 778  :             if ( pehdr->sym.max_offset < size )

	mov	rax, QWORD PTR pehdr$[rsp]
	mov	ecx, DWORD PTR size$[rsp]
	cmp	DWORD PTR [rax+56], ecx
	jge	SHORT $LN8@pe_create_

; 779  :                 pehdr->sym.max_offset = size;

	mov	rax, QWORD PTR pehdr$[rsp]
	mov	ecx, DWORD PTR size$[rsp]
	mov	DWORD PTR [rax+56], ecx
$LN8@pe_create_:

; 780  :             pehdr->e.seginfo->internal = TRUE;

	mov	rax, QWORD PTR pehdr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 16
	mov	rcx, QWORD PTR pehdr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	BYTE PTR [rcx+107], al

; 781  :             pehdr->e.seginfo->start_loc = 0;

	mov	rax, QWORD PTR pehdr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+8], 0
$LN7@pe_create_:

; 782  :         }
; 783  :         pehdr->e.seginfo->segtype = SEGTYPE_HDR;

	mov	rax, QWORD PTR pehdr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+72], 6

; 784  :         pehdr->e.seginfo->CodeBuffer = LclAlloc( size );

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR pehdr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx+16], rax

; 785  :         memcpy( pehdr->e.seginfo->CodeBuffer, p, size );

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR pehdr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	r8, rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	call	memcpy

; 786  : #if 0 //def __UNIX__
; 787  :         time((int_32 *)(pehdr->e.seginfo->CodeBuffer+offsetof( struct IMAGE_PE_HEADER32, FileHeader.TimeDateStamp )));
; 788  : #else
; 789  :         time((time_t *)(pehdr->e.seginfo->CodeBuffer+offsetof( struct IMAGE_PE_HEADER32, FileHeader.TimeDateStamp )));

	mov	rax, QWORD PTR pehdr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	add	rax, 8
	mov	rcx, rax
	call	time

; 790  : #endif
; 791  :         sym = CreateVariable( "@pe_file_flags", ((struct IMAGE_PE_HEADER32 *)p)->FileHeader.Characteristics );

	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, WORD PTR [rax+22]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11998
	call	CreateVariable
	mov	QWORD PTR sym$[rsp], rax

; 792  :         if ( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN9@pe_create_

; 793  :             DebugMsg(("pe_create_PE_header: CreateVariable(@pe_file_flags)=%X [value=%X]\n", sym, sym ? sym->value : 0 ));

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN11@pe_create_
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv165[rsp], eax
	jmp	SHORT $LN12@pe_create_
$LN11@pe_create_:
	mov	DWORD PTR tv165[rsp], 0
$LN12@pe_create_:
	mov	r8d, DWORD PTR tv165[rsp]
	mov	rdx, QWORD PTR sym$[rsp]
	lea	rcx, OFFSET FLAT:$SG12000
	call	DoDebugMsg

; 794  :             sym->predefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 795  :             sym->sfunc_ptr = (internal_func)&set_file_flags;

	mov	rax, QWORD PTR sym$[rsp]
	lea	rcx, OFFSET FLAT:set_file_flags
	mov	QWORD PTR [rax+64], rcx
$LN9@pe_create_:
$LN2@pe_create_:

; 796  :         }
; 797  :     }
; 798  : }

	add	rsp, 88					; 00000058H
	ret	0
pe_create_PE_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
_TEXT	SEGMENT
tv67 = 32
modinfo$ = 64
bin_init PROC

; 1833 : {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1834 :     modinfo->g.WriteModule = bin_write_module;

	mov	rax, QWORD PTR modinfo$[rsp]
	lea	rcx, OFFSET FLAT:bin_write_module
	mov	QWORD PTR [rax+288], rcx

; 1835 :     modinfo->g.Pass1Checks = bin_check_external;

	mov	rax, QWORD PTR modinfo$[rsp]
	lea	rcx, OFFSET FLAT:bin_check_external
	mov	QWORD PTR [rax+304], rcx

; 1836 :     switch ( modinfo->sub_format ) {

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	eax, DWORD PTR [rax+372]
	mov	DWORD PTR tv67[rsp], eax
	cmp	DWORD PTR tv67[rsp], 1
	je	SHORT $LN4@bin_init
	cmp	DWORD PTR tv67[rsp], 2
	je	SHORT $LN5@bin_init
	jmp	SHORT $LN2@bin_init
$LN4@bin_init:

; 1837 : #if MZ_SUPPORT
; 1838 :     case SFORMAT_MZ:
; 1839 :         memcpy( &modinfo->mz_data, &mzdata, sizeof( struct MZDATA ) );

	mov	rax, QWORD PTR modinfo$[rsp]
	add	rax, 412				; 0000019cH
	mov	r8d, 8
	lea	rdx, OFFSET FLAT:mzdata
	mov	rcx, rax
	call	memcpy

; 1840 :         break;

	jmp	SHORT $LN2@bin_init
$LN5@bin_init:

; 1841 : #endif
; 1842 : #if PE_SUPPORT
; 1843 :     case SFORMAT_PE:
; 1844 :         modinfo->g.EndDirHook = pe_enddirhook; /* v2.11 */

	mov	rax, QWORD PTR modinfo$[rsp]
	lea	rcx, OFFSET FLAT:pe_enddirhook
	mov	QWORD PTR [rax+296], rcx
$LN2@bin_init:

; 1845 :         break;
; 1846 : #endif
; 1847 :     }
; 1848 :     return;
; 1849 : }

	add	rsp, 56					; 00000038H
	ret	0
bin_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 534  :         {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 535  :             return _time64(_Time);

	mov	rcx, QWORD PTR _Time$[rsp]
	call	_time64

; 536  :         }

	add	rsp, 40					; 00000028H
	ret	0
time	ENDP
_TEXT	ENDS
END
