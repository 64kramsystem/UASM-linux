; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG10775 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG10712 DB	'jumpExtend(far=%u), pass=%u, curr offset=%X, Ofssize=%u', 0aH
	DB	00H
	ORG $+3
$SG10771 DB	'NULL', 00H
	ORG $+7
$SG10772 DB	'process_branch(%X): segment override %s', 0aH, 00H
	ORG $+7
$SG10777 DB	'process_branch(%X): segment override %s caused FAR jmp/c'
	DB	'all', 0aH, 00H
	ORG $+3
$SG10779 DB	'process_branch(%X): sym=NULL, op.memtype=%Xh', 0aH, 00H
	ORG $+2
$SG10780 DB	'NULL', 00H
	ORG $+3
$SG10781 DB	'process_branch(%X, %s): opnd.explicit=%u/memtype=%X/Ofss'
	DB	'ize=%u CI.memtype=%X sym.state=%u/mem_type=%Xh/ofs=%X/seg=%s', 0aH
	DB	00H
	ORG $+2
$SG10798 DB	'process_branch: error, opndx.mem_type is MT_NEAR', 0aH, 00H
	ORG $+6
$SG10783 DB	'process_branch(%s): EXTERNDEF assumed forward reference '
	DB	'(=SYM_UNDEFINED)', 0aH, 00H
	ORG $+6
$SG10800 DB	'process_branch(%s): error, unexpected symbol state=%u', 0aH
	DB	00H
	ORG $+1
$SG10808 DB	'process_branch: FAR call optimization applied!', 0aH, 00H
$SG10809 DB	'process_branch: step1: addr=%Xh', 0aH, 00H
	ORG $+7
$SG10813 DB	'process_branch: CI.memtype=%Xh addr=%Xh', 0aH, 00H
	ORG $+7
$SG10819 DB	'process_branch: jump out of range, mem_type=%Xh addr=%Xh'
	DB	0aH, 00H
	ORG $+6
$SG10830 DB	'process_branch: displacement=%X opnd_type=%X', 0aH, 00H
	ORG $+2
$SG10835 DB	'%u process_branch: CPU < 386 and Jcc distance != SHORT, '
	DB	'mem_type=%X, curr_ofs=%X, addr=%d', 0aH, 00H
	ORG $+5
$SG10837 DB	'process_branch: fixup needed', 0aH, 00H
	ORG $+2
$SG10842 DB	'process_branch: FAR call optimization applied!, seg=%X, '
	DB	'CurrSeg=%X, grps=%X/%X', 0aH, 00H
$SG10850 DB	'process_branch: unexpected mem_type %Xh', 0aH, 00H
	ORG $+7
$SG10851 DB	'branch.c', 00H
	ORG $+7
$SG10855 DB	'process_branch: FAR call/jmp', 0aH, 00H
	ORG $+2
$SG10865 DB	'process_branch: JMP/CALL far, unexpected mem_type=%X', 0aH
	DB	00H
	ORG $+2
$SG10866 DB	'branch.c', 00H
	ORG $+7
$SG10873 DB	'process_branch: JMP/CALL, CodeInfo->memtype=%X', 0aH, 00H
$SG10883 DB	'process_branch: JMP/CALL, unexpected mem_type=%X', 0aH, 00H
	ORG $+6
$SG10884 DB	'branch.c', 00H
	ORG $+7
$SG10900 DB	'process_branch: JMP/CALL, FAR memtype, jump extension', 0aH
	DB	00H
_DATA	ENDS
PUBLIC	process_branch
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	OutputByte:PROC
EXTRN	set_frame:PROC
EXTRN	CreateFixup:PROC
EXTRN	GetSymOfssize:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	GetOverrideAssume:PROC
EXTRN	InternalError:PROC
EXTRN	segm_override:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	InstrTable:BYTE
EXTRN	optable_idx:BYTE
EXTRN	SegOverride:QWORD
pdata	SEGMENT
$pdata$jumpExtend DD imagerel jumpExtend
	DD	imagerel jumpExtend+338
	DD	imagerel $unwind$jumpExtend
$pdata$FarCallToNear DD imagerel FarCallToNear
	DD	imagerel FarCallToNear+57
	DD	imagerel $unwind$FarCallToNear
$pdata$process_branch DD imagerel $LN174
	DD	imagerel $LN174+6274
	DD	imagerel $unwind$process_branch
pdata	ENDS
xdata	SEGMENT
$unwind$jumpExtend DD 010d01H
	DD	0a20dH
$unwind$FarCallToNear DD 010901H
	DD	04209H
$unwind$process_branch DD 021501H
	DD	0230115H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\branch.c
_TEXT	SEGMENT
addr$ = 96
fixup_type$ = 100
sym$ = 104
state$ = 112
fixup_option$ = 116
symseg$ = 120
mem_type$ = 128
tv553 = 132
tv727 = 136
tv839 = 140
tv373 = 144
tv450 = 148
tv488 = 152
tv571 = 156
tv584 = 160
tv605 = 164
tv604 = 168
tv607 = 172
tv634 = 176
tv656 = 180
tv663 = 184
tv684 = 188
tv730 = 192
tv744 = 196
tv758 = 200
tv782 = 204
tv795 = 208
tv821 = 212
tv820 = 216
tv823 = 220
opidx$ = 224
tv349 = 228
tv580 = 232
tv791 = 236
tv190 = 240
tv196 = 244
tv87 = 248
tv143 = 256
tv179 = 264
CodeInfo$ = 288
CurrOpnd$ = 296
opndx$ = 304
process_branch PROC

; 135  : {

$LN174:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 280				; 00000118H

; 136  :     int_32              addr;
; 137  :     enum fixup_types    fixup_type;
; 138  :     enum fixup_options  fixup_option;
; 139  :     enum sym_state      state;
; 140  :     struct asym         *sym;
; 141  :     enum memtype        mem_type;
; 142  :     struct dsym         *symseg;
; 143  :     unsigned            opidx = IndexFromToken( CodeInfo->token );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 455				; 000001c7H
	cdqe
	lea	rcx, OFFSET FLAT:optable_idx
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	DWORD PTR opidx$[rsp], eax

; 144  : 
; 145  :     /* v2.05: just 1 operand possible */
; 146  :     if ( CurrOpnd != OPND1 ) {

	cmp	DWORD PTR CurrOpnd$[rsp], 0
	je	SHORT $LN14@process_br

; 147  :         //EmitError( SYNTAX_ERROR ); /* v2.10: error msg changed */
; 148  :         return( EmitError( INVALID_INSTRUCTION_OPERANDS ) );

	mov	ecx, 49					; 00000031H
	call	EmitError
	jmp	$LN1@process_br
$LN14@process_br:

; 149  :     }
; 150  :     if ( opndx->explicit && opndx->instr != T_SHORT )

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN15@process_br
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 245			; 000000f5H
	je	SHORT $LN15@process_br

; 151  :         CodeInfo->mem_type = opndx->mem_type;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+28], ecx
$LN15@process_br:

; 152  :     /*
; 153  :      * Masm checks overrides for branch instructions with immediate operand!
; 154  :      * Of course, no segment prefix byte is emitted - would be pretty useless.
; 155  :      * It might cause the call/jmp to become FAR, though.
; 156  :      */
; 157  :     if ( opndx->override != NULL ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	$LN16@process_br

; 158  :         segm_override( opndx, NULL );

	xor	edx, edx
	mov	rcx, QWORD PTR opndx$[rsp]
	call	segm_override

; 159  :         DebugMsg(("process_branch(%" I32_SPEC "X): segment override %s\n", GetCurrOffset(), SegOverride ? SegOverride->name : "NULL" ));

	cmp	QWORD PTR SegOverride, 0
	je	SHORT $LN132@process_br
	mov	rax, QWORD PTR SegOverride
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv87[rsp], rax
	jmp	SHORT $LN133@process_br
$LN132@process_br:
	lea	rax, OFFSET FLAT:$SG10771
	mov	QWORD PTR tv87[rsp], rax
$LN133@process_br:
	call	GetCurrOffset
	mov	r8, QWORD PTR tv87[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG10772
	call	DoDebugMsg

; 160  :         if ( SegOverride && opndx->sym && opndx->sym->segment ) {

	cmp	QWORD PTR SegOverride, 0
	je	$LN17@process_br
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	$LN17@process_br
	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	QWORD PTR [rax+24], 0
	je	$LN17@process_br

; 161  :             if ( SegOverride != opndx->sym->segment &&  SegOverride != ((struct dsym *)opndx->sym->segment)->e.seginfo->group ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+24]
	cmp	QWORD PTR SegOverride, rax
	je	SHORT $LN18@process_br
	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR SegOverride, rax
	je	SHORT $LN18@process_br

; 162  :                 return( EmitErr( CANNOT_ACCESS_LABEL_THROUGH_SEGMENT_REGISTERS, opndx->sym ? opndx->sym->name : "" ) );

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN134@process_br
	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv143[rsp], rax
	jmp	SHORT $LN135@process_br
$LN134@process_br:
	lea	rax, OFFSET FLAT:$SG10775
	mov	QWORD PTR tv143[rsp], rax
$LN135@process_br:
	mov	rdx, QWORD PTR tv143[rsp]
	mov	ecx, 89					; 00000059H
	call	EmitErr
	jmp	$LN1@process_br
$LN18@process_br:

; 163  :             }
; 164  :             /* v2.05: switch to far jmp/call */
; 165  :             if ( SegOverride != &CurrSeg->sym && SegOverride != CurrSeg->e.seginfo->group ) {

	mov	rax, QWORD PTR ModuleInfo+432
	cmp	QWORD PTR SegOverride, rax
	je	SHORT $LN19@process_br
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR SegOverride, rax
	je	SHORT $LN19@process_br

; 166  :                 DebugMsg(("process_branch(%" I32_SPEC "X): segment override %s caused FAR jmp/call\n", GetCurrOffset(), SegOverride->name ));

	call	GetCurrOffset
	mov	rcx, QWORD PTR SegOverride
	mov	r8, QWORD PTR [rcx+8]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG10777
	call	DoDebugMsg

; 167  :                 //CodeInfo->isfar = TRUE;
; 168  :                 CodeInfo->mem_type = MT_FAR;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 130			; 00000082H
$LN19@process_br:
$LN17@process_br:
$LN16@process_br:

; 169  :             }
; 170  :         }
; 171  :     }
; 172  : 
; 173  :     CodeInfo->opnd[OPND1].data32l = opndx->value;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rdx, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+rax+40], edx

; 174  :     /* v2.06: make sure, that next bytes are cleared (for OP_I48)! */
; 175  :     CodeInfo->opnd[OPND1].data32h = 0;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+44], 0

; 176  :     sym = opndx->sym;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym$[rsp], rax

; 177  :     if( sym == NULL ) { /* no symbolic label specified? */

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN20@process_br

; 178  :         DebugMsg(("process_branch(%" I32_SPEC "X): sym=NULL, op.memtype=%Xh\n", GetCurrOffset(), opndx->mem_type ));

	call	GetCurrOffset
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR [rcx+64]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG10779
	call	DoDebugMsg

; 179  : 
; 180  :         /* Masm rejects: "jump dest must specify a label */
; 181  : #if NEEDLABEL
; 182  :         return( EmitError( JUMP_DESTINATION_MUST_SPECIFY_A_LABEL ) );

	mov	ecx, 249				; 000000f9H
	call	EmitError
	jmp	$LN1@process_br
$LN20@process_br:

; 183  : #else
; 184  :         if( IS_JMPCALL( CodeInfo->token ) )
; 185  :             CodeInfo->isfar = TRUE; /* ??? most likely nonsense! */
; 186  : 
; 187  :         if( CodeInfo->opnd[OPND1].data32l > USHRT_MAX )
; 188  :             CodeInfo->opnd[OPND1].type = OP_I32;
; 189  :         else
; 190  :             CodeInfo->opnd_type[OPND1] = OP_I16;
; 191  : 
; 192  :         return( NOT_ERROR );
; 193  : #endif
; 194  :     }
; 195  :     DebugMsg1(("process_branch(%" I32_SPEC "X, %s): opnd.explicit=%u/memtype=%X/Ofssize=%u CI.memtype=%X sym.state=%u/mem_type=%Xh/ofs=%" I32_SPEC "X/seg=%s\n",

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN136@process_br
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv179[rsp], rax
	jmp	SHORT $LN137@process_br
$LN136@process_br:
	lea	rax, OFFSET FLAT:$SG10780
	mov	QWORD PTR tv179[rsp], rax
$LN137@process_br:
	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	mov	DWORD PTR tv190[rsp], eax
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	shr	ecx, 1
	and	ecx, 1
	mov	DWORD PTR tv196[rsp], ecx
	call	GetCurrOffset
	mov	rcx, QWORD PTR tv179[rsp]
	mov	QWORD PTR [rsp+80], rcx
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rsp+72], ecx
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	mov	DWORD PTR [rsp+64], ecx
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+32]
	mov	DWORD PTR [rsp+56], ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rsp+48], ecx
	mov	ecx, DWORD PTR tv190[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rsp+32], ecx
	mov	ecx, DWORD PTR tv196[rsp]
	mov	r9d, ecx
	mov	rcx, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rcx+8]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG10781
	call	DoDebugMsg1

; 196  :               GetCurrOffset(), sym->name, opndx->explicit, opndx->mem_type, opndx->Ofssize, CodeInfo->mem_type,
; 197  :               sym->state, sym->mem_type, sym->offset, sym->segment ? sym->segment->name : "NULL" ));
; 198  : 
; 199  :     state = sym->state;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR state$[rsp], eax

; 200  :     addr = GetCurrOffset(); /* for SYM_UNDEFINED, will force distance to SHORT */

	call	GetCurrOffset
	mov	DWORD PTR addr$[rsp], eax

; 201  : 
; 202  :     /* v2.02: if symbol is GLOBAL and it isn't clear yet were
; 203  :      * it's located, then assume it is a forward reference (=SYM_UNDEFINED)!
; 204  :      * This applies to PROTOs and EXTERNDEFs in Pass 1.
; 205  :      */
; 206  :     if ( ( state == SYM_EXTERNAL ) && sym->weak ) {

	cmp	DWORD PTR state$[rsp], 2
	jne	SHORT $LN21@process_br
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN21@process_br

; 207  :         DebugMsg1(("process_branch(%s): EXTERNDEF assumed forward reference (=SYM_UNDEFINED)\n", sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10783
	call	DoDebugMsg1

; 208  :         state = SYM_UNDEFINED;

	mov	DWORD PTR state$[rsp], 0
$LN21@process_br:

; 209  :     }
; 210  : 
; 211  :     /* v2.02: removed SYM_UNDEFINED. Don't check segment of such symbols! */
; 212  : //    if ( state == SYM_UNDEFINED || state == SYM_INTERNAL || state == SYM_EXTERNAL ) {
; 213  :     if ( state == SYM_INTERNAL || state == SYM_EXTERNAL ) {

	cmp	DWORD PTR state$[rsp], 1
	je	SHORT $LN24@process_br
	cmp	DWORD PTR state$[rsp], 2
	jne	$LN22@process_br
$LN24@process_br:

; 214  :         /* v2.04: if the symbol is internal, but wasn't met yet
; 215  :          * in this pass and its offset is < $, don't use current offset
; 216  :          */
; 217  :         if ( state == SYM_INTERNAL &&
; 218  :             sym->asmpass != ( Parse_Pass & 0xFF) &&

	cmp	DWORD PTR state$[rsp], 1
	jne	SHORT $LN25@process_br
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	mov	ecx, DWORD PTR Parse_Pass
	and	ecx, 255				; 000000ffH
	cmp	eax, ecx
	je	SHORT $LN25@process_br
	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR addr$[rsp]
	cmp	DWORD PTR [rax+16], ecx
	jge	SHORT $LN25@process_br

; 219  :             sym->offset < addr )
; 220  :             ;

	jmp	SHORT $LN26@process_br
$LN25@process_br:

; 221  :         else
; 222  :             addr = sym->offset; /* v2.02: init addr, so sym->offset isn't changed */

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR addr$[rsp], eax
$LN26@process_br:

; 223  :         symseg = GetSegm( sym );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR symseg$[rsp], rax

; 224  :         if( symseg == NULL || ( CurrSeg != symseg ) ) {

	cmp	QWORD PTR symseg$[rsp], 0
	je	SHORT $LN28@process_br
	mov	rax, QWORD PTR symseg$[rsp]
	cmp	QWORD PTR ModuleInfo+432, rax
	je	$LN27@process_br
$LN28@process_br:

; 225  :             /* if label has a different segment and jump/call is near or short,
; 226  :              report an error */
; 227  :             //if ( ModuleInfo.flatgrp_idx != 0 )
; 228  :             /* v2.09: make sure there's no near jmp/call between 32- and 64-bit */
; 229  :             //if ( ModuleInfo.flat_grp )
; 230  :             if ( ModuleInfo.flat_grp
; 231  : #if AMD64_SUPPORT
; 232  :                 && ( symseg == NULL || symseg->e.seginfo->Ofssize == ModuleInfo.Ofssize )

	cmp	QWORD PTR ModuleInfo+440, 0
	je	SHORT $LN29@process_br
	cmp	QWORD PTR symseg$[rsp], 0
	je	SHORT $LN31@process_br
	mov	rax, QWORD PTR symseg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+104]
	movzx	ecx, BYTE PTR ModuleInfo+404
	cmp	eax, ecx
	jne	SHORT $LN29@process_br
$LN31@process_br:

; 233  : #endif
; 234  :                ) {
; 235  :             } else if ( symseg != NULL && CurrSeg != NULL ) {

	jmp	SHORT $LN30@process_br
$LN29@process_br:
	cmp	QWORD PTR symseg$[rsp], 0
	je	SHORT $LN32@process_br
	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN32@process_br

; 236  :                 /* if the segments belong to the same group, it's ok */
; 237  :                 if ( symseg->e.seginfo->group != NULL &&

	mov	rax, QWORD PTR symseg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN33@process_br
	mov	rax, QWORD PTR symseg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN33@process_br

; 238  :                     symseg->e.seginfo->group == CurrSeg->e.seginfo->group )
; 239  :                     ;

	jmp	SHORT $LN34@process_br
$LN33@process_br:

; 240  :                 /* v2.05: added SegOverride condition */
; 241  :                 //else if ( opndx->mem_type == MT_NEAR ) {
; 242  :                 else if ( opndx->mem_type == MT_NEAR && SegOverride == NULL ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+64], 129			; 00000081H
	jne	SHORT $LN35@process_br
	cmp	QWORD PTR SegOverride, 0
	jne	SHORT $LN35@process_br

; 243  :                     DebugMsg(("process_branch: error, opndx.mem_type is MT_NEAR\n" ));

	lea	rcx, OFFSET FLAT:$SG10798
	call	DoDebugMsg

; 244  :                     return( EmitError( CANNOT_HAVE_IMPLICIT_FAR_JUMP_OR_CALL_TO_NEAR_LABEL ) );

	mov	ecx, 169				; 000000a9H
	call	EmitError
	jmp	$LN1@process_br
$LN35@process_br:
$LN34@process_br:
$LN32@process_br:
$LN30@process_br:

; 245  :                 }
; 246  :             }
; 247  :             /* jumps to another segment are just like to another file */
; 248  :             state = SYM_EXTERNAL;

	mov	DWORD PTR state$[rsp], 2
$LN27@process_br:

; 249  :         }

	jmp	SHORT $LN23@process_br
$LN22@process_br:

; 250  :     } else if ( state != SYM_UNDEFINED ) {

	cmp	DWORD PTR state$[rsp], 0
	je	SHORT $LN36@process_br

; 251  :         DebugMsg(("process_branch(%s): error, unexpected symbol state=%u\n", sym->name, sym->state ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+32]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10800
	call	DoDebugMsg

; 252  :         return( EmitErr( JUMP_DESTINATION_MUST_SPECIFY_A_LABEL ) );

	mov	ecx, 249				; 000000f9H
	call	EmitErr
	jmp	$LN1@process_br
$LN36@process_br:
$LN23@process_br:

; 253  :     }
; 254  : 
; 255  :     if ( state != SYM_EXTERNAL ) {

	cmp	DWORD PTR state$[rsp], 2
	je	$LN37@process_br

; 256  :         /* v1.94: if a segment override is active,
; 257  :          check if it's matching the assumed value of CS.
; 258  :          If no, assume a FAR call.
; 259  :          */
; 260  :         if ( SegOverride != NULL && CodeInfo->mem_type == MT_EMPTY ) {

	cmp	QWORD PTR SegOverride, 0
	je	SHORT $LN38@process_br
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	SHORT $LN38@process_br

; 261  :             if ( SegOverride != GetOverrideAssume( ASSUME_CS ) ) {

	mov	ecx, 1
	call	GetOverrideAssume
	cmp	QWORD PTR SegOverride, rax
	je	SHORT $LN39@process_br

; 262  :                 CodeInfo->mem_type = MT_FAR;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 130			; 00000082H
$LN39@process_br:
$LN38@process_br:

; 263  :             }
; 264  :         }
; 265  :         if(  ( CodeInfo->mem_type == MT_EMPTY ||
; 266  :               CodeInfo->mem_type == MT_NEAR ) &&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	je	SHORT $LN41@process_br
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 129			; 00000081H
	jne	$LN40@process_br
$LN41@process_br:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	$LN40@process_br

; 267  :            CodeInfo->isfar == FALSE ) {
; 268  : 
; 269  :             /* if the label is FAR - or there is a segment override
; 270  :              * which equals assumed value of CS - and there is no type cast,
; 271  :              * then do a "far call optimization".
; 272  :              */
; 273  :             if( CodeInfo->token == T_CALL &&
; 274  :                 CodeInfo->mem_type == MT_EMPTY &&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 455			; 000001c7H
	jne	SHORT $LN42@process_br
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	SHORT $LN42@process_br
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	je	SHORT $LN43@process_br
	cmp	QWORD PTR SegOverride, 0
	je	SHORT $LN42@process_br
$LN43@process_br:

; 275  :                 ( sym->mem_type == MT_FAR || SegOverride ) ) {
; 276  :                 DebugMsg1(("process_branch: FAR call optimization applied!\n" ));

	lea	rcx, OFFSET FLAT:$SG10808
	call	DoDebugMsg1

; 277  :                 FarCallToNear( CodeInfo ); /* switch mem_type to NEAR */

	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	FarCallToNear
$LN42@process_br:

; 278  :             }
; 279  : 
; 280  :             //addr = sym->offset; /* v2.02: this has been done above */
; 281  :             DebugMsg(("process_branch: step1: addr=%Xh\n", addr ));

	mov	edx, DWORD PTR addr$[rsp]
	lea	rcx, OFFSET FLAT:$SG10809
	call	DoDebugMsg

; 282  :             addr -= ( GetCurrOffset() + 2 );  /* calculate the displacement */

	call	GetCurrOffset
	add	eax, 2
	mov	ecx, DWORD PTR addr$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR addr$[rsp], eax

; 283  :             addr += CodeInfo->opnd[OPND1].data32l;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+40]
	mov	ecx, DWORD PTR addr$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR addr$[rsp], eax

; 284  :             /*  JCXZ, LOOPW, LOOPEW, LOOPZW, LOOPNEW, LOOPNZW,
; 285  :                JECXZ, LOOPD, LOOPED, LOOPZD, LOOPNED, LOOPNZD? */
; 286  :             if (( CodeInfo->Ofssize && InstrTable[opidx].byte1_info == F_16A ) ||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN46@process_br
	mov	eax, DWORD PTR opidx$[rsp]
	imul	rax, rax, 14
	lea	rcx, OFFSET FLAT:InstrTable
	movzx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 3
	je	SHORT $LN45@process_br
$LN46@process_br:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 1
	je	SHORT $LN44@process_br
	mov	eax, DWORD PTR opidx$[rsp]
	imul	rax, rax, 14
	lea	rcx, OFFSET FLAT:InstrTable
	movzx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 4
	jne	SHORT $LN44@process_br
$LN45@process_br:

; 287  :                 ( CodeInfo->Ofssize != USE32 && InstrTable[opidx].byte1_info == F_32A ))
; 288  :                 addr--; /* 1 extra byte for ADRSIZ (0x67) */

	mov	eax, DWORD PTR addr$[rsp]
	dec	eax
	mov	DWORD PTR addr$[rsp], eax
$LN44@process_br:

; 289  : 
; 290  :             /* v2.02: removed */
; 291  :             //if( CodeInfo->token == T_CALL && CodeInfo->mem_type == MT_EMPTY ) {
; 292  :             //    CodeInfo->mem_type = MT_NEAR;
; 293  :             //}
; 294  :             DebugMsg(("process_branch: CI.memtype=%Xh addr=%Xh\n", CodeInfo->mem_type, addr ));

	mov	r8d, DWORD PTR addr$[rsp]
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rax+28]
	lea	rcx, OFFSET FLAT:$SG10813
	call	DoDebugMsg

; 295  :             if( CodeInfo->mem_type != MT_NEAR && CodeInfo->token != T_CALL &&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 129			; 00000081H
	je	SHORT $LN47@process_br
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 455			; 000001c7H
	je	SHORT $LN47@process_br
	cmp	DWORD PTR addr$[rsp], -128		; ffffffffffffff80H
	jl	SHORT $LN47@process_br
	cmp	DWORD PTR addr$[rsp], 127		; 0000007fH
	jg	SHORT $LN47@process_br

; 296  :                 ( addr >= SCHAR_MIN && addr <= SCHAR_MAX ) ) {
; 297  :                 CodeInfo->opnd[OPND1].type = OP_I8;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 131072		; 00020000H

; 298  :             } else {

	jmp	$LN48@process_br
$LN47@process_br:

; 299  :                 if ( opndx->instr == T_SHORT || ( IS_XCX_BRANCH( CodeInfo->token ) ) ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 245			; 000000f5H
	je	SHORT $LN50@process_br
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 487			; 000001e7H
	jl	$LN49@process_br
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 504			; 000001f8H
	jg	$LN49@process_br
$LN50@process_br:

; 300  :                     /* v2.06: added */
; 301  :                     if( CodeInfo->token == T_CALL ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 455			; 000001c7H
	jne	SHORT $LN51@process_br

; 302  :                         return( EmitError( CANNOT_USE_SHORT_WITH_CALL ) );

	mov	ecx, 43					; 0000002bH
	call	EmitError
	jmp	$LN1@process_br
$LN51@process_br:

; 303  :                     }
; 304  :                     /* v1.96: since HJWasm's backpatch strategy is to move from
; 305  :                      * "smallest" to "largest" distance, an "out of range"
; 306  :                      * error can be detected at any time.
; 307  :                      */
; 308  :                     DebugMsg(("process_branch: jump out of range, mem_type=%Xh addr=%Xh\n", CodeInfo->mem_type, addr ));

	mov	r8d, DWORD PTR addr$[rsp]
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rax+28]
	lea	rcx, OFFSET FLAT:$SG10819
	call	DoDebugMsg

; 309  :                     /* v2.06: removed */
; 310  :                     /* v2.03: added */
; 311  :                     //if ( addr >= SCHAR_MIN && addr <= SCHAR_MAX ) {
; 312  :                     //    return( EmitError( ONLY_SHORT_JUMP_DISTANCE_IS_ALLOWED ) );
; 313  :                     //}
; 314  :                     if ( addr < 0 ) {

	cmp	DWORD PTR addr$[rsp], 0
	jge	SHORT $LN52@process_br

; 315  :                         addr -= SCHAR_MIN;

	mov	eax, DWORD PTR addr$[rsp]
	add	eax, 128				; 00000080H
	mov	DWORD PTR addr$[rsp], eax

; 316  :                         addr = 0 - addr;

	xor	eax, eax
	sub	eax, DWORD PTR addr$[rsp]
	mov	DWORD PTR addr$[rsp], eax

; 317  :                     } else

	jmp	SHORT $LN53@process_br
$LN52@process_br:

; 318  :                         addr -= SCHAR_MAX;

	mov	eax, DWORD PTR addr$[rsp]
	sub	eax, 127				; 0000007fH
	mov	DWORD PTR addr$[rsp], eax
$LN53@process_br:

; 319  :                     return( EmitErr( CodeInfo->mem_type == MT_EMPTY ? JUMP_OUT_OF_RANGE : ONLY_SHORT_JUMP_DISTANCE_IS_ALLOWED, addr ) );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	SHORT $LN138@process_br
	mov	DWORD PTR tv349[rsp], 53		; 00000035H
	jmp	SHORT $LN139@process_br
$LN138@process_br:
	mov	DWORD PTR tv349[rsp], 44		; 0000002cH
$LN139@process_br:
	mov	edx, DWORD PTR addr$[rsp]
	mov	ecx, DWORD PTR tv349[rsp]
	call	EmitErr
	jmp	$LN1@process_br
$LN49@process_br:

; 320  :                 }
; 321  :                 /* near destination */
; 322  :                 /* is there a type coercion? */
; 323  :                 if ( opndx->Ofssize != USE_EMPTY ) {

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	cmp	eax, 254				; 000000feH
	je	$LN54@process_br

; 324  :                     if ( opndx->Ofssize == USE16 ) {

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	test	eax, eax
	jne	SHORT $LN56@process_br

; 325  :                         CodeInfo->opnd[OPND1].type = OP_I16;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 262144		; 00040000H

; 326  :                         addr -= 1; /* 16 bit displacement */

	mov	eax, DWORD PTR addr$[rsp]
	dec	eax
	mov	DWORD PTR addr$[rsp], eax

; 327  :                     } else {

	jmp	SHORT $LN57@process_br
$LN56@process_br:

; 328  :                         CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 524288		; 00080000H

; 329  :                         addr -= 3; /* 32 bit displacement */

	mov	eax, DWORD PTR addr$[rsp]
	sub	eax, 3
	mov	DWORD PTR addr$[rsp], eax
$LN57@process_br:

; 330  :                     }
; 331  :                     CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, opndx->Ofssize );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	mov	rcx, QWORD PTR opndx$[rsp]
	movzx	ecx, BYTE PTR [rcx+69]
	cmp	eax, ecx
	je	SHORT $LN140@process_br
	mov	DWORD PTR tv373[rsp], 1
	jmp	SHORT $LN141@process_br
$LN140@process_br:
	mov	DWORD PTR tv373[rsp], 0
$LN141@process_br:
	movzx	eax, BYTE PTR tv373[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 332  :                     if ( CodeInfo->prefix.opsiz )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN58@process_br

; 333  :                         addr--;

	mov	eax, DWORD PTR addr$[rsp]
	dec	eax
	mov	DWORD PTR addr$[rsp], eax
$LN58@process_br:

; 334  :                 } else if( CodeInfo->Ofssize > USE16 ) {

	jmp	SHORT $LN55@process_br
$LN54@process_br:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jle	SHORT $LN59@process_br

; 335  :                     CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 524288		; 00080000H

; 336  :                     addr -= 3; /* 32 bit displacement */

	mov	eax, DWORD PTR addr$[rsp]
	sub	eax, 3
	mov	DWORD PTR addr$[rsp], eax

; 337  :                 } else {

	jmp	SHORT $LN60@process_br
$LN59@process_br:

; 338  :                     CodeInfo->opnd[OPND1].type = OP_I16;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 262144		; 00040000H

; 339  :                     addr -= 1; /* 16 bit displacement */

	mov	eax, DWORD PTR addr$[rsp]
	dec	eax
	mov	DWORD PTR addr$[rsp], eax
$LN60@process_br:
$LN55@process_br:

; 340  :                 }
; 341  :                 if( IS_CONDJMP( CodeInfo->token ) ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 457			; 000001c9H
	jl	SHORT $LN61@process_br
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 486			; 000001e6H
	jg	SHORT $LN61@process_br

; 342  :                     /* 1 extra byte for opcode ( 0F ) */
; 343  :                     addr--;

	mov	eax, DWORD PTR addr$[rsp]
	dec	eax
	mov	DWORD PTR addr$[rsp], eax
$LN61@process_br:
$LN48@process_br:

; 344  :                 }
; 345  :             }
; 346  : 
; 347  :             /* store the displacement */
; 348  :             CodeInfo->opnd[OPND1].data32l = addr;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR addr$[rsp]
	mov	DWORD PTR [rcx+rax+40], edx

; 349  :             DebugMsg1(("process_branch: displacement=%" I32_SPEC "X opnd_type=%" I32_SPEC "X\n", addr, CodeInfo->opnd[OPND1].type ));

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	r8d, DWORD PTR [rcx+rax+32]
	mov	edx, DWORD PTR addr$[rsp]
	lea	rcx, OFFSET FLAT:$SG10830
	call	DoDebugMsg1

; 350  : 
; 351  :             /* automatic (conditional) jump expansion.
; 352  :              * for 386 and above this is not needed, since there exists
; 353  :              * an extended version of Jcc
; 354  :              */
; 355  :             if( ( ModuleInfo.curr_cpu & P_CPU_MASK) < P_386 && IS_JCC( CodeInfo->token ) ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jge	$LN62@process_br
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 456			; 000001c8H
	jle	$LN62@process_br
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 487			; 000001e7H
	jge	$LN62@process_br

; 356  :                 /* look into jump extension */
; 357  :                 if( CodeInfo->opnd[OPND1].type != OP_I8 ) {

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 131072		; 00020000H
	je	$LN63@process_br

; 358  :                     if( CodeInfo->mem_type == MT_EMPTY && ModuleInfo.ljmp == TRUE ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	SHORT $LN64@process_br
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 5
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN64@process_br

; 359  :                         jumpExtend( CodeInfo, FALSE );

	xor	edx, edx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	jumpExtend

; 360  :                         addr -= 1;

	mov	eax, DWORD PTR addr$[rsp]
	dec	eax
	mov	DWORD PTR addr$[rsp], eax

; 361  :                         CodeInfo->opnd[OPND1].data32l = addr;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR addr$[rsp]
	mov	DWORD PTR [rcx+rax+40], edx

; 362  :                         //return( SCRAP_INSTRUCTION );
; 363  :                     //} else if( !PhaseError ) {
; 364  :                     } else {

	jmp	SHORT $LN65@process_br
$LN64@process_br:

; 365  :                         DebugMsg(("%u process_branch: CPU < 386 and Jcc distance != SHORT, mem_type=%X, curr_ofs=%X, addr=%d\n", Parse_Pass + 1, CodeInfo->mem_type, GetCurrOffset(), addr ));

	call	GetCurrOffset
	mov	ecx, DWORD PTR Parse_Pass
	inc	ecx
	mov	edx, DWORD PTR addr$[rsp]
	mov	DWORD PTR [rsp+32], edx
	mov	r9d, eax
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	r8d, DWORD PTR [rax+28]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG10835
	call	DoDebugMsg

; 366  :                         /* v2.11: don't emit "out of range" if OP_I16 was forced by type coercion ( jmp near ptr xxx ) */
; 367  :                         return( EmitErr( CodeInfo->mem_type == MT_EMPTY ? JUMP_OUT_OF_RANGE : JUMP_DISTANCE_NOT_POSSIBLE, addr ) );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	SHORT $LN142@process_br
	mov	DWORD PTR tv450[rsp], 53		; 00000035H
	jmp	SHORT $LN143@process_br
$LN142@process_br:
	mov	DWORD PTR tv450[rsp], 50		; 00000032H
$LN143@process_br:
	mov	edx, DWORD PTR addr$[rsp]
	mov	ecx, DWORD PTR tv450[rsp]
	call	EmitErr
	jmp	$LN1@process_br
$LN65@process_br:
$LN63@process_br:
$LN62@process_br:

; 368  :                     }
; 369  :                 }
; 370  :             }
; 371  :             /* v2.02: in pass one, write "backpatch" fixup for forward
; 372  :              * references.
; 373  :              */
; 374  :             /* the "if" below needs to be explaind.
; 375  :              * Fixups will be written for forward references in pass one.
; 376  :              * state is SYM_UNDEFINED then. The fixups will be scanned when
; 377  :              * the label is met finally, still in pass one. See backptch.c
; 378  :              * for details.
; 379  :              */
; 380  :             if ( state != SYM_UNDEFINED )

	cmp	DWORD PTR state$[rsp], 0
	je	SHORT $LN66@process_br

; 381  :                 return( NOT_ERROR ); /* exit, no fixup is written! */

	xor	eax, eax
	jmp	$LN1@process_br
$LN66@process_br:
$LN40@process_br:
$LN37@process_br:

; 382  :         }
; 383  :     }
; 384  : 
; 385  :     DebugMsg1(("process_branch: fixup needed\n" ));

	lea	rcx, OFFSET FLAT:$SG10837
	call	DoDebugMsg1

; 386  : 
; 387  :     fixup_option = OPTJ_NONE;

	mov	DWORD PTR fixup_option$[rsp], 0

; 388  :     fixup_type = FIX_RELOFF8;

	mov	DWORD PTR fixup_type$[rsp], 1

; 389  : 
; 390  :     mem_type = opndx->mem_type;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR mem_type$[rsp], eax

; 391  : 
; 392  :     /* v2.04: far call optimization possible if destination is in
; 393  :      * another segment of the same group. However, a fixup must be written.
; 394  :      * Masm does NOT optimize if destination is external!
; 395  :      */
; 396  :     if( CodeInfo->token == T_CALL &&
; 397  :        CodeInfo->mem_type == MT_EMPTY &&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 455			; 000001c7H
	jne	$LN67@process_br
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	$LN67@process_br
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	je	SHORT $LN68@process_br
	cmp	QWORD PTR SegOverride, 0
	je	$LN67@process_br
$LN68@process_br:

; 398  :        ( sym->mem_type == MT_FAR || SegOverride ) ) {
; 399  :         symseg = GetSegm( sym );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR symseg$[rsp], rax

; 400  :         if ( symseg == CurrSeg ||

	mov	rax, QWORD PTR ModuleInfo+432
	cmp	QWORD PTR symseg$[rsp], rax
	je	SHORT $LN70@process_br
	cmp	QWORD PTR symseg$[rsp], 0
	je	SHORT $LN69@process_br
	mov	rax, QWORD PTR symseg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN69@process_br
	mov	rax, QWORD PTR symseg$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN69@process_br
$LN70@process_br:

; 401  :             ( symseg != NULL && symseg->e.seginfo->group != NULL && symseg->e.seginfo->group == CurrSeg->e.seginfo->group ) ) {
; 402  :             DebugMsg1(("process_branch: FAR call optimization applied!, seg=%X, CurrSeg=%X, grps=%X/%X\n", symseg, CurrSeg, symseg->e.seginfo->group, CurrSeg->e.seginfo->group ));

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR symseg$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR [rcx]
	mov	r8, QWORD PTR ModuleInfo+432
	mov	rdx, QWORD PTR symseg$[rsp]
	lea	rcx, OFFSET FLAT:$SG10842
	call	DoDebugMsg1

; 403  :             FarCallToNear( CodeInfo ); /* switch mem_type to NEAR */

	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	FarCallToNear
$LN69@process_br:
$LN67@process_br:

; 404  :         }
; 405  :     }
; 406  :     /* forward ref, or external symbol */
; 407  :     if( CodeInfo->mem_type == MT_EMPTY && mem_type != MT_EMPTY && opndx->instr != T_SHORT ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	$LN71@process_br
	cmp	DWORD PTR mem_type$[rsp], 192		; 000000c0H
	je	$LN71@process_br
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 245			; 000000f5H
	je	$LN71@process_br

; 408  :         /* MT_PROC is most likely obsolete ( used by TYPEDEF only ) */
; 409  :         /* v2.09: removed */
; 410  :         //if ( mem_type == MT_PROC )
; 411  :         //    mem_type = ( ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) ? MT_FAR : MT_NEAR );
; 412  :         switch( mem_type ) {

	mov	eax, DWORD PTR mem_type$[rsp]
	mov	DWORD PTR tv488[rsp], eax
	cmp	DWORD PTR tv488[rsp], 129		; 00000081H
	je	SHORT $LN75@process_br
	cmp	DWORD PTR tv488[rsp], 130		; 00000082H
	je	SHORT $LN72@process_br
	jmp	SHORT $LN77@process_br
$LN72@process_br:

; 413  :         case MT_FAR:
; 414  :             if( IS_JMPCALL( CodeInfo->token ) ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 455			; 000001c7H
	je	SHORT $LN74@process_br
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 456			; 000001c8H
	jne	SHORT $LN73@process_br
$LN74@process_br:

; 415  :                 CodeInfo->isfar = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 4
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al
$LN73@process_br:
$LN75@process_br:

; 416  :             }
; 417  :             /* v2.06: commented 2 lines to copy behavior of MT_NEAR */
; 418  :             //CodeInfo->mem_type = mem_type;
; 419  :             //break;
; 420  :         case MT_NEAR:
; 421  :             /* v2.04: 'if' added */
; 422  :             if ( state != SYM_UNDEFINED )

	cmp	DWORD PTR state$[rsp], 0
	je	SHORT $LN76@process_br

; 423  :                 CodeInfo->mem_type = mem_type;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR mem_type$[rsp]
	mov	DWORD PTR [rax+28], ecx
$LN76@process_br:

; 424  :             break;

	jmp	SHORT $LN2@process_br
$LN77@process_br:

; 425  :         default:
; 426  :             DebugMsg(("process_branch: unexpected mem_type %Xh\n", mem_type ));

	mov	edx, DWORD PTR mem_type$[rsp]
	lea	rcx, OFFSET FLAT:$SG10850
	call	DoDebugMsg

; 427  :             /**/myassert( 0 );

	mov	edx, 427				; 000001abH
	lea	rcx, OFFSET FLAT:$SG10851
	call	InternalError

; 428  :             CodeInfo->mem_type = mem_type;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR mem_type$[rsp]
	mov	DWORD PTR [rax+28], ecx
$LN2@process_br:
$LN71@process_br:

; 429  :         }
; 430  :     }
; 431  : 
; 432  :     /* handle far JMP + CALL? */
; 433  :     if ( IS_JMPCALL( CodeInfo->token ) &&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 455			; 000001c7H
	je	SHORT $LN79@process_br
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 456			; 000001c8H
	jne	$LN78@process_br
$LN79@process_br:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	je	SHORT $LN80@process_br
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 130			; 00000082H
	jne	$LN78@process_br
$LN80@process_br:

; 434  :         ( CodeInfo->isfar == TRUE || CodeInfo->mem_type == MT_FAR )) {
; 435  :         CodeInfo->isfar = TRUE; /* flag isn't set if explicit is true */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 4
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 436  :         DebugMsg1(("process_branch: FAR call/jmp\n"));

	lea	rcx, OFFSET FLAT:$SG10855
	call	DoDebugMsg1

; 437  :         switch( CodeInfo->mem_type ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR tv553[rsp], eax
	cmp	DWORD PTR tv553[rsp], 129		; 00000081H
	je	SHORT $LN81@process_br
	cmp	DWORD PTR tv553[rsp], 130		; 00000082H
	je	SHORT $LN84@process_br
	cmp	DWORD PTR tv553[rsp], 192		; 000000c0H
	je	SHORT $LN84@process_br
	jmp	$LN89@process_br
$LN81@process_br:

; 438  :         case MT_NEAR:
; 439  :             if( opndx->explicit || opndx->instr == T_SHORT ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN83@process_br
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 245			; 000000f5H
	jne	SHORT $LN82@process_br
$LN83@process_br:

; 440  :                 return( EmitError( CANNOT_USE_SHORT_OR_NEAR ) );

	mov	ecx, 52					; 00000034H
	call	EmitError
	jmp	$LN1@process_br
$LN82@process_br:
$LN84@process_br:

; 441  :             }
; 442  :             /* fall through */
; 443  :         case MT_FAR:
; 444  :         case MT_EMPTY:
; 445  :             /* v1.95: explicit flag to be removed! */
; 446  :             //if ( opndx->explicit && opndx->Ofssize != USE_EMPTY )
; 447  :             if ( opndx->Ofssize != USE_EMPTY )

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	cmp	eax, 254				; 000000feH
	je	SHORT $LN85@process_br

; 448  :                 CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, opndx->Ofssize );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	mov	rcx, QWORD PTR opndx$[rsp]
	movzx	ecx, BYTE PTR [rcx+69]
	cmp	eax, ecx
	je	SHORT $LN144@process_br
	mov	DWORD PTR tv571[rsp], 1
	jmp	SHORT $LN145@process_br
$LN144@process_br:
	mov	DWORD PTR tv571[rsp], 0
$LN145@process_br:
	movzx	eax, BYTE PTR tv571[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
	jmp	SHORT $LN86@process_br
$LN85@process_br:

; 449  :             else
; 450  :                 CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, GetSymOfssize( sym ) );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	mov	DWORD PTR tv580[rsp], eax
	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSymOfssize
	mov	ecx, DWORD PTR tv580[rsp]
	cmp	ecx, eax
	je	SHORT $LN146@process_br
	mov	DWORD PTR tv584[rsp], 1
	jmp	SHORT $LN147@process_br
$LN146@process_br:
	mov	DWORD PTR tv584[rsp], 0
$LN147@process_br:
	movzx	eax, BYTE PTR tv584[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN86@process_br:

; 451  : 
; 452  :             /* set fixup frame variables Frame + Frame_Datum */
; 453  :             set_frame( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	set_frame

; 454  :             if( IS_OPER_32( CodeInfo ) ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN152@process_br
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN150@process_br
	mov	DWORD PTR tv605[rsp], 1
	jmp	SHORT $LN151@process_br
$LN150@process_br:
	mov	DWORD PTR tv605[rsp], 0
$LN151@process_br:
	mov	eax, DWORD PTR tv605[rsp]
	mov	DWORD PTR tv607[rsp], eax
	jmp	SHORT $LN153@process_br
$LN152@process_br:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN148@process_br
	mov	DWORD PTR tv604[rsp], 1
	jmp	SHORT $LN149@process_br
$LN148@process_br:
	mov	DWORD PTR tv604[rsp], 0
$LN149@process_br:
	mov	eax, DWORD PTR tv604[rsp]
	mov	DWORD PTR tv607[rsp], eax
$LN153@process_br:
	cmp	DWORD PTR tv607[rsp], 0
	je	SHORT $LN87@process_br

; 455  :                 fixup_type = FIX_PTR32;

	mov	DWORD PTR fixup_type$[rsp], 10

; 456  :                 CodeInfo->opnd[OPND1].type = OP_I48;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 2097152		; 00200000H

; 457  :             } else {

	jmp	SHORT $LN88@process_br
$LN87@process_br:

; 458  :                 fixup_type = FIX_PTR16;

	mov	DWORD PTR fixup_type$[rsp], 9

; 459  :                 CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 524288		; 00080000H
$LN88@process_br:

; 460  :             }
; 461  :             break;

	jmp	SHORT $LN4@process_br
$LN89@process_br:

; 462  : #ifdef DEBUG_OUT
; 463  :         default: /* cannot happen */
; 464  :             DebugMsg(("process_branch: JMP/CALL far, unexpected mem_type=%X\n", CodeInfo->mem_type ));

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rax+28]
	lea	rcx, OFFSET FLAT:$SG10865
	call	DoDebugMsg

; 465  :             /**/myassert( 0 );

	mov	edx, 465				; 000001d1H
	lea	rcx, OFFSET FLAT:$SG10866
	call	InternalError
$LN4@process_br:

; 466  :             //return( EmitError( INVALID_OPERAND_SIZE ) );
; 467  : #endif
; 468  :         }
; 469  :         CodeInfo->opnd[OPND1].InsFixup = CreateFixup( sym, fixup_type, fixup_option );

	mov	r8d, DWORD PTR fixup_option$[rsp]
	mov	edx, DWORD PTR fixup_type$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateFixup
	mov	ecx, 24
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rdx+rcx+48], rax

; 470  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@process_br
$LN78@process_br:

; 471  :     }  /* end if FAR JMP/CALL */
; 472  : 
; 473  :     switch( CodeInfo->token ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv634[rsp], eax
	cmp	DWORD PTR tv634[rsp], 455		; 000001c7H
	je	SHORT $LN90@process_br
	cmp	DWORD PTR tv634[rsp], 456		; 000001c8H
	je	$LN95@process_br
	jmp	$LN105@process_br
$LN90@process_br:

; 474  :     case T_CALL:
; 475  :         if( opndx->instr == T_SHORT ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 245			; 000000f5H
	jne	SHORT $LN91@process_br

; 476  :             return( EmitError( CANNOT_USE_SHORT_WITH_CALL ) );

	mov	ecx, 43					; 0000002bH
	call	EmitError
	jmp	$LN1@process_br
$LN91@process_br:

; 477  :         }
; 478  :         if( CodeInfo->mem_type == MT_EMPTY ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	SHORT $LN92@process_br

; 479  :             fixup_option = OPTJ_CALL;

	mov	DWORD PTR fixup_option$[rsp], 4

; 480  :             if( CodeInfo->Ofssize > USE16 ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jle	SHORT $LN93@process_br

; 481  :                 fixup_type = FIX_RELOFF32;

	mov	DWORD PTR fixup_type$[rsp], 3

; 482  :                 CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 524288		; 00080000H

; 483  :             } else {

	jmp	SHORT $LN94@process_br
$LN93@process_br:

; 484  :                 fixup_type = FIX_RELOFF16;

	mov	DWORD PTR fixup_type$[rsp], 2

; 485  :                 CodeInfo->opnd[OPND1].type = OP_I16;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 262144		; 00040000H
$LN94@process_br:

; 486  :             }
; 487  :             break;

	jmp	$LN6@process_br
$LN92@process_br:
$LN95@process_br:

; 488  :         }
; 489  :         /* fall through */
; 490  :     case T_JMP:
; 491  :         DebugMsg1(("process_branch: JMP/CALL, CodeInfo->memtype=%X\n", CodeInfo->mem_type ));

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rax+28]
	lea	rcx, OFFSET FLAT:$SG10873
	call	DoDebugMsg1

; 492  :         switch( CodeInfo->mem_type ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR tv656[rsp], eax
	cmp	DWORD PTR tv656[rsp], 129		; 00000081H
	je	SHORT $LN97@process_br
	cmp	DWORD PTR tv656[rsp], 192		; 000000c0H
	je	SHORT $LN96@process_br
	jmp	$LN104@process_br
$LN96@process_br:

; 493  :         case MT_EMPTY:
; 494  :             /* forward reference
; 495  :              * default distance is short, we will expand later if needed
; 496  :              */
; 497  :             CodeInfo->opnd[OPND1].type = OP_I8;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 131072		; 00020000H

; 498  :             fixup_type = FIX_RELOFF8;

	mov	DWORD PTR fixup_type$[rsp], 1

; 499  :             fixup_option = (opndx->instr == T_SHORT) ? OPTJ_EXPLICIT : OPTJ_NONE;

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 245			; 000000f5H
	jne	SHORT $LN154@process_br
	mov	DWORD PTR tv663[rsp], 1
	jmp	SHORT $LN155@process_br
$LN154@process_br:
	mov	DWORD PTR tv663[rsp], 0
$LN155@process_br:
	mov	eax, DWORD PTR tv663[rsp]
	mov	DWORD PTR fixup_option$[rsp], eax

; 500  :             break;

	jmp	$LN8@process_br
$LN97@process_br:

; 501  :         case MT_NEAR:
; 502  :             fixup_option = OPTJ_EXPLICIT;

	mov	DWORD PTR fixup_option$[rsp], 1

; 503  : #if 1 /* v2.11: added, see call5.aso */
; 504  :             if( opndx->Ofssize != USE_EMPTY ) {

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	cmp	eax, 254				; 000000feH
	je	$LN98@process_br

; 505  :                 if ( opndx->Ofssize == USE16 ) {

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	test	eax, eax
	jne	SHORT $LN100@process_br

; 506  :                     fixup_type = FIX_RELOFF16;

	mov	DWORD PTR fixup_type$[rsp], 2

; 507  :                     CodeInfo->opnd[OPND1].type = OP_I16;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 262144		; 00040000H

; 508  :                 } else {

	jmp	SHORT $LN101@process_br
$LN100@process_br:

; 509  :                     fixup_type = FIX_RELOFF32;

	mov	DWORD PTR fixup_type$[rsp], 3

; 510  :                     CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 524288		; 00080000H
$LN101@process_br:

; 511  :                 }
; 512  :                 CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, opndx->Ofssize );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	mov	rcx, QWORD PTR opndx$[rsp]
	movzx	ecx, BYTE PTR [rcx+69]
	cmp	eax, ecx
	je	SHORT $LN156@process_br
	mov	DWORD PTR tv684[rsp], 1
	jmp	SHORT $LN157@process_br
$LN156@process_br:
	mov	DWORD PTR tv684[rsp], 0
$LN157@process_br:
	movzx	eax, BYTE PTR tv684[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 513  :             } else

	jmp	SHORT $LN99@process_br
$LN98@process_br:

; 514  : #endif
; 515  :             if( CodeInfo->Ofssize > USE16 ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jle	SHORT $LN102@process_br

; 516  :                 fixup_type = FIX_RELOFF32;

	mov	DWORD PTR fixup_type$[rsp], 3

; 517  :                 CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 524288		; 00080000H

; 518  :             } else {

	jmp	SHORT $LN103@process_br
$LN102@process_br:

; 519  :                 fixup_type = FIX_RELOFF16;

	mov	DWORD PTR fixup_type$[rsp], 2

; 520  :                 CodeInfo->opnd[OPND1].type = OP_I16;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 262144		; 00040000H
$LN103@process_br:
$LN99@process_br:

; 521  :             }
; 522  :             set_frame( sym );/* added v1.95 (after change in fixup.c */

	mov	rcx, QWORD PTR sym$[rsp]
	call	set_frame

; 523  :             break;

	jmp	SHORT $LN8@process_br
$LN104@process_br:

; 524  : #ifdef DEBUG_OUT
; 525  :         default:
; 526  :             DebugMsg(("process_branch: JMP/CALL, unexpected mem_type=%X\n", CodeInfo->mem_type ));

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rax+28]
	lea	rcx, OFFSET FLAT:$SG10883
	call	DoDebugMsg

; 527  :             /**/myassert( 0 );

	mov	edx, 527				; 0000020fH
	lea	rcx, OFFSET FLAT:$SG10884
	call	InternalError
$LN8@process_br:

; 528  :             //return( EmitError( INVALID_OPERAND_SIZE ) );
; 529  : #endif
; 530  :         }
; 531  :         /* deactivated because there's no override involved here */
; 532  :         // check_assume( sym, EMPTY );
; 533  :         break;

	jmp	$LN6@process_br
$LN105@process_br:

; 534  :     default: /* JxCXZ, LOOPxx, Jxx */
; 535  :         /* JxCXZ and LOOPxx always require SHORT label */
; 536  :         if ( IS_XCX_BRANCH( CodeInfo->token ) ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 487			; 000001e7H
	jl	SHORT $LN106@process_br
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 504			; 000001f8H
	jg	SHORT $LN106@process_br

; 537  :             if( CodeInfo->mem_type != MT_EMPTY && opndx->instr != T_SHORT ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	je	SHORT $LN107@process_br
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 245			; 000000f5H
	je	SHORT $LN107@process_br

; 538  :                 return( EmitError( ONLY_SHORT_JUMP_DISTANCE_IS_ALLOWED ) );

	mov	ecx, 44					; 0000002cH
	call	EmitError
	jmp	$LN1@process_br
$LN107@process_br:

; 539  :             }
; 540  :             CodeInfo->opnd[OPND1].type = OP_I8;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 131072		; 00020000H

; 541  :             fixup_option = OPTJ_EXPLICIT;

	mov	DWORD PTR fixup_option$[rsp], 1

; 542  :             fixup_type = FIX_RELOFF8;

	mov	DWORD PTR fixup_type$[rsp], 1

; 543  :             break;

	jmp	$LN6@process_br
$LN106@process_br:

; 544  :         }
; 545  :         /* just Jxx remaining */
; 546  : 
; 547  :         if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	$LN108@process_br

; 548  : 
; 549  :             switch( CodeInfo->mem_type ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR tv727[rsp], eax
	cmp	DWORD PTR tv727[rsp], 129		; 00000081H
	je	SHORT $LN111@process_br
	cmp	DWORD PTR tv727[rsp], 130		; 00000082H
	je	$LN116@process_br
	cmp	DWORD PTR tv727[rsp], 192		; 000000c0H
	je	SHORT $LN110@process_br
	jmp	$LN122@process_br
$LN110@process_br:

; 550  :             case MT_EMPTY:
; 551  :                 /* forward reference */
; 552  :                 fixup_option = ( opndx->instr == T_SHORT ) ? OPTJ_EXPLICIT : OPTJ_JXX;

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 245			; 000000f5H
	jne	SHORT $LN158@process_br
	mov	DWORD PTR tv730[rsp], 1
	jmp	SHORT $LN159@process_br
$LN158@process_br:
	mov	DWORD PTR tv730[rsp], 3
$LN159@process_br:
	mov	eax, DWORD PTR tv730[rsp]
	mov	DWORD PTR fixup_option$[rsp], eax

; 553  :                 fixup_type = FIX_RELOFF8;

	mov	DWORD PTR fixup_type$[rsp], 1

; 554  :                 CodeInfo->opnd[OPND1].type = OP_I8;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 131072		; 00020000H

; 555  :                 break;

	jmp	$LN10@process_br
$LN111@process_br:

; 556  :             case MT_NEAR:
; 557  :                 fixup_option = OPTJ_EXPLICIT;

	mov	DWORD PTR fixup_option$[rsp], 1

; 558  :                 /* v1.95: explicit flag to be removed! */
; 559  :                 //if ( opndx->explicit && opndx->Ofssize != USE_EMPTY ) {
; 560  :                 if ( opndx->Ofssize != USE_EMPTY ) {

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	cmp	eax, 254				; 000000feH
	je	$LN112@process_br

; 561  :                     CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, opndx->Ofssize );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	mov	rcx, QWORD PTR opndx$[rsp]
	movzx	ecx, BYTE PTR [rcx+69]
	cmp	eax, ecx
	je	SHORT $LN160@process_br
	mov	DWORD PTR tv744[rsp], 1
	jmp	SHORT $LN161@process_br
$LN160@process_br:
	mov	DWORD PTR tv744[rsp], 0
$LN161@process_br:
	movzx	eax, BYTE PTR tv744[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 562  :                     CodeInfo->opnd[OPND1].type = (opndx->Ofssize >= USE32) ? OP_I32 : OP_I16;

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	cmp	eax, 1
	jl	SHORT $LN162@process_br
	mov	DWORD PTR tv758[rsp], 524288		; 00080000H
	jmp	SHORT $LN163@process_br
$LN162@process_br:
	mov	DWORD PTR tv758[rsp], 262144		; 00040000H
$LN163@process_br:
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR tv758[rsp]
	mov	DWORD PTR [rcx+rax+32], edx
	jmp	SHORT $LN113@process_br
$LN112@process_br:

; 563  :                 } else if( CodeInfo->Ofssize > USE16 ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jle	SHORT $LN114@process_br

; 564  :                     fixup_type = FIX_RELOFF32;

	mov	DWORD PTR fixup_type$[rsp], 3

; 565  :                     CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 524288		; 00080000H

; 566  :                 } else {

	jmp	SHORT $LN115@process_br
$LN114@process_br:

; 567  :                     fixup_type = FIX_RELOFF16;

	mov	DWORD PTR fixup_type$[rsp], 2

; 568  :                     CodeInfo->opnd[OPND1].type = OP_I16;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 262144		; 00040000H
$LN115@process_br:
$LN113@process_br:

; 569  :                 }
; 570  :                 break;

	jmp	$LN10@process_br
$LN116@process_br:

; 571  :             case MT_FAR:
; 572  :                 if ( ModuleInfo.ljmp ) { /* OPTION LJMP set? */

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 5
	and	eax, 1
	test	eax, eax
	je	$LN117@process_br

; 573  :                     /* v1.95: explicit flag to be removed! */
; 574  :                     //if ( opndx->explicit && opndx->Ofssize != USE_EMPTY )
; 575  :                     if ( opndx->Ofssize != USE_EMPTY )

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	cmp	eax, 254				; 000000feH
	je	SHORT $LN118@process_br

; 576  :                         CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, opndx->Ofssize );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	mov	rcx, QWORD PTR opndx$[rsp]
	movzx	ecx, BYTE PTR [rcx+69]
	cmp	eax, ecx
	je	SHORT $LN164@process_br
	mov	DWORD PTR tv782[rsp], 1
	jmp	SHORT $LN165@process_br
$LN164@process_br:
	mov	DWORD PTR tv782[rsp], 0
$LN165@process_br:
	movzx	eax, BYTE PTR tv782[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
	jmp	SHORT $LN119@process_br
$LN118@process_br:

; 577  :                     else
; 578  :                         CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, GetSymOfssize( sym ));

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	mov	DWORD PTR tv791[rsp], eax
	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSymOfssize
	mov	ecx, DWORD PTR tv791[rsp]
	cmp	ecx, eax
	je	SHORT $LN166@process_br
	mov	DWORD PTR tv795[rsp], 1
	jmp	SHORT $LN167@process_br
$LN166@process_br:
	mov	DWORD PTR tv795[rsp], 0
$LN167@process_br:
	movzx	eax, BYTE PTR tv795[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN119@process_br:

; 579  :                     /* destination is FAR (externdef <dest>:far */
; 580  :                     DebugMsg(("process_branch: JMP/CALL, FAR memtype, jump extension\n" ));

	lea	rcx, OFFSET FLAT:$SG10900
	call	DoDebugMsg

; 581  :                     jumpExtend( CodeInfo, TRUE );

	mov	edx, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	jumpExtend

; 582  :                     CodeInfo->isfar = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 4
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 583  :                     if( IS_OPER_32( CodeInfo ) ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN172@process_br
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN170@process_br
	mov	DWORD PTR tv821[rsp], 1
	jmp	SHORT $LN171@process_br
$LN170@process_br:
	mov	DWORD PTR tv821[rsp], 0
$LN171@process_br:
	mov	eax, DWORD PTR tv821[rsp]
	mov	DWORD PTR tv823[rsp], eax
	jmp	SHORT $LN173@process_br
$LN172@process_br:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN168@process_br
	mov	DWORD PTR tv820[rsp], 1
	jmp	SHORT $LN169@process_br
$LN168@process_br:
	mov	DWORD PTR tv820[rsp], 0
$LN169@process_br:
	mov	eax, DWORD PTR tv820[rsp]
	mov	DWORD PTR tv823[rsp], eax
$LN173@process_br:
	cmp	DWORD PTR tv823[rsp], 0
	je	SHORT $LN120@process_br

; 584  :                         fixup_type = FIX_PTR32;

	mov	DWORD PTR fixup_type$[rsp], 10

; 585  :                         CodeInfo->opnd[OPND1].type = OP_I48;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 2097152		; 00200000H

; 586  :                     } else {

	jmp	SHORT $LN121@process_br
$LN120@process_br:

; 587  :                         fixup_type = FIX_PTR16;

	mov	DWORD PTR fixup_type$[rsp], 9

; 588  :                         CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 524288		; 00080000H
$LN121@process_br:

; 589  :                     }
; 590  :                     break;

	jmp	SHORT $LN10@process_br
$LN117@process_br:
$LN122@process_br:

; 591  :                 }
; 592  :                 /* fall through */
; 593  :             default: /* is another memtype possible at all? */
; 594  :                 return( EmitError( ONLY_SHORT_AND_NEAR_JUMP_DISTANCE_IS_ALLOWED ) );

	mov	ecx, 75					; 0000004bH
	call	EmitError
	jmp	$LN1@process_br
$LN10@process_br:

; 595  :             }
; 596  :         } else {

	jmp	$LN109@process_br
$LN108@process_br:

; 597  :             /* the only mode in 8086, 80186, 80286 is
; 598  :              * Jxx SHORT
; 599  :              * Masm allows "Jxx near" if LJMP is on (default) */
; 600  :             switch( CodeInfo->mem_type ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR tv839[rsp], eax
	cmp	DWORD PTR tv839[rsp], 129		; 00000081H
	jl	$LN130@process_br
	cmp	DWORD PTR tv839[rsp], 130		; 00000082H
	jle	SHORT $LN126@process_br
	cmp	DWORD PTR tv839[rsp], 192		; 000000c0H
	je	SHORT $LN123@process_br
	jmp	$LN130@process_br
$LN123@process_br:

; 601  :             case MT_EMPTY:
; 602  :                 if ( opndx->instr == T_SHORT )

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 245			; 000000f5H
	jne	SHORT $LN124@process_br

; 603  :                     fixup_option = OPTJ_EXPLICIT;

	mov	DWORD PTR fixup_option$[rsp], 1
	jmp	SHORT $LN125@process_br
$LN124@process_br:

; 604  :                 else
; 605  :                     fixup_option = OPTJ_EXTEND;

	mov	DWORD PTR fixup_option$[rsp], 2
$LN125@process_br:

; 606  :                 fixup_type = FIX_RELOFF8;

	mov	DWORD PTR fixup_type$[rsp], 1

; 607  :                 CodeInfo->opnd[OPND1].type = OP_I8;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 131072		; 00020000H

; 608  :                 break;

	jmp	$LN12@process_br
$LN126@process_br:

; 609  :             case MT_NEAR: /* allow Jxx NEAR if LJMP on */
; 610  :             case MT_FAR:
; 611  :                 if ( ModuleInfo.ljmp ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 5
	and	eax, 1
	test	eax, eax
	je	$LN127@process_br

; 612  :                     if ( CodeInfo->mem_type == MT_FAR ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 130			; 00000082H
	jne	SHORT $LN128@process_br

; 613  :                         jumpExtend( CodeInfo, TRUE );

	mov	edx, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	jumpExtend

; 614  :                         fixup_type = FIX_PTR16;

	mov	DWORD PTR fixup_type$[rsp], 9

; 615  :                         CodeInfo->isfar = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 4
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 616  :                         CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 524288		; 00080000H

; 617  :                     } else {

	jmp	SHORT $LN129@process_br
$LN128@process_br:

; 618  :                         jumpExtend( CodeInfo, FALSE );

	xor	edx, edx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	jumpExtend

; 619  :                         fixup_type = FIX_RELOFF16;

	mov	DWORD PTR fixup_type$[rsp], 2

; 620  :                         CodeInfo->opnd[OPND1].type = OP_I16;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 262144		; 00040000H
$LN129@process_br:

; 621  :                     }
; 622  :                     break;

	jmp	SHORT $LN12@process_br
$LN127@process_br:
$LN130@process_br:

; 623  :                 }
; 624  :                 /* fall through */
; 625  :             default:
; 626  :                 return( EmitError( ONLY_SHORT_JUMP_DISTANCE_IS_ALLOWED ) );

	mov	ecx, 44					; 0000002cH
	call	EmitError
	jmp	SHORT $LN1@process_br
$LN12@process_br:
$LN109@process_br:
$LN6@process_br:

; 627  :             }
; 628  :         }
; 629  :     } /* end switch (CodeInfo->token) */
; 630  :     CodeInfo->opnd[OPND1].InsFixup = CreateFixup( sym, fixup_type, fixup_option );

	mov	r8d, DWORD PTR fixup_option$[rsp]
	mov	edx, DWORD PTR fixup_type$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateFixup
	mov	ecx, 24
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rdx+rcx+48], rax

; 631  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@process_br:

; 632  : }

	add	rsp, 280				; 00000118H
	ret	0
process_branch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\branch.c
_TEXT	SEGMENT
CodeInfo$ = 48
FarCallToNear PROC

; 114  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 115  :     if( Parse_Pass == PASS_2 )

	cmp	DWORD PTR Parse_Pass, 1
	jne	SHORT $LN2@FarCallToN

; 116  :         EmitWarn( 4, CALL_FAR_TO_NEAR );

	mov	edx, 133				; 00000085H
	mov	ecx, 4
	call	EmitWarn
$LN2@FarCallToN:

; 117  : 
; 118  :     OutputCodeByte( 0x0E ); /* 0x0E is "PUSH CS" opcode */

	mov	cl, 14
	call	OutputByte

; 119  :     CodeInfo->mem_type = MT_NEAR;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 129			; 00000081H

; 120  : 
; 121  :     return;
; 122  : }

	add	rsp, 40					; 00000028H
	ret	0
FarCallToNear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\branch.c
_TEXT	SEGMENT
next_ins_size$ = 48
tv85 = 52
tv89 = 56
tv93 = 60
tv68 = 64
CodeInfo$ = 96
far_flag$ = 104
jumpExtend PROC

; 76   : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 77   :     //uint_8 opcode;
; 78   :     unsigned next_ins_size;
; 79   : 
; 80   :     if( Parse_Pass == PASS_2 )

	cmp	DWORD PTR Parse_Pass, 1
	jne	SHORT $LN2@jumpExtend

; 81   :         EmitWarn( 4, EXTENDING_JUMP );

	mov	edx, 127				; 0000007fH
	mov	ecx, 4
	call	EmitWarn
$LN2@jumpExtend:

; 82   : 
; 83   :     DebugMsg(("jumpExtend(far=%u), pass=%u, curr offset=%X, Ofssize=%u\n", far_flag, Parse_Pass + 1, GetCurrOffset(), CodeInfo->Ofssize ));

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	mov	DWORD PTR tv68[rsp], eax
	call	GetCurrOffset
	mov	ecx, DWORD PTR Parse_Pass
	inc	ecx
	mov	edx, DWORD PTR tv68[rsp]
	mov	DWORD PTR [rsp+32], edx
	mov	r9d, eax
	mov	r8d, ecx
	mov	edx, DWORD PTR far_flag$[rsp]
	lea	rcx, OFFSET FLAT:$SG10712
	call	DoDebugMsg

; 84   :     if( far_flag ) {

	cmp	DWORD PTR far_flag$[rsp], 0
	je	SHORT $LN3@jumpExtend

; 85   :         if ( CodeInfo->prefix.opsiz ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@jumpExtend

; 86   :             /* it's 66 EA OOOO SSSS or 66 EA OOOOOOOO SSSS */
; 87   :             next_ins_size = CodeInfo->Ofssize ? 6 : 8;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN8@jumpExtend
	mov	DWORD PTR tv85[rsp], 6
	jmp	SHORT $LN9@jumpExtend
$LN8@jumpExtend:
	mov	DWORD PTR tv85[rsp], 8
$LN9@jumpExtend:
	mov	eax, DWORD PTR tv85[rsp]
	mov	DWORD PTR next_ins_size$[rsp], eax

; 88   :         } else {

	jmp	SHORT $LN6@jumpExtend
$LN5@jumpExtend:

; 89   :             /* it's EA OOOOOOOO SSSS or EA OOOO SSSS */
; 90   :             next_ins_size = CodeInfo->Ofssize ? 7 : 5;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN10@jumpExtend
	mov	DWORD PTR tv89[rsp], 7
	jmp	SHORT $LN11@jumpExtend
$LN10@jumpExtend:
	mov	DWORD PTR tv89[rsp], 5
$LN11@jumpExtend:
	mov	eax, DWORD PTR tv89[rsp]
	mov	DWORD PTR next_ins_size$[rsp], eax
$LN6@jumpExtend:

; 91   :         }
; 92   :     } else {

	jmp	SHORT $LN4@jumpExtend
$LN3@jumpExtend:

; 93   :         /* it's E9 OOOOOOOO or E9 OOOO */
; 94   :         next_ins_size = CodeInfo->Ofssize ? 5 : 3;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN12@jumpExtend
	mov	DWORD PTR tv93[rsp], 5
	jmp	SHORT $LN13@jumpExtend
$LN12@jumpExtend:
	mov	DWORD PTR tv93[rsp], 3
$LN13@jumpExtend:
	mov	eax, DWORD PTR tv93[rsp]
	mov	DWORD PTR next_ins_size$[rsp], eax
$LN4@jumpExtend:

; 95   :     }
; 96   : 
; 97   :     /* it's ensured that the short jump version is first in InstrTable */
; 98   :     //opcode = InstrTable[optable_idx[CodeInfo->token]].opcode;
; 99   :     //OutputCodeByte( opcode ^ 1 );
; 100  :     /* the negation is achieved by XOR 1 */
; 101  :     OutputCodeByte( CodeInfo->pinstr->opcode ^ 1 );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax+12]
	xor	eax, 1
	movzx	ecx, al
	call	OutputByte

; 102  :     OutputCodeByte( next_ins_size );

	movzx	ecx, BYTE PTR next_ins_size$[rsp]
	call	OutputByte

; 103  :     CodeInfo->token = T_JMP;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+24], 456			; 000001c8H

; 104  :     CodeInfo->pinstr = &InstrTable[ IndexFromToken( T_JMP )];

	mov	eax, 2
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:optable_idx
	movzx	eax, WORD PTR [rcx+rax]
	imul	rax, rax, 14
	lea	rcx, OFFSET FLAT:InstrTable
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 105  : 
; 106  :     return;
; 107  : }

	add	rsp, 88					; 00000058H
	ret	0
jumpExtend ENDP
_TEXT	ENDS
END
