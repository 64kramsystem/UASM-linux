; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
CONST	SEGMENT
optiontab DQ	FLAT:$SG11210
	DQ	FLAT:SetDotName
	DQ	FLAT:$SG11211
	DQ	FLAT:SetNoDotName
	DQ	FLAT:$SG11212
	DQ	FLAT:SetM510
	DQ	FLAT:$SG11213
	DQ	FLAT:SetNoM510
	DQ	FLAT:$SG11214
	DQ	FLAT:SetScoped
	DQ	FLAT:$SG11215
	DQ	FLAT:SetNoScoped
	DQ	FLAT:$SG11216
	DQ	FLAT:SetOldStructs
	DQ	FLAT:$SG11217
	DQ	FLAT:SetNoOldStructs
	DQ	FLAT:$SG11218
	DQ	FLAT:SetEmulator
	DQ	FLAT:$SG11219
	DQ	FLAT:SetNoEmulator
	DQ	FLAT:$SG11220
	DQ	FLAT:SetLJmp
	DQ	FLAT:$SG11221
	DQ	FLAT:SetNoLJmp
	DQ	FLAT:$SG11222
	DQ	FLAT:Unsupported
	DQ	FLAT:$SG11223
	DQ	FLAT:SetNoReadonly
	DQ	FLAT:$SG11224
	DQ	FLAT:Unsupported
	DQ	FLAT:$SG11225
	DQ	FLAT:SetNoOldmacros
	DQ	FLAT:$SG11226
	DQ	FLAT:Unsupported
	DQ	FLAT:$SG11227
	DQ	FLAT:SetExpr32
	DQ	FLAT:$SG11228
	DQ	FLAT:SetNoSignExt
	DQ	FLAT:$SG11229
	DQ	FLAT:SetCaseMap
	DQ	FLAT:$SG11230
	DQ	FLAT:SetProc
	DQ	FLAT:$SG11231
	DQ	FLAT:SetPrologue
	DQ	FLAT:$SG11232
	DQ	FLAT:SetEpilogue
	DQ	FLAT:$SG11233
	DQ	FLAT:SetLanguage
	DQ	FLAT:$SG11234
	DQ	FLAT:SetNoKeyword
	DQ	FLAT:$SG11235
	DQ	FLAT:SetSetIF2
	DQ	FLAT:$SG11236
	DQ	FLAT:SetOffset
	DQ	FLAT:$SG11237
	DQ	FLAT:SetSegment
	DQ	FLAT:$SG11238
	DQ	FLAT:SetFieldAlign
	DQ	FLAT:$SG11239
	DQ	FLAT:SetProcAlign
	DQ	FLAT:$SG11240
	DQ	FLAT:SetMZ
	DQ	FLAT:$SG11241
	DQ	FLAT:SetFrame
	DQ	FLAT:$SG11242
	DQ	FLAT:SetElf
	DQ	FLAT:$SG11243
	DQ	FLAT:SetRenameKey
	DQ	FLAT:$SG11244
	DQ	FLAT:SetWin64
	DQ	FLAT:$SG11245
	DQ	FLAT:SetDllImport
	DQ	FLAT:$SG11246
	DQ	FLAT:SetCodeView
	DQ	FLAT:$SG11247
	DQ	FLAT:SetStackBase
	DQ	FLAT:$SG11248
	DQ	FLAT:SetEvex
	DQ	FLAT:$SG11249
	DQ	FLAT:SetZeroLocals
CONST	ENDS
_DATA	SEGMENT
$SG11273 DB	'option syntax error: >%s<', 0aH, 00H
	ORG $+1
$SG10778 DB	'NONE', 00H
	ORG $+3
$SG10784 DB	'ALL', 00H
$SG10781 DB	'NOTPUBLIC', 00H
	ORG $+2
$SG10993 DB	'EXPORT', 00H
	ORG $+1
$SG11240 DB	'MZ', 00H
	ORG $+1
$SG10785 DB	'SetCaseMap(%s) ok', 0aH, 00H
	ORG $+1
$SG10928 DB	'TRUE', 00H
	ORG $+3
$SG10930 DB	'FALSE', 00H
	ORG $+2
$SG10943 DB	'NONE', 00H
	ORG $+3
$SG10972 DB	'GROUP', 00H
	ORG $+2
$SG11098 DB	'NOAUTO', 00H
	ORG $+1
$SG11242 DB	'ELF', 00H
$SG10946 DB	'PROLOGUEDEF', 00H
$SG10959 DB	'NONE', 00H
	ORG $+3
$SG11009 DB	'USE16', 00H
	ORG $+2
$SG11154 DB	'__imp_', 00H
	ORG $+5
$SG10962 DB	'EPILOGUEDEF', 00H
$SG10975 DB	'FLAT', 00H
	ORG $+7
$SG10978 DB	'SEGMENT', 00H
$SG10991 DB	'PRIVATE', 00H
$SG11012 DB	'USE32', 00H
	ORG $+2
$SG11015 DB	'USE64', 00H
	ORG $+2
$SG11096 DB	'AUTO', 00H
	ORG $+3
$SG11155 DB	'_imp_', 00H
	ORG $+2
$SG11166 DB	'NONE', 00H
	ORG $+3
$SG11196 DB	'@StackBase', 00H
	ORG $+5
$SG11197 DB	'@ProcStatus', 00H
	ORG $+4
$SG11210 DB	'DOTNAME', 00H
$SG11211 DB	'NODOTNAME', 00H
	ORG $+2
$SG11212 DB	'M510', 00H
	ORG $+3
$SG11213 DB	'NOM510', 00H
	ORG $+1
$SG11214 DB	'SCOPED', 00H
	ORG $+5
$SG11215 DB	'NOSCOPED', 00H
	ORG $+7
$SG11216 DB	'OLDSTRUCTS', 00H
	ORG $+5
$SG11217 DB	'NOOLDSTRUCTS', 00H
	ORG $+3
$SG11218 DB	'EMULATOR', 00H
	ORG $+7
$SG11219 DB	'NOEMULATOR', 00H
	ORG $+1
$SG11220 DB	'LJMP', 00H
	ORG $+3
$SG11221 DB	'NOLJMP', 00H
	ORG $+5
$SG11222 DB	'READONLY', 00H
	ORG $+7
$SG11223 DB	'NOREADONLY', 00H
	ORG $+5
$SG11224 DB	'OLDMACROS', 00H
	ORG $+6
$SG11225 DB	'NOOLDMACROS', 00H
$SG11226 DB	'EXPR16', 00H
	ORG $+1
$SG11227 DB	'EXPR32', 00H
	ORG $+5
$SG11228 DB	'NOSIGNEXTEND', 00H
	ORG $+3
$SG11229 DB	'CASEMAP', 00H
$SG11230 DB	'PROC', 00H
	ORG $+3
$SG11231 DB	'PROLOGUE', 00H
	ORG $+7
$SG11232 DB	'EPILOGUE', 00H
	ORG $+7
$SG11233 DB	'LANGUAGE', 00H
	ORG $+7
$SG11234 DB	'NOKEYWORD', 00H
	ORG $+2
$SG11235 DB	'SETIF2', 00H
	ORG $+1
$SG11236 DB	'OFFSET', 00H
	ORG $+5
$SG11237 DB	'SEGMENT', 00H
$SG11238 DB	'FIELDALIGN', 00H
	ORG $+5
$SG11239 DB	'PROCALIGN', 00H
	ORG $+2
$SG11241 DB	'FRAME', 00H
	ORG $+6
$SG11243 DB	'RENAMEKEYWORD', 00H
	ORG $+2
$SG11244 DB	'WIN64', 00H
	ORG $+2
$SG11245 DB	'DLLIMPORT', 00H
	ORG $+6
$SG11246 DB	'CODEVIEW', 00H
	ORG $+7
$SG11247 DB	'STACKBASE', 00H
	ORG $+2
$SG11248 DB	'EVEX', 00H
	ORG $+7
$SG11249 DB	'ZEROLOCALS', 00H
	ORG $+5
$SG11262 DB	'OPTION directive enter, option=%s', 0aH, 00H
_DATA	ENDS
PUBLIC	OptionDirective
EXTRN	__imp_isspace:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp__strupr:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	SetMasm510:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymSetCmpFunc:PROC
EXTRN	GetLangType:PROC
EXTRN	FindResWord:PROC
EXTRN	IsKeywordDisabled:PROC
EXTRN	DisableKeyword:PROC
EXTRN	RenameKeyword:PROC
EXTRN	EvalOperand:PROC
EXTRN	EmitConstError:PROC
EXTRN	CreateVariable:PROC
EXTRN	UpdateStackBase:PROC
EXTRN	UpdateProcStatus:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SpecialTable:BYTE
EXTRN	sym_Interface:QWORD
pdata	SEGMENT
$pdata$SetEvex DD imagerel SetEvex
	DD	imagerel SetEvex+203
	DD	imagerel $unwind$SetEvex
$pdata$SetZeroLocals DD imagerel SetZeroLocals
	DD	imagerel SetZeroLocals+203
	DD	imagerel $unwind$SetZeroLocals
$pdata$SetDotName DD imagerel SetDotName
	DD	imagerel SetDotName+30
	DD	imagerel $unwind$SetDotName
$pdata$SetNoDotName DD imagerel SetNoDotName
	DD	imagerel SetNoDotName+30
	DD	imagerel $unwind$SetNoDotName
$pdata$SetCaseMap DD imagerel SetCaseMap
	DD	imagerel SetCaseMap+409
	DD	imagerel $unwind$SetCaseMap
$pdata$SetM510 DD imagerel SetM510
	DD	imagerel SetM510+50
	DD	imagerel $unwind$SetM510
$pdata$SetNoM510 DD imagerel SetNoM510
	DD	imagerel SetNoM510+50
	DD	imagerel $unwind$SetNoM510
$pdata$SetScoped DD imagerel SetScoped
	DD	imagerel SetScoped+31
	DD	imagerel $unwind$SetScoped
$pdata$SetNoScoped DD imagerel SetNoScoped
	DD	imagerel SetNoScoped+31
	DD	imagerel $unwind$SetNoScoped
$pdata$SetOldStructs DD imagerel SetOldStructs
	DD	imagerel SetOldStructs+31
	DD	imagerel $unwind$SetOldStructs
$pdata$SetNoOldStructs DD imagerel SetNoOldStructs
	DD	imagerel SetNoOldStructs+31
	DD	imagerel $unwind$SetNoOldStructs
$pdata$SetEmulator DD imagerel SetEmulator
	DD	imagerel SetEmulator+31
	DD	imagerel $unwind$SetEmulator
$pdata$SetNoEmulator DD imagerel SetNoEmulator
	DD	imagerel SetNoEmulator+31
	DD	imagerel $unwind$SetNoEmulator
$pdata$SetLJmp DD imagerel SetLJmp
	DD	imagerel SetLJmp+30
	DD	imagerel $unwind$SetLJmp
$pdata$SetNoLJmp DD imagerel SetNoLJmp
	DD	imagerel SetNoLJmp+30
	DD	imagerel $unwind$SetNoLJmp
$pdata$SetNoReadonly DD imagerel SetNoReadonly
	DD	imagerel SetNoReadonly+15
	DD	imagerel $unwind$SetNoReadonly
$pdata$SetNoOldmacros DD imagerel SetNoOldmacros
	DD	imagerel SetNoOldmacros+15
	DD	imagerel $unwind$SetNoOldmacros
$pdata$SetExpr32 DD imagerel SetExpr32
	DD	imagerel SetExpr32+15
	DD	imagerel $unwind$SetExpr32
$pdata$SetNoSignExt DD imagerel SetNoSignExt
	DD	imagerel SetNoSignExt+31
	DD	imagerel $unwind$SetNoSignExt
$pdata$SkipOption DD imagerel SkipOption
	DD	imagerel SkipOption+82
	DD	imagerel $unwind$SkipOption
$pdata$SetNoKeyword DD imagerel SetNoKeyword
	DD	imagerel SetNoKeyword+511
	DD	imagerel $unwind$SetNoKeyword
$pdata$SetLanguage DD imagerel SetLanguage
	DD	imagerel SetLanguage+201
	DD	imagerel $unwind$SetLanguage
$pdata$SetSetIF2 DD imagerel SetSetIF2
	DD	imagerel SetSetIF2+191
	DD	imagerel $unwind$SetSetIF2
$pdata$SetPrologue DD imagerel SetPrologue
	DD	imagerel SetPrologue+323
	DD	imagerel $unwind$SetPrologue
$pdata$SetEpilogue DD imagerel SetEpilogue
	DD	imagerel SetEpilogue+323
	DD	imagerel $unwind$SetEpilogue
$pdata$SetOffset DD imagerel SetOffset
	DD	imagerel SetOffset+250
	DD	imagerel $unwind$SetOffset
$pdata$SetProc DD imagerel SetProc
	DD	imagerel SetProc+330
	DD	imagerel $unwind$SetProc
$pdata$SetSegment DD imagerel SetSegment
	DD	imagerel SetSegment+397
	DD	imagerel $unwind$SetSegment
$pdata$SetFieldAlign DD imagerel SetFieldAlign
	DD	imagerel SetFieldAlign+279
	DD	imagerel $unwind$SetFieldAlign
$pdata$SetProcAlign DD imagerel SetProcAlign
	DD	imagerel SetProcAlign+277
	DD	imagerel $unwind$SetProcAlign
$pdata$SetMZ DD	imagerel SetMZ
	DD	imagerel SetMZ+651
	DD	imagerel $unwind$SetMZ
$pdata$SetFrame DD imagerel SetFrame
	DD	imagerel SetFrame+191
	DD	imagerel $unwind$SetFrame
$pdata$SetElf DD imagerel SetElf
	DD	imagerel SetElf+215
	DD	imagerel $unwind$SetElf
$pdata$SetRenameKey DD imagerel SetRenameKey
	DD	imagerel SetRenameKey+437
	DD	imagerel $unwind$SetRenameKey
$pdata$SetWin64 DD imagerel SetWin64
	DD	imagerel SetWin64+246
	DD	imagerel $unwind$SetWin64
$pdata$IncludeDll DD imagerel IncludeDll
	DD	imagerel IncludeDll+279
	DD	imagerel $unwind$IncludeDll
$pdata$SetDllImport DD imagerel SetDllImport
	DD	imagerel SetDllImport+244
	DD	imagerel $unwind$SetDllImport
$pdata$SetCodeView DD imagerel SetCodeView
	DD	imagerel SetCodeView+183
	DD	imagerel $unwind$SetCodeView
$pdata$SetStackBase DD imagerel SetStackBase
	DD	imagerel SetStackBase+357
	DD	imagerel $unwind$SetStackBase
$pdata$Unsupported DD imagerel Unsupported
	DD	imagerel Unsupported+77
	DD	imagerel $unwind$Unsupported
$pdata$OptionDirective DD imagerel $LN18
	DD	imagerel $LN18+575
	DD	imagerel $unwind$OptionDirective
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
xdata	SEGMENT
$unwind$SetEvex DD 032901H
	DD	01c0112H
	DD	0700bH
$unwind$SetZeroLocals DD 032901H
	DD	01c0112H
	DD	0700bH
$unwind$SetDotName DD 010b01H
	DD	0700bH
$unwind$SetNoDotName DD 010b01H
	DD	0700bH
$unwind$SetCaseMap DD 022301H
	DD	0700b520fH
$unwind$SetM510 DD 022301H
	DD	0700b320fH
$unwind$SetNoM510 DD 022301H
	DD	0700b320fH
$unwind$SetScoped DD 010b01H
	DD	0700bH
$unwind$SetNoScoped DD 010b01H
	DD	0700bH
$unwind$SetOldStructs DD 010b01H
	DD	0700bH
$unwind$SetNoOldStructs DD 010b01H
	DD	0700bH
$unwind$SetEmulator DD 010b01H
	DD	0700bH
$unwind$SetNoEmulator DD 010b01H
	DD	0700bH
$unwind$SetLJmp DD 010b01H
	DD	0700bH
$unwind$SetNoLJmp DD 010b01H
	DD	0700bH
$unwind$SetNoReadonly DD 010b01H
	DD	0700bH
$unwind$SetNoOldmacros DD 010b01H
	DD	0700bH
$unwind$SetExpr32 DD 010b01H
	DD	0700bH
$unwind$SetNoSignExt DD 010b01H
	DD	0700bH
$unwind$SkipOption DD 010b01H
	DD	0700bH
$unwind$SetNoKeyword DD 022301H
	DD	0700b720fH
$unwind$SetLanguage DD 022301H
	DD	0700b720fH
$unwind$SetSetIF2 DD 022301H
	DD	0700b520fH
$unwind$SetPrologue DD 022301H
	DD	0700b520fH
$unwind$SetEpilogue DD 022301H
	DD	0700b520fH
$unwind$SetOffset DD 022301H
	DD	0700b520fH
$unwind$SetProc DD 022301H
	DD	0700b520fH
$unwind$SetSegment DD 022301H
	DD	0700b520fH
$unwind$SetFieldAlign DD 032901H
	DD	01c0112H
	DD	0700bH
$unwind$SetProcAlign DD 032901H
	DD	01c0112H
	DD	0700bH
$unwind$SetMZ DD 032901H
	DD	01c0112H
	DD	0700bH
$unwind$SetFrame DD 022301H
	DD	0700b520fH
$unwind$SetElf DD 032901H
	DD	01c0112H
	DD	0700bH
$unwind$SetRenameKey DD 022301H
	DD	0700b520fH
$unwind$SetWin64 DD 032901H
	DD	01c0112H
	DD	0700bH
$unwind$IncludeDll DD 021e01H
	DD	07006720aH
$unwind$SetDllImport DD 022301H
	DD	0700b520fH
$unwind$SetCodeView DD 032901H
	DD	01c0112H
	DD	0700bH
$unwind$SetStackBase DD 022301H
	DD	0700b520fH
$unwind$Unsupported DD 022301H
	DD	0700b320fH
$unwind$OptionDirective DD 022101H
	DD	0700a720eH
xdata	ENDS
CONST	SEGMENT
SetEvex$rtcName$0 DB 069H
	DB	00H
	ORG $+2
SetEvex$rtcName$1 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	078H
	DB	00H
	ORG $+6
SetEvex$rtcVarDesc DD 060H
	DD	068H
	DQ	FLAT:SetEvex$rtcName$1
	DD	034H
	DD	04H
	DQ	FLAT:SetEvex$rtcName$0
	ORG $+96
SetEvex$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:SetEvex$rtcVarDesc
SetZeroLocals$rtcName$0 DB 069H
	DB	00H
	ORG $+2
SetZeroLocals$rtcName$1 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	078H
	DB	00H
	ORG $+6
SetZeroLocals$rtcVarDesc DD 060H
	DD	068H
	DQ	FLAT:SetZeroLocals$rtcName$1
	DD	034H
	DD	04H
	DQ	FLAT:SetZeroLocals$rtcName$0
	ORG $+96
SetZeroLocals$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:SetZeroLocals$rtcVarDesc
SetLanguage$rtcName$0 DB 069H
	DB	00H
	ORG $+6
SetLanguage$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:SetLanguage$rtcVarDesc
SetFieldAlign$rtcName$0 DB 069H
	DB	00H
	ORG $+6
SetLanguage$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:SetLanguage$rtcName$0
	ORG $+48
SetFieldAlign$rtcName$1 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	078H
	DB	00H
	ORG $+2
SetFieldAlign$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:SetFieldAlign$rtcVarDesc
SetProcAlign$rtcName$0 DB 069H
	DB	00H
	ORG $+6
SetFieldAlign$rtcVarDesc DD 060H
	DD	068H
	DQ	FLAT:SetFieldAlign$rtcName$1
	DD	034H
	DD	04H
	DQ	FLAT:SetFieldAlign$rtcName$0
	ORG $+96
SetProcAlign$rtcName$1 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	078H
	DB	00H
	ORG $+2
SetProcAlign$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:SetProcAlign$rtcVarDesc
SetMZ$rtcName$0 DB 069H
	DB	00H
	ORG $+6
SetProcAlign$rtcVarDesc DD 060H
	DD	068H
	DQ	FLAT:SetProcAlign$rtcName$1
	DD	034H
	DD	04H
	DQ	FLAT:SetProcAlign$rtcName$0
	ORG $+96
SetMZ$rtcName$1 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	078H
	DB	00H
	ORG $+2
SetMZ$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:SetMZ$rtcVarDesc
SetElf$rtcName$0 DB 069H
	DB	00H
	ORG $+6
SetMZ$rtcVarDesc DD 060H
	DD	068H
	DQ	FLAT:SetMZ$rtcName$1
	DD	034H
	DD	04H
	DQ	FLAT:SetMZ$rtcName$0
	ORG $+96
SetElf$rtcName$1 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	078H
	DB	00H
	ORG $+2
SetElf$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:SetElf$rtcVarDesc
SetWin64$rtcName$0 DB 069H
	DB	00H
	ORG $+6
SetElf$rtcVarDesc DD 060H
	DD	068H
	DQ	FLAT:SetElf$rtcName$1
	DD	034H
	DD	04H
	DQ	FLAT:SetElf$rtcName$0
	ORG $+96
SetWin64$rtcName$1 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	078H
	DB	00H
	ORG $+2
SetWin64$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:SetWin64$rtcVarDesc
SetCodeView$rtcName$0 DB 069H
	DB	00H
	ORG $+6
SetWin64$rtcVarDesc DD 060H
	DD	068H
	DQ	FLAT:SetWin64$rtcName$1
	DD	034H
	DD	04H
	DQ	FLAT:SetWin64$rtcName$0
	ORG $+96
SetCodeView$rtcName$1 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	00H
	ORG $+3
SetCodeView$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:SetCodeView$rtcVarDesc
	ORG $+8
SetCodeView$rtcVarDesc DD 060H
	DD	068H
	DQ	FLAT:SetCodeView$rtcName$1
	DD	034H
	DD	04H
	DQ	FLAT:SetCodeView$rtcName$0
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
idx$ = 32
tv93 = 40
tv191 = 48
i$ = 80
tokenarray$ = 88
OptionDirective PROC

; 935  : {

$LN18:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+80]

; 936  :     int idx = -1;

	mov	DWORD PTR idx$[rsp], -1

; 937  : 
; 938  :     DebugMsg1(( "OPTION directive enter, option=%s\n", tokenarray[i+1].string_ptr ));

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11262
	call	DoDebugMsg1

; 939  : 
; 940  :     i++; /* skip OPTION directive */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN2@OptionDire:

; 941  :     while ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN3@OptionDire

; 942  :         _strupr( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__strupr

; 943  :         for ( idx = 0; idx < TABITEMS; idx++ ) {

	mov	DWORD PTR idx$[rsp], 0
	jmp	SHORT $LN6@OptionDire
$LN4@OptionDire:
	mov	eax, DWORD PTR idx$[rsp]
	inc	eax
	mov	DWORD PTR idx$[rsp], eax
$LN6@OptionDire:
	movsxd	rax, DWORD PTR idx$[rsp]
	cmp	rax, 40					; 00000028H
	jae	SHORT $LN5@OptionDire

; 944  :             if ( 0 == strcmp( tokenarray[i].string_ptr, optiontab[idx].name ) )

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:optiontab
	movsxd	rdx, DWORD PTR i$[rsp]
	imul	rdx, rdx, 32				; 00000020H
	mov	QWORD PTR tv93[rsp], rdx
	mov	rdx, QWORD PTR [rcx+rax]
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR tv93[rsp]
	mov	rcx, QWORD PTR [rax+rcx+8]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN7@OptionDire

; 945  :                 break;

	jmp	SHORT $LN5@OptionDire
$LN7@OptionDire:

; 946  :         }

	jmp	SHORT $LN4@OptionDire
$LN5@OptionDire:

; 947  :         if ( idx >= TABITEMS )

	movsxd	rax, DWORD PTR idx$[rsp]
	cmp	rax, 40					; 00000028H
	jb	SHORT $LN8@OptionDire

; 948  :             break;

	jmp	$LN3@OptionDire
$LN8@OptionDire:

; 949  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 950  :         /* v2.06: check for colon separator here */
; 951  :         if ( idx >= NOARGOPTS ) {

	cmp	DWORD PTR idx$[rsp], 19
	jl	SHORT $LN9@OptionDire

; 952  :             if ( tokenarray[i].token != T_COLON ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN10@OptionDire

; 953  :                 return( EmitError( COLON_EXPECTED ) );

	mov	ecx, 84					; 00000054H
	call	EmitError
	jmp	$LN1@OptionDire
$LN10@OptionDire:

; 954  :             }
; 955  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 956  :             /* there must be something after the colon */
; 957  :             if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN11@OptionDire

; 958  :                 i -= 2; /* position back to option identifier */

	mov	eax, DWORD PTR i$[rsp]
	sub	eax, 2
	mov	DWORD PTR i$[rsp], eax

; 959  :                 break;

	jmp	SHORT $LN3@OptionDire
$LN11@OptionDire:

; 960  :             }
; 961  :             /* reject option if -Zne is set */
; 962  :             if ( idx >= MASMOPTS && Options.strict_masm_compat ) {

	cmp	DWORD PTR idx$[rsp], 28
	jl	SHORT $LN12@OptionDire
	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	je	SHORT $LN12@OptionDire

; 963  :                 i -= 2;

	mov	eax, DWORD PTR i$[rsp]
	sub	eax, 2
	mov	DWORD PTR i$[rsp], eax

; 964  :                 break;

	jmp	SHORT $LN3@OptionDire
$LN12@OptionDire:
$LN9@OptionDire:

; 965  :             }
; 966  :         }
; 967  :         if ( optiontab[idx].func( &i, tokenarray ) == ERROR )

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:optiontab
	mov	QWORD PTR tv191[rsp], rcx
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	r8, QWORD PTR tv191[rsp]
	call	QWORD PTR [r8+rax+8]
	cmp	eax, -1
	jne	SHORT $LN13@OptionDire

; 968  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@OptionDire
$LN13@OptionDire:

; 969  :         if ( tokenarray[i].token != T_COMMA )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN14@OptionDire

; 970  :             break;

	jmp	SHORT $LN3@OptionDire
$LN14@OptionDire:

; 971  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 972  :     }

	jmp	$LN2@OptionDire
$LN3@OptionDire:

; 973  :     if ( idx >= TABITEMS  || tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR idx$[rsp]
	cmp	rax, 40					; 00000028H
	jae	SHORT $LN16@OptionDire
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN15@OptionDire
$LN16@OptionDire:

; 974  :         DebugMsg(( "option syntax error: >%s<\n", tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11273
	call	DoDebugMsg

; 975  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@OptionDire
$LN15@OptionDire:

; 976  :     }
; 977  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@OptionDire:

; 978  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
OptionDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
Unsupported PROC

; 847  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 848  :     return( EmitErr( NOT_SUPPORTED, tokenarray[(*pi)-2].tokpos ) );

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	sub	eax, 2
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 72					; 00000048H
	call	EmitErr

; 849  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Unsupported ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 32
pi$ = 64
tokenarray$ = 72
SetStackBase PROC

; 821  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 822  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 823  : 
; 824  :     if ( tokenarray[i].token != T_REG ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	je	SHORT $LN2@SetStackBa

; 825  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@SetStackBa
$LN2@SetStackBa:

; 826  :     }
; 827  :     if ( !( GetSflagsSp( tokenarray[i].tokval ) & SFR_IREG ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax+4]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN3@SetStackBa

; 828  :         return( EmitError( MUST_BE_INDEX_OR_BASE_REGISTER ) );

	mov	ecx, 33					; 00000021H
	call	EmitError
	jmp	$LN1@SetStackBa
$LN3@SetStackBa:

; 829  :     }
; 830  :     ModuleInfo.basereg[ModuleInfo.Ofssize] = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	movzx	ecx, BYTE PTR ModuleInfo+404
	lea	rdx, OFFSET FLAT:ModuleInfo+500
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [r8+rax+16]
	mov	DWORD PTR [rdx+rcx*4], eax

; 831  :     if ( !ModuleInfo.g.StackBase ) {

	cmp	QWORD PTR ModuleInfo+272, 0
	jne	SHORT $LN4@SetStackBa

; 832  :         ModuleInfo.g.StackBase = CreateVariable( "@StackBase", 0 );

	xor	edx, edx
	lea	rcx, OFFSET FLAT:$SG11196
	call	CreateVariable
	mov	QWORD PTR ModuleInfo+272, rax

; 833  :         ModuleInfo.g.StackBase->predefined = TRUE;

	mov	rax, QWORD PTR ModuleInfo+272
	movzx	eax, BYTE PTR [rax+40]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR ModuleInfo+272
	mov	BYTE PTR [rcx+40], al

; 834  :         ModuleInfo.g.StackBase->sfunc_ptr = UpdateStackBase;

	mov	rax, QWORD PTR ModuleInfo+272
	lea	rcx, OFFSET FLAT:UpdateStackBase
	mov	QWORD PTR [rax+64], rcx

; 835  :         ModuleInfo.g.ProcStatus = CreateVariable( "@ProcStatus", 0 );

	xor	edx, edx
	lea	rcx, OFFSET FLAT:$SG11197
	call	CreateVariable
	mov	QWORD PTR ModuleInfo+280, rax

; 836  :         ModuleInfo.g.ProcStatus->predefined = TRUE;

	mov	rax, QWORD PTR ModuleInfo+280
	movzx	eax, BYTE PTR [rax+40]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR ModuleInfo+280
	mov	BYTE PTR [rcx+40], al

; 837  :         ModuleInfo.g.ProcStatus->sfunc_ptr = UpdateProcStatus;

	mov	rax, QWORD PTR ModuleInfo+280
	lea	rcx, OFFSET FLAT:UpdateProcStatus
	mov	QWORD PTR [rax+64], rcx
$LN4@SetStackBa:

; 838  :     }
; 839  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 840  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 841  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetStackBa:

; 842  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SetStackBase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 52
opnd$ = 96
pi$ = 240
tokenarray$ = 248
SetCodeView PROC

; 798  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 224				; 000000e0H
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+240]

; 799  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 800  :     struct expr opnd;
; 801  : 
; 802  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opnd, 0 ) == ERROR )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opnd$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN2@SetCodeVie

; 803  :         return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@SetCodeVie
$LN2@SetCodeVie:

; 804  :     if ( opnd.kind == EXPR_CONST ) {

	cmp	DWORD PTR opnd$[rsp+60], 0
	jne	SHORT $LN3@SetCodeVie

; 805  :         ModuleInfo.cv_opt = opnd.value;

	movzx	eax, BYTE PTR opnd$[rsp]
	mov	BYTE PTR ModuleInfo+427, al

; 806  :     } else {

	jmp	SHORT $LN4@SetCodeVie
$LN3@SetCodeVie:

; 807  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	SHORT $LN1@SetCodeVie
$LN4@SetCodeVie:

; 808  :     }
; 809  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 810  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetCodeVie:

; 811  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:SetCodeView$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 224				; 000000e0H
	pop	rdi
	ret	0
SetCodeView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 32
pi$ = 64
tokenarray$ = 72
SetDllImport PROC

; 772  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 773  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 774  : 
; 775  :     /* used for COFF only */
; 776  :     //if ( Options.output_format != OFORMAT_COFF ) {
; 777  :     //    SkipOption( pi, tokenarray );
; 778  :     //    return( NOT_ERROR);
; 779  :     //}
; 780  : 
; 781  :     if ( tokenarray[i].token == T_ID &&

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN2@SetDllImpo
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG11166
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN2@SetDllImpo

; 782  :         ( _stricmp( tokenarray[i].string_ptr, "NONE" ) == 0 ) ) {
; 783  :         ModuleInfo.CurrDll = NULL;

	mov	QWORD PTR ModuleInfo+336, 0

; 784  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN3@SetDllImpo
$LN2@SetDllImpo:

; 785  :     } else if ( tokenarray[i].token == T_STRING && tokenarray[i].string_delim == '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN4@SetDllImpo
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN4@SetDllImpo

; 786  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN5@SetDllImpo

; 787  :             ModuleInfo.CurrDll = IncludeDll( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	IncludeDll
	mov	QWORD PTR ModuleInfo+336, rax
$LN5@SetDllImpo:

; 788  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SetDllImpo:
$LN3@SetDllImpo:

; 789  :     }
; 790  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 791  :     return( NOT_ERROR );

	xor	eax, eax

; 792  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SetDllImport ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
q$ = 32
node$ = 40
tv85 = 48
name$ = 80
IncludeDll PROC

; 743  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 744  :     struct dll_desc **q;
; 745  :     struct dll_desc *node;
; 746  : 
; 747  :     /* allow a zero-sized name! */
; 748  :     if ( *name == NULLC )

	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN5@IncludeDll

; 749  :         return( NULL );

	xor	eax, eax
	jmp	$LN1@IncludeDll
$LN5@IncludeDll:

; 750  : 
; 751  :     for ( q = &ModuleInfo.g.DllQueue; *q ; q = &(*q)->next ) {

	lea	rax, OFFSET FLAT:ModuleInfo+80
	mov	QWORD PTR q$[rsp], rax
	jmp	SHORT $LN4@IncludeDll
$LN2@IncludeDll:
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$[rsp], rax
$LN4@IncludeDll:
	mov	rax, QWORD PTR q$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@IncludeDll

; 752  :         if ( _stricmp( (*q)->name, name ) == 0 )

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 12
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN6@IncludeDll

; 753  :             return( *q );

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	jmp	$LN1@IncludeDll
$LN6@IncludeDll:

; 754  :     }

	jmp	SHORT $LN2@IncludeDll
$LN3@IncludeDll:

; 755  :     node = LclAlloc( sizeof( struct dll_desc ) + strlen( name ) );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	add	rax, 16
	mov	rcx, rax
	call	LclAlloc
	mov	QWORD PTR node$[rsp], rax

; 756  :     node->next = NULL;

	mov	rax, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax], 0

; 757  :     node->cnt = 0;

	mov	rax, QWORD PTR node$[rsp]
	mov	DWORD PTR [rax+8], 0

; 758  :     strcpy( node->name, name );

	mov	rax, QWORD PTR node$[rsp]
	add	rax, 12
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, rax
	call	strcpy

; 759  :     *q = node;

	mov	rax, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax], rcx

; 760  : 
; 761  : #if AMD64_SUPPORT
; 762  :     ModuleInfo.g.imp_prefix = ( ( ModuleInfo.defOfssize == USE64 ) ? "__imp_" : "_imp_" );

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN8@IncludeDll
	lea	rax, OFFSET FLAT:$SG11154
	mov	QWORD PTR tv85[rsp], rax
	jmp	SHORT $LN9@IncludeDll
$LN8@IncludeDll:
	lea	rax, OFFSET FLAT:$SG11155
	mov	QWORD PTR tv85[rsp], rax
$LN9@IncludeDll:
	mov	rax, QWORD PTR tv85[rsp]
	mov	QWORD PTR ModuleInfo+88, rax

; 763  : #else
; 764  :     ModuleInfo.g.imp_prefix = "_imp_";
; 765  : #endif
; 766  : 
; 767  :     return( node );

	mov	rax, QWORD PTR node$[rsp]
$LN1@IncludeDll:

; 768  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
IncludeDll ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 52
opndx$ = 96
pi$ = 240
tokenarray$ = 248
SetWin64 PROC

; 713  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 224				; 000000e0H
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+240]

; 714  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 715  :     struct expr opndx;
; 716  : 
; 717  :     /* if -win64 isn't set, skip the option */
; 718  :     /* v2.09: skip option if Ofssize != USE64 */
; 719  :     if ( ModuleInfo.defOfssize != USE64 ) {

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	je	SHORT $LN2@SetWin64

; 720  :         SkipOption( pi, tokenarray );

	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR pi$[rsp]
	call	SkipOption

; 721  :         return( NOT_ERROR);

	xor	eax, eax
	jmp	SHORT $LN1@SetWin64
$LN2@SetWin64:

; 722  :     }
; 723  : 
; 724  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN3@SetWin64

; 725  :         return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@SetWin64
$LN3@SetWin64:

; 726  :     if ( opndx.kind == EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN4@SetWin64

; 727  :         if ( opndx.llvalue & ( ~W64F_ALL ) ) {

	mov	rax, QWORD PTR opndx$[rsp]
	and	rax, -16
	test	rax, rax
	je	SHORT $LN6@SetWin64

; 728  :             return( EmitConstError( &opndx ) );

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	SHORT $LN1@SetWin64
$LN6@SetWin64:

; 729  :         }
; 730  :         ModuleInfo.win64_flags = opndx.value;

	movzx	eax, BYTE PTR opndx$[rsp]
	mov	BYTE PTR ModuleInfo+413, al

; 731  :     } else {

	jmp	SHORT $LN5@SetWin64
$LN4@SetWin64:

; 732  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	SHORT $LN1@SetWin64
$LN5@SetWin64:

; 733  :     }
; 734  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 735  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetWin64:

; 736  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:SetWin64$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 224				; 000000e0H
	pop	rdi
	ret	0
SetWin64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 32
index$ = 36
oldname$ = 40
pi$ = 64
tokenarray$ = 72
SetRenameKey PROC

; 668  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 669  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 670  :     //struct ReservedWord *resw;
; 671  :     unsigned index;
; 672  :     char *oldname;
; 673  : 
; 674  : #if 0 /* v2.11: allow temporary renaming of keywords */
; 675  :     /* do nothing if pass > 1 */
; 676  :     if( Parse_Pass != PASS_1 ) {
; 677  :         SkipOption( pi, tokenarray );
; 678  :         return( NOT_ERROR );
; 679  :     }
; 680  : #endif
; 681  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' )  {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN3@SetRenameK
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN2@SetRenameK
$LN3@SetRenameK:

; 682  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@SetRenameK
$LN2@SetRenameK:

; 683  :     }
; 684  :     oldname = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR oldname$[rsp], rax

; 685  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 686  :     /* v2.06: syntax changed */
; 687  :     //if ( tokenarray[i].token != T_COMMA ) {
; 688  :     if ( tokenarray[i].token != T_DIRECTIVE || tokenarray[i].dirtype != DRT_EQUALSGN ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	SHORT $LN5@SetRenameK
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 48					; 00000030H
	je	SHORT $LN4@SetRenameK
$LN5@SetRenameK:

; 689  :         //EmitError( EXPECTING_COMMA );
; 690  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@SetRenameK
$LN4@SetRenameK:

; 691  :     }
; 692  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 693  :     if ( tokenarray[i].token != T_ID )  {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN6@SetRenameK

; 694  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@SetRenameK
$LN6@SetRenameK:

; 695  :     }
; 696  : 
; 697  :     /* todo: if MAX_ID_LEN can be > 255, then check size,
; 698  :      * since a reserved word's size must be <= 255 */
; 699  :     index = FindResWord( oldname, strlen( oldname ) );

	mov	rcx, QWORD PTR oldname$[rsp]
	call	strlen
	movzx	edx, al
	mov	rcx, QWORD PTR oldname$[rsp]
	call	FindResWord
	mov	DWORD PTR index$[rsp], eax

; 700  :     if ( index == 0 ) {

	cmp	DWORD PTR index$[rsp], 0
	jne	SHORT $LN7@SetRenameK

; 701  :         return( EmitError( RESERVED_WORD_EXPECTED ) );

	mov	ecx, 158				; 0000009eH
	call	EmitError
	jmp	SHORT $LN1@SetRenameK
$LN7@SetRenameK:

; 702  :     }
; 703  :     RenameKeyword( index, tokenarray[i].string_ptr, strlen( tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	strlen
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	movzx	r8d, al
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	mov	ecx, DWORD PTR index$[rsp]
	call	RenameKeyword

; 704  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 705  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 706  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetRenameK:

; 707  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SetRenameKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 52
opndx$ = 96
pi$ = 240
tokenarray$ = 248
SetElf	PROC

; 642  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 224				; 000000e0H
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+240]

; 643  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 644  :     struct expr opndx;
; 645  : 
; 646  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN2@SetElf

; 647  :         return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@SetElf
$LN2@SetElf:

; 648  :     if ( opndx.kind == EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN3@SetElf

; 649  :         if ( opndx.llvalue > 0xFF ) {

	cmp	QWORD PTR opndx$[rsp], 255		; 000000ffH
	jbe	SHORT $LN5@SetElf

; 650  :             return( EmitConstError( &opndx ) );

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	SHORT $LN1@SetElf
$LN5@SetElf:

; 651  :         }
; 652  :         if ( Options.output_format == OFORMAT_ELF )

	cmp	DWORD PTR Options+160, 3
	jne	SHORT $LN6@SetElf

; 653  :             ModuleInfo.elf_osabi = opndx.value;

	movzx	eax, BYTE PTR opndx$[rsp]
	mov	BYTE PTR ModuleInfo+412, al
$LN6@SetElf:

; 654  :     } else {

	jmp	SHORT $LN4@SetElf
$LN3@SetElf:

; 655  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	SHORT $LN1@SetElf
$LN4@SetElf:

; 656  :     }
; 657  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 658  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetElf:

; 659  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:SetElf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 224				; 000000e0H
	pop	rdi
	ret	0
SetElf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 32
pi$ = 64
tokenarray$ = 72
SetFrame PROC

; 624  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 625  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 626  : 
; 627  :     if ( 0 == _stricmp( tokenarray[i].string_ptr, "AUTO" ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG11096
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN2@SetFrame

; 628  :         ModuleInfo.frame_auto = 1;

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 17
	mov	DWORD PTR ModuleInfo+408, eax

; 629  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN3@SetFrame
$LN2@SetFrame:

; 630  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "NOAUTO" ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG11098
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN4@SetFrame

; 631  :         ModuleInfo.frame_auto = 0;

	mov	eax, DWORD PTR ModuleInfo+408
	btr	eax, 17
	mov	DWORD PTR ModuleInfo+408, eax

; 632  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SetFrame:
$LN3@SetFrame:

; 633  :     }
; 634  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 635  :     return( NOT_ERROR );

	xor	eax, eax

; 636  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SetFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 52
j$ = 68
parms$ = 72
opndx$ = 96
k$5 = 212
pi$ = 240
tokenarray$ = 248
SetMZ	PROC

; 568  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 224				; 000000e0H
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+240]

; 569  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 570  :     int j;
; 571  :     uint_16 *parms;
; 572  :     struct expr opndx;
; 573  : 
; 574  :     for ( j = 0, parms = (uint_16 *)&ModuleInfo.mz_data ; j < 4; j++ ) {

	mov	DWORD PTR j$[rsp], 0
	lea	rax, OFFSET FLAT:ModuleInfo+412
	mov	QWORD PTR parms$[rsp], rax
	jmp	SHORT $LN4@SetMZ
$LN2@SetMZ:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN4@SetMZ:
	cmp	DWORD PTR j$[rsp], 4
	jge	$LN3@SetMZ

; 575  :         int k;
; 576  :         for ( k = i; tokenarray[k].token != T_FINAL; k++ )

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR k$5[rsp], eax
	jmp	SHORT $LN7@SetMZ
$LN5@SetMZ:
	mov	eax, DWORD PTR k$5[rsp]
	inc	eax
	mov	DWORD PTR k$5[rsp], eax
$LN7@SetMZ:
	movsxd	rax, DWORD PTR k$5[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN6@SetMZ

; 577  :             if ( tokenarray[k].token == T_COMMA ||
; 578  :                 tokenarray[k].token == T_COLON ||

	movsxd	rax, DWORD PTR k$5[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN12@SetMZ
	movsxd	rax, DWORD PTR k$5[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN12@SetMZ
	movsxd	rax, DWORD PTR k$5[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 13
	jne	SHORT $LN11@SetMZ
$LN12@SetMZ:

; 579  :                 tokenarray[k].token == T_DBL_COLON )
; 580  :                 break;

	jmp	SHORT $LN6@SetMZ
$LN11@SetMZ:
	jmp	$LN5@SetMZ
$LN6@SetMZ:

; 581  :         if ( EvalOperand( &i, tokenarray, k, &opndx, 0 ) == ERROR )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR k$5[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN13@SetMZ

; 582  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@SetMZ
$LN13@SetMZ:

; 583  :         if ( opndx.kind == EXPR_EMPTY ) {

	cmp	DWORD PTR opndx$[rsp+60], -2
	jne	SHORT $LN14@SetMZ
	jmp	SHORT $LN15@SetMZ
$LN14@SetMZ:

; 584  :         } else if ( opndx.kind == EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN16@SetMZ

; 585  :             if ( opndx.value64 > 0xFFFF ) {

	cmp	QWORD PTR opndx$[rsp], 65535		; 0000ffffH
	jle	SHORT $LN18@SetMZ

; 586  :                 return( EmitConstError( &opndx ) );

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	$LN1@SetMZ
$LN18@SetMZ:

; 587  :             }
; 588  :             if ( ModuleInfo.sub_format == SFORMAT_MZ )

	cmp	DWORD PTR ModuleInfo+372, 1
	jne	SHORT $LN19@SetMZ

; 589  :                 *(parms + j) = opndx.value;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR parms$[rsp]
	movzx	edx, WORD PTR opndx$[rsp]
	mov	WORD PTR [rcx+rax*2], dx
$LN19@SetMZ:

; 590  :         } else {

	jmp	SHORT $LN17@SetMZ
$LN16@SetMZ:

; 591  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN1@SetMZ
$LN17@SetMZ:
$LN15@SetMZ:

; 592  :         }
; 593  :         if ( tokenarray[i].token == T_COLON )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN20@SetMZ

; 594  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN21@SetMZ
$LN20@SetMZ:

; 595  :         else if ( tokenarray[i].token == T_DBL_COLON ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 13
	jne	SHORT $LN22@SetMZ

; 596  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 597  :             j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN22@SetMZ:
$LN21@SetMZ:

; 598  :         }
; 599  :     }

	jmp	$LN2@SetMZ
$LN3@SetMZ:

; 600  : 
; 601  :     /* ensure data integrity of the params */
; 602  :     if ( ModuleInfo.sub_format == SFORMAT_MZ ) {

	cmp	DWORD PTR ModuleInfo+372, 1
	jne	SHORT $LN23@SetMZ

; 603  :         if ( ModuleInfo.mz_data.ofs_fixups < 0x1E )

	movzx	eax, WORD PTR ModuleInfo+412
	cmp	eax, 30
	jge	SHORT $LN24@SetMZ

; 604  :             ModuleInfo.mz_data.ofs_fixups = 0x1E;

	mov	eax, 30
	mov	WORD PTR ModuleInfo+412, ax
$LN24@SetMZ:

; 605  : 
; 606  :         for( j = 16; j < ModuleInfo.mz_data.alignment; j <<= 1 );

	mov	DWORD PTR j$[rsp], 16
	jmp	SHORT $LN10@SetMZ
$LN8@SetMZ:
	mov	eax, DWORD PTR j$[rsp]
	shl	eax, 1
	mov	DWORD PTR j$[rsp], eax
$LN10@SetMZ:
	movzx	eax, WORD PTR ModuleInfo+414
	cmp	DWORD PTR j$[rsp], eax
	jge	SHORT $LN9@SetMZ
	jmp	SHORT $LN8@SetMZ
$LN9@SetMZ:

; 607  :         if( j != ModuleInfo.mz_data.alignment )

	movzx	eax, WORD PTR ModuleInfo+414
	cmp	DWORD PTR j$[rsp], eax
	je	SHORT $LN25@SetMZ

; 608  :             EmitError( INVALID_HEADER_ALIGNMENT );

	mov	ecx, 205				; 000000cdH
	call	EmitError
$LN25@SetMZ:

; 609  : 
; 610  :         if ( ModuleInfo.mz_data.heapmax < ModuleInfo.mz_data.heapmin )

	movzx	eax, WORD PTR ModuleInfo+418
	movzx	ecx, WORD PTR ModuleInfo+416
	cmp	eax, ecx
	jge	SHORT $LN26@SetMZ

; 611  :             ModuleInfo.mz_data.heapmax = ModuleInfo.mz_data.heapmin;

	movzx	eax, WORD PTR ModuleInfo+416
	mov	WORD PTR ModuleInfo+418, ax
$LN26@SetMZ:
$LN23@SetMZ:

; 612  :     }
; 613  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 614  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetMZ:

; 615  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:SetMZ$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 224				; 000000e0H
	pop	rdi
	ret	0
SetMZ	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 52
temp$ = 68
temp2$ = 72
opndx$ = 96
pi$ = 240
tokenarray$ = 248
SetProcAlign PROC

; 542  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 224				; 000000e0H
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+240]

; 543  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 544  :     int temp, temp2;
; 545  :     struct expr opndx;
; 546  : 
; 547  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	BYTE PTR [rsp+32], 2
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN5@SetProcAli

; 548  :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@SetProcAli
$LN5@SetProcAli:

; 549  :     if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN6@SetProcAli

; 550  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	SHORT $LN1@SetProcAli
$LN6@SetProcAli:

; 551  :     }
; 552  :     if( opndx.value > MAX_STRUCT_ALIGN ) {

	cmp	DWORD PTR opndx$[rsp], 32		; 00000020H
	jle	SHORT $LN7@SetProcAli

; 553  :         EmitError( STRUCT_ALIGN_TOO_HIGH );

	mov	ecx, 214				; 000000d6H
	call	EmitError
$LN7@SetProcAli:

; 554  :     }
; 555  :     for( temp = 1, temp2 = 0; temp < opndx.value ; temp <<= 1, temp2++ );

	mov	DWORD PTR temp$[rsp], 1
	mov	DWORD PTR temp2$[rsp], 0
	jmp	SHORT $LN4@SetProcAli
$LN2@SetProcAli:
	mov	eax, DWORD PTR temp$[rsp]
	shl	eax, 1
	mov	DWORD PTR temp$[rsp], eax
	mov	eax, DWORD PTR temp2$[rsp]
	inc	eax
	mov	DWORD PTR temp2$[rsp], eax
$LN4@SetProcAli:
	mov	eax, DWORD PTR opndx$[rsp]
	cmp	DWORD PTR temp$[rsp], eax
	jge	SHORT $LN3@SetProcAli
	jmp	SHORT $LN2@SetProcAli
$LN3@SetProcAli:

; 556  :     if( temp != opndx.value ) {

	mov	eax, DWORD PTR opndx$[rsp]
	cmp	DWORD PTR temp$[rsp], eax
	je	SHORT $LN8@SetProcAli

; 557  :         return( EmitErr( POWER_OF_2, opndx.value ) );

	mov	edx, DWORD PTR opndx$[rsp]
	mov	ecx, 129				; 00000081H
	call	EmitErr
	jmp	SHORT $LN1@SetProcAli
$LN8@SetProcAli:

; 558  :     }
; 559  :     ModuleInfo.procalign = temp2;

	movzx	eax, BYTE PTR temp2$[rsp]
	mov	BYTE PTR ModuleInfo+399, al

; 560  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 561  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetProcAli:

; 562  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:SetProcAlign$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 224				; 000000e0H
	pop	rdi
	ret	0
SetProcAlign ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 52
temp$ = 68
temp2$ = 72
opndx$ = 96
pi$ = 240
tokenarray$ = 248
SetFieldAlign PROC

; 514  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 224				; 000000e0H
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+240]

; 515  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 516  :     unsigned temp, temp2;
; 517  :     struct expr opndx;
; 518  : 
; 519  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	BYTE PTR [rsp+32], 2
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN5@SetFieldAl

; 520  :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@SetFieldAl
$LN5@SetFieldAl:

; 521  :     if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN6@SetFieldAl

; 522  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	SHORT $LN1@SetFieldAl
$LN6@SetFieldAl:

; 523  :     }
; 524  :     if( opndx.uvalue > MAX_STRUCT_ALIGN ) {

	cmp	DWORD PTR opndx$[rsp], 32		; 00000020H
	jbe	SHORT $LN7@SetFieldAl

; 525  :         return( EmitError( STRUCT_ALIGN_TOO_HIGH ) );

	mov	ecx, 214				; 000000d6H
	call	EmitError
	jmp	SHORT $LN1@SetFieldAl
$LN7@SetFieldAl:

; 526  :     }
; 527  :     for( temp = 1, temp2 = 0; temp < opndx.uvalue ; temp <<= 1, temp2++ );

	mov	DWORD PTR temp$[rsp], 1
	mov	DWORD PTR temp2$[rsp], 0
	jmp	SHORT $LN4@SetFieldAl
$LN2@SetFieldAl:
	mov	eax, DWORD PTR temp$[rsp]
	shl	eax, 1
	mov	DWORD PTR temp$[rsp], eax
	mov	eax, DWORD PTR temp2$[rsp]
	inc	eax
	mov	DWORD PTR temp2$[rsp], eax
$LN4@SetFieldAl:
	mov	eax, DWORD PTR opndx$[rsp]
	cmp	DWORD PTR temp$[rsp], eax
	jae	SHORT $LN3@SetFieldAl
	jmp	SHORT $LN2@SetFieldAl
$LN3@SetFieldAl:

; 528  :     if( temp != opndx.uvalue ) {

	mov	eax, DWORD PTR opndx$[rsp]
	cmp	DWORD PTR temp$[rsp], eax
	je	SHORT $LN8@SetFieldAl

; 529  :         return( EmitErr( POWER_OF_2, opndx.value ) );

	mov	edx, DWORD PTR opndx$[rsp]
	mov	ecx, 129				; 00000081H
	call	EmitErr
	jmp	SHORT $LN1@SetFieldAl
$LN8@SetFieldAl:

; 530  :     }
; 531  :     ModuleInfo.fieldalign = temp2;

	movzx	eax, BYTE PTR temp2$[rsp]
	mov	BYTE PTR ModuleInfo+397, al

; 532  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 533  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetFieldAl:

; 534  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:SetFieldAlign$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 224				; 000000e0H
	pop	rdi
	ret	0
SetFieldAlign ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 32
pi$ = 64
tokenarray$ = 72
SetSegment PROC

; 483  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 484  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 485  : 
; 486  :     if ( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_FLAT ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 7
	jne	SHORT $LN2@SetSegment
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 261		; 00000105H
	jne	SHORT $LN2@SetSegment

; 487  : #if AMD64_SUPPORT
; 488  :         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_64 )

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 112				; 00000070H
	jl	SHORT $LN4@SetSegment

; 489  :             ModuleInfo.defOfssize = USE64;

	mov	BYTE PTR ModuleInfo+405, 2
	jmp	SHORT $LN5@SetSegment
$LN4@SetSegment:

; 490  :         else
; 491  : #endif
; 492  :             ModuleInfo.defOfssize = USE32;

	mov	BYTE PTR ModuleInfo+405, 1
$LN5@SetSegment:

; 493  :     } else if ( tokenarray[i].token == T_ID && _stricmp( tokenarray[i].string_ptr, "USE16" ) == 0) {

	jmp	$LN3@SetSegment
$LN2@SetSegment:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN6@SetSegment
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG11009
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN6@SetSegment

; 494  :         ModuleInfo.defOfssize = USE16;

	mov	BYTE PTR ModuleInfo+405, 0
	jmp	$LN7@SetSegment
$LN6@SetSegment:

; 495  :     } else if ( tokenarray[i].token == T_ID && _stricmp( tokenarray[i].string_ptr, "USE32" ) == 0) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN8@SetSegment
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG11012
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN8@SetSegment

; 496  :         ModuleInfo.defOfssize = USE32;

	mov	BYTE PTR ModuleInfo+405, 1
	jmp	SHORT $LN9@SetSegment
$LN8@SetSegment:

; 497  : #if AMD64_SUPPORT
; 498  :     } else if ( tokenarray[i].token == T_ID && _stricmp( tokenarray[i].string_ptr, "USE64" ) == 0) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN10@SetSegment
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG11015
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN10@SetSegment

; 499  :         ModuleInfo.defOfssize = USE64;

	mov	BYTE PTR ModuleInfo+405, 2

; 500  : #endif
; 501  :     } else {

	jmp	SHORT $LN11@SetSegment
$LN10@SetSegment:

; 502  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@SetSegment
$LN11@SetSegment:
$LN9@SetSegment:
$LN7@SetSegment:
$LN3@SetSegment:

; 503  :     }
; 504  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 505  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 506  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetSegment:

; 507  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SetSegment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 32
tv69 = 36
pi$ = 64
tokenarray$ = 72
SetProc	PROC

; 449  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 450  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 451  : 
; 452  :     switch ( tokenarray[i].token ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR tv69[rsp], al
	cmp	BYTE PTR tv69[rsp], 3
	je	$LN8@SetProc
	cmp	BYTE PTR tv69[rsp], 8
	je	SHORT $LN4@SetProc
	jmp	$LN2@SetProc
$LN4@SetProc:

; 453  :     case T_ID:
; 454  :         if ( 0 == _stricmp( tokenarray[i].string_ptr, "PRIVATE" ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG10991
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN5@SetProc

; 455  :             ModuleInfo.procs_private = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	or	eax, 4
	mov	DWORD PTR ModuleInfo+408, eax

; 456  :             ModuleInfo.procs_export = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -9					; fffffff7H
	mov	DWORD PTR ModuleInfo+408, eax

; 457  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN6@SetProc
$LN5@SetProc:

; 458  :         } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "EXPORT" ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG10993
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN7@SetProc

; 459  :             ModuleInfo.procs_private = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -5					; fffffffbH
	mov	DWORD PTR ModuleInfo+408, eax

; 460  :             ModuleInfo.procs_export = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	or	eax, 8
	mov	DWORD PTR ModuleInfo+408, eax

; 461  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@SetProc:
$LN6@SetProc:

; 462  :         }
; 463  :         break;

	jmp	SHORT $LN2@SetProc
$LN8@SetProc:

; 464  :     case T_DIRECTIVE: /* word PUBLIC is a directive */
; 465  :         if ( tokenarray[i].tokval == T_PUBLIC ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 426		; 000001aaH
	jne	SHORT $LN9@SetProc

; 466  :             ModuleInfo.procs_private = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -5					; fffffffbH
	mov	DWORD PTR ModuleInfo+408, eax

; 467  :             ModuleInfo.procs_export = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -9					; fffffff7H
	mov	DWORD PTR ModuleInfo+408, eax

; 468  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN9@SetProc:
$LN2@SetProc:

; 469  :         }
; 470  :         break;
; 471  :     }
; 472  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 473  :     return( NOT_ERROR );

	xor	eax, eax

; 474  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SetProc	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 32
pi$ = 64
tokenarray$ = 72
SetOffset PROC

; 428  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 429  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 430  : 
; 431  :     if ( 0 == _stricmp( tokenarray[i].string_ptr, "GROUP" ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG10972
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN2@SetOffset

; 432  :         ModuleInfo.offsettype = OT_GROUP;

	mov	DWORD PTR ModuleInfo+384, 0
	jmp	SHORT $LN3@SetOffset
$LN2@SetOffset:

; 433  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "FLAT" ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG10975
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN4@SetOffset

; 434  :         ModuleInfo.offsettype = OT_FLAT;

	mov	DWORD PTR ModuleInfo+384, 1
	jmp	SHORT $LN5@SetOffset
$LN4@SetOffset:

; 435  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "SEGMENT" ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG10978
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN6@SetOffset

; 436  :         ModuleInfo.offsettype = OT_SEGMENT;

	mov	DWORD PTR ModuleInfo+384, 2

; 437  :     } else {

	jmp	SHORT $LN7@SetOffset
$LN6@SetOffset:

; 438  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@SetOffset
$LN7@SetOffset:
$LN5@SetOffset:
$LN3@SetOffset:

; 439  :     }
; 440  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 441  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 442  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetOffset:

; 443  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SetOffset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 32
pi$ = 64
tokenarray$ = 72
SetEpilogue PROC

; 396  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 397  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 398  : 
; 399  :     if ( tokenarray[i].token != T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN2@SetEpilogu

; 400  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@SetEpilogu
$LN2@SetEpilogu:

; 401  :     }
; 402  :     if ( ModuleInfo.proc_epilogue ) {

	cmp	QWORD PTR ModuleInfo+328, 0
	je	SHORT $LN3@SetEpilogu

; 403  :         LclFree( ModuleInfo.proc_epilogue );
; 404  :         ModuleInfo.proc_epilogue = NULL;

	mov	QWORD PTR ModuleInfo+328, 0
$LN3@SetEpilogu:

; 405  :     }
; 406  : 
; 407  :     if ( 0 == _stricmp( tokenarray[i].string_ptr, "NONE" ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG10959
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN4@SetEpilogu

; 408  :         ModuleInfo.epiloguemode = PEM_NONE;

	mov	BYTE PTR ModuleInfo+425, 2
	jmp	SHORT $LN5@SetEpilogu
$LN4@SetEpilogu:

; 409  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "EPILOGUEDEF" ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG10962
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN6@SetEpilogu

; 410  :         ModuleInfo.epiloguemode = PEM_DEFAULT;

	mov	BYTE PTR ModuleInfo+425, 0

; 411  :     } else {

	jmp	SHORT $LN7@SetEpilogu
$LN6@SetEpilogu:

; 412  :         ModuleInfo.epiloguemode = PEM_MACRO;

	mov	BYTE PTR ModuleInfo+425, 1

; 413  :         ModuleInfo.proc_epilogue = LclAlloc( strlen( tokenarray[i].string_ptr ) + 1);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	strlen
	inc	rax
	mov	rcx, rax
	call	LclAlloc
	mov	QWORD PTR ModuleInfo+328, rax

; 414  :         strcpy( ModuleInfo.proc_epilogue, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	rcx, QWORD PTR ModuleInfo+328
	call	strcpy
$LN7@SetEpilogu:
$LN5@SetEpilogu:

; 415  :     }
; 416  : 
; 417  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 418  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 419  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetEpilogu:

; 420  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SetEpilogue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 32
pi$ = 64
tokenarray$ = 72
SetPrologue PROC

; 364  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 365  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 366  : 
; 367  :     if ( tokenarray[i].token != T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN2@SetPrologu

; 368  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@SetPrologu
$LN2@SetPrologu:

; 369  :     }
; 370  :     if ( ModuleInfo.proc_prologue ) {

	cmp	QWORD PTR ModuleInfo+320, 0
	je	SHORT $LN3@SetPrologu

; 371  :         LclFree( ModuleInfo.proc_prologue );
; 372  :         ModuleInfo.proc_prologue = NULL;

	mov	QWORD PTR ModuleInfo+320, 0
$LN3@SetPrologu:

; 373  :     }
; 374  :     if ( 0 == _stricmp( tokenarray[i].string_ptr, "NONE" ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG10943
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN4@SetPrologu

; 375  :         ModuleInfo.prologuemode = PEM_NONE;

	mov	BYTE PTR ModuleInfo+424, 2
	jmp	SHORT $LN5@SetPrologu
$LN4@SetPrologu:

; 376  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "PROLOGUEDEF" ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG10946
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN6@SetPrologu

; 377  :         ModuleInfo.prologuemode = PEM_DEFAULT;

	mov	BYTE PTR ModuleInfo+424, 0

; 378  :     } else {

	jmp	SHORT $LN7@SetPrologu
$LN6@SetPrologu:

; 379  :         ModuleInfo.prologuemode = PEM_MACRO;

	mov	BYTE PTR ModuleInfo+424, 1

; 380  :         ModuleInfo.proc_prologue = LclAlloc( strlen( tokenarray[i].string_ptr ) + 1);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	strlen
	inc	rax
	mov	rcx, rax
	call	LclAlloc
	mov	QWORD PTR ModuleInfo+320, rax

; 381  :         strcpy( ModuleInfo.proc_prologue, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	rcx, QWORD PTR ModuleInfo+320
	call	strcpy
$LN7@SetPrologu:
$LN5@SetPrologu:

; 382  :     }
; 383  : 
; 384  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 385  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 386  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetPrologu:

; 387  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SetPrologue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 32
pi$ = 64
tokenarray$ = 72
SetSetIF2 PROC

; 331  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 332  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 333  : 
; 334  :     if ( 0 == _stricmp( tokenarray[i].string_ptr, "TRUE" ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG10928
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN2@SetSetIF2

; 335  :         ModuleInfo.setif2 = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 10
	mov	DWORD PTR ModuleInfo+408, eax

; 336  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN3@SetSetIF2
$LN2@SetSetIF2:

; 337  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "FALSE" ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG10930
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN4@SetSetIF2

; 338  :         ModuleInfo.setif2 = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	btr	eax, 10
	mov	DWORD PTR ModuleInfo+408, eax

; 339  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SetSetIF2:
$LN3@SetSetIF2:

; 340  :     }
; 341  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 342  :     return( NOT_ERROR );

	xor	eax, eax

; 343  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SetSetIF2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 36
pi$ = 80
tokenarray$ = 88
SetLanguage PROC

; 308  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 309  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 310  :     //lang_type langtype;
; 311  :     //int language = ERROR;
; 312  : 
; 313  :     if ( tokenarray[i].token == T_RES_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 7
	jne	SHORT $LN2@SetLanguag

; 314  :         if ( GetLangType( &i, tokenarray, &ModuleInfo.langtype ) == NOT_ERROR ) {

	lea	r8, OFFSET FLAT:ModuleInfo+364
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	GetLangType
	test	eax, eax
	jne	SHORT $LN3@SetLanguag

; 315  :             /* update @Interface assembly time variable */
; 316  :             if ( ModuleInfo.model != MODEL_NONE && sym_Interface )

	cmp	DWORD PTR ModuleInfo+360, 0
	je	SHORT $LN4@SetLanguag
	cmp	QWORD PTR sym_Interface, 0
	je	SHORT $LN4@SetLanguag

; 317  :                 sym_Interface->value = ModuleInfo.langtype;

	mov	rax, QWORD PTR sym_Interface
	mov	ecx, DWORD PTR ModuleInfo+364
	mov	DWORD PTR [rax+16], ecx
$LN4@SetLanguag:

; 318  :             *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 319  :             return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@SetLanguag
$LN3@SetLanguag:
$LN2@SetLanguag:

; 320  :         }
; 321  :     }
; 322  :     return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN1@SetLanguag:

; 323  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:SetLanguage$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
SetLanguage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 32
index$ = 36
p$ = 40
p2$1 = 48
cnt$2 = 56
pi$ = 80
tokenarray$ = 88
SetNoKeyword PROC

; 260  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 261  :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 262  :     //struct ReservedWord *resw;
; 263  :     unsigned index;
; 264  :     char *p;
; 265  : 
; 266  :     if( Parse_Pass != PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN12@SetNoKeywo

; 267  :         SkipOption( pi, tokenarray );

	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR pi$[rsp]
	call	SkipOption

; 268  :         return( NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@SetNoKeywo
$LN12@SetNoKeywo:

; 269  :     }
; 270  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN14@SetNoKeywo
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN13@SetNoKeywo
$LN14@SetNoKeywo:

; 271  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@SetNoKeywo
$LN13@SetNoKeywo:

; 272  :     }
; 273  :     for ( p = tokenarray[i].string_ptr; *p; ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR p$[rsp], rax
$LN2@SetNoKeywo:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@SetNoKeywo
$LN5@SetNoKeywo:

; 274  :         while ( isspace( *p ) ) p++;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN6@SetNoKeywo
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN5@SetNoKeywo
$LN6@SetNoKeywo:

; 275  :         if ( *p ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN15@SetNoKeywo

; 276  :             char *p2 = p;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR p2$1[rsp], rax

; 277  :             unsigned char cnt;
; 278  :             //struct instr_item *instruct;
; 279  :             for ( ;*p; p++ ) {

	jmp	SHORT $LN9@SetNoKeywo
$LN7@SetNoKeywo:
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN9@SetNoKeywo:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN8@SetNoKeywo

; 280  :                 if ( isspace( *p ) || *p == ',' )

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	jne	SHORT $LN17@SetNoKeywo
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN16@SetNoKeywo
$LN17@SetNoKeywo:

; 281  :                     break;

	jmp	SHORT $LN8@SetNoKeywo
$LN16@SetNoKeywo:

; 282  :             }

	jmp	SHORT $LN7@SetNoKeywo
$LN8@SetNoKeywo:

; 283  :             cnt = p - p2;

	mov	rax, QWORD PTR p2$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR cnt$2[rsp], al

; 284  :             /* todo: if MAX_ID_LEN can be > 255, then check size,
; 285  :              * since a reserved word's size must be <= 255
; 286  :              */
; 287  :             index = FindResWord( p2, cnt );

	movzx	edx, BYTE PTR cnt$2[rsp]
	mov	rcx, QWORD PTR p2$1[rsp]
	call	FindResWord
	mov	DWORD PTR index$[rsp], eax

; 288  :             if ( index != 0 )

	cmp	DWORD PTR index$[rsp], 0
	je	SHORT $LN18@SetNoKeywo

; 289  :                 DisableKeyword( index );

	mov	ecx, DWORD PTR index$[rsp]
	call	DisableKeyword
	jmp	SHORT $LN19@SetNoKeywo
$LN18@SetNoKeywo:

; 290  :             else {
; 291  :                 if ( IsKeywordDisabled( p2, cnt ) ) {

	movzx	eax, BYTE PTR cnt$2[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR p2$1[rsp]
	call	IsKeywordDisabled
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@SetNoKeywo

; 292  :                     return( EmitError( RESERVED_WORD_EXPECTED ) );

	mov	ecx, 158				; 0000009eH
	call	EmitError
	jmp	SHORT $LN1@SetNoKeywo
$LN20@SetNoKeywo:
$LN19@SetNoKeywo:
$LN15@SetNoKeywo:
$LN10@SetNoKeywo:

; 293  :                 }
; 294  :             }
; 295  :         }
; 296  :         while ( isspace(*p) ) p++;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN11@SetNoKeywo
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN10@SetNoKeywo
$LN11@SetNoKeywo:

; 297  :         if (*p == ',') p++;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN21@SetNoKeywo
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN21@SetNoKeywo:

; 298  :     }

	jmp	$LN2@SetNoKeywo
$LN3@SetNoKeywo:

; 299  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 300  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 301  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetNoKeywo:

; 302  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
SetNoKeyword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 16
tokenarray$ = 24
SkipOption PROC

; 249  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
$LN2@SkipOption:

; 250  :     while ( tokenarray[*pi].token != T_FINAL &&

	mov	rax, QWORD PTR pi$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN3@SkipOption
	mov	rax, QWORD PTR pi$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN3@SkipOption

; 251  :            tokenarray[*pi].token != T_COMMA )
; 252  :         (*pi)++;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR pi$[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN2@SkipOption
$LN3@SkipOption:

; 253  : }

	pop	rdi
	ret	0
SkipOption ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 16
tokenarray$ = 24
SetNoSignExt PROC

; 242  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 243  :     ModuleInfo.NoSignExtend = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 18
	mov	DWORD PTR ModuleInfo+408, eax

; 244  :     return( NOT_ERROR );

	xor	eax, eax

; 245  : }

	pop	rdi
	ret	0
SetNoSignExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 16
tokenarray$ = 24
SetExpr32 PROC

; 235  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 236  :     /* default, nothing to do */
; 237  :     return( NOT_ERROR );

	xor	eax, eax

; 238  : }

	pop	rdi
	ret	0
SetExpr32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 16
tokenarray$ = 24
SetNoOldmacros PROC

; 226  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 227  :     /* default, nothing to do */
; 228  :     return( NOT_ERROR );

	xor	eax, eax

; 229  : }

	pop	rdi
	ret	0
SetNoOldmacros ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 16
tokenarray$ = 24
SetNoReadonly PROC

; 217  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 218  :     /* default, nothing to do */
; 219  :     return( NOT_ERROR );

	xor	eax, eax

; 220  : }

	pop	rdi
	ret	0
SetNoReadonly ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 16
tokenarray$ = 24
SetNoLJmp PROC

; 208  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 209  :     ModuleInfo.ljmp = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -33				; ffffffdfH
	mov	DWORD PTR ModuleInfo+408, eax

; 210  :     return( NOT_ERROR );

	xor	eax, eax

; 211  : }

	pop	rdi
	ret	0
SetNoLJmp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 16
tokenarray$ = 24
SetLJmp	PROC

; 199  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 200  :     ModuleInfo.ljmp = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	or	eax, 32					; 00000020H
	mov	DWORD PTR ModuleInfo+408, eax

; 201  :     return( NOT_ERROR );

	xor	eax, eax

; 202  : }

	pop	rdi
	ret	0
SetLJmp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 16
tokenarray$ = 24
SetNoEmulator PROC

; 190  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 191  :     ModuleInfo.emulator = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	btr	eax, 9
	mov	DWORD PTR ModuleInfo+408, eax

; 192  :     return( NOT_ERROR );

	xor	eax, eax

; 193  : }

	pop	rdi
	ret	0
SetNoEmulator ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 16
tokenarray$ = 24
SetEmulator PROC

; 181  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 182  :     ModuleInfo.emulator = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 9
	mov	DWORD PTR ModuleInfo+408, eax

; 183  :     return( NOT_ERROR );

	xor	eax, eax

; 184  : }

	pop	rdi
	ret	0
SetEmulator ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 16
tokenarray$ = 24
SetNoOldStructs PROC

; 172  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 173  :     ModuleInfo.oldstructs = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	btr	eax, 8
	mov	DWORD PTR ModuleInfo+408, eax

; 174  :     return( NOT_ERROR );

	xor	eax, eax

; 175  : }

	pop	rdi
	ret	0
SetNoOldStructs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 16
tokenarray$ = 24
SetOldStructs PROC

; 163  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 164  :     ModuleInfo.oldstructs = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 8
	mov	DWORD PTR ModuleInfo+408, eax

; 165  :     return( NOT_ERROR );

	xor	eax, eax

; 166  : }

	pop	rdi
	ret	0
SetOldStructs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 16
tokenarray$ = 24
SetNoScoped PROC

; 154  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 155  :     ModuleInfo.scoped = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	btr	eax, 7
	mov	DWORD PTR ModuleInfo+408, eax

; 156  :     return( NOT_ERROR );

	xor	eax, eax

; 157  : }

	pop	rdi
	ret	0
SetNoScoped ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 16
tokenarray$ = 24
SetScoped PROC

; 145  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 146  :     ModuleInfo.scoped = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 7
	mov	DWORD PTR ModuleInfo+408, eax

; 147  :     return( NOT_ERROR );

	xor	eax, eax

; 148  : }

	pop	rdi
	ret	0
SetScoped ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetNoM510 PROC

; 136  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 137  :     SetMasm510(FALSE);

	xor	ecx, ecx
	call	SetMasm510

; 138  :     return( NOT_ERROR );

	xor	eax, eax

; 139  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetNoM510 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetM510	PROC

; 127  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 128  :     SetMasm510( TRUE );

	mov	cl, 1
	call	SetMasm510

; 129  :     return( NOT_ERROR );

	xor	eax, eax

; 130  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetM510	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 32
pi$ = 64
tokenarray$ = 72
SetCaseMap PROC

; 98   : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 99   :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 100  :     if ( tokenarray[i].token == T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN2@SetCaseMap

; 101  :         if ( 0 == _stricmp( tokenarray[i].string_ptr, "NONE" ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG10778
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN4@SetCaseMap

; 102  :             ModuleInfo.case_sensitive = TRUE;        /* -Cx */

	mov	eax, DWORD PTR ModuleInfo+408
	or	eax, 1
	mov	DWORD PTR ModuleInfo+408, eax

; 103  :             ModuleInfo.convert_uppercase = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -3					; fffffffdH
	mov	DWORD PTR ModuleInfo+408, eax
	jmp	$LN5@SetCaseMap
$LN4@SetCaseMap:

; 104  :         } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "NOTPUBLIC" ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG10781
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN6@SetCaseMap

; 105  :             ModuleInfo.case_sensitive = FALSE;       /* -Cp */

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ModuleInfo+408, eax

; 106  :             ModuleInfo.convert_uppercase = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -3					; fffffffdH
	mov	DWORD PTR ModuleInfo+408, eax
	jmp	SHORT $LN7@SetCaseMap
$LN6@SetCaseMap:

; 107  :         } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "ALL" ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG10784
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN8@SetCaseMap

; 108  :             ModuleInfo.case_sensitive = FALSE;       /* -Cu */

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ModuleInfo+408, eax

; 109  :             ModuleInfo.convert_uppercase = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	or	eax, 2
	mov	DWORD PTR ModuleInfo+408, eax

; 110  :         } else {

	jmp	SHORT $LN9@SetCaseMap
$LN8@SetCaseMap:

; 111  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@SetCaseMap
$LN9@SetCaseMap:
$LN7@SetCaseMap:
$LN5@SetCaseMap:

; 112  :         }
; 113  :         DebugMsg1(("SetCaseMap(%s) ok\n", tokenarray[i].string_ptr ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG10785
	call	DoDebugMsg1

; 114  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 115  :         SymSetCmpFunc();

	call	SymSetCmpFunc

; 116  :     } else {

	jmp	SHORT $LN3@SetCaseMap
$LN2@SetCaseMap:

; 117  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@SetCaseMap
$LN3@SetCaseMap:

; 118  :     }
; 119  :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 120  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetCaseMap:

; 121  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SetCaseMap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 16
tokenarray$ = 24
SetNoDotName PROC

; 89   : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 90   :     ModuleInfo.dotname = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -17				; ffffffefH
	mov	DWORD PTR ModuleInfo+408, eax

; 91   :     return( NOT_ERROR );

	xor	eax, eax

; 92   : }

	pop	rdi
	ret	0
SetNoDotName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
pi$ = 16
tokenarray$ = 24
SetDotName PROC

; 80   : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 81   :     ModuleInfo.dotname = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	or	eax, 16
	mov	DWORD PTR ModuleInfo+408, eax

; 82   :     return( NOT_ERROR );

	xor	eax, eax

; 83   : }

	pop	rdi
	ret	0
SetDotName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 52
opndx$ = 96
pi$ = 240
tokenarray$ = 248
SetZeroLocals PROC

; 58   : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 224				; 000000e0H
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+240]

; 59   : 	int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 60   : 	struct expr opndx;
; 61   : 
; 62   : 	if (EvalOperand(&i, tokenarray, Token_Count, &opndx, 0) == ERROR)

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN2@SetZeroLoc

; 63   : 		return(ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@SetZeroLoc
$LN2@SetZeroLoc:

; 64   : 	if (opndx.kind == EXPR_CONST) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN3@SetZeroLoc

; 65   : 		if (opndx.llvalue > 1) {

	cmp	QWORD PTR opndx$[rsp], 1
	jbe	SHORT $LN5@SetZeroLoc

; 66   : 			return(EmitConstError(&opndx));

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	SHORT $LN1@SetZeroLoc
$LN5@SetZeroLoc:

; 67   : 		}
; 68   : 		ZEROLOCALS = opndx.llvalue;

	movzx	eax, BYTE PTR opndx$[rsp]
	mov	BYTE PTR ZEROLOCALS, al

; 69   : 	}

	jmp	SHORT $LN4@SetZeroLoc
$LN3@SetZeroLoc:

; 70   : 	else {
; 71   : 		return(EmitError(CONSTANT_EXPECTED));

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	SHORT $LN1@SetZeroLoc
$LN4@SetZeroLoc:

; 72   : 	}
; 73   : 	*pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 74   : 	return(NOT_ERROR);

	xor	eax, eax
$LN1@SetZeroLoc:

; 75   : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:SetZeroLocals$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 224				; 000000e0H
	pop	rdi
	ret	0
SetZeroLocals ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
_TEXT	SEGMENT
i$ = 52
opndx$ = 96
pi$ = 240
tokenarray$ = 248
SetEvex	PROC

; 37   : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 224				; 000000e0H
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+240]

; 38   : 	int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 39   : 	struct expr opndx;
; 40   : 
; 41   : 	if (EvalOperand(&i, tokenarray, Token_Count, &opndx, 0) == ERROR)

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN2@SetEvex

; 42   : 		return(ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@SetEvex
$LN2@SetEvex:

; 43   : 	if (opndx.kind == EXPR_CONST) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN3@SetEvex

; 44   : 		if (opndx.llvalue > 1) {

	cmp	QWORD PTR opndx$[rsp], 1
	jbe	SHORT $LN5@SetEvex

; 45   : 			return(EmitConstError(&opndx));

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	SHORT $LN1@SetEvex
$LN5@SetEvex:

; 46   : 		}
; 47   : 		evex = opndx.llvalue;

	movzx	eax, BYTE PTR opndx$[rsp]
	mov	BYTE PTR evex, al

; 48   : 	}

	jmp	SHORT $LN4@SetEvex
$LN3@SetEvex:

; 49   : 	else {
; 50   : 		return(EmitError(CONSTANT_EXPECTED));

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	SHORT $LN1@SetEvex
$LN4@SetEvex:

; 51   : 	}
; 52   : 	*pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 53   : 	return(NOT_ERROR);

	xor	eax, eax
$LN1@SetEvex:

; 54   : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:SetEvex$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 224				; 000000e0H
	pop	rdi
	ret	0
SetEvex	ENDP
_TEXT	ENDS
END
