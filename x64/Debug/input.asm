; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	commentbuffer:QWORD
COMM	FileCur:QWORD
COMM	LineCur:QWORD
COMM	end_tokenarray:QWORD
COMM	end_stringbuf:QWORD
COMM	token_stringbuf:QWORD
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG10929 DB	01H DUP (?)
$SG10933 DB	01H DUP (?)
$SG10934 DB	01H DUP (?)
$SG10935 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG10805 DB	'AddFile(%s) enter, curr index=%u', 0aH, 00H
	ORG $+2
$SG10847 DB	'(%u)', 00H
	ORG $+3
$SG10913 DB	'%s : ', 00H
	ORG $+2
$SG10960 DB	'rb', 00H
	ORG $+1
$SG10849 DB	'[%s.%u]', 00H
$SG10887 DB	'PushMacro(%s)', 0aH, 00H
	ORG $+1
$SG10912 DB	'%s(%u) : ', 00H
	ORG $+2
$SG10992 DB	'rb', 00H
	ORG $+1
$SG10932 DB	'MacroLoop', 00H
	ORG $+2
$SG10996 DB	'rb', 00H
	ORG $+1
$SG10953 DB	'open_file_in_include_path(%s) enter', 0aH, 00H
	ORG $+3
$SG10959 DB	'open_file_in_include_path: >%s<', 0aH, 00H
	ORG $+3
$SG11035 DB	';', 00H
	ORG $+2
$SG10962 DB	'open_file_in_include_path()=%p', 0aH, 00H
$SG10986 DB	'SearchFile(%s) enter', 0aH, 00H
	ORG $+2
$SG10993 DB	'SearchFile(): file found, fopen(%s)=%X', 0aH, 00H
$SG10994 DB	'SearchFile(): fopen(%s) failed', 0aH, 00H
$SG10997 DB	'SearchFile(): fopen(%s)=%X', 0aH, 00H
	ORG $+4
$SG11001 DB	'SearchFile(): open_file_in_include_path(%s)=%X [%s]', 0aH
	DB	00H
	ORG $+3
$SG11002 DB	'SearchFile(): open_file_in_include_path(%s)=NULL', 0aH, 00H
	ORG $+6
$SG11017 DB	'GetTextLine: ***** EOF file %s (idx=%u) *****', 0aH, 00H
	ORG $+1
$SG11031 DB	'AddStringToIncludePath(%s) enter', 0aH, 00H
	ORG $+14
$SG11045 DB	'PushInputStatus() stringbuf-tokencnt-currsrc old=%X-%u-%'
	DB	'X new=%X-%X-%X', 0aH, 00H
$SG11050 DB	'PopInputStatus() old=%X-%u-%X new=%X-%u-%X', 0aH, 00H
	ORG $+4
$SG11061 DB	'InputInit() enter', 0aH, 00H
	ORG $+5
$SG11062 DB	'InputInit: srclinebuffer=%p, tokenarray=%p, token_string'
	DB	'buf=%p end_stringbuf=%p', 0aH, 00H
	ORG $+7
$SG11063 DB	'InputInit() exit', 0aH, 00H
	ORG $+6
$SG11066 DB	'InputPassInit() enter', 0aH, 00H
	ORG $+1
$SG11082 DB	'%2u: %5u *%2u %s', 0aH, 00H
	ORG $+6
$SG11083 DB	'%2u: %5u     %s', 0aH, 00H
	ORG $+7
$SG11084 DB	'InputFini: idx=%u name=%s', 0aH, 00H
	ORG $+5
$SG11087 DB	'lines read(files)/processed in pass one: %u / %u', 0aH, 00H
	ORG $+6
$SG11088 DB	'invokations: PreprocessLine=%u/%u/%u, Tokenize=%u/%u', 0aH
	DB	00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	GetLineNumber
PUBLIC	GetFNamePart
PUBLIC	GetExtPart
PUBLIC	SearchFile
PUBLIC	GetTextLine
PUBLIC	PushMacro
PUBLIC	SetLineNumber
PUBLIC	AddStringToIncludePath
PUBLIC	InputInit
PUBLIC	InputPassInit
PUBLIC	InputFini
PUBLIC	PushInputStatus
PUBLIC	PopInputStatus
PUBLIC	GetCurrSrcPos
PUBLIC	ClearSrcStack
PUBLIC	get_curr_srcfile
PUBLIC	set_curr_srcfile
PUBLIC	GetFName
PUBLIC	GetTopLine
PUBLIC	GetTopSrcName
PUBLIC	UpdateLineNumber
PUBLIC	print_source_nesting_structure
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isspace:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp_getc:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	memcpy:PROC
EXTRN	__imp_strchr:PROC
EXTRN	strcat:PROC
EXTRN	strcpy:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitErr:PROC
EXTRN	PrintNote:PROC
EXTRN	ErrnoStr:PROC
EXTRN	MemAlloc:PROC
EXTRN	MemFree:PROC
EXTRN	LclAlloc:PROC
EXTRN	fill_placeholders:PROC
EXTRN	DeleteLineQueue:PROC
EXTRN	GetLqLine:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	cnttok0:DWORD
EXTRN	cnttok1:DWORD
EXTRN	cntppl0:DWORD
EXTRN	cntppl1:DWORD
EXTRN	cntppl2:DWORD
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	8

SrcFree	DQ	01H DUP (?)
cntflines DD	01H DUP (?)
cntlines DD	01H DUP (?)
srclinebuffer DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$GetLineNumber DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$GetLineNumber
$pdata$GetFNamePart DD imagerel $LN8
	DD	imagerel $LN8+129
	DD	imagerel $unwind$GetFNamePart
$pdata$GetExtPart DD imagerel $LN12
	DD	imagerel $LN12+177
	DD	imagerel $unwind$GetExtPart
$pdata$SearchFile DD imagerel $LN23
	DD	imagerel $LN23+964
	DD	imagerel $unwind$SearchFile
$pdata$GetTextLine DD imagerel $LN17
	DD	imagerel $LN17+688
	DD	imagerel $unwind$GetTextLine
$pdata$PushMacro DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$PushMacro
$pdata$SetLineNumber DD imagerel $LN3
	DD	imagerel $LN3+21
	DD	imagerel $unwind$SetLineNumber
$pdata$AddStringToIncludePath DD imagerel $LN8
	DD	imagerel $LN8+276
	DD	imagerel $unwind$AddStringToIncludePath
$pdata$InputInit DD imagerel $LN3
	DD	imagerel $LN3+397
	DD	imagerel $unwind$InputInit
$pdata$InputPassInit DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$InputPassInit
$pdata$InputFini DD imagerel $LN12
	DD	imagerel $LN12+512
	DD	imagerel $unwind$InputFini
$pdata$PushInputStatus DD imagerel $LN5
	DD	imagerel $LN5+354
	DD	imagerel $unwind$PushInputStatus
$pdata$PopInputStatus DD imagerel $LN5
	DD	imagerel $LN5+288
	DD	imagerel $unwind$PopInputStatus
$pdata$GetCurrSrcPos DD imagerel $LN9
	DD	imagerel $LN9+183
	DD	imagerel $unwind$GetCurrSrcPos
$pdata$ClearSrcStack DD imagerel $LN7
	DD	imagerel $LN7+139
	DD	imagerel $unwind$ClearSrcStack
$pdata$get_curr_srcfile DD imagerel $LN7
	DD	imagerel $LN7+88
	DD	imagerel $unwind$get_curr_srcfile
$pdata$set_curr_srcfile DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$set_curr_srcfile
$pdata$GetFName DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$GetFName
$pdata$GetTopLine DD imagerel $LN6
	DD	imagerel $LN6+148
	DD	imagerel $unwind$GetTopLine
$pdata$GetTopSrcName DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$GetTopSrcName
$pdata$AddFile DD imagerel AddFile
	DD	imagerel AddFile+403
	DD	imagerel $unwind$AddFile
$pdata$FreeFiles DD imagerel FreeFiles
	DD	imagerel FreeFiles+71
	DD	imagerel $unwind$FreeFiles
$pdata$UpdateLineNumber DD imagerel $LN7
	DD	imagerel $LN7+103
	DD	imagerel $unwind$UpdateLineNumber
$pdata$my_fgets DD imagerel my_fgets
	DD	imagerel my_fgets+302
	DD	imagerel $unwind$my_fgets
$pdata$PushSrcItem DD imagerel PushSrcItem
	DD	imagerel PushSrcItem+165
	DD	imagerel $unwind$PushSrcItem
$pdata$print_source_nesting_structure DD imagerel $LN12
	DD	imagerel $LN12+428
	DD	imagerel $unwind$print_source_nesting_structure
$pdata$open_file_in_include_path DD imagerel open_file_in_include_path
	DD	imagerel open_file_in_include_path+477
	DD	imagerel $unwind$open_file_in_include_path
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
SearchFile$rtcName$0 DB 066H
	DB	075H
	DB	06cH
	DB	06cH
	DB	070H
	DB	061H
	DB	074H
	DB	068H
	DB	00H
	ORG $+7
SearchFile$rtcVarDesc DD 050H
	DD	0104H
	DQ	FLAT:SearchFile$rtcName$0
	ORG $+48
SearchFile$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:SearchFile$rtcVarDesc
CONST	ENDS
xdata	SEGMENT
$unwind$GetLineNumber DD 021501H
	DD	070023206H
$unwind$GetFNamePart DD 021e01H
	DD	07006120aH
$unwind$GetExtPart DD 021e01H
	DD	07006120aH
$unwind$SearchFile DD 033a19H
	DD	0340111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0198H
$unwind$GetTextLine DD 021e01H
	DD	07006920aH
$unwind$PushMacro DD 021e01H
	DD	07006320aH
$unwind$SetLineNumber DD 010501H
	DD	07005H
$unwind$AddStringToIncludePath DD 021e01H
	DD	07006520aH
$unwind$InputInit DD 021501H
	DD	070027206H
$unwind$InputPassInit DD 021501H
	DD	070023206H
$unwind$InputFini DD 021501H
	DD	070027206H
$unwind$PushInputStatus DD 021e01H
	DD	07006920aH
$unwind$PopInputStatus DD 021e01H
	DD	07006720aH
$unwind$GetCurrSrcPos DD 021e01H
	DD	07006520aH
$unwind$ClearSrcStack DD 021501H
	DD	070025206H
$unwind$get_curr_srcfile DD 021501H
	DD	070021206H
$unwind$set_curr_srcfile DD 010901H
	DD	07009H
$unwind$GetFName DD 010501H
	DD	07005H
$unwind$GetTopLine DD 021e01H
	DD	07006320aH
$unwind$GetTopSrcName DD 021501H
	DD	070023206H
$unwind$AddFile DD 021e01H
	DD	07006520aH
$unwind$FreeFiles DD 021501H
	DD	070023206H
$unwind$UpdateLineNumber DD 022301H
	DD	0700b120fH
$unwind$my_fgets DD 022701H
	DD	0700f7213H
$unwind$PushSrcItem DD 022201H
	DD	0700a520eH
$unwind$print_source_nesting_structure DD 021501H
	DD	070027206H
$unwind$open_file_in_include_path DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
printf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
printf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:printf$rtcName$0
	ORG $+48
printf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:printf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
curr$ = 32
next$ = 40
i$ = 48
namelen$ = 52
file$ = 56
name$ = 80
fullpath$ = 88
open_file_in_include_path PROC

; 538  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 539  :     char            *curr;
; 540  :     char            *next;
; 541  :     int             i;
; 542  :     int             namelen;
; 543  :     FILE            *file = NULL;

	mov	QWORD PTR file$[rsp], 0
$LN2@open_file_:

; 544  : 
; 545  :     while( isspace( *name ) )

	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN3@open_file_

; 546  :         name++;

	mov	rax, QWORD PTR name$[rsp]
	inc	rax
	mov	QWORD PTR name$[rsp], rax
	jmp	SHORT $LN2@open_file_
$LN3@open_file_:

; 547  : 
; 548  :     curr = ModuleInfo.g.IncludePath;

	mov	rax, QWORD PTR ModuleInfo+176
	mov	QWORD PTR curr$[rsp], rax

; 549  :     namelen = strlen( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	mov	DWORD PTR namelen$[rsp], eax

; 550  : 
; 551  :     DebugMsg(("open_file_in_include_path(%s) enter\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG10953
	call	DoDebugMsg

; 552  :     for ( ; curr; curr = next ) {

	jmp	SHORT $LN6@open_file_
$LN4@open_file_:
	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR curr$[rsp], rax
$LN6@open_file_:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN5@open_file_

; 553  :         next = strchr( curr, INC_PATH_DELIM );

	mov	edx, 59					; 0000003bH
	mov	rcx, QWORD PTR curr$[rsp]
	call	QWORD PTR __imp_strchr
	mov	QWORD PTR next$[rsp], rax

; 554  :         if ( next ) {

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN7@open_file_

; 555  :             i = next - curr;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR i$[rsp], eax

; 556  :             next++; /* skip path delimiter char (; or :) */

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax

; 557  :         } else {

	jmp	SHORT $LN8@open_file_
$LN7@open_file_:

; 558  :             i = strlen( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax
$LN8@open_file_:

; 559  :         }
; 560  : 
; 561  :         /* v2.06: ignore
; 562  :          * - "empty" entries in PATH
; 563  :          * - entries which would cause a buffer overflow
; 564  :          */
; 565  :         if ( i == 0 || ( ( i + namelen ) >= FILENAME_MAX ) )

	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN10@open_file_
	mov	eax, DWORD PTR namelen$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, 260				; 00000104H
	jl	SHORT $LN9@open_file_
$LN10@open_file_:

; 566  :             continue;

	jmp	SHORT $LN4@open_file_
$LN9@open_file_:

; 567  : 
; 568  :         memcpy( fullpath, curr, i );

	movsxd	rax, DWORD PTR i$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR fullpath$[rsp]
	call	memcpy

; 569  :         if( fullpath[i-1] != '/'
; 570  : #if !defined(__UNIX__)
; 571  :            && fullpath[i-1] != '\\' && fullpath[i-1] != ':'

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR fullpath$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN11@open_file_
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR fullpath$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN11@open_file_
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR fullpath$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN11@open_file_

; 572  : #endif
; 573  :         ) {
; 574  :             fullpath[i] = DIR_SEPARATOR;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR fullpath$[rsp]
	mov	BYTE PTR [rcx+rax], 92			; 0000005cH

; 575  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN11@open_file_:

; 576  :         }
; 577  :         strcpy( fullpath+i, name );

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR fullpath$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, rax
	call	strcpy

; 578  : 
; 579  :         DebugMsg(("open_file_in_include_path: >%s<\n", fullpath ));

	mov	rdx, QWORD PTR fullpath$[rsp]
	lea	rcx, OFFSET FLAT:$SG10959
	call	DoDebugMsg

; 580  :         file = fopen( fullpath, "rb" );

	lea	rdx, OFFSET FLAT:$SG10960
	mov	rcx, QWORD PTR fullpath$[rsp]
	call	QWORD PTR __imp_fopen
	mov	QWORD PTR file$[rsp], rax

; 581  :         if( file ) {

	cmp	QWORD PTR file$[rsp], 0
	je	SHORT $LN12@open_file_

; 582  :             break;

	jmp	SHORT $LN5@open_file_
$LN12@open_file_:

; 583  :         }
; 584  :     }

	jmp	$LN4@open_file_
$LN5@open_file_:

; 585  :     DebugMsg(("open_file_in_include_path()=%p\n", file ));

	mov	rdx, QWORD PTR file$[rsp]
	lea	rcx, OFFSET FLAT:$SG10962
	call	DoDebugMsg

; 586  :     return( file );

	mov	rax, QWORD PTR file$[rsp]

; 587  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
open_file_in_include_path ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
curr$ = 48
tab$ = 56
print_source_nesting_structure PROC

; 508  : {

$LN12:
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 509  :     struct src_item *curr;
; 510  :     unsigned        tab = 1;

	mov	DWORD PTR tab$[rsp], 1

; 511  : 
; 512  :     /* in main source file? */
; 513  :     if ( src_stack == NULL || src_stack->next == NULL )

	cmp	QWORD PTR ModuleInfo+200, 0
	je	SHORT $LN6@print_sour
	mov	rax, QWORD PTR ModuleInfo+200
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN5@print_sour
$LN6@print_sour:

; 514  :         return;

	jmp	$LN1@print_sour
$LN5@print_sour:

; 515  : 
; 516  :     for( curr = src_stack; curr->next ; curr = curr->next ) {

	mov	rax, QWORD PTR ModuleInfo+200
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@print_sour
$LN2@print_sour:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$[rsp], rax
$LN4@print_sour:
	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN3@print_sour

; 517  :         if( curr->type == SIT_FILE ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	test	eax, eax
	jne	SHORT $LN7@print_sour

; 518  :             PrintNote( NOTE_INCLUDED_BY, tab, "", GetFName( curr->srcfile )->fname, curr->line_num );

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, WORD PTR [rax+10]
	mov	ecx, eax
	call	GetFName
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+24]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9, QWORD PTR [rax]
	lea	r8, OFFSET FLAT:$SG10929
	mov	edx, DWORD PTR tab$[rsp]
	mov	ecx, 123				; 0000007bH
	call	PrintNote

; 519  :             tab++;

	mov	eax, DWORD PTR tab$[rsp]
	inc	eax
	mov	DWORD PTR tab$[rsp], eax

; 520  :         } else {

	jmp	$LN8@print_sour
$LN7@print_sour:

; 521  :             //char fname[_MAX_FNAME+_MAX_EXT];
; 522  :             if (*(curr->mi->macro->name) == NULLC ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rax+32]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN9@print_sour

; 523  :                 PrintNote( NOTE_ITERATION_MACRO_CALLED_FROM, tab, "", "MacroLoop", curr->line_num, curr->mi->macro->value + 1 );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rax+32]
	mov	eax, DWORD PTR [rax+16]
	inc	eax
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, OFFSET FLAT:$SG10932
	lea	r8, OFFSET FLAT:$SG10933
	mov	edx, DWORD PTR tab$[rsp]
	mov	ecx, 125				; 0000007dH
	call	PrintNote

; 524  :             } else {

	jmp	SHORT $LN10@print_sour
$LN9@print_sour:

; 525  :                 PrintNote( NOTE_MACRO_CALLED_FROM, tab, "", curr->mi->macro->name, curr->line_num, GetFNamePart( GetFName(((struct dsym *)curr->mi->macro)->e.macroinfo->srcfile)->fname ) ) ;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rax+32]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR [rax+28]
	call	GetFName
	mov	rcx, QWORD PTR [rax]
	call	GetFNamePart
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR [rcx+32]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR [rcx+8]
	lea	r8, OFFSET FLAT:$SG10934
	mov	edx, DWORD PTR tab$[rsp]
	mov	ecx, 124				; 0000007cH
	call	PrintNote
$LN10@print_sour:

; 526  :             }
; 527  :             tab++;

	mov	eax, DWORD PTR tab$[rsp]
	inc	eax
	mov	DWORD PTR tab$[rsp], eax
$LN8@print_sour:

; 528  :         }
; 529  :     }

	jmp	$LN2@print_sour
$LN3@print_sour:

; 530  :     PrintNote( NOTE_MAIN_LINE_CODE, tab, "", GetFName( curr->srcfile )->fname, curr->line_num );

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, WORD PTR [rax+10]
	mov	ecx, eax
	call	GetFName
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+24]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9, QWORD PTR [rax]
	lea	r8, OFFSET FLAT:$SG10935
	mov	edx, DWORD PTR tab$[rsp]
	mov	ecx, 126				; 0000007eH
	call	PrintNote
$LN1@print_sour:

; 531  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
print_source_nesting_structure ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
curr$ = 32
type$ = 64
pv$ = 72
PushSrcItem PROC

; 416  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+64]

; 417  :     struct src_item   *curr;
; 418  : 
; 419  :     if ( SrcFree ) {

	cmp	QWORD PTR SrcFree, 0
	je	SHORT $LN2@PushSrcIte

; 420  :         curr = SrcFree;

	mov	rax, QWORD PTR SrcFree
	mov	QWORD PTR curr$[rsp], rax

; 421  :         SrcFree = curr->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR SrcFree, rax

; 422  :     } else

	jmp	SHORT $LN3@PushSrcIte
$LN2@PushSrcIte:

; 423  :         curr = LclAlloc( sizeof( struct src_item ) );

	mov	ecx, 32					; 00000020H
	call	LclAlloc
	mov	QWORD PTR curr$[rsp], rax
$LN3@PushSrcIte:

; 424  :     curr->next = src_stack;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+200
	mov	QWORD PTR [rax], rcx

; 425  :     src_stack = curr;

	mov	rax, QWORD PTR curr$[rsp]
	mov	QWORD PTR ModuleInfo+200, rax

; 426  :     curr->type = type;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	ecx, BYTE PTR type$[rsp]
	mov	BYTE PTR [rax+8], cl

; 427  :     curr->content = pv;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR pv$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 428  :     curr->line_num = 0;

	mov	rax, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rax+24], 0

; 429  :     return( curr );

	mov	rax, QWORD PTR curr$[rsp]

; 430  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
PushSrcItem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
ptr$ = 32
last$ = 40
c$ = 48
tv69 = 52
tv73 = 56
buffer$ = 80
max$ = 88
fp$ = 96
my_fgets PROC

; 355  : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 356  :     char        *ptr = buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR ptr$[rsp], rax

; 357  :     char        *last = buffer + max;

	movsxd	rax, DWORD PTR max$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR last$[rsp], rax

; 358  :     int         c;
; 359  : 
; 360  :     c = getc( fp );

	mov	rcx, QWORD PTR fp$[rsp]
	call	QWORD PTR __imp_getc
	mov	DWORD PTR c$[rsp], eax
$LN2@my_fgets:

; 361  :     while( ptr < last ) {

	mov	rax, QWORD PTR last$[rsp]
	cmp	QWORD PTR ptr$[rsp], rax
	jae	$LN3@my_fgets

; 362  :         switch ( c ) {

	mov	eax, DWORD PTR c$[rsp]
	mov	DWORD PTR tv69[rsp], eax
	cmp	DWORD PTR tv69[rsp], -1
	je	SHORT $LN9@my_fgets
	cmp	DWORD PTR tv69[rsp], 10
	je	SHORT $LN7@my_fgets
	cmp	DWORD PTR tv69[rsp], 13
	je	SHORT $LN6@my_fgets
	cmp	DWORD PTR tv69[rsp], 26
	je	SHORT $LN9@my_fgets
	jmp	SHORT $LN10@my_fgets
$LN6@my_fgets:

; 363  :         case '\r':
; 364  :             break; /* don't store CR */

	jmp	SHORT $LN4@my_fgets
$LN7@my_fgets:

; 365  :         case '\n':
; 366  :             /* fall through */
; 367  :         //case '\0': /* v2.08: */
; 368  : #ifdef DEBUG_OUT
; 369  :             if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN8@my_fgets

; 370  :                 cntflines++;

	mov	eax, DWORD PTR cntflines
	inc	eax
	mov	DWORD PTR cntflines, eax
$LN8@my_fgets:

; 371  : #endif
; 372  :             *ptr = NULLC;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	BYTE PTR [rax], 0

; 373  :             return( buffer );

	mov	rax, QWORD PTR buffer$[rsp]
	jmp	SHORT $LN1@my_fgets
$LN9@my_fgets:

; 374  : #if DETECTCTRLZ
; 375  :         case 0x1a:
; 376  :             /* since source files are opened in binary mode, ctrl-z
; 377  :              * handling must be done here.
; 378  :              */
; 379  :             /* no break */
; 380  : #endif
; 381  :         case EOF:
; 382  :             *ptr = NULLC;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	BYTE PTR [rax], 0

; 383  :             return( ptr > buffer ? buffer : NULL );

	mov	rax, QWORD PTR buffer$[rsp]
	cmp	QWORD PTR ptr$[rsp], rax
	jbe	SHORT $LN12@my_fgets
	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR tv73[rsp], rax
	jmp	SHORT $LN13@my_fgets
$LN12@my_fgets:
	mov	QWORD PTR tv73[rsp], 0
$LN13@my_fgets:
	mov	rax, QWORD PTR tv73[rsp]
	jmp	SHORT $LN1@my_fgets
$LN10@my_fgets:

; 384  :         default:
; 385  :             *ptr++ = c;

	mov	rax, QWORD PTR ptr$[rsp]
	movzx	ecx, BYTE PTR c$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN4@my_fgets:

; 386  :         }
; 387  :         c = getc( fp );

	mov	rcx, QWORD PTR fp$[rsp]
	call	QWORD PTR __imp_getc
	mov	DWORD PTR c$[rsp], eax

; 388  :     }

	jmp	$LN2@my_fgets
$LN3@my_fgets:

; 389  :     EmitErr( LINE_TOO_LONG );

	mov	ecx, 61					; 0000003dH
	call	EmitErr

; 390  :     *(ptr-1) = NULLC;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	BYTE PTR [rax-1], 0

; 391  :     return( buffer );

	mov	rax, QWORD PTR buffer$[rsp]
$LN1@my_fgets:

; 392  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
my_fgets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
curr$ = 0
sym$ = 32
p$ = 40
UpdateLineNumber PROC

; 306  : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 307  :     struct src_item *curr;
; 308  :     for ( curr = src_stack; curr ; curr = curr->next )

	mov	rax, QWORD PTR ModuleInfo+200
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@UpdateLine
$LN2@UpdateLine:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$[rsp], rax
$LN4@UpdateLine:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@UpdateLine

; 309  :         if ( curr->type == SIT_FILE ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	test	eax, eax
	jne	SHORT $LN5@UpdateLine

; 310  :             sym->value = curr->line_num;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+24]
	mov	DWORD PTR [rax+16], ecx

; 311  :             break;

	jmp	SHORT $LN3@UpdateLine
$LN5@UpdateLine:

; 312  :         }

	jmp	SHORT $LN2@UpdateLine
$LN3@UpdateLine:

; 313  :     return;
; 314  : }

	add	rsp, 16
	pop	rdi
	ret	0
UpdateLineNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
FreeFiles PROC

; 241  : {

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 242  : #if FASTMEM==0
; 243  :     int i;
; 244  : 
; 245  :     /* remove the main src item from src stack */
; 246  :     src_stack->next = SrcFree;
; 247  :     SrcFree = src_stack;
; 248  : #endif
; 249  :     /* v2.03: set src_stack=NULL to ensure that GetCurrSrcPos()
; 250  :      * won't find something when called from main().
; 251  :      */
; 252  :     src_stack = NULL;

	mov	QWORD PTR ModuleInfo+200, 0

; 253  : 
; 254  : #if FASTMEM==0
; 255  :     /* free the "free src_items"-heap */
; 256  :     while ( SrcFree ) {
; 257  :         struct src_item *next;
; 258  :         next = SrcFree->next;
; 259  :         LclFree( SrcFree );
; 260  :         SrcFree = next;
; 261  :     };
; 262  :     for ( i = 0; i < ModuleInfo.g.cnt_fnames; i++ ) {
; 263  :         LclFree( ModuleInfo.g.FNames[i].fname );
; 264  :         //LclFree( ModuleInfo.g.FNames[i].fullname );
; 265  :     }
; 266  : #endif
; 267  :     if ( ModuleInfo.g.FNames ) {

	cmp	QWORD PTR ModuleInfo+160, 0
	je	SHORT $LN2@FreeFiles

; 268  :         MemFree( ModuleInfo.g.FNames );

	mov	rcx, QWORD PTR ModuleInfo+160
	call	MemFree

; 269  :         ModuleInfo.g.FNames = NULL;

	mov	QWORD PTR ModuleInfo+160, 0
$LN2@FreeFiles:

; 270  :     }
; 271  :     return;
; 272  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
FreeFiles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
index$ = 32
newfn$1 = 40
fname$ = 64
AddFile	PROC

; 192  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 193  :     unsigned    index;
; 194  : 
; 195  :     DebugMsg1(("AddFile(%s) enter, curr index=%u\n", fname, ModuleInfo.g.cnt_fnames ));

	mov	r8d, DWORD PTR ModuleInfo+168
	mov	rdx, QWORD PTR fname$[rsp]
	lea	rcx, OFFSET FLAT:$SG10805
	call	DoDebugMsg1

; 196  :     for( index = 0; index < ModuleInfo.g.cnt_fnames; index++ ) {

	mov	DWORD PTR index$[rsp], 0
	jmp	SHORT $LN4@AddFile
$LN2@AddFile:
	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	DWORD PTR index$[rsp], eax
$LN4@AddFile:
	mov	eax, DWORD PTR ModuleInfo+168
	cmp	DWORD PTR index$[rsp], eax
	jae	SHORT $LN3@AddFile

; 197  :         if( filecmp( fname, ModuleInfo.g.FNames[index].fname ) == 0 ) {

	mov	eax, DWORD PTR index$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR ModuleInfo+160
	mov	rdx, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR fname$[rsp]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN5@AddFile

; 198  : #ifdef DEBUG_OUT
; 199  :             if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN6@AddFile

; 200  :                 ModuleInfo.g.FNames[index].included++;

	mov	eax, DWORD PTR index$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR ModuleInfo+160
	mov	eax, DWORD PTR [rcx+rax+8]
	inc	eax
	mov	ecx, DWORD PTR index$[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR ModuleInfo+160
	mov	DWORD PTR [rdx+rcx+8], eax
$LN6@AddFile:

; 201  : #endif
; 202  :             return( index );

	mov	eax, DWORD PTR index$[rsp]
	jmp	$LN1@AddFile
$LN5@AddFile:

; 203  :         }
; 204  :     }

	jmp	SHORT $LN2@AddFile
$LN3@AddFile:

; 205  : 
; 206  :     if ( ( index % 64 ) == 0 ) {

	xor	edx, edx
	mov	eax, DWORD PTR index$[rsp]
	mov	ecx, 64					; 00000040H
	div	ecx
	mov	eax, edx
	test	eax, eax
	jne	SHORT $LN7@AddFile

; 207  :         struct fname_item *newfn;
; 208  :         newfn = (struct fname_item *)MemAlloc( ( index + 64 ) * sizeof( struct fname_item ) );

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 64					; 00000040H
	mov	eax, eax
	imul	rax, rax, 16
	mov	rcx, rax
	call	MemAlloc
	mov	QWORD PTR newfn$1[rsp], rax

; 209  :         if ( ModuleInfo.g.FNames ) {

	cmp	QWORD PTR ModuleInfo+160, 0
	je	SHORT $LN8@AddFile

; 210  :             memcpy( newfn, ModuleInfo.g.FNames, index * sizeof( struct fname_item ) );

	mov	eax, DWORD PTR index$[rsp]
	imul	rax, rax, 16
	mov	r8, rax
	mov	rdx, QWORD PTR ModuleInfo+160
	mov	rcx, QWORD PTR newfn$1[rsp]
	call	memcpy

; 211  :             MemFree( ModuleInfo.g.FNames );

	mov	rcx, QWORD PTR ModuleInfo+160
	call	MemFree
$LN8@AddFile:

; 212  :         }
; 213  :         ModuleInfo.g.FNames = newfn;

	mov	rax, QWORD PTR newfn$1[rsp]
	mov	QWORD PTR ModuleInfo+160, rax
$LN7@AddFile:

; 214  :     }
; 215  :     ModuleInfo.g.cnt_fnames++;

	mov	eax, DWORD PTR ModuleInfo+168
	inc	eax
	mov	DWORD PTR ModuleInfo+168, eax

; 216  : 
; 217  :     /* v2.11: use name directly - allows COFF .file entries with relative paths */
; 218  :     //_splitpath( fname, NULL, NULL, name, ext );
; 219  : 
; 220  :     ModuleInfo.g.FNames[index].fname = (char *)LclAlloc( strlen( fname ) + 1 );

	mov	rcx, QWORD PTR fname$[rsp]
	call	strlen
	inc	rax
	mov	rcx, rax
	call	LclAlloc
	mov	ecx, DWORD PTR index$[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR ModuleInfo+160
	mov	QWORD PTR [rdx+rcx], rax

; 221  :     strcpy( ModuleInfo.g.FNames[index].fname, fname );

	mov	eax, DWORD PTR index$[rsp]
	imul	rax, rax, 16
	mov	rdx, QWORD PTR fname$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+160
	mov	rcx, QWORD PTR [rcx+rax]
	call	strcpy

; 222  :     /* v2.11: field fullname removed */
; 223  :     //ModuleInfo.g.FNames[index].fullname = (char *)LclAlloc( strlen( fullname ) + 1 );
; 224  :     //strcpy( ModuleInfo.g.FNames[index].fullname, fullname );
; 225  :     DebugCmd( ModuleInfo.g.FNames[index].included = 1 );

	mov	eax, DWORD PTR index$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR ModuleInfo+160
	mov	DWORD PTR [rcx+rax+8], 1

; 226  :     return( index );

	mov	eax, DWORD PTR index$[rsp]
$LN1@AddFile:

; 227  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
AddFile	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
GetTopSrcName PROC

; 340  : {

$LN4:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 341  :     if ( src_stack->type == SIT_MACRO )

	mov	rax, QWORD PTR ModuleInfo+200
	movzx	eax, BYTE PTR [rax+8]
	cmp	eax, 1
	jne	SHORT $LN2@GetTopSrcN

; 342  :         return( src_stack->mi->macro->name );

	mov	rax, QWORD PTR ModuleInfo+200
	mov	rax, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rax+32]
	mov	rax, QWORD PTR [rax+8]
	jmp	SHORT $LN1@GetTopSrcN
$LN2@GetTopSrcN:

; 343  :     return( GetFName( src_stack->srcfile )->fname );

	mov	rax, QWORD PTR ModuleInfo+200
	movzx	eax, WORD PTR [rax+10]
	mov	ecx, eax
	call	GetFName
	mov	rax, QWORD PTR [rax]
$LN1@GetTopSrcN:

; 344  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
GetTopSrcName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
buffer$ = 48
GetTopLine PROC

; 329  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 330  :     *buffer = NULLC;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rax], 0

; 331  :     if ( ModuleInfo.GeneratedCode )

	cmp	DWORD PTR ModuleInfo+456, 0
	je	SHORT $LN2@GetTopLine

; 332  :         sprintf( buffer, "(%u)", GetLqLine() );

	call	GetLqLine
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG10847
	mov	rcx, QWORD PTR buffer$[rsp]
	call	sprintf
	jmp	SHORT $LN3@GetTopLine
$LN2@GetTopLine:

; 333  :     else if( src_stack->type == SIT_MACRO )

	mov	rax, QWORD PTR ModuleInfo+200
	movzx	eax, BYTE PTR [rax+8]
	cmp	eax, 1
	jne	SHORT $LN4@GetTopLine

; 334  :         sprintf( buffer, "[%s.%" I32_SPEC "u]", src_stack->mi->macro->name, src_stack->line_num );

	mov	rax, QWORD PTR ModuleInfo+200
	mov	rax, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rax+32]
	mov	rcx, QWORD PTR ModuleInfo+200
	mov	r9d, DWORD PTR [rcx+24]
	mov	r8, QWORD PTR [rax+8]
	lea	rdx, OFFSET FLAT:$SG10849
	mov	rcx, QWORD PTR buffer$[rsp]
	call	sprintf
$LN4@GetTopLine:
$LN3@GetTopLine:

; 335  :     return( buffer );

	mov	rax, QWORD PTR buffer$[rsp]

; 336  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
GetTopLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
index$ = 16
GetFName PROC

; 231  : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	push	rdi

; 232  :     return( ModuleInfo.g.FNames+index );

	mov	eax, DWORD PTR index$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR ModuleInfo+160
	add	rcx, rax
	mov	rax, rcx

; 233  : }

	pop	rdi
	ret	0
GetFName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
file$ = 16
line_num$ = 24
set_curr_srcfile PROC

; 469  : {

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi

; 470  :     if ( file != 0xFFF ) /* 0xFFF is the special value for macro lines */

	cmp	DWORD PTR file$[rsp], 4095		; 00000fffH
	je	SHORT $LN2@set_curr_s

; 471  :         src_stack->srcfile = file;

	mov	rax, QWORD PTR ModuleInfo+200
	movzx	ecx, WORD PTR file$[rsp]
	mov	WORD PTR [rax+10], cx
$LN2@set_curr_s:

; 472  :     src_stack->line_num = line_num;

	mov	rax, QWORD PTR ModuleInfo+200
	mov	ecx, DWORD PTR line_num$[rsp]
	mov	DWORD PTR [rax+24], ecx

; 473  :     return;
; 474  : }

	pop	rdi
	ret	0
set_curr_srcfile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
curr$ = 0
get_curr_srcfile PROC

; 458  : {

$LN7:
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 459  :     struct src_item *curr;
; 460  :     for ( curr = src_stack; curr ; curr = curr->next )

	mov	rax, QWORD PTR ModuleInfo+200
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@get_curr_s
$LN2@get_curr_s:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$[rsp], rax
$LN4@get_curr_s:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@get_curr_s

; 461  :         if ( curr->type == SIT_FILE )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	test	eax, eax
	jne	SHORT $LN5@get_curr_s

; 462  :             return( curr->srcfile );

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, WORD PTR [rax+10]
	jmp	SHORT $LN1@get_curr_s
$LN5@get_curr_s:
	jmp	SHORT $LN2@get_curr_s
$LN3@get_curr_s:

; 463  :     return( ModuleInfo.srcfile );

	mov	eax, DWORD PTR ModuleInfo+428
$LN1@get_curr_s:

; 464  : }

	add	rsp, 16
	pop	rdi
	ret	0
get_curr_srcfile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
nextfile$ = 32
ClearSrcStack PROC

; 284  : {

$LN7:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 285  :     struct src_item   *nextfile;
; 286  : 
; 287  :     DeleteLineQueue();

	call	DeleteLineQueue

; 288  : 
; 289  :     /* dont close the last item (which is the main src file) */
; 290  :     for( ; src_stack->next ; src_stack = nextfile ) {

	jmp	SHORT $LN4@ClearSrcSt
$LN2@ClearSrcSt:
	mov	rax, QWORD PTR nextfile$[rsp]
	mov	QWORD PTR ModuleInfo+200, rax
$LN4@ClearSrcSt:
	mov	rax, QWORD PTR ModuleInfo+200
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@ClearSrcSt

; 291  :         nextfile = src_stack->next;

	mov	rax, QWORD PTR ModuleInfo+200
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR nextfile$[rsp], rax

; 292  :         if ( src_stack->type == SIT_FILE ) {

	mov	rax, QWORD PTR ModuleInfo+200
	movzx	eax, BYTE PTR [rax+8]
	test	eax, eax
	jne	SHORT $LN5@ClearSrcSt

; 293  :             fclose( src_stack->file );

	mov	rax, QWORD PTR ModuleInfo+200
	mov	rcx, QWORD PTR [rax+16]
	call	QWORD PTR __imp_fclose
$LN5@ClearSrcSt:

; 294  :         }
; 295  :         //LclFree( src_stack );
; 296  :         src_stack->next = SrcFree;

	mov	rax, QWORD PTR ModuleInfo+200
	mov	rcx, QWORD PTR SrcFree
	mov	QWORD PTR [rax], rcx

; 297  :         SrcFree = src_stack;

	mov	rax, QWORD PTR ModuleInfo+200
	mov	QWORD PTR SrcFree, rax

; 298  :     }

	jmp	SHORT $LN2@ClearSrcSt
$LN3@ClearSrcSt:

; 299  :     return;
; 300  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
ClearSrcStack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
curr$ = 32
tv81 = 40
buffer$ = 64
GetCurrSrcPos PROC

; 490  : {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 491  :     struct src_item *curr;
; 492  : 
; 493  :     for( curr = src_stack; curr; curr = curr->next ) {

	mov	rax, QWORD PTR ModuleInfo+200
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@GetCurrSrc
$LN2@GetCurrSrc:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$[rsp], rax
$LN4@GetCurrSrc:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@GetCurrSrc

; 494  :         if ( curr->type == SIT_FILE ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	test	eax, eax
	jne	SHORT $LN5@GetCurrSrc

; 495  :             return( sprintf( buffer, ModuleInfo.EndDirFound == FALSE ? "%s(%" I32_SPEC "u) : " : "%s : ", GetFName( curr->srcfile )->fname , curr->line_num ) );

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 16
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN7@GetCurrSrc
	lea	rax, OFFSET FLAT:$SG10912
	mov	QWORD PTR tv81[rsp], rax
	jmp	SHORT $LN8@GetCurrSrc
$LN7@GetCurrSrc:
	lea	rax, OFFSET FLAT:$SG10913
	mov	QWORD PTR tv81[rsp], rax
$LN8@GetCurrSrc:
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, WORD PTR [rax+10]
	mov	ecx, eax
	call	GetFName
	mov	rcx, QWORD PTR curr$[rsp]
	mov	r9d, DWORD PTR [rcx+24]
	mov	r8, QWORD PTR [rax]
	mov	rdx, QWORD PTR tv81[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	sprintf
	jmp	SHORT $LN1@GetCurrSrc
$LN5@GetCurrSrc:

; 496  :         }
; 497  :     }

	jmp	SHORT $LN2@GetCurrSrc
$LN3@GetCurrSrc:

; 498  :     *buffer = NULLC;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rax], 0

; 499  :     return( 0 );

	xor	eax, eax
$LN1@GetCurrSrc:

; 500  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
GetCurrSrcPos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
newstat$ = 80
PopInputStatus PROC

; 859  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 860  :     DebugMsg1(("PopInputStatus() old=%X-%u-%X new=%X-%u-%X\n",

	mov	rax, QWORD PTR newstat$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR newstat$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR newstat$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR ModuleInfo+464
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR token_stringbuf
	lea	rcx, OFFSET FLAT:$SG11050
	call	DoDebugMsg1

; 861  :                token_stringbuf, Token_Count, CurrSource,
; 862  :                newstat->token_stringbuf, newstat->token_count, newstat->currsource ));
; 863  : #ifdef __I86__
; 864  :     MemFree( CurrSource );
; 865  : #else
; 866  :     StringBufferEnd = token_stringbuf;

	mov	rax, QWORD PTR token_stringbuf
	mov	QWORD PTR ModuleInfo+488, rax

; 867  : #endif
; 868  :     token_stringbuf = newstat->token_stringbuf;

	mov	rax, QWORD PTR newstat$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR token_stringbuf, rax

; 869  :     Token_Count = newstat->token_count;

	mov	rax, QWORD PTR newstat$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR ModuleInfo+496, eax

; 870  :     CurrSource = newstat->currsource;

	mov	rax, QWORD PTR newstat$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR ModuleInfo+464, rax

; 871  :     if ( newstat->CurrComment ) {

	mov	rax, QWORD PTR newstat$[rsp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN2@PopInputSt

; 872  :         ModuleInfo.CurrComment = commentbuffer;

	mov	rax, QWORD PTR commentbuffer
	mov	QWORD PTR ModuleInfo+472, rax

; 873  :         strcpy( ModuleInfo.CurrComment, newstat->CurrComment );

	mov	rax, QWORD PTR newstat$[rsp]
	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR ModuleInfo+472
	call	strcpy

; 874  :         *newstat->CurrComment = NULLC;

	mov	rax, QWORD PTR newstat$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	BYTE PTR [rax], 0

; 875  :     } else

	jmp	SHORT $LN3@PopInputSt
$LN2@PopInputSt:

; 876  :         ModuleInfo.CurrComment = NULL;

	mov	QWORD PTR ModuleInfo+472, 0
$LN3@PopInputSt:

; 877  : #ifdef __I86__
; 878  :     StringBufferEnd = newstat->stringbufferend;
; 879  :     ModuleInfo.tokenarray = newstat->tokenarray;
; 880  : #else
; 881  :     ModuleInfo.tokenarray -= Token_Count + 1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR ModuleInfo+480
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ModuleInfo+480, rax

; 882  : #endif
; 883  :     ModuleInfo.line_flags = newstat->line_flags; /* v2.08 */

	mov	rax, QWORD PTR newstat$[rsp]
	movzx	eax, BYTE PTR [rax+28]
	mov	BYTE PTR ModuleInfo+398, al

; 884  :     return;
; 885  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
PopInputStatus ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
i$1 = 64
oldstat$ = 96
PushInputStatus PROC

; 825  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 826  :     oldstat->token_stringbuf = token_stringbuf;

	mov	rax, QWORD PTR oldstat$[rsp]
	mov	rcx, QWORD PTR token_stringbuf
	mov	QWORD PTR [rax], rcx

; 827  :     oldstat->token_count = Token_Count;

	mov	rax, QWORD PTR oldstat$[rsp]
	mov	ecx, DWORD PTR ModuleInfo+496
	mov	DWORD PTR [rax+24], ecx

; 828  :     oldstat->currsource = CurrSource;

	mov	rax, QWORD PTR oldstat$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+464
	mov	QWORD PTR [rax+8], rcx

; 829  :     /* if there's a comment, attach it to current source */
; 830  :     if ( ModuleInfo.CurrComment ) {

	cmp	QWORD PTR ModuleInfo+472, 0
	je	SHORT $LN2@PushInputS

; 831  :         int i = strlen( CurrSource );

	mov	rcx, QWORD PTR ModuleInfo+464
	call	strlen
	mov	DWORD PTR i$1[rsp], eax

; 832  :         oldstat->CurrComment = CurrSource + i;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR ModuleInfo+464
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR oldstat$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 833  :         strcpy( oldstat->CurrComment, ModuleInfo.CurrComment );

	mov	rdx, QWORD PTR ModuleInfo+472
	mov	rax, QWORD PTR oldstat$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	strcpy

; 834  :     } else

	jmp	SHORT $LN3@PushInputS
$LN2@PushInputS:

; 835  :         oldstat->CurrComment = NULL;

	mov	rax, QWORD PTR oldstat$[rsp]
	mov	QWORD PTR [rax+16], 0
$LN3@PushInputS:

; 836  :     oldstat->line_flags = ModuleInfo.line_flags; /* v2.08 */

	mov	rax, QWORD PTR oldstat$[rsp]
	movzx	ecx, BYTE PTR ModuleInfo+398
	mov	BYTE PTR [rax+28], cl

; 837  : #ifdef __I86__
; 838  :     oldstat->tokenarray = ModuleInfo.tokenarray;
; 839  :     oldstat->stringbufferend = StringBufferEnd;
; 840  :     CurrSource = MemAlloc( MAX_LINE_LEN + SIZE_TOKENARRAY + SIZE_STRINGBUFFER );
; 841  :     ModuleInfo.tokenarray = (struct asm_tok *)( CurrSource + MAX_LINE_LEN );
; 842  :     token_stringbuf = CurrSource + MAX_LINE_LEN + SIZE_TOKENARRAY;
; 843  : #else
; 844  :     token_stringbuf = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR token_stringbuf, rax

; 845  :     ModuleInfo.tokenarray += Token_Count + 1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR ModuleInfo+480
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ModuleInfo+480, rax

; 846  :     CurrSource = GetAlignedPointer( CurrSource, strlen( CurrSource ) );

	mov	rcx, QWORD PTR ModuleInfo+464
	call	strlen
	add	rax, 8
	and	rax, -8
	mov	rcx, QWORD PTR ModuleInfo+464
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ModuleInfo+464, rax

; 847  :     /*myassert( ( CurrSource + MAX_LINE_LEN ) <= (char *)ModuleInfo.tokenarray );*/
; 848  :     /*myassert( ( ModuleInfo.tokenarray + sizeof( struct asm_tok ) * MAX_TOKEN ) <= end_tokenarray ); */
; 849  :     /*myassert( ( token_stringbuf + 2 * MAX_LINE_LEN ) <= end_stringbuf ); */
; 850  : #endif
; 851  :     DebugMsg1(("PushInputStatus() stringbuf-tokencnt-currsrc old=%X-%u-%X new=%X-%X-%X\n",

	mov	rax, QWORD PTR ModuleInfo+464
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR ModuleInfo+480
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR token_stringbuf
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR oldstat$[rsp]
	mov	r9, QWORD PTR [rax+8]
	mov	rax, QWORD PTR oldstat$[rsp]
	mov	r8d, DWORD PTR [rax+24]
	mov	rax, QWORD PTR oldstat$[rsp]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11045
	call	DoDebugMsg1

; 852  :                oldstat->token_stringbuf, oldstat->token_count, oldstat->currsource,
; 853  :                token_stringbuf, ModuleInfo.tokenarray, CurrSource ));
; 854  :     return( ModuleInfo.tokenarray );

	mov	rax, QWORD PTR ModuleInfo+480

; 855  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
PushInputStatus ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
i$ = 48
tv95 = 52
InputFini PROC

; 967  : {

$LN12:
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 968  : #ifdef DEBUG_OUT
; 969  :     int   i;
; 970  : 
; 971  :     /* for the main source file, lines usually isn't filled yet */
; 972  :     if ( ModuleInfo.g.FNames )

	cmp	QWORD PTR ModuleInfo+160, 0
	je	SHORT $LN5@InputFini

; 973  :         ModuleInfo.g.FNames[ModuleInfo.srcfile].lines = src_stack->line_num;

	mov	eax, DWORD PTR ModuleInfo+428
	imul	rax, rax, 16
	mov	rcx, QWORD PTR ModuleInfo+160
	mov	rdx, QWORD PTR ModuleInfo+200
	mov	edx, DWORD PTR [rdx+24]
	mov	DWORD PTR [rcx+rax+12], edx
$LN5@InputFini:

; 974  :     for( i = 0; i < ModuleInfo.g.cnt_fnames; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@InputFini
$LN2@InputFini:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@InputFini:
	mov	eax, DWORD PTR ModuleInfo+168
	cmp	DWORD PTR i$[rsp], eax
	jae	$LN3@InputFini

; 975  :         if ( Options.log_all_files ) {

	movzx	eax, BYTE PTR Options+23
	test	eax, eax
	je	$LN6@InputFini

; 976  :             if ( ModuleInfo.g.FNames[i].included > 1 )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR ModuleInfo+160
	cmp	DWORD PTR [rcx+rax+8], 1
	jbe	SHORT $LN7@InputFini

; 977  :                 printf("%2u: %5u *%2u %s\n", i+1, ModuleInfo.g.FNames[i].lines, ModuleInfo.g.FNames[i].included, ModuleInfo.g.FNames[i].fname );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	movsxd	rdx, DWORD PTR i$[rsp]
	imul	rdx, rdx, 16
	mov	r8d, DWORD PTR i$[rsp]
	inc	r8d
	mov	DWORD PTR tv95[rsp], r8d
	mov	r9, QWORD PTR ModuleInfo+160
	mov	rax, QWORD PTR [r9+rax]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR ModuleInfo+160
	mov	r9d, DWORD PTR [rax+rcx+8]
	mov	rax, QWORD PTR ModuleInfo+160
	mov	r8d, DWORD PTR [rax+rdx+12]
	mov	eax, DWORD PTR tv95[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11082
	call	printf
	jmp	SHORT $LN8@InputFini
$LN7@InputFini:

; 978  :             else
; 979  :                 printf("%2u: %5u     %s\n", i+1, ModuleInfo.g.FNames[i].lines, ModuleInfo.g.FNames[i].fname );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	mov	edx, DWORD PTR i$[rsp]
	inc	edx
	mov	r8, QWORD PTR ModuleInfo+160
	mov	r9, QWORD PTR [r8+rax]
	mov	rax, QWORD PTR ModuleInfo+160
	mov	r8d, DWORD PTR [rax+rcx+12]
	lea	rcx, OFFSET FLAT:$SG11083
	call	printf
$LN8@InputFini:
$LN6@InputFini:

; 980  :         }
; 981  :         DebugMsg(( "InputFini: idx=%u name=%s\n", i, ModuleInfo.g.FNames[i].fname ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR ModuleInfo+160
	mov	r8, QWORD PTR [rcx+rax]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11084
	call	DoDebugMsg

; 982  :     }

	jmp	$LN2@InputFini
$LN3@InputFini:

; 983  : #endif
; 984  :     if ( ModuleInfo.g.IncludePath )

	cmp	QWORD PTR ModuleInfo+176, 0
	je	SHORT $LN9@InputFini

; 985  :         MemFree( ModuleInfo.g.IncludePath );

	mov	rcx, QWORD PTR ModuleInfo+176
	call	MemFree
$LN9@InputFini:

; 986  : 
; 987  :     /* free items in ModuleInfo.g.FNames ( and FreeFile, if FASTMEM==0 ) */
; 988  :     FreeFiles();

	call	FreeFiles

; 989  : #ifdef DEBUG_OUT
; 990  :     if ( Options.quiet == FALSE ) {

	movzx	eax, BYTE PTR Options
	test	eax, eax
	jne	SHORT $LN10@InputFini

; 991  :         printf("lines read(files)/processed in pass one: %" I32_SPEC "u / %" I32_SPEC "u\n", cntflines, cntlines );

	mov	r8d, DWORD PTR cntlines
	mov	edx, DWORD PTR cntflines
	lea	rcx, OFFSET FLAT:$SG11087
	call	printf

; 992  :         printf("invokations: PreprocessLine=%" I32_SPEC "u/%" I32_SPEC "u/%" I32_SPEC "u, Tokenize=%" I32_SPEC "u/%" I32_SPEC "u\n", cntppl0, cntppl1, cntppl2, cnttok0, cnttok1 );

	mov	eax, DWORD PTR cnttok1
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR cnttok0
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR cntppl2
	mov	r8d, DWORD PTR cntppl1
	mov	edx, DWORD PTR cntppl0
	lea	rcx, OFFSET FLAT:$SG11088
	call	printf
$LN10@InputFini:

; 993  :     }
; 994  : #endif
; 995  :     ModuleInfo.tokenarray = NULL;

	mov	QWORD PTR ModuleInfo+480, 0

; 996  : #ifdef DEBUG_OUT
; 997  :     token_stringbuf = NULL;

	mov	QWORD PTR token_stringbuf, 0

; 998  :     StringBufferEnd = NULL;

	mov	QWORD PTR ModuleInfo+488, 0

; 999  :     commentbuffer = NULL;

	mov	QWORD PTR commentbuffer, 0

; 1000 :     CurrSource = NULL;

	mov	QWORD PTR ModuleInfo+464, 0

; 1001 : #endif
; 1002 :     LclFree( srclinebuffer );
; 1003 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
InputFini ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
InputPassInit PROC

; 953  : {

$LN3:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 954  :     DebugMsg(( "InputPassInit() enter\n" ));

	lea	rcx, OFFSET FLAT:$SG11066
	call	DoDebugMsg

; 955  :     src_stack->line_num = 0;

	mov	rax, QWORD PTR ModuleInfo+200
	mov	DWORD PTR [rax+24], 0

; 956  :     //inside_comment = NULLC;
; 957  :     CurrSource = srclinebuffer;

	mov	rax, QWORD PTR srclinebuffer
	mov	QWORD PTR ModuleInfo+464, rax

; 958  :     *CurrSource = NULLC;

	mov	rax, QWORD PTR ModuleInfo+464
	mov	BYTE PTR [rax], 0

; 959  :     StringBufferEnd = token_stringbuf;

	mov	rax, QWORD PTR token_stringbuf
	mov	QWORD PTR ModuleInfo+488, rax

; 960  :     return;
; 961  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
InputPassInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
fl$ = 48
InputInit PROC

; 891  : {

$LN3:
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 892  :     struct src_item *fl;
; 893  : #if 0
; 894  :     char        path[FILENAME_MAX];
; 895  :     char        drive[_MAX_DRIVE];
; 896  :     char        dir[_MAX_DIR];
; 897  : #endif
; 898  : 
; 899  :     DebugMsg(( "InputInit() enter\n" ));

	lea	rcx, OFFSET FLAT:$SG11061
	call	DoDebugMsg

; 900  :     //ModuleInfo.g.cnt_fnames = 0;
; 901  :     //ModuleInfo.g.FNames = NULL;
; 902  :     //IncludePath = NULL;
; 903  :     //src_stack = NULL;
; 904  :     SrcFree = NULL; /* v2.11 */

	mov	QWORD PTR SrcFree, 0

; 905  : #if FILESEQ
; 906  :     FileSeq.head = NULL;
; 907  : #endif
; 908  : #ifdef DEBUG_OUT
; 909  :     cntppl0 = 0;

	mov	DWORD PTR cntppl0, 0

; 910  :     cntppl1 = 0;

	mov	DWORD PTR cntppl1, 0

; 911  :     cntppl2 = 0;

	mov	DWORD PTR cntppl2, 0

; 912  :     cnttok0 = 0;

	mov	DWORD PTR cnttok0, 0

; 913  :     cnttok1 = 0;

	mov	DWORD PTR cnttok1, 0

; 914  :     cntflines = 0;

	mov	DWORD PTR cntflines, 0

; 915  :     cntlines = 0;

	mov	DWORD PTR cntlines, 0

; 916  : #endif
; 917  : 
; 918  :     /* add path of main module to the include path.
; 919  :      * v2.12: unnecessary since v2.10, since the directory part of the
; 920  :      * current source is added if a file is to be included; see SearchFile().
; 921  :      */
; 922  :     //_splitpath( CurrFName[ASM], drive, dir, NULL, NULL );
; 923  :     //if ( drive[0] || dir[0] ) {
; 924  :     //    _makepath( path, drive, dir, NULL, NULL );
; 925  :     //    AddStringToIncludePath( path );
; 926  :     //}
; 927  : 
; 928  :     srclinebuffer = LclAlloc( SIZE_SRCLINES + SIZE_TOKENARRAY + SIZE_STRINGBUFFER );

	mov	ecx, 240600				; 0003abd8H
	call	LclAlloc
	mov	QWORD PTR srclinebuffer, rax

; 929  :     /* the comment buffer is at the end of the source line buffer */
; 930  :     commentbuffer = srclinebuffer + SIZE_SRCLINES - MAX_LINE_LEN;

	mov	rax, QWORD PTR srclinebuffer
	add	rax, 24000				; 00005dc0H
	mov	QWORD PTR commentbuffer, rax

; 931  :     /* behind the comment buffer is the token buffer */
; 932  :     ModuleInfo.tokenarray = (struct asm_tok *)( srclinebuffer + SIZE_SRCLINES );

	mov	rax, QWORD PTR srclinebuffer
	add	rax, 24600				; 00006018H
	mov	QWORD PTR ModuleInfo+480, rax

; 933  :     token_stringbuf = srclinebuffer + SIZE_SRCLINES + SIZE_TOKENARRAY;

	mov	rax, QWORD PTR srclinebuffer
	add	rax, 216600				; 00034e18H
	mov	QWORD PTR token_stringbuf, rax

; 934  : #ifdef DEBUG_OUT
; 935  :     end_tokenarray = (struct asm_tok *)token_stringbuf;

	mov	rax, QWORD PTR token_stringbuf
	mov	QWORD PTR end_tokenarray, rax

; 936  :     end_stringbuf = token_stringbuf + SIZE_STRINGBUFFER;

	mov	rax, QWORD PTR token_stringbuf
	add	rax, 24000				; 00005dc0H
	mov	QWORD PTR end_stringbuf, rax

; 937  :     DebugMsg(( "InputInit: srclinebuffer=%p, tokenarray=%p, token_stringbuf=%p end_stringbuf=%p\n", srclinebuffer, ModuleInfo.tokenarray, token_stringbuf, end_stringbuf ));

	mov	rax, QWORD PTR end_stringbuf
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR token_stringbuf
	mov	r8, QWORD PTR ModuleInfo+480
	mov	rdx, QWORD PTR srclinebuffer
	lea	rcx, OFFSET FLAT:$SG11062
	call	DoDebugMsg

; 938  : #endif
; 939  : 
; 940  :     fl = PushSrcItem( SIT_FILE, CurrFile[ASM] );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rdx, QWORD PTR [rcx+rax]
	xor	ecx, ecx
	call	PushSrcItem
	mov	QWORD PTR fl$[rsp], rax

; 941  :     fl->srcfile = ModuleInfo.srcfile = AddFile( CurrFName[ASM] );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rcx, QWORD PTR [rcx+rax]
	call	AddFile
	mov	DWORD PTR ModuleInfo+428, eax
	mov	rax, QWORD PTR fl$[rsp]
	movzx	ecx, WORD PTR ModuleInfo+428
	mov	WORD PTR [rax+10], cx

; 942  :     /* setting a function pointer won't work for text macros! */
; 943  :     //FileCur->sfunc_ptr = &GetFileCur;
; 944  :     FileCur->string_ptr = GetFName( fl->srcfile )->fname;

	mov	rax, QWORD PTR fl$[rsp]
	movzx	eax, WORD PTR [rax+10]
	mov	ecx, eax
	call	GetFName
	mov	rcx, QWORD PTR FileCur
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx+16], rax

; 945  : 
; 946  :     DebugMsg(( "InputInit() exit\n" ));

	lea	rcx, OFFSET FLAT:$SG11063
	call	DoDebugMsg

; 947  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
InputInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
tmp$ = 32
len$ = 40
string$ = 64
AddStringToIncludePath PROC

; 757  : {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 758  :     char *tmp;
; 759  :     int len;
; 760  : 
; 761  :     DebugMsg(("AddStringToIncludePath(%s) enter\n", string ));

	mov	rdx, QWORD PTR string$[rsp]
	lea	rcx, OFFSET FLAT:$SG11031
	call	DoDebugMsg
$LN2@AddStringT:

; 762  :     while( isspace( *string ) )

	mov	rax, QWORD PTR string$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN3@AddStringT

; 763  :         string++;

	mov	rax, QWORD PTR string$[rsp]
	inc	rax
	mov	QWORD PTR string$[rsp], rax
	jmp	SHORT $LN2@AddStringT
$LN3@AddStringT:

; 764  :     len = strlen( string );

	mov	rcx, QWORD PTR string$[rsp]
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 765  :     if ( len == 0 )

	cmp	DWORD PTR len$[rsp], 0
	jne	SHORT $LN4@AddStringT

; 766  :         return;

	jmp	$LN1@AddStringT
$LN4@AddStringT:

; 767  :     if( ModuleInfo.g.IncludePath == NULL ) {

	cmp	QWORD PTR ModuleInfo+176, 0
	jne	SHORT $LN5@AddStringT

; 768  :         ModuleInfo.g.IncludePath = MemAlloc( len + 1 );

	mov	eax, DWORD PTR len$[rsp]
	inc	eax
	cdqe
	mov	rcx, rax
	call	MemAlloc
	mov	QWORD PTR ModuleInfo+176, rax

; 769  :         strcpy( ModuleInfo.g.IncludePath, string );

	mov	rdx, QWORD PTR string$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+176
	call	strcpy

; 770  :     } else {

	jmp	SHORT $LN6@AddStringT
$LN5@AddStringT:

; 771  :         tmp = ModuleInfo.g.IncludePath;

	mov	rax, QWORD PTR ModuleInfo+176
	mov	QWORD PTR tmp$[rsp], rax

; 772  :         ModuleInfo.g.IncludePath = MemAlloc( strlen( tmp ) + sizeof( INC_PATH_DELIM_STR ) +

	mov	rcx, QWORD PTR tmp$[rsp]
	call	strlen
	movsxd	rcx, DWORD PTR len$[rsp]
	lea	rax, QWORD PTR [rax+rcx+3]
	mov	rcx, rax
	call	MemAlloc
	mov	QWORD PTR ModuleInfo+176, rax

; 773  :                                 len + 1 );
; 774  :         strcpy( ModuleInfo.g.IncludePath, tmp );

	mov	rdx, QWORD PTR tmp$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+176
	call	strcpy

; 775  :         strcat( ModuleInfo.g.IncludePath, INC_PATH_DELIM_STR );

	lea	rdx, OFFSET FLAT:$SG11035
	mov	rcx, QWORD PTR ModuleInfo+176
	call	strcat

; 776  :         strcat( ModuleInfo.g.IncludePath, string );

	mov	rdx, QWORD PTR string$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+176
	call	strcat

; 777  :         MemFree( tmp );

	mov	rcx, QWORD PTR tmp$[rsp]
	call	MemFree
$LN6@AddStringT:
$LN1@AddStringT:

; 778  :     }
; 779  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
AddStringToIncludePath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
line$ = 16
SetLineNumber PROC

; 479  : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	push	rdi

; 480  :     src_stack->line_num = line;

	mov	rax, QWORD PTR ModuleInfo+200
	mov	ecx, DWORD PTR line$[rsp]
	mov	DWORD PTR [rax+24], ecx

; 481  :     return;
; 482  : }

	pop	rdi
	ret	0
SetLineNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
mi$ = 48
PushMacro PROC

; 436  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 437  :     DebugMsg1(( "PushMacro(%s)\n", mi->macro->name ));

	mov	rax, QWORD PTR mi$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10887
	call	DoDebugMsg1

; 438  :     PushSrcItem( SIT_MACRO, mi );

	mov	rdx, QWORD PTR mi$[rsp]
	mov	cl, 1
	call	PushSrcItem

; 439  :     return;
; 440  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
PushMacro ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
curr$ = 48
tv86 = 56
tv153 = 64
tv173 = 72
buffer$ = 96
GetTextLine PROC

; 694  : {

$LN17:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 695  :     struct src_item *curr = src_stack;

	mov	rax, QWORD PTR ModuleInfo+200
	mov	QWORD PTR curr$[rsp], rax

; 696  : 
; 697  :     if ( curr->type == SIT_FILE ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	test	eax, eax
	jne	$LN5@GetTextLin

; 698  : 
; 699  :         if( my_fgets( buffer, MAX_LINE_LEN, curr->file ) ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	edx, 600				; 00000258H
	mov	rcx, QWORD PTR buffer$[rsp]
	call	my_fgets
	test	rax, rax
	je	SHORT $LN7@GetTextLin

; 700  :             curr->line_num++;

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+24]
	inc	eax
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 701  : #ifdef DEBUG_OUT
; 702  :             if ( Parse_Pass == PASS_1 ) cntlines++;

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN8@GetTextLin
	mov	eax, DWORD PTR cntlines
	inc	eax
	mov	DWORD PTR cntlines, eax
$LN8@GetTextLin:

; 703  : #endif
; 704  :             return( buffer );

	mov	rax, QWORD PTR buffer$[rsp]
	jmp	$LN1@GetTextLin
$LN7@GetTextLin:

; 705  :         }
; 706  :         DebugCmd( ModuleInfo.g.FNames[curr->srcfile].lines = curr->line_num );

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, WORD PTR [rax+10]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR ModuleInfo+160
	mov	rdx, QWORD PTR curr$[rsp]
	mov	edx, DWORD PTR [rdx+24]
	mov	DWORD PTR [rcx+rax+12], edx

; 707  :         DebugMsg1(("GetTextLine: ***** EOF file %s (idx=%u) *****\n", GetFName( curr->srcfile )->fname, curr->srcfile ));

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, WORD PTR [rax+10]
	mov	DWORD PTR tv86[rsp], eax
	mov	rcx, QWORD PTR curr$[rsp]
	movzx	ecx, WORD PTR [rcx+10]
	call	GetFName
	mov	ecx, DWORD PTR tv86[rsp]
	mov	r8d, ecx
	mov	rdx, QWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11017
	call	DoDebugMsg1

; 708  :         /* don't close and remove main source file */
; 709  :         if ( curr->next ) {

	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN9@GetTextLin

; 710  :             fclose( curr->file );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	QWORD PTR __imp_fclose

; 711  :             src_stack = curr->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ModuleInfo+200, rax

; 712  :             curr->next = SrcFree;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR SrcFree
	mov	QWORD PTR [rax], rcx

; 713  :             SrcFree = curr;

	mov	rax, QWORD PTR curr$[rsp]
	mov	QWORD PTR SrcFree, rax
$LN9@GetTextLin:

; 714  :         }
; 715  :         /* update value of @FileCur variable */
; 716  :         for( curr = src_stack; curr->type != SIT_FILE; curr = curr->next );

	mov	rax, QWORD PTR ModuleInfo+200
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@GetTextLin
$LN2@GetTextLin:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$[rsp], rax
$LN4@GetTextLin:
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	test	eax, eax
	je	SHORT $LN3@GetTextLin
	jmp	SHORT $LN2@GetTextLin
$LN3@GetTextLin:

; 717  :         FileCur->string_ptr = GetFName( curr->srcfile)->fname;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, WORD PTR [rax+10]
	mov	ecx, eax
	call	GetFName
	mov	rcx, QWORD PTR FileCur
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx+16], rax

; 718  : #if FILESEQ
; 719  :         if ( Options.line_numbers && Parse_Pass == PASS_1 )
; 720  :             AddFileSeq( curr->srcfile );
; 721  : #endif
; 722  : 
; 723  :     } else {

	jmp	$LN6@GetTextLin
$LN5@GetTextLin:

; 724  : 
; 725  :         curr->mi->currline = ( curr->mi->currline ? curr->mi->currline->next : curr->mi->startline );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN15@GetTextLin
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv153[rsp], rax
	jmp	SHORT $LN16@GetTextLin
$LN15@GetTextLin:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv153[rsp], rax
$LN16@GetTextLin:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR tv153[rsp]
	mov	QWORD PTR [rax], rcx

; 726  :         if ( curr->mi->currline ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	cmp	QWORD PTR [rax], 0
	je	$LN10@GetTextLin

; 727  :             /* if line contains placeholders, replace them by current values */
; 728  :             if ( curr->mi->currline->ph_count ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+8]
	test	eax, eax
	je	SHORT $LN11@GetTextLin

; 729  :                 fill_placeholders( buffer,

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	r8, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [r8+16]
	mov	r8, QWORD PTR [r8]
	add	r8, 9
	mov	QWORD PTR tv173[rsp], r8
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR [rcx+16]
	mov	r8d, DWORD PTR [rdx+40]
	mov	rax, QWORD PTR tv173[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR buffer$[rsp]
	call	fill_placeholders

; 730  :                                   curr->mi->currline->line,
; 731  :                                   curr->mi->parmcnt,
; 732  :                                   curr->mi->localstart, curr->mi->parm_array );
; 733  :             } else {

	jmp	SHORT $LN12@GetTextLin
$LN11@GetTextLin:

; 734  :                 strcpy( buffer, curr->mi->currline->line );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rax]
	add	rax, 9
	mov	rdx, rax
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcpy
$LN12@GetTextLin:

; 735  :             }
; 736  :             curr->line_num++;

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+24]
	inc	eax
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 737  : #ifdef DEBUG_OUT
; 738  :             if ( Parse_Pass == PASS_1 ) cntlines++;

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN13@GetTextLin
	mov	eax, DWORD PTR cntlines
	inc	eax
	mov	DWORD PTR cntlines, eax
$LN13@GetTextLin:

; 739  : #endif
; 740  :             return( buffer );

	mov	rax, QWORD PTR buffer$[rsp]
	jmp	SHORT $LN1@GetTextLin
$LN10@GetTextLin:

; 741  :         }
; 742  :         src_stack = curr->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ModuleInfo+200, rax

; 743  :         curr->next = SrcFree;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR SrcFree
	mov	QWORD PTR [rax], rcx

; 744  :         SrcFree = curr;

	mov	rax, QWORD PTR curr$[rsp]
	mov	QWORD PTR SrcFree, rax
$LN6@GetTextLin:

; 745  :     }
; 746  : 
; 747  :     return( NULL ); /* end of file or macro reached */

	xor	eax, eax
$LN1@GetTextLin:

; 748  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
GetTextLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
file$ = 32
fl$ = 40
fn$ = 48
isabs$ = 56
fullpath$ = 80
fn2$4 = 360
src$5 = 368
i$6 = 376
$T7 = 392
tv83 = 400
__$ArrayPad$ = 408
path$ = 432
queue$ = 440
SearchFile PROC

; 597  : {

$LN23:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 416				; 000001a0H
	mov	rdi, rsp
	mov	ecx, 104				; 00000068H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+432]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 598  :     FILE        *file = NULL;

	mov	QWORD PTR file$[rsp], 0

; 599  :     struct src_item *fl;
; 600  :     const char  *fn;
; 601  :     bool        isabs;
; 602  :     char        fullpath[FILENAME_MAX];
; 603  : 
; 604  :     DebugMsg1(("SearchFile(%s) enter\n", path ));

	mov	rdx, QWORD PTR path$[rsp]
	lea	rcx, OFFSET FLAT:$SG10986
	call	DoDebugMsg1

; 605  : 
; 606  :     //_splitpath( path, drive, dir, fname, ext );
; 607  :     //DebugMsg1(("SearchFile(): drive=%s, dir=%s, fname=%s, ext=%s\n", drive, dir, fname, ext ));
; 608  :     fn = GetFNamePart( path );

	mov	rcx, QWORD PTR path$[rsp]
	call	GetFNamePart
	mov	QWORD PTR fn$[rsp], rax

; 609  : 
; 610  :     /* if no absolute path is given, then search in the directory
; 611  :      * of the current source file first!
; 612  :      * v2.11: various changes because field fullpath has been removed.
; 613  :      */
; 614  : 
; 615  :     isabs = ISABS( path );

	mov	rax, QWORD PTR path$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN17@SearchFile
	mov	rax, QWORD PTR path$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN17@SearchFile
	mov	rax, QWORD PTR path$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN18@SearchFile
	mov	rax, QWORD PTR path$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN18@SearchFile
	mov	rax, QWORD PTR path$[rsp]
	movsx	eax, BYTE PTR [rax+2]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN19@SearchFile
	mov	rax, QWORD PTR path$[rsp]
	movsx	eax, BYTE PTR [rax+2]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN17@SearchFile
$LN18@SearchFile:
	mov	DWORD PTR tv83[rsp], 0
	jmp	SHORT $LN20@SearchFile
$LN17@SearchFile:
$LN19@SearchFile:
	mov	DWORD PTR tv83[rsp], 1
$LN20@SearchFile:
	movzx	eax, BYTE PTR tv83[rsp]
	mov	BYTE PTR isabs$[rsp], al

; 616  :     //if ( dir[0] != '\\' && dir[0] != '/' ) {
; 617  :     if ( !isabs ) {

	movzx	eax, BYTE PTR isabs$[rsp]
	test	eax, eax
	jne	$LN5@SearchFile

; 618  :         for ( fl = src_stack; fl ; fl = fl->next ) {

	mov	rax, QWORD PTR ModuleInfo+200
	mov	QWORD PTR fl$[rsp], rax
	jmp	SHORT $LN4@SearchFile
$LN2@SearchFile:
	mov	rax, QWORD PTR fl$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR fl$[rsp], rax
$LN4@SearchFile:
	cmp	QWORD PTR fl$[rsp], 0
	je	$LN3@SearchFile

; 619  :             if ( fl->type == SIT_FILE ) {

	mov	rax, QWORD PTR fl$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	test	eax, eax
	jne	$LN6@SearchFile

; 620  :                 const char  *fn2;
; 621  :                 char        *src;
; 622  :                 //_splitpath( GetFName( fl->srcfile )->fname, drive2, dir2, NULL, NULL );
; 623  :                 //DebugMsg1(("SearchFile(): curr src=%s, split into drive=%s, dir=%s\n", GetFName( fl->srcfile)->fname, drive2, dir2 ));
; 624  :                 src = GetFName( fl->srcfile )->fname;

	mov	rax, QWORD PTR fl$[rsp]
	movzx	eax, WORD PTR [rax+10]
	mov	ecx, eax
	call	GetFName
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR src$5[rsp], rax

; 625  :                 fn2 = GetFNamePart( src );

	mov	rcx, QWORD PTR src$5[rsp]
	call	GetFNamePart
	mov	QWORD PTR fn2$4[rsp], rax

; 626  :                 if ( fn2 != src ) {

	mov	rax, QWORD PTR src$5[rsp]
	cmp	QWORD PTR fn2$4[rsp], rax
	je	$LN7@SearchFile

; 627  :                     int i = fn2 - src;

	mov	rax, QWORD PTR src$5[rsp]
	mov	rcx, QWORD PTR fn2$4[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR i$6[rsp], eax

; 628  :                     /* v2.10: if there's a directory part, add it to the directory part of the current file.
; 629  :                      * fixme: check that both parts won't exceed FILENAME_MAX!
; 630  :                      * fixme: 'path' is relative, but it may contain a drive letter!
; 631  :                      */
; 632  :                     memcpy( fullpath, src, i );

	movsxd	rax, DWORD PTR i$6[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR src$5[rsp]
	lea	rcx, QWORD PTR fullpath$[rsp]
	call	memcpy

; 633  :                     strcpy( fullpath + i, path );

	movsxd	rax, DWORD PTR i$6[rsp]
	lea	rax, QWORD PTR fullpath$[rsp+rax]
	mov	rdx, QWORD PTR path$[rsp]
	mov	rcx, rax
	call	strcpy

; 634  :                     if ( file = fopen( fullpath, "rb" ) ) {

	lea	rdx, OFFSET FLAT:$SG10992
	lea	rcx, QWORD PTR fullpath$[rsp]
	call	QWORD PTR __imp_fopen
	mov	QWORD PTR file$[rsp], rax
	cmp	QWORD PTR file$[rsp], 0
	je	SHORT $LN8@SearchFile

; 635  :                         DebugMsg1(("SearchFile(): file found, fopen(%s)=%X\n", fullpath, file ));

	mov	r8, QWORD PTR file$[rsp]
	lea	rdx, QWORD PTR fullpath$[rsp]
	lea	rcx, OFFSET FLAT:$SG10993
	call	DoDebugMsg1

; 636  :                         path = fullpath;

	lea	rax, QWORD PTR fullpath$[rsp]
	mov	QWORD PTR path$[rsp], rax

; 637  :                     }

	jmp	SHORT $LN9@SearchFile
$LN8@SearchFile:

; 638  : #ifdef DEBUG_OUT
; 639  :                     else
; 640  :                         DebugMsg1(("SearchFile(): fopen(%s) failed\n", fullpath ));

	lea	rdx, QWORD PTR fullpath$[rsp]
	lea	rcx, OFFSET FLAT:$SG10994
	call	DoDebugMsg1
$LN9@SearchFile:
$LN7@SearchFile:

; 641  : #endif
; 642  :                 }
; 643  :                 break;

	jmp	SHORT $LN3@SearchFile
$LN6@SearchFile:

; 644  :             }
; 645  :         }

	jmp	$LN2@SearchFile
$LN3@SearchFile:
$LN5@SearchFile:

; 646  :     }
; 647  :     if ( file == NULL ) {

	cmp	QWORD PTR file$[rsp], 0
	jne	$LN10@SearchFile

; 648  :         fullpath[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	QWORD PTR $T7[rsp], rax
	cmp	QWORD PTR $T7[rsp], 260			; 00000104H
	jae	SHORT $LN21@SearchFile
	jmp	SHORT $LN22@SearchFile
$LN21@SearchFile:
	call	__report_rangecheckfailure
$LN22@SearchFile:
	mov	rax, QWORD PTR $T7[rsp]
	mov	BYTE PTR fullpath$[rsp+rax], 0

; 649  :         file = fopen( path, "rb" );

	lea	rdx, OFFSET FLAT:$SG10996
	mov	rcx, QWORD PTR path$[rsp]
	call	QWORD PTR __imp_fopen
	mov	QWORD PTR file$[rsp], rax

; 650  :         DebugMsg1(("SearchFile(): fopen(%s)=%X\n", path, file ));

	mov	r8, QWORD PTR file$[rsp]
	mov	rdx, QWORD PTR path$[rsp]
	lea	rcx, OFFSET FLAT:$SG10997
	call	DoDebugMsg1

; 651  : 
; 652  :         /* if the file isn't found yet and include paths have been set,
; 653  :          * and NO absolute path is given, then search include dirs
; 654  :          */
; 655  :         if( file == NULL && ModuleInfo.g.IncludePath != NULL && !isabs ) {

	cmp	QWORD PTR file$[rsp], 0
	jne	SHORT $LN11@SearchFile
	cmp	QWORD PTR ModuleInfo+176, 0
	je	SHORT $LN11@SearchFile
	movzx	eax, BYTE PTR isabs$[rsp]
	test	eax, eax
	jne	SHORT $LN11@SearchFile

; 656  :             if ( file = open_file_in_include_path( path, fullpath ) ) {

	lea	rdx, QWORD PTR fullpath$[rsp]
	mov	rcx, QWORD PTR path$[rsp]
	call	open_file_in_include_path
	mov	QWORD PTR file$[rsp], rax
	cmp	QWORD PTR file$[rsp], 0
	je	SHORT $LN12@SearchFile

; 657  :                 DebugMsg1(("SearchFile(): open_file_in_include_path(%s)=%X [%s]\n", path, file, fullpath ));

	lea	r9, QWORD PTR fullpath$[rsp]
	mov	r8, QWORD PTR file$[rsp]
	mov	rdx, QWORD PTR path$[rsp]
	lea	rcx, OFFSET FLAT:$SG11001
	call	DoDebugMsg1

; 658  :                 path = fullpath;

	lea	rax, QWORD PTR fullpath$[rsp]
	mov	QWORD PTR path$[rsp], rax

; 659  :             }

	jmp	SHORT $LN13@SearchFile
$LN12@SearchFile:

; 660  : #ifdef DEBUG_OUT
; 661  :             else
; 662  :                 DebugMsg1(("SearchFile(): open_file_in_include_path(%s)=NULL\n", path ));

	mov	rdx, QWORD PTR path$[rsp]
	lea	rcx, OFFSET FLAT:$SG11002
	call	DoDebugMsg1
$LN13@SearchFile:
$LN11@SearchFile:

; 663  : #endif
; 664  :         }
; 665  :         if( file == NULL ) {

	cmp	QWORD PTR file$[rsp], 0
	jne	SHORT $LN14@SearchFile

; 666  :             EmitErr( CANNOT_OPEN_FILE, path, ErrnoStr() );

	call	ErrnoStr
	mov	r8, rax
	mov	rdx, QWORD PTR path$[rsp]
	mov	ecx, 106				; 0000006aH
	call	EmitErr

; 667  :             return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@SearchFile
$LN14@SearchFile:
$LN10@SearchFile:

; 668  :         }
; 669  :     }
; 670  :     /* is the file to be added to the file stack?
; 671  :      * assembly files usually are, but binary files ( INCBIN ) aren't.
; 672  :      */
; 673  :     if ( queue ) {

	movzx	eax, BYTE PTR queue$[rsp]
	test	eax, eax
	je	SHORT $LN15@SearchFile

; 674  :         fl = PushSrcItem( SIT_FILE, file );

	mov	rdx, QWORD PTR file$[rsp]
	xor	ecx, ecx
	call	PushSrcItem
	mov	QWORD PTR fl$[rsp], rax

; 675  :         fl->srcfile = AddFile( path );

	mov	rcx, QWORD PTR path$[rsp]
	call	AddFile
	mov	rcx, QWORD PTR fl$[rsp]
	mov	WORD PTR [rcx+10], ax

; 676  :         FileCur->string_ptr = GetFName( fl->srcfile )->fname;

	mov	rax, QWORD PTR fl$[rsp]
	movzx	eax, WORD PTR [rax+10]
	mov	ecx, eax
	call	GetFName
	mov	rcx, QWORD PTR FileCur
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx+16], rax
$LN15@SearchFile:

; 677  : #if FILESEQ
; 678  :         if ( Options.line_numbers && Parse_Pass == PASS_1 )
; 679  :             AddFileSeq( fl->srcfile );
; 680  : #endif
; 681  :     }
; 682  :     return( file );

	mov	rax, QWORD PTR file$[rsp]
$LN1@SearchFile:
$LN16@SearchFile:

; 683  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:SearchFile$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 416				; 000001a0H
	pop	rdi
	ret	0
SearchFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
rc$ = 0
tv76 = 8
fname$ = 32
GetExtPart PROC

; 171  : {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 172  :     char *rc;
; 173  :     for( rc = NULL; *fname; fname++ ) {

	mov	QWORD PTR rc$[rsp], 0
	jmp	SHORT $LN4@GetExtPart
$LN2@GetExtPart:
	mov	rax, QWORD PTR fname$[rsp]
	inc	rax
	mov	QWORD PTR fname$[rsp], rax
$LN4@GetExtPart:
	mov	rax, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@GetExtPart

; 174  :         if( *fname == '.' ) {

	mov	rax, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN5@GetExtPart

; 175  :             rc = (char *)fname;

	mov	rax, QWORD PTR fname$[rsp]
	mov	QWORD PTR rc$[rsp], rax
	jmp	SHORT $LN6@GetExtPart
$LN5@GetExtPart:

; 176  :         } else if( ISPC( *fname ) ) {

	mov	rax, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN8@GetExtPart
	mov	rax, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN8@GetExtPart
	mov	rax, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN7@GetExtPart
$LN8@GetExtPart:

; 177  :             rc = NULL;

	mov	QWORD PTR rc$[rsp], 0
$LN7@GetExtPart:
$LN6@GetExtPart:

; 178  :         }
; 179  :     }

	jmp	SHORT $LN2@GetExtPart
$LN3@GetExtPart:

; 180  :     return( rc ? rc : (char *)fname );

	cmp	QWORD PTR rc$[rsp], 0
	je	SHORT $LN10@GetExtPart
	mov	rax, QWORD PTR rc$[rsp]
	mov	QWORD PTR tv76[rsp], rax
	jmp	SHORT $LN11@GetExtPart
$LN10@GetExtPart:
	mov	rax, QWORD PTR fname$[rsp]
	mov	QWORD PTR tv76[rsp], rax
$LN11@GetExtPart:
	mov	rax, QWORD PTR tv76[rsp]

; 181  : }

	add	rsp, 16
	pop	rdi
	ret	0
GetExtPart ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
rc$ = 0
fname$ = 32
GetFNamePart PROC

; 159  : {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 160  :     const char *rc;
; 161  :     for ( rc = fname; *fname; fname++ )

	mov	rax, QWORD PTR fname$[rsp]
	mov	QWORD PTR rc$[rsp], rax
	jmp	SHORT $LN4@GetFNamePa
$LN2@GetFNamePa:
	mov	rax, QWORD PTR fname$[rsp]
	inc	rax
	mov	QWORD PTR fname$[rsp], rax
$LN4@GetFNamePa:
	mov	rax, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@GetFNamePa

; 162  :         if ( ISPC( *fname ) )

	mov	rax, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN6@GetFNamePa
	mov	rax, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN6@GetFNamePa
	mov	rax, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN5@GetFNamePa
$LN6@GetFNamePa:

; 163  :             rc = fname + 1;

	mov	rax, QWORD PTR fname$[rsp]
	inc	rax
	mov	QWORD PTR rc$[rsp], rax
$LN5@GetFNamePa:
	jmp	SHORT $LN2@GetFNamePa
$LN3@GetFNamePa:

; 164  :     return( rc );

	mov	rax, QWORD PTR rc$[rsp]

; 165  : }

	add	rsp, 16
	pop	rdi
	ret	0
GetFNamePart ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
GetLineNumber PROC

; 318  : {

$LN3:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 319  :     UpdateLineNumber( LineCur, NULL );

	xor	edx, edx
	mov	rcx, QWORD PTR LineCur
	call	UpdateLineNumber

; 320  :     return( LineCur->uvalue );

	mov	rax, QWORD PTR LineCur
	mov	eax, DWORD PTR [rax+16]

; 321  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
GetLineNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Buffer$ = 96
_Format$ = 104
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1788 : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:sprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp___stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1391 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Format$ = 96
printf	PROC						; COMDAT

; 950  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 957  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:printf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
	push	rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	rdi
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
