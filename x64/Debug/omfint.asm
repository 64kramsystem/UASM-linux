; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
CONST	SEGMENT
myFuncs	DQ	FLAT:writeUnexp
	DQ	FLAT:writeMisc
	DQ	FLAT:writeMisc32
	DQ	FLAT:writeSegdef
	DQ	FLAT:writeLedata
	DQ	FLAT:writeComent
	DQ	FLAT:writeTheadr
	DQ	FLAT:writeModend
	DQ	FLAT:writePubdef
	DQ	FLAT:writeLinnum
	DQ	FLAT:writeComdat
	DQ	FLAT:writeLinsym
func_index DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	05H
	DB	07H
	DB	01H
	DB	00H
	DB	08H
	DB	00H
	DB	09H
	DB	01H
	DB	03H
	DB	01H
	DB	02H
	DB	00H
	DB	04H
	DB	04H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	02H
	DB	01H
	DB	08H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	0aH
	DB	0bH
	DB	01H
	DB	02H
	DB	01H
CONST	ENDS
_DATA	SEGMENT
$SG7698	DB	'omfint.c', 00H
	ORG $+7
$SG7740	DB	'PutMem: buffer overflow error [length=%u, free=%u]', 0aH
	DB	00H
	ORG $+4
$SG7741	DB	'omfint.c', 00H
	ORG $+7
$SG7750	DB	'omfint.c', 00H
	ORG $+7
$SG7759	DB	'omfint.c', 00H
	ORG $+7
$SG7768	DB	'omfint.c', 00H
	ORG $+7
$SG7779	DB	'omfint.c', 00H
	ORG $+7
$SG7791	DB	'omfint.c', 00H
	ORG $+7
$SG7801	DB	'omfint.c', 00H
	ORG $+7
$SG7811	DB	'omfint.c', 00H
	ORG $+7
$SG7828	DB	'omfint.c', 00H
	ORG $+7
$SG7836	DB	'omfint.c', 00H
	ORG $+7
$SG7844	DB	'omfint.c', 00H
	ORG $+7
$SG7855	DB	'omfint.c', 00H
	ORG $+7
$SG7862	DB	'unexpected OMF record type 0x%02X', 0aH, 00H
	ORG $+5
$SG7863	DB	'omfint.c', 00H
	ORG $+7
$SG7888	DB	'omfint.c', 00H
	ORG $+7
$SG7889	DB	'omf_write_record( cmd=%X data=%p length=%u )', 0aH, 00H
_DATA	ENDS
PUBLIC	omf_write_record
EXTRN	__imp_fwrite:PROC
EXTRN	memcpy:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	Fatal:PROC
EXTRN	WriteError:PROC
EXTRN	InternalError:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$omf_write_record DD imagerel $LN5
	DD	imagerel $LN5+307
	DD	imagerel $unwind$omf_write_record
$pdata$safeWrite DD imagerel safeWrite
	DD	imagerel safeWrite+88
	DD	imagerel $unwind$safeWrite
$pdata$WBegRec DD imagerel WBegRec
	DD	imagerel WBegRec+36
	DD	imagerel $unwind$WBegRec
$pdata$WEndRec DD imagerel WEndRec
	DD	imagerel WEndRec+328
	DD	imagerel $unwind$WEndRec
$pdata$PutByte DD imagerel PutByte
	DD	imagerel PutByte+49
	DD	imagerel $unwind$PutByte
$pdata$PutIndex DD imagerel PutIndex
	DD	imagerel PutIndex+99
	DD	imagerel $unwind$PutIndex
$pdata$PutWord DD imagerel PutWord
	DD	imagerel PutWord+53
	DD	imagerel $unwind$PutWord
$pdata$PutDword DD imagerel PutDword
	DD	imagerel PutDword+50
	DD	imagerel $unwind$PutDword
$pdata$PutMem DD imagerel PutMem
	DD	imagerel PutMem+176
	DD	imagerel $unwind$PutMem
$pdata$writeMisc DD imagerel writeMisc
	DD	imagerel writeMisc+142
	DD	imagerel $unwind$writeMisc
$pdata$writeMisc32 DD imagerel writeMisc32
	DD	imagerel writeMisc32+156
	DD	imagerel $unwind$writeMisc32
$pdata$writeComent DD imagerel writeComent
	DD	imagerel writeComent+173
	DD	imagerel $unwind$writeComent
$pdata$writeSegdef DD imagerel writeSegdef
	DD	imagerel writeSegdef+394
	DD	imagerel $unwind$writeSegdef
$pdata$writeLedata DD imagerel writeLedata
	DD	imagerel writeLedata+247
	DD	imagerel $unwind$writeLedata
$pdata$writeTheadr DD imagerel writeTheadr
	DD	imagerel writeTheadr+103
	DD	imagerel $unwind$writeTheadr
$pdata$writeModend DD imagerel writeModend
	DD	imagerel writeModend+298
	DD	imagerel $unwind$writeModend
$pdata$PutBase DD imagerel PutBase
	DD	imagerel PutBase+122
	DD	imagerel $unwind$PutBase
$pdata$writePubdef DD imagerel writePubdef
	DD	imagerel writePubdef+198
	DD	imagerel $unwind$writePubdef
$pdata$writeLinnum DD imagerel writeLinnum
	DD	imagerel writeLinnum+176
	DD	imagerel $unwind$writeLinnum
$pdata$writeComdat DD imagerel writeComdat
	DD	imagerel writeComdat+345
	DD	imagerel $unwind$writeComdat
$pdata$writeLinsym DD imagerel writeLinsym
	DD	imagerel writeLinsym+192
	DD	imagerel $unwind$writeLinsym
$pdata$writeUnexp DD imagerel writeUnexp
	DD	imagerel writeUnexp+89
	DD	imagerel $unwind$writeUnexp
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
xdata	SEGMENT
$unwind$omf_write_record DD 033c19H
	DD	020c0113H
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	01050H
$unwind$safeWrite DD 022801H
	DD	070103214H
$unwind$WBegRec DD 010a01H
	DD	0700aH
$unwind$WEndRec DD 021e01H
	DD	07006920aH
$unwind$PutByte DD 010a01H
	DD	0700aH
$unwind$PutIndex DD 022301H
	DD	0700b320fH
$unwind$PutWord DD 010b01H
	DD	0700bH
$unwind$PutDword DD 010a01H
	DD	0700aH
$unwind$PutMem DD 022801H
	DD	070103214H
$unwind$writeMisc DD 022301H
	DD	0700b520fH
$unwind$writeMisc32 DD 022301H
	DD	0700b520fH
$unwind$writeComent DD 022301H
	DD	0700b520fH
$unwind$writeSegdef DD 022301H
	DD	0700b520fH
$unwind$writeLedata DD 022301H
	DD	0700b520fH
$unwind$writeTheadr DD 022301H
	DD	0700b520fH
$unwind$writeModend DD 022301H
	DD	0700b720fH
$unwind$PutBase DD 022301H
	DD	0700b320fH
$unwind$writePubdef DD 022301H
	DD	0700b520fH
$unwind$writeLinnum DD 022301H
	DD	0700b520fH
$unwind$writeComdat DD 022301H
	DD	0700b520fH
$unwind$writeLinsym DD 022301H
	DD	0700b520fH
$unwind$writeUnexp DD 022301H
	DD	0700b320fH
xdata	ENDS
CONST	SEGMENT
	ORG $+2
omf_write_record$rtcName$0 DB 06fH
	DB	075H
	DB	074H
	DB	00H
	ORG $+4
omf_write_record$rtcVarDesc DD 030H
	DD	0ff7H
	DQ	FLAT:omf_write_record$rtcName$0
	ORG $+48
omf_write_record$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:omf_write_record$rtcVarDesc
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeUnexp PROC

; 456  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 457  :     DebugMsg(("unexpected OMF record type 0x%02X\n", objr->command ));

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG7862
	call	DoDebugMsg

; 458  :     Fatal( INTERNAL_ERROR, __FILE__, __LINE__ );

	mov	r8d, 458				; 000001caH
	lea	rdx, OFFSET FLAT:$SG7863
	mov	ecx, 110				; 0000006eH
	call	Fatal

; 459  :     /* this is never reached, since Fatal() won't return */
; 460  :     return( 0 );

	xor	eax, eax

; 461  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
writeUnexp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
tv70 = 32
out$ = 64
objr$ = 72
writeLinsym PROC

; 440  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 441  : 
; 442  :     /**/myassert( objr->command == CMD_LINSYM );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	cmp	eax, 196				; 000000c4H
	jne	SHORT $LN3@writeLinsy
	mov	DWORD PTR tv70[rsp], 0
	jmp	SHORT $LN4@writeLinsy
$LN3@writeLinsy:
	mov	edx, 442				; 000001baH
	lea	rcx, OFFSET FLAT:$SG7855
	call	InternalError
	mov	DWORD PTR tv70[rsp], eax
$LN4@writeLinsy:

; 443  : 
; 444  :     WBegRec( out, CMD_LINSYM + objr->is_32 );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+17]
	add	eax, 196				; 000000c4H
	movzx	edx, al
	mov	rcx, QWORD PTR out$[rsp]
	call	WBegRec

; 445  :     PutByte( out, objr->d.linsym.flags );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, BYTE PTR [rax+20]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutByte

; 446  :     PutIndex( out, objr->d.linsym.public_lname_idx );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, WORD PTR [rax+22]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutIndex

; 447  :     PutMem( out, objr->data, objr->length );

	mov	rax, QWORD PTR objr$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rax, QWORD PTR objr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutMem

; 448  :     WEndRec( out );

	mov	rcx, QWORD PTR out$[rsp]
	call	WEndRec

; 449  :     return( 0 );

	xor	eax, eax

; 450  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
writeLinsym ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
tv70 = 32
out$ = 64
objr$ = 72
writeComdat PROC

; 412  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 413  :     /**/myassert( objr->command == CMD_COMDAT );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	cmp	eax, 194				; 000000c2H
	jne	SHORT $LN6@writeComda
	mov	DWORD PTR tv70[rsp], 0
	jmp	SHORT $LN7@writeComda
$LN6@writeComda:
	mov	edx, 413				; 0000019dH
	lea	rcx, OFFSET FLAT:$SG7844
	call	InternalError
	mov	DWORD PTR tv70[rsp], eax
$LN7@writeComda:

; 414  : 
; 415  :     /* write CMD_COMDAT/CMD_COMD32 */
; 416  :     WBegRec( out, objr->command + objr->is_32 );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	mov	rcx, QWORD PTR objr$[rsp]
	movzx	ecx, BYTE PTR [rcx+17]
	add	eax, ecx
	movzx	edx, al
	mov	rcx, QWORD PTR out$[rsp]
	call	WBegRec

; 417  :     PutByte( out, objr->d.comdat.flags );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, BYTE PTR [rax+20]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutByte

; 418  :     PutByte( out, objr->d.comdat.attributes );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, BYTE PTR [rax+21]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutByte

; 419  :     PutByte( out, objr->d.comdat.align );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, BYTE PTR [rax+22]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutByte

; 420  :     if( objr->is_32 ) {

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+17]
	test	eax, eax
	je	SHORT $LN2@writeComda

; 421  :         PutDword( out, objr->d.comdat.offset );

	mov	rax, QWORD PTR objr$[rsp]
	mov	edx, DWORD PTR [rax+24]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutDword

; 422  :     } else {

	jmp	SHORT $LN3@writeComda
$LN2@writeComda:

; 423  :         PutWord( out, objr->d.comdat.offset );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, WORD PTR [rax+24]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutWord
$LN3@writeComda:

; 424  :     }
; 425  :     PutIndex( out, objr->d.comdat.type_idx );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, WORD PTR [rax+28]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutIndex

; 426  :     if( ( objr->d.comdat.attributes & COMDAT_ALLOC_MASK ) == COMDAT_EXPLICIT ) {

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+21]
	and	eax, 15
	test	eax, eax
	jne	SHORT $LN4@writeComda

; 427  :         PutBase( out, &objr->d.comdat.base );

	mov	rax, QWORD PTR objr$[rsp]
	add	rax, 30
	mov	rdx, rax
	mov	rcx, QWORD PTR out$[rsp]
	call	PutBase
$LN4@writeComda:

; 428  :     }
; 429  :     PutIndex( out, objr->d.comdat.public_lname_idx );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, WORD PTR [rax+36]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutIndex

; 430  :     /* record is already in ms omf format */
; 431  :     PutMem( out, objr->data, objr->length );

	mov	rax, QWORD PTR objr$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rax, QWORD PTR objr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutMem

; 432  :     WEndRec( out );

	mov	rcx, QWORD PTR out$[rsp]
	call	WEndRec

; 433  :     return( 0 );

	xor	eax, eax

; 434  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
writeComdat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
tv70 = 32
out$ = 64
objr$ = 72
writeLinnum PROC

; 393  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 394  : 
; 395  :     /**/myassert( objr->command == CMD_LINNUM );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	cmp	eax, 148				; 00000094H
	jne	SHORT $LN3@writeLinnu
	mov	DWORD PTR tv70[rsp], 0
	jmp	SHORT $LN4@writeLinnu
$LN3@writeLinnu:
	mov	edx, 395				; 0000018bH
	lea	rcx, OFFSET FLAT:$SG7836
	call	InternalError
	mov	DWORD PTR tv70[rsp], eax
$LN4@writeLinnu:

; 396  : 
; 397  :     WBegRec( out, CMD_LINNUM + objr->is_32 );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+17]
	add	eax, 148				; 00000094H
	movzx	edx, al
	mov	rcx, QWORD PTR out$[rsp]
	call	WBegRec

; 398  :     PutBase( out, &objr->d.linnum.base );

	mov	rax, QWORD PTR objr$[rsp]
	add	rax, 20
	mov	rdx, rax
	mov	rcx, QWORD PTR out$[rsp]
	call	PutBase

; 399  :     PutMem( out, objr->data, objr->length );

	mov	rax, QWORD PTR objr$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rax, QWORD PTR objr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutMem

; 400  :     WEndRec( out );

	mov	rcx, QWORD PTR out$[rsp]
	call	WEndRec

; 401  :     return( 0 );

	xor	eax, eax

; 402  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
writeLinnum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
tv73 = 32
out$ = 64
objr$ = 72
writePubdef PROC

; 381  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 382  :     /**/myassert( objr->command == CMD_PUBDEF || objr->command == CMD_LPUBDEF );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	cmp	eax, 144				; 00000090H
	je	SHORT $LN3@writePubde
	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	cmp	eax, 182				; 000000b6H
	je	SHORT $LN3@writePubde
	mov	edx, 382				; 0000017eH
	lea	rcx, OFFSET FLAT:$SG7828
	call	InternalError
	mov	DWORD PTR tv73[rsp], eax
	jmp	SHORT $LN4@writePubde
$LN3@writePubde:
	mov	DWORD PTR tv73[rsp], 0
$LN4@writePubde:

; 383  : 
; 384  :     WBegRec( out, objr->command + objr->is_32 );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	mov	rcx, QWORD PTR objr$[rsp]
	movzx	ecx, BYTE PTR [rcx+17]
	add	eax, ecx
	movzx	edx, al
	mov	rcx, QWORD PTR out$[rsp]
	call	WBegRec

; 385  :     PutBase( out, &objr->d.pubdef.base );

	mov	rax, QWORD PTR objr$[rsp]
	add	rax, 20
	mov	rdx, rax
	mov	rcx, QWORD PTR out$[rsp]
	call	PutBase

; 386  :     PutMem( out, objr->data, objr->length );

	mov	rax, QWORD PTR objr$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rax, QWORD PTR objr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutMem

; 387  :     WEndRec( out );

	mov	rcx, QWORD PTR out$[rsp]
	call	WEndRec

; 388  :     return( 0 );

	xor	eax, eax

; 389  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
writePubdef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
base$ = 56
PutBase	PROC

; 371  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 372  :     PutIndex( out, base->grp_idx );

	mov	rax, QWORD PTR base$[rsp]
	movzx	edx, WORD PTR [rax]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutIndex

; 373  :     PutIndex( out, base->seg_idx );

	mov	rax, QWORD PTR base$[rsp]
	movzx	edx, WORD PTR [rax+2]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutIndex

; 374  :     if( base->grp_idx == 0 && base->seg_idx == 0 ) {

	mov	rax, QWORD PTR base$[rsp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	jne	SHORT $LN2@PutBase
	mov	rax, QWORD PTR base$[rsp]
	movzx	eax, WORD PTR [rax+2]
	test	eax, eax
	jne	SHORT $LN2@PutBase

; 375  :         PutWord( out, base->frame );

	mov	rax, QWORD PTR base$[rsp]
	movzx	edx, WORD PTR [rax+4]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutWord
$LN2@PutBase:

; 376  :     }
; 377  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
PutBase	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
is32$ = 32
mtype$ = 36
tv70 = 40
tv77 = 44
tv85 = 48
out$ = 80
objr$ = 88
writeModend PROC

; 336  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 337  :     int     is32;
; 338  :     //uint_8  is_log;
; 339  :     uint_8  mtype;
; 340  : 
; 341  :     /**/myassert( objr->command == CMD_MODEND );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	cmp	eax, 138				; 0000008aH
	jne	SHORT $LN5@writeModen
	mov	DWORD PTR tv70[rsp], 0
	jmp	SHORT $LN6@writeModen
$LN5@writeModen:
	mov	edx, 341				; 00000155H
	lea	rcx, OFFSET FLAT:$SG7811
	call	InternalError
	mov	DWORD PTR tv70[rsp], eax
$LN6@writeModen:

; 342  : 
; 343  :     is32 = ( ( objr->is_32 && objr->d.modend.start_addrs ) ? TRUE : FALSE );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+17]
	test	eax, eax
	je	SHORT $LN7@writeModen
	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+21]
	test	eax, eax
	je	SHORT $LN7@writeModen
	mov	DWORD PTR tv77[rsp], 1
	jmp	SHORT $LN8@writeModen
$LN7@writeModen:
	mov	DWORD PTR tv77[rsp], 0
$LN8@writeModen:
	mov	eax, DWORD PTR tv77[rsp]
	mov	DWORD PTR is32$[rsp], eax

; 344  :     WBegRec( out, CMD_MODEND + is32 );

	mov	eax, DWORD PTR is32$[rsp]
	add	eax, 138				; 0000008aH
	movzx	edx, al
	mov	rcx, QWORD PTR out$[rsp]
	call	WBegRec

; 345  :     /* first byte is Module Type:
; 346  :      * bit 7: 1=main program module
; 347  :      * bit 6: 1=contains start address
; 348  :      * bit 5: Segment bit ( according to OMF, this bit should be 1 )
; 349  :      * bit 1-4: must be 0
; 350  :      * bit 0: start address contains relocatable address ( according to OMF, this bit should be 1 )
; 351  :      * Masm does set bit 0, but does not set bit 5!
; 352  :      */
; 353  :     mtype = objr->d.modend.main_module ? 0x80 : 0;

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+20]
	test	eax, eax
	je	SHORT $LN9@writeModen
	mov	DWORD PTR tv85[rsp], 128		; 00000080H
	jmp	SHORT $LN10@writeModen
$LN9@writeModen:
	mov	DWORD PTR tv85[rsp], 0
$LN10@writeModen:
	movzx	eax, BYTE PTR tv85[rsp]
	mov	BYTE PTR mtype$[rsp], al

; 354  :     if( objr->d.modend.start_addrs ) {

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+21]
	test	eax, eax
	je	SHORT $LN2@writeModen

; 355  :         //is_log = objr->d.modend.is_logical;
; 356  :         //mtype |= 0x40 | is_log;
; 357  :         mtype |= 0x41;

	movzx	eax, BYTE PTR mtype$[rsp]
	or	eax, 65					; 00000041H
	mov	BYTE PTR mtype$[rsp], al

; 358  :         PutByte( out, mtype );

	movzx	edx, BYTE PTR mtype$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutByte

; 359  :         PutMem( out, objr->data, objr->length );

	mov	rax, QWORD PTR objr$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rax, QWORD PTR objr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutMem

; 360  :     } else

	jmp	SHORT $LN3@writeModen
$LN2@writeModen:

; 361  :         PutByte( out, mtype );

	movzx	edx, BYTE PTR mtype$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutByte
$LN3@writeModen:

; 362  : 
; 363  :     WEndRec( out );

	mov	rcx, QWORD PTR out$[rsp]
	call	WEndRec

; 364  :     return( 0 );

	xor	eax, eax

; 365  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
writeModend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
tv70 = 32
out$ = 64
objr$ = 72
writeTheadr PROC

; 328  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 329  :     /**/myassert( objr->command == CMD_THEADR );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN3@writeThead
	mov	DWORD PTR tv70[rsp], 0
	jmp	SHORT $LN4@writeThead
$LN3@writeThead:
	mov	edx, 329				; 00000149H
	lea	rcx, OFFSET FLAT:$SG7801
	call	InternalError
	mov	DWORD PTR tv70[rsp], eax
$LN4@writeThead:

; 330  : 
; 331  :     return( writeMisc( out, objr ) );

	mov	rdx, QWORD PTR objr$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	call	writeMisc

; 332  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
writeTheadr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
tv73 = 32
out$ = 64
objr$ = 72
writeLedata PROC

; 311  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 312  :     /**/myassert( objr->command == CMD_LEDATA || objr->command == CMD_LIDATA );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	cmp	eax, 160				; 000000a0H
	je	SHORT $LN5@writeLedat
	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	cmp	eax, 162				; 000000a2H
	je	SHORT $LN5@writeLedat
	mov	edx, 312				; 00000138H
	lea	rcx, OFFSET FLAT:$SG7791
	call	InternalError
	mov	DWORD PTR tv73[rsp], eax
	jmp	SHORT $LN6@writeLedat
$LN5@writeLedat:
	mov	DWORD PTR tv73[rsp], 0
$LN6@writeLedat:

; 313  : 
; 314  :     WBegRec( out, objr->command + objr->is_32 );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	mov	rcx, QWORD PTR objr$[rsp]
	movzx	ecx, BYTE PTR [rcx+17]
	add	eax, ecx
	movzx	edx, al
	mov	rcx, QWORD PTR out$[rsp]
	call	WBegRec

; 315  :     PutIndex( out, objr->d.ledata.idx );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, WORD PTR [rax+20]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutIndex

; 316  :     if( objr->is_32 ) {

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+17]
	test	eax, eax
	je	SHORT $LN2@writeLedat

; 317  :         PutDword( out, objr->d.ledata.offset );

	mov	rax, QWORD PTR objr$[rsp]
	mov	edx, DWORD PTR [rax+24]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutDword

; 318  :     } else {

	jmp	SHORT $LN3@writeLedat
$LN2@writeLedat:

; 319  :         PutWord( out, objr->d.ledata.offset );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, WORD PTR [rax+24]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutWord
$LN3@writeLedat:

; 320  :     }
; 321  :     PutMem( out, objr->data, objr->length );

	mov	rax, QWORD PTR objr$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rax, QWORD PTR objr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutMem

; 322  :     WEndRec( out );

	mov	rcx, QWORD PTR out$[rsp]
	call	WEndRec

; 323  :     return( 0 );

	xor	eax, eax

; 324  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
writeLedata ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
is32$ = 32
acbp$ = 36
align$ = 37
tv70 = 40
out$ = 64
objr$ = 72
writeSegdef PROC

; 215  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 216  :     int         is32;
; 217  :     uint_8      acbp;
; 218  :     uint_8      align;
; 219  : 
; 220  :     /**/myassert( objr->command == CMD_SEGDEF );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	cmp	eax, 152				; 00000098H
	jne	SHORT $LN7@writeSegde
	mov	DWORD PTR tv70[rsp], 0
	jmp	SHORT $LN8@writeSegde
$LN7@writeSegde:
	mov	edx, 220				; 000000dcH
	lea	rcx, OFFSET FLAT:$SG7779
	call	InternalError
	mov	DWORD PTR tv70[rsp], eax
$LN8@writeSegde:

; 221  : 
; 222  :     //is32 = objr->d.segdef.use_32;
; 223  :     is32 = objr->is_32;

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+17]
	mov	DWORD PTR is32$[rsp], eax

; 224  :     WBegRec( out, CMD_SEGDEF + is32 );

	mov	eax, DWORD PTR is32$[rsp]
	add	eax, 152				; 00000098H
	movzx	edx, al
	mov	rcx, QWORD PTR out$[rsp]
	call	WBegRec

; 225  : 
; 226  :     /* ACBP: bits=AAACCCBP
; 227  :      * AAA=alignment
; 228  :      * CCC=combination
; 229  :      * B=big
; 230  :      * P=32bit
; 231  :      */
; 232  :     acbp = ( objr->d.segdef.combine << 2 ) | objr->d.segdef.use_32;

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+24]
	shl	eax, 2
	mov	rcx, QWORD PTR objr$[rsp]
	movzx	ecx, BYTE PTR [rcx+22]
	or	eax, ecx
	mov	BYTE PTR acbp$[rsp], al

; 233  :     align = objr->d.segdef.align;

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+23]
	mov	BYTE PTR align$[rsp], al

; 234  : #if 1
; 235  :     acbp |= align << 5;

	movzx	eax, BYTE PTR align$[rsp]
	shl	eax, 5
	movzx	ecx, BYTE PTR acbp$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR acbp$[rsp], al

; 236  : #else
; 237  :     switch( align ) {
; 238  :     case SEGDEF_ALIGN_ABS:      acbp |= ALIGN_ABS << 5;     break;
; 239  :     case SEGDEF_ALIGN_BYTE:     acbp |= ALIGN_BYTE << 5;    break;
; 240  :     case SEGDEF_ALIGN_WORD:     acbp |= ALIGN_WORD << 5;    break;
; 241  :     case SEGDEF_ALIGN_PARA:     acbp |= ALIGN_PARA << 5;    break;
; 242  :     case SEGDEF_ALIGN_PAGE:     acbp |= ALIGN_PAGE << 5;    break;
; 243  :     case SEGDEF_ALIGN_DWORD:    acbp |= ALIGN_DWORD << 5;   break;
; 244  : #if PAGE4K
; 245  :     case SEGDEF_ALIGN_4KPAGE:   acbp |= ALIGN_4KPAGE << 5;  break;
; 246  : #endif
; 247  :     default: /**/myassert( 0 );
; 248  :     }
; 249  : #endif
; 250  :     /* set BIG bit. should also be done for 32-bit segments
; 251  :      * if their size is exactly 4 GB. Currently HJWasm won't
; 252  :      * support segments with size 4 GB.
; 253  :      */
; 254  :     if( is32 == 0 && objr->d.segdef.seg_length == 0x10000 ) {

	cmp	DWORD PTR is32$[rsp], 0
	jne	SHORT $LN2@writeSegde
	mov	rax, QWORD PTR objr$[rsp]
	cmp	DWORD PTR [rax+36], 65536		; 00010000H
	jne	SHORT $LN2@writeSegde

; 255  :         acbp |= 0x02;

	movzx	eax, BYTE PTR acbp$[rsp]
	or	eax, 2
	mov	BYTE PTR acbp$[rsp], al
$LN2@writeSegde:

; 256  :     }
; 257  : 
; 258  :     /* the segdef record is small (16bit: size 6 - 9 ):
; 259  :      * - byte acbp
; 260  :      * - word (32bit:dword) length
; 261  :      * - index seg name
; 262  :      * - index class name
; 263  :      * - index ovl name
; 264  :      * ABS segdefs are 3 bytes longer
; 265  :     */
; 266  : 
; 267  :     PutByte( out, acbp );

	movzx	edx, BYTE PTR acbp$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutByte

; 268  :     if( align == SEGDEF_ALIGN_ABS ) {

	movzx	eax, BYTE PTR align$[rsp]
	test	eax, eax
	jne	SHORT $LN3@writeSegde

; 269  :         /* absolut segment has frame=word and offset=byte
; 270  :          * it isn't fixupp physical reference
; 271  :          * and doesn't depend on segment size (16/32bit)
; 272  :          */
; 273  :         PutWord( out, objr->d.segdef.abs.frame );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, WORD PTR [rax+28]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutWord

; 274  :         PutByte( out, objr->d.segdef.abs.offset );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, BYTE PTR [rax+32]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutByte
$LN3@writeSegde:

; 275  :     }
; 276  :     if( is32 ) {

	cmp	DWORD PTR is32$[rsp], 0
	je	SHORT $LN4@writeSegde

; 277  :         PutDword( out, objr->d.segdef.seg_length );

	mov	rax, QWORD PTR objr$[rsp]
	mov	edx, DWORD PTR [rax+36]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutDword

; 278  :     } else {

	jmp	SHORT $LN5@writeSegde
$LN4@writeSegde:

; 279  :         PutWord( out, objr->d.segdef.seg_length );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, WORD PTR [rax+36]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutWord
$LN5@writeSegde:

; 280  :     }
; 281  : 
; 282  :     PutIndex( out, objr->d.segdef.seg_lname_idx );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, WORD PTR [rax+40]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutIndex

; 283  :     PutIndex( out, objr->d.segdef.class_lname_idx );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, WORD PTR [rax+42]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutIndex

; 284  :     PutIndex( out, objr->d.segdef.ovl_lname_idx );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, WORD PTR [rax+44]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutIndex

; 285  :     //if( objr->d.segdef.access_valid ) {
; 286  :     //    EmitError( ACCESS_CLASSES_NOT_SUPPORTED );
; 287  :     //}
; 288  :     WEndRec( out );

	mov	rcx, QWORD PTR out$[rsp]
	call	WEndRec

; 289  :     return( 0 );

	xor	eax, eax

; 290  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
writeSegdef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
tv69 = 32
out$ = 64
objr$ = 72
writeComent PROC

; 202  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 203  :     /**/myassert( objr->data != NULL );

	mov	rax, QWORD PTR objr$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@writeComen
	mov	DWORD PTR tv69[rsp], 0
	jmp	SHORT $LN4@writeComen
$LN3@writeComen:
	mov	edx, 203				; 000000cbH
	lea	rcx, OFFSET FLAT:$SG7768
	call	InternalError
	mov	DWORD PTR tv69[rsp], eax
$LN4@writeComen:

; 204  : 
; 205  :     WBegRec( out, CMD_COMENT );

	mov	dl, 136					; 00000088H
	mov	rcx, QWORD PTR out$[rsp]
	call	WBegRec

; 206  :     PutByte( out, objr->d.coment.attr );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, BYTE PTR [rax+20]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutByte

; 207  :     PutByte( out, objr->d.coment.cmt_class );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, BYTE PTR [rax+21]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutByte

; 208  :     PutMem( out, objr->data, objr->length );

	mov	rax, QWORD PTR objr$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rax, QWORD PTR objr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutMem

; 209  :     WEndRec( out );

	mov	rcx, QWORD PTR out$[rsp]
	call	WEndRec

; 210  :     return( 0 );

	xor	eax, eax

; 211  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
writeComent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
tv69 = 32
out$ = 64
objr$ = 72
writeMisc32 PROC

; 191  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 192  :     /**/myassert( objr->data != NULL );

	mov	rax, QWORD PTR objr$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@writeMisc3
	mov	DWORD PTR tv69[rsp], 0
	jmp	SHORT $LN4@writeMisc3
$LN3@writeMisc3:
	mov	edx, 192				; 000000c0H
	lea	rcx, OFFSET FLAT:$SG7759
	call	InternalError
	mov	DWORD PTR tv69[rsp], eax
$LN4@writeMisc3:

; 193  : 
; 194  :     WBegRec( out, objr->command | objr->is_32 );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	mov	rcx, QWORD PTR objr$[rsp]
	movzx	ecx, BYTE PTR [rcx+17]
	or	eax, ecx
	movzx	edx, al
	mov	rcx, QWORD PTR out$[rsp]
	call	WBegRec

; 195  :     PutMem( out, objr->data, objr->length );

	mov	rax, QWORD PTR objr$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rax, QWORD PTR objr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutMem

; 196  :     WEndRec( out );

	mov	rcx, QWORD PTR out$[rsp]
	call	WEndRec

; 197  :     return( 0 );

	xor	eax, eax

; 198  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
writeMisc32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
tv69 = 32
out$ = 64
objr$ = 72
writeMisc PROC

; 178  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 179  :     /**/myassert( objr->data != NULL );

	mov	rax, QWORD PTR objr$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@writeMisc
	mov	DWORD PTR tv69[rsp], 0
	jmp	SHORT $LN4@writeMisc
$LN3@writeMisc:
	mov	edx, 179				; 000000b3H
	lea	rcx, OFFSET FLAT:$SG7750
	call	InternalError
	mov	DWORD PTR tv69[rsp], eax
$LN4@writeMisc:

; 180  : 
; 181  :     WBegRec( out, objr->command );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	edx, BYTE PTR [rax+16]
	mov	rcx, QWORD PTR out$[rsp]
	call	WBegRec

; 182  :     PutMem( out, objr->data, objr->length );

	mov	rax, QWORD PTR objr$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rax, QWORD PTR objr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR out$[rsp]
	call	PutMem

; 183  :     WEndRec( out );

	mov	rcx, QWORD PTR out$[rsp]
	call	WEndRec

; 184  :     return( 0 );

	xor	eax, eax

; 185  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
writeMisc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
buf$ = 56
length$ = 64
PutMem	PROC

; 158  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 159  :     /* ensure that there is enough free space in the buffer,
; 160  :      * and also 1 byte left for the chksum!
; 161  :      */
; 162  :     if( length <= OBJ_BUFFER_SIZE - 1 - out->in_buf ) {

	mov	rax, QWORD PTR out$[rsp]
	mov	ecx, 4079				; 00000fefH
	sub	ecx, DWORD PTR [rax]
	mov	eax, ecx
	cmp	DWORD PTR length$[rsp], eax
	ja	SHORT $LN2@PutMem

; 163  :         memcpy( &out->buffer[ out->in_buf ], buf, length );

	mov	eax, DWORD PTR length$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	rdx, QWORD PTR out$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx+7]
	mov	r8d, eax
	mov	rdx, QWORD PTR buf$[rsp]
	call	memcpy

; 164  :         out->in_buf += length;

	mov	rax, QWORD PTR out$[rsp]
	mov	eax, DWORD PTR [rax]
	add	eax, DWORD PTR length$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	mov	DWORD PTR [rcx], eax

; 165  :     } else {

	jmp	SHORT $LN3@PutMem
$LN2@PutMem:

; 166  :         /* this "shouldn't happen". */
; 167  :         DebugMsg(("PutMem: buffer overflow error [length=%u, free=%u]\n", length, OBJ_BUFFER_SIZE - 1 - out->in_buf ));

	mov	rax, QWORD PTR out$[rsp]
	mov	ecx, 4079				; 00000fefH
	sub	ecx, DWORD PTR [rax]
	mov	eax, ecx
	mov	r8d, eax
	mov	edx, DWORD PTR length$[rsp]
	lea	rcx, OFFSET FLAT:$SG7740
	call	DoDebugMsg

; 168  :         Fatal( INTERNAL_ERROR, __FILE__, __LINE__ );

	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG7741
	mov	ecx, 110				; 0000006eH
	call	Fatal
$LN3@PutMem:

; 169  :     }
; 170  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
PutMem	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 16
value$ = 24
PutDword PROC

; 149  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 150  :     WriteU32( out->buffer + out->in_buf, value );

	mov	rax, QWORD PTR out$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR out$[rsp]
	mov	edx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rcx+rax+7], edx

; 151  :     out->in_buf += sizeof( uint_32 );

	mov	rax, QWORD PTR out$[rsp]
	mov	eax, DWORD PTR [rax]
	add	rax, 4
	mov	rcx, QWORD PTR out$[rsp]
	mov	DWORD PTR [rcx], eax

; 152  : }

	pop	rdi
	ret	0
PutDword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 16
value$ = 24
PutWord	PROC

; 140  : {

	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 141  :     WriteU16( out->buffer + out->in_buf, value );

	mov	rax, QWORD PTR out$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR out$[rsp]
	movzx	edx, WORD PTR value$[rsp]
	mov	WORD PTR [rcx+rax+7], dx

; 142  :     out->in_buf += sizeof( uint_16 );

	mov	rax, QWORD PTR out$[rsp]
	mov	eax, DWORD PTR [rax]
	add	rax, 2
	mov	rcx, QWORD PTR out$[rsp]
	mov	DWORD PTR [rcx], eax

; 143  : }

	pop	rdi
	ret	0
PutWord	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
index$ = 56
PutIndex PROC

; 129  : {

	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 130  :     if( index > 0x7f ) {

	movzx	eax, WORD PTR index$[rsp]
	cmp	eax, 127				; 0000007fH
	jle	SHORT $LN2@PutIndex

; 131  :         PutByte( out, 0x80 | ( index >> 8 ) );

	movzx	eax, WORD PTR index$[rsp]
	sar	eax, 8
	bts	eax, 7
	movzx	edx, al
	mov	rcx, QWORD PTR out$[rsp]
	call	PutByte
$LN2@PutIndex:

; 132  :     }
; 133  :     PutByte( out, index & 0xff );

	movzx	eax, WORD PTR index$[rsp]
	and	eax, 255				; 000000ffH
	movzx	edx, al
	mov	rcx, QWORD PTR out$[rsp]
	call	PutByte

; 134  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
PutIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 16
value$ = 24
PutByte	PROC

; 121  : {

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 122  :     out->buffer[ out->in_buf++ ] = value;

	mov	rax, QWORD PTR out$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR out$[rsp]
	movzx	edx, BYTE PTR value$[rsp]
	mov	BYTE PTR [rcx+rax+7], dl
	mov	rax, QWORD PTR out$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR out$[rsp]
	mov	DWORD PTR [rcx], eax

; 123  : }

	pop	rdi
	ret	0
PutByte	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
checksum$ = 32
p$ = 40
end$ = 48
tv71 = 56
tv137 = 64
tv140 = 72
out$ = 96
WEndRec	PROC

; 91   : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 92   :     uint_8  checksum;
; 93   :     uint_8  *p;
; 94   :     uint_8  *end;
; 95   : 
; 96   :     /**/myassert( out && out->cmd );

	cmp	QWORD PTR out$[rsp], 0
	je	SHORT $LN6@WEndRec
	mov	rax, QWORD PTR out$[rsp]
	movzx	eax, BYTE PTR [rax+4]
	test	eax, eax
	je	SHORT $LN6@WEndRec
	mov	DWORD PTR tv71[rsp], 0
	jmp	SHORT $LN7@WEndRec
$LN6@WEndRec:
	mov	edx, 96					; 00000060H
	lea	rcx, OFFSET FLAT:$SG7698
	call	InternalError
	mov	DWORD PTR tv71[rsp], eax
$LN7@WEndRec:

; 97   : 
; 98   :     out->reclen = out->in_buf + 1; /* add 1 for checksum byte */

	mov	rax, QWORD PTR out$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR out$[rsp]
	mov	WORD PTR [rcx+5], ax

; 99   :     checksum = out->cmd + ( out->reclen & 0xff ) + (( out->reclen ) >> 8);

	mov	rax, QWORD PTR out$[rsp]
	movzx	eax, BYTE PTR [rax+4]
	mov	rcx, QWORD PTR out$[rsp]
	movzx	ecx, WORD PTR [rcx+5]
	and	ecx, 255				; 000000ffH
	add	eax, ecx
	mov	rcx, QWORD PTR out$[rsp]
	movzx	ecx, WORD PTR [rcx+5]
	sar	ecx, 8
	add	eax, ecx
	mov	BYTE PTR checksum$[rsp], al

; 100  :     for( p = out->buffer, end = p + out->in_buf; p < end; ) {

	mov	rax, QWORD PTR out$[rsp]
	add	rax, 7
	mov	QWORD PTR p$[rsp], rax
	mov	rax, QWORD PTR out$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR end$[rsp], rax
$LN2@WEndRec:
	mov	rax, QWORD PTR end$[rsp]
	cmp	QWORD PTR p$[rsp], rax
	jae	SHORT $LN3@WEndRec

; 101  :         checksum += *p++;

	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rax]
	movzx	ecx, BYTE PTR checksum$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR checksum$[rsp], al
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 102  :     }

	jmp	SHORT $LN2@WEndRec
$LN3@WEndRec:

; 103  :     checksum = - checksum;

	movzx	eax, BYTE PTR checksum$[rsp]
	neg	eax
	mov	BYTE PTR checksum$[rsp], al

; 104  :     *p = checksum; /* store chksum in buffer */

	mov	rax, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR checksum$[rsp]
	mov	BYTE PTR [rax], cl

; 105  : 
; 106  :     /* write buffer + 4 extra bytes (1 cmd, 2 length, 1 chksum) */
; 107  :     safeWrite( CurrFile[OBJ], &out->cmd, out->in_buf + 4 );

	mov	rax, QWORD PTR out$[rsp]
	mov	eax, DWORD PTR [rax]
	add	eax, 4
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, 4
	mov	edx, 8
	imul	rdx, rdx, 1
	mov	QWORD PTR tv137[rsp], rdx
	lea	r8, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR tv140[rsp], r8
	mov	r8d, eax
	mov	rdx, rcx
	mov	rcx, QWORD PTR tv140[rsp]
	mov	rax, QWORD PTR tv137[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	safeWrite

; 108  : 
; 109  : #if 0 //def DEBUG_OUT
; 110  :     p = &out->cmd;
; 111  :     DebugMsg1(("WEndRec: %X %X %X %X\n", *p, *(p+1), *(p+2), *(p+3) ));
; 112  :     //printf( "WEndRec: %X %X %X %X (ofs cmd=%u ofs reclen=%u)\n", *p, *(p+1), *(p+2), *(p+3), offsetof( struct outbuff, cmd ), offsetof( struct outbuff, reclen ) );
; 113  : #endif
; 114  : 
; 115  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
WEndRec	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 16
command$ = 24
WBegRec	PROC

; 78   : {

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 79   :     out->in_buf = 0;

	mov	rax, QWORD PTR out$[rsp]
	mov	DWORD PTR [rax], 0

; 80   :     out->cmd = command;

	mov	rax, QWORD PTR out$[rsp]
	movzx	ecx, BYTE PTR command$[rsp]
	mov	BYTE PTR [rax+4], cl

; 81   : }

	pop	rdi
	ret	0
WBegRec	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
file$ = 48
buf$ = 56
len$ = 64
safeWrite PROC

; 56   : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 57   :     if( fwrite( buf, 1, len, file ) != len )

	mov	eax, DWORD PTR len$[rsp]
	mov	r9, QWORD PTR file$[rsp]
	mov	r8d, eax
	mov	edx, 1
	mov	rcx, QWORD PTR buf$[rsp]
	call	QWORD PTR __imp_fwrite
	mov	ecx, DWORD PTR len$[rsp]
	cmp	rax, rcx
	je	SHORT $LN2@safeWrite

; 58   :         WriteError();

	call	WriteError
$LN2@safeWrite:

; 59   : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
safeWrite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
_TEXT	SEGMENT
out$ = 48
tv74 = 4160
tv128 = 4168
__$ArrayPad$ = 4176
objr$ = 4208
omf_write_record PROC

; 522  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	eax, 4192				; 00001060H
	call	__chkstk
	sub	rsp, rax
	mov	rdi, rsp
	mov	ecx, 1048				; 00000418H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+4208]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 523  :     struct outbuff out;
; 524  : 
; 525  :     /**/myassert( objr != NULL && objr->command >= CMD_MIN_CMD && objr->command <= CMD_MAX_CMD + 1 );

	cmp	QWORD PTR objr$[rsp], 0
	je	SHORT $LN3@omf_write_
	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	cmp	eax, 128				; 00000080H
	jl	SHORT $LN3@omf_write_
	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	cmp	eax, 203				; 000000cbH
	jg	SHORT $LN3@omf_write_
	mov	DWORD PTR tv74[rsp], 0
	jmp	SHORT $LN4@omf_write_
$LN3@omf_write_:
	mov	edx, 525				; 0000020dH
	lea	rcx, OFFSET FLAT:$SG7888
	call	InternalError
	mov	DWORD PTR tv74[rsp], eax
$LN4@omf_write_:

; 526  :     DebugMsg1(("omf_write_record( cmd=%X data=%p length=%u )\n", objr->command, objr->data, objr->length ));

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	mov	rcx, QWORD PTR objr$[rsp]
	mov	r9d, DWORD PTR [rcx]
	mov	rcx, QWORD PTR objr$[rsp]
	mov	r8, QWORD PTR [rcx+8]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG7889
	call	DoDebugMsg1

; 527  :     myFuncs[ func_index[JUMP_INDEX(objr->command) ] ] ( &out, objr );

	mov	rax, QWORD PTR objr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	sub	eax, 128				; 00000080H
	sar	eax, 1
	cdqe
	lea	rcx, OFFSET FLAT:func_index
	movzx	eax, BYTE PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:myFuncs
	mov	QWORD PTR tv128[rsp], rcx
	mov	rdx, QWORD PTR objr$[rsp]
	lea	rcx, QWORD PTR out$[rsp]
	mov	r8, QWORD PTR tv128[rsp]
	call	QWORD PTR [r8+rax*8]

; 528  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:omf_write_record$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 4192				; 00001060H
	pop	rdi
	ret	0
omf_write_record ENDP
_TEXT	ENDS
END
