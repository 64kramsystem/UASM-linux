; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	Options
PUBLIC	DefaultDir
_BSS	SEGMENT
$SG11609 DB	01H DUP (?)
	ALIGN	4

$SG11641 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	8

DefaultDir DQ	04H DUP (?)
rspidx	DD	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
cmdl_options DQ	FLAT:$SG11397
	DD	00H
	ORG $+4
	DQ	FLAT:Set_h
	DQ	FLAT:$SG11398
	DD	017H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11399
	DD	00H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11400
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Cp
	DQ	FLAT:$SG11401
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Cu
	DQ	FLAT:$SG11402
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Cx
	DQ	FLAT:$SG11403
	DD	00H
	ORG $+4
	DQ	FLAT:Set_ce
	DQ	FLAT:$SG11404
	DD	02H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11405
	DD	00H
	ORG $+4
	DQ	FLAT:Set_c
	DQ	FLAT:$SG11406
	DD	00H
	ORG $+4
	DQ	FLAT:Set_dm
	DQ	FLAT:$SG11407
	DD	019H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11408
	DD	018H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11409
	DD	01bH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11410
	DD	01aH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11411
	DD	00H
	ORG $+4
	DQ	FLAT:Set_dt
	DQ	FLAT:$SG11412
	DD	00H
	ORG $+4
	DQ	FLAT:Set_D
	DQ	FLAT:$SG11413
	DD	0303H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11414
	DD	03H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11415
	DD	00H
	ORG $+4
	DQ	FLAT:Set_EP
	DQ	FLAT:$SG11416
	DD	0cH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11417
	DD	00H
	ORG $+4
	DQ	FLAT:Set_e
	DQ	FLAT:$SG11418
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fd
	DQ	FLAT:$SG11419
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fi
	DQ	FLAT:$SG11420
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fl
	DQ	FLAT:$SG11421
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fo
	DQ	FLAT:$SG11422
	DD	00H
	ORG $+4
	DQ	FLAT:Set_FPx
	DQ	FLAT:$SG11423
	DD	01H
	ORG $+4
	DQ	FLAT:Set_FPx
	DQ	FLAT:$SG11424
	DD	02H
	ORG $+4
	DQ	FLAT:Set_fp
	DQ	FLAT:$SG11425
	DD	03H
	ORG $+4
	DQ	FLAT:Set_fp
	DQ	FLAT:$SG11426
	DD	04H
	ORG $+4
	DQ	FLAT:Set_fp
	DQ	FLAT:$SG11427
	DD	01H
	ORG $+4
	DQ	FLAT:Set_fp
	DQ	FLAT:$SG11428
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fw
	DQ	FLAT:$SG11429
	DD	04H
	ORG $+4
	DQ	FLAT:Set_G
	DQ	FLAT:$SG11430
	DD	01H
	ORG $+4
	DQ	FLAT:Set_G
	DQ	FLAT:$SG11431
	DD	07H
	ORG $+4
	DQ	FLAT:Set_G
	DQ	FLAT:$SG11432
	DD	03H
	ORG $+4
	DQ	FLAT:Set_G
	DQ	FLAT:$SG11433
	DD	00H
	ORG $+4
	DQ	FLAT:Set_h
	DQ	FLAT:$SG11434
	DD	00H
	ORG $+4
	DQ	FLAT:Set_I
	DQ	FLAT:$SG11435
	DD	012H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11436
	DD	03H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11437
	DD	07H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11438
	DD	06H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11439
	DD	05H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11440
	DD	04H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11441
	DD	02H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11442
	DD	01H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11443
	DD	0100H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11444
	DD	00H
	ORG $+4
	DQ	FLAT:Set_nbp
	DQ	FLAT:$SG11445
	DD	08H
	ORG $+4
	DQ	FLAT:Set_n
	DQ	FLAT:$SG11446
	DD	07H
	ORG $+4
	DQ	FLAT:Set_n
	DQ	FLAT:$SG11447
	DD	00H
	ORG $+4
	DQ	FLAT:Set_nfp
	DQ	FLAT:$SG11448
	DD	05H
	ORG $+4
	DQ	FLAT:Set_n
	DQ	FLAT:$SG11449
	DD	00H
	ORG $+4
	DQ	FLAT:Set_nologo
	DQ	FLAT:$SG11450
	DD	06H
	ORG $+4
	DQ	FLAT:Set_n
	DQ	FLAT:$SG11451
	DD	01H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11452
	DD	0200H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11453
	DD	00H
	ORG $+4
	DQ	FLAT:Set_pm
	DQ	FLAT:$SG11454
	DD	00H
	ORG $+4
	DQ	FLAT:Set_q
	DQ	FLAT:$SG11455
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Sa
	DQ	FLAT:$SG11456
	DD	099H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11457
	DD	093H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11458
	DD	098H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11459
	DD	092H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11460
	DD	09bH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11461
	DD	016H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11462
	DD	00H
	ORG $+4
	DQ	FLAT:Set_WX
	DQ	FLAT:$SG11463
	DD	00H
	ORG $+4
	DQ	FLAT:Set_W
	DQ	FLAT:$SG11464
	DD	0302H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11465
	DD	00H
	ORG $+4
	DQ	FLAT:Set_w
	DQ	FLAT:$SG11466
	DD	09cH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11467
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Zd
	DQ	FLAT:$SG11468
	DD	09aH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11469
	DD	090H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11470
	DD	02H
	ORG $+4
	DQ	FLAT:Set_Zi
	DQ	FLAT:$SG11471
	DD	08eH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11472
	DD	08fH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11473
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Zp
	DQ	FLAT:$SG11474
	DD	00H
	ORG $+4
	DQ	FLAT:Set_zcm
	DQ	FLAT:$SG11475
	DD	085H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11476
	DD	00H
	ORG $+4
	DQ	FLAT:Set_zf
	DQ	FLAT:$SG11477
	DD	01H
	ORG $+4
	DQ	FLAT:Set_zf
	DQ	FLAT:$SG11478
	DD	080H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11479
	DD	081H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11480
	DD	082H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11481
	DD	083H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11482
	DD	084H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11483
	DD	0bcH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11484
	DD	01H
	ORG $+4
	DQ	FLAT:Set_zt
	DQ	FLAT:$SG11485
	DD	02H
	ORG $+4
	DQ	FLAT:Set_zt
	DQ	FLAT:$SG11486
	DD	00H
	ORG $+4
	DQ	FLAT:Set_zt
	DQ	FLAT:$SG11487
	DD	091H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11488
	DD	087H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11489
	DD	088H
	ORG $+4
	DQ	FLAT:Set_True
cpuoption DD	00H
	DD	010H
	DD	020H
	DD	030H
	DD	040H
	DD	050H
	DD	060H
	DD	0160H
	DD	0560H
	DD	0d60H
	DD	070H
CONST	ENDS
_DATA	SEGMENT
$SG11299 DB	'W', 00H
	ORG $+6
$SG11322 DB	'%3u: %s', 0aH, 00H
	ORG $+3
$SG11397 DB	'?', 00H
	ORG $+2
$SG11326 DB	'debugging output on', 0aH, 00H
	ORG $+3
$SG11330 DB	'FASTPASS disabled', 0aH, 00H
	ORG $+1
$SG11398 DB	'af', 00H
	ORG $+1
$SG11334 DB	'backpatching disabled', 0aH, 00H
	ORG $+1
$SG11399 DB	'bin', 00H
$SG11400 DB	'Cp', 00H
	ORG $+1
$SG11401 DB	'Cu', 00H
	ORG $+1
$SG11402 DB	'Cx', 00H
	ORG $+1
$SG11403 DB	'ce', 00H
	ORG $+1
$SG11404 DB	'coff', 00H
	ORG $+3
$SG11405 DB	'c', 00H
	ORG $+2
$SG11406 DB	'dm', 00H
	ORG $+1
$SG11407 DB	'drh', 00H
$SG11408 DB	'dr', 00H
	ORG $+1
$SG11409 DB	'dsh', 00H
$SG11410 DB	'ds', 00H
	ORG $+1
$SG11411 DB	'dt', 00H
	ORG $+1
$SG11412 DB	'D^$', 00H
$SG11413 DB	'elf64', 00H
	ORG $+2
$SG11414 DB	'elf', 00H
$SG11415 DB	'EP', 00H
	ORG $+1
$SG11416 DB	'eq', 00H
	ORG $+1
$SG11417 DB	'e=#', 00H
$SG11418 DB	'Fd=@', 00H
	ORG $+3
$SG11419 DB	'Fi=^@', 00H
	ORG $+2
$SG11420 DB	'Fl=@', 00H
	ORG $+3
$SG11421 DB	'Fo=^@', 00H
	ORG $+2
$SG11422 DB	'FPi87', 00H
	ORG $+2
$SG11423 DB	'FPi', 00H
$SG11424 DB	'fp0', 00H
$SG11425 DB	'fp2', 00H
$SG11426 DB	'fp3', 00H
$SG11427 DB	'fpc', 00H
$SG11428 DB	'Fw=^@', 00H
	ORG $+2
$SG11429 DB	'Gc', 00H
	ORG $+1
$SG11430 DB	'Gd', 00H
	ORG $+1
$SG11431 DB	'Gr', 00H
	ORG $+1
$SG11432 DB	'Gz', 00H
	ORG $+1
$SG11433 DB	'h', 00H
	ORG $+2
$SG11434 DB	'I=^@', 00H
	ORG $+3
$SG11435 DB	'ls', 00H
	ORG $+1
$SG11436 DB	'mc', 00H
	ORG $+1
$SG11437 DB	'mf', 00H
	ORG $+1
$SG11438 DB	'mh', 00H
	ORG $+1
$SG11439 DB	'ml', 00H
	ORG $+1
$SG11440 DB	'mm', 00H
	ORG $+1
$SG11441 DB	'ms', 00H
	ORG $+1
$SG11442 DB	'mt', 00H
	ORG $+1
$SG11443 DB	'mz', 00H
	ORG $+1
$SG11444 DB	'nbp', 00H
$SG11445 DB	'nc=$', 00H
	ORG $+3
$SG11446 DB	'nd=$', 00H
	ORG $+3
$SG11447 DB	'nfp', 00H
$SG11448 DB	'nm=$', 00H
	ORG $+3
$SG11449 DB	'nologo', 00H
	ORG $+1
$SG11450 DB	'nt=$', 00H
	ORG $+3
$SG11451 DB	'omf', 00H
$SG11452 DB	'pe', 00H
	ORG $+1
$SG11453 DB	'pm=#', 00H
	ORG $+3
$SG11454 DB	'q', 00H
	ORG $+2
$SG11455 DB	'Sa', 00H
	ORG $+1
$SG11456 DB	'Sf', 00H
	ORG $+1
$SG11457 DB	'Sg', 00H
	ORG $+1
$SG11458 DB	'Sn', 00H
	ORG $+1
$SG11459 DB	'Sx', 00H
	ORG $+1
$SG11460 DB	'safeseh', 00H
$SG11461 DB	'sp', 00H
	ORG $+1
$SG11462 DB	'WX', 00H
	ORG $+1
$SG11463 DB	'W=#', 00H
$SG11464 DB	'win64', 00H
	ORG $+2
$SG11465 DB	'w', 00H
	ORG $+2
$SG11466 DB	'X', 00H
	ORG $+2
$SG11467 DB	'Zd', 00H
	ORG $+1
$SG11468 DB	'Zf', 00H
	ORG $+1
$SG11469 DB	'Zg', 00H
	ORG $+1
$SG11470 DB	'Zi=#', 00H
	ORG $+3
$SG11471 DB	'Zm', 00H
	ORG $+1
$SG11472 DB	'Zne', 00H
$SG11473 DB	'Zp=#', 00H
	ORG $+3
$SG11474 DB	'zcm', 00H
$SG11475 DB	'zcw', 00H
$SG11476 DB	'zf0', 00H
$SG11477 DB	'zf1', 00H
$SG11478 DB	'zlc', 00H
$SG11479 DB	'zld', 00H
$SG11480 DB	'zlf', 00H
$SG11481 DB	'zlp', 00H
$SG11482 DB	'zls', 00H
$SG11483 DB	'Zs', 00H
	ORG $+1
$SG11484 DB	'zt0', 00H
$SG11485 DB	'zt1', 00H
$SG11486 DB	'zt2', 00H
$SG11487 DB	'Zv8', 00H
$SG11488 DB	'zze', 00H
$SG11489 DB	'zzs', 00H
$SG11508 DB	'GetNameToken( %s, %u, ''%c'' ) enter, rspidx=%u', 0aH, 00H
	ORG $+1
$SG11537 DB	'ReadParamFile(%s) enter', 0aH, 00H
	ORG $+3
$SG11538 DB	'rb', 00H
	ORG $+1
$SG11590 DB	'ProcessOption(%s)', 0aH, 00H
	ORG $+1
$SG11219 DB	'Zi', 00H
	ORG $+1
$SG11607 DB	'ProcessOption: unknown option specifier: %s', 0aH, 00H
	ORG $+3
$SG11608 DB	'cmdline.c', 00H
	ORG $+2
$SG11650 DB	'NULL', 00H
	ORG $+3
$SG11228 DB	'Zp', 00H
	ORG $+1
$SG11651 DB	'ParseCmdLine: file=>%s< rest=>%s<', 0aH, 00H
	ORG $+5
$SG11674 DB	'CmdLineFini enter', 0aH, 00H
	ORG $+5
$SG11677 DB	'CmdLineFini exit', 0aH, 00H
	ORG $+6
Options	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	00H
	DD	032H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+1
	DW	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	01H
	DD	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	ORG $+3
$SG11166 DB	'queue_item(%u, %s) enter', 0aH, 00H
	ORG $+6
$SG11179 DB	'get_fname( type=%u, >%s< ) enter', 0aH, 00H
	ORG $+6
$SG11181 DB	'get_fname(%u, >%s< ) name is empty or a directory', 0aH, 00H
	ORG $+5
$SG11185 DB	'get_fname: default drive+dir used: %s', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	ParseCmdline
PUBLIC	CmdlineFini
EXTRN	__report_rangecheckfailure:PROC
EXTRN	isspace:PROC
EXTRN	isalnum:PROC
EXTRN	__acrt_iob_func:PROC
EXTRN	fclose:PROC
EXTRN	fopen:PROC
EXTRN	fread:PROC
EXTRN	fseek:PROC
EXTRN	ftell:PROC
EXTRN	rewind:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	exit:PROC
EXTRN	getenv:PROC
EXTRN	strcat:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	Fatal:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	ErrnoStr:PROC
EXTRN	PrintUsage:PROC
EXTRN	MemAlloc:PROC
EXTRN	MemFree:PROC
EXTRN	MsgGetEx:PROC
EXTRN	InternalError:PROC
EXTRN	GetFNamePart:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	banner_printed:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
OptValue DD	01H DUP (?)
OptName	DQ	01H DUP (?)
cmdsave	DQ	0fH DUP (?)
cmdbuffers DQ	0fH DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$ParseCmdline DD imagerel $LN29
	DD	imagerel $LN29+1029
	DD	imagerel $unwind$ParseCmdline
$pdata$CmdlineFini DD imagerel $LN17
	DD	imagerel $LN17+324
	DD	imagerel $unwind$CmdlineFini
$pdata$SetCpuCmdline DD imagerel SetCpuCmdline
	DD	imagerel SetCpuCmdline+145
	DD	imagerel $unwind$SetCpuCmdline
$pdata$queue_item DD imagerel queue_item
	DD	imagerel queue_item+193
	DD	imagerel $unwind$queue_item
$pdata$get_fname DD imagerel get_fname
	DD	imagerel get_fname+545
	DD	imagerel $unwind$get_fname
$pdata$set_option_n_name DD imagerel set_option_n_name
	DD	imagerel set_option_n_name+217
	DD	imagerel $unwind$set_option_n_name
$pdata$Set_Zi DD imagerel Set_Zi
	DD	imagerel Set_Zi+67
	DD	imagerel $unwind$Set_Zi
$pdata$Set_Zp DD imagerel Set_Zp
	DD	imagerel Set_Zp+123
	DD	imagerel $unwind$Set_Zp
$pdata$Set_D DD	imagerel Set_D
	DD	imagerel Set_D+26
	DD	imagerel $unwind$Set_D
$pdata$Set_Fi DD imagerel Set_Fi
	DD	imagerel Set_Fi+23
	DD	imagerel $unwind$Set_Fi
$pdata$Set_I DD	imagerel Set_I
	DD	imagerel Set_I+26
	DD	imagerel $unwind$Set_I
$pdata$Set_q DD	imagerel Set_q
	DD	imagerel Set_q+21
	DD	imagerel $unwind$Set_q
$pdata$Set_EP DD imagerel Set_EP
	DD	imagerel Set_EP+21
	DD	imagerel $unwind$Set_EP
$pdata$Set_Fd DD imagerel Set_Fd
	DD	imagerel Set_Fd+33
	DD	imagerel $unwind$Set_Fd
$pdata$Set_Fw DD imagerel Set_Fw
	DD	imagerel Set_Fw+26
	DD	imagerel $unwind$Set_Fw
$pdata$Set_Fl DD imagerel Set_Fl
	DD	imagerel Set_Fl+33
	DD	imagerel $unwind$Set_Fl
$pdata$Set_Fo DD imagerel Set_Fo
	DD	imagerel Set_Fo+26
	DD	imagerel $unwind$Set_Fo
$pdata$Set_True DD imagerel Set_True
	DD	imagerel Set_True+39
	DD	imagerel $unwind$Set_True
$pdata$Set_n DD	imagerel Set_n
	DD	imagerel Set_n+27
	DD	imagerel $unwind$Set_n
$pdata$Set_w DD	imagerel Set_w
	DD	imagerel Set_w+21
	DD	imagerel $unwind$Set_w
$pdata$Set_W DD	imagerel Set_W
	DD	imagerel Set_W+55
	DD	imagerel $unwind$Set_W
$pdata$Set_h DD	imagerel Set_h
	DD	imagerel Set_h+24
	DD	imagerel $unwind$Set_h
$pdata$Set_dm DD imagerel Set_dm
	DD	imagerel Set_dm+69
	DD	imagerel $unwind$Set_dm
$pdata$Set_dt DD imagerel Set_dt
	DD	imagerel Set_dt+44
	DD	imagerel $unwind$Set_dt
$pdata$Set_nfp DD imagerel Set_nfp
	DD	imagerel Set_nfp+28
	DD	imagerel $unwind$Set_nfp
$pdata$Set_nbp DD imagerel Set_nbp
	DD	imagerel Set_nbp+28
	DD	imagerel $unwind$Set_nbp
$pdata$GetNameToken DD imagerel GetNameToken
	DD	imagerel GetNameToken+539
	DD	imagerel $unwind$GetNameToken
$pdata$ReadParamFile DD imagerel ReadParamFile
	DD	imagerel ReadParamFile+335
	DD	imagerel $unwind$ReadParamFile
$pdata$getnextcmdstring DD imagerel getnextcmdstring
	DD	imagerel getnextcmdstring+206
	DD	imagerel $unwind$getnextcmdstring
$pdata$ProcessOption DD imagerel ProcessOption
	DD	imagerel ProcessOption+1059
	DD	imagerel $unwind$ProcessOption
pdata	ENDS
xdata	SEGMENT
$unwind$ParseCmdline DD 022319H
	DD	02d0111H
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$CmdlineFini DD 010401H
	DD	08204H
$unwind$SetCpuCmdline DD 010d01H
	DD	0420dH
$unwind$queue_item DD 010d01H
	DD	0620dH
$unwind$get_fname DD 022219H
	DD	02b0110H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$set_option_n_name DD 010d01H
	DD	0420dH
$unwind$Set_Zi DD 010401H
	DD	04204H
$unwind$Set_Zp DD 010401H
	DD	06204H
$unwind$Set_D DD 010401H
	DD	04204H
$unwind$Set_Fi DD 010401H
	DD	04204H
$unwind$Set_I DD 010401H
	DD	04204H
$unwind$Set_q DD 010401H
	DD	04204H
$unwind$Set_EP DD 010401H
	DD	04204H
$unwind$Set_Fd DD 010401H
	DD	04204H
$unwind$Set_Fw DD 010401H
	DD	04204H
$unwind$Set_Fl DD 010401H
	DD	04204H
$unwind$Set_Fo DD 010401H
	DD	04204H
$unwind$Set_True DD 010401H
	DD	02204H
$unwind$Set_n DD 010401H
	DD	04204H
$unwind$Set_w DD 010401H
	DD	04204H
$unwind$Set_W DD 010401H
	DD	04204H
$unwind$Set_h DD 010401H
	DD	04204H
$unwind$Set_dm DD 010401H
	DD	06204H
$unwind$Set_dt DD 010401H
	DD	04204H
$unwind$Set_nfp DD 010401H
	DD	04204H
$unwind$Set_nbp DD 010401H
	DD	04204H
$unwind$GetNameToken DD 011801H
	DD	08218H
$unwind$ReadParamFile DD 010901H
	DD	08209H
$unwind$getnextcmdstring DD 010901H
	DD	06209H
$unwind$ProcessOption DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
i$ = 32
j$ = 36
tv156 = 40
p$ = 48
opt$ = 56
cmdline$ = 80
buffer$ = 88
ProcessOption PROC

; 824  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 825  :     int   i;
; 826  :     int   j;
; 827  :     const char *p = *cmdline;

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$[rsp], rax

; 828  :     const char *opt;
; 829  :     //char  c;
; 830  : 
; 831  :     DebugMsg(("ProcessOption(%s)\n", p ));

	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, OFFSET FLAT:$SG11590
	call	DoDebugMsg

; 832  : 
; 833  :     /* numeric option (-0, -1, ... ) handled separately since
; 834  :      * the value can be >= 10.
; 835  :      */
; 836  :     if ( *p >= '0' && *p <= '9' ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN15@ProcessOpt
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN15@ProcessOpt

; 837  :         p = GetNumber( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	GetNumber
	mov	QWORD PTR p$[rsp], rax

; 838  :         if ( OptValue < sizeof(cpuoption)/sizeof(cpuoption[0]) ) {

	mov	eax, DWORD PTR OptValue
	cmp	rax, 11
	jae	SHORT $LN16@ProcessOpt

; 839  :             p = GetNameToken( buffer, p, 16, 0 ); /* get optional 'p' */

	xor	r9d, r9d
	mov	r8d, 16
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	GetNameToken
	mov	QWORD PTR p$[rsp], rax

; 840  :             *cmdline = p;

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 841  :             SetCpuCmdline( cpuoption[OptValue], buffer );

	mov	eax, DWORD PTR OptValue
	lea	rcx, OFFSET FLAT:cpuoption
	mov	rdx, QWORD PTR buffer$[rsp]
	mov	ecx, DWORD PTR [rcx+rax*4]
	call	SetCpuCmdline

; 842  :             return;

	jmp	$LN1@ProcessOpt
$LN16@ProcessOpt:

; 843  :         }
; 844  :         p = *cmdline; /* v2.11: restore option pointer */

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$[rsp], rax
$LN15@ProcessOpt:

; 845  :     }
; 846  :     for( i = 0; i < ( sizeof(cmdl_options) / sizeof(cmdl_options[0]) ); i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@ProcessOpt
$LN2@ProcessOpt:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@ProcessOpt:
	movsxd	rax, DWORD PTR i$[rsp]
	cmp	rax, 93					; 0000005dH
	jae	$LN3@ProcessOpt

; 847  :         //DebugMsg(("ProcessOption(%s): %s\n", p, opt ));
; 848  :         if( *p == *cmdl_options[i].name ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 24
	lea	rdx, OFFSET FLAT:cmdl_options
	mov	rcx, QWORD PTR [rdx+rcx]
	movsx	ecx, BYTE PTR [rcx]
	cmp	eax, ecx
	jne	$LN17@ProcessOpt

; 849  :             for ( opt = cmdl_options[i].name+1, j = 1 ; isalnum(*opt) && *opt == p[j]; opt++, j++ );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cmdl_options
	mov	rax, QWORD PTR [rcx+rax]
	inc	rax
	mov	QWORD PTR opt$[rsp], rax
	mov	DWORD PTR j$[rsp], 1
	jmp	SHORT $LN7@ProcessOpt
$LN5@ProcessOpt:
	mov	rax, QWORD PTR opt$[rsp]
	inc	rax
	mov	QWORD PTR opt$[rsp], rax
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN7@ProcessOpt:
	mov	rax, QWORD PTR opt$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isalnum
	test	eax, eax
	je	SHORT $LN6@ProcessOpt
	mov	rax, QWORD PTR opt$[rsp]
	movsx	eax, BYTE PTR [rax]
	movsxd	rcx, DWORD PTR j$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN6@ProcessOpt
	jmp	SHORT $LN5@ProcessOpt
$LN6@ProcessOpt:

; 850  :             /* make sure end of option is reached */
; 851  :             if ( isalnum(*opt) )

	mov	rax, QWORD PTR opt$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isalnum
	test	eax, eax
	je	SHORT $LN18@ProcessOpt

; 852  :                 continue;

	jmp	$LN2@ProcessOpt
$LN18@ProcessOpt:

; 853  :             p += j;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 854  :             OptValue = cmdl_options[i].value;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cmdl_options
	mov	eax, DWORD PTR [rcx+rax+8]
	mov	DWORD PTR OptValue, eax
	jmp	SHORT $LN10@ProcessOpt
$LN8@ProcessOpt:

; 855  :             //DebugMsg(("ProcessOption(%s): Option found\n", p ));
; 856  :             for( ;; opt++) {

	mov	rax, QWORD PTR opt$[rsp]
	inc	rax
	mov	QWORD PTR opt$[rsp], rax
$LN10@ProcessOpt:

; 857  :                 switch ( *opt ) {

	mov	rax, QWORD PTR opt$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv156[rsp], eax
	cmp	DWORD PTR tv156[rsp], 94		; 0000005eH
	ja	$LN30@ProcessOpt
	movsxd	rax, DWORD PTR tv156[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN32@ProcessOpt[rcx+rax]
	mov	eax, DWORD PTR $LN33@ProcessOpt[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN19@ProcessOpt:

; 858  :                 //case '*': /* don't know what this is supposed to do? */
; 859  :                 case NULLC:
; 860  :                     if ( !IsOptionDelimiter( *p ) )

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN20@ProcessOpt
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN20@ProcessOpt
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN20@ProcessOpt
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN20@ProcessOpt
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 9
	je	SHORT $LN20@ProcessOpt

; 861  :                         goto opt_error_exit;

	jmp	$opt_error_exit$34
$LN20@ProcessOpt:

; 862  :                     *cmdline = p;

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 863  :                     cmdl_options[i].function();

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cmdl_options
	call	QWORD PTR [rcx+rax+16]

; 864  :                     return; /* option processed successfully */

	jmp	$LN1@ProcessOpt

; 865  :                     break;

	jmp	$LN11@ProcessOpt
$LN21@ProcessOpt:

; 866  :                 case '#':             /* collect a number */
; 867  :                     if( *p >= '0' && *p <= '9' )

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN22@ProcessOpt
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN22@ProcessOpt

; 868  :                         p = GetNumber( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	GetNumber
	mov	QWORD PTR p$[rsp], rax
$LN22@ProcessOpt:

; 869  :                     break;

	jmp	$LN11@ProcessOpt
$LN23@ProcessOpt:

; 870  :                 case '$':      /* collect an identifer+value */
; 871  :                 case '@':      /* collect a filename */
; 872  :                     OptName = buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR OptName, rax

; 873  : #if 0  /* v2.05: removed */
; 874  :                     if ( rspidx )
; 875  :                         p = GetNameToken( buffer, p, FILENAME_MAX - 1, *opt );
; 876  :                     else {
; 877  :                         j = strlen( p );
; 878  :                         memcpy( buffer, p, (j >= FILENAME_MAX) ? FILENAME_MAX : j + 1 );
; 879  :                         p += j;
; 880  :                     }
; 881  : #else
; 882  :                     /* v2.10: spaces in filename now handled inside GetNameToken() */
; 883  :                     p = GetNameToken( buffer, p, FILENAME_MAX - 1, *opt );

	mov	rax, QWORD PTR opt$[rsp]
	movzx	r9d, BYTE PTR [rax]
	mov	r8d, 259				; 00000103H
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	GetNameToken
	mov	QWORD PTR p$[rsp], rax

; 884  : #endif
; 885  :                     break;

	jmp	$LN11@ProcessOpt
$LN24@ProcessOpt:

; 886  :                 case '=':    /* collect an optional '=' */
; 887  :                     if ( *p == '=' || *p == '#' )

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN26@ProcessOpt
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN25@ProcessOpt
$LN26@ProcessOpt:

; 888  :                         p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN25@ProcessOpt:

; 889  :                     break;

	jmp	SHORT $LN11@ProcessOpt
$LN27@ProcessOpt:
$LN13@ProcessOpt:

; 890  :                 case '^':    /* skip spaces before argument */
; 891  :                     while ( isspace(*p) ) p++;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isspace
	test	eax, eax
	je	SHORT $LN14@ProcessOpt
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN13@ProcessOpt
$LN14@ProcessOpt:

; 892  :                     if ( *p == NULLC ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN28@ProcessOpt

; 893  :                         p = getnextcmdstring( cmdline );

	mov	rcx, QWORD PTR cmdline$[rsp]
	call	getnextcmdstring
	mov	QWORD PTR p$[rsp], rax

; 894  :                         if ( p == NULL ) {

	cmp	QWORD PTR p$[rsp], 0
	jne	SHORT $LN29@ProcessOpt

; 895  :                             EmitWarn( 1, MISSING_ARGUMENT_FOR_CMDLINE_OPTION );

	mov	edx, 251				; 000000fbH
	mov	ecx, 1
	call	EmitWarn

; 896  :                             return;

	jmp	SHORT $LN1@ProcessOpt
$LN29@ProcessOpt:
$LN28@ProcessOpt:

; 897  :                         }
; 898  :                     }
; 899  :                     break;

	jmp	SHORT $LN11@ProcessOpt
$LN30@ProcessOpt:

; 900  :                 default:
; 901  :                     /* internal error: unknown format of option item! */
; 902  :                     DebugMsg(( "ProcessOption: unknown option specifier: %s\n", opt ));

	mov	rdx, QWORD PTR opt$[rsp]
	lea	rcx, OFFSET FLAT:$SG11607
	call	DoDebugMsg

; 903  :                     /**/myassert( 0 );

	mov	edx, 903				; 00000387H
	lea	rcx, OFFSET FLAT:$SG11608
	call	InternalError
$LN11@ProcessOpt:

; 904  :                     break;
; 905  :                 }
; 906  :             }

	jmp	$LN8@ProcessOpt
$LN17@ProcessOpt:

; 907  :         }
; 908  :     }

	jmp	$LN2@ProcessOpt
$LN3@ProcessOpt:
$opt_error_exit$34:

; 909  : opt_error_exit:
; 910  :     EmitWarn( 1, INVALID_CMDLINE_OPTION, *cmdline - 1 );

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rax, QWORD PTR [rax]
	dec	rax
	mov	r8, rax
	mov	edx, 109				; 0000006dH
	mov	ecx, 1
	call	EmitWarn

; 911  :     *cmdline = "";

	mov	rax, QWORD PTR cmdline$[rsp]
	lea	rcx, OFFSET FLAT:$SG11609
	mov	QWORD PTR [rax], rcx
$LN1@ProcessOpt:

; 912  :     return;
; 913  : }

	add	rsp, 72					; 00000048H
	ret	0
	npad	2
$LN33@ProcessOpt:
	DD	$LN19@ProcessOpt
	DD	$LN21@ProcessOpt
	DD	$LN23@ProcessOpt
	DD	$LN24@ProcessOpt
	DD	$LN27@ProcessOpt
	DD	$LN30@ProcessOpt
$LN32@ProcessOpt:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
ProcessOption ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
p$ = 8
GetNumber PROC

; 807  : {

	mov	QWORD PTR [rsp+8], rcx

; 808  :     OptValue = 0;

	mov	DWORD PTR OptValue, 0

; 809  :     for( ;*p >= '0' && *p <= '9'; p++ )

	jmp	SHORT $LN4@GetNumber
$LN2@GetNumber:
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN4@GetNumber:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN3@GetNumber
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN3@GetNumber

; 810  :         OptValue = OptValue * 10 + *p - '0';

	imul	eax, DWORD PTR OptValue, 10
	mov	rcx, QWORD PTR p$[rsp]
	movsx	ecx, BYTE PTR [rcx]
	lea	eax, DWORD PTR [rax+rcx-48]
	mov	DWORD PTR OptValue, eax
	jmp	SHORT $LN2@GetNumber
$LN3@GetNumber:

; 811  :     return( p );

	mov	rax, QWORD PTR p$[rsp]

; 812  : }

	ret	0
GetNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
src$ = 32
dst$ = 40
cmdline$ = 64
getnextcmdstring PROC

; 788  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 789  :     const char **src;
; 790  :     const char **dst;
; 791  : 
; 792  :     /* something onto the response file stack? */
; 793  :     if ( rspidx ) {

	cmp	DWORD PTR rspidx, 0
	je	SHORT $LN5@getnextcmd

; 794  :         rspidx--;

	mov	eax, DWORD PTR rspidx
	dec	eax
	mov	DWORD PTR rspidx, eax

; 795  :         if ( cmdbuffers[rspidx] )

	movsxd	rax, DWORD PTR rspidx
	lea	rcx, OFFSET FLAT:cmdbuffers
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN6@getnextcmd

; 796  :             MemFree( (void *)cmdbuffers[rspidx] );

	movsxd	rax, DWORD PTR rspidx
	lea	rcx, OFFSET FLAT:cmdbuffers
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	MemFree
$LN6@getnextcmd:

; 797  :         return( cmdsave[rspidx] );

	movsxd	rax, DWORD PTR rspidx
	lea	rcx, OFFSET FLAT:cmdsave
	mov	rax, QWORD PTR [rcx+rax*8]
	jmp	SHORT $LN1@getnextcmd
$LN5@getnextcmd:

; 798  :     }
; 799  :     for ( dst = cmdline, src = cmdline+1; *src; )

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR cmdline$[rsp]
	add	rax, 8
	mov	QWORD PTR src$[rsp], rax
$LN2@getnextcmd:
	mov	rax, QWORD PTR src$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@getnextcmd

; 800  :         *dst++ = *src++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR dst$[rsp]
	add	rax, 8
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	add	rax, 8
	mov	QWORD PTR src$[rsp], rax
	jmp	SHORT $LN2@getnextcmd
$LN3@getnextcmd:

; 801  :     *dst = *src;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 802  :     return( *cmdline );

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rax, QWORD PTR [rax]
$LN1@getnextcmd:

; 803  : }

	add	rsp, 56					; 00000038H
	ret	0
getnextcmdstring ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
ch$ = 32
len$ = 36
file$ = 40
str$ = 48
env$ = 56
name$ = 80
ReadParamFile PROC

; 735  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 736  :     char        *env;
; 737  :     char        *str;
; 738  :     FILE        *file;
; 739  :     int         len;
; 740  :     char        ch;
; 741  : 
; 742  :     DebugMsg(("ReadParamFile(%s) enter\n"));

	lea	rcx, OFFSET FLAT:$SG11537
	call	DoDebugMsg

; 743  :     env = NULL;

	mov	QWORD PTR env$[rsp], 0

; 744  :     file = fopen( name, "rb" );

	lea	rdx, OFFSET FLAT:$SG11538
	mov	rcx, QWORD PTR name$[rsp]
	call	fopen
	mov	QWORD PTR file$[rsp], rax

; 745  :     if( file == NULL ) {

	cmp	QWORD PTR file$[rsp], 0
	jne	SHORT $LN4@ReadParamF

; 746  :         /* v2.10: changed to fatal error */
; 747  :         //EmitErr( CANNOT_OPEN_FILE, name, ErrnoStr() );
; 748  :         Fatal( CANNOT_OPEN_FILE, name, ErrnoStr() );

	call	ErrnoStr
	mov	r8, rax
	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 106				; 0000006aH
	call	Fatal

; 749  :         return( NULL );

	xor	eax, eax
	jmp	$LN1@ReadParamF
$LN4@ReadParamF:

; 750  :     }
; 751  :     len = 0;

	mov	DWORD PTR len$[rsp], 0

; 752  :     if ( fseek( file, 0, SEEK_END ) == 0 ) {

	mov	r8d, 2
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rsp]
	call	fseek
	test	eax, eax
	jne	SHORT $LN5@ReadParamF

; 753  :         len = ftell( file );

	mov	rcx, QWORD PTR file$[rsp]
	call	ftell
	mov	DWORD PTR len$[rsp], eax

; 754  :         rewind( file );

	mov	rcx, QWORD PTR file$[rsp]
	call	rewind

; 755  :         env = MemAlloc( len + 1 );

	mov	eax, DWORD PTR len$[rsp]
	inc	eax
	cdqe
	mov	rcx, rax
	call	MemAlloc
	mov	QWORD PTR env$[rsp], rax

; 756  : #if defined(__GNUC__) /* gcc warns if return value of fread() is "ignored" */
; 757  :         if ( fread( env, 1, len, file ) );
; 758  : #else
; 759  :         fread( env, 1, len, file );

	movsxd	rax, DWORD PTR len$[rsp]
	mov	r9, QWORD PTR file$[rsp]
	mov	r8, rax
	mov	edx, 1
	mov	rcx, QWORD PTR env$[rsp]
	call	fread

; 760  : #endif
; 761  :         env[len] = NULLC;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR env$[rsp]
	mov	BYTE PTR [rcx+rax], 0
$LN5@ReadParamF:

; 762  :     }
; 763  :     fclose( file );

	mov	rcx, QWORD PTR file$[rsp]
	call	fclose

; 764  :     if ( len == 0)

	cmp	DWORD PTR len$[rsp], 0
	jne	SHORT $LN6@ReadParamF

; 765  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@ReadParamF
$LN6@ReadParamF:

; 766  :     /* zip through characters changing \r, \n etc into ' ' */
; 767  :     str = env;

	mov	rax, QWORD PTR env$[rsp]
	mov	QWORD PTR str$[rsp], rax
$LN2@ReadParamF:

; 768  :     while( *str ) {

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@ReadParamF

; 769  :         ch = *str;

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR ch$[rsp], al

; 770  :         if( ch == '\r' || ch == '\n' ) {

	movsx	eax, BYTE PTR ch$[rsp]
	cmp	eax, 13
	je	SHORT $LN8@ReadParamF
	movsx	eax, BYTE PTR ch$[rsp]
	cmp	eax, 10
	jne	SHORT $LN7@ReadParamF
$LN8@ReadParamF:

; 771  :             *str = ' ';

	mov	rax, QWORD PTR str$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
$LN7@ReadParamF:

; 772  :         }
; 773  : #if HANDLECTRLZ
; 774  :         if( ch == 0x1A ) {      /* if end of file */

	movsx	eax, BYTE PTR ch$[rsp]
	cmp	eax, 26
	jne	SHORT $LN9@ReadParamF

; 775  :             *str = '\0';        /* - mark end of str */

	mov	rax, QWORD PTR str$[rsp]
	mov	BYTE PTR [rax], 0

; 776  :             break;

	jmp	SHORT $LN3@ReadParamF
$LN9@ReadParamF:

; 777  :         }
; 778  : #endif
; 779  :         ++str;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 780  :     }

	jmp	SHORT $LN2@ReadParamF
$LN3@ReadParamF:

; 781  :     return( env );

	mov	rax, QWORD PTR env$[rsp]
$LN1@ReadParamF:

; 782  : }

	add	rsp, 72					; 00000048H
	ret	0
ReadParamFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
equatefound$ = 48
dst$ = 80
str$ = 88
max$ = 96
type$ = 104
GetNameToken PROC

; 680  : {

	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 681  :     bool equatefound = FALSE;

	mov	BYTE PTR equatefound$[rsp], 0

; 682  : 
; 683  :     DebugMsg(("GetNameToken( %s, %u, '%c' ) enter, rspidx=%u\n", str, max, type, rspidx ));

	movsx	eax, BYTE PTR type$[rsp]
	mov	ecx, DWORD PTR rspidx
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, eax
	mov	r8d, DWORD PTR max$[rsp]
	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, OFFSET FLAT:$SG11508
	call	DoDebugMsg
$is_quote$22:

; 684  :     //while( isspace( *str ) ) ++str;  /* no spaces allowed! */
; 685  : is_quote:
; 686  :     if( *str == '"' ) {

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 34					; 00000022H
	jne	$LN8@GetNameTok

; 687  :         ++str;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 688  :         for( ; max && *str; max-- ) {

	jmp	SHORT $LN4@GetNameTok
$LN2@GetNameTok:
	mov	eax, DWORD PTR max$[rsp]
	dec	eax
	mov	DWORD PTR max$[rsp], eax
$LN4@GetNameTok:
	cmp	DWORD PTR max$[rsp], 0
	je	SHORT $LN3@GetNameTok
	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@GetNameTok

; 689  :             if ( *str == '"' ) {

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN10@GetNameTok

; 690  :                 ++str;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 691  :                 break;

	jmp	SHORT $LN3@GetNameTok
$LN10@GetNameTok:

; 692  :             }
; 693  :             /* handle the \" case */
; 694  :             if ( *str == '\\' && *(str+1) == '"' ) {

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN11@GetNameTok
	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN11@GetNameTok

; 695  :                 ++str;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax
$LN11@GetNameTok:

; 696  :             }
; 697  :             *dst++ = *str++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 698  :         }

	jmp	$LN2@GetNameTok
$LN3@GetNameTok:

; 699  :     } else {

	jmp	$LN9@GetNameTok
$LN8@GetNameTok:

; 700  :         for( ; max; max-- ) {

	jmp	SHORT $LN7@GetNameTok
$LN5@GetNameTok:
	mov	eax, DWORD PTR max$[rsp]
	dec	eax
	mov	DWORD PTR max$[rsp], eax
$LN7@GetNameTok:
	cmp	DWORD PTR max$[rsp], 0
	je	$LN6@GetNameTok

; 701  :             /* v2.10: don't stop for white spaces */
; 702  :             //if ( *str == NULLC || *str == ' ' || *str == '\t' )
; 703  :             if ( *str == NULLC )

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN12@GetNameTok

; 704  :                 break;

	jmp	$LN6@GetNameTok
$LN12@GetNameTok:

; 705  :             /* v2.10: don't stop for white spaces if filename is expected and true cmdline is parsed */
; 706  :             if ( ( *str == ' ' || *str == '\t' ) && ( rspidx || type != '@' ) )

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN14@GetNameTok
	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 9
	jne	SHORT $LN13@GetNameTok
$LN14@GetNameTok:
	cmp	DWORD PTR rspidx, 0
	jne	SHORT $LN15@GetNameTok
	movsx	eax, BYTE PTR type$[rsp]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN13@GetNameTok
$LN15@GetNameTok:

; 707  :                 break;

	jmp	$LN6@GetNameTok
$LN13@GetNameTok:

; 708  :             if ( type == 0 )

	movsx	eax, BYTE PTR type$[rsp]
	test	eax, eax
	jne	SHORT $LN16@GetNameTok

; 709  :                 if ( *str == '-'
; 710  : #if SWITCHCHAR
; 711  :                     || *str == '/'

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN18@GetNameTok
	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN17@GetNameTok
$LN18@GetNameTok:

; 712  : #endif
; 713  :                    )
; 714  :                     break;

	jmp	$LN6@GetNameTok
$LN17@GetNameTok:
$LN16@GetNameTok:

; 715  :             if ( *str == '=' && type == '$' && equatefound == FALSE ) {

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 61					; 0000003dH
	jne	SHORT $LN19@GetNameTok
	movsx	eax, BYTE PTR type$[rsp]
	cmp	eax, 36					; 00000024H
	jne	SHORT $LN19@GetNameTok
	movzx	eax, BYTE PTR equatefound$[rsp]
	test	eax, eax
	jne	SHORT $LN19@GetNameTok

; 716  :                 equatefound = TRUE;

	mov	BYTE PTR equatefound$[rsp], 1

; 717  :                 *dst++ = *str++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 718  :                 if (*str == '"')

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN20@GetNameTok

; 719  :                     goto is_quote;

	jmp	$is_quote$22
$LN20@GetNameTok:
$LN19@GetNameTok:

; 720  :             }
; 721  :             *dst++ = *str++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 722  :         }

	jmp	$LN5@GetNameTok
$LN6@GetNameTok:
$LN9@GetNameTok:

; 723  :     }
; 724  :     *dst = NULLC;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 0

; 725  :     return( str );

	mov	rax, QWORD PTR str$[rsp]

; 726  : }

	add	rsp, 72					; 00000048H
	ret	0
GetNameToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_nbp	PROC

; 495  : {

	sub	rsp, 40					; 00000028H

; 496  :     Options.nobackpatch = TRUE;

	mov	BYTE PTR Options+16, 1

; 497  :     DebugMsg(( "backpatching disabled\n" ));

	lea	rcx, OFFSET FLAT:$SG11334
	call	DoDebugMsg

; 498  : }

	add	rsp, 40					; 00000028H
	ret	0
Set_nbp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_nfp	PROC

; 488  : {

	sub	rsp, 40					; 00000028H

; 489  :     Options.nofastpass = TRUE;

	mov	BYTE PTR Options+17, 1

; 490  :     DebugMsg(( "FASTPASS disabled\n" ));

	lea	rcx, OFFSET FLAT:$SG11330
	call	DoDebugMsg

; 491  : }

	add	rsp, 40					; 00000028H
	ret	0
Set_nfp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_dt	PROC

; 480  : {

	sub	rsp, 40					; 00000028H

; 481  :     Options.debug = TRUE;

	mov	BYTE PTR Options+15, 1

; 482  :     ModuleInfo.cref = TRUE; /* enable debug displays */

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 12
	mov	DWORD PTR ModuleInfo+408, eax

; 483  :     DebugMsg(( "debugging output on\n" ));

	lea	rcx, OFFSET FLAT:$SG11326
	call	DoDebugMsg

; 484  : }

	add	rsp, 40					; 00000028H
	ret	0
Set_dt	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
i$ = 32
Set_dm	PROC

; 472  : {

	sub	rsp, 56					; 00000038H

; 473  :     int i;
; 474  :     for ( i = 0; i < MSG_LAST; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@Set_dm
$LN2@Set_dm:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@Set_dm:
	cmp	DWORD PTR i$[rsp], 279			; 00000117H
	jge	SHORT $LN3@Set_dm

; 475  :         printf("%3u: %s\n", i, MsgGetEx(i) );

	mov	ecx, DWORD PTR i$[rsp]
	call	MsgGetEx
	mov	r8, rax
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11322
	call	printf

; 476  :     }

	jmp	SHORT $LN2@Set_dm
$LN3@Set_dm:

; 477  : }

	add	rsp, 56					; 00000038H
	ret	0
Set_dm	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_h	PROC

; 467  : static void OPTQUAL Set_h( void ) {  PrintUsage();  exit(1); }

	sub	rsp, 40					; 00000028H
	call	PrintUsage
	mov	ecx, 1
	call	exit
$LN2@Set_h:
	add	rsp, 40					; 00000028H
	ret	0
Set_h	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_zt	PROC

; 465  : static void OPTQUAL Set_zt( void ) { Options.stdcall_decoration = OptValue; }

	movzx	eax, BYTE PTR OptValue
	mov	BYTE PTR Options+134, al
	ret	0
Set_zt	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_zf	PROC

; 462  : static void OPTQUAL Set_zf( void )  { Options.fctype = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+184, eax
	ret	0
Set_zf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_zcm	PROC

; 460  : static void OPTQUAL Set_zcm( void ) { Options.no_cdecl_decoration = FALSE; }

	mov	BYTE PTR Options+133, 0
	ret	0
Set_zcm	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_ofmt PROC

; 456  :     Options.output_format = OptValue & 0xff;

	mov	eax, DWORD PTR OptValue
	and	eax, 255				; 000000ffH
	mov	DWORD PTR Options+160, eax

; 457  :     Options.sub_format = OptValue >> 8;

	mov	eax, DWORD PTR OptValue
	shr	eax, 8
	mov	DWORD PTR Options+164, eax

; 458  : }

	ret	0
Set_ofmt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_W	PROC

; 446  : {

	sub	rsp, 40					; 00000028H

; 447  :     if ( OptValue <= 4 )

	cmp	DWORD PTR OptValue, 4
	ja	SHORT $LN2@Set_W

; 448  :         Options.warning_level = OptValue;

	movzx	eax, BYTE PTR OptValue
	mov	BYTE PTR Options+13, al
	jmp	SHORT $LN3@Set_W
$LN2@Set_W:

; 449  :     else
; 450  :         EmitWarn( 1, INVALID_CMDLINE_VALUE, "W" );

	lea	r8, OFFSET FLAT:$SG11299
	mov	edx, 195				; 000000c3H
	mov	ecx, 1
	call	EmitWarn
$LN3@Set_W:

; 451  : }

	add	rsp, 40					; 00000028H
	ret	0
Set_W	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_w	PROC

; 442  : static void OPTQUAL Set_w( void ) { Set_WX(); Options.warning_level = 0; }

	sub	rsp, 40					; 00000028H
	call	Set_WX
	mov	BYTE PTR Options+13, 0
	add	rsp, 40					; 00000028H
	ret	0
Set_w	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_WX	PROC

; 440  : static void OPTQUAL Set_WX( void ) { Options.warning_error = TRUE; }

	mov	BYTE PTR Options+14, 1
	ret	0
Set_WX	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_pm	PROC

; 437  : static void OPTQUAL Set_pm( void ) { Options.max_passes = OptValue; };

	movzx	eax, WORD PTR OptValue
	mov	WORD PTR Options+20, ax
	ret	0
Set_pm	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_n	PROC

; 434  : static void OPTQUAL Set_n( void ) { set_option_n_name( OptValue, OptName ); }

	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR OptName
	mov	ecx, DWORD PTR OptValue
	call	set_option_n_name
	add	rsp, 40					; 00000028H
	ret	0
Set_n	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_m	PROC

; 433  : static void OPTQUAL Set_m( void ) { Options.model = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+176, eax
	ret	0
Set_m	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
p$ = 0
Set_True PROC

; 428  : {

	sub	rsp, 24

; 429  :     char *p = ((char *)&Options) + OptValue;

	mov	eax, DWORD PTR OptValue
	lea	rcx, OFFSET FLAT:Options
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 430  :     *p = TRUE;

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 1

; 431  : }

	add	rsp, 24
	ret	0
Set_True ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Sa	PROC

; 421  :     Options.listif = TRUE;

	mov	BYTE PTR Options+146, 1

; 422  :     Options.list_generated_code = TRUE;

	mov	BYTE PTR Options+147, 1

; 423  :     Options.list_macro = LM_LISTMACROALL;

	mov	DWORD PTR Options+148, 2

; 424  : }

	ret	0
Set_Sa	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_G	PROC

; 416  : static void OPTQUAL Set_G( void ) { Options.langtype = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+172, eax
	ret	0
Set_G	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_FPx	PROC

; 415  : static void OPTQUAL Set_FPx( void ) { Options.floating_point = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+4, eax
	ret	0
Set_FPx	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_fp	PROC

; 414  : static void OPTQUAL Set_fp( void ) { Options.cpu &= ~P_FPU_MASK; Options.cpu = OptValue; }

	mov	eax, DWORD PTR Options+180
	and	eax, -8
	mov	DWORD PTR Options+180, eax
	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+180, eax
	ret	0
Set_fp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Fo	PROC

; 412  : static void OPTQUAL Set_Fo( void ) { get_fname( OPTN_OBJ_FN, GetAFileName() ); }

	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR OptName
	mov	ecx, 1
	call	get_fname
	add	rsp, 40					; 00000028H
	ret	0
Set_Fo	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Fl	PROC

; 411  : static void OPTQUAL Set_Fl( void ) { get_fname( OPTN_LST_FN, GetAFileName() ); Options.write_listing = TRUE;}

	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR OptName
	mov	ecx, 2
	call	get_fname
	mov	BYTE PTR Options+137, 1
	add	rsp, 40					; 00000028H
	ret	0
Set_Fl	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Fw	PROC

; 410  : static void OPTQUAL Set_Fw( void ) { get_fname( OPTN_ERR_FN, GetAFileName() ); }

	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR OptName
	mov	ecx, 3
	call	get_fname
	add	rsp, 40					; 00000028H
	ret	0
Set_Fw	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Fd	PROC

; 408  : static void OPTQUAL Set_Fd( void ) { get_fname( OPTN_LNKDEF_FN, GetAFileName() ); Options.write_impdef = TRUE;}

	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR OptName
	mov	ecx, 4
	call	get_fname
	mov	BYTE PTR Options+138, 1
	add	rsp, 40					; 00000028H
	ret	0
Set_Fd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_EP	PROC

; 405  : static void OPTQUAL Set_EP( void ) { Options.preprocessor_stdout = TRUE; Set_q(); }

	sub	rsp, 40					; 00000028H
	mov	BYTE PTR Options+141, 1
	call	Set_q
	add	rsp, 40					; 00000028H
	ret	0
Set_EP	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_q	PROC

; 404  : static void OPTQUAL Set_q( void )      { Set_nologo(); Options.quiet = TRUE; }

	sub	rsp, 40					; 00000028H
	call	Set_nologo
	mov	BYTE PTR Options, 1
	add	rsp, 40					; 00000028H
	ret	0
Set_q	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_nologo PROC

; 403  : static void OPTQUAL Set_nologo( void ) { banner_printed = TRUE; }

	mov	BYTE PTR banner_printed, 1
	ret	0
Set_nologo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_e	PROC

; 401  : static void OPTQUAL Set_e( void ) { Options.error_limit = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+8, eax
	ret	0
Set_e	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_I	PROC

; 399  : static void OPTQUAL Set_I( void )  { queue_item( OPTQ_INCPATH,  GetAFileName() ); }

	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR OptName
	mov	ecx, 2
	call	queue_item
	add	rsp, 40					; 00000028H
	ret	0
Set_I	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Fi	PROC

; 398  : static void OPTQUAL Set_Fi( void ) { queue_item( OPTQ_FINCLUDE, GetAFileName() ); }

	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR OptName
	xor	ecx, ecx
	call	queue_item
	add	rsp, 40					; 00000028H
	ret	0
Set_Fi	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_D	PROC

; 397  : static void OPTQUAL Set_D( void )  { queue_item( OPTQ_MACRO,    GetAFileName() ); }

	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR OptName
	mov	ecx, 1
	call	queue_item
	add	rsp, 40					; 00000028H
	ret	0
Set_D	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
power$ = 32
tv79 = 36
tv82 = 40
Set_Zp	PROC

; 386  : {

	sub	rsp, 56					; 00000038H

; 387  :     uint_8 power;
; 388  :     for ( power = 0; (1 << power) <= MAX_STRUCT_ALIGN; power++ )

	mov	BYTE PTR power$[rsp], 0
	jmp	SHORT $LN4@Set_Zp
$LN2@Set_Zp:
	movzx	eax, BYTE PTR power$[rsp]
	inc	al
	mov	BYTE PTR power$[rsp], al
$LN4@Set_Zp:
	movzx	eax, BYTE PTR power$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv79[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv79[rsp]
	shl	eax, cl
	cmp	eax, 32					; 00000020H
	jg	SHORT $LN3@Set_Zp

; 389  :         if ( ( 1 << power ) == OptValue ) {

	movzx	eax, BYTE PTR power$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv82[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv82[rsp]
	shl	eax, cl
	cmp	eax, DWORD PTR OptValue
	jne	SHORT $LN5@Set_Zp

; 390  :             Options.fieldalign = power;

	movzx	eax, BYTE PTR power$[rsp]
	mov	BYTE PTR Options+168, al

; 391  :             return;

	jmp	SHORT $LN1@Set_Zp
$LN5@Set_Zp:

; 392  :         }

	jmp	SHORT $LN2@Set_Zp
$LN3@Set_Zp:

; 393  :     EmitWarn( 1, INVALID_CMDLINE_VALUE, "Zp" );

	lea	r8, OFFSET FLAT:$SG11228
	mov	edx, 195				; 000000c3H
	mov	ecx, 1
	call	EmitWarn
$LN1@Set_Zp:

; 394  :     return;
; 395  : }

	add	rsp, 56					; 00000038H
	ret	0
Set_Zp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Zi	PROC

; 374  : {

	sub	rsp, 40					; 00000028H

; 375  :     Set_Zd();

	call	Set_Zd

; 376  :     Options.debug_symbols = CV_SIGNATURE;

	mov	BYTE PTR Options+2, 1

; 377  :     /* v2.10: added optional numeric argument for -Zi */
; 378  :     if ( OptValue <= CVEX_MAX )

	cmp	DWORD PTR OptValue, 3
	ja	SHORT $LN2@Set_Zi

; 379  :         Options.debug_ext = OptValue;

	movzx	eax, BYTE PTR OptValue
	mov	BYTE PTR Options+3, al
	jmp	SHORT $LN3@Set_Zi
$LN2@Set_Zi:

; 380  :     else
; 381  :         EmitWarn( 1, INVALID_CMDLINE_VALUE, "Zi" );

	lea	r8, OFFSET FLAT:$SG11219
	mov	edx, 195				; 000000c3H
	mov	ecx, 1
	call	EmitWarn
$LN3@Set_Zi:

; 382  : }

	add	rsp, 40					; 00000028H
	ret	0
Set_Zi	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Zd	PROC

; 372  : static void OPTQUAL Set_Zd( void ) { Options.line_numbers = TRUE; }

	mov	BYTE PTR Options+1, 1
	ret	0
Set_Zd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Cx	PROC

; 370  : static void OPTQUAL Set_Cx( void ) { Options.case_sensitive = FALSE;  Options.convert_uppercase = FALSE; }

	mov	BYTE PTR Options+139, 0
	mov	BYTE PTR Options+140, 0
	ret	0
Set_Cx	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Cu	PROC

; 369  : static void OPTQUAL Set_Cu( void ) { Options.case_sensitive = FALSE;  Options.convert_uppercase = TRUE;  }

	mov	BYTE PTR Options+139, 0
	mov	BYTE PTR Options+140, 1
	ret	0
Set_Cu	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Cp	PROC

; 368  : static void OPTQUAL Set_Cp( void ) { Options.case_sensitive = TRUE;   Options.convert_uppercase = FALSE; }

	mov	BYTE PTR Options+139, 1
	mov	BYTE PTR Options+140, 0
	ret	0
Set_Cp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_ce	PROC

; 365  : static void OPTQUAL Set_ce( void ) { rspidx = 1 / rspidx; }

	mov	eax, 1
	cdq
	idiv	DWORD PTR rspidx
	mov	DWORD PTR rspidx, eax
	ret	0
Set_ce	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_c	PROC

; 362  : static void OPTQUAL Set_c( void ) { }

	ret	0
Set_c	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
idx$ = 48
name$ = 56
set_option_n_name PROC

; 343  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 344  :     if ( *name != '.' && !is_valid_id_char( *name ) ) {

	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN2@set_option
	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isalnum
	test	eax, eax
	jne	SHORT $LN2@set_option
	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN2@set_option
	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN2@set_option
	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN2@set_option
	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN2@set_option

; 345  :         EmitError( N_OPTION_NEEDS_A_NAME_PARAMETER );

	mov	ecx, 234				; 000000eaH
	call	EmitError

; 346  :         return;

	jmp	SHORT $LN1@set_option
$LN2@set_option:

; 347  :     }
; 348  : 
; 349  :     if( Options.names[idx] != NULL ) {

	movsxd	rax, DWORD PTR idx$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN3@set_option

; 350  :         MemFree( Options.names[idx] );

	movsxd	rax, DWORD PTR idx$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	MemFree
$LN3@set_option:

; 351  :     }
; 352  :     Options.names[idx] = MemAlloc( strlen( name ) + 1 );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	inc	rax
	mov	rcx, rax
	call	MemAlloc
	movsxd	rcx, DWORD PTR idx$[rsp]
	lea	rdx, OFFSET FLAT:Options+32
	mov	QWORD PTR [rdx+rcx*8], rax

; 353  :     strcpy( Options.names[idx], name );

	movsxd	rax, DWORD PTR idx$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	strcpy
$LN1@set_option:

; 354  : }

	add	rsp, 40					; 00000028H
	ret	0
set_option_n_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
$T1 = 32
pName$ = 40
name$ = 48
__$ArrayPad$ = 320
type$ = 352
token$ = 360
get_fname PROC

; 287  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 344				; 00000158H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 288  :     const char  *pName;
; 289  :     char        name [ FILENAME_MAX ];
; 290  : 
; 291  :     DebugMsg(("get_fname( type=%u, >%s< ) enter\n", type, token ));

	mov	r8, QWORD PTR token$[rsp]
	mov	edx, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:$SG11179
	call	DoDebugMsg

; 292  :     //_splitpath( token, drive, dir, fname, ext );
; 293  :     pName = GetFNamePart( token );

	mov	rcx, QWORD PTR token$[rsp]
	call	GetFNamePart
	mov	QWORD PTR pName$[rsp], rax

; 294  :     /*
; 295  :      * If name's ending with a '\' (or '/' in Unix), it's supposed
; 296  :      * to be a directory name only.
; 297  :      */
; 298  :     if( *pName == NULLC ) {

	mov	rax, QWORD PTR pName$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	$LN2@get_fname

; 299  :         DebugMsg(("get_fname(%u, >%s< ) name is empty or a directory\n", type, token ));

	mov	r8, QWORD PTR token$[rsp]
	mov	edx, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:$SG11181
	call	DoDebugMsg

; 300  :         /* v2.10: ensure type is < NUM_FILE_TYPES */
; 301  :         if ( type < NUM_FILE_TYPES ) {

	cmp	DWORD PTR type$[rsp], 4
	jge	SHORT $LN3@get_fname

; 302  :             if ( DefaultDir[type] )

	movsxd	rax, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN4@get_fname

; 303  :                 MemFree( DefaultDir[type]);

	movsxd	rax, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	MemFree
$LN4@get_fname:

; 304  :             DefaultDir[type] = MemAlloc( strlen( token ) + 1 );

	mov	rcx, QWORD PTR token$[rsp]
	call	strlen
	inc	rax
	mov	rcx, rax
	call	MemAlloc
	movsxd	rcx, DWORD PTR type$[rsp]
	lea	rdx, OFFSET FLAT:DefaultDir
	mov	QWORD PTR [rdx+rcx*8], rax

; 305  :             strcpy( DefaultDir[type], token );

	movsxd	rax, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	mov	rdx, QWORD PTR token$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	strcpy
$LN3@get_fname:

; 306  :         }
; 307  :         return;

	jmp	$LN1@get_fname
$LN2@get_fname:

; 308  :     }
; 309  :     /* v2.10: ensure type is < NUM_FILE_TYPES */
; 310  :     //if ( drive[0] == NULLC && dir[0] == NULLC && type < NUM_FILE_TYPES && DefaultDir[type] ) {
; 311  :     name[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 260			; 00000104H
	jae	SHORT $LN8@get_fname
	jmp	SHORT $LN9@get_fname
$LN8@get_fname:
	call	__report_rangecheckfailure
$LN9@get_fname:
	mov	rax, QWORD PTR $T1[rsp]
	mov	BYTE PTR name$[rsp+rax], 0

; 312  :     if ( pName == token && type < NUM_FILE_TYPES && DefaultDir[type] ) {

	mov	rax, QWORD PTR token$[rsp]
	cmp	QWORD PTR pName$[rsp], rax
	jne	SHORT $LN5@get_fname
	cmp	DWORD PTR type$[rsp], 4
	jge	SHORT $LN5@get_fname
	movsxd	rax, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN5@get_fname

; 313  :         DebugMsg(("get_fname: default drive+dir used: %s\n" ));

	lea	rcx, OFFSET FLAT:$SG11185
	call	DoDebugMsg

; 314  :         //_splitpath( DefaultDir[type], drive, dir, NULL, NULL );
; 315  :         strcpy( name, DefaultDir[type] );

	movsxd	rax, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR name$[rsp]
	call	strcpy
$LN5@get_fname:

; 316  :     }
; 317  :     strcat( name, token );

	mov	rdx, QWORD PTR token$[rsp]
	lea	rcx, QWORD PTR name$[rsp]
	call	strcat

; 318  : #if 0 /* v2.12: extension will be set in SetFileNames() */
; 319  :     if( type && type < NUM_FILE_TYPES ) {
; 320  :         char *pExt = GetExtPart( name );
; 321  :         if ( *pExt == NULLC ) {
; 322  :             *pExt++ = '.';
; 323  :             strcpy( pExt, DefaultExt[type-1] );
; 324  :         }
; 325  :     }
; 326  : #endif
; 327  :     //_makepath( name, drive, dir, fname, pExt );
; 328  :     if( Options.names[type] != NULL ) {

	movsxd	rax, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN6@get_fname

; 329  :         MemFree( Options.names[type] );

	movsxd	rax, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	MemFree
$LN6@get_fname:

; 330  :     }
; 331  :     Options.names[type] = MemAlloc( strlen( name ) + 1 );

	lea	rcx, QWORD PTR name$[rsp]
	call	strlen
	inc	rax
	mov	rcx, rax
	call	MemAlloc
	movsxd	rcx, DWORD PTR type$[rsp]
	lea	rdx, OFFSET FLAT:Options+32
	mov	QWORD PTR [rdx+rcx*8], rax

; 332  :     strcpy( Options.names[type], name );

	movsxd	rax, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	lea	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	strcpy
$LN1@get_fname:
$LN7@get_fname:

; 333  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 344				; 00000158H
	ret	0
get_fname ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
q$ = 32
p$ = 40
i$ = 64
string$ = 72
queue_item PROC

; 263  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 264  :     struct qitem *p;
; 265  :     struct qitem *q;
; 266  : 
; 267  :     DebugMsg(("queue_item(%u, %s) enter\n", i, string));

	mov	r8, QWORD PTR string$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11166
	call	DoDebugMsg

; 268  :     p = MemAlloc( sizeof(struct qitem) + strlen( string ) );

	mov	rcx, QWORD PTR string$[rsp]
	call	strlen
	add	rax, 16
	mov	rcx, rax
	call	MemAlloc
	mov	QWORD PTR p$[rsp], rax

; 269  :     p->next = NULL;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], 0

; 270  :     strcpy( p->value, string );

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 8
	mov	rdx, QWORD PTR string$[rsp]
	mov	rcx, rax
	call	strcpy

; 271  :     q = Options.queues[i];

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+104
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR q$[rsp], rax

; 272  :     if ( q ) {

	cmp	QWORD PTR q$[rsp], 0
	je	SHORT $LN5@queue_item
	jmp	SHORT $LN4@queue_item
$LN2@queue_item:

; 273  :         for ( ; q->next; q = q->next );

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$[rsp], rax
$LN4@queue_item:
	mov	rax, QWORD PTR q$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@queue_item
	jmp	SHORT $LN2@queue_item
$LN3@queue_item:

; 274  :         q->next = p;

	mov	rax, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 275  :     } else

	jmp	SHORT $LN6@queue_item
$LN5@queue_item:

; 276  :         Options.queues[i] = p;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+104
	mov	rdx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx
$LN6@queue_item:

; 277  :     return;
; 278  : }

	add	rsp, 56					; 00000038H
	ret	0
queue_item ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
value$ = 48
parm$ = 56
SetCpuCmdline PROC

; 227  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 228  : 
; 229  :     Options.cpu &= ~(P_CPU_MASK | P_EXT_MASK | P_PM);

	mov	eax, DWORD PTR Options+180
	and	eax, -65529				; ffffffffffff0007H
	mov	DWORD PTR Options+180, eax

; 230  :     Options.cpu |= value;

	mov	eax, DWORD PTR value$[rsp]
	mov	ecx, DWORD PTR Options+180
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR Options+180, eax

; 231  : 
; 232  :     for( ; *parm ; parm++ ) {

	jmp	SHORT $LN4@SetCpuCmdl
$LN2@SetCpuCmdl:
	mov	rax, QWORD PTR parm$[rsp]
	inc	rax
	mov	QWORD PTR parm$[rsp], rax
$LN4@SetCpuCmdl:
	mov	rax, QWORD PTR parm$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@SetCpuCmdl

; 233  :         if( *parm == 'p' && Options.cpu >= P_286 ) {

	mov	rax, QWORD PTR parm$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 112				; 00000070H
	jne	SHORT $LN5@SetCpuCmdl
	cmp	DWORD PTR Options+180, 32		; 00000020H
	jl	SHORT $LN5@SetCpuCmdl

; 234  :             Options.cpu |= P_PM;      /* set privileged mode */

	mov	eax, DWORD PTR Options+180
	or	eax, 8
	mov	DWORD PTR Options+180, eax

; 235  : #if MANGLERSUPP
; 236  :         } else if( *parm == '"' ) {       /* set default mangler */
; 237  :             char *dest;
; 238  :             parm++;
; 239  :             dest = strchr( parm, '"' );
; 240  :             if( Options.names[OPTN_DEFNAME_MANGLER] != NULL ) {
; 241  :                 MemFree( Options.names[OPTN_DEFNAME_MANGLER );
; 242  :             }
; 243  :             Options.names[OPTN_DEFNAME_MANGLER = MemAlloc( dest - parm + 1 );
; 244  :             dest = Options.names[OPTN_DEFNAME_MANGLER];
; 245  :             for( ; *parm != '"'; dest++, parm++ ) {
; 246  :                 *dest = *parm;
; 247  :             }
; 248  :             *dest = NULLC;
; 249  : #endif
; 250  :         } else {

	jmp	SHORT $LN6@SetCpuCmdl
$LN5@SetCpuCmdl:

; 251  :             EmitWarn( 1, CPU_OPTION_INVALID, parm );

	mov	r8, QWORD PTR parm$[rsp]
	mov	edx, 134				; 00000086H
	mov	ecx, 1
	call	EmitWarn

; 252  :             break;

	jmp	SHORT $LN3@SetCpuCmdl
$LN6@SetCpuCmdl:

; 253  :         }
; 254  :     }

	jmp	SHORT $LN2@SetCpuCmdl
$LN3@SetCpuCmdl:

; 255  : }

	add	rsp, 40					; 00000028H
	ret	0
SetCpuCmdline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
i$ = 32
q$1 = 40
p$2 = 48
CmdlineFini PROC

; 1064 : {

$LN17:
	sub	rsp, 72					; 00000048H

; 1065 :     int i;
; 1066 :     DebugMsg(("CmdLineFini enter\n" ));

	lea	rcx, OFFSET FLAT:$SG11674
	call	DoDebugMsg

; 1067 :     for ( i = 0; i < NUM_FILE_TYPES; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@CmdlineFin
$LN2@CmdlineFin:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@CmdlineFin:
	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN3@CmdlineFin

; 1068 :         if ( DefaultDir[i] != NULL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN14@CmdlineFin

; 1069 :             MemFree( DefaultDir[i] );

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	MemFree

; 1070 :             DefaultDir[i] = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	mov	QWORD PTR [rcx+rax*8], 0
$LN14@CmdlineFin:

; 1071 :         }
; 1072 :     }

	jmp	SHORT $LN2@CmdlineFin
$LN3@CmdlineFin:

; 1073 :     for ( i = 0; i < OPTN_LAST; i++ )

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@CmdlineFin
$LN5@CmdlineFin:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@CmdlineFin:
	cmp	DWORD PTR i$[rsp], 9
	jge	SHORT $LN6@CmdlineFin

; 1074 :         if ( Options.names[i] != NULL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN15@CmdlineFin

; 1075 :             MemFree( Options.names[i] );

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	MemFree

; 1076 :             Options.names[i] = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	mov	QWORD PTR [rcx+rax*8], 0
$LN15@CmdlineFin:

; 1077 :         }

	jmp	SHORT $LN5@CmdlineFin
$LN6@CmdlineFin:

; 1078 :     for ( i = 0; i < OPTQ_LAST; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN10@CmdlineFin
$LN8@CmdlineFin:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@CmdlineFin:
	cmp	DWORD PTR i$[rsp], 3
	jge	SHORT $LN9@CmdlineFin

; 1079 :         struct qitem *p;
; 1080 :         struct qitem *q;
; 1081 :         for ( q = Options.queues[i]; q; ) {

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+104
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR q$1[rsp], rax
$LN11@CmdlineFin:
	cmp	QWORD PTR q$1[rsp], 0
	je	SHORT $LN12@CmdlineFin

; 1082 :             p = q->next;

	mov	rax, QWORD PTR q$1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$2[rsp], rax

; 1083 :             MemFree( q );

	mov	rcx, QWORD PTR q$1[rsp]
	call	MemFree

; 1084 :             q = p;

	mov	rax, QWORD PTR p$2[rsp]
	mov	QWORD PTR q$1[rsp], rax

; 1085 :         }

	jmp	SHORT $LN11@CmdlineFin
$LN12@CmdlineFin:

; 1086 :         Options.queues[i] = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+104
	mov	QWORD PTR [rcx+rax*8], 0

; 1087 :     }

	jmp	SHORT $LN8@CmdlineFin
$LN9@CmdlineFin:

; 1088 :     DebugMsg(("CmdLineFini exit\n" ));

	lea	rcx, OFFSET FLAT:$SG11677
	call	DoDebugMsg

; 1089 :     return;
; 1090 : }

	add	rsp, 72					; 00000048H
	ret	0
CmdlineFini ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
str$ = 32
i$ = 40
tv79 = 44
len$1 = 48
tv175 = 56
paramfile$ = 64
__$ArrayPad$ = 336
cmdline$ = 368
pCntArgs$ = 376
ParseCmdline PROC

; 967  : {

$LN29:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 360				; 00000168H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 968  :     int i;
; 969  :     const char *str = *cmdline;

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR str$[rsp], rax

; 970  :     char paramfile[FILENAME_MAX];
; 971  : 
; 972  :     for ( i = 0; i < NUM_FILE_TYPES; i++ )

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@ParseCmdli
$LN2@ParseCmdli:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@ParseCmdli:
	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN3@ParseCmdli

; 973  :         if ( Options.names[i] != NULL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN10@ParseCmdli

; 974  :             MemFree( Options.names[i] );

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	MemFree

; 975  :             Options.names[i] = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	mov	QWORD PTR [rcx+rax*8], 0
$LN10@ParseCmdli:

; 976  :         }

	jmp	SHORT $LN2@ParseCmdli
$LN3@ParseCmdli:
$LN5@ParseCmdli:

; 977  : 
; 978  :     /* enable next line if debug log is to be active, but -dt cannot be set */
; 979  :     //Set_dt();
; 980  : 
; 981  :     for( ; str; ) {

	cmp	QWORD PTR str$[rsp], 0
	je	$LN6@ParseCmdli

; 982  :         switch( *str ) {

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv79[rsp], eax
	cmp	DWORD PTR tv79[rsp], 64			; 00000040H
	ja	$LN21@ParseCmdli
	movsxd	rax, DWORD PTR tv79[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN27@ParseCmdli[rcx+rax]
	mov	eax, DWORD PTR $LN28@ParseCmdli[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN11@ParseCmdli:

; 983  :         case ' ':
; 984  :         case '\t':
; 985  :             str++;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 986  :             break;

	jmp	$LN8@ParseCmdli
$LN12@ParseCmdli:

; 987  :         case NULLC:
; 988  :             str = getnextcmdstring( cmdline );

	mov	rcx, QWORD PTR cmdline$[rsp]
	call	getnextcmdstring
	mov	QWORD PTR str$[rsp], rax

; 989  :             break;

	jmp	$LN8@ParseCmdli
$LN13@ParseCmdli:

; 990  :         case '-':
; 991  : #if SWITCHCHAR
; 992  :         case '/':
; 993  : #endif
; 994  :             str++;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 995  :             *cmdline = str;

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	mov	QWORD PTR [rax], rcx

; 996  :             ProcessOption( cmdline, paramfile );

	lea	rdx, QWORD PTR paramfile$[rsp]
	mov	rcx, QWORD PTR cmdline$[rsp]
	call	ProcessOption

; 997  :             (*pCntArgs)++;

	mov	rax, QWORD PTR pCntArgs$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR pCntArgs$[rsp]
	mov	DWORD PTR [rcx], eax

; 998  :             str = *cmdline;

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR str$[rsp], rax

; 999  :             break;

	jmp	$LN8@ParseCmdli
$LN14@ParseCmdli:

; 1000 :         case '@':
; 1001 :             if ( rspidx >= MAX_RSP_NESTING ) {

	cmp	DWORD PTR rspidx, 15
	jl	SHORT $LN15@ParseCmdli

; 1002 :                 EmitErr( NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 100				; 00000064H
	call	EmitErr

; 1003 :                 *cmdline = "";

	mov	rax, QWORD PTR cmdline$[rsp]
	lea	rcx, OFFSET FLAT:$SG11641
	mov	QWORD PTR [rax], rcx

; 1004 :                 return( NULL );

	xor	eax, eax
	jmp	$LN1@ParseCmdli
$LN15@ParseCmdli:

; 1005 :             }
; 1006 :             str++;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 1007 : #if 1 /* v2.06: was '0' in v2.05, now '1' again since it didn't work with quoted names */
; 1008 :             /* todo: might be unnecessary since v.2.10, since GetNameToken() handles spaces inside filenames differently */
; 1009 :             if ( rspidx ) {

	cmp	DWORD PTR rspidx, 0
	je	SHORT $LN16@ParseCmdli

; 1010 :                 cmdsave[rspidx] = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );

	mov	r9b, 64					; 00000040H
	mov	r8d, 259				; 00000103H
	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR paramfile$[rsp]
	call	GetNameToken
	movsxd	rcx, DWORD PTR rspidx
	lea	rdx, OFFSET FLAT:cmdsave
	mov	QWORD PTR [rdx+rcx*8], rax

; 1011 :             } else {

	jmp	SHORT $LN17@ParseCmdli
$LN16@ParseCmdli:

; 1012 :                 strcpy( paramfile, str ); /* fixme: no overflow check */

	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR paramfile$[rsp]
	call	strcpy

; 1013 :                 cmdsave[rspidx] = str + strlen(str);

	mov	rcx, QWORD PTR str$[rsp]
	call	strlen
	mov	rcx, QWORD PTR str$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR rspidx
	lea	rdx, OFFSET FLAT:cmdsave
	mov	QWORD PTR [rdx+rcx*8], rax
$LN17@ParseCmdli:

; 1014 :             }
; 1015 : #else
; 1016 :             cmdsave[rspidx] = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );
; 1017 : #endif
; 1018 :             cmdbuffers[rspidx] = NULL;

	movsxd	rax, DWORD PTR rspidx
	lea	rcx, OFFSET FLAT:cmdbuffers
	mov	QWORD PTR [rcx+rax*8], 0

; 1019 :             str = NULL;

	mov	QWORD PTR str$[rsp], 0

; 1020 :             if ( paramfile[0] )

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR paramfile$[rsp+rax]
	test	eax, eax
	je	SHORT $LN18@ParseCmdli

; 1021 :                 str = getenv( paramfile );

	lea	rcx, QWORD PTR paramfile$[rsp]
	call	getenv
	mov	QWORD PTR str$[rsp], rax
$LN18@ParseCmdli:

; 1022 :             if( str == NULL ) {

	cmp	QWORD PTR str$[rsp], 0
	jne	SHORT $LN19@ParseCmdli

; 1023 :                 str = ReadParamFile( paramfile );

	lea	rcx, QWORD PTR paramfile$[rsp]
	call	ReadParamFile
	mov	QWORD PTR str$[rsp], rax

; 1024 :                 cmdbuffers[rspidx] = str;

	movsxd	rax, DWORD PTR rspidx
	lea	rcx, OFFSET FLAT:cmdbuffers
	mov	rdx, QWORD PTR str$[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 1025 :                 if ( str == NULL ) {

	cmp	QWORD PTR str$[rsp], 0
	jne	SHORT $LN20@ParseCmdli

; 1026 :                     str = cmdsave[rspidx];

	movsxd	rax, DWORD PTR rspidx
	lea	rcx, OFFSET FLAT:cmdsave
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR str$[rsp], rax

; 1027 :                     break;

	jmp	$LN8@ParseCmdli
$LN20@ParseCmdli:
$LN19@ParseCmdli:

; 1028 :                 }
; 1029 :             }
; 1030 :             rspidx++;

	mov	eax, DWORD PTR rspidx
	inc	eax
	mov	DWORD PTR rspidx, eax

; 1031 :             break;

	jmp	$LN8@ParseCmdli
$LN21@ParseCmdli:

; 1032 :         default: /* collect  file name */
; 1033 : #if BUILD_TARGET
; 1034 :             set_default_build_target();
; 1035 : #endif
; 1036 : #if 1 /* v2.06: activated (was removed in v2.05). Needed for quoted filenames */
; 1037 :             if ( rspidx ) {

	cmp	DWORD PTR rspidx, 0
	je	SHORT $LN22@ParseCmdli

; 1038 :                 str = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );

	mov	r9b, 64					; 00000040H
	mov	r8d, 259				; 00000103H
	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR paramfile$[rsp]
	call	GetNameToken
	mov	QWORD PTR str$[rsp], rax

; 1039 :                 get_fname( OPTN_ASM_FN, paramfile );

	lea	rdx, QWORD PTR paramfile$[rsp]
	xor	ecx, ecx
	call	get_fname

; 1040 :             } else {

	jmp	SHORT $LN23@ParseCmdli
$LN22@ParseCmdli:

; 1041 :                 int len;
; 1042 :                 len = strlen( str );

	mov	rcx, QWORD PTR str$[rsp]
	call	strlen
	mov	DWORD PTR len$1[rsp], eax

; 1043 :                 get_fname( OPTN_ASM_FN, str );

	mov	rdx, QWORD PTR str$[rsp]
	xor	ecx, ecx
	call	get_fname

; 1044 :                 str += len;

	movsxd	rax, DWORD PTR len$1[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR str$[rsp], rax
$LN23@ParseCmdli:

; 1045 :             }
; 1046 : #else
; 1047 :             str = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );
; 1048 :             Options.names[ASM] = MemAlloc( strlen( paramfile ) + 1 );
; 1049 :             strcpy( Options.names[ASM], paramfile );
; 1050 : #endif
; 1051 :             DebugMsg(("ParseCmdLine: file=>%s< rest=>%s<\n", Options.names[ASM], str ? str : "NULL" ));

	cmp	QWORD PTR str$[rsp], 0
	je	SHORT $LN25@ParseCmdli
	mov	rax, QWORD PTR str$[rsp]
	mov	QWORD PTR tv175[rsp], rax
	jmp	SHORT $LN26@ParseCmdli
$LN25@ParseCmdli:
	lea	rax, OFFSET FLAT:$SG11650
	mov	QWORD PTR tv175[rsp], rax
$LN26@ParseCmdli:
	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:Options+32
	mov	r8, QWORD PTR tv175[rsp]
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG11651
	call	DoDebugMsg

; 1052 :             (*pCntArgs)++;

	mov	rax, QWORD PTR pCntArgs$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR pCntArgs$[rsp]
	mov	DWORD PTR [rcx], eax

; 1053 :             *cmdline = str;

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	mov	QWORD PTR [rax], rcx

; 1054 :             return( Options.names[ASM] );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:Options+32
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@ParseCmdli
$LN8@ParseCmdli:

; 1055 :         }
; 1056 :     }

	jmp	$LN5@ParseCmdli
$LN6@ParseCmdli:

; 1057 :     *cmdline = str;

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	mov	QWORD PTR [rax], rcx

; 1058 :     return( NULL );

	xor	eax, eax
$LN1@ParseCmdli:

; 1059 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 360				; 00000168H
	ret	0
	npad	2
$LN28@ParseCmdli:
	DD	$LN12@ParseCmdli
	DD	$LN11@ParseCmdli
	DD	$LN13@ParseCmdli
	DD	$LN14@ParseCmdli
	DD	$LN21@ParseCmdli
$LN27@ParseCmdli:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
ParseCmdline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 950  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 957  : }

	add	rsp, 56					; 00000038H
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 640  : }

	add	rsp, 56					; 00000038H
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
