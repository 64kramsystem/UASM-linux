; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	Options
PUBLIC	DefaultDir
_BSS	SEGMENT
$SG11563 DB	01H DUP (?)
	ALIGN	4

$SG11595 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	8

DefaultDir DQ	04H DUP (?)
rspidx	DD	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
cmdl_options DQ	FLAT:$SG11351
	DD	00H
	ORG $+4
	DQ	FLAT:Set_h
	DQ	FLAT:$SG11352
	DD	017H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11353
	DD	00H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11354
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Cp
	DQ	FLAT:$SG11355
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Cu
	DQ	FLAT:$SG11356
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Cx
	DQ	FLAT:$SG11357
	DD	00H
	ORG $+4
	DQ	FLAT:Set_ce
	DQ	FLAT:$SG11358
	DD	02H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11359
	DD	00H
	ORG $+4
	DQ	FLAT:Set_c
	DQ	FLAT:$SG11360
	DD	00H
	ORG $+4
	DQ	FLAT:Set_dm
	DQ	FLAT:$SG11361
	DD	019H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11362
	DD	018H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11363
	DD	01bH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11364
	DD	01aH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11365
	DD	00H
	ORG $+4
	DQ	FLAT:Set_dt
	DQ	FLAT:$SG11366
	DD	00H
	ORG $+4
	DQ	FLAT:Set_D
	DQ	FLAT:$SG11367
	DD	0303H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11368
	DD	03H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11369
	DD	00H
	ORG $+4
	DQ	FLAT:Set_EP
	DQ	FLAT:$SG11370
	DD	0cH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11371
	DD	00H
	ORG $+4
	DQ	FLAT:Set_e
	DQ	FLAT:$SG11372
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fd
	DQ	FLAT:$SG11373
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fi
	DQ	FLAT:$SG11374
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fl
	DQ	FLAT:$SG11375
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fo
	DQ	FLAT:$SG11376
	DD	00H
	ORG $+4
	DQ	FLAT:Set_FPx
	DQ	FLAT:$SG11377
	DD	01H
	ORG $+4
	DQ	FLAT:Set_FPx
	DQ	FLAT:$SG11378
	DD	02H
	ORG $+4
	DQ	FLAT:Set_fp
	DQ	FLAT:$SG11379
	DD	03H
	ORG $+4
	DQ	FLAT:Set_fp
	DQ	FLAT:$SG11380
	DD	04H
	ORG $+4
	DQ	FLAT:Set_fp
	DQ	FLAT:$SG11381
	DD	01H
	ORG $+4
	DQ	FLAT:Set_fp
	DQ	FLAT:$SG11382
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fw
	DQ	FLAT:$SG11383
	DD	04H
	ORG $+4
	DQ	FLAT:Set_G
	DQ	FLAT:$SG11384
	DD	01H
	ORG $+4
	DQ	FLAT:Set_G
	DQ	FLAT:$SG11385
	DD	07H
	ORG $+4
	DQ	FLAT:Set_G
	DQ	FLAT:$SG11386
	DD	03H
	ORG $+4
	DQ	FLAT:Set_G
	DQ	FLAT:$SG11387
	DD	00H
	ORG $+4
	DQ	FLAT:Set_h
	DQ	FLAT:$SG11388
	DD	00H
	ORG $+4
	DQ	FLAT:Set_I
	DQ	FLAT:$SG11389
	DD	012H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11390
	DD	03H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11391
	DD	07H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11392
	DD	06H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11393
	DD	05H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11394
	DD	04H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11395
	DD	02H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11396
	DD	01H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG11397
	DD	0100H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11398
	DD	00H
	ORG $+4
	DQ	FLAT:Set_nbp
	DQ	FLAT:$SG11399
	DD	08H
	ORG $+4
	DQ	FLAT:Set_n
	DQ	FLAT:$SG11400
	DD	07H
	ORG $+4
	DQ	FLAT:Set_n
	DQ	FLAT:$SG11401
	DD	00H
	ORG $+4
	DQ	FLAT:Set_nfp
	DQ	FLAT:$SG11402
	DD	05H
	ORG $+4
	DQ	FLAT:Set_n
	DQ	FLAT:$SG11403
	DD	00H
	ORG $+4
	DQ	FLAT:Set_nologo
	DQ	FLAT:$SG11404
	DD	06H
	ORG $+4
	DQ	FLAT:Set_n
	DQ	FLAT:$SG11405
	DD	01H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11406
	DD	0200H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11407
	DD	00H
	ORG $+4
	DQ	FLAT:Set_pm
	DQ	FLAT:$SG11408
	DD	00H
	ORG $+4
	DQ	FLAT:Set_q
	DQ	FLAT:$SG11409
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Sa
	DQ	FLAT:$SG11410
	DD	099H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11411
	DD	093H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11412
	DD	098H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11413
	DD	092H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11414
	DD	09bH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11415
	DD	016H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11416
	DD	00H
	ORG $+4
	DQ	FLAT:Set_WX
	DQ	FLAT:$SG11417
	DD	00H
	ORG $+4
	DQ	FLAT:Set_W
	DQ	FLAT:$SG11418
	DD	0302H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG11419
	DD	00H
	ORG $+4
	DQ	FLAT:Set_w
	DQ	FLAT:$SG11420
	DD	09cH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11421
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Zd
	DQ	FLAT:$SG11422
	DD	09aH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11423
	DD	090H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11424
	DD	02H
	ORG $+4
	DQ	FLAT:Set_Zi
	DQ	FLAT:$SG11425
	DD	08eH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11426
	DD	08fH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11427
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Zp
	DQ	FLAT:$SG11428
	DD	00H
	ORG $+4
	DQ	FLAT:Set_zcm
	DQ	FLAT:$SG11429
	DD	085H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11430
	DD	00H
	ORG $+4
	DQ	FLAT:Set_zf
	DQ	FLAT:$SG11431
	DD	01H
	ORG $+4
	DQ	FLAT:Set_zf
	DQ	FLAT:$SG11432
	DD	080H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11433
	DD	081H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11434
	DD	082H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11435
	DD	083H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11436
	DD	084H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11437
	DD	0bcH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11438
	DD	01H
	ORG $+4
	DQ	FLAT:Set_zt
	DQ	FLAT:$SG11439
	DD	02H
	ORG $+4
	DQ	FLAT:Set_zt
	DQ	FLAT:$SG11440
	DD	00H
	ORG $+4
	DQ	FLAT:Set_zt
	DQ	FLAT:$SG11441
	DD	091H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11442
	DD	087H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG11443
	DD	088H
	ORG $+4
	DQ	FLAT:Set_True
cpuoption DD	00H
	DD	010H
	DD	020H
	DD	030H
	DD	040H
	DD	050H
	DD	060H
	DD	0160H
	DD	0560H
	DD	0d60H
	DD	070H
CONST	ENDS
_DATA	SEGMENT
$SG11276 DB	'%3u: %s', 0aH, 00H
	ORG $+7
$SG11280 DB	'debugging output on', 0aH, 00H
	ORG $+3
$SG11284 DB	'FASTPASS disabled', 0aH, 00H
	ORG $+1
$SG11351 DB	'?', 00H
	ORG $+2
$SG11288 DB	'backpatching disabled', 0aH, 00H
	ORG $+1
$SG11352 DB	'af', 00H
	ORG $+1
$SG11353 DB	'bin', 00H
$SG11354 DB	'Cp', 00H
	ORG $+1
$SG11355 DB	'Cu', 00H
	ORG $+1
$SG11356 DB	'Cx', 00H
	ORG $+1
$SG11357 DB	'ce', 00H
	ORG $+1
$SG11358 DB	'coff', 00H
	ORG $+3
$SG11359 DB	'c', 00H
	ORG $+2
$SG11360 DB	'dm', 00H
	ORG $+1
$SG11361 DB	'drh', 00H
$SG11362 DB	'dr', 00H
	ORG $+1
$SG11363 DB	'dsh', 00H
$SG11364 DB	'ds', 00H
	ORG $+1
$SG11365 DB	'dt', 00H
	ORG $+1
$SG11366 DB	'D^$', 00H
$SG11367 DB	'elf64', 00H
	ORG $+2
$SG11368 DB	'elf', 00H
$SG11369 DB	'EP', 00H
	ORG $+1
$SG11370 DB	'eq', 00H
	ORG $+1
$SG11371 DB	'e=#', 00H
$SG11372 DB	'Fd=@', 00H
	ORG $+3
$SG11373 DB	'Fi=^@', 00H
	ORG $+2
$SG11374 DB	'Fl=@', 00H
	ORG $+3
$SG11375 DB	'Fo=^@', 00H
	ORG $+2
$SG11376 DB	'FPi87', 00H
	ORG $+2
$SG11377 DB	'FPi', 00H
$SG11378 DB	'fp0', 00H
$SG11379 DB	'fp2', 00H
$SG11380 DB	'fp3', 00H
$SG11381 DB	'fpc', 00H
$SG11382 DB	'Fw=^@', 00H
	ORG $+2
$SG11383 DB	'Gc', 00H
	ORG $+1
$SG11384 DB	'Gd', 00H
	ORG $+1
$SG11385 DB	'Gr', 00H
	ORG $+1
$SG11386 DB	'Gz', 00H
	ORG $+1
$SG11387 DB	'h', 00H
	ORG $+2
$SG11388 DB	'I=^@', 00H
	ORG $+3
$SG11389 DB	'ls', 00H
	ORG $+1
$SG11390 DB	'mc', 00H
	ORG $+1
$SG11391 DB	'mf', 00H
	ORG $+1
$SG11392 DB	'mh', 00H
	ORG $+1
$SG11393 DB	'ml', 00H
	ORG $+1
$SG11394 DB	'mm', 00H
	ORG $+1
$SG11395 DB	'ms', 00H
	ORG $+1
$SG11396 DB	'mt', 00H
	ORG $+1
$SG11397 DB	'mz', 00H
	ORG $+1
$SG11398 DB	'nbp', 00H
$SG11399 DB	'nc=$', 00H
	ORG $+3
$SG11400 DB	'nd=$', 00H
	ORG $+3
$SG11401 DB	'nfp', 00H
$SG11402 DB	'nm=$', 00H
	ORG $+3
$SG11403 DB	'nologo', 00H
	ORG $+1
$SG11404 DB	'nt=$', 00H
	ORG $+3
$SG11405 DB	'omf', 00H
$SG11406 DB	'pe', 00H
	ORG $+1
$SG11407 DB	'pm=#', 00H
	ORG $+3
$SG11408 DB	'q', 00H
	ORG $+2
$SG11409 DB	'Sa', 00H
	ORG $+1
$SG11410 DB	'Sf', 00H
	ORG $+1
$SG11411 DB	'Sg', 00H
	ORG $+1
$SG11412 DB	'Sn', 00H
	ORG $+1
$SG11413 DB	'Sx', 00H
	ORG $+1
$SG11415 DB	'sp', 00H
	ORG $+1
$SG11414 DB	'safeseh', 00H
$SG11416 DB	'WX', 00H
	ORG $+1
$SG11417 DB	'W=#', 00H
$SG11418 DB	'win64', 00H
	ORG $+2
$SG11419 DB	'w', 00H
	ORG $+2
$SG11420 DB	'X', 00H
	ORG $+2
$SG11421 DB	'Zd', 00H
	ORG $+1
$SG11422 DB	'Zf', 00H
	ORG $+1
$SG11423 DB	'Zg', 00H
	ORG $+1
$SG11424 DB	'Zi=#', 00H
	ORG $+3
$SG11425 DB	'Zm', 00H
	ORG $+1
$SG11426 DB	'Zne', 00H
$SG11427 DB	'Zp=#', 00H
	ORG $+3
$SG11428 DB	'zcm', 00H
$SG11429 DB	'zcw', 00H
$SG11430 DB	'zf0', 00H
$SG11431 DB	'zf1', 00H
$SG11432 DB	'zlc', 00H
$SG11433 DB	'zld', 00H
$SG11434 DB	'zlf', 00H
$SG11435 DB	'zlp', 00H
$SG11436 DB	'zls', 00H
$SG11437 DB	'Zs', 00H
	ORG $+1
$SG11438 DB	'zt0', 00H
$SG11439 DB	'zt1', 00H
$SG11440 DB	'zt2', 00H
$SG11441 DB	'Zv8', 00H
$SG11442 DB	'zze', 00H
$SG11443 DB	'zzs', 00H
$SG11492 DB	'rb', 00H
	ORG $+1
$SG11462 DB	'GetNameToken( %s, %u, ''%c'' ) enter, rspidx=%u', 0aH, 00H
	ORG $+1
$SG11491 DB	'ReadParamFile(%s) enter', 0aH, 00H
	ORG $+3
$SG11173 DB	'Zi', 00H
	ORG $+1
$SG11544 DB	'ProcessOption(%s)', 0aH, 00H
	ORG $+1
$SG11182 DB	'Zp', 00H
	ORG $+1
$SG11561 DB	'ProcessOption: unknown option specifier: %s', 0aH, 00H
	ORG $+3
$SG11562 DB	'cmdline.c', 00H
	ORG $+2
$SG11604 DB	'NULL', 00H
	ORG $+3
$SG11253 DB	'W', 00H
	ORG $+2
$SG11605 DB	'ParseCmdLine: file=>%s< rest=>%s<', 0aH, 00H
	ORG $+5
$SG11628 DB	'CmdLineFini enter', 0aH, 00H
	ORG $+5
$SG11631 DB	'CmdLineFini exit', 0aH, 00H
	ORG $+6
Options	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	00H
	DD	032H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+1
	DW	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	01H
	DD	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	ORG $+3
$SG11120 DB	'queue_item(%u, %s) enter', 0aH, 00H
	ORG $+6
$SG11133 DB	'get_fname( type=%u, >%s< ) enter', 0aH, 00H
	ORG $+6
$SG11135 DB	'get_fname(%u, >%s< ) name is empty or a directory', 0aH, 00H
	ORG $+5
$SG11139 DB	'get_fname: default drive+dir used: %s', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	ParseCmdline
PUBLIC	CmdlineFini
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isspace:PROC
EXTRN	__imp_isalnum:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp_fseek:PROC
EXTRN	__imp_ftell:PROC
EXTRN	__imp_rewind:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp_getenv:PROC
EXTRN	strcat:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	Fatal:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	ErrnoStr:PROC
EXTRN	PrintUsage:PROC
EXTRN	MemAlloc:PROC
EXTRN	MemFree:PROC
EXTRN	MsgGetEx:PROC
EXTRN	InternalError:PROC
EXTRN	GetFNamePart:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	banner_printed:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
OptValue DD	01H DUP (?)
OptName	DQ	01H DUP (?)
cmdsave	DQ	0fH DUP (?)
cmdbuffers DQ	0fH DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$ParseCmdline DD imagerel $LN29
	DD	imagerel $LN29+1101
	DD	imagerel $unwind$ParseCmdline
$pdata$CmdlineFini DD imagerel $LN17
	DD	imagerel $LN17+342
	DD	imagerel $unwind$CmdlineFini
$pdata$SetCpuCmdline DD imagerel SetCpuCmdline
	DD	imagerel SetCpuCmdline+166
	DD	imagerel $unwind$SetCpuCmdline
$pdata$queue_item DD imagerel queue_item
	DD	imagerel queue_item+214
	DD	imagerel $unwind$queue_item
$pdata$get_fname DD imagerel get_fname
	DD	imagerel get_fname+593
	DD	imagerel $unwind$get_fname
$pdata$set_option_n_name DD imagerel set_option_n_name
	DD	imagerel set_option_n_name+239
	DD	imagerel $unwind$set_option_n_name
$pdata$Set_c DD	imagerel Set_c
	DD	imagerel Set_c+4
	DD	imagerel $unwind$Set_c
$pdata$Set_ce DD imagerel Set_ce
	DD	imagerel Set_ce+22
	DD	imagerel $unwind$Set_ce
$pdata$Set_Cp DD imagerel Set_Cp
	DD	imagerel Set_Cp+18
	DD	imagerel $unwind$Set_Cp
$pdata$Set_Cu DD imagerel Set_Cu
	DD	imagerel Set_Cu+18
	DD	imagerel $unwind$Set_Cu
$pdata$Set_Cx DD imagerel Set_Cx
	DD	imagerel Set_Cx+18
	DD	imagerel $unwind$Set_Cx
$pdata$Set_Zd DD imagerel Set_Zd
	DD	imagerel Set_Zd+11
	DD	imagerel $unwind$Set_Zd
$pdata$Set_Zi DD imagerel Set_Zi
	DD	imagerel Set_Zi+85
	DD	imagerel $unwind$Set_Zi
$pdata$Set_Zp DD imagerel Set_Zp
	DD	imagerel Set_Zp+141
	DD	imagerel $unwind$Set_Zp
$pdata$Set_D DD	imagerel Set_D
	DD	imagerel Set_D+44
	DD	imagerel $unwind$Set_D
$pdata$Set_Fi DD imagerel Set_Fi
	DD	imagerel Set_Fi+41
	DD	imagerel $unwind$Set_Fi
$pdata$Set_I DD	imagerel Set_I
	DD	imagerel Set_I+44
	DD	imagerel $unwind$Set_I
$pdata$Set_e DD	imagerel Set_e
	DD	imagerel Set_e+16
	DD	imagerel $unwind$Set_e
$pdata$Set_nologo DD imagerel Set_nologo
	DD	imagerel Set_nologo+11
	DD	imagerel $unwind$Set_nologo
$pdata$Set_q DD	imagerel Set_q
	DD	imagerel Set_q+39
	DD	imagerel $unwind$Set_q
$pdata$Set_EP DD imagerel Set_EP
	DD	imagerel Set_EP+39
	DD	imagerel $unwind$Set_EP
$pdata$Set_Fd DD imagerel Set_Fd
	DD	imagerel Set_Fd+51
	DD	imagerel $unwind$Set_Fd
$pdata$Set_Fw DD imagerel Set_Fw
	DD	imagerel Set_Fw+44
	DD	imagerel $unwind$Set_Fw
$pdata$Set_Fl DD imagerel Set_Fl
	DD	imagerel Set_Fl+51
	DD	imagerel $unwind$Set_Fl
$pdata$Set_Fo DD imagerel Set_Fo
	DD	imagerel Set_Fo+44
	DD	imagerel $unwind$Set_Fo
$pdata$Set_fp DD imagerel Set_fp
	DD	imagerel Set_fp+31
	DD	imagerel $unwind$Set_fp
$pdata$Set_FPx DD imagerel Set_FPx
	DD	imagerel Set_FPx+16
	DD	imagerel $unwind$Set_FPx
$pdata$Set_G DD	imagerel Set_G
	DD	imagerel Set_G+16
	DD	imagerel $unwind$Set_G
$pdata$Set_Sa DD imagerel Set_Sa
	DD	imagerel Set_Sa+28
	DD	imagerel $unwind$Set_Sa
$pdata$Set_True DD imagerel Set_True
	DD	imagerel Set_True+57
	DD	imagerel $unwind$Set_True
$pdata$Set_m DD	imagerel Set_m
	DD	imagerel Set_m+16
	DD	imagerel $unwind$Set_m
$pdata$Set_n DD	imagerel Set_n
	DD	imagerel Set_n+45
	DD	imagerel $unwind$Set_n
$pdata$Set_pm DD imagerel Set_pm
	DD	imagerel Set_pm+18
	DD	imagerel $unwind$Set_pm
$pdata$Set_WX DD imagerel Set_WX
	DD	imagerel Set_WX+11
	DD	imagerel $unwind$Set_WX
$pdata$Set_w DD	imagerel Set_w
	DD	imagerel Set_w+39
	DD	imagerel $unwind$Set_w
$pdata$Set_W DD	imagerel Set_W
	DD	imagerel Set_W+73
	DD	imagerel $unwind$Set_W
$pdata$Set_ofmt DD imagerel Set_ofmt
	DD	imagerel Set_ofmt+36
	DD	imagerel $unwind$Set_ofmt
$pdata$Set_zcm DD imagerel Set_zcm
	DD	imagerel Set_zcm+11
	DD	imagerel $unwind$Set_zcm
$pdata$Set_zf DD imagerel Set_zf
	DD	imagerel Set_zf+16
	DD	imagerel $unwind$Set_zf
$pdata$Set_zt DD imagerel Set_zt
	DD	imagerel Set_zt+17
	DD	imagerel $unwind$Set_zt
$pdata$Set_h DD	imagerel Set_h
	DD	imagerel Set_h+43
	DD	imagerel $unwind$Set_h
$pdata$Set_dm DD imagerel Set_dm
	DD	imagerel Set_dm+87
	DD	imagerel $unwind$Set_dm
$pdata$Set_dt DD imagerel Set_dt
	DD	imagerel Set_dt+62
	DD	imagerel $unwind$Set_dt
$pdata$Set_nfp DD imagerel Set_nfp
	DD	imagerel Set_nfp+46
	DD	imagerel $unwind$Set_nfp
$pdata$Set_nbp DD imagerel Set_nbp
	DD	imagerel Set_nbp+46
	DD	imagerel $unwind$Set_nbp
$pdata$GetNameToken DD imagerel GetNameToken
	DD	imagerel GetNameToken+561
	DD	imagerel $unwind$GetNameToken
$pdata$ReadParamFile DD imagerel ReadParamFile
	DD	imagerel ReadParamFile+363
	DD	imagerel $unwind$ReadParamFile
$pdata$getnextcmdstring DD imagerel getnextcmdstring
	DD	imagerel getnextcmdstring+228
	DD	imagerel $unwind$getnextcmdstring
$pdata$GetNumber DD imagerel GetNumber
	DD	imagerel GetNumber+91
	DD	imagerel $unwind$GetNumber
$pdata$ProcessOption DD imagerel ProcessOption
	DD	imagerel ProcessOption+1083
	DD	imagerel $unwind$ProcessOption
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
xdata	SEGMENT
$unwind$ParseCmdline DD 033b19H
	DD	0300112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0170H
$unwind$CmdlineFini DD 021501H
	DD	070027206H
$unwind$SetCpuCmdline DD 022101H
	DD	0700a320eH
$unwind$queue_item DD 022101H
	DD	0700a520eH
$unwind$get_fname DD 033919H
	DD	02e0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0168H
$unwind$set_option_n_name DD 022101H
	DD	0700a320eH
$unwind$Set_c DD 010201H
	DD	07002H
$unwind$Set_ce DD 010201H
	DD	07002H
$unwind$Set_Cp DD 010201H
	DD	07002H
$unwind$Set_Cu DD 010201H
	DD	07002H
$unwind$Set_Cx DD 010201H
	DD	07002H
$unwind$Set_Zd DD 010201H
	DD	07002H
$unwind$Set_Zi DD 021501H
	DD	070023206H
$unwind$Set_Zp DD 021501H
	DD	070025206H
$unwind$Set_D DD 021501H
	DD	070023206H
$unwind$Set_Fi DD 021501H
	DD	070023206H
$unwind$Set_I DD 021501H
	DD	070023206H
$unwind$Set_e DD 010201H
	DD	07002H
$unwind$Set_nologo DD 010201H
	DD	07002H
$unwind$Set_q DD 021501H
	DD	070023206H
$unwind$Set_EP DD 021501H
	DD	070023206H
$unwind$Set_Fd DD 021501H
	DD	070023206H
$unwind$Set_Fw DD 021501H
	DD	070023206H
$unwind$Set_Fl DD 021501H
	DD	070023206H
$unwind$Set_Fo DD 021501H
	DD	070023206H
$unwind$Set_fp DD 010201H
	DD	07002H
$unwind$Set_FPx DD 010201H
	DD	07002H
$unwind$Set_G DD 010201H
	DD	07002H
$unwind$Set_Sa DD 010201H
	DD	07002H
$unwind$Set_True DD 021501H
	DD	070021206H
$unwind$Set_m DD 010201H
	DD	07002H
$unwind$Set_n DD 021501H
	DD	070023206H
$unwind$Set_pm DD 010201H
	DD	07002H
$unwind$Set_WX DD 010201H
	DD	07002H
$unwind$Set_w DD 021501H
	DD	070023206H
$unwind$Set_W DD 021501H
	DD	070023206H
$unwind$Set_ofmt DD 010201H
	DD	07002H
$unwind$Set_zcm DD 010201H
	DD	07002H
$unwind$Set_zf DD 010201H
	DD	07002H
$unwind$Set_zt DD 010201H
	DD	07002H
$unwind$Set_h DD 021501H
	DD	070023206H
$unwind$Set_dm DD 021501H
	DD	070025206H
$unwind$Set_dt DD 021501H
	DD	070023206H
$unwind$Set_nfp DD 021501H
	DD	070023206H
$unwind$Set_nbp DD 021501H
	DD	070023206H
$unwind$GetNameToken DD 022d01H
	DD	070157219H
$unwind$ReadParamFile DD 021e01H
	DD	07006720aH
$unwind$getnextcmdstring DD 021e01H
	DD	07006520aH
$unwind$GetNumber DD 010601H
	DD	07006H
$unwind$ProcessOption DD 022301H
	DD	0700b720fH
xdata	ENDS
CONST	SEGMENT
	ORG $+4
ParseCmdline$rtcName$0 DB 070H
	DB	061H
	DB	072H
	DB	061H
	DB	06dH
	DB	066H
	DB	069H
	DB	06cH
	DB	065H
	DB	00H
	ORG $+6
ParseCmdline$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:ParseCmdline$rtcVarDesc
get_fname$rtcName$0 DB 06eH
	DB	061H
	DB	06dH
	DB	065H
	DB	00H
	ORG $+3
ParseCmdline$rtcVarDesc DD 040H
	DD	0104H
	DQ	FLAT:ParseCmdline$rtcName$0
	ORG $+48
get_fname$rtcVarDesc DD 040H
	DD	0104H
	DQ	FLAT:get_fname$rtcName$0
	ORG $+48
get_fname$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:get_fname$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
printf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
printf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:printf$rtcName$0
	ORG $+48
printf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:printf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
i$ = 32
j$ = 36
p$ = 40
opt$ = 48
tv156 = 56
cmdline$ = 80
buffer$ = 88
ProcessOption PROC

; 824  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 825  :     int   i;
; 826  :     int   j;
; 827  :     const char *p = *cmdline;

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$[rsp], rax

; 828  :     const char *opt;
; 829  :     //char  c;
; 830  : 
; 831  :     DebugMsg(("ProcessOption(%s)\n", p ));

	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, OFFSET FLAT:$SG11544
	call	DoDebugMsg

; 832  : 
; 833  :     /* numeric option (-0, -1, ... ) handled separately since
; 834  :      * the value can be >= 10.
; 835  :      */
; 836  :     if ( *p >= '0' && *p <= '9' ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN15@ProcessOpt
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN15@ProcessOpt

; 837  :         p = GetNumber( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	GetNumber
	mov	QWORD PTR p$[rsp], rax

; 838  :         if ( OptValue < sizeof(cpuoption)/sizeof(cpuoption[0]) ) {

	mov	eax, DWORD PTR OptValue
	cmp	rax, 11
	jae	SHORT $LN16@ProcessOpt

; 839  :             p = GetNameToken( buffer, p, 16, 0 ); /* get optional 'p' */

	xor	r9d, r9d
	mov	r8d, 16
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	GetNameToken
	mov	QWORD PTR p$[rsp], rax

; 840  :             *cmdline = p;

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 841  :             SetCpuCmdline( cpuoption[OptValue], buffer );

	mov	eax, DWORD PTR OptValue
	lea	rcx, OFFSET FLAT:cpuoption
	mov	rdx, QWORD PTR buffer$[rsp]
	mov	ecx, DWORD PTR [rcx+rax*4]
	call	SetCpuCmdline

; 842  :             return;

	jmp	$LN1@ProcessOpt
$LN16@ProcessOpt:

; 843  :         }
; 844  :         p = *cmdline; /* v2.11: restore option pointer */

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$[rsp], rax
$LN15@ProcessOpt:

; 845  :     }
; 846  :     for( i = 0; i < ( sizeof(cmdl_options) / sizeof(cmdl_options[0]) ); i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@ProcessOpt
$LN2@ProcessOpt:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@ProcessOpt:
	movsxd	rax, DWORD PTR i$[rsp]
	cmp	rax, 93					; 0000005dH
	jae	$LN3@ProcessOpt

; 847  :         //DebugMsg(("ProcessOption(%s): %s\n", p, opt ));
; 848  :         if( *p == *cmdl_options[i].name ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 24
	lea	rdx, OFFSET FLAT:cmdl_options
	mov	rcx, QWORD PTR [rdx+rcx]
	movsx	ecx, BYTE PTR [rcx]
	cmp	eax, ecx
	jne	$LN17@ProcessOpt

; 849  :             for ( opt = cmdl_options[i].name+1, j = 1 ; isalnum(*opt) && *opt == p[j]; opt++, j++ );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cmdl_options
	mov	rax, QWORD PTR [rcx+rax]
	inc	rax
	mov	QWORD PTR opt$[rsp], rax
	mov	DWORD PTR j$[rsp], 1
	jmp	SHORT $LN7@ProcessOpt
$LN5@ProcessOpt:
	mov	rax, QWORD PTR opt$[rsp]
	inc	rax
	mov	QWORD PTR opt$[rsp], rax
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN7@ProcessOpt:
	mov	rax, QWORD PTR opt$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	je	SHORT $LN6@ProcessOpt
	mov	rax, QWORD PTR opt$[rsp]
	movsx	eax, BYTE PTR [rax]
	movsxd	rcx, DWORD PTR j$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN6@ProcessOpt
	jmp	SHORT $LN5@ProcessOpt
$LN6@ProcessOpt:

; 850  :             /* make sure end of option is reached */
; 851  :             if ( isalnum(*opt) )

	mov	rax, QWORD PTR opt$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	je	SHORT $LN18@ProcessOpt

; 852  :                 continue;

	jmp	$LN2@ProcessOpt
$LN18@ProcessOpt:

; 853  :             p += j;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 854  :             OptValue = cmdl_options[i].value;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cmdl_options
	mov	eax, DWORD PTR [rcx+rax+8]
	mov	DWORD PTR OptValue, eax
	jmp	SHORT $LN10@ProcessOpt
$LN8@ProcessOpt:

; 855  :             //DebugMsg(("ProcessOption(%s): Option found\n", p ));
; 856  :             for( ;; opt++) {

	mov	rax, QWORD PTR opt$[rsp]
	inc	rax
	mov	QWORD PTR opt$[rsp], rax
$LN10@ProcessOpt:

; 857  :                 switch ( *opt ) {

	mov	rax, QWORD PTR opt$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv156[rsp], eax
	cmp	DWORD PTR tv156[rsp], 94		; 0000005eH
	ja	$LN30@ProcessOpt
	movsxd	rax, DWORD PTR tv156[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN32@ProcessOpt[rcx+rax]
	mov	eax, DWORD PTR $LN33@ProcessOpt[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN19@ProcessOpt:

; 858  :                 //case '*': /* don't know what this is supposed to do? */
; 859  :                 case NULLC:
; 860  :                     if ( !IsOptionDelimiter( *p ) )

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN20@ProcessOpt
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN20@ProcessOpt
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN20@ProcessOpt
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN20@ProcessOpt
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 9
	je	SHORT $LN20@ProcessOpt

; 861  :                         goto opt_error_exit;

	jmp	$opt_error_exit$34
$LN20@ProcessOpt:

; 862  :                     *cmdline = p;

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 863  :                     cmdl_options[i].function();

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cmdl_options
	call	QWORD PTR [rcx+rax+16]

; 864  :                     return; /* option processed successfully */

	jmp	$LN1@ProcessOpt

; 865  :                     break;

	jmp	$LN11@ProcessOpt
$LN21@ProcessOpt:

; 866  :                 case '#':             /* collect a number */
; 867  :                     if( *p >= '0' && *p <= '9' )

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN22@ProcessOpt
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN22@ProcessOpt

; 868  :                         p = GetNumber( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	GetNumber
	mov	QWORD PTR p$[rsp], rax
$LN22@ProcessOpt:

; 869  :                     break;

	jmp	$LN11@ProcessOpt
$LN23@ProcessOpt:

; 870  :                 case '$':      /* collect an identifer+value */
; 871  :                 case '@':      /* collect a filename */
; 872  :                     OptName = buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR OptName, rax

; 873  : #if 0  /* v2.05: removed */
; 874  :                     if ( rspidx )
; 875  :                         p = GetNameToken( buffer, p, FILENAME_MAX - 1, *opt );
; 876  :                     else {
; 877  :                         j = strlen( p );
; 878  :                         memcpy( buffer, p, (j >= FILENAME_MAX) ? FILENAME_MAX : j + 1 );
; 879  :                         p += j;
; 880  :                     }
; 881  : #else
; 882  :                     /* v2.10: spaces in filename now handled inside GetNameToken() */
; 883  :                     p = GetNameToken( buffer, p, FILENAME_MAX - 1, *opt );

	mov	rax, QWORD PTR opt$[rsp]
	movzx	r9d, BYTE PTR [rax]
	mov	r8d, 259				; 00000103H
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	GetNameToken
	mov	QWORD PTR p$[rsp], rax

; 884  : #endif
; 885  :                     break;

	jmp	$LN11@ProcessOpt
$LN24@ProcessOpt:

; 886  :                 case '=':    /* collect an optional '=' */
; 887  :                     if ( *p == '=' || *p == '#' )

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN26@ProcessOpt
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN25@ProcessOpt
$LN26@ProcessOpt:

; 888  :                         p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN25@ProcessOpt:

; 889  :                     break;

	jmp	SHORT $LN11@ProcessOpt
$LN27@ProcessOpt:
$LN13@ProcessOpt:

; 890  :                 case '^':    /* skip spaces before argument */
; 891  :                     while ( isspace(*p) ) p++;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN14@ProcessOpt
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN13@ProcessOpt
$LN14@ProcessOpt:

; 892  :                     if ( *p == NULLC ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN28@ProcessOpt

; 893  :                         p = getnextcmdstring( cmdline );

	mov	rcx, QWORD PTR cmdline$[rsp]
	call	getnextcmdstring
	mov	QWORD PTR p$[rsp], rax

; 894  :                         if ( p == NULL ) {

	cmp	QWORD PTR p$[rsp], 0
	jne	SHORT $LN29@ProcessOpt

; 895  :                             EmitWarn( 1, MISSING_ARGUMENT_FOR_CMDLINE_OPTION );

	mov	edx, 251				; 000000fbH
	mov	ecx, 1
	call	EmitWarn

; 896  :                             return;

	jmp	SHORT $LN1@ProcessOpt
$LN29@ProcessOpt:
$LN28@ProcessOpt:

; 897  :                         }
; 898  :                     }
; 899  :                     break;

	jmp	SHORT $LN11@ProcessOpt
$LN30@ProcessOpt:

; 900  :                 default:
; 901  :                     /* internal error: unknown format of option item! */
; 902  :                     DebugMsg(( "ProcessOption: unknown option specifier: %s\n", opt ));

	mov	rdx, QWORD PTR opt$[rsp]
	lea	rcx, OFFSET FLAT:$SG11561
	call	DoDebugMsg

; 903  :                     /**/myassert( 0 );

	mov	edx, 903				; 00000387H
	lea	rcx, OFFSET FLAT:$SG11562
	call	InternalError
$LN11@ProcessOpt:

; 904  :                     break;
; 905  :                 }
; 906  :             }

	jmp	$LN8@ProcessOpt
$LN17@ProcessOpt:

; 907  :         }
; 908  :     }

	jmp	$LN2@ProcessOpt
$LN3@ProcessOpt:
$opt_error_exit$34:

; 909  : opt_error_exit:
; 910  :     EmitWarn( 1, INVALID_CMDLINE_OPTION, *cmdline - 1 );

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rax, QWORD PTR [rax]
	dec	rax
	mov	r8, rax
	mov	edx, 109				; 0000006dH
	mov	ecx, 1
	call	EmitWarn

; 911  :     *cmdline = "";

	mov	rax, QWORD PTR cmdline$[rsp]
	lea	rcx, OFFSET FLAT:$SG11563
	mov	QWORD PTR [rax], rcx
$LN1@ProcessOpt:

; 912  :     return;
; 913  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
	npad	1
$LN33@ProcessOpt:
	DD	$LN19@ProcessOpt
	DD	$LN21@ProcessOpt
	DD	$LN23@ProcessOpt
	DD	$LN24@ProcessOpt
	DD	$LN27@ProcessOpt
	DD	$LN30@ProcessOpt
$LN32@ProcessOpt:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
ProcessOption ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
p$ = 16
GetNumber PROC

; 807  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 808  :     OptValue = 0;

	mov	DWORD PTR OptValue, 0

; 809  :     for( ;*p >= '0' && *p <= '9'; p++ )

	jmp	SHORT $LN4@GetNumber
$LN2@GetNumber:
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN4@GetNumber:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN3@GetNumber
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN3@GetNumber

; 810  :         OptValue = OptValue * 10 + *p - '0';

	imul	eax, DWORD PTR OptValue, 10
	mov	rcx, QWORD PTR p$[rsp]
	movsx	ecx, BYTE PTR [rcx]
	lea	eax, DWORD PTR [rax+rcx-48]
	mov	DWORD PTR OptValue, eax
	jmp	SHORT $LN2@GetNumber
$LN3@GetNumber:

; 811  :     return( p );

	mov	rax, QWORD PTR p$[rsp]

; 812  : }

	pop	rdi
	ret	0
GetNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
src$ = 32
dst$ = 40
cmdline$ = 64
getnextcmdstring PROC

; 788  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 789  :     const char **src;
; 790  :     const char **dst;
; 791  : 
; 792  :     /* something onto the response file stack? */
; 793  :     if ( rspidx ) {

	cmp	DWORD PTR rspidx, 0
	je	SHORT $LN5@getnextcmd

; 794  :         rspidx--;

	mov	eax, DWORD PTR rspidx
	dec	eax
	mov	DWORD PTR rspidx, eax

; 795  :         if ( cmdbuffers[rspidx] )

	movsxd	rax, DWORD PTR rspidx
	lea	rcx, OFFSET FLAT:cmdbuffers
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN6@getnextcmd

; 796  :             MemFree( (void *)cmdbuffers[rspidx] );

	movsxd	rax, DWORD PTR rspidx
	lea	rcx, OFFSET FLAT:cmdbuffers
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	MemFree
$LN6@getnextcmd:

; 797  :         return( cmdsave[rspidx] );

	movsxd	rax, DWORD PTR rspidx
	lea	rcx, OFFSET FLAT:cmdsave
	mov	rax, QWORD PTR [rcx+rax*8]
	jmp	SHORT $LN1@getnextcmd
$LN5@getnextcmd:

; 798  :     }
; 799  :     for ( dst = cmdline, src = cmdline+1; *src; )

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR cmdline$[rsp]
	add	rax, 8
	mov	QWORD PTR src$[rsp], rax
$LN2@getnextcmd:
	mov	rax, QWORD PTR src$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@getnextcmd

; 800  :         *dst++ = *src++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR dst$[rsp]
	add	rax, 8
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	add	rax, 8
	mov	QWORD PTR src$[rsp], rax
	jmp	SHORT $LN2@getnextcmd
$LN3@getnextcmd:

; 801  :     *dst = *src;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 802  :     return( *cmdline );

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rax, QWORD PTR [rax]
$LN1@getnextcmd:

; 803  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
getnextcmdstring ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
env$ = 32
str$ = 40
file$ = 48
len$ = 56
ch$ = 60
name$ = 80
ReadParamFile PROC

; 735  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 736  :     char        *env;
; 737  :     char        *str;
; 738  :     FILE        *file;
; 739  :     int         len;
; 740  :     char        ch;
; 741  : 
; 742  :     DebugMsg(("ReadParamFile(%s) enter\n"));

	lea	rcx, OFFSET FLAT:$SG11491
	call	DoDebugMsg

; 743  :     env = NULL;

	mov	QWORD PTR env$[rsp], 0

; 744  :     file = fopen( name, "rb" );

	lea	rdx, OFFSET FLAT:$SG11492
	mov	rcx, QWORD PTR name$[rsp]
	call	QWORD PTR __imp_fopen
	mov	QWORD PTR file$[rsp], rax

; 745  :     if( file == NULL ) {

	cmp	QWORD PTR file$[rsp], 0
	jne	SHORT $LN4@ReadParamF

; 746  :         /* v2.10: changed to fatal error */
; 747  :         //EmitErr( CANNOT_OPEN_FILE, name, ErrnoStr() );
; 748  :         Fatal( CANNOT_OPEN_FILE, name, ErrnoStr() );

	call	ErrnoStr
	mov	r8, rax
	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 106				; 0000006aH
	call	Fatal

; 749  :         return( NULL );

	xor	eax, eax
	jmp	$LN1@ReadParamF
$LN4@ReadParamF:

; 750  :     }
; 751  :     len = 0;

	mov	DWORD PTR len$[rsp], 0

; 752  :     if ( fseek( file, 0, SEEK_END ) == 0 ) {

	mov	r8d, 2
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rsp]
	call	QWORD PTR __imp_fseek
	test	eax, eax
	jne	SHORT $LN5@ReadParamF

; 753  :         len = ftell( file );

	mov	rcx, QWORD PTR file$[rsp]
	call	QWORD PTR __imp_ftell
	mov	DWORD PTR len$[rsp], eax

; 754  :         rewind( file );

	mov	rcx, QWORD PTR file$[rsp]
	call	QWORD PTR __imp_rewind

; 755  :         env = MemAlloc( len + 1 );

	mov	eax, DWORD PTR len$[rsp]
	inc	eax
	cdqe
	mov	rcx, rax
	call	MemAlloc
	mov	QWORD PTR env$[rsp], rax

; 756  : #if defined(__GNUC__) /* gcc warns if return value of fread() is "ignored" */
; 757  :         if ( fread( env, 1, len, file ) );
; 758  : #else
; 759  :         fread( env, 1, len, file );

	movsxd	rax, DWORD PTR len$[rsp]
	mov	r9, QWORD PTR file$[rsp]
	mov	r8, rax
	mov	edx, 1
	mov	rcx, QWORD PTR env$[rsp]
	call	QWORD PTR __imp_fread

; 760  : #endif
; 761  :         env[len] = NULLC;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR env$[rsp]
	mov	BYTE PTR [rcx+rax], 0
$LN5@ReadParamF:

; 762  :     }
; 763  :     fclose( file );

	mov	rcx, QWORD PTR file$[rsp]
	call	QWORD PTR __imp_fclose

; 764  :     if ( len == 0)

	cmp	DWORD PTR len$[rsp], 0
	jne	SHORT $LN6@ReadParamF

; 765  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@ReadParamF
$LN6@ReadParamF:

; 766  :     /* zip through characters changing \r, \n etc into ' ' */
; 767  :     str = env;

	mov	rax, QWORD PTR env$[rsp]
	mov	QWORD PTR str$[rsp], rax
$LN2@ReadParamF:

; 768  :     while( *str ) {

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@ReadParamF

; 769  :         ch = *str;

	mov	rax, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR ch$[rsp], al

; 770  :         if( ch == '\r' || ch == '\n' ) {

	movsx	eax, BYTE PTR ch$[rsp]
	cmp	eax, 13
	je	SHORT $LN8@ReadParamF
	movsx	eax, BYTE PTR ch$[rsp]
	cmp	eax, 10
	jne	SHORT $LN7@ReadParamF
$LN8@ReadParamF:

; 771  :             *str = ' ';

	mov	rax, QWORD PTR str$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
$LN7@ReadParamF:

; 772  :         }
; 773  : #if HANDLECTRLZ
; 774  :         if( ch == 0x1A ) {      /* if end of file */

	movsx	eax, BYTE PTR ch$[rsp]
	cmp	eax, 26
	jne	SHORT $LN9@ReadParamF

; 775  :             *str = '\0';        /* - mark end of str */

	mov	rax, QWORD PTR str$[rsp]
	mov	BYTE PTR [rax], 0

; 776  :             break;

	jmp	SHORT $LN3@ReadParamF
$LN9@ReadParamF:

; 777  :         }
; 778  : #endif
; 779  :         ++str;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 780  :     }

	jmp	SHORT $LN2@ReadParamF
$LN3@ReadParamF:

; 781  :     return( env );

	mov	rax, QWORD PTR env$[rsp]
$LN1@ReadParamF:

; 782  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ReadParamFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
equatefound$ = 48
dst$ = 80
str$ = 88
max$ = 96
type$ = 104
GetNameToken PROC

; 680  : {

	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 681  :     bool equatefound = FALSE;

	mov	BYTE PTR equatefound$[rsp], 0

; 682  : 
; 683  :     DebugMsg(("GetNameToken( %s, %u, '%c' ) enter, rspidx=%u\n", str, max, type, rspidx ));

	movsx	eax, BYTE PTR type$[rsp]
	mov	ecx, DWORD PTR rspidx
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, eax
	mov	r8d, DWORD PTR max$[rsp]
	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, OFFSET FLAT:$SG11462
	call	DoDebugMsg
$is_quote$22:

; 684  :     //while( isspace( *str ) ) ++str;  /* no spaces allowed! */
; 685  : is_quote:
; 686  :     if( *str == '"' ) {

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 34					; 00000022H
	jne	$LN8@GetNameTok

; 687  :         ++str;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 688  :         for( ; max && *str; max-- ) {

	jmp	SHORT $LN4@GetNameTok
$LN2@GetNameTok:
	mov	eax, DWORD PTR max$[rsp]
	dec	eax
	mov	DWORD PTR max$[rsp], eax
$LN4@GetNameTok:
	cmp	DWORD PTR max$[rsp], 0
	je	SHORT $LN3@GetNameTok
	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@GetNameTok

; 689  :             if ( *str == '"' ) {

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN10@GetNameTok

; 690  :                 ++str;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 691  :                 break;

	jmp	SHORT $LN3@GetNameTok
$LN10@GetNameTok:

; 692  :             }
; 693  :             /* handle the \" case */
; 694  :             if ( *str == '\\' && *(str+1) == '"' ) {

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN11@GetNameTok
	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN11@GetNameTok

; 695  :                 ++str;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax
$LN11@GetNameTok:

; 696  :             }
; 697  :             *dst++ = *str++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 698  :         }

	jmp	$LN2@GetNameTok
$LN3@GetNameTok:

; 699  :     } else {

	jmp	$LN9@GetNameTok
$LN8@GetNameTok:

; 700  :         for( ; max; max-- ) {

	jmp	SHORT $LN7@GetNameTok
$LN5@GetNameTok:
	mov	eax, DWORD PTR max$[rsp]
	dec	eax
	mov	DWORD PTR max$[rsp], eax
$LN7@GetNameTok:
	cmp	DWORD PTR max$[rsp], 0
	je	$LN6@GetNameTok

; 701  :             /* v2.10: don't stop for white spaces */
; 702  :             //if ( *str == NULLC || *str == ' ' || *str == '\t' )
; 703  :             if ( *str == NULLC )

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN12@GetNameTok

; 704  :                 break;

	jmp	$LN6@GetNameTok
$LN12@GetNameTok:

; 705  :             /* v2.10: don't stop for white spaces if filename is expected and true cmdline is parsed */
; 706  :             if ( ( *str == ' ' || *str == '\t' ) && ( rspidx || type != '@' ) )

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN14@GetNameTok
	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 9
	jne	SHORT $LN13@GetNameTok
$LN14@GetNameTok:
	cmp	DWORD PTR rspidx, 0
	jne	SHORT $LN15@GetNameTok
	movsx	eax, BYTE PTR type$[rsp]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN13@GetNameTok
$LN15@GetNameTok:

; 707  :                 break;

	jmp	$LN6@GetNameTok
$LN13@GetNameTok:

; 708  :             if ( type == 0 )

	movsx	eax, BYTE PTR type$[rsp]
	test	eax, eax
	jne	SHORT $LN16@GetNameTok

; 709  :                 if ( *str == '-'
; 710  : #if SWITCHCHAR
; 711  :                     || *str == '/'

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN18@GetNameTok
	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN17@GetNameTok
$LN18@GetNameTok:

; 712  : #endif
; 713  :                    )
; 714  :                     break;

	jmp	$LN6@GetNameTok
$LN17@GetNameTok:
$LN16@GetNameTok:

; 715  :             if ( *str == '=' && type == '$' && equatefound == FALSE ) {

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 61					; 0000003dH
	jne	SHORT $LN19@GetNameTok
	movsx	eax, BYTE PTR type$[rsp]
	cmp	eax, 36					; 00000024H
	jne	SHORT $LN19@GetNameTok
	movzx	eax, BYTE PTR equatefound$[rsp]
	test	eax, eax
	jne	SHORT $LN19@GetNameTok

; 716  :                 equatefound = TRUE;

	mov	BYTE PTR equatefound$[rsp], 1

; 717  :                 *dst++ = *str++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 718  :                 if (*str == '"')

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN20@GetNameTok

; 719  :                     goto is_quote;

	jmp	$is_quote$22
$LN20@GetNameTok:
$LN19@GetNameTok:

; 720  :             }
; 721  :             *dst++ = *str++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 722  :         }

	jmp	$LN5@GetNameTok
$LN6@GetNameTok:
$LN9@GetNameTok:

; 723  :     }
; 724  :     *dst = NULLC;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 0

; 725  :     return( str );

	mov	rax, QWORD PTR str$[rsp]

; 726  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
GetNameToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_nbp	PROC

; 495  : {

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 496  :     Options.nobackpatch = TRUE;

	mov	BYTE PTR Options+16, 1

; 497  :     DebugMsg(( "backpatching disabled\n" ));

	lea	rcx, OFFSET FLAT:$SG11288
	call	DoDebugMsg

; 498  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_nbp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_nfp	PROC

; 488  : {

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 489  :     Options.nofastpass = TRUE;

	mov	BYTE PTR Options+17, 1

; 490  :     DebugMsg(( "FASTPASS disabled\n" ));

	lea	rcx, OFFSET FLAT:$SG11284
	call	DoDebugMsg

; 491  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_nfp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_dt	PROC

; 480  : {

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 481  :     Options.debug = TRUE;

	mov	BYTE PTR Options+15, 1

; 482  :     ModuleInfo.cref = TRUE; /* enable debug displays */

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 12
	mov	DWORD PTR ModuleInfo+408, eax

; 483  :     DebugMsg(( "debugging output on\n" ));

	lea	rcx, OFFSET FLAT:$SG11280
	call	DoDebugMsg

; 484  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_dt	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
i$ = 32
Set_dm	PROC

; 472  : {

	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 473  :     int i;
; 474  :     for ( i = 0; i < MSG_LAST; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@Set_dm
$LN2@Set_dm:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@Set_dm:
	cmp	DWORD PTR i$[rsp], 277			; 00000115H
	jge	SHORT $LN3@Set_dm

; 475  :         printf("%3u: %s\n", i, MsgGetEx(i) );

	mov	ecx, DWORD PTR i$[rsp]
	call	MsgGetEx
	mov	r8, rax
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11276
	call	printf

; 476  :     }

	jmp	SHORT $LN2@Set_dm
$LN3@Set_dm:

; 477  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
Set_dm	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_h	PROC

; 467  : static void OPTQUAL Set_h( void ) {  PrintUsage();  exit(1); }

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	PrintUsage
	mov	ecx, 1
	call	QWORD PTR __imp_exit
$LN2@Set_h:
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_h	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_zt	PROC

; 465  : static void OPTQUAL Set_zt( void ) { Options.stdcall_decoration = OptValue; }

	push	rdi
	movzx	eax, BYTE PTR OptValue
	mov	BYTE PTR Options+134, al
	pop	rdi
	ret	0
Set_zt	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_zf	PROC

; 462  : static void OPTQUAL Set_zf( void )  { Options.fctype = OptValue; }

	push	rdi
	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+184, eax
	pop	rdi
	ret	0
Set_zf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_zcm	PROC

; 460  : static void OPTQUAL Set_zcm( void ) { Options.no_cdecl_decoration = FALSE; }

	push	rdi
	mov	BYTE PTR Options+133, 0
	pop	rdi
	ret	0
Set_zcm	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_ofmt PROC

; 455  : {

	push	rdi

; 456  :     Options.output_format = OptValue & 0xff;

	mov	eax, DWORD PTR OptValue
	and	eax, 255				; 000000ffH
	mov	DWORD PTR Options+160, eax

; 457  :     Options.sub_format = OptValue >> 8;

	mov	eax, DWORD PTR OptValue
	shr	eax, 8
	mov	DWORD PTR Options+164, eax

; 458  : }

	pop	rdi
	ret	0
Set_ofmt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_W	PROC

; 446  : {

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 447  :     if ( OptValue <= 4 )

	cmp	DWORD PTR OptValue, 4
	ja	SHORT $LN2@Set_W

; 448  :         Options.warning_level = OptValue;

	movzx	eax, BYTE PTR OptValue
	mov	BYTE PTR Options+13, al
	jmp	SHORT $LN3@Set_W
$LN2@Set_W:

; 449  :     else
; 450  :         EmitWarn( 1, INVALID_CMDLINE_VALUE, "W" );

	lea	r8, OFFSET FLAT:$SG11253
	mov	edx, 195				; 000000c3H
	mov	ecx, 1
	call	EmitWarn
$LN3@Set_W:

; 451  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_W	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_w	PROC

; 442  : static void OPTQUAL Set_w( void ) { Set_WX(); Options.warning_level = 0; }

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	Set_WX
	mov	BYTE PTR Options+13, 0
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_w	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_WX	PROC

; 440  : static void OPTQUAL Set_WX( void ) { Options.warning_error = TRUE; }

	push	rdi
	mov	BYTE PTR Options+14, 1
	pop	rdi
	ret	0
Set_WX	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_pm	PROC

; 437  : static void OPTQUAL Set_pm( void ) { Options.max_passes = OptValue; };

	push	rdi
	movzx	eax, WORD PTR OptValue
	mov	WORD PTR Options+20, ax
	pop	rdi
	ret	0
Set_pm	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_n	PROC

; 434  : static void OPTQUAL Set_n( void ) { set_option_n_name( OptValue, OptName ); }

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rdx, QWORD PTR OptName
	mov	ecx, DWORD PTR OptValue
	call	set_option_n_name
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_n	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_m	PROC

; 433  : static void OPTQUAL Set_m( void ) { Options.model = OptValue; }

	push	rdi
	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+176, eax
	pop	rdi
	ret	0
Set_m	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
p$ = 0
Set_True PROC

; 428  : {

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 429  :     char *p = ((char *)&Options) + OptValue;

	mov	eax, DWORD PTR OptValue
	lea	rcx, OFFSET FLAT:Options
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 430  :     *p = TRUE;

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 1

; 431  : }

	add	rsp, 16
	pop	rdi
	ret	0
Set_True ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Sa	PROC

; 420  : {

	push	rdi

; 421  :     Options.listif = TRUE;

	mov	BYTE PTR Options+146, 1

; 422  :     Options.list_generated_code = TRUE;

	mov	BYTE PTR Options+147, 1

; 423  :     Options.list_macro = LM_LISTMACROALL;

	mov	DWORD PTR Options+148, 2

; 424  : }

	pop	rdi
	ret	0
Set_Sa	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_G	PROC

; 416  : static void OPTQUAL Set_G( void ) { Options.langtype = OptValue; }

	push	rdi
	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+172, eax
	pop	rdi
	ret	0
Set_G	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_FPx	PROC

; 415  : static void OPTQUAL Set_FPx( void ) { Options.floating_point = OptValue; }

	push	rdi
	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+4, eax
	pop	rdi
	ret	0
Set_FPx	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_fp	PROC

; 414  : static void OPTQUAL Set_fp( void ) { Options.cpu &= ~P_FPU_MASK; Options.cpu = OptValue; }

	push	rdi
	mov	eax, DWORD PTR Options+180
	and	eax, -8
	mov	DWORD PTR Options+180, eax
	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+180, eax
	pop	rdi
	ret	0
Set_fp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Fo	PROC

; 412  : static void OPTQUAL Set_Fo( void ) { get_fname( OPTN_OBJ_FN, GetAFileName() ); }

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rdx, QWORD PTR OptName
	mov	ecx, 1
	call	get_fname
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_Fo	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Fl	PROC

; 411  : static void OPTQUAL Set_Fl( void ) { get_fname( OPTN_LST_FN, GetAFileName() ); Options.write_listing = TRUE;}

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rdx, QWORD PTR OptName
	mov	ecx, 2
	call	get_fname
	mov	BYTE PTR Options+137, 1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_Fl	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Fw	PROC

; 410  : static void OPTQUAL Set_Fw( void ) { get_fname( OPTN_ERR_FN, GetAFileName() ); }

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rdx, QWORD PTR OptName
	mov	ecx, 3
	call	get_fname
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_Fw	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Fd	PROC

; 408  : static void OPTQUAL Set_Fd( void ) { get_fname( OPTN_LNKDEF_FN, GetAFileName() ); Options.write_impdef = TRUE;}

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rdx, QWORD PTR OptName
	mov	ecx, 4
	call	get_fname
	mov	BYTE PTR Options+138, 1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_Fd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_EP	PROC

; 405  : static void OPTQUAL Set_EP( void ) { Options.preprocessor_stdout = TRUE; Set_q(); }

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR Options+141, 1
	call	Set_q
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_EP	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_q	PROC

; 404  : static void OPTQUAL Set_q( void )      { Set_nologo(); Options.quiet = TRUE; }

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	Set_nologo
	mov	BYTE PTR Options, 1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_q	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_nologo PROC

; 403  : static void OPTQUAL Set_nologo( void ) { banner_printed = TRUE; }

	push	rdi
	mov	BYTE PTR banner_printed, 1
	pop	rdi
	ret	0
Set_nologo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_e	PROC

; 401  : static void OPTQUAL Set_e( void ) { Options.error_limit = OptValue; }

	push	rdi
	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+8, eax
	pop	rdi
	ret	0
Set_e	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_I	PROC

; 399  : static void OPTQUAL Set_I( void )  { queue_item( OPTQ_INCPATH,  GetAFileName() ); }

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rdx, QWORD PTR OptName
	mov	ecx, 2
	call	queue_item
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_I	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Fi	PROC

; 398  : static void OPTQUAL Set_Fi( void ) { queue_item( OPTQ_FINCLUDE, GetAFileName() ); }

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rdx, QWORD PTR OptName
	xor	ecx, ecx
	call	queue_item
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_Fi	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_D	PROC

; 397  : static void OPTQUAL Set_D( void )  { queue_item( OPTQ_MACRO,    GetAFileName() ); }

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rdx, QWORD PTR OptName
	mov	ecx, 1
	call	queue_item
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_D	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
power$ = 32
tv79 = 36
tv82 = 40
Set_Zp	PROC

; 386  : {

	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 387  :     uint_8 power;
; 388  :     for ( power = 0; (1 << power) <= MAX_STRUCT_ALIGN; power++ )

	mov	BYTE PTR power$[rsp], 0
	jmp	SHORT $LN4@Set_Zp
$LN2@Set_Zp:
	movzx	eax, BYTE PTR power$[rsp]
	inc	al
	mov	BYTE PTR power$[rsp], al
$LN4@Set_Zp:
	movzx	eax, BYTE PTR power$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv79[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv79[rsp]
	shl	eax, cl
	cmp	eax, 32					; 00000020H
	jg	SHORT $LN3@Set_Zp

; 389  :         if ( ( 1 << power ) == OptValue ) {

	movzx	eax, BYTE PTR power$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv82[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv82[rsp]
	shl	eax, cl
	cmp	eax, DWORD PTR OptValue
	jne	SHORT $LN5@Set_Zp

; 390  :             Options.fieldalign = power;

	movzx	eax, BYTE PTR power$[rsp]
	mov	BYTE PTR Options+168, al

; 391  :             return;

	jmp	SHORT $LN1@Set_Zp
$LN5@Set_Zp:

; 392  :         }

	jmp	SHORT $LN2@Set_Zp
$LN3@Set_Zp:

; 393  :     EmitWarn( 1, INVALID_CMDLINE_VALUE, "Zp" );

	lea	r8, OFFSET FLAT:$SG11182
	mov	edx, 195				; 000000c3H
	mov	ecx, 1
	call	EmitWarn
$LN1@Set_Zp:

; 394  :     return;
; 395  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
Set_Zp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Zi	PROC

; 374  : {

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 375  :     Set_Zd();

	call	Set_Zd

; 376  :     Options.debug_symbols = CV_SIGNATURE;

	mov	BYTE PTR Options+2, 1

; 377  :     /* v2.10: added optional numeric argument for -Zi */
; 378  :     if ( OptValue <= CVEX_MAX )

	cmp	DWORD PTR OptValue, 3
	ja	SHORT $LN2@Set_Zi

; 379  :         Options.debug_ext = OptValue;

	movzx	eax, BYTE PTR OptValue
	mov	BYTE PTR Options+3, al
	jmp	SHORT $LN3@Set_Zi
$LN2@Set_Zi:

; 380  :     else
; 381  :         EmitWarn( 1, INVALID_CMDLINE_VALUE, "Zi" );

	lea	r8, OFFSET FLAT:$SG11173
	mov	edx, 195				; 000000c3H
	mov	ecx, 1
	call	EmitWarn
$LN3@Set_Zi:

; 382  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
Set_Zi	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Zd	PROC

; 372  : static void OPTQUAL Set_Zd( void ) { Options.line_numbers = TRUE; }

	push	rdi
	mov	BYTE PTR Options+1, 1
	pop	rdi
	ret	0
Set_Zd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Cx	PROC

; 370  : static void OPTQUAL Set_Cx( void ) { Options.case_sensitive = FALSE;  Options.convert_uppercase = FALSE; }

	push	rdi
	mov	BYTE PTR Options+139, 0
	mov	BYTE PTR Options+140, 0
	pop	rdi
	ret	0
Set_Cx	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Cu	PROC

; 369  : static void OPTQUAL Set_Cu( void ) { Options.case_sensitive = FALSE;  Options.convert_uppercase = TRUE;  }

	push	rdi
	mov	BYTE PTR Options+139, 0
	mov	BYTE PTR Options+140, 1
	pop	rdi
	ret	0
Set_Cu	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_Cp	PROC

; 368  : static void OPTQUAL Set_Cp( void ) { Options.case_sensitive = TRUE;   Options.convert_uppercase = FALSE; }

	push	rdi
	mov	BYTE PTR Options+139, 1
	mov	BYTE PTR Options+140, 0
	pop	rdi
	ret	0
Set_Cp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_ce	PROC

; 365  : static void OPTQUAL Set_ce( void ) { rspidx = 1 / rspidx; }

	push	rdi
	mov	eax, 1
	cdq
	idiv	DWORD PTR rspidx
	mov	DWORD PTR rspidx, eax
	pop	rdi
	ret	0
Set_ce	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
Set_c	PROC

; 362  : static void OPTQUAL Set_c( void ) { }

	push	rdi
	pop	rdi
	ret	0
Set_c	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
idx$ = 48
name$ = 56
set_option_n_name PROC

; 343  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 344  :     if ( *name != '.' && !is_valid_id_char( *name ) ) {

	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN2@set_option
	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	SHORT $LN2@set_option
	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN2@set_option
	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN2@set_option
	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN2@set_option
	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN2@set_option

; 345  :         EmitError( N_OPTION_NEEDS_A_NAME_PARAMETER );

	mov	ecx, 234				; 000000eaH
	call	EmitError

; 346  :         return;

	jmp	SHORT $LN1@set_option
$LN2@set_option:

; 347  :     }
; 348  : 
; 349  :     if( Options.names[idx] != NULL ) {

	movsxd	rax, DWORD PTR idx$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN3@set_option

; 350  :         MemFree( Options.names[idx] );

	movsxd	rax, DWORD PTR idx$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	MemFree
$LN3@set_option:

; 351  :     }
; 352  :     Options.names[idx] = MemAlloc( strlen( name ) + 1 );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	inc	rax
	mov	rcx, rax
	call	MemAlloc
	movsxd	rcx, DWORD PTR idx$[rsp]
	lea	rdx, OFFSET FLAT:Options+32
	mov	QWORD PTR [rdx+rcx*8], rax

; 353  :     strcpy( Options.names[idx], name );

	movsxd	rax, DWORD PTR idx$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	strcpy
$LN1@set_option:

; 354  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
set_option_n_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
pName$ = 32
name$ = 64
$T4 = 352
__$ArrayPad$ = 360
type$ = 384
token$ = 392
get_fname PROC

; 287  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 368				; 00000170H
	mov	rdi, rsp
	mov	ecx, 92					; 0000005cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+384]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 288  :     const char  *pName;
; 289  :     char        name [ FILENAME_MAX ];
; 290  : 
; 291  :     DebugMsg(("get_fname( type=%u, >%s< ) enter\n", type, token ));

	mov	r8, QWORD PTR token$[rsp]
	mov	edx, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:$SG11133
	call	DoDebugMsg

; 292  :     //_splitpath( token, drive, dir, fname, ext );
; 293  :     pName = GetFNamePart( token );

	mov	rcx, QWORD PTR token$[rsp]
	call	GetFNamePart
	mov	QWORD PTR pName$[rsp], rax

; 294  :     /*
; 295  :      * If name's ending with a '\' (or '/' in Unix), it's supposed
; 296  :      * to be a directory name only.
; 297  :      */
; 298  :     if( *pName == NULLC ) {

	mov	rax, QWORD PTR pName$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	$LN2@get_fname

; 299  :         DebugMsg(("get_fname(%u, >%s< ) name is empty or a directory\n", type, token ));

	mov	r8, QWORD PTR token$[rsp]
	mov	edx, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:$SG11135
	call	DoDebugMsg

; 300  :         /* v2.10: ensure type is < NUM_FILE_TYPES */
; 301  :         if ( type < NUM_FILE_TYPES ) {

	cmp	DWORD PTR type$[rsp], 4
	jge	SHORT $LN3@get_fname

; 302  :             if ( DefaultDir[type] )

	movsxd	rax, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN4@get_fname

; 303  :                 MemFree( DefaultDir[type]);

	movsxd	rax, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	MemFree
$LN4@get_fname:

; 304  :             DefaultDir[type] = MemAlloc( strlen( token ) + 1 );

	mov	rcx, QWORD PTR token$[rsp]
	call	strlen
	inc	rax
	mov	rcx, rax
	call	MemAlloc
	movsxd	rcx, DWORD PTR type$[rsp]
	lea	rdx, OFFSET FLAT:DefaultDir
	mov	QWORD PTR [rdx+rcx*8], rax

; 305  :             strcpy( DefaultDir[type], token );

	movsxd	rax, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	mov	rdx, QWORD PTR token$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	strcpy
$LN3@get_fname:

; 306  :         }
; 307  :         return;

	jmp	$LN1@get_fname
$LN2@get_fname:

; 308  :     }
; 309  :     /* v2.10: ensure type is < NUM_FILE_TYPES */
; 310  :     //if ( drive[0] == NULLC && dir[0] == NULLC && type < NUM_FILE_TYPES && DefaultDir[type] ) {
; 311  :     name[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	QWORD PTR $T4[rsp], rax
	cmp	QWORD PTR $T4[rsp], 260			; 00000104H
	jae	SHORT $LN8@get_fname
	jmp	SHORT $LN9@get_fname
$LN8@get_fname:
	call	__report_rangecheckfailure
$LN9@get_fname:
	mov	rax, QWORD PTR $T4[rsp]
	mov	BYTE PTR name$[rsp+rax], 0

; 312  :     if ( pName == token && type < NUM_FILE_TYPES && DefaultDir[type] ) {

	mov	rax, QWORD PTR token$[rsp]
	cmp	QWORD PTR pName$[rsp], rax
	jne	SHORT $LN5@get_fname
	cmp	DWORD PTR type$[rsp], 4
	jge	SHORT $LN5@get_fname
	movsxd	rax, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN5@get_fname

; 313  :         DebugMsg(("get_fname: default drive+dir used: %s\n" ));

	lea	rcx, OFFSET FLAT:$SG11139
	call	DoDebugMsg

; 314  :         //_splitpath( DefaultDir[type], drive, dir, NULL, NULL );
; 315  :         strcpy( name, DefaultDir[type] );

	movsxd	rax, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR name$[rsp]
	call	strcpy
$LN5@get_fname:

; 316  :     }
; 317  :     strcat( name, token );

	mov	rdx, QWORD PTR token$[rsp]
	lea	rcx, QWORD PTR name$[rsp]
	call	strcat

; 318  : #if 0 /* v2.12: extension will be set in SetFileNames() */
; 319  :     if( type && type < NUM_FILE_TYPES ) {
; 320  :         char *pExt = GetExtPart( name );
; 321  :         if ( *pExt == NULLC ) {
; 322  :             *pExt++ = '.';
; 323  :             strcpy( pExt, DefaultExt[type-1] );
; 324  :         }
; 325  :     }
; 326  : #endif
; 327  :     //_makepath( name, drive, dir, fname, pExt );
; 328  :     if( Options.names[type] != NULL ) {

	movsxd	rax, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN6@get_fname

; 329  :         MemFree( Options.names[type] );

	movsxd	rax, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	MemFree
$LN6@get_fname:

; 330  :     }
; 331  :     Options.names[type] = MemAlloc( strlen( name ) + 1 );

	lea	rcx, QWORD PTR name$[rsp]
	call	strlen
	inc	rax
	mov	rcx, rax
	call	MemAlloc
	movsxd	rcx, DWORD PTR type$[rsp]
	lea	rdx, OFFSET FLAT:Options+32
	mov	QWORD PTR [rdx+rcx*8], rax

; 332  :     strcpy( Options.names[type], name );

	movsxd	rax, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	lea	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	strcpy
$LN1@get_fname:
$LN7@get_fname:

; 333  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:get_fname$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 368				; 00000170H
	pop	rdi
	ret	0
get_fname ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
p$ = 32
q$ = 40
i$ = 64
string$ = 72
queue_item PROC

; 263  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+64]

; 264  :     struct qitem *p;
; 265  :     struct qitem *q;
; 266  : 
; 267  :     DebugMsg(("queue_item(%u, %s) enter\n", i, string));

	mov	r8, QWORD PTR string$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11120
	call	DoDebugMsg

; 268  :     p = MemAlloc( sizeof(struct qitem) + strlen( string ) );

	mov	rcx, QWORD PTR string$[rsp]
	call	strlen
	add	rax, 16
	mov	rcx, rax
	call	MemAlloc
	mov	QWORD PTR p$[rsp], rax

; 269  :     p->next = NULL;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], 0

; 270  :     strcpy( p->value, string );

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 8
	mov	rdx, QWORD PTR string$[rsp]
	mov	rcx, rax
	call	strcpy

; 271  :     q = Options.queues[i];

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+104
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR q$[rsp], rax

; 272  :     if ( q ) {

	cmp	QWORD PTR q$[rsp], 0
	je	SHORT $LN5@queue_item
	jmp	SHORT $LN4@queue_item
$LN2@queue_item:

; 273  :         for ( ; q->next; q = q->next );

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$[rsp], rax
$LN4@queue_item:
	mov	rax, QWORD PTR q$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@queue_item
	jmp	SHORT $LN2@queue_item
$LN3@queue_item:

; 274  :         q->next = p;

	mov	rax, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 275  :     } else

	jmp	SHORT $LN6@queue_item
$LN5@queue_item:

; 276  :         Options.queues[i] = p;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+104
	mov	rdx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx
$LN6@queue_item:

; 277  :     return;
; 278  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
queue_item ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
value$ = 48
parm$ = 56
SetCpuCmdline PROC

; 227  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 228  : 
; 229  :     Options.cpu &= ~(P_CPU_MASK | P_EXT_MASK | P_PM);

	mov	eax, DWORD PTR Options+180
	and	eax, -65529				; ffffffffffff0007H
	mov	DWORD PTR Options+180, eax

; 230  :     Options.cpu |= value;

	mov	eax, DWORD PTR value$[rsp]
	mov	ecx, DWORD PTR Options+180
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR Options+180, eax

; 231  : 
; 232  :     for( ; *parm ; parm++ ) {

	jmp	SHORT $LN4@SetCpuCmdl
$LN2@SetCpuCmdl:
	mov	rax, QWORD PTR parm$[rsp]
	inc	rax
	mov	QWORD PTR parm$[rsp], rax
$LN4@SetCpuCmdl:
	mov	rax, QWORD PTR parm$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@SetCpuCmdl

; 233  :         if( *parm == 'p' && Options.cpu >= P_286 ) {

	mov	rax, QWORD PTR parm$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 112				; 00000070H
	jne	SHORT $LN5@SetCpuCmdl
	cmp	DWORD PTR Options+180, 32		; 00000020H
	jl	SHORT $LN5@SetCpuCmdl

; 234  :             Options.cpu |= P_PM;      /* set privileged mode */

	mov	eax, DWORD PTR Options+180
	or	eax, 8
	mov	DWORD PTR Options+180, eax

; 235  : #if MANGLERSUPP
; 236  :         } else if( *parm == '"' ) {       /* set default mangler */
; 237  :             char *dest;
; 238  :             parm++;
; 239  :             dest = strchr( parm, '"' );
; 240  :             if( Options.names[OPTN_DEFNAME_MANGLER] != NULL ) {
; 241  :                 MemFree( Options.names[OPTN_DEFNAME_MANGLER );
; 242  :             }
; 243  :             Options.names[OPTN_DEFNAME_MANGLER = MemAlloc( dest - parm + 1 );
; 244  :             dest = Options.names[OPTN_DEFNAME_MANGLER];
; 245  :             for( ; *parm != '"'; dest++, parm++ ) {
; 246  :                 *dest = *parm;
; 247  :             }
; 248  :             *dest = NULLC;
; 249  : #endif
; 250  :         } else {

	jmp	SHORT $LN6@SetCpuCmdl
$LN5@SetCpuCmdl:

; 251  :             EmitWarn( 1, CPU_OPTION_INVALID, parm );

	mov	r8, QWORD PTR parm$[rsp]
	mov	edx, 134				; 00000086H
	mov	ecx, 1
	call	EmitWarn

; 252  :             break;

	jmp	SHORT $LN3@SetCpuCmdl
$LN6@SetCpuCmdl:

; 253  :         }
; 254  :     }

	jmp	SHORT $LN2@SetCpuCmdl
$LN3@SetCpuCmdl:

; 255  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
SetCpuCmdline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
i$ = 32
p$1 = 40
q$2 = 48
CmdlineFini PROC

; 1064 : {

$LN17:
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1065 :     int i;
; 1066 :     DebugMsg(("CmdLineFini enter\n" ));

	lea	rcx, OFFSET FLAT:$SG11628
	call	DoDebugMsg

; 1067 :     for ( i = 0; i < NUM_FILE_TYPES; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@CmdlineFin
$LN2@CmdlineFin:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@CmdlineFin:
	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN3@CmdlineFin

; 1068 :         if ( DefaultDir[i] != NULL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN14@CmdlineFin

; 1069 :             MemFree( DefaultDir[i] );

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	MemFree

; 1070 :             DefaultDir[i] = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:DefaultDir
	mov	QWORD PTR [rcx+rax*8], 0
$LN14@CmdlineFin:

; 1071 :         }
; 1072 :     }

	jmp	SHORT $LN2@CmdlineFin
$LN3@CmdlineFin:

; 1073 :     for ( i = 0; i < OPTN_LAST; i++ )

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@CmdlineFin
$LN5@CmdlineFin:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@CmdlineFin:
	cmp	DWORD PTR i$[rsp], 9
	jge	SHORT $LN6@CmdlineFin

; 1074 :         if ( Options.names[i] != NULL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN15@CmdlineFin

; 1075 :             MemFree( Options.names[i] );

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	MemFree

; 1076 :             Options.names[i] = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	mov	QWORD PTR [rcx+rax*8], 0
$LN15@CmdlineFin:

; 1077 :         }

	jmp	SHORT $LN5@CmdlineFin
$LN6@CmdlineFin:

; 1078 :     for ( i = 0; i < OPTQ_LAST; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN10@CmdlineFin
$LN8@CmdlineFin:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@CmdlineFin:
	cmp	DWORD PTR i$[rsp], 3
	jge	SHORT $LN9@CmdlineFin

; 1079 :         struct qitem *p;
; 1080 :         struct qitem *q;
; 1081 :         for ( q = Options.queues[i]; q; ) {

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+104
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR q$2[rsp], rax
$LN11@CmdlineFin:
	cmp	QWORD PTR q$2[rsp], 0
	je	SHORT $LN12@CmdlineFin

; 1082 :             p = q->next;

	mov	rax, QWORD PTR q$2[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$1[rsp], rax

; 1083 :             MemFree( q );

	mov	rcx, QWORD PTR q$2[rsp]
	call	MemFree

; 1084 :             q = p;

	mov	rax, QWORD PTR p$1[rsp]
	mov	QWORD PTR q$2[rsp], rax

; 1085 :         }

	jmp	SHORT $LN11@CmdlineFin
$LN12@CmdlineFin:

; 1086 :         Options.queues[i] = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+104
	mov	QWORD PTR [rcx+rax*8], 0

; 1087 :     }

	jmp	SHORT $LN8@CmdlineFin
$LN9@CmdlineFin:

; 1088 :     DebugMsg(("CmdLineFini exit\n" ));

	lea	rcx, OFFSET FLAT:$SG11631
	call	DoDebugMsg

; 1089 :     return;
; 1090 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
CmdlineFini ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
_TEXT	SEGMENT
i$ = 32
str$ = 40
paramfile$ = 64
len$4 = 340
tv79 = 352
tv175 = 360
__$ArrayPad$ = 368
cmdline$ = 400
pCntArgs$ = 408
ParseCmdline PROC

; 967  : {

$LN29:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 384				; 00000180H
	mov	rdi, rsp
	mov	ecx, 96					; 00000060H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+400]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 968  :     int i;
; 969  :     const char *str = *cmdline;

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR str$[rsp], rax

; 970  :     char paramfile[FILENAME_MAX];
; 971  : 
; 972  :     for ( i = 0; i < NUM_FILE_TYPES; i++ )

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@ParseCmdli
$LN2@ParseCmdli:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@ParseCmdli:
	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN3@ParseCmdli

; 973  :         if ( Options.names[i] != NULL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN10@ParseCmdli

; 974  :             MemFree( Options.names[i] );

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	MemFree

; 975  :             Options.names[i] = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:Options+32
	mov	QWORD PTR [rcx+rax*8], 0
$LN10@ParseCmdli:

; 976  :         }

	jmp	SHORT $LN2@ParseCmdli
$LN3@ParseCmdli:
$LN5@ParseCmdli:

; 977  : 
; 978  :     /* enable next line if debug log is to be active, but -dt cannot be set */
; 979  :     //Set_dt();
; 980  : 
; 981  :     for( ; str; ) {

	cmp	QWORD PTR str$[rsp], 0
	je	$LN6@ParseCmdli

; 982  :         switch( *str ) {

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv79[rsp], eax
	cmp	DWORD PTR tv79[rsp], 64			; 00000040H
	ja	$LN21@ParseCmdli
	movsxd	rax, DWORD PTR tv79[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN27@ParseCmdli[rcx+rax]
	mov	eax, DWORD PTR $LN28@ParseCmdli[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN11@ParseCmdli:

; 983  :         case ' ':
; 984  :         case '\t':
; 985  :             str++;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 986  :             break;

	jmp	$LN8@ParseCmdli
$LN12@ParseCmdli:

; 987  :         case NULLC:
; 988  :             str = getnextcmdstring( cmdline );

	mov	rcx, QWORD PTR cmdline$[rsp]
	call	getnextcmdstring
	mov	QWORD PTR str$[rsp], rax

; 989  :             break;

	jmp	$LN8@ParseCmdli
$LN13@ParseCmdli:

; 990  :         case '-':
; 991  : #if SWITCHCHAR
; 992  :         case '/':
; 993  : #endif
; 994  :             str++;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 995  :             *cmdline = str;

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	mov	QWORD PTR [rax], rcx

; 996  :             ProcessOption( cmdline, paramfile );

	lea	rdx, QWORD PTR paramfile$[rsp]
	mov	rcx, QWORD PTR cmdline$[rsp]
	call	ProcessOption

; 997  :             (*pCntArgs)++;

	mov	rax, QWORD PTR pCntArgs$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR pCntArgs$[rsp]
	mov	DWORD PTR [rcx], eax

; 998  :             str = *cmdline;

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR str$[rsp], rax

; 999  :             break;

	jmp	$LN8@ParseCmdli
$LN14@ParseCmdli:

; 1000 :         case '@':
; 1001 :             if ( rspidx >= MAX_RSP_NESTING ) {

	cmp	DWORD PTR rspidx, 15
	jl	SHORT $LN15@ParseCmdli

; 1002 :                 EmitErr( NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 100				; 00000064H
	call	EmitErr

; 1003 :                 *cmdline = "";

	mov	rax, QWORD PTR cmdline$[rsp]
	lea	rcx, OFFSET FLAT:$SG11595
	mov	QWORD PTR [rax], rcx

; 1004 :                 return( NULL );

	xor	eax, eax
	jmp	$LN1@ParseCmdli
$LN15@ParseCmdli:

; 1005 :             }
; 1006 :             str++;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 1007 : #if 1 /* v2.06: was '0' in v2.05, now '1' again since it didn't work with quoted names */
; 1008 :             /* todo: might be unnecessary since v.2.10, since GetNameToken() handles spaces inside filenames differently */
; 1009 :             if ( rspidx ) {

	cmp	DWORD PTR rspidx, 0
	je	SHORT $LN16@ParseCmdli

; 1010 :                 cmdsave[rspidx] = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );

	mov	r9b, 64					; 00000040H
	mov	r8d, 259				; 00000103H
	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR paramfile$[rsp]
	call	GetNameToken
	movsxd	rcx, DWORD PTR rspidx
	lea	rdx, OFFSET FLAT:cmdsave
	mov	QWORD PTR [rdx+rcx*8], rax

; 1011 :             } else {

	jmp	SHORT $LN17@ParseCmdli
$LN16@ParseCmdli:

; 1012 :                 strcpy( paramfile, str ); /* fixme: no overflow check */

	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR paramfile$[rsp]
	call	strcpy

; 1013 :                 cmdsave[rspidx] = str + strlen(str);

	mov	rcx, QWORD PTR str$[rsp]
	call	strlen
	mov	rcx, QWORD PTR str$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR rspidx
	lea	rdx, OFFSET FLAT:cmdsave
	mov	QWORD PTR [rdx+rcx*8], rax
$LN17@ParseCmdli:

; 1014 :             }
; 1015 : #else
; 1016 :             cmdsave[rspidx] = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );
; 1017 : #endif
; 1018 :             cmdbuffers[rspidx] = NULL;

	movsxd	rax, DWORD PTR rspidx
	lea	rcx, OFFSET FLAT:cmdbuffers
	mov	QWORD PTR [rcx+rax*8], 0

; 1019 :             str = NULL;

	mov	QWORD PTR str$[rsp], 0

; 1020 :             if ( paramfile[0] )

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR paramfile$[rsp+rax]
	test	eax, eax
	je	SHORT $LN18@ParseCmdli

; 1021 :                 str = getenv( paramfile );

	lea	rcx, QWORD PTR paramfile$[rsp]
	call	QWORD PTR __imp_getenv
	mov	QWORD PTR str$[rsp], rax
$LN18@ParseCmdli:

; 1022 :             if( str == NULL ) {

	cmp	QWORD PTR str$[rsp], 0
	jne	SHORT $LN19@ParseCmdli

; 1023 :                 str = ReadParamFile( paramfile );

	lea	rcx, QWORD PTR paramfile$[rsp]
	call	ReadParamFile
	mov	QWORD PTR str$[rsp], rax

; 1024 :                 cmdbuffers[rspidx] = str;

	movsxd	rax, DWORD PTR rspidx
	lea	rcx, OFFSET FLAT:cmdbuffers
	mov	rdx, QWORD PTR str$[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 1025 :                 if ( str == NULL ) {

	cmp	QWORD PTR str$[rsp], 0
	jne	SHORT $LN20@ParseCmdli

; 1026 :                     str = cmdsave[rspidx];

	movsxd	rax, DWORD PTR rspidx
	lea	rcx, OFFSET FLAT:cmdsave
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR str$[rsp], rax

; 1027 :                     break;

	jmp	$LN8@ParseCmdli
$LN20@ParseCmdli:
$LN19@ParseCmdli:

; 1028 :                 }
; 1029 :             }
; 1030 :             rspidx++;

	mov	eax, DWORD PTR rspidx
	inc	eax
	mov	DWORD PTR rspidx, eax

; 1031 :             break;

	jmp	$LN8@ParseCmdli
$LN21@ParseCmdli:

; 1032 :         default: /* collect  file name */
; 1033 : #if BUILD_TARGET
; 1034 :             set_default_build_target();
; 1035 : #endif
; 1036 : #if 1 /* v2.06: activated (was removed in v2.05). Needed for quoted filenames */
; 1037 :             if ( rspidx ) {

	cmp	DWORD PTR rspidx, 0
	je	SHORT $LN22@ParseCmdli

; 1038 :                 str = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );

	mov	r9b, 64					; 00000040H
	mov	r8d, 259				; 00000103H
	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR paramfile$[rsp]
	call	GetNameToken
	mov	QWORD PTR str$[rsp], rax

; 1039 :                 get_fname( OPTN_ASM_FN, paramfile );

	lea	rdx, QWORD PTR paramfile$[rsp]
	xor	ecx, ecx
	call	get_fname

; 1040 :             } else {

	jmp	SHORT $LN23@ParseCmdli
$LN22@ParseCmdli:

; 1041 :                 int len;
; 1042 :                 len = strlen( str );

	mov	rcx, QWORD PTR str$[rsp]
	call	strlen
	mov	DWORD PTR len$4[rsp], eax

; 1043 :                 get_fname( OPTN_ASM_FN, str );

	mov	rdx, QWORD PTR str$[rsp]
	xor	ecx, ecx
	call	get_fname

; 1044 :                 str += len;

	movsxd	rax, DWORD PTR len$4[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR str$[rsp], rax
$LN23@ParseCmdli:

; 1045 :             }
; 1046 : #else
; 1047 :             str = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );
; 1048 :             Options.names[ASM] = MemAlloc( strlen( paramfile ) + 1 );
; 1049 :             strcpy( Options.names[ASM], paramfile );
; 1050 : #endif
; 1051 :             DebugMsg(("ParseCmdLine: file=>%s< rest=>%s<\n", Options.names[ASM], str ? str : "NULL" ));

	cmp	QWORD PTR str$[rsp], 0
	je	SHORT $LN25@ParseCmdli
	mov	rax, QWORD PTR str$[rsp]
	mov	QWORD PTR tv175[rsp], rax
	jmp	SHORT $LN26@ParseCmdli
$LN25@ParseCmdli:
	lea	rax, OFFSET FLAT:$SG11604
	mov	QWORD PTR tv175[rsp], rax
$LN26@ParseCmdli:
	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:Options+32
	mov	r8, QWORD PTR tv175[rsp]
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG11605
	call	DoDebugMsg

; 1052 :             (*pCntArgs)++;

	mov	rax, QWORD PTR pCntArgs$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR pCntArgs$[rsp]
	mov	DWORD PTR [rcx], eax

; 1053 :             *cmdline = str;

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	mov	QWORD PTR [rax], rcx

; 1054 :             return( Options.names[ASM] );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:Options+32
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@ParseCmdli
$LN8@ParseCmdli:

; 1055 :         }
; 1056 :     }

	jmp	$LN5@ParseCmdli
$LN6@ParseCmdli:

; 1057 :     *cmdline = str;

	mov	rax, QWORD PTR cmdline$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	mov	QWORD PTR [rax], rcx

; 1058 :     return( NULL );

	xor	eax, eax
$LN1@ParseCmdli:

; 1059 : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:ParseCmdline$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 384				; 00000180H
	pop	rdi
	ret	0
	npad	3
$LN28@ParseCmdli:
	DD	$LN12@ParseCmdli
	DD	$LN11@ParseCmdli
	DD	$LN13@ParseCmdli
	DD	$LN14@ParseCmdli
	DD	$LN21@ParseCmdli
$LN27@ParseCmdli:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
ParseCmdline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Format$ = 96
printf	PROC						; COMDAT

; 950  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 957  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:printf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
	push	rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	rdi
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
