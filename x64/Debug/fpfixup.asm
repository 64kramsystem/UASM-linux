; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG10617 DB	'F__RQQ', 00H
	ORG $+9
$SG10618 DB	'AddFloatingPointEmulationFixup enter, token=%u, regoverr'
	DB	'ide=%d', 0aH, 00H
_DATA	ENDS
CONST	SEGMENT
patchmask DW	0f8ffH
	ORG $+6
patchchr2 DB	057H
	DB	044H
	DB	045H
	DB	043H
	DB	053H
	DB	041H
	DB	046H
	DB	047H
CONST	ENDS
PUBLIC	AddFloatingPointEmulationFixup
EXTRN	DoDebugMsg:PROC
EXTRN	SymFind:PROC
EXTRN	MakeExtern:PROC
EXTRN	CreateFixup:PROC
EXTRN	store_fixup:PROC
EXTRN	omf_FlushCurrSeg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	write_to_file:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$AddFloatingPointEmulationFixup DD imagerel $LN19
	DD	imagerel $LN19+636
	DD	imagerel $unwind$AddFloatingPointEmulationFixup
pdata	ENDS
xdata	SEGMENT
$unwind$AddFloatingPointEmulationFixup DD 031a19H
	DD	07007e20bH
	DD	06006H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\fpfixup.c
_TEXT	SEGMENT
i$ = 48
patch$ = 52
fixup$ = 56
sym$ = 64
data$ = 80
name$ = 88
__$ArrayPad$ = 96
CodeInfo$ = 144
AddFloatingPointEmulationFixup PROC

; 68   : {

$LN19:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 69   :     int i;
; 70   :     enum fp_patches patch;
; 71   :     struct asym *sym[2];
; 72   :     struct fixup *fixup;
; 73   :     int_32 data;
; 74   :     char name[8] = "F__RQQ";

	lea	rax, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG10617
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 7
	rep movsb
	lea	rax, QWORD PTR name$[rsp+7]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb

; 75   : 
; 76   :     DebugMsg(("AddFloatingPointEmulationFixup enter, token=%u, regoverride=%d\n", CodeInfo->token, CodeInfo->prefix.RegOverride ));

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	r8d, DWORD PTR [rax+4]
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rax+24]
	lea	rcx, OFFSET FLAT:$SG10618
	call	DoDebugMsg

; 77   : 
; 78   :     if( CodeInfo->token == T_FWAIT ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 833			; 00000341H
	jne	SHORT $LN8@AddFloatin

; 79   :         patch = FPP_WAIT;

	mov	DWORD PTR patch$[rsp], 0
	jmp	SHORT $LN9@AddFloatin
$LN8@AddFloatin:

; 80   :     } else if ( CodeInfo->prefix.RegOverride == EMPTY ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+4], -2
	jne	SHORT $LN10@AddFloatin

; 81   :         patch = FPP_NORMAL;

	mov	DWORD PTR patch$[rsp], 1

; 82   :     } else {

	jmp	SHORT $LN11@AddFloatin
$LN10@AddFloatin:

; 83   :         patch = CodeInfo->prefix.RegOverride + 2;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+4]
	add	eax, 2
	mov	DWORD PTR patch$[rsp], eax
$LN11@AddFloatin:
$LN9@AddFloatin:

; 84   :     }
; 85   : 
; 86   :     /* emit 1-2 externals for the patch if not done already */
; 87   :     for ( i = 0; i < 2; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@AddFloatin
$LN2@AddFloatin:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@AddFloatin:
	cmp	DWORD PTR i$[rsp], 2
	jge	$LN3@AddFloatin

; 88   :         sym[i] = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	QWORD PTR sym$[rsp+rax*8], 0

; 89   :         if ( patchmask & ( 1 << ( i*8+patch ) ) ) {

	movzx	eax, WORD PTR patchmask
	mov	ecx, DWORD PTR patch$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	ecx, DWORD PTR [rcx+rdx*8]
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	and	eax, ecx
	test	eax, eax
	je	$LN12@AddFloatin

; 90   :             name[1] = 'I' + i;

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 73					; 00000049H
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	BYTE PTR name$[rsp+rcx], al

; 91   :             name[2] = patchchr2[patch];

	movsxd	rax, DWORD PTR patch$[rsp]
	lea	rcx, OFFSET FLAT:patchchr2
	mov	edx, 1
	imul	rdx, rdx, 2
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR name$[rsp+rdx], al

; 92   :             sym[i] = SymSearch( name );

	lea	rcx, QWORD PTR name$[rsp]
	call	SymFind
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	QWORD PTR sym$[rsp+rcx*8], rax

; 93   :             if( sym[i] == NULL || sym[i]->state == SYM_UNDEFINED ) {

	movsxd	rax, DWORD PTR i$[rsp]
	cmp	QWORD PTR sym$[rsp+rax*8], 0
	je	SHORT $LN14@AddFloatin
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR sym$[rsp+rax*8]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN13@AddFloatin
$LN14@AddFloatin:

; 94   :                 sym[i] = MakeExtern( name, MT_FAR, NULL, sym[i], USE16 );

	movsxd	rax, DWORD PTR i$[rsp]
	mov	BYTE PTR [rsp+32], 0
	mov	r9, QWORD PTR sym$[rsp+rax*8]
	xor	r8d, r8d
	mov	edx, 130				; 00000082H
	lea	rcx, QWORD PTR name$[rsp]
	call	MakeExtern
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	QWORD PTR sym$[rsp+rcx*8], rax

; 95   :                 sym[i]->langtype = LANG_NONE;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR sym$[rsp+rax*8]
	mov	DWORD PTR [rax+84], 0
$LN13@AddFloatin:
$LN12@AddFloatin:

; 96   :             }
; 97   :         }
; 98   :     }

	jmp	$LN2@AddFloatin
$LN3@AddFloatin:

; 99   : 
; 100  :     /* no need for fixups if no object file is written */
; 101  :     if ( write_to_file == FALSE )

	movzx	eax, BYTE PTR write_to_file
	test	eax, eax
	jne	SHORT $LN15@AddFloatin

; 102  :         return;

	jmp	$LN1@AddFloatin
$LN15@AddFloatin:

; 103  : 
; 104  :     /* make sure the next 3 bytes in code stream aren't separated.
; 105  :      * The first fixup covers bytes $+0 and $+1, the (possible) second
; 106  :      * fixup covers bytes $+1 and $+2.
; 107  :      */
; 108  :     if( Options.output_format == OFORMAT_OMF &&

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN16@AddFloatin
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+104]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	add	eax, 3
	cmp	eax, 1014				; 000003f6H
	jbe	SHORT $LN16@AddFloatin

; 109  :        ( CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc + 3 ) > MAX_LEDATA_THRESHOLD )
; 110  :         omf_FlushCurrSeg();

	call	omf_FlushCurrSeg
$LN16@AddFloatin:

; 111  : 
; 112  :     for ( i = 0; i < 2 ; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@AddFloatin
$LN5@AddFloatin:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@AddFloatin:
	cmp	DWORD PTR i$[rsp], 2
	jge	SHORT $LN6@AddFloatin

; 113  :         if ( sym[i] ) {

	movsxd	rax, DWORD PTR i$[rsp]
	cmp	QWORD PTR sym$[rsp+rax*8], 0
	je	SHORT $LN17@AddFloatin

; 114  :             fixup = CreateFixup( sym[i], FIX_OFF16, OPTJ_NONE );

	movsxd	rax, DWORD PTR i$[rsp]
	xor	r8d, r8d
	mov	edx, 5
	mov	rcx, QWORD PTR sym$[rsp+rax*8]
	call	CreateFixup
	mov	QWORD PTR fixup$[rsp], rax

; 115  :             fixup->frame_type = FRAME_TARG;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	BYTE PTR [rax+40], 5

; 116  :             /* assume locofs has been set inside CreateFixup() */
; 117  :             //fixup->locofs = CurrSeg->e.seginfo->current_loc + i;
; 118  :             fixup->locofs += i;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+20]
	add	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	DWORD PTR [rcx+20], eax

; 119  :             data = 0;

	mov	DWORD PTR data$[rsp], 0

; 120  :             store_fixup( fixup, CurrSeg, &data );

	lea	r8, QWORD PTR data$[rsp]
	mov	rdx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR fixup$[rsp]
	call	store_fixup
$LN17@AddFloatin:

; 121  :         }
; 122  :     }

	jmp	SHORT $LN5@AddFloatin
$LN6@AddFloatin:
$LN1@AddFloatin:

; 123  :     return;
; 124  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	pop	rdi
	pop	rsi
	ret	0
AddFloatingPointEmulationFixup ENDP
_TEXT	ENDS
END
