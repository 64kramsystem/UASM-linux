; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG11378 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
COMM	MacroLevel:BYTE
COMM	MacroLocals:DWORD
_DATA	ENDS
_BSS	SEGMENT
$SG11145 DB	01H DUP (?)
$SG11231 DB	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
__digits DB	'0123456789ABCDEF'
CONST	ENDS
_DATA	SEGMENT
$SG11267 DB	'NULL', 00H
	ORG $+3
$SG11268 DB	'RunMacro(%s): EXITM, result=>%s<', 0aH, 00H
	ORG $+6
$SG11273 DB	'RunMacro(%s): GOTO %s, MacroLevel=%u', 0aH, 00H
	ORG $+2
$SG11276 DB	'RunMacro(%s): GOTO, line=>%s<', 0aH, 00H
	ORG $+1
$SG11280 DB	'RunMacro(%s): GOTO, label >%s< not found!', 0aH, 00H
	ORG $+5
$SG11281 DB	'RunMacro(%s): GOTO, found label >%s<', 0aH, 00H
	ORG $+2
$SG11284 DB	'RunMacro(%s) exit, MacroLevel=%u', 0aH, 00H
	ORG $+6
$SG11346 DB	'ExpandText(line=>%s<, subst=%u ) enter', 0aH, 00H
$SG11353 DB	'SYM_TMACRO', 00H
	ORG $+5
$SG11354 DB	'SYM_MACRO', 00H
	ORG $+6
$SG11355 DB	'ExpandText: symbol found: %s, %s, defined=%u, *pDst-1=%c'
	DB	0aH, 00H
	ORG $+6
$SG11365 DB	'ExpandText: %s replaced by >%s<', 0aH, 00H
	ORG $+7
$SG11384 DB	'ExpandText(line=>%s<) error exit', 0aH, 00H
	ORG $+6
$SG11379 DB	'ExpandText: back from RunMacro(%s), rc=%u, text returned'
	DB	'=>%s<, rest=>%s<', 0aH, 00H
	ORG $+6
$SG11391 DB	'ExpandText: expanded line=>%s<', 0aH, 00H
$SG11419 DB	'ExpandTMacro(text=>%s< equm=%u lvl=%u) enter', 0aH, 00H
	ORG $+2
$SG11425 DB	'ExpandTMacro(%u): repl >%s()< by >%s<', 0aH, 00H
	ORG $+1
$SG11427 DB	'ExpandTMacro(>%s<, %u): calling ExpandTMacro, value >%s<'
	DB	0aH, 00H
	ORG $+6
$SG11429 DB	'ExpandTMacro(%u): repl >%s< by >%s<', 0aH, 00H
	ORG $+3
$SG11505 DB	'LOCAL', 00H
	ORG $+2
$SG11507 DB	'ExpandToken: %% found, line=%s', 0aH, 00H
$SG11511 DB	'ExpandToken: testing id >%s< equmode=%u', 0aH, 00H
	ORG $+7
$SG11518 DB	'ExpandToken(%s): macro function without () - not expande'
	DB	'd!', 0aH, 00H
	ORG $+4
$SG11525 DB	'ExpandToken(%s, addbr=%u): macro function expanded to >%'
	DB	's<', 0aH, 00H
	ORG $+4
$SG11533 DB	'ExpandToken(%s): macro proc at pos %u NOT expanded', 0aH
	DB	00H
	ORG $+4
$SG11536 DB	'ExpandToken(%s): macro proc to be expanded', 0aH, 00H
	ORG $+4
$SG11537 DB	'ExpandToken(%s): macro proc called', 0aH, 00H
	ORG $+4
$SG11541 DB	'ExpandToken(%s, addbr=%u): value >%s< expanded to >%s<', 0aH
	DB	00H
$SG11543 DB	'ExpandToken(%s): rest after expansion: %s', 0aH, 00H
	ORG $+5
$SG11550 DB	'ExpandToken: ''constant expected'' error', 0aH, 00H
$SG11551 DB	'ExpandToken: curr pos=%u, start expr=%u, expr size=%d', 0aH
	DB	00H
	ORG $+1
$SG11620 DB	'ExpandLine(>%s<) enter', 0aH, 00H
$SG11657 DB	'ExpandLine(%s): expansion occured, retokenize', 0aH, 00H
	ORG $+1
$SG11659 DB	'ExpandLine(>%s<) exit, rc=%u, token_count=%u', 0aH, 00H
	ORG $+2
$SG10990 DB	'myltoa( value=%Xh, out=%s, radix=%u, sign=%u, %u)', 0aH, 00H
	ORG $+5
$SG11013 DB	'myltoa( value=%Xh, out=%s, radix=%u, sign=%u, %u)', 0aH, 00H
	ORG $+5
$SG11129 DB	'RunMacro(%s, idx=%u src=>%s< ) enter, lvl=%u, locals=%04'
	DB	'u', 0aH, 00H
	ORG $+5
$SG11139 DB	'RunMacro(%s) exit, macro is purged', 0aH, 00H
	ORG $+4
$SG11140 DB	'RunMacro(%s): params=>%s< parmcnt=%u vararg=%u', 0aH, 00H
$SG11152 DB	'RunMacro(%s.%u), parameter %u required >%s<', 0aH, 00H
	ORG $+3
$SG11156 DB	'NULL', 00H
	ORG $+3
$SG11157 DB	'RunMacro(%s.%u): curr (=def) parameter value=>%s<', 0aH, 00H
	ORG $+5
$SG11158 DB	'RunMacro(%s.%u), >%s<', 0aH, 00H
	ORG $+1
$SG11186 DB	'RunMacro(%s.%u), num expansion: >%s<', 0aH, 00H
	ORG $+2
$SG11190 DB	'RunMacro(%s.%u): num expansion, opndx.type=%d, value=%d', 0aH
	DB	00H
	ORG $+7
$SG11192 DB	'RunMacro(%s.%u): num expansion, additional token=%s', 0aH
	DB	00H
	ORG $+3
$SG11193 DB	'expans.c', 00H
	ORG $+7
$SG11209 DB	'expans.c', 00H
	ORG $+7
$SG11212 DB	'expans.c', 00H
	ORG $+7
$SG11216 DB	'RunMacro(%s.%u): undelimited string >%s<, watching ''!'''
	DB	0aH, 00H
$SG11217 DB	'expans.c', 00H
	ORG $+7
$SG11219 DB	'expans.c', 00H
	ORG $+7
$SG11223 DB	'RunMacro(%s.%u[%u]): curr parameter value=>%s<', 0aH, 00H
$SG11230 DB	'RunMacro(%s.%u): curr parameter value=>%s<', 0aH, 00H
	ORG $+4
$SG11232 DB	'RunMacro(%s.%u): curr parameter value=><', 0aH, 00H
	ORG $+6
$SG11238 DB	'RunMacro(%s): missing '')''', 0aH, 00H
	ORG $+5
$SG11239 DB	'RunMacro(%s): expected '')'', found >%s<', 0aH, 00H
$SG11241 DB	'RunMacro(%s): expected T_FINAL, found >%s<, parmidx=%u', 0aH
	DB	00H
$SG11245 DB	'RunMacro(%s): enter assembly loop, macro level=%u', 0aH, 00H
_DATA	ENDS
PUBLIC	myltoa
PUBLIC	myqtoa
PUBLIC	RunMacro
PUBLIC	ExpandText
PUBLIC	ExpandLineItems
PUBLIC	ExpandLine
PUBLIC	ExpandLiterals
EXTRN	__report_rangecheckfailure:PROC
EXTRN	isalpha:PROC
EXTRN	isspace:PROC
EXTRN	isalnum:PROC
EXTRN	memcpy:PROC
EXTRN	strchr:PROC
EXTRN	_memicmp:PROC
EXTRN	strcat:PROC
EXTRN	strcpy:PROC
EXTRN	_stricmp:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	SymFind:PROC
EXTRN	SymFindDeclare:PROC
EXTRN	ParseLine:PROC
EXTRN	WritePreprocessedLine:PROC
EXTRN	PreprocessLine:PROC
EXTRN	WriteCodeLabel:PROC
EXTRN	EvalOperand:PROC
EXTRN	GetTextLine:PROC
EXTRN	PushMacro:PROC
EXTRN	SetLineNumber:PROC
EXTRN	PushInputStatus:PROC
EXTRN	PopInputStatus:PROC
EXTRN	Tokenize:PROC
EXTRN	fill_placeholders:PROC
EXTRN	TextItemError:PROC
EXTRN	GetIfNestLevel:PROC
EXTRN	SetIfNestLevel:PROC
EXTRN	LstWriteSrcLine:PROC
EXTRN	InternalError:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$myltoa DD imagerel $LN10
	DD	imagerel $LN10+451
	DD	imagerel $unwind$myltoa
$pdata$myqtoa DD imagerel $LN10
	DD	imagerel $LN10+493
	DD	imagerel $unwind$myqtoa
$pdata$RunMacro DD imagerel $LN189
	DD	imagerel $LN189+8936
	DD	imagerel $unwind$RunMacro
$pdata$ExpandText DD imagerel $LN67
	DD	imagerel $LN67+2285
	DD	imagerel $unwind$ExpandText
$pdata$ExpandLineItems DD imagerel $LN14
	DD	imagerel $LN14+254
	DD	imagerel $unwind$ExpandLineItems
$pdata$ExpandLine DD imagerel $LN59
	DD	imagerel $LN59+1848
	DD	imagerel $unwind$ExpandLine
$pdata$ExpandLiterals DD imagerel $LN10
	DD	imagerel $LN10+245
	DD	imagerel $unwind$ExpandLiterals
$pdata$ExpandTMacro DD imagerel ExpandTMacro
	DD	imagerel ExpandTMacro+1089
	DD	imagerel $unwind$ExpandTMacro
$pdata$SkipMacro DD imagerel SkipMacro
	DD	imagerel SkipMacro+94
	DD	imagerel $unwind$SkipMacro
$pdata$AddTokens DD imagerel AddTokens
	DD	imagerel AddTokens+224
	DD	imagerel $unwind$AddTokens
$pdata$RebuildLine DD imagerel RebuildLine
	DD	imagerel RebuildLine+773
	DD	imagerel $unwind$RebuildLine
$pdata$ExpandToken DD imagerel ExpandToken
	DD	imagerel ExpandToken+2570
	DD	imagerel $unwind$ExpandToken
pdata	ENDS
xdata	SEGMENT
$unwind$myltoa DD 022919H
	DD	011011aH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$myqtoa DD 022d19H
	DD	013011bH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$RunMacro DD 035043119H
	DD	011b3320H
	DD	05014003eH
	DD	imagerel __GSHandlerCheck
	DD	01e0H
$unwind$ExpandText DD 022819H
	DD	02d0116H
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$ExpandLineItems DD 011701H
	DD	08217H
$unwind$ExpandLine DD 010e01H
	DD	0e20eH
$unwind$ExpandLiterals DD 010d01H
	DD	0620dH
$unwind$ExpandTMacro DD 022d19H
	DD	08f011bH
	DD	imagerel __GSHandlerCheck
	DD	0460H
$unwind$SkipMacro DD 021e19H
	DD	087010cH
	DD	imagerel __GSHandlerCheck
	DD	0420H
$unwind$AddTokens DD 031901H
	DD	070152219H
	DD	06014H
$unwind$RebuildLine DD 022c19H
	DD	08b011aH
	DD	imagerel __GSHandlerCheck
	DD	0440H
$unwind$ExpandToken DD 022d19H
	DD	0a1011bH
	DD	imagerel __GSHandlerCheck
	DD	04f0H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
i$ = 48
tmp$ = 52
evaluate$ = 56
inLocal$ = 57
sym$ = 64
is_exitm$ = 72
addbrackets$ = 76
pos$ = 80
rc$ = 84
tv196 = 88
tv286 = 92
old_tokencount$1 = 96
size$ = 100
$T2 = 104
tv322 = 112
opndx$ = 128
buffer$ = 240
__$ArrayPad$ = 1264
line$ = 1296
pi$ = 1304
tokenarray$ = 1312
max$ = 1320
bracket_flags$ = 1328
equmode$ = 1336
ExpandToken PROC

; 1131 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1288				; 00000508H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1132 :     int pos;
; 1133 :     int tmp;
; 1134 :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 1135 :     int size;
; 1136 :     int addbrackets = bracket_flags;

	mov	eax, DWORD PTR bracket_flags$[rsp]
	mov	DWORD PTR addbrackets$[rsp], eax

; 1137 :     char evaluate = FALSE;

	mov	BYTE PTR evaluate$[rsp], 0

; 1138 :     //char *p;
; 1139 :     bool is_exitm;
; 1140 :     struct expr opndx;
; 1141 :     struct asym *sym;
; 1142 :     ret_code rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 1143 :     char buffer[MAX_LINE_LEN];
; 1144 : 	char inLocal = FALSE;

	mov	BYTE PTR inLocal$[rsp], 0

; 1145 : 
; 1146 :     for ( ; i < max && tokenarray[i].token != T_COMMA; i++ ) {

	jmp	SHORT $LN4@ExpandToke
$LN2@ExpandToke:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@ExpandToke:
	mov	eax, DWORD PTR max$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@ExpandToke
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	$LN3@ExpandToke

; 1147 :     
; 1148 : 		if (strcasecmp(tokenarray[i].string_ptr, "LOCAL") == 0)

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG11505
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN8@ExpandToke

; 1149 : 		{
; 1150 : 			inLocal = TRUE;

	mov	BYTE PTR inLocal$[rsp], 1
$LN8@ExpandToke:

; 1151 : 		}
; 1152 : 		/* v2.05: the '%' should only be handled as an operator if addbrackets==TRUE,
; 1153 :          * which means that the current directive is a preprocessor directive and the
; 1154 :          * expected argument is a literal (or text macro).
; 1155 :          */
; 1156 :         if ( tokenarray[i].token == T_PERCENT && addbrackets && evaluate == FALSE ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN9@ExpandToke
	cmp	DWORD PTR addbrackets$[rsp], 0
	je	SHORT $LN9@ExpandToke
	movsx	eax, BYTE PTR evaluate$[rsp]
	test	eax, eax
	jne	SHORT $LN9@ExpandToke

; 1157 :             evaluate = TRUE;

	mov	BYTE PTR evaluate$[rsp], 1

; 1158 :             addbrackets = FALSE;

	mov	DWORD PTR addbrackets$[rsp], 0

; 1159 :             equmode = FALSE;

	mov	DWORD PTR equmode$[rsp], 0

; 1160 :             pos = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR pos$[rsp], eax

; 1161 :             DebugMsg1(("ExpandToken: %% found, line=%s\n", tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11507
	call	DoDebugMsg1

; 1162 :             continue;

	jmp	$LN2@ExpandToke
$LN9@ExpandToke:

; 1163 :         }
; 1164 :         if( tokenarray[i].token == T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN10@ExpandToke

; 1165 : 			if(inLocal == TRUE)

	movsx	eax, BYTE PTR inLocal$[rsp]
	cmp	eax, 1
	jne	SHORT $LN11@ExpandToke

; 1166 : 				sym = SymFindDeclare(tokenarray[i].string_ptr);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFindDeclare
	mov	QWORD PTR sym$[rsp], rax
	jmp	SHORT $LN12@ExpandToke
$LN11@ExpandToke:

; 1167 : 			else
; 1168 : 				sym = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax
$LN12@ExpandToke:

; 1169 :             DebugMsg1(("ExpandToken: testing id >%s< equmode=%u\n", tokenarray[i].string_ptr, equmode ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r8d, DWORD PTR equmode$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11511
	call	DoDebugMsg1

; 1170 :             /* don't check isdefined flag (which cannot occur in pass one, and this code usually runs
; 1171 :              * in pass one only!
; 1172 :              */
; 1173 :             //if( sym && sym->isdefined ) {
; 1174 :             if( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN13@ExpandToke

; 1175 :                 if ( sym->state == SYM_MACRO ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	jne	$LN14@ExpandToke

; 1176 :                     tmp = i; /* save index of macro name */

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR tmp$[rsp], eax

; 1177 :                     if ( sym->isfunc == TRUE ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN16@ExpandToke

; 1178 :                         /* ignore macro functions without a following '(' */
; 1179 :                         if ( tokenarray[i+1].token != T_OP_BRACKET ) {

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN18@ExpandToke

; 1180 :                             DebugMsg1(("ExpandToken(%s): macro function without () - not expanded!\n", sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11518
	call	DoDebugMsg1

; 1181 :                             continue;

	jmp	$LN2@ExpandToke
$LN18@ExpandToke:

; 1182 :                         }
; 1183 :                         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1184 :                         if ( equmode == TRUE ) {

	cmp	DWORD PTR equmode$[rsp], 1
	jne	$LN19@ExpandToke

; 1185 :                             i++; /* skip '(' */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1186 :                             /* go beyond the ')' */
; 1187 :                             for ( tmp = 1; i < max; i++ ) {

	mov	DWORD PTR tmp$[rsp], 1
	jmp	SHORT $LN7@ExpandToke
$LN5@ExpandToke:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@ExpandToke:
	mov	eax, DWORD PTR max$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN6@ExpandToke

; 1188 :                                 if ( tokenarray[i].token == T_OP_BRACKET )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN20@ExpandToke

; 1189 :                                     tmp++;

	mov	eax, DWORD PTR tmp$[rsp]
	inc	eax
	mov	DWORD PTR tmp$[rsp], eax
	jmp	SHORT $LN21@ExpandToke
$LN20@ExpandToke:

; 1190 :                                 else if ( tokenarray[i].token == T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN22@ExpandToke

; 1191 :                                     tmp--;

	mov	eax, DWORD PTR tmp$[rsp]
	dec	eax
	mov	DWORD PTR tmp$[rsp], eax

; 1192 :                                     if ( tmp == 0 )

	cmp	DWORD PTR tmp$[rsp], 0
	jne	SHORT $LN23@ExpandToke

; 1193 :                                         break;

	jmp	SHORT $LN6@ExpandToke
$LN23@ExpandToke:
$LN22@ExpandToke:
$LN21@ExpandToke:

; 1194 :                                 }
; 1195 :                             }

	jmp	SHORT $LN5@ExpandToke
$LN6@ExpandToke:

; 1196 :                             i--;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax

; 1197 :                             continue;

	jmp	$LN2@ExpandToke
$LN19@ExpandToke:

; 1198 :                         }
; 1199 :                         //DebugMsg1(("ExpandToken: macro function %s to be expanded\n", sym->name ));
; 1200 :                         i = RunMacro( (struct dsym *)sym, i, tokenarray, buffer,

	cmp	DWORD PTR tmp$[rsp], 1
	jne	SHORT $LN46@ExpandToke
	mov	DWORD PTR tv196[rsp], 1
	jmp	SHORT $LN47@ExpandToke
$LN46@ExpandToke:
	mov	DWORD PTR tv196[rsp], 0
$LN47@ExpandToke:
	lea	rax, QWORD PTR is_exitm$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv196[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR buffer$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	RunMacro
	mov	DWORD PTR i$[rsp], eax

; 1201 : #if MACROLABEL
; 1202 :                                      (tmp == 1 ? MF_LABEL : 0),
; 1203 : #else
; 1204 :                                      0,
; 1205 : #endif
; 1206 :                                      &is_exitm );
; 1207 :                         if ( i == -1 )

	cmp	DWORD PTR i$[rsp], -1
	jne	SHORT $LN24@ExpandToke

; 1208 :                             return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandToke
$LN24@ExpandToke:

; 1209 :                         DebugMsg1(("ExpandToken(%s, addbr=%u): macro function expanded to >%s<\n", sym->name, addbrackets, buffer));

	lea	r9, QWORD PTR buffer$[rsp]
	mov	r8d, DWORD PTR addbrackets$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11525
	call	DoDebugMsg1

; 1210 :                         /* expand text, but don't if macro was at position 0 (might be a text macro definition directive */
; 1211 :                         /* v2.09: don't expand further if addbrackets is set */
; 1212 :                         if ( tmp && (!addbrackets) && ( ERROR == ExpandTMacro( buffer, tokenarray, equmode, 0 ) ) )

	cmp	DWORD PTR tmp$[rsp], 0
	je	SHORT $LN25@ExpandToke
	cmp	DWORD PTR addbrackets$[rsp], 0
	jne	SHORT $LN25@ExpandToke
	xor	r9d, r9d
	mov	r8d, DWORD PTR equmode$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	ExpandTMacro
	cmp	eax, -1
	jne	SHORT $LN25@ExpandToke

; 1213 :                             return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandToke
$LN25@ExpandToke:

; 1214 :                         /* get size of string to replace ( must be done before AddTokens() */
; 1215 :                         size = ( tokenarray[i-1].tokpos + 1) - tokenarray[tmp].tokpos;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	inc	rax
	movsxd	rcx, DWORD PTR tmp$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	sub	rax, QWORD PTR [rdx+rcx+24]
	mov	DWORD PTR size$[rsp], eax

; 1216 :                         AddTokens( tokenarray, tmp+1, tmp+1 - i, Token_Count );

	mov	eax, DWORD PTR tmp$[rsp]
	inc	eax
	sub	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR tmp$[rsp]
	inc	ecx
	mov	r9d, DWORD PTR ModuleInfo+496
	mov	r8d, eax
	mov	edx, ecx
	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	AddTokens

; 1217 :                         Token_Count += (tmp+1) - i;

	mov	eax, DWORD PTR tmp$[rsp]
	inc	eax
	sub	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR ModuleInfo+496
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+496, eax

; 1218 :                         if ( Token_Count < max ) /* take care not to read beyond T_FINAL */

	mov	eax, DWORD PTR max$[rsp]
	cmp	DWORD PTR ModuleInfo+496, eax
	jge	SHORT $LN26@ExpandToke

; 1219 :                             max = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR max$[rsp], eax
$LN26@ExpandToke:

; 1220 :                         if ( ERROR == RebuildLine( buffer, tmp, tokenarray,

	movsxd	rax, DWORD PTR tmp$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR line$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	sub	rax, rdx
	mov	ecx, DWORD PTR addbrackets$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR size$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR tmp$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	RebuildLine
	cmp	eax, -1
	jne	SHORT $LN27@ExpandToke

; 1221 :                                                   size, tokenarray[tmp].tokpos - line, addbrackets ) )
; 1222 :                             return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandToke
$LN27@ExpandToke:

; 1223 :                         rc = STRING_EXPANDED;

	mov	DWORD PTR rc$[rsp], 1

; 1224 :                         i = tmp;

	mov	eax, DWORD PTR tmp$[rsp]
	mov	DWORD PTR i$[rsp], eax

; 1225 :                     } else {

	jmp	$LN17@ExpandToke
$LN16@ExpandToke:

; 1226 :                         /* a macro proc is expanded at pos 0 or pos 2
; 1227 :                          * (or at pos 1 if sym->label is on)
; 1228 :                          */
; 1229 :                         if ( i == 0 ||
; 1230 :                             ( i == 2 && ( tokenarray[1].token == T_COLON ||
; 1231 :                                          tokenarray[1].token == T_DBL_COLON ))
; 1232 : #if MACROLABEL
; 1233 :                             || ( i == 1 && sym->label )

	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN30@ExpandToke
	cmp	DWORD PTR i$[rsp], 2
	jne	SHORT $LN31@ExpandToke
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN30@ExpandToke
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 13
	je	SHORT $LN30@ExpandToke
$LN31@ExpandToke:
	cmp	DWORD PTR i$[rsp], 1
	jne	SHORT $LN28@ExpandToke
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN28@ExpandToke
$LN30@ExpandToke:

; 1234 : #endif
; 1235 :                            )
; 1236 :                             ;

	jmp	SHORT $LN29@ExpandToke
$LN28@ExpandToke:

; 1237 :                         else {
; 1238 :                             DebugMsg1(("ExpandToken(%s): macro proc at pos %u NOT expanded\n", sym->name, i ));

	mov	r8d, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11533
	call	DoDebugMsg1

; 1239 : #if 1 /* v2.03: no error, just don't expand! */
; 1240 :                             continue;

	jmp	$LN2@ExpandToke
$LN29@ExpandToke:

; 1241 : #else
; 1242 :                             return( EmitErr( SYNTAX_ERROR_EX, sym->name ) );
; 1243 : #endif
; 1244 :                         }
; 1245 :                         /* v2.08: write optional code label. This has been
; 1246 :                          * moved out from RunMacro().
; 1247 :                          */
; 1248 :                         if ( i == 2 ) {

	cmp	DWORD PTR i$[rsp], 2
	jne	SHORT $LN32@ExpandToke

; 1249 :                             if ( ERROR == WriteCodeLabel( line, tokenarray ) )

	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR line$[rsp]
	call	WriteCodeLabel
	cmp	eax, -1
	jne	SHORT $LN33@ExpandToke

; 1250 :                                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandToke
$LN33@ExpandToke:
$LN32@ExpandToke:

; 1251 :                         }
; 1252 :                         //buffer[0] = NULLC; /* nothing should be returned, just to be safe */
; 1253 :                         DebugMsg1(("ExpandToken(%s): macro proc to be expanded\n", sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11536
	call	DoDebugMsg1

; 1254 :                         i = RunMacro( (struct dsym *)sym, i+1, tokenarray, NULL,

	cmp	DWORD PTR i$[rsp], 1
	jne	SHORT $LN48@ExpandToke
	mov	DWORD PTR tv286[rsp], 1
	jmp	SHORT $LN49@ExpandToke
$LN48@ExpandToke:
	mov	DWORD PTR tv286[rsp], 0
$LN49@ExpandToke:
	mov	eax, DWORD PTR tv286[rsp]
	or	eax, 2
	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx
	lea	rdx, QWORD PTR is_exitm$[rsp]
	mov	QWORD PTR [rsp+40], rdx
	mov	DWORD PTR [rsp+32], eax
	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, ecx
	mov	rcx, QWORD PTR sym$[rsp]
	call	RunMacro
	mov	DWORD PTR i$[rsp], eax

; 1255 : #if MACROLABEL
; 1256 :                                      MF_NOSAVE | (i == 1 ? MF_LABEL : 0),
; 1257 : #else
; 1258 :                                      MF_NOSAVE,
; 1259 : #endif
; 1260 :                                      &is_exitm );
; 1261 :                         DebugMsg1(("ExpandToken(%s): macro proc called\n", sym->name));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11537
	call	DoDebugMsg1

; 1262 :                         if ( i == -1 )

	cmp	DWORD PTR i$[rsp], -1
	jne	SHORT $LN34@ExpandToke

; 1263 :                             return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandToke
$LN34@ExpandToke:

; 1264 : #if 0
; 1265 :                         /* it's possible to "hide" the EXITM directive when the
; 1266 :                          * macro lines are read. But it's not useful for macro
; 1267 :                          * procs to check if exitm has been executed, because
; 1268 :                          * Masm simply will ignore anything that's "returned".
; 1269 :                          */
; 1270 :                         if ( is_exitm ) {
; 1271 :                             DebugMsg(("ExpandToken: EXITM in macro procedure!\n" ));
; 1272 :                             strcat( buffer, tokenarray[tmp].tokpos );
; 1273 :                             strcpy( line, buffer );
; 1274 :                             rc = STRING_EXPANDED;
; 1275 :                         } else
; 1276 : #endif
; 1277 :                             return( EMPTY ); /* no further processing */

	mov	eax, -2
	jmp	$LN1@ExpandToke

; 1278 :                         break;

	jmp	$LN3@ExpandToke
$LN17@ExpandToke:

; 1279 :                     }

	jmp	$LN15@ExpandToke
$LN14@ExpandToke:

; 1280 :                 } else if( sym->state == SYM_TMACRO ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 10
	jne	$LN35@ExpandToke

; 1281 : 
; 1282 :                     //GetLiteralValue( buffer, sym->string_ptr );
; 1283 :                     strcpy( buffer, sym->string_ptr );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+16]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	strcpy

; 1284 :                     if ( ERROR == ExpandTMacro( buffer, tokenarray, equmode, 0 ) )

	xor	r9d, r9d
	mov	r8d, DWORD PTR equmode$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	ExpandTMacro
	cmp	eax, -1
	jne	SHORT $LN36@ExpandToke

; 1285 :                         return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandToke
$LN36@ExpandToke:

; 1286 :                     DebugMsg1(("ExpandToken(%s, addbr=%u): value >%s< expanded to >%s<\n", sym->name, addbrackets, sym->string_ptr, buffer ));

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r9, QWORD PTR [rax+16]
	mov	r8d, DWORD PTR addbrackets$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11541
	call	DoDebugMsg1

; 1287 :                     if ( ERROR == RebuildLine( buffer, i, tokenarray, strlen( tokenarray[i].string_ptr ),

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR line$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	sub	rax, rdx
	mov	QWORD PTR tv322[rsp], rax
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+8]
	call	strlen
	mov	ecx, DWORD PTR addbrackets$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR tv322[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, eax
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	RebuildLine
	cmp	eax, -1
	jne	SHORT $LN37@ExpandToke

; 1288 :                                               tokenarray[i].tokpos - line, addbrackets ) )
; 1289 :                         return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandToke
$LN37@ExpandToke:

; 1290 :                     rc = STRING_EXPANDED;

	mov	DWORD PTR rc$[rsp], 1

; 1291 :                     DebugMsg1(("ExpandToken(%s): rest after expansion: %s\n", sym->name, tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11543
	call	DoDebugMsg1
$LN35@ExpandToke:
$LN15@ExpandToke:
$LN13@ExpandToke:
$LN10@ExpandToke:

; 1292 :                 }
; 1293 :             }
; 1294 :         }
; 1295 :     }

	jmp	$LN2@ExpandToke
$LN3@ExpandToke:

; 1296 :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 1297 :     if ( evaluate ) {

	movsx	eax, BYTE PTR evaluate$[rsp]
	test	eax, eax
	je	$LN38@ExpandToke

; 1298 :         int old_tokencount = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR old_tokencount$1[rsp], eax

; 1299 :         if ( i == (pos+1) ) { /* just a single %? */

	mov	eax, DWORD PTR pos$[rsp]
	inc	eax
	cmp	DWORD PTR i$[rsp], eax
	jne	SHORT $LN39@ExpandToke

; 1300 :             opndx.value = 0;

	mov	DWORD PTR opndx$[rsp], 0

; 1301 :             i = pos;

	mov	eax, DWORD PTR pos$[rsp]
	mov	DWORD PTR i$[rsp], eax

; 1302 :         } else {

	jmp	$LN40@ExpandToke
$LN39@ExpandToke:

; 1303 :             i = pos++;

	mov	eax, DWORD PTR pos$[rsp]
	mov	DWORD PTR i$[rsp], eax
	mov	eax, DWORD PTR pos$[rsp]
	inc	eax
	mov	DWORD PTR pos$[rsp], eax

; 1304 :             tmp = tokenarray[*pi].tokpos - tokenarray[pos].tokpos;

	mov	rax, QWORD PTR pi$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR pos$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR tmp$[rsp], eax

; 1305 :             memcpy( buffer, tokenarray[pos].tokpos, tmp );

	movsxd	rax, DWORD PTR tmp$[rsp]
	movsxd	rcx, DWORD PTR pos$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+24]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memcpy

; 1306 :             buffer[tmp] = NULLC;

	movsxd	rax, DWORD PTR tmp$[rsp]
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 1024		; 00000400H
	jae	SHORT $LN50@ExpandToke
	jmp	SHORT $LN51@ExpandToke
$LN50@ExpandToke:
	call	__report_rangecheckfailure
$LN51@ExpandToke:
	mov	rax, QWORD PTR $T2[rsp]
	mov	BYTE PTR buffer$[rsp+rax], 0

; 1307 :             tmp = old_tokencount + 1;

	mov	eax, DWORD PTR old_tokencount$1[rsp]
	inc	eax
	mov	DWORD PTR tmp$[rsp], eax

; 1308 :             Token_Count = Tokenize( buffer, tmp, tokenarray, TOK_RESCAN );

	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR tmp$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 1309 :             if ( EvalOperand( &tmp, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	BYTE PTR [rsp+32], 2
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR tmp$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN41@ExpandToke

; 1310 :                 opndx.value = 0; /* v2.09: assume value 0, don't return with ERROR */

	mov	DWORD PTR opndx$[rsp], 0
	jmp	SHORT $LN42@ExpandToke
$LN41@ExpandToke:

; 1311 :             else if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN43@ExpandToke

; 1312 :                 /* v2.09: with flag EXPF_NOUNDEF, EvalOperand() will have returned
; 1313 :                  * with error if there's an undefined symbol involved
; 1314 :                  */
; 1315 :                 //if ( opndx.sym && opndx.sym->state == SYM_UNDEFINED )
; 1316 :                 //    EmitErr( SYMBOL_NOT_DEFINED, opndx.sym->name );
; 1317 :                 //else {
; 1318 :                     DebugMsg(("ExpandToken: 'constant expected' error\n"));

	lea	rcx, OFFSET FLAT:$SG11550
	call	DoDebugMsg

; 1319 :                     EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 1320 :                 //}
; 1321 :                 //return( ERROR );
; 1322 :                 opndx.value = 0; /* assume value 0 */

	mov	DWORD PTR opndx$[rsp], 0
$LN43@ExpandToke:
$LN42@ExpandToke:

; 1323 :             }
; 1324 :             Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$1[rsp]
	mov	DWORD PTR ModuleInfo+496, eax
$LN40@ExpandToke:

; 1325 :         }
; 1326 : #if TEVALUE_UNSIGNED
; 1327 :         /* v2.03: Masm compatible: returns an unsigned value */
; 1328 :         myltoa( opndx.value, StringBufferEnd, ModuleInfo.radix, FALSE, FALSE );

	movzx	eax, BYTE PTR ModuleInfo+396
	mov	BYTE PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8d, eax
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	ecx, DWORD PTR opndx$[rsp]
	call	myltoa

; 1329 : #else
; 1330 :         myltoa( opndx.value, StringBufferEnd, ModuleInfo.radix, opndx.hvalue < 0, FALSE );
; 1331 : #endif
; 1332 :             /* v2.05: get size of string to be "replaced" */
; 1333 :         tmp = tokenarray[*pi].tokpos - tokenarray[i].tokpos;

	mov	rax, QWORD PTR pi$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR tmp$[rsp], eax

; 1334 :         DebugMsg1(("ExpandToken: curr pos=%u, start expr=%u, expr size=%d\n", *pi, i, tmp ));

	mov	r9d, DWORD PTR tmp$[rsp]
	mov	r8d, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR pi$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11551
	call	DoDebugMsg1

; 1335 : 
; 1336 :         //tokenarray[i].token = T_STRING;
; 1337 :         tokenarray[i].string_ptr = StringBufferEnd;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	QWORD PTR [rcx+rax+8], rdx

; 1338 :         AddTokens( tokenarray, i+1, i+1 - *pi, Token_Count );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	rcx, QWORD PTR pi$[rsp]
	sub	eax, DWORD PTR [rcx]
	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx
	mov	r9d, DWORD PTR ModuleInfo+496
	mov	r8d, eax
	mov	edx, ecx
	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	AddTokens

; 1339 :         Token_Count += (i+1) - *pi;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	rcx, QWORD PTR pi$[rsp]
	sub	eax, DWORD PTR [rcx]
	mov	ecx, DWORD PTR ModuleInfo+496
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+496, eax

; 1340 : 
; 1341 :         if ( ERROR == RebuildLine( StringBufferEnd, i, tokenarray,

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR line$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	sub	rax, rdx
	mov	ecx, DWORD PTR bracket_flags$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR tmp$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+488
	call	RebuildLine
	cmp	eax, -1
	jne	SHORT $LN44@ExpandToke

; 1342 :                                   tmp, tokenarray[i].tokpos - line, bracket_flags ) )
; 1343 :             return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@ExpandToke
$LN44@ExpandToke:

; 1344 :         rc = STRING_EXPANDED;

	mov	DWORD PTR rc$[rsp], 1
$LN38@ExpandToke:

; 1345 :     }
; 1346 :     return( rc );

	mov	eax, DWORD PTR rc$[rsp]
$LN1@ExpandToke:
$LN45@ExpandToke:

; 1347 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1288				; 00000508H
	ret	0
ExpandToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
newlen$ = 32
dest$ = 40
src$ = 48
rest$ = 56
buffer$ = 64
__$ArrayPad$ = 1088
newstring$ = 1120
i$ = 1128
tokenarray$ = 1136
oldlen$ = 1144
pos_line$ = 1152
addbrackets$ = 1160
RebuildLine PROC

; 1081 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1112				; 00000458H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1082 :     char *dest;
; 1083 :     const char *src;
; 1084 :     unsigned  newlen;
; 1085 :     unsigned  rest = strlen( tokenarray[i].tokpos + oldlen ) + 1;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, DWORD PTR oldlen$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	add	rcx, QWORD PTR [rdx+rax+24]
	mov	rax, rcx
	mov	rcx, rax
	call	strlen
	inc	rax
	mov	DWORD PTR rest$[rsp], eax

; 1086 :     char buffer[MAX_LINE_LEN];
; 1087 : 
; 1088 :     dest = tokenarray[i].tokpos;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR dest$[rsp], rax

; 1089 :     memcpy( buffer, dest + oldlen, rest ); /* save content of line behind item */

	mov	eax, DWORD PTR rest$[rsp]
	mov	ecx, DWORD PTR oldlen$[rsp]
	mov	rdx, QWORD PTR dest$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8d, eax
	mov	rdx, rcx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memcpy

; 1090 :     newlen = strlen( newstring );

	mov	rcx, QWORD PTR newstring$[rsp]
	call	strlen
	mov	DWORD PTR newlen$[rsp], eax

; 1091 :     if ( addbrackets ) {

	cmp	DWORD PTR addbrackets$[rsp], 0
	je	SHORT $LN11@RebuildLin

; 1092 :         newlen += 2;   /* count '<' and '>' */

	mov	eax, DWORD PTR newlen$[rsp]
	add	eax, 2
	mov	DWORD PTR newlen$[rsp], eax

; 1093 :         for ( src = newstring; *src; src++ )

	mov	rax, QWORD PTR newstring$[rsp]
	mov	QWORD PTR src$[rsp], rax
	jmp	SHORT $LN4@RebuildLin
$LN2@RebuildLin:
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN4@RebuildLin:
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@RebuildLin

; 1094 :             if ( *src == '<' || *src == '>' || *src == '!' )    /* count '!' operator */

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN13@RebuildLin
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN13@RebuildLin
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN12@RebuildLin
$LN13@RebuildLin:

; 1095 :                 newlen++;

	mov	eax, DWORD PTR newlen$[rsp]
	inc	eax
	mov	DWORD PTR newlen$[rsp], eax
$LN12@RebuildLin:
	jmp	SHORT $LN2@RebuildLin
$LN3@RebuildLin:
$LN11@RebuildLin:

; 1096 :     }
; 1097 :     if ( newlen > oldlen )

	mov	eax, DWORD PTR oldlen$[rsp]
	cmp	DWORD PTR newlen$[rsp], eax
	jbe	SHORT $LN14@RebuildLin

; 1098 :         if ( ( pos_line + newlen - oldlen + rest ) >= MAX_LINE_LEN ) {

	mov	eax, DWORD PTR newlen$[rsp]
	mov	ecx, DWORD PTR pos_line$[rsp]
	add	ecx, eax
	mov	eax, ecx
	sub	eax, DWORD PTR oldlen$[rsp]
	add	eax, DWORD PTR rest$[rsp]
	cmp	eax, 1024				; 00000400H
	jb	SHORT $LN15@RebuildLin

; 1099 :             return( EmitErr( EXPANDED_LINE_TOO_LONG, tokenarray[0].tokpos ) );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 90					; 0000005aH
	call	EmitErr
	jmp	$LN1@RebuildLin
$LN15@RebuildLin:
$LN14@RebuildLin:

; 1100 :         }
; 1101 : 
; 1102 :     if ( addbrackets ) {

	cmp	DWORD PTR addbrackets$[rsp], 0
	je	$LN16@RebuildLin

; 1103 :         *dest++ = '<';

	mov	rax, QWORD PTR dest$[rsp]
	mov	BYTE PTR [rax], 60			; 0000003cH
	mov	rax, QWORD PTR dest$[rsp]
	inc	rax
	mov	QWORD PTR dest$[rsp], rax

; 1104 :         for ( src = newstring; *src; src++ ) {

	mov	rax, QWORD PTR newstring$[rsp]
	mov	QWORD PTR src$[rsp], rax
	jmp	SHORT $LN7@RebuildLin
$LN5@RebuildLin:
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN7@RebuildLin:
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN6@RebuildLin

; 1105 :             if ( *src == '<' || *src == '>' || *src == '!' )    /* count '!' operator */

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN19@RebuildLin
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN19@RebuildLin
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN18@RebuildLin
$LN19@RebuildLin:

; 1106 :                 *dest++ = '!';

	mov	rax, QWORD PTR dest$[rsp]
	mov	BYTE PTR [rax], 33			; 00000021H
	mov	rax, QWORD PTR dest$[rsp]
	inc	rax
	mov	QWORD PTR dest$[rsp], rax
$LN18@RebuildLin:

; 1107 :             *dest++ = *src;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dest$[rsp]
	inc	rax
	mov	QWORD PTR dest$[rsp], rax

; 1108 :         }

	jmp	SHORT $LN5@RebuildLin
$LN6@RebuildLin:

; 1109 :         *dest++ = '>';

	mov	rax, QWORD PTR dest$[rsp]
	mov	BYTE PTR [rax], 62			; 0000003eH
	mov	rax, QWORD PTR dest$[rsp]
	inc	rax
	mov	QWORD PTR dest$[rsp], rax

; 1110 :     } else {

	jmp	SHORT $LN17@RebuildLin
$LN16@RebuildLin:

; 1111 :         memcpy( dest, newstring, newlen );

	mov	eax, DWORD PTR newlen$[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR newstring$[rsp]
	mov	rcx, QWORD PTR dest$[rsp]
	call	memcpy

; 1112 :         dest += newlen;

	mov	eax, DWORD PTR newlen$[rsp]
	mov	rcx, QWORD PTR dest$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dest$[rsp], rax
$LN17@RebuildLin:

; 1113 :     }
; 1114 :     memcpy( dest, buffer, rest ); /* add rest of line */

	mov	eax, DWORD PTR rest$[rsp]
	mov	r8d, eax
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR dest$[rsp]
	call	memcpy

; 1115 : 
; 1116 :     /* v2.05: changed '<' to '<=' */
; 1117 :     for ( i++; i <= Token_Count; i++ ) {

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN10@RebuildLin
$LN8@RebuildLin:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@RebuildLin:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jg	SHORT $LN9@RebuildLin

; 1118 :         tokenarray[i].tokpos = tokenarray[i].tokpos - oldlen + newlen;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, DWORD PTR oldlen$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	ecx, DWORD PTR newlen$[rsp]
	add	rax, rcx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	QWORD PTR [rdx+rcx+24], rax

; 1119 :     }

	jmp	SHORT $LN8@RebuildLin
$LN9@RebuildLin:

; 1120 : 
; 1121 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@RebuildLin:

; 1122 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1112				; 00000458H
	ret	0
RebuildLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
i$ = 0
tv136 = 8
tokenarray$ = 48
start$ = 56
count$ = 64
end$ = 72
AddTokens PROC

; 827  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 24

; 828  :     int i;
; 829  : 
; 830  :     if ( count > 0 ) {

	cmp	DWORD PTR count$[rsp], 0
	jle	SHORT $LN8@AddTokens

; 831  :         for( i = end; i >= start; i-- ) {

	mov	eax, DWORD PTR end$[rsp]
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN4@AddTokens
$LN2@AddTokens:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@AddTokens:
	mov	eax, DWORD PTR start$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jl	SHORT $LN3@AddTokens

; 832  :             tokenarray[i+count] = tokenarray[i];

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, DWORD PTR count$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	add	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	lea	rsi, QWORD PTR [r8+rax]
	mov	ecx, 32					; 00000020H
	rep movsb

; 833  :         }

	jmp	SHORT $LN2@AddTokens
$LN3@AddTokens:

; 834  :     } else if ( count < 0 ) {

	jmp	SHORT $LN9@AddTokens
$LN8@AddTokens:
	cmp	DWORD PTR count$[rsp], 0
	jge	SHORT $LN10@AddTokens

; 835  :         for( i = start - count; i <= end; ++i ) {

	mov	eax, DWORD PTR count$[rsp]
	mov	ecx, DWORD PTR start$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN7@AddTokens
$LN5@AddTokens:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@AddTokens:
	mov	eax, DWORD PTR end$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jg	SHORT $LN6@AddTokens

; 836  :             tokenarray[i+count] = tokenarray[i];

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, DWORD PTR count$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	add	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rdi, QWORD PTR tokenarray$[rsp]
	mov	QWORD PTR tv136[rsp], rdi
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rcx, QWORD PTR tv136[rsp]
	lea	rsi, QWORD PTR [rcx+rax]
	mov	ecx, 32					; 00000020H
	rep movsb

; 837  :         }

	jmp	SHORT $LN5@AddTokens
$LN6@AddTokens:
$LN10@AddTokens:
$LN9@AddTokens:

; 838  :     }
; 839  : }

	add	rsp, 24
	pop	rdi
	pop	rsi
	ret	0
AddTokens ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
buffer$ = 32
__$ArrayPad$ = 1056
tokenarray$ = 1088
SkipMacro PROC

; 133  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1080				; 00000438H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
$LN2@SkipMacro:

; 134  :     char buffer[MAX_LINE_LEN];
; 135  : 
; 136  :     /* The queue isn't just thrown away, because any
; 137  :      * coditional assembly directives found in the source
; 138  :      * must be executed.
; 139  :      */
; 140  :      while ( GetTextLine( buffer ) ) {

	lea	rcx, QWORD PTR buffer$[rsp]
	call	GetTextLine
	test	rax, rax
	je	SHORT $LN3@SkipMacro

; 141  :         Tokenize( buffer, 0, tokenarray, TOK_DEFAULT );

	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	Tokenize

; 142  :     }

	jmp	SHORT $LN2@SkipMacro
$LN3@SkipMacro:

; 143  : 
; 144  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1080				; 00000438H
	ret	0
SkipMacro ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
expanded$ = 48
i$ = 52
len$ = 56
sym$ = 64
old_tokencount$ = 72
is_exitm$ = 76
p$1 = 80
buffer$ = 96
__$ArrayPad$ = 1120
outbuf$ = 1152
tokenarray$ = 1160
equmode$ = 1168
level$ = 1176
ExpandTMacro PROC

; 1002 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1144				; 00000478H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1003 :     int old_tokencount = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR old_tokencount$[rsp], eax

; 1004 :     int i;
; 1005 :     char expanded = TRUE;

	mov	BYTE PTR expanded$[rsp], 1

; 1006 :     int len;
; 1007 :     bool is_exitm;
; 1008 :     struct asym *sym;
; 1009 :     //char lvalue[MAX_LINE_LEN];    /* holds literal value */
; 1010 :     char buffer[MAX_LINE_LEN];
; 1011 : 
; 1012 :     DebugMsg1(("ExpandTMacro(text=>%s< equm=%u lvl=%u) enter\n", outbuf, equmode, level ));

	mov	r9d, DWORD PTR level$[rsp]
	mov	r8d, DWORD PTR equmode$[rsp]
	mov	rdx, QWORD PTR outbuf$[rsp]
	lea	rcx, OFFSET FLAT:$SG11419
	call	DoDebugMsg1

; 1013 : 
; 1014 :     if ( level >= MAX_TEXTMACRO_NESTING ) {

	cmp	DWORD PTR level$[rsp], 20
	jl	SHORT $LN7@ExpandTMac

; 1015 :         return( EmitError( MACRO_NESTING_LEVEL_TOO_DEEP ) );

	mov	ecx, 101				; 00000065H
	call	EmitError
	jmp	$LN1@ExpandTMac
$LN7@ExpandTMac:
$LN2@ExpandTMac:

; 1016 :     }
; 1017 : 
; 1018 :     while ( expanded == TRUE ) {

	movsx	eax, BYTE PTR expanded$[rsp]
	cmp	eax, 1
	jne	$LN3@ExpandTMac

; 1019 :         i = old_tokencount + 1;

	mov	eax, DWORD PTR old_tokencount$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1020 :         Token_Count = Tokenize( outbuf, i, tokenarray, TOK_RESCAN );

	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR outbuf$[rsp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 1021 :         expanded = FALSE;

	mov	BYTE PTR expanded$[rsp], 0

; 1022 :         for ( ; i < Token_Count; i++ ) {

	jmp	SHORT $LN6@ExpandTMac
$LN4@ExpandTMac:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN6@ExpandTMac:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN5@ExpandTMac

; 1023 :             if ( tokenarray[i].token == T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN8@ExpandTMac

; 1024 :                 sym = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 1025 :                 /* expand macro functions */
; 1026 :                 if ( sym && sym->state == SYM_MACRO &&
; 1027 :                     sym->isdefined == TRUE && sym->isfunc == TRUE &&
; 1028 :                     tokenarray[i+1].token == T_OP_BRACKET && equmode == FALSE ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN9@ExpandTMac
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	jne	$LN9@ExpandTMac
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN9@ExpandTMac
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN9@ExpandTMac
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	$LN9@ExpandTMac
	cmp	DWORD PTR equmode$[rsp], 0
	jne	$LN9@ExpandTMac

; 1029 :                     len = tokenarray[i].tokpos - outbuf;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR outbuf$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	sub	rax, rdx
	mov	DWORD PTR len$[rsp], eax

; 1030 :                     memcpy( buffer, outbuf, len );

	movsxd	rax, DWORD PTR len$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR outbuf$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memcpy

; 1031 :                     i = RunMacro( (struct dsym *)sym, i+1, tokenarray, buffer+len, 0, &is_exitm );

	movsxd	rax, DWORD PTR len$[rsp]
	lea	rax, QWORD PTR buffer$[rsp+rax]
	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx
	lea	rdx, QWORD PTR is_exitm$[rsp]
	mov	QWORD PTR [rsp+40], rdx
	mov	DWORD PTR [rsp+32], 0
	mov	r9, rax
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, ecx
	mov	rcx, QWORD PTR sym$[rsp]
	call	RunMacro
	mov	DWORD PTR i$[rsp], eax

; 1032 :                     if ( i < 0 ) {

	cmp	DWORD PTR i$[rsp], 0
	jge	SHORT $LN11@ExpandTMac

; 1033 :                         Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax

; 1034 :                         return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandTMac
$LN11@ExpandTMac:

; 1035 :                     }
; 1036 :                     DebugMsg1(("ExpandTMacro(%u): repl >%s()< by >%s<\n", level, sym->name, buffer+len ));

	movsxd	rax, DWORD PTR len$[rsp]
	lea	rax, QWORD PTR buffer$[rsp+rax]
	mov	r9, rax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR level$[rsp]
	lea	rcx, OFFSET FLAT:$SG11425
	call	DoDebugMsg1

; 1037 :                     strcat( buffer+len, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR len$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp+rcx]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rdx+rax+24]
	call	strcat

; 1038 :                     strcpy( outbuf, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR outbuf$[rsp]
	call	strcpy

; 1039 :                     expanded = TRUE;

	mov	BYTE PTR expanded$[rsp], 1

; 1040 :                     /* is i to be decremented here? */
; 1041 :                     break;

	jmp	$LN5@ExpandTMac
	jmp	$LN10@ExpandTMac
$LN9@ExpandTMac:

; 1042 :                 } else if ( sym && sym->state == SYM_TMACRO && sym->isdefined == TRUE ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN12@ExpandTMac
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 10
	jne	$LN12@ExpandTMac
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN12@ExpandTMac

; 1043 :                     char *p;
; 1044 :                     len = tokenarray[i].tokpos - outbuf;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR outbuf$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	sub	rax, rdx
	mov	DWORD PTR len$[rsp], eax

; 1045 :                     memcpy( buffer, outbuf, len );

	movsxd	rax, DWORD PTR len$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR outbuf$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memcpy

; 1046 :                     //GetLiteralValue( buffer+len, sym->string_ptr );
; 1047 :                     strcpy( buffer+len, sym->string_ptr );

	movsxd	rax, DWORD PTR len$[rsp]
	lea	rax, QWORD PTR buffer$[rsp+rax]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rcx+16]
	mov	rcx, rax
	call	strcpy

; 1048 :                     DebugMsg1(("ExpandTMacro(>%s<, %u): calling ExpandTMacro, value >%s<\n", sym->name, level, buffer+len ));

	movsxd	rax, DWORD PTR len$[rsp]
	lea	rax, QWORD PTR buffer$[rsp+rax]
	mov	r9, rax
	mov	r8d, DWORD PTR level$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11427
	call	DoDebugMsg1

; 1049 :                     if ( ERROR == ExpandTMacro( buffer + len, tokenarray, equmode, level+1 ) ) {

	mov	eax, DWORD PTR level$[rsp]
	inc	eax
	movsxd	rcx, DWORD PTR len$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp+rcx]
	mov	r9d, eax
	mov	r8d, DWORD PTR equmode$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	call	ExpandTMacro
	cmp	eax, -1
	jne	SHORT $LN13@ExpandTMac

; 1050 :                         Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax

; 1051 :                         return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandTMac
$LN13@ExpandTMac:

; 1052 :                     }
; 1053 :                     DebugMsg1(("ExpandTMacro(%u): repl >%s< by >%s<\n", level, sym->name, buffer+len ));

	movsxd	rax, DWORD PTR len$[rsp]
	lea	rax, QWORD PTR buffer$[rsp+rax]
	mov	r9, rax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR level$[rsp]
	lea	rcx, OFFSET FLAT:$SG11429
	call	DoDebugMsg1

; 1054 :                     //if ( level || ( tokenarray[i+1].token != T_FINAL && tokenarray[i+1].token != T_COMMA ))
; 1055 :                         p = tokenarray[i].tokpos + sym->name_size;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+72]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	add	rcx, QWORD PTR [rdx+rax+24]
	mov	rax, rcx
	mov	QWORD PTR p$1[rsp], rax

; 1056 :                     //else
; 1057 :                     //    p = tokenarray[i+1].tokpos;
; 1058 :                     strcat( buffer+len, p );

	movsxd	rax, DWORD PTR len$[rsp]
	lea	rax, QWORD PTR buffer$[rsp+rax]
	mov	rdx, QWORD PTR p$1[rsp]
	mov	rcx, rax
	call	strcat

; 1059 :                     strcpy( outbuf, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR outbuf$[rsp]
	call	strcpy

; 1060 :                     expanded = TRUE;

	mov	BYTE PTR expanded$[rsp], 1

; 1061 :                     break;

	jmp	SHORT $LN5@ExpandTMac
$LN12@ExpandTMac:
$LN10@ExpandTMac:
$LN8@ExpandTMac:

; 1062 :                 }
; 1063 :             }
; 1064 :         }

	jmp	$LN4@ExpandTMac
$LN5@ExpandTMac:

; 1065 :     }

	jmp	$LN2@ExpandTMac
$LN3@ExpandTMac:

; 1066 :     Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax

; 1067 :     //strcpy( outbuf, lvalue );
; 1068 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@ExpandTMac:

; 1069 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1144				; 00000478H
	ret	0
ExpandTMacro ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
idx$ = 32
cnt$ = 36
i$ = 64
tokenarray$ = 72
ExpandLiterals PROC

; 1394 : {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 1395 :     int cnt = 0;

	mov	DWORD PTR cnt$[rsp], 0

; 1396 :     int idx;
; 1397 :     /* count non-empty literals */
; 1398 :     for ( idx = i; idx < Token_Count; idx++ ) {

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR idx$[rsp], eax
	jmp	SHORT $LN4@ExpandLite
$LN2@ExpandLite:
	mov	eax, DWORD PTR idx$[rsp]
	inc	eax
	mov	DWORD PTR idx$[rsp], eax
$LN4@ExpandLite:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR idx$[rsp], eax
	jge	SHORT $LN3@ExpandLite

; 1399 :         if ( tokenarray[idx].token == T_STRING &&
; 1400 :             tokenarray[idx].stringlen &&

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN5@ExpandLite
	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 0
	je	SHORT $LN5@ExpandLite
	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN6@ExpandLite
	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN5@ExpandLite
$LN6@ExpandLite:

; 1401 :             ( tokenarray[idx].string_delim == '<' || tokenarray[idx].string_delim == '{' ) ) {
; 1402 :             cnt++;

	mov	eax, DWORD PTR cnt$[rsp]
	inc	eax
	mov	DWORD PTR cnt$[rsp], eax
$LN5@ExpandLite:

; 1403 :         }
; 1404 :     }

	jmp	SHORT $LN2@ExpandLite
$LN3@ExpandLite:

; 1405 :     /* if non-empty literals are found, expand the line. if the line
; 1406 :      * was expanded, re-tokenize it.
; 1407 :      */
; 1408 :     if ( cnt ) {

	cmp	DWORD PTR cnt$[rsp], 0
	je	SHORT $LN7@ExpandLite

; 1409 :         if ( ExpandText( tokenarray[i].tokpos, tokenarray, FALSE ) == STRING_EXPANDED )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	xor	r8d, r8d
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+24]
	call	ExpandText
	cmp	eax, 1
	jne	SHORT $LN8@ExpandLite

; 1410 :             Tokenize( tokenarray[i].tokpos, i, tokenarray, TOK_RESCAN );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+24]
	call	Tokenize
$LN8@ExpandLite:
$LN7@ExpandLite:

; 1411 :     }
; 1412 : 
; 1413 : }

	add	rsp, 56					; 00000038H
	ret	0
ExpandLiterals ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
count$ = 48
i$ = 52
rc$ = 56
bracket_flags$ = 60
tv182 = 64
lvl$ = 68
j$ = 72
tmp$1 = 76
tv84 = 80
flags$ = 84
tv222 = 88
addbrackets$2 = 92
sym$ = 96
string$ = 128
tokenarray$ = 136
ExpandLine PROC

; 1421 : {

$LN59:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 1422 :     int count;
; 1423 :     unsigned int bracket_flags; /* flags */
; 1424 :     int flags;
; 1425 :     int lvl;
; 1426 :     int i;
; 1427 :     int j;
; 1428 :     ret_code rc;
; 1429 :     struct asym *sym;
; 1430 : 
; 1431 :     /* filter certain conditions.
; 1432 :      * bracket_flags: for (preprocessor) directives that expect a literal
; 1433 :      * parameter, the expanded argument has to be enclosed in '<>' again.
; 1434 :      */
; 1435 :     DebugMsg1(( "ExpandLine(>%s<) enter\n", string ));

	mov	rdx, QWORD PTR string$[rsp]
	lea	rcx, OFFSET FLAT:$SG11620
	call	DoDebugMsg1

; 1436 :     for ( lvl = 0; lvl < MAX_TEXTMACRO_NESTING; lvl++ ) {

	mov	DWORD PTR lvl$[rsp], 0
	jmp	SHORT $LN4@ExpandLine
$LN2@ExpandLine:
	mov	eax, DWORD PTR lvl$[rsp]
	inc	eax
	mov	DWORD PTR lvl$[rsp], eax
$LN4@ExpandLine:
	cmp	DWORD PTR lvl$[rsp], 20
	jge	$LN3@ExpandLine

; 1437 :         bracket_flags = 0;

	mov	DWORD PTR bracket_flags$[rsp], 0

; 1438 :         count = 0;

	mov	DWORD PTR count$[rsp], 0

; 1439 :         rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 1440 :         i = ( Token_Count > 2 && ( tokenarray[1].token == T_COLON || tokenarray[1].token == T_DBL_COLON ) && tokenarray[2].token == T_DIRECTIVE ) ? 2 : 0;

	cmp	DWORD PTR ModuleInfo+496, 2
	jle	SHORT $LN53@ExpandLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN52@ExpandLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 13
	jne	SHORT $LN53@ExpandLine
$LN52@ExpandLine:
	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	SHORT $LN53@ExpandLine
	mov	DWORD PTR tv84[rsp], 2
	jmp	SHORT $LN54@ExpandLine
$LN53@ExpandLine:
	mov	DWORD PTR tv84[rsp], 0
$LN54@ExpandLine:
	mov	eax, DWORD PTR tv84[rsp]
	mov	DWORD PTR i$[rsp], eax

; 1441 :         if ( tokenarray[i].token == T_DIRECTIVE ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	$LN14@ExpandLine

; 1442 :             flags = GetValueSp( tokenarray[i].tokval );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR flags$[rsp], eax

; 1443 :             if ( flags & DF_STRPARM ) {

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	$LN16@ExpandLine

; 1444 :                 bracket_flags = -1;

	mov	DWORD PTR bracket_flags$[rsp], -1	; ffffffffH

; 1445 :                 /* v2.08 handle .ERRDEF and .ERRNDEF here. Previously
; 1446 :                  * expansion for these directives was handled in condasm.asm,
; 1447 :                  * and the directives were flagged as DF_NOEXPAND.
; 1448 :                  */
; 1449 :                 if ( tokenarray[i].dirtype == DRT_ERRDIR ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 10
	jne	$LN18@ExpandLine

; 1450 :                     if (tokenarray[i].tokval == T_DOT_ERRDEF || tokenarray[i].tokval == T_DOT_ERRNDEF ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 361		; 00000169H
	je	SHORT $LN20@ExpandLine
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 362		; 0000016aH
	jne	$LN19@ExpandLine
$LN20@ExpandLine:

; 1451 :                         if ( i )

	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN21@ExpandLine

; 1452 :                             rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	call	ExpandToken
	mov	DWORD PTR rc$[rsp], eax
$LN21@ExpandLine:
$LN5@ExpandLine:

; 1453 :                         while ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA ) i++;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN6@ExpandLine
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN6@ExpandLine
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN5@ExpandLine
$LN6@ExpandLine:

; 1454 :                         count = i; /* don't expand the symbol name */

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR count$[rsp], eax
$LN19@ExpandLine:
$LN18@ExpandLine:

; 1455 :                     }
; 1456 :                 }

	jmp	SHORT $LN17@ExpandLine
$LN16@ExpandLine:

; 1457 :             } else if ( flags & DF_NOEXPAND ) {

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN22@ExpandLine

; 1458 :                 /* [ELSE]IF[N]DEF, ECHO, FOR[C]
; 1459 :                  * .[NO|X]CREF, INCLUDE */
; 1460 :                 /* don't expand arguments */
; 1461 :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@ExpandLine
$LN22@ExpandLine:
$LN17@ExpandLine:

; 1462 :             }

	jmp	$LN15@ExpandLine
$LN14@ExpandLine:

; 1463 :         } else if ( Token_Count > 1 && tokenarray[1].token == T_DIRECTIVE ) {

	cmp	DWORD PTR ModuleInfo+496, 1
	jle	$LN23@ExpandLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	$LN23@ExpandLine

; 1464 :             switch ( tokenarray[1].dirtype ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1]
	mov	DWORD PTR tv182[rsp], eax
	mov	eax, DWORD PTR tv182[rsp]
	sub	eax, 4
	mov	DWORD PTR tv182[rsp], eax
	cmp	DWORD PTR tv182[rsp], 43		; 0000002bH
	ja	$LN7@ExpandLine
	movsxd	rax, DWORD PTR tv182[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN57@ExpandLine[rcx+rax]
	mov	eax, DWORD PTR $LN58@ExpandLine[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN25@ExpandLine:

; 1465 :             case DRT_CATSTR:
; 1466 :                 bracket_flags = -1;

	mov	DWORD PTR bracket_flags$[rsp], -1	; ffffffffH

; 1467 :                 count = 2;

	mov	DWORD PTR count$[rsp], 2

; 1468 :                 break;

	jmp	$LN7@ExpandLine
$LN26@ExpandLine:

; 1469 :             case DRT_SUBSTR:
; 1470 :                 /* syntax: name SUBSTR <literal>, pos [, size] */
; 1471 :                 bracket_flags = 0x1;

	mov	DWORD PTR bracket_flags$[rsp], 1

; 1472 :                 count = 2;

	mov	DWORD PTR count$[rsp], 2

; 1473 :                 break;

	jmp	$LN7@ExpandLine
$LN27@ExpandLine:

; 1474 :             case DRT_SIZESTR:
; 1475 :                 /* syntax: label SIZESTR literal */
; 1476 :                 rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	call	ExpandToken
	mov	DWORD PTR rc$[rsp], eax

; 1477 :                 bracket_flags = 0x1;

	mov	DWORD PTR bracket_flags$[rsp], 1

; 1478 :                 count = 2;

	mov	DWORD PTR count$[rsp], 2

; 1479 :                 break;

	jmp	$LN7@ExpandLine
$LN28@ExpandLine:

; 1480 :             case DRT_INSTR:
; 1481 :                 /* syntax: label INSTR [number,] literal, literal */
; 1482 :                 rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	call	ExpandToken
	mov	DWORD PTR rc$[rsp], eax

; 1483 :                 /* check if the optional <number> argument is given */
; 1484 :                 for ( i = 2, count = 0, j = 0; i < Token_Count; i++ ) {

	mov	DWORD PTR i$[rsp], 2
	mov	DWORD PTR count$[rsp], 0
	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN11@ExpandLine
$LN9@ExpandLine:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN11@ExpandLine:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN10@ExpandLine

; 1485 :                     if ( tokenarray[i].token == T_OP_BRACKET )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN29@ExpandLine

; 1486 :                         count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax
	jmp	SHORT $LN30@ExpandLine
$LN29@ExpandLine:

; 1487 :                     else if ( tokenarray[i].token == T_CL_BRACKET )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN31@ExpandLine

; 1488 :                         count--;

	mov	eax, DWORD PTR count$[rsp]
	dec	eax
	mov	DWORD PTR count$[rsp], eax
	jmp	SHORT $LN32@ExpandLine
$LN31@ExpandLine:

; 1489 :                     else if ( tokenarray[i].token == T_COMMA && count == 0 )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN33@ExpandLine
	cmp	DWORD PTR count$[rsp], 0
	jne	SHORT $LN33@ExpandLine

; 1490 :                         j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN33@ExpandLine:
$LN32@ExpandLine:
$LN30@ExpandLine:

; 1491 :                 }

	jmp	$LN9@ExpandLine
$LN10@ExpandLine:

; 1492 : 
; 1493 :                 bracket_flags = ( ( j > 1 ) ? 0x6 : 0x3 );

	cmp	DWORD PTR j$[rsp], 1
	jle	SHORT $LN55@ExpandLine
	mov	DWORD PTR tv222[rsp], 6
	jmp	SHORT $LN56@ExpandLine
$LN55@ExpandLine:
	mov	DWORD PTR tv222[rsp], 3
$LN56@ExpandLine:
	mov	eax, DWORD PTR tv222[rsp]
	mov	DWORD PTR bracket_flags$[rsp], eax

; 1494 :                 count = 2;

	mov	DWORD PTR count$[rsp], 2

; 1495 :                 break;

	jmp	SHORT $LN7@ExpandLine
$LN34@ExpandLine:

; 1496 :             case DRT_MACRO:
; 1497 :                 sym = SymSearch( tokenarray[0].string_ptr );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 1498 :                 /* don't expand macro DEFINITIONs!
; 1499 :                  * the name is an exception, if it's not the macro itself
; 1500 :                  */
; 1501 :                 if ( sym && sym->state != SYM_MACRO )

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN35@ExpandLine
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	je	SHORT $LN35@ExpandLine

; 1502 :                     rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	call	ExpandToken
	mov	DWORD PTR rc$[rsp], eax
$LN35@ExpandLine:

; 1503 :                 count = Token_Count; /* stop further expansion */

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR count$[rsp], eax

; 1504 :                 break;

	jmp	SHORT $LN7@ExpandLine
$LN36@ExpandLine:

; 1505 :             case DRT_EQU:
; 1506 :                 /* EQU is a special case. If the - expanded - expression is
; 1507 :                  * a number, then the value for EQU is numeric. Else the
; 1508 :                  * expression isn't expanded at all. This effectively makes it
; 1509 :                  * impossible to expand EQU lines here.
; 1510 :                  */
; 1511 : #if 0 /* v2.09: EQU should NEVER be expanded here. See regression test equate20.aso */
; 1512 :                 sym = SymSearch( tokenarray[0].string_ptr );
; 1513 :                 if ( sym == NULL || sym->state == SYM_TMACRO )
; 1514 : #endif
; 1515 :                     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@ExpandLine
$LN7@ExpandLine:

; 1516 :             }
; 1517 :         } else {

	jmp	$LN24@ExpandLine
$LN23@ExpandLine:

; 1518 :             /* v2.08: expand the very first token and then ... */
; 1519 :             rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	call	ExpandToken
	mov	DWORD PTR rc$[rsp], eax

; 1520 :             if( rc == ERROR || rc == EMPTY )

	cmp	DWORD PTR rc$[rsp], -1
	je	SHORT $LN38@ExpandLine
	cmp	DWORD PTR rc$[rsp], -2
	jne	SHORT $LN37@ExpandLine
$LN38@ExpandLine:

; 1521 :                 return( rc );

	mov	eax, DWORD PTR rc$[rsp]
	jmp	$LN1@ExpandLine
$LN37@ExpandLine:

; 1522 :             if ( rc == STRING_EXPANDED ) {

	cmp	DWORD PTR rc$[rsp], 1
	jne	SHORT $LN39@ExpandLine

; 1523 :                 /* ... fully retokenize - the expansion might have revealed a conditional
; 1524 :                  * assembly directive
; 1525 :                  */
; 1526 :                 Token_Count = Tokenize( string, 0, tokenarray, TOK_DEFAULT );

	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR string$[rsp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 1527 :                 continue;

	jmp	$LN2@ExpandLine
$LN39@ExpandLine:

; 1528 :             }
; 1529 : #if 1 /* v2.10. see regression test equate27.asm */
; 1530 :             if ( count == 1 && tokenarray[0].token == T_ID && tokenarray[1].token == T_ID ) {

	cmp	DWORD PTR count$[rsp], 1
	jne	$LN40@ExpandLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN40@ExpandLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN40@ExpandLine

; 1531 :                 rc = ExpandToken( string, &count, tokenarray, 2, FALSE, FALSE );

	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 2
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	call	ExpandToken
	mov	DWORD PTR rc$[rsp], eax

; 1532 :                 if( rc == ERROR || rc == EMPTY )

	cmp	DWORD PTR rc$[rsp], -1
	je	SHORT $LN42@ExpandLine
	cmp	DWORD PTR rc$[rsp], -2
	jne	SHORT $LN41@ExpandLine
$LN42@ExpandLine:

; 1533 :                     return( rc );

	mov	eax, DWORD PTR rc$[rsp]
	jmp	$LN1@ExpandLine
$LN41@ExpandLine:

; 1534 :                 if ( rc == STRING_EXPANDED ) {

	cmp	DWORD PTR rc$[rsp], 1
	jne	SHORT $LN43@ExpandLine

; 1535 :                     Token_Count = Tokenize( string, 0, tokenarray, TOK_DEFAULT );

	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR string$[rsp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 1536 :                     continue;

	jmp	$LN2@ExpandLine
$LN43@ExpandLine:
$LN40@ExpandLine:
$LN24@ExpandLine:
$LN15@ExpandLine:
$LN12@ExpandLine:

; 1537 :                 }
; 1538 :             }
; 1539 : #endif
; 1540 :         }
; 1541 :         /* scan the line from left to right for (text) macros.
; 1542 :          * it's currently not quite correct. a macro proc should only
; 1543 :          * be evaluated in the following cases:
; 1544 :          * 1. it is the first token of a line
; 1545 :          * 2. it is the second token, and the first one is an ID
; 1546 :          * 3. it is the third token, the first one is an ID and
; 1547 :          *    the second is a ':' or '::'.
; 1548 :          */
; 1549 :         while ( count < Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR count$[rsp], eax
	jge	$LN13@ExpandLine

; 1550 :             int tmp;
; 1551 :             int addbrackets;
; 1552 :             addbrackets = bracket_flags & 1;

	mov	eax, DWORD PTR bracket_flags$[rsp]
	and	eax, 1
	mov	DWORD PTR addbrackets$2[rsp], eax

; 1553 :             if ( bracket_flags != -1 )

	cmp	DWORD PTR bracket_flags$[rsp], -1	; ffffffffH
	je	SHORT $LN44@ExpandLine

; 1554 :                 bracket_flags = bracket_flags >> 1;

	mov	eax, DWORD PTR bracket_flags$[rsp]
	shr	eax, 1
	mov	DWORD PTR bracket_flags$[rsp], eax
$LN44@ExpandLine:

; 1555 :             tmp = ExpandToken( string, &count, tokenarray, Token_Count, addbrackets, FALSE );

	mov	DWORD PTR [rsp+40], 0
	mov	eax, DWORD PTR addbrackets$2[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR ModuleInfo+496
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	call	ExpandToken
	mov	DWORD PTR tmp$1[rsp], eax

; 1556 :             if( tmp < NOT_ERROR ) /* ERROR or EMPTY? */

	cmp	DWORD PTR tmp$1[rsp], 0
	jge	SHORT $LN45@ExpandLine

; 1557 :                 return( tmp );

	mov	eax, DWORD PTR tmp$1[rsp]
	jmp	$LN1@ExpandLine
$LN45@ExpandLine:

; 1558 :             if ( tmp == STRING_EXPANDED )

	cmp	DWORD PTR tmp$1[rsp], 1
	jne	SHORT $LN46@ExpandLine

; 1559 :                 rc = STRING_EXPANDED;

	mov	DWORD PTR rc$[rsp], 1
$LN46@ExpandLine:

; 1560 :             if ( tokenarray[count].token == T_COMMA )

	movsxd	rax, DWORD PTR count$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN47@ExpandLine

; 1561 :                 count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax
$LN47@ExpandLine:

; 1562 :         }

	jmp	$LN12@ExpandLine
$LN13@ExpandLine:

; 1563 :         if( rc == STRING_EXPANDED ) {

	cmp	DWORD PTR rc$[rsp], 1
	jne	SHORT $LN48@ExpandLine

; 1564 :             DebugMsg1(( "ExpandLine(%s): expansion occured, retokenize\n", string ));

	mov	rdx, QWORD PTR string$[rsp]
	lea	rcx, OFFSET FLAT:$SG11657
	call	DoDebugMsg1

; 1565 :             Token_Count = Tokenize( string, 0, tokenarray, TOK_RESCAN | TOK_LINE );

	mov	r9d, 5
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR string$[rsp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 1566 :         } else

	jmp	SHORT $LN49@ExpandLine
$LN48@ExpandLine:

; 1567 :             break;

	jmp	SHORT $LN3@ExpandLine
$LN49@ExpandLine:

; 1568 :     } /* end for() */

	jmp	$LN2@ExpandLine
$LN3@ExpandLine:

; 1569 :     if ( lvl == MAX_TEXTMACRO_NESTING ) {

	cmp	DWORD PTR lvl$[rsp], 20
	jne	SHORT $LN50@ExpandLine

; 1570 :         return( EmitError( MACRO_NESTING_LEVEL_TOO_DEEP ) );

	mov	ecx, 101				; 00000065H
	call	EmitError
	jmp	SHORT $LN1@ExpandLine
$LN50@ExpandLine:

; 1571 :     }
; 1572 :     DebugMsg1(( "ExpandLine(>%s<) exit, rc=%u, token_count=%u\n", string, rc, Token_Count ));

	mov	r9d, DWORD PTR ModuleInfo+496
	mov	r8d, DWORD PTR rc$[rsp]
	mov	rdx, QWORD PTR string$[rsp]
	lea	rcx, OFFSET FLAT:$SG11659
	call	DoDebugMsg1

; 1573 :     return( rc );

	mov	eax, DWORD PTR rc$[rsp]
$LN1@ExpandLine:

; 1574 : }

	add	rsp, 120				; 00000078H
	ret	0
	npad	1
$LN58@ExpandLine:
	DD	$LN34@ExpandLine
	DD	$LN25@ExpandLine
	DD	$LN26@ExpandLine
	DD	$LN28@ExpandLine
	DD	$LN27@ExpandLine
	DD	$LN36@ExpandLine
	DD	$LN7@ExpandLine
$LN57@ExpandLine:
	DB	0
	DB	1
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
ExpandLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
k$ = 48
lvl$ = 52
tmp$ = 56
rc$ = 60
line$ = 80
i$ = 88
tokenarray$ = 96
addbrackets$ = 104
equmode$ = 112
ExpandLineItems PROC

; 1356 : {

$LN14:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1357 :     int k;
; 1358 :     int lvl;
; 1359 :     int tmp;
; 1360 :     ret_code rc;
; 1361 : 
; 1362 :     for ( lvl = 0; ; lvl++ ) {

	mov	DWORD PTR lvl$[rsp], 0
	jmp	SHORT $LN4@ExpandLine
$LN2@ExpandLine:
	mov	eax, DWORD PTR lvl$[rsp]
	inc	eax
	mov	DWORD PTR lvl$[rsp], eax
$LN4@ExpandLine:

; 1363 :         rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 1364 :         for( k = i; k < Token_Count; ) {

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR k$[rsp], eax
$LN5@ExpandLine:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN6@ExpandLine

; 1365 :             tmp = ExpandToken( line, &k, tokenarray, Token_Count, addbrackets, equmode );

	mov	eax, DWORD PTR equmode$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR addbrackets$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR ModuleInfo+496
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR k$[rsp]
	mov	rcx, QWORD PTR line$[rsp]
	call	ExpandToken
	mov	DWORD PTR tmp$[rsp], eax

; 1366 :             if ( tmp == ERROR )

	cmp	DWORD PTR tmp$[rsp], -1
	jne	SHORT $LN8@ExpandLine

; 1367 :                 return( lvl );

	mov	eax, DWORD PTR lvl$[rsp]
	jmp	SHORT $LN1@ExpandLine
$LN8@ExpandLine:

; 1368 :             if ( tmp == STRING_EXPANDED )

	cmp	DWORD PTR tmp$[rsp], 1
	jne	SHORT $LN9@ExpandLine

; 1369 :                 rc = STRING_EXPANDED;

	mov	DWORD PTR rc$[rsp], 1
$LN9@ExpandLine:

; 1370 :             if ( tokenarray[k].token == T_COMMA )

	movsxd	rax, DWORD PTR k$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN10@ExpandLine

; 1371 :                 k++;

	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN10@ExpandLine:

; 1372 :         }

	jmp	SHORT $LN5@ExpandLine
$LN6@ExpandLine:

; 1373 :         if ( rc == NOT_ERROR )

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN11@ExpandLine

; 1374 :             break;

	jmp	SHORT $LN3@ExpandLine
$LN11@ExpandLine:

; 1375 :         /* expansion happened, re-tokenize and continue! */
; 1376 :         Token_Count = Tokenize( line, i, tokenarray, TOK_RESCAN );

	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR line$[rsp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 1377 :         if ( lvl == MAX_TEXTMACRO_NESTING ) {

	cmp	DWORD PTR lvl$[rsp], 20
	jne	SHORT $LN12@ExpandLine

; 1378 :             EmitError( MACRO_NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 101				; 00000065H
	call	EmitError

; 1379 :             break;

	jmp	SHORT $LN3@ExpandLine
$LN12@ExpandLine:

; 1380 :         }
; 1381 :     }

	jmp	$LN2@ExpandLine
$LN3@ExpandLine:

; 1382 :     return( lvl );

	mov	eax, DWORD PTR lvl$[rsp]
$LN1@ExpandLine:

; 1383 : }

	add	rsp, 72					; 00000048H
	ret	0
ExpandLineItems ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
quoted_string$ = 48
pSrc$ = 56
macro_proc$ = 64
lvl$ = 68
i$1 = 72
pIdent$ = 80
pDst$ = 88
j$2 = 96
cnt$3 = 100
sym$ = 104
rc$ = 112
is_exitm$ = 116
old_tokencount$ = 120
p$4 = 128
old_stringbufferend$ = 136
tv160 = 144
tv282 = 152
tv292 = 160
sp$ = 176
__$ArrayPad$ = 336
line$ = 368
tokenarray$ = 376
substitute$ = 384
ExpandText PROC

; 851  : {

$LN67:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 360				; 00000168H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 852  :     char *pSrc;
; 853  :     char *pDst;
; 854  :     char *pIdent;
; 855  :     int  lvl;
; 856  :     bool is_exitm;
; 857  :     int old_tokencount = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR old_tokencount$[rsp], eax

; 858  :     char *old_stringbufferend = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR old_stringbufferend$[rsp], rax

; 859  :     char quoted_string = 0;

	mov	BYTE PTR quoted_string$[rsp], 0

; 860  :     char macro_proc = FALSE;

	mov	BYTE PTR macro_proc$[rsp], 0

; 861  :     //char *pStart;
; 862  :     ret_code rc;
; 863  :     struct asym *sym;
; 864  :     char *sp[MAX_TEXTMACRO_NESTING];
; 865  : 
; 866  :         DebugMsg1(("ExpandText(line=>%s<, subst=%u ) enter\n", line, substitute ));

	mov	r8d, DWORD PTR substitute$[rsp]
	mov	rdx, QWORD PTR line$[rsp]
	lea	rcx, OFFSET FLAT:$SG11346
	call	DoDebugMsg1

; 867  :     sp[0] = line;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR line$[rsp]
	mov	QWORD PTR sp$[rsp+rax], rcx

; 868  :     pDst = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR pDst$[rsp], rax

; 869  :     StringBufferEnd += MAX_LINE_LEN;

	mov	rax, QWORD PTR ModuleInfo+488
	add	rax, 1024				; 00000400H
	mov	QWORD PTR ModuleInfo+488, rax

; 870  :     rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 871  :     for ( lvl = 0; lvl >= 0; lvl-- ) {

	mov	DWORD PTR lvl$[rsp], 0
	jmp	SHORT $LN4@ExpandText
$LN2@ExpandText:
	mov	eax, DWORD PTR lvl$[rsp]
	dec	eax
	mov	DWORD PTR lvl$[rsp], eax
$LN4@ExpandText:
	cmp	DWORD PTR lvl$[rsp], 0
	jl	$LN3@ExpandText

; 872  :         pSrc = sp[lvl];

	movsxd	rax, DWORD PTR lvl$[rsp]
	mov	rax, QWORD PTR sp$[rsp+rax*8]
	mov	QWORD PTR pSrc$[rsp], rax
$LN62@ExpandText:
$LN61@ExpandText:
$LN5@ExpandText:

; 873  :         while ( *pSrc ) {

	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN6@ExpandText

; 874  :             if( is_valid_id_first_char( *pSrc ) && ( substitute != 0 || quoted_string == 0 ) ) {

	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isalpha
	test	eax, eax
	jne	SHORT $LN17@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN17@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN17@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN17@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN17@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	jne	$LN15@ExpandText
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 4
	and	eax, 1
	cmp	eax, 1
	jne	$LN15@ExpandText
$LN17@ExpandText:
	cmp	DWORD PTR substitute$[rsp], 0
	jne	SHORT $LN18@ExpandText
	movsx	eax, BYTE PTR quoted_string$[rsp]
	test	eax, eax
	jne	$LN15@ExpandText
$LN18@ExpandText:

; 875  :                 pIdent = pDst;

	mov	rax, QWORD PTR pDst$[rsp]
	mov	QWORD PTR pIdent$[rsp], rax
$LN66@ExpandText:
$LN65@ExpandText:
$LN64@ExpandText:
$LN63@ExpandText:
$LN9@ExpandText:

; 876  :                 do {
; 877  :                     *pDst++ = *pSrc++;

	mov	rax, QWORD PTR pDst$[rsp]
	mov	rcx, QWORD PTR pSrc$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR pDst$[rsp]
	inc	rax
	mov	QWORD PTR pDst$[rsp], rax
	mov	rax, QWORD PTR pSrc$[rsp]
	inc	rax
	mov	QWORD PTR pSrc$[rsp], rax

; 878  :                 } while ( is_valid_id_char( *pSrc ));

	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isalnum
	test	eax, eax
	jne	SHORT $LN9@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN63@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN64@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN65@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN66@ExpandText

; 879  :                 *pDst = NULLC;

	mov	rax, QWORD PTR pDst$[rsp]
	mov	BYTE PTR [rax], 0

; 880  :                 sym = SymSearch( pIdent );

	mov	rcx, QWORD PTR pIdent$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 881  : #ifdef DEBUG_OUT
; 882  :                 if ( sym && ( sym->state == SYM_TMACRO || sym->state == SYM_MACRO ) ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN19@ExpandText
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 10
	je	SHORT $LN20@ExpandText
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	jne	SHORT $LN19@ExpandText
$LN20@ExpandText:

; 883  :                     DebugMsg1(( "ExpandText: symbol found: %s, %s, defined=%u, *pDst-1=%c\n", sym->name, sym->state == SYM_TMACRO ? "SYM_TMACRO" : "SYM_MACRO", sym->isdefined, *(pDst-1) ));

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 10
	jne	SHORT $LN57@ExpandText
	lea	rax, OFFSET FLAT:$SG11353
	mov	QWORD PTR tv160[rsp], rax
	jmp	SHORT $LN58@ExpandText
$LN57@ExpandText:
	lea	rax, OFFSET FLAT:$SG11354
	mov	QWORD PTR tv160[rsp], rax
$LN58@ExpandText:
	mov	rax, QWORD PTR pDst$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+40]
	shr	cl, 1
	and	cl, 1
	movzx	ecx, cl
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8, QWORD PTR tv160[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11355
	call	DoDebugMsg1
$LN19@ExpandText:

; 884  :                 }
; 885  : #endif
; 886  :                 if ( sym && sym->isdefined == TRUE ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN21@ExpandText
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN21@ExpandText

; 887  :                     if ( sym->state == SYM_TMACRO ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 10
	jne	$LN22@ExpandText

; 888  :                         /* v2.08: no expansion inside quoted strings without & */
; 889  :                         if ( quoted_string && *(pIdent-1) != '&' && *pSrc != '&' )

	movsx	eax, BYTE PTR quoted_string$[rsp]
	test	eax, eax
	je	SHORT $LN24@ExpandText
	mov	rax, QWORD PTR pIdent$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN24@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN24@ExpandText

; 890  :                             continue;

	jmp	$LN5@ExpandText
$LN24@ExpandText:

; 891  :                         if ( substitute ) {

	cmp	DWORD PTR substitute$[rsp], 0
	je	SHORT $LN25@ExpandText

; 892  :                             if ( *(pIdent-1) == '&' )

	mov	rax, QWORD PTR pIdent$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN27@ExpandText

; 893  :                                 pIdent--;

	mov	rax, QWORD PTR pIdent$[rsp]
	dec	rax
	mov	QWORD PTR pIdent$[rsp], rax
$LN27@ExpandText:

; 894  :                             if ( *pSrc == '&' )

	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN28@ExpandText

; 895  :                                 pSrc++;

	mov	rax, QWORD PTR pSrc$[rsp]
	inc	rax
	mov	QWORD PTR pSrc$[rsp], rax
$LN28@ExpandText:

; 896  :                         } else if ( pIdent > old_stringbufferend && *(pIdent-1) == '%' )

	jmp	SHORT $LN26@ExpandText
$LN25@ExpandText:
	mov	rax, QWORD PTR old_stringbufferend$[rsp]
	cmp	QWORD PTR pIdent$[rsp], rax
	jbe	SHORT $LN29@ExpandText
	mov	rax, QWORD PTR pIdent$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN29@ExpandText

; 897  :                                 pIdent--;

	mov	rax, QWORD PTR pIdent$[rsp]
	dec	rax
	mov	QWORD PTR pIdent$[rsp], rax
$LN29@ExpandText:
$LN26@ExpandText:

; 898  : 
; 899  :                         sp[lvl++] = pSrc;

	movsxd	rax, DWORD PTR lvl$[rsp]
	mov	rcx, QWORD PTR pSrc$[rsp]
	mov	QWORD PTR sp$[rsp+rax*8], rcx
	mov	eax, DWORD PTR lvl$[rsp]
	inc	eax
	mov	DWORD PTR lvl$[rsp], eax

; 900  :                         pSrc = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR pSrc$[rsp], rax

; 901  :                         //StringBufferEnd = GetAlignedPointer( pSrc, GetLiteralValue( pSrc, sym->string_ptr ) );
; 902  :                         strcpy( pSrc, sym->string_ptr );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR pSrc$[rsp]
	call	strcpy

; 903  :                         StringBufferEnd = GetAlignedPointer( pSrc, strlen( pSrc ) );

	mov	rcx, QWORD PTR pSrc$[rsp]
	call	strlen
	add	rax, 8
	and	rax, -8
	mov	rcx, QWORD PTR pSrc$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ModuleInfo+488, rax

; 904  :                         DebugMsg1(("ExpandText: %s replaced by >%s<\n", sym->name, pSrc ));

	mov	r8, QWORD PTR pSrc$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11365
	call	DoDebugMsg1

; 905  :                         pDst = pIdent;

	mov	rax, QWORD PTR pIdent$[rsp]
	mov	QWORD PTR pDst$[rsp], rax

; 906  :                         rc = STRING_EXPANDED;

	mov	DWORD PTR rc$[rsp], 1
	jmp	$LN23@ExpandText
$LN22@ExpandText:

; 907  :                     } else if ( sym->state == SYM_MACRO && sym->isfunc == TRUE ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	jne	$LN30@ExpandText
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN30@ExpandText

; 908  :                         /* expand macro functions. */
; 909  :                         char *p = pSrc;

	mov	rax, QWORD PTR pSrc$[rsp]
	mov	QWORD PTR p$4[rsp], rax
$LN10@ExpandText:

; 910  :                         int i;
; 911  :                         while ( isspace(*p) ) p++;

	mov	rax, QWORD PTR p$4[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isspace
	test	eax, eax
	je	SHORT $LN11@ExpandText
	mov	rax, QWORD PTR p$4[rsp]
	inc	rax
	mov	QWORD PTR p$4[rsp], rax
	jmp	SHORT $LN10@ExpandText
$LN11@ExpandText:

; 912  :                         /* no macro function invokation if the '(' is missing! */
; 913  :                         if ( *p == '(' ) {

	mov	rax, QWORD PTR p$4[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 40					; 00000028H
	jne	$LN32@ExpandText

; 914  :                             int j;
; 915  :                             int cnt;
; 916  :                             i = Token_Count + 1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR i$1[rsp], eax

; 917  :                             Token_Count = Tokenize( p, i, tokenarray, TOK_RESCAN );

	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$4[rsp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 918  :                             for ( j = i, cnt = 0; j < Token_Count; j++ ) {

	mov	eax, DWORD PTR i$1[rsp]
	mov	DWORD PTR j$2[rsp], eax
	mov	DWORD PTR cnt$3[rsp], 0
	jmp	SHORT $LN14@ExpandText
$LN12@ExpandText:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN14@ExpandText:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR j$2[rsp], eax
	jge	SHORT $LN13@ExpandText

; 919  :                                 if ( tokenarray[j].token == T_OP_BRACKET )

	movsxd	rax, DWORD PTR j$2[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN33@ExpandText

; 920  :                                     cnt++;

	mov	eax, DWORD PTR cnt$3[rsp]
	inc	eax
	mov	DWORD PTR cnt$3[rsp], eax
	jmp	SHORT $LN34@ExpandText
$LN33@ExpandText:

; 921  :                                 else if ( tokenarray[j].token == T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR j$2[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN35@ExpandText

; 922  :                                     cnt--;

	mov	eax, DWORD PTR cnt$3[rsp]
	dec	eax
	mov	DWORD PTR cnt$3[rsp], eax

; 923  :                                     if ( cnt == 0 ) {

	cmp	DWORD PTR cnt$3[rsp], 0
	jne	SHORT $LN36@ExpandText

; 924  :                                         j++;

	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax

; 925  :                                         break;

	jmp	SHORT $LN13@ExpandText
$LN36@ExpandText:
$LN35@ExpandText:
$LN34@ExpandText:

; 926  :                                     }
; 927  :                                 }
; 928  :                             }

	jmp	SHORT $LN12@ExpandText
$LN13@ExpandText:

; 929  :                             /* don't substitute inside quoted strings if there's no '&' */
; 930  :                             if ( quoted_string && *(pIdent-1) != '&' && tokenarray[j].token != '&' ) {

	movsx	eax, BYTE PTR quoted_string$[rsp]
	test	eax, eax
	je	SHORT $LN37@ExpandText
	mov	rax, QWORD PTR pIdent$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN37@ExpandText
	movsxd	rax, DWORD PTR j$2[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN37@ExpandText

; 931  :                                 Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax

; 932  :                                 continue;

	jmp	$LN61@ExpandText
$LN37@ExpandText:

; 933  :                             }
; 934  :                             if ( substitute ) {

	cmp	DWORD PTR substitute$[rsp], 0
	je	SHORT $LN38@ExpandText

; 935  :                                 if ( *(pIdent-1) == '&' )

	mov	rax, QWORD PTR pIdent$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN40@ExpandText

; 936  :                                     pIdent--;

	mov	rax, QWORD PTR pIdent$[rsp]
	dec	rax
	mov	QWORD PTR pIdent$[rsp], rax
$LN40@ExpandText:

; 937  :                             } else if ( pIdent > old_stringbufferend && *(pIdent-1) == '%' )

	jmp	SHORT $LN39@ExpandText
$LN38@ExpandText:
	mov	rax, QWORD PTR old_stringbufferend$[rsp]
	cmp	QWORD PTR pIdent$[rsp], rax
	jbe	SHORT $LN41@ExpandText
	mov	rax, QWORD PTR pIdent$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN41@ExpandText

; 938  :                                 pIdent--;

	mov	rax, QWORD PTR pIdent$[rsp]
	dec	rax
	mov	QWORD PTR pIdent$[rsp], rax
$LN41@ExpandText:
$LN39@ExpandText:

; 939  :                             //*StringBufferEnd = NULLC;
; 940  :                             i = RunMacro( (struct dsym *)sym, i, tokenarray, pDst, 0, &is_exitm );

	lea	rax, QWORD PTR is_exitm$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR pDst$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	RunMacro
	mov	DWORD PTR i$1[rsp], eax

; 941  :                             Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax

; 942  :                             DebugMsg1(( "ExpandText: back from RunMacro(%s), rc=%u, text returned=>%s<, rest=>%s<\n", sym->name, i, pDst, i >= 0 ? tokenarray[i].tokpos : "" ));

	cmp	DWORD PTR i$1[rsp], 0
	jl	SHORT $LN59@ExpandText
	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR tv282[rsp], rax
	jmp	SHORT $LN60@ExpandText
$LN59@ExpandText:
	lea	rax, OFFSET FLAT:$SG11378
	mov	QWORD PTR tv282[rsp], rax
$LN60@ExpandText:
	mov	rax, QWORD PTR tv282[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR pDst$[rsp]
	mov	r8d, DWORD PTR i$1[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11379
	call	DoDebugMsg1

; 943  :                             if ( i == -1 ) {

	cmp	DWORD PTR i$1[rsp], -1
	jne	SHORT $LN42@ExpandText

; 944  :                                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandText
$LN42@ExpandText:

; 945  :                             }
; 946  :                             pSrc = tokenarray[i-1].tokpos + strlen( tokenarray[i-1].string_ptr );

	mov	eax, DWORD PTR i$1[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	QWORD PTR tv292[rsp], rax
	mov	ecx, DWORD PTR i$1[rsp]
	dec	ecx
	movsxd	rcx, ecx
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+8]
	call	strlen
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR tv292[rsp]
	add	rax, QWORD PTR [rcx+rdx+24]
	mov	QWORD PTR pSrc$[rsp], rax

; 947  :                             if ( substitute && *pSrc == '&' )

	cmp	DWORD PTR substitute$[rsp], 0
	je	SHORT $LN43@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN43@ExpandText

; 948  :                                 pSrc++;

	mov	rax, QWORD PTR pSrc$[rsp]
	inc	rax
	mov	QWORD PTR pSrc$[rsp], rax
$LN43@ExpandText:

; 949  :                             sp[lvl++] = pSrc;

	movsxd	rax, DWORD PTR lvl$[rsp]
	mov	rcx, QWORD PTR pSrc$[rsp]
	mov	QWORD PTR sp$[rsp+rax*8], rcx
	mov	eax, DWORD PTR lvl$[rsp]
	inc	eax
	mov	DWORD PTR lvl$[rsp], eax

; 950  :                             pSrc = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR pSrc$[rsp], rax

; 951  :                             cnt = strlen( pDst );

	mov	rcx, QWORD PTR pDst$[rsp]
	call	strlen
	mov	DWORD PTR cnt$3[rsp], eax

; 952  :                             memcpy( pSrc, pDst, cnt + 1 );

	mov	eax, DWORD PTR cnt$3[rsp]
	inc	eax
	cdqe
	mov	r8, rax
	mov	rdx, QWORD PTR pDst$[rsp]
	mov	rcx, QWORD PTR pSrc$[rsp]
	call	memcpy

; 953  :                             StringBufferEnd = GetAlignedPointer( pSrc, cnt );

	mov	eax, DWORD PTR cnt$3[rsp]
	inc	eax
	cdqe
	add	rax, 7
	and	rax, -8
	mov	rcx, QWORD PTR pSrc$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ModuleInfo+488, rax

; 954  :                             pDst = pIdent;

	mov	rax, QWORD PTR pIdent$[rsp]
	mov	QWORD PTR pDst$[rsp], rax

; 955  :                             rc = STRING_EXPANDED;

	mov	DWORD PTR rc$[rsp], 1
$LN32@ExpandText:

; 956  :                         }

	jmp	SHORT $LN31@ExpandText
$LN30@ExpandText:

; 957  :                     } else if ( sym->state == SYM_MACRO ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	jne	SHORT $LN44@ExpandText

; 958  :                         macro_proc = TRUE;

	mov	BYTE PTR macro_proc$[rsp], 1
$LN44@ExpandText:
$LN31@ExpandText:
$LN23@ExpandText:

; 959  :                     }
; 960  :                     if ( lvl == MAX_TEXTMACRO_NESTING ) {

	cmp	DWORD PTR lvl$[rsp], 20
	jne	SHORT $LN45@ExpandText

; 961  :                         DebugMsg(("ExpandText(line=>%s<) error exit\n", line));

	mov	rdx, QWORD PTR line$[rsp]
	lea	rcx, OFFSET FLAT:$SG11384
	call	DoDebugMsg

; 962  :                         EmitError( MACRO_NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 101				; 00000065H
	call	EmitError

; 963  :                         break;

	jmp	SHORT $LN6@ExpandText
$LN45@ExpandText:
$LN21@ExpandText:

; 964  :                     }
; 965  :                 }
; 966  :             } else {

	jmp	SHORT $LN16@ExpandText
$LN15@ExpandText:

; 967  :                 if ( *pSrc == '"' || *pSrc == '\'' ) {

	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN47@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN46@ExpandText
$LN47@ExpandText:

; 968  :                     if ( quoted_string == 0 )

	movsx	eax, BYTE PTR quoted_string$[rsp]
	test	eax, eax
	jne	SHORT $LN48@ExpandText

; 969  :                         quoted_string = *pSrc;

	mov	rax, QWORD PTR pSrc$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR quoted_string$[rsp], al
	jmp	SHORT $LN49@ExpandText
$LN48@ExpandText:

; 970  :                     else if ( *pSrc == quoted_string )

	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	movsx	ecx, BYTE PTR quoted_string$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN50@ExpandText

; 971  :                         quoted_string = 0;

	mov	BYTE PTR quoted_string$[rsp], 0
$LN50@ExpandText:
$LN49@ExpandText:
$LN46@ExpandText:

; 972  :                 }
; 973  :                 *pDst++ = *pSrc++;

	mov	rax, QWORD PTR pDst$[rsp]
	mov	rcx, QWORD PTR pSrc$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR pDst$[rsp]
	inc	rax
	mov	QWORD PTR pDst$[rsp], rax
	mov	rax, QWORD PTR pSrc$[rsp]
	inc	rax
	mov	QWORD PTR pSrc$[rsp], rax
$LN16@ExpandText:

; 974  :             }
; 975  :         } /* end while */

	jmp	$LN62@ExpandText
$LN6@ExpandText:

; 976  :     }

	jmp	$LN2@ExpandText
$LN3@ExpandText:

; 977  :     *pDst++ = NULLC;

	mov	rax, QWORD PTR pDst$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR pDst$[rsp]
	inc	rax
	mov	QWORD PTR pDst$[rsp], rax

; 978  : 
; 979  :     StringBufferEnd = old_stringbufferend;

	mov	rax, QWORD PTR old_stringbufferend$[rsp]
	mov	QWORD PTR ModuleInfo+488, rax

; 980  :     if ( rc == STRING_EXPANDED ) {

	cmp	DWORD PTR rc$[rsp], 1
	jne	SHORT $LN51@ExpandText

; 981  :         memcpy( line, StringBufferEnd, pDst - StringBufferEnd );

	mov	rax, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR pDst$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR line$[rsp]
	call	memcpy

; 982  :         DebugMsg1(("ExpandText: expanded line=>%s<\n", line));

	mov	rdx, QWORD PTR line$[rsp]
	lea	rcx, OFFSET FLAT:$SG11391
	call	DoDebugMsg1
$LN51@ExpandText:

; 983  :     }
; 984  :     if ( substitute ) {

	cmp	DWORD PTR substitute$[rsp], 0
	je	SHORT $LN52@ExpandText

; 985  :         if ( rc == STRING_EXPANDED ) {

	cmp	DWORD PTR rc$[rsp], 1
	jne	SHORT $LN53@ExpandText

; 986  :             Token_Count = Tokenize( tokenarray[0].tokpos, 0, tokenarray, TOK_RESCAN );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+24]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax
$LN53@ExpandText:

; 987  :         }
; 988  :         if ( rc == STRING_EXPANDED || macro_proc ) {

	cmp	DWORD PTR rc$[rsp], 1
	je	SHORT $LN55@ExpandText
	movsx	eax, BYTE PTR macro_proc$[rsp]
	test	eax, eax
	je	SHORT $LN54@ExpandText
$LN55@ExpandText:

; 989  :             return( ExpandLine( tokenarray[0].tokpos, tokenarray ) );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+24]
	call	ExpandLine
	jmp	SHORT $LN1@ExpandText
$LN54@ExpandText:
$LN52@ExpandText:

; 990  :         }
; 991  :     }
; 992  :     return( rc );

	mov	eax, DWORD PTR rc$[rsp]
$LN1@ExpandText:

; 993  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 360				; 00000168H
	ret	0
ExpandText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
i$ = 0
parmidx$ = 4
ptr$ = 8
bracket_level$ = 16
cnt$1 = 20
currparm$ = 24
inside_literal$2 = 32
sym$ = 40
info$ = 48
size$3 = 56
varargcnt$ = 60
len$4 = 64
parm_end_delim$ = 68
cnt2$5 = 72
len$6 = 76
cnt_opnum$7 = 80
inside_angle_brackets$8 = 84
p$9 = 88
p$10 = 96
lnode$ = 104
is_exitm2$11 = 112
skipcomma$ = 116
cntgoto$12 = 120
parmstrings$ = 128
tv646 = 136
max$13 = 140
tv1508 = 144
oldifnesting$14 = 148
mi$ = 152
tmp$15 = 200
tmp$16 = 204
tv912 = 208
tv986 = 212
tv1059 = 216
tv1073 = 220
old_tokencount$17 = 224
savedStringBuffer$ = 232
tv678 = 240
tv1113 = 248
tv1419 = 256
tv310 = 264
p$18 = 272
end$19 = 280
opndx$ = 288
oldstat$20 = 400
__$ArrayPad$ = 432
macro$ = 464
idx$ = 472
tokenarray$ = 480
out$ = 488
mflags$ = 496
is_exitm$ = 504
RunMacro PROC

; 161  : {

$LN189:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 496				; 000001f0H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax

; 162  :     char        *currparm;
; 163  :     char        *savedStringBuffer = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR savedStringBuffer$[rbp], rax

; 164  :     int         i;
; 165  :     //int         start = idx-1;
; 166  :     int         parmidx;
; 167  :     int         skipcomma;
; 168  :     int         varargcnt;
; 169  :     int         bracket_level = -1;/* () level (needed for macro functions) */

	mov	DWORD PTR bracket_level$[rbp], -1

; 170  :     int         parm_end_delim;   /* parameter end delimiter */
; 171  :     //char        addprefix;
; 172  :     char        *ptr;
; 173  :     char        *parmstrings;
; 174  :     struct macro_info *info;
; 175  :     struct srcline    *lnode;
; 176  :     struct asym       *sym;
; 177  :     struct expr       opndx;
; 178  :     struct macro_instance mi;
; 179  : 
; 180  :     DebugMsg1(("RunMacro(%s, idx=%u src=>%s< ) enter, lvl=%u, locals=%04u\n", macro->sym.name, idx, tokenarray[idx].tokpos, MacroLevel, MacroLocals ));

	movzx	eax, BYTE PTR MacroLevel
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	edx, DWORD PTR MacroLocals
	mov	DWORD PTR [rsp+40], edx
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	r9, QWORD PTR [rax+rcx+24]
	mov	r8d, DWORD PTR idx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11129
	call	DoDebugMsg1

; 181  : 
; 182  :     if ( MacroLevel == MAX_MACRO_NESTING ) {

	movzx	eax, BYTE PTR MacroLevel
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN40@RunMacro

; 183  :         EmitError( NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 100				; 00000064H
	call	EmitError

; 184  :         return( -1 );

	mov	eax, -1
	jmp	$LN1@RunMacro
$LN40@RunMacro:

; 185  :     }
; 186  :     mi.parm_array = NULL;

	mov	QWORD PTR mi$[rbp+24], 0

; 187  :     info = macro->e.macroinfo;

	mov	rax, QWORD PTR macro$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR info$[rbp], rax

; 188  : #ifdef DEBUG_OUT
; 189  :     info->count++;

	mov	rax, QWORD PTR info$[rbp]
	mov	eax, DWORD PTR [rax+24]
	inc	eax
	mov	rcx, QWORD PTR info$[rbp]
	mov	DWORD PTR [rcx+24], eax

; 190  : #endif
; 191  : 
; 192  :     /* invokation of macro functions requires params enclosed in "()" */
; 193  : 
; 194  :     parm_end_delim = T_FINAL;

	mov	DWORD PTR parm_end_delim$[rbp], 0

; 195  :     if ( macro->sym.isfunc ) {

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN41@RunMacro

; 196  :         if ( tokenarray[idx].token == T_OP_BRACKET ) { /* should be always true */

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN42@RunMacro

; 197  :             idx++;

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax

; 198  :             parm_end_delim = T_CL_BRACKET;

	mov	DWORD PTR parm_end_delim$[rbp], 41	; 00000029H

; 199  :             bracket_level = 1;

	mov	DWORD PTR bracket_level$[rbp], 1
$LN42@RunMacro:

; 200  :         }
; 201  :         *out = NULLC; /* v2.08: init return value buffer */

	mov	rax, QWORD PTR out$[rbp]
	mov	BYTE PTR [rax], 0
$LN41@RunMacro:

; 202  :     }
; 203  :     /* v2.08: if macro is purged, return "void" */
; 204  :     if ( macro->sym.purged ) {

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN43@RunMacro

; 205  :         if ( bracket_level > 0 ) {

	cmp	DWORD PTR bracket_level$[rbp], 0
	jle	SHORT $LN44@RunMacro

; 206  :             for( ; bracket_level && tokenarray[idx].token != T_FINAL; idx++ )

	jmp	SHORT $LN4@RunMacro
$LN2@RunMacro:
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax
$LN4@RunMacro:
	cmp	DWORD PTR bracket_level$[rbp], 0
	je	SHORT $LN3@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN3@RunMacro

; 207  :                 if ( tokenarray[idx].token == T_OP_BRACKET )

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN46@RunMacro

; 208  :                     bracket_level++;

	mov	eax, DWORD PTR bracket_level$[rbp]
	inc	eax
	mov	DWORD PTR bracket_level$[rbp], eax
	jmp	SHORT $LN47@RunMacro
$LN46@RunMacro:

; 209  :                 else if ( tokenarray[idx].token == T_CL_BRACKET )

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN48@RunMacro

; 210  :                     bracket_level--;

	mov	eax, DWORD PTR bracket_level$[rbp]
	dec	eax
	mov	DWORD PTR bracket_level$[rbp], eax
$LN48@RunMacro:
$LN47@RunMacro:
	jmp	SHORT $LN2@RunMacro
$LN3@RunMacro:

; 211  :         } else

	jmp	SHORT $LN45@RunMacro
$LN44@RunMacro:

; 212  :             idx = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR idx$[rbp], eax
$LN45@RunMacro:

; 213  :         DebugMsg1(("RunMacro(%s) exit, macro is purged\n", macro->sym.name ));

	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11139
	call	DoDebugMsg1

; 214  :         return( idx );

	mov	eax, DWORD PTR idx$[rbp]
	jmp	$LN1@RunMacro
$LN43@RunMacro:

; 215  :     }
; 216  : 
; 217  :     DebugMsg1(( "RunMacro(%s): params=>%s< parmcnt=%u vararg=%u\n", macro->sym.name, tokenarray[idx].tokpos, info->parmcnt, macro->sym.mac_vararg ));

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	and	al, 1
	movzx	eax, al
	mov	rcx, QWORD PTR info$[rbp]
	movzx	ecx, WORD PTR [rcx]
	movsxd	rdx, DWORD PTR idx$[rbp]
	imul	rdx, rdx, 32				; 00000020H
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	r8, QWORD PTR [rax+rdx+24]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11140
	call	DoDebugMsg1

; 218  : 
; 219  :     if ( info->parmcnt ) {

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	je	SHORT $LN49@RunMacro

; 220  :         mi.parm_array = (char **)myalloca( info->parmcnt * sizeof( char * ) + PARMSTRINGSIZE );

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax]
	lea	rax, QWORD PTR [rax*8+2048]
	mov	rcx, rax
	add	rcx, 15
	cmp	rcx, rax
	ja	SHORT $LN188@RunMacro
	mov	rcx, 1152921504606846960		; 0ffffffffffffff0H
$LN188@RunMacro:
	and	rcx, -16
	mov	rax, rcx
	call	__chkstk
	sub	rsp, rax
	lea	rax, QWORD PTR [rsp+48]
	mov	QWORD PTR mi$[rbp+24], rax

; 221  :         parmstrings = (char *)(mi.parm_array + info->parmcnt);

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR mi$[rbp+24]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR parmstrings$[rbp], rax

; 222  :         /* init the macro arguments pointer */
; 223  :         currparm = parmstrings;

	mov	rax, QWORD PTR parmstrings$[rbp]
	mov	QWORD PTR currparm$[rbp], rax
$LN49@RunMacro:

; 224  :     }
; 225  : 
; 226  :     /* now get all the parameters from the original src line.
; 227  :      * macro parameters are expanded if
; 228  :      * - it is a macro function call            or
; 229  :      * - the expansion operator (%) is found
; 230  :      */
; 231  : 
; 232  :     parmidx = 0;

	mov	DWORD PTR parmidx$[rbp], 0

; 233  : #if MACROLABEL
; 234  :     if ( macro->sym.label ) {

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN50@RunMacro

; 235  :         if ( mflags & MF_LABEL ) {

	mov	eax, DWORD PTR mflags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN51@RunMacro

; 236  :             i = strlen( tokenarray[0].string_ptr );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	strlen
	mov	DWORD PTR i$[rbp], eax

; 237  :             mi.parm_array[parmidx] = currparm;

	movsxd	rax, DWORD PTR parmidx$[rbp]
	mov	rcx, QWORD PTR mi$[rbp+24]
	mov	rdx, QWORD PTR currparm$[rbp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 238  :             memcpy( currparm, tokenarray[0].string_ptr, i+1 );

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	cdqe
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 0
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	mov	rcx, QWORD PTR currparm$[rbp]
	call	memcpy

; 239  :             currparm = GetAlignedPointer( currparm, i );

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	cdqe
	add	rax, 7
	and	rax, -8
	mov	rcx, QWORD PTR currparm$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR currparm$[rbp], rax

; 240  :         } else

	jmp	SHORT $LN52@RunMacro
$LN51@RunMacro:

; 241  :             mi.parm_array[parmidx] = "";

	movsxd	rax, DWORD PTR parmidx$[rbp]
	mov	rcx, QWORD PTR mi$[rbp+24]
	lea	rdx, OFFSET FLAT:$SG11145
	mov	QWORD PTR [rcx+rax*8], rdx
$LN52@RunMacro:

; 242  :         parmidx++;

	mov	eax, DWORD PTR parmidx$[rbp]
	inc	eax
	mov	DWORD PTR parmidx$[rbp], eax
$LN50@RunMacro:

; 243  :     }
; 244  : #endif
; 245  : 
; 246  :     *is_exitm = FALSE;

	mov	rax, QWORD PTR is_exitm$[rbp]
	mov	BYTE PTR [rax], 0

; 247  : 
; 248  :     /* v2.08: allow T_FINAL to be chained, lastidx==0 is true final */
; 249  :     tokenarray[Token_Count].lastidx = 0;

	movsxd	rax, DWORD PTR ModuleInfo+496
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	DWORD PTR [rcx+rax+16], 0

; 250  : 
; 251  :     for( varargcnt = 0, skipcomma = 0; parmidx < info->parmcnt; parmidx++ ) {

	mov	DWORD PTR varargcnt$[rbp], 0
	mov	DWORD PTR skipcomma$[rbp], 0
	jmp	SHORT $LN7@RunMacro
$LN5@RunMacro:
	mov	eax, DWORD PTR parmidx$[rbp]
	inc	eax
	mov	DWORD PTR parmidx$[rbp], eax
$LN7@RunMacro:
	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax]
	cmp	DWORD PTR parmidx$[rbp], eax
	jge	$LN6@RunMacro

; 252  : 
; 253  :         /* v2.09: don't skip comma if it was the last argument.
; 254  :          * this will a) make a trailing comma trigger warning 'too many arguments...'
; 255  :          * and b), argument handling of FOR loop is significantly simplified.
; 256  :          */
; 257  :         if ( tokenarray[idx].token == T_COMMA && skipcomma )

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN53@RunMacro
	cmp	DWORD PTR skipcomma$[rbp], 0
	je	SHORT $LN53@RunMacro

; 258  :             idx++;

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax
$LN53@RunMacro:

; 259  :         skipcomma = 1;

	mov	DWORD PTR skipcomma$[rbp], 1

; 260  : 
; 261  :         if ( tokenarray[idx].token == T_FINAL ||
; 262  :             tokenarray[idx].token == parm_end_delim ||

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN56@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, DWORD PTR parm_end_delim$[rbp]
	je	SHORT $LN56@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	$LN54@RunMacro
	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN57@RunMacro
	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax]
	dec	eax
	cmp	DWORD PTR parmidx$[rbp], eax
	je	$LN54@RunMacro
$LN57@RunMacro:
$LN56@RunMacro:

; 263  :             ( tokenarray[idx].token == T_COMMA &&
; 264  :              ( macro->sym.mac_vararg == FALSE || parmidx != info->parmcnt - 1 ) ) ) {
; 265  : 
; 266  :             /* it's a blank parm */
; 267  :             if( info->parmlist[parmidx].required ) {

	movsxd	rax, DWORD PTR parmidx$[rbp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR info$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax+8]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN58@RunMacro

; 268  :                 DebugMsg1(( "RunMacro(%s.%u), parameter %u required >%s<\n", macro->sym.name, parmidx, parmidx, tokenarray[idx].tokpos ));

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR parmidx$[rbp]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11152
	call	DoDebugMsg1

; 269  :                 if ( *macro->sym.name == NULLC )

	mov	rax, QWORD PTR macro$[rbp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN59@RunMacro

; 270  :                     EmitErr( MISSING_MACRO_ARGUMENT_2, macro->sym.value + 1 );

	mov	rax, QWORD PTR macro$[rbp]
	mov	eax, DWORD PTR [rax+16]
	inc	eax
	mov	edx, eax
	mov	ecx, 87					; 00000057H
	call	EmitErr
	jmp	SHORT $LN60@RunMacro
$LN59@RunMacro:

; 271  :                 else
; 272  :                     EmitErr( MISSING_MACRO_ARGUMENT, macro->sym.name, parmidx + 1 );

	mov	eax, DWORD PTR parmidx$[rbp]
	inc	eax
	mov	r8d, eax
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 220				; 000000dcH
	call	EmitErr
$LN60@RunMacro:

; 273  :                 return( -1 );

	mov	eax, -1
	jmp	$LN1@RunMacro
$LN58@RunMacro:

; 274  :             }
; 275  :             if ( varargcnt == 0 ) {

	cmp	DWORD PTR varargcnt$[rbp], 0
	jne	SHORT $LN61@RunMacro

; 276  :                 mi.parm_array[parmidx] = info->parmlist[parmidx].deflt;

	movsxd	rax, DWORD PTR parmidx$[rbp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR info$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	movsxd	rdx, DWORD PTR parmidx$[rbp]
	mov	r8, QWORD PTR mi$[rbp+24]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR [r8+rdx*8], rax

; 277  :                 DebugMsg1(("RunMacro(%s.%u): curr (=def) parameter value=>%s<\n", macro->sym.name, parmidx, mi.parm_array[parmidx] ? parmidx, mi.parm_array[parmidx] : "NULL" ));

	movsxd	rax, DWORD PTR parmidx$[rbp]
	mov	rcx, QWORD PTR mi$[rbp+24]
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN165@RunMacro
	movsxd	rax, DWORD PTR parmidx$[rbp]
	mov	rcx, QWORD PTR mi$[rbp+24]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR tv310[rbp], rax
	jmp	SHORT $LN166@RunMacro
$LN165@RunMacro:
	lea	rax, OFFSET FLAT:$SG11156
	mov	QWORD PTR tv310[rbp], rax
$LN166@RunMacro:
	mov	r9, QWORD PTR tv310[rbp]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11157
	call	DoDebugMsg1
$LN61@RunMacro:

; 278  :             }
; 279  : 
; 280  :         } else {

	jmp	$LN55@RunMacro
$LN54@RunMacro:

; 281  :             int  inside_literal = 0;

	mov	DWORD PTR inside_literal$2[rbp], 0

; 282  :             int  inside_angle_brackets = 0;

	mov	DWORD PTR inside_angle_brackets$8[rbp], 0

; 283  :             int  old_tokencount = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR old_tokencount$17[rbp], eax

; 284  : 
; 285  :             *currparm = NULLC;

	mov	rax, QWORD PTR currparm$[rbp]
	mov	BYTE PTR [rax], 0

; 286  : 
; 287  :             DebugMsg1(( "RunMacro(%s.%u), >%s<\n", macro->sym.name, parmidx, tokenarray[idx].tokpos ));

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r9, QWORD PTR [rcx+rax+24]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11158
	call	DoDebugMsg1

; 288  : 
; 289  :             for( ptr = currparm; ( tokenarray[idx].token != T_FINAL && tokenarray[idx].token != T_COMMA ) || inside_literal; idx++ ) {

	mov	rax, QWORD PTR currparm$[rbp]
	mov	QWORD PTR ptr$[rbp], rax
	jmp	SHORT $LN10@RunMacro
$LN8@RunMacro:
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax
$LN10@RunMacro:
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN63@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN62@RunMacro
$LN63@RunMacro:
	cmp	DWORD PTR inside_literal$2[rbp], 0
	je	$LN9@RunMacro
$LN62@RunMacro:

; 290  : 
; 291  :                 /* if were're inside a literal, go up one level and continue scanning the argument */
; 292  :                 if ( tokenarray[idx].token == T_FINAL ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN64@RunMacro

; 293  :                     idx = tokenarray[idx].lastidx; /* restore token index */

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR idx$[rbp], eax

; 294  :                     inside_literal--;

	mov	eax, DWORD PTR inside_literal$2[rbp]
	dec	eax
	mov	DWORD PTR inside_literal$2[rbp], eax

; 295  :                     if ( tokenarray[idx].string_delim == '<' )

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN65@RunMacro

; 296  :                         inside_angle_brackets = 0;

	mov	DWORD PTR inside_angle_brackets$8[rbp], 0
	jmp	SHORT $LN66@RunMacro
$LN65@RunMacro:

; 297  :                     else {
; 298  :                         *ptr++ = '}';

	mov	rax, QWORD PTR ptr$[rbp]
	mov	BYTE PTR [rax], 125			; 0000007dH
	mov	rax, QWORD PTR ptr$[rbp]
	inc	rax
	mov	QWORD PTR ptr$[rbp], rax
$LN66@RunMacro:

; 299  :                     }
; 300  :                     continue;

	jmp	$LN8@RunMacro
$LN64@RunMacro:

; 301  :                 }
; 302  : 
; 303  :                 if ( tokenarray[idx].token == T_PERCENT ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	$LN67@RunMacro

; 304  :                     int max;
; 305  :                     int cnt;
; 306  :                     int cnt_opnum;
; 307  :                     /* expansion of macro parameters.
; 308  :                      * if the token behind % is not a text macro or macro function
; 309  :                      * the expression will be always expanded and evaluated.
; 310  :                      * Else it is expanded, but only evaluated if
; 311  :                      */
; 312  :                     idx++;

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax
$LN11@RunMacro:

; 313  :                     while ( tokenarray[idx].token == T_PERCENT ) idx++;

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN12@RunMacro
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax
	jmp	SHORT $LN11@RunMacro
$LN12@RunMacro:

; 314  :                     i = idx;

	mov	eax, DWORD PTR idx$[rbp]
	mov	DWORD PTR i$[rbp], eax

; 315  :                     cnt_opnum = 1;

	mov	DWORD PTR cnt_opnum$7[rbp], 1

; 316  :                     if ( tokenarray[i].token == T_ID ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN68@RunMacro

; 317  :                         sym = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rbp], rax

; 318  :                         if ( sym && sym->isdefined &&

	cmp	QWORD PTR sym$[rbp], 0
	je	SHORT $LN69@RunMacro
	mov	rax, QWORD PTR sym$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN69@RunMacro
	mov	rax, QWORD PTR sym$[rbp]
	cmp	DWORD PTR [rax+32], 10
	je	SHORT $LN70@RunMacro
	mov	rax, QWORD PTR sym$[rbp]
	cmp	DWORD PTR [rax+32], 9
	jne	SHORT $LN69@RunMacro
	mov	rax, QWORD PTR sym$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN69@RunMacro
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN69@RunMacro
$LN70@RunMacro:

; 319  :                             ( sym->state == SYM_TMACRO ||
; 320  :                              ( sym->state == SYM_MACRO && sym->isfunc == TRUE && tokenarray[i+1].token == T_OP_BRACKET ) ) )
; 321  :                             cnt_opnum = 0;

	mov	DWORD PTR cnt_opnum$7[rbp], 0
$LN69@RunMacro:
$LN68@RunMacro:

; 322  :                     }
; 323  : 
; 324  :                     for( cnt = 0; tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA; i++ ) {

	mov	DWORD PTR cnt$1[rbp], 0
	jmp	SHORT $LN15@RunMacro
$LN13@RunMacro:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN15@RunMacro:
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN14@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	$LN14@RunMacro

; 325  :                         if ( is_valid_id_first_char( *tokenarray[i].string_ptr )) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isalpha
	test	eax, eax
	jne	$LN72@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	$LN72@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN72@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN72@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN72@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	jne	$LN71@RunMacro
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 4
	and	eax, 1
	cmp	eax, 1
	jne	$LN71@RunMacro
$LN72@RunMacro:

; 326  :                             if ( tokenarray[i+1].token == T_OP_BRACKET ) {

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	$LN73@RunMacro

; 327  :                                 int cnt2;
; 328  :                                 i += 2;

	mov	eax, DWORD PTR i$[rbp]
	add	eax, 2
	mov	DWORD PTR i$[rbp], eax

; 329  :                                 for ( cnt2 = 1;cnt2 && tokenarray[i].token != T_FINAL; i++ ) {

	mov	DWORD PTR cnt2$5[rbp], 1
	jmp	SHORT $LN18@RunMacro
$LN16@RunMacro:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN18@RunMacro:
	cmp	DWORD PTR cnt2$5[rbp], 0
	je	SHORT $LN17@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN17@RunMacro

; 330  :                                     if ( tokenarray[i].token == T_OP_BRACKET )

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN74@RunMacro

; 331  :                                         cnt2++;

	mov	eax, DWORD PTR cnt2$5[rbp]
	inc	eax
	mov	DWORD PTR cnt2$5[rbp], eax
	jmp	SHORT $LN75@RunMacro
$LN74@RunMacro:

; 332  :                                     else if ( tokenarray[i].token == T_CL_BRACKET )

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN76@RunMacro

; 333  :                                         cnt2--;

	mov	eax, DWORD PTR cnt2$5[rbp]
	dec	eax
	mov	DWORD PTR cnt2$5[rbp], eax
$LN76@RunMacro:
$LN75@RunMacro:

; 334  :                                 }

	jmp	SHORT $LN16@RunMacro
$LN17@RunMacro:

; 335  :                                 i--;

	mov	eax, DWORD PTR i$[rbp]
	dec	eax
	mov	DWORD PTR i$[rbp], eax
$LN73@RunMacro:

; 336  :                             }
; 337  :                             continue;

	jmp	$LN13@RunMacro
$LN71@RunMacro:

; 338  :                         }
; 339  :                         /* count brackets */
; 340  :                         if ( parm_end_delim == T_CL_BRACKET )

	cmp	DWORD PTR parm_end_delim$[rbp], 41	; 00000029H
	jne	SHORT $LN77@RunMacro

; 341  :                             if ( tokenarray[i].token == T_OP_BRACKET )

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN78@RunMacro

; 342  :                                 cnt++;

	mov	eax, DWORD PTR cnt$1[rbp]
	inc	eax
	mov	DWORD PTR cnt$1[rbp], eax
	jmp	SHORT $LN79@RunMacro
$LN78@RunMacro:

; 343  :                             else if ( tokenarray[i].token == T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN80@RunMacro

; 344  :                                 if ( cnt == 0 )

	cmp	DWORD PTR cnt$1[rbp], 0
	jne	SHORT $LN81@RunMacro

; 345  :                                     break;

	jmp	$LN14@RunMacro
$LN81@RunMacro:

; 346  :                                 cnt--;

	mov	eax, DWORD PTR cnt$1[rbp]
	dec	eax
	mov	DWORD PTR cnt$1[rbp], eax
$LN80@RunMacro:
$LN79@RunMacro:
$LN77@RunMacro:

; 347  :                             }
; 348  : 
; 349  :                         /* stop if undelimited string occurs (need to scan for '!') */
; 350  :                         if ( tokenarray[i].token == T_STRING && tokenarray[i].string_delim == NULLC )

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN82@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	test	eax, eax
	jne	SHORT $LN82@RunMacro

; 351  :                             break;

	jmp	SHORT $LN14@RunMacro
$LN82@RunMacro:

; 352  : 
; 353  :                         /* names dot and amp are ok */
; 354  :                         if ( tokenarray[i].token == T_DOT || tokenarray[i].token == '&' || tokenarray[i].token == '%' )

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN85@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN85@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN83@RunMacro
$LN85@RunMacro:

; 355  :                             ;

	jmp	SHORT $LN84@RunMacro
$LN83@RunMacro:

; 356  :                         else
; 357  :                             cnt_opnum++; /* anything else will trigger numeric evaluation */

	mov	eax, DWORD PTR cnt_opnum$7[rbp]
	inc	eax
	mov	DWORD PTR cnt_opnum$7[rbp], eax
$LN84@RunMacro:

; 358  :                     }

	jmp	$LN13@RunMacro
$LN14@RunMacro:

; 359  : 
; 360  :                     if ( i == idx ) { /* no items except %? */

	mov	eax, DWORD PTR idx$[rbp]
	cmp	DWORD PTR i$[rbp], eax
	jne	SHORT $LN86@RunMacro

; 361  :                         idx--;

	mov	eax, DWORD PTR idx$[rbp]
	dec	eax
	mov	DWORD PTR idx$[rbp], eax

; 362  :                         continue;

	jmp	$LN8@RunMacro
$LN86@RunMacro:

; 363  :                     }
; 364  : 
; 365  :                     cnt = tokenarray[i].tokpos - tokenarray[idx].tokpos;

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR cnt$1[rbp], eax
$LN19@RunMacro:

; 366  :                     while ( isspace( *(tokenarray[idx].tokpos+cnt-1) ) ) cnt--;

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR cnt$1[rbp]
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rdx+rax+24]
	movsx	eax, BYTE PTR [rax+rcx-1]
	mov	ecx, eax
	call	isspace
	test	eax, eax
	je	SHORT $LN20@RunMacro
	mov	eax, DWORD PTR cnt$1[rbp]
	dec	eax
	mov	DWORD PTR cnt$1[rbp], eax
	jmp	SHORT $LN19@RunMacro
$LN20@RunMacro:

; 367  :                     memcpy( ptr, tokenarray[idx].tokpos, cnt );

	movsxd	rax, DWORD PTR cnt$1[rbp]
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rax+rcx+24]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	memcpy

; 368  :                     *(ptr+cnt) = NULLC;

	movsxd	rax, DWORD PTR cnt$1[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	mov	BYTE PTR [rcx+rax], 0

; 369  :                     if ( ExpandText( ptr, tokenarray, FALSE ) == ERROR ) {

	xor	r8d, r8d
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	ExpandText
	cmp	eax, -1
	jne	SHORT $LN87@RunMacro

; 370  :                         StringBufferEnd = savedStringBuffer;

	mov	rax, QWORD PTR savedStringBuffer$[rbp]
	mov	QWORD PTR ModuleInfo+488, rax

; 371  :                         return(-1);

	mov	eax, -1
	jmp	$LN1@RunMacro
$LN87@RunMacro:

; 372  :                     }
; 373  :                     idx = i - 1;

	mov	eax, DWORD PTR i$[rbp]
	dec	eax
	mov	DWORD PTR idx$[rbp], eax

; 374  :                     if ( cnt_opnum ) {

	cmp	DWORD PTR cnt_opnum$7[rbp], 0
	je	$LN88@RunMacro

; 375  :                         /* convert numeric expression into a string */
; 376  :                         max = Tokenize( ptr, Token_Count+1, tokenarray, TOK_RESCAN );

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR ptr$[rbp]
	call	Tokenize
	mov	DWORD PTR max$13[rbp], eax

; 377  :                         i = Token_Count + 1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR i$[rbp], eax

; 378  :                         DebugMsg1(( "RunMacro(%s.%u), num expansion: >%s<\n", macro->sym.name, parmidx, ptr ));

	mov	r9, QWORD PTR ptr$[rbp]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11186
	call	DoDebugMsg1

; 379  :                         /* the % operator won't accept forward references.
; 380  :                          * v2.09: flag EXPF_NOUNDEF set.
; 381  :                          */
; 382  :                         if ( EvalOperand( &i, tokenarray, max, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	BYTE PTR [rsp+32], 2
	lea	r9, QWORD PTR opndx$[rbp]
	mov	r8d, DWORD PTR max$13[rbp]
	mov	rdx, QWORD PTR tokenarray$[rbp]
	lea	rcx, QWORD PTR i$[rbp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN89@RunMacro

; 383  :                             opndx.llvalue = 0;

	mov	QWORD PTR opndx$[rbp], 0
	jmp	SHORT $LN90@RunMacro
$LN89@RunMacro:

; 384  :                         else if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rbp+60], 0
	je	SHORT $LN91@RunMacro

; 385  :                             EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 386  :                             opndx.llvalue = 0;

	mov	QWORD PTR opndx$[rbp], 0
$LN91@RunMacro:
$LN90@RunMacro:

; 387  :                         }
; 388  :                         DebugMsg1(( "RunMacro(%s.%u): num expansion, opndx.type=%d, value=%d\n", macro->sym.name, parmidx, opndx.type, opndx.value ));

	mov	eax, DWORD PTR opndx$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR opndx$[rbp+96]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11190
	call	DoDebugMsg1

; 389  :                         /* v2.08: accept constant and copy any stuff that's following */
; 390  :                         myltoa( opndx.uvalue, StringBufferEnd, ModuleInfo.radix, opndx.hvalue < 0, FALSE );

	cmp	DWORD PTR opndx$[rbp+4], 0
	jge	SHORT $LN167@RunMacro
	mov	DWORD PTR tv646[rbp], 1
	jmp	SHORT $LN168@RunMacro
$LN167@RunMacro:
	mov	DWORD PTR tv646[rbp], 0
$LN168@RunMacro:
	movzx	eax, BYTE PTR ModuleInfo+396
	mov	BYTE PTR [rsp+32], 0
	movzx	r9d, BYTE PTR tv646[rbp]
	mov	r8d, eax
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	ecx, DWORD PTR opndx$[rbp]
	call	myltoa

; 391  :                         //ptr += strlen( ptr );
; 392  :                         if ( i != max ) {

	mov	eax, DWORD PTR max$13[rbp]
	cmp	DWORD PTR i$[rbp], eax
	je	SHORT $LN92@RunMacro

; 393  :                             /* the evaluator was unable to evaluate the full expression. the rest
; 394  :                              * has to be "copied" */
; 395  :                             DebugMsg1(( "RunMacro(%s.%u): num expansion, additional token=%s\n", macro->sym.name, parmidx, tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r9, QWORD PTR [rcx+rax+24]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11192
	call	DoDebugMsg1

; 396  :                             /* just copy won't work, since <>-literals aren't handled correctly then */
; 397  :                             //EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );
; 398  :                             strcat( StringBufferEnd, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	rcx, QWORD PTR ModuleInfo+488
	call	strcat
$LN92@RunMacro:

; 399  :                         }
; 400  :                         strcpy( ptr, StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR ptr$[rbp]
	call	strcpy
$LN88@RunMacro:

; 401  :                     }
; 402  :                     ptr += strlen( ptr );

	mov	rcx, QWORD PTR ptr$[rbp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rbp], rax

; 403  :                     /**/myassert( ptr < parmstrings + PARMSTRINGSIZE );

	mov	rax, QWORD PTR parmstrings$[rbp]
	add	rax, 2048				; 00000800H
	cmp	QWORD PTR ptr$[rbp], rax
	jae	SHORT $LN169@RunMacro
	mov	DWORD PTR tv678[rbp], 0
	jmp	SHORT $LN170@RunMacro
$LN169@RunMacro:
	mov	edx, 403				; 00000193H
	lea	rcx, OFFSET FLAT:$SG11193
	call	InternalError
	mov	DWORD PTR tv678[rbp], eax
$LN170@RunMacro:

; 404  :                     continue;

	jmp	$LN8@RunMacro
$LN67@RunMacro:

; 405  :                 }
; 406  : 
; 407  :                 if ( tokenarray[idx].token == T_STRING && tokenarray[idx].string_delim == '{' ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	$LN93@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 123				; 0000007bH
	jne	$LN93@RunMacro

; 408  :                     char *p = tokenarray[idx].string_ptr;

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR p$18[rbp], rax

; 409  :                     int tmp = idx;

	mov	eax, DWORD PTR idx$[rbp]
	mov	DWORD PTR tmp$15[rbp], eax

; 410  :                     /* copy the '{' */
; 411  :                     *ptr++ = '{';

	mov	rax, QWORD PTR ptr$[rbp]
	mov	BYTE PTR [rax], 123			; 0000007bH
	mov	rax, QWORD PTR ptr$[rbp]
	inc	rax
	mov	QWORD PTR ptr$[rbp], rax

; 412  :                     /* the string must be tokenized */
; 413  :                     inside_literal++;

	mov	eax, DWORD PTR inside_literal$2[rbp]
	inc	eax
	mov	DWORD PTR inside_literal$2[rbp], eax

; 414  :                     idx = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR idx$[rbp], eax

; 415  :                     Token_Count = Tokenize( p, idx + 1, tokenarray, TOK_RESCAN | TOK_NOCURLBRACES );

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	r9d, 3
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR p$18[rbp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 416  :                     tokenarray[Token_Count].lastidx = tmp;

	movsxd	rax, DWORD PTR ModuleInfo+496
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	edx, DWORD PTR tmp$15[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 417  :                     continue;

	jmp	$LN8@RunMacro
$LN93@RunMacro:

; 418  :                 }
; 419  : 
; 420  :                 if ( inside_angle_brackets == 0 ) {

	cmp	DWORD PTR inside_angle_brackets$8[rbp], 0
	jne	$LN94@RunMacro

; 421  :                     /* track brackets for macro functions; exit if one more ')' than '(' is found */
; 422  :                     if ( bracket_level > 0 ) {

	cmp	DWORD PTR bracket_level$[rbp], 0
	jle	SHORT $LN95@RunMacro

; 423  :                         if ( tokenarray[idx].token == T_OP_BRACKET ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN96@RunMacro

; 424  :                             bracket_level++;

	mov	eax, DWORD PTR bracket_level$[rbp]
	inc	eax
	mov	DWORD PTR bracket_level$[rbp], eax
	jmp	SHORT $LN97@RunMacro
$LN96@RunMacro:

; 425  :                         } else if ( tokenarray[idx].token == T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN98@RunMacro

; 426  :                             bracket_level--;

	mov	eax, DWORD PTR bracket_level$[rbp]
	dec	eax
	mov	DWORD PTR bracket_level$[rbp], eax

; 427  :                             if ( bracket_level == 0 )

	cmp	DWORD PTR bracket_level$[rbp], 0
	jne	SHORT $LN99@RunMacro

; 428  :                                 break;

	jmp	$LN9@RunMacro
$LN99@RunMacro:
$LN98@RunMacro:
$LN97@RunMacro:
$LN95@RunMacro:

; 429  :                         }
; 430  :                     }
; 431  : 
; 432  :                     /* if there's a literal enclosed in <>, remove the delimiters and
; 433  :                      * tokenize the item (Token_Count must be adjusted, since RunMacro()
; 434  :                      * might be called later!)
; 435  :                      */
; 436  :                     if ( tokenarray[idx].token == T_STRING && tokenarray[idx].string_delim == '<' && inside_angle_brackets == 0 ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	$LN100@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	jne	$LN100@RunMacro
	cmp	DWORD PTR inside_angle_brackets$8[rbp], 0
	jne	$LN100@RunMacro

; 437  :                         char *p;
; 438  :                         int tmp;
; 439  :                         int size;
; 440  : #if 1
; 441  :                         if ( !strchr( tokenarray[idx].string_ptr, '%' ) ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	edx, 37					; 00000025H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	strchr
	test	rax, rax
	jne	SHORT $LN101@RunMacro

; 442  :                             memcpy( ptr, tokenarray[idx].string_ptr, tokenarray[idx].stringlen );

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	eax, DWORD PTR [rcx+rax+16]
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8d, eax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	memcpy

; 443  :                             ptr += tokenarray[idx].stringlen;

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rbp], rax

; 444  :                             continue;

	jmp	$LN8@RunMacro
$LN101@RunMacro:

; 445  :                         }
; 446  : #endif
; 447  :                         tmp = idx;

	mov	eax, DWORD PTR idx$[rbp]
	mov	DWORD PTR tmp$16[rbp], eax

; 448  :                         size = tokenarray[idx+1].tokpos - (tokenarray[idx].tokpos+1);

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rdx+rcx+24]
	inc	rcx
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR size$3[rbp], eax

; 449  :                         p = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR p$9[rbp], rax

; 450  :                         memcpy( p, tokenarray[idx].tokpos+1, size );

	movsxd	rax, DWORD PTR size$3[rbp]
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rdx+rcx+24]
	inc	rcx
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR p$9[rbp]
	call	memcpy
$LN21@RunMacro:

; 451  :                         while ( *(p+size-1) != '>' ) size--;

	movsxd	rax, DWORD PTR size$3[rbp]
	mov	rcx, QWORD PTR p$9[rbp]
	movsx	eax, BYTE PTR [rcx+rax-1]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN22@RunMacro
	mov	eax, DWORD PTR size$3[rbp]
	dec	eax
	mov	DWORD PTR size$3[rbp], eax
	jmp	SHORT $LN21@RunMacro
$LN22@RunMacro:

; 452  :                         *(p+size-1) = NULLC;

	movsxd	rax, DWORD PTR size$3[rbp]
	mov	rcx, QWORD PTR p$9[rbp]
	mov	BYTE PTR [rcx+rax-1], 0

; 453  :                         StringBufferEnd = GetAlignedPointer( p, size );

	mov	eax, DWORD PTR size$3[rbp]
	inc	eax
	cdqe
	add	rax, 7
	and	rax, -8
	mov	rcx, QWORD PTR p$9[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ModuleInfo+488, rax

; 454  :                         //strcpy( tmpline, tokenarray[idx].string_ptr );
; 455  :                         /* the string must be tokenized */
; 456  :                         inside_literal++;

	mov	eax, DWORD PTR inside_literal$2[rbp]
	inc	eax
	mov	DWORD PTR inside_literal$2[rbp], eax

; 457  :                         inside_angle_brackets = 1;

	mov	DWORD PTR inside_angle_brackets$8[rbp], 1

; 458  :                         idx = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR idx$[rbp], eax

; 459  :                         Token_Count = Tokenize( p, idx + 1, tokenarray, TOK_RESCAN );

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR p$9[rbp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 460  :                         tokenarray[Token_Count].lastidx = tmp;

	movsxd	rax, DWORD PTR ModuleInfo+496
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	edx, DWORD PTR tmp$16[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 461  :                         /* copy spaces located before the first token */
; 462  :                         memcpy( ptr, p, tokenarray[idx+1].tokpos - p );

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR p$9[rbp]
	mov	rax, QWORD PTR [rcx+rax+24]
	sub	rax, rdx
	mov	r8, rax
	mov	rdx, QWORD PTR p$9[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	memcpy

; 463  :                         ptr += tokenarray[idx+1].tokpos - p;

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR p$9[rbp]
	mov	rax, QWORD PTR [rcx+rax+24]
	sub	rax, rdx
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rbp], rax

; 464  :                         continue;

	jmp	$LN8@RunMacro
$LN100@RunMacro:

; 465  :                     }
; 466  :                     /* macros functions must be expanded always.
; 467  :                      * text macros are expanded only selectively
; 468  :                      */
; 469  :                     if ( tokenarray[idx].token == T_ID ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN102@RunMacro

; 470  :                         if ( sym = SymSearch( tokenarray[idx].string_ptr ) ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rbp], rax
	cmp	QWORD PTR sym$[rbp], 0
	je	$LN103@RunMacro

; 471  :                             if ( sym->state == SYM_MACRO && sym->isdefined == TRUE &&
; 472  :                                 sym->isfunc == TRUE && tokenarray[idx+1].token == T_OP_BRACKET ) {

	mov	rax, QWORD PTR sym$[rbp]
	cmp	DWORD PTR [rax+32], 9
	jne	$LN104@RunMacro
	mov	rax, QWORD PTR sym$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN104@RunMacro
	mov	rax, QWORD PTR sym$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN104@RunMacro
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	$LN104@RunMacro

; 473  :                                 bool is_exitm2;
; 474  :                                 //int oldidx = idx;
; 475  :                                 idx = RunMacro( (struct dsym *)sym, idx+1, tokenarray, ptr, 0, &is_exitm2 );

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	lea	rcx, QWORD PTR is_exitm2$11[rbp]
	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR sym$[rbp]
	call	RunMacro
	mov	DWORD PTR idx$[rbp], eax

; 476  :                                 if ( idx < 0 ) {

	cmp	DWORD PTR idx$[rbp], 0
	jge	SHORT $LN106@RunMacro

; 477  :                                     StringBufferEnd = savedStringBuffer;

	mov	rax, QWORD PTR savedStringBuffer$[rbp]
	mov	QWORD PTR ModuleInfo+488, rax

; 478  :                                     return( idx );

	mov	eax, DWORD PTR idx$[rbp]
	jmp	$LN1@RunMacro
$LN106@RunMacro:

; 479  :                                 }
; 480  :                                 ptr += strlen( ptr );

	mov	rcx, QWORD PTR ptr$[rbp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rbp], rax

; 481  :                                 /* copy spaces behind macro function call */
; 482  :                                 if ( tokenarray[idx].token != T_FINAL && tokenarray[idx].token != T_COMMA ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN107@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN107@RunMacro

; 483  :                                     i = tokenarray[idx].tokpos - ( tokenarray[idx-1].tokpos + 1 );

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, DWORD PTR idx$[rbp]
	dec	ecx
	movsxd	rcx, ecx
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rdx+rcx+24]
	inc	rcx
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR i$[rbp], eax

; 484  :                                     memcpy( ptr, tokenarray[idx-1].tokpos + 1, i );

	movsxd	rax, DWORD PTR i$[rbp]
	mov	ecx, DWORD PTR idx$[rbp]
	dec	ecx
	movsxd	rcx, ecx
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rdx+rcx+24]
	inc	rcx
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR ptr$[rbp]
	call	memcpy

; 485  :                                     ptr += i;

	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rbp], rax
$LN107@RunMacro:

; 486  :                                 }
; 487  :                                 idx--; /* adjust token index */

	mov	eax, DWORD PTR idx$[rbp]
	dec	eax
	mov	DWORD PTR idx$[rbp], eax

; 488  :                                 /**/myassert( ptr < parmstrings + PARMSTRINGSIZE );

	mov	rax, QWORD PTR parmstrings$[rbp]
	add	rax, 2048				; 00000800H
	cmp	QWORD PTR ptr$[rbp], rax
	jae	SHORT $LN171@RunMacro
	mov	DWORD PTR tv912[rbp], 0
	jmp	SHORT $LN172@RunMacro
$LN171@RunMacro:
	mov	edx, 488				; 000001e8H
	lea	rcx, OFFSET FLAT:$SG11209
	call	InternalError
	mov	DWORD PTR tv912[rbp], eax
$LN172@RunMacro:

; 489  :                                 continue;

	jmp	$LN8@RunMacro
	jmp	$LN105@RunMacro
$LN104@RunMacro:

; 490  :                             } else if ( sym->state == SYM_TMACRO && sym->isdefined == TRUE &&

	mov	rax, QWORD PTR sym$[rbp]
	cmp	DWORD PTR [rax+32], 10
	jne	$LN108@RunMacro
	mov	rax, QWORD PTR sym$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN108@RunMacro
	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN108@RunMacro
	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax+2]
	mov	ecx, DWORD PTR parmidx$[rbp]
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	and	eax, ecx
	test	eax, eax
	je	$LN108@RunMacro

; 491  :                                        ( macro->sym.predefined && ( info->autoexp & ( 1 << parmidx ) ) ) ) {
; 492  :                                 //GetLiteralValue( ptr, sym->string_ptr );
; 493  :                                 strcpy( ptr, sym->string_ptr );

	mov	rax, QWORD PTR sym$[rbp]
	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	strcpy

; 494  :                                 ExpandTMacro( ptr, tokenarray, FALSE, 0 );

	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	ExpandTMacro

; 495  :                                 ptr += strlen( ptr );

	mov	rcx, QWORD PTR ptr$[rbp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rbp], rax

; 496  :                                 /* copy spaces behind text macro */
; 497  :                                 if ( tokenarray[idx+1].token != T_FINAL && tokenarray[idx+1].token != T_COMMA ) {

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN109@RunMacro
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	$LN109@RunMacro

; 498  :                                     i = tokenarray[idx+1].tokpos - ( tokenarray[idx].tokpos + sym->name_size );

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR sym$[rbp]
	movzx	edx, BYTE PTR [rdx+72]
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	add	rcx, rdx
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR i$[rbp], eax

; 499  :                                     memcpy( ptr, tokenarray[idx].tokpos + sym->name_size, i );

	movsxd	rax, DWORD PTR i$[rbp]
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR sym$[rbp]
	movzx	edx, BYTE PTR [rdx+72]
	mov	r8, QWORD PTR tokenarray$[rbp]
	add	rdx, QWORD PTR [r8+rcx+24]
	mov	rcx, rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR ptr$[rbp]
	call	memcpy

; 500  :                                     ptr += i;

	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rbp], rax
$LN109@RunMacro:

; 501  :                                 }
; 502  :                                 /**/myassert( ptr < parmstrings + PARMSTRINGSIZE );

	mov	rax, QWORD PTR parmstrings$[rbp]
	add	rax, 2048				; 00000800H
	cmp	QWORD PTR ptr$[rbp], rax
	jae	SHORT $LN173@RunMacro
	mov	DWORD PTR tv986[rbp], 0
	jmp	SHORT $LN174@RunMacro
$LN173@RunMacro:
	mov	edx, 502				; 000001f6H
	lea	rcx, OFFSET FLAT:$SG11212
	call	InternalError
	mov	DWORD PTR tv986[rbp], eax
$LN174@RunMacro:

; 503  :                                 continue;

	jmp	$LN8@RunMacro
$LN108@RunMacro:
$LN105@RunMacro:
$LN103@RunMacro:
$LN102@RunMacro:
$LN94@RunMacro:

; 504  :                             }
; 505  :                         }
; 506  :                     }
; 507  :                 }
; 508  :                 /* get length of item */
; 509  :                 i = tokenarray[idx+1].tokpos - tokenarray[idx].tokpos;

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR i$[rbp], eax

; 510  :                 if ( !inside_literal && ( tokenarray[idx+1].token == T_COMMA ||

	cmp	DWORD PTR inside_literal$2[rbp], 0
	jne	SHORT $LN110@RunMacro
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN111@RunMacro
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, DWORD PTR parm_end_delim$[rbp]
	jne	SHORT $LN110@RunMacro
$LN111@RunMacro:
$LN23@RunMacro:

; 511  :                     tokenarray[idx+1].token == parm_end_delim ) ) {
; 512  :                     while ( isspace( *(tokenarray[idx].tokpos+i-1 ) ) ) i--;

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rbp]
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rdx+rax+24]
	movsx	eax, BYTE PTR [rax+rcx-1]
	mov	ecx, eax
	call	isspace
	test	eax, eax
	je	SHORT $LN24@RunMacro
	mov	eax, DWORD PTR i$[rbp]
	dec	eax
	mov	DWORD PTR i$[rbp], eax
	jmp	SHORT $LN23@RunMacro
$LN24@RunMacro:
$LN110@RunMacro:

; 513  :                 }
; 514  :                 /* the literal character operator ! is valid for macro arguments */
; 515  :                 if ( tokenarray[idx].token == T_STRING && tokenarray[idx].string_delim == NULLC ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	$LN112@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	test	eax, eax
	jne	$LN112@RunMacro

; 516  :                     char *p;
; 517  :                     char *end;
; 518  :                     DebugMsg1(("RunMacro(%s.%u): undelimited string >%s<, watching '!'\n", macro->sym.name, parmidx, tokenarray[idx].string_ptr ));

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r9, QWORD PTR [rcx+rax+8]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11216
	call	DoDebugMsg1

; 519  :                     p = tokenarray[idx].tokpos;

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR p$10[rbp], rax

; 520  :                     end = p + i;

	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR p$10[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR end$19[rbp], rax

; 521  :                     /**/myassert( ( ptr + i ) < parmstrings + PARMSTRINGSIZE );

	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR parmstrings$[rbp]
	add	rcx, 2048				; 00000800H
	cmp	rax, rcx
	jae	SHORT $LN175@RunMacro
	mov	DWORD PTR tv1059[rbp], 0
	jmp	SHORT $LN176@RunMacro
$LN175@RunMacro:
	mov	edx, 521				; 00000209H
	lea	rcx, OFFSET FLAT:$SG11217
	call	InternalError
	mov	DWORD PTR tv1059[rbp], eax
$LN176@RunMacro:

; 522  :                     for ( ; p < end; p++ ) {

	jmp	SHORT $LN27@RunMacro
$LN25@RunMacro:
	mov	rax, QWORD PTR p$10[rbp]
	inc	rax
	mov	QWORD PTR p$10[rbp], rax
$LN27@RunMacro:
	mov	rax, QWORD PTR end$19[rbp]
	cmp	QWORD PTR p$10[rbp], rax
	jae	SHORT $LN26@RunMacro

; 523  :                         if ( *p == '!' )

	mov	rax, QWORD PTR p$10[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN113@RunMacro

; 524  :                             p++;

	mov	rax, QWORD PTR p$10[rbp]
	inc	rax
	mov	QWORD PTR p$10[rbp], rax
$LN113@RunMacro:

; 525  :                         *ptr++ = *p;

	mov	rax, QWORD PTR ptr$[rbp]
	mov	rcx, QWORD PTR p$10[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR ptr$[rbp]
	inc	rax
	mov	QWORD PTR ptr$[rbp], rax

; 526  :                     }

	jmp	SHORT $LN25@RunMacro
$LN26@RunMacro:

; 527  :                     continue;

	jmp	$LN8@RunMacro
$LN112@RunMacro:

; 528  :                 }
; 529  :                 /**/myassert( ( ptr + i ) < parmstrings + PARMSTRINGSIZE );

	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR parmstrings$[rbp]
	add	rcx, 2048				; 00000800H
	cmp	rax, rcx
	jae	SHORT $LN177@RunMacro
	mov	DWORD PTR tv1073[rbp], 0
	jmp	SHORT $LN178@RunMacro
$LN177@RunMacro:
	mov	edx, 529				; 00000211H
	lea	rcx, OFFSET FLAT:$SG11219
	call	InternalError
	mov	DWORD PTR tv1073[rbp], eax
$LN178@RunMacro:

; 530  :                 memcpy( ptr, tokenarray[idx].tokpos, i );

	movsxd	rax, DWORD PTR i$[rbp]
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rax+rcx+24]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	memcpy

; 531  :                 ptr += i;

	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rbp], rax

; 532  : 
; 533  :             } /* end for */

	jmp	$LN8@RunMacro
$LN9@RunMacro:

; 534  : 
; 535  :             *ptr = NULLC;

	mov	rax, QWORD PTR ptr$[rbp]
	mov	BYTE PTR [rax], 0

; 536  : 
; 537  :             /* restore input status values */
; 538  :             Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$17[rbp]
	mov	DWORD PTR ModuleInfo+496, eax

; 539  :             StringBufferEnd = savedStringBuffer;

	mov	rax, QWORD PTR savedStringBuffer$[rbp]
	mov	QWORD PTR ModuleInfo+488, rax

; 540  : 
; 541  :             /* store the macro argument in the parameter array */
; 542  :             if (  macro->sym.mac_vararg && ( parmidx == info->parmcnt - 1 ) ) {

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN114@RunMacro
	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax]
	dec	eax
	cmp	DWORD PTR parmidx$[rbp], eax
	jne	$LN114@RunMacro

; 543  :                 if ( varargcnt == 0 )

	cmp	DWORD PTR varargcnt$[rbp], 0
	jne	SHORT $LN116@RunMacro

; 544  :                     mi.parm_array[parmidx] = currparm;

	movsxd	rax, DWORD PTR parmidx$[rbp]
	mov	rcx, QWORD PTR mi$[rbp+24]
	mov	rdx, QWORD PTR currparm$[rbp]
	mov	QWORD PTR [rcx+rax*8], rdx
$LN116@RunMacro:

; 545  :                 DebugMsg1(("RunMacro(%s.%u[%u]): curr parameter value=>%s<\n", macro->sym.name, parmidx, varargcnt, currparm ));

	mov	rax, QWORD PTR currparm$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR varargcnt$[rbp]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11223
	call	DoDebugMsg1

; 546  :                 currparm = ( macro->sym.predefined ? GetAlignedPointer( currparm, ptr - currparm ) : ptr );

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN179@RunMacro
	mov	rax, QWORD PTR currparm$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	add	rax, 8
	and	rax, -8
	mov	rcx, QWORD PTR currparm$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv1113[rbp], rax
	jmp	SHORT $LN180@RunMacro
$LN179@RunMacro:
	mov	rax, QWORD PTR ptr$[rbp]
	mov	QWORD PTR tv1113[rbp], rax
$LN180@RunMacro:
	mov	rax, QWORD PTR tv1113[rbp]
	mov	QWORD PTR currparm$[rbp], rax

; 547  :                 /* v2.08: Masm swallows the last trailing comma */
; 548  :                 //if ( tokenarray[idx].token == T_COMMA ) {
; 549  :                 if ( tokenarray[idx].token == T_COMMA ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN117@RunMacro

; 550  :                     idx++;

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax

; 551  :                     if ( macro->sym.isfunc == FALSE || tokenarray[idx].token != parm_end_delim ) {

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN119@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, DWORD PTR parm_end_delim$[rbp]
	je	SHORT $LN118@RunMacro
$LN119@RunMacro:

; 552  :                         parmidx--;

	mov	eax, DWORD PTR parmidx$[rbp]
	dec	eax
	mov	DWORD PTR parmidx$[rbp], eax

; 553  :                         if ( !macro->sym.predefined ) {

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN120@RunMacro

; 554  :                             *currparm++ = ',';

	mov	rax, QWORD PTR currparm$[rbp]
	mov	BYTE PTR [rax], 44			; 0000002cH
	mov	rax, QWORD PTR currparm$[rbp]
	inc	rax
	mov	QWORD PTR currparm$[rbp], rax
$LN120@RunMacro:

; 555  :                         }
; 556  :                         *currparm = NULLC;

	mov	rax, QWORD PTR currparm$[rbp]
	mov	BYTE PTR [rax], 0
$LN118@RunMacro:

; 557  :                     }
; 558  :                     skipcomma = 0;

	mov	DWORD PTR skipcomma$[rbp], 0
$LN117@RunMacro:

; 559  :                 }
; 560  :                 varargcnt++;

	mov	eax, DWORD PTR varargcnt$[rbp]
	inc	eax
	mov	DWORD PTR varargcnt$[rbp], eax
	jmp	$LN115@RunMacro
$LN114@RunMacro:

; 561  :             } else if ( *currparm ) {

	mov	rax, QWORD PTR currparm$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN121@RunMacro

; 562  :                 mi.parm_array[parmidx] = currparm;

	movsxd	rax, DWORD PTR parmidx$[rbp]
	mov	rcx, QWORD PTR mi$[rbp+24]
	mov	rdx, QWORD PTR currparm$[rbp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 563  :                 DebugMsg1(("RunMacro(%s.%u): curr parameter value=>%s<\n", macro->sym.name, parmidx, currparm ));

	mov	r9, QWORD PTR currparm$[rbp]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11230
	call	DoDebugMsg1

; 564  :                 currparm = GetAlignedPointer( currparm, ptr - currparm );

	mov	rax, QWORD PTR currparm$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	add	rax, 8
	and	rax, -8
	mov	rcx, QWORD PTR currparm$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR currparm$[rbp], rax

; 565  :             } else {

	jmp	SHORT $LN122@RunMacro
$LN121@RunMacro:

; 566  :                 mi.parm_array[parmidx] = "";

	movsxd	rax, DWORD PTR parmidx$[rbp]
	mov	rcx, QWORD PTR mi$[rbp+24]
	lea	rdx, OFFSET FLAT:$SG11231
	mov	QWORD PTR [rcx+rax*8], rdx

; 567  :                 DebugMsg1(("RunMacro(%s.%u): curr parameter value=><\n", macro->sym.name, parmidx ));

	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11232
	call	DoDebugMsg1
$LN122@RunMacro:
$LN115@RunMacro:
$LN55@RunMacro:

; 568  :             }
; 569  :         } /*end if */
; 570  :     } /* end for  */

	jmp	$LN5@RunMacro
$LN6@RunMacro:

; 571  : 
; 572  :     /* for macro functions, check for the terminating ')' */
; 573  :     if ( bracket_level >= 0 ) {

	cmp	DWORD PTR bracket_level$[rbp], 0
	jl	$LN123@RunMacro

; 574  :         if ( tokenarray[idx].token != T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	$LN125@RunMacro

; 575  :             for ( i = idx; idx < Token_Count && tokenarray[idx].token != T_CL_BRACKET; idx++ );

	mov	eax, DWORD PTR idx$[rbp]
	mov	DWORD PTR i$[rbp], eax
	jmp	SHORT $LN30@RunMacro
$LN28@RunMacro:
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax
$LN30@RunMacro:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR idx$[rbp], eax
	jge	SHORT $LN29@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN29@RunMacro
	jmp	SHORT $LN28@RunMacro
$LN29@RunMacro:

; 576  :             if ( idx == Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR idx$[rbp], eax
	jne	SHORT $LN126@RunMacro

; 577  :                 DebugMsg1(("RunMacro(%s): missing ')'\n", macro->sym.name));

	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11238
	call	DoDebugMsg1

; 578  :                 EmitError( MISSING_RIGHT_PARENTHESIS );

	mov	ecx, 244				; 000000f4H
	call	EmitError

; 579  :                 return( -1 );

	mov	eax, -1
	jmp	$LN1@RunMacro

; 580  :             } else {

	jmp	SHORT $LN127@RunMacro
$LN126@RunMacro:

; 581  :                 DebugMsg1(("RunMacro(%s): expected ')', found >%s<\n", macro->sym.name, tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11239
	call	DoDebugMsg1

; 582  :                 /* v2.09: changed to a warning only (Masm-compatible) */
; 583  :                 EmitWarn( 1, TOO_MANY_ARGUMENTS_IN_MACRO_CALL, macro->sym.name, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r9, QWORD PTR [rcx+rax+24]
	mov	rax, QWORD PTR macro$[rbp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 149				; 00000095H
	mov	ecx, 1
	call	EmitWarn
$LN127@RunMacro:
$LN125@RunMacro:

; 584  :             }
; 585  :         }
; 586  :         idx++;

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax
	jmp	$LN124@RunMacro
$LN123@RunMacro:

; 587  :     //} else if ( tokenarray[idx].token != T_FINAL && *macro->sym.name != NULLC ) { /* v2.08: changed */
; 588  :     } else if ( tokenarray[idx].token != T_FINAL ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN128@RunMacro

; 589  :         DebugMsg1(("RunMacro(%s): expected T_FINAL, found >%s<, parmidx=%u\n", macro->sym.name, tokenarray[idx].tokpos, parmidx ));

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	r9d, DWORD PTR parmidx$[rbp]
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11241
	call	DoDebugMsg1

; 590  :         /* v2.05: changed to a warning. That's what Masm does */
; 591  :         /* v2.09: don't emit a warning if it's a FOR directive
; 592  :          * (in this case, the caller knows better what to do ).
; 593  :          */
; 594  :         if ( !(mflags & MF_IGNARGS) )

	mov	eax, DWORD PTR mflags$[rbp]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN129@RunMacro

; 595  :             EmitWarn( 1, TOO_MANY_ARGUMENTS_IN_MACRO_CALL, macro->sym.name, tokenarray[idx].tokpos );

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r9, QWORD PTR [rcx+rax+24]
	mov	rax, QWORD PTR macro$[rbp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 149				; 00000095H
	mov	ecx, 1
	call	EmitWarn
$LN129@RunMacro:
$LN128@RunMacro:
$LN124@RunMacro:

; 596  :         //return( -1 );
; 597  :     }
; 598  : 
; 599  :     /* a predefined macro func with a function address? */
; 600  : 
; 601  :     if ( macro->sym.predefined == TRUE && macro->sym.func_ptr != NULL ) {

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN130@RunMacro
	mov	rax, QWORD PTR macro$[rbp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN130@RunMacro

; 602  :         mi.parmcnt = varargcnt;

	mov	eax, DWORD PTR varargcnt$[rbp]
	mov	DWORD PTR mi$[rbp+40], eax

; 603  :         macro->sym.func_ptr( &mi, out, tokenarray );

	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR out$[rbp]
	lea	rcx, QWORD PTR mi$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	call	QWORD PTR [rax+16]

; 604  :         *is_exitm = TRUE;

	mov	rax, QWORD PTR is_exitm$[rbp]
	mov	BYTE PTR [rax], 1

; 605  :         return( idx );

	mov	eax, DWORD PTR idx$[rbp]
	jmp	$LN1@RunMacro
$LN130@RunMacro:

; 606  :     }
; 607  : 
; 608  : #if 0
; 609  :     /* check if a (code) label before the macro is to be written
; 610  :      * v2.08: this is the wrong place, because the label is written
; 611  :      * AFTER possible macro functions in the arguments are evaluated.
; 612  :      * Hence this functionality has been moved to ExpandToken().
; 613  :      */
; 614  :     addprefix = FALSE;
; 615  :     if ( macro->sym.isfunc == FALSE && 
; 616  : #if MACROLABEL
; 617  :         macro->sym.label == FALSE &&
; 618  : #endif
; 619  :         label >= 0 && start > label )
; 620  :         addprefix = TRUE;
; 621  : #endif
; 622  : 
; 623  :     mi.localstart = MacroLocals;

	mov	eax, DWORD PTR MacroLocals
	mov	DWORD PTR mi$[rbp+16], eax

; 624  :     MacroLocals += info->localcnt; /* adjust global variable MacroLocals */

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax+2]
	mov	ecx, DWORD PTR MacroLocals
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR MacroLocals, eax

; 625  : 
; 626  :     /* avoid to use values stored in struct macro_info directly. A macro
; 627  :      * may be redefined within the macro! Hence copy all values that are
; 628  :      * needed later in the while loop to macro_instance!
; 629  :      */
; 630  :     mi.startline = info->data;

	mov	rax, QWORD PTR info$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR mi$[rbp+8], rax

; 631  :     mi.currline = NULL;

	mov	QWORD PTR mi$[rbp], 0

; 632  :     mi.parmcnt = info->parmcnt;

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR mi$[rbp+40], eax

; 633  : 
; 634  :     /* v2.03: no processing if macro has no lines */
; 635  :     /* v2.08: addprefix is obsolete */
; 636  :     //if ( mi.currline || addprefix ) {
; 637  :     if ( mi.startline ) {

	cmp	QWORD PTR mi$[rbp+8], 0
	je	$LN131@RunMacro

; 638  :         struct input_status oldstat;
; 639  :         int oldifnesting;
; 640  :         int cntgoto;
; 641  : 
; 642  :         DebugMsg1(("RunMacro(%s): enter assembly loop, macro level=%u\n", macro->sym.name, MacroLevel+1 ));

	movzx	eax, BYTE PTR MacroLevel
	inc	eax
	mov	r8d, eax
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11245
	call	DoDebugMsg1

; 643  :         /* v2.04: this listing is too excessive */
; 644  :         //if ( ModuleInfo.list && ( ModuleInfo.list_macro == LM_LISTMACROALL || MacroLevel == 0 ) )
; 645  :         //if ( MacroLevel == 0 && macro->sym.isfunc == FALSE && *macro->sym.name )
; 646  :         if ( macro->sym.isfunc == FALSE && *macro->sym.name )

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN132@RunMacro
	mov	rax, QWORD PTR macro$[rbp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN132@RunMacro

; 647  :             LstWriteSrcLine();

	call	LstWriteSrcLine
$LN132@RunMacro:

; 648  :         if ( !( mflags & MF_NOSAVE ) )

	mov	eax, DWORD PTR mflags$[rbp]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN133@RunMacro

; 649  :             tokenarray = PushInputStatus( &oldstat );

	lea	rcx, QWORD PTR oldstat$20[rbp]
	call	PushInputStatus
	mov	QWORD PTR tokenarray$[rbp], rax
$LN133@RunMacro:

; 650  : 
; 651  :         /*
; 652  :          * move the macro instance onto the file stack!
; 653  :          * Also reset the current linenumber!
; 654  :          */
; 655  :         mi.macro = &macro->sym;

	mov	rax, QWORD PTR macro$[rbp]
	mov	QWORD PTR mi$[rbp+32], rax

; 656  :         PushMacro( &mi );

	lea	rcx, QWORD PTR mi$[rbp]
	call	PushMacro

; 657  :         MacroLevel++;

	movzx	eax, BYTE PTR MacroLevel
	inc	al
	mov	BYTE PTR MacroLevel, al

; 658  :         oldifnesting = GetIfNestLevel(); /* v2.10 */

	call	GetIfNestLevel
	mov	DWORD PTR oldifnesting$14[rbp], eax

; 659  :         cntgoto = 0; /* v2.10 */

	mov	DWORD PTR cntgoto$12[rbp], 0
$LN187@RunMacro:
$LN186@RunMacro:
$LN185@RunMacro:
$LN31@RunMacro:

; 660  :         /* Run the assembler until we hit EXITM or ENDM.
; 661  :          * Also handle GOTO and macro label lines!
; 662  :          * v2.08 no need anymore to check the queue level
; 663  :          * v2.11 GetPreprocessedLine() replaced by GetTextLine()
; 664  :          * and PreprocessLine().
; 665  :          */
; 666  : 
; 667  :         while ( GetTextLine( CurrSource ) ) {

	mov	rcx, QWORD PTR ModuleInfo+464
	call	GetTextLine
	test	rax, rax
	je	$LN32@RunMacro

; 668  :             if ( PreprocessLine( CurrSource, tokenarray ) == 0 )

	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR ModuleInfo+464
	call	PreprocessLine
	test	eax, eax
	jne	SHORT $LN134@RunMacro

; 669  :                 continue;

	jmp	SHORT $LN31@RunMacro
$LN134@RunMacro:

; 670  :             /* skip macro label lines */
; 671  :             if ( tokenarray[0].token == T_COLON ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN135@RunMacro

; 672  :                 /* v2.05: emit the error msg here, not in StoreMacro() */
; 673  :                 if ( tokenarray[1].token != T_ID )

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN136@RunMacro

; 674  :                     EmitErr( SYNTAX_ERROR_EX, tokenarray[0].tokpos );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN137@RunMacro
$LN136@RunMacro:

; 675  :                 else if ( tokenarray[2].token != T_FINAL )

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN138@RunMacro

; 676  :                     EmitErr( SYNTAX_ERROR_EX, tokenarray[2].tokpos );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN138@RunMacro:
$LN137@RunMacro:

; 677  :                 continue;

	jmp	$LN185@RunMacro
$LN135@RunMacro:

; 678  :             }
; 679  : 
; 680  :             if ( tokenarray[0].token == T_DIRECTIVE ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	$LN139@RunMacro

; 681  :                 if ( tokenarray[0].tokval == T_EXITM ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	cmp	DWORD PTR [rcx+rax+16], 398		; 0000018eH
	jne	$LN140@RunMacro

; 682  :                     if ( ModuleInfo.list && ModuleInfo.list_macro == LM_LISTMACROALL )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN142@RunMacro
	cmp	DWORD PTR ModuleInfo+400, 2
	jne	SHORT $LN142@RunMacro

; 683  :                         LstWriteSrcLine();

	call	LstWriteSrcLine
$LN142@RunMacro:

; 684  :                     if ( tokenarray[1].token != T_FINAL ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN143@RunMacro

; 685  :                         /* v2.05: display error if there's more than 1 argument or
; 686  :                          * the argument isn't a text item
; 687  :                          */
; 688  :                         if ( tokenarray[1].token != T_STRING || tokenarray[1].string_delim != '<' )

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN146@RunMacro
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN144@RunMacro
$LN146@RunMacro:

; 689  :                             TextItemError( &tokenarray[1] );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	TextItemError
	jmp	$LN145@RunMacro
$LN144@RunMacro:

; 690  :                         else if ( Token_Count > 2 )

	cmp	DWORD PTR ModuleInfo+496, 2
	jle	SHORT $LN147@RunMacro

; 691  :                             EmitErr( SYNTAX_ERROR_EX, tokenarray[2].tokpos );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN148@RunMacro
$LN147@RunMacro:

; 692  :                         else if ( out ) { /* return value buffer may be NULL ( loop directives ) */

	cmp	QWORD PTR out$[rbp], 0
	je	$LN149@RunMacro

; 693  : 
; 694  :                             /* v2.08a: the <>-literal behind EXITM is handled specifically,
; 695  :                              * macro operator '!' within the literal is only handled
; 696  :                              * if it contains a placeholder (macro argument, macro local ).
; 697  :                              *
; 698  :                              * v2.09: handle '!' inside literal if ANY expansion occurred.
; 699  :                              * To determine text macro or macro function expansion,
; 700  :                              * check if there's a literal in the original line.
; 701  :                              */
; 702  :                             if ( mi.currline->ph_count || *(mi.currline->line+(tokenarray[1].tokpos-CurrSource)) != '<' ) {

	mov	rax, QWORD PTR mi$[rbp]
	movzx	eax, BYTE PTR [rax+8]
	test	eax, eax
	jne	SHORT $LN152@RunMacro
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR ModuleInfo+464
	mov	rax, QWORD PTR [rcx+rax+24]
	sub	rax, rdx
	mov	rcx, QWORD PTR mi$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+9]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN150@RunMacro
$LN152@RunMacro:

; 703  :                                 memcpy( out, tokenarray[1].string_ptr, tokenarray[1].stringlen + 1 );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	eax, DWORD PTR [rcx+rax+16]
	inc	eax
	mov	eax, eax
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 1
	mov	r8d, eax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	mov	rcx, QWORD PTR out$[rbp]
	call	memcpy

; 704  :                             } else {

	jmp	$LN151@RunMacro
$LN150@RunMacro:

; 705  :                                 /* since the string_ptr member has the !-operator stripped, it
; 706  :                                  * cannot be used. To get the original value of the literal,
; 707  :                                  * use tokpos.
; 708  :                                  */
; 709  :                                 int len;
; 710  :                                 len = tokenarray[2].tokpos - (tokenarray[1].tokpos+1);

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rdx+rcx+24]
	inc	rcx
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR len$6[rbp], eax

; 711  :                                 memcpy( out, tokenarray[1].tokpos+1, len );

	movsxd	rax, DWORD PTR len$6[rbp]
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rdx+rcx+24]
	inc	rcx
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR out$[rbp]
	call	memcpy
$LN33@RunMacro:

; 712  :                                 while( *(out+len-1) != '>' ) len--;

	movsxd	rax, DWORD PTR len$6[rbp]
	mov	rcx, QWORD PTR out$[rbp]
	movsx	eax, BYTE PTR [rcx+rax-1]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN34@RunMacro
	mov	eax, DWORD PTR len$6[rbp]
	dec	eax
	mov	DWORD PTR len$6[rbp], eax
	jmp	SHORT $LN33@RunMacro
$LN34@RunMacro:

; 713  :                                 *(out+len-1) = NULLC;

	movsxd	rax, DWORD PTR len$6[rbp]
	mov	rcx, QWORD PTR out$[rbp]
	mov	BYTE PTR [rcx+rax-1], 0
$LN151@RunMacro:
$LN149@RunMacro:
$LN148@RunMacro:
$LN145@RunMacro:
$LN143@RunMacro:

; 714  :                             }
; 715  :                         }
; 716  :                     }
; 717  :                     DebugMsg1(("RunMacro(%s): EXITM, result=>%s<\n", macro->sym.name, out ? out : "NULL" ));

	cmp	QWORD PTR out$[rbp], 0
	je	SHORT $LN181@RunMacro
	mov	rax, QWORD PTR out$[rbp]
	mov	QWORD PTR tv1419[rbp], rax
	jmp	SHORT $LN182@RunMacro
$LN181@RunMacro:
	lea	rax, OFFSET FLAT:$SG11267
	mov	QWORD PTR tv1419[rbp], rax
$LN182@RunMacro:
	mov	r8, QWORD PTR tv1419[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11268
	call	DoDebugMsg1

; 718  : 
; 719  :                     /* v2.10: if a goto had occured, rescan the full macro to ensure that
; 720  :                      * the "if"-nesting level is ok.
; 721  :                      */
; 722  :                     if ( cntgoto ) {

	cmp	DWORD PTR cntgoto$12[rbp], 0
	je	SHORT $LN153@RunMacro

; 723  :                         mi.currline = NULL;

	mov	QWORD PTR mi$[rbp], 0

; 724  :                         SetLineNumber( 0 );

	xor	ecx, ecx
	call	SetLineNumber

; 725  :                         SetIfNestLevel( oldifnesting );

	mov	ecx, DWORD PTR oldifnesting$14[rbp]
	call	SetIfNestLevel
$LN153@RunMacro:

; 726  :                     }
; 727  : 
; 728  :                     SkipMacro( tokenarray );

	mov	rcx, QWORD PTR tokenarray$[rbp]
	call	SkipMacro

; 729  :                     *is_exitm = TRUE;

	mov	rax, QWORD PTR is_exitm$[rbp]
	mov	BYTE PTR [rax], 1

; 730  :                     break;

	jmp	$LN32@RunMacro
	jmp	$LN141@RunMacro
$LN140@RunMacro:

; 731  : #if 0 /* won't happen anymore */
; 732  :                 } else if ( tokenarray[0].tokval == T_ENDM ) {
; 733  :                     DebugMsg1(("RunMacro(%s): ENDM\n", macro->sym.name ));
; 734  :                     break;
; 735  : #endif
; 736  :                 } else if ( tokenarray[0].tokval == T_GOTO ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	cmp	DWORD PTR [rcx+rax+16], 400		; 00000190H
	jne	$LN154@RunMacro

; 737  :                     if ( tokenarray[1].token != T_FINAL ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN155@RunMacro

; 738  :                         int len = strlen( tokenarray[1].string_ptr );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	strlen
	mov	DWORD PTR len$4[rbp], eax

; 739  :                         DebugMsg1(("RunMacro(%s): GOTO %s, MacroLevel=%u\n", macro->sym.name, tokenarray[1].string_ptr, MacroLevel ));

	movzx	eax, BYTE PTR MacroLevel
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 1
	mov	r9d, eax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	r8, QWORD PTR [rax+rcx+8]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11273
	call	DoDebugMsg1

; 740  :                         /* search for the destination line */
; 741  :                         for( i = 1, lnode = mi.startline; lnode != NULL; lnode = lnode->next, i++ ) {

	mov	DWORD PTR i$[rbp], 1
	mov	rax, QWORD PTR mi$[rbp+8]
	mov	QWORD PTR lnode$[rbp], rax
	jmp	SHORT $LN37@RunMacro
$LN35@RunMacro:
	mov	rax, QWORD PTR lnode$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR lnode$[rbp], rax
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN37@RunMacro:
	cmp	QWORD PTR lnode$[rbp], 0
	je	$LN36@RunMacro

; 742  :                             ptr = lnode->line;

	mov	rax, QWORD PTR lnode$[rbp]
	add	rax, 9
	mov	QWORD PTR ptr$[rbp], rax

; 743  :                             //DebugMsg(("RunMacro(%s): GOTO, scan line >%s< for label >%s<\n", macro->sym.name, ptr, line));
; 744  :                             if ( *ptr == ':' ) {

	mov	rax, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 58					; 0000003aH
	jne	$LN157@RunMacro

; 745  :                                 if ( lnode->ph_count ) {

	mov	rax, QWORD PTR lnode$[rbp]
	movzx	eax, BYTE PTR [rax+8]
	test	eax, eax
	je	SHORT $LN158@RunMacro

; 746  :                                     fill_placeholders( StringBufferEnd, lnode->line, mi.parmcnt, mi.localstart, mi.parm_array );

	mov	rax, QWORD PTR lnode$[rbp]
	add	rax, 9
	mov	rcx, QWORD PTR mi$[rbp+24]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, DWORD PTR mi$[rbp+16]
	mov	r8d, DWORD PTR mi$[rbp+40]
	mov	rdx, rax
	mov	rcx, QWORD PTR ModuleInfo+488
	call	fill_placeholders

; 747  :                                     ptr = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR ptr$[rbp], rax
$LN158@RunMacro:

; 748  :                                 }
; 749  :                                 ptr++;

	mov	rax, QWORD PTR ptr$[rbp]
	inc	rax
	mov	QWORD PTR ptr$[rbp], rax
$LN38@RunMacro:

; 750  :                                 while( isspace( *ptr )) ptr++;

	mov	rax, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isspace
	test	eax, eax
	je	SHORT $LN39@RunMacro
	mov	rax, QWORD PTR ptr$[rbp]
	inc	rax
	mov	QWORD PTR ptr$[rbp], rax
	jmp	SHORT $LN38@RunMacro
$LN39@RunMacro:

; 751  :                                 DebugMsg1(("RunMacro(%s): GOTO, line=>%s<\n", macro->sym.name, ptr ));

	mov	r8, QWORD PTR ptr$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11276
	call	DoDebugMsg1

; 752  :                                 /* macro labels are always case-insensitive! */
; 753  :                                 //if ( ( SymCmpFunc( ptr, tokenarray[1].string_ptr, len ) == 0 ) &&
; 754  :                                 if ( ( _memicmp( ptr, tokenarray[1].string_ptr, len ) == 0 ) &&

	movsxd	rax, DWORD PTR len$4[rbp]
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 1
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN159@RunMacro
	movsxd	rax, DWORD PTR len$4[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	mov	ecx, eax
	call	isalnum
	test	eax, eax
	jne	SHORT $LN183@RunMacro
	movsxd	rax, DWORD PTR len$4[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN183@RunMacro
	movsxd	rax, DWORD PTR len$4[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN183@RunMacro
	movsxd	rax, DWORD PTR len$4[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN183@RunMacro
	movsxd	rax, DWORD PTR len$4[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN183@RunMacro
	mov	DWORD PTR tv1508[rbp], 0
	jmp	SHORT $LN184@RunMacro
$LN183@RunMacro:
	mov	DWORD PTR tv1508[rbp], 1
$LN184@RunMacro:
	cmp	DWORD PTR tv1508[rbp], 0
	jne	SHORT $LN159@RunMacro

; 755  :                                     ( is_valid_id_char(*(ptr+len) ) == FALSE ) ) {
; 756  :                                     /* label found! */
; 757  :                                     break;

	jmp	SHORT $LN36@RunMacro
$LN159@RunMacro:
$LN157@RunMacro:

; 758  :                                 }
; 759  :                             }
; 760  :                         }

	jmp	$LN35@RunMacro
$LN36@RunMacro:

; 761  :                         if ( !lnode ) {

	cmp	QWORD PTR lnode$[rbp], 0
	jne	SHORT $LN160@RunMacro

; 762  :                             /* v2.05: display error msg BEFORE SkipMacro()! */
; 763  :                             DebugMsg1(("RunMacro(%s): GOTO, label >%s< not found!\n", macro->sym.name, tokenarray[1].string_ptr ));

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r8, QWORD PTR [rcx+rax+8]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11280
	call	DoDebugMsg1

; 764  :                             EmitErr( MACRO_LABEL_NOT_DEFINED, tokenarray[1].string_ptr );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 265				; 00000109H
	call	EmitErr

; 765  :                         } else {

	jmp	SHORT $LN161@RunMacro
$LN160@RunMacro:

; 766  :                             DebugMsg1(("RunMacro(%s): GOTO, found label >%s<\n", macro->sym.name, ptr));

	mov	r8, QWORD PTR ptr$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11281
	call	DoDebugMsg1

; 767  :                             /* v2.10: rewritten, "if"-nesting-level handling added */
; 768  :                             mi.currline = lnode;

	mov	rax, QWORD PTR lnode$[rbp]
	mov	QWORD PTR mi$[rbp], rax

; 769  :                             SetLineNumber( i );

	mov	ecx, DWORD PTR i$[rbp]
	call	SetLineNumber

; 770  :                             SetIfNestLevel( oldifnesting );

	mov	ecx, DWORD PTR oldifnesting$14[rbp]
	call	SetIfNestLevel

; 771  :                             cntgoto++;

	mov	eax, DWORD PTR cntgoto$12[rbp]
	inc	eax
	mov	DWORD PTR cntgoto$12[rbp], eax

; 772  :                             continue;

	jmp	$LN186@RunMacro
$LN161@RunMacro:

; 773  :                         }
; 774  :                     } else {

	jmp	SHORT $LN156@RunMacro
$LN155@RunMacro:

; 775  :                         EmitErr( SYNTAX_ERROR_EX, tokenarray->tokpos );

	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN156@RunMacro:

; 776  :                     }
; 777  :                     SkipMacro( tokenarray );

	mov	rcx, QWORD PTR tokenarray$[rbp]
	call	SkipMacro

; 778  :                     break;

	jmp	SHORT $LN32@RunMacro
$LN154@RunMacro:
$LN141@RunMacro:
$LN139@RunMacro:

; 779  :                 }
; 780  :             }
; 781  :             ParseLine( tokenarray );

	mov	rcx, QWORD PTR tokenarray$[rbp]
	call	ParseLine

; 782  :             if ( Options.preprocessor_stdout == TRUE )

	movzx	eax, BYTE PTR Options+141
	cmp	eax, 1
	jne	SHORT $LN162@RunMacro

; 783  :                 WritePreprocessedLine( CurrSource );

	mov	rcx, QWORD PTR ModuleInfo+464
	call	WritePreprocessedLine
$LN162@RunMacro:

; 784  : 
; 785  :             /* the macro might contain an END directive.
; 786  :              * v2.08: this doesn't mean the macro is to be cancelled.
; 787  :              * Masm continues to run it and the assembly is stopped
; 788  :              * when the top source level is reached again.
; 789  :              */
; 790  :             //if ( ModuleInfo.EndDirFound ) {
; 791  :             //    SkipMacro( tokenarray );
; 792  :             //    *is_exitm = TRUE; /* force loop exit */
; 793  :             //    break;
; 794  :             //}
; 795  :         } /* end while */

	jmp	$LN187@RunMacro
$LN32@RunMacro:

; 796  : 
; 797  :         MacroLevel--;

	movzx	eax, BYTE PTR MacroLevel
	dec	al
	mov	BYTE PTR MacroLevel, al

; 798  :         if ( !(mflags & MF_NOSAVE ) )

	mov	eax, DWORD PTR mflags$[rbp]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN163@RunMacro

; 799  :             PopInputStatus( &oldstat );

	lea	rcx, QWORD PTR oldstat$20[rbp]
	call	PopInputStatus
$LN163@RunMacro:
$LN131@RunMacro:

; 800  : 
; 801  :         /* don't use tokenarray from here on, it's invalid after PopInputStatus() */
; 802  : 
; 803  : #if FASTMEM==0
; 804  :         /* v2.06: free "old" macro line data if macro has been changed
; 805  :          * and isn't in use anymore */
; 806  :         if ( mi.startline != info->data && ( !MacroInUse( macro ) ) ) {
; 807  :             struct srcline  *curr;
; 808  :             struct srcline  *next;
; 809  :             DebugMsg1(("RunMacro(%s): macro has been changed, releasing old lines\n", macro->sym.name ));
; 810  :             for( curr = mi.startline ; curr; curr = next ) {
; 811  :                 next = curr->next;
; 812  :                 LclFree( curr );
; 813  :             }
; 814  :         }
; 815  : #endif
; 816  :     } /* end if */
; 817  : 
; 818  :     DebugMsg1(("RunMacro(%s) exit, MacroLevel=%u\n", macro->sym.name, MacroLevel ));

	movzx	eax, BYTE PTR MacroLevel
	mov	r8d, eax
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11284
	call	DoDebugMsg1

; 819  : 
; 820  :     return( idx );

	mov	eax, DWORD PTR idx$[rbp]
$LN1@RunMacro:

; 821  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+448]
	pop	rbp
	ret	0
RunMacro ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
dst$ = 48
p$ = 56
tv72 = 64
tv76 = 72
saved_value$ = 80
tmpbuf$ = 88
__$ArrayPad$ = 128
value$ = 160
buffer$ = 168
radix$ = 176
sign$ = 184
addzero$ = 192
myqtoa	PROC

; 84   : {

$LN10:
	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 85   :   char   *p;
; 86   :   char   *dst = buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR dst$[rsp], rax

; 87   :   char   tmpbuf[34];
; 88   : #ifdef DEBUG_OUT
; 89   :   uint_64 saved_value = value;

	mov	rax, QWORD PTR value$[rsp]
	mov	QWORD PTR saved_value$[rsp], rax

; 90   : #endif
; 91   :   if (sign) {

	movzx	eax, BYTE PTR sign$[rsp]
	test	eax, eax
	je	SHORT $LN5@myqtoa

; 92   :     *dst++ = '-';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 45			; 0000002dH
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 93   :     value = 0 - value;

	xor	eax, eax
	sub	rax, QWORD PTR value$[rsp]
	mov	QWORD PTR value$[rsp], rax

; 94   :   }

	jmp	SHORT $LN6@myqtoa
$LN5@myqtoa:

; 95   :   else if (value == 0) {

	cmp	QWORD PTR value$[rsp], 0
	jne	SHORT $LN7@myqtoa

; 96   :     *dst++ = '0';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 48			; 00000030H
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 97   :     *dst = NULLC;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 0

; 98   :     return(buffer);

	mov	rax, QWORD PTR buffer$[rsp]
	jmp	$LN1@myqtoa
$LN7@myqtoa:
$LN6@myqtoa:

; 99   :     }
; 100  :   for (p = &tmpbuf[33], *p = NULLC; value; value = value / radix)

	mov	eax, 1
	imul	rax, rax, 33				; 00000021H
	lea	rax, QWORD PTR tmpbuf$[rsp+rax]
	mov	QWORD PTR p$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 0
	jmp	SHORT $LN4@myqtoa
$LN2@myqtoa:
	mov	eax, DWORD PTR radix$[rsp]
	mov	QWORD PTR tv72[rsp], rax
	xor	edx, edx
	mov	rax, QWORD PTR value$[rsp]
	mov	rcx, QWORD PTR tv72[rsp]
	div	rcx
	mov	QWORD PTR value$[rsp], rax
$LN4@myqtoa:
	cmp	QWORD PTR value$[rsp], 0
	je	SHORT $LN3@myqtoa

; 101  :     *(--p) = __digits[value % radix];

	mov	rax, QWORD PTR p$[rsp]
	dec	rax
	mov	QWORD PTR p$[rsp], rax
	mov	eax, DWORD PTR radix$[rsp]
	mov	QWORD PTR tv76[rsp], rax
	xor	edx, edx
	mov	rax, QWORD PTR value$[rsp]
	mov	rcx, QWORD PTR tv76[rsp]
	div	rcx
	mov	rax, rdx
	lea	rcx, OFFSET FLAT:__digits
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [rdx], al
	jmp	SHORT $LN2@myqtoa
$LN3@myqtoa:

; 102  :   if (addzero && (*p > '9')) /* v2: add a leading '0' if first digit is alpha */

	movzx	eax, BYTE PTR addzero$[rsp]
	test	eax, eax
	je	SHORT $LN8@myqtoa
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN8@myqtoa

; 103  :     *dst++ = '0';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 48			; 00000030H
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
$LN8@myqtoa:

; 104  :   memcpy(dst, p, &tmpbuf[33] + 1 - p);

	mov	eax, 1
	imul	rax, rax, 33				; 00000021H
	lea	rax, QWORD PTR tmpbuf$[rsp+rax+1]
	sub	rax, QWORD PTR p$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	call	memcpy

; 105  :   DebugMsg1(("myltoa( value=%" I32_SPEC "Xh, out=%s, radix=%u, sign=%u, %u)\n", saved_value, buffer, radix, sign, addzero));

	movzx	eax, BYTE PTR addzero$[rsp]
	movzx	ecx, BYTE PTR sign$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR radix$[rsp]
	mov	r8, QWORD PTR buffer$[rsp]
	mov	rdx, QWORD PTR saved_value$[rsp]
	lea	rcx, OFFSET FLAT:$SG11013
	call	DoDebugMsg1

; 106  :   return(buffer);

	mov	rax, QWORD PTR buffer$[rsp]
$LN1@myqtoa:

; 107  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	ret	0
myqtoa	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
dst$ = 48
p$ = 56
saved_value$ = 64
tmpbuf$ = 72
__$ArrayPad$ = 112
value$ = 144
buffer$ = 152
radix$ = 160
sign$ = 168
addzero$ = 176
myltoa	PROC

; 54   : {

$LN10:
	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 55   :     char   *p;
; 56   :     char   *dst = buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR dst$[rsp], rax

; 57   :     char   tmpbuf[34];
; 58   : 
; 59   : #ifdef DEBUG_OUT
; 60   :     uint_32 saved_value = value;

	mov	eax, DWORD PTR value$[rsp]
	mov	DWORD PTR saved_value$[rsp], eax

; 61   : #endif
; 62   :     if ( sign ) {

	movzx	eax, BYTE PTR sign$[rsp]
	test	eax, eax
	je	SHORT $LN5@myltoa

; 63   :         *dst++ = '-';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 45			; 0000002dH
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 64   :          value = 0 - value;

	xor	eax, eax
	sub	eax, DWORD PTR value$[rsp]
	mov	DWORD PTR value$[rsp], eax
	jmp	SHORT $LN6@myltoa
$LN5@myltoa:

; 65   :     } else if ( value == 0 ) {

	cmp	DWORD PTR value$[rsp], 0
	jne	SHORT $LN7@myltoa

; 66   :         *dst++ = '0';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 48			; 00000030H
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 67   :         *dst = NULLC;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 0

; 68   :         return( buffer );

	mov	rax, QWORD PTR buffer$[rsp]
	jmp	$LN1@myltoa
$LN7@myltoa:
$LN6@myltoa:

; 69   :     }
; 70   :     for ( p = &tmpbuf[33], *p = NULLC; value; value = value / radix )

	mov	eax, 1
	imul	rax, rax, 33				; 00000021H
	lea	rax, QWORD PTR tmpbuf$[rsp+rax]
	mov	QWORD PTR p$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 0
	jmp	SHORT $LN4@myltoa
$LN2@myltoa:
	xor	edx, edx
	mov	eax, DWORD PTR value$[rsp]
	div	DWORD PTR radix$[rsp]
	mov	DWORD PTR value$[rsp], eax
$LN4@myltoa:
	cmp	DWORD PTR value$[rsp], 0
	je	SHORT $LN3@myltoa

; 71   :         *(--p) = __digits[value % radix];

	mov	rax, QWORD PTR p$[rsp]
	dec	rax
	mov	QWORD PTR p$[rsp], rax
	xor	edx, edx
	mov	eax, DWORD PTR value$[rsp]
	div	DWORD PTR radix$[rsp]
	mov	eax, edx
	mov	eax, eax
	lea	rcx, OFFSET FLAT:__digits
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [rdx], al
	jmp	SHORT $LN2@myltoa
$LN3@myltoa:

; 72   :     if ( addzero && ( *p > '9') ) /* v2: add a leading '0' if first digit is alpha */

	movzx	eax, BYTE PTR addzero$[rsp]
	test	eax, eax
	je	SHORT $LN8@myltoa
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN8@myltoa

; 73   :         *dst++ = '0';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 48			; 00000030H
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
$LN8@myltoa:

; 74   :     memcpy( dst, p, &tmpbuf[33] + 1 - p );

	mov	eax, 1
	imul	rax, rax, 33				; 00000021H
	lea	rax, QWORD PTR tmpbuf$[rsp+rax+1]
	sub	rax, QWORD PTR p$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	call	memcpy

; 75   :     DebugMsg1(("myltoa( value=%" I32_SPEC "Xh, out=%s, radix=%u, sign=%u, %u)\n", saved_value, buffer, radix, sign, addzero ));

	movzx	eax, BYTE PTR addzero$[rsp]
	movzx	ecx, BYTE PTR sign$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR radix$[rsp]
	mov	r8, QWORD PTR buffer$[rsp]
	mov	edx, DWORD PTR saved_value$[rsp]
	lea	rcx, OFFSET FLAT:$SG10990
	call	DoDebugMsg1

; 76   :     return( buffer );

	mov	rax, QWORD PTR buffer$[rsp]
$LN1@myltoa:

; 77   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
myltoa	ENDP
_TEXT	ENDS
END
