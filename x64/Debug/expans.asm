; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG11316 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	MacroLevel:BYTE
COMM	MacroLocals:DWORD
_DATA	ENDS
_BSS	SEGMENT
$SG11083 DB	01H DUP (?)
$SG11169 DB	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
__digits DB	'0123456789ABCDEF'
CONST	ENDS
_DATA	SEGMENT
$SG11284 DB	'ExpandText(line=>%s<, subst=%u ) enter', 0aH, 00H
$SG11291 DB	'SYM_TMACRO', 00H
	ORG $+5
$SG11292 DB	'SYM_MACRO', 00H
	ORG $+6
$SG11293 DB	'ExpandText: symbol found: %s, %s, defined=%u, *pDst-1=%c'
	DB	0aH, 00H
	ORG $+6
$SG11303 DB	'ExpandText: %s replaced by >%s<', 0aH, 00H
	ORG $+7
$SG11317 DB	'ExpandText: back from RunMacro(%s), rc=%u, text returned'
	DB	'=>%s<, rest=>%s<', 0aH, 00H
	ORG $+6
$SG11322 DB	'ExpandText(line=>%s<) error exit', 0aH, 00H
	ORG $+6
$SG11329 DB	'ExpandText: expanded line=>%s<', 0aH, 00H
$SG11357 DB	'ExpandTMacro(text=>%s< equm=%u lvl=%u) enter', 0aH, 00H
	ORG $+2
$SG11363 DB	'ExpandTMacro(%u): repl >%s()< by >%s<', 0aH, 00H
	ORG $+1
$SG11365 DB	'ExpandTMacro(>%s<, %u): calling ExpandTMacro, value >%s<'
	DB	0aH, 00H
	ORG $+6
$SG11367 DB	'ExpandTMacro(%u): repl >%s< by >%s<', 0aH, 00H
	ORG $+3
$SG11442 DB	'ExpandToken: %% found, line=%s', 0aH, 00H
$SG11444 DB	'ExpandToken: testing id >%s< equmode=%u', 0aH, 00H
	ORG $+7
$SG11451 DB	'ExpandToken(%s): macro function without () - not expande'
	DB	'd!', 0aH, 00H
	ORG $+4
$SG11458 DB	'ExpandToken(%s, addbr=%u): macro function expanded to >%'
	DB	's<', 0aH, 00H
	ORG $+4
$SG11466 DB	'ExpandToken(%s): macro proc at pos %u NOT expanded', 0aH
	DB	00H
	ORG $+4
$SG11469 DB	'ExpandToken(%s): macro proc to be expanded', 0aH, 00H
	ORG $+4
$SG11470 DB	'ExpandToken(%s): macro proc called', 0aH, 00H
	ORG $+4
$SG11474 DB	'ExpandToken(%s, addbr=%u): value >%s< expanded to >%s<', 0aH
	DB	00H
$SG11476 DB	'ExpandToken(%s): rest after expansion: %s', 0aH, 00H
	ORG $+5
$SG11483 DB	'ExpandToken: ''constant expected'' error', 0aH, 00H
$SG11484 DB	'ExpandToken: curr pos=%u, start expr=%u, expr size=%d', 0aH
	DB	00H
	ORG $+1
$SG11553 DB	'ExpandLine(>%s<) enter', 0aH, 00H
$SG11590 DB	'ExpandLine(%s): expansion occured, retokenize', 0aH, 00H
	ORG $+1
$SG11592 DB	'ExpandLine(>%s<) exit, rc=%u, token_count=%u', 0aH, 00H
	ORG $+2
$SG10951 DB	'myltoa( value=%Xh, out=%s, radix=%u, sign=%u, %u)', 0aH, 00H
	ORG $+5
$SG11067 DB	'RunMacro(%s, idx=%u src=>%s< ) enter, lvl=%u, locals=%04'
	DB	'u', 0aH, 00H
	ORG $+5
$SG11077 DB	'RunMacro(%s) exit, macro is purged', 0aH, 00H
	ORG $+4
$SG11078 DB	'RunMacro(%s): params=>%s< parmcnt=%u vararg=%u', 0aH, 00H
$SG11090 DB	'RunMacro(%s.%u), parameter %u required >%s<', 0aH, 00H
	ORG $+3
$SG11094 DB	'NULL', 00H
	ORG $+3
$SG11095 DB	'RunMacro(%s.%u): curr (=def) parameter value=>%s<', 0aH, 00H
	ORG $+5
$SG11096 DB	'RunMacro(%s.%u), >%s<', 0aH, 00H
	ORG $+1
$SG11124 DB	'RunMacro(%s.%u), num expansion: >%s<', 0aH, 00H
	ORG $+2
$SG11128 DB	'RunMacro(%s.%u): num expansion, opndx.type=%d, value=%d', 0aH
	DB	00H
	ORG $+7
$SG11130 DB	'RunMacro(%s.%u): num expansion, additional token=%s', 0aH
	DB	00H
	ORG $+3
$SG11131 DB	'expans.c', 00H
	ORG $+7
$SG11147 DB	'expans.c', 00H
	ORG $+7
$SG11150 DB	'expans.c', 00H
	ORG $+7
$SG11154 DB	'RunMacro(%s.%u): undelimited string >%s<, watching ''!'''
	DB	0aH, 00H
$SG11155 DB	'expans.c', 00H
	ORG $+7
$SG11157 DB	'expans.c', 00H
	ORG $+7
$SG11161 DB	'RunMacro(%s.%u[%u]): curr parameter value=>%s<', 0aH, 00H
$SG11168 DB	'RunMacro(%s.%u): curr parameter value=>%s<', 0aH, 00H
	ORG $+4
$SG11170 DB	'RunMacro(%s.%u): curr parameter value=><', 0aH, 00H
	ORG $+6
$SG11176 DB	'RunMacro(%s): missing '')''', 0aH, 00H
	ORG $+5
$SG11177 DB	'RunMacro(%s): expected '')'', found >%s<', 0aH, 00H
$SG11179 DB	'RunMacro(%s): expected T_FINAL, found >%s<, parmidx=%u', 0aH
	DB	00H
$SG11183 DB	'RunMacro(%s): enter assembly loop, macro level=%u', 0aH, 00H
	ORG $+1
$SG11205 DB	'NULL', 00H
	ORG $+7
$SG11206 DB	'RunMacro(%s): EXITM, result=>%s<', 0aH, 00H
	ORG $+6
$SG11211 DB	'RunMacro(%s): GOTO %s, MacroLevel=%u', 0aH, 00H
	ORG $+2
$SG11214 DB	'RunMacro(%s): GOTO, line=>%s<', 0aH, 00H
	ORG $+1
$SG11218 DB	'RunMacro(%s): GOTO, label >%s< not found!', 0aH, 00H
	ORG $+5
$SG11219 DB	'RunMacro(%s): GOTO, found label >%s<', 0aH, 00H
	ORG $+2
$SG11222 DB	'RunMacro(%s) exit, MacroLevel=%u', 0aH, 00H
_DATA	ENDS
PUBLIC	myltoa
PUBLIC	RunMacro
PUBLIC	ExpandText
PUBLIC	ExpandLineItems
PUBLIC	ExpandLine
PUBLIC	ExpandLiterals
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isalpha:PROC
EXTRN	__imp_isspace:PROC
EXTRN	__imp_isalnum:PROC
EXTRN	memcpy:PROC
EXTRN	__imp_strchr:PROC
EXTRN	__imp__memicmp:PROC
EXTRN	strcat:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	SymFind:PROC
EXTRN	ParseLine:PROC
EXTRN	WritePreprocessedLine:PROC
EXTRN	PreprocessLine:PROC
EXTRN	WriteCodeLabel:PROC
EXTRN	EvalOperand:PROC
EXTRN	GetTextLine:PROC
EXTRN	PushMacro:PROC
EXTRN	SetLineNumber:PROC
EXTRN	PushInputStatus:PROC
EXTRN	PopInputStatus:PROC
EXTRN	Tokenize:PROC
EXTRN	fill_placeholders:PROC
EXTRN	TextItemError:PROC
EXTRN	GetIfNestLevel:PROC
EXTRN	SetIfNestLevel:PROC
EXTRN	LstWriteSrcLine:PROC
EXTRN	InternalError:PROC
EXTRN	_RTC_AllocaHelper:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_CheckStackVars2:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	_RTC_UninitUse:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$myltoa DD imagerel $LN10
	DD	imagerel $LN10+502
	DD	imagerel $unwind$myltoa
$pdata$RunMacro DD imagerel $LN264
	DD	imagerel $LN264+11052
	DD	imagerel $unwind$RunMacro
$pdata$ExpandText DD imagerel $LN67
	DD	imagerel $LN67+2412
	DD	imagerel $unwind$ExpandText
$pdata$ExpandLineItems DD imagerel $LN14
	DD	imagerel $LN14+300
	DD	imagerel $unwind$ExpandLineItems
$pdata$ExpandLine DD imagerel $LN59
	DD	imagerel $LN59+1900
	DD	imagerel $unwind$ExpandLine
$pdata$ExpandLiterals DD imagerel $LN10
	DD	imagerel $LN10+266
	DD	imagerel $unwind$ExpandLiterals
$pdata$ExpandTMacro DD imagerel ExpandTMacro
	DD	imagerel ExpandTMacro+1141
	DD	imagerel $unwind$ExpandTMacro
$pdata$SkipMacro DD imagerel SkipMacro
	DD	imagerel SkipMacro+134
	DD	imagerel $unwind$SkipMacro
$pdata$AddTokens DD imagerel AddTokens
	DD	imagerel AddTokens+244
	DD	imagerel $unwind$AddTokens
$pdata$RebuildLine DD imagerel RebuildLine
	DD	imagerel RebuildLine+819
	DD	imagerel $unwind$RebuildLine
$pdata$ExpandToken DD imagerel ExpandToken
	DD	imagerel ExpandToken+2632
	DD	imagerel $unwind$ExpandToken
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
xdata	SEGMENT
$unwind$myltoa DD 034319H
	DD	012011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$RunMacro DD 035054919H
	DD	011c3321H
	DD	070150055H
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	0290H
$unwind$ExpandText DD 034019H
	DD	0300117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0170H
$unwind$ExpandLineItems DD 022c01H
	DD	070149218H
$unwind$ExpandLine DD 022901H
	DD	0700bf212H
$unwind$ExpandLiterals DD 022101H
	DD	0700a520eH
$unwind$ExpandTMacro DD 034519H
	DD	05e011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	02e8H
$unwind$SkipMacro DD 033619H
	DD	056010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	02a0H
$unwind$AddTokens DD 032d01H
	DD	070152219H
	DD	06014H
$unwind$RebuildLine DD 034419H
	DD	05a011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	02c0H
$unwind$ExpandToken DD 034519H
	DD	07a011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	03c8H
xdata	ENDS
CONST	SEGMENT
myltoa$rtcName$0 DB 074H
	DB	06dH
	DB	070H
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+9
myltoa$rtcVarDesc DD 048H
	DD	022H
	DQ	FLAT:myltoa$rtcName$0
	ORG $+48
myltoa$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:myltoa$rtcVarDesc
RunMacro$rtcName$0 DB 070H
	DB	061H
	DB	072H
	DB	06dH
	DB	073H
	DB	074H
	DB	072H
	DB	069H
	DB	06eH
	DB	067H
	DB	073H
	DB	00H
RunMacro$rtcName$2 DB 070H
	DB	074H
	DB	072H
	DB	00H
RunMacro$rtcName$1 DB 063H
	DB	075H
	DB	072H
	DB	072H
	DB	070H
	DB	061H
	DB	072H
	DB	06dH
	DB	00H
	ORG $+3
RunMacro$rtcName$3 DB 069H
	DB	00H
	ORG $+2
RunMacro$rtcName$4 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	078H
	DB	00H
	ORG $+2
RunMacro$rtcName$5 DB 06dH
	DB	069H
	DB	00H
	ORG $+1
ExpandText$rtcName$1 DB 073H
	DB	070H
	DB	00H
	ORG $+1
RunMacro$rtcName$6 DB 069H
	DB	073H
	DB	05fH
	DB	065H
	DB	078H
	DB	069H
	DB	074H
	DB	06dH
	DB	032H
	DB	00H
	ORG $+2
ExpandLineItems$rtcName$0 DB 06bH
	DB	00H
	ORG $+2
RunMacro$rtcName$7 DB 06fH
	DB	06cH
	DB	064H
	DB	073H
	DB	074H
	DB	061H
	DB	074H
	DB	00H
RunMacro$rtcName$8 DB 05fH
	DB	05fH
	DB	024H
	DB	041H
	DB	06cH
	DB	06cH
	DB	06fH
	DB	063H
	DB	061H
	DB	050H
	DB	061H
	DB	064H
	DB	024H
	DB	00H
	ORG $+2
RunMacro$rtcFrameData DD 06H
	DD	00H
	DQ	FLAT:RunMacro$rtcVarDesc
ExpandLine$rtcName$0 DB 063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	00H
	ORG $+2
RunMacro$rtcVarDesc DD 0238H
	DD	08H
	DQ	FLAT:RunMacro$rtcName$8
	DD	01d8H
	DD	020H
	DQ	FLAT:RunMacro$rtcName$7
	DD	01a4H
	DD	01H
	DQ	FLAT:RunMacro$rtcName$6
	DD	0128H
	DD	030H
	DQ	FLAT:RunMacro$rtcName$5
	DD	0a0H
	DD	068H
	DQ	FLAT:RunMacro$rtcName$4
	DD	044H
	DD	04H
	DQ	FLAT:RunMacro$rtcName$3
	ORG $+288
ExpandText$rtcName$0 DB 069H
	DB	073H
	DB	05fH
	DB	065H
	DB	078H
	DB	069H
	DB	074H
	DB	06dH
	DB	00H
	ORG $+7
ExpandText$rtcVarDesc DD 090H
	DD	0a0H
	DQ	FLAT:ExpandText$rtcName$1
	DD	054H
	DD	01H
	DQ	FLAT:ExpandText$rtcName$0
	ORG $+96
ExpandText$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:ExpandText$rtcVarDesc
ExpandLineItems$rtcVarDesc DD 034H
	DD	04H
	DQ	FLAT:ExpandLineItems$rtcName$0
	ORG $+48
ExpandLineItems$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:ExpandLineItems$rtcVarDesc
ExpandLine$rtcVarDesc DD 034H
	DD	04H
	DQ	FLAT:ExpandLine$rtcName$0
	ORG $+48
ExpandLine$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:ExpandLine$rtcVarDesc
ExpandTMacro$rtcName$0 DB 069H
	DB	073H
	DB	05fH
	DB	065H
	DB	078H
	DB	069H
	DB	074H
	DB	06dH
	DB	00H
	ORG $+3
ExpandTMacro$rtcName$1 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+5
ExpandTMacro$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:ExpandTMacro$rtcVarDesc
SkipMacro$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
ExpandTMacro$rtcVarDesc DD 070H
	DD	0258H
	DQ	FLAT:ExpandTMacro$rtcName$1
	DD	044H
	DD	01H
	DQ	FLAT:ExpandTMacro$rtcName$0
	ORG $+96
SkipMacro$rtcVarDesc DD 030H
	DD	0258H
	DQ	FLAT:SkipMacro$rtcName$0
	ORG $+48
SkipMacro$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:SkipMacro$rtcVarDesc
RebuildLine$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
RebuildLine$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:RebuildLine$rtcVarDesc
ExpandToken$rtcName$0 DB 074H
	DB	06dH
	DB	070H
	DB	00H
	ORG $+4
RebuildLine$rtcVarDesc DD 050H
	DD	0258H
	DQ	FLAT:RebuildLine$rtcName$0
	ORG $+48
ExpandToken$rtcName$1 DB 069H
	DB	073H
	DB	05fH
	DB	065H
	DB	078H
	DB	069H
	DB	074H
	DB	06dH
	DB	00H
	ORG $+3
ExpandToken$rtcName$2 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	078H
	DB	00H
	ORG $+2
ExpandToken$rtcName$3 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+5
ExpandToken$rtcVarDesc DD 0140H
	DD	0258H
	DQ	FLAT:ExpandToken$rtcName$3
	DD	0a0H
	DD	068H
	DQ	FLAT:ExpandToken$rtcName$2
	DD	074H
	DD	01H
	DQ	FLAT:ExpandToken$rtcName$1
	DD	044H
	DD	04H
	DQ	FLAT:ExpandToken$rtcName$0
	ORG $+192
ExpandToken$rtcFrameData DD 04H
	DD	00H
	DQ	FLAT:ExpandToken$rtcVarDesc
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
pos$ = 48
tmp$ = 68
i$ = 84
size$ = 88
addbrackets$ = 92
evaluate$ = 96
is_exitm$ = 116
opndx$ = 160
sym$ = 280
rc$ = 288
buffer$ = 320
old_tokencount$7 = 932
$T8 = 944
tv180 = 952
tv270 = 956
tv306 = 960
__$ArrayPad$ = 968
line$ = 992
pi$ = 1000
tokenarray$ = 1008
max$ = 1016
bracket_flags$ = 1024
equmode$ = 1032
ExpandToken PROC

; 1101 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 976				; 000003d0H
	mov	rdi, rsp
	mov	ecx, 244				; 000000f4H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+992]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1102 :     int pos;
; 1103 :     int tmp;
; 1104 :     int i = *pi;

	mov	rax, QWORD PTR pi$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 1105 :     int size;
; 1106 :     int addbrackets = bracket_flags;

	mov	eax, DWORD PTR bracket_flags$[rsp]
	mov	DWORD PTR addbrackets$[rsp], eax

; 1107 :     char evaluate = FALSE;

	mov	BYTE PTR evaluate$[rsp], 0

; 1108 :     //char *p;
; 1109 :     bool is_exitm;
; 1110 :     struct expr opndx;
; 1111 :     struct asym *sym;
; 1112 :     ret_code rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 1113 :     char buffer[MAX_LINE_LEN];
; 1114 : 
; 1115 :     for ( ; i < max && tokenarray[i].token != T_COMMA; i++ ) {

	jmp	SHORT $LN4@ExpandToke
$LN2@ExpandToke:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@ExpandToke:
	mov	eax, DWORD PTR max$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@ExpandToke
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	$LN3@ExpandToke

; 1116 :         /* v2.05: the '%' should only be handled as an operator if addbrackets==TRUE,
; 1117 :          * which means that the current directive is a preprocessor directive and the
; 1118 :          * expected argument is a literal (or text macro).
; 1119 :          */
; 1120 :         if ( tokenarray[i].token == T_PERCENT && addbrackets && evaluate == FALSE ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN8@ExpandToke
	cmp	DWORD PTR addbrackets$[rsp], 0
	je	SHORT $LN8@ExpandToke
	movsx	eax, BYTE PTR evaluate$[rsp]
	test	eax, eax
	jne	SHORT $LN8@ExpandToke

; 1121 :             evaluate = TRUE;

	mov	BYTE PTR evaluate$[rsp], 1

; 1122 :             addbrackets = FALSE;

	mov	DWORD PTR addbrackets$[rsp], 0

; 1123 :             equmode = FALSE;

	mov	DWORD PTR equmode$[rsp], 0

; 1124 :             pos = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR pos$[rsp], eax

; 1125 :             DebugMsg1(("ExpandToken: %% found, line=%s\n", tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11442
	call	DoDebugMsg1

; 1126 :             continue;

	jmp	$LN2@ExpandToke
$LN8@ExpandToke:

; 1127 :         }
; 1128 :         if( tokenarray[i].token == T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN9@ExpandToke

; 1129 :             sym = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 1130 :             DebugMsg1(("ExpandToken: testing id >%s< equmode=%u\n", tokenarray[i].string_ptr, equmode ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r8d, DWORD PTR equmode$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11444
	call	DoDebugMsg1

; 1131 :             /* don't check isdefined flag (which cannot occur in pass one, and this code usually runs
; 1132 :              * in pass one only!
; 1133 :              */
; 1134 :             //if( sym && sym->isdefined ) {
; 1135 :             if( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN10@ExpandToke

; 1136 :                 if ( sym->state == SYM_MACRO ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	jne	$LN11@ExpandToke

; 1137 :                     tmp = i; /* save index of macro name */

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR tmp$[rsp], eax

; 1138 :                     if ( sym->isfunc == TRUE ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN13@ExpandToke

; 1139 :                         /* ignore macro functions without a following '(' */
; 1140 :                         if ( tokenarray[i+1].token != T_OP_BRACKET ) {

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN15@ExpandToke

; 1141 :                             DebugMsg1(("ExpandToken(%s): macro function without () - not expanded!\n", sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11451
	call	DoDebugMsg1

; 1142 :                             continue;

	jmp	$LN2@ExpandToke
$LN15@ExpandToke:

; 1143 :                         }
; 1144 :                         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1145 :                         if ( equmode == TRUE ) {

	cmp	DWORD PTR equmode$[rsp], 1
	jne	$LN16@ExpandToke

; 1146 :                             i++; /* skip '(' */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1147 :                             /* go beyond the ')' */
; 1148 :                             for ( tmp = 1; i < max; i++ ) {

	mov	DWORD PTR tmp$[rsp], 1
	jmp	SHORT $LN7@ExpandToke
$LN5@ExpandToke:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@ExpandToke:
	mov	eax, DWORD PTR max$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN6@ExpandToke

; 1149 :                                 if ( tokenarray[i].token == T_OP_BRACKET )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN17@ExpandToke

; 1150 :                                     tmp++;

	mov	eax, DWORD PTR tmp$[rsp]
	inc	eax
	mov	DWORD PTR tmp$[rsp], eax
	jmp	SHORT $LN18@ExpandToke
$LN17@ExpandToke:

; 1151 :                                 else if ( tokenarray[i].token == T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN19@ExpandToke

; 1152 :                                     tmp--;

	mov	eax, DWORD PTR tmp$[rsp]
	dec	eax
	mov	DWORD PTR tmp$[rsp], eax

; 1153 :                                     if ( tmp == 0 )

	cmp	DWORD PTR tmp$[rsp], 0
	jne	SHORT $LN20@ExpandToke

; 1154 :                                         break;

	jmp	SHORT $LN6@ExpandToke
$LN20@ExpandToke:
$LN19@ExpandToke:
$LN18@ExpandToke:

; 1155 :                                 }
; 1156 :                             }

	jmp	SHORT $LN5@ExpandToke
$LN6@ExpandToke:

; 1157 :                             i--;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax

; 1158 :                             continue;

	jmp	$LN2@ExpandToke
$LN16@ExpandToke:

; 1159 :                         }
; 1160 :                         //DebugMsg1(("ExpandToken: macro function %s to be expanded\n", sym->name ));
; 1161 :                         i = RunMacro( (struct dsym *)sym, i, tokenarray, buffer,

	cmp	DWORD PTR tmp$[rsp], 1
	jne	SHORT $LN43@ExpandToke
	mov	DWORD PTR tv180[rsp], 1
	jmp	SHORT $LN44@ExpandToke
$LN43@ExpandToke:
	mov	DWORD PTR tv180[rsp], 0
$LN44@ExpandToke:
	lea	rax, QWORD PTR is_exitm$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv180[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR buffer$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	RunMacro
	mov	DWORD PTR i$[rsp], eax

; 1162 : #if MACROLABEL
; 1163 :                                      (tmp == 1 ? MF_LABEL : 0),
; 1164 : #else
; 1165 :                                      0,
; 1166 : #endif
; 1167 :                                      &is_exitm );
; 1168 :                         if ( i == -1 )

	cmp	DWORD PTR i$[rsp], -1
	jne	SHORT $LN21@ExpandToke

; 1169 :                             return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandToke
$LN21@ExpandToke:

; 1170 :                         DebugMsg1(("ExpandToken(%s, addbr=%u): macro function expanded to >%s<\n", sym->name, addbrackets, buffer));

	lea	r9, QWORD PTR buffer$[rsp]
	mov	r8d, DWORD PTR addbrackets$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11458
	call	DoDebugMsg1

; 1171 :                         /* expand text, but don't if macro was at position 0 (might be a text macro definition directive */
; 1172 :                         /* v2.09: don't expand further if addbrackets is set */
; 1173 :                         if ( tmp && (!addbrackets) && ( ERROR == ExpandTMacro( buffer, tokenarray, equmode, 0 ) ) )

	cmp	DWORD PTR tmp$[rsp], 0
	je	SHORT $LN22@ExpandToke
	cmp	DWORD PTR addbrackets$[rsp], 0
	jne	SHORT $LN22@ExpandToke
	xor	r9d, r9d
	mov	r8d, DWORD PTR equmode$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	ExpandTMacro
	cmp	eax, -1
	jne	SHORT $LN22@ExpandToke

; 1174 :                             return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandToke
$LN22@ExpandToke:

; 1175 :                         /* get size of string to replace ( must be done before AddTokens() */
; 1176 :                         size = ( tokenarray[i-1].tokpos + 1) - tokenarray[tmp].tokpos;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	inc	rax
	movsxd	rcx, DWORD PTR tmp$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	sub	rax, QWORD PTR [rdx+rcx+24]
	mov	DWORD PTR size$[rsp], eax

; 1177 :                         AddTokens( tokenarray, tmp+1, tmp+1 - i, Token_Count );

	mov	eax, DWORD PTR tmp$[rsp]
	inc	eax
	sub	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR tmp$[rsp]
	inc	ecx
	mov	r9d, DWORD PTR ModuleInfo+496
	mov	r8d, eax
	mov	edx, ecx
	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	AddTokens

; 1178 :                         Token_Count += (tmp+1) - i;

	mov	eax, DWORD PTR tmp$[rsp]
	inc	eax
	sub	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR ModuleInfo+496
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+496, eax

; 1179 :                         if ( Token_Count < max ) /* take care not to read beyond T_FINAL */

	mov	eax, DWORD PTR max$[rsp]
	cmp	DWORD PTR ModuleInfo+496, eax
	jge	SHORT $LN23@ExpandToke

; 1180 :                             max = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR max$[rsp], eax
$LN23@ExpandToke:

; 1181 :                         if ( ERROR == RebuildLine( buffer, tmp, tokenarray,

	movsxd	rax, DWORD PTR tmp$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR line$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	sub	rax, rdx
	mov	ecx, DWORD PTR addbrackets$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR size$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR tmp$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	RebuildLine
	cmp	eax, -1
	jne	SHORT $LN24@ExpandToke

; 1182 :                                                   size, tokenarray[tmp].tokpos - line, addbrackets ) )
; 1183 :                             return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandToke
$LN24@ExpandToke:

; 1184 :                         rc = STRING_EXPANDED;

	mov	DWORD PTR rc$[rsp], 1

; 1185 :                         i = tmp;

	mov	eax, DWORD PTR tmp$[rsp]
	mov	DWORD PTR i$[rsp], eax

; 1186 :                     } else {

	jmp	$LN14@ExpandToke
$LN13@ExpandToke:

; 1187 :                         /* a macro proc is expanded at pos 0 or pos 2
; 1188 :                          * (or at pos 1 if sym->label is on)
; 1189 :                          */
; 1190 :                         if ( i == 0 ||
; 1191 :                             ( i == 2 && ( tokenarray[1].token == T_COLON ||
; 1192 :                                          tokenarray[1].token == T_DBL_COLON ))
; 1193 : #if MACROLABEL
; 1194 :                             || ( i == 1 && sym->label )

	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN27@ExpandToke
	cmp	DWORD PTR i$[rsp], 2
	jne	SHORT $LN28@ExpandToke
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN27@ExpandToke
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 13
	je	SHORT $LN27@ExpandToke
$LN28@ExpandToke:
	cmp	DWORD PTR i$[rsp], 1
	jne	SHORT $LN25@ExpandToke
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN25@ExpandToke
$LN27@ExpandToke:

; 1195 : #endif
; 1196 :                            )
; 1197 :                             ;

	jmp	SHORT $LN26@ExpandToke
$LN25@ExpandToke:

; 1198 :                         else {
; 1199 :                             DebugMsg1(("ExpandToken(%s): macro proc at pos %u NOT expanded\n", sym->name, i ));

	mov	r8d, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11466
	call	DoDebugMsg1

; 1200 : #if 1 /* v2.03: no error, just don't expand! */
; 1201 :                             continue;

	jmp	$LN2@ExpandToke
$LN26@ExpandToke:

; 1202 : #else
; 1203 :                             return( EmitErr( SYNTAX_ERROR_EX, sym->name ) );
; 1204 : #endif
; 1205 :                         }
; 1206 :                         /* v2.08: write optional code label. This has been
; 1207 :                          * moved out from RunMacro().
; 1208 :                          */
; 1209 :                         if ( i == 2 ) {

	cmp	DWORD PTR i$[rsp], 2
	jne	SHORT $LN29@ExpandToke

; 1210 :                             if ( ERROR == WriteCodeLabel( line, tokenarray ) )

	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR line$[rsp]
	call	WriteCodeLabel
	cmp	eax, -1
	jne	SHORT $LN30@ExpandToke

; 1211 :                                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandToke
$LN30@ExpandToke:
$LN29@ExpandToke:

; 1212 :                         }
; 1213 :                         //buffer[0] = NULLC; /* nothing should be returned, just to be safe */
; 1214 :                         DebugMsg1(("ExpandToken(%s): macro proc to be expanded\n", sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11469
	call	DoDebugMsg1

; 1215 :                         i = RunMacro( (struct dsym *)sym, i+1, tokenarray, NULL,

	cmp	DWORD PTR i$[rsp], 1
	jne	SHORT $LN45@ExpandToke
	mov	DWORD PTR tv270[rsp], 1
	jmp	SHORT $LN46@ExpandToke
$LN45@ExpandToke:
	mov	DWORD PTR tv270[rsp], 0
$LN46@ExpandToke:
	mov	eax, DWORD PTR tv270[rsp]
	or	eax, 2
	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx
	lea	rdx, QWORD PTR is_exitm$[rsp]
	mov	QWORD PTR [rsp+40], rdx
	mov	DWORD PTR [rsp+32], eax
	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, ecx
	mov	rcx, QWORD PTR sym$[rsp]
	call	RunMacro
	mov	DWORD PTR i$[rsp], eax

; 1216 : #if MACROLABEL
; 1217 :                                      MF_NOSAVE | (i == 1 ? MF_LABEL : 0),
; 1218 : #else
; 1219 :                                      MF_NOSAVE,
; 1220 : #endif
; 1221 :                                      &is_exitm );
; 1222 :                         DebugMsg1(("ExpandToken(%s): macro proc called\n", sym->name));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11470
	call	DoDebugMsg1

; 1223 :                         if ( i == -1 )

	cmp	DWORD PTR i$[rsp], -1
	jne	SHORT $LN31@ExpandToke

; 1224 :                             return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandToke
$LN31@ExpandToke:

; 1225 : #if 0
; 1226 :                         /* it's possible to "hide" the EXITM directive when the
; 1227 :                          * macro lines are read. But it's not useful for macro
; 1228 :                          * procs to check if exitm has been executed, because
; 1229 :                          * Masm simply will ignore anything that's "returned".
; 1230 :                          */
; 1231 :                         if ( is_exitm ) {
; 1232 :                             DebugMsg(("ExpandToken: EXITM in macro procedure!\n" ));
; 1233 :                             strcat( buffer, tokenarray[tmp].tokpos );
; 1234 :                             strcpy( line, buffer );
; 1235 :                             rc = STRING_EXPANDED;
; 1236 :                         } else
; 1237 : #endif
; 1238 :                             return( EMPTY ); /* no further processing */

	mov	eax, -2
	jmp	$LN1@ExpandToke

; 1239 :                         break;

	jmp	$LN3@ExpandToke
$LN14@ExpandToke:

; 1240 :                     }

	jmp	$LN12@ExpandToke
$LN11@ExpandToke:

; 1241 :                 } else if( sym->state == SYM_TMACRO ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 10
	jne	$LN32@ExpandToke

; 1242 : 
; 1243 :                     //GetLiteralValue( buffer, sym->string_ptr );
; 1244 :                     strcpy( buffer, sym->string_ptr );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+16]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	strcpy

; 1245 :                     if ( ERROR == ExpandTMacro( buffer, tokenarray, equmode, 0 ) )

	xor	r9d, r9d
	mov	r8d, DWORD PTR equmode$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	ExpandTMacro
	cmp	eax, -1
	jne	SHORT $LN33@ExpandToke

; 1246 :                         return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandToke
$LN33@ExpandToke:

; 1247 :                     DebugMsg1(("ExpandToken(%s, addbr=%u): value >%s< expanded to >%s<\n", sym->name, addbrackets, sym->string_ptr, buffer ));

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r9, QWORD PTR [rax+16]
	mov	r8d, DWORD PTR addbrackets$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11474
	call	DoDebugMsg1

; 1248 :                     if ( ERROR == RebuildLine( buffer, i, tokenarray, strlen( tokenarray[i].string_ptr ),

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR line$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	sub	rax, rdx
	mov	QWORD PTR tv306[rsp], rax
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+8]
	call	strlen
	mov	ecx, DWORD PTR addbrackets$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR tv306[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, eax
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	RebuildLine
	cmp	eax, -1
	jne	SHORT $LN34@ExpandToke

; 1249 :                                               tokenarray[i].tokpos - line, addbrackets ) )
; 1250 :                         return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandToke
$LN34@ExpandToke:

; 1251 :                     rc = STRING_EXPANDED;

	mov	DWORD PTR rc$[rsp], 1

; 1252 :                     DebugMsg1(("ExpandToken(%s): rest after expansion: %s\n", sym->name, tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11476
	call	DoDebugMsg1
$LN32@ExpandToke:
$LN12@ExpandToke:
$LN10@ExpandToke:
$LN9@ExpandToke:

; 1253 :                 }
; 1254 :             }
; 1255 :         }
; 1256 :     }

	jmp	$LN2@ExpandToke
$LN3@ExpandToke:

; 1257 :     *pi = i;

	mov	rax, QWORD PTR pi$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 1258 :     if ( evaluate ) {

	movsx	eax, BYTE PTR evaluate$[rsp]
	test	eax, eax
	je	$LN35@ExpandToke

; 1259 :         int old_tokencount = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR old_tokencount$7[rsp], eax

; 1260 :         if ( i == (pos+1) ) { /* just a single %? */

	mov	eax, DWORD PTR pos$[rsp]
	inc	eax
	cmp	DWORD PTR i$[rsp], eax
	jne	SHORT $LN36@ExpandToke

; 1261 :             opndx.value = 0;

	mov	DWORD PTR opndx$[rsp], 0

; 1262 :             i = pos;

	mov	eax, DWORD PTR pos$[rsp]
	mov	DWORD PTR i$[rsp], eax

; 1263 :         } else {

	jmp	$LN37@ExpandToke
$LN36@ExpandToke:

; 1264 :             i = pos++;

	mov	eax, DWORD PTR pos$[rsp]
	mov	DWORD PTR i$[rsp], eax
	mov	eax, DWORD PTR pos$[rsp]
	inc	eax
	mov	DWORD PTR pos$[rsp], eax

; 1265 :             tmp = tokenarray[*pi].tokpos - tokenarray[pos].tokpos;

	mov	rax, QWORD PTR pi$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR pos$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR tmp$[rsp], eax

; 1266 :             memcpy( buffer, tokenarray[pos].tokpos, tmp );

	movsxd	rax, DWORD PTR tmp$[rsp]
	movsxd	rcx, DWORD PTR pos$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+24]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memcpy

; 1267 :             buffer[tmp] = NULLC;

	movsxd	rax, DWORD PTR tmp$[rsp]
	mov	QWORD PTR $T8[rsp], rax
	cmp	QWORD PTR $T8[rsp], 600			; 00000258H
	jae	SHORT $LN47@ExpandToke
	jmp	SHORT $LN48@ExpandToke
$LN47@ExpandToke:
	call	__report_rangecheckfailure
$LN48@ExpandToke:
	mov	rax, QWORD PTR $T8[rsp]
	mov	BYTE PTR buffer$[rsp+rax], 0

; 1268 :             tmp = old_tokencount + 1;

	mov	eax, DWORD PTR old_tokencount$7[rsp]
	inc	eax
	mov	DWORD PTR tmp$[rsp], eax

; 1269 :             Token_Count = Tokenize( buffer, tmp, tokenarray, TOK_RESCAN );

	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR tmp$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 1270 :             if ( EvalOperand( &tmp, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	BYTE PTR [rsp+32], 2
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR tmp$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN38@ExpandToke

; 1271 :                 opndx.value = 0; /* v2.09: assume value 0, don't return with ERROR */

	mov	DWORD PTR opndx$[rsp], 0
	jmp	SHORT $LN39@ExpandToke
$LN38@ExpandToke:

; 1272 :             else if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN40@ExpandToke

; 1273 :                 /* v2.09: with flag EXPF_NOUNDEF, EvalOperand() will have returned
; 1274 :                  * with error if there's an undefined symbol involved
; 1275 :                  */
; 1276 :                 //if ( opndx.sym && opndx.sym->state == SYM_UNDEFINED )
; 1277 :                 //    EmitErr( SYMBOL_NOT_DEFINED, opndx.sym->name );
; 1278 :                 //else {
; 1279 :                     DebugMsg(("ExpandToken: 'constant expected' error\n"));

	lea	rcx, OFFSET FLAT:$SG11483
	call	DoDebugMsg

; 1280 :                     EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 1281 :                 //}
; 1282 :                 //return( ERROR );
; 1283 :                 opndx.value = 0; /* assume value 0 */

	mov	DWORD PTR opndx$[rsp], 0
$LN40@ExpandToke:
$LN39@ExpandToke:

; 1284 :             }
; 1285 :             Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$7[rsp]
	mov	DWORD PTR ModuleInfo+496, eax
$LN37@ExpandToke:

; 1286 :         }
; 1287 : #if TEVALUE_UNSIGNED
; 1288 :         /* v2.03: Masm compatible: returns an unsigned value */
; 1289 :         myltoa( opndx.value, StringBufferEnd, ModuleInfo.radix, FALSE, FALSE );

	movzx	eax, BYTE PTR ModuleInfo+396
	mov	BYTE PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8d, eax
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	ecx, DWORD PTR opndx$[rsp]
	call	myltoa

; 1290 : #else
; 1291 :         myltoa( opndx.value, StringBufferEnd, ModuleInfo.radix, opndx.hvalue < 0, FALSE );
; 1292 : #endif
; 1293 :             /* v2.05: get size of string to be "replaced" */
; 1294 :         tmp = tokenarray[*pi].tokpos - tokenarray[i].tokpos;

	mov	rax, QWORD PTR pi$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR tmp$[rsp], eax

; 1295 :         DebugMsg1(("ExpandToken: curr pos=%u, start expr=%u, expr size=%d\n", *pi, i, tmp ));

	mov	r9d, DWORD PTR tmp$[rsp]
	mov	r8d, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR pi$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11484
	call	DoDebugMsg1

; 1296 : 
; 1297 :         //tokenarray[i].token = T_STRING;
; 1298 :         tokenarray[i].string_ptr = StringBufferEnd;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	QWORD PTR [rcx+rax+8], rdx

; 1299 :         AddTokens( tokenarray, i+1, i+1 - *pi, Token_Count );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	rcx, QWORD PTR pi$[rsp]
	sub	eax, DWORD PTR [rcx]
	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx
	mov	r9d, DWORD PTR ModuleInfo+496
	mov	r8d, eax
	mov	edx, ecx
	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	AddTokens

; 1300 :         Token_Count += (i+1) - *pi;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	rcx, QWORD PTR pi$[rsp]
	sub	eax, DWORD PTR [rcx]
	mov	ecx, DWORD PTR ModuleInfo+496
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+496, eax

; 1301 : 
; 1302 :         if ( ERROR == RebuildLine( StringBufferEnd, i, tokenarray,

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR line$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	sub	rax, rdx
	mov	ecx, DWORD PTR bracket_flags$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR tmp$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+488
	call	RebuildLine
	cmp	eax, -1
	jne	SHORT $LN41@ExpandToke

; 1303 :                                   tmp, tokenarray[i].tokpos - line, bracket_flags ) )
; 1304 :             return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@ExpandToke
$LN41@ExpandToke:

; 1305 :         rc = STRING_EXPANDED;

	mov	DWORD PTR rc$[rsp], 1
$LN35@ExpandToke:

; 1306 :     }
; 1307 :     return( rc );

	mov	eax, DWORD PTR rc$[rsp]
$LN1@ExpandToke:
$LN42@ExpandToke:

; 1308 : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:ExpandToken$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 976				; 000003d0H
	pop	rdi
	ret	0
ExpandToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
dest$ = 32
src$ = 40
newlen$ = 48
rest$ = 52
buffer$ = 80
__$ArrayPad$ = 704
newstring$ = 736
i$ = 744
tokenarray$ = 752
oldlen$ = 760
pos_line$ = 768
addbrackets$ = 776
RebuildLine PROC

; 1051 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 720				; 000002d0H
	mov	rdi, rsp
	mov	ecx, 180				; 000000b4H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+736]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1052 :     char *dest;
; 1053 :     const char *src;
; 1054 :     unsigned  newlen;
; 1055 :     unsigned  rest = strlen( tokenarray[i].tokpos + oldlen ) + 1;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, DWORD PTR oldlen$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	add	rcx, QWORD PTR [rdx+rax+24]
	mov	rax, rcx
	mov	rcx, rax
	call	strlen
	inc	rax
	mov	DWORD PTR rest$[rsp], eax

; 1056 :     char buffer[MAX_LINE_LEN];
; 1057 : 
; 1058 :     dest = tokenarray[i].tokpos;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR dest$[rsp], rax

; 1059 :     memcpy( buffer, dest + oldlen, rest ); /* save content of line behind item */

	mov	eax, DWORD PTR rest$[rsp]
	mov	ecx, DWORD PTR oldlen$[rsp]
	mov	rdx, QWORD PTR dest$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8d, eax
	mov	rdx, rcx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memcpy

; 1060 :     newlen = strlen( newstring );

	mov	rcx, QWORD PTR newstring$[rsp]
	call	strlen
	mov	DWORD PTR newlen$[rsp], eax

; 1061 :     if ( addbrackets ) {

	cmp	DWORD PTR addbrackets$[rsp], 0
	je	SHORT $LN11@RebuildLin

; 1062 :         newlen += 2;   /* count '<' and '>' */

	mov	eax, DWORD PTR newlen$[rsp]
	add	eax, 2
	mov	DWORD PTR newlen$[rsp], eax

; 1063 :         for ( src = newstring; *src; src++ )

	mov	rax, QWORD PTR newstring$[rsp]
	mov	QWORD PTR src$[rsp], rax
	jmp	SHORT $LN4@RebuildLin
$LN2@RebuildLin:
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN4@RebuildLin:
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@RebuildLin

; 1064 :             if ( *src == '<' || *src == '>' || *src == '!' )    /* count '!' operator */

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN13@RebuildLin
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN13@RebuildLin
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN12@RebuildLin
$LN13@RebuildLin:

; 1065 :                 newlen++;

	mov	eax, DWORD PTR newlen$[rsp]
	inc	eax
	mov	DWORD PTR newlen$[rsp], eax
$LN12@RebuildLin:
	jmp	SHORT $LN2@RebuildLin
$LN3@RebuildLin:
$LN11@RebuildLin:

; 1066 :     }
; 1067 :     if ( newlen > oldlen )

	mov	eax, DWORD PTR oldlen$[rsp]
	cmp	DWORD PTR newlen$[rsp], eax
	jbe	SHORT $LN14@RebuildLin

; 1068 :         if ( ( pos_line + newlen - oldlen + rest ) >= MAX_LINE_LEN ) {

	mov	eax, DWORD PTR newlen$[rsp]
	mov	ecx, DWORD PTR pos_line$[rsp]
	add	ecx, eax
	mov	eax, ecx
	sub	eax, DWORD PTR oldlen$[rsp]
	add	eax, DWORD PTR rest$[rsp]
	cmp	eax, 600				; 00000258H
	jb	SHORT $LN15@RebuildLin

; 1069 :             return( EmitErr( EXPANDED_LINE_TOO_LONG, tokenarray[0].tokpos ) );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 90					; 0000005aH
	call	EmitErr
	jmp	$LN1@RebuildLin
$LN15@RebuildLin:
$LN14@RebuildLin:

; 1070 :         }
; 1071 : 
; 1072 :     if ( addbrackets ) {

	cmp	DWORD PTR addbrackets$[rsp], 0
	je	$LN16@RebuildLin

; 1073 :         *dest++ = '<';

	mov	rax, QWORD PTR dest$[rsp]
	mov	BYTE PTR [rax], 60			; 0000003cH
	mov	rax, QWORD PTR dest$[rsp]
	inc	rax
	mov	QWORD PTR dest$[rsp], rax

; 1074 :         for ( src = newstring; *src; src++ ) {

	mov	rax, QWORD PTR newstring$[rsp]
	mov	QWORD PTR src$[rsp], rax
	jmp	SHORT $LN7@RebuildLin
$LN5@RebuildLin:
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN7@RebuildLin:
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN6@RebuildLin

; 1075 :             if ( *src == '<' || *src == '>' || *src == '!' )    /* count '!' operator */

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN19@RebuildLin
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN19@RebuildLin
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN18@RebuildLin
$LN19@RebuildLin:

; 1076 :                 *dest++ = '!';

	mov	rax, QWORD PTR dest$[rsp]
	mov	BYTE PTR [rax], 33			; 00000021H
	mov	rax, QWORD PTR dest$[rsp]
	inc	rax
	mov	QWORD PTR dest$[rsp], rax
$LN18@RebuildLin:

; 1077 :             *dest++ = *src;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dest$[rsp]
	inc	rax
	mov	QWORD PTR dest$[rsp], rax

; 1078 :         }

	jmp	SHORT $LN5@RebuildLin
$LN6@RebuildLin:

; 1079 :         *dest++ = '>';

	mov	rax, QWORD PTR dest$[rsp]
	mov	BYTE PTR [rax], 62			; 0000003eH
	mov	rax, QWORD PTR dest$[rsp]
	inc	rax
	mov	QWORD PTR dest$[rsp], rax

; 1080 :     } else {

	jmp	SHORT $LN17@RebuildLin
$LN16@RebuildLin:

; 1081 :         memcpy( dest, newstring, newlen );

	mov	eax, DWORD PTR newlen$[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR newstring$[rsp]
	mov	rcx, QWORD PTR dest$[rsp]
	call	memcpy

; 1082 :         dest += newlen;

	mov	eax, DWORD PTR newlen$[rsp]
	mov	rcx, QWORD PTR dest$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dest$[rsp], rax
$LN17@RebuildLin:

; 1083 :     }
; 1084 :     memcpy( dest, buffer, rest ); /* add rest of line */

	mov	eax, DWORD PTR rest$[rsp]
	mov	r8d, eax
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR dest$[rsp]
	call	memcpy

; 1085 : 
; 1086 :     /* v2.05: changed '<' to '<=' */
; 1087 :     for ( i++; i <= Token_Count; i++ ) {

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN10@RebuildLin
$LN8@RebuildLin:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@RebuildLin:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jg	SHORT $LN9@RebuildLin

; 1088 :         tokenarray[i].tokpos = tokenarray[i].tokpos - oldlen + newlen;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, DWORD PTR oldlen$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	ecx, DWORD PTR newlen$[rsp]
	add	rax, rcx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	QWORD PTR [rdx+rcx+24], rax

; 1089 :     }

	jmp	SHORT $LN8@RebuildLin
$LN9@RebuildLin:

; 1090 : 
; 1091 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@RebuildLin:

; 1092 : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:RebuildLine$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 720				; 000002d0H
	pop	rdi
	ret	0
RebuildLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
i$ = 0
tv136 = 8
tokenarray$ = 48
start$ = 56
count$ = 64
end$ = 72
AddTokens PROC

; 797  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 24
	mov	rdi, rsp
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 798  :     int i;
; 799  : 
; 800  :     if ( count > 0 ) {

	cmp	DWORD PTR count$[rsp], 0
	jle	SHORT $LN8@AddTokens

; 801  :         for( i = end; i >= start; i-- ) {

	mov	eax, DWORD PTR end$[rsp]
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN4@AddTokens
$LN2@AddTokens:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@AddTokens:
	mov	eax, DWORD PTR start$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jl	SHORT $LN3@AddTokens

; 802  :             tokenarray[i+count] = tokenarray[i];

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, DWORD PTR count$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	add	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	lea	rsi, QWORD PTR [r8+rax]
	mov	ecx, 32					; 00000020H
	rep movsb

; 803  :         }

	jmp	SHORT $LN2@AddTokens
$LN3@AddTokens:

; 804  :     } else if ( count < 0 ) {

	jmp	SHORT $LN9@AddTokens
$LN8@AddTokens:
	cmp	DWORD PTR count$[rsp], 0
	jge	SHORT $LN10@AddTokens

; 805  :         for( i = start - count; i <= end; ++i ) {

	mov	eax, DWORD PTR count$[rsp]
	mov	ecx, DWORD PTR start$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN7@AddTokens
$LN5@AddTokens:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@AddTokens:
	mov	eax, DWORD PTR end$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jg	SHORT $LN6@AddTokens

; 806  :             tokenarray[i+count] = tokenarray[i];

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, DWORD PTR count$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	add	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rdi, QWORD PTR tokenarray$[rsp]
	mov	QWORD PTR tv136[rsp], rdi
	lea	rdi, QWORD PTR [rdx+rcx]
	mov	rcx, QWORD PTR tv136[rsp]
	lea	rsi, QWORD PTR [rcx+rax]
	mov	ecx, 32					; 00000020H
	rep movsb

; 807  :         }

	jmp	SHORT $LN5@AddTokens
$LN6@AddTokens:
$LN10@AddTokens:
$LN9@AddTokens:

; 808  :     }
; 809  : }

	add	rsp, 24
	pop	rdi
	pop	rsi
	ret	0
AddTokens ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 672
tokenarray$ = 704
SkipMacro PROC

; 103  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 688				; 000002b0H
	mov	rdi, rsp
	mov	ecx, 172				; 000000acH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+704]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
$LN2@SkipMacro:

; 104  :     char buffer[MAX_LINE_LEN];
; 105  : 
; 106  :     /* The queue isn't just thrown away, because any
; 107  :      * coditional assembly directives found in the source
; 108  :      * must be executed.
; 109  :      */
; 110  :      while ( GetTextLine( buffer ) ) {

	lea	rcx, QWORD PTR buffer$[rsp]
	call	GetTextLine
	test	rax, rax
	je	SHORT $LN3@SkipMacro

; 111  :         Tokenize( buffer, 0, tokenarray, TOK_DEFAULT );

	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	Tokenize

; 112  :     }

	jmp	SHORT $LN2@SkipMacro
$LN3@SkipMacro:

; 113  : 
; 114  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:SkipMacro$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 688				; 000002b0H
	pop	rdi
	ret	0
SkipMacro ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
old_tokencount$ = 48
i$ = 52
expanded$ = 56
len$ = 60
is_exitm$ = 68
sym$ = 88
buffer$ = 112
p$5 = 728
__$ArrayPad$ = 744
outbuf$ = 768
tokenarray$ = 776
equmode$ = 784
level$ = 792
ExpandTMacro PROC

; 972  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 752				; 000002f0H
	mov	rdi, rsp
	mov	ecx, 188				; 000000bcH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+768]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 973  :     int old_tokencount = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR old_tokencount$[rsp], eax

; 974  :     int i;
; 975  :     char expanded = TRUE;

	mov	BYTE PTR expanded$[rsp], 1

; 976  :     int len;
; 977  :     bool is_exitm;
; 978  :     struct asym *sym;
; 979  :     //char lvalue[MAX_LINE_LEN];    /* holds literal value */
; 980  :     char buffer[MAX_LINE_LEN];
; 981  : 
; 982  :     DebugMsg1(("ExpandTMacro(text=>%s< equm=%u lvl=%u) enter\n", outbuf, equmode, level ));

	mov	r9d, DWORD PTR level$[rsp]
	mov	r8d, DWORD PTR equmode$[rsp]
	mov	rdx, QWORD PTR outbuf$[rsp]
	lea	rcx, OFFSET FLAT:$SG11357
	call	DoDebugMsg1

; 983  : 
; 984  :     if ( level >= MAX_TEXTMACRO_NESTING ) {

	cmp	DWORD PTR level$[rsp], 20
	jl	SHORT $LN7@ExpandTMac

; 985  :         return( EmitError( MACRO_NESTING_LEVEL_TOO_DEEP ) );

	mov	ecx, 101				; 00000065H
	call	EmitError
	jmp	$LN1@ExpandTMac
$LN7@ExpandTMac:
$LN2@ExpandTMac:

; 986  :     }
; 987  : 
; 988  :     while ( expanded == TRUE ) {

	movsx	eax, BYTE PTR expanded$[rsp]
	cmp	eax, 1
	jne	$LN3@ExpandTMac

; 989  :         i = old_tokencount + 1;

	mov	eax, DWORD PTR old_tokencount$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 990  :         Token_Count = Tokenize( outbuf, i, tokenarray, TOK_RESCAN );

	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR outbuf$[rsp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 991  :         expanded = FALSE;

	mov	BYTE PTR expanded$[rsp], 0

; 992  :         for ( ; i < Token_Count; i++ ) {

	jmp	SHORT $LN6@ExpandTMac
$LN4@ExpandTMac:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN6@ExpandTMac:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN5@ExpandTMac

; 993  :             if ( tokenarray[i].token == T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN8@ExpandTMac

; 994  :                 sym = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 995  :                 /* expand macro functions */
; 996  :                 if ( sym && sym->state == SYM_MACRO &&
; 997  :                     sym->isdefined == TRUE && sym->isfunc == TRUE &&
; 998  :                     tokenarray[i+1].token == T_OP_BRACKET && equmode == FALSE ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN9@ExpandTMac
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	jne	$LN9@ExpandTMac
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN9@ExpandTMac
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN9@ExpandTMac
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	$LN9@ExpandTMac
	cmp	DWORD PTR equmode$[rsp], 0
	jne	$LN9@ExpandTMac

; 999  :                     len = tokenarray[i].tokpos - outbuf;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR outbuf$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	sub	rax, rdx
	mov	DWORD PTR len$[rsp], eax

; 1000 :                     memcpy( buffer, outbuf, len );

	movsxd	rax, DWORD PTR len$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR outbuf$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memcpy

; 1001 :                     i = RunMacro( (struct dsym *)sym, i+1, tokenarray, buffer+len, 0, &is_exitm );

	movsxd	rax, DWORD PTR len$[rsp]
	lea	rax, QWORD PTR buffer$[rsp+rax]
	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx
	lea	rdx, QWORD PTR is_exitm$[rsp]
	mov	QWORD PTR [rsp+40], rdx
	mov	DWORD PTR [rsp+32], 0
	mov	r9, rax
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, ecx
	mov	rcx, QWORD PTR sym$[rsp]
	call	RunMacro
	mov	DWORD PTR i$[rsp], eax

; 1002 :                     if ( i < 0 ) {

	cmp	DWORD PTR i$[rsp], 0
	jge	SHORT $LN11@ExpandTMac

; 1003 :                         Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax

; 1004 :                         return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandTMac
$LN11@ExpandTMac:

; 1005 :                     }
; 1006 :                     DebugMsg1(("ExpandTMacro(%u): repl >%s()< by >%s<\n", level, sym->name, buffer+len ));

	movsxd	rax, DWORD PTR len$[rsp]
	lea	rax, QWORD PTR buffer$[rsp+rax]
	mov	r9, rax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR level$[rsp]
	lea	rcx, OFFSET FLAT:$SG11363
	call	DoDebugMsg1

; 1007 :                     strcat( buffer+len, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR len$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp+rcx]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rdx+rax+24]
	call	strcat

; 1008 :                     strcpy( outbuf, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR outbuf$[rsp]
	call	strcpy

; 1009 :                     expanded = TRUE;

	mov	BYTE PTR expanded$[rsp], 1

; 1010 :                     /* is i to be decremented here? */
; 1011 :                     break;

	jmp	$LN5@ExpandTMac
	jmp	$LN10@ExpandTMac
$LN9@ExpandTMac:

; 1012 :                 } else if ( sym && sym->state == SYM_TMACRO && sym->isdefined == TRUE ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN12@ExpandTMac
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 10
	jne	$LN12@ExpandTMac
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN12@ExpandTMac

; 1013 :                     char *p;
; 1014 :                     len = tokenarray[i].tokpos - outbuf;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR outbuf$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	sub	rax, rdx
	mov	DWORD PTR len$[rsp], eax

; 1015 :                     memcpy( buffer, outbuf, len );

	movsxd	rax, DWORD PTR len$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR outbuf$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memcpy

; 1016 :                     //GetLiteralValue( buffer+len, sym->string_ptr );
; 1017 :                     strcpy( buffer+len, sym->string_ptr );

	movsxd	rax, DWORD PTR len$[rsp]
	lea	rax, QWORD PTR buffer$[rsp+rax]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rcx+16]
	mov	rcx, rax
	call	strcpy

; 1018 :                     DebugMsg1(("ExpandTMacro(>%s<, %u): calling ExpandTMacro, value >%s<\n", sym->name, level, buffer+len ));

	movsxd	rax, DWORD PTR len$[rsp]
	lea	rax, QWORD PTR buffer$[rsp+rax]
	mov	r9, rax
	mov	r8d, DWORD PTR level$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11365
	call	DoDebugMsg1

; 1019 :                     if ( ERROR == ExpandTMacro( buffer + len, tokenarray, equmode, level+1 ) ) {

	mov	eax, DWORD PTR level$[rsp]
	inc	eax
	movsxd	rcx, DWORD PTR len$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp+rcx]
	mov	r9d, eax
	mov	r8d, DWORD PTR equmode$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	call	ExpandTMacro
	cmp	eax, -1
	jne	SHORT $LN13@ExpandTMac

; 1020 :                         Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax

; 1021 :                         return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandTMac
$LN13@ExpandTMac:

; 1022 :                     }
; 1023 :                     DebugMsg1(("ExpandTMacro(%u): repl >%s< by >%s<\n", level, sym->name, buffer+len ));

	movsxd	rax, DWORD PTR len$[rsp]
	lea	rax, QWORD PTR buffer$[rsp+rax]
	mov	r9, rax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR level$[rsp]
	lea	rcx, OFFSET FLAT:$SG11367
	call	DoDebugMsg1

; 1024 :                     //if ( level || ( tokenarray[i+1].token != T_FINAL && tokenarray[i+1].token != T_COMMA ))
; 1025 :                         p = tokenarray[i].tokpos + sym->name_size;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+72]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	add	rcx, QWORD PTR [rdx+rax+24]
	mov	rax, rcx
	mov	QWORD PTR p$5[rsp], rax

; 1026 :                     //else
; 1027 :                     //    p = tokenarray[i+1].tokpos;
; 1028 :                     strcat( buffer+len, p );

	movsxd	rax, DWORD PTR len$[rsp]
	lea	rax, QWORD PTR buffer$[rsp+rax]
	mov	rdx, QWORD PTR p$5[rsp]
	mov	rcx, rax
	call	strcat

; 1029 :                     strcpy( outbuf, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR outbuf$[rsp]
	call	strcpy

; 1030 :                     expanded = TRUE;

	mov	BYTE PTR expanded$[rsp], 1

; 1031 :                     break;

	jmp	SHORT $LN5@ExpandTMac
$LN12@ExpandTMac:
$LN10@ExpandTMac:
$LN8@ExpandTMac:

; 1032 :                 }
; 1033 :             }
; 1034 :         }

	jmp	$LN4@ExpandTMac
$LN5@ExpandTMac:

; 1035 :     }

	jmp	$LN2@ExpandTMac
$LN3@ExpandTMac:

; 1036 :     Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax

; 1037 :     //strcpy( outbuf, lvalue );
; 1038 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@ExpandTMac:

; 1039 : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:ExpandTMacro$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 752				; 000002f0H
	pop	rdi
	ret	0
ExpandTMacro ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
cnt$ = 32
idx$ = 36
i$ = 64
tokenarray$ = 72
ExpandLiterals PROC

; 1355 : {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+64]

; 1356 :     int cnt = 0;

	mov	DWORD PTR cnt$[rsp], 0

; 1357 :     int idx;
; 1358 :     /* count non-empty literals */
; 1359 :     for ( idx = i; idx < Token_Count; idx++ ) {

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR idx$[rsp], eax
	jmp	SHORT $LN4@ExpandLite
$LN2@ExpandLite:
	mov	eax, DWORD PTR idx$[rsp]
	inc	eax
	mov	DWORD PTR idx$[rsp], eax
$LN4@ExpandLite:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR idx$[rsp], eax
	jge	SHORT $LN3@ExpandLite

; 1360 :         if ( tokenarray[idx].token == T_STRING &&
; 1361 :             tokenarray[idx].stringlen &&

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN5@ExpandLite
	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 0
	je	SHORT $LN5@ExpandLite
	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN6@ExpandLite
	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN5@ExpandLite
$LN6@ExpandLite:

; 1362 :             ( tokenarray[idx].string_delim == '<' || tokenarray[idx].string_delim == '{' ) ) {
; 1363 :             cnt++;

	mov	eax, DWORD PTR cnt$[rsp]
	inc	eax
	mov	DWORD PTR cnt$[rsp], eax
$LN5@ExpandLite:

; 1364 :         }
; 1365 :     }

	jmp	SHORT $LN2@ExpandLite
$LN3@ExpandLite:

; 1366 :     /* if non-empty literals are found, expand the line. if the line
; 1367 :      * was expanded, re-tokenize it.
; 1368 :      */
; 1369 :     if ( cnt ) {

	cmp	DWORD PTR cnt$[rsp], 0
	je	SHORT $LN7@ExpandLite

; 1370 :         if ( ExpandText( tokenarray[i].tokpos, tokenarray, FALSE ) == STRING_EXPANDED )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	xor	r8d, r8d
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+24]
	call	ExpandText
	cmp	eax, 1
	jne	SHORT $LN8@ExpandLite

; 1371 :             Tokenize( tokenarray[i].tokpos, i, tokenarray, TOK_RESCAN );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+24]
	call	Tokenize
$LN8@ExpandLite:
$LN7@ExpandLite:

; 1372 :     }
; 1373 : 
; 1374 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
ExpandLiterals ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
count$ = 52
bracket_flags$ = 68
flags$ = 72
lvl$ = 76
i$ = 80
j$ = 84
rc$ = 88
sym$ = 96
tmp$4 = 104
addbrackets$5 = 108
tv84 = 112
tv182 = 116
tv222 = 120
string$ = 144
tokenarray$ = 152
ExpandLine PROC

; 1382 : {

$LN59:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rdi, rsp
	mov	ecx, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+144]

; 1383 :     int count;
; 1384 :     unsigned int bracket_flags; /* flags */
; 1385 :     int flags;
; 1386 :     int lvl;
; 1387 :     int i;
; 1388 :     int j;
; 1389 :     ret_code rc;
; 1390 :     struct asym *sym;
; 1391 : 
; 1392 :     /* filter certain conditions.
; 1393 :      * bracket_flags: for (preprocessor) directives that expect a literal
; 1394 :      * parameter, the expanded argument has to be enclosed in '<>' again.
; 1395 :      */
; 1396 :     DebugMsg1(( "ExpandLine(>%s<) enter\n", string ));

	mov	rdx, QWORD PTR string$[rsp]
	lea	rcx, OFFSET FLAT:$SG11553
	call	DoDebugMsg1

; 1397 :     for ( lvl = 0; lvl < MAX_TEXTMACRO_NESTING; lvl++ ) {

	mov	DWORD PTR lvl$[rsp], 0
	jmp	SHORT $LN4@ExpandLine
$LN2@ExpandLine:
	mov	eax, DWORD PTR lvl$[rsp]
	inc	eax
	mov	DWORD PTR lvl$[rsp], eax
$LN4@ExpandLine:
	cmp	DWORD PTR lvl$[rsp], 20
	jge	$LN3@ExpandLine

; 1398 :         bracket_flags = 0;

	mov	DWORD PTR bracket_flags$[rsp], 0

; 1399 :         count = 0;

	mov	DWORD PTR count$[rsp], 0

; 1400 :         rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 1401 :         i = ( Token_Count > 2 && ( tokenarray[1].token == T_COLON || tokenarray[1].token == T_DBL_COLON ) && tokenarray[2].token == T_DIRECTIVE ) ? 2 : 0;

	cmp	DWORD PTR ModuleInfo+496, 2
	jle	SHORT $LN53@ExpandLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN52@ExpandLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 13
	jne	SHORT $LN53@ExpandLine
$LN52@ExpandLine:
	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	SHORT $LN53@ExpandLine
	mov	DWORD PTR tv84[rsp], 2
	jmp	SHORT $LN54@ExpandLine
$LN53@ExpandLine:
	mov	DWORD PTR tv84[rsp], 0
$LN54@ExpandLine:
	mov	eax, DWORD PTR tv84[rsp]
	mov	DWORD PTR i$[rsp], eax

; 1402 :         if ( tokenarray[i].token == T_DIRECTIVE ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	$LN14@ExpandLine

; 1403 :             flags = GetValueSp( tokenarray[i].tokval );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR flags$[rsp], eax

; 1404 :             if ( flags & DF_STRPARM ) {

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	$LN16@ExpandLine

; 1405 :                 bracket_flags = -1;

	mov	DWORD PTR bracket_flags$[rsp], -1	; ffffffffH

; 1406 :                 /* v2.08 handle .ERRDEF and .ERRNDEF here. Previously
; 1407 :                  * expansion for these directives was handled in condasm.asm,
; 1408 :                  * and the directives were flagged as DF_NOEXPAND.
; 1409 :                  */
; 1410 :                 if ( tokenarray[i].dirtype == DRT_ERRDIR ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 10
	jne	$LN18@ExpandLine

; 1411 :                     if (tokenarray[i].tokval == T_DOT_ERRDEF || tokenarray[i].tokval == T_DOT_ERRNDEF ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 356		; 00000164H
	je	SHORT $LN20@ExpandLine
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 357		; 00000165H
	jne	$LN19@ExpandLine
$LN20@ExpandLine:

; 1412 :                         if ( i )

	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN21@ExpandLine

; 1413 :                             rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	call	ExpandToken
	mov	DWORD PTR rc$[rsp], eax
$LN21@ExpandLine:
$LN5@ExpandLine:

; 1414 :                         while ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA ) i++;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN6@ExpandLine
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN6@ExpandLine
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN5@ExpandLine
$LN6@ExpandLine:

; 1415 :                         count = i; /* don't expand the symbol name */

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR count$[rsp], eax
$LN19@ExpandLine:
$LN18@ExpandLine:

; 1416 :                     }
; 1417 :                 }

	jmp	SHORT $LN17@ExpandLine
$LN16@ExpandLine:

; 1418 :             } else if ( flags & DF_NOEXPAND ) {

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN22@ExpandLine

; 1419 :                 /* [ELSE]IF[N]DEF, ECHO, FOR[C]
; 1420 :                  * .[NO|X]CREF, INCLUDE */
; 1421 :                 /* don't expand arguments */
; 1422 :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@ExpandLine
$LN22@ExpandLine:
$LN17@ExpandLine:

; 1423 :             }

	jmp	$LN15@ExpandLine
$LN14@ExpandLine:

; 1424 :         } else if ( Token_Count > 1 && tokenarray[1].token == T_DIRECTIVE ) {

	cmp	DWORD PTR ModuleInfo+496, 1
	jle	$LN23@ExpandLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	$LN23@ExpandLine

; 1425 :             switch ( tokenarray[1].dirtype ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1]
	mov	DWORD PTR tv182[rsp], eax
	mov	eax, DWORD PTR tv182[rsp]
	sub	eax, 4
	mov	DWORD PTR tv182[rsp], eax
	cmp	DWORD PTR tv182[rsp], 43		; 0000002bH
	ja	$LN7@ExpandLine
	movsxd	rax, DWORD PTR tv182[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN57@ExpandLine[rcx+rax]
	mov	eax, DWORD PTR $LN58@ExpandLine[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN25@ExpandLine:

; 1426 :             case DRT_CATSTR:
; 1427 :                 bracket_flags = -1;

	mov	DWORD PTR bracket_flags$[rsp], -1	; ffffffffH

; 1428 :                 count = 2;

	mov	DWORD PTR count$[rsp], 2

; 1429 :                 break;

	jmp	$LN7@ExpandLine
$LN26@ExpandLine:

; 1430 :             case DRT_SUBSTR:
; 1431 :                 /* syntax: name SUBSTR <literal>, pos [, size] */
; 1432 :                 bracket_flags = 0x1;

	mov	DWORD PTR bracket_flags$[rsp], 1

; 1433 :                 count = 2;

	mov	DWORD PTR count$[rsp], 2

; 1434 :                 break;

	jmp	$LN7@ExpandLine
$LN27@ExpandLine:

; 1435 :             case DRT_SIZESTR:
; 1436 :                 /* syntax: label SIZESTR literal */
; 1437 :                 rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	call	ExpandToken
	mov	DWORD PTR rc$[rsp], eax

; 1438 :                 bracket_flags = 0x1;

	mov	DWORD PTR bracket_flags$[rsp], 1

; 1439 :                 count = 2;

	mov	DWORD PTR count$[rsp], 2

; 1440 :                 break;

	jmp	$LN7@ExpandLine
$LN28@ExpandLine:

; 1441 :             case DRT_INSTR:
; 1442 :                 /* syntax: label INSTR [number,] literal, literal */
; 1443 :                 rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	call	ExpandToken
	mov	DWORD PTR rc$[rsp], eax

; 1444 :                 /* check if the optional <number> argument is given */
; 1445 :                 for ( i = 2, count = 0, j = 0; i < Token_Count; i++ ) {

	mov	DWORD PTR i$[rsp], 2
	mov	DWORD PTR count$[rsp], 0
	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN11@ExpandLine
$LN9@ExpandLine:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN11@ExpandLine:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN10@ExpandLine

; 1446 :                     if ( tokenarray[i].token == T_OP_BRACKET )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN29@ExpandLine

; 1447 :                         count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax
	jmp	SHORT $LN30@ExpandLine
$LN29@ExpandLine:

; 1448 :                     else if ( tokenarray[i].token == T_CL_BRACKET )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN31@ExpandLine

; 1449 :                         count--;

	mov	eax, DWORD PTR count$[rsp]
	dec	eax
	mov	DWORD PTR count$[rsp], eax
	jmp	SHORT $LN32@ExpandLine
$LN31@ExpandLine:

; 1450 :                     else if ( tokenarray[i].token == T_COMMA && count == 0 )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN33@ExpandLine
	cmp	DWORD PTR count$[rsp], 0
	jne	SHORT $LN33@ExpandLine

; 1451 :                         j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN33@ExpandLine:
$LN32@ExpandLine:
$LN30@ExpandLine:

; 1452 :                 }

	jmp	$LN9@ExpandLine
$LN10@ExpandLine:

; 1453 : 
; 1454 :                 bracket_flags = ( ( j > 1 ) ? 0x6 : 0x3 );

	cmp	DWORD PTR j$[rsp], 1
	jle	SHORT $LN55@ExpandLine
	mov	DWORD PTR tv222[rsp], 6
	jmp	SHORT $LN56@ExpandLine
$LN55@ExpandLine:
	mov	DWORD PTR tv222[rsp], 3
$LN56@ExpandLine:
	mov	eax, DWORD PTR tv222[rsp]
	mov	DWORD PTR bracket_flags$[rsp], eax

; 1455 :                 count = 2;

	mov	DWORD PTR count$[rsp], 2

; 1456 :                 break;

	jmp	SHORT $LN7@ExpandLine
$LN34@ExpandLine:

; 1457 :             case DRT_MACRO:
; 1458 :                 sym = SymSearch( tokenarray[0].string_ptr );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 1459 :                 /* don't expand macro DEFINITIONs!
; 1460 :                  * the name is an exception, if it's not the macro itself
; 1461 :                  */
; 1462 :                 if ( sym && sym->state != SYM_MACRO )

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN35@ExpandLine
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	je	SHORT $LN35@ExpandLine

; 1463 :                     rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	call	ExpandToken
	mov	DWORD PTR rc$[rsp], eax
$LN35@ExpandLine:

; 1464 :                 count = Token_Count; /* stop further expansion */

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR count$[rsp], eax

; 1465 :                 break;

	jmp	SHORT $LN7@ExpandLine
$LN36@ExpandLine:

; 1466 :             case DRT_EQU:
; 1467 :                 /* EQU is a special case. If the - expanded - expression is
; 1468 :                  * a number, then the value for EQU is numeric. Else the
; 1469 :                  * expression isn't expanded at all. This effectively makes it
; 1470 :                  * impossible to expand EQU lines here.
; 1471 :                  */
; 1472 : #if 0 /* v2.09: EQU should NEVER be expanded here. See regression test equate20.aso */
; 1473 :                 sym = SymSearch( tokenarray[0].string_ptr );
; 1474 :                 if ( sym == NULL || sym->state == SYM_TMACRO )
; 1475 : #endif
; 1476 :                     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@ExpandLine
$LN7@ExpandLine:

; 1477 :             }
; 1478 :         } else {

	jmp	$LN24@ExpandLine
$LN23@ExpandLine:

; 1479 :             /* v2.08: expand the very first token and then ... */
; 1480 :             rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	call	ExpandToken
	mov	DWORD PTR rc$[rsp], eax

; 1481 :             if( rc == ERROR || rc == EMPTY )

	cmp	DWORD PTR rc$[rsp], -1
	je	SHORT $LN38@ExpandLine
	cmp	DWORD PTR rc$[rsp], -2
	jne	SHORT $LN37@ExpandLine
$LN38@ExpandLine:

; 1482 :                 return( rc );

	mov	eax, DWORD PTR rc$[rsp]
	jmp	$LN1@ExpandLine
$LN37@ExpandLine:

; 1483 :             if ( rc == STRING_EXPANDED ) {

	cmp	DWORD PTR rc$[rsp], 1
	jne	SHORT $LN39@ExpandLine

; 1484 :                 /* ... fully retokenize - the expansion might have revealed a conditional
; 1485 :                  * assembly directive
; 1486 :                  */
; 1487 :                 Token_Count = Tokenize( string, 0, tokenarray, TOK_DEFAULT );

	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR string$[rsp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 1488 :                 continue;

	jmp	$LN2@ExpandLine
$LN39@ExpandLine:

; 1489 :             }
; 1490 : #if 1 /* v2.10. see regression test equate27.asm */
; 1491 :             if ( count == 1 && tokenarray[0].token == T_ID && tokenarray[1].token == T_ID ) {

	cmp	DWORD PTR count$[rsp], 1
	jne	$LN40@ExpandLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN40@ExpandLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN40@ExpandLine

; 1492 :                 rc = ExpandToken( string, &count, tokenarray, 2, FALSE, FALSE );

	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 2
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	call	ExpandToken
	mov	DWORD PTR rc$[rsp], eax

; 1493 :                 if( rc == ERROR || rc == EMPTY )

	cmp	DWORD PTR rc$[rsp], -1
	je	SHORT $LN42@ExpandLine
	cmp	DWORD PTR rc$[rsp], -2
	jne	SHORT $LN41@ExpandLine
$LN42@ExpandLine:

; 1494 :                     return( rc );

	mov	eax, DWORD PTR rc$[rsp]
	jmp	$LN1@ExpandLine
$LN41@ExpandLine:

; 1495 :                 if ( rc == STRING_EXPANDED ) {

	cmp	DWORD PTR rc$[rsp], 1
	jne	SHORT $LN43@ExpandLine

; 1496 :                     Token_Count = Tokenize( string, 0, tokenarray, TOK_DEFAULT );

	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR string$[rsp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 1497 :                     continue;

	jmp	$LN2@ExpandLine
$LN43@ExpandLine:
$LN40@ExpandLine:
$LN24@ExpandLine:
$LN15@ExpandLine:
$LN12@ExpandLine:

; 1498 :                 }
; 1499 :             }
; 1500 : #endif
; 1501 :         }
; 1502 :         /* scan the line from left to right for (text) macros.
; 1503 :          * it's currently not quite correct. a macro proc should only
; 1504 :          * be evaluated in the following cases:
; 1505 :          * 1. it is the first token of a line
; 1506 :          * 2. it is the second token, and the first one is an ID
; 1507 :          * 3. it is the third token, the first one is an ID and
; 1508 :          *    the second is a ':' or '::'.
; 1509 :          */
; 1510 :         while ( count < Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR count$[rsp], eax
	jge	$LN13@ExpandLine

; 1511 :             int tmp;
; 1512 :             int addbrackets;
; 1513 :             addbrackets = bracket_flags & 1;

	mov	eax, DWORD PTR bracket_flags$[rsp]
	and	eax, 1
	mov	DWORD PTR addbrackets$5[rsp], eax

; 1514 :             if ( bracket_flags != -1 )

	cmp	DWORD PTR bracket_flags$[rsp], -1	; ffffffffH
	je	SHORT $LN44@ExpandLine

; 1515 :                 bracket_flags = bracket_flags >> 1;

	mov	eax, DWORD PTR bracket_flags$[rsp]
	shr	eax, 1
	mov	DWORD PTR bracket_flags$[rsp], eax
$LN44@ExpandLine:

; 1516 :             tmp = ExpandToken( string, &count, tokenarray, Token_Count, addbrackets, FALSE );

	mov	DWORD PTR [rsp+40], 0
	mov	eax, DWORD PTR addbrackets$5[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR ModuleInfo+496
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	call	ExpandToken
	mov	DWORD PTR tmp$4[rsp], eax

; 1517 :             if( tmp < NOT_ERROR ) /* ERROR or EMPTY? */

	cmp	DWORD PTR tmp$4[rsp], 0
	jge	SHORT $LN45@ExpandLine

; 1518 :                 return( tmp );

	mov	eax, DWORD PTR tmp$4[rsp]
	jmp	$LN1@ExpandLine
$LN45@ExpandLine:

; 1519 :             if ( tmp == STRING_EXPANDED )

	cmp	DWORD PTR tmp$4[rsp], 1
	jne	SHORT $LN46@ExpandLine

; 1520 :                 rc = STRING_EXPANDED;

	mov	DWORD PTR rc$[rsp], 1
$LN46@ExpandLine:

; 1521 :             if ( tokenarray[count].token == T_COMMA )

	movsxd	rax, DWORD PTR count$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN47@ExpandLine

; 1522 :                 count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax
$LN47@ExpandLine:

; 1523 :         }

	jmp	$LN12@ExpandLine
$LN13@ExpandLine:

; 1524 :         if( rc == STRING_EXPANDED ) {

	cmp	DWORD PTR rc$[rsp], 1
	jne	SHORT $LN48@ExpandLine

; 1525 :             DebugMsg1(( "ExpandLine(%s): expansion occured, retokenize\n", string ));

	mov	rdx, QWORD PTR string$[rsp]
	lea	rcx, OFFSET FLAT:$SG11590
	call	DoDebugMsg1

; 1526 :             Token_Count = Tokenize( string, 0, tokenarray, TOK_RESCAN | TOK_LINE );

	mov	r9d, 5
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR string$[rsp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 1527 :         } else

	jmp	SHORT $LN49@ExpandLine
$LN48@ExpandLine:

; 1528 :             break;

	jmp	SHORT $LN3@ExpandLine
$LN49@ExpandLine:

; 1529 :     } /* end for() */

	jmp	$LN2@ExpandLine
$LN3@ExpandLine:

; 1530 :     if ( lvl == MAX_TEXTMACRO_NESTING ) {

	cmp	DWORD PTR lvl$[rsp], 20
	jne	SHORT $LN50@ExpandLine

; 1531 :         return( EmitError( MACRO_NESTING_LEVEL_TOO_DEEP ) );

	mov	ecx, 101				; 00000065H
	call	EmitError
	jmp	SHORT $LN1@ExpandLine
$LN50@ExpandLine:

; 1532 :     }
; 1533 :     DebugMsg1(( "ExpandLine(>%s<) exit, rc=%u, token_count=%u\n", string, rc, Token_Count ));

	mov	r9d, DWORD PTR ModuleInfo+496
	mov	r8d, DWORD PTR rc$[rsp]
	mov	rdx, QWORD PTR string$[rsp]
	lea	rcx, OFFSET FLAT:$SG11592
	call	DoDebugMsg1

; 1534 :     return( rc );

	mov	eax, DWORD PTR rc$[rsp]
$LN1@ExpandLine:

; 1535 : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:ExpandLine$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 128				; 00000080H
	pop	rdi
	ret	0
	npad	1
$LN58@ExpandLine:
	DD	$LN34@ExpandLine
	DD	$LN25@ExpandLine
	DD	$LN26@ExpandLine
	DD	$LN28@ExpandLine
	DD	$LN27@ExpandLine
	DD	$LN36@ExpandLine
	DD	$LN7@ExpandLine
$LN57@ExpandLine:
	DB	0
	DB	1
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
ExpandLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
k$ = 52
lvl$ = 68
tmp$ = 72
rc$ = 76
line$ = 96
i$ = 104
tokenarray$ = 112
addbrackets$ = 120
equmode$ = 128
ExpandLineItems PROC

; 1317 : {

$LN14:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 1318 :     int k;
; 1319 :     int lvl;
; 1320 :     int tmp;
; 1321 :     ret_code rc;
; 1322 : 
; 1323 :     for ( lvl = 0; ; lvl++ ) {

	mov	DWORD PTR lvl$[rsp], 0
	jmp	SHORT $LN4@ExpandLine
$LN2@ExpandLine:
	mov	eax, DWORD PTR lvl$[rsp]
	inc	eax
	mov	DWORD PTR lvl$[rsp], eax
$LN4@ExpandLine:

; 1324 :         rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 1325 :         for( k = i; k < Token_Count; ) {

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR k$[rsp], eax
$LN5@ExpandLine:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN6@ExpandLine

; 1326 :             tmp = ExpandToken( line, &k, tokenarray, Token_Count, addbrackets, equmode );

	mov	eax, DWORD PTR equmode$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR addbrackets$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR ModuleInfo+496
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR k$[rsp]
	mov	rcx, QWORD PTR line$[rsp]
	call	ExpandToken
	mov	DWORD PTR tmp$[rsp], eax

; 1327 :             if ( tmp == ERROR )

	cmp	DWORD PTR tmp$[rsp], -1
	jne	SHORT $LN8@ExpandLine

; 1328 :                 return( lvl );

	mov	eax, DWORD PTR lvl$[rsp]
	jmp	SHORT $LN1@ExpandLine
$LN8@ExpandLine:

; 1329 :             if ( tmp == STRING_EXPANDED )

	cmp	DWORD PTR tmp$[rsp], 1
	jne	SHORT $LN9@ExpandLine

; 1330 :                 rc = STRING_EXPANDED;

	mov	DWORD PTR rc$[rsp], 1
$LN9@ExpandLine:

; 1331 :             if ( tokenarray[k].token == T_COMMA )

	movsxd	rax, DWORD PTR k$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN10@ExpandLine

; 1332 :                 k++;

	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN10@ExpandLine:

; 1333 :         }

	jmp	SHORT $LN5@ExpandLine
$LN6@ExpandLine:

; 1334 :         if ( rc == NOT_ERROR )

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN11@ExpandLine

; 1335 :             break;

	jmp	SHORT $LN3@ExpandLine
$LN11@ExpandLine:

; 1336 :         /* expansion happened, re-tokenize and continue! */
; 1337 :         Token_Count = Tokenize( line, i, tokenarray, TOK_RESCAN );

	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR line$[rsp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 1338 :         if ( lvl == MAX_TEXTMACRO_NESTING ) {

	cmp	DWORD PTR lvl$[rsp], 20
	jne	SHORT $LN12@ExpandLine

; 1339 :             EmitError( MACRO_NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 101				; 00000065H
	call	EmitError

; 1340 :             break;

	jmp	SHORT $LN3@ExpandLine
$LN12@ExpandLine:

; 1341 :         }
; 1342 :     }

	jmp	$LN2@ExpandLine
$LN3@ExpandLine:

; 1343 :     return( lvl );

	mov	eax, DWORD PTR lvl$[rsp]
$LN1@ExpandLine:

; 1344 : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:ExpandLineItems$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
ExpandLineItems ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
pSrc$ = 48
pDst$ = 56
pIdent$ = 64
lvl$ = 72
is_exitm$ = 84
old_tokencount$ = 100
old_stringbufferend$ = 104
quoted_string$ = 112
macro_proc$ = 113
rc$ = 116
sym$ = 120
sp$ = 144
p$5 = 312
i$6 = 320
j$7 = 324
cnt$8 = 328
tv160 = 344
tv282 = 352
tv292 = 360
__$ArrayPad$ = 368
line$ = 400
tokenarray$ = 408
substitute$ = 416
ExpandText PROC

; 821  : {

$LN67:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 384				; 00000180H
	mov	rdi, rsp
	mov	ecx, 96					; 00000060H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+400]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 822  :     char *pSrc;
; 823  :     char *pDst;
; 824  :     char *pIdent;
; 825  :     int  lvl;
; 826  :     bool is_exitm;
; 827  :     int old_tokencount = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR old_tokencount$[rsp], eax

; 828  :     char *old_stringbufferend = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR old_stringbufferend$[rsp], rax

; 829  :     char quoted_string = 0;

	mov	BYTE PTR quoted_string$[rsp], 0

; 830  :     char macro_proc = FALSE;

	mov	BYTE PTR macro_proc$[rsp], 0

; 831  :     //char *pStart;
; 832  :     ret_code rc;
; 833  :     struct asym *sym;
; 834  :     char *sp[MAX_TEXTMACRO_NESTING];
; 835  : 
; 836  :         DebugMsg1(("ExpandText(line=>%s<, subst=%u ) enter\n", line, substitute ));

	mov	r8d, DWORD PTR substitute$[rsp]
	mov	rdx, QWORD PTR line$[rsp]
	lea	rcx, OFFSET FLAT:$SG11284
	call	DoDebugMsg1

; 837  :     sp[0] = line;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR line$[rsp]
	mov	QWORD PTR sp$[rsp+rax], rcx

; 838  :     pDst = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR pDst$[rsp], rax

; 839  :     StringBufferEnd += MAX_LINE_LEN;

	mov	rax, QWORD PTR ModuleInfo+488
	add	rax, 600				; 00000258H
	mov	QWORD PTR ModuleInfo+488, rax

; 840  :     rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 841  :     for ( lvl = 0; lvl >= 0; lvl-- ) {

	mov	DWORD PTR lvl$[rsp], 0
	jmp	SHORT $LN4@ExpandText
$LN2@ExpandText:
	mov	eax, DWORD PTR lvl$[rsp]
	dec	eax
	mov	DWORD PTR lvl$[rsp], eax
$LN4@ExpandText:
	cmp	DWORD PTR lvl$[rsp], 0
	jl	$LN3@ExpandText

; 842  :         pSrc = sp[lvl];

	movsxd	rax, DWORD PTR lvl$[rsp]
	mov	rax, QWORD PTR sp$[rsp+rax*8]
	mov	QWORD PTR pSrc$[rsp], rax
$LN62@ExpandText:
$LN61@ExpandText:
$LN5@ExpandText:

; 843  :         while ( *pSrc ) {

	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN6@ExpandText

; 844  :             if( is_valid_id_first_char( *pSrc ) && ( substitute != 0 || quoted_string == 0 ) ) {

	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalpha
	test	eax, eax
	jne	SHORT $LN17@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN17@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN17@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN17@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN17@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	jne	$LN15@ExpandText
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 4
	and	eax, 1
	cmp	eax, 1
	jne	$LN15@ExpandText
$LN17@ExpandText:
	cmp	DWORD PTR substitute$[rsp], 0
	jne	SHORT $LN18@ExpandText
	movsx	eax, BYTE PTR quoted_string$[rsp]
	test	eax, eax
	jne	$LN15@ExpandText
$LN18@ExpandText:

; 845  :                 pIdent = pDst;

	mov	rax, QWORD PTR pDst$[rsp]
	mov	QWORD PTR pIdent$[rsp], rax
$LN66@ExpandText:
$LN65@ExpandText:
$LN64@ExpandText:
$LN63@ExpandText:
$LN9@ExpandText:

; 846  :                 do {
; 847  :                     *pDst++ = *pSrc++;

	mov	rax, QWORD PTR pDst$[rsp]
	mov	rcx, QWORD PTR pSrc$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR pDst$[rsp]
	inc	rax
	mov	QWORD PTR pDst$[rsp], rax
	mov	rax, QWORD PTR pSrc$[rsp]
	inc	rax
	mov	QWORD PTR pSrc$[rsp], rax

; 848  :                 } while ( is_valid_id_char( *pSrc ));

	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	SHORT $LN9@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN63@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN64@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN65@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN66@ExpandText

; 849  :                 *pDst = NULLC;

	mov	rax, QWORD PTR pDst$[rsp]
	mov	BYTE PTR [rax], 0

; 850  :                 sym = SymSearch( pIdent );

	mov	rcx, QWORD PTR pIdent$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 851  : #ifdef DEBUG_OUT
; 852  :                 if ( sym && ( sym->state == SYM_TMACRO || sym->state == SYM_MACRO ) ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN19@ExpandText
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 10
	je	SHORT $LN20@ExpandText
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	jne	SHORT $LN19@ExpandText
$LN20@ExpandText:

; 853  :                     DebugMsg1(( "ExpandText: symbol found: %s, %s, defined=%u, *pDst-1=%c\n", sym->name, sym->state == SYM_TMACRO ? "SYM_TMACRO" : "SYM_MACRO", sym->isdefined, *(pDst-1) ));

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 10
	jne	SHORT $LN57@ExpandText
	lea	rax, OFFSET FLAT:$SG11291
	mov	QWORD PTR tv160[rsp], rax
	jmp	SHORT $LN58@ExpandText
$LN57@ExpandText:
	lea	rax, OFFSET FLAT:$SG11292
	mov	QWORD PTR tv160[rsp], rax
$LN58@ExpandText:
	mov	rax, QWORD PTR pDst$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+40]
	shr	cl, 1
	and	cl, 1
	movzx	ecx, cl
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8, QWORD PTR tv160[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11293
	call	DoDebugMsg1
$LN19@ExpandText:

; 854  :                 }
; 855  : #endif
; 856  :                 if ( sym && sym->isdefined == TRUE ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN21@ExpandText
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN21@ExpandText

; 857  :                     if ( sym->state == SYM_TMACRO ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 10
	jne	$LN22@ExpandText

; 858  :                         /* v2.08: no expansion inside quoted strings without & */
; 859  :                         if ( quoted_string && *(pIdent-1) != '&' && *pSrc != '&' )

	movsx	eax, BYTE PTR quoted_string$[rsp]
	test	eax, eax
	je	SHORT $LN24@ExpandText
	mov	rax, QWORD PTR pIdent$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN24@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN24@ExpandText

; 860  :                             continue;

	jmp	$LN5@ExpandText
$LN24@ExpandText:

; 861  :                         if ( substitute ) {

	cmp	DWORD PTR substitute$[rsp], 0
	je	SHORT $LN25@ExpandText

; 862  :                             if ( *(pIdent-1) == '&' )

	mov	rax, QWORD PTR pIdent$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN27@ExpandText

; 863  :                                 pIdent--;

	mov	rax, QWORD PTR pIdent$[rsp]
	dec	rax
	mov	QWORD PTR pIdent$[rsp], rax
$LN27@ExpandText:

; 864  :                             if ( *pSrc == '&' )

	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN28@ExpandText

; 865  :                                 pSrc++;

	mov	rax, QWORD PTR pSrc$[rsp]
	inc	rax
	mov	QWORD PTR pSrc$[rsp], rax
$LN28@ExpandText:

; 866  :                         } else if ( pIdent > old_stringbufferend && *(pIdent-1) == '%' )

	jmp	SHORT $LN26@ExpandText
$LN25@ExpandText:
	mov	rax, QWORD PTR old_stringbufferend$[rsp]
	cmp	QWORD PTR pIdent$[rsp], rax
	jbe	SHORT $LN29@ExpandText
	mov	rax, QWORD PTR pIdent$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN29@ExpandText

; 867  :                                 pIdent--;

	mov	rax, QWORD PTR pIdent$[rsp]
	dec	rax
	mov	QWORD PTR pIdent$[rsp], rax
$LN29@ExpandText:
$LN26@ExpandText:

; 868  : 
; 869  :                         sp[lvl++] = pSrc;

	movsxd	rax, DWORD PTR lvl$[rsp]
	mov	rcx, QWORD PTR pSrc$[rsp]
	mov	QWORD PTR sp$[rsp+rax*8], rcx
	mov	eax, DWORD PTR lvl$[rsp]
	inc	eax
	mov	DWORD PTR lvl$[rsp], eax

; 870  :                         pSrc = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR pSrc$[rsp], rax

; 871  :                         //StringBufferEnd = GetAlignedPointer( pSrc, GetLiteralValue( pSrc, sym->string_ptr ) );
; 872  :                         strcpy( pSrc, sym->string_ptr );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR pSrc$[rsp]
	call	strcpy

; 873  :                         StringBufferEnd = GetAlignedPointer( pSrc, strlen( pSrc ) );

	mov	rcx, QWORD PTR pSrc$[rsp]
	call	strlen
	add	rax, 8
	and	rax, -8
	mov	rcx, QWORD PTR pSrc$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ModuleInfo+488, rax

; 874  :                         DebugMsg1(("ExpandText: %s replaced by >%s<\n", sym->name, pSrc ));

	mov	r8, QWORD PTR pSrc$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11303
	call	DoDebugMsg1

; 875  :                         pDst = pIdent;

	mov	rax, QWORD PTR pIdent$[rsp]
	mov	QWORD PTR pDst$[rsp], rax

; 876  :                         rc = STRING_EXPANDED;

	mov	DWORD PTR rc$[rsp], 1
	jmp	$LN23@ExpandText
$LN22@ExpandText:

; 877  :                     } else if ( sym->state == SYM_MACRO && sym->isfunc == TRUE ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	jne	$LN30@ExpandText
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN30@ExpandText

; 878  :                         /* expand macro functions. */
; 879  :                         char *p = pSrc;

	mov	rax, QWORD PTR pSrc$[rsp]
	mov	QWORD PTR p$5[rsp], rax
$LN10@ExpandText:

; 880  :                         int i;
; 881  :                         while ( isspace(*p) ) p++;

	mov	rax, QWORD PTR p$5[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN11@ExpandText
	mov	rax, QWORD PTR p$5[rsp]
	inc	rax
	mov	QWORD PTR p$5[rsp], rax
	jmp	SHORT $LN10@ExpandText
$LN11@ExpandText:

; 882  :                         /* no macro function invokation if the '(' is missing! */
; 883  :                         if ( *p == '(' ) {

	mov	rax, QWORD PTR p$5[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 40					; 00000028H
	jne	$LN32@ExpandText

; 884  :                             int j;
; 885  :                             int cnt;
; 886  :                             i = Token_Count + 1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR i$6[rsp], eax

; 887  :                             Token_Count = Tokenize( p, i, tokenarray, TOK_RESCAN );

	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$6[rsp]
	mov	rcx, QWORD PTR p$5[rsp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 888  :                             for ( j = i, cnt = 0; j < Token_Count; j++ ) {

	mov	eax, DWORD PTR i$6[rsp]
	mov	DWORD PTR j$7[rsp], eax
	mov	DWORD PTR cnt$8[rsp], 0
	jmp	SHORT $LN14@ExpandText
$LN12@ExpandText:
	mov	eax, DWORD PTR j$7[rsp]
	inc	eax
	mov	DWORD PTR j$7[rsp], eax
$LN14@ExpandText:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR j$7[rsp], eax
	jge	SHORT $LN13@ExpandText

; 889  :                                 if ( tokenarray[j].token == T_OP_BRACKET )

	movsxd	rax, DWORD PTR j$7[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN33@ExpandText

; 890  :                                     cnt++;

	mov	eax, DWORD PTR cnt$8[rsp]
	inc	eax
	mov	DWORD PTR cnt$8[rsp], eax
	jmp	SHORT $LN34@ExpandText
$LN33@ExpandText:

; 891  :                                 else if ( tokenarray[j].token == T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR j$7[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN35@ExpandText

; 892  :                                     cnt--;

	mov	eax, DWORD PTR cnt$8[rsp]
	dec	eax
	mov	DWORD PTR cnt$8[rsp], eax

; 893  :                                     if ( cnt == 0 ) {

	cmp	DWORD PTR cnt$8[rsp], 0
	jne	SHORT $LN36@ExpandText

; 894  :                                         j++;

	mov	eax, DWORD PTR j$7[rsp]
	inc	eax
	mov	DWORD PTR j$7[rsp], eax

; 895  :                                         break;

	jmp	SHORT $LN13@ExpandText
$LN36@ExpandText:
$LN35@ExpandText:
$LN34@ExpandText:

; 896  :                                     }
; 897  :                                 }
; 898  :                             }

	jmp	$LN12@ExpandText
$LN13@ExpandText:

; 899  :                             /* don't substitute inside quoted strings if there's no '&' */
; 900  :                             if ( quoted_string && *(pIdent-1) != '&' && tokenarray[j].token != '&' ) {

	movsx	eax, BYTE PTR quoted_string$[rsp]
	test	eax, eax
	je	SHORT $LN37@ExpandText
	mov	rax, QWORD PTR pIdent$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN37@ExpandText
	movsxd	rax, DWORD PTR j$7[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN37@ExpandText

; 901  :                                 Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax

; 902  :                                 continue;

	jmp	$LN61@ExpandText
$LN37@ExpandText:

; 903  :                             }
; 904  :                             if ( substitute ) {

	cmp	DWORD PTR substitute$[rsp], 0
	je	SHORT $LN38@ExpandText

; 905  :                                 if ( *(pIdent-1) == '&' )

	mov	rax, QWORD PTR pIdent$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN40@ExpandText

; 906  :                                     pIdent--;

	mov	rax, QWORD PTR pIdent$[rsp]
	dec	rax
	mov	QWORD PTR pIdent$[rsp], rax
$LN40@ExpandText:

; 907  :                             } else if ( pIdent > old_stringbufferend && *(pIdent-1) == '%' )

	jmp	SHORT $LN39@ExpandText
$LN38@ExpandText:
	mov	rax, QWORD PTR old_stringbufferend$[rsp]
	cmp	QWORD PTR pIdent$[rsp], rax
	jbe	SHORT $LN41@ExpandText
	mov	rax, QWORD PTR pIdent$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN41@ExpandText

; 908  :                                 pIdent--;

	mov	rax, QWORD PTR pIdent$[rsp]
	dec	rax
	mov	QWORD PTR pIdent$[rsp], rax
$LN41@ExpandText:
$LN39@ExpandText:

; 909  :                             //*StringBufferEnd = NULLC;
; 910  :                             i = RunMacro( (struct dsym *)sym, i, tokenarray, pDst, 0, &is_exitm );

	lea	rax, QWORD PTR is_exitm$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR pDst$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$6[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	RunMacro
	mov	DWORD PTR i$6[rsp], eax

; 911  :                             Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax

; 912  :                             DebugMsg1(( "ExpandText: back from RunMacro(%s), rc=%u, text returned=>%s<, rest=>%s<\n", sym->name, i, pDst, i >= 0 ? tokenarray[i].tokpos : "" ));

	cmp	DWORD PTR i$6[rsp], 0
	jl	SHORT $LN59@ExpandText
	movsxd	rax, DWORD PTR i$6[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR tv282[rsp], rax
	jmp	SHORT $LN60@ExpandText
$LN59@ExpandText:
	lea	rax, OFFSET FLAT:$SG11316
	mov	QWORD PTR tv282[rsp], rax
$LN60@ExpandText:
	mov	rax, QWORD PTR tv282[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR pDst$[rsp]
	mov	r8d, DWORD PTR i$6[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11317
	call	DoDebugMsg1

; 913  :                             if ( i == -1 ) {

	cmp	DWORD PTR i$6[rsp], -1
	jne	SHORT $LN42@ExpandText

; 914  :                                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExpandText
$LN42@ExpandText:

; 915  :                             }
; 916  :                             pSrc = tokenarray[i-1].tokpos + strlen( tokenarray[i-1].string_ptr );

	mov	eax, DWORD PTR i$6[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	QWORD PTR tv292[rsp], rax
	mov	ecx, DWORD PTR i$6[rsp]
	dec	ecx
	movsxd	rcx, ecx
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+8]
	call	strlen
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR tv292[rsp]
	add	rax, QWORD PTR [rcx+rdx+24]
	mov	QWORD PTR pSrc$[rsp], rax

; 917  :                             if ( substitute && *pSrc == '&' )

	cmp	DWORD PTR substitute$[rsp], 0
	je	SHORT $LN43@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN43@ExpandText

; 918  :                                 pSrc++;

	mov	rax, QWORD PTR pSrc$[rsp]
	inc	rax
	mov	QWORD PTR pSrc$[rsp], rax
$LN43@ExpandText:

; 919  :                             sp[lvl++] = pSrc;

	movsxd	rax, DWORD PTR lvl$[rsp]
	mov	rcx, QWORD PTR pSrc$[rsp]
	mov	QWORD PTR sp$[rsp+rax*8], rcx
	mov	eax, DWORD PTR lvl$[rsp]
	inc	eax
	mov	DWORD PTR lvl$[rsp], eax

; 920  :                             pSrc = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR pSrc$[rsp], rax

; 921  :                             cnt = strlen( pDst );

	mov	rcx, QWORD PTR pDst$[rsp]
	call	strlen
	mov	DWORD PTR cnt$8[rsp], eax

; 922  :                             memcpy( pSrc, pDst, cnt + 1 );

	mov	eax, DWORD PTR cnt$8[rsp]
	inc	eax
	cdqe
	mov	r8, rax
	mov	rdx, QWORD PTR pDst$[rsp]
	mov	rcx, QWORD PTR pSrc$[rsp]
	call	memcpy

; 923  :                             StringBufferEnd = GetAlignedPointer( pSrc, cnt );

	mov	eax, DWORD PTR cnt$8[rsp]
	inc	eax
	cdqe
	add	rax, 7
	and	rax, -8
	mov	rcx, QWORD PTR pSrc$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ModuleInfo+488, rax

; 924  :                             pDst = pIdent;

	mov	rax, QWORD PTR pIdent$[rsp]
	mov	QWORD PTR pDst$[rsp], rax

; 925  :                             rc = STRING_EXPANDED;

	mov	DWORD PTR rc$[rsp], 1
$LN32@ExpandText:

; 926  :                         }

	jmp	SHORT $LN31@ExpandText
$LN30@ExpandText:

; 927  :                     } else if ( sym->state == SYM_MACRO ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	jne	SHORT $LN44@ExpandText

; 928  :                         macro_proc = TRUE;

	mov	BYTE PTR macro_proc$[rsp], 1
$LN44@ExpandText:
$LN31@ExpandText:
$LN23@ExpandText:

; 929  :                     }
; 930  :                     if ( lvl == MAX_TEXTMACRO_NESTING ) {

	cmp	DWORD PTR lvl$[rsp], 20
	jne	SHORT $LN45@ExpandText

; 931  :                         DebugMsg(("ExpandText(line=>%s<) error exit\n", line));

	mov	rdx, QWORD PTR line$[rsp]
	lea	rcx, OFFSET FLAT:$SG11322
	call	DoDebugMsg

; 932  :                         EmitError( MACRO_NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 101				; 00000065H
	call	EmitError

; 933  :                         break;

	jmp	SHORT $LN6@ExpandText
$LN45@ExpandText:
$LN21@ExpandText:

; 934  :                     }
; 935  :                 }
; 936  :             } else {

	jmp	SHORT $LN16@ExpandText
$LN15@ExpandText:

; 937  :                 if ( *pSrc == '"' || *pSrc == '\'' ) {

	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN47@ExpandText
	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN46@ExpandText
$LN47@ExpandText:

; 938  :                     if ( quoted_string == 0 )

	movsx	eax, BYTE PTR quoted_string$[rsp]
	test	eax, eax
	jne	SHORT $LN48@ExpandText

; 939  :                         quoted_string = *pSrc;

	mov	rax, QWORD PTR pSrc$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR quoted_string$[rsp], al
	jmp	SHORT $LN49@ExpandText
$LN48@ExpandText:

; 940  :                     else if ( *pSrc == quoted_string )

	mov	rax, QWORD PTR pSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	movsx	ecx, BYTE PTR quoted_string$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN50@ExpandText

; 941  :                         quoted_string = 0;

	mov	BYTE PTR quoted_string$[rsp], 0
$LN50@ExpandText:
$LN49@ExpandText:
$LN46@ExpandText:

; 942  :                 }
; 943  :                 *pDst++ = *pSrc++;

	mov	rax, QWORD PTR pDst$[rsp]
	mov	rcx, QWORD PTR pSrc$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR pDst$[rsp]
	inc	rax
	mov	QWORD PTR pDst$[rsp], rax
	mov	rax, QWORD PTR pSrc$[rsp]
	inc	rax
	mov	QWORD PTR pSrc$[rsp], rax
$LN16@ExpandText:

; 944  :             }
; 945  :         } /* end while */

	jmp	$LN62@ExpandText
$LN6@ExpandText:

; 946  :     }

	jmp	$LN2@ExpandText
$LN3@ExpandText:

; 947  :     *pDst++ = NULLC;

	mov	rax, QWORD PTR pDst$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR pDst$[rsp]
	inc	rax
	mov	QWORD PTR pDst$[rsp], rax

; 948  : 
; 949  :     StringBufferEnd = old_stringbufferend;

	mov	rax, QWORD PTR old_stringbufferend$[rsp]
	mov	QWORD PTR ModuleInfo+488, rax

; 950  :     if ( rc == STRING_EXPANDED ) {

	cmp	DWORD PTR rc$[rsp], 1
	jne	SHORT $LN51@ExpandText

; 951  :         memcpy( line, StringBufferEnd, pDst - StringBufferEnd );

	mov	rax, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR pDst$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR line$[rsp]
	call	memcpy

; 952  :         DebugMsg1(("ExpandText: expanded line=>%s<\n", line));

	mov	rdx, QWORD PTR line$[rsp]
	lea	rcx, OFFSET FLAT:$SG11329
	call	DoDebugMsg1
$LN51@ExpandText:

; 953  :     }
; 954  :     if ( substitute ) {

	cmp	DWORD PTR substitute$[rsp], 0
	je	SHORT $LN52@ExpandText

; 955  :         if ( rc == STRING_EXPANDED ) {

	cmp	DWORD PTR rc$[rsp], 1
	jne	SHORT $LN53@ExpandText

; 956  :             Token_Count = Tokenize( tokenarray[0].tokpos, 0, tokenarray, TOK_RESCAN );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+24]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax
$LN53@ExpandText:

; 957  :         }
; 958  :         if ( rc == STRING_EXPANDED || macro_proc ) {

	cmp	DWORD PTR rc$[rsp], 1
	je	SHORT $LN55@ExpandText
	movsx	eax, BYTE PTR macro_proc$[rsp]
	test	eax, eax
	je	SHORT $LN54@ExpandText
$LN55@ExpandText:

; 959  :             return( ExpandLine( tokenarray[0].tokpos, tokenarray ) );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+24]
	call	ExpandLine
	jmp	SHORT $LN1@ExpandText
$LN54@ExpandText:
$LN52@ExpandText:

; 960  :         }
; 961  :     }
; 962  :     return( rc );

	mov	eax, DWORD PTR rc$[rsp]
$LN1@ExpandText:

; 963  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:ExpandText$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 384				; 00000180H
	pop	rdi
	ret	0
ExpandText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
currparm$ = 0
savedStringBuffer$ = 8
i$ = 20
parmidx$ = 36
skipcomma$ = 40
varargcnt$ = 44
bracket_level$ = 48
parm_end_delim$ = 52
ptr$ = 56
parmstrings$ = 64
info$ = 72
lnode$ = 80
sym$ = 88
opndx$ = 112
mi$ = 248
inside_literal$12 = 308
inside_angle_brackets$13 = 312
old_tokencount$14 = 316
max$15 = 320
cnt$16 = 324
cnt_opnum$17 = 328
cnt2$18 = 332
p$19 = 336
tmp$20 = 344
p$21 = 352
tmp$22 = 360
size$23 = 364
is_exitm2$24 = 372
p$25 = 392
end$26 = 400
oldstat$27 = 424
oldifnesting$28 = 468
cntgoto$29 = 472
len$30 = 476
len$31 = 480
$T32 = 496
$T33 = 497
$T34 = 498
__$AllocaPad$$ = 520
tv1729 = 536
tv177 = 544
tv310 = 552
tv646 = 560
tv678 = 564
tv912 = 568
tv986 = 572
tv1059 = 576
tv1073 = 580
tv1113 = 584
tv1419 = 592
tv1508 = 600
__$ArrayPad$ = 608
macro$ = 656
idx$ = 664
tokenarray$ = 672
out$ = 680
mflags$ = 688
is_exitm$ = 696
RunMacro PROC

; 131  : {

$LN264:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 680				; 000002a8H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 170				; 000000aaH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+712]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	mov	QWORD PTR __$AllocaPad$$[rbp], 0
	mov	BYTE PTR $T32[rbp], 0
	mov	BYTE PTR $T34[rbp], 0
	mov	BYTE PTR $T33[rbp], 0

; 132  :     char        *currparm;
; 133  :     char        *savedStringBuffer = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR savedStringBuffer$[rbp], rax

; 134  :     int         i;
; 135  :     //int         start = idx-1;
; 136  :     int         parmidx;
; 137  :     int         skipcomma;
; 138  :     int         varargcnt;
; 139  :     int         bracket_level = -1;/* () level (needed for macro functions) */

	mov	DWORD PTR bracket_level$[rbp], -1

; 140  :     int         parm_end_delim;   /* parameter end delimiter */
; 141  :     //char        addprefix;
; 142  :     char        *ptr;
; 143  :     char        *parmstrings;
; 144  :     struct macro_info *info;
; 145  :     struct srcline    *lnode;
; 146  :     struct asym       *sym;
; 147  :     struct expr       opndx;
; 148  :     struct macro_instance mi;
; 149  : 
; 150  :     DebugMsg1(("RunMacro(%s, idx=%u src=>%s< ) enter, lvl=%u, locals=%04u\n", macro->sym.name, idx, tokenarray[idx].tokpos, MacroLevel, MacroLocals ));

	movzx	eax, BYTE PTR MacroLevel
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	edx, DWORD PTR MacroLocals
	mov	DWORD PTR [rsp+40], edx
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	r9, QWORD PTR [rax+rcx+24]
	mov	r8d, DWORD PTR idx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11067
	call	DoDebugMsg1

; 151  : 
; 152  :     if ( MacroLevel == MAX_MACRO_NESTING ) {

	movzx	eax, BYTE PTR MacroLevel
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN40@RunMacro

; 153  :         EmitError( NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 100				; 00000064H
	call	EmitError

; 154  :         return( -1 );

	mov	eax, -1
	jmp	$LN1@RunMacro
$LN40@RunMacro:

; 155  :     }
; 156  :     mi.parm_array = NULL;

	mov	QWORD PTR mi$[rbp+24], 0

; 157  :     info = macro->e.macroinfo;

	mov	rax, QWORD PTR macro$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR info$[rbp], rax

; 158  : #ifdef DEBUG_OUT
; 159  :     info->count++;

	mov	rax, QWORD PTR info$[rbp]
	mov	eax, DWORD PTR [rax+24]
	inc	eax
	mov	rcx, QWORD PTR info$[rbp]
	mov	DWORD PTR [rcx+24], eax

; 160  : #endif
; 161  : 
; 162  :     /* invokation of macro functions requires params enclosed in "()" */
; 163  : 
; 164  :     parm_end_delim = T_FINAL;

	mov	DWORD PTR parm_end_delim$[rbp], 0

; 165  :     if ( macro->sym.isfunc ) {

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN41@RunMacro

; 166  :         if ( tokenarray[idx].token == T_OP_BRACKET ) { /* should be always true */

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN42@RunMacro

; 167  :             idx++;

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax

; 168  :             parm_end_delim = T_CL_BRACKET;

	mov	DWORD PTR parm_end_delim$[rbp], 41	; 00000029H

; 169  :             bracket_level = 1;

	mov	DWORD PTR bracket_level$[rbp], 1
$LN42@RunMacro:

; 170  :         }
; 171  :         *out = NULLC; /* v2.08: init return value buffer */

	mov	rax, QWORD PTR out$[rbp]
	mov	BYTE PTR [rax], 0
$LN41@RunMacro:

; 172  :     }
; 173  :     /* v2.08: if macro is purged, return "void" */
; 174  :     if ( macro->sym.purged ) {

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN43@RunMacro

; 175  :         if ( bracket_level > 0 ) {

	cmp	DWORD PTR bracket_level$[rbp], 0
	jle	SHORT $LN44@RunMacro

; 176  :             for( ; bracket_level && tokenarray[idx].token != T_FINAL; idx++ )

	jmp	SHORT $LN4@RunMacro
$LN2@RunMacro:
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax
$LN4@RunMacro:
	cmp	DWORD PTR bracket_level$[rbp], 0
	je	SHORT $LN3@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN3@RunMacro

; 177  :                 if ( tokenarray[idx].token == T_OP_BRACKET )

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN46@RunMacro

; 178  :                     bracket_level++;

	mov	eax, DWORD PTR bracket_level$[rbp]
	inc	eax
	mov	DWORD PTR bracket_level$[rbp], eax
	jmp	SHORT $LN47@RunMacro
$LN46@RunMacro:

; 179  :                 else if ( tokenarray[idx].token == T_CL_BRACKET )

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN48@RunMacro

; 180  :                     bracket_level--;

	mov	eax, DWORD PTR bracket_level$[rbp]
	dec	eax
	mov	DWORD PTR bracket_level$[rbp], eax
$LN48@RunMacro:
$LN47@RunMacro:
	jmp	SHORT $LN2@RunMacro
$LN3@RunMacro:

; 181  :         } else

	jmp	SHORT $LN45@RunMacro
$LN44@RunMacro:

; 182  :             idx = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR idx$[rbp], eax
$LN45@RunMacro:

; 183  :         DebugMsg1(("RunMacro(%s) exit, macro is purged\n", macro->sym.name ));

	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11077
	call	DoDebugMsg1

; 184  :         return( idx );

	mov	eax, DWORD PTR idx$[rbp]
	jmp	$LN1@RunMacro
$LN43@RunMacro:

; 185  :     }
; 186  : 
; 187  :     DebugMsg1(( "RunMacro(%s): params=>%s< parmcnt=%u vararg=%u\n", macro->sym.name, tokenarray[idx].tokpos, info->parmcnt, macro->sym.mac_vararg ));

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	and	al, 1
	movzx	eax, al
	mov	rcx, QWORD PTR info$[rbp]
	movzx	ecx, WORD PTR [rcx]
	movsxd	rdx, DWORD PTR idx$[rbp]
	imul	rdx, rdx, 32				; 00000020H
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	r8, QWORD PTR [rax+rdx+24]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11078
	call	DoDebugMsg1

; 188  : 
; 189  :     if ( info->parmcnt ) {

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	je	$LN49@RunMacro

; 190  :         mi.parm_array = (char **)myalloca( info->parmcnt * sizeof( char * ) + PARMSTRINGSIZE );

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax]
	lea	rax, QWORD PTR [rax*8+1200]
	add	rax, 36					; 00000024H
	mov	QWORD PTR tv1729[rbp], rax
	mov	rax, QWORD PTR tv1729[rbp]
	add	rax, 15
	cmp	rax, QWORD PTR tv1729[rbp]
	ja	SHORT $LN263@RunMacro
	mov	rax, 1152921504606846960		; 0ffffffffffffff0H
$LN263@RunMacro:
	and	rax, -16
	call	__chkstk
	sub	rsp, rax
	lea	rax, QWORD PTR [rsp+48]
	mov	QWORD PTR tv177[rbp], rax
	lea	r8, QWORD PTR __$AllocaPad$$[rbp]
	mov	rdx, QWORD PTR tv1729[rbp]
	mov	rcx, QWORD PTR tv177[rbp]
	call	_RTC_AllocaHelper
	add	QWORD PTR tv177[rbp], 32		; 00000020H
	mov	rax, QWORD PTR tv177[rbp]
	mov	QWORD PTR mi$[rbp+24], rax

; 191  :         parmstrings = (char *)(mi.parm_array + info->parmcnt);

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR mi$[rbp+24]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	BYTE PTR $T32[rbp], 1
	mov	QWORD PTR parmstrings$[rbp], rax

; 192  :         /* init the macro arguments pointer */
; 193  :         currparm = parmstrings;

	cmp	BYTE PTR $T32[rbp], 0
	jne	SHORT $LN188@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$0
	call	_RTC_UninitUse
$LN188@RunMacro:
	mov	BYTE PTR $T33[rbp], 1
	mov	rax, QWORD PTR parmstrings$[rbp]
	mov	QWORD PTR currparm$[rbp], rax
$LN49@RunMacro:

; 194  :     }
; 195  : 
; 196  :     /* now get all the parameters from the original src line.
; 197  :      * macro parameters are expanded if
; 198  :      * - it is a macro function call            or
; 199  :      * - the expansion operator (%) is found
; 200  :      */
; 201  : 
; 202  :     parmidx = 0;

	mov	DWORD PTR parmidx$[rbp], 0

; 203  : #if MACROLABEL
; 204  :     if ( macro->sym.label ) {

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN50@RunMacro

; 205  :         if ( mflags & MF_LABEL ) {

	mov	eax, DWORD PTR mflags$[rbp]
	and	eax, 1
	test	eax, eax
	je	$LN51@RunMacro

; 206  :             i = strlen( tokenarray[0].string_ptr );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	strlen
	mov	DWORD PTR i$[rbp], eax

; 207  :             mi.parm_array[parmidx] = currparm;

	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN189@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN189@RunMacro:
	movsxd	rax, DWORD PTR parmidx$[rbp]
	mov	rcx, QWORD PTR mi$[rbp+24]
	mov	rdx, QWORD PTR currparm$[rbp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 208  :             memcpy( currparm, tokenarray[0].string_ptr, i+1 );

	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN190@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN190@RunMacro:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	cdqe
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 0
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	mov	rcx, QWORD PTR currparm$[rbp]
	call	memcpy

; 209  :             currparm = GetAlignedPointer( currparm, i );

	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN191@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN191@RunMacro:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	cdqe
	add	rax, 7
	and	rax, -8
	mov	rcx, QWORD PTR currparm$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR $T33[rbp], 1
	mov	QWORD PTR currparm$[rbp], rax

; 210  :         } else

	jmp	SHORT $LN52@RunMacro
$LN51@RunMacro:

; 211  :             mi.parm_array[parmidx] = "";

	movsxd	rax, DWORD PTR parmidx$[rbp]
	mov	rcx, QWORD PTR mi$[rbp+24]
	lea	rdx, OFFSET FLAT:$SG11083
	mov	QWORD PTR [rcx+rax*8], rdx
$LN52@RunMacro:

; 212  :         parmidx++;

	mov	eax, DWORD PTR parmidx$[rbp]
	inc	eax
	mov	DWORD PTR parmidx$[rbp], eax
$LN50@RunMacro:

; 213  :     }
; 214  : #endif
; 215  : 
; 216  :     *is_exitm = FALSE;

	mov	rax, QWORD PTR is_exitm$[rbp]
	mov	BYTE PTR [rax], 0

; 217  : 
; 218  :     /* v2.08: allow T_FINAL to be chained, lastidx==0 is true final */
; 219  :     tokenarray[Token_Count].lastidx = 0;

	movsxd	rax, DWORD PTR ModuleInfo+496
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	DWORD PTR [rcx+rax+16], 0

; 220  : 
; 221  :     for( varargcnt = 0, skipcomma = 0; parmidx < info->parmcnt; parmidx++ ) {

	mov	DWORD PTR varargcnt$[rbp], 0
	mov	DWORD PTR skipcomma$[rbp], 0
	jmp	SHORT $LN7@RunMacro
$LN5@RunMacro:
	mov	eax, DWORD PTR parmidx$[rbp]
	inc	eax
	mov	DWORD PTR parmidx$[rbp], eax
$LN7@RunMacro:
	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax]
	cmp	DWORD PTR parmidx$[rbp], eax
	jge	$LN6@RunMacro

; 222  : 
; 223  :         /* v2.09: don't skip comma if it was the last argument.
; 224  :          * this will a) make a trailing comma trigger warning 'too many arguments...'
; 225  :          * and b), argument handling of FOR loop is significantly simplified.
; 226  :          */
; 227  :         if ( tokenarray[idx].token == T_COMMA && skipcomma )

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN53@RunMacro
	cmp	DWORD PTR skipcomma$[rbp], 0
	je	SHORT $LN53@RunMacro

; 228  :             idx++;

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax
$LN53@RunMacro:

; 229  :         skipcomma = 1;

	mov	DWORD PTR skipcomma$[rbp], 1

; 230  : 
; 231  :         if ( tokenarray[idx].token == T_FINAL ||
; 232  :             tokenarray[idx].token == parm_end_delim ||

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN56@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, DWORD PTR parm_end_delim$[rbp]
	je	SHORT $LN56@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	$LN54@RunMacro
	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN57@RunMacro
	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax]
	dec	eax
	cmp	DWORD PTR parmidx$[rbp], eax
	je	$LN54@RunMacro
$LN57@RunMacro:
$LN56@RunMacro:

; 233  :             ( tokenarray[idx].token == T_COMMA &&
; 234  :              ( macro->sym.mac_vararg == FALSE || parmidx != info->parmcnt - 1 ) ) ) {
; 235  : 
; 236  :             /* it's a blank parm */
; 237  :             if( info->parmlist[parmidx].required ) {

	movsxd	rax, DWORD PTR parmidx$[rbp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR info$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax+8]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN58@RunMacro

; 238  :                 DebugMsg1(( "RunMacro(%s.%u), parameter %u required >%s<\n", macro->sym.name, parmidx, parmidx, tokenarray[idx].tokpos ));

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR parmidx$[rbp]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11090
	call	DoDebugMsg1

; 239  :                 if ( *macro->sym.name == NULLC )

	mov	rax, QWORD PTR macro$[rbp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN59@RunMacro

; 240  :                     EmitErr( MISSING_MACRO_ARGUMENT_2, macro->sym.value + 1 );

	mov	rax, QWORD PTR macro$[rbp]
	mov	eax, DWORD PTR [rax+16]
	inc	eax
	mov	edx, eax
	mov	ecx, 87					; 00000057H
	call	EmitErr
	jmp	SHORT $LN60@RunMacro
$LN59@RunMacro:

; 241  :                 else
; 242  :                     EmitErr( MISSING_MACRO_ARGUMENT, macro->sym.name, parmidx + 1 );

	mov	eax, DWORD PTR parmidx$[rbp]
	inc	eax
	mov	r8d, eax
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 220				; 000000dcH
	call	EmitErr
$LN60@RunMacro:

; 243  :                 return( -1 );

	mov	eax, -1
	jmp	$LN1@RunMacro
$LN58@RunMacro:

; 244  :             }
; 245  :             if ( varargcnt == 0 ) {

	cmp	DWORD PTR varargcnt$[rbp], 0
	jne	SHORT $LN61@RunMacro

; 246  :                 mi.parm_array[parmidx] = info->parmlist[parmidx].deflt;

	movsxd	rax, DWORD PTR parmidx$[rbp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR info$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	movsxd	rdx, DWORD PTR parmidx$[rbp]
	mov	r8, QWORD PTR mi$[rbp+24]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR [r8+rdx*8], rax

; 247  :                 DebugMsg1(("RunMacro(%s.%u): curr (=def) parameter value=>%s<\n", macro->sym.name, parmidx, mi.parm_array[parmidx] ? parmidx, mi.parm_array[parmidx] : "NULL" ));

	movsxd	rax, DWORD PTR parmidx$[rbp]
	mov	rcx, QWORD PTR mi$[rbp+24]
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN165@RunMacro
	movsxd	rax, DWORD PTR parmidx$[rbp]
	mov	rcx, QWORD PTR mi$[rbp+24]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR tv310[rbp], rax
	jmp	SHORT $LN166@RunMacro
$LN165@RunMacro:
	lea	rax, OFFSET FLAT:$SG11094
	mov	QWORD PTR tv310[rbp], rax
$LN166@RunMacro:
	mov	r9, QWORD PTR tv310[rbp]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11095
	call	DoDebugMsg1
$LN61@RunMacro:

; 248  :             }
; 249  : 
; 250  :         } else {

	jmp	$LN55@RunMacro
$LN54@RunMacro:

; 251  :             int  inside_literal = 0;

	mov	DWORD PTR inside_literal$12[rbp], 0

; 252  :             int  inside_angle_brackets = 0;

	mov	DWORD PTR inside_angle_brackets$13[rbp], 0

; 253  :             int  old_tokencount = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR old_tokencount$14[rbp], eax

; 254  : 
; 255  :             *currparm = NULLC;

	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN192@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN192@RunMacro:
	mov	rax, QWORD PTR currparm$[rbp]
	mov	BYTE PTR [rax], 0

; 256  : 
; 257  :             DebugMsg1(( "RunMacro(%s.%u), >%s<\n", macro->sym.name, parmidx, tokenarray[idx].tokpos ));

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r9, QWORD PTR [rcx+rax+24]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11096
	call	DoDebugMsg1

; 258  : 
; 259  :             for( ptr = currparm; ( tokenarray[idx].token != T_FINAL && tokenarray[idx].token != T_COMMA ) || inside_literal; idx++ ) {

	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN193@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN193@RunMacro:
	mov	BYTE PTR $T34[rbp], 1
	mov	rax, QWORD PTR currparm$[rbp]
	mov	QWORD PTR ptr$[rbp], rax
	jmp	SHORT $LN10@RunMacro
$LN8@RunMacro:
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax
$LN10@RunMacro:
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN63@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN62@RunMacro
$LN63@RunMacro:
	cmp	DWORD PTR inside_literal$12[rbp], 0
	je	$LN9@RunMacro
$LN62@RunMacro:

; 260  : 
; 261  :                 /* if were're inside a literal, go up one level and continue scanning the argument */
; 262  :                 if ( tokenarray[idx].token == T_FINAL ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	$LN64@RunMacro

; 263  :                     idx = tokenarray[idx].lastidx; /* restore token index */

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR idx$[rbp], eax

; 264  :                     inside_literal--;

	mov	eax, DWORD PTR inside_literal$12[rbp]
	dec	eax
	mov	DWORD PTR inside_literal$12[rbp], eax

; 265  :                     if ( tokenarray[idx].string_delim == '<' )

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN65@RunMacro

; 266  :                         inside_angle_brackets = 0;

	mov	DWORD PTR inside_angle_brackets$13[rbp], 0
	jmp	SHORT $LN66@RunMacro
$LN65@RunMacro:

; 267  :                     else {
; 268  :                         *ptr++ = '}';

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN194@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN194@RunMacro:
	mov	rax, QWORD PTR ptr$[rbp]
	mov	BYTE PTR [rax], 125			; 0000007dH
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN195@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN195@RunMacro:
	mov	rax, QWORD PTR ptr$[rbp]
	inc	rax
	mov	BYTE PTR $T34[rbp], 1
	mov	QWORD PTR ptr$[rbp], rax
$LN66@RunMacro:

; 269  :                     }
; 270  :                     continue;

	jmp	$LN8@RunMacro
$LN64@RunMacro:

; 271  :                 }
; 272  : 
; 273  :                 if ( tokenarray[idx].token == T_PERCENT ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	$LN67@RunMacro

; 274  :                     int max;
; 275  :                     int cnt;
; 276  :                     int cnt_opnum;
; 277  :                     /* expansion of macro parameters.
; 278  :                      * if the token behind % is not a text macro or macro function
; 279  :                      * the expression will be always expanded and evaluated.
; 280  :                      * Else it is expanded, but only evaluated if
; 281  :                      */
; 282  :                     idx++;

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax
$LN11@RunMacro:

; 283  :                     while ( tokenarray[idx].token == T_PERCENT ) idx++;

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN12@RunMacro
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax
	jmp	SHORT $LN11@RunMacro
$LN12@RunMacro:

; 284  :                     i = idx;

	mov	eax, DWORD PTR idx$[rbp]
	mov	DWORD PTR i$[rbp], eax

; 285  :                     cnt_opnum = 1;

	mov	DWORD PTR cnt_opnum$17[rbp], 1

; 286  :                     if ( tokenarray[i].token == T_ID ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN68@RunMacro

; 287  :                         sym = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rbp], rax

; 288  :                         if ( sym && sym->isdefined &&

	cmp	QWORD PTR sym$[rbp], 0
	je	SHORT $LN69@RunMacro
	mov	rax, QWORD PTR sym$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN69@RunMacro
	mov	rax, QWORD PTR sym$[rbp]
	cmp	DWORD PTR [rax+32], 10
	je	SHORT $LN70@RunMacro
	mov	rax, QWORD PTR sym$[rbp]
	cmp	DWORD PTR [rax+32], 9
	jne	SHORT $LN69@RunMacro
	mov	rax, QWORD PTR sym$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN69@RunMacro
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN69@RunMacro
$LN70@RunMacro:

; 289  :                             ( sym->state == SYM_TMACRO ||
; 290  :                              ( sym->state == SYM_MACRO && sym->isfunc == TRUE && tokenarray[i+1].token == T_OP_BRACKET ) ) )
; 291  :                             cnt_opnum = 0;

	mov	DWORD PTR cnt_opnum$17[rbp], 0
$LN69@RunMacro:
$LN68@RunMacro:

; 292  :                     }
; 293  : 
; 294  :                     for( cnt = 0; tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA; i++ ) {

	mov	DWORD PTR cnt$16[rbp], 0
	jmp	SHORT $LN15@RunMacro
$LN13@RunMacro:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN15@RunMacro:
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN14@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	$LN14@RunMacro

; 295  :                         if ( is_valid_id_first_char( *tokenarray[i].string_ptr )) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalpha
	test	eax, eax
	jne	$LN72@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	$LN72@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN72@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN72@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN72@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	jne	$LN71@RunMacro
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 4
	and	eax, 1
	cmp	eax, 1
	jne	$LN71@RunMacro
$LN72@RunMacro:

; 296  :                             if ( tokenarray[i+1].token == T_OP_BRACKET ) {

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	$LN73@RunMacro

; 297  :                                 int cnt2;
; 298  :                                 i += 2;

	mov	eax, DWORD PTR i$[rbp]
	add	eax, 2
	mov	DWORD PTR i$[rbp], eax

; 299  :                                 for ( cnt2 = 1;cnt2 && tokenarray[i].token != T_FINAL; i++ ) {

	mov	DWORD PTR cnt2$18[rbp], 1
	jmp	SHORT $LN18@RunMacro
$LN16@RunMacro:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN18@RunMacro:
	cmp	DWORD PTR cnt2$18[rbp], 0
	je	SHORT $LN17@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN17@RunMacro

; 300  :                                     if ( tokenarray[i].token == T_OP_BRACKET )

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN74@RunMacro

; 301  :                                         cnt2++;

	mov	eax, DWORD PTR cnt2$18[rbp]
	inc	eax
	mov	DWORD PTR cnt2$18[rbp], eax
	jmp	SHORT $LN75@RunMacro
$LN74@RunMacro:

; 302  :                                     else if ( tokenarray[i].token == T_CL_BRACKET )

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN76@RunMacro

; 303  :                                         cnt2--;

	mov	eax, DWORD PTR cnt2$18[rbp]
	dec	eax
	mov	DWORD PTR cnt2$18[rbp], eax
$LN76@RunMacro:
$LN75@RunMacro:

; 304  :                                 }

	jmp	SHORT $LN16@RunMacro
$LN17@RunMacro:

; 305  :                                 i--;

	mov	eax, DWORD PTR i$[rbp]
	dec	eax
	mov	DWORD PTR i$[rbp], eax
$LN73@RunMacro:

; 306  :                             }
; 307  :                             continue;

	jmp	$LN13@RunMacro
$LN71@RunMacro:

; 308  :                         }
; 309  :                         /* count brackets */
; 310  :                         if ( parm_end_delim == T_CL_BRACKET )

	cmp	DWORD PTR parm_end_delim$[rbp], 41	; 00000029H
	jne	SHORT $LN77@RunMacro

; 311  :                             if ( tokenarray[i].token == T_OP_BRACKET )

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN78@RunMacro

; 312  :                                 cnt++;

	mov	eax, DWORD PTR cnt$16[rbp]
	inc	eax
	mov	DWORD PTR cnt$16[rbp], eax
	jmp	SHORT $LN79@RunMacro
$LN78@RunMacro:

; 313  :                             else if ( tokenarray[i].token == T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN80@RunMacro

; 314  :                                 if ( cnt == 0 )

	cmp	DWORD PTR cnt$16[rbp], 0
	jne	SHORT $LN81@RunMacro

; 315  :                                     break;

	jmp	$LN14@RunMacro
$LN81@RunMacro:

; 316  :                                 cnt--;

	mov	eax, DWORD PTR cnt$16[rbp]
	dec	eax
	mov	DWORD PTR cnt$16[rbp], eax
$LN80@RunMacro:
$LN79@RunMacro:
$LN77@RunMacro:

; 317  :                             }
; 318  : 
; 319  :                         /* stop if undelimited string occurs (need to scan for '!') */
; 320  :                         if ( tokenarray[i].token == T_STRING && tokenarray[i].string_delim == NULLC )

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN82@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	test	eax, eax
	jne	SHORT $LN82@RunMacro

; 321  :                             break;

	jmp	SHORT $LN14@RunMacro
$LN82@RunMacro:

; 322  : 
; 323  :                         /* names dot and amp are ok */
; 324  :                         if ( tokenarray[i].token == T_DOT || tokenarray[i].token == '&' || tokenarray[i].token == '%' )

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN85@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN85@RunMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN83@RunMacro
$LN85@RunMacro:

; 325  :                             ;

	jmp	SHORT $LN84@RunMacro
$LN83@RunMacro:

; 326  :                         else
; 327  :                             cnt_opnum++; /* anything else will trigger numeric evaluation */

	mov	eax, DWORD PTR cnt_opnum$17[rbp]
	inc	eax
	mov	DWORD PTR cnt_opnum$17[rbp], eax
$LN84@RunMacro:

; 328  :                     }

	jmp	$LN13@RunMacro
$LN14@RunMacro:

; 329  : 
; 330  :                     if ( i == idx ) { /* no items except %? */

	mov	eax, DWORD PTR idx$[rbp]
	cmp	DWORD PTR i$[rbp], eax
	jne	SHORT $LN86@RunMacro

; 331  :                         idx--;

	mov	eax, DWORD PTR idx$[rbp]
	dec	eax
	mov	DWORD PTR idx$[rbp], eax

; 332  :                         continue;

	jmp	$LN8@RunMacro
$LN86@RunMacro:

; 333  :                     }
; 334  : 
; 335  :                     cnt = tokenarray[i].tokpos - tokenarray[idx].tokpos;

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR cnt$16[rbp], eax
$LN19@RunMacro:

; 336  :                     while ( isspace( *(tokenarray[idx].tokpos+cnt-1) ) ) cnt--;

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR cnt$16[rbp]
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rdx+rax+24]
	movsx	eax, BYTE PTR [rax+rcx-1]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN20@RunMacro
	mov	eax, DWORD PTR cnt$16[rbp]
	dec	eax
	mov	DWORD PTR cnt$16[rbp], eax
	jmp	SHORT $LN19@RunMacro
$LN20@RunMacro:

; 337  :                     memcpy( ptr, tokenarray[idx].tokpos, cnt );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN196@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN196@RunMacro:
	movsxd	rax, DWORD PTR cnt$16[rbp]
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rax+rcx+24]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	memcpy

; 338  :                     *(ptr+cnt) = NULLC;

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN197@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN197@RunMacro:
	movsxd	rax, DWORD PTR cnt$16[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	mov	BYTE PTR [rcx+rax], 0

; 339  :                     if ( ExpandText( ptr, tokenarray, FALSE ) == ERROR ) {

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN198@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN198@RunMacro:
	xor	r8d, r8d
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	ExpandText
	cmp	eax, -1
	jne	SHORT $LN87@RunMacro

; 340  :                         StringBufferEnd = savedStringBuffer;

	mov	rax, QWORD PTR savedStringBuffer$[rbp]
	mov	QWORD PTR ModuleInfo+488, rax

; 341  :                         return(-1);

	mov	eax, -1
	jmp	$LN1@RunMacro
$LN87@RunMacro:

; 342  :                     }
; 343  :                     idx = i - 1;

	mov	eax, DWORD PTR i$[rbp]
	dec	eax
	mov	DWORD PTR idx$[rbp], eax

; 344  :                     if ( cnt_opnum ) {

	cmp	DWORD PTR cnt_opnum$17[rbp], 0
	je	$LN88@RunMacro

; 345  :                         /* convert numeric expression into a string */
; 346  :                         max = Tokenize( ptr, Token_Count+1, tokenarray, TOK_RESCAN );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN199@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN199@RunMacro:
	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR ptr$[rbp]
	call	Tokenize
	mov	DWORD PTR max$15[rbp], eax

; 347  :                         i = Token_Count + 1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR i$[rbp], eax

; 348  :                         DebugMsg1(( "RunMacro(%s.%u), num expansion: >%s<\n", macro->sym.name, parmidx, ptr ));

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN200@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN200@RunMacro:
	mov	r9, QWORD PTR ptr$[rbp]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11124
	call	DoDebugMsg1

; 349  :                         /* the % operator won't accept forward references.
; 350  :                          * v2.09: flag EXPF_NOUNDEF set.
; 351  :                          */
; 352  :                         if ( EvalOperand( &i, tokenarray, max, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	BYTE PTR [rsp+32], 2
	lea	r9, QWORD PTR opndx$[rbp]
	mov	r8d, DWORD PTR max$15[rbp]
	mov	rdx, QWORD PTR tokenarray$[rbp]
	lea	rcx, QWORD PTR i$[rbp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN89@RunMacro

; 353  :                             opndx.llvalue = 0;

	mov	QWORD PTR opndx$[rbp], 0
	jmp	SHORT $LN90@RunMacro
$LN89@RunMacro:

; 354  :                         else if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rbp+60], 0
	je	SHORT $LN91@RunMacro

; 355  :                             EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 356  :                             opndx.llvalue = 0;

	mov	QWORD PTR opndx$[rbp], 0
$LN91@RunMacro:
$LN90@RunMacro:

; 357  :                         }
; 358  :                         DebugMsg1(( "RunMacro(%s.%u): num expansion, opndx.type=%d, value=%d\n", macro->sym.name, parmidx, opndx.type, opndx.value ));

	mov	eax, DWORD PTR opndx$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR opndx$[rbp+96]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11128
	call	DoDebugMsg1

; 359  :                         /* v2.08: accept constant and copy any stuff that's following */
; 360  :                         myltoa( opndx.uvalue, StringBufferEnd, ModuleInfo.radix, opndx.hvalue < 0, FALSE );

	cmp	DWORD PTR opndx$[rbp+4], 0
	jge	SHORT $LN167@RunMacro
	mov	DWORD PTR tv646[rbp], 1
	jmp	SHORT $LN168@RunMacro
$LN167@RunMacro:
	mov	DWORD PTR tv646[rbp], 0
$LN168@RunMacro:
	movzx	eax, BYTE PTR ModuleInfo+396
	mov	BYTE PTR [rsp+32], 0
	movzx	r9d, BYTE PTR tv646[rbp]
	mov	r8d, eax
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	ecx, DWORD PTR opndx$[rbp]
	call	myltoa

; 361  :                         //ptr += strlen( ptr );
; 362  :                         if ( i != max ) {

	mov	eax, DWORD PTR max$15[rbp]
	cmp	DWORD PTR i$[rbp], eax
	je	SHORT $LN92@RunMacro

; 363  :                             /* the evaluator was unable to evaluate the full expression. the rest
; 364  :                              * has to be "copied" */
; 365  :                             DebugMsg1(( "RunMacro(%s.%u): num expansion, additional token=%s\n", macro->sym.name, parmidx, tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r9, QWORD PTR [rcx+rax+24]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11130
	call	DoDebugMsg1

; 366  :                             /* just copy won't work, since <>-literals aren't handled correctly then */
; 367  :                             //EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );
; 368  :                             strcat( StringBufferEnd, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	rcx, QWORD PTR ModuleInfo+488
	call	strcat
$LN92@RunMacro:

; 369  :                         }
; 370  :                         strcpy( ptr, StringBufferEnd );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN201@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN201@RunMacro:
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR ptr$[rbp]
	call	strcpy
$LN88@RunMacro:

; 371  :                     }
; 372  :                     ptr += strlen( ptr );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN202@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN202@RunMacro:
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN203@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN203@RunMacro:
	mov	rcx, QWORD PTR ptr$[rbp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR $T34[rbp], 1
	mov	QWORD PTR ptr$[rbp], rax

; 373  :                     /**/myassert( ptr < parmstrings + PARMSTRINGSIZE );

	cmp	BYTE PTR $T32[rbp], 0
	jne	SHORT $LN204@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$0
	call	_RTC_UninitUse
$LN204@RunMacro:
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN205@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN205@RunMacro:
	mov	rax, QWORD PTR parmstrings$[rbp]
	add	rax, 1200				; 000004b0H
	cmp	QWORD PTR ptr$[rbp], rax
	jae	SHORT $LN169@RunMacro
	mov	DWORD PTR tv678[rbp], 0
	jmp	SHORT $LN170@RunMacro
$LN169@RunMacro:
	mov	edx, 373				; 00000175H
	lea	rcx, OFFSET FLAT:$SG11131
	call	InternalError
	mov	DWORD PTR tv678[rbp], eax
$LN170@RunMacro:

; 374  :                     continue;

	jmp	$LN8@RunMacro
$LN67@RunMacro:

; 375  :                 }
; 376  : 
; 377  :                 if ( tokenarray[idx].token == T_STRING && tokenarray[idx].string_delim == '{' ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	$LN93@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 123				; 0000007bH
	jne	$LN93@RunMacro

; 378  :                     char *p = tokenarray[idx].string_ptr;

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR p$19[rbp], rax

; 379  :                     int tmp = idx;

	mov	eax, DWORD PTR idx$[rbp]
	mov	DWORD PTR tmp$20[rbp], eax

; 380  :                     /* copy the '{' */
; 381  :                     *ptr++ = '{';

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN206@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN206@RunMacro:
	mov	rax, QWORD PTR ptr$[rbp]
	mov	BYTE PTR [rax], 123			; 0000007bH
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN207@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN207@RunMacro:
	mov	rax, QWORD PTR ptr$[rbp]
	inc	rax
	mov	BYTE PTR $T34[rbp], 1
	mov	QWORD PTR ptr$[rbp], rax

; 382  :                     /* the string must be tokenized */
; 383  :                     inside_literal++;

	mov	eax, DWORD PTR inside_literal$12[rbp]
	inc	eax
	mov	DWORD PTR inside_literal$12[rbp], eax

; 384  :                     idx = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR idx$[rbp], eax

; 385  :                     Token_Count = Tokenize( p, idx + 1, tokenarray, TOK_RESCAN | TOK_NOCURLBRACES );

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	r9d, 3
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR p$19[rbp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 386  :                     tokenarray[Token_Count].lastidx = tmp;

	movsxd	rax, DWORD PTR ModuleInfo+496
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	edx, DWORD PTR tmp$20[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 387  :                     continue;

	jmp	$LN8@RunMacro
$LN93@RunMacro:

; 388  :                 }
; 389  : 
; 390  :                 if ( inside_angle_brackets == 0 ) {

	cmp	DWORD PTR inside_angle_brackets$13[rbp], 0
	jne	$LN94@RunMacro

; 391  :                     /* track brackets for macro functions; exit if one more ')' than '(' is found */
; 392  :                     if ( bracket_level > 0 ) {

	cmp	DWORD PTR bracket_level$[rbp], 0
	jle	SHORT $LN95@RunMacro

; 393  :                         if ( tokenarray[idx].token == T_OP_BRACKET ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN96@RunMacro

; 394  :                             bracket_level++;

	mov	eax, DWORD PTR bracket_level$[rbp]
	inc	eax
	mov	DWORD PTR bracket_level$[rbp], eax
	jmp	SHORT $LN97@RunMacro
$LN96@RunMacro:

; 395  :                         } else if ( tokenarray[idx].token == T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN98@RunMacro

; 396  :                             bracket_level--;

	mov	eax, DWORD PTR bracket_level$[rbp]
	dec	eax
	mov	DWORD PTR bracket_level$[rbp], eax

; 397  :                             if ( bracket_level == 0 )

	cmp	DWORD PTR bracket_level$[rbp], 0
	jne	SHORT $LN99@RunMacro

; 398  :                                 break;

	jmp	$LN9@RunMacro
$LN99@RunMacro:
$LN98@RunMacro:
$LN97@RunMacro:
$LN95@RunMacro:

; 399  :                         }
; 400  :                     }
; 401  : 
; 402  :                     /* if there's a literal enclosed in <>, remove the delimiters and
; 403  :                      * tokenize the item (Token_Count must be adjusted, since RunMacro()
; 404  :                      * might be called later!)
; 405  :                      */
; 406  :                     if ( tokenarray[idx].token == T_STRING && tokenarray[idx].string_delim == '<' && inside_angle_brackets == 0 ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	$LN100@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	jne	$LN100@RunMacro
	cmp	DWORD PTR inside_angle_brackets$13[rbp], 0
	jne	$LN100@RunMacro

; 407  :                         char *p;
; 408  :                         int tmp;
; 409  :                         int size;
; 410  : #if 1
; 411  :                         if ( !strchr( tokenarray[idx].string_ptr, '%' ) ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	edx, 37					; 00000025H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp_strchr
	test	rax, rax
	jne	$LN101@RunMacro

; 412  :                             memcpy( ptr, tokenarray[idx].string_ptr, tokenarray[idx].stringlen );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN208@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN208@RunMacro:
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	eax, DWORD PTR [rcx+rax+16]
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8d, eax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	memcpy

; 413  :                             ptr += tokenarray[idx].stringlen;

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN209@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN209@RunMacro:
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR $T34[rbp], 1
	mov	QWORD PTR ptr$[rbp], rax

; 414  :                             continue;

	jmp	$LN8@RunMacro
$LN101@RunMacro:

; 415  :                         }
; 416  : #endif
; 417  :                         tmp = idx;

	mov	eax, DWORD PTR idx$[rbp]
	mov	DWORD PTR tmp$22[rbp], eax

; 418  :                         size = tokenarray[idx+1].tokpos - (tokenarray[idx].tokpos+1);

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rdx+rcx+24]
	inc	rcx
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR size$23[rbp], eax

; 419  :                         p = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR p$21[rbp], rax

; 420  :                         memcpy( p, tokenarray[idx].tokpos+1, size );

	movsxd	rax, DWORD PTR size$23[rbp]
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rdx+rcx+24]
	inc	rcx
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR p$21[rbp]
	call	memcpy
$LN21@RunMacro:

; 421  :                         while ( *(p+size-1) != '>' ) size--;

	movsxd	rax, DWORD PTR size$23[rbp]
	mov	rcx, QWORD PTR p$21[rbp]
	movsx	eax, BYTE PTR [rcx+rax-1]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN22@RunMacro
	mov	eax, DWORD PTR size$23[rbp]
	dec	eax
	mov	DWORD PTR size$23[rbp], eax
	jmp	SHORT $LN21@RunMacro
$LN22@RunMacro:

; 422  :                         *(p+size-1) = NULLC;

	movsxd	rax, DWORD PTR size$23[rbp]
	mov	rcx, QWORD PTR p$21[rbp]
	mov	BYTE PTR [rcx+rax-1], 0

; 423  :                         StringBufferEnd = GetAlignedPointer( p, size );

	mov	eax, DWORD PTR size$23[rbp]
	inc	eax
	cdqe
	add	rax, 7
	and	rax, -8
	mov	rcx, QWORD PTR p$21[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ModuleInfo+488, rax

; 424  :                         //strcpy( tmpline, tokenarray[idx].string_ptr );
; 425  :                         /* the string must be tokenized */
; 426  :                         inside_literal++;

	mov	eax, DWORD PTR inside_literal$12[rbp]
	inc	eax
	mov	DWORD PTR inside_literal$12[rbp], eax

; 427  :                         inside_angle_brackets = 1;

	mov	DWORD PTR inside_angle_brackets$13[rbp], 1

; 428  :                         idx = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR idx$[rbp], eax

; 429  :                         Token_Count = Tokenize( p, idx + 1, tokenarray, TOK_RESCAN );

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	r9d, 1
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR p$21[rbp]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 430  :                         tokenarray[Token_Count].lastidx = tmp;

	movsxd	rax, DWORD PTR ModuleInfo+496
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	edx, DWORD PTR tmp$22[rbp]
	mov	DWORD PTR [rcx+rax+16], edx

; 431  :                         /* copy spaces located before the first token */
; 432  :                         memcpy( ptr, p, tokenarray[idx+1].tokpos - p );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN210@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN210@RunMacro:
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR p$21[rbp]
	mov	rax, QWORD PTR [rcx+rax+24]
	sub	rax, rdx
	mov	r8, rax
	mov	rdx, QWORD PTR p$21[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	memcpy

; 433  :                         ptr += tokenarray[idx+1].tokpos - p;

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN211@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN211@RunMacro:
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR p$21[rbp]
	mov	rax, QWORD PTR [rcx+rax+24]
	sub	rax, rdx
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR $T34[rbp], 1
	mov	QWORD PTR ptr$[rbp], rax

; 434  :                         continue;

	jmp	$LN8@RunMacro
$LN100@RunMacro:

; 435  :                     }
; 436  :                     /* macros functions must be expanded always.
; 437  :                      * text macros are expanded only selectively
; 438  :                      */
; 439  :                     if ( tokenarray[idx].token == T_ID ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN102@RunMacro

; 440  :                         if ( sym = SymSearch( tokenarray[idx].string_ptr ) ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rbp], rax
	cmp	QWORD PTR sym$[rbp], 0
	je	$LN103@RunMacro

; 441  :                             if ( sym->state == SYM_MACRO && sym->isdefined == TRUE &&
; 442  :                                 sym->isfunc == TRUE && tokenarray[idx+1].token == T_OP_BRACKET ) {

	mov	rax, QWORD PTR sym$[rbp]
	cmp	DWORD PTR [rax+32], 9
	jne	$LN104@RunMacro
	mov	rax, QWORD PTR sym$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN104@RunMacro
	mov	rax, QWORD PTR sym$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN104@RunMacro
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	$LN104@RunMacro

; 443  :                                 bool is_exitm2;
; 444  :                                 //int oldidx = idx;
; 445  :                                 idx = RunMacro( (struct dsym *)sym, idx+1, tokenarray, ptr, 0, &is_exitm2 );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN212@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN212@RunMacro:
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	lea	rcx, QWORD PTR is_exitm2$24[rbp]
	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR sym$[rbp]
	call	RunMacro
	mov	DWORD PTR idx$[rbp], eax

; 446  :                                 if ( idx < 0 ) {

	cmp	DWORD PTR idx$[rbp], 0
	jge	SHORT $LN106@RunMacro

; 447  :                                     StringBufferEnd = savedStringBuffer;

	mov	rax, QWORD PTR savedStringBuffer$[rbp]
	mov	QWORD PTR ModuleInfo+488, rax

; 448  :                                     return( idx );

	mov	eax, DWORD PTR idx$[rbp]
	jmp	$LN1@RunMacro
$LN106@RunMacro:

; 449  :                                 }
; 450  :                                 ptr += strlen( ptr );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN213@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN213@RunMacro:
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN214@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN214@RunMacro:
	mov	rcx, QWORD PTR ptr$[rbp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR $T34[rbp], 1
	mov	QWORD PTR ptr$[rbp], rax

; 451  :                                 /* copy spaces behind macro function call */
; 452  :                                 if ( tokenarray[idx].token != T_FINAL && tokenarray[idx].token != T_COMMA ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN107@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	$LN107@RunMacro

; 453  :                                     i = tokenarray[idx].tokpos - ( tokenarray[idx-1].tokpos + 1 );

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, DWORD PTR idx$[rbp]
	dec	ecx
	movsxd	rcx, ecx
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rdx+rcx+24]
	inc	rcx
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR i$[rbp], eax

; 454  :                                     memcpy( ptr, tokenarray[idx-1].tokpos + 1, i );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN215@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN215@RunMacro:
	movsxd	rax, DWORD PTR i$[rbp]
	mov	ecx, DWORD PTR idx$[rbp]
	dec	ecx
	movsxd	rcx, ecx
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rdx+rcx+24]
	inc	rcx
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR ptr$[rbp]
	call	memcpy

; 455  :                                     ptr += i;

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN216@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN216@RunMacro:
	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR $T34[rbp], 1
	mov	QWORD PTR ptr$[rbp], rax
$LN107@RunMacro:

; 456  :                                 }
; 457  :                                 idx--; /* adjust token index */

	mov	eax, DWORD PTR idx$[rbp]
	dec	eax
	mov	DWORD PTR idx$[rbp], eax

; 458  :                                 /**/myassert( ptr < parmstrings + PARMSTRINGSIZE );

	cmp	BYTE PTR $T32[rbp], 0
	jne	SHORT $LN217@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$0
	call	_RTC_UninitUse
$LN217@RunMacro:
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN218@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN218@RunMacro:
	mov	rax, QWORD PTR parmstrings$[rbp]
	add	rax, 1200				; 000004b0H
	cmp	QWORD PTR ptr$[rbp], rax
	jae	SHORT $LN171@RunMacro
	mov	DWORD PTR tv912[rbp], 0
	jmp	SHORT $LN172@RunMacro
$LN171@RunMacro:
	mov	edx, 458				; 000001caH
	lea	rcx, OFFSET FLAT:$SG11147
	call	InternalError
	mov	DWORD PTR tv912[rbp], eax
$LN172@RunMacro:

; 459  :                                 continue;

	jmp	$LN8@RunMacro
	jmp	$LN105@RunMacro
$LN104@RunMacro:

; 460  :                             } else if ( sym->state == SYM_TMACRO && sym->isdefined == TRUE &&

	mov	rax, QWORD PTR sym$[rbp]
	cmp	DWORD PTR [rax+32], 10
	jne	$LN108@RunMacro
	mov	rax, QWORD PTR sym$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN108@RunMacro
	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN108@RunMacro
	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax+2]
	mov	ecx, DWORD PTR parmidx$[rbp]
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	and	eax, ecx
	test	eax, eax
	je	$LN108@RunMacro

; 461  :                                        ( macro->sym.predefined && ( info->autoexp & ( 1 << parmidx ) ) ) ) {
; 462  :                                 //GetLiteralValue( ptr, sym->string_ptr );
; 463  :                                 strcpy( ptr, sym->string_ptr );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN219@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN219@RunMacro:
	mov	rax, QWORD PTR sym$[rbp]
	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	strcpy

; 464  :                                 ExpandTMacro( ptr, tokenarray, FALSE, 0 );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN220@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN220@RunMacro:
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	ExpandTMacro

; 465  :                                 ptr += strlen( ptr );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN221@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN221@RunMacro:
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN222@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN222@RunMacro:
	mov	rcx, QWORD PTR ptr$[rbp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR $T34[rbp], 1
	mov	QWORD PTR ptr$[rbp], rax

; 466  :                                 /* copy spaces behind text macro */
; 467  :                                 if ( tokenarray[idx+1].token != T_FINAL && tokenarray[idx+1].token != T_COMMA ) {

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN109@RunMacro
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	$LN109@RunMacro

; 468  :                                     i = tokenarray[idx+1].tokpos - ( tokenarray[idx].tokpos + sym->name_size );

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR sym$[rbp]
	movzx	edx, BYTE PTR [rdx+72]
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	add	rcx, rdx
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR i$[rbp], eax

; 469  :                                     memcpy( ptr, tokenarray[idx].tokpos + sym->name_size, i );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN223@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN223@RunMacro:
	movsxd	rax, DWORD PTR i$[rbp]
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR sym$[rbp]
	movzx	edx, BYTE PTR [rdx+72]
	mov	r8, QWORD PTR tokenarray$[rbp]
	add	rdx, QWORD PTR [r8+rcx+24]
	mov	rcx, rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR ptr$[rbp]
	call	memcpy

; 470  :                                     ptr += i;

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN224@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN224@RunMacro:
	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR $T34[rbp], 1
	mov	QWORD PTR ptr$[rbp], rax
$LN109@RunMacro:

; 471  :                                 }
; 472  :                                 /**/myassert( ptr < parmstrings + PARMSTRINGSIZE );

	cmp	BYTE PTR $T32[rbp], 0
	jne	SHORT $LN225@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$0
	call	_RTC_UninitUse
$LN225@RunMacro:
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN226@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN226@RunMacro:
	mov	rax, QWORD PTR parmstrings$[rbp]
	add	rax, 1200				; 000004b0H
	cmp	QWORD PTR ptr$[rbp], rax
	jae	SHORT $LN173@RunMacro
	mov	DWORD PTR tv986[rbp], 0
	jmp	SHORT $LN174@RunMacro
$LN173@RunMacro:
	mov	edx, 472				; 000001d8H
	lea	rcx, OFFSET FLAT:$SG11150
	call	InternalError
	mov	DWORD PTR tv986[rbp], eax
$LN174@RunMacro:

; 473  :                                 continue;

	jmp	$LN8@RunMacro
$LN108@RunMacro:
$LN105@RunMacro:
$LN103@RunMacro:
$LN102@RunMacro:
$LN94@RunMacro:

; 474  :                             }
; 475  :                         }
; 476  :                     }
; 477  :                 }
; 478  :                 /* get length of item */
; 479  :                 i = tokenarray[idx+1].tokpos - tokenarray[idx].tokpos;

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR i$[rbp], eax

; 480  :                 if ( !inside_literal && ( tokenarray[idx+1].token == T_COMMA ||

	cmp	DWORD PTR inside_literal$12[rbp], 0
	jne	SHORT $LN110@RunMacro
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN111@RunMacro
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, DWORD PTR parm_end_delim$[rbp]
	jne	SHORT $LN110@RunMacro
$LN111@RunMacro:
$LN23@RunMacro:

; 481  :                     tokenarray[idx+1].token == parm_end_delim ) ) {
; 482  :                     while ( isspace( *(tokenarray[idx].tokpos+i-1 ) ) ) i--;

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rbp]
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rdx+rax+24]
	movsx	eax, BYTE PTR [rax+rcx-1]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN24@RunMacro
	mov	eax, DWORD PTR i$[rbp]
	dec	eax
	mov	DWORD PTR i$[rbp], eax
	jmp	SHORT $LN23@RunMacro
$LN24@RunMacro:
$LN110@RunMacro:

; 483  :                 }
; 484  :                 /* the literal character operator ! is valid for macro arguments */
; 485  :                 if ( tokenarray[idx].token == T_STRING && tokenarray[idx].string_delim == NULLC ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	$LN112@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	test	eax, eax
	jne	$LN112@RunMacro

; 486  :                     char *p;
; 487  :                     char *end;
; 488  :                     DebugMsg1(("RunMacro(%s.%u): undelimited string >%s<, watching '!'\n", macro->sym.name, parmidx, tokenarray[idx].string_ptr ));

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r9, QWORD PTR [rcx+rax+8]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11154
	call	DoDebugMsg1

; 489  :                     p = tokenarray[idx].tokpos;

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR p$25[rbp], rax

; 490  :                     end = p + i;

	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR p$25[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR end$26[rbp], rax

; 491  :                     /**/myassert( ( ptr + i ) < parmstrings + PARMSTRINGSIZE );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN227@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN227@RunMacro:
	cmp	BYTE PTR $T32[rbp], 0
	jne	SHORT $LN228@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$0
	call	_RTC_UninitUse
$LN228@RunMacro:
	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR parmstrings$[rbp]
	add	rcx, 1200				; 000004b0H
	cmp	rax, rcx
	jae	SHORT $LN175@RunMacro
	mov	DWORD PTR tv1059[rbp], 0
	jmp	SHORT $LN176@RunMacro
$LN175@RunMacro:
	mov	edx, 491				; 000001ebH
	lea	rcx, OFFSET FLAT:$SG11155
	call	InternalError
	mov	DWORD PTR tv1059[rbp], eax
$LN176@RunMacro:

; 492  :                     for ( ; p < end; p++ ) {

	jmp	SHORT $LN27@RunMacro
$LN25@RunMacro:
	mov	rax, QWORD PTR p$25[rbp]
	inc	rax
	mov	QWORD PTR p$25[rbp], rax
$LN27@RunMacro:
	mov	rax, QWORD PTR end$26[rbp]
	cmp	QWORD PTR p$25[rbp], rax
	jae	SHORT $LN26@RunMacro

; 493  :                         if ( *p == '!' )

	mov	rax, QWORD PTR p$25[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN113@RunMacro

; 494  :                             p++;

	mov	rax, QWORD PTR p$25[rbp]
	inc	rax
	mov	QWORD PTR p$25[rbp], rax
$LN113@RunMacro:

; 495  :                         *ptr++ = *p;

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN229@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN229@RunMacro:
	mov	rax, QWORD PTR ptr$[rbp]
	mov	rcx, QWORD PTR p$25[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN230@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN230@RunMacro:
	mov	rax, QWORD PTR ptr$[rbp]
	inc	rax
	mov	BYTE PTR $T34[rbp], 1
	mov	QWORD PTR ptr$[rbp], rax

; 496  :                     }

	jmp	$LN25@RunMacro
$LN26@RunMacro:

; 497  :                     continue;

	jmp	$LN8@RunMacro
$LN112@RunMacro:

; 498  :                 }
; 499  :                 /**/myassert( ( ptr + i ) < parmstrings + PARMSTRINGSIZE );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN231@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN231@RunMacro:
	cmp	BYTE PTR $T32[rbp], 0
	jne	SHORT $LN232@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$0
	call	_RTC_UninitUse
$LN232@RunMacro:
	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR parmstrings$[rbp]
	add	rcx, 1200				; 000004b0H
	cmp	rax, rcx
	jae	SHORT $LN177@RunMacro
	mov	DWORD PTR tv1073[rbp], 0
	jmp	SHORT $LN178@RunMacro
$LN177@RunMacro:
	mov	edx, 499				; 000001f3H
	lea	rcx, OFFSET FLAT:$SG11157
	call	InternalError
	mov	DWORD PTR tv1073[rbp], eax
$LN178@RunMacro:

; 500  :                 memcpy( ptr, tokenarray[idx].tokpos, i );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN233@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN233@RunMacro:
	movsxd	rax, DWORD PTR i$[rbp]
	movsxd	rcx, DWORD PTR idx$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rax+rcx+24]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	memcpy

; 501  :                 ptr += i;

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN234@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN234@RunMacro:
	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR $T34[rbp], 1
	mov	QWORD PTR ptr$[rbp], rax

; 502  : 
; 503  :             } /* end for */

	jmp	$LN8@RunMacro
$LN9@RunMacro:

; 504  : 
; 505  :             *ptr = NULLC;

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN235@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN235@RunMacro:
	mov	rax, QWORD PTR ptr$[rbp]
	mov	BYTE PTR [rax], 0

; 506  : 
; 507  :             /* restore input status values */
; 508  :             Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$14[rbp]
	mov	DWORD PTR ModuleInfo+496, eax

; 509  :             StringBufferEnd = savedStringBuffer;

	mov	rax, QWORD PTR savedStringBuffer$[rbp]
	mov	QWORD PTR ModuleInfo+488, rax

; 510  : 
; 511  :             /* store the macro argument in the parameter array */
; 512  :             if (  macro->sym.mac_vararg && ( parmidx == info->parmcnt - 1 ) ) {

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN114@RunMacro
	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax]
	dec	eax
	cmp	DWORD PTR parmidx$[rbp], eax
	jne	$LN114@RunMacro

; 513  :                 if ( varargcnt == 0 )

	cmp	DWORD PTR varargcnt$[rbp], 0
	jne	SHORT $LN116@RunMacro

; 514  :                     mi.parm_array[parmidx] = currparm;

	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN236@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN236@RunMacro:
	movsxd	rax, DWORD PTR parmidx$[rbp]
	mov	rcx, QWORD PTR mi$[rbp+24]
	mov	rdx, QWORD PTR currparm$[rbp]
	mov	QWORD PTR [rcx+rax*8], rdx
$LN116@RunMacro:

; 515  :                 DebugMsg1(("RunMacro(%s.%u[%u]): curr parameter value=>%s<\n", macro->sym.name, parmidx, varargcnt, currparm ));

	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN237@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN237@RunMacro:
	mov	rax, QWORD PTR currparm$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR varargcnt$[rbp]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11161
	call	DoDebugMsg1

; 516  :                 currparm = ( macro->sym.predefined ? GetAlignedPointer( currparm, ptr - currparm ) : ptr );

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN179@RunMacro
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN238@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN238@RunMacro:
	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN239@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN239@RunMacro:
	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN240@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN240@RunMacro:
	mov	rax, QWORD PTR currparm$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	add	rax, 8
	and	rax, -8
	mov	rcx, QWORD PTR currparm$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv1113[rbp], rax
	jmp	SHORT $LN180@RunMacro
$LN179@RunMacro:
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN241@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN241@RunMacro:
	mov	rax, QWORD PTR ptr$[rbp]
	mov	QWORD PTR tv1113[rbp], rax
$LN180@RunMacro:
	mov	BYTE PTR $T33[rbp], 1
	mov	rax, QWORD PTR tv1113[rbp]
	mov	QWORD PTR currparm$[rbp], rax

; 517  :                 /* v2.08: Masm swallows the last trailing comma */
; 518  :                 //if ( tokenarray[idx].token == T_COMMA ) {
; 519  :                 if ( tokenarray[idx].token == T_COMMA ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	$LN117@RunMacro

; 520  :                     idx++;

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax

; 521  :                     if ( macro->sym.isfunc == FALSE || tokenarray[idx].token != parm_end_delim ) {

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN119@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, DWORD PTR parm_end_delim$[rbp]
	je	SHORT $LN118@RunMacro
$LN119@RunMacro:

; 522  :                         parmidx--;

	mov	eax, DWORD PTR parmidx$[rbp]
	dec	eax
	mov	DWORD PTR parmidx$[rbp], eax

; 523  :                         if ( !macro->sym.predefined ) {

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN120@RunMacro

; 524  :                             *currparm++ = ',';

	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN242@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN242@RunMacro:
	mov	rax, QWORD PTR currparm$[rbp]
	mov	BYTE PTR [rax], 44			; 0000002cH
	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN243@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN243@RunMacro:
	mov	rax, QWORD PTR currparm$[rbp]
	inc	rax
	mov	BYTE PTR $T33[rbp], 1
	mov	QWORD PTR currparm$[rbp], rax
$LN120@RunMacro:

; 525  :                         }
; 526  :                         *currparm = NULLC;

	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN244@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN244@RunMacro:
	mov	rax, QWORD PTR currparm$[rbp]
	mov	BYTE PTR [rax], 0
$LN118@RunMacro:

; 527  :                     }
; 528  :                     skipcomma = 0;

	mov	DWORD PTR skipcomma$[rbp], 0
$LN117@RunMacro:

; 529  :                 }
; 530  :                 varargcnt++;

	mov	eax, DWORD PTR varargcnt$[rbp]
	inc	eax
	mov	DWORD PTR varargcnt$[rbp], eax
	jmp	$LN115@RunMacro
$LN114@RunMacro:

; 531  :             } else if ( *currparm ) {

	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN245@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN245@RunMacro:
	mov	rax, QWORD PTR currparm$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN121@RunMacro

; 532  :                 mi.parm_array[parmidx] = currparm;

	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN246@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN246@RunMacro:
	movsxd	rax, DWORD PTR parmidx$[rbp]
	mov	rcx, QWORD PTR mi$[rbp+24]
	mov	rdx, QWORD PTR currparm$[rbp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 533  :                 DebugMsg1(("RunMacro(%s.%u): curr parameter value=>%s<\n", macro->sym.name, parmidx, currparm ));

	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN247@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN247@RunMacro:
	mov	r9, QWORD PTR currparm$[rbp]
	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11168
	call	DoDebugMsg1

; 534  :                 currparm = GetAlignedPointer( currparm, ptr - currparm );

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN248@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN248@RunMacro:
	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN249@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN249@RunMacro:
	cmp	BYTE PTR $T33[rbp], 0
	jne	SHORT $LN250@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$1
	call	_RTC_UninitUse
$LN250@RunMacro:
	mov	rax, QWORD PTR currparm$[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	add	rax, 8
	and	rax, -8
	mov	rcx, QWORD PTR currparm$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR $T33[rbp], 1
	mov	QWORD PTR currparm$[rbp], rax

; 535  :             } else {

	jmp	SHORT $LN122@RunMacro
$LN121@RunMacro:

; 536  :                 mi.parm_array[parmidx] = "";

	movsxd	rax, DWORD PTR parmidx$[rbp]
	mov	rcx, QWORD PTR mi$[rbp+24]
	lea	rdx, OFFSET FLAT:$SG11169
	mov	QWORD PTR [rcx+rax*8], rdx

; 537  :                 DebugMsg1(("RunMacro(%s.%u): curr parameter value=><\n", macro->sym.name, parmidx ));

	mov	r8d, DWORD PTR parmidx$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11170
	call	DoDebugMsg1
$LN122@RunMacro:
$LN115@RunMacro:
$LN55@RunMacro:

; 538  :             }
; 539  :         } /*end if */
; 540  :     } /* end for  */

	jmp	$LN5@RunMacro
$LN6@RunMacro:

; 541  : 
; 542  :     /* for macro functions, check for the terminating ')' */
; 543  :     if ( bracket_level >= 0 ) {

	cmp	DWORD PTR bracket_level$[rbp], 0
	jl	$LN123@RunMacro

; 544  :         if ( tokenarray[idx].token != T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	$LN125@RunMacro

; 545  :             for ( i = idx; idx < Token_Count && tokenarray[idx].token != T_CL_BRACKET; idx++ );

	mov	eax, DWORD PTR idx$[rbp]
	mov	DWORD PTR i$[rbp], eax
	jmp	SHORT $LN30@RunMacro
$LN28@RunMacro:
	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax
$LN30@RunMacro:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR idx$[rbp], eax
	jge	SHORT $LN29@RunMacro
	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN29@RunMacro
	jmp	SHORT $LN28@RunMacro
$LN29@RunMacro:

; 546  :             if ( idx == Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR idx$[rbp], eax
	jne	SHORT $LN126@RunMacro

; 547  :                 DebugMsg1(("RunMacro(%s): missing ')'\n", macro->sym.name));

	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11176
	call	DoDebugMsg1

; 548  :                 EmitError( MISSING_RIGHT_PARENTHESIS );

	mov	ecx, 244				; 000000f4H
	call	EmitError

; 549  :                 return( -1 );

	mov	eax, -1
	jmp	$LN1@RunMacro

; 550  :             } else {

	jmp	SHORT $LN127@RunMacro
$LN126@RunMacro:

; 551  :                 DebugMsg1(("RunMacro(%s): expected ')', found >%s<\n", macro->sym.name, tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11177
	call	DoDebugMsg1

; 552  :                 /* v2.09: changed to a warning only (Masm-compatible) */
; 553  :                 EmitWarn( 1, TOO_MANY_ARGUMENTS_IN_MACRO_CALL, macro->sym.name, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r9, QWORD PTR [rcx+rax+24]
	mov	rax, QWORD PTR macro$[rbp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 149				; 00000095H
	mov	ecx, 1
	call	EmitWarn
$LN127@RunMacro:
$LN125@RunMacro:

; 554  :             }
; 555  :         }
; 556  :         idx++;

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax
	jmp	$LN124@RunMacro
$LN123@RunMacro:

; 557  :     //} else if ( tokenarray[idx].token != T_FINAL && *macro->sym.name != NULLC ) { /* v2.08: changed */
; 558  :     } else if ( tokenarray[idx].token != T_FINAL ) {

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN128@RunMacro

; 559  :         DebugMsg1(("RunMacro(%s): expected T_FINAL, found >%s<, parmidx=%u\n", macro->sym.name, tokenarray[idx].tokpos, parmidx ));

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	r9d, DWORD PTR parmidx$[rbp]
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11179
	call	DoDebugMsg1

; 560  :         /* v2.05: changed to a warning. That's what Masm does */
; 561  :         /* v2.09: don't emit a warning if it's a FOR directive
; 562  :          * (in this case, the caller knows better what to do ).
; 563  :          */
; 564  :         if ( !(mflags & MF_IGNARGS) )

	mov	eax, DWORD PTR mflags$[rbp]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN129@RunMacro

; 565  :             EmitWarn( 1, TOO_MANY_ARGUMENTS_IN_MACRO_CALL, macro->sym.name, tokenarray[idx].tokpos );

	movsxd	rax, DWORD PTR idx$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r9, QWORD PTR [rcx+rax+24]
	mov	rax, QWORD PTR macro$[rbp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 149				; 00000095H
	mov	ecx, 1
	call	EmitWarn
$LN129@RunMacro:
$LN128@RunMacro:
$LN124@RunMacro:

; 566  :         //return( -1 );
; 567  :     }
; 568  : 
; 569  :     /* a predefined macro func with a function address? */
; 570  : 
; 571  :     if ( macro->sym.predefined == TRUE && macro->sym.func_ptr != NULL ) {

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN130@RunMacro
	mov	rax, QWORD PTR macro$[rbp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN130@RunMacro

; 572  :         mi.parmcnt = varargcnt;

	mov	eax, DWORD PTR varargcnt$[rbp]
	mov	DWORD PTR mi$[rbp+40], eax

; 573  :         macro->sym.func_ptr( &mi, out, tokenarray );

	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR out$[rbp]
	lea	rcx, QWORD PTR mi$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	call	QWORD PTR [rax+16]

; 574  :         *is_exitm = TRUE;

	mov	rax, QWORD PTR is_exitm$[rbp]
	mov	BYTE PTR [rax], 1

; 575  :         return( idx );

	mov	eax, DWORD PTR idx$[rbp]
	jmp	$LN1@RunMacro
$LN130@RunMacro:

; 576  :     }
; 577  : 
; 578  : #if 0
; 579  :     /* check if a (code) label before the macro is to be written
; 580  :      * v2.08: this is the wrong place, because the label is written
; 581  :      * AFTER possible macro functions in the arguments are evaluated.
; 582  :      * Hence this functionality has been moved to ExpandToken().
; 583  :      */
; 584  :     addprefix = FALSE;
; 585  :     if ( macro->sym.isfunc == FALSE && 
; 586  : #if MACROLABEL
; 587  :         macro->sym.label == FALSE &&
; 588  : #endif
; 589  :         label >= 0 && start > label )
; 590  :         addprefix = TRUE;
; 591  : #endif
; 592  : 
; 593  :     mi.localstart = MacroLocals;

	mov	eax, DWORD PTR MacroLocals
	mov	DWORD PTR mi$[rbp+16], eax

; 594  :     MacroLocals += info->localcnt; /* adjust global variable MacroLocals */

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax+2]
	mov	ecx, DWORD PTR MacroLocals
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR MacroLocals, eax

; 595  : 
; 596  :     /* avoid to use values stored in struct macro_info directly. A macro
; 597  :      * may be redefined within the macro! Hence copy all values that are
; 598  :      * needed later in the while loop to macro_instance!
; 599  :      */
; 600  :     mi.startline = info->data;

	mov	rax, QWORD PTR info$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR mi$[rbp+8], rax

; 601  :     mi.currline = NULL;

	mov	QWORD PTR mi$[rbp], 0

; 602  :     mi.parmcnt = info->parmcnt;

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR mi$[rbp+40], eax

; 603  : 
; 604  :     /* v2.03: no processing if macro has no lines */
; 605  :     /* v2.08: addprefix is obsolete */
; 606  :     //if ( mi.currline || addprefix ) {
; 607  :     if ( mi.startline ) {

	cmp	QWORD PTR mi$[rbp+8], 0
	je	$LN131@RunMacro

; 608  :         struct input_status oldstat;
; 609  :         int oldifnesting;
; 610  :         int cntgoto;
; 611  : 
; 612  :         DebugMsg1(("RunMacro(%s): enter assembly loop, macro level=%u\n", macro->sym.name, MacroLevel+1 ));

	movzx	eax, BYTE PTR MacroLevel
	inc	eax
	mov	r8d, eax
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11183
	call	DoDebugMsg1

; 613  :         /* v2.04: this listing is too excessive */
; 614  :         //if ( ModuleInfo.list && ( ModuleInfo.list_macro == LM_LISTMACROALL || MacroLevel == 0 ) )
; 615  :         //if ( MacroLevel == 0 && macro->sym.isfunc == FALSE && *macro->sym.name )
; 616  :         if ( macro->sym.isfunc == FALSE && *macro->sym.name )

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN132@RunMacro
	mov	rax, QWORD PTR macro$[rbp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN132@RunMacro

; 617  :             LstWriteSrcLine();

	call	LstWriteSrcLine
$LN132@RunMacro:

; 618  :         if ( !( mflags & MF_NOSAVE ) )

	mov	eax, DWORD PTR mflags$[rbp]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN133@RunMacro

; 619  :             tokenarray = PushInputStatus( &oldstat );

	lea	rcx, QWORD PTR oldstat$27[rbp]
	call	PushInputStatus
	mov	QWORD PTR tokenarray$[rbp], rax
$LN133@RunMacro:

; 620  : 
; 621  :         /*
; 622  :          * move the macro instance onto the file stack!
; 623  :          * Also reset the current linenumber!
; 624  :          */
; 625  :         mi.macro = &macro->sym;

	mov	rax, QWORD PTR macro$[rbp]
	mov	QWORD PTR mi$[rbp+32], rax

; 626  :         PushMacro( &mi );

	lea	rcx, QWORD PTR mi$[rbp]
	call	PushMacro

; 627  :         MacroLevel++;

	movzx	eax, BYTE PTR MacroLevel
	inc	al
	mov	BYTE PTR MacroLevel, al

; 628  :         oldifnesting = GetIfNestLevel(); /* v2.10 */

	call	GetIfNestLevel
	mov	DWORD PTR oldifnesting$28[rbp], eax

; 629  :         cntgoto = 0; /* v2.10 */

	mov	DWORD PTR cntgoto$29[rbp], 0
$LN187@RunMacro:
$LN186@RunMacro:
$LN185@RunMacro:
$LN31@RunMacro:

; 630  :         /* Run the assembler until we hit EXITM or ENDM.
; 631  :          * Also handle GOTO and macro label lines!
; 632  :          * v2.08 no need anymore to check the queue level
; 633  :          * v2.11 GetPreprocessedLine() replaced by GetTextLine()
; 634  :          * and PreprocessLine().
; 635  :          */
; 636  : 
; 637  :         while ( GetTextLine( CurrSource ) ) {

	mov	rcx, QWORD PTR ModuleInfo+464
	call	GetTextLine
	test	rax, rax
	je	$LN32@RunMacro

; 638  :             if ( PreprocessLine( CurrSource, tokenarray ) == 0 )

	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR ModuleInfo+464
	call	PreprocessLine
	test	eax, eax
	jne	SHORT $LN134@RunMacro

; 639  :                 continue;

	jmp	SHORT $LN31@RunMacro
$LN134@RunMacro:

; 640  :             /* skip macro label lines */
; 641  :             if ( tokenarray[0].token == T_COLON ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN135@RunMacro

; 642  :                 /* v2.05: emit the error msg here, not in StoreMacro() */
; 643  :                 if ( tokenarray[1].token != T_ID )

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN136@RunMacro

; 644  :                     EmitErr( SYNTAX_ERROR_EX, tokenarray[0].tokpos );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN137@RunMacro
$LN136@RunMacro:

; 645  :                 else if ( tokenarray[2].token != T_FINAL )

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN138@RunMacro

; 646  :                     EmitErr( SYNTAX_ERROR_EX, tokenarray[2].tokpos );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN138@RunMacro:
$LN137@RunMacro:

; 647  :                 continue;

	jmp	$LN185@RunMacro
$LN135@RunMacro:

; 648  :             }
; 649  : 
; 650  :             if ( tokenarray[0].token == T_DIRECTIVE ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	$LN139@RunMacro

; 651  :                 if ( tokenarray[0].tokval == T_EXITM ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	cmp	DWORD PTR [rcx+rax+16], 393		; 00000189H
	jne	$LN140@RunMacro

; 652  :                     if ( ModuleInfo.list && ModuleInfo.list_macro == LM_LISTMACROALL )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN142@RunMacro
	cmp	DWORD PTR ModuleInfo+400, 2
	jne	SHORT $LN142@RunMacro

; 653  :                         LstWriteSrcLine();

	call	LstWriteSrcLine
$LN142@RunMacro:

; 654  :                     if ( tokenarray[1].token != T_FINAL ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN143@RunMacro

; 655  :                         /* v2.05: display error if there's more than 1 argument or
; 656  :                          * the argument isn't a text item
; 657  :                          */
; 658  :                         if ( tokenarray[1].token != T_STRING || tokenarray[1].string_delim != '<' )

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN146@RunMacro
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN144@RunMacro
$LN146@RunMacro:

; 659  :                             TextItemError( &tokenarray[1] );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	TextItemError
	jmp	$LN145@RunMacro
$LN144@RunMacro:

; 660  :                         else if ( Token_Count > 2 )

	cmp	DWORD PTR ModuleInfo+496, 2
	jle	SHORT $LN147@RunMacro

; 661  :                             EmitErr( SYNTAX_ERROR_EX, tokenarray[2].tokpos );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN148@RunMacro
$LN147@RunMacro:

; 662  :                         else if ( out ) { /* return value buffer may be NULL ( loop directives ) */

	cmp	QWORD PTR out$[rbp], 0
	je	$LN149@RunMacro

; 663  : 
; 664  :                             /* v2.08a: the <>-literal behind EXITM is handled specifically,
; 665  :                              * macro operator '!' within the literal is only handled
; 666  :                              * if it contains a placeholder (macro argument, macro local ).
; 667  :                              *
; 668  :                              * v2.09: handle '!' inside literal if ANY expansion occurred.
; 669  :                              * To determine text macro or macro function expansion,
; 670  :                              * check if there's a literal in the original line.
; 671  :                              */
; 672  :                             if ( mi.currline->ph_count || *(mi.currline->line+(tokenarray[1].tokpos-CurrSource)) != '<' ) {

	mov	rax, QWORD PTR mi$[rbp]
	movzx	eax, BYTE PTR [rax+8]
	test	eax, eax
	jne	SHORT $LN152@RunMacro
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR ModuleInfo+464
	mov	rax, QWORD PTR [rcx+rax+24]
	sub	rax, rdx
	mov	rcx, QWORD PTR mi$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+9]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN150@RunMacro
$LN152@RunMacro:

; 673  :                                 memcpy( out, tokenarray[1].string_ptr, tokenarray[1].stringlen + 1 );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	eax, DWORD PTR [rcx+rax+16]
	inc	eax
	mov	eax, eax
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 1
	mov	r8d, eax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	mov	rcx, QWORD PTR out$[rbp]
	call	memcpy

; 674  :                             } else {

	jmp	$LN151@RunMacro
$LN150@RunMacro:

; 675  :                                 /* since the string_ptr member has the !-operator stripped, it
; 676  :                                  * cannot be used. To get the original value of the literal,
; 677  :                                  * use tokpos.
; 678  :                                  */
; 679  :                                 int len;
; 680  :                                 len = tokenarray[2].tokpos - (tokenarray[1].tokpos+1);

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rdx+rcx+24]
	inc	rcx
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR len$30[rbp], eax

; 681  :                                 memcpy( out, tokenarray[1].tokpos+1, len );

	movsxd	rax, DWORD PTR len$30[rbp]
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rdx+rcx+24]
	inc	rcx
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR out$[rbp]
	call	memcpy
$LN33@RunMacro:

; 682  :                                 while( *(out+len-1) != '>' ) len--;

	movsxd	rax, DWORD PTR len$30[rbp]
	mov	rcx, QWORD PTR out$[rbp]
	movsx	eax, BYTE PTR [rcx+rax-1]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN34@RunMacro
	mov	eax, DWORD PTR len$30[rbp]
	dec	eax
	mov	DWORD PTR len$30[rbp], eax
	jmp	SHORT $LN33@RunMacro
$LN34@RunMacro:

; 683  :                                 *(out+len-1) = NULLC;

	movsxd	rax, DWORD PTR len$30[rbp]
	mov	rcx, QWORD PTR out$[rbp]
	mov	BYTE PTR [rcx+rax-1], 0
$LN151@RunMacro:
$LN149@RunMacro:
$LN148@RunMacro:
$LN145@RunMacro:
$LN143@RunMacro:

; 684  :                             }
; 685  :                         }
; 686  :                     }
; 687  :                     DebugMsg1(("RunMacro(%s): EXITM, result=>%s<\n", macro->sym.name, out ? out : "NULL" ));

	cmp	QWORD PTR out$[rbp], 0
	je	SHORT $LN181@RunMacro
	mov	rax, QWORD PTR out$[rbp]
	mov	QWORD PTR tv1419[rbp], rax
	jmp	SHORT $LN182@RunMacro
$LN181@RunMacro:
	lea	rax, OFFSET FLAT:$SG11205
	mov	QWORD PTR tv1419[rbp], rax
$LN182@RunMacro:
	mov	r8, QWORD PTR tv1419[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11206
	call	DoDebugMsg1

; 688  : 
; 689  :                     /* v2.10: if a goto had occured, rescan the full macro to ensure that
; 690  :                      * the "if"-nesting level is ok.
; 691  :                      */
; 692  :                     if ( cntgoto ) {

	cmp	DWORD PTR cntgoto$29[rbp], 0
	je	SHORT $LN153@RunMacro

; 693  :                         mi.currline = NULL;

	mov	QWORD PTR mi$[rbp], 0

; 694  :                         SetLineNumber( 0 );

	xor	ecx, ecx
	call	SetLineNumber

; 695  :                         SetIfNestLevel( oldifnesting );

	mov	ecx, DWORD PTR oldifnesting$28[rbp]
	call	SetIfNestLevel
$LN153@RunMacro:

; 696  :                     }
; 697  : 
; 698  :                     SkipMacro( tokenarray );

	mov	rcx, QWORD PTR tokenarray$[rbp]
	call	SkipMacro

; 699  :                     *is_exitm = TRUE;

	mov	rax, QWORD PTR is_exitm$[rbp]
	mov	BYTE PTR [rax], 1

; 700  :                     break;

	jmp	$LN32@RunMacro
	jmp	$LN141@RunMacro
$LN140@RunMacro:

; 701  : #if 0 /* won't happen anymore */
; 702  :                 } else if ( tokenarray[0].tokval == T_ENDM ) {
; 703  :                     DebugMsg1(("RunMacro(%s): ENDM\n", macro->sym.name ));
; 704  :                     break;
; 705  : #endif
; 706  :                 } else if ( tokenarray[0].tokval == T_GOTO ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rbp]
	cmp	DWORD PTR [rcx+rax+16], 395		; 0000018bH
	jne	$LN154@RunMacro

; 707  :                     if ( tokenarray[1].token != T_FINAL ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN155@RunMacro

; 708  :                         int len = strlen( tokenarray[1].string_ptr );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	strlen
	mov	DWORD PTR len$31[rbp], eax

; 709  :                         DebugMsg1(("RunMacro(%s): GOTO %s, MacroLevel=%u\n", macro->sym.name, tokenarray[1].string_ptr, MacroLevel ));

	movzx	eax, BYTE PTR MacroLevel
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 1
	mov	r9d, eax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	r8, QWORD PTR [rax+rcx+8]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11211
	call	DoDebugMsg1

; 710  :                         /* search for the destination line */
; 711  :                         for( i = 1, lnode = mi.startline; lnode != NULL; lnode = lnode->next, i++ ) {

	mov	DWORD PTR i$[rbp], 1
	mov	rax, QWORD PTR mi$[rbp+8]
	mov	QWORD PTR lnode$[rbp], rax
	jmp	SHORT $LN37@RunMacro
$LN35@RunMacro:
	mov	rax, QWORD PTR lnode$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR lnode$[rbp], rax
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN37@RunMacro:
	cmp	QWORD PTR lnode$[rbp], 0
	je	$LN36@RunMacro

; 712  :                             ptr = lnode->line;

	mov	rax, QWORD PTR lnode$[rbp]
	add	rax, 9
	mov	BYTE PTR $T34[rbp], 1
	mov	QWORD PTR ptr$[rbp], rax

; 713  :                             //DebugMsg(("RunMacro(%s): GOTO, scan line >%s< for label >%s<\n", macro->sym.name, ptr, line));
; 714  :                             if ( *ptr == ':' ) {

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN251@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN251@RunMacro:
	mov	rax, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 58					; 0000003aH
	jne	$LN157@RunMacro

; 715  :                                 if ( lnode->ph_count ) {

	mov	rax, QWORD PTR lnode$[rbp]
	movzx	eax, BYTE PTR [rax+8]
	test	eax, eax
	je	SHORT $LN158@RunMacro

; 716  :                                     fill_placeholders( StringBufferEnd, lnode->line, mi.parmcnt, mi.localstart, mi.parm_array );

	mov	rax, QWORD PTR lnode$[rbp]
	add	rax, 9
	mov	rcx, QWORD PTR mi$[rbp+24]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, DWORD PTR mi$[rbp+16]
	mov	r8d, DWORD PTR mi$[rbp+40]
	mov	rdx, rax
	mov	rcx, QWORD PTR ModuleInfo+488
	call	fill_placeholders

; 717  :                                     ptr = StringBufferEnd;

	mov	BYTE PTR $T34[rbp], 1
	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR ptr$[rbp], rax
$LN158@RunMacro:

; 718  :                                 }
; 719  :                                 ptr++;

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN252@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN252@RunMacro:
	mov	rax, QWORD PTR ptr$[rbp]
	inc	rax
	mov	BYTE PTR $T34[rbp], 1
	mov	QWORD PTR ptr$[rbp], rax
$LN38@RunMacro:

; 720  :                                 while( isspace( *ptr )) ptr++;

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN253@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN253@RunMacro:
	mov	rax, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN39@RunMacro
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN254@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN254@RunMacro:
	mov	rax, QWORD PTR ptr$[rbp]
	inc	rax
	mov	BYTE PTR $T34[rbp], 1
	mov	QWORD PTR ptr$[rbp], rax
	jmp	SHORT $LN38@RunMacro
$LN39@RunMacro:

; 721  :                                 DebugMsg1(("RunMacro(%s): GOTO, line=>%s<\n", macro->sym.name, ptr ));

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN255@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN255@RunMacro:
	mov	r8, QWORD PTR ptr$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11214
	call	DoDebugMsg1

; 722  :                                 /* macro labels are always case-insensitive! */
; 723  :                                 //if ( ( SymCmpFunc( ptr, tokenarray[1].string_ptr, len ) == 0 ) &&
; 724  :                                 if ( ( _memicmp( ptr, tokenarray[1].string_ptr, len ) == 0 ) &&

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN256@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN256@RunMacro:
	movsxd	rax, DWORD PTR len$31[rbp]
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 1
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	$LN159@RunMacro
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN257@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN257@RunMacro:
	movsxd	rax, DWORD PTR len$31[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	$LN183@RunMacro
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN258@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN258@RunMacro:
	movsxd	rax, DWORD PTR len$31[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 95					; 0000005fH
	je	$LN183@RunMacro
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN259@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN259@RunMacro:
	movsxd	rax, DWORD PTR len$31[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN183@RunMacro
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN260@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN260@RunMacro:
	movsxd	rax, DWORD PTR len$31[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN183@RunMacro
	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN261@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN261@RunMacro:
	movsxd	rax, DWORD PTR len$31[rbp]
	mov	rcx, QWORD PTR ptr$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN183@RunMacro
	mov	DWORD PTR tv1508[rbp], 0
	jmp	SHORT $LN184@RunMacro
$LN183@RunMacro:
	mov	DWORD PTR tv1508[rbp], 1
$LN184@RunMacro:
	cmp	DWORD PTR tv1508[rbp], 0
	jne	SHORT $LN159@RunMacro

; 725  :                                     ( is_valid_id_char(*(ptr+len) ) == FALSE ) ) {
; 726  :                                     /* label found! */
; 727  :                                     break;

	jmp	SHORT $LN36@RunMacro
$LN159@RunMacro:
$LN157@RunMacro:

; 728  :                                 }
; 729  :                             }
; 730  :                         }

	jmp	$LN35@RunMacro
$LN36@RunMacro:

; 731  :                         if ( !lnode ) {

	cmp	QWORD PTR lnode$[rbp], 0
	jne	SHORT $LN160@RunMacro

; 732  :                             /* v2.05: display error msg BEFORE SkipMacro()! */
; 733  :                             DebugMsg1(("RunMacro(%s): GOTO, label >%s< not found!\n", macro->sym.name, tokenarray[1].string_ptr ));

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r8, QWORD PTR [rcx+rax+8]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11218
	call	DoDebugMsg1

; 734  :                             EmitErr( MACRO_LABEL_NOT_DEFINED, tokenarray[1].string_ptr );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 264				; 00000108H
	call	EmitErr

; 735  :                         } else {

	jmp	SHORT $LN161@RunMacro
$LN160@RunMacro:

; 736  :                             DebugMsg1(("RunMacro(%s): GOTO, found label >%s<\n", macro->sym.name, ptr));

	cmp	BYTE PTR $T34[rbp], 0
	jne	SHORT $LN262@RunMacro
	lea	rcx, OFFSET FLAT:RunMacro$rtcName$2
	call	_RTC_UninitUse
$LN262@RunMacro:
	mov	r8, QWORD PTR ptr$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11219
	call	DoDebugMsg1

; 737  :                             /* v2.10: rewritten, "if"-nesting-level handling added */
; 738  :                             mi.currline = lnode;

	mov	rax, QWORD PTR lnode$[rbp]
	mov	QWORD PTR mi$[rbp], rax

; 739  :                             SetLineNumber( i );

	mov	ecx, DWORD PTR i$[rbp]
	call	SetLineNumber

; 740  :                             SetIfNestLevel( oldifnesting );

	mov	ecx, DWORD PTR oldifnesting$28[rbp]
	call	SetIfNestLevel

; 741  :                             cntgoto++;

	mov	eax, DWORD PTR cntgoto$29[rbp]
	inc	eax
	mov	DWORD PTR cntgoto$29[rbp], eax

; 742  :                             continue;

	jmp	$LN186@RunMacro
$LN161@RunMacro:

; 743  :                         }
; 744  :                     } else {

	jmp	SHORT $LN156@RunMacro
$LN155@RunMacro:

; 745  :                         EmitErr( SYNTAX_ERROR_EX, tokenarray->tokpos );

	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN156@RunMacro:

; 746  :                     }
; 747  :                     SkipMacro( tokenarray );

	mov	rcx, QWORD PTR tokenarray$[rbp]
	call	SkipMacro

; 748  :                     break;

	jmp	SHORT $LN32@RunMacro
$LN154@RunMacro:
$LN141@RunMacro:
$LN139@RunMacro:

; 749  :                 }
; 750  :             }
; 751  :             ParseLine( tokenarray );

	mov	rcx, QWORD PTR tokenarray$[rbp]
	call	ParseLine

; 752  :             if ( Options.preprocessor_stdout == TRUE )

	movzx	eax, BYTE PTR Options+141
	cmp	eax, 1
	jne	SHORT $LN162@RunMacro

; 753  :                 WritePreprocessedLine( CurrSource );

	mov	rcx, QWORD PTR ModuleInfo+464
	call	WritePreprocessedLine
$LN162@RunMacro:

; 754  : 
; 755  :             /* the macro might contain an END directive.
; 756  :              * v2.08: this doesn't mean the macro is to be cancelled.
; 757  :              * Masm continues to run it and the assembly is stopped
; 758  :              * when the top source level is reached again.
; 759  :              */
; 760  :             //if ( ModuleInfo.EndDirFound ) {
; 761  :             //    SkipMacro( tokenarray );
; 762  :             //    *is_exitm = TRUE; /* force loop exit */
; 763  :             //    break;
; 764  :             //}
; 765  :         } /* end while */

	jmp	$LN187@RunMacro
$LN32@RunMacro:

; 766  : 
; 767  :         MacroLevel--;

	movzx	eax, BYTE PTR MacroLevel
	dec	al
	mov	BYTE PTR MacroLevel, al

; 768  :         if ( !(mflags & MF_NOSAVE ) )

	mov	eax, DWORD PTR mflags$[rbp]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN163@RunMacro

; 769  :             PopInputStatus( &oldstat );

	lea	rcx, QWORD PTR oldstat$27[rbp]
	call	PopInputStatus
$LN163@RunMacro:
$LN131@RunMacro:

; 770  : 
; 771  :         /* don't use tokenarray from here on, it's invalid after PopInputStatus() */
; 772  : 
; 773  : #if FASTMEM==0
; 774  :         /* v2.06: free "old" macro line data if macro has been changed
; 775  :          * and isn't in use anymore */
; 776  :         if ( mi.startline != info->data && ( !MacroInUse( macro ) ) ) {
; 777  :             struct srcline  *curr;
; 778  :             struct srcline  *next;
; 779  :             DebugMsg1(("RunMacro(%s): macro has been changed, releasing old lines\n", macro->sym.name ));
; 780  :             for( curr = mi.startline ; curr; curr = next ) {
; 781  :                 next = curr->next;
; 782  :                 LclFree( curr );
; 783  :             }
; 784  :         }
; 785  : #endif
; 786  :     } /* end if */
; 787  : 
; 788  :     DebugMsg1(("RunMacro(%s) exit, MacroLevel=%u\n", macro->sym.name, MacroLevel ));

	movzx	eax, BYTE PTR MacroLevel
	mov	r8d, eax
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11222
	call	DoDebugMsg1

; 789  : 
; 790  :     return( idx );

	mov	eax, DWORD PTR idx$[rbp]
$LN1@RunMacro:

; 791  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:RunMacro$rtcFrameData
	mov	r8, QWORD PTR __$AllocaPad$$[rbp]
	call	_RTC_CheckStackVars2
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+632]
	pop	rdi
	pop	rbp
	ret	0
RunMacro ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
_TEXT	SEGMENT
p$ = 48
dst$ = 56
tmpbuf$ = 72
saved_value$ = 116
__$ArrayPad$ = 128
value$ = 160
buffer$ = 168
radix$ = 176
sign$ = 184
addzero$ = 192
myltoa	PROC

; 54   : {

$LN10:
	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 144				; 00000090H
	mov	rdi, rsp
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+160]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 55   :     char   *p;
; 56   :     char   *dst = buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR dst$[rsp], rax

; 57   :     char   tmpbuf[34];
; 58   : 
; 59   : #ifdef DEBUG_OUT
; 60   :     uint_32 saved_value = value;

	mov	eax, DWORD PTR value$[rsp]
	mov	DWORD PTR saved_value$[rsp], eax

; 61   : #endif
; 62   :     if ( sign ) {

	movzx	eax, BYTE PTR sign$[rsp]
	test	eax, eax
	je	SHORT $LN5@myltoa

; 63   :         *dst++ = '-';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 45			; 0000002dH
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 64   :          value = 0 - value;

	xor	eax, eax
	sub	eax, DWORD PTR value$[rsp]
	mov	DWORD PTR value$[rsp], eax
	jmp	SHORT $LN6@myltoa
$LN5@myltoa:

; 65   :     } else if ( value == 0 ) {

	cmp	DWORD PTR value$[rsp], 0
	jne	SHORT $LN7@myltoa

; 66   :         *dst++ = '0';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 48			; 00000030H
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 67   :         *dst = NULLC;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 0

; 68   :         return( buffer );

	mov	rax, QWORD PTR buffer$[rsp]
	jmp	$LN1@myltoa
$LN7@myltoa:
$LN6@myltoa:

; 69   :     }
; 70   :     for ( p = &tmpbuf[33], *p = NULLC; value; value = value / radix )

	mov	eax, 1
	imul	rax, rax, 33				; 00000021H
	lea	rax, QWORD PTR tmpbuf$[rsp+rax]
	mov	QWORD PTR p$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 0
	jmp	SHORT $LN4@myltoa
$LN2@myltoa:
	xor	edx, edx
	mov	eax, DWORD PTR value$[rsp]
	div	DWORD PTR radix$[rsp]
	mov	DWORD PTR value$[rsp], eax
$LN4@myltoa:
	cmp	DWORD PTR value$[rsp], 0
	je	SHORT $LN3@myltoa

; 71   :         *(--p) = __digits[value % radix];

	mov	rax, QWORD PTR p$[rsp]
	dec	rax
	mov	QWORD PTR p$[rsp], rax
	xor	edx, edx
	mov	eax, DWORD PTR value$[rsp]
	div	DWORD PTR radix$[rsp]
	mov	eax, edx
	mov	eax, eax
	lea	rcx, OFFSET FLAT:__digits
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [rdx], al
	jmp	SHORT $LN2@myltoa
$LN3@myltoa:

; 72   :     if ( addzero && ( *p > '9') ) /* v2: add a leading '0' if first digit is alpha */

	movzx	eax, BYTE PTR addzero$[rsp]
	test	eax, eax
	je	SHORT $LN8@myltoa
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN8@myltoa

; 73   :         *dst++ = '0';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 48			; 00000030H
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
$LN8@myltoa:

; 74   :     memcpy( dst, p, &tmpbuf[33] + 1 - p );

	mov	eax, 1
	imul	rax, rax, 33				; 00000021H
	lea	rax, QWORD PTR tmpbuf$[rsp+rax+1]
	sub	rax, QWORD PTR p$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	call	memcpy

; 75   :     DebugMsg1(("myltoa( value=%" I32_SPEC "Xh, out=%s, radix=%u, sign=%u, %u)\n", saved_value, buffer, radix, sign, addzero ));

	movzx	eax, BYTE PTR addzero$[rsp]
	movzx	ecx, BYTE PTR sign$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR radix$[rsp]
	mov	r8, QWORD PTR buffer$[rsp]
	mov	edx, DWORD PTR saved_value$[rsp]
	lea	rcx, OFFSET FLAT:$SG10951
	call	DoDebugMsg1

; 76   :     return( buffer );

	mov	rax, QWORD PTR buffer$[rsp]
$LN1@myltoa:

; 77   : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:myltoa$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 144				; 00000090H
	pop	rdi
	ret	0
myltoa	ENDP
_TEXT	ENDS
END
