; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG12318 DB	01H DUP (?)
	ALIGN	4

$SG11700 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

vcallpass DD	01H DUP (?)
$SG12186 DB	01H DUP (?)
	ALIGN	4

$SG12197 DB	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
fastcall_tab DQ	FLAT:ms32_fcstart
	DQ	FLAT:ms32_fcend
	DQ	FLAT:ms32_param
	DQ	FLAT:watc_fcstart
	DQ	FLAT:watc_fcend
	DQ	FLAT:watc_param
	DQ	FLAT:ms64_fcstart
	DQ	FLAT:ms64_fcend
	DQ	FLAT:ms64_param
ms32_regs DD	012H
	DD	013H
vectorcall_tab DQ FLAT:ms32_fcstart
	DQ	FLAT:ms32_fcend
	DQ	FLAT:ms32_param
	DQ	FLAT:watc_fcstart
	DQ	FLAT:watc_fcend
	DQ	FLAT:watc_param
	DQ	FLAT:ms64_fcstart
	DQ	FLAT:ms64_fcend
	DQ	FLAT:ms64_param
regax	DD	09H
	DD	011H
	DD	073H
	ORG $+4
ms16_regs DD	09H
	DD	0bH
	DD	0cH
	ORG $+12
ms64_regs DD	02H
	DD	03H
	DD	05bH
	DD	05cH
	DD	0aH
	DD	0bH
	DD	063H
	DD	064H
	DD	012H
	DD	013H
	DD	06bH
	DD	06cH
	DD	074H
	DD	075H
	DD	07bH
	DD	07cH
CONST	ENDS
_DATA	SEGMENT
$SG12288 DB	'InvokeDir(%s) enter', 0aH, 00H
	ORG $+3
$SG12293 DB	'NULL', 00H
	ORG $+3
$SG12294 DB	'NULL', 00H
	ORG $+3
$SG12295 DB	'NULL', 00H
	ORG $+3
$SG12296 DB	'InvokeDir: target is expression, kind=%u sym=%s mbr=%s t'
	DB	'ype=%s memtype=%X ofssize=%u', 0aH, 00H
	ORG $+2
$SG12298 DB	'InvokeDirective: opnd.type=>%s< mem_type=%Xh', 0aH, 00H
	ORG $+2
$SG12317 DB	'InvokeDir: error proc.name=>%s< .mem_type=%Xh', 0aH, 00H
	ORG $+1
$SG12319 DB	'InvokeDir: error sym.name=%s', 0aH, 00H
	ORG $+2
$SG12320 DB	'NULL', 00H
	ORG $+3
$SG12321 DB	'InvokeDir: proc=%s target_type=>%s<', 0aH, 00H
	ORG $+3
$SG12323 DB	'NULL', 00H
	ORG $+3
$SG12324 DB	'InvokeDir: error, sym=%s state=%u memtype=%Xh [type=%s m'
	DB	'emtype=%Xh]', 0aH, 00H
	ORG $+3
$SG12335 DB	'InvokeDir: superfluous argument, i=%u', 0aH, 00H
	ORG $+1
$SG12327 DB	'InvokeDir: error, target_type=%s [memtype=%X pmemtype=%X'
	DB	' isproc=%u])', 0aH, 00H
	ORG $+2
$SG12328 DB	'InvokeDir: numparams=%u', 0aH, 00H
	ORG $+7
$SG11312 DB	'ms64_param(%s, index=%u, param.memtype=%Xh, addr=%u) ent'
	DB	'er', 0aH, 00H
$SG12362 DB	' call ', 00H
	ORG $+5
$SG12336 DB	'InvokeDir: VARARG proc, numparams=%u, actual (max) param'
	DB	's=%u, parasize=%u', 0aH, 00H
	ORG $+1
$SG11402 DB	's', 00H
	ORG $+2
$SG12343 DB	'InvokeDir: PushInvokeParam(curr=%u, i=%u, numParam=%u) f'
	DB	'ailed', 0aH, 00H
	ORG $+1
$SG12345 DB	'InvokeDir: PushInvokeParam(curr=%u, i=%u, numParam=%u) f'
	DB	'ailed', 0aH, 00H
	ORG $+1
$SG12350 DB	'InvokeDir: superfluous argument, i=%u', 0aH, 00H
	ORG $+1
$SG12367 DB	' externdef %r %s: %r %r', 00H
$SG12351 DB	'InvokeDir: VARARG proc, numparams=%u, actual (max) param'
	DB	's=%u, parasize=%u', 0aH, 00H
	ORG $+1
$SG11403 DB	'z', 00H
	ORG $+2
$SG12358 DB	'InvokeDir: PushInvokeParam(curr=%u, i=%u, numParam=%u) f'
	DB	'ailed', 0aH, 00H
	ORG $+1
$SG12360 DB	'InvokeDir: PushInvokeParam(curr=%u, i=%u, numParam=%u) f'
	DB	'ailed', 0aH, 00H
	ORG $+1
$SG12368 DB	' externdef %s: %r %r', 00H
	ORG $+3
$SG11346 DB	' lea %r, %s', 00H
$SG11638 DB	's', 00H
	ORG $+2
$SG11347 DB	' mov [%r+%u], %r', 00H
	ORG $+3
$SG11639 DB	'z', 00H
	ORG $+2
$SG11348 DB	'ms64_param(%s, param=%u): ADDR flags=%X', 0aH, 00H
	ORG $+3
$SG11644 DB	'0', 00H
	ORG $+2
$SG12375 DB	'InvokeDir: size of fix args=%u, var args=%u', 0aH, 00H
	ORG $+3
$SG12376 DB	' add %r, %u', 00H
$SG11816 DB	' ', 00H
	ORG $+2
$SG12377 DB	' add %r, %u', 00H
$SG12029 DB	'z', 00H
	ORG $+2
$SG11355 DB	' mov %r ptr [%r+%u], %r ( %s )', 00H
	ORG $+1
$SG11356 DB	' mov %r ptr [%r+%u], %r ( %s )', 00H
	ORG $+1
$SG11358 DB	'ms64_param(%s, param=%u): MT_PTR, type error, psize=%u', 0aH
	DB	00H
$SG11363 DB	' mov %r ptr [%r+%u], %s', 00H
$SG11364 DB	'ms64_param(%s, param=%u): MT_EMPTY size.p=%u flags=%X', 0aH
	DB	00H
	ORG $+1
$SG11369 DB	' mov %r ptr [%r+%u+0], %r (%s)', 00H
	ORG $+1
$SG11370 DB	' mov %r ptr [%r+%u+4], %r (%s)', 00H
	ORG $+1
$SG11371 DB	' mov %r ptr [%r+%u], %s', 00H
$SG11378 DB	'ms64_param(%s, param=%u): type error size.p/a=%u/%u flag'
	DB	's=%X', 0aH, 00H
	ORG $+2
$SG11383 DB	'ms64_param(%s, param=%u): REG size.p/a=%u/%u flags=%X', 0aH
	DB	00H
	ORG $+1
$SG11386 DB	'ms64_param(%s, param=%u): MEM size.p/a=%u/%u flags=%X', 0aH
	DB	00H
	ORG $+1
$SG11400 DB	' movsxd %r, %s', 00H
	ORG $+1
$SG11401 DB	' mov %r, %s', 00H
$SG12030 DB	's', 00H
	ORG $+2
$SG11404 DB	' mov%sx %r, %s', 00H
	ORG $+1
$SG11407 DB	' mov %r, %s', 00H
$SG12043 DB	'z', 00H
	ORG $+2
$SG11408 DB	' mov [%r+%u], %r', 00H
	ORG $+3
$SG11646 DB	'FALSE', 00H
	ORG $+2
$SG12044 DB	's', 00H
	ORG $+2
$SG11417 DB	'ms64_param(%s, param=%u): argument optimized', 0aH, 00H
	ORG $+2
$SG11420 DB	' movd %r, %s', 00H
	ORG $+3
$SG11421 DB	' movq %r, %s', 00H
	ORG $+3
$SG11425 DB	'ms64_param(%s, param=%u): argument optimized', 0aH, 00H
	ORG $+2
$SG11428 DB	' movd %r, %s', 00H
	ORG $+3
$SG11429 DB	' movq %r, %s', 00H
	ORG $+3
$SG11434 DB	'mov %r, %s', 00H
	ORG $+1
$SG12132 DB	's', 00H
	ORG $+2
$SG11435 DB	'vmovd %r, %r', 00H
	ORG $+3
$SG11436 DB	'mov %r, %r ptr %s', 00H
	ORG $+2
$SG12133 DB	'z', 00H
	ORG $+2
$SG11437 DB	'vmovq %r, %r', 00H
	ORG $+3
$SG11443 DB	'vmovsd %r,qword ptr %s', 00H
	ORG $+1
$SG11444 DB	'vmovss %r,dword ptr %s', 00H
	ORG $+1
$SG11447 DB	'movq %r,qword ptr %s', 00H
	ORG $+3
$SG11449 DB	'movd %r,dword ptr %s', 00H
	ORG $+3
$SG11458 DB	'vmovss %r,dword ptr [%s+%d]', 00H
$SG12189 DB	'w', 00H
	ORG $+2
$SG11468 DB	'vmovsd %r,qword ptr [%s+%d]', 00H
$SG12193 DB	'w', 00H
	ORG $+2
$SG11471 DB	'vmovss %r,dword ptr [%s+%d]', 00H
$SG12196 DB	'd', 00H
	ORG $+2
$SG11479 DB	'vmovss %r,dword ptr [%s+%d]', 00H
$SG12202 DB	'd', 00H
	ORG $+2
$SG11487 DB	'vmovsd %r,qword ptr [%s+%d]', 00H
$SG12204 DB	'w', 00H
	ORG $+2
$SG11495 DB	'vmovsd %r,qword ptr [%s+%d]', 00H
$SG12210 DB	'd', 00H
	ORG $+2
$SG11512 DB	'ms64_param(%s, param=%u): argument optimized', 0aH, 00H
	ORG $+2
$SG11513 DB	'vmovaps %r,oword ptr %s', 00H
$SG11519 DB	'ms64_param(%s, param=%u): argument optimized', 0aH, 00H
	ORG $+2
$SG11520 DB	'vmovaps %r,ymmword ptr %s', 00H
	ORG $+6
$SG11545 DB	'vmovss %r,dword ptr %s', 00H
	ORG $+1
$SG11546 DB	'vmovss %r,dword ptr [%s+%d]', 00H
	ORG $+4
$SG11550 DB	'vmovsd %r,oword ptr %s', 00H
	ORG $+1
$SG11551 DB	'vmovsd %r,oword ptr [%s+%d]', 00H
	ORG $+4
$SG11555 DB	'vmovaps %r,oword ptr %s', 00H
$SG11560 DB	'vmovaps %r,oword ptr %s', 00H
$SG11561 DB	'vmovaps %r,oword ptr [%s+%d]', 00H
	ORG $+3
$SG11565 DB	'vmovups %r,oword ptr %s', 00H
$SG11570 DB	'vmovups %r,ymmword ptr %s', 00H
	ORG $+6
$SG11571 DB	'vmovups %r,ymmword ptr [%s+%d]', 00H
	ORG $+1
$SG11576 DB	'vmovss %r,dword ptr %s', 00H
	ORG $+1
$SG11577 DB	'mov %r, qword ptr %s', 00H
	ORG $+3
$SG11581 DB	'vmovsd %r,qword ptr %s', 00H
	ORG $+1
$SG11582 DB	'mov %r, qword ptr %s', 00H
	ORG $+3
$SG11589 DB	'ms64_param(%s, param=%u): argument optimized', 0aH, 00H
	ORG $+2
$SG11590 DB	'vmovaps %r,oword ptr %s', 00H
$SG11591 DB	'vmovaps %r,oword ptr %s', 00H
$SG11593 DB	'vmovups %r,oword ptr %s', 00H
$SG11598 DB	' lea %r, %s', 00H
	ORG $+4
$SG11599 DB	' lea %r, %s', 00H
	ORG $+4
$SG11600 DB	' mov qword ptr [%r+%u], %r', 00H
	ORG $+5
$SG11601 DB	' lea %r, %s', 00H
	ORG $+4
$SG11612 DB	'ms64_param(%s, param=%u): forward ref=%s, assumed size=%'
	DB	'u', 0aH, 00H
	ORG $+5
$SG11619 DB	'ms64_param(%s, param=%u): type error size.p/a=%u/%u flag'
	DB	's=%X', 0aH, 00H
	ORG $+2
$SG11627 DB	'ms64_param(%s, param=%u): argument optimized', 0aH, 00H
	ORG $+2
$SG11636 DB	' movsxd %r, %s', 00H
	ORG $+1
$SG11637 DB	' mov %r, %s', 00H
	ORG $+4
$SG11640 DB	' mov%sx %r, %s', 00H
	ORG $+1
$SG11645 DB	'NULL', 00H
	ORG $+3
$SG11648 DB	' xor %r, %r', 00H
	ORG $+4
$SG11655 DB	' mov %r ptr [%r+%u], %s', 00H
$SG11656 DB	' mov %r, %s', 00H
	ORG $+4
$SG11657 DB	'ms64_param(%s, param=%u): size=%u flags=%X', 0aH, 00H
$SG11677 DB	'NULL', 00H
	ORG $+3
$SG11678 DB	'NULL', 00H
	ORG $+3
$SG11679 DB	'NULL', 00H
	ORG $+3
$SG11680 DB	'NULL', 00H
	ORG $+7
$SG11681 DB	'GetSegmentPart(%s) enter [override=%s sym=%s segment=%s]'
	DB	0aH, 00H
	ORG $+2
$SG11696 DB	'seg ', 00H
	ORG $+3
$SG11699 DB	'seg ', 00H
	ORG $+7
$SG11701 DB	'GetSegmentPart: reg%u, buffer=%s', 0aH, 00H
	ORG $+6
$SG11713 DB	'watc_fcstart(%s, %u, %u)', 0aH, 00H
	ORG $+6
$SG11721 DB	'watc_fcend(%s, %u, %u)', 0aH, 00H
$SG11724 DB	' add %r, %u', 00H
	ORG $+4
$SG11726 DB	' add %r, %u', 00H
	ORG $+4
$SG11764 DB	'watc_param(%s, param=%u [name=%s, state=%u]),addr=%u: ps'
	DB	'ize=%u', 0aH, 00H
$SG11766 DB	'watc_param(%s): register param=%s', 0aH, 00H
	ORG $+5
$SG11776 DB	'%r %s, %r', 00H
	ORG $+6
$SG11777 DB	'%r %s, %s', 00H
	ORG $+6
$SG11778 DB	'%r %s, %r %s', 00H
	ORG $+3
$SG11788 DB	'mov %s, %r (%s)', 00H
$SG11789 DB	'mov %s, %s', 00H
	ORG $+5
$SG11792 DB	'mov %s, %s', 00H
	ORG $+5
$SG11795 DB	'mov %s, %s', 00H
	ORG $+5
$SG11798 DB	'mov %s, %r %r %s[%u]', 00H
	ORG $+3
$SG11872 DB	'NULL', 00H
	ORG $+3
$SG11873 DB	'PushInvokeParam(%s, param=%s:%u, i=%u ) enter', 0aH, 00H
	ORG $+1
$SG11875 DB	'PushInvokeParam(%s): T_FINAL token, i=%u', 0aH, 00H
	ORG $+6
$SG11878 DB	'PushInvokeParam(%s,%u): pmtype=%Xh, psize=%u', 0aH, 00H
	ORG $+2
$SG11884 DB	'PushInvokeParm(%u): error, psize=%u, fptrsize=%u', 0aH, 00H
	ORG $+6
$SG11895 DB	'PushInvokeParam: far ptr, %s isfar=%u, psize=%u, fptrsiz'
	DB	'e=%u', 0aH, 00H
	ORG $+2
$SG11900 DB	' push %s', 00H
	ORG $+7
$SG11901 DB	' lea %r, %s', 00H
	ORG $+4
$SG11902 DB	' push %r', 00H
	ORG $+7
$SG11909 DB	' db 66h', 00H
$SG11910 DB	' push %r', 00H
	ORG $+7
$SG11911 DB	' push %s', 00H
	ORG $+7
$SG11914 DB	' mov %r, offset %s', 00H
	ORG $+5
$SG11915 DB	' push %r', 00H
	ORG $+7
$SG11921 DB	' pushd %r %s', 00H
	ORG $+3
$SG11925 DB	' pushw %r %s', 00H
	ORG $+3
$SG11926 DB	' push %r %s', 00H
	ORG $+4
$SG11929 DB	'PushInvokeParm(%u): new value of size_vararg=%u [CurrWor'
	DB	'dSize=%u]', 0aH, 00H
	ORG $+5
$SG11936 DB	' db 66h', 00H
$SG11937 DB	' push %r', 00H
	ORG $+7
$SG11948 DB	'PushInvokeParm(%u): error, psize=0', 0aH, 00H
	ORG $+4
$SG11950 DB	'PushInvokeParm(%u): memtype EMPTY, asize=%u psize=%u', 0aH
	DB	00H
	ORG $+2
$SG11961 DB	'PushInvokeParam(%s, %u): arg name=%s, asize=%u, amtype=%'
	DB	'xh psize=%u', 0aH, 00H
	ORG $+3
$SG11974 DB	'PushInvokeParm(%u): argsize error, arg size=%d, parm siz'
	DB	'e=%d', 0aH, 00H
	ORG $+2
$SG11994 DB	' push word ptr %s+%u', 00H
	ORG $+3
$SG11962 DB	'PushInvokeParam(%s, %u): arg no name, asize=%u, amtype=%'
	DB	'xh psize=%u', 0aH, 00H
	ORG $+3
$SG11984 DB	'PushInvokeParm(%u): asize=%u added to size_vararg, now=%'
	DB	'u', 0aH, 00H
	ORG $+5
$SG11993 DB	' sub %r, 2', 00H
	ORG $+5
$SG11995 DB	' push %r ptr %s+%u', 00H
	ORG $+5
$SG11999 DB	'PushInvokeParm(%u): error, ADDR, psize=%u, is > 4', 0aH, 00H
	ORG $+5
$SG12002 DB	' movsx %r, %s', 00H
	ORG $+2
$SG12003 DB	' push %r', 00H
	ORG $+7
$SG12007 DB	' mov %r, %s', 00H
	ORG $+4
$SG12008 DB	' push %r', 00H
	ORG $+7
$SG12017 DB	' xor %r, %r', 00H
	ORG $+4
$SG12018 DB	' push %r', 00H
	ORG $+7
$SG12019 DB	' push 0', 00H
$SG12020 DB	' mov %r, %s', 00H
	ORG $+4
$SG12022 DB	' mov %r, 0', 00H
	ORG $+5
$SG12023 DB	' mov %r, %s', 00H
$SG12024 DB	' cbw', 00H
	ORG $+3
$SG12026 DB	' cwd', 00H
	ORG $+7
$SG12027 DB	' push %r', 00H
	ORG $+7
$SG12028 DB	' push %r', 00H
	ORG $+7
$SG12031 DB	' mov%sx %r, %s', 00H
	ORG $+1
$SG12032 DB	' push %r', 00H
	ORG $+7
$SG12040 DB	' pushw 0', 00H
	ORG $+7
$SG12041 DB	' sub %r, 2', 00H
	ORG $+5
$SG12042 DB	' push %s', 00H
	ORG $+7
$SG12045 DB	' mov%sx %r, %s', 00H
	ORG $+1
$SG12046 DB	' push %r', 00H
	ORG $+7
$SG12048 DB	' push %s', 00H
	ORG $+7
$SG12053 DB	' movsx %r, %s', 00H
	ORG $+2
$SG12054 DB	' push %r', 00H
	ORG $+7
$SG12057 DB	' mov %r, %s', 00H
$SG12058 DB	' cwd', 00H
	ORG $+7
$SG12059 DB	' push %r', 00H
	ORG $+7
$SG12060 DB	' push %r', 00H
	ORG $+7
$SG12061 DB	' push %s', 00H
	ORG $+7
$SG12066 DB	' xor %r, %r', 00H
	ORG $+4
$SG12067 DB	' push %r', 00H
	ORG $+7
$SG12068 DB	' pushw 0', 00H
	ORG $+7
$SG12069 DB	' push %s', 00H
	ORG $+7
$SG12091 DB	' mov %r, %s', 00H
$SG12101 DB	' cbw', 00H
	ORG $+7
$SG12082 DB	'PushInvokeParm(%u): error, REG, asize=%u, psize=%u, push'
	DB	'size=%u', 0aH, 00H
	ORG $+7
$SG12096 DB	' movsx %r, %s', 00H
	ORG $+2
$SG12100 DB	' mov %r, %s', 00H
	ORG $+4
$SG12103 DB	' mov %r, %s', 00H
$SG12104 DB	' cwd', 00H
	ORG $+7
$SG12105 DB	' push %r', 00H
	ORG $+7
$SG12114 DB	' sub %r, 2', 00H
	ORG $+5
$SG12117 DB	' movsx %r, %s', 00H
	ORG $+2
$SG12118 DB	' pushw 0', 00H
	ORG $+7
$SG12119 DB	' pushw 0', 00H
	ORG $+7
$SG12123 DB	' xor %r, %r', 00H
	ORG $+4
$SG12124 DB	' push %r', 00H
	ORG $+7
$SG12134 DB	' mov%sx %r, %s', 00H
	ORG $+1
$SG12136 DB	' mov %r, %s', 00H
$SG12140 DB	' cbw', 00H
	ORG $+7
$SG12142 DB	' mov %r, 0', 00H
	ORG $+5
$SG11119 DB	'ms32_fcstart(proc=%s, ofs=%u)', 0aH, 00H
	ORG $+1
$SG12146 DB	' push %r', 00H
	ORG $+7
$SG12170 DB	' mov %r, %s', 00H
	ORG $+4
$SG11147 DB	'ms32_param(proc=%s, ofs=%u, index=%u, param=%s) fcscratc'
	DB	'h=%u', 0aH, 00H
	ORG $+2
$SG12172 DB	' xor %r, %r', 00H
	ORG $+4
$SG12176 DB	' xor %r, %r', 00H
	ORG $+4
$SG12177 DB	' mov %r, %r (%s)', 00H
	ORG $+7
$SG11153 DB	' lea %r, %s', 00H
	ORG $+4
$SG12178 DB	' push %r', 00H
	ORG $+7
$SG12182 DB	' mov %r, %r (%s)', 00H
	ORG $+3
$SG11158 DB	'movsx', 00H
	ORG $+2
$SG11159 DB	'movzx', 00H
	ORG $+6
$SG11160 DB	' %s %r, %s', 00H
	ORG $+5
$SG11161 DB	' mov %r, %s', 00H
	ORG $+12
$SG12184 DB	'PushInvokeParm(%u): error, CONST, asize=%u, psize=%u, pu'
	DB	'shsize=%u', 0aH, 00H
	ORG $+5
$SG12185 DB	' push %r', 00H
	ORG $+7
$SG11162 DB	' mov %r, 0', 00H
	ORG $+5
$SG11165 DB	' mov %r, %s', 00H
	ORG $+4
$SG12198 DB	' push%s (%s) shr 32t', 00H
	ORG $+3
$SG12203 DB	' pushw %r (%s)', 00H
	ORG $+1
$SG12209 DB	' pushd %r (%s)', 00H
	ORG $+1
$SG11186 DB	'ms64_fcstart(%s, numparams=%u) vararg=%u', 0aH, 00H
	ORG $+6
$SG12212 DB	'PushInvokeParm(%u): error, CONST, asize=%u, psize=%u, pu'
	DB	'shsize=%u', 0aH, 00H
	ORG $+5
$SG12215 DB	' push%s %r (%s)', 00H
$SG12216 DB	' push%s %s', 00H
	ORG $+5
$SG11193 DB	' sub %r, %d', 00H
	ORG $+4
$SG12218 DB	'PushInvokeParm(%u): psize=%u added to size_vararg, now=%'
	DB	'u', 0aH, 00H
	ORG $+5
$SG11202 DB	' add %r, %d', 00H
_DATA	ENDS
PUBLIC	InvokeDirective
EXTRN	__report_rangecheckfailure:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strchr:PROC
EXTRN	strcat:PROC
EXTRN	strcpy:PROC
EXTRN	_stricmp:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	SymFind:PROC
EXTRN	SizeFromMemtype:PROC
EXTRN	SizeFromRegister:PROC
EXTRN	GetResWName:PROC
EXTRN	EvalOperand:PROC
EXTRN	AddLineQueue:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	RunLineQueue:PROC
EXTRN	search_assume:PROC
EXTRN	GetStdAssume:PROC
EXTRN	GetSymOfssize:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	GetGroup:PROC
EXTRN	LstWrite:PROC
EXTRN	Mangle:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SpecialTable:BYTE
EXTRN	sym_ReservedStack:QWORD
EXTRN	maxintvalues:BYTE
EXTRN	minintvalues:BYTE
EXTRN	stackreg:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
	ALIGN	4

size_vararg DD	01H DUP (?)
fcscratch DD	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$ms32_fcstart DD imagerel ms32_fcstart
	DD	imagerel ms32_fcstart+160
	DD	imagerel $unwind$ms32_fcstart
$pdata$ms32_param DD imagerel ms32_param
	DD	imagerel ms32_param+636
	DD	imagerel $unwind$ms32_param
$pdata$watc_fcstart DD imagerel watc_fcstart
	DD	imagerel watc_fcstart+64
	DD	imagerel $unwind$watc_fcstart
$pdata$watc_fcend DD imagerel watc_fcend
	DD	imagerel watc_fcend+203
	DD	imagerel $unwind$watc_fcend
$pdata$watc_param DD imagerel watc_param
	DD	imagerel watc_param+1277
	DD	imagerel $unwind$watc_param
$pdata$ms64_fcstart DD imagerel ms64_fcstart
	DD	imagerel ms64_fcstart+334
	DD	imagerel $unwind$ms64_fcstart
$pdata$ms64_fcend DD imagerel ms64_fcend
	DD	imagerel ms64_fcend+64
	DD	imagerel $unwind$ms64_fcend
$pdata$ms64_param DD imagerel ms64_param
	DD	imagerel ms64_param+12044
	DD	imagerel $unwind$ms64_param
$pdata$GetSegmentPart DD imagerel GetSegmentPart
	DD	imagerel GetSegmentPart+786
	DD	imagerel $unwind$GetSegmentPart
$pdata$SkipTypecast DD imagerel SkipTypecast
	DD	imagerel SkipTypecast+249
	DD	imagerel $unwind$SkipTypecast
$pdata$PushInvokeParam DD imagerel PushInvokeParam
	DD	imagerel PushInvokeParam+9172
	DD	imagerel $unwind$PushInvokeParam
$pdata$InvokeDirective DD imagerel $LN114
	DD	imagerel $LN114+4563
	DD	imagerel $unwind$InvokeDirective
pdata	ENDS
xdata	SEGMENT
$unwind$ms32_fcstart DD 011701H
	DD	06217H
$unwind$ms32_param DD 011701H
	DD	0a217H
$unwind$watc_fcstart DD 011701H
	DD	04217H
$unwind$watc_fcend DD 011201H
	DD	04212H
$unwind$watc_param DD 022c19H
	DD	02b011aH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$ms64_fcstart DD 011701H
	DD	04217H
$unwind$ms64_fcend DD 011201H
	DD	04212H
$unwind$ms64_param DD 021a01H
	DD	01d011aH
$unwind$GetSegmentPart DD 011301H
	DD	0e213H
$unwind$SkipTypecast DD 011201H
	DD	06212H
$unwind$PushInvokeParam DD 022c19H
	DD	0133011aH
	DD	imagerel __GSHandlerCheck
	DD	0980H
$unwind$InvokeDirective DD 021001H
	DD	02f0110H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\invoke.c
_TEXT	SEGMENT
r0flags$ = 64
sym$ = 72
numParam$ = 80
curr$ = 88
proc$ = 96
info$ = 104
p$ = 112
j$1 = 120
j$2 = 124
porder$ = 128
namepos$ = 132
value$ = 136
tv251 = 140
parmpos$ = 144
size$ = 148
tv135 = 152
tv139 = 160
tv143 = 168
tv176 = 176
tv231 = 184
tv239 = 192
tv257 = 200
iatname$3 = 208
tv751 = 216
tv740 = 224
tv741 = 232
tv744 = 240
tv745 = 248
opnd$ = 256
i$ = 384
tokenarray$ = 392
InvokeDirective PROC

; 2024 : {

$LN114:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 376				; 00000178H

; 2025 :     struct asym    *sym;
; 2026 :     struct dsym    *proc;
; 2027 :     char           *p;
; 2028 :     //char         *param;
; 2029 :     int            numParam;
; 2030 :     int            value;
; 2031 :     int            size;
; 2032 :     int            parmpos;
; 2033 :     int            namepos;
; 2034 :     int            porder;
; 2035 :     int            j;
; 2036 :     uint_8         r0flags = 0;

	mov	BYTE PTR r0flags$[rsp], 0

; 2037 :     //bool           uselabel = FALSE;
; 2038 :     struct proc_info *info;
; 2039 :     struct dsym    *curr;
; 2040 :     struct expr    opnd;
; 2041 :     //char           buffer[MAX_LINE_LEN];
; 2042 : 
; 2043 :     DebugMsg1(("InvokeDir(%s) enter\n", tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG12288
	call	DoDebugMsg1

; 2044 :     i++; /* skip INVOKE directive */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 2045 :     namepos = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR namepos$[rsp], eax

; 2046 :     /* if there is more than just an ID item describing the invoke target,
; 2047 :      use the expression evaluator to get it
; 2048 :      */
; 2049 :     if ( tokenarray[i].token != T_ID || ( tokenarray[i+1].token != T_COMMA && tokenarray[i+1].token != T_FINAL ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN35@InvokeDire
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	$LN33@InvokeDire
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN33@InvokeDire
$LN35@InvokeDire:

; 2050 :     //if ( tokenarray[i+1].token != T_COMMA && tokenarray[i+1].token != T_FINAL ) {
; 2051 :         if ( ERROR == EvalOperand( &i, tokenarray, Token_Count, &opnd, 0 ) )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opnd$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN36@InvokeDire

; 2052 :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@InvokeDire
$LN36@InvokeDire:

; 2053 :         DebugMsg1(("InvokeDir: target is expression, kind=%u sym=%s mbr=%s type=%s memtype=%X ofssize=%u\n",

	cmp	QWORD PTR opnd$[rsp+96], 0
	je	SHORT $LN98@InvokeDire
	mov	rax, QWORD PTR opnd$[rsp+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv135[rsp], rax
	jmp	SHORT $LN99@InvokeDire
$LN98@InvokeDire:
	lea	rax, OFFSET FLAT:$SG12293
	mov	QWORD PTR tv135[rsp], rax
$LN99@InvokeDire:
	cmp	QWORD PTR opnd$[rsp+88], 0
	je	SHORT $LN100@InvokeDire
	mov	rax, QWORD PTR opnd$[rsp+88]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv139[rsp], rax
	jmp	SHORT $LN101@InvokeDire
$LN100@InvokeDire:
	lea	rax, OFFSET FLAT:$SG12294
	mov	QWORD PTR tv139[rsp], rax
$LN101@InvokeDire:
	cmp	QWORD PTR opnd$[rsp+80], 0
	je	SHORT $LN102@InvokeDire
	mov	rax, QWORD PTR opnd$[rsp+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv143[rsp], rax
	jmp	SHORT $LN103@InvokeDire
$LN102@InvokeDire:
	lea	rax, OFFSET FLAT:$SG12295
	mov	QWORD PTR tv143[rsp], rax
$LN103@InvokeDire:
	movzx	eax, BYTE PTR opnd$[rsp+69]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR opnd$[rsp+64]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR tv135[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv139[rsp]
	mov	r8, QWORD PTR tv143[rsp]
	mov	edx, DWORD PTR opnd$[rsp+60]
	lea	rcx, OFFSET FLAT:$SG12296
	call	DoDebugMsg1

; 2054 :                    opnd.kind,
; 2055 :                    opnd.sym ? opnd.sym->name : "NULL",
; 2056 :                    opnd.mbr ? opnd.mbr->name : "NULL",
; 2057 :                    opnd.type ? opnd.type->name : "NULL",
; 2058 :                    opnd.mem_type, opnd.Ofssize ));
; 2059 : #if 1
; 2060 :         /* a typecast with PTR? Since v1.95, this has highest priority */
; 2061 :         //if (opnd.explicit == TRUE && opnd.type != NULL && opnd.type->state == SYM_TYPE ) {
; 2062 :         /* v1.96: removed opnd.explicit!!! */
; 2063 :         /* fixme: if opnd.type is set, opnd.type MUST have state SYM_TYPE */
; 2064 :         if ( opnd.type != NULL && opnd.type->state == SYM_TYPE ) {

	cmp	QWORD PTR opnd$[rsp+96], 0
	je	SHORT $LN37@InvokeDire
	mov	rax, QWORD PTR opnd$[rsp+96]
	cmp	DWORD PTR [rax+40], 7
	jne	SHORT $LN37@InvokeDire

; 2065 :             sym = opnd.type;

	mov	rax, QWORD PTR opnd$[rsp+96]
	mov	QWORD PTR sym$[rsp], rax

; 2066 :             DebugMsg1(("InvokeDirective: opnd.type=>%s< mem_type=%Xh\n", sym->name, sym->mem_type ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+44]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12298
	call	DoDebugMsg1

; 2067 :             proc = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR proc$[rsp], rax

; 2068 :             //if ( opnd.label_tok != NULL ) /* v2.09: uselabel obsolete */
; 2069 :             //    uselabel = TRUE;
; 2070 :             if ( sym->mem_type == MT_PROC ) /* added for v1.95 */

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+44], 128			; 00000080H
	jne	SHORT $LN38@InvokeDire

; 2071 :                 goto isfnproto;

	jmp	$isfnproto$115
$LN38@InvokeDire:

; 2072 :             if ( sym->mem_type == MT_PTR )  /* v2.09: mem_type must be MT_PTR */

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+44], 195			; 000000c3H
	jne	SHORT $LN39@InvokeDire

; 2073 :                 goto isfnptr;

	jmp	$isfnptr$116
$LN39@InvokeDire:
$LN37@InvokeDire:

; 2074 :         }
; 2075 : #endif
; 2076 :         if ( opnd.kind == EXPR_REG ) {

	cmp	DWORD PTR opnd$[rsp+60], 2
	jne	SHORT $LN40@InvokeDire

; 2077 :             if ( GetValueSp( opnd.base_reg->tokval ) & OP_RGT8 )

	mov	rax, QWORD PTR opnd$[rsp+24]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 14
	test	eax, eax
	je	SHORT $LN42@InvokeDire

; 2078 :                 sym = GetStdAssume( GetRegNo( opnd.base_reg->tokval ) );

	mov	rax, QWORD PTR opnd$[rsp+24]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	ecx, eax
	call	GetStdAssume
	mov	QWORD PTR sym$[rsp], rax
	jmp	SHORT $LN43@InvokeDire
$LN42@InvokeDire:

; 2079 :             else
; 2080 :                 sym = NULL;

	mov	QWORD PTR sym$[rsp], 0
$LN43@InvokeDire:

; 2081 :         } else

	jmp	SHORT $LN41@InvokeDire
$LN40@InvokeDire:

; 2082 :             sym = ( opnd.mbr ? opnd.mbr : opnd.sym );

	cmp	QWORD PTR opnd$[rsp+88], 0
	je	SHORT $LN104@InvokeDire
	mov	rax, QWORD PTR opnd$[rsp+88]
	mov	QWORD PTR tv176[rsp], rax
	jmp	SHORT $LN105@InvokeDire
$LN104@InvokeDire:
	mov	rax, QWORD PTR opnd$[rsp+80]
	mov	QWORD PTR tv176[rsp], rax
$LN105@InvokeDire:
	mov	rax, QWORD PTR tv176[rsp]
	mov	QWORD PTR sym$[rsp], rax
$LN41@InvokeDire:

; 2083 : 
; 2084 :     } else {

	jmp	SHORT $LN34@InvokeDire
$LN33@InvokeDire:

; 2085 :         opnd.base_reg = NULL;

	mov	QWORD PTR opnd$[rsp+24], 0

; 2086 :         sym = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 2087 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN34@InvokeDire:

; 2088 :     }
; 2089 : 
; 2090 :     if( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN44@InvokeDire

; 2091 :         /* v2.04: msg changed */
; 2092 :         return( EmitErr( INVOKE_REQUIRES_PROTOTYPE ) );

	mov	ecx, 159				; 0000009fH
	call	EmitErr
	jmp	$LN1@InvokeDire
$LN44@InvokeDire:

; 2093 :         //return( EmitErr( SYMBOL_NOT_DEFINED, name ) );
; 2094 :     }
; 2095 :     if( sym->isproc )  /* the most simple case: symbol is a PROC */

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+49]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN45@InvokeDire

; 2096 :         ;

	jmp	$LN46@InvokeDire
$LN45@InvokeDire:

; 2097 :     else if ( sym->mem_type == MT_PTR && sym->target_type && sym->target_type->isproc )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+44], 195			; 000000c3H
	jne	SHORT $LN47@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN47@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+56]
	movzx	eax, BYTE PTR [rax+49]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN47@InvokeDire

; 2098 :         sym = sym->target_type;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR sym$[rsp], rax
	jmp	$LN48@InvokeDire
$LN47@InvokeDire:

; 2099 :     else if ( sym->mem_type == MT_PTR && sym->target_type && sym->target_type->mem_type == MT_PROC ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+44], 195			; 000000c3H
	jne	SHORT $LN49@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN49@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+56]
	cmp	DWORD PTR [rax+44], 128			; 00000080H
	jne	SHORT $LN49@InvokeDire

; 2100 :         proc = (struct dsym *)sym->target_type;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR proc$[rsp], rax

; 2101 :         goto isfnproto;

	jmp	SHORT $isfnproto$115
	jmp	$LN50@InvokeDire
$LN49@InvokeDire:

; 2102 :     } else if ( ( sym->mem_type == MT_TYPE ) && ( sym->type->mem_type == MT_PTR || sym->type->mem_type == MT_PROC ) ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+44], 196			; 000000c4H
	jne	$LN51@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+88]
	cmp	DWORD PTR [rax+44], 195			; 000000c3H
	je	SHORT $LN53@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+88]
	cmp	DWORD PTR [rax+44], 128			; 00000080H
	jne	$LN51@InvokeDire
$LN53@InvokeDire:

; 2103 :         /* second case: symbol is a (function?) pointer */
; 2104 :         proc = (struct dsym *)sym->type;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR proc$[rsp], rax

; 2105 :         if ( proc->sym.mem_type != MT_PROC )

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+44], 128			; 00000080H
	je	SHORT $LN54@InvokeDire

; 2106 :             goto isfnptr;

	jmp	SHORT $isfnptr$116
$LN54@InvokeDire:
$isfnproto$115:

; 2107 :     isfnproto:
; 2108 :         /* pointer target must be a PROTO typedef */
; 2109 :         if ( proc->sym.mem_type != MT_PROC ) {

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+44], 128			; 00000080H
	je	SHORT $LN55@InvokeDire

; 2110 :             DebugMsg(("InvokeDir: error proc.name=>%s< .mem_type=%Xh\n", proc->sym.name, proc->sym.mem_type ));

	mov	rax, QWORD PTR proc$[rsp]
	mov	r8d, DWORD PTR [rax+44]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12317
	call	DoDebugMsg

; 2111 :             DebugMsg(("InvokeDir: error sym.name=%s\n", sym ? sym->name : "" ));

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN106@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv231[rsp], rax
	jmp	SHORT $LN107@InvokeDire
$LN106@InvokeDire:
	lea	rax, OFFSET FLAT:$SG12318
	mov	QWORD PTR tv231[rsp], rax
$LN107@InvokeDire:
	mov	rdx, QWORD PTR tv231[rsp]
	lea	rcx, OFFSET FLAT:$SG12319
	call	DoDebugMsg

; 2112 :             return( EmitErr( INVOKE_REQUIRES_PROTOTYPE ) );

	mov	ecx, 159				; 0000009fH
	call	EmitErr
	jmp	$LN1@InvokeDire
$LN55@InvokeDire:
$isfnptr$116:

; 2113 :         }
; 2114 :     isfnptr:
; 2115 :         /* get the pointer target */
; 2116 :         sym = proc->sym.target_type;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR sym$[rsp], rax

; 2117 :         DebugMsg1(("InvokeDir: proc=%s target_type=>%s<\n", proc->sym.name, sym ? sym->name : "NULL" ));

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN108@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv239[rsp], rax
	jmp	SHORT $LN109@InvokeDire
$LN108@InvokeDire:
	lea	rax, OFFSET FLAT:$SG12320
	mov	QWORD PTR tv239[rsp], rax
$LN109@InvokeDire:
	mov	r8, QWORD PTR tv239[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12321
	call	DoDebugMsg1

; 2118 :         if ( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN56@InvokeDire

; 2119 :             return( EmitErr( INVOKE_REQUIRES_PROTOTYPE ) );

	mov	ecx, 159				; 0000009fH
	call	EmitErr
	jmp	$LN1@InvokeDire
$LN56@InvokeDire:

; 2120 :         }
; 2121 :     } else {

	jmp	$LN52@InvokeDire
$LN51@InvokeDire:

; 2122 :         DebugMsg(("InvokeDir: error, sym=%s state=%u memtype=%Xh [type=%s memtype=%Xh]\n",

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN110@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	eax, DWORD PTR [rax+44]
	mov	DWORD PTR tv251[rsp], eax
	jmp	SHORT $LN111@InvokeDire
$LN110@InvokeDire:
	mov	DWORD PTR tv251[rsp], 0
$LN111@InvokeDire:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN112@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv257[rsp], rax
	jmp	SHORT $LN113@InvokeDire
$LN112@InvokeDire:
	lea	rax, OFFSET FLAT:$SG12323
	mov	QWORD PTR tv257[rsp], rax
$LN113@InvokeDire:
	mov	eax, DWORD PTR tv251[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR tv257[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+44]
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+40]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12324
	call	DoDebugMsg

; 2123 :                   sym->name, sym->state, sym->mem_type,
; 2124 :                   sym->type ? sym->type->name : "NULL",
; 2125 :                   sym->type ? sym->type->mem_type : 0));
; 2126 : #ifdef DEBUG_OUT
; 2127 :         if ( sym->mem_type == MT_PTR || sym->mem_type == MT_PROC )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+44], 195			; 000000c3H
	je	SHORT $LN58@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+44], 128			; 00000080H
	jne	SHORT $LN57@InvokeDire
$LN58@InvokeDire:

; 2128 :             DebugMsg(("InvokeDir: error, target_type=%s [memtype=%X pmemtype=%X isproc=%u])\n",

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+56]
	movzx	eax, BYTE PTR [rax+49]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	movzx	ecx, BYTE PTR [rcx+54]
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rdx+56]
	mov	r8, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [r8+56]
	mov	QWORD PTR tv751[rsp], r8
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, DWORD PTR [rdx+44]
	mov	rax, QWORD PTR tv751[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12327
	call	DoDebugMsg
$LN57@InvokeDire:

; 2129 :                       sym->target_type->name,
; 2130 :                       sym->target_type->mem_type,
; 2131 :                       sym->target_type->ptr_memtype,
; 2132 :                       sym->target_type->isproc ));
; 2133 : #endif
; 2134 :         return( EmitErr( INVOKE_REQUIRES_PROTOTYPE ) );

	mov	ecx, 159				; 0000009fH
	call	EmitErr
	jmp	$LN1@InvokeDire
$LN52@InvokeDire:
$LN50@InvokeDire:
$LN48@InvokeDire:
$LN46@InvokeDire:

; 2135 :     }
; 2136 :     proc = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR proc$[rsp], rax

; 2137 :     info = proc->e.procinfo;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR info$[rsp], rax

; 2138 :     /* if (Parse_Pass == PASS_1) */
; 2139 :       memset(info->vregs, 0, 6); /* reset vregs EVERY pass */

	mov	rax, QWORD PTR info$[rsp]
	add	rax, 68					; 00000044H
	mov	r8d, 6
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 2140 :       /* clear sse register flags every pass*/
; 2141 :       memset(info->xyzused, 0, 6);

	mov	rax, QWORD PTR info$[rsp]
	add	rax, 74					; 0000004aH
	mov	r8d, 6
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 2142 :       memset(info->vecregsize, 0, 6);

	mov	rax, QWORD PTR info$[rsp]
	add	rax, 62					; 0000003eH
	mov	r8d, 6
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 2143 :       info->vsize = 0;

	mov	rax, QWORD PTR info$[rsp]
	mov	DWORD PTR [rax+44], 0

; 2144 :       //memset(regsize, 0, 6);
; 2145 :     
; 2146 : #if 0 /* v2.05: can't happen anymore */
; 2147 :     /* does FASTCALL variant support INVOKE? */
; 2148 :     if ( proc->sym.langtype == LANG_FASTCALL && fastcall_tab[ModuleInfo.fctype].invokestart == NULL ) {
; 2149 :         return( EmitError( FASTCALL_VARIANT_NOT_SUPPORTED ) );
; 2150 :     }
; 2151 : #endif
; 2152 : 
; 2153 :     /* get the number of parameters */
; 2154 :     for ( curr = info->paralist, numParam = 0 ; curr ; curr = curr->nextparam, numParam++ );

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR curr$[rsp], rax
	mov	DWORD PTR numParam$[rsp], 0
	jmp	SHORT $LN4@InvokeDire
$LN2@InvokeDire:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+120]
	mov	QWORD PTR curr$[rsp], rax
	mov	eax, DWORD PTR numParam$[rsp]
	inc	eax
	mov	DWORD PTR numParam$[rsp], eax
$LN4@InvokeDire:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@InvokeDire
	jmp	SHORT $LN2@InvokeDire
$LN3@InvokeDire:

; 2155 :     DebugMsg1(("InvokeDir: numparams=%u\n", numParam ));

	mov	edx, DWORD PTR numParam$[rsp]
	lea	rcx, OFFSET FLAT:$SG12328
	call	DoDebugMsg1

; 2156 : 
; 2157 :     if ( proc->sym.langtype == LANG_FASTCALL ) {

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 7
	jne	SHORT $LN59@InvokeDire

; 2158 :         fcscratch = 0;

	mov	DWORD PTR fcscratch, 0

; 2159 :         porder = fastcall_tab[ModuleInfo.fctype].invokestart( proc, numParam, i, tokenarray, &value );

	movsxd	rax, DWORD PTR ModuleInfo+376
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:fastcall_tab
	mov	QWORD PTR tv740[rsp], rcx
	lea	rdx, QWORD PTR value$[rsp]
	mov	QWORD PTR [rsp+32], rdx
	mov	r9, QWORD PTR tokenarray$[rsp]
	mov	r8d, DWORD PTR i$[rsp]
	mov	edx, DWORD PTR numParam$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	r10, QWORD PTR tv740[rsp]
	call	QWORD PTR [r10+rax]
	mov	DWORD PTR porder$[rsp], eax

; 2160 :     }

	jmp	SHORT $LN60@InvokeDire
$LN59@InvokeDire:

; 2161 :     else if ( proc->sym.langtype == LANG_VECTORCALL ) {

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	SHORT $LN61@InvokeDire

; 2162 :         fcscratch = 0;

	mov	DWORD PTR fcscratch, 0

; 2163 :         porder = vectorcall_tab[ModuleInfo.fctype].invokestart( proc, numParam, i, tokenarray, &value );

	movsxd	rax, DWORD PTR ModuleInfo+376
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:vectorcall_tab
	mov	QWORD PTR tv741[rsp], rcx
	lea	rdx, QWORD PTR value$[rsp]
	mov	QWORD PTR [rsp+32], rdx
	mov	r9, QWORD PTR tokenarray$[rsp]
	mov	r8d, DWORD PTR i$[rsp]
	mov	edx, DWORD PTR numParam$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	r10, QWORD PTR tv741[rsp]
	call	QWORD PTR [r10+rax]
	mov	DWORD PTR porder$[rsp], eax
$LN61@InvokeDire:
$LN60@InvokeDire:

; 2164 :     }
; 2165 : 
; 2166 : 	/* -----------------------------------------------------------------------------------------------
; 2167 : 	 HANDLE PARAMETERS (FIRST PASS)
; 2168 : 	----------------------------------------------------------------------------------------------- */ 
; 2169 :     curr = info->paralist;

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR curr$[rsp], rax

; 2170 :     parmpos = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR parmpos$[rsp], eax

; 2171 : 
; 2172 :     if ( !( info->has_vararg ) ) {

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN62@InvokeDire

; 2173 :         /* check if there is a superfluous parameter in the INVOKE call */
; 2174 :         if ( PushInvokeParam( i, tokenarray, proc, NULL, numParam, &r0flags ) != ERROR ) {

	lea	rax, QWORD PTR r0flags$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR numParam$[rsp]
	mov	DWORD PTR [rsp+32], eax
	xor	r9d, r9d
	mov	r8, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	PushInvokeParam
	cmp	eax, -1
	je	SHORT $LN64@InvokeDire

; 2175 :             DebugMsg(("InvokeDir: superfluous argument, i=%u\n", i));

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG12335
	call	DoDebugMsg

; 2176 :             return( EmitErr( TOO_MANY_ARGUMENTS_TO_INVOKE ) );

	mov	ecx, 177				; 000000b1H
	call	EmitErr
	jmp	$LN1@InvokeDire
$LN64@InvokeDire:

; 2177 :         }
; 2178 :     } else {

	jmp	$LN63@InvokeDire
$LN62@InvokeDire:

; 2179 :         int j = (Token_Count - i) / 2;

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR ModuleInfo+496
	sub	ecx, eax
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR j$1[rsp], eax

; 2180 :         /* for VARARG procs, just push the additional params with
; 2181 :          the VARARG descriptor
; 2182 :         */
; 2183 :         numParam--;

	mov	eax, DWORD PTR numParam$[rsp]
	dec	eax
	mov	DWORD PTR numParam$[rsp], eax

; 2184 :         size_vararg = 0; /* reset the VARARG parameter size count */

	mov	DWORD PTR size_vararg, 0
$LN5@InvokeDire:

; 2185 :         while ( curr && curr->sym.is_vararg == FALSE ) curr = curr->nextparam;

	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN6@InvokeDire
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@InvokeDire
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+120]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN5@InvokeDire
$LN6@InvokeDire:

; 2186 :         DebugMsg1(("InvokeDir: VARARG proc, numparams=%u, actual (max) params=%u, parasize=%u\n", numParam, j, info->parasize));

	mov	rax, QWORD PTR info$[rsp]
	mov	r9d, DWORD PTR [rax+32]
	mov	r8d, DWORD PTR j$1[rsp]
	mov	edx, DWORD PTR numParam$[rsp]
	lea	rcx, OFFSET FLAT:$SG12336
	call	DoDebugMsg1

; 2187 :         for ( ; j >= numParam; j-- )

	jmp	SHORT $LN9@InvokeDire
$LN7@InvokeDire:
	mov	eax, DWORD PTR j$1[rsp]
	dec	eax
	mov	DWORD PTR j$1[rsp], eax
$LN9@InvokeDire:
	mov	eax, DWORD PTR numParam$[rsp]
	cmp	DWORD PTR j$1[rsp], eax
	jl	SHORT $LN8@InvokeDire

; 2188 :             PushInvokeParam( i, tokenarray, proc, curr, j, &r0flags );

	lea	rax, QWORD PTR r0flags$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR j$1[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	PushInvokeParam
	jmp	SHORT $LN7@InvokeDire
$LN8@InvokeDire:

; 2189 :         /* move to first non-vararg parameter, if any */
; 2190 :         for ( curr = info->paralist; curr && curr->sym.is_vararg == TRUE; curr = curr->nextparam );

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN12@InvokeDire
$LN10@InvokeDire:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+120]
	mov	QWORD PTR curr$[rsp], rax
$LN12@InvokeDire:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN11@InvokeDire
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN11@InvokeDire
	jmp	SHORT $LN10@InvokeDire
$LN11@InvokeDire:
$LN63@InvokeDire:

; 2191 :     }
; 2192 :     
; 2193 :     /* the parameters are usually stored in "push" order.
; 2194 :      * This if() must match the one in proc.c, ParseParams().
; 2195 :      */
; 2196 : 
; 2197 :     if ( sym->langtype == LANG_STDCALL ||
; 2198 :         sym->langtype == LANG_C ||
; 2199 :         ( sym->langtype == LANG_FASTCALL && porder ) || 
; 2200 :         (sym->langtype == LANG_VECTORCALL  && porder) ||

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+84], 3
	je	SHORT $LN67@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+84], 1
	je	SHORT $LN67@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+84], 7
	jne	SHORT $LN68@InvokeDire
	cmp	DWORD PTR porder$[rsp], 0
	jne	SHORT $LN67@InvokeDire
$LN68@InvokeDire:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	SHORT $LN69@InvokeDire
	cmp	DWORD PTR porder$[rsp], 0
	jne	SHORT $LN67@InvokeDire
$LN69@InvokeDire:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+84], 2
	jne	$LN65@InvokeDire
$LN67@InvokeDire:

; 2201 :         sym->langtype == LANG_SYSCALL ) {
; 2202 :         for ( ; curr ; curr = curr->nextparam ) {

	jmp	SHORT $LN15@InvokeDire
$LN13@InvokeDire:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+120]
	mov	QWORD PTR curr$[rsp], rax
$LN15@InvokeDire:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN14@InvokeDire

; 2203 :             numParam--;

	mov	eax, DWORD PTR numParam$[rsp]
	dec	eax
	mov	DWORD PTR numParam$[rsp], eax

; 2204 :             if ( PushInvokeParam( i, tokenarray, proc, curr, numParam, &r0flags ) == ERROR ) {

	lea	rax, QWORD PTR r0flags$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR numParam$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	PushInvokeParam
	cmp	eax, -1
	jne	SHORT $LN70@InvokeDire

; 2205 :                 DebugMsg(("InvokeDir: PushInvokeParam(curr=%u, i=%u, numParam=%u) failed\n", curr, i, numParam));

	mov	r9d, DWORD PTR numParam$[rsp]
	mov	r8d, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR curr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12343
	call	DoDebugMsg

; 2206 :                 EmitErr( TOO_FEW_ARGUMENTS_TO_INVOKE, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 146				; 00000092H
	call	EmitErr
$LN70@InvokeDire:

; 2207 :             }
; 2208 :         }

	jmp	$LN13@InvokeDire
$LN14@InvokeDire:

; 2209 :     } else {

	jmp	$LN66@InvokeDire
$LN65@InvokeDire:

; 2210 :         for ( numParam = 0 ; curr && curr->sym.is_vararg == FALSE; curr = curr->nextparam, numParam++ ) {

	mov	DWORD PTR numParam$[rsp], 0
	jmp	SHORT $LN18@InvokeDire
$LN16@InvokeDire:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+120]
	mov	QWORD PTR curr$[rsp], rax
	mov	eax, DWORD PTR numParam$[rsp]
	inc	eax
	mov	DWORD PTR numParam$[rsp], eax
$LN18@InvokeDire:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN17@InvokeDire
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN17@InvokeDire

; 2211 :             if ( PushInvokeParam( i, tokenarray, proc, curr, numParam, &r0flags ) == ERROR ) {

	lea	rax, QWORD PTR r0flags$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR numParam$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	PushInvokeParam
	cmp	eax, -1
	jne	SHORT $LN71@InvokeDire

; 2212 :                 DebugMsg(("InvokeDir: PushInvokeParam(curr=%u, i=%u, numParam=%u) failed\n", curr, i, numParam));

	mov	r9d, DWORD PTR numParam$[rsp]
	mov	r8d, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR curr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12345
	call	DoDebugMsg

; 2213 :                 EmitErr( TOO_FEW_ARGUMENTS_TO_INVOKE, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 146				; 00000092H
	call	EmitErr
$LN71@InvokeDire:

; 2214 :             }
; 2215 :         }

	jmp	$LN16@InvokeDire
$LN17@InvokeDire:
$LN66@InvokeDire:

; 2216 :     }
; 2217 : 
; 2218 : 	/* -----------------------------------------------------------------------------------------------
; 2219 : 	HANDLE PARAMETERS (SECOND PASS FOR VECTORCALL)
; 2220 : 	----------------------------------------------------------------------------------------------- */
; 2221 : 	if (sym->langtype == LANG_VECTORCALL)

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	$LN72@InvokeDire

; 2222 : 	{
; 2223 : 		vcallpass = 1;

	mov	DWORD PTR vcallpass, 1

; 2224 :     info->vsize = 0;

	mov	rax, QWORD PTR info$[rsp]
	mov	DWORD PTR [rax+44], 0

; 2225 : 		curr = info->paralist;

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR curr$[rsp], rax

; 2226 : 		parmpos = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR parmpos$[rsp], eax

; 2227 : 
; 2228 : 		if (!(info->has_vararg)) {

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN73@InvokeDire

; 2229 : 			/* check if there is a superfluous parameter in the INVOKE call */
; 2230 : 			if (PushInvokeParam(i, tokenarray, proc, NULL, numParam, &r0flags) != ERROR) {

	lea	rax, QWORD PTR r0flags$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR numParam$[rsp]
	mov	DWORD PTR [rsp+32], eax
	xor	r9d, r9d
	mov	r8, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	PushInvokeParam
	cmp	eax, -1
	je	SHORT $LN75@InvokeDire

; 2231 : 				DebugMsg(("InvokeDir: superfluous argument, i=%u\n", i));

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG12350
	call	DoDebugMsg

; 2232 : 				return(EmitErr(TOO_MANY_ARGUMENTS_TO_INVOKE));

	mov	ecx, 177				; 000000b1H
	call	EmitErr
	jmp	$LN1@InvokeDire
$LN75@InvokeDire:

; 2233 : 			}
; 2234 : 		}

	jmp	$LN74@InvokeDire
$LN73@InvokeDire:

; 2235 : 		else {
; 2236 : 			int j = (Token_Count - i) / 2;

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR ModuleInfo+496
	sub	ecx, eax
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR j$2[rsp], eax

; 2237 : 			/* for VARARG procs, just push the additional params with
; 2238 : 			the VARARG descriptor
; 2239 : 			*/
; 2240 : 			numParam--;

	mov	eax, DWORD PTR numParam$[rsp]
	dec	eax
	mov	DWORD PTR numParam$[rsp], eax

; 2241 : 			size_vararg = 0; /* reset the VARARG parameter size count */

	mov	DWORD PTR size_vararg, 0
$LN19@InvokeDire:

; 2242 : 			while (curr && curr->sym.is_vararg == FALSE) curr = curr->nextparam;

	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN20@InvokeDire
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN20@InvokeDire
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+120]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN19@InvokeDire
$LN20@InvokeDire:

; 2243 : 			DebugMsg1(("InvokeDir: VARARG proc, numparams=%u, actual (max) params=%u, parasize=%u\n", numParam, j, info->parasize));

	mov	rax, QWORD PTR info$[rsp]
	mov	r9d, DWORD PTR [rax+32]
	mov	r8d, DWORD PTR j$2[rsp]
	mov	edx, DWORD PTR numParam$[rsp]
	lea	rcx, OFFSET FLAT:$SG12351
	call	DoDebugMsg1

; 2244 : 			for (; j >= numParam; j--)

	jmp	SHORT $LN23@InvokeDire
$LN21@InvokeDire:
	mov	eax, DWORD PTR j$2[rsp]
	dec	eax
	mov	DWORD PTR j$2[rsp], eax
$LN23@InvokeDire:
	mov	eax, DWORD PTR numParam$[rsp]
	cmp	DWORD PTR j$2[rsp], eax
	jl	SHORT $LN22@InvokeDire

; 2245 : 				PushInvokeParam(i, tokenarray, proc, curr, j, &r0flags);

	lea	rax, QWORD PTR r0flags$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR j$2[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	PushInvokeParam
	jmp	SHORT $LN21@InvokeDire
$LN22@InvokeDire:

; 2246 : 			/* move to first non-vararg parameter, if any */
; 2247 : 			for (curr = info->paralist; curr && curr->sym.is_vararg == TRUE; curr = curr->nextparam);

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN26@InvokeDire
$LN24@InvokeDire:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+120]
	mov	QWORD PTR curr$[rsp], rax
$LN26@InvokeDire:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN25@InvokeDire
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN25@InvokeDire
	jmp	SHORT $LN24@InvokeDire
$LN25@InvokeDire:
$LN74@InvokeDire:

; 2248 : 		}
; 2249 : 
; 2250 : 		/* the parameters are usually stored in "push" order.
; 2251 : 		* This if() must match the one in proc.c, ParseParams().
; 2252 : 		*/
; 2253 : 
; 2254 : 		if (sym->langtype == LANG_STDCALL ||
; 2255 : 			sym->langtype == LANG_C ||
; 2256 : 			(sym->langtype == LANG_FASTCALL && porder) ||
; 2257 : 			(sym->langtype == LANG_VECTORCALL  && porder) ||

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+84], 3
	je	SHORT $LN78@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+84], 1
	je	SHORT $LN78@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+84], 7
	jne	SHORT $LN79@InvokeDire
	cmp	DWORD PTR porder$[rsp], 0
	jne	SHORT $LN78@InvokeDire
$LN79@InvokeDire:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	SHORT $LN80@InvokeDire
	cmp	DWORD PTR porder$[rsp], 0
	jne	SHORT $LN78@InvokeDire
$LN80@InvokeDire:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+84], 2
	jne	$LN76@InvokeDire
$LN78@InvokeDire:

; 2258 : 			sym->langtype == LANG_SYSCALL) {
; 2259 : 			for (; curr; curr = curr->nextparam) {

	jmp	SHORT $LN29@InvokeDire
$LN27@InvokeDire:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+120]
	mov	QWORD PTR curr$[rsp], rax
$LN29@InvokeDire:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN28@InvokeDire

; 2260 : 				numParam--;

	mov	eax, DWORD PTR numParam$[rsp]
	dec	eax
	mov	DWORD PTR numParam$[rsp], eax

; 2261 : 				if (PushInvokeParam(i, tokenarray, proc, curr, numParam, &r0flags) == ERROR) {

	lea	rax, QWORD PTR r0flags$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR numParam$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	PushInvokeParam
	cmp	eax, -1
	jne	SHORT $LN81@InvokeDire

; 2262 : 					DebugMsg(("InvokeDir: PushInvokeParam(curr=%u, i=%u, numParam=%u) failed\n", curr, i, numParam));

	mov	r9d, DWORD PTR numParam$[rsp]
	mov	r8d, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR curr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12358
	call	DoDebugMsg

; 2263 : 					EmitErr(TOO_FEW_ARGUMENTS_TO_INVOKE, sym->name);

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 146				; 00000092H
	call	EmitErr
$LN81@InvokeDire:

; 2264 : 				}
; 2265 : 			}

	jmp	$LN27@InvokeDire
$LN28@InvokeDire:

; 2266 : 		}

	jmp	$LN77@InvokeDire
$LN76@InvokeDire:

; 2267 : 		else {
; 2268 : 			for (numParam = 0; curr && curr->sym.is_vararg == FALSE; curr = curr->nextparam, numParam++) {

	mov	DWORD PTR numParam$[rsp], 0
	jmp	SHORT $LN32@InvokeDire
$LN30@InvokeDire:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+120]
	mov	QWORD PTR curr$[rsp], rax
	mov	eax, DWORD PTR numParam$[rsp]
	inc	eax
	mov	DWORD PTR numParam$[rsp], eax
$LN32@InvokeDire:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN31@InvokeDire
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN31@InvokeDire

; 2269 : 				if (PushInvokeParam(i, tokenarray, proc, curr, numParam, &r0flags) == ERROR) {

	lea	rax, QWORD PTR r0flags$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR numParam$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	PushInvokeParam
	cmp	eax, -1
	jne	SHORT $LN82@InvokeDire

; 2270 : 					DebugMsg(("InvokeDir: PushInvokeParam(curr=%u, i=%u, numParam=%u) failed\n", curr, i, numParam));

	mov	r9d, DWORD PTR numParam$[rsp]
	mov	r8d, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR curr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12360
	call	DoDebugMsg

; 2271 : 					EmitErr(TOO_FEW_ARGUMENTS_TO_INVOKE, sym->name);

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 146				; 00000092H
	call	EmitErr
$LN82@InvokeDire:

; 2272 : 				}
; 2273 : 			}

	jmp	$LN30@InvokeDire
$LN31@InvokeDire:
$LN77@InvokeDire:
$LN72@InvokeDire:

; 2274 : 		}
; 2275 : 	}
; 2276 : 	vcallpass = 0;

	mov	DWORD PTR vcallpass, 0

; 2277 : 
; 2278 : #if 1
; 2279 :     /* v2.05 added. A warning only, because Masm accepts this. */
; 2280 :     if ( opnd.base_reg != NULL &&
; 2281 :         Parse_Pass == PASS_1 &&
; 2282 :         (r0flags & R0_USED ) &&

	cmp	QWORD PTR opnd$[rsp+24], 0
	je	SHORT $LN83@InvokeDire
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN83@InvokeDire
	movzx	eax, BYTE PTR r0flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN83@InvokeDire
	mov	rax, QWORD PTR opnd$[rsp+24]
	movzx	eax, BYTE PTR [rax+1]
	test	eax, eax
	jne	SHORT $LN83@InvokeDire

; 2283 :         opnd.base_reg->bytval == 0 )
; 2284 :         EmitWarn( 2, REGISTER_VALUE_OVERWRITTEN_BY_INVOKE );

	mov	edx, 165				; 000000a5H
	mov	ecx, 2
	call	EmitWarn
$LN83@InvokeDire:

; 2285 : #endif
; 2286 :     p = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR p$[rsp], rax

; 2287 :     strcpy( p, " call " );

	lea	rdx, OFFSET FLAT:$SG12362
	mov	rcx, QWORD PTR p$[rsp]
	call	strcpy

; 2288 :     p += 6;

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 6
	mov	QWORD PTR p$[rsp], rax

; 2289 :     /* v2.09: 'uselabel' obsolete */
; 2290 :     //if ( uselabel ) {
; 2291 :     //    DebugMsg1(("InvokeDir: opnd.label_tok is used: %s\n", opnd.label_tok->string_ptr ));
; 2292 :     //    strcpy( p, opnd.label_tok->string_ptr );
; 2293 :     //} else {
; 2294 : #if DLLIMPORT
; 2295 :         if ( sym->state == SYM_EXTERNAL && sym->dll ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 2
	jne	$LN84@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+64], 0
	je	$LN84@InvokeDire

; 2296 :             char *iatname = p;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR iatname$3[rsp], rax

; 2297 :             strcpy( p, ModuleInfo.g.imp_prefix );

	mov	rdx, QWORD PTR ModuleInfo+88
	mov	rcx, QWORD PTR p$[rsp]
	call	strcpy

; 2298 :             p += strlen( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 2299 :             p += Mangle( sym, p );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	Mangle
	cdqe
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 2300 :             namepos++;

	mov	eax, DWORD PTR namepos$[rsp]
	inc	eax
	mov	DWORD PTR namepos$[rsp], eax

; 2301 :             if ( sym->iat_used == FALSE ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	$LN85@InvokeDire

; 2302 :                 sym->iat_used = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	or	al, 8
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+48], al

; 2303 :                 sym->dll->cnt++;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	mov	DWORD PTR [rcx+8], eax

; 2304 :                 if ( sym->langtype != LANG_NONE && sym->langtype != ModuleInfo.langtype )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+84], 0
	je	SHORT $LN86@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR ModuleInfo+364
	cmp	DWORD PTR [rax+84], ecx
	je	SHORT $LN86@InvokeDire

; 2305 :                     AddLineQueueX( " externdef %r %s: %r %r", sym->langtype + T_C - 1, iatname, T_PTR, T_PROC );

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+84]
	add	eax, 263				; 00000107H
	mov	DWORD PTR [rsp+32], 433			; 000001b1H
	mov	r9d, 258				; 00000102H
	mov	r8, QWORD PTR iatname$3[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12367
	call	AddLineQueueX
	jmp	SHORT $LN87@InvokeDire
$LN86@InvokeDire:

; 2306 :                 else
; 2307 :                     AddLineQueueX( " externdef %s: %r %r", iatname, T_PTR, T_PROC );

	mov	r9d, 433				; 000001b1H
	mov	r8d, 258				; 00000102H
	mov	rdx, QWORD PTR iatname$3[rsp]
	lea	rcx, OFFSET FLAT:$SG12368
	call	AddLineQueueX
$LN87@InvokeDire:
$LN85@InvokeDire:
$LN84@InvokeDire:

; 2308 :             }
; 2309 :         }
; 2310 : #endif
; 2311 :         size = tokenarray[parmpos].tokpos - tokenarray[namepos].tokpos;

	movsxd	rax, DWORD PTR parmpos$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR namepos$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR size$[rsp], eax

; 2312 :         memcpy( p, tokenarray[namepos].tokpos, size );

	movsxd	rax, DWORD PTR size$[rsp]
	movsxd	rcx, DWORD PTR namepos$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+24]
	mov	rcx, QWORD PTR p$[rsp]
	call	memcpy

; 2313 :         *(p+size) = NULLC;

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 2314 : #if 0  /* v2.09: uselabel obsolete */
; 2315 :     }
; 2316 : #endif
; 2317 :     AddLineQueue( StringBufferEnd );

	mov	rcx, QWORD PTR ModuleInfo+488
	call	AddLineQueue

; 2318 : 
; 2319 :     if (( sym->langtype == LANG_C || sym->langtype == LANG_SYSCALL ) &&

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+84], 1
	je	SHORT $LN90@InvokeDire
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+84], 2
	jne	$LN88@InvokeDire
$LN90@InvokeDire:
	mov	rax, QWORD PTR info$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN91@InvokeDire
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN88@InvokeDire
	cmp	DWORD PTR size_vararg, 0
	je	$LN88@InvokeDire
$LN91@InvokeDire:

; 2320 :         ( info->parasize || ( info->has_vararg && size_vararg ) )) {
; 2321 :         if ( info->has_vararg ) {

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN92@InvokeDire

; 2322 :             DebugMsg1(("InvokeDir: size of fix args=%u, var args=%u\n", info->parasize, size_vararg));

	mov	r8d, DWORD PTR size_vararg
	mov	rax, QWORD PTR info$[rsp]
	mov	edx, DWORD PTR [rax+32]
	lea	rcx, OFFSET FLAT:$SG12375
	call	DoDebugMsg1

; 2323 :             AddLineQueueX( " add %r, %u", stackreg[ModuleInfo.Ofssize], NUMQUAL info->parasize + size_vararg );

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+32]
	add	eax, DWORD PTR size_vararg
	movzx	ecx, BYTE PTR ModuleInfo+404
	lea	rdx, OFFSET FLAT:stackreg
	mov	r8d, eax
	mov	edx, DWORD PTR [rdx+rcx*4]
	lea	rcx, OFFSET FLAT:$SG12376
	call	AddLineQueueX

; 2324 :         } else

	jmp	SHORT $LN93@InvokeDire
$LN92@InvokeDire:

; 2325 :             AddLineQueueX( " add %r, %u", stackreg[ModuleInfo.Ofssize], NUMQUAL info->parasize );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	mov	rdx, QWORD PTR info$[rsp]
	mov	r8d, DWORD PTR [rdx+32]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12377
	call	AddLineQueueX
$LN93@InvokeDire:

; 2326 :     } 

	jmp	$LN89@InvokeDire
$LN88@InvokeDire:

; 2327 :     else if ( sym->langtype == LANG_FASTCALL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+84], 7
	jne	SHORT $LN94@InvokeDire

; 2328 :         fastcall_tab[ModuleInfo.fctype].invokeend( proc, numParam, value );

	movsxd	rax, DWORD PTR ModuleInfo+376
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:fastcall_tab
	mov	QWORD PTR tv744[rsp], rcx
	mov	r8d, DWORD PTR value$[rsp]
	mov	edx, DWORD PTR numParam$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	r9, QWORD PTR tv744[rsp]
	call	QWORD PTR [r9+rax+8]

; 2329 :     }

	jmp	SHORT $LN95@InvokeDire
$LN94@InvokeDire:

; 2330 :     else if ( sym->langtype == LANG_VECTORCALL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	SHORT $LN96@InvokeDire

; 2331 :         vectorcall_tab[ModuleInfo.fctype].invokeend( proc, numParam, value );

	movsxd	rax, DWORD PTR ModuleInfo+376
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:vectorcall_tab
	mov	QWORD PTR tv745[rsp], rcx
	mov	r8d, DWORD PTR value$[rsp]
	mov	edx, DWORD PTR numParam$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	r9, QWORD PTR tv745[rsp]
	call	QWORD PTR [r9+rax+8]
$LN96@InvokeDire:
$LN95@InvokeDire:
$LN89@InvokeDire:

; 2332 :     }
; 2333 : 
; 2334 :     LstWrite( LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL );

	call	GetCurrOffset
	xor	r8d, r8d
	mov	edx, eax
	mov	ecx, 4
	call	LstWrite

; 2335 : 
; 2336 :     RunLineQueue();

	call	RunLineQueue

; 2337 : 
; 2338 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@InvokeDire:

; 2339 : }

	add	rsp, 376				; 00000178H
	ret	0
InvokeDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\invoke.c
_TEXT	SEGMENT
asize$ = 64
psize$ = 68
Ofssize$ = 72
addr$ = 73
reg$1 = 76
pushsize$ = 80
j$ = 84
sreg$2 = 88
dw$3 = 92
fptrsize$ = 96
asize2$4 = 100
tv771 = 104
tv1238 = 108
qual$5 = 112
currParm$ = 116
optype$6 = 120
opnd$ = 128
instr$7 = 240
tv710 = 248
tv714 = 252
tv1117 = 256
tv1191 = 260
tv193 = 264
tv427 = 268
reg$ = 272
tv1653 = 276
tv1710 = 280
tv1423 = 284
suffix$8 = 288
tv1457 = 296
tv68 = 304
$T9 = 312
tv830 = 320
tv891 = 328
tv1112 = 336
tv1322 = 344
tv1323 = 352
tv1327 = 360
tv1330 = 368
fullparam$ = 384
buffer$ = 1408
__$ArrayPad$ = 2432
i$ = 2464
tokenarray$ = 2472
proc$ = 2480
curr$ = 2488
reqParam$ = 2496
r0flags$ = 2504
PushInvokeParam PROC

; 1292 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 2456				; 00000998H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1293 :     int currParm;
; 1294 :     int psize;
; 1295 :     int asize;
; 1296 :     int pushsize;
; 1297 :     int j;
; 1298 :     int fptrsize;
; 1299 :     char Ofssize;
; 1300 :     bool addr = FALSE; /* ADDR operator found */

	mov	BYTE PTR addr$[rsp], 0

; 1301 :     struct expr opnd;
; 1302 :     char fullparam[MAX_LINE_LEN];
; 1303 :     char buffer[MAX_LINE_LEN];
; 1304 :     int reg;
; 1305 :     DebugMsg1(("PushInvokeParam(%s, param=%s:%u, i=%u ) enter\n", proc->sym.name, curr ? curr->sym.name : "NULL", reqParam, i ));

	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN253@PushInvoke
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv68[rsp], rax
	jmp	SHORT $LN254@PushInvoke
$LN253@PushInvoke:
	lea	rax, OFFSET FLAT:$SG11872
	mov	QWORD PTR tv68[rsp], rax
$LN254@PushInvoke:
	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR reqParam$[rsp]
	mov	r8, QWORD PTR tv68[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11873
	call	DoDebugMsg1

; 1306 :    //__debugbreak();
; 1307 :     for ( currParm = 0; currParm <= reqParam; ) {

	mov	DWORD PTR currParm$[rsp], 0
$LN2@PushInvoke:
	mov	eax, DWORD PTR reqParam$[rsp]
	cmp	DWORD PTR currParm$[rsp], eax
	jg	$LN3@PushInvoke

; 1308 :         if ( tokenarray[i].token == T_FINAL ) { /* this is no real error! */

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN16@PushInvoke

; 1309 :             DebugMsg1(("PushInvokeParam(%s): T_FINAL token, i=%u\n", proc->sym.name, i));

	mov	r8d, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11875
	call	DoDebugMsg1

; 1310 :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@PushInvoke
$LN16@PushInvoke:

; 1311 :         }
; 1312 :         if ( tokenarray[i].token == T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN17@PushInvoke

; 1313 :             currParm++;

	mov	eax, DWORD PTR currParm$[rsp]
	inc	eax
	mov	DWORD PTR currParm$[rsp], eax
$LN17@PushInvoke:

; 1314 :         }
; 1315 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1316 :     }

	jmp	$LN2@PushInvoke
$LN3@PushInvoke:

; 1317 :     /* if curr is NULL this call is just a parameter check */
; 1318 :     if ( !curr ) return( NOT_ERROR );

	cmp	QWORD PTR curr$[rsp], 0
	jne	SHORT $LN18@PushInvoke
	xor	eax, eax
	jmp	$LN1@PushInvoke
$LN18@PushInvoke:

; 1319 : 
; 1320 : #if 1 /* v2.05 */
; 1321 :     psize = curr->sym.total_size;

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR psize$[rsp], eax

; 1322 :     DebugMsg1(("PushInvokeParam(%s,%u): pmtype=%Xh, psize=%u\n", proc->sym.name, reqParam, curr->sym.mem_type, psize ));

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR curr$[rsp]
	mov	r9d, DWORD PTR [rax+44]
	mov	r8d, DWORD PTR reqParam$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11878
	call	DoDebugMsg1

; 1323 : #else
; 1324 :     /* set psize (size of parameter) */
; 1325 :     if ( curr->is_ptr ) {
; 1326 :         psize = 2 << curr->sym.Ofssize;
; 1327 :         if ( curr->sym.isfar )
; 1328 :             psize += 2;
; 1329 :     } else
; 1330 :         psize = SizeFromMemtype( curr->sym.mem_type, curr->sym.Ofssize, curr->sym.type );
; 1331 :     DebugMsg1(("PushInvokeParam(%s,%u): is_ptr=%u, pmtype=%Xh, psize=%u\n", proc->sym.name, reqParam, curr->is_ptr, curr->sym.mem_type, psize ));
; 1332 : #endif
; 1333 : 
; 1334 :     /* ADDR: the argument's address is to be pushed? */
; 1335 :     if ( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_ADDR ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 7
	jne	SHORT $LN19@PushInvoke
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 260		; 00000104H
	jne	SHORT $LN19@PushInvoke

; 1336 :         addr = TRUE;

	mov	BYTE PTR addr$[rsp], 1

; 1337 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN19@PushInvoke:

; 1338 :     }
; 1339 : 
; 1340 :     /* copy the parameter tokens to fullparam */
; 1341 :     for ( j = i; tokenarray[j].token != T_COMMA && tokenarray[j].token != T_FINAL; j++ );

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR j$[rsp], eax
	jmp	SHORT $LN7@PushInvoke
$LN5@PushInvoke:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN7@PushInvoke:
	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN6@PushInvoke
	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN6@PushInvoke
	jmp	SHORT $LN5@PushInvoke
$LN6@PushInvoke:

; 1342 :     memcpy( fullparam, tokenarray[i].tokpos, tokenarray[j].tokpos - tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+24]
	lea	rcx, QWORD PTR fullparam$[rsp]
	call	memcpy

; 1343 :     fullparam[tokenarray[j].tokpos - tokenarray[i].tokpos] = NULLC;

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	QWORD PTR $T9[rsp], rax
	cmp	QWORD PTR $T9[rsp], 1024		; 00000400H
	jae	SHORT $LN255@PushInvoke
	jmp	SHORT $LN256@PushInvoke
$LN255@PushInvoke:
	call	__report_rangecheckfailure
$LN256@PushInvoke:
	mov	rax, QWORD PTR $T9[rsp]
	mov	BYTE PTR fullparam$[rsp+rax], 0

; 1344 : 
; 1345 :     j = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR j$[rsp], eax

; 1346 :     /* v2.11: GetSymOfssize() doesn't work for state SYM_TYPE */
; 1347 :     //fptrsize = 2 + ( 2 << GetSymOfssize( &proc->sym ) );
; 1348 :     Ofssize = ( proc->sym.state == SYM_TYPE ? proc->sym.seg_ofssize : GetSymOfssize( &proc->sym ) );

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+40], 7
	jne	SHORT $LN257@PushInvoke
	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	and	al, 3
	movzx	eax, al
	mov	DWORD PTR tv193[rsp], eax
	jmp	SHORT $LN258@PushInvoke
$LN257@PushInvoke:
	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, rax
	call	GetSymOfssize
	mov	DWORD PTR tv193[rsp], eax
$LN258@PushInvoke:
	movzx	eax, BYTE PTR tv193[rsp]
	mov	BYTE PTR Ofssize$[rsp], al

; 1349 :     fptrsize = 2 + ( 2 << Ofssize );

	movsx	eax, BYTE PTR Ofssize$[rsp]
	mov	ecx, 2
	mov	DWORD PTR tv1423[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv1423[rsp]
	shl	eax, cl
	add	eax, 2
	mov	DWORD PTR fptrsize$[rsp], eax

; 1350 : 
; 1351 :     if ( addr ) {

	movzx	eax, BYTE PTR addr$[rsp]
	test	eax, eax
	je	$LN20@PushInvoke

; 1352 :         /* v2.06: don't handle forward refs if -Zne is set */
; 1353 :         //if ( EvalOperand( &j, Token_Count, &opnd, 0 ) == ERROR )
; 1354 :         if ( EvalOperand( &j, tokenarray, Token_Count, &opnd, ModuleInfo.invoke_exprparm ) == ERROR )

	movzx	eax, BYTE PTR ModuleInfo+426
	mov	BYTE PTR [rsp+32], al
	lea	r9, QWORD PTR opnd$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR j$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN22@PushInvoke

; 1355 :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@PushInvoke
$LN22@PushInvoke:

; 1356 :         /* DWORD (16bit) and FWORD(32bit) are treated like FAR ptrs
; 1357 :          * v2.11: argument may be a FAR32 pointer ( psize == 6 ), while
; 1358 :          * fptrsize may be just 4!
; 1359 :          */
; 1360 :         //if ( psize > fptrsize ) {
; 1361 :         if ( psize > fptrsize && fptrsize > 4 ) {

	mov	eax, DWORD PTR fptrsize$[rsp]
	cmp	DWORD PTR psize$[rsp], eax
	jle	SHORT $LN23@PushInvoke
	cmp	DWORD PTR fptrsize$[rsp], 4
	jle	SHORT $LN23@PushInvoke

; 1362 :             /* QWORD is NOT accepted as a FAR ptr */
; 1363 :             DebugMsg1(("PushInvokeParm(%u): error, psize=%u, fptrsize=%u\n", reqParam, psize, fptrsize));

	mov	r9d, DWORD PTR fptrsize$[rsp]
	mov	r8d, DWORD PTR psize$[rsp]
	mov	edx, DWORD PTR reqParam$[rsp]
	lea	rcx, OFFSET FLAT:$SG11884
	call	DoDebugMsg1

; 1364 :             EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	mov	eax, DWORD PTR reqParam$[rsp]
	inc	eax
	mov	edx, eax
	mov	ecx, 145				; 00000091H
	call	EmitErr

; 1365 :             return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@PushInvoke
$LN23@PushInvoke:

; 1366 :         }
; 1367 : 
; 1368 :         if (proc->sym.langtype == LANG_FASTCALL){

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 7
	jne	SHORT $LN24@PushInvoke

; 1369 :           if (fastcall_tab[ModuleInfo.fctype].handleparam(proc, reqParam, curr, addr, &opnd, fullparam, r0flags))

	movsxd	rax, DWORD PTR ModuleInfo+376
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:fastcall_tab
	mov	QWORD PTR tv1322[rsp], rcx
	mov	rdx, QWORD PTR r0flags$[rsp]
	mov	QWORD PTR [rsp+48], rdx
	lea	rdx, QWORD PTR fullparam$[rsp]
	mov	QWORD PTR [rsp+40], rdx
	lea	rdx, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rsp+32], rdx
	movzx	r9d, BYTE PTR addr$[rsp]
	mov	r8, QWORD PTR curr$[rsp]
	mov	edx, DWORD PTR reqParam$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	r10, QWORD PTR tv1322[rsp]
	call	QWORD PTR [r10+rax+16]
	test	eax, eax
	je	SHORT $LN26@PushInvoke

; 1370 :             return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@PushInvoke
$LN26@PushInvoke:

; 1371 :         }

	jmp	$LN25@PushInvoke
$LN24@PushInvoke:

; 1372 :         else if (proc->sym.langtype == LANG_VECTORCALL){

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	SHORT $LN27@PushInvoke

; 1373 :             if ( vectorcall_tab[ModuleInfo.fctype].handleparam( proc, reqParam, curr, addr, &opnd, fullparam, r0flags ) )

	movsxd	rax, DWORD PTR ModuleInfo+376
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:vectorcall_tab
	mov	QWORD PTR tv1323[rsp], rcx
	mov	rdx, QWORD PTR r0flags$[rsp]
	mov	QWORD PTR [rsp+48], rdx
	lea	rdx, QWORD PTR fullparam$[rsp]
	mov	QWORD PTR [rsp+40], rdx
	lea	rdx, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rsp+32], rdx
	movzx	r9d, BYTE PTR addr$[rsp]
	mov	r8, QWORD PTR curr$[rsp]
	mov	edx, DWORD PTR reqParam$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	r10, QWORD PTR tv1323[rsp]
	call	QWORD PTR [r10+rax+16]
	test	eax, eax
	je	SHORT $LN28@PushInvoke

; 1374 :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@PushInvoke
$LN28@PushInvoke:
$LN27@PushInvoke:
$LN25@PushInvoke:

; 1375 :         }
; 1376 :         if ( opnd.kind == EXPR_REG || opnd.indirect ) {

	cmp	DWORD PTR opnd$[rsp+60], 2
	je	SHORT $LN31@PushInvoke
	mov	eax, DWORD PTR opnd$[rsp+72]
	and	eax, 1
	test	eax, eax
	je	$LN29@PushInvoke
$LN31@PushInvoke:

; 1377 :             if ( curr->sym.isfar || psize == fptrsize ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN33@PushInvoke
	mov	eax, DWORD PTR fptrsize$[rsp]
	cmp	DWORD PTR psize$[rsp], eax
	jne	$LN32@PushInvoke
$LN33@PushInvoke:

; 1378 :                 DebugMsg1(("PushInvokeParam: far ptr, %s isfar=%u, psize=%u, fptrsize=%u\n", curr->sym.name, curr->sym.isfar, psize, fptrsize ));

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	mov	ecx, DWORD PTR fptrsize$[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR psize$[rsp]
	mov	r8d, eax
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11895
	call	DoDebugMsg1

; 1379 :                 if ( opnd.sym && opnd.sym->state == SYM_STACK )

	cmp	QWORD PTR opnd$[rsp+80], 0
	je	SHORT $LN34@PushInvoke
	mov	rax, QWORD PTR opnd$[rsp+80]
	cmp	DWORD PTR [rax+40], 5
	jne	SHORT $LN34@PushInvoke

; 1380 :                     GetResWName( T_SS, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	ecx, 27
	call	GetResWName
	jmp	SHORT $LN35@PushInvoke
$LN34@PushInvoke:

; 1381 :                 else if ( opnd.override != NULL )

	cmp	QWORD PTR opnd$[rsp+48], 0
	je	SHORT $LN36@PushInvoke

; 1382 :                     strcpy( buffer, opnd.override->string_ptr );

	mov	rax, QWORD PTR opnd$[rsp+48]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	strcpy
	jmp	SHORT $LN37@PushInvoke
$LN36@PushInvoke:

; 1383 :                 else
; 1384 :                     GetResWName( T_DS, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	ecx, 28
	call	GetResWName
$LN37@PushInvoke:
$LN35@PushInvoke:

; 1385 :                 AddLineQueueX( " push %s", buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, OFFSET FLAT:$SG11900
	call	AddLineQueueX
$LN32@PushInvoke:

; 1386 :             }
; 1387 :             AddLineQueueX( " lea %r, %s", regax[ModuleInfo.Ofssize], fullparam );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:regax
	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG11901
	call	AddLineQueueX

; 1388 :             *r0flags |= R0_USED;

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al

; 1389 :             AddLineQueueX( " push %r", regax[ModuleInfo.Ofssize] );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:regax
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG11902
	call	AddLineQueueX

; 1390 :         } else {

	jmp	$LN30@PushInvoke
$LN29@PushInvoke:
$push_address$273:

; 1391 :         push_address:
; 1392 : 
; 1393 :             /* push segment part of address?
; 1394 :              * v2.11: do not assume a far pointer if psize == fptrsize
; 1395 :              * ( parameter might be near32 in a 16-bit environment )
; 1396 :              */
; 1397 :             //if ( curr->sym.isfar || psize == fptrsize ) {
; 1398 :             if ( curr->sym.isfar || psize > ( 2 << curr->sym.Ofssize ) ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN39@PushInvoke
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+52]
	mov	ecx, 2
	mov	DWORD PTR tv1457[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv1457[rsp]
	shl	eax, cl
	cmp	DWORD PTR psize$[rsp], eax
	jle	$LN38@PushInvoke
$LN39@PushInvoke:

; 1399 : 
; 1400 :                 short sreg;
; 1401 :                 sreg = GetSegmentPart( &opnd, buffer, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR opnd$[rsp]
	call	GetSegmentPart
	mov	WORD PTR sreg$2[rsp], ax

; 1402 :                 if ( sreg ) {

	movsx	eax, WORD PTR sreg$2[rsp]
	test	eax, eax
	je	SHORT $LN40@PushInvoke

; 1403 :                     /* v2.11: push segment part as WORD or DWORD depending on target's offset size
; 1404 :                      * problem: "pushw ds" is not accepted, so just emit a size prefix.
; 1405 :                      */
; 1406 :                     if ( Ofssize != ModuleInfo.Ofssize || ( curr->sym.Ofssize == USE16 && CurrWordSize > 2 ) )

	movsx	eax, BYTE PTR Ofssize$[rsp]
	movzx	ecx, BYTE PTR ModuleInfo+404
	cmp	eax, ecx
	jne	SHORT $LN43@PushInvoke
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+52]
	test	eax, eax
	jne	SHORT $LN42@PushInvoke
	movzx	eax, BYTE PTR ModuleInfo+406
	cmp	eax, 2
	jle	SHORT $LN42@PushInvoke
$LN43@PushInvoke:

; 1407 :                         AddLineQueue( " db 66h" );

	lea	rcx, OFFSET FLAT:$SG11909
	call	AddLineQueue
$LN42@PushInvoke:

; 1408 :                     AddLineQueueX( " push %r", sreg );

	movsx	eax, WORD PTR sreg$2[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11910
	call	AddLineQueueX

; 1409 :                 } else

	jmp	SHORT $LN41@PushInvoke
$LN40@PushInvoke:

; 1410 :                     AddLineQueueX( " push %s", buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, OFFSET FLAT:$SG11911
	call	AddLineQueueX
$LN41@PushInvoke:
$LN38@PushInvoke:

; 1411 :             }
; 1412 :             /* push offset part of address */
; 1413 :             if ( (ModuleInfo.curr_cpu & P_CPU_MASK ) < P_186 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 16
	jge	SHORT $LN44@PushInvoke

; 1414 :                 AddLineQueueX( " mov %r, offset %s", T_AX, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG11914
	call	AddLineQueueX

; 1415 :                 AddLineQueueX( " push %r", T_AX );

	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG11915
	call	AddLineQueueX

; 1416 :                 *r0flags |= R0_USED;

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al

; 1417 :             } else {

	jmp	$LN45@PushInvoke
$LN44@PushInvoke:

; 1418 :                 if ( curr->sym.is_vararg && opnd.Ofssize == USE_EMPTY && opnd.sym )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN46@PushInvoke
	movzx	eax, BYTE PTR opnd$[rsp+69]
	cmp	eax, 254				; 000000feH
	jne	SHORT $LN46@PushInvoke
	cmp	QWORD PTR opnd$[rsp+80], 0
	je	SHORT $LN46@PushInvoke

; 1419 :                     opnd.Ofssize = GetSymOfssize( opnd.sym );

	mov	rcx, QWORD PTR opnd$[rsp+80]
	call	GetSymOfssize
	mov	BYTE PTR opnd$[rsp+69], al
$LN46@PushInvoke:

; 1420 :                 /* v2.04: expand 16-bit offset to 32
; 1421 :                  * v2.11: also expand if there's an explicit near32 ptr requested in 16-bit
; 1422 :                  */
; 1423 :                 //if ( opnd.Ofssize == USE16 && CurrWordSize > 2 ) {
; 1424 :                 if ( ( opnd.Ofssize == USE16 && CurrWordSize > 2 ) ||

	movzx	eax, BYTE PTR opnd$[rsp+69]
	test	eax, eax
	jne	SHORT $LN50@PushInvoke
	movzx	eax, BYTE PTR ModuleInfo+406
	cmp	eax, 2
	jg	SHORT $LN49@PushInvoke
$LN50@PushInvoke:
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+52]
	cmp	eax, 1
	jne	SHORT $LN47@PushInvoke
	movzx	eax, BYTE PTR ModuleInfo+406
	cmp	eax, 2
	jne	SHORT $LN47@PushInvoke
$LN49@PushInvoke:

; 1425 :                     ( curr->sym.Ofssize == USE32 && CurrWordSize == 2 ) ) {
; 1426 :                     AddLineQueueX( " pushd %r %s", T_OFFSET, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 241				; 000000f1H
	lea	rcx, OFFSET FLAT:$SG11921
	call	AddLineQueueX
	jmp	$LN48@PushInvoke
$LN47@PushInvoke:

; 1427 :                 } else if ( CurrWordSize > 2 && curr->sym.Ofssize == USE16 &&

	movzx	eax, BYTE PTR ModuleInfo+406
	cmp	eax, 2
	jle	SHORT $LN51@PushInvoke
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+52]
	test	eax, eax
	jne	SHORT $LN51@PushInvoke
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN53@PushInvoke
	movsx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	jne	SHORT $LN51@PushInvoke
$LN53@PushInvoke:

; 1428 :                            ( curr->sym.isfar || Ofssize == USE16 ) ) { /* v2.11: added */
; 1429 :                     AddLineQueueX( " pushw %r %s", T_OFFSET, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 241				; 000000f1H
	lea	rcx, OFFSET FLAT:$SG11925
	call	AddLineQueueX

; 1430 :                 } else {

	jmp	SHORT $LN52@PushInvoke
$LN51@PushInvoke:

; 1431 :                     AddLineQueueX( " push %r %s", T_OFFSET, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 241				; 000000f1H
	lea	rcx, OFFSET FLAT:$SG11926
	call	AddLineQueueX

; 1432 :                     /* v2.04: a 32bit offset pushed in 16-bit code */
; 1433 :                     if ( curr->sym.is_vararg && CurrWordSize == 2 && opnd.Ofssize > USE16 ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN54@PushInvoke
	movzx	eax, BYTE PTR ModuleInfo+406
	cmp	eax, 2
	jne	SHORT $LN54@PushInvoke
	movzx	eax, BYTE PTR opnd$[rsp+69]
	test	eax, eax
	jle	SHORT $LN54@PushInvoke

; 1434 :                         size_vararg += CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	ecx, DWORD PTR size_vararg
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR size_vararg, eax
$LN54@PushInvoke:
$LN52@PushInvoke:
$LN48@PushInvoke:
$LN45@PushInvoke:
$LN30@PushInvoke:

; 1435 :                     }
; 1436 :                 }
; 1437 :             }
; 1438 :         }
; 1439 :         if ( curr->sym.is_vararg ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN55@PushInvoke

; 1440 :             size_vararg += CurrWordSize + ( curr->sym.isfar ? CurrWordSize : 0 );

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN259@PushInvoke
	movzx	eax, BYTE PTR ModuleInfo+406
	mov	DWORD PTR tv427[rsp], eax
	jmp	SHORT $LN260@PushInvoke
$LN259@PushInvoke:
	mov	DWORD PTR tv427[rsp], 0
$LN260@PushInvoke:
	movzx	eax, BYTE PTR ModuleInfo+406
	add	eax, DWORD PTR tv427[rsp]
	mov	ecx, DWORD PTR size_vararg
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR size_vararg, eax

; 1441 :             DebugMsg1(("PushInvokeParm(%u): new value of size_vararg=%u [CurrWordSize=%u]\n", reqParam, size_vararg, CurrWordSize ));

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	r9d, eax
	mov	r8d, DWORD PTR size_vararg
	mov	edx, DWORD PTR reqParam$[rsp]
	lea	rcx, OFFSET FLAT:$SG11929
	call	DoDebugMsg1
$LN55@PushInvoke:

; 1442 :         }
; 1443 :     } else { /* ! ADDR branch */

	jmp	$LN21@PushInvoke
$LN20@PushInvoke:

; 1444 : 
; 1445 :         /* handle the <reg>::<reg> case here, the evaluator wont handle it */
; 1446 :         if ( tokenarray[j].token == T_REG &&
; 1447 :             tokenarray[j+1].token == T_DBL_COLON &&

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	jne	$LN56@PushInvoke
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 13
	jne	$LN56@PushInvoke
	mov	eax, DWORD PTR j$[rsp]
	add	eax, 2
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	jne	$LN56@PushInvoke

; 1448 :             tokenarray[j+2].token == T_REG ) {
; 1449 :             int asize2;
; 1450 :             /* for pointers, segreg size is assumed to be always 2 */
; 1451 :             if ( GetValueSp( tokenarray[j].tokval ) & OP_SR ) {

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 24576				; 00006000H
	test	eax, eax
	je	SHORT $LN58@PushInvoke

; 1452 :                 asize2 = 2;

	mov	DWORD PTR asize2$4[rsp], 2

; 1453 :                 /* v2.11: if target and current src have different offset sizes,
; 1454 :                  * the push of the segment register must be 66h-prefixed!
; 1455 :                  */
; 1456 :                 if ( Ofssize != ModuleInfo.Ofssize || ( curr->sym.Ofssize == USE16 && CurrWordSize > 2 ) )

	movsx	eax, BYTE PTR Ofssize$[rsp]
	movzx	ecx, BYTE PTR ModuleInfo+404
	cmp	eax, ecx
	jne	SHORT $LN61@PushInvoke
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+52]
	test	eax, eax
	jne	SHORT $LN60@PushInvoke
	movzx	eax, BYTE PTR ModuleInfo+406
	cmp	eax, 2
	jle	SHORT $LN60@PushInvoke
$LN61@PushInvoke:

; 1457 :                     AddLineQueue( " db 66h" );

	lea	rcx, OFFSET FLAT:$SG11936
	call	AddLineQueue
$LN60@PushInvoke:

; 1458 :             } else

	jmp	SHORT $LN59@PushInvoke
$LN58@PushInvoke:

; 1459 :                 asize2 = SizeFromRegister( tokenarray[j].tokval );

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+16]
	call	SizeFromRegister
	mov	DWORD PTR asize2$4[rsp], eax
$LN59@PushInvoke:

; 1460 :             asize = SizeFromRegister( tokenarray[j+2].tokval );

	mov	eax, DWORD PTR j$[rsp]
	add	eax, 2
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+16]
	call	SizeFromRegister
	mov	DWORD PTR asize$[rsp], eax

; 1461 :             AddLineQueueX( " push %r", tokenarray[j].tokval );

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR [rcx+rax+16]
	lea	rcx, OFFSET FLAT:$SG11937
	call	AddLineQueueX

; 1462 :             /* v2.04: changed */
; 1463 :             if (( curr->sym.is_vararg ) && (asize + asize2) != CurrWordSize )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN62@PushInvoke
	mov	eax, DWORD PTR asize2$4[rsp]
	mov	ecx, DWORD PTR asize$[rsp]
	add	ecx, eax
	mov	eax, ecx
	movzx	ecx, BYTE PTR ModuleInfo+406
	cmp	eax, ecx
	je	SHORT $LN62@PushInvoke

; 1464 :                 size_vararg += asize2;

	mov	eax, DWORD PTR asize2$4[rsp]
	mov	ecx, DWORD PTR size_vararg
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR size_vararg, eax
	jmp	SHORT $LN63@PushInvoke
$LN62@PushInvoke:

; 1465 :             else
; 1466 :                 asize += asize2;

	mov	eax, DWORD PTR asize2$4[rsp]
	mov	ecx, DWORD PTR asize$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR asize$[rsp], eax
$LN63@PushInvoke:

; 1467 :             strcpy( fullparam, tokenarray[j+2].string_ptr );

	mov	eax, DWORD PTR j$[rsp]
	add	eax, 2
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, QWORD PTR fullparam$[rsp]
	call	strcpy

; 1468 : 
; 1469 :             opnd.kind = EXPR_REG;

	mov	DWORD PTR opnd$[rsp+60], 2

; 1470 :             opnd.indirect = FALSE;

	mov	eax, DWORD PTR opnd$[rsp+72]
	and	eax, -2					; fffffffeH
	mov	DWORD PTR opnd$[rsp+72], eax

; 1471 :             opnd.sym = NULL;

	mov	QWORD PTR opnd$[rsp+80], 0

; 1472 :             opnd.base_reg = &tokenarray[j+2]; /* for error msg 'eax overwritten...' */

	mov	eax, DWORD PTR j$[rsp]
	add	eax, 2
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR opnd$[rsp+24], rax

; 1473 :         } else {

	jmp	$LN57@PushInvoke
$LN56@PushInvoke:

; 1474 :             /* v2.06: don't handle forward refs if -Zne is set */
; 1475 :             //if ( EvalOperand( &j, Token_Count, &opnd, 0 ) == ERROR ) {
; 1476 :             if ( EvalOperand( &j, tokenarray, Token_Count, &opnd, ModuleInfo.invoke_exprparm ) == ERROR ) {

	movzx	eax, BYTE PTR ModuleInfo+426
	mov	BYTE PTR [rsp+32], al
	lea	r9, QWORD PTR opnd$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR j$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN64@PushInvoke

; 1477 :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@PushInvoke
$LN64@PushInvoke:

; 1478 :             }
; 1479 : 
; 1480 :             /* for a simple register, get its size */
; 1481 :             if ( opnd.kind == EXPR_REG && opnd.indirect == FALSE ) {

	cmp	DWORD PTR opnd$[rsp+60], 2
	jne	SHORT $LN65@PushInvoke
	mov	eax, DWORD PTR opnd$[rsp+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN65@PushInvoke

; 1482 :                 asize = SizeFromRegister( opnd.base_reg->tokval );

	mov	rax, QWORD PTR opnd$[rsp+24]
	mov	ecx, DWORD PTR [rax+16]
	call	SizeFromRegister
	mov	DWORD PTR asize$[rsp], eax
	jmp	$LN66@PushInvoke
$LN65@PushInvoke:

; 1483 :             //} else if ( opnd.mem_type == MT_EMPTY ) { /* v2.10: a TYPE may return mem_type != MT_EMPTY! */
; 1484 :             } else if ( opnd.kind == EXPR_CONST || opnd.mem_type == MT_EMPTY ) {

	cmp	DWORD PTR opnd$[rsp+60], 0
	je	SHORT $LN69@PushInvoke
	cmp	DWORD PTR opnd$[rsp+64], 192		; 000000c0H
	jne	$LN67@PushInvoke
$LN69@PushInvoke:

; 1485 :                 asize = psize;

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR asize$[rsp], eax

; 1486 :                 /* v2.04: added, to catch 0-size params ( STRUCT without members ) */
; 1487 :                 if ( psize == 0 ) {

	cmp	DWORD PTR psize$[rsp], 0
	jne	SHORT $LN70@PushInvoke

; 1488 :                     if ( curr->sym.is_vararg == FALSE ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN71@PushInvoke

; 1489 :                         DebugMsg1(("PushInvokeParm(%u): error, psize=0\n" ));

	lea	rcx, OFFSET FLAT:$SG11948
	call	DoDebugMsg1

; 1490 :                         EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	mov	eax, DWORD PTR reqParam$[rsp]
	inc	eax
	mov	edx, eax
	mov	ecx, 145				; 00000091H
	call	EmitErr
$LN71@PushInvoke:

; 1491 :                     }
; 1492 :                     /* v2.07: for VARARG, get the member's size if it is a structured var */
; 1493 :                     if ( opnd.mbr && opnd.mbr->mem_type == MT_TYPE )

	cmp	QWORD PTR opnd$[rsp+88], 0
	je	SHORT $LN72@PushInvoke
	mov	rax, QWORD PTR opnd$[rsp+88]
	cmp	DWORD PTR [rax+44], 196			; 000000c4H
	jne	SHORT $LN72@PushInvoke

; 1494 :                         asize = SizeFromMemtype( opnd.mbr->mem_type, opnd.Ofssize, opnd.mbr->type );

	movzx	eax, BYTE PTR opnd$[rsp+69]
	mov	rcx, QWORD PTR opnd$[rsp+88]
	mov	r8, QWORD PTR [rcx+88]
	mov	edx, eax
	mov	rax, QWORD PTR opnd$[rsp+88]
	mov	ecx, DWORD PTR [rax+44]
	call	SizeFromMemtype
	mov	DWORD PTR asize$[rsp], eax
$LN72@PushInvoke:
$LN70@PushInvoke:

; 1495 :                 }
; 1496 :                 DebugMsg1(("PushInvokeParm(%u): memtype EMPTY, asize=%u psize=%u\n", reqParam, asize, psize ));

	mov	r9d, DWORD PTR psize$[rsp]
	mov	r8d, DWORD PTR asize$[rsp]
	mov	edx, DWORD PTR reqParam$[rsp]
	lea	rcx, OFFSET FLAT:$SG11950
	call	DoDebugMsg1
	jmp	$LN68@PushInvoke
$LN67@PushInvoke:

; 1497 :             } else if ( opnd.mem_type != MT_TYPE ) {

	cmp	DWORD PTR opnd$[rsp+64], 196		; 000000c4H
	je	$LN73@PushInvoke

; 1498 :                 if ( opnd.kind == EXPR_ADDR &&
; 1499 :                      opnd.indirect == FALSE &&
; 1500 :                      opnd.sym &&
; 1501 :                      opnd.instr == EMPTY &&

	cmp	DWORD PTR opnd$[rsp+60], 1
	jne	SHORT $LN75@PushInvoke
	mov	eax, DWORD PTR opnd$[rsp+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN75@PushInvoke
	cmp	QWORD PTR opnd$[rsp+80], 0
	je	SHORT $LN75@PushInvoke
	cmp	DWORD PTR opnd$[rsp+56], -2
	jne	SHORT $LN75@PushInvoke
	cmp	DWORD PTR opnd$[rsp+64], 129		; 00000081H
	je	SHORT $LN76@PushInvoke
	cmp	DWORD PTR opnd$[rsp+64], 130		; 00000082H
	jne	SHORT $LN75@PushInvoke
$LN76@PushInvoke:

; 1502 :                      ( opnd.mem_type == MT_NEAR || opnd.mem_type == MT_FAR ) )
; 1503 :                     goto push_address;

	jmp	$push_address$273
$LN75@PushInvoke:

; 1504 :                 if ( opnd.Ofssize == USE_EMPTY )

	movzx	eax, BYTE PTR opnd$[rsp+69]
	cmp	eax, 254				; 000000feH
	jne	SHORT $LN77@PushInvoke

; 1505 :                     opnd.Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	BYTE PTR opnd$[rsp+69], al
$LN77@PushInvoke:

; 1506 :                 asize = SizeFromMemtype( opnd.mem_type, opnd.Ofssize, opnd.type );

	movzx	eax, BYTE PTR opnd$[rsp+69]
	mov	r8, QWORD PTR opnd$[rsp+96]
	mov	edx, eax
	mov	ecx, DWORD PTR opnd$[rsp+64]
	call	SizeFromMemtype
	mov	DWORD PTR asize$[rsp], eax

; 1507 :             } else {

	jmp	SHORT $LN74@PushInvoke
$LN73@PushInvoke:

; 1508 :                 if ( opnd.sym != NULL )

	cmp	QWORD PTR opnd$[rsp+80], 0
	je	SHORT $LN78@PushInvoke

; 1509 :                     asize = opnd.sym->type->total_size;

	mov	rax, QWORD PTR opnd$[rsp+80]
	mov	rax, QWORD PTR [rax+88]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR asize$[rsp], eax
	jmp	SHORT $LN79@PushInvoke
$LN78@PushInvoke:

; 1510 :                 else
; 1511 :                     asize = opnd.mbr->type->total_size;

	mov	rax, QWORD PTR opnd$[rsp+88]
	mov	rax, QWORD PTR [rax+88]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR asize$[rsp], eax
$LN79@PushInvoke:
$LN74@PushInvoke:
$LN68@PushInvoke:
$LN66@PushInvoke:
$LN57@PushInvoke:

; 1512 :             }
; 1513 :         }
; 1514 : 
; 1515 :         if ( curr->sym.is_vararg == TRUE )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN80@PushInvoke

; 1516 :             psize = asize;

	mov	eax, DWORD PTR asize$[rsp]
	mov	DWORD PTR psize$[rsp], eax
$LN80@PushInvoke:

; 1517 : 
; 1518 : #ifdef DEBUG_OUT
; 1519 :         if ( opnd.sym )

	cmp	QWORD PTR opnd$[rsp+80], 0
	je	SHORT $LN81@PushInvoke

; 1520 :             DebugMsg1(("PushInvokeParam(%s, %u): arg name=%s, asize=%u, amtype=%xh psize=%u\n", proc->sym.name, reqParam, opnd.sym->name, asize, opnd.mem_type, psize));

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR opnd$[rsp+64]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR asize$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR opnd$[rsp+80]
	mov	r9, QWORD PTR [rax+8]
	mov	r8d, DWORD PTR reqParam$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11961
	call	DoDebugMsg1
	jmp	SHORT $LN82@PushInvoke
$LN81@PushInvoke:

; 1521 :         else
; 1522 :             DebugMsg1(("PushInvokeParam(%s, %u): arg no name, asize=%u, amtype=%xh psize=%u\n", proc->sym.name, reqParam, asize, opnd.mem_type, psize));

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR opnd$[rsp+64]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR asize$[rsp]
	mov	r8d, DWORD PTR reqParam$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11962
	call	DoDebugMsg1
$LN82@PushInvoke:

; 1523 : #endif
; 1524 :         pushsize = CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	DWORD PTR pushsize$[rsp], eax

; 1525 : 
; 1526 :         if (proc->sym.langtype == LANG_FASTCALL){

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 7
	jne	SHORT $LN83@PushInvoke

; 1527 :           if (fastcall_tab[ModuleInfo.fctype].handleparam(proc, reqParam, curr, addr, &opnd, fullparam, r0flags))

	movsxd	rax, DWORD PTR ModuleInfo+376
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:fastcall_tab
	mov	QWORD PTR tv1327[rsp], rcx
	mov	rdx, QWORD PTR r0flags$[rsp]
	mov	QWORD PTR [rsp+48], rdx
	lea	rdx, QWORD PTR fullparam$[rsp]
	mov	QWORD PTR [rsp+40], rdx
	lea	rdx, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rsp+32], rdx
	movzx	r9d, BYTE PTR addr$[rsp]
	mov	r8, QWORD PTR curr$[rsp]
	mov	edx, DWORD PTR reqParam$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	r10, QWORD PTR tv1327[rsp]
	call	QWORD PTR [r10+rax+16]
	test	eax, eax
	je	SHORT $LN85@PushInvoke

; 1528 :             return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@PushInvoke
$LN85@PushInvoke:

; 1529 :         }

	jmp	$LN84@PushInvoke
$LN83@PushInvoke:

; 1530 :         else if (proc->sym.langtype == LANG_VECTORCALL){

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	$LN86@PushInvoke

; 1531 :           if (opnd.kind == EXPR_REG && reqParam > 5) {

	cmp	DWORD PTR opnd$[rsp+60], 2
	jne	SHORT $LN87@PushInvoke
	cmp	DWORD PTR reqParam$[rsp], 5
	jle	SHORT $LN87@PushInvoke

; 1532 :             if ((GetValueSp(reg) & OP_XMM)||(GetValueSp(reg) & OP_YMM) 

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN90@PushInvoke
	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN89@PushInvoke
$LN90@PushInvoke:

; 1533 : #if EVEXSUPP
; 1534 :                 ||(GetValueSp(reg) & OP_ZMM)
; 1535 : #endif
; 1536 :               )
; 1537 :                 EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam );                

	mov	edx, DWORD PTR reqParam$[rsp]
	mov	ecx, 145				; 00000091H
	call	EmitErr
$LN89@PushInvoke:

; 1538 :            }

	jmp	SHORT $LN88@PushInvoke
$LN87@PushInvoke:

; 1539 :            else if (vectorcall_tab[ModuleInfo.fctype].handleparam(proc, reqParam, curr, addr, &opnd, fullparam, r0flags))

	movsxd	rax, DWORD PTR ModuleInfo+376
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:vectorcall_tab
	mov	QWORD PTR tv1330[rsp], rcx
	mov	rdx, QWORD PTR r0flags$[rsp]
	mov	QWORD PTR [rsp+48], rdx
	lea	rdx, QWORD PTR fullparam$[rsp]
	mov	QWORD PTR [rsp+40], rdx
	lea	rdx, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rsp+32], rdx
	movzx	r9d, BYTE PTR addr$[rsp]
	mov	r8, QWORD PTR curr$[rsp]
	mov	edx, DWORD PTR reqParam$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	r10, QWORD PTR tv1330[rsp]
	call	QWORD PTR [r10+rax+16]
	test	eax, eax
	je	SHORT $LN91@PushInvoke

; 1540 :             return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@PushInvoke
$LN91@PushInvoke:
$LN88@PushInvoke:
$LN86@PushInvoke:
$LN84@PushInvoke:

; 1541 :         }
; 1542 :         /* v2.04: this check has been moved behind the fastcall_tab() call */
; 1543 :         /* v2.11: if target is a pointer, sizes must match */
; 1544 :         //if ( asize > psize ) { /* argument's size too big? */
; 1545 :         if ( ( asize > psize ) || ( asize < psize && curr->sym.mem_type == MT_PTR ) ) {

	mov	eax, DWORD PTR psize$[rsp]
	cmp	DWORD PTR asize$[rsp], eax
	jg	SHORT $LN93@PushInvoke
	mov	eax, DWORD PTR psize$[rsp]
	cmp	DWORD PTR asize$[rsp], eax
	jge	SHORT $LN92@PushInvoke
	mov	rax, QWORD PTR curr$[rsp]
	cmp	DWORD PTR [rax+44], 195			; 000000c3H
	jne	SHORT $LN92@PushInvoke
$LN93@PushInvoke:

; 1546 :             DebugMsg(("PushInvokeParm(%u): argsize error, arg size=%d, parm size=%d\n", reqParam, asize, psize));

	mov	r9d, DWORD PTR psize$[rsp]
	mov	r8d, DWORD PTR asize$[rsp]
	mov	edx, DWORD PTR reqParam$[rsp]
	lea	rcx, OFFSET FLAT:$SG11974
	call	DoDebugMsg

; 1547 :             EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	mov	eax, DWORD PTR reqParam$[rsp]
	inc	eax
	mov	edx, eax
	mov	ecx, 145				; 00000091H
	call	EmitErr

; 1548 :             return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@PushInvoke
$LN92@PushInvoke:

; 1549 :         }
; 1550 : 
; 1551 :         if ( ( opnd.kind == EXPR_ADDR && opnd.instr != T_OFFSET ) ||

	cmp	DWORD PTR opnd$[rsp+60], 1
	jne	SHORT $LN97@PushInvoke
	cmp	DWORD PTR opnd$[rsp+56], 241		; 000000f1H
	jne	SHORT $LN96@PushInvoke
$LN97@PushInvoke:
	cmp	DWORD PTR opnd$[rsp+60], 2
	jne	$LN94@PushInvoke
	mov	eax, DWORD PTR opnd$[rsp+72]
	and	eax, 1
	cmp	eax, 1
	jne	$LN94@PushInvoke
$LN96@PushInvoke:

; 1552 :             ( opnd.kind == EXPR_REG && opnd.indirect == TRUE ) ) {
; 1553 : 
; 1554 :             /* catch the case when EAX has been used for ADDR,
; 1555 :              * and is later used as addressing register!
; 1556 :              *
; 1557 :              */
; 1558 :             if ( *r0flags &&

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN98@PushInvoke
	cmp	QWORD PTR opnd$[rsp+24], 0
	je	SHORT $LN100@PushInvoke
	mov	rax, QWORD PTR opnd$[rsp+24]
	cmp	DWORD PTR [rax+16], 17
	je	SHORT $LN99@PushInvoke
	mov	rax, QWORD PTR opnd$[rsp+24]
	cmp	DWORD PTR [rax+16], 115			; 00000073H
	je	SHORT $LN99@PushInvoke
$LN100@PushInvoke:
	cmp	QWORD PTR opnd$[rsp+32], 0
	je	SHORT $LN98@PushInvoke
	mov	rax, QWORD PTR opnd$[rsp+32]
	cmp	DWORD PTR [rax+16], 17
	je	SHORT $LN101@PushInvoke
	mov	rax, QWORD PTR opnd$[rsp+32]
	cmp	DWORD PTR [rax+16], 115			; 00000073H
	jne	SHORT $LN98@PushInvoke
$LN101@PushInvoke:
$LN99@PushInvoke:

; 1559 :                 (( opnd.base_reg != NULL &&
; 1560 :                   ( opnd.base_reg->tokval == T_EAX
; 1561 : #if AMD64_SUPPORT
; 1562 :                    || opnd.base_reg->tokval == T_RAX
; 1563 : #endif
; 1564 :                   )) ||
; 1565 :                  ( opnd.idx_reg != NULL &&
; 1566 :                   ( opnd.idx_reg->tokval == T_EAX
; 1567 : #if AMD64_SUPPORT
; 1568 :                    || opnd.idx_reg->tokval == T_RAX
; 1569 : #endif
; 1570 :                  )))) {
; 1571 :                 EmitErr( REGISTER_VALUE_OVERWRITTEN_BY_INVOKE );

	mov	ecx, 165				; 000000a5H
	call	EmitErr

; 1572 :                 *r0flags = 0;

	mov	rax, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rax], 0
$LN98@PushInvoke:

; 1573 :             }
; 1574 : 
; 1575 :             if ( curr->sym.is_vararg ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN102@PushInvoke

; 1576 :                 size_vararg += ( asize > pushsize ? asize : pushsize );

	mov	eax, DWORD PTR pushsize$[rsp]
	cmp	DWORD PTR asize$[rsp], eax
	jle	SHORT $LN261@PushInvoke
	mov	eax, DWORD PTR asize$[rsp]
	mov	DWORD PTR tv710[rsp], eax
	jmp	SHORT $LN262@PushInvoke
$LN261@PushInvoke:
	mov	eax, DWORD PTR pushsize$[rsp]
	mov	DWORD PTR tv710[rsp], eax
$LN262@PushInvoke:
	mov	eax, DWORD PTR tv710[rsp]
	mov	ecx, DWORD PTR size_vararg
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR size_vararg, eax

; 1577 :                 DebugMsg1(("PushInvokeParm(%u): asize=%u added to size_vararg, now=%u\n",

	mov	eax, DWORD PTR pushsize$[rsp]
	cmp	DWORD PTR asize$[rsp], eax
	jle	SHORT $LN263@PushInvoke
	mov	eax, DWORD PTR asize$[rsp]
	mov	DWORD PTR tv714[rsp], eax
	jmp	SHORT $LN264@PushInvoke
$LN263@PushInvoke:
	mov	eax, DWORD PTR pushsize$[rsp]
	mov	DWORD PTR tv714[rsp], eax
$LN264@PushInvoke:
	mov	r9d, DWORD PTR size_vararg
	mov	r8d, DWORD PTR tv714[rsp]
	mov	edx, DWORD PTR reqParam$[rsp]
	lea	rcx, OFFSET FLAT:$SG11984
	call	DoDebugMsg1
$LN102@PushInvoke:

; 1578 :                            reqParam, asize > pushsize ? asize : pushsize, size_vararg ));
; 1579 :             }
; 1580 :             if ( asize > pushsize ) {

	mov	eax, DWORD PTR pushsize$[rsp]
	cmp	DWORD PTR asize$[rsp], eax
	jle	$LN103@PushInvoke

; 1581 : 
; 1582 :                 short dw = T_WORD;

	mov	eax, 207				; 000000cfH
	mov	WORD PTR dw$3[rsp], ax

; 1583 :                 if (( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN105@PushInvoke

; 1584 :                     pushsize = 4;

	mov	DWORD PTR pushsize$[rsp], 4

; 1585 :                     dw = T_DWORD;

	mov	eax, 209				; 000000d1H
	mov	WORD PTR dw$3[rsp], ax
$LN105@PushInvoke:

; 1586 :                 }
; 1587 : 
; 1588 :                 /* in params like "qword ptr [eax]" the typecast
; 1589 :                  * has to be removed */
; 1590 :                 if ( opnd.explicit ) {

	mov	eax, DWORD PTR opnd$[rsp+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN106@PushInvoke

; 1591 :                     SkipTypecast( fullparam, i, tokenarray );

	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, QWORD PTR fullparam$[rsp]
	call	SkipTypecast

; 1592 :                     opnd.explicit = FALSE;

	mov	eax, DWORD PTR opnd$[rsp+72]
	and	eax, -3					; fffffffdH
	mov	DWORD PTR opnd$[rsp+72], eax
$LN106@PushInvoke:
$LN8@PushInvoke:

; 1593 :                 }
; 1594 : 
; 1595 :                 while ( asize > 0 ) {

	cmp	DWORD PTR asize$[rsp], 0
	jle	$LN9@PushInvoke

; 1596 : 
; 1597 :                     if ( asize & 2 ) {

	mov	eax, DWORD PTR asize$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN107@PushInvoke

; 1598 : 
; 1599 :                         /* ensure the stack remains dword-aligned in 32bit */
; 1600 :                         if ( ModuleInfo.Ofssize > USE16 ) {

	movzx	eax, BYTE PTR ModuleInfo+404
	test	eax, eax
	jle	SHORT $LN109@PushInvoke

; 1601 :                             /* v2.05: better push a 0 word? */
; 1602 :                             //AddLineQueueX( " pushw 0" );
; 1603 :                           /* ASMC v1.12: dword-aligned stack in 32bit */
; 1604 :                           if (pushsize == 4)

	cmp	DWORD PTR pushsize$[rsp], 4
	jne	SHORT $LN110@PushInvoke

; 1605 :                             size_vararg += 2;

	mov	eax, DWORD PTR size_vararg
	add	eax, 2
	mov	DWORD PTR size_vararg, eax
$LN110@PushInvoke:

; 1606 :                           /******/
; 1607 : #if AMD64_SUPPORT
; 1608 :                             AddLineQueueX( " sub %r, 2", stackreg[ModuleInfo.Ofssize] );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG11993
	call	AddLineQueueX
$LN109@PushInvoke:

; 1609 : #else
; 1610 :                             AddLineQueueX( " sub %r, 2", T_ESP );
; 1611 : #endif
; 1612 :                         }
; 1613 :                         AddLineQueueX( " push word ptr %s+%u", fullparam, NUMQUAL asize-2 );

	mov	eax, DWORD PTR asize$[rsp]
	sub	eax, 2
	mov	r8d, eax
	lea	rdx, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG11994
	call	AddLineQueueX

; 1614 :                         asize -= 2;

	mov	eax, DWORD PTR asize$[rsp]
	sub	eax, 2
	mov	DWORD PTR asize$[rsp], eax

; 1615 :                     } else {

	jmp	SHORT $LN108@PushInvoke
$LN107@PushInvoke:

; 1616 :                         AddLineQueueX( " push %r ptr %s+%u", dw, fullparam, NUMQUAL asize-pushsize );

	mov	eax, DWORD PTR pushsize$[rsp]
	mov	ecx, DWORD PTR asize$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	movsx	ecx, WORD PTR dw$3[rsp]
	mov	r9d, eax
	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG11995
	call	AddLineQueueX

; 1617 :                         asize -= pushsize;

	mov	eax, DWORD PTR pushsize$[rsp]
	mov	ecx, DWORD PTR asize$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR asize$[rsp], eax
$LN108@PushInvoke:

; 1618 :                     }
; 1619 :                 }

	jmp	$LN8@PushInvoke
$LN9@PushInvoke:

; 1620 :                 //return( NOT_ERROR );
; 1621 : 
; 1622 :             } else if ( asize < pushsize ) {

	jmp	$LN104@PushInvoke
$LN103@PushInvoke:
	mov	eax, DWORD PTR pushsize$[rsp]
	cmp	DWORD PTR asize$[rsp], eax
	jge	$LN111@PushInvoke

; 1623 : 
; 1624 :                 if ( psize > 4 ) {

	cmp	DWORD PTR psize$[rsp], 4
	jle	SHORT $LN113@PushInvoke

; 1625 :                     DebugMsg1(("PushInvokeParm(%u): error, ADDR, psize=%u, is > 4\n",

	mov	r8d, DWORD PTR psize$[rsp]
	mov	edx, DWORD PTR reqParam$[rsp]
	lea	rcx, OFFSET FLAT:$SG11999
	call	DoDebugMsg1

; 1626 :                               reqParam, psize ));
; 1627 :                     EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	mov	eax, DWORD PTR reqParam$[rsp]
	inc	eax
	mov	edx, eax
	mov	ecx, 145				; 00000091H
	call	EmitErr
$LN113@PushInvoke:

; 1628 :                 }
; 1629 :                 /* v2.11: added, use MOVSX/MOVZX if cpu >= 80386 */
; 1630 :                 if ( asize < 4 && psize > 2 && IS_SIGNED( opnd.mem_type ) && ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {

	cmp	DWORD PTR asize$[rsp], 4
	jge	SHORT $LN114@PushInvoke
	cmp	DWORD PTR psize$[rsp], 2
	jle	SHORT $LN114@PushInvoke
	mov	eax, DWORD PTR opnd$[rsp+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN114@PushInvoke
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN114@PushInvoke

; 1631 :                     AddLineQueueX( " movsx %r, %s", T_EAX, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 17
	lea	rcx, OFFSET FLAT:$SG12002
	call	AddLineQueueX

; 1632 :                     AddLineQueueX( " push %r", T_EAX );

	mov	edx, 17
	lea	rcx, OFFSET FLAT:$SG12003
	call	AddLineQueueX

; 1633 :                     *r0flags = R0_USED; /* reset R0_H_CLEARED  */

	mov	rax, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rax], 1

; 1634 :                 } else {

	jmp	$LN115@PushInvoke
$LN114@PushInvoke:

; 1635 :                     //switch (sym->mem_type) {
; 1636 :                     switch ( opnd.mem_type ) {

	mov	eax, DWORD PTR opnd$[rsp+64]
	mov	DWORD PTR tv771[rsp], eax
	cmp	DWORD PTR tv771[rsp], 0
	je	SHORT $LN116@PushInvoke
	cmp	DWORD PTR tv771[rsp], 1
	je	$LN129@PushInvoke
	cmp	DWORD PTR tv771[rsp], 64		; 00000040H
	je	SHORT $LN116@PushInvoke
	cmp	DWORD PTR tv771[rsp], 65		; 00000041H
	je	$LN129@PushInvoke
	jmp	$LN136@PushInvoke
$LN116@PushInvoke:

; 1637 :                     case MT_BYTE:
; 1638 :                     case MT_SBYTE:
; 1639 :                         if ( psize == 1 && curr->sym.is_vararg == FALSE ) {

	cmp	DWORD PTR psize$[rsp], 1
	jne	SHORT $LN117@PushInvoke
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN117@PushInvoke

; 1640 :                             AddLineQueueX( " mov %r, %s", T_AL, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG12007
	call	AddLineQueueX

; 1641 :                             AddLineQueueX( " push %r", regax[ModuleInfo.Ofssize] );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:regax
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12008
	call	AddLineQueueX
	jmp	$LN118@PushInvoke
$LN117@PushInvoke:

; 1642 :                         } else if ( pushsize == 2 ) { /* 16-bit code? */

	cmp	DWORD PTR pushsize$[rsp], 2
	jne	$LN119@PushInvoke

; 1643 :                             if ( opnd.mem_type == MT_BYTE ) {

	cmp	DWORD PTR opnd$[rsp+64], 0
	jne	$LN121@PushInvoke

; 1644 :                                 if ( psize == 4 )

	cmp	DWORD PTR psize$[rsp], 4
	jne	SHORT $LN123@PushInvoke

; 1645 :                                     if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < P_186 )  {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 16
	jge	SHORT $LN124@PushInvoke

; 1646 :                                         if ( !(*r0flags & R0_X_CLEARED ) )

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN126@PushInvoke

; 1647 :                                             AddLineQueueX( " xor %r, %r", T_AX, T_AX );

	mov	r8d, 9
	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12017
	call	AddLineQueueX
$LN126@PushInvoke:

; 1648 :                                         *r0flags |= ( R0_X_CLEARED | R0_H_CLEARED );

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 6
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al

; 1649 :                                         AddLineQueueX( " push %r", T_AX );

	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12018
	call	AddLineQueueX

; 1650 :                                     } else

	jmp	SHORT $LN125@PushInvoke
$LN124@PushInvoke:

; 1651 :                                         AddLineQueue( " push 0" );

	lea	rcx, OFFSET FLAT:$SG12019
	call	AddLineQueue
$LN125@PushInvoke:
$LN123@PushInvoke:

; 1652 :                                 AddLineQueueX( " mov %r, %s", T_AL, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG12020
	call	AddLineQueueX

; 1653 :                                 if ( !( *r0flags & R0_H_CLEARED )) {

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN127@PushInvoke

; 1654 :                                     AddLineQueueX( " mov %r, 0", T_AH );

	mov	edx, 5
	lea	rcx, OFFSET FLAT:$SG12022
	call	AddLineQueueX

; 1655 :                                     *r0flags |= R0_H_CLEARED;

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 2
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al
$LN127@PushInvoke:

; 1656 :                                 }
; 1657 :                             } else {

	jmp	SHORT $LN122@PushInvoke
$LN121@PushInvoke:

; 1658 :                                 AddLineQueueX( " mov %r, %s", T_AL, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG12023
	call	AddLineQueueX

; 1659 :                                 *r0flags = 0; /* reset AH_CLEARED */

	mov	rax, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rax], 0

; 1660 :                                 AddLineQueue( " cbw" );

	lea	rcx, OFFSET FLAT:$SG12024
	call	AddLineQueue

; 1661 :                                 if ( psize == 4 ) {

	cmp	DWORD PTR psize$[rsp], 4
	jne	SHORT $LN128@PushInvoke

; 1662 :                                     AddLineQueue( " cwd" );

	lea	rcx, OFFSET FLAT:$SG12026
	call	AddLineQueue

; 1663 :                                     AddLineQueueX( " push %r", T_DX );

	mov	edx, 11
	lea	rcx, OFFSET FLAT:$SG12027
	call	AddLineQueueX

; 1664 :                                     *r0flags |= R2_USED;

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 8
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al
$LN128@PushInvoke:
$LN122@PushInvoke:

; 1665 :                                 }
; 1666 :                             }
; 1667 :                             AddLineQueueX( " push %r", T_AX );

	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12028
	call	AddLineQueueX

; 1668 :                         } else {

	jmp	SHORT $LN120@PushInvoke
$LN119@PushInvoke:

; 1669 :                             AddLineQueueX( " mov%sx %r, %s", opnd.mem_type == MT_BYTE ? "z" : "s", T_EAX, fullparam );

	cmp	DWORD PTR opnd$[rsp+64], 0
	jne	SHORT $LN265@PushInvoke
	lea	rax, OFFSET FLAT:$SG12029
	mov	QWORD PTR tv830[rsp], rax
	jmp	SHORT $LN266@PushInvoke
$LN265@PushInvoke:
	lea	rax, OFFSET FLAT:$SG12030
	mov	QWORD PTR tv830[rsp], rax
$LN266@PushInvoke:
	lea	r9, QWORD PTR fullparam$[rsp]
	mov	r8d, 17
	mov	rdx, QWORD PTR tv830[rsp]
	lea	rcx, OFFSET FLAT:$SG12031
	call	AddLineQueueX

; 1670 :                             AddLineQueueX( " push %r", T_EAX );

	mov	edx, 17
	lea	rcx, OFFSET FLAT:$SG12032
	call	AddLineQueueX
$LN120@PushInvoke:
$LN118@PushInvoke:

; 1671 :                         }
; 1672 :                         *r0flags |= R0_USED;

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al

; 1673 :                         break;

	jmp	$LN10@PushInvoke
$LN129@PushInvoke:

; 1674 :                     case MT_WORD:
; 1675 :                     case MT_SWORD:
; 1676 :                         /* pushsize is 4 here, hence it's always 32-bit code!
; 1677 :                          * v2.04: use the Masm-compatible, non-destructive
; 1678 :                          * PUSH if psize is 2.
; 1679 :                          */
; 1680 :                         //if ( Options.masm_compat_gencode ) {
; 1681 :                         /* v2.11: don't push 0 if src operand is signed */
; 1682 :                         //if ( Options.masm_compat_gencode || psize == 2 ) {
; 1683 :                         if ( opnd.mem_type == MT_WORD && ( Options.masm_compat_gencode || psize == 2 )) {

	cmp	DWORD PTR opnd$[rsp+64], 1
	jne	SHORT $LN130@PushInvoke
	movzx	eax, BYTE PTR Options+144
	test	eax, eax
	jne	SHORT $LN132@PushInvoke
	cmp	DWORD PTR psize$[rsp], 2
	jne	SHORT $LN130@PushInvoke
$LN132@PushInvoke:

; 1684 :                             /* v2.05: push a 0 word if argument is VARARG
; 1685 :                              * v2.10: push a 0 word if psize != 2
; 1686 :                              */
; 1687 :                             //if ( curr->sym.is_vararg )
; 1688 :                             if ( curr->sym.is_vararg || psize != 2 )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN135@PushInvoke
	cmp	DWORD PTR psize$[rsp], 2
	je	SHORT $LN133@PushInvoke
$LN135@PushInvoke:

; 1689 :                                 AddLineQueueX( " pushw 0" );

	lea	rcx, OFFSET FLAT:$SG12040
	call	AddLineQueueX
	jmp	SHORT $LN134@PushInvoke
$LN133@PushInvoke:

; 1690 :                             else {
; 1691 : #if AMD64_SUPPORT
; 1692 :                                 AddLineQueueX( " sub %r, 2", stackreg[ModuleInfo.Ofssize] );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12041
	call	AddLineQueueX
$LN134@PushInvoke:

; 1693 : #else
; 1694 :                                 AddLineQueueX( " sub %r, 2", T_ESP );
; 1695 : #endif
; 1696 :                             }
; 1697 :                             AddLineQueueX( " push %s", fullparam );

	lea	rdx, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG12042
	call	AddLineQueueX

; 1698 :                         } else {

	jmp	SHORT $LN131@PushInvoke
$LN130@PushInvoke:

; 1699 :                             AddLineQueueX( " mov%sx %r, %s", opnd.mem_type == MT_WORD ? "z" : "s", T_EAX, fullparam );

	cmp	DWORD PTR opnd$[rsp+64], 1
	jne	SHORT $LN267@PushInvoke
	lea	rax, OFFSET FLAT:$SG12043
	mov	QWORD PTR tv891[rsp], rax
	jmp	SHORT $LN268@PushInvoke
$LN267@PushInvoke:
	lea	rax, OFFSET FLAT:$SG12044
	mov	QWORD PTR tv891[rsp], rax
$LN268@PushInvoke:
	lea	r9, QWORD PTR fullparam$[rsp]
	mov	r8d, 17
	mov	rdx, QWORD PTR tv891[rsp]
	lea	rcx, OFFSET FLAT:$SG12045
	call	AddLineQueueX

; 1700 :                             AddLineQueueX( " push %r", T_EAX );

	mov	edx, 17
	lea	rcx, OFFSET FLAT:$SG12046
	call	AddLineQueueX

; 1701 :                             *r0flags = R0_USED; /* reset R0_H_CLEARED  */

	mov	rax, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rax], 1
$LN131@PushInvoke:

; 1702 :                         }
; 1703 :                         break;

	jmp	SHORT $LN10@PushInvoke
$LN136@PushInvoke:

; 1704 :                     default:
; 1705 :                         AddLineQueueX( " push %s", fullparam );

	lea	rdx, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG12048
	call	AddLineQueueX
$LN10@PushInvoke:
$LN115@PushInvoke:

; 1706 :                     }
; 1707 :                 }
; 1708 :             } else { /* asize == pushsize */

	jmp	$LN112@PushInvoke
$LN111@PushInvoke:

; 1709 : 
; 1710 :                 /* v2.11: changed */
; 1711 :                 if ( IS_SIGNED( opnd.mem_type ) && psize > asize ) {

	mov	eax, DWORD PTR opnd$[rsp+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 64					; 00000040H
	jne	$LN137@PushInvoke
	mov	eax, DWORD PTR asize$[rsp]
	cmp	DWORD PTR psize$[rsp], eax
	jle	$LN137@PushInvoke

; 1712 :                     if ( psize > 2 && (( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) ) {

	cmp	DWORD PTR psize$[rsp], 2
	jle	SHORT $LN139@PushInvoke
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN139@PushInvoke

; 1713 :                         AddLineQueueX( " movsx %r, %s", T_EAX, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 17
	lea	rcx, OFFSET FLAT:$SG12053
	call	AddLineQueueX

; 1714 :                         AddLineQueueX( " push %r", T_EAX );

	mov	edx, 17
	lea	rcx, OFFSET FLAT:$SG12054
	call	AddLineQueueX

; 1715 :                         *r0flags = R0_USED; /* reset R0_H_CLEARED  */

	mov	rax, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rax], 1
	jmp	SHORT $LN140@PushInvoke
$LN139@PushInvoke:

; 1716 :                     } else if ( pushsize == 2 && psize > 2 ) {

	cmp	DWORD PTR pushsize$[rsp], 2
	jne	SHORT $LN141@PushInvoke
	cmp	DWORD PTR psize$[rsp], 2
	jle	SHORT $LN141@PushInvoke

; 1717 :                         AddLineQueueX( " mov %r, %s", T_AX, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12057
	call	AddLineQueueX

; 1718 :                         AddLineQueueX( " cwd" );

	lea	rcx, OFFSET FLAT:$SG12058
	call	AddLineQueueX

; 1719 :                         AddLineQueueX( " push %r", T_DX );

	mov	edx, 11
	lea	rcx, OFFSET FLAT:$SG12059
	call	AddLineQueueX

; 1720 :                         AddLineQueueX( " push %r", T_AX );

	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12060
	call	AddLineQueueX

; 1721 :                         *r0flags = R0_USED | R2_USED;

	mov	rax, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rax], 9

; 1722 :                     } else

	jmp	SHORT $LN142@PushInvoke
$LN141@PushInvoke:

; 1723 :                         AddLineQueueX( " push %s", fullparam );

	lea	rdx, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG12061
	call	AddLineQueueX
$LN142@PushInvoke:
$LN140@PushInvoke:

; 1724 :                 } else {

	jmp	$LN138@PushInvoke
$LN137@PushInvoke:

; 1725 :                     if ( pushsize == 2 && psize > 2 ) {

	cmp	DWORD PTR pushsize$[rsp], 2
	jne	SHORT $LN143@PushInvoke
	cmp	DWORD PTR psize$[rsp], 2
	jle	SHORT $LN143@PushInvoke

; 1726 :                         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < P_186 )  {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 16
	jge	SHORT $LN144@PushInvoke

; 1727 :                             if ( !(*r0flags & R0_X_CLEARED ) )

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN146@PushInvoke

; 1728 :                                 AddLineQueueX( " xor %r, %r", T_AX, T_AX );

	mov	r8d, 9
	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12066
	call	AddLineQueueX
$LN146@PushInvoke:

; 1729 :                             AddLineQueueX( " push %r", T_AX );

	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12067
	call	AddLineQueueX

; 1730 :                             *r0flags |= ( R0_USED | R0_X_CLEARED | R0_H_CLEARED );

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 7
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al

; 1731 :                         } else

	jmp	SHORT $LN145@PushInvoke
$LN144@PushInvoke:

; 1732 :                             AddLineQueueX( " pushw 0" );

	lea	rcx, OFFSET FLAT:$SG12068
	call	AddLineQueueX
$LN145@PushInvoke:
$LN143@PushInvoke:

; 1733 :                     }
; 1734 :                     AddLineQueueX( " push %s", fullparam );

	lea	rdx, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG12069
	call	AddLineQueueX
$LN138@PushInvoke:
$LN112@PushInvoke:
$LN104@PushInvoke:

; 1735 :                 }
; 1736 :             }
; 1737 : 
; 1738 :         } else { /* the parameter is a register or constant value! */

	jmp	$LN95@PushInvoke
$LN94@PushInvoke:

; 1739 : 
; 1740 :             //char is_r0 = FALSE;
; 1741 :             if ( opnd.kind == EXPR_REG ) {

	cmp	DWORD PTR opnd$[rsp+60], 2
	jne	$LN147@PushInvoke

; 1742 :                 int reg = opnd.base_reg->tokval;

	mov	rax, QWORD PTR opnd$[rsp+24]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR reg$1[rsp], eax

; 1743 :                 unsigned optype = GetValueSp( reg );

	movsxd	rax, DWORD PTR reg$1[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR optype$6[rsp], eax

; 1744 : 
; 1745 :                 /* v2.11 */
; 1746 :                 if ( curr->sym.is_vararg == TRUE && psize < pushsize )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN149@PushInvoke
	mov	eax, DWORD PTR pushsize$[rsp]
	cmp	DWORD PTR psize$[rsp], eax
	jge	SHORT $LN149@PushInvoke

; 1747 :                     psize = pushsize;

	mov	eax, DWORD PTR pushsize$[rsp]
	mov	DWORD PTR psize$[rsp], eax
$LN149@PushInvoke:

; 1748 : 
; 1749 :                 /* v2.06: check if register is valid to be pushed.
; 1750 :                  * ST(n), MMn, XMMn, YMMn and special registers are NOT valid!
; 1751 :                  */
; 1752 :                 if ( optype & ( OP_STI | OP_MMX | OP_XMM

	mov	eax, DWORD PTR optype$6[rsp]
	and	eax, 102576				; 000190b0H
	test	eax, eax
	je	SHORT $LN150@PushInvoke

; 1753 : #if AVXSUPP
; 1754 :                                | OP_YMM
; 1755 : #endif
; 1756 :                                | OP_RSPEC ) ) {
; 1757 : 
; 1758 :                     return( EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 ) );

	mov	eax, DWORD PTR reqParam$[rsp]
	inc	eax
	mov	edx, eax
	mov	ecx, 145				; 00000091H
	call	EmitErr
	jmp	$LN1@PushInvoke
$LN150@PushInvoke:

; 1759 :                 }
; 1760 : 
; 1761 :                 if ( ( *r0flags & R0_USED ) && ( reg == T_AH || ( optype & OP_A ) ) ) {

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN151@PushInvoke
	cmp	DWORD PTR reg$1[rsp], 5
	je	SHORT $LN153@PushInvoke
	mov	eax, DWORD PTR optype$6[rsp]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $LN151@PushInvoke
$LN153@PushInvoke:

; 1762 :                     EmitErr( REGISTER_VALUE_OVERWRITTEN_BY_INVOKE );

	mov	ecx, 165				; 000000a5H
	call	EmitErr

; 1763 :                     *r0flags &= ~R0_USED;

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, -2
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al
	jmp	SHORT $LN152@PushInvoke
$LN151@PushInvoke:

; 1764 :                 } else if ( ( *r0flags & R2_USED ) && ( reg == T_DH || GetRegNo( reg ) == 2 ) ) {

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN154@PushInvoke
	cmp	DWORD PTR reg$1[rsp], 7
	je	SHORT $LN155@PushInvoke
	movsxd	rax, DWORD PTR reg$1[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	cmp	eax, 2
	jne	SHORT $LN154@PushInvoke
$LN155@PushInvoke:

; 1765 :                     EmitErr( REGISTER_VALUE_OVERWRITTEN_BY_INVOKE );

	mov	ecx, 165				; 000000a5H
	call	EmitErr

; 1766 :                     *r0flags &= ~R2_USED;

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, -9
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al
$LN154@PushInvoke:
$LN152@PushInvoke:

; 1767 :                 }
; 1768 :                 /* v2.11: use target's "pushsize", not the current one */
; 1769 :                 //if ( asize != psize || asize < pushsize ) {
; 1770 :                 if ( asize != psize || asize < ( 2 << Ofssize ) ) {

	mov	eax, DWORD PTR psize$[rsp]
	cmp	DWORD PTR asize$[rsp], eax
	jne	SHORT $LN157@PushInvoke
	movsx	eax, BYTE PTR Ofssize$[rsp]
	mov	ecx, 2
	mov	DWORD PTR tv1653[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv1653[rsp]
	shl	eax, cl
	cmp	DWORD PTR asize$[rsp], eax
	jge	$LN156@PushInvoke
$LN157@PushInvoke:

; 1771 :                     /* register size doesn't match the needed parameter size.
; 1772 :                      */
; 1773 :                     if ( psize > 4 ) {

	cmp	DWORD PTR psize$[rsp], 4
	jle	SHORT $LN158@PushInvoke

; 1774 :                         DebugMsg1(("PushInvokeParm(%u): error, REG, asize=%u, psize=%u, pushsize=%u\n",

	mov	eax, DWORD PTR pushsize$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR psize$[rsp]
	mov	r8d, DWORD PTR asize$[rsp]
	mov	edx, DWORD PTR reqParam$[rsp]
	lea	rcx, OFFSET FLAT:$SG12082
	call	DoDebugMsg1

; 1775 :                                   reqParam, asize, psize, pushsize ));
; 1776 :                         EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	mov	eax, DWORD PTR reqParam$[rsp]
	inc	eax
	mov	edx, eax
	mov	ecx, 145				; 00000091H
	call	EmitErr
$LN158@PushInvoke:

; 1777 :                     }
; 1778 : 
; 1779 :                     if ( asize <= 2 && ( psize == 4 || pushsize == 4 ) ) {

	cmp	DWORD PTR asize$[rsp], 2
	jg	$LN159@PushInvoke
	cmp	DWORD PTR psize$[rsp], 4
	je	SHORT $LN160@PushInvoke
	cmp	DWORD PTR pushsize$[rsp], 4
	jne	$LN159@PushInvoke
$LN160@PushInvoke:

; 1780 :                         if (( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 && asize == psize ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN161@PushInvoke
	mov	eax, DWORD PTR psize$[rsp]
	cmp	DWORD PTR asize$[rsp], eax
	jne	SHORT $LN161@PushInvoke

; 1781 :                             if ( asize == 2 )

	cmp	DWORD PTR asize$[rsp], 2
	jne	SHORT $LN163@PushInvoke

; 1782 :                                 reg = reg - T_AX + T_EAX;

	mov	eax, DWORD PTR reg$1[rsp]
	add	eax, 8
	mov	DWORD PTR reg$1[rsp], eax
	jmp	SHORT $LN164@PushInvoke
$LN163@PushInvoke:

; 1783 :                             else {
; 1784 :                                 /* v2.11: hibyte registers AH, BH, CH, DH ( no 4-7 ) needs special handling */
; 1785 :                                 if ( reg < T_AH )

	cmp	DWORD PTR reg$1[rsp], 5
	jge	SHORT $LN165@PushInvoke

; 1786 :                                     reg = reg - T_AL + T_EAX;

	mov	eax, DWORD PTR reg$1[rsp]
	add	eax, 16
	mov	DWORD PTR reg$1[rsp], eax
	jmp	SHORT $LN166@PushInvoke
$LN165@PushInvoke:

; 1787 :                                 else {
; 1788 :                                     AddLineQueueX( " mov %r, %s", T_AL, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG12091
	call	AddLineQueueX

; 1789 :                                     *r0flags |= R0_USED;

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al

; 1790 :                                     reg = T_EAX;

	mov	DWORD PTR reg$1[rsp], 17
$LN166@PushInvoke:

; 1791 :                                 }
; 1792 :                                 asize = 2; /* done */

	mov	DWORD PTR asize$[rsp], 2
$LN164@PushInvoke:

; 1793 :                             }

	jmp	$LN162@PushInvoke
$LN161@PushInvoke:

; 1794 :                         } else if ( IS_SIGNED( opnd.mem_type ) && pushsize < 4 ) {

	mov	eax, DWORD PTR opnd$[rsp+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 64					; 00000040H
	jne	$LN167@PushInvoke
	cmp	DWORD PTR pushsize$[rsp], 4
	jge	$LN167@PushInvoke

; 1795 : 
; 1796 :                             /* psize is 4 in this branch */
; 1797 :                             if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN169@PushInvoke

; 1798 :                                 AddLineQueueX( " movsx %r, %s", T_EAX, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 17
	lea	rcx, OFFSET FLAT:$SG12096
	call	AddLineQueueX

; 1799 :                                 *r0flags = R0_USED;

	mov	rax, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rax], 1

; 1800 :                                 reg = T_EAX;

	mov	DWORD PTR reg$1[rsp], 17

; 1801 :                             } else {

	jmp	$LN170@PushInvoke
$LN169@PushInvoke:

; 1802 :                                 *r0flags = R0_USED | R2_USED;

	mov	rax, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rax], 9

; 1803 :                                 if ( asize == 1 ) {

	cmp	DWORD PTR asize$[rsp], 1
	jne	SHORT $LN171@PushInvoke

; 1804 :                                     if ( reg != T_AL )

	cmp	DWORD PTR reg$1[rsp], 1
	je	SHORT $LN173@PushInvoke

; 1805 :                                         AddLineQueueX( " mov %r, %s", T_AL, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG12100
	call	AddLineQueueX
$LN173@PushInvoke:

; 1806 :                                     AddLineQueue( " cbw" );

	lea	rcx, OFFSET FLAT:$SG12101
	call	AddLineQueue
	jmp	SHORT $LN172@PushInvoke
$LN171@PushInvoke:

; 1807 :                                 } else if ( reg != T_AX )

	cmp	DWORD PTR reg$1[rsp], 9
	je	SHORT $LN174@PushInvoke

; 1808 :                                     AddLineQueueX( " mov %r, %s", T_AX, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12103
	call	AddLineQueueX
$LN174@PushInvoke:
$LN172@PushInvoke:

; 1809 :                                 AddLineQueue( " cwd" );

	lea	rcx, OFFSET FLAT:$SG12104
	call	AddLineQueue

; 1810 :                                 AddLineQueueX( " push %r", T_DX );

	mov	edx, 11
	lea	rcx, OFFSET FLAT:$SG12105
	call	AddLineQueueX

; 1811 :                                 reg = T_AX;

	mov	DWORD PTR reg$1[rsp], 9
$LN170@PushInvoke:

; 1812 :                             }
; 1813 :                             asize = 2; /* done */

	mov	DWORD PTR asize$[rsp], 2
	jmp	$LN168@PushInvoke
$LN167@PushInvoke:

; 1814 : 
; 1815 :                         } else if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_186 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 16
	jl	$LN175@PushInvoke

; 1816 : 
; 1817 :                             if ( pushsize == 4 ) {

	cmp	DWORD PTR pushsize$[rsp], 4
	jne	SHORT $LN177@PushInvoke

; 1818 :                                 if ( asize == 1 ) {

	cmp	DWORD PTR asize$[rsp], 1
	jne	SHORT $LN179@PushInvoke
	jmp	SHORT $LN180@PushInvoke
$LN179@PushInvoke:

; 1819 :                                     /* handled below */
; 1820 :                                 } else if ( psize <= 2 ) {

	cmp	DWORD PTR psize$[rsp], 2
	jg	SHORT $LN181@PushInvoke

; 1821 : #if AMD64_SUPPORT
; 1822 :                                     AddLineQueueX( " sub %r, 2", stackreg[ModuleInfo.Ofssize] );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12114
	call	AddLineQueueX
	jmp	SHORT $LN182@PushInvoke
$LN181@PushInvoke:

; 1823 : #else
; 1824 :                                     AddLineQueueX( " sub %r, 2", T_ESP );
; 1825 : #endif
; 1826 :                                 } else if ( IS_SIGNED( opnd.mem_type ) ) {

	mov	eax, DWORD PTR opnd$[rsp+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN183@PushInvoke

; 1827 :                                     AddLineQueueX( " movsx %r, %s", T_EAX, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 17
	lea	rcx, OFFSET FLAT:$SG12117
	call	AddLineQueueX

; 1828 :                                     *r0flags = R0_USED;

	mov	rax, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rax], 1

; 1829 :                                     reg = T_EAX;

	mov	DWORD PTR reg$1[rsp], 17

; 1830 :                                 } else {

	jmp	SHORT $LN184@PushInvoke
$LN183@PushInvoke:

; 1831 :                                     AddLineQueue( " pushw 0" );

	lea	rcx, OFFSET FLAT:$SG12118
	call	AddLineQueue
$LN184@PushInvoke:
$LN182@PushInvoke:
$LN180@PushInvoke:

; 1832 :                                 }
; 1833 :                             } else

	jmp	SHORT $LN178@PushInvoke
$LN177@PushInvoke:

; 1834 :                                 AddLineQueue( " pushw 0" );

	lea	rcx, OFFSET FLAT:$SG12119
	call	AddLineQueue
$LN178@PushInvoke:

; 1835 : 
; 1836 :                         } else {

	jmp	SHORT $LN176@PushInvoke
$LN175@PushInvoke:

; 1837 : 
; 1838 :                             if ( !(*r0flags & R0_X_CLEARED) ) {

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN185@PushInvoke

; 1839 :                                 /* v2.11: extra check needed */
; 1840 :                                 if ( reg == T_AH || ( optype & OP_A ) )

	cmp	DWORD PTR reg$1[rsp], 5
	je	SHORT $LN187@PushInvoke
	mov	eax, DWORD PTR optype$6[rsp]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $LN186@PushInvoke
$LN187@PushInvoke:

; 1841 :                                     EmitErr( REGISTER_VALUE_OVERWRITTEN_BY_INVOKE );

	mov	ecx, 165				; 000000a5H
	call	EmitErr
$LN186@PushInvoke:

; 1842 :                                 AddLineQueueX( " xor %r, %r", T_AX, T_AX );

	mov	r8d, 9
	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12123
	call	AddLineQueueX
$LN185@PushInvoke:

; 1843 :                             }
; 1844 :                             AddLineQueueX( " push %r", T_AX );

	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12124
	call	AddLineQueueX

; 1845 :                             *r0flags = R0_USED | R0_H_CLEARED | R0_X_CLEARED;

	mov	rax, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rax], 7
$LN176@PushInvoke:
$LN168@PushInvoke:
$LN162@PushInvoke:
$LN159@PushInvoke:

; 1846 :                         }
; 1847 :                     }
; 1848 : 
; 1849 :                     if ( asize == 1 ) {

	cmp	DWORD PTR asize$[rsp], 1
	jne	$LN188@PushInvoke

; 1850 :                         if ( ( reg >= T_AH && reg <= T_BH ) || psize != 1 ) {

	cmp	DWORD PTR reg$1[rsp], 5
	jl	SHORT $LN192@PushInvoke
	cmp	DWORD PTR reg$1[rsp], 8
	jle	SHORT $LN191@PushInvoke
$LN192@PushInvoke:
	cmp	DWORD PTR psize$[rsp], 1
	je	$LN189@PushInvoke
$LN191@PushInvoke:

; 1851 :                             if ( psize != 1 && ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {

	cmp	DWORD PTR psize$[rsp], 1
	je	$LN193@PushInvoke
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	$LN193@PushInvoke

; 1852 :                                 /* v2.10: consider signed type coercion! */
; 1853 :                                 AddLineQueueX( " mov%sx %r, %s", IS_SIGNED( opnd.mem_type ) ? "s" : "z",

	mov	eax, DWORD PTR opnd$[rsp+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN269@PushInvoke
	lea	rax, OFFSET FLAT:$SG12132
	mov	QWORD PTR tv1112[rsp], rax
	jmp	SHORT $LN270@PushInvoke
$LN269@PushInvoke:
	lea	rax, OFFSET FLAT:$SG12133
	mov	QWORD PTR tv1112[rsp], rax
$LN270@PushInvoke:
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:regax
	lea	r9, QWORD PTR fullparam$[rsp]
	mov	r8d, DWORD PTR [rcx+rax*4]
	mov	rdx, QWORD PTR tv1112[rsp]
	lea	rcx, OFFSET FLAT:$SG12134
	call	AddLineQueueX

; 1854 :                                               regax[ModuleInfo.Ofssize], fullparam );
; 1855 :                                 *r0flags =  ( IS_SIGNED( opnd.mem_type ) ? R0_USED : R0_USED | R0_H_CLEARED );

	mov	eax, DWORD PTR opnd$[rsp+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN271@PushInvoke
	mov	DWORD PTR tv1117[rsp], 1
	jmp	SHORT $LN272@PushInvoke
$LN271@PushInvoke:
	mov	DWORD PTR tv1117[rsp], 3
$LN272@PushInvoke:
	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	ecx, BYTE PTR tv1117[rsp]
	mov	BYTE PTR [rax], cl

; 1856 :                             } else {

	jmp	$LN194@PushInvoke
$LN193@PushInvoke:

; 1857 :                                 if ( reg != T_AL ) {

	cmp	DWORD PTR reg$1[rsp], 1
	je	SHORT $LN195@PushInvoke

; 1858 :                                     AddLineQueueX( " mov %r, %s", T_AL, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG12136
	call	AddLineQueueX

; 1859 :                                     *r0flags |= R0_USED;

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al

; 1860 :                                     *r0flags &= ~R0_X_CLEARED;

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, -5
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al
$LN195@PushInvoke:

; 1861 :                                 }
; 1862 :                                 if ( psize != 1 ) /* v2.11: don't modify AH if paramsize is 1 */

	cmp	DWORD PTR psize$[rsp], 1
	je	SHORT $LN196@PushInvoke

; 1863 :                                     if ( IS_SIGNED( opnd.mem_type ) ) {

	mov	eax, DWORD PTR opnd$[rsp+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN197@PushInvoke

; 1864 :                                         AddLineQueue( " cbw" );

	lea	rcx, OFFSET FLAT:$SG12140
	call	AddLineQueue

; 1865 :                                         *r0flags &= ~( R0_H_CLEARED | R0_X_CLEARED );

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, -7
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al
	jmp	SHORT $LN198@PushInvoke
$LN197@PushInvoke:

; 1866 :                                     } else if (!( *r0flags & R0_H_CLEARED )) {

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN199@PushInvoke

; 1867 :                                         AddLineQueueX( " mov %r, 0", T_AH );

	mov	edx, 5
	lea	rcx, OFFSET FLAT:$SG12142
	call	AddLineQueueX

; 1868 :                                         *r0flags |= R0_H_CLEARED;

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 2
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al
$LN199@PushInvoke:
$LN198@PushInvoke:
$LN196@PushInvoke:
$LN194@PushInvoke:

; 1869 :                                     }
; 1870 :                             }
; 1871 :                             reg = regax[ModuleInfo.Ofssize];

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:regax
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR reg$1[rsp], eax

; 1872 :                         } else {

	jmp	SHORT $LN190@PushInvoke
$LN189@PushInvoke:

; 1873 :                             /* convert 8-bit to 16/32-bit register name */
; 1874 :                             if ( (( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386) &&

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN200@PushInvoke
	cmp	DWORD PTR psize$[rsp], 4
	je	SHORT $LN202@PushInvoke
	cmp	DWORD PTR pushsize$[rsp], 4
	jne	SHORT $LN200@PushInvoke
$LN202@PushInvoke:

; 1875 :                                 ( psize == 4 || pushsize == 4 ) ) {
; 1876 :                                 reg = reg - T_AL + T_EAX;

	mov	eax, DWORD PTR reg$1[rsp]
	add	eax, 16
	mov	DWORD PTR reg$1[rsp], eax

; 1877 :                             } else

	jmp	SHORT $LN201@PushInvoke
$LN200@PushInvoke:

; 1878 :                                 reg = reg - T_AL + T_AX;

	mov	eax, DWORD PTR reg$1[rsp]
	add	eax, 8
	mov	DWORD PTR reg$1[rsp], eax
$LN201@PushInvoke:
$LN190@PushInvoke:
$LN188@PushInvoke:
$LN156@PushInvoke:

; 1879 :                         }
; 1880 :                     }
; 1881 : #if 0
; 1882 :                     if ( is_r0 && ( *r0flags & R0_USED ) ) {
; 1883 :                         EmitErr( REGISTER_VALUE_OVERWRITTEN_BY_INVOKE );
; 1884 :                         *r0flags = 0;
; 1885 :                     }
; 1886 : #endif
; 1887 :                 }
; 1888 :                 AddLineQueueX( " push %r", reg );

	mov	edx, DWORD PTR reg$1[rsp]
	lea	rcx, OFFSET FLAT:$SG12146
	call	AddLineQueueX

; 1889 :                 /* v2.05: don't change psize if > pushsize */
; 1890 :                 if ( psize < pushsize )

	mov	eax, DWORD PTR pushsize$[rsp]
	cmp	DWORD PTR psize$[rsp], eax
	jge	SHORT $LN203@PushInvoke

; 1891 :                     /* v2.04: adjust psize ( for siz_vararg update ) */
; 1892 :                     psize = pushsize;

	mov	eax, DWORD PTR pushsize$[rsp]
	mov	DWORD PTR psize$[rsp], eax
$LN203@PushInvoke:

; 1893 : 
; 1894 :             } else { /* constant value */

	jmp	$LN148@PushInvoke
$LN147@PushInvoke:

; 1895 : 
; 1896 :                 /* v2.06: size check */
; 1897 :                 if ( psize ) {

	cmp	DWORD PTR psize$[rsp], 0
	je	$LN204@PushInvoke

; 1898 :                     if ( opnd.kind == EXPR_FLOAT )

	cmp	DWORD PTR opnd$[rsp+60], 3
	jne	SHORT $LN205@PushInvoke

; 1899 :                         asize = 4;

	mov	DWORD PTR asize$[rsp], 4
	jmp	$LN206@PushInvoke
$LN205@PushInvoke:

; 1900 :                     else if ( opnd.value64 <= 255 && opnd.value64 >= -255 )

	cmp	QWORD PTR opnd$[rsp], 255		; 000000ffH
	jg	SHORT $LN207@PushInvoke
	cmp	QWORD PTR opnd$[rsp], -255		; ffffffffffffff01H
	jl	SHORT $LN207@PushInvoke

; 1901 :                         asize = 1;

	mov	DWORD PTR asize$[rsp], 1
	jmp	SHORT $LN208@PushInvoke
$LN207@PushInvoke:

; 1902 :                     else if ( opnd.value64 <= 65535 && opnd.value64 >= -65535 )

	cmp	QWORD PTR opnd$[rsp], 65535		; 0000ffffH
	jg	SHORT $LN209@PushInvoke
	cmp	QWORD PTR opnd$[rsp], -65535		; ffffffffffff0001H
	jl	SHORT $LN209@PushInvoke

; 1903 :                         asize = 2;

	mov	DWORD PTR asize$[rsp], 2
	jmp	SHORT $LN210@PushInvoke
$LN209@PushInvoke:

; 1904 :                     else if ( opnd.value64 <= maxintvalues[0] && opnd.value64 >= minintvalues[0] )

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:maxintvalues
	mov	rax, QWORD PTR [rcx+rax]
	cmp	QWORD PTR opnd$[rsp], rax
	jg	SHORT $LN211@PushInvoke
	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:minintvalues
	mov	rax, QWORD PTR [rcx+rax]
	cmp	QWORD PTR opnd$[rsp], rax
	jl	SHORT $LN211@PushInvoke

; 1905 :                         asize = 4;

	mov	DWORD PTR asize$[rsp], 4
	jmp	SHORT $LN212@PushInvoke
$LN211@PushInvoke:

; 1906 :                     else
; 1907 :                         asize = 8;

	mov	DWORD PTR asize$[rsp], 8
$LN212@PushInvoke:
$LN210@PushInvoke:
$LN208@PushInvoke:
$LN206@PushInvoke:

; 1908 :                     if ( psize < asize )

	mov	eax, DWORD PTR asize$[rsp]
	cmp	DWORD PTR psize$[rsp], eax
	jge	SHORT $LN213@PushInvoke

; 1909 :                         EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	mov	eax, DWORD PTR reqParam$[rsp]
	inc	eax
	mov	edx, eax
	mov	ecx, 145				; 00000091H
	call	EmitErr
$LN213@PushInvoke:
$LN204@PushInvoke:

; 1910 :                 }
; 1911 : 
; 1912 :                 /* v2.11: don't use CurrWordSize */
; 1913 :                 //asize = CurrWordSize;
; 1914 :                 asize = 2 << Ofssize;

	movsx	eax, BYTE PTR Ofssize$[rsp]
	mov	ecx, 2
	mov	DWORD PTR tv1710[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv1710[rsp]
	shl	eax, cl
	mov	DWORD PTR asize$[rsp], eax

; 1915 : 
; 1916 :                 if ( psize < asize )  /* ensure that the default argsize (2,4,8) is met */

	mov	eax, DWORD PTR asize$[rsp]
	cmp	DWORD PTR psize$[rsp], eax
	jge	SHORT $LN214@PushInvoke

; 1917 :                     if ( psize == 0 && curr->sym.is_vararg ) {

	cmp	DWORD PTR psize$[rsp], 0
	jne	SHORT $LN215@PushInvoke
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN215@PushInvoke

; 1918 :                         /* v2.04: push a dword constant in 16-bit */
; 1919 :                         if ( asize == 2 &&

	cmp	DWORD PTR asize$[rsp], 2
	jne	SHORT $LN217@PushInvoke
	cmp	DWORD PTR opnd$[rsp], 65535		; 0000ffffH
	jg	SHORT $LN219@PushInvoke
	cmp	DWORD PTR opnd$[rsp], -65535		; ffffffffffff0001H
	jge	SHORT $LN217@PushInvoke
$LN219@PushInvoke:

; 1920 :                             ( opnd.value > 0xFFFFL || opnd.value < -65535L ) )
; 1921 :                             psize = 4;

	mov	DWORD PTR psize$[rsp], 4
	jmp	SHORT $LN218@PushInvoke
$LN217@PushInvoke:

; 1922 :                         else
; 1923 :                             psize = asize;

	mov	eax, DWORD PTR asize$[rsp]
	mov	DWORD PTR psize$[rsp], eax
$LN218@PushInvoke:

; 1924 :                     } else

	jmp	SHORT $LN216@PushInvoke
$LN215@PushInvoke:

; 1925 :                         psize = asize;

	mov	eax, DWORD PTR asize$[rsp]
	mov	DWORD PTR psize$[rsp], eax
$LN216@PushInvoke:
$LN214@PushInvoke:

; 1926 : 
; 1927 :                 if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < P_186 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 16
	jge	$LN220@PushInvoke

; 1928 :                     *r0flags |= R0_USED;

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al

; 1929 :                     switch ( psize ) {

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR tv1191[rsp], eax
	cmp	DWORD PTR tv1191[rsp], 2
	je	SHORT $LN222@PushInvoke
	cmp	DWORD PTR tv1191[rsp], 4
	je	SHORT $LN227@PushInvoke
	jmp	$LN233@PushInvoke
$LN222@PushInvoke:

; 1930 :                     case 2:
; 1931 :                         if ( opnd.value != 0 || opnd.kind == EXPR_ADDR ) {

	cmp	DWORD PTR opnd$[rsp], 0
	jne	SHORT $LN225@PushInvoke
	cmp	DWORD PTR opnd$[rsp+60], 1
	jne	SHORT $LN223@PushInvoke
$LN225@PushInvoke:

; 1932 :                             AddLineQueueX( " mov %r, %s", T_AX, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12170
	call	AddLineQueueX

; 1933 :                         } else {

	jmp	SHORT $LN224@PushInvoke
$LN223@PushInvoke:

; 1934 :                             if ( !(*r0flags & R0_X_CLEARED ) ) {

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN226@PushInvoke

; 1935 :                                 AddLineQueueX( " xor %r, %r", T_AX, T_AX );

	mov	r8d, 9
	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12172
	call	AddLineQueueX
$LN226@PushInvoke:

; 1936 :                             }
; 1937 :                             *r0flags |= R0_H_CLEARED | R0_X_CLEARED;

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 6
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al
$LN224@PushInvoke:

; 1938 :                         }
; 1939 :                         break;

	jmp	$LN12@PushInvoke
$LN227@PushInvoke:

; 1940 :                     case 4:
; 1941 :                         if ( opnd.uvalue <= 0xFFFF )

	cmp	DWORD PTR opnd$[rsp], 65535		; 0000ffffH
	ja	SHORT $LN228@PushInvoke

; 1942 :                             AddLineQueueX( " xor %r, %r", T_AX, T_AX );

	mov	r8d, 9
	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12176
	call	AddLineQueueX
	jmp	SHORT $LN229@PushInvoke
$LN228@PushInvoke:

; 1943 :                         else
; 1944 :                             AddLineQueueX( " mov %r, %r (%s)", T_AX, T_HIGHWORD, fullparam );

	lea	r9, QWORD PTR fullparam$[rsp]
	mov	r8d, 232				; 000000e8H
	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12177
	call	AddLineQueueX
$LN229@PushInvoke:

; 1945 :                         AddLineQueueX( " push %r", T_AX );

	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12178
	call	AddLineQueueX

; 1946 :                         if ( opnd.uvalue != 0 || opnd.kind == EXPR_ADDR ) {

	cmp	DWORD PTR opnd$[rsp], 0
	jne	SHORT $LN232@PushInvoke
	cmp	DWORD PTR opnd$[rsp+60], 1
	jne	SHORT $LN230@PushInvoke
$LN232@PushInvoke:

; 1947 :                             AddLineQueueX( " mov %r, %r (%s)", T_AX, T_LOWWORD, fullparam );

	lea	r9, QWORD PTR fullparam$[rsp]
	mov	r8d, 238				; 000000eeH
	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12182
	call	AddLineQueueX

; 1948 :                         } else {

	jmp	SHORT $LN231@PushInvoke
$LN230@PushInvoke:

; 1949 :                             *r0flags |= R0_H_CLEARED | R0_X_CLEARED;

	mov	rax, QWORD PTR r0flags$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 6
	mov	rcx, QWORD PTR r0flags$[rsp]
	mov	BYTE PTR [rcx], al
$LN231@PushInvoke:

; 1950 :                         }
; 1951 :                         break;

	jmp	SHORT $LN12@PushInvoke
$LN233@PushInvoke:

; 1952 :                     default:
; 1953 :                         DebugMsg1(("PushInvokeParm(%u): error, CONST, asize=%u, psize=%u, pushsize=%u\n",

	mov	eax, DWORD PTR pushsize$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR psize$[rsp]
	mov	r8d, DWORD PTR asize$[rsp]
	mov	edx, DWORD PTR reqParam$[rsp]
	lea	rcx, OFFSET FLAT:$SG12184
	call	DoDebugMsg1

; 1954 :                                   reqParam, asize, psize, pushsize ));
; 1955 :                         EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	mov	eax, DWORD PTR reqParam$[rsp]
	inc	eax
	mov	edx, eax
	mov	ecx, 145				; 00000091H
	call	EmitErr
$LN12@PushInvoke:

; 1956 :                     }
; 1957 :                     AddLineQueueX( " push %r", T_AX );

	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG12185
	call	AddLineQueueX

; 1958 :                 } else { /* cpu >= 80186 */

	jmp	$LN221@PushInvoke
$LN220@PushInvoke:

; 1959 :                     char *instr = "";

	lea	rax, OFFSET FLAT:$SG12186
	mov	QWORD PTR instr$7[rsp], rax

; 1960 :                     char *suffix;
; 1961 :                     int qual = EMPTY;

	mov	DWORD PTR qual$5[rsp], -2

; 1962 :                     //if ( asize != psize ) {
; 1963 :                     if ( psize != pushsize ) {

	mov	eax, DWORD PTR pushsize$[rsp]
	cmp	DWORD PTR psize$[rsp], eax
	je	$LN234@PushInvoke

; 1964 :                         switch ( psize ) {

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR tv1238[rsp], eax
	cmp	DWORD PTR tv1238[rsp], 2
	je	SHORT $LN235@PushInvoke
	cmp	DWORD PTR tv1238[rsp], 4
	je	$LN241@PushInvoke
	cmp	DWORD PTR tv1238[rsp], 6
	je	SHORT $LN236@PushInvoke
	cmp	DWORD PTR tv1238[rsp], 8
	je	$LN244@PushInvoke
	jmp	$LN248@PushInvoke
$LN235@PushInvoke:

; 1965 :                         case 2:
; 1966 :                             instr = "w";

	lea	rax, OFFSET FLAT:$SG12189
	mov	QWORD PTR instr$7[rsp], rax

; 1967 :                             break;

	jmp	$LN14@PushInvoke
$LN236@PushInvoke:

; 1968 :                         case 6: /* v2.04: added */
; 1969 :                             /* v2.11: use pushw only for 16-bit target */
; 1970 :                             if ( Ofssize == USE16 )

	movsx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	jne	SHORT $LN237@PushInvoke

; 1971 :                                 suffix = "w";

	lea	rax, OFFSET FLAT:$SG12193
	mov	QWORD PTR suffix$8[rsp], rax
	jmp	SHORT $LN238@PushInvoke
$LN237@PushInvoke:

; 1972 :                             else if ( Ofssize == USE32 && CurrWordSize == 2 )

	movsx	eax, BYTE PTR Ofssize$[rsp]
	cmp	eax, 1
	jne	SHORT $LN239@PushInvoke
	movzx	eax, BYTE PTR ModuleInfo+406
	cmp	eax, 2
	jne	SHORT $LN239@PushInvoke

; 1973 :                                 suffix = "d";

	lea	rax, OFFSET FLAT:$SG12196
	mov	QWORD PTR suffix$8[rsp], rax
	jmp	SHORT $LN240@PushInvoke
$LN239@PushInvoke:

; 1974 :                             else
; 1975 :                                 suffix = "";

	lea	rax, OFFSET FLAT:$SG12197
	mov	QWORD PTR suffix$8[rsp], rax
$LN240@PushInvoke:
$LN238@PushInvoke:

; 1976 :                             AddLineQueueX( " push%s (%s) shr 32t", suffix, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	rdx, QWORD PTR suffix$8[rsp]
	lea	rcx, OFFSET FLAT:$SG12198
	call	AddLineQueueX
$LN241@PushInvoke:

; 1977 :                             /* no break */
; 1978 :                         case 4:
; 1979 :                             if (( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 )

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN242@PushInvoke

; 1980 :                                 instr = "d";

	lea	rax, OFFSET FLAT:$SG12202
	mov	QWORD PTR instr$7[rsp], rax
	jmp	SHORT $LN243@PushInvoke
$LN242@PushInvoke:

; 1981 :                             else {
; 1982 :                                 AddLineQueueX( " pushw %r (%s)", T_HIGHWORD, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 232				; 000000e8H
	lea	rcx, OFFSET FLAT:$SG12203
	call	AddLineQueueX

; 1983 :                                 instr = "w";

	lea	rax, OFFSET FLAT:$SG12204
	mov	QWORD PTR instr$7[rsp], rax

; 1984 :                                 qual = T_LOWWORD;

	mov	DWORD PTR qual$5[rsp], 238		; 000000eeH
$LN243@PushInvoke:

; 1985 :                             }
; 1986 :                             break;

	jmp	$LN14@PushInvoke
$LN244@PushInvoke:

; 1987 :                         case 8:
; 1988 : #if AMD64_SUPPORT
; 1989 :                             if (( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_64 )

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 112				; 00000070H
	jl	SHORT $LN245@PushInvoke

; 1990 :                                 break;

	jmp	$LN14@PushInvoke
$LN245@PushInvoke:

; 1991 : #endif
; 1992 :                             /* v2.06: added support for double constants */
; 1993 :                             if ( opnd.kind == EXPR_CONST || opnd.kind == EXPR_FLOAT ) {

	cmp	DWORD PTR opnd$[rsp+60], 0
	je	SHORT $LN247@PushInvoke
	cmp	DWORD PTR opnd$[rsp+60], 3
	jne	SHORT $LN246@PushInvoke
$LN247@PushInvoke:

; 1994 :                                 AddLineQueueX( " pushd %r (%s)", T_HIGH32, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	edx, 231				; 000000e7H
	lea	rcx, OFFSET FLAT:$SG12209
	call	AddLineQueueX

; 1995 :                                 qual = T_LOW32;

	mov	DWORD PTR qual$5[rsp], 237		; 000000edH

; 1996 :                                 instr = "d";

	lea	rax, OFFSET FLAT:$SG12210
	mov	QWORD PTR instr$7[rsp], rax

; 1997 :                                 break;

	jmp	SHORT $LN14@PushInvoke
$LN246@PushInvoke:
$LN248@PushInvoke:

; 1998 :                             }
; 1999 :                         default:
; 2000 :                             DebugMsg1(("PushInvokeParm(%u): error, CONST, asize=%u, psize=%u, pushsize=%u\n",

	mov	eax, DWORD PTR pushsize$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR psize$[rsp]
	mov	r8d, DWORD PTR asize$[rsp]
	mov	edx, DWORD PTR reqParam$[rsp]
	lea	rcx, OFFSET FLAT:$SG12212
	call	DoDebugMsg1

; 2001 :                                       reqParam, asize, psize, pushsize ));
; 2002 :                             EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	mov	eax, DWORD PTR reqParam$[rsp]
	inc	eax
	mov	edx, eax
	mov	ecx, 145				; 00000091H
	call	EmitErr
$LN14@PushInvoke:
$LN234@PushInvoke:

; 2003 :                         }
; 2004 :                     }
; 2005 :                     if ( qual != EMPTY )

	cmp	DWORD PTR qual$5[rsp], -2
	je	SHORT $LN249@PushInvoke

; 2006 :                         AddLineQueueX( " push%s %r (%s)", instr, qual, fullparam );

	lea	r9, QWORD PTR fullparam$[rsp]
	mov	r8d, DWORD PTR qual$5[rsp]
	mov	rdx, QWORD PTR instr$7[rsp]
	lea	rcx, OFFSET FLAT:$SG12215
	call	AddLineQueueX
	jmp	SHORT $LN250@PushInvoke
$LN249@PushInvoke:

; 2007 :                     else
; 2008 :                         AddLineQueueX( " push%s %s", instr, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	mov	rdx, QWORD PTR instr$7[rsp]
	lea	rcx, OFFSET FLAT:$SG12216
	call	AddLineQueueX
$LN250@PushInvoke:
$LN221@PushInvoke:
$LN148@PushInvoke:

; 2009 :                 }
; 2010 :             }
; 2011 :             if ( curr->sym.is_vararg ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN251@PushInvoke

; 2012 :                 size_vararg += psize;

	mov	eax, DWORD PTR psize$[rsp]
	mov	ecx, DWORD PTR size_vararg
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR size_vararg, eax

; 2013 :                 DebugMsg1(("PushInvokeParm(%u): psize=%u added to size_vararg, now=%u\n", reqParam, psize, size_vararg ));

	mov	r9d, DWORD PTR size_vararg
	mov	r8d, DWORD PTR psize$[rsp]
	mov	edx, DWORD PTR reqParam$[rsp]
	lea	rcx, OFFSET FLAT:$SG12218
	call	DoDebugMsg1
$LN251@PushInvoke:
$LN95@PushInvoke:
$LN21@PushInvoke:

; 2014 :             }
; 2015 :         }
; 2016 :     }
; 2017 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@PushInvoke:
$LN252@PushInvoke:

; 2018 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 2456				; 00000998H
	ret	0
PushInvokeParam ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\invoke.c
_TEXT	SEGMENT
j$ = 32
fullparam$ = 64
i$ = 72
tokenarray$ = 80
SkipTypecast PROC

; 1262 : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1263 :     int j;
; 1264 :     fullparam[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR fullparam$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 1265 :     for ( j = i; ; j++ ) {

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR j$[rsp], eax
	jmp	SHORT $LN4@SkipTypeca
$LN2@SkipTypeca:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN4@SkipTypeca:

; 1266 :         if (( tokenarray[j].token == T_COMMA ) || ( tokenarray[j].token == T_FINAL ) )

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN6@SkipTypeca
	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN5@SkipTypeca
$LN6@SkipTypeca:

; 1267 :             break;

	jmp	$LN3@SkipTypeca
$LN5@SkipTypeca:

; 1268 :         if (( tokenarray[j+1].token == T_BINARY_OPERATOR ) && ( tokenarray[j+1].tokval == T_PTR ) )

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 5
	jne	SHORT $LN7@SkipTypeca
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 258		; 00000102H
	jne	SHORT $LN7@SkipTypeca

; 1269 :             j = j + 1;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
	jmp	SHORT $LN8@SkipTypeca
$LN7@SkipTypeca:

; 1270 :         else {
; 1271 :             if ( fullparam[0] != NULLC )

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR fullparam$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN9@SkipTypeca

; 1272 :                 strcat( fullparam," " );

	lea	rdx, OFFSET FLAT:$SG11816
	mov	rcx, QWORD PTR fullparam$[rsp]
	call	strcat
$LN9@SkipTypeca:

; 1273 :             strcat( fullparam, tokenarray[j].string_ptr );

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	rcx, QWORD PTR fullparam$[rsp]
	call	strcat
$LN8@SkipTypeca:

; 1274 :         }
; 1275 :     }

	jmp	$LN2@SkipTypeca
$LN3@SkipTypeca:

; 1276 : }

	add	rsp, 56					; 00000038H
	ret	0
SkipTypecast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\invoke.c
_TEXT	SEGMENT
reg$ = 48
as$1 = 52
dir$2 = 56
seg$3 = 64
tv71 = 72
tv73 = 80
tv79 = 88
tv85 = 96
tv181 = 104
opnd$ = 128
buffer$ = 136
fullparam$ = 144
GetSegmentPart PROC

; 1090 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 1091 :     short reg = T_NULL;

	xor	eax, eax
	mov	WORD PTR reg$[rsp], ax

; 1092 :     DebugMsg1(("GetSegmentPart(%s) enter [override=%s sym=%s segment=%s]\n",

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN21@GetSegment
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	QWORD PTR [rax+32], 0
	je	SHORT $LN19@GetSegment
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+32]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv71[rsp], rax
	jmp	SHORT $LN20@GetSegment
$LN19@GetSegment:
	lea	rax, OFFSET FLAT:$SG11677
	mov	QWORD PTR tv71[rsp], rax
$LN20@GetSegment:
	mov	rax, QWORD PTR tv71[rsp]
	mov	QWORD PTR tv73[rsp], rax
	jmp	SHORT $LN22@GetSegment
$LN21@GetSegment:
	lea	rax, OFFSET FLAT:$SG11678
	mov	QWORD PTR tv73[rsp], rax
$LN22@GetSegment:
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN23@GetSegment
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv79[rsp], rax
	jmp	SHORT $LN24@GetSegment
$LN23@GetSegment:
	lea	rax, OFFSET FLAT:$SG11679
	mov	QWORD PTR tv79[rsp], rax
$LN24@GetSegment:
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN25@GetSegment
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv85[rsp], rax
	jmp	SHORT $LN26@GetSegment
$LN25@GetSegment:
	lea	rax, OFFSET FLAT:$SG11680
	mov	QWORD PTR tv85[rsp], rax
$LN26@GetSegment:
	mov	rax, QWORD PTR tv73[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv79[rsp]
	mov	r8, QWORD PTR tv85[rsp]
	mov	rdx, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG11681
	call	DoDebugMsg1

; 1093 :                fullparam, opnd->override ? opnd->override->string_ptr : "NULL",
; 1094 :                opnd->sym ? opnd->sym->name : "NULL",
; 1095 :                opnd->sym ? opnd->sym->segment ? opnd->sym->segment->name : "NULL" : "NULL" ));
; 1096 :     if ( opnd->override != NULL ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN2@GetSegment

; 1097 :         if ( opnd->override->token == T_REG )

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+48]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 2
	jne	SHORT $LN4@GetSegment

; 1098 :             reg = opnd->override->tokval;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+48]
	movzx	eax, WORD PTR [rax+16]
	mov	WORD PTR reg$[rsp], ax
	jmp	SHORT $LN5@GetSegment
$LN4@GetSegment:

; 1099 :         else
; 1100 :             strcpy( buffer, opnd->override->string_ptr );

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcpy
$LN5@GetSegment:

; 1101 :     } else if ( opnd->sym != NULL && opnd->sym->segment != NULL ) {

	jmp	$LN3@GetSegment
$LN2@GetSegment:
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	$LN6@GetSegment
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	QWORD PTR [rax+32], 0
	je	$LN6@GetSegment

; 1102 :         struct dsym *dir = GetSegm( opnd->sym );

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR dir$2[rsp], rax

; 1103 :         enum assume_segreg as;
; 1104 :         if ( dir->e.seginfo->segtype == SEGTYPE_DATA ||

	mov	rax, QWORD PTR dir$2[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+72], 2
	je	SHORT $LN10@GetSegment
	mov	rax, QWORD PTR dir$2[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+72], 3
	jne	SHORT $LN8@GetSegment
$LN10@GetSegment:

; 1105 :             dir->e.seginfo->segtype == SEGTYPE_BSS )
; 1106 :             as = search_assume( (struct asym *)dir, ASSUME_DS, TRUE );

	mov	r8b, 1
	mov	edx, 3
	mov	rcx, QWORD PTR dir$2[rsp]
	call	search_assume
	mov	DWORD PTR as$1[rsp], eax
	jmp	SHORT $LN9@GetSegment
$LN8@GetSegment:

; 1107 :         else
; 1108 :             as = search_assume( (struct asym *)dir, ASSUME_CS, TRUE );

	mov	r8b, 1
	mov	edx, 1
	mov	rcx, QWORD PTR dir$2[rsp]
	call	search_assume
	mov	DWORD PTR as$1[rsp], eax
$LN9@GetSegment:

; 1109 :         if ( as != ASSUME_NOTHING ) {

	cmp	DWORD PTR as$1[rsp], -2
	je	SHORT $LN11@GetSegment

; 1110 :             //GetResWName( segreg_tab[as], buffer );
; 1111 :             reg = T_ES + as; /* v2.08: T_ES is first seg reg in special.h */

	mov	eax, DWORD PTR as$1[rsp]
	add	eax, 25
	mov	WORD PTR reg$[rsp], ax

; 1112 :         } else {

	jmp	SHORT $LN12@GetSegment
$LN11@GetSegment:

; 1113 :             struct asym *seg;
; 1114 :             seg = GetGroup( opnd->sym );

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	GetGroup
	mov	QWORD PTR seg$3[rsp], rax

; 1115 :             if ( seg == NULL )

	cmp	QWORD PTR seg$3[rsp], 0
	jne	SHORT $LN13@GetSegment

; 1116 :                 seg = &dir->sym;

	mov	rax, QWORD PTR dir$2[rsp]
	mov	QWORD PTR seg$3[rsp], rax
$LN13@GetSegment:

; 1117 :             if ( seg )

	cmp	QWORD PTR seg$3[rsp], 0
	je	SHORT $LN14@GetSegment

; 1118 :                 strcpy( buffer, seg->name );

	mov	rax, QWORD PTR seg$3[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcpy
	jmp	SHORT $LN15@GetSegment
$LN14@GetSegment:

; 1119 :             else {
; 1120 :                 strcpy( buffer, "seg " );

	lea	rdx, OFFSET FLAT:$SG11696
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcpy

; 1121 :                 strcat( buffer, fullparam );

	mov	rdx, QWORD PTR fullparam$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcat
$LN15@GetSegment:
$LN12@GetSegment:

; 1122 :             }
; 1123 :         }

	jmp	SHORT $LN7@GetSegment
$LN6@GetSegment:

; 1124 :     } else if ( opnd->sym && opnd->sym->state == SYM_STACK ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN16@GetSegment
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+40], 5
	jne	SHORT $LN16@GetSegment

; 1125 :         reg = T_SS;

	mov	eax, 27
	mov	WORD PTR reg$[rsp], ax

; 1126 :     } else {

	jmp	SHORT $LN17@GetSegment
$LN16@GetSegment:

; 1127 :         strcpy( buffer,"seg " );

	lea	rdx, OFFSET FLAT:$SG11699
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcpy

; 1128 :         strcat( buffer, fullparam );

	mov	rdx, QWORD PTR fullparam$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcat
$LN17@GetSegment:
$LN7@GetSegment:
$LN3@GetSegment:

; 1129 :     }
; 1130 :     DebugMsg1(("GetSegmentPart: reg%u, buffer=%s\n", reg, reg ? "" : buffer ));

	movsx	eax, WORD PTR reg$[rsp]
	test	eax, eax
	je	SHORT $LN27@GetSegment
	lea	rax, OFFSET FLAT:$SG11700
	mov	QWORD PTR tv181[rsp], rax
	jmp	SHORT $LN28@GetSegment
$LN27@GetSegment:
	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR tv181[rsp], rax
$LN28@GetSegment:
	movsx	eax, WORD PTR reg$[rsp]
	mov	r8, QWORD PTR tv181[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11701
	call	DoDebugMsg1

; 1131 :     return( reg );

	movzx	eax, WORD PTR reg$[rsp]

; 1132 : }

	add	rsp, 120				; 00000078H
	ret	0
GetSegmentPart ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\invoke.c
_TEXT	SEGMENT
i$ = 48
j$ = 52
vecidx$ = 56
psize$ = 60
info$ = 64
memberCount$ = 72
membersize$ = 76
size$ = 80
destroyed$ = 84
tCount$ = 88
reg$ = 92
t$ = 96
freevecregs$ = 104
base$ = 108
reg2$ = 112
tv1210 = 116
tv1354 = 120
tv390 = 124
tv1569 = 128
tv1675 = 132
tv289 = 136
tv353 = 140
tv375 = 144
tv1477 = 148
tv1498 = 152
tv1556 = 156
tv1607 = 160
tv160 = 164
tv197 = 168
tv1870 = 172
tv1890 = 176
tv2356 = 180
tv2415 = 184
tv2453 = 188
tv422 = 192
tv1642 = 200
tv1727 = 208
proc$ = 240
index$ = 248
param$ = 256
addr$ = 264
opnd$ = 272
paramvalue$ = 280
regs_used$ = 288
ms64_param PROC

; 262  : {

	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 232				; 000000e8H

; 263  :     uint_32 size;
; 264  :     uint_32 psize;
; 265  :     char name[256];
; 266  :     char buff[256];
; 267  :     uint_64 fvalue[2];
; 268  :     int reg;
; 269  :     int reg2;
; 270  :     int i;
; 271  :     int j = 0;

	mov	DWORD PTR j$[rsp], 0

; 272  : 	int tCount = 0;

	mov	DWORD PTR tCount$[rsp], 0

; 273  : 	int freevecregs = 0;

	mov	DWORD PTR freevecregs$[rsp], 0

; 274  : 	int vecidx = -1;

	mov	DWORD PTR vecidx$[rsp], -1

; 275  :     int membersize = 0;     /* used for vectorcall array */

	mov	DWORD PTR membersize$[rsp], 0

; 276  :     int memberCount= 0;     /* used for vectorcall array */

	mov	DWORD PTR memberCount$[rsp], 0

; 277  :     int base;
; 278  :     struct proc_info *info = proc->e.procinfo; 

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR info$[rsp], rax

; 279  :     struct dsym *t = NULL; /* used for vectorcall array member size */

	mov	QWORD PTR t$[rsp], 0

; 280  :     bool destroyed = FALSE;

	mov	BYTE PTR destroyed$[rsp], 0

; 281  :     struct asym *sym;
; 282  : 
; 283  :     DebugMsg1(("ms64_param(%s, index=%u, param.memtype=%Xh, addr=%u) enter\n", proc->sym.name, index, param->sym.mem_type, addr ));

	movzx	eax, BYTE PTR addr$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR param$[rsp]
	mov	r9d, DWORD PTR [rax+44]
	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11312
	call	DoDebugMsg1

; 284  :     /* v2.11: default size is 32-bit, not 64-bit */
; 285  :     if ( param->sym.is_vararg ) {

	mov	rax, QWORD PTR param$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN69@ms64_param

; 286  :         psize = 0;

	mov	DWORD PTR psize$[rsp], 0

; 287  :         
; 288  :         if ( addr || opnd->instr == T_OFFSET )

	movzx	eax, BYTE PTR addr$[rsp]
	test	eax, eax
	jne	SHORT $LN73@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+56], 241			; 000000f1H
	jne	SHORT $LN71@ms64_param
$LN73@ms64_param:

; 289  :             psize = 8;

	mov	DWORD PTR psize$[rsp], 8
	jmp	SHORT $LN72@ms64_param
$LN71@ms64_param:

; 290  :         else if ( opnd->kind == EXPR_REG && opnd->indirect == FALSE )

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN74@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN74@ms64_param

; 291  :             psize = SizeFromRegister( opnd->base_reg->tokval );

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	ecx, DWORD PTR [rax+16]
	call	SizeFromRegister
	mov	DWORD PTR psize$[rsp], eax
	jmp	SHORT $LN75@ms64_param
$LN74@ms64_param:

; 292  :         else if ( opnd->mem_type != MT_EMPTY )

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	je	SHORT $LN76@ms64_param

; 293  :             psize = SizeFromMemtype( opnd->mem_type, USE64, opnd->type );

	mov	rax, QWORD PTR opnd$[rsp]
	mov	r8, QWORD PTR [rax+96]
	mov	edx, 2
	mov	rax, QWORD PTR opnd$[rsp]
	mov	ecx, DWORD PTR [rax+64]
	call	SizeFromMemtype
	mov	DWORD PTR psize$[rsp], eax
$LN76@ms64_param:
$LN75@ms64_param:
$LN72@ms64_param:

; 294  :         if ( psize < 4 )

	cmp	DWORD PTR psize$[rsp], 4
	jae	SHORT $LN77@ms64_param

; 295  :             psize = 4;

	mov	DWORD PTR psize$[rsp], 4
$LN77@ms64_param:

; 296  : 
; 297  :     } else

	jmp	SHORT $LN70@ms64_param
$LN69@ms64_param:

; 298  :         psize = SizeFromMemtype( param->sym.mem_type, USE64, param->sym.type );

	mov	rax, QWORD PTR param$[rsp]
	mov	r8, QWORD PTR [rax+88]
	mov	edx, 2
	mov	rax, QWORD PTR param$[rsp]
	mov	ecx, DWORD PTR [rax+44]
	call	SizeFromMemtype
	mov	DWORD PTR psize$[rsp], eax
$LN70@ms64_param:

; 299  : 
; 300  : 	if (vcallpass == 1)

	cmp	DWORD PTR vcallpass, 1
	jne	SHORT $LN78@ms64_param

; 301  : 		goto vcall;

	jmp	$vcall$351
$LN78@ms64_param:

; 302  : 
; 303  :     /* check for register overwrites; v2.11: moved out the if( index >= 4 ) block */
; 304  :     if ( opnd->base_reg != NULL ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	$LN79@ms64_param

; 305  :         reg = opnd->base_reg->tokval;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR reg$[rsp], eax

; 306  :         if ( GetValueSp( reg ) & OP_R ) {

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 15
	test	eax, eax
	je	$LN80@ms64_param

; 307  :             i = GetRegNo( reg );

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	DWORD PTR i$[rsp], eax

; 308  :             if ( REGPAR_WIN64 & ( 1 << i ) ) {

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv1870[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv1870[rsp]
	shl	eax, cl
	and	eax, 774				; 00000306H
	test	eax, eax
	je	SHORT $LN81@ms64_param

; 309  :                 base = GetParmIndex( i );

	cmp	DWORD PTR i$[rsp], 8
	jl	SHORT $LN333@ms64_param
	mov	eax, DWORD PTR i$[rsp]
	sub	eax, 6
	mov	DWORD PTR tv160[rsp], eax
	jmp	SHORT $LN334@ms64_param
$LN333@ms64_param:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR tv160[rsp], eax
$LN334@ms64_param:
	mov	eax, DWORD PTR tv160[rsp]
	mov	DWORD PTR base$[rsp], eax

; 310  :                 if ( *regs_used & ( 1 << ( base + RPAR_START ) ) )

	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	ecx, DWORD PTR base$[rsp]
	add	ecx, 3
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN83@ms64_param

; 311  :                     destroyed = TRUE;

	mov	BYTE PTR destroyed$[rsp], 1
$LN83@ms64_param:

; 312  :             } else if ( (*regs_used & R0_USED ) && ( ( GetValueSp( reg ) & OP_A ) || reg == T_AH ) ) {

	jmp	SHORT $LN82@ms64_param
$LN81@ms64_param:
	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN84@ms64_param
	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 512				; 00000200H
	test	eax, eax
	jne	SHORT $LN85@ms64_param
	cmp	DWORD PTR reg$[rsp], 5
	jne	SHORT $LN84@ms64_param
$LN85@ms64_param:

; 313  :                 destroyed = TRUE;

	mov	BYTE PTR destroyed$[rsp], 1
$LN84@ms64_param:
$LN82@ms64_param:
$LN80@ms64_param:
$LN79@ms64_param:

; 314  :             }
; 315  :         }
; 316  :     }
; 317  :     if ( opnd->idx_reg != NULL ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+32], 0
	je	$LN86@ms64_param

; 318  :         reg2 = opnd->idx_reg->tokval;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR reg2$[rsp], eax

; 319  :         if ( GetValueSp( reg2 ) & OP_R ) {

	movsxd	rax, DWORD PTR reg2$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 15
	test	eax, eax
	je	$LN87@ms64_param

; 320  :             i = GetRegNo( reg2 );

	movsxd	rax, DWORD PTR reg2$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	DWORD PTR i$[rsp], eax

; 321  :             if ( REGPAR_WIN64 & ( 1 << i ) ) {

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv1890[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv1890[rsp]
	shl	eax, cl
	and	eax, 774				; 00000306H
	test	eax, eax
	je	SHORT $LN88@ms64_param

; 322  :                 base = GetParmIndex( i );

	cmp	DWORD PTR i$[rsp], 8
	jl	SHORT $LN335@ms64_param
	mov	eax, DWORD PTR i$[rsp]
	sub	eax, 6
	mov	DWORD PTR tv197[rsp], eax
	jmp	SHORT $LN336@ms64_param
$LN335@ms64_param:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR tv197[rsp], eax
$LN336@ms64_param:
	mov	eax, DWORD PTR tv197[rsp]
	mov	DWORD PTR base$[rsp], eax

; 323  :                 if ( *regs_used & ( 1 << ( base + RPAR_START ) ) )

	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	ecx, DWORD PTR base$[rsp]
	add	ecx, 3
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN90@ms64_param

; 324  :                     destroyed = TRUE;

	mov	BYTE PTR destroyed$[rsp], 1
$LN90@ms64_param:

; 325  :             } else if ( (*regs_used & R0_USED ) && ( ( GetValueSp( reg2 ) & OP_A ) || reg2 == T_AH ) ) {

	jmp	SHORT $LN89@ms64_param
$LN88@ms64_param:
	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN91@ms64_param
	movsxd	rax, DWORD PTR reg2$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 512				; 00000200H
	test	eax, eax
	jne	SHORT $LN92@ms64_param
	cmp	DWORD PTR reg2$[rsp], 5
	jne	SHORT $LN91@ms64_param
$LN92@ms64_param:

; 326  :                 destroyed = TRUE;

	mov	BYTE PTR destroyed$[rsp], 1
$LN91@ms64_param:
$LN89@ms64_param:
$LN87@ms64_param:
$LN86@ms64_param:

; 327  :             }
; 328  :         }
; 329  :     }
; 330  :     if ( destroyed ) {

	movzx	eax, BYTE PTR destroyed$[rsp]
	test	eax, eax
	je	SHORT $LN93@ms64_param

; 331  :         EmitErr( REGISTER_VALUE_OVERWRITTEN_BY_INVOKE );

	mov	ecx, 165				; 000000a5H
	call	EmitErr

; 332  :         *regs_used = 0;

	mov	rax, QWORD PTR regs_used$[rsp]
	mov	BYTE PTR [rax], 0
$LN93@ms64_param:

; 333  :     }
; 334  :     if (((proc->sym.langtype == LANG_VECTORCALL)&&( index >= 6 ))||

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	SHORT $LN97@ms64_param
	cmp	DWORD PTR index$[rsp], 6
	jge	SHORT $LN96@ms64_param
$LN97@ms64_param:
	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 7
	jne	$LN94@ms64_param
	cmp	DWORD PTR index$[rsp], 4
	jl	$LN94@ms64_param
$LN96@ms64_param:

; 335  :     ((proc->sym.langtype == LANG_FASTCALL)&&( index >= 4 ))) {
; 336  :         if ( addr  ) { //|| psize > 8

	movzx	eax, BYTE PTR addr$[rsp]
	test	eax, eax
	je	$LN98@ms64_param

; 337  :             if ( psize == 4 )

	cmp	DWORD PTR psize$[rsp], 4
	jne	SHORT $LN99@ms64_param

; 338  :                 i = T_EAX;

	mov	DWORD PTR i$[rsp], 17
	jmp	SHORT $LN100@ms64_param
$LN99@ms64_param:

; 339  :             else {
; 340  :                 i = T_RAX;

	mov	DWORD PTR i$[rsp], 115			; 00000073H

; 341  :                 if ( psize < 8 )

	cmp	DWORD PTR psize$[rsp], 8
	jae	SHORT $LN101@ms64_param

; 342  :                     EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, index+1 );

	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	edx, eax
	mov	ecx, 145				; 00000091H
	call	EmitErr
$LN101@ms64_param:
$LN100@ms64_param:

; 343  :             }
; 344  :             *regs_used |= R0_USED;

	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR regs_used$[rsp]
	mov	BYTE PTR [rcx], al

; 345  :             AddLineQueueX( " lea %r, %s", i, paramvalue );

	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11346
	call	AddLineQueueX

; 346  :             AddLineQueueX( " mov [%r+%u], %r", T_RSP, NUMQUAL index*8, i );

	mov	eax, DWORD PTR index$[rsp]
	shl	eax, 3
	mov	r9d, DWORD PTR i$[rsp]
	mov	r8d, eax
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG11347
	call	AddLineQueueX

; 347  :             DebugMsg(("ms64_param(%s, param=%u): ADDR flags=%X\n", proc->sym.name, index, *regs_used ));

	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	r9d, eax
	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11348
	call	DoDebugMsg

; 348  :             return( 1 );

	mov	eax, 1
	jmp	$LN1@ms64_param
$LN98@ms64_param:

; 349  :         }
; 350  :         if ( opnd->kind == EXPR_CONST ||

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 0
	je	SHORT $LN104@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	$LN102@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	$LN102@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	jne	$LN102@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+56], 241			; 000000f1H
	je	$LN102@ms64_param
$LN104@ms64_param:

; 351  :            ( opnd->kind == EXPR_ADDR && opnd->indirect == FALSE && opnd->mem_type == MT_EMPTY && opnd->instr != T_OFFSET ) ) {
; 352  :             /* v2.06: support 64-bit constants for params > 4 */
; 353  :             if ( psize == 8 &&

	cmp	DWORD PTR psize$[rsp], 8
	jne	$LN105@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax], 2147483647		; 7fffffffH
	jg	SHORT $LN107@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax], -2147483648		; ffffffff80000000H
	jge	$LN105@ms64_param
$LN107@ms64_param:

; 354  :                 ( opnd->value64 > LONG_MAX || opnd->value64 < LONG_MIN ) ) {
; 355  :                 AddLineQueueX( " mov %r ptr [%r+%u], %r ( %s )", T_DWORD, T_RSP, NUMQUAL index*8, T_LOW32, paramvalue );

	mov	eax, DWORD PTR index$[rsp]
	shl	eax, 3
	mov	rcx, QWORD PTR paramvalue$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [rsp+32], 237			; 000000edH
	mov	r9d, eax
	mov	r8d, 119				; 00000077H
	mov	edx, 209				; 000000d1H
	lea	rcx, OFFSET FLAT:$SG11355
	call	AddLineQueueX

; 356  :                 AddLineQueueX( " mov %r ptr [%r+%u], %r ( %s )", T_DWORD, T_RSP, NUMQUAL index*8+4, T_HIGH32, paramvalue );

	mov	eax, DWORD PTR index$[rsp]
	lea	eax, DWORD PTR [rax*8+4]
	mov	rcx, QWORD PTR paramvalue$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [rsp+32], 231			; 000000e7H
	mov	r9d, eax
	mov	r8d, 119				; 00000077H
	mov	edx, 209				; 000000d1H
	lea	rcx, OFFSET FLAT:$SG11356
	call	AddLineQueueX

; 357  : 				return(1);

	mov	eax, 1
	jmp	$LN1@ms64_param

; 358  :             } else {

	jmp	$LN106@ms64_param
$LN105@ms64_param:

; 359  :                 /* v2.11: no expansion if target type is a pointer and argument is an address part */
; 360  :                 if ( param->sym.mem_type == MT_PTR && opnd->kind == EXPR_ADDR && opnd->sym->state != SYM_UNDEFINED ) {

	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 195			; 000000c3H
	jne	SHORT $LN108@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN108@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+40], 0
	je	SHORT $LN108@ms64_param

; 361  :                     DebugMsg(("ms64_param(%s, param=%u): MT_PTR, type error, psize=%u\n", proc->sym.name, index, psize ));

	mov	r9d, DWORD PTR psize$[rsp]
	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11358
	call	DoDebugMsg

; 362  :                     EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, index+1 );

	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	edx, eax
	mov	ecx, 145				; 00000091H
	call	EmitErr
$LN108@ms64_param:

; 363  :                 }
; 364  :                 switch ( psize ) {

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR tv289[rsp], eax
	cmp	DWORD PTR tv289[rsp], 1
	je	SHORT $LN109@ms64_param
	cmp	DWORD PTR tv289[rsp], 2
	je	SHORT $LN110@ms64_param
	cmp	DWORD PTR tv289[rsp], 4
	je	SHORT $LN111@ms64_param
	jmp	SHORT $LN112@ms64_param
$LN109@ms64_param:

; 365  :                 case 1:   i = T_BYTE; break;

	mov	DWORD PTR i$[rsp], 205			; 000000cdH
	jmp	SHORT $LN2@ms64_param
$LN110@ms64_param:

; 366  :                 case 2:   i = T_WORD; break;

	mov	DWORD PTR i$[rsp], 207			; 000000cfH
	jmp	SHORT $LN2@ms64_param
$LN111@ms64_param:

; 367  :                 case 4:   i = T_DWORD; break;

	mov	DWORD PTR i$[rsp], 209			; 000000d1H
	jmp	SHORT $LN2@ms64_param
$LN112@ms64_param:

; 368  :                 default:  i = T_QWORD; break;

	mov	DWORD PTR i$[rsp], 213			; 000000d5H
$LN2@ms64_param:

; 369  :                 }
; 370  :                 AddLineQueueX( " mov %r ptr [%r+%u], %s", i, T_RSP, NUMQUAL index*8, paramvalue );

	mov	eax, DWORD PTR index$[rsp]
	shl	eax, 3
	mov	rcx, QWORD PTR paramvalue$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, eax
	mov	r8d, 119				; 00000077H
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11363
	call	AddLineQueueX

; 371  : 				return(1);

	mov	eax, 1
	jmp	$LN1@ms64_param
$LN106@ms64_param:

; 372  :             }
; 373  :             DebugMsg(("ms64_param(%s, param=%u): MT_EMPTY size.p=%u flags=%X\n", proc->sym.name, index, psize, *regs_used ));

	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR psize$[rsp]
	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11364
	call	DoDebugMsg
	jmp	$LN103@ms64_param
$LN102@ms64_param:

; 374  : 
; 375  :         } else if ( opnd->kind == EXPR_FLOAT  ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 3
	jne	$LN113@ms64_param

; 376  :             if ( param->sym.mem_type == MT_REAL8 ) {

	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 39			; 00000027H
	jne	SHORT $LN115@ms64_param

; 377  :                 AddLineQueueX( " mov %r ptr [%r+%u+0], %r (%s)", T_DWORD, T_RSP, NUMQUAL index*8, T_LOW32, paramvalue );

	mov	eax, DWORD PTR index$[rsp]
	shl	eax, 3
	mov	rcx, QWORD PTR paramvalue$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [rsp+32], 237			; 000000edH
	mov	r9d, eax
	mov	r8d, 119				; 00000077H
	mov	edx, 209				; 000000d1H
	lea	rcx, OFFSET FLAT:$SG11369
	call	AddLineQueueX

; 378  :                 AddLineQueueX( " mov %r ptr [%r+%u+4], %r (%s)", T_DWORD, T_RSP, NUMQUAL index*8, T_HIGH32, paramvalue );

	mov	eax, DWORD PTR index$[rsp]
	shl	eax, 3
	mov	rcx, QWORD PTR paramvalue$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [rsp+32], 231			; 000000e7H
	mov	r9d, eax
	mov	r8d, 119				; 00000077H
	mov	edx, 209				; 000000d1H
	lea	rcx, OFFSET FLAT:$SG11370
	call	AddLineQueueX

; 379  : 				return(1);

	mov	eax, 1
	jmp	$LN1@ms64_param

; 380  : 			}

	jmp	SHORT $LN116@ms64_param
$LN115@ms64_param:

; 381  : 			else {
; 382  : 				AddLineQueueX(" mov %r ptr [%r+%u], %s", T_DWORD, T_RSP, NUMQUAL index * 8, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	shl	eax, 3
	mov	rcx, QWORD PTR paramvalue$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, eax
	mov	r8d, 119				; 00000077H
	mov	edx, 209				; 000000d1H
	lea	rcx, OFFSET FLAT:$SG11371
	call	AddLineQueueX

; 383  : 				return(1);

	mov	eax, 1
	jmp	$LN1@ms64_param
$LN116@ms64_param:

; 384  : 			}
; 385  : 
; 386  :         } else { /* it's a register or variable */

	jmp	$LN114@ms64_param
$LN113@ms64_param:

; 387  : 
; 388  :             if ( opnd->kind == EXPR_REG && opnd->indirect == FALSE ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	$LN117@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	$LN117@ms64_param

; 389  :                 size = SizeFromRegister( reg );

	mov	ecx, DWORD PTR reg$[rsp]
	call	SizeFromRegister
	mov	DWORD PTR size$[rsp], eax

; 390  :                 if ( size == psize )

	mov	eax, DWORD PTR psize$[rsp]
	cmp	DWORD PTR size$[rsp], eax
	jne	SHORT $LN119@ms64_param

; 391  :                     i = reg;

	mov	eax, DWORD PTR reg$[rsp]
	mov	DWORD PTR i$[rsp], eax
	jmp	$LN120@ms64_param
$LN119@ms64_param:

; 392  :                 else {
; 393  :                     if ( size > psize || ( size < psize && param->sym.mem_type == MT_PTR ) ) {

	mov	eax, DWORD PTR psize$[rsp]
	cmp	DWORD PTR size$[rsp], eax
	ja	SHORT $LN122@ms64_param
	mov	eax, DWORD PTR psize$[rsp]
	cmp	DWORD PTR size$[rsp], eax
	jae	SHORT $LN121@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 195			; 000000c3H
	jne	SHORT $LN121@ms64_param
$LN122@ms64_param:

; 394  :                         DebugMsg(("ms64_param(%s, param=%u): type error size.p/a=%u/%u flags=%X\n", proc->sym.name, index, psize, size, *regs_used ));

	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR size$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR psize$[rsp]
	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11378
	call	DoDebugMsg

; 395  :                         EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, index+1 );

	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	edx, eax
	mov	ecx, 145				; 00000091H
	call	EmitErr

; 396  :                         psize = size;

	mov	eax, DWORD PTR size$[rsp]
	mov	DWORD PTR psize$[rsp], eax
$LN121@ms64_param:

; 397  :                     }
; 398  :                     switch ( psize ) {

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR tv353[rsp], eax
	cmp	DWORD PTR tv353[rsp], 1
	je	SHORT $LN123@ms64_param
	cmp	DWORD PTR tv353[rsp], 2
	je	SHORT $LN124@ms64_param
	cmp	DWORD PTR tv353[rsp], 4
	je	SHORT $LN125@ms64_param
	jmp	SHORT $LN126@ms64_param
$LN123@ms64_param:

; 399  :                     case 1:  i = T_AL;  break;

	mov	DWORD PTR i$[rsp], 1
	jmp	SHORT $LN4@ms64_param
$LN124@ms64_param:

; 400  :                     case 2:  i = T_AX;  break;

	mov	DWORD PTR i$[rsp], 9
	jmp	SHORT $LN4@ms64_param
$LN125@ms64_param:

; 401  :                     case 4:  i = T_EAX; break;

	mov	DWORD PTR i$[rsp], 17
	jmp	SHORT $LN4@ms64_param
$LN126@ms64_param:

; 402  :                     default: i = T_RAX; break;

	mov	DWORD PTR i$[rsp], 115			; 00000073H
$LN4@ms64_param:

; 403  :                     }
; 404  :                     *regs_used |= R0_USED;

	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR regs_used$[rsp]
	mov	BYTE PTR [rcx], al
$LN120@ms64_param:

; 405  :                 }
; 406  :                 DebugMsg(("ms64_param(%s, param=%u): REG size.p/a=%u/%u flags=%X\n", proc->sym.name, index, psize, size, *regs_used ));

	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR size$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR psize$[rsp]
	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11383
	call	DoDebugMsg

; 407  :             } else {

	jmp	$LN118@ms64_param
$LN117@ms64_param:

; 408  :                 if ( opnd->mem_type == MT_EMPTY )

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	jne	SHORT $LN127@ms64_param

; 409  :                     size = ( opnd->instr == T_OFFSET ? 8 : 4 );

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+56], 241			; 000000f1H
	jne	SHORT $LN337@ms64_param
	mov	DWORD PTR tv375[rsp], 8
	jmp	SHORT $LN338@ms64_param
$LN337@ms64_param:
	mov	DWORD PTR tv375[rsp], 4
$LN338@ms64_param:
	mov	eax, DWORD PTR tv375[rsp]
	mov	DWORD PTR size$[rsp], eax
	jmp	SHORT $LN128@ms64_param
$LN127@ms64_param:

; 410  :                 else
; 411  :                     size = SizeFromMemtype( opnd->mem_type, USE64, opnd->type );

	mov	rax, QWORD PTR opnd$[rsp]
	mov	r8, QWORD PTR [rax+96]
	mov	edx, 2
	mov	rax, QWORD PTR opnd$[rsp]
	mov	ecx, DWORD PTR [rax+64]
	call	SizeFromMemtype
	mov	DWORD PTR size$[rsp], eax
$LN128@ms64_param:

; 412  :                 DebugMsg(("ms64_param(%s, param=%u): MEM size.p/a=%u/%u flags=%X\n", proc->sym.name, index, psize, size, *regs_used ));

	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR size$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR psize$[rsp]
	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11386
	call	DoDebugMsg

; 413  :                 switch ( psize ) {

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR tv390[rsp], eax
	cmp	DWORD PTR tv390[rsp], 1
	je	SHORT $LN129@ms64_param
	cmp	DWORD PTR tv390[rsp], 2
	je	SHORT $LN130@ms64_param
	cmp	DWORD PTR tv390[rsp], 4
	je	SHORT $LN131@ms64_param
	jmp	SHORT $LN132@ms64_param
$LN129@ms64_param:

; 414  :                 case 1:  i = T_AL;  break;

	mov	DWORD PTR i$[rsp], 1
	jmp	SHORT $LN6@ms64_param
$LN130@ms64_param:

; 415  :                 case 2:  i = T_AX;  break;

	mov	DWORD PTR i$[rsp], 9
	jmp	SHORT $LN6@ms64_param
$LN131@ms64_param:

; 416  :                 case 4:  i = T_EAX; break;

	mov	DWORD PTR i$[rsp], 17
	jmp	SHORT $LN6@ms64_param
$LN132@ms64_param:

; 417  :                 default: i = T_RAX; break;

	mov	DWORD PTR i$[rsp], 115			; 00000073H
$LN6@ms64_param:

; 418  :                 }
; 419  : 				if(proc->sym.langtype == LANG_VECTORCALL) return(1);

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	SHORT $LN133@ms64_param
	mov	eax, 1
	jmp	$LN1@ms64_param
$LN133@ms64_param:

; 420  :                 *regs_used |= R0_USED;

	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR regs_used$[rsp]
	mov	BYTE PTR [rcx], al
$LN118@ms64_param:

; 421  :             }
; 422  : 
; 423  :             /* v2.11: no expansion if target type is a pointer */
; 424  :             if ( size > psize || ( size < psize && param->sym.mem_type == MT_PTR ) ) {

	mov	eax, DWORD PTR psize$[rsp]
	cmp	DWORD PTR size$[rsp], eax
	ja	SHORT $LN135@ms64_param
	mov	eax, DWORD PTR psize$[rsp]
	cmp	DWORD PTR size$[rsp], eax
	jae	SHORT $LN134@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 195			; 000000c3H
	jne	SHORT $LN134@ms64_param
$LN135@ms64_param:

; 425  :                 EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, index+1 );

	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	edx, eax
	mov	ecx, 145				; 00000091H
	call	EmitErr
$LN134@ms64_param:

; 426  :             }
; 427  :             if ( size != psize ) {

	mov	eax, DWORD PTR psize$[rsp]
	cmp	DWORD PTR size$[rsp], eax
	je	$LN136@ms64_param

; 428  :                 if ( size == 4 ) {

	cmp	DWORD PTR size$[rsp], 4
	jne	SHORT $LN138@ms64_param

; 429  :                     if ( IS_SIGNED( opnd->mem_type ) )

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN140@ms64_param

; 430  :                         AddLineQueueX( " movsxd %r, %s", i, paramvalue );

	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11400
	call	AddLineQueueX
	jmp	SHORT $LN141@ms64_param
$LN140@ms64_param:

; 431  :                     else
; 432  :                         AddLineQueueX( " mov %r, %s", i, paramvalue );

	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11401
	call	AddLineQueueX
$LN141@ms64_param:

; 433  :                 } else

	jmp	SHORT $LN139@ms64_param
$LN138@ms64_param:

; 434  :                     AddLineQueueX( " mov%sx %r, %s", IS_SIGNED( opnd->mem_type ) ? "s" : "z", i, paramvalue );

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN339@ms64_param
	lea	rax, OFFSET FLAT:$SG11402
	mov	QWORD PTR tv422[rsp], rax
	jmp	SHORT $LN340@ms64_param
$LN339@ms64_param:
	lea	rax, OFFSET FLAT:$SG11403
	mov	QWORD PTR tv422[rsp], rax
$LN340@ms64_param:
	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	r8d, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR tv422[rsp]
	lea	rcx, OFFSET FLAT:$SG11404
	call	AddLineQueueX
$LN139@ms64_param:

; 435  :             } else if ( opnd->kind != EXPR_REG || opnd->indirect == TRUE )

	jmp	SHORT $LN137@ms64_param
$LN136@ms64_param:
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN143@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN142@ms64_param
$LN143@ms64_param:

; 436  :                 AddLineQueueX( " mov %r, %s", i, paramvalue );

	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11407
	call	AddLineQueueX
$LN142@ms64_param:
$LN137@ms64_param:

; 437  : 
; 438  :             AddLineQueueX( " mov [%r+%u], %r", T_RSP, NUMQUAL index*8, i );

	mov	eax, DWORD PTR index$[rsp]
	shl	eax, 3
	mov	r9d, DWORD PTR i$[rsp]
	mov	r8d, eax
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG11408
	call	AddLineQueueX

; 439  : 			return(1);

	mov	eax, 1
	jmp	$LN1@ms64_param
$LN114@ms64_param:
$LN103@ms64_param:

; 440  :         }

	jmp	$LN95@ms64_param
$LN94@ms64_param:

; 441  : 
; 442  :     } else if ( param->sym.mem_type == MT_REAL4 ||

	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 35			; 00000023H
	je	SHORT $LN145@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 39			; 00000027H
	jne	$LN144@ms64_param
$LN145@ms64_param:

; 443  :                param->sym.mem_type == MT_REAL8 ) {
; 444  :         /* v2.04: check if argument is the correct XMM register already */
; 445  :         if ( opnd->kind == EXPR_REG && opnd->indirect == FALSE ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	$LN146@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	$LN146@ms64_param

; 446  :             if ( GetValueSp( reg ) & OP_XMM ) {

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	$LN148@ms64_param

; 447  :                  if (proc->sym.langtype == LANG_VECTORCALL)

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	SHORT $LN149@ms64_param

; 448  :                      info->vregs[index] = 1;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+68], 1
$LN149@ms64_param:

; 449  :                 if ( reg == T_XMM0 + index )

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	cmp	DWORD PTR reg$[rsp], eax
	jne	SHORT $LN150@ms64_param

; 450  :                     DebugMsg(("ms64_param(%s, param=%u): argument optimized\n", proc->sym.name, index ));

	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11417
	call	DoDebugMsg
	jmp	SHORT $LN151@ms64_param
$LN150@ms64_param:

; 451  : 				else
; 452  : 				{
; 453  : 					if (param->sym.mem_type == MT_REAL4)

	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 35			; 00000023H
	jne	SHORT $LN152@ms64_param

; 454  : 						AddLineQueueX(" movd %r, %s", T_XMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11420
	call	AddLineQueueX
	jmp	SHORT $LN153@ms64_param
$LN152@ms64_param:

; 455  : 					else
; 456  : 						AddLineQueueX(" movq %r, %s", T_XMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11421
	call	AddLineQueueX
$LN153@ms64_param:
$LN151@ms64_param:

; 457  : 				}
; 458  :                 return( 1 );

	mov	eax, 1
	jmp	$LN1@ms64_param
$LN148@ms64_param:

; 459  :             }
; 460  :         }

	jmp	$LN147@ms64_param
$LN146@ms64_param:

; 461  : 		else if (opnd->kind == EXPR_REG && opnd->indirect == TRUE) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	$LN154@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	cmp	eax, 1
	jne	$LN154@ms64_param

; 462  : 			//if (GetValueSp(reg) & OP_XMM) {
; 463  : 				if (reg == T_XMM0 + index)

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	cmp	DWORD PTR reg$[rsp], eax
	jne	SHORT $LN155@ms64_param

; 464  : 					DebugMsg(("ms64_param(%s, param=%u): argument optimized\n", proc->sym.name, index));

	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11425
	call	DoDebugMsg
	jmp	SHORT $LN156@ms64_param
$LN155@ms64_param:

; 465  : 				else
; 466  : 				{
; 467  : 					if(param->sym.mem_type == MT_REAL4)

	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 35			; 00000023H
	jne	SHORT $LN157@ms64_param

; 468  : 						AddLineQueueX(" movd %r, %s", T_XMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11428
	call	AddLineQueueX
	jmp	SHORT $LN158@ms64_param
$LN157@ms64_param:

; 469  : 					else
; 470  : 						AddLineQueueX(" movq %r, %s", T_XMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11429
	call	AddLineQueueX
$LN158@ms64_param:
$LN156@ms64_param:

; 471  : 				}
; 472  : 				return(1);

	mov	eax, 1
	jmp	$LN1@ms64_param
$LN154@ms64_param:
$LN147@ms64_param:

; 473  : 			//}
; 474  : 		}
; 475  : 
; 476  : 		if ( opnd->kind == EXPR_FLOAT ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 3
	jne	$LN159@ms64_param

; 477  : 			if (proc->sym.langtype == LANG_VECTORCALL)

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	SHORT $LN160@ms64_param

; 478  : 			{
; 479  : 				info->vregs[index] = 1;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+68], 1

; 480  : 				info->xyzused[index] = 1; /* JPH */

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1
$LN160@ms64_param:

; 481  : 			}
; 482  :             *regs_used |= R0_USED;

	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR regs_used$[rsp]
	mov	BYTE PTR [rcx], al

; 483  :             if ( param->sym.mem_type == MT_REAL4 ) {

	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 35			; 00000023H
	jne	SHORT $LN161@ms64_param

; 484  :                 
; 485  :                 AddLineQueueX( "mov %r, %s", T_EAX, paramvalue );

	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, 17
	lea	rcx, OFFSET FLAT:$SG11434
	call	AddLineQueueX

; 486  :                 AddLineQueueX( "vmovd %r, %r", T_XMM0 + index, T_EAX );

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	mov	r8d, 17
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11435
	call	AddLineQueueX

; 487  : 				return(1);

	mov	eax, 1
	jmp	$LN1@ms64_param

; 488  :             } else {

	jmp	SHORT $LN162@ms64_param
$LN161@ms64_param:

; 489  :                 AddLineQueueX( "mov %r, %r ptr %s", T_RAX, T_REAL8, paramvalue );

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	r8d, 215				; 000000d7H
	mov	edx, 115				; 00000073H
	lea	rcx, OFFSET FLAT:$SG11436
	call	AddLineQueueX

; 490  :                 AddLineQueueX( "vmovq %r, %r", T_XMM0 + index, T_RAX );

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	mov	r8d, 115				; 00000073H
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11437
	call	AddLineQueueX

; 491  : 				return(1);

	mov	eax, 1
	jmp	$LN1@ms64_param
$LN162@ms64_param:
$LN159@ms64_param:

; 492  :             }
; 493  :         } 
; 494  :         if ( opnd->kind == EXPR_ADDR ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	$LN163@ms64_param

; 495  : 			if (proc->sym.langtype == LANG_VECTORCALL)

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	$LN164@ms64_param

; 496  : 			{
; 497  : 				*regs_used |= R0_USED;

	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR regs_used$[rsp]
	mov	BYTE PTR [rcx], al

; 498  : 				info->vregs[index] = 1;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+68], 1

; 499  : 				info->xyzused[index] = 1; /* JPH */

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1

; 500  : 				if (opnd->sym->mem_type == MT_REAL8)

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+44], 39			; 00000027H
	jne	SHORT $LN166@ms64_param

; 501  : 					AddLineQueueX("vmovsd %r,qword ptr %s", T_XMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11443
	call	AddLineQueueX
	jmp	SHORT $LN167@ms64_param
$LN166@ms64_param:

; 502  : 				else
; 503  : 					AddLineQueueX("vmovss %r,dword ptr %s", T_XMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11444
	call	AddLineQueueX
$LN167@ms64_param:

; 504  : 			}

	jmp	SHORT $LN165@ms64_param
$LN164@ms64_param:

; 505  : 			else
; 506  : 			{
; 507  : 				if (param->sym.mem_type == MT_REAL8)

	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 39			; 00000027H
	jne	SHORT $LN168@ms64_param

; 508  : 					AddLineQueueX("movq %r,qword ptr %s", T_XMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11447
	call	AddLineQueueX
	jmp	SHORT $LN169@ms64_param
$LN168@ms64_param:

; 509  : 				else if (param->sym.mem_type == MT_REAL4)

	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 35			; 00000023H
	jne	SHORT $LN170@ms64_param

; 510  : 					AddLineQueueX("movd %r,dword ptr %s", T_XMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11449
	call	AddLineQueueX
$LN170@ms64_param:
$LN169@ms64_param:
$LN165@ms64_param:

; 511  : 			}
; 512  : 			return(1);

	mov	eax, 1
	jmp	$LN1@ms64_param
$LN163@ms64_param:
$LN144@ms64_param:
$LN95@ms64_param:

; 513  :         } 
; 514  :       } 
; 515  : 	if(vcallpass==1)

	cmp	DWORD PTR vcallpass, 1
	jne	SHORT $LN171@ms64_param

; 516  : 		goto vcalldone;

	jmp	$vcalldone$352
$LN171@ms64_param:
$vcall$351:

; 517  : 
; 518  : vcall:     
; 519  : 	  if ((proc->sym.langtype == LANG_VECTORCALL) && (psize == 8) && (param->sym.ttype != 0) && (param->sym.ttype->e.structinfo->isHFA) && (param->sym.mem_type == MT_TYPE)) {

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	$LN172@ms64_param
	cmp	DWORD PTR psize$[rsp], 8
	jne	$LN172@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	$LN172@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+22]
	test	eax, eax
	je	$LN172@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 196			; 000000c4H
	jne	$LN172@ms64_param

; 520  :           /* it can be only HFA data type made of 2 REAL4 */
; 521  :           t = param->sym.ttype;   

	mov	rax, QWORD PTR param$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR t$[rsp], rax

; 522  : 		  if (t != 0 && t->e.structinfo->isHFA && (vcallpass == 1))

	cmp	QWORD PTR t$[rsp], 0
	je	$LN174@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+22]
	test	eax, eax
	je	$LN174@ms64_param
	cmp	DWORD PTR vcallpass, 1
	jne	$LN174@ms64_param

; 523  : 		  {
; 524  :       
; 525  : 			  freevecregs = 0;

	mov	DWORD PTR freevecregs$[rsp], 0

; 526  : 			  vecidx = -1;

	mov	DWORD PTR vecidx$[rsp], -1

; 527  : 			  for (i = 0; i < 6; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN10@ms64_param
$LN8@ms64_param:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@ms64_param:
	cmp	DWORD PTR i$[rsp], 6
	jge	SHORT $LN9@ms64_param

; 528  : 			  {
; 529  : 				  if (info->vregs[i] == 0)

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+68]
	test	eax, eax
	jne	SHORT $LN175@ms64_param

; 530  : 				  {
; 531  : 					  if (vecidx == -1) vecidx = i;

	cmp	DWORD PTR vecidx$[rsp], -1
	jne	SHORT $LN176@ms64_param
	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR vecidx$[rsp], eax
$LN176@ms64_param:

; 532  : 					  freevecregs++;

	mov	eax, DWORD PTR freevecregs$[rsp]
	inc	eax
	mov	DWORD PTR freevecregs$[rsp], eax
$LN175@ms64_param:

; 533  : 				  }
; 534  : 			  }

	jmp	SHORT $LN8@ms64_param
$LN9@ms64_param:

; 535  : 
; 536  : 			  memberCount = t->e.structinfo->memberCount;

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR memberCount$[rsp], eax

; 537  : 			  if (memberCount > freevecregs) goto uselea;

	mov	eax, DWORD PTR freevecregs$[rsp]
	cmp	DWORD PTR memberCount$[rsp], eax
	jle	SHORT $LN177@ms64_param
	jmp	$uselea$353
$LN177@ms64_param:

; 538  : 			  membersize = psize / memberCount;     //get the size of a single element which is REAL4 in this case        

	xor	edx, edx
	mov	eax, DWORD PTR psize$[rsp]
	div	DWORD PTR memberCount$[rsp]
	mov	DWORD PTR membersize$[rsp], eax

; 539  : 			  j = 0;

	mov	DWORD PTR j$[rsp], 0

; 540  : 			  tCount = memberCount;

	mov	eax, DWORD PTR memberCount$[rsp]
	mov	DWORD PTR tCount$[rsp], eax
$LN11@ms64_param:

; 541  : 			  while (tCount > 0)

	cmp	DWORD PTR tCount$[rsp], 0
	jle	$LN12@ms64_param

; 542  : 			  {
; 543  : 				  if (info->vregs[vecidx] == 0)

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+68]
	test	eax, eax
	jne	$LN178@ms64_param

; 544  : 				  {
; 545  : 					  info->vregs[vecidx] = 1;

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+68], 1

; 546  : 					  info->vecregs[index] = memberCount;         //store number of members in proper location pointed by index

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	edx, BYTE PTR memberCount$[rsp]
	mov	BYTE PTR [rcx+rax+56], dl

; 547  : 					  info->vsize += membersize;                  //vsize contains total size 

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+44]
	add	eax, DWORD PTR membersize$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 548  : 					  info->vecregsize[vecidx] = membersize;      //size of data tu be put in register

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	edx, BYTE PTR membersize$[rsp]
	mov	BYTE PTR [rcx+rax+62], dl

; 549  : 					  info->xyzused[vecidx] = 1;                  //mark that the placeholder for register is used

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1

; 550  : 					  AddLineQueueX("vmovss %r,dword ptr [%s+%d]", T_XMM0 + vecidx, paramvalue, j* membersize);

	mov	eax, DWORD PTR j$[rsp]
	imul	eax, DWORD PTR membersize$[rsp]
	mov	ecx, DWORD PTR vecidx$[rsp]
	add	ecx, 40					; 00000028H
	mov	r9d, eax
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG11458
	call	AddLineQueueX

; 551  : 					  tCount--;

	mov	eax, DWORD PTR tCount$[rsp]
	dec	eax
	mov	DWORD PTR tCount$[rsp], eax

; 552  : 					  j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN178@ms64_param:

; 553  : 				  }
; 554  : 				  vecidx++;

	mov	eax, DWORD PTR vecidx$[rsp]
	inc	eax
	mov	DWORD PTR vecidx$[rsp], eax

; 555  : 			  }

	jmp	$LN11@ms64_param
$LN12@ms64_param:
$LN174@ms64_param:

; 556  : 		  }
; 557  :     }

	jmp	$LN173@ms64_param
$LN172@ms64_param:

; 558  : 	  else if ((proc->sym.langtype == LANG_VECTORCALL) && (psize == 16) && (param->sym.ttype != 0) && (param->sym.ttype->e.structinfo->isHFA) && (param->sym.mem_type == MT_TYPE)) {

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	$LN179@ms64_param
	cmp	DWORD PTR psize$[rsp], 16
	jne	$LN179@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	$LN179@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+22]
	test	eax, eax
	je	$LN179@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 196			; 000000c4H
	jne	$LN179@ms64_param

; 559  : 		  /* it can be only HFA data type made of 2 REAL8 */
; 560  : 		  t = param->sym.ttype;

	mov	rax, QWORD PTR param$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR t$[rsp], rax

; 561  : 		  if (t != 0 && t->e.structinfo->isHFA && (vcallpass == 1))

	cmp	QWORD PTR t$[rsp], 0
	je	$LN181@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+22]
	test	eax, eax
	je	$LN181@ms64_param
	cmp	DWORD PTR vcallpass, 1
	jne	$LN181@ms64_param

; 562  : 		  {
; 563  : 			  
; 564  : 			  freevecregs = 0;

	mov	DWORD PTR freevecregs$[rsp], 0

; 565  : 			  vecidx = -1;

	mov	DWORD PTR vecidx$[rsp], -1

; 566  : 			  for (i = 0; i < 6; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN15@ms64_param
$LN13@ms64_param:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN15@ms64_param:
	cmp	DWORD PTR i$[rsp], 6
	jge	SHORT $LN14@ms64_param

; 567  : 			  {
; 568  : 				  if (info->vregs[i] == 0)

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+68]
	test	eax, eax
	jne	SHORT $LN182@ms64_param

; 569  : 				  {
; 570  : 					  if (vecidx == -1) vecidx = i;

	cmp	DWORD PTR vecidx$[rsp], -1
	jne	SHORT $LN183@ms64_param
	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR vecidx$[rsp], eax
$LN183@ms64_param:

; 571  : 					  freevecregs++;

	mov	eax, DWORD PTR freevecregs$[rsp]
	inc	eax
	mov	DWORD PTR freevecregs$[rsp], eax
$LN182@ms64_param:

; 572  : 				  }
; 573  : 			  }

	jmp	SHORT $LN13@ms64_param
$LN14@ms64_param:

; 574  : 
; 575  : 			  memberCount = t->e.structinfo->memberCount;

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR memberCount$[rsp], eax

; 576  : 			  if (memberCount > freevecregs) goto uselea;

	mov	eax, DWORD PTR freevecregs$[rsp]
	cmp	DWORD PTR memberCount$[rsp], eax
	jle	SHORT $LN184@ms64_param
	jmp	$uselea$353
$LN184@ms64_param:

; 577  : 			  membersize = psize / memberCount;          //get the size of a single element which is REAL4 in this case        

	xor	edx, edx
	mov	eax, DWORD PTR psize$[rsp]
	div	DWORD PTR memberCount$[rsp]
	mov	DWORD PTR membersize$[rsp], eax

; 578  : 			  j = 0;

	mov	DWORD PTR j$[rsp], 0

; 579  : 			  tCount = memberCount;

	mov	eax, DWORD PTR memberCount$[rsp]
	mov	DWORD PTR tCount$[rsp], eax

; 580  : 			  if (membersize == 8)

	cmp	DWORD PTR membersize$[rsp], 8
	jne	$LN185@ms64_param
$LN16@ms64_param:

; 581  : 			  {
; 582  : 				  while (tCount > 0)

	cmp	DWORD PTR tCount$[rsp], 0
	jle	$LN17@ms64_param

; 583  : 				  {
; 584  : 					  if (info->vregs[vecidx] == 0)

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+68]
	test	eax, eax
	jne	$LN187@ms64_param

; 585  : 					  {
; 586  : 						  info->vregs[vecidx] = 1;

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+68], 1

; 587  : 						  info->vecregs[index] = memberCount;        //store number of members in proper location pointed by index

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	edx, BYTE PTR memberCount$[rsp]
	mov	BYTE PTR [rcx+rax+56], dl

; 588  : 						  info->vsize += membersize;                      //vsize contains total size 

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+44]
	add	eax, DWORD PTR membersize$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 589  : 						  info->vecregsize[vecidx] = membersize;      //size of data tu be put in register

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	edx, BYTE PTR membersize$[rsp]
	mov	BYTE PTR [rcx+rax+62], dl

; 590  : 						  info->xyzused[vecidx] = 1;                  //mark that the placeholder for register is used

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1

; 591  : 						  AddLineQueueX("vmovsd %r,qword ptr [%s+%d]", T_XMM0 + vecidx, paramvalue, j * membersize);

	mov	eax, DWORD PTR j$[rsp]
	imul	eax, DWORD PTR membersize$[rsp]
	mov	ecx, DWORD PTR vecidx$[rsp]
	add	ecx, 40					; 00000028H
	mov	r9d, eax
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG11468
	call	AddLineQueueX

; 592  : 						  tCount--;

	mov	eax, DWORD PTR tCount$[rsp]
	dec	eax
	mov	DWORD PTR tCount$[rsp], eax

; 593  : 						  j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN187@ms64_param:

; 594  : 					  }
; 595  : 					  vecidx++;

	mov	eax, DWORD PTR vecidx$[rsp]
	inc	eax
	mov	DWORD PTR vecidx$[rsp], eax

; 596  : 				  }

	jmp	$LN16@ms64_param
$LN17@ms64_param:

; 597  : 			  }

	jmp	$LN186@ms64_param
$LN185@ms64_param:

; 598  : 			  /* HFA data type made of 4 REAL4 */
; 599  : 			  else if (membersize == 4)

	cmp	DWORD PTR membersize$[rsp], 4
	jne	$LN188@ms64_param
$LN18@ms64_param:

; 600  : 			  {
; 601  : 				  while (tCount > 0)

	cmp	DWORD PTR tCount$[rsp], 0
	jle	$LN19@ms64_param

; 602  : 				  {
; 603  : 					  if (info->vregs[vecidx] == 0)

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+68]
	test	eax, eax
	jne	$LN189@ms64_param

; 604  : 					  {
; 605  : 						  info->vregs[vecidx] = 1;

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+68], 1

; 606  : 						  info->vecregs[index] = memberCount;         //store number of members in proper location pointed by index

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	edx, BYTE PTR memberCount$[rsp]
	mov	BYTE PTR [rcx+rax+56], dl

; 607  : 						  info->vsize += membersize;                  //vsize contains total size 

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+44]
	add	eax, DWORD PTR membersize$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 608  : 						  info->vecregsize[vecidx] = membersize;      //size of data tu be put in register

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	edx, BYTE PTR membersize$[rsp]
	mov	BYTE PTR [rcx+rax+62], dl

; 609  : 						  info->xyzused[vecidx] = 1;                  //mark that the placeholder for register is used

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1

; 610  : 						  AddLineQueueX("vmovss %r,dword ptr [%s+%d]", T_XMM0 + vecidx, paramvalue, j * membersize);

	mov	eax, DWORD PTR j$[rsp]
	imul	eax, DWORD PTR membersize$[rsp]
	mov	ecx, DWORD PTR vecidx$[rsp]
	add	ecx, 40					; 00000028H
	mov	r9d, eax
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG11471
	call	AddLineQueueX

; 611  : 						  tCount--;

	mov	eax, DWORD PTR tCount$[rsp]
	dec	eax
	mov	DWORD PTR tCount$[rsp], eax

; 612  : 						  j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN189@ms64_param:

; 613  : 					  }
; 614  : 					  vecidx++;

	mov	eax, DWORD PTR vecidx$[rsp]
	inc	eax
	mov	DWORD PTR vecidx$[rsp], eax

; 615  : 				  }

	jmp	$LN18@ms64_param
$LN19@ms64_param:
$LN188@ms64_param:
$LN186@ms64_param:
$LN181@ms64_param:

; 616  : 			  }
; 617  : 		  }
; 618  : 	  }

	jmp	$LN180@ms64_param
$LN179@ms64_param:

; 619  :       else if ((proc->sym.langtype == LANG_VECTORCALL) && (psize == 12) && (param->sym.ttype != 0) && (param->sym.ttype->e.structinfo->isHFA) && (param->sym.mem_type == MT_TYPE)) {

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	$LN190@ms64_param
	cmp	DWORD PTR psize$[rsp], 12
	jne	$LN190@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	$LN190@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+22]
	test	eax, eax
	je	$LN190@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 196			; 000000c4H
	jne	$LN190@ms64_param

; 620  : 		  /* it can be only HFA data type made of 3 REAL4 */
; 621  : 		  t = param->sym.ttype;

	mov	rax, QWORD PTR param$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR t$[rsp], rax

; 622  : 		  if (t != 0 && t->e.structinfo->isHFA && (vcallpass == 1))

	cmp	QWORD PTR t$[rsp], 0
	je	$LN192@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+22]
	test	eax, eax
	je	$LN192@ms64_param
	cmp	DWORD PTR vcallpass, 1
	jne	$LN192@ms64_param

; 623  : 		  {
; 624  : 			  freevecregs = 0;

	mov	DWORD PTR freevecregs$[rsp], 0

; 625  : 			  vecidx = -1;

	mov	DWORD PTR vecidx$[rsp], -1

; 626  : 			  for (i = 0; i < 6; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN22@ms64_param
$LN20@ms64_param:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN22@ms64_param:
	cmp	DWORD PTR i$[rsp], 6
	jge	SHORT $LN21@ms64_param

; 627  : 			  {
; 628  : 				  if (info->vregs[i] == 0)

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+68]
	test	eax, eax
	jne	SHORT $LN193@ms64_param

; 629  : 				  {
; 630  : 					  if (vecidx == -1) vecidx = i;

	cmp	DWORD PTR vecidx$[rsp], -1
	jne	SHORT $LN194@ms64_param
	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR vecidx$[rsp], eax
$LN194@ms64_param:

; 631  : 					  freevecregs++;

	mov	eax, DWORD PTR freevecregs$[rsp]
	inc	eax
	mov	DWORD PTR freevecregs$[rsp], eax
$LN193@ms64_param:

; 632  : 				  }
; 633  : 			  }

	jmp	SHORT $LN20@ms64_param
$LN21@ms64_param:

; 634  : 
; 635  : 			  memberCount = t->e.structinfo->memberCount;

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR memberCount$[rsp], eax

; 636  : 			  if (memberCount > freevecregs) goto uselea;

	mov	eax, DWORD PTR freevecregs$[rsp]
	cmp	DWORD PTR memberCount$[rsp], eax
	jle	SHORT $LN195@ms64_param
	jmp	$uselea$353
$LN195@ms64_param:

; 637  : 			  membersize = psize / memberCount;               //get the size of a single element which is REAL4 in this case        

	xor	edx, edx
	mov	eax, DWORD PTR psize$[rsp]
	div	DWORD PTR memberCount$[rsp]
	mov	DWORD PTR membersize$[rsp], eax

; 638  : 			  j = 0;

	mov	DWORD PTR j$[rsp], 0

; 639  : 			  tCount = memberCount;

	mov	eax, DWORD PTR memberCount$[rsp]
	mov	DWORD PTR tCount$[rsp], eax
$LN23@ms64_param:

; 640  : 			  while (tCount > 0)

	cmp	DWORD PTR tCount$[rsp], 0
	jle	$LN24@ms64_param

; 641  : 			  {
; 642  : 				  if (info->vregs[vecidx] == 0)

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+68]
	test	eax, eax
	jne	$LN196@ms64_param

; 643  : 				  {
; 644  : 					  info->vregs[vecidx] = 1;

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+68], 1

; 645  : 					  info->vecregs[index] = memberCount;         //store number of members in proper location pointed by index

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	edx, BYTE PTR memberCount$[rsp]
	mov	BYTE PTR [rcx+rax+56], dl

; 646  : 					  info->vsize += membersize;                  //vsize contains total size 

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+44]
	add	eax, DWORD PTR membersize$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 647  : 					  info->vecregsize[vecidx] = membersize;      //size of data tu be put in register

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	edx, BYTE PTR membersize$[rsp]
	mov	BYTE PTR [rcx+rax+62], dl

; 648  : 					  info->xyzused[vecidx] = 1;                  //mark that the placeholder for register is used

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1

; 649  : 					  AddLineQueueX("vmovss %r,dword ptr [%s+%d]", T_XMM0 + vecidx, paramvalue, j * membersize);

	mov	eax, DWORD PTR j$[rsp]
	imul	eax, DWORD PTR membersize$[rsp]
	mov	ecx, DWORD PTR vecidx$[rsp]
	add	ecx, 40					; 00000028H
	mov	r9d, eax
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG11479
	call	AddLineQueueX

; 650  : 					  tCount--;

	mov	eax, DWORD PTR tCount$[rsp]
	dec	eax
	mov	DWORD PTR tCount$[rsp], eax

; 651  : 					  j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN196@ms64_param:

; 652  : 				  }
; 653  : 				  vecidx++;

	mov	eax, DWORD PTR vecidx$[rsp]
	inc	eax
	mov	DWORD PTR vecidx$[rsp], eax

; 654  : 			  }

	jmp	$LN23@ms64_param
$LN24@ms64_param:
$LN192@ms64_param:

; 655  : 		  }
; 656  : 	  }

	jmp	$LN191@ms64_param
$LN190@ms64_param:

; 657  :       else if ((proc->sym.langtype == LANG_VECTORCALL) && (psize == 24) && (param->sym.ttype != 0) && (param->sym.ttype->e.structinfo->isHFA) && (param->sym.mem_type == MT_TYPE)) {

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	$LN197@ms64_param
	cmp	DWORD PTR psize$[rsp], 24
	jne	$LN197@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	$LN197@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+22]
	test	eax, eax
	je	$LN197@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 196			; 000000c4H
	jne	$LN197@ms64_param

; 658  : 		  /* it can be only HFA data type made of 3 REAL8 */
; 659  : 		  t = param->sym.ttype;

	mov	rax, QWORD PTR param$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR t$[rsp], rax

; 660  : 		  if (t != 0 && t->e.structinfo->isHFA && (vcallpass == 1))

	cmp	QWORD PTR t$[rsp], 0
	je	$LN199@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+22]
	test	eax, eax
	je	$LN199@ms64_param
	cmp	DWORD PTR vcallpass, 1
	jne	$LN199@ms64_param

; 661  : 		  {
; 662  : 
; 663  : 			  freevecregs = 0;

	mov	DWORD PTR freevecregs$[rsp], 0

; 664  : 			  vecidx = -1;

	mov	DWORD PTR vecidx$[rsp], -1

; 665  : 			  for (i = 0; i < 6; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN27@ms64_param
$LN25@ms64_param:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN27@ms64_param:
	cmp	DWORD PTR i$[rsp], 6
	jge	SHORT $LN26@ms64_param

; 666  : 			  {
; 667  : 				  if (info->vregs[i] == 0)

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+68]
	test	eax, eax
	jne	SHORT $LN200@ms64_param

; 668  : 				  {
; 669  : 					  if (vecidx == -1) vecidx = i;

	cmp	DWORD PTR vecidx$[rsp], -1
	jne	SHORT $LN201@ms64_param
	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR vecidx$[rsp], eax
$LN201@ms64_param:

; 670  : 					  freevecregs++;

	mov	eax, DWORD PTR freevecregs$[rsp]
	inc	eax
	mov	DWORD PTR freevecregs$[rsp], eax
$LN200@ms64_param:

; 671  : 				  }
; 672  : 			  }

	jmp	SHORT $LN25@ms64_param
$LN26@ms64_param:

; 673  : 
; 674  : 			  memberCount = t->e.structinfo->memberCount;

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR memberCount$[rsp], eax

; 675  : 			  if (memberCount > freevecregs) goto uselea;

	mov	eax, DWORD PTR freevecregs$[rsp]
	cmp	DWORD PTR memberCount$[rsp], eax
	jle	SHORT $LN202@ms64_param
	jmp	$uselea$353
$LN202@ms64_param:

; 676  : 			  membersize = psize / memberCount;          //get the size of a single element which is REAL4 in this case        

	xor	edx, edx
	mov	eax, DWORD PTR psize$[rsp]
	div	DWORD PTR memberCount$[rsp]
	mov	DWORD PTR membersize$[rsp], eax

; 677  : 			  j = 0;

	mov	DWORD PTR j$[rsp], 0

; 678  : 			  tCount = memberCount;

	mov	eax, DWORD PTR memberCount$[rsp]
	mov	DWORD PTR tCount$[rsp], eax
$LN28@ms64_param:

; 679  : 			  while (tCount > 0)

	cmp	DWORD PTR tCount$[rsp], 0
	jle	$LN29@ms64_param

; 680  : 			  {
; 681  : 				  if (info->vregs[vecidx] == 0)

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+68]
	test	eax, eax
	jne	$LN203@ms64_param

; 682  : 				  {
; 683  : 					  info->vregs[vecidx] = 1;

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+68], 1

; 684  : 					  info->vecregs[index] = memberCount;        //store number of members in proper location pointed by index

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	edx, BYTE PTR memberCount$[rsp]
	mov	BYTE PTR [rcx+rax+56], dl

; 685  : 					  info->vsize += membersize;                      //vsize contains total size 

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+44]
	add	eax, DWORD PTR membersize$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 686  : 					  info->vecregsize[vecidx] = membersize;      //size of data tu be put in register

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	edx, BYTE PTR membersize$[rsp]
	mov	BYTE PTR [rcx+rax+62], dl

; 687  : 					  info->xyzused[vecidx] = 1;                  //mark that the placeholder for register is used

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1

; 688  : 					  AddLineQueueX("vmovsd %r,qword ptr [%s+%d]", T_XMM0 + vecidx, paramvalue, j * membersize);

	mov	eax, DWORD PTR j$[rsp]
	imul	eax, DWORD PTR membersize$[rsp]
	mov	ecx, DWORD PTR vecidx$[rsp]
	add	ecx, 40					; 00000028H
	mov	r9d, eax
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG11487
	call	AddLineQueueX

; 689  : 					  tCount--;

	mov	eax, DWORD PTR tCount$[rsp]
	dec	eax
	mov	DWORD PTR tCount$[rsp], eax

; 690  : 					  j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN203@ms64_param:

; 691  : 				  }
; 692  : 				  vecidx++;

	mov	eax, DWORD PTR vecidx$[rsp]
	inc	eax
	mov	DWORD PTR vecidx$[rsp], eax

; 693  : 			  }

	jmp	$LN28@ms64_param
$LN29@ms64_param:
$LN199@ms64_param:

; 694  : 		  }
; 695  :       }

	jmp	$LN198@ms64_param
$LN197@ms64_param:

; 696  : 	  else if ((proc->sym.langtype == LANG_VECTORCALL) && (psize == 32) && (param->sym.ttype != 0) && (param->sym.ttype->e.structinfo->isHFA) && (param->sym.mem_type == MT_TYPE)) {

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	$LN204@ms64_param
	cmp	DWORD PTR psize$[rsp], 32		; 00000020H
	jne	$LN204@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	$LN204@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+22]
	test	eax, eax
	je	$LN204@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 196			; 000000c4H
	jne	$LN204@ms64_param

; 697  : 		  /* it can be only HFA data type made of 4 REAL8 */
; 698  : 		  t = param->sym.ttype;

	mov	rax, QWORD PTR param$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR t$[rsp], rax

; 699  : 		  if (t != 0 && t->e.structinfo->isHFA && (vcallpass == 1))

	cmp	QWORD PTR t$[rsp], 0
	je	$LN206@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+22]
	test	eax, eax
	je	$LN206@ms64_param
	cmp	DWORD PTR vcallpass, 1
	jne	$LN206@ms64_param

; 700  : 		  {
; 701  : 
; 702  : 			  freevecregs = 0;

	mov	DWORD PTR freevecregs$[rsp], 0

; 703  : 			  vecidx = -1;

	mov	DWORD PTR vecidx$[rsp], -1

; 704  : 			  for (i = 0; i < 6; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN32@ms64_param
$LN30@ms64_param:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN32@ms64_param:
	cmp	DWORD PTR i$[rsp], 6
	jge	SHORT $LN31@ms64_param

; 705  : 			  {
; 706  : 				  if (info->vregs[i] == 0)

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+68]
	test	eax, eax
	jne	SHORT $LN207@ms64_param

; 707  : 				  {
; 708  : 					  if (vecidx == -1) vecidx = i;

	cmp	DWORD PTR vecidx$[rsp], -1
	jne	SHORT $LN208@ms64_param
	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR vecidx$[rsp], eax
$LN208@ms64_param:

; 709  : 					  freevecregs++;

	mov	eax, DWORD PTR freevecregs$[rsp]
	inc	eax
	mov	DWORD PTR freevecregs$[rsp], eax
$LN207@ms64_param:

; 710  : 				  }
; 711  : 			  }

	jmp	SHORT $LN30@ms64_param
$LN31@ms64_param:

; 712  : 
; 713  : 			  memberCount = t->e.structinfo->memberCount;

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR memberCount$[rsp], eax

; 714  : 			  if (memberCount > freevecregs) goto uselea;

	mov	eax, DWORD PTR freevecregs$[rsp]
	cmp	DWORD PTR memberCount$[rsp], eax
	jle	SHORT $LN209@ms64_param
	jmp	$uselea$353
$LN209@ms64_param:

; 715  : 			  membersize = psize / memberCount;          //get the size of a single element which is REAL4 in this case        

	xor	edx, edx
	mov	eax, DWORD PTR psize$[rsp]
	div	DWORD PTR memberCount$[rsp]
	mov	DWORD PTR membersize$[rsp], eax

; 716  : 			  j = 0;

	mov	DWORD PTR j$[rsp], 0

; 717  : 			  tCount = memberCount;

	mov	eax, DWORD PTR memberCount$[rsp]
	mov	DWORD PTR tCount$[rsp], eax
$LN33@ms64_param:

; 718  : 			  while (tCount > 0)

	cmp	DWORD PTR tCount$[rsp], 0
	jle	$LN34@ms64_param

; 719  : 			  {
; 720  : 				  if (info->vregs[vecidx] == 0)

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+68]
	test	eax, eax
	jne	$LN210@ms64_param

; 721  : 				  {
; 722  : 					  info->vregs[vecidx] = 1;

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+68], 1

; 723  : 					  info->vecregs[index] = memberCount;        //store number of members in proper location pointed by index

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	edx, BYTE PTR memberCount$[rsp]
	mov	BYTE PTR [rcx+rax+56], dl

; 724  : 					  info->vsize += membersize;                      //vsize contains total size 

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+44]
	add	eax, DWORD PTR membersize$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 725  : 					  info->vecregsize[vecidx] = membersize;      //size of data tu be put in register

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	edx, BYTE PTR membersize$[rsp]
	mov	BYTE PTR [rcx+rax+62], dl

; 726  : 					  info->xyzused[vecidx] = 1;                  //mark that the placeholder for register is used

	movsxd	rax, DWORD PTR vecidx$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1

; 727  : 					  AddLineQueueX("vmovsd %r,qword ptr [%s+%d]", T_XMM0 + vecidx, paramvalue, j * 8);

	mov	eax, DWORD PTR j$[rsp]
	shl	eax, 3
	mov	ecx, DWORD PTR vecidx$[rsp]
	add	ecx, 40					; 00000028H
	mov	r9d, eax
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG11495
	call	AddLineQueueX

; 728  : 					  tCount--;

	mov	eax, DWORD PTR tCount$[rsp]
	dec	eax
	mov	DWORD PTR tCount$[rsp], eax

; 729  : 					  j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN210@ms64_param:

; 730  : 				  }
; 731  : 				  vecidx++;

	mov	eax, DWORD PTR vecidx$[rsp]
	inc	eax
	mov	DWORD PTR vecidx$[rsp], eax

; 732  : 			  }

	jmp	$LN33@ms64_param
$LN34@ms64_param:
$LN206@ms64_param:

; 733  : 		  }
; 734  : 	  }

	jmp	$LN205@ms64_param
$LN204@ms64_param:

; 735  : 
; 736  :       else {
; 737  :       if ( addr || psize > 8 ) { /* psize > 8 should happen only for vectorcall */

	movzx	eax, BYTE PTR addr$[rsp]
	test	eax, eax
	jne	SHORT $LN212@ms64_param
	cmp	DWORD PTR psize$[rsp], 8
	jbe	$LN211@ms64_param
$LN212@ms64_param:

; 738  : 		  if (psize >= 4) {

	cmp	DWORD PTR psize$[rsp], 4
	jb	$LN213@ms64_param

; 739  : 			  if (proc->sym.langtype == LANG_VECTORCALL) {

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	$LN215@ms64_param

; 740  : 				  if ((param->sym.mem_type == MT_TYPE)) {

	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 196			; 000000c4H
	jne	$LN217@ms64_param

; 741  : 					  t = param->sym.ttype;

	mov	rax, QWORD PTR param$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR t$[rsp], rax

; 742  : 
; 743  : 					  if (vcallpass == 0 && opnd->kind == EXPR_REG && opnd->indirect == FALSE && reg < T_XMM6 && index < 6 && info->vecregs[(reg - T_XMM0)] != 0 && (index != reg-T_XMM0))

	cmp	DWORD PTR vcallpass, 0
	jne	SHORT $LN219@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN219@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN219@ms64_param
	cmp	DWORD PTR reg$[rsp], 46			; 0000002eH
	jge	SHORT $LN219@ms64_param
	cmp	DWORD PTR index$[rsp], 6
	jge	SHORT $LN219@ms64_param
	mov	eax, DWORD PTR reg$[rsp]
	sub	eax, 40					; 00000028H
	cdqe
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+56]
	test	eax, eax
	je	SHORT $LN219@ms64_param
	mov	eax, DWORD PTR reg$[rsp]
	sub	eax, 40					; 00000028H
	cmp	DWORD PTR index$[rsp], eax
	je	SHORT $LN219@ms64_param

; 744  : 					  {
; 745  : 						  EmitErr(REGISTER_VALUE_OVERWRITTEN_BY_INVOKE, index);

	mov	edx, DWORD PTR index$[rsp]
	mov	ecx, 165				; 000000a5H
	call	EmitErr

; 746  : 						  return(1);

	mov	eax, 1
	jmp	$LN1@ms64_param
$LN219@ms64_param:

; 747  : 					  }
; 748  : 
; 749  : 					  if (t->e.structinfo->stype == MM128 && vcallpass==0) {

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+16], 1
	jne	$LN220@ms64_param
	cmp	DWORD PTR vcallpass, 0
	jne	$LN220@ms64_param

; 750  : 						  if (opnd->kind == EXPR_REG && opnd->indirect == FALSE) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	$LN222@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	$LN222@ms64_param

; 751  : 							  if ((GetValueSp(reg) & OP_XMM)|| t->e.structinfo->isHFA ) {

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN224@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+22]
	test	eax, eax
	je	$LN223@ms64_param
$LN224@ms64_param:

; 752  : 
; 753  : 								  t->e.structinfo->memberCount = 1;

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	DWORD PTR [rax+24], 1

; 754  : 								  info->vregs[index] = 1;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+68], 1

; 755  : 								  info->vecregs[index] = 1;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+56], 1

; 756  : 								  info->xyzused[index] = 1;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1

; 757  : 								  info->vsize += 16;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+44]
	add	eax, 16
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 758  : 								  info->vecregsize[index] = 16;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+62], 16

; 759  : 								  if (reg == T_XMM0 + index)

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	cmp	DWORD PTR reg$[rsp], eax
	jne	SHORT $LN225@ms64_param

; 760  : 									  DebugMsg(("ms64_param(%s, param=%u): argument optimized\n", proc->sym.name, index));

	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11512
	call	DoDebugMsg
	jmp	SHORT $LN226@ms64_param
$LN225@ms64_param:

; 761  : 								  else
; 762  : 									  AddLineQueueX("vmovaps %r,oword ptr %s", T_XMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11513
	call	AddLineQueueX
$LN226@ms64_param:

; 763  : 								  return(1);

	mov	eax, 1
	jmp	$LN1@ms64_param
$LN223@ms64_param:
$LN222@ms64_param:

; 764  : 							  }
; 765  : 						  }
; 766  : 					  }

	jmp	$LN221@ms64_param
$LN220@ms64_param:

; 767  : 					  else if (t->e.structinfo->stype == MM256 && vcallpass == 0) {

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+16], 2
	jne	$LN227@ms64_param
	cmp	DWORD PTR vcallpass, 0
	jne	$LN227@ms64_param

; 768  : 						  if (opnd->kind == EXPR_REG && opnd->indirect == FALSE) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	$LN228@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	$LN228@ms64_param

; 769  : 							  if (GetValueSp(reg) & OP_YMM) {

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	$LN229@ms64_param

; 770  : 								  t->e.structinfo->memberCount = 1;

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	DWORD PTR [rax+24], 1

; 771  : 								  info->vregs[index] = 1;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+68], 1

; 772  : 								  info->xyzused[index] = 1;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1

; 773  : 								  info->vsize += 32;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+44]
	add	eax, 32					; 00000020H
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 774  : 								  info->vecregsize[index] = 32;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+62], 32		; 00000020H

; 775  : 								  if (reg == T_YMM0 + index)

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 56					; 00000038H
	cmp	DWORD PTR reg$[rsp], eax
	jne	SHORT $LN230@ms64_param

; 776  : 									  DebugMsg(("ms64_param(%s, param=%u): argument optimized\n", proc->sym.name, index));

	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11519
	call	DoDebugMsg
	jmp	SHORT $LN231@ms64_param
$LN230@ms64_param:

; 777  : 								  else
; 778  : 									  AddLineQueueX("vmovaps %r,ymmword ptr %s", T_YMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 56					; 00000038H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11520
	call	AddLineQueueX
$LN231@ms64_param:

; 779  : 								  return(1);

	mov	eax, 1
	jmp	$LN1@ms64_param
$LN229@ms64_param:
$LN228@ms64_param:
$LN227@ms64_param:
$LN221@ms64_param:

; 780  : 							  }
; 781  : 						  }
; 782  : 					  }
; 783  : #if EVEXSUPP
; 784  : 					  else if (t->e.structinfo->stype == MM512 && vcallpass == 0) {
; 785  : 						  if (opnd->kind == EXPR_REG && opnd->indirect == FALSE) {
; 786  : 							  if (GetValueSp(reg) & OP_YMM) {
; 787  : 								  t->e.structinfo->memberCount = 1;
; 788  : 								  info->vregs[index] = 1;
; 789  : 								  info->xyzused[index] = 1;
; 790  : 								  info->vsize += 64;
; 791  : 								  info->vecregsize[index] = 64;
; 792  : 								  if (reg == T_YMM0 + index)
; 793  : 									  DebugMsg(("ms64_param(%s, param=%u): argument optimized\n", proc->sym.name, index));
; 794  : 								  else
; 795  : 									  AddLineQueueX("vmovaps %r,ymmword ptr %s", T_YMM0 + index, paramvalue);
; 796  : 								  return(1);
; 797  : 							  }
; 798  : 						  }
; 799  : 					  }
; 800  : #endif                
; 801  : 
; 802  : 					  if (t->e.structinfo->stype == MM128)

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+16], 1
	jne	SHORT $LN232@ms64_param

; 803  : 						  membersize = 16;

	mov	DWORD PTR membersize$[rsp], 16
	jmp	SHORT $LN233@ms64_param
$LN232@ms64_param:

; 804  : 					  else if (t->e.structinfo->stype == MM256)

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+16], 2
	jne	SHORT $LN234@ms64_param

; 805  : 						  membersize = 32;

	mov	DWORD PTR membersize$[rsp], 32		; 00000020H
$LN234@ms64_param:
$LN233@ms64_param:

; 806  : #if EVEXSUPP
; 807  : 					  else if (t->e.structinfo->stype == MM512)
; 808  : 						  membersize = 64;
; 809  : #endif            
; 810  : 					  memberCount = t->e.structinfo->memberCount;

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR memberCount$[rsp], eax

; 811  : 					  if (t->e.structinfo->isHVA) {

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+21]
	test	eax, eax
	je	SHORT $LN235@ms64_param

; 812  : 						  if (memberCount)

	cmp	DWORD PTR memberCount$[rsp], 0
	je	SHORT $LN237@ms64_param

; 813  : 							  membersize = psize / memberCount;

	xor	edx, edx
	mov	eax, DWORD PTR psize$[rsp]
	div	DWORD PTR memberCount$[rsp]
	mov	DWORD PTR membersize$[rsp], eax
$LN237@ms64_param:

; 814  : 					  }

	jmp	$LN236@ms64_param
$LN235@ms64_param:

; 815  : 					  else if ((t->e.structinfo->isHFA)|| (proc->e.procinfo->paralist->sym.type && proc->e.procinfo->paralist->sym.type->max_mbr_size == 4))  {

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+22]
	test	eax, eax
	jne	SHORT $LN240@ms64_param
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax+8]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN238@ms64_param
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+88]
	cmp	DWORD PTR [rax+56], 4
	jne	SHORT $LN238@ms64_param
$LN240@ms64_param:

; 816  : 						  membersize = psize;

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR membersize$[rsp], eax

; 817  : 						  memberCount = 1;

	mov	DWORD PTR memberCount$[rsp], 1

; 818  : 					  }

	jmp	SHORT $LN239@ms64_param
$LN238@ms64_param:

; 819  : 					  else if (vcallpass == 0 && t->e.structinfo->stype != MM128 && t->e.structinfo->stype != MM256) {

	cmp	DWORD PTR vcallpass, 0
	jne	SHORT $LN241@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+16], 1
	je	SHORT $LN241@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+16], 2
	je	SHORT $LN241@ms64_param

; 820  : 						  goto uselea;

	jmp	$uselea$353
$LN241@ms64_param:
$LN239@ms64_param:
$LN236@ms64_param:

; 821  : 					  }
; 822  :             if (t->e.structinfo->isHFA) memberCount = 1;

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+22]
	test	eax, eax
	je	SHORT $LN242@ms64_param
	mov	DWORD PTR memberCount$[rsp], 1
$LN242@ms64_param:

; 823  : 					  info->vecregs[index] = memberCount;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	edx, BYTE PTR memberCount$[rsp]
	mov	BYTE PTR [rcx+rax+56], dl

; 824  : 					  info->vsize += psize;

	mov	rax, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rax+44]
	add	eax, DWORD PTR psize$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 825  : 					  info->vecregsize[index] = membersize;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	edx, BYTE PTR membersize$[rsp]
	mov	BYTE PTR [rcx+rax+62], dl

; 826  : 					  if (((vcallpass == 1) && t->e.structinfo->isHVA) || t->e.structinfo->stype == MM128 || t->e.structinfo->stype == MM256) {

	cmp	DWORD PTR vcallpass, 1
	jne	SHORT $LN245@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+21]
	test	eax, eax
	jne	SHORT $LN244@ms64_param
$LN245@ms64_param:
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+16], 1
	je	SHORT $LN244@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+16], 2
	jne	$LN243@ms64_param
$LN244@ms64_param:

; 827  : 						  for (i = 0, j = 0; i < 6; i++) {

	mov	DWORD PTR i$[rsp], 0
	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN37@ms64_param
$LN35@ms64_param:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN37@ms64_param:
	cmp	DWORD PTR i$[rsp], 6
	jge	SHORT $LN36@ms64_param

; 828  : 							  j += info->vregs[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+68]
	mov	ecx, DWORD PTR j$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR j$[rsp], eax

; 829  : 							  if (info->vregs[i]) {

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+68]
	test	eax, eax
	je	SHORT $LN246@ms64_param

; 830  : 								  info->xyzused[i] = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1

; 831  : 							  }

	jmp	SHORT $LN247@ms64_param
$LN246@ms64_param:

; 832  : 							  else if ((info->vregs[i] >= 1) && (info->xyzused[i] != 1))

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+68]
	cmp	eax, 1
	jl	SHORT $LN248@ms64_param
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+74]
	cmp	eax, 1
	je	SHORT $LN248@ms64_param

; 833  : 								  info->xyzused[i] = 0;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 0
$LN248@ms64_param:
$LN247@ms64_param:

; 834  : 						  }

	jmp	$LN35@ms64_param
$LN36@ms64_param:

; 835  : 						  if (j > 6)goto uselea;

	cmp	DWORD PTR j$[rsp], 6
	jle	SHORT $LN249@ms64_param
	jmp	$uselea$353
$LN249@ms64_param:

; 836  : 						  for (i = 0, j = 0; i < 6; i++) {

	mov	DWORD PTR i$[rsp], 0
	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN40@ms64_param
$LN38@ms64_param:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN40@ms64_param:
	cmp	DWORD PTR i$[rsp], 6
	jge	SHORT $LN39@ms64_param

; 837  : 							  if (info->xyzused[i] == 0)

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+74]
	test	eax, eax
	jne	SHORT $LN250@ms64_param

; 838  : 								  j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN250@ms64_param:

; 839  : 						  }

	jmp	SHORT $LN38@ms64_param
$LN39@ms64_param:

; 840  : 						  if (vcallpass == 1 && memberCount > j && (t->e.structinfo->isHFA || t->e.structinfo->isHVA)) goto uselea;

	cmp	DWORD PTR vcallpass, 1
	jne	SHORT $LN251@ms64_param
	mov	eax, DWORD PTR j$[rsp]
	cmp	DWORD PTR memberCount$[rsp], eax
	jle	SHORT $LN251@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+22]
	test	eax, eax
	jne	SHORT $LN252@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+21]
	test	eax, eax
	je	SHORT $LN251@ms64_param
$LN252@ms64_param:
	jmp	$uselea$353
$LN251@ms64_param:

; 841  : 
; 842  : 						  switch (membersize) {

	mov	eax, DWORD PTR membersize$[rsp]
	mov	DWORD PTR tv1210[rsp], eax
	cmp	DWORD PTR tv1210[rsp], 4
	je	SHORT $LN253@ms64_param
	cmp	DWORD PTR tv1210[rsp], 8
	je	$LN256@ms64_param
	cmp	DWORD PTR tv1210[rsp], 16
	je	$LN259@ms64_param
	cmp	DWORD PTR tv1210[rsp], 32		; 00000020H
	je	$LN266@ms64_param
	jmp	$LN41@ms64_param
$LN253@ms64_param:

; 843  : 						  case 4:                             /* it could be 3 or more REAL4 */
; 844  : 							  for (i = 0, j = 0; i < membersize; i++) {

	mov	DWORD PTR i$[rsp], 0
	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN45@ms64_param
$LN43@ms64_param:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN45@ms64_param:
	mov	eax, DWORD PTR membersize$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN44@ms64_param
$LN46@ms64_param:

; 845  : 								  while (info->xyzused[j] != 0) j++;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+74]
	test	eax, eax
	je	SHORT $LN47@ms64_param
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
	jmp	SHORT $LN46@ms64_param
$LN47@ms64_param:

; 846  : 								  if (i == 0) AddLineQueueX("vmovss %r,dword ptr %s", T_XMM0 + j, paramvalue);

	cmp	DWORD PTR i$[rsp], 0
	jne	SHORT $LN254@ms64_param
	mov	eax, DWORD PTR j$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11545
	call	AddLineQueueX
	jmp	SHORT $LN255@ms64_param
$LN254@ms64_param:

; 847  : 								  else      AddLineQueueX("vmovss %r,dword ptr [%s+%d]", T_XMM0 + j, paramvalue, i * 4);

	mov	eax, DWORD PTR i$[rsp]
	shl	eax, 2
	mov	ecx, DWORD PTR j$[rsp]
	add	ecx, 40					; 00000028H
	mov	r9d, eax
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG11546
	call	AddLineQueueX
$LN255@ms64_param:

; 848  : 								  info->xyzused[j] = 1;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1

; 849  : 							  }

	jmp	$LN43@ms64_param
$LN44@ms64_param:

; 850  : 							  break;

	jmp	$LN41@ms64_param
$LN256@ms64_param:

; 851  : 						  case 8:
; 852  : 							  for (i = 0, j = 0; i < memberCount; i++) {

	mov	DWORD PTR i$[rsp], 0
	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN50@ms64_param
$LN48@ms64_param:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN50@ms64_param:
	mov	eax, DWORD PTR memberCount$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN49@ms64_param
$LN51@ms64_param:

; 853  : 								  while (info->xyzused[j] != 0) j++;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+74]
	test	eax, eax
	je	SHORT $LN52@ms64_param
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
	jmp	SHORT $LN51@ms64_param
$LN52@ms64_param:

; 854  : 								  if (i == 0) AddLineQueueX("vmovsd %r,oword ptr %s", T_XMM0 + j, paramvalue);

	cmp	DWORD PTR i$[rsp], 0
	jne	SHORT $LN257@ms64_param
	mov	eax, DWORD PTR j$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11550
	call	AddLineQueueX
	jmp	SHORT $LN258@ms64_param
$LN257@ms64_param:

; 855  : 								  else      AddLineQueueX("vmovsd %r,oword ptr [%s+%d]", T_XMM0 + j, paramvalue, i * 8);

	mov	eax, DWORD PTR i$[rsp]
	shl	eax, 3
	mov	ecx, DWORD PTR j$[rsp]
	add	ecx, 40					; 00000028H
	mov	r9d, eax
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG11551
	call	AddLineQueueX
$LN258@ms64_param:

; 856  : 								  info->xyzused[j] = 1;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1

; 857  : 							  }

	jmp	$LN48@ms64_param
$LN49@ms64_param:

; 858  : 							  break;

	jmp	$LN41@ms64_param
$LN259@ms64_param:

; 859  : 						  case 16:
; 860  : 							  if ((vcallpass == 0) && t->e.structinfo->stype == MM128)

	cmp	DWORD PTR vcallpass, 0
	jne	SHORT $LN260@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+16], 1
	jne	SHORT $LN260@ms64_param

; 861  : 							  {
; 862  : 								  AddLineQueueX("vmovaps %r,oword ptr %s", T_XMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11555
	call	AddLineQueueX

; 863  : 								  info->xyzused[index] = 1;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1

; 864  : 							  }

	jmp	$LN261@ms64_param
$LN260@ms64_param:

; 865  : 							  else if ((vcallpass == 1) && (t->e.structinfo->isHFA || t->e.structinfo->isHVA))

	cmp	DWORD PTR vcallpass, 1
	jne	$LN262@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+22]
	test	eax, eax
	jne	SHORT $LN263@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+21]
	test	eax, eax
	je	$LN262@ms64_param
$LN263@ms64_param:

; 866  : 							  {
; 867  : 								  for (i = 0, j = 0; i < memberCount; i++) {

	mov	DWORD PTR i$[rsp], 0
	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN55@ms64_param
$LN53@ms64_param:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN55@ms64_param:
	mov	eax, DWORD PTR memberCount$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN54@ms64_param
$LN56@ms64_param:

; 868  : 									  while (info->xyzused[j] != 0) j++;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+74]
	test	eax, eax
	je	SHORT $LN57@ms64_param
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
	jmp	SHORT $LN56@ms64_param
$LN57@ms64_param:

; 869  : 									  if (i == 0) AddLineQueueX("vmovaps %r,oword ptr %s", T_XMM0 + j, paramvalue);

	cmp	DWORD PTR i$[rsp], 0
	jne	SHORT $LN264@ms64_param
	mov	eax, DWORD PTR j$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11560
	call	AddLineQueueX
	jmp	SHORT $LN265@ms64_param
$LN264@ms64_param:

; 870  : 									  else      AddLineQueueX("vmovaps %r,oword ptr [%s+%d]", T_XMM0 + j, paramvalue, i * 16);

	imul	eax, DWORD PTR i$[rsp], 16
	mov	ecx, DWORD PTR j$[rsp]
	add	ecx, 40					; 00000028H
	mov	r9d, eax
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG11561
	call	AddLineQueueX
$LN265@ms64_param:

; 871  : 									  info->xyzused[j] = 1;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1

; 872  : 								  }

	jmp	$LN53@ms64_param
$LN54@ms64_param:
$LN262@ms64_param:
$LN261@ms64_param:

; 873  : 							  }
; 874  : 							  break;

	jmp	$LN41@ms64_param
$LN266@ms64_param:

; 875  : 						  case 32:
; 876  : 							  if ((vcallpass == 0) && t->e.structinfo->stype == MM256)

	cmp	DWORD PTR vcallpass, 0
	jne	SHORT $LN267@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+16], 2
	jne	SHORT $LN267@ms64_param

; 877  : 							  {
; 878  : 								  AddLineQueueX("vmovups %r,oword ptr %s", T_YMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 56					; 00000038H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11565
	call	AddLineQueueX

; 879  : 								  info->xyzused[index] = 1;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1

; 880  : 							  }

	jmp	$LN268@ms64_param
$LN267@ms64_param:

; 881  : 							  else if ((vcallpass == 1) && (t->e.structinfo->isHFA || t->e.structinfo->isHVA))

	cmp	DWORD PTR vcallpass, 1
	jne	$LN269@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+22]
	test	eax, eax
	jne	SHORT $LN270@ms64_param
	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+21]
	test	eax, eax
	je	$LN269@ms64_param
$LN270@ms64_param:

; 882  : 							  {
; 883  : 								  for (i = 0, j = 0; i < memberCount; i++) {

	mov	DWORD PTR i$[rsp], 0
	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN60@ms64_param
$LN58@ms64_param:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN60@ms64_param:
	mov	eax, DWORD PTR memberCount$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN59@ms64_param
$LN61@ms64_param:

; 884  : 									  while (info->xyzused[j] != 0) j++;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+74]
	test	eax, eax
	je	SHORT $LN62@ms64_param
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
	jmp	SHORT $LN61@ms64_param
$LN62@ms64_param:

; 885  : 									  if (i == 0) AddLineQueueX("vmovups %r,ymmword ptr %s", T_YMM0 + j, paramvalue);

	cmp	DWORD PTR i$[rsp], 0
	jne	SHORT $LN271@ms64_param
	mov	eax, DWORD PTR j$[rsp]
	add	eax, 56					; 00000038H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11570
	call	AddLineQueueX
	jmp	SHORT $LN272@ms64_param
$LN271@ms64_param:

; 886  : 									  else      AddLineQueueX("vmovups %r,ymmword ptr [%s+%d]", T_YMM0 + j, paramvalue, i * 32);

	imul	eax, DWORD PTR i$[rsp], 32		; 00000020H
	mov	ecx, DWORD PTR j$[rsp]
	add	ecx, 56					; 00000038H
	mov	r9d, eax
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG11571
	call	AddLineQueueX
$LN272@ms64_param:

; 887  : 									  info->xyzused[j] = 1;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+74], 1

; 888  : 								  }

	jmp	$LN58@ms64_param
$LN59@ms64_param:
$LN269@ms64_param:
$LN268@ms64_param:
$LN41@ms64_param:
$LN243@ms64_param:

; 889  : 							  }
; 890  : 							  break;
; 891  : #if EVEXSUPP 
; 892  : 						  case 64:
; 893  : 							  if ((vcallpass == 1) && (t->e.structinfo->isHFA || t->e.structinfo->isHVA))
; 894  : 							  {
; 895  : 								  for (i = 0, j = 0; i < memberCount; i++) {
; 896  : 									  while (info->xyzused[j] != 0) j++;
; 897  : 									  if (i == 0) AddLineQueueX("vmovups %r,zmmword ptr %s", T_ZMM0 + j, paramvalue);
; 898  : 									  else      AddLineQueueX("vmovups %r,zmmword ptr [%s+%d]", T_ZMM0 + j, paramvalue, i * 64);
; 899  : 									  info->xyzused[j] = 1;
; 900  : 								  }
; 901  : 							  }
; 902  : 							  break;
; 903  : #endif 
; 904  : 						  }
; 905  : 					  }
; 906  : 				  }

	jmp	$LN218@ms64_param
$LN217@ms64_param:

; 907  : 				  else if (vcallpass == 0) {

	cmp	DWORD PTR vcallpass, 0
	jne	$LN273@ms64_param

; 908  : 					  switch (psize) {

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR tv1354[rsp], eax
	cmp	DWORD PTR tv1354[rsp], 4
	je	SHORT $LN274@ms64_param
	cmp	DWORD PTR tv1354[rsp], 8
	je	$LN277@ms64_param
	cmp	DWORD PTR tv1354[rsp], 16
	je	$LN280@ms64_param
	cmp	DWORD PTR tv1354[rsp], 32		; 00000020H
	je	$LN286@ms64_param
	jmp	$LN63@ms64_param
$LN274@ms64_param:

; 909  : 					  case 4:
; 910  : 						  if (opnd->kind == EXPR_FLOAT) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 3
	jne	SHORT $LN275@ms64_param

; 911  : 							  AddLineQueueX("vmovss %r,dword ptr %s", T_XMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11576
	call	AddLineQueueX

; 912  : 							  info->vregs[index] = 1;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+68], 1

; 913  : 						  }

	jmp	SHORT $LN276@ms64_param
$LN275@ms64_param:

; 914  : 						  else
; 915  : 							  AddLineQueueX("mov %r, qword ptr %s", ms64_regs[index + 2 * 4], paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 8
	cdqe
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG11577
	call	AddLineQueueX
$LN276@ms64_param:

; 916  : 						  break;

	jmp	$LN63@ms64_param
$LN277@ms64_param:

; 917  : 					  case 8:
; 918  : 						  if (opnd->kind == EXPR_FLOAT) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 3
	jne	SHORT $LN278@ms64_param

; 919  : 							  AddLineQueueX("vmovsd %r,qword ptr %s", T_XMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11581
	call	AddLineQueueX

; 920  : 							  info->vregs[index] = 1;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+68], 1

; 921  : 						  }

	jmp	SHORT $LN279@ms64_param
$LN278@ms64_param:

; 922  : 						  else
; 923  : 							  AddLineQueueX("mov %r, qword ptr %s", ms64_regs[index + 2 * 4], paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 8
	cdqe
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG11582
	call	AddLineQueueX
$LN279@ms64_param:

; 924  : 						  break;

	jmp	$LN63@ms64_param
$LN280@ms64_param:

; 925  : 					  case 16:
; 926  : 						  if (opnd->kind == EXPR_REG && opnd->indirect == FALSE) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	$LN281@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN281@ms64_param

; 927  : 							  if (GetValueSp(reg) & OP_XMM) {

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN283@ms64_param

; 928  : 								  if (reg == T_XMM0 + index)

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	cmp	DWORD PTR reg$[rsp], eax
	jne	SHORT $LN284@ms64_param

; 929  : 									  DebugMsg(("ms64_param(%s, param=%u): argument optimized\n", proc->sym.name, index));

	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11589
	call	DoDebugMsg
	jmp	SHORT $LN285@ms64_param
$LN284@ms64_param:

; 930  : 								  else
; 931  : 									  AddLineQueueX("vmovaps %r,oword ptr %s", T_XMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11590
	call	AddLineQueueX
$LN285@ms64_param:
$LN283@ms64_param:

; 932  : 							  }
; 933  : 						  }

	jmp	SHORT $LN282@ms64_param
$LN281@ms64_param:

; 934  : 						  else
; 935  : 							  AddLineQueueX("vmovaps %r,oword ptr %s", T_XMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 40					; 00000028H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11591
	call	AddLineQueueX
$LN282@ms64_param:

; 936  : 						  info->vregs[index] = 1;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+68], 1

; 937  : 						  break;

	jmp	SHORT $LN63@ms64_param
$LN286@ms64_param:

; 938  : 					  case 32:
; 939  : 						  info->vregs[index] = 1;

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+68], 1

; 940  : 						  AddLineQueueX("vmovups %r,oword ptr %s", T_YMM0 + index, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 56					; 00000038H
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11593
	call	AddLineQueueX
$LN63@ms64_param:
$LN273@ms64_param:
$LN218@ms64_param:

; 941  : 						  break;
; 942  : #if EVEXSUPP 
; 943  : 					  case 32:
; 944  : 						  info->vregs[index] = 1;
; 945  : 						  AddLineQueueX("vmovups %r,zmmword ptr %s", T_ZMM0 + index, paramvalue);
; 946  : 						  break;
; 947  : #endif
; 948  : 					  }
; 949  : 				  }
; 950  : 			  }

	jmp	$LN216@ms64_param
$LN215@ms64_param:
$uselea$353:

; 951  : 			  else
; 952  : 			  {
; 953  :       uselea:
; 954  : 
; 955  : 				  if ((proc->sym.langtype == LANG_VECTORCALL))

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	$LN287@ms64_param

; 956  : 				  {
; 957  : 					  if (index < 4)

	cmp	DWORD PTR index$[rsp], 4
	jge	$LN289@ms64_param

; 958  : 					  {
; 959  : 						  *regs_used |= (1 << (index + RPAR_START)); /* Flag the appropriate GP register as used now for the reference */

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 3
	mov	ecx, 1
	mov	DWORD PTR tv2356[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv2356[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR regs_used$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR regs_used$[rsp]
	mov	BYTE PTR [rcx], al

; 960  : 						  info->vecregs[index] = 0; /* In this case the vectorcall item is passed by reference in a GP register, so prevent it being homed in PROC */

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR info$[rsp]
	mov	BYTE PTR [rcx+rax+56], 0

; 961  : 						  AddLineQueueX(" lea %r, %s", ms64_regs[index + 2 * 4 + (psize > 4 ? 4 : 0)], paramvalue);

	cmp	DWORD PTR psize$[rsp], 4
	jbe	SHORT $LN341@ms64_param
	mov	DWORD PTR tv1477[rsp], 4
	jmp	SHORT $LN342@ms64_param
$LN341@ms64_param:
	mov	DWORD PTR tv1477[rsp], 0
$LN342@ms64_param:
	mov	eax, DWORD PTR index$[rsp]
	mov	ecx, DWORD PTR tv1477[rsp]
	lea	eax, DWORD PTR [rax+rcx+8]
	cdqe
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG11598
	call	AddLineQueueX

; 962  : 					  }

	jmp	SHORT $LN290@ms64_param
$LN289@ms64_param:

; 963  : 					  else
; 964  : 					  {
; 965  : 						  *regs_used |= R0_USED;

	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR regs_used$[rsp]
	mov	BYTE PTR [rcx], al

; 966  : 						  AddLineQueueX(" lea %r, %s", T_RAX, paramvalue);

	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, 115				; 00000073H
	lea	rcx, OFFSET FLAT:$SG11599
	call	AddLineQueueX

; 967  : 						  AddLineQueueX(" mov qword ptr [%r+%u], %r", T_RSP, NUMQUAL index * 8, T_RAX);

	mov	eax, DWORD PTR index$[rsp]
	shl	eax, 3
	mov	r9d, 115				; 00000073H
	mov	r8d, eax
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG11600
	call	AddLineQueueX

; 968  : 						  return(1);

	mov	eax, 1
	jmp	$LN1@ms64_param
$LN290@ms64_param:

; 969  : 
; 970  : 					  }
; 971  : 				  }

	jmp	SHORT $LN288@ms64_param
$LN287@ms64_param:

; 972  : 				  else
; 973  : 				  {
; 974  : 					  AddLineQueueX(" lea %r, %s", ms64_regs[index + 2 * 4 + (psize > 4 ? 4 : 0)], paramvalue);

	cmp	DWORD PTR psize$[rsp], 4
	jbe	SHORT $LN343@ms64_param
	mov	DWORD PTR tv1498[rsp], 4
	jmp	SHORT $LN344@ms64_param
$LN343@ms64_param:
	mov	DWORD PTR tv1498[rsp], 0
$LN344@ms64_param:
	mov	eax, DWORD PTR index$[rsp]
	mov	ecx, DWORD PTR tv1498[rsp]
	lea	eax, DWORD PTR [rax+rcx+8]
	cdqe
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG11601
	call	AddLineQueueX
$LN288@ms64_param:
$LN216@ms64_param:

; 975  : 				  }
; 976  : 			  }
; 977  : 		  }

	jmp	SHORT $LN214@ms64_param
$LN213@ms64_param:

; 978  :           else
; 979  :                 EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, index+1 );

	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	edx, eax
	mov	ecx, 145				; 00000091H
	call	EmitErr
$LN214@ms64_param:

; 980  :             return( 1 );

	mov	eax, 1
	jmp	$LN1@ms64_param
$LN211@ms64_param:

; 981  :         }
; 982  :         
; 983  : 	  if (vcallpass == 0)

	cmp	DWORD PTR vcallpass, 0
	jne	$LN291@ms64_param

; 984  : 	  {
; 985  : 		  /* register argument? */
; 986  : 		  if (opnd->kind == EXPR_REG && opnd->indirect == FALSE) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN292@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN292@ms64_param

; 987  : 			  reg = opnd->base_reg->tokval;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR reg$[rsp], eax

; 988  : 			  size = SizeFromRegister(reg);

	mov	ecx, DWORD PTR reg$[rsp]
	call	SizeFromRegister
	mov	DWORD PTR size$[rsp], eax

; 989  : 		  }

	jmp	$LN293@ms64_param
$LN292@ms64_param:

; 990  : 		  else if (opnd->kind == EXPR_CONST || opnd->kind == EXPR_FLOAT) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 0
	je	SHORT $LN296@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 3
	jne	SHORT $LN294@ms64_param
$LN296@ms64_param:

; 991  : 			  size = psize;

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR size$[rsp], eax

; 992  : 		  }

	jmp	$LN295@ms64_param
$LN294@ms64_param:

; 993  : 		  else if (opnd->mem_type != MT_EMPTY) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	je	SHORT $LN297@ms64_param

; 994  : 			  size = SizeFromMemtype(opnd->mem_type, USE64, opnd->type);

	mov	rax, QWORD PTR opnd$[rsp]
	mov	r8, QWORD PTR [rax+96]
	mov	edx, 2
	mov	rax, QWORD PTR opnd$[rsp]
	mov	ecx, DWORD PTR [rax+64]
	call	SizeFromMemtype
	mov	DWORD PTR size$[rsp], eax

; 995  : 		  }

	jmp	$LN298@ms64_param
$LN297@ms64_param:

; 996  : 		  else if (opnd->kind == EXPR_ADDR && opnd->sym != NULL && opnd->sym->state == SYM_UNDEFINED) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN299@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN299@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN299@ms64_param

; 997  : 			  DebugMsg1(("ms64_param(%s, param=%u): forward ref=%s, assumed size=%u\n", proc->sym.name, index, opnd->sym->name, psize));

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	ecx, DWORD PTR psize$[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9, QWORD PTR [rax+8]
	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11612
	call	DoDebugMsg1

; 998  : 			  size = psize;

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR size$[rsp], eax

; 999  : 		  }

	jmp	$LN300@ms64_param
$LN299@ms64_param:

; 1000 : 		  else if (opnd->kind == EXPR_ADDR && opnd->sym == NULL) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN301@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+80], 0
	jne	SHORT $LN301@ms64_param

; 1001 : 			  size = psize;

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR size$[rsp], eax

; 1002 : 		  }

	jmp	SHORT $LN302@ms64_param
$LN301@ms64_param:

; 1003 : 		  else if (opnd->kind == EXPR_REG && opnd->indirect == TRUE)

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN303@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN303@ms64_param

; 1004 : 		  {
; 1005 : 			  size = psize;

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR size$[rsp], eax

; 1006 : 		  }

	jmp	SHORT $LN304@ms64_param
$LN303@ms64_param:

; 1007 : 		  else
; 1008 : 			  size = (opnd->instr == T_OFFSET ? 8 : 4);

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+56], 241			; 000000f1H
	jne	SHORT $LN345@ms64_param
	mov	DWORD PTR tv1556[rsp], 8
	jmp	SHORT $LN346@ms64_param
$LN345@ms64_param:
	mov	DWORD PTR tv1556[rsp], 4
$LN346@ms64_param:
	mov	eax, DWORD PTR tv1556[rsp]
	mov	DWORD PTR size$[rsp], eax
$LN304@ms64_param:
$LN302@ms64_param:
$LN300@ms64_param:
$LN298@ms64_param:
$LN295@ms64_param:
$LN293@ms64_param:

; 1009 : 
; 1010 : 		  /* v2.11: allow argument extension, so long as the target isn't a pointer */
; 1011 : 		  //if ( size != psize && param->sym.is_vararg == FALSE ) {
; 1012 : 		  if (size > psize || (size < psize && param->sym.mem_type == MT_PTR)) {

	mov	eax, DWORD PTR psize$[rsp]
	cmp	DWORD PTR size$[rsp], eax
	ja	SHORT $LN306@ms64_param
	mov	eax, DWORD PTR psize$[rsp]
	cmp	DWORD PTR size$[rsp], eax
	jae	SHORT $LN305@ms64_param
	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+44], 195			; 000000c3H
	jne	SHORT $LN305@ms64_param
$LN306@ms64_param:

; 1013 : 			  DebugMsg(("ms64_param(%s, param=%u): type error size.p/a=%u/%u flags=%X\n", proc->sym.name, index, psize, size, *regs_used));

	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR size$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR psize$[rsp]
	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11619
	call	DoDebugMsg

; 1014 : 			  EmitErr(INVOKE_ARGUMENT_TYPE_MISMATCH, index + 1);

	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	edx, eax
	mov	ecx, 145				; 00000091H
	call	EmitErr
$LN305@ms64_param:

; 1015 : 		  }
; 1016 : 		  /* v2.11: use parameter size to allow argument extension */
; 1017 : 		  switch (psize) {

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR tv1569[rsp], eax
	cmp	DWORD PTR tv1569[rsp], 1
	je	SHORT $LN307@ms64_param
	cmp	DWORD PTR tv1569[rsp], 2
	je	SHORT $LN308@ms64_param
	cmp	DWORD PTR tv1569[rsp], 4
	je	SHORT $LN309@ms64_param
	jmp	SHORT $LN310@ms64_param
$LN307@ms64_param:

; 1018 : 		  case 1: base = 0 * 4; break;

	mov	DWORD PTR base$[rsp], 0
	jmp	SHORT $LN65@ms64_param
$LN308@ms64_param:

; 1019 : 		  case 2: base = 1 * 4; break;

	mov	DWORD PTR base$[rsp], 4
	jmp	SHORT $LN65@ms64_param
$LN309@ms64_param:

; 1020 : 		  case 4: base = 2 * 4; break;

	mov	DWORD PTR base$[rsp], 8
	jmp	SHORT $LN65@ms64_param
$LN310@ms64_param:

; 1021 : 		  default:base = 3 * 4; break;

	mov	DWORD PTR base$[rsp], 12
$LN65@ms64_param:

; 1022 : 		  }
; 1023 : 		  /* optimization if the register holds the value already */
; 1024 : 		  if (opnd->kind == EXPR_REG && opnd->indirect == FALSE) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	$LN311@ms64_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	$LN311@ms64_param

; 1025 : 			  if (GetValueSp(reg) & OP_R) {

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 15
	test	eax, eax
	je	$LN312@ms64_param

; 1026 : 				  if (ms64_regs[index + base] == reg) {

	mov	eax, DWORD PTR base$[rsp]
	mov	ecx, DWORD PTR index$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	edx, DWORD PTR reg$[rsp]
	cmp	DWORD PTR [rcx+rax*4], edx
	jne	SHORT $LN313@ms64_param

; 1027 : 					  DebugMsg(("ms64_param(%s, param=%u): argument optimized\n", proc->sym.name, index));

	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11627
	call	DoDebugMsg

; 1028 : 
; 1029 : 					  return(1);

	mov	eax, 1
	jmp	$LN1@ms64_param
$LN313@ms64_param:

; 1030 : 				  }
; 1031 : 				  i = GetRegNo(reg);

	movsxd	rax, DWORD PTR reg$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	DWORD PTR i$[rsp], eax

; 1032 : 				  if (REGPAR_WIN64 & (1 << i)) {

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv2415[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv2415[rsp]
	shl	eax, cl
	and	eax, 774				; 00000306H
	test	eax, eax
	je	SHORT $LN314@ms64_param

; 1033 : 					  i = GetParmIndex(i);

	cmp	DWORD PTR i$[rsp], 8
	jl	SHORT $LN347@ms64_param
	mov	eax, DWORD PTR i$[rsp]
	sub	eax, 6
	mov	DWORD PTR tv1607[rsp], eax
	jmp	SHORT $LN348@ms64_param
$LN347@ms64_param:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR tv1607[rsp], eax
$LN348@ms64_param:
	mov	eax, DWORD PTR tv1607[rsp]
	mov	DWORD PTR i$[rsp], eax

; 1034 : 					  if (*regs_used & (1 << (i + RPAR_START)))

	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, 3
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN315@ms64_param

; 1035 : 						  EmitErr(REGISTER_VALUE_OVERWRITTEN_BY_INVOKE);

	mov	ecx, 165				; 000000a5H
	call	EmitErr
$LN315@ms64_param:
$LN314@ms64_param:
$LN312@ms64_param:
$LN311@ms64_param:

; 1036 : 				  }
; 1037 : 			  }
; 1038 : 		  }
; 1039 : 
; 1040 : 		  /* v2.11: allow argument extension */
; 1041 : 		  if (size < psize)

	mov	eax, DWORD PTR psize$[rsp]
	cmp	DWORD PTR size$[rsp], eax
	jae	$LN316@ms64_param

; 1042 : 			  if (size == 4) {

	cmp	DWORD PTR size$[rsp], 4
	jne	SHORT $LN318@ms64_param

; 1043 : 				  if (IS_SIGNED(opnd->mem_type))

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN320@ms64_param

; 1044 : 					  AddLineQueueX(" movsxd %r, %s", ms64_regs[index + base], paramvalue);

	mov	eax, DWORD PTR base$[rsp]
	mov	ecx, DWORD PTR index$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG11636
	call	AddLineQueueX
	jmp	SHORT $LN321@ms64_param
$LN320@ms64_param:

; 1045 : 				  else
; 1046 : 					  AddLineQueueX(" mov %r, %s", ms64_regs[index + 2 * 4], paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 8
	cdqe
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG11637
	call	AddLineQueueX
$LN321@ms64_param:

; 1047 : 			  }

	jmp	SHORT $LN319@ms64_param
$LN318@ms64_param:

; 1048 : 			  else
; 1049 : 				  AddLineQueueX(" mov%sx %r, %s", IS_SIGNED(opnd->mem_type) ? "s" : "z", ms64_regs[index + base], paramvalue);

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN349@ms64_param
	lea	rax, OFFSET FLAT:$SG11638
	mov	QWORD PTR tv1642[rsp], rax
	jmp	SHORT $LN350@ms64_param
$LN349@ms64_param:
	lea	rax, OFFSET FLAT:$SG11639
	mov	QWORD PTR tv1642[rsp], rax
$LN350@ms64_param:
	mov	eax, DWORD PTR base$[rsp]
	mov	ecx, DWORD PTR index$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	r8d, DWORD PTR [rcx+rax*4]
	mov	rdx, QWORD PTR tv1642[rsp]
	lea	rcx, OFFSET FLAT:$SG11640
	call	AddLineQueueX
$LN319@ms64_param:
	jmp	$LN317@ms64_param
$LN316@ms64_param:

; 1050 : 		  else {
; 1051 : 			  /* v2.12 added by habran : if parametar  is zero use 'xor reg,reg' instead of 'mov reg,0' */
; 1052 : 			  if ((!strcasecmp(paramvalue, "0") || (!strcasecmp(paramvalue, "NULL")) || (!strcasecmp(paramvalue, "FALSE")))) {

	lea	rdx, OFFSET FLAT:$SG11644
	mov	rcx, QWORD PTR paramvalue$[rsp]
	call	_stricmp
	test	eax, eax
	je	SHORT $LN324@ms64_param
	lea	rdx, OFFSET FLAT:$SG11645
	mov	rcx, QWORD PTR paramvalue$[rsp]
	call	_stricmp
	test	eax, eax
	je	SHORT $LN324@ms64_param
	lea	rdx, OFFSET FLAT:$SG11646
	mov	rcx, QWORD PTR paramvalue$[rsp]
	call	_stricmp
	test	eax, eax
	jne	$LN322@ms64_param
$LN324@ms64_param:

; 1053 : 				  if (ms64_regs[index + base] > T_R9D) index -= 4;

	mov	eax, DWORD PTR base$[rsp]
	mov	ecx, DWORD PTR index$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	lea	rcx, OFFSET FLAT:ms64_regs
	cmp	DWORD PTR [rcx+rax*4], 108		; 0000006cH
	jle	SHORT $LN325@ms64_param
	mov	eax, DWORD PTR index$[rsp]
	sub	eax, 4
	mov	DWORD PTR index$[rsp], eax
$LN325@ms64_param:

; 1054 : 				  AddLineQueueX(" xor %r, %r", ms64_regs[index + base], ms64_regs[index + base]);

	mov	eax, DWORD PTR base$[rsp]
	mov	ecx, DWORD PTR index$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	edx, DWORD PTR base$[rsp]
	mov	r8d, DWORD PTR index$[rsp]
	add	r8d, edx
	mov	edx, r8d
	movsxd	rdx, edx
	lea	r8, OFFSET FLAT:ms64_regs
	mov	QWORD PTR tv1727[rsp], r8
	mov	r8d, DWORD PTR [rcx+rax*4]
	mov	rax, QWORD PTR tv1727[rsp]
	mov	edx, DWORD PTR [rax+rdx*4]
	lea	rcx, OFFSET FLAT:$SG11648
	call	AddLineQueueX

; 1055 : 				  return(1);

	mov	eax, 1
	jmp	$LN1@ms64_param

; 1056 : 			  }

	jmp	$LN323@ms64_param
$LN322@ms64_param:

; 1057 : 			  else
; 1058 : 			  {
; 1059 : 				  if (index > 3)

	cmp	DWORD PTR index$[rsp], 3
	jle	$LN326@ms64_param

; 1060 : 				  {
; 1061 : 					  switch (psize) {

	mov	eax, DWORD PTR psize$[rsp]
	mov	DWORD PTR tv1675[rsp], eax
	cmp	DWORD PTR tv1675[rsp], 1
	je	SHORT $LN328@ms64_param
	cmp	DWORD PTR tv1675[rsp], 2
	je	SHORT $LN329@ms64_param
	cmp	DWORD PTR tv1675[rsp], 4
	je	SHORT $LN330@ms64_param
	jmp	SHORT $LN331@ms64_param
$LN328@ms64_param:

; 1062 : 					  case 1:   i = T_BYTE; break;

	mov	DWORD PTR i$[rsp], 205			; 000000cdH
	jmp	SHORT $LN67@ms64_param
$LN329@ms64_param:

; 1063 : 					  case 2:   i = T_WORD; break;

	mov	DWORD PTR i$[rsp], 207			; 000000cfH
	jmp	SHORT $LN67@ms64_param
$LN330@ms64_param:

; 1064 : 					  case 4:   i = T_DWORD; break;

	mov	DWORD PTR i$[rsp], 209			; 000000d1H
	jmp	SHORT $LN67@ms64_param
$LN331@ms64_param:

; 1065 : 					  default:  i = T_QWORD; break;

	mov	DWORD PTR i$[rsp], 213			; 000000d5H
$LN67@ms64_param:

; 1066 : 					  }
; 1067 : 					  AddLineQueueX(" mov %r ptr [%r+%u], %s", i, T_RSP, NUMQUAL index * 8, paramvalue);

	mov	eax, DWORD PTR index$[rsp]
	shl	eax, 3
	mov	rcx, QWORD PTR paramvalue$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, eax
	mov	r8d, 119				; 00000077H
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11655
	call	AddLineQueueX

; 1068 : 				  }

	jmp	SHORT $LN327@ms64_param
$LN326@ms64_param:

; 1069 : 				  else
; 1070 : 					  AddLineQueueX(" mov %r, %s", ms64_regs[index + base], paramvalue);

	mov	eax, DWORD PTR base$[rsp]
	mov	ecx, DWORD PTR index$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	lea	rcx, OFFSET FLAT:ms64_regs
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG11656
	call	AddLineQueueX
$LN327@ms64_param:
$LN323@ms64_param:
$LN317@ms64_param:

; 1071 : 			  }
; 1072 : 		  }
; 1073 : 		  *regs_used |= (1 << (index + RPAR_START - 1));

	mov	eax, DWORD PTR index$[rsp]
	add	eax, 2
	mov	ecx, 1
	mov	DWORD PTR tv2453[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv2453[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR regs_used$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR regs_used$[rsp]
	mov	BYTE PTR [rcx], al

; 1074 : 		  DebugMsg1(("ms64_param(%s, param=%u): size=%u flags=%X\n", proc->sym.name, index, size, *regs_used));

	mov	rax, QWORD PTR regs_used$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR size$[rsp]
	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11657
	call	DoDebugMsg1
$LN291@ms64_param:
$LN205@ms64_param:
$LN198@ms64_param:
$LN191@ms64_param:
$LN180@ms64_param:
$LN173@ms64_param:
$vcalldone$352:

; 1075 : 	  }
; 1076 :     }
; 1077 : vcalldone:
; 1078 :     return( 1 );

	mov	eax, 1
$LN1@ms64_param:

; 1079 : }

	add	rsp, 232				; 000000e8H
	ret	0
ms64_param ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\invoke.c
_TEXT	SEGMENT
proc$ = 48
numparams$ = 56
value$ = 64
ms64_fcend PROC

; 238  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 239  :     /* use <value>, which has been set by ms64_fcstart() */
; 240  :     if ( !( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) )

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN2@ms64_fcend

; 241  :         AddLineQueueX( " add %r, %d", T_RSP, value * 8 );

	mov	eax, DWORD PTR value$[rsp]
	shl	eax, 3
	mov	r8d, eax
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG11202
	call	AddLineQueueX
$LN2@ms64_fcend:

; 242  :     return;
; 243  : }

	add	rsp, 40					; 00000028H
	ret	0
ms64_fcend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\invoke.c
_TEXT	SEGMENT
proc$ = 48
numparams$ = 56
start$ = 64
tokenarray$ = 72
value$ = 80
ms64_fcstart PROC

; 208  : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 209  :     /* v2.04: VARARG didn't work */
; 210  :     if ( proc->e.procinfo->has_vararg ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@ms64_fcsta

; 211  :         //numparams = ( tokenarray[start].token != T_FINAL ? 1 : 0 );
; 212  :         for ( numparams = 0; tokenarray[start].token != T_FINAL; start++ )

	mov	DWORD PTR numparams$[rsp], 0
	jmp	SHORT $LN4@ms64_fcsta
$LN2@ms64_fcsta:
	mov	eax, DWORD PTR start$[rsp]
	inc	eax
	mov	DWORD PTR start$[rsp], eax
$LN4@ms64_fcsta:
	movsxd	rax, DWORD PTR start$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN3@ms64_fcsta

; 213  :         if (tokenarray[start].token == T_COMMA) {

	movsxd	rax, DWORD PTR start$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN6@ms64_fcsta

; 214  :           numparams++;

	mov	eax, DWORD PTR numparams$[rsp]
	inc	eax
	mov	DWORD PTR numparams$[rsp], eax
$LN6@ms64_fcsta:

; 215  : 
; 216  :         }

	jmp	SHORT $LN2@ms64_fcsta
$LN3@ms64_fcsta:
$LN5@ms64_fcsta:

; 217  :     }
; 218  : 	sym_ReservedStack->hasinvoke = 1;  //added by habran

	mov	rax, QWORD PTR sym_ReservedStack
	mov	DWORD PTR [rax+24], 1

; 219  : 	DebugMsg1(("ms64_fcstart(%s, numparams=%u) vararg=%u\n", proc->sym.name, numparams, proc->e.procinfo->has_vararg ));

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 1
	movzx	eax, al
	mov	r9d, eax
	mov	r8d, DWORD PTR numparams$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11186
	call	DoDebugMsg1

; 220  :     if ( numparams < 4 )

	cmp	DWORD PTR numparams$[rsp], 4
	jge	SHORT $LN7@ms64_fcsta

; 221  :         numparams = 4;

	mov	DWORD PTR numparams$[rsp], 4
	jmp	SHORT $LN8@ms64_fcsta
$LN7@ms64_fcsta:

; 222  :     else if ( numparams & 1 )

	mov	eax, DWORD PTR numparams$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN9@ms64_fcsta

; 223  :         numparams++;

	mov	eax, DWORD PTR numparams$[rsp]
	inc	eax
	mov	DWORD PTR numparams$[rsp], eax
$LN9@ms64_fcsta:
$LN8@ms64_fcsta:

; 224  :     *value = numparams;

	mov	rax, QWORD PTR value$[rsp]
	mov	ecx, DWORD PTR numparams$[rsp]
	mov	DWORD PTR [rax], ecx

; 225  :     if ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) {

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 2
	test	eax, eax
	je	SHORT $LN10@ms64_fcsta

; 226  :         if ( ( numparams * sizeof( uint_64 ) ) > sym_ReservedStack->value )

	movsxd	rax, DWORD PTR numparams$[rsp]
	shl	rax, 3
	mov	rcx, QWORD PTR sym_ReservedStack
	movsxd	rcx, DWORD PTR [rcx+16]
	cmp	rax, rcx
	jbe	SHORT $LN12@ms64_fcsta

; 227  :             sym_ReservedStack->value = numparams * sizeof( uint_64 );

	movsxd	rax, DWORD PTR numparams$[rsp]
	shl	rax, 3
	mov	rcx, QWORD PTR sym_ReservedStack
	mov	DWORD PTR [rcx+16], eax
$LN12@ms64_fcsta:

; 228  :     } else

	jmp	SHORT $LN11@ms64_fcsta
$LN10@ms64_fcsta:

; 229  :         AddLineQueueX( " sub %r, %d", T_RSP, numparams * sizeof( uint_64 ) );

	movsxd	rax, DWORD PTR numparams$[rsp]
	shl	rax, 3
	mov	r8, rax
	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG11193
	call	AddLineQueueX
$LN11@ms64_fcsta:

; 230  :     /* since Win64 fastcall doesn't push, it's a better/faster strategy to
; 231  :      * handle the arguments from left to right.
; 232  :      */
; 233  :     return( 0 );

	xor	eax, eax

; 234  : }

	add	rsp, 40					; 00000028H
	ret	0
ms64_fcstart ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\invoke.c
_TEXT	SEGMENT
i$ = 64
qual$ = 68
sreg$1 = 72
p$ = 80
opc$ = 88
psize$ = 92
reg$ = 96
regs$ = 128
buffer$2 = 192
__$ArrayPad$ = 320
proc$ = 352
index$ = 360
param$ = 368
addr$ = 376
opnd$ = 384
paramvalue$ = 392
r0used$ = 400
watc_param PROC

; 1170 : {

	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 344				; 00000158H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1171 :     int opc;
; 1172 :     int qual;
; 1173 :     int i;
; 1174 :     char regs[64];
; 1175 :     char *reg[4];
; 1176 :     char *p;
; 1177 :     int psize = SizeFromMemtype( param->sym.mem_type, USE_EMPTY, param->sym.type );

	mov	rax, QWORD PTR param$[rsp]
	mov	r8, QWORD PTR [rax+88]
	mov	edx, 254				; 000000feH
	mov	rax, QWORD PTR param$[rsp]
	mov	ecx, DWORD PTR [rax+44]
	call	SizeFromMemtype
	mov	DWORD PTR psize$[rsp], eax

; 1178 : 
; 1179 :     DebugMsg1(("watc_param(%s, param=%u [name=%s, state=%u]),addr=%u: psize=%u\n", proc->sym.name, index, param->sym.name, param->sym.state, addr, psize ));

	movzx	eax, BYTE PTR addr$[rsp]
	mov	ecx, DWORD PTR psize$[rsp]
	mov	DWORD PTR [rsp+48], ecx
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR param$[rsp]
	mov	eax, DWORD PTR [rax+40]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR param$[rsp]
	mov	r9, QWORD PTR [rax+8]
	mov	r8d, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11764
	call	DoDebugMsg1

; 1180 :     if ( param->sym.state != SYM_TMACRO )

	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+40], 10
	je	SHORT $LN8@watc_param

; 1181 :         return( 0 );

	xor	eax, eax
	jmp	$LN1@watc_param
$LN8@watc_param:

; 1182 :     DebugMsg1(("watc_param(%s): register param=%s\n", proc->sym.name, param->sym.string_ptr ));

	mov	rax, QWORD PTR param$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11766
	call	DoDebugMsg1

; 1183 : 
; 1184 :     fcscratch += CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	ecx, DWORD PTR fcscratch
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR fcscratch, eax

; 1185 : 
; 1186 :     /* the "name" might be a register pair */
; 1187 : 
; 1188 :     reg[0] = param->sym.string_ptr;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR param$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR reg$[rsp+rax], rcx

; 1189 :     reg[1] = NULL;

	mov	eax, 8
	imul	rax, rax, 1
	mov	QWORD PTR reg$[rsp+rax], 0

; 1190 :     reg[2] = NULL;

	mov	eax, 8
	imul	rax, rax, 2
	mov	QWORD PTR reg$[rsp+rax], 0

; 1191 :     reg[3] = NULL;

	mov	eax, 8
	imul	rax, rax, 3
	mov	QWORD PTR reg$[rsp+rax], 0

; 1192 :     if ( strchr( reg[0], ':' ) ) {

	mov	eax, 8
	imul	rax, rax, 0
	mov	edx, 58					; 0000003aH
	mov	rcx, QWORD PTR reg$[rsp+rax]
	call	strchr
	test	rax, rax
	je	$LN9@watc_param

; 1193 :         strcpy( regs, reg[0] );

	mov	eax, 8
	imul	rax, rax, 0
	mov	rdx, QWORD PTR reg$[rsp+rax]
	lea	rcx, QWORD PTR regs$[rsp]
	call	strcpy

; 1194 :         fcscratch += CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	ecx, DWORD PTR fcscratch
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR fcscratch, eax

; 1195 :         for ( p = regs, i = 0; i < 4; i++ ) {

	lea	rax, QWORD PTR regs$[rsp]
	mov	QWORD PTR p$[rsp], rax
	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@watc_param
$LN2@watc_param:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@watc_param:
	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN3@watc_param

; 1196 :             reg[i] = p;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR reg$[rsp+rax*8], rcx

; 1197 :             p = strchr( p, ':' );

	mov	edx, 58					; 0000003aH
	mov	rcx, QWORD PTR p$[rsp]
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 1198 :             if ( p == NULL )

	cmp	QWORD PTR p$[rsp], 0
	jne	SHORT $LN10@watc_param

; 1199 :                 break;

	jmp	SHORT $LN3@watc_param
$LN10@watc_param:

; 1200 :             *p++ = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 1201 :             p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 1202 :         }

	jmp	SHORT $LN2@watc_param
$LN3@watc_param:
$LN9@watc_param:

; 1203 :     }
; 1204 : 
; 1205 :     if ( addr ) {

	movzx	eax, BYTE PTR addr$[rsp]
	test	eax, eax
	je	$LN11@watc_param

; 1206 :         if ( opnd->kind == T_REG || opnd->sym->state == SYM_STACK ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 2
	je	SHORT $LN14@watc_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+40], 5
	jne	SHORT $LN12@watc_param
$LN14@watc_param:

; 1207 :             opc = T_LEA;

	mov	DWORD PTR opc$[rsp], 634		; 0000027aH

; 1208 :             qual = T_NULL;

	mov	DWORD PTR qual$[rsp], 0

; 1209 :         } else {

	jmp	SHORT $LN13@watc_param
$LN12@watc_param:

; 1210 :             opc = T_MOV;

	mov	DWORD PTR opc$[rsp], 606		; 0000025eH

; 1211 :             qual = T_OFFSET;

	mov	DWORD PTR qual$[rsp], 241		; 000000f1H
$LN13@watc_param:

; 1212 :         }
; 1213 :         /* v2.05: filling of segment part added */
; 1214 :         i = 0;

	mov	DWORD PTR i$[rsp], 0

; 1215 :         if ( reg[1] != NULL ) {

	mov	eax, 8
	imul	rax, rax, 1
	cmp	QWORD PTR reg$[rsp+rax], 0
	je	$LN15@watc_param

; 1216 :             char buffer[128];
; 1217 :             short sreg;
; 1218 :             if ( sreg = GetSegmentPart( opnd, buffer, paramvalue ) )

	mov	r8, QWORD PTR paramvalue$[rsp]
	lea	rdx, QWORD PTR buffer$2[rsp]
	mov	rcx, QWORD PTR opnd$[rsp]
	call	GetSegmentPart
	mov	WORD PTR sreg$1[rsp], ax
	movsx	eax, WORD PTR sreg$1[rsp]
	test	eax, eax
	je	SHORT $LN16@watc_param

; 1219 :                 AddLineQueueX( "%r %s, %r", T_MOV, reg[0],  sreg );

	movsx	eax, WORD PTR sreg$1[rsp]
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	r9d, eax
	mov	r8, QWORD PTR reg$[rsp+rcx]
	mov	edx, 606				; 0000025eH
	lea	rcx, OFFSET FLAT:$SG11776
	call	AddLineQueueX
	jmp	SHORT $LN17@watc_param
$LN16@watc_param:

; 1220 :             else
; 1221 :                 AddLineQueueX( "%r %s, %s", T_MOV, reg[0],  buffer );

	mov	eax, 8
	imul	rax, rax, 0
	lea	r9, QWORD PTR buffer$2[rsp]
	mov	r8, QWORD PTR reg$[rsp+rax]
	mov	edx, 606				; 0000025eH
	lea	rcx, OFFSET FLAT:$SG11777
	call	AddLineQueueX
$LN17@watc_param:

; 1222 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN15@watc_param:

; 1223 :         }
; 1224 :         AddLineQueueX( "%r %s, %r %s", opc, reg[i], qual, paramvalue );

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR paramvalue$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, DWORD PTR qual$[rsp]
	mov	r8, QWORD PTR reg$[rsp+rax*8]
	mov	edx, DWORD PTR opc$[rsp]
	lea	rcx, OFFSET FLAT:$SG11778
	call	AddLineQueueX

; 1225 :         return( 1 );

	mov	eax, 1
	jmp	$LN1@watc_param
$LN11@watc_param:

; 1226 :     }
; 1227 :     for ( i = 3; i >= 0; i-- ) {

	mov	DWORD PTR i$[rsp], 3
	jmp	SHORT $LN7@watc_param
$LN5@watc_param:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@watc_param:
	cmp	DWORD PTR i$[rsp], 0
	jl	$LN6@watc_param

; 1228 :         if ( reg[i] ) {

	movsxd	rax, DWORD PTR i$[rsp]
	cmp	QWORD PTR reg$[rsp+rax*8], 0
	je	$LN18@watc_param

; 1229 :             if ( opnd->kind == EXPR_CONST ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	$LN19@watc_param

; 1230 :                 if ( i > 0 )

	cmp	DWORD PTR i$[rsp], 0
	jle	SHORT $LN21@watc_param

; 1231 :                     qual = T_LOWWORD;

	mov	DWORD PTR qual$[rsp], 238		; 000000eeH
	jmp	SHORT $LN22@watc_param
$LN21@watc_param:

; 1232 :                 else if ( i == 0 && reg[1] != NULL )

	cmp	DWORD PTR i$[rsp], 0
	jne	SHORT $LN23@watc_param
	mov	eax, 8
	imul	rax, rax, 1
	cmp	QWORD PTR reg$[rsp+rax], 0
	je	SHORT $LN23@watc_param

; 1233 :                     qual = T_HIGHWORD;

	mov	DWORD PTR qual$[rsp], 232		; 000000e8H
	jmp	SHORT $LN24@watc_param
$LN23@watc_param:

; 1234 :                 else
; 1235 :                     qual = T_NULL;

	mov	DWORD PTR qual$[rsp], 0
$LN24@watc_param:
$LN22@watc_param:

; 1236 :                 if ( qual != T_NULL )

	cmp	DWORD PTR qual$[rsp], 0
	je	SHORT $LN25@watc_param

; 1237 :                     AddLineQueueX( "mov %s, %r (%s)", reg[i], qual, paramvalue );

	movsxd	rax, DWORD PTR i$[rsp]
	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	r8d, DWORD PTR qual$[rsp]
	mov	rdx, QWORD PTR reg$[rsp+rax*8]
	lea	rcx, OFFSET FLAT:$SG11788
	call	AddLineQueueX
	jmp	SHORT $LN26@watc_param
$LN25@watc_param:

; 1238 :                 else
; 1239 :                     AddLineQueueX( "mov %s, %s", reg[i], paramvalue );

	movsxd	rax, DWORD PTR i$[rsp]
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR reg$[rsp+rax*8]
	lea	rcx, OFFSET FLAT:$SG11789
	call	AddLineQueueX
$LN26@watc_param:

; 1240 :             } else if ( opnd->kind == EXPR_REG ) {

	jmp	$LN20@watc_param
$LN19@watc_param:
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN27@watc_param

; 1241 :                 AddLineQueueX( "mov %s, %s", reg[i], paramvalue );

	movsxd	rax, DWORD PTR i$[rsp]
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR reg$[rsp+rax*8]
	lea	rcx, OFFSET FLAT:$SG11792
	call	AddLineQueueX

; 1242 :             } else {

	jmp	$LN28@watc_param
$LN27@watc_param:

; 1243 :                 if ( i == 0 && reg[1] == NULL )

	cmp	DWORD PTR i$[rsp], 0
	jne	SHORT $LN29@watc_param
	mov	eax, 8
	imul	rax, rax, 1
	cmp	QWORD PTR reg$[rsp+rax], 0
	jne	SHORT $LN29@watc_param

; 1244 :                     AddLineQueueX( "mov %s, %s", reg[i], paramvalue );

	movsxd	rax, DWORD PTR i$[rsp]
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR reg$[rsp+rax*8]
	lea	rcx, OFFSET FLAT:$SG11795
	call	AddLineQueueX
	jmp	SHORT $LN30@watc_param
$LN29@watc_param:

; 1245 :                 else {
; 1246 :                     if ( ModuleInfo.Ofssize )

	movzx	eax, BYTE PTR ModuleInfo+404
	test	eax, eax
	je	SHORT $LN31@watc_param

; 1247 :                         qual = T_DWORD;

	mov	DWORD PTR qual$[rsp], 209		; 000000d1H
	jmp	SHORT $LN32@watc_param
$LN31@watc_param:

; 1248 :                     else
; 1249 :                         qual = T_WORD;

	mov	DWORD PTR qual$[rsp], 207		; 000000cfH
$LN32@watc_param:

; 1250 :                     AddLineQueueX( "mov %s, %r %r %s[%u]", reg[i], qual, T_PTR, paramvalue, psize - ( (i+1) * ( 2 << ModuleInfo.Ofssize ) ) );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	movzx	ecx, BYTE PTR ModuleInfo+404
	mov	edx, 2
	shl	edx, cl
	mov	ecx, edx
	imul	eax, ecx
	mov	ecx, DWORD PTR psize$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR paramvalue$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 258				; 00000102H
	mov	r8d, DWORD PTR qual$[rsp]
	mov	rdx, QWORD PTR reg$[rsp+rcx*8]
	lea	rcx, OFFSET FLAT:$SG11798
	call	AddLineQueueX
$LN30@watc_param:
$LN28@watc_param:
$LN20@watc_param:
$LN18@watc_param:

; 1251 :                 }
; 1252 :             }
; 1253 :         }
; 1254 :     }

	jmp	$LN5@watc_param
$LN6@watc_param:

; 1255 :     return( 1 );

	mov	eax, 1
$LN1@watc_param:

; 1256 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 344				; 00000158H
	ret	0
watc_param ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\invoke.c
_TEXT	SEGMENT
proc$ = 48
numparams$ = 56
value$ = 64
watc_fcend PROC

; 1155 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1156 :     DebugMsg1(("watc_fcend(%s, %u, %u)\n", proc->sym.name, numparams, value ));

	mov	r9d, DWORD PTR value$[rsp]
	mov	r8d, DWORD PTR numparams$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11721
	call	DoDebugMsg1

; 1157 :     if ( proc->e.procinfo->has_vararg ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+128]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@watc_fcend

; 1158 :         AddLineQueueX( " add %r, %u", stackreg[ModuleInfo.Ofssize], NUMQUAL proc->e.procinfo->parasize + size_vararg );

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+32]
	add	eax, DWORD PTR size_vararg
	movzx	ecx, BYTE PTR ModuleInfo+404
	lea	rdx, OFFSET FLAT:stackreg
	mov	r8d, eax
	mov	edx, DWORD PTR [rdx+rcx*4]
	lea	rcx, OFFSET FLAT:$SG11724
	call	AddLineQueueX
	jmp	SHORT $LN3@watc_fcend
$LN2@watc_fcend:

; 1159 :     } else if ( fcscratch < proc->e.procinfo->parasize ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+32]
	cmp	DWORD PTR fcscratch, eax
	jae	SHORT $LN4@watc_fcend

; 1160 :         AddLineQueueX( " add %r, %u", stackreg[ModuleInfo.Ofssize], NUMQUAL ( proc->e.procinfo->parasize - fcscratch ) );

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	ecx, DWORD PTR fcscratch
	mov	eax, DWORD PTR [rax+32]
	sub	eax, ecx
	movzx	ecx, BYTE PTR ModuleInfo+404
	lea	rdx, OFFSET FLAT:stackreg
	mov	r8d, eax
	mov	edx, DWORD PTR [rdx+rcx*4]
	lea	rcx, OFFSET FLAT:$SG11726
	call	AddLineQueueX
$LN4@watc_fcend:
$LN3@watc_fcend:

; 1161 :     }
; 1162 :     return;
; 1163 : }

	add	rsp, 40					; 00000028H
	ret	0
watc_fcend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\invoke.c
_TEXT	SEGMENT
proc$ = 48
numparams$ = 56
start$ = 64
tokenarray$ = 72
value$ = 80
watc_fcstart PROC

; 1148 : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1149 :     DebugMsg1(("watc_fcstart(%s, %u, %u)\n", proc->sym.name, numparams, start ));

	mov	r9d, DWORD PTR start$[rsp]
	mov	r8d, DWORD PTR numparams$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11713
	call	DoDebugMsg1

; 1150 :     return( 1 );

	mov	eax, 1

; 1151 : }

	add	rsp, 40					; 00000028H
	ret	0
watc_fcstart ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\invoke.c
_TEXT	SEGMENT
reg$1 = 48
size$2 = 52
pst$ = 56
tv143 = 64
proc$ = 96
index$ = 104
param$ = 112
addr$ = 120
opnd$ = 128
paramvalue$ = 136
r0used$ = 144
ms32_param PROC

; 163  : {

	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 164  :     enum special_token const *pst;
; 165  : 
; 166  :     DebugMsg1(("ms32_param(proc=%s, ofs=%u, index=%u, param=%s) fcscratch=%u\n", proc->sym.name, proc->sym.Ofssize, index, param->sym.name, fcscratch ));

	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+52]
	mov	ecx, DWORD PTR fcscratch
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR param$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, DWORD PTR index$[rsp]
	mov	r8d, eax
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11147
	call	DoDebugMsg1

; 167  :     if ( param->sym.state != SYM_TMACRO )

	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+40], 10
	je	SHORT $LN2@ms32_param

; 168  :         return( 0 );

	xor	eax, eax
	jmp	$LN1@ms32_param
$LN2@ms32_param:

; 169  :     if ( GetSymOfssize( &proc->sym ) == USE16 ) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, rax
	call	GetSymOfssize
	test	eax, eax
	jne	SHORT $LN3@ms32_param

; 170  :         pst = ms16_regs + fcscratch;

	movsxd	rax, DWORD PTR fcscratch
	lea	rcx, OFFSET FLAT:ms16_regs
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	QWORD PTR pst$[rsp], rax

; 171  :         fcscratch++;

	mov	eax, DWORD PTR fcscratch
	inc	eax
	mov	DWORD PTR fcscratch, eax

; 172  :     } else {

	jmp	SHORT $LN4@ms32_param
$LN3@ms32_param:

; 173  :         fcscratch--;

	mov	eax, DWORD PTR fcscratch
	dec	eax
	mov	DWORD PTR fcscratch, eax

; 174  :         pst = ms32_regs + fcscratch;

	movsxd	rax, DWORD PTR fcscratch
	lea	rcx, OFFSET FLAT:ms32_regs
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	QWORD PTR pst$[rsp], rax
$LN4@ms32_param:

; 175  :     }
; 176  :     if ( addr )

	movzx	eax, BYTE PTR addr$[rsp]
	test	eax, eax
	je	SHORT $LN5@ms32_param

; 177  :         AddLineQueueX( " lea %r, %s", *pst, paramvalue );

	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	rax, QWORD PTR pst$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11153
	call	AddLineQueueX
	jmp	$LN6@ms32_param
$LN5@ms32_param:

; 178  :     else {
; 179  :         enum special_token reg = *pst;

	mov	rax, QWORD PTR pst$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR reg$1[rsp], eax

; 180  :         int size;
; 181  :         /* v2.08: adjust register if size of operand won't require the full register */
; 182  :         if ( ( opnd->kind != EXPR_CONST ) &&

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 0
	je	$LN7@ms32_param
	mov	rax, QWORD PTR param$[rsp]
	mov	r8, QWORD PTR [rax+88]
	mov	edx, 254				; 000000feH
	mov	rax, QWORD PTR param$[rsp]
	mov	ecx, DWORD PTR [rax+44]
	call	SizeFromMemtype
	mov	DWORD PTR size$2[rsp], eax
	mov	rax, QWORD PTR pst$[rsp]
	mov	ecx, DWORD PTR [rax]
	call	SizeFromRegister
	cmp	DWORD PTR size$2[rsp], eax
	jge	$LN7@ms32_param

; 183  :             ( size = SizeFromMemtype( param->sym.mem_type, USE_EMPTY, param->sym.type ) ) < SizeFromRegister( *pst ) ) {
; 184  :             if (( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN9@ms32_param

; 185  :                 AddLineQueueX( " %s %r, %s", ( param->sym.mem_type & MT_SIGNED ) ? "movsx" : "movzx", reg, paramvalue );

	mov	rax, QWORD PTR param$[rsp]
	mov	eax, DWORD PTR [rax+44]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN15@ms32_param
	lea	rax, OFFSET FLAT:$SG11158
	mov	QWORD PTR tv143[rsp], rax
	jmp	SHORT $LN16@ms32_param
$LN15@ms32_param:
	lea	rax, OFFSET FLAT:$SG11159
	mov	QWORD PTR tv143[rsp], rax
$LN16@ms32_param:
	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	r8d, DWORD PTR reg$1[rsp]
	mov	rdx, QWORD PTR tv143[rsp]
	lea	rcx, OFFSET FLAT:$SG11160
	call	AddLineQueueX

; 186  :             } else {

	jmp	SHORT $LN10@ms32_param
$LN9@ms32_param:

; 187  :                 /* this is currently always UNSIGNED */
; 188  :                 AddLineQueueX( " mov %r, %s", T_AL + GetRegNo( reg ), paramvalue );

	movsxd	rax, DWORD PTR reg$1[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	inc	eax
	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11161
	call	AddLineQueueX

; 189  :                 AddLineQueueX( " mov %r, 0", T_AH + GetRegNo( reg ) );

	movsxd	rax, DWORD PTR reg$1[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	add	eax, 5
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11162
	call	AddLineQueueX
$LN10@ms32_param:

; 190  :             }
; 191  :         } else {

	jmp	SHORT $LN8@ms32_param
$LN7@ms32_param:

; 192  :             /* v2.08: optimization */
; 193  :             if ( opnd->kind == EXPR_REG && opnd->indirect == 0 && opnd->base_reg ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN11@ms32_param
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN11@ms32_param
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN11@ms32_param

; 194  :                 if ( opnd->base_reg->tokval == reg )

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	ecx, DWORD PTR reg$1[rsp]
	cmp	DWORD PTR [rax+16], ecx
	jne	SHORT $LN12@ms32_param

; 195  :                     return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@ms32_param
$LN12@ms32_param:
$LN11@ms32_param:

; 196  :             }
; 197  :             AddLineQueueX( " mov %r, %s", reg, paramvalue );

	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, DWORD PTR reg$1[rsp]
	lea	rcx, OFFSET FLAT:$SG11165
	call	AddLineQueueX
$LN8@ms32_param:
$LN6@ms32_param:

; 198  :         }
; 199  :     }
; 200  :     if ( *pst == T_AX )

	mov	rax, QWORD PTR pst$[rsp]
	cmp	DWORD PTR [rax], 9
	jne	SHORT $LN13@ms32_param

; 201  :         *r0used |= R0_USED;

	mov	rax, QWORD PTR r0used$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR r0used$[rsp]
	mov	BYTE PTR [rcx], al
$LN13@ms32_param:

; 202  :     return( 1 );

	mov	eax, 1
$LN1@ms32_param:

; 203  : }

	add	rsp, 88					; 00000058H
	ret	0
ms32_param ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\invoke.c
_TEXT	SEGMENT
proc$ = 8
numparams$ = 16
value$ = 24
ms32_fcend PROC

; 156  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 157  :     /* nothing to do */
; 158  :     return;
; 159  : }

	ret	0
ms32_fcend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\invoke.c
_TEXT	SEGMENT
param$ = 32
proc$ = 64
numparams$ = 72
start$ = 80
tokenarray$ = 88
value$ = 96
ms32_fcstart PROC

; 142  : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 143  :     struct dsym *param;
; 144  :     DebugMsg1(("ms32_fcstart(proc=%s, ofs=%u)\n", proc->sym.name, GetSymOfssize( &proc->sym ) ));

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, rax
	call	GetSymOfssize
	mov	r8d, eax
	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11119
	call	DoDebugMsg1

; 145  :     if ( GetSymOfssize( &proc->sym ) == USE16 )

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, rax
	call	GetSymOfssize
	test	eax, eax
	jne	SHORT $LN5@ms32_fcsta

; 146  :         return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@ms32_fcsta
$LN5@ms32_fcsta:

; 147  :     /* v2.07: count number of register params */
; 148  :     for ( param = proc->e.procinfo->paralist ; param ; param = param->nextparam )

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR param$[rsp], rax
	jmp	SHORT $LN4@ms32_fcsta
$LN2@ms32_fcsta:
	mov	rax, QWORD PTR param$[rsp]
	mov	rax, QWORD PTR [rax+120]
	mov	QWORD PTR param$[rsp], rax
$LN4@ms32_fcsta:
	cmp	QWORD PTR param$[rsp], 0
	je	SHORT $LN3@ms32_fcsta

; 149  :         if ( param->sym.state == SYM_TMACRO )

	mov	rax, QWORD PTR param$[rsp]
	cmp	DWORD PTR [rax+40], 10
	jne	SHORT $LN6@ms32_fcsta

; 150  :             fcscratch++;

	mov	eax, DWORD PTR fcscratch
	inc	eax
	mov	DWORD PTR fcscratch, eax
$LN6@ms32_fcsta:
	jmp	SHORT $LN2@ms32_fcsta
$LN3@ms32_fcsta:

; 151  :     return( 1 );

	mov	eax, 1
$LN1@ms32_fcsta:

; 152  : }

	add	rsp, 56					; 00000038H
	ret	0
ms32_fcstart ENDP
_TEXT	ENDS
END
