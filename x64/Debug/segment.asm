; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	symCurSeg:QWORD
_DATA	ENDS
_BSS	SEGMENT
$SG11416 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11327 DB	'READONLY', 00H
	ORG $+3
$SG11328 DB	'BYTE', 00H
	ORG $+3
$SG11329 DB	'WORD', 00H
	ORG $+3
$SG11330 DB	'DWORD', 00H
	ORG $+2
$SG11331 DB	'PARA', 00H
	ORG $+3
$SG11332 DB	'PAGE', 00H
	ORG $+3
$SG11333 DB	'ALIGN', 00H
	ORG $+2
$SG11335 DB	'PUBLIC', 00H
	ORG $+1
$SG11339 DB	'AT', 00H
	ORG $+1
$SG11334 DB	'PRIVATE', 00H
$SG11336 DB	'STACK', 00H
	ORG $+2
$SG11337 DB	'COMMON', 00H
	ORG $+1
$SG11338 DB	'MEMORY', 00H
	ORG $+1
$SG11340 DB	'COMDAT', 00H
	ORG $+1
$SG11341 DB	'USE16', 00H
	ORG $+2
$SG11342 DB	'USE32', 00H
	ORG $+2
$SG11343 DB	'USE64', 00H
	ORG $+2
$SG11344 DB	'FLAT', 00H
	ORG $+3
$SG11345 DB	'INFO', 00H
	ORG $+3
$SG11346 DB	'DISCARD', 00H
$SG11347 DB	'NOCACHE', 00H
$SG11348 DB	'NOPAGE', 00H
	ORG $+1
$SG11349 DB	'SHARED', 00H
	ORG $+1
$SG11350 DB	'EXECUTE', 00H
$SG11351 DB	'READ', 00H
	ORG $+3
$SG11352 DB	'WRITE', 00H
	ORG $+2
$SG11353 DB	'ALIAS', 00H
	ORG $+2
$SG11389 DB	'UpdateCurPC: curr value=%Xh', 0aH, 00H
	ORG $+3
$SG11402 DB	'FreeLnameQueue enter', 0aH, 00H
	ORG $+2
$SG11404 DB	'FreeLnameQueue exit', 0aH, 00H
	ORG $+3
$SG11412 DB	'NULL', 00H
	ORG $+3
$SG11413 DB	'UpdateCurrSegVars(%s)', 0aH, 00H
	ORG $+1
$SG11483 DB	'DeleteGroup(%s): free seg_item=%p', 0aH, 00H
	ORG $+1
$SG11631 DB	'BSS', 00H
$SG11484 DB	'DeleteGroup(%s): extension %p will be freed', 0aH, 00H
	ORG $+3
$SG11527 DB	'GrpDir: segment >%s< is in group >%s< already', 0aH, 00H
	ORG $+1
$SG11552 DB	'SetOfssize, error: CurrSeg=%s, ModuleInfo.Ofssize=%u, cu'
	DB	'rr_cpu=%X, defOfssize=%u', 0aH, 00H
	ORG $+2
$SG11562 DB	'(null)', 00H
	ORG $+1
$SG11808 DB	'(', 00H
	ORG $+2
$SG11553 DB	'SetOfssize: ModuleInfo.Ofssize=%u', 0aH, 00H
	ORG $+1
$SG11811 DB	')', 00H
	ORG $+2
$SG11559 DB	'CloseSeg(%s) enter', 0aH, 00H
$SG11825 DB	'(', 00H
	ORG $+2
$SG11563 DB	'CloseSeg(%s): nesting error, CurrSeg=%s', 0aH, 00H
	ORG $+3
$SG11619 DB	'CONST', 00H
	ORG $+2
$SG11831 DB	'1-6', 00H
$SG11564 DB	'CloseSeg(%s): current ofs=%X', 0aH, 00H
	ORG $+2
$SG11571 DB	'FLAT', 00H
	ORG $+3
$SG11572 DB	'DefineFlatGroup(): Ofssize=%u', 0aH, 00H
	ORG $+1
$SG11621 DB	'DBTYP', 00H
	ORG $+2
$SG11623 DB	'DBSYM', 00H
	ORG $+2
$SG11626 DB	'CODE', 00H
	ORG $+3
$SG11628 DB	'DATA', 00H
	ORG $+3
$SG11713 DB	'SetCurrSeg(%s) sym=%p', 0aH, 00H
	ORG $+1
$SG11783 DB	'SegmentDir(%s) enter: ModuleInfo.Ofssize=%u, num_seg=%u', 0aH
	DB	00H
	ORG $+3
$SG11839 DB	')', 00H
	ORG $+2
$SG11793 DB	'SegmentDir(%s): symbol redefinition', 0aH, 00H
	ORG $+3
$SG11794 DB	'SegmentDir(%s): i=%u, string=%s token=%X', 0aH, 00H
	ORG $+2
$SG11855 DB	'(', 00H
	ORG $+2
$SG11797 DB	'SegmentDir(%s): class found: %s', 0aH, 00H
	ORG $+3
$SG11859 DB	')', 00H
	ORG $+2
$SG11803 DB	'SegmentDir(%s): align attribute found', 0aH, 00H
	ORG $+1
$SG11805 DB	'SegmentDir(%s): ALIGN() found', 0aH, 00H
	ORG $+1
$SG11815 DB	'SegmentDir(%s): combine attribute found', 0aH, 00H
	ORG $+7
$SG11817 DB	'SegmentDir(%s): AT found', 0aH, 00H
	ORG $+6
$SG11822 DB	'SegmentDir(%s): COMDAT found', 0aH, 00H
	ORG $+2
$SG11845 DB	'SegmentDir(%s): characteristics found', 0aH, 00H
	ORG $+1
$SG11850 DB	'NULL', 00H
	ORG $+3
$SG11851 DB	'SegmentDir(%s): ALIAS found, curr value=%s', 0aH, 00H
	ORG $+4
$SG11864 DB	'SegmentDir(%s): ALIAS argument=>%s<', 0aH, 00H
	ORG $+3
$SG11866 DB	'segment.c', 00H
	ORG $+6
$SG11910 DB	'segment.c', 00H
	ORG $+6
$SG11922 DB	'SegmentFini() enter', 0aH, 00H
	ORG $+3
$SG11924 DB	'SegmentFini() exit', 0aH, 00H
	ORG $+4
$SG11942 DB	'SegmentInit(%u) enter', 0aH, 00H
	ORG $+1
$SG11948 DB	'SegmentInit(%u), %s: max_ofs=%X, alloc_size=%Xh', 0aH, 00H
	ORG $+7
$SG11950 DB	'SegmentInit(%u): total buffer size=%X, start=%p', 0aH, 00H
	ORG $+7
$SG11955 DB	'SegmentInit(%u), %s: buffer=%p', 0aH, 00H
$SG11956 DB	'SegmentInit(%u), %s: size=%X buffer=%p', 0aH, 00H
$SG11966 DB	'SegmentSaveState: saved_segStack=%X', 0aH, 00H
_DATA	ENDS
CONST	SEGMENT
SegAttrToken DQ	FLAT:$SG11327
	DQ	FLAT:$SG11328
	DQ	FLAT:$SG11329
	DQ	FLAT:$SG11330
	DQ	FLAT:$SG11331
	DQ	FLAT:$SG11332
	DQ	FLAT:$SG11333
	DQ	FLAT:$SG11334
	DQ	FLAT:$SG11335
	DQ	FLAT:$SG11336
	DQ	FLAT:$SG11337
	DQ	FLAT:$SG11338
	DQ	FLAT:$SG11339
	DQ	FLAT:$SG11340
	DQ	FLAT:$SG11341
	DQ	FLAT:$SG11342
	DQ	FLAT:$SG11343
	DQ	FLAT:$SG11344
	DQ	FLAT:$SG11345
	DQ	FLAT:$SG11346
	DQ	FLAT:$SG11347
	DQ	FLAT:$SG11348
	DQ	FLAT:$SG11349
	DQ	FLAT:$SG11350
	DQ	FLAT:$SG11351
	DQ	FLAT:$SG11352
	DQ	FLAT:$SG11353
SegAttrValue DB	00H
	DB	01H
	DB	00H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	02H
	DB	08H
	DB	02H
	DB	00H
	DB	082H
	DB	00H
	DB	04H
	DB	02H
	DB	04H
	DB	05H
	DB	04H
	DB	06H
	DB	04H
	DB	02H
	DB	04H
	DB	00H
	DB	084H
	DB	00H
	DB	0c4H
	DB	00H
	DB	08H
	DB	01H
	DB	08H
	DB	02H
	DB	08H
	DB	01H
	DB	088H
	DB	00H
	DB	0a0H
	DB	02H
	DB	020H
	DB	04H
	DB	020H
	DB	08H
	DB	020H
	DB	010H
	DB	020H
	DB	020H
	DB	020H
	DB	040H
	DB	020H
	DB	080H
	DB	020H
	DB	00H
	DB	010H
	ORG $+2
min_cpu	DW	00H
	DW	030H
	DW	070H
CONST	ENDS
PUBLIC	SetSymSegOfs
PUBLIC	GetSymOfssize
PUBLIC	GetCurrOffset
PUBLIC	CreateIntSegment
PUBLIC	GetSegIdx
PUBLIC	SegmentInit
PUBLIC	SegmentFini
PUBLIC	GetGroup
PUBLIC	GetCurrSegAlign
PUBLIC	SetOfssize
PUBLIC	TypeFromClassName
PUBLIC	DefineFlatGroup
PUBLIC	SegmentModuleExit
PUBLIC	DeleteGroup
PUBLIC	SegmentSaveState
PUBLIC	UpdateCurPC
PUBLIC	GrpDir
PUBLIC	UpdateWordSize
PUBLIC	EndsDir
PUBLIC	SegmentDir
PUBLIC	SortSegments
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strcmp:PROC
EXTRN	_stricmp:PROC
EXTRN	strlen:PROC
EXTRN	_strupr:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	QAddItem:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymAlloc:PROC
EXTRN	SymFree:PROC
EXTRN	SymCreate:PROC
EXTRN	SymFind:PROC
EXTRN	sym_add_table:PROC
EXTRN	sym_remove_table:PROC
EXTRN	Set64Bit:PROC
EXTRN	GetCodeClass:PROC
EXTRN	ModelSimSegmExit:PROC
EXTRN	EvalOperand:PROC
EXTRN	omf_OutSelect:PROC
EXTRN	omf_FlushCurrSeg:PROC
EXTRN	LstWrite:PROC
EXTRN	MsgGetEx:PROC
EXTRN	InternalError:PROC
EXTRN	EndstructDirective:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	write_to_file:BYTE
EXTRN	SymCmpFunc:QWORD
EXTRN	SymTables:BYTE
EXTRN	UseSavedState:BYTE
EXTRN	SegAssumeTable:BYTE
EXTRN	CurrStruct:QWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
	ALIGN	4

grpdefidx DD	01H DUP (?)
SegStack DQ	014H DUP (?)
stkindex DD	01H DUP (?)
	ALIGN	8

saved_CurrSeg DQ 01H DUP (?)
saved_SegStack DQ 01H DUP (?)
saved_stkindex DD 01H DUP (?)
codebuf	DB	0400H DUP (?)
buffer_size DD	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$SetSymSegOfs DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$SetSymSegOfs
$pdata$GetSymOfssize DD imagerel $LN10
	DD	imagerel $LN10+161
	DD	imagerel $unwind$GetSymOfssize
$pdata$GetCurrOffset DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$GetCurrOffset
$pdata$CreateIntSegment DD imagerel $LN11
	DD	imagerel $LN11+350
	DD	imagerel $unwind$CreateIntSegment
$pdata$SegmentInit DD imagerel $LN23
	DD	imagerel $LN23+934
	DD	imagerel $unwind$SegmentInit
$pdata$SegmentFini DD imagerel $LN4
	DD	imagerel $LN4+38
	DD	imagerel $unwind$SegmentFini
$pdata$GetGroup DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$GetGroup
$pdata$GetCurrSegAlign DD imagerel $LN5
	DD	imagerel $LN5+83
	DD	imagerel $unwind$GetCurrSegAlign
$pdata$SetOfssize DD imagerel $LN8
	DD	imagerel $LN8+271
	DD	imagerel $unwind$SetOfssize
$pdata$TypeFromClassName DD imagerel $LN19
	DD	imagerel $LN19+535
	DD	imagerel $unwind$TypeFromClassName
$pdata$DefineFlatGroup DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$DefineFlatGroup
$pdata$SegmentModuleExit DD imagerel $LN7
	DD	imagerel $LN7+88
	DD	imagerel $unwind$SegmentModuleExit
$pdata$DeleteGroup DD imagerel $LN6
	DD	imagerel $LN6+122
	DD	imagerel $unwind$DeleteGroup
$pdata$SegmentSaveState DD imagerel $LN4
	DD	imagerel $LN4+122
	DD	imagerel $unwind$SegmentSaveState
$pdata$FindToken DD imagerel FindToken
	DD	imagerel FindToken+103
	DD	imagerel $unwind$FindToken
$pdata$UpdateCurPC DD imagerel $LN9
	DD	imagerel $LN9+203
	DD	imagerel $unwind$UpdateCurPC
$pdata$AddLnameItem DD imagerel AddLnameItem
	DD	imagerel AddLnameItem+31
	DD	imagerel $unwind$AddLnameItem
$pdata$FreeLnameQueue DD imagerel FreeLnameQueue
	DD	imagerel FreeLnameQueue+109
	DD	imagerel $unwind$FreeLnameQueue
$pdata$UpdateCurrSegVars DD imagerel UpdateCurrSegVars
	DD	imagerel UpdateCurrSegVars+275
	DD	imagerel $unwind$UpdateCurrSegVars
$pdata$push_seg DD imagerel push_seg
	DD	imagerel push_seg+91
	DD	imagerel $unwind$push_seg
$pdata$pop_seg DD imagerel pop_seg
	DD	imagerel pop_seg+62
	DD	imagerel $unwind$pop_seg
$pdata$CreateGroup DD imagerel CreateGroup
	DD	imagerel CreateGroup+330
	DD	imagerel $unwind$CreateGroup
$pdata$CreateSegment DD imagerel CreateSegment
	DD	imagerel CreateSegment+405
	DD	imagerel $unwind$CreateSegment
$pdata$GrpDir DD imagerel $LN33
	DD	imagerel $LN33+999
	DD	imagerel $unwind$GrpDir
$pdata$CloseSeg DD imagerel CloseSeg
	DD	imagerel CloseSeg+242
	DD	imagerel $unwind$CloseSeg
$pdata$FindClass DD imagerel FindClass
	DD	imagerel FindClass+121
	DD	imagerel $unwind$FindClass
$pdata$CreateClassLname DD imagerel CreateClassLname
	DD	imagerel CreateClassLname+121
	DD	imagerel $unwind$CreateClassLname
$pdata$SetSegmentClass DD imagerel SetSegmentClass
	DD	imagerel SetSegmentClass+69
	DD	imagerel $unwind$SetSegmentClass
$pdata$EndsDir DD imagerel $LN9
	DD	imagerel $LN9+230
	DD	imagerel $unwind$EndsDir
$pdata$SetCurrSeg DD imagerel SetCurrSeg
	DD	imagerel SetCurrSeg+240
	DD	imagerel $unwind$SetCurrSeg
$pdata$UnlinkSeg DD imagerel UnlinkSeg
	DD	imagerel UnlinkSeg+187
	DD	imagerel $unwind$UnlinkSeg
$pdata$SegmentDir DD imagerel $LN98
	DD	imagerel $LN98+4592
	DD	imagerel $unwind$SegmentDir
$pdata$SortSegments DD imagerel $LN21
	DD	imagerel $LN21+476
	DD	imagerel $unwind$SortSegments
pdata	ENDS
xdata	SEGMENT
$unwind$SetSymSegOfs DD 010901H
	DD	04209H
$unwind$GetSymOfssize DD 010901H
	DD	02209H
$unwind$GetCurrOffset DD 010401H
	DD	02204H
$unwind$CreateIntSegment DD 011801H
	DD	06218H
$unwind$SegmentInit DD 010801H
	DD	0a208H
$unwind$SegmentFini DD 010401H
	DD	04204H
$unwind$GetGroup DD 010901H
	DD	02209H
$unwind$GetCurrSegAlign DD 010401H
	DD	02204H
$unwind$SetOfssize DD 010401H
	DD	08204H
$unwind$TypeFromClassName DD 022319H
	DD	0290111H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$DefineFlatGroup DD 010401H
	DD	04204H
$unwind$SegmentModuleExit DD 010401H
	DD	04204H
$unwind$DeleteGroup DD 010901H
	DD	06209H
$unwind$SegmentSaveState DD 010401H
	DD	04204H
$unwind$FindToken DD 011301H
	DD	06213H
$unwind$UpdateCurPC DD 010e01H
	DD	0620eH
$unwind$AddLnameItem DD 010901H
	DD	04209H
$unwind$FreeLnameQueue DD 010401H
	DD	06204H
$unwind$UpdateCurrSegVars DD 010401H
	DD	06204H
$unwind$push_seg DD 010901H
	DD	04209H
$unwind$pop_seg DD 010401H
	DD	04204H
$unwind$CreateGroup DD 010901H
	DD	06209H
$unwind$CreateSegment DD 011301H
	DD	06213H
$unwind$GrpDir DD 010d01H
	DD	0a20dH
$unwind$CloseSeg DD 010901H
	DD	06209H
$unwind$FindClass DD 010d01H
	DD	0620dH
$unwind$CreateClassLname DD 010901H
	DD	06209H
$unwind$SetSegmentClass DD 010e01H
	DD	0620eH
$unwind$EndsDir DD 010d01H
	DD	0420dH
$unwind$SetCurrSeg DD 010d01H
	DD	0620dH
$unwind$UnlinkSeg DD 010901H
	DD	02209H
$unwind$SegmentDir DD 021001H
	DD	0270110H
$unwind$SortSegments DD 010801H
	DD	08208H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
swap$ = 32
changed$ = 33
tv73 = 36
curr$ = 40
tmp$1 = 48
prev$2 = 56
type$ = 80
SortSegments PROC

; 1361 : {

$LN21:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 1362 :     bool changed = TRUE;

	mov	BYTE PTR changed$[rsp], 1
$LN2@SortSegmen:

; 1363 :     bool swap;
; 1364 :     struct dsym *curr;
; 1365 :     //int index = 1;
; 1366 : 
; 1367 :     while ( changed == TRUE ) {

	movzx	eax, BYTE PTR changed$[rsp]
	cmp	eax, 1
	jne	$LN3@SortSegmen

; 1368 :         struct dsym *prev = NULL;

	mov	QWORD PTR prev$2[rsp], 0

; 1369 :         changed = FALSE;

	mov	BYTE PTR changed$[rsp], 0

; 1370 :         for( curr = SymTables[TAB_SEG].head; curr && curr->next ; prev = curr, curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN6@SortSegmen
$LN4@SortSegmen:
	mov	rax, QWORD PTR curr$[rsp]
	mov	QWORD PTR prev$2[rsp], rax
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN6@SortSegmen:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN5@SortSegmen
	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+112], 0
	je	$LN5@SortSegmen

; 1371 :             swap = FALSE;

	mov	BYTE PTR swap$[rsp], 0

; 1372 :             switch (type ) {

	mov	eax, DWORD PTR type$[rsp]
	mov	DWORD PTR tv73[rsp], eax
	cmp	DWORD PTR tv73[rsp], 0
	je	SHORT $LN9@SortSegmen
	cmp	DWORD PTR tv73[rsp], 1
	je	SHORT $LN11@SortSegmen
	cmp	DWORD PTR tv73[rsp], 2
	je	SHORT $LN13@SortSegmen
	jmp	$LN16@SortSegmen
$LN9@SortSegmen:

; 1373 :             case 0:
; 1374 :                 if ( curr->e.seginfo->fileoffset > curr->next->e.seginfo->fileoffset )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	mov	rcx, QWORD PTR [rcx+104]
	mov	ecx, DWORD PTR [rcx+56]
	cmp	DWORD PTR [rax+56], ecx
	jbe	SHORT $LN10@SortSegmen

; 1375 :                     swap = TRUE;

	mov	BYTE PTR swap$[rsp], 1
$LN10@SortSegmen:

; 1376 :                 break;

	jmp	$LN7@SortSegmen
$LN11@SortSegmen:

; 1377 :             case 1:
; 1378 :                 if ( strcmp( curr->sym.name, curr->next->sym.name ) > 0 )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	strcmp
	test	eax, eax
	jle	SHORT $LN12@SortSegmen

; 1379 :                     swap = TRUE;

	mov	BYTE PTR swap$[rsp], 1
$LN12@SortSegmen:

; 1380 :                 break;

	jmp	SHORT $LN7@SortSegmen
$LN13@SortSegmen:

; 1381 :             case 2:
; 1382 :                 if ( curr->e.seginfo->lname_idx > curr->next->e.seginfo->lname_idx ||

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	mov	rcx, QWORD PTR [rcx+104]
	mov	ecx, DWORD PTR [rcx+76]
	cmp	DWORD PTR [rax+76], ecx
	jg	SHORT $LN15@SortSegmen
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	mov	rcx, QWORD PTR [rcx+104]
	mov	ecx, DWORD PTR [rcx+76]
	cmp	DWORD PTR [rax+76], ecx
	jne	SHORT $LN14@SortSegmen
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	_stricmp
	test	eax, eax
	jle	SHORT $LN14@SortSegmen
$LN15@SortSegmen:

; 1383 :                     ( curr->e.seginfo->lname_idx == curr->next->e.seginfo->lname_idx &&
; 1384 :                     ( _stricmp( curr->sym.name, curr->next->sym.name ) > 0 ) ) )
; 1385 :                     swap = TRUE;

	mov	BYTE PTR swap$[rsp], 1
$LN14@SortSegmen:

; 1386 :                 break;

	jmp	SHORT $LN7@SortSegmen
$LN16@SortSegmen:

; 1387 : #ifdef DEBUG_OUT
; 1388 :             default: /**/myassert( 0 );

	mov	edx, 1388				; 0000056cH
	lea	rcx, OFFSET FLAT:$SG11910
	call	InternalError
$LN7@SortSegmen:

; 1389 : #endif
; 1390 :             }
; 1391 :             if ( swap ) {

	movzx	eax, BYTE PTR swap$[rsp]
	test	eax, eax
	je	SHORT $LN17@SortSegmen

; 1392 :                 struct dsym *tmp = curr->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR tmp$1[rsp], rax

; 1393 :                 changed = TRUE;

	mov	BYTE PTR changed$[rsp], 1

; 1394 :                 if ( prev == NULL ) {

	cmp	QWORD PTR prev$2[rsp], 0
	jne	SHORT $LN18@SortSegmen

; 1395 :                     SymTables[TAB_SEG].head = tmp;

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, QWORD PTR tmp$1[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 1396 :                 } else {

	jmp	SHORT $LN19@SortSegmen
$LN18@SortSegmen:

; 1397 :                     prev->next = tmp;

	mov	rax, QWORD PTR prev$2[rsp]
	mov	rcx, QWORD PTR tmp$1[rsp]
	mov	QWORD PTR [rax+112], rcx
$LN19@SortSegmen:

; 1398 :                 }
; 1399 :                 curr->next = tmp->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR tmp$1[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	mov	QWORD PTR [rax+112], rcx

; 1400 :                 tmp->next = curr;

	mov	rax, QWORD PTR tmp$1[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	QWORD PTR [rax+112], rcx
$LN17@SortSegmen:

; 1401 :             }
; 1402 :         }

	jmp	$LN4@SortSegmen
$LN5@SortSegmen:

; 1403 :     }

	jmp	$LN2@SortSegmen
$LN3@SortSegmen:

; 1404 : 
; 1405 :     /* v2.7: don't change segment indices! They're stored in fixup.frame_datum */
; 1406 :     //for ( curr = SymTables[TAB_SEG].head; curr ; curr = curr->next ) {
; 1407 :     //    curr->e.seginfo->seg_idx = index++;
; 1408 :     //}
; 1409 : }

	add	rsp, 72					; 00000048H
	ret	0
SortSegments ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
newcharacteristics$ = 48
dir$ = 56
is_old$ = 64
temp$ = 68
sym$ = 72
oldalign$ = 80
oldcombine$ = 81
oldOfssize$ = 82
name$ = 88
txt$1 = 96
token$ = 104
type$ = 112
tv237 = 120
initstate$ = 124
temp2$ = 128
typeidx$ = 132
tv452 = 136
res$2 = 140
sym2$3 = 144
tv518 = 152
tv579 = 160
tv744 = 168
tv740 = 176
opndx$ = 192
i$ = 320
tokenarray$ = 328
SegmentDir PROC

; 919  : {

$LN98:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 312				; 00000138H

; 920  :     char                is_old = FALSE;

	mov	BYTE PTR is_old$[rsp], 0

; 921  :     char                *token;
; 922  :     int                 typeidx;
; 923  :     const struct typeinfo *type;          /* type of option */
; 924  :     int                 temp;
; 925  :     int                 temp2;
; 926  :     unsigned            initstate = 0;  /* flags for attribute initialization */

	mov	DWORD PTR initstate$[rsp], 0

; 927  :     //unsigned char       oldreadonly;    /* readonly value of a defined segment */
; 928  :     //unsigned char       oldsegtype;
; 929  :     unsigned char       oldOfssize;
; 930  :     char                oldalign;
; 931  :     char                oldcombine;
; 932  :     //struct asym         *oldclsym;
; 933  :     uint_8              newcharacteristics = 0;

	mov	BYTE PTR newcharacteristics$[rsp], 0

; 934  :     struct dsym         *dir;
; 935  :     char                *name;
; 936  :     struct asym         *sym;
; 937  :     struct expr         opndx;
; 938  : 
; 939  :     if ( Parse_Pass != PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN10@SegmentDir

; 940  :         return( SetCurrSeg( i, tokenarray ) );

	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	SetCurrSeg
	jmp	$LN1@SegmentDir
$LN10@SegmentDir:

; 941  : 
; 942  :     if( i != 1 ) {

	cmp	DWORD PTR i$[rsp], 1
	je	SHORT $LN11@SegmentDir

; 943  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@SegmentDir
$LN11@SegmentDir:

; 944  :     }
; 945  : 
; 946  :     name = tokenarray[0].string_ptr;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR name$[rsp], rax

; 947  : 
; 948  :     DebugMsg1(("SegmentDir(%s) enter: ModuleInfo.Ofssize=%u, num_seg=%u\n", name, ModuleInfo.Ofssize, ModuleInfo.g.num_segs ));

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	r9d, DWORD PTR ModuleInfo+8
	mov	r8d, eax
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11783
	call	DoDebugMsg1

; 949  : 
; 950  :     /* See if the segment is already defined */
; 951  :     sym = SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 952  :     if( sym == NULL || sym->state == SYM_UNDEFINED ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN14@SegmentDir
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN12@SegmentDir
$LN14@SegmentDir:

; 953  : 
; 954  :         /* segment is not defined (yet) */
; 955  :         sym = (struct asym *)CreateSegment( (struct dsym *)sym, name, TRUE );

	mov	r8b, 1
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateSegment
	mov	QWORD PTR sym$[rsp], rax

; 956  :         sym->list = TRUE; /* always list segments */

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+49]
	or	al, 1
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+49], al

; 957  :         dir = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR dir$[rsp], rax
	jmp	$LN13@SegmentDir
$LN12@SegmentDir:

; 958  :         /* v2.12: seg_idx member now set AFTER parsing is done */
; 959  :         //dir->e.seginfo->seg_idx = ++ModuleInfo.g.num_segs;
; 960  : #if 0 //COFF_SUPPORT || ELF_SUPPORT /* v2.09: removed, since not Masm-compatible */
; 961  :         if ( Options.output_format == OFORMAT_COFF
; 962  : #if ELF_SUPPORT
; 963  :             || Options.output_format == OFORMAT_ELF
; 964  : #endif
; 965  :            ) {
; 966  :             char *p;
; 967  :             if ( p = strchr(sym->name, '$') ) {
; 968  :                 char buffer[MAX_ID_LEN+1];
; 969  :                 struct dsym *dir2;
; 970  :                 /* initialize segment with values from the one without suffix */
; 971  :                 memcpy( buffer, sym->name, p - sym->name );
; 972  :                 buffer[p - sym->name] = NULLC;
; 973  :                 if ( ( dir2 = (struct dsym *)SymSearch( buffer ) ) && dir2->sym.state == SYM_SEG ) {
; 974  :                     dir->e.seginfo->segtype  = dir2->e.seginfo->segtype;
; 975  :                     dir->e.seginfo->combine  = dir2->e.seginfo->combine;
; 976  :                     dir->e.seginfo->readonly = dir2->e.seginfo->readonly;
; 977  :                     dir->e.seginfo->Ofssize  = dir2->e.seginfo->Ofssize;
; 978  :                     dir->e.seginfo->alignment= dir2->e.seginfo->alignment;
; 979  :                     dir->e.seginfo->characteristics = dir2->e.seginfo->characteristics;
; 980  :                     dir->e.seginfo->clsym           = dir2->e.seginfo->clsym;
; 981  :                 }
; 982  :             }
; 983  :         }
; 984  : #endif
; 985  :     } else if ( sym->state == SYM_SEG ) { /* segment already defined? */

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 3
	jne	$LN15@SegmentDir

; 986  :         
; 987  :         dir = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR dir$[rsp], rax

; 988  :         /* v2.12: check 'isdefined' instead of lname_idx */
; 989  :         //if( dir->e.seginfo->lname_idx == 0 ) {
; 990  :         if( sym->isdefined == FALSE ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	$LN17@SegmentDir

; 991  :             /* segment was forward referenced (in a GROUP directive), but not really set up */
; 992  :             /* the segment list is to be sorted.
; 993  :              * So unlink the segment and add it at the end.
; 994  :              */
; 995  :             UnlinkSeg( dir );

	mov	rcx, QWORD PTR dir$[rsp]
	call	UnlinkSeg

; 996  :             /* v2.12: seg_idx member now set AFTER parsing is done */
; 997  :             //dir->e.seginfo->seg_idx = ++ModuleInfo.g.num_segs;
; 998  :             dir->next = NULL;

	mov	rax, QWORD PTR dir$[rsp]
	mov	QWORD PTR [rax+112], 0

; 999  :             if ( SymTables[TAB_SEG].head == NULL )

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	cmp	QWORD PTR [rcx+rax], 0
	jne	SHORT $LN19@SegmentDir

; 1000 :                 SymTables[TAB_SEG].head = SymTables[TAB_SEG].tail = dir;

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, QWORD PTR dir$[rsp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, QWORD PTR dir$[rsp]
	mov	QWORD PTR [rcx+rax], rdx
	jmp	SHORT $LN20@SegmentDir
$LN19@SegmentDir:

; 1001 :             else {
; 1002 :                 SymTables[TAB_SEG].tail->next = dir;

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	rcx, QWORD PTR dir$[rsp]
	mov	QWORD PTR [rax+112], rcx

; 1003 :                 SymTables[TAB_SEG].tail = dir;

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, QWORD PTR dir$[rsp]
	mov	QWORD PTR [rcx+rax+8], rdx
$LN20@SegmentDir:

; 1004 :             }
; 1005 :         } else {

	jmp	SHORT $LN18@SegmentDir
$LN17@SegmentDir:

; 1006 :             is_old = TRUE;

	mov	BYTE PTR is_old$[rsp], 1

; 1007 :             //oldreadonly = dir->e.seginfo->readonly;
; 1008 :             //oldsegtype  = dir->e.seginfo->segtype;
; 1009 :             oldOfssize  = dir->e.seginfo->Ofssize;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+104]
	mov	BYTE PTR oldOfssize$[rsp], al

; 1010 :             oldalign    = dir->e.seginfo->alignment;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+106]
	mov	BYTE PTR oldalign$[rsp], al

; 1011 :             oldcombine  = dir->e.seginfo->combine;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+108]
	and	al, 7
	mov	BYTE PTR oldcombine$[rsp], al
$LN18@SegmentDir:

; 1012 :             /* v2.09: class isn't checked anymore, and characteristics is handled differently */
; 1013 :             //oldcharacteristics = dir->e.seginfo->characteristics;
; 1014 :             //oldclsym    = dir->e.seginfo->clsym;
; 1015 :         }
; 1016 : 
; 1017 :     } else {

	jmp	SHORT $LN16@SegmentDir
$LN15@SegmentDir:

; 1018 :         /* symbol is different kind, error */
; 1019 :         DebugMsg(("SegmentDir(%s): symbol redefinition\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11793
	call	DoDebugMsg

; 1020 :         return( EmitErr( SYMBOL_REDEFINITION, name ) );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@SegmentDir
$LN16@SegmentDir:
$LN13@SegmentDir:

; 1021 :     }
; 1022 : 
; 1023 :     i++; /* go past SEGMENT */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1024 : 
; 1025 :     for( ; i < Token_Count; i++ ) {

	jmp	SHORT $LN4@SegmentDir
$LN2@SegmentDir:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@SegmentDir:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@SegmentDir

; 1026 :         token = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR token$[rsp], rax

; 1027 :         DebugMsg1(("SegmentDir(%s): i=%u, string=%s token=%X\n", name, i, token, tokenarray[i].token ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR token$[rsp]
	mov	r8d, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11794
	call	DoDebugMsg1

; 1028 :         if( tokenarray[i].token == T_STRING ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	$LN21@SegmentDir

; 1029 : 
; 1030 :             /* the class name - the only token which is of type STRING */
; 1031 :             /* string must be delimited by [double]quotes */
; 1032 :             if ( tokenarray[i].string_delim != '"' &&

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN22@SegmentDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN22@SegmentDir

; 1033 :                 tokenarray[i].string_delim != '\'' ) {
; 1034 :                 EmitErr( SYNTAX_ERROR_EX, token );

	mov	rdx, QWORD PTR token$[rsp]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1035 :                 continue;

	jmp	$LN2@SegmentDir
$LN22@SegmentDir:

; 1036 :             }
; 1037 :             /* remove the quote delimiters */
; 1038 :             token++;

	mov	rax, QWORD PTR token$[rsp]
	inc	rax
	mov	QWORD PTR token$[rsp], rax

; 1039 :             *(token+tokenarray[i].stringlen) = NULLC;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	rcx, QWORD PTR token$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 1040 : 
; 1041 :             SetSegmentClass( dir, token );

	mov	rdx, QWORD PTR token$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	call	SetSegmentClass

; 1042 : 
; 1043 :             DebugMsg1(("SegmentDir(%s): class found: %s\n", name, token ));

	mov	r8, QWORD PTR token$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11797
	call	DoDebugMsg1

; 1044 :             continue;

	jmp	$LN2@SegmentDir
$LN21@SegmentDir:

; 1045 :         }
; 1046 : 
; 1047 :         /* check the rest of segment attributes.
; 1048 :          */
; 1049 :         typeidx = FindToken( token, SegAttrToken, sizeof( SegAttrToken )/sizeof( SegAttrToken[0] ) );

	mov	r8d, 27
	lea	rdx, OFFSET FLAT:SegAttrToken
	mov	rcx, QWORD PTR token$[rsp]
	call	FindToken
	mov	DWORD PTR typeidx$[rsp], eax

; 1050 :         if( typeidx < 0 ) {

	cmp	DWORD PTR typeidx$[rsp], 0
	jge	SHORT $LN23@SegmentDir

; 1051 :             EmitErr( UNKNOWN_SEGMENT_ATTRIBUTE, token );

	mov	rdx, QWORD PTR token$[rsp]
	mov	ecx, 81					; 00000051H
	call	EmitErr

; 1052 :             continue;

	jmp	$LN2@SegmentDir
$LN23@SegmentDir:

; 1053 :         }
; 1054 :         type = &SegAttrValue[typeidx];

	movsxd	rax, DWORD PTR typeidx$[rsp]
	lea	rcx, OFFSET FLAT:SegAttrValue
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR type$[rsp], rax

; 1055 : 
; 1056 :         /* initstate is used to check if any field is already
; 1057 :          * initialized
; 1058 :          */
; 1059 :         if( initstate & INIT_EXCL_MASK & type->init ) {

	mov	eax, DWORD PTR initstate$[rsp]
	and	eax, 31
	mov	rcx, QWORD PTR type$[rsp]
	movzx	ecx, BYTE PTR [rcx+1]
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN24@SegmentDir

; 1060 :             EmitErr( SEGMENT_ATTRIBUTE_DEFINED_ALREADY, token );

	mov	rdx, QWORD PTR token$[rsp]
	mov	ecx, 77					; 0000004dH
	call	EmitErr

; 1061 :             continue;

	jmp	$LN2@SegmentDir

; 1062 :         } else {

	jmp	SHORT $LN25@SegmentDir
$LN24@SegmentDir:

; 1063 :             initstate |= type->init; /* mark it initialized */

	mov	rax, QWORD PTR type$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	ecx, DWORD PTR initstate$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR initstate$[rsp], eax
$LN25@SegmentDir:

; 1064 :         }
; 1065 : 
; 1066 :         switch ( type->init ) {

	mov	rax, QWORD PTR type$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	DWORD PTR tv237[rsp], eax
	mov	eax, DWORD PTR tv237[rsp]
	dec	eax
	mov	DWORD PTR tv237[rsp], eax
	cmp	DWORD PTR tv237[rsp], 195		; 000000c3H
	ja	$LN74@SegmentDir
	movsxd	rax, DWORD PTR tv237[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN96@SegmentDir[rcx+rax]
	mov	eax, DWORD PTR $LN97@SegmentDir[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN26@SegmentDir:

; 1067 :         case INIT_ATTR:
; 1068 :             dir->e.seginfo->readonly = TRUE;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 1
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	BYTE PTR [rcx+107], al

; 1069 :             break;

	jmp	$LN5@SegmentDir
$LN27@SegmentDir:

; 1070 :         case INIT_ALIGN:
; 1071 :             DebugMsg1(("SegmentDir(%s): align attribute found\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11803
	call	DoDebugMsg1

; 1072 :             dir->e.seginfo->alignment = type->value;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR type$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax+106], cl

; 1073 :             break;

	jmp	$LN5@SegmentDir
$LN28@SegmentDir:

; 1074 :         case INIT_ALIGN_PARAM:
; 1075 :             DebugMsg1(("SegmentDir(%s): ALIGN() found\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11805
	call	DoDebugMsg1

; 1076 :             if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN29@SegmentDir

; 1077 :                 EmitErr( NOT_SUPPORTED_WITH_OMF_FORMAT, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 223				; 000000dfH
	call	EmitErr

; 1078 :                 i = Token_Count; /* stop further parsing of this line */

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rsp], eax

; 1079 :                 break;

	jmp	$LN5@SegmentDir
$LN29@SegmentDir:

; 1080 :             }
; 1081 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1082 :             if ( tokenarray[i].token != T_OP_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN30@SegmentDir

; 1083 :                 EmitErr( EXPECTED, "(" );

	lea	rdx, OFFSET FLAT:$SG11808
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1084 :                 break;

	jmp	$LN5@SegmentDir
$LN30@SegmentDir:

; 1085 :             }
; 1086 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1087 :             if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN31@SegmentDir

; 1088 :                 break;

	jmp	$LN5@SegmentDir
$LN31@SegmentDir:

; 1089 :             if ( tokenarray[i].token != T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN32@SegmentDir

; 1090 :                 EmitErr( EXPECTED, ")" );

	lea	rdx, OFFSET FLAT:$SG11811
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1091 :                 break;

	jmp	$LN5@SegmentDir
$LN32@SegmentDir:

; 1092 :             }
; 1093 :             if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN33@SegmentDir

; 1094 :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 1095 :                 break;

	jmp	$LN5@SegmentDir
$LN33@SegmentDir:

; 1096 :             }
; 1097 :             /*
; 1098 :              COFF allows alignment values
; 1099 :              1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192
; 1100 :              */
; 1101 :             for( temp = 1, temp2 = 0; temp < opndx.value && temp < 8192 ; temp <<= 1, temp2++ );

	mov	DWORD PTR temp$[rsp], 1
	mov	DWORD PTR temp2$[rsp], 0
	jmp	SHORT $LN9@SegmentDir
$LN7@SegmentDir:
	mov	eax, DWORD PTR temp$[rsp]
	shl	eax, 1
	mov	DWORD PTR temp$[rsp], eax
	mov	eax, DWORD PTR temp2$[rsp]
	inc	eax
	mov	DWORD PTR temp2$[rsp], eax
$LN9@SegmentDir:
	mov	eax, DWORD PTR opndx$[rsp]
	cmp	DWORD PTR temp$[rsp], eax
	jge	SHORT $LN8@SegmentDir
	cmp	DWORD PTR temp$[rsp], 8192		; 00002000H
	jge	SHORT $LN8@SegmentDir
	jmp	SHORT $LN7@SegmentDir
$LN8@SegmentDir:

; 1102 :             if( temp != opndx.value ) {

	mov	eax, DWORD PTR opndx$[rsp]
	cmp	DWORD PTR temp$[rsp], eax
	je	SHORT $LN34@SegmentDir

; 1103 :                 EmitErr( POWER_OF_2, opndx.value );

	mov	edx, DWORD PTR opndx$[rsp]
	mov	ecx, 129				; 00000081H
	call	EmitErr
$LN34@SegmentDir:

; 1104 :             }
; 1105 :             dir->e.seginfo->alignment = temp2;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	ecx, BYTE PTR temp2$[rsp]
	mov	BYTE PTR [rax+106], cl

; 1106 :             break;

	jmp	$LN5@SegmentDir
$LN35@SegmentDir:

; 1107 :         case INIT_COMBINE:
; 1108 :             DebugMsg1(("SegmentDir(%s): combine attribute found\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11815
	call	DoDebugMsg1

; 1109 :             dir->e.seginfo->combine = type->value;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR type$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	and	cl, 7
	movzx	eax, BYTE PTR [rax+108]
	and	al, 248					; 000000f8H
	or	al, cl
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	BYTE PTR [rcx+108], al

; 1110 :             break;

	jmp	$LN5@SegmentDir
$LN36@SegmentDir:

; 1111 :         case INIT_COMBINE_AT:
; 1112 :             DebugMsg1(("SegmentDir(%s): AT found\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11817
	call	DoDebugMsg1

; 1113 :             dir->e.seginfo->combine = type->value;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR type$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	and	cl, 7
	movzx	eax, BYTE PTR [rax+108]
	and	al, 248					; 000000f8H
	or	al, cl
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	BYTE PTR [rcx+108], al

; 1114 :             /* v2.05: always use MAX_SEGALIGNMENT */
; 1115 :             //dir->e.seginfo->alignment = -1;
; 1116 :             dir->e.seginfo->alignment = MAX_SEGALIGNMENT;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	BYTE PTR [rax+106], 255			; 000000ffH

; 1117 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1118 :             if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) != ERROR ) {

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	je	SHORT $LN37@SegmentDir

; 1119 :                 if ( opndx.kind == EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN38@SegmentDir

; 1120 :                     dir->e.seginfo->abs_frame = opndx.value;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	ecx, WORD PTR opndx$[rsp]
	mov	WORD PTR [rax+88], cx

; 1121 :                     dir->e.seginfo->abs_offset = 0;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	DWORD PTR [rax+96], 0

; 1122 :                 } else {

	jmp	SHORT $LN39@SegmentDir
$LN38@SegmentDir:

; 1123 :                     EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError
$LN39@SegmentDir:
$LN37@SegmentDir:

; 1124 :                 }
; 1125 :             }
; 1126 :             break;

	jmp	$LN5@SegmentDir
$LN40@SegmentDir:

; 1127 : #if COMDATSUPP
; 1128 :         case INIT_COMBINE_COMDAT:
; 1129 :             DebugMsg1(("SegmentDir(%s): COMDAT found\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11822
	call	DoDebugMsg1

; 1130 :             /* v2.12: COMDAT supported by OMF */
; 1131 :             //if ( Options.output_format != OFORMAT_COFF ) {
; 1132 :             if ( Options.output_format != OFORMAT_COFF && Options.output_format != OFORMAT_OMF ) {

	cmp	DWORD PTR Options+160, 2
	je	SHORT $LN41@SegmentDir
	cmp	DWORD PTR Options+160, 1
	je	SHORT $LN41@SegmentDir

; 1133 :                 EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 224				; 000000e0H
	call	EmitErr

; 1134 :                 i = Token_Count; /* stop further parsing of this line */

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rsp], eax

; 1135 :                 break;

	jmp	$LN5@SegmentDir
$LN41@SegmentDir:

; 1136 :             }
; 1137 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1138 :             if ( tokenarray[i].token != T_OP_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN42@SegmentDir

; 1139 :                 EmitErr( EXPECTED, "(" );

	lea	rdx, OFFSET FLAT:$SG11825
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1140 :                 break;

	jmp	$LN5@SegmentDir
$LN42@SegmentDir:

; 1141 :             }
; 1142 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1143 :             if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN43@SegmentDir

; 1144 :                 break;

	jmp	$LN5@SegmentDir
$LN43@SegmentDir:

; 1145 :             if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN44@SegmentDir

; 1146 :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 1147 :                 i = Token_Count; /* stop further parsing of this line */

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rsp], eax

; 1148 :                 break;

	jmp	$LN5@SegmentDir
$LN44@SegmentDir:

; 1149 :             }
; 1150 :             if ( opndx.value < 1 || opndx.value > 6 ) {

	cmp	DWORD PTR opndx$[rsp], 1
	jl	SHORT $LN47@SegmentDir
	cmp	DWORD PTR opndx$[rsp], 6
	jle	SHORT $LN45@SegmentDir
$LN47@SegmentDir:

; 1151 :                 EmitErr( VALUE_NOT_WITHIN_ALLOWED_RANGE, "1-6" );

	lea	rdx, OFFSET FLAT:$SG11831
	mov	ecx, 24
	call	EmitErr

; 1152 :             } else {

	jmp	$LN46@SegmentDir
$LN45@SegmentDir:

; 1153 :                 /* if value is IMAGE_COMDAT_SELECT_ASSOCIATIVE,
; 1154 :                  * get the associated segment name argument.
; 1155 :                  */
; 1156 :                 if ( opndx.value == 5 ) {

	cmp	DWORD PTR opndx$[rsp], 5
	jne	$LN48@SegmentDir

; 1157 :                     struct asym *sym2;
; 1158 :                     if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN49@SegmentDir

; 1159 :                         EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr

; 1160 :                         i = Token_Count; /* stop further parsing of this line */

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rsp], eax

; 1161 :                         break;

	jmp	$LN5@SegmentDir
$LN49@SegmentDir:

; 1162 :                     }
; 1163 :                     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1164 :                     if ( tokenarray[i].token != T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN50@SegmentDir

; 1165 :                         EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1166 :                         i = Token_Count; /* stop further parsing of this line */

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rsp], eax

; 1167 :                         break;

	jmp	$LN5@SegmentDir
$LN50@SegmentDir:

; 1168 :                     }
; 1169 :                     /* associated segment must be COMDAT, but not associative */
; 1170 :                     sym2 = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym2$3[rsp], rax

; 1171 :                     if ( sym2 == NULL ||
; 1172 :                         sym2->state != SYM_SEG ||
; 1173 :                         ((struct dsym *)sym2)->e.seginfo->comdat_selection == 0 ||

	cmp	QWORD PTR sym2$3[rsp], 0
	je	SHORT $LN53@SegmentDir
	mov	rax, QWORD PTR sym2$3[rsp]
	cmp	DWORD PTR [rax+40], 3
	jne	SHORT $LN53@SegmentDir
	mov	rax, QWORD PTR sym2$3[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+108]
	shr	al, 3
	and	al, 7
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN53@SegmentDir
	mov	rax, QWORD PTR sym2$3[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+108]
	shr	al, 3
	and	al, 7
	movzx	eax, al
	cmp	eax, 5
	jne	SHORT $LN51@SegmentDir
$LN53@SegmentDir:

; 1174 :                         ((struct dsym *)sym2)->e.seginfo->comdat_selection == 5 )
; 1175 :                         EmitErr( INVALID_ASSOCIATED_SEGMENT, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 25
	call	EmitErr
	jmp	SHORT $LN52@SegmentDir
$LN51@SegmentDir:

; 1176 :                     else
; 1177 :                         dir->e.seginfo->comdat_number = ((struct dsym *)sym2)->e.seginfo->seg_idx;

	mov	rax, QWORD PTR sym2$3[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	movzx	eax, WORD PTR [rax+68]
	mov	WORD PTR [rcx+88], ax
$LN52@SegmentDir:

; 1178 :                     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN48@SegmentDir:
$LN46@SegmentDir:

; 1179 :                 }
; 1180 :             }
; 1181 :             if ( tokenarray[i].token != T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN54@SegmentDir

; 1182 :                 EmitErr( EXPECTED, ")" );

	lea	rdx, OFFSET FLAT:$SG11839
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1183 :                 break;

	jmp	$LN5@SegmentDir
$LN54@SegmentDir:

; 1184 :             }
; 1185 :             dir->e.seginfo->comdat_selection = opndx.value;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	ecx, BYTE PTR opndx$[rsp]
	and	cl, 7
	shl	cl, 3
	movzx	eax, BYTE PTR [rax+108]
	and	al, 199					; 000000c7H
	or	al, cl
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	BYTE PTR [rcx+108], al

; 1186 :             dir->e.seginfo->combine = type->value;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR type$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	and	cl, 7
	movzx	eax, BYTE PTR [rax+108]
	and	al, 248					; 000000f8H
	or	al, cl
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	BYTE PTR [rcx+108], al

; 1187 :             break;

	jmp	$LN5@SegmentDir
$LN55@SegmentDir:

; 1188 : #endif
; 1189 :         case INIT_OFSSIZE:
; 1190 :         case INIT_OFSSIZE_FLAT:
; 1191 :             if ( type->init == INIT_OFSSIZE_FLAT ) {

	mov	rax, QWORD PTR type$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 136				; 00000088H
	jne	SHORT $LN56@SegmentDir

; 1192 :                 DefineFlatGroup();

	call	DefineFlatGroup

; 1193 : #if AMD64_SUPPORT
; 1194 :                 /* v2.09: make sure ofssize is at least USE32 for FLAT */
; 1195 :                 dir->e.seginfo->Ofssize = ( ModuleInfo.defOfssize > USE16 ? ModuleInfo.defOfssize : USE32 );

	movzx	eax, BYTE PTR ModuleInfo+405
	test	eax, eax
	jle	SHORT $LN92@SegmentDir
	movzx	eax, BYTE PTR ModuleInfo+405
	mov	DWORD PTR tv452[rsp], eax
	jmp	SHORT $LN93@SegmentDir
$LN92@SegmentDir:
	mov	DWORD PTR tv452[rsp], 1
$LN93@SegmentDir:
	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	ecx, BYTE PTR tv452[rsp]
	mov	BYTE PTR [rax+104], cl

; 1196 : #else
; 1197 :                 dir->e.seginfo->Ofssize = USE32;
; 1198 : #endif
; 1199 :                 /* put the segment into the FLAT group.
; 1200 :                  * this is not quite Masm-compatible, because trying to put
; 1201 :                  * the segment into another group will cause an error.
; 1202 :                  */
; 1203 :                 dir->e.seginfo->group = &ModuleInfo.flat_grp->sym;

	mov	rax, QWORD PTR ModuleInfo+440
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	QWORD PTR [rcx], rax

; 1204 :             } else

	jmp	SHORT $LN57@SegmentDir
$LN56@SegmentDir:

; 1205 :                 dir->e.seginfo->Ofssize = type->value;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR type$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax+104], cl
$LN57@SegmentDir:

; 1206 :             break;

	jmp	$LN5@SegmentDir
$LN58@SegmentDir:

; 1207 : #if COFF_SUPPORT || ELF_SUPPORT || PE_SUPPORT
; 1208 :         case INIT_CHAR_INFO:
; 1209 :             dir->e.seginfo->info = TRUE; /* fixme: check that this flag isn't changed */

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 2
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	BYTE PTR [rcx+107], al

; 1210 :             break;

	jmp	$LN5@SegmentDir
$LN59@SegmentDir:

; 1211 :         case INIT_CHAR:
; 1212 :             DebugMsg1(("SegmentDir(%s): characteristics found\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11845
	call	DoDebugMsg1

; 1213 :             /* characteristics are restricted to COFF/ELF/BIN-PE */
; 1214 :             if ( Options.output_format == OFORMAT_OMF
; 1215 : #if PE_SUPPORT
; 1216 :                 || ( Options.output_format == OFORMAT_BIN && ModuleInfo.sub_format != SFORMAT_PE )

	cmp	DWORD PTR Options+160, 1
	je	SHORT $LN62@SegmentDir
	cmp	DWORD PTR Options+160, 0
	jne	SHORT $LN60@SegmentDir
	cmp	DWORD PTR ModuleInfo+372, 2
	je	SHORT $LN60@SegmentDir
$LN62@SegmentDir:

; 1217 : #endif
; 1218 :                ) {
; 1219 :                 EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 224				; 000000e0H
	call	EmitErr

; 1220 :             } else

	jmp	SHORT $LN61@SegmentDir
$LN60@SegmentDir:

; 1221 :                 newcharacteristics |= type->value;

	mov	rax, QWORD PTR type$[rsp]
	movzx	eax, BYTE PTR [rax]
	movzx	ecx, BYTE PTR newcharacteristics$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR newcharacteristics$[rsp], al
$LN61@SegmentDir:

; 1222 :             break;

	jmp	$LN5@SegmentDir
$LN63@SegmentDir:

; 1223 :         case INIT_ALIAS:
; 1224 :             DebugMsg1(("SegmentDir(%s): ALIAS found, curr value=%s\n", name, dir->e.seginfo->aliasname ? dir->e.seginfo->aliasname : "NULL" ));

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN94@SegmentDir
	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR tv518[rsp], rax
	jmp	SHORT $LN95@SegmentDir
$LN94@SegmentDir:
	lea	rax, OFFSET FLAT:$SG11850
	mov	QWORD PTR tv518[rsp], rax
$LN95@SegmentDir:
	mov	r8, QWORD PTR tv518[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11851
	call	DoDebugMsg1

; 1225 :             /* alias() is restricted to COFF/ELF/BIN-PE */
; 1226 :             if ( Options.output_format == OFORMAT_OMF
; 1227 :                 || ( Options.output_format == OFORMAT_BIN && ModuleInfo.sub_format != SFORMAT_PE )

	cmp	DWORD PTR Options+160, 1
	je	SHORT $LN65@SegmentDir
	cmp	DWORD PTR Options+160, 0
	jne	SHORT $LN64@SegmentDir
	cmp	DWORD PTR ModuleInfo+372, 2
	je	SHORT $LN64@SegmentDir
$LN65@SegmentDir:

; 1228 :                ) {
; 1229 :                 EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 224				; 000000e0H
	call	EmitErr

; 1230 :                 i = Token_Count; /* stop further parsing of this line */

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rsp], eax

; 1231 :                 break;

	jmp	$LN5@SegmentDir
$LN64@SegmentDir:

; 1232 :             }
; 1233 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1234 :             if ( tokenarray[i].token != T_OP_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN66@SegmentDir

; 1235 :                 EmitErr( EXPECTED, "(" );

	lea	rdx, OFFSET FLAT:$SG11855
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1236 :                 break;

	jmp	$LN5@SegmentDir
$LN66@SegmentDir:

; 1237 :             }
; 1238 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1239 :             if ( tokenarray[i].token != T_STRING ||

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN68@SegmentDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN67@SegmentDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN67@SegmentDir
$LN68@SegmentDir:

; 1240 :                 ( tokenarray[i].string_delim != '"' &&
; 1241 :                 tokenarray[i].string_delim != '\'' ) ) {
; 1242 :                 EmitErr( SYNTAX_ERROR_EX, token );

	mov	rdx, QWORD PTR token$[rsp]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1243 :                 i = Token_Count; /* stop further parsing of this line */

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rsp], eax

; 1244 :                 break;

	jmp	$LN5@SegmentDir
$LN67@SegmentDir:

; 1245 :             }
; 1246 :             temp = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR temp$[rsp], eax

; 1247 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1248 :             if ( tokenarray[i].token != T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN69@SegmentDir

; 1249 :                 EmitErr( EXPECTED, ")" );

	lea	rdx, OFFSET FLAT:$SG11859
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1250 :                 break;

	jmp	$LN5@SegmentDir
$LN69@SegmentDir:

; 1251 :             }
; 1252 :             /* v2.10: if segment already exists, check that old and new aliasname are equal */
; 1253 :             if ( is_old ) {

	movsx	eax, BYTE PTR is_old$[rsp]
	test	eax, eax
	je	$LN70@SegmentDir

; 1254 :                 if ( dir->e.seginfo->aliasname == NULL ||
; 1255 :                     ( tokenarray[temp].stringlen != strlen( dir->e.seginfo->aliasname ) ) ||

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	QWORD PTR [rax+96], 0
	je	$LN73@SegmentDir
	movsxd	rax, DWORD PTR temp$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	QWORD PTR tv579[rsp], rax
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	rcx, QWORD PTR [rcx+96]
	call	strlen
	mov	rcx, QWORD PTR tv579[rsp]
	cmp	rcx, rax
	jne	SHORT $LN73@SegmentDir
	movsxd	rax, DWORD PTR temp$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	movsxd	rcx, DWORD PTR temp$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+8]
	inc	rcx
	mov	rdx, QWORD PTR dir$[rsp]
	mov	rdx, QWORD PTR [rdx+104]
	mov	QWORD PTR tv744[rsp], rdx
	mov	r8d, eax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv744[rsp]
	mov	rcx, QWORD PTR [rax+96]
	call	memcmp
	test	eax, eax
	je	SHORT $LN72@SegmentDir
$LN73@SegmentDir:

; 1256 :                     memcmp( dir->e.seginfo->aliasname, tokenarray[temp].string_ptr + 1, tokenarray[temp].stringlen ) ) {
; 1257 :                     EmitErr( SEGDEF_CHANGED, dir->sym.name, MsgGetEx( TXT_ALIASNAME ) );

	mov	ecx, 13
	call	MsgGetEx
	mov	r8, rax
	mov	rax, QWORD PTR dir$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 78					; 0000004eH
	call	EmitErr

; 1258 :                     break;

	jmp	$LN5@SegmentDir
$LN72@SegmentDir:

; 1259 :                 }
; 1260 :             } else {

	jmp	$LN71@SegmentDir
$LN70@SegmentDir:

; 1261 :                 /* v2.10: " + 1" was missing in next line */
; 1262 :                 dir->e.seginfo->aliasname = LclAlloc( tokenarray[temp].stringlen + 1 );

	movsxd	rax, DWORD PTR temp$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	inc	eax
	mov	eax, eax
	mov	ecx, eax
	call	LclAlloc
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	QWORD PTR [rcx+96], rax

; 1263 :                 memcpy( dir->e.seginfo->aliasname, tokenarray[temp].string_ptr+1, tokenarray[temp].stringlen );

	movsxd	rax, DWORD PTR temp$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	movsxd	rcx, DWORD PTR temp$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+8]
	inc	rcx
	mov	rdx, QWORD PTR dir$[rsp]
	mov	rdx, QWORD PTR [rdx+104]
	mov	QWORD PTR tv740[rsp], rdx
	mov	r8d, eax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv740[rsp]
	mov	rcx, QWORD PTR [rax+96]
	call	memcpy

; 1264 :                 *(dir->e.seginfo->aliasname+tokenarray[temp].stringlen) = NULLC;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movsxd	rcx, DWORD PTR temp$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx+16]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rcx+rax], 0
$LN71@SegmentDir:

; 1265 :             }
; 1266 :             DebugMsg1(("SegmentDir(%s): ALIAS argument=>%s<\n", name, dir->e.seginfo->aliasname ));

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	r8, QWORD PTR [rax+96]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11864
	call	DoDebugMsg1

; 1267 :             break;

	jmp	SHORT $LN5@SegmentDir
$LN74@SegmentDir:

; 1268 : #endif
; 1269 : #ifdef DEBUG_OUT
; 1270 :         default: /* shouldn't happen */
; 1271 :             /**/myassert( 0 );

	mov	edx, 1271				; 000004f7H
	lea	rcx, OFFSET FLAT:$SG11866
	call	InternalError
$LN5@SegmentDir:

; 1272 :             break;
; 1273 : #endif
; 1274 :         }
; 1275 :     } /* end for */

	jmp	$LN2@SegmentDir
$LN3@SegmentDir:

; 1276 : 
; 1277 :     /* make a guess about the segment's type */
; 1278 :     if( dir->e.seginfo->segtype != SEGTYPE_CODE ) {

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+72], 1
	je	SHORT $LN75@SegmentDir

; 1279 :         enum seg_type res;
; 1280 : 
; 1281 :         //token = GetLname( dir->e.seginfo->class_name_idx );
; 1282 :         res = TypeFromClassName( dir, dir->e.seginfo->clsym );

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rdx, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR dir$[rsp]
	call	TypeFromClassName
	mov	DWORD PTR res$2[rsp], eax

; 1283 :         if( res != SEGTYPE_UNDEF ) {

	cmp	DWORD PTR res$2[rsp], 0
	je	SHORT $LN76@SegmentDir

; 1284 :             dir->e.seginfo->segtype = res;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	ecx, DWORD PTR res$2[rsp]
	mov	DWORD PTR [rax+72], ecx
$LN76@SegmentDir:
$LN75@SegmentDir:

; 1285 :         }
; 1286 : #if 0 /* v2.03: removed */
; 1287 :         else {
; 1288 :             res = TypeFromSegmentName( name );
; 1289 :             dir->e.seginfo->segtype = res;
; 1290 :         }
; 1291 : #endif
; 1292 :     }
; 1293 : 
; 1294 :     if( is_old ) {

	movsx	eax, BYTE PTR is_old$[rsp]
	test	eax, eax
	je	$LN77@SegmentDir

; 1295 :         int txt = 0;

	mov	DWORD PTR txt$1[rsp], 0

; 1296 : 
; 1297 :         /* Check if new definition is different from previous one */
; 1298 : 
; 1299 :         // oldobj = dir->e.seginfo->segrec;
; 1300 :         if ( oldalign    != dir->e.seginfo->alignment )

	movsx	eax, BYTE PTR oldalign$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	movzx	ecx, BYTE PTR [rcx+106]
	cmp	eax, ecx
	je	SHORT $LN79@SegmentDir

; 1301 :             txt = TXT_ALIGNMENT;

	mov	DWORD PTR txt$1[rsp], 8
	jmp	SHORT $LN80@SegmentDir
$LN79@SegmentDir:

; 1302 :         else if ( oldcombine  != dir->e.seginfo->combine )

	movsx	eax, BYTE PTR oldcombine$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	movzx	ecx, BYTE PTR [rcx+108]
	and	cl, 7
	movzx	ecx, cl
	cmp	eax, ecx
	je	SHORT $LN81@SegmentDir

; 1303 :             txt = TXT_COMBINE;

	mov	DWORD PTR txt$1[rsp], 9
	jmp	SHORT $LN82@SegmentDir
$LN81@SegmentDir:

; 1304 :         else if ( oldOfssize  != dir->e.seginfo->Ofssize )

	movzx	eax, BYTE PTR oldOfssize$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	movzx	ecx, BYTE PTR [rcx+104]
	cmp	eax, ecx
	je	SHORT $LN83@SegmentDir

; 1305 :             txt = TXT_SEG_WORD_SIZE;

	mov	DWORD PTR txt$1[rsp], 10
	jmp	SHORT $LN84@SegmentDir
$LN83@SegmentDir:

; 1306 : #if 0 /* v2.09: removed */
; 1307 :         else if(  oldreadonly != dir->e.seginfo->readonly )
; 1308 :             /* readonly is not a true segment attribute */
; 1309 :             txt = TXT_READONLY;
; 1310 :         else if ( oldclsym != dir->e.seginfo->clsym )
; 1311 :             /* segment class check is done in SetSegmentClass() */
; 1312 :             txt = TXT_CLASS;
; 1313 : #endif
; 1314 :         else if ( newcharacteristics && ( newcharacteristics != dir->e.seginfo->characteristics ) )

	movzx	eax, BYTE PTR newcharacteristics$[rsp]
	test	eax, eax
	je	SHORT $LN85@SegmentDir
	movzx	eax, BYTE PTR newcharacteristics$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	movzx	ecx, BYTE PTR [rcx+105]
	cmp	eax, ecx
	je	SHORT $LN85@SegmentDir

; 1315 :             txt = TXT_CHARACTERISTICS;

	mov	DWORD PTR txt$1[rsp], 12
$LN85@SegmentDir:
$LN84@SegmentDir:
$LN82@SegmentDir:
$LN80@SegmentDir:

; 1316 : 
; 1317 :         if ( txt ) {

	cmp	DWORD PTR txt$1[rsp], 0
	je	SHORT $LN86@SegmentDir

; 1318 :             EmitErr( SEGDEF_CHANGED, dir->sym.name, MsgGetEx( txt ) );

	mov	ecx, DWORD PTR txt$1[rsp]
	call	MsgGetEx
	mov	r8, rax
	mov	rax, QWORD PTR dir$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 78					; 0000004eH
	call	EmitErr
$LN86@SegmentDir:

; 1319 :             //return( ERROR ); /* v2: display error, but continue */
; 1320 :         }
; 1321 : 
; 1322 :     } else {

	jmp	SHORT $LN78@SegmentDir
$LN77@SegmentDir:

; 1323 :         /* A new definition */
; 1324 : 
; 1325 :         //sym = &dir->sym;
; 1326 :         sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+48], al

; 1327 :         sym->segment = sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+32], rcx

; 1328 :         sym->offset = 0; /* remains 0 ( =segment's local start offset ) */

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+16], 0

; 1329 : #if COMDATSUPP
; 1330 :         /* no segment index for COMDAT segments in OMF! */
; 1331 :         if ( dir->e.seginfo->comdat_selection && Options.output_format == OFORMAT_OMF )

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+108]
	shr	al, 3
	and	al, 7
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN87@SegmentDir
	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN87@SegmentDir

; 1332 :             ;

	jmp	SHORT $LN88@SegmentDir
$LN87@SegmentDir:

; 1333 :         else {
; 1334 : #endif
; 1335 :             dir->e.seginfo->seg_idx = ++ModuleInfo.g.num_segs;

	mov	eax, DWORD PTR ModuleInfo+8
	inc	eax
	mov	DWORD PTR ModuleInfo+8, eax
	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	ecx, DWORD PTR ModuleInfo+8
	mov	DWORD PTR [rax+68], ecx

; 1336 :             /* dir->e.seginfo->lname_idx = */ AddLnameItem( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	AddLnameItem
$LN88@SegmentDir:
$LN78@SegmentDir:

; 1337 : #if COMDATSUPP
; 1338 :         }
; 1339 : #endif
; 1340 : 
; 1341 :     }
; 1342 :     if ( newcharacteristics )

	movzx	eax, BYTE PTR newcharacteristics$[rsp]
	test	eax, eax
	je	SHORT $LN89@SegmentDir

; 1343 :         dir->e.seginfo->characteristics = newcharacteristics;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	ecx, BYTE PTR newcharacteristics$[rsp]
	mov	BYTE PTR [rax+105], cl
$LN89@SegmentDir:

; 1344 : 
; 1345 :     push_seg( dir ); /* set CurrSeg */

	mov	rcx, QWORD PTR dir$[rsp]
	call	push_seg

; 1346 : 
; 1347 :     if ( ModuleInfo.list )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN90@SegmentDir

; 1348 :         LstWrite( LSTTYPE_LABEL, 0, NULL );

	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, 7
	call	LstWrite
$LN90@SegmentDir:

; 1349 : 
; 1350 :     return( SetOfssize() );

	call	SetOfssize
$LN1@SegmentDir:

; 1351 : }

	add	rsp, 312				; 00000138H
	ret	0
	npad	1
$LN97@SegmentDir:
	DD	$LN26@SegmentDir
	DD	$LN27@SegmentDir
	DD	$LN35@SegmentDir
	DD	$LN55@SegmentDir
	DD	$LN63@SegmentDir
	DD	$LN59@SegmentDir
	DD	$LN28@SegmentDir
	DD	$LN36@SegmentDir
	DD	$LN58@SegmentDir
	DD	$LN40@SegmentDir
	DD	$LN74@SegmentDir
$LN96@SegmentDir:
	DB	0
	DB	1
	DB	10
	DB	2
	DB	10
	DB	10
	DB	10
	DB	3
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	4
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	5
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	6
	DB	10
	DB	7
	DB	10
	DB	10
	DB	10
	DB	3
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	8
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	9
SegmentDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
curr$ = 0
prev$ = 8
dir$ = 32
UnlinkSeg PROC

; 896  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 897  :     struct dsym *curr;
; 898  :     struct dsym *prev;
; 899  :     for ( curr = SymTables[TAB_SEG].head, prev = NULL; curr; prev = curr, curr = curr->next )

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	mov	QWORD PTR prev$[rsp], 0
	jmp	SHORT $LN4@UnlinkSeg
$LN2@UnlinkSeg:
	mov	rax, QWORD PTR curr$[rsp]
	mov	QWORD PTR prev$[rsp], rax
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN4@UnlinkSeg:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@UnlinkSeg

; 900  :         if ( curr == dir ) {

	mov	rax, QWORD PTR dir$[rsp]
	cmp	QWORD PTR curr$[rsp], rax
	jne	SHORT $LN5@UnlinkSeg

; 901  :             /* if segment is first, set a new head */
; 902  :             if ( prev == NULL )

	cmp	QWORD PTR prev$[rsp], 0
	jne	SHORT $LN6@UnlinkSeg

; 903  :                 SymTables[TAB_SEG].head = curr->next;

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rdx+112]
	mov	QWORD PTR [rcx+rax], rdx
	jmp	SHORT $LN7@UnlinkSeg
$LN6@UnlinkSeg:

; 904  :             else
; 905  :                 prev->next = curr->next;

	mov	rax, QWORD PTR prev$[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	mov	QWORD PTR [rax+112], rcx
$LN7@UnlinkSeg:

; 906  : 
; 907  :             /* if segment is last, set a new tail */
; 908  :             if ( curr->next == NULL )

	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+112], 0
	jne	SHORT $LN8@UnlinkSeg

; 909  :                 SymTables[TAB_SEG].tail = prev;

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, QWORD PTR prev$[rsp]
	mov	QWORD PTR [rcx+rax+8], rdx
$LN8@UnlinkSeg:

; 910  :             break;

	jmp	SHORT $LN3@UnlinkSeg
$LN5@UnlinkSeg:

; 911  :         }

	jmp	$LN2@UnlinkSeg
$LN3@UnlinkSeg:

; 912  :     return;
; 913  : }

	add	rsp, 24
	ret	0
UnlinkSeg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
sym$ = 32
i$ = 64
tokenarray$ = 72
SetCurrSeg PROC

; 871  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 872  :     struct asym *sym;
; 873  : 
; 874  :     sym = SymSearch( tokenarray[0].string_ptr );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 875  :     DebugMsg1(("SetCurrSeg(%s) sym=%p\n", tokenarray[0].string_ptr, sym));

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	r8, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11713
	call	DoDebugMsg1

; 876  :     if ( sym == NULL || sym->state != SYM_SEG ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN3@SetCurrSeg
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 3
	je	SHORT $LN2@SetCurrSeg
$LN3@SetCurrSeg:

; 877  :         return( EmitErr( SEGMENT_NOT_DEFINED, tokenarray[0].string_ptr ) );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 83					; 00000053H
	call	EmitErr
	jmp	SHORT $LN1@SetCurrSeg
$LN2@SetCurrSeg:

; 878  :     }
; 879  :     /* v2.04: added */
; 880  :     sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+48], al

; 881  :     if ( CurrSeg && Options.output_format == OFORMAT_OMF ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN4@SetCurrSeg
	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN4@SetCurrSeg

; 882  :         omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 883  :         if ( Options.no_comment_data_in_code_records == FALSE )

	movzx	eax, BYTE PTR Options+128
	test	eax, eax
	jne	SHORT $LN5@SetCurrSeg

; 884  :             omf_OutSelect( FALSE );

	xor	ecx, ecx
	call	omf_OutSelect
$LN5@SetCurrSeg:
$LN4@SetCurrSeg:

; 885  :     }
; 886  :     push_seg( (struct dsym *)sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	push_seg

; 887  : 
; 888  :     if ( ModuleInfo.list )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@SetCurrSeg

; 889  :         LstWrite( LSTTYPE_LABEL, 0, NULL );

	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, 7
	call	LstWrite
$LN6@SetCurrSeg:

; 890  : 
; 891  :     return( SetOfssize() );

	call	SetOfssize
$LN1@SetCurrSeg:

; 892  : }

	add	rsp, 56					; 00000038H
	ret	0
SetCurrSeg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
EndsDir	PROC

; 846  : {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 847  :     if( CurrStruct != NULL ) {

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN2@EndsDir

; 848  :         return( EndstructDirective( i, tokenarray ) );

	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	EndstructDirective
	jmp	$LN1@EndsDir
$LN2@EndsDir:

; 849  :     }
; 850  :     /* a label must precede ENDS */
; 851  :     if( i != 1 ) {

	cmp	DWORD PTR i$[rsp], 1
	je	SHORT $LN3@EndsDir

; 852  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@EndsDir
$LN3@EndsDir:

; 853  :     }
; 854  :     if ( Parse_Pass != PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN4@EndsDir

; 855  :         if ( ModuleInfo.list )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@EndsDir

; 856  :             LstWrite( LSTTYPE_LABEL, 0, NULL );

	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, 7
	call	LstWrite
$LN5@EndsDir:
$LN4@EndsDir:

; 857  :     }
; 858  :     if ( CloseSeg( tokenarray[0].string_ptr ) == ERROR )

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	CloseSeg
	cmp	eax, -1
	jne	SHORT $LN6@EndsDir

; 859  :         return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@EndsDir
$LN6@EndsDir:

; 860  :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 861  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN7@EndsDir

; 862  :         EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN7@EndsDir:

; 863  :     }
; 864  :     return( SetOfssize() );

	call	SetOfssize
$LN1@EndsDir:

; 865  : }

	add	rsp, 40					; 00000028H
	ret	0
EndsDir	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
clsym$ = 32
seg$ = 64
name$ = 72
SetSegmentClass PROC

; 787  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 788  :     struct asym *clsym;
; 789  : 
; 790  :     clsym = CreateClassLname( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	CreateClassLname
	mov	QWORD PTR clsym$[rsp], rax

; 791  :     if( clsym == NULL ) {

	cmp	QWORD PTR clsym$[rsp], 0
	jne	SHORT $LN2@SetSegment

; 792  :         return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@SetSegment
$LN2@SetSegment:

; 793  :     }
; 794  : #if 0 /* v2.09: Masm allows a segment's class name to change */
; 795  :     if ( seg->e.seginfo->clsym == NULL )
; 796  :         seg->e.seginfo->clsym = clsym;
; 797  :     else if ( seg->e.seginfo->clsym != clsym ) {
; 798  :         return( EmitErr( SEGDEF_CHANGED, seg->sym.name, MsgGetEx( TXT_CLASS ) ) );
; 799  :     }
; 800  : #else
; 801  :     seg->e.seginfo->clsym = clsym;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR clsym$[rsp]
	mov	QWORD PTR [rax+80], rcx

; 802  : #endif
; 803  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetSegment:

; 804  : }

	add	rsp, 56					; 00000038H
	ret	0
SetSegmentClass ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
len$ = 32
sym$ = 40
name$ = 64
CreateClassLname PROC

; 761  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 762  :     struct asym *sym;
; 763  :     int len = strlen( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 764  : 
; 765  :     /* max lname is 255 - this is an OMF restriction */
; 766  :     if( len > MAX_LNAME ) {

	cmp	DWORD PTR len$[rsp], 255		; 000000ffH
	jle	SHORT $LN2@CreateClas

; 767  :         EmitError( CLASS_NAME_TOO_LONG );

	mov	ecx, 79					; 0000004fH
	call	EmitError

; 768  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@CreateClas
$LN2@CreateClas:

; 769  :     }
; 770  : 
; 771  :     if ( !( sym = FindClass( name, len ) ) ) {

	mov	edx, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR name$[rsp]
	call	FindClass
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN3@CreateClas

; 772  :         /* the classes aren't inserted into the symbol table
; 773  :          but they are in a queue */
; 774  :         sym = SymAlloc( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymAlloc
	mov	QWORD PTR sym$[rsp], rax

; 775  :         sym->state = SYM_CLASS_LNAME;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+40], 11

; 776  :         /* sym->class_lname_idx = */ AddLnameItem( sym ); /* index needed by OMF only */

	mov	rcx, QWORD PTR sym$[rsp]
	call	AddLnameItem
$LN3@CreateClas:

; 777  :     }
; 778  : 
; 779  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]
$LN1@CreateClas:

; 780  : }

	add	rsp, 56					; 00000038H
	ret	0
CreateClassLname ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
node$ = 32
sym$1 = 40
name$ = 64
len$ = 72
FindClass PROC

; 742  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 743  :     struct qnode    *node;
; 744  : 
; 745  :     for( node = ModuleInfo.g.LnameQueue.head; node; node = node->next ) {

	mov	rax, QWORD PTR ModuleInfo+32
	mov	QWORD PTR node$[rsp], rax
	jmp	SHORT $LN4@FindClass
$LN2@FindClass:
	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR node$[rsp], rax
$LN4@FindClass:
	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN3@FindClass

; 746  :         struct asym *sym = node->sym;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR sym$1[rsp], rax

; 747  :         /* v2.09: use SymCmpFunc (optionally case-sensitive, depending on OPTION CASEMAP) */
; 748  :         //if( sym->state == SYM_CLASS_LNAME && ( _stricmp( sym->name, name ) == 0 ) )
; 749  :         if( sym->state == SYM_CLASS_LNAME && ( SymCmpFunc( sym->name, name, len ) == 0 ) )

	mov	rax, QWORD PTR sym$1[rsp]
	cmp	DWORD PTR [rax+40], 11
	jne	SHORT $LN5@FindClass
	movsxd	rax, DWORD PTR len$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR sym$1[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	jne	SHORT $LN5@FindClass

; 750  :             return( sym );

	mov	rax, QWORD PTR sym$1[rsp]
	jmp	SHORT $LN1@FindClass
$LN5@FindClass:

; 751  :     }

	jmp	SHORT $LN2@FindClass
$LN3@FindClass:

; 752  :     return( NULL );

	xor	eax, eax
$LN1@FindClass:

; 753  : }

	add	rsp, 56					; 00000038H
	ret	0
FindClass ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
tv77 = 32
name$ = 64
CloseSeg PROC

; 546  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 547  :     //struct asym      *sym;
; 548  : 
; 549  :     DebugMsg1(("CloseSeg(%s) enter\n", name));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11559
	call	DoDebugMsg1

; 550  : 
; 551  :     if( CurrSeg == NULL || ( SymCmpFunc( CurrSeg->sym.name, name, CurrSeg->sym.name_size ) != 0 ) ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN3@CloseSeg
	mov	rax, QWORD PTR ModuleInfo+432
	movzx	eax, BYTE PTR [rax+80]
	mov	r8d, eax
	mov	rdx, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+8]
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN2@CloseSeg
$LN3@CloseSeg:

; 552  :         DebugMsg(("CloseSeg(%s): nesting error, CurrSeg=%s\n", name, CurrSeg ? CurrSeg->sym.name : "(null)" ));

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN7@CloseSeg
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv77[rsp], rax
	jmp	SHORT $LN8@CloseSeg
$LN7@CloseSeg:
	lea	rax, OFFSET FLAT:$SG11562
	mov	QWORD PTR tv77[rsp], rax
$LN8@CloseSeg:
	mov	r8, QWORD PTR tv77[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11563
	call	DoDebugMsg

; 553  :         return( EmitErr( BLOCK_NESTING_ERROR, name ) );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 80					; 00000050H
	call	EmitErr
	jmp	SHORT $LN1@CloseSeg
$LN2@CloseSeg:

; 554  :     }
; 555  : 
; 556  :     DebugMsg1(("CloseSeg(%s): current ofs=%" I32_SPEC "X\n", name, CurrSeg->e.seginfo->current_loc));

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	mov	r8d, DWORD PTR [rax+12]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11564
	call	DoDebugMsg1

; 557  : 
; 558  :     if ( write_to_file && ( Options.output_format == OFORMAT_OMF ) ) {

	movzx	eax, BYTE PTR write_to_file
	test	eax, eax
	je	SHORT $LN4@CloseSeg
	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN4@CloseSeg

; 559  : 
; 560  :         //if ( !omf_FlushCurrSeg() ) /* v2: error check is obsolete */
; 561  :         //    EmitErr( INTERNAL_ERROR, "CloseSeg", 1 ); /* coding error! */
; 562  :         omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 563  :         if ( Options.no_comment_data_in_code_records == FALSE )

	movzx	eax, BYTE PTR Options+128
	test	eax, eax
	jne	SHORT $LN5@CloseSeg

; 564  :             omf_OutSelect( FALSE );

	xor	ecx, ecx
	call	omf_OutSelect
$LN5@CloseSeg:
$LN4@CloseSeg:

; 565  :     }
; 566  : 
; 567  :     pop_seg();

	call	pop_seg

; 568  : 
; 569  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@CloseSeg:

; 570  : }

	add	rsp, 56					; 00000038H
	ret	0
CloseSeg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
sym$ = 8
p$ = 16
UpdateWordSize PROC

; 510  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 511  :     sym->value = CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 512  :     return;
; 513  : }

	ret	0
UpdateWordSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
seg$ = 32
grp$ = 40
name$ = 48
curr$1 = 56
si$2 = 64
i$ = 96
tokenarray$ = 104
GrpDir	PROC

; 399  : {

$LN33:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 400  :     char        *name;
; 401  :     struct dsym *grp;
; 402  :     struct dsym *seg;
; 403  : 
; 404  :     /* GROUP directive must be at pos 1, needs a name at pos 0 */
; 405  :     if( i != 1 ) {

	cmp	DWORD PTR i$[rsp], 1
	je	SHORT $LN7@GrpDir

; 406  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@GrpDir
$LN7@GrpDir:

; 407  :     }
; 408  :     /* GROUP isn't valid for COFF/ELF/BIN-PE */
; 409  : #if COFF_SUPPORT || ELF_SUPPORT || PE_SUPPORT
; 410  :     if ( Options.output_format == OFORMAT_COFF
; 411  : #if ELF_SUPPORT
; 412  :         || Options.output_format == OFORMAT_ELF
; 413  : #endif
; 414  : #if PE_SUPPORT
; 415  :         || ( Options.output_format == OFORMAT_BIN && ModuleInfo.sub_format == SFORMAT_PE )

	cmp	DWORD PTR Options+160, 2
	je	SHORT $LN9@GrpDir
	cmp	DWORD PTR Options+160, 3
	je	SHORT $LN9@GrpDir
	cmp	DWORD PTR Options+160, 0
	jne	SHORT $LN8@GrpDir
	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN8@GrpDir
$LN9@GrpDir:

; 416  : #endif
; 417  :        ) {
; 418  :         return( EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, _strupr( tokenarray[i].string_ptr ) ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	_strupr
	mov	rdx, rax
	mov	ecx, 224				; 000000e0H
	call	EmitErr
	jmp	$LN1@GrpDir
$LN8@GrpDir:

; 419  :     }
; 420  : #endif
; 421  :     grp = CreateGroup( tokenarray[0].string_ptr );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	CreateGroup
	mov	QWORD PTR grp$[rsp], rax

; 422  :     if( grp == NULL )

	cmp	QWORD PTR grp$[rsp], 0
	jne	SHORT $LN10@GrpDir

; 423  :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@GrpDir
$LN10@GrpDir:

; 424  : 
; 425  :     i++; /* go past GROUP */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@GrpDir:

; 426  : 
; 427  :     do {
; 428  : 
; 429  :         /* get segment name */
; 430  :         if ( tokenarray[i].token != T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN11@GrpDir

; 431  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@GrpDir
$LN11@GrpDir:

; 432  :         }
; 433  :         name = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR name$[rsp], rax

; 434  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 435  : 
; 436  :         seg = (struct dsym *)SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR seg$[rsp], rax

; 437  :         if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN12@GrpDir

; 438  :             if( seg == NULL || seg->sym.state == SYM_UNDEFINED ) {

	cmp	QWORD PTR seg$[rsp], 0
	je	SHORT $LN16@GrpDir
	mov	rax, QWORD PTR seg$[rsp]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN14@GrpDir
$LN16@GrpDir:

; 439  :                 seg = CreateSegment( seg, name, TRUE );

	mov	r8b, 1
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR seg$[rsp]
	call	CreateSegment
	mov	QWORD PTR seg$[rsp], rax

; 440  :                 /* inherit the offset magnitude from the group */
; 441  :                 if ( grp->e.grpinfo->seglist )

	mov	rax, QWORD PTR grp$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN17@GrpDir

; 442  :                     seg->e.seginfo->Ofssize = grp->sym.Ofssize;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR grp$[rsp]
	movzx	ecx, BYTE PTR [rcx+52]
	mov	BYTE PTR [rax+104], cl
$LN17@GrpDir:

; 443  :             } else if( seg->sym.state != SYM_SEG ) {

	jmp	$LN15@GrpDir
$LN14@GrpDir:
	mov	rax, QWORD PTR seg$[rsp]
	cmp	DWORD PTR [rax+40], 3
	je	SHORT $LN18@GrpDir

; 444  :                 return( EmitErr( SEGMENT_EXPECTED, name ) );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 131				; 00000083H
	call	EmitErr
	jmp	$LN1@GrpDir

; 445  :             } else if( seg->e.seginfo->group != NULL &&

	jmp	SHORT $LN19@GrpDir
$LN18@GrpDir:

; 446  :                       /* v2.09: allow segments in FLAT magic group be moved to a "real" group */
; 447  :                       seg->e.seginfo->group != &ModuleInfo.flat_grp->sym &&

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN20@GrpDir
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR ModuleInfo+440
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN20@GrpDir
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR grp$[rsp]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN20@GrpDir

; 448  :                       seg->e.seginfo->group != &grp->sym ) {
; 449  :                 /* segment is in another group */
; 450  :                 DebugMsg(("GrpDir: segment >%s< is in group >%s< already\n", name, seg->e.seginfo->group->name));

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11527
	call	DoDebugMsg

; 451  :                 return( EmitErr( SEGMENT_IN_ANOTHER_GROUP, name ) );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 135				; 00000087H
	call	EmitErr
	jmp	$LN1@GrpDir
$LN20@GrpDir:
$LN19@GrpDir:
$LN15@GrpDir:

; 452  :             }
; 453  :             /* the first segment will define the group's word size */
; 454  :             if( grp->e.grpinfo->seglist == NULL ) {

	mov	rax, QWORD PTR grp$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN21@GrpDir

; 455  :                 grp->sym.Ofssize = seg->e.seginfo->Ofssize;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR grp$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	mov	BYTE PTR [rcx+52], al
	jmp	SHORT $LN22@GrpDir
$LN21@GrpDir:

; 456  :             } else if ( grp->sym.Ofssize != seg->e.seginfo->Ofssize ) {

	mov	rax, QWORD PTR grp$[rsp]
	movzx	eax, BYTE PTR [rax+52]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	movzx	ecx, BYTE PTR [rcx+104]
	cmp	eax, ecx
	je	SHORT $LN23@GrpDir

; 457  :                 return( EmitErr( GROUP_SEGMENT_SIZE_CONFLICT, grp->sym.name, seg->sym.name ) );

	mov	rax, QWORD PTR seg$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR grp$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 239				; 000000efH
	call	EmitErr
	jmp	$LN1@GrpDir
$LN23@GrpDir:
$LN22@GrpDir:

; 458  :             }
; 459  :         } else {

	jmp	SHORT $LN13@GrpDir
$LN12@GrpDir:

; 460  :             /* v2.04: don't check the "defined" flag in passes > 1. It's for IFDEF only! */
; 461  :             //if( seg == NULL || seg->sym.state != SYM_SEG || seg->sym.defined == FALSE ) {
; 462  :             /* v2.07: check the "segment" field instead of "defined" flag! */
; 463  :             //if( seg == NULL || seg->sym.state != SYM_SEG ) {
; 464  :             if( seg == NULL || seg->sym.state != SYM_SEG || seg->sym.segment == NULL ) {

	cmp	QWORD PTR seg$[rsp], 0
	je	SHORT $LN25@GrpDir
	mov	rax, QWORD PTR seg$[rsp]
	cmp	DWORD PTR [rax+40], 3
	jne	SHORT $LN25@GrpDir
	mov	rax, QWORD PTR seg$[rsp]
	cmp	QWORD PTR [rax+32], 0
	jne	SHORT $LN24@GrpDir
$LN25@GrpDir:

; 465  :                 return( EmitErr( SEGMENT_NOT_DEFINED, name ) );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 83					; 00000053H
	call	EmitErr
	jmp	$LN1@GrpDir
$LN24@GrpDir:
$LN13@GrpDir:

; 466  :             }
; 467  :         }
; 468  : 
; 469  :         /* insert segment in group if it's not there already */
; 470  :         if ( seg->e.seginfo->group == NULL ) {

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	QWORD PTR [rax], 0
	jne	$LN26@GrpDir

; 471  :             struct seg_item    *si;
; 472  : 
; 473  :             /* set the segment's grp */
; 474  :             seg->e.seginfo->group = &grp->sym;

	mov	rax, QWORD PTR grp$[rsp]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	QWORD PTR [rcx], rax

; 475  : 
; 476  :             si = LclAlloc( sizeof( struct seg_item ) );

	mov	ecx, 16
	call	LclAlloc
	mov	QWORD PTR si$2[rsp], rax

; 477  :             si->seg = seg;

	mov	rax, QWORD PTR si$2[rsp]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 478  :             si->next = NULL;

	mov	rax, QWORD PTR si$2[rsp]
	mov	QWORD PTR [rax], 0

; 479  :             grp->e.grpinfo->numseg++;

	mov	rax, QWORD PTR grp$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+16]
	inc	eax
	mov	rcx, QWORD PTR grp$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	DWORD PTR [rcx+16], eax

; 480  : 
; 481  :             /* insert the segment at the end of linked list */
; 482  :             if( grp->e.grpinfo->seglist == NULL ) {

	mov	rax, QWORD PTR grp$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN27@GrpDir

; 483  :                 grp->e.grpinfo->seglist = si;

	mov	rax, QWORD PTR grp$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR si$2[rsp]
	mov	QWORD PTR [rax], rcx

; 484  :             } else {

	jmp	SHORT $LN28@GrpDir
$LN27@GrpDir:

; 485  :                 struct seg_item *curr;
; 486  :                 curr = grp->e.grpinfo->seglist;

	mov	rax, QWORD PTR grp$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$1[rsp], rax
$LN5@GrpDir:

; 487  :                 while( curr->next != NULL ) {

	mov	rax, QWORD PTR curr$1[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN6@GrpDir

; 488  :                     curr = curr->next;

	mov	rax, QWORD PTR curr$1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$1[rsp], rax

; 489  :                 }

	jmp	SHORT $LN5@GrpDir
$LN6@GrpDir:

; 490  :                 curr->next = si;

	mov	rax, QWORD PTR curr$1[rsp]
	mov	rcx, QWORD PTR si$2[rsp]
	mov	QWORD PTR [rax], rcx
$LN28@GrpDir:
$LN26@GrpDir:

; 491  :             }
; 492  :         }
; 493  : 
; 494  :         if ( i < Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN29@GrpDir

; 495  :             if ( tokenarray[i].token != T_COMMA || tokenarray[i+1].token == T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN31@GrpDir
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN30@GrpDir
$LN31@GrpDir:

; 496  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@GrpDir
$LN30@GrpDir:

; 497  :             }
; 498  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN29@GrpDir:

; 499  :         }
; 500  : 
; 501  :     } while ( i < Token_Count );

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jl	$LN4@GrpDir

; 502  : 
; 503  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@GrpDir:

; 504  : }

	add	rsp, 88					; 00000058H
	ret	0
GrpDir	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
tv71 = 32
seg$ = 64
name$ = 72
add_global$ = 80
CreateSegment PROC

; 347  : {

	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 348  :     if ( seg == NULL )

	cmp	QWORD PTR seg$[rsp], 0
	jne	SHORT $LN2@CreateSegm

; 349  :         seg = ( add_global ? (struct dsym *)SymCreate( name ) : (struct dsym *)SymAlloc( name ) );

	movzx	eax, BYTE PTR add_global$[rsp]
	test	eax, eax
	je	SHORT $LN9@CreateSegm
	mov	rcx, QWORD PTR name$[rsp]
	call	SymCreate
	mov	QWORD PTR tv71[rsp], rax
	jmp	SHORT $LN10@CreateSegm
$LN9@CreateSegm:
	mov	rcx, QWORD PTR name$[rsp]
	call	SymAlloc
	mov	QWORD PTR tv71[rsp], rax
$LN10@CreateSegm:
	mov	rax, QWORD PTR tv71[rsp]
	mov	QWORD PTR seg$[rsp], rax
	jmp	SHORT $LN3@CreateSegm
$LN2@CreateSegm:

; 350  :     else if ( seg->sym.state == SYM_UNDEFINED )

	mov	rax, QWORD PTR seg$[rsp]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN4@CreateSegm

; 351  :         sym_remove_table( &SymTables[TAB_UNDEF], seg );

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR seg$[rsp]
	mov	rcx, rax
	call	sym_remove_table
$LN4@CreateSegm:
$LN3@CreateSegm:

; 352  : 
; 353  :     if ( seg ) {

	cmp	QWORD PTR seg$[rsp], 0
	je	$LN5@CreateSegm

; 354  :         seg->sym.state = SYM_SEG;

	mov	rax, QWORD PTR seg$[rsp]
	mov	DWORD PTR [rax+40], 3

; 355  :         seg->e.seginfo = LclAlloc( sizeof( struct seg_info ) );

	mov	ecx, 112				; 00000070H
	call	LclAlloc
	mov	rcx, QWORD PTR seg$[rsp]
	mov	QWORD PTR [rcx+104], rax

; 356  :         memset( seg->e.seginfo, 0, sizeof( struct seg_info ) );

	mov	r8d, 112				; 00000070H
	xor	edx, edx
	mov	rax, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rax+104]
	call	memset

; 357  :         seg->e.seginfo->Ofssize = ModuleInfo.defOfssize;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	ecx, BYTE PTR ModuleInfo+405
	mov	BYTE PTR [rax+104], cl

; 358  :         seg->e.seginfo->alignment = 4; /* this is PARA (2^4) */

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	BYTE PTR [rax+106], 4

; 359  :         seg->e.seginfo->combine = COMB_INVALID;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+108]
	and	al, 248					; 000000f8H
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	BYTE PTR [rcx+108], al

; 360  :         /* null class name, in case none is mentioned */
; 361  :         //seg->e.seginfo->clsym = NULL;
; 362  :         seg->next = NULL;

	mov	rax, QWORD PTR seg$[rsp]
	mov	QWORD PTR [rax+112], 0

; 363  :         /* don't use sym_add_table(). Thus the "prev" member
; 364  :          * becomes free for another use.
; 365  :          */
; 366  :         if ( SymTables[TAB_SEG].head == NULL )

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	cmp	QWORD PTR [rcx+rax], 0
	jne	SHORT $LN6@CreateSegm

; 367  :             SymTables[TAB_SEG].head = SymTables[TAB_SEG].tail = seg;

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, QWORD PTR seg$[rsp]
	mov	QWORD PTR [rcx+rax+8], rdx
	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, QWORD PTR seg$[rsp]
	mov	QWORD PTR [rcx+rax], rdx
	jmp	SHORT $LN7@CreateSegm
$LN6@CreateSegm:

; 368  :         else {
; 369  :             SymTables[TAB_SEG].tail->next = seg;

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	QWORD PTR [rax+112], rcx

; 370  :             SymTables[TAB_SEG].tail = seg;

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, QWORD PTR seg$[rsp]
	mov	QWORD PTR [rcx+rax+8], rdx
$LN7@CreateSegm:
$LN5@CreateSegm:

; 371  :         }
; 372  :     }
; 373  :     return( seg );

	mov	rax, QWORD PTR seg$[rsp]

; 374  : }

	add	rsp, 56					; 00000038H
	ret	0
CreateSegment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
grp$ = 32
name$ = 64
CreateGroup PROC

; 315  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 316  :     struct dsym    *grp;
; 317  : 
; 318  :     grp = (struct dsym *)SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR grp$[rsp], rax

; 319  : 
; 320  :     if( grp == NULL || grp->sym.state == SYM_UNDEFINED ) {

	cmp	QWORD PTR grp$[rsp], 0
	je	SHORT $LN4@CreateGrou
	mov	rax, QWORD PTR grp$[rsp]
	cmp	DWORD PTR [rax+40], 0
	jne	$LN2@CreateGrou
$LN4@CreateGrou:

; 321  :         if ( grp == NULL )

	cmp	QWORD PTR grp$[rsp], 0
	jne	SHORT $LN5@CreateGrou

; 322  :             grp = (struct dsym *)SymCreate( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymCreate
	mov	QWORD PTR grp$[rsp], rax
	jmp	SHORT $LN6@CreateGrou
$LN5@CreateGrou:

; 323  :         else
; 324  :             sym_remove_table( &SymTables[TAB_UNDEF], grp );

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR grp$[rsp]
	mov	rcx, rax
	call	sym_remove_table
$LN6@CreateGrou:

; 325  : 
; 326  :         grp->sym.state = SYM_GRP;

	mov	rax, QWORD PTR grp$[rsp]
	mov	DWORD PTR [rax+40], 4

; 327  :         grp->e.grpinfo = LclAlloc( sizeof( struct grp_info ) );

	mov	ecx, 24
	call	LclAlloc
	mov	rcx, QWORD PTR grp$[rsp]
	mov	QWORD PTR [rcx+104], rax

; 328  :         grp->e.grpinfo->seglist = NULL;

	mov	rax, QWORD PTR grp$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR [rax], 0

; 329  :         //grp->e.grpinfo->grp_idx = 0;
; 330  :         //grp->e.grpinfo->lname_idx = 0;
; 331  :         grp->e.grpinfo->numseg = 0;

	mov	rax, QWORD PTR grp$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	DWORD PTR [rax+16], 0

; 332  :         sym_add_table( &SymTables[TAB_GRP], grp );

	mov	eax, 16
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR grp$[rsp]
	mov	rcx, rax
	call	sym_add_table

; 333  : 
; 334  :         grp->sym.list = TRUE;

	mov	rax, QWORD PTR grp$[rsp]
	movzx	eax, BYTE PTR [rax+49]
	or	al, 1
	mov	rcx, QWORD PTR grp$[rsp]
	mov	BYTE PTR [rcx+49], al

; 335  :         grp->e.grpinfo->grp_idx = ++grpdefidx;

	mov	eax, DWORD PTR grpdefidx
	inc	eax
	mov	DWORD PTR grpdefidx, eax
	mov	rax, QWORD PTR grp$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	ecx, DWORD PTR grpdefidx
	mov	DWORD PTR [rax+8], ecx

; 336  :         /* grp->e.grpinfo->lname_idx = */ AddLnameItem( &grp->sym );

	mov	rax, QWORD PTR grp$[rsp]
	mov	rcx, rax
	call	AddLnameItem
	jmp	SHORT $LN3@CreateGrou
$LN2@CreateGrou:

; 337  :     } else if( grp->sym.state != SYM_GRP ) {

	mov	rax, QWORD PTR grp$[rsp]
	cmp	DWORD PTR [rax+40], 4
	je	SHORT $LN7@CreateGrou

; 338  :         EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 339  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@CreateGrou
$LN7@CreateGrou:
$LN3@CreateGrou:

; 340  :     }
; 341  :     grp->sym.isdefined = TRUE;

	mov	rax, QWORD PTR grp$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	or	al, 2
	mov	rcx, QWORD PTR grp$[rsp]
	mov	BYTE PTR [rcx+48], al

; 342  :     return( grp );

	mov	rax, QWORD PTR grp$[rsp]
$LN1@CreateGrou:

; 343  : }

	add	rsp, 56					; 00000038H
	ret	0
CreateGroup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
pop_seg	PROC

; 266  : {

	sub	rsp, 40					; 00000028H

; 267  :     //seg = popitem( &CurrSeg ); /* changed in v1.96 */
; 268  :     /* it's already checked that CurrSeg is != NULL, so
; 269  :      * stkindex must be > 0, but anyway ...
; 270  :      */
; 271  :     if ( stkindex ) {

	cmp	DWORD PTR stkindex, 0
	je	SHORT $LN2@pop_seg

; 272  :         stkindex--;

	mov	eax, DWORD PTR stkindex
	dec	eax
	mov	DWORD PTR stkindex, eax

; 273  :         CurrSeg = SegStack[stkindex];

	movsxd	rax, DWORD PTR stkindex
	lea	rcx, OFFSET FLAT:SegStack
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR ModuleInfo+432, rax

; 274  :         UpdateCurrSegVars();

	call	UpdateCurrSegVars
$LN2@pop_seg:

; 275  :     }
; 276  :     return;
; 277  : }

	add	rsp, 40					; 00000028H
	ret	0
pop_seg	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
seg$ = 48
push_seg PROC

; 250  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 251  :     //pushitem( &CurrSeg, seg ); /* changed in v1.96 */
; 252  :     if ( stkindex >= MAX_SEG_NESTING ) {

	cmp	DWORD PTR stkindex, 20
	jl	SHORT $LN2@push_seg

; 253  :         EmitError( NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 100				; 00000064H
	call	EmitError

; 254  :         return;

	jmp	SHORT $LN1@push_seg
$LN2@push_seg:

; 255  :     }
; 256  :     SegStack[stkindex] = CurrSeg;

	movsxd	rax, DWORD PTR stkindex
	lea	rcx, OFFSET FLAT:SegStack
	mov	rdx, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rcx+rax*8], rdx

; 257  :     stkindex++;

	mov	eax, DWORD PTR stkindex
	inc	eax
	mov	DWORD PTR stkindex, eax

; 258  :     CurrSeg = seg;

	mov	rax, QWORD PTR seg$[rsp]
	mov	QWORD PTR ModuleInfo+432, rax

; 259  :     UpdateCurrSegVars();

	call	UpdateCurrSegVars
$LN1@push_seg:

; 260  :     return;
; 261  : }

	add	rsp, 40					; 00000028H
	ret	0
push_seg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
info$ = 32
tv66 = 40
UpdateCurrSegVars PROC

; 219  : {

	sub	rsp, 56					; 00000038H

; 220  :     struct assume_info *info;
; 221  : 
; 222  :     DebugMsg1(("UpdateCurrSegVars(%s)\n", CurrSeg ? CurrSeg->sym.name : "NULL" ));

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN8@UpdateCurr
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN9@UpdateCurr
$LN8@UpdateCurr:
	lea	rax, OFFSET FLAT:$SG11412
	mov	QWORD PTR tv66[rsp], rax
$LN9@UpdateCurr:
	mov	rdx, QWORD PTR tv66[rsp]
	lea	rcx, OFFSET FLAT:$SG11413
	call	DoDebugMsg1

; 223  :     info = &(SegAssumeTable[ ASSUME_CS ]);

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SegAssumeTable
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR info$[rsp], rax

; 224  :     if( CurrSeg == NULL ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN2@UpdateCurr

; 225  :         info->symbol = NULL;

	mov	rax, QWORD PTR info$[rsp]
	mov	QWORD PTR [rax], 0

; 226  :         info->is_flat = FALSE;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+9], 0

; 227  :         info->error = TRUE;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+8], 1

; 228  :         symCurSeg->string_ptr = "";

	mov	rax, QWORD PTR symCurSeg
	lea	rcx, OFFSET FLAT:$SG11416
	mov	QWORD PTR [rax+16], rcx

; 229  :         //symPC.segment = NULL; /* v2.05: removed */
; 230  :     } else {

	jmp	SHORT $LN3@UpdateCurr
$LN2@UpdateCurr:

; 231  :         info->is_flat = FALSE;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+9], 0

; 232  :         info->error = FALSE;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+8], 0

; 233  :         /* fixme: OPTION OFFSET:SEGMENT? */
; 234  :         if( CurrSeg->e.seginfo->group != NULL ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN4@UpdateCurr

; 235  :             info->symbol = CurrSeg->e.seginfo->group;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 236  :             if ( info->symbol == &ModuleInfo.flat_grp->sym )

	mov	rax, QWORD PTR ModuleInfo+440
	mov	rcx, QWORD PTR info$[rsp]
	cmp	QWORD PTR [rcx], rax
	jne	SHORT $LN6@UpdateCurr

; 237  :                 info->is_flat = TRUE;

	mov	rax, QWORD PTR info$[rsp]
	mov	BYTE PTR [rax+9], 1
$LN6@UpdateCurr:

; 238  :         } else {

	jmp	SHORT $LN5@UpdateCurr
$LN4@UpdateCurr:

; 239  :             info->symbol = &CurrSeg->sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR info$[rsp]
	mov	QWORD PTR [rcx], rax
$LN5@UpdateCurr:

; 240  :         }
; 241  :         symCurSeg->string_ptr = CurrSeg->sym.name;

	mov	rax, QWORD PTR symCurSeg
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+16], rcx
$LN3@UpdateCurr:

; 242  :         //symPC.segment = &CurrSeg->sym; /* v2.05: removed */
; 243  :     }
; 244  :     return;
; 245  : }

	add	rsp, 56					; 00000038H
	ret	0
UpdateCurrSegVars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
curr$ = 32
next$ = 40
FreeLnameQueue PROC

; 195  : {

	sub	rsp, 56					; 00000038H

; 196  :     struct qnode *curr;
; 197  :     struct qnode *next;
; 198  : 
; 199  :     DebugMsg(("FreeLnameQueue enter\n" ));

	lea	rcx, OFFSET FLAT:$SG11402
	call	DoDebugMsg

; 200  :     for( curr = ModuleInfo.g.LnameQueue.head; curr; curr = next ) {

	mov	rax, QWORD PTR ModuleInfo+32
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@FreeLnameQ
$LN2@FreeLnameQ:
	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR curr$[rsp], rax
$LN4@FreeLnameQ:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@FreeLnameQ

; 201  :         next = curr->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR next$[rsp], rax

; 202  :         /* the class name symbols are not part of the
; 203  :          * symbol table and hence must be freed now.
; 204  :          */
; 205  :         if( curr->sym->state == SYM_CLASS_LNAME ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	DWORD PTR [rax+40], 11
	jne	SHORT $LN5@FreeLnameQ

; 206  :             SymFree( curr->sym );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	SymFree
$LN5@FreeLnameQ:

; 207  :         }
; 208  :         LclFree( curr );
; 209  :     }

	jmp	SHORT $LN2@FreeLnameQ
$LN3@FreeLnameQ:

; 210  :     DebugMsg(("FreeLnameQueue exit\n" ));

	lea	rcx, OFFSET FLAT:$SG11404
	call	DoDebugMsg

; 211  : }

	add	rsp, 56					; 00000038H
	ret	0
FreeLnameQueue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
sym$ = 48
AddLnameItem PROC

; 180  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 181  :     QAddItem( &ModuleInfo.g.LnameQueue, sym );

	mov	rdx, QWORD PTR sym$[rsp]
	lea	rcx, OFFSET FLAT:ModuleInfo+32
	call	QAddItem

; 182  :     //return( ++LnamesIdx );
; 183  :     return;
; 184  : 
; 185  : }

	add	rsp, 40					; 00000028H
	ret	0
AddLnameItem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
tv73 = 32
sym$ = 64
p$ = 72
UpdateCurPC PROC

; 131  : {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 132  :     if( CurrStruct ) {

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN2@UpdateCurP

; 133  :         //symPC.segment = NULL;
; 134  :         //symPC.mem_type = MT_ABS;
; 135  :         sym->mem_type = MT_EMPTY;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+44], 192			; 000000c0H

; 136  :         sym->segment = NULL; /* v2.07: needed again */

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+32], 0

; 137  :         sym->offset = CurrStruct->sym.offset + (CurrStruct->next ? CurrStruct->next->sym.offset : 0);

	mov	rax, QWORD PTR CurrStruct
	cmp	QWORD PTR [rax+112], 0
	je	SHORT $LN7@UpdateCurP
	mov	rax, QWORD PTR CurrStruct
	mov	rax, QWORD PTR [rax+112]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv73[rsp], eax
	jmp	SHORT $LN8@UpdateCurP
$LN7@UpdateCurP:
	mov	DWORD PTR tv73[rsp], 0
$LN8@UpdateCurP:
	mov	rax, QWORD PTR CurrStruct
	mov	eax, DWORD PTR [rax+16]
	add	eax, DWORD PTR tv73[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+16], eax
	jmp	SHORT $LN3@UpdateCurP
$LN2@UpdateCurP:

; 138  :     } else if ( CurrSeg ) { /* v2.10: check for CurrSeg != NULL */

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN4@UpdateCurP

; 139  :         sym->mem_type = MT_NEAR;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+44], 129			; 00000081H

; 140  :         sym->segment = (struct asym *)CurrSeg;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rax+32], rcx

; 141  :         sym->offset = GetCurrOffset();

	call	GetCurrOffset
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 142  :     } else

	jmp	SHORT $LN5@UpdateCurP
$LN4@UpdateCurP:

; 143  :         EmitErr( MUST_BE_IN_SEGMENT_BLOCK ); /* v2.10: added */

	mov	ecx, 82					; 00000052H
	call	EmitErr
$LN5@UpdateCurP:
$LN3@UpdateCurP:

; 144  : 
; 145  :     DebugMsg1(("UpdateCurPC: curr value=%" I32_SPEC "Xh\n", sym->offset ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR [rax+16]
	lea	rcx, OFFSET FLAT:$SG11389
	call	DoDebugMsg1

; 146  : }

	add	rsp, 56					; 00000038H
	ret	0
UpdateCurPC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
i$ = 32
token$ = 64
table$ = 72
size$ = 80
FindToken PROC

; 117  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 118  :     int i;
; 119  :     for( i = 0; i < size; i++, table++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@FindToken
$LN2@FindToken:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR table$[rsp]
	add	rax, 8
	mov	QWORD PTR table$[rsp], rax
$LN4@FindToken:
	mov	eax, DWORD PTR size$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@FindToken

; 120  :         if( _stricmp( *table, token ) == 0 ) {

	mov	rdx, QWORD PTR token$[rsp]
	mov	rax, QWORD PTR table$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN5@FindToken

; 121  :             return( i );

	mov	eax, DWORD PTR i$[rsp]
	jmp	SHORT $LN1@FindToken
$LN5@FindToken:

; 122  :         }
; 123  :     }

	jmp	SHORT $LN2@FindToken
$LN3@FindToken:

; 124  :     return( -1 );  /* Not found */

	mov	eax, -1
$LN1@FindToken:

; 125  : }

	add	rsp, 56					; 00000038H
	ret	0
FindToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
SegmentSaveState PROC

; 1587 : {

$LN4:
	sub	rsp, 40					; 00000028H

; 1588 :     //int i;
; 1589 : 
; 1590 :     //i = stkindex;
; 1591 : 
; 1592 :     saved_CurrSeg = CurrSeg;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR saved_CurrSeg, rax

; 1593 :     saved_stkindex = stkindex;

	mov	eax, DWORD PTR stkindex
	mov	DWORD PTR saved_stkindex, eax

; 1594 :     if ( stkindex ) {

	cmp	DWORD PTR stkindex, 0
	je	SHORT $LN2@SegmentSav

; 1595 :         saved_SegStack = LclAlloc( stkindex * sizeof(struct dsym *) );

	movsxd	rax, DWORD PTR stkindex
	shl	rax, 3
	mov	rcx, rax
	call	LclAlloc
	mov	QWORD PTR saved_SegStack, rax

; 1596 :         memcpy( saved_SegStack, &SegStack, stkindex * sizeof(struct dsym *) );

	movsxd	rax, DWORD PTR stkindex
	shl	rax, 3
	mov	r8, rax
	lea	rdx, OFFSET FLAT:SegStack
	mov	rcx, QWORD PTR saved_SegStack
	call	memcpy

; 1597 :         DebugMsg(("SegmentSaveState: saved_segStack=%X\n", saved_SegStack ));

	mov	rdx, QWORD PTR saved_SegStack
	lea	rcx, OFFSET FLAT:$SG11966
	call	DoDebugMsg
$LN2@SegmentSav:

; 1598 :     }
; 1599 : 
; 1600 :     //saved_CurSeg_name  = symCurSeg->string_ptr;
; 1601 : }

	add	rsp, 40					; 00000028H
	ret	0
SegmentSaveState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
curr$ = 32
next$ = 40
dir$ = 64
DeleteGroup PROC

; 379  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 380  : #if FASTMEM==0 || defined(DEBUG_OUT)
; 381  :     struct seg_item    *curr;
; 382  :     struct seg_item    *next;
; 383  : 
; 384  :     for( curr = dir->e.grpinfo->seglist; curr; curr = next ) {

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@DeleteGrou
$LN2@DeleteGrou:
	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR curr$[rsp], rax
$LN4@DeleteGrou:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@DeleteGrou

; 385  :         next = curr->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR next$[rsp], rax

; 386  :         DebugMsg(("DeleteGroup(%s): free seg_item=%p\n", dir->sym.name, curr ));

	mov	r8, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR dir$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11483
	call	DoDebugMsg

; 387  :         LclFree( curr );
; 388  :     }

	jmp	SHORT $LN2@DeleteGrou
$LN3@DeleteGrou:

; 389  : #endif
; 390  :     DebugMsg(("DeleteGroup(%s): extension %p will be freed\n", dir->sym.name, dir->e.grpinfo ));

	mov	rax, QWORD PTR dir$[rsp]
	mov	r8, QWORD PTR [rax+104]
	mov	rax, QWORD PTR dir$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11484
	call	DoDebugMsg

; 391  :     LclFree( dir->e.grpinfo );
; 392  :     return;
; 393  : }

	add	rsp, 56					; 00000038H
	ret	0
DeleteGroup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
SegmentModuleExit PROC

; 1415 : {

$LN7:
	sub	rsp, 40					; 00000028H

; 1416 :     if ( ModuleInfo.model != MODEL_NONE )

	cmp	DWORD PTR ModuleInfo+360, 0
	je	SHORT $LN4@SegmentMod

; 1417 :         ModelSimSegmExit();

	call	ModelSimSegmExit
$LN4@SegmentMod:

; 1418 :     /* if there's still an open segment, it's an error */
; 1419 :     if ( CurrSeg ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN5@SegmentMod

; 1420 :         EmitErr( BLOCK_NESTING_ERROR, CurrSeg->sym.name );

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 80					; 00000050H
	call	EmitErr
$LN2@SegmentMod:

; 1421 :         /* but close the still open segments anyway */
; 1422 :         while( CurrSeg && ( CloseSeg( CurrSeg->sym.name ) == NOT_ERROR ) );

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN3@SegmentMod
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+8]
	call	CloseSeg
	test	eax, eax
	jne	SHORT $LN3@SegmentMod
	jmp	SHORT $LN2@SegmentMod
$LN3@SegmentMod:
$LN5@SegmentMod:

; 1423 :     }
; 1424 : 
; 1425 :     return( NOT_ERROR );

	xor	eax, eax

; 1426 : }

	add	rsp, 40					; 00000028H
	ret	0
SegmentModuleExit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
DefineFlatGroup PROC

; 574  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 575  :     if( ModuleInfo.flat_grp == NULL ) {

	cmp	QWORD PTR ModuleInfo+440, 0
	jne	SHORT $LN2@DefineFlat

; 576  :         /* can't fail because <FLAT> is a reserved word */
; 577  :         ModuleInfo.flat_grp = CreateGroup( "FLAT" );

	lea	rcx, OFFSET FLAT:$SG11571
	call	CreateGroup
	mov	QWORD PTR ModuleInfo+440, rax

; 578  :         ModuleInfo.flat_grp->sym.Ofssize = ModuleInfo.defOfssize;

	mov	rax, QWORD PTR ModuleInfo+440
	movzx	ecx, BYTE PTR ModuleInfo+405
	mov	BYTE PTR [rax+52], cl

; 579  :         DebugMsg1(("DefineFlatGroup(): Ofssize=%u\n", ModuleInfo.flat_grp->sym.Ofssize ));

	mov	rax, QWORD PTR ModuleInfo+440
	movzx	eax, BYTE PTR [rax+52]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11572
	call	DoDebugMsg1
$LN2@DefineFlat:

; 580  :     }
; 581  :     ModuleInfo.flat_grp->sym.isdefined = TRUE; /* v2.09 */

	mov	rax, QWORD PTR ModuleInfo+440
	movzx	eax, BYTE PTR [rax+48]
	or	al, 2
	mov	rcx, QWORD PTR ModuleInfo+440
	mov	BYTE PTR [rcx+48], al

; 582  : }

	add	rsp, 40					; 00000028H
	ret	0
DefineFlatGroup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
tv82 = 32
slen$ = 36
uname$ = 48
__$ArrayPad$ = 304
seg$ = 336
clname$ = 344
TypeFromClassName PROC

; 645  : {

$LN19:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 328				; 00000148H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 646  :     int     slen;
; 647  :     char    uname[MAX_ID_LEN+1];
; 648  : 
; 649  :     if ( seg->e.seginfo->alignment == MAX_SEGALIGNMENT )

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN4@TypeFromCl

; 650  :         return( SEGTYPE_ABS );

	mov	eax, 5
	jmp	$LN1@TypeFromCl
$LN4@TypeFromCl:

; 651  : 
; 652  :     /* v2.03: added */
; 653  :     if ( seg->e.seginfo->combine == COMB_STACK )

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+108]
	and	al, 7
	movzx	eax, al
	cmp	eax, 5
	jne	SHORT $LN5@TypeFromCl

; 654  :         return( SEGTYPE_STACK );

	mov	eax, 4
	jmp	$LN1@TypeFromCl
$LN5@TypeFromCl:

; 655  : 
; 656  :     if( clname == NULL )

	cmp	QWORD PTR clname$[rsp], 0
	jne	SHORT $LN6@TypeFromCl

; 657  :         return( SEGTYPE_UNDEF );

	xor	eax, eax
	jmp	$LN1@TypeFromCl
$LN6@TypeFromCl:

; 658  : 
; 659  :     if( _stricmp( clname->name, GetCodeClass() ) == 0 )

	call	GetCodeClass
	mov	rdx, rax
	mov	rax, QWORD PTR clname$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN7@TypeFromCl

; 660  :         return( SEGTYPE_CODE );

	mov	eax, 1
	jmp	$LN1@TypeFromCl
$LN7@TypeFromCl:

; 661  : 
; 662  :     slen = clname->name_size;

	mov	rax, QWORD PTR clname$[rsp]
	movzx	eax, BYTE PTR [rax+80]
	mov	DWORD PTR slen$[rsp], eax

; 663  :     memcpy( uname, clname->name, clname->name_size + 1 );

	mov	rax, QWORD PTR clname$[rsp]
	movzx	eax, BYTE PTR [rax+80]
	inc	eax
	cdqe
	mov	r8, rax
	mov	rax, QWORD PTR clname$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, QWORD PTR uname$[rsp]
	call	memcpy

; 664  :     _strupr( uname );

	lea	rcx, QWORD PTR uname$[rsp]
	call	_strupr

; 665  :     switch( slen ) {

	mov	eax, DWORD PTR slen$[rsp]
	mov	DWORD PTR tv82[rsp], eax
	cmp	DWORD PTR tv82[rsp], 0
	jl	SHORT $LN8@TypeFromCl
	cmp	DWORD PTR tv82[rsp], 2
	jle	$LN17@TypeFromCl
	cmp	DWORD PTR tv82[rsp], 3
	je	$LN15@TypeFromCl
	cmp	DWORD PTR tv82[rsp], 4
	je	SHORT $LN12@TypeFromCl
$LN8@TypeFromCl:

; 666  :     default:
; 667  :     case 5:
; 668  :         if( memcmp( uname, "CONST", 6 ) == 0 )

	mov	r8d, 6
	lea	rdx, OFFSET FLAT:$SG11619
	lea	rcx, QWORD PTR uname$[rsp]
	call	memcmp
	test	eax, eax
	jne	SHORT $LN9@TypeFromCl

; 669  :             return( SEGTYPE_DATA );

	mov	eax, 2
	jmp	$LN1@TypeFromCl
$LN9@TypeFromCl:

; 670  :         //if( memcmp( uname, "STACK", 6 ) == 0 )
; 671  :         //    return( SEGTYPE_DATA );
; 672  :         if( memcmp( uname, "DBTYP", 6 ) == 0 )

	mov	r8d, 6
	lea	rdx, OFFSET FLAT:$SG11621
	lea	rcx, QWORD PTR uname$[rsp]
	call	memcmp
	test	eax, eax
	jne	SHORT $LN10@TypeFromCl

; 673  :             return( SEGTYPE_DATA );

	mov	eax, 2
	jmp	$LN1@TypeFromCl
$LN10@TypeFromCl:

; 674  :         if( memcmp( uname, "DBSYM", 6 ) == 0 )

	mov	r8d, 6
	lea	rdx, OFFSET FLAT:$SG11623
	lea	rcx, QWORD PTR uname$[rsp]
	call	memcmp
	test	eax, eax
	jne	SHORT $LN11@TypeFromCl

; 675  :             return( SEGTYPE_DATA );

	mov	eax, 2
	jmp	$LN1@TypeFromCl
$LN11@TypeFromCl:
$LN12@TypeFromCl:

; 676  :     case 4:
; 677  :         /* v2.03: changed */
; 678  :         //if( memcmp( uname , "CODE", 5 ) == 0 )
; 679  :         //    return( SEGTYPE_CODE );
; 680  :         if( memcmp( uname + slen - 4, "CODE", 4 ) == 0 )

	movsxd	rax, DWORD PTR slen$[rsp]
	lea	rax, QWORD PTR uname$[rsp+rax-4]
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11626
	mov	rcx, rax
	call	memcmp
	test	eax, eax
	jne	SHORT $LN13@TypeFromCl

; 681  :             return( SEGTYPE_CODE );

	mov	eax, 1
	jmp	SHORT $LN1@TypeFromCl
$LN13@TypeFromCl:

; 682  :         if( memcmp( uname + slen - 4, "DATA", 4 ) == 0 )

	movsxd	rax, DWORD PTR slen$[rsp]
	lea	rax, QWORD PTR uname$[rsp+rax-4]
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11628
	mov	rcx, rax
	call	memcmp
	test	eax, eax
	jne	SHORT $LN14@TypeFromCl

; 683  :             return( SEGTYPE_DATA );

	mov	eax, 2
	jmp	SHORT $LN1@TypeFromCl
$LN14@TypeFromCl:
$LN15@TypeFromCl:

; 684  :     case 3:
; 685  :         if( memcmp( uname + slen - 3, "BSS", 3 ) == 0 )

	movsxd	rax, DWORD PTR slen$[rsp]
	lea	rax, QWORD PTR uname$[rsp+rax-3]
	mov	r8d, 3
	lea	rdx, OFFSET FLAT:$SG11631
	mov	rcx, rax
	call	memcmp
	test	eax, eax
	jne	SHORT $LN16@TypeFromCl

; 686  :             return( SEGTYPE_BSS );

	mov	eax, 3
	jmp	SHORT $LN1@TypeFromCl
$LN16@TypeFromCl:
$LN17@TypeFromCl:

; 687  :     case 2:
; 688  :     case 1:
; 689  :     case 0:
; 690  :         return( SEGTYPE_UNDEF );

	xor	eax, eax
$LN1@TypeFromCl:

; 691  :     }
; 692  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 328				; 00000148H
	ret	0
TypeFromClassName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
tv94 = 48
tv141 = 52
tv144 = 56
SetOfssize PROC

; 520  : {

$LN8:
	sub	rsp, 72					; 00000048H

; 521  :     if( CurrSeg == NULL ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN2@SetOfssize

; 522  :         ModuleInfo.Ofssize = ModuleInfo.defOfssize;

	movzx	eax, BYTE PTR ModuleInfo+405
	mov	BYTE PTR ModuleInfo+404, al

; 523  :     } else {

	jmp	$LN3@SetOfssize
$LN2@SetOfssize:

; 524  :         ModuleInfo.Ofssize = CurrSeg->e.seginfo->Ofssize;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+104]
	mov	BYTE PTR ModuleInfo+404, al

; 525  :         if( (uint_8)ModuleInfo.curr_cpu < min_cpu[ModuleInfo.Ofssize] ) {

	movzx	eax, BYTE PTR ModuleInfo+392
	movzx	ecx, BYTE PTR ModuleInfo+404
	lea	rdx, OFFSET FLAT:min_cpu
	movzx	ecx, WORD PTR [rdx+rcx*2]
	cmp	eax, ecx
	jge	SHORT $LN4@SetOfssize

; 526  :             DebugMsg(("SetOfssize, error: CurrSeg=%s, ModuleInfo.Ofssize=%u, curr_cpu=%X, defOfssize=%u\n",

	movzx	eax, BYTE PTR ModuleInfo+405
	movzx	ecx, BYTE PTR ModuleInfo+404
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR ModuleInfo+392
	mov	r8d, ecx
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11552
	call	DoDebugMsg

; 527  :                       CurrSeg->sym.name, ModuleInfo.Ofssize, ModuleInfo.curr_cpu, ModuleInfo.defOfssize ));
; 528  :             return( EmitErr( INCOMPATIBLE_CPU_MODE_FOR_XXBIT_SEGMENT, 16 << ModuleInfo.Ofssize ) );

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	ecx, 16
	mov	DWORD PTR tv141[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv141[rsp]
	shl	eax, cl
	mov	edx, eax
	mov	ecx, 132				; 00000084H
	call	EmitErr
	jmp	SHORT $LN1@SetOfssize
$LN4@SetOfssize:
$LN3@SetOfssize:

; 529  :         }
; 530  :     }
; 531  :     DebugMsg1(("SetOfssize: ModuleInfo.Ofssize=%u\n", ModuleInfo.Ofssize ));

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11553
	call	DoDebugMsg1

; 532  : 
; 533  :     CurrWordSize = (2 << ModuleInfo.Ofssize);

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	ecx, 2
	mov	DWORD PTR tv144[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv144[rsp]
	shl	eax, cl
	mov	BYTE PTR ModuleInfo+406, al

; 534  : 
; 535  : #if AMD64_SUPPORT
; 536  :     Set64Bit( ModuleInfo.Ofssize == USE64 );

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	SHORT $LN6@SetOfssize
	mov	DWORD PTR tv94[rsp], 1
	jmp	SHORT $LN7@SetOfssize
$LN6@SetOfssize:
	mov	DWORD PTR tv94[rsp], 0
$LN7@SetOfssize:
	movzx	ecx, BYTE PTR tv94[rsp]
	call	Set64Bit

; 537  : #endif
; 538  : 
; 539  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@SetOfssize:

; 540  : }

	add	rsp, 72					; 00000048H
	ret	0
SetOfssize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
tv79 = 0
GetCurrSegAlign PROC

; 305  : {

$LN5:
	sub	rsp, 24

; 306  :     if( CurrSeg == NULL )

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN2@GetCurrSeg

; 307  :         return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@GetCurrSeg
$LN2@GetCurrSeg:

; 308  :     if ( CurrSeg->e.seginfo->alignment == MAX_SEGALIGNMENT ) /* ABS? */

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN3@GetCurrSeg

; 309  :         return( 0x40 ); /* assume PARA alignment for AT segments */

	mov	eax, 64					; 00000040H
	jmp	SHORT $LN1@GetCurrSeg
$LN3@GetCurrSeg:

; 310  :     return( 1 << CurrSeg->e.seginfo->alignment );

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+106]
	mov	ecx, 1
	mov	DWORD PTR tv79[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv79[rsp]
	shl	eax, cl
$LN1@GetCurrSeg:

; 311  : }

	add	rsp, 24
	ret	0
GetCurrSegAlign ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
curr$ = 0
sym$ = 32
GetGroup PROC

; 596  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 597  :     struct dsym  *curr;
; 598  : 
; 599  :     curr = GetSegm( sym );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR curr$[rsp], rax

; 600  :     if( curr != NULL )

	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN2@GetGroup

; 601  :         return( curr->e.seginfo->group );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax]
	jmp	SHORT $LN1@GetGroup
$LN2@GetGroup:

; 602  :     return( NULL );

	xor	eax, eax
$LN1@GetGroup:

; 603  : }

	add	rsp, 24
	ret	0
GetGroup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
SegmentFini PROC

; 1432 : {

$LN4:
	sub	rsp, 40					; 00000028H

; 1433 : #if FASTMEM==0
; 1434 :     struct dsym    *curr;
; 1435 : #endif
; 1436 : 
; 1437 :     DebugMsg(("SegmentFini() enter\n"));

	lea	rcx, OFFSET FLAT:$SG11922
	call	DoDebugMsg

; 1438 : #if FASTMEM==0
; 1439 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {
; 1440 :         struct fixup *fix;
; 1441 :         DebugMsg(("SegmentFini: segment %s\n", curr->sym.name ));
; 1442 :         for ( fix = curr->e.seginfo->FixupList.head; fix ; ) {
; 1443 :             struct fixup *next = fix->nextrlc;
; 1444 :             DebugMsg(("SegmentFini: free fixup [sym=%s, loc=%" I32_SPEC "X]\n", fix->sym ? fix->sym->name : "NULL", fix->location ));
; 1445 :             LclFree( fix );
; 1446 :             fix = next;
; 1447 :         }
; 1448 :     }
; 1449 : #endif
; 1450 : 
; 1451 : #if FASTPASS
; 1452 :     if ( saved_SegStack ) {
; 1453 :         LclFree( saved_SegStack );
; 1454 :     }
; 1455 : #endif
; 1456 :     FreeLnameQueue();

	call	FreeLnameQueue

; 1457 :     DebugMsg(("SegmentFini() exit\n"));

	lea	rcx, OFFSET FLAT:$SG11924
	call	DoDebugMsg

; 1458 : }

	add	rsp, 40					; 00000028H
	ret	0
SegmentFini ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
i$ = 48
curr$ = 56
p$ = 64
pass$ = 96
SegmentInit PROC

; 1464 : {

$LN23:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 1465 :     struct dsym *curr;
; 1466 :     uint_32     i;
; 1467 : #ifdef __I86__
; 1468 :     char __huge *p;
; 1469 : #else
; 1470 :     char        *p;
; 1471 : #endif
; 1472 :     //struct fixup *fix;
; 1473 : 
; 1474 :     DebugMsg(("SegmentInit(%u) enter\n", pass ));

	mov	edx, DWORD PTR pass$[rsp]
	lea	rcx, OFFSET FLAT:$SG11942
	call	DoDebugMsg

; 1475 :     CurrSeg      = NULL;

	mov	QWORD PTR ModuleInfo+432, 0

; 1476 :     stkindex     = 0;

	mov	DWORD PTR stkindex, 0

; 1477 : 
; 1478 :     if ( pass == PASS_1 ) {

	cmp	DWORD PTR pass$[rsp], 0
	jne	SHORT $LN8@SegmentIni

; 1479 :         grpdefidx   = 0;

	mov	DWORD PTR grpdefidx, 0

; 1480 :         //LnamesIdx   = 1; /* the first Lname is a null-string */
; 1481 :         //pCodeBuff = NULL;
; 1482 :         buffer_size = 0;

	mov	DWORD PTR buffer_size, 0
$LN8@SegmentIni:

; 1483 :         //flat_grp    = NULL;
; 1484 : #if FASTPASS
; 1485 : #if FASTMEM==0
; 1486 :         saved_SegStack = NULL;
; 1487 : #endif
; 1488 : #endif
; 1489 : 
; 1490 : #if 0 /* v2.03: obsolete, also belongs to simplified segment handling */
; 1491 :         /* set ModuleInfo.code_class */
; 1492 :         if( Options.code_class  )
; 1493 :             size = strlen( Options.code_class ) + 1;
; 1494 :         else
; 1495 :             size = 4 + 1;
; 1496 :         ModuleInfo.code_class = LclAlloc( size );
; 1497 :         if ( Options.code_class )
; 1498 :             strcpy( ModuleInfo.code_class, Options.code_class );
; 1499 :         else
; 1500 :             strcpy( ModuleInfo.code_class, "CODE" );
; 1501 : #endif
; 1502 :     }
; 1503 : 
; 1504 :     /*
; 1505 :      * alloc a buffer for the contents
; 1506 :      */
; 1507 : 
; 1508 :     if ( ModuleInfo.pCodeBuff == NULL && Options.output_format != OFORMAT_OMF ) {

	cmp	QWORD PTR ModuleInfo+448, 0
	jne	$LN9@SegmentIni
	cmp	DWORD PTR Options+160, 1
	je	$LN9@SegmentIni

; 1509 :         for( curr = SymTables[TAB_SEG].head, buffer_size = 0; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	mov	DWORD PTR buffer_size, 0
	jmp	SHORT $LN4@SegmentIni
$LN2@SegmentIni:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN4@SegmentIni:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN3@SegmentIni

; 1510 :             if ( curr->e.seginfo->internal )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+107]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@SegmentIni

; 1511 :                 continue;

	jmp	SHORT $LN2@SegmentIni
$LN10@SegmentIni:

; 1512 :             if ( curr->e.seginfo->bytes_written ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+24], 0
	je	SHORT $LN11@SegmentIni

; 1513 :                 i = curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR [rcx+64]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$[rsp], eax

; 1514 :                 /* the segment can grow in step 2-n due to forward references.
; 1515 :                  * for a quick solution just add 25% to the size if segment
; 1516 :                  * is a code segment. (v2.02: previously if was added only if
; 1517 :                  * code segment contained labels, but this isn't sufficient.)
; 1518 :                  */
; 1519 :                 //if ( curr->e.seginfo->labels ) /* v2.02: changed */
; 1520 :                 if ( curr->e.seginfo->segtype == SEGTYPE_CODE )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+72], 1
	jne	SHORT $LN12@SegmentIni

; 1521 :                     i = i + (i >> 2);

	mov	eax, DWORD PTR i$[rsp]
	shr	eax, 2
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$[rsp], eax
$LN12@SegmentIni:

; 1522 :                 DebugMsg(("SegmentInit(%u), %s: max_ofs=%" I32_SPEC "X, alloc_size=%" I32_SPEC "Xh\n", pass, curr->sym.name, curr->sym.max_offset, i ));

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR curr$[rsp]
	mov	r9d, DWORD PTR [rax+64]
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR pass$[rsp]
	lea	rcx, OFFSET FLAT:$SG11948
	call	DoDebugMsg

; 1523 :                 buffer_size += i;

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR buffer_size
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR buffer_size, eax
$LN11@SegmentIni:

; 1524 :             }
; 1525 :         }

	jmp	$LN2@SegmentIni
$LN3@SegmentIni:

; 1526 :         if ( buffer_size ) {

	cmp	DWORD PTR buffer_size, 0
	je	SHORT $LN13@SegmentIni

; 1527 :             ModuleInfo.pCodeBuff = LclAlloc( buffer_size );

	mov	eax, DWORD PTR buffer_size
	mov	ecx, eax
	call	LclAlloc
	mov	QWORD PTR ModuleInfo+448, rax

; 1528 :             DebugMsg(("SegmentInit(%u): total buffer size=%" I32_SPEC "X, start=%p\n", pass, buffer_size, ModuleInfo.pCodeBuff ));

	mov	r9, QWORD PTR ModuleInfo+448
	mov	r8d, DWORD PTR buffer_size
	mov	edx, DWORD PTR pass$[rsp]
	lea	rcx, OFFSET FLAT:$SG11950
	call	DoDebugMsg
$LN13@SegmentIni:
$LN9@SegmentIni:

; 1529 :         }
; 1530 :     }
; 1531 :     /* Reset length of all segments to zero.
; 1532 :      * set start of segment buffers.
; 1533 :      */
; 1534 : #if FASTMEM==0
; 1535 :     /* fastmem clears the memory blocks, but malloc() won't */
; 1536 :     if ( ModuleInfo.pCodeBuff )
; 1537 :         memset( ModuleInfo.pCodeBuff, 0, buffer_size );
; 1538 : #endif
; 1539 :     for( curr = SymTables[TAB_SEG].head, p = ModuleInfo.pCodeBuff; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	mov	rax, QWORD PTR ModuleInfo+448
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN7@SegmentIni
$LN5@SegmentIni:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN7@SegmentIni:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN6@SegmentIni

; 1540 :         curr->e.seginfo->current_loc = 0;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	DWORD PTR [rax+12], 0

; 1541 :         if ( curr->e.seginfo->internal )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+107]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@SegmentIni

; 1542 :             continue;

	jmp	SHORT $LN5@SegmentIni
$LN14@SegmentIni:

; 1543 :         if ( curr->e.seginfo->bytes_written ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+24], 0
	je	$LN15@SegmentIni

; 1544 :             if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN16@SegmentIni

; 1545 :                 curr->e.seginfo->CodeBuffer = codebuf;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	lea	rcx, OFFSET FLAT:codebuf
	mov	QWORD PTR [rax+16], rcx

; 1546 :                 DebugMsg(("SegmentInit(%u), %s: buffer=%p\n", pass, curr->sym.name, codebuf ));

	lea	r9, OFFSET FLAT:codebuf
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR pass$[rsp]
	lea	rcx, OFFSET FLAT:$SG11955
	call	DoDebugMsg

; 1547 :             } else {

	jmp	SHORT $LN17@SegmentIni
$LN16@SegmentIni:

; 1548 :                 curr->e.seginfo->CodeBuffer = p;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 1549 :                 i = curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR [rcx+64]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$[rsp], eax

; 1550 :                 DebugMsg(("SegmentInit(%u), %s: size=%" I32_SPEC "X buffer=%p\n", pass, curr->sym.name, i, p ));

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR pass$[rsp]
	lea	rcx, OFFSET FLAT:$SG11956
	call	DoDebugMsg

; 1551 :                 p += i;

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax
$LN17@SegmentIni:
$LN15@SegmentIni:

; 1552 :             }
; 1553 :         }
; 1554 :         if( curr->e.seginfo->combine != COMB_STACK ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+108]
	and	al, 7
	movzx	eax, al
	cmp	eax, 5
	je	SHORT $LN18@SegmentIni

; 1555 :             curr->sym.max_offset = 0;

	mov	rax, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rax+64], 0
$LN18@SegmentIni:

; 1556 :         }
; 1557 :         if ( Options.output_format == OFORMAT_OMF ) { /* v2.03: do this selectively */

	cmp	DWORD PTR Options+160, 1
	jne	SHORT $LN19@SegmentIni

; 1558 :             curr->e.seginfo->start_loc = 0;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	DWORD PTR [rax+8], 0

; 1559 :             curr->e.seginfo->data_in_code = FALSE;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+107]
	and	al, 247					; 000000f7H
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	BYTE PTR [rcx+107], al
$LN19@SegmentIni:

; 1560 :         }
; 1561 :         curr->e.seginfo->bytes_written = 0;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	DWORD PTR [rax+24], 0

; 1562 : 
; 1563 :         //if ( Options.output_format != OFORMAT_OMF ) {
; 1564 :         curr->e.seginfo->FixupList.head = NULL;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR [rax+40], 0

; 1565 :         curr->e.seginfo->FixupList.tail = NULL;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR [rax+48], 0

; 1566 :         //}
; 1567 :     }

	jmp	$LN5@SegmentIni
$LN6@SegmentIni:

; 1568 : 
; 1569 :     ModuleInfo.Ofssize = USE16;

	mov	BYTE PTR ModuleInfo+404, 0

; 1570 : 
; 1571 : #if FASTPASS
; 1572 :     if ( pass != PASS_1 && UseSavedState == TRUE ) {

	cmp	DWORD PTR pass$[rsp], 0
	je	SHORT $LN20@SegmentIni
	movzx	eax, BYTE PTR UseSavedState
	cmp	eax, 1
	jne	SHORT $LN20@SegmentIni

; 1573 :         CurrSeg = saved_CurrSeg;

	mov	rax, QWORD PTR saved_CurrSeg
	mov	QWORD PTR ModuleInfo+432, rax

; 1574 :         stkindex = saved_stkindex;

	mov	eax, DWORD PTR saved_stkindex
	mov	DWORD PTR stkindex, eax

; 1575 :         if ( stkindex )

	cmp	DWORD PTR stkindex, 0
	je	SHORT $LN21@SegmentIni

; 1576 :             memcpy( &SegStack, saved_SegStack, stkindex * sizeof(struct dsym *) );

	movsxd	rax, DWORD PTR stkindex
	shl	rax, 3
	mov	r8, rax
	mov	rdx, QWORD PTR saved_SegStack
	lea	rcx, OFFSET FLAT:SegStack
	call	memcpy
$LN21@SegmentIni:

; 1577 : 
; 1578 :         //symCurSeg->string_ptr = saved_CurSeg_name;
; 1579 : 
; 1580 :         UpdateCurrSegVars();

	call	UpdateCurrSegVars
$LN20@SegmentIni:

; 1581 :     }
; 1582 : #endif
; 1583 : }

	add	rsp, 88					; 00000058H
	ret	0
SegmentInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
sym$ = 8
GetSegIdx PROC

; 587  : {

	mov	QWORD PTR [rsp+8], rcx

; 588  :     if( sym )

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN2@GetSegIdx

; 589  :         return( ((struct dsym *)sym)->e.seginfo->seg_idx );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+68]
	jmp	SHORT $LN1@GetSegIdx
$LN2@GetSegIdx:

; 590  :     return( 0 );

	xor	eax, eax
$LN1@GetSegIdx:

; 591  : }

	ret	0
GetSegIdx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
seg$ = 32
name$ = 64
classname$ = 72
alignment$ = 80
Ofssize$ = 88
add_global$ = 96
CreateIntSegment PROC

; 812  : {

$LN11:
	mov	BYTE PTR [rsp+32], r9b
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 813  :     struct dsym *seg;
; 814  :     if ( add_global ) {

	movzx	eax, BYTE PTR add_global$[rsp]
	test	eax, eax
	je	SHORT $LN2@CreateIntS

; 815  :         seg = (struct dsym *)SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR seg$[rsp], rax

; 816  :         if ( seg == NULL || seg->sym.state == SYM_UNDEFINED )

	cmp	QWORD PTR seg$[rsp], 0
	je	SHORT $LN6@CreateIntS
	mov	rax, QWORD PTR seg$[rsp]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN4@CreateIntS
$LN6@CreateIntS:

; 817  :             seg = CreateSegment( seg, name, add_global );

	movzx	r8d, BYTE PTR add_global$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR seg$[rsp]
	call	CreateSegment
	mov	QWORD PTR seg$[rsp], rax
	jmp	SHORT $LN5@CreateIntS
$LN4@CreateIntS:

; 818  :         else if ( seg->sym.state != SYM_SEG ) {

	mov	rax, QWORD PTR seg$[rsp]
	cmp	DWORD PTR [rax+40], 3
	je	SHORT $LN7@CreateIntS

; 819  :             EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 820  :             return( NULL );

	xor	eax, eax
	jmp	$LN1@CreateIntS
$LN7@CreateIntS:
$LN5@CreateIntS:

; 821  :         }
; 822  :     } else

	jmp	SHORT $LN3@CreateIntS
$LN2@CreateIntS:

; 823  :         seg = CreateSegment( NULL, name, FALSE );

	xor	r8d, r8d
	mov	rdx, QWORD PTR name$[rsp]
	xor	ecx, ecx
	call	CreateSegment
	mov	QWORD PTR seg$[rsp], rax
$LN3@CreateIntS:

; 824  :     if ( seg ) {

	cmp	QWORD PTR seg$[rsp], 0
	je	$LN8@CreateIntS

; 825  :         /* v2.12: check 'isdefined' instead of 'lname_idx' */
; 826  :         //if( seg->e.seginfo->lname_idx == 0 ) {
; 827  :         if( seg->sym.isdefined == FALSE ) {

	mov	rax, QWORD PTR seg$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN9@CreateIntS

; 828  :             seg->e.seginfo->seg_idx = ++ModuleInfo.g.num_segs;

	mov	eax, DWORD PTR ModuleInfo+8
	inc	eax
	mov	DWORD PTR ModuleInfo+8, eax
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	ecx, DWORD PTR ModuleInfo+8
	mov	DWORD PTR [rax+68], ecx

; 829  :             /* seg->e.seginfo->lname_idx = */ AddLnameItem( &seg->sym );

	mov	rax, QWORD PTR seg$[rsp]
	mov	rcx, rax
	call	AddLnameItem

; 830  :             seg->sym.isdefined = TRUE; /* v2.12: added */

	mov	rax, QWORD PTR seg$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	or	al, 2
	mov	rcx, QWORD PTR seg$[rsp]
	mov	BYTE PTR [rcx+48], al
$LN9@CreateIntS:

; 831  :         }
; 832  :         seg->e.seginfo->internal = TRUE; /* segment has private buffer */

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 16
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	BYTE PTR [rcx+107], al

; 833  :         seg->sym.segment = &seg->sym;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	QWORD PTR [rcx+32], rax

; 834  :         seg->e.seginfo->alignment = alignment;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	ecx, BYTE PTR alignment$[rsp]
	mov	BYTE PTR [rax+106], cl

; 835  :         seg->e.seginfo->Ofssize = Ofssize;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	ecx, BYTE PTR Ofssize$[rsp]
	mov	BYTE PTR [rax+104], cl

; 836  :         SetSegmentClass( seg, classname );

	mov	rdx, QWORD PTR classname$[rsp]
	mov	rcx, QWORD PTR seg$[rsp]
	call	SetSegmentClass

; 837  :         return( &seg->sym );

	mov	rax, QWORD PTR seg$[rsp]
	jmp	SHORT $LN1@CreateIntS
$LN8@CreateIntS:

; 838  :     }
; 839  :     return( NULL );

	xor	eax, eax
$LN1@CreateIntS:

; 840  : }

	add	rsp, 56					; 00000038H
	ret	0
CreateIntSegment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
tv67 = 0
GetCurrOffset PROC

; 281  : {

$LN5:
	sub	rsp, 24

; 282  :     return( CurrSeg ? CurrSeg->e.seginfo->current_loc : 0 );

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN3@GetCurrOff
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR tv67[rsp], eax
	jmp	SHORT $LN4@GetCurrOff
$LN3@GetCurrOff:
	mov	DWORD PTR tv67[rsp], 0
$LN4@GetCurrOff:
	mov	eax, DWORD PTR tv67[rsp]

; 283  : }

	add	rsp, 24
	ret	0
GetCurrOffset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
curr$ = 0
sym$ = 32
GetSymOfssize PROC

; 608  : {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 609  :     struct dsym   *curr;
; 610  : 
; 611  :     /* v2.07: MT_ABS has been removed */
; 612  :     //if ( sym->mem_type == MT_ABS )
; 613  :     //    return( USE16 );
; 614  : 
; 615  :     curr = GetSegm( sym );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR curr$[rsp], rax

; 616  :     if( curr == NULL ) {

	cmp	QWORD PTR curr$[rsp], 0
	jne	SHORT $LN2@GetSymOfss

; 617  :         /* v2.04: SYM_STACK added */
; 618  :         //if( sym->state == SYM_EXTERNAL || ( sym->state == SYM_INTERNAL && sym->isproc ) || sym->state == SYM_GRP )
; 619  :         if( sym->state == SYM_EXTERNAL )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 2
	jne	SHORT $LN4@GetSymOfss

; 620  :             return( sym->seg_ofssize );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	and	al, 3
	movzx	eax, al
	jmp	SHORT $LN1@GetSymOfss
$LN4@GetSymOfss:

; 621  :         if( sym->state == SYM_STACK || sym->state == SYM_GRP )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 5
	je	SHORT $LN6@GetSymOfss
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 4
	jne	SHORT $LN5@GetSymOfss
$LN6@GetSymOfss:

; 622  :             return( sym->Ofssize );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+52]
	jmp	SHORT $LN1@GetSymOfss
$LN5@GetSymOfss:

; 623  :         if( sym->state == SYM_SEG  )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 3
	jne	SHORT $LN7@GetSymOfss

; 624  :             return( ((struct dsym *)sym)->e.seginfo->Ofssize );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+104]
	jmp	SHORT $LN1@GetSymOfss
$LN7@GetSymOfss:

; 625  :         /* v2.07: added */
; 626  :         if ( sym->mem_type == MT_EMPTY )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+44], 192			; 000000c0H
	jne	SHORT $LN8@GetSymOfss

; 627  :             return( USE16 );

	xor	eax, eax
	jmp	SHORT $LN1@GetSymOfss
$LN8@GetSymOfss:

; 628  :     } else {

	jmp	SHORT $LN3@GetSymOfss
$LN2@GetSymOfss:

; 629  :         return( curr->e.seginfo->Ofssize );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+104]
	jmp	SHORT $LN1@GetSymOfss
$LN3@GetSymOfss:

; 630  :     }
; 631  :     return( ModuleInfo.Ofssize );

	movzx	eax, BYTE PTR ModuleInfo+404
$LN1@GetSymOfss:

; 632  : }

	add	rsp, 24
	ret	0
GetSymOfssize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
_TEXT	SEGMENT
sym$ = 48
SetSymSegOfs PROC

; 636  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 637  :     sym->segment = &CurrSeg->sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+32], rax

; 638  :     sym->offset = GetCurrOffset();

	call	GetCurrOffset
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 639  : }

	add	rsp, 40					; 00000028H
	ret	0
SetSymSegOfs ENDP
_TEXT	ENDS
END
