; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG12353 DB	01H DUP (?)
	ALIGN	4

$SG11689 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

$SG11877 DB	01H DUP (?)
	ALIGN	4

$SG11898 DB	01H DUP (?)
	ALIGN	4

$SG11899 DB	01H DUP (?)
	ALIGN	4

$SG11911 DB	01H DUP (?)
	ALIGN	4

$SG11912 DB	01H DUP (?)
	ALIGN	4

evallvl	DD	01H DUP (?)
$SG11176 DB	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
unaryop	DQ	FLAT:low_op
	DQ	FLAT:high_op
	DQ	FLAT:lowword_op
	DQ	FLAT:highword_op
	DQ	FLAT:low32_op
	DQ	FLAT:high32_op
	DQ	FLAT:offset_op
	DQ	FLAT:offset_op
	DQ	FLAT:offset_op
	DQ	FLAT:offset_op
	DQ	FLAT:seg_op
	DQ	FLAT:opattr_op
	DQ	FLAT:opattr_op
	DQ	FLAT:sizlen_op
	DQ	FLAT:sizlen_op
	DQ	FLAT:sizlen_op
	DQ	FLAT:sizlen_op
	DQ	FLAT:short_op
	DQ	FLAT:this_op
	DQ	FLAT:type_op
	DQ	FLAT:wimask_op
	DQ	FLAT:wimask_op
CONST	ENDS
_DATA	SEGMENT
$SG12307 DB	'NULL', 00H
	ORG $+11
$SG12308 DB	'%u evaluate(i=%d, end=%d, flags=%X) enter [opnd1: kind=%'
	DB	'd type=%s]', 0aH, 00H
$SG12310 DB	'NULL', 00H
	ORG $+3
$SG11090 DB	'rn-sae', 00H
	ORG $+1
$SG11106 DB	'sae', 00H
$SG12311 DB	'%u evaluate loop, operator=>%s< opnd1->sym=%X, type=%s', 0aH
	DB	00H
$SG12319 DB	'%u evaluate: unexpected token at idx=%u, token=%X >%s<', 0aH
	DB	00H
$SG12329 DB	'%u evaluate: error, missing ''%c'', i=%u', 0aH, 00H
$SG12341 DB	'%u evaluate: unexpected token at %u, token=%X >%s<', 0aH
	DB	00H
$SG12349 DB	'NULL', 00H
	ORG $+3
$SG12350 DB	'NULL', 00H
	ORG $+3
$SG12352 DB	'NULL', 00H
	ORG $+7
$SG12351 DB	'%u evaluate exit, rc=%d, kind=%d value=%I64d(0x%I64X) me'
	DB	'mtype=%Xh string=%s indirect=%u type=>%s<', 0aH, 00H
	ORG $+1
$SG12354 DB	'NULL', 00H
	ORG $+7
$SG12355 DB	'%u evaluate exit, rc=%d, kind=%d value=%d(0x%X) memtype='
	DB	'%Xh string=%s ind=%u exp=%u ofssiz=%d instr=%s type=>%s<', 0aH
	DB	00H
	ORG $+2
$SG11364 DB	'NULL', 00H
	ORG $+3
$SG11094 DB	'rd-sae', 00H
	ORG $+1
$SG11182 DB	'@@', 00H
	ORG $+1
$SG11365 DB	'sizlen_op(%s): sym=%X, mbr=%X, type=>%s<', 0aH, 00H
	ORG $+2
$SG11098 DB	'ru-sae', 00H
	ORG $+5
$SG12392 DB	'EvalOperand(start=%u, end=%u, flags=%X) enter: >%s<', 0aH
	DB	00H
	ORG $+3
$SG11400 DB	'NULL', 00H
	ORG $+3
$SG11401 DB	'sizlen_op(SIZE): result=%u [symbol %s, first_size=%u]', 0aH
	DB	00H
	ORG $+1
$SG11405 DB	'sizlen_op(sizeof): symbol %s, state=%u, size=%u', 0aH, 00H
	ORG $+7
$SG11408 DB	'sizlen_op(sizeof): symbol %s (TYPE), opnd2.value=%u', 0aH
	DB	00H
	ORG $+3
$SG11409 DB	'sizlen_op(sizeof): symbol NULL, opnd2.value=%u', 0aH, 00H
$SG11434 DB	'NULL', 00H
	ORG $+3
$SG11435 DB	'NULL', 00H
	ORG $+3
$SG11454 DB	'type_op: assume type=%X [name=>%s< memtype=%X]', 0aH, 00H
$SG11475 DB	'NULL', 00H
	ORG $+3
$SG11436 DB	'type_op: opnd2 kind=%d memtype=%X sym=%s type=%s instr=%'
	DB	'd istype=%u explicit=%u', 0aH, 00H
	ORG $+7
$SG11476 DB	'type_op: result value=%u is_type=%u type=%s', 0aH, 00H
	ORG $+3
$SG11504 DB	'NULL', 00H
	ORG $+3
$SG11505 DB	'opattr_op: arg kind=%d memtype=%X sym=%s', 0aH, 00H
	ORG $+6
$SG11535 DB	'opattr_op returns %Xh', 0aH, 00H
	ORG $+1
$SG11690 DB	'NULL', 00H
	ORG $+3
$SG11691 DB	'this_op: memtype=%Xh type=%s', 0aH, 00H
	ORG $+2
$SG11744 DB	'NULL', 00H
	ORG $+3
$SG11745 DB	'NULL', 00H
	ORG $+3
$SG11746 DB	'NULL', 00H
	ORG $+3
$SG11747 DB	'NULL', 00H
	ORG $+3
$SG11748 DB	'NULL', 00H
	ORG $+3
$SG11749 DB	'NULL', 00H
	ORG $+3
$SG11750 DB	'plus_op: kind=%d/%d memtype=%Xh-%Xh value=%d-%d sym=%s-%'
	DB	's mbr=%s-%s type=%s-%s', 0aH, 00H
$SG11752 DB	'plus_op: error direct register', 0aH, 00H
$SG11758 DB	'plus_op: multiple overrides', 0aH, 00H
	ORG $+3
$SG11761 DB	'plus_op: CONST - CONST', 0aH, 00H
$SG11764 DB	'plus_op: ADDR - ADDR', 0aH, 00H
	ORG $+2
$SG11768 DB	'plus_op: two relocatable labels: %s - %s ', 0aH, 00H
	ORG $+5
$SG11776 DB	'plus_op: CONST - ADDR', 0aH, 00H
	ORG $+1
$SG11782 DB	'plus_op: ADDR - CONST', 0aH, 00H
	ORG $+1
$SG11786 DB	'plus_op: error, unexpected format: %u - %u', 0aH, 00H
	ORG $+4
$SG11800 DB	'minus_op: kind tok1=%u, tok2=%u', 0aH, 00H
	ORG $+7
$SG11802 DB	'minus_op: error direct register', 0aH, 00H
	ORG $+7
$SG11807 DB	'minus_op: CONST-CONST', 0aH, 00H
	ORG $+1
$SG11810 DB	'minus_op: ADDR-CONST', 0aH, 00H
	ORG $+2
$SG11813 DB	'minus_op: ADDR-ADDR', 0aH, 00H
	ORG $+3
$SG11815 DB	'minus_op error, opnd2->indirect==TRUE', 0aH, 00H
	ORG $+1
$SG11820 DB	'minus_op error, label_tok=%X opnd1.sym=%X opnd2.sym=%X', 0aH
	DB	00H
$SG11824 DB	'minus_op error 6', 0aH, 00H
	ORG $+6
$SG11826 DB	'minus_op error, sym.segm=%X opnd1->sym.segm=%X', 0aH, 00H
$SG11834 DB	'minus_op, exit, ADDR, base=%X, idx=%X', 0aH, 00H
	ORG $+1
$SG11837 DB	'minus_op, exit, error: kinds tok1=%u, tok2=%u', 0aH, 00H
	ORG $+1
$SG11863 DB	'NULL', 00H
	ORG $+3
$SG11864 DB	'NULL', 00H
	ORG $+3
$SG11865 DB	'NULL', 00H
	ORG $+3
$SG11866 DB	'NULL', 00H
	ORG $+3
$SG11867 DB	'NULL', 00H
	ORG $+3
$SG11868 DB	'NULL', 00H
	ORG $+3
$SG11869 DB	'dot_op: op1-op2 kind=%d/%d sym=%s-%s type=%s-%s mbr=%s-%'
	DB	's', 0aH, 00H
	ORG $+5
$SG11871 DB	'dot_op: error direct register', 0aH, 00H
	ORG $+1
$SG11875 DB	'dot_op: forward reference %s, replaced by null struct ty'
	DB	'pe', 0aH, 00H
$SG11880 DB	'NULL', 00H
	ORG $+3
$SG11881 DB	'NULL', 00H
	ORG $+7
$SG11882 DB	'dot_op, ADDR - ADDR, t1-t2 memtype=%X-%X sym=%s-%s', 0aH
	DB	00H
	ORG $+4
$SG11884 DB	'dot_op: error, mbr 2 is NULL', 0aH, 00H
	ORG $+2
$SG11888 DB	'dot_op: error, two relocatable labels: %s - %s ', 0aH, 00H
	ORG $+7
$SG11894 DB	'dot_op, CONST - ADDR: t1-t2 memtype=%Xh-%Xh istype=%u-%u'
	DB	0aH, 00H
	ORG $+6
$SG11900 DB	'dot_op, CONST - ADDR, t1.type=%X (%s), t2.type=%X (%s)', 0aH
	DB	00H
$SG11904 DB	'dot_op, ADDR - CONST: t1-t2 memtype=%Xh-%Xh t1.explicit='
	DB	'%u', 0aH, 00H
	ORG $+4
$SG11907 DB	'dot_op: error, constant or simple type after dot', 0aH, 00H
	ORG $+6
$SG11913 DB	'dot_op, ADDR - CONST, t1.type=%X (%s), t2.type=%X (%s)', 0aH
	DB	00H
$SG11916 DB	'dot_op, CONST - CONST, t1-t2 value=%u-%u, memtype=%Xh-%X'
	DB	'h istype=%u-%u', 0aH, 00H
$SG11918 DB	'dot_op: error, opnd2.mbr=NULL', 0aH, 00H
	ORG $+1
$SG11941 DB	'NULL', 00H
	ORG $+3
$SG11925 DB	'dot_op: error, unknown kind combination, opnd1->kind=%d,'
	DB	' opnd2->kind=%d', 0aH, 00H
	ORG $+3
$SG11942 DB	'NULL', 00H
	ORG $+7
$SG11943 DB	'colon_op: t1-t2 kind=%d/%d type=%s-%s is_type=%u-%u', 0aH
	DB	00H
	ORG $+3
$SG11948 DB	'colon_op: multiple override=%s', 0aH, 00H
$SG11951 DB	'colon_op: register after : not enclosed in []', 0aH, 00H
	ORG $+1
$SG11956 DB	'colon_op: register before '':'' has idx_reg set!?', 0aH, 00H
	ORG $+7
$SG11969 DB	'colon_op error 4', 0aH, 00H
	ORG $+6
$SG11970 DB	'colon_op error 5', 0aH, 00H
	ORG $+6
$SG11977 DB	'positive_op: value=%I64X high=%I64X', 0aH, 00H
	ORG $+3
$SG11982 DB	'positive_op: error 1', 0aH, 00H
	ORG $+2
$SG11989 DB	'negative_op: value=%I64X high=%I64X', 0aH, 00H
	ORG $+3
$SG11995 DB	'negative_op: unexpected opnd2.kind=%d', 0aH, 00H
	ORG $+1
$SG12005 DB	'CheckAssume(%s, MT_PTR type=>%s< )', 0aH, 00H
	ORG $+4
$SG10985 DB	'get_precedence: unexpected operator=%s', 0aH, 00H
$SG12010 DB	'NULL', 00H
	ORG $+3
$SG12011 DB	'NULL', 00H
	ORG $+3
$SG12012 DB	'NULL', 00H
	ORG $+3
$SG12013 DB	'NULL', 00H
	ORG $+3
$SG12045 DB	'cmp_types: memtype=%X-%X type=%X-%X', 0aH, 00H
	ORG $+3
$SG12014 DB	'CheckAssume(%s, type=>%s<, mbr=>%s<): assume=%s [memtype'
	DB	'=%X isptr=%u type=%s target_type=%s ptr_memt=%X]', 0aH, 00H
	ORG $+6
$SG12043 DB	'expreval.c', 00H
	ORG $+5
$SG12044 DB	'cmp_types: MT_PTR-MT_PTR is_ptr=%u-%u ptr_memtype=%X-%X '
	DB	'target_type=%X-%X', 0aH, 00H
	ORG $+5
$SG12082 DB	'%u calculate(%s): value too large', 0aH, 00H
	ORG $+5
$SG12087 DB	'%u calculate(%s): single item', 0aH, 00H
	ORG $+1
$SG12091 DB	'calculate(%s): incompatible usage of (simple) type', 0aH
	DB	00H
	ORG $+4
$SG12096 DB	'%u calculate(%s): single item', 0aH, 00H
	ORG $+1
$SG12098 DB	'calculate(%s): incompatible usage of (simple) type', 0aH
	DB	00H
	ORG $+4
$SG12100 DB	'calculate(%s): calling plus_op()', 0aH, 00H
	ORG $+6
$SG11082 DB	'%u get_operand(idx=%u >%s<) enter [memtype=%Xh]', 0aH, 00H
	ORG $+7
$SG11084 DB	'%u get_operand: T_NUM, %s, base=%u, len=%u', 0aH, 00H
	ORG $+4
$SG11086 DB	'%u get_operand: T_STRING, %s, size=%u', 0aH, 00H
	ORG $+1
$SG12113 DB	'calculate(*): kind=%d/%d value=%I64d-%I64d mbr=%X-%X', 0aH
	DB	00H
	ORG $+2
$SG12119 DB	'calculate(*) error direct register', 0aH, 00H
	ORG $+4
$SG12123 DB	'calculate(*) error 2', 0aH, 00H
	ORG $+2
$SG12125 DB	'calculate(/): t1-t2 kind %u-%u values %I64d-%I64d', 0aH, 00H
	ORG $+1
$SG11102 DB	'rz-sae', 00H
	ORG $+5
$SG12127 DB	'calculate(/) error 1', 0aH, 00H
	ORG $+2
$SG12129 DB	'calculate(/) error 2', 0aH, 00H
	ORG $+2
$SG12131 DB	'NULL', 00H
	ORG $+3
$SG12132 DB	'NULL', 00H
	ORG $+3
$SG12133 DB	'NULL', 00H
	ORG $+3
$SG12134 DB	'NULL', 00H
	ORG $+3
$SG11113 DB	'%u get_operand: T_REG, string=%s, tokval=%u, regno=%u', 0aH
	DB	00H
	ORG $+1
$SG12135 DB	'calculate(%s [T_BINARY_OPERATOR] ): t1-t2 kind %d/%d mem'
	DB	'type %X-%X sym %s-%s type %s-%s', 0aH, 00H
	ORG $+7
$SG12140 DB	'calculate(PTR), error 1: t1 is_type == FALSE', 0aH, 00H
	ORG $+2
$SG12147 DB	'calculate(PTR): segment register size (=2/4) doesn''t ma'
	DB	'tch type size (=%u)', 0aH, 00H
	ORG $+4
$SG12149 DB	'calculate(PTR): register size doesn''t match type size; '
	DB	'%u != %u', 0aH, 00H
	ORG $+3
$SG11131 DB	'NULL', 00H
	ORG $+7
$SG12152 DB	'calculate(PTR): type memtype=%Xh ( MT_FLOAT not set, alt'
	DB	'hough right op is FLOAT )', 0aH, 00H
	ORG $+5
$SG11132 DB	'%u get_operand: T_ID, is_dot=1, id=%s, opnd.type=%s', 0aH
	DB	00H
	ORG $+3
$SG11133 DB	'NULL', 00H
	ORG $+3
$SG11134 DB	'get_operand(%s): is_dot, sym=%s, offset=%Xh', 0aH, 00H
	ORG $+3
$SG12165 DB	'calculate(%s) error 1', 0aH, 00H
	ORG $+1
$SG12166 DB	'NULL', 00H
	ORG $+3
$SG12167 DB	'calculate(%s) error 2, token2.kind=%d indirect=%u sym=%s'
	DB	0aH, 00H
	ORG $+6
$SG12168 DB	'calculate(%s) error 3', 0aH, 00H
	ORG $+1
$SG12169 DB	'calculate(%s) error 4', 0aH, 00H
	ORG $+1
$SG11161 DB	'get_operand(%s): symbol is macro/textmacro/alias!', 0aH, 00H
	ORG $+5
$SG12170 DB	'calculate(%s): values=%I64d/%I64d is_type=%u/%u memtypes'
	DB	'=%X/%X', 0aH, 00H
$SG11146 DB	'%u get_operand: T_ID, id=%s', 0aH, 00H
	ORG $+3
$SG11158 DB	'get_operand(%s): OPATTR, symbol invalid', 0aH, 00H
	ORG $+7
$SG12185 DB	'calculate(SHL): value=%I64X << %u (max=%u)', 0aH, 00H
$SG11167 DB	'NULL', 00H
	ORG $+7
$SG11168 DB	'get_operand(%s): symbol not (yet) defined, CurrProc=%s', 0aH
	DB	00H
$SG11171 DB	'NULL', 00H
	ORG $+3
$SG11172 DB	'get_operand(%s): symbol error (type=%s typekind=%u)', 0aH
	DB	00H
	ORG $+3
$SG12200 DB	'NULL', 00H
	ORG $+3
$SG12201 DB	'NULL', 00H
	ORG $+3
$SG11177 DB	'get_operand(%s): forward reference to a struct (using nu'
	DB	'llmbr)', 0aH, 00H
$SG12202 DB	'NULL', 00H
	ORG $+3
$SG11178 DB	'NULL', 00H
	ORG $+3
$SG12203 DB	'calculate(%s [T_UNARY_OPERATOR]): opnd2 kind=%d sym=%s m'
	DB	'br=%s type=%s memtype=%X is_type=%u indirect=%u', 0aH, 00H
	ORG $+7
$SG11179 DB	'get_operand(%s): symbol %s not defined, pass > 1, curr p'
	DB	'roc=>%s<, ', 0aH, 00H
	ORG $+4
$SG12206 DB	'calculate(%s) error 1', 0aH, 00H
	ORG $+1
$SG11184 DB	'NULL', 00H
	ORG $+3
$SG11188 DB	'get_operand(%s): struct/union definition isn''t closed!', 0aH
	DB	00H
$SG11185 DB	'get_operand(%s): sym->state=%u type=>%s< ofs=%X memtype='
	DB	'%Xh total_size=%u defined=%u', 0aH, 00H
	ORG $+2
$SG11198 DB	'NULL', 00H
	ORG $+3
$SG11189 DB	'get_operand(%s): symbol.typekind=%u (STRUCT/UNION/TYPEDE'
	DB	'F/RECORD)', 0aH, 00H
	ORG $+5
$SG11197 DB	'get_operand(%s): structure field, ofs=%Xh', 0aH, 00H
	ORG $+5
$SG11199 DB	'get_operand: mem_type=%Xh type=%s', 0aH, 00H
	ORG $+5
$SG11204 DB	'get_operand(%s): equate hval=%Xh, lval=%Xh', 0aH, 00H
	ORG $+4
$SG12234 DB	'calculate %s ''float'' error', 0aH, 00H
	ORG $+4
$SG11212 DB	'%u get_operand: T_STYPE (>%s<, value=%X)', 0aH, 00H
	ORG $+6
$SG12237 DB	'calculate(%s): unknown operator', 0aH, 00H
	ORG $+7
$SG11214 DB	'%u get_operand: T_RES_ID (>%s<, value=%X)', 0aH, 00H
	ORG $+1
$SG12240 DB	'NULL', 00H
	ORG $+7
$SG12241 DB	'%u calculate(%s) exit, ok kind=%d value=0x%I64X_%016I64X'
	DB	' memtype=0x%X indirect=%u type=>%s<', 0aH, 00H
	ORG $+3
$SG12244 DB	'NULL', 00H
	ORG $+3
$SG11221 DB	'%u get_operand: T_FLOAT (>%s<)', 0aH, 00H
$SG12246 DB	'NULL', 00H
	ORG $+3
$SG12245 DB	'%u calculate(%s) exit, ok kind=%d value=%I64d(0x%I64X) m'
	DB	'emtype=0x%X indirect=%u type=>%s<', 0aH, 00H
	ORG $+1
$SG12247 DB	'NULL', 00H
	ORG $+7
$SG11223 DB	'%u get_operand: default (token=%u, string=%s)', 0aH, 00H
	ORG $+1
$SG11233 DB	'NULL', 00H
	ORG $+3
$SG12248 DB	'%u calculate(%s) exit, ok kind=%d value=%d(0x%X) memtype'
	DB	'=0x%X ind=%u exp=%u type=%s mbr=%s', 0aH, 00H
$SG11234 DB	'NULL', 00H
	ORG $+3
$SG11235 DB	'NULL', 00H
	ORG $+3
$SG11236 DB	'NULL', 00H
	ORG $+3
$SG12263 DB	'NULL', 00H
	ORG $+7
$SG11237 DB	'%u get_operand exit, ok, kind=%d value=%I64X hvalue=%I64'
	DB	'X mem_type=%Xh abs=%u string=%s is_type=%u type=>%s< sym=%s m'
	DB	'br=%s', 0aH, 00H
	ORG $+4
$SG12264 DB	'PrepareOp: DOT operator found, old.sym=%X, old.type=%s, '
	DB	'expr=%s', 0aH, 00H
	ORG $+7
$SG12267 DB	'PrepareOp: implicit type: %s', 0aH, 00H
	ORG $+2
$SG12269 DB	'PrepareOp: forward ref to %s, type will be NULL', 0aH, 00H
	ORG $+3
$SG12272 DB	'NULL', 00H
	ORG $+15
$SG12273 DB	'PrepareOp: OPATTR operator found, old.sym=%X, old.type=%'
	DB	's, expr=%s', 0aH, 00H
_DATA	ENDS
PUBLIC	EvalOperand
PUBLIC	ExprEvalInit
PUBLIC	EmitConstError
PUBLIC	myatoi128
EXTRN	__imp_isalpha:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	strlen:PROC
EXTRN	__imp__strupr:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	SymAlloc:PROC
EXTRN	SymLookup:PROC
EXTRN	SymFind:PROC
EXTRN	SizeFromMemtype:PROC
EXTRN	MemtypeFromSize:PROC
EXTRN	SizeFromRegister:PROC
EXTRN	sym_add_table:PROC
EXTRN	GetResWName:PROC
EXTRN	SetSymSegOfs:PROC
EXTRN	GetSymOfssize:PROC
EXTRN	DefineFlatGroup:PROC
EXTRN	GetStdAssumeEx:PROC
EXTRN	CreateTypeSymbol:PROC
EXTRN	SearchNameInStruct:PROC
EXTRN	GetAnonymousLabel:PROC
EXTRN	atofloat:PROC
EXTRN	InternalError:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SymTables:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	CurrProc:QWORD
EXTRN	CurrStruct:QWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
	ALIGN	8

thissym	DQ	01H DUP (?)
nullstruct DQ	01H DUP (?)
nullmbr	DQ	01H DUP (?)
fnEmitErr DQ	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$EvalOperand DD imagerel $LN9
	DD	imagerel $LN9+291
	DD	imagerel $unwind$EvalOperand
$pdata$ExprEvalInit DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$ExprEvalInit
$pdata$EmitConstError DD imagerel $LN5
	DD	imagerel $LN5+100
	DD	imagerel $unwind$EmitConstError
$pdata$noEmitErr DD imagerel noEmitErr
	DD	imagerel noEmitErr+27
	DD	imagerel $unwind$noEmitErr
$pdata$init_expr DD imagerel init_expr
	DD	imagerel init_expr+211
	DD	imagerel $unwind$init_expr
$pdata$TokenAssign DD imagerel TokenAssign
	DD	imagerel TokenAssign+62
	DD	imagerel $unwind$TokenAssign
$pdata$get_precedence DD imagerel get_precedence
	DD	imagerel get_precedence+376
	DD	imagerel $unwind$get_precedence
$pdata$GetTypeSize DD imagerel GetTypeSize
	DD	imagerel GetTypeSize+201
	DD	imagerel $unwind$GetTypeSize
$pdata$GetRecordMask DD imagerel GetRecordMask
	DD	imagerel GetRecordMask+187
	DD	imagerel $unwind$GetRecordMask
$pdata$myatoi128 DD imagerel $LN11
	DD	imagerel $LN11+297
	DD	imagerel $unwind$myatoi128
$pdata$get_operand DD imagerel get_operand
	DD	imagerel get_operand+7340
	DD	imagerel $unwind$get_operand
$pdata$check_both DD imagerel check_both
	DD	imagerel check_both+89
	DD	imagerel $unwind$check_both
$pdata$index_connect DD imagerel index_connect
	DD	imagerel index_connect+304
	DD	imagerel $unwind$index_connect
$pdata$MakeConst DD imagerel MakeConst
	DD	imagerel MakeConst+279
	DD	imagerel $unwind$MakeConst
$pdata$MakeConst2 DD imagerel MakeConst2
	DD	imagerel MakeConst2+255
	DD	imagerel $unwind$MakeConst2
$pdata$ConstError DD imagerel ConstError
	DD	imagerel ConstError+114
	DD	imagerel $unwind$ConstError
$pdata$fix_struct_value DD imagerel fix_struct_value
	DD	imagerel fix_struct_value+76
	DD	imagerel $unwind$fix_struct_value
$pdata$check_direct_reg DD imagerel check_direct_reg
	DD	imagerel check_direct_reg+74
	DD	imagerel $unwind$check_direct_reg
$pdata$GetSizeValue DD imagerel GetSizeValue
	DD	imagerel GetSizeValue+153
	DD	imagerel $unwind$GetSizeValue
$pdata$IsOffset DD imagerel IsOffset
	DD	imagerel IsOffset+87
	DD	imagerel $unwind$IsOffset
$pdata$invalid_operand DD imagerel invalid_operand
	DD	imagerel invalid_operand+99
	DD	imagerel $unwind$invalid_operand
$pdata$sizlen_op DD imagerel sizlen_op
	DD	imagerel sizlen_op+1446
	DD	imagerel $unwind$sizlen_op
$pdata$type_op DD imagerel type_op
	DD	imagerel type_op+2252
	DD	imagerel $unwind$type_op
$pdata$opattr_op DD imagerel opattr_op
	DD	imagerel opattr_op+1262
	DD	imagerel $unwind$opattr_op
$pdata$short_op DD imagerel short_op
	DD	imagerel short_op+144
	DD	imagerel $unwind$short_op
$pdata$seg_op DD imagerel seg_op
	DD	imagerel seg_op+171
	DD	imagerel $unwind$seg_op
$pdata$offset_op DD imagerel offset_op
	DD	imagerel offset_op+272
	DD	imagerel $unwind$offset_op
$pdata$lowword_op DD imagerel lowword_op
	DD	imagerel lowword_op+137
	DD	imagerel $unwind$lowword_op
$pdata$highword_op DD imagerel highword_op
	DD	imagerel highword_op+137
	DD	imagerel $unwind$highword_op
$pdata$low_op DD imagerel low_op
	DD	imagerel low_op+137
	DD	imagerel $unwind$low_op
$pdata$high_op DD imagerel high_op
	DD	imagerel high_op+154
	DD	imagerel $unwind$high_op
$pdata$low32_op DD imagerel low32_op
	DD	imagerel low32_op+287
	DD	imagerel $unwind$low32_op
$pdata$high32_op DD imagerel high32_op
	DD	imagerel high32_op+283
	DD	imagerel $unwind$high32_op
$pdata$this_op DD imagerel this_op
	DD	imagerel this_op+395
	DD	imagerel $unwind$this_op
$pdata$wimask_op DD imagerel wimask_op
	DD	imagerel wimask_op+438
	DD	imagerel $unwind$wimask_op
$pdata$plus_op DD imagerel plus_op
	DD	imagerel plus_op+1904
	DD	imagerel $unwind$plus_op
$pdata$minus_op DD imagerel minus_op
	DD	imagerel minus_op+1319
	DD	imagerel $unwind$minus_op
$pdata$struct_field_error DD imagerel struct_field_error
	DD	imagerel struct_field_error+81
	DD	imagerel $unwind$struct_field_error
$pdata$dot_op DD imagerel dot_op
	DD	imagerel dot_op+3230
	DD	imagerel $unwind$dot_op
$pdata$colon_op DD imagerel colon_op
	DD	imagerel colon_op+1386
	DD	imagerel $unwind$colon_op
$pdata$positive_op DD imagerel positive_op
	DD	imagerel positive_op+252
	DD	imagerel $unwind$positive_op
$pdata$negative_op DD imagerel negative_op
	DD	imagerel negative_op+345
	DD	imagerel $unwind$negative_op
$pdata$CheckAssume DD imagerel CheckAssume
	DD	imagerel CheckAssume+835
	DD	imagerel $unwind$CheckAssume
$pdata$check_streg DD imagerel check_streg
	DD	imagerel check_streg+126
	DD	imagerel $unwind$check_streg
$pdata$cmp_types DD imagerel cmp_types
	DD	imagerel cmp_types+837
	DD	imagerel $unwind$cmp_types
$pdata$calculate DD imagerel calculate
	DD	imagerel calculate+7288
	DD	imagerel $unwind$calculate
$pdata$PrepareOp DD imagerel PrepareOp
	DD	imagerel PrepareOp+552
	DD	imagerel $unwind$PrepareOp
$pdata$OperErr DD imagerel OperErr
	DD	imagerel OperErr+105
	DD	imagerel $unwind$OperErr
$pdata$evaluate DD imagerel evaluate
	DD	imagerel evaluate+3461
	DD	imagerel $unwind$evaluate
$pdata$is_expr_item DD imagerel is_expr_item
	DD	imagerel is_expr_item+460
	DD	imagerel $unwind$is_expr_item
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
get_operand$rtcName$0 DB 06cH
	DB	061H
	DB	062H
	DB	065H
	DB	06cH
	DB	062H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
	ORG $+6
get_operand$rtcVarDesc DD 088H
	DD	010H
	DQ	FLAT:get_operand$rtcName$0
	ORG $+48
get_operand$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:get_operand$rtcVarDesc
evaluate$rtcName$0 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	032H
	DB	00H
	ORG $+2
evaluate$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:evaluate$rtcVarDesc
	ORG $+8
evaluate$rtcVarDesc DD 0a0H
	DD	068H
	DQ	FLAT:evaluate$rtcName$0
CONST	ENDS
xdata	SEGMENT
$unwind$EvalOperand DD 022d01H
	DD	070157219H
$unwind$ExprEvalInit DD 010201H
	DD	07002H
$unwind$EmitConstError DD 021e01H
	DD	07006320aH
$unwind$noEmitErr DD 011401H
	DD	07014H
$unwind$init_expr DD 010601H
	DD	07006H
$unwind$TokenAssign DD 022301H
	DD	0700b320fH
$unwind$get_precedence DD 021e01H
	DD	07006520aH
$unwind$GetTypeSize DD 022001H
	DD	07009120dH
$unwind$GetRecordMask DD 021e01H
	DD	07006520aH
$unwind$myatoi128 DD 022d01H
	DD	070153219H
$unwind$get_operand DD 034519H
	DD	02c011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0158H
$unwind$check_both DD 011501H
	DD	07015H
$unwind$index_connect DD 022301H
	DD	0700b320fH
$unwind$MakeConst DD 010601H
	DD	07006H
$unwind$MakeConst2 DD 022301H
	DD	0700b320fH
$unwind$ConstError DD 022301H
	DD	0700b320fH
$unwind$fix_struct_value DD 010601H
	DD	07006H
$unwind$check_direct_reg DD 010b01H
	DD	0700bH
$unwind$GetSizeValue DD 021e01H
	DD	07006520aH
$unwind$IsOffset DD 010601H
	DD	07006H
$unwind$invalid_operand DD 022801H
	DD	070103214H
$unwind$sizlen_op DD 022b01H
	DD	07014b218H
$unwind$type_op DD 022e01H
	DD	07014d218H
$unwind$opattr_op DD 022b01H
	DD	070145218H
$unwind$short_op DD 022b01H
	DD	070143218H
$unwind$seg_op DD 022b01H
	DD	070143218H
$unwind$offset_op DD 022b01H
	DD	070143218H
$unwind$lowword_op DD 022b01H
	DD	070143218H
$unwind$highword_op DD 022b01H
	DD	070143218H
$unwind$low_op DD 022b01H
	DD	070143218H
$unwind$high_op DD 022b01H
	DD	070143218H
$unwind$low32_op DD 022b01H
	DD	070147218H
$unwind$high32_op DD 022b01H
	DD	070147218H
$unwind$this_op DD 022b01H
	DD	070145218H
$unwind$wimask_op DD 022b01H
	DD	070147218H
$unwind$plus_op DD 032901H
	DD	0140112H
	DD	0700bH
$unwind$minus_op DD 022301H
	DD	0700b520fH
$unwind$struct_field_error DD 021e01H
	DD	07006320aH
$unwind$dot_op DD 032901H
	DD	0160112H
	DD	0700bH
$unwind$colon_op DD 022601H
	DD	0700bd20fH
$unwind$positive_op DD 022301H
	DD	0700b320fH
$unwind$negative_op DD 022301H
	DD	0700b320fH
$unwind$CheckAssume DD 032401H
	DD	012010dH
	DD	07006H
$unwind$check_streg DD 022301H
	DD	0700b320fH
$unwind$cmp_types DD 022e01H
	DD	07010f217H
$unwind$calculate DD 032e01H
	DD	0240117H
	DD	07010H
$unwind$PrepareOp DD 022801H
	DD	070107214H
$unwind$OperErr DD 022101H
	DD	0700a320eH
$unwind$evaluate DD 033301H
	DD	02e011cH
	DD	07015H
$unwind$is_expr_item DD 021e01H
	DD	07006120aH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
tv66 = 0
tv68 = 4
tv148 = 8
tv88 = 12
item$ = 32
is_expr_item PROC

; 3382 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 3383 :     switch( item->token ) {

	mov	rax, QWORD PTR item$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv66[rsp], al
	cmp	BYTE PTR tv66[rsp], 1
	je	SHORT $LN6@is_expr_it
	cmp	BYTE PTR tv66[rsp], 3
	je	$LN13@is_expr_it
	cmp	BYTE PTR tv66[rsp], 7
	je	$LN11@is_expr_it
	cmp	BYTE PTR tv66[rsp], 44			; 0000002cH
	je	$LN15@is_expr_it
	jmp	$LN2@is_expr_it
$LN6@is_expr_it:

; 3384 :     case T_INSTRUCTION:
; 3385 :         switch( item->tokval ) {

	mov	rax, QWORD PTR item$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv68[rsp], eax
	mov	eax, DWORD PTR tv68[rsp]
	sub	eax, 501				; 000001f5H
	mov	DWORD PTR tv68[rsp], eax
	cmp	DWORD PTR tv68[rsp], 75			; 0000004bH
	ja	SHORT $LN4@is_expr_it
	mov	eax, DWORD PTR tv68[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN19@is_expr_it[rcx+rax]
	mov	eax, DWORD PTR $LN20@is_expr_it[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN7@is_expr_it:

; 3386 :         case T_SHL:
; 3387 :         case T_SHR:
; 3388 :             item->token = T_BINARY_OPERATOR;

	mov	rax, QWORD PTR item$[rsp]
	mov	BYTE PTR [rax], 5

; 3389 :             item->precedence = 8;

	mov	rax, QWORD PTR item$[rsp]
	mov	BYTE PTR [rax+1], 8

; 3390 :             return( TRUE );

	mov	al, 1
	jmp	$LN1@is_expr_it
$LN8@is_expr_it:

; 3391 :         case T_NOT:
; 3392 :             item->token = T_UNARY_OPERATOR;

	mov	rax, QWORD PTR item$[rsp]
	mov	BYTE PTR [rax], 4

; 3393 :             item->precedence = 11;

	mov	rax, QWORD PTR item$[rsp]
	mov	BYTE PTR [rax+1], 11

; 3394 :             return( TRUE );

	mov	al, 1
	jmp	$LN1@is_expr_it
$LN9@is_expr_it:

; 3395 :         case T_AND:
; 3396 :             item->token = T_BINARY_OPERATOR;

	mov	rax, QWORD PTR item$[rsp]
	mov	BYTE PTR [rax], 5

; 3397 :             item->precedence = 12;

	mov	rax, QWORD PTR item$[rsp]
	mov	BYTE PTR [rax+1], 12

; 3398 :             return( TRUE );

	mov	al, 1
	jmp	$LN1@is_expr_it
$LN10@is_expr_it:

; 3399 :         case T_OR:
; 3400 :         case T_XOR:
; 3401 :             item->token = T_BINARY_OPERATOR;

	mov	rax, QWORD PTR item$[rsp]
	mov	BYTE PTR [rax], 5

; 3402 :             item->precedence = 13;

	mov	rax, QWORD PTR item$[rsp]
	mov	BYTE PTR [rax+1], 13

; 3403 :             return( TRUE );

	mov	al, 1
	jmp	SHORT $LN1@is_expr_it
$LN4@is_expr_it:

; 3404 :         }
; 3405 :         return( FALSE );

	xor	al, al
	jmp	SHORT $LN1@is_expr_it
$LN11@is_expr_it:

; 3406 :     case T_RES_ID:
; 3407 :         if ( item->tokval == T_DUP ) /* DUP must terminate the expression */

	mov	rax, QWORD PTR item$[rsp]
	cmp	DWORD PTR [rax+16], 259			; 00000103H
	jne	SHORT $LN12@is_expr_it

; 3408 :             return( FALSE );

	xor	al, al
	jmp	SHORT $LN1@is_expr_it
$LN12@is_expr_it:

; 3409 :         break;

	jmp	SHORT $LN2@is_expr_it
$LN13@is_expr_it:

; 3410 :     case T_DIRECTIVE:
; 3411 :         /* PROC is converted to a type */
; 3412 :         if ( item->tokval == T_PROC ) {

	mov	rax, QWORD PTR item$[rsp]
	cmp	DWORD PTR [rax+16], 428			; 000001acH
	jne	SHORT $LN14@is_expr_it

; 3413 :             item->token = T_STYPE;

	mov	rax, QWORD PTR item$[rsp]
	mov	BYTE PTR [rax], 6

; 3414 :             /* v2.06: avoid to use ST_PROC */
; 3415 :             //item->bytval = ST_PROC;
; 3416 :             item->tokval = ( ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) ? T_FAR : T_NEAR );

	mov	eax, DWORD PTR ModuleInfo+360
	mov	ecx, 1
	mov	DWORD PTR tv148[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv148[rsp]
	shl	eax, cl
	and	eax, 112				; 00000070H
	test	eax, eax
	je	SHORT $LN17@is_expr_it
	mov	DWORD PTR tv88[rsp], 222		; 000000deH
	jmp	SHORT $LN18@is_expr_it
$LN17@is_expr_it:
	mov	DWORD PTR tv88[rsp], 221		; 000000ddH
$LN18@is_expr_it:
	mov	rax, QWORD PTR item$[rsp]
	mov	ecx, DWORD PTR tv88[rsp]
	mov	DWORD PTR [rax+16], ecx

; 3417 :             return( TRUE );

	mov	al, 1
	jmp	SHORT $LN1@is_expr_it
$LN14@is_expr_it:
$LN15@is_expr_it:

; 3418 :         }
; 3419 :         /* fall through. Other directives will end the expression */
; 3420 :     case T_COMMA:
; 3421 :     //case T_FLOAT: /* v2.05: floats are now handled */
; 3422 :     //case T_QUESTION_MARK: /* v2.08: no need to be handled here */
; 3423 :         return( FALSE );

	xor	al, al
	jmp	SHORT $LN1@is_expr_it
$LN2@is_expr_it:

; 3424 :     }
; 3425 :     return( TRUE );

	mov	al, 1
$LN1@is_expr_it:

; 3426 : }

	add	rsp, 16
	pop	rdi
	ret	0
	npad	3
$LN20@is_expr_it:
	DD	$LN10@is_expr_it
	DD	$LN9@is_expr_it
	DD	$LN7@is_expr_it
	DD	$LN8@is_expr_it
	DD	$LN4@is_expr_it
$LN19@is_expr_it:
	DB	0
	DB	4
	DB	4
	DB	1
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
is_expr_item ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
rc$ = 112
curr_operator$4 = 128
opnd2$5 = 160
exp_token$6 = 276
tv68 = 280
tv166 = 288
tv274 = 296
tv428 = 300
tv485 = 304
tv494 = 312
tv506 = 320
tv513 = 328
tv521 = 336
tv537 = 344
tv549 = 352
opnd1$ = 384
i$ = 392
tokenarray$ = 400
end$ = 408
flags$ = 416
evaluate PROC

; 3216 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 368				; 00000170H
	mov	rdi, rsp
	mov	ecx, 92					; 0000005cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+384]

; 3217 :     ret_code rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 3218 :     unsigned char c;
; 3219 :     char *p;
; 3220 :     DebugMsg1(("%u evaluate(i=%d, end=%d, flags=%X) enter [opnd1: kind=%d type=%s]\n",

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN44@evaluate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv68[rsp], rax
	jmp	SHORT $LN45@evaluate
$LN44@evaluate:
	lea	rax, OFFSET FLAT:$SG12307
	mov	QWORD PTR tv68[rsp], rax
$LN45@evaluate:
	mov	eax, DWORD PTR evallvl
	inc	eax
	mov	DWORD PTR evallvl, eax
	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR tv68[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+60]
	mov	DWORD PTR [rsp+40], ecx
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR end$[rsp]
	mov	rax, QWORD PTR i$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG12308
	call	DoDebugMsg1

; 3221 :                ++evallvl, *i, end, flags, opnd1->kind, opnd1->type ? opnd1->type->name : "NULL" ));
; 3222 : 
; 3223 :     /* v2.07: this function has been "simplified".
; 3224 :      * it's ensured now that if any operator is involved
; 3225 :      * - including () and [] - then calculate() will be called.
; 3226 :      * v2.10: removed the 'return( ERROR )' branches, to make
; 3227 :      * OPATTR work better.
; 3228 :      * v2.10: loop changed from 'do {} while' to 'while () {}'.
; 3229 :      * v2.10: 'flags' argument contains "inside []" information.
; 3230 :      */
; 3231 : 
; 3232 :     /*
; 3233 :      * First token may be either an unary operator or an operand
; 3234 :      */
; 3235 :     if ( opnd1->kind == EXPR_EMPTY &&  !is_unary_op( tokenarray[*i].token ) ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], -2
	jne	$LN8@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	je	$LN8@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 91					; 0000005bH
	je	$LN8@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN8@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN8@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 4
	je	SHORT $LN8@evaluate

; 3236 :         rc = get_operand( opnd1, i, tokenarray, flags );

	movzx	r9d, BYTE PTR flags$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	get_operand
	mov	DWORD PTR rc$[rsp], eax
$LN8@evaluate:
$LN2@evaluate:

; 3237 :     }
; 3238 :     /* now handle operators. */
; 3239 :     while ( rc == NOT_ERROR && *i < end && !IsCurrToken( T_CL_BRACKET ) && !IsCurrToken( T_CL_SQ_BRACKET ) ) {

	cmp	DWORD PTR rc$[rsp], 0
	jne	$LN3@evaluate
	mov	rax, QWORD PTR i$[rsp]
	mov	ecx, DWORD PTR end$[rsp]
	cmp	DWORD PTR [rax], ecx
	jge	$LN3@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	$LN3@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 93					; 0000005dH
	je	$LN3@evaluate

; 3240 : 
; 3241 :         int curr_operator;
; 3242 :         struct expr opnd2;
; 3243 : 
; 3244 :         curr_operator = *i;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR curr_operator$4[rsp], eax

; 3245 :         DebugMsg1(("%u evaluate loop, operator=>%s< opnd1->sym=%X, type=%s\n",

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN46@evaluate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv166[rsp], rax
	jmp	SHORT $LN47@evaluate
$LN46@evaluate:
	lea	rax, OFFSET FLAT:$SG12310
	mov	QWORD PTR tv166[rsp], rax
$LN47@evaluate:
	movsxd	rax, DWORD PTR curr_operator$4[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tv166[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	r9, QWORD PTR [rcx+80]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG12311
	call	DoDebugMsg1

; 3246 :                    evallvl, tokenarray[curr_operator].string_ptr, opnd1->sym, (opnd1->type ? opnd1->type->name : "NULL") ));
; 3247 : 
; 3248 :         if ( opnd1->kind != EXPR_EMPTY ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], -2
	je	$LN9@evaluate

; 3249 :             /* check operator behind operand. Must be binary or open bracket */
; 3250 :             if ( tokenarray[curr_operator].token == '+' || tokenarray[curr_operator].token == '-' )

	movsxd	rax, DWORD PTR curr_operator$4[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN12@evaluate
	movsxd	rax, DWORD PTR curr_operator$4[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN10@evaluate
$LN12@evaluate:

; 3251 :                 tokenarray[curr_operator].specval = BINARY_PLUSMINUS;

	movsxd	rax, DWORD PTR curr_operator$4[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	BYTE PTR [rcx+rax+1], 1
	jmp	$LN11@evaluate
$LN10@evaluate:

; 3252 :             else if( !is_operator( tokenarray[curr_operator].token ) || tokenarray[curr_operator].token == T_UNARY_OPERATOR ) {

	movsxd	rax, DWORD PTR curr_operator$4[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jge	SHORT $LN15@evaluate
	movsxd	rax, DWORD PTR curr_operator$4[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 4
	je	SHORT $LN15@evaluate
	movsxd	rax, DWORD PTR curr_operator$4[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 5
	jne	SHORT $LN14@evaluate
$LN15@evaluate:
	movsxd	rax, DWORD PTR curr_operator$4[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 4
	jne	$LN13@evaluate
$LN14@evaluate:

; 3253 :                 DebugMsg(("%u evaluate: unexpected token at idx=%u, token=%X >%s<\n", evallvl, curr_operator, tokenarray[curr_operator].token, tokenarray[curr_operator].tokpos ));

	movsxd	rax, DWORD PTR curr_operator$4[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR curr_operator$4[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rdx+rax+24]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, ecx
	mov	r8d, DWORD PTR curr_operator$4[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG12319
	call	DoDebugMsg

; 3254 :                 rc = ERROR;

	mov	DWORD PTR rc$[rsp], -1

; 3255 :                 //if ( !opnd2.is_opattr )  /* v2.11: opnd2 was accessed before initialization */
; 3256 :                 
; 3257 :                 if ( !opnd1->is_opattr )

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN16@evaluate

; 3258 :                     OperErr( curr_operator, tokenarray );

	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR curr_operator$4[rsp]
	call	OperErr
$LN16@evaluate:

; 3259 :                 break;

	jmp	$LN3@evaluate
$LN13@evaluate:
$LN11@evaluate:
$LN9@evaluate:

; 3260 :             }
; 3261 :         }
; 3262 : 
; 3263 :         (*i)++;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax

; 3264 : 
; 3265 :         init_expr( &opnd2 );

	lea	rcx, QWORD PTR opnd2$5[rsp]
	call	init_expr

; 3266 :         PrepareOp( &opnd2, opnd1, &tokenarray[curr_operator] );

	movsxd	rax, DWORD PTR curr_operator$4[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	rdx, QWORD PTR opnd1$[rsp]
	lea	rcx, QWORD PTR opnd2$5[rsp]
	call	PrepareOp

; 3267 : 
; 3268 :         /* read the (next) operand.
; 3269 :          */
; 3270 : 
; 3271 :         if( tokenarray[curr_operator].token == T_OP_BRACKET ||

	movsxd	rax, DWORD PTR curr_operator$4[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN19@evaluate
	movsxd	rax, DWORD PTR curr_operator$4[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 91					; 0000005bH
	jne	$LN17@evaluate
$LN19@evaluate:

; 3272 :            tokenarray[curr_operator].token == T_OP_SQ_BRACKET ) {
; 3273 :             int exp_token = T_CL_BRACKET;

	mov	DWORD PTR exp_token$6[rsp], 41		; 00000029H

; 3274 :             if( tokenarray[curr_operator].token == T_OP_SQ_BRACKET ) {

	movsxd	rax, DWORD PTR curr_operator$4[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 91					; 0000005bH
	jne	SHORT $LN20@evaluate

; 3275 :                 exp_token = T_CL_SQ_BRACKET;

	mov	DWORD PTR exp_token$6[rsp], 93		; 0000005dH
	jmp	SHORT $LN21@evaluate
$LN20@evaluate:

; 3276 : #if 1 /* v2.10: slightly hackish; see regression test dotop5.asm */
; 3277 :             } else if ( opnd1->is_dot ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 7
	and	eax, 1
	test	eax, eax
	je	SHORT $LN22@evaluate

; 3278 :                 opnd2.type = opnd1->type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR opnd2$5[rsp+96], rax

; 3279 :                 opnd2.is_dot = TRUE;

	mov	eax, DWORD PTR opnd2$5[rsp+72]
	bts	eax, 7
	mov	DWORD PTR opnd2$5[rsp+72], eax
$LN22@evaluate:
$LN21@evaluate:

; 3280 : #endif
; 3281 :             }
; 3282 : 
; 3283 :             rc = evaluate( &opnd2, i, tokenarray, end, ( flags | ( exp_token == T_CL_SQ_BRACKET ? EXPF_IN_SQBR : 0 ) ) & ~EXPF_ONEOPND );

	cmp	DWORD PTR exp_token$6[rsp], 93		; 0000005dH
	jne	SHORT $LN48@evaluate
	mov	DWORD PTR tv274[rsp], 8
	jmp	SHORT $LN49@evaluate
$LN48@evaluate:
	mov	DWORD PTR tv274[rsp], 0
$LN49@evaluate:
	movzx	eax, BYTE PTR flags$[rsp]
	or	eax, DWORD PTR tv274[rsp]
	and	eax, -5
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR end$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	lea	rcx, QWORD PTR opnd2$5[rsp]
	call	evaluate
	mov	DWORD PTR rc$[rsp], eax

; 3284 : 
; 3285 :             if( !IsCurrToken( exp_token ) ) {

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, DWORD PTR exp_token$6[rsp]
	je	$LN23@evaluate

; 3286 :                 DebugMsg(("%u evaluate: error, missing '%c', i=%u\n", evallvl, exp_token, *i ));

	mov	rax, QWORD PTR i$[rsp]
	mov	r9d, DWORD PTR [rax]
	mov	r8d, DWORD PTR exp_token$6[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG12329
	call	DoDebugMsg

; 3287 :                 if ( rc != ERROR ) {

	cmp	DWORD PTR rc$[rsp], -1
	je	SHORT $LN25@evaluate

; 3288 :                     fnEmitErr( MISSING_RIGHT_PARENTHESIS_IN_EXPRESSION );

	mov	ecx, 227				; 000000e3H
	call	QWORD PTR fnEmitErr

; 3289 :                     /* v2.12: if curr token is a comma, the intention might be to call a macro function
; 3290 :                      * - using an undefined ( or not yet defined ) macro. The problem is that the name
; 3291 :                      * of this undefined macro isn't displayed in pass one, making it hard to see the
; 3292 :                      * reason for the error msg. However, if a comma is found, then it's surely no valid
; 3293 :                      * expression - in this case an "undefined symbol" err msg may be helpful.
; 3294 :                      */
; 3295 :                     if ( IsCurrToken( T_COMMA ) && opnd1->sym && opnd1->sym->state == SYM_UNDEFINED )

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN26@evaluate
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN26@evaluate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN26@evaluate

; 3296 :                         fnEmitErr( SYMBOL_NOT_DEFINED, opnd1->sym->name );

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 102				; 00000066H
	call	QWORD PTR fnEmitErr
$LN26@evaluate:
$LN25@evaluate:

; 3297 :                 }
; 3298 :                 rc = ERROR;

	mov	DWORD PTR rc$[rsp], -1

; 3299 :             } else {

	jmp	SHORT $LN24@evaluate
$LN23@evaluate:

; 3300 :                 (*i)++;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax
$LN24@evaluate:

; 3301 :             }

	jmp	$LN18@evaluate
$LN17@evaluate:

; 3302 : 
; 3303 :         } else if( is_unary_op( tokenarray[*i].token ) ) { /* brackets, +, -, T_UNARY_OPERATOR? */

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	je	$LN29@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 91					; 0000005bH
	je	SHORT $LN29@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN29@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN29@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 4
	jne	SHORT $LN27@evaluate
$LN29@evaluate:

; 3304 :             rc = evaluate( &opnd2, i, tokenarray, end, flags | EXPF_ONEOPND );

	movzx	eax, BYTE PTR flags$[rsp]
	or	eax, 4
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR end$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	lea	rcx, QWORD PTR opnd2$5[rsp]
	call	evaluate
	mov	DWORD PTR rc$[rsp], eax

; 3305 :         } else {

	jmp	SHORT $LN28@evaluate
$LN27@evaluate:

; 3306 :             /* get either:
; 3307 :              * - operand of unary operator OR
; 3308 :              * - 2. operand of binary operator
; 3309 :              */
; 3310 :             rc = get_operand( &opnd2, i, tokenarray, flags );

	movzx	r9d, BYTE PTR flags$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	lea	rcx, QWORD PTR opnd2$5[rsp]
	call	get_operand
	mov	DWORD PTR rc$[rsp], eax
$LN28@evaluate:
$LN18@evaluate:
$LN4@evaluate:

; 3311 :         }
; 3312 : 
; 3313 :         /*
; 3314 :          * parse expression until either the end or an operator with a higher priority is found.
; 3315 :          */
; 3316 : 
; 3317 :         while( rc != ERROR && *i < end && !IsCurrToken( T_CL_BRACKET ) && !IsCurrToken( T_CL_SQ_BRACKET ) ) {

	cmp	DWORD PTR rc$[rsp], -1
	je	$LN5@evaluate
	mov	rax, QWORD PTR i$[rsp]
	mov	ecx, DWORD PTR end$[rsp]
	cmp	DWORD PTR [rax], ecx
	jge	$LN5@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	$LN5@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 93					; 0000005dH
	je	$LN5@evaluate

; 3318 :             
; 3319 :             if ( tokenarray[*i].token == '+' || tokenarray[*i].token == '-' )

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN32@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN30@evaluate
$LN32@evaluate:

; 3320 :                 tokenarray[*i].specval = BINARY_PLUSMINUS;

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	BYTE PTR [rcx+rax+1], 1
	jmp	$LN31@evaluate
$LN30@evaluate:

; 3321 :             else if( !is_operator( tokenarray[*i].token ) || tokenarray[*i].token == T_UNARY_OPERATOR ) {

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jge	SHORT $LN35@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 4
	je	SHORT $LN35@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 5
	jne	SHORT $LN34@evaluate
$LN35@evaluate:
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 4
	jne	$LN33@evaluate
$LN34@evaluate:

; 3322 :                 DebugMsg(("%u evaluate: unexpected token at %u, token=%X >%s<\n", evallvl, *i, tokenarray[*i].token, tokenarray[*i].tokpos ));

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR i$[rsp]
	movsxd	rcx, DWORD PTR [rcx]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rdx+rax+24]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, ecx
	mov	rax, QWORD PTR i$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG12341
	call	DoDebugMsg

; 3323 :                 rc = ERROR;

	mov	DWORD PTR rc$[rsp], -1

; 3324 :                 if ( !opnd2.is_opattr ) /* don't emit error if expression is OPATTR operand */

	mov	eax, DWORD PTR opnd2$5[rsp+72]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN36@evaluate

; 3325 :                     OperErr( *i, tokenarray );

	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR i$[rsp]
	mov	ecx, DWORD PTR [rax]
	call	OperErr
$LN36@evaluate:

; 3326 :                 break;

	jmp	$LN5@evaluate
$LN33@evaluate:
$LN31@evaluate:

; 3327 :             }
; 3328 : 
; 3329 :             if( get_precedence( &tokenarray[*i] ) >= get_precedence( &tokenarray[curr_operator] ) )

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	get_precedence
	mov	DWORD PTR tv428[rsp], eax
	movsxd	rcx, DWORD PTR curr_operator$4[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	call	get_precedence
	mov	ecx, DWORD PTR tv428[rsp]
	cmp	ecx, eax
	jl	SHORT $LN37@evaluate

; 3330 :                 break;

	jmp	SHORT $LN5@evaluate
$LN37@evaluate:

; 3331 : 
; 3332 :             rc = evaluate( &opnd2, i, tokenarray, end, flags | EXPF_ONEOPND );

	movzx	eax, BYTE PTR flags$[rsp]
	or	eax, 4
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR end$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	lea	rcx, QWORD PTR opnd2$5[rsp]
	call	evaluate
	mov	DWORD PTR rc$[rsp], eax

; 3333 : 
; 3334 :         }

	jmp	$LN4@evaluate
$LN5@evaluate:

; 3335 : 
; 3336 :         /* v2.10: OPATTR special handling */
; 3337 :         if ( rc == ERROR && opnd2.is_opattr ) {

	cmp	DWORD PTR rc$[rsp], -1
	jne	$LN38@evaluate
	mov	eax, DWORD PTR opnd2$5[rsp+72]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	je	SHORT $LN38@evaluate
$LN6@evaluate:

; 3338 :             /* skip tokens until the end */
; 3339 :             while( *i < end && !IsCurrToken( T_CL_BRACKET ) && !IsCurrToken( T_CL_SQ_BRACKET ) ) {

	mov	rax, QWORD PTR i$[rsp]
	mov	ecx, DWORD PTR end$[rsp]
	cmp	DWORD PTR [rax], ecx
	jge	SHORT $LN7@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN7@evaluate
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 93					; 0000005dH
	je	SHORT $LN7@evaluate

; 3340 :                 (*i)++;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax

; 3341 :             }

	jmp	SHORT $LN6@evaluate
$LN7@evaluate:

; 3342 :             opnd2.kind = EXPR_EMPTY;

	mov	DWORD PTR opnd2$5[rsp+60], -2

; 3343 :             rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0
$LN38@evaluate:

; 3344 :         }
; 3345 :         if( rc != ERROR )

	cmp	DWORD PTR rc$[rsp], -1
	je	SHORT $LN39@evaluate

; 3346 :             rc = calculate( opnd1, &opnd2, &tokenarray[curr_operator] );

	movsxd	rax, DWORD PTR curr_operator$4[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	lea	rdx, QWORD PTR opnd2$5[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	calculate
	mov	DWORD PTR rc$[rsp], eax
$LN39@evaluate:

; 3347 : 
; 3348 :         if( flags & EXPF_ONEOPND ) /* stop after one operand? */

	movzx	eax, BYTE PTR flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN40@evaluate

; 3349 :             break;

	jmp	SHORT $LN3@evaluate
$LN40@evaluate:

; 3350 :     }

	jmp	$LN2@evaluate
$LN3@evaluate:

; 3351 : 
; 3352 : #ifdef DEBUG_OUT
; 3353 :     if ( opnd1->hvalue != -1 && opnd1->hvalue != 0 ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+4], -1
	je	$LN41@evaluate
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	$LN41@evaluate

; 3354 :         DebugMsg1(("%u evaluate exit, rc=%d, kind=%d value=%" I64_SPEC "d(0x%" I64_SPEC "X) memtype=%Xh string=%s indirect=%u type=>%s<\n",

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN50@evaluate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv485[rsp], rax
	jmp	SHORT $LN51@evaluate
$LN50@evaluate:
	lea	rax, OFFSET FLAT:$SG12349
	mov	QWORD PTR tv485[rsp], rax
$LN51@evaluate:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN52@evaluate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv494[rsp], rax
	jmp	SHORT $LN53@evaluate
$LN52@evaluate:
	lea	rax, OFFSET FLAT:$SG12350
	mov	QWORD PTR tv494[rsp], rax
$LN53@evaluate:
	mov	eax, DWORD PTR evallvl
	mov	DWORD PTR tv506[rsp], eax
	mov	eax, DWORD PTR evallvl
	dec	eax
	mov	DWORD PTR evallvl, eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	mov	rcx, QWORD PTR tv485[rsp]
	mov	QWORD PTR [rsp+72], rcx
	mov	DWORD PTR [rsp+64], eax
	mov	rax, QWORD PTR tv494[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	r9d, DWORD PTR [rax+60]
	mov	r8d, DWORD PTR rc$[rsp]
	mov	edx, DWORD PTR tv506[rsp]
	lea	rcx, OFFSET FLAT:$SG12351
	call	DoDebugMsg1

; 3355 :                    evallvl--, rc, opnd1->kind, opnd1->llvalue, opnd1->llvalue, opnd1->mem_type,
; 3356 :                    opnd1->quoted_string ? opnd1->quoted_string->string_ptr : "NULL",
; 3357 :                    opnd1->indirect,
; 3358 :                    opnd1->type ? opnd1->type->name : "NULL" ));
; 3359 :     } else {

	jmp	$LN42@evaluate
$LN41@evaluate:

; 3360 :         DebugMsg1(("%u evaluate exit, rc=%d, kind=%d value=%" I32_SPEC "d(0x%" I32_SPEC "X) memtype=%Xh string=%s ind=%u exp=%u ofssiz=%d instr=%s type=>%s<\n",

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN54@evaluate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv513[rsp], rax
	jmp	SHORT $LN55@evaluate
$LN54@evaluate:
	lea	rax, OFFSET FLAT:$SG12352
	mov	QWORD PTR tv513[rsp], rax
$LN55@evaluate:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+56], -2
	jne	SHORT $LN56@evaluate
	lea	rax, OFFSET FLAT:$SG12353
	mov	QWORD PTR tv521[rsp], rax
	jmp	SHORT $LN57@evaluate
$LN56@evaluate:
	xor	edx, edx
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rax+56]
	call	GetResWName
	mov	QWORD PTR tv521[rsp], rax
$LN57@evaluate:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN58@evaluate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv537[rsp], rax
	jmp	SHORT $LN59@evaluate
$LN58@evaluate:
	lea	rax, OFFSET FLAT:$SG12354
	mov	QWORD PTR tv537[rsp], rax
$LN59@evaluate:
	mov	eax, DWORD PTR evallvl
	mov	DWORD PTR tv549[rsp], eax
	mov	eax, DWORD PTR evallvl
	dec	eax
	mov	DWORD PTR evallvl, eax
	mov	rax, QWORD PTR opnd1$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	shr	ecx, 1
	and	ecx, 1
	mov	rdx, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rdx+72]
	and	edx, 1
	mov	r8, QWORD PTR tv513[rsp]
	mov	QWORD PTR [rsp+96], r8
	mov	r8, QWORD PTR tv521[rsp]
	mov	QWORD PTR [rsp+88], r8
	mov	DWORD PTR [rsp+80], eax
	mov	DWORD PTR [rsp+72], ecx
	mov	DWORD PTR [rsp+64], edx
	mov	rax, QWORD PTR tv537[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	r9d, DWORD PTR [rax+60]
	mov	r8d, DWORD PTR rc$[rsp]
	mov	edx, DWORD PTR tv549[rsp]
	lea	rcx, OFFSET FLAT:$SG12355
	call	DoDebugMsg1
$LN42@evaluate:

; 3361 :                    evallvl--, rc, opnd1->kind, opnd1->value, opnd1->value, opnd1->mem_type,
; 3362 :                    opnd1->quoted_string ? opnd1->quoted_string->string_ptr : "NULL",
; 3363 :                    opnd1->indirect, opnd1->explicit, opnd1->Ofssize,
; 3364 :                    opnd1->instr == EMPTY ? "" : GetResWName( opnd1->instr, NULL ),
; 3365 :                    opnd1->type ? opnd1->type->name : "NULL" ));
; 3366 :     }
; 3367 : #endif
; 3368 :     return( rc );

	mov	eax, DWORD PTR rc$[rsp]

; 3369 : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:evaluate$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 368				; 00000170H
	pop	rdi
	ret	0
evaluate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
OperErr	PROC

; 3203 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 3204 :     if ( tokenarray[i].token <= T_BAD_NUM ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 12
	jg	SHORT $LN2@OperErr

; 3205 :         fnEmitErr( MISSING_OPERATOR_IN_EXPRESSION ); ERRLOC(i);

	mov	ecx, 150				; 00000096H
	call	QWORD PTR fnEmitErr

; 3206 :     } else

	jmp	SHORT $LN3@OperErr
$LN2@OperErr:

; 3207 :         fnEmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	QWORD PTR fnEmitErr
$LN3@OperErr:

; 3208 : 
; 3209 :     return;
; 3210 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
OperErr	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
tv75 = 32
tv86 = 40
tv151 = 48
tv162 = 56
opnd$ = 80
old$ = 88
oper$ = 96
PrepareOp PROC

; 3156 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 3157 :     opnd->is_opattr = old->is_opattr;

	mov	rax, QWORD PTR old$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 4
	and	eax, 1
	and	eax, 1
	shl	eax, 4
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, -17				; ffffffefH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 3158 : 
; 3159 :     switch ( oper->token ) {

	mov	rax, QWORD PTR oper$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv75[rsp], al
	cmp	BYTE PTR tv75[rsp], 4
	je	$LN10@PrepareOp
	cmp	BYTE PTR tv75[rsp], 46			; 0000002eH
	je	SHORT $LN6@PrepareOp
	jmp	$LN2@PrepareOp
$LN6@PrepareOp:

; 3160 :     case T_DOT:
; 3161 :         DebugMsg(("PrepareOp: DOT operator found, old.sym=%X, old.type=%s, expr=%s\n", old->sym, (old->type ? old->type->name : "NULL" ), oper->tokpos + strlen( oper->string_ptr ) ));

	mov	rax, QWORD PTR old$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN13@PrepareOp
	mov	rax, QWORD PTR old$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv86[rsp], rax
	jmp	SHORT $LN14@PrepareOp
$LN13@PrepareOp:
	lea	rax, OFFSET FLAT:$SG12263
	mov	QWORD PTR tv86[rsp], rax
$LN14@PrepareOp:
	mov	rax, QWORD PTR oper$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	strlen
	mov	rcx, QWORD PTR oper$[rsp]
	add	rax, QWORD PTR [rcx+24]
	mov	r9, rax
	mov	r8, QWORD PTR tv86[rsp]
	mov	rax, QWORD PTR old$[rsp]
	mov	rdx, QWORD PTR [rax+80]
	lea	rcx, OFFSET FLAT:$SG12264
	call	DoDebugMsg

; 3162 :         if ( old->type ) {

	mov	rax, QWORD PTR old$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN7@PrepareOp

; 3163 :             DebugMsg1(("PrepareOp: implicit type: %s\n", old->type->name));

	mov	rax, QWORD PTR old$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12267
	call	DoDebugMsg1

; 3164 :             opnd->type = old->type;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR old$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx

; 3165 :             opnd->is_dot = TRUE;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	bts	eax, 7
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx+72], eax
	jmp	SHORT $LN8@PrepareOp
$LN7@PrepareOp:

; 3166 : #if 0
; 3167 :         /* v2.09 (type field is now set in get_operand();
; 3168 :          * it's problematic to use old->sym here, because this field
; 3169 :          * is not necessarily set by the operand just before the dot.
; 3170 :          */
; 3171 :         //} else if ( old->sym && old->sym->mem_type == MT_TYPE ) {
; 3172 :         } else if ( old->sym && old->sym->mem_type == MT_TYPE && old->instr == EMPTY ) {
; 3173 :             DebugMsg1(("PrepareOp: label %s, implicit type: %s\n", old->sym->name, old->sym->type->name));
; 3174 :             for ( opnd->type = old->sym->type; opnd->type->type; opnd->type = opnd->type->type );
; 3175 : #endif
; 3176 :         /* v2.07: changed */
; 3177 :         //} else if ( !ModuleInfo.oldstructs ) {
; 3178 :         /* v2.08: reverted, replaced by changes in dot_op() and get_operand(), case T_STYPE */
; 3179 :         //} else if ( old->sym && old->sym->mem_type == MT_EMPTY && !ModuleInfo.oldstructs ) {
; 3180 :         /* v2.11: nullstruct not used here. Set type to NULL and is_dot==TRUE */
; 3181 :         //} else if ( !ModuleInfo.oldstructs ) {
; 3182 :         } else if ( !ModuleInfo.oldstructs && old->sym && old->sym->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 8
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN9@PrepareOp
	mov	rax, QWORD PTR old$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN9@PrepareOp
	mov	rax, QWORD PTR old$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN9@PrepareOp

; 3183 :             DebugMsg1(("PrepareOp: forward ref to %s, type will be NULL\n", old->sym->name ));

	mov	rax, QWORD PTR old$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12269
	call	DoDebugMsg1

; 3184 :             opnd->type = NULL;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rax+96], 0

; 3185 :             opnd->is_dot = TRUE;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	bts	eax, 7
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx+72], eax
$LN9@PrepareOp:
$LN8@PrepareOp:

; 3186 :         }
; 3187 :         break;

	jmp	$LN2@PrepareOp
$LN10@PrepareOp:

; 3188 :     case T_UNARY_OPERATOR:
; 3189 :         switch ( oper->tokval ) {

	mov	rax, QWORD PTR oper$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv151[rsp], eax
	cmp	DWORD PTR tv151[rsp], 229		; 000000e5H
	je	SHORT $LN11@PrepareOp
	cmp	DWORD PTR tv151[rsp], 242		; 000000f2H
	je	SHORT $LN11@PrepareOp
	jmp	SHORT $LN4@PrepareOp
$LN11@PrepareOp:

; 3190 :         case T_OPATTR:
; 3191 :         case T_DOT_TYPE:
; 3192 :             DebugMsg(("PrepareOp: OPATTR operator found, old.sym=%X, old.type=%s, expr=%s\n",

	mov	rax, QWORD PTR old$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN15@PrepareOp
	mov	rax, QWORD PTR old$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv162[rsp], rax
	jmp	SHORT $LN16@PrepareOp
$LN15@PrepareOp:
	lea	rax, OFFSET FLAT:$SG12272
	mov	QWORD PTR tv162[rsp], rax
$LN16@PrepareOp:
	mov	rax, QWORD PTR oper$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	strlen
	mov	rcx, QWORD PTR oper$[rsp]
	add	rax, QWORD PTR [rcx+24]
	mov	r9, rax
	mov	r8, QWORD PTR tv162[rsp]
	mov	rax, QWORD PTR old$[rsp]
	mov	rdx, QWORD PTR [rax+80]
	lea	rcx, OFFSET FLAT:$SG12273
	call	DoDebugMsg

; 3193 :                       old->sym, (old->type ? old->type->name : "NULL" ), oper->tokpos + strlen( oper->string_ptr ) ));
; 3194 :             opnd->is_opattr = TRUE;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 16
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx+72], eax
$LN4@PrepareOp:
$LN2@PrepareOp:

; 3195 :             break;
; 3196 :         }
; 3197 :         break;
; 3198 :     }
; 3199 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
PrepareOp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
temp$ = 96
sym$ = 104
name$ = 112
tv92 = 120
tv322 = 124
tv341 = 128
tv347 = 136
tv353 = 144
tv359 = 152
tv502 = 160
tv545 = 168
tv561 = 172
tv578 = 176
tv584 = 180
tv590 = 184
tv596 = 188
tv602 = 192
tv1355 = 200
tv1367 = 208
tv710 = 216
tv716 = 224
tv722 = 232
tv777 = 240
tv960 = 248
tv886 = 256
tv909 = 264
tv930 = 272
tv936 = 280
opnd1$ = 304
opnd2$ = 312
oper$ = 320
calculate PROC

; 2558 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 288				; 00000120H
	mov	rdi, rsp
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+304]

; 2559 :     int_32              temp;
; 2560 :     struct asym         *sym;
; 2561 :     char                *name;
; 2562 : 
; 2563 :     /* avoid to use the <string> member once it's part of an expression!
; 2564 :      * the <value> member is the one to be used then.
; 2565 :      * test case: db "a"+80h
; 2566 :      * v2.08: first: this is too early; second: the current operand is opnd2.
; 2567 :      * third: the space is also used by float_tok member, which cannot be cleared.
; 2568 :      * probably the best solution - at calculate()'s end:
; 2569 :      * if ( opnd1->kind == EXPR_CONST ) opnd1->quoted_string = NULL;
; 2570 :      */
; 2571 :     opnd1->quoted_string = NULL;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rax+16], 0

; 2572 : 
; 2573 :     /* v2.11: added check to ensure constant fits in 64-bits */
; 2574 :     if ( opnd2->hlvalue ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	$LN8@calculate

; 2575 :         /* opattr and unary +/- are ok, they can handle 128-bits */
; 2576 :         if ( opnd2->is_opattr || ( ( oper->token == '+' || oper->token == '-' ) && oper->specval == UNARY_PLUSMINUS ) )

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN11@calculate
	mov	rax, QWORD PTR oper$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN12@calculate
	mov	rax, QWORD PTR oper$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN9@calculate
$LN12@calculate:
	mov	rax, QWORD PTR oper$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	test	eax, eax
	jne	SHORT $LN9@calculate
$LN11@calculate:

; 2577 :             ;

	jmp	SHORT $LN10@calculate
$LN9@calculate:

; 2578 :         else {
; 2579 :             DebugMsg(("%u calculate(%s): value too large\n", evallvl, oper->string_ptr ));

	mov	rax, QWORD PTR oper$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG12082
	call	DoDebugMsg

; 2580 :             return( fnEmitErr( CONSTANT_VALUE_TOO_LARGE_EX, opnd2->hlvalue, opnd2->value64 ) );

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 272				; 00000110H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@calculate
$LN10@calculate:
$LN8@calculate:

; 2581 :         }
; 2582 :     }
; 2583 : 
; 2584 :     switch( oper->token ) {

	mov	rax, QWORD PTR oper$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv92[rsp], eax
	mov	eax, DWORD PTR tv92[rsp]
	sub	eax, 4
	mov	DWORD PTR tv92[rsp], eax
	cmp	DWORD PTR tv92[rsp], 87			; 00000057H
	ja	$LN133@calculate
	movsxd	rax, DWORD PTR tv92[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN179@calculate[rcx+rax]
	mov	eax, DWORD PTR $LN180@calculate[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN13@calculate:

; 2585 :     case T_OP_SQ_BRACKET:
; 2586 :         /* v2.07: the ASSUMEs are now checked only when operator [] is done.
; 2587 :          * this is compatible with Masm:
; 2588 :          *   assume ebx:ptr <struct>
; 2589 :          *   mov eax, [ebx.<member>]             ;is to fail
; 2590 :          *   mov eax, [ebx.<struct>.<member>]    ;is to be ok
; 2591 :          * previously both variants were accepted by jwasm.
; 2592 :          */
; 2593 :         if ( opnd2->assumecheck == TRUE ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 6
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN14@calculate

; 2594 :             opnd2->assumecheck = FALSE;   /* check ONE time only! */

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, -65				; ffffffbfH
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 2595 :             if ( opnd1->sym == NULL ) /* v2.10: added; see assume10.asm */

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+80], 0
	jne	SHORT $LN15@calculate

; 2596 :                 CheckAssume( opnd2 );

	mov	rcx, QWORD PTR opnd2$[rsp]
	call	CheckAssume
$LN15@calculate:
$LN14@calculate:

; 2597 :         }
; 2598 : 
; 2599 :         if ( opnd1->kind == EXPR_EMPTY ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], -2
	jne	$LN16@calculate

; 2600 :             DebugMsg1(("%u calculate(%s): single item\n", evallvl, oper->string_ptr ));

	mov	rax, QWORD PTR oper$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG12087
	call	DoDebugMsg1

; 2601 :             TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 2602 :             opnd1->type = opnd2->type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx

; 2603 :             if ( opnd1->is_type && opnd1->kind == EXPR_CONST )

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN17@calculate
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN17@calculate

; 2604 :                 opnd1->is_type = 0;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, -9					; fffffff7H
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax
$LN17@calculate:

; 2605 :             break;

	jmp	$LN2@calculate
$LN16@calculate:

; 2606 :         }
; 2607 : 
; 2608 :         /* v2.03: make HJWasm reject syntax variants
; 2609 :          * "mov eax, DWORD [EBX]"
; 2610 :          * "mov eax, DWORD [var_name]"
; 2611 :          * variants still valid:
; 2612 :          * "mov eax, DWORD [WORD]"
; 2613 :          * "mov eax, DWORD [4]"
; 2614 :          * "mov eax, [DWORD][EBX]"
; 2615 :          */
; 2616 :         /* v2.08: structure/union names are ok: mov eax, S1[ebx] */
; 2617 :         //if ( opnd1->is_type == TRUE &&
; 2618 :         if ( opnd1->is_type == TRUE && opnd1->type == NULL &&

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN18@calculate
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	jne	SHORT $LN18@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	je	SHORT $LN19@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN18@calculate
$LN19@calculate:

; 2619 :             (opnd2->kind == EXPR_ADDR || opnd2->kind == EXPR_REG ) ) {
; 2620 :             DebugMsg(("calculate(%s): incompatible usage of (simple) type\n", oper->string_ptr ));

	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12091
	call	DoDebugMsg

; 2621 :             return( fnEmitErr( SYNTAX_ERROR_IN_EXPRESSION ) );

	mov	ecx, 263				; 00000107H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@calculate
$LN18@calculate:

; 2622 :         }
; 2623 : 
; 2624 :         /* v2.08: moved here from get_operand() */
; 2625 :         if ( opnd1->base_reg && opnd1->base_reg->tokval == T_ST )

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN20@calculate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+24]
	cmp	DWORD PTR [rax+16], 31
	jne	SHORT $LN20@calculate

; 2626 :             return( check_streg( opnd1, opnd2 ) );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	check_streg
	jmp	$LN1@calculate
$LN20@calculate:

; 2627 : 
; 2628 : #ifdef DEBUG_OUT
; 2629 :         if ( plus_op( opnd1, opnd2 ) == ERROR )

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	plus_op
	cmp	eax, -1
	jne	SHORT $LN21@calculate

; 2630 :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@calculate
$LN21@calculate:

; 2631 :         break;

	jmp	$LN2@calculate
$LN22@calculate:

; 2632 : #else
; 2633 :         return( plus_op( opnd1, opnd2 ) );
; 2634 : #endif
; 2635 :     case T_OP_BRACKET:
; 2636 : 
; 2637 :         if ( opnd1->kind == EXPR_EMPTY ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], -2
	jne	SHORT $LN23@calculate

; 2638 :             DebugMsg1(("%u calculate(%s): single item\n", evallvl, oper->string_ptr ));

	mov	rax, QWORD PTR oper$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG12096
	call	DoDebugMsg1

; 2639 :             TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 2640 :             opnd1->type = opnd2->type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx

; 2641 :             break;

	jmp	$LN2@calculate
$LN23@calculate:

; 2642 :         }
; 2643 :         /* v2.03: make HJWasm reject syntax variants
; 2644 :          * "mov eax, DWORD (<label>)"
; 2645 :          */
; 2646 :         if ( opnd1->is_type == TRUE && opnd2->kind == EXPR_ADDR ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN24@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN24@calculate

; 2647 :             DebugMsg(("calculate(%s): incompatible usage of (simple) type\n", oper->string_ptr ));

	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12098
	call	DoDebugMsg

; 2648 :             return( fnEmitErr( SYNTAX_ERROR_IN_EXPRESSION ) );

	mov	ecx, 263				; 00000107H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@calculate
$LN24@calculate:

; 2649 :         }
; 2650 : 
; 2651 :         /* v2.08: moved here from get_operand() */
; 2652 :         if ( opnd1->base_reg && opnd1->base_reg->tokval == T_ST )

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN25@calculate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+24]
	cmp	DWORD PTR [rax+16], 31
	jne	SHORT $LN25@calculate

; 2653 :             return( check_streg( opnd1, opnd2 ) );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	check_streg
	jmp	$LN1@calculate
$LN25@calculate:

; 2654 : 
; 2655 :         DebugMsg1(("calculate(%s): calling plus_op()\n", oper->string_ptr ));

	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12100
	call	DoDebugMsg1

; 2656 : #ifdef DEBUG_OUT
; 2657 :         if ( plus_op( opnd1, opnd2 ) == ERROR )

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	plus_op
	cmp	eax, -1
	jne	SHORT $LN26@calculate

; 2658 :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@calculate
$LN26@calculate:

; 2659 :         break;

	jmp	$LN2@calculate
$LN27@calculate:

; 2660 : #else
; 2661 :         return( plus_op( opnd1, opnd2 ) );
; 2662 : #endif
; 2663 :     case '+':
; 2664 :         if ( oper->specval == UNARY_PLUSMINUS ) /* unary op? */

	mov	rax, QWORD PTR oper$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	test	eax, eax
	jne	SHORT $LN28@calculate

; 2665 :             return( positive_op( opnd1, opnd2 ) );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	positive_op
	jmp	$LN1@calculate
$LN28@calculate:

; 2666 : #ifdef DEBUG_OUT
; 2667 :         if ( plus_op( opnd1, opnd2 ) == ERROR )

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	plus_op
	cmp	eax, -1
	jne	SHORT $LN29@calculate

; 2668 :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@calculate
$LN29@calculate:

; 2669 :         break;

	jmp	$LN2@calculate
$LN30@calculate:

; 2670 : #else
; 2671 :         return( plus_op( opnd1, opnd2 ) );
; 2672 : #endif
; 2673 :     case '-':
; 2674 :         if ( oper->specval == UNARY_PLUSMINUS ) /* unary op? */

	mov	rax, QWORD PTR oper$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	test	eax, eax
	jne	SHORT $LN31@calculate

; 2675 :             return( negative_op( opnd1, opnd2 ) );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	negative_op
	jmp	$LN1@calculate
$LN31@calculate:

; 2676 : #ifdef DEBUG_OUT
; 2677 :         if ( minus_op( opnd1, opnd2 ) == ERROR )

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	minus_op
	cmp	eax, -1
	jne	SHORT $LN32@calculate

; 2678 :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@calculate
$LN32@calculate:

; 2679 :         break;

	jmp	$LN2@calculate
$LN33@calculate:

; 2680 : #else
; 2681 :         return( minus_op( opnd1, opnd2 ) );
; 2682 : #endif
; 2683 :     case T_DOT:
; 2684 : #ifdef DEBUG_OUT
; 2685 :         if ( dot_op( opnd1, opnd2 ) == ERROR )

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	dot_op
	cmp	eax, -1
	jne	SHORT $LN34@calculate

; 2686 :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@calculate
$LN34@calculate:

; 2687 :         break;

	jmp	$LN2@calculate
$LN35@calculate:

; 2688 : #else
; 2689 :         return( dot_op( opnd1, opnd2 ) );
; 2690 : #endif
; 2691 :     case T_COLON:
; 2692 : #ifdef DEBUG_OUT
; 2693 :         if ( colon_op( opnd1, opnd2 ) == ERROR )

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	colon_op
	cmp	eax, -1
	jne	SHORT $LN36@calculate

; 2694 :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@calculate
$LN36@calculate:

; 2695 :         break;

	jmp	$LN2@calculate
$LN37@calculate:

; 2696 : #else
; 2697 :         return( colon_op( opnd1, opnd2 ) );
; 2698 : #endif
; 2699 :     case '*':
; 2700 :         /*
; 2701 :          * The only formats allowed are:
; 2702 :          *        constant * constant
; 2703 :          *        register * scaling factor ( 1, 2, 4 or 8 )
; 2704 :          *                   386 only
; 2705 :          */
; 2706 :         DebugMsg1(("calculate(*): kind=%d/%d value=%" I64_SPEC "d-%" I64_SPEC "d mbr=%X-%X\n",

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	r9, QWORD PTR [rax]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+60]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax+60]
	lea	rcx, OFFSET FLAT:$SG12113
	call	DoDebugMsg1

; 2707 :                    opnd1->kind,    opnd2->kind,
; 2708 :                    opnd1->value64, opnd2->value64,
; 2709 :                    opnd1->mbr,     opnd2->mbr ));
; 2710 : 
; 2711 :         MakeConst( opnd1 );

	mov	rcx, QWORD PTR opnd1$[rsp]
	call	MakeConst

; 2712 :         MakeConst( opnd2 );

	mov	rcx, QWORD PTR opnd2$[rsp]
	call	MakeConst

; 2713 : 
; 2714 :         if( check_same( opnd1, opnd2, EXPR_CONST ) ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN38@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN38@calculate

; 2715 :             opnd1->llvalue *= opnd2->llvalue;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax]
	imul	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	$LN39@calculate
$LN38@calculate:

; 2716 :         } else if( check_both( opnd1, opnd2, EXPR_REG, EXPR_CONST ) ) {

	xor	r9d, r9d
	mov	r8d, 2
	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	check_both
	movzx	eax, al
	test	eax, eax
	je	$LN40@calculate

; 2717 :             if( check_direct_reg( opnd1, opnd2 ) == ERROR ) {

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	check_direct_reg
	cmp	eax, -1
	jne	SHORT $LN42@calculate

; 2718 :                 DebugMsg(("calculate(*) error direct register\n"));

	lea	rcx, OFFSET FLAT:$SG12119
	call	DoDebugMsg

; 2719 :                 return( fnEmitErr( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@calculate
$LN42@calculate:

; 2720 :             }
; 2721 :             /* scaling factor */
; 2722 :             if( opnd2->kind == EXPR_REG ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN43@calculate

; 2723 :                 /* scale * reg */
; 2724 :                 opnd1->idx_reg = opnd2->base_reg;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+32], rcx

; 2725 :                 opnd1->scale = opnd1->value;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax+68], cl

; 2726 :                 opnd1->value = 0;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax], 0

; 2727 :                 //opnd2->base_reg = NULL;
; 2728 :             } else {

	jmp	SHORT $LN44@calculate
$LN43@calculate:

; 2729 :                 /* reg * scale */
; 2730 :                 opnd1->idx_reg = opnd1->base_reg;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+32], rcx

; 2731 :                 opnd1->scale = opnd2->value;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax+68], cl
$LN44@calculate:

; 2732 :             }
; 2733 :             /* v2.08: check 0 (the default value) here */
; 2734 :             if ( opnd1->scale == 0 ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	movzx	eax, BYTE PTR [rax+68]
	test	eax, eax
	jne	SHORT $LN45@calculate

; 2735 :                 return( fnEmitErr( SCALE_FACTOR_MUST_BE_1_2_4_OR_8 ) );

	mov	ecx, 36					; 00000024H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@calculate
$LN45@calculate:

; 2736 :             }
; 2737 : 
; 2738 :             opnd1->base_reg = NULL;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rax+24], 0

; 2739 :             opnd1->indirect = TRUE;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 2740 :             opnd1->kind = EXPR_ADDR;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 1

; 2741 :         } else {

	jmp	SHORT $LN41@calculate
$LN40@calculate:

; 2742 :             DebugMsg(("calculate(*) error 2\n"));

	lea	rcx, OFFSET FLAT:$SG12123
	call	DoDebugMsg

; 2743 :             return( ConstError( opnd1, opnd2 ) );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	ConstError
	jmp	$LN1@calculate
$LN41@calculate:
$LN39@calculate:

; 2744 :         }
; 2745 :         break;

	jmp	$LN2@calculate
$LN46@calculate:

; 2746 :     case '/':
; 2747 :         /*
; 2748 :          * The only formats allowed are:
; 2749 :          *        constant / constant
; 2750 :          */
; 2751 :         DebugMsg1(("calculate(/): t1-t2 kind %u-%u values %" I64_SPEC "d-%" I64_SPEC "d\n",

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	r9, QWORD PTR [rax]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+60]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax+60]
	lea	rcx, OFFSET FLAT:$SG12125
	call	DoDebugMsg1

; 2752 :                    opnd1->kind,    opnd2->kind,
; 2753 :                    opnd1->value64, opnd2->value64 ));
; 2754 :         MakeConst( opnd1 );

	mov	rcx, QWORD PTR opnd1$[rsp]
	call	MakeConst

; 2755 :         MakeConst( opnd2 );

	mov	rcx, QWORD PTR opnd2$[rsp]
	call	MakeConst

; 2756 : 
; 2757 :         if( check_same( opnd1, opnd2, EXPR_CONST ) == FALSE ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN139@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN139@calculate
	mov	DWORD PTR tv322[rsp], 1
	jmp	SHORT $LN140@calculate
$LN139@calculate:
	mov	DWORD PTR tv322[rsp], 0
$LN140@calculate:
	cmp	DWORD PTR tv322[rsp], 0
	jne	SHORT $LN47@calculate

; 2758 :             DebugMsg(("calculate(/) error 1\n"));

	lea	rcx, OFFSET FLAT:$SG12127
	call	DoDebugMsg

; 2759 :             return( ConstError( opnd1, opnd2 ) );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	ConstError
	jmp	$LN1@calculate
$LN47@calculate:

; 2760 :         }
; 2761 : 
; 2762 :         if ( opnd2->llvalue == 0 ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN48@calculate

; 2763 :             DebugMsg(("calculate(/) error 2\n"));

	lea	rcx, OFFSET FLAT:$SG12129
	call	DoDebugMsg

; 2764 :             return( fnEmitErr( DIVIDE_BY_ZERO_IN_EXPR ) );

	mov	ecx, 167				; 000000a7H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@calculate
$LN48@calculate:

; 2765 :         }
; 2766 : 
; 2767 :         opnd1->value64 /= opnd2->value64;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	cdq
	mov	rcx, QWORD PTR opnd2$[rsp]
	idiv	QWORD PTR [rcx]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 2768 :         break;

	jmp	$LN2@calculate
$LN49@calculate:

; 2769 :     case T_BINARY_OPERATOR:
; 2770 :         DebugMsg1(("calculate(%s [T_BINARY_OPERATOR] ): t1-t2 kind %d/%d memtype %X-%X sym %s-%s type %s-%s\n",

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN141@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv341[rsp], rax
	jmp	SHORT $LN142@calculate
$LN141@calculate:
	lea	rax, OFFSET FLAT:$SG12131
	mov	QWORD PTR tv341[rsp], rax
$LN142@calculate:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN143@calculate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv347[rsp], rax
	jmp	SHORT $LN144@calculate
$LN143@calculate:
	lea	rax, OFFSET FLAT:$SG12132
	mov	QWORD PTR tv347[rsp], rax
$LN144@calculate:
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN145@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv353[rsp], rax
	jmp	SHORT $LN146@calculate
$LN145@calculate:
	lea	rax, OFFSET FLAT:$SG12133
	mov	QWORD PTR tv353[rsp], rax
$LN146@calculate:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN147@calculate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv359[rsp], rax
	jmp	SHORT $LN148@calculate
$LN147@calculate:
	lea	rax, OFFSET FLAT:$SG12134
	mov	QWORD PTR tv359[rsp], rax
$LN148@calculate:
	mov	rax, QWORD PTR tv341[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	rax, QWORD PTR tv347[rsp]
	mov	QWORD PTR [rsp+64], rax
	mov	rax, QWORD PTR tv353[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR tv359[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r9d, DWORD PTR [rax+60]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	r8d, DWORD PTR [rax+60]
	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12135
	call	DoDebugMsg1

; 2771 :                    oper->string_ptr,
; 2772 :                    opnd1->kind, opnd2->kind,
; 2773 :                    opnd1->mem_type, opnd2->mem_type,
; 2774 :                    opnd1->sym  ? opnd1->sym->name  : "NULL",
; 2775 :                    opnd2->sym  ? opnd2->sym->name  : "NULL",
; 2776 :                    opnd1->type ? opnd1->type->name : "NULL",
; 2777 :                    opnd2->type ? opnd2->type->name : "NULL" ));
; 2778 : 
; 2779 :         if ( oper->tokval == T_PTR ) {

	mov	rax, QWORD PTR oper$[rsp]
	cmp	DWORD PTR [rax+16], 258			; 00000102H
	jne	$LN50@calculate

; 2780 :             if ( opnd1->is_type == FALSE ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	$LN51@calculate

; 2781 :                 if ( opnd1->sym && opnd1->sym->state == SYM_UNDEFINED ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN52@calculate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN52@calculate

; 2782 :                     CreateTypeSymbol( opnd1->sym, NULL, TRUE );

	mov	r8b, 1
	xor	edx, edx
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	CreateTypeSymbol

; 2783 :                     opnd1->type = opnd1->sym;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [rax+96], rcx

; 2784 :                     opnd1->sym = NULL;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rax+80], 0

; 2785 :                     opnd1->is_type = TRUE;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 8
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 2786 :                 } else {

	jmp	SHORT $LN53@calculate
$LN52@calculate:

; 2787 :                     DebugMsg(("calculate(PTR), error 1: t1 is_type == FALSE\n"));

	lea	rcx, OFFSET FLAT:$SG12140
	call	DoDebugMsg

; 2788 :                     return( fnEmitErr( INVALID_TYPE_EXPRESSION ) );

	mov	ecx, 179				; 000000b3H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@calculate
$LN53@calculate:
$LN51@calculate:

; 2789 :                 }
; 2790 :             }
; 2791 :             opnd2->explicit = TRUE;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 2
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 2792 :             /* v2.02: if operand is a register, make sure
; 2793 :              * that invalid combinations ("DWORD PTR AX") are flagged.
; 2794 :              *
; 2795 :              * v2.10: must also be checked inside []. However, it's
; 2796 :              * a problem to properly handle this case, since opnd->indirect
; 2797 :              * is just a flag.
; 2798 :              * Curr. hackish fix: to query state of assumecheck if indirect==TRUE.
; 2799 :              * Proposed "good" fix: change EXPR_REG to EXPR_ADDR in
; 2800 :              * CheckAssume(), that is, when the terminating  ']' was found.
; 2801 :              */
; 2802 :             //if ( opnd2->kind == EXPR_REG && opnd2->indirect == FALSE ) {
; 2803 :             if ( opnd2->kind == EXPR_REG && ( opnd2->indirect == FALSE || opnd2->assumecheck == TRUE ) ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	$LN54@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN56@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 6
	and	eax, 1
	cmp	eax, 1
	jne	$LN54@calculate
$LN56@calculate:

; 2804 :                 temp = opnd2->base_reg->tokval;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR temp$[rsp], eax

; 2805 :                 /* for segment registers, both size 2 and 4 is ok.*/
; 2806 :                 if ( GetValueSp( temp ) & OP_SR ) {

	movsxd	rax, DWORD PTR temp$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 24576				; 00006000H
	test	eax, eax
	je	SHORT $LN57@calculate

; 2807 :                     if ( opnd1->value != 2 && opnd1->value != 4 ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax], 2
	je	SHORT $LN59@calculate
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax], 4
	je	SHORT $LN59@calculate

; 2808 :                         DebugMsg(("calculate(PTR): segment register size (=2/4) doesn't match type size (=%u)\n", opnd1->value ));

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG12147
	call	DoDebugMsg

; 2809 :                         return( fnEmitErr( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@calculate
$LN59@calculate:

; 2810 :                     }

	jmp	SHORT $LN58@calculate
$LN57@calculate:

; 2811 :                 } else if ( opnd1->value != SizeFromRegister( temp ) ) {

	mov	ecx, DWORD PTR temp$[rsp]
	call	SizeFromRegister
	mov	rcx, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rcx], eax
	je	SHORT $LN60@calculate

; 2812 :                     DebugMsg(("calculate(PTR): register size doesn't match type size; %u != %u\n", SizeFromRegister( temp ), opnd1->value ));

	mov	ecx, DWORD PTR temp$[rsp]
	call	SizeFromRegister
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	r8d, DWORD PTR [rcx]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12149
	call	DoDebugMsg

; 2813 :                     return( fnEmitErr( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@calculate
$LN60@calculate:
$LN58@calculate:

; 2814 :                 }

	jmp	SHORT $LN55@calculate
$LN54@calculate:

; 2815 :             } else if ( opnd2->kind == EXPR_FLOAT ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 3
	jne	SHORT $LN61@calculate

; 2816 :                 if ( !( opnd1->mem_type & MT_FLOAT ) ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+64]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN62@calculate

; 2817 :                     DebugMsg(("calculate(PTR): type memtype=%Xh ( MT_FLOAT not set, although right op is FLOAT )\n", opnd1->mem_type ));

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax+64]
	lea	rcx, OFFSET FLAT:$SG12152
	call	DoDebugMsg

; 2818 :                     return( fnEmitErr( REAL_OR_BCD_NUMBER_NOT_ALLOWED ) );

	mov	ecx, 270				; 0000010eH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@calculate
$LN62@calculate:
$LN61@calculate:
$LN55@calculate:

; 2819 :                 }
; 2820 :             }
; 2821 :             opnd2->mem_type = opnd1->mem_type;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+64], ecx

; 2822 :             opnd2->Ofssize  = opnd1->Ofssize;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	movzx	ecx, BYTE PTR [rcx+69]
	mov	BYTE PTR [rax+69], cl

; 2823 :             /* v2.04: added */
; 2824 :             if ( opnd2->is_type )

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN63@calculate

; 2825 :                 opnd2->value  = opnd1->value;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax], ecx
$LN63@calculate:

; 2826 : 
; 2827 :             /* todo: describe which case is handled here. How is the left
; 2828 :              * operand of PTR supposed to get an override? And why is
; 2829 :              * it necessary to change kind to EXPR_ADDR here? */
; 2830 :             if ( opnd1->override != NULL ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN64@calculate

; 2831 :                 if ( opnd2->override == NULL )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+48], 0
	jne	SHORT $LN65@calculate

; 2832 :                     opnd2->override = opnd1->override;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	QWORD PTR [rax+48], rcx
$LN65@calculate:

; 2833 :                 opnd2->kind = EXPR_ADDR;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rax+60], 1
$LN64@calculate:

; 2834 :             }
; 2835 :             //if ( opnd1->mbr )
; 2836 :             //    opnd2->mbr = opnd1->mbr;
; 2837 :             //if ( opnd1->sym )
; 2838 :             //    opnd2->sym = opnd1->sym;
; 2839 :             //opnd2->instr = opnd1->instr;
; 2840 : 
; 2841 :             /* note: member type isn't copied, IOW: value of opnd1->type is kept. */
; 2842 :             TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 2843 :             break;

	jmp	$LN2@calculate
$LN50@calculate:

; 2844 :         }
; 2845 : 
; 2846 :         MakeConst( opnd1 );

	mov	rcx, QWORD PTR opnd1$[rsp]
	call	MakeConst

; 2847 :         MakeConst( opnd2 );

	mov	rcx, QWORD PTR opnd2$[rsp]
	call	MakeConst

; 2848 : 
; 2849 :         if ( check_same( opnd1, opnd2, EXPR_CONST ) )

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN66@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN66@calculate

; 2850 :             ;

	jmp	$LN67@calculate
$LN66@calculate:

; 2851 :         /* if it's EQ, NE, LE [, ...], operands may be either constants
; 2852 :          or relocatable labels */
; 2853 :         else if ( oper->precedence == CMP_PRECEDENCE &&

	mov	rax, QWORD PTR oper$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 10
	jne	$LN68@calculate
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 0
	je	$LN68@calculate

; 2854 :                  opnd1->kind != EXPR_CONST ) {
; 2855 :             if ( opnd1->kind == EXPR_ADDR && opnd1->indirect == FALSE && opnd1->sym )

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	$LN70@calculate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	$LN70@calculate
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	$LN70@calculate

; 2856 :                 if ( opnd2->kind == EXPR_ADDR && opnd2->indirect == FALSE && opnd2->sym ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN72@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN72@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN72@calculate

; 2857 :                     if ( MakeConst2( opnd1, opnd2 ) == ERROR ) {

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	MakeConst2
	cmp	eax, -1
	jne	SHORT $LN74@calculate

; 2858 :                         DebugMsg(("calculate(%s) error 1\n", oper->string_ptr ));

	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12165
	call	DoDebugMsg

; 2859 :                         return( ERROR );

	mov	eax, -1
	jmp	$LN1@calculate
$LN74@calculate:

; 2860 :                     }
; 2861 :                 } else {

	jmp	$LN73@calculate
$LN72@calculate:

; 2862 :                     DebugMsg(("calculate(%s) error 2, token2.kind=%d indirect=%u sym=%s\n",

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN149@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv502[rsp], rax
	jmp	SHORT $LN150@calculate
$LN149@calculate:
	lea	rax, OFFSET FLAT:$SG12166
	mov	QWORD PTR tv502[rsp], rax
$LN150@calculate:
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	mov	rcx, QWORD PTR tv502[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, eax
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+60]
	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12167
	call	DoDebugMsg

; 2863 :                               oper->string_ptr, opnd2->kind, opnd2->indirect,
; 2864 :                               opnd2->sym ? opnd2->sym->name : "NULL" ));
; 2865 :                     return( fnEmitErr( OPERAND_MUST_BE_RELOCATABLE ) );

	mov	ecx, 188				; 000000bcH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@calculate
$LN73@calculate:

; 2866 :                 }

	jmp	SHORT $LN71@calculate
$LN70@calculate:

; 2867 :             else {
; 2868 :                 DebugMsg(("calculate(%s) error 3\n", oper->string_ptr ));

	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12168
	call	DoDebugMsg

; 2869 :                 return( fnEmitErr( CONSTANT_OR_RELOCATABLE_LABEL_EXPECTED ) );

	mov	ecx, 189				; 000000bdH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@calculate
$LN71@calculate:

; 2870 :             }
; 2871 :         } else {

	jmp	SHORT $LN69@calculate
$LN68@calculate:

; 2872 :             DebugMsg(("calculate(%s) error 4\n", oper->string_ptr ));

	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12169
	call	DoDebugMsg

; 2873 :             return( ConstError( opnd1, opnd2 ) );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	ConstError
	jmp	$LN1@calculate
$LN69@calculate:
$LN67@calculate:

; 2874 :         }
; 2875 : 
; 2876 :         DebugMsg1(("calculate(%s): values=%" I64_SPEC "d/%" I64_SPEC "d is_type=%u/%u memtypes=%X/%X\n", oper->string_ptr,

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	shr	ecx, 3
	and	ecx, 1
	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	edx, DWORD PTR [rdx+64]
	mov	DWORD PTR [rsp+56], edx
	mov	rdx, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rdx+64]
	mov	DWORD PTR [rsp+48], edx
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], ecx
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r9, QWORD PTR [rax]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12170
	call	DoDebugMsg1

; 2877 :                    opnd1->value64, opnd2->value64, opnd1->is_type, opnd2->is_type, opnd1->mem_type, opnd2->mem_type  ));
; 2878 :         switch( oper->tokval ) {

	mov	rax, QWORD PTR oper$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv545[rsp], eax
	cmp	DWORD PTR tv545[rsp], 501		; 000001f5H
	ja	SHORT $LN163@calculate
	cmp	DWORD PTR tv545[rsp], 501		; 000001f5H
	je	$LN100@calculate
	mov	eax, DWORD PTR tv545[rsp]
	sub	eax, 251				; 000000fbH
	mov	DWORD PTR tv545[rsp], eax
	cmp	DWORD PTR tv545[rsp], 6
	ja	$LN4@calculate
	mov	eax, DWORD PTR tv545[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN178@calculate[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN163@calculate:
	cmp	DWORD PTR tv545[rsp], 504		; 000001f8H
	je	$LN99@calculate
	cmp	DWORD PTR tv545[rsp], 506		; 000001faH
	je	$LN101@calculate
	cmp	DWORD PTR tv545[rsp], 514		; 00000202H
	je	$LN88@calculate
	cmp	DWORD PTR tv545[rsp], 515		; 00000203H
	je	$LN94@calculate
	jmp	$LN4@calculate
$LN75@calculate:

; 2879 :         case T_EQ:
; 2880 : #if 1 /* v2.03: added */
; 2881 :             /* if both operands are types, do a more comprehensive comparison! */
; 2882 :             if ( opnd1->is_type && opnd2->is_type ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN76@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN76@calculate

; 2883 :                 cmp_types( opnd1, opnd2, -1 );

	mov	r8d, -1
	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	cmp_types

; 2884 :             } else

	jmp	SHORT $LN77@calculate
$LN76@calculate:

; 2885 : #endif
; 2886 :             opnd1->value64 = ( opnd1->value64 == opnd2->value64 ? -1:0 );

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN151@calculate
	mov	DWORD PTR tv561[rsp], -1
	jmp	SHORT $LN152@calculate
$LN151@calculate:
	mov	DWORD PTR tv561[rsp], 0
$LN152@calculate:
	movsxd	rax, DWORD PTR tv561[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax
$LN77@calculate:

; 2887 :             break;

	jmp	$LN4@calculate
$LN78@calculate:

; 2888 :         case T_NE:
; 2889 : #if 1 /* v2.03: added */
; 2890 :             /* if both operands are types, do a more comprehensive comparison! */
; 2891 :             if ( opnd1->is_type && opnd2->is_type ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN79@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN79@calculate

; 2892 :                 cmp_types( opnd1, opnd2, 0 );

	xor	r8d, r8d
	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	cmp_types

; 2893 :             } else

	jmp	SHORT $LN80@calculate
$LN79@calculate:

; 2894 : #endif
; 2895 :             opnd1->value64 = ( opnd1->value64 != opnd2->value64 ? -1:0 );

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN153@calculate
	mov	DWORD PTR tv578[rsp], -1
	jmp	SHORT $LN154@calculate
$LN153@calculate:
	mov	DWORD PTR tv578[rsp], 0
$LN154@calculate:
	movsxd	rax, DWORD PTR tv578[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax
$LN80@calculate:

; 2896 :             break;

	jmp	$LN4@calculate
$LN81@calculate:

; 2897 :         case T_LT:
; 2898 :             opnd1->value64 = ( opnd1->value64 <  opnd2->value64 ? -1:0 );

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jge	SHORT $LN155@calculate
	mov	DWORD PTR tv584[rsp], -1
	jmp	SHORT $LN156@calculate
$LN155@calculate:
	mov	DWORD PTR tv584[rsp], 0
$LN156@calculate:
	movsxd	rax, DWORD PTR tv584[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 2899 :             break;

	jmp	$LN4@calculate
$LN82@calculate:

; 2900 :         case T_LE:
; 2901 :             opnd1->value64 = ( opnd1->value64 <= opnd2->value64 ? -1:0 );

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jg	SHORT $LN157@calculate
	mov	DWORD PTR tv590[rsp], -1
	jmp	SHORT $LN158@calculate
$LN157@calculate:
	mov	DWORD PTR tv590[rsp], 0
$LN158@calculate:
	movsxd	rax, DWORD PTR tv590[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 2902 :             break;

	jmp	$LN4@calculate
$LN83@calculate:

; 2903 :         case T_GT:
; 2904 :             opnd1->value64 = ( opnd1->value64 >  opnd2->value64 ? -1:0 );

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jle	SHORT $LN159@calculate
	mov	DWORD PTR tv596[rsp], -1
	jmp	SHORT $LN160@calculate
$LN159@calculate:
	mov	DWORD PTR tv596[rsp], 0
$LN160@calculate:
	movsxd	rax, DWORD PTR tv596[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 2905 :             break;

	jmp	$LN4@calculate
$LN84@calculate:

; 2906 :         case T_GE:
; 2907 :             opnd1->value64 = ( opnd1->value64 >= opnd2->value64 ? -1:0 );

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jl	SHORT $LN161@calculate
	mov	DWORD PTR tv602[rsp], -1
	jmp	SHORT $LN162@calculate
$LN161@calculate:
	mov	DWORD PTR tv602[rsp], 0
$LN162@calculate:
	movsxd	rax, DWORD PTR tv602[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 2908 :             break;

	jmp	$LN4@calculate
$LN85@calculate:

; 2909 :         case T_MOD:
; 2910 :             if ( opnd2->llvalue == 0 ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN86@calculate

; 2911 :                 return( fnEmitErr( DIVIDE_BY_ZERO_IN_EXPR ) );

	mov	ecx, 167				; 000000a7H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@calculate

; 2912 :             } else

	jmp	SHORT $LN87@calculate
$LN86@calculate:

; 2913 :                 opnd1->llvalue %= opnd2->llvalue;

	xor	edx, edx
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR opnd2$[rsp]
	div	QWORD PTR [rcx]
	mov	rax, rdx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax
$LN87@calculate:

; 2914 :             break;

	jmp	$LN4@calculate
$LN88@calculate:

; 2915 :         case T_SHL:
; 2916 :             /* v2.04: check for shift count < 0 */
; 2917 :             DebugMsg1(("calculate(SHL): value=%" I64_SPEC "X << %" I32_SPEC "u (max=%u)\n", opnd1->llvalue, opnd2->value, 8 * sizeof( opnd1->llvalue ) ));

	mov	r9d, 64					; 00000040H
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG12185
	call	DoDebugMsg1

; 2918 :             if ( opnd2->value < 0 )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax], 0
	jge	SHORT $LN89@calculate

; 2919 :                 fnEmitErr( COUNT_MUST_BE_POSITIVE_OR_ZERO );

	mov	ecx, 208				; 000000d0H
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN90@calculate
$LN89@calculate:

; 2920 :             else if ( opnd2->value >= ( 8 * sizeof( opnd1->llvalue ) ) )

	mov	rax, QWORD PTR opnd2$[rsp]
	movsxd	rax, DWORD PTR [rax]
	cmp	rax, 64					; 00000040H
	jb	SHORT $LN91@calculate

; 2921 :                 opnd1->llvalue = 0;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rax], 0
	jmp	SHORT $LN92@calculate
$LN91@calculate:

; 2922 :             else
; 2923 :                 opnd1->llvalue = opnd1->llvalue << opnd2->value;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR tv1355[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv1355[rsp]
	mov	rax, QWORD PTR [rax]
	shl	rax, cl
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax
$LN92@calculate:
$LN90@calculate:

; 2924 :             /* v2.01: result is 64-bit only if mode is USE64 */
; 2925 :             /* v2.06: for -Zm only. This is not entirely correct,
; 2926 :              * since Masm v6x also does 32-bit shifts, but since v2.06
; 2927 :              * HJWasm intends to behave like Masm v8+.
; 2928 :              * Might be better to implement OPTION EXPR16|32|64.
; 2929 :              */
; 2930 :             //if ( ModuleInfo.Ofssize <= USE32 ) {
; 2931 :             if ( ModuleInfo.m510 ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 6
	and	eax, 1
	test	eax, eax
	je	SHORT $LN93@calculate

; 2932 :                 opnd1->hvalue = 0;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+4], 0

; 2933 :                 opnd1->hlvalue = 0;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rax+8], 0
$LN93@calculate:

; 2934 :             }
; 2935 :             break;

	jmp	$LN4@calculate
$LN94@calculate:

; 2936 :         case T_SHR:
; 2937 :             /* Masm v8 works with unsigned 64-bit,
; 2938 :              * Masm v6 masks shift count with 0x3F.
; 2939 :              * v2.04: does behave like Masm v8+.
; 2940 :              * there is a problem with some compilers if shift
; 2941 :              * count is >= 64. So in this case the result is zeroed manually
; 2942 :              */
; 2943 : #if 0
; 2944 :             if ( opnd1->hvalue == -1 ) {
; 2945 :                 opnd1->hvalue = 0;
; 2946 :                 opnd1->hlvalue = 0;
; 2947 :             }
; 2948 : #endif
; 2949 :             /* v2.04: check for shift count < 0 */
; 2950 :             if ( opnd2->value < 0 )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax], 0
	jge	SHORT $LN95@calculate

; 2951 :                 fnEmitErr( COUNT_MUST_BE_POSITIVE_OR_ZERO );

	mov	ecx, 208				; 000000d0H
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN96@calculate
$LN95@calculate:

; 2952 :             else if ( opnd2->value >= ( 8 * sizeof( opnd1->llvalue ) ) )

	mov	rax, QWORD PTR opnd2$[rsp]
	movsxd	rax, DWORD PTR [rax]
	cmp	rax, 64					; 00000040H
	jb	SHORT $LN97@calculate

; 2953 :                 opnd1->llvalue = 0;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rax], 0
	jmp	SHORT $LN98@calculate
$LN97@calculate:

; 2954 :             else
; 2955 :                 opnd1->llvalue = opnd1->llvalue >> opnd2->value;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR tv1367[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv1367[rsp]
	mov	rax, QWORD PTR [rax]
	shr	rax, cl
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax
$LN98@calculate:
$LN96@calculate:

; 2956 :             break;

	jmp	SHORT $LN4@calculate
$LN99@calculate:

; 2957 :         case T_AND:
; 2958 :             opnd1->llvalue &= opnd2->llvalue;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	and	rax, rcx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 2959 :             break;

	jmp	SHORT $LN4@calculate
$LN100@calculate:

; 2960 :         case T_OR:
; 2961 :             opnd1->llvalue |= opnd2->llvalue;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	or	rax, rcx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 2962 :             break;

	jmp	SHORT $LN4@calculate
$LN101@calculate:

; 2963 :         case T_XOR:
; 2964 :             opnd1->llvalue ^= opnd2->llvalue;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	xor	rax, rcx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax
$LN4@calculate:

; 2965 :             break;
; 2966 :         }
; 2967 :         break; /* end case T_BINARY_OPERATOR */

	jmp	$LN2@calculate
$LN102@calculate:

; 2968 :     case T_UNARY_OPERATOR:
; 2969 :         DebugMsg1(("calculate(%s [T_UNARY_OPERATOR]): opnd2 kind=%d sym=%s mbr=%s type=%s memtype=%X is_type=%u indirect=%u\n",

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN164@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv710[rsp], rax
	jmp	SHORT $LN165@calculate
$LN164@calculate:
	lea	rax, OFFSET FLAT:$SG12200
	mov	QWORD PTR tv710[rsp], rax
$LN165@calculate:
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN166@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv716[rsp], rax
	jmp	SHORT $LN167@calculate
$LN166@calculate:
	lea	rax, OFFSET FLAT:$SG12201
	mov	QWORD PTR tv716[rsp], rax
$LN167@calculate:
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN168@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv722[rsp], rax
	jmp	SHORT $LN169@calculate
$LN168@calculate:
	lea	rax, OFFSET FLAT:$SG12202
	mov	QWORD PTR tv722[rsp], rax
$LN169@calculate:
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	shr	ecx, 3
	and	ecx, 1
	mov	DWORD PTR [rsp+64], eax
	mov	DWORD PTR [rsp+56], ecx
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR tv710[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv716[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv722[rsp]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+60]
	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12203
	call	DoDebugMsg1

; 2970 :                    oper->string_ptr,
; 2971 :                    opnd2->kind,
; 2972 :                    opnd2->sym ? opnd2->sym->name : "NULL",
; 2973 :                    opnd2->mbr ? opnd2->mbr->name : "NULL",
; 2974 :                    opnd2->type ? opnd2->type->name : "NULL",
; 2975 :                    opnd2->mem_type, opnd2->is_type, opnd2->indirect ));
; 2976 :         /* NOT is an instruction and hence has no valid
; 2977 :          * value to be returned by GetValueSp() or GetSflagsSp()!
; 2978 :          */
; 2979 :         if( oper->tokval == T_NOT ) {

	mov	rax, QWORD PTR oper$[rsp]
	cmp	DWORD PTR [rax+16], 576			; 00000240H
	jne	SHORT $LN103@calculate

; 2980 :             MakeConst( opnd2 );

	mov	rcx, QWORD PTR opnd2$[rsp]
	call	MakeConst

; 2981 :             if( opnd2->kind != EXPR_CONST ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	je	SHORT $LN104@calculate

; 2982 :                 DebugMsg(("calculate(%s) error 1\n", oper->string_ptr ));

	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12206
	call	DoDebugMsg

; 2983 :                 return( fnEmitErr( CONSTANT_OPERAND_EXPECTED ) );

	mov	ecx, 66					; 00000042H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@calculate
$LN104@calculate:

; 2984 :             }
; 2985 :             TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 2986 :             opnd1->llvalue = ~(opnd2->llvalue);

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax]
	not	rax
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 2987 :             break;

	jmp	$LN2@calculate
$LN103@calculate:

; 2988 :         }
; 2989 : 
; 2990 :         /* operator         accepts
; 2991 :          ----------------------------------------------
; 2992 :          SIZEOF/SIZE        label, type, struct field
; 2993 :          LENGTHOF/LENGTH    label, struct field
; 2994 :          TYPE               label, type, struct field, register, number
; 2995 :          LOW                constant, label (OMF+BIN only)
; 2996 :          HIGH               constant, label (OMF+BIN only)
; 2997 :          LOWWORD            constant, label
; 2998 :          HIGHWORD           constant
; 2999 :          LOW32              constant, label, float
; 3000 :          HIGH32             constant, float
; 3001 :          THIS               type
; 3002 :          OPATTR/.TYPE       label, type, struct field, register, number
; 3003 :          SHORT              label
; 3004 :          SEG                label
; 3005 :          OFFSET/LROFFSET    label, struct field, number
; 3006 :          IMAGEREL           label
; 3007 :          SECTIONREL         label
; 3008 :          WIDTH/MASK         bitfields or RECORD type
; 3009 :          */
; 3010 : 
; 3011 :         temp = GetValueSp( oper->tokval );

	mov	rax, QWORD PTR oper$[rsp]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR temp$[rsp], eax

; 3012 : 
; 3013 :         sym = opnd2->sym;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym$[rsp], rax

; 3014 :         if( opnd2->mbr != NULL )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN105@calculate

; 3015 :             sym = opnd2->mbr;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR sym$[rsp], rax
$LN105@calculate:

; 3016 : 
; 3017 :         /* for error displays, get the position of the operand that
; 3018 :          * caused the trouble.
; 3019 :          */
; 3020 :         if ( opnd2->instr != EMPTY )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+56], -2
	je	SHORT $LN106@calculate

; 3021 :             name = oper->tokpos + strlen( oper->string_ptr ) + 1;

	mov	rax, QWORD PTR oper$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	strlen
	mov	rcx, QWORD PTR oper$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR name$[rsp], rax
	jmp	SHORT $LN107@calculate
$LN106@calculate:

; 3022 :         else if ( sym )

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN108@calculate

; 3023 :             name = sym->name;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR name$[rsp], rax
	jmp	SHORT $LN109@calculate
$LN108@calculate:

; 3024 :         else if ( opnd2->base_reg != NULL && opnd2->indirect == FALSE )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN110@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN110@calculate

; 3025 :             name = opnd2->base_reg->string_ptr;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR name$[rsp], rax
	jmp	SHORT $LN111@calculate
$LN110@calculate:

; 3026 :         else
; 3027 :             name = oper->tokpos + strlen( oper->string_ptr ) + 1;

	mov	rax, QWORD PTR oper$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	strlen
	mov	rcx, QWORD PTR oper$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR name$[rsp], rax
$LN111@calculate:
$LN109@calculate:
$LN107@calculate:

; 3028 : 
; 3029 :         switch ( opnd2->kind ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+60]
	mov	DWORD PTR tv777[rsp], eax
	cmp	DWORD PTR tv777[rsp], 0
	je	SHORT $LN112@calculate
	cmp	DWORD PTR tv777[rsp], 1
	je	$LN123@calculate
	cmp	DWORD PTR tv777[rsp], 2
	je	$LN128@calculate
	cmp	DWORD PTR tv777[rsp], 3
	je	$LN130@calculate
	jmp	$LN6@calculate
$LN112@calculate:

; 3030 :         case EXPR_CONST:
; 3031 :             /* v2.05: conditions "struct-field" and "istype" exchanged */
; 3032 :             /* is item a struct field? */
; 3033 :             /* v2.10: fixme: EXPR_CONST & mbr!=NULL - what's that supposed to be? */
; 3034 :             if ( opnd2->mbr != NULL && opnd2->mbr->state != SYM_TYPE ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	$LN113@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+88]
	cmp	DWORD PTR [rax+32], 7
	je	SHORT $LN113@calculate

; 3035 :                 if ( opnd2->mbr->mem_type == MT_BITS ) { /* bitfield? */

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+88]
	cmp	DWORD PTR [rax+36], 193			; 000000c1H
	jne	SHORT $LN115@calculate

; 3036 :                     if ( ( temp & AT_BF ) == 0 ) {

	mov	eax, DWORD PTR temp$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	SHORT $LN117@calculate

; 3037 :                         return( invalid_operand( opnd2, oper->string_ptr, name ) );

	mov	r8, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR opnd2$[rsp]
	call	invalid_operand
	jmp	$LN1@calculate
$LN117@calculate:

; 3038 :                     }
; 3039 :                 } else {

	jmp	SHORT $LN116@calculate
$LN115@calculate:

; 3040 :                     if ( ( temp & AT_FIELD ) == 0 ) {

	mov	eax, DWORD PTR temp$[rsp]
	and	eax, 16
	test	eax, eax
	jne	SHORT $LN118@calculate

; 3041 :                         return( invalid_operand( opnd2, oper->string_ptr, name ) );

	mov	r8, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR opnd2$[rsp]
	call	invalid_operand
	jmp	$LN1@calculate
$LN118@calculate:
$LN116@calculate:

; 3042 :                     }
; 3043 :                 }

	jmp	SHORT $LN114@calculate
$LN113@calculate:

; 3044 :             } else if ( opnd2->is_type ) { /* is item a type? */

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN119@calculate

; 3045 :                 if ( ( temp & AT_TYPE ) == 0 ) {

	mov	eax, DWORD PTR temp$[rsp]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN121@calculate

; 3046 :                     return( invalid_operand( opnd2, oper->string_ptr, name ) );

	mov	r8, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR opnd2$[rsp]
	call	invalid_operand
	jmp	$LN1@calculate
$LN121@calculate:

; 3047 :                 }
; 3048 :             } else { /*  or is it a number? */

	jmp	SHORT $LN120@calculate
$LN119@calculate:

; 3049 :                 if ( ( temp & AT_NUM ) == 0 ) {

	mov	eax, DWORD PTR temp$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN122@calculate

; 3050 :                     return( invalid_operand( opnd2, oper->string_ptr, name ) );

	mov	r8, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR opnd2$[rsp]
	call	invalid_operand
	jmp	$LN1@calculate
$LN122@calculate:
$LN120@calculate:
$LN114@calculate:

; 3051 :                 }
; 3052 :             }
; 3053 :             break;

	jmp	$LN6@calculate
$LN123@calculate:

; 3054 :         case EXPR_ADDR:
; 3055 :             /* an indirect memory operand? (not an auto variable) */
; 3056 :             if ( opnd2->indirect == TRUE && opnd2->sym == NULL ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN124@calculate
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	jne	SHORT $LN124@calculate

; 3057 :                 if ( ( temp & AT_IND ) == 0 ) {

	mov	eax, DWORD PTR temp$[rsp]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN126@calculate

; 3058 :                     return( invalid_operand( opnd2, oper->string_ptr, name ) );

	mov	r8, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR opnd2$[rsp]
	call	invalid_operand
	jmp	$LN1@calculate
$LN126@calculate:

; 3059 :                 }
; 3060 :             } else {

	jmp	SHORT $LN125@calculate
$LN124@calculate:

; 3061 :                 if ( ( temp & AT_LABEL ) == 0 ) {

	mov	eax, DWORD PTR temp$[rsp]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN127@calculate

; 3062 :                     return( invalid_operand( opnd2, oper->string_ptr, name ) );

	mov	r8, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR opnd2$[rsp]
	call	invalid_operand
	jmp	$LN1@calculate
$LN127@calculate:
$LN125@calculate:

; 3063 :                 }
; 3064 :             }
; 3065 : #if 0 /* v2.08: this if() obsolete? */
; 3066 :             if( opnd2->instr != EMPTY ) {
; 3067 :                 /* if instr is set, it's not a full address */
; 3068 :                 switch ( oper->tokval ) {
; 3069 :                 case T_LOW:
; 3070 :                 case T_HIGH:
; 3071 :                 case T_LOWWORD:
; 3072 :                 case T_HIGHWORD:
; 3073 : #if LOHI32
; 3074 :                 case T_LOW32:
; 3075 :                 case T_HIGH32:
; 3076 : #endif
; 3077 :                 case T_TYPE:
; 3078 :                 case T_OPATTR:
; 3079 :                 case T_DOT_TYPE:
; 3080 :                 case T_OFFSET: /* v2.08: added, to allow OFFSET OFFSET <addr> */
; 3081 :                     break;
; 3082 :                 default:
; 3083 :                     /* remaining: OFFSET, LROFFSET, IMAGEREL, SECTIONREL, SEG,
; 3084 :                      * SHORT
; 3085 :                      * THIS (won't set opnd.instr)
; 3086 :                      * (SIZE, SIZEOF, LENGTH, LENGHTOF, MASK, WIDTH) -> EXPR_CONST
; 3087 :                      *
; 3088 :                      */
; 3089 :                     DebugMsg(("calculate %s error 2\n", oper->string_ptr ));
; 3090 :                     return( fnEmitErr( LABEL_EXPECTED ) );
; 3091 :                 }
; 3092 :             }
; 3093 : #endif
; 3094 :             break;

	jmp	SHORT $LN6@calculate
$LN128@calculate:

; 3095 :         case EXPR_REG:
; 3096 :             if ( ( temp & AT_REG ) == 0 ) {

	mov	eax, DWORD PTR temp$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN129@calculate

; 3097 :                 return( invalid_operand( opnd2, oper->string_ptr, name ) );

	mov	r8, QWORD PTR name$[rsp]
	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR opnd2$[rsp]
	call	invalid_operand
	jmp	$LN1@calculate
$LN129@calculate:

; 3098 :             }
; 3099 :             break;

	jmp	SHORT $LN6@calculate
$LN130@calculate:

; 3100 :         case EXPR_FLOAT: /* v2.05: added */
; 3101 :             if ( ( temp & AT_FLOAT ) == 0 ) {

	mov	eax, DWORD PTR temp$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	jne	SHORT $LN131@calculate

; 3102 :                 DebugMsg(("calculate %s 'float' error\n", oper->string_ptr ));

	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12234
	call	DoDebugMsg

; 3103 :                 return( fnEmitErr( REAL_OR_BCD_NUMBER_NOT_ALLOWED ) );

	mov	ecx, 270				; 0000010eH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@calculate
$LN131@calculate:
$LN6@calculate:

; 3104 :             }
; 3105 :             break;
; 3106 :         }
; 3107 : #ifdef DEBUG_OUT
; 3108 :         if ( unaryop[ GetSflagsSp( oper->tokval ) ]( oper->tokval, opnd1, opnd2, sym, name ) == ERROR )

	mov	rax, QWORD PTR oper$[rsp]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax+4]
	lea	rcx, OFFSET FLAT:unaryop
	mov	QWORD PTR tv960[rsp], rcx
	mov	rdx, QWORD PTR name$[rsp]
	mov	QWORD PTR [rsp+32], rdx
	mov	r9, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR opnd2$[rsp]
	mov	rdx, QWORD PTR opnd1$[rsp]
	mov	r10, QWORD PTR oper$[rsp]
	mov	ecx, DWORD PTR [r10+16]
	mov	r10, QWORD PTR tv960[rsp]
	call	QWORD PTR [r10+rax*8]
	cmp	eax, -1
	jne	SHORT $LN132@calculate

; 3109 :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@calculate
$LN132@calculate:

; 3110 :         break;

	jmp	SHORT $LN2@calculate
$LN133@calculate:

; 3111 : #else
; 3112 :         return( unaryop[ GetSflagsSp( oper->tokval ) ]( oper->tokval, opnd1, opnd2, sym, name ) );
; 3113 : #endif
; 3114 :     //case T_RES_ID:
; 3115 :     default: /* shouldn't happen */
; 3116 :         DebugMsg(("calculate(%s): unknown operator\n", oper->string_ptr ));

	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12237
	call	DoDebugMsg

; 3117 :         return( fnEmitErr( SYNTAX_ERROR_EX, oper->string_ptr ) );

	mov	rax, QWORD PTR oper$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 209				; 000000d1H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@calculate
$LN2@calculate:

; 3118 :     } /* end switch( oper->token ) */
; 3119 : 
; 3120 : #ifdef DEBUG_OUT
; 3121 :     if ( opnd1->hlvalue ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	$LN134@calculate

; 3122 :         DebugMsg1(("%u calculate(%s) exit, ok kind=%d value=0x%" I64_SPEC "X_%016" I64_SPEC "X memtype=0x%X indirect=%u type=>%s<\n",

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN170@calculate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv886[rsp], rax
	jmp	SHORT $LN171@calculate
$LN170@calculate:
	lea	rax, OFFSET FLAT:$SG12240
	mov	QWORD PTR tv886[rsp], rax
$LN171@calculate:
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	mov	rcx, QWORD PTR tv886[rsp]
	mov	QWORD PTR [rsp+64], rcx
	mov	DWORD PTR [rsp+56], eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	r9d, DWORD PTR [rax+60]
	mov	rax, QWORD PTR oper$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG12241
	call	DoDebugMsg1
	jmp	$LN135@calculate
$LN134@calculate:

; 3123 :                    evallvl,
; 3124 :                    oper->string_ptr,
; 3125 :                    opnd1->kind,
; 3126 :                    opnd1->hlvalue, opnd1->llvalue,
; 3127 :                    opnd1->mem_type,
; 3128 :                    opnd1->indirect, opnd1->type ? opnd1->type->name : "NULL" ));
; 3129 :     } else if ( opnd1->hvalue ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	$LN136@calculate

; 3130 :         DebugMsg1(("%u calculate(%s) exit, ok kind=%d value=%" I64_SPEC"d(0x%" I64_SPEC "X) memtype=0x%X indirect=%u type=>%s<\n",

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN172@calculate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv909[rsp], rax
	jmp	SHORT $LN173@calculate
$LN172@calculate:
	lea	rax, OFFSET FLAT:$SG12244
	mov	QWORD PTR tv909[rsp], rax
$LN173@calculate:
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	mov	rcx, QWORD PTR tv909[rsp]
	mov	QWORD PTR [rsp+64], rcx
	mov	DWORD PTR [rsp+56], eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	r9d, DWORD PTR [rax+60]
	mov	rax, QWORD PTR oper$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG12245
	call	DoDebugMsg1

; 3131 :                    evallvl,
; 3132 :                    oper->string_ptr,
; 3133 :                    opnd1->kind,
; 3134 :                    opnd1->llvalue, opnd1->llvalue,
; 3135 :                    opnd1->mem_type,
; 3136 :                    opnd1->indirect, opnd1->type ? opnd1->type->name : "NULL" ));
; 3137 :     } else {

	jmp	$LN137@calculate
$LN136@calculate:

; 3138 :         DebugMsg1(("%u calculate(%s) exit, ok kind=%d value=%d(0x%X) memtype=0x%X ind=%u exp=%u type=%s mbr=%s\n",

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN174@calculate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv930[rsp], rax
	jmp	SHORT $LN175@calculate
$LN174@calculate:
	lea	rax, OFFSET FLAT:$SG12246
	mov	QWORD PTR tv930[rsp], rax
$LN175@calculate:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN176@calculate
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv936[rsp], rax
	jmp	SHORT $LN177@calculate
$LN176@calculate:
	lea	rax, OFFSET FLAT:$SG12247
	mov	QWORD PTR tv936[rsp], rax
$LN177@calculate:
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, 1
	mov	rdx, QWORD PTR tv930[rsp]
	mov	QWORD PTR [rsp+80], rdx
	mov	rdx, QWORD PTR tv936[rsp]
	mov	QWORD PTR [rsp+72], rdx
	mov	DWORD PTR [rsp+64], eax
	mov	DWORD PTR [rsp+56], ecx
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	r9d, DWORD PTR [rax+60]
	mov	rax, QWORD PTR oper$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG12248
	call	DoDebugMsg1
$LN137@calculate:
$LN135@calculate:

; 3139 :                    evallvl,
; 3140 :                    oper->string_ptr,
; 3141 :                    opnd1->kind,
; 3142 :                    opnd1->value, opnd1->value,
; 3143 :                    opnd1->mem_type,
; 3144 :                    opnd1->indirect, opnd1->explicit,
; 3145 :                    opnd1->type ? opnd1->type->name : "NULL",
; 3146 :                    opnd1->mbr ? opnd1->mbr->name : "NULL" ));
; 3147 :     }
; 3148 : #endif
; 3149 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@calculate:

; 3150 : }

	add	rsp, 288				; 00000120H
	pop	rdi
	ret	0
	npad	3
$LN180@calculate:
	DD	$LN102@calculate
	DD	$LN49@calculate
	DD	$LN22@calculate
	DD	$LN37@calculate
	DD	$LN27@calculate
	DD	$LN30@calculate
	DD	$LN33@calculate
	DD	$LN46@calculate
	DD	$LN35@calculate
	DD	$LN13@calculate
	DD	$LN133@calculate
$LN179@calculate:
	DB	0
	DB	1
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	2
	DB	10
	DB	3
	DB	4
	DB	10
	DB	5
	DB	6
	DB	7
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	8
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	9
$LN178@calculate:
	DD	$LN75@calculate
	DD	$LN78@calculate
	DD	$LN84@calculate
	DD	$LN83@calculate
	DD	$LN82@calculate
	DD	$LN81@calculate
	DD	$LN85@calculate
calculate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
type1$ = 64
type2$ = 72
tv79 = 80
tv87 = 88
tv95 = 96
tv143 = 104
tv159 = 108
tv201 = 112
opnd1$ = 144
opnd2$ = 152
trueval$ = 160
cmp_types PROC

; 2505 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rdi, rsp
	mov	ecx, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+144]

; 2506 :     struct asym *type1;
; 2507 :     struct asym *type2;
; 2508 : 
; 2509 :     /* v2.10: special handling of pointer types. */
; 2510 :     //if ( opnd1->mem_type == MT_PTR && opnd2->mem_type == MT_PTR && opnd1->type && opnd2->type ) {
; 2511 :     if ( opnd1->mem_type == MT_PTR && opnd2->mem_type == MT_PTR ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+64], 195			; 000000c3H
	jne	$LN2@cmp_types
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+64], 195			; 000000c3H
	jne	$LN2@cmp_types

; 2512 :         /**/myassert( ( opnd1->type || opnd1->type_tok ) && ( opnd2->type || opnd2->type_tok ) );

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	jne	SHORT $LN7@cmp_types
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN9@cmp_types
$LN7@cmp_types:
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	jne	SHORT $LN8@cmp_types
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN9@cmp_types
$LN8@cmp_types:
	mov	DWORD PTR tv79[rsp], 0
	jmp	SHORT $LN10@cmp_types
$LN9@cmp_types:
	mov	edx, 2512				; 000009d0H
	lea	rcx, OFFSET FLAT:$SG12043
	call	InternalError
	mov	DWORD PTR tv79[rsp], eax
$LN10@cmp_types:

; 2513 :         type1 = ( opnd1->type ? opnd1->type : SymSearch( opnd1->type_tok->string_ptr ) );

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN11@cmp_types
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR tv87[rsp], rax
	jmp	SHORT $LN12@cmp_types
$LN11@cmp_types:
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	rcx, QWORD PTR [rax+8]
	call	SymFind
	mov	QWORD PTR tv87[rsp], rax
$LN12@cmp_types:
	mov	rax, QWORD PTR tv87[rsp]
	mov	QWORD PTR type1$[rsp], rax

; 2514 :         type2 = ( opnd2->type ? opnd2->type : SymSearch( opnd2->type_tok->string_ptr ) );

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN13@cmp_types
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR tv95[rsp], rax
	jmp	SHORT $LN14@cmp_types
$LN13@cmp_types:
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	rcx, QWORD PTR [rax+8]
	call	SymFind
	mov	QWORD PTR tv95[rsp], rax
$LN14@cmp_types:
	mov	rax, QWORD PTR tv95[rsp]
	mov	QWORD PTR type2$[rsp], rax

; 2515 :         //opnd1->value64 = ( ( type1->is_ptr == type2->is_ptr &&
; 2516 :         opnd1->value64 = ( ( type1->is_ptr == type2->is_ptr &&

	mov	rax, QWORD PTR type1$[rsp]
	movzx	eax, BYTE PTR [rax+45]
	mov	rcx, QWORD PTR type2$[rsp]
	movzx	ecx, BYTE PTR [rcx+45]
	cmp	eax, ecx
	jne	SHORT $LN15@cmp_types
	mov	rax, QWORD PTR type1$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	mov	rcx, QWORD PTR type2$[rsp]
	movzx	ecx, BYTE PTR [rcx+46]
	cmp	eax, ecx
	jne	SHORT $LN15@cmp_types
	mov	rax, QWORD PTR type1$[rsp]
	mov	rcx, QWORD PTR type2$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	cmp	QWORD PTR [rax+48], rcx
	jne	SHORT $LN15@cmp_types
	mov	eax, DWORD PTR trueval$[rsp]
	mov	DWORD PTR tv143[rsp], eax
	jmp	SHORT $LN16@cmp_types
$LN15@cmp_types:
	mov	eax, DWORD PTR trueval$[rsp]
	not	eax
	mov	DWORD PTR tv143[rsp], eax
$LN16@cmp_types:
	movsxd	rax, DWORD PTR tv143[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 2517 :                             type1->ptr_memtype == type2->ptr_memtype &&
; 2518 :                             type1->target_type == type2->target_type ) ? trueval : ~trueval );
; 2519 :         DebugMsg1(("cmp_types: MT_PTR-MT_PTR is_ptr=%u-%u ptr_memtype=%X-%X target_type=%X-%X\n",

	mov	rax, QWORD PTR type2$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	mov	rcx, QWORD PTR type1$[rsp]
	movzx	ecx, BYTE PTR [rcx+46]
	mov	rdx, QWORD PTR type2$[rsp]
	movzx	edx, BYTE PTR [rdx+45]
	mov	r8, QWORD PTR type1$[rsp]
	movzx	r8d, BYTE PTR [r8+45]
	mov	DWORD PTR tv159[rsp], r8d
	mov	r9, QWORD PTR type2$[rsp]
	mov	r9, QWORD PTR [r9+48]
	mov	QWORD PTR [rsp+48], r9
	mov	r9, QWORD PTR type1$[rsp]
	mov	r9, QWORD PTR [r9+48]
	mov	QWORD PTR [rsp+40], r9
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, edx
	mov	eax, DWORD PTR tv159[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12044
	call	DoDebugMsg1

; 2520 :                    type1->is_ptr, type2->is_ptr,
; 2521 :                    type1->ptr_memtype, type2->ptr_memtype,
; 2522 :                    type1->target_type, type2->target_type ));
; 2523 :     } else {

	jmp	$LN3@cmp_types
$LN2@cmp_types:

; 2524 :         DebugMsg1(("cmp_types: memtype=%X-%X type=%X-%X\n",

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	r9, QWORD PTR [rax+96]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+64]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax+64]
	lea	rcx, OFFSET FLAT:$SG12045
	call	DoDebugMsg1

; 2525 :                    opnd1->mem_type, opnd2->mem_type, opnd1->type, opnd2->type ));
; 2526 :         /* v2.09: include type member in comparison, but ignore typedef types */
; 2527 :         if ( opnd1->type && opnd1->type->typekind == TYPE_TYPEDEF && opnd1->type->is_ptr == 0 )

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN4@cmp_types
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	jne	SHORT $LN4@cmp_types
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+45]
	test	eax, eax
	jne	SHORT $LN4@cmp_types

; 2528 :             opnd1->type = NULL;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rax+96], 0
$LN4@cmp_types:

; 2529 :         if ( opnd2->type && opnd2->type->typekind == TYPE_TYPEDEF && opnd2->type->is_ptr == 0 )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN5@cmp_types
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	jne	SHORT $LN5@cmp_types
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+45]
	test	eax, eax
	jne	SHORT $LN5@cmp_types

; 2530 :             opnd2->type = NULL;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	QWORD PTR [rax+96], 0
$LN5@cmp_types:

; 2531 :         opnd1->value64 = ( ( opnd1->mem_type == opnd2->mem_type &&

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	cmp	DWORD PTR [rax+64], ecx
	jne	SHORT $LN17@cmp_types
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	cmp	QWORD PTR [rax+96], rcx
	jne	SHORT $LN17@cmp_types
	mov	eax, DWORD PTR trueval$[rsp]
	mov	DWORD PTR tv201[rsp], eax
	jmp	SHORT $LN18@cmp_types
$LN17@cmp_types:
	mov	eax, DWORD PTR trueval$[rsp]
	not	eax
	mov	DWORD PTR tv201[rsp], eax
$LN18@cmp_types:
	movsxd	rax, DWORD PTR tv201[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax
$LN3@cmp_types:

; 2532 :                             opnd1->type == opnd2->type ) ? trueval : ~trueval );
; 2533 :     }
; 2534 : }

	add	rsp, 128				; 00000080H
	pop	rdi
	ret	0
cmp_types ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
opnd1$ = 48
opnd2$ = 56
check_streg PROC

; 2489 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 2490 :     if ( opnd1->scale > 0 ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	movzx	eax, BYTE PTR [rax+68]
	test	eax, eax
	jle	SHORT $LN2@check_stre

; 2491 :         return( fnEmitErr( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN1@check_stre
$LN2@check_stre:

; 2492 :     }
; 2493 :     opnd1->scale++; /* make sure there's only ONE bracket pair */

	mov	rax, QWORD PTR opnd1$[rsp]
	movzx	eax, BYTE PTR [rax+68]
	inc	al
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	BYTE PTR [rcx+68], al

; 2494 :     if ( opnd2->kind != EXPR_CONST ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	je	SHORT $LN3@check_stre

; 2495 :         return( fnEmitErr( INVALID_COPROCESSOR_REGISTER ) );

	mov	ecx, 252				; 000000fcH
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN1@check_stre
$LN3@check_stre:

; 2496 :     }
; 2497 :     opnd1->st_idx = opnd2->value;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax], ecx

; 2498 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@check_stre:

; 2499 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
check_streg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
sym$ = 80
tv143 = 88
tv149 = 96
tv162 = 104
tv168 = 112
tv178 = 120
tv137 = 124
tv152 = 128
opnd$ = 160
CheckAssume PROC

; 2427 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 144				; 00000090H
	mov	rdi, rsp
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+160]

; 2428 :     struct asym *sym = NULL;

	mov	QWORD PTR sym$[rsp], 0

; 2429 : 
; 2430 : #if 1 /* v2.10: see regression test ptr2.asm */
; 2431 :     if ( opnd->explicit ) { /* perhaps check mem_type instead of explicit */

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	$LN2@CheckAssum

; 2432 :         if ( opnd->type && opnd->type->mem_type == MT_PTR ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	$LN3@CheckAssum
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+36], 195			; 000000c3H
	jne	SHORT $LN3@CheckAssum

; 2433 :             DebugMsg1(( "CheckAssume(%s, MT_PTR type=>%s< )\n", opnd->type->name ));

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12005
	call	DoDebugMsg1

; 2434 :             if ( opnd->type->is_ptr == 1 ) { /* dereference only if indirection is 1 */

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+45]
	cmp	eax, 1
	jne	SHORT $LN4@CheckAssum

; 2435 :                 opnd->mem_type = opnd->type->ptr_memtype;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+46]
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx+64], eax

; 2436 :                 opnd->type = opnd->type->target_type;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR [rcx+96], rax

; 2437 :                 return; /* ignore assumes in this case */

	jmp	$LN1@CheckAssum
$LN4@CheckAssum:
$LN3@CheckAssum:
$LN2@CheckAssum:

; 2438 :             }
; 2439 :         }
; 2440 :     }
; 2441 : #endif
; 2442 :     /* in jwasm < v2.10, the idx_reg had higher priority than base_reg.
; 2443 :      * However, the base reg is supposed to have a higher priority.
; 2444 :      * This wasn't fully clear, because in Masm 6, if no register has
; 2445 :      * a scaling factor, the second one becomes base - something that
; 2446 :      * HJWasm didn't do, unless -Zg was set.
; 2447 :      * Since v2.10, HJWasm behaves like Masm v6+: base and index registers
; 2448 :      * are swapped, and assume for base has higher priority than assume for
; 2449 :      * index.
; 2450 :      */
; 2451 :     if ( opnd->base_reg ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN5@CheckAssum

; 2452 :         sym = GetStdAssumeEx( opnd->base_reg->bytval );

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+24]
	movzx	eax, BYTE PTR [rax+1]
	mov	ecx, eax
	call	GetStdAssumeEx
	mov	QWORD PTR sym$[rsp], rax
$LN5@CheckAssum:

; 2453 :     }
; 2454 :     if (!sym && opnd->idx_reg ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN6@CheckAssum
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+32], 0
	je	SHORT $LN6@CheckAssum

; 2455 :         sym = GetStdAssumeEx( opnd->idx_reg->bytval );

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+32]
	movzx	eax, BYTE PTR [rax+1]
	mov	ecx, eax
	call	GetStdAssumeEx
	mov	QWORD PTR sym$[rsp], rax
$LN6@CheckAssum:

; 2456 :     }
; 2457 :     if ( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN7@CheckAssum

; 2458 :         DebugMsg1(( "CheckAssume(%s, type=>%s<, mbr=>%s<): assume=%s [memtype=%X isptr=%u type=%s target_type=%s ptr_memt=%X]\n",

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN14@CheckAssum
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv143[rsp], rax
	jmp	SHORT $LN15@CheckAssum
$LN14@CheckAssum:
	lea	rax, OFFSET FLAT:$SG12010
	mov	QWORD PTR tv143[rsp], rax
$LN15@CheckAssum:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN16@CheckAssum
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv149[rsp], rax
	jmp	SHORT $LN17@CheckAssum
$LN16@CheckAssum:
	lea	rax, OFFSET FLAT:$SG12011
	mov	QWORD PTR tv149[rsp], rax
$LN17@CheckAssum:
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN18@CheckAssum
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv162[rsp], rax
	jmp	SHORT $LN19@CheckAssum
$LN18@CheckAssum:
	lea	rax, OFFSET FLAT:$SG12012
	mov	QWORD PTR tv162[rsp], rax
$LN19@CheckAssum:
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN20@CheckAssum
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv168[rsp], rax
	jmp	SHORT $LN21@CheckAssum
$LN20@CheckAssum:
	lea	rax, OFFSET FLAT:$SG12013
	mov	QWORD PTR tv168[rsp], rax
$LN21@CheckAssum:
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+32], 0
	je	SHORT $LN22@CheckAssum
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv178[rsp], eax
	jmp	SHORT $LN23@CheckAssum
$LN22@CheckAssum:
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv178[rsp], eax
$LN23@CheckAssum:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	mov	DWORD PTR tv137[rsp], eax
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+45]
	mov	DWORD PTR tv152[rsp], ecx
	xor	edx, edx
	mov	ecx, DWORD PTR tv178[rsp]
	call	GetResWName
	mov	ecx, DWORD PTR tv137[rsp]
	mov	DWORD PTR [rsp+72], ecx
	mov	rcx, QWORD PTR tv143[rsp]
	mov	QWORD PTR [rsp+64], rcx
	mov	rcx, QWORD PTR tv149[rsp]
	mov	QWORD PTR [rsp+56], rcx
	mov	ecx, DWORD PTR tv152[rsp]
	mov	DWORD PTR [rsp+48], ecx
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR tv162[rsp]
	mov	r8, QWORD PTR tv168[rsp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12014
	call	DoDebugMsg1

; 2459 :                    GetResWName( ( opnd->idx_reg ? opnd->idx_reg->tokval : opnd->base_reg->tokval ), NULL ),
; 2460 :                    opnd->type ? opnd->type->name : "NULL",
; 2461 :                    opnd->mbr ? opnd->mbr->name : "NULL",
; 2462 :                    sym->name, sym->mem_type, sym->is_ptr,
; 2463 :                    sym->type ? sym->type->name : "NULL",
; 2464 :                    sym->target_type ? sym->target_type->name : "NULL",
; 2465 :                    sym->ptr_memtype ));
; 2466 :         /* v2.08: skip ASSUMEd type if type or mbr is set */
; 2467 :         //if ( opnd->type || opnd->mbr )
; 2468 :         //    return;
; 2469 :         /* skip "alias" types */
; 2470 :         /* v2.05: obsolete */
; 2471 :         //for ( ; sym->type; sym = sym->type );
; 2472 :         /* v2.05: new */
; 2473 :         if ( sym->mem_type == MT_TYPE )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN8@CheckAssum

; 2474 :             opnd->type = sym->type;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [rax+96], rcx
	jmp	SHORT $LN9@CheckAssum
$LN8@CheckAssum:

; 2475 :         else if ( sym->is_ptr == 1 ) { /* v2.10: only dereference if indirection is 1 */

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+45]
	cmp	eax, 1
	jne	SHORT $LN10@CheckAssum

; 2476 :             opnd->type = sym->target_type;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	QWORD PTR [rax+96], rcx

; 2477 :             if ( sym->target_type )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN11@CheckAssum

; 2478 :                 opnd->mem_type = sym->target_type->mem_type;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rcx+64], eax
	jmp	SHORT $LN12@CheckAssum
$LN11@CheckAssum:

; 2479 :             else
; 2480 :                 opnd->mem_type = sym->ptr_memtype;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx+64], eax
$LN12@CheckAssum:
$LN10@CheckAssum:
$LN9@CheckAssum:
$LN7@CheckAssum:
$LN1@CheckAssum:

; 2481 :         }
; 2482 :     }
; 2483 : }

	add	rsp, 144				; 00000090H
	pop	rdi
	ret	0
CheckAssume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
opnd1$ = 48
opnd2$ = 56
negative_op PROC

; 2392 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 2393 :     DebugMsg1(("negative_op: value=%" I64_SPEC "X high=%" I64_SPEC "X\n", opnd2->llvalue, opnd2->hlvalue ));

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11989
	call	DoDebugMsg1

; 2394 :     /*
; 2395 :      * The formats allowed are:
; 2396 :      *        - constant
; 2397 :      *        - float
; 2398 :      */
; 2399 : 
; 2400 :     MakeConst( opnd2 );

	mov	rcx, QWORD PTR opnd2$[rsp]
	call	MakeConst

; 2401 :     if( opnd2->kind == EXPR_CONST ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN2@negative_o

; 2402 :         opnd1->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 0

; 2403 :         opnd1->llvalue = -opnd2->llvalue;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax]
	neg	rax
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 2404 :         /* v2.06: the unary '-' operator is to work with
; 2405 :          * magnitudes > 64-bit. Current implementation is
; 2406 :          * a bit hackish.
; 2407 :          */
; 2408 :         if ( opnd2->hlvalue )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN4@negative_o

; 2409 :             opnd1->hlvalue = -opnd2->hlvalue - 1;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+8]
	neg	rax
	dec	rax
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx+8], rax
$LN4@negative_o:

; 2410 :         opnd1->negative = 1 - opnd2->negative; /* ??? supposed to be used for EXPR_FLOAT only! */

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 5
	and	eax, 1
	mov	ecx, 1
	sub	ecx, eax
	mov	eax, ecx
	and	eax, 1
	shl	eax, 5
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, -33				; ffffffdfH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax
	jmp	$LN3@negative_o
$LN2@negative_o:

; 2411 :     } else if( opnd2->kind == EXPR_FLOAT ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 3
	jne	SHORT $LN5@negative_o

; 2412 :         opnd1->kind = EXPR_FLOAT;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 3

; 2413 :         opnd1->float_tok = opnd2->float_tok;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 2414 :         opnd1->negative = 1 - opnd2->negative;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 5
	and	eax, 1
	mov	ecx, 1
	sub	ecx, eax
	mov	eax, ecx
	and	eax, 1
	shl	eax, 5
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, -33				; ffffffdfH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 2415 :     } else {

	jmp	SHORT $LN6@negative_o
$LN5@negative_o:

; 2416 :         DebugMsg(("negative_op: unexpected opnd2.kind=%d\n", opnd2->kind ));

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	edx, DWORD PTR [rax+60]
	lea	rcx, OFFSET FLAT:$SG11995
	call	DoDebugMsg

; 2417 :         return( fnEmitErr( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN1@negative_o
$LN6@negative_o:
$LN3@negative_o:

; 2418 :     }
; 2419 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@negative_o:

; 2420 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
negative_op ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
opnd1$ = 48
opnd2$ = 56
positive_op PROC

; 2364 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 2365 :     DebugMsg1(("positive_op: value=%" I64_SPEC "X high=%" I64_SPEC "X\n", opnd2->llvalue, opnd2->hlvalue ));

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11977
	call	DoDebugMsg1

; 2366 :     /*
; 2367 :      * The formats allowed are:
; 2368 :      *        + constant
; 2369 :      *        + float
; 2370 :      * v2.06: unlike the other operators unary + will
; 2371 :      * handle 128-bit values (needed for TBYTE integers)
; 2372 :      */
; 2373 : 
; 2374 :     MakeConst( opnd2 );

	mov	rcx, QWORD PTR opnd2$[rsp]
	call	MakeConst

; 2375 :     if( opnd2->kind == EXPR_CONST ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN2@positive_o

; 2376 :         opnd1->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 0

; 2377 :         opnd1->llvalue = opnd2->llvalue;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 2378 :         opnd1->hlvalue = opnd2->hlvalue; /* v2.06: added */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx
	jmp	SHORT $LN3@positive_o
$LN2@positive_o:

; 2379 :     } else if( opnd2->kind == EXPR_FLOAT ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 3
	jne	SHORT $LN4@positive_o

; 2380 :         opnd1->kind = EXPR_FLOAT;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 3

; 2381 :         opnd1->float_tok = opnd2->float_tok;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 2382 :         opnd1->negative = opnd2->negative;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 5
	and	eax, 1
	and	eax, 1
	shl	eax, 5
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, -33				; ffffffdfH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 2383 :     } else {

	jmp	SHORT $LN5@positive_o
$LN4@positive_o:

; 2384 :         DebugMsg(("positive_op: error 1\n"));

	lea	rcx, OFFSET FLAT:$SG11982
	call	DoDebugMsg

; 2385 :         return( fnEmitErr( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN1@positive_o
$LN5@positive_o:
$LN3@positive_o:

; 2386 :     }
; 2387 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@positive_o:

; 2388 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
positive_op ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
temp$ = 64
sym$ = 72
tv76 = 80
tv82 = 88
tv142 = 96
opnd1$ = 128
opnd2$ = 136
colon_op PROC

; 2233 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+128]

; 2234 :     int_32              temp;
; 2235 :     struct asym         *sym;
; 2236 :     /*
; 2237 :      * The only formats allowed are:
; 2238 :      *     seg_reg : const
; 2239 :      *     seg_reg : address
; 2240 :      *     seg_label : const
; 2241 :      *     seg_label : address
; 2242 :      *     ( seg_label = segment or group symbol )
; 2243 :      *     inside square brackets, seg_reg : register is not accepted
; 2244 :      *     if Masm-syntax is on.
; 2245 :      */
; 2246 :     DebugMsg1(("colon_op: t1-t2 kind=%d/%d type=%s-%s is_type=%u-%u\n",

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN27@colon_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv76[rsp], rax
	jmp	SHORT $LN28@colon_op
$LN27@colon_op:
	lea	rax, OFFSET FLAT:$SG11941
	mov	QWORD PTR tv76[rsp], rax
$LN28@colon_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN29@colon_op
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv82[rsp], rax
	jmp	SHORT $LN30@colon_op
$LN29@colon_op:
	lea	rax, OFFSET FLAT:$SG11942
	mov	QWORD PTR tv82[rsp], rax
$LN30@colon_op:
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	shr	ecx, 3
	and	ecx, 1
	mov	DWORD PTR [rsp+48], eax
	mov	DWORD PTR [rsp+40], ecx
	mov	rax, QWORD PTR tv76[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv82[rsp]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+60]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax+60]
	lea	rcx, OFFSET FLAT:$SG11943
	call	DoDebugMsg1

; 2247 :                opnd1->kind, opnd2->kind,
; 2248 :                opnd1->type ? opnd1->type->name : "NULL",
; 2249 :                opnd2->type ? opnd2->type->name : "NULL",
; 2250 :                opnd1->is_type, opnd2->is_type ));
; 2251 :     if( opnd2->override != NULL ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN4@colon_op

; 2252 :         /* v2.07a: was too rigid */
; 2253 :         if ( ( opnd1->kind == EXPR_REG && opnd2->override->token == T_REG ) ||

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN7@colon_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+48]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 2
	je	SHORT $LN6@colon_op
$LN7@colon_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN5@colon_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+48]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 8
	jne	SHORT $LN5@colon_op
$LN6@colon_op:

; 2254 :             ( opnd1->kind == EXPR_ADDR && opnd2->override->token == T_ID ) ) {
; 2255 :             DebugMsg(("colon_op: multiple override=%s\n", opnd2->override->string_ptr ));

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11948
	call	DoDebugMsg

; 2256 :             return( fnEmitErr( MULTIPLE_OVERRIDES ) );

	mov	ecx, 68					; 00000044H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@colon_op
$LN5@colon_op:
$LN4@colon_op:

; 2257 :         }
; 2258 :     }
; 2259 :     switch ( opnd2->kind ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+60]
	mov	DWORD PTR tv142[rsp], eax
	cmp	DWORD PTR tv142[rsp], 2
	je	SHORT $LN8@colon_op
	cmp	DWORD PTR tv142[rsp], 3
	je	SHORT $LN10@colon_op
	jmp	SHORT $LN2@colon_op
$LN8@colon_op:

; 2260 :     case EXPR_REG:
; 2261 :         /* v2.05: register as second operand must be enclosed in [] */
; 2262 :         if ( opnd2->indirect == FALSE ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN9@colon_op

; 2263 :             DebugMsg(("colon_op: register after : not enclosed in []\n" ));

	lea	rcx, OFFSET FLAT:$SG11951
	call	DoDebugMsg

; 2264 :             return( fnEmitErr( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@colon_op
$LN9@colon_op:

; 2265 :         }
; 2266 :         break;

	jmp	SHORT $LN2@colon_op
$LN10@colon_op:

; 2267 :     case EXPR_FLOAT:
; 2268 :         return( fnEmitErr( REAL_OR_BCD_NUMBER_NOT_ALLOWED ) );

	mov	ecx, 270				; 0000010eH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@colon_op
$LN2@colon_op:

; 2269 :     }
; 2270 : 
; 2271 :     if( opnd1->kind == EXPR_REG ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	$LN11@colon_op

; 2272 : 
; 2273 :         /* the item before the ':' must be a single register */
; 2274 :         if( opnd1->idx_reg != NULL ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+32], 0
	je	SHORT $LN13@colon_op

; 2275 :             DebugMsg(("colon_op: register before ':' has idx_reg set!?\n"));

	lea	rcx, OFFSET FLAT:$SG11956
	call	DoDebugMsg

; 2276 :             return( fnEmitErr( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@colon_op
$LN13@colon_op:

; 2277 :         }
; 2278 :         /* segment override inside bracket not allowed with -Zne.
; 2279 :          * [ds:0] is ok, but [ds:ebx] is rejected.
; 2280 :          */
; 2281 :         /* v2.08: test moved here from get_operand() */
; 2282 :         /* v2.10: regression in v2.08-2.09: check was way too simple.
; 2283 :          * problem: indirect-flag isn't set for segment regs (anymore?).
; 2284 :          * error check moved back to get_operand().
; 2285 :          */
; 2286 : #if 0
; 2287 :         if ( Options.strict_masm_compat ) {
; 2288 :             return( fnEmitErr( INVALID_USE_OF_REGISTER ) );
; 2289 :         }
; 2290 : #endif
; 2291 :         /* make sure first operand is a segment register */
; 2292 :         temp = opnd1->base_reg->tokval;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR temp$[rsp], eax

; 2293 :         if ( ( GetValueSp( temp ) & OP_SR ) == 0 ) {

	movsxd	rax, DWORD PTR temp$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 24576				; 00006000H
	test	eax, eax
	jne	SHORT $LN14@colon_op

; 2294 :             return( fnEmitErr( SEGMENT_GROUP_OR_SEGREG_EXPECTED ) );

	mov	ecx, 69					; 00000045H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@colon_op
$LN14@colon_op:

; 2295 :         }
; 2296 : 
; 2297 :         opnd2->override = opnd1->base_reg;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+48], rcx

; 2298 :         opnd2->indirect |= opnd1->indirect;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, 1
	or	eax, ecx
	and	eax, 1
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, -2					; fffffffeH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 2299 : 
; 2300 :         if ( opnd2->kind == EXPR_CONST ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN15@colon_op

; 2301 :             opnd2->kind = EXPR_ADDR;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rax+60], 1
$LN15@colon_op:

; 2302 :             /* v2.05: type flag cleared HERE, not in dot_op()
; 2303 :              * v2.05rc17 problem: mov es:byte ptr <var>,0
; 2304 :              * so the flag isn't cleared at all now.
; 2305 :              */
; 2306 :             //opnd2->is_type = FALSE;
; 2307 :         }
; 2308 : 
; 2309 :         if( opnd1->explicit ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN16@colon_op

; 2310 :             opnd2->explicit = opnd1->explicit;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	and	eax, 1
	shl	eax, 1
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, -3					; fffffffdH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 2311 :             opnd2->mem_type = opnd1->mem_type;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+64], ecx

; 2312 :             opnd2->Ofssize  = opnd1->Ofssize;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	movzx	ecx, BYTE PTR [rcx+69]
	mov	BYTE PTR [rax+69], cl
$LN16@colon_op:

; 2313 :         }
; 2314 :         TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 2315 : 
; 2316 :         /*
; 2317 :          * currently the <type> token isn't copied by
; 2318 :          * TokenAssign (which is probably just for historical reasons).
; 2319 :          * So copy it manually!
; 2320 :          * v1.95: only copy if it is != NULL!
; 2321 :          * Testcase: (<type> ptr DS:[0]).<struct_field> ...
; 2322 :          * In this case the DS:[] will clear the <type>, as a result
; 2323 :          * the dot operator won't have a valid assume and the code fails.
; 2324 :          */
; 2325 :         if ( opnd2->type )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN17@colon_op

; 2326 :             opnd1->type = opnd2->type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx
$LN17@colon_op:

; 2327 : 
; 2328 :     } else if( opnd1->kind == EXPR_ADDR &&

	jmp	$LN12@colon_op
$LN11@colon_op:

; 2329 :               /* opnd2->kind == EXPR_ADDR && */
; 2330 :               opnd1->override == NULL &&
; 2331 :               opnd1->instr == EMPTY &&
; 2332 :               opnd1->value == 0 &&
; 2333 :               opnd1->sym &&
; 2334 :               opnd1->base_reg == NULL &&

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	$LN18@colon_op
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+48], 0
	jne	$LN18@colon_op
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+56], -2
	jne	$LN18@colon_op
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	$LN18@colon_op
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	$LN18@colon_op
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+24], 0
	jne	$LN18@colon_op
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+32], 0
	jne	$LN18@colon_op

; 2335 :               opnd1->idx_reg == NULL ) {
; 2336 : 
; 2337 :         sym = opnd1->sym;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym$[rsp], rax

; 2338 : 
; 2339 :         if( sym->state == SYM_GRP || sym->state == SYM_SEG ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 4
	je	SHORT $LN22@colon_op
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 3
	jne	$LN20@colon_op
$LN22@colon_op:

; 2340 :             opnd2->kind = EXPR_ADDR;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rax+60], 1

; 2341 :             opnd2->override = opnd1->label_tok;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	mov	QWORD PTR [rax+48], rcx

; 2342 :             opnd2->indirect |= opnd1->indirect;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, 1
	or	eax, ecx
	and	eax, 1
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, -2					; fffffffeH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 2343 :             if( opnd1->explicit ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN23@colon_op

; 2344 :                 opnd2->explicit = opnd1->explicit;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	and	eax, 1
	shl	eax, 1
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, -3					; fffffffdH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 2345 :                 opnd2->mem_type = opnd1->mem_type;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+64], ecx

; 2346 :                 opnd2->Ofssize  = opnd1->Ofssize;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	movzx	ecx, BYTE PTR [rcx+69]
	mov	BYTE PTR [rax+69], cl
$LN23@colon_op:

; 2347 :             }
; 2348 :             TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 2349 :             opnd1->type = opnd2->type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx
	jmp	SHORT $LN21@colon_op
$LN20@colon_op:

; 2350 : 
; 2351 :         } else if( Parse_Pass > PASS_1 || sym->state != SYM_UNDEFINED ) {

	cmp	DWORD PTR Parse_Pass, 0
	ja	SHORT $LN25@colon_op
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN24@colon_op
$LN25@colon_op:

; 2352 :             DebugMsg(("colon_op error 4\n"));

	lea	rcx, OFFSET FLAT:$SG11969
	call	DoDebugMsg

; 2353 :             return( fnEmitErr( SEGMENT_GROUP_OR_SEGREG_EXPECTED ) );

	mov	ecx, 69					; 00000045H
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN1@colon_op
$LN24@colon_op:
$LN21@colon_op:

; 2354 :         }
; 2355 :     } else {

	jmp	SHORT $LN19@colon_op
$LN18@colon_op:

; 2356 :         DebugMsg(("colon_op error 5\n"));

	lea	rcx, OFFSET FLAT:$SG11970
	call	DoDebugMsg

; 2357 :         return( fnEmitErr( SEGMENT_GROUP_OR_SEGREG_EXPECTED ) );

	mov	ecx, 69					; 00000045H
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN1@colon_op
$LN19@colon_op:
$LN12@colon_op:

; 2358 :     }
; 2359 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@colon_op:

; 2360 : }

	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
colon_op ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
tv68 = 80
tv74 = 88
tv80 = 96
tv86 = 104
tv92 = 112
tv130 = 120
tv179 = 128
tv185 = 136
tv310 = 144
tv318 = 152
tv389 = 160
tv397 = 168
opnd1$ = 192
opnd2$ = 200
dot_op	PROC

; 2029 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 176				; 000000b0H
	mov	rdi, rsp
	mov	ecx, 44					; 0000002cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+192]

; 2030 :     /* this code needs cleanup! some stuff is obsolete. */
; 2031 : 
; 2032 :     DebugMsg1(("dot_op: op1-op2 kind=%d/%d sym=%s-%s type=%s-%s mbr=%s-%s\n",

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN39@dot_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv68[rsp], rax
	jmp	SHORT $LN40@dot_op
$LN39@dot_op:
	lea	rax, OFFSET FLAT:$SG11863
	mov	QWORD PTR tv68[rsp], rax
$LN40@dot_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN41@dot_op
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv74[rsp], rax
	jmp	SHORT $LN42@dot_op
$LN41@dot_op:
	lea	rax, OFFSET FLAT:$SG11864
	mov	QWORD PTR tv74[rsp], rax
$LN42@dot_op:
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN43@dot_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv80[rsp], rax
	jmp	SHORT $LN44@dot_op
$LN43@dot_op:
	lea	rax, OFFSET FLAT:$SG11865
	mov	QWORD PTR tv80[rsp], rax
$LN44@dot_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN45@dot_op
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv86[rsp], rax
	jmp	SHORT $LN46@dot_op
$LN45@dot_op:
	lea	rax, OFFSET FLAT:$SG11866
	mov	QWORD PTR tv86[rsp], rax
$LN46@dot_op:
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN47@dot_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv92[rsp], rax
	jmp	SHORT $LN48@dot_op
$LN47@dot_op:
	lea	rax, OFFSET FLAT:$SG11867
	mov	QWORD PTR tv92[rsp], rax
$LN48@dot_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN49@dot_op
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv130[rsp], rax
	jmp	SHORT $LN50@dot_op
$LN49@dot_op:
	lea	rax, OFFSET FLAT:$SG11868
	mov	QWORD PTR tv130[rsp], rax
$LN50@dot_op:
	mov	rax, QWORD PTR tv68[rsp]
	mov	QWORD PTR [rsp+64], rax
	mov	rax, QWORD PTR tv74[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR tv80[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR tv86[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv92[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv130[rsp]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+60]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax+60]
	lea	rcx, OFFSET FLAT:$SG11869
	call	DoDebugMsg1

; 2033 :                opnd1->kind, opnd2->kind,
; 2034 :                opnd1->sym  ? opnd1->sym->name  : "NULL",
; 2035 :                opnd2->sym  ? opnd2->sym->name  : "NULL",
; 2036 :                opnd1->type ? opnd1->type->name : "NULL",
; 2037 :                opnd2->type ? opnd2->type->name : "NULL",
; 2038 :                opnd1->mbr  ? opnd1->mbr->name  : "NULL",
; 2039 :                opnd2->mbr  ? opnd2->mbr->name  : "NULL" ));
; 2040 : 
; 2041 :     /*
; 2042 :      * The formats allowed are:
; 2043 :      *        [register]      . (type) constant
; 2044 :      *        label           . (type) constant
; 2045 :      *        (type) constant . (type) constant
; 2046 :      *
; 2047 :      * with OPTION OLDSTRUCTS:
; 2048 :      *        [register]      . address
; 2049 :      *        address         . address
; 2050 :      */
; 2051 : 
; 2052 :     if( check_direct_reg( opnd1, opnd2 ) == ERROR ) {

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	check_direct_reg
	cmp	eax, -1
	jne	SHORT $LN2@dot_op

; 2053 :         DebugMsg(("dot_op: error direct register\n"));

	lea	rcx, OFFSET FLAT:$SG11871
	call	DoDebugMsg

; 2054 :         return( fnEmitErr( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@dot_op
$LN2@dot_op:

; 2055 :     }
; 2056 : 
; 2057 :     /* v2.08: remove EXPR_REG variants */
; 2058 :     if ( opnd1->kind == EXPR_REG )

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN3@dot_op

; 2059 :         opnd1->kind = EXPR_ADDR;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 1
$LN3@dot_op:

; 2060 :     if ( opnd2->kind == EXPR_REG )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN4@dot_op

; 2061 :         opnd2->kind = EXPR_ADDR;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rax+60], 1
$LN4@dot_op:

; 2062 : 
; 2063 :     /* forward ref to a struct: [reg].<struct> */
; 2064 :     if ( opnd2->sym && opnd2->sym->state == SYM_UNDEFINED && Parse_Pass == PASS_1 ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	$LN5@dot_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 0
	jne	$LN5@dot_op
	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN5@dot_op

; 2065 :         DebugMsg(("dot_op: forward reference %s, replaced by null struct type\n", opnd2->sym->name ));

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11875
	call	DoDebugMsg

; 2066 :         if ( !nullstruct )

	cmp	QWORD PTR nullstruct, 0
	jne	SHORT $LN6@dot_op

; 2067 :             nullstruct = CreateTypeSymbol( NULL, "", FALSE );

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:$SG11877
	xor	ecx, ecx
	call	CreateTypeSymbol
	mov	QWORD PTR nullstruct, rax
$LN6@dot_op:

; 2068 :         opnd2->type = nullstruct;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR nullstruct
	mov	QWORD PTR [rax+96], rcx

; 2069 :         opnd2->is_type = TRUE; /* v2.10: added */

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 8
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 2070 :         opnd2->sym = NULL;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	QWORD PTR [rax+80], 0

; 2071 :         opnd2->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rax+60], 0
$LN5@dot_op:

; 2072 :     }
; 2073 : 
; 2074 :     if( check_same( opnd1, opnd2, EXPR_ADDR ) ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	$LN7@dot_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	$LN7@dot_op

; 2075 : 
; 2076 :         DebugMsg1(("dot_op, ADDR - ADDR, t1-t2 memtype=%X-%X sym=%s-%s\n",

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN51@dot_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv179[rsp], rax
	jmp	SHORT $LN52@dot_op
$LN51@dot_op:
	lea	rax, OFFSET FLAT:$SG11880
	mov	QWORD PTR tv179[rsp], rax
$LN52@dot_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN53@dot_op
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv185[rsp], rax
	jmp	SHORT $LN54@dot_op
$LN53@dot_op:
	lea	rax, OFFSET FLAT:$SG11881
	mov	QWORD PTR tv185[rsp], rax
$LN54@dot_op:
	mov	rax, QWORD PTR tv179[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv185[rsp]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+64]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax+64]
	lea	rcx, OFFSET FLAT:$SG11882
	call	DoDebugMsg1

; 2077 :                    opnd1->mem_type, opnd2->mem_type,
; 2078 :                    opnd1->sym  ? opnd1->sym->name  : "NULL",
; 2079 :                    opnd2->sym  ? opnd2->sym->name  : "NULL" ));
; 2080 : 
; 2081 : #if 1 /* v2.05: error */
; 2082 :         if ( opnd2->mbr == NULL && !ModuleInfo.oldstructs ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+88], 0
	jne	SHORT $LN9@dot_op
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 8
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN9@dot_op

; 2083 :             DebugMsg(("dot_op: error, mbr 2 is NULL\n"));

	lea	rcx, OFFSET FLAT:$SG11884
	call	DoDebugMsg

; 2084 :             return( struct_field_error( opnd1 ) );

	mov	rcx, QWORD PTR opnd1$[rsp]
	call	struct_field_error
	jmp	$LN1@dot_op
$LN9@dot_op:

; 2085 :         }
; 2086 : #endif
; 2087 :         if ( index_connect( opnd1, opnd2 ) == ERROR )

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	index_connect
	cmp	eax, -1
	jne	SHORT $LN10@dot_op

; 2088 :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@dot_op
$LN10@dot_op:

; 2089 : 
; 2090 :         if( opnd2->sym != NULL ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	$LN11@dot_op

; 2091 :             if( opnd1->sym != NULL &&
; 2092 :                 opnd1->sym->state != SYM_UNDEFINED &&

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN12@dot_op
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN12@dot_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN12@dot_op

; 2093 :                 opnd2->sym->state != SYM_UNDEFINED ) {
; 2094 :                 DebugMsg(("dot_op: error, two relocatable labels: %s - %s \n", opnd1->sym->name, opnd2->sym->name ));

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG11888
	call	DoDebugMsg

; 2095 :                 return( fnEmitErr( CANNOT_ADD_TWO_RELOCATABLE_LABELS ) );

	mov	ecx, 173				; 000000adH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@dot_op
$LN12@dot_op:

; 2096 :             }
; 2097 :             opnd1->label_tok = opnd2->label_tok;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	mov	QWORD PTR [rax+40], rcx

; 2098 :             opnd1->sym = opnd2->sym;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [rax+80], rcx
$LN11@dot_op:

; 2099 :         }
; 2100 :         if( opnd2->mbr != NULL ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN13@dot_op

; 2101 :             opnd1->mbr = opnd2->mbr;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	QWORD PTR [rax+88], rcx
$LN13@dot_op:

; 2102 :         }
; 2103 :         opnd1->value += opnd2->value;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR opnd2$[rsp]
	add	eax, DWORD PTR [rcx]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax

; 2104 :         if( opnd1->explicit == FALSE ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN14@dot_op

; 2105 :             opnd1->mem_type = opnd2->mem_type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+64], ecx
$LN14@dot_op:

; 2106 :         }
; 2107 :         if ( opnd2->type )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN15@dot_op

; 2108 :             opnd1->type = opnd2->type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx
$LN15@dot_op:

; 2109 : 
; 2110 :     } else if( ( opnd1->kind == EXPR_CONST ) && ( opnd2->kind == EXPR_ADDR ) ) {

	jmp	$LN8@dot_op
$LN7@dot_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	$LN16@dot_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	$LN16@dot_op

; 2111 : 
; 2112 :         DebugMsg1(("dot_op, CONST - ADDR: t1-t2 memtype=%Xh-%Xh istype=%u-%u\n",

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	shr	ecx, 3
	and	ecx, 1
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+64]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax+64]
	lea	rcx, OFFSET FLAT:$SG11894
	call	DoDebugMsg1

; 2113 :                    opnd1->mem_type, opnd2->mem_type, opnd1->is_type, opnd2->is_type ));
; 2114 :         /* v2.08 added (copied from branch EXPR_ADDR-EXPR_REG )*/
; 2115 :         if ( opnd1->is_type && opnd1->type ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN18@dot_op
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN18@dot_op

; 2116 :             opnd2->assumecheck = FALSE;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, -65				; ffffffbfH
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 2117 :             opnd1->llvalue = 0;  /* v2.08: this was previously done in get_operand() */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rax], 0
$LN18@dot_op:

; 2118 :         }
; 2119 : #if 1 /* v2.05: error */
; 2120 :         /* <structname>.<member>[<index_reg>] is ALWAYS ok! */
; 2121 :         if ( ( !ModuleInfo.oldstructs ) && ( opnd1->is_type == FALSE && opnd1->mbr == NULL ) )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 8
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN19@dot_op
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN19@dot_op
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+88], 0
	jne	SHORT $LN19@dot_op

; 2122 :             return( struct_field_error( opnd1 ) );

	mov	rcx, QWORD PTR opnd1$[rsp]
	call	struct_field_error
	jmp	$LN1@dot_op
$LN19@dot_op:

; 2123 : #endif
; 2124 :         /* for TYPE.xxx, return offset instead of size */
; 2125 :         if ( opnd1->mbr && opnd1->mbr->state == SYM_TYPE )

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN20@dot_op
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+88]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN20@dot_op

; 2126 :             opnd1->llvalue = opnd1->mbr->offset;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+88]
	movsxd	rax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax
$LN20@dot_op:

; 2127 :         opnd2->indirect |= opnd1->indirect;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, 1
	or	eax, ecx
	and	eax, 1
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, -2					; fffffffeH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 2128 :         opnd2->llvalue += opnd1->llvalue;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR opnd1$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	QWORD PTR [rcx], rax

; 2129 :         DebugMsg1(("dot_op, CONST - ADDR, t1.type=%X (%s), t2.type=%X (%s)\n",

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN55@dot_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv310[rsp], rax
	jmp	SHORT $LN56@dot_op
$LN55@dot_op:
	lea	rax, OFFSET FLAT:$SG11898
	mov	QWORD PTR tv310[rsp], rax
$LN56@dot_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN57@dot_op
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv318[rsp], rax
	jmp	SHORT $LN58@dot_op
$LN57@dot_op:
	lea	rax, OFFSET FLAT:$SG11899
	mov	QWORD PTR tv318[rsp], rax
$LN58@dot_op:
	mov	rax, QWORD PTR tv310[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r9, QWORD PTR [rax+96]
	mov	r8, QWORD PTR tv318[rsp]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rdx, QWORD PTR [rax+96]
	lea	rcx, OFFSET FLAT:$SG11900
	call	DoDebugMsg1

; 2130 :                    opnd1->type,
; 2131 :                    opnd1->type ? opnd1->type->name : "",
; 2132 :                    opnd2->type,
; 2133 :                    opnd2->type ? opnd2->type->name : "" ));
; 2134 :         /* v2.06: added. test case: INVOKE struct.mbr[edx] ( mbr has a type ) */
; 2135 :         if ( opnd2->mbr )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN21@dot_op

; 2136 :             opnd1->type = opnd2->type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx
$LN21@dot_op:

; 2137 :         TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign
	jmp	$LN17@dot_op
$LN16@dot_op:

; 2138 : 
; 2139 :     } else if( ( opnd1->kind == EXPR_ADDR ) && ( opnd2->kind == EXPR_CONST ) ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	$LN22@dot_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	$LN22@dot_op

; 2140 : 
; 2141 :         DebugMsg1(("dot_op, ADDR - CONST: t1-t2 memtype=%Xh-%Xh t1.explicit=%u\n",

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	mov	r9d, eax
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+64]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax+64]
	lea	rcx, OFFSET FLAT:$SG11904
	call	DoDebugMsg1

; 2142 :                    opnd1->mem_type, opnd2->mem_type, opnd1->explicit ));
; 2143 : 
; 2144 :         /* v2.08: changed to catch [ebx].<num> or [ebx].<simple type> */
; 2145 :         //if ( (!ModuleInfo.oldstructs) && opnd2->type == NULL && opnd2->mbr == NULL ) {
; 2146 :         if ( (!ModuleInfo.oldstructs) && ( opnd2->type == NULL || opnd2->is_type == FALSE ) && opnd2->mbr == NULL ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 8
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN24@dot_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN25@dot_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN24@dot_op
$LN25@dot_op:
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+88], 0
	jne	SHORT $LN24@dot_op

; 2147 :             DebugMsg(("dot_op: error, constant or simple type after dot\n"));

	lea	rcx, OFFSET FLAT:$SG11907
	call	DoDebugMsg

; 2148 :             return( struct_field_error( opnd1 ) );

	mov	rcx, QWORD PTR opnd1$[rsp]
	call	struct_field_error
	jmp	$LN1@dot_op
$LN24@dot_op:

; 2149 :         }
; 2150 : 
; 2151 :         /* v2.08 added (copied from branch EXPR_ADDR-EXPR_REG )*/
; 2152 :         if ( opnd2->is_type && opnd2->type ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN26@dot_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN26@dot_op

; 2153 :             opnd1->assumecheck = FALSE;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, -65				; ffffffbfH
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 2154 :             opnd2->llvalue = 0;  /* v2.08: this was previously done in get_operand() */

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	QWORD PTR [rax], 0
$LN26@dot_op:

; 2155 :         }
; 2156 :         /* for [var].TYPE | STRUCT_FIELD, use offset instead of size */
; 2157 :         if ( opnd2->mbr && opnd2->mbr->state == SYM_TYPE )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN27@dot_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+88]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN27@dot_op

; 2158 :             opnd2->llvalue = opnd2->mbr->offset;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+88]
	movsxd	rax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	QWORD PTR [rcx], rax
$LN27@dot_op:

; 2159 :         opnd1->llvalue += opnd2->llvalue;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR opnd2$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 2160 :         opnd1->mem_type = opnd2->mem_type; /* v2.08: now always done */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+64], ecx

; 2161 :         if( opnd2->mbr != NULL ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN28@dot_op

; 2162 :             opnd1->mbr = opnd2->mbr;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	QWORD PTR [rax+88], rcx
$LN28@dot_op:

; 2163 : #if 0 /* v2.07 */
; 2164 :             /* temp. disabled in v1.95, test case:
; 2165 :              * mov eax,(<struct> ptr [ebx]).F1
; 2166 :              * however: mov ax, word ptr var[bx].F1 ???
; 2167 :              * the condition can't be disabled. Instead the PTR
; 2168 :              * operator must NOT set the explicit flag if the
; 2169 :              * first operand is a structure.
; 2170 :              */
; 2171 :             if( opnd1->explicit == FALSE )
; 2172 : #endif
; 2173 :                 //opnd1->mem_type = opnd2->mem_type; /* v2.08: obsolete */
; 2174 :         }
; 2175 : 
; 2176 :         DebugMsg1(("dot_op, ADDR - CONST, t1.type=%X (%s), t2.type=%X (%s)\n",

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN59@dot_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv389[rsp], rax
	jmp	SHORT $LN60@dot_op
$LN59@dot_op:
	lea	rax, OFFSET FLAT:$SG11911
	mov	QWORD PTR tv389[rsp], rax
$LN60@dot_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN61@dot_op
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv397[rsp], rax
	jmp	SHORT $LN62@dot_op
$LN61@dot_op:
	lea	rax, OFFSET FLAT:$SG11912
	mov	QWORD PTR tv397[rsp], rax
$LN62@dot_op:
	mov	rax, QWORD PTR tv389[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r9, QWORD PTR [rax+96]
	mov	r8, QWORD PTR tv397[rsp]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rdx, QWORD PTR [rax+96]
	lea	rcx, OFFSET FLAT:$SG11913
	call	DoDebugMsg1

; 2177 :                    opnd1->type,
; 2178 :                    opnd1->type ? opnd1->type->name : "",
; 2179 :                    opnd2->type,
; 2180 :                    opnd2->type ? opnd2->type->name : "" ));
; 2181 : #if 0 /* v1.96 */
; 2182 :         if ( opnd2->type )
; 2183 : #endif
; 2184 :             opnd1->type = opnd2->type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx
	jmp	$LN23@dot_op
$LN22@dot_op:

; 2185 : 
; 2186 :     } else if ( opnd1->kind == EXPR_CONST && opnd2->kind == EXPR_CONST ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	$LN29@dot_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	$LN29@dot_op

; 2187 : 
; 2188 :         DebugMsg1(("dot_op, CONST - CONST, t1-t2 value=%u-%u, memtype=%Xh-%Xh istype=%u-%u\n",

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	shr	ecx, 3
	and	ecx, 1
	mov	DWORD PTR [rsp+48], eax
	mov	DWORD PTR [rsp+40], ecx
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	r9d, DWORD PTR [rax+64]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11916
	call	DoDebugMsg1

; 2189 :                    opnd1->value, opnd2->value, opnd1->mem_type, opnd2->mem_type, opnd1->is_type, opnd2->is_type));
; 2190 :         if ( opnd2->mbr == NULL && !ModuleInfo.oldstructs ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+88], 0
	jne	SHORT $LN31@dot_op
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 8
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN31@dot_op

; 2191 :             DebugMsg(("dot_op: error, opnd2.mbr=NULL\n" ));

	lea	rcx, OFFSET FLAT:$SG11918
	call	DoDebugMsg

; 2192 :             return( struct_field_error( opnd1 ) );

	mov	rcx, QWORD PTR opnd1$[rsp]
	call	struct_field_error
	jmp	$LN1@dot_op
$LN31@dot_op:

; 2193 :         }
; 2194 :         if ( opnd1->type != NULL ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	$LN32@dot_op

; 2195 :             /*
; 2196 :              * v2.06: the token1 value must NOT be ignored if the token is a
; 2197 :              * struct member: mov ax, [offset] <struct>.<mbr>.<mbr>
; 2198 :              */
; 2199 :             if ( opnd1->mbr != NULL )

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN34@dot_op

; 2200 :                 opnd1->llvalue += opnd2->llvalue;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR opnd2$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	SHORT $LN35@dot_op
$LN34@dot_op:

; 2201 :             else {
; 2202 :                 /* old token is a type - the value (=size) is ignored then. */
; 2203 :                 opnd1->llvalue = opnd2->llvalue;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
$LN35@dot_op:

; 2204 :             }
; 2205 :             opnd1->mbr = opnd2->mbr;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	QWORD PTR [rax+88], rcx

; 2206 :             /* v2.0: copy mem_type (test case: mov ds:[<struct>.<mbr>], 123) */
; 2207 :             opnd1->mem_type = opnd2->mem_type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+64], ecx

; 2208 :             /* v2.05: removed, it's still a type constant */
; 2209 :             //opnd1->is_type = FALSE;
; 2210 :             opnd1->is_type = opnd2->is_type;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	and	eax, 1
	shl	eax, 3
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, -9					; fffffff7H
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 2211 :             /* either clear <type> or use the renewed one */
; 2212 :             if ( opnd1->type != opnd2->type )

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	cmp	QWORD PTR [rax+96], rcx
	je	SHORT $LN36@dot_op

; 2213 :                 opnd1->type = opnd2->type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx
	jmp	SHORT $LN37@dot_op
$LN36@dot_op:

; 2214 :             else
; 2215 :                 opnd1->type = NULL;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rax+96], 0
$LN37@dot_op:

; 2216 :         } else {

	jmp	SHORT $LN33@dot_op
$LN32@dot_op:

; 2217 :             /* old token is NOT a type */
; 2218 :             /* most likely a number or an MT_ABS symbol! */
; 2219 :             /* so the TOTAL of both constants is required */
; 2220 :             opnd1->llvalue += opnd2->llvalue;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR opnd2$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 2221 :             opnd1->mbr = opnd2->mbr;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	QWORD PTR [rax+88], rcx

; 2222 :             opnd1->mem_type = opnd2->mem_type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+64], ecx
$LN33@dot_op:

; 2223 :         }
; 2224 :     } else {

	jmp	SHORT $LN30@dot_op
$LN29@dot_op:

; 2225 :         DebugMsg(("dot_op: error, unknown kind combination, opnd1->kind=%d, opnd2->kind=%d\n", opnd1->kind, opnd2->kind ));

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+60]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax+60]
	lea	rcx, OFFSET FLAT:$SG11925
	call	DoDebugMsg

; 2226 :         return( struct_field_error( opnd1 ) );

	mov	rcx, QWORD PTR opnd1$[rsp]
	call	struct_field_error
	jmp	SHORT $LN1@dot_op
$LN30@dot_op:
$LN23@dot_op:
$LN17@dot_op:
$LN8@dot_op:

; 2227 :     }
; 2228 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@dot_op:

; 2229 : }

	add	rsp, 176				; 000000b0H
	pop	rdi
	ret	0
dot_op	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
opnd$ = 48
struct_field_error PROC

; 2019 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 2020 :     if ( opnd->is_opattr ) {

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@struct_fie

; 2021 :         opnd->kind = EXPR_ERROR;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], -1

; 2022 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@struct_fie
$LN2@struct_fie:

; 2023 :     }
; 2024 :     return( fnEmitErr( STRUCTURE_FIELD_EXPECTED ) );

	mov	ecx, 271				; 0000010fH
	call	QWORD PTR fnEmitErr
$LN1@struct_fie:

; 2025 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
struct_field_error ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
sym$ = 32
opnd1$ = 64
opnd2$ = 72
minus_op PROC

; 1873 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 1874 :     struct asym      *sym;
; 1875 :     /*
; 1876 :      * The only formats allowed are:
; 1877 :      *        constant - constant
; 1878 :      *         address - constant       ( only in this order )
; 1879 :      *         address - address
; 1880 :      *        register - constant       ( only inside [] and in this
; 1881 :      *                                    order )
; 1882 :      */
; 1883 : 
; 1884 :     DebugMsg1(("minus_op: kind tok1=%u, tok2=%u\n", opnd1->kind, opnd2->kind ));

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+60]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax+60]
	lea	rcx, OFFSET FLAT:$SG11800
	call	DoDebugMsg1

; 1885 : 
; 1886 :     if( check_direct_reg( opnd1, opnd2 ) == ERROR ) {

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	check_direct_reg
	cmp	eax, -1
	jne	SHORT $LN2@minus_op

; 1887 :         DebugMsg(("minus_op: error direct register\n"));

	lea	rcx, OFFSET FLAT:$SG11802
	call	DoDebugMsg

; 1888 :         return( fnEmitErr( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@minus_op
$LN2@minus_op:

; 1889 :     }
; 1890 : 
; 1891 :     /* added for v1.94. It's related to the change done in MakeConst()!
; 1892 :      * todo: find out why flag no_error_msg was checked in v1.94-2.09.
; 1893 :      */
; 1894 :     if ( opnd1->kind == EXPR_ADDR &&
; 1895 :         opnd2->kind == EXPR_ADDR &&
; 1896 :         opnd2->sym &&

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN3@minus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN3@minus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN3@minus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN3@minus_op

; 1897 :         opnd2->sym->state == SYM_UNDEFINED /* && !no_error_msg */ )
; 1898 :         ; /* don't convert token2 to a constant! */

	jmp	SHORT $LN4@minus_op
$LN3@minus_op:

; 1899 :     else
; 1900 :         MakeConst( opnd2 );

	mov	rcx, QWORD PTR opnd2$[rsp]
	call	MakeConst
$LN4@minus_op:

; 1901 : 
; 1902 :     if( check_same( opnd1, opnd2, EXPR_CONST ) ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN5@minus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN5@minus_op

; 1903 : 
; 1904 :         DebugMsg1(("minus_op: CONST-CONST\n" ));

	lea	rcx, OFFSET FLAT:$SG11807
	call	DoDebugMsg1

; 1905 :         opnd1->llvalue -= opnd2->llvalue;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	$LN6@minus_op
$LN5@minus_op:

; 1906 : 
; 1907 :     } else if( opnd1->kind == EXPR_ADDR &&

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN7@minus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN7@minus_op

; 1908 :               opnd2->kind == EXPR_CONST ) {
; 1909 : 
; 1910 :         DebugMsg1(("minus_op: ADDR-CONST\n" ));

	lea	rcx, OFFSET FLAT:$SG11810
	call	DoDebugMsg1

; 1911 :         opnd1->llvalue -= opnd2->llvalue;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 1912 :         fix_struct_value( opnd1 );

	mov	rcx, QWORD PTR opnd1$[rsp]
	call	fix_struct_value
	jmp	$LN8@minus_op
$LN7@minus_op:

; 1913 : 
; 1914 :     } else if( check_same( opnd1, opnd2, EXPR_ADDR ) ){

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	$LN9@minus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	$LN9@minus_op

; 1915 : 
; 1916 :         DebugMsg1(("minus_op: ADDR-ADDR\n" ));

	lea	rcx, OFFSET FLAT:$SG11813
	call	DoDebugMsg1

; 1917 :         fix_struct_value( opnd1 );

	mov	rcx, QWORD PTR opnd1$[rsp]
	call	fix_struct_value

; 1918 :         fix_struct_value( opnd2 );

	mov	rcx, QWORD PTR opnd2$[rsp]
	call	fix_struct_value

; 1919 :         //if( opnd2->base_reg != NULL || opnd2->idx_reg != NULL ) { /* v2.09: just check 'indirect' */
; 1920 :         if( opnd2->indirect ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN11@minus_op

; 1921 :             DebugMsg(("minus_op error, opnd2->indirect==TRUE\n"));

	lea	rcx, OFFSET FLAT:$SG11815
	call	DoDebugMsg

; 1922 :             return( fnEmitErr( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@minus_op
$LN11@minus_op:

; 1923 :         }
; 1924 :         if( opnd2->label_tok == NULL ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+40], 0
	jne	SHORT $LN12@minus_op

; 1925 :             /* v2.06c: do 64-bit arithmetic (more rigid test in data.c) */
; 1926 :             //opnd1->value -= opnd2->value;
; 1927 :             opnd1->value64 -= opnd2->value64;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 1928 :             opnd1->indirect |= opnd2->indirect;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, 1
	or	eax, ecx
	and	eax, 1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, -2					; fffffffeH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 1929 :         } else {

	jmp	$LN13@minus_op
$LN12@minus_op:

; 1930 :             if( opnd1->label_tok == NULL || opnd1->sym == NULL || opnd2->sym == NULL ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN15@minus_op
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN15@minus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	jne	SHORT $LN14@minus_op
$LN15@minus_op:

; 1931 :                 DebugMsg(("minus_op error, label_tok=%X opnd1.sym=%X opnd2.sym=%X\n", opnd1->label_tok, opnd1->sym, opnd2->sym ));

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r9, QWORD PTR [rax+80]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	r8, QWORD PTR [rax+80]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rdx, QWORD PTR [rax+40]
	lea	rcx, OFFSET FLAT:$SG11820
	call	DoDebugMsg

; 1932 :                 /* v2.05: error msg changed */
; 1933 :                 //fnEmitErr( SYNTAX_ERROR );
; 1934 :                 return( fnEmitErr( OPERAND_MUST_BE_RELOCATABLE ) );

	mov	ecx, 188				; 000000bcH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@minus_op
$LN14@minus_op:

; 1935 :             }
; 1936 :             /* handle first operand */
; 1937 :             sym = opnd1->sym;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym$[rsp], rax

; 1938 :             opnd1->value += sym->offset;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR sym$[rsp]
	add	eax, DWORD PTR [rcx+16]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax

; 1939 : 
; 1940 :             /* handle second operand */
; 1941 :             sym = opnd2->sym;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym$[rsp], rax

; 1942 :             if( Parse_Pass > PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jbe	$LN16@minus_op

; 1943 :                 /* if symbol is external, error - unless it's the same symbol */
; 1944 :                 if ( ( sym->state == SYM_EXTERNAL ||
; 1945 :                      opnd1->sym->state == SYM_EXTERNAL) &&

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	je	SHORT $LN18@minus_op
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN17@minus_op
$LN18@minus_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	QWORD PTR sym$[rsp], rax
	je	SHORT $LN17@minus_op

; 1946 :                     sym != opnd1->sym ) {
; 1947 :                     DebugMsg(("minus_op error 6\n"));

	lea	rcx, OFFSET FLAT:$SG11824
	call	DoDebugMsg

; 1948 :                     return( fnEmitErr(INVALID_USE_OF_EXTERNAL_SYMBOL, opnd1->sym->name ) );

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 193				; 000000c1H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@minus_op
$LN17@minus_op:

; 1949 :                 }
; 1950 :                 /* check if the 2 offsets belong to the same segment */
; 1951 :                 if ( sym->segment != opnd1->sym->segment ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	cmp	QWORD PTR [rcx+24], rax
	je	SHORT $LN19@minus_op

; 1952 :                     DebugMsg(("minus_op error, sym.segm=%X opnd1->sym.segm=%X\n", sym->segment, opnd1->sym->segment ));

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	r8, QWORD PTR [rax+24]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+24]
	lea	rcx, OFFSET FLAT:$SG11826
	call	DoDebugMsg

; 1953 :                     return( fnEmitErr( OPERANDS_MUST_BE_IN_SAME_SEGMENT ) );

	mov	ecx, 192				; 000000c0H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@minus_op
$LN19@minus_op:
$LN16@minus_op:

; 1954 :                 }
; 1955 :             }
; 1956 : 
; 1957 :             /* the type changes from address to constant.
; 1958 :              * but only if both labels are defined and no indirect addressing.
; 1959 :              */
; 1960 :             opnd1->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 0

; 1961 : 
; 1962 :             /* v2.05: if at least one label is undefined, assume result=1 */
; 1963 :             if ( opnd1->sym->state == SYM_UNDEFINED ||

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN22@minus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN20@minus_op
$LN22@minus_op:

; 1964 :                 opnd2->sym->state == SYM_UNDEFINED ) {
; 1965 :                 opnd1->value = 1;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax], 1

; 1966 :                 /* 2.09: make sure an undefined label is returned in opnd.sym.
; 1967 :                  * expression type has to be ADDR then; see equate22.aso.
; 1968 :                  * 2.11: returning EXPR_ADDR may cause problems -
; 1969 :                  * it may make the code longer than necessary, thus
; 1970 :                  * triggering an unnecessary jump extension.
; 1971 :                  * so it is returned only if the expression is used to define an equate.
; 1972 :                  */
; 1973 :                 if ( opnd1->sym->state != SYM_UNDEFINED ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN23@minus_op

; 1974 :                     opnd1->sym = opnd2->sym;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [rax+80], rcx

; 1975 :                     opnd1->label_tok = opnd2->label_tok;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	mov	QWORD PTR [rax+40], rcx
$LN23@minus_op:

; 1976 :                 }
; 1977 :                 opnd1->kind = EXPR_ADDR;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 1

; 1978 :             } else {

	jmp	SHORT $LN21@minus_op
$LN20@minus_op:

; 1979 :                 /* v2.06c: do 64-bit arithmetic (more rigid test in data.c) */
; 1980 :                 //opnd1->value -= sym->offset;
; 1981 :                 //opnd1->value -= opnd2->value;
; 1982 :                 opnd1->value64 -= sym->offset;

	mov	rax, QWORD PTR sym$[rsp]
	movsxd	rax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR [rcx]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 1983 :                 opnd1->value64 -= opnd2->value64;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 1984 :                 opnd1->label_tok = NULL;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rax+40], 0

; 1985 :                 opnd1->sym = NULL;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rax+80], 0
$LN21@minus_op:

; 1986 :             }
; 1987 :             //if( opnd1->base_reg == NULL && opnd1->idx_reg == NULL ) { /* v2.09: just check 'indirect' */
; 1988 :             if( opnd1->indirect == FALSE ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN24@minus_op

; 1989 :                 if( opnd1->instr == T_OFFSET && opnd2->instr == T_OFFSET )

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+56], 241			; 000000f1H
	jne	SHORT $LN26@minus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+56], 241			; 000000f1H
	jne	SHORT $LN26@minus_op

; 1990 :                     opnd1->instr = EMPTY;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+56], -2
$LN26@minus_op:

; 1991 :                 //opnd1->indirect = FALSE; /* v2.09: not needed */
; 1992 :             } else {

	jmp	SHORT $LN25@minus_op
$LN24@minus_op:

; 1993 :                 DebugMsg1(("minus_op, exit, ADDR, base=%X, idx=%X\n", opnd1->base_reg, opnd1->idx_reg ));

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	r8, QWORD PTR [rax+32]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rdx, QWORD PTR [rax+24]
	lea	rcx, OFFSET FLAT:$SG11834
	call	DoDebugMsg1

; 1994 :                 opnd1->kind = EXPR_ADDR;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 1
$LN25@minus_op:

; 1995 :                 //opnd1->indirect |= opnd2->indirect;  /* v2.09: op1->indirect is always 1, op2->indirect is always 0 */
; 1996 :             }
; 1997 :             opnd1->explicit = FALSE;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, -3					; fffffffdH
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 1998 :             opnd1->mem_type = MT_EMPTY;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+64], 192			; 000000c0H
$LN13@minus_op:

; 1999 :         }

	jmp	$LN10@minus_op
$LN9@minus_op:

; 2000 : 
; 2001 :     } else if( opnd1->kind == EXPR_REG &&

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN27@minus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN27@minus_op

; 2002 :               opnd2->kind == EXPR_CONST ) {
; 2003 : 
; 2004 :         opnd1->llvalue = -1 * opnd2->llvalue;

	mov	rax, QWORD PTR opnd2$[rsp]
	imul	rax, QWORD PTR [rax], -1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 2005 :         opnd1->indirect |= opnd2->indirect;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, 1
	or	eax, ecx
	and	eax, 1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, -2					; fffffffeH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 2006 :         opnd1->kind = EXPR_ADDR;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 1

; 2007 : 
; 2008 :     } else {

	jmp	SHORT $LN28@minus_op
$LN27@minus_op:

; 2009 :         DebugMsg(("minus_op, exit, error: kinds tok1=%u, tok2=%u\n", opnd1->kind, opnd2->kind ));

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+60]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax+60]
	lea	rcx, OFFSET FLAT:$SG11837
	call	DoDebugMsg

; 2010 :         return( ConstError( opnd1, opnd2 ) );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	ConstError
	jmp	SHORT $LN1@minus_op
$LN28@minus_op:
$LN10@minus_op:
$LN8@minus_op:
$LN6@minus_op:

; 2011 :     }
; 2012 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@minus_op:

; 2013 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
minus_op ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
tv68 = 112
tv74 = 120
tv80 = 128
tv86 = 136
tv92 = 144
tv130 = 152
opnd1$ = 176
opnd2$ = 184
plus_op	PROC

; 1746 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 160				; 000000a0H
	mov	rdi, rsp
	mov	ecx, 40					; 00000028H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+176]

; 1747 :     DebugMsg1(("plus_op: kind=%d/%d memtype=%Xh-%Xh value=%d-%d sym=%s-%s mbr=%s-%s type=%s-%s\n",

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN31@plus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv68[rsp], rax
	jmp	SHORT $LN32@plus_op
$LN31@plus_op:
	lea	rax, OFFSET FLAT:$SG11744
	mov	QWORD PTR tv68[rsp], rax
$LN32@plus_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN33@plus_op
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv74[rsp], rax
	jmp	SHORT $LN34@plus_op
$LN33@plus_op:
	lea	rax, OFFSET FLAT:$SG11745
	mov	QWORD PTR tv74[rsp], rax
$LN34@plus_op:
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN35@plus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv80[rsp], rax
	jmp	SHORT $LN36@plus_op
$LN35@plus_op:
	lea	rax, OFFSET FLAT:$SG11746
	mov	QWORD PTR tv80[rsp], rax
$LN36@plus_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN37@plus_op
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv86[rsp], rax
	jmp	SHORT $LN38@plus_op
$LN37@plus_op:
	lea	rax, OFFSET FLAT:$SG11747
	mov	QWORD PTR tv86[rsp], rax
$LN38@plus_op:
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN39@plus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv92[rsp], rax
	jmp	SHORT $LN40@plus_op
$LN39@plus_op:
	lea	rax, OFFSET FLAT:$SG11748
	mov	QWORD PTR tv92[rsp], rax
$LN40@plus_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN41@plus_op
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv130[rsp], rax
	jmp	SHORT $LN42@plus_op
$LN41@plus_op:
	lea	rax, OFFSET FLAT:$SG11749
	mov	QWORD PTR tv130[rsp], rax
$LN42@plus_op:
	mov	rax, QWORD PTR tv68[rsp]
	mov	QWORD PTR [rsp+96], rax
	mov	rax, QWORD PTR tv74[rsp]
	mov	QWORD PTR [rsp+88], rax
	mov	rax, QWORD PTR tv80[rsp]
	mov	QWORD PTR [rsp+80], rax
	mov	rax, QWORD PTR tv86[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	rax, QWORD PTR tv92[rsp]
	mov	QWORD PTR [rsp+64], rax
	mov	rax, QWORD PTR tv130[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	r9d, DWORD PTR [rax+64]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+60]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax+60]
	lea	rcx, OFFSET FLAT:$SG11750
	call	DoDebugMsg1

; 1748 :                opnd1->kind, opnd2->kind,
; 1749 :                opnd1->mem_type, opnd2->mem_type, 
; 1750 :                opnd1->value, opnd2->value,
; 1751 :                opnd1->sym ? opnd1->sym->name : "NULL",
; 1752 :                opnd2->sym ? opnd2->sym->name : "NULL",
; 1753 :                opnd1->mbr ? opnd1->mbr->name : "NULL",
; 1754 :                opnd2->mbr ? opnd2->mbr->name : "NULL",
; 1755 :                opnd1->type ? opnd1->type->name : "NULL",
; 1756 :                opnd2->type ? opnd2->type->name : "NULL" ));
; 1757 :     /*
; 1758 :      * The formats allowed are (registers inside [] only!):
; 1759 :      *        constant + constant  CONST-CONST
; 1760 :      *        constant + address   CONST-ADDR
; 1761 :      *        register + constant  ADDR-CONST
; 1762 :      *        address + register   ADDR-ADDR
; 1763 :      *        register + register  ADDR-ADDR
; 1764 :      *        address  + address   ADDR-ADDR
; 1765 :      */
; 1766 : 
; 1767 :     if( check_direct_reg( opnd1, opnd2 ) == ERROR ) {

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	check_direct_reg
	cmp	eax, -1
	jne	SHORT $LN2@plus_op

; 1768 :         DebugMsg(("plus_op: error direct register\n" ));

	lea	rcx, OFFSET FLAT:$SG11752
	call	DoDebugMsg

; 1769 :         return( fnEmitErr( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@plus_op
$LN2@plus_op:

; 1770 :     }
; 1771 :     /* v2.08: remove EXPR_REG variants */
; 1772 :     if ( opnd1->kind == EXPR_REG )

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN3@plus_op

; 1773 :         opnd1->kind = EXPR_ADDR;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 1
$LN3@plus_op:

; 1774 :     if ( opnd2->kind == EXPR_REG )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN4@plus_op

; 1775 :         opnd2->kind = EXPR_ADDR;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rax+60], 1
$LN4@plus_op:

; 1776 : 
; 1777 :     /* v2.07: don't allow multiple overrides */
; 1778 :     if ( opnd2->override ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN5@plus_op

; 1779 :         if ( opnd1->override ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN6@plus_op

; 1780 :             /* v2.07a: both T_REG or both T_ID is rejected */
; 1781 :             if ( opnd1->override->token == opnd2->override->token ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+48]
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	movzx	ecx, BYTE PTR [rcx]
	cmp	eax, ecx
	jne	SHORT $LN7@plus_op

; 1782 :                 DebugMsg(("plus_op: multiple overrides\n" ));

	lea	rcx, OFFSET FLAT:$SG11758
	call	DoDebugMsg

; 1783 :                 return( fnEmitErr( MULTIPLE_OVERRIDES ) );

	mov	ecx, 68					; 00000044H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@plus_op
$LN7@plus_op:
$LN6@plus_op:

; 1784 :             }
; 1785 :         }
; 1786 :         opnd1->override = opnd2->override;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	QWORD PTR [rax+48], rcx
$LN5@plus_op:

; 1787 :     }
; 1788 : 
; 1789 :     if( check_same( opnd1, opnd2, EXPR_CONST ) ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN8@plus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN8@plus_op

; 1790 : 
; 1791 :         DebugMsg1(("plus_op: CONST - CONST\n" ));

	lea	rcx, OFFSET FLAT:$SG11761
	call	DoDebugMsg1

; 1792 :         opnd1->llvalue += opnd2->llvalue;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR opnd2$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	$LN9@plus_op
$LN8@plus_op:

; 1793 : 
; 1794 :     } else if( check_same( opnd1, opnd2, EXPR_ADDR ) ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	$LN10@plus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	$LN10@plus_op

; 1795 : 
; 1796 :         DebugMsg1(("plus_op: ADDR - ADDR\n" ));

	lea	rcx, OFFSET FLAT:$SG11764
	call	DoDebugMsg1

; 1797 :         fix_struct_value( opnd1 );

	mov	rcx, QWORD PTR opnd1$[rsp]
	call	fix_struct_value

; 1798 :         fix_struct_value( opnd2 );

	mov	rcx, QWORD PTR opnd2$[rsp]
	call	fix_struct_value

; 1799 :         if ( index_connect( opnd1, opnd2 ) == ERROR )

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	index_connect
	cmp	eax, -1
	jne	SHORT $LN12@plus_op

; 1800 :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@plus_op
$LN12@plus_op:

; 1801 :         if( opnd2->sym != NULL ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	$LN13@plus_op

; 1802 :             /* two relocatable labels not allowed */
; 1803 :             /* v2.05: changed */
; 1804 :             //if ( ( opnd1->sym != NULL ) && ( Parse_Pass > PASS_1 || error_msg == FALSE ) ) {
; 1805 :             if ( opnd1->sym != NULL &&
; 1806 :                 opnd1->sym->state != SYM_UNDEFINED &&

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN14@plus_op
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN14@plus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN14@plus_op

; 1807 :                 opnd2->sym->state != SYM_UNDEFINED ) {
; 1808 :                 DebugMsg(("plus_op: two relocatable labels: %s - %s \n", opnd1->sym->name, opnd2->sym->name ));

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG11768
	call	DoDebugMsg

; 1809 :                 return( fnEmitErr( CANNOT_ADD_TWO_RELOCATABLE_LABELS ) );

	mov	ecx, 173				; 000000adH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@plus_op
$LN14@plus_op:

; 1810 :             }
; 1811 :             opnd1->label_tok = opnd2->label_tok;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	mov	QWORD PTR [rax+40], rcx

; 1812 :             opnd1->sym = opnd2->sym;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [rax+80], rcx

; 1813 :             /* v2.05: added */
; 1814 :             if ( opnd1->mem_type == MT_EMPTY )

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	jne	SHORT $LN15@plus_op

; 1815 :                 opnd1->mem_type = opnd2->mem_type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+64], ecx
$LN15@plus_op:

; 1816 :             /* v2.10: copy qualifier ( [<reg>+imagerel xxx] */
; 1817 :             if ( opnd2->instr != EMPTY )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+56], -2
	je	SHORT $LN16@plus_op

; 1818 :                 opnd1->instr = opnd2->instr;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax+56], ecx
$LN16@plus_op:
$LN13@plus_op:

; 1819 :         }
; 1820 :         opnd1->llvalue += opnd2->llvalue;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR opnd2$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 1821 :         /* v2.08: added, test case [ecx+ebx.<struc>].<mbr> */
; 1822 :         if ( opnd2->type )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN17@plus_op

; 1823 :             opnd1->type = opnd2->type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx
$LN17@plus_op:

; 1824 : 
; 1825 :     } else if( check_both( opnd1, opnd2, EXPR_CONST, EXPR_ADDR ) ) {

	jmp	$LN11@plus_op
$LN10@plus_op:
	mov	r9d, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	check_both
	movzx	eax, al
	test	eax, eax
	je	$LN18@plus_op

; 1826 : 
; 1827 :         if( opnd1->kind == EXPR_CONST ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	$LN20@plus_op

; 1828 :             DebugMsg1(("plus_op: CONST - ADDR\n" ));

	lea	rcx, OFFSET FLAT:$SG11776
	call	DoDebugMsg1

; 1829 :             opnd2->llvalue += opnd1->llvalue;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR opnd1$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	QWORD PTR [rcx], rax

; 1830 :             opnd2->indirect |= opnd1->indirect;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, 1
	or	eax, ecx
	and	eax, 1
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	and	ecx, -2					; fffffffeH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 1831 : 
; 1832 :             if( opnd1->explicit == TRUE ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN22@plus_op

; 1833 :                 opnd2->explicit = TRUE;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 2
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 1834 :                 opnd2->mem_type = opnd1->mem_type;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+64], ecx
	jmp	SHORT $LN23@plus_op
$LN22@plus_op:

; 1835 :             } else if ( opnd2->mem_type == MT_EMPTY )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	jne	SHORT $LN24@plus_op

; 1836 :                 opnd2->mem_type = opnd1->mem_type;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+64], ecx
$LN24@plus_op:
$LN23@plus_op:

; 1837 : 
; 1838 :             /* v2.05: added. See dotop2.asm, "mov eax, v2.f1[ebx*2]" */
; 1839 :             if ( opnd2->mbr == NULL )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+88], 0
	jne	SHORT $LN25@plus_op

; 1840 :                 opnd2->mbr = opnd1->mbr;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	QWORD PTR [rax+88], rcx
$LN25@plus_op:

; 1841 : 
; 1842 :             /* v2.08: added, test case [4+ebx.<struc>].<mbr> */
; 1843 :             if ( opnd2->type )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN26@plus_op

; 1844 :                 opnd1->type = opnd2->type; /* set <type> in op1! */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx
$LN26@plus_op:

; 1845 : 
; 1846 :             TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 1847 : 
; 1848 :         } else {

	jmp	$LN21@plus_op
$LN20@plus_op:

; 1849 :             DebugMsg1(("plus_op: ADDR - CONST\n" ));

	lea	rcx, OFFSET FLAT:$SG11782
	call	DoDebugMsg1

; 1850 :             opnd1->llvalue += opnd2->llvalue;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR opnd2$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 1851 :             /* v2.04: added. to make this case behave like
; 1852 :              * the CONST - REG case (see below).
; 1853 :              */
; 1854 :             /* v2.08: changed, test case [reg+struct] */
; 1855 :             //if ( opnd1->mem_type == MT_EMPTY )
; 1856 :             if ( opnd2->mbr ) { /* v2.10: added; regression test dotop5.asm */

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN27@plus_op

; 1857 :                 opnd1->mbr = opnd2->mbr;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	QWORD PTR [rax+88], rcx

; 1858 :                 opnd1->mem_type = opnd2->mem_type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+64], ecx

; 1859 :             } else

	jmp	SHORT $LN28@plus_op
$LN27@plus_op:

; 1860 :             if ( opnd1->mem_type == MT_EMPTY && opnd2->is_type == FALSE )

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	jne	SHORT $LN29@plus_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN29@plus_op

; 1861 :                 opnd1->mem_type = opnd2->mem_type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+64], ecx
$LN29@plus_op:
$LN28@plus_op:
$LN21@plus_op:

; 1862 :         }
; 1863 :         fix_struct_value( opnd1 );

	mov	rcx, QWORD PTR opnd1$[rsp]
	call	fix_struct_value

; 1864 :     } else {

	jmp	SHORT $LN19@plus_op
$LN18@plus_op:

; 1865 :         DebugMsg(("plus_op: error, unexpected format: %u - %u\n", opnd1->kind, opnd2->kind ));

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+60]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax+60]
	lea	rcx, OFFSET FLAT:$SG11786
	call	DoDebugMsg

; 1866 :         return( ConstError( opnd1, opnd2 ) );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	ConstError
	jmp	SHORT $LN1@plus_op
$LN19@plus_op:
$LN11@plus_op:
$LN9@plus_op:

; 1867 :     }
; 1868 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@plus_op:

; 1869 : }

	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
plus_op	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
i$1 = 32
dir$2 = 40
fl$3 = 48
tv176 = 56
oper$ = 80
opnd1$ = 88
opnd2$ = 96
sym$ = 104
name$ = 112
wimask_op PROC

; 1690 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+80]

; 1691 :     /* additional check needed if operand is a type */
; 1692 :     if ( opnd2->is_type ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@wimask_op

; 1693 :         sym = opnd2->type;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR sym$[rsp], rax

; 1694 :         if (sym->typekind != TYPE_RECORD ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 4
	je	SHORT $LN10@wimask_op

; 1695 :             return( fnEmitErr( OPERAND_MUST_BE_RECORD ) );

	mov	ecx, 161				; 000000a1H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@wimask_op
$LN10@wimask_op:

; 1696 :         }

	jmp	SHORT $LN9@wimask_op
$LN8@wimask_op:

; 1697 :     } else if ( opnd2->kind == EXPR_CONST ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN11@wimask_op

; 1698 :         sym = opnd2->mbr;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR sym$[rsp], rax

; 1699 :     } else {

	jmp	SHORT $LN12@wimask_op
$LN11@wimask_op:

; 1700 :         sym = opnd2->sym;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym$[rsp], rax
$LN12@wimask_op:
$LN9@wimask_op:

; 1701 :     }
; 1702 :     if ( oper == T_MASK ) {

	cmp	DWORD PTR oper$[rsp], 240		; 000000f0H
	jne	$LN13@wimask_op

; 1703 :         int i;
; 1704 :         opnd1->value = 0;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax], 0

; 1705 :         if ( opnd2->is_type ) { /* get mask of the RECORD? */

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN15@wimask_op

; 1706 : #if AMD64_SUPPORT
; 1707 :             opnd1->llvalue = GetRecordMask( (struct dsym *)sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetRecordMask
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 1708 : #else
; 1709 :             opnd1->value = GetRecordMask( (struct dsym *)sym );
; 1710 : #endif
; 1711 :         } else { /* get mask of the bitfield */

	jmp	SHORT $LN16@wimask_op
$LN15@wimask_op:

; 1712 :             for ( i = sym->offset ;i < sym->offset + sym->total_size; i++ )

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR i$1[rsp], eax
	jmp	SHORT $LN4@wimask_op
$LN2@wimask_op:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@wimask_op:
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR sym$[rsp]
	add	eax, DWORD PTR [rcx+56]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN3@wimask_op

; 1713 : #if AMD64_SUPPORT
; 1714 : #if defined(LLONG_MAX) || defined(__GNUC__) || defined(__TINYC__)
; 1715 :                 opnd1->llvalue |= 1ULL << i;

	mov	eax, DWORD PTR i$1[rsp]
	mov	ecx, 1
	mov	QWORD PTR tv176[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv176[rsp]
	shl	rax, cl
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR [rcx]
	or	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	SHORT $LN2@wimask_op
$LN3@wimask_op:
$LN16@wimask_op:

; 1716 : #else
; 1717 :                 opnd1->llvalue |= 1i64 << i;
; 1718 : #endif
; 1719 : #else
; 1720 :                 opnd1->value |= 1 << i;
; 1721 : #endif
; 1722 :         }
; 1723 :     } else {

	jmp	SHORT $LN14@wimask_op
$LN13@wimask_op:

; 1724 :         if ( opnd2->is_type ) { /* get width of the RECORD? */

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN17@wimask_op

; 1725 :             struct dsym *dir = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR dir$2[rsp], rax

; 1726 :             struct sfield *fl;
; 1727 :             for ( fl = dir->e.structinfo->head; fl; fl = fl->next )

	mov	rax, QWORD PTR dir$2[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR fl$3[rsp], rax
	jmp	SHORT $LN7@wimask_op
$LN5@wimask_op:
	mov	rax, QWORD PTR fl$3[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR fl$3[rsp], rax
$LN7@wimask_op:
	cmp	QWORD PTR fl$3[rsp], 0
	je	SHORT $LN6@wimask_op

; 1728 :                 opnd1->value += fl->sym.total_size;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR fl$3[rsp]
	add	eax, DWORD PTR [rcx+56]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN5@wimask_op
$LN6@wimask_op:

; 1729 :         } else

	jmp	SHORT $LN18@wimask_op
$LN17@wimask_op:

; 1730 :             opnd1->value = sym->total_size;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax], ecx
$LN18@wimask_op:
$LN14@wimask_op:

; 1731 :     }
; 1732 :     opnd1->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 0

; 1733 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@wimask_op:

; 1734 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
wimask_op ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
tv87 = 32
oper$ = 64
opnd1$ = 72
opnd2$ = 80
sym$ = 88
name$ = 96
this_op	PROC

; 1647 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+64]

; 1648 :     if ( opnd2->is_type == FALSE ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN2@this_op

; 1649 :         return( fnEmitErr( INVALID_TYPE_EXPRESSION ) );

	mov	ecx, 179				; 000000b3H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@this_op
$LN2@this_op:

; 1650 :     }
; 1651 :     /* v2.06: won't work inside structs */
; 1652 :     if ( CurrStruct ) {

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN3@this_op

; 1653 :         return( fnEmitErr( MUST_BE_IN_SEGMENT_BLOCK ) );

	mov	ecx, 82					; 00000052H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@this_op
$LN3@this_op:

; 1654 :     }
; 1655 :     /* v2.06: won't work outside segments */
; 1656 :     if ( CurrSeg == NULL ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN4@this_op

; 1657 :         return( EmitErr( MUST_BE_IN_SEGMENT_BLOCK ) ); /* error displayed even in EQU, hence EmitErr()! */

	mov	ecx, 82					; 00000052H
	call	EmitErr
	jmp	$LN1@this_op
$LN4@this_op:

; 1658 :     }
; 1659 : 
; 1660 :     if ( thissym == NULL ) {

	cmp	QWORD PTR thissym, 0
	jne	SHORT $LN5@this_op

; 1661 :         thissym = SymAlloc( "" );

	lea	rcx, OFFSET FLAT:$SG11689
	call	SymAlloc
	mov	QWORD PTR thissym, rax

; 1662 :         /* fixme: set thissym->variable? */
; 1663 :         thissym->state = SYM_INTERNAL;

	mov	rax, QWORD PTR thissym
	mov	DWORD PTR [rax+32], 1

; 1664 :         thissym->isdefined = TRUE;

	mov	rax, QWORD PTR thissym
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR thissym
	mov	BYTE PTR [rcx+40], al
$LN5@this_op:

; 1665 :     }
; 1666 : 
; 1667 :     DebugMsg1(("this_op: memtype=%Xh type=%s\n", opnd2->mem_type, opnd2->type ? opnd2->type->name : "NULL" ));

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN9@this_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv87[rsp], rax
	jmp	SHORT $LN10@this_op
$LN9@this_op:
	lea	rax, OFFSET FLAT:$SG11690
	mov	QWORD PTR tv87[rsp], rax
$LN10@this_op:
	mov	r8, QWORD PTR tv87[rsp]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	edx, DWORD PTR [rax+64]
	lea	rcx, OFFSET FLAT:$SG11691
	call	DoDebugMsg1

; 1668 :     opnd1->kind = EXPR_ADDR;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 1

; 1669 : 
; 1670 :     /* v2.09: a label is not a valid argument */
; 1671 :     //if ( opnd2->sym && opnd2->sym->mem_type == MT_TYPE )
; 1672 :     //    thissym->type = opnd2->sym->type;
; 1673 :     /* v2.09: set structured type */
; 1674 :     thissym->type = opnd2->type;

	mov	rax, QWORD PTR thissym
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+80], rcx

; 1675 :     if ( opnd2->type ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN6@this_op

; 1676 :         thissym->mem_type = MT_TYPE;

	mov	rax, QWORD PTR thissym
	mov	DWORD PTR [rax+36], 196			; 000000c4H

; 1677 :     } else

	jmp	SHORT $LN7@this_op
$LN6@this_op:

; 1678 :         thissym->mem_type = opnd2->mem_type;

	mov	rax, QWORD PTR thissym
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+36], ecx
$LN7@this_op:

; 1679 : 
; 1680 :     opnd1->sym  = thissym;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR thissym
	mov	QWORD PTR [rax+80], rcx

; 1681 :     SetSymSegOfs( thissym );

	mov	rcx, QWORD PTR thissym
	call	SetSymSegOfs

; 1682 :     opnd1->mem_type = thissym->mem_type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR thissym
	mov	ecx, DWORD PTR [rcx+36]
	mov	DWORD PTR [rax+64], ecx

; 1683 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@this_op:

; 1684 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
this_op	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
tv83 = 48
oper$ = 80
opnd1$ = 88
opnd2$ = 96
sym$ = 104
name$ = 112
high32_op PROC

; 1624 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+80]

; 1625 :     /* v2.06: added support for double constants */
; 1626 :     if ( opnd2->kind == EXPR_FLOAT ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 3
	jne	$LN2@high32_op

; 1627 :         if ( Options.strict_masm_compat )

	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	je	SHORT $LN3@high32_op

; 1628 :             return( ConstError( opnd1, opnd2 ) );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	ConstError
	jmp	$LN1@high32_op
$LN3@high32_op:

; 1629 :         atofloat( &opnd2->llvalue, opnd2->float_tok->string_ptr, sizeof( opnd2->llvalue), opnd2->negative, opnd2->float_tok->floattype );

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	shr	ecx, 5
	and	ecx, 1
	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	r8, QWORD PTR opnd2$[rsp]
	mov	QWORD PTR tv83[rsp], r8
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR [rsp+32], al
	movzx	r9d, cl
	mov	r8d, 8
	mov	rdx, QWORD PTR [rdx+8]
	mov	rax, QWORD PTR tv83[rsp]
	mov	rcx, rax
	call	atofloat

; 1630 :         opnd2->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rax+60], 0

; 1631 :         opnd2->float_tok = NULL;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	QWORD PTR [rax+16], 0
$LN2@high32_op:

; 1632 :     }
; 1633 :     TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 1634 :     if ( opnd2->kind == EXPR_ADDR && opnd2->instr != T_SEG ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN4@high32_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+56], 244			; 000000f4H
	je	SHORT $LN4@high32_op

; 1635 :         opnd1->instr = T_HIGH32;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+56], 231			; 000000e7H

; 1636 :         //opnd1->mem_type = MT_DWORD; /* v2.10: changed - also see change in parser.c, idata_fixup() */
; 1637 :         opnd1->mem_type = MT_EMPTY;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+64], 192			; 000000c0H
$LN4@high32_op:

; 1638 :     }
; 1639 :     opnd1->llvalue = opnd1->llvalue >> 32;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	shr	rax, 32					; 00000020H
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 1640 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@high32_op:

; 1641 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
high32_op ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
tv83 = 48
oper$ = 80
opnd1$ = 88
opnd2$ = 96
sym$ = 104
name$ = 112
low32_op PROC

; 1603 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+80]

; 1604 :     /* v2.06: added support for double constants */
; 1605 :     if ( opnd2->kind == EXPR_FLOAT ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 3
	jne	$LN2@low32_op

; 1606 :         if ( Options.strict_masm_compat )

	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	je	SHORT $LN3@low32_op

; 1607 :             return( ConstError( opnd1, opnd2 ) );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	ConstError
	jmp	$LN1@low32_op
$LN3@low32_op:

; 1608 :         atofloat( &opnd2->llvalue, opnd2->float_tok->string_ptr, sizeof( opnd2->llvalue), opnd2->negative, opnd2->float_tok->floattype );

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	shr	ecx, 5
	and	ecx, 1
	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	r8, QWORD PTR opnd2$[rsp]
	mov	QWORD PTR tv83[rsp], r8
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR [rsp+32], al
	movzx	r9d, cl
	mov	r8d, 8
	mov	rdx, QWORD PTR [rdx+8]
	mov	rax, QWORD PTR tv83[rsp]
	mov	rcx, rax
	call	atofloat

; 1609 :         opnd2->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rax+60], 0

; 1610 :         opnd2->float_tok = NULL;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	QWORD PTR [rax+16], 0
$LN2@low32_op:

; 1611 :     }
; 1612 :     TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 1613 :     if ( opnd2->kind == EXPR_ADDR && opnd2->instr != T_SEG ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN4@low32_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+56], 244			; 000000f4H
	je	SHORT $LN4@low32_op

; 1614 :         opnd1->instr = T_LOW32;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+56], 237			; 000000edH

; 1615 :         //opnd1->mem_type = MT_DWORD; /* v2.10: changed - also see change in parser.c, idata_fixup() */
; 1616 :         opnd1->mem_type = MT_EMPTY;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+64], 192			; 000000c0H
$LN4@low32_op:

; 1617 :     }
; 1618 :     opnd1->llvalue &= 0xffffffff;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	ecx, -1					; ffffffffH
	mov	rax, QWORD PTR [rax]
	and	rax, rcx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 1619 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@low32_op:

; 1620 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
low32_op ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
oper$ = 48
opnd1$ = 56
opnd2$ = 64
sym$ = 72
name$ = 80
high_op	PROC

; 1579 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 1580 :     TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 1581 :     if ( opnd2->kind == EXPR_ADDR && opnd2->instr != T_SEG ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN2@high_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+56], 244			; 000000f4H
	je	SHORT $LN2@high_op

; 1582 :         /* v2.07: don't check any format-specific rules in the
; 1583 :          * expression evaluator!
; 1584 :          */
; 1585 : #if 0
; 1586 :         if ( Options.output_format != OFORMAT_OMF &&
; 1587 :             Options.output_format != OFORMAT_BIN && opnd2->sym ) {
; 1588 :             return( fnEmitErr( SYMBOL_TYPE_CONFLICT, opnd2->sym->name ) );
; 1589 :         }
; 1590 : #endif
; 1591 :         opnd1->instr = T_HIGH;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+56], 230			; 000000e6H

; 1592 :         opnd1->mem_type = MT_EMPTY;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+64], 192			; 000000c0H
$LN2@high_op:

; 1593 :     }
; 1594 :     opnd1->value = opnd1->value >> 8;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	sar	eax, 8
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax

; 1595 :     opnd1->llvalue &= 0xff;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 1596 :     return( NOT_ERROR );

	xor	eax, eax

; 1597 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
high_op	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
oper$ = 48
opnd1$ = 56
opnd2$ = 64
sym$ = 72
name$ = 80
low_op	PROC

; 1557 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 1558 :     TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 1559 :     if ( opnd2->kind == EXPR_ADDR && opnd2->instr != T_SEG ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN2@low_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+56], 244			; 000000f4H
	je	SHORT $LN2@low_op

; 1560 : #if 0
; 1561 :         /* LOW works for OMF/BIN only */
; 1562 :         /* v2.07: don't check any format-specific rules in the
; 1563 :          * expression evaluator!
; 1564 :          */
; 1565 :         if ( Options.output_format != OFORMAT_OMF &&
; 1566 :             Options.output_format != OFORMAT_BIN && opnd2->sym ) {
; 1567 :             return( fnEmitErr( SYMBOL_TYPE_CONFLICT, opnd2->sym->name ) );
; 1568 :         }
; 1569 : #endif
; 1570 :         opnd1->instr = T_LOW;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+56], 236			; 000000ecH

; 1571 :         opnd1->mem_type = MT_EMPTY;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+64], 192			; 000000c0H
$LN2@low_op:

; 1572 :     }
; 1573 :     opnd1->llvalue &= 0xff;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 1574 :     return( NOT_ERROR );

	xor	eax, eax

; 1575 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
low_op	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
oper$ = 48
opnd1$ = 56
opnd2$ = 64
sym$ = 72
name$ = 80
highword_op PROC

; 1544 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 1545 :     TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 1546 :     if ( opnd2->kind == EXPR_ADDR && opnd2->instr != T_SEG ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN2@highword_o
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+56], 244			; 000000f4H
	je	SHORT $LN2@highword_o

; 1547 :         opnd1->instr = T_HIGHWORD;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+56], 232			; 000000e8H

; 1548 :         //opnd1->mem_type = MT_WORD; /* v2.05 */
; 1549 :         opnd1->mem_type = MT_EMPTY;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+64], 192			; 000000c0H
$LN2@highword_o:

; 1550 :     }
; 1551 : 	opnd1->value = (opnd1->value >> 16) & 0xFFFF; /* ASMC v2.14 (fix borrowed from nidud) */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	sar	eax, 16
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax

; 1552 :     return( NOT_ERROR );

	xor	eax, eax

; 1553 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
highword_op ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
oper$ = 48
opnd1$ = 56
opnd2$ = 64
sym$ = 72
name$ = 80
lowword_op PROC

; 1531 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 1532 :     TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 1533 :     if ( opnd2->kind == EXPR_ADDR && opnd2->instr != T_SEG ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN2@lowword_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+56], 244			; 000000f4H
	je	SHORT $LN2@lowword_op

; 1534 :         opnd1->instr = T_LOWWORD;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+56], 238			; 000000eeH

; 1535 :         //opnd1->mem_type = MT_WORD; /* v2.05 */
; 1536 :         opnd1->mem_type = MT_EMPTY;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+64], 192			; 000000c0H
$LN2@lowword_op:

; 1537 :     }
; 1538 :     opnd1->llvalue &= 0xffff;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax]
	and	rax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rcx], rax

; 1539 :     return( NOT_ERROR );

	xor	eax, eax

; 1540 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
lowword_op ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
oper$ = 48
opnd1$ = 56
opnd2$ = 64
sym$ = 72
name$ = 80
offset_op PROC

; 1493 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 1494 :     if ( oper == T_OFFSET ) {

	cmp	DWORD PTR oper$[rsp], 241		; 000000f1H
	jne	SHORT $LN2@offset_op

; 1495 :         /* if operand is a constant value, skip OFFSET operator */
; 1496 :         if ( opnd2->kind == EXPR_CONST ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN3@offset_op

; 1497 :             TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 1498 :             return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@offset_op
$LN3@offset_op:
$LN2@offset_op:

; 1499 :         }
; 1500 :     }
; 1501 :     if ( (sym && sym->state == SYM_GRP) || opnd2->instr == T_SEG ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN6@offset_op
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 4
	je	SHORT $LN5@offset_op
$LN6@offset_op:
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+56], 244			; 000000f4H
	jne	SHORT $LN4@offset_op
$LN5@offset_op:

; 1502 :         return( invalid_operand( opnd2, GetResWName( oper, NULL ), name ) );

	xor	edx, edx
	mov	ecx, DWORD PTR oper$[rsp]
	call	GetResWName
	mov	r8, QWORD PTR name$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR opnd2$[rsp]
	call	invalid_operand
	jmp	SHORT $LN1@offset_op
$LN4@offset_op:

; 1503 :     }
; 1504 :     /* offset operator accepts types, but returns always 0 */
; 1505 :     if ( opnd2->is_type )

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@offset_op

; 1506 :         opnd2->value = 0;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rax], 0
$LN7@offset_op:

; 1507 : 
; 1508 :     TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 1509 :     opnd1->instr = oper;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR oper$[rsp]
	mov	DWORD PTR [rax+56], ecx

; 1510 : 
; 1511 :     if ( opnd2->indirect ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@offset_op

; 1512 :         /* Masm v5.1 allows indirect operands, but Masm v6 with -Zm
; 1513 :          * won't accept it.
; 1514 :          */
; 1515 :         return( invalid_operand( opnd2, GetResWName( oper, NULL ), name ) );

	xor	edx, edx
	mov	ecx, DWORD PTR oper$[rsp]
	call	GetResWName
	mov	r8, QWORD PTR name$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR opnd2$[rsp]
	call	invalid_operand
	jmp	SHORT $LN1@offset_op
$LN8@offset_op:

; 1516 :     }
; 1517 :     /* skip memory type of operand, just address is needed */
; 1518 :     //opnd1->mem_type = MT_NEAR;
; 1519 :     opnd1->mem_type = MT_EMPTY;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+64], 192			; 000000c0H

; 1520 :     /* clear overrides ("offset SEG:xxx") */
; 1521 :     /* v2.01: override information is important for fixup creation!
; 1522 :      * the reason why it was cleared probably was to avoid creation
; 1523 :      * of a segment prefix. This case is now handled in the parser.
; 1524 :      */
; 1525 :     // opnd1->override = NULL;
; 1526 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@offset_op:

; 1527 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
offset_op ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
oper$ = 48
opnd1$ = 56
opnd2$ = 64
sym$ = 72
name$ = 80
seg_op	PROC

; 1474 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 1475 :     /* v2.10: check for sym==NULL ( seg ds:[0] ) added */
; 1476 :     if ( opnd2->sym == NULL || opnd2->sym->state == SYM_STACK || opnd2->is_abs ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN3@seg_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 5
	je	SHORT $LN3@seg_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@seg_op
$LN3@seg_op:

; 1477 :         return( fnEmitErr( OPERAND_MUST_BE_RELOCATABLE ) );

	mov	ecx, 188				; 000000bcH
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN1@seg_op
$LN2@seg_op:

; 1478 :     }
; 1479 :     TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 1480 :     opnd1->instr = oper;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR oper$[rsp]
	mov	DWORD PTR [rax+56], ecx

; 1481 :     if ( opnd1->mbr ) /* v2.08: set value more selectively */

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN4@seg_op

; 1482 :         opnd1->value = 0;    /* v2.07: added ( SEG <member> ) */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax], 0
$LN4@seg_op:

; 1483 :     opnd1->mem_type = MT_EMPTY; /* v2.04a */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+64], 192			; 000000c0H

; 1484 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@seg_op:

; 1485 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
seg_op	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
oper$ = 48
opnd1$ = 56
opnd2$ = 64
sym$ = 72
name$ = 80
short_op PROC

; 1460 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 1461 :     if ( opnd2->kind != EXPR_ADDR ||

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN3@short_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	je	SHORT $LN2@short_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+64], 129			; 00000081H
	je	SHORT $LN2@short_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+64], 130			; 00000082H
	je	SHORT $LN2@short_op
$LN3@short_op:

; 1462 :         ( opnd2->mem_type != MT_EMPTY &&
; 1463 :          opnd2->mem_type != MT_NEAR &&
; 1464 :          opnd2->mem_type != MT_FAR ) ) {
; 1465 :         return( fnEmitErr( EXPRESSION_MUST_BE_A_CODE_ADDRESS ) );

	mov	ecx, 233				; 000000e9H
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN1@short_op
$LN2@short_op:

; 1466 :     }
; 1467 :     TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 1468 :     opnd1->instr = oper;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR oper$[rsp]
	mov	DWORD PTR [rax+56], ecx

; 1469 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@short_op:

; 1470 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
short_op ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
tv68 = 32
oper$ = 64
opnd1$ = 72
opnd2$ = 80
sym$ = 88
name$ = 96
opattr_op PROC

; 1357 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+64]

; 1358 : 
; 1359 :     DebugMsg1(("opattr_op: arg kind=%d memtype=%X sym=%s\n",

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN32@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv68[rsp], rax
	jmp	SHORT $LN33@opattr_op
$LN32@opattr_op:
	lea	rax, OFFSET FLAT:$SG11504
	mov	QWORD PTR tv68[rsp], rax
$LN33@opattr_op:
	mov	r9, QWORD PTR tv68[rsp]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+64]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	edx, DWORD PTR [rax+60]
	lea	rcx, OFFSET FLAT:$SG11505
	call	DoDebugMsg1

; 1360 :                opnd2->kind, opnd2->mem_type,
; 1361 :                opnd2->sym ? opnd2->sym->name : "NULL" ));
; 1362 :     opnd1->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 0

; 1363 :     opnd1->sym = NULL;  /* clear symbol in case it is undef */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	QWORD PTR [rax+80], 0

; 1364 :     opnd1->value = 0;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax], 0

; 1365 :     opnd1->mem_type = MT_EMPTY;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+64], 192			; 000000c0H

; 1366 :     opnd1->is_opattr = FALSE; /* v2: added */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, -17				; ffffffefH
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 1367 : 
; 1368 :     if ( opnd2->kind == EXPR_EMPTY )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], -2
	jne	SHORT $LN2@opattr_op

; 1369 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@opattr_op
$LN2@opattr_op:

; 1370 : 
; 1371 :     /* bit 0: code label (near|far)? */
; 1372 :     if ( opnd2->kind == EXPR_ADDR ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	$LN3@opattr_op

; 1373 :         if ( opnd2->sym && opnd2->sym->state != SYM_STACK &&

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN4@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 5
	je	SHORT $LN4@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN4@opattr_op

; 1374 :             ( opnd2->mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS )
; 1375 :             opnd1->value |= OPATTR_CODELABEL;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN4@opattr_op:

; 1376 : 
; 1377 :         if ( IsOffset( opnd2 ) &&
; 1378 :             opnd2->sym &&

	mov	rcx, QWORD PTR opnd2$[rsp]
	call	IsOffset
	test	eax, eax
	je	SHORT $LN5@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN5@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN5@opattr_op

; 1379 :             ( opnd2->sym->mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS )
; 1380 :             opnd1->value |= OPATTR_CODELABEL;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN5@opattr_op:

; 1381 : 
; 1382 :         /* bit 1: memory variable, relocatable data label? */
; 1383 :         if ( opnd2->sym &&

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN6@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	je	SHORT $LN7@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+64]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN7@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	jne	SHORT $LN6@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN6@opattr_op
$LN7@opattr_op:

; 1384 :             (( opnd2->sym->mem_type == MT_TYPE ||
; 1385 :               ( opnd2->mem_type & MT_SPECIAL ) == 0 ) ||
; 1386 :              ( opnd2->mem_type == MT_EMPTY &&
; 1387 :               ( opnd2->sym->mem_type & MT_SPECIAL ) == 0 )))
; 1388 :             opnd1->value |= OPATTR_DATALABEL;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	or	eax, 2
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN6@opattr_op:
$LN3@opattr_op:

; 1389 :     }
; 1390 :     /* kind==EXPR_ADDR is not reliably set for indirect register addressing! */
; 1391 :     /* v2.12: check if operand is valid */
; 1392 :     //if ( opnd2->indirect )
; 1393 :     if ( opnd2->kind != EXPR_ERROR && opnd2->indirect )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], -1
	je	SHORT $LN8@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@opattr_op

; 1394 :         opnd1->value |= OPATTR_DATALABEL;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	or	eax, 2
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN8@opattr_op:

; 1395 : 
; 1396 : 
; 1397 :     /* bit 2: immediate value? */
; 1398 : 	/* John Hankinson modified here to allow -Zne switch to treat literal string macro argument with opattr type = 0 */
; 1399 : 	if (Options.strict_masm_compat && opnd2->kind == EXPR_CONST && opnd2->mem_type != MT_SQWORD && opnd2->quoted_string != NULL)

	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	je	SHORT $LN9@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN9@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+64], 71			; 00000047H
	je	SHORT $LN9@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN9@opattr_op

; 1400 : 	{
; 1401 : 	}

	jmp	$LN10@opattr_op
$LN9@opattr_op:

; 1402 :     else if ( opnd2->kind == EXPR_CONST ||

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	je	SHORT $LN12@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN11@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN11@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	jne	SHORT $LN14@opattr_op
	mov	rcx, QWORD PTR opnd2$[rsp]
	call	IsOffset
	test	eax, eax
	jne	SHORT $LN13@opattr_op
$LN14@opattr_op:
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	je	SHORT $LN13@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN11@opattr_op
$LN13@opattr_op:
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 1
	je	SHORT $LN15@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN11@opattr_op
$LN15@opattr_op:
$LN12@opattr_op:

; 1403 :         ( opnd2->kind == EXPR_ADDR &&
; 1404 :          opnd2->indirect == FALSE &&
; 1405 :          (( opnd2->mem_type == MT_EMPTY && IsOffset(opnd2) ) ||
; 1406 :           //( opnd2->mem_type == MT_ABS ) ||  /* v2.06: added (abs. external) */
; 1407 :           ( opnd2->mem_type == MT_EMPTY ) ||  /* v2.06: added (abs. external) */
; 1408 :           (( opnd2->mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS )) &&
; 1409 :          ( opnd2->sym->state == SYM_INTERNAL ||
; 1410 :           opnd2->sym->state == SYM_EXTERNAL ) ) )
; 1411 :         opnd1->value |= OPATTR_IMMEDIATE;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	or	eax, 4
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN11@opattr_op:
$LN10@opattr_op:

; 1412 : 
; 1413 :     /* bit 3: uses direct memory addressing?
; 1414 :      */
; 1415 :     if ( opnd2->kind == EXPR_ADDR &&
; 1416 :         opnd2->indirect == FALSE &&
; 1417 :         //opnd2->base_reg == NULL &&
; 1418 :         (( opnd2->mem_type == MT_EMPTY && opnd2->instr == EMPTY ) ||
; 1419 :          ( opnd2->mem_type == MT_TYPE ) || /* v2.05: added */
; 1420 :          (( opnd2->mem_type & MT_SPECIAL ) == 0 ) ||
; 1421 :          opnd2->mem_type == MT_PTR ) &&

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	$LN16@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	$LN16@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	jne	SHORT $LN18@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+56], -2
	je	SHORT $LN17@opattr_op
$LN18@opattr_op:
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+64], 196			; 000000c4H
	je	SHORT $LN17@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+64]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN17@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+64], 195			; 000000c3H
	jne	SHORT $LN16@opattr_op
$LN17@opattr_op:
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN19@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 1
	je	SHORT $LN19@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN16@opattr_op
$LN19@opattr_op:

; 1422 :         (opnd2->sym == NULL ||
; 1423 :          opnd2->sym->state == SYM_INTERNAL ||
; 1424 :          opnd2->sym->state == SYM_EXTERNAL ) )
; 1425 :         opnd1->value |= OPATTR_DIRECTMEM;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	or	eax, 8
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN16@opattr_op:

; 1426 : 
; 1427 :     if ( opnd2->kind == EXPR_REG && opnd2->indirect == FALSE )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN20@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN20@opattr_op

; 1428 :         opnd1->value |= OPATTR_REGISTER;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	or	eax, 16
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN20@opattr_op:

; 1429 : 
; 1430 :     //if ( opnd2->kind != EXPR_ERROR && ( opnd2->sym == 0 || opnd2->sym->isdefined == TRUE ) )
; 1431 : 	/* John Hankinson modified here to allow -Zne switch to treat literal string macro argument with opattr type = 0 */
; 1432 : 	if (Options.strict_masm_compat && opnd2->kind == EXPR_CONST && opnd2->mem_type != MT_SQWORD && opnd2->quoted_string != NULL)

	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	je	SHORT $LN21@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN21@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+64], 71			; 00000047H
	je	SHORT $LN21@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN21@opattr_op

; 1433 : 	{
; 1434 : 	}

	jmp	SHORT $LN22@opattr_op
$LN21@opattr_op:

; 1435 :     else if ( opnd2->kind != EXPR_ERROR && opnd2->kind != EXPR_FLOAT && ( opnd2->sym == NULL || opnd2->sym->isdefined == TRUE ) )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], -1
	je	SHORT $LN23@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 3
	je	SHORT $LN23@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN24@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN23@opattr_op
$LN24@opattr_op:

; 1436 :         opnd1->value |= OPATTR_DEFINED; 

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	or	eax, 32					; 00000020H
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN23@opattr_op:
$LN22@opattr_op:

; 1437 : 
; 1438 :     if ( ( opnd2->sym && opnd2->sym->state == SYM_STACK ) ||

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN27@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 5
	je	SHORT $LN26@opattr_op
$LN27@opattr_op:
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN25@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN25@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax+4]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN25@opattr_op
$LN26@opattr_op:

; 1439 :         ( opnd2->indirect && opnd2->base_reg &&
; 1440 :          /* v2.11: use new flag SFR_SSBASED */
; 1441 :          //( opnd2->base_reg->tokval == T_ESP || opnd2->base_reg->tokval == T_EBP || opnd2->base_reg->tokval == T_BP ) ) )
; 1442 :          ( GetSflagsSp( opnd2->base_reg->tokval ) & SFR_SSBASED ) ) )
; 1443 :             opnd1->value |= OPATTR_SSREL;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN25@opattr_op:

; 1444 :     
; 1445 :     if ( opnd2->sym && opnd2->sym->state == SYM_EXTERNAL )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN28@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN28@opattr_op

; 1446 :         opnd1->value |= OPATTR_EXTRNREF;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax]
	bts	eax, 7
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN28@opattr_op:

; 1447 : 
; 1448 :     if ( oper == T_OPATTR )

	cmp	DWORD PTR oper$[rsp], 242		; 000000f2H
	jne	SHORT $LN29@opattr_op

; 1449 :         /* v2.12: no language if symbol isn't defined properly */
; 1450 :         //if ( opnd2->sym )
; 1451 :         if ( opnd2->sym && opnd2->kind != EXPR_ERROR )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN30@opattr_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], -1
	je	SHORT $LN30@opattr_op

; 1452 :             opnd1->value |= opnd2->sym->langtype << 8;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	eax, DWORD PTR [rax+76]
	shl	eax, 8
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN30@opattr_op:
$LN29@opattr_op:

; 1453 : 
; 1454 :     DebugMsg1(("opattr_op returns %Xh\n", opnd1->value));

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11535
	call	DoDebugMsg1

; 1455 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@opattr_op:

; 1456 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
opattr_op ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
tv78 = 64
tv82 = 72
tv132 = 80
tv413 = 84
tv307 = 88
tv540 = 92
tv322 = 96
tv336 = 104
oper$ = 128
opnd1$ = 136
opnd2$ = 144
sym$ = 152
name$ = 160
type_op	PROC

; 1176 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+128]

; 1177 :     DebugMsg1(("type_op: opnd2 kind=%d memtype=%X sym=%s type=%s instr=%d istype=%u explicit=%u\n",

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN42@type_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv78[rsp], rax
	jmp	SHORT $LN43@type_op
$LN42@type_op:
	lea	rax, OFFSET FLAT:$SG11434
	mov	QWORD PTR tv78[rsp], rax
$LN43@type_op:
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN44@type_op
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv82[rsp], rax
	jmp	SHORT $LN45@type_op
$LN44@type_op:
	lea	rax, OFFSET FLAT:$SG11435
	mov	QWORD PTR tv82[rsp], rax
$LN45@type_op:
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	shr	ecx, 3
	and	ecx, 1
	mov	DWORD PTR [rsp+56], eax
	mov	DWORD PTR [rsp+48], ecx
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR tv78[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv82[rsp]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rax+64]
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	edx, DWORD PTR [rax+60]
	lea	rcx, OFFSET FLAT:$SG11436
	call	DoDebugMsg1

; 1178 :                opnd2->kind,
; 1179 :                opnd2->mem_type,
; 1180 :                sym ? sym->name : "NULL",
; 1181 :                opnd2->type ? opnd2->type->name : "NULL",
; 1182 :                opnd2->instr,
; 1183 :                opnd2->is_type,
; 1184 :                opnd2->explicit ));
; 1185 :     opnd1->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 0

; 1186 :     /* TYPE accepts arrays/structs/unions */
; 1187 :     /* v2.11: if memtype isn't empty, ignore any unary operator
; 1188 :      * test cases:
; 1189 :      * - type qword ptr sym.
; 1190 :      * - type qword ptr offset sym
; 1191 :      * operators LOW, HIGH, LOWWORD, HIGHWORD, LOW32, HIGH32,
; 1192 :      * OFFSET, IMAGEREL, SECTIONREL and LROFFSET
; 1193 :      * will set opnd.memtype to MT_EMPTY.
; 1194 :      */
; 1195 :     if( opnd2->instr != EMPTY && opnd2->mem_type != MT_EMPTY ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+56], -2
	je	SHORT $LN4@type_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	je	SHORT $LN4@type_op

; 1196 :         opnd2->instr = EMPTY;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rax+56], -2

; 1197 :         sym = NULL;

	mov	QWORD PTR sym$[rsp], 0
$LN4@type_op:

; 1198 :     }
; 1199 :     if( opnd2->instr != EMPTY ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+56], -2
	je	$LN5@type_op

; 1200 :         if ( opnd2->sym ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	$LN7@type_op

; 1201 :             switch ( opnd2->instr ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR tv132[rsp], eax
	mov	eax, DWORD PTR tv132[rsp]
	sub	eax, 230				; 000000e6H
	mov	DWORD PTR tv132[rsp], eax
	cmp	DWORD PTR tv132[rsp], 13
	ja	$LN2@type_op
	movsxd	rax, DWORD PTR tv132[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN52@type_op[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN8@type_op:

; 1202 :             case T_LOW:
; 1203 :             case T_HIGH:
; 1204 :                 opnd1->value = 1;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax], 1

; 1205 :                 break;

	jmp	SHORT $LN2@type_op
$LN9@type_op:

; 1206 :             case T_LOWWORD:
; 1207 :             case T_HIGHWORD:
; 1208 :                 //case T_SEG: /* masm returns 0 for TYPE SEG <label>! */
; 1209 :                 opnd1->value = 2;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax], 2

; 1210 :                 break;

	jmp	SHORT $LN2@type_op
$LN10@type_op:

; 1211 : #if LOHI32
; 1212 :             case T_LOW32:
; 1213 :             case T_HIGH32:
; 1214 :                 opnd1->value = 4;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax], 4

; 1215 :                 break;

	jmp	SHORT $LN2@type_op
$LN11@type_op:

; 1216 : #endif
; 1217 :             case T_OFFSET:
; 1218 :             case T_LROFFSET:
; 1219 : #if SECTIONRELSUPP
; 1220 :             case T_SECTIONREL: /* masm returns 0 for TYPE SECTIONREL <label>! */
; 1221 : #endif
; 1222 : #if IMAGERELSUPP
; 1223 :             case T_IMAGEREL: /* masm returns 0 for TYPE IMAGEREL <label>! */
; 1224 : #endif
; 1225 :                 opnd1->value = 2 << GetSymOfssize( opnd2->sym );

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	GetSymOfssize
	mov	ecx, 2
	mov	DWORD PTR tv413[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv413[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax

; 1226 :                 opnd1->is_type = TRUE; /* v2.03: added */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 8
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax
$LN2@type_op:
$LN7@type_op:

; 1227 :                 break;
; 1228 :             }
; 1229 :         }

	jmp	$LN6@type_op
$LN5@type_op:

; 1230 :     } else if ( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	$LN12@type_op

; 1231 :         //printf( "sym=NULL kind=%d mem_type=%X indirect=%u is_type=%u type=%s\n", opnd2->kind, opnd2->mem_type, opnd2->indirect, opnd2->is_type, opnd2->type ? opnd2->type->name : "NULL" );
; 1232 :         /* for types, return total_size */
; 1233 :         if ( opnd2->is_type == TRUE ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN14@type_op

; 1234 :             /* v2.06: default value of RECORD types is the mask! */
; 1235 :             if ( opnd2->type && opnd2->type->typekind == TYPE_RECORD )

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN16@type_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 4
	jne	SHORT $LN16@type_op

; 1236 :                 opnd2->value = opnd2->type->total_size;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rcx], eax
$LN16@type_op:

; 1237 :             //opnd1->value = opnd2->value;
; 1238 :             TokenAssign( opnd1, opnd2 );

	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	TokenAssign

; 1239 :             /* v2.05: added, (type procptr) ptr <reg>
; 1240 :              * the type probably should be set generally,
; 1241 :              * but this variant is the one used by INVOKE, other
; 1242 :              * usages are virtually irrelevant.
; 1243 :              * v2.10: opnd1->type now always set. Example:
; 1244 :              *   ( type x ) eq ( type y )
; 1245 :              * also see new function cmp_types()
; 1246 :              */
; 1247 :             //if ( opnd2->mem_type == MT_PROC )
; 1248 :             opnd1->type = opnd2->type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx
	jmp	$LN15@type_op
$LN14@type_op:

; 1249 : 
; 1250 :         } else if ( opnd2->kind == EXPR_REG && opnd2->indirect == FALSE ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	$LN17@type_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	$LN17@type_op

; 1251 :             opnd1->value = SizeFromRegister( opnd2->base_reg->tokval );

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	ecx, DWORD PTR [rax+16]
	call	SizeFromRegister
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax

; 1252 :             opnd1->is_type = TRUE; /* v2.03: added */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 8
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 1253 :             /* v2.10: check for assumes if it's a full size GPR */
; 1254 :             if ( opnd1->value == CurrWordSize &&
; 1255 :                 opnd1->mem_type == MT_EMPTY &&
; 1256 :                 ( GetValueSp( opnd2->base_reg->tokval ) & OP_RGT8 ) &&

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	rcx, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rcx], eax
	jne	$LN19@type_op
	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	jne	$LN19@type_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 14
	test	eax, eax
	je	$LN19@type_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+24]
	movzx	eax, BYTE PTR [rax+1]
	mov	ecx, eax
	call	GetStdAssumeEx
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN19@type_op

; 1257 :                 ( sym = GetStdAssumeEx( opnd2->base_reg->bytval ) ) ) {
; 1258 :                 DebugMsg1(("type_op: assume type=%X [name=>%s< memtype=%X]\n", sym, sym->name, sym->mem_type ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+36]
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR sym$[rsp]
	lea	rcx, OFFSET FLAT:$SG11454
	call	DoDebugMsg1

; 1259 :                 opnd1->type = sym;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+96], rcx

; 1260 :                 opnd1->mem_type = sym->mem_type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	mov	DWORD PTR [rax+64], ecx

; 1261 :                 opnd1->value = sym->total_size;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax], ecx

; 1262 :             } else {

	jmp	SHORT $LN20@type_op
$LN19@type_op:

; 1263 :                 opnd1->mem_type = opnd2->mem_type; /* v2.10: added */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+64], ecx

; 1264 :                 opnd1->type = opnd2->type; /* v2.10: added */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx

; 1265 :                 if ( opnd1->mem_type == MT_EMPTY )

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	jne	SHORT $LN21@type_op

; 1266 :                     MemtypeFromSize( opnd1->value, &opnd1->mem_type ); /* v2.03: added */

	mov	rax, QWORD PTR opnd1$[rsp]
	add	rax, 64					; 00000040H
	mov	rdx, rax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rax]
	call	MemtypeFromSize
$LN21@type_op:
$LN20@type_op:

; 1267 :             }

	jmp	$LN18@type_op
$LN17@type_op:

; 1268 : 
; 1269 : #if 0 /* Masm returns 0 for TYPE <segment_register> */
; 1270 :             /* if it is a segment register, use default word size */
; 1271 :             if ( opnd1->value == 0 )
; 1272 :                 opnd1->value = Use32 ? 4 : 2;
; 1273 : #endif
; 1274 :         //} else if ( opnd2->explicit ) { /* v2.05: changed */
; 1275 :         //} else if ( opnd2->mem_type != MT_EMPTY ) { /* v2.10: changed */
; 1276 :         } else if ( opnd2->mem_type != MT_EMPTY || opnd2->explicit ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	jne	SHORT $LN24@type_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	$LN22@type_op
$LN24@type_op:

; 1277 :             if ( opnd2->mem_type != MT_EMPTY ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	je	SHORT $LN25@type_op

; 1278 :                 opnd1->value = SizeFromMemtype( opnd2->mem_type, opnd2->Ofssize, opnd2->type );

	mov	rax, QWORD PTR opnd2$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	r8, QWORD PTR [rcx+96]
	mov	edx, eax
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rax+64]
	call	SizeFromMemtype
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax

; 1279 :                 opnd1->mem_type = opnd2->mem_type; /* v2.04: added */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+64], ecx

; 1280 :             } else {

	jmp	SHORT $LN26@type_op
$LN25@type_op:

; 1281 :                 if ( opnd2->type ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN27@type_op

; 1282 :                     opnd1->value = opnd2->type->total_size;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rcx], eax

; 1283 :                     opnd1->mem_type = opnd2->type->mem_type;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rcx+64], eax
$LN27@type_op:
$LN26@type_op:

; 1284 :                 }
; 1285 :             }
; 1286 :             opnd1->is_type = TRUE; /* v2.04: added */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 8
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 1287 :             opnd1->type = opnd2->type; /* v2.09: added */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx

; 1288 :         } else /* it is a number or EXPR_REG + indirect */

	jmp	SHORT $LN23@type_op
$LN22@type_op:

; 1289 :             opnd1->value = 0;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax], 0
$LN23@type_op:
$LN18@type_op:
$LN15@type_op:

; 1290 : #if 0
; 1291 :     } else if ( sym->state == SYM_TYPE ) {
; 1292 :         TokenAssign( opnd1, opnd2 );
; 1293 :         opnd1->type = sym;
; 1294 : #endif
; 1295 :     } else if ( sym->state == SYM_UNDEFINED ) { /* v2.10: added */

	jmp	$LN13@type_op
$LN12@type_op:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN28@type_op

; 1296 :         opnd1->kind = EXPR_ADDR;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 1

; 1297 :         opnd1->sym = sym;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+80], rcx

; 1298 :         /* is_type must be set, to avoid the forward referenced symbol be changed
; 1299 :          * to a type if the type expression is the left operand of PTR
; 1300 :          */
; 1301 :         opnd1->is_type = TRUE;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 8
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax
	jmp	$LN29@type_op
$LN28@type_op:

; 1302 :         //} else if( sym->mem_type == MT_TYPE ) { /* v2.04: check for explicit */
; 1303 :     } else if( sym->mem_type == MT_TYPE && opnd2->explicit == FALSE ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN30@type_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN30@type_op

; 1304 :         opnd1->value = sym->type->total_size;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rcx], eax

; 1305 :         opnd1->is_type = TRUE; /* v2.03: added */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 8
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 1306 :         //if ( opnd1->mem_type == MT_EMPTY ) /* v2.09 */
; 1307 :         opnd1->mem_type = sym->type->mem_type; /* v2.09 */

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rcx+64], eax

; 1308 :         opnd1->type = sym->type; /* v2.09 */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [rax+96], rcx

; 1309 :         //printf( "sym=%s MT_TYPE type=%s type->memt=%X\n", sym->name, sym->type->name, sym->type->mem_type );
; 1310 :     } else {

	jmp	$LN31@type_op
$LN30@type_op:

; 1311 : #if 1 /* v2.03: added */
; 1312 :         opnd1->is_type = TRUE;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 8
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 1313 :         if ( opnd1->mem_type == MT_EMPTY )

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	jne	SHORT $LN32@type_op

; 1314 :             opnd1->mem_type = opnd2->mem_type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+64], ecx
$LN32@type_op:

; 1315 : #endif
; 1316 :         //if ( opnd2->type ) { /* v2.10a: see types14.asm */
; 1317 :         if ( opnd2->type && opnd2->mbr == NULL ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN33@type_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+88], 0
	jne	SHORT $LN33@type_op

; 1318 :             opnd1->type_tok = opnd2->type_tok;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	mov	QWORD PTR [rax+40], rcx

; 1319 :             opnd1->type = opnd2->type;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx

; 1320 :             opnd1->value = opnd1->type->total_size;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rcx], eax
	jmp	$LN34@type_op
$LN33@type_op:

; 1321 :         } else if ( sym->mem_type == MT_PTR ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 195			; 000000c3H
	jne	SHORT $LN35@type_op

; 1322 :             //printf( "sym=%s MT_PTR target_memt=%X target=%s\n", sym->name, sym->ptr_memtype, sym->target_type ? sym->target_type->name : "NULL" );
; 1323 :             opnd1->type_tok = opnd2->type_tok; /* v2.10: added */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	mov	QWORD PTR [rax+40], rcx

; 1324 :             opnd1->value = SizeFromMemtype( sym->isfar ? MT_FAR : MT_NEAR, sym->Ofssize, NULL );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN46@type_op
	mov	DWORD PTR tv307[rsp], 130		; 00000082H
	jmp	SHORT $LN47@type_op
$LN46@type_op:
	mov	DWORD PTR tv307[rsp], 129		; 00000081H
$LN47@type_op:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	xor	r8d, r8d
	mov	edx, eax
	mov	ecx, DWORD PTR tv307[rsp]
	call	SizeFromMemtype
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	$LN36@type_op
$LN35@type_op:

; 1325 :         } else if( sym->mem_type == MT_NEAR ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 129			; 00000081H
	jne	SHORT $LN37@type_op

; 1326 :             /* v2.09: also handle 64-bit */
; 1327 :             //opnd1->value = GetSymOfssize( sym ) ? LS_NEAR32 : LS_NEAR16;
; 1328 :             opnd1->value = 0xFF00 | ( 2 << GetSymOfssize( sym ) );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSymOfssize
	mov	ecx, 2
	mov	DWORD PTR tv540[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv540[rsp]
	shl	eax, cl
	or	eax, 65280				; 0000ff00H
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN38@type_op
$LN37@type_op:

; 1329 :         } else if( sym->mem_type == MT_FAR ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN39@type_op

; 1330 :             opnd1->value = GetSymOfssize( sym ) ? LS_FAR32 : LS_FAR16;

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSymOfssize
	test	eax, eax
	je	SHORT $LN48@type_op
	mov	DWORD PTR tv322[rsp], 65286		; 0000ff06H
	jmp	SHORT $LN49@type_op
$LN48@type_op:
	mov	DWORD PTR tv322[rsp], 65285		; 0000ff05H
$LN49@type_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR tv322[rsp]
	mov	DWORD PTR [rax], ecx

; 1331 :         } else

	jmp	SHORT $LN40@type_op
$LN39@type_op:

; 1332 :             opnd1->value = SizeFromMemtype( opnd2->mem_type, GetSymOfssize( sym ), sym->type );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSymOfssize
	mov	rcx, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rcx+80]
	mov	edx, eax
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rax+64]
	call	SizeFromMemtype
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN40@type_op:
$LN38@type_op:
$LN36@type_op:
$LN34@type_op:
$LN31@type_op:
$LN29@type_op:
$LN13@type_op:
$LN6@type_op:

; 1333 :     }
; 1334 :     DebugMsg1(("type_op: result value=%u is_type=%u type=%s\n", opnd1->value, opnd1->is_type, opnd1->type ? opnd1->type->name : "NULL" ));

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN50@type_op
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv336[rsp], rax
	jmp	SHORT $LN51@type_op
$LN50@type_op:
	lea	rax, OFFSET FLAT:$SG11475
	mov	QWORD PTR tv336[rsp], rax
$LN51@type_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	mov	r9, QWORD PTR tv336[rsp]
	mov	r8d, eax
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11476
	call	DoDebugMsg1

; 1335 :     return( NOT_ERROR );

	xor	eax, eax

; 1336 : }

	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
	npad	2
$LN52@type_op:
	DD	$LN8@type_op
	DD	$LN10@type_op
	DD	$LN9@type_op
	DD	$LN11@type_op
	DD	$LN2@type_op
	DD	$LN2@type_op
	DD	$LN8@type_op
	DD	$LN10@type_op
	DD	$LN9@type_op
	DD	$LN11@type_op
	DD	$LN2@type_op
	DD	$LN11@type_op
	DD	$LN2@type_op
	DD	$LN11@type_op
type_op	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
tv69 = 48
tv141 = 56
tv149 = 60
tv349 = 64
tv199 = 68
tv205 = 72
tv209 = 80
oper$ = 112
opnd1$ = 120
opnd2$ = 128
sym$ = 136
name$ = 144
sizlen_op PROC

; 1061 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rdi, rsp
	mov	ecx, 24
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+112]

; 1062 :     opnd1->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 0

; 1063 : 
; 1064 :     DebugMsg1(("sizlen_op(%s): sym=%X, mbr=%X, type=>%s<\n", GetResWName( oper, NULL ),

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN50@sizlen_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN51@sizlen_op
$LN50@sizlen_op:
	lea	rax, OFFSET FLAT:$SG11364
	mov	QWORD PTR tv69[rsp], rax
$LN51@sizlen_op:
	xor	edx, edx
	mov	ecx, DWORD PTR oper$[rsp]
	call	GetResWName
	mov	rcx, QWORD PTR tv69[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	r9, QWORD PTR [rcx+88]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	r8, QWORD PTR [rcx+80]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11365
	call	DoDebugMsg1

; 1065 :                opnd2->sym, opnd2->mbr, opnd2->type ? opnd2->type->name : "NULL" ));
; 1066 : 
; 1067 :     if ( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN4@sizlen_op

; 1068 :         if ( sym->state == SYM_STRUCT_FIELD || sym->state == SYM_STACK )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 6
	je	SHORT $LN7@sizlen_op
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 5
	jne	SHORT $LN5@sizlen_op
$LN7@sizlen_op:

; 1069 :             ;

	jmp	$LN6@sizlen_op
$LN5@sizlen_op:

; 1070 :         else if ( sym->state == SYM_UNDEFINED ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN8@sizlen_op

; 1071 :             /* v2.10: forward references should have attributes EXPR_ADDR + sym.state=SYM_UNDEFINED */
; 1072 :             opnd1->kind = EXPR_ADDR;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 1

; 1073 :             opnd1->sym = sym;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+80], rcx

; 1074 :         } else if ( ( sym->state == SYM_EXTERNAL ||

	jmp	$LN9@sizlen_op
$LN8@sizlen_op:

; 1075 :                  sym->state == SYM_INTERNAL) &&
; 1076 :                  //sym->mem_type != MT_ABS &&
; 1077 :                  sym->mem_type != MT_EMPTY &&
; 1078 :                  //sym->mem_type != MT_PROC && /* MT_PROC probably obsolete */
; 1079 :                  sym->mem_type != MT_FAR &&

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	je	SHORT $LN12@sizlen_op
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN10@sizlen_op
$LN12@sizlen_op:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 192			; 000000c0H
	je	SHORT $LN10@sizlen_op
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	je	SHORT $LN10@sizlen_op
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 129			; 00000081H
	je	SHORT $LN10@sizlen_op

; 1080 :                  sym->mem_type != MT_NEAR )
; 1081 :             ;

	jmp	SHORT $LN11@sizlen_op
$LN10@sizlen_op:

; 1082 :         else if ( sym->state == SYM_GRP || sym->state == SYM_SEG ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 4
	je	SHORT $LN15@sizlen_op
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 3
	jne	SHORT $LN13@sizlen_op
$LN15@sizlen_op:

; 1083 :             return( fnEmitErr( EXPECTED_DATA_LABEL ) );

	mov	ecx, 232				; 000000e8H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@sizlen_op
	jmp	SHORT $LN14@sizlen_op
$LN13@sizlen_op:

; 1084 :         } else if ( oper == T_SIZE || oper == T_LENGTH )

	cmp	DWORD PTR oper$[rsp], 246		; 000000f6H
	je	SHORT $LN18@sizlen_op
	cmp	DWORD PTR oper$[rsp], 234		; 000000eaH
	jne	SHORT $LN16@sizlen_op
$LN18@sizlen_op:

; 1085 :             ;

	jmp	SHORT $LN17@sizlen_op
$LN16@sizlen_op:

; 1086 :         else {
; 1087 :             return( fnEmitErr( EXPECTED_DATA_LABEL ) );

	mov	ecx, 232				; 000000e8H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@sizlen_op
$LN17@sizlen_op:
$LN14@sizlen_op:
$LN11@sizlen_op:
$LN9@sizlen_op:
$LN6@sizlen_op:
$LN4@sizlen_op:

; 1088 :         }
; 1089 :     }
; 1090 : 
; 1091 :     switch( oper ) {

	mov	eax, DWORD PTR oper$[rsp]
	mov	DWORD PTR tv141[rsp], eax
	cmp	DWORD PTR tv141[rsp], 234		; 000000eaH
	je	SHORT $LN19@sizlen_op
	cmp	DWORD PTR tv141[rsp], 235		; 000000ebH
	je	SHORT $LN20@sizlen_op
	cmp	DWORD PTR tv141[rsp], 246		; 000000f6H
	je	$LN25@sizlen_op
	cmp	DWORD PTR tv141[rsp], 247		; 000000f7H
	je	$LN38@sizlen_op
	jmp	$LN2@sizlen_op
$LN19@sizlen_op:

; 1092 :     case T_LENGTH:
; 1093 :         /* data items and struct fields have a "first" count.
; 1094 :          * for procedure locals (+arguments) and code labels, always 1 is returned.
; 1095 :          */
; 1096 :         /* v2.09: first_length is valid if isdata is set */
; 1097 :         //opnd1->value = ( sym->state != SYM_STACK && sym->isarray ) ? sym->first_length : 1;
; 1098 :         opnd1->value = sym->isdata ? sym->first_length : 1;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN52@sizlen_op
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+48]
	mov	DWORD PTR tv149[rsp], eax
	jmp	SHORT $LN53@sizlen_op
$LN52@sizlen_op:
	mov	DWORD PTR tv149[rsp], 1
$LN53@sizlen_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR tv149[rsp]
	mov	DWORD PTR [rax], ecx

; 1099 :         break;

	jmp	$LN2@sizlen_op
$LN20@sizlen_op:

; 1100 :     case T_LENGTHOF:
; 1101 :         /* LENGTHOF needs either a data label or a structure field */
; 1102 :         /* a TYPE (structure, typedef) is invalid */
; 1103 :         if( opnd2->kind == EXPR_CONST ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN21@sizlen_op

; 1104 :             opnd1->value = opnd2->mbr->total_length;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN22@sizlen_op
$LN21@sizlen_op:

; 1105 : #if 0 /* v2.09: unnecessary */
; 1106 :         } else if( sym->state == SYM_UNDEFINED && Parse_Pass == PASS_1 ) {
; 1107 :             opnd1->value = sym->total_length;
; 1108 : #endif
; 1109 :         } else if ( sym->state == SYM_EXTERNAL && sym->iscomm == FALSE ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN23@sizlen_op
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN23@sizlen_op

; 1110 :             /* for externals other than COMM, total_length field is used otherwise */
; 1111 :             opnd1->value = 1;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax], 1

; 1112 :         } else {

	jmp	SHORT $LN24@sizlen_op
$LN23@sizlen_op:

; 1113 :             opnd1->value = sym->total_length;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax], ecx
$LN24@sizlen_op:
$LN22@sizlen_op:

; 1114 :         }
; 1115 :         break;

	jmp	$LN2@sizlen_op
$LN25@sizlen_op:

; 1116 :     case T_SIZE:
; 1117 :         /* v2.04: first_size is no longer set for SYM_STACK. */
; 1118 :         if( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN26@sizlen_op

; 1119 :             /* v2.09: check memtype */
; 1120 :             if ( ( opnd2->mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS )

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN28@sizlen_op

; 1121 :                 opnd1->value = 0xFF00 | opnd2->value;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax]
	or	eax, 65280				; 0000ff00H
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN29@sizlen_op
$LN28@sizlen_op:

; 1122 :             else
; 1123 :                 opnd1->value = opnd2->value;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax], ecx
$LN29@sizlen_op:

; 1124 :         } else if ( sym->isdata ) {

	jmp	$LN27@sizlen_op
$LN26@sizlen_op:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN30@sizlen_op

; 1125 :             opnd1->value = sym->first_size;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+44]
	mov	DWORD PTR [rax], ecx
	jmp	$LN31@sizlen_op
$LN30@sizlen_op:

; 1126 : #if 0 /* v2.09: can't happen, since for a type, sym is NULL */
; 1127 :         } else if( sym->state == SYM_TYPE ) {
; 1128 :             opnd1->value = sym->total_size;
; 1129 : #endif
; 1130 :         } else if( sym->state == SYM_STACK ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 5
	jne	SHORT $LN32@sizlen_op

; 1131 :             opnd1->value = GetSizeValue( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSizeValue
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	$LN33@sizlen_op
$LN32@sizlen_op:

; 1132 :         } else if( sym->mem_type == MT_NEAR ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 129			; 00000081H
	jne	SHORT $LN34@sizlen_op

; 1133 :             /* v2.09: also handle 64-bit */
; 1134 :             //opnd1->value = GetSymOfssize( sym ) ? LS_NEAR32 : LS_NEAR16;
; 1135 :             opnd1->value = 0xFF00 | ( 2 << GetSymOfssize( sym ) );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSymOfssize
	mov	ecx, 2
	mov	DWORD PTR tv349[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv349[rsp]
	shl	eax, cl
	or	eax, 65280				; 0000ff00H
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN35@sizlen_op
$LN34@sizlen_op:

; 1136 :         } else if( sym->mem_type == MT_FAR ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 130			; 00000082H
	jne	SHORT $LN36@sizlen_op

; 1137 :             opnd1->value = GetSymOfssize( sym ) ? LS_FAR32 : LS_FAR16;

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSymOfssize
	test	eax, eax
	je	SHORT $LN54@sizlen_op
	mov	DWORD PTR tv199[rsp], 65286		; 0000ff06H
	jmp	SHORT $LN55@sizlen_op
$LN54@sizlen_op:
	mov	DWORD PTR tv199[rsp], 65285		; 0000ff05H
$LN55@sizlen_op:
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR tv199[rsp]
	mov	DWORD PTR [rax], ecx

; 1138 :         } else {

	jmp	SHORT $LN37@sizlen_op
$LN36@sizlen_op:

; 1139 :             opnd1->value = GetSizeValue( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSizeValue
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN37@sizlen_op:
$LN35@sizlen_op:
$LN33@sizlen_op:
$LN31@sizlen_op:
$LN27@sizlen_op:

; 1140 :         }
; 1141 :         DebugMsg1(("sizlen_op(SIZE): result=%u [symbol %s, first_size=%u]\n", opnd1->value, sym ? sym->name : "NULL", sym ? sym->first_size : 0 ));

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN56@sizlen_op
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+44]
	mov	DWORD PTR tv205[rsp], eax
	jmp	SHORT $LN57@sizlen_op
$LN56@sizlen_op:
	mov	DWORD PTR tv205[rsp], 0
$LN57@sizlen_op:
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN58@sizlen_op
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv209[rsp], rax
	jmp	SHORT $LN59@sizlen_op
$LN58@sizlen_op:
	lea	rax, OFFSET FLAT:$SG11400
	mov	QWORD PTR tv209[rsp], rax
$LN59@sizlen_op:
	mov	r9d, DWORD PTR tv205[rsp]
	mov	r8, QWORD PTR tv209[rsp]
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11401
	call	DoDebugMsg1

; 1142 :         break;

	jmp	$LN2@sizlen_op
$LN38@sizlen_op:

; 1143 :     case T_SIZEOF:
; 1144 : #ifdef DEBUG_OUT
; 1145 :         if (sym)

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN39@sizlen_op

; 1146 :             DebugMsg1(("sizlen_op(sizeof): symbol %s, state=%u, size=%u\n", sym->name, sym->state, sym->total_size ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+56]
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+32]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11405
	call	DoDebugMsg1
	jmp	SHORT $LN40@sizlen_op
$LN39@sizlen_op:

; 1147 :         else if ( opnd2->is_type && opnd2->type )

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN41@sizlen_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN41@sizlen_op

; 1148 :             DebugMsg1(("sizlen_op(sizeof): symbol %s (TYPE), opnd2.value=%u\n", opnd2->type->name, opnd2->value ));

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	r8d, DWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11408
	call	DoDebugMsg1
	jmp	SHORT $LN42@sizlen_op
$LN41@sizlen_op:

; 1149 :         else
; 1150 :             DebugMsg1(("sizlen_op(sizeof): symbol NULL, opnd2.value=%u\n", opnd2->value ));

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11409
	call	DoDebugMsg1
$LN42@sizlen_op:
$LN40@sizlen_op:

; 1151 : #endif
; 1152 :         /* if sym is NULL, then operand is a type constant */
; 1153 :         if ( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN43@sizlen_op

; 1154 :             /* v2.06: default value of RECORD types is the mask! */
; 1155 :             if ( opnd2->is_type && opnd2->type && opnd2->type->typekind == TYPE_RECORD )

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN45@sizlen_op
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN45@sizlen_op
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 4
	jne	SHORT $LN45@sizlen_op

; 1156 :                 opnd1->value = opnd2->type->total_size;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN46@sizlen_op
$LN45@sizlen_op:

; 1157 :             else
; 1158 :                 opnd1->value = opnd2->value;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax], ecx
$LN46@sizlen_op:

; 1159 : #if 1 /* v2.05: don't use total_size for externals anymore! */
; 1160 :         } else if ( sym->state == SYM_EXTERNAL && sym->iscomm == FALSE ) {

	jmp	SHORT $LN44@sizlen_op
$LN43@sizlen_op:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN47@sizlen_op
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN47@sizlen_op

; 1161 :             opnd1->value = GetSizeValue( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSizeValue
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax

; 1162 :             //if ( sym->iscomm == TRUE )
; 1163 :             //    opnd1->value *= sym->total_length;
; 1164 : #endif
; 1165 :         } else

	jmp	SHORT $LN48@sizlen_op
$LN47@sizlen_op:

; 1166 :             opnd1->value = sym->total_size;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax], ecx
$LN48@sizlen_op:
$LN44@sizlen_op:
$LN2@sizlen_op:

; 1167 :         break;
; 1168 :     }
; 1169 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@sizlen_op:

; 1170 : }

	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
sizlen_op ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
opnd$ = 48
oprtr$ = 56
operand$ = 64
invalid_operand PROC

; 1041 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 1042 :     if ( !opnd->is_opattr )

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN2@invalid_op

; 1043 :         fnEmitErr( INVALID_OPERAND_FOR_OPERATOR, _strupr( oprtr), operand );

	mov	rcx, QWORD PTR oprtr$[rsp]
	call	QWORD PTR __imp__strupr
	mov	r8, QWORD PTR operand$[rsp]
	mov	rdx, rax
	mov	ecx, 228				; 000000e4H
	call	QWORD PTR fnEmitErr
$LN2@invalid_op:

; 1044 :     return( ERROR );

	mov	eax, -1

; 1045 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
invalid_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
opnd$ = 16
IsOffset PROC

; 1025 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 1026 :     if ( opnd->mem_type == MT_EMPTY )

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	jne	SHORT $LN2@IsOffset

; 1027 :         if ( opnd->instr == T_OFFSET ||
; 1028 : #if IMAGERELSUPP
; 1029 :             opnd->instr == T_IMAGEREL ||
; 1030 : #endif
; 1031 : #if SECTIONRELSUPP
; 1032 :             opnd->instr == T_SECTIONREL ||

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+56], 241			; 000000f1H
	je	SHORT $LN4@IsOffset
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+56], 233			; 000000e9H
	je	SHORT $LN4@IsOffset
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+56], 243			; 000000f3H
	je	SHORT $LN4@IsOffset
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+56], 239			; 000000efH
	jne	SHORT $LN3@IsOffset
$LN4@IsOffset:

; 1033 : #endif
; 1034 :             opnd->instr == T_LROFFSET )
; 1035 :             return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@IsOffset
$LN3@IsOffset:
$LN2@IsOffset:

; 1036 :     return( 0 );

	xor	eax, eax
$LN1@IsOffset:

; 1037 : }

	pop	rdi
	ret	0
IsOffset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
tv77 = 32
sym$ = 64
GetSizeValue PROC

; 1017 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 1018 :     if ( sym->mem_type == MT_PTR )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 195			; 000000c3H
	jne	SHORT $LN2@GetSizeVal

; 1019 :         return( SizeFromMemtype( sym->isfar ? MT_FAR : MT_NEAR, sym->Ofssize, sym->type ) );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@GetSizeVal
	mov	DWORD PTR tv77[rsp], 130		; 00000082H
	jmp	SHORT $LN5@GetSizeVal
$LN4@GetSizeVal:
	mov	DWORD PTR tv77[rsp], 129		; 00000081H
$LN5@GetSizeVal:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rcx+80]
	mov	edx, eax
	mov	ecx, DWORD PTR tv77[rsp]
	call	SizeFromMemtype
	jmp	SHORT $LN1@GetSizeVal
$LN2@GetSizeVal:

; 1020 :     return( SizeFromMemtype( sym->mem_type, sym->Ofssize, sym->type ) );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rcx+80]
	mov	edx, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rax+36]
	call	SizeFromMemtype
$LN1@GetSizeVal:

; 1021 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
GetSizeValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
opnd1$ = 16
opnd2$ = 24
check_direct_reg PROC

; 1007 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 1008 :     if( ( opnd1->kind == EXPR_REG ) && ( opnd1->indirect == FALSE )
; 1009 :         || ( opnd2->kind == EXPR_REG ) && ( opnd2->indirect == FALSE ) ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN4@check_dire
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN3@check_dire
$LN4@check_dire:
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 2
	jne	SHORT $LN2@check_dire
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN2@check_dire
$LN3@check_dire:

; 1010 :         return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@check_dire
$LN2@check_dire:

; 1011 :     }
; 1012 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@check_dire:

; 1013 : }

	pop	rdi
	ret	0
check_direct_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
opnd$ = 16
fix_struct_value PROC

; 998  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 999  :     if( opnd->mbr && ( opnd->mbr->state == SYM_TYPE ) ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN2@fix_struct
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+88]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN2@fix_struct

; 1000 :         opnd->value += opnd->mbr->total_size;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	ecx, DWORD PTR [rcx]
	add	ecx, DWORD PTR [rax+56]
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx], eax

; 1001 :         opnd->mbr = NULL;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rax+88], 0
$LN2@fix_struct:

; 1002 :     }
; 1003 : }

	pop	rdi
	ret	0
fix_struct_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
opnd1$ = 48
opnd2$ = 56
ConstError PROC

; 984  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 985  :     if ( opnd1->is_opattr )

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@ConstError

; 986  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@ConstError
$LN2@ConstError:

; 987  :     if ( opnd1->kind == EXPR_FLOAT || opnd2->kind == EXPR_FLOAT )

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	DWORD PTR [rax+60], 3
	je	SHORT $LN5@ConstError
	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	DWORD PTR [rax+60], 3
	jne	SHORT $LN3@ConstError
$LN5@ConstError:

; 988  :         fnEmitErr( REAL_OR_BCD_NUMBER_NOT_ALLOWED );

	mov	ecx, 270				; 0000010eH
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN4@ConstError
$LN3@ConstError:

; 989  :     else
; 990  :         fnEmitErr( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	QWORD PTR fnEmitErr
$LN4@ConstError:

; 991  :     return( ERROR );

	mov	eax, -1
$LN1@ConstError:

; 992  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ConstError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
opnd1$ = 48
opnd2$ = 56
MakeConst2 PROC

; 964  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 965  : 
; 966  :     if ( opnd1->sym->state == SYM_EXTERNAL ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN2@MakeConst2

; 967  :         return( fnEmitErr( INVALID_USE_OF_EXTERNAL_SYMBOL, opnd1->sym->name ) );

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 193				; 000000c1H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@MakeConst2

; 968  :     } else if ( ( opnd1->sym->segment != opnd2->sym->segment &&

	jmp	SHORT $LN3@MakeConst2
$LN2@MakeConst2:

; 969  :                  /* v2.07: ignore segments if at least one label is a fwd ref */
; 970  :                  opnd1->sym->state != SYM_UNDEFINED &&
; 971  :                  opnd2->sym->state != SYM_UNDEFINED ) ||

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rax+24], rcx
	je	SHORT $LN6@MakeConst2
	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN6@MakeConst2
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN5@MakeConst2
$LN6@MakeConst2:
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN4@MakeConst2
$LN5@MakeConst2:

; 972  :                opnd2->sym->state == SYM_EXTERNAL ) {
; 973  :         return( fnEmitErr( OPERANDS_MUST_BE_IN_SAME_SEGMENT ) );

	mov	ecx, 192				; 000000c0H
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN1@MakeConst2
$LN4@MakeConst2:
$LN3@MakeConst2:

; 974  :     }
; 975  :     opnd1->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rax+60], 0

; 976  :     opnd1->value += opnd1->sym->offset;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR [rcx]
	add	ecx, DWORD PTR [rax+16]
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx], eax

; 977  :     opnd2->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rax+60], 0

; 978  :     opnd2->value += opnd2->sym->offset;

	mov	rax, QWORD PTR opnd2$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR [rcx]
	add	ecx, DWORD PTR [rax+16]
	mov	eax, ecx
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	DWORD PTR [rcx], eax

; 979  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@MakeConst2:

; 980  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
MakeConst2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
opnd$ = 16
MakeConst PROC

; 910  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 911  :     if( ( opnd->kind != EXPR_ADDR ) || opnd->indirect ) /* v2.09: check for indirect added */

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+60], 1
	jne	SHORT $LN3@MakeConst
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@MakeConst
$LN3@MakeConst:

; 912  :         return;

	jmp	$LN1@MakeConst
$LN2@MakeConst:

; 913  : 
; 914  :     if( opnd->sym ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN4@MakeConst

; 915  :         if ( Parse_Pass > PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN5@MakeConst

; 916  :             return;

	jmp	$LN1@MakeConst
$LN5@MakeConst:

; 917  :         /* added for v1.94: if the evaluator assumed an address because
; 918  :          * the label wasn't defined yet, then negate this. Also, an
; 919  :          * EXTERNDEF:ABS is to be accepted.
; 920  :          * v2.07: if the "not yet defined" label was an argument of
; 921  :          * an (OFFSET) operator, do NOT change the type!
; 922  :          */
; 923  :         if ( ( opnd->sym->state == SYM_UNDEFINED && opnd->instr == EMPTY ) ||

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN9@MakeConst
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+56], -2
	je	SHORT $LN8@MakeConst
$LN9@MakeConst:
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN6@MakeConst
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+80]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN6@MakeConst
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 2
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN6@MakeConst
$LN8@MakeConst:

; 924  :             ( opnd->sym->state == SYM_EXTERNAL && opnd->sym->weak == TRUE && opnd->is_abs == TRUE ) )
; 925  :             ;

	jmp	SHORT $LN7@MakeConst
$LN6@MakeConst:

; 926  :         else
; 927  :             return;

	jmp	SHORT $LN1@MakeConst
$LN7@MakeConst:

; 928  :         /* assume a value != 0 to avoid problems with div */
; 929  :         opnd->value = 1;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax], 1
$LN4@MakeConst:

; 930  :     }
; 931  : 
; 932  :     opnd->label_tok = NULL;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rax+40], 0

; 933  :     if( opnd->mbr != NULL ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN10@MakeConst

; 934  :         if( opnd->mbr->state == SYM_STRUCT_FIELD ) {

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+88]
	cmp	DWORD PTR [rax+32], 6
	jne	SHORT $LN11@MakeConst

; 935  : #if 0 /* v2.09: mbr can only be SYM_STRUCT_FIELD or SYM_UNDEFINED (if nullmbr) */
; 936  :         } else if( opnd->mbr->state == SYM_TYPE ) {
; 937  :             opnd->value += opnd->mbr->total_size;
; 938  :             opnd->mbr = NULL;
; 939  : #endif
; 940  :         } else {

	jmp	SHORT $LN12@MakeConst
$LN11@MakeConst:

; 941  :             return;

	jmp	SHORT $LN1@MakeConst
$LN12@MakeConst:
$LN10@MakeConst:

; 942  :         }
; 943  :     }
; 944  : #if 0 /* v2.09: obsolete */
; 945  :     if( opnd->base_reg != NULL )
; 946  :         return;
; 947  :     if( opnd->idx_reg  != NULL )
; 948  :         return;
; 949  : #endif
; 950  :     if( opnd->override != NULL )

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN13@MakeConst

; 951  :         return;

	jmp	SHORT $LN1@MakeConst
$LN13@MakeConst:

; 952  :     opnd->instr = EMPTY;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+56], -2

; 953  :     opnd->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 0

; 954  :     //opnd->indirect = FALSE; /* not needed */
; 955  :     opnd->explicit = FALSE;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, -3					; fffffffdH
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 956  :     opnd->mem_type = MT_EMPTY;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+64], 192			; 000000c0H
$LN1@MakeConst:

; 957  : }

	pop	rdi
	ret	0
MakeConst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
opnd1$ = 48
opnd2$ = 56
index_connect PROC

; 865  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 866  :     /* move opnd2.base to either opnd1.base or opnd1.idx */
; 867  :     if ( opnd2->base_reg != NULL ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	$LN2@index_conn

; 868  :         if ( opnd1->base_reg == NULL )

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN3@index_conn

; 869  :             opnd1->base_reg = opnd2->base_reg;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+24], rcx
	jmp	SHORT $LN4@index_conn
$LN3@index_conn:

; 870  :         else if ( opnd1->idx_reg == NULL ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+32], 0
	jne	SHORT $LN5@index_conn

; 871  :             /* v2.10: exchange base and index register.
; 872  :              * was previously in parser.c, and only done
; 873  :              * if -Zg was active.
; 874  :              */
; 875  :             if ( opnd1->base_reg->bytval != 4 ) {   /* if base isn't [E|R]SP, exchange regs */

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rax, QWORD PTR [rax+24]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 4
	je	SHORT $LN7@index_conn

; 876  :                 opnd1->idx_reg = opnd1->base_reg;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+32], rcx

; 877  :                 opnd1->base_reg = opnd2->base_reg;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+24], rcx

; 878  :             } else {

	jmp	SHORT $LN8@index_conn
$LN7@index_conn:

; 879  :                 opnd1->idx_reg = opnd2->base_reg;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+32], rcx
$LN8@index_conn:

; 880  :             }
; 881  :         } else {

	jmp	SHORT $LN6@index_conn
$LN5@index_conn:

; 882  :             return( fnEmitErr( MULTIPLE_INDEX_REGISTERS_NOT_ALLOWED ) );

	mov	ecx, 34					; 00000022H
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN1@index_conn
$LN6@index_conn:
$LN4@index_conn:

; 883  :         }
; 884  :         opnd1->indirect = TRUE;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax
$LN2@index_conn:

; 885  :     }
; 886  :     /* move opnd2.idx to opnd1.index - if it is free */
; 887  :     if( opnd2->idx_reg != NULL ) {

	mov	rax, QWORD PTR opnd2$[rsp]
	cmp	QWORD PTR [rax+32], 0
	je	SHORT $LN9@index_conn

; 888  :         //if ( opnd2->scale == 0 && opnd1->base_reg == NULL ) {
; 889  :         //    opnd1->base_reg = opnd2->idx_reg;
; 890  :         //} else if ( opnd1->idx_reg == NULL ) {
; 891  :         if ( opnd1->idx_reg == NULL ) {

	mov	rax, QWORD PTR opnd1$[rsp]
	cmp	QWORD PTR [rax+32], 0
	jne	SHORT $LN10@index_conn

; 892  :             opnd1->idx_reg = opnd2->idx_reg;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR [rcx+32]
	mov	QWORD PTR [rax+32], rcx

; 893  :             opnd1->scale = opnd2->scale;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR opnd2$[rsp]
	movzx	ecx, BYTE PTR [rcx+68]
	mov	BYTE PTR [rax+68], cl

; 894  :         } else {

	jmp	SHORT $LN11@index_conn
$LN10@index_conn:

; 895  :             return( fnEmitErr( MULTIPLE_INDEX_REGISTERS_NOT_ALLOWED ) );

	mov	ecx, 34					; 00000022H
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN1@index_conn
$LN11@index_conn:

; 896  :         }
; 897  :         opnd1->indirect = TRUE;

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 1
	mov	rcx, QWORD PTR opnd1$[rsp]
	mov	DWORD PTR [rcx+72], eax
$LN9@index_conn:

; 898  :     }
; 899  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@index_conn:

; 900  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
index_connect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
opnd1$ = 16
opnd2$ = 24
type1$ = 32
type2$ = 40
check_both PROC

; 854  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 855  :     if( opnd1->kind == type1 && opnd2->kind == type2 )

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR type1$[rsp]
	cmp	DWORD PTR [rax+60], ecx
	jne	SHORT $LN2@check_both
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR type2$[rsp]
	cmp	DWORD PTR [rax+60], ecx
	jne	SHORT $LN2@check_both

; 856  :         return( TRUE );

	mov	al, 1
	jmp	SHORT $LN1@check_both
$LN2@check_both:

; 857  :     if( opnd1->kind == type2 && opnd2->kind == type1 )

	mov	rax, QWORD PTR opnd1$[rsp]
	mov	ecx, DWORD PTR type2$[rsp]
	cmp	DWORD PTR [rax+60], ecx
	jne	SHORT $LN3@check_both
	mov	rax, QWORD PTR opnd2$[rsp]
	mov	ecx, DWORD PTR type1$[rsp]
	cmp	DWORD PTR [rax+60], ecx
	jne	SHORT $LN3@check_both

; 858  :         return( TRUE );

	mov	al, 1
	jmp	SHORT $LN1@check_both
$LN3@check_both:

; 859  :     return( FALSE );

	xor	al, al
$LN1@check_both:

; 860  : }

	pop	rdi
	ret	0
check_both ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
tmp$ = 96
sym$ = 104
i$ = 112
j$ = 116
labelbuff$ = 136
cnt$4 = 164
tv79 = 176
tv145 = 184
tv325 = 192
tv451 = 200
tv470 = 208
tv475 = 216
tv592 = 224
tv605 = 232
tv643 = 240
tv668 = 248
tv693 = 256
tv716 = 264
tv727 = 272
tv803 = 280
tv808 = 288
tv932 = 296
tv1002 = 304
tv1110 = 312
tv1116 = 320
tv1122 = 328
tv1132 = 336
__$ArrayPad$ = 344
opnd$ = 368
idx$ = 376
tokenarray$ = 384
flags$ = 392
get_operand PROC

; 347  : {

	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 352				; 00000160H
	mov	rdi, rsp
	mov	ecx, 88					; 00000058H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+368]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 348  :     char        *tmp;
; 349  :     struct asym *sym;
; 350  :     int         i = *idx;

	mov	rax, QWORD PTR idx$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax

; 351  :     int         j;
; 352  :     char        labelbuff[16];/* for anonymous labels */
; 353  : 
; 354  :     DebugMsg1(("%u get_operand(idx=%u >%s<) enter [memtype=%Xh]\n", evallvl, i, tokenarray[i].tokpos, opnd->mem_type ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rsp+32], ecx
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r9, QWORD PTR [rcx+rax+24]
	mov	r8d, DWORD PTR i$[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11082
	call	DoDebugMsg1

; 355  :     switch( tokenarray[i].token ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv79[rsp], eax
	mov	eax, DWORD PTR tv79[rsp]
	sub	eax, 2
	mov	DWORD PTR tv79[rsp], eax
	cmp	DWORD PTR tv79[rsp], 9
	ja	$LN122@get_operan
	movsxd	rax, DWORD PTR tv79[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN167@get_operan[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN18@get_operan:

; 356  :     case T_NUM:
; 357  :         DebugMsg1(("%u get_operand: T_NUM, %s, base=%u, len=%u\n", evallvl, tokenarray[i].string_ptr, tokenarray[i].numbase, tokenarray[i].itemlen ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	movsx	ecx, BYTE PTR [rdx+rcx+1]
	movsxd	rdx, DWORD PTR i$[rsp]
	imul	rdx, rdx, 32				; 00000020H
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [r8+rax+16]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rax+rdx+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11084
	call	DoDebugMsg1

; 358  :         opnd->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 0

; 359  :         myatoi128( tokenarray[i].string_ptr, &opnd->llvalue, tokenarray[i].numbase, tokenarray[i].itemlen );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	movsx	ecx, BYTE PTR [rdx+rcx+1]
	mov	rdx, QWORD PTR opnd$[rsp]
	movsxd	r8, DWORD PTR i$[rsp]
	imul	r8, r8, 32				; 00000020H
	mov	QWORD PTR tv145[rsp], r8
	mov	r9, QWORD PTR tokenarray$[rsp]
	mov	r9d, DWORD PTR [r9+rax+16]
	mov	r8d, ecx
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR tv145[rsp]
	mov	rcx, QWORD PTR [rax+rcx+8]
	call	myatoi128

; 360  :         //opnd->llvalue = tokenarray[i].value64;
; 361  :         //opnd->hlvalue = ( tokenarray[i].numflg == NF_NULL ? 0 : *(uint_64 *)( tokenarray[i].string_ptr - sizeof(uint_64) ) );
; 362  :         break;

	jmp	$LN2@get_operan
$LN19@get_operan:

; 363  :     case T_STRING:
; 364  :         DebugMsg1(("%u get_operand: T_STRING, %s, size=%u\n", evallvl, tokenarray[i].string_ptr, tokenarray[i].stringlen ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r9d, DWORD PTR [rdx+rax+16]
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rax+rcx+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11086
	call	DoDebugMsg1

; 365  :         /* string enclosed in <> or {} are rejected since v1.94! */
; 366  : 		if (tokenarray[i].string_delim != '"' && tokenarray[i].string_delim != '\'') {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 34					; 00000022H
	je	$LN20@get_operan
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 39					; 00000027H
	je	$LN20@get_operan

; 367  : 			/* here is handled EVEX Static Rounding Mode
; 368  : 			* {sae},   {rn-sae},{rd-sae},{ru-sae} {rz-sae}
; 369  : 			* ZLLBVAAA ZLLBVAAA ZLLBVAAA ZLLBVAAA ZLLBVAAA
; 370  : 			* 00010000 00010000 00110000 01010000 01110000
; 371  : 			* to destinguish between SAE and RN  I added 0x10
; 372  : 			* to all 4 other decorators
; 373  : 			* which will be subtracted in codegen.c
; 374  : 			*/
; 375  : 			if ((tokenarray[i].string_delim == '{') &&

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN21@get_operan
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r8d, 6
	lea	rdx, OFFSET FLAT:$SG11090
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	memcmp
	test	eax, eax
	jne	SHORT $LN21@get_operan

; 376  : 				(0 == memcmp(tokenarray[i].string_ptr, "rn-sae", 6))) {
; 377  : 				if (!evex) EmitError(UNAUTHORISED_USE_OF_EVEX_ENCODING);

	movzx	eax, BYTE PTR evex
	test	eax, eax
	jne	SHORT $LN23@get_operan
	mov	ecx, 277				; 00000115H
	call	EmitError
$LN23@get_operan:

; 378  : 				opnd->kind = EXPR_DECORATOR;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 4

; 379  : 				opnd->saeflags = 0x20;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	BYTE PTR [rax+70], 32			; 00000020H

; 380  : 				break;

	jmp	$LN2@get_operan

; 381  : 			}

	jmp	$LN22@get_operan
$LN21@get_operan:

; 382  : 			else if ((tokenarray[i].string_delim == '{') &&

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN24@get_operan
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r8d, 6
	lea	rdx, OFFSET FLAT:$SG11094
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	memcmp
	test	eax, eax
	jne	SHORT $LN24@get_operan

; 383  : 				(0 == memcmp(tokenarray[i].string_ptr, "rd-sae", 6))) {
; 384  : 				if (!evex) EmitError(UNAUTHORISED_USE_OF_EVEX_ENCODING);

	movzx	eax, BYTE PTR evex
	test	eax, eax
	jne	SHORT $LN26@get_operan
	mov	ecx, 277				; 00000115H
	call	EmitError
$LN26@get_operan:

; 385  : 				opnd->kind = EXPR_DECORATOR;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 4

; 386  : 				opnd->saeflags = 0x40;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	BYTE PTR [rax+70], 64			; 00000040H

; 387  : 				break;

	jmp	$LN2@get_operan

; 388  : 			}

	jmp	$LN25@get_operan
$LN24@get_operan:

; 389  : 			else if ((tokenarray[i].string_delim == '{') &&

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN27@get_operan
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r8d, 6
	lea	rdx, OFFSET FLAT:$SG11098
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	memcmp
	test	eax, eax
	jne	SHORT $LN27@get_operan

; 390  : 				(0 == memcmp(tokenarray[i].string_ptr, "ru-sae", 6))) {
; 391  : 				if (!evex) EmitError(UNAUTHORISED_USE_OF_EVEX_ENCODING);

	movzx	eax, BYTE PTR evex
	test	eax, eax
	jne	SHORT $LN29@get_operan
	mov	ecx, 277				; 00000115H
	call	EmitError
$LN29@get_operan:

; 392  : 				opnd->kind = EXPR_DECORATOR;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 4

; 393  : 				opnd->saeflags = 0x60;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	BYTE PTR [rax+70], 96			; 00000060H

; 394  : 				break;

	jmp	$LN2@get_operan

; 395  : 			}

	jmp	$LN28@get_operan
$LN27@get_operan:

; 396  : 			else if ((tokenarray[i].string_delim == '{') &&

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN30@get_operan
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r8d, 6
	lea	rdx, OFFSET FLAT:$SG11102
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	memcmp
	test	eax, eax
	jne	SHORT $LN30@get_operan

; 397  : 				(0 == memcmp(tokenarray[i].string_ptr, "rz-sae", 6))) {
; 398  : 				if (!evex) EmitError(UNAUTHORISED_USE_OF_EVEX_ENCODING);

	movzx	eax, BYTE PTR evex
	test	eax, eax
	jne	SHORT $LN32@get_operan
	mov	ecx, 277				; 00000115H
	call	EmitError
$LN32@get_operan:

; 399  : 				opnd->kind = EXPR_DECORATOR;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 4

; 400  : 				opnd->saeflags = 0x80;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	BYTE PTR [rax+70], 128			; 00000080H

; 401  : 				break;

	jmp	$LN2@get_operan

; 402  : 			}

	jmp	$LN31@get_operan
$LN30@get_operan:

; 403  : 			else if ((tokenarray[i].string_delim == '{') &&

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN33@get_operan
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r8d, 3
	lea	rdx, OFFSET FLAT:$SG11106
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	memcmp
	test	eax, eax
	jne	SHORT $LN33@get_operan

; 404  : 				(0 == memcmp(tokenarray[i].string_ptr, "sae", 3))) {
; 405  : 				if (!evex) EmitError(UNAUTHORISED_USE_OF_EVEX_ENCODING);

	movzx	eax, BYTE PTR evex
	test	eax, eax
	jne	SHORT $LN35@get_operan
	mov	ecx, 277				; 00000115H
	call	EmitError
$LN35@get_operan:

; 406  : 				opnd->kind = EXPR_DECORATOR;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 4

; 407  : 				opnd->saeflags = 0x10;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	BYTE PTR [rax+70], 16

; 408  : 				break;

	jmp	$LN2@get_operan

; 409  : 			}

	jmp	SHORT $LN34@get_operan
$LN33@get_operan:

; 410  : 			else if (opnd->is_opattr) /* OPATTR operator accepts anything! */

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	je	SHORT $LN36@get_operan

; 411  : 				break;

	jmp	$LN2@get_operan
$LN36@get_operan:
$LN34@get_operan:
$LN31@get_operan:
$LN28@get_operan:
$LN25@get_operan:
$LN22@get_operan:

; 412  : 			/* v2.0: display a comprehensible error msg if a quote is missing */
; 413  : 			if (tokenarray[i].string_delim == NULLC &&

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	test	eax, eax
	jne	SHORT $LN37@get_operan
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN39@get_operan
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN37@get_operan
$LN39@get_operan:

; 414  : 				(*tokenarray[i].string_ptr == '"' || *tokenarray[i].string_ptr == '\''))
; 415  : 				fnEmitErr(MISSING_QUOTATION_MARK_IN_STRING);

	mov	ecx, 166				; 000000a6H
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN38@get_operan
$LN37@get_operan:

; 416  : 			else
; 417  : 				fnEmitErr(MISSING_QUOTATION_MARK_IN_STRING, tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 166				; 000000a6H
	call	QWORD PTR fnEmitErr
$LN38@get_operan:

; 418  : 			return(ERROR);

	mov	eax, -1
	jmp	$LN1@get_operan
$LN20@get_operan:

; 419  : 		}
; 420  :         opnd->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 0

; 421  :         opnd->quoted_string = &tokenarray[i];

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 422  :         //opnd->value = 0;
; 423  :         tmp = tokenarray[i].string_ptr + 1; /* skip the quote */

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	inc	rax
	mov	QWORD PTR tmp$[rsp], rax

; 424  : 
; 425  :         /* v2.06: use max. 16 bytes to create the "value".
; 426  :          * Prior to 2.06, max 8 bytes were used for 64-bit and
; 427  :          * max 4 bytes were used for 16-/32-bit.
; 428  :          */
; 429  :         j = ( tokenarray[i].stringlen > sizeof( opnd->chararray ) ? sizeof( opnd->chararray ) : tokenarray[i].stringlen );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	cmp	rax, 16
	jbe	SHORT $LN133@get_operan
	mov	QWORD PTR tv325[rsp], 16
	jmp	SHORT $LN134@get_operan
$LN133@get_operan:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	QWORD PTR tv325[rsp], rax
$LN134@get_operan:
	mov	eax, DWORD PTR tv325[rsp]
	mov	DWORD PTR j$[rsp], eax

; 430  :         for( ; j; j-- )

	jmp	SHORT $LN6@get_operan
$LN4@get_operan:
	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	mov	DWORD PTR j$[rsp], eax
$LN6@get_operan:
	cmp	DWORD PTR j$[rsp], 0
	je	SHORT $LN5@get_operan

; 431  :             opnd->chararray[j-1] = *tmp++;

	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	rdx, QWORD PTR tmp$[rsp]
	movzx	edx, BYTE PTR [rdx]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR tmp$[rsp]
	inc	rax
	mov	QWORD PTR tmp$[rsp], rax
	jmp	SHORT $LN4@get_operan
$LN5@get_operan:

; 432  :         break;

	jmp	$LN2@get_operan
$LN40@get_operan:

; 433  :     case T_REG:
; 434  :         DebugMsg1(( "%u get_operand: T_REG, string=%s, tokval=%u, regno=%u\n", evallvl, tokenarray[i].string_ptr, tokenarray[i].tokval, tokenarray[i].bytval ));        

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	movsxd	rdx, DWORD PTR i$[rsp]
	imul	rdx, rdx, 32				; 00000020H
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	r9d, DWORD PTR [rax+rcx+16]
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rax+rdx+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11113
	call	DoDebugMsg1

; 435  :         opnd->kind = EXPR_REG;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 2

; 436  :         opnd->base_reg = &tokenarray[i];

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rcx+24], rax

; 437  :         j = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR j$[rsp], eax

; 438  :         
; 439  :         /* check if cpu is sufficient for register */
; 440  :         if( ( ( GetCpuSp( j ) & P_EXT_MASK ) &&
; 441  :              (( GetCpuSp( j ) & ModuleInfo.curr_cpu & P_EXT_MASK) == 0) ||

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, WORD PTR [rcx+rax+8]
	and	eax, 65280				; 0000ff00H
	test	eax, eax
	je	SHORT $LN43@get_operan
	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, WORD PTR [rcx+rax+8]
	and	eax, DWORD PTR ModuleInfo+392
	and	eax, 65280				; 0000ff00H
	test	eax, eax
	je	SHORT $LN42@get_operan
$LN43@get_operan:
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	movsxd	rcx, DWORD PTR j$[rsp]
	imul	rcx, rcx, 12
	lea	rdx, OFFSET FLAT:SpecialTable
	movzx	ecx, WORD PTR [rdx+rcx+8]
	and	ecx, 240				; 000000f0H
	cmp	eax, ecx
	jge	SHORT $LN41@get_operan
$LN42@get_operan:

; 442  :              ( ModuleInfo.curr_cpu & P_CPU_MASK ) < ( GetCpuSp( j ) & P_CPU_MASK ) ) ) {
; 443  :             /* v2.11: do not exit in indirect mode; avoids additional syntax error caused by ']' */
; 444  :             if ( flags & EXPF_IN_SQBR ) {

	movzx	eax, BYTE PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN44@get_operan

; 445  :                 opnd->kind = EXPR_ERROR;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], -1

; 446  :                 fnEmitErr( INSTRUCTION_OR_REGISTER_NOT_ACCEPTED_IN_CURRENT_CPU_MODE );

	mov	ecx, 30
	call	QWORD PTR fnEmitErr

; 447  :             } else

	jmp	SHORT $LN45@get_operan
$LN44@get_operan:

; 448  :                 return( fnEmitErr( INSTRUCTION_OR_REGISTER_NOT_ACCEPTED_IN_CURRENT_CPU_MODE ) );

	mov	ecx, 30
	call	QWORD PTR fnEmitErr
	jmp	$LN1@get_operan
$LN45@get_operan:
$LN41@get_operan:

; 449  :         }
; 450  : 
; 451  :         if( flags & EXPF_IN_SQBR ) {

	movzx	eax, BYTE PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	$LN46@get_operan

; 452  :             /* a valid index register? */
; 453  :             if ( GetSflagsSp( j ) & SFR_IREG ) {

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax+4]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN47@get_operan

; 454  :                 opnd->indirect = TRUE;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 1
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 455  :                 opnd->assumecheck = TRUE;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx+72], eax
	jmp	$LN48@get_operan
$LN47@get_operan:

; 456  :             } else if ( GetValueSp( j ) & OP_SR ) {

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 24576				; 00006000H
	test	eax, eax
	je	SHORT $LN49@get_operan

; 457  :                 /* a segment register inside square brackets is only
; 458  :                  * accepted by Masm if it is the segment part of an
; 459  :                  * address (mov ax,[bx+cs:label])!
; 460  :                  */
; 461  :                 /* v2.10: check moved here avain. regression v2.08-2.09, where
; 462  :                  * it was in colon_op(). see regression test OVERRID3.ASC.
; 463  :                  */
; 464  :                 //if( tokenarray[i+1].token != T_COLON ) {
; 465  :                 if( tokenarray[i+1].token != T_COLON ||

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN52@get_operan
	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	je	SHORT $LN51@get_operan
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 2
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	jne	SHORT $LN51@get_operan
$LN52@get_operan:

; 466  :                    ( Options.strict_masm_compat && tokenarray[i+2].token == T_REG ) ) {
; 467  :                     return( fnEmitErr( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	QWORD PTR fnEmitErr
	jmp	$LN1@get_operan
$LN51@get_operan:

; 468  :                 }
; 469  :             } else {

	jmp	SHORT $LN50@get_operan
$LN49@get_operan:

; 470  :                 if ( opnd->is_opattr ) /* v2.11: just set error for opattr */

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	je	SHORT $LN53@get_operan

; 471  :                     opnd->kind = EXPR_ERROR;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], -1
	jmp	SHORT $LN54@get_operan
$LN53@get_operan:

; 472  :                 else
; 473  :                   opnd->indirect = TRUE;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 1
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx+72], eax
$LN54@get_operan:
$LN50@get_operan:
$LN48@get_operan:
$LN46@get_operan:

; 474  :                     //return( fnEmitErr( MUST_BE_INDEX_OR_BASE_REGISTER ) );
; 475  :             }
; 476  :         }
; 477  :         break;

	jmp	$LN2@get_operan
$LN55@get_operan:

; 478  :     case T_ID:
; 479  :         tmp = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR tmp$[rsp], rax

; 480  :         //if ( opnd->type ) { /* v2.11 */
; 481  :         if ( opnd->is_dot ) {

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 7
	and	eax, 1
	test	eax, eax
	je	$LN56@get_operan

; 482  :             DebugMsg1(("%u get_operand: T_ID, is_dot=1, id=%s, opnd.type=%s\n", evallvl, tokenarray[i].string_ptr, opnd->type ? opnd->type->name : "NULL" ));

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN135@get_operan
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv451[rsp], rax
	jmp	SHORT $LN136@get_operan
$LN135@get_operan:
	lea	rax, OFFSET FLAT:$SG11131
	mov	QWORD PTR tv451[rsp], rax
$LN136@get_operan:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r9, QWORD PTR tv451[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11132
	call	DoDebugMsg1

; 483  :             //__debugbreak();
; 484  :             opnd->value = 0;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax], 0

; 485  :             sym = ( opnd->type ? SearchNameInStruct( opnd->type, tmp, &opnd->uvalue, 0 ) : NULL );

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN137@get_operan
	mov	rax, QWORD PTR opnd$[rsp]
	xor	r9d, r9d
	mov	r8, rax
	mov	rdx, QWORD PTR tmp$[rsp]
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR [rax+96]
	call	SearchNameInStruct
	mov	QWORD PTR tv470[rsp], rax
	jmp	SHORT $LN138@get_operan
$LN137@get_operan:
	mov	QWORD PTR tv470[rsp], 0
$LN138@get_operan:
	mov	rax, QWORD PTR tv470[rsp]
	mov	QWORD PTR sym$[rsp], rax

; 486  :             DebugMsg1(("get_operand(%s): is_dot, sym=%s, offset=%" I32_SPEC "Xh\n",

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN139@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv475[rsp], rax
	jmp	SHORT $LN140@get_operan
$LN139@get_operan:
	lea	rax, OFFSET FLAT:$SG11133
	mov	QWORD PTR tv475[rsp], rax
$LN140@get_operan:
	mov	rax, QWORD PTR opnd$[rsp]
	mov	r9d, DWORD PTR [rax]
	mov	r8, QWORD PTR tv475[rsp]
	mov	rdx, QWORD PTR tmp$[rsp]
	lea	rcx, OFFSET FLAT:$SG11134
	call	DoDebugMsg1

; 487  :                        tmp, sym ? sym->name : "NULL", opnd->uvalue ));
; 488  :             if ( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	$LN58@get_operan

; 489  :                 sym = SymSearch( tmp );

	mov	rcx, QWORD PTR tmp$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 490  :                 if ( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN59@get_operan

; 491  :                     /*
; 492  :                      * skip a type specifier matching the data item's type
; 493  :                      * that's something like "<item>.<type>.<member>"
; 494  :                      */
; 495  :                     if ( sym->state == SYM_TYPE ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN60@get_operan

; 496  :                         /*
; 497  :                          * v2.07: "if" added.
; 498  :                          * Masm accepts a different type spec if the "assumed"
; 499  :                          * type is undefined
; 500  :                          * v2.09: the change in v2.07 is a regression. if it's a type,
; 501  :                          * then "usually" assume a type coercion and "switch" to the
; 502  :                          * new type - but not for register assume. This isn't fixed
; 503  :                          * yet, because there's no way to find out if a register assume
; 504  :                          * did set field 'type'.
; 505  :                          * v2.09: oldstructs condition added, see regression test dotop4.asm.
; 506  :                          * v2.11: fixme? opnd->type may be NULL here?
; 507  :                          * v2.12: for opnd->type==NULL test case, see expr5.aso.
; 508  :                          */
; 509  :                         //if ( sym == opnd->type || opnd->type->isdefined == FALSE )
; 510  :                         //if ( sym == opnd->type || opnd->type->isdefined == FALSE || ModuleInfo.oldstructs )
; 511  :                         if ( sym == opnd->type || ( opnd->type && opnd->type->isdefined == FALSE ) || ModuleInfo.oldstructs )

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR sym$[rsp], rax
	je	SHORT $LN64@get_operan
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN65@get_operan
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN64@get_operan
$LN65@get_operan:
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 8
	and	eax, 1
	test	eax, eax
	je	SHORT $LN62@get_operan
$LN64@get_operan:

; 512  :                             ; //opnd->sym = sym;

	jmp	SHORT $LN63@get_operan
$LN62@get_operan:

; 513  :                         else {
; 514  :                             sym = NULL;

	mov	QWORD PTR sym$[rsp], 0
$LN63@get_operan:

; 515  :                         }

	jmp	SHORT $LN61@get_operan
$LN60@get_operan:

; 516  :                     } else if ( ModuleInfo.oldstructs &&

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 8
	and	eax, 1
	test	eax, eax
	je	SHORT $LN66@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 6
	je	SHORT $LN68@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	je	SHORT $LN68@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN66@get_operan
$LN68@get_operan:

; 517  :                                ( sym->state == SYM_STRUCT_FIELD ||
; 518  :                                 sym->state == SYM_EXTERNAL || /* v2.01: added */
; 519  :                                 /* v2.05: changed */
; 520  :                                 //( sym->state == SYM_INTERNAL && sym->mem_type == MT_ABS ) ) )
; 521  :                                 sym->state == SYM_INTERNAL ) )
; 522  :                         //opnd->sym = sym;
; 523  :                         ;

	jmp	SHORT $LN67@get_operan
$LN66@get_operan:

; 524  :                     else {
; 525  :                         /* fixme: clear sym?
; 526  :                          * if the symbol is not a type, it's an error which can
; 527  :                          * be detected in pass 1 already. dot_op() will emit
; 528  :                          * 'struct field expected' if sym isn't cleared.
; 529  :                          * v2.11: always clear sym.
; 530  :                          */
; 531  :                         //if ( opnd->type != nullstruct )
; 532  :                         sym = NULL;

	mov	QWORD PTR sym$[rsp], 0
$LN67@get_operan:
$LN61@get_operan:
$LN59@get_operan:
$LN58@get_operan:

; 533  :                     }
; 534  :                 }
; 535  :             }
; 536  :         } else {

	jmp	$LN57@get_operan
$LN56@get_operan:

; 537  :             DebugMsg1(("%u get_operand: T_ID, id=%s\n", evallvl, tokenarray[i].string_ptr ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11146
	call	DoDebugMsg1

; 538  :             /* ensure anonym labels are uppercase */
; 539  :             /* v2.06: changed. Previously member 'string_ptr' was used to
; 540  :              * store the anonymous label, but one cannot safely assume that
; 541  :              * there's enough free space for a larger symbol name! It (partly)
; 542  :              * worked by accident, because @F/@B usually are the last tokens
; 543  :              * in a line [ but see: .if ( eax == @F && ecx == 2 ) ].
; 544  :              */
; 545  :             if ( *tmp == '@' && *(tmp+2 ) == NULLC ) {

	mov	rax, QWORD PTR tmp$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN69@get_operan
	mov	rax, QWORD PTR tmp$[rsp]
	movsx	eax, BYTE PTR [rax+2]
	test	eax, eax
	jne	SHORT $LN69@get_operan

; 546  :                 if ( *(tmp+1) == 'b' || *(tmp+1 ) == 'B' )

	mov	rax, QWORD PTR tmp$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 98					; 00000062H
	je	SHORT $LN72@get_operan
	mov	rax, QWORD PTR tmp$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 66					; 00000042H
	jne	SHORT $LN70@get_operan
$LN72@get_operan:

; 547  :                     tmp = GetAnonymousLabel( labelbuff, 0 );

	xor	edx, edx
	lea	rcx, QWORD PTR labelbuff$[rsp]
	call	GetAnonymousLabel
	mov	QWORD PTR tmp$[rsp], rax
	jmp	SHORT $LN71@get_operan
$LN70@get_operan:

; 548  :                 else if (*(tmp+1) == 'f' || *(tmp+1 ) == 'F' )

	mov	rax, QWORD PTR tmp$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 102				; 00000066H
	je	SHORT $LN74@get_operan
	mov	rax, QWORD PTR tmp$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 70					; 00000046H
	jne	SHORT $LN73@get_operan
$LN74@get_operan:

; 549  :                     tmp = GetAnonymousLabel( labelbuff, 1 );

	mov	edx, 1
	lea	rcx, QWORD PTR labelbuff$[rsp]
	call	GetAnonymousLabel
	mov	QWORD PTR tmp$[rsp], rax
$LN73@get_operan:
$LN71@get_operan:
$LN69@get_operan:

; 550  :             }
; 551  :             sym = SymSearch( tmp );

	mov	rcx, QWORD PTR tmp$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax
$LN57@get_operan:

; 552  :         }
; 553  :         if ( sym == NULL ||
; 554  :             sym->state == SYM_UNDEFINED ||
; 555  :             ( sym->state == SYM_TYPE && sym->typekind == TYPE_NONE ) ||  /* v2.10: added */
; 556  : #if ALIAS_IN_EXPR == 0
; 557  :             sym->state == SYM_ALIAS || /* v2.04: added */
; 558  : #endif
; 559  :             sym->state == SYM_MACRO ||

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN77@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN77@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN78@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	test	eax, eax
	je	SHORT $LN77@get_operan
$LN78@get_operan:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	je	SHORT $LN77@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 10
	jne	$LN75@get_operan
$LN77@get_operan:

; 560  :             sym->state == SYM_TMACRO ) {
; 561  : 
; 562  :             /* for OPATTR, anything is ok */
; 563  :             if ( opnd->is_opattr ) {

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	je	SHORT $LN79@get_operan

; 564  :                 DebugMsg1(( "get_operand(%s): OPATTR, symbol invalid\n", tokenarray[i].string_ptr ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11158
	call	DoDebugMsg1

; 565  :                 opnd->kind = EXPR_ERROR;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], -1

; 566  :                 break;

	jmp	$LN2@get_operan
$LN79@get_operan:

; 567  :             }
; 568  : #if 0 /* v2.10: obsolete, since fnEmitErr() won't display anything in "EQU" mode */
; 569  :             /* if it is EQU, don't display an error, but return ERROR */
; 570  :             if ( flags & EXPF_NOERRMSG ) {
; 571  :                 DebugMsg1(("get_operand(%s): EQU, symbol invalid\n", tokenarray[i].string_ptr));
; 572  :                 return( ERROR );
; 573  :             }
; 574  : #endif
; 575  :             if ( sym && ( sym->state == SYM_MACRO ||

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN80@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	je	SHORT $LN81@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 10
	jne	SHORT $LN80@get_operan
$LN81@get_operan:

; 576  : #if ALIAS_IN_EXPR == 0
; 577  :                          sym->state == SYM_ALIAS || /* v2.04: added */
; 578  : #endif
; 579  :                          sym->state == SYM_TMACRO ) ) {
; 580  :                 DebugMsg1(("get_operand(%s): symbol is macro/textmacro/alias!\n", tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11161
	call	DoDebugMsg1

; 581  :                 fnEmitErr( INVALID_SYMBOL_TYPE_IN_EXPRESSION, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 243				; 000000f3H
	call	QWORD PTR fnEmitErr

; 582  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@get_operan
$LN80@get_operan:

; 583  :             }
; 584  :             /* v2.11: flag EXPF_NOUNDEF won't accept undefined symbols anymore.
; 585  :              * previously, it did just avoid to create a label with state SYM_UNDEFINED -
; 586  :              * hence the old name, EXPF_NOLCREATE
; 587  :              */
; 588  :             //if( Parse_Pass == PASS_1 ) {
; 589  :             if( Parse_Pass == PASS_1 && !( flags & EXPF_NOUNDEF ) ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN82@get_operan
	movzx	eax, BYTE PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	jne	$LN82@get_operan

; 590  :                 /* if symbol wasn't found, assume it is a forward ref! */
; 591  :                 if ( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	$LN84@get_operan

; 592  :                     /* v2.11: flag EXPF_NOLCREATE has got another meaning */
; 593  :                     //if ( opnd->type == NULL && !( flags & EXPF_NOLCREATE ) ) { /* added v1.95 */
; 594  :                     if ( opnd->type == NULL ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+96], 0
	jne	$LN85@get_operan

; 595  :                         sym = SymLookup( tmp );

	mov	rcx, QWORD PTR tmp$[rsp]
	call	SymLookup
	mov	QWORD PTR sym$[rsp], rax

; 596  :                         sym->state = SYM_UNDEFINED;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+32], 0

; 597  :                         sym_add_table( &SymTables[TAB_UNDEF], (struct dsym *)sym ); /* add UNDEFINED */

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_add_table

; 598  :                         DebugMsg1(("get_operand(%s): symbol not (yet) defined, CurrProc=%s\n", tmp, CurrProc ? CurrProc->sym.name : "NULL" ));

	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN141@get_operan
	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv592[rsp], rax
	jmp	SHORT $LN142@get_operan
$LN141@get_operan:
	lea	rax, OFFSET FLAT:$SG11167
	mov	QWORD PTR tv592[rsp], rax
$LN142@get_operan:
	mov	r8, QWORD PTR tv592[rsp]
	mov	rdx, QWORD PTR tmp$[rsp]
	lea	rcx, OFFSET FLAT:$SG11168
	call	DoDebugMsg1
	jmp	$LN86@get_operan
$LN85@get_operan:

; 599  :                     
; 600  :                     // } else if ( opnd->type == NULL || opnd->type != nullstruct ) { /* v2.08: if changed */
; 601  :                     // } else if ( opnd->type == NULL || opnd->type->typekind != TYPE_NONE ) { /* v2.11: if changed */
; 602  :                     } else if ( opnd->type->typekind != TYPE_NONE ) {

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+66]
	test	eax, eax
	je	$LN87@get_operan

; 603  :                         /* no struct or struct is known and defined */
; 604  :                         DebugMsg(("get_operand(%s): symbol error (type=%s typekind=%u)\n", tmp, opnd->type ? opnd->type->name : "NULL", opnd->type ? opnd->type->typekind : 0 ));

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN143@get_operan
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+66]
	mov	DWORD PTR tv605[rsp], eax
	jmp	SHORT $LN144@get_operan
$LN143@get_operan:
	mov	DWORD PTR tv605[rsp], 0
$LN144@get_operan:
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN145@get_operan
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv643[rsp], rax
	jmp	SHORT $LN146@get_operan
$LN145@get_operan:
	lea	rax, OFFSET FLAT:$SG11171
	mov	QWORD PTR tv643[rsp], rax
$LN146@get_operan:
	mov	r9d, DWORD PTR tv605[rsp]
	mov	r8, QWORD PTR tv643[rsp]
	mov	rdx, QWORD PTR tmp$[rsp]
	lea	rcx, OFFSET FLAT:$SG11172
	call	DoDebugMsg

; 605  :                         if ( *opnd->type->name )

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN89@get_operan

; 606  :                             fnEmitErr( MEMBER_NOT_DEFINED, opnd->type->name, tmp );

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	r8, QWORD PTR tmp$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 63					; 0000003fH
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN90@get_operan
$LN89@get_operan:

; 607  :                         else
; 608  :                             fnEmitErr( SYMBOL_NOT_DEFINED, tmp );

	mov	rdx, QWORD PTR tmp$[rsp]
	mov	ecx, 102				; 00000066H
	call	QWORD PTR fnEmitErr
$LN90@get_operan:

; 609  :                         return( ERROR );

	mov	eax, -1
	jmp	$LN1@get_operan

; 610  :                     } else {

	jmp	SHORT $LN88@get_operan
$LN87@get_operan:

; 611  :                         /* forward reference to a struct.
; 612  :                          * In these cases, assume everything is ok.
; 613  :                          */
; 614  :                         if ( !nullmbr ) {

	cmp	QWORD PTR nullmbr, 0
	jne	SHORT $LN91@get_operan

; 615  :                             nullmbr = SymAlloc( "" );

	lea	rcx, OFFSET FLAT:$SG11176
	call	SymAlloc
	mov	QWORD PTR nullmbr, rax
$LN91@get_operan:

; 616  :                         }
; 617  :                         DebugMsg(("get_operand(%s): forward reference to a struct (using nullmbr)\n", tmp ));

	mov	rdx, QWORD PTR tmp$[rsp]
	lea	rcx, OFFSET FLAT:$SG11177
	call	DoDebugMsg

; 618  :                         /* "break" because nullmbr has state SYM_UNDEFINED */
; 619  :                         opnd->mbr = nullmbr;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR nullmbr
	mov	QWORD PTR [rax+88], rcx

; 620  :                         opnd->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 0

; 621  :                         break;

	jmp	$LN2@get_operan
$LN88@get_operan:
$LN86@get_operan:
$LN84@get_operan:

; 622  :                     }
; 623  :                 }
; 624  :             } else {

	jmp	$LN83@get_operan
$LN82@get_operan:

; 625  :                 DebugMsg1(("get_operand(%s): symbol %s not defined, pass > 1, curr proc=>%s<, \n", tokenarray[i].string_ptr, tmp, CurrProc ? CurrProc->sym.name : "NULL" ));

	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN147@get_operan
	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv668[rsp], rax
	jmp	SHORT $LN148@get_operan
$LN147@get_operan:
	lea	rax, OFFSET FLAT:$SG11178
	mov	QWORD PTR tv668[rsp], rax
$LN148@get_operan:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r9, QWORD PTR tv668[rsp]
	mov	r8, QWORD PTR tmp$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11179
	call	DoDebugMsg1

; 626  :                 if ( opnd->type && *opnd->type->name ) {

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN92@get_operan
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN92@get_operan

; 627  :                     fnEmitErr( MEMBER_NOT_DEFINED, opnd->type->name, tmp );

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	r8, QWORD PTR tmp$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 63					; 0000003fH
	call	QWORD PTR fnEmitErr

; 628  :                 } else {

	jmp	SHORT $LN93@get_operan
$LN92@get_operan:

; 629  :                     fnEmitErr( SYMBOL_NOT_DEFINED, *(tmp+1) == '&' ? "@@" : tmp );

	mov	rax, QWORD PTR tmp$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN149@get_operan
	lea	rax, OFFSET FLAT:$SG11182
	mov	QWORD PTR tv693[rsp], rax
	jmp	SHORT $LN150@get_operan
$LN149@get_operan:
	mov	rax, QWORD PTR tmp$[rsp]
	mov	QWORD PTR tv693[rsp], rax
$LN150@get_operan:
	mov	rdx, QWORD PTR tv693[rsp]
	mov	ecx, 102				; 00000066H
	call	QWORD PTR fnEmitErr
$LN93@get_operan:

; 630  :                 }
; 631  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@get_operan
$LN83@get_operan:

; 632  :             }

	jmp	SHORT $LN76@get_operan
$LN75@get_operan:

; 633  : #if ALIAS_IN_EXPR /* v2.04b: added */
; 634  :         } else if ( sym->state == SYM_ALIAS ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 8
	jne	SHORT $LN94@get_operan

; 635  :             /* ALIAS symbols are not really useable in expressions.
; 636  :              * The alias' substitute symbol is, however.
; 637  :              */
; 638  :             sym = sym->substitute; /* can't be NULL */

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR sym$[rsp], rax
$LN94@get_operan:
$LN76@get_operan:

; 639  : #endif
; 640  :         }
; 641  :         /* set default values */
; 642  :         sym->used = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 1
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 643  :         DebugMsg1(("get_operand(%s): sym->state=%u type=>%s< ofs=%X memtype=%Xh total_size=%u defined=%u\n",

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN151@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv716[rsp], rax
	jmp	SHORT $LN152@get_operan
$LN151@get_operan:
	lea	rax, OFFSET FLAT:$SG11184
	mov	QWORD PTR tv716[rsp], rax
$LN152@get_operan:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	DWORD PTR [rsp+56], eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR tv716[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+32]
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	lea	rcx, OFFSET FLAT:$SG11185
	call	DoDebugMsg1

; 644  :                 tokenarray[i].string_ptr, sym->state, sym->type ? sym->type->name : "NULL", sym->offset, sym->mem_type, sym->total_size, sym->isdefined ));
; 645  :         switch ( sym->state ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv727[rsp], eax
	cmp	DWORD PTR tv727[rsp], 6
	je	$LN103@get_operan
	cmp	DWORD PTR tv727[rsp], 7
	je	SHORT $LN95@get_operan
	jmp	$LN104@get_operan
$LN95@get_operan:

; 646  :         case SYM_TYPE: /* STRUCT, UNION, RECORD, TYPEDEF */
; 647  :             /* v2.09: no structinfo data for typedefs */
; 648  :             if ( sym->typekind != TYPE_TYPEDEF && ((struct dsym *)sym)->e.structinfo->isOpen ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	je	SHORT $LN96@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+17]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN96@get_operan

; 649  :                 DebugMsg1(("get_operand(%s): struct/union definition isn't closed!\n", sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11188
	call	DoDebugMsg1

; 650  :                 opnd->kind = EXPR_ERROR;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], -1

; 651  :                 break;

	jmp	$LN7@get_operan
$LN96@get_operan:

; 652  :             }

	jmp	SHORT $LN11@get_operan
$LN9@get_operan:

; 653  :             /* skip "alias" types */
; 654  :             for ( ; sym->type; sym = sym->type );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym$[rsp], rax
$LN11@get_operan:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN10@get_operan
	jmp	SHORT $LN9@get_operan
$LN10@get_operan:

; 655  :             opnd->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 0

; 656  :             opnd->mem_type = sym->mem_type;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	mov	DWORD PTR [rax+64], ecx

; 657  :             opnd->is_type = TRUE;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 8
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 658  :             opnd->type = sym;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+96], rcx

; 659  :             DebugMsg1(("get_operand(%s): symbol.typekind=%u (STRUCT/UNION/TYPEDEF/RECORD)\n", sym->name, sym->typekind ));

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	mov	r8d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11189
	call	DoDebugMsg1

; 660  : 
; 661  :             /* v2.08: if() removed. This was an old hack. */
; 662  :             //if ( tokenarray[i-1].token != T_DOT && tokenarray[i+1].token != T_DOT )
; 663  :             /* v2.06: the default value for RECORD types is the mask value */
; 664  :             if ( sym->typekind == TYPE_RECORD ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 4
	jne	SHORT $LN97@get_operan

; 665  : #if AMD64_SUPPORT
; 666  :                 opnd->llvalue = GetRecordMask( (struct dsym *)sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetRecordMask
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	$LN98@get_operan
$LN97@get_operan:

; 667  : #else
; 668  :                 opnd->value = GetRecordMask( (struct dsym *)sym );
; 669  : #endif
; 670  :             } else if ( ( sym->mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS ) { /* v2.09: added */

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN99@get_operan

; 671  :                 if ( sym->mem_type == MT_PROC ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 128			; 00000080H
	jne	SHORT $LN101@get_operan

; 672  :                     opnd->value = sym->total_size;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax], ecx

; 673  :                     opnd->Ofssize = sym->Ofssize;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+44]
	mov	BYTE PTR [rax+69], cl

; 674  :                 } else

	jmp	SHORT $LN102@get_operan
$LN101@get_operan:

; 675  :                     opnd->value = GetTypeSize( sym->mem_type, sym->Ofssize );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	edx, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rax+36]
	call	GetTypeSize
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx], eax
$LN102@get_operan:

; 676  :             } else

	jmp	SHORT $LN100@get_operan
$LN99@get_operan:

; 677  :                 opnd->value = sym->total_size;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax], ecx
$LN100@get_operan:
$LN98@get_operan:

; 678  : 
; 679  :             break;

	jmp	$LN7@get_operan
$LN103@get_operan:

; 680  :         case SYM_STRUCT_FIELD:
; 681  :             DebugMsg1(("get_operand(%s): structure field, ofs=%Xh\n", sym->name, sym->offset ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+16]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11197
	call	DoDebugMsg1

; 682  : 
; 683  :             /* opnd->value might have been set by SearchNameInStruct() already! */
; 684  :             opnd->value += sym->offset;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR sym$[rsp]
	add	eax, DWORD PTR [rcx+16]
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx], eax

; 685  :             opnd->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 0

; 686  :             opnd->mbr = sym;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+88], rcx
	jmp	SHORT $LN14@get_operan
$LN12@get_operan:

; 687  :             /* skip "alias" types (probably obsolete by now!) */
; 688  :             for ( ; sym->type; sym = sym->type );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym$[rsp], rax
$LN14@get_operan:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN13@get_operan
	jmp	SHORT $LN12@get_operan
$LN13@get_operan:

; 689  :             opnd->mem_type = sym->mem_type;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	mov	DWORD PTR [rax+64], ecx

; 690  :             /*
; 691  :              * check if the member field is a type (struct or union).
; 692  :              * If yes, set the <type> member!
; 693  :              * this cannot be done in PrepareOp()
; 694  :              */
; 695  :             opnd->type = ( sym->state == SYM_TYPE && sym->typekind != TYPE_TYPEDEF ) ? sym : NULL;

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN153@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	je	SHORT $LN153@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR tv803[rsp], rax
	jmp	SHORT $LN154@get_operan
$LN153@get_operan:
	mov	QWORD PTR tv803[rsp], 0
$LN154@get_operan:
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR tv803[rsp]
	mov	QWORD PTR [rax+96], rcx

; 696  :             DebugMsg1(("get_operand: mem_type=%Xh type=%s\n", opnd->mem_type, opnd->type ? opnd->type->name : "NULL" ));

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN155@get_operan
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv808[rsp], rax
	jmp	SHORT $LN156@get_operan
$LN155@get_operan:
	lea	rax, OFFSET FLAT:$SG11198
	mov	QWORD PTR tv808[rsp], rax
$LN156@get_operan:
	mov	r8, QWORD PTR tv808[rsp]
	mov	rax, QWORD PTR opnd$[rsp]
	mov	edx, DWORD PTR [rax+64]
	lea	rcx, OFFSET FLAT:$SG11199
	call	DoDebugMsg1

; 697  :             break;

	jmp	$LN7@get_operan
$LN104@get_operan:

; 698  :         default: /* SYM_INTERNAL, SYM_EXTERNAL, SYM_SEG, SYM_GRP, SYM_STACK */
; 699  :             opnd->kind = EXPR_ADDR;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 1

; 700  :             /* call internal function (@Line, ... ) */
; 701  :             if ( sym->predefined && sym->sfunc_ptr )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN105@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+64], 0
	je	SHORT $LN105@get_operan

; 702  :                 sym->sfunc_ptr( sym, NULL );

	xor	edx, edx
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	call	QWORD PTR [rax+64]
$LN105@get_operan:

; 703  :             //if( opnd->sym->mem_type == MT_ABS ) {
; 704  :             if( sym->state == SYM_INTERNAL && sym->segment == NULL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	$LN106@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN106@get_operan

; 705  :                 opnd->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 0

; 706  :                 opnd->uvalue = sym->uvalue;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax], ecx

; 707  :                 opnd->hvalue = sym->value3264;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax+4], ecx

; 708  :                 DebugMsg1(("get_operand(%s): equate hval=%Xh, lval=%Xh\n", sym->name, opnd->hvalue, opnd->uvalue ));

	mov	rax, QWORD PTR opnd$[rsp]
	mov	r9d, DWORD PTR [rax]
	mov	rax, QWORD PTR opnd$[rsp]
	mov	r8d, DWORD PTR [rax+4]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11204
	call	DoDebugMsg1

; 709  :                 opnd->mem_type = sym->mem_type;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	mov	DWORD PTR [rax+64], ecx

; 710  :                 /* don't set the symbol reference, it isn't a label */
; 711  :             } else if( sym->state == SYM_EXTERNAL &&

	jmp	$LN107@get_operan
$LN106@get_operan:

; 712  :                       sym->mem_type == MT_EMPTY &&

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN108@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 192			; 000000c0H
	jne	SHORT $LN108@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN108@get_operan

; 713  :                       sym->iscomm == FALSE ) {
; 714  :                 /* type remains EXPR_ADDR, to force fixup creation */
; 715  :                 //opnd->mem_type = sym->mem_type; /* v2.10: unnecessary, init value IS MT_EMPTY */
; 716  :                 opnd->is_abs = TRUE;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 4
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 717  :                 opnd->sym = sym;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+80], rcx

; 718  :             } else {

	jmp	$LN109@get_operan
$LN108@get_operan:

; 719  :                 opnd->label_tok = &tokenarray[i];

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 720  : 
; 721  :                 /* a variable with arbitrary type? */
; 722  :                 /* v2.05: added check for MT_EMPTY */
; 723  :                 //if( opnd->sym->type ) { 
; 724  :                 if( sym->type && sym->type->mem_type != MT_EMPTY ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN110@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+36], 192			; 000000c0H
	je	SHORT $LN110@get_operan

; 725  :                     /* skip "alias" types */
; 726  :                     /* v2.05: obsolete */
; 727  :                     //for ( sym2 = opnd->sym; sym2->type; sym2 = sym2->type );
; 728  :                     //opnd->mem_type = sym2->mem_type;
; 729  :                     opnd->mem_type = sym->type->mem_type;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR [rcx+64], eax

; 730  :                 } else {

	jmp	SHORT $LN111@get_operan
$LN110@get_operan:

; 731  :                     opnd->mem_type = sym->mem_type;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	mov	DWORD PTR [rax+64], ecx
$LN111@get_operan:

; 732  :                 }
; 733  :                 /* since there is no fixup for auto variables, the "offset"
; 734  :                  must be stored in the <value> field */
; 735  :                 if ( sym->state == SYM_STACK ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 5
	jne	$LN112@get_operan

; 736  : #if STACKBASESUPP
; 737  :                   opnd->llvalue = sym->offset;// +StackAdj;

	mov	rax, QWORD PTR sym$[rsp]
	movsxd	rax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rcx], rax

; 738  :                     if ((ModuleInfo.win64_flags & W64F_HABRAN) && sym->isparam){

	movzx	eax, BYTE PTR ModuleInfo+413
	and	eax, 11
	test	eax, eax
	je	$LN113@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN113@get_operan

; 739  :                       int cnt = CurrProc->e.procinfo->pushed_reg;

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR cnt$4[rsp], eax

; 740  :                       cnt = cnt * 8;

	mov	eax, DWORD PTR cnt$4[rsp]
	shl	eax, 3
	mov	DWORD PTR cnt$4[rsp], eax

; 741  :                       cnt += sym->offset + CurrProc->e.procinfo->localsize + CurrProc->e.procinfo->xmmsize; //pointing to RSP

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	add	ecx, DWORD PTR [rax+36]
	mov	eax, ecx
	mov	rcx, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rcx+96]
	add	eax, DWORD PTR [rcx+72]
	mov	ecx, DWORD PTR cnt$4[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR cnt$4[rsp], eax

; 742  :                       cnt -= 8;     //pointing abowe RSP to the shadow space off RCX RDX R8 R9

	mov	eax, DWORD PTR cnt$4[rsp]
	sub	eax, 8
	mov	DWORD PTR cnt$4[rsp], eax

; 743  :                       opnd->llvalue = cnt;

	movsxd	rax, DWORD PTR cnt$4[rsp]
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rcx], rax
$LN113@get_operan:

; 744  :                     }
; 745  : #else
; 746  :                     opnd->llvalue = sym->offset;
; 747  : #endif
; 748  :                     opnd->indirect = TRUE;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 1
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 749  :                     /* v2.10: base register values now set here */
; 750  :                     opnd->base_reg = &tokenarray[i];

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rcx+24], rax

; 751  : #if STACKBASESUPP
; 752  :                     tokenarray[i].tokval = CurrProc->e.procinfo->basereg;

	mov	rax, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rax+96]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	movzx	eax, WORD PTR [rax+86]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	DWORD PTR [rdx+rcx+16], eax

; 753  : #else
; 754  :                     tokenarray[i].tokval = basereg[ModuleInfo.Ofssize];
; 755  : #endif
; 756  :                     tokenarray[i].bytval = GetRegNo( tokenarray[i].tokval );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movsxd	rdx, DWORD PTR i$[rsp]
	imul	rdx, rdx, 32				; 00000020H
	mov	r8, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR [r8+rdx+1], al
$LN112@get_operan:

; 757  :                 }
; 758  :                 opnd->sym = sym;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+80], rcx
	jmp	SHORT $LN17@get_operan
$LN15@get_operan:

; 759  :                 /* v2.09: added (also see change in PrepareOp() )
; 760  :                  * and see case SYM_STRUCT_FIELD.
; 761  :                  */
; 762  :                 for ( ; sym->type; sym = sym->type );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym$[rsp], rax
$LN17@get_operan:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN16@get_operan
	jmp	SHORT $LN15@get_operan
$LN16@get_operan:

; 763  :                 opnd->type = ( sym->state == SYM_TYPE && sym->typekind != TYPE_TYPEDEF ) ? sym : NULL;

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN157@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	je	SHORT $LN157@get_operan
	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR tv932[rsp], rax
	jmp	SHORT $LN158@get_operan
$LN157@get_operan:
	mov	QWORD PTR tv932[rsp], 0
$LN158@get_operan:
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR tv932[rsp]
	mov	QWORD PTR [rax+96], rcx
$LN109@get_operan:
$LN107@get_operan:
$LN7@get_operan:

; 764  :             }
; 765  :             break;
; 766  :         }
; 767  :         break;

	jmp	$LN2@get_operan
$LN114@get_operan:

; 768  :     case T_STYPE:
; 769  :         DebugMsg1(("%u get_operand: T_STYPE (>%s<, value=%X)\n", evallvl, tokenarray[i].string_ptr, tokenarray[i].tokval));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r9d, DWORD PTR [rdx+rax+16]
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rax+rcx+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11212
	call	DoDebugMsg1

; 770  :         opnd->kind = EXPR_CONST;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 0

; 771  :         /* for types, return the size as numeric constant */
; 772  :         /* fixme: mem_type should be set only when used as first arg of PTR op! */
; 773  :         opnd->mem_type = GetMemtypeSp( tokenarray[i].tokval );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx+64], eax

; 774  :         opnd->Ofssize = GetSflagsSp( tokenarray[i].tokval );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	rdx, QWORD PTR opnd$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+4]
	mov	BYTE PTR [rdx+69], al

; 775  :         opnd->value = GetTypeSize( opnd->mem_type, opnd->Ofssize );

	mov	rax, QWORD PTR opnd$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	mov	edx, eax
	mov	rax, QWORD PTR opnd$[rsp]
	mov	ecx, DWORD PTR [rax+64]
	call	GetTypeSize
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx], eax

; 776  :         opnd->is_type = TRUE;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	or	eax, 8
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rcx+72], eax

; 777  :         opnd->type = NULL; /* v2.08: added */

	mov	rax, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rax+96], 0

; 778  :         break;

	jmp	$LN2@get_operan
$LN115@get_operan:

; 779  :     case T_RES_ID:
; 780  :         DebugMsg1(("%u get_operand: T_RES_ID (>%s<, value=%X)\n", evallvl, tokenarray[i].string_ptr, tokenarray[i].tokval));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r9d, DWORD PTR [rdx+rax+16]
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rax+rcx+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11214
	call	DoDebugMsg1

; 781  :         if ( tokenarray[i].tokval == T_FLAT ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 261		; 00000105H
	jne	$LN116@get_operan

; 782  :             /* v2.09: query NOUNDEF flag */
; 783  :             //if ( error_msg ) { /* don't define FLAT group in EQU expression! */
; 784  :             if ( ( flags & EXPF_NOUNDEF ) == 0 ) {

	movzx	eax, BYTE PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN118@get_operan

; 785  :                 /* v2.08 cpu check added */
; 786  :                 if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < P_386 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jge	SHORT $LN119@get_operan

; 787  :                     fnEmitErr( INSTRUCTION_OR_REGISTER_NOT_ACCEPTED_IN_CURRENT_CPU_MODE );

	mov	ecx, 30
	call	QWORD PTR fnEmitErr

; 788  :                     return( ERROR );

	mov	eax, -1
	jmp	$LN1@get_operan
$LN119@get_operan:

; 789  :                 }
; 790  :                 DefineFlatGroup();

	call	DefineFlatGroup
$LN118@get_operan:

; 791  :             }
; 792  :             if ( !( opnd->sym = &ModuleInfo.flat_grp->sym ) )

	mov	rax, QWORD PTR ModuleInfo+440
	mov	QWORD PTR tv1002[rsp], rax
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR tv1002[rsp]
	mov	QWORD PTR [rax+80], rcx
	cmp	QWORD PTR tv1002[rsp], 0
	jne	SHORT $LN120@get_operan

; 793  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@get_operan
$LN120@get_operan:

; 794  : 
; 795  :             opnd->label_tok = &tokenarray[i];

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 796  :             opnd->kind = EXPR_ADDR;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 1

; 797  : 
; 798  :         } else {

	jmp	SHORT $LN117@get_operan
$LN116@get_operan:

; 799  :             return( fnEmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	QWORD PTR fnEmitErr
	jmp	$LN1@get_operan
$LN117@get_operan:

; 800  :         }
; 801  :         break;

	jmp	$LN2@get_operan
$LN121@get_operan:

; 802  :     case T_FLOAT: /* v2.05 */
; 803  :         DebugMsg1(("%u get_operand: T_FLOAT (>%s<)\n", evallvl, tokenarray[i].string_ptr ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11221
	call	DoDebugMsg1

; 804  :         opnd->kind = EXPR_FLOAT;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], 3

; 805  :         opnd->float_tok = &tokenarray[i];

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 806  :         //opnd->ftype = ( tokenarray[i].floattype != 0 );
; 807  :         break;

	jmp	$LN2@get_operan
$LN122@get_operan:

; 808  :     //case T_CL_BRACKET:
; 809  :     //case T_CL_SQ_BRACKET:
; 810  :     default:
; 811  :         DebugMsg1(("%u get_operand: default (token=%u, string=%s)\n", evallvl, tokenarray[i].token, tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r9, QWORD PTR [rdx+rax+8]
	mov	r8d, ecx
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11223
	call	DoDebugMsg1

; 812  :         if ( opnd->is_opattr ) {    /* for OPATTR, allow any operand */

	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	je	SHORT $LN123@get_operan

; 813  :             if ( tokenarray[i].token == T_FINAL ||
; 814  :                 tokenarray[i].token == T_CL_BRACKET ||

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN125@get_operan
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN125@get_operan
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 93					; 0000005dH
	jne	SHORT $LN124@get_operan
$LN125@get_operan:

; 815  :                 tokenarray[i].token == T_CL_SQ_BRACKET ) /* don't go beyond T_FINAL, ) or ] ! */
; 816  :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_operan
$LN124@get_operan:

; 817  :             break;

	jmp	$LN2@get_operan
$LN123@get_operan:

; 818  :         }
; 819  :         if ( tokenarray[i].token == T_BAD_NUM )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 12
	jne	SHORT $LN126@get_operan

; 820  :             /* Masm complains even if in EQU-mode */
; 821  :             fnEmitErr( NONDIGIT_IN_NUMBER, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 217				; 000000d9H
	call	QWORD PTR fnEmitErr
	jmp	$LN127@get_operan
$LN126@get_operan:

; 822  :         else if ( tokenarray[i].token == T_COLON )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN128@get_operan

; 823  :             fnEmitErr( SYNTAX_ERROR_UNEXPECTED_COLON );

	mov	ecx, 47					; 0000002fH
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN129@get_operan
$LN128@get_operan:

; 824  :         else if ( isalpha( *tokenarray[i].string_ptr ) )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalpha
	test	eax, eax
	je	SHORT $LN130@get_operan

; 825  :             fnEmitErr( EXPRESSION_EXPECTED, tokenarray[i].tokpos ); /* better error msg */

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 64					; 00000040H
	call	QWORD PTR fnEmitErr
	jmp	SHORT $LN131@get_operan
$LN130@get_operan:

; 826  :         else
; 827  :             fnEmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	QWORD PTR fnEmitErr
$LN131@get_operan:
$LN129@get_operan:
$LN127@get_operan:

; 828  :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@get_operan
$LN2@get_operan:

; 829  :     }
; 830  :     (*idx)++;

	mov	rax, QWORD PTR idx$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR idx$[rsp]
	mov	DWORD PTR [rcx], eax

; 831  :     DebugMsg1(("%u get_operand exit, ok, kind=%d value=%" I64_SPEC "X hvalue=%" I64_SPEC "X mem_type=%Xh abs=%u string=%s is_type=%u type=>%s< sym=%s mbr=%s\n",

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN159@get_operan
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv1110[rsp], rax
	jmp	SHORT $LN160@get_operan
$LN159@get_operan:
	lea	rax, OFFSET FLAT:$SG11233
	mov	QWORD PTR tv1110[rsp], rax
$LN160@get_operan:
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN161@get_operan
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv1116[rsp], rax
	jmp	SHORT $LN162@get_operan
$LN161@get_operan:
	lea	rax, OFFSET FLAT:$SG11234
	mov	QWORD PTR tv1116[rsp], rax
$LN162@get_operan:
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN163@get_operan
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv1122[rsp], rax
	jmp	SHORT $LN164@get_operan
$LN163@get_operan:
	lea	rax, OFFSET FLAT:$SG11235
	mov	QWORD PTR tv1122[rsp], rax
$LN164@get_operan:
	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN165@get_operan
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv1132[rsp], rax
	jmp	SHORT $LN166@get_operan
$LN165@get_operan:
	lea	rax, OFFSET FLAT:$SG11236
	mov	QWORD PTR tv1132[rsp], rax
$LN166@get_operan:
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 3
	and	eax, 1
	mov	rcx, QWORD PTR opnd$[rsp]
	mov	ecx, DWORD PTR [rcx+72]
	shr	ecx, 2
	and	ecx, 1
	mov	rdx, QWORD PTR tv1110[rsp]
	mov	QWORD PTR [rsp+88], rdx
	mov	rdx, QWORD PTR tv1116[rsp]
	mov	QWORD PTR [rsp+80], rdx
	mov	rdx, QWORD PTR tv1122[rsp]
	mov	QWORD PTR [rsp+72], rdx
	mov	DWORD PTR [rsp+64], eax
	mov	rax, QWORD PTR tv1132[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], ecx
	mov	rax, QWORD PTR opnd$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR opnd$[rsp]
	mov	r9, QWORD PTR [rax]
	mov	rax, QWORD PTR opnd$[rsp]
	mov	r8d, DWORD PTR [rax+60]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11237
	call	DoDebugMsg1

; 832  :                evallvl, opnd->kind, opnd->llvalue, opnd->hlvalue, opnd->mem_type, opnd->is_abs,
; 833  :                opnd->quoted_string ? opnd->quoted_string->string_ptr : "NULL",
; 834  :                opnd->is_type, opnd->type ? opnd->type->name : "NULL",
; 835  :                opnd->sym ? opnd->sym->name : "NULL",
; 836  :                opnd->mbr ? opnd->mbr->name : "NULL" ));
; 837  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@get_operan:

; 838  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:get_operand$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 352				; 00000160H
	pop	rdi
	ret	0
	npad	1
$LN167@get_operan:
	DD	$LN40@get_operan
	DD	$LN122@get_operan
	DD	$LN122@get_operan
	DD	$LN122@get_operan
	DD	$LN114@get_operan
	DD	$LN115@get_operan
	DD	$LN55@get_operan
	DD	$LN19@get_operan
	DD	$LN18@get_operan
	DD	$LN121@get_operan
get_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
val$ = 0
len$ = 4
end$ = 8
px$ = 16
tv78 = 24
src$ = 48
dst$ = 56
base$ = 64
size$ = 72
myatoi128 PROC

; 309  : {

$LN11:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 310  :     uint_32             val;
; 311  :     unsigned            len;
; 312  :     const char          *end = src + size;

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR end$[rsp], rax

; 313  :     uint_16             *px;
; 314  : 
; 315  :     dst[0] = 0;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dst$[rsp]
	mov	QWORD PTR [rcx+rax], 0

; 316  :     dst[1] = 0;

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR dst$[rsp]
	mov	QWORD PTR [rcx+rax], 0
$LN4@myatoi128:

; 317  :     do {
; 318  :         val = ( *src <= '9' ? *src - '0' : ( *src | 0x20 ) - 'a' + 10 );

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN9@myatoi128
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR tv78[rsp], eax
	jmp	SHORT $LN10@myatoi128
$LN9@myatoi128:
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	or	eax, 32					; 00000020H
	sub	eax, 87					; 00000057H
	mov	DWORD PTR tv78[rsp], eax
$LN10@myatoi128:
	mov	eax, DWORD PTR tv78[rsp]
	mov	DWORD PTR val$[rsp], eax

; 319  :         px = (uint_16 *)dst;

	mov	rax, QWORD PTR dst$[rsp]
	mov	QWORD PTR px$[rsp], rax

; 320  :         for ( len = ( 2 * sizeof( uint_64 ) ) >> 1; len; len-- ) {

	mov	DWORD PTR len$[rsp], 8
	jmp	SHORT $LN7@myatoi128
$LN5@myatoi128:
	mov	eax, DWORD PTR len$[rsp]
	dec	eax
	mov	DWORD PTR len$[rsp], eax
$LN7@myatoi128:
	cmp	DWORD PTR len$[rsp], 0
	je	SHORT $LN6@myatoi128

; 321  :             val += (uint_32)*px * base;

	mov	rax, QWORD PTR px$[rsp]
	movzx	eax, WORD PTR [rax]
	imul	eax, DWORD PTR base$[rsp]
	mov	ecx, DWORD PTR val$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR val$[rsp], eax

; 322  :             *(px++) = val;

	mov	rax, QWORD PTR px$[rsp]
	movzx	ecx, WORD PTR val$[rsp]
	mov	WORD PTR [rax], cx
	mov	rax, QWORD PTR px$[rsp]
	add	rax, 2
	mov	QWORD PTR px$[rsp], rax

; 323  :             val >>= 16;

	mov	eax, DWORD PTR val$[rsp]
	shr	eax, 16
	mov	DWORD PTR val$[rsp], eax

; 324  :         };

	jmp	SHORT $LN5@myatoi128
$LN6@myatoi128:

; 325  :         //myassert( val == 0 ); /* if number doesn't fit in 128 bits */
; 326  :         src++;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 327  :     } while( src < end );

	mov	rax, QWORD PTR end$[rsp]
	cmp	QWORD PTR src$[rsp], rax
	jb	$LN4@myatoi128

; 328  :     return;
; 329  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
myatoi128 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
mask$ = 0
i$ = 8
fl$ = 16
sym$1 = 24
tv93 = 32
record$ = 64
GetRecordMask PROC

; 283  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 284  : #if AMD64_SUPPORT
; 285  :     uint_64 mask = 0;

	mov	QWORD PTR mask$[rsp], 0

; 286  : #else
; 287  :     uint_32 mask = 0;
; 288  : #endif
; 289  :     int i;
; 290  :     struct sfield *fl;
; 291  : 
; 292  :     for ( fl = record->e.structinfo->head; fl; fl = fl->next ) {

	mov	rax, QWORD PTR record$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR fl$[rsp], rax
	jmp	SHORT $LN4@GetRecordM
$LN2@GetRecordM:
	mov	rax, QWORD PTR fl$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR fl$[rsp], rax
$LN4@GetRecordM:
	cmp	QWORD PTR fl$[rsp], 0
	je	SHORT $LN3@GetRecordM

; 293  :         struct asym *sym = &fl->sym;

	mov	rax, QWORD PTR fl$[rsp]
	mov	QWORD PTR sym$1[rsp], rax

; 294  :         for ( i = sym->offset ;i < sym->offset + sym->total_size; i++ )

	mov	rax, QWORD PTR sym$1[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN7@GetRecordM
$LN5@GetRecordM:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@GetRecordM:
	mov	rax, QWORD PTR sym$1[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR sym$1[rsp]
	add	eax, DWORD PTR [rcx+56]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN6@GetRecordM

; 295  :             mask |= 1 << i;

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv93[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv93[rsp]
	shl	eax, cl
	cdqe
	mov	rcx, QWORD PTR mask$[rsp]
	or	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR mask$[rsp], rax
	jmp	SHORT $LN5@GetRecordM
$LN6@GetRecordM:

; 296  :     }

	jmp	SHORT $LN2@GetRecordM
$LN3@GetRecordM:

; 297  :     return( mask );

	mov	rax, QWORD PTR mask$[rsp]

; 298  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
GetRecordMask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
tv70 = 0
tv88 = 4
tv77 = 8
tv92 = 12
mem_type$ = 32
Ofssize$ = 40
GetTypeSize PROC

; 264  : {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+32]

; 265  :     if ( (mem_type & MT_SPECIAL) == 0 )

	mov	eax, DWORD PTR mem_type$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN4@GetTypeSiz

; 266  :         return( ( mem_type & MT_SIZE_MASK ) + 1 );

	mov	eax, DWORD PTR mem_type$[rsp]
	and	eax, 31
	inc	eax
	jmp	$LN1@GetTypeSiz
$LN4@GetTypeSiz:

; 267  :     if ( Ofssize == USE_EMPTY )

	cmp	DWORD PTR Ofssize$[rsp], 254		; 000000feH
	jne	SHORT $LN5@GetTypeSiz

; 268  :         Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	DWORD PTR Ofssize$[rsp], eax
$LN5@GetTypeSiz:

; 269  :     switch ( mem_type ) {

	mov	eax, DWORD PTR mem_type$[rsp]
	mov	DWORD PTR tv70[rsp], eax
	cmp	DWORD PTR tv70[rsp], 129		; 00000081H
	je	SHORT $LN6@GetTypeSiz
	cmp	DWORD PTR tv70[rsp], 130		; 00000082H
	je	SHORT $LN7@GetTypeSiz
	jmp	SHORT $LN2@GetTypeSiz
$LN6@GetTypeSiz:

; 270  :     case MT_NEAR: return ( 0xFF00 | ( 2 << Ofssize ) ) ;

	mov	eax, DWORD PTR Ofssize$[rsp]
	mov	ecx, 2
	mov	DWORD PTR tv88[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv88[rsp]
	shl	eax, cl
	or	eax, 65280				; 0000ff00H
	jmp	SHORT $LN1@GetTypeSiz
$LN7@GetTypeSiz:

; 271  :     case MT_FAR:  return ( ( Ofssize == USE16 ) ? LS_FAR16 : 0xFF00 | ( ( 2 << Ofssize ) + 2 ) );

	cmp	DWORD PTR Ofssize$[rsp], 0
	jne	SHORT $LN9@GetTypeSiz
	mov	DWORD PTR tv77[rsp], 65285		; 0000ff05H
	jmp	SHORT $LN10@GetTypeSiz
$LN9@GetTypeSiz:
	mov	eax, DWORD PTR Ofssize$[rsp]
	mov	ecx, 2
	mov	DWORD PTR tv92[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv92[rsp]
	shl	eax, cl
	add	eax, 2
	or	eax, 65280				; 0000ff00H
	mov	DWORD PTR tv77[rsp], eax
$LN10@GetTypeSiz:
	mov	eax, DWORD PTR tv77[rsp]
	jmp	SHORT $LN1@GetTypeSiz
$LN2@GetTypeSiz:

; 272  :     }
; 273  :     /* shouldn't happen */
; 274  :     return( 0 );

	xor	eax, eax
$LN1@GetTypeSiz:

; 275  : }

	add	rsp, 16
	pop	rdi
	ret	0
GetTypeSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
tv66 = 32
tv72 = 36
tv76 = 40
item$ = 64
get_precedence PROC

; 144  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 145  :     /* The following table is taken verbatim from MASM 6.1 Programmer's Guide,
; 146  :      * page 14, Table 1.3.
; 147  : 
; 148  :      * 1            (), []
; 149  :      * 2            LENGTH, SIZE, WIDTH, MASK, LENGTHOF, SIZEOF
; 150  :      * 3            . (structure-field-name operator)
; 151  :      * 4            : (segment override operator), PTR
; 152  :      * 5            LROFFSET, OFFSET, SEG, THIS, TYPE
; 153  :      * 6            HIGH, HIGHWORD, LOW, LOWWORD
; 154  :      * 7            +, - (unary)
; 155  :      * 8            *, /, MOD, SHL, SHR
; 156  :      * 9            +, - (binary)
; 157  :      * 10           EQ, NE, LT, LE, GT, GE
; 158  :      * 11           NOT
; 159  :      * 12           AND
; 160  :      * 13           OR, XOR
; 161  :      * 14           OPATTR, SHORT, .TYPE
; 162  : 
; 163  :      * The following table appears in QuickHelp online documentation for
; 164  :      * both MASM 6.0 and 6.1. It's slightly different!
; 165  : 
; 166  :      * 1            LENGTH, SIZE, WIDTH, MASK
; 167  :      * 2            (), []
; 168  :      * 3            . (structure-field-name operator)
; 169  :      * 4            : (segment override operator), PTR
; 170  :      * 5            THIS, OFFSET, SEG, TYPE
; 171  :      * 6            HIGH, LOW
; 172  :      * 7            +, - (unary)
; 173  :      * 8            *, /, MOD, SHL, SHR
; 174  :      * 9            +, - (binary)
; 175  :      * 10           EQ, NE, LT, LE, GT, GE
; 176  :      * 11           NOT
; 177  :      * 12           AND
; 178  :      * 13           OR, XOR
; 179  :      * 14           SHORT, OPATTR, .TYPE, ADDR
; 180  : 
; 181  :      * japheth: the first table is the prefered one. Reasons:
; 182  :      * - () and [] must be first.
; 183  :      * - it contains operators SIZEOF, LENGTHOF, HIGHWORD, LOWWORD, LROFFSET
; 184  :      * - ADDR is no operator for expressions. It's exclusively used inside
; 185  :      *   INVOKE directive.
; 186  : 
; 187  :      * However, what's wrong in both tables is the precedence of
; 188  :      * the dot operator: Actually for both HJWasm and Wasm the dot precedence
; 189  :      * is 2 and LENGTH, SIZE, ... have precedence 3 instead.
; 190  : 
; 191  :      * Precedence of operator TYPE was 5 in original Wasm source. It has
; 192  :      * been changed to 4, as described in the Masm docs. This allows syntax
; 193  :      * "TYPE DWORD ptr xxx"
; 194  : 
; 195  :      * v2.02: another case which is problematic:
; 196  :      *     mov al,BYTE PTR CS:[]
; 197  :      * Since PTR and ':' have the very same priority, the evaluator will
; 198  :      * first calculate 'BYTE PTR CS'. This is invalid, but didn't matter
; 199  :      * prior to v2.02 because register coercion was never checked for
; 200  :      * plausibility. Solution: priority of ':' is changed from 4 to 3.
; 201  :      */
; 202  : 
; 203  :     switch( item->token ) {

	mov	rax, QWORD PTR item$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv66[rsp], eax
	mov	eax, DWORD PTR tv66[rsp]
	sub	eax, 4
	mov	DWORD PTR tv66[rsp], eax
	cmp	DWORD PTR tv66[rsp], 87			; 00000057H
	ja	$LN2@get_preced
	movsxd	rax, DWORD PTR tv66[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN15@get_preced[rcx+rax]
	mov	eax, DWORD PTR $LN16@get_preced[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@get_preced:

; 204  :     case T_UNARY_OPERATOR:
; 205  :     case T_BINARY_OPERATOR:
; 206  :         return( item->precedence );

	mov	rax, QWORD PTR item$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	jmp	$LN1@get_preced
$LN5@get_preced:

; 207  :     case T_OP_BRACKET:
; 208  :     case T_OP_SQ_BRACKET:
; 209  :         /* v2.08: with -Zm, the priority of [] and (), if
; 210  :          * used as binary operator, is 9 (like binary +/-).
; 211  :          * test cases: mov ax,+5[bx]
; 212  :          *             mov ax,-5[bx]
; 213  :          */
; 214  :         //return( 1 );
; 215  :         return( ModuleInfo.m510 ? 9 : 1 );

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 6
	and	eax, 1
	test	eax, eax
	je	SHORT $LN11@get_preced
	mov	DWORD PTR tv72[rsp], 9
	jmp	SHORT $LN12@get_preced
$LN11@get_preced:
	mov	DWORD PTR tv72[rsp], 1
$LN12@get_preced:
	mov	eax, DWORD PTR tv72[rsp]
	jmp	SHORT $LN1@get_preced
$LN6@get_preced:

; 216  :     case T_DOT:
; 217  :         return( 2 );

	mov	eax, 2
	jmp	SHORT $LN1@get_preced
$LN7@get_preced:

; 218  :     case T_COLON:
; 219  :         //return( 4 );
; 220  :         return( 3 ); /* changed for v2.02 */

	mov	eax, 3
	jmp	SHORT $LN1@get_preced
$LN8@get_preced:

; 221  :     case '*':
; 222  :     case '/':
; 223  :         return( 8 );

	mov	eax, 8
	jmp	SHORT $LN1@get_preced
$LN9@get_preced:

; 224  :     case '+':
; 225  :     case '-':
; 226  :         return( item->specval ? 9 : 7 );

	mov	rax, QWORD PTR item$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	test	eax, eax
	je	SHORT $LN13@get_preced
	mov	DWORD PTR tv76[rsp], 9
	jmp	SHORT $LN14@get_preced
$LN13@get_preced:
	mov	DWORD PTR tv76[rsp], 7
$LN14@get_preced:
	mov	eax, DWORD PTR tv76[rsp]
	jmp	SHORT $LN1@get_preced
$LN2@get_preced:

; 227  :     }
; 228  :     /* shouldn't happen! */
; 229  :     DebugMsg(("get_precedence: unexpected operator=%s\n", item->string_ptr));

	mov	rax, QWORD PTR item$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10985
	call	DoDebugMsg

; 230  :     fnEmitErr( SYNTAX_ERROR_EX, item->string_ptr );

	mov	rax, QWORD PTR item$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 209				; 000000d1H
	call	QWORD PTR fnEmitErr

; 231  :     return( ERROR );

	mov	eax, -1
$LN1@get_preced:

; 232  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN16@get_preced:
	DD	$LN4@get_preced
	DD	$LN5@get_preced
	DD	$LN8@get_preced
	DD	$LN9@get_preced
	DD	$LN6@get_preced
	DD	$LN7@get_preced
	DD	$LN2@get_preced
$LN15@get_preced:
	DB	0
	DB	0
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	1
	DB	6
	DB	2
	DB	3
	DB	6
	DB	3
	DB	4
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	1
get_precedence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
opnd1$ = 48
opnd2$ = 56
TokenAssign PROC

; 112  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 113  : #if 1
; 114  :     /* note that offsetof() is used. This means, don't change position
; 115  :      of field <type> in expr! */
; 116  :     memcpy( opnd1, opnd2, offsetof( struct expr, type ) );

	mov	r8d, 96					; 00000060H
	mov	rdx, QWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR opnd1$[rsp]
	call	memcpy

; 117  : #else
; 118  :     opnd1->llvalue  = opnd2->llvalue;
; 119  :     opnd1->hlvalue  = opnd2->hlvalue;
; 120  :     opnd1->quoted_string   = opnd2->quoted_string; /* probably useless */
; 121  :     opnd1->base_reg = opnd2->base_reg;
; 122  :     opnd1->idx_reg  = opnd2->idx_reg;
; 123  :     opnd1->label_tok = opnd2->label_tok;
; 124  :     opnd1->override = opnd2->override;
; 125  :     opnd1->instr    = opnd2->instr;
; 126  :     opnd1->kind     = opnd2->kind;
; 127  :     opnd1->mem_type = opnd2->mem_type;
; 128  :     opnd1->scale    = opnd2->scale;
; 129  :     opnd1->Ofssize  = opnd2->Ofssize;
; 130  :     opnd1->flags1   = opnd2->flags1;
; 131  :     opnd1->sym      = opnd2->sym;
; 132  :     opnd1->mbr      = opnd2->mbr;
; 133  : //  opnd1->type     = opnd2->type;
; 134  : #endif
; 135  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
TokenAssign ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
opnd$ = 16
init_expr PROC

; 90   : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 91   :     opnd->value    = 0;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax], 0

; 92   :     opnd->hvalue   = 0;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+4], 0

; 93   :     opnd->hlvalue  = 0;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rax+8], 0

; 94   :     opnd->quoted_string   = NULL;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rax+16], 0

; 95   :     opnd->base_reg = NULL;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rax+24], 0

; 96   :     opnd->idx_reg  = NULL;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rax+32], 0

; 97   :     opnd->label_tok = NULL;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rax+40], 0

; 98   :     opnd->override = NULL;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rax+48], 0

; 99   :     opnd->instr    = EMPTY;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+56], -2

; 100  :     opnd->kind     = EXPR_EMPTY;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], -2

; 101  :     opnd->mem_type = MT_EMPTY;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+64], 192			; 000000c0H

; 102  :     opnd->scale    = 0;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	BYTE PTR [rax+68], 0

; 103  :     opnd->Ofssize  = USE_EMPTY;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	BYTE PTR [rax+69], 254			; 000000feH

; 104  :     opnd->flags1   = 0;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	BYTE PTR [rax+72], 0

; 105  :     opnd->sym      = NULL;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rax+80], 0

; 106  :     opnd->mbr      = NULL;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rax+88], 0

; 107  :     opnd->type     = NULL;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rax+96], 0

; 108  : }

	pop	rdi
	ret	0
init_expr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
msg$ = 16
noEmitErr PROC

; 3430 : {

	mov	DWORD PTR [rsp+8], ecx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi

; 3431 :     return( ERROR );

	mov	eax, -1

; 3432 : }

	pop	rdi
	ret	0
noEmitErr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
opnd$ = 48
EmitConstError PROC

; 3458 : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 3459 :     if ( opnd->hlvalue != 0 )

	mov	rax, QWORD PTR opnd$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@EmitConstE

; 3460 :         EmitErr( CONSTANT_VALUE_TOO_LARGE_EX, opnd->hlvalue, opnd->value64 );

	mov	rax, QWORD PTR opnd$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR opnd$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 272				; 00000110H
	call	EmitErr
	jmp	SHORT $LN3@EmitConstE
$LN2@EmitConstE:

; 3461 :     else
; 3462 :         EmitErr( CONSTANT_VALUE_TOO_LARGE, opnd->value64 );

	mov	rax, QWORD PTR opnd$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	ecx, 235				; 000000ebH
	call	EmitErr
$LN3@EmitConstE:

; 3463 :     return( ERROR );

	mov	eax, -1

; 3464 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
EmitConstError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
ExprEvalInit PROC

; 3470 : {

$LN3:
	push	rdi

; 3471 :     thissym = NULL;

	mov	QWORD PTR thissym, 0

; 3472 :     nullstruct = NULL;

	mov	QWORD PTR nullstruct, 0

; 3473 :     nullmbr = NULL;

	mov	QWORD PTR nullmbr, 0

; 3474 : }

	pop	rdi
	ret	0
ExprEvalInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expreval.c
_TEXT	SEGMENT
i$ = 48
tv88 = 56
start_tok$ = 80
tokenarray$ = 88
end_tok$ = 96
result$ = 104
flags$ = 112
EvalOperand PROC

; 3440 : {

$LN9:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 3441 :     int         i;
; 3442 : 
; 3443 :     DebugMsg1(("EvalOperand(start=%u, end=%u, flags=%X) enter: >%s<\n", *start_tok, end_tok, flags, tokenarray[*start_tok].tokpos ));

	mov	rax, QWORD PTR start_tok$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	movzx	ecx, BYTE PTR flags$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rdx+rax+24]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, ecx
	mov	r8d, DWORD PTR end_tok$[rsp]
	mov	rax, QWORD PTR start_tok$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG12392
	call	DoDebugMsg1

; 3444 : 
; 3445 :     init_expr( result );

	mov	rcx, QWORD PTR result$[rsp]
	call	init_expr

; 3446 : 
; 3447 :     for( i = *start_tok; ( i < end_tok ) && is_expr_item( &tokenarray[i] ); i++ );

	mov	rax, QWORD PTR start_tok$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN4@EvalOperan
$LN2@EvalOperan:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@EvalOperan:
	mov	eax, DWORD PTR end_tok$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@EvalOperan
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	is_expr_item
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@EvalOperan
	jmp	SHORT $LN2@EvalOperan
$LN3@EvalOperan:

; 3448 :     if ( i == *start_tok )

	mov	rax, QWORD PTR start_tok$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$[rsp], eax
	jne	SHORT $LN5@EvalOperan

; 3449 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@EvalOperan
$LN5@EvalOperan:

; 3450 : 
; 3451 :     /* v2.10: global flag 'error_msg' replaced by 'fnEmitErr()' */
; 3452 :     fnEmitErr = ( ( flags & EXPF_NOERRMSG ) ? noEmitErr : EmitErr );

	movzx	eax, BYTE PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@EvalOperan
	lea	rax, OFFSET FLAT:noEmitErr
	mov	QWORD PTR tv88[rsp], rax
	jmp	SHORT $LN8@EvalOperan
$LN7@EvalOperan:
	lea	rax, OFFSET FLAT:EmitErr
	mov	QWORD PTR tv88[rsp], rax
$LN8@EvalOperan:
	mov	rax, QWORD PTR tv88[rsp]
	mov	QWORD PTR fnEmitErr, rax

; 3453 :     return ( evaluate( result, start_tok, tokenarray, i, flags ) );

	movzx	eax, BYTE PTR flags$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR i$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR start_tok$[rsp]
	mov	rcx, QWORD PTR result$[rsp]
	call	evaluate
$LN1@EvalOperan:

; 3454 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
EvalOperand ENDP
_TEXT	ENDS
END
