; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG1506	DB	'queue.c', 00H
_DATA	ENDS
PUBLIC	QEnqueue
PUBLIC	QAddItem
EXTRN	LclAlloc:PROC
EXTRN	InternalError:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
pdata	SEGMENT
$pdata$QEnqueue DD imagerel $LN7
	DD	imagerel $LN7+167
	DD	imagerel $unwind$QEnqueue
$pdata$QAddItem DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$QAddItem
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
xdata	SEGMENT
$unwind$QEnqueue DD 022301H
	DD	0700b520fH
$unwind$QAddItem DD 022301H
	DD	0700b520fH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\queue.c
_TEXT	SEGMENT
node$ = 32
q$ = 64
data$ = 72
QAddItem PROC

; 63   : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 64   :     struct qnode    *node;
; 65   : 
; 66   :     node = LclAlloc( sizeof( struct qnode ) );

	mov	ecx, 16
	call	LclAlloc
	mov	QWORD PTR node$[rsp], rax

; 67   :     node->elmt = data;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 68   :     QEnqueue( q, node );

	mov	rdx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR q$[rsp]
	call	QEnqueue

; 69   : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
QAddItem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\queue.c
_TEXT	SEGMENT
tv73 = 32
q$ = 64
item$ = 72
QEnqueue PROC

; 48   : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 49   :     if( q->head == NULL ) {

	mov	rax, QWORD PTR q$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN2@QEnqueue

; 50   :         q->head = q->tail = item;

	mov	rax, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR item$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR item$[rsp]
	mov	QWORD PTR [rax], rcx

; 51   :     } else {

	jmp	SHORT $LN3@QEnqueue
$LN2@QEnqueue:

; 52   : /**/    myassert( q->tail != NULL );

	mov	rax, QWORD PTR q$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN5@QEnqueue
	mov	DWORD PTR tv73[rsp], 0
	jmp	SHORT $LN6@QEnqueue
$LN5@QEnqueue:
	mov	edx, 52					; 00000034H
	lea	rcx, OFFSET FLAT:$SG1506
	call	InternalError
	mov	DWORD PTR tv73[rsp], eax
$LN6@QEnqueue:

; 53   :         *(void **)q->tail = item;

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR item$[rsp]
	mov	QWORD PTR [rax], rcx

; 54   :         q->tail = item;

	mov	rax, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR item$[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN3@QEnqueue:

; 55   :     }
; 56   :     *(void**)item = NULL;

	mov	rax, QWORD PTR item$[rsp]
	mov	QWORD PTR [rax], 0

; 57   : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
QEnqueue ENDP
_TEXT	ENDS
END
