; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	hTrmem:QWORD
COMM	FileTrmem:QWORD
_DATA	ENDS
CONST	SEGMENT
MSG_OUT_OF_MEMORY DB 'Tracker out of memory', 00H
	ORG $+2
MSG_CHUNK_BYTE_UNFREED DB '%U chunks (%L bytes) unfreed', 00H
	ORG $+3
MSG_SIZE_ZERO DB '%W size zero', 00H
	ORG $+3
MSG_OVERRUN_ALLOCATION DB '%W %D overrun allocation by %C of %U bytes', 00H
	ORG $+5
MSG_UNOWNED_CHUNK DB '%W unowned chunk %D', 00H
	ORG $+4
MSG_NULL_PTR DB	'%W NULL pointer', 00H
MSG_NO_ROUTINE DB 'Tracker was not given a %S routine!', 00H
	ORG $+4
MSG_NOT_IN_ALLOCATION DB '%W %D not in any allocation', 00H
	ORG $+4
MSG_OVERRUN_2 DB '%W %D+%U overruns allocation %D+%U', 00H
	ORG $+5
MSG_PRT_USAGE DB 'Current usage: %L bytes; Peak usage: %L bytes', 00H
	ORG $+2
MSG_MIN_ALLOC DB '%W allocation of %U less than minimum size', 00H
	ORG $+5
MSG_PRT_LIST_1 DB '  Who      Addr     Size     Call     Contents', 00H
	ORG $+1
MSG_PRT_LIST_2 DB '======== ======== ======== ======== =================='
	DB	'=========================', 00H
MSG_PRT_LIST_3 DB '%C %D %U %L %X', 00H
CONST	ENDS
_DATA	SEGMENT
$SG7174	DB	'0123456789abcdef', 00H
	ORG $+7
$SG7418	DB	'Validate', 00H
	ORG $+3
$SG7454	DB	'Alloc', 00H
	ORG $+2
$SG7456	DB	'Alloc', 00H
	ORG $+2
$SG7585	DB	'Expand', 00H
	ORG $+1
$SG7679	DB	'w', 00H
	ORG $+2
$SG7491	DB	'Validate', 00H
	ORG $+7
$SG7492	DB	'Validate', 00H
	ORG $+3
$SG7506	DB	'Free', 00H
	ORG $+3
$SG7508	DB	'Free', 00H
	ORG $+3
$SG7509	DB	'Free', 00H
	ORG $+7
$SG7575	DB	'Realloc', 00H
$SG7623	DB	'ChkRange', 00H
	ORG $+7
$SG7626	DB	'ChkRange', 00H
	ORG $+7
$SG7627	DB	'ChkRange', 00H
	ORG $+7
$SG7680	DB	'~hjwasm.trk', 00H
	ORG $+4
$SG7682	DB	'tm_Init: _trmem_open() failed', 0aH, 00H
	ORG $+1
$SG7683	DB	'tm_Init: fopen("~hjwasm.trk") failed [%u]', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_trmem_open
PUBLIC	_trmem_close
PUBLIC	_trmem_alloc
PUBLIC	_trmem_free
PUBLIC	_trmem_realloc
PUBLIC	_trmem_expand
PUBLIC	_trmem_strdup
PUBLIC	_trmem_msize
PUBLIC	_trmem_prt_usage
PUBLIC	_trmem_prt_list
PUBLIC	_trmem_get_current_usage
PUBLIC	_trmem_get_peak_usage
PUBLIC	_trmem_guess_who
PUBLIC	_trmem_validate_all
PUBLIC	_trmem_set_min_alloc
PUBLIC	_trmem_validate
PUBLIC	_trmem_chk_range
PUBLIC	_trmem_whoami
PUBLIC	tm_Init
PUBLIC	tm_Fini
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_exit:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strlen:PROC
EXTRN	__imp_isprint:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$_trmem_open DD imagerel $LN4
	DD	imagerel $LN4+242
	DD	imagerel $unwind$_trmem_open
$pdata$_trmem_close DD imagerel $LN10
	DD	imagerel $LN10+272
	DD	imagerel $unwind$_trmem_close
$pdata$_trmem_alloc DD imagerel $LN9
	DD	imagerel $LN9+399
	DD	imagerel $unwind$_trmem_alloc
$pdata$_trmem_free DD imagerel $LN6
	DD	imagerel $LN6+302
	DD	imagerel $unwind$_trmem_free
$pdata$_trmem_realloc DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$_trmem_realloc
$pdata$_trmem_expand DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$_trmem_expand
$pdata$_trmem_strdup DD imagerel $LN4
	DD	imagerel $LN4+122
	DD	imagerel $unwind$_trmem_strdup
$pdata$_trmem_msize DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$_trmem_msize
$pdata$_trmem_prt_usage DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$_trmem_prt_usage
$pdata$_trmem_prt_list DD imagerel $LN8
	DD	imagerel $LN8+258
	DD	imagerel $unwind$_trmem_prt_list
$pdata$_trmem_get_current_usage DD imagerel $LN3
	DD	imagerel $LN3+16
	DD	imagerel $unwind$_trmem_get_current_usage
$pdata$_trmem_get_peak_usage DD imagerel $LN3
	DD	imagerel $LN3+16
	DD	imagerel $unwind$_trmem_get_peak_usage
$pdata$_trmem_guess_who DD imagerel $LN3
	DD	imagerel $LN3+17
	DD	imagerel $unwind$_trmem_guess_who
$pdata$isValidChunk DD imagerel isValidChunk
	DD	imagerel isValidChunk+196
	DD	imagerel $unwind$isValidChunk
$pdata$setSize DD imagerel setSize
	DD	imagerel setSize+56
	DD	imagerel $unwind$setSize
$pdata$getSize DD imagerel getSize
	DD	imagerel getSize+43
	DD	imagerel $unwind$getSize
$pdata$stpcpy DD imagerel stpcpy
	DD	imagerel stpcpy+88
	DD	imagerel $unwind$stpcpy
$pdata$formHex DD imagerel formHex
	DD	imagerel formHex+158
	DD	imagerel $unwind$formHex
$pdata$formCodePtr DD imagerel formCodePtr
	DD	imagerel formCodePtr+66
	DD	imagerel $unwind$formCodePtr
$pdata$trPrt DD	imagerel trPrt
	DD	imagerel trPrt+1588
	DD	imagerel $unwind$trPrt
$pdata$allocEntry DD imagerel allocEntry
	DD	imagerel allocEntry+99
	DD	imagerel $unwind$allocEntry
$pdata$freeEntry DD imagerel freeEntry
	DD	imagerel freeEntry+54
	DD	imagerel $unwind$freeEntry
$pdata$addToList DD imagerel addToList
	DD	imagerel addToList+42
	DD	imagerel $unwind$addToList
$pdata$findOnList DD imagerel findOnList
	DD	imagerel findOnList+96
	DD	imagerel $unwind$findOnList
$pdata$removeFromList DD imagerel removeFromList
	DD	imagerel removeFromList+127
	DD	imagerel $unwind$removeFromList
$pdata$_trmem_validate_all DD imagerel $LN6
	DD	imagerel $LN6+121
	DD	imagerel $unwind$_trmem_validate_all
$pdata$_trmem_set_min_alloc DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$_trmem_set_min_alloc
$pdata$_trmem_validate DD imagerel $LN4
	DD	imagerel $LN4+144
	DD	imagerel $unwind$_trmem_validate
$pdata$ChangeAlloc DD imagerel ChangeAlloc
	DD	imagerel ChangeAlloc+1089
	DD	imagerel $unwind$ChangeAlloc
$pdata$_trmem_chk_range DD imagerel $LN9
	DD	imagerel $LN9+353
	DD	imagerel $unwind$_trmem_chk_range
$pdata$_trmem_whoami DD imagerel $LN3
	DD	imagerel $LN3+6
	DD	imagerel $unwind$_trmem_whoami
$pdata$memLine DD imagerel memLine
	DD	imagerel memLine+74
	DD	imagerel $unwind$memLine
$pdata$tm_Init DD imagerel $LN6
	DD	imagerel $LN6+194
	DD	imagerel $unwind$tm_Init
$pdata$tm_Fini DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$tm_Fini
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
	ORG $+1
trPrt$rtcName$0 DB 061H
	DB	072H
	DB	067H
	DB	073H
	DB	00H
	ORG $+3
trPrt$rtcName$1 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
	ORG $+3
trPrt$rtcVarDesc DD 050H
	DD	064H
	DQ	FLAT:trPrt$rtcName$1
	DD	028H
	DD	08H
	DQ	FLAT:trPrt$rtcName$0
	ORG $+96
trPrt$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:trPrt$rtcVarDesc
CONST	ENDS
xdata	SEGMENT
$unwind$_trmem_open DD 022d01H
	DD	070155219H
$unwind$_trmem_close DD 021e01H
	DD	07006720aH
$unwind$_trmem_alloc DD 022801H
	DD	070107214H
$unwind$_trmem_free DD 022801H
	DD	070107214H
$unwind$_trmem_realloc DD 022d01H
	DD	070155219H
$unwind$_trmem_expand DD 022d01H
	DD	070155219H
$unwind$_trmem_strdup DD 022801H
	DD	070105214H
$unwind$_trmem_msize DD 022301H
	DD	0700b320fH
$unwind$_trmem_prt_usage DD 021e01H
	DD	07006320aH
$unwind$_trmem_prt_list DD 021e01H
	DD	07006b20aH
$unwind$_trmem_get_current_usage DD 010601H
	DD	07006H
$unwind$_trmem_get_peak_usage DD 010601H
	DD	07006H
$unwind$_trmem_guess_who DD 010601H
	DD	07006H
$unwind$isValidChunk DD 022d01H
	DD	07015b219H
$unwind$setSize DD 010b01H
	DD	0700bH
$unwind$getSize DD 010601H
	DD	07006H
$unwind$stpcpy DD 010b01H
	DD	0700bH
$unwind$formHex DD 022701H
	DD	0700f1213H
$unwind$formCodePtr DD 022801H
	DD	070103214H
$unwind$trPrt DD 034519H
	DD	026011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$allocEntry DD 021e01H
	DD	07006520aH
$unwind$freeEntry DD 022301H
	DD	0700b320fH
$unwind$addToList DD 010b01H
	DD	0700bH
$unwind$findOnList DD 022301H
	DD	0700b120fH
$unwind$removeFromList DD 022301H
	DD	0700b120fH
$unwind$_trmem_validate_all DD 021e01H
	DD	07006520aH
$unwind$_trmem_set_min_alloc DD 010b01H
	DD	0700bH
$unwind$_trmem_validate DD 022801H
	DD	070107214H
$unwind$ChangeAlloc DD 022d01H
	DD	070159219H
$unwind$_trmem_chk_range DD 022d01H
	DD	07015b219H
$unwind$_trmem_whoami DD 010201H
	DD	07002H
$unwind$memLine DD 022801H
	DD	070103214H
$unwind$tm_Init DD 021501H
	DD	070027206H
$unwind$tm_Fini DD 021501H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
printf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
printf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:printf$rtcName$0
	ORG $+48
printf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:printf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
tm_Fini	PROC

; 790  : {

$LN3:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 791  :     /* if tm_Fini() is called, both hTrmem & memFile are != NULL */
; 792  :     _trmem_prt_list( hTrmem );

	mov	rcx, QWORD PTR hTrmem
	call	_trmem_prt_list

; 793  :     _trmem_close( hTrmem );

	mov	rcx, QWORD PTR hTrmem
	call	_trmem_close

; 794  :     fclose( FileTrmem );

	mov	rcx, QWORD PTR FileTrmem
	call	QWORD PTR __imp_fclose

; 795  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
tm_Fini	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
tm_Init	PROC

; 773  : {

$LN6:
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 774  :     if ( FileTrmem = fopen( TRMEM_LOGFN, "w" ) ) {

	lea	rdx, OFFSET FLAT:$SG7679
	lea	rcx, OFFSET FLAT:$SG7680
	call	QWORD PTR __imp_fopen
	mov	QWORD PTR FileTrmem, rax
	cmp	QWORD PTR FileTrmem, 0
	je	SHORT $LN2@tm_Init

; 775  :         //hTrmem = _trmem_open( malloc, free, realloc, _expand, memFile, memLine,
; 776  :         hTrmem = _trmem_open( malloc, free, _TRMEM_NO_REALLOC, _TRMEM_NO_REALLOC, FileTrmem, memLine,

	mov	DWORD PTR [rsp+48], 57			; 00000039H
	lea	rax, OFFSET FLAT:memLine
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR FileTrmem
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, QWORD PTR __imp_free
	mov	rcx, QWORD PTR __imp_malloc
	call	_trmem_open
	mov	QWORD PTR hTrmem, rax

; 777  :                   _TRMEM_ALLOC_SIZE_0 | _TRMEM_FREE_NULL | _TRMEM_OUT_OF_MEMORY | _TRMEM_CLOSE_CHECK_FREE );
; 778  :         if( hTrmem == NULL ) {

	cmp	QWORD PTR hTrmem, 0
	jne	SHORT $LN4@tm_Init

; 779  :             printf("tm_Init: _trmem_open() failed\n" );

	lea	rcx, OFFSET FLAT:$SG7682
	call	printf

; 780  :             exit( EXIT_FAILURE );

	mov	ecx, 1
	call	QWORD PTR __imp_exit
$LN4@tm_Init:

; 781  :         }
; 782  :     } else {

	jmp	SHORT $LN3@tm_Init
$LN2@tm_Init:

; 783  :         printf("tm_Init: fopen(\"" TRMEM_LOGFN "\") failed [%u]\n", errno );

	call	QWORD PTR __imp__errno
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG7683
	call	printf

; 784  :         exit( EXIT_FAILURE );

	mov	ecx, 1
	call	QWORD PTR __imp_exit
$LN3@tm_Init:
$LN5@tm_Init:

; 785  :     }
; 786  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
tm_Init	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
fh$ = 48
buf$ = 56
size$ = 64
memLine	PROC

; 765  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 766  :     //fwrite( "***",1, 3, stderr );
; 767  :     //fwrite( buf, 1, size, stderr );
; 768  :     fwrite( buf, 1, size, fh );

	mov	eax, DWORD PTR size$[rsp]
	mov	r9, QWORD PTR fh$[rsp]
	mov	r8d, eax
	mov	edx, 1
	mov	rcx, QWORD PTR buf$[rsp]
	call	QWORD PTR __imp_fwrite

; 769  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
memLine	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
_trmem_whoami PROC

; 748  : {

$LN3:
	push	rdi

; 749  :     return 0;

	xor	eax, eax

; 750  : }

	pop	rdi
	ret	0
_trmem_whoami ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
tr$ = 64
end$ = 72
end_of_mem$ = 80
start$ = 112
len$ = 120
who$ = 128
hdl$ = 136
_trmem_chk_range PROC

; 658  : {

$LN9:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rdi, rsp
	mov	ecx, 24
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+112]

; 659  :     entry_ptr   tr;
; 660  :     void        *end;
; 661  :     void        *end_of_mem;
; 662  : 
; 663  :     tr = hdl->alloc_list;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tr$[rsp], rax
$LN2@trmem_chk_:

; 664  :     for(;;) {
; 665  :         if( tr == 0 ) {

	cmp	QWORD PTR tr$[rsp], 0
	jne	SHORT $LN5@trmem_chk_

; 666  :             trPrt( hdl, MSG_NOT_IN_ALLOCATION, "ChkRange", who,

	mov	rax, QWORD PTR start$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR who$[rsp]
	lea	r8, OFFSET FLAT:$SG7623
	lea	rdx, OFFSET FLAT:MSG_NOT_IN_ALLOCATION
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt

; 667  :                 start );
; 668  :             return( 0 );

	xor	eax, eax
	jmp	$LN1@trmem_chk_
$LN5@trmem_chk_:

; 669  :         }
; 670  :         end_of_mem = _PtrAdd( tr->mem, getSize( tr ) );

	mov	rcx, QWORD PTR tr$[rsp]
	call	getSize
	mov	rcx, QWORD PTR tr$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR end_of_mem$[rsp], rax

; 671  :         if( _PtrCmp( start, >=, tr->mem ) &&

	mov	rax, QWORD PTR tr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	QWORD PTR start$[rsp], rax
	jb	SHORT $LN6@trmem_chk_
	mov	rax, QWORD PTR end_of_mem$[rsp]
	cmp	QWORD PTR start$[rsp], rax
	jae	SHORT $LN6@trmem_chk_

; 672  :             _PtrCmp( start, < , end_of_mem ) ) break;

	jmp	SHORT $LN3@trmem_chk_
$LN6@trmem_chk_:

; 673  :         tr = tr->next;

	mov	rax, QWORD PTR tr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tr$[rsp], rax

; 674  :     }

	jmp	$LN2@trmem_chk_
$LN3@trmem_chk_:

; 675  :     end = _PtrAdd( start, len );

	mov	rax, QWORD PTR len$[rsp]
	mov	rcx, QWORD PTR start$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR end$[rsp], rax

; 676  :     if( _PtrCmp( end, >, end_of_mem ) ) {

	mov	rax, QWORD PTR end_of_mem$[rsp]
	cmp	QWORD PTR end$[rsp], rax
	jbe	SHORT $LN7@trmem_chk_

; 677  :         trPrt( hdl, MSG_OVERRUN_2, "ChkRange", who,

	mov	rcx, QWORD PTR tr$[rsp]
	call	getSize
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR tr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR len$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR start$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR who$[rsp]
	lea	r8, OFFSET FLAT:$SG7626
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_2
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt

; 678  :             start, len, tr->mem, getSize( tr ) );
; 679  :         return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@trmem_chk_
$LN7@trmem_chk_:

; 680  :     }
; 681  :     return( isValidChunk( tr, "ChkRange", who, hdl ) );

	mov	r9, QWORD PTR hdl$[rsp]
	mov	r8, QWORD PTR who$[rsp]
	lea	rdx, OFFSET FLAT:$SG7627
	mov	rcx, QWORD PTR tr$[rsp]
	call	isValidChunk
$LN1@trmem_chk_:

; 682  : }

	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
_trmem_chk_range ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
tr$ = 48
new_block$ = 56
old_size$ = 64
old$ = 96
size$ = 104
who$ = 112
hdl$ = 120
fn$ = 128
name$ = 136
ChangeAlloc PROC

; 540  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 541  :     entry_ptr   tr;
; 542  :     void *      new_block;
; 543  :     size_t      old_size;
; 544  : 
; 545  :     if( fn == (void *) _TRMEM_NO_ROUTINE ) {

	cmp	QWORD PTR fn$[rsp], 0
	jne	SHORT $LN2@ChangeAllo

; 546  :         trPrt( hdl, MSG_NO_ROUTINE, name );

	mov	r8, QWORD PTR name$[rsp]
	lea	rdx, OFFSET FLAT:MSG_NO_ROUTINE
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt

; 547  :         return( NULL );

	xor	eax, eax
	jmp	$LN1@ChangeAllo
$LN2@ChangeAllo:

; 548  :     }
; 549  : 
; 550  :     if( size == 0 ) {

	cmp	QWORD PTR size$[rsp], 0
	jne	$LN3@ChangeAllo

; 551  :         if( hdl->flags & _TRMEM_REALLOC_SIZE_0 ) {

	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN4@ChangeAllo

; 552  :             trPrt( hdl, MSG_SIZE_ZERO, name, who );

	mov	r9, QWORD PTR who$[rsp]
	mov	r8, QWORD PTR name$[rsp]
	lea	rdx, OFFSET FLAT:MSG_SIZE_ZERO
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt
$LN4@ChangeAllo:

; 553  :         }
; 554  :         if( old == NULL ) {

	cmp	QWORD PTR old$[rsp], 0
	jne	SHORT $LN5@ChangeAllo

; 555  :             if( hdl->flags & _TRMEM_REALLOC_NULL ) {

	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN6@ChangeAllo

; 556  :                 trPrt( hdl, MSG_NULL_PTR, name, who );

	mov	r9, QWORD PTR who$[rsp]
	mov	r8, QWORD PTR name$[rsp]
	lea	rdx, OFFSET FLAT:MSG_NULL_PTR
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt
$LN6@ChangeAllo:

; 557  :             }
; 558  :             return( fn( NULL, 0 ) );

	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR fn$[rsp]
	jmp	$LN1@ChangeAllo
$LN5@ChangeAllo:

; 559  :         }
; 560  : 
; 561  :         /* old != NULL */
; 562  :         tr = removeFromList( old, hdl );

	mov	rdx, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR old$[rsp]
	call	removeFromList
	mov	QWORD PTR tr$[rsp], rax

; 563  :         if( tr == NULL ) {

	cmp	QWORD PTR tr$[rsp], 0
	jne	SHORT $LN7@ChangeAllo

; 564  :             trPrt( hdl, MSG_UNOWNED_CHUNK, name, who, old );

	mov	rax, QWORD PTR old$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR who$[rsp]
	mov	r8, QWORD PTR name$[rsp]
	lea	rdx, OFFSET FLAT:MSG_UNOWNED_CHUNK
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt

; 565  :             return( NULL );

	xor	eax, eax
	jmp	$LN1@ChangeAllo
$LN7@ChangeAllo:

; 566  :         }
; 567  :         isValidChunk( tr, name, who, hdl );

	mov	r9, QWORD PTR hdl$[rsp]
	mov	r8, QWORD PTR who$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR tr$[rsp]
	call	isValidChunk

; 568  :         size = getSize( tr );

	mov	rcx, QWORD PTR tr$[rsp]
	call	getSize
	mov	QWORD PTR size$[rsp], rax

; 569  :         hdl->mem_used -= size;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+8]
	sub	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR hdl$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 570  :         MEMSET( old, FREED_BYTE, size + 1 );

	mov	rax, QWORD PTR size$[rsp]
	inc	rax
	mov	r8, rax
	mov	edx, 189				; 000000bdH
	mov	rcx, QWORD PTR old$[rsp]
	call	memset

; 571  :         freeEntry( tr, hdl );

	mov	rdx, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR tr$[rsp]
	call	freeEntry

; 572  :         return( fn( old, 0 ) );

	xor	edx, edx
	mov	rcx, QWORD PTR old$[rsp]
	call	QWORD PTR fn$[rsp]
	jmp	$LN1@ChangeAllo
$LN3@ChangeAllo:

; 573  :     }
; 574  : 
; 575  :     /* size != 0 */
; 576  :     if( old == NULL ) {

	cmp	QWORD PTR old$[rsp], 0
	jne	$LN8@ChangeAllo

; 577  :         if( hdl->flags & _TRMEM_REALLOC_NULL ) {

	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN9@ChangeAllo

; 578  :             trPrt( hdl, MSG_NULL_PTR, name, who );

	mov	r9, QWORD PTR who$[rsp]
	mov	r8, QWORD PTR name$[rsp]
	lea	rdx, OFFSET FLAT:MSG_NULL_PTR
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt
$LN9@ChangeAllo:

; 579  :         }
; 580  :         new_block = fn( NULL, size + 1 );

	mov	rax, QWORD PTR size$[rsp]
	inc	rax
	mov	rdx, rax
	xor	ecx, ecx
	call	QWORD PTR fn$[rsp]
	mov	QWORD PTR new_block$[rsp], rax

; 581  :         if( new_block != NULL ) {

	cmp	QWORD PTR new_block$[rsp], 0
	je	$LN10@ChangeAllo

; 582  :             MEMSET( new_block, ALLOC_BYTE, size + 1 );

	mov	rax, QWORD PTR size$[rsp]
	inc	rax
	mov	r8, rax
	mov	edx, 165				; 000000a5H
	mov	rcx, QWORD PTR new_block$[rsp]
	call	memset

; 583  :             tr = allocEntry( hdl );

	mov	rcx, QWORD PTR hdl$[rsp]
	call	allocEntry
	mov	QWORD PTR tr$[rsp], rax

; 584  :             if( tr != NULL ) {

	cmp	QWORD PTR tr$[rsp], 0
	je	SHORT $LN11@ChangeAllo

; 585  :                 tr->mem = new_block;

	mov	rax, QWORD PTR tr$[rsp]
	mov	rcx, QWORD PTR new_block$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 586  :                 tr->who = who;

	mov	rax, QWORD PTR tr$[rsp]
	mov	rcx, QWORD PTR who$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 587  :                 setSize( tr, size );

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR tr$[rsp]
	call	setSize

; 588  :                 addToList( tr, hdl );

	mov	rdx, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR tr$[rsp]
	call	addToList
$LN11@ChangeAllo:

; 589  :             }
; 590  :             hdl->mem_used += size;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+8]
	add	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR hdl$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 591  :             if( hdl->mem_used > hdl->max_mem ) {

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR hdl$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	cmp	DWORD PTR [rax+8], ecx
	jbe	SHORT $LN12@ChangeAllo

; 592  :                 hdl->max_mem = hdl->mem_used;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR hdl$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax+12], ecx
$LN12@ChangeAllo:
$LN10@ChangeAllo:

; 593  :             }
; 594  :         }
; 595  :         return( new_block );

	mov	rax, QWORD PTR new_block$[rsp]
	jmp	$LN1@ChangeAllo
$LN8@ChangeAllo:

; 596  :     }
; 597  : 
; 598  :     /* old != NULL && size != 0 */
; 599  :     tr = removeFromList( old, hdl );

	mov	rdx, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR old$[rsp]
	call	removeFromList
	mov	QWORD PTR tr$[rsp], rax

; 600  :     if( tr == NULL ) {

	cmp	QWORD PTR tr$[rsp], 0
	jne	SHORT $LN13@ChangeAllo

; 601  :         trPrt( hdl, MSG_UNOWNED_CHUNK, name, who, old );

	mov	rax, QWORD PTR old$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR who$[rsp]
	mov	r8, QWORD PTR name$[rsp]
	lea	rdx, OFFSET FLAT:MSG_UNOWNED_CHUNK
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt

; 602  :         return( NULL );

	xor	eax, eax
	jmp	$LN1@ChangeAllo
$LN13@ChangeAllo:

; 603  :     }
; 604  :     if( !isValidChunk( tr, name, who, hdl ) ) {

	mov	r9, QWORD PTR hdl$[rsp]
	mov	r8, QWORD PTR who$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR tr$[rsp]
	call	isValidChunk
	test	eax, eax
	jne	SHORT $LN14@ChangeAllo

; 605  :         return( NULL );

	xor	eax, eax
	jmp	$LN1@ChangeAllo
$LN14@ChangeAllo:

; 606  :     }
; 607  :     new_block = fn( old, size + 1 );

	mov	rax, QWORD PTR size$[rsp]
	inc	rax
	mov	rdx, rax
	mov	rcx, QWORD PTR old$[rsp]
	call	QWORD PTR fn$[rsp]
	mov	QWORD PTR new_block$[rsp], rax

; 608  :     if( new_block == NULL ) {

	cmp	QWORD PTR new_block$[rsp], 0
	jne	SHORT $LN15@ChangeAllo

; 609  :         addToList( tr, hdl );   /* put back on list without change */

	mov	rdx, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR tr$[rsp]
	call	addToList

; 610  :         return( new_block );

	mov	rax, QWORD PTR new_block$[rsp]
	jmp	$LN1@ChangeAllo
$LN15@ChangeAllo:

; 611  :     }
; 612  :     old_size = getSize( tr );

	mov	rcx, QWORD PTR tr$[rsp]
	call	getSize
	mov	QWORD PTR old_size$[rsp], rax

; 613  :     if( size > old_size ) {

	mov	rax, QWORD PTR old_size$[rsp]
	cmp	QWORD PTR size$[rsp], rax
	jbe	SHORT $LN16@ChangeAllo

; 614  :         MEMSET(_PtrAdd( new_block, old_size ), ALLOC_BYTE, size + 1 - old_size);

	mov	rax, QWORD PTR size$[rsp]
	inc	rax
	sub	rax, QWORD PTR old_size$[rsp]
	mov	rcx, QWORD PTR old_size$[rsp]
	mov	rdx, QWORD PTR new_block$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, rax
	mov	edx, 165				; 000000a5H
	call	memset

; 615  :     } else {

	jmp	SHORT $LN17@ChangeAllo
$LN16@ChangeAllo:

; 616  :         *(unsigned char *)_PtrAdd( new_block, size ) = ALLOC_BYTE;

	mov	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR new_block$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rax], 165			; 000000a5H
$LN17@ChangeAllo:

; 617  :     }
; 618  :     hdl->mem_used -= old_size;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+8]
	sub	rax, QWORD PTR old_size$[rsp]
	mov	rcx, QWORD PTR hdl$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 619  :     hdl->mem_used += size;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+8]
	add	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR hdl$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 620  :     if( hdl->mem_used > hdl->max_mem ) {

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR hdl$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	cmp	DWORD PTR [rax+8], ecx
	jbe	SHORT $LN18@ChangeAllo

; 621  :         hdl->max_mem = hdl->mem_used;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR hdl$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax+12], ecx
$LN18@ChangeAllo:

; 622  :     }
; 623  :     tr->mem = new_block;

	mov	rax, QWORD PTR tr$[rsp]
	mov	rcx, QWORD PTR new_block$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 624  :     tr->who = who;

	mov	rax, QWORD PTR tr$[rsp]
	mov	rcx, QWORD PTR who$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 625  :     setSize( tr, size );

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR tr$[rsp]
	call	setSize

; 626  :     addToList( tr, hdl );

	mov	rdx, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR tr$[rsp]
	call	addToList

; 627  :     return( new_block );

	mov	rax, QWORD PTR new_block$[rsp]
$LN1@ChangeAllo:

; 628  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
ChangeAlloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
tr$ = 48
mem$ = 80
who$ = 88
hdl$ = 96
_trmem_validate PROC

; 498  : {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 499  :     entry_ptr tr;
; 500  : 
; 501  :     tr = findOnList( mem, hdl );

	mov	rdx, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR mem$[rsp]
	call	findOnList
	mov	QWORD PTR tr$[rsp], rax

; 502  :     if( tr == NULL ) {

	cmp	QWORD PTR tr$[rsp], 0
	jne	SHORT $LN2@trmem_vali

; 503  :         trPrt( hdl, MSG_UNOWNED_CHUNK, "Validate", who, mem );

	mov	rax, QWORD PTR mem$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR who$[rsp]
	lea	r8, OFFSET FLAT:$SG7491
	lea	rdx, OFFSET FLAT:MSG_UNOWNED_CHUNK
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt

; 504  :         return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@trmem_vali
$LN2@trmem_vali:

; 505  :     }
; 506  :     return( isValidChunk( tr, "Validate", who, hdl ) );

	mov	r9, QWORD PTR hdl$[rsp]
	mov	r8, QWORD PTR who$[rsp]
	lea	rdx, OFFSET FLAT:$SG7492
	mov	rcx, QWORD PTR tr$[rsp]
	call	isValidChunk
$LN1@trmem_vali:

; 507  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
_trmem_validate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
size$ = 16
hdl$ = 24
_trmem_set_min_alloc PROC

; 430  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 431  :     hdl->min_alloc = size;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR size$[rsp]
	mov	QWORD PTR [rax+80], rcx

; 432  : }

	pop	rdi
	ret	0
_trmem_set_min_alloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
walk$ = 32
result$ = 40
hdl$ = 64
_trmem_validate_all PROC

; 378  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 379  :     entry_ptr   walk;
; 380  :     int result = 1;

	mov	DWORD PTR result$[rsp], 1

; 381  : 
; 382  :     walk = hdl->alloc_list;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR walk$[rsp], rax
$LN2@trmem_vali:

; 383  :     while( walk ) {

	cmp	QWORD PTR walk$[rsp], 0
	je	SHORT $LN3@trmem_vali

; 384  :         //printf("trmem_validate_all: item=%p, next=%p, mem=%p\n", walk, walk->next, walk->mem );
; 385  :         if( !isValidChunk( walk, "Validate", 0, hdl ) ) {

	mov	r9, QWORD PTR hdl$[rsp]
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:$SG7418
	mov	rcx, QWORD PTR walk$[rsp]
	call	isValidChunk
	test	eax, eax
	jne	SHORT $LN4@trmem_vali

; 386  :             result = 0;

	mov	DWORD PTR result$[rsp], 0
$LN4@trmem_vali:

; 387  :         }
; 388  :         walk = walk->next;

	mov	rax, QWORD PTR walk$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR walk$[rsp], rax

; 389  :     }

	jmp	SHORT $LN2@trmem_vali
$LN3@trmem_vali:

; 390  :     return result;

	mov	eax, DWORD PTR result$[rsp]

; 391  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_trmem_validate_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
walk$ = 0
found$ = 8
mem$ = 32
hdl$ = 40
removeFromList PROC

; 328  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 329  :     entry_ptr_ptr   walk;
; 330  :     entry_ptr       found;
; 331  : 
; 332  :     walk = &hdl->alloc_list;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	QWORD PTR walk$[rsp], rax
$LN2@removeFrom:

; 333  :     while( *walk ) {

	mov	rax, QWORD PTR walk$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@removeFrom

; 334  :         //printf("removeFromList: item=%p, next=%p, mem=%p\n", *walk, (*walk)->next, (*walk)->mem );
; 335  :         if( _PtrCmp( (*walk)->mem, ==, mem ) ) {

	mov	rax, QWORD PTR walk$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR mem$[rsp]
	cmp	QWORD PTR [rax+8], rcx
	jne	SHORT $LN4@removeFrom

; 336  :             found = *walk;

	mov	rax, QWORD PTR walk$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR found$[rsp], rax

; 337  :             *walk = found->next;

	mov	rax, QWORD PTR walk$[rsp]
	mov	rcx, QWORD PTR found$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 338  :             return( found );

	mov	rax, QWORD PTR found$[rsp]
	jmp	SHORT $LN1@removeFrom
$LN4@removeFrom:

; 339  :         }
; 340  :         walk = &(*walk)->next;

	mov	rax, QWORD PTR walk$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR walk$[rsp], rax

; 341  :     }

	jmp	SHORT $LN2@removeFrom
$LN3@removeFrom:

; 342  :     return( NULL );

	xor	eax, eax
$LN1@removeFrom:

; 343  : }

	add	rsp, 16
	pop	rdi
	ret	0
removeFromList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
walk$ = 0
mem$ = 32
hdl$ = 40
findOnList PROC

; 313  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 314  :     entry_ptr       walk;
; 315  : 
; 316  :     walk = hdl->alloc_list;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR walk$[rsp], rax
$LN2@findOnList:

; 317  :     while( walk ) {

	cmp	QWORD PTR walk$[rsp], 0
	je	SHORT $LN3@findOnList

; 318  :         if( _PtrCmp( walk->mem, ==, mem ) ) {

	mov	rax, QWORD PTR walk$[rsp]
	mov	rcx, QWORD PTR mem$[rsp]
	cmp	QWORD PTR [rax+8], rcx
	jne	SHORT $LN4@findOnList

; 319  :             return( walk );

	mov	rax, QWORD PTR walk$[rsp]
	jmp	SHORT $LN1@findOnList
$LN4@findOnList:

; 320  :         }
; 321  :         walk = walk->next;

	mov	rax, QWORD PTR walk$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR walk$[rsp], rax

; 322  :     }

	jmp	SHORT $LN2@findOnList
$LN3@findOnList:

; 323  :     return( NULL );

	xor	eax, eax
$LN1@findOnList:

; 324  : }

	add	rsp, 16
	pop	rdi
	ret	0
findOnList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
tr$ = 16
hdl$ = 24
addToList PROC

; 307  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 308  :     tr->next = hdl->alloc_list;

	mov	rax, QWORD PTR tr$[rsp]
	mov	rcx, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 309  :     hdl->alloc_list = tr;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR tr$[rsp]
	mov	QWORD PTR [rax], rcx

; 310  : }

	pop	rdi
	ret	0
addToList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
tr$ = 48
hdl$ = 56
freeEntry PROC

; 302  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 303  :     hdl->free( tr );

	mov	rcx, QWORD PTR tr$[rsp]
	mov	rax, QWORD PTR hdl$[rsp]
	call	QWORD PTR [rax+32]

; 304  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
freeEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
tr$ = 32
hdl$ = 64
allocEntry PROC

; 291  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 292  :     entry_ptr   tr;
; 293  : 
; 294  :     tr = (entry_ptr) hdl->alloc( sizeof( entry ) );

	mov	ecx, 40					; 00000028H
	mov	rax, QWORD PTR hdl$[rsp]
	call	QWORD PTR [rax+24]
	mov	QWORD PTR tr$[rsp], rax

; 295  :     if( tr == NULL && ( hdl->flags & _TRMEM_OUT_OF_MEMORY ) ) {

	cmp	QWORD PTR tr$[rsp], 0
	jne	SHORT $LN2@allocEntry
	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN2@allocEntry

; 296  :         trPrt( hdl, MSG_OUT_OF_MEMORY );

	lea	rdx, OFFSET FLAT:MSG_OUT_OF_MEMORY
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt
$LN2@allocEntry:

; 297  :     }
; 298  :     return( tr );

	mov	rax, QWORD PTR tr$[rsp]

; 299  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
allocEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
args$ = 40
buff$ = 80
ptr$ = 200
ch$ = 208
ui$ = 212
ul$ = 216
dp$ = 224
who$ = 232
start$ = 240
xptr$ = 248
i$ = 256
size$ = 264
tv74 = 280
__$ArrayPad$ = 288
hdl$ = 320
fmt$ = 328
trPrt	PROC

; 192  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 304				; 00000130H
	mov	rdi, rsp
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+320]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 193  :     va_list     args;
; 194  :     char        buff[100];
; 195  :     char *      ptr;
; 196  :     char        ch;
; 197  :     uint        ui;
; 198  :     uint_32     ul;
; 199  :     void        *dp;
; 200  :     _trmem_who  who;
; 201  :     char *      start;
; 202  :     char *      xptr;
; 203  :     int         i;
; 204  :     size_t      size;
; 205  : 
; 206  :     va_start( args, fmt );

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 207  :     ptr = buff;

	lea	rax, QWORD PTR buff$[rsp]
	mov	QWORD PTR ptr$[rsp], rax
$LN2@trPrt:

; 208  :     for(;;) {
; 209  :         ch = *fmt++;

	mov	rax, QWORD PTR fmt$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR ch$[rsp], al
	mov	rax, QWORD PTR fmt$[rsp]
	inc	rax
	mov	QWORD PTR fmt$[rsp], rax

; 210  :         if( ch == '\0' ) break;

	movsx	eax, BYTE PTR ch$[rsp]
	test	eax, eax
	jne	SHORT $LN13@trPrt
	jmp	$LN3@trPrt
$LN13@trPrt:

; 211  :         if( ch == '%' ) {

	movsx	eax, BYTE PTR ch$[rsp]
	cmp	eax, 37					; 00000025H
	jne	$LN14@trPrt

; 212  :             ch = *fmt++;

	mov	rax, QWORD PTR fmt$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR ch$[rsp], al
	mov	rax, QWORD PTR fmt$[rsp]
	inc	rax
	mov	QWORD PTR fmt$[rsp], rax

; 213  :             switch( ch ) {

	movsx	eax, BYTE PTR ch$[rsp]
	mov	DWORD PTR tv74[rsp], eax
	mov	eax, DWORD PTR tv74[rsp]
	sub	eax, 67					; 00000043H
	mov	DWORD PTR tv74[rsp], eax
	cmp	DWORD PTR tv74[rsp], 21
	ja	$LN30@trPrt
	movsxd	rax, DWORD PTR tv74[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN32@trPrt[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN16@trPrt:

; 214  :             case 'W':   /* "a1(a2):" */
; 215  :                 ptr = stpcpy( ptr, va_arg( args, const char * ) );

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rdx, QWORD PTR [rax-8]
	mov	rcx, QWORD PTR ptr$[rsp]
	call	stpcpy
	mov	QWORD PTR ptr$[rsp], rax

; 216  :                 who = va_arg( args, _trmem_who );

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR who$[rsp], rax

; 217  :                 if( who != _TRMEM_NO_ROUTINE ) {

	cmp	QWORD PTR who$[rsp], 0
	je	SHORT $LN17@trPrt

; 218  :                     *ptr++ = '(';

	mov	rax, QWORD PTR ptr$[rsp]
	mov	BYTE PTR [rax], 40			; 00000028H
	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax

; 219  :                     ptr = formHex( ptr, (uint_32)who, sizeof( who ) );

	mov	r8d, 8
	mov	edx, DWORD PTR who$[rsp]
	mov	rcx, QWORD PTR ptr$[rsp]
	call	formHex
	mov	QWORD PTR ptr$[rsp], rax

; 220  :                     *ptr++ = ')';

	mov	rax, QWORD PTR ptr$[rsp]
	mov	BYTE PTR [rax], 41			; 00000029H
	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN17@trPrt:

; 221  :                 }
; 222  :                 *ptr++ = ':';

	mov	rax, QWORD PTR ptr$[rsp]
	mov	BYTE PTR [rax], 58			; 0000003aH
	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax

; 223  :                 break;

	jmp	$LN5@trPrt
$LN18@trPrt:

; 224  :             case 'C':   /* code pointer */
; 225  :                 who = va_arg( args, _trmem_who );

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR who$[rsp], rax

; 226  :                 ptr = formCodePtr( hdl, ptr, who );

	mov	r8, QWORD PTR who$[rsp]
	mov	rdx, QWORD PTR ptr$[rsp]
	mov	rcx, QWORD PTR hdl$[rsp]
	call	formCodePtr
	mov	QWORD PTR ptr$[rsp], rax

; 227  :                 break;

	jmp	$LN5@trPrt
$LN19@trPrt:

; 228  :             case 'D':   /* data pointer */
; 229  :                 dp = va_arg( args, void * );

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR dp$[rsp], rax

; 230  : #if defined( M_I86LM ) || defined( M_I86HM ) || defined( M_I86CM )
; 231  :                 ptr = formFarPtr( ptr, dp );
; 232  : #else
; 233  :                 ptr = formHex( ptr, (uint_32)dp, sizeof( dp ) );

	mov	r8d, 8
	mov	edx, DWORD PTR dp$[rsp]
	mov	rcx, QWORD PTR ptr$[rsp]
	call	formHex
	mov	QWORD PTR ptr$[rsp], rax

; 234  : #endif
; 235  :                 break;

	jmp	$LN5@trPrt
$LN20@trPrt:

; 236  :             case 'S':   /* char * (string) pointer */
; 237  :                 ptr = stpcpy( ptr, va_arg( args, char * ) );

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rdx, QWORD PTR [rax-8]
	mov	rcx, QWORD PTR ptr$[rsp]
	call	stpcpy
	mov	QWORD PTR ptr$[rsp], rax

; 238  :                 break;

	jmp	$LN5@trPrt
$LN21@trPrt:

; 239  :             case 'U':   /* unsigned integer */
; 240  :                 ui = va_arg( args, uint );

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	eax, DWORD PTR [rax-8]
	mov	DWORD PTR ui$[rsp], eax

; 241  :                 ptr = formHex( ptr, (uint_32)ui, sizeof( ui ) );

	mov	r8d, 4
	mov	edx, DWORD PTR ui$[rsp]
	mov	rcx, QWORD PTR ptr$[rsp]
	call	formHex
	mov	QWORD PTR ptr$[rsp], rax

; 242  :                 break;

	jmp	$LN5@trPrt
$LN22@trPrt:

; 243  :             case 'L':   /* unsigned long */
; 244  :                 ul = va_arg( args, uint_32 );

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	eax, DWORD PTR [rax-8]
	mov	DWORD PTR ul$[rsp], eax

; 245  :                 ptr = formHex( ptr, (uint_32)ul, sizeof( ul ) );

	mov	r8d, 4
	mov	edx, DWORD PTR ul$[rsp]
	mov	rcx, QWORD PTR ptr$[rsp]
	call	formHex
	mov	QWORD PTR ptr$[rsp], rax

; 246  :                 break;

	jmp	$LN5@trPrt
$LN23@trPrt:

; 247  :             case 'X':   /* 14 bytes of hex data */
; 248  :                 start = va_arg( args, char* );

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR start$[rsp], rax

; 249  :                 size = va_arg( args, size_t );

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR size$[rsp], rax

; 250  :                 if( size > 14 ) size = 14;

	cmp	QWORD PTR size$[rsp], 14
	jbe	SHORT $LN24@trPrt
	mov	QWORD PTR size$[rsp], 14
$LN24@trPrt:

; 251  :                 xptr = start;

	mov	rax, QWORD PTR start$[rsp]
	mov	QWORD PTR xptr$[rsp], rax

; 252  :                 for( i=0; i<14; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN9@trPrt
$LN7@trPrt:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN9@trPrt:
	cmp	DWORD PTR i$[rsp], 14
	jge	$LN8@trPrt

; 253  :                     if( i < size ) {

	movsxd	rax, DWORD PTR i$[rsp]
	cmp	rax, QWORD PTR size$[rsp]
	jae	SHORT $LN25@trPrt

; 254  :                         ptr = formHex( ptr, *xptr, sizeof( char ) );

	mov	rax, QWORD PTR xptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	r8d, 1
	mov	edx, eax
	mov	rcx, QWORD PTR ptr$[rsp]
	call	formHex
	mov	QWORD PTR ptr$[rsp], rax

; 255  :                         xptr++;

	mov	rax, QWORD PTR xptr$[rsp]
	inc	rax
	mov	QWORD PTR xptr$[rsp], rax

; 256  :                     } else {    // no more to print, so make things line up.

	jmp	SHORT $LN26@trPrt
$LN25@trPrt:

; 257  :                         *ptr = ' ';

	mov	rax, QWORD PTR ptr$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H

; 258  :                         *(ptr + 1) = ' ';

	mov	rax, QWORD PTR ptr$[rsp]
	mov	BYTE PTR [rax+1], 32			; 00000020H

; 259  :                         ptr += 2;

	mov	rax, QWORD PTR ptr$[rsp]
	add	rax, 2
	mov	QWORD PTR ptr$[rsp], rax
$LN26@trPrt:

; 260  :                     }
; 261  :                     if( i == 7 ) {

	cmp	DWORD PTR i$[rsp], 7
	jne	SHORT $LN27@trPrt

; 262  :                         *ptr = ' ';

	mov	rax, QWORD PTR ptr$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H

; 263  :                         ptr++;

	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN27@trPrt:

; 264  :                     }
; 265  :                 }

	jmp	$LN7@trPrt
$LN8@trPrt:

; 266  :                 for( i=0; i < size; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN12@trPrt
$LN10@trPrt:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN12@trPrt:
	movsxd	rax, DWORD PTR i$[rsp]
	cmp	rax, QWORD PTR size$[rsp]
	jae	SHORT $LN11@trPrt

; 267  :                     if( isprint( *start ) ) {

	mov	rax, QWORD PTR start$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isprint
	test	eax, eax
	je	SHORT $LN28@trPrt

; 268  :                         *ptr = *start;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	rcx, QWORD PTR start$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 269  :                     } else {

	jmp	SHORT $LN29@trPrt
$LN28@trPrt:

; 270  :                         *ptr = '.';

	mov	rax, QWORD PTR ptr$[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH
$LN29@trPrt:

; 271  :                     }
; 272  :                     ptr++;

	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax

; 273  :                     start++;

	mov	rax, QWORD PTR start$[rsp]
	inc	rax
	mov	QWORD PTR start$[rsp], rax

; 274  :                 }

	jmp	$LN10@trPrt
$LN11@trPrt:

; 275  :                 break;

	jmp	SHORT $LN5@trPrt
$LN30@trPrt:

; 276  :             default:
; 277  :                 *ptr++ = ch;

	mov	rax, QWORD PTR ptr$[rsp]
	movzx	ecx, BYTE PTR ch$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN5@trPrt:

; 278  :                 break;
; 279  :             }
; 280  :         } else {

	jmp	SHORT $LN15@trPrt
$LN14@trPrt:

; 281  :            *ptr++ = ch;

	mov	rax, QWORD PTR ptr$[rsp]
	movzx	ecx, BYTE PTR ch$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN15@trPrt:

; 282  :         }
; 283  :     }

	jmp	$LN2@trPrt
$LN3@trPrt:

; 284  :     va_end( args );

	mov	QWORD PTR args$[rsp], 0

; 285  :     *ptr++ = '\n';

	mov	rax, QWORD PTR ptr$[rsp]
	mov	BYTE PTR [rax], 10
	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax

; 286  :     *ptr = '\0';

	mov	rax, QWORD PTR ptr$[rsp]
	mov	BYTE PTR [rax], 0

; 287  :     hdl->prt_line( hdl->prt_parm, buff, ptr - buff );

	lea	rax, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR ptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rax, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR [rax+56]
	mov	rax, QWORD PTR hdl$[rsp]
	call	QWORD PTR [rax+64]

; 288  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:trPrt$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 304				; 00000130H
	pop	rdi
	ret	0
$LN32@trPrt:
	DD	$LN18@trPrt
	DD	$LN19@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN22@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN30@trPrt
	DD	$LN20@trPrt
	DD	$LN30@trPrt
	DD	$LN21@trPrt
	DD	$LN30@trPrt
	DD	$LN16@trPrt
	DD	$LN23@trPrt
trPrt	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
hdl$ = 48
ptr$ = 56
who$ = 64
formCodePtr PROC

; 183  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 184  : #if defined( M_I86LM ) || defined( M_I86HM ) || defined( M_I86MM )
; 185  :     return formFarPtr( ptr, who );
; 186  : #else
; 187  :     return formHex( ptr, (uint_32) who, sizeof(who) );

	mov	r8d, 8
	mov	edx, DWORD PTR who$[rsp]
	mov	rcx, QWORD PTR ptr$[rsp]
	call	formHex

; 188  : #endif
; 189  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
formCodePtr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
str$ = 0
ptr$ = 32
data$ = 40
size$ = 48
formHex	PROC

; 156  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 157  :     char            *str;
; 158  : 
; 159  :     size *= 2;

	mov	eax, DWORD PTR size$[rsp]
	shl	eax, 1
	mov	DWORD PTR size$[rsp], eax

; 160  :     ptr += size;

	mov	eax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rsp], rax

; 161  :     str = ptr;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR str$[rsp], rax

; 162  :     for( ; size > 0; size-- ) {

	jmp	SHORT $LN4@formHex
$LN2@formHex:
	mov	eax, DWORD PTR size$[rsp]
	dec	eax
	mov	DWORD PTR size$[rsp], eax
$LN4@formHex:
	cmp	DWORD PTR size$[rsp], 0
	jbe	SHORT $LN3@formHex

; 163  :         *--str = "0123456789abcdef"[data & 0x0f];

	mov	rax, QWORD PTR str$[rsp]
	dec	rax
	mov	QWORD PTR str$[rsp], rax
	mov	eax, DWORD PTR data$[rsp]
	and	eax, 15
	mov	eax, eax
	lea	rcx, OFFSET FLAT:$SG7174
	mov	rdx, QWORD PTR str$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [rdx], al

; 164  :         data >>= 4;

	mov	eax, DWORD PTR data$[rsp]
	shr	eax, 4
	mov	DWORD PTR data$[rsp], eax

; 165  :     }

	jmp	SHORT $LN2@formHex
$LN3@formHex:

; 166  :     return( ptr );

	mov	rax, QWORD PTR ptr$[rsp]

; 167  : }

	add	rsp, 16
	pop	rdi
	ret	0
formHex	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
dest$ = 16
src$ = 24
stpcpy	PROC

; 145  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 146  :     *dest = *src;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
$LN2@stpcpy:

; 147  :     while( *dest ) {

	mov	rax, QWORD PTR dest$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@stpcpy

; 148  :         ++dest;

	mov	rax, QWORD PTR dest$[rsp]
	inc	rax
	mov	QWORD PTR dest$[rsp], rax

; 149  :         ++src;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 150  :         *dest = *src;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 151  :     }

	jmp	SHORT $LN2@stpcpy
$LN3@stpcpy:

; 152  :     return( dest );

	mov	rax, QWORD PTR dest$[rsp]

; 153  : }

	pop	rdi
	ret	0
stpcpy	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
p$ = 16
getSize	PROC

; 136  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 137  :     return( p->size ^ (size_t)p->mem ^ (size_t)p->who ^ (size_t)p );

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax+24]
	xor	rax, rcx
	mov	rcx, QWORD PTR p$[rsp]
	xor	rax, QWORD PTR [rcx+16]
	xor	rax, QWORD PTR p$[rsp]

; 138  : }

	pop	rdi
	ret	0
getSize	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
p$ = 16
size$ = 24
setSize	PROC

; 131  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 132  :     p->size = size ^ (size_t)p->mem ^ (size_t)p->who ^ (size_t)p;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR size$[rsp]
	xor	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR p$[rsp]
	xor	rax, QWORD PTR [rcx+16]
	xor	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+24], rax

; 133  : }

	pop	rdi
	ret	0
setSize	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
mem$ = 64
size$ = 72
blk_size$ = 80
tr$ = 112
rtn$ = 120
who$ = 128
hdl$ = 136
isValidChunk PROC

; 468  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rdi, rsp
	mov	ecx, 24
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+112]

; 469  :     void *mem;
; 470  :     size_t size;
; 471  :     size_t blk_size;
; 472  : 
; 473  :     size = getSize( tr );

	mov	rcx, QWORD PTR tr$[rsp]
	call	getSize
	mov	QWORD PTR size$[rsp], rax

; 474  :     mem = tr->mem;

	mov	rax, QWORD PTR tr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR mem$[rsp], rax

; 475  :     blk_size = *(size_t*)_PtrSub( mem, sizeof( size_t ) );

	mov	rax, QWORD PTR mem$[rsp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR blk_size$[rsp], rax

; 476  : #ifndef __NETWARE__
; 477  : #if 0
; 478  :     if(( blk_size & 1 ) == 0 ) {
; 479  :         trPrt( hdl, MSG_UNDERRUN_ALLOCATION, rtn, who, mem, tr->who, size );
; 480  :         return( 0 );
; 481  :     }
; 482  :     blk_size &= ~1;
; 483  :     if( size > blk_size || ( blk_size - size ) > SIZE_DELTA ) {
; 484  :         trPrt( hdl, MSG_UNDERRUN_ALLOCATION, rtn, who, mem, tr->who, size );
; 485  :         return( 0 );
; 486  :     }
; 487  : #endif
; 488  : #endif
; 489  :     if( *(unsigned char *)_PtrAdd( mem, size ) != ALLOC_BYTE ) {

	mov	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR mem$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 165				; 000000a5H
	je	SHORT $LN2@isValidChu

; 490  :         trPrt( hdl, MSG_OVERRUN_ALLOCATION, rtn, who, mem, tr->who, size );

	mov	rax, QWORD PTR size$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR tr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR mem$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR who$[rsp]
	mov	r8, QWORD PTR rtn$[rsp]
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_ALLOCATION
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt

; 491  :         return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@isValidChu
$LN2@isValidChu:

; 492  :     }
; 493  :     return( 1 );

	mov	eax, 1
$LN1@isValidChu:

; 494  : }

	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
isValidChunk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
p$ = 16
_trmem_guess_who PROC

; 739  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 740  :     return( (_trmem_who)*((void **)p-1) );

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax-8]

; 741  : }

	pop	rdi
	ret	0
_trmem_guess_who ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
hdl$ = 16
_trmem_get_peak_usage PROC

; 731  : unsigned long _trmem_get_peak_usage( _trmem_hdl hdl ) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 732  : /*****************************************************/
; 733  :     return hdl->max_mem;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+12]

; 734  : }

	pop	rdi
	ret	0
_trmem_get_peak_usage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
hdl$ = 16
_trmem_get_current_usage PROC

; 726  : unsigned long _trmem_get_current_usage( _trmem_hdl hdl ) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 727  : /********************************************************/
; 728  :     return hdl->mem_used;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+8]

; 729  : }

	pop	rdi
	ret	0
_trmem_get_current_usage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
tr$ = 64
chunks$ = 72
size$ = 80
hdl$ = 112
_trmem_prt_list PROC

; 692  : {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rdi, rsp
	mov	ecx, 24
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+112]

; 693  :     entry_ptr   tr;
; 694  :     unsigned    chunks;
; 695  :     size_t      size;
; 696  : 
; 697  :     tr = hdl->alloc_list;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tr$[rsp], rax

; 698  :     if( tr == 0 ) return( 0 );

	cmp	QWORD PTR tr$[rsp], 0
	jne	SHORT $LN5@trmem_prt_
	xor	eax, eax
	jmp	$LN1@trmem_prt_
$LN5@trmem_prt_:

; 699  :     _trmem_prt_usage( hdl );

	mov	rcx, QWORD PTR hdl$[rsp]
	call	_trmem_prt_usage

; 700  :     trPrt( hdl, MSG_PRT_LIST_1 );

	lea	rdx, OFFSET FLAT:MSG_PRT_LIST_1
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt

; 701  :     trPrt( hdl, MSG_PRT_LIST_2 );

	lea	rdx, OFFSET FLAT:MSG_PRT_LIST_2
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt

; 702  :     chunks = 0;

	mov	DWORD PTR chunks$[rsp], 0
$LN4@trmem_prt_:

; 703  :     do {
; 704  :         size = getSize( tr );

	mov	rcx, QWORD PTR tr$[rsp]
	call	getSize
	mov	QWORD PTR size$[rsp], rax

; 705  :         if( chunks < 20 ) {

	cmp	DWORD PTR chunks$[rsp], 20
	jae	SHORT $LN6@trmem_prt_

; 706  :             trPrt( hdl

	mov	rax, QWORD PTR size$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR tr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR tr$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR size$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR tr$[rsp]
	mov	r9, QWORD PTR [rax+8]
	mov	rax, QWORD PTR tr$[rsp]
	mov	r8, QWORD PTR [rax+16]
	lea	rdx, OFFSET FLAT:MSG_PRT_LIST_3
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt
$LN6@trmem_prt_:

; 707  :                  , MSG_PRT_LIST_3
; 708  :                  , tr->who
; 709  :                  , tr->mem
; 710  :                  , size
; 711  :                  , tr->when
; 712  :                  , tr->mem
; 713  :                  , size );
; 714  :         }
; 715  :         ++chunks;

	mov	eax, DWORD PTR chunks$[rsp]
	inc	eax
	mov	DWORD PTR chunks$[rsp], eax

; 716  :         tr = tr->next;

	mov	rax, QWORD PTR tr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tr$[rsp], rax

; 717  :     } while( tr );

	cmp	QWORD PTR tr$[rsp], 0
	jne	$LN4@trmem_prt_

; 718  :     return( chunks );

	mov	eax, DWORD PTR chunks$[rsp]
$LN1@trmem_prt_:

; 719  : }

	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
_trmem_prt_list ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
hdl$ = 48
_trmem_prt_usage PROC

; 686  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 687  :     trPrt( hdl, MSG_PRT_USAGE, hdl->mem_used, hdl->max_mem );

	mov	rax, QWORD PTR hdl$[rsp]
	mov	r9d, DWORD PTR [rax+12]
	mov	rax, QWORD PTR hdl$[rsp]
	mov	r8d, DWORD PTR [rax+8]
	lea	rdx, OFFSET FLAT:MSG_PRT_USAGE
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt

; 688  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
_trmem_prt_usage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
mem$ = 48
hdl$ = 56
_trmem_msize PROC

; 721  : size_t _trmem_msize( void *mem, _trmem_hdl hdl ) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 722  : /************************************************/
; 723  :     return( getSize( findOnList( mem, hdl ) ) );

	mov	rdx, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR mem$[rsp]
	call	findOnList
	mov	rcx, rax
	call	getSize

; 724  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
_trmem_msize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
mem$ = 32
len$ = 40
str$ = 64
who$ = 72
hdl$ = 80
_trmem_strdup PROC

; 644  : {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 645  :     char    *mem;
; 646  :     size_t  len;
; 647  : 
; 648  :     len = strlen( str ) + 1;

	mov	rcx, QWORD PTR str$[rsp]
	call	strlen
	inc	rax
	mov	QWORD PTR len$[rsp], rax

; 649  :     mem = _trmem_alloc( len, who, hdl );

	mov	r8, QWORD PTR hdl$[rsp]
	mov	rdx, QWORD PTR who$[rsp]
	mov	rcx, QWORD PTR len$[rsp]
	call	_trmem_alloc
	mov	QWORD PTR mem$[rsp], rax

; 650  :     if( mem )

	cmp	QWORD PTR mem$[rsp], 0
	je	SHORT $LN2@trmem_strd

; 651  :         memcpy( mem, str, len );

	mov	r8, QWORD PTR len$[rsp]
	mov	rdx, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR mem$[rsp]
	call	memcpy
$LN2@trmem_strd:

; 652  :     return( mem );

	mov	rax, QWORD PTR mem$[rsp]

; 653  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_trmem_strdup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
old$ = 64
size$ = 72
who$ = 80
hdl$ = 88
_trmem_expand PROC

; 638  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 639  :     return( ChangeAlloc( old, size, who, hdl, hdl->expand, "Expand" ) );

	lea	rax, OFFSET FLAT:$SG7585
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR hdl$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR hdl$[rsp]
	mov	r8, QWORD PTR who$[rsp]
	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR old$[rsp]
	call	ChangeAlloc

; 640  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_trmem_expand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
old$ = 64
size$ = 72
who$ = 80
hdl$ = 88
_trmem_realloc PROC

; 632  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 633  :     return( ChangeAlloc( old, size, who, hdl, hdl->realloc, "Realloc" ) );

	lea	rax, OFFSET FLAT:$SG7575
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR hdl$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR hdl$[rsp]
	mov	r8, QWORD PTR who$[rsp]
	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR old$[rsp]
	call	ChangeAlloc

; 634  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_trmem_realloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
tr$ = 48
size$ = 56
mem$ = 80
who$ = 88
hdl$ = 96
_trmem_free PROC

; 511  : {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 512  :     entry_ptr   tr;
; 513  :     size_t      size;
; 514  : 
; 515  :     if( mem == NULL ) {

	cmp	QWORD PTR mem$[rsp], 0
	jne	SHORT $LN2@trmem_free

; 516  :         if( hdl->flags & _TRMEM_FREE_NULL ) {

	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN3@trmem_free

; 517  :             trPrt( hdl, MSG_NULL_PTR, "Free", who );

	mov	r9, QWORD PTR who$[rsp]
	lea	r8, OFFSET FLAT:$SG7506
	lea	rdx, OFFSET FLAT:MSG_NULL_PTR
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt
$LN3@trmem_free:

; 518  :         }
; 519  :         hdl->free( mem );

	mov	rcx, QWORD PTR mem$[rsp]
	mov	rax, QWORD PTR hdl$[rsp]
	call	QWORD PTR [rax+32]

; 520  :         return;

	jmp	$LN1@trmem_free
$LN2@trmem_free:

; 521  :     }
; 522  :     //printf("trmem_free: item=%p\n", mem );
; 523  :     tr = removeFromList( mem, hdl );

	mov	rdx, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR mem$[rsp]
	call	removeFromList
	mov	QWORD PTR tr$[rsp], rax

; 524  :     if( tr == NULL ) {

	cmp	QWORD PTR tr$[rsp], 0
	jne	SHORT $LN4@trmem_free

; 525  :         trPrt( hdl, MSG_UNOWNED_CHUNK, "Free", who, mem );

	mov	rax, QWORD PTR mem$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR who$[rsp]
	lea	r8, OFFSET FLAT:$SG7508
	lea	rdx, OFFSET FLAT:MSG_UNOWNED_CHUNK
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt

; 526  :         return;

	jmp	SHORT $LN1@trmem_free
$LN4@trmem_free:

; 527  :     }
; 528  :     isValidChunk( tr, "Free", who, hdl );

	mov	r9, QWORD PTR hdl$[rsp]
	mov	r8, QWORD PTR who$[rsp]
	lea	rdx, OFFSET FLAT:$SG7509
	mov	rcx, QWORD PTR tr$[rsp]
	call	isValidChunk

; 529  :     size = getSize( tr );

	mov	rcx, QWORD PTR tr$[rsp]
	call	getSize
	mov	QWORD PTR size$[rsp], rax

; 530  :     hdl->mem_used -= size;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+8]
	sub	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR hdl$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 531  :     MEMSET( mem, FREED_BYTE, size + 1 );

	mov	rax, QWORD PTR size$[rsp]
	inc	rax
	mov	r8, rax
	mov	edx, 189				; 000000bdH
	mov	rcx, QWORD PTR mem$[rsp]
	call	memset

; 532  :     freeEntry( tr, hdl );

	mov	rdx, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR tr$[rsp]
	call	freeEntry

; 533  :     hdl->free( mem );

	mov	rcx, QWORD PTR mem$[rsp]
	mov	rax, QWORD PTR hdl$[rsp]
	call	QWORD PTR [rax+32]
$LN1@trmem_free:

; 534  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
_trmem_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
mem$ = 48
tr$ = 56
size$ = 80
who$ = 88
hdl$ = 96
_trmem_alloc PROC

; 436  : {

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 437  :     void        *mem;
; 438  :     entry_ptr   tr;
; 439  : 
; 440  :     hdl->alloc_no += 1;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+16]
	inc	eax
	mov	rcx, QWORD PTR hdl$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 441  :     if( size == 0 && ( hdl->flags & _TRMEM_ALLOC_SIZE_0 ) ) {

	cmp	QWORD PTR size$[rsp], 0
	jne	SHORT $LN2@trmem_allo
	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@trmem_allo

; 442  :         trPrt( hdl, MSG_SIZE_ZERO, "Alloc", who );

	mov	r9, QWORD PTR who$[rsp]
	lea	r8, OFFSET FLAT:$SG7454
	lea	rdx, OFFSET FLAT:MSG_SIZE_ZERO
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt

; 443  :         return ( NULL );

	xor	eax, eax
	jmp	$LN1@trmem_allo
	jmp	SHORT $LN3@trmem_allo
$LN2@trmem_allo:

; 444  :     } else if( size < hdl->min_alloc ) {

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	QWORD PTR size$[rsp], rax
	jae	SHORT $LN4@trmem_allo

; 445  :         trPrt( hdl, MSG_MIN_ALLOC, "Alloc", who, size );

	mov	rax, QWORD PTR size$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR who$[rsp]
	lea	r8, OFFSET FLAT:$SG7456
	lea	rdx, OFFSET FLAT:MSG_MIN_ALLOC
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt
$LN4@trmem_allo:
$LN3@trmem_allo:

; 446  :     }
; 447  :     mem = hdl->alloc( size + 1 );

	mov	rax, QWORD PTR size$[rsp]
	inc	rax
	mov	rcx, rax
	mov	rax, QWORD PTR hdl$[rsp]
	call	QWORD PTR [rax+24]
	mov	QWORD PTR mem$[rsp], rax

; 448  :     if( mem != NULL ) {

	cmp	QWORD PTR mem$[rsp], 0
	je	$LN5@trmem_allo

; 449  :         MEMSET( mem, ALLOC_BYTE, size + 1 );

	mov	rax, QWORD PTR size$[rsp]
	inc	rax
	mov	r8, rax
	mov	edx, 165				; 000000a5H
	mov	rcx, QWORD PTR mem$[rsp]
	call	memset

; 450  :         tr = allocEntry( hdl );

	mov	rcx, QWORD PTR hdl$[rsp]
	call	allocEntry
	mov	QWORD PTR tr$[rsp], rax

; 451  :         if( tr != NULL ) {

	cmp	QWORD PTR tr$[rsp], 0
	je	SHORT $LN6@trmem_allo

; 452  :             tr->mem = mem;

	mov	rax, QWORD PTR tr$[rsp]
	mov	rcx, QWORD PTR mem$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 453  :             tr->who = who;

	mov	rax, QWORD PTR tr$[rsp]
	mov	rcx, QWORD PTR who$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 454  :             tr->when = hdl->alloc_no;

	mov	rax, QWORD PTR tr$[rsp]
	mov	rcx, QWORD PTR hdl$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax+32], ecx

; 455  :             setSize( tr, size );

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR tr$[rsp]
	call	setSize

; 456  :             addToList( tr, hdl );

	mov	rdx, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR tr$[rsp]
	call	addToList
$LN6@trmem_allo:

; 457  :         }
; 458  :         hdl->mem_used += size;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+8]
	add	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR hdl$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 459  :         if( hdl->mem_used > hdl->max_mem ) {

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR hdl$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	cmp	DWORD PTR [rax+8], ecx
	jbe	SHORT $LN7@trmem_allo

; 460  :             hdl->max_mem = hdl->mem_used;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR hdl$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax+12], ecx
$LN7@trmem_allo:
$LN5@trmem_allo:

; 461  :         }
; 462  :     }
; 463  :     return( mem );

	mov	rax, QWORD PTR mem$[rsp]
$LN1@trmem_allo:

; 464  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
_trmem_alloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
chunks$ = 32
mem_used$ = 36
walk$ = 40
next$ = 48
hdl$ = 80
_trmem_close PROC

; 395  : {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 396  :     uint        chunks;
; 397  :     uint_32     mem_used;
; 398  :     entry_ptr   walk;
; 399  :     entry_ptr   next;
; 400  : 
; 401  :     chunks = 0;

	mov	DWORD PTR chunks$[rsp], 0

; 402  :     if( hdl->flags & _TRMEM_CLOSE_CHECK_FREE ) {

	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN6@trmem_clos

; 403  :         mem_used = hdl->mem_used;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR mem_used$[rsp], eax

; 404  :         walk = hdl->alloc_list;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR walk$[rsp], rax
$LN2@trmem_clos:

; 405  :         while( walk ) {

	cmp	QWORD PTR walk$[rsp], 0
	je	SHORT $LN3@trmem_clos

; 406  :             //printf("trmem_close: item=%p, next=%p, mem=%p\n", walk, walk->next, walk->mem );
; 407  :             next = walk->next;

	mov	rax, QWORD PTR walk$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR next$[rsp], rax

; 408  :             ++chunks;

	mov	eax, DWORD PTR chunks$[rsp]
	inc	eax
	mov	DWORD PTR chunks$[rsp], eax

; 409  :             _trmem_free( walk->mem, _TRMEM_NO_ROUTINE, hdl );

	mov	r8, QWORD PTR hdl$[rsp]
	xor	edx, edx
	mov	rax, QWORD PTR walk$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	_trmem_free

; 410  :             walk = next;

	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR walk$[rsp], rax

; 411  :         }

	jmp	SHORT $LN2@trmem_clos
$LN3@trmem_clos:

; 412  :         if( chunks ) {

	cmp	DWORD PTR chunks$[rsp], 0
	je	SHORT $LN8@trmem_clos

; 413  :             trPrt( hdl, MSG_CHUNK_BYTE_UNFREED, chunks, mem_used );

	mov	r9d, DWORD PTR mem_used$[rsp]
	mov	r8d, DWORD PTR chunks$[rsp]
	lea	rdx, OFFSET FLAT:MSG_CHUNK_BYTE_UNFREED
	mov	rcx, QWORD PTR hdl$[rsp]
	call	trPrt
$LN8@trmem_clos:

; 414  :         }
; 415  :     } else {

	jmp	SHORT $LN7@trmem_clos
$LN6@trmem_clos:

; 416  :         walk = hdl->alloc_list;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR walk$[rsp], rax
$LN4@trmem_clos:

; 417  :         while( walk ) {

	cmp	QWORD PTR walk$[rsp], 0
	je	SHORT $LN5@trmem_clos

; 418  :             next = walk->next;

	mov	rax, QWORD PTR walk$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR next$[rsp], rax

; 419  :             ++chunks;

	mov	eax, DWORD PTR chunks$[rsp]
	inc	eax
	mov	DWORD PTR chunks$[rsp], eax

; 420  :             freeEntry( walk, hdl );

	mov	rdx, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR walk$[rsp]
	call	freeEntry

; 421  :             walk = next;

	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR walk$[rsp], rax

; 422  :         }

	jmp	SHORT $LN4@trmem_clos
$LN5@trmem_clos:
$LN7@trmem_clos:

; 423  :     }
; 424  :     hdl->free( hdl );

	mov	rcx, QWORD PTR hdl$[rsp]
	mov	rax, QWORD PTR hdl$[rsp]
	call	QWORD PTR [rax+32]

; 425  :     return( chunks );

	mov	eax, DWORD PTR chunks$[rsp]

; 426  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
_trmem_close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_TEXT	SEGMENT
hdl$ = 32
alloc$ = 64
free$ = 72
realloc$ = 80
expand$ = 88
prt_parm$ = 96
prt_line$ = 104
flags$ = 112
_trmem_open PROC

; 354  : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 355  :     _trmem_hdl  hdl;
; 356  : 
; 357  :     hdl = (_trmem_hdl) alloc( sizeof( struct _trmem_internal ) );

	mov	ecx, 88					; 00000058H
	call	QWORD PTR alloc$[rsp]
	mov	QWORD PTR hdl$[rsp], rax

; 358  :     if( hdl == NULL ) {

	cmp	QWORD PTR hdl$[rsp], 0
	jne	SHORT $LN2@trmem_open

; 359  :         return( NULL );

	xor	eax, eax
	jmp	$LN1@trmem_open
$LN2@trmem_open:

; 360  :     }
; 361  :     hdl->alloc          = alloc;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR alloc$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 362  :     hdl->free           = free;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR free$[rsp]
	mov	QWORD PTR [rax+32], rcx

; 363  :     hdl->realloc        = realloc;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR realloc$[rsp]
	mov	QWORD PTR [rax+40], rcx

; 364  :     hdl->expand         = expand;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR expand$[rsp]
	mov	QWORD PTR [rax+48], rcx

; 365  :     hdl->prt_parm       = prt_parm;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR prt_parm$[rsp]
	mov	QWORD PTR [rax+56], rcx

; 366  :     hdl->prt_line       = prt_line;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	rcx, QWORD PTR prt_line$[rsp]
	mov	QWORD PTR [rax+64], rcx

; 367  :     hdl->flags          = flags;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rax+72], ecx

; 368  :     hdl->alloc_list     = NULL;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	QWORD PTR [rax], 0

; 369  :     hdl->mem_used       = 0;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	DWORD PTR [rax+8], 0

; 370  :     hdl->max_mem        = 0;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	DWORD PTR [rax+12], 0

; 371  :     hdl->min_alloc      = 0;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	QWORD PTR [rax+80], 0

; 372  :     hdl->alloc_no       = 0;

	mov	rax, QWORD PTR hdl$[rsp]
	mov	DWORD PTR [rax+16], 0

; 373  :     return( hdl );

	mov	rax, QWORD PTR hdl$[rsp]
$LN1@trmem_open:

; 374  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_trmem_open ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Format$ = 96
printf	PROC						; COMDAT

; 950  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 957  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:printf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
	push	rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	rdi
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
