; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	SymTables:BYTE:060H
COMM	SegOverride:QWORD
COMM	xmmOver0:BYTE:020H
COMM	xmmOver1:BYTE:020H
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG12296 DB	'HandleStringInstructions: CMPS: CodeInfo->RegOverride=%X'
	DB	', opndx->override=%s', 0aH, 00H
	ORG $+2
$SG12363 DB	'check_size enter, optype1=%X, optype2=%X', 0aH, 00H
	ORG $+6
$SG12389 DB	'check_size, MOVZX/MOVSX: op2_size=%u, opndx.memtype=%Xh,'
	DB	' opndx.sym=%X', 0aH, 00H
	ORG $+1
$SG12393 DB	'BYTE', 00H
	ORG $+3
$SG12440 DB	'check_size: OP_A flag reset, new op2=%X', 0aH, 00H
	ORG $+3
$SG12474 DB	'DWORD', 00H
	ORG $+2
$SG12792 DB	'ptr', 00H
$SG12443 DB	'check_size: OP_A flag reset, new op2=%X', 0aH, 00H
	ORG $+3
$SG12502 DB	'DWORD', 00H
	ORG $+6
$SG12447 DB	'check_size: OP_A flag reset, new op1=%X', 0aH, 00H
	ORG $+7
$SG12450 DB	'check_size: OP_A flag reset, new op2=%X', 0aH, 00H
	ORG $+7
$SG12452 DB	'check_size default: op1_size1=%u, op2_size=%u', 0aH, 00H
	ORG $+1
$SG12466 DB	'WORD', 00H
	ORG $+3
$SG12478 DB	'BYTE', 00H
	ORG $+3
$SG12470 DB	'check_size: op1=%X op1_size=0, op2=%X, op2_size=%u CodeI'
	DB	'nfo->data[2]=%X', 0aH, 00H
	ORG $+3
$SG12495 DB	'BYTE', 00H
	ORG $+3
$SG12498 DB	'WORD', 00H
	ORG $+7
$SG12503 DB	'check_size exit [CodeInfo->mem_type=%Xh]', 0aH, 00H
	ORG $+6
$SG11523 DB	'SizeFromMemtype( MT_NEAR, Ofssize=%u )=%u', 0aH, 00H
	ORG $+5
$SG11525 DB	'SizeFromMemtype( MT_FAR, Ofssize=%u )=%u', 0aH, 00H
	ORG $+6
$SG11527 DB	'SizeFromMemtype( MT_PROC, Ofssize=%u, type=%s )=%u', 0aH
	DB	00H
	ORG $+4
$SG11529 DB	'SizeFromMemtype( MT_PTR, Ofssize=%u )=%u', 0aH, 00H
	ORG $+6
$SG11533 DB	'SizeFromMemtype( memtype=%Xh, Ofssize=%u )=%u', 0aH, 00H
	ORG $+1
$SG12581 DB	'ParseLine enter, Token_Count=%u, ofs=%Xh', 0aH, 00H
	ORG $+6
$SG12584 DB	'ParseLine T_COLON, code label=%s', 0aH, 00H
	ORG $+6
$SG12587 DB	'ParseLine, CreateLabel(%s) failed, exit', 0aH, 00H
	ORG $+7
$SG11576 DB	'OperandSize: unhandled operand type %Xh!!!', 0aH, 00H
	ORG $+4
$SG12601 DB	'ParseLine: T_DIRECTIVE >%s<', 0aH, 00H
	ORG $+3
$SG12625 DB	'ParseLine: T_STYPE >%s<', 0aH, 00H
	ORG $+7
$SG12627 DB	'ParseLine: T_ID >%s<', 0aH, 00H
	ORG $+2
$SG12631 DB	'ParseLine: unexpected colon', 0aH, 00H
	ORG $+3
$SG11608 DB	'NULL', 00H
	ORG $+3
$SG12633 DB	'ParseLine: unexpected token=%u, i=%u, string=%s', 0aH, 00H
	ORG $+3
$SG11609 DB	'NULL', 00H
	ORG $+7
$SG12634 DB	'ParseLine: %s', 0aH, 00H
	ORG $+1
$SG11610 DB	'check_assume(%s): calling SetFixupFrame(%s, FALSE)', 0aH
	DB	00H
$SG11689 DB	'NULL', 00H
	ORG $+7
$SG11617 DB	'check_assume: no segment register available to access la'
	DB	'bel %s', 0aH, 00H
$SG11618 DB	'check_assume: no segment register available to access se'
	DB	'g-label %s', 0aH, 00H
	ORG $+4
$SG12644 DB	'ParseLine: unexpected token %u after prefix, exit, error'
	DB	0aH, 00H
	ORG $+6
$SG12645 DB	'ParseLine: %s', 0aH, 00H
	ORG $+1
$SG12663 DB	'ParseLine(%s): calling EvalOperand, i=%u', 0aH, 00H
	ORG $+6
$SG12665 DB	'ParseLine(%s): EvalOperand() failed', 0aH, 00H
	ORG $+3
$SG11644 DB	'seg_override: sym=%s', 0aH, 00H
	ORG $+2
$SG12677 DB	'ParseLine(%s): unexpected operand kind=%d, error, exit', 0aH
	DB	00H
$SG11648 DB	'seg_override, direct addressing: prefix.adrsiz will be s'
	DB	'et, assume=%s CI->ofssize=%u', 0aH, 00H
	ORG $+2
$SG12679 DB	'ParseLine(%s): too many operands (%s) ', 0aH, 00H
$SG12705 DB	'ParseLine(%s,%u): avx invalid operand, op2.kind=%u', 0aH
	DB	00H
	ORG $+4
$SG12709 DB	'ParseLine(%s,%u): avx not enough operands (%u)', 0aH, 00H
$SG11707 DB	'set_rm_sib: error, Ofssize=%u, adrsize=%u, data=%X', 0aH
	DB	00H
	ORG $+4
$SG12712 DB	'ParseLine(%s,%u): avx VX_DST, op3.kind=CONST (value=%u),'
	DB	' numops=%u', 0aH, 00H
$SG12035 DB	'NULL', 00H
	ORG $+7
$SG11690 DB	'set_rm_sib(scale=%u, index=%d, base=%d, sym=%s) enter [C'
	DB	'I.adrsiz=%u]', 0aH, 00H
	ORG $+2
$SG12730 DB	'ParseLine(%s,%u): type ADDRESS', 0aH, 00H
$SG12733 DB	'ParseLine(%s,%u): type CONST, opndx.memtype=%Xh', 0aH, 00H
	ORG $+7
$SG12720 DB	'ParseLine(%s,%u): opnd2 is avx reg (%s), flags=%X ci.typ'
	DB	'e[0]=%X numops=%u', 0aH, 00H
	ORG $+5
$SG11701 DB	'set_rm_sib: direct addressing, CI.Ofssize=%u / adrsize=%'
	DB	'u / data=%X', 0aH, 00H
	ORG $+3
$SG12726 DB	'ParseLine(%s,%u): avx invalid opnd 2, flags=%X ci.type[0'
	DB	']=%X', 0aH, 00H
	ORG $+2
$SG11710 DB	'set_rm_sib, direct, CodeInfo->prefix.adrsiz=%u', 0aH, 00H
$SG12758 DB	'ParseLine(%s): ( %u - %u ) >%s<', 0aH, 00H
	ORG $+7
$SG12727 DB	'ParseLine(%s,%u): type/value/mem_type/ofssize=%Xh/%I64Xh'
	DB	'/%Xh/%d', 0aH, 00H
	ORG $+7
$SG11709 DB	'set_rm_sib: 64-bit, no fixup, data64=%I64X', 0aH, 00H
	ORG $+4
$SG12736 DB	'ParseLine(%s,%u): type REG', 0aH, 00H
	ORG $+4
$SG11721 DB	'set_rm_sib: base_reg is %u', 0aH, 00H
$SG12160 DB	'NULL', 00H
	ORG $+7
$SG11726 DB	'set_rm_sib, indirect with base, mod_field=%X, rm_field=%'
	DB	'X, rex=%X', 0aH, 00H
	ORG $+5
$SG12751 DB	'ParseLine(%s): CurrOpnd != j ( %u - %u ) >%s<', 0aH, 00H
	ORG $+1
$SG11762 DB	'segm_override: assume error, reg=%u', 0aH, 00H
	ORG $+3
$SG11743 DB	'set_rm_sib, indirect, base+index: mod_field=%X, rm_field'
	DB	'=%X, rex=%X', 0aH, 00H
	ORG $+3
$SG12772 DB	'ParseLine(%s): no third operand expected', 0aH, 00H
	ORG $+6
$SG12778 DB	'ParseLine(%s): check_size() failed, exit', 0aH, 00H
	ORG $+6
$SG12791 DB	'xmmword', 00H
$SG11785 DB	'idata_nofixup( CurrOpnd=%u ) enter [opnd kind=%u mem_typ'
	DB	'e=%Xh value=%I64X]', 0aH, 00H
	ORG $+4
$SG11788 DB	'idata_nofixup: error, hlvalue=%I64X', 0aH, 00H
	ORG $+3
$SG11798 DB	'idata_nofixup: invalid size %d for immediate operand', 0aH
	DB	00H
	ORG $+2
$SG11816 DB	'idata_nofixup exit, op_type=%X', 0aH, 00H
$SG11842 DB	'idata_fixup( CurrOpnd=%u ) enter [opndx.kind=%u mem_type'
	DB	'=%Xh, CodeInfo.mem_type=%Xh]', 0aH, 00H
	ORG $+2
$SG11906 DB	'idata_fixup, unexpected size %u', 0aH, 00H
	ORG $+7
$SG11907 DB	'parser.c', 00H
	ORG $+7
$SG11912 DB	'idata_fixup, mem_type=BYTE', 0aH, 00H
	ORG $+4
$SG11915 DB	'idata_fixup, FIX_HIBYTE', 0aH, 00H
	ORG $+7
$SG11916 DB	'idata_fixup, FIX_OFF8', 0aH, 00H
	ORG $+1
$SG12052 DB	'memory_operand, JMP/CALL: CodeInfo->memtype set to %Xh', 0aH
	DB	00H
$SG11933 DB	'idata_fixup exit [CodeInfo.mem_type=%Xh Ofssize=%u opsiz'
	DB	'=%u fixup.type=%u fixup.frame=%d]', 0aH, 00H
	ORG $+5
$SG11956 DB	'SetPtrMemtype: model with FAR data pointers', 0aH, 00H
	ORG $+3
$SG11958 DB	'SetPtrMemtype: size=%u, new memtype=0x%x', 0aH, 00H
	ORG $+6
$SG12036 DB	'memory_operand(opndx.value=%X / sym=%s / memtype=%Xh, wi'
	DB	'th_fixup=%u) enter, [CodeInfo->memtype=%Xh, Ofssize=%u, adrsi'
	DB	'z=%u]', 0aH, 00H
	ORG $+4
$SG12043 DB	'memory_operand: mbr %s has mem_type MT_TYPE, total_size='
	DB	'%u', 0aH, 00H
	ORG $+4
$SG12051 DB	'memory_operand, JMP/CALL: CodeInfo->memtype=empty, instr'
	DB	'uction operand must have size', 0aH, 00H
	ORG $+1
$SG12055 DB	'memory_operand: invalid operand, size=%u', 0aH, 00H
	ORG $+6
$SG12061 DB	'memory_operand: JMP/CALL, CodeInfo->far=%u', 0aH, 00H
	ORG $+4
$SG12074 DB	'memory_operand: unexpected mem_type=%X', 0aH, 00H
$SG12075 DB	'parser.c', 00H
	ORG $+7
$SG12095 DB	'memory_operand: error, base regno=%u, index regno=%u, op'
	DB	'nd.scale=%u', 0aH, 00H
	ORG $+3
$SG12123 DB	'memory_operand: direct addressing, fixup type=%u', 0aH, 00H
	ORG $+6
$SG12124 DB	'memory_operand: CodeInfo->Ofssize=%u/prefix.adrsize=%u, '
	DB	'Ofssize=%u', 0aH, 00H
$SG12161 DB	'NULL', 00H
	ORG $+7
$SG12137 DB	'memory_operand exit, ok, opndx.type/value=%Xh/%Xh, CodeI'
	DB	'nfo.memtype/rmbyte=%X/%X opndtype=%Xh fix=%Xh', 0aH, 00H
	ORG $+1
$SG12162 DB	'process_address: INDIRECT, sym=%s mbr=%s ci.adrsiz=%u', 0aH
	DB	00H
	ORG $+1
$SG12165 DB	'process_address: displacement doesn''t fit in 32 bits: %'
	DB	'I64X', 0aH, 00H
	ORG $+3
$SG12171 DB	'process_address: instr=%s', 0aH, 00H
	ORG $+5
$SG12177 DB	'process_address: symbol=NULL', 0aH, 00H
	ORG $+2
$SG12185 DB	'process_address: sym=SYM_UNDEFINED, name=%s, state=%X', 0aH
	DB	00H
	ORG $+1
$SG12196 DB	'process_address: sym->state=SEG/GROUP', 0aH, 00H
	ORG $+1
$SG12197 DB	'process_address direct, sym=%s sym.memtype=%X opndx.memt'
	DB	'ype=%X', 0aH, 00H
$SG12226 DB	'process_register enter (%s)', 0aH, 00H
	ORG $+3
$SG12234 DB	'process_register: assume error, reg=%u', 0aH, 00H
$SG12242 DB	'process_register: assume error, reg=%u', 0aH, 00H
$SG12246 DB	'process_register: assume error, reg=%u', 0aH, 00H
_DATA	ENDS
PUBLIC	SizeFromMemtype
PUBLIC	MemtypeFromSize
PUBLIC	SizeFromRegister
PUBLIC	GetLangType
PUBLIC	sym_add_table
PUBLIC	sym_remove_table
PUBLIC	sym_ext2int
PUBLIC	OperandSize
PUBLIC	set_frame
PUBLIC	set_frame2
PUBLIC	ParseLine
PUBLIC	ProcessFile
PUBLIC	segm_override
PUBLIC	idata_fixup
EXTRN	memcpy:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	SymFind:PROC
EXTRN	WritePreprocessedLine:PROC
EXTRN	PreprocessLine:PROC
EXTRN	GetResWName:PROC
EXTRN	codegen:PROC
EXTRN	EvalOperand:PROC
EXTRN	EmitConstError:PROC
EXTRN	CreateFixup:PROC
EXTRN	SetFixupFrame:PROC
EXTRN	CreateLabel:PROC
EXTRN	GetSymOfssize:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	GetAssume:PROC
EXTRN	GetOverrideAssume:PROC
EXTRN	RetInstr:PROC
EXTRN	write_prologue:PROC
EXTRN	InternalError:PROC
EXTRN	GetTextLine:PROC
EXTRN	LstWrite:PROC
EXTRN	LstWriteSrcLine:PROC
EXTRN	data_dir:PROC
EXTRN	StoreLine:PROC
EXTRN	omf_OutSelect:PROC
EXTRN	AddPublicData:PROC
EXTRN	atofloat:PROC
EXTRN	process_branch:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	InstrTable:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	optable_idx:BYTE
EXTRN	CurrStruct:QWORD
EXTRN	SegAssumeTable:BYTE
EXTRN	StdAssumeTable:BYTE
EXTRN	CurrProc:QWORD
EXTRN	StoreState:BYTE
EXTRN	UseSavedState:BYTE
EXTRN	directive_tab:BYTE
EXTRN	ProcStatus:DWORD
EXTRN	opnd_clstab:BYTE
EXTRN	vex_flags:BYTE
EXTRN	Frame_Type:BYTE
EXTRN	Frame_Datum:WORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
LastRegOverride DD 01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$SizeFromMemtype DD imagerel $LN22
	DD	imagerel $LN22+680
	DD	imagerel $unwind$SizeFromMemtype
$pdata$MemtypeFromSize DD imagerel $LN8
	DD	imagerel $LN8+158
	DD	imagerel $unwind$MemtypeFromSize
$pdata$SizeFromRegister DD imagerel $LN15
	DD	imagerel $LN15+251
	DD	imagerel $unwind$SizeFromRegister
$pdata$sym_ext2int DD imagerel $LN5
	DD	imagerel $LN5+165
	DD	imagerel $unwind$sym_ext2int
$pdata$OperandSize DD imagerel $LN30
	DD	imagerel $LN30+412
	DD	imagerel $unwind$OperandSize
$pdata$set_frame DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$set_frame
$pdata$set_frame2 DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$set_frame2
$pdata$ParseLine DD imagerel $LN228
	DD	imagerel $LN228+9040
	DD	imagerel $unwind$ParseLine
$pdata$ProcessFile DD imagerel $LN7
	DD	imagerel $LN7+353
	DD	imagerel $unwind$ProcessFile
$pdata$comp_mem16 DD imagerel comp_mem16
	DD	imagerel comp_mem16+140
	DD	imagerel $unwind$comp_mem16
$pdata$check_assume DD imagerel check_assume
	DD	imagerel check_assume+333
	DD	imagerel $unwind$check_assume
$pdata$seg_override DD imagerel seg_override
	DD	imagerel seg_override+730
	DD	imagerel $unwind$seg_override
$pdata$set_rm_sib DD imagerel set_rm_sib
	DD	imagerel set_rm_sib+2280
	DD	imagerel $unwind$set_rm_sib
$pdata$segm_override DD imagerel $LN11
	DD	imagerel $LN11+302
	DD	imagerel $unwind$segm_override
$pdata$idata_nofixup DD imagerel idata_nofixup
	DD	imagerel idata_nofixup+1050
	DD	imagerel $unwind$idata_nofixup
$pdata$idata_fixup DD imagerel $LN124
	DD	imagerel $LN124+3914
	DD	imagerel $unwind$idata_fixup
$pdata$SetPtrMemtype DD imagerel SetPtrMemtype
	DD	imagerel SetPtrMemtype+659
	DD	imagerel $unwind$SetPtrMemtype
$pdata$Set_Memtype DD imagerel Set_Memtype
	DD	imagerel Set_Memtype+976
	DD	imagerel $unwind$Set_Memtype
$pdata$memory_operand DD imagerel memory_operand
	DD	imagerel memory_operand+4208
	DD	imagerel $unwind$memory_operand
$pdata$process_address DD imagerel process_address
	DD	imagerel process_address+1379
	DD	imagerel $unwind$process_address
$pdata$process_const DD imagerel process_const
	DD	imagerel process_const+127
	DD	imagerel $unwind$process_const
$pdata$process_register DD imagerel process_register
	DD	imagerel process_register+1545
	DD	imagerel $unwind$process_register
$pdata$HandleStringInstructions DD imagerel HandleStringInstructions
	DD	imagerel HandleStringInstructions+1604
	DD	imagerel $unwind$HandleStringInstructions
$pdata$check_size DD imagerel check_size
	DD	imagerel check_size+5368
	DD	imagerel $unwind$check_size
$pdata$IsType DD imagerel IsType
	DD	imagerel IsType+57
	DD	imagerel $unwind$IsType
pdata	ENDS
xdata	SEGMENT
$unwind$SizeFromMemtype DD 011101H
	DD	0c211H
$unwind$MemtypeFromSize DD 010d01H
	DD	0220dH
$unwind$SizeFromRegister DD 010801H
	DD	02208H
$unwind$sym_ext2int DD 010901H
	DD	04209H
$unwind$OperandSize DD 010d01H
	DD	0620dH
$unwind$set_frame DD 010901H
	DD	06209H
$unwind$set_frame2 DD 010901H
	DD	06209H
$unwind$ParseLine DD 042019H
	DD	05f010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	02e0H
$unwind$ProcessFile DD 010901H
	DD	04209H
$unwind$comp_mem16 DD 010c01H
	DD	0620cH
$unwind$check_assume DD 011301H
	DD	08213H
$unwind$seg_override DD 011701H
	DD	0a217H
$unwind$set_rm_sib DD 011701H
	DD	0a217H
$unwind$segm_override DD 010e01H
	DD	0620eH
$unwind$idata_nofixup DD 011201H
	DD	0a212H
$unwind$idata_fixup DD 021501H
	DD	0130115H
$unwind$SetPtrMemtype DD 010e01H
	DD	0820eH
$unwind$Set_Memtype DD 010d01H
	DD	0220dH
$unwind$memory_operand DD 021a01H
	DD	017011aH
$unwind$process_address DD 011201H
	DD	08212H
$unwind$process_const DD 011201H
	DD	04212H
$unwind$process_register DD 011201H
	DD	08212H
$unwind$HandleStringInstructions DD 010e01H
	DD	0820eH
$unwind$check_size DD 021101H
	DD	0110111H
$unwind$IsType DD 010901H
	DD	06209H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
sym$ = 32
name$ = 64
IsType	PROC

; 2858 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2859 :     struct asym *sym;
; 2860 : 
; 2861 :     sym = SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 2862 :     if ( sym && (sym->state == SYM_TYPE ) )

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN2@IsType
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 7
	jne	SHORT $LN2@IsType

; 2863 :         return( sym );

	mov	rax, QWORD PTR sym$[rsp]
	jmp	SHORT $LN1@IsType
$LN2@IsType:

; 2864 :     return( NULL );

	xor	eax, eax
$LN1@IsType:

; 2865 : }

	add	rsp, 56					; 00000038H
	ret	0
IsType	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
op2_size$ = 48
tv137 = 52
op2$ = 56
op1_size$ = 60
op1$ = 64
rc$ = 68
tv260 = 72
tv700 = 76
tv139 = 80
tv152 = 84
tv272 = 88
tv285 = 92
op3_size$1 = 96
tv348 = 100
tv382 = 104
tv393 = 108
tv602 = 112
p$2 = 120
CodeInfo$ = 144
opndx$ = 152
check_size PROC

; 2338 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 2339 :     enum operand_type op1 = CodeInfo->opnd[OPND1].type;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	mov	DWORD PTR op1$[rsp], eax

; 2340 :     enum operand_type op2 = CodeInfo->opnd[OPND2].type;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	mov	DWORD PTR op2$[rsp], eax

; 2341 :     ret_code    rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 2342 :     int         op1_size;
; 2343 :     int         op2_size;
; 2344 :     //int         op_size = 0;
; 2345 :     DebugMsg1(("check_size enter, optype1=%" I32_SPEC "X, optype2=%" I32_SPEC "X\n", op1, op2 ));

	mov	r8d, DWORD PTR op2$[rsp]
	mov	edx, DWORD PTR op1$[rsp]
	lea	rcx, OFFSET FLAT:$SG12363
	call	DoDebugMsg1

; 2346 :     if (CodeInfo->token >= T_KADDB && CodeInfo->token <= T_KUNPCKDQ){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1687		; 00000697H
	jl	$LN12@check_size
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1713		; 000006b1H
	jg	$LN12@check_size

; 2347 :       //int op3_size;
; 2348 :       if ((CodeInfo->opnd[OPND1].type != OP_K) && (CodeInfo->opnd[OPND2].type != OP_K) &&

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 64		; 00000040H
	je	SHORT $LN13@check_size
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 64		; 00000040H
	je	SHORT $LN13@check_size
	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 64		; 00000040H
	je	SHORT $LN13@check_size

; 2349 :         (CodeInfo->opnd[OPND3].type != OP_K))
; 2350 :         return(EmitError(INVALID_INSTRUCTION_OPERANDS));

	mov	ecx, 49					; 00000031H
	call	EmitError
	jmp	$LN1@check_size
$LN13@check_size:

; 2351 :       CodeInfo->indextype = OP_K;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+132], 64			; 00000040H

; 2352 :       CodeInfo->basetype = OP_K;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+108], 64			; 00000040H

; 2353 : 
; 2354 :       op1_size = CodeInfo->pinstr->prefix;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+8]
	mov	DWORD PTR op1_size$[rsp], eax

; 2355 :       op2_size = CodeInfo->pinstr->prefix;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+8]
	mov	DWORD PTR op2_size$[rsp], eax

; 2356 :       goto def_check;

	jmp	$def_check$156
$LN12@check_size:

; 2357 :     }
; 2358 : 
; 2359 :     switch( CodeInfo->token ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv137[rsp], eax
	cmp	DWORD PTR tv137[rsp], 1025		; 00000401H
	jg	SHORT $LN150@check_size
	cmp	DWORD PTR tv137[rsp], 1024		; 00000400H
	jge	$LN59@check_size
	mov	eax, DWORD PTR tv137[rsp]
	sub	eax, 513				; 00000201H
	mov	DWORD PTR tv137[rsp], eax
	cmp	DWORD PTR tv137[rsp], 131		; 00000083H
	ja	$LN93@check_size
	movsxd	rax, DWORD PTR tv137[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN154@check_size[rcx+rax]
	mov	eax, DWORD PTR $LN155@check_size[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN150@check_size:
	cmp	DWORD PTR tv137[rsp], 1334		; 00000536H
	jg	$LN151@check_size
	cmp	DWORD PTR tv137[rsp], 1334		; 00000536H
	je	$LN65@check_size
	cmp	DWORD PTR tv137[rsp], 1267		; 000004f3H
	jg	SHORT $LN152@check_size
	cmp	DWORD PTR tv137[rsp], 1267		; 000004f3H
	je	$LN67@check_size
	cmp	DWORD PTR tv137[rsp], 1032		; 00000408H
	jl	$LN93@check_size
	cmp	DWORD PTR tv137[rsp], 1033		; 00000409H
	jle	$LN59@check_size
	cmp	DWORD PTR tv137[rsp], 1046		; 00000416H
	je	$LN72@check_size
	cmp	DWORD PTR tv137[rsp], 1210		; 000004baH
	je	$LN48@check_size
	jmp	$LN93@check_size
$LN152@check_size:
	cmp	DWORD PTR tv137[rsp], 1294		; 0000050eH
	jl	$LN93@check_size
	cmp	DWORD PTR tv137[rsp], 1295		; 0000050fH
	jle	$LN59@check_size
	cmp	DWORD PTR tv137[rsp], 1296		; 00000510H
	jle	$LN93@check_size
	cmp	DWORD PTR tv137[rsp], 1298		; 00000512H
	jle	$LN59@check_size
	cmp	DWORD PTR tv137[rsp], 1316		; 00000524H
	je	$LN59@check_size
	jmp	$LN93@check_size
$LN151@check_size:
	cmp	DWORD PTR tv137[rsp], 1603		; 00000643H
	jg	SHORT $LN153@check_size
	cmp	DWORD PTR tv137[rsp], 1603		; 00000643H
	je	$LN60@check_size
	cmp	DWORD PTR tv137[rsp], 1339		; 0000053bH
	je	$LN61@check_size
	cmp	DWORD PTR tv137[rsp], 1341		; 0000053dH
	jle	$LN93@check_size
	cmp	DWORD PTR tv137[rsp], 1343		; 0000053fH
	jle	$LN61@check_size
	cmp	DWORD PTR tv137[rsp], 1344		; 00000540H
	je	$LN63@check_size
	jmp	$LN93@check_size
$LN153@check_size:
	cmp	DWORD PTR tv137[rsp], 1631		; 0000065fH
	je	$LN59@check_size
	cmp	DWORD PTR tv137[rsp], 1908		; 00000774H
	jle	$LN93@check_size
	cmp	DWORD PTR tv137[rsp], 1910		; 00000776H
	jle	$LN59@check_size
	cmp	DWORD PTR tv137[rsp], 1913		; 00000779H
	jle	$LN93@check_size
	cmp	DWORD PTR tv137[rsp], 1915		; 0000077bH
	jle	$LN59@check_size
	jmp	$LN93@check_size
$LN14@check_size:

; 2360 :     case T_IN:
; 2361 :         if( op2 == OP_DX ) {

	cmp	DWORD PTR op2$[rsp], 2050		; 00000802H
	jne	SHORT $LN15@check_size

; 2362 :             /* wide and size is NOT determined by DX, but
; 2363 :              * by the first operand, AL|AX|EAX
; 2364 :              */
; 2365 :             switch( op1 ) {

	mov	eax, DWORD PTR op1$[rsp]
	mov	DWORD PTR tv139[rsp], eax
	cmp	DWORD PTR tv139[rsp], 513		; 00000201H
	je	SHORT $LN17@check_size
	cmp	DWORD PTR tv139[rsp], 516		; 00000204H
	je	SHORT $LN18@check_size
	jmp	SHORT $LN4@check_size

; 2366 :             case OP_AX:
; 2367 :                 break;

	jmp	SHORT $LN4@check_size
$LN17@check_size:

; 2368 :             case OP_AL:
; 2369 :                 CodeInfo->iswide = 0;         /* clear w-bit */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al
$LN18@check_size:

; 2370 :             case OP_EAX:
; 2371 :                 if( CodeInfo->Ofssize ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN19@check_size

; 2372 :                     CodeInfo->prefix.opsiz = FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN19@check_size:
$LN4@check_size:
$LN15@check_size:

; 2373 :                 }
; 2374 :                 break;
; 2375 :             }
; 2376 :         }
; 2377 :         break;

	jmp	$LN2@check_size
$LN20@check_size:

; 2378 :     case T_OUT:
; 2379 :         if( op1 == OP_DX ) {

	cmp	DWORD PTR op1$[rsp], 2050		; 00000802H
	jne	SHORT $LN21@check_size

; 2380 :             switch( op2 ) {

	mov	eax, DWORD PTR op2$[rsp]
	mov	DWORD PTR tv152[rsp], eax
	cmp	DWORD PTR tv152[rsp], 513		; 00000201H
	je	SHORT $LN23@check_size
	cmp	DWORD PTR tv152[rsp], 516		; 00000204H
	je	SHORT $LN24@check_size
	jmp	SHORT $LN6@check_size

; 2381 :             case OP_AX:
; 2382 :                 break;

	jmp	SHORT $LN6@check_size
$LN23@check_size:

; 2383 :             case OP_AL:
; 2384 :                 CodeInfo->iswide = 0;         /* clear w-bit */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al
$LN24@check_size:

; 2385 :             case OP_EAX:
; 2386 :                 if( CodeInfo->Ofssize ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN25@check_size

; 2387 :                     CodeInfo->prefix.opsiz = FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN25@check_size:
$LN6@check_size:
$LN21@check_size:

; 2388 :                 }
; 2389 :             }
; 2390 :         }
; 2391 :         break;

	jmp	$LN2@check_size
$LN26@check_size:

; 2392 :     case T_LEA:
; 2393 : #if 0
; 2394 :         /* first op must be 16/32 register, but this condition is checked
; 2395 :          in CodeGen. operands 1 and 2 can be mixed:
; 2396 :          lea cx,[bp]
; 2397 :          lea cx,[ebp]
; 2398 :          lea ecx,[bp]
; 2399 :          lea ecx,[ebp]
; 2400 :          are all valid. However, Masm sometimes complains
; 2401 :          "cannot use 16-bit register with a 32-bit address"
; 2402 :          */
; 2403 :         switch( OperandSize( op1, CodeInfo ) ) {
; 2404 :         case 2:
; 2405 :         case 4:
; 2406 :             break;
; 2407 :         default:
; 2408 :             EmitErr( OPERANDS_MUST_BE_THE_SAME_SIZE, OperandSize( op1, CodeInfo ), ModuleInfo.Ofssize ? 4 : 2);
; 2409 :             rc = ERROR;
; 2410 :         }
; 2411 : #endif
; 2412 :         break;

	jmp	$LN2@check_size
$LN27@check_size:

; 2413 :     case T_RCL:
; 2414 :     case T_RCR:
; 2415 :     case T_ROL:
; 2416 :     case T_ROR:
; 2417 :     case T_SAL:
; 2418 :     case T_SAR:
; 2419 :     case T_SHL:
; 2420 :     case T_SHR:
; 2421 :         /* v2.11: added */
; 2422 :         if ( CodeInfo->opnd[OPND1].type == OP_M && CodeInfo->undef_sym == FALSE &&

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], -1887436800	; ffffffff8f800000H
	jne	SHORT $LN28@check_size
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN28@check_size
	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rcx+rax+80], 0
	je	SHORT $LN29@check_size
	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rcx+rax+80]
	cmp	DWORD PTR [rax+40], 0
	je	SHORT $LN28@check_size
$LN29@check_size:

; 2423 :             ( opndx[OPND1].sym == NULL || opndx[OPND1].sym->state != SYM_UNDEFINED ) ) {
; 2424 :             EmitErr( INSTRUCTION_OPERAND_MUST_HAVE_SIZE );

	mov	ecx, 182				; 000000b6H
	call	EmitErr

; 2425 :             rc = ERROR;

	mov	DWORD PTR rc$[rsp], -1

; 2426 :             break;

	jmp	$LN2@check_size
$LN28@check_size:

; 2427 :         }
; 2428 :         //if ( CodeInfo->opnd[OPND1].type == OP_M && Parse_Pass == PASS_2 )
; 2429 :         //    EmitWarn( 2, SIZE_NOT_SPECIFIED_ASSUMING, "BYTE" );
; 2430 : 
; 2431 :         /* v2.0: if second argument is a forward reference,
; 2432 :          * change type to "immediate 1"
; 2433 :          */
; 2434 :         if ( opndx[OPND2].kind == EXPR_ADDR &&
; 2435 :             Parse_Pass == PASS_1 &&
; 2436 :             opndx[OPND2].indirect == FALSE &&
; 2437 :             opndx[OPND2].sym &&

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rcx+rax+60], 1
	jne	$LN30@check_size
	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN30@check_size
	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rcx+rax+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN30@check_size
	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rcx+rax+80], 0
	je	SHORT $LN30@check_size
	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rcx+rax+80]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN30@check_size

; 2438 :             opndx[OPND2].sym->state == SYM_UNDEFINED ) {
; 2439 :             CodeInfo->opnd[OPND2].type = OP_I8;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 131072		; 00020000H

; 2440 :             CodeInfo->opnd[OPND2].data32l = 1;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+40], 1
$LN30@check_size:

; 2441 :         }
; 2442 :         /* v2.06: added (because if first operand is memory, wide bit
; 2443 :          * isn't set!)
; 2444 :          */
; 2445 :         if ( OperandSize( op1, CodeInfo ) > 1 )

	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR op1$[rsp]
	call	OperandSize
	cmp	eax, 1
	jle	SHORT $LN31@check_size

; 2446 :             CodeInfo->iswide = 1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al
$LN31@check_size:

; 2447 :         /* v2.06: makes the OP_CL_ONLY case in codegen.c obsolete */
; 2448 :         if ( op2 == OP_CL ) {

	cmp	DWORD PTR op2$[rsp], 1025		; 00000401H
	jne	SHORT $LN32@check_size

; 2449 :             /* CL is encoded in bit 345 of rm_byte, but we don't need it
; 2450 :              * so clear it here */
; 2451 :             CodeInfo->rm_byte &= NOT_BIT_345;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	and	eax, 199				; 000000c7H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+104], al
$LN32@check_size:

; 2452 :         }
; 2453 :         break;

	jmp	$LN2@check_size
$LN33@check_size:

; 2454 :     case T_LDS:
; 2455 :     case T_LES:
; 2456 :     case T_LFS:
; 2457 :     case T_LGS:
; 2458 :     case T_LSS:
; 2459 :         op1_size = OperandSize( op1, CodeInfo ) + 2; /* add 2 for the impl. segment register */

	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR op1$[rsp]
	call	OperandSize
	add	eax, 2
	mov	DWORD PTR op1_size$[rsp], eax

; 2460 :         op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR op2$[rsp]
	call	OperandSize
	mov	DWORD PTR op2_size$[rsp], eax

; 2461 :         if ( op2_size != 0 && op1_size != op2_size ) {

	cmp	DWORD PTR op2_size$[rsp], 0
	je	SHORT $LN34@check_size
	mov	eax, DWORD PTR op2_size$[rsp]
	cmp	DWORD PTR op1_size$[rsp], eax
	je	SHORT $LN34@check_size

; 2462 :             return( EmitError( INVALID_OPERAND_SIZE ) );

	mov	ecx, 71					; 00000047H
	call	EmitError
	jmp	$LN1@check_size
$LN34@check_size:

; 2463 :         }
; 2464 :         break;

	jmp	$LN2@check_size
$LN35@check_size:

; 2465 :     case T_ENTER:
; 2466 : #if 0 /* v2.11: operand sizes are checked in codegen */
; 2467 :         /* ENTER has to be OP_I16, OP_I8_U */
; 2468 :         if( op1 == OP_I32 ) {
; 2469 :             /* parse_phase_1 will treat 16-bit data as OP_I32 if CPU is 386 */
; 2470 :             if( CodeInfo->opnd[OPND1].data32l > (int_32)USHRT_MAX ) {
; 2471 :                 /* if op1 is really 32-bit data, then error */
; 2472 :                 EmitError( INVALID_OPERAND_SIZE );
; 2473 :                 rc = ERROR;
; 2474 :             }
; 2475 :         }
; 2476 :         /* type cast op1 to OP_I16 */
; 2477 :         CodeInfo->opnd[OPND1].type = OP_I16;
; 2478 :         /* op2 have to be 8-bit data */
; 2479 :         if( op2 >= OP_I16 ) {
; 2480 :             if( CodeInfo->opnd[OPND2].data32l > UCHAR_MAX ) {
; 2481 :                 EmitError( INVALID_OPERAND_SIZE );
; 2482 :                 rc = ERROR;
; 2483 :             }
; 2484 :             CodeInfo->opnd[OPND2].type = OP_I8;
; 2485 :         }
; 2486 : #endif
; 2487 :         break;

	jmp	$LN2@check_size
$LN36@check_size:

; 2488 :     case T_MOVSX:
; 2489 :     case T_MOVZX:
; 2490 :         CodeInfo->iswide = 0;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 2491 :         op1_size = OperandSize( op1, CodeInfo );

	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR op1$[rsp]
	call	OperandSize
	mov	DWORD PTR op1_size$[rsp], eax

; 2492 :         op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR op2$[rsp]
	call	OperandSize
	mov	DWORD PTR op2_size$[rsp], eax

; 2493 :         DebugMsg1(("check_size, MOVZX/MOVSX: op2_size=%u, opndx.memtype=%Xh, opndx.sym=%X\n", op2_size, opndx[OPND2].mem_type, opndx[OPND2].sym ));

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	ecx, 104				; 00000068H
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR opndx$[rsp]
	mov	r9, QWORD PTR [rdx+rax+80]
	mov	rax, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR [rax+rcx+64]
	mov	edx, DWORD PTR op2_size$[rsp]
	lea	rcx, OFFSET FLAT:$SG12389
	call	DoDebugMsg1

; 2494 :         if ( op2_size == 0 && Parse_Pass == PASS_2 )

	cmp	DWORD PTR op2_size$[rsp], 0
	jne	SHORT $LN37@check_size
	cmp	DWORD PTR Parse_Pass, 1
	jne	SHORT $LN37@check_size

; 2495 :             if ( op1_size == 2 ) {

	cmp	DWORD PTR op1_size$[rsp], 2
	jne	SHORT $LN38@check_size

; 2496 :                 EmitWarn( 2, SIZE_NOT_SPECIFIED_ASSUMING, "BYTE" );

	lea	r8, OFFSET FLAT:$SG12393
	mov	edx, 73					; 00000049H
	mov	ecx, 2
	call	EmitWarn

; 2497 :             } else

	jmp	SHORT $LN39@check_size
$LN38@check_size:

; 2498 :                 EmitErr( INSTRUCTION_OPERAND_MUST_HAVE_SIZE );

	mov	ecx, 182				; 000000b6H
	call	EmitErr
$LN39@check_size:
$LN37@check_size:

; 2499 :         switch( op1_size ) {

	mov	eax, DWORD PTR op1_size$[rsp]
	mov	DWORD PTR tv260[rsp], eax
	cmp	DWORD PTR tv260[rsp], 2
	je	$LN45@check_size
	cmp	DWORD PTR tv260[rsp], 4
	je	SHORT $LN40@check_size
	cmp	DWORD PTR tv260[rsp], 8
	je	SHORT $LN40@check_size
	jmp	$LN47@check_size
$LN40@check_size:

; 2500 : #if AMD64_SUPPORT
; 2501 :         case 8:
; 2502 :             //if ( CodeInfo->Ofssize == USE64 )
; 2503 :             //    break;
; 2504 : #endif
; 2505 :         case 4:
; 2506 :             if (op2_size < 2)

	cmp	DWORD PTR op2_size$[rsp], 2
	jge	SHORT $LN41@check_size

; 2507 :                 ;

	jmp	SHORT $LN42@check_size
$LN41@check_size:

; 2508 :             else if (op2_size == 2)

	cmp	DWORD PTR op2_size$[rsp], 2
	jne	SHORT $LN43@check_size

; 2509 :                 CodeInfo->iswide = 1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al
	jmp	SHORT $LN44@check_size
$LN43@check_size:

; 2510 :             else {
; 2511 :                 EmitError( OP2_TOO_BIG );

	mov	ecx, 59					; 0000003bH
	call	EmitError

; 2512 :                 rc = ERROR;

	mov	DWORD PTR rc$[rsp], -1
$LN44@check_size:
$LN42@check_size:

; 2513 :             }
; 2514 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? FALSE : TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN138@check_size
	mov	DWORD PTR tv272[rsp], 0
	jmp	SHORT $LN139@check_size
$LN138@check_size:
	mov	DWORD PTR tv272[rsp], 1
$LN139@check_size:
	movzx	eax, BYTE PTR tv272[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 2515 :             break;

	jmp	SHORT $LN8@check_size
$LN45@check_size:

; 2516 :         case 2:
; 2517 :             if( op2_size >= 2 ) {

	cmp	DWORD PTR op2_size$[rsp], 2
	jl	SHORT $LN46@check_size

; 2518 :                 EmitError( OP2_TOO_BIG );

	mov	ecx, 59					; 0000003bH
	call	EmitError

; 2519 :                 rc = ERROR;

	mov	DWORD PTR rc$[rsp], -1
$LN46@check_size:

; 2520 :             }
; 2521 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? TRUE : FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN140@check_size
	mov	DWORD PTR tv285[rsp], 1
	jmp	SHORT $LN141@check_size
$LN140@check_size:
	mov	DWORD PTR tv285[rsp], 0
$LN141@check_size:
	movzx	eax, BYTE PTR tv285[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 2522 :             break;

	jmp	SHORT $LN8@check_size
$LN47@check_size:

; 2523 :         default:
; 2524 :             /* op1 must be r16/r32/r64 */
; 2525 :             EmitError( OP1_TOO_SMALL );

	mov	ecx, 60					; 0000003cH
	call	EmitError

; 2526 :             rc = ERROR;

	mov	DWORD PTR rc$[rsp], -1
$LN8@check_size:

; 2527 :         }
; 2528 :         break;

	jmp	$LN2@check_size
$LN48@check_size:

; 2529 : #if AMD64_SUPPORT
; 2530 :     case T_MOVSXD:
; 2531 :         break;

	jmp	$LN2@check_size
$LN49@check_size:

; 2532 : #endif
; 2533 :     case T_ARPL: /* v2.06: new, avoids the OP_R16 hack in codegen.c */
; 2534 :         CodeInfo->prefix.opsiz = 0;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 2535 :         goto def_check;

	jmp	$def_check$156

; 2536 :         break;

	jmp	$LN2@check_size
$LN50@check_size:

; 2537 : #if AMD64_SUPPORT
; 2538 :     case T_LAR: /* v2.04: added */
; 2539 :     case T_LSL: /* 19-sep-93 */
; 2540 : #if 1 /* v2.04: changed */
; 2541 :         if ( ModuleInfo.Ofssize != USE64 || ( ( op2 & OP_M ) == 0 ) )

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	SHORT $LN52@check_size
	mov	eax, DWORD PTR op2$[rsp]
	and	eax, -1887436800			; ffffffff8f800000H
	test	eax, eax
	jne	SHORT $LN51@check_size
$LN52@check_size:

; 2542 :             goto def_check;

	jmp	$def_check$156
$LN51@check_size:

; 2543 :         /* in 64-bit, if second argument is memory operand,
; 2544 :          * ensure it has size WORD ( or 0 if a forward ref )
; 2545 :          */
; 2546 :         op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR op2$[rsp]
	call	OperandSize
	mov	DWORD PTR op2_size$[rsp], eax

; 2547 :         if ( op2_size != 2 && op2_size != 0 ) {

	cmp	DWORD PTR op2_size$[rsp], 2
	je	SHORT $LN53@check_size
	cmp	DWORD PTR op2_size$[rsp], 0
	je	SHORT $LN53@check_size

; 2548 :             return( EmitError( INVALID_OPERAND_SIZE ) );

	mov	ecx, 71					; 00000047H
	call	EmitError
	jmp	$LN1@check_size
$LN53@check_size:

; 2549 :         }
; 2550 :         /* the opsize prefix depends on the FIRST operand only! */
; 2551 :         op1_size = OperandSize( op1, CodeInfo );

	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR op1$[rsp]
	call	OperandSize
	mov	DWORD PTR op1_size$[rsp], eax

; 2552 :         if ( op1_size != 2 )

	cmp	DWORD PTR op1_size$[rsp], 2
	je	SHORT $LN54@check_size

; 2553 :             CodeInfo->prefix.opsiz = FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN54@check_size:

; 2554 : #else
; 2555 :         op1_size = OperandSize( op1, CodeInfo );
; 2556 :         switch( op1_size ) {
; 2557 :         case 2:
; 2558 :             if( CodeInfo->Ofssize )
; 2559 :                 CodeInfo->prefix.opsiz = TRUE;
; 2560 :             break;
; 2561 :         case 4:
; 2562 :             if( CodeInfo->Ofssize )
; 2563 :                 CodeInfo->prefix.opsiz = FALSE;
; 2564 :             break;
; 2565 :         default:
; 2566 :             return( EmitError( INVALID_OPERAND_SIZE ) );
; 2567 :         }
; 2568 :         op2_size = OperandSize( op2, CodeInfo );
; 2569 :         switch( op2_size ) {
; 2570 :         case 2:
; 2571 :         case 4:
; 2572 :             break;
; 2573 :         default:
; 2574 :             EmitError( INVALID_OPERAND_SIZE );
; 2575 :             rc = ERROR;
; 2576 :             break;
; 2577 :         }
; 2578 : #endif
; 2579 :         break;

	jmp	$LN2@check_size
$LN55@check_size:

; 2580 : #endif
; 2581 :     case T_IMUL: /* v2.06: check for 3rd operand must be done here */
; 2582 :         if ( CodeInfo->opnd[OPND3].type != OP_NONE ) {

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 0
	je	$LN56@check_size

; 2583 :             int op3_size;
; 2584 :             op1_size = OperandSize( op1, CodeInfo );

	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR op1$[rsp]
	call	OperandSize
	mov	DWORD PTR op1_size$[rsp], eax

; 2585 :             op3_size = OperandSize( CodeInfo->opnd[OPND3].type, CodeInfo );

	mov	eax, 24
	imul	rax, rax, 2
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+32]
	call	OperandSize
	mov	DWORD PTR op3_size$1[rsp], eax

; 2586 :             /* the only case which must be checked here
; 2587 :              * is a WORD register as op1 and a DWORD immediate as op3 */
; 2588 :             if ( op1_size == 2 && op3_size > 2 ) {

	cmp	DWORD PTR op1_size$[rsp], 2
	jne	SHORT $LN57@check_size
	cmp	DWORD PTR op3_size$1[rsp], 2
	jle	SHORT $LN57@check_size

; 2589 :                 EmitErr( OPERANDS_MUST_BE_THE_SAME_SIZE, op1_size, op3_size );

	mov	r8d, DWORD PTR op3_size$1[rsp]
	mov	edx, DWORD PTR op1_size$[rsp]
	mov	ecx, 48					; 00000030H
	call	EmitErr

; 2590 :                 rc = ERROR;

	mov	DWORD PTR rc$[rsp], -1

; 2591 :                 break;

	jmp	$LN2@check_size
$LN57@check_size:

; 2592 :             }
; 2593 :             if ( CodeInfo->opnd[OPND3].type & ( OP_I16 | OP_I32 ) )

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 786432				; 000c0000H
	test	eax, eax
	je	SHORT $LN58@check_size

; 2594 :                 CodeInfo->opnd[OPND3].type = ( op1_size == 2 ? OP_I16 : OP_I32 );

	cmp	DWORD PTR op1_size$[rsp], 2
	jne	SHORT $LN142@check_size
	mov	DWORD PTR tv348[rsp], 262144		; 00040000H
	jmp	SHORT $LN143@check_size
$LN142@check_size:
	mov	DWORD PTR tv348[rsp], 524288		; 00080000H
$LN143@check_size:
	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR tv348[rsp]
	mov	DWORD PTR [rcx+rax+32], edx
$LN58@check_size:
$LN56@check_size:

; 2595 :         }
; 2596 :         goto def_check;

	jmp	$def_check$156

; 2597 :         break;

	jmp	$LN2@check_size
$LN59@check_size:

; 2598 :     case T_CVTSD2SI:
; 2599 :     case T_CVTTSD2SI:
; 2600 :     case T_CVTSS2SI:
; 2601 :     case T_CVTTSS2SI:
; 2602 :     //case T_MOVNTI: /* v2.05: removed */
; 2603 : #if AVXSUPP
; 2604 :     case T_VBROADCASTSD:
; 2605 :     case T_VBROADCASTF128:
; 2606 :     case T_VEXTRACTF128:
; 2607 :     case T_VINSERTF128:
; 2608 :     case T_VCVTSD2SI:
; 2609 :     case T_VCVTTSD2SI:
; 2610 :     case T_VCVTSS2SI:
; 2611 :     case T_VCVTTSS2SI:
; 2612 : #endif
; 2613 : #if VMXSUPP /* v2.09: added */
; 2614 :     case T_INVEPT:
; 2615 :     case T_INVVPID:
; 2616 : #endif
; 2617 : #if SVMSUPP /* v2.09: added */
; 2618 :     case T_INVLPGA:
; 2619 : #endif
; 2620 :         break;

	jmp	$LN2@check_size
$LN60@check_size:

; 2621 : #if AVXSUPP
; 2622 :     case T_VCVTSD2USI:
; 2623 :           CodeInfo->evex_flag = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+136], 1

; 2624 :           break;

	jmp	$LN2@check_size
$LN61@check_size:

; 2625 :     case T_VCVTPD2DQ:
; 2626 :     case T_VCVTTPD2DQ:
; 2627 :     case T_VCVTPD2PS:
; 2628 :         if ( op2 == OP_M && opndx[OPND2].indirect ) {

	cmp	DWORD PTR op2$[rsp], -1887436800	; ffffffff8f800000H
	jne	SHORT $LN62@check_size
	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rcx+rax+72]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN62@check_size

; 2629 :             return( EmitError( INSTRUCTION_OPERAND_MUST_HAVE_SIZE ) );

	mov	ecx, 182				; 000000b6H
	call	EmitError
	jmp	$LN1@check_size
$LN62@check_size:

; 2630 :         }
; 2631 :         break;

	jmp	$LN2@check_size
$LN63@check_size:

; 2632 :     case T_VMOVDDUP:
; 2633 :         if ( !( op1 & OP_YMM ) )

	mov	eax, DWORD PTR op1$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN64@check_size

; 2634 :             break;

	jmp	$LN2@check_size
$LN64@check_size:
$LN65@check_size:

; 2635 :         /* fall through */
; 2636 :     case T_VPERM2F128: /* has just one memory variant, and VX_L isnt set */
; 2637 :         if ( op2 == OP_M )

	cmp	DWORD PTR op2$[rsp], -1887436800	; ffffffff8f800000H
	jne	SHORT $LN66@check_size

; 2638 :             CodeInfo->opnd[OPND2].type |= OP_M256;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	bts	eax, 28
	mov	ecx, 24
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rdx+rcx+32], eax
$LN66@check_size:

; 2639 :         break;

	jmp	$LN2@check_size
$LN67@check_size:

; 2640 : #endif
; 2641 : #if SSE4SUPP
; 2642 :     case T_CRC32:
; 2643 :         /* v2.02: for CRC32, the second operand determines whether an
; 2644 :          * OPSIZE prefix byte is to be written.
; 2645 :          */
; 2646 :         op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR op2$[rsp]
	call	OperandSize
	mov	DWORD PTR op2_size$[rsp], eax

; 2647 :         if ( op2_size < 2)

	cmp	DWORD PTR op2_size$[rsp], 2
	jge	SHORT $LN68@check_size

; 2648 :             CodeInfo->prefix.opsiz = FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
	jmp	$LN69@check_size
$LN68@check_size:

; 2649 :         else if ( op2_size == 2 )

	cmp	DWORD PTR op2_size$[rsp], 2
	jne	SHORT $LN70@check_size

; 2650 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? TRUE : FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN144@check_size
	mov	DWORD PTR tv382[rsp], 1
	jmp	SHORT $LN145@check_size
$LN144@check_size:
	mov	DWORD PTR tv382[rsp], 0
$LN145@check_size:
	movzx	eax, BYTE PTR tv382[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
	jmp	SHORT $LN71@check_size
$LN70@check_size:

; 2651 :         else
; 2652 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? FALSE : TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN146@check_size
	mov	DWORD PTR tv393[rsp], 0
	jmp	SHORT $LN147@check_size
$LN146@check_size:
	mov	DWORD PTR tv393[rsp], 1
$LN147@check_size:
	movzx	eax, BYTE PTR tv393[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN71@check_size:
$LN69@check_size:

; 2653 :         break;

	jmp	$LN2@check_size
$LN72@check_size:

; 2654 : #endif
; 2655 :     case T_MOVD:
; 2656 : #if 0
; 2657 :         op1_size = OperandSize( op1, CodeInfo );
; 2658 :         op2_size = OperandSize( op2, CodeInfo );
; 2659 :         if( ( op1_size != 0 ) && ( op1_size != 4 )
; 2660 :             || ( op2_size != 0 ) && ( op2_size != 4 ) ) {
; 2661 :             EmitErr( OPERANDS_MUST_BE_THE_SAME_SIZE, op1_size, op2_size );
; 2662 :             rc = ERROR;
; 2663 :         }
; 2664 : #endif
; 2665 :         break;

	jmp	$LN2@check_size
$LN73@check_size:

; 2666 :     case T_MOV:
; 2667 :         if( op1 & OP_SR ) { /* segment register as op1? */

	mov	eax, DWORD PTR op1$[rsp]
	and	eax, 24576				; 00006000H
	test	eax, eax
	je	SHORT $LN74@check_size

; 2668 :             op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR op2$[rsp]
	call	OperandSize
	mov	DWORD PTR op2_size$[rsp], eax

; 2669 :             if( ( op2_size == 2 ) || ( op2_size == 4 )
; 2670 : #if AMD64_SUPPORT
; 2671 :                || ( op2_size == 8 && ModuleInfo.Ofssize == USE64 )

	cmp	DWORD PTR op2_size$[rsp], 2
	je	SHORT $LN77@check_size
	cmp	DWORD PTR op2_size$[rsp], 4
	je	SHORT $LN77@check_size
	cmp	DWORD PTR op2_size$[rsp], 8
	jne	SHORT $LN76@check_size
	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	SHORT $LN76@check_size
$LN77@check_size:

; 2672 : #endif
; 2673 :               ) {
; 2674 :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@check_size
$LN76@check_size:

; 2675 :             }

	jmp	$LN75@check_size
$LN74@check_size:

; 2676 :         } else if( op2 & OP_SR ) {

	mov	eax, DWORD PTR op2$[rsp]
	and	eax, 24576				; 00006000H
	test	eax, eax
	je	SHORT $LN78@check_size

; 2677 :             op1_size = OperandSize( op1, CodeInfo );

	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR op1$[rsp]
	call	OperandSize
	mov	DWORD PTR op1_size$[rsp], eax

; 2678 :             if( ( op1_size == 2 ) || ( op1_size == 4 )
; 2679 : #if AMD64_SUPPORT
; 2680 :                || ( op1_size == 8 && ModuleInfo.Ofssize == USE64 )

	cmp	DWORD PTR op1_size$[rsp], 2
	je	SHORT $LN81@check_size
	cmp	DWORD PTR op1_size$[rsp], 4
	je	SHORT $LN81@check_size
	cmp	DWORD PTR op1_size$[rsp], 8
	jne	SHORT $LN80@check_size
	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	SHORT $LN80@check_size
$LN81@check_size:

; 2681 : #endif
; 2682 :               ) {
; 2683 :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@check_size
$LN80@check_size:

; 2684 :             }

	jmp	$LN79@check_size
$LN78@check_size:

; 2685 :         } else if( ( op1 & OP_M ) && ( op2 & OP_A ) ) { /* 1. operand memory reference, 2. AL|AX|EAX|RAX? */

	mov	eax, DWORD PTR op1$[rsp]
	and	eax, -1887436800			; ffffffff8f800000H
	test	eax, eax
	je	$LN82@check_size
	mov	eax, DWORD PTR op2$[rsp]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	$LN82@check_size

; 2686 : 
; 2687 :             if ( CodeInfo->isdirect == FALSE ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN84@check_size

; 2688 :                 /* address mode is indirect.
; 2689 :                  * don't use the short format (opcodes A0-A3) - it exists for direct
; 2690 :                  * addressing only. Reset OP_A flag!
; 2691 :                  */
; 2692 :                 CodeInfo->opnd[OPND2].type &= ~OP_A;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	btr	eax, 9
	mov	ecx, 24
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rdx+rcx+32], eax

; 2693 :                 DebugMsg1(("check_size: OP_A flag reset, new op2=%X\n", CodeInfo->opnd[OPND2].type ));

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rcx+rax+32]
	lea	rcx, OFFSET FLAT:$SG12440
	call	DoDebugMsg1
	jmp	$LN85@check_size
$LN84@check_size:

; 2694 : #if AMD64_SUPPORT
; 2695 :             } else if ( CodeInfo->Ofssize == USE64 && ( CodeInfo->opnd[OPND1].data64 < 0x80000000 || CodeInfo->opnd[OPND1].data64 >= 0xffffffff80000000 ) ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	jne	$LN86@check_size
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, -2147483648			; 80000000H
	cmp	QWORD PTR [rcx+rax+40], rdx
	jb	SHORT $LN87@check_size
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+40], -2147483648	; ffffffff80000000H
	jb	SHORT $LN86@check_size
$LN87@check_size:

; 2696 :                 /* for 64bit, opcodes A0-A3 ( direct memory addressing with AL/AX/EAX/RAX )
; 2697 :                  * are followed by a full 64-bit moffs. This is only used if the offset won't fit
; 2698 :                  * in a 32-bit signed value.
; 2699 :                  */
; 2700 :                 CodeInfo->opnd[OPND2].type &= ~OP_A;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	btr	eax, 9
	mov	ecx, 24
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rdx+rcx+32], eax

; 2701 :                 DebugMsg1(("check_size: OP_A flag reset, new op2=%X\n", CodeInfo->opnd[OPND2].type ));

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rcx+rax+32]
	lea	rcx, OFFSET FLAT:$SG12443
	call	DoDebugMsg1
$LN86@check_size:
$LN85@check_size:

; 2702 : #endif
; 2703 :             }

	jmp	$LN83@check_size
$LN82@check_size:

; 2704 : 
; 2705 :         } else if( ( op1 & OP_A ) && ( op2 & OP_M ) ) { /* 2. operand memory reference, 1. AL|AX|EAX|RAX? */

	mov	eax, DWORD PTR op1$[rsp]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	$LN88@check_size
	mov	eax, DWORD PTR op2$[rsp]
	and	eax, -1887436800			; ffffffff8f800000H
	test	eax, eax
	je	$LN88@check_size

; 2706 : 
; 2707 :             if ( CodeInfo->isdirect == FALSE ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN89@check_size

; 2708 :                 CodeInfo->opnd[OPND1].type &= ~OP_A;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	btr	eax, 9
	mov	ecx, 24
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rdx+rcx+32], eax

; 2709 :                 DebugMsg1(("check_size: OP_A flag reset, new op1=%X\n", CodeInfo->opnd[OPND1].type ));

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rcx+rax+32]
	lea	rcx, OFFSET FLAT:$SG12447
	call	DoDebugMsg1
	jmp	$LN90@check_size
$LN89@check_size:

; 2710 : #if AMD64_SUPPORT
; 2711 :             } else if ( CodeInfo->Ofssize == USE64 && ( CodeInfo->opnd[OPND2].data64 < 0x80000000 || CodeInfo->opnd[OPND2].data64 >= 0xffffffff80000000 ) ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	jne	$LN91@check_size
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, -2147483648			; 80000000H
	cmp	QWORD PTR [rcx+rax+40], rdx
	jb	SHORT $LN92@check_size
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+40], -2147483648	; ffffffff80000000H
	jb	SHORT $LN91@check_size
$LN92@check_size:

; 2712 :                 CodeInfo->opnd[OPND1].type &= ~OP_A;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	btr	eax, 9
	mov	ecx, 24
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rdx+rcx+32], eax

; 2713 :                 DebugMsg1(("check_size: OP_A flag reset, new op2=%X\n", CodeInfo->opnd[OPND1].type ));

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rcx+rax+32]
	lea	rcx, OFFSET FLAT:$SG12450
	call	DoDebugMsg1
$LN91@check_size:
$LN90@check_size:
$LN88@check_size:
$LN83@check_size:
$LN79@check_size:
$LN75@check_size:
$LN93@check_size:
$def_check$156:

; 2714 : #endif
; 2715 :             }
; 2716 :         }
; 2717 :         /* fall through */
; 2718 :     default:
; 2719 : //#if AMD64_SUPPORT
; 2720 :     def_check:
; 2721 : //#endif
; 2722 :         /* make sure the 2 opnds are of the same type */
; 2723 :         op1_size = OperandSize( op1, CodeInfo );

	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR op1$[rsp]
	call	OperandSize
	mov	DWORD PTR op1_size$[rsp], eax

; 2724 :         op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR op2$[rsp]
	call	OperandSize
	mov	DWORD PTR op2_size$[rsp], eax

; 2725 :         DebugMsg1(("check_size default: op1_size1=%u, op2_size=%u\n", op1_size, op2_size));

	mov	r8d, DWORD PTR op2_size$[rsp]
	mov	edx, DWORD PTR op1_size$[rsp]
	lea	rcx, OFFSET FLAT:$SG12452
	call	DoDebugMsg1

; 2726 :         if( op1_size > op2_size ) {

	mov	eax, DWORD PTR op2_size$[rsp]
	cmp	DWORD PTR op1_size$[rsp], eax
	jle	SHORT $LN94@check_size

; 2727 :             if( ( op2 >= OP_I8 ) && ( op2 <= OP_I32 ) ) {     /* immediate */

	cmp	DWORD PTR op2$[rsp], 131072		; 00020000H
	jl	SHORT $LN95@check_size
	cmp	DWORD PTR op2$[rsp], 524288		; 00080000H
	jg	SHORT $LN95@check_size

; 2728 :                 op2_size = op1_size;    /* promote to larger size */

	mov	eax, DWORD PTR op1_size$[rsp]
	mov	DWORD PTR op2_size$[rsp], eax
$LN95@check_size:
$LN94@check_size:

; 2729 :             }
; 2730 :         }
; 2731 : #if 1
; 2732 :         /* v2.04: check in idata_nofixup was signed,
; 2733 :          * so now add -256 - -129 and 128-255 to acceptable byte range.
; 2734 :          * Since Masm v8, the check is more restrictive, -255 - -129
; 2735 :          * is no longer accepted.
; 2736 :          */
; 2737 :         if( ( op1_size == 1 ) && ( op2 == OP_I16 ) &&
; 2738 :             ( CodeInfo->opnd[OPND2].data32l <= UCHAR_MAX ) &&

	cmp	DWORD PTR op1_size$[rsp], 1
	jne	SHORT $LN96@check_size
	cmp	DWORD PTR op2$[rsp], 262144		; 00040000H
	jne	SHORT $LN96@check_size
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 255		; 000000ffH
	jg	SHORT $LN96@check_size
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], -255		; ffffffffffffff01H
	jl	SHORT $LN96@check_size

; 2739 :             //CodeInfo->opnd[OPND2].data32l >= -128 ) ) {
; 2740 :             ( CodeInfo->opnd[OPND2].data32l >= -255 ) ) {
; 2741 :             return( rc ); /* OK cause no sign extension */

	mov	eax, DWORD PTR rc$[rsp]
	jmp	$LN1@check_size
$LN96@check_size:

; 2742 :         }
; 2743 : #endif
; 2744 : #if 0
; 2745 :         /* v2.03: this "if" made HJWasm accept any 32-bit constant
; 2746 :          *        for 16-bit destinations, which is Masm compatibel,
; 2747 :          *      "mov ax, 12345h"
; 2748 :          * the test is a bit too liberal here, IMO, because
; 2749 :          * it makes HJWasm accept "mov ax, near32 ptr var",
; 2750 :          * which is rejected by Masm.
; 2751 :          */
; 2752 :         if( ( op1_size == 2 ) && ( op2 == OP_I32 )
; 2753 :             && ( CodeInfo->data[OPND2] <= USHRT_MAX ) ) {
; 2754 :             return( rc ); /* OK cause no sign extension */
; 2755 :         }
; 2756 : #endif
; 2757 :         if( op1_size != op2_size ) {

	mov	eax, DWORD PTR op2_size$[rsp]
	cmp	DWORD PTR op1_size$[rsp], eax
	je	$LN97@check_size

; 2758 :             /* if one or more are !defined, set them appropriately */
; 2759 : #if AVXSUPP
; 2760 :             if( ( op1 | op2 ) & ( OP_MMX | OP_XMM | OP_YMM | OP_K | OP_ZMM ) ) {

	mov	eax, DWORD PTR op2$[rsp]
	mov	ecx, DWORD PTR op1$[rsp]
	or	ecx, eax
	mov	eax, ecx
	and	eax, 496				; 000001f0H
	test	eax, eax
	je	SHORT $LN98@check_size

; 2761 : #else
; 2762 :             if( ( op1 | op2 ) & ( OP_MMX | OP_XMM ) ) {
; 2763 : #endif
; 2764 :             }

	jmp	SHORT $LN99@check_size
$LN98@check_size:

; 2765 :             else if( ( op1_size != 0 ) && ( op2_size != 0 ) ) {

	cmp	DWORD PTR op1_size$[rsp], 0
	je	SHORT $LN100@check_size
	cmp	DWORD PTR op2_size$[rsp], 0
	je	SHORT $LN100@check_size

; 2766 :               if ((CodeInfo->token == T_VCVTSD2USI)||(CodeInfo->token == T_VCVTSS2USI)||
; 2767 :                 (CodeInfo->token == T_VCVTTSD2USI)||(CodeInfo->token == T_VCVTTSS2USI))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1603		; 00000643H
	je	SHORT $LN103@check_size
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1604		; 00000644H
	je	SHORT $LN103@check_size
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1623		; 00000657H
	je	SHORT $LN103@check_size
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1624		; 00000658H
	jne	SHORT $LN101@check_size
$LN103@check_size:

; 2768 :                 CodeInfo->evex_flag = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+136], 1
	jmp	SHORT $LN102@check_size
$LN101@check_size:

; 2769 :               else{
; 2770 :                 EmitErr(OPERANDS_MUST_BE_THE_SAME_SIZE, op1_size, op2_size);

	mov	r8d, DWORD PTR op2_size$[rsp]
	mov	edx, DWORD PTR op1_size$[rsp]
	mov	ecx, 48					; 00000030H
	call	EmitErr

; 2771 :                 rc = ERROR;

	mov	DWORD PTR rc$[rsp], -1
$LN102@check_size:
$LN100@check_size:
$LN99@check_size:

; 2772 :               }
; 2773 :             }
; 2774 :             /* size == 0 is assumed to mean "undefined", but there
; 2775 :              * is also the case of an "empty" struct or union. The
; 2776 :              * latter case isn't handled correctly.
; 2777 :              */
; 2778 :             if( op1_size == 0 ) {

	cmp	DWORD PTR op1_size$[rsp], 0
	jne	$LN104@check_size

; 2779 :                 if( ( op1 & OP_M_ANY ) && ( op2 & OP_I ) ) {

	mov	eax, DWORD PTR op1$[rsp]
	and	eax, -8388608				; ffffffffff800000H
	test	eax, eax
	je	$LN105@check_size
	mov	eax, DWORD PTR op2$[rsp]
	and	eax, 917504				; 000e0000H
	test	eax, eax
	je	$LN105@check_size

; 2780 :                     char *p = "WORD";

	lea	rax, OFFSET FLAT:$SG12466
	mov	QWORD PTR p$2[rsp], rax

; 2781 :                     if( (uint_32)CodeInfo->opnd[OPND2].data32l > USHRT_MAX || op2_size == 4 ) {

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 65535		; 0000ffffH
	ja	SHORT $LN109@check_size
	cmp	DWORD PTR op2_size$[rsp], 4
	jne	$LN107@check_size
$LN109@check_size:

; 2782 :                         CodeInfo->iswide = 1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 2783 :                         DebugMsg1(("check_size: op1=%X op1_size=0, op2=%X, op2_size=%u CodeInfo->data[2]=%X\n", op1, op2, op2_size, CodeInfo->opnd[OPND2].data32l ));

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+40]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR op2_size$[rsp]
	mov	r8d, DWORD PTR op2$[rsp]
	mov	edx, DWORD PTR op1$[rsp]
	lea	rcx, OFFSET FLAT:$SG12470
	call	DoDebugMsg1

; 2784 : #if 1 /* added v1.95: in 16bit code, 'mov [di],8000h' should warn: assuming WORD */
; 2785 :                         if ( ModuleInfo.Ofssize == USE16 && op2_size > 2 && InWordRange( CodeInfo->opnd[OPND2].data32l ) )

	movzx	eax, BYTE PTR ModuleInfo+404
	test	eax, eax
	jne	SHORT $LN110@check_size
	cmp	DWORD PTR op2_size$[rsp], 2
	jle	SHORT $LN110@check_size
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 65535		; 0000ffffH
	jg	SHORT $LN148@check_size
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], -65535		; ffffffffffff0001H
	jl	SHORT $LN148@check_size
	mov	DWORD PTR tv602[rsp], 1
	jmp	SHORT $LN149@check_size
$LN148@check_size:
	mov	DWORD PTR tv602[rsp], 0
$LN149@check_size:
	cmp	DWORD PTR tv602[rsp], 0
	je	SHORT $LN110@check_size

; 2786 :                             op2_size = 2;

	mov	DWORD PTR op2_size$[rsp], 2
$LN110@check_size:

; 2787 : #endif
; 2788 :                         if (op2_size <= 2 && CodeInfo->opnd[OPND2].data32l > SHRT_MIN && ModuleInfo.Ofssize == USE16 ) {

	cmp	DWORD PTR op2_size$[rsp], 2
	jg	SHORT $LN111@check_size
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], -32768		; ffffffffffff8000H
	jle	SHORT $LN111@check_size
	movzx	eax, BYTE PTR ModuleInfo+404
	test	eax, eax
	jne	SHORT $LN111@check_size

; 2789 :                             CodeInfo->mem_type = MT_WORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 1

; 2790 :                             CodeInfo->opnd[OPND2].type = OP_I16;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 262144		; 00040000H

; 2791 :                         } else {

	jmp	SHORT $LN112@check_size
$LN111@check_size:

; 2792 :                             CodeInfo->mem_type = MT_DWORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 3

; 2793 :                             CodeInfo->opnd[OPND2].type = OP_I32;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 524288		; 00080000H

; 2794 :                             p = "DWORD";

	lea	rax, OFFSET FLAT:$SG12474
	mov	QWORD PTR p$2[rsp], rax
$LN112@check_size:

; 2795 :                         }

	jmp	$LN108@check_size
$LN107@check_size:

; 2796 :                     } else if( (uint_32)CodeInfo->opnd[OPND2].data32l > UCHAR_MAX || op2_size == 2 ) {

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 255		; 000000ffH
	ja	SHORT $LN115@check_size
	cmp	DWORD PTR op2_size$[rsp], 2
	jne	SHORT $LN113@check_size
$LN115@check_size:

; 2797 :                          CodeInfo->mem_type = MT_WORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 1

; 2798 :                          CodeInfo->iswide = 1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 2799 :                          CodeInfo->opnd[OPND2].type = OP_I16;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 262144		; 00040000H

; 2800 :                     } else {

	jmp	SHORT $LN114@check_size
$LN113@check_size:

; 2801 :                          CodeInfo->mem_type = MT_BYTE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 0

; 2802 :                          CodeInfo->opnd[OPND2].type = OP_I8;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 131072		; 00020000H

; 2803 :                          p = "BYTE";

	lea	rax, OFFSET FLAT:$SG12478
	mov	QWORD PTR p$2[rsp], rax
$LN114@check_size:
$LN108@check_size:

; 2804 :                     }
; 2805 :                     if( opndx[OPND2].explicit == FALSE ) {

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rcx+rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN116@check_size

; 2806 :                         /* v2.06: emit warning at pass one if mem op isn't a forward ref */
; 2807 :                         /* v2.06b: added "undefined" check */
; 2808 :                         if ( ( CodeInfo->opnd[OPND1].InsFixup == NULL && Parse_Pass == PASS_1 && CodeInfo->undef_sym == FALSE ) ||

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	jne	SHORT $LN119@check_size
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN119@check_size
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN118@check_size
$LN119@check_size:
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	je	SHORT $LN117@check_size
	cmp	DWORD PTR Parse_Pass, 1
	jne	SHORT $LN117@check_size
$LN118@check_size:

; 2809 :                             ( CodeInfo->opnd[OPND1].InsFixup && Parse_Pass == PASS_2 ) )
; 2810 :                                 EmitWarn( 1, SIZE_NOT_SPECIFIED_ASSUMING, p );  //ovde je greska

	mov	r8, QWORD PTR p$2[rsp]
	mov	edx, 73					; 00000049H
	mov	ecx, 1
	call	EmitWarn
$LN117@check_size:
$LN116@check_size:

; 2811 :                     }

	jmp	$LN106@check_size
$LN105@check_size:

; 2812 :                 } else if( ( op1 & OP_M_ANY ) && ( op2 & ( OP_R | OP_SR ) ) ) {

	mov	eax, DWORD PTR op1$[rsp]
	and	eax, -8388608				; ffffffffff800000H
	test	eax, eax
	je	SHORT $LN120@check_size
	mov	eax, DWORD PTR op2$[rsp]
	and	eax, 24591				; 0000600fH
	test	eax, eax
	je	SHORT $LN120@check_size
	jmp	$LN121@check_size
$LN120@check_size:

; 2813 :                 } else if( ( op1 & ( OP_MMX | OP_XMM ) ) && ( op2 & OP_I ) ) {

	mov	eax, DWORD PTR op1$[rsp]
	and	eax, 48					; 00000030H
	test	eax, eax
	je	$LN122@check_size
	mov	eax, DWORD PTR op2$[rsp]
	and	eax, 917504				; 000e0000H
	test	eax, eax
	je	$LN122@check_size

; 2814 :                     if( (uint_32)CodeInfo->opnd[OPND2].data32l > USHRT_MAX ) {

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 65535		; 0000ffffH
	jbe	SHORT $LN124@check_size

; 2815 :                          CodeInfo->opnd[OPND2].type = OP_I32;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 524288		; 00080000H
	jmp	SHORT $LN125@check_size
$LN124@check_size:

; 2816 :                     } else if( (uint_32)CodeInfo->opnd[OPND2].data32l > UCHAR_MAX ) {

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 255		; 000000ffH
	jbe	SHORT $LN126@check_size

; 2817 :                          CodeInfo->opnd[OPND2].type = OP_I16;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 262144		; 00040000H

; 2818 :                     } else {

	jmp	SHORT $LN127@check_size
$LN126@check_size:

; 2819 :                          CodeInfo->opnd[OPND2].type = OP_I8;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 131072		; 00020000H
$LN127@check_size:
$LN125@check_size:

; 2820 :                     }

	jmp	$LN123@check_size
$LN122@check_size:

; 2821 :                 } else if( ( op1 | op2 ) & ( OP_MMX | OP_XMM ) ) {

	mov	eax, DWORD PTR op2$[rsp]
	mov	ecx, DWORD PTR op1$[rsp]
	or	ecx, eax
	mov	eax, ecx
	and	eax, 48					; 00000030H
	test	eax, eax
	je	SHORT $LN128@check_size

; 2822 :                 } else {

	jmp	$LN129@check_size
$LN128@check_size:

; 2823 :                     //AsmIntErr( 1 ); /* printf("internal error = %u", 1 ) */
; 2824 :                     switch( op2_size ) {

	mov	eax, DWORD PTR op2_size$[rsp]
	mov	DWORD PTR tv700[rsp], eax
	cmp	DWORD PTR tv700[rsp], 1
	je	SHORT $LN130@check_size
	cmp	DWORD PTR tv700[rsp], 2
	je	SHORT $LN132@check_size
	cmp	DWORD PTR tv700[rsp], 4
	je	$LN135@check_size
	jmp	$LN10@check_size
$LN130@check_size:

; 2825 :                     case 1:
; 2826 :                         CodeInfo->mem_type = MT_BYTE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 0

; 2827 :                         if( ( Parse_Pass == PASS_1 ) && ( op2 & OP_I ) ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN131@check_size
	mov	eax, DWORD PTR op2$[rsp]
	and	eax, 917504				; 000e0000H
	test	eax, eax
	je	SHORT $LN131@check_size

; 2828 :                             EmitWarn( 1, SIZE_NOT_SPECIFIED_ASSUMING, "BYTE" );

	lea	r8, OFFSET FLAT:$SG12495
	mov	edx, 73					; 00000049H
	mov	ecx, 1
	call	EmitWarn
$LN131@check_size:

; 2829 :                         }
; 2830 :                         break;

	jmp	$LN10@check_size
$LN132@check_size:

; 2831 :                     case 2:
; 2832 :                         CodeInfo->mem_type = MT_WORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 1

; 2833 :                         CodeInfo->iswide = 1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 2834 :                         if( ( Parse_Pass == PASS_1 ) && ( op2 & OP_I ) ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN133@check_size
	mov	eax, DWORD PTR op2$[rsp]
	and	eax, 917504				; 000e0000H
	test	eax, eax
	je	SHORT $LN133@check_size

; 2835 :                             EmitWarn( 1, SIZE_NOT_SPECIFIED_ASSUMING, "WORD" );

	lea	r8, OFFSET FLAT:$SG12498
	mov	edx, 73					; 00000049H
	mov	ecx, 1
	call	EmitWarn
$LN133@check_size:

; 2836 :                         }
; 2837 :                         if( CodeInfo->Ofssize )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN134@check_size

; 2838 :                             CodeInfo->prefix.opsiz = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	or	al, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN134@check_size:

; 2839 :                         break;

	jmp	SHORT $LN10@check_size
$LN135@check_size:

; 2840 :                     case 4:
; 2841 :                         CodeInfo->mem_type = MT_DWORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 3

; 2842 :                         CodeInfo->iswide = 1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 2843 :                         if( ( Parse_Pass == PASS_1 ) && ( op2 & OP_I ) ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN136@check_size
	mov	eax, DWORD PTR op2$[rsp]
	and	eax, 917504				; 000e0000H
	test	eax, eax
	je	SHORT $LN136@check_size

; 2844 :                             EmitWarn( 1, SIZE_NOT_SPECIFIED_ASSUMING, "DWORD" );

	lea	r8, OFFSET FLAT:$SG12502
	mov	edx, 73					; 00000049H
	mov	ecx, 1
	call	EmitWarn
$LN136@check_size:
$LN10@check_size:
$LN129@check_size:
$LN123@check_size:
$LN121@check_size:
$LN106@check_size:
$LN104@check_size:
$LN97@check_size:
$LN2@check_size:

; 2845 :                         }
; 2846 :                         break;
; 2847 :                     }
; 2848 :                 }
; 2849 :             }
; 2850 :         }
; 2851 :     }
; 2852 :     DebugMsg1(("check_size exit [CodeInfo->mem_type=%Xh]\n", CodeInfo->mem_type));

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rax+28]
	lea	rcx, OFFSET FLAT:$SG12503
	call	DoDebugMsg1

; 2853 :     return( rc );

	mov	eax, DWORD PTR rc$[rsp]
$LN1@check_size:

; 2854 : }

	add	rsp, 136				; 00000088H
	ret	0
	npad	2
$LN155@check_size:
	DD	$LN27@check_size
	DD	$LN33@check_size
	DD	$LN49@check_size
	DD	$LN73@check_size
	DD	$LN35@check_size
	DD	$LN55@check_size
	DD	$LN14@check_size
	DD	$LN50@check_size
	DD	$LN26@check_size
	DD	$LN36@check_size
	DD	$LN20@check_size
	DD	$LN93@check_size
$LN154@check_size:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	1
	DB	1
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	2
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	3
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	4
	DB	11
	DB	5
	DB	6
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	7
	DB	7
	DB	8
	DB	11
	DB	1
	DB	1
	DB	1
	DB	11
	DB	11
	DB	9
	DB	9
	DB	11
	DB	10
check_size ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
tv65 = 32
op_size$ = 36
opndidx$ = 40
tv263 = 44
tv278 = 48
tv292 = 52
CodeInfo$ = 80
opndx$ = 88
HandleStringInstructions PROC

; 2166 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2167 :     int opndidx = OPND1;

	mov	DWORD PTR opndidx$[rsp], 0

; 2168 :     int op_size;
; 2169 : 
; 2170 :     switch( CodeInfo->token ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 1211		; 000004bbH
	jg	$LN53@HandleStri
	cmp	DWORD PTR tv65[rsp], 1211		; 000004bbH
	je	$LN8@HandleStri
	cmp	DWORD PTR tv65[rsp], 536		; 00000218H
	jg	SHORT $LN54@HandleStri
	cmp	DWORD PTR tv65[rsp], 536		; 00000218H
	je	$LN17@HandleStri
	mov	eax, DWORD PTR tv65[rsp]
	sub	eax, 521				; 00000209H
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 14
	ja	$LN29@HandleStri
	movsxd	rax, DWORD PTR tv65[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN60@HandleStri[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN54@HandleStri:
	cmp	DWORD PTR tv65[rsp], 537		; 00000219H
	jl	$LN29@HandleStri
	cmp	DWORD PTR tv65[rsp], 540		; 0000021cH
	jle	$LN25@HandleStri
	cmp	DWORD PTR tv65[rsp], 1047		; 00000417H
	je	$LN20@HandleStri
	cmp	DWORD PTR tv65[rsp], 1053		; 0000041dH
	je	$LN17@HandleStri
	jmp	$LN29@HandleStri
$LN53@HandleStri:
	cmp	DWORD PTR tv65[rsp], 1458		; 000005b2H
	jg	SHORT $LN55@HandleStri
	cmp	DWORD PTR tv65[rsp], 1457		; 000005b1H
	jge	SHORT $LN6@HandleStri
	cmp	DWORD PTR tv65[rsp], 1212		; 000004bcH
	je	$LN27@HandleStri
	cmp	DWORD PTR tv65[rsp], 1213		; 000004bdH
	je	$LN20@HandleStri
	cmp	DWORD PTR tv65[rsp], 1450		; 000005aaH
	jle	$LN29@HandleStri
	cmp	DWORD PTR tv65[rsp], 1452		; 000005acH
	jle	SHORT $LN6@HandleStri
	jmp	$LN29@HandleStri
$LN55@HandleStri:
	cmp	DWORD PTR tv65[rsp], 1763		; 000006e3H
	je	SHORT $LN6@HandleStri
	cmp	DWORD PTR tv65[rsp], 1944		; 00000798H
	je	$LN17@HandleStri
	cmp	DWORD PTR tv65[rsp], 1955		; 000007a3H
	je	$LN17@HandleStri
	jmp	$LN29@HandleStri
$LN6@HandleStri:

; 2171 : #if AVXSUPP
; 2172 :     case T_VCMPSD:
; 2173 :     case T_VPCMPD:
; 2174 :     case T_VPCMPB:
; 2175 :     case T_VPCMPUD:
; 2176 :     case T_VPCMPUB:
; 2177 : #endif
; 2178 :     case T_CMPSD:
; 2179 :         /* filter SSE2 opcode CMPSD */
; 2180 :         if ( CodeInfo->opnd[OPND1].type & (OP_XMM | OP_MMX)) {

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 48					; 00000030H
	test	eax, eax
	je	SHORT $LN7@HandleStri

; 2181 :             /* v2.01: QWORD operand for CMPSD/MOVSD may have set REX_W! */
; 2182 : #if AMD64_SUPPORT
; 2183 :             CodeInfo->prefix.rex &= ~REX_W;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	and	eax, -9
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+8], al

; 2184 : #endif
; 2185 :             return;

	jmp	$LN1@HandleStri
$LN7@HandleStri:
$LN8@HandleStri:

; 2186 :         }
; 2187 :         /* fall through */
; 2188 :     case T_CMPS:
; 2189 :     case T_CMPSB:
; 2190 :     case T_CMPSW:
; 2191 : #if AMD64_SUPPORT
; 2192 :     case T_CMPSQ:
; 2193 : #endif
; 2194 :          /* cmps allows prefix for the first operand (=source) only */
; 2195 :         if ( CodeInfo->prefix.RegOverride != EMPTY ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+4], -2
	je	$LN9@HandleStri

; 2196 :             if ( opndx[OPND2].override != NULL ) {

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	je	SHORT $LN10@HandleStri

; 2197 :                 if ( CodeInfo->prefix.RegOverride == ASSUME_ES ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+4], 0
	jne	SHORT $LN12@HandleStri

; 2198 :                     /* content of LastRegOverride is valid if
; 2199 :                      * CodeInfo->RegOverride is != EMPTY.
; 2200 :                      */
; 2201 :                     if ( LastRegOverride == ASSUME_DS )

	cmp	DWORD PTR LastRegOverride, 3
	jne	SHORT $LN14@HandleStri

; 2202 :                         CodeInfo->prefix.RegOverride = EMPTY;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+4], -2
	jmp	SHORT $LN15@HandleStri
$LN14@HandleStri:

; 2203 :                     else
; 2204 :                         CodeInfo->prefix.RegOverride = LastRegOverride;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR LastRegOverride
	mov	DWORD PTR [rax+4], ecx
$LN15@HandleStri:

; 2205 :                 } else {

	jmp	SHORT $LN13@HandleStri
$LN12@HandleStri:

; 2206 :                     DebugMsg1(("HandleStringInstructions: CMPS: CodeInfo->RegOverride=%X, opndx->override=%s\n", CodeInfo->prefix.RegOverride, opndx[OPND2].override->string_ptr ));

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rax+4]
	lea	rcx, OFFSET FLAT:$SG12296
	call	DoDebugMsg1

; 2207 :                     EmitError( INVALID_INSTRUCTION_OPERANDS );

	mov	ecx, 49					; 00000031H
	call	EmitError
$LN13@HandleStri:

; 2208 :                 }

	jmp	SHORT $LN11@HandleStri
$LN10@HandleStri:

; 2209 :             } else if ( CodeInfo->prefix.RegOverride == ASSUME_DS ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+4], 3
	jne	SHORT $LN16@HandleStri

; 2210 :                 /* prefix for first operand? */
; 2211 :                 CodeInfo->prefix.RegOverride = EMPTY;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+4], -2
$LN16@HandleStri:
$LN11@HandleStri:
$LN9@HandleStri:

; 2212 :             }
; 2213 :         }
; 2214 :         break;

	jmp	$LN2@HandleStri
$LN17@HandleStri:

; 2215 : #if AVXSUPP
; 2216 :     case T_VMOVSD:
; 2217 :     case T_VMOVUPS:
; 2218 : #endif
; 2219 :     case T_MOVSD:
; 2220 :     case T_MOVUPS:
; 2221 : 
; 2222 :         /* filter SSE2 opcode MOVSD */
; 2223 :         if ( ( CodeInfo->opnd[OPND1].type & (OP_XMM | OP_MMX | OP_YMM | OP_ZMM) ) ||

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 432				; 000001b0H
	test	eax, eax
	jne	SHORT $LN19@HandleStri
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 432				; 000001b0H
	test	eax, eax
	je	SHORT $LN18@HandleStri
$LN19@HandleStri:

; 2224 :             ( CodeInfo->opnd[OPND2].type & (OP_XMM | OP_MMX | OP_YMM | OP_ZMM) ) ) {
; 2225 :             /* v2.01: QWORD operand for CMPSD/MOVSD may have set REX_W! */
; 2226 : #if AMD64_SUPPORT
; 2227 :             CodeInfo->prefix.rex &= ~REX_W;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	and	eax, -9
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+8], al

; 2228 : #endif
; 2229 :             return;

	jmp	$LN1@HandleStri
$LN18@HandleStri:
$LN20@HandleStri:

; 2230 :         }
; 2231 :         /* fall through */
; 2232 :     case T_MOVS:
; 2233 :     case T_MOVSB:
; 2234 :     case T_MOVSW:
; 2235 : #if AMD64_SUPPORT
; 2236 :     case T_MOVSQ:
; 2237 :     case T_MOVQ:
; 2238 : #endif
; 2239 :         /* movs allows prefix for the second operand (=source) only */
; 2240 :         if ( CodeInfo->prefix.RegOverride != EMPTY )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+4], -2
	je	SHORT $LN21@HandleStri

; 2241 :             if ( opndx[OPND2].override == NULL )

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	jne	SHORT $LN22@HandleStri

; 2242 :                 EmitError( INVALID_INSTRUCTION_OPERANDS );

	mov	ecx, 49					; 00000031H
	call	EmitError
	jmp	SHORT $LN23@HandleStri
$LN22@HandleStri:

; 2243 :             else if ( CodeInfo->prefix.RegOverride == ASSUME_DS )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+4], 3
	jne	SHORT $LN24@HandleStri

; 2244 :                 CodeInfo->prefix.RegOverride = EMPTY;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+4], -2
$LN24@HandleStri:
$LN23@HandleStri:
$LN21@HandleStri:

; 2245 :         break;

	jmp	SHORT $LN2@HandleStri
$LN25@HandleStri:

; 2246 :     case T_OUTS:
; 2247 :     case T_OUTSB:
; 2248 :     case T_OUTSW:
; 2249 :     case T_OUTSD:
; 2250 :         /* v2.01: remove default DS prefix */
; 2251 :         if ( CodeInfo->prefix.RegOverride == ASSUME_DS )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+4], 3
	jne	SHORT $LN26@HandleStri

; 2252 :             CodeInfo->prefix.RegOverride = EMPTY;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+4], -2
$LN26@HandleStri:

; 2253 :         opndidx = OPND2;

	mov	DWORD PTR opndidx$[rsp], 1

; 2254 :         break;

	jmp	SHORT $LN2@HandleStri
$LN27@HandleStri:

; 2255 :     case T_LODS:
; 2256 :     case T_LODSB:
; 2257 :     case T_LODSW:
; 2258 :     case T_LODSD:
; 2259 : #if AMD64_SUPPORT
; 2260 :     case T_LODSQ:
; 2261 : #endif
; 2262 :         /* v2.10: remove unnecessary DS prefix ( Masm-compatible ) */
; 2263 :         if ( CodeInfo->prefix.RegOverride == ASSUME_DS )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+4], 3
	jne	SHORT $LN28@HandleStri

; 2264 :             CodeInfo->prefix.RegOverride = EMPTY;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+4], -2
$LN28@HandleStri:

; 2265 :         break;

	jmp	SHORT $LN2@HandleStri
$LN29@HandleStri:

; 2266 :     default: /*INS[B|W|D], SCAS[B|W|D|Q], STOS[B|W|D|Q] */
; 2267 :         /* INSx, SCASx and STOSx don't allow any segment prefix != ES
; 2268 :          for the memory operand.
; 2269 :          */
; 2270 :         if ( CodeInfo->prefix.RegOverride != EMPTY )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+4], -2
	je	SHORT $LN30@HandleStri

; 2271 :             if ( CodeInfo->prefix.RegOverride == ASSUME_ES )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+4], 0
	jne	SHORT $LN31@HandleStri

; 2272 :                 CodeInfo->prefix.RegOverride = EMPTY;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+4], -2
	jmp	SHORT $LN32@HandleStri
$LN31@HandleStri:

; 2273 :             else
; 2274 :                 EmitError( INVALID_INSTRUCTION_OPERANDS );

	mov	ecx, 49					; 00000031H
	call	EmitError
$LN32@HandleStri:
$LN30@HandleStri:
$LN2@HandleStri:

; 2275 :     }
; 2276 : 
; 2277 :     if ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[opndidx] == OP_NONE ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR opndidx$[rsp]
	cmp	DWORD PTR [rax+rcx*4], 0
	jne	SHORT $LN33@HandleStri

; 2278 :         CodeInfo->iswide = 0;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 2279 :         CodeInfo->prefix.opsiz = FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN33@HandleStri:

; 2280 :     }
; 2281 : 
; 2282 :     /* if the instruction is the variant without suffix (MOVS, LODS, ..),
; 2283 :      * then use the operand's size to get further info.
; 2284 :      */
; 2285 :     //if ( CodeInfo->pinstr->opnd_type[opndidx] != OP_NONE &&
; 2286 :     if ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[opndidx] != OP_NONE &&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR opndidx$[rsp]
	cmp	DWORD PTR [rax+rcx*4], 0
	je	$LN34@HandleStri
	movsxd	rax, DWORD PTR opndidx$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 0
	je	$LN34@HandleStri

; 2287 :         CodeInfo->opnd[opndidx].type != OP_NONE ) {
; 2288 :         if (CodeInfo->token == T_KMOVB) op_size = 1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1730		; 000006c2H
	jne	SHORT $LN35@HandleStri
	mov	DWORD PTR op_size$[rsp], 1
	jmp	SHORT $LN36@HandleStri
$LN35@HandleStri:

; 2289 :         else if (CodeInfo->token == T_KMOVW) op_size = 2;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1733		; 000006c5H
	jne	SHORT $LN37@HandleStri
	mov	DWORD PTR op_size$[rsp], 2
	jmp	SHORT $LN38@HandleStri
$LN37@HandleStri:

; 2290 :         else if (CodeInfo->token == T_KMOVD) op_size = 4;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1731		; 000006c3H
	jne	SHORT $LN39@HandleStri
	mov	DWORD PTR op_size$[rsp], 4
	jmp	SHORT $LN40@HandleStri
$LN39@HandleStri:

; 2291 :         else if (CodeInfo->token == T_KMOVQ) op_size = 8;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1732		; 000006c4H
	jne	SHORT $LN41@HandleStri
	mov	DWORD PTR op_size$[rsp], 8
	jmp	SHORT $LN42@HandleStri
$LN41@HandleStri:

; 2292 :         else op_size = OperandSize( CodeInfo->opnd[opndidx].type, CodeInfo );

	movsxd	rax, DWORD PTR opndidx$[rsp]
	imul	rax, rax, 24
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+32]
	call	OperandSize
	mov	DWORD PTR op_size$[rsp], eax
$LN42@HandleStri:
$LN40@HandleStri:
$LN38@HandleStri:
$LN36@HandleStri:

; 2293 :         /* v2.06: added. if memory operand has no size */
; 2294 :         if ( op_size == 0 )

	cmp	DWORD PTR op_size$[rsp], 0
	jne	SHORT $LN43@HandleStri

; 2295 :           op_size = OperandSize( CodeInfo->opnd[opndidx+1].type, CodeInfo );

	mov	eax, DWORD PTR opndidx$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 24
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+32]
	call	OperandSize
	mov	DWORD PTR op_size$[rsp], eax
$LN43@HandleStri:

; 2296 :         if ( op_size == 0 ) {

	cmp	DWORD PTR op_size$[rsp], 0
	jne	SHORT $LN44@HandleStri

; 2297 :             if ( CodeInfo->opnd[opndidx].InsFixup == NULL || CodeInfo->opnd[opndidx].InsFixup->sym->state != SYM_UNDEFINED )

	movsxd	rax, DWORD PTR opndidx$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	je	SHORT $LN46@HandleStri
	movsxd	rax, DWORD PTR opndidx$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	mov	rax, QWORD PTR [rax+56]
	cmp	DWORD PTR [rax+40], 0
	je	SHORT $LN45@HandleStri
$LN46@HandleStri:

; 2298 :                 EmitError( INSTRUCTION_OPERAND_MUST_HAVE_SIZE );

	mov	ecx, 182				; 000000b6H
	call	EmitError
$LN45@HandleStri:

; 2299 :             op_size = 1; /* assume shortest format */

	mov	DWORD PTR op_size$[rsp], 1
$LN44@HandleStri:

; 2300 :         }
; 2301 :         switch( op_size ) {

	mov	eax, DWORD PTR op_size$[rsp]
	mov	DWORD PTR tv263[rsp], eax
	cmp	DWORD PTR tv263[rsp], 1
	je	SHORT $LN47@HandleStri
	cmp	DWORD PTR tv263[rsp], 2
	je	SHORT $LN48@HandleStri
	cmp	DWORD PTR tv263[rsp], 4
	je	$LN49@HandleStri
	cmp	DWORD PTR tv263[rsp], 8
	je	$LN50@HandleStri
	jmp	$LN4@HandleStri
$LN47@HandleStri:

; 2302 :         case 1:
; 2303 :             CodeInfo->iswide = 0;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 2304 :             //if( CodeInfo->Ofssize )
; 2305 :                 CodeInfo->prefix.opsiz = FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 2306 :             break;

	jmp	$LN4@HandleStri
$LN48@HandleStri:

; 2307 :         case 2:
; 2308 :             CodeInfo->iswide = 1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 2309 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? TRUE : FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN56@HandleStri
	mov	DWORD PTR tv278[rsp], 1
	jmp	SHORT $LN57@HandleStri
$LN56@HandleStri:
	mov	DWORD PTR tv278[rsp], 0
$LN57@HandleStri:
	movzx	eax, BYTE PTR tv278[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 2310 :             break;

	jmp	$LN4@HandleStri
$LN49@HandleStri:

; 2311 :         case 4:
; 2312 :             CodeInfo->iswide = 1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 2313 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? FALSE : TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN58@HandleStri
	mov	DWORD PTR tv292[rsp], 0
	jmp	SHORT $LN59@HandleStri
$LN58@HandleStri:
	mov	DWORD PTR tv292[rsp], 1
$LN59@HandleStri:
	movzx	eax, BYTE PTR tv292[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 2314 :             break;

	jmp	SHORT $LN4@HandleStri
$LN50@HandleStri:

; 2315 : #if AMD64_SUPPORT
; 2316 :         case 8:
; 2317 :             if ( CodeInfo->Ofssize == USE64 ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	jne	SHORT $LN51@HandleStri

; 2318 :                 CodeInfo->iswide = 1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 2319 :                 CodeInfo->prefix.opsiz = FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 2320 :                 CodeInfo->prefix.rex = REX_W;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+8], 8
$LN51@HandleStri:
$LN4@HandleStri:
$LN34@HandleStri:
$LN1@HandleStri:

; 2321 :             }
; 2322 :             break;
; 2323 : #endif
; 2324 :         }
; 2325 :     }
; 2326 :     return;
; 2327 : }

	add	rsp, 72					; 00000048H
	ret	0
$LN60@HandleStri:
	DD	$LN8@HandleStri
	DD	$LN8@HandleStri
	DD	$LN8@HandleStri
	DD	$LN6@HandleStri
	DD	$LN29@HandleStri
	DD	$LN29@HandleStri
	DD	$LN29@HandleStri
	DD	$LN29@HandleStri
	DD	$LN27@HandleStri
	DD	$LN27@HandleStri
	DD	$LN27@HandleStri
	DD	$LN27@HandleStri
	DD	$LN20@HandleStri
	DD	$LN20@HandleStri
	DD	$LN20@HandleStri
HandleStringInstructions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
regno$ = 32
flags$ = 36
regtok$ = 40
tv191 = 44
tv272 = 48
tv275 = 52
CodeInfo$ = 80
CurrOpnd$ = 88
opndx$ = 96
process_register PROC

; 2006 : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2007 :     enum special_token regtok;
; 2008 :     int  regno;
; 2009 :     uint_32 flags;
; 2010 :     DebugMsg1(( "process_register enter (%s)\n", opndx[CurrOpnd].base_reg->string_ptr ));

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12226
	call	DoDebugMsg1

; 2011 :     regtok = opndx[CurrOpnd].base_reg->tokval;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR regtok$[rsp], eax

; 2012 :     regno = GetRegNo( regtok );

	movsxd	rax, DWORD PTR regtok$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	DWORD PTR regno$[rsp], eax

; 2013 :     /* the register's "OP-flags" are stored in the 'value' field */
; 2014 :     flags = GetValueSp( regtok );

	movsxd	rax, DWORD PTR regtok$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR flags$[rsp], eax

; 2015 :     CodeInfo->opnd[CurrOpnd].type = flags;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rcx+rax+32], edx

; 2016 : #if AVXSUPP
; 2017 : 	if (CodeInfo->opnd[CurrOpnd].type == OP_XMM || CodeInfo->opnd[CurrOpnd].type == OP_YMM)

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 32		; 00000020H
	je	SHORT $LN3@process_re
	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 128		; 00000080H
	jne	SHORT $LN2@process_re
$LN3@process_re:

; 2018 : 	{
; 2019 : 		if (!evex && regno > 15)

	movzx	eax, BYTE PTR evex
	test	eax, eax
	jne	SHORT $LN4@process_re
	cmp	DWORD PTR regno$[rsp], 15
	jle	SHORT $LN4@process_re

; 2020 : 		{ 
; 2021 : 			return(EmitError(UNAUTHORISED_USE_OF_EVEX_REGISTERS));

	mov	ecx, 22
	call	EmitError
	jmp	$LN1@process_re
$LN4@process_re:
$LN2@process_re:

; 2022 : 		}
; 2023 : 	}
; 2024 : 	if (CodeInfo->opnd[CurrOpnd].type == OP_ZMM) {

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 256		; 00000100H
	jne	SHORT $LN5@process_re

; 2025 : 		if (evex)

	movzx	eax, BYTE PTR evex
	test	eax, eax
	je	SHORT $LN6@process_re

; 2026 : 			CodeInfo->evex_flag = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+136], 1
	jmp	SHORT $LN7@process_re
$LN6@process_re:

; 2027 : 		else
; 2028 : 			return(EmitError(UNAUTHORISED_USE_OF_EVEX_REGISTERS));

	mov	ecx, 22
	call	EmitError
	jmp	$LN1@process_re
$LN7@process_re:
$LN5@process_re:

; 2029 : 	}
; 2030 : 	if (CodeInfo->opnd[CurrOpnd].type == OP_K && regno > 7) {

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 64		; 00000040H
	jne	SHORT $LN8@process_re
	cmp	DWORD PTR regno$[rsp], 7
	jle	SHORT $LN8@process_re

; 2031 : 		DebugMsg(("process_register: assume error, reg=%u\n", regno));

	mov	edx, DWORD PTR regno$[rsp]
	lea	rcx, OFFSET FLAT:$SG12234
	call	DoDebugMsg

; 2032 : 		return(EmitError(USE_OF_REGISTER_ASSUMED_TO_ERROR));

	mov	ecx, 183				; 000000b7H
	call	EmitError
	jmp	$LN1@process_re
$LN8@process_re:

; 2033 : 	}
; 2034 : #endif    
; 2035 : 	if ( flags & OP_R8 ) {

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	$LN9@process_re

; 2036 :         /* it's probably better to not reset the wide bit at all */
; 2037 :         if ( flags != OP_CL )      /* problem: SHL AX|AL, CL */

	cmp	DWORD PTR flags$[rsp], 1025		; 00000401H
	je	SHORT $LN11@process_re

; 2038 :             CodeInfo->iswide = 0;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al
$LN11@process_re:

; 2039 : 
; 2040 : #if AMD64_SUPPORT
; 2041 :         if ( CodeInfo->Ofssize == USE64 && regno >=4 && regno <=7 )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	jne	SHORT $LN12@process_re
	cmp	DWORD PTR regno$[rsp], 4
	jl	SHORT $LN12@process_re
	cmp	DWORD PTR regno$[rsp], 7
	jg	SHORT $LN12@process_re

; 2042 :             if ( SpecialTable[regtok].cpu == P_86 )

	movsxd	rax, DWORD PTR regtok$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, WORD PTR [rcx+rax+8]
	test	eax, eax
	jne	SHORT $LN13@process_re

; 2043 :                 CodeInfo->x86hi_used = 1; /* it's AH,BH,CH,DH */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 16
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al
	jmp	SHORT $LN14@process_re
$LN13@process_re:

; 2044 :             else
; 2045 :                 CodeInfo->x64lo_used = 1; /* it's SPL,BPL,SIL,DIL */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al
$LN14@process_re:
$LN12@process_re:

; 2046 : #endif
; 2047 :         if ( StdAssumeTable[regno].error & (( regtok >= T_AH && regtok <= T_BH ) ? RH_ERROR : RL_ERROR ) ) {

	cmp	DWORD PTR regtok$[rsp], 5
	jl	SHORT $LN44@process_re
	cmp	DWORD PTR regtok$[rsp], 8
	jg	SHORT $LN44@process_re
	mov	DWORD PTR tv191[rsp], 16
	jmp	SHORT $LN45@process_re
$LN44@process_re:
	mov	DWORD PTR tv191[rsp], 1
$LN45@process_re:
	movsxd	rax, DWORD PTR regno$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	movzx	eax, BYTE PTR [rcx+rax+8]
	and	eax, DWORD PTR tv191[rsp]
	test	eax, eax
	je	SHORT $LN15@process_re

; 2048 :             DebugMsg(("process_register: assume error, reg=%u\n", regno ));

	mov	edx, DWORD PTR regno$[rsp]
	lea	rcx, OFFSET FLAT:$SG12242
	call	DoDebugMsg

; 2049 :             return( EmitError( USE_OF_REGISTER_ASSUMED_TO_ERROR ) );

	mov	ecx, 183				; 000000b7H
	call	EmitError
	jmp	$LN1@process_re
$LN15@process_re:

; 2050 :         }

	jmp	$LN10@process_re
$LN9@process_re:

; 2051 :     } else if ( flags & OP_R ) { /* 16-, 32- or 64-bit GPR? */

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 15
	test	eax, eax
	je	$LN16@process_re

; 2052 :         CodeInfo->iswide = 1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 2053 :         if ( StdAssumeTable[regno].error & flags & OP_R ) {

	movsxd	rax, DWORD PTR regno$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:StdAssumeTable
	movzx	eax, BYTE PTR [rcx+rax+8]
	and	eax, DWORD PTR flags$[rsp]
	and	eax, 15
	test	eax, eax
	je	SHORT $LN18@process_re

; 2054 :             DebugMsg(("process_register: assume error, reg=%u\n", regno ));

	mov	edx, DWORD PTR regno$[rsp]
	lea	rcx, OFFSET FLAT:$SG12246
	call	DoDebugMsg

; 2055 :             return( EmitError( USE_OF_REGISTER_ASSUMED_TO_ERROR ) );

	mov	ecx, 183				; 000000b7H
	call	EmitError
	jmp	$LN1@process_re
$LN18@process_re:

; 2056 :         }
; 2057 :         if ( flags & OP_R16 ) {

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN19@process_re

; 2058 :             if ( CodeInfo->Ofssize > USE16 )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jle	SHORT $LN21@process_re

; 2059 :                 CodeInfo->prefix.opsiz = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	or	al, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN21@process_re:

; 2060 :         } else {

	jmp	SHORT $LN20@process_re
$LN19@process_re:

; 2061 :             if( CodeInfo->Ofssize == USE16 )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jne	SHORT $LN22@process_re

; 2062 :                 CodeInfo->prefix.opsiz = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	or	al, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN22@process_re:
$LN20@process_re:

; 2063 :         }

	jmp	$LN17@process_re
$LN16@process_re:

; 2064 :     } else if ( flags & OP_SR ) {

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 24576				; 00006000H
	test	eax, eax
	je	SHORT $LN23@process_re

; 2065 :         if( regno == 1 ) { /* 1 is CS */

	cmp	DWORD PTR regno$[rsp], 1
	jne	SHORT $LN25@process_re

; 2066 :             /* POP CS is not allowed */
; 2067 :             if( CodeInfo->token == T_POP ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 602			; 0000025aH
	jne	SHORT $LN26@process_re

; 2068 :                 return( EmitError( POP_CS_IS_NOT_ALLOWED ) );

	mov	ecx, 41					; 00000029H
	call	EmitError
	jmp	$LN1@process_re
$LN26@process_re:
$LN25@process_re:

; 2069 :             }
; 2070 :         }

	jmp	$LN24@process_re
$LN23@process_re:

; 2071 :     } else if ( flags & OP_ST ) {

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32768				; 00008000H
	test	eax, eax
	je	SHORT $LN27@process_re

; 2072 : 
; 2073 :         regno = opndx[CurrOpnd].st_idx;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR regno$[rsp], eax

; 2074 :         if ( regno > 7 ) { /* v1.96: index check added */

	cmp	DWORD PTR regno$[rsp], 7
	jle	SHORT $LN29@process_re

; 2075 :             return( EmitError( INVALID_COPROCESSOR_REGISTER ) );

	mov	ecx, 252				; 000000fcH
	call	EmitError
	jmp	$LN1@process_re
$LN29@process_re:

; 2076 :         }
; 2077 :         CodeInfo->rm_byte |= regno;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	or	eax, DWORD PTR regno$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+104], al

; 2078 :         if( regno != 0 )

	cmp	DWORD PTR regno$[rsp], 0
	je	SHORT $LN30@process_re

; 2079 :             CodeInfo->opnd[CurrOpnd].type = OP_ST_REG;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 65536		; 00010000H
$LN30@process_re:

; 2080 :         /* v2.06: exit, rm_byte is already set. */
; 2081 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@process_re
	jmp	$LN28@process_re
$LN27@process_re:

; 2082 : 
; 2083 :     } else if ( flags & OP_RSPEC ) { /* CRx, DRx, TRx */

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4096				; 00001000H
	test	eax, eax
	je	$LN31@process_re

; 2084 :         if( CodeInfo->token != T_MOV ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 606			; 0000025eH
	je	SHORT $LN32@process_re

; 2085 :             return( EmitError( ONLY_MOV_CAN_USE_SPECIAL_REGISTER ) );

	mov	ecx, 42					; 0000002aH
	call	EmitError
	jmp	$LN1@process_re
$LN32@process_re:

; 2086 :         }
; 2087 :         /* v2.04: previously there were 3 flags, OP_CR, OP_DR and OP_TR.
; 2088 :          * this was summoned to one flag OP_RSPEC to free 2 flags, which
; 2089 :          * are needed if AVC ( new YMM registers ) is to be supported.
; 2090 :          * To distinguish between CR, DR and TR, the register number is
; 2091 :          * used now: CRx are numbers 0-F, DRx are numbers 0x10-0x1F and
; 2092 :          * TRx are 0x20-0x2F.
; 2093 :          */
; 2094 : 		if (regno >= 0x20) { /* TRx? */

	cmp	DWORD PTR regno$[rsp], 32		; 00000020H
	jl	SHORT $LN33@process_re

; 2095 : 			CodeInfo->opc_or |= 0x04;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+107]
	or	eax, 4
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+107], al

; 2096 : 			/* TR3-TR5 are available on 486-586
; 2097 : 			* TR6+TR7 are available on 386-586
; 2098 : 			* v2.11: simplified.
; 2099 : 			*/
; 2100 : 			if ((ModuleInfo.curr_cpu & P_CPU_MASK) >= P_686) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 96					; 00000060H
	jl	SHORT $LN35@process_re

; 2101 : 				return(EmitErr(CANNOT_USE_TRN_TO_TRM_WITH_CURRENT_CPU_SETTING, regno > 0x25 ? 6 : 3, regno > 0x25 ? 7 : 5));

	cmp	DWORD PTR regno$[rsp], 37		; 00000025H
	jle	SHORT $LN46@process_re
	mov	DWORD PTR tv272[rsp], 7
	jmp	SHORT $LN47@process_re
$LN46@process_re:
	mov	DWORD PTR tv272[rsp], 5
$LN47@process_re:
	cmp	DWORD PTR regno$[rsp], 37		; 00000025H
	jle	SHORT $LN48@process_re
	mov	DWORD PTR tv275[rsp], 6
	jmp	SHORT $LN49@process_re
$LN48@process_re:
	mov	DWORD PTR tv275[rsp], 3
$LN49@process_re:
	mov	r8d, DWORD PTR tv272[rsp]
	mov	edx, DWORD PTR tv275[rsp]
	mov	ecx, 32					; 00000020H
	call	EmitErr
	jmp	$LN1@process_re
$LN35@process_re:

; 2102 : 			}
; 2103 : 		}

	jmp	SHORT $LN34@process_re
$LN33@process_re:

; 2104 : 		else if (regno >= 0x10) { /* DRx? */

	cmp	DWORD PTR regno$[rsp], 16
	jl	SHORT $LN36@process_re

; 2105 : 			CodeInfo->opc_or |= 0x01;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+107]
	or	eax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+107], al
$LN36@process_re:
$LN34@process_re:

; 2106 : 		}
; 2107 : 		regno &= 0x0F;

	mov	eax, DWORD PTR regno$[rsp]
	and	eax, 15
	mov	DWORD PTR regno$[rsp], eax
$LN31@process_re:
$LN28@process_re:
$LN24@process_re:
$LN17@process_re:
$LN10@process_re:

; 2108 : 	}
; 2109 : #if AMD64_SUPPORT
; 2110 : 
; 2111 :     /* if it's a x86-64 register (SIL, R8W, R8D, RSI, ... */
; 2112 :     if ( ( SpecialTable[regtok].cpu & P_CPU_MASK ) == P_64 ) {

	movsxd	rax, DWORD PTR regtok$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, WORD PTR [rcx+rax+8]
	and	eax, 240				; 000000f0H
	cmp	eax, 112				; 00000070H
	jne	SHORT $LN37@process_re

; 2113 :         CodeInfo->prefix.rex |= 0x40;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+8], al

; 2114 :         if ( flags & OP_R64 )

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN38@process_re

; 2115 :             CodeInfo->prefix.rex |= REX_W;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	or	eax, 8
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+8], al
$LN38@process_re:
$LN37@process_re:

; 2116 :     }
; 2117 : #endif
; 2118 :     if( CurrOpnd == OPND1 ) {

	cmp	DWORD PTR CurrOpnd$[rsp], 0
	jne	SHORT $LN39@process_re

; 2119 :         /* the first operand
; 2120 :          * r/m is treated as a 'reg' field */
; 2121 :         CodeInfo->rm_byte |= MOD_11;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	or	eax, 192				; 000000c0H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+104], al

; 2122 : #if AMD64_SUPPORT
; 2123 :         CodeInfo->prefix.rex |= (regno & 8 ) >> 3; /* set REX_B */

	mov	eax, DWORD PTR regno$[rsp]
	and	eax, 8
	sar	eax, 3
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+8]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+8], al

; 2124 :         regno &= BIT_012;

	mov	eax, DWORD PTR regno$[rsp]
	and	eax, 7
	mov	DWORD PTR regno$[rsp], eax

; 2125 : #endif
; 2126 :         /* fill the r/m field */
; 2127 :         CodeInfo->rm_byte |= regno;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	or	eax, DWORD PTR regno$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+104], al

; 2128 :     } else {

	jmp	$LN40@process_re
$LN39@process_re:

; 2129 :         /* the second operand
; 2130 :          * XCHG can use short form if op1 is AX/EAX/RAX */
; 2131 :         if( ( CodeInfo->token == T_XCHG ) && ( CodeInfo->opnd[OPND1].type & OP_A ) &&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 666			; 0000029aH
	jne	SHORT $LN41@process_re
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $LN41@process_re
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN41@process_re

; 2132 :              ( 0 == (CodeInfo->opnd[OPND1].type & OP_R8 ) ) ) {
; 2133 : #if AMD64_SUPPORT
; 2134 :             CodeInfo->prefix.rex |= (regno & 8 ) >> 3; /* set REX_B */

	mov	eax, DWORD PTR regno$[rsp]
	and	eax, 8
	sar	eax, 3
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+8]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+8], al

; 2135 :             regno &= BIT_012;

	mov	eax, DWORD PTR regno$[rsp]
	and	eax, 7
	mov	DWORD PTR regno$[rsp], eax

; 2136 : #endif
; 2137 :             CodeInfo->rm_byte = ( CodeInfo->rm_byte & BIT_67 ) | regno;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	and	eax, 192				; 000000c0H
	or	eax, DWORD PTR regno$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+104], al

; 2138 :         } else {

	jmp	SHORT $LN42@process_re
$LN41@process_re:

; 2139 :             /* fill reg field with reg */
; 2140 : #if AMD64_SUPPORT
; 2141 :             CodeInfo->prefix.rex |= (regno & 8 ) >> 1; /* set REX_R */

	mov	eax, DWORD PTR regno$[rsp]
	and	eax, 8
	sar	eax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+8]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+8], al

; 2142 :             regno &= BIT_012;

	mov	eax, DWORD PTR regno$[rsp]
	and	eax, 7
	mov	DWORD PTR regno$[rsp], eax

; 2143 : #endif
; 2144 :             CodeInfo->rm_byte = ( CodeInfo->rm_byte & ~BIT_345 ) | ( regno << 3 );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	and	eax, -57				; ffffffffffffffc7H
	mov	ecx, DWORD PTR regno$[rsp]
	shl	ecx, 3
	or	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+104], al
$LN42@process_re:
$LN40@process_re:

; 2145 :         }
; 2146 :     }
; 2147 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@process_re:

; 2148 : }

	add	rsp, 72					; 00000048H
	ret	0
process_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
CodeInfo$ = 48
CurrOpnd$ = 56
opndx$ = 64
process_const PROC

; 1948 : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1949 : #if 0 /* v2.06: obsolete */
; 1950 :     /* hack for IMUL: compress the operands so there are 2 only */
; 1951 :     if( ( CodeInfo->token == T_IMUL ) &&
; 1952 :        ( CodeInfo->opnd_type[OPND1] & OP_R ) ) {
; 1953 :         if( CurrOpnd == OPND2 ) {
; 1954 : #if AMD64_SUPPORT
; 1955 :             CodeInfo->prefix.rex |= ((CodeInfo->prefix.rex & REX_B) ? REX_R : 0);
; 1956 : #endif
; 1957 :             CodeInfo->rm_byte = ( CodeInfo->rm_byte & ~BIT_345 )
; 1958 :                           | ( ( CodeInfo->rm_byte & BIT_012 ) << 3 );
; 1959 :         } else if( CurrOpnd == OPND3 ) {
; 1960 :             /* v2.04b: if op2 was assumed an immediate due to fwd ref,
; 1961 :              * change it back to a mem ref now.
; 1962 :              */
; 1963 :             if ( ( CodeInfo->opnd_type[OPND2] & OP_I ) &&
; 1964 :                 CodeInfo->InsFixup[OPND2] &&
; 1965 :                 CodeInfo->InsFixup[OPND2]->sym->state == SYM_UNDEFINED )
; 1966 :                 CodeInfo->opnd_type[OPND2] = OP_M;
; 1967 :             CodeInfo->opnd_type[OPND1] = CodeInfo->opnd_type[OPND2];
; 1968 :             CodeInfo->opnd_type[OPND2] = OP_NONE;
; 1969 :             CodeInfo->data[OPND1] = CodeInfo->data[OPND2];
; 1970 :             CodeInfo->data[OPND2] = 0;
; 1971 :             CodeInfo->InsFixup[OPND1] = CodeInfo->InsFixup[OPND2];
; 1972 :             CodeInfo->InsFixup[OPND2] = NULL;
; 1973 :             CurrOpnd = OPND2;
; 1974 :         }
; 1975 :     }
; 1976 : #endif
; 1977 :     /* v2.11: don't accept an empty string */
; 1978 :     if ( opndx->quoted_string && opndx->quoted_string->stringlen == 0 )

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN2@process_co
	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+16]
	cmp	DWORD PTR [rax+16], 0
	jne	SHORT $LN2@process_co

; 1979 :         return( EmitError( EMPTY_STRING ) );

	mov	ecx, 163				; 000000a3H
	call	EmitError
	jmp	SHORT $LN1@process_co
$LN2@process_co:

; 1980 : 
; 1981 :     /* optimization: skip <value> if it is 0 and instruction
; 1982 :      * is RET[W|D|N|F]. */
; 1983 :     /* v2.06: moved here and checked the opcode directly, so
; 1984 :      * RETD and RETW are also handled. */
; 1985 :     if ( ( ( CodeInfo->pinstr->opcode & 0xf7 ) == 0xc2 ) &&
; 1986 :         CurrOpnd == OPND1 && opndx->value == 0 ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax+12]
	and	eax, 247				; 000000f7H
	cmp	eax, 194				; 000000c2H
	jne	SHORT $LN3@process_co
	cmp	DWORD PTR CurrOpnd$[rsp], 0
	jne	SHORT $LN3@process_co
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN3@process_co

; 1987 :         //     (CodeInfo.token == T_RET ||
; 1988 :         //      CodeInfo.token == T_RETN ||
; 1989 :         //      CodeInfo.token == T_RETF)) {
; 1990 :         //if ( opndx.sym == NULL || opndx.sym->state == SYM_INTERNAL ) {
; 1991 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@process_co
$LN3@process_co:

; 1992 :     }
; 1993 :     return( idata_nofixup( CodeInfo, CurrOpnd, opndx ) );

	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	idata_nofixup
$LN1@process_co:

; 1994 : }

	add	rsp, 40					; 00000028H
	ret	0
process_const ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
tv219 = 32
p$1 = 40
tv75 = 48
tv81 = 56
CodeInfo$ = 80
CurrOpnd$ = 88
opndx$ = 96
process_address PROC

; 1805 : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1806 :     if( opndx->indirect ) {  /* indirect register operand or stack var */

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	je	$LN7@process_ad

; 1807 : 
; 1808 :         DebugMsg1(("process_address: INDIRECT, sym=%s mbr=%s ci.adrsiz=%u\n",

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN46@process_ad
	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv75[rsp], rax
	jmp	SHORT $LN47@process_ad
$LN46@process_ad:
	lea	rax, OFFSET FLAT:$SG12160
	mov	QWORD PTR tv75[rsp], rax
$LN47@process_ad:
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN48@process_ad
	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv81[rsp], rax
	jmp	SHORT $LN49@process_ad
$LN48@process_ad:
	lea	rax, OFFSET FLAT:$SG12161
	mov	QWORD PTR tv81[rsp], rax
$LN49@process_ad:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	mov	r9d, eax
	mov	r8, QWORD PTR tv75[rsp]
	mov	rdx, QWORD PTR tv81[rsp]
	lea	rcx, OFFSET FLAT:$SG12162
	call	DoDebugMsg1

; 1809 :                    opndx->sym ? opndx->sym->name : "NULL",
; 1810 :                    opndx->mbr ? opndx->mbr->name : "NULL",
; 1811 :                    CodeInfo->prefix.adrsiz ));
; 1812 :         /* if displacement doesn't fit in 32-bits:
; 1813 :          * Masm (both ML and ML64) just truncates.
; 1814 :          * HJWasm throws an error in 64bit mode and
; 1815 :          * warns (level 3) in the other modes.
; 1816 :          * todo: this check should also be done for direct addressing!
; 1817 :          */
; 1818 :         if ( opndx->hvalue && ( opndx->hvalue != -1 || opndx->value >= 0 ) ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN9@process_ad
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+4], -1
	jne	SHORT $LN10@process_ad
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax], 0
	jl	SHORT $LN9@process_ad
$LN10@process_ad:

; 1819 :             DebugMsg1(("process_address: displacement doesn't fit in 32 bits: %" I64_SPEC "X\n", opndx->value64 ));

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG12165
	call	DoDebugMsg1

; 1820 : #if AMD64_SUPPORT
; 1821 :             if ( ModuleInfo.Ofssize == USE64 ) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	SHORT $LN11@process_ad

; 1822 :                 return( EmitConstError( opndx ) );

	mov	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	$LN1@process_ad
$LN11@process_ad:

; 1823 :             }
; 1824 : #endif
; 1825 :             EmitWarn( 3, DISPLACEMENT_OUT_OF_RANGE, opndx->value64 );

	mov	rax, QWORD PTR opndx$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	edx, 54					; 00000036H
	mov	ecx, 3
	call	EmitWarn
$LN9@process_ad:

; 1826 :         }
; 1827 :         if( opndx->sym == NULL || opndx->sym->state == SYM_STACK ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN13@process_ad
	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+40], 5
	jne	SHORT $LN12@process_ad
$LN13@process_ad:

; 1828 :             return( memory_operand( CodeInfo, CurrOpnd, opndx, FALSE ) );

	xor	r9d, r9d
	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	memory_operand
	jmp	$LN1@process_ad
$LN12@process_ad:

; 1829 :         }

	jmp	$LN8@process_ad
$LN7@process_ad:

; 1830 :         /* do default processing */
; 1831 : 
; 1832 :     } else if( opndx->instr != EMPTY ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], -2
	je	$LN14@process_ad

; 1833 :         /* instr is OFFSET | LROFFSET | SEG | LOW | LOWWORD, ... */
; 1834 :         DebugMsg1(("process_address: instr=%s\n", GetResWName( opndx->instr, NULL ) ));

	xor	edx, edx
	mov	rax, QWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rax+56]
	call	GetResWName
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12171
	call	DoDebugMsg1

; 1835 :         if( opndx->sym == NULL ) { /* better to check opndx->type? */

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+80], 0
	jne	SHORT $LN16@process_ad

; 1836 :             return( idata_nofixup( CodeInfo, CurrOpnd, opndx ) );

	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	idata_nofixup
	jmp	$LN1@process_ad

; 1837 :         } else {

	jmp	SHORT $LN17@process_ad
$LN16@process_ad:

; 1838 :             /* allow "lea <reg>, [offset <sym>]" */
; 1839 :             if( CodeInfo->token == T_LEA && opndx->instr == T_OFFSET )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 634			; 0000027aH
	jne	SHORT $LN18@process_ad
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 241			; 000000f1H
	jne	SHORT $LN18@process_ad

; 1840 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );

	mov	r9b, 1
	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	memory_operand
	jmp	$LN1@process_ad
$LN18@process_ad:

; 1841 :             return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	idata_fixup
	jmp	$LN1@process_ad
$LN17@process_ad:

; 1842 :         }

	jmp	$LN15@process_ad
$LN14@process_ad:

; 1843 :     } else if( opndx->sym == NULL ) { /* direct operand without symbol */

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+80], 0
	jne	$LN19@process_ad

; 1844 :         DebugMsg1(("process_address: symbol=NULL\n" ));

	lea	rcx, OFFSET FLAT:$SG12177
	call	DoDebugMsg1

; 1845 :         if( opndx->override != NULL ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN21@process_ad

; 1846 :             /* direct absolute memory without symbol.
; 1847 :              DS:[0] won't create a fixup, but
; 1848 :              DGROUP:[0] will create one! */
; 1849 : #if AMD64_SUPPORT
; 1850 :             /* for 64bit, always create a fixup, since RIP-relative addressing is used
; 1851 :              * v2.11: don't create fixup in 64-bit.
; 1852 :              */
; 1853 :             //if ( opndx->override->token == T_REG && CodeInfo->Ofssize != USE64 )
; 1854 :             if ( opndx->override->token == T_REG || CodeInfo->Ofssize == USE64 )

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+48]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 2
	je	SHORT $LN25@process_ad
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	jne	SHORT $LN23@process_ad
$LN25@process_ad:

; 1855 : #else
; 1856 :             if ( opndx->override->token == T_REG )
; 1857 : #endif
; 1858 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, FALSE ) );

	xor	r9d, r9d
	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	memory_operand
	jmp	$LN1@process_ad
	jmp	SHORT $LN24@process_ad
$LN23@process_ad:

; 1859 :             else
; 1860 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );

	mov	r9b, 1
	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	memory_operand
	jmp	$LN1@process_ad
$LN24@process_ad:

; 1861 :         } else {

	jmp	SHORT $LN22@process_ad
$LN21@process_ad:

; 1862 :             return( idata_nofixup( CodeInfo, CurrOpnd, opndx ) );

	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	idata_nofixup
	jmp	$LN1@process_ad
$LN22@process_ad:

; 1863 :         }

	jmp	$LN20@process_ad
$LN19@process_ad:

; 1864 :     } else if( ( opndx->sym->state == SYM_UNDEFINED ) && !opndx->explicit ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+40], 0
	jne	$LN26@process_ad
	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	$LN26@process_ad

; 1865 :         DebugMsg1(("process_address: sym=SYM_UNDEFINED, name=%s, state=%X\n", opndx->sym->name, opndx->sym->state ));

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	r8d, DWORD PTR [rax+40]
	mov	rdx, QWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG12185
	call	DoDebugMsg1

; 1866 :         /* v2.04: unnecessary, the expression evaluator will have emitted an error already */
; 1867 :         //if( Parse_Pass != PASS_1 ) {
; 1868 :         //    EmitErr( SYMBOL_NOT_DEFINED, opndx->sym->name );
; 1869 :         //    return( ERROR );
; 1870 :         //}
; 1871 :         /* undefined symbol, it's not possible to determine
; 1872 :          * operand type and size currently. However, for backpatching
; 1873 :          * a fixup should be created.
; 1874 :          */
; 1875 :         /* assume a code label for branch instructions! */
; 1876 :         if( IS_ANY_BRANCH( CodeInfo->token ) )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 455			; 000001c7H
	jl	SHORT $LN28@process_ad
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 504			; 000001f8H
	jg	SHORT $LN28@process_ad

; 1877 :             return( process_branch( CodeInfo, CurrOpnd, opndx ) );

	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	process_branch
	jmp	$LN1@process_ad
$LN28@process_ad:

; 1878 : 
; 1879 :         switch( CodeInfo->token ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv219[rsp], eax
	cmp	DWORD PTR tv219[rsp], 565		; 00000235H
	je	SHORT $LN29@process_ad
	cmp	DWORD PTR tv219[rsp], 601		; 00000259H
	je	SHORT $LN29@process_ad
	cmp	DWORD PTR tv219[rsp], 603		; 0000025bH
	je	SHORT $LN29@process_ad
	jmp	SHORT $LN31@process_ad
$LN29@process_ad:

; 1880 :         case T_PUSH:
; 1881 :         case T_PUSHW:
; 1882 :         case T_PUSHD:
; 1883 :             /* v2.0: don't assume immediate operand if cpu is 8086 */
; 1884 :             if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) > P_86 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	test	eax, eax
	jle	SHORT $LN30@process_ad

; 1885 :                 //return( idata_nofixup( CodeInfo, opndx ) ); /* v1.96: changed */
; 1886 :                 return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	idata_fixup
	jmp	$LN1@process_ad
$LN30@process_ad:

; 1887 :             }
; 1888 :             break;

	jmp	$LN2@process_ad
$LN31@process_ad:

; 1889 :         default:
; 1890 :             /* v2.04: if operand is the second argument (and the first is NOT
; 1891 :              * a segment register!), scan the
; 1892 :              * instruction table if the instruction allows an immediate!
; 1893 :              * If so, assume the undefined symbol is a constant.
; 1894 :              */
; 1895 :             if ( CurrOpnd == OPND2 && (( CodeInfo->opnd[OPND1].type & OP_SR ) == 0 ) ) {

	cmp	DWORD PTR CurrOpnd$[rsp], 1
	jne	$LN32@process_ad
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 24576				; 00006000H
	test	eax, eax
	jne	SHORT $LN32@process_ad

; 1896 :                 const struct instr_item  *p = CodeInfo->pinstr;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR p$1[rsp], rax
$LN6@process_ad:

; 1897 :                 do {
; 1898 :                     if ( opnd_clstab[p->opclsidx].opnd_type[OPND2] & OP_I ) {

	mov	rax, QWORD PTR p$1[rsp]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	eax, DWORD PTR [rax+rcx]
	and	eax, 917504				; 000e0000H
	test	eax, eax
	je	SHORT $LN33@process_ad

; 1899 :                         return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	idata_fixup
	jmp	$LN1@process_ad
$LN33@process_ad:

; 1900 :                     }
; 1901 :                     p++;

	mov	rax, QWORD PTR p$1[rsp]
	add	rax, 14
	mov	QWORD PTR p$1[rsp], rax

; 1902 :                 } while ( p->first == FALSE );

	mov	rax, QWORD PTR p$1[rsp]
	movzx	eax, BYTE PTR [rax+4]
	test	eax, eax
	je	SHORT $LN6@process_ad
$LN32@process_ad:

; 1903 :             }
; 1904 :             /* v2.10: if current operand is the third argument, always assume an immediate */
; 1905 :             if ( CurrOpnd == OPND3 )

	cmp	DWORD PTR CurrOpnd$[rsp], 2
	jne	SHORT $LN34@process_ad

; 1906 :                 return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	idata_fixup
	jmp	$LN1@process_ad
$LN34@process_ad:
$LN2@process_ad:

; 1907 :         }
; 1908 :         /* do default processing */
; 1909 : 
; 1910 :     } else if( ( opndx->sym->state == SYM_SEG ) ||

	jmp	$LN27@process_ad
$LN26@process_ad:
	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+40], 3
	je	SHORT $LN37@process_ad
	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+40], 4
	jne	SHORT $LN35@process_ad
$LN37@process_ad:

; 1911 :                ( opndx->sym->state == SYM_GRP ) ) {
; 1912 :         DebugMsg1(("process_address: sym->state=SEG/GROUP\n"));

	lea	rcx, OFFSET FLAT:$SG12196
	call	DoDebugMsg1

; 1913 :         /* SEGMENT and GROUP symbol is converted to SEG symbol
; 1914 :          * for next processing */
; 1915 :         opndx->instr = T_SEG;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	DWORD PTR [rax+56], 244			; 000000f4H

; 1916 :         return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	idata_fixup
	jmp	$LN1@process_ad

; 1917 :     } else {

	jmp	$LN36@process_ad
$LN35@process_ad:

; 1918 :         DebugMsg1(("process_address direct, sym=%s sym.memtype=%X opndx.memtype=%X\n", opndx->sym->name, opndx->sym->mem_type, opndx->mem_type ));

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	rdx, QWORD PTR opndx$[rsp]
	mov	r9d, DWORD PTR [rdx+64]
	mov	r8d, DWORD PTR [rax+44]
	mov	rdx, QWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG12197
	call	DoDebugMsg1

; 1919 : 
; 1920 :         /* symbol external, but absolute? */
; 1921 :         if( opndx->is_abs ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $LN38@process_ad

; 1922 :             return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	idata_fixup
	jmp	$LN1@process_ad
$LN38@process_ad:

; 1923 :         }
; 1924 : 
; 1925 :         /* CODE location is converted to OFFSET symbol */
; 1926 :         if ( opndx->mem_type == MT_NEAR || opndx->mem_type == MT_FAR ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+64], 129			; 00000081H
	je	SHORT $LN40@process_ad
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+64], 130			; 00000082H
	jne	SHORT $LN39@process_ad
$LN40@process_ad:

; 1927 :             if( CodeInfo->token == T_LEA ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 634			; 0000027aH
	jne	SHORT $LN41@process_ad

; 1928 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );

	mov	r9b, 1
	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	memory_operand
	jmp	SHORT $LN1@process_ad
	jmp	SHORT $LN42@process_ad
$LN41@process_ad:

; 1929 :             //} else if( opndx->sym == &symPC ) {
; 1930 :             //    return( idata_fixup( CodeInfo, opndx ) );
; 1931 :             } else if( opndx->mbr != NULL ) { /* structure field? */

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN43@process_ad

; 1932 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );

	mov	r9b, 1
	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	memory_operand
	jmp	SHORT $LN1@process_ad

; 1933 :             } else {

	jmp	SHORT $LN44@process_ad
$LN43@process_ad:

; 1934 :                 return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	idata_fixup
	jmp	SHORT $LN1@process_ad
$LN44@process_ad:
$LN42@process_ad:
$LN39@process_ad:
$LN36@process_ad:
$LN27@process_ad:
$LN20@process_ad:
$LN15@process_ad:
$LN8@process_ad:

; 1935 :             }
; 1936 :         }
; 1937 :     }
; 1938 :     /* default processing: memory with fixup */
; 1939 :     return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );

	mov	r9b, 1
	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	memory_operand
$LN1@process_ad:

; 1940 : }

	add	rsp, 72					; 00000048H
	ret	0
process_address ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
Ofssize$ = 64
ss$ = 65
fixup_type$ = 68
index$ = 72
base$ = 76
tv495 = 80
tv331 = 84
mem_type$1 = 88
j$ = 92
sym$ = 96
tv194 = 104
tv213 = 108
tv214 = 112
tv276 = 116
tv348 = 120
tv353 = 124
tv529 = 128
tv528 = 132
tv531 = 136
tv550 = 140
tv564 = 144
tv590 = 148
tv589 = 152
tv592 = 156
size$2 = 160
tv81 = 168
CodeInfo$ = 192
CurrOpnd$ = 200
opndx$ = 208
with_fixup$ = 216
memory_operand PROC

; 1430 : {

	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 1431 :     char                ss = SCALE_FACTOR_1;

	mov	BYTE PTR ss$[rsp], 0

; 1432 :     int                 index;
; 1433 :     int                 base;
; 1434 :     int                 j;
; 1435 :     struct asym         *sym;
; 1436 :     uint_8              Ofssize;
; 1437 :     enum fixup_types    fixup_type;
; 1438 : 
; 1439 :     DebugMsg1(("memory_operand(opndx.value=%X / sym=%s / memtype=%Xh, with_fixup=%u) enter, [CodeInfo->memtype=%Xh, Ofssize=%u, adrsiz=%u]\n",

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN101@memory_ope
	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv81[rsp], rax
	jmp	SHORT $LN102@memory_ope
$LN101@memory_ope:
	lea	rax, OFFSET FLAT:$SG12035
	mov	QWORD PTR tv81[rsp], rax
$LN102@memory_ope:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+106]
	movzx	edx, BYTE PTR with_fixup$[rsp]
	mov	DWORD PTR [rsp+56], eax
	mov	DWORD PTR [rsp+48], ecx
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], edx
	mov	rax, QWORD PTR opndx$[rsp]
	mov	r9d, DWORD PTR [rax+64]
	mov	r8, QWORD PTR tv81[rsp]
	mov	rax, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG12036
	call	DoDebugMsg1

; 1440 :                opndx->value, opndx->sym ? opndx->sym->name : "NULL", opndx->mem_type, with_fixup, CodeInfo->mem_type, CodeInfo->Ofssize, CodeInfo->prefix.adrsiz ));
; 1441 : 
; 1442 :     /* v211: use full 64-bit value */
; 1443 :     //CodeInfo->opnd[CurrOpnd].data = opndx->value;
; 1444 :     CodeInfo->opnd[CurrOpnd].data64 = opndx->value64;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rdx, QWORD PTR opndx$[rsp]
	mov	rdx, QWORD PTR [rdx]
	mov	QWORD PTR [rcx+rax+40], rdx

; 1445 :     CodeInfo->opnd[CurrOpnd].type = OP_M;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], -1887436800	; ffffffff8f800000H

; 1446 : 
; 1447 :     sym = opndx->sym;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym$[rsp], rax

; 1448 : 
; 1449 :     segm_override( opndx, CodeInfo );

	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR opndx$[rsp]
	call	segm_override

; 1450 : 
; 1451 :     /* change pointer types ( MT_NEAR, MT_FAR, MT_PTR */
; 1452 :     /* v2.04a: should not be called if OFFSET was used */
; 1453 :     //if ( opndx->mem_type == MT_PTR ) /* this was before v2.04 */
; 1454 :     //if ( ( opndx->mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS )
; 1455 :     /* v2.05: change reverted */
; 1456 :     //if ( ( opndx->mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS && opndx->instr == EMPTY )
; 1457 :     if ( opndx->mem_type == MT_PTR )

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+64], 195			; 000000c3H
	jne	SHORT $LN10@memory_ope

; 1458 :         SetPtrMemtype( CodeInfo, opndx );

	mov	rdx, QWORD PTR opndx$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	SetPtrMemtype
	jmp	$LN11@memory_ope
$LN10@memory_ope:

; 1459 :     else if ( ( opndx->mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN12@memory_ope

; 1460 :         int size;
; 1461 :         if ( opndx->Ofssize == USE_EMPTY && sym )

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	cmp	eax, 254				; 000000feH
	jne	SHORT $LN13@memory_ope
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN13@memory_ope

; 1462 :             opndx->Ofssize = GetSymOfssize( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSymOfssize
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	BYTE PTR [rcx+69], al
$LN13@memory_ope:

; 1463 :         /* v2.09: use opndx->type ( for MT_PROC ) */
; 1464 :         //size = SizeFromMemtype( opndx->mem_type, opndx->Ofssize, NULL );
; 1465 :         size = SizeFromMemtype( opndx->mem_type, opndx->Ofssize, opndx->type );

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	r8, QWORD PTR [rcx+96]
	mov	edx, eax
	mov	rax, QWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rax+64]
	call	SizeFromMemtype
	mov	DWORD PTR size$2[rsp], eax

; 1466 :         MemtypeFromSize( size, &opndx->mem_type );

	mov	rax, QWORD PTR opndx$[rsp]
	add	rax, 64					; 00000040H
	mov	rdx, rax
	mov	ecx, DWORD PTR size$2[rsp]
	call	MemtypeFromSize
$LN12@memory_ope:
$LN11@memory_ope:

; 1467 :     }
; 1468 : 
; 1469 :     Set_Memtype( CodeInfo, opndx->mem_type );

	mov	rax, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR [rax+64]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	Set_Memtype

; 1470 :     if( opndx->mbr != NULL ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	$LN14@memory_ope

; 1471 :         /* if the struct field is just another struct, use it's total size
; 1472 :          * to set CodeInfo->mem_type.
; 1473 :          */
; 1474 :         //if ( opndx->mbr->mem_type == MT_TYPE ) {
; 1475 :         /* v2: don't overwrite opndx->mem_type,
; 1476 :          *    testcase: cmp (dword ptr <struct_field>), 0
; 1477 :          */
; 1478 :         if ( opndx->mbr->mem_type == MT_TYPE && opndx->mem_type == MT_EMPTY ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+88]
	cmp	DWORD PTR [rax+44], 196			; 000000c4H
	jne	$LN15@memory_ope
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	jne	$LN15@memory_ope

; 1479 :             enum memtype mem_type;
; 1480 :             DebugMsg1(("memory_operand: mbr %s has mem_type MT_TYPE, total_size=%u\n", opndx->mbr->name, opndx->mbr->total_size ));

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	r8d, DWORD PTR [rax+64]
	mov	rdx, QWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG12043
	call	DoDebugMsg1

; 1481 : #if AVXSUPP
; 1482 :             if (CodeInfo->token == T_VMOVSS){       //MemtypeFromSize returns OP_M128

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1945		; 00000799H
	jne	SHORT $LN16@memory_ope

; 1483 :               mem_type = MT_DWORD;                  //but we need MT_DWORD ;habran

	mov	DWORD PTR mem_type$1[rsp], 3

; 1484 :               Set_Memtype(CodeInfo, mem_type);

	mov	edx, DWORD PTR mem_type$1[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	Set_Memtype

; 1485 :          }

	jmp	SHORT $LN17@memory_ope
$LN16@memory_ope:

; 1486 :         else
; 1487 : #endif
; 1488 :             if ( MemtypeFromSize( opndx->mbr->total_size, &mem_type ) == NOT_ERROR )

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+88]
	lea	rdx, QWORD PTR mem_type$1[rsp]
	mov	ecx, DWORD PTR [rax+64]
	call	MemtypeFromSize
	test	eax, eax
	jne	SHORT $LN18@memory_ope

; 1489 :                 Set_Memtype( CodeInfo, mem_type );

	mov	edx, DWORD PTR mem_type$1[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	Set_Memtype
$LN18@memory_ope:
$LN17@memory_ope:
$LN15@memory_ope:

; 1490 :         }
; 1491 :         //else  /* v2: obsolete */
; 1492 :         //    Set_Memtype( CodeInfo, opndx->mbr->mem_type );
; 1493 :         /* v2.06b: tell codegen that the member is a forward ref */
; 1494 :         if ( opndx->mbr->state == SYM_UNDEFINED )

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+88]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN19@memory_ope

; 1495 :             CodeInfo->undef_sym = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al
$LN19@memory_ope:
$LN14@memory_ope:

; 1496 :     }
; 1497 : 
; 1498 :     /* instruction-specific handling */
; 1499 :     switch ( CodeInfo->token ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv194[rsp], eax
	cmp	DWORD PTR tv194[rsp], 455		; 000001c7H
	jl	$LN2@memory_ope
	cmp	DWORD PTR tv194[rsp], 456		; 000001c8H
	jle	SHORT $LN20@memory_ope
	jmp	$LN2@memory_ope
$LN20@memory_ope:

; 1500 :     case T_JMP:
; 1501 :     case T_CALL:
; 1502 :         /* the 2 branch instructions are peculiar because they
; 1503 :          * will work with an unsized label.
; 1504 :          */
; 1505 :         /* v1.95: convert MT_NEAR/MT_FAR and display error if no type.
; 1506 :          * For memory operands, expressions of type MT_NEAR/MT_FAR are
; 1507 :          * call [bx+<code_label>]
; 1508 :          */
; 1509 :         if ( CodeInfo->mem_type == MT_EMPTY ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	$LN21@memory_ope

; 1510 :             /* with -Zm, no size needed for indirect CALL/JMP */
; 1511 :             if ( ModuleInfo.m510 == FALSE &&

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 6
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN22@memory_ope
	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN22@memory_ope
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+80], 0
	jne	SHORT $LN22@memory_ope

; 1512 :                 ( Parse_Pass > PASS_1 && opndx->sym == NULL ) ) {
; 1513 :                 DebugMsg1(("memory_operand, JMP/CALL: CodeInfo->memtype=empty, instruction operand must have size\n" ));

	lea	rcx, OFFSET FLAT:$SG12051
	call	DoDebugMsg1

; 1514 :                 return( EmitError( INSTRUCTION_OPERAND_MUST_HAVE_SIZE ) );

	mov	ecx, 182				; 000000b6H
	call	EmitError
	jmp	$LN1@memory_ope
$LN22@memory_ope:

; 1515 :             }
; 1516 : #if AMD64_SUPPORT
; 1517 :             opndx->mem_type = (CodeInfo->Ofssize == USE64) ? MT_QWORD : (CodeInfo->Ofssize == USE32) ? MT_DWORD : MT_WORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	jne	SHORT $LN105@memory_ope
	mov	DWORD PTR tv214[rsp], 7
	jmp	SHORT $LN106@memory_ope
$LN105@memory_ope:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 1
	jne	SHORT $LN103@memory_ope
	mov	DWORD PTR tv213[rsp], 3
	jmp	SHORT $LN104@memory_ope
$LN103@memory_ope:
	mov	DWORD PTR tv213[rsp], 1
$LN104@memory_ope:
	mov	eax, DWORD PTR tv213[rsp]
	mov	DWORD PTR tv214[rsp], eax
$LN106@memory_ope:
	mov	rax, QWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR tv214[rsp]
	mov	DWORD PTR [rax+64], ecx

; 1518 : #else
; 1519 :             opndx->mem_type = (CodeInfo->Ofssize == USE32) ? MT_DWORD : MT_WORD;
; 1520 : #endif
; 1521 :             Set_Memtype( CodeInfo, opndx->mem_type );

	mov	rax, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR [rax+64]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	Set_Memtype

; 1522 :             DebugMsg1(("memory_operand, JMP/CALL: CodeInfo->memtype set to %Xh\n", CodeInfo->mem_type ));

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rax+28]
	lea	rcx, OFFSET FLAT:$SG12052
	call	DoDebugMsg1
$LN21@memory_ope:

; 1523 :         }
; 1524 :         j = SizeFromMemtype( CodeInfo->mem_type, CodeInfo->Ofssize, NULL );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	xor	r8d, r8d
	mov	edx, eax
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR [rax+28]
	call	SizeFromMemtype
	mov	DWORD PTR j$[rsp], eax

; 1525 :         if ( ( j == 1 || j > 6 )
; 1526 : #if AMD64_SUPPORT
; 1527 :             && ( CodeInfo->Ofssize != USE64 )

	cmp	DWORD PTR j$[rsp], 1
	je	SHORT $LN24@memory_ope
	cmp	DWORD PTR j$[rsp], 6
	jle	SHORT $LN23@memory_ope
$LN24@memory_ope:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	je	SHORT $LN23@memory_ope

; 1528 : #endif
; 1529 :         ) {
; 1530 :             /* CALL/JMP possible for WORD/DWORD/FWORD memory operands only */
; 1531 :             DebugMsg1(("memory_operand: invalid operand, size=%u\n", j ));

	mov	edx, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:$SG12055
	call	DoDebugMsg1

; 1532 :             return( EmitError( INVALID_OPERAND_SIZE ) );

	mov	ecx, 71					; 00000047H
	call	EmitError
	jmp	$LN1@memory_ope
$LN23@memory_ope:

; 1533 :         }
; 1534 : 
; 1535 :         if( opndx->mem_type == MT_FAR || CodeInfo->mem_type == MT_FWORD ||
; 1536 : #if AMD64_SUPPORT
; 1537 :            ( CodeInfo->mem_type == MT_TBYTE && CodeInfo->Ofssize == USE64 ) ||

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+64], 130			; 00000082H
	je	SHORT $LN26@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 5
	je	SHORT $LN26@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 9
	jne	SHORT $LN27@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	je	SHORT $LN26@memory_ope
$LN27@memory_ope:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 3
	jne	SHORT $LN25@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jne	SHORT $LN29@memory_ope
	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	cmp	eax, 1
	jne	SHORT $LN28@memory_ope
$LN29@memory_ope:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 1
	jne	SHORT $LN25@memory_ope
	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	test	eax, eax
	jne	SHORT $LN25@memory_ope
$LN28@memory_ope:
$LN26@memory_ope:

; 1538 : #endif
; 1539 :             ( CodeInfo->mem_type == MT_DWORD &&
; 1540 :               (( CodeInfo->Ofssize == USE16 && opndx->Ofssize != USE32 ) ||
; 1541 :                ( CodeInfo->Ofssize == USE32 && opndx->Ofssize == USE16 )))) {
; 1542 :             CodeInfo->isfar = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 4
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al
$LN25@memory_ope:

; 1543 :         }
; 1544 :         DebugMsg1(("memory_operand: JMP/CALL, CodeInfo->far=%u\n", CodeInfo->isfar ));

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12061
	call	DoDebugMsg1
$LN2@memory_ope:

; 1545 :         break;
; 1546 :     }
; 1547 : 
; 1548 :     if ( ( CodeInfo->mem_type & MT_SPECIAL) == 0 ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	$LN30@memory_ope

; 1549 :         switch ( CodeInfo->mem_type & MT_SIZE_MASK ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 31
	mov	DWORD PTR tv276[rsp], eax
	cmp	DWORD PTR tv276[rsp], 63		; 0000003fH
	ja	$LN41@memory_ope
	movsxd	rax, DWORD PTR tv276[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN127@memory_ope[rcx+rax]
	mov	eax, DWORD PTR $LN128@memory_ope[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN32@memory_ope:

; 1550 :             /* size is encoded 0-based */
; 1551 :         case  0:  CodeInfo->opnd[CurrOpnd].type = OP_M08;  break;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 8388608		; 00800000H
	jmp	$LN4@memory_ope
$LN33@memory_ope:

; 1552 :         case  1:  CodeInfo->opnd[CurrOpnd].type = OP_M16;  break;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 16777216	; 01000000H
	jmp	$LN4@memory_ope
$LN34@memory_ope:

; 1553 :         case  3:  CodeInfo->opnd[CurrOpnd].type = OP_M32;  break;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 33554432	; 02000000H
	jmp	$LN4@memory_ope
$LN35@memory_ope:

; 1554 :         case  5:  CodeInfo->opnd[CurrOpnd].type = OP_M48;  break;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 1073741824	; 40000000H
	jmp	$LN4@memory_ope
$LN36@memory_ope:

; 1555 :         case  7:  CodeInfo->opnd[CurrOpnd].type = OP_M64;  break;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 67108864	; 04000000H
	jmp	$LN4@memory_ope
$LN37@memory_ope:

; 1556 :         case  9:  CodeInfo->opnd[CurrOpnd].type = OP_M80;  break;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], -2147483648	; ffffffff80000000H
	jmp	SHORT $LN4@memory_ope
$LN38@memory_ope:

; 1557 :         case 15:  CodeInfo->opnd[CurrOpnd].type = OP_M128; break;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 134217728	; 08000000H
	jmp	SHORT $LN4@memory_ope
$LN39@memory_ope:

; 1558 : #if AVXSUPP
; 1559 :         case 31:  CodeInfo->opnd[CurrOpnd].type = OP_M256; break;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 268435456	; 10000000H
	jmp	SHORT $LN4@memory_ope
$LN40@memory_ope:

; 1560 :         case 63:  CodeInfo->opnd[CurrOpnd].type = OP_M512; break;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 536870912	; 20000000H
	jmp	SHORT $LN4@memory_ope
$LN41@memory_ope:

; 1561 : #endif
; 1562 : #ifdef DEBUG_OUT
; 1563 :         default:
; 1564 :             DebugMsg1(("memory_operand: unexpected mem_type=%X\n", CodeInfo->mem_type ));

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rax+28]
	lea	rcx, OFFSET FLAT:$SG12074
	call	DoDebugMsg1

; 1565 :             /**/myassert( 0 );

	mov	edx, 1565				; 0000061dH
	lea	rcx, OFFSET FLAT:$SG12075
	call	InternalError
$LN4@memory_ope:

; 1566 : #endif
; 1567 :         }
; 1568 : #if 0 /* v2.06: the wide flag isn't set for memory operands currently, */
; 1569 :         if ( CodeInfo->opnd_type[CurrOpnd] & ( OP_M16 | OP_M32 | OP_M64 ) )
; 1570 :             CodeInfo->iswide = 1;
; 1571 : #endif
; 1572 :     } else if ( CodeInfo->mem_type == MT_EMPTY ) {

	jmp	$LN31@memory_ope
$LN30@memory_ope:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	SHORT $LN42@memory_ope

; 1573 :         /* v2.05: added */
; 1574 :         switch ( CodeInfo->token ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv331[rsp], eax
	cmp	DWORD PTR tv331[rsp], 599		; 00000257H
	jl	SHORT $LN6@memory_ope
	cmp	DWORD PTR tv331[rsp], 600		; 00000258H
	jle	SHORT $LN43@memory_ope
	cmp	DWORD PTR tv331[rsp], 600		; 00000258H
	jle	SHORT $LN6@memory_ope
	cmp	DWORD PTR tv331[rsp], 602		; 0000025aH
	jle	SHORT $LN45@memory_ope
	jmp	SHORT $LN6@memory_ope
$LN43@memory_ope:

; 1575 :         case T_INC:
; 1576 :         case T_DEC:
; 1577 :             /* hjwasm v1.94-v2.04 accepted unsized operand for INC/DEC */
; 1578 :             if ( opndx->sym == NULL ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+80], 0
	jne	SHORT $LN44@memory_ope

; 1579 :                 return( EmitError( INSTRUCTION_OPERAND_MUST_HAVE_SIZE ) );

	mov	ecx, 182				; 000000b6H
	call	EmitError
	jmp	$LN1@memory_ope
$LN44@memory_ope:

; 1580 :             }
; 1581 :             break;

	jmp	SHORT $LN6@memory_ope
$LN45@memory_ope:

; 1582 :         case T_PUSH:
; 1583 :         case T_POP:
; 1584 :             if ( opndx->mem_type == MT_TYPE ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+64], 196			; 000000c4H
	jne	SHORT $LN46@memory_ope

; 1585 :                 return( EmitError( INVALID_INSTRUCTION_OPERANDS ) );

	mov	ecx, 49					; 00000031H
	call	EmitError
	jmp	$LN1@memory_ope
$LN46@memory_ope:
$LN6@memory_ope:
$LN42@memory_ope:
$LN31@memory_ope:

; 1586 :             }
; 1587 :             break;
; 1588 :         }
; 1589 :     }
; 1590 : 
; 1591 :     base = ( opndx->base_reg ? opndx->base_reg->tokval : EMPTY );

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN107@memory_ope
	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv348[rsp], eax
	jmp	SHORT $LN108@memory_ope
$LN107@memory_ope:
	mov	DWORD PTR tv348[rsp], -2		; fffffffeH
$LN108@memory_ope:
	mov	eax, DWORD PTR tv348[rsp]
	mov	DWORD PTR base$[rsp], eax

; 1592 :     index = ( opndx->idx_reg ? opndx->idx_reg->tokval : EMPTY );

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+32], 0
	je	SHORT $LN109@memory_ope
	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv353[rsp], eax
	jmp	SHORT $LN110@memory_ope
$LN109@memory_ope:
	mov	DWORD PTR tv353[rsp], -2		; fffffffeH
$LN110@memory_ope:
	mov	eax, DWORD PTR tv353[rsp]
	mov	DWORD PTR index$[rsp], eax

; 1593 :     CodeInfo->indexreg = GetRegNo( index );

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR [rdx+112], al

; 1594 :     CodeInfo->basereg = GetRegNo( base );

	movsxd	rax, DWORD PTR base$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR [rdx+113], al

; 1595 :     /* use base + index from here - don't use opndx-> base_reg/idx_reg! */
; 1596 : 
; 1597 : #if 0 /* v2.10: moved to expreval.c */
; 1598 :     if ( sym && sym->state == SYM_STACK ) {
; 1599 :         if( base != EMPTY ) {
; 1600 :             if( index != EMPTY ) {
; 1601 :                 /* no free index register */
; 1602 :                 return( EmitError( MULTIPLE_INDEX_REGISTERS_NOT_ALLOWED ) );
; 1603 :             } else {
; 1604 :                 index = base;
; 1605 :             }
; 1606 :         }
; 1607 :         base = basereg[CodeInfo->Ofssize];
; 1608 :     }
; 1609 : #endif
; 1610 : 
; 1611 :     /* check for base registers */
; 1612 : 
; 1613 :     if ( base != EMPTY ) {

	cmp	DWORD PTR base$[rsp], -2
	je	$LN47@memory_ope

; 1614 :         if ( ( ( GetValueSp( base ) & OP_R32) && CodeInfo->Ofssize == USE32 ) ||
; 1615 : #if AMD64_SUPPORT
; 1616 :             ( ( GetValueSp( base ) & OP_R64) && CodeInfo->Ofssize == USE64 ) ||

	movsxd	rax, DWORD PTR base$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN51@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 1
	je	SHORT $LN50@memory_ope
$LN51@memory_ope:
	movsxd	rax, DWORD PTR base$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN52@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	je	SHORT $LN50@memory_ope
$LN52@memory_ope:
	movsxd	rax, DWORD PTR base$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN48@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jne	SHORT $LN48@memory_ope
$LN50@memory_ope:

; 1617 : #endif
; 1618 :             ( ( GetValueSp( base ) & OP_R16) && CodeInfo->Ofssize == USE16 ) )
; 1619 :             CodeInfo->prefix.adrsiz = FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
	jmp	SHORT $LN49@memory_ope
$LN48@memory_ope:

; 1620 :         else {
; 1621 :             CodeInfo->prefix.adrsiz = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	or	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 1622 : #if AMD64_SUPPORT
; 1623 :             /* 16bit addressing modes don't exist in long mode */
; 1624 :             if ( ( GetValueSp( base ) & OP_R16) && CodeInfo->Ofssize == USE64 ) {

	movsxd	rax, DWORD PTR base$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN53@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	jne	SHORT $LN53@memory_ope

; 1625 :                 return( EmitError( INVALID_ADDRESSING_MODE_WITH_CURRENT_CPU_SETTING ) );

	mov	ecx, 31
	call	EmitError
	jmp	$LN1@memory_ope
$LN53@memory_ope:
$LN49@memory_ope:
$LN47@memory_ope:

; 1626 :             }
; 1627 : #endif
; 1628 :         }
; 1629 :     }
; 1630 : 
; 1631 :     /* check for index registers */
; 1632 : 
; 1633 :     if( index != EMPTY ) {

	cmp	DWORD PTR index$[rsp], -2
	je	$LN54@memory_ope

; 1634 :         if ( ( ( GetValueSp( index ) & OP_R32) && CodeInfo->Ofssize == USE32 ) ||
; 1635 : #if AMD64_SUPPORT
; 1636 :             ( ( GetValueSp( index ) & OP_R64) && CodeInfo->Ofssize == USE64 ) ||

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN58@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 1
	je	SHORT $LN57@memory_ope
$LN58@memory_ope:
	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN59@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	je	SHORT $LN57@memory_ope
$LN59@memory_ope:
	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN55@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jne	SHORT $LN55@memory_ope
$LN57@memory_ope:

; 1637 : #endif
; 1638 :             ( ( GetValueSp( index ) & OP_R16) && CodeInfo->Ofssize == USE16 ) ) {
; 1639 :             CodeInfo->prefix.adrsiz = FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 1640 :         } else {

	jmp	SHORT $LN56@memory_ope
$LN55@memory_ope:

; 1641 :             CodeInfo->prefix.adrsiz = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	or	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN56@memory_ope:

; 1642 :         }
; 1643 : 
; 1644 :         /* v2.10: register swapping has been moved to expreval.c, index_connect().
; 1645 :          * what has remained here is the check if R/ESP is used as index reg.
; 1646 :          */
; 1647 : 		if ((GetRegNo(index) == 4)

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	cmp	eax, 4
	jne	$LN60@memory_ope

; 1648 : #if 0
; 1649 : 			&& (GetResWName(index, NULL) <= T_RBP)
; 1650 : #endif
; 1651 : 			) { /* [E|R]SP? */
; 1652 : 			
; 1653 : 				//if ( (GetRegNo( index ) == 4) && (GetResWName( index, NULL ) <= T_RBP )) { /* [E|R]SP? */ /* Removed in 2.13 in favour of above */
; 1654 : 
; 1655 :             DebugMsg(( "memory_operand: error, base regno=%u, index regno=%u, opnd.scale=%u\n", GetRegNo( base ), GetRegNo( index ), opndx->scale ));

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+68]
	movsxd	rcx, DWORD PTR index$[rsp]
	imul	rcx, rcx, 12
	lea	rdx, OFFSET FLAT:SpecialTable
	movzx	ecx, BYTE PTR [rdx+rcx+10]
	movsxd	rdx, DWORD PTR base$[rsp]
	imul	rdx, rdx, 12
	lea	r8, OFFSET FLAT:SpecialTable
	movzx	edx, BYTE PTR [r8+rdx+10]
	mov	r9d, eax
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:$SG12095
	call	DoDebugMsg

; 1656 :             //int tmp = index;
; 1657 :             if( opndx->scale ) { /* no scale must be set */

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+68]
	test	eax, eax
	je	SHORT $LN61@memory_ope

; 1658 :                 EmitErr( CANNOT_BE_USED_AS_INDEX_REGISTER, GetResWName( index, NULL ) );

	xor	edx, edx
	mov	ecx, DWORD PTR index$[rsp]
	call	GetResWName
	mov	rdx, rax
	mov	ecx, 37					; 00000025H
	call	EmitErr

; 1659 :                 //return( ERROR );
; 1660 :             } else {

	jmp	SHORT $LN62@memory_ope
$LN61@memory_ope:

; 1661 :             //if ( GetRegNo( base ) == 4 ) {
; 1662 :                 EmitErr( MULTIPLE_BASE_REGISTERS_NOT_ALLOWED );

	mov	ecx, 29
	call	EmitErr
$LN62@memory_ope:

; 1663 :                 //return( ERROR );
; 1664 :             }
; 1665 :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@memory_ope
$LN60@memory_ope:

; 1666 :             /* swap base and index */
; 1667 :             //index = base;
; 1668 :             //base = tmp;
; 1669 : #if 0
; 1670 :         } else if ( Options.masm_compat_gencode && opndx->scale == 0 && GetRegNo( base ) != 4 ) {
; 1671 :             /* v2.08: Masm 6+ swaps base and index, even if -Zm is set (Masm 5.1 does NOT swap) */
; 1672 :             int tmp = index;
; 1673 :             /* swap base and index */
; 1674 :             index = base;
; 1675 :             base = tmp;
; 1676 : #endif
; 1677 :         }
; 1678 : 
; 1679 :         /* 32/64 bit indirect addressing? */
; 1680 :         if( ( CodeInfo->Ofssize == USE16 && CodeInfo->prefix.adrsiz == 1 ) ||
; 1681 : #if AMD64_SUPPORT
; 1682 :            CodeInfo->Ofssize == USE64  ||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jne	SHORT $LN66@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	je	SHORT $LN65@memory_ope
$LN66@memory_ope:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	je	SHORT $LN65@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 1
	jne	$LN63@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN63@memory_ope
$LN65@memory_ope:

; 1683 : #endif
; 1684 :            ( CodeInfo->Ofssize == USE32 && CodeInfo->prefix.adrsiz == 0 ) ) {
; 1685 :             if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN67@memory_ope

; 1686 :                 /* scale, 0 or 1->00, 2->40, 4->80, 8->C0 */
; 1687 :                 switch( opndx->scale ) {

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+68]
	mov	BYTE PTR tv495[rsp], al
	cmp	BYTE PTR tv495[rsp], 0
	jb	SHORT $LN73@memory_ope
	cmp	BYTE PTR tv495[rsp], 1
	jbe	SHORT $LN69@memory_ope
	cmp	BYTE PTR tv495[rsp], 2
	je	SHORT $LN70@memory_ope
	cmp	BYTE PTR tv495[rsp], 4
	je	SHORT $LN71@memory_ope
	cmp	BYTE PTR tv495[rsp], 8
	je	SHORT $LN72@memory_ope
	jmp	SHORT $LN73@memory_ope
$LN69@memory_ope:

; 1688 :                 case 0:
; 1689 :                 case 1:  break; /* ss = 00 */

	jmp	SHORT $LN8@memory_ope
$LN70@memory_ope:

; 1690 :                 case 2: ss = SCALE_FACTOR_2; break; /* ss = 01 */

	mov	BYTE PTR ss$[rsp], 64			; 00000040H
	jmp	SHORT $LN8@memory_ope
$LN71@memory_ope:

; 1691 :                 case 4: ss = SCALE_FACTOR_4; break; /* ss = 10 */

	mov	BYTE PTR ss$[rsp], -128			; ffffffffffffff80H
	jmp	SHORT $LN8@memory_ope
$LN72@memory_ope:

; 1692 :                 case 8: ss = SCALE_FACTOR_8; break; /* ss = 11 */

	mov	BYTE PTR ss$[rsp], -64			; ffffffffffffffc0H
	jmp	SHORT $LN8@memory_ope
$LN73@memory_ope:

; 1693 :                 default: /* must be * 1, 2, 4 or 8 */
; 1694 :                     return( EmitError( SCALE_FACTOR_MUST_BE_1_2_4_OR_8 ) );

	mov	ecx, 36					; 00000024H
	call	EmitError
	jmp	$LN1@memory_ope
$LN8@memory_ope:

; 1695 :                 }
; 1696 :             } else {

	jmp	SHORT $LN68@memory_ope
$LN67@memory_ope:

; 1697 :                 /* 286 and down cannot use this memory mode */
; 1698 :                 return( EmitError( INVALID_ADDRESSING_MODE_WITH_CURRENT_CPU_SETTING ) );

	mov	ecx, 31
	call	EmitError
	jmp	$LN1@memory_ope
$LN68@memory_ope:

; 1699 :             }
; 1700 :         } else {

	jmp	SHORT $LN64@memory_ope
$LN63@memory_ope:

; 1701 :             /* v2.01: 16-bit addressing mode. No scale possible */
; 1702 :             if ( opndx->scale ) {

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+68]
	test	eax, eax
	je	SHORT $LN74@memory_ope

; 1703 :                 return( EmitError( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	EmitError
	jmp	$LN1@memory_ope
$LN74@memory_ope:
$LN64@memory_ope:
$LN54@memory_ope:

; 1704 :             }
; 1705 :         }
; 1706 :     }
; 1707 : 
; 1708 :     if( with_fixup ) {

	movzx	eax, BYTE PTR with_fixup$[rsp]
	test	eax, eax
	je	$LN75@memory_ope

; 1709 : 
; 1710 :         if( opndx->is_abs ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	$LN76@memory_ope

; 1711 :             Ofssize = IS_ADDR32( CodeInfo );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN115@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN113@memory_ope
	mov	DWORD PTR tv529[rsp], 1
	jmp	SHORT $LN114@memory_ope
$LN113@memory_ope:
	mov	DWORD PTR tv529[rsp], 0
$LN114@memory_ope:
	mov	eax, DWORD PTR tv529[rsp]
	mov	DWORD PTR tv531[rsp], eax
	jmp	SHORT $LN116@memory_ope
$LN115@memory_ope:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN111@memory_ope
	mov	DWORD PTR tv528[rsp], 1
	jmp	SHORT $LN112@memory_ope
$LN111@memory_ope:
	mov	DWORD PTR tv528[rsp], 0
$LN112@memory_ope:
	mov	eax, DWORD PTR tv528[rsp]
	mov	DWORD PTR tv531[rsp], eax
$LN116@memory_ope:
	movzx	eax, BYTE PTR tv531[rsp]
	mov	BYTE PTR Ofssize$[rsp], al
	jmp	SHORT $LN77@memory_ope
$LN76@memory_ope:

; 1712 :         } else if ( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN78@memory_ope

; 1713 :             Ofssize = GetSymOfssize( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSymOfssize
	mov	BYTE PTR Ofssize$[rsp], al
	jmp	SHORT $LN79@memory_ope
$LN78@memory_ope:

; 1714 :         } else if ( SegOverride ) {

	cmp	QWORD PTR SegOverride, 0
	je	SHORT $LN80@memory_ope

; 1715 :             Ofssize = GetSymOfssize( SegOverride );

	mov	rcx, QWORD PTR SegOverride
	call	GetSymOfssize
	mov	BYTE PTR Ofssize$[rsp], al

; 1716 :         } else

	jmp	SHORT $LN81@memory_ope
$LN80@memory_ope:

; 1717 :             Ofssize = CodeInfo->Ofssize;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	mov	BYTE PTR Ofssize$[rsp], al
$LN81@memory_ope:
$LN79@memory_ope:
$LN77@memory_ope:

; 1718 : 
; 1719 :         /* now set fixup_type.
; 1720 :          * for direct addressing, the fixup type can easily be set by
; 1721 :          * the symbol's offset size.
; 1722 :          */
; 1723 :         if( base == EMPTY && index == EMPTY ) {

	cmp	DWORD PTR base$[rsp], -2
	jne	$LN82@memory_ope
	cmp	DWORD PTR index$[rsp], -2
	jne	$LN82@memory_ope

; 1724 :             CodeInfo->prefix.adrsiz = ADDRSIZE( CodeInfo->Ofssize, Ofssize );

	movzx	eax, BYTE PTR Ofssize$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+106]
	xor	eax, ecx
	test	eax, eax
	je	SHORT $LN117@memory_ope
	mov	DWORD PTR tv550[rsp], 1
	jmp	SHORT $LN118@memory_ope
$LN117@memory_ope:
	mov	DWORD PTR tv550[rsp], 0
$LN118@memory_ope:
	movzx	eax, BYTE PTR tv550[rsp]
	and	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 254					; 000000feH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 1725 : #if AMD64_SUPPORT
; 1726 :             if ( Ofssize == USE64 )

	movzx	eax, BYTE PTR Ofssize$[rsp]
	cmp	eax, 2
	jne	SHORT $LN84@memory_ope

; 1727 :                 /* v2.03: override with a segment assumed != FLAT? */
; 1728 :                 if ( opndx->override != NULL &&

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN86@memory_ope
	mov	rax, QWORD PTR ModuleInfo+440
	cmp	QWORD PTR SegOverride, rax
	je	SHORT $LN86@memory_ope

; 1729 :                     SegOverride != &ModuleInfo.flat_grp->sym )
; 1730 :                     fixup_type = FIX_OFF32;

	mov	DWORD PTR fixup_type$[rsp], 6
	jmp	SHORT $LN87@memory_ope
$LN86@memory_ope:

; 1731 :                 else
; 1732 :                     fixup_type = FIX_RELOFF32;

	mov	DWORD PTR fixup_type$[rsp], 3
$LN87@memory_ope:
	jmp	SHORT $LN85@memory_ope
$LN84@memory_ope:

; 1733 :             else
; 1734 : #endif
; 1735 :                 fixup_type = ( Ofssize ) ? FIX_OFF32 : FIX_OFF16;

	movzx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	je	SHORT $LN119@memory_ope
	mov	DWORD PTR tv564[rsp], 6
	jmp	SHORT $LN120@memory_ope
$LN119@memory_ope:
	mov	DWORD PTR tv564[rsp], 5
$LN120@memory_ope:
	mov	eax, DWORD PTR tv564[rsp]
	mov	DWORD PTR fixup_type$[rsp], eax
$LN85@memory_ope:

; 1736 :             DebugMsg1(( "memory_operand: direct addressing, fixup type=%u\n", fixup_type ));

	mov	edx, DWORD PTR fixup_type$[rsp]
	lea	rcx, OFFSET FLAT:$SG12123
	call	DoDebugMsg1

; 1737 :         } else {

	jmp	$LN83@memory_ope
$LN82@memory_ope:

; 1738 :             DebugMsg1(( "memory_operand: CodeInfo->Ofssize=%u/prefix.adrsize=%u, Ofssize=%u\n",

	movzx	eax, BYTE PTR Ofssize$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 1
	movzx	ecx, cl
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	movzx	edx, BYTE PTR [rdx+106]
	mov	r9d, eax
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:$SG12124
	call	DoDebugMsg1

; 1739 :                       CodeInfo->Ofssize, CodeInfo->prefix.adrsiz, Ofssize ));
; 1740 : #if AMD64_SUPPORT
; 1741 :             if( Ofssize == USE64 ) {

	movzx	eax, BYTE PTR Ofssize$[rsp]
	cmp	eax, 2
	jne	SHORT $LN88@memory_ope

; 1742 :                 fixup_type = FIX_OFF32;

	mov	DWORD PTR fixup_type$[rsp], 6

; 1743 :             } else

	jmp	$LN89@memory_ope
$LN88@memory_ope:

; 1744 : #endif
; 1745 :             if( IS_ADDR32( CodeInfo ) ) { /* address prefix needed? */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN125@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN123@memory_ope
	mov	DWORD PTR tv590[rsp], 1
	jmp	SHORT $LN124@memory_ope
$LN123@memory_ope:
	mov	DWORD PTR tv590[rsp], 0
$LN124@memory_ope:
	mov	eax, DWORD PTR tv590[rsp]
	mov	DWORD PTR tv592[rsp], eax
	jmp	SHORT $LN126@memory_ope
$LN125@memory_ope:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN121@memory_ope
	mov	DWORD PTR tv589[rsp], 1
	jmp	SHORT $LN122@memory_ope
$LN121@memory_ope:
	mov	DWORD PTR tv589[rsp], 0
$LN122@memory_ope:
	mov	eax, DWORD PTR tv589[rsp]
	mov	DWORD PTR tv592[rsp], eax
$LN126@memory_ope:
	cmp	DWORD PTR tv592[rsp], 0
	je	SHORT $LN90@memory_ope

; 1746 :                 /* changed for v1.95. Probably more tests needed!
; 1747 :                  * test case:
; 1748 :                  *   mov eax,[ebx*2-10+offset var] ;code and var are 16bit!
; 1749 :                  * the old code usually works fine because HiWord of the
; 1750 :                  * symbol's offset is zero. However, if there's an additional
; 1751 :                  * displacement which makes the value stored at the location
; 1752 :                  * < 0, then the target's HiWord becomes <> 0.
; 1753 :                  */
; 1754 :                 //fixup_type = ( Ofssize ) ? FIX_OFF32 : FIX_OFF16;
; 1755 :                 fixup_type = FIX_OFF32;

	mov	DWORD PTR fixup_type$[rsp], 6

; 1756 :             } else {

	jmp	SHORT $LN91@memory_ope
$LN90@memory_ope:

; 1757 :                 fixup_type = FIX_OFF16;

	mov	DWORD PTR fixup_type$[rsp], 5

; 1758 :                 if( Ofssize && Parse_Pass == PASS_2 ) {

	movzx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	je	SHORT $LN92@memory_ope
	cmp	DWORD PTR Parse_Pass, 1
	jne	SHORT $LN92@memory_ope

; 1759 :                     /* address size is 16bit but label is 32-bit.
; 1760 :                      * example: use a 16bit register as base in FLAT model:
; 1761 :                      *   test buff[di],cl */
; 1762 :                     EmitWarn( 2, WORD_FIXUP_FOR_32BIT_LABEL, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 218				; 000000daH
	mov	ecx, 2
	call	EmitWarn
$LN92@memory_ope:
$LN91@memory_ope:
$LN89@memory_ope:
$LN83@memory_ope:

; 1763 :                 }
; 1764 :             }
; 1765 :         }
; 1766 : 
; 1767 : #if IMAGERELSUPP || SECTIONRELSUPP /* v2.10: added; IMAGEREL/SECTIONREL for indirect memory operands */
; 1768 :         if ( fixup_type == FIX_OFF32 )

	cmp	DWORD PTR fixup_type$[rsp], 6
	jne	SHORT $LN93@memory_ope

; 1769 :             if ( opndx->instr == T_IMAGEREL )

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 233			; 000000e9H
	jne	SHORT $LN94@memory_ope

; 1770 :                 fixup_type = FIX_OFF32_IMGREL;

	mov	DWORD PTR fixup_type$[rsp], 12
	jmp	SHORT $LN95@memory_ope
$LN94@memory_ope:

; 1771 :             else if ( opndx->instr == T_SECTIONREL )

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 243			; 000000f3H
	jne	SHORT $LN96@memory_ope

; 1772 :                 fixup_type = FIX_OFF32_SECREL;

	mov	DWORD PTR fixup_type$[rsp], 13
$LN96@memory_ope:
$LN95@memory_ope:
$LN93@memory_ope:

; 1773 : #endif
; 1774 :         /* no fixups are needed for memory operands of string instructions and XLAT/XLATB.
; 1775 :          * However, CMPSD and MOVSD are also SSE2 opcodes, so the fixups must be generated
; 1776 :          * anyways.
; 1777 :          */
; 1778 :         if ( CodeInfo->token != T_XLAT && CodeInfo->token != T_XLATB ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 667			; 0000029bH
	je	SHORT $LN97@memory_ope
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 668			; 0000029cH
	je	SHORT $LN97@memory_ope

; 1779 :             //DebugMsg1(("memory_operand: calling CreateFixup(%s, fixup=%u) [CodeInfo->memtype=%Xh]\n", sym ? sym->name : "NULL", fixup_type, CodeInfo->mem_type));
; 1780 :             CodeInfo->opnd[CurrOpnd].InsFixup = CreateFixup( sym, fixup_type, OPTJ_NONE );

	xor	r8d, r8d
	mov	edx, DWORD PTR fixup_type$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateFixup
	mov	ecx, DWORD PTR CurrOpnd$[rsp]
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rdx+rcx+48], rax
$LN97@memory_ope:
$LN75@memory_ope:

; 1781 :         }
; 1782 :     }
; 1783 : 
; 1784 :     if( set_rm_sib( CodeInfo, CurrOpnd, ss, index, base, sym ) == ERROR ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR base$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR index$[rsp]
	movzx	r8d, BYTE PTR ss$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	set_rm_sib
	cmp	eax, -1
	jne	SHORT $LN98@memory_ope

; 1785 :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@memory_ope
$LN98@memory_ope:

; 1786 :     }
; 1787 :     /* set frame type/data in fixup if one was created */
; 1788 :     if ( CodeInfo->opnd[CurrOpnd].InsFixup ) {

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	je	SHORT $LN99@memory_ope

; 1789 :         CodeInfo->opnd[CurrOpnd].InsFixup->frame_type = Frame_Type;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	movzx	ecx, BYTE PTR Frame_Type
	mov	BYTE PTR [rax+40], cl

; 1790 :         CodeInfo->opnd[CurrOpnd].InsFixup->frame_datum = Frame_Datum;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	movzx	ecx, WORD PTR Frame_Datum
	mov	WORD PTR [rax+42], cx
$LN99@memory_ope:

; 1791 :     }
; 1792 : 
; 1793 :     DebugMsg1(("memory_operand exit, ok, opndx.type/value=%Xh/%Xh, CodeInfo.memtype/rmbyte=%X/%X opndtype=%Xh fix=%Xh\n",

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	ecx, DWORD PTR CurrOpnd$[rsp]
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	movzx	edx, BYTE PTR [rdx+104]
	mov	r8, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [r8+rax+48]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+rcx+32]
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], edx
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	r9d, DWORD PTR [rax+28]
	mov	rax, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rax, QWORD PTR opndx$[rsp]
	mov	rdx, QWORD PTR [rax+96]
	lea	rcx, OFFSET FLAT:$SG12137
	call	DoDebugMsg1

; 1794 :               opndx->type, opndx->value, CodeInfo->mem_type, CodeInfo->rm_byte, CodeInfo->opnd[CurrOpnd].type, CodeInfo->opnd[CurrOpnd].InsFixup ));
; 1795 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@memory_ope:

; 1796 : }

	add	rsp, 184				; 000000b8H
	ret	0
	npad	3
$LN128@memory_ope:
	DD	$LN32@memory_ope
	DD	$LN33@memory_ope
	DD	$LN34@memory_ope
	DD	$LN35@memory_ope
	DD	$LN36@memory_ope
	DD	$LN37@memory_ope
	DD	$LN38@memory_ope
	DD	$LN39@memory_ope
	DD	$LN40@memory_ope
	DD	$LN41@memory_ope
$LN127@memory_ope:
	DB	0
	DB	1
	DB	9
	DB	2
	DB	9
	DB	3
	DB	9
	DB	4
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	7
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	8
memory_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
tv138 = 0
tv85 = 4
tv171 = 8
CodeInfo$ = 32
mem_type$ = 40
Set_Memtype PROC

; 1299 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1300 :     if( CodeInfo->token == T_LEA )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 634			; 0000027aH
	jne	SHORT $LN8@Set_Memtyp

; 1301 :         return;

	jmp	$LN1@Set_Memtyp
$LN8@Set_Memtyp:

; 1302 :     /* v2.05: changed. Set "data" types only. */
; 1303 :     if( mem_type == MT_EMPTY || mem_type == MT_TYPE ||
; 1304 :        mem_type == MT_NEAR || mem_type == MT_FAR )

	cmp	DWORD PTR mem_type$[rsp], 192		; 000000c0H
	je	SHORT $LN10@Set_Memtyp
	cmp	DWORD PTR mem_type$[rsp], 196		; 000000c4H
	je	SHORT $LN10@Set_Memtyp
	cmp	DWORD PTR mem_type$[rsp], 129		; 00000081H
	je	SHORT $LN10@Set_Memtyp
	cmp	DWORD PTR mem_type$[rsp], 130		; 00000082H
	jne	SHORT $LN9@Set_Memtyp
$LN10@Set_Memtyp:

; 1305 :         return;

	jmp	$LN1@Set_Memtyp
$LN9@Set_Memtyp:

; 1306 : 
; 1307 :     CodeInfo->mem_type = mem_type;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR mem_type$[rsp]
	mov	DWORD PTR [rax+28], ecx

; 1308 : 
; 1309 :     if( CodeInfo->Ofssize > USE16 ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jle	$LN11@Set_Memtyp

; 1310 :         /* if we are in use32 mode, we have to add OPSIZ prefix for
; 1311 :          * most of the 386 instructions when operand has type WORD.
; 1312 :          * Exceptions ( MOVSX and MOVZX ) are handled in check_size().
; 1313 :          */
; 1314 :         if ( IS_MEM_TYPE( mem_type, WORD ) )

	cmp	DWORD PTR mem_type$[rsp], 1
	je	SHORT $LN15@Set_Memtyp
	cmp	DWORD PTR mem_type$[rsp], 65		; 00000041H
	jne	SHORT $LN13@Set_Memtyp
$LN15@Set_Memtyp:

; 1315 :             CodeInfo->prefix.opsiz = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	or	al, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
	jmp	$LN14@Set_Memtyp
$LN13@Set_Memtyp:

; 1316 : #if AMD64_SUPPORT
; 1317 :         /*
; 1318 :          * set rex Wide bit if a QWORD operand is found (not for FPU/MMX/SSE instr).
; 1319 :          * This looks pretty hackish now and is to be cleaned!
; 1320 :          * v2.01: also had issues with SSE2 MOVSD/CMPSD, now fixed!
; 1321 :          */
; 1322 :         /* v2.06: with AVX, SSE tokens may exist twice, one
; 1323 :          * for "legacy", the other for VEX encoding!
; 1324 :          */
; 1325 :         else if ( IS_MEMTYPE_SIZ( mem_type, sizeof( uint_64 ) ) ) {

	mov	eax, DWORD PTR mem_type$[rsp]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	jge	$LN16@Set_Memtyp
	mov	eax, DWORD PTR mem_type$[rsp]
	and	eax, 31
	cdqe
	cmp	rax, 7
	jne	$LN16@Set_Memtyp

; 1326 :             switch( CodeInfo->token ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv85[rsp], eax
	cmp	DWORD PTR tv85[rsp], 601		; 00000259H
	jl	SHORT $LN18@Set_Memtyp
	cmp	DWORD PTR tv85[rsp], 602		; 0000025aH
	jle	SHORT $LN17@Set_Memtyp
	cmp	DWORD PTR tv85[rsp], 617		; 00000269H
	je	SHORT $LN17@Set_Memtyp
	cmp	DWORD PTR tv85[rsp], 1287		; 00000507H
	jle	SHORT $LN18@Set_Memtyp
	cmp	DWORD PTR tv85[rsp], 1291		; 0000050bH
	jle	SHORT $LN17@Set_Memtyp
	jmp	SHORT $LN18@Set_Memtyp
$LN17@Set_Memtyp:

; 1327 :             case T_PUSH: /* for PUSH/POP, REX_W isn't needed (no 32-bit variants in 64-bit mode) */
; 1328 :             case T_POP:
; 1329 :             case T_CMPXCHG8B:
; 1330 : #if VMXSUPP
; 1331 :             case T_VMPTRLD:
; 1332 :             case T_VMPTRST:
; 1333 :             case T_VMCLEAR:
; 1334 :             case T_VMXON:
; 1335 : #endif
; 1336 :                 break;

	jmp	$LN2@Set_Memtyp
$LN18@Set_Memtyp:

; 1337 :             default:
; 1338 :                 /* don't set REX for opcodes that accept memory operands
; 1339 :                  * of any size.
; 1340 :                  */
; 1341 :                 if ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[OPND1] == OP_M_ANY ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	cmp	DWORD PTR [rax+rcx], -8388608		; ffffffffff800000H
	jne	SHORT $LN19@Set_Memtyp

; 1342 :                     //printf( "Set_Memtype: OP_M_ANY detected, file=%s, instr=%s\n", CurrFName[ASM], GetResWName( CodeInfo->token, NULL ) );
; 1343 :                     break;

	jmp	$LN2@Set_Memtyp
$LN19@Set_Memtyp:

; 1344 :                 }
; 1345 :                 /* don't set REX for FPU opcodes */
; 1346 :                 if ( CodeInfo->pinstr->cpu & P_FPU_MASK )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+10]
	and	eax, 7
	test	eax, eax
	je	SHORT $LN20@Set_Memtyp

; 1347 :                     break;

	jmp	$LN2@Set_Memtyp
$LN20@Set_Memtyp:

; 1348 :                 /* don't set REX for - most - MMX/SSE opcodes */
; 1349 :                 if ( CodeInfo->pinstr->cpu & P_EXT_MASK ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+10]
	and	eax, 65280				; 0000ff00H
	test	eax, eax
	je	$LN21@Set_Memtyp

; 1350 :                     switch ( CodeInfo->token ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv138[rsp], eax
	cmp	DWORD PTR tv138[rsp], 1446		; 000005a6H
	jg	SHORT $LN36@Set_Memtyp
	cmp	DWORD PTR tv138[rsp], 1446		; 000005a6H
	je	SHORT $LN23@Set_Memtyp
	cmp	DWORD PTR tv138[rsp], 1028		; 00000404H
	jl	SHORT $LN24@Set_Memtyp
	cmp	DWORD PTR tv138[rsp], 1029		; 00000405H
	jle	SHORT $LN23@Set_Memtyp
	cmp	DWORD PTR tv138[rsp], 1046		; 00000416H
	je	SHORT $LN23@Set_Memtyp
	cmp	DWORD PTR tv138[rsp], 1215		; 000004bfH
	jle	SHORT $LN24@Set_Memtyp
	cmp	DWORD PTR tv138[rsp], 1217		; 000004c1H
	jle	SHORT $LN23@Set_Memtyp
	jmp	SHORT $LN24@Set_Memtyp
$LN36@Set_Memtyp:
	cmp	DWORD PTR tv138[rsp], 1912		; 00000778H
	je	SHORT $LN23@Set_Memtyp
	cmp	DWORD PTR tv138[rsp], 1934		; 0000078eH
	je	SHORT $LN23@Set_Memtyp
	cmp	DWORD PTR tv138[rsp], 1989		; 000007c5H
	jle	SHORT $LN24@Set_Memtyp
	cmp	DWORD PTR tv138[rsp], 1991		; 000007c7H
	jle	SHORT $LN23@Set_Memtyp
	jmp	SHORT $LN24@Set_Memtyp
$LN23@Set_Memtyp:

; 1351 :                         /* [V]CMPSD and [V]MOVSD are also candidates,
; 1352 :                          * but currently they are handled in HandleStringInstructions()
; 1353 :                          */
; 1354 :                     case T_CVTSI2SD: /* v2.06: added */
; 1355 :                     case T_CVTSI2SS: /* v2.06: added */
; 1356 :                     case T_PEXTRQ: /* v2.06: added */
; 1357 :                     case T_PINSRQ: /* v2.06: added */
; 1358 :                     case T_MOVD:
; 1359 : #if AVXSUPP
; 1360 :                     case T_VCVTSI2SD:
; 1361 :                     case T_VCVTSI2SS:
; 1362 :                     case T_VPEXTRQ:
; 1363 :                     case T_VPINSRQ:
; 1364 :                     case T_VMOVD:
; 1365 : #endif
; 1366 :                         CodeInfo->prefix.rex |= REX_W;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	or	eax, 8
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+8], al
$LN24@Set_Memtyp:

; 1367 :                         break;
; 1368 :                     default:
; 1369 :                         break;
; 1370 :                     }
; 1371 :                 }

	jmp	SHORT $LN22@Set_Memtyp
$LN21@Set_Memtyp:

; 1372 :                 else
; 1373 :                     CodeInfo->prefix.rex |= REX_W;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	or	eax, 8
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+8], al
$LN22@Set_Memtyp:
$LN2@Set_Memtyp:
$LN16@Set_Memtyp:
$LN14@Set_Memtyp:

; 1374 :             }
; 1375 :         }
; 1376 : #endif
; 1377 : 
; 1378 :     /* v2.05: IS_MEM_TYPE() doesn't work with MT_REALx */
; 1379 :     //} else if( CodeInfo->Ofssize == USE16 && ( IS_MEM_TYPE( mem_type, DWORD ) ) ) {
; 1380 :     } else {

	jmp	$LN12@Set_Memtyp
$LN11@Set_Memtyp:

; 1381 :         if( IS_MEMTYPE_SIZ( mem_type, sizeof(uint_32) ) ) {

	mov	eax, DWORD PTR mem_type$[rsp]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	jge	SHORT $LN25@Set_Memtyp
	mov	eax, DWORD PTR mem_type$[rsp]
	and	eax, 31
	cdqe
	cmp	rax, 3
	jne	SHORT $LN25@Set_Memtyp

; 1382 : 
; 1383 :             /* in 16bit mode, a DWORD memory access usually requires an OPSIZ
; 1384 :              * prefix. A few instructions, which access m16:16 operands,
; 1385 :              * are exceptions.
; 1386 :              */
; 1387 :             switch( CodeInfo->token ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv171[rsp], eax
	mov	eax, DWORD PTR tv171[rsp]
	sub	eax, 455				; 000001c7H
	mov	DWORD PTR tv171[rsp], eax
	cmp	DWORD PTR tv171[rsp], 183		; 000000b7H
	ja	SHORT $LN28@Set_Memtyp
	movsxd	rax, DWORD PTR tv171[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN37@Set_Memtyp[rcx+rax]
	mov	eax, DWORD PTR $LN38@Set_Memtyp[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN27@Set_Memtyp:

; 1388 :             case T_LDS:
; 1389 :             case T_LES:
; 1390 :             case T_LFS:
; 1391 :             case T_LGS:
; 1392 :             case T_LSS:
; 1393 :             case T_CALL: /* v2.0: added */
; 1394 :             case T_JMP:  /* v2.0: added */
; 1395 :                 /* in these cases, opsize does NOT need to be changed  */
; 1396 :                 break;

	jmp	SHORT $LN6@Set_Memtyp
$LN28@Set_Memtyp:

; 1397 :             default:
; 1398 :                 CodeInfo->prefix.opsiz = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	or	al, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN6@Set_Memtyp:

; 1399 :                 break;
; 1400 :             }
; 1401 :         }

	jmp	$LN26@Set_Memtyp
$LN25@Set_Memtyp:

; 1402 : #if AMD64_SUPPORT
; 1403 :         /* v2.06: added because in v2.05, 64-bit memory operands were
; 1404 :          * accepted in 16-bit code
; 1405 :          */
; 1406 :         else if ( IS_MEMTYPE_SIZ( mem_type, sizeof(uint_64) ) ) {

	mov	eax, DWORD PTR mem_type$[rsp]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	jge	SHORT $LN29@Set_Memtyp
	mov	eax, DWORD PTR mem_type$[rsp]
	and	eax, 31
	cdqe
	cmp	rax, 7
	jne	SHORT $LN29@Set_Memtyp

; 1407 :             if ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[OPND1] == OP_M_ANY ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	cmp	DWORD PTR [rax+rcx], -8388608		; ffffffffff800000H
	jne	SHORT $LN30@Set_Memtyp
	jmp	SHORT $LN31@Set_Memtyp
$LN30@Set_Memtyp:

; 1408 :                 //printf( "Set_Memtype: OP_M_ANY detected, file=%s, instr=%s\n", CurrFName[ASM], GetResWName( CodeInfo->token, NULL ) );
; 1409 :             } else if ( CodeInfo->pinstr->cpu & ( P_FPU_MASK | P_EXT_MASK ) ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+10]
	and	eax, 65287				; 0000ff07H
	test	eax, eax
	je	SHORT $LN32@Set_Memtyp
	jmp	SHORT $LN33@Set_Memtyp
$LN32@Set_Memtyp:

; 1410 :                 ;
; 1411 :             } else if ( CodeInfo->token != T_CMPXCHG8B )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 617			; 00000269H
	je	SHORT $LN34@Set_Memtyp

; 1412 :                 /* setting REX.W will cause an error in codegen */
; 1413 :                 CodeInfo->prefix.rex |= REX_W;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	or	eax, 8
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+8], al
$LN34@Set_Memtyp:
$LN33@Set_Memtyp:
$LN31@Set_Memtyp:
$LN29@Set_Memtyp:
$LN26@Set_Memtyp:
$LN12@Set_Memtyp:
$LN1@Set_Memtyp:

; 1414 :         }
; 1415 : #endif
; 1416 :     }
; 1417 :     return;
; 1418 : }

	add	rsp, 24
	ret	0
	npad	1
$LN38@Set_Memtyp:
	DD	$LN27@Set_Memtyp
	DD	$LN28@Set_Memtyp
$LN37@Set_Memtyp:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
Set_Memtype ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
size$ = 32
tv155 = 36
tv264 = 40
tv268 = 44
sym$ = 48
CodeInfo$ = 80
opndx$ = 88
SetPtrMemtype PROC

; 1245 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1246 :     struct asym *sym = opndx->sym;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym$[rsp], rax

; 1247 :     int size = 0;

	mov	DWORD PTR size$[rsp], 0

; 1248 : 
; 1249 :     if ( opndx->mbr )  /* the mbr field has higher priority */

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN2@SetPtrMemt

; 1250 :         sym = opndx->mbr;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR sym$[rsp], rax
$LN2@SetPtrMemt:

; 1251 : 
; 1252 :     /* v2.10: the "explicit" condition is now handled FIRST */
; 1253 : #if 1 /* v2.0: handle PF16 ptr [ebx], which didn't work in v1.96 */
; 1254 :     if ( opndx->explicit && opndx->type ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN3@SetPtrMemt
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN3@SetPtrMemt

; 1255 :         size = opndx->type->total_size;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR size$[rsp], eax

; 1256 :         CodeInfo->isfar = opndx->type->isfar;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 4
	and	al, 1
	and	al, 1
	shl	al, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+142]
	and	cl, 251					; 000000fbH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 1257 :     } else

	jmp	$LN4@SetPtrMemt
$LN3@SetPtrMemt:

; 1258 : #endif
; 1259 :     if ( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN5@SetPtrMemt

; 1260 :         if ( sym->type ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	$LN7@SetPtrMemt

; 1261 :             size = sym->type->total_size;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR size$[rsp], eax

; 1262 :             CodeInfo->isfar = sym->type->isfar;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+88]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 4
	and	al, 1
	and	al, 1
	shl	al, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+142]
	and	cl, 251					; 000000fbH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 1263 : 
; 1264 :             /* there's an ambiguity with pointers of size DWORD,
; 1265 :              since they can be either NEAR32 or FAR16 */
; 1266 :             if ( size == 4 && sym->type->Ofssize != CodeInfo->Ofssize )

	cmp	DWORD PTR size$[rsp], 4
	jne	SHORT $LN9@SetPtrMemt
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+88]
	movzx	eax, BYTE PTR [rax+52]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+106]
	cmp	eax, ecx
	je	SHORT $LN9@SetPtrMemt

; 1267 :                 opndx->Ofssize = sym->type->Ofssize;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rcx, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+52]
	mov	BYTE PTR [rcx+69], al
$LN9@SetPtrMemt:

; 1268 : 
; 1269 :         } else if ( sym->mem_type == MT_PTR ) {

	jmp	$LN8@SetPtrMemt
$LN7@SetPtrMemt:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+44], 195			; 000000c3H
	jne	SHORT $LN10@SetPtrMemt

; 1270 :             size = SizeFromMemtype( sym->isfar ? MT_FAR : MT_NEAR, sym->Ofssize, NULL );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@SetPtrMemt
	mov	DWORD PTR tv155[rsp], 130		; 00000082H
	jmp	SHORT $LN18@SetPtrMemt
$LN17@SetPtrMemt:
	mov	DWORD PTR tv155[rsp], 129		; 00000081H
$LN18@SetPtrMemt:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+52]
	xor	r8d, r8d
	mov	edx, eax
	mov	ecx, DWORD PTR tv155[rsp]
	call	SizeFromMemtype
	mov	DWORD PTR size$[rsp], eax

; 1271 :             CodeInfo->isfar = sym->isfar;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 4
	and	al, 1
	and	al, 1
	shl	al, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+142]
	and	cl, 251					; 000000fbH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 1272 :         } else  {

	jmp	SHORT $LN11@SetPtrMemt
$LN10@SetPtrMemt:

; 1273 :             if ( sym->isarray )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+49]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@SetPtrMemt

; 1274 :                 size = sym->total_size / sym->total_length;

	xor	edx, edx
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	rcx, QWORD PTR sym$[rsp]
	div	DWORD PTR [rcx+72]
	mov	DWORD PTR size$[rsp], eax
	jmp	SHORT $LN13@SetPtrMemt
$LN12@SetPtrMemt:

; 1275 :             else
; 1276 :                 size = sym->total_size;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR size$[rsp], eax
$LN13@SetPtrMemt:
$LN11@SetPtrMemt:
$LN8@SetPtrMemt:

; 1277 :         }
; 1278 :     } else {

	jmp	SHORT $LN6@SetPtrMemt
$LN5@SetPtrMemt:

; 1279 :         if ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) ) {

	mov	eax, DWORD PTR ModuleInfo+360
	mov	ecx, 1
	mov	DWORD PTR tv264[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv264[rsp]
	shl	eax, cl
	and	eax, 104				; 00000068H
	test	eax, eax
	je	SHORT $LN14@SetPtrMemt

; 1280 :             DebugMsg1(("SetPtrMemtype: model with FAR data pointers\n" ));

	lea	rcx, OFFSET FLAT:$SG11956
	call	DoDebugMsg1

; 1281 :             size = 2;

	mov	DWORD PTR size$[rsp], 2
$LN14@SetPtrMemt:

; 1282 :         }
; 1283 :         size += (2 << ModuleInfo.defOfssize );

	movzx	eax, BYTE PTR ModuleInfo+405
	mov	ecx, 2
	mov	DWORD PTR tv268[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv268[rsp]
	shl	eax, cl
	mov	ecx, DWORD PTR size$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR size$[rsp], eax
$LN6@SetPtrMemt:
$LN4@SetPtrMemt:

; 1284 :     }
; 1285 :     if ( size )

	cmp	DWORD PTR size$[rsp], 0
	je	SHORT $LN15@SetPtrMemt

; 1286 :         MemtypeFromSize( size, &opndx->mem_type );

	mov	rax, QWORD PTR opndx$[rsp]
	add	rax, 64					; 00000040H
	mov	rdx, rax
	mov	ecx, DWORD PTR size$[rsp]
	call	MemtypeFromSize
$LN15@SetPtrMemt:

; 1287 :     DebugMsg1(("SetPtrMemtype: size=%u, new memtype=0x%x\n", size, opndx->mem_type ));

	mov	rax, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR [rax+64]
	mov	edx, DWORD PTR size$[rsp]
	lea	rcx, OFFSET FLAT:$SG11958
	call	DoDebugMsg1

; 1288 : }

	add	rsp, 72					; 00000048H
	ret	0
SetPtrMemtype ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
Ofssize$ = 48
size$ = 52
fixup_type$ = 56
tv174 = 60
tv197 = 64
tv277 = 68
tv335 = 72
tv273 = 76
tv267 = 80
tv266 = 84
tv269 = 88
tv271 = 92
tv327 = 96
tv328 = 100
tv353 = 104
tv369 = 108
tv430 = 112
tv467 = 116
tv466 = 120
tv469 = 124
fixup_option$ = 128
tv651 = 132
CodeInfo$ = 160
CurrOpnd$ = 168
opndx$ = 176
idata_fixup PROC

; 925  : {

$LN124:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 926  :     //struct fixup      *fixup;
; 927  :     enum fixup_types    fixup_type;
; 928  :     enum fixup_options  fixup_option = OPTJ_NONE;

	mov	DWORD PTR fixup_option$[rsp], 0

; 929  :     int                 size;
; 930  :     uint_8              Ofssize; /* 1=32bit, 0=16bit offset for fixup */
; 931  : 
; 932  :     DebugMsg1(("idata_fixup( CurrOpnd=%u ) enter [opndx.kind=%u mem_type=%Xh, CodeInfo.mem_type=%Xh]\n", CurrOpnd, opndx->kind, opndx->mem_type, CodeInfo->mem_type));

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR opndx$[rsp]
	mov	r9d, DWORD PTR [rax+64]
	mov	rax, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR [rax+60]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	lea	rcx, OFFSET FLAT:$SG11842
	call	DoDebugMsg1

; 933  : 
; 934  :     /* jmp/call/jcc/loopcc/jxcxz? */
; 935  :     if( IS_ANY_BRANCH( CodeInfo->token ) ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 455			; 000001c7H
	jl	SHORT $LN12@idata_fixu
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 504			; 000001f8H
	jg	SHORT $LN12@idata_fixu

; 936  :         return( process_branch( CodeInfo, CurrOpnd, opndx ) );

	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	process_branch
	jmp	$LN1@idata_fixu
$LN12@idata_fixu:

; 937  :     }
; 938  :     CodeInfo->opnd[CurrOpnd].data32l = opndx->value;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rdx, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+rax+40], edx

; 939  : 
; 940  :     if ( opndx->Ofssize != USE_EMPTY ) {

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	cmp	eax, 254				; 000000feH
	je	SHORT $LN13@idata_fixu

; 941  :         Ofssize = opndx->Ofssize;

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	mov	BYTE PTR Ofssize$[rsp], al

; 942  :     } else if( ( opndx->sym->state == SYM_SEG )

	jmp	SHORT $LN14@idata_fixu
$LN13@idata_fixu:

; 943  :         || ( opndx->sym->state == SYM_GRP )
; 944  :         || ( opndx->instr == T_SEG ) ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+40], 3
	je	SHORT $LN17@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+40], 4
	je	SHORT $LN17@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 244			; 000000f4H
	jne	SHORT $LN15@idata_fixu
$LN17@idata_fixu:

; 945  :         Ofssize = USE16;

	mov	BYTE PTR Ofssize$[rsp], 0
	jmp	SHORT $LN16@idata_fixu
$LN15@idata_fixu:

; 946  :     } else if( opndx->is_abs ) {  /* an (external) absolute symbol? */

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $LN18@idata_fixu

; 947  :         Ofssize = USE16;

	mov	BYTE PTR Ofssize$[rsp], 0

; 948  :     } else {

	jmp	SHORT $LN19@idata_fixu
$LN18@idata_fixu:

; 949  :         Ofssize = GetSymOfssize( opndx->sym );

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	GetSymOfssize
	mov	BYTE PTR Ofssize$[rsp], al
$LN19@idata_fixu:
$LN16@idata_fixu:
$LN14@idata_fixu:

; 950  :     }
; 951  : 
; 952  :     if( opndx->instr == T_SHORT ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 245			; 000000f5H
	jne	SHORT $LN20@idata_fixu

; 953  :         /* short works for branch instructions only */
; 954  :         return( EmitErr( INVALID_INSTRUCTION_OPERANDS ) );

	mov	ecx, 49					; 00000031H
	call	EmitErr
	jmp	$LN1@idata_fixu
$LN20@idata_fixu:

; 955  :     }
; 956  : 
; 957  :     /* the code below should be rewritten.
; 958  :      * - an address operator ( OFFSET, LROFFSET, IMAGEREL, SECTIONREL,
; 959  :      *   LOW, HIGH, LOWWORD, HIGHWORD, LOW32, HIGH32, SEG ) should not
; 960  :      *   force a magnitude, but may set a minimal magnitude - and the
; 961  :      *   fixup type, of course.
; 962  :      * - check if Codeinfo->mem_type really has to be set here!
; 963  :      */
; 964  : 
; 965  :     /* v2.06: added */
; 966  :     /* v2.10: modified */
; 967  :     //if ( opndx->explicit ) {
; 968  :     if ( opndx->explicit && !opndx->is_abs ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN21@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN21@idata_fixu

; 969  :         CodeInfo->const_size_fixed = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 8
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 970  :         if ( CodeInfo->mem_type == MT_EMPTY )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	SHORT $LN22@idata_fixu

; 971  :             CodeInfo->mem_type = opndx->mem_type;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+28], ecx
$LN22@idata_fixu:
$LN21@idata_fixu:

; 972  :     }
; 973  :     /* v2.03: don't ignore a "NEAR32 ptr" qualifier */
; 974  :     //if ( CodeInfo->mem_type == MT_EMPTY && CurrOpnd > OPND1 ) {
; 975  :     if ( CodeInfo->mem_type == MT_EMPTY && CurrOpnd > OPND1 && opndx->Ofssize == USE_EMPTY ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	$LN23@idata_fixu
	cmp	DWORD PTR CurrOpnd$[rsp], 0
	jbe	$LN23@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	cmp	eax, 254				; 000000feH
	jne	$LN23@idata_fixu

; 976  :         size = OperandSize( CodeInfo->opnd[OPND1].type, CodeInfo );

	mov	eax, 24
	imul	rax, rax, 0
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+32]
	call	OperandSize
	mov	DWORD PTR size$[rsp], eax

; 977  :         /* may be a forward reference, so wait till pass 2 */
; 978  :         if( Parse_Pass > PASS_1 && opndx->instr != EMPTY ) {

	cmp	DWORD PTR Parse_Pass, 0
	jbe	$LN24@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], -2
	je	$LN24@idata_fixu

; 979  :             switch ( opndx->instr ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR tv174[rsp], eax
	cmp	DWORD PTR tv174[rsp], 233		; 000000e9H
	je	SHORT $LN27@idata_fixu
	cmp	DWORD PTR tv174[rsp], 239		; 000000efH
	je	SHORT $LN27@idata_fixu
	cmp	DWORD PTR tv174[rsp], 241		; 000000f1H
	je	SHORT $LN27@idata_fixu
	cmp	DWORD PTR tv174[rsp], 243		; 000000f3H
	je	SHORT $LN27@idata_fixu
	cmp	DWORD PTR tv174[rsp], 244		; 000000f4H
	je	SHORT $LN25@idata_fixu
	jmp	SHORT $LN2@idata_fixu
$LN25@idata_fixu:

; 980  :             case T_SEG: /* v2.04a: added */
; 981  :                 if( size && (size < 2 ) ) {

	cmp	DWORD PTR size$[rsp], 0
	je	SHORT $LN26@idata_fixu
	cmp	DWORD PTR size$[rsp], 2
	jge	SHORT $LN26@idata_fixu

; 982  :                     return( EmitErr( OPERANDS_MUST_BE_THE_SAME_SIZE, size, 2 ) );

	mov	r8d, 2
	mov	edx, DWORD PTR size$[rsp]
	mov	ecx, 48					; 00000030H
	call	EmitErr
	jmp	$LN1@idata_fixu
$LN26@idata_fixu:

; 983  :                 }
; 984  :                 break;

	jmp	SHORT $LN2@idata_fixu
$LN27@idata_fixu:

; 985  :             case T_OFFSET:
; 986  :             case T_LROFFSET:
; 987  : #if IMAGERELSUPP
; 988  :             case T_IMAGEREL:
; 989  : #endif
; 990  : #if SECTIONRELSUPP
; 991  :             case T_SECTIONREL:
; 992  : #endif
; 993  :                 if( size && (size < 2 || ( Ofssize && size < 4 ))) {

	cmp	DWORD PTR size$[rsp], 0
	je	SHORT $LN28@idata_fixu
	cmp	DWORD PTR size$[rsp], 2
	jl	SHORT $LN29@idata_fixu
	movzx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	je	SHORT $LN28@idata_fixu
	cmp	DWORD PTR size$[rsp], 4
	jge	SHORT $LN28@idata_fixu
$LN29@idata_fixu:

; 994  :                     return( EmitErr( OPERANDS_MUST_BE_THE_SAME_SIZE, size, ( 2 << Ofssize ) ) );

	movzx	eax, BYTE PTR Ofssize$[rsp]
	mov	ecx, 2
	mov	DWORD PTR tv651[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv651[rsp]
	shl	eax, cl
	mov	r8d, eax
	mov	edx, DWORD PTR size$[rsp]
	mov	ecx, 48					; 00000030H
	call	EmitErr
	jmp	$LN1@idata_fixu
$LN28@idata_fixu:
$LN2@idata_fixu:
$LN24@idata_fixu:

; 995  :                 }
; 996  :             }
; 997  :         }
; 998  :         switch ( size ) {

	mov	eax, DWORD PTR size$[rsp]
	mov	DWORD PTR tv197[rsp], eax
	cmp	DWORD PTR tv197[rsp], 1
	je	SHORT $LN30@idata_fixu
	cmp	DWORD PTR tv197[rsp], 2
	je	SHORT $LN33@idata_fixu
	cmp	DWORD PTR tv197[rsp], 4
	je	$LN36@idata_fixu
	cmp	DWORD PTR tv197[rsp], 8
	je	$LN37@idata_fixu
	jmp	$LN4@idata_fixu
$LN30@idata_fixu:

; 999  :         case 1:
; 1000 :             /* v2.05: if () added */
; 1001 :             if ( opndx->is_abs || opndx->instr == T_LOW || opndx->instr == T_HIGH )

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN32@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 236			; 000000ecH
	je	SHORT $LN32@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 230			; 000000e6H
	jne	SHORT $LN31@idata_fixu
$LN32@idata_fixu:

; 1002 :                 CodeInfo->mem_type = MT_BYTE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 0
$LN31@idata_fixu:

; 1003 :             break;

	jmp	$LN4@idata_fixu
$LN33@idata_fixu:

; 1004 :         case 2:
; 1005 :             /* v2.05: if () added */
; 1006 :             if ( opndx->is_abs ||
; 1007 :                 CodeInfo->Ofssize == USE16 ||
; 1008 :                 opndx->instr == T_LOWWORD ||

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN35@idata_fixu
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN35@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 238			; 000000eeH
	je	SHORT $LN35@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 232			; 000000e8H
	jne	SHORT $LN34@idata_fixu
$LN35@idata_fixu:

; 1009 :                 opndx->instr == T_HIGHWORD )
; 1010 :                 CodeInfo->mem_type = MT_WORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 1
$LN34@idata_fixu:

; 1011 :             break;

	jmp	$LN4@idata_fixu
$LN36@idata_fixu:

; 1012 :         case 4:
; 1013 :             CodeInfo->mem_type = MT_DWORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 3

; 1014 :             break;

	jmp	SHORT $LN4@idata_fixu
$LN37@idata_fixu:

; 1015 : #if AMD64_SUPPORT
; 1016 :         case 8:
; 1017 :             /* v2.05: it's questionable if size 8 is a good assumption for an
; 1018 :              * immediate constant. It's valid for MOV <reg>, <imm> only.
; 1019 :              */
; 1020 :             //case 8: CodeInfo->mem_type = MT_QWORD;break;
; 1021 :             /* v2.05a: added */
; 1022 :             if ( Ofssize == USE64 ) {

	movzx	eax, BYTE PTR Ofssize$[rsp]
	cmp	eax, 2
	jne	SHORT $LN38@idata_fixu

; 1023 :                 if ( CodeInfo->token == T_MOV &&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 606			; 0000025eH
	jne	SHORT $LN39@idata_fixu
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN39@idata_fixu

; 1024 :                     ( CodeInfo->opnd[OPND1].type & OP_R64 ) )
; 1025 :                     CodeInfo->mem_type = MT_QWORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 7
	jmp	SHORT $LN40@idata_fixu
$LN39@idata_fixu:

; 1026 :                 else if ( opndx->instr == T_LOW32 || opndx->instr == T_HIGH32 )

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 237			; 000000edH
	je	SHORT $LN42@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 231			; 000000e7H
	jne	SHORT $LN41@idata_fixu
$LN42@idata_fixu:

; 1027 :                     /* v2.10:added; LOW32/HIGH32 in expreval.c won't set mem_type anymore. */
; 1028 :                     CodeInfo->mem_type = MT_DWORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 3
$LN41@idata_fixu:
$LN40@idata_fixu:
$LN38@idata_fixu:
$LN4@idata_fixu:
$LN23@idata_fixu:

; 1029 :             }
; 1030 :             break;
; 1031 : #endif
; 1032 :         }
; 1033 :     }
; 1034 :     if ( CodeInfo->mem_type == MT_EMPTY ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	$LN43@idata_fixu

; 1035 :         if( opndx->is_abs ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	$LN44@idata_fixu

; 1036 :             //if( opndx->mem_type != MT_EMPTY && opndx->mem_type != MT_ABS ) {
; 1037 :             if( opndx->mem_type != MT_EMPTY ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	je	SHORT $LN46@idata_fixu

; 1038 :                 CodeInfo->mem_type = opndx->mem_type;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+28], ecx
	jmp	$LN47@idata_fixu
$LN46@idata_fixu:

; 1039 :             } else if ( CodeInfo->token == T_PUSHW ) { /* v2.10: special handling PUSHW */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 603			; 0000025bH
	jne	SHORT $LN48@idata_fixu

; 1040 :                 CodeInfo->mem_type = MT_WORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 1

; 1041 :             } else {

	jmp	$LN49@idata_fixu
$LN48@idata_fixu:

; 1042 :                 CodeInfo->mem_type = ( IS_OPER_32( CodeInfo ) ? MT_DWORD : MT_WORD );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN102@idata_fixu
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN100@idata_fixu
	mov	DWORD PTR tv267[rsp], 1
	jmp	SHORT $LN101@idata_fixu
$LN100@idata_fixu:
	mov	DWORD PTR tv267[rsp], 0
$LN101@idata_fixu:
	mov	eax, DWORD PTR tv267[rsp]
	mov	DWORD PTR tv269[rsp], eax
	jmp	SHORT $LN103@idata_fixu
$LN102@idata_fixu:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN98@idata_fixu
	mov	DWORD PTR tv266[rsp], 1
	jmp	SHORT $LN99@idata_fixu
$LN98@idata_fixu:
	mov	DWORD PTR tv266[rsp], 0
$LN99@idata_fixu:
	mov	eax, DWORD PTR tv266[rsp]
	mov	DWORD PTR tv269[rsp], eax
$LN103@idata_fixu:
	cmp	DWORD PTR tv269[rsp], 0
	je	SHORT $LN104@idata_fixu
	mov	DWORD PTR tv271[rsp], 3
	jmp	SHORT $LN105@idata_fixu
$LN104@idata_fixu:
	mov	DWORD PTR tv271[rsp], 1
$LN105@idata_fixu:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR tv271[rsp]
	mov	DWORD PTR [rax+28], ecx
$LN49@idata_fixu:
$LN47@idata_fixu:

; 1043 :             }
; 1044 :         } else {

	jmp	$LN45@idata_fixu
$LN44@idata_fixu:

; 1045 :             switch ( CodeInfo->token ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv273[rsp], eax
	cmp	DWORD PTR tv273[rsp], 565		; 00000235H
	je	SHORT $LN50@idata_fixu
	cmp	DWORD PTR tv273[rsp], 601		; 00000259H
	je	SHORT $LN50@idata_fixu
	cmp	DWORD PTR tv273[rsp], 603		; 0000025bH
	je	SHORT $LN50@idata_fixu
	jmp	$LN6@idata_fixu
$LN50@idata_fixu:

; 1046 :             case T_PUSHW:
; 1047 :             case T_PUSHD:
; 1048 :             case T_PUSH:
; 1049 :                 /* for forward reference, assume BYTE */
; 1050 :                 /* v2.02: don't assume BYTE if it is SEG/GRP */
; 1051 :                 //if ( opndx->mem_type == MT_EMPTY ) {
; 1052 :                 /* v2.07: added cases IMAGEREL and SECTIONREL */
; 1053 :                 if ( opndx->mem_type == MT_EMPTY  ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	jne	SHORT $LN51@idata_fixu

; 1054 :                     switch( opndx->instr ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR tv277[rsp], eax
	mov	eax, DWORD PTR tv277[rsp]
	add	eax, 2
	mov	DWORD PTR tv277[rsp], eax
	cmp	DWORD PTR tv277[rsp], 245		; 000000f5H
	ja	SHORT $LN8@idata_fixu
	movsxd	rax, DWORD PTR tv277[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN122@idata_fixu[rcx+rax]
	mov	eax, DWORD PTR $LN123@idata_fixu[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN52@idata_fixu:

; 1055 :                     case EMPTY:
; 1056 :                     case T_LOW:
; 1057 :                     case T_HIGH:
; 1058 :                         opndx->mem_type = MT_BYTE;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	DWORD PTR [rax+64], 0

; 1059 :                         break;

	jmp	SHORT $LN8@idata_fixu
$LN53@idata_fixu:

; 1060 :                     case T_LOW32: /* v2.10: added - low32_op() doesn't set mem_type anymore. */
; 1061 : #if IMAGERELSUPP
; 1062 :                     case T_IMAGEREL:
; 1063 : #endif
; 1064 : #if SECTIONRELSUPP
; 1065 :                     case T_SECTIONREL:
; 1066 : #endif
; 1067 :                         opndx->mem_type = MT_DWORD;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	DWORD PTR [rax+64], 3
$LN8@idata_fixu:
$LN51@idata_fixu:

; 1068 :                         break;
; 1069 :                     };
; 1070 :                 }
; 1071 :                 /* default: push offset only */
; 1072 :                 /* for PUSH + undefined symbol, assume BYTE */
; 1073 :                 if ( opndx->mem_type == MT_FAR && ( opndx->explicit == FALSE ) )

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+64], 130			; 00000082H
	jne	SHORT $LN54@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN54@idata_fixu

; 1074 :                     opndx->mem_type = MT_NEAR;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	DWORD PTR [rax+64], 129			; 00000081H
$LN54@idata_fixu:

; 1075 :                 /* v2.04: curly brackets added */
; 1076 :                 if ( CodeInfo->token == T_PUSHW ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 603			; 0000025bH
	jne	SHORT $LN55@idata_fixu

; 1077 :                     if ( SizeFromMemtype( opndx->mem_type, Ofssize, opndx->type ) < 2 )

	movzx	eax, BYTE PTR Ofssize$[rsp]
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	r8, QWORD PTR [rcx+96]
	mov	edx, eax
	mov	rax, QWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rax+64]
	call	SizeFromMemtype
	cmp	eax, 2
	jge	SHORT $LN57@idata_fixu

; 1078 :                         opndx->mem_type = MT_WORD;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	DWORD PTR [rax+64], 1
$LN57@idata_fixu:

; 1079 :                 } else if ( CodeInfo->token == T_PUSHD ) {

	jmp	SHORT $LN56@idata_fixu
$LN55@idata_fixu:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 565			; 00000235H
	jne	SHORT $LN58@idata_fixu

; 1080 :                     if ( SizeFromMemtype( opndx->mem_type, Ofssize, opndx->type ) < 4 )

	movzx	eax, BYTE PTR Ofssize$[rsp]
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	r8, QWORD PTR [rcx+96]
	mov	edx, eax
	mov	rax, QWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rax+64]
	call	SizeFromMemtype
	cmp	eax, 4
	jge	SHORT $LN59@idata_fixu

; 1081 :                         opndx->mem_type = MT_DWORD;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	DWORD PTR [rax+64], 3
$LN59@idata_fixu:
$LN58@idata_fixu:
$LN56@idata_fixu:
$LN6@idata_fixu:

; 1082 :                 }
; 1083 :                 break;
; 1084 :             }
; 1085 :             /* if a WORD size is given, don't override it with */
; 1086 :             /* anything what might look better at first glance */
; 1087 :             if( opndx->mem_type != MT_EMPTY )

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+64], 192			; 000000c0H
	je	SHORT $LN60@idata_fixu

; 1088 :                 CodeInfo->mem_type = opndx->mem_type;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+28], ecx
	jmp	SHORT $LN61@idata_fixu
$LN60@idata_fixu:

; 1089 :             /* v2.04: assume BYTE size if symbol is undefined */
; 1090 :             else if ( opndx->sym->state == SYM_UNDEFINED ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN62@idata_fixu

; 1091 :                 CodeInfo->mem_type = MT_BYTE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 0

; 1092 :                 fixup_option = OPTJ_PUSH;

	mov	DWORD PTR fixup_option$[rsp], 5

; 1093 :             } else

	jmp	SHORT $LN63@idata_fixu
$LN62@idata_fixu:

; 1094 : #if AMD64_SUPPORT
; 1095 :                 /* v2.06d: changed */
; 1096 :                    CodeInfo->mem_type = ( Ofssize == USE64 ? MT_QWORD : Ofssize == USE32 ? MT_DWORD : MT_WORD );

	movzx	eax, BYTE PTR Ofssize$[rsp]
	cmp	eax, 2
	jne	SHORT $LN108@idata_fixu
	mov	DWORD PTR tv328[rsp], 7
	jmp	SHORT $LN109@idata_fixu
$LN108@idata_fixu:
	movzx	eax, BYTE PTR Ofssize$[rsp]
	cmp	eax, 1
	jne	SHORT $LN106@idata_fixu
	mov	DWORD PTR tv327[rsp], 3
	jmp	SHORT $LN107@idata_fixu
$LN106@idata_fixu:
	mov	DWORD PTR tv327[rsp], 1
$LN107@idata_fixu:
	mov	eax, DWORD PTR tv327[rsp]
	mov	DWORD PTR tv328[rsp], eax
$LN109@idata_fixu:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR tv328[rsp]
	mov	DWORD PTR [rax+28], ecx
$LN63@idata_fixu:
$LN61@idata_fixu:
$LN45@idata_fixu:
$LN43@idata_fixu:

; 1097 : #else
; 1098 :                 CodeInfo->mem_type = ( Ofssize > USE16 ? MT_DWORD : MT_WORD );
; 1099 : #endif
; 1100 :         }
; 1101 :     }
; 1102 :     size = SizeFromMemtype( CodeInfo->mem_type, Ofssize, NULL );

	movzx	eax, BYTE PTR Ofssize$[rsp]
	xor	r8d, r8d
	mov	edx, eax
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR [rax+28]
	call	SizeFromMemtype
	mov	DWORD PTR size$[rsp], eax

; 1103 :     switch( size ) {

	mov	eax, DWORD PTR size$[rsp]
	mov	DWORD PTR tv335[rsp], eax
	cmp	DWORD PTR tv335[rsp], 1
	je	SHORT $LN64@idata_fixu
	cmp	DWORD PTR tv335[rsp], 2
	je	SHORT $LN65@idata_fixu
	cmp	DWORD PTR tv335[rsp], 4
	je	$LN66@idata_fixu
	cmp	DWORD PTR tv335[rsp], 8
	je	$LN67@idata_fixu
	jmp	$LN74@idata_fixu
$LN64@idata_fixu:

; 1104 :     case 1:
; 1105 :         CodeInfo->opnd[CurrOpnd].type = OP_I8;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 131072		; 00020000H

; 1106 :         CodeInfo->prefix.opsiz = FALSE; /* v2.10: reset opsize is not really a good idea - might have been set by previous operand */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 1107 :         break;

	jmp	$LN10@idata_fixu
$LN65@idata_fixu:

; 1108 :     case 2:  CodeInfo->opnd[CurrOpnd].type = OP_I16; CodeInfo->prefix.opsiz = OPSIZE16( CodeInfo );  break;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 262144		; 00040000H
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN110@idata_fixu
	mov	DWORD PTR tv353[rsp], 1
	jmp	SHORT $LN111@idata_fixu
$LN110@idata_fixu:
	mov	DWORD PTR tv353[rsp], 0
$LN111@idata_fixu:
	movzx	eax, BYTE PTR tv353[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
	jmp	$LN10@idata_fixu
$LN66@idata_fixu:

; 1109 :     case 4:  CodeInfo->opnd[CurrOpnd].type = OP_I32; CodeInfo->prefix.opsiz = OPSIZE32( CodeInfo );  break;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 524288		; 00080000H
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN112@idata_fixu
	mov	DWORD PTR tv369[rsp], 0
	jmp	SHORT $LN113@idata_fixu
$LN112@idata_fixu:
	mov	DWORD PTR tv369[rsp], 1
$LN113@idata_fixu:
	movzx	eax, BYTE PTR tv369[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
	jmp	$LN10@idata_fixu
$LN67@idata_fixu:

; 1110 : #if AMD64_SUPPORT
; 1111 :     case 8:
; 1112 :         /* v2.05: do only assume size 8 if the constant won't fit in 4 bytes. */
; 1113 :         if ( opndx->value64 > LONG_MAX || opndx->value64 < LONG_MIN ||

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax], 2147483647		; 7fffffffH
	jg	SHORT $LN70@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax], -2147483648		; ffffffff80000000H
	jl	SHORT $LN70@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN68@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+64]
	and	eax, 31
	cmp	eax, 7
	jne	SHORT $LN68@idata_fixu
$LN70@idata_fixu:

; 1114 :             (opndx->explicit && ( opndx->mem_type & MT_SIZE_MASK ) == 7 ) ) {
; 1115 :             CodeInfo->opnd[CurrOpnd].type = OP_I64;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 1048576		; 00100000H

; 1116 :             CodeInfo->opnd[CurrOpnd].data32h = opndx->hvalue;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rdx, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+rax+44], edx
	jmp	$LN69@idata_fixu
$LN68@idata_fixu:

; 1117 :         //} else if ( Ofssize == USE64 ) { /* v2.11: assume 64-bit only for OFFSET or MOV r64, xxx */
; 1118 :         } else if ( Ofssize == USE64 && ( opndx->instr == T_OFFSET || ( CodeInfo->token == T_MOV && ( CodeInfo->opnd[OPND1].type & OP_R64 ) ) ) ) {

	movzx	eax, BYTE PTR Ofssize$[rsp]
	cmp	eax, 2
	jne	SHORT $LN71@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 241			; 000000f1H
	je	SHORT $LN73@idata_fixu
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 606			; 0000025eH
	jne	SHORT $LN71@idata_fixu
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN71@idata_fixu
$LN73@idata_fixu:

; 1119 :             /* v2.06d: in 64-bit, ALWAYS set OP_I64, so "mov m64, ofs" will fail,
; 1120 :              * This was accepted in v2.05-v2.06c)
; 1121 :              */
; 1122 :             CodeInfo->opnd[CurrOpnd].type = OP_I64;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 1048576		; 00100000H

; 1123 :             CodeInfo->opnd[CurrOpnd].data32h = opndx->hvalue;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rdx, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+rax+44], edx

; 1124 :         } else {

	jmp	SHORT $LN72@idata_fixu
$LN71@idata_fixu:

; 1125 :             CodeInfo->opnd[CurrOpnd].type = OP_I32;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 524288		; 00080000H
$LN72@idata_fixu:
$LN69@idata_fixu:

; 1126 :         }
; 1127 :         CodeInfo->prefix.opsiz = OPSIZE32( CodeInfo );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN114@idata_fixu
	mov	DWORD PTR tv430[rsp], 0
	jmp	SHORT $LN115@idata_fixu
$LN114@idata_fixu:
	mov	DWORD PTR tv430[rsp], 1
$LN115@idata_fixu:
	movzx	eax, BYTE PTR tv430[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 1128 :         break;

	jmp	SHORT $LN10@idata_fixu
$LN74@idata_fixu:

; 1129 : #endif
; 1130 : #ifdef DEBUG_OUT
; 1131 :     default:
; 1132 :         DebugMsg1(("idata_fixup, unexpected size %u\n", size ));

	mov	edx, DWORD PTR size$[rsp]
	lea	rcx, OFFSET FLAT:$SG11906
	call	DoDebugMsg1

; 1133 :         /**/myassert( 0 );

	mov	edx, 1133				; 0000046dH
	lea	rcx, OFFSET FLAT:$SG11907
	call	InternalError
$LN10@idata_fixu:

; 1134 : #endif
; 1135 :     }
; 1136 : 
; 1137 :     /* set fixup_type */
; 1138 : 
; 1139 :     if( opndx->instr == T_SEG ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 244			; 000000f4H
	jne	SHORT $LN75@idata_fixu

; 1140 :         fixup_type = FIX_SEG;

	mov	DWORD PTR fixup_type$[rsp], 8
	jmp	$LN76@idata_fixu
$LN75@idata_fixu:

; 1141 :     } else if( CodeInfo->mem_type == MT_BYTE ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 0
	jne	SHORT $LN77@idata_fixu

; 1142 :         DebugMsg1(("idata_fixup, mem_type=BYTE\n" ));

	lea	rcx, OFFSET FLAT:$SG11912
	call	DoDebugMsg1

; 1143 :         if ( opndx->instr == T_HIGH ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 230			; 000000e6H
	jne	SHORT $LN79@idata_fixu

; 1144 :             DebugMsg1(("idata_fixup, FIX_HIBYTE\n" ));

	lea	rcx, OFFSET FLAT:$SG11915
	call	DoDebugMsg1

; 1145 :             fixup_type = FIX_HIBYTE;

	mov	DWORD PTR fixup_type$[rsp], 11

; 1146 :         } else {

	jmp	SHORT $LN80@idata_fixu
$LN79@idata_fixu:

; 1147 :             DebugMsg1(("idata_fixup, FIX_OFF8\n" ));

	lea	rcx, OFFSET FLAT:$SG11916
	call	DoDebugMsg1

; 1148 :             fixup_type = FIX_OFF8;

	mov	DWORD PTR fixup_type$[rsp], 4
$LN80@idata_fixu:

; 1149 :         }

	jmp	$LN78@idata_fixu
$LN77@idata_fixu:

; 1150 : #if 0
; 1151 :     } else if( CodeInfo->mem_type == MT_FAR ) {
; 1152 :         /* v2.04: to be tested. this code is most likely obsolete.
; 1153 :          * There's never a PTR16|PTR32 fixup here. Far JMP/CALL are handled
; 1154 :          * elsewhere, and data items also.
; 1155 :          */
; 1156 :         /* temporary */
; 1157 :         printf("idata_fixup: MT_FAR occured at %s:%" I32_SPEC "u\n", CurrFName[ASM], LineNumber );
; 1158 :         fixup_type = ( Ofssize ) ? FIX_PTR32 : FIX_PTR16;
; 1159 :         CodeInfo->isfar = TRUE; /* needed for mark_fixupp() */
; 1160 :         if ( opndx->Ofssize != USE_EMPTY )
; 1161 :             CodeInfo->Ofssize = opndx->Ofssize;
; 1162 : #endif
; 1163 :     } else if( IS_OPER_32( CodeInfo ) ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN120@idata_fixu
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN118@idata_fixu
	mov	DWORD PTR tv467[rsp], 1
	jmp	SHORT $LN119@idata_fixu
$LN118@idata_fixu:
	mov	DWORD PTR tv467[rsp], 0
$LN119@idata_fixu:
	mov	eax, DWORD PTR tv467[rsp]
	mov	DWORD PTR tv469[rsp], eax
	jmp	SHORT $LN121@idata_fixu
$LN120@idata_fixu:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN116@idata_fixu
	mov	DWORD PTR tv466[rsp], 1
	jmp	SHORT $LN117@idata_fixu
$LN116@idata_fixu:
	mov	DWORD PTR tv466[rsp], 0
$LN117@idata_fixu:
	mov	eax, DWORD PTR tv466[rsp]
	mov	DWORD PTR tv469[rsp], eax
$LN121@idata_fixu:
	cmp	DWORD PTR tv469[rsp], 0
	je	$LN81@idata_fixu

; 1164 : #if AMD64_SUPPORT
; 1165 :         /* v2.06: changed */
; 1166 :         //if ( Ofssize == USE64 && CodeInfo->mem_type == MT_QWORD )
; 1167 :         /* v2.10: changed */
; 1168 :         //if ( CodeInfo->opnd[CurrOpnd].type == OP_I64 )
; 1169 :         if ( CodeInfo->opnd[CurrOpnd].type == OP_I64 && ( opndx->instr == EMPTY || opndx->instr == T_OFFSET ) )

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 1048576		; 00100000H
	jne	SHORT $LN83@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], -2
	je	SHORT $LN85@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 241			; 000000f1H
	jne	SHORT $LN83@idata_fixu
$LN85@idata_fixu:

; 1170 :             fixup_type = FIX_OFF64;

	mov	DWORD PTR fixup_type$[rsp], 7
	jmp	SHORT $LN84@idata_fixu
$LN83@idata_fixu:

; 1171 :         else
; 1172 : #endif
; 1173 :             /* v2.04: changed, no longer depends on OfsSize */
; 1174 :             /* v2.05a: changed, so size==8 won't get a FIX_OFF16 type */
; 1175 :             //if ( size == 4 )
; 1176 :             if ( size >= 4 && opndx->instr != T_LOWWORD ) {

	cmp	DWORD PTR size$[rsp], 4
	jl	SHORT $LN86@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 238			; 000000eeH
	je	SHORT $LN86@idata_fixu

; 1177 :                 /* v2.06: added branch for PTR16 fixup.
; 1178 :                  * it's only done if type coercion is FAR (Masm-compat)
; 1179 :                  */
; 1180 :                 if ( opndx->explicit && Ofssize == USE16 && opndx->mem_type == MT_FAR )

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN88@idata_fixu
	movzx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	jne	SHORT $LN88@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+64], 130			; 00000082H
	jne	SHORT $LN88@idata_fixu

; 1181 :                     fixup_type = FIX_PTR16;

	mov	DWORD PTR fixup_type$[rsp], 9
	jmp	SHORT $LN89@idata_fixu
$LN88@idata_fixu:

; 1182 :                 else
; 1183 :                     fixup_type = FIX_OFF32;

	mov	DWORD PTR fixup_type$[rsp], 6
$LN89@idata_fixu:

; 1184 :             } else

	jmp	SHORT $LN87@idata_fixu
$LN86@idata_fixu:

; 1185 :                 fixup_type = FIX_OFF16;

	mov	DWORD PTR fixup_type$[rsp], 5
$LN87@idata_fixu:
$LN84@idata_fixu:

; 1186 :     } else {

	jmp	SHORT $LN82@idata_fixu
$LN81@idata_fixu:

; 1187 :         /* v2.04: changed, no longer depends on OfsSize */
; 1188 :         //if ( CodeInfo->mem_type == MT_DWORD ) {
; 1189 :             /* fixme !!!! warning
; 1190 :              * operand size is 16bit
; 1191 :              * but fixup is 32-bit */
; 1192 :         //    fixup_type = FIX_OFF32;
; 1193 :         //} else
; 1194 :             fixup_type = FIX_OFF16;

	mov	DWORD PTR fixup_type$[rsp], 5
$LN82@idata_fixu:
$LN78@idata_fixu:
$LN76@idata_fixu:

; 1195 :     }
; 1196 :     /* v2.04: 'if' added, don't set W bit if size == 1
; 1197 :      * code example:
; 1198 :      *   extern x:byte
; 1199 :      *   or al,x
; 1200 :      * v2.11: set wide bit only if immediate is second operand.
; 1201 :      * and first operand is a memory reference with size > 1
; 1202 :      */
; 1203 :     //if ( size != 1 )
; 1204 :     if ( CurrOpnd == OPND2 && size != 1 )

	cmp	DWORD PTR CurrOpnd$[rsp], 1
	jne	SHORT $LN90@idata_fixu
	cmp	DWORD PTR size$[rsp], 1
	je	SHORT $LN90@idata_fixu

; 1205 :         CodeInfo->iswide = 1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al
$LN90@idata_fixu:

; 1206 : 
; 1207 :     segm_override( opndx, NULL ); /* set SegOverride global var */

	xor	edx, edx
	mov	rcx, QWORD PTR opndx$[rsp]
	call	segm_override

; 1208 : 
; 1209 :     /* set frame type in variables Frame_Type and Frame_Datum for fixup creation */
; 1210 :     if ( ModuleInfo.offsettype == OT_SEGMENT &&

	cmp	DWORD PTR ModuleInfo+384, 2
	jne	SHORT $LN91@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 241			; 000000f1H
	je	SHORT $LN93@idata_fixu
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 244			; 000000f4H
	jne	SHORT $LN91@idata_fixu
$LN93@idata_fixu:

; 1211 :         ( opndx->instr == T_OFFSET || opndx->instr == T_SEG ))
; 1212 :         set_frame2( opndx->sym );

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	set_frame2
	jmp	SHORT $LN92@idata_fixu
$LN91@idata_fixu:

; 1213 :     else
; 1214 :         set_frame( opndx->sym );

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	set_frame
$LN92@idata_fixu:

; 1215 : 
; 1216 :     //DebugMsg1(("idata_fixup: calling CreateFixup(%s, %u)\n", opndx->sym->name, fixup_type ));
; 1217 :     CodeInfo->opnd[CurrOpnd].InsFixup = CreateFixup( opndx->sym, fixup_type, fixup_option );

	mov	r8d, DWORD PTR fixup_option$[rsp]
	mov	edx, DWORD PTR fixup_type$[rsp]
	mov	rax, QWORD PTR opndx$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	CreateFixup
	mov	ecx, DWORD PTR CurrOpnd$[rsp]
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rdx+rcx+48], rax

; 1218 : 
; 1219 :     if ( opndx->instr == T_LROFFSET )

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 239			; 000000efH
	jne	SHORT $LN94@idata_fixu

; 1220 :         CodeInfo->opnd[CurrOpnd].InsFixup->loader_resolved = TRUE;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	movzx	eax, BYTE PTR [rax+33]
	or	al, 1
	mov	ecx, DWORD PTR CurrOpnd$[rsp]
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+48]
	mov	BYTE PTR [rcx+33], al
$LN94@idata_fixu:

; 1221 : 
; 1222 : #if IMAGERELSUPP
; 1223 :     if ( opndx->instr == T_IMAGEREL && fixup_type == FIX_OFF32 )

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 233			; 000000e9H
	jne	SHORT $LN95@idata_fixu
	cmp	DWORD PTR fixup_type$[rsp], 6
	jne	SHORT $LN95@idata_fixu

; 1224 :         CodeInfo->opnd[CurrOpnd].InsFixup->type = FIX_OFF32_IMGREL;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	mov	DWORD PTR [rax+24], 12
$LN95@idata_fixu:

; 1225 : #endif
; 1226 : #if SECTIONRELSUPP
; 1227 :     if ( opndx->instr == T_SECTIONREL && fixup_type == FIX_OFF32 )

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+56], 243			; 000000f3H
	jne	SHORT $LN96@idata_fixu
	cmp	DWORD PTR fixup_type$[rsp], 6
	jne	SHORT $LN96@idata_fixu

; 1228 :         CodeInfo->opnd[CurrOpnd].InsFixup->type = FIX_OFF32_SECREL;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	mov	DWORD PTR [rax+24], 13
$LN96@idata_fixu:

; 1229 : #endif
; 1230 :     DebugMsg1(("idata_fixup exit [CodeInfo.mem_type=%Xh Ofssize=%u opsiz=%u fixup.type=%u fixup.frame=%d]\n",

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	movsx	eax, BYTE PTR [rax+40]
	mov	ecx, DWORD PTR CurrOpnd$[rsp]
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+48]
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	movzx	edx, BYTE PTR [rdx+9]
	shr	dl, 1
	and	dl, 1
	movzx	edx, dl
	mov	r8, QWORD PTR CodeInfo$[rsp]
	movzx	r8d, BYTE PTR [r8+106]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [rcx+24]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, edx
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rax+28]
	lea	rcx, OFFSET FLAT:$SG11933
	call	DoDebugMsg1

; 1231 :                CodeInfo->mem_type, CodeInfo->Ofssize, CodeInfo->prefix.opsiz,
; 1232 :                CodeInfo->opnd[CurrOpnd].InsFixup->type, CodeInfo->opnd[CurrOpnd].InsFixup->frame_type ));
; 1233 : 
; 1234 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@idata_fixu:

; 1235 : }

	add	rsp, 152				; 00000098H
	ret	0
	npad	1
$LN123@idata_fixu:
	DD	$LN52@idata_fixu
	DD	$LN53@idata_fixu
	DD	$LN8@idata_fixu
$LN122@idata_fixu:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	0
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
idata_fixup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
op_type$ = 48
value$ = 52
tv175 = 56
tv188 = 60
size$ = 64
tv202 = 68
tv214 = 72
CodeInfo$ = 96
CurrOpnd$ = 104
opndx$ = 112
idata_nofixup PROC

; 787  : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 788  :     enum operand_type op_type;
; 789  :     int_32      value;
; 790  :     int         size;
; 791  : 
; 792  :     DebugMsg1(("idata_nofixup( CurrOpnd=%u ) enter [opnd kind=%u mem_type=%Xh value=%" I64_SPEC "X]\n", CurrOpnd, opndx->kind, opndx->mem_type, opndx->value64));

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR opndx$[rsp]
	mov	r9d, DWORD PTR [rax+64]
	mov	rax, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR [rax+60]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	lea	rcx, OFFSET FLAT:$SG11785
	call	DoDebugMsg1

; 793  : 
; 794  :     /* jmp/call/jxx/loop/jcxz/jecxz? */
; 795  :     if( IS_ANY_BRANCH( CodeInfo->token ) ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 455			; 000001c7H
	jl	SHORT $LN6@idata_nofi
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 504			; 000001f8H
	jg	SHORT $LN6@idata_nofi

; 796  :         return( process_branch( CodeInfo, CurrOpnd, opndx ) );

	mov	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	process_branch
	jmp	$LN1@idata_nofi
$LN6@idata_nofi:

; 797  :     }
; 798  :     value = opndx->value;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rsp], eax

; 799  :     CodeInfo->opnd[CurrOpnd].data32l = value;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rcx+rax+40], edx

; 800  : 
; 801  : #if AMD64_SUPPORT
; 802  :     /* 64bit immediates are restricted to MOV <reg>,<imm64>
; 803  :      */
; 804  :     if ( opndx->hlvalue != 0 ) { /* magnitude > 64 bits? */

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN7@idata_nofi

; 805  :         DebugMsg1(("idata_nofixup: error, hlvalue=%" I64_SPEC "X\n", opndx->hlvalue ));

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11788
	call	DoDebugMsg1

; 806  :         return( EmitConstError( opndx ) );

	mov	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	$LN1@idata_nofi
$LN7@idata_nofi:

; 807  :     }
; 808  :     /* v2.03: handle QWORD type coercion here as well!
; 809  :      * This change also reveals an old problem in the expression evaluator:
; 810  :      * the mem_type field is set whenever a (simple) type token is found.
; 811  :      * It should be set ONLY when the type is used in conjuction with the
; 812  :      * PTR operator!
; 813  :      * current workaround: query the 'explicit' flag.
; 814  :      */
; 815  :     //if ( opndx->value64 <= minintvalues[0] || opndx->value64 > maxintvalues[0] ) {
; 816  :     /* use long format of MOV for 64-bit if value won't fit in a signed DWORD */
; 817  :     if ( CodeInfo->Ofssize == USE64 &&
; 818  :         CodeInfo->token == T_MOV &&
; 819  :         CurrOpnd == OPND2 &&
; 820  :         ( CodeInfo->opnd[OPND1].type & OP_R64 ) &&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	jne	$LN8@idata_nofi
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 606			; 0000025eH
	jne	$LN8@idata_nofi
	cmp	DWORD PTR CurrOpnd$[rsp], 1
	jne	$LN8@idata_nofi
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN8@idata_nofi
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax], 2147483647		; 7fffffffH
	jg	SHORT $LN9@idata_nofi
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax], -2147483648		; ffffffff80000000H
	jl	SHORT $LN9@idata_nofi
	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@idata_nofi
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+64], 7
	je	SHORT $LN10@idata_nofi
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+64], 71			; 00000047H
	jne	SHORT $LN8@idata_nofi
$LN10@idata_nofi:
$LN9@idata_nofi:

; 821  :         ( opndx->value64 > LONG_MAX || opndx->value64 < LONG_MIN ||
; 822  :          (opndx->explicit && ( opndx->mem_type == MT_QWORD || opndx->mem_type == MT_SQWORD ) ) ) ) {
; 823  :         // CodeInfo->iswide = 1; /* has been set by first operand already */
; 824  :         CodeInfo->opnd[CurrOpnd].type = OP_I64;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 1048576		; 00100000H

; 825  :         CodeInfo->opnd[CurrOpnd].data32h = opndx->hvalue;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rdx, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+rax+44], edx

; 826  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@idata_nofi
$LN8@idata_nofi:

; 827  :     }
; 828  :     //if ( opndx->value64 <= minintvalues[0] || opndx->value64 > maxintvalues[0] ) {
; 829  :     //    DebugMsg1(("idata_nofixup: error, hvalue=%Xh\n", opndx->hvalue ));
; 830  :     //    return( EmitConstError( opndx ) );
; 831  :     //}
; 832  : #endif
; 833  : 
; 834  :     /* v2.06: code simplified.
; 835  :      * to be fixed: the "wide" bit should not be set here!
; 836  :      * Problem: the "wide" bit isn't set in memory_operand(),
; 837  :      * probably because of the instructions which accept both
; 838  :      * signed and unsigned arguments (ADD, CMP, ... ).
; 839  :      */
; 840  : 
; 841  :     if ( opndx->explicit ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	$LN11@idata_nofi

; 842  :         /* size coercion for immediate value */
; 843  :         CodeInfo->const_size_fixed = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 8
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 844  :         size = SizeFromMemtype( opndx->mem_type,

	mov	rax, QWORD PTR opndx$[rsp]
	movzx	eax, BYTE PTR [rax+69]
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	r8, QWORD PTR [rcx+96]
	mov	edx, eax
	mov	rax, QWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rax+64]
	call	SizeFromMemtype
	mov	DWORD PTR size$[rsp], eax

; 845  :                                opndx->Ofssize,
; 846  :                                opndx->type );
; 847  :         /* don't check if size and value are compatible. */
; 848  :         switch ( size ) {

	mov	eax, DWORD PTR size$[rsp]
	mov	DWORD PTR tv175[rsp], eax
	cmp	DWORD PTR tv175[rsp], 1
	je	SHORT $LN13@idata_nofi
	cmp	DWORD PTR tv175[rsp], 2
	je	SHORT $LN14@idata_nofi
	cmp	DWORD PTR tv175[rsp], 4
	je	SHORT $LN15@idata_nofi
	jmp	SHORT $LN16@idata_nofi
$LN13@idata_nofi:

; 849  :         case 1: op_type = OP_I8;  break;

	mov	DWORD PTR op_type$[rsp], 131072		; 00020000H
	jmp	SHORT $LN2@idata_nofi
$LN14@idata_nofi:

; 850  :         case 2: op_type = OP_I16; break;

	mov	DWORD PTR op_type$[rsp], 262144		; 00040000H
	jmp	SHORT $LN2@idata_nofi
$LN15@idata_nofi:

; 851  :         case 4: op_type = OP_I32; break;

	mov	DWORD PTR op_type$[rsp], 524288		; 00080000H
	jmp	SHORT $LN2@idata_nofi
$LN16@idata_nofi:

; 852  :         default:
; 853  :             DebugMsg1(("idata_nofixup: invalid size %d for immediate operand\n", size ));

	mov	edx, DWORD PTR size$[rsp]
	lea	rcx, OFFSET FLAT:$SG11798
	call	DoDebugMsg1

; 854  :             return( EmitError( INVALID_INSTRUCTION_OPERANDS ) );

	mov	ecx, 49					; 00000031H
	call	EmitError
	jmp	$LN1@idata_nofi
$LN2@idata_nofi:

; 855  :         }
; 856  :     } else {

	jmp	SHORT $LN12@idata_nofi
$LN11@idata_nofi:

; 857  :         /* use true signed values for BYTE only! */
; 858  :         if ( (int_8)value == value )

	movsx	eax, BYTE PTR value$[rsp]
	cmp	eax, DWORD PTR value$[rsp]
	jne	SHORT $LN17@idata_nofi

; 859  :             op_type = OP_I8;

	mov	DWORD PTR op_type$[rsp], 131072		; 00020000H
	jmp	SHORT $LN18@idata_nofi
$LN17@idata_nofi:

; 860  :         //else if ( value <= SHRT_MAX && value >= SHRT_MIN )
; 861  :         /* v2.04: range FFFF0000-FFFF7FFF is also acceptable for 16-bit */
; 862  :         //else if ( value <= USHRT_MAX && value >= SHRT_MIN )
; 863  :         /* v2.04b: HJWASMR needs a 1L */
; 864  :         //else if( value <= USHRT_MAX && value >= - (USHRT_MAX+1) )
; 865  :         /* v2.07: HJWASMR needs 0L before the - op */
; 866  :         //else if( value <= USHRT_MAX && value >= - USHRT_MAX )
; 867  :         else if( value <= USHRT_MAX && value >= 0L - USHRT_MAX )

	cmp	DWORD PTR value$[rsp], 65535		; 0000ffffH
	jg	SHORT $LN19@idata_nofi
	cmp	DWORD PTR value$[rsp], -65535		; ffffffffffff0001H
	jl	SHORT $LN19@idata_nofi

; 868  :             op_type = OP_I16;

	mov	DWORD PTR op_type$[rsp], 262144		; 00040000H
	jmp	SHORT $LN20@idata_nofi
$LN19@idata_nofi:

; 869  :         else {
; 870  :             op_type = OP_I32;

	mov	DWORD PTR op_type$[rsp], 524288		; 00080000H
$LN20@idata_nofi:
$LN18@idata_nofi:
$LN12@idata_nofi:

; 871  :         }
; 872  :     }
; 873  : 
; 874  :     switch ( CodeInfo->token ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv188[rsp], eax
	cmp	DWORD PTR tv188[rsp], 565		; 00000235H
	je	$LN30@idata_nofi
	cmp	DWORD PTR tv188[rsp], 601		; 00000259H
	je	SHORT $LN21@idata_nofi
	cmp	DWORD PTR tv188[rsp], 603		; 0000025bH
	je	$LN27@idata_nofi
	jmp	$LN4@idata_nofi
$LN21@idata_nofi:

; 875  :     case T_PUSH:
; 876  :         if ( opndx->explicit == FALSE ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN22@idata_nofi

; 877  :             if ( CodeInfo->Ofssize > USE16 && op_type == OP_I16 )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jle	SHORT $LN23@idata_nofi
	cmp	DWORD PTR op_type$[rsp], 262144		; 00040000H
	jne	SHORT $LN23@idata_nofi

; 878  :                 op_type = OP_I32;

	mov	DWORD PTR op_type$[rsp], 524288		; 00080000H
$LN23@idata_nofi:
$LN22@idata_nofi:

; 879  :         }
; 880  :         if ( op_type == OP_I16 )

	cmp	DWORD PTR op_type$[rsp], 262144		; 00040000H
	jne	SHORT $LN24@idata_nofi

; 881  :             CodeInfo->prefix.opsiz = OPSIZE16( CodeInfo );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN35@idata_nofi
	mov	DWORD PTR tv202[rsp], 1
	jmp	SHORT $LN36@idata_nofi
$LN35@idata_nofi:
	mov	DWORD PTR tv202[rsp], 0
$LN36@idata_nofi:
	movzx	eax, BYTE PTR tv202[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
	jmp	SHORT $LN25@idata_nofi
$LN24@idata_nofi:

; 882  :         else if ( op_type == OP_I32 )

	cmp	DWORD PTR op_type$[rsp], 524288		; 00080000H
	jne	SHORT $LN26@idata_nofi

; 883  :             CodeInfo->prefix.opsiz = OPSIZE32( CodeInfo );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN37@idata_nofi
	mov	DWORD PTR tv214[rsp], 0
	jmp	SHORT $LN38@idata_nofi
$LN37@idata_nofi:
	mov	DWORD PTR tv214[rsp], 1
$LN38@idata_nofi:
	movzx	eax, BYTE PTR tv214[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN26@idata_nofi:
$LN25@idata_nofi:

; 884  :         break;

	jmp	SHORT $LN4@idata_nofi
$LN27@idata_nofi:

; 885  :     case T_PUSHW:
; 886  :         if ( op_type != OP_I32 ) {

	cmp	DWORD PTR op_type$[rsp], 524288		; 00080000H
	je	SHORT $LN28@idata_nofi

; 887  :             op_type = OP_I16;

	mov	DWORD PTR op_type$[rsp], 262144		; 00040000H

; 888  :             if( (int_8)value == (int_16)value ) {

	movsx	eax, BYTE PTR value$[rsp]
	movsx	ecx, WORD PTR value$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN29@idata_nofi

; 889  :                 op_type = OP_I8;

	mov	DWORD PTR op_type$[rsp], 131072		; 00020000H
$LN29@idata_nofi:
$LN28@idata_nofi:

; 890  :             }
; 891  :         }
; 892  :         break;

	jmp	SHORT $LN4@idata_nofi
$LN30@idata_nofi:

; 893  :     case T_PUSHD:
; 894  :         if ( op_type == OP_I16 )

	cmp	DWORD PTR op_type$[rsp], 262144		; 00040000H
	jne	SHORT $LN31@idata_nofi

; 895  :             op_type = OP_I32;

	mov	DWORD PTR op_type$[rsp], 524288		; 00080000H
$LN31@idata_nofi:
$LN4@idata_nofi:

; 896  :         break;
; 897  :     }
; 898  : 
; 899  :     /* v2.11: set the wide-bit if a mem_type size of > BYTE is set???
; 900  :      * actually, it should only be set if immediate is second operand
; 901  :      * ( and first operand is a memory ref with a size > 1 )
; 902  :      */
; 903  :     if ( CurrOpnd == OPND2 )

	cmp	DWORD PTR CurrOpnd$[rsp], 1
	jne	SHORT $LN32@idata_nofi

; 904  :         if ( !(CodeInfo->mem_type & MT_SPECIAL) && ( CodeInfo->mem_type & MT_SIZE_MASK ) )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN33@idata_nofi
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 31
	test	eax, eax
	je	SHORT $LN33@idata_nofi

; 905  :             CodeInfo->iswide = 1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al
$LN33@idata_nofi:
$LN32@idata_nofi:

; 906  : 
; 907  :     CodeInfo->opnd[CurrOpnd].type = op_type;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR op_type$[rsp]
	mov	DWORD PTR [rcx+rax+32], edx

; 908  :     DebugMsg1(("idata_nofixup exit, op_type=%" I32_SPEC "X\n", op_type ));

	mov	edx, DWORD PTR op_type$[rsp]
	lea	rcx, OFFSET FLAT:$SG11816
	call	DoDebugMsg1

; 909  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@idata_nofi:

; 910  : }

	add	rsp, 88					; 00000058H
	ret	0
idata_nofixup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
temp$1 = 32
sym$ = 40
opndx$ = 64
CodeInfo$ = 72
segm_override PROC

; 745  : {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 746  :     struct asym      *sym;
; 747  : 
; 748  :     if( opndx->override != NULL ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	$LN2@segm_overr

; 749  :         if( opndx->override->token == T_REG ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+48]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 2
	jne	$LN3@segm_overr

; 750  :             int temp = GetRegNo( opndx->override->tokval );

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	DWORD PTR temp$1[rsp], eax

; 751  :             if ( SegAssumeTable[temp].error ) {

	movsxd	rax, DWORD PTR temp$1[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SegAssumeTable
	movzx	eax, BYTE PTR [rcx+rax+8]
	test	eax, eax
	je	SHORT $LN5@segm_overr

; 752  :                 DebugMsg(("segm_override: assume error, reg=%u\n", temp ));

	mov	edx, DWORD PTR temp$1[rsp]
	lea	rcx, OFFSET FLAT:$SG11762
	call	DoDebugMsg

; 753  :                 return( EmitError( USE_OF_REGISTER_ASSUMED_TO_ERROR ) );

	mov	ecx, 183				; 000000b7H
	call	EmitError
	jmp	$LN1@segm_overr
$LN5@segm_overr:

; 754  :             }
; 755  : #if AMD64_SUPPORT
; 756  :             /* ES,CS,SS and DS overrides are invalid in 64-bit */
; 757  :             if ( CodeInfo && CodeInfo->Ofssize == USE64 && temp < ASSUME_FS ) {

	cmp	QWORD PTR CodeInfo$[rsp], 0
	je	SHORT $LN6@segm_overr
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	jne	SHORT $LN6@segm_overr
	cmp	DWORD PTR temp$1[rsp], 4
	jge	SHORT $LN6@segm_overr

; 758  :                 return( EmitError( ILLEGAL_USE_OF_SEGMENT_REGISTER ) );

	mov	ecx, 275				; 00000113H
	call	EmitError
	jmp	SHORT $LN1@segm_overr
$LN6@segm_overr:

; 759  :             }
; 760  : #endif
; 761  :             sym = GetOverrideAssume( temp );

	mov	ecx, DWORD PTR temp$1[rsp]
	call	GetOverrideAssume
	mov	QWORD PTR sym$[rsp], rax

; 762  :             if ( CodeInfo ) {

	cmp	QWORD PTR CodeInfo$[rsp], 0
	je	SHORT $LN7@segm_overr

; 763  :                 /* hack: save the previous reg override value (needed for CMPS) */
; 764  :                 LastRegOverride = CodeInfo->prefix.RegOverride;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR LastRegOverride, eax

; 765  :                 CodeInfo->prefix.RegOverride = temp;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR temp$1[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN7@segm_overr:

; 766  :             }
; 767  :         } else {

	jmp	SHORT $LN4@segm_overr
$LN3@segm_overr:

; 768  :             sym = SymSearch( opndx->override->string_ptr );

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR [rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax
$LN4@segm_overr:

; 769  :         }
; 770  :         if ( sym && ( sym->state == SYM_GRP || sym->state == SYM_SEG ))

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN8@segm_overr
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 4
	je	SHORT $LN9@segm_overr
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 3
	jne	SHORT $LN8@segm_overr
$LN9@segm_overr:

; 771  :             SegOverride = sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR SegOverride, rax
$LN8@segm_overr:
$LN2@segm_overr:

; 772  :     }
; 773  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@segm_overr:

; 774  : }

	add	rsp, 56					; 00000038H
	ret	0
segm_override ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
mod_field$ = 48
rm_field$ = 49
base_reg$ = 50
idx_reg$ = 51
rex$ = 52
bit3_idx$ = 53
bit3_base$ = 54
temp$ = 56
tv228 = 60
tv341 = 64
tv186 = 68
tv70 = 72
CodeInfo$ = 96
CurrOpnd$ = 104
ss$ = 112
index$ = 120
base$ = 128
sym$ = 136
set_rm_sib PROC

; 506  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 507  :     int                 temp;
; 508  :     unsigned char       mod_field;
; 509  :     unsigned char       rm_field;
; 510  :     unsigned char       base_reg;
; 511  :     unsigned char       idx_reg;
; 512  : #if AMD64_SUPPORT
; 513  :     unsigned char       bit3_base;
; 514  :     unsigned char       bit3_idx;
; 515  :     unsigned char       rex;
; 516  : #endif
; 517  : 
; 518  :     DebugMsg1(("set_rm_sib(scale=%u, index=%d, base=%d, sym=%s) enter [CI.adrsiz=%u]\n", 1 << (ss >> 6), index, base, sym ? sym->name : "NULL", CodeInfo->prefix.adrsiz ));

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN58@set_rm_sib
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv70[rsp], rax
	jmp	SHORT $LN59@set_rm_sib
$LN58@set_rm_sib:
	lea	rax, OFFSET FLAT:$SG11689
	mov	QWORD PTR tv70[rsp], rax
$LN59@set_rm_sib:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	movsx	ecx, BYTE PTR ss$[rsp]
	sar	ecx, 6
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR tv70[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR base$[rsp]
	mov	r8d, DWORD PTR index$[rsp]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG11690
	call	DoDebugMsg1

; 519  : 
; 520  :     /* clear mod */
; 521  :     rm_field = 0;

	mov	BYTE PTR rm_field$[rsp], 0

; 522  :     CodeInfo->basetype = base;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR base$[rsp]
	mov	BYTE PTR [rax+108], cl

; 523  : #if AMD64_SUPPORT
; 524  :     bit3_base = 0;

	mov	BYTE PTR bit3_base$[rsp], 0

; 525  :     bit3_idx = 0;

	mov	BYTE PTR bit3_idx$[rsp], 0

; 526  :     rex = 0;

	mov	BYTE PTR rex$[rsp], 0

; 527  : #endif
; 528  :     if( CodeInfo->opnd[CurrOpnd].InsFixup != NULL ) { /* symbolic displacement given? */

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	je	SHORT $LN6@set_rm_sib

; 529  :         mod_field = MOD_10;

	mov	BYTE PTR mod_field$[rsp], 128		; 00000080H
	jmp	SHORT $LN7@set_rm_sib
$LN6@set_rm_sib:

; 530  :     } else if((CodeInfo->opnd[CurrOpnd].data32l == 0) ||( base == T_RIP)) { /* no displacement (or 0) */

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 0
	je	SHORT $LN10@set_rm_sib
	cmp	DWORD PTR base$[rsp], 131		; 00000083H
	jne	SHORT $LN8@set_rm_sib
$LN10@set_rm_sib:

; 531  :         mod_field = MOD_00;

	mov	BYTE PTR mod_field$[rsp], 0

; 532  :     } else if( ( CodeInfo->opnd[CurrOpnd].data32l > SCHAR_MAX )

	jmp	SHORT $LN9@set_rm_sib
$LN8@set_rm_sib:

; 533  :        || ( CodeInfo->opnd[CurrOpnd].data32l < SCHAR_MIN ) ) {

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 127		; 0000007fH
	jg	SHORT $LN13@set_rm_sib
	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], -128		; ffffffffffffff80H
	jge	SHORT $LN11@set_rm_sib
$LN13@set_rm_sib:

; 534  :         mod_field = MOD_10; /* full size displacement */

	mov	BYTE PTR mod_field$[rsp], 128		; 00000080H

; 535  :     } else {

	jmp	SHORT $LN12@set_rm_sib
$LN11@set_rm_sib:

; 536  :         mod_field = MOD_01; /* byte size displacement */

	mov	BYTE PTR mod_field$[rsp], 64		; 00000040H
$LN12@set_rm_sib:
$LN9@set_rm_sib:
$LN7@set_rm_sib:

; 537  :     }
; 538  : 
; 539  :     if( ( index == EMPTY ) && ( base == EMPTY ) ) {

	cmp	DWORD PTR index$[rsp], -2
	jne	$LN14@set_rm_sib
	cmp	DWORD PTR base$[rsp], -2
	jne	$LN14@set_rm_sib

; 540  :         /* direct memory.
; 541  :          * clear the rightmost 3 bits
; 542  :          */
; 543  :         CodeInfo->isdirect = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	or	al, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al

; 544  :         mod_field = MOD_00;

	mov	BYTE PTR mod_field$[rsp], 0

; 545  : 
; 546  :         /* default is DS:[], DS: segment override is not needed */
; 547  :         seg_override( CodeInfo, T_DS, sym, TRUE );

	mov	r9b, 1
	mov	r8, QWORD PTR sym$[rsp]
	mov	edx, 28
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	seg_override

; 548  : 
; 549  :         DebugMsg1(( "set_rm_sib: direct addressing, CI.Ofssize=%u / adrsize=%u / data=%" I32_SPEC "X\n",

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 1
	movzx	ecx, cl
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	movzx	edx, BYTE PTR [rdx+106]
	mov	r8, QWORD PTR CodeInfo$[rsp]
	mov	r9d, DWORD PTR [r8+rax+40]
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:$SG11701
	call	DoDebugMsg1

; 550  :                    CodeInfo->Ofssize, CodeInfo->prefix.adrsiz, CodeInfo->opnd[CurrOpnd].data32l ));
; 551  :         //if( !IS_ADDR32( CodeInfo ) ) {
; 552  :         if( ( CodeInfo->Ofssize == USE16 && CodeInfo->prefix.adrsiz == 0 ) ||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jne	SHORT $LN19@set_rm_sib
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@set_rm_sib
$LN19@set_rm_sib:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 1
	jne	$LN16@set_rm_sib
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN16@set_rm_sib
$LN18@set_rm_sib:

; 553  :             ( CodeInfo->Ofssize == USE32 && CodeInfo->prefix.adrsiz == 1 )) {
; 554  :             if( !InWordRange( CodeInfo->opnd[CurrOpnd].data32l ) ) {

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 65535		; 0000ffffH
	jg	SHORT $LN60@set_rm_sib
	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], -65535		; ffffffffffff0001H
	jl	SHORT $LN60@set_rm_sib
	mov	DWORD PTR tv186[rsp], 1
	jmp	SHORT $LN61@set_rm_sib
$LN60@set_rm_sib:
	mov	DWORD PTR tv186[rsp], 0
$LN61@set_rm_sib:
	cmp	DWORD PTR tv186[rsp], 0
	jne	SHORT $LN20@set_rm_sib

; 555  :                 /* expect 16-bit but got 32-bit address */
; 556  :                 DebugMsg1(( "set_rm_sib: error, Ofssize=%u, adrsize=%u, data=%" I32_SPEC "X\n",

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 1
	movzx	ecx, cl
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	movzx	edx, BYTE PTR [rdx+106]
	mov	r8, QWORD PTR CodeInfo$[rsp]
	mov	r9d, DWORD PTR [r8+rax+40]
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:$SG11707
	call	DoDebugMsg1

; 557  :                         CodeInfo->Ofssize, CodeInfo->prefix.adrsiz, CodeInfo->opnd[CurrOpnd].data32l ));
; 558  :                 return( EmitError( MAGNITUDE_OF_OFFSET_EXCEEDS_16BIT ) );

	mov	ecx, 58					; 0000003aH
	call	EmitError
	jmp	$LN1@set_rm_sib
$LN20@set_rm_sib:

; 559  :             }
; 560  :             rm_field = RM_D16; /* D16=110b */

	mov	BYTE PTR rm_field$[rsp], 6

; 561  :         } else {

	jmp	SHORT $LN17@set_rm_sib
$LN16@set_rm_sib:

; 562  :             rm_field = RM_D32; /* D32=101b */

	mov	BYTE PTR rm_field$[rsp], 5

; 563  : #if AMD64_SUPPORT
; 564  :             /* v2.03: the non-RIP encoding for 64bit uses a redundant SIB mode (base=none, index=none) */
; 565  :             /* v2.11: always use 64-bit non-RIP addressing if no fixup has been created. */
; 566  :             //if ( CodeInfo->Ofssize == USE64 && CodeInfo->prefix.RegOverride != EMPTY && SegOverride != &ModuleInfo.flat_grp->sym ) {
; 567  :             if ( CodeInfo->Ofssize == USE64 && CodeInfo->opnd[CurrOpnd].InsFixup == NULL ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	jne	SHORT $LN21@set_rm_sib
	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	jne	SHORT $LN21@set_rm_sib

; 568  :                 DebugMsg1(( "set_rm_sib: 64-bit, no fixup, data64=%" I64_SPEC "X\n", CodeInfo->opnd[CurrOpnd].data64 ));

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+40]
	lea	rcx, OFFSET FLAT:$SG11709
	call	DoDebugMsg1

; 569  :                 rm_field = RM_SIB;

	mov	BYTE PTR rm_field$[rsp], 4

; 570  :                 CodeInfo->sib = 0x25; /* IIIBBB, base=101b, index=100b */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+105], 37			; 00000025H
$LN21@set_rm_sib:
$LN17@set_rm_sib:

; 571  :             }
; 572  : #endif
; 573  :         }
; 574  :         DebugMsg1(("set_rm_sib, direct, CodeInfo->prefix.adrsiz=%u\n", CodeInfo->prefix.adrsiz ));

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11710
	call	DoDebugMsg1
	jmp	$LN15@set_rm_sib
$LN14@set_rm_sib:

; 575  :     } else if( ( index == EMPTY ) && ( base != EMPTY ) ) {

	cmp	DWORD PTR index$[rsp], -2
	jne	$LN22@set_rm_sib
	cmp	DWORD PTR base$[rsp], -2
	je	$LN22@set_rm_sib

; 576  :         /* for SI, DI and BX: default is DS:[],
; 577  :          * DS: segment override is not needed
; 578  :          * for BP: default is SS:[], SS: segment override is not needed
; 579  :          */
; 580  :         switch( base ) {

	mov	eax, DWORD PTR base$[rsp]
	mov	DWORD PTR tv228[rsp], eax
	cmp	DWORD PTR tv228[rsp], 12
	je	SHORT $LN29@set_rm_sib
	cmp	DWORD PTR tv228[rsp], 14
	je	SHORT $LN26@set_rm_sib
	cmp	DWORD PTR tv228[rsp], 15
	je	SHORT $LN24@set_rm_sib
	cmp	DWORD PTR tv228[rsp], 16
	je	SHORT $LN25@set_rm_sib
	jmp	SHORT $LN30@set_rm_sib
$LN24@set_rm_sib:

; 581  :         case T_SI:
; 582  :             rm_field = RM_SI; /* 4 */

	mov	BYTE PTR rm_field$[rsp], 4

; 583  :             break;

	jmp	$LN2@set_rm_sib
$LN25@set_rm_sib:

; 584  :         case T_DI:
; 585  :             rm_field = RM_DI; /* 5 */

	mov	BYTE PTR rm_field$[rsp], 5

; 586  :             break;

	jmp	$LN2@set_rm_sib
$LN26@set_rm_sib:

; 587  :         case T_BP:
; 588  :             rm_field = RM_BP; /* 6 */

	mov	BYTE PTR rm_field$[rsp], 6

; 589  :             if( mod_field == MOD_00 ) {

	movzx	eax, BYTE PTR mod_field$[rsp]
	test	eax, eax
	jne	SHORT $LN27@set_rm_sib

; 590  :                if (base != T_RIP) mod_field = MOD_01;

	cmp	DWORD PTR base$[rsp], 131		; 00000083H
	je	SHORT $LN28@set_rm_sib
	mov	BYTE PTR mod_field$[rsp], 64		; 00000040H
$LN28@set_rm_sib:
$LN27@set_rm_sib:

; 591  :             }
; 592  :             break;

	jmp	$LN2@set_rm_sib
$LN29@set_rm_sib:

; 593  :         case T_BX:
; 594  :             rm_field = RM_BX; /* 7 */

	mov	BYTE PTR rm_field$[rsp], 7

; 595  :             break;

	jmp	$LN2@set_rm_sib
$LN30@set_rm_sib:

; 596  :         default: /* for 386 and up */
; 597  :             base_reg = GetRegNo( base );

	movsxd	rax, DWORD PTR base$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR base_reg$[rsp], al

; 598  : #if AMD64_SUPPORT
; 599  :             if (base_reg == 16)

	movzx	eax, BYTE PTR base_reg$[rsp]
	cmp	eax, 16
	jne	SHORT $LN31@set_rm_sib

; 600  :                base_reg=5;  //RIP bytval=16 but we need 5 added by habran

	mov	BYTE PTR base_reg$[rsp], 5
$LN31@set_rm_sib:

; 601  :             bit3_base = base_reg >> 3;

	movzx	eax, BYTE PTR base_reg$[rsp]
	sar	eax, 3
	mov	BYTE PTR bit3_base$[rsp], al

; 602  :             base_reg &= BIT_012;

	movzx	eax, BYTE PTR base_reg$[rsp]
	and	eax, 7
	mov	BYTE PTR base_reg$[rsp], al

; 603  : #endif
; 604  :             rm_field = base_reg;

	movzx	eax, BYTE PTR base_reg$[rsp]
	mov	BYTE PTR rm_field$[rsp], al

; 605  :             DebugMsg1(("set_rm_sib: base_reg is %u\n", base_reg ));

	movzx	eax, BYTE PTR base_reg$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11721
	call	DoDebugMsg1

; 606  :             if ( base_reg == 4 ) {

	movzx	eax, BYTE PTR base_reg$[rsp]
	cmp	eax, 4
	jne	SHORT $LN32@set_rm_sib

; 607  :                 /* 4 is RSP/ESP or R12/R12D, which must use SIB encoding.
; 608  :                  * SSIIIBBB, ss = 00, index = 100b ( no index ), base = 100b ( ESP ) */
; 609  :                 CodeInfo->sib = 0x24;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+105], 36			; 00000024H
	jmp	SHORT $LN33@set_rm_sib
$LN32@set_rm_sib:

; 610  :             } else if ( base_reg == 5 && mod_field == MOD_00 ) {

	movzx	eax, BYTE PTR base_reg$[rsp]
	cmp	eax, 5
	jne	SHORT $LN34@set_rm_sib
	movzx	eax, BYTE PTR mod_field$[rsp]
	test	eax, eax
	jne	SHORT $LN34@set_rm_sib

; 611  :                 /* 5 is [E|R]BP or R13[D]. Needs displacement */
; 612  :                // 5 is also RIP register but doesn't need MOD_01
; 613  :                 if (base != T_RIP)  //added by habran

	cmp	DWORD PTR base$[rsp], 131		; 00000083H
	je	SHORT $LN35@set_rm_sib

; 614  :                  mod_field = MOD_01; /* byte size displacement */

	mov	BYTE PTR mod_field$[rsp], 64		; 00000040H
$LN35@set_rm_sib:
$LN34@set_rm_sib:
$LN33@set_rm_sib:

; 615  :             }
; 616  : #if AMD64_SUPPORT
; 617  :             /* v2.02 */
; 618  :             //rex = ( bit3_base << 2 ); /* set REX_R */
; 619  :             rex = bit3_base; /* set REX_R */

	movzx	eax, BYTE PTR bit3_base$[rsp]
	mov	BYTE PTR rex$[rsp], al
$LN2@set_rm_sib:

; 620  : #endif
; 621  :         }
; 622  : #if AMD64_SUPPORT
; 623  :         DebugMsg1(("set_rm_sib, indirect with base, mod_field=%X, rm_field=%X, rex=%X\n", mod_field, rm_field, rex ));

	movzx	eax, BYTE PTR rex$[rsp]
	movzx	ecx, BYTE PTR rm_field$[rsp]
	movzx	edx, BYTE PTR mod_field$[rsp]
	mov	r9d, eax
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:$SG11726
	call	DoDebugMsg1

; 624  : #else
; 625  :         DebugMsg1(("set_rm_sib, indirect with base, rm_field=%X\n", rm_field ));
; 626  : #endif
; 627  :         seg_override( CodeInfo, base, sym, FALSE );

	xor	r9d, r9d
	mov	r8, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR base$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	seg_override
	jmp	$LN23@set_rm_sib
$LN22@set_rm_sib:

; 628  :     } else if( ( index != EMPTY ) && ( base == EMPTY ) ) {

	cmp	DWORD PTR index$[rsp], -2
	je	$LN36@set_rm_sib
	cmp	DWORD PTR base$[rsp], -2
	jne	SHORT $LN36@set_rm_sib

; 629  :         idx_reg = GetRegNo( index );

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR idx_reg$[rsp], al

; 630  : #if AMD64_SUPPORT
; 631  :         bit3_idx = idx_reg >> 3;

	movzx	eax, BYTE PTR idx_reg$[rsp]
	sar	eax, 3
	mov	BYTE PTR bit3_idx$[rsp], al

; 632  :         idx_reg &= BIT_012;

	movzx	eax, BYTE PTR idx_reg$[rsp]
	and	eax, 7
	mov	BYTE PTR idx_reg$[rsp], al

; 633  : #endif
; 634  :         /* mod field is 00 */
; 635  :         mod_field = MOD_00;

	mov	BYTE PTR mod_field$[rsp], 0

; 636  :         /* s-i-b is present ( r/m = 100b ) */
; 637  :         rm_field = RM_SIB;

	mov	BYTE PTR rm_field$[rsp], 4

; 638  :         /* scale factor, index, base ( 0x05 => no base reg ) */
; 639  :         CodeInfo->sib = ( ss | ( idx_reg << 3 ) | 0x05 );

	movsx	eax, BYTE PTR ss$[rsp]
	movzx	ecx, BYTE PTR idx_reg$[rsp]
	shl	ecx, 3
	or	eax, ecx
	or	eax, 5
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+105], al

; 640  : #if AMD64_SUPPORT
; 641  :         rex = (bit3_idx << 1); /* set REX_X */

	movzx	eax, BYTE PTR bit3_idx$[rsp]
	shl	eax, 1
	mov	BYTE PTR rex$[rsp], al

; 642  : #endif
; 643  :         /* default is DS:[], DS: segment override is not needed */
; 644  :         seg_override( CodeInfo, T_DS, sym, FALSE );

	xor	r9d, r9d
	mov	r8, QWORD PTR sym$[rsp]
	mov	edx, 28
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	seg_override

; 645  :     } else {

	jmp	$LN37@set_rm_sib
$LN36@set_rm_sib:

; 646  :         /* base != EMPTY && index != EMPTY */
; 647  :         base_reg = GetRegNo( base );

	movsxd	rax, DWORD PTR base$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR base_reg$[rsp], al

; 648  :         idx_reg  = GetRegNo( index );

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR idx_reg$[rsp], al

; 649  :         if ( base == T_RIP)

	cmp	DWORD PTR base$[rsp], 131		; 00000083H
	jne	SHORT $LN38@set_rm_sib

; 650  :           base_reg = 0x5;

	mov	BYTE PTR base_reg$[rsp], 5
$LN38@set_rm_sib:

; 651  : #if AMD64_SUPPORT
; 652  :         bit3_base = base_reg >> 3;

	movzx	eax, BYTE PTR base_reg$[rsp]
	sar	eax, 3
	mov	BYTE PTR bit3_base$[rsp], al

; 653  :         bit3_idx  = idx_reg  >> 3;

	movzx	eax, BYTE PTR idx_reg$[rsp]
	sar	eax, 3
	mov	BYTE PTR bit3_idx$[rsp], al

; 654  :         base_reg &= BIT_012;

	movzx	eax, BYTE PTR base_reg$[rsp]
	and	eax, 7
	mov	BYTE PTR base_reg$[rsp], al

; 655  :         idx_reg  &= BIT_012;

	movzx	eax, BYTE PTR idx_reg$[rsp]
	and	eax, 7
	mov	BYTE PTR idx_reg$[rsp], al

; 656  : #endif
; 657  :         if ( ( GetSflagsSp( base ) & GetSflagsSp( index ) & SFR_SIZMSK ) == 0 ) {

	movsxd	rax, DWORD PTR base$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movsxd	rdx, DWORD PTR index$[rsp]
	imul	rdx, rdx, 12
	lea	r8, OFFSET FLAT:SpecialTable
	mov	edx, DWORD PTR [r8+rdx+4]
	mov	eax, DWORD PTR [rcx+rax+4]
	and	eax, edx
	and	eax, 31
	test	eax, eax
	jne	SHORT $LN39@set_rm_sib

; 658  : #if AVXSUPP
; 659  :            CodeInfo->indextype = GetValueSp( index );

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR [rdx+132], eax

; 660  :            if (CodeInfo->indextype == OP_XMM || CodeInfo->indextype == OP_YMM || CodeInfo->indextype == OP_ZMM){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+132], 32			; 00000020H
	je	SHORT $LN42@set_rm_sib
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+132], 128		; 00000080H
	je	SHORT $LN42@set_rm_sib
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+132], 256		; 00000100H
	jne	SHORT $LN40@set_rm_sib
$LN42@set_rm_sib:

; 661  :              ;
; 662  :            }

	jmp	SHORT $LN41@set_rm_sib
$LN40@set_rm_sib:

; 663  :           else
; 664  : #endif
; 665  :           return( EmitError( CANNOT_MIX_16_AND_32_BIT_REGISTERS ) );

	mov	ecx, 38					; 00000026H
	call	EmitError
	jmp	$LN1@set_rm_sib
$LN41@set_rm_sib:
$LN39@set_rm_sib:

; 666  :         }
; 667  :   
; 668  :         switch( index ) {

	mov	eax, DWORD PTR index$[rsp]
	mov	DWORD PTR tv341[rsp], eax
	mov	eax, DWORD PTR tv341[rsp]
	sub	eax, 12
	mov	DWORD PTR tv341[rsp], eax
	cmp	DWORD PTR tv341[rsp], 119		; 00000077H
	ja	$LN48@set_rm_sib
	movsxd	rax, DWORD PTR tv341[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN62@set_rm_sib[rcx+rax]
	mov	eax, DWORD PTR $LN63@set_rm_sib[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN43@set_rm_sib:

; 669  :         case T_BX:
; 670  :         case T_BP:
; 671  :             if( ( temp = comp_mem16( index, base ) ) == ERROR )

	mov	edx, DWORD PTR base$[rsp]
	mov	ecx, DWORD PTR index$[rsp]
	call	comp_mem16
	mov	DWORD PTR temp$[rsp], eax
	cmp	DWORD PTR temp$[rsp], -1
	jne	SHORT $LN44@set_rm_sib

; 672  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@set_rm_sib
$LN44@set_rm_sib:

; 673  :             rm_field = temp;

	movzx	eax, BYTE PTR temp$[rsp]
	mov	BYTE PTR rm_field$[rsp], al

; 674  :             seg_override( CodeInfo, index, sym, FALSE );

	xor	r9d, r9d
	mov	r8, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	seg_override

; 675  :             break;

	jmp	$LN4@set_rm_sib
$LN45@set_rm_sib:

; 676  :         case T_SI:
; 677  :         case T_DI:
; 678  :             if( ( temp = comp_mem16( base, index ) ) == ERROR )

	mov	edx, DWORD PTR index$[rsp]
	mov	ecx, DWORD PTR base$[rsp]
	call	comp_mem16
	mov	DWORD PTR temp$[rsp], eax
	cmp	DWORD PTR temp$[rsp], -1
	jne	SHORT $LN46@set_rm_sib

; 679  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@set_rm_sib
$LN46@set_rm_sib:

; 680  :             rm_field = temp;

	movzx	eax, BYTE PTR temp$[rsp]
	mov	BYTE PTR rm_field$[rsp], al

; 681  :             seg_override( CodeInfo, base, sym, FALSE );

	xor	r9d, r9d
	mov	r8, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR base$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	seg_override

; 682  :             break;

	jmp	$LN4@set_rm_sib
$LN47@set_rm_sib:

; 683  : #if AMD64_SUPPORT
; 684  :         case T_RSP:
; 685  :         case T_RIP:      //added by habran
; 686  : #endif
; 687  :         case T_ESP:
; 688  :             //EmitErr( CANNOT_BE_USED_AS_INDEX_REGISTER, ??? );
; 689  :             return( EmitError( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	EmitError
	jmp	$LN1@set_rm_sib
$LN48@set_rm_sib:

; 690  :         default:
; 691  :             if( base_reg == 5 ) { /* v2.03: EBP/RBP/R13/R13D? */

	movzx	eax, BYTE PTR base_reg$[rsp]
	cmp	eax, 5
	jne	SHORT $LN49@set_rm_sib

; 692  :                 if( mod_field == MOD_00 ) {

	movzx	eax, BYTE PTR mod_field$[rsp]
	test	eax, eax
	jne	SHORT $LN50@set_rm_sib

; 693  :                     if (base != T_RIP) mod_field = MOD_01;     //ADDED BY HABRAN

	cmp	DWORD PTR base$[rsp], 131		; 00000083H
	je	SHORT $LN51@set_rm_sib
	mov	BYTE PTR mod_field$[rsp], 64		; 00000040H
$LN51@set_rm_sib:
$LN50@set_rm_sib:
$LN49@set_rm_sib:

; 694  :                 }
; 695  :             }
; 696  : 
; 697  :             /* s-i-b is present ( r/m = 100b ) */
; 698  :             rm_field |= RM_SIB;

	movzx	eax, BYTE PTR rm_field$[rsp]
	or	eax, 4
	mov	BYTE PTR rm_field$[rsp], al

; 699  :             CodeInfo->sib = ( ss | idx_reg << 3 | base_reg );

	movsx	eax, BYTE PTR ss$[rsp]
	movzx	ecx, BYTE PTR idx_reg$[rsp]
	shl	ecx, 3
	or	eax, ecx
	movzx	ecx, BYTE PTR base_reg$[rsp]
	or	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+105], al

; 700  : #if AMD64_SUPPORT
; 701  :             rex = (bit3_idx << 1) + (bit3_base); /* set REX_X + REX_B */

	movzx	eax, BYTE PTR bit3_idx$[rsp]
	movzx	ecx, BYTE PTR bit3_base$[rsp]
	lea	eax, DWORD PTR [rcx+rax*2]
	mov	BYTE PTR rex$[rsp], al

; 702  : #endif
; 703  :             seg_override( CodeInfo, base, sym, FALSE );

	xor	r9d, r9d
	mov	r8, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR base$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	seg_override
$LN4@set_rm_sib:

; 704  :         } /* end switch(index) */
; 705  : #if AMD64_SUPPORT
; 706  :         DebugMsg1(("set_rm_sib, indirect, base+index: mod_field=%X, rm_field=%X, rex=%X\n", mod_field, rm_field, rex ));

	movzx	eax, BYTE PTR rex$[rsp]
	movzx	ecx, BYTE PTR rm_field$[rsp]
	movzx	edx, BYTE PTR mod_field$[rsp]
	mov	r9d, eax
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:$SG11743
	call	DoDebugMsg1
$LN37@set_rm_sib:
$LN23@set_rm_sib:
$LN15@set_rm_sib:

; 707  : #else
; 708  :         DebugMsg1(("set_rm_sib, indirect, base+index: rm_field=%X\n", rm_field ));
; 709  : #endif
; 710  :     }
; 711  :     if( CurrOpnd == OPND2 ) {

	cmp	DWORD PTR CurrOpnd$[rsp], 1
	jne	SHORT $LN52@set_rm_sib

; 712  :         /* shift the register field to left by 3 bit */
; 713  :        if ( base == T_RIP )      //added by habran

	cmp	DWORD PTR base$[rsp], 131		; 00000083H
	jne	SHORT $LN54@set_rm_sib

; 714  :           mod_field &= BIT_012;

	movzx	eax, BYTE PTR mod_field$[rsp]
	and	eax, 7
	mov	BYTE PTR mod_field$[rsp], al
$LN54@set_rm_sib:

; 715  :           CodeInfo->rm_byte = mod_field | ( rm_field << 3 ) | ( CodeInfo->rm_byte & BIT_012 );

	movzx	eax, BYTE PTR mod_field$[rsp]
	movzx	ecx, BYTE PTR rm_field$[rsp]
	shl	ecx, 3
	or	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+104]
	and	ecx, 7
	or	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+104], al

; 716  : 
; 717  : #if AMD64_SUPPORT
; 718  :         /* v2.02: exchange B and R, keep X */
; 719  :         //CodeInfo->prefix.rex |= (rex >> 2 );
; 720  :         CodeInfo->prefix.rex |= ( ( rex >> 2 ) | ( rex & REX_X ) | (( rex & 1) << 2 ) );

	movzx	eax, BYTE PTR rex$[rsp]
	sar	eax, 2
	movzx	ecx, BYTE PTR rex$[rsp]
	and	ecx, 2
	or	eax, ecx
	movzx	ecx, BYTE PTR rex$[rsp]
	and	ecx, 1
	shl	ecx, 2
	or	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+8]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+8], al
	jmp	SHORT $LN53@set_rm_sib
$LN52@set_rm_sib:

; 721  : #endif
; 722  :     } else if( CurrOpnd == OPND1 ) {

	cmp	DWORD PTR CurrOpnd$[rsp], 0
	jne	SHORT $LN55@set_rm_sib

; 723  :        if ( base == T_RIP )     //added by habran

	cmp	DWORD PTR base$[rsp], 131		; 00000083H
	jne	SHORT $LN56@set_rm_sib

; 724  :           mod_field &= BIT_012;

	movzx	eax, BYTE PTR mod_field$[rsp]
	and	eax, 7
	mov	BYTE PTR mod_field$[rsp], al
$LN56@set_rm_sib:

; 725  :         CodeInfo->rm_byte = mod_field | rm_field;

	movzx	eax, BYTE PTR mod_field$[rsp]
	movzx	ecx, BYTE PTR rm_field$[rsp]
	or	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+104], al

; 726  : #if AMD64_SUPPORT
; 727  :         CodeInfo->prefix.rex |= rex;

	movzx	eax, BYTE PTR rex$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+8]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+8], al
$LN55@set_rm_sib:
$LN53@set_rm_sib:

; 728  : #endif
; 729  :     }
; 730  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@set_rm_sib:

; 731  : }

	add	rsp, 88					; 00000058H
	ret	0
	npad	1
$LN63@set_rm_sib:
	DD	$LN43@set_rm_sib
	DD	$LN45@set_rm_sib
	DD	$LN47@set_rm_sib
	DD	$LN48@set_rm_sib
$LN62@set_rm_sib:
	DB	0
	DB	3
	DB	0
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
set_rm_sib ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
tv77 = 32
default_seg$ = 36
tv142 = 40
tv157 = 44
tv169 = 48
tv189 = 52
assume$ = 56
tv92 = 64
CodeInfo$ = 96
seg_reg$ = 104
sym$ = 112
direct$ = 120
seg_override PROC

; 406  : {

	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 407  :     enum assume_segreg  default_seg;
; 408  :     struct asym         *assume;
; 409  : 
; 410  :     /* don't touch segment overrides for string instructions */
; 411  :     //if ( InstrTable[optable_idx[CodeInfo->token]].allowed_prefix == AP_REP ||
; 412  :     //     InstrTable[optable_idx[CodeInfo->token]].allowed_prefix == AP_REPxx )
; 413  :     if ( CodeInfo->pinstr->allowed_prefix == AP_REP ||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+2]
	cmp	eax, 2
	je	SHORT $LN5@seg_overri
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+2]
	cmp	eax, 3
	jne	SHORT $LN4@seg_overri
$LN5@seg_overri:

; 414  :          CodeInfo->pinstr->allowed_prefix == AP_REPxx )
; 415  :         return;

	jmp	$LN1@seg_overri
$LN4@seg_overri:

; 416  : 
; 417  :     if( CodeInfo->token == T_LEA ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 634			; 0000027aH
	jne	SHORT $LN6@seg_overri

; 418  :         CodeInfo->prefix.RegOverride = EMPTY; /* skip segment override */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+4], -2

; 419  :         SetFixupFrame( sym, FALSE );

	xor	edx, edx
	mov	rcx, QWORD PTR sym$[rsp]
	call	SetFixupFrame

; 420  :         return;

	jmp	$LN1@seg_overri
$LN6@seg_overri:

; 421  :     }
; 422  : 
; 423  :     switch( seg_reg ) {

	mov	eax, DWORD PTR seg_reg$[rsp]
	mov	DWORD PTR tv77[rsp], eax
	cmp	DWORD PTR tv77[rsp], 14
	je	SHORT $LN7@seg_overri
	cmp	DWORD PTR tv77[rsp], 20
	jle	SHORT $LN8@seg_overri
	cmp	DWORD PTR tv77[rsp], 22
	jle	SHORT $LN7@seg_overri
	jmp	SHORT $LN8@seg_overri
$LN7@seg_overri:

; 424  :     //case T_SS: /* doesn't happen */
; 425  :     case T_BP:
; 426  :     case T_EBP:
; 427  :     case T_ESP:
; 428  :         /* todo: check why cases T_RBP/T_RSP aren't needed! */
; 429  :         default_seg = ASSUME_SS;

	mov	DWORD PTR default_seg$[rsp], 2

; 430  :         break;

	jmp	SHORT $LN2@seg_overri
$LN8@seg_overri:

; 431  :     default:
; 432  :         default_seg = ASSUME_DS;

	mov	DWORD PTR default_seg$[rsp], 3
$LN2@seg_overri:

; 433  :     }
; 434  : 
; 435  :     if( CodeInfo->prefix.RegOverride != EMPTY ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+4], -2
	je	$LN9@seg_overri

; 436  :         assume = GetOverrideAssume( CodeInfo->prefix.RegOverride );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR [rax+4]
	call	GetOverrideAssume
	mov	QWORD PTR assume$[rsp], rax

; 437  :         /* assume now holds assumed SEG/GRP symbol */
; 438  :         if ( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN11@seg_overri

; 439  :             DebugMsg1(("seg_override: sym=%s\n", sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11644
	call	DoDebugMsg1

; 440  :             SetFixupFrame( assume ? assume : sym, FALSE );

	cmp	QWORD PTR assume$[rsp], 0
	je	SHORT $LN23@seg_overri
	mov	rax, QWORD PTR assume$[rsp]
	mov	QWORD PTR tv92[rsp], rax
	jmp	SHORT $LN24@seg_overri
$LN23@seg_overri:
	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR tv92[rsp], rax
$LN24@seg_overri:
	xor	edx, edx
	mov	rcx, QWORD PTR tv92[rsp]
	call	SetFixupFrame
	jmp	$LN12@seg_overri
$LN11@seg_overri:

; 441  :         } else if ( direct ) {

	movzx	eax, BYTE PTR direct$[rsp]
	test	eax, eax
	je	$LN13@seg_overri

; 442  :             /* no label attached (DS:[0]). No fixup is to be created! */
; 443  :             if ( assume ) {

	cmp	QWORD PTR assume$[rsp], 0
	je	SHORT $LN14@seg_overri

; 444  :                 DebugMsg1(("seg_override, direct addressing: prefix.adrsiz will be set, assume=%s CI->ofssize=%u\n", assume->name, CodeInfo->Ofssize ));

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	mov	r8d, eax
	mov	rax, QWORD PTR assume$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11648
	call	DoDebugMsg1

; 445  :                 CodeInfo->prefix.adrsiz = ADDRSIZE( CodeInfo->Ofssize, GetSymOfssize( assume ) );

	mov	rcx, QWORD PTR assume$[rsp]
	call	GetSymOfssize
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+106]
	xor	eax, ecx
	test	eax, eax
	je	SHORT $LN25@seg_overri
	mov	DWORD PTR tv142[rsp], 1
	jmp	SHORT $LN26@seg_overri
$LN25@seg_overri:
	mov	DWORD PTR tv142[rsp], 0
$LN26@seg_overri:
	movzx	eax, BYTE PTR tv142[rsp]
	and	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 254					; 000000feH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 446  :                 //DebugMsg1(("seg_override: CI->prefix.adrsiz=%u\n", CodeInfo->prefix.adrsiz ));
; 447  :             } else {

	jmp	$LN15@seg_overri
$LN14@seg_overri:

; 448  :                 /* v2.01: if -Zm, then use current CS offset size.
; 449  :                  * This isn't how Masm v6 does it, but it matches Masm v5.
; 450  :                  */
; 451  :                 if ( ModuleInfo.m510 )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 6
	and	eax, 1
	test	eax, eax
	je	SHORT $LN16@seg_overri

; 452  :                     CodeInfo->prefix.adrsiz = ADDRSIZE( CodeInfo->Ofssize, ModuleInfo.Ofssize );

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+106]
	xor	eax, ecx
	test	eax, eax
	je	SHORT $LN27@seg_overri
	mov	DWORD PTR tv157[rsp], 1
	jmp	SHORT $LN28@seg_overri
$LN27@seg_overri:
	mov	DWORD PTR tv157[rsp], 0
$LN28@seg_overri:
	movzx	eax, BYTE PTR tv157[rsp]
	and	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 254					; 000000feH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
	jmp	SHORT $LN17@seg_overri
$LN16@seg_overri:

; 453  :                 else
; 454  :                     CodeInfo->prefix.adrsiz = ADDRSIZE( CodeInfo->Ofssize, ModuleInfo.defOfssize );

	movzx	eax, BYTE PTR ModuleInfo+405
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+106]
	xor	eax, ecx
	test	eax, eax
	je	SHORT $LN29@seg_overri
	mov	DWORD PTR tv169[rsp], 1
	jmp	SHORT $LN30@seg_overri
$LN29@seg_overri:
	mov	DWORD PTR tv169[rsp], 0
$LN30@seg_overri:
	movzx	eax, BYTE PTR tv169[rsp]
	and	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 254					; 000000feH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN17@seg_overri:
$LN15@seg_overri:
$LN13@seg_overri:
$LN12@seg_overri:

; 455  :             }
; 456  :         }
; 457  :     } else {

	jmp	$LN10@seg_overri
$LN9@seg_overri:

; 458  :         if ( sym || SegOverride )

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN19@seg_overri
	cmp	QWORD PTR SegOverride, 0
	je	SHORT $LN18@seg_overri
$LN19@seg_overri:

; 459  :             check_assume( CodeInfo, sym, default_seg );

	mov	r8d, DWORD PTR default_seg$[rsp]
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	check_assume
$LN18@seg_overri:

; 460  :         if ( sym == NULL && SegOverride ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN20@seg_overri
	cmp	QWORD PTR SegOverride, 0
	je	SHORT $LN20@seg_overri

; 461  :             CodeInfo->prefix.adrsiz = ADDRSIZE( CodeInfo->Ofssize, GetSymOfssize( SegOverride ) );

	mov	rcx, QWORD PTR SegOverride
	call	GetSymOfssize
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+106]
	xor	eax, ecx
	test	eax, eax
	je	SHORT $LN31@seg_overri
	mov	DWORD PTR tv189[rsp], 1
	jmp	SHORT $LN32@seg_overri
$LN31@seg_overri:
	mov	DWORD PTR tv189[rsp], 0
$LN32@seg_overri:
	movzx	eax, BYTE PTR tv189[rsp]
	and	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 254					; 000000feH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN20@seg_overri:
$LN10@seg_overri:

; 462  :         }
; 463  :     }
; 464  : 
; 465  :     if( CodeInfo->prefix.RegOverride == default_seg ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR default_seg$[rsp]
	cmp	DWORD PTR [rax+4], ecx
	jne	SHORT $LN21@seg_overri

; 466  :         CodeInfo->prefix.RegOverride = EMPTY;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+4], -2
$LN21@seg_overri:
$LN1@seg_overri:

; 467  :     }
; 468  : }

	add	rsp, 88					; 00000058H
	ret	0
seg_override ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
reg$ = 32
assume$ = 40
tv74 = 48
tv78 = 56
CodeInfo$ = 80
sym$ = 88
default_reg$ = 96
check_assume PROC

; 367  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 368  :     enum assume_segreg     reg;
; 369  :     struct asym            *assume;
; 370  : 
; 371  :     if( sym && sym->state == SYM_UNDEFINED )

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN2@check_assu
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN2@check_assu

; 372  :         return;

	jmp	$LN1@check_assu
$LN2@check_assu:

; 373  : 
; 374  :     reg = GetAssume( SegOverride, sym, default_reg, &assume );

	lea	r9, QWORD PTR assume$[rsp]
	mov	r8d, DWORD PTR default_reg$[rsp]
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR SegOverride
	call	GetAssume
	mov	DWORD PTR reg$[rsp], eax

; 375  :     /* set global vars Frame and Frame_Datum */
; 376  :     DebugMsg1(("check_assume(%s): calling SetFixupFrame(%s, FALSE)\n", sym ? sym->name : "NULL", assume ? assume->name : "NULL" ));

	cmp	QWORD PTR assume$[rsp], 0
	je	SHORT $LN11@check_assu
	mov	rax, QWORD PTR assume$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv74[rsp], rax
	jmp	SHORT $LN12@check_assu
$LN11@check_assu:
	lea	rax, OFFSET FLAT:$SG11608
	mov	QWORD PTR tv74[rsp], rax
$LN12@check_assu:
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN13@check_assu
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv78[rsp], rax
	jmp	SHORT $LN14@check_assu
$LN13@check_assu:
	lea	rax, OFFSET FLAT:$SG11609
	mov	QWORD PTR tv78[rsp], rax
$LN14@check_assu:
	mov	r8, QWORD PTR tv74[rsp]
	mov	rdx, QWORD PTR tv78[rsp]
	lea	rcx, OFFSET FLAT:$SG11610
	call	DoDebugMsg1

; 377  :     SetFixupFrame( assume, FALSE );

	xor	edx, edx
	mov	rcx, QWORD PTR assume$[rsp]
	call	SetFixupFrame

; 378  : 
; 379  :     if( reg == ASSUME_NOTHING ) {

	cmp	DWORD PTR reg$[rsp], -2
	jne	SHORT $LN3@check_assu

; 380  :         if ( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN5@check_assu

; 381  :             //if( sym->state != SYM_EXTERNAL && sym->state != SYM_STACK ) {
; 382  :             /* v1.95: condition changed. Now there's an error msg only if
; 383  :              * the symbol has an explicite segment.
; 384  :              */
; 385  :             if( sym->segment != NULL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+32], 0
	je	SHORT $LN7@check_assu

; 386  :                 DebugMsg1(("check_assume: no segment register available to access label %s\n", sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11617
	call	DoDebugMsg1

; 387  :                 EmitErr( CANNOT_ACCESS_LABEL_THROUGH_SEGMENT_REGISTERS, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 89					; 00000059H
	call	EmitErr

; 388  :             } else

	jmp	SHORT $LN8@check_assu
$LN7@check_assu:

; 389  :                 CodeInfo->prefix.RegOverride = default_reg;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR default_reg$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN8@check_assu:

; 390  :         } else {

	jmp	SHORT $LN6@check_assu
$LN5@check_assu:

; 391  :             DebugMsg1(("check_assume: no segment register available to access seg-label %s\n", SegOverride->name ));

	mov	rax, QWORD PTR SegOverride
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11618
	call	DoDebugMsg1

; 392  :             EmitErr( CANNOT_ACCESS_LABEL_THROUGH_SEGMENT_REGISTERS, SegOverride->name );

	mov	rax, QWORD PTR SegOverride
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 89					; 00000059H
	call	EmitErr
$LN6@check_assu:

; 393  :         }

	jmp	SHORT $LN4@check_assu
$LN3@check_assu:

; 394  :     } else if( default_reg != EMPTY ) {

	cmp	DWORD PTR default_reg$[rsp], -2
	je	SHORT $LN9@check_assu

; 395  :         CodeInfo->prefix.RegOverride = reg;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR reg$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN9@check_assu:
$LN4@check_assu:
$LN1@check_assu:

; 396  :     }
; 397  : }

	add	rsp, 72					; 00000048H
	ret	0
check_assume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
tv64 = 32
tv65 = 36
tv68 = 40
reg1$ = 64
reg2$ = 72
comp_mem16 PROC

; 340  : {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 341  :     switch( reg1 ) {

	mov	eax, DWORD PTR reg1$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 12
	je	SHORT $LN8@comp_mem16
	cmp	DWORD PTR tv64[rsp], 14
	je	SHORT $LN11@comp_mem16
	jmp	SHORT $LN14@comp_mem16
$LN8@comp_mem16:

; 342  :     case T_BX:
; 343  :         switch( reg2 ) {

	mov	eax, DWORD PTR reg2$[rsp]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 15
	je	SHORT $LN9@comp_mem16
	cmp	DWORD PTR tv65[rsp], 16
	je	SHORT $LN10@comp_mem16
	jmp	SHORT $LN4@comp_mem16
$LN9@comp_mem16:

; 344  :         case T_SI: return( RM_BX_SI ); /* 00 */

	xor	eax, eax
	jmp	SHORT $LN1@comp_mem16
$LN10@comp_mem16:

; 345  :         case T_DI: return( RM_BX_DI ); /* 01 */

	mov	eax, 1
	jmp	SHORT $LN1@comp_mem16
$LN4@comp_mem16:

; 346  :         }
; 347  :         break;

	jmp	SHORT $LN2@comp_mem16
$LN11@comp_mem16:

; 348  :     case T_BP:
; 349  :         switch( reg2 ) {

	mov	eax, DWORD PTR reg2$[rsp]
	mov	DWORD PTR tv68[rsp], eax
	cmp	DWORD PTR tv68[rsp], 15
	je	SHORT $LN12@comp_mem16
	cmp	DWORD PTR tv68[rsp], 16
	je	SHORT $LN13@comp_mem16
	jmp	SHORT $LN6@comp_mem16
$LN12@comp_mem16:

; 350  :         case T_SI: return( RM_BP_SI ); /* 02 */

	mov	eax, 2
	jmp	SHORT $LN1@comp_mem16
$LN13@comp_mem16:

; 351  :         case T_DI: return( RM_BP_DI ); /* 03 */

	mov	eax, 3
	jmp	SHORT $LN1@comp_mem16
$LN6@comp_mem16:

; 352  :         }
; 353  :         break;

	jmp	SHORT $LN2@comp_mem16
$LN14@comp_mem16:

; 354  :     default:
; 355  :         return( EmitError( MULTIPLE_INDEX_REGISTERS_NOT_ALLOWED ) );

	mov	ecx, 34					; 00000022H
	call	EmitError
	jmp	SHORT $LN1@comp_mem16
$LN2@comp_mem16:

; 356  :     }
; 357  :     return( EmitError( MULTIPLE_BASE_REGISTERS_NOT_ALLOWED ) );

	mov	ecx, 29
	call	EmitError
$LN1@comp_mem16:

; 358  : }

	add	rsp, 56					; 00000038H
	ret	0
comp_mem16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
tokenarray$ = 48
ProcessFile PROC

; 3571 : {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3572 : 	/* Initialize xmmword override tokens each pass */
; 3573 : 	xmmOver0.token = 6;

	mov	BYTE PTR xmmOver0, 6

; 3574 : 	xmmOver0.specval = 15;

	mov	BYTE PTR xmmOver0+1, 15

; 3575 : 	xmmOver0.floattype = 15;

	mov	BYTE PTR xmmOver0+1, 15

; 3576 : 	xmmOver0.numbase = 15;

	mov	BYTE PTR xmmOver0+1, 15

; 3577 : 	xmmOver0.string_delim = 15;

	mov	BYTE PTR xmmOver0+1, 15

; 3578 : 	xmmOver0.precedence = 15;

	mov	BYTE PTR xmmOver0+1, 15

; 3579 : 	xmmOver0.bytval = 15;

	mov	BYTE PTR xmmOver0+1, 15

; 3580 : 	xmmOver0.dirtype = 15;

	mov	BYTE PTR xmmOver0+1, 15

; 3581 : 	xmmOver0.tokval = T_XMMWORD;

	mov	DWORD PTR xmmOver0+16, 228		; 000000e4H

; 3582 : 	xmmOver0.string_ptr = "xmmword";

	lea	rax, OFFSET FLAT:$SG12791
	mov	QWORD PTR xmmOver0+8, rax

; 3583 : 	xmmOver0.stringlen = T_XMMWORD;

	mov	DWORD PTR xmmOver0+16, 228		; 000000e4H

; 3584 : 	xmmOver0.idarg = T_XMMWORD;

	mov	DWORD PTR xmmOver0+16, 228		; 000000e4H

; 3585 : 	xmmOver0.itemlen = T_XMMWORD;

	mov	DWORD PTR xmmOver0+16, 228		; 000000e4H

; 3586 : 	xmmOver0.lastidx = T_XMMWORD;

	mov	DWORD PTR xmmOver0+16, 228		; 000000e4H

; 3587 : 
; 3588 : 	xmmOver1.token = 5;

	mov	BYTE PTR xmmOver1, 5

; 3589 : 	xmmOver1.specval = 4;

	mov	BYTE PTR xmmOver1+1, 4

; 3590 : 	xmmOver1.floattype = 4;

	mov	BYTE PTR xmmOver1+1, 4

; 3591 : 	xmmOver1.numbase = 4;

	mov	BYTE PTR xmmOver1+1, 4

; 3592 : 	xmmOver1.string_delim = 4;

	mov	BYTE PTR xmmOver1+1, 4

; 3593 : 	xmmOver1.precedence = 4;

	mov	BYTE PTR xmmOver1+1, 4

; 3594 : 	xmmOver1.bytval = 4;

	mov	BYTE PTR xmmOver1+1, 4

; 3595 : 	xmmOver1.dirtype = 4;

	mov	BYTE PTR xmmOver1+1, 4

; 3596 : 	xmmOver1.tokval = T_PTR;

	mov	DWORD PTR xmmOver1+16, 258		; 00000102H

; 3597 : 	xmmOver1.string_ptr = "ptr";

	lea	rax, OFFSET FLAT:$SG12792
	mov	QWORD PTR xmmOver1+8, rax

; 3598 : 	xmmOver1.stringlen = T_PTR;

	mov	DWORD PTR xmmOver1+16, 258		; 00000102H

; 3599 : 	xmmOver1.idarg = T_PTR;

	mov	DWORD PTR xmmOver1+16, 258		; 00000102H

; 3600 : 	xmmOver1.itemlen = T_PTR;

	mov	DWORD PTR xmmOver1+16, 258		; 00000102H

; 3601 : 	xmmOver1.lastidx = T_PTR;

	mov	DWORD PTR xmmOver1+16, 258		; 00000102H
$LN2@ProcessFil:

; 3602 : 
; 3603 :     while ( ModuleInfo.EndDirFound == FALSE && GetTextLine( CurrSource ) ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 16
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN3@ProcessFil
	mov	rcx, QWORD PTR ModuleInfo+464
	call	GetTextLine
	test	rax, rax
	je	SHORT $LN3@ProcessFil

; 3604 :         if ( PreprocessLine( CurrSource, tokenarray ) ) {

	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+464
	call	PreprocessLine
	test	eax, eax
	je	SHORT $LN4@ProcessFil

; 3605 :             ParseLine( tokenarray );

	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	ParseLine

; 3606 :             if ( Options.preprocessor_stdout == TRUE && Parse_Pass == PASS_1 )

	movzx	eax, BYTE PTR Options+141
	cmp	eax, 1
	jne	SHORT $LN5@ProcessFil
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN5@ProcessFil

; 3607 :                 WritePreprocessedLine( CurrSource );

	mov	rcx, QWORD PTR ModuleInfo+464
	call	WritePreprocessedLine
$LN5@ProcessFil:
$LN4@ProcessFil:

; 3608 :         }
; 3609 :     }

	jmp	SHORT $LN2@ProcessFil
$LN3@ProcessFil:

; 3610 :     return;
; 3611 : }

	add	rsp, 40					; 00000028H
	ret	0
ProcessFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
i$ = 64
CurrOpnd$ = 68
j$ = 72
k$ = 76
regtok$ = 80
tv1544 = 84
instr$ = 88
temp$ = 96
dirflags$ = 100
tv560 = 104
tv739 = 108
flags$1 = 112
tv1260 = 116
tv212 = 120
tv322 = 124
n$ = 128
tv133 = 132
tv571 = 136
tv764 = 140
tv1497 = 144
oldofs$ = 148
sym$ = 152
tv1578 = 160
CodeInfo$ = 176
opndx$ = 320
__$ArrayPad$ = 736
tokenarray$ = 784
ParseLine PROC

; 2878 : {

$LN228:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 760				; 000002f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2879 :   int                 i;
; 2880 :   int                 j;
; 2881 :   int                 k = 0;

	mov	DWORD PTR k$[rsp], 0

; 2882 :   int                 n = 0;

	mov	DWORD PTR n$[rsp], 0

; 2883 :   unsigned            dirflags;
; 2884 :   unsigned            CurrOpnd;
; 2885 :   ret_code            temp;
; 2886 :   struct asym         *sym;
; 2887 :   uint_32             oldofs;
; 2888 :   enum special_token regtok;
; 2889 : #ifdef DEBUG_OUT
; 2890 :   char                *instr;
; 2891 : #endif
; 2892 :   struct code_info    CodeInfo;
; 2893 : #if AVXSUPP
; 2894 :   struct expr         opndx[MAX_OPND + 1];
; 2895 : #else
; 2896 :   struct expr         opndx[MAX_OPND];
; 2897 : #endif
; 2898 : 
; 2899 :   DebugMsg1(("ParseLine enter, Token_Count=%u, ofs=%Xh\n",

	call	GetCurrOffset
	mov	r8d, eax
	mov	edx, DWORD PTR ModuleInfo+496
	lea	rcx, OFFSET FLAT:$SG12581
	call	DoDebugMsg1

; 2900 :     Token_Count, GetCurrOffset()));
; 2901 :   i = 0;

	mov	DWORD PTR i$[rsp], 0

; 2902 :   /* Does line start with a code label? */
; 2903 :   if (tokenarray[0].token == T_ID && (tokenarray[1].token == T_COLON || tokenarray[1].token == T_DBL_COLON)) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN41@ParseLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN42@ParseLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 13
	jne	$LN41@ParseLine
$LN42@ParseLine:

; 2904 :     i = 2;

	mov	DWORD PTR i$[rsp], 2

; 2905 :     DebugMsg1(("ParseLine T_COLON, code label=%s\n", tokenarray[0].string_ptr));

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG12584
	call	DoDebugMsg1

; 2906 :     if (ProcStatus & PRST_PROLOGUE_NOT_DONE) write_prologue(tokenarray);

	mov	eax, DWORD PTR ProcStatus
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN43@ParseLine
	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	write_prologue
$LN43@ParseLine:

; 2907 : 
; 2908 :     /* create a global or local code label */
; 2909 :     if (CreateLabel(tokenarray[0].string_ptr, MT_NEAR, NULL,
; 2910 :       (ModuleInfo.scoped && CurrProc && tokenarray[1].token != T_DBL_COLON)) == NULL) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 7
	and	eax, 1
	test	eax, eax
	je	SHORT $LN219@ParseLine
	cmp	QWORD PTR CurrProc, 0
	je	SHORT $LN219@ParseLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 13
	je	SHORT $LN219@ParseLine
	mov	DWORD PTR tv133[rsp], 1
	jmp	SHORT $LN220@ParseLine
$LN219@ParseLine:
	mov	DWORD PTR tv133[rsp], 0
$LN220@ParseLine:
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	movzx	r9d, BYTE PTR tv133[rsp]
	xor	r8d, r8d
	mov	edx, 129				; 00000081H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	CreateLabel
	test	rax, rax
	jne	SHORT $LN44@ParseLine

; 2911 :       DebugMsg(("ParseLine, CreateLabel(%s) failed, exit\n", tokenarray[0].string_ptr));

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG12587
	call	DoDebugMsg

; 2912 :       return(ERROR);

	mov	eax, -1
	jmp	$LN1@ParseLine
$LN44@ParseLine:

; 2913 :     }
; 2914 :     if (tokenarray[i].token == T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN45@ParseLine

; 2915 :       /* v2.06: this is a bit too late. Should be done BEFORE
; 2916 :        * CreateLabel, because of '@@'. There's a flag supposed to
; 2917 :        * be used for this handling, LOF_STORED in line_flags.
; 2918 :        * It's only a problem if a '@@:' is the first line
; 2919 :        * in the code section.
; 2920 :        * v2.10: is no longer an issue because the label counter has
; 2921 :        * been moved to module_vars (see global.h).
; 2922 :        */
; 2923 :       FStoreLine(0);

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN46@ParseLine
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR ModuleInfo+464
	call	StoreLine
$LN46@ParseLine:

; 2924 :       if (CurrFile[LST]) {

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN48@ParseLine

; 2925 :         LstWrite(LSTTYPE_LABEL, 0, NULL);

	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, 7
	call	LstWrite
$LN48@ParseLine:

; 2926 :       }
; 2927 :       return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@ParseLine
$LN45@ParseLine:
$LN41@ParseLine:

; 2928 :     }
; 2929 :   }
; 2930 :   /* handle directives and (anonymous) data items */
; 2931 :   if (tokenarray[i].token != T_INSTRUCTION) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 1
	je	$LN49@ParseLine

; 2932 :     /* a code label before a data item is only accepted in Masm5 compat mode */
; 2933 :     Frame_Type = FRAME_NONE;

	mov	BYTE PTR Frame_Type, 6

; 2934 :     SegOverride = NULL;

	mov	QWORD PTR SegOverride, 0

; 2935 :     if (i == 0 && tokenarray[0].token == T_ID) {

	cmp	DWORD PTR i$[rsp], 0
	jne	$LN50@ParseLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN50@ParseLine

; 2936 :       /* token at pos 0 may be a label.
; 2937 :        * it IS a label if:
; 2938 :        * 1. token at pos 1 is a directive (lbl dd ...)
; 2939 :        * 2. token at pos 0 is NOT a userdef type ( lbl DWORD ...)
; 2940 :        * 3. inside a struct and token at pos 1 is a userdef type
; 2941 :        *    or a predefined type. (usertype DWORD|usertype ... )
; 2942 :        *    the separate namespace allows this syntax here.
; 2943 :        */
; 2944 :       if (tokenarray[1].token == T_DIRECTIVE)

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	SHORT $LN51@ParseLine

; 2945 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	$LN52@ParseLine
$LN51@ParseLine:

; 2946 :       else {
; 2947 :         sym = IsType(tokenarray[0].string_ptr);

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	IsType
	mov	QWORD PTR sym$[rsp], rax

; 2948 :         if (sym == NULL)

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN53@ParseLine

; 2949 :           i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN54@ParseLine
$LN53@ParseLine:

; 2950 :         else if (CurrStruct &&

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN55@ParseLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 6
	je	SHORT $LN56@ParseLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN55@ParseLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	IsType
	test	rax, rax
	je	SHORT $LN55@ParseLine
$LN56@ParseLine:

; 2951 :           ((tokenarray[1].token == T_STYPE) ||
; 2952 :           (tokenarray[1].token == T_ID && (IsType(tokenarray[1].string_ptr)))))
; 2953 :           i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN55@ParseLine:
$LN54@ParseLine:
$LN52@ParseLine:
$LN50@ParseLine:

; 2954 :       }
; 2955 :     }
; 2956 :     switch (tokenarray[i].token) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR tv212[rsp], al
	cmp	BYTE PTR tv212[rsp], 3
	je	SHORT $LN57@ParseLine
	cmp	BYTE PTR tv212[rsp], 6
	je	$LN80@ParseLine
	cmp	BYTE PTR tv212[rsp], 8
	je	$LN81@ParseLine
	jmp	$LN83@ParseLine
$LN57@ParseLine:

; 2957 :     case T_DIRECTIVE:
; 2958 :       DebugMsg1(("ParseLine: T_DIRECTIVE >%s<\n", tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG12601
	call	DoDebugMsg1

; 2959 :       if (tokenarray[i].dirtype == DRT_DATADIR) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 8
	jne	SHORT $LN58@ParseLine

; 2960 :         return(data_dir(i, tokenarray, NULL));

	xor	r8d, r8d
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	data_dir
	jmp	$LN1@ParseLine
$LN58@ParseLine:

; 2961 :       }
; 2962 :       dirflags = GetValueSp(tokenarray[i].tokval);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR dirflags$[rsp], eax

; 2963 :       if (CurrStruct && (dirflags & DF_NOSTRUC)) {

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN59@ParseLine
	mov	eax, DWORD PTR dirflags$[rsp]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN59@ParseLine

; 2964 :         return(EmitError(STATEMENT_NOT_ALLOWED_INSIDE_STRUCTURE_DEFINITION));

	mov	ecx, 141				; 0000008dH
	call	EmitError
	jmp	$LN1@ParseLine
$LN59@ParseLine:

; 2965 :       }
; 2966 :       /* label allowed for directive? */
; 2967 :       //if ( tokenarray[i].flags & DF_LABEL ) {
; 2968 :       if (dirflags & DF_LABEL) {

	mov	eax, DWORD PTR dirflags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN60@ParseLine

; 2969 :         if (i && tokenarray[0].token != T_ID) {

	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN62@ParseLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN62@ParseLine

; 2970 :           return(EmitErr(SYNTAX_ERROR_EX, tokenarray[0].string_ptr));

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ParseLine
$LN62@ParseLine:

; 2971 :         }
; 2972 :       }

	jmp	SHORT $LN61@ParseLine
$LN60@ParseLine:

; 2973 :       else if (i && tokenarray[i - 1].token != T_COLON && tokenarray[i - 1].token != T_DBL_COLON) {

	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN63@ParseLine
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN63@ParseLine
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 13
	je	SHORT $LN63@ParseLine

; 2974 :         return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i - 1].string_ptr));

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ParseLine
$LN63@ParseLine:
$LN61@ParseLine:

; 2975 :       }
; 2976 :       /* must be done BEFORE FStoreLine()! */
; 2977 :       if ((ProcStatus & PRST_PROLOGUE_NOT_DONE) && (dirflags & DF_PROC)) write_prologue(tokenarray);

	mov	eax, DWORD PTR ProcStatus
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN64@ParseLine
	mov	eax, DWORD PTR dirflags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN64@ParseLine
	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	write_prologue
$LN64@ParseLine:

; 2978 : #if FASTPASS
; 2979 :       if (StoreState || (dirflags & DF_STORE)) {

	movzx	eax, BYTE PTR StoreState
	test	eax, eax
	jne	SHORT $LN66@ParseLine
	mov	eax, DWORD PTR dirflags$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN65@ParseLine
$LN66@ParseLine:

; 2980 :         /* v2.07: the comment must be stored as well
; 2981 :          * if a listing (with -Sg) is to be written and
; 2982 :          * the directive will generate lines
; 2983 :          */
; 2984 :         if ((dirflags & DF_CGEN) && ModuleInfo.CurrComment && ModuleInfo.list_generated_code) {

	mov	eax, DWORD PTR dirflags$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN67@ParseLine
	cmp	QWORD PTR ModuleInfo+472, 0
	je	SHORT $LN67@ParseLine
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 14
	and	eax, 1
	test	eax, eax
	je	SHORT $LN67@ParseLine

; 2985 :           FStoreLine(1);

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN69@ParseLine
	xor	r8d, r8d
	mov	edx, 1
	mov	rcx, QWORD PTR ModuleInfo+464
	call	StoreLine
$LN69@ParseLine:

; 2986 :         }

	jmp	SHORT $LN68@ParseLine
$LN67@ParseLine:

; 2987 :         else
; 2988 :           FStoreLine(0);

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN71@ParseLine
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR ModuleInfo+464
	call	StoreLine
$LN71@ParseLine:
$LN68@ParseLine:
$LN65@ParseLine:

; 2989 :       }
; 2990 : #endif
; 2991 :       if (tokenarray[i].dirtype > DRT_DATADIR) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 8
	jle	SHORT $LN73@ParseLine

; 2992 :         temp = directive_tab[tokenarray[i].dirtype](i, tokenarray);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1]
	lea	rcx, OFFSET FLAT:directive_tab
	mov	QWORD PTR tv1578[rsp], rcx
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	r8, QWORD PTR tv1578[rsp]
	call	QWORD PTR [r8+rax*8]
	mov	DWORD PTR temp$[rsp], eax

; 2993 :       }

	jmp	SHORT $LN74@ParseLine
$LN73@ParseLine:

; 2994 :       else {
; 2995 :         temp = ERROR;

	mov	DWORD PTR temp$[rsp], -1

; 2996 :         /* ENDM, EXITM and GOTO directives should never be seen here */
; 2997 :         switch (tokenarray[i].tokval) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR tv322[rsp], eax
	cmp	DWORD PTR tv322[rsp], 398		; 0000018eH
	je	SHORT $LN76@ParseLine
	cmp	DWORD PTR tv322[rsp], 399		; 0000018fH
	je	SHORT $LN75@ParseLine
	cmp	DWORD PTR tv322[rsp], 400		; 00000190H
	je	SHORT $LN76@ParseLine
	jmp	SHORT $LN77@ParseLine
$LN75@ParseLine:

; 2998 :         case T_ENDM:
; 2999 :           EmitError(UNMATCHED_MACRO_NESTING);

	mov	ecx, 162				; 000000a2H
	call	EmitError

; 3000 :           break;

	jmp	SHORT $LN4@ParseLine
$LN76@ParseLine:

; 3001 :         case T_EXITM:
; 3002 :         case T_GOTO:
; 3003 :           EmitError(DIRECTIVE_MUST_APPEAR_INSIDE_A_MACRO);

	mov	ecx, 178				; 000000b2H
	call	EmitError

; 3004 :           break;

	jmp	SHORT $LN4@ParseLine
$LN77@ParseLine:

; 3005 :         default:
; 3006 :           /* this error may happen if
; 3007 :            * CATSTR, SUBSTR, MACRO, ...
; 3008 :            * aren't at pos 1
; 3009 :            */
; 3010 :           EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN4@ParseLine:
$LN74@ParseLine:

; 3011 :           break;
; 3012 :         }
; 3013 :       }
; 3014 :       /* v2.0: for generated code it's important that list file is
; 3015 :        * written in ALL passes, to update file position! */
; 3016 :       //if ( ModuleInfo.list && (( line_flags & LOF_LISTED ) == 0 ) && Parse_Pass == PASS_1 )
; 3017 : #if FASTPASS
; 3018 :       /* v2.08: UseSavedState == FALSE added */
; 3019 :       if (ModuleInfo.list && (Parse_Pass == PASS_1 || ModuleInfo.GeneratedCode || UseSavedState == FALSE))

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN78@ParseLine
	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN79@ParseLine
	cmp	DWORD PTR ModuleInfo+456, 0
	jne	SHORT $LN79@ParseLine
	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	jne	SHORT $LN78@ParseLine
$LN79@ParseLine:

; 3020 : #else
; 3021 :       if ( ModuleInfo.list )
; 3022 : #endif
; 3023 :         LstWriteSrcLine();

	call	LstWriteSrcLine
$LN78@ParseLine:

; 3024 :       return(temp);

	mov	eax, DWORD PTR temp$[rsp]
	jmp	$LN1@ParseLine
$LN80@ParseLine:

; 3025 :     case T_STYPE:
; 3026 :       DebugMsg1(("ParseLine: T_STYPE >%s<\n", tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG12625
	call	DoDebugMsg1

; 3027 :       return(data_dir(i, tokenarray, NULL));

	xor	r8d, r8d
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	data_dir
	jmp	$LN1@ParseLine
$LN81@ParseLine:

; 3028 :     case T_ID:
; 3029 :       DebugMsg1(("ParseLine: T_ID >%s<\n", tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG12627
	call	DoDebugMsg1

; 3030 :       if (sym = IsType(tokenarray[i].string_ptr)) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	IsType
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN82@ParseLine

; 3031 :         return(data_dir(i, tokenarray, sym));

	mov	r8, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	data_dir
	jmp	$LN1@ParseLine
$LN82@ParseLine:

; 3032 :       }
; 3033 :       break;

	jmp	SHORT $LN2@ParseLine
$LN83@ParseLine:

; 3034 :     default:
; 3035 :       if (tokenarray[i].token == T_COLON) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN84@ParseLine

; 3036 :         DebugMsg(("ParseLine: unexpected colon\n"));

	lea	rcx, OFFSET FLAT:$SG12631
	call	DoDebugMsg

; 3037 :         return(EmitError(SYNTAX_ERROR_UNEXPECTED_COLON));

	mov	ecx, 47					; 0000002fH
	call	EmitError
	jmp	$LN1@ParseLine
$LN84@ParseLine:
$LN2@ParseLine:

; 3038 :       }
; 3039 :       break;
; 3040 :     } /* end switch (tokenarray[i].token) */
; 3041 :     if (i && tokenarray[i - 1].token == T_ID)

	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN85@ParseLine
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN85@ParseLine

; 3042 :       i--;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN85@ParseLine:

; 3043 :     DebugMsg(("ParseLine: unexpected token=%u, i=%u, string=%s\n", tokenarray[i].token, i, tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r9, QWORD PTR [rdx+rax+8]
	mov	r8d, DWORD PTR i$[rsp]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG12633
	call	DoDebugMsg

; 3044 :     return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ParseLine
$LN49@ParseLine:

; 3045 :   }
; 3046 : 
; 3047 :   DebugMsg1(("ParseLine: %s\n", tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG12634
	call	DoDebugMsg1

; 3048 :   /* v2.04 added */
; 3049 :   if (CurrStruct) {

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN86@ParseLine

; 3050 :     return(EmitError(STATEMENT_NOT_ALLOWED_INSIDE_STRUCTURE_DEFINITION));

	mov	ecx, 141				; 0000008dH
	call	EmitError
	jmp	$LN1@ParseLine
$LN86@ParseLine:

; 3051 :   }
; 3052 : 
; 3053 :   if (ProcStatus & PRST_PROLOGUE_NOT_DONE) write_prologue(tokenarray);

	mov	eax, DWORD PTR ProcStatus
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN87@ParseLine
	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	write_prologue
$LN87@ParseLine:

; 3054 : 
; 3055 :   /* v2.07: moved because special handling is needed for RET/IRET */
; 3056 :   //FStoreLine(); /* must be placed AFTER write_prologue() */
; 3057 : 
; 3058 :   if (CurrFile[LST]) oldofs = GetCurrOffset();

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN88@ParseLine
	call	GetCurrOffset
	mov	DWORD PTR oldofs$[rsp], eax
$LN88@ParseLine:

; 3059 : 
; 3060 :   /* init CodeInfo */
; 3061 :   CodeInfo.prefix.ins = EMPTY;

	mov	DWORD PTR CodeInfo$[rsp], -2

; 3062 :   CodeInfo.prefix.RegOverride = EMPTY;

	mov	DWORD PTR CodeInfo$[rsp+4], -2

; 3063 : #if AMD64_SUPPORT
; 3064 :   CodeInfo.prefix.rex = 0;

	mov	BYTE PTR CodeInfo$[rsp+8], 0

; 3065 : #endif
; 3066 :   CodeInfo.prefix.adrsiz = FALSE;

	movzx	eax, BYTE PTR CodeInfo$[rsp+9]
	and	al, 254					; 000000feH
	mov	BYTE PTR CodeInfo$[rsp+9], al

; 3067 :   CodeInfo.prefix.opsiz = FALSE;

	movzx	eax, BYTE PTR CodeInfo$[rsp+9]
	and	al, 253					; 000000fdH
	mov	BYTE PTR CodeInfo$[rsp+9], al

; 3068 :   CodeInfo.mem_type = MT_EMPTY;

	mov	DWORD PTR CodeInfo$[rsp+28], 192	; 000000c0H

; 3069 :   for (j = 0; j < MAX_OPND; j++) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN8@ParseLine
$LN6@ParseLine:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN8@ParseLine:
	cmp	DWORD PTR j$[rsp], 3
	jge	SHORT $LN7@ParseLine

; 3070 :     CodeInfo.opnd[j].type = OP_NONE;

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 24
	mov	DWORD PTR CodeInfo$[rsp+rax+32], 0

; 3071 : #ifdef DEBUG_OUT
; 3072 :     CodeInfo.opnd[j].data32l = -1;

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 24
	mov	DWORD PTR CodeInfo$[rsp+rax+40], -1

; 3073 :     /* make sure it's invalid */
; 3074 :     CodeInfo.opnd[j].InsFixup = (void *)0xffffffff;

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 24
	mov	ecx, -1
	mov	QWORD PTR CodeInfo$[rsp+rax+48], rcx

; 3075 : #endif
; 3076 :   }

	jmp	SHORT $LN6@ParseLine
$LN7@ParseLine:

; 3077 :   CodeInfo.rm_byte = 0;

	mov	BYTE PTR CodeInfo$[rsp+104], 0

; 3078 :   CodeInfo.sib = 0;            /* assume ss is *1 */

	mov	BYTE PTR CodeInfo$[rsp+105], 0

; 3079 :   CodeInfo.Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	BYTE PTR CodeInfo$[rsp+106], al

; 3080 :   CodeInfo.opc_or = 0;

	mov	BYTE PTR CodeInfo$[rsp+107], 0

; 3081 :   CodeInfo.basetype = 0;

	mov	BYTE PTR CodeInfo$[rsp+108], 0

; 3082 : #if AVXSUPP
; 3083 :   CodeInfo.evex_sae = 0;

	mov	BYTE PTR CodeInfo$[rsp+141], 0

; 3084 :   CodeInfo.vexregop = 0;

	mov	BYTE PTR CodeInfo$[rsp+128], 0

; 3085 :   CodeInfo.tuple = 0;

	mov	BYTE PTR CodeInfo$[rsp+140], 0

; 3086 :   CodeInfo.vexconst = 0;

	mov	DWORD PTR CodeInfo$[rsp+124], 0

; 3087 :   CodeInfo.evex_flag = FALSE;  /* if TRUE will output 0x62 */

	mov	BYTE PTR CodeInfo$[rsp+136], 0

; 3088 :   CodeInfo.reg3 = 0xff;          /* if not reg3 make it negative  */

	mov	BYTE PTR CodeInfo$[rsp+111], 255	; 000000ffH

; 3089 :   CodeInfo.basereg = 0xff;

	mov	BYTE PTR CodeInfo$[rsp+113], 255	; 000000ffH

; 3090 :   CodeInfo.indexreg = 0xff;

	mov	BYTE PTR CodeInfo$[rsp+112], 255	; 000000ffH

; 3091 :   if (tokenarray[0].tokval >= T_KADDB && tokenarray[0].tokval <= T_KMOVW){

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 1687		; 00000697H
	jb	SHORT $LN89@ParseLine
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 1733		; 000006c5H
	ja	SHORT $LN89@ParseLine

; 3092 :     CodeInfo.evex_flag = FALSE;

	mov	BYTE PTR CodeInfo$[rsp+136], 0

; 3093 :   }

	jmp	SHORT $LN90@ParseLine
$LN89@ParseLine:

; 3094 :   else{
; 3095 :     //Init EVEX three bytes
; 3096 :     CodeInfo.evex_p0 = 0;      /* P0[3 : 2] Must be 0 */

	mov	BYTE PTR CodeInfo$[rsp+137], 0

; 3097 :     CodeInfo.evex_p1 = 0x4;    /* P1[2]    Must be 1  */

	mov	BYTE PTR CodeInfo$[rsp+138], 4

; 3098 :     CodeInfo.evex_p2 = 0;

	mov	BYTE PTR CodeInfo$[rsp+139], 0

; 3099 :     if (broadflags || decoflags)

	movzx	eax, BYTE PTR broadflags
	test	eax, eax
	jne	SHORT $LN92@ParseLine
	movzx	eax, BYTE PTR decoflags
	test	eax, eax
	je	SHORT $LN91@ParseLine
$LN92@ParseLine:

; 3100 :       CodeInfo.evex_flag = TRUE;   /* if TRUE will output 0x62 */

	mov	BYTE PTR CodeInfo$[rsp+136], 1
$LN91@ParseLine:
$LN90@ParseLine:

; 3101 :   }
; 3102 : #endif
; 3103 :   CodeInfo.flags = 0;

	mov	BYTE PTR CodeInfo$[rsp+142], 0

; 3104 : 
; 3105 :   /* instruction prefix?
; 3106 :    * T_LOCK, T_REP, T_REPE, T_REPNE, T_REPNZ, T_REPZ */
; 3107 :   if (tokenarray[i].tokval >= T_LOCK && tokenarray[i].tokval <= T_REPZ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 582		; 00000246H
	jb	$LN93@ParseLine
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 587		; 0000024bH
	ja	$LN93@ParseLine

; 3108 :     CodeInfo.prefix.ins = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR CodeInfo$[rsp], eax

; 3109 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 3110 :     /* prefix has to be followed by an instruction */
; 3111 :     if (tokenarray[i].token != T_INSTRUCTION) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 1
	je	SHORT $LN94@ParseLine

; 3112 :       DebugMsg(("ParseLine: unexpected token %u after prefix, exit, error\n", tokenarray[i].token));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12644
	call	DoDebugMsg

; 3113 :       return(EmitError(PREFIX_MUST_BE_FOLLOWED_BY_AN_INSTRUCTION));

	mov	ecx, 46					; 0000002eH
	call	EmitError
	jmp	$LN1@ParseLine
$LN94@ParseLine:

; 3114 :     }
; 3115 :     DebugMsg1(("ParseLine: %s\n", tokenarray[i].tokpos));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG12645
	call	DoDebugMsg1
$LN93@ParseLine:

; 3116 :   };
; 3117 : 
; 3118 :   if (CurrProc) {

	cmp	QWORD PTR CurrProc, 0
	je	$LN95@ParseLine

; 3119 :     switch (tokenarray[i].tokval) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR tv560[rsp], eax
	cmp	DWORD PTR tv560[rsp], 627		; 00000273H
	jb	$LN9@ParseLine
	cmp	DWORD PTR tv560[rsp], 628		; 00000274H
	jbe	SHORT $LN96@ParseLine
	cmp	DWORD PTR tv560[rsp], 649		; 00000289H
	je	SHORT $LN96@ParseLine
	cmp	DWORD PTR tv560[rsp], 1208		; 000004b8H
	je	SHORT $LN96@ParseLine
	jmp	$LN9@ParseLine
$LN96@ParseLine:

; 3120 :     case T_RET:
; 3121 :     case T_IRET:  /* IRET is always 16-bit; OTOH, IRETW doesn't exist */
; 3122 :     case T_IRETD:
; 3123 : #if AMD64_SUPPORT
; 3124 :     case T_IRETQ:
; 3125 : #endif
; 3126 :       if (!(ProcStatus & PRST_INSIDE_EPILOGUE) && ModuleInfo.epiloguemode != PEM_NONE) {

	mov	eax, DWORD PTR ProcStatus
	and	eax, 2
	test	eax, eax
	jne	$LN97@ParseLine
	movzx	eax, BYTE PTR ModuleInfo+425
	cmp	eax, 2
	je	$LN97@ParseLine

; 3127 :         /* v2.07: special handling for RET/IRET */
; 3128 :         FStoreLine((ModuleInfo.CurrComment && ModuleInfo.list_generated_code) ? 1 : 0);

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN98@ParseLine
	cmp	QWORD PTR ModuleInfo+472, 0
	je	SHORT $LN221@ParseLine
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 14
	and	eax, 1
	test	eax, eax
	je	SHORT $LN221@ParseLine
	mov	DWORD PTR tv571[rsp], 1
	jmp	SHORT $LN222@ParseLine
$LN221@ParseLine:
	mov	DWORD PTR tv571[rsp], 0
$LN222@ParseLine:
	xor	r8d, r8d
	mov	edx, DWORD PTR tv571[rsp]
	mov	rcx, QWORD PTR ModuleInfo+464
	call	StoreLine
$LN98@ParseLine:

; 3129 :         ProcStatus |= PRST_INSIDE_EPILOGUE;

	mov	eax, DWORD PTR ProcStatus
	or	eax, 2
	mov	DWORD PTR ProcStatus, eax

; 3130 :         temp = RetInstr(i, tokenarray, Token_Count);

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	RetInstr
	mov	DWORD PTR temp$[rsp], eax

; 3131 :         ProcStatus &= ~PRST_INSIDE_EPILOGUE;

	mov	eax, DWORD PTR ProcStatus
	and	eax, -3
	mov	DWORD PTR ProcStatus, eax

; 3132 :         return(temp);

	mov	eax, DWORD PTR temp$[rsp]
	jmp	$LN1@ParseLine
$LN97@ParseLine:

; 3133 :       }
; 3134 :       /* default translation: just RET to RETF if proc is far */
; 3135 :       /* v2.08: this code must run even if PRST_INSIDE_EPILOGUE is set */
; 3136 :       if (tokenarray[i].tokval == T_RET && CurrProc->sym.mem_type == MT_FAR)

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 649		; 00000289H
	jne	SHORT $LN100@ParseLine
	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+44], 130			; 00000082H
	jne	SHORT $LN100@ParseLine

; 3137 :         tokenarray[i].tokval = T_RETF;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	DWORD PTR [rcx+rax+16], 651		; 0000028bH
$LN100@ParseLine:
$LN9@ParseLine:
$LN95@ParseLine:

; 3138 :     }
; 3139 :   }
; 3140 : 
; 3141 :   FStoreLine(0); /* must be placed AFTER write_prologue() */

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN101@ParseLine
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR ModuleInfo+464
	call	StoreLine
$LN101@ParseLine:

; 3142 : 
; 3143 : #ifdef DEBUG_OUT
; 3144 :   instr = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR instr$[rsp], rax

; 3145 : #endif
; 3146 :   CodeInfo.token = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR CodeInfo$[rsp+24], eax

; 3147 :   /* get the instruction's start position in InstrTable[] */
; 3148 :   CodeInfo.pinstr = &InstrTable[IndexFromToken(CodeInfo.token)];

	mov	eax, DWORD PTR CodeInfo$[rsp+24]
	sub	eax, 455				; 000001c7H
	cdqe
	lea	rcx, OFFSET FLAT:optable_idx
	movzx	eax, WORD PTR [rcx+rax*2]
	imul	rax, rax, 14
	lea	rcx, OFFSET FLAT:InstrTable
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR CodeInfo$[rsp+16], rax

; 3149 :   i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 3150 : 
; 3151 :   if (CurrSeg == NULL) {

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN103@ParseLine

; 3152 :     return(EmitError(MUST_BE_IN_SEGMENT_BLOCK));

	mov	ecx, 82					; 00000052H
	call	EmitError
	jmp	$LN1@ParseLine
$LN103@ParseLine:

; 3153 :   }
; 3154 :   if (CurrSeg->e.seginfo->segtype == SEGTYPE_UNDEF) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+72], 0
	jne	SHORT $LN104@ParseLine

; 3155 :     CurrSeg->e.seginfo->segtype = SEGTYPE_CODE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	mov	DWORD PTR [rax+72], 1
$LN104@ParseLine:

; 3156 :   }
; 3157 :   if (ModuleInfo.CommentDataInCode)

	movzx	eax, BYTE PTR ModuleInfo+423
	test	eax, eax
	je	SHORT $LN105@ParseLine

; 3158 :     omf_OutSelect(FALSE);

	xor	ecx, ecx
	call	omf_OutSelect
$LN105@ParseLine:

; 3159 : 
; 3160 :   /* get the instruction's arguments.
; 3161 :    * This loop accepts up to 4 arguments if AVXSUPP is on */
; 3162 :   for (j = 0; j < sizeof(opndx) / sizeof(opndx[0]) && tokenarray[i].token != T_FINAL; j++) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN13@ParseLine
$LN11@ParseLine:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN13@ParseLine:
	movsxd	rax, DWORD PTR j$[rsp]
	cmp	rax, 4
	jae	$LN12@ParseLine
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN12@ParseLine

; 3163 :     if (j) 

	cmp	DWORD PTR j$[rsp], 0
	je	$LN106@ParseLine

; 3164 : 	{
; 3165 : 		
; 3166 : 		if (tokenarray[i].token != T_COMMA)

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN107@ParseLine

; 3167 : 			break;

	jmp	$LN12@ParseLine
$LN107@ParseLine:

; 3168 : 
; 3169 : 		/* inject xmmword ptr to relevant sse instructions */
; 3170 : 		if (Options.masm_compat_gencode && tokenarray[i].token == T_COMMA && (CodeInfo.token == T_SUBPD) ||(CodeInfo.token == T_SUBPS) || (CodeInfo.token == T_ADDPS) ||  (CodeInfo.token == T_ADDPD) || (CodeInfo.token == T_MULPD) || (CodeInfo.token == T_MULPS) || (CodeInfo.token == T_ANDPD) || (CodeInfo.token == T_ANDPS) || (CodeInfo.token == T_MOVAPD) || (CodeInfo.token == T_MOVAPS) || (CodeInfo.token == T_MOVUPS))

	movzx	eax, BYTE PTR Options+144
	test	eax, eax
	je	SHORT $LN110@ParseLine
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN110@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 877	; 0000036dH
	je	$LN109@ParseLine
$LN110@ParseLine:
	cmp	DWORD PTR CodeInfo$[rsp+24], 878	; 0000036eH
	je	SHORT $LN109@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 854	; 00000356H
	je	SHORT $LN109@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 853	; 00000355H
	je	SHORT $LN109@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 869	; 00000365H
	je	SHORT $LN109@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 870	; 00000366H
	je	SHORT $LN109@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 1014	; 000003f6H
	je	SHORT $LN109@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 1015	; 000003f7H
	je	SHORT $LN109@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 1048	; 00000418H
	je	SHORT $LN109@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 1049	; 00000419H
	je	SHORT $LN109@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 1053	; 0000041dH
	jne	$LN108@ParseLine
$LN109@ParseLine:

; 3171 : 		{
; 3172 : 
; 3173 : 			xmmOver0.tokpos = tokenarray[i].tokpos;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR xmmOver0+24, rax

; 3174 : 			xmmOver1.tokpos = tokenarray[i].tokpos;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR xmmOver1+24, rax

; 3175 : 			k = 0;

	mov	DWORD PTR k$[rsp], 0

; 3176 : 			n = ModuleInfo.token_count+1;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR n$[rsp], eax

; 3177 : 			for (k = 0; k < n-1; k++)

	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN16@ParseLine
$LN14@ParseLine:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN16@ParseLine:
	mov	eax, DWORD PTR n$[rsp]
	dec	eax
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN15@ParseLine

; 3178 : 			{
; 3179 : 				if (tokenarray[k].tokval == T_XMMWORD && tokenarray[k + 1].tokval == T_PTR)

	movsxd	rax, DWORD PTR k$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 228		; 000000e4H
	jne	SHORT $LN111@ParseLine
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 258		; 00000102H
	jne	SHORT $LN111@ParseLine

; 3180 : 					goto skipxmmsub;

	jmp	$skipxmmsub$229
$LN111@ParseLine:

; 3181 : 			}

	jmp	SHORT $LN14@ParseLine
$LN15@ParseLine:

; 3182 : 			for (k = n-1; k >= i+1; k--)

	mov	eax, DWORD PTR n$[rsp]
	dec	eax
	mov	DWORD PTR k$[rsp], eax
	jmp	SHORT $LN19@ParseLine
$LN17@ParseLine:
	mov	eax, DWORD PTR k$[rsp]
	dec	eax
	mov	DWORD PTR k$[rsp], eax
$LN19@ParseLine:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cmp	DWORD PTR k$[rsp], eax
	jl	SHORT $LN18@ParseLine

; 3183 : 			{
; 3184 : 				tokenarray[k+2] = tokenarray[k];

	movsxd	rax, DWORD PTR k$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, DWORD PTR k$[rsp]
	add	ecx, 2
	movsxd	rcx, ecx
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdi, QWORD PTR [rdx+rcx]
	lea	rsi, QWORD PTR [r8+rax]
	mov	ecx, 32					; 00000020H
	rep movsb

; 3185 : 			}

	jmp	SHORT $LN17@ParseLine
$LN18@ParseLine:

; 3186 : 			tokenarray[i + 1] = xmmOver0;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	lea	rdx, OFFSET FLAT:xmmOver0
	lea	rdi, QWORD PTR [rcx+rax]
	mov	rsi, rdx
	mov	ecx, 32					; 00000020H
	rep movsb

; 3187 : 			tokenarray[i + 2] = xmmOver1;

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 2
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	lea	rdx, OFFSET FLAT:xmmOver1
	lea	rdi, QWORD PTR [rcx+rax]
	mov	rsi, rdx
	mov	ecx, 32					; 00000020H
	rep movsb

; 3188 : 			ModuleInfo.token_count += 2;

	mov	eax, DWORD PTR ModuleInfo+496
	add	eax, 2
	mov	DWORD PTR ModuleInfo+496, eax
$LN108@ParseLine:
$skipxmmsub$229:

; 3189 : 		}
; 3190 : 	skipxmmsub:
; 3191 : 		i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN106@ParseLine:

; 3192 : 
; 3193 : 
; 3194 :     }
; 3195 : 
; 3196 :     DebugMsg1(("ParseLine(%s): calling EvalOperand, i=%u\n", instr, i));

	mov	r8d, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12663
	call	DoDebugMsg1

; 3197 : /*    if (CodeInfo.token == T_SUBPD) __debugbreak();*/
; 3198 :     if (EvalOperand(&i, tokenarray, Token_Count, &opndx[j], 0) == ERROR) {

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 104				; 00000068H
	lea	rax, QWORD PTR opndx$[rsp+rax]
	mov	BYTE PTR [rsp+32], 0
	mov	r9, rax
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN112@ParseLine

; 3199 :       DebugMsg(("ParseLine(%s): EvalOperand() failed\n", instr));

	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12665
	call	DoDebugMsg

; 3200 :       return(ERROR);

	mov	eax, -1
	jmp	$LN1@ParseLine
$LN112@ParseLine:

; 3201 :     }
; 3202 : 
; 3203 :     if (j == 2 && (opndx[j].kind == EXPR_REG)){

	cmp	DWORD PTR j$[rsp], 2
	jne	SHORT $LN113@ParseLine
	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 104				; 00000068H
	cmp	DWORD PTR opndx$[rsp+rax+60], 2
	jne	SHORT $LN113@ParseLine

; 3204 :       regtok = opndx[OPND3].base_reg->tokval;

	mov	eax, 104				; 00000068H
	imul	rax, rax, 2
	mov	rax, QWORD PTR opndx$[rsp+rax+24]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR regtok$[rsp], eax

; 3205 :       CodeInfo.reg3 = GetRegNo(regtok);

	movsxd	rax, DWORD PTR regtok$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR CodeInfo$[rsp+111], al
$LN113@ParseLine:

; 3206 :     }
; 3207 :     switch (opndx[j].kind) {

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	eax, DWORD PTR opndx$[rsp+rax+60]
	mov	DWORD PTR tv739[rsp], eax
	cmp	DWORD PTR tv739[rsp], -2
	je	$LN121@ParseLine
	cmp	DWORD PTR tv739[rsp], -1
	je	$LN123@ParseLine
	cmp	DWORD PTR tv739[rsp], 3
	je	SHORT $LN114@ParseLine
	cmp	DWORD PTR tv739[rsp], 4
	je	$LN118@ParseLine
	jmp	$LN20@ParseLine
$LN114@ParseLine:

; 3208 :     case EXPR_FLOAT:
; 3209 :       /* v2.06: accept float constants for PUSH */
; 3210 :       if (j == OPND2 || CodeInfo.token == T_PUSH || CodeInfo.token == T_PUSHD) {

	cmp	DWORD PTR j$[rsp], 1
	je	SHORT $LN116@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 601	; 00000259H
	je	SHORT $LN116@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 565	; 00000235H
	jne	$LN115@ParseLine
$LN116@ParseLine:

; 3211 : #if FPIMMEDIATE
; 3212 :         if (Options.strict_masm_compat == FALSE) {

	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	jne	$LN117@ParseLine

; 3213 :           /* convert to REAL4, unless REAL8 coercion is requested */
; 3214 :           atofloat(&opndx[j].fvalue, opndx[j].float_tok->string_ptr, opndx[j].mem_type == MT_REAL8 ? 8 : 4, opndx[j].negative, opndx[j].float_tok->floattype);

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 104				; 00000068H
	cmp	DWORD PTR opndx$[rsp+rax+64], 39	; 00000027H
	jne	SHORT $LN223@ParseLine
	mov	DWORD PTR tv764[rsp], 8
	jmp	SHORT $LN224@ParseLine
$LN223@ParseLine:
	mov	DWORD PTR tv764[rsp], 4
$LN224@ParseLine:
	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	rax, QWORD PTR opndx$[rsp+rax+16]
	movsxd	rcx, DWORD PTR j$[rsp]
	imul	rcx, rcx, 104				; 00000068H
	mov	ecx, DWORD PTR opndx$[rsp+rcx+72]
	shr	ecx, 5
	and	ecx, 1
	movsxd	rdx, DWORD PTR j$[rsp]
	imul	rdx, rdx, 104				; 00000068H
	mov	rdx, QWORD PTR opndx$[rsp+rdx+16]
	movsxd	rdi, DWORD PTR j$[rsp]
	imul	rdi, rdi, 104				; 00000068H
	lea	rdi, QWORD PTR opndx$[rsp+rdi]
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR [rsp+32], al
	movzx	r9d, cl
	mov	r8d, DWORD PTR tv764[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	rcx, rdi
	call	atofloat

; 3215 :           opndx[j].kind = EXPR_CONST;

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	DWORD PTR opndx$[rsp+rax+60], 0

; 3216 :           opndx[j].float_tok = NULL;

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	QWORD PTR opndx$[rsp+rax+16], 0

; 3217 :           break;

	jmp	$LN20@ParseLine
$LN117@ParseLine:

; 3218 :         }
; 3219 : #endif
; 3220 :         /* Masm message is: real or BCD number not allowed */
; 3221 :         return(EmitError(FP_INITIALIZER_IGNORED));

	mov	ecx, 74					; 0000004aH
	call	EmitError
	jmp	$LN1@ParseLine
$LN115@ParseLine:
$LN118@ParseLine:

; 3222 :       }
; 3223 : #if AVXSUPP
; 3224 :  /* here is handled EVEX Static Rounding Mode {sae}, {rn-sae}, {rd-sae}, {ru-sae}, {rz-sae} */
; 3225 :     case EXPR_DECORATOR:
; 3226 :       if (opndx[j - 1].indirect || opndx[j - 2].indirect)

	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 104				; 00000068H
	mov	eax, DWORD PTR opndx$[rsp+rax+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN120@ParseLine
	mov	eax, DWORD PTR j$[rsp]
	sub	eax, 2
	cdqe
	imul	rax, rax, 104				; 00000068H
	mov	eax, DWORD PTR opndx$[rsp+rax+72]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN119@ParseLine
$LN120@ParseLine:

; 3227 :         return(EmitError(EMBEDDED_ROUNDING_IS_AVAILABLE_ONLY_WITH_REG_REG_OP));

	mov	ecx, 21
	call	EmitError
	jmp	$LN1@ParseLine
$LN119@ParseLine:

; 3228 :         CodeInfo.evex_sae = opndx[j].saeflags;

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 104				; 00000068H
	movzx	eax, BYTE PTR opndx$[rsp+rax+70]
	mov	BYTE PTR CodeInfo$[rsp+141], al

; 3229 :         j--;

	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	mov	DWORD PTR j$[rsp], eax

; 3230 :         break;

	jmp	SHORT $LN20@ParseLine
$LN121@ParseLine:

; 3231 :       /* fall through */
; 3232 : #endif
; 3233 :     case EXPR_EMPTY:
; 3234 :       if (i == Token_Count)

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jne	SHORT $LN122@ParseLine

; 3235 :         i--;  /* v2.08: if there was a terminating comma, display it */

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN122@ParseLine:
$LN123@ParseLine:

; 3236 :       /* fall through */
; 3237 :     case EXPR_ERROR:
; 3238 :       DebugMsg(("ParseLine(%s): unexpected operand kind=%d, error, exit\n", instr, opndx[j].kind));

	movsxd	rax, DWORD PTR j$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	r8d, DWORD PTR opndx$[rsp+rax+60]
	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12677
	call	DoDebugMsg

; 3239 :       return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ParseLine
$LN20@ParseLine:

; 3240 :     }
; 3241 :   }

	jmp	$LN11@ParseLine
$LN12@ParseLine:

; 3242 :   if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN124@ParseLine

; 3243 :     DebugMsg(("ParseLine(%s): too many operands (%s) \n", instr, tokenarray[i].tokpos));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12679
	call	DoDebugMsg

; 3244 :     return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ParseLine
$LN124@ParseLine:

; 3245 :   }
; 3246 :   for (CurrOpnd = 0; CurrOpnd < j && CurrOpnd < MAX_OPND; CurrOpnd++) {

	mov	DWORD PTR CurrOpnd$[rsp], 0
	jmp	SHORT $LN24@ParseLine
$LN22@ParseLine:
	mov	eax, DWORD PTR CurrOpnd$[rsp]
	inc	eax
	mov	DWORD PTR CurrOpnd$[rsp], eax
$LN24@ParseLine:
	mov	eax, DWORD PTR j$[rsp]
	cmp	DWORD PTR CurrOpnd$[rsp], eax
	jae	$LN23@ParseLine
	cmp	DWORD PTR CurrOpnd$[rsp], 3
	jae	$LN23@ParseLine

; 3247 : 
; 3248 :     Frame_Type = FRAME_NONE;

	mov	BYTE PTR Frame_Type, 6

; 3249 :     SegOverride = NULL; /* segreg prefix is stored in RegOverride */

	mov	QWORD PTR SegOverride, 0

; 3250 :     CodeInfo.opnd[CurrOpnd].data32l = 0;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	DWORD PTR CodeInfo$[rsp+rax+40], 0

; 3251 :     CodeInfo.opnd[CurrOpnd].InsFixup = NULL;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 24
	mov	QWORD PTR CodeInfo$[rsp+rax+48], 0

; 3252 : #if AVXSUPP
; 3253 :     /* if encoding is VEX and destination op is XMM, YMM or memory,
; 3254 :      * the second argument may be stored in the vexregop field.
; 3255 :      */
; 3256 :     if (CodeInfo.token >= VEX_START &&
; 3257 :       CurrOpnd == OPND2 &&

	cmp	DWORD PTR CodeInfo$[rsp+24], 1296	; 00000510H
	jl	$LN125@ParseLine
	cmp	DWORD PTR CurrOpnd$[rsp], 1
	jne	$LN125@ParseLine
	mov	eax, 24
	imul	rax, rax, 0
	mov	eax, DWORD PTR CodeInfo$[rsp+rax+32]
	and	eax, -1082129940			; ffffffffbf8001ecH
	test	eax, eax
	je	$LN125@ParseLine

; 3258 :       (CodeInfo.opnd[OPND1].type & (OP_R32 | OP_R64 | OP_K | OP_XMM | OP_YMM | OP_ZMM | OP_M | OP_M64 | OP_M256 | OP_M512))) {
; 3259 :       CodeInfo.indexreg = 0xFF;

	mov	BYTE PTR CodeInfo$[rsp+112], 255	; 000000ffH

; 3260 :       CodeInfo.basereg = 0xFF;

	mov	BYTE PTR CodeInfo$[rsp+113], 255	; 000000ffH

; 3261 :       if (CodeInfo.token == T_VMOVSD || CodeInfo.token == T_VMOVSS){

	cmp	DWORD PTR CodeInfo$[rsp+24], 1944	; 00000798H
	je	SHORT $LN127@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 1945	; 00000799H
	jne	SHORT $LN126@ParseLine
$LN127@ParseLine:

; 3262 :           if (opndx[1].kind == EXPR_CONST)

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	cmp	DWORD PTR opndx$[rsp+rax+60], 0
	jne	SHORT $LN128@ParseLine

; 3263 :           return(EmitErr(INVALID_INSTRUCTION_OPERANDS));       }

	mov	ecx, 49					; 00000031H
	call	EmitErr
	jmp	$LN1@ParseLine
$LN128@ParseLine:
$LN126@ParseLine:

; 3264 :       if (opndx[OPND1].kind == EXPR_REG){

	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	cmp	DWORD PTR opndx$[rsp+rax+60], 2
	jne	$LN129@ParseLine

; 3265 :         regtok = opndx[OPND1].base_reg->tokval;

	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rax, QWORD PTR opndx$[rsp+rax+24]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR regtok$[rsp], eax

; 3266 :       CodeInfo.reg1 = GetRegNo(regtok);

	movsxd	rax, DWORD PTR regtok$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR CodeInfo$[rsp+109], al

; 3267 :       if (opndx[OPND1].idx_reg) CodeInfo.indexreg = opndx[OPND1].idx_reg->bytval;

	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	cmp	QWORD PTR opndx$[rsp+rax+32], 0
	je	SHORT $LN130@ParseLine
	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rax, QWORD PTR opndx$[rsp+rax+32]
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR CodeInfo$[rsp+112], al
$LN130@ParseLine:

; 3268 :       if (CodeInfo.reg1 > 15) CodeInfo.evex_flag = TRUE;

	movzx	eax, BYTE PTR CodeInfo$[rsp+109]
	cmp	eax, 15
	jle	SHORT $LN131@ParseLine
	mov	BYTE PTR CodeInfo$[rsp+136], 1
$LN131@ParseLine:

; 3269 :       CodeInfo.r1type = GetValueSp(opndx[OPND1].base_reg->tokval);

	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rax, QWORD PTR opndx$[rsp+rax+24]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR CodeInfo$[rsp+116], eax

; 3270 :       if (CodeInfo.r1type == OP_ZMM)CodeInfo.evex_flag = TRUE;

	cmp	DWORD PTR CodeInfo$[rsp+116], 256	; 00000100H
	jne	SHORT $LN132@ParseLine
	mov	BYTE PTR CodeInfo$[rsp+136], 1
$LN132@ParseLine:
$LN129@ParseLine:

; 3271 :       }
; 3272 :       if (opndx[OPND2].kind == EXPR_REG){

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	cmp	DWORD PTR opndx$[rsp+rax+60], 2
	jne	$LN133@ParseLine

; 3273 :         regtok = opndx[OPND2].base_reg->tokval;

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rax, QWORD PTR opndx$[rsp+rax+24]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR regtok$[rsp], eax

; 3274 :       CodeInfo.reg2 = GetRegNo(regtok);

	movsxd	rax, DWORD PTR regtok$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR CodeInfo$[rsp+110], al

; 3275 :       if (opndx[OPND2].idx_reg) CodeInfo.indexreg = opndx[OPND2].idx_reg->bytval;

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	cmp	QWORD PTR opndx$[rsp+rax+32], 0
	je	SHORT $LN134@ParseLine
	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rax, QWORD PTR opndx$[rsp+rax+32]
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR CodeInfo$[rsp+112], al
$LN134@ParseLine:

; 3276 :       if (CodeInfo.reg2 > 15) CodeInfo.evex_flag = TRUE;

	movzx	eax, BYTE PTR CodeInfo$[rsp+110]
	cmp	eax, 15
	jle	SHORT $LN135@ParseLine
	mov	BYTE PTR CodeInfo$[rsp+136], 1
$LN135@ParseLine:

; 3277 :        CodeInfo.r2type = GetValueSp(opndx[OPND2].base_reg->tokval);

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rax, QWORD PTR opndx$[rsp+rax+24]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR CodeInfo$[rsp+120], eax

; 3278 :        if (CodeInfo.r2type == OP_ZMM)CodeInfo.evex_flag = TRUE;

	cmp	DWORD PTR CodeInfo$[rsp+120], 256	; 00000100H
	jne	SHORT $LN136@ParseLine
	mov	BYTE PTR CodeInfo$[rsp+136], 1
$LN136@ParseLine:
$LN133@ParseLine:

; 3279 :        }
; 3280 :       if (((CodeInfo.token == T_ANDN)||(CodeInfo.token == T_MULX)||
; 3281 :         (CodeInfo.token == T_PEXT)||(CodeInfo.token == T_PDEP)) &&

	cmp	DWORD PTR CodeInfo$[rsp+24], 1674	; 0000068aH
	je	SHORT $LN138@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 1675	; 0000068bH
	je	SHORT $LN138@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 1685	; 00000695H
	je	SHORT $LN138@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 1684	; 00000694H
	jne	SHORT $LN137@ParseLine
$LN138@ParseLine:
	cmp	DWORD PTR CurrOpnd$[rsp], 1
	jne	SHORT $LN137@ParseLine

; 3282 :         (CurrOpnd == OPND2 )) goto putinvex;

	jmp	$putinvex$230
$LN137@ParseLine:

; 3283 :       if (vex_flags[CodeInfo.token - VEX_START] & VX_NND)

	mov	eax, DWORD PTR CodeInfo$[rsp+24]
	sub	eax, 1296				; 00000510H
	cdqe
	lea	rcx, OFFSET FLAT:vex_flags
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN139@ParseLine

; 3284 :         ;

	jmp	$LN140@ParseLine
$LN139@ParseLine:

; 3285 :       else if ((vex_flags[CodeInfo.token - VEX_START] & VX_IMM) &&
; 3286 :         (opndx[OPND3].kind == EXPR_CONST) && (j > 2))

	mov	eax, DWORD PTR CodeInfo$[rsp+24]
	sub	eax, 1296				; 00000510H
	cdqe
	lea	rcx, OFFSET FLAT:vex_flags
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN141@ParseLine
	mov	eax, 104				; 00000068H
	imul	rax, rax, 2
	cmp	DWORD PTR opndx$[rsp+rax+60], 0
	jne	SHORT $LN141@ParseLine
	cmp	DWORD PTR j$[rsp], 2
	jle	SHORT $LN141@ParseLine

; 3287 :         ;

	jmp	$LN142@ParseLine
$LN141@ParseLine:

; 3288 :       else if ((vex_flags[CodeInfo.token - VEX_START] & VX_NMEM) &&

	mov	eax, DWORD PTR CodeInfo$[rsp+24]
	sub	eax, 1296				; 00000510H
	cdqe
	lea	rcx, OFFSET FLAT:vex_flags
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN143@ParseLine
	mov	eax, 24
	imul	rax, rax, 0
	mov	eax, DWORD PTR CodeInfo$[rsp+rax+32]
	and	eax, -1887436800			; ffffffff8f800000H
	test	eax, eax
	jne	SHORT $LN145@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 1944	; 00000798H
	je	SHORT $LN146@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 1945	; 00000799H
	jne	SHORT $LN143@ParseLine
$LN146@ParseLine:
	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	cmp	DWORD PTR opndx$[rsp+rax+60], 2
	jne	SHORT $LN147@ParseLine
	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	eax, DWORD PTR opndx$[rsp+rax+72]
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN143@ParseLine
$LN147@ParseLine:
$LN145@ParseLine:

; 3289 :         ((CodeInfo.opnd[OPND1].type & OP_M) ||
; 3290 :         /* v2.11: VMOVSD and VMOVSS always have 2 ops if a memory op is involved */
; 3291 :         ((CodeInfo.token == T_VMOVSD || CodeInfo.token == T_VMOVSS) &&
; 3292 :         (opndx[OPND2].kind != EXPR_REG || opndx[OPND2].indirect == TRUE))))
; 3293 :          ;

	jmp	$LN144@ParseLine
$LN143@ParseLine:

; 3294 :       else {
; 3295 :         if (opndx[OPND2].kind != EXPR_REG ||

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	cmp	DWORD PTR opndx$[rsp+rax+60], 2
	jne	SHORT $LN149@ParseLine
	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	rax, QWORD PTR opndx$[rsp+rax+24]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, 492				; 000001ecH
	test	eax, eax
	jne	SHORT $LN148@ParseLine
$LN149@ParseLine:

; 3296 :           (!(GetValueSp(opndx[CurrOpnd].base_reg->tokval) & (OP_R32 | OP_R64 |OP_K | OP_XMM | OP_YMM | OP_ZMM)))) {
; 3297 :           DebugMsg(("ParseLine(%s,%u): avx invalid operand, op2.kind=%u\n", instr, CurrOpnd, opndx[OPND2].kind));

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	r9d, DWORD PTR opndx$[rsp+rax+60]
	mov	r8d, DWORD PTR CurrOpnd$[rsp]
	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12705
	call	DoDebugMsg

; 3298 :           if ((CodeInfo.token < T_KMOVB) && (CodeInfo.token > T_KMOVW))

	cmp	DWORD PTR CodeInfo$[rsp+24], 1730	; 000006c2H
	jge	SHORT $LN150@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 1733	; 000006c5H
	jle	SHORT $LN150@ParseLine

; 3299 :             return(EmitErr(INVALID_INSTRUCTION_OPERANDS));

	mov	ecx, 49					; 00000031H
	call	EmitErr
	jmp	$LN1@ParseLine
$LN150@ParseLine:
$LN148@ParseLine:

; 3300 :         }
; 3301 :         /* fixme: check if there's an operand behind OPND2 at all!
; 3302 :          * if no, there's no point to continue with switch (opndx[].kind).
; 3303 :          * v2.11: additional check for j <= 2 added
; 3304 :          */
; 3305 :         if (j <= 2) {

	cmp	DWORD PTR j$[rsp], 2
	jg	SHORT $LN151@ParseLine

; 3306 :           DebugMsg(("ParseLine(%s,%u): avx not enough operands (%u)\n", instr, CurrOpnd, opndx[OPND2].kind, j));

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	ecx, DWORD PTR j$[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR opndx$[rsp+rax+60]
	mov	r8d, DWORD PTR CurrOpnd$[rsp]
	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12709
	call	DoDebugMsg

; 3307 :           /* v2.11: next line should be activated - currently the error is emitted below as syntax error */
; 3308 :           //return( EmitErr( INVALID_INSTRUCTION_OPERANDS ) );
; 3309 :         }

	jmp	$LN152@ParseLine
$LN151@ParseLine:

; 3310 :         else
; 3311 : 
; 3312 : 		  /* flag VX_DST is set if an immediate is expected as operand 3 */
; 3313 : 			if ((vex_flags[CodeInfo.token - VEX_START] & VX_DST) &&

	mov	eax, DWORD PTR CodeInfo$[rsp+24]
	sub	eax, 1296				; 00000510H
	cdqe
	lea	rcx, OFFSET FLAT:vex_flags
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 4
	test	eax, eax
	je	$LN153@ParseLine
	mov	eax, 104				; 00000068H
	imul	rax, rax, 2
	cmp	DWORD PTR opndx$[rsp+rax+60], 0
	jne	$LN153@ParseLine

; 3314 : 				(opndx[OPND3].kind == EXPR_CONST)) {
; 3315 : 				DebugMsg1(("ParseLine(%s,%u): avx VX_DST, op3.kind=CONST (value=%u), numops=%u\n", instr, CurrOpnd, opndx[OPND3].kind, opndx[OPND3].value, j));

	mov	eax, 104				; 00000068H
	imul	rax, rax, 2
	mov	ecx, 104				; 00000068H
	imul	rcx, rcx, 2
	mov	edx, DWORD PTR j$[rsp]
	mov	DWORD PTR [rsp+40], edx
	mov	eax, DWORD PTR opndx$[rsp+rax]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR opndx$[rsp+rcx+60]
	mov	r8d, DWORD PTR CurrOpnd$[rsp]
	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12712
	call	DoDebugMsg1

; 3316 : 				if (opndx[OPND2].idx_reg)

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	cmp	QWORD PTR opndx$[rsp+rax+32], 0
	je	SHORT $LN155@ParseLine

; 3317 : 					CodeInfo.indexreg = opndx[OPND2].idx_reg->bytval;

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rax, QWORD PTR opndx$[rsp+rax+32]
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR CodeInfo$[rsp+112], al
$LN155@ParseLine:

; 3318 : 				if (opndx[OPND2].base_reg)

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	cmp	QWORD PTR opndx$[rsp+rax+24], 0
	je	SHORT $LN156@ParseLine

; 3319 : 					CodeInfo.basereg = opndx[OPND2].base_reg->bytval;

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rax, QWORD PTR opndx$[rsp+rax+24]
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR CodeInfo$[rsp+113], al
$LN156@ParseLine:

; 3320 : 				/* third operand data goes in CodeInfo.vexconst used in codegen.c */
; 3321 : 				CodeInfo.vexconst = opndx[CurrOpnd].value;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	eax, DWORD PTR opndx$[rsp+rax]
	mov	DWORD PTR CodeInfo$[rsp+124], eax

; 3322 : 				if (opndx[OPND1].base_reg) {

	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	cmp	QWORD PTR opndx$[rsp+rax+24], 0
	je	SHORT $LN157@ParseLine

; 3323 : 					/* first operand register is moved to vexregop */
; 3324 : 					/* handle VEX.NDD */
; 3325 : 					CodeInfo.vexregop = opndx[OPND1].base_reg->bytval + 1;

	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rax, QWORD PTR opndx$[rsp+rax+24]
	movzx	eax, BYTE PTR [rax+1]
	inc	eax
	mov	BYTE PTR CodeInfo$[rsp+128], al

; 3326 : 					memcpy(&opndx[OPND1], &opndx[CurrOpnd], sizeof(opndx[0]) * 3);

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	lea	rax, QWORD PTR opndx$[rsp+rax]
	mov	ecx, 104				; 00000068H
	imul	rcx, rcx, 0
	lea	rcx, QWORD PTR opndx$[rsp+rcx]
	mov	r8d, 312				; 00000138H
	mov	rdx, rax
	call	memcpy

; 3327 : 					CodeInfo.rm_byte = 0;

	mov	BYTE PTR CodeInfo$[rsp+104], 0

; 3328 : 					if (process_register(&CodeInfo, OPND1, opndx) == ERROR)

	lea	r8, QWORD PTR opndx$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	process_register
	cmp	eax, -1
	jne	SHORT $LN158@ParseLine

; 3329 : 						return(ERROR);

	mov	eax, -1
	jmp	$LN1@ParseLine
$LN158@ParseLine:
$LN157@ParseLine:

; 3330 : 				}
; 3331 : 			}

	jmp	$LN154@ParseLine
$LN153@ParseLine:

; 3332 : 
; 3333 :           else if (CodeInfo.token < T_VGETMANTPD || CodeInfo.token > T_VGETMANTPS ) {

	cmp	DWORD PTR CodeInfo$[rsp+24], 1434	; 0000059aH
	jl	SHORT $LN161@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 1435	; 0000059bH
	jle	$LN159@ParseLine
$LN161@ParseLine:

; 3334 :             unsigned flags = GetValueSp(opndx[CurrOpnd].base_reg->tokval);

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	rax, QWORD PTR opndx$[rsp+rax+24]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR flags$1[rsp], eax

; 3335 :             //CodeInfo.rtype = GetValueSp(opndx[CurrOpnd].base_reg->tokval);
; 3336 :             DebugMsg1(("ParseLine(%s,%u): opnd2 is avx reg (%s), flags=%X ci.type[0]=%X numops=%u\n",

	mov	eax, 24
	imul	rax, rax, 0
	mov	ecx, DWORD PTR CurrOpnd$[rsp]
	imul	rcx, rcx, 104				; 00000068H
	mov	rcx, QWORD PTR opndx$[rsp+rcx+24]
	mov	edx, DWORD PTR j$[rsp]
	mov	DWORD PTR [rsp+48], edx
	mov	eax, DWORD PTR CodeInfo$[rsp+rax+32]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR flags$1[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR [rcx+8]
	mov	r8d, DWORD PTR CurrOpnd$[rsp]
	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12720
	call	DoDebugMsg1

; 3337 :               instr, CurrOpnd, opndx[CurrOpnd].base_reg->string_ptr, flags, CodeInfo.opnd[OPND1].type, j));
; 3338 : //#if 1
; 3339 :             /* v2.08: no error here if first op is an untyped memory reference
; 3340 :              * note that OP_M includes OP_M128, but not OP_M256 (to be fixed?)
; 3341 :              */
; 3342 :             if (CodeInfo.opnd[OPND1].type == OP_M)

	mov	eax, 24
	imul	rax, rax, 0
	cmp	DWORD PTR CodeInfo$[rsp+rax+32], -1887436800 ; ffffffff8f800000H
	jne	SHORT $LN162@ParseLine

; 3343 :               ; else

	jmp	$LN163@ParseLine
$LN162@ParseLine:

; 3344 : //#endif
; 3345 :               if ((flags & (OP_XMM | OP_M128)) &&
; 3346 :                 (CodeInfo.opnd[OPND1].type & (OP_YMM | OP_M256)) ||

	mov	eax, DWORD PTR flags$1[rsp]
	and	eax, 134217760				; 08000020H
	test	eax, eax
	je	SHORT $LN166@ParseLine
	mov	eax, 24
	imul	rax, rax, 0
	mov	eax, DWORD PTR CodeInfo$[rsp+rax+32]
	and	eax, 268435584				; 10000080H
	test	eax, eax
	jne	SHORT $LN165@ParseLine
$LN166@ParseLine:
	mov	eax, DWORD PTR flags$1[rsp]
	and	eax, 268435584				; 10000080H
	test	eax, eax
	je	SHORT $LN164@ParseLine
	mov	eax, 24
	imul	rax, rax, 0
	mov	eax, DWORD PTR CodeInfo$[rsp+rax+32]
	and	eax, 134217760				; 08000020H
	test	eax, eax
	je	SHORT $LN164@ParseLine
$LN165@ParseLine:

; 3347 :                 (flags & (OP_YMM | OP_M256)) &&
; 3348 :                 (CodeInfo.opnd[OPND1].type & (OP_XMM | OP_M128))) {
; 3349 :                 DebugMsg(("ParseLine(%s,%u): avx invalid opnd 2, flags=%X ci.type[0]=%X\n", instr, CurrOpnd, flags, CodeInfo.opnd[OPND1].type));

	mov	eax, 24
	imul	rax, rax, 0
	mov	eax, DWORD PTR CodeInfo$[rsp+rax+32]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR flags$1[rsp]
	mov	r8d, DWORD PTR CurrOpnd$[rsp]
	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12726
	call	DoDebugMsg

; 3350 :                 return(EmitErr(INVALID_INSTRUCTION_OPERANDS));

	mov	ecx, 49					; 00000031H
	call	EmitErr
	jmp	$LN1@ParseLine
$LN164@ParseLine:
$LN163@ParseLine:
$putinvex$230:

; 3351 :               }
; 3352 :             /* second operand register is moved to vexregop */
; 3353 :             /* to be fixed: CurrOpnd is always OPND2, so use this const here */
; 3354 :             //CodeInfo.vexdata is containing I_U8 data of EXPR_CONST ,habran
; 3355 :        putinvex:
; 3356 :             CodeInfo.vexconst = opndx[CurrOpnd].value;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	eax, DWORD PTR opndx$[rsp+rax]
	mov	DWORD PTR CodeInfo$[rsp+124], eax

; 3357 :             CodeInfo.vexregop = opndx[CurrOpnd].base_reg->bytval + 1;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	rax, QWORD PTR opndx$[rsp+rax+24]
	movzx	eax, BYTE PTR [rax+1]
	inc	eax
	mov	BYTE PTR CodeInfo$[rsp+128], al

; 3358 :             memcpy(&opndx[CurrOpnd], &opndx[CurrOpnd + 1], sizeof(opndx[0]) * 2);

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	inc	eax
	mov	eax, eax
	imul	rax, rax, 104				; 00000068H
	lea	rax, QWORD PTR opndx$[rsp+rax]
	mov	ecx, DWORD PTR CurrOpnd$[rsp]
	imul	rcx, rcx, 104				; 00000068H
	lea	rcx, QWORD PTR opndx$[rsp+rcx]
	mov	r8d, 208				; 000000d0H
	mov	rdx, rax
	call	memcpy

; 3359 :           }

	jmp	SHORT $LN160@ParseLine
$LN159@ParseLine:

; 3360 :           else
; 3361 :           {
; 3362 :             CodeInfo.vexconst = opndx[CurrOpnd + 1].value;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	inc	eax
	mov	eax, eax
	imul	rax, rax, 104				; 00000068H
	mov	eax, DWORD PTR opndx$[rsp+rax]
	mov	DWORD PTR CodeInfo$[rsp+124], eax

; 3363 :             j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN160@ParseLine:
$LN154@ParseLine:
$LN152@ParseLine:

; 3364 :           }
; 3365 :           j--;

	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	mov	DWORD PTR j$[rsp], eax
$LN144@ParseLine:
$LN142@ParseLine:
$LN140@ParseLine:
$LN125@ParseLine:

; 3366 :       }
; 3367 :     }
; 3368 : #endif
; 3369 :     DebugMsg1(("ParseLine(%s,%u): type/value/mem_type/ofssize=%Xh/%" I64_SPEC "Xh/%Xh/%d\n", instr, CurrOpnd, opndx[CurrOpnd].kind, opndx[CurrOpnd].value64, opndx[CurrOpnd].mem_type, opndx[CurrOpnd].Ofssize));

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	movzx	eax, BYTE PTR opndx$[rsp+rax+69]
	mov	ecx, DWORD PTR CurrOpnd$[rsp]
	imul	rcx, rcx, 104				; 00000068H
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	imul	rdx, rdx, 104				; 00000068H
	mov	edi, DWORD PTR CurrOpnd$[rsp]
	imul	rdi, rdi, 104				; 00000068H
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR opndx$[rsp+rcx+64]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR opndx$[rsp+rdx]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR opndx$[rsp+rdi+60]
	mov	r8d, DWORD PTR CurrOpnd$[rsp]
	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12727
	call	DoDebugMsg1

; 3370 :     switch (opndx[CurrOpnd].kind) {

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	eax, DWORD PTR opndx$[rsp+rax+60]
	mov	DWORD PTR tv1260[rsp], eax
	cmp	DWORD PTR tv1260[rsp], 0
	je	$LN170@ParseLine
	cmp	DWORD PTR tv1260[rsp], 1
	je	SHORT $LN168@ParseLine
	cmp	DWORD PTR tv1260[rsp], 2
	je	$LN172@ParseLine
	cmp	DWORD PTR tv1260[rsp], 4
	je	SHORT $LN167@ParseLine
	jmp	$LN25@ParseLine
$LN167@ParseLine:

; 3371 :     case EXPR_DECORATOR:
; 3372 :       CodeInfo.evex_sae = opndx[CurrOpnd].saeflags;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	movzx	eax, BYTE PTR opndx$[rsp+rax+70]
	mov	BYTE PTR CodeInfo$[rsp+141], al

; 3373 :       return( codegen( &CodeInfo, oldofs ) );

	mov	edx, DWORD PTR oldofs$[rsp]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	codegen
	jmp	$LN1@ParseLine
$LN168@ParseLine:

; 3374 :     case EXPR_ADDR:
; 3375 :       DebugMsg1(("ParseLine(%s,%u): type ADDRESS\n", instr, CurrOpnd));

	mov	r8d, DWORD PTR CurrOpnd$[rsp]
	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12730
	call	DoDebugMsg1

; 3376 :       if (process_address(&CodeInfo, CurrOpnd, &opndx[CurrOpnd]) == ERROR)

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	lea	rax, QWORD PTR opndx$[rsp+rax]
	mov	r8, rax
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	process_address
	cmp	eax, -1
	jne	SHORT $LN169@ParseLine

; 3377 :         return(ERROR);

	mov	eax, -1
	jmp	$LN1@ParseLine
$LN169@ParseLine:

; 3378 :       break;

	jmp	$LN25@ParseLine
$LN170@ParseLine:

; 3379 :     case EXPR_CONST:
; 3380 :       DebugMsg1(("ParseLine(%s,%u): type CONST, opndx.memtype=%Xh\n", instr, CurrOpnd, opndx[CurrOpnd].mem_type));

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	r9d, DWORD PTR opndx$[rsp+rax+64]
	mov	r8d, DWORD PTR CurrOpnd$[rsp]
	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12733
	call	DoDebugMsg1

; 3381 :       if (process_const(&CodeInfo, CurrOpnd, &opndx[CurrOpnd]) == ERROR)

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	lea	rax, QWORD PTR opndx$[rsp+rax]
	mov	r8, rax
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	process_const
	cmp	eax, -1
	jne	SHORT $LN171@ParseLine

; 3382 :         return(ERROR);

	mov	eax, -1
	jmp	$LN1@ParseLine
$LN171@ParseLine:

; 3383 :       break;

	jmp	$LN25@ParseLine
$LN172@ParseLine:

; 3384 :     case EXPR_REG:
; 3385 :       DebugMsg1(("ParseLine(%s,%u): type REG\n", instr, CurrOpnd));

	mov	r8d, DWORD PTR CurrOpnd$[rsp]
	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12736
	call	DoDebugMsg1

; 3386 :       if (opndx[CurrOpnd].indirect) { /* indirect operand ( "[EBX+...]" )? */

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	mov	eax, DWORD PTR opndx$[rsp+rax+72]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN173@ParseLine

; 3387 :         if (process_address(&CodeInfo, CurrOpnd, &opndx[CurrOpnd]) == ERROR)

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	lea	rax, QWORD PTR opndx$[rsp+rax]
	mov	r8, rax
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	process_address
	cmp	eax, -1
	jne	SHORT $LN175@ParseLine

; 3388 :           return(ERROR);

	mov	eax, -1
	jmp	$LN1@ParseLine
$LN175@ParseLine:

; 3389 :       }

	jmp	$LN174@ParseLine
$LN173@ParseLine:

; 3390 :       else {
; 3391 :         /* process_register() can't handle 3rd operand */
; 3392 :         if (!CodeInfo.vexregop){

	movzx	eax, BYTE PTR CodeInfo$[rsp+128]
	test	eax, eax
	jne	$LN176@ParseLine

; 3393 :           if (CurrOpnd == OPND1){

	cmp	DWORD PTR CurrOpnd$[rsp], 0
	jne	SHORT $LN177@ParseLine

; 3394 :             regtok = opndx[OPND1].base_reg->tokval;

	mov	eax, 104				; 00000068H
	imul	rax, rax, 0
	mov	rax, QWORD PTR opndx$[rsp+rax+24]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR regtok$[rsp], eax

; 3395 :             CodeInfo.reg1 = GetRegNo(regtok);

	movsxd	rax, DWORD PTR regtok$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR CodeInfo$[rsp+109], al

; 3396 :             if (CodeInfo.reg1 > 15) CodeInfo.evex_flag = TRUE;

	movzx	eax, BYTE PTR CodeInfo$[rsp+109]
	cmp	eax, 15
	jle	SHORT $LN179@ParseLine
	mov	BYTE PTR CodeInfo$[rsp+136], 1
$LN179@ParseLine:

; 3397 :           }

	jmp	SHORT $LN178@ParseLine
$LN177@ParseLine:

; 3398 :           else if (CurrOpnd == OPND2){

	cmp	DWORD PTR CurrOpnd$[rsp], 1
	jne	SHORT $LN180@ParseLine

; 3399 :             regtok = opndx[OPND2].base_reg->tokval;

	mov	eax, 104				; 00000068H
	imul	rax, rax, 1
	mov	rax, QWORD PTR opndx$[rsp+rax+24]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR regtok$[rsp], eax

; 3400 :             CodeInfo.reg2 = GetRegNo(regtok);

	movsxd	rax, DWORD PTR regtok$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR CodeInfo$[rsp+110], al

; 3401 :             if (CodeInfo.reg2 > 15) CodeInfo.evex_flag = TRUE;

	movzx	eax, BYTE PTR CodeInfo$[rsp+110]
	cmp	eax, 15
	jle	SHORT $LN181@ParseLine
	mov	BYTE PTR CodeInfo$[rsp+136], 1
$LN181@ParseLine:
$LN180@ParseLine:
$LN178@ParseLine:
$LN176@ParseLine:

; 3402 :           }
; 3403 :         }
; 3404 :         if (CurrOpnd == OPND3) {

	cmp	DWORD PTR CurrOpnd$[rsp], 2
	jne	$LN182@ParseLine

; 3405 :           CodeInfo.opnd[OPND3].type = GetValueSp(opndx[OPND3].base_reg->tokval);

	mov	eax, 104				; 00000068H
	imul	rax, rax, 2
	mov	rax, QWORD PTR opndx$[rsp+rax+24]
	mov	eax, DWORD PTR [rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	edx, 24
	imul	rdx, rdx, 2
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR CodeInfo$[rsp+rdx+32], eax

; 3406 :           CodeInfo.opnd[OPND3].data32l = opndx[OPND3].base_reg->bytval;

	mov	eax, 104				; 00000068H
	imul	rax, rax, 2
	mov	rax, QWORD PTR opndx$[rsp+rax+24]
	mov	ecx, 24
	imul	rcx, rcx, 2
	movzx	eax, BYTE PTR [rax+1]
	mov	DWORD PTR CodeInfo$[rsp+rcx+40], eax

; 3407 :           regtok = opndx[OPND3].base_reg->tokval;

	mov	eax, 104				; 00000068H
	imul	rax, rax, 2
	mov	rax, QWORD PTR opndx$[rsp+rax+24]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR regtok$[rsp], eax

; 3408 :           CodeInfo.reg3 = GetRegNo(regtok);

	movsxd	rax, DWORD PTR regtok$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR CodeInfo$[rsp+111], al

; 3409 :           if (CodeInfo.reg3 > 15) CodeInfo.evex_flag = TRUE;

	movzx	eax, BYTE PTR CodeInfo$[rsp+111]
	cmp	eax, 15
	jle	SHORT $LN184@ParseLine
	mov	BYTE PTR CodeInfo$[rsp+136], 1
$LN184@ParseLine:

; 3410 :         }

	jmp	SHORT $LN183@ParseLine
$LN182@ParseLine:

; 3411 :         else if (process_register(&CodeInfo, CurrOpnd, opndx) == ERROR)

	lea	r8, QWORD PTR opndx$[rsp]
	mov	edx, DWORD PTR CurrOpnd$[rsp]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	process_register
	cmp	eax, -1
	jne	SHORT $LN185@ParseLine

; 3412 :           return(ERROR);

	mov	eax, -1
	jmp	$LN1@ParseLine
$LN185@ParseLine:
$LN183@ParseLine:
$LN174@ParseLine:
$LN25@ParseLine:

; 3413 :       }
; 3414 :       break;
; 3415 :     }
; 3416 :    } /* end for */

	jmp	$LN22@ParseLine
$LN23@ParseLine:

; 3417 : 
; 3418 : #if AVXSUPP
; 3419 : 	 /* 4 arguments are valid vor AVX only */
; 3420 :    if (CurrOpnd != j) {

	mov	eax, DWORD PTR j$[rsp]
	cmp	DWORD PTR CurrOpnd$[rsp], eax
	je	$LN186@ParseLine
	jmp	SHORT $LN29@ParseLine
$LN27@ParseLine:

; 3421 : 	   for (; tokenarray[i].token != T_COMMA; i--);

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN29@ParseLine:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN28@ParseLine
	jmp	SHORT $LN27@ParseLine
$LN28@ParseLine:

; 3422 : 	   DebugMsg(("ParseLine(%s): CurrOpnd != j ( %u - %u ) >%s<\n", instr, CurrOpnd, j, tokenarray[i].tokpos));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR j$[rsp]
	mov	r8d, DWORD PTR CurrOpnd$[rsp]
	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12751
	call	DoDebugMsg

; 3423 : 	   if (CodeInfo.token < VEX_START)

	cmp	DWORD PTR CodeInfo$[rsp+24], 1296	; 00000510H
	jge	SHORT $LN187@ParseLine

; 3424 : 		   return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ParseLine
	jmp	SHORT $LN188@ParseLine
$LN187@ParseLine:

; 3425 : 	   else
; 3426 : 		   if ((CodeInfo.token == T_VMASKMOVPS || CodeInfo.token == T_VMASKMOVPD) && (j < 3))

	cmp	DWORD PTR CodeInfo$[rsp+24], 1326	; 0000052eH
	je	SHORT $LN190@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 1327	; 0000052fH
	jne	SHORT $LN189@ParseLine
$LN190@ParseLine:
	cmp	DWORD PTR j$[rsp], 3
	jge	SHORT $LN189@ParseLine

; 3427 : 			   return(EmitErr(MISSING_OPERATOR_IN_EXPRESSION));

	mov	ecx, 150				; 00000096H
	call	EmitErr
	jmp	$LN1@ParseLine
$LN189@ParseLine:
$LN188@ParseLine:
$LN186@ParseLine:

; 3428 :    }
; 3429 :    if (CodeInfo.token == T_VBLENDVPS || CodeInfo.token == T_VBLENDVPD) {

	cmp	DWORD PTR CodeInfo$[rsp+24], 1315	; 00000523H
	je	SHORT $LN192@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 1314	; 00000522H
	jne	SHORT $LN191@ParseLine
$LN192@ParseLine:

; 3430 : 	   DebugMsg(("ParseLine(%s): ( %u - %u ) >%s<\n", instr, CurrOpnd, j, tokenarray[i].tokpos));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR j$[rsp]
	mov	r8d, DWORD PTR CurrOpnd$[rsp]
	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12758
	call	DoDebugMsg

; 3431 : 	   if (CodeInfo.opnd[OPND3].type == OP_NONE) {

	mov	eax, 24
	imul	rax, rax, 2
	cmp	DWORD PTR CodeInfo$[rsp+rax+32], 0
	jne	SHORT $LN193@ParseLine

; 3432 : 		   return (EmitErr(MISSING_OPERATOR_IN_EXPRESSION));

	mov	ecx, 150				; 00000096H
	call	EmitErr
	jmp	$LN1@ParseLine
$LN193@ParseLine:
$LN191@ParseLine:

; 3433 : 	   }
; 3434 :    }
; 3435 : 
; 3436 : #endif
; 3437 : 
; 3438 :   /* for FAR calls/jmps some special handling is required:
; 3439 :    * in the instruction tables, the "far" entries are located BEHIND
; 3440 :    * the "near" entries, that's why it's needed to skip all items
; 3441 :    * until the next "first" item is found.
; 3442 :    */
; 3443 :   if (CodeInfo.isfar) {

	movzx	eax, BYTE PTR CodeInfo$[rsp+142]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN194@ParseLine

; 3444 :     if (CodeInfo.token == T_CALL || CodeInfo.token == T_JMP) {

	cmp	DWORD PTR CodeInfo$[rsp+24], 455	; 000001c7H
	je	SHORT $LN196@ParseLine
	cmp	DWORD PTR CodeInfo$[rsp+24], 456	; 000001c8H
	jne	SHORT $LN195@ParseLine
$LN196@ParseLine:
$LN32@ParseLine:

; 3445 :       do {
; 3446 :         CodeInfo.pinstr++;

	mov	rax, QWORD PTR CodeInfo$[rsp+16]
	add	rax, 14
	mov	QWORD PTR CodeInfo$[rsp+16], rax

; 3447 :       } while (CodeInfo.pinstr->first == FALSE);

	mov	rax, QWORD PTR CodeInfo$[rsp+16]
	movzx	eax, BYTE PTR [rax+4]
	test	eax, eax
	je	SHORT $LN32@ParseLine
$LN195@ParseLine:
$LN194@ParseLine:

; 3448 :     }
; 3449 :   }
; 3450 :   /* special handling for string instructions */
; 3451 : 
; 3452 :   if (CodeInfo.pinstr->allowed_prefix == AP_REP ||

	mov	rax, QWORD PTR CodeInfo$[rsp+16]
	movzx	eax, WORD PTR [rax+2]
	cmp	eax, 2
	je	SHORT $LN199@ParseLine
	mov	rax, QWORD PTR CodeInfo$[rsp+16]
	movzx	eax, WORD PTR [rax+2]
	cmp	eax, 3
	jne	SHORT $LN197@ParseLine
$LN199@ParseLine:

; 3453 :     CodeInfo.pinstr->allowed_prefix == AP_REPxx) {
; 3454 :     HandleStringInstructions(&CodeInfo, opndx);

	lea	rdx, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	HandleStringInstructions

; 3455 : #if SVMSUPP /* v2.09, not active because a bit too hackish yet - it "works", though. */
; 3456 :   } else if ( CodeInfo.token >= T_VMRUN && CodeInfo.token <= T_INVLPGA && CodeInfo.pinstr->opclsidx ) {
; 3457 :     /* the size of the first operand is to trigger the address size byte 67h,
; 3458 :      * not the operand size byte 66h!
; 3459 :      */
; 3460 :     CodeInfo.prefix.adrsiz = CodeInfo.prefix.opsiz;
; 3461 :     CodeInfo.prefix.opsiz = 0;
; 3462 :     /* the first op must be EAX/AX or RAX/EAX. The operand class
; 3463 :      * used in the instruction table is OP_A ( which is AL/AX/EAX/RAX ).
; 3464 :      */
; 3465 :     if ( ( CodeInfo.opnd[OPND1].type & ( CodeInfo.Ofssize == USE64 ? OP_R64 | OP_R32 : OP_R32 | OP_R16 ) ) == 0 ) {
; 3466 :       DebugMsg(("ParseLine(%s): opnd1 unexpected type=%X\n", instr, CodeInfo.opnd[OPND1].type ));
; 3467 :       return( EmitErr( INVALID_INSTRUCTION_OPERANDS ) );
; 3468 :     }
; 3469 :     /* the INVLPGA instruction has a fix second operand (=ECX). However, there's no
; 3470 :      * operand class for ECX alone. So it has to be ensured here that the register IS ecx.
; 3471 :      */
; 3472 :     if ( CodeInfo.token == T_INVLPGA )
; 3473 :       if ( ( CodeInfo.rm_byte & BIT_345 ) != ( 1 << 3 ) ) { /* ECX is register 1 */
; 3474 :         DebugMsg(("ParseLine(%s): opnd2 is not ecx\n", instr ));
; 3475 :         return( EmitErr( INVALID_INSTRUCTION_OPERANDS ) );
; 3476 :       }
; 3477 : #endif
; 3478 :   }

	jmp	$LN198@ParseLine
$LN197@ParseLine:

; 3479 :   else {
; 3480 :     if (CurrOpnd > 1) {

	cmp	DWORD PTR CurrOpnd$[rsp], 1
	jbe	$LN200@ParseLine

; 3481 :       /* v1.96: check if a third argument is ok */
; 3482 :       if (CurrOpnd > 2) {

	cmp	DWORD PTR CurrOpnd$[rsp], 2
	jbe	$LN201@ParseLine
$LN35@ParseLine:

; 3483 :         do {
; 3484 :           //if ( CodeInfo.pinstr->opnd_type_3rd != OP3_NONE )
; 3485 :           if ((opnd_clstab[CodeInfo.pinstr->opclsidx].opnd_type_3rd != OP3_NONE) ||

	mov	rax, QWORD PTR CodeInfo$[rsp+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	movzx	eax, BYTE PTR [rcx+rax+8]
	test	eax, eax
	jne	SHORT $LN203@ParseLine
	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	cmp	DWORD PTR opndx$[rsp+rax+60], 4
	jne	SHORT $LN202@ParseLine
$LN203@ParseLine:

; 3486 :             (opndx[CurrOpnd].kind == EXPR_DECORATOR)){
; 3487 :             if (opndx[CurrOpnd].kind == EXPR_DECORATOR)CodeInfo.evex_sae = opndx[CurrOpnd].saeflags;

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	cmp	DWORD PTR opndx$[rsp+rax+60], 4
	jne	SHORT $LN204@ParseLine
	mov	eax, DWORD PTR CurrOpnd$[rsp]
	imul	rax, rax, 104				; 00000068H
	movzx	eax, BYTE PTR opndx$[rsp+rax+70]
	mov	BYTE PTR CodeInfo$[rsp+141], al
$LN204@ParseLine:

; 3488 :             break;

	jmp	$LN34@ParseLine
$LN202@ParseLine:

; 3489 :           }
; 3490 :           CodeInfo.pinstr++;           //work here for {sae}

	mov	rax, QWORD PTR CodeInfo$[rsp+16]
	add	rax, 14
	mov	QWORD PTR CodeInfo$[rsp+16], rax

; 3491 :           if ((CodeInfo.pinstr->first == TRUE)) {

	mov	rax, QWORD PTR CodeInfo$[rsp+16]
	movzx	eax, BYTE PTR [rax+4]
	cmp	eax, 1
	jne	SHORT $LN205@ParseLine

; 3492 :             DebugMsg(("ParseLine(%s): no third operand expected\n", instr));

	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12772
	call	DoDebugMsg
	jmp	SHORT $LN38@ParseLine
$LN36@ParseLine:

; 3493 :             for (; tokenarray[i].token != T_COMMA; i--);

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN38@ParseLine:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN37@ParseLine
	jmp	SHORT $LN36@ParseLine
$LN37@ParseLine:

; 3494 :             return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ParseLine
$LN205@ParseLine:

; 3495 :           }
; 3496 :         } while (1);

	xor	eax, eax
	cmp	eax, 1
	jne	$LN35@ParseLine
$LN34@ParseLine:
$LN201@ParseLine:

; 3497 :       }
; 3498 :       /* v2.06: moved here from process_const() */
; 3499 :       if (CodeInfo.token == T_IMUL) {

	cmp	DWORD PTR CodeInfo$[rsp+24], 621	; 0000026dH
	jne	$LN206@ParseLine

; 3500 :         /* the 2-operand form with an immediate as second op
; 3501 :          * is actually a 3-operand form. That's why the rm byte
; 3502 :          * has to be adjusted. */
; 3503 :         if (CodeInfo.opnd[OPND3].type == OP_NONE && (CodeInfo.opnd[OPND2].type & OP_I)) {

	mov	eax, 24
	imul	rax, rax, 2
	cmp	DWORD PTR CodeInfo$[rsp+rax+32], 0
	jne	SHORT $LN207@ParseLine
	mov	eax, 24
	imul	rax, rax, 1
	mov	eax, DWORD PTR CodeInfo$[rsp+rax+32]
	and	eax, 917504				; 000e0000H
	test	eax, eax
	je	SHORT $LN207@ParseLine

; 3504 : #if AMD64_SUPPORT
; 3505 :           CodeInfo.prefix.rex |= ((CodeInfo.prefix.rex & REX_B) ? REX_R : 0);

	movzx	eax, BYTE PTR CodeInfo$[rsp+8]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN225@ParseLine
	mov	DWORD PTR tv1497[rsp], 4
	jmp	SHORT $LN226@ParseLine
$LN225@ParseLine:
	mov	DWORD PTR tv1497[rsp], 0
$LN226@ParseLine:
	movzx	eax, BYTE PTR CodeInfo$[rsp+8]
	or	eax, DWORD PTR tv1497[rsp]
	mov	BYTE PTR CodeInfo$[rsp+8], al

; 3506 : #endif
; 3507 :           CodeInfo.rm_byte = (CodeInfo.rm_byte & ~BIT_345) | ((CodeInfo.rm_byte & BIT_012) << 3);

	movzx	eax, BYTE PTR CodeInfo$[rsp+104]
	and	eax, -57				; ffffffffffffffc7H
	movzx	ecx, BYTE PTR CodeInfo$[rsp+104]
	and	ecx, 7
	shl	ecx, 3
	or	eax, ecx
	mov	BYTE PTR CodeInfo$[rsp+104], al

; 3508 :         }

	jmp	SHORT $LN208@ParseLine
$LN207@ParseLine:

; 3509 :         else if ((CodeInfo.opnd[OPND3].type != OP_NONE) &&
; 3510 :           (CodeInfo.opnd[OPND2].type & OP_I) &&
; 3511 :           CodeInfo.opnd[OPND2].InsFixup &&

	mov	eax, 24
	imul	rax, rax, 2
	cmp	DWORD PTR CodeInfo$[rsp+rax+32], 0
	je	SHORT $LN209@ParseLine
	mov	eax, 24
	imul	rax, rax, 1
	mov	eax, DWORD PTR CodeInfo$[rsp+rax+32]
	and	eax, 917504				; 000e0000H
	test	eax, eax
	je	SHORT $LN209@ParseLine
	mov	eax, 24
	imul	rax, rax, 1
	cmp	QWORD PTR CodeInfo$[rsp+rax+48], 0
	je	SHORT $LN209@ParseLine
	mov	eax, 24
	imul	rax, rax, 1
	mov	rax, QWORD PTR CodeInfo$[rsp+rax+48]
	mov	rax, QWORD PTR [rax+56]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN209@ParseLine

; 3512 :           CodeInfo.opnd[OPND2].InsFixup->sym->state == SYM_UNDEFINED)
; 3513 :           CodeInfo.opnd[OPND2].type = OP_M;

	mov	eax, 24
	imul	rax, rax, 1
	mov	DWORD PTR CodeInfo$[rsp+rax+32], -1887436800 ; ffffffff8f800000H
$LN209@ParseLine:
$LN208@ParseLine:
$LN206@ParseLine:

; 3514 :       }
; 3515 :       if (check_size(&CodeInfo, opndx) == ERROR) {

	lea	rdx, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	check_size
	cmp	eax, -1
	jne	SHORT $LN210@ParseLine

; 3516 :         DebugMsg(("ParseLine(%s): check_size() failed, exit\n", instr));

	mov	rdx, QWORD PTR instr$[rsp]
	lea	rcx, OFFSET FLAT:$SG12778
	call	DoDebugMsg

; 3517 :         return(ERROR);

	mov	eax, -1
	jmp	$LN1@ParseLine
$LN210@ParseLine:
$LN200@ParseLine:

; 3518 :       }
; 3519 :     }
; 3520 : #if AMD64_SUPPORT
; 3521 :     if (CodeInfo.Ofssize == USE64) {

	movzx	eax, BYTE PTR CodeInfo$[rsp+106]
	cmp	eax, 2
	jne	$LN211@ParseLine

; 3522 : 
; 3523 :       //if ( CodeInfo.x86hi_used && ( CodeInfo.x64lo_used || CodeInfo.prefix.rex & 7 ))
; 3524 :       if (CodeInfo.x86hi_used && CodeInfo.prefix.rex)

	movzx	eax, BYTE PTR CodeInfo$[rsp+142]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN212@ParseLine
	movzx	eax, BYTE PTR CodeInfo$[rsp+8]
	test	eax, eax
	je	SHORT $LN212@ParseLine

; 3525 :         EmitError(INVALID_USAGE_OF_AHBHCHDH);

	mov	ecx, 254				; 000000feH
	call	EmitError
$LN212@ParseLine:

; 3526 : 
; 3527 :       /* for some instructions, the "wide" flag has to be removed selectively.
; 3528 :        * this is to be improved - by a new flag in struct instr_item.
; 3529 :        */
; 3530 :       switch (CodeInfo.token) {

	mov	eax, DWORD PTR CodeInfo$[rsp+24]
	mov	DWORD PTR tv1544[rsp], eax
	cmp	DWORD PTR tv1544[rsp], 606		; 0000025eH
	jg	SHORT $LN227@ParseLine
	cmp	DWORD PTR tv1544[rsp], 606		; 0000025eH
	je	SHORT $LN215@ParseLine
	cmp	DWORD PTR tv1544[rsp], 455		; 000001c7H
	jl	$LN39@ParseLine
	cmp	DWORD PTR tv1544[rsp], 456		; 000001c8H
	jle	SHORT $LN214@ParseLine
	cmp	DWORD PTR tv1544[rsp], 600		; 00000258H
	jle	$LN39@ParseLine
	cmp	DWORD PTR tv1544[rsp], 602		; 0000025aH
	jle	SHORT $LN213@ParseLine
	jmp	$LN39@ParseLine
$LN227@ParseLine:
	cmp	DWORD PTR tv1544[rsp], 1292		; 0000050cH
	jl	SHORT $LN39@ParseLine
	cmp	DWORD PTR tv1544[rsp], 1293		; 0000050dH
	jle	SHORT $LN214@ParseLine
	jmp	SHORT $LN39@ParseLine
$LN213@ParseLine:

; 3531 :       case T_PUSH:
; 3532 :       case T_POP:
; 3533 :         /* v2.06: REX.W prefix is always 0, because size is either 2 or 8 */
; 3534 :         //if ( CodeInfo.opnd_type[OPND1] & OP_R64 )
; 3535 :         CodeInfo.prefix.rex &= 0x7;

	movzx	eax, BYTE PTR CodeInfo$[rsp+8]
	and	eax, 7
	mov	BYTE PTR CodeInfo$[rsp+8], al

; 3536 :         break;

	jmp	SHORT $LN39@ParseLine
$LN214@ParseLine:

; 3537 :       case T_CALL:
; 3538 :       case T_JMP:
; 3539 : #if VMXSUPP /* v2.09: added */
; 3540 :       case T_VMREAD:
; 3541 :       case T_VMWRITE:
; 3542 : #endif
; 3543 :         /* v2.02: previously rex-prefix was cleared entirely,
; 3544 :          * but bits 0-2 are needed to make "call rax" and "call r8"
; 3545 :          * distinguishable!
; 3546 :          */
; 3547 :         //CodeInfo.prefix.rex = 0;
; 3548 :         CodeInfo.prefix.rex &= 0x7;

	movzx	eax, BYTE PTR CodeInfo$[rsp+8]
	and	eax, 7
	mov	BYTE PTR CodeInfo$[rsp+8], al

; 3549 :         break;

	jmp	SHORT $LN39@ParseLine
$LN215@ParseLine:

; 3550 :       case T_MOV:
; 3551 :         /* don't use the Wide bit for moves to/from special regs */
; 3552 :         if (CodeInfo.opnd[OPND1].type & OP_RSPEC || CodeInfo.opnd[OPND2].type & OP_RSPEC)

	mov	eax, 24
	imul	rax, rax, 0
	mov	eax, DWORD PTR CodeInfo$[rsp+rax+32]
	and	eax, 4096				; 00001000H
	test	eax, eax
	jne	SHORT $LN217@ParseLine
	mov	eax, 24
	imul	rax, rax, 1
	mov	eax, DWORD PTR CodeInfo$[rsp+rax+32]
	and	eax, 4096				; 00001000H
	test	eax, eax
	je	SHORT $LN216@ParseLine
$LN217@ParseLine:

; 3553 :           CodeInfo.prefix.rex &= 0x7;

	movzx	eax, BYTE PTR CodeInfo$[rsp+8]
	and	eax, 7
	mov	BYTE PTR CodeInfo$[rsp+8], al
$LN216@ParseLine:
$LN39@ParseLine:
$LN211@ParseLine:
$LN198@ParseLine:

; 3554 :         break;
; 3555 :       }
; 3556 :     }
; 3557 : #endif
; 3558 :   }
; 3559 :   /* now call the code generator */
; 3560 :   temp = codegen( &CodeInfo, oldofs );

	mov	edx, DWORD PTR oldofs$[rsp]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	codegen
	mov	DWORD PTR temp$[rsp], eax

; 3561 :   /* now reset EVEX maskflags for the next line */
; 3562 :   decoflags = 0;

	mov	BYTE PTR decoflags, 0

; 3563 :   broadflags = 0;

	mov	BYTE PTR broadflags, 0

; 3564 :   return( temp );

	mov	eax, DWORD PTR temp$[rsp]
$LN1@ParseLine:

; 3565 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 760				; 000002f8H
	pop	rdi
	pop	rsi
	ret	0
ParseLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
tv66 = 32
sym$ = 64
set_frame2 PROC

; 491  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 492  :     SetFixupFrame( SegOverride ? SegOverride : sym, TRUE );

	cmp	QWORD PTR SegOverride, 0
	je	SHORT $LN3@set_frame2
	mov	rax, QWORD PTR SegOverride
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN4@set_frame2
$LN3@set_frame2:
	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR tv66[rsp], rax
$LN4@set_frame2:
	mov	dl, 1
	mov	rcx, QWORD PTR tv66[rsp]
	call	SetFixupFrame

; 493  : }

	add	rsp, 56					; 00000038H
	ret	0
set_frame2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
tv66 = 32
sym$ = 64
set_frame PROC

; 479  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 480  :     SetFixupFrame( SegOverride ? SegOverride : sym, FALSE );

	cmp	QWORD PTR SegOverride, 0
	je	SHORT $LN3@set_frame
	mov	rax, QWORD PTR SegOverride
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN4@set_frame
$LN3@set_frame:
	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR tv66[rsp], rax
$LN4@set_frame:
	xor	edx, edx
	mov	rcx, QWORD PTR tv66[rsp]
	call	SetFixupFrame

; 481  : }

	add	rsp, 56					; 00000038H
	ret	0
set_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
tv130 = 32
opnd$ = 64
CodeInfo$ = 72
OperandSize PROC

; 290  : {

$LN30:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 291  :     /* v2.0: OP_M8_R8 and OP_M16_R16 have the DFT bit set! */
; 292  :     if( opnd == OP_NONE ) {

	cmp	DWORD PTR opnd$[rsp], 0
	jne	SHORT $LN2@OperandSiz

; 293  :         return( 0 );

	xor	eax, eax
	jmp	$LN1@OperandSiz
	jmp	$LN3@OperandSiz
$LN2@OperandSiz:

; 294  :     } else if( opnd == OP_M ) {

	cmp	DWORD PTR opnd$[rsp], -1887436800	; ffffffff8f800000H
	jne	SHORT $LN4@OperandSiz

; 295  :         return( SizeFromMemtype( CodeInfo->mem_type, CodeInfo->Ofssize, NULL ) );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	xor	r8d, r8d
	mov	edx, eax
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR [rax+28]
	call	SizeFromMemtype
	jmp	$LN1@OperandSiz
	jmp	$LN5@OperandSiz
$LN4@OperandSiz:

; 296  :     } else if( opnd & ( OP_R8 | OP_M08 | OP_I8 ) ) {

	mov	eax, DWORD PTR opnd$[rsp]
	and	eax, 8519681				; 00820001H
	test	eax, eax
	je	SHORT $LN6@OperandSiz

; 297  :         return( 1 );

	mov	eax, 1
	jmp	$LN1@OperandSiz
	jmp	$LN7@OperandSiz
$LN6@OperandSiz:

; 298  :     } else if( opnd & ( OP_R16 | OP_M16 | OP_I16 | OP_SR ) ) {

	mov	eax, DWORD PTR opnd$[rsp]
	and	eax, 17063938				; 01046002H
	test	eax, eax
	je	SHORT $LN8@OperandSiz

; 299  :         return( 2 );

	mov	eax, 2
	jmp	$LN1@OperandSiz
	jmp	$LN9@OperandSiz
$LN8@OperandSiz:

; 300  :     } else if( opnd & ( OP_R32 | OP_M32 | OP_I32 ) ) {

	mov	eax, DWORD PTR opnd$[rsp]
	and	eax, 34078724				; 02080004H
	test	eax, eax
	je	SHORT $LN10@OperandSiz

; 301  :         return( 4 );

	mov	eax, 4
	jmp	$LN1@OperandSiz
	jmp	$LN11@OperandSiz
$LN10@OperandSiz:

; 302  : #if AMD64_SUPPORT
; 303  :     } else if( opnd & ( OP_R64 | OP_M64 | OP_MMX | OP_I64 ) ) {

	mov	eax, DWORD PTR opnd$[rsp]
	and	eax, 68157464				; 04100018H
	test	eax, eax
	je	SHORT $LN12@OperandSiz

; 304  : #else
; 305  :     } else if( opnd & ( OP_M64 | OP_MMX ) ) {
; 306  : #endif
; 307  :         return( 8 );

	mov	eax, 8
	jmp	$LN1@OperandSiz
	jmp	$LN13@OperandSiz
$LN12@OperandSiz:

; 308  : //    } else if( opnd & ( OP_I | OP_I48 ) ) {
; 309  :     } else if( opnd & ( OP_I48 | OP_M48 ) ) {

	mov	eax, DWORD PTR opnd$[rsp]
	and	eax, 1075838976				; 40200000H
	test	eax, eax
	je	SHORT $LN14@OperandSiz

; 310  :         return( 6 );

	mov	eax, 6
	jmp	$LN1@OperandSiz
	jmp	$LN15@OperandSiz
$LN14@OperandSiz:

; 311  :     } else if( opnd & ( OP_STI | OP_M80 ) ) {

	mov	eax, DWORD PTR opnd$[rsp]
	and	eax, -2147385344			; ffffffff80018000H
	test	eax, eax
	je	SHORT $LN16@OperandSiz

; 312  :         return( 10 );

	mov	eax, 10
	jmp	$LN1@OperandSiz
	jmp	$LN17@OperandSiz
$LN16@OperandSiz:

; 313  :     } else if( opnd & ( OP_XMM | OP_M128 ) ) {

	mov	eax, DWORD PTR opnd$[rsp]
	and	eax, 134217760				; 08000020H
	test	eax, eax
	je	SHORT $LN18@OperandSiz

; 314  :         return( 16 );

	mov	eax, 16
	jmp	$LN1@OperandSiz
	jmp	SHORT $LN19@OperandSiz
$LN18@OperandSiz:

; 315  : #if AVXSUPP
; 316  :     }else if (opnd & (OP_K | OP_M64)) {

	mov	eax, DWORD PTR opnd$[rsp]
	and	eax, 67108928				; 04000040H
	test	eax, eax
	je	SHORT $LN20@OperandSiz

; 317  :       return(8);

	mov	eax, 8
	jmp	SHORT $LN1@OperandSiz
	jmp	SHORT $LN21@OperandSiz
$LN20@OperandSiz:

; 318  :     }else if (opnd & (OP_YMM | OP_M256)) {

	mov	eax, DWORD PTR opnd$[rsp]
	and	eax, 268435584				; 10000080H
	test	eax, eax
	je	SHORT $LN22@OperandSiz

; 319  :         return( 32 );

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN1@OperandSiz
	jmp	SHORT $LN23@OperandSiz
$LN22@OperandSiz:

; 320  :     }else if (opnd & (OP_ZMM | OP_M512)) {

	mov	eax, DWORD PTR opnd$[rsp]
	and	eax, 536871168				; 20000100H
	test	eax, eax
	je	SHORT $LN24@OperandSiz

; 321  :       return(64);

	mov	eax, 64					; 00000040H
	jmp	SHORT $LN1@OperandSiz
	jmp	SHORT $LN25@OperandSiz
$LN24@OperandSiz:

; 322  : #endif
; 323  :     } else if( opnd & OP_RSPEC ) {

	mov	eax, DWORD PTR opnd$[rsp]
	and	eax, 4096				; 00001000H
	test	eax, eax
	je	SHORT $LN26@OperandSiz

; 324  : #if AMD64_SUPPORT
; 325  :         return( ( CodeInfo->Ofssize == USE64 ) ? 8 : 4 );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	jne	SHORT $LN28@OperandSiz
	mov	DWORD PTR tv130[rsp], 8
	jmp	SHORT $LN29@OperandSiz
$LN28@OperandSiz:
	mov	DWORD PTR tv130[rsp], 4
$LN29@OperandSiz:
	mov	eax, DWORD PTR tv130[rsp]
	jmp	SHORT $LN1@OperandSiz
$LN26@OperandSiz:
$LN25@OperandSiz:
$LN23@OperandSiz:
$LN21@OperandSiz:
$LN19@OperandSiz:
$LN17@OperandSiz:
$LN15@OperandSiz:
$LN13@OperandSiz:
$LN11@OperandSiz:
$LN9@OperandSiz:
$LN7@OperandSiz:
$LN5@OperandSiz:
$LN3@OperandSiz:

; 326  : #else
; 327  :         return( 4 );
; 328  : #endif
; 329  :     }
; 330  :     DebugMsg1(("OperandSize: unhandled operand type %Xh!!!\n", opnd ));

	mov	edx, DWORD PTR opnd$[rsp]
	lea	rcx, OFFSET FLAT:$SG11576
	call	DoDebugMsg1

; 331  :     return( 0 );

	xor	eax, eax
$LN1@OperandSiz:

; 332  : }

	add	rsp, 56					; 00000038H
	ret	0
OperandSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
sym$ = 48
sym_ext2int PROC

; 153  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 154  :     /* v2.07: GlobalQueue has been removed */
; 155  :     if ( sym->isproc == FALSE && sym->ispublic == FALSE ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+49]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@sym_ext2in
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@sym_ext2in

; 156  :         sym->ispublic = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+48], al

; 157  :         AddPublicData( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	AddPublicData
$LN2@sym_ext2in:

; 158  :     }
; 159  :     sym_remove_table( &SymTables[TAB_EXT], (struct dsym *)sym );

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_remove_table

; 160  :     if ( sym->isproc == FALSE ) /* v2.01: don't clear flags for PROTO */

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+49]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@sym_ext2in

; 161  :         sym->first_size = 0;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+52], 0
$LN3@sym_ext2in:

; 162  :     sym->state = SYM_INTERNAL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+40], 1

; 163  : }

	add	rsp, 40					; 00000028H
	ret	0
sym_ext2int ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
queue$ = 8
item$ = 16
sym_remove_table PROC

; 124  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 125  :     /* unlink the node */
; 126  :     if( item->prev )

	mov	rax, QWORD PTR item$[rsp]
	cmp	QWORD PTR [rax+120], 0
	je	SHORT $LN2@sym_remove

; 127  :         item->prev->next = item->next;

	mov	rax, QWORD PTR item$[rsp]
	mov	rax, QWORD PTR [rax+120]
	mov	rcx, QWORD PTR item$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	mov	QWORD PTR [rax+112], rcx
$LN2@sym_remove:

; 128  :     if( item->next )

	mov	rax, QWORD PTR item$[rsp]
	cmp	QWORD PTR [rax+112], 0
	je	SHORT $LN3@sym_remove

; 129  :         item->next->prev = item->prev;

	mov	rax, QWORD PTR item$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	rcx, QWORD PTR item$[rsp]
	mov	rcx, QWORD PTR [rcx+120]
	mov	QWORD PTR [rax+120], rcx
$LN3@sym_remove:

; 130  : 
; 131  :     //if ( dir->next == NULL )
; 132  :     //    dir->next = dir->prev;
; 133  : 
; 134  :     if ( queue->head == item )

	mov	rax, QWORD PTR queue$[rsp]
	mov	rcx, QWORD PTR item$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN4@sym_remove

; 135  :         queue->head = item->next;

	mov	rax, QWORD PTR queue$[rsp]
	mov	rcx, QWORD PTR item$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	mov	QWORD PTR [rax], rcx
$LN4@sym_remove:

; 136  :     if ( queue->tail == item )

	mov	rax, QWORD PTR queue$[rsp]
	mov	rcx, QWORD PTR item$[rsp]
	cmp	QWORD PTR [rax+8], rcx
	jne	SHORT $LN5@sym_remove

; 137  :         queue->tail = item->prev;

	mov	rax, QWORD PTR queue$[rsp]
	mov	rcx, QWORD PTR item$[rsp]
	mov	rcx, QWORD PTR [rcx+120]
	mov	QWORD PTR [rax+8], rcx
$LN5@sym_remove:

; 138  : 
; 139  :     item->next = NULL;

	mov	rax, QWORD PTR item$[rsp]
	mov	QWORD PTR [rax+112], 0

; 140  :     item->prev = NULL;

	mov	rax, QWORD PTR item$[rsp]
	mov	QWORD PTR [rax+120], 0

; 141  : }

	ret	0
sym_remove_table ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
queue$ = 8
item$ = 16
sym_add_table PROC

; 102  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 103  : #ifdef DEBUG_OUT
; 104  :     if ( queue == &SymTables[TAB_UNDEF] )

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR queue$[rsp], rax
	jne	SHORT $LN2@sym_add_ta

; 105  :         item->sym.fwdref = TRUE;

	mov	rax, QWORD PTR item$[rsp]
	movzx	eax, BYTE PTR [rax+49]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR item$[rsp]
	mov	BYTE PTR [rcx+49], al
$LN2@sym_add_ta:

; 106  : #endif
; 107  :     if( queue->head == NULL ) {

	mov	rax, QWORD PTR queue$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN3@sym_add_ta

; 108  :         queue->head = queue->tail = item;

	mov	rax, QWORD PTR queue$[rsp]
	mov	rcx, QWORD PTR item$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR queue$[rsp]
	mov	rcx, QWORD PTR item$[rsp]
	mov	QWORD PTR [rax], rcx

; 109  :         item->next = item->prev = NULL;

	mov	rax, QWORD PTR item$[rsp]
	mov	QWORD PTR [rax+120], 0
	mov	rax, QWORD PTR item$[rsp]
	mov	QWORD PTR [rax+112], 0

; 110  :     } else {

	jmp	SHORT $LN4@sym_add_ta
$LN3@sym_add_ta:

; 111  :         item->prev = queue->tail;

	mov	rax, QWORD PTR item$[rsp]
	mov	rcx, QWORD PTR queue$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+120], rcx

; 112  :         queue->tail->next = item;

	mov	rax, QWORD PTR queue$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR item$[rsp]
	mov	QWORD PTR [rax+112], rcx

; 113  :         queue->tail = item;

	mov	rax, QWORD PTR queue$[rsp]
	mov	rcx, QWORD PTR item$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 114  :         item->next = NULL;

	mov	rax, QWORD PTR item$[rsp]
	mov	QWORD PTR [rax+112], 0
$LN4@sym_add_ta:

; 115  :     }
; 116  : }

	ret	0
sym_add_table ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
i$ = 8
tokenarray$ = 16
plang$ = 24
GetLangType PROC

; 167  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 168  :     if( tokenarray[*i].token == T_RES_ID ) {

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 7
	jne	SHORT $LN2@GetLangTyp

; 169  : #if 1 /* v2.03: simplified */
; 170  :         if ( tokenarray[(*i)].tokval >= T_C &&

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 264		; 00000108H
	jb	SHORT $LN3@GetLangTyp
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 271		; 0000010fH
	ja	SHORT $LN3@GetLangTyp

; 171  :             tokenarray[(*i)].tokval <= T_VECTORCALL ) { /* 2.15 implemented the VECTORCALL */
; 172  :             *plang = tokenarray[(*i)].bytval;

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1]
	mov	rcx, QWORD PTR plang$[rsp]
	mov	DWORD PTR [rcx], eax

; 173  :             (*i)++;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax

; 174  :             return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@GetLangTyp
$LN3@GetLangTyp:
$LN2@GetLangTyp:

; 175  :         }
; 176  : #else
; 177  :         switch( tokenarray[(*i)].tokval ) {
; 178  :         case T_C:        *plang = LANG_C;          break;
; 179  :         case T_SYSCALL:  *plang = LANG_SYSCALL;    break;
; 180  :         case T_STDCALL:  *plang = LANG_STDCALL;    break;
; 181  :         case T_PASCAL:   *plang = LANG_PASCAL;     break;
; 182  :         case T_FORTRAN:  *plang = LANG_FORTRAN;    break;
; 183  :         case T_BASIC:    *plang = LANG_BASIC;      break;
; 184  :         case T_FASTCALL: *plang = LANG_FASTCALL;   break;
; 185  :         case T_FASTCALL: *plang = LANG_VECTORCALL; break;
; 186  :         default:
; 187  :             return( ERROR );
; 188  :         }
; 189  :         (*i)++;
; 190  :         return( NOT_ERROR );
; 191  : #endif
; 192  :     }
; 193  :     return( ERROR );

	mov	eax, -1
$LN1@GetLangTyp:

; 194  : }

	ret	0
GetLangType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
flags$ = 0
tv129 = 4
registertoken$ = 32
SizeFromRegister PROC

; 203  : {

$LN15:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 204  :     unsigned flags;
; 205  :     if (((registertoken >= T_YMM0) && (registertoken <= T_YMM7 ))||

	cmp	DWORD PTR registertoken$[rsp], 56	; 00000038H
	jl	SHORT $LN5@SizeFromRe
	cmp	DWORD PTR registertoken$[rsp], 63	; 0000003fH
	jle	SHORT $LN4@SizeFromRe
$LN5@SizeFromRe:
	cmp	DWORD PTR registertoken$[rsp], 156	; 0000009cH
	jl	SHORT $LN2@SizeFromRe
	cmp	DWORD PTR registertoken$[rsp], 179	; 000000b3H
	jg	SHORT $LN2@SizeFromRe
$LN4@SizeFromRe:

; 206  :       ((registertoken >= T_YMM8) && (registertoken <= T_YMM31 )))
; 207  :       flags = GetSflagsSp( registertoken ) & SFR_YMMMASK ;

	movsxd	rax, DWORD PTR registertoken$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax+4]
	and	eax, 63					; 0000003fH
	mov	DWORD PTR flags$[rsp], eax
	jmp	SHORT $LN3@SizeFromRe
$LN2@SizeFromRe:

; 208  :     else if (((registertoken >= T_ZMM0) && (registertoken <= T_ZMM7 ))||

	cmp	DWORD PTR registertoken$[rsp], 64	; 00000040H
	jl	SHORT $LN9@SizeFromRe
	cmp	DWORD PTR registertoken$[rsp], 71	; 00000047H
	jle	SHORT $LN8@SizeFromRe
$LN9@SizeFromRe:
	cmp	DWORD PTR registertoken$[rsp], 180	; 000000b4H
	jl	SHORT $LN6@SizeFromRe
	cmp	DWORD PTR registertoken$[rsp], 203	; 000000cbH
	jg	SHORT $LN6@SizeFromRe
$LN8@SizeFromRe:

; 209  :       ((registertoken >= T_ZMM8) && (registertoken <= T_ZMM31 )))
; 210  :       flags = GetSflagsSp( registertoken ) & SFR_ZMMMASK ;

	movsxd	rax, DWORD PTR registertoken$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax+4]
	and	eax, 127				; 0000007fH
	mov	DWORD PTR flags$[rsp], eax
	jmp	SHORT $LN7@SizeFromRe
$LN6@SizeFromRe:

; 211  :     else
; 212  :       flags = GetSflagsSp( registertoken ) & SFR_SIZMSK;

	movsxd	rax, DWORD PTR registertoken$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax+4]
	and	eax, 31
	mov	DWORD PTR flags$[rsp], eax
$LN7@SizeFromRe:
$LN3@SizeFromRe:

; 213  : 
; 214  :     if ( flags )

	cmp	DWORD PTR flags$[rsp], 0
	je	SHORT $LN10@SizeFromRe

; 215  :         return( flags );

	mov	eax, DWORD PTR flags$[rsp]
	jmp	SHORT $LN1@SizeFromRe
$LN10@SizeFromRe:

; 216  : 
; 217  :     flags = GetValueSp( registertoken );

	movsxd	rax, DWORD PTR registertoken$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR flags$[rsp], eax

; 218  :     if ( flags & OP_SR )

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 24576				; 00006000H
	test	eax, eax
	je	SHORT $LN11@SizeFromRe

; 219  :         return( CurrWordSize );

	movzx	eax, BYTE PTR ModuleInfo+406
	jmp	SHORT $LN1@SizeFromRe
$LN11@SizeFromRe:

; 220  : 
; 221  :     /* CRx, DRx, TRx remaining */
; 222  : #if AMD64_SUPPORT
; 223  :     return( ModuleInfo.Ofssize == USE64 ? 8 : 4 );

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 2
	jne	SHORT $LN13@SizeFromRe
	mov	DWORD PTR tv129[rsp], 8
	jmp	SHORT $LN14@SizeFromRe
$LN13@SizeFromRe:
	mov	DWORD PTR tv129[rsp], 4
$LN14@SizeFromRe:
	mov	eax, DWORD PTR tv129[rsp]
$LN1@SizeFromRe:

; 224  : #else
; 225  :     return( 4 );
; 226  : #endif
; 227  : }

	add	rsp, 24
	ret	0
SizeFromRegister ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
i$ = 0
size$ = 32
ptype$ = 40
MemtypeFromSize PROC

; 274  : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 275  :     int i;
; 276  :     for ( i = T_BYTE; SpecialTable[i].type == RWT_STYPE; i++ ) {

	mov	DWORD PTR i$[rsp], 205			; 000000cdH
	jmp	SHORT $LN4@MemtypeFro
$LN2@MemtypeFro:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@MemtypeFro:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+11]
	cmp	eax, 6
	jne	SHORT $LN3@MemtypeFro

; 277  :         if( ( SpecialTable[i].bytval & MT_SPECIAL ) == 0 ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN5@MemtypeFro

; 278  :             /* the size is encoded 0-based in field mem_type */
; 279  :             if( ( ( SpecialTable[i].bytval & MT_SIZE_MASK) + 1 ) == size ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	and	eax, 31
	inc	eax
	cmp	eax, DWORD PTR size$[rsp]
	jne	SHORT $LN6@MemtypeFro

; 280  :                 *ptype = SpecialTable[i].bytval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	rcx, QWORD PTR ptype$[rsp]
	mov	DWORD PTR [rcx], eax

; 281  :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@MemtypeFro
$LN6@MemtypeFro:
$LN5@MemtypeFro:

; 282  :             }
; 283  :         }
; 284  :     }

	jmp	SHORT $LN2@MemtypeFro
$LN3@MemtypeFro:

; 285  :     return( ERROR );

	mov	eax, -1
$LN1@MemtypeFro:

; 286  : }

	add	rsp, 24
	ret	0
MemtypeFromSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
tv70 = 32
tv89 = 36
tv134 = 40
tv140 = 44
tv149 = 48
tv187 = 52
tv190 = 56
tv193 = 60
tv197 = 64
tv204 = 68
tv212 = 72
tv216 = 76
tv220 = 80
tv224 = 84
tv228 = 88
mem_type$ = 112
Ofssize$ = 120
type$ = 128
SizeFromMemtype PROC

; 239  : {

$LN22:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H

; 240  :     if ( ( mem_type & MT_SPECIAL) == 0 )

	mov	eax, DWORD PTR mem_type$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN4@SizeFromMe

; 241  :         return ( (mem_type & MT_SIZE_MASK) + 1 );

	mov	eax, DWORD PTR mem_type$[rsp]
	and	eax, 31
	inc	eax
	jmp	$LN1@SizeFromMe
$LN4@SizeFromMe:

; 242  : 
; 243  :     if ( Ofssize == USE_EMPTY )

	cmp	DWORD PTR Ofssize$[rsp], 254		; 000000feH
	jne	SHORT $LN5@SizeFromMe

; 244  :         Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	DWORD PTR Ofssize$[rsp], eax
$LN5@SizeFromMe:

; 245  : 
; 246  :     switch ( mem_type ) {

	mov	eax, DWORD PTR mem_type$[rsp]
	mov	DWORD PTR tv70[rsp], eax
	cmp	DWORD PTR tv70[rsp], 128		; 00000080H
	je	$LN8@SizeFromMe
	cmp	DWORD PTR tv70[rsp], 129		; 00000081H
	je	SHORT $LN6@SizeFromMe
	cmp	DWORD PTR tv70[rsp], 130		; 00000082H
	je	SHORT $LN7@SizeFromMe
	cmp	DWORD PTR tv70[rsp], 195		; 000000c3H
	je	$LN9@SizeFromMe
	cmp	DWORD PTR tv70[rsp], 196		; 000000c4H
	je	$LN10@SizeFromMe
	jmp	$LN12@SizeFromMe
$LN6@SizeFromMe:

; 247  :     case MT_NEAR:
; 248  :         DebugMsg1(("SizeFromMemtype( MT_NEAR, Ofssize=%u )=%u\n", Ofssize, 2 << Ofssize ));

	mov	eax, DWORD PTR Ofssize$[rsp]
	mov	ecx, 2
	mov	DWORD PTR tv187[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv187[rsp]
	shl	eax, cl
	mov	r8d, eax
	mov	edx, DWORD PTR Ofssize$[rsp]
	lea	rcx, OFFSET FLAT:$SG11523
	call	DoDebugMsg1

; 249  :         return ( 2 << Ofssize );

	mov	eax, DWORD PTR Ofssize$[rsp]
	mov	ecx, 2
	mov	DWORD PTR tv190[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv190[rsp]
	shl	eax, cl
	jmp	$LN1@SizeFromMe
$LN7@SizeFromMe:

; 250  :     case MT_FAR:
; 251  :         DebugMsg1(("SizeFromMemtype( MT_FAR, Ofssize=%u )=%u\n", Ofssize, ( 2 << Ofssize ) + 2 ));

	mov	eax, DWORD PTR Ofssize$[rsp]
	mov	ecx, 2
	mov	DWORD PTR tv193[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv193[rsp]
	shl	eax, cl
	add	eax, 2
	mov	r8d, eax
	mov	edx, DWORD PTR Ofssize$[rsp]
	lea	rcx, OFFSET FLAT:$SG11525
	call	DoDebugMsg1

; 252  :         return ( ( 2 << Ofssize ) + 2 );

	mov	eax, DWORD PTR Ofssize$[rsp]
	mov	ecx, 2
	mov	DWORD PTR tv197[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv197[rsp]
	shl	eax, cl
	add	eax, 2
	jmp	$LN1@SizeFromMe
$LN8@SizeFromMe:

; 253  :     case MT_PROC:
; 254  :         DebugMsg1(("SizeFromMemtype( MT_PROC, Ofssize=%u, type=%s )=%u\n", Ofssize, type->name, ( 2 << Ofssize ) + ( type->isfar ? 2 : 0 ) ));

	mov	rax, QWORD PTR type$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@SizeFromMe
	mov	DWORD PTR tv89[rsp], 2
	jmp	SHORT $LN15@SizeFromMe
$LN14@SizeFromMe:
	mov	DWORD PTR tv89[rsp], 0
$LN15@SizeFromMe:
	mov	eax, DWORD PTR Ofssize$[rsp]
	mov	ecx, 2
	mov	DWORD PTR tv204[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv204[rsp]
	shl	eax, cl
	add	eax, DWORD PTR tv89[rsp]
	mov	r9d, eax
	mov	rax, QWORD PTR type$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR Ofssize$[rsp]
	lea	rcx, OFFSET FLAT:$SG11527
	call	DoDebugMsg1

; 255  :         /* v2.09: use type->isfar setting */
; 256  :         //return( ( 2 << Ofssize ) + ( ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) ? 2 : 0 ) );
; 257  :         return( ( 2 << Ofssize ) + ( type->isfar ? 2 : 0 ) );

	mov	rax, QWORD PTR type$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@SizeFromMe
	mov	DWORD PTR tv134[rsp], 2
	jmp	SHORT $LN17@SizeFromMe
$LN16@SizeFromMe:
	mov	DWORD PTR tv134[rsp], 0
$LN17@SizeFromMe:
	mov	eax, DWORD PTR Ofssize$[rsp]
	mov	ecx, 2
	mov	DWORD PTR tv212[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv212[rsp]
	shl	eax, cl
	add	eax, DWORD PTR tv134[rsp]
	jmp	$LN1@SizeFromMe
$LN9@SizeFromMe:

; 258  :     case MT_PTR:
; 259  :         DebugMsg1(("SizeFromMemtype( MT_PTR, Ofssize=%u )=%u\n", Ofssize, ( 2 << Ofssize ) + ( ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) ) ? 2 : 0 ) ));

	mov	eax, DWORD PTR ModuleInfo+360
	mov	ecx, 1
	mov	DWORD PTR tv216[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv216[rsp]
	shl	eax, cl
	and	eax, 104				; 00000068H
	test	eax, eax
	je	SHORT $LN18@SizeFromMe
	mov	DWORD PTR tv140[rsp], 2
	jmp	SHORT $LN19@SizeFromMe
$LN18@SizeFromMe:
	mov	DWORD PTR tv140[rsp], 0
$LN19@SizeFromMe:
	mov	eax, DWORD PTR Ofssize$[rsp]
	mov	ecx, 2
	mov	DWORD PTR tv220[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv220[rsp]
	shl	eax, cl
	add	eax, DWORD PTR tv140[rsp]
	mov	r8d, eax
	mov	edx, DWORD PTR Ofssize$[rsp]
	lea	rcx, OFFSET FLAT:$SG11529
	call	DoDebugMsg1

; 260  :         return( ( 2 << Ofssize ) + ( ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) ) ? 2 : 0 ) );

	mov	eax, DWORD PTR ModuleInfo+360
	mov	ecx, 1
	mov	DWORD PTR tv224[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv224[rsp]
	shl	eax, cl
	and	eax, 104				; 00000068H
	test	eax, eax
	je	SHORT $LN20@SizeFromMe
	mov	DWORD PTR tv149[rsp], 2
	jmp	SHORT $LN21@SizeFromMe
$LN20@SizeFromMe:
	mov	DWORD PTR tv149[rsp], 0
$LN21@SizeFromMe:
	mov	eax, DWORD PTR Ofssize$[rsp]
	mov	ecx, 2
	mov	DWORD PTR tv228[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv228[rsp]
	shl	eax, cl
	add	eax, DWORD PTR tv149[rsp]
	jmp	SHORT $LN1@SizeFromMe
$LN10@SizeFromMe:

; 261  :     case MT_TYPE:
; 262  :         if ( type )

	cmp	QWORD PTR type$[rsp], 0
	je	SHORT $LN11@SizeFromMe

; 263  :           return( type->total_size );

	mov	rax, QWORD PTR type$[rsp]
	mov	eax, DWORD PTR [rax+64]
	jmp	SHORT $LN1@SizeFromMe
$LN11@SizeFromMe:
$LN12@SizeFromMe:

; 264  :     default:
; 265  :         DebugMsg1(("SizeFromMemtype( memtype=%Xh, Ofssize=%u )=%u\n", mem_type, Ofssize, 0 ));

	xor	r9d, r9d
	mov	r8d, DWORD PTR Ofssize$[rsp]
	mov	edx, DWORD PTR mem_type$[rsp]
	lea	rcx, OFFSET FLAT:$SG11533
	call	DoDebugMsg1

; 266  :         return( 0 );

	xor	eax, eax
$LN1@SizeFromMe:

; 267  :     }
; 268  : }

	add	rsp, 104				; 00000068H
	ret	0
SizeFromMemtype ENDP
_TEXT	ENDS
END
