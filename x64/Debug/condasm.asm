; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	CurrIfState:DWORD
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11278 DB	'if-else', 00H
$SG11025 DB	'BLOCK_ACTIVE', 00H
	ORG $+3
$SG11027 DB	'BLOCK_INACTIVE', 00H
	ORG $+1
$SG11029 DB	'BLOCK_DONE', 00H
	ORG $+5
$SG11039 DB	'condasm_prepare(%s), old status: %s, lvl=%u, falselvl=%u'
	DB	0aH, 00H
	ORG $+6
$SG11053 DB	'condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u'
	DB	0aH, 00H
	ORG $+6
$SG11061 DB	'check_defd(%s): state=%u defined=%u', 0aH, 00H
	ORG $+3
$SG11062 DB	'check_defd(%s): sym=NULL', 0aH, 00H
	ORG $+6
$SG11112 DB	'CondAsmDirective(%s), CurrIfState=%u(%s), lvl=%u, falsel'
	DB	'vl=%u', 0aH, 00H
	ORG $+1
$SG11118 DB	'CondAsmDirective(%s), BLOCK_ACTIVE, lvl=%u, falselvl=%u '
	DB	'[%s]', 0aH, 00H
	ORG $+2
$SG11121 DB	'CondAsmDirective(%s), EvalOperand returned with ERROR', 0aH
	DB	00H
	ORG $+1
$SG11139 DB	'CondAsmDirective(%s), cmp >%s< and >%s<', 0aH, 00H
	ORG $+7
$SG11174 DB	'CondAsmDirective(%s) exit, state=%s, lvl=%u, falselvl=%u'
	DB	0aH, 00H
_DATA	ENDS
PUBLIC	conditional_assembly_prepare
PUBLIC	GetIfNestLevel
PUBLIC	SetIfNestLevel
PUBLIC	CondCheckOpen
PUBLIC	CondInit
PUBLIC	CondAsmDirective
PUBLIC	ErrorDirective
EXTRN	isspace:PROC
EXTRN	memcpy:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	_stricmp:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	SymFind:PROC
EXTRN	GetResWName:PROC
EXTRN	EvalOperand:PROC
EXTRN	LstWriteSrcLine:PROC
EXTRN	TextItemError:PROC
EXTRN	SearchNameInStruct:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	MacroLevel:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	__ImageBase:BYTE
_BSS	SEGMENT
blocknestlevel DD 01H DUP (?)
falseblocknestlevel DD 01H DUP (?)
elseoccured DD	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$conditional_assembly_prepare DD imagerel $LN20
	DD	imagerel $LN20+610
	DD	imagerel $unwind$conditional_assembly_prepare
$pdata$CondCheckOpen DD imagerel $LN4
	DD	imagerel $LN4+35
	DD	imagerel $unwind$CondCheckOpen
$pdata$GetCurrIfStatString DD imagerel GetCurrIfStatString
	DD	imagerel GetCurrIfStatString+57
	DD	imagerel $unwind$GetCurrIfStatString
$pdata$check_defd DD imagerel check_defd
	DD	imagerel check_defd+128
	DD	imagerel $unwind$check_defd
$pdata$check_blank DD imagerel check_blank
	DD	imagerel check_blank+68
	DD	imagerel $unwind$check_blank
$pdata$check_dif DD imagerel check_dif
	DD	imagerel check_dif+121
	DD	imagerel $unwind$check_dif
$pdata$CondAsmDirective DD imagerel $LN105
	DD	imagerel $LN105+3220
	DD	imagerel $unwind$CondAsmDirective
$pdata$GetErrText DD imagerel GetErrText
	DD	imagerel GetErrText+179
	DD	imagerel $unwind$GetErrText
$pdata$ErrorDirective DD imagerel $LN74
	DD	imagerel $LN74+2741
	DD	imagerel $unwind$ErrorDirective
pdata	ENDS
xdata	SEGMENT
$unwind$conditional_assembly_prepare DD 010801H
	DD	0c208H
$unwind$CondCheckOpen DD 010401H
	DD	04204H
$unwind$GetCurrIfStatString DD 010401H
	DD	02204H
$unwind$check_defd DD 010901H
	DD	06209H
$unwind$check_blank DD 010901H
	DD	04209H
$unwind$check_dif DD 011301H
	DD	06213H
$unwind$CondAsmDirective DD 021001H
	DD	0270110H
$unwind$GetErrText DD 010d01H
	DD	0420dH
$unwind$ErrorDirective DD 021001H
	DD	01f0110H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
errmsg$ = 48
j$1 = 52
erridx$ = 56
direct$ = 60
idloc$ = 64
sym$ = 72
tv73 = 80
string1$ = 88
tv430 = 96
size$2 = 100
string2$ = 104
value$3 = 112
opndx$ = 128
i$ = 256
tokenarray$ = 264
ErrorDirective PROC

; 453  : {

$LN74:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 248				; 000000f8H

; 454  :     struct expr opndx;
; 455  :     unsigned direct;
; 456  :     const char *string1;
; 457  :     const char *string2;
; 458  :     int errmsg = EMPTY;

	mov	DWORD PTR errmsg$[rsp], -2

; 459  :     int erridx = 0;

	mov	DWORD PTR erridx$[rsp], 0

; 460  :     struct asym *sym;
; 461  :     int idloc;
; 462  : 
; 463  :     direct = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR direct$[rsp], eax

; 464  : 
; 465  :     i++; /* go past directive */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 466  : 
; 467  :     /* get an expression if necessary */
; 468  :     switch( GetSflagsSp( direct) ) {

	mov	eax, DWORD PTR direct$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax+4]
	mov	DWORD PTR tv73[rsp], eax
	cmp	DWORD PTR tv73[rsp], 1
	je	SHORT $LN12@ErrorDirec
	cmp	DWORD PTR tv73[rsp], 2
	je	$LN49@ErrorDirec
	cmp	DWORD PTR tv73[rsp], 3
	je	$LN40@ErrorDirec
	cmp	DWORD PTR tv73[rsp], 4
	je	$LN24@ErrorDirec
	cmp	DWORD PTR tv73[rsp], 6
	je	$LN66@ErrorDirec
	jmp	$LN68@ErrorDirec
$LN12@ErrorDirec:

; 469  :     case CC_NUMARG: /* .ERR[E|NZ] */
; 470  : 
; 471  :         if (( ERROR == EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) ))

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN13@ErrorDirec

; 472  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@ErrorDirec
$LN13@ErrorDirec:

; 473  :         if ( opndx.kind == EXPR_CONST )

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN14@ErrorDirec

; 474  :             ;

	jmp	SHORT $LN15@ErrorDirec
$LN14@ErrorDirec:

; 475  :         else if ( opndx.kind == EXPR_ADDR && opndx.indirect == FALSE && opndx.sym && opndx.sym->state == SYM_UNDEFINED )

	cmp	DWORD PTR opndx$[rsp+60], 1
	jne	SHORT $LN16@ErrorDirec
	mov	eax, DWORD PTR opndx$[rsp+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN16@ErrorDirec
	cmp	QWORD PTR opndx$[rsp+80], 0
	je	SHORT $LN16@ErrorDirec
	mov	rax, QWORD PTR opndx$[rsp+80]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN16@ErrorDirec

; 476  :             ;//opndx.value += opndx.sym->offset;

	jmp	SHORT $LN17@ErrorDirec
$LN16@ErrorDirec:

; 477  :         else {
; 478  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN1@ErrorDirec
$LN17@ErrorDirec:
$LN15@ErrorDirec:

; 479  :         }
; 480  :         if ( tokenarray[i].token == T_COMMA && tokenarray[i+1].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN18@ErrorDirec
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN18@ErrorDirec

; 481  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 482  :             erridx = i++;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR erridx$[rsp], eax
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN18@ErrorDirec:

; 483  :         }
; 484  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN19@ErrorDirec

; 485  :             break;

	jmp	$LN2@ErrorDirec
$LN19@ErrorDirec:

; 486  :         if ( direct == T_DOT_ERRNZ && opndx.value ) {

	cmp	DWORD PTR direct$[rsp], 354		; 00000162H
	jne	SHORT $LN20@ErrorDirec
	cmp	DWORD PTR opndx$[rsp], 0
	je	SHORT $LN20@ErrorDirec

; 487  :             errmsg = FORCED_NOT_ZERO;

	mov	DWORD PTR errmsg$[rsp], 115		; 00000073H
	jmp	SHORT $LN21@ErrorDirec
$LN20@ErrorDirec:

; 488  :         } else if ( direct == T_DOT_ERRE && !opndx.value ) {

	cmp	DWORD PTR direct$[rsp], 353		; 00000161H
	jne	SHORT $LN22@ErrorDirec
	cmp	DWORD PTR opndx$[rsp], 0
	jne	SHORT $LN22@ErrorDirec

; 489  :             errmsg = FORCED_EQUAL;

	mov	DWORD PTR errmsg$[rsp], 116		; 00000074H
$LN22@ErrorDirec:
$LN21@ErrorDirec:

; 490  :         }
; 491  : 
; 492  :         if ( errmsg != EMPTY )

	cmp	DWORD PTR errmsg$[rsp], -2
	je	SHORT $LN23@ErrorDirec

; 493  :             EmitErr( errmsg, opndx.value, GetErrText( erridx, tokenarray ) );

	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR erridx$[rsp]
	call	GetErrText
	mov	r8, rax
	mov	edx, DWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR errmsg$[rsp]
	call	EmitErr
$LN23@ErrorDirec:

; 494  :         break;

	jmp	$LN2@ErrorDirec
$LN24@ErrorDirec:

; 495  :     case CC_SYMARG: /* .ERR[N]DEF */
; 496  :         /* there's a special handling of these directives in ExpandLine()! */
; 497  :         if ( tokenarray[i].token != T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN25@ErrorDirec

; 498  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ErrorDirec
$LN25@ErrorDirec:

; 499  :         }
; 500  :         idloc = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR idloc$[rsp], eax
$LN73@ErrorDirec:
$LN6@ErrorDirec:

; 501  :         /* skip the next param */
; 502  :         do {
; 503  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 504  :         } while ( tokenarray[i].token == T_DOT || tokenarray[i].token == T_ID );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN6@ErrorDirec
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN73@ErrorDirec

; 505  :         if ( tokenarray[i].token == T_COMMA && tokenarray[i+1].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN26@ErrorDirec
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN26@ErrorDirec

; 506  :             /* v2.05: added */
; 507  :             /* v2.08: obsolete, the expansion occurs in the preprocessor.
; 508  :              * See ExpandLine() in expans.c
; 509  :              */
; 510  :             //ExpandLineItems( tokenarray[i].tokpos, i, tokenarray, TRUE, FALSE );
; 511  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 512  :             erridx = i++;  /* Masm seems to accept anything as text */

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR erridx$[rsp], eax
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN26@ErrorDirec:

; 513  :         }
; 514  : 
; 515  :         //if ( tokenarray[i].token != T_FINAL )
; 516  :         //    break;
; 517  : 
; 518  :         /* should run on pass 2 only! */
; 519  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN27@ErrorDirec

; 520  :             break;

	jmp	$LN2@ErrorDirec
$LN27@ErrorDirec:

; 521  : 
; 522  :         /* don't use check_defd()! */
; 523  :         /* v2.07: check for structured variables */
; 524  :         if ( Options.strict_masm_compat == FALSE &&
; 525  :             tokenarray[idloc+1].token == T_DOT &&
; 526  :             ( sym = SymSearch( tokenarray[idloc].string_ptr ) ) &&

	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	jne	$LN28@ErrorDirec
	mov	eax, DWORD PTR idloc$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	jne	$LN28@ErrorDirec
	movsxd	rax, DWORD PTR idloc$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	je	$LN28@ErrorDirec
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 7
	je	SHORT $LN30@ErrorDirec
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	$LN28@ErrorDirec
$LN30@ErrorDirec:

; 527  :             ( ( sym->state == SYM_TYPE ) || sym->type ) ) {
; 528  :             uint_32 value;
; 529  :             int j = idloc;

	mov	eax, DWORD PTR idloc$[rsp]
	mov	DWORD PTR j$1[rsp], eax

; 530  :             int size;
; 531  :             value = 0;

	mov	DWORD PTR value$3[rsp], 0
$LN9@ErrorDirec:

; 532  :             do {
; 533  :                 j += 2;

	mov	eax, DWORD PTR j$1[rsp]
	add	eax, 2
	mov	DWORD PTR j$1[rsp], eax

; 534  :                 /* if it's a structured variable, use its type! */
; 535  :                 if ( sym->state != SYM_TYPE )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 7
	je	SHORT $LN31@ErrorDirec

; 536  :                     sym = sym->type;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym$[rsp], rax
$LN31@ErrorDirec:

; 537  :                 sym = SearchNameInStruct( sym, tokenarray[j].string_ptr, &value, 0 );

	movsxd	rax, DWORD PTR j$1[rsp]
	imul	rax, rax, 32				; 00000020H
	xor	r9d, r9d
	lea	r8, QWORD PTR value$3[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	rcx, QWORD PTR sym$[rsp]
	call	SearchNameInStruct
	mov	QWORD PTR sym$[rsp], rax

; 538  :             } while ( sym && tokenarray[j+1].token == T_DOT );

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN32@ErrorDirec
	mov	eax, DWORD PTR j$1[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN9@ErrorDirec
$LN32@ErrorDirec:

; 539  :             if ( tokenarray[j].token == T_ID )

	movsxd	rax, DWORD PTR j$1[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN33@ErrorDirec

; 540  :                 j++;

	mov	eax, DWORD PTR j$1[rsp]
	inc	eax
	mov	DWORD PTR j$1[rsp], eax
	jmp	SHORT $LN34@ErrorDirec
$LN33@ErrorDirec:

; 541  :             else if ( tokenarray[j].token != T_FINAL && tokenarray[j].token != T_COMMA ) {

	movsxd	rax, DWORD PTR j$1[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN35@ErrorDirec
	movsxd	rax, DWORD PTR j$1[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN35@ErrorDirec

; 542  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[j].string_ptr ) );

	movsxd	rax, DWORD PTR j$1[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ErrorDirec
$LN35@ErrorDirec:
$LN34@ErrorDirec:

; 543  :             }
; 544  :             size = tokenarray[j].tokpos - tokenarray[idloc].tokpos;

	movsxd	rax, DWORD PTR j$1[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR idloc$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR size$2[rsp], eax

; 545  :             memcpy( StringBufferEnd, tokenarray[idloc].tokpos, size );

	movsxd	rax, DWORD PTR size$2[rsp]
	movsxd	rcx, DWORD PTR idloc$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+24]
	mov	rcx, QWORD PTR ModuleInfo+488
	call	memcpy

; 546  :             *(StringBufferEnd+size) = NULLC;

	movsxd	rax, DWORD PTR size$2[rsp]
	mov	rcx, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rcx+rax], 0

; 547  :         } else {

	jmp	SHORT $LN29@ErrorDirec
$LN28@ErrorDirec:

; 548  :             sym = SymSearch( tokenarray[idloc].string_ptr );

	movsxd	rax, DWORD PTR idloc$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 549  :             strcpy( StringBufferEnd, tokenarray[idloc].string_ptr );

	movsxd	rax, DWORD PTR idloc$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	rcx, QWORD PTR ModuleInfo+488
	call	strcpy
$LN29@ErrorDirec:

; 550  :         }
; 551  :         if ( sym && sym->state == SYM_UNDEFINED )

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN36@ErrorDirec
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN36@ErrorDirec

; 552  :             sym = NULL;

	mov	QWORD PTR sym$[rsp], 0
$LN36@ErrorDirec:

; 553  : 
; 554  :         /* Masm "usually" ignores the optional errtxt! */
; 555  :         if( direct == T_DOT_ERRDEF && sym != NULL )

	cmp	DWORD PTR direct$[rsp], 361		; 00000169H
	jne	SHORT $LN37@ErrorDirec
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN37@ErrorDirec

; 556  :             EmitErr( FORCED_DEF, StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	ecx, 117				; 00000075H
	call	EmitErr
	jmp	SHORT $LN38@ErrorDirec
$LN37@ErrorDirec:

; 557  :         else if( direct == T_DOT_ERRNDEF && sym == NULL )

	cmp	DWORD PTR direct$[rsp], 362		; 0000016aH
	jne	SHORT $LN39@ErrorDirec
	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN39@ErrorDirec

; 558  :             EmitErr( FORCED_NOT_DEF, StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	ecx, 118				; 00000076H
	call	EmitErr
$LN39@ErrorDirec:
$LN38@ErrorDirec:

; 559  :         break;

	jmp	$LN2@ErrorDirec
$LN40@ErrorDirec:

; 560  :     case CC_BLKARG: /* .ERR[N]B */
; 561  :         string1 = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR string1$[rsp], rax

; 562  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN42@ErrorDirec
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN41@ErrorDirec
$LN42@ErrorDirec:

; 563  :             return( TextItemError( &tokenarray[i] ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	TextItemError
	jmp	$LN1@ErrorDirec
$LN41@ErrorDirec:

; 564  :         }
; 565  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 566  :         if ( tokenarray[i].token == T_COMMA && tokenarray[i+1].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN43@ErrorDirec
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN43@ErrorDirec

; 567  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 568  :             erridx = i++;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR erridx$[rsp], eax
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN43@ErrorDirec:

; 569  :         }
; 570  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN44@ErrorDirec

; 571  :             break;

	jmp	$LN2@ErrorDirec
$LN44@ErrorDirec:

; 572  :         if ( direct == T_DOT_ERRB && check_blank( string1 ) )

	cmp	DWORD PTR direct$[rsp], 359		; 00000167H
	jne	SHORT $LN45@ErrorDirec
	mov	rcx, QWORD PTR string1$[rsp]
	call	check_blank
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN45@ErrorDirec

; 573  :             errmsg = FORCED_BLANK;

	mov	DWORD PTR errmsg$[rsp], 119		; 00000077H
	jmp	SHORT $LN46@ErrorDirec
$LN45@ErrorDirec:

; 574  :         else if ( direct == T_DOT_ERRNB && !check_blank( string1 ) )

	cmp	DWORD PTR direct$[rsp], 360		; 00000168H
	jne	SHORT $LN47@ErrorDirec
	mov	rcx, QWORD PTR string1$[rsp]
	call	check_blank
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN47@ErrorDirec

; 575  :             errmsg = FORCED_NOT_BLANK;

	mov	DWORD PTR errmsg$[rsp], 120		; 00000078H
$LN47@ErrorDirec:
$LN46@ErrorDirec:

; 576  :         if ( errmsg != EMPTY )

	cmp	DWORD PTR errmsg$[rsp], -2
	je	SHORT $LN48@ErrorDirec

; 577  :             EmitErr( errmsg, string1, GetErrText( erridx, tokenarray ) );

	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR erridx$[rsp]
	call	GetErrText
	mov	r8, rax
	mov	rdx, QWORD PTR string1$[rsp]
	mov	ecx, DWORD PTR errmsg$[rsp]
	call	EmitErr
$LN48@ErrorDirec:

; 578  :         break;

	jmp	$LN2@ErrorDirec
$LN49@ErrorDirec:

; 579  :     case CC_LITARG: /* .ERRDIF[I], .ERRIDN[I] */
; 580  :         string1 = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR string1$[rsp], rax

; 581  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN51@ErrorDirec
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN50@ErrorDirec
$LN51@ErrorDirec:

; 582  :             return( TextItemError( &tokenarray[i] ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	TextItemError
	jmp	$LN1@ErrorDirec
$LN50@ErrorDirec:

; 583  :         }
; 584  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 585  :         if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN52@ErrorDirec

; 586  :             return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	$LN1@ErrorDirec
$LN52@ErrorDirec:

; 587  :         }
; 588  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 589  :         string2 = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR string2$[rsp], rax

; 590  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN54@ErrorDirec
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN53@ErrorDirec
$LN54@ErrorDirec:

; 591  :             return( TextItemError( &tokenarray[i] ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	TextItemError
	jmp	$LN1@ErrorDirec
$LN53@ErrorDirec:

; 592  :         }
; 593  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 594  :         if ( tokenarray[i].token == T_COMMA && tokenarray[i+1].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN55@ErrorDirec
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN55@ErrorDirec

; 595  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 596  :             erridx = i++;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR erridx$[rsp], eax
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN55@ErrorDirec:

; 597  :         }
; 598  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN56@ErrorDirec

; 599  :             break;

	jmp	$LN2@ErrorDirec
$LN56@ErrorDirec:

; 600  : 
; 601  :         switch ( direct ) {

	mov	eax, DWORD PTR direct$[rsp]
	mov	DWORD PTR tv430[rsp], eax
	cmp	DWORD PTR tv430[rsp], 355		; 00000163H
	je	SHORT $LN57@ErrorDirec
	cmp	DWORD PTR tv430[rsp], 356		; 00000164H
	je	SHORT $LN59@ErrorDirec
	cmp	DWORD PTR tv430[rsp], 357		; 00000165H
	je	SHORT $LN61@ErrorDirec
	jmp	SHORT $LN63@ErrorDirec
$LN57@ErrorDirec:

; 602  :         case T_DOT_ERRDIF:
; 603  :             if ( check_dif( string1, string2, TRUE ) )

	mov	r8b, 1
	mov	rdx, QWORD PTR string2$[rsp]
	mov	rcx, QWORD PTR string1$[rsp]
	call	check_dif
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN58@ErrorDirec

; 604  :                 errmsg = FORCED_DIF;

	mov	DWORD PTR errmsg$[rsp], 121		; 00000079H
$LN58@ErrorDirec:

; 605  :             break;

	jmp	SHORT $LN10@ErrorDirec
$LN59@ErrorDirec:

; 606  :         case T_DOT_ERRDIFI:
; 607  :             if ( check_dif( string1, string2, FALSE ) )

	xor	r8d, r8d
	mov	rdx, QWORD PTR string2$[rsp]
	mov	rcx, QWORD PTR string1$[rsp]
	call	check_dif
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN60@ErrorDirec

; 608  :                 errmsg = FORCED_DIF;

	mov	DWORD PTR errmsg$[rsp], 121		; 00000079H
$LN60@ErrorDirec:

; 609  :             break;

	jmp	SHORT $LN10@ErrorDirec
$LN61@ErrorDirec:

; 610  :         case T_DOT_ERRIDN:
; 611  :             if ( !check_dif( string1, string2, TRUE ) )

	mov	r8b, 1
	mov	rdx, QWORD PTR string2$[rsp]
	mov	rcx, QWORD PTR string1$[rsp]
	call	check_dif
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN62@ErrorDirec

; 612  :                 errmsg = FORCED_IDN;

	mov	DWORD PTR errmsg$[rsp], 122		; 0000007aH
$LN62@ErrorDirec:

; 613  :             break;

	jmp	SHORT $LN10@ErrorDirec
$LN63@ErrorDirec:

; 614  :         default:
; 615  :             if ( !check_dif( string1, string2, FALSE ) )

	xor	r8d, r8d
	mov	rdx, QWORD PTR string2$[rsp]
	mov	rcx, QWORD PTR string1$[rsp]
	call	check_dif
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN64@ErrorDirec

; 616  :                 errmsg = FORCED_IDN;

	mov	DWORD PTR errmsg$[rsp], 122		; 0000007aH
$LN64@ErrorDirec:
$LN10@ErrorDirec:

; 617  :         }
; 618  :         if ( errmsg != EMPTY )

	cmp	DWORD PTR errmsg$[rsp], -2
	je	SHORT $LN65@ErrorDirec

; 619  :             EmitErr( errmsg, string1, string2, GetErrText( erridx, tokenarray ) );

	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR erridx$[rsp]
	call	GetErrText
	mov	r9, rax
	mov	r8, QWORD PTR string2$[rsp]
	mov	rdx, QWORD PTR string1$[rsp]
	mov	ecx, DWORD PTR errmsg$[rsp]
	call	EmitErr
$LN65@ErrorDirec:

; 620  :         break;

	jmp	SHORT $LN2@ErrorDirec
$LN66@ErrorDirec:

; 621  :     case CC_PASS2: /* .ERR2 */
; 622  :         if ( ModuleInfo.setif2 == FALSE ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 10
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN67@ErrorDirec

; 623  :             return( EmitError( IF2_NOT_ALLOWED ) );

	mov	ecx, 190				; 000000beH
	call	EmitError
	jmp	$LN1@ErrorDirec
$LN67@ErrorDirec:
$LN68@ErrorDirec:

; 624  :         }
; 625  :     case CC_PASS1: /* .ERR1 */
; 626  :     default: /* .ERR */
; 627  :         if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN69@ErrorDirec

; 628  :             erridx = i++;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR erridx$[rsp], eax
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN69@ErrorDirec:

; 629  :         }
; 630  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN70@ErrorDirec

; 631  :             break;

	jmp	SHORT $LN2@ErrorDirec
$LN70@ErrorDirec:

; 632  :         EmitErr( FORCED_ERR, GetErrText( erridx, tokenarray ) );

	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR erridx$[rsp]
	call	GetErrText
	mov	rdx, rax
	mov	ecx, 114				; 00000072H
	call	EmitErr
$LN2@ErrorDirec:

; 633  :         break;
; 634  :     }
; 635  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN71@ErrorDirec

; 636  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@ErrorDirec
$LN71@ErrorDirec:

; 637  :     }
; 638  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@ErrorDirec:

; 639  : }

	add	rsp, 248				; 000000f8H
	ret	0
ErrorDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
GetErrText PROC

; 425  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 426  :     *StringBufferEnd = NULLC;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rax], 0

; 427  :     if ( i ) {

	cmp	DWORD PTR i$[rsp], 0
	je	$LN2@GetErrText

; 428  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN5@GetErrText
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN3@GetErrText
$LN5@GetErrText:

; 429  :             TextItemError( &tokenarray[i] );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	TextItemError

; 430  :         } else {

	jmp	SHORT $LN4@GetErrText
$LN3@GetErrText:

; 431  :             *(StringBufferEnd+0) = ':';

	mov	rax, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rax], 58			; 0000003aH

; 432  :             *(StringBufferEnd+1) = ' ';

	mov	rax, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rax+1], 32			; 00000020H

; 433  :             //GetLiteralValue( buffer+2, text->string_ptr );
; 434  :             strcpy( StringBufferEnd+2, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR ModuleInfo+488
	add	rcx, 2
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rdx+rax+8]
	call	strcpy
$LN4@GetErrText:
$LN2@GetErrText:

; 435  :         }
; 436  :     }
; 437  :     return( StringBufferEnd );

	mov	rax, QWORD PTR ModuleInfo+488

; 438  : 
; 439  : }

	add	rsp, 40					; 00000028H
	ret	0
GetErrText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
NextIfState$ = 48
directive$ = 52
string1$ = 56
sym$1 = 64
tv141 = 72
tv251 = 76
string2$ = 80
tv167 = 88
tv169 = 92
tv171 = 96
tv258 = 100
tv265 = 104
tv272 = 108
tv274 = 112
tv281 = 116
tv283 = 120
tv321 = 124
tv326 = 128
tv328 = 132
tv387 = 136
tv396 = 140
tv415 = 144
tv481 = 148
value$2 = 152
tv71 = 160
tv93 = 168
tv499 = 176
opndx$ = 192
i$ = 320
tokenarray$ = 328
CondAsmDirective PROC

; 221  : {

$LN105:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 312				; 00000138H

; 222  :     int directive = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR directive$[rsp], eax

; 223  :     const char *string1;
; 224  :     const char *string2;
; 225  :     enum if_state NextIfState;
; 226  :     struct expr opndx;
; 227  : 
; 228  :     if ( CurrIfState != BLOCK_ACTIVE ) {

	cmp	DWORD PTR CurrIfState, 0
	je	SHORT $LN11@CondAsmDir

; 229  :         DebugMsg1(("CondAsmDirective(%s), CurrIfState=%u(%s), lvl=%u, falselvl=%u\n",

	call	GetCurrIfStatString
	mov	QWORD PTR tv71[rsp], rax
	xor	edx, edx
	mov	ecx, DWORD PTR directive$[rsp]
	call	GetResWName
	mov	ecx, DWORD PTR falseblocknestlevel
	mov	DWORD PTR [rsp+40], ecx
	mov	ecx, DWORD PTR blocknestlevel
	mov	DWORD PTR [rsp+32], ecx
	mov	rcx, QWORD PTR tv71[rsp]
	mov	r9, rcx
	mov	r8d, DWORD PTR CurrIfState
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11112
	call	DoDebugMsg1

; 230  :                    GetResWName(directive, NULL), CurrIfState, GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 231  :         if ( i || ModuleInfo.listif ) {

	cmp	DWORD PTR i$[rsp], 0
	jne	SHORT $LN13@CondAsmDir
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 13
	and	eax, 1
	test	eax, eax
	je	SHORT $LN12@CondAsmDir
$LN13@CondAsmDir:

; 232  :             LstWriteSrcLine();

	call	LstWriteSrcLine
$LN12@CondAsmDir:

; 233  :         }
; 234  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@CondAsmDir
$LN11@CondAsmDir:

; 235  :     }
; 236  : 
; 237  :     if ( ModuleInfo.list == TRUE ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN14@CondAsmDir

; 238  :         if ( MacroLevel == 0 ||
; 239  :             ModuleInfo.list_macro == LM_LISTMACROALL ||

	movzx	eax, BYTE PTR MacroLevel
	test	eax, eax
	je	SHORT $LN16@CondAsmDir
	cmp	DWORD PTR ModuleInfo+400, 2
	je	SHORT $LN16@CondAsmDir
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 13
	and	eax, 1
	test	eax, eax
	je	SHORT $LN15@CondAsmDir
$LN16@CondAsmDir:

; 240  :             ModuleInfo.listif )
; 241  :             LstWriteSrcLine();

	call	LstWriteSrcLine
$LN15@CondAsmDir:
$LN14@CondAsmDir:

; 242  :     }
; 243  : 
; 244  :     DebugMsg1(("CondAsmDirective(%s), BLOCK_ACTIVE, lvl=%u, falselvl=%u [%s]\n", GetResWName(directive, NULL), blocknestlevel, falseblocknestlevel, tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	QWORD PTR tv93[rsp], rax
	xor	edx, edx
	mov	ecx, DWORD PTR directive$[rsp]
	call	GetResWName
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR tv93[rsp]
	mov	rcx, QWORD PTR [rcx+rdx+24]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, DWORD PTR falseblocknestlevel
	mov	r8d, DWORD PTR blocknestlevel
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11118
	call	DoDebugMsg1

; 245  : 
; 246  :     i++; /* go past IFx, ELSEx, ENDIF */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 247  : 
; 248  :     /* check params and call appropriate test routine */
; 249  : 
; 250  :     switch( GetSflagsSp(directive) ) {

	movsxd	rax, DWORD PTR directive$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax+4]
	mov	DWORD PTR tv141[rsp], eax
	mov	eax, DWORD PTR tv141[rsp]
	dec	eax
	mov	DWORD PTR tv141[rsp], eax
	cmp	DWORD PTR tv141[rsp], 5
	ja	$LN68@CondAsmDir
	mov	eax, DWORD PTR tv141[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN104@CondAsmDir[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN17@CondAsmDir:

; 251  :     case CC_NUMARG: /* [ELSE]IF[E] */
; 252  :         /* no forward reference allowed, symbol must be defined */
; 253  :         if ( ( ERROR == EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) ) ) {

	mov	BYTE PTR [rsp+32], 2
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN18@CondAsmDir

; 254  :             DebugMsg(("CondAsmDirective(%s), EvalOperand returned with ERROR\n", GetResWName(directive, NULL) ));

	xor	edx, edx
	mov	ecx, DWORD PTR directive$[rsp]
	call	GetResWName
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11121
	call	DoDebugMsg

; 255  :             /* v2.11: don't exit, assume 0 */
; 256  :             //return( ERROR );
; 257  :             opndx.kind = EXPR_CONST;

	mov	DWORD PTR opndx$[rsp+60], 0

; 258  :             opndx.value = 0;

	mov	DWORD PTR opndx$[rsp], 0

; 259  :             i = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rsp], eax
$LN18@CondAsmDir:

; 260  :         }
; 261  : #if 0 /* v2.05: obsolete */
; 262  :         if ( opndx.sym && opndx.sym->state == SYM_UNDEFINED ) {
; 263  :             EmitErr( SYMBOL_NOT_DEFINED, opndx.sym->name );
; 264  :         } else
; 265  : #endif
; 266  :         if ( opndx.kind == EXPR_CONST )

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN19@CondAsmDir

; 267  :             ;

	jmp	SHORT $LN20@CondAsmDir
$LN19@CondAsmDir:

; 268  :         else if ( opndx.kind == EXPR_ADDR && opndx.indirect == FALSE ) {

	cmp	DWORD PTR opndx$[rsp+60], 1
	jne	SHORT $LN21@CondAsmDir
	mov	eax, DWORD PTR opndx$[rsp+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN21@CondAsmDir

; 269  :             opndx.value += opndx.sym->offset;

	mov	rax, QWORD PTR opndx$[rsp+80]
	mov	eax, DWORD PTR [rax+16]
	mov	ecx, DWORD PTR opndx$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opndx$[rsp], eax

; 270  :             /* v2.07: Masm doesn't accept a relocatable item,
; 271  :              * so emit at least a warning!
; 272  :              */
; 273  :             EmitWarn( 2, CONSTANT_EXPECTED );

	mov	edx, 65					; 00000041H
	mov	ecx, 2
	call	EmitWarn

; 274  :         } else {

	jmp	SHORT $LN22@CondAsmDir
$LN21@CondAsmDir:

; 275  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN1@CondAsmDir
$LN22@CondAsmDir:
$LN20@CondAsmDir:

; 276  :         }
; 277  :         if ( directive == T_IF || directive == T_ELSEIF )

	cmp	DWORD PTR directive$[rsp], 364		; 0000016cH
	je	SHORT $LN25@CondAsmDir
	cmp	DWORD PTR directive$[rsp], 377		; 00000179H
	jne	SHORT $LN23@CondAsmDir
$LN25@CondAsmDir:

; 278  :             NextIfState = ( opndx.value ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	cmp	DWORD PTR opndx$[rsp], 0
	je	SHORT $LN71@CondAsmDir
	mov	DWORD PTR tv167[rsp], 0
	jmp	SHORT $LN72@CondAsmDir
$LN71@CondAsmDir:
	mov	DWORD PTR tv167[rsp], 1
$LN72@CondAsmDir:
	mov	eax, DWORD PTR tv167[rsp]
	mov	DWORD PTR NextIfState$[rsp], eax
	jmp	SHORT $LN24@CondAsmDir
$LN23@CondAsmDir:

; 279  :         else
; 280  :             NextIfState = ( !opndx.value ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	cmp	DWORD PTR opndx$[rsp], 0
	jne	SHORT $LN73@CondAsmDir
	mov	DWORD PTR tv169[rsp], 1
	jmp	SHORT $LN74@CondAsmDir
$LN73@CondAsmDir:
	mov	DWORD PTR tv169[rsp], 0
$LN74@CondAsmDir:
	cmp	DWORD PTR tv169[rsp], 0
	je	SHORT $LN75@CondAsmDir
	mov	DWORD PTR tv171[rsp], 0
	jmp	SHORT $LN76@CondAsmDir
$LN75@CondAsmDir:
	mov	DWORD PTR tv171[rsp], 1
$LN76@CondAsmDir:
	mov	eax, DWORD PTR tv171[rsp]
	mov	DWORD PTR NextIfState$[rsp], eax
$LN24@CondAsmDir:

; 281  :         break;

	jmp	$LN2@CondAsmDir
$LN26@CondAsmDir:

; 282  :     case CC_LITARG: /*  [ELSE]IFDIF[I], [ELSE]IFIDN[I] */
; 283  :         string1 = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR string1$[rsp], rax

; 284  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN28@CondAsmDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN27@CondAsmDir
$LN28@CondAsmDir:

; 285  :             if ( tokenarray[i].token == T_ID && SymSearch( string1 ) == NULL )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN29@CondAsmDir
	mov	rcx, QWORD PTR string1$[rsp]
	call	SymFind
	test	rax, rax
	jne	SHORT $LN29@CondAsmDir

; 286  :                 EmitErr( SYMBOL_NOT_DEFINED, string1 );

	mov	rdx, QWORD PTR string1$[rsp]
	mov	ecx, 102				; 00000066H
	call	EmitErr
	jmp	SHORT $LN30@CondAsmDir
$LN29@CondAsmDir:

; 287  :             else
; 288  :                 EmitError( TEXT_ITEM_REQUIRED );

	mov	ecx, 144				; 00000090H
	call	EmitError
$LN30@CondAsmDir:

; 289  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@CondAsmDir
$LN27@CondAsmDir:

; 290  :         }
; 291  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 292  :         if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN31@CondAsmDir

; 293  :             return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	$LN1@CondAsmDir
$LN31@CondAsmDir:

; 294  :         }
; 295  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 296  :         string2 = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR string2$[rsp], rax

; 297  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN33@CondAsmDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN32@CondAsmDir
$LN33@CondAsmDir:

; 298  :             if ( tokenarray[i].token == T_ID && SymSearch( string2 ) == NULL )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN34@CondAsmDir
	mov	rcx, QWORD PTR string2$[rsp]
	call	SymFind
	test	rax, rax
	jne	SHORT $LN34@CondAsmDir

; 299  :                 EmitErr( SYMBOL_NOT_DEFINED, string2 );

	mov	rdx, QWORD PTR string2$[rsp]
	mov	ecx, 102				; 00000066H
	call	EmitErr
	jmp	SHORT $LN35@CondAsmDir
$LN34@CondAsmDir:

; 300  :             else
; 301  :                 EmitError( TEXT_ITEM_REQUIRED );

	mov	ecx, 144				; 00000090H
	call	EmitError
$LN35@CondAsmDir:

; 302  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@CondAsmDir
$LN32@CondAsmDir:

; 303  :         }
; 304  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 305  :         DebugMsg1(("CondAsmDirective(%s), cmp >%s< and >%s<\n", GetResWName(directive, NULL), string1, string2 ));

	xor	edx, edx
	mov	ecx, DWORD PTR directive$[rsp]
	call	GetResWName
	mov	r9, QWORD PTR string2$[rsp]
	mov	r8, QWORD PTR string1$[rsp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11139
	call	DoDebugMsg1

; 306  :         switch ( directive ) {

	mov	eax, DWORD PTR directive$[rsp]
	mov	DWORD PTR tv251[rsp], eax
	mov	eax, DWORD PTR tv251[rsp]
	sub	eax, 368				; 00000170H
	mov	DWORD PTR tv251[rsp], eax
	cmp	DWORD PTR tv251[rsp], 15
	ja	$LN39@CondAsmDir
	movsxd	rax, DWORD PTR tv251[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN103@CondAsmDir[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN36@CondAsmDir:

; 307  :         case T_IFDIF:
; 308  :         case T_ELSEIFDIF:
; 309  :             NextIfState = check_dif( string1, string2, TRUE ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	mov	r8b, 1
	mov	rdx, QWORD PTR string2$[rsp]
	mov	rcx, QWORD PTR string1$[rsp]
	call	check_dif
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN77@CondAsmDir
	mov	DWORD PTR tv258[rsp], 0
	jmp	SHORT $LN78@CondAsmDir
$LN77@CondAsmDir:
	mov	DWORD PTR tv258[rsp], 1
$LN78@CondAsmDir:
	mov	eax, DWORD PTR tv258[rsp]
	mov	DWORD PTR NextIfState$[rsp], eax

; 310  :             break;

	jmp	$LN4@CondAsmDir
$LN37@CondAsmDir:

; 311  :         case T_IFDIFI:
; 312  :         case T_ELSEIFDIFI:
; 313  :             NextIfState = check_dif( string1, string2, FALSE ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	xor	r8d, r8d
	mov	rdx, QWORD PTR string2$[rsp]
	mov	rcx, QWORD PTR string1$[rsp]
	call	check_dif
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN79@CondAsmDir
	mov	DWORD PTR tv265[rsp], 0
	jmp	SHORT $LN80@CondAsmDir
$LN79@CondAsmDir:
	mov	DWORD PTR tv265[rsp], 1
$LN80@CondAsmDir:
	mov	eax, DWORD PTR tv265[rsp]
	mov	DWORD PTR NextIfState$[rsp], eax

; 314  :             break;

	jmp	$LN4@CondAsmDir
$LN38@CondAsmDir:

; 315  :         case T_IFIDN:
; 316  :         case T_ELSEIFIDN:
; 317  :             NextIfState = !check_dif( string1, string2, TRUE ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	mov	r8b, 1
	mov	rdx, QWORD PTR string2$[rsp]
	mov	rcx, QWORD PTR string1$[rsp]
	call	check_dif
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN81@CondAsmDir
	mov	DWORD PTR tv272[rsp], 1
	jmp	SHORT $LN82@CondAsmDir
$LN81@CondAsmDir:
	mov	DWORD PTR tv272[rsp], 0
$LN82@CondAsmDir:
	cmp	DWORD PTR tv272[rsp], 0
	je	SHORT $LN83@CondAsmDir
	mov	DWORD PTR tv274[rsp], 0
	jmp	SHORT $LN84@CondAsmDir
$LN83@CondAsmDir:
	mov	DWORD PTR tv274[rsp], 1
$LN84@CondAsmDir:
	mov	eax, DWORD PTR tv274[rsp]
	mov	DWORD PTR NextIfState$[rsp], eax

; 318  :             break;

	jmp	SHORT $LN4@CondAsmDir
$LN39@CondAsmDir:

; 319  :         default:
; 320  :             NextIfState = !check_dif( string1, string2, FALSE ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	xor	r8d, r8d
	mov	rdx, QWORD PTR string2$[rsp]
	mov	rcx, QWORD PTR string1$[rsp]
	call	check_dif
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN85@CondAsmDir
	mov	DWORD PTR tv281[rsp], 1
	jmp	SHORT $LN86@CondAsmDir
$LN85@CondAsmDir:
	mov	DWORD PTR tv281[rsp], 0
$LN86@CondAsmDir:
	cmp	DWORD PTR tv281[rsp], 0
	je	SHORT $LN87@CondAsmDir
	mov	DWORD PTR tv283[rsp], 0
	jmp	SHORT $LN88@CondAsmDir
$LN87@CondAsmDir:
	mov	DWORD PTR tv283[rsp], 1
$LN88@CondAsmDir:
	mov	eax, DWORD PTR tv283[rsp]
	mov	DWORD PTR NextIfState$[rsp], eax
$LN4@CondAsmDir:

; 321  :         }
; 322  :         break;

	jmp	$LN2@CondAsmDir
$LN40@CondAsmDir:

; 323  :     case CC_BLKARG: /* [ELSE]IF[N]B */
; 324  :         string1 = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR string1$[rsp], rax

; 325  : 
; 326  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN42@CondAsmDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN41@CondAsmDir
$LN42@CondAsmDir:

; 327  :             if ( tokenarray[i].token == T_ID && SymSearch( string1 ) == NULL )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN43@CondAsmDir
	mov	rcx, QWORD PTR string1$[rsp]
	call	SymFind
	test	rax, rax
	jne	SHORT $LN43@CondAsmDir

; 328  :                 EmitErr( SYMBOL_NOT_DEFINED, string1 );

	mov	rdx, QWORD PTR string1$[rsp]
	mov	ecx, 102				; 00000066H
	call	EmitErr
	jmp	SHORT $LN44@CondAsmDir
$LN43@CondAsmDir:

; 329  :             else
; 330  :                 EmitError( TEXT_ITEM_REQUIRED );

	mov	ecx, 144				; 00000090H
	call	EmitError
$LN44@CondAsmDir:

; 331  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@CondAsmDir
$LN41@CondAsmDir:

; 332  :         }
; 333  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 334  :         if ( directive == T_IFB || directive == T_ELSEIFB ) {

	cmp	DWORD PTR directive$[rsp], 372		; 00000174H
	je	SHORT $LN47@CondAsmDir
	cmp	DWORD PTR directive$[rsp], 385		; 00000181H
	jne	SHORT $LN45@CondAsmDir
$LN47@CondAsmDir:

; 335  :             NextIfState = check_blank( string1 ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	mov	rcx, QWORD PTR string1$[rsp]
	call	check_blank
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN89@CondAsmDir
	mov	DWORD PTR tv321[rsp], 0
	jmp	SHORT $LN90@CondAsmDir
$LN89@CondAsmDir:
	mov	DWORD PTR tv321[rsp], 1
$LN90@CondAsmDir:
	mov	eax, DWORD PTR tv321[rsp]
	mov	DWORD PTR NextIfState$[rsp], eax

; 336  :         } else {

	jmp	SHORT $LN46@CondAsmDir
$LN45@CondAsmDir:

; 337  :             NextIfState = !check_blank( string1 ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	mov	rcx, QWORD PTR string1$[rsp]
	call	check_blank
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN91@CondAsmDir
	mov	DWORD PTR tv326[rsp], 1
	jmp	SHORT $LN92@CondAsmDir
$LN91@CondAsmDir:
	mov	DWORD PTR tv326[rsp], 0
$LN92@CondAsmDir:
	cmp	DWORD PTR tv326[rsp], 0
	je	SHORT $LN93@CondAsmDir
	mov	DWORD PTR tv328[rsp], 0
	jmp	SHORT $LN94@CondAsmDir
$LN93@CondAsmDir:
	mov	DWORD PTR tv328[rsp], 1
$LN94@CondAsmDir:
	mov	eax, DWORD PTR tv328[rsp]
	mov	DWORD PTR NextIfState$[rsp], eax
$LN46@CondAsmDir:

; 338  :         }
; 339  :         break;

	jmp	$LN2@CondAsmDir
$LN48@CondAsmDir:

; 340  :     case CC_PASS1: /* [ELSE]IF1 */
; 341  :         /* v2.04: changed */
; 342  :         //NextIfState = ((Parse_Pass == PASS_1) ? BLOCK_ACTIVE : BLOCK_INACTIVE);
; 343  :         NextIfState = BLOCK_ACTIVE;

	mov	DWORD PTR NextIfState$[rsp], 0

; 344  :         break;

	jmp	$LN2@CondAsmDir
$LN49@CondAsmDir:

; 345  :     case CC_PASS2: /* [ELSE]IF2 */
; 346  :         if ( ModuleInfo.setif2 == FALSE ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 10
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN50@CondAsmDir

; 347  :             EmitError( IF2_NOT_ALLOWED );

	mov	ecx, 190				; 000000beH
	call	EmitError

; 348  :             break;

	jmp	$LN2@CondAsmDir
$LN50@CondAsmDir:

; 349  :         }
; 350  :         /* v2.04: changed */
; 351  :         //NextIfState = ((Parse_Pass == PASS_1) ? BLOCK_INACTIVE : BLOCK_ACTIVE);
; 352  :         NextIfState = BLOCK_ACTIVE;

	mov	DWORD PTR NextIfState$[rsp], 0

; 353  :         break;

	jmp	$LN2@CondAsmDir
$LN51@CondAsmDir:

; 354  :     case CC_SYMARG: /* [ELSE]IF[N]DEF */
; 355  :         NextIfState = BLOCK_INACTIVE;

	mov	DWORD PTR NextIfState$[rsp], 1

; 356  :         /* Masm's implementation works with IDs as arguments only. The rest
; 357  :          * will return FALSE. However, it's nice to be able to check whether
; 358  :          * a reserved word is defined or not.
; 359  :          */
; 360  :         /* v2.0: [ELSE]IF[N]DEF is valid *without* an argument! */
; 361  :         //if ( tokenarray[i].token == T_ID && tokenarray[i+1].token == T_FINAL) {
; 362  :         if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN52@CondAsmDir
	jmp	$LN53@CondAsmDir
$LN52@CondAsmDir:

; 363  :         } else if ( tokenarray[i].token == T_ID  ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN54@CondAsmDir

; 364  :             /* v2.07: handle structs + members (if -Zne is NOT set) */
; 365  :             struct asym *sym;
; 366  :             if ( Options.strict_masm_compat == FALSE &&
; 367  :                 tokenarray[i+1].token == T_DOT &&
; 368  :                 ( sym = SymSearch( tokenarray[i].string_ptr ) ) &&

	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	jne	$LN56@CondAsmDir
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	jne	$LN56@CondAsmDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$1[rsp], rax
	cmp	QWORD PTR sym$1[rsp], 0
	je	$LN56@CondAsmDir
	mov	rax, QWORD PTR sym$1[rsp]
	cmp	DWORD PTR [rax+32], 7
	je	SHORT $LN58@CondAsmDir
	mov	rax, QWORD PTR sym$1[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	$LN56@CondAsmDir
$LN58@CondAsmDir:

; 369  :                 ( ( sym->state == SYM_TYPE ) || sym->type ) ) {
; 370  :                 uint_32 value;
; 371  :                 value = 0;

	mov	DWORD PTR value$2[rsp], 0
$LN8@CondAsmDir:

; 372  :                 do {
; 373  :                     i += 2;

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 2
	mov	DWORD PTR i$[rsp], eax

; 374  :                     /* if it's a structured variable, use its type! */
; 375  :                     if ( sym->state != SYM_TYPE )

	mov	rax, QWORD PTR sym$1[rsp]
	cmp	DWORD PTR [rax+32], 7
	je	SHORT $LN59@CondAsmDir

; 376  :                         sym = sym->type;

	mov	rax, QWORD PTR sym$1[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym$1[rsp], rax
$LN59@CondAsmDir:

; 377  :                     sym = SearchNameInStruct( sym, tokenarray[i].string_ptr, &value, 0 );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	xor	r9d, r9d
	lea	r8, QWORD PTR value$2[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	rcx, QWORD PTR sym$1[rsp]
	call	SearchNameInStruct
	mov	QWORD PTR sym$1[rsp], rax

; 378  :                 } while ( sym && tokenarray[i+1].token == T_DOT );

	cmp	QWORD PTR sym$1[rsp], 0
	je	SHORT $LN60@CondAsmDir
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	je	$LN8@CondAsmDir
$LN60@CondAsmDir:

; 379  :                 NextIfState = ( sym ? BLOCK_ACTIVE : BLOCK_INACTIVE );

	cmp	QWORD PTR sym$1[rsp], 0
	je	SHORT $LN95@CondAsmDir
	mov	DWORD PTR tv387[rsp], 0
	jmp	SHORT $LN96@CondAsmDir
$LN95@CondAsmDir:
	mov	DWORD PTR tv387[rsp], 1
$LN96@CondAsmDir:
	mov	eax, DWORD PTR tv387[rsp]
	mov	DWORD PTR NextIfState$[rsp], eax

; 380  :             } else {

	jmp	SHORT $LN57@CondAsmDir
$LN56@CondAsmDir:

; 381  :                 NextIfState = ( check_defd( tokenarray[i].string_ptr )  ? BLOCK_ACTIVE : BLOCK_INACTIVE );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	check_defd
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN97@CondAsmDir
	mov	DWORD PTR tv396[rsp], 0
	jmp	SHORT $LN98@CondAsmDir
$LN97@CondAsmDir:
	mov	DWORD PTR tv396[rsp], 1
$LN98@CondAsmDir:
	mov	eax, DWORD PTR tv396[rsp]
	mov	DWORD PTR NextIfState$[rsp], eax
$LN57@CondAsmDir:

; 382  :             }
; 383  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	$LN55@CondAsmDir
$LN54@CondAsmDir:

; 384  :         } else if ( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_FLAT ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 7
	jne	SHORT $LN61@CondAsmDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 261		; 00000105H
	jne	SHORT $LN61@CondAsmDir

; 385  :             /* v2.09: special treatment of FLAT added */
; 386  :             NextIfState = (( ModuleInfo.flat_grp && ModuleInfo.flat_grp->sym.isdefined ) ? BLOCK_ACTIVE : BLOCK_INACTIVE );

	cmp	QWORD PTR ModuleInfo+440, 0
	je	SHORT $LN99@CondAsmDir
	mov	rax, QWORD PTR ModuleInfo+440
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN99@CondAsmDir
	mov	DWORD PTR tv415[rsp], 0
	jmp	SHORT $LN100@CondAsmDir
$LN99@CondAsmDir:
	mov	DWORD PTR tv415[rsp], 1
$LN100@CondAsmDir:
	mov	eax, DWORD PTR tv415[rsp]
	mov	DWORD PTR NextIfState$[rsp], eax

; 387  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 388  :         } else if ( Options.strict_masm_compat == FALSE && (

	jmp	$LN62@CondAsmDir
$LN61@CondAsmDir:

; 389  :                     tokenarray[i].token == T_RES_ID ||
; 390  :                     tokenarray[i].token == T_STYPE ||
; 391  :                     tokenarray[i].token == T_INSTRUCTION ||
; 392  :                     tokenarray[i].token == T_DIRECTIVE ||
; 393  :                     //tokenarray[i].token == T_UNARY_OP ||
; 394  :                     //tokenarray[i].token == T_BINARY_OP ||
; 395  :                     tokenarray[i].token == T_REG ) &&

	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	jne	$LN63@CondAsmDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 7
	je	SHORT $LN64@CondAsmDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 6
	je	SHORT $LN64@CondAsmDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 1
	je	SHORT $LN64@CondAsmDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	je	SHORT $LN64@CondAsmDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	jne	SHORT $LN63@CondAsmDir
$LN64@CondAsmDir:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN63@CondAsmDir

; 396  :                    tokenarray[i+1].token == T_FINAL ) {
; 397  :             NextIfState = BLOCK_ACTIVE;

	mov	DWORD PTR NextIfState$[rsp], 0

; 398  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN63@CondAsmDir:
$LN62@CondAsmDir:
$LN55@CondAsmDir:
$LN53@CondAsmDir:

; 399  :         }
; 400  :         if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN65@CondAsmDir

; 401  :             EmitWarn( 2, IFDEF_EXPECTS_SYMBOL_ARGUMENT, tokenarray[i-1].tokpos );

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	edx, 248				; 000000f8H
	mov	ecx, 2
	call	EmitWarn
$LN9@CondAsmDir:

; 402  :             while ( tokenarray[i].token != T_FINAL ) i++;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN10@CondAsmDir
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN9@CondAsmDir
$LN10@CondAsmDir:
$LN65@CondAsmDir:

; 403  :         }
; 404  :         if ( directive == T_IFNDEF || directive == T_ELSEIFNDEF )

	cmp	DWORD PTR directive$[rsp], 375		; 00000177H
	je	SHORT $LN67@CondAsmDir
	cmp	DWORD PTR directive$[rsp], 388		; 00000184H
	jne	SHORT $LN66@CondAsmDir
$LN67@CondAsmDir:

; 405  :             NextIfState = ( ( NextIfState == BLOCK_ACTIVE ) ? BLOCK_INACTIVE : BLOCK_ACTIVE );

	cmp	DWORD PTR NextIfState$[rsp], 0
	jne	SHORT $LN101@CondAsmDir
	mov	DWORD PTR tv481[rsp], 1
	jmp	SHORT $LN102@CondAsmDir
$LN101@CondAsmDir:
	mov	DWORD PTR tv481[rsp], 0
$LN102@CondAsmDir:
	mov	eax, DWORD PTR tv481[rsp]
	mov	DWORD PTR NextIfState$[rsp], eax
$LN66@CondAsmDir:

; 406  :         break;

	jmp	SHORT $LN2@CondAsmDir
$LN68@CondAsmDir:

; 407  :     default: /* ELSE and ENDIF */
; 408  :         NextIfState = BLOCK_ACTIVE;

	mov	DWORD PTR NextIfState$[rsp], 0
$LN2@CondAsmDir:

; 409  :         break;
; 410  :     }
; 411  : 
; 412  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN69@CondAsmDir

; 413  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@CondAsmDir
$LN69@CondAsmDir:

; 414  :     }
; 415  : 
; 416  :     CurrIfState = NextIfState;

	mov	eax, DWORD PTR NextIfState$[rsp]
	mov	DWORD PTR CurrIfState, eax

; 417  : 
; 418  :     DebugMsg1(("CondAsmDirective(%s) exit, state=%s, lvl=%u, falselvl=%u\n",

	call	GetCurrIfStatString
	mov	QWORD PTR tv499[rsp], rax
	xor	edx, edx
	mov	ecx, DWORD PTR directive$[rsp]
	call	GetResWName
	mov	ecx, DWORD PTR falseblocknestlevel
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR blocknestlevel
	mov	rcx, QWORD PTR tv499[rsp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11174
	call	DoDebugMsg1

; 419  :                GetResWName(directive, NULL), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 420  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@CondAsmDir:

; 421  : }

	add	rsp, 312				; 00000138H
	ret	0
	npad	1
$LN104@CondAsmDir:
	DD	$LN17@CondAsmDir
	DD	$LN26@CondAsmDir
	DD	$LN40@CondAsmDir
	DD	$LN51@CondAsmDir
	DD	$LN48@CondAsmDir
	DD	$LN49@CondAsmDir
$LN103@CondAsmDir:
	DD	$LN36@CondAsmDir
	DD	$LN37@CondAsmDir
	DD	$LN38@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN36@CondAsmDir
	DD	$LN37@CondAsmDir
	DD	$LN38@CondAsmDir
CondAsmDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
tv70 = 32
tv76 = 36
string1$ = 64
string2$ = 72
sensitive$ = 80
check_dif PROC

; 211  : {

	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 212  :     if( sensitive ) {

	movzx	eax, BYTE PTR sensitive$[rsp]
	test	eax, eax
	je	SHORT $LN2@check_dif

; 213  :         return( strcmp( string1, string2 ) != 0 );

	mov	rdx, QWORD PTR string2$[rsp]
	mov	rcx, QWORD PTR string1$[rsp]
	call	strcmp
	test	eax, eax
	je	SHORT $LN5@check_dif
	mov	DWORD PTR tv70[rsp], 1
	jmp	SHORT $LN6@check_dif
$LN5@check_dif:
	mov	DWORD PTR tv70[rsp], 0
$LN6@check_dif:
	movzx	eax, BYTE PTR tv70[rsp]
	jmp	SHORT $LN1@check_dif

; 214  :     } else {

	jmp	SHORT $LN3@check_dif
$LN2@check_dif:

; 215  :         return( _stricmp( string1, string2 ) != 0 );

	mov	rdx, QWORD PTR string2$[rsp]
	mov	rcx, QWORD PTR string1$[rsp]
	call	_stricmp
	test	eax, eax
	je	SHORT $LN7@check_dif
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN8@check_dif
$LN7@check_dif:
	mov	DWORD PTR tv76[rsp], 0
$LN8@check_dif:
	movzx	eax, BYTE PTR tv76[rsp]
$LN3@check_dif:
$LN1@check_dif:

; 216  :     }
; 217  : }

	add	rsp, 56					; 00000038H
	ret	0
check_dif ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
string$ = 48
check_blank PROC

; 198  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 199  :     for ( ;*string; string++ )

	jmp	SHORT $LN4@check_blan
$LN2@check_blan:
	mov	rax, QWORD PTR string$[rsp]
	inc	rax
	mov	QWORD PTR string$[rsp], rax
$LN4@check_blan:
	mov	rax, QWORD PTR string$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@check_blan

; 200  :         if ( isspace(*string) == FALSE )

	mov	rax, QWORD PTR string$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isspace
	test	eax, eax
	jne	SHORT $LN5@check_blan

; 201  :             return FALSE;

	xor	al, al
	jmp	SHORT $LN1@check_blan
$LN5@check_blan:
	jmp	SHORT $LN2@check_blan
$LN3@check_blan:

; 202  :     return( TRUE );

	mov	al, 1
$LN1@check_blan:

; 203  : }

	add	rsp, 40					; 00000028H
	ret	0
check_blank ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
sym$ = 32
name$ = 64
check_defd PROC

; 179  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 180  :     struct asym      *sym;
; 181  :     if ( *name ) {

	mov	rax, QWORD PTR name$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN2@check_defd

; 182  :         sym = SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 183  :         if( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN3@check_defd

; 184  :             DebugMsg1(("check_defd(%s): state=%u defined=%u\n", name, sym->state, sym->isdefined ));

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	mov	r9d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+32]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11061
	call	DoDebugMsg1

; 185  :             /* v2.04: changed. the "defined" flag is active for ALL symbols */
; 186  :             //if ( sym->state == SYM_INTERNAL || sym->state == SYM_MACRO || sym->state == SYM_TMACRO || sym->state == SYM_UNDEFINED ) {
; 187  :             return( sym->isdefined );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	jmp	SHORT $LN1@check_defd
$LN3@check_defd:

; 188  :         }
; 189  :         DebugMsg1(("check_defd(%s): sym=NULL\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11062
	call	DoDebugMsg1
$LN2@check_defd:

; 190  :     }
; 191  :     return( FALSE );

	xor	al, al
$LN1@check_defd:

; 192  : }

	add	rsp, 56					; 00000038H
	ret	0
check_defd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
tv64 = 0
GetCurrIfStatString PROC

; 75   : {

	sub	rsp, 24

; 76   :     switch ( CurrIfState ) {

	mov	eax, DWORD PTR CurrIfState
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 0
	je	SHORT $LN4@GetCurrIfS
	cmp	DWORD PTR tv64[rsp], 1
	je	SHORT $LN5@GetCurrIfS
	jmp	SHORT $LN6@GetCurrIfS
$LN4@GetCurrIfS:

; 77   :     case BLOCK_ACTIVE:   return( "BLOCK_ACTIVE" );

	lea	rax, OFFSET FLAT:$SG11025
	jmp	SHORT $LN1@GetCurrIfS
$LN5@GetCurrIfS:

; 78   :     case BLOCK_INACTIVE: return( "BLOCK_INACTIVE" );

	lea	rax, OFFSET FLAT:$SG11027
	jmp	SHORT $LN1@GetCurrIfS
$LN6@GetCurrIfS:

; 79   :     default:             return( "BLOCK_DONE" );

	lea	rax, OFFSET FLAT:$SG11029
$LN1@GetCurrIfS:

; 80   :     }
; 81   : }

	add	rsp, 24
	ret	0
GetCurrIfStatString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
CondInit PROC

; 668  :     CurrIfState = BLOCK_ACTIVE;

	mov	DWORD PTR CurrIfState, 0

; 669  :     blocknestlevel = 0;

	mov	DWORD PTR blocknestlevel, 0

; 670  :     falseblocknestlevel = 0;

	mov	DWORD PTR falseblocknestlevel, 0

; 671  : }

	ret	0
CondInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
CondCheckOpen PROC

; 643  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 644  :     if( blocknestlevel > 0 ) {

	cmp	DWORD PTR blocknestlevel, 0
	jle	SHORT $LN2@CondCheckO

; 645  :         EmitErr( BLOCK_NESTING_ERROR, "if-else" );

	lea	rdx, OFFSET FLAT:$SG11278
	mov	ecx, 80					; 00000050H
	call	EmitErr
$LN2@CondCheckO:

; 646  :     }
; 647  :     return;
; 648  : }

	add	rsp, 40					; 00000028H
	ret	0
CondCheckOpen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
newlevel$ = 8
SetIfNestLevel PROC

; 658  : {

	mov	DWORD PTR [rsp+8], ecx

; 659  :     blocknestlevel = newlevel;

	mov	eax, DWORD PTR newlevel$[rsp]
	mov	DWORD PTR blocknestlevel, eax

; 660  :     return;
; 661  : }

	ret	0
SetIfNestLevel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
GetIfNestLevel PROC

; 653  :     return( blocknestlevel );

	mov	eax, DWORD PTR blocknestlevel

; 654  : }

	ret	0
GetIfNestLevel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
_TEXT	SEGMENT
tv73 = 48
tv90 = 52
tv170 = 56
tv177 = 60
tv183 = 64
tv66 = 72
tv148 = 80
directive$ = 112
conditional_assembly_prepare PROC

; 92   : {

$LN20:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H

; 93   :     DebugMsg1(("condasm_prepare(%s), old status: %s, lvl=%u, falselvl=%u\n",

	call	GetCurrIfStatString
	mov	QWORD PTR tv66[rsp], rax
	xor	edx, edx
	mov	ecx, DWORD PTR directive$[rsp]
	call	GetResWName
	mov	ecx, DWORD PTR falseblocknestlevel
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR blocknestlevel
	mov	rcx, QWORD PTR tv66[rsp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11039
	call	DoDebugMsg1

; 94   :                GetResWName( directive, NULL), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 95   :     switch( directive ) {

	mov	eax, DWORD PTR directive$[rsp]
	mov	DWORD PTR tv73[rsp], eax
	cmp	DWORD PTR tv73[rsp], 364		; 0000016cH
	jl	$LN2@conditiona
	cmp	DWORD PTR tv73[rsp], 375		; 00000177H
	jle	SHORT $LN4@conditiona
	cmp	DWORD PTR tv73[rsp], 375		; 00000177H
	jle	$LN2@conditiona
	cmp	DWORD PTR tv73[rsp], 388		; 00000184H
	jle	$LN7@conditiona
	cmp	DWORD PTR tv73[rsp], 389		; 00000185H
	je	$LN13@conditiona
	jmp	$LN2@conditiona
$LN4@conditiona:

; 96   :     case T_IF:
; 97   :     case T_IF1:
; 98   :     case T_IF2:
; 99   :     case T_IFB:
; 100  :     case T_IFDEF:
; 101  :     case T_IFDIF:
; 102  :     case T_IFDIFI:
; 103  :     case T_IFE:
; 104  :     case T_IFIDN:
; 105  :     case T_IFIDNI:
; 106  :     case T_IFNB:
; 107  :     case T_IFNDEF:
; 108  :         if( CurrIfState != BLOCK_ACTIVE ) {

	cmp	DWORD PTR CurrIfState, 0
	je	SHORT $LN5@conditiona

; 109  :             falseblocknestlevel++;

	mov	eax, DWORD PTR falseblocknestlevel
	inc	eax
	mov	DWORD PTR falseblocknestlevel, eax

; 110  :             break;

	jmp	$LN2@conditiona
$LN5@conditiona:

; 111  :         }
; 112  :         if( blocknestlevel == MAX_IF_NESTING ) {

	cmp	DWORD PTR blocknestlevel, 20
	jne	SHORT $LN6@conditiona

; 113  :             EmitError( NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 100				; 00000064H
	call	EmitError

; 114  :             break;

	jmp	$LN2@conditiona
$LN6@conditiona:

; 115  :         }
; 116  :         elseoccured &= ~( 1 << blocknestlevel ); /* v2.06: added */

	mov	eax, DWORD PTR blocknestlevel
	mov	ecx, 1
	mov	DWORD PTR tv170[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv170[rsp]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR elseoccured
	and	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR elseoccured, eax

; 117  :         blocknestlevel++;

	mov	eax, DWORD PTR blocknestlevel
	inc	eax
	mov	DWORD PTR blocknestlevel, eax

; 118  :         break;

	jmp	$LN2@conditiona
$LN7@conditiona:

; 119  :     case T_ELSE:
; 120  :     case T_ELSEIF:
; 121  :     case T_ELSEIF1:
; 122  :     case T_ELSEIF2:
; 123  :     case T_ELSEIFB:
; 124  :     case T_ELSEIFDEF:
; 125  :     case T_ELSEIFDIF:
; 126  :     case T_ELSEIFDIFI:
; 127  :     case T_ELSEIFE:
; 128  :     case T_ELSEIFIDN:
; 129  :     case T_ELSEIFIDNI:
; 130  :     case T_ELSEIFNB:
; 131  :     case T_ELSEIFNDEF:
; 132  :         if ( blocknestlevel ) { /* v2.04: do nothing if there was no IFx */

	cmp	DWORD PTR blocknestlevel, 0
	je	$LN8@conditiona

; 133  :             if ( falseblocknestlevel > 0 ) {

	cmp	DWORD PTR falseblocknestlevel, 0
	jle	SHORT $LN10@conditiona

; 134  :                 break;

	jmp	$LN2@conditiona
$LN10@conditiona:

; 135  :             }
; 136  :             /* v2.06: check added to detect multiple ELSE branches */
; 137  :             if ( elseoccured & ( 1 << ( blocknestlevel - 1 ) ) ) {

	mov	eax, DWORD PTR blocknestlevel
	dec	eax
	mov	ecx, 1
	mov	DWORD PTR tv177[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv177[rsp]
	shl	eax, cl
	mov	ecx, DWORD PTR elseoccured
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	SHORT $LN11@conditiona

; 138  :                 EmitError( ELSE_CLAUSE_ALREADY_OCCURED_IN_THIS_IF_BLOCK );

	mov	ecx, 274				; 00000112H
	call	EmitError

; 139  :                 break;

	jmp	$LN2@conditiona
$LN11@conditiona:

; 140  :             }
; 141  :             /* status may change:
; 142  :              * inactive -> active
; 143  :              * active   -> done
; 144  :              */
; 145  :             CurrIfState = (( CurrIfState == BLOCK_INACTIVE ) ? BLOCK_ACTIVE : BLOCK_DONE );

	cmp	DWORD PTR CurrIfState, 1
	jne	SHORT $LN18@conditiona
	mov	DWORD PTR tv90[rsp], 0
	jmp	SHORT $LN19@conditiona
$LN18@conditiona:
	mov	DWORD PTR tv90[rsp], 2
$LN19@conditiona:
	mov	eax, DWORD PTR tv90[rsp]
	mov	DWORD PTR CurrIfState, eax

; 146  :             /* v2.06: no further ELSEx once ELSE was detected */
; 147  :             if ( directive == T_ELSE )

	cmp	DWORD PTR directive$[rsp], 376		; 00000178H
	jne	SHORT $LN12@conditiona

; 148  :                 elseoccured |= ( 1 << ( blocknestlevel - 1 ) );

	mov	eax, DWORD PTR blocknestlevel
	dec	eax
	mov	ecx, 1
	mov	DWORD PTR tv183[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv183[rsp]
	shl	eax, cl
	mov	ecx, DWORD PTR elseoccured
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR elseoccured, eax
$LN12@conditiona:

; 149  :         } else {

	jmp	SHORT $LN9@conditiona
$LN8@conditiona:

; 150  :             EmitErr( BLOCK_NESTING_ERROR, GetResWName( directive, NULL ) );

	xor	edx, edx
	mov	ecx, DWORD PTR directive$[rsp]
	call	GetResWName
	mov	rdx, rax
	mov	ecx, 80					; 00000050H
	call	EmitErr
$LN9@conditiona:

; 151  :         }
; 152  :         break;

	jmp	SHORT $LN2@conditiona
$LN13@conditiona:

; 153  :     case T_ENDIF:
; 154  :         if ( blocknestlevel ) {

	cmp	DWORD PTR blocknestlevel, 0
	je	SHORT $LN14@conditiona

; 155  :             if ( falseblocknestlevel > 0 ) {

	cmp	DWORD PTR falseblocknestlevel, 0
	jle	SHORT $LN16@conditiona

; 156  :                 falseblocknestlevel--;

	mov	eax, DWORD PTR falseblocknestlevel
	dec	eax
	mov	DWORD PTR falseblocknestlevel, eax

; 157  :                 break;

	jmp	SHORT $LN2@conditiona
$LN16@conditiona:

; 158  :             }
; 159  :             blocknestlevel--;

	mov	eax, DWORD PTR blocknestlevel
	dec	eax
	mov	DWORD PTR blocknestlevel, eax

; 160  :             CurrIfState = BLOCK_ACTIVE; /* v2.04: added */

	mov	DWORD PTR CurrIfState, 0

; 161  :         } else {

	jmp	SHORT $LN15@conditiona
$LN14@conditiona:

; 162  :             EmitErr( BLOCK_NESTING_ERROR, GetResWName( directive, NULL ) );

	xor	edx, edx
	mov	ecx, DWORD PTR directive$[rsp]
	call	GetResWName
	mov	rdx, rax
	mov	ecx, 80					; 00000050H
	call	EmitErr
$LN15@conditiona:
$LN2@conditiona:

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",

	call	GetCurrIfStatString
	mov	QWORD PTR tv148[rsp], rax
	xor	edx, edx
	mov	ecx, DWORD PTR directive$[rsp]
	call	GetResWName
	mov	ecx, DWORD PTR falseblocknestlevel
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR blocknestlevel
	mov	rcx, QWORD PTR tv148[rsp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11053
	call	DoDebugMsg1

; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 104				; 00000068H
	ret	0
conditional_assembly_prepare ENDP
_TEXT	ENDS
END
