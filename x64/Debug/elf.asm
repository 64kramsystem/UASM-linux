; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11311 DB	'.shstrtab', 00H
	ORG $+6
$SG11312 DB	'.symtab', 00H
$SG11313 DB	'.strtab', 00H
$SG11336 DB	'_TEXT', 00H
	ORG $+2
$SG11337 DB	'.text', 00H
	ORG $+2
$SG11338 DB	'_DATA', 00H
	ORG $+2
$SG11339 DB	'.data', 00H
	ORG $+2
$SG11340 DB	'CONST', 00H
	ORG $+2
$SG11341 DB	'.rodata', 00H
$SG11342 DB	'_BSS', 00H
	ORG $+3
$SG11343 DB	'.bss', 00H
	ORG $+3
$SG11406 DB	'set_symtab32, LOCAL: symbol %s, value=%X', 0aH, 00H
	ORG $+6
$SG11410 DB	'set_symtab32, EXTERNAL: symbol %s, info=%X, shndx=%X, va'
	DB	'lue=%X', 0aH, 00H
$SG11417 DB	'set_symtab32, PUBLIC+LOCAL: symbol %s, value=%X', 0aH, 00H
	ORG $+7
$SG11456 DB	'set_symtab64, LOCAL: symbol %s, value=%I64X', 0aH, 00H
	ORG $+3
$SG11521 DB	'set_symtab_values: index after EXTERNALs: %u', 0aH, 00H
	ORG $+2
$SG11525 DB	'set_symtab_values: creating string table, size=%X', 0aH, 00H
	ORG $+5
$SG11460 DB	'set_symtab64, EXTERNAL: symbol %s, info=%X, shndx=%X, va'
	DB	'lue=%I64X', 0aH, 00H
	ORG $+5
$SG11519 DB	'set_symtab_values: index after sections: %u', 0aH, 00H
	ORG $+3
$SG11527 DB	'set_symtab_values: exit, symindex=%u', 0aH, 00H
	ORG $+2
$SG11467 DB	'set_symtab64, PUBLIC+LOCAL: symbol %s, info=%X, shndx=%X'
	DB	', value=%I64X', 0aH, 00H
	ORG $+1
$SG11522 DB	'set_symtab_values: index after PUBLICs: %u', 0aH, 00H
$SG11557 DB	'.rela', 00H
	ORG $+2
$SG11558 DB	'.rel', 00H
	ORG $+3
$SG11559 DB	'elf.c', 00H
	ORG $+6
$SG11560 DB	'set_shstrtab_values: size=%X', 0aH, 00H
	ORG $+2
$SG11607 DB	'elf_write_section_table32( fileofs=%X ): enter', 0aH, 00H
$SG11617 DB	'CONST', 00H
	ORG $+2
$SG11620 DB	'elf_write_section_table32(%s): ofs=%X size=%X numrelocs='
	DB	'%u', 0aH, 00H
	ORG $+4
$SG11624 DB	'elf_write_section_table32(%s): ofs=%X size=%X', 0aH, 00H
	ORG $+1
$SG11627 DB	'elf_write_section_table32(%s): relocs, ofs=%X size=%X', 0aH
	DB	00H
	ORG $+1
$SG11628 DB	'elf_write_section_table32: exit, final fileofs=%X', 0aH, 00H
	ORG $+5
$SG11661 DB	'elf_write_section_table64( fileofs=%X ): enter', 0aH, 00H
$SG11671 DB	'CONST', 00H
	ORG $+2
$SG11674 DB	'elf_write_section_table64(%s): ofs=%I64X size=%I64X numr'
	DB	'elocs=%u', 0aH, 00H
	ORG $+6
$SG11678 DB	'elf_write_section_table64(%s): ofs=%I64X size=%I64X', 0aH
	DB	00H
	ORG $+3
$SG11681 DB	'elf_write_section_table64(%s): relocs, ofs=%I64X size=%I'
	DB	'64X', 0aH, 00H
	ORG $+3
$SG11682 DB	'elf_write_section_table64: exit, final fileofs=%X', 0aH, 00H
	ORG $+5
$SG11698 DB	'write_relocs32: enter', 0aH, 00H
	ORG $+1
$SG11707 DB	'write_relocs32(): unhandled reloc loc=%X type=%u idx=%u '
	DB	'sym=%s', 0aH, 00H
$SG11711 DB	'write_relocs32: exit', 0aH, 00H
	ORG $+2
$SG11726 DB	'write_relocs64: enter', 0aH, 00H
	ORG $+1
$SG11727 DB	'write_relocs64(): reloc loc=%X type=%u idx=%u sym=%s ofs'
	DB	'=%X addbyt=%u', 0aH, 00H
	ORG $+1
$SG11741 DB	'write_relocs64: exit', 0aH, 00H
	ORG $+2
$SG11737 DB	'write_relocs64(): unhandled reloc loc=%X type=%u idx=%u '
	DB	'sym=%s', 0aH, 00H
$SG11762 DB	'elf_write_data: enter', 0aH, 00H
	ORG $+1
$SG11763 DB	'elf_write_data(%s): program data at ofs=%X, size=%X', 0aH
	DB	00H
	ORG $+3
$SG11765 DB	'elf.c', 00H
	ORG $+2
$SG11768 DB	'elf_write_data(%s): internal at ofs=%X, size=%X', 0aH, 00H
	ORG $+7
$SG11771 DB	'elf_write_data(%s): relocs at ofs=%X, size=%X', 0aH, 00H
	ORG $+1
$SG11775 DB	'elf_write_data: exit', 0aH, 00H
	ORG $+2
$SG11789 DB	'elf_write_module: enter', 0aH, 00H
	ORG $+3
$SG11791 DB	07fH, 'ELF', 00H
	ORG $+3
$SG11794 DB	07fH, 'ELF', 00H
	ORG $+7
$SG11796 DB	'elf_write_module: exit', 0aH, 00H
_DATA	ENDS
CONST	SEGMENT
internal_segparms DQ FLAT:$SG11311
	DD	03H
	ORG $+4
	DQ	FLAT:$SG11312
	DD	02H
	ORG $+4
	DQ	FLAT:$SG11313
	DD	03H
	ORG $+4
cst	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11336
	DQ	FLAT:$SG11337
	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11338
	DQ	FLAT:$SG11339
	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG11340
	DQ	FLAT:$SG11341
	DB	04H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG11342
	DQ	FLAT:$SG11343
CONST	ENDS
PUBLIC	elf_init
EXTRN	__imp_fseek:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strcat:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	WriteError:PROC
EXTRN	LclAlloc:PROC
EXTRN	Mangle:PROC
EXTRN	GetSegIdx:PROC
EXTRN	InternalError:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	SymTables:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$elf_init DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$elf_init
$pdata$ElfConvertSectionName DD imagerel ElfConvertSectionName
	DD	imagerel ElfConvertSectionName+370
	DD	imagerel $unwind$ElfConvertSectionName
$pdata$get_num_reloc_sections DD imagerel get_num_reloc_sections
	DD	imagerel get_num_reloc_sections+111
	DD	imagerel $unwind$get_num_reloc_sections
$pdata$set_symtab32 DD imagerel set_symtab32
	DD	imagerel set_symtab32+1462
	DD	imagerel $unwind$set_symtab32
$pdata$set_symtab64 DD imagerel set_symtab64
	DD	imagerel set_symtab64+1502
	DD	imagerel $unwind$set_symtab64
$pdata$set_symtab_values DD imagerel set_symtab_values
	DD	imagerel set_symtab_values+1500
	DD	imagerel $unwind$set_symtab_values
$pdata$set_shstrtab_values DD imagerel set_shstrtab_values
	DD	imagerel set_shstrtab_values+1135
	DD	imagerel $unwind$set_shstrtab_values
$pdata$get_relocation_count DD imagerel get_relocation_count
	DD	imagerel get_relocation_count+98
	DD	imagerel $unwind$get_relocation_count
$pdata$Get_Alignment DD imagerel Get_Alignment
	DD	imagerel Get_Alignment+89
	DD	imagerel $unwind$Get_Alignment
$pdata$elf_write_section_table32 DD imagerel elf_write_section_table32
	DD	imagerel elf_write_section_table32+1752
	DD	imagerel $unwind$elf_write_section_table32
$pdata$elf_write_section_table64 DD imagerel elf_write_section_table64
	DD	imagerel elf_write_section_table64+1844
	DD	imagerel $unwind$elf_write_section_table64
$pdata$write_relocs32 DD imagerel write_relocs32
	DD	imagerel write_relocs32+604
	DD	imagerel $unwind$write_relocs32
$pdata$write_relocs64 DD imagerel write_relocs64
	DD	imagerel write_relocs64+748
	DD	imagerel $unwind$write_relocs64
$pdata$elf_write_data DD imagerel elf_write_data
	DD	imagerel elf_write_data+1005
	DD	imagerel $unwind$elf_write_data
$pdata$elf_write_module DD imagerel elf_write_module
	DD	imagerel elf_write_module+1149
	DD	imagerel $unwind$elf_write_module
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
set_symtab32$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
set_symtab32$rtcVarDesc DD 080H
	DD	0100H
	DQ	FLAT:set_symtab32$rtcName$0
	ORG $+48
set_symtab32$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:set_symtab32$rtcVarDesc
set_symtab64$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
set_symtab64$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:set_symtab64$rtcVarDesc
set_symtab_values$rtcName$0 DB 06cH
	DB	06fH
	DB	063H
	DB	061H
	DB	06cH
	DB	073H
	DB	00H
	ORG $+1
set_symtab64$rtcVarDesc DD 080H
	DD	0100H
	DQ	FLAT:set_symtab64$rtcName$0
	ORG $+48
set_symtab_values$rtcVarDesc DD 048H
	DD	010H
	DQ	FLAT:set_symtab_values$rtcName$0
	ORG $+48
set_symtab_values$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:set_symtab_values$rtcVarDesc
set_shstrtab_values$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
set_shstrtab_values$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:set_shstrtab_values$rtcVarDesc
elf_write_section_table32$rtcName$0 DB 073H
	DB	068H
	DB	064H
	DB	072H
	DB	033H
	DB	032H
	DB	00H
	ORG $+1
set_shstrtab_values$rtcVarDesc DD 050H
	DD	0f8H
	DQ	FLAT:set_shstrtab_values$rtcName$0
	ORG $+48
elf_write_section_table32$rtcVarDesc DD 058H
	DD	028H
	DQ	FLAT:elf_write_section_table32$rtcName$0
	ORG $+48
elf_write_section_table32$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:elf_write_section_table32$rtcVarDesc
elf_write_section_table64$rtcName$0 DB 073H
	DB	068H
	DB	064H
	DB	072H
	DB	036H
	DB	034H
	DB	00H
	ORG $+1
elf_write_section_table64$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:elf_write_section_table64$rtcVarDesc
write_relocs32$rtcName$0 DB 072H
	DB	065H
	DB	06cH
	DB	06fH
	DB	063H
	DB	033H
	DB	032H
	DB	00H
elf_write_section_table64$rtcVarDesc DD 060H
	DD	040H
	DQ	FLAT:elf_write_section_table64$rtcName$0
	ORG $+48
write_relocs32$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:write_relocs32$rtcName$0
	ORG $+48
write_relocs32$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:write_relocs32$rtcVarDesc
write_relocs64$rtcName$0 DB 072H
	DB	065H
	DB	06cH
	DB	06fH
	DB	063H
	DB	036H
	DB	034H
	DB	00H
elf_write_module$rtcName$0 DB 065H
	DB	06dH
	DB	00H
	ORG $+5
write_relocs64$rtcVarDesc DD 058H
	DD	018H
	DQ	FLAT:write_relocs64$rtcName$0
	ORG $+48
write_relocs64$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:write_relocs64$rtcVarDesc
elf_write_module$rtcVarDesc DD 030H
	DD	088H
	DQ	FLAT:elf_write_module$rtcName$0
	ORG $+48
elf_write_module$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:elf_write_module$rtcVarDesc
CONST	ENDS
xdata	SEGMENT
$unwind$elf_init DD 010601H
	DD	07006H
$unwind$ElfConvertSectionName DD 022301H
	DD	0700b520fH
$unwind$get_num_reloc_sections DD 021501H
	DD	070021206H
$unwind$set_symtab32 DD 033f19H
	DD	0340116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0198H
$unwind$set_symtab64 DD 033f19H
	DD	0340116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0198H
$unwind$set_symtab_values DD 022401H
	DD	07006f20dH
$unwind$set_shstrtab_values DD 033619H
	DD	034010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0190H
$unwind$get_relocation_count DD 021e01H
	DD	07006120aH
$unwind$Get_Alignment DD 021e01H
	DD	07006120aH
$unwind$elf_write_section_table32 DD 034019H
	DD	0140117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$elf_write_section_table64 DD 034019H
	DD	0180117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$write_relocs32 DD 022301H
	DD	0700bb20fH
$unwind$write_relocs64 DD 033619H
	DD	012010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$elf_write_data DD 022601H
	DD	0700bd20fH
$unwind$elf_write_module DD 033619H
	DD	01e010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
em$ = 48
tv90 = 208
tv251 = 212
tv249 = 216
__$ArrayPad$ = 224
modinfo$ = 256
elf_write_module PROC

; 1278 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 240				; 000000f0H
	mov	rdi, rsp
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+256]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1279 :     //struct dsym  *dir;
; 1280 :     struct elfmod em;
; 1281 : 
; 1282 :     DebugMsg(("elf_write_module: enter\n"));

	lea	rcx, OFFSET FLAT:$SG11789
	call	DoDebugMsg

; 1283 : 
; 1284 :     memset( &em, 0, sizeof( em ) );

	mov	r8d, 136				; 00000088H
	xor	edx, edx
	lea	rcx, QWORD PTR em$[rsp]
	call	memset

; 1285 :     em.srcname = CurrFName[ASM];

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR em$[rsp+8], rax

; 1286 : #if 1
; 1287 :     /* the path part is stripped. todo: check if this is ok to do */
; 1288 :     em.srcname += strlen( em.srcname );

	mov	rcx, QWORD PTR em$[rsp+8]
	call	strlen
	mov	rcx, QWORD PTR em$[rsp+8]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR em$[rsp+8], rax
$LN2@elf_write_:

; 1289 :     while ( em.srcname > CurrFName[ASM] &&
; 1290 :            *(em.srcname-1) != '/' &&

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rax, QWORD PTR [rcx+rax]
	cmp	QWORD PTR em$[rsp+8], rax
	jbe	SHORT $LN3@elf_write_
	mov	rax, QWORD PTR em$[rsp+8]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN3@elf_write_
	mov	rax, QWORD PTR em$[rsp+8]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN3@elf_write_

; 1291 :            *(em.srcname-1) != '\\') em.srcname--;

	mov	rax, QWORD PTR em$[rsp+8]
	dec	rax
	mov	QWORD PTR em$[rsp+8], rax
	jmp	SHORT $LN2@elf_write_
$LN3@elf_write_:

; 1292 : #endif
; 1293 :     /* position at 0 ( probably unnecessary, since there were no writes yet ) */
; 1294 :     fseek( CurrFile[OBJ], 0, SEEK_SET );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_fseek

; 1295 : 
; 1296 :     switch ( modinfo->defOfssize ) {

	mov	rax, QWORD PTR modinfo$[rsp]
	movzx	eax, BYTE PTR [rax+405]
	mov	BYTE PTR tv90[rsp], al
	cmp	BYTE PTR tv90[rsp], 2
	je	SHORT $LN6@elf_write_
	jmp	$LN8@elf_write_
$LN6@elf_write_:

; 1297 : #if AMD64_SUPPORT
; 1298 :     case USE64:
; 1299 :         memcpy( &em.ehdr64.e_ident, ELF_SIGNATURE, ELF_SIGNATURE_LEN );

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11791
	lea	rcx, QWORD PTR em$[rsp+72]
	call	memcpy

; 1300 :         em.ehdr64.e_ident[EI_CLASS] = ELFCLASS64;

	mov	eax, 1
	imul	rax, rax, 4
	mov	BYTE PTR em$[rsp+rax+72], 2

; 1301 :         em.ehdr64.e_ident[EI_DATA] = ELFDATA2LSB;

	mov	eax, 1
	imul	rax, rax, 5
	mov	BYTE PTR em$[rsp+rax+72], 1

; 1302 :         em.ehdr64.e_ident[EI_VERSION] = EV_CURRENT;

	mov	eax, 1
	imul	rax, rax, 6
	mov	BYTE PTR em$[rsp+rax+72], 1

; 1303 :         em.ehdr64.e_ident[EI_OSABI] = modinfo->elf_osabi;

	mov	eax, 1
	imul	rax, rax, 7
	mov	rcx, QWORD PTR modinfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+412]
	mov	BYTE PTR em$[rsp+rax+72], cl

; 1304 :         /* v2.07: set abiversion to 0 */
; 1305 :         //ehdr64.e_ident[EI_ABIVERSION] = EV_CURRENT;
; 1306 :         em.ehdr64.e_ident[EI_ABIVERSION] = 0;

	mov	eax, 1
	imul	rax, rax, 8
	mov	BYTE PTR em$[rsp+rax+72], 0

; 1307 :         em.ehdr64.e_type = ET_REL; /* file type */

	mov	eax, 1
	mov	WORD PTR em$[rsp+88], ax

; 1308 :         em.ehdr64.e_machine = EM_X86_64;

	mov	eax, 62					; 0000003eH
	mov	WORD PTR em$[rsp+90], ax

; 1309 :         em.ehdr64.e_version = EV_CURRENT;

	mov	DWORD PTR em$[rsp+92], 1

; 1310 :         em.ehdr64.e_entry = 0; /* no entry for relocatable objects */

	mov	QWORD PTR em$[rsp+96], 0

; 1311 :         em.ehdr64.e_phoff = 0; /* no progheaders for relocatable objects */

	mov	QWORD PTR em$[rsp+104], 0

; 1312 :         em.ehdr64.e_shoff = sizeof( em.ehdr64 );

	mov	QWORD PTR em$[rsp+112], 64		; 00000040H

; 1313 :         em.ehdr64.e_flags = 0;

	mov	DWORD PTR em$[rsp+120], 0

; 1314 :         em.ehdr64.e_ehsize = sizeof( em.ehdr64 );

	mov	eax, 64					; 00000040H
	mov	WORD PTR em$[rsp+124], ax

; 1315 :         em.ehdr64.e_phentsize = 0; /* no progheaders for relocatable objects */

	xor	eax, eax
	mov	WORD PTR em$[rsp+126], ax

; 1316 :         em.ehdr64.e_phnum = 0;

	xor	eax, eax
	mov	WORD PTR em$[rsp+128], ax

; 1317 :         em.ehdr64.e_shentsize = sizeof( Elf64_Shdr );

	mov	eax, 64					; 00000040H
	mov	WORD PTR em$[rsp+130], ax

; 1318 :         /* calculate # of sections. Add the following internal sections:
; 1319 :          - 1 NULL entry
; 1320 :          - 1 .shstrtab
; 1321 :          - 1 .symtab
; 1322 :          - 1 .strtab
; 1323 :          - n .rela<xxx> sections
; 1324 :          */
; 1325 :         em.ehdr64.e_shnum = 1 + modinfo->g.num_segs + 3 + get_num_reloc_sections();

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR tv251[rsp], eax
	call	get_num_reloc_sections
	mov	ecx, DWORD PTR tv251[rsp]
	lea	eax, DWORD PTR [rcx+rax+4]
	mov	WORD PTR em$[rsp+132], ax

; 1326 :         em.ehdr64.e_shstrndx = 1 + modinfo->g.num_segs + SHSTRTAB_IDX; /* set index of .shstrtab section */

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	WORD PTR em$[rsp+134], ax

; 1327 :         if ( fwrite( &em.ehdr64, 1, sizeof( em.ehdr64 ), CurrFile[OBJ] ) != sizeof( em.ehdr64 ) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 64					; 00000040H
	mov	edx, 1
	lea	rcx, QWORD PTR em$[rsp+72]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 64					; 00000040H
	je	SHORT $LN7@elf_write_

; 1328 :             WriteError();

	call	WriteError
$LN7@elf_write_:

; 1329 :         elf_write_section_table64( modinfo, &em,

	movzx	eax, WORD PTR em$[rsp+132]
	movzx	ecx, WORD PTR em$[rsp+130]
	imul	eax, ecx
	cdqe
	add	rax, 64					; 00000040H
	mov	r8d, eax
	lea	rdx, QWORD PTR em$[rsp]
	mov	rcx, QWORD PTR modinfo$[rsp]
	call	elf_write_section_table64

; 1330 :                                   sizeof( Elf64_Ehdr ) + em.ehdr64.e_shnum * em.ehdr64.e_shentsize );
; 1331 :         break;

	jmp	$LN4@elf_write_
$LN8@elf_write_:

; 1332 : #endif
; 1333 :     default:
; 1334 :         memcpy( &em.ehdr32.e_ident, ELF_SIGNATURE, ELF_SIGNATURE_LEN );

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11794
	lea	rcx, QWORD PTR em$[rsp+72]
	call	memcpy

; 1335 :         em.ehdr32.e_ident[EI_CLASS] = ELFCLASS32;

	mov	eax, 1
	imul	rax, rax, 4
	mov	BYTE PTR em$[rsp+rax+72], 1

; 1336 :         em.ehdr32.e_ident[EI_DATA] = ELFDATA2LSB;

	mov	eax, 1
	imul	rax, rax, 5
	mov	BYTE PTR em$[rsp+rax+72], 1

; 1337 :         em.ehdr32.e_ident[EI_VERSION] = EV_CURRENT;

	mov	eax, 1
	imul	rax, rax, 6
	mov	BYTE PTR em$[rsp+rax+72], 1

; 1338 :         em.ehdr32.e_ident[EI_OSABI] = modinfo->elf_osabi;

	mov	eax, 1
	imul	rax, rax, 7
	mov	rcx, QWORD PTR modinfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+412]
	mov	BYTE PTR em$[rsp+rax+72], cl

; 1339 :         /* v2.07: set abiversion to 0 */
; 1340 :         //ehdr32.e_ident[EI_ABIVERSION] = EV_CURRENT;
; 1341 :         em.ehdr32.e_ident[EI_ABIVERSION] = 0;

	mov	eax, 1
	imul	rax, rax, 8
	mov	BYTE PTR em$[rsp+rax+72], 0

; 1342 :         em.ehdr32.e_type = ET_REL; /* file type */

	mov	eax, 1
	mov	WORD PTR em$[rsp+88], ax

; 1343 :         em.ehdr32.e_machine = EM_386;

	mov	eax, 3
	mov	WORD PTR em$[rsp+90], ax

; 1344 :         em.ehdr32.e_version = EV_CURRENT;

	mov	DWORD PTR em$[rsp+92], 1

; 1345 :         em.ehdr32.e_entry = 0; /* no entry for relocatable objects */

	mov	DWORD PTR em$[rsp+96], 0

; 1346 :         em.ehdr32.e_phoff = 0; /* no progheaders for relocatable objects */

	mov	DWORD PTR em$[rsp+100], 0

; 1347 :         em.ehdr32.e_shoff = sizeof( em.ehdr32 );

	mov	DWORD PTR em$[rsp+104], 52		; 00000034H

; 1348 :         em.ehdr32.e_flags = 0;

	mov	DWORD PTR em$[rsp+108], 0

; 1349 :         em.ehdr32.e_ehsize = sizeof( em.ehdr32 );

	mov	eax, 52					; 00000034H
	mov	WORD PTR em$[rsp+112], ax

; 1350 :         em.ehdr32.e_phentsize = 0; /* no progheaders for relocatable objects */

	xor	eax, eax
	mov	WORD PTR em$[rsp+114], ax

; 1351 :         em.ehdr32.e_phnum = 0;

	xor	eax, eax
	mov	WORD PTR em$[rsp+116], ax

; 1352 :         em.ehdr32.e_shentsize = sizeof( Elf32_Shdr );

	mov	eax, 40					; 00000028H
	mov	WORD PTR em$[rsp+118], ax

; 1353 :         /* calculate # of sections. Add the following internal sections:
; 1354 :          - 1 NULL entry
; 1355 :          - 1 .shstrtab
; 1356 :          - 1 .symtab
; 1357 :          - 1 .strtab
; 1358 :          - n .rel<xxx> entries
; 1359 :          */
; 1360 :         em.ehdr32.e_shnum = 1 + modinfo->g.num_segs + 3 + get_num_reloc_sections();

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR tv249[rsp], eax
	call	get_num_reloc_sections
	mov	ecx, DWORD PTR tv249[rsp]
	lea	eax, DWORD PTR [rcx+rax+4]
	mov	WORD PTR em$[rsp+120], ax

; 1361 :         em.ehdr32.e_shstrndx = 1 + modinfo->g.num_segs + SHSTRTAB_IDX; /* set index of .shstrtab section */

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	WORD PTR em$[rsp+122], ax

; 1362 :         if ( fwrite( &em.ehdr32, 1, sizeof( em.ehdr32 ), CurrFile[OBJ] ) != sizeof( em.ehdr32 ) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 52					; 00000034H
	mov	edx, 1
	lea	rcx, QWORD PTR em$[rsp+72]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 52					; 00000034H
	je	SHORT $LN9@elf_write_

; 1363 :             WriteError();

	call	WriteError
$LN9@elf_write_:

; 1364 :         elf_write_section_table32( modinfo, &em,

	movzx	eax, WORD PTR em$[rsp+120]
	movzx	ecx, WORD PTR em$[rsp+118]
	imul	eax, ecx
	cdqe
	add	rax, 52					; 00000034H
	mov	r8d, eax
	lea	rdx, QWORD PTR em$[rsp]
	mov	rcx, QWORD PTR modinfo$[rsp]
	call	elf_write_section_table32
$LN4@elf_write_:

; 1365 :                                   sizeof( Elf32_Ehdr ) + em.ehdr32.e_shnum * em.ehdr32.e_shentsize );
; 1366 :     };
; 1367 :     elf_write_data( modinfo, &em );

	lea	rdx, QWORD PTR em$[rsp]
	mov	rcx, QWORD PTR modinfo$[rsp]
	call	elf_write_data

; 1368 :     DebugMsg(("elf_write_module: exit\n"));

	lea	rcx, OFFSET FLAT:$SG11796
	call	DoDebugMsg

; 1369 :     return( NOT_ERROR );

	xor	eax, eax

; 1370 : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:elf_write_module$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 240				; 000000f0H
	pop	rdi
	ret	0
elf_write_module ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
curr$ = 32
size$ = 40
i$ = 44
tv246 = 48
tv133 = 56
tv257 = 64
tv248 = 72
tv249 = 80
tv196 = 88
tv252 = 96
modinfo$ = 128
em$ = 136
elf_write_data PROC

; 1220 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+128]

; 1221 :     struct dsym *curr;
; 1222 :     //int seg_index;
; 1223 :     //uint_32 offset = 0;
; 1224 :     uint_32     size;
; 1225 :     int         i;
; 1226 : 
; 1227 :     DebugMsg(("elf_write_data: enter\n"));

	lea	rcx, OFFSET FLAT:$SG11762
	call	DoDebugMsg

; 1228 : 
; 1229 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@elf_write_
$LN2@elf_write_:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@elf_write_:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN3@elf_write_

; 1230 :         size = curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR [rcx+56]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR size$[rsp], eax

; 1231 :         DebugMsg(("elf_write_data(%s): program data at ofs=%X, size=%X\n", curr->sym.name, curr->e.seginfo->fileoffset, size ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	r9d, DWORD PTR size$[rsp]
	mov	r8d, DWORD PTR [rax+56]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11763
	call	DoDebugMsg

; 1232 :         if ( curr->e.seginfo->segtype != SEGTYPE_BSS && size != 0 ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 3
	je	$LN11@elf_write_
	cmp	DWORD PTR size$[rsp], 0
	je	$LN11@elf_write_

; 1233 :             fseek( CurrFile[OBJ], curr->e.seginfo->fileoffset + curr->e.seginfo->start_loc, SEEK_SET );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	eax, DWORD PTR [rax+56]
	add	eax, DWORD PTR [rcx+8]
	mov	ecx, 8
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR tv246[rsp], rdx
	xor	r8d, r8d
	mov	edx, eax
	mov	rax, QWORD PTR tv246[rsp]
	mov	rcx, QWORD PTR [rax+rcx]
	call	QWORD PTR __imp_fseek

; 1234 :             /**/myassert( curr->e.seginfo->CodeBuffer );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN20@elf_write_
	mov	DWORD PTR tv133[rsp], 0
	jmp	SHORT $LN21@elf_write_
$LN20@elf_write_:
	mov	edx, 1234				; 000004d2H
	lea	rcx, OFFSET FLAT:$SG11765
	call	InternalError
	mov	DWORD PTR tv133[rsp], eax
$LN21@elf_write_:

; 1235 :             if ( fwrite( curr->e.seginfo->CodeBuffer, 1, size, CurrFile[OBJ] ) != size )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	edx, DWORD PTR size$[rsp]
	mov	r8, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [r8+96]
	mov	QWORD PTR tv257[rsp], r8
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, edx
	mov	edx, 1
	mov	rax, QWORD PTR tv257[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	QWORD PTR __imp_fwrite
	mov	ecx, DWORD PTR size$[rsp]
	cmp	rax, rcx
	je	SHORT $LN12@elf_write_

; 1236 :                 WriteError();

	call	WriteError
$LN12@elf_write_:
$LN11@elf_write_:

; 1237 :         }
; 1238 :     }

	jmp	$LN2@elf_write_
$LN3@elf_write_:

; 1239 : 
; 1240 :     /* write internal sections */
; 1241 :     for ( i = 0; i < NUM_INTSEGS; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@elf_write_
$LN5@elf_write_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@elf_write_:
	cmp	DWORD PTR i$[rsp], 3
	jge	$LN6@elf_write_

; 1242 :         if ( em->internal_segs[i].data ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR em$[rsp]
	cmp	QWORD PTR [rcx+rax+32], 0
	je	$LN13@elf_write_

; 1243 :             DebugMsg(("elf_write_data(%s): internal at ofs=%X, size=%X\n", internal_segparms[i].name, em->internal_segs[i].fileoffset, em->internal_segs[i].size));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	movsxd	rdx, DWORD PTR i$[rsp]
	imul	rdx, rdx, 16
	lea	r8, OFFSET FLAT:internal_segparms
	mov	QWORD PTR tv248[rsp], r8
	mov	r9, QWORD PTR em$[rsp]
	mov	r9d, DWORD PTR [r9+rax+24]
	mov	rax, QWORD PTR em$[rsp]
	mov	r8d, DWORD PTR [rax+rcx+28]
	mov	rax, QWORD PTR tv248[rsp]
	mov	rdx, QWORD PTR [rax+rdx]
	lea	rcx, OFFSET FLAT:$SG11768
	call	DoDebugMsg

; 1244 :             fseek( CurrFile[OBJ], em->internal_segs[i].fileoffset, SEEK_SET );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	ecx, 8
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR tv249[rsp], rdx
	xor	r8d, r8d
	mov	r9, QWORD PTR em$[rsp]
	mov	edx, DWORD PTR [r9+rax+28]
	mov	rax, QWORD PTR tv249[rsp]
	mov	rcx, QWORD PTR [rax+rcx]
	call	QWORD PTR __imp_fseek

; 1245 :             if ( fwrite( em->internal_segs[i].data, 1, em->internal_segs[i].size, CurrFile[OBJ] ) != em->internal_segs[i].size )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	movsxd	rdx, DWORD PTR i$[rsp]
	imul	rdx, rdx, 16
	mov	r8, QWORD PTR em$[rsp]
	mov	edx, DWORD PTR [r8+rdx+24]
	movsxd	r8, DWORD PTR i$[rsp]
	imul	r8, r8, 16
	mov	QWORD PTR tv196[rsp], r8
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, edx
	mov	edx, 1
	mov	rax, QWORD PTR em$[rsp]
	mov	rcx, QWORD PTR tv196[rsp]
	mov	rcx, QWORD PTR [rax+rcx+32]
	call	QWORD PTR __imp_fwrite
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR em$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx+24]
	cmp	rax, rcx
	je	SHORT $LN14@elf_write_

; 1246 :                 WriteError();

	call	WriteError
$LN14@elf_write_:
$LN13@elf_write_:

; 1247 :         }
; 1248 :     }

	jmp	$LN5@elf_write_
$LN6@elf_write_:

; 1249 : 
; 1250 :     /* write reloc sections content */
; 1251 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN10@elf_write_
$LN8@elf_write_:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN10@elf_write_:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN9@elf_write_

; 1252 :         if ( curr->e.seginfo->num_relocs ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+64], 0
	je	$LN15@elf_write_

; 1253 :             DebugMsg(("elf_write_data(%s): relocs at ofs=%X, size=%X\n", curr->sym.name, curr->e.seginfo->reloc_offset, curr->e.seginfo->num_relocs * sizeof(Elf32_Rel)));

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+64]
	shl	rax, 3
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	r9, rax
	mov	r8d, DWORD PTR [rcx+12]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11771
	call	DoDebugMsg

; 1254 :             fseek( CurrFile[OBJ], curr->e.seginfo->reloc_offset, SEEK_SET );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 8
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:ModuleInfo+96
	mov	QWORD PTR tv252[rsp], rdx
	xor	r8d, r8d
	mov	edx, DWORD PTR [rax+12]
	mov	rax, QWORD PTR tv252[rsp]
	mov	rcx, QWORD PTR [rax+rcx]
	call	QWORD PTR __imp_fseek

; 1255 : #if AMD64_SUPPORT
; 1256 :             if ( modinfo->defOfssize == USE64 )

	mov	rax, QWORD PTR modinfo$[rsp]
	movzx	eax, BYTE PTR [rax+405]
	cmp	eax, 2
	jne	SHORT $LN16@elf_write_

; 1257 :                 write_relocs64( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	write_relocs64
	jmp	SHORT $LN17@elf_write_
$LN16@elf_write_:

; 1258 :             else
; 1259 : #endif
; 1260 :                 write_relocs32( em, curr );

	mov	rdx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR em$[rsp]
	call	write_relocs32
$LN17@elf_write_:
$LN15@elf_write_:

; 1261 :         }
; 1262 :     }

	jmp	$LN8@elf_write_
$LN9@elf_write_:

; 1263 : #if GNURELOCS
; 1264 :     if ( em->extused ) {

	mov	rax, QWORD PTR em$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	test	eax, eax
	je	SHORT $LN18@elf_write_

; 1265 :         EmitWarn( 2, ELF_GNU_EXTENSIONS_USED );

	mov	edx, 262				; 00000106H
	mov	ecx, 2
	call	EmitWarn
$LN18@elf_write_:

; 1266 :     }
; 1267 : #endif
; 1268 : 
; 1269 :     DebugMsg(("elf_write_data: exit\n"));

	lea	rcx, OFFSET FLAT:$SG11775
	call	DoDebugMsg

; 1270 : 
; 1271 :     return( NOT_ERROR );

	xor	eax, eax

; 1272 : }

	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
elf_write_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
elftype$ = 64
fixup$ = 72
reloc64$ = 88
symidx$4 = 116
tv94 = 128
__$ArrayPad$ = 136
curr$ = 160
write_relocs64 PROC

; 1132 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 144				; 00000090H
	mov	rdi, rsp
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+160]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1133 :     uint_8 elftype;
; 1134 :     struct fixup *fixup;
; 1135 :     Elf64_Rela reloc64; /* v2.05: changed to Rela */
; 1136 : 
; 1137 :     DebugMsg(("write_relocs64: enter\n"));

	lea	rcx, OFFSET FLAT:$SG11726
	call	DoDebugMsg

; 1138 :     for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR fixup$[rsp], rax
	jmp	SHORT $LN4@write_relo
$LN2@write_relo:
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR fixup$[rsp], rax
$LN4@write_relo:
	cmp	QWORD PTR fixup$[rsp], 0
	je	$LN3@write_relo

; 1139 :         unsigned symidx = fixup->sym->ext_idx;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	eax, DWORD PTR [rax+88]
	mov	DWORD PTR symidx$4[rsp], eax

; 1140 :         reloc64.r_offset = fixup->locofs;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+20]
	mov	QWORD PTR reloc64$[rsp], rax

; 1141 :         /* v2.07: addend wasn't handled correctly.
; 1142 :          * Also note the type cast for fixup.offset -
; 1143 :          * r_addend has type int_64, while fixup.offset has type uint_32!
; 1144 :          */
; 1145 :         //reloc64.r_addend = fixup->offset;
; 1146 :         /* the following line depends on what's done in store_fixup().
; 1147 :          * if the inline addend is set to 0 there, the fixup->offset
; 1148 :          * must be used in the calculation ( it's 32-bit only!!! ).
; 1149 :          */
; 1150 :         //reloc64.r_addend = (int_32)fixup->offset - fixup->addbytes;
; 1151 :         /*
; 1152 :          * if the inline addend is not touched in store_fixup(),
; 1153 :          * we just have to use the addbytes field.
; 1154 :          */
; 1155 :         reloc64.r_addend = - fixup->addbytes;

	mov	rax, QWORD PTR fixup$[rsp]
	movzx	eax, BYTE PTR [rax+32]
	neg	eax
	cdqe
	mov	QWORD PTR reloc64$[rsp+16], rax

; 1156 :         DebugMsg(("write_relocs64(): reloc loc=%X type=%u idx=%u sym=%s ofs=%X addbyt=%u\n",

	mov	rax, QWORD PTR fixup$[rsp]
	movzx	eax, BYTE PTR [rax+32]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	rdx, QWORD PTR fixup$[rsp]
	mov	rdx, QWORD PTR [rdx+56]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR [rdx+88]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+24]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	edx, DWORD PTR [rax+20]
	lea	rcx, OFFSET FLAT:$SG11727
	call	DoDebugMsg

; 1157 :                   fixup->locofs, fixup->type, fixup->sym->ext_idx, fixup->sym->name, fixup->offset, fixup->addbytes ));
; 1158 :         switch ( fixup->type ) {

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv94[rsp], eax
	mov	eax, DWORD PTR tv94[rsp]
	dec	eax
	mov	DWORD PTR tv94[rsp], eax
	cmp	DWORD PTR tv94[rsp], 11
	ja	SHORT $LN15@write_relo
	movsxd	rax, DWORD PTR tv94[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN20@write_relo[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN7@write_relo:

; 1159 :         case FIX_RELOFF32:
; 1160 : #if 0  /* v2.07: activate if the section's index is to be used as symtab ref */
; 1161 :             if ( fixup->sym->segment != &curr->sym ) {
; 1162 :                 //printf("PC-relative fixup to another section: %s\n", fixup->sym->name );
; 1163 :                 reloc64.r_addend += fixup->sym->offset;
; 1164 :                 symidx = fixup->sym->segment->ext_idx;
; 1165 :             }
; 1166 : #endif
; 1167 :             elftype = R_X86_64_PC32;

	mov	BYTE PTR elftype$[rsp], 2

; 1168 :             break;

	jmp	$LN5@write_relo
$LN8@write_relo:

; 1169 :         case FIX_OFF64:        elftype = R_X86_64_64;          break;

	mov	BYTE PTR elftype$[rsp], 1
	jmp	$LN5@write_relo
$LN9@write_relo:

; 1170 :         //case FIX_???:        elftype = R_X86_64_GOT32;       break;
; 1171 :         //case FIX_???:        elftype = R_X86_64_PLT32;       break;
; 1172 :         //case FIX_???:        elftype = R_X86_64_COPY;        break;
; 1173 :         //case FIX_???:        elftype = R_X86_64_GLOB_DAT;    break;
; 1174 :         //case FIX_???:        elftype = R_X86_64_JMP_SLOT;    break;
; 1175 :         case FIX_OFF32_IMGREL: elftype = R_X86_64_RELATIVE;    break;

	mov	BYTE PTR elftype$[rsp], 8
	jmp	$LN5@write_relo
$LN10@write_relo:

; 1176 :         //case FIX_???:        elftype = R_X86_64_GOTPCREL;    break;
; 1177 :         case FIX_OFF32:        elftype = R_X86_64_32;          break;

	mov	BYTE PTR elftype$[rsp], 10
	jmp	$LN5@write_relo
$LN11@write_relo:

; 1178 :         //case FIX_???:        elftype = R_X86_64_32S;         break;
; 1179 :         case FIX_OFF16:        elftype = R_X86_64_16;          break;

	mov	BYTE PTR elftype$[rsp], 12
	jmp	$LN5@write_relo
$LN12@write_relo:

; 1180 :         case FIX_RELOFF16:     elftype = R_X86_64_PC16;        break;

	mov	BYTE PTR elftype$[rsp], 13
	jmp	$LN5@write_relo
$LN13@write_relo:

; 1181 :         case FIX_OFF8:         elftype = R_X86_64_8;           break;

	mov	BYTE PTR elftype$[rsp], 14
	jmp	$LN5@write_relo
$LN14@write_relo:

; 1182 :         case FIX_RELOFF8:      elftype = R_X86_64_PC8;         break;

	mov	BYTE PTR elftype$[rsp], 15
	jmp	$LN5@write_relo
$LN15@write_relo:

; 1183 :         //case FIX_???:        elftype = R_X86_64_DPTMOD64;    break;
; 1184 :         //case FIX_???:        elftype = R_X86_64_DPTOFF64;    break;
; 1185 :         //case FIX_???:        elftype = R_X86_64_TPOFF64;     break;
; 1186 :         //case FIX_???:        elftype = R_X86_64_TLSGD;       break;
; 1187 :         //case FIX_???:        elftype = R_X86_64_TLSLD;       break;
; 1188 :         //case FIX_???:        elftype = R_X86_64_DPTOFF32;    break;
; 1189 :         //case FIX_???:        elftype = R_X86_64_GOTTPOFF;    break;
; 1190 :         //case FIX_???:        elftype = R_X86_64_TPOFF32;     break;
; 1191 :         //case FIX_???:        elftype = R_X86_64_PC64;        break;
; 1192 :         //case FIX_???:        elftype = R_X86_64_GOTOFF64;    break;
; 1193 :         //case FIX_???:        elftype = R_X86_64_GOTPC32;     break;
; 1194 :         //case FIX_???:        elftype = R_X86_64_SIZE32;      break;
; 1195 :         //case FIX_???:        elftype = R_X86_64_SIZE64;      break;
; 1196 :         default:
; 1197 :             DebugMsg(("write_relocs64(): unhandled reloc loc=%X type=%u idx=%u sym=%s\n",

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR [rcx+88]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+24]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	edx, DWORD PTR [rax+20]
	lea	rcx, OFFSET FLAT:$SG11737
	call	DoDebugMsg

; 1198 :                       fixup->locofs, fixup->type, fixup->sym->ext_idx, fixup->sym->name));
; 1199 :             elftype = R_X86_64_NONE;

	mov	BYTE PTR elftype$[rsp], 0

; 1200 :             if ( fixup->type < FIX_LAST ) {

	mov	rax, QWORD PTR fixup$[rsp]
	cmp	DWORD PTR [rax+24], 14
	jge	SHORT $LN16@write_relo

; 1201 :                 EmitErr( INVALID_FIXUP_TYPE, ModuleInfo.fmtopt->formatname, fixup->type, curr->sym.name, fixup->locofs );

	mov	rax, QWORD PTR ModuleInfo+344
	add	rax, 10
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	mov	DWORD PTR [rsp+32], ecx
	mov	rcx, QWORD PTR curr$[rsp]
	mov	r9, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rcx+24]
	mov	rdx, rax
	mov	ecx, 198				; 000000c6H
	call	EmitErr

; 1202 :             } else

	jmp	SHORT $LN17@write_relo
$LN16@write_relo:

; 1203 :                 EmitErr( UNKNOWN_FIXUP_TYPE, fixup->type, curr->sym.name, fixup->locofs );

	mov	rax, QWORD PTR fixup$[rsp]
	mov	r9d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	edx, DWORD PTR [rax+24]
	mov	ecx, 196				; 000000c4H
	call	EmitErr
$LN17@write_relo:
$LN5@write_relo:

; 1204 :         }
; 1205 :         /* the low 8 bits of info are type */
; 1206 :         /* the high 24 bits are symbol table index */
; 1207 :         reloc64.r_info = ELF64_R_INFO( symidx, elftype );

	mov	eax, DWORD PTR symidx$4[rsp]
	shl	rax, 32					; 00000020H
	movzx	ecx, BYTE PTR elftype$[rsp]
	add	rax, rcx
	mov	QWORD PTR reloc64$[rsp+8], rax

; 1208 :         if ( fwrite( &reloc64, 1, sizeof( reloc64 ), CurrFile[OBJ] ) != sizeof(reloc64) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 24
	mov	edx, 1
	lea	rcx, QWORD PTR reloc64$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 24
	je	SHORT $LN18@write_relo

; 1209 :             WriteError();

	call	WriteError
$LN18@write_relo:

; 1210 :     }

	jmp	$LN2@write_relo
$LN3@write_relo:

; 1211 :     DebugMsg(("write_relocs64: exit\n"));

	lea	rcx, OFFSET FLAT:$SG11741
	call	DoDebugMsg

; 1212 :     return;
; 1213 : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:write_relocs64$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 144				; 00000090H
	pop	rdi
	ret	0
$LN20@write_relo:
	DD	$LN14@write_relo
	DD	$LN12@write_relo
	DD	$LN7@write_relo
	DD	$LN13@write_relo
	DD	$LN11@write_relo
	DD	$LN10@write_relo
	DD	$LN8@write_relo
	DD	$LN15@write_relo
	DD	$LN15@write_relo
	DD	$LN15@write_relo
	DD	$LN15@write_relo
	DD	$LN9@write_relo
write_relocs64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
elftype$ = 48
fixup$ = 56
reloc32$ = 72
tv71 = 84
em$ = 112
curr$ = 120
write_relocs32 PROC

; 1082 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rdi, rsp
	mov	ecx, 24
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+112]

; 1083 :     uint_8 elftype;
; 1084 :     struct fixup *fixup;
; 1085 :     Elf32_Rel reloc32;
; 1086 : 
; 1087 :     DebugMsg(("write_relocs32: enter\n"));

	lea	rcx, OFFSET FLAT:$SG11698
	call	DoDebugMsg

; 1088 :     for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR fixup$[rsp], rax
	jmp	SHORT $LN4@write_relo
$LN2@write_relo:
	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR fixup$[rsp], rax
$LN4@write_relo:
	cmp	QWORD PTR fixup$[rsp], 0
	je	$LN3@write_relo

; 1089 :         reloc32.r_offset = fixup->locofs;

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+20]
	mov	DWORD PTR reloc32$[rsp], eax

; 1090 :         switch ( fixup->type ) {

	mov	rax, QWORD PTR fixup$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv71[rsp], eax
	mov	eax, DWORD PTR tv71[rsp]
	dec	eax
	mov	DWORD PTR tv71[rsp], eax
	cmp	DWORD PTR tv71[rsp], 11
	ja	$LN14@write_relo
	movsxd	rax, DWORD PTR tv71[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN19@write_relo[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN7@write_relo:

; 1091 :         case FIX_OFF32:         elftype = R_386_32;             break;

	mov	BYTE PTR elftype$[rsp], 1
	jmp	$LN5@write_relo
$LN8@write_relo:

; 1092 :         case FIX_RELOFF32:      elftype = R_386_PC32;           break;

	mov	BYTE PTR elftype$[rsp], 2
	jmp	$LN5@write_relo
$LN9@write_relo:

; 1093 :         //case FIX_???:         elftype = R_386_GOT32;          break;
; 1094 :         //case FIX_???:         elftype = R_386_PLT32;          break;
; 1095 :         //case FIX_???:         elftype = R_386_COPY;           break;
; 1096 :         //case FIX_???:         elftype = R_386_GLOB_DAT;       break;
; 1097 :         //case FIX_???:         elftype = R_386_JMP_SLOT;       break;
; 1098 :         case FIX_OFF32_IMGREL:  elftype = R_386_RELATIVE;       break;

	mov	BYTE PTR elftype$[rsp], 8
	jmp	$LN5@write_relo
$LN10@write_relo:

; 1099 :         //case FIX_???:         elftype = R_386_GOTOFF;         break;
; 1100 :         //case FIX_???:         elftype = R_386_GOTPC;          break;
; 1101 : #if GNURELOCS
; 1102 :         case FIX_OFF16:    em->extused = TRUE; elftype = R_386_16;   break;

	mov	rax, QWORD PTR em$[rsp]
	mov	BYTE PTR [rax+16], 1
	mov	BYTE PTR elftype$[rsp], 20
	jmp	$LN5@write_relo
$LN11@write_relo:

; 1103 :         case FIX_RELOFF16: em->extused = TRUE; elftype = R_386_PC16; break;

	mov	rax, QWORD PTR em$[rsp]
	mov	BYTE PTR [rax+16], 1
	mov	BYTE PTR elftype$[rsp], 21
	jmp	$LN5@write_relo
$LN12@write_relo:

; 1104 :         case FIX_OFF8:     em->extused = TRUE; elftype = R_386_8;    break;

	mov	rax, QWORD PTR em$[rsp]
	mov	BYTE PTR [rax+16], 1
	mov	BYTE PTR elftype$[rsp], 22
	jmp	$LN5@write_relo
$LN13@write_relo:

; 1105 :         case FIX_RELOFF8:  em->extused = TRUE; elftype = R_386_PC8;  break;

	mov	rax, QWORD PTR em$[rsp]
	mov	BYTE PTR [rax+16], 1
	mov	BYTE PTR elftype$[rsp], 23
	jmp	$LN5@write_relo
$LN14@write_relo:

; 1106 : #endif
; 1107 :         default:
; 1108 :             DebugMsg(("write_relocs32(): unhandled reloc loc=%X type=%u idx=%u sym=%s\n",

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR [rcx+88]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rax+24]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	edx, DWORD PTR [rax+20]
	lea	rcx, OFFSET FLAT:$SG11707
	call	DoDebugMsg

; 1109 :                       fixup->locofs, fixup->type, fixup->sym->ext_idx, fixup->sym->name));
; 1110 :             elftype = R_386_NONE;

	mov	BYTE PTR elftype$[rsp], 0

; 1111 :             if ( fixup->type < FIX_LAST ) {

	mov	rax, QWORD PTR fixup$[rsp]
	cmp	DWORD PTR [rax+24], 14
	jge	SHORT $LN15@write_relo

; 1112 :                 EmitErr( INVALID_FIXUP_TYPE, ModuleInfo.fmtopt->formatname, fixup->type, curr->sym.name, fixup->locofs );

	mov	rax, QWORD PTR ModuleInfo+344
	add	rax, 10
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	mov	DWORD PTR [rsp+32], ecx
	mov	rcx, QWORD PTR curr$[rsp]
	mov	r9, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR fixup$[rsp]
	mov	r8d, DWORD PTR [rcx+24]
	mov	rdx, rax
	mov	ecx, 198				; 000000c6H
	call	EmitErr

; 1113 :             } else

	jmp	SHORT $LN16@write_relo
$LN15@write_relo:

; 1114 :                 EmitErr( UNKNOWN_FIXUP_TYPE, fixup->type, curr->sym.name, fixup->locofs );

	mov	rax, QWORD PTR fixup$[rsp]
	mov	r9d, DWORD PTR [rax+20]
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR fixup$[rsp]
	mov	edx, DWORD PTR [rax+24]
	mov	ecx, 196				; 000000c4H
	call	EmitErr
$LN16@write_relo:
$LN5@write_relo:

; 1115 :         }
; 1116 :         /* the low 8 bits of info are type */
; 1117 :         /* the high 24 bits are symbol table index */
; 1118 :         reloc32.r_info = ELF32_R_INFO( fixup->sym->ext_idx, elftype );

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	eax, DWORD PTR [rax+88]
	shl	eax, 8
	movzx	ecx, BYTE PTR elftype$[rsp]
	add	eax, ecx
	mov	DWORD PTR reloc32$[rsp+4], eax

; 1119 :         if ( fwrite( &reloc32, 1, sizeof(reloc32), CurrFile[OBJ] ) != sizeof(reloc32) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 8
	mov	edx, 1
	lea	rcx, QWORD PTR reloc32$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 8
	je	SHORT $LN17@write_relo

; 1120 :             WriteError();

	call	WriteError
$LN17@write_relo:

; 1121 :     }

	jmp	$LN2@write_relo
$LN3@write_relo:

; 1122 :     DebugMsg(("write_relocs32: exit\n"));

	lea	rcx, OFFSET FLAT:$SG11711
	call	DoDebugMsg

; 1123 :     return;
; 1124 : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:write_relocs32$rtcFrameData
	call	_RTC_CheckStackVars
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
	npad	3
$LN19@write_relo:
	DD	$LN13@write_relo
	DD	$LN11@write_relo
	DD	$LN8@write_relo
	DD	$LN12@write_relo
	DD	$LN10@write_relo
	DD	$LN7@write_relo
	DD	$LN14@write_relo
	DD	$LN14@write_relo
	DD	$LN14@write_relo
	DD	$LN14@write_relo
	DD	$LN14@write_relo
	DD	$LN9@write_relo
write_relocs32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
i$ = 48
curr$ = 56
p$ = 64
shdr64$ = 96
tv144 = 176
__$ArrayPad$ = 184
modinfo$ = 208
em$ = 216
fileoffset$ = 224
elf_write_section_table64 PROC

; 931  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 192				; 000000c0H
	mov	rdi, rsp
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+208]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 932  :     int         i;
; 933  :     struct dsym *curr;
; 934  :     uint_8      *p;
; 935  :     //uint_32     fileoffset;
; 936  :     Elf64_Shdr  shdr64;
; 937  : 
; 938  :     DebugMsg(("elf_write_section_table64( fileofs=%X ): enter\n", fileoffset ));

	mov	edx, DWORD PTR fileoffset$[rsp]
	lea	rcx, OFFSET FLAT:$SG11661
	call	DoDebugMsg

; 939  : 
; 940  :     //fileoffset = sizeof(Elf64_Ehdr) + ehdr->e_shnum * ehdr->e_shentsize;
; 941  :     fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR fileoffset$[rsp]
	add	eax, 15
	and	eax, -16				; fffffff0H
	mov	DWORD PTR fileoffset$[rsp], eax

; 942  : 
; 943  :     /* set contents and size of internal .shstrtab section */
; 944  :     set_shstrtab_values( em );

	mov	rcx, QWORD PTR em$[rsp]
	call	set_shstrtab_values

; 945  : 
; 946  :     /* write the NULL entry */
; 947  :     memset( &shdr64, 0, sizeof( shdr64) );

	mov	r8d, 64					; 00000040H
	xor	edx, edx
	lea	rcx, QWORD PTR shdr64$[rsp]
	call	memset

; 948  :     if ( fwrite( &shdr64, 1, sizeof(shdr64), CurrFile[OBJ] ) != sizeof(shdr64) ) /* write the empty NULL entry */

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 64					; 00000040H
	mov	edx, 1
	lea	rcx, QWORD PTR shdr64$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 64					; 00000040H
	je	SHORT $LN11@elf_write_

; 949  :         WriteError();

	call	WriteError
$LN11@elf_write_:

; 950  : 
; 951  :     /* use p to scan strings (=section names) of .shstrtab */
; 952  :     p = (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR em$[rsp]
	mov	rax, QWORD PTR [rcx+rax+32]
	mov	QWORD PTR p$[rsp], rax

; 953  :     p++; /* skip 'name' of NULL entry */

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 954  : 
; 955  :     /* write the section headers defined in the module */
; 956  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@elf_write_
$LN2@elf_write_:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@elf_write_:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN3@elf_write_

; 957  : 
; 958  :         memset( &shdr64, 0, sizeof(shdr64) );

	mov	r8d, 64					; 00000040H
	xor	edx, edx
	lea	rcx, QWORD PTR shdr64$[rsp]
	call	memset

; 959  : 
; 960  :         shdr64.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR em$[rsp]
	mov	rax, QWORD PTR [rcx+rax+32]
	mov	rcx, QWORD PTR p$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR shdr64$[rsp], eax

; 961  :         p += strlen( (char *)p ) + 1;

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR p$[rsp], rax

; 962  :         if ( curr->e.seginfo->info == TRUE ) { /* v2.07:added; v2.12: highest priority */

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN12@elf_write_

; 963  :             shdr64.sh_type = SHT_NOTE;

	mov	DWORD PTR shdr64$[rsp+4], 7

; 964  :             shdr64.sh_flags = 0;

	mov	QWORD PTR shdr64$[rsp+8], 0

; 965  :         } else {

	jmp	$LN13@elf_write_
$LN12@elf_write_:

; 966  :             shdr64.sh_type = ( curr->e.seginfo->segtype != SEGTYPE_BSS ? SHT_PROGBITS : SHT_NOBITS );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 3
	je	SHORT $LN28@elf_write_
	mov	DWORD PTR tv144[rsp], 1
	jmp	SHORT $LN29@elf_write_
$LN28@elf_write_:
	mov	DWORD PTR tv144[rsp], 8
$LN29@elf_write_:
	mov	eax, DWORD PTR tv144[rsp]
	mov	DWORD PTR shdr64$[rsp+4], eax

; 967  :             if ( curr->e.seginfo->segtype == SEGTYPE_CODE ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 1
	jne	SHORT $LN14@elf_write_

; 968  :                 shdr64.sh_flags = SHF_EXECINSTR | SHF_ALLOC;

	mov	QWORD PTR shdr64$[rsp+8], 6
	jmp	SHORT $LN15@elf_write_
$LN14@elf_write_:

; 969  :             } else if ( curr->e.seginfo->readonly == TRUE ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN16@elf_write_

; 970  :                 shdr64.sh_flags = SHF_ALLOC;

	mov	QWORD PTR shdr64$[rsp+8], 2
	jmp	SHORT $LN17@elf_write_
$LN16@elf_write_:

; 971  :             } else if ( curr->e.seginfo->clsym && strcmp( curr->e.seginfo->clsym->name, "CONST" ) == 0 ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN18@elf_write_
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+80]
	lea	rdx, OFFSET FLAT:$SG11671
	mov	rcx, QWORD PTR [rax+8]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN18@elf_write_

; 972  :                 shdr64.sh_flags = SHF_ALLOC; /* v2.07: added */

	mov	QWORD PTR shdr64$[rsp+8], 2

; 973  :             } else {

	jmp	SHORT $LN19@elf_write_
$LN18@elf_write_:

; 974  :                 shdr64.sh_flags = SHF_WRITE | SHF_ALLOC;

	mov	QWORD PTR shdr64$[rsp+8], 3
$LN19@elf_write_:
$LN17@elf_write_:
$LN15@elf_write_:
$LN13@elf_write_:

; 975  :             }
; 976  :         }
; 977  : #if 0
; 978  :         /* todo: translate values in field <characteristics> to
; 979  :          * elf section flags.
; 980  :          */
; 981  :         if ( curr->e.seginfo->characteristics == ??? ) {
; 982  :         }
; 983  : #endif
; 984  :         shdr64.sh_addr = 0;

	mov	QWORD PTR shdr64$[rsp+16], 0

; 985  :         /* v2.12: the sh_offset field holds the file position, even for SHT_NOBITS */
; 986  :         //if ( shdr64.sh_type != SHT_NOBITS ) {
; 987  :             shdr64.sh_offset = fileoffset; /* start of section in file */

	mov	eax, DWORD PTR fileoffset$[rsp]
	mov	QWORD PTR shdr64$[rsp+24], rax

; 988  :             curr->e.seginfo->fileoffset = fileoffset; /* save the offset in the segment */

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR fileoffset$[rsp]
	mov	DWORD PTR [rax+56], ecx

; 989  :         //}
; 990  :         /* v2.07: set size for all sections, including .bss */
; 991  :         shdr64.sh_size = curr->sym.max_offset;

	mov	rax, QWORD PTR curr$[rsp]
	movsxd	rax, DWORD PTR [rax+56]
	mov	QWORD PTR shdr64$[rsp+32], rax

; 992  :         shdr64.sh_link = 0;

	mov	DWORD PTR shdr64$[rsp+40], 0

; 993  :         shdr64.sh_info = 0;

	mov	DWORD PTR shdr64$[rsp+44], 0

; 994  :         shdr64.sh_addralign = Get_Alignment( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	Get_Alignment
	mov	eax, eax
	mov	QWORD PTR shdr64$[rsp+48], rax

; 995  :         shdr64.sh_entsize = 0;

	mov	QWORD PTR shdr64$[rsp+56], 0

; 996  : 
; 997  :         if ( fwrite( &shdr64, 1, sizeof(shdr64), CurrFile[OBJ] ) != sizeof(shdr64) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 64					; 00000040H
	mov	edx, 1
	lea	rcx, QWORD PTR shdr64$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 64					; 00000040H
	je	SHORT $LN20@elf_write_

; 998  :             WriteError();

	call	WriteError
$LN20@elf_write_:

; 999  :         curr->e.seginfo->num_relocs = get_relocation_count( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	get_relocation_count
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+64], eax

; 1000 : 
; 1001 :         /* v2.12: don't adjust fileoffset for SHT_NOBITS sections */
; 1002 :         if ( shdr64.sh_type != SHT_NOBITS ) {

	cmp	DWORD PTR shdr64$[rsp+4], 8
	je	SHORT $LN21@elf_write_

; 1003 :             fileoffset += shdr64.sh_size;

	mov	eax, DWORD PTR fileoffset$[rsp]
	add	rax, QWORD PTR shdr64$[rsp+32]
	mov	DWORD PTR fileoffset$[rsp], eax

; 1004 :             fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR fileoffset$[rsp]
	add	eax, 15
	and	eax, -16				; fffffff0H
	mov	DWORD PTR fileoffset$[rsp], eax
$LN21@elf_write_:

; 1005 :         }
; 1006 : 
; 1007 :         DebugMsg(("elf_write_section_table64(%s): ofs=%" I64_SPEC "X size=%" I64_SPEC "X numrelocs=%u\n", curr->sym.name, shdr64.sh_offset, shdr64.sh_size, curr->e.seginfo->num_relocs));

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR shdr64$[rsp+32]
	mov	r8, QWORD PTR shdr64$[rsp+24]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11674
	call	DoDebugMsg

; 1008 :     }

	jmp	$LN2@elf_write_
$LN3@elf_write_:

; 1009 : 
; 1010 :     /* set size and contents of .symtab and .strtab sections */
; 1011 :     set_symtab_values( em );

	mov	rcx, QWORD PTR em$[rsp]
	call	set_symtab_values

; 1012 : 
; 1013 :     /* write headers of internal sections */
; 1014 :     for ( i = 0; i < NUM_INTSEGS; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@elf_write_
$LN5@elf_write_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@elf_write_:
	cmp	DWORD PTR i$[rsp], 3
	jge	$LN6@elf_write_

; 1015 : 
; 1016 :         shdr64.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR em$[rsp]
	mov	rax, QWORD PTR [rcx+rax+32]
	mov	rcx, QWORD PTR p$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR shdr64$[rsp], eax

; 1017 :         p += strlen( (char *)p ) + 1;

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR p$[rsp], rax

; 1018 :         shdr64.sh_type = internal_segparms[i].type;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:internal_segparms
	mov	eax, DWORD PTR [rcx+rax+8]
	mov	DWORD PTR shdr64$[rsp+4], eax

; 1019 :         shdr64.sh_flags = 0;

	mov	QWORD PTR shdr64$[rsp+8], 0

; 1020 :         shdr64.sh_offset = fileoffset; /* start of section in file */

	mov	eax, DWORD PTR fileoffset$[rsp]
	mov	QWORD PTR shdr64$[rsp+24], rax

; 1021 :         em->internal_segs[i].fileoffset = fileoffset;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR em$[rsp]
	mov	edx, DWORD PTR fileoffset$[rsp]
	mov	DWORD PTR [rcx+rax+28], edx

; 1022 :         shdr64.sh_size = em->internal_segs[i].size;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR em$[rsp]
	mov	eax, DWORD PTR [rcx+rax+24]
	mov	QWORD PTR shdr64$[rsp+32], rax

; 1023 :         /* section .symtab is special */
; 1024 :         if ( i == SYMTAB_IDX ) {

	cmp	DWORD PTR i$[rsp], 1
	jne	SHORT $LN22@elf_write_

; 1025 :             shdr64.sh_link = 1 + modinfo->g.num_segs + STRTAB_IDX;

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	eax, DWORD PTR [rax+8]
	add	eax, 3
	mov	DWORD PTR shdr64$[rsp+40], eax

; 1026 :             shdr64.sh_info = em->start_globals;

	mov	rax, QWORD PTR em$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR shdr64$[rsp+44], eax

; 1027 :             shdr64.sh_addralign = 4;

	mov	QWORD PTR shdr64$[rsp+48], 4

; 1028 :             shdr64.sh_entsize = sizeof( Elf64_Sym );

	mov	QWORD PTR shdr64$[rsp+56], 24

; 1029 :         } else {

	jmp	SHORT $LN23@elf_write_
$LN22@elf_write_:

; 1030 :             shdr64.sh_link = 0;

	mov	DWORD PTR shdr64$[rsp+40], 0

; 1031 :             shdr64.sh_info = 0;

	mov	DWORD PTR shdr64$[rsp+44], 0

; 1032 :             shdr64.sh_addralign = 1;

	mov	QWORD PTR shdr64$[rsp+48], 1

; 1033 :             shdr64.sh_entsize = 0;

	mov	QWORD PTR shdr64$[rsp+56], 0
$LN23@elf_write_:

; 1034 :         }
; 1035 :         if ( fwrite( &shdr64, 1, sizeof( shdr64 ), CurrFile[OBJ] ) != sizeof( shdr64 ) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 64					; 00000040H
	mov	edx, 1
	lea	rcx, QWORD PTR shdr64$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 64					; 00000040H
	je	SHORT $LN24@elf_write_

; 1036 :             WriteError();

	call	WriteError
$LN24@elf_write_:

; 1037 : 
; 1038 :         fileoffset += shdr64.sh_size;

	mov	eax, DWORD PTR fileoffset$[rsp]
	add	rax, QWORD PTR shdr64$[rsp+32]
	mov	DWORD PTR fileoffset$[rsp], eax

; 1039 :         fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR fileoffset$[rsp]
	add	eax, 15
	and	eax, -16				; fffffff0H
	mov	DWORD PTR fileoffset$[rsp], eax

; 1040 :         DebugMsg(("elf_write_section_table64(%s): ofs=%" I64_SPEC "X size=%" I64_SPEC "X\n", internal_segparms[i].name, shdr64.sh_offset, shdr64.sh_size));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:internal_segparms
	mov	r9, QWORD PTR shdr64$[rsp+32]
	mov	r8, QWORD PTR shdr64$[rsp+24]
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG11678
	call	DoDebugMsg

; 1041 :     }

	jmp	$LN5@elf_write_
$LN6@elf_write_:

; 1042 : 
; 1043 :     /* write headers of reloc sections */
; 1044 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN10@elf_write_
$LN8@elf_write_:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN10@elf_write_:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN9@elf_write_

; 1045 :         if ( curr->e.seginfo->FixupList.head == NULL )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+40], 0
	jne	SHORT $LN25@elf_write_

; 1046 :             continue;

	jmp	SHORT $LN8@elf_write_
$LN25@elf_write_:

; 1047 : 
; 1048 :         memset( &shdr64, 0, sizeof(shdr64) );

	mov	r8d, 64					; 00000040H
	xor	edx, edx
	lea	rcx, QWORD PTR shdr64$[rsp]
	call	memset

; 1049 : 
; 1050 :         shdr64.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR em$[rsp]
	mov	rax, QWORD PTR [rcx+rax+32]
	mov	rcx, QWORD PTR p$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR shdr64$[rsp], eax

; 1051 :         p += strlen( (char *)p ) + 1;

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR p$[rsp], rax

; 1052 :         shdr64.sh_type = SHT_RELA; /* v2.05: changed REL to RELA */

	mov	DWORD PTR shdr64$[rsp+4], 4

; 1053 :         shdr64.sh_flags = 0;

	mov	QWORD PTR shdr64$[rsp+8], 0

; 1054 :         shdr64.sh_addr = 0;

	mov	QWORD PTR shdr64$[rsp+16], 0

; 1055 :         shdr64.sh_offset = fileoffset; /* start of section in file */

	mov	eax, DWORD PTR fileoffset$[rsp]
	mov	QWORD PTR shdr64$[rsp+24], rax

; 1056 :         /* save the file offset in the slot reserved for ELF relocs */
; 1057 :         curr->e.seginfo->reloc_offset = fileoffset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR fileoffset$[rsp]
	mov	DWORD PTR [rax+12], ecx

; 1058 :         /* size of section in file */
; 1059 :         shdr64.sh_size = curr->e.seginfo->num_relocs * sizeof( Elf64_Rela );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+64]
	imul	rax, rax, 24
	mov	QWORD PTR shdr64$[rsp+32], rax

; 1060 :         shdr64.sh_link = 1 + modinfo->g.num_segs + SYMTAB_IDX;

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	eax, DWORD PTR [rax+8]
	add	eax, 2
	mov	DWORD PTR shdr64$[rsp+40], eax

; 1061 :         /* set info to the src section index */
; 1062 :         shdr64.sh_info = GetSegIdx( curr->sym.segment );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	GetSegIdx
	mov	DWORD PTR shdr64$[rsp+44], eax

; 1063 :         shdr64.sh_addralign = 4;

	mov	QWORD PTR shdr64$[rsp+48], 4

; 1064 :         shdr64.sh_entsize = sizeof( Elf64_Rela );

	mov	QWORD PTR shdr64$[rsp+56], 24

; 1065 : 
; 1066 :         if ( fwrite( &shdr64, 1, sizeof( shdr64 ), CurrFile[OBJ] ) != sizeof( shdr64 ) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 64					; 00000040H
	mov	edx, 1
	lea	rcx, QWORD PTR shdr64$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 64					; 00000040H
	je	SHORT $LN26@elf_write_

; 1067 :             WriteError();

	call	WriteError
$LN26@elf_write_:

; 1068 : 
; 1069 :         fileoffset += shdr64.sh_size;

	mov	eax, DWORD PTR fileoffset$[rsp]
	add	rax, QWORD PTR shdr64$[rsp+32]
	mov	DWORD PTR fileoffset$[rsp], eax

; 1070 :         fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR fileoffset$[rsp]
	add	eax, 15
	and	eax, -16				; fffffff0H
	mov	DWORD PTR fileoffset$[rsp], eax

; 1071 :         DebugMsg(("elf_write_section_table64(%s): relocs, ofs=%" I64_SPEC "X size=%" I64_SPEC "X\n", curr->sym.name, shdr64.sh_offset, shdr64.sh_size));

	mov	r9, QWORD PTR shdr64$[rsp+32]
	mov	r8, QWORD PTR shdr64$[rsp+24]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11681
	call	DoDebugMsg

; 1072 :     }

	jmp	$LN8@elf_write_
$LN9@elf_write_:

; 1073 :     DebugMsg(("elf_write_section_table64: exit, final fileofs=%X\n", fileoffset ));

	mov	edx, DWORD PTR fileoffset$[rsp]
	lea	rcx, OFFSET FLAT:$SG11682
	call	DoDebugMsg

; 1074 :     return( NOT_ERROR );

	xor	eax, eax

; 1075 : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:elf_write_section_table64$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 192				; 000000c0H
	pop	rdi
	ret	0
elf_write_section_table64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
i$ = 48
curr$ = 56
p$ = 64
shdr32$ = 88
tv144 = 144
__$ArrayPad$ = 152
modinfo$ = 176
em$ = 184
fileoffset$ = 192
elf_write_section_table32 PROC

; 776  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 160				; 000000a0H
	mov	rdi, rsp
	mov	ecx, 40					; 00000028H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+176]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 777  :     int         i;
; 778  :     struct dsym *curr;
; 779  :     uint_8      *p;
; 780  :     //uint_32     fileoffset;
; 781  :     Elf32_Shdr  shdr32;
; 782  : 
; 783  :     DebugMsg(("elf_write_section_table32( fileofs=%X ): enter\n", fileoffset ));

	mov	edx, DWORD PTR fileoffset$[rsp]
	lea	rcx, OFFSET FLAT:$SG11607
	call	DoDebugMsg

; 784  : 
; 785  :     //fileoffset = sizeof(Elf64_Ehdr) + ehdr->e_shnum * ehdr->e_shentsize;
; 786  :     fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR fileoffset$[rsp]
	add	eax, 15
	and	eax, -16				; fffffff0H
	mov	DWORD PTR fileoffset$[rsp], eax

; 787  : 
; 788  :     /* set contents and size of internal .shstrtab section */
; 789  :     set_shstrtab_values( em );

	mov	rcx, QWORD PTR em$[rsp]
	call	set_shstrtab_values

; 790  : 
; 791  :     /* write the NULL entry */
; 792  :     memset( &shdr32, 0, sizeof( shdr32) );

	mov	r8d, 40					; 00000028H
	xor	edx, edx
	lea	rcx, QWORD PTR shdr32$[rsp]
	call	memset

; 793  :     if ( fwrite( &shdr32, 1, sizeof(shdr32), CurrFile[OBJ] ) != sizeof(shdr32) ) /* write the empty NULL entry */

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 40					; 00000028H
	mov	edx, 1
	lea	rcx, QWORD PTR shdr32$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 40					; 00000028H
	je	SHORT $LN11@elf_write_

; 794  :         WriteError();

	call	WriteError
$LN11@elf_write_:

; 795  : 
; 796  :     /* use p to scan strings (=section names) of .shstrtab */
; 797  :     p = (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR em$[rsp]
	mov	rax, QWORD PTR [rcx+rax+32]
	mov	QWORD PTR p$[rsp], rax

; 798  :     p++; /* skip 'name' of NULL entry */

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 799  : 
; 800  :     /* write the section headers defined in the module, */
; 801  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@elf_write_
$LN2@elf_write_:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@elf_write_:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN3@elf_write_

; 802  : 
; 803  :         memset( &shdr32, 0, sizeof(shdr32) );

	mov	r8d, 40					; 00000028H
	xor	edx, edx
	lea	rcx, QWORD PTR shdr32$[rsp]
	call	memset

; 804  : 
; 805  :         shdr32.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR em$[rsp]
	mov	rax, QWORD PTR [rcx+rax+32]
	mov	rcx, QWORD PTR p$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR shdr32$[rsp], eax

; 806  :         p += strlen( (char *)p ) + 1;

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR p$[rsp], rax

; 807  :         if ( curr->e.seginfo->info == TRUE ) { /* v2.07:added; v2.12: highest priority */

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN12@elf_write_

; 808  :             shdr32.sh_type = SHT_NOTE;

	mov	DWORD PTR shdr32$[rsp+4], 7

; 809  :             shdr32.sh_flags = 0;

	mov	DWORD PTR shdr32$[rsp+8], 0

; 810  :         } else {

	jmp	$LN13@elf_write_
$LN12@elf_write_:

; 811  :             shdr32.sh_type = ( curr->e.seginfo->segtype != SEGTYPE_BSS ? SHT_PROGBITS : SHT_NOBITS );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 3
	je	SHORT $LN28@elf_write_
	mov	DWORD PTR tv144[rsp], 1
	jmp	SHORT $LN29@elf_write_
$LN28@elf_write_:
	mov	DWORD PTR tv144[rsp], 8
$LN29@elf_write_:
	mov	eax, DWORD PTR tv144[rsp]
	mov	DWORD PTR shdr32$[rsp+4], eax

; 812  :             if ( curr->e.seginfo->segtype == SEGTYPE_CODE ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 1
	jne	SHORT $LN14@elf_write_

; 813  :                 shdr32.sh_flags = SHF_EXECINSTR | SHF_ALLOC;

	mov	DWORD PTR shdr32$[rsp+8], 6
	jmp	SHORT $LN15@elf_write_
$LN14@elf_write_:

; 814  :             } else if ( curr->e.seginfo->readonly == TRUE ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN16@elf_write_

; 815  :                 shdr32.sh_flags = SHF_ALLOC;

	mov	DWORD PTR shdr32$[rsp+8], 2
	jmp	SHORT $LN17@elf_write_
$LN16@elf_write_:

; 816  :             } else if ( curr->e.seginfo->clsym && strcmp( curr->e.seginfo->clsym->name, "CONST" ) == 0 ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN18@elf_write_
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+80]
	lea	rdx, OFFSET FLAT:$SG11617
	mov	rcx, QWORD PTR [rax+8]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN18@elf_write_

; 817  :                 shdr32.sh_flags = SHF_ALLOC; /* v2.07: added */

	mov	DWORD PTR shdr32$[rsp+8], 2

; 818  :             } else {

	jmp	SHORT $LN19@elf_write_
$LN18@elf_write_:

; 819  :                 shdr32.sh_flags = SHF_WRITE | SHF_ALLOC;

	mov	DWORD PTR shdr32$[rsp+8], 3
$LN19@elf_write_:
$LN17@elf_write_:
$LN15@elf_write_:
$LN13@elf_write_:

; 820  :             }
; 821  :         }
; 822  : #if 0
; 823  :         /* todo: translate values in field <characteristics> to
; 824  :          * elf section flags.
; 825  :          */
; 826  :         if ( curr->e.seginfo->characteristics == ??? ) {
; 827  :         }
; 828  : #endif
; 829  :         shdr32.sh_addr = 0;

	mov	DWORD PTR shdr32$[rsp+12], 0

; 830  :         /* v2.12: the sh_offset field holds the file position, even for SHT_NOBITS */
; 831  :         //if ( shdr32.sh_type != SHT_NOBITS ) {
; 832  :             shdr32.sh_offset = fileoffset; /* start of section in file */

	mov	eax, DWORD PTR fileoffset$[rsp]
	mov	DWORD PTR shdr32$[rsp+16], eax

; 833  :             curr->e.seginfo->fileoffset = fileoffset; /* save the offset in the segment */

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR fileoffset$[rsp]
	mov	DWORD PTR [rax+56], ecx

; 834  :         //}
; 835  :         /* v2.07: set size for all sections, including .bss */
; 836  :         shdr32.sh_size = curr->sym.max_offset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR shdr32$[rsp+20], eax

; 837  :         shdr32.sh_link = 0;

	mov	DWORD PTR shdr32$[rsp+24], 0

; 838  :         shdr32.sh_info = 0;

	mov	DWORD PTR shdr32$[rsp+28], 0

; 839  :         shdr32.sh_addralign = Get_Alignment( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	Get_Alignment
	mov	DWORD PTR shdr32$[rsp+32], eax

; 840  :         shdr32.sh_entsize = 0;

	mov	DWORD PTR shdr32$[rsp+36], 0

; 841  : 
; 842  :         if ( fwrite( &shdr32, 1, sizeof(shdr32), CurrFile[OBJ] ) != sizeof(shdr32) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 40					; 00000028H
	mov	edx, 1
	lea	rcx, QWORD PTR shdr32$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 40					; 00000028H
	je	SHORT $LN20@elf_write_

; 843  :             WriteError();

	call	WriteError
$LN20@elf_write_:

; 844  :         curr->e.seginfo->num_relocs = get_relocation_count( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	get_relocation_count
	mov	rcx, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+64], eax

; 845  : 
; 846  :         /* v2.12: don't adjust fileoffset for SHT_NOBITS sections.
; 847  :          * it didn't cause fatal damage previously, but made the
; 848  :          * object module unnecessary large.
; 849  :          */
; 850  :         if ( shdr32.sh_type != SHT_NOBITS ) {

	cmp	DWORD PTR shdr32$[rsp+4], 8
	je	SHORT $LN21@elf_write_

; 851  :             fileoffset += shdr32.sh_size;

	mov	eax, DWORD PTR shdr32$[rsp+20]
	mov	ecx, DWORD PTR fileoffset$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR fileoffset$[rsp], eax

; 852  :             fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR fileoffset$[rsp]
	add	eax, 15
	and	eax, -16				; fffffff0H
	mov	DWORD PTR fileoffset$[rsp], eax
$LN21@elf_write_:

; 853  :         }
; 854  : 
; 855  :         DebugMsg(("elf_write_section_table32(%s): ofs=%X size=%X numrelocs=%u\n", curr->sym.name, shdr32.sh_offset, shdr32.sh_size, curr->e.seginfo->num_relocs));

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR shdr32$[rsp+20]
	mov	r8d, DWORD PTR shdr32$[rsp+16]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11620
	call	DoDebugMsg

; 856  :     }

	jmp	$LN2@elf_write_
$LN3@elf_write_:

; 857  : 
; 858  :     /* set size and contents of .symtab and .strtab sections */
; 859  :     set_symtab_values( em );

	mov	rcx, QWORD PTR em$[rsp]
	call	set_symtab_values

; 860  : 
; 861  :     /* write headers of internal sections */
; 862  :     for ( i = 0; i < NUM_INTSEGS; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@elf_write_
$LN5@elf_write_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@elf_write_:
	cmp	DWORD PTR i$[rsp], 3
	jge	$LN6@elf_write_

; 863  :         shdr32.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR em$[rsp]
	mov	rax, QWORD PTR [rcx+rax+32]
	mov	rcx, QWORD PTR p$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR shdr32$[rsp], eax

; 864  :         p += strlen( (char *)p ) + 1;

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR p$[rsp], rax

; 865  :         shdr32.sh_type = internal_segparms[i].type;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:internal_segparms
	mov	eax, DWORD PTR [rcx+rax+8]
	mov	DWORD PTR shdr32$[rsp+4], eax

; 866  :         shdr32.sh_flags = 0;

	mov	DWORD PTR shdr32$[rsp+8], 0

; 867  :         shdr32.sh_offset = fileoffset; /* start of section in file */

	mov	eax, DWORD PTR fileoffset$[rsp]
	mov	DWORD PTR shdr32$[rsp+16], eax

; 868  :         em->internal_segs[i].fileoffset = fileoffset;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR em$[rsp]
	mov	edx, DWORD PTR fileoffset$[rsp]
	mov	DWORD PTR [rcx+rax+28], edx

; 869  :         shdr32.sh_size = em->internal_segs[i].size;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR em$[rsp]
	mov	eax, DWORD PTR [rcx+rax+24]
	mov	DWORD PTR shdr32$[rsp+20], eax

; 870  :         /* section .symtab is special */
; 871  :         if ( i == SYMTAB_IDX ) {

	cmp	DWORD PTR i$[rsp], 1
	jne	SHORT $LN22@elf_write_

; 872  :             shdr32.sh_link = 1 + modinfo->g.num_segs + STRTAB_IDX;

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	eax, DWORD PTR [rax+8]
	add	eax, 3
	mov	DWORD PTR shdr32$[rsp+24], eax

; 873  :             shdr32.sh_info = em->start_globals;

	mov	rax, QWORD PTR em$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR shdr32$[rsp+28], eax

; 874  :             shdr32.sh_addralign = 4;

	mov	DWORD PTR shdr32$[rsp+32], 4

; 875  :             shdr32.sh_entsize = sizeof( Elf32_Sym );

	mov	DWORD PTR shdr32$[rsp+36], 16

; 876  :         } else {

	jmp	SHORT $LN23@elf_write_
$LN22@elf_write_:

; 877  :             shdr32.sh_link = 0;

	mov	DWORD PTR shdr32$[rsp+24], 0

; 878  :             shdr32.sh_info = 0;

	mov	DWORD PTR shdr32$[rsp+28], 0

; 879  :             shdr32.sh_addralign = 1;

	mov	DWORD PTR shdr32$[rsp+32], 1

; 880  :             shdr32.sh_entsize = 0;

	mov	DWORD PTR shdr32$[rsp+36], 0
$LN23@elf_write_:

; 881  :         }
; 882  :         if ( fwrite( &shdr32, 1, sizeof( shdr32 ), CurrFile[OBJ] ) != sizeof( shdr32 ) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 40					; 00000028H
	mov	edx, 1
	lea	rcx, QWORD PTR shdr32$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 40					; 00000028H
	je	SHORT $LN24@elf_write_

; 883  :             WriteError();

	call	WriteError
$LN24@elf_write_:

; 884  : 
; 885  :         fileoffset += shdr32.sh_size;

	mov	eax, DWORD PTR shdr32$[rsp+20]
	mov	ecx, DWORD PTR fileoffset$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR fileoffset$[rsp], eax

; 886  :         fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR fileoffset$[rsp]
	add	eax, 15
	and	eax, -16				; fffffff0H
	mov	DWORD PTR fileoffset$[rsp], eax

; 887  :         DebugMsg(("elf_write_section_table32(%s): ofs=%X size=%X\n", internal_segparms[i].name, shdr32.sh_offset, shdr32.sh_size));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:internal_segparms
	mov	r9d, DWORD PTR shdr32$[rsp+20]
	mov	r8d, DWORD PTR shdr32$[rsp+16]
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG11624
	call	DoDebugMsg

; 888  :     }

	jmp	$LN5@elf_write_
$LN6@elf_write_:

; 889  : 
; 890  :     /* write headers of reloc sections */
; 891  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN10@elf_write_
$LN8@elf_write_:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN10@elf_write_:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN9@elf_write_

; 892  :         if ( curr->e.seginfo->FixupList.head == NULL )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+40], 0
	jne	SHORT $LN25@elf_write_

; 893  :             continue;

	jmp	SHORT $LN8@elf_write_
$LN25@elf_write_:

; 894  : 
; 895  :         memset( &shdr32, 0, sizeof( shdr32 ) );

	mov	r8d, 40					; 00000028H
	xor	edx, edx
	lea	rcx, QWORD PTR shdr32$[rsp]
	call	memset

; 896  : 
; 897  :         shdr32.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR em$[rsp]
	mov	rax, QWORD PTR [rcx+rax+32]
	mov	rcx, QWORD PTR p$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR shdr32$[rsp], eax

; 898  :         p += strlen( (char *)p ) + 1;

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR p$[rsp], rax

; 899  :         shdr32.sh_type = SHT_REL;

	mov	DWORD PTR shdr32$[rsp+4], 9

; 900  :         shdr32.sh_flags = 0;

	mov	DWORD PTR shdr32$[rsp+8], 0

; 901  :         shdr32.sh_addr = 0;

	mov	DWORD PTR shdr32$[rsp+12], 0

; 902  :         shdr32.sh_offset = fileoffset; /* start of section in file */

	mov	eax, DWORD PTR fileoffset$[rsp]
	mov	DWORD PTR shdr32$[rsp+16], eax

; 903  :         /* save the file offset in the slot reserved for ELF relocs */
; 904  :         curr->e.seginfo->reloc_offset = fileoffset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR fileoffset$[rsp]
	mov	DWORD PTR [rax+12], ecx

; 905  :         /* size of section in file */
; 906  :         shdr32.sh_size = curr->e.seginfo->num_relocs * sizeof( Elf32_Rel );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	eax, DWORD PTR [rax+64]
	shl	rax, 3
	mov	DWORD PTR shdr32$[rsp+20], eax

; 907  :         shdr32.sh_link = 1 + modinfo->g.num_segs + SYMTAB_IDX;

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	eax, DWORD PTR [rax+8]
	add	eax, 2
	mov	DWORD PTR shdr32$[rsp+24], eax

; 908  :         /* set info to the src section index */
; 909  :         shdr32.sh_info = GetSegIdx( curr->sym.segment );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	GetSegIdx
	mov	DWORD PTR shdr32$[rsp+28], eax

; 910  :         shdr32.sh_addralign = 4;

	mov	DWORD PTR shdr32$[rsp+32], 4

; 911  :         shdr32.sh_entsize = sizeof( Elf32_Rel );

	mov	DWORD PTR shdr32$[rsp+36], 8

; 912  : 
; 913  :         if ( fwrite( &shdr32, 1, sizeof( shdr32 ), CurrFile[OBJ] ) != sizeof( shdr32 ) )

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 40					; 00000028H
	mov	edx, 1
	lea	rcx, QWORD PTR shdr32$[rsp]
	call	QWORD PTR __imp_fwrite
	cmp	rax, 40					; 00000028H
	je	SHORT $LN26@elf_write_

; 914  :             WriteError();

	call	WriteError
$LN26@elf_write_:

; 915  : 
; 916  :         fileoffset += shdr32.sh_size;

	mov	eax, DWORD PTR shdr32$[rsp+20]
	mov	ecx, DWORD PTR fileoffset$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR fileoffset$[rsp], eax

; 917  :         fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR fileoffset$[rsp]
	add	eax, 15
	and	eax, -16				; fffffff0H
	mov	DWORD PTR fileoffset$[rsp], eax

; 918  :         DebugMsg(("elf_write_section_table32(%s): relocs, ofs=%X size=%X\n", curr->sym.name, shdr32.sh_offset, shdr32.sh_size));

	mov	r9d, DWORD PTR shdr32$[rsp+20]
	mov	r8d, DWORD PTR shdr32$[rsp+16]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11627
	call	DoDebugMsg

; 919  : 
; 920  :     }

	jmp	$LN8@elf_write_
$LN9@elf_write_:

; 921  :     DebugMsg(("elf_write_section_table32: exit, final fileofs=%X\n", fileoffset ));

	mov	edx, DWORD PTR fileoffset$[rsp]
	lea	rcx, OFFSET FLAT:$SG11628
	call	DoDebugMsg

; 922  :     return( NOT_ERROR );

	xor	eax, eax

; 923  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:elf_write_section_table32$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
elf_write_section_table32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
tv78 = 0
curr$ = 32
Get_Alignment PROC

; 760  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 761  :     if ( curr->e.seginfo->alignment == MAX_SEGALIGNMENT )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN2@Get_Alignm

; 762  :         return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@Get_Alignm
$LN2@Get_Alignm:

; 763  :     return( 1 << curr->e.seginfo->alignment );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+106]
	mov	ecx, 1
	mov	DWORD PTR tv78[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv78[rsp]
	shl	eax, cl
$LN1@Get_Alignm:

; 764  : }

	add	rsp, 16
	pop	rdi
	ret	0
Get_Alignment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
relocs$ = 0
fix$ = 8
curr$ = 32
get_relocation_count PROC

; 749  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 750  :     unsigned relocs;
; 751  :     struct fixup *fix;
; 752  : 
; 753  :     for ( relocs = 0, fix = curr->e.seginfo->FixupList.head; fix ; fix = fix->nextrlc, relocs++ );

	mov	DWORD PTR relocs$[rsp], 0
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR fix$[rsp], rax
	jmp	SHORT $LN4@get_reloca
$LN2@get_reloca:
	mov	rax, QWORD PTR fix$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR fix$[rsp], rax
	mov	eax, DWORD PTR relocs$[rsp]
	inc	eax
	mov	DWORD PTR relocs$[rsp], eax
$LN4@get_reloca:
	cmp	QWORD PTR fix$[rsp], 0
	je	SHORT $LN3@get_reloca
	jmp	SHORT $LN2@get_reloca
$LN3@get_reloca:

; 754  : 
; 755  :     return( relocs );

	mov	eax, DWORD PTR relocs$[rsp]

; 756  : }

	add	rsp, 16
	pop	rdi
	ret	0
get_relocation_count ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
i$ = 32
curr$ = 40
p$ = 48
size$ = 56
buffer$ = 80
tv78 = 352
tv92 = 360
tv172 = 368
tv201 = 376
tv216 = 384
tv232 = 392
__$ArrayPad$ = 400
em$ = 432
set_shstrtab_values PROC

; 686  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 416				; 000001a0H
	mov	rdi, rsp
	mov	ecx, 104				; 00000068H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+432]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 687  :     int         i;
; 688  :     struct dsym *curr;
; 689  :     char        *p;
; 690  :     unsigned int size = 1; /* the first byte at offset 0 is the NULL section name */

	mov	DWORD PTR size$[rsp], 1

; 691  :     char buffer[MAX_ID_LEN+1];
; 692  : 
; 693  :     /* get size of section names defined in the program & relocation sections ) */
; 694  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@set_shstrt
$LN2@set_shstrt:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@set_shstrt:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN3@set_shstrt

; 695  :         /* v2.07: ALIAS name defined? */
; 696  :         p = ( curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ElfConvertSectionName( &curr->sym, buffer ) );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN20@set_shstrt
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR tv78[rsp], rax
	jmp	SHORT $LN21@set_shstrt
$LN20@set_shstrt:
	mov	rax, QWORD PTR curr$[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rax
	call	ElfConvertSectionName
	mov	QWORD PTR tv78[rsp], rax
$LN21@set_shstrt:
	mov	rax, QWORD PTR tv78[rsp]
	mov	QWORD PTR p$[rsp], rax

; 697  :         size += strlen( p ) + 1;

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	ecx, DWORD PTR size$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	DWORD PTR size$[rsp], eax

; 698  :         if ( curr->e.seginfo->FixupList.head )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN17@set_shstrt

; 699  :             size += strlen( p ) +

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN22@set_shstrt
	mov	QWORD PTR tv92[rsp], 6
	jmp	SHORT $LN23@set_shstrt
$LN22@set_shstrt:
	mov	QWORD PTR tv92[rsp], 5
$LN23@set_shstrt:
	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	add	rax, QWORD PTR tv92[rsp]
	mov	ecx, DWORD PTR size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR size$[rsp], eax
$LN17@set_shstrt:

; 700  : #if AMD64_SUPPORT
; 701  :                 (( ModuleInfo.defOfssize == USE64 ) ? sizeof(".rela") : sizeof(".rel"));
; 702  : #else
; 703  :                 sizeof(".rel");
; 704  : #endif
; 705  :     }

	jmp	$LN2@set_shstrt
$LN3@set_shstrt:

; 706  :     /* get internal section name sizes */
; 707  :     for ( i = 0; i < NUM_INTSEGS; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@set_shstrt
$LN5@set_shstrt:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@set_shstrt:
	cmp	DWORD PTR i$[rsp], 3
	jge	SHORT $LN6@set_shstrt

; 708  :         size += strlen( internal_segparms[i].name ) + 1;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:internal_segparms
	mov	rcx, QWORD PTR [rcx+rax]
	call	strlen
	mov	ecx, DWORD PTR size$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	DWORD PTR size$[rsp], eax

; 709  :     }

	jmp	SHORT $LN5@set_shstrt
$LN6@set_shstrt:

; 710  : 
; 711  :     em->internal_segs[SHSTRTAB_IDX].size = size;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR em$[rsp]
	mov	edx, DWORD PTR size$[rsp]
	mov	DWORD PTR [rcx+rax+24], edx

; 712  : 
; 713  :     /* size is known, now alloc .shstrtab data buffer and fill it */
; 714  : 
; 715  :     em->internal_segs[SHSTRTAB_IDX].data = LclAlloc( size );

	mov	eax, DWORD PTR size$[rsp]
	mov	ecx, eax
	call	LclAlloc
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR em$[rsp]
	mov	QWORD PTR [rdx+rcx+32], rax

; 716  :     p = (char *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR em$[rsp]
	mov	rax, QWORD PTR [rcx+rax+32]
	mov	QWORD PTR p$[rsp], rax

; 717  :     *p++ = NULLC; /* NULL section name */

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 718  : 
; 719  :     /* 1. names of program sections */
; 720  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN10@set_shstrt
$LN8@set_shstrt:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN10@set_shstrt:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN9@set_shstrt

; 721  :         strcpy( p, curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ElfConvertSectionName( &curr->sym, buffer ) );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN24@set_shstrt
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR tv172[rsp], rax
	jmp	SHORT $LN25@set_shstrt
$LN24@set_shstrt:
	mov	rax, QWORD PTR curr$[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rax
	call	ElfConvertSectionName
	mov	QWORD PTR tv172[rsp], rax
$LN25@set_shstrt:
	mov	rdx, QWORD PTR tv172[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	strcpy

; 722  :         p += strlen( p ) + 1;

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR p$[rsp], rax

; 723  :     }

	jmp	$LN8@set_shstrt
$LN9@set_shstrt:

; 724  :     /* 2. names of internal sections */
; 725  :     for ( i = 0; i < NUM_INTSEGS; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN13@set_shstrt
$LN11@set_shstrt:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN13@set_shstrt:
	cmp	DWORD PTR i$[rsp], 3
	jge	SHORT $LN12@set_shstrt

; 726  :         strcpy( p, internal_segparms[i].name );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:internal_segparms
	mov	rdx, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR p$[rsp]
	call	strcpy

; 727  :         p += strlen( p ) + 1;

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR p$[rsp], rax

; 728  :     }

	jmp	SHORT $LN11@set_shstrt
$LN12@set_shstrt:

; 729  :     /* 3. names of "relocation" sections */
; 730  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN16@set_shstrt
$LN14@set_shstrt:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN16@set_shstrt:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN15@set_shstrt

; 731  :         if ( curr->e.seginfo->FixupList.head ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+40], 0
	je	$LN18@set_shstrt

; 732  : #if AMD64_SUPPORT
; 733  :             strcpy( p, (( ModuleInfo.defOfssize == USE64 ) ? ".rela": ".rel") );

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN26@set_shstrt
	lea	rax, OFFSET FLAT:$SG11557
	mov	QWORD PTR tv201[rsp], rax
	jmp	SHORT $LN27@set_shstrt
$LN26@set_shstrt:
	lea	rax, OFFSET FLAT:$SG11558
	mov	QWORD PTR tv201[rsp], rax
$LN27@set_shstrt:
	mov	rdx, QWORD PTR tv201[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	strcpy

; 734  : #else
; 735  :             strcpy( p, ".rel" );
; 736  : #endif
; 737  :             p += strlen( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 738  :             strcpy( p, curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ElfConvertSectionName( &curr->sym, buffer ) );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+96], 0
	je	SHORT $LN28@set_shstrt
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR tv216[rsp], rax
	jmp	SHORT $LN29@set_shstrt
$LN28@set_shstrt:
	mov	rax, QWORD PTR curr$[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rax
	call	ElfConvertSectionName
	mov	QWORD PTR tv216[rsp], rax
$LN29@set_shstrt:
	mov	rdx, QWORD PTR tv216[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	strcpy

; 739  :             p += strlen( p ) + 1;

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR p$[rsp], rax
$LN18@set_shstrt:

; 740  :         }
; 741  :     }

	jmp	$LN14@set_shstrt
$LN15@set_shstrt:

; 742  :     /**/myassert( size == p - (char *)em->internal_segs[SHSTRTAB_IDX].data );

	mov	eax, DWORD PTR size$[rsp]
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR em$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+32]
	mov	rdx, QWORD PTR p$[rsp]
	sub	rdx, rcx
	mov	rcx, rdx
	cmp	rax, rcx
	jne	SHORT $LN30@set_shstrt
	mov	DWORD PTR tv232[rsp], 0
	jmp	SHORT $LN31@set_shstrt
$LN30@set_shstrt:
	mov	edx, 742				; 000002e6H
	lea	rcx, OFFSET FLAT:$SG11559
	call	InternalError
	mov	DWORD PTR tv232[rsp], eax
$LN31@set_shstrt:

; 743  :     DebugMsg(("set_shstrtab_values: size=%X\n", size));

	mov	edx, DWORD PTR size$[rsp]
	lea	rcx, OFFSET FLAT:$SG11560
	call	DoDebugMsg

; 744  :     return;
; 745  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:set_shstrtab_values$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 416				; 000001a0H
	pop	rdi
	ret	0
set_shstrtab_values ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
strsize$ = 32
entries$ = 36
curr$ = 40
q$ = 48
p2$ = 56
locals$ = 72
localscurr$ = 104
fix$4 = 112
em$ = 144
set_symtab_values PROC

; 540  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rdi, rsp
	mov	ecx, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+144]

; 541  :     uint_32 strsize;
; 542  :     uint_32 entries;
; 543  :     struct dsym *curr;
; 544  :     //struct asym *sym;
; 545  :     struct qnode *q;
; 546  :     char *p2;
; 547  :     struct {
; 548  :         struct localname *head;
; 549  :         struct localname *tail;
; 550  :     } locals = { NULL, NULL };

	mov	QWORD PTR locals$[rsp], 0
	mov	QWORD PTR locals$[rsp+8], 0

; 551  :     struct localname *localscurr;
; 552  : 
; 553  :     /* symbol table. there is
; 554  :      - 1 NULL entry,
; 555  :      - 1 entry for the module/file,
; 556  :      - 1 entry for each section and
; 557  :      - n entries for local symbols
; 558  :      - m entries for global symbols
; 559  :      */
; 560  : 
; 561  :     /* symbol table starts with 1 NULL entry + 1 file entry */
; 562  :     em->symindex = 1 + 1;

	mov	rax, QWORD PTR em$[rsp]
	mov	DWORD PTR [rax], 2

; 563  : 
; 564  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next )

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@set_symtab
$LN2@set_symtab:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@set_symtab:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@set_symtab

; 565  :         curr->sym.ext_idx = em->symindex++;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR em$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+88], ecx
	mov	rax, QWORD PTR em$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR em$[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN2@set_symtab
$LN3@set_symtab:

; 566  : 
; 567  :     /* add local symbols to symbol table */
; 568  : 
; 569  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN7@set_symtab
$LN5@set_symtab:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN7@set_symtab:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN6@set_symtab

; 570  :         if ( curr->e.seginfo->num_relocs ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+64], 0
	je	$LN26@set_symtab

; 571  :             struct fixup *fix = curr->e.seginfo->FixupList.head;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR fix$4[rsp], rax

; 572  :             for ( ; fix; fix = fix->nextrlc ) {

	jmp	SHORT $LN10@set_symtab
$LN8@set_symtab:
	mov	rax, QWORD PTR fix$4[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR fix$4[rsp], rax
$LN10@set_symtab:
	cmp	QWORD PTR fix$4[rsp], 0
	je	$LN9@set_symtab

; 573  :                 /* if it's not EXTERNAL/PUBLIC, add symbol. */
; 574  :                 /* however, if it's an assembly time variable */
; 575  :                 /* use a raw section reference */
; 576  :                 if ( fix->sym->variable ) {

	mov	rax, QWORD PTR fix$4[rsp]
	mov	rax, QWORD PTR [rax+56]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN27@set_symtab

; 577  :                     fix->sym = fix->segment_var;

	mov	rax, QWORD PTR fix$4[rsp]
	mov	rcx, QWORD PTR fix$4[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	mov	QWORD PTR [rax+56], rcx

; 578  :                 } else if ( ( fix->sym->state == SYM_INTERNAL ) &&

	jmp	$LN28@set_symtab
$LN27@set_symtab:

; 579  :                     fix->sym->included == FALSE &&

	mov	rax, QWORD PTR fix$4[rsp]
	mov	rax, QWORD PTR [rax+56]
	cmp	DWORD PTR [rax+32], 1
	jne	$LN29@set_symtab
	mov	rax, QWORD PTR fix$4[rsp]
	mov	rax, QWORD PTR [rax+56]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	$LN29@set_symtab
	mov	rax, QWORD PTR fix$4[rsp]
	mov	rax, QWORD PTR [rax+56]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	$LN29@set_symtab

; 580  :                     fix->sym->ispublic == FALSE ) {
; 581  :                     fix->sym->included = TRUE;

	mov	rax, QWORD PTR fix$4[rsp]
	mov	rax, QWORD PTR [rax+56]
	movzx	eax, BYTE PTR [rax+41]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR fix$4[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	BYTE PTR [rcx+41], al

; 582  :                     localscurr = LclAlloc( sizeof( struct localname ) );

	mov	ecx, 16
	call	LclAlloc
	mov	QWORD PTR localscurr$[rsp], rax

; 583  :                     localscurr->next = NULL;

	mov	rax, QWORD PTR localscurr$[rsp]
	mov	QWORD PTR [rax], 0

; 584  :                     localscurr->sym = fix->sym;

	mov	rax, QWORD PTR localscurr$[rsp]
	mov	rcx, QWORD PTR fix$4[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rax+8], rcx

; 585  :                     if (locals.tail) {

	cmp	QWORD PTR locals$[rsp+8], 0
	je	SHORT $LN30@set_symtab

; 586  :                         locals.tail->next = localscurr;

	mov	rax, QWORD PTR locals$[rsp+8]
	mov	rcx, QWORD PTR localscurr$[rsp]
	mov	QWORD PTR [rax], rcx

; 587  :                         locals.tail = localscurr;

	mov	rax, QWORD PTR localscurr$[rsp]
	mov	QWORD PTR locals$[rsp+8], rax

; 588  :                     } else {

	jmp	SHORT $LN31@set_symtab
$LN30@set_symtab:

; 589  :                         locals.head = locals.tail = localscurr;

	mov	rax, QWORD PTR localscurr$[rsp]
	mov	QWORD PTR locals$[rsp+8], rax
	mov	rax, QWORD PTR locals$[rsp+8]
	mov	QWORD PTR locals$[rsp], rax
$LN31@set_symtab:

; 590  :                     }
; 591  :                     fix->sym->ext_idx = em->symindex++;

	mov	rax, QWORD PTR fix$4[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR em$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+88], ecx
	mov	rax, QWORD PTR em$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR em$[rsp]
	mov	DWORD PTR [rcx], eax
$LN29@set_symtab:
$LN28@set_symtab:

; 592  :                 }
; 593  :             }

	jmp	$LN8@set_symtab
$LN9@set_symtab:
$LN26@set_symtab:

; 594  :         }
; 595  :     }

	jmp	$LN5@set_symtab
$LN6@set_symtab:

; 596  :     DebugMsg(("set_symtab_values: index after sections: %u\n", em->symindex));

	mov	rax, QWORD PTR em$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11519
	call	DoDebugMsg

; 597  :     em->start_globals = em->symindex;

	mov	rax, QWORD PTR em$[rsp]
	mov	rcx, QWORD PTR em$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+4], ecx

; 598  : 
; 599  :     /* count EXTERNs and used EXTERNDEFs (and PROTOs [since v2.01]) */
; 600  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN13@set_symtab
$LN11@set_symtab:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN13@set_symtab:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN12@set_symtab

; 601  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN32@set_symtab
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN32@set_symtab

; 602  :             continue;

	jmp	SHORT $LN11@set_symtab
$LN32@set_symtab:

; 603  :         curr->sym.ext_idx = em->symindex++;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR em$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+88], ecx
	mov	rax, QWORD PTR em$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR em$[rsp]
	mov	DWORD PTR [rcx], eax

; 604  :     }

	jmp	SHORT $LN11@set_symtab
$LN12@set_symtab:

; 605  :     DebugMsg(("set_symtab_values: index after EXTERNALs: %u\n", em->symindex));

	mov	rax, QWORD PTR em$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11521
	call	DoDebugMsg

; 606  : 
; 607  : #if ELFALIAS
; 608  :     /* count aliases */
; 609  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {
; 610  :         curr->sym.idx = em->symindex++;
; 611  :     }
; 612  :     DebugMsg(("set_symtab_values: index after ALIASES: %u\n", em->symindex));
; 613  : #endif
; 614  : 
; 615  :     /* count publics */
; 616  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo+16
	mov	QWORD PTR q$[rsp], rax
	jmp	SHORT $LN16@set_symtab
$LN14@set_symtab:
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$[rsp], rax
$LN16@set_symtab:
	cmp	QWORD PTR q$[rsp], 0
	je	SHORT $LN15@set_symtab

; 617  :         q->sym->ext_idx = em->symindex++;

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR em$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+88], ecx
	mov	rax, QWORD PTR em$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR em$[rsp]
	mov	DWORD PTR [rcx], eax

; 618  :     }

	jmp	SHORT $LN14@set_symtab
$LN15@set_symtab:

; 619  :     DebugMsg(("set_symtab_values: index after PUBLICs: %u\n", em->symindex));

	mov	rax, QWORD PTR em$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11522
	call	DoDebugMsg

; 620  : 
; 621  :     /* size of symbol table is defined */
; 622  :     entries = em->symindex;

	mov	rax, QWORD PTR em$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR entries$[rsp], eax

; 623  : 
; 624  : #if ADDSTARTLABEL
; 625  :     if ( ModuleInfo.g.start_label )
; 626  :         entries++;
; 627  : #endif
; 628  : 
; 629  : #if AMD64_SUPPORT
; 630  :     if ( ModuleInfo.defOfssize == USE64 )

	movzx	eax, BYTE PTR ModuleInfo+405
	cmp	eax, 2
	jne	SHORT $LN33@set_symtab

; 631  :         strsize = set_symtab64( em, entries, locals.head );

	mov	r8, QWORD PTR locals$[rsp]
	mov	edx, DWORD PTR entries$[rsp]
	mov	rcx, QWORD PTR em$[rsp]
	call	set_symtab64
	mov	DWORD PTR strsize$[rsp], eax
	jmp	SHORT $LN34@set_symtab
$LN33@set_symtab:

; 632  :     else
; 633  : #endif
; 634  :         strsize = set_symtab32( em, entries, locals.head );

	mov	r8, QWORD PTR locals$[rsp]
	mov	edx, DWORD PTR entries$[rsp]
	mov	rcx, QWORD PTR em$[rsp]
	call	set_symtab32
	mov	DWORD PTR strsize$[rsp], eax
$LN34@set_symtab:

; 635  : 
; 636  :     /* generate the string table */
; 637  :     DebugMsg(("set_symtab_values: creating string table, size=%X\n", strsize));

	mov	edx, DWORD PTR strsize$[rsp]
	lea	rcx, OFFSET FLAT:$SG11525
	call	DoDebugMsg

; 638  : 
; 639  :     em->internal_segs[STRTAB_IDX].size = strsize;

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR em$[rsp]
	mov	edx, DWORD PTR strsize$[rsp]
	mov	DWORD PTR [rcx+rax+24], edx

; 640  :     em->internal_segs[STRTAB_IDX].data = LclAlloc( strsize );

	mov	eax, DWORD PTR strsize$[rsp]
	mov	ecx, eax
	call	LclAlloc
	mov	ecx, 16
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR em$[rsp]
	mov	QWORD PTR [rdx+rcx+32], rax

; 641  :     memset( em->internal_segs[STRTAB_IDX].data, 0, strsize );

	mov	eax, DWORD PTR strsize$[rsp]
	mov	ecx, 16
	imul	rcx, rcx, 2
	mov	r8d, eax
	xor	edx, edx
	mov	rax, QWORD PTR em$[rsp]
	mov	rcx, QWORD PTR [rax+rcx+32]
	call	memset

; 642  :     p2 = em->internal_segs[STRTAB_IDX].data;

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR em$[rsp]
	mov	rax, QWORD PTR [rcx+rax+32]
	mov	QWORD PTR p2$[rsp], rax

; 643  :     *p2++ = NULLC;

	mov	rax, QWORD PTR p2$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR p2$[rsp]
	inc	rax
	mov	QWORD PTR p2$[rsp], rax

; 644  : 
; 645  :     strcpy( p2, em->srcname );

	mov	rax, QWORD PTR em$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR p2$[rsp]
	call	strcpy

; 646  :     p2 += strlen( p2 ) + 1;

	mov	rcx, QWORD PTR p2$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p2$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR p2$[rsp], rax

; 647  : 
; 648  :     for ( localscurr = locals.head ; localscurr ; localscurr = localscurr->next ) {

	mov	rax, QWORD PTR locals$[rsp]
	mov	QWORD PTR localscurr$[rsp], rax
	jmp	SHORT $LN19@set_symtab
$LN17@set_symtab:
	mov	rax, QWORD PTR localscurr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR localscurr$[rsp], rax
$LN19@set_symtab:
	cmp	QWORD PTR localscurr$[rsp], 0
	je	SHORT $LN18@set_symtab

; 649  :         p2 += Mangle( localscurr->sym, p2 ) + 1;

	mov	rdx, QWORD PTR p2$[rsp]
	mov	rax, QWORD PTR localscurr$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	Mangle
	inc	eax
	cdqe
	mov	rcx, QWORD PTR p2$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p2$[rsp], rax

; 650  :     }

	jmp	SHORT $LN17@set_symtab
$LN18@set_symtab:

; 651  : 
; 652  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN22@set_symtab
$LN20@set_symtab:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN22@set_symtab:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN21@set_symtab

; 653  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN35@set_symtab
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN35@set_symtab

; 654  :             continue;

	jmp	SHORT $LN20@set_symtab
$LN35@set_symtab:

; 655  :         p2 += Mangle( &curr->sym, p2 ) + 1;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR p2$[rsp]
	mov	rcx, rax
	call	Mangle
	inc	eax
	cdqe
	mov	rcx, QWORD PTR p2$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p2$[rsp], rax

; 656  :     }

	jmp	SHORT $LN20@set_symtab
$LN21@set_symtab:

; 657  : 
; 658  : #if ELFALIAS
; 659  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {
; 660  :         p2 += Mangle( &curr->sym, p2 ) + 1;
; 661  :     }
; 662  : #endif
; 663  : 
; 664  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo+16
	mov	QWORD PTR q$[rsp], rax
	jmp	SHORT $LN25@set_symtab
$LN23@set_symtab:
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$[rsp], rax
$LN25@set_symtab:
	cmp	QWORD PTR q$[rsp], 0
	je	SHORT $LN24@set_symtab

; 665  :         p2 += Mangle( q->sym, p2 ) + 1;

	mov	rdx, QWORD PTR p2$[rsp]
	mov	rax, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	Mangle
	inc	eax
	cdqe
	mov	rcx, QWORD PTR p2$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p2$[rsp], rax

; 666  :     }

	jmp	SHORT $LN23@set_symtab
$LN24@set_symtab:

; 667  : #if ADDSTARTLABEL
; 668  :     if ( ModuleInfo.g.start_label ) {
; 669  :         Mangle( ModuleInfo.g.start_label, p2 );
; 670  :     }
; 671  : #endif
; 672  :     DebugMsg(("set_symtab_values: exit, symindex=%u\n", em->symindex ));

	mov	rax, QWORD PTR em$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG11527
	call	DoDebugMsg

; 673  :     return;
; 674  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:set_symtab_values$rtcFrameData
	call	_RTC_CheckStackVars
	add	rsp, 128				; 00000080H
	pop	rdi
	ret	0
set_symtab_values ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
strsize$ = 48
len$ = 52
stt$ = 56
curr$ = 64
sym$ = 72
localscurr$ = 80
q$ = 88
p64$ = 96
buffer$ = 128
tv229 = 400
__$ArrayPad$ = 408
em$ = 432
entries$ = 440
localshead$ = 448
set_symtab64 PROC

; 366  : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 416				; 000001a0H
	mov	rdi, rsp
	mov	ecx, 104				; 00000068H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+432]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 367  :     uint_32   strsize = 1;

	mov	DWORD PTR strsize$[rsp], 1

; 368  :     uint_32   len;
; 369  :     uint_8    stt;
; 370  :     struct dsym   *curr;
; 371  :     struct asym   *sym;
; 372  :     struct localname *localscurr;
; 373  :     struct qnode  *q;
; 374  :     Elf64_Sym *p64;
; 375  :     char      buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 376  : 
; 377  :     em->internal_segs[SYMTAB_IDX].size = entries * sizeof( Elf64_Sym );

	mov	eax, DWORD PTR entries$[rsp]
	imul	rax, rax, 24
	mov	ecx, 16
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR em$[rsp]
	mov	DWORD PTR [rdx+rcx+24], eax

; 378  :     em->internal_segs[SYMTAB_IDX].data = LclAlloc( em->internal_segs[SYMTAB_IDX].size );

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR em$[rsp]
	mov	eax, DWORD PTR [rcx+rax+24]
	mov	ecx, eax
	call	LclAlloc
	mov	ecx, 16
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR em$[rsp]
	mov	QWORD PTR [rdx+rcx+32], rax

; 379  :     memset( em->internal_segs[SYMTAB_IDX].data, 0, em->internal_segs[SYMTAB_IDX].size );

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR em$[rsp]
	mov	eax, DWORD PTR [rcx+rax+24]
	mov	ecx, 16
	imul	rcx, rcx, 1
	mov	r8d, eax
	xor	edx, edx
	mov	rax, QWORD PTR em$[rsp]
	mov	rcx, QWORD PTR [rax+rcx+32]
	call	memset

; 380  : 
; 381  :     p64 = (Elf64_Sym *)em->internal_segs[SYMTAB_IDX].data;

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR em$[rsp]
	mov	rax, QWORD PTR [rcx+rax+32]
	mov	QWORD PTR p64$[rsp], rax

; 382  : 
; 383  :     p64++; /* skip NULL entry */

	mov	rax, QWORD PTR p64$[rsp]
	add	rax, 24
	mov	QWORD PTR p64$[rsp], rax

; 384  : 
; 385  :     /* 1. make file entry */
; 386  :     p64->st_name = strsize;  /* symbol's name in string table */

	mov	rax, QWORD PTR p64$[rsp]
	mov	ecx, DWORD PTR strsize$[rsp]
	mov	DWORD PTR [rax], ecx

; 387  :     strsize += strlen( em->srcname ) + 1;

	mov	rax, QWORD PTR em$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	strlen
	mov	ecx, DWORD PTR strsize$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	DWORD PTR strsize$[rsp], eax

; 388  :     p64->st_value = 0;

	mov	rax, QWORD PTR p64$[rsp]
	mov	QWORD PTR [rax+8], 0

; 389  :     p64->st_size = 0;

	mov	rax, QWORD PTR p64$[rsp]
	mov	QWORD PTR [rax+16], 0

; 390  :     p64->st_info = ELF64_ST_INFO( STB_LOCAL, STT_FILE ); /* symbol's type and binding info */

	mov	rax, QWORD PTR p64$[rsp]
	mov	BYTE PTR [rax+4], 4

; 391  :     p64->st_shndx = SHN_ABS; /* section index */

	mov	eax, 65521				; 0000fff1H
	mov	rcx, QWORD PTR p64$[rsp]
	mov	WORD PTR [rcx+6], ax

; 392  :     p64++;

	mov	rax, QWORD PTR p64$[rsp]
	add	rax, 24
	mov	QWORD PTR p64$[rsp], rax

; 393  : 
; 394  :     /* 2. make section entries */
; 395  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@set_symtab
$LN2@set_symtab:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@set_symtab:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@set_symtab

; 396  :         //p64->st_name = ?;  /* name isn't set */
; 397  :         p64->st_info = ELF64_ST_INFO( STB_LOCAL, STT_SECTION );

	mov	rax, QWORD PTR p64$[rsp]
	mov	BYTE PTR [rax+4], 3

; 398  :         p64->st_shndx = GetSegIdx( curr->sym.segment );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	GetSegIdx
	mov	rcx, QWORD PTR p64$[rsp]
	mov	WORD PTR [rcx+6], ax

; 399  :         p64++;

	mov	rax, QWORD PTR p64$[rsp]
	add	rax, 24
	mov	QWORD PTR p64$[rsp], rax

; 400  :     }

	jmp	SHORT $LN2@set_symtab
$LN3@set_symtab:

; 401  : 
; 402  :     /* 3. locals */
; 403  : 
; 404  :     for ( localscurr = localshead ; localscurr ; localscurr = localscurr->next ) {

	mov	rax, QWORD PTR localshead$[rsp]
	mov	QWORD PTR localscurr$[rsp], rax
	jmp	SHORT $LN7@set_symtab
$LN5@set_symtab:
	mov	rax, QWORD PTR localscurr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR localscurr$[rsp], rax
$LN7@set_symtab:
	cmp	QWORD PTR localscurr$[rsp], 0
	je	$LN6@set_symtab

; 405  :         len = Mangle( localscurr->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rax, QWORD PTR localscurr$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	Mangle
	mov	DWORD PTR len$[rsp], eax

; 406  :         p64->st_name = strsize;

	mov	rax, QWORD PTR p64$[rsp]
	mov	ecx, DWORD PTR strsize$[rsp]
	mov	DWORD PTR [rax], ecx

; 407  :         curr = (struct dsym *)localscurr->sym->segment;

	mov	rax, QWORD PTR localscurr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR curr$[rsp], rax

; 408  :         if ( curr && curr->e.seginfo->segtype != SEGTYPE_CODE )

	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN14@set_symtab
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 1
	je	SHORT $LN14@set_symtab

; 409  :             stt = STT_OBJECT;

	mov	BYTE PTR stt$[rsp], 1
	jmp	SHORT $LN15@set_symtab
$LN14@set_symtab:

; 410  :         else
; 411  :             stt = STT_FUNC;

	mov	BYTE PTR stt$[rsp], 2
$LN15@set_symtab:

; 412  :         p64->st_info = ELF64_ST_INFO( STB_LOCAL, stt );

	movzx	eax, BYTE PTR stt$[rsp]
	and	eax, 15
	mov	rcx, QWORD PTR p64$[rsp]
	mov	BYTE PTR [rcx+4], al

; 413  :         p64->st_value = localscurr->sym->offset;

	mov	rax, QWORD PTR localscurr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movsxd	rax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR p64$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 414  : #if 1 /* v2.07: changed - to make MT_ABS obsolete */
; 415  :         if ( curr )

	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN16@set_symtab

; 416  :             p64->st_shndx = GetSegIdx( &curr->sym );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, rax
	call	GetSegIdx
	mov	rcx, QWORD PTR p64$[rsp]
	mov	WORD PTR [rcx+6], ax
	jmp	SHORT $LN17@set_symtab
$LN16@set_symtab:

; 417  :         else
; 418  :             p64->st_shndx = SHN_ABS;

	mov	eax, 65521				; 0000fff1H
	mov	rcx, QWORD PTR p64$[rsp]
	mov	WORD PTR [rcx+6], ax
$LN17@set_symtab:

; 419  : #else
; 420  :         if ( localscurr->sym->mem_type == MT_ABS )
; 421  :             p64->st_shndx = SHN_ABS;
; 422  :         else
; 423  :             p64->st_shndx = GetSegIdx( &curr->sym );
; 424  : #endif
; 425  :         strsize += len + 1;

	mov	eax, DWORD PTR strsize$[rsp]
	mov	ecx, DWORD PTR len$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	DWORD PTR strsize$[rsp], eax

; 426  :         DebugMsg(("set_symtab64, LOCAL: symbol %s, value=%" I64_SPEC "X\n", buffer, p64->st_value));

	mov	rax, QWORD PTR p64$[rsp]
	mov	r8, QWORD PTR [rax+8]
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, OFFSET FLAT:$SG11456
	call	DoDebugMsg

; 427  :         p64++;

	mov	rax, QWORD PTR p64$[rsp]
	add	rax, 24
	mov	QWORD PTR p64$[rsp], rax

; 428  :     }

	jmp	$LN5@set_symtab
$LN6@set_symtab:

; 429  : 
; 430  :     /* 4. externals + communals ( + protos [since v2.01]) */
; 431  : 
; 432  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN10@set_symtab
$LN8@set_symtab:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN10@set_symtab:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN9@set_symtab

; 433  :         /* skip "weak" (=unused) externdefs */
; 434  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@set_symtab
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN18@set_symtab

; 435  :             continue;

	jmp	SHORT $LN8@set_symtab
$LN18@set_symtab:

; 436  :         len = Mangle( &curr->sym, buffer );

	mov	rax, QWORD PTR curr$[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rax
	call	Mangle
	mov	DWORD PTR len$[rsp], eax

; 437  : 
; 438  :         p64->st_name = strsize;

	mov	rax, QWORD PTR p64$[rsp]
	mov	ecx, DWORD PTR strsize$[rsp]
	mov	DWORD PTR [rax], ecx

; 439  : 
; 440  :         /* for COMMUNALs, store their size in the Value field */
; 441  :         if ( curr->sym.iscomm == TRUE ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN19@set_symtab

; 442  :             p64->st_info = ELF64_ST_INFO( STB_GLOBAL, STT_COMMON );

	mov	rax, QWORD PTR p64$[rsp]
	mov	BYTE PTR [rax+4], 21

; 443  :             p64->st_value = curr->sym.total_size;

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	rcx, QWORD PTR p64$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 444  :             p64->st_shndx = SHN_COMMON;

	mov	eax, 65522				; 0000fff2H
	mov	rcx, QWORD PTR p64$[rsp]
	mov	WORD PTR [rcx+6], ax

; 445  :         } else {

	jmp	SHORT $LN20@set_symtab
$LN19@set_symtab:

; 446  : #if OWELFIMPORT
; 447  :             p64->st_info = ( IsWeak( curr->sym ) ? ELF64_ST_INFO( STB_WEAK, STT_IMPORT ) : ELF64_ST_INFO( STB_GLOBAL, STT_IMPORT ) );
; 448  : #else
; 449  :             /* todo: set STT_FUNC for prototypes??? */
; 450  :             p64->st_info = ( IsWeak( curr->sym ) ? ELF64_ST_INFO( STB_WEAK, STT_NOTYPE ) : ELF64_ST_INFO( STB_GLOBAL, STT_NOTYPE ) );

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN28@set_symtab
	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+64], 0
	je	SHORT $LN28@set_symtab
	mov	DWORD PTR tv229[rsp], 32		; 00000020H
	jmp	SHORT $LN29@set_symtab
$LN28@set_symtab:
	mov	DWORD PTR tv229[rsp], 16
$LN29@set_symtab:
	mov	rax, QWORD PTR p64$[rsp]
	movzx	ecx, BYTE PTR tv229[rsp]
	mov	BYTE PTR [rax+4], cl

; 451  : #endif
; 452  :             p64->st_value = curr->sym.offset; /* is always 0 */

	mov	rax, QWORD PTR curr$[rsp]
	movsxd	rax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR p64$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 453  :             p64->st_shndx = SHN_UNDEF;

	xor	eax, eax
	mov	rcx, QWORD PTR p64$[rsp]
	mov	WORD PTR [rcx+6], ax
$LN20@set_symtab:

; 454  :         }
; 455  : 
; 456  :         strsize += len + 1;

	mov	eax, DWORD PTR strsize$[rsp]
	mov	ecx, DWORD PTR len$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	DWORD PTR strsize$[rsp], eax

; 457  :         DebugMsg(("set_symtab64, EXTERNAL: symbol %s, info=%X, shndx=%X, value=%" I64_SPEC "X\n", buffer, p64->st_info, p64->st_shndx, p64->st_value));

	mov	rax, QWORD PTR p64$[rsp]
	movzx	eax, WORD PTR [rax+6]
	mov	rcx, QWORD PTR p64$[rsp]
	movzx	ecx, BYTE PTR [rcx+4]
	mov	rdx, QWORD PTR p64$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsp+32], rdx
	mov	r9d, eax
	mov	r8d, ecx
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, OFFSET FLAT:$SG11460
	call	DoDebugMsg

; 458  :         p64++;

	mov	rax, QWORD PTR p64$[rsp]
	add	rax, 24
	mov	QWORD PTR p64$[rsp], rax

; 459  :     }

	jmp	$LN8@set_symtab
$LN9@set_symtab:

; 460  : 
; 461  : #if ELFALIAS
; 462  :     /* 5. aliases */
; 463  : 
; 464  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {
; 465  :         len = Mangle( &curr->sym, buffer );
; 466  : 
; 467  :         p64->st_name = strsize;
; 468  : 
; 469  : #if OWELFIMPORT
; 470  :         p64->st_info = ELF64_ST_INFO( STB_WEAK, STT_IMPORT );
; 471  : #else
; 472  :         p64->st_info = ELF64_ST_INFO( STB_WEAK, STT_NOTYPE );
; 473  : #endif
; 474  :         p64->st_value = 0; /* is always 0 */
; 475  :         p64->st_shndx = SHN_UNDEF;
; 476  : 
; 477  :         strsize += len + 1;
; 478  :         DebugMsg(("set_symtab64, ALIASES: symbol %s, value=%" I64_SPEC "X\n", buffer, p64->st_value));
; 479  :         p64++;
; 480  :     }
; 481  : #endif
; 482  : 
; 483  :     /* 6. PUBLIC entries */
; 484  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo+16
	mov	QWORD PTR q$[rsp], rax
	jmp	SHORT $LN13@set_symtab
$LN11@set_symtab:
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$[rsp], rax
$LN13@set_symtab:
	cmp	QWORD PTR q$[rsp], 0
	je	$LN12@set_symtab

; 485  :         sym = q->sym;

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR sym$[rsp], rax

; 486  :         len = Mangle( sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	Mangle
	mov	DWORD PTR len$[rsp], eax

; 487  : 
; 488  :         curr = (struct dsym *)sym->segment;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR curr$[rsp], rax

; 489  :         if ( curr && curr->e.seginfo->segtype != SEGTYPE_CODE )

	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN21@set_symtab
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 1
	je	SHORT $LN21@set_symtab

; 490  :             stt = STT_OBJECT;

	mov	BYTE PTR stt$[rsp], 1
	jmp	SHORT $LN22@set_symtab
$LN21@set_symtab:

; 491  :         else
; 492  :             stt = STT_FUNC;

	mov	BYTE PTR stt$[rsp], 2
$LN22@set_symtab:

; 493  : 
; 494  :         p64->st_name = strsize;

	mov	rax, QWORD PTR p64$[rsp]
	mov	ecx, DWORD PTR strsize$[rsp]
	mov	DWORD PTR [rax], ecx

; 495  :         p64->st_info = ELF64_ST_INFO( STB_GLOBAL, stt );

	movzx	eax, BYTE PTR stt$[rsp]
	and	eax, 15
	add	eax, 16
	mov	rcx, QWORD PTR p64$[rsp]
	mov	BYTE PTR [rcx+4], al

; 496  :         p64->st_value = sym->offset;

	mov	rax, QWORD PTR sym$[rsp]
	movsxd	rax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR p64$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 497  : #if 1 /* v2.07: changed - to make MT_ABS obsolete */
; 498  :         if ( sym->state == SYM_INTERNAL )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN23@set_symtab

; 499  :             if ( curr )

	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN25@set_symtab

; 500  :                 p64->st_shndx = GetSegIdx( &curr->sym );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, rax
	call	GetSegIdx
	mov	rcx, QWORD PTR p64$[rsp]
	mov	WORD PTR [rcx+6], ax
	jmp	SHORT $LN26@set_symtab
$LN25@set_symtab:

; 501  :             else
; 502  :                 p64->st_shndx = SHN_ABS;

	mov	eax, 65521				; 0000fff1H
	mov	rcx, QWORD PTR p64$[rsp]
	mov	WORD PTR [rcx+6], ax
$LN26@set_symtab:
	jmp	SHORT $LN24@set_symtab
$LN23@set_symtab:

; 503  :         else
; 504  :             p64->st_shndx = SHN_UNDEF;

	xor	eax, eax
	mov	rcx, QWORD PTR p64$[rsp]
	mov	WORD PTR [rcx+6], ax
$LN24@set_symtab:

; 505  : #else
; 506  :         if ( sym->mem_type == MT_ABS )
; 507  :             p64->st_shndx = SHN_ABS;
; 508  :         else if ( curr )
; 509  :             p64->st_shndx = GetSegIdx( &curr->sym );
; 510  :         else
; 511  :             p64->st_shndx = SHN_UNDEF;
; 512  : #endif
; 513  :         strsize += len + 1;

	mov	eax, DWORD PTR strsize$[rsp]
	mov	ecx, DWORD PTR len$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	DWORD PTR strsize$[rsp], eax

; 514  : 
; 515  :         DebugMsg(("set_symtab64, PUBLIC+LOCAL: symbol %s, info=%X, shndx=%X, value=%" I64_SPEC "X\n", buffer, p64->st_info, p64->st_shndx, p64->st_value));

	mov	rax, QWORD PTR p64$[rsp]
	movzx	eax, WORD PTR [rax+6]
	mov	rcx, QWORD PTR p64$[rsp]
	movzx	ecx, BYTE PTR [rcx+4]
	mov	rdx, QWORD PTR p64$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsp+32], rdx
	mov	r9d, eax
	mov	r8d, ecx
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, OFFSET FLAT:$SG11467
	call	DoDebugMsg

; 516  : 
; 517  :         p64++;

	mov	rax, QWORD PTR p64$[rsp]
	add	rax, 24
	mov	QWORD PTR p64$[rsp], rax

; 518  :     }

	jmp	$LN11@set_symtab
$LN12@set_symtab:

; 519  : #if ADDSTARTLABEL
; 520  :     if ( ModuleInfo.g.start_label ) {
; 521  :         len = Mangle( ModuleInfo.g.start_label, buffer );
; 522  :         p64->st_name = strsize;
; 523  :         p64->st_info = ELF64_ST_INFO( STB_ENTRY, STT_FUNC );
; 524  :         p64->st_value = ModuleInfo.g.start_label->offset;
; 525  :         p64->st_shndx = GetSegIdx( ModuleInfo.g.start_label->segment );
; 526  :         strsize += len + 1;
; 527  :         DebugMsg(("set_symtab64, ENTRY: symbol %s, value=%" I64_SPEC "X\n", buffer, p64->st_value));
; 528  :         p64++;
; 529  :     }
; 530  : #endif
; 531  :     return( strsize );

	mov	eax, DWORD PTR strsize$[rsp]

; 532  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:set_symtab64$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 416				; 000001a0H
	pop	rdi
	ret	0
set_symtab64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
strsize$ = 48
len$ = 52
stt$ = 56
curr$ = 64
sym$ = 72
localscurr$ = 80
q$ = 88
p32$ = 96
buffer$ = 128
tv227 = 400
__$ArrayPad$ = 408
em$ = 432
entries$ = 440
localshead$ = 448
set_symtab32 PROC

; 184  : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 416				; 000001a0H
	mov	rdi, rsp
	mov	ecx, 104				; 00000068H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+432]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 185  :     uint_32   strsize = 1;

	mov	DWORD PTR strsize$[rsp], 1

; 186  :     uint_32   len;
; 187  :     uint_8    stt;
; 188  :     struct dsym   *curr;
; 189  :     struct asym   *sym;
; 190  :     struct localname *localscurr;
; 191  :     struct qnode  *q;
; 192  :     Elf32_Sym *p32;
; 193  :     char      buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 194  : 
; 195  :     em->internal_segs[SYMTAB_IDX].size = entries * sizeof( Elf32_Sym );

	mov	eax, DWORD PTR entries$[rsp]
	imul	rax, rax, 16
	mov	ecx, 16
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR em$[rsp]
	mov	DWORD PTR [rdx+rcx+24], eax

; 196  :     em->internal_segs[SYMTAB_IDX].data = LclAlloc( em->internal_segs[SYMTAB_IDX].size );

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR em$[rsp]
	mov	eax, DWORD PTR [rcx+rax+24]
	mov	ecx, eax
	call	LclAlloc
	mov	ecx, 16
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR em$[rsp]
	mov	QWORD PTR [rdx+rcx+32], rax

; 197  :     memset( em->internal_segs[SYMTAB_IDX].data, 0, em->internal_segs[SYMTAB_IDX].size );

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR em$[rsp]
	mov	eax, DWORD PTR [rcx+rax+24]
	mov	ecx, 16
	imul	rcx, rcx, 1
	mov	r8d, eax
	xor	edx, edx
	mov	rax, QWORD PTR em$[rsp]
	mov	rcx, QWORD PTR [rax+rcx+32]
	call	memset

; 198  : 
; 199  :     p32 = (Elf32_Sym *)em->internal_segs[SYMTAB_IDX].data;

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR em$[rsp]
	mov	rax, QWORD PTR [rcx+rax+32]
	mov	QWORD PTR p32$[rsp], rax

; 200  : 
; 201  :     p32++; /* skip NULL entry */

	mov	rax, QWORD PTR p32$[rsp]
	add	rax, 16
	mov	QWORD PTR p32$[rsp], rax

; 202  : 
; 203  :     /* 1. make file entry */
; 204  :     p32->st_name = strsize;  /* symbol's name in string table */

	mov	rax, QWORD PTR p32$[rsp]
	mov	ecx, DWORD PTR strsize$[rsp]
	mov	DWORD PTR [rax], ecx

; 205  :     strsize += strlen( em->srcname ) + 1;

	mov	rax, QWORD PTR em$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	strlen
	mov	ecx, DWORD PTR strsize$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	DWORD PTR strsize$[rsp], eax

; 206  :     p32->st_value = 0;

	mov	rax, QWORD PTR p32$[rsp]
	mov	DWORD PTR [rax+4], 0

; 207  :     p32->st_size = 0;

	mov	rax, QWORD PTR p32$[rsp]
	mov	DWORD PTR [rax+8], 0

; 208  :     p32->st_info = ELF32_ST_INFO( STB_LOCAL, STT_FILE ); /* symbol's type and binding info */

	mov	rax, QWORD PTR p32$[rsp]
	mov	BYTE PTR [rax+12], 4

; 209  :     p32->st_shndx = SHN_ABS; /* section index */

	mov	eax, 65521				; 0000fff1H
	mov	rcx, QWORD PTR p32$[rsp]
	mov	WORD PTR [rcx+14], ax

; 210  :     p32++;

	mov	rax, QWORD PTR p32$[rsp]
	add	rax, 16
	mov	QWORD PTR p32$[rsp], rax

; 211  : 
; 212  :     /* 2. make section entries */
; 213  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@set_symtab
$LN2@set_symtab:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@set_symtab:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@set_symtab

; 214  :         //p32->st_name = ?;  /* name isn't set */
; 215  :         p32->st_info = ELF32_ST_INFO( STB_LOCAL, STT_SECTION );

	mov	rax, QWORD PTR p32$[rsp]
	mov	BYTE PTR [rax+12], 3

; 216  :         p32->st_shndx = GetSegIdx( curr->sym.segment );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	GetSegIdx
	mov	rcx, QWORD PTR p32$[rsp]
	mov	WORD PTR [rcx+14], ax

; 217  :         p32++;

	mov	rax, QWORD PTR p32$[rsp]
	add	rax, 16
	mov	QWORD PTR p32$[rsp], rax

; 218  :     }

	jmp	SHORT $LN2@set_symtab
$LN3@set_symtab:

; 219  : 
; 220  :     /* 3. locals */
; 221  : 
; 222  :     for ( localscurr = localshead ; localscurr ; localscurr = localscurr->next ) {

	mov	rax, QWORD PTR localshead$[rsp]
	mov	QWORD PTR localscurr$[rsp], rax
	jmp	SHORT $LN7@set_symtab
$LN5@set_symtab:
	mov	rax, QWORD PTR localscurr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR localscurr$[rsp], rax
$LN7@set_symtab:
	cmp	QWORD PTR localscurr$[rsp], 0
	je	$LN6@set_symtab

; 223  :         len = Mangle( localscurr->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rax, QWORD PTR localscurr$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	Mangle
	mov	DWORD PTR len$[rsp], eax

; 224  :         p32->st_name = strsize;

	mov	rax, QWORD PTR p32$[rsp]
	mov	ecx, DWORD PTR strsize$[rsp]
	mov	DWORD PTR [rax], ecx

; 225  :         curr = (struct dsym *)localscurr->sym->segment;

	mov	rax, QWORD PTR localscurr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR curr$[rsp], rax

; 226  :         if ( curr && curr->e.seginfo->segtype != SEGTYPE_CODE )

	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN14@set_symtab
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 1
	je	SHORT $LN14@set_symtab

; 227  :             stt = STT_OBJECT;

	mov	BYTE PTR stt$[rsp], 1
	jmp	SHORT $LN15@set_symtab
$LN14@set_symtab:

; 228  :         else
; 229  :             stt = STT_FUNC;

	mov	BYTE PTR stt$[rsp], 2
$LN15@set_symtab:

; 230  :         p32->st_info = ELF32_ST_INFO( STB_LOCAL, stt );

	movzx	eax, BYTE PTR stt$[rsp]
	and	eax, 15
	mov	rcx, QWORD PTR p32$[rsp]
	mov	BYTE PTR [rcx+12], al

; 231  :         p32->st_value = localscurr->sym->offset;

	mov	rax, QWORD PTR localscurr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR p32$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR [rcx+4], eax

; 232  : #if 1 /* v2.07: changed - to make MT_ABS obsolete */
; 233  :         if ( curr )

	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN16@set_symtab

; 234  :             p32->st_shndx = GetSegIdx( &curr->sym );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, rax
	call	GetSegIdx
	mov	rcx, QWORD PTR p32$[rsp]
	mov	WORD PTR [rcx+14], ax
	jmp	SHORT $LN17@set_symtab
$LN16@set_symtab:

; 235  :         else
; 236  :             p32->st_shndx = SHN_ABS;

	mov	eax, 65521				; 0000fff1H
	mov	rcx, QWORD PTR p32$[rsp]
	mov	WORD PTR [rcx+14], ax
$LN17@set_symtab:

; 237  : #else
; 238  :         if ( localscurr->sym->mem_type == MT_ABS )
; 239  :             p32->st_shndx = SHN_ABS;
; 240  :         else
; 241  :             p32->st_shndx = GetSegIdx( &curr->sym );
; 242  : #endif
; 243  :         strsize += len + 1;

	mov	eax, DWORD PTR strsize$[rsp]
	mov	ecx, DWORD PTR len$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	DWORD PTR strsize$[rsp], eax

; 244  :         DebugMsg(("set_symtab32, LOCAL: symbol %s, value=%X\n", buffer, p32->st_value));

	mov	rax, QWORD PTR p32$[rsp]
	mov	r8d, DWORD PTR [rax+4]
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, OFFSET FLAT:$SG11406
	call	DoDebugMsg

; 245  :         p32++;

	mov	rax, QWORD PTR p32$[rsp]
	add	rax, 16
	mov	QWORD PTR p32$[rsp], rax

; 246  :     }

	jmp	$LN5@set_symtab
$LN6@set_symtab:

; 247  : 
; 248  :     /* 4. externals + communals (+ protos [since v2.01]) */
; 249  : 
; 250  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN10@set_symtab
$LN8@set_symtab:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN10@set_symtab:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN9@set_symtab

; 251  :         /* skip "weak" (=unused) externdefs */
; 252  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@set_symtab
	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN18@set_symtab

; 253  :             continue;

	jmp	SHORT $LN8@set_symtab
$LN18@set_symtab:

; 254  :         len = Mangle( &curr->sym, buffer );

	mov	rax, QWORD PTR curr$[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rax
	call	Mangle
	mov	DWORD PTR len$[rsp], eax

; 255  : 
; 256  :         p32->st_name = strsize;

	mov	rax, QWORD PTR p32$[rsp]
	mov	ecx, DWORD PTR strsize$[rsp]
	mov	DWORD PTR [rax], ecx

; 257  : 
; 258  :         /* for COMMUNALs, store their size in the Value field */
; 259  :         if ( curr->sym.iscomm == TRUE ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN19@set_symtab

; 260  :             p32->st_info = ELF32_ST_INFO( STB_GLOBAL, STT_COMMON );

	mov	rax, QWORD PTR p32$[rsp]
	mov	BYTE PTR [rax+12], 21

; 261  :             p32->st_value = curr->sym.total_size;

	mov	rax, QWORD PTR p32$[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax+4], ecx

; 262  :             p32->st_shndx = SHN_COMMON;

	mov	eax, 65522				; 0000fff2H
	mov	rcx, QWORD PTR p32$[rsp]
	mov	WORD PTR [rcx+14], ax

; 263  :         } else {

	jmp	SHORT $LN20@set_symtab
$LN19@set_symtab:

; 264  : #if OWELFIMPORT
; 265  :             p32->st_info = ( IsWeak( curr->sym ) ? ELF32_ST_INFO( STB_WEAK, STT_IMPORT ) : ELF32_ST_INFO( STB_GLOBAL, STT_IMPORT ) );
; 266  : #else
; 267  :             /* todo: set STT_FUNC for prototypes/code labels??? */
; 268  :             p32->st_info = ( IsWeak( curr->sym ) ? ELF32_ST_INFO( STB_WEAK, STT_NOTYPE ) : ELF32_ST_INFO( STB_GLOBAL, STT_NOTYPE ) );

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN28@set_symtab
	mov	rax, QWORD PTR curr$[rsp]
	cmp	QWORD PTR [rax+64], 0
	je	SHORT $LN28@set_symtab
	mov	DWORD PTR tv227[rsp], 32		; 00000020H
	jmp	SHORT $LN29@set_symtab
$LN28@set_symtab:
	mov	DWORD PTR tv227[rsp], 16
$LN29@set_symtab:
	mov	rax, QWORD PTR p32$[rsp]
	movzx	ecx, BYTE PTR tv227[rsp]
	mov	BYTE PTR [rax+12], cl

; 269  : #endif
; 270  :             p32->st_value = curr->sym.offset; /* is always 0 */

	mov	rax, QWORD PTR p32$[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax+4], ecx

; 271  :             p32->st_shndx = SHN_UNDEF;

	xor	eax, eax
	mov	rcx, QWORD PTR p32$[rsp]
	mov	WORD PTR [rcx+14], ax
$LN20@set_symtab:

; 272  :         }
; 273  : 
; 274  :         strsize += len + 1;

	mov	eax, DWORD PTR strsize$[rsp]
	mov	ecx, DWORD PTR len$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	DWORD PTR strsize$[rsp], eax

; 275  :         DebugMsg(("set_symtab32, EXTERNAL: symbol %s, info=%X, shndx=%X, value=%X\n", buffer, p32->st_info, p32->st_shndx, p32->st_value));

	mov	rax, QWORD PTR p32$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	rcx, QWORD PTR p32$[rsp]
	movzx	ecx, BYTE PTR [rcx+12]
	mov	rdx, QWORD PTR p32$[rsp]
	mov	edx, DWORD PTR [rdx+4]
	mov	DWORD PTR [rsp+32], edx
	mov	r9d, eax
	mov	r8d, ecx
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, OFFSET FLAT:$SG11410
	call	DoDebugMsg

; 276  :         p32++;

	mov	rax, QWORD PTR p32$[rsp]
	add	rax, 16
	mov	QWORD PTR p32$[rsp], rax

; 277  :     }

	jmp	$LN8@set_symtab
$LN9@set_symtab:

; 278  : 
; 279  : #if ELFALIAS
; 280  :     /* 5. aliases */
; 281  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {
; 282  :         len = Mangle( &curr->sym, buffer );
; 283  : 
; 284  :         p32->st_name = strsize;
; 285  : 
; 286  : #if OWELFIMPORT
; 287  :         p32->st_info = ELF32_ST_INFO( STB_WEAK, STT_IMPORT );
; 288  : #else
; 289  :         p32->st_info = ELF32_ST_INFO( STB_WEAK, STT_NOTYPE );
; 290  : #endif
; 291  :         p32->st_value = 0; /* is always 0 */
; 292  :         p32->st_shndx = SHN_UNDEF;
; 293  : 
; 294  :         strsize += len + 1;
; 295  :         DebugMsg(("set_symtab32, ALIAS: symbol %s, value=%X\n", buffer, p32->st_value));
; 296  :         p32++;
; 297  :     }
; 298  : #endif
; 299  : 
; 300  :     /* 6. PUBLIC entries */
; 301  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo+16
	mov	QWORD PTR q$[rsp], rax
	jmp	SHORT $LN13@set_symtab
$LN11@set_symtab:
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$[rsp], rax
$LN13@set_symtab:
	cmp	QWORD PTR q$[rsp], 0
	je	$LN12@set_symtab

; 302  :         sym = q->sym;

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR sym$[rsp], rax

; 303  :         len = Mangle( sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	Mangle
	mov	DWORD PTR len$[rsp], eax

; 304  : 
; 305  :         curr = (struct dsym *)sym->segment;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR curr$[rsp], rax

; 306  :         if ( curr && curr->e.seginfo->segtype != SEGTYPE_CODE )

	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN21@set_symtab
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	DWORD PTR [rax+72], 1
	je	SHORT $LN21@set_symtab

; 307  :             stt = STT_OBJECT;

	mov	BYTE PTR stt$[rsp], 1
	jmp	SHORT $LN22@set_symtab
$LN21@set_symtab:

; 308  :         else
; 309  :             stt = STT_FUNC;

	mov	BYTE PTR stt$[rsp], 2
$LN22@set_symtab:

; 310  : 
; 311  :         p32->st_name = strsize;

	mov	rax, QWORD PTR p32$[rsp]
	mov	ecx, DWORD PTR strsize$[rsp]
	mov	DWORD PTR [rax], ecx

; 312  :         p32->st_info = ELF32_ST_INFO( STB_GLOBAL, stt );

	movzx	eax, BYTE PTR stt$[rsp]
	and	eax, 15
	add	eax, 16
	mov	rcx, QWORD PTR p32$[rsp]
	mov	BYTE PTR [rcx+12], al

; 313  :         p32->st_value = sym->offset;

	mov	rax, QWORD PTR p32$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax+4], ecx

; 314  : #if 1 /* v2.07: changed - to make MT_ABS obsolete */
; 315  :         if ( sym->state == SYM_INTERNAL )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN23@set_symtab

; 316  :             if ( curr )

	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN25@set_symtab

; 317  :                 p32->st_shndx = GetSegIdx( &curr->sym );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, rax
	call	GetSegIdx
	mov	rcx, QWORD PTR p32$[rsp]
	mov	WORD PTR [rcx+14], ax
	jmp	SHORT $LN26@set_symtab
$LN25@set_symtab:

; 318  :             else
; 319  :                 p32->st_shndx = SHN_ABS;

	mov	eax, 65521				; 0000fff1H
	mov	rcx, QWORD PTR p32$[rsp]
	mov	WORD PTR [rcx+14], ax
$LN26@set_symtab:
	jmp	SHORT $LN24@set_symtab
$LN23@set_symtab:

; 320  :         else
; 321  :             p32->st_shndx = SHN_UNDEF;

	xor	eax, eax
	mov	rcx, QWORD PTR p32$[rsp]
	mov	WORD PTR [rcx+14], ax
$LN24@set_symtab:

; 322  : #else
; 323  :         if ( sym->mem_type == MT_ABS )
; 324  :             p32->st_shndx = SHN_ABS;
; 325  :         else if ( curr )
; 326  :             p32->st_shndx = GetSegIdx( &curr->sym );
; 327  :         else
; 328  :             p32->st_shndx = SHN_UNDEF;
; 329  : #endif
; 330  :         strsize += len + 1;

	mov	eax, DWORD PTR strsize$[rsp]
	mov	ecx, DWORD PTR len$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	DWORD PTR strsize$[rsp], eax

; 331  : 
; 332  :         DebugMsg(("set_symtab32, PUBLIC+LOCAL: symbol %s, value=%X\n", buffer, p32->st_value));

	mov	rax, QWORD PTR p32$[rsp]
	mov	r8d, DWORD PTR [rax+4]
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, OFFSET FLAT:$SG11417
	call	DoDebugMsg

; 333  : 
; 334  :         p32++;

	mov	rax, QWORD PTR p32$[rsp]
	add	rax, 16
	mov	QWORD PTR p32$[rsp], rax

; 335  :     }

	jmp	$LN11@set_symtab
$LN12@set_symtab:

; 336  : #if ADDSTARTLABEL
; 337  :     if ( ModuleInfo.g.start_label ) {
; 338  :         len = Mangle( ModuleInfo.g.start_label, buffer );
; 339  :         p32->st_name = strsize;
; 340  :         p32->st_info = ELF32_ST_INFO( STB_ENTRY, STT_FUNC );
; 341  :         p32->st_value = ModuleInfo.g.start_label->offset;
; 342  :         p32->st_shndx = GetSegIdx( ModuleInfo.g.start_label->segment );
; 343  :         strsize += len + 1;
; 344  :         DebugMsg(("set_symtab32, ENTRY: symbol %s, value=%X\n", buffer, p32->st_value));
; 345  :         p32++;
; 346  :     }
; 347  : #endif
; 348  :     return( strsize );

	mov	eax, DWORD PTR strsize$[rsp]

; 349  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:set_symtab32$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 416				; 000001a0H
	pop	rdi
	ret	0
set_symtab32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
curr$ = 0
num$ = 8
get_num_reloc_sections PROC

; 169  : {

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 170  :     struct dsym    *curr;
; 171  :     int num = 0;

	mov	DWORD PTR num$[rsp], 0

; 172  : 
; 173  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@get_num_re
$LN2@get_num_re:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR curr$[rsp], rax
$LN4@get_num_re:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@get_num_re

; 174  :         if ( curr->e.seginfo->FixupList.head )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN5@get_num_re

; 175  :             num++;

	mov	eax, DWORD PTR num$[rsp]
	inc	eax
	mov	DWORD PTR num$[rsp], eax
$LN5@get_num_re:

; 176  :     }

	jmp	SHORT $LN2@get_num_re
$LN3@get_num_re:

; 177  :     return( num );

	mov	eax, DWORD PTR num$[rsp]

; 178  : }

	add	rsp, 16
	pop	rdi
	ret	0
get_num_reloc_sections ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
i$ = 32
sym$ = 64
buffer$ = 72
ElfConvertSectionName PROC

; 148  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 149  :     int i;
; 150  : 
; 151  :     for ( i = 0; i < sizeof( cst ) / sizeof( cst[0] ); i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@ElfConvert
$LN2@ElfConvert:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@ElfConvert:
	movsxd	rax, DWORD PTR i$[rsp]
	cmp	rax, 4
	jae	$LN3@ElfConvert

; 152  :         if ( memcmp( sym->name, cst[i].src, cst[i].len ) == 0 ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 24
	lea	rdx, OFFSET FLAT:cst
	mov	r8d, eax
	mov	rdx, QWORD PTR [rdx+rcx+8]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcmp
	test	eax, eax
	jne	$LN5@ElfConvert

; 153  :             if ( sym->name[cst[i].len] == NULLC )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN6@ElfConvert

; 154  :                 return( (char *)cst[i].dst );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	mov	rax, QWORD PTR [rcx+rax+16]
	jmp	$LN1@ElfConvert
	jmp	$LN7@ElfConvert
$LN6@ElfConvert:

; 155  :             else if ( ( cst[i].flags & CSF_GRPCHK )  && sym->name[cst[i].len] == '$' ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax+1]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@ElfConvert
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 36					; 00000024H
	jne	SHORT $LN8@ElfConvert

; 156  :                 strcpy( buffer, cst[i].dst );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	mov	rdx, QWORD PTR [rcx+rax+16]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcpy

; 157  :                 strcat( buffer, sym->name+cst[i].len );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cst
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR sym$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	rdx, rax
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strcat

; 158  :                 return( buffer );

	mov	rax, QWORD PTR buffer$[rsp]
	jmp	SHORT $LN1@ElfConvert
$LN8@ElfConvert:
$LN7@ElfConvert:
$LN5@ElfConvert:

; 159  :             }
; 160  :         }
; 161  :     }

	jmp	$LN2@ElfConvert
$LN3@ElfConvert:

; 162  :     return( sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
$LN1@ElfConvert:

; 163  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
ElfConvertSectionName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
_TEXT	SEGMENT
modinfo$ = 16
elf_init PROC

; 1378 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 1379 :     modinfo->elf_osabi = ELFOSABI_LINUX;

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	BYTE PTR [rax+412], 3

; 1380 :     modinfo->g.WriteModule = elf_write_module;

	mov	rax, QWORD PTR modinfo$[rsp]
	lea	rcx, OFFSET FLAT:elf_write_module
	mov	QWORD PTR [rax+288], rcx

; 1381 : #if 0
; 1382 :     printf("size Elf_Ehdr: %2u - %2u\n", sizeof(Elf32_Ehdr), sizeof(Elf64_Ehdr));
; 1383 :     printf("size Elf_Shdr: %2u - %2u\n", sizeof(Elf32_Shdr), sizeof(Elf64_Shdr));
; 1384 :     printf("size Elf_Sym : %2u - %2u\n", sizeof(Elf32_Sym ), sizeof(Elf64_Sym ));
; 1385 :     printf("size Elf_Rel : %2u - %2u\n", sizeof(Elf32_Rel ), sizeof(Elf64_Rel ));
; 1386 :     printf("size Elf_Rela: %2u - %2u\n", sizeof(Elf32_Rela), sizeof(Elf64_Rela));
; 1387 : #endif
; 1388 :     return;
; 1389 : }

	pop	rdi
	ret	0
elf_init ENDP
_TEXT	ENDS
END
