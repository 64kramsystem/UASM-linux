; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG11500 DB	01H DUP (?)
	ALIGN	4

$SG11517 DB	01H DUP (?)
	ALIGN	4

?prefix@?1??log_struct@@9@9 DD 01H DUP (?)		; `log_struct'::`2'::prefix
$SG11588 DB	01H DUP (?)
	ALIGN	4

$SG11601 DB	01H DUP (?)
	ALIGN	4

$SG11627 DB	01H DUP (?)
	ALIGN	4

$SG11629 DB	01H DUP (?)
	ALIGN	4

$SG11643 DB	01H DUP (?)
	ALIGN	4

$SG11662 DB	01H DUP (?)
	ALIGN	4

$SG11672 DB	01H DUP (?)
	ALIGN	4

$SG11692 DB	01H DUP (?)
	ALIGN	4

$SG11761 DB	01H DUP (?)
	ALIGN	4

$SG11786 DB	01H DUP (?)
	ALIGN	4

$SG11790 DB	01H DUP (?)
	ALIGN	4

$SG11791 DB	01H DUP (?)
	ALIGN	4

$SG11797 DB	01H DUP (?)
	ALIGN	4

$SG11814 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
COMM	list_pos:DWORD
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

$SG11259 DB	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
szCount	DB	'count', 00H
	ORG $+2
maccap	DW	032H
	DW	033H
	DW	00H
	ORG $+2
strcap	DW	034H
	DW	035H
	DW	00H
	ORG $+2
reccap	DW	036H
	DW	037H
	DW	00H
	ORG $+2
tdcap	DW	038H
	DW	039H
	DW	00H
	ORG $+2
segcap	DW	03aH
	DW	03bH
	DW	00H
	ORG $+2
prccap	DW	03cH
	DW	03dH
	DW	00H
	ORG $+2
dots	DB	' . . . . . . . . . . . . . . . .', 00H
	ORG $+7
cr	DW	00H
	DW	00H
	ORG $+4
	DQ	FLAT:maccap
	DQ	FLAT:log_macro
	DW	01H
	DW	00H
	ORG $+4
	DQ	FLAT:strcap
	DQ	FLAT:log_struct
	DW	02H
	DW	00H
	ORG $+4
	DQ	FLAT:strcap
	DQ	FLAT:log_struct
	DW	03H
	DW	00H
	ORG $+4
	DQ	FLAT:reccap
	DQ	FLAT:log_record
	DW	04H
	DW	00H
	ORG $+4
	DQ	FLAT:tdcap
	DQ	FLAT:log_typedef
	DW	05H
	DW	00H
	ORG $+4
	DQ	FLAT:segcap
	DQ	FLAT:log_segment
	DW	06H
	DW	01H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:log_group
	DW	07H
	DW	00H
	ORG $+4
	DQ	FLAT:prccap
	DQ	FLAT:log_proc
szFmtProcStk DB	'  %s %s        %-17s %s %c %04X', 00H
strings	DQ	FLAT:$SG11217
	DQ	FLAT:$SG11218
	DQ	FLAT:$SG11219
	DQ	FLAT:$SG11220
	DQ	FLAT:$SG11221
	DQ	FLAT:$SG11222
	DQ	FLAT:$SG11223
	DQ	FLAT:$SG11224
	DQ	FLAT:$SG11225
	DQ	FLAT:$SG11226
	DQ	FLAT:$SG11227
	DQ	FLAT:$SG11228
	DQ	FLAT:$SG11229
	DQ	FLAT:$SG11230
	DQ	FLAT:$SG11231
	DQ	FLAT:$SG11232
	DQ	FLAT:$SG11233
	DQ	FLAT:$SG11234
	DQ	FLAT:$SG11235
	DQ	FLAT:$SG11236
	DQ	FLAT:$SG11237
	DQ	FLAT:$SG11238
	DQ	FLAT:$SG11239
	DQ	FLAT:$SG11240
	DQ	FLAT:$SG11241
	DQ	FLAT:$SG11242
	DQ	FLAT:$SG11243
	DQ	FLAT:$SG11244
	DQ	FLAT:$SG11245
	DQ	FLAT:$SG11246
	DQ	FLAT:$SG11247
	DQ	FLAT:$SG11248
	DQ	FLAT:$SG11249
	DQ	FLAT:$SG11250
	DQ	FLAT:$SG11251
	DQ	FLAT:$SG11252
	DQ	FLAT:$SG11253
	DQ	FLAT:$SG11254
	DQ	FLAT:$SG11255
	DQ	FLAT:$SG11256
	DQ	FLAT:$SG11257
	DQ	FLAT:$SG11258
	DQ	FLAT:$SG11259
	DQ	FLAT:$SG11260
	DQ	FLAT:$SG11261
	DQ	FLAT:$SG11262
	DQ	FLAT:$SG11263
	DQ	FLAT:$SG11264
	DQ	FLAT:$SG11265
	DQ	FLAT:$SG11266
	DQ	FLAT:$SG11267
	DQ	FLAT:$SG11268
	DQ	FLAT:$SG11269
	DQ	FLAT:$SG11270
	DQ	FLAT:$SG11271
	DQ	FLAT:$SG11272
	DQ	FLAT:$SG11273
	DQ	FLAT:$SG11274
	DQ	FLAT:$SG11275
	DQ	FLAT:$SG11276
	DQ	FLAT:$SG11277
	DQ	FLAT:$SG11278
	DQ	FLAT:$SG11279
	DQ	FLAT:$SG11280
CONST	ENDS
_DATA	SEGMENT
$SG11264 DB	'FORTRAN', 00H
$SG11265 DB	'BASIC', 00H
	ORG $+2
$SG11266 DB	'FASTCALL', 00H
	ORG $+3
$SG11273 DB	'Types:', 00H
	ORG $+1
$SG11428 DB	0dH, 0aH, 00H
	ORG $+1
$SG11267 DB	'Macros:', 00H
$SG11268 DB	'                N a m e                 Type', 00H
	ORG $+3
$SG11269 DB	'Structures and Unions:', 00H
	ORG $+1
$SG11270 DB	'                N a m e                 Size/Ofs   Type', 00H
$SG11271 DB	'Records:', 00H
	ORG $+7
$SG11272 DB	'                N a m e                 Width   # fields'
	DB	0aH, '                                        Shift   Width   '
	DB	' Mask   Initial', 00H
	ORG $+3
$SG11414 DB	'%-25X', 00H
	ORG $+2
$SG11434 DB	'%u', 00H
	ORG $+1
$SG11274 DB	'                N a m e                 Size    Attr', 00H
	ORG $+3
$SG11275 DB	'Segments and Groups:', 00H
	ORG $+3
$SG11276 DB	'                N a m e                 Size     Length '
	DB	'  Align   Combine Class', 00H
$SG11277 DB	'Procedures, parameters and locals:', 00H
	ORG $+5
$SG11387 DB	'LstWrite: Pass=%u, stored pos=%u', 0aH, 00H
	ORG $+6
$SG11278 DB	'                N a m e                 Type     Value  '
	DB	'  Segment  Length', 00H
	ORG $+2
$SG11444 DB	0dH, 0aH, 00H
	ORG $+1
$SG11279 DB	'Symbols:', 00H
	ORG $+7
$SG11280 DB	'                N a m e                 Type       Value'
	DB	'     Attr', 00H
	ORG $+2
$SG11391 DB	'%08X', 00H
	ORG $+7
$SG11382 DB	'LstWrite( %u, %u ): enter [ pos=%u, GeneratedCode=%u, Ma'
	DB	'croLevel=%u ]', 0aH, 00H
	ORG $+1
$SG11404 DB	'%02X', 00H
	ORG $+3
$SG11406 DB	'%02X', 00H
	ORG $+3
$SG11409 DB	'%08X', 00H
	ORG $+3
$SG11413 DB	'%-25I64X', 00H
	ORG $+3
$SG11420 DB	'%08X', 00H
	ORG $+3
$SG11424 DB	'%08X', 00H
	ORG $+3
$SG11445 DB	0dH, 0aH, 00H
	ORG $+1
$SG11427 DB	'LstWrite: type=%u, writing CRLF', 0aH, 00H
	ORG $+3
$SG11461 DB	0dH, 0aH, 00H
	ORG $+1
$SG11436 DB	'LstWrite: writing (%u b) >%s< [%u/%u], new pos=%u', 0aH, 00H
	ORG $+1
$SG11481 DB	'%u', 00H
	ORG $+1
$SG11442 DB	'LstWrite: writing (%u b) >%s%s<', 0aH, 00H
	ORG $+3
$SG11492 DB	'?', 00H
	ORG $+2
$SG11443 DB	'LstWrite: writing (%u b) >%s<', 0aH, 00H
	ORG $+1
$SG11446 DB	'LstWrite: additional line >%s<, new pos=%u', 0aH, 00H
$SG11555 DB	'?', 00H
	ORG $+2
$SG11501 DB	'%s %s        %s', 00H
$SG11502 DB	' %5lu', 00H
	ORG $+2
$SG11541 DB	'%s %s ', 00H
	ORG $+1
$SG11554 DB	'GetMemtypeString: found mem_type=MT_PROC for sym=%s', 0aH
	DB	00H
	ORG $+3
$SG11561 DB	'?', 00H
	ORG $+2
$SG11589 DB	' ', 00H
	ORG $+2
$SG11594 DB	'%s %s        %8X (%u)', 00H
	ORG $+2
$SG11595 DB	'%s %s        %8X', 00H
	ORG $+3
$SG11602 DB	' ', 00H
	ORG $+2
$SG11596 DB	'%s %s        %8X', 00H
	ORG $+3
$SG11604 DB	'%s', 00H
	ORG $+1
$SG11603 DB	'%s %s        %8X   ', 00H
$SG11606 DB	'[%u]', 00H
	ORG $+3
$SG11632 DB	'?', 00H
	ORG $+2
$SG11628 DB	'%s %s      %6X  %7X', 00H
$SG11634 DB	'?', 00H
	ORG $+2
$SG11633 DB	'  %s %s      %6X  %7X  %016I64X %s', 00H
	ORG $+1
$SG11646 DB	' ', 00H
	ORG $+2
$SG11635 DB	'  %s %s      %6X  %7X  %08X %s', 00H
	ORG $+1
$SG11648 DB	' ', 00H
	ORG $+2
$SG11649 DB	' ', 00H
	ORG $+2
$SG11650 DB	'%s %s    %8u  %s', 00H
	ORG $+3
$SG11708 DB	' ', 00H
	ORG $+2
$SG11663 DB	'%s %s        ', 00H
	ORG $+2
$SG11666 DB	'32 Bit   %08X ', 00H
	ORG $+1
$SG11669 DB	'64 Bit   %08X ', 00H
	ORG $+1
$SG11670 DB	'16 Bit   %04X     ', 00H
	ORG $+1
$SG11779 DB	'%s', 00H
	ORG $+1
$SG11671 DB	'%-7s %-8s', 00H
	ORG $+2
$SG11673 DB	'''%s''', 00H
	ORG $+3
$SG11766 DB	'%0*X ', 00H
	ORG $+2
$SG11775 DB	'*%-8s ', 00H
	ORG $+1
$SG11781 DB	'  ', 00H
	ORG $+1
$SG11693 DB	'%s %s        %s', 00H
$SG11764 DB	'%s %s        P %-6s %08X %-8s ', 00H
	ORG $+1
$SG11765 DB	'%s %s        P %-6s %04X     %-8s ', 00H
	ORG $+1
$SG11768 DB	'(F) ', 00H
	ORG $+3
$SG11771 DB	'%-9s', 00H
	ORG $+3
$SG11774 DB	'%-9s', 00H
	ORG $+3
$SG11776 DB	'%-9s ', 00H
	ORG $+2
$SG11794 DB	'%s[%u]', 00H
	ORG $+1
$SG11839 DB	'%s ', 00H
$SG11778 DB	'(%.8s) ', 00H
$SG11789 DB	'  %s %s        %-17s %s', 00H
$SG11800 DB	'  %s %s        L %-6s %08X %s', 00H
	ORG $+2
$SG11801 DB	'  %s %s        L %-6s %04X     %s', 00H
	ORG $+2
$SG11803 DB	' (F)', 00H
	ORG $+3
$SG11819 DB	'%s[%u]', 00H
	ORG $+1
$SG11845 DB	'%s ', 00H
$SG11816 DB	'%s %s        ', 00H
	ORG $+2
$SG11820 DB	'%-10s ', 00H
	ORG $+1
$SG11823 DB	'%-10s ', 00H
	ORG $+1
$SG11824 DB	'%-10s ', 00H
	ORG $+1
$SG11827 DB	' %8Xh ', 00H
	ORG $+1
$SG11832 DB	' %I64Xh ', 00H
	ORG $+3
$SG11836 DB	' %8Xh ', 00H
	ORG $+1
$SG11849 DB	'%s ', 00H
$SG11835 DB	'-%08Xh ', 00H
$SG11837 DB	' %8Xh ', 00H
	ORG $+1
$SG11841 DB	'(F) ', 00H
	ORG $+3
$SG11843 DB	'%s=%u ', 00H
	ORG $+1
$SG11848 DB	'*%s ', 00H
	ORG $+3
$SG11851 DB	'%s ', 00H
$SG11852 DB	'%s', 00H
	ORG $+1
$SG11854 DB	'%s %s        %s   %s', 00H
	ORG $+3
$SG11856 DB	'%s %s        %s  %s', 00H
$SG11230 DB	'Far', 00H
$SG11916 DB	'LstWriteCRef: calling qsort', 0aH, 00H
	ORG $+3
$SG11935 DB	'LstWriteCRef: log_symbol( %s )', 0aH, 00H
$SG11936 DB	'LstWriteCRef: %s suppressed', 0aH, 00H
	ORG $+3
$SG11937 DB	'LstWriteCRef: free sorted symbols', 0aH, 00H
	ORG $+1
$SG11217 DB	'Byte', 00H
	ORG $+3
$SG11218 DB	'Word', 00H
	ORG $+3
$SG11219 DB	'DWord', 00H
	ORG $+2
$SG11220 DB	'FWord', 00H
	ORG $+2
$SG11221 DB	'QWord', 00H
	ORG $+2
$SG11222 DB	'TByte', 00H
	ORG $+2
$SG11223 DB	'Para', 00H
	ORG $+3
$SG11227 DB	'Near16', 00H
	ORG $+1
$SG11242 DB	'Ptr', 00H
$SG11224 DB	'XmmWord', 00H
$SG11225 DB	'Page', 00H
	ORG $+3
$SG11226 DB	'Near', 00H
	ORG $+3
$SG11228 DB	'Near32', 00H
	ORG $+1
$SG11229 DB	'Near64', 00H
	ORG $+1
$SG11231 DB	'Far16', 00H
	ORG $+2
$SG11232 DB	'Far32', 00H
	ORG $+2
$SG11233 DB	'Far64', 00H
	ORG $+2
$SG11234 DB	'L Near', 00H
	ORG $+1
$SG11235 DB	'L Near16', 00H
	ORG $+3
$SG11238 DB	'L Far', 00H
	ORG $+2
$SG11245 DB	'Number', 00H
	ORG $+1
$SG11256 DB	'Abs', 00H
$SG11236 DB	'L Near32', 00H
	ORG $+3
$SG11247 DB	'Stack', 00H
	ORG $+2
$SG11248 DB	'Public', 00H
	ORG $+1
$SG11260 DB	'C', 00H
	ORG $+2
$SG11237 DB	'L Near64', 00H
	ORG $+3
$SG11249 DB	'Common', 00H
	ORG $+5
$SG11239 DB	'L Far16', 00H
$SG11240 DB	'L Far32', 00H
$SG11241 DB	'L Far64', 00H
$SG11243 DB	'Proc', 00H
	ORG $+3
$SG11244 DB	'Func', 00H
	ORG $+3
$SG11246 DB	'Private', 00H
$SG11250 DB	'External', 00H
	ORG $+7
$SG11251 DB	'Undefined', 00H
	ORG $+2
$SG11252 DB	'GROUP', 00H
	ORG $+2
$SG11253 DB	'No Seg', 00H
	ORG $+1
$SG11254 DB	'Text', 00H
	ORG $+3
$SG11255 DB	'Alias', 00H
	ORG $+2
$SG11257 DB	'COMM', 00H
	ORG $+3
$SG11258 DB	'VARARG', 00H
	ORG $+5
$SG11261 DB	'SYSCALL', 00H
$SG11262 DB	'STDCALL', 00H
$SG11263 DB	'PASCAL', 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	vfprintf
PUBLIC	printf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	LstInit
PUBLIC	LstWrite
PUBLIC	LstWriteSrcLine
PUBLIC	LstWriteCRef
PUBLIC	LstPrintf
PUBLIC	LstNL
PUBLIC	LstSetPosition
PUBLIC	ListingDirective
PUBLIC	ListMacroDirective
EXTRN	__acrt_iob_func:PROC
EXTRN	fseek:PROC
EXTRN	fwrite:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	qsort:PROC
EXTRN	memset:PROC
EXTRN	strcat:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	MemAlloc:PROC
EXTRN	MemFree:PROC
EXTRN	SymLookup:PROC
EXTRN	SymGetAll:PROC
EXTRN	SymGetCount:PROC
EXTRN	GetResWName:PROC
EXTRN	GetSymOfssize:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	get_curr_srcfile:PROC
EXTRN	GetFName:PROC
EXTRN	MsgGetEx:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	MacroLevel:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	LineStoreCurr:QWORD
EXTRN	UseSavedState:BYTE
EXTRN	CurrStruct:QWORD
EXTRN	LastCodeBufSize:DWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vfprintf DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$vfprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$LstInit DD imagerel $LN4
	DD	imagerel $LN4+218
	DD	imagerel $unwind$LstInit
$pdata$LstWrite DD imagerel $LN74
	DD	imagerel $LN74+2636
	DD	imagerel $unwind$LstWrite
$pdata$LstWriteSrcLine DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$LstWriteSrcLine
$pdata$LstWriteCRef DD imagerel $LN47
	DD	imagerel $LN47+1388
	DD	imagerel $unwind$LstWriteCRef
$pdata$LstPrintf DD imagerel $LN4
	DD	imagerel $LN4+122
	DD	imagerel $unwind$LstPrintf
$pdata$LstNL DD	imagerel $LN4
	DD	imagerel $LN4+90
	DD	imagerel $unwind$LstNL
$pdata$LstSetPosition DD imagerel $LN4
	DD	imagerel $LN4+127
	DD	imagerel $unwind$LstSetPosition
$pdata$log_macro DD imagerel log_macro
	DD	imagerel log_macro+222
	DD	imagerel $unwind$log_macro
$pdata$log_struct DD imagerel log_struct
	DD	imagerel log_struct+831
	DD	imagerel $unwind$log_struct
$pdata$log_record DD imagerel log_record
	DD	imagerel log_record+721
	DD	imagerel $unwind$log_record
$pdata$log_typedef DD imagerel log_typedef
	DD	imagerel log_typedef+433
	DD	imagerel $unwind$log_typedef
$pdata$log_segment DD imagerel log_segment
	DD	imagerel log_segment+410
	DD	imagerel $unwind$log_segment
$pdata$log_group DD imagerel log_group
	DD	imagerel log_group+253
	DD	imagerel $unwind$log_group
$pdata$log_proc DD imagerel log_proc
	DD	imagerel log_proc+2436
	DD	imagerel $unwind$log_proc
$pdata$get_seg_align DD imagerel get_seg_align
	DD	imagerel get_seg_align+328
	DD	imagerel $unwind$get_seg_align
$pdata$get_seg_combine DD imagerel get_seg_combine
	DD	imagerel get_seg_combine+149
	DD	imagerel $unwind$get_seg_combine
$pdata$SimpleTypeString DD imagerel SimpleTypeString
	DD	imagerel SimpleTypeString+304
	DD	imagerel $unwind$SimpleTypeString
$pdata$GetMemtypeString DD imagerel GetMemtypeString
	DD	imagerel GetMemtypeString+869
	DD	imagerel $unwind$GetMemtypeString
$pdata$get_proc_type DD imagerel get_proc_type
	DD	imagerel get_proc_type+179
	DD	imagerel $unwind$get_proc_type
$pdata$log_symbol DD imagerel log_symbol
	DD	imagerel log_symbol+1051
	DD	imagerel $unwind$log_symbol
$pdata$LstCaption DD imagerel LstCaption
	DD	imagerel LstCaption+64
	DD	imagerel $unwind$LstCaption
$pdata$compare_syms DD imagerel compare_syms
	DD	imagerel compare_syms+48
	DD	imagerel $unwind$compare_syms
$pdata$ListingDirective DD imagerel $LN33
	DD	imagerel $LN33+856
	DD	imagerel $unwind$ListingDirective
$pdata$ListMacroDirective DD imagerel $LN4
	DD	imagerel $LN4+118
	DD	imagerel $unwind$ListMacroDirective
pdata	ENDS
xdata	SEGMENT
$unwind$LstInit DD 010401H
	DD	08204H
$unwind$LstWrite DD 035042b19H
	DD	0115331aH
	DD	0500e001aH
	DD	imagerel __GSHandlerCheck
	DD	0c8H
$unwind$LstWriteSrcLine DD 010401H
	DD	04204H
$unwind$LstWriteCRef DD 021919H
	DD	0230107H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$LstPrintf DD 011801H
	DD	06218H
$unwind$LstNL DD 010401H
	DD	04204H
$unwind$LstSetPosition DD 010401H
	DD	04204H
$unwind$log_macro DD 010901H
	DD	0a209H
$unwind$log_struct DD 011301H
	DD	0e213H
$unwind$log_record DD 020c01H
	DD	015010cH
$unwind$log_typedef DD 010901H
	DD	0a209H
$unwind$log_segment DD 022019H
	DD	0110111H
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$log_group DD 010e01H
	DD	0820eH
$unwind$log_proc DD 021e19H
	DD	025010cH
	DD	imagerel __GSHandlerCheck
	DD	0118H
$unwind$get_seg_align DD 010e01H
	DD	0620eH
$unwind$get_seg_combine DD 010901H
	DD	02209H
$unwind$SimpleTypeString DD 010801H
	DD	02208H
$unwind$GetMemtypeString DD 010e01H
	DD	0820eH
$unwind$get_proc_type DD 010901H
	DD	06209H
$unwind$log_symbol DD 010901H
	DD	0a209H
$unwind$LstCaption DD 010d01H
	DD	0420dH
$unwind$compare_syms DD 010e01H
	DD	0420eH
$unwind$ListingDirective DD 010d01H
	DD	0820dH
$unwind$ListMacroDirective DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vfprintf DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
ListMacroDirective PROC

; 1248 : {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 1249 :     if ( tokenarray[i+1].token != T_FINAL ) {

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN2@ListMacroD

; 1250 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].string_ptr ) );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@ListMacroD
$LN2@ListMacroD:

; 1251 :     }
; 1252 : 
; 1253 :     ModuleInfo.list_macro = GetSflagsSp( tokenarray[i].tokval );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	eax, DWORD PTR [rcx+rax+4]
	mov	DWORD PTR ModuleInfo+400, eax

; 1254 : 
; 1255 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@ListMacroD:

; 1256 : }

	add	rsp, 40					; 00000028H
	ret	0
ListMacroDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
tv69 = 32
tv161 = 36
directive$ = 40
sym$1 = 48
i$ = 80
tokenarray$ = 88
ListingDirective PROC

; 1160 : {

$LN33:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 1161 :     int directive = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR directive$[rsp], eax

; 1162 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1163 : 
; 1164 :     switch ( directive ) {

	mov	eax, DWORD PTR directive$[rsp]
	mov	DWORD PTR tv69[rsp], eax
	mov	eax, DWORD PTR tv69[rsp]
	sub	eax, 295				; 00000127H
	mov	DWORD PTR tv69[rsp], eax
	cmp	DWORD PTR tv69[rsp], 11
	ja	$LN24@ListingDir
	movsxd	rax, DWORD PTR tv69[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN32@ListingDir[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN9@ListingDir:

; 1165 :     case T_DOT_LIST:
; 1166 :         if ( CurrFile[LST] )

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN10@ListingDir

; 1167 :             ModuleInfo.list = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 11
	mov	DWORD PTR ModuleInfo+408, eax
$LN10@ListingDir:

; 1168 :         break;

	jmp	$LN2@ListingDir
$LN11@ListingDir:

; 1169 :     case T_DOT_CREF:
; 1170 :         ModuleInfo.cref = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 12
	mov	DWORD PTR ModuleInfo+408, eax

; 1171 :         break;

	jmp	$LN2@ListingDir
$LN12@ListingDir:

; 1172 :     case T_DOT_NOLIST:
; 1173 :     case T_DOT_XLIST:
; 1174 :         ModuleInfo.list = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	btr	eax, 11
	mov	DWORD PTR ModuleInfo+408, eax

; 1175 :         break;

	jmp	$LN2@ListingDir
$LN13@ListingDir:

; 1176 :     case T_DOT_NOCREF:
; 1177 :     case T_DOT_XCREF:
; 1178 :         if ( i == Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jne	SHORT $LN14@ListingDir

; 1179 :             ModuleInfo.cref = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	btr	eax, 12
	mov	DWORD PTR ModuleInfo+408, eax

; 1180 :             break;

	jmp	$LN2@ListingDir
$LN14@ListingDir:
$LN6@ListingDir:

; 1181 :         }
; 1182 :         do {
; 1183 :             struct asym *sym;
; 1184 :             if ( tokenarray[i].token != T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN15@ListingDir

; 1185 :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ListingDir
$LN15@ListingDir:

; 1186 :             }
; 1187 :             /* the name may be a forward reference. In this case it will
; 1188 :              * be created here.
; 1189 :              * v2.11: function call cannot fail. no need for checks.
; 1190 :              */
; 1191 :             sym = SymLookup( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymLookup
	mov	QWORD PTR sym$1[rsp], rax

; 1192 :             sym->list = FALSE;

	mov	rax, QWORD PTR sym$1[rsp]
	movzx	eax, BYTE PTR [rax+41]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR sym$1[rsp]
	mov	BYTE PTR [rcx+41], al

; 1193 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1194 :             if ( i < Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN16@ListingDir

; 1195 :                 if ( tokenarray[i].token != T_COMMA )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN17@ListingDir

; 1196 :                     return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	$LN1@ListingDir
$LN17@ListingDir:

; 1197 : 
; 1198 :                 /* if there's nothing after the comma, don't increment */
; 1199 :                 if ( i < ( Token_Count - 1 ) )

	mov	eax, DWORD PTR ModuleInfo+496
	dec	eax
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN18@ListingDir

; 1200 :                     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN18@ListingDir:
$LN16@ListingDir:

; 1201 :             }
; 1202 :         } while ( i < Token_Count );

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jl	$LN6@ListingDir

; 1203 :         break;

	jmp	$LN2@ListingDir
$LN19@ListingDir:

; 1204 :     case T_DOT_LISTALL: /* list false conditionals and generated code */
; 1205 :         if ( CurrFile[LST] )

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN20@ListingDir

; 1206 :             ModuleInfo.list = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 11
	mov	DWORD PTR ModuleInfo+408, eax
$LN20@ListingDir:

; 1207 :         ModuleInfo.list_generated_code = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 14
	mov	DWORD PTR ModuleInfo+408, eax
$LN21@ListingDir:

; 1208 :         /* fall through */
; 1209 :     case T_DOT_LISTIF:
; 1210 :     case T_DOT_LFCOND: /* .LFCOND is synonym for .LISTIF */
; 1211 :         ModuleInfo.listif = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 13
	mov	DWORD PTR ModuleInfo+408, eax

; 1212 :         break;

	jmp	$LN2@ListingDir
$LN22@ListingDir:

; 1213 :     case T_DOT_NOLISTIF:
; 1214 :     case T_DOT_SFCOND: /* .SFCOND is synonym for .NOLISTIF */
; 1215 :         ModuleInfo.listif = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	btr	eax, 13
	mov	DWORD PTR ModuleInfo+408, eax

; 1216 :         break;

	jmp	$LN2@ListingDir
$LN23@ListingDir:

; 1217 :     case T_DOT_TFCOND: /* .TFCOND toggles .LFCOND, .SFCOND */
; 1218 :         ModuleInfo.listif = !ModuleInfo.listif;

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 13
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN30@ListingDir
	mov	DWORD PTR tv161[rsp], 1
	jmp	SHORT $LN31@ListingDir
$LN30@ListingDir:
	mov	DWORD PTR tv161[rsp], 0
$LN31@ListingDir:
	mov	eax, DWORD PTR tv161[rsp]
	and	eax, 1
	shl	eax, 13
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 13
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 1219 :         break;

	jmp	$LN2@ListingDir
$LN24@ListingDir:

; 1220 :     case T_PAGE:
; 1221 :     default: /* TITLE, SUBTITLE, SUBTTL */
; 1222 :         /* tiny checks to ensure that these directives
; 1223 :          aren't used as code labels or struct fields */
; 1224 :         if ( tokenarray[i].token == T_COLON )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN25@ListingDir

; 1225 :             break;

	jmp	SHORT $LN2@ListingDir
$LN25@ListingDir:

; 1226 :         /* this isn't really Masm-compatible, but ensures we don't get
; 1227 :          * struct fields with names page, title, subtitle, subttl.
; 1228 :          */
; 1229 :         if( CurrStruct ) {

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN26@ListingDir

; 1230 :             return( EmitError( STATEMENT_NOT_ALLOWED_INSIDE_STRUCTURE_DEFINITION ) );

	mov	ecx, 141				; 0000008dH
	call	EmitError
	jmp	$LN1@ListingDir
$LN26@ListingDir:

; 1231 :         }
; 1232 :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN27@ListingDir

; 1233 :             EmitWarn( 4, DIRECTIVE_IGNORED, tokenarray[i-1].string_ptr );

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+8]
	mov	edx, 128				; 00000080H
	mov	ecx, 4
	call	EmitWarn
$LN27@ListingDir:
$LN7@ListingDir:

; 1234 :         while ( tokenarray[i].token != T_FINAL) i++;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN8@ListingDir
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN7@ListingDir
$LN8@ListingDir:
$LN2@ListingDir:

; 1235 :     }
; 1236 : 
; 1237 :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN28@ListingDir

; 1238 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@ListingDir
$LN28@ListingDir:

; 1239 :     }
; 1240 : 
; 1241 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@ListingDir:

; 1242 : }

	add	rsp, 72					; 00000048H
	ret	0
	npad	3
$LN32@ListingDir:
	DD	$LN11@ListingDir
	DD	$LN21@ListingDir
	DD	$LN9@ListingDir
	DD	$LN19@ListingDir
	DD	$LN21@ListingDir
	DD	$LN13@ListingDir
	DD	$LN12@ListingDir
	DD	$LN22@ListingDir
	DD	$LN22@ListingDir
	DD	$LN23@ListingDir
	DD	$LN13@ListingDir
	DD	$LN12@ListingDir
ListingDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
p1$ = 48
p2$ = 56
compare_syms PROC

; 1036 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1037 :     return( strcmp( (*(struct asym * *)p1)->name, (*(struct asym * *)p2)->name ) );

	mov	rax, QWORD PTR p2$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR p1$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR [rcx+8]
	call	strcmp

; 1038 : }

	add	rsp, 40					; 00000028H
	ret	0
compare_syms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
caption$ = 48
prefNL$ = 56
LstCaption PROC

; 1026 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1027 :     for (; prefNL; prefNL--)

	jmp	SHORT $LN4@LstCaption
$LN2@LstCaption:
	mov	eax, DWORD PTR prefNL$[rsp]
	dec	eax
	mov	DWORD PTR prefNL$[rsp], eax
$LN4@LstCaption:
	cmp	DWORD PTR prefNL$[rsp], 0
	je	SHORT $LN3@LstCaption

; 1028 :         LstNL();

	call	LstNL
	jmp	SHORT $LN2@LstCaption
$LN3@LstCaption:

; 1029 :     LstPrintf( caption );

	mov	rcx, QWORD PTR caption$[rsp]
	call	LstPrintf

; 1030 :     LstNL();

	call	LstNL

; 1031 :     LstNL();

	call	LstNL

; 1032 : }

	add	rsp, 40					; 00000028H
	ret	0
LstCaption ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
tv72 = 48
i$ = 52
pdots$ = 56
tv70 = 64
tv218 = 72
sym$ = 96
log_symbol PROC

; 949  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 950  :     int i = sym->name_size;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	DWORD PTR i$[rsp], eax

; 951  :     const char *pdots;
; 952  :     //char buffer[MAX_LINE_LEN];
; 953  : 
; 954  :     pdots = ((i >= DOTSMAX) ? "" : dots + i + 1 );

	cmp	DWORD PTR i$[rsp], 32			; 00000020H
	jl	SHORT $LN27@log_symbol
	lea	rax, OFFSET FLAT:$SG11814
	mov	QWORD PTR tv70[rsp], rax
	jmp	SHORT $LN28@log_symbol
$LN27@log_symbol:
	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:dots
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR tv70[rsp], rax
$LN28@log_symbol:
	mov	rax, QWORD PTR tv70[rsp]
	mov	QWORD PTR pdots$[rsp], rax

; 955  : 
; 956  :     switch ( sym->state ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv72[rsp], eax
	cmp	DWORD PTR tv72[rsp], 0
	jl	$LN2@log_symbol
	cmp	DWORD PTR tv72[rsp], 2
	jle	SHORT $LN4@log_symbol
	cmp	DWORD PTR tv72[rsp], 8
	je	$LN25@log_symbol
	cmp	DWORD PTR tv72[rsp], 10
	je	$LN24@log_symbol
	jmp	$LN2@log_symbol
$LN4@log_symbol:

; 957  :     case SYM_UNDEFINED:
; 958  :     case SYM_INTERNAL:
; 959  :     case SYM_EXTERNAL:
; 960  :         LstPrintf( "%s %s        ", sym->name, pdots );

	mov	r8, QWORD PTR pdots$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11816
	call	LstPrintf

; 961  : 
; 962  :         if ( sym->isarray ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@log_symbol

; 963  :             i = sprintf( StringBufferEnd, "%s[%u]", GetMemtypeString( sym, NULL ), sym->total_length );

	xor	edx, edx
	mov	rcx, QWORD PTR sym$[rsp]
	call	GetMemtypeString
	mov	rcx, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rcx+64]
	mov	r8, rax
	lea	rdx, OFFSET FLAT:$SG11819
	mov	rcx, QWORD PTR ModuleInfo+488
	call	sprintf
	mov	DWORD PTR i$[rsp], eax

; 964  :             LstPrintf( "%-10s ", StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	lea	rcx, OFFSET FLAT:$SG11820
	call	LstPrintf
	jmp	SHORT $LN6@log_symbol
$LN5@log_symbol:

; 965  :         } else if ( sym->state == SYM_EXTERNAL && sym->iscomm == TRUE ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN7@log_symbol
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN7@log_symbol

; 966  :             LstPrintf( "%-10s ", strings[LS_COMM] );

	mov	eax, 8
	imul	rax, rax, 40				; 00000028H
	lea	rcx, OFFSET FLAT:strings
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG11823
	call	LstPrintf

; 967  :         } else

	jmp	SHORT $LN8@log_symbol
$LN7@log_symbol:

; 968  :             LstPrintf( "%-10s ", GetMemtypeString( sym, NULL ) );

	xor	edx, edx
	mov	rcx, QWORD PTR sym$[rsp]
	call	GetMemtypeString
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11824
	call	LstPrintf
$LN8@log_symbol:
$LN6@log_symbol:

; 969  : 
; 970  :         /* print value */
; 971  :         /* v2.07: MT_ABS is obsolete */
; 972  :         //if ( sym->mem_type == MT_ABS )
; 973  :         if ( sym->state == SYM_EXTERNAL && sym->iscomm == TRUE )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN9@log_symbol
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN9@log_symbol

; 974  :             LstPrintf( " %8" I32_SPEC "Xh ", sym->total_size / sym->total_length );

	xor	edx, edx
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	rcx, QWORD PTR sym$[rsp]
	div	DWORD PTR [rcx+64]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11827
	call	LstPrintf
	jmp	$LN10@log_symbol
$LN9@log_symbol:

; 975  :         else if ( sym->mem_type == MT_EMPTY ) { /* also check segment? might be != NULL for equates (var = offset x) */

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 192			; 000000c0H
	jne	SHORT $LN11@log_symbol

; 976  :             if ( sym->value3264 != 0 && sym->value3264 != -1 )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+56], 0
	je	SHORT $LN13@log_symbol
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+56], -1
	je	SHORT $LN13@log_symbol

; 977  :                 LstPrintf( " %" I64_SPEC "Xh ", sym->uvalue, sym->value3264 );

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+56]
	mov	rax, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR [rax+16]
	lea	rcx, OFFSET FLAT:$SG11832
	call	LstPrintf
	jmp	SHORT $LN14@log_symbol
$LN13@log_symbol:

; 978  :             else if ( sym->value3264 < 0 )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+56], 0
	jge	SHORT $LN15@log_symbol

; 979  :                 LstPrintf( "-%08" I32_SPEC "Xh ", 0 - sym->uvalue );

	mov	rax, QWORD PTR sym$[rsp]
	xor	ecx, ecx
	sub	ecx, DWORD PTR [rax+16]
	mov	eax, ecx
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11835
	call	LstPrintf
	jmp	SHORT $LN16@log_symbol
$LN15@log_symbol:

; 980  :             else
; 981  :                 LstPrintf( " %8" I32_SPEC "Xh ", sym->offset );

	mov	rax, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR [rax+16]
	lea	rcx, OFFSET FLAT:$SG11836
	call	LstPrintf
$LN16@log_symbol:
$LN14@log_symbol:

; 982  :         } else

	jmp	SHORT $LN12@log_symbol
$LN11@log_symbol:

; 983  :             LstPrintf( " %8" I32_SPEC "Xh ", sym->offset );

	mov	rax, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR [rax+16]
	lea	rcx, OFFSET FLAT:$SG11837
	call	LstPrintf
$LN12@log_symbol:
$LN10@log_symbol:

; 984  : 
; 985  :         /* print segment */
; 986  :         //if ( sym->mem_type == MT_ABS || sym->state == SYM_UNDEFINED )
; 987  :         //    ;
; 988  :         //else
; 989  :         if ( sym->segment )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN17@log_symbol

; 990  :             LstPrintf( "%s ", get_sym_seg_name( sym ) );

	mov	rcx, QWORD PTR sym$[rsp]
	call	get_sym_seg_name
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11839
	call	LstPrintf
$LN17@log_symbol:

; 991  : 
; 992  : #ifdef DEBUG_OUT
; 993  :         if ( sym->fwdref )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@log_symbol

; 994  :             LstPrintf( "(F) " );

	lea	rcx, OFFSET FLAT:$SG11841
	call	LstPrintf
$LN18@log_symbol:

; 995  : #endif
; 996  :         if ( sym->state == SYM_EXTERNAL && sym->iscomm == TRUE )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN19@log_symbol
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN19@log_symbol

; 997  :             LstPrintf( "%s=%u ", szCount, sym->total_length );

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+64]
	lea	rdx, OFFSET FLAT:szCount
	lea	rcx, OFFSET FLAT:$SG11843
	call	LstPrintf
$LN19@log_symbol:

; 998  : 
; 999  :         if( sym->ispublic )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@log_symbol

; 1000 :             LstPrintf( "%s ", strings[LS_PUBLIC] );

	mov	eax, 8
	imul	rax, rax, 31
	lea	rcx, OFFSET FLAT:strings
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG11845
	call	LstPrintf
$LN20@log_symbol:

; 1001 : 
; 1002 :         if ( sym->state == SYM_EXTERNAL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN21@log_symbol

; 1003 :             LstPrintf( sym->weak ? "*%s " : "%s ", strings[LS_EXTERNAL] );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN29@log_symbol
	lea	rax, OFFSET FLAT:$SG11848
	mov	QWORD PTR tv218[rsp], rax
	jmp	SHORT $LN30@log_symbol
$LN29@log_symbol:
	lea	rax, OFFSET FLAT:$SG11849
	mov	QWORD PTR tv218[rsp], rax
$LN30@log_symbol:
	mov	eax, 8
	imul	rax, rax, 33				; 00000021H
	lea	rcx, OFFSET FLAT:strings
	mov	rdx, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR tv218[rsp]
	call	LstPrintf
	jmp	SHORT $LN22@log_symbol
$LN21@log_symbol:

; 1004 :         } else if ( sym->state == SYM_UNDEFINED ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN23@log_symbol

; 1005 :             LstPrintf( "%s ", strings[LS_UNDEFINED] );

	mov	eax, 8
	imul	rax, rax, 34				; 00000022H
	lea	rcx, OFFSET FLAT:strings
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG11851
	call	LstPrintf
$LN23@log_symbol:
$LN22@log_symbol:

; 1006 :         }
; 1007 : 
; 1008 :         LstPrintf( "%s", GetLanguage( sym ) );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetLanguage
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11852
	call	LstPrintf

; 1009 :         LstNL();

	call	LstNL

; 1010 :         break;

	jmp	$LN2@log_symbol
$LN24@log_symbol:

; 1011 :     case SYM_TMACRO:
; 1012 :         //GetLiteralValue( buffer, sym->string_ptr );
; 1013 :         //strcpy( buffer, sym->string_ptr );
; 1014 :         LstPrintf( "%s %s        %s   %s", sym->name, pdots, strings[LS_TEXT], sym->string_ptr );

	mov	eax, 8
	imul	rax, rax, 37				; 00000025H
	lea	rcx, OFFSET FLAT:strings
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	QWORD PTR [rsp+32], rdx
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11854
	call	LstPrintf

; 1015 :         LstNL();

	call	LstNL

; 1016 :         break;

	jmp	SHORT $LN2@log_symbol
$LN25@log_symbol:

; 1017 :     case SYM_ALIAS:
; 1018 :         LstPrintf( "%s %s        %s  %s", sym->name, pdots, strings[LS_ALIAS], sym->substitute->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, 8
	imul	rcx, rcx, 38				; 00000026H
	lea	rdx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR [rdx+rcx]
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11856
	call	LstPrintf

; 1019 :         LstNL();

	call	LstNL
$LN2@log_symbol:

; 1020 :         break;
; 1021 :     }
; 1022 : }

	add	rsp, 88					; 00000058H
	ret	0
log_symbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
sym$ = 8
get_sym_seg_name PROC

; 785  : {

	mov	QWORD PTR [rsp+8], rcx

; 786  :     if( sym->segment ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN2@get_sym_se

; 787  :         return( sym->segment->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+8]
	jmp	SHORT $LN1@get_sym_se

; 788  :     } else {

	jmp	SHORT $LN3@get_sym_se
$LN2@get_sym_se:

; 789  :         return( strings[LS_NOSEG] );

	mov	eax, 8
	imul	rax, rax, 36				; 00000024H
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
$LN3@get_sym_se:
$LN1@get_sym_se:

; 790  :     }
; 791  : }

	ret	0
get_sym_seg_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
tv65 = 32
sym$ = 64
get_proc_type PROC

; 765  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 766  :     /* if there's no segment associated with the symbol,
; 767  :      add the symbol's offset size to the distance */
; 768  :     switch( sym->mem_type ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 129		; 00000081H
	je	SHORT $LN4@get_proc_t
	cmp	DWORD PTR tv65[rsp], 130		; 00000082H
	je	SHORT $LN6@get_proc_t
	jmp	SHORT $LN2@get_proc_t
$LN4@get_proc_t:

; 769  :     case MT_NEAR:
; 770  :         if ( sym->segment == NULL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN5@get_proc_t

; 771  :             return( strings[LS_NEAR16 + GetSymOfssize( sym )] );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSymOfssize
	add	eax, 10
	cdqe
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax*8]
	jmp	SHORT $LN1@get_proc_t
$LN5@get_proc_t:

; 772  :         }
; 773  :         return( strings[LS_NEAR] );

	mov	eax, 8
	imul	rax, rax, 9
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@get_proc_t
$LN6@get_proc_t:

; 774  :     case MT_FAR:
; 775  :         if ( sym->segment == NULL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN7@get_proc_t

; 776  :             return( strings[LS_FAR16 + GetSymOfssize( sym )] );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSymOfssize
	add	eax, 14
	cdqe
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax*8]
	jmp	SHORT $LN1@get_proc_t
$LN7@get_proc_t:

; 777  :         }
; 778  :         return( strings[LS_FAR] );

	mov	eax, 8
	imul	rax, rax, 13
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@get_proc_t
$LN2@get_proc_t:

; 779  :     }
; 780  :     return( " " );

	lea	rax, OFFSET FLAT:$SG11708
$LN1@get_proc_t:

; 781  : }

	add	rsp, 56					; 00000038H
	ret	0
get_proc_type ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
sym$ = 8
GetLanguage PROC

; 565  : {

	mov	QWORD PTR [rsp+8], rcx

; 566  :     if ( sym->langtype <= 7 )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+76], 7
	jg	SHORT $LN2@GetLanguag

; 567  :         return( strings[sym->langtype + LS_VOID] );

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+76]
	add	eax, 42					; 0000002aH
	cdqe
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax*8]
	jmp	SHORT $LN1@GetLanguag
$LN2@GetLanguag:

; 568  :     return( "?" );

	lea	rax, OFFSET FLAT:$SG11561
$LN1@GetLanguag:

; 569  : }

	ret	0
GetLanguage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
tv76 = 32
i$1 = 36
mem_type$ = 40
b2$2 = 48
p$ = 56
sym$ = 80
buffer$ = 88
GetMemtypeString PROC

; 495  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 496  :     const char *p;
; 497  :     enum memtype mem_type;
; 498  : 
; 499  :     if ( (sym->mem_type & MT_SPECIAL) == 0 )

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+36]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN7@GetMemtype

; 500  :         return( SimpleTypeString( sym->mem_type ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rax+36]
	call	SimpleTypeString
	jmp	$LN1@GetMemtype
$LN7@GetMemtype:

; 501  : 
; 502  :     /* v2.05: improve display of stack vars */
; 503  :     mem_type = sym->mem_type;

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR mem_type$[rsp], eax

; 504  :     if ( sym->state == SYM_STACK && sym->is_ptr )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 5
	jne	SHORT $LN8@GetMemtype
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+45]
	test	eax, eax
	je	SHORT $LN8@GetMemtype

; 505  :         mem_type = MT_PTR;

	mov	DWORD PTR mem_type$[rsp], 195		; 000000c3H
$LN8@GetMemtype:

; 506  : 
; 507  :     switch ( mem_type ) {

	mov	eax, DWORD PTR mem_type$[rsp]
	mov	DWORD PTR tv76[rsp], eax
	mov	eax, DWORD PTR tv76[rsp]
	sub	eax, 128				; 00000080H
	mov	DWORD PTR tv76[rsp], eax
	cmp	DWORD PTR tv76[rsp], 68			; 00000044H
	ja	$LN2@GetMemtype
	movsxd	rax, DWORD PTR tv76[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN28@GetMemtype[rcx+rax]
	mov	eax, DWORD PTR $LN29@GetMemtype[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN9@GetMemtype:

; 508  :     case MT_PTR:
; 509  : #if AMD64_SUPPORT
; 510  :         if ( sym->Ofssize == USE64 )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	cmp	eax, 2
	jne	SHORT $LN10@GetMemtype

; 511  :             p = strings[LS_NEAR];

	mov	eax, 8
	imul	rax, rax, 9
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN11@GetMemtype
$LN10@GetMemtype:

; 512  :         else
; 513  : #endif
; 514  :             if ( sym->isfar )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@GetMemtype

; 515  :                 p = strings[LS_FAR16 + sym->Ofssize];

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	add	eax, 14
	cdqe
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN13@GetMemtype
$LN12@GetMemtype:

; 516  :             else
; 517  :                 p = strings[LS_NEAR16 + sym->Ofssize];

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	add	eax, 10
	cdqe
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR p$[rsp], rax
$LN13@GetMemtype:
$LN11@GetMemtype:

; 518  : 
; 519  :         if ( buffer ) { /* Currently, 'buffer' is only != NULL for typedefs */

	cmp	QWORD PTR buffer$[rsp], 0
	je	$LN14@GetMemtype

; 520  :             int i;
; 521  :             char *b2 = buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR b2$2[rsp], rax

; 522  :             /* v2.10: improved pointer TYPEDEF display */
; 523  :             for ( i = sym->is_ptr; i; i-- ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+45]
	mov	DWORD PTR i$1[rsp], eax
	jmp	SHORT $LN6@GetMemtype
$LN4@GetMemtype:
	mov	eax, DWORD PTR i$1[rsp]
	dec	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@GetMemtype:
	cmp	DWORD PTR i$1[rsp], 0
	je	SHORT $LN5@GetMemtype

; 524  :                 b2 += sprintf( b2, "%s %s ", p, strings[LS_PTR] );

	mov	eax, 8
	imul	rax, rax, 25
	lea	rcx, OFFSET FLAT:strings
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8, QWORD PTR p$[rsp]
	lea	rdx, OFFSET FLAT:$SG11541
	mov	rcx, QWORD PTR b2$2[rsp]
	call	sprintf
	cdqe
	mov	rcx, QWORD PTR b2$2[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR b2$2[rsp], rax

; 525  :             }

	jmp	SHORT $LN4@GetMemtype
$LN5@GetMemtype:

; 526  :             /* v2.05: added. */
; 527  :             if ( sym->state == SYM_TYPE && sym->typekind == TYPE_TYPEDEF ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN15@GetMemtype
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+66]
	cmp	eax, 3
	jne	SHORT $LN15@GetMemtype

; 528  :                 //strcat( buffer, " ");
; 529  :                 if ( sym->target_type )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN16@GetMemtype

; 530  :                     strcpy( b2, sym->target_type->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR b2$2[rsp]
	call	strcpy
	jmp	SHORT $LN17@GetMemtype
$LN16@GetMemtype:

; 531  :                 else if ( ( sym->ptr_memtype & MT_SPECIAL ) == 0 )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN18@GetMemtype

; 532  :                     strcpy( b2, SimpleTypeString( sym->ptr_memtype ) );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	mov	ecx, eax
	call	SimpleTypeString
	mov	rdx, rax
	mov	rcx, QWORD PTR b2$2[rsp]
	call	strcpy
$LN18@GetMemtype:
$LN17@GetMemtype:
$LN15@GetMemtype:

; 533  :             }
; 534  :             return( buffer );

	mov	rax, QWORD PTR buffer$[rsp]
	jmp	$LN1@GetMemtype
$LN14@GetMemtype:

; 535  :         }
; 536  :         return( p );

	mov	rax, QWORD PTR p$[rsp]
	jmp	$LN1@GetMemtype
$LN19@GetMemtype:

; 537  :     case MT_FAR:
; 538  :         if ( sym->segment )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN20@GetMemtype

; 539  :             return( strings[LS_LFAR] );

	mov	eax, 8
	imul	rax, rax, 21
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	$LN1@GetMemtype
$LN20@GetMemtype:

; 540  :         return( strings[LS_LFAR16 + GetSymOfssize( sym )] );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSymOfssize
	add	eax, 22
	cdqe
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax*8]
	jmp	$LN1@GetMemtype
$LN21@GetMemtype:

; 541  :     case MT_NEAR:
; 542  :         if ( sym->segment )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN22@GetMemtype

; 543  :             return( strings[LS_LNEAR] );

	mov	eax, 8
	imul	rax, rax, 17
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	$LN1@GetMemtype
$LN22@GetMemtype:

; 544  :         return( strings[LS_LNEAR16 + GetSymOfssize( sym )] );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSymOfssize
	add	eax, 18
	cdqe
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax*8]
	jmp	SHORT $LN1@GetMemtype
$LN23@GetMemtype:

; 545  :     case MT_TYPE:
; 546  :         if ( *(sym->type->name) )  /* there are a lot of unnamed types */

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN24@GetMemtype

; 547  :             return( sym->type->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	jmp	SHORT $LN1@GetMemtype
$LN24@GetMemtype:

; 548  :         /* v2.04: changed */
; 549  :         //return( strings[LS_PTR] );
; 550  :         return( GetMemtypeString( sym->type, buffer ) );

	mov	rdx, QWORD PTR buffer$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	GetMemtypeString
	jmp	SHORT $LN1@GetMemtype
$LN25@GetMemtype:

; 551  :     //case MT_ABS: /* v2.07: MT_ABS is obsolete */
; 552  :     case MT_EMPTY: /* number, via EQU or = directive */
; 553  :         return( strings[LS_NUMBER] );

	mov	eax, 8
	imul	rax, rax, 28
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@GetMemtype
$LN26@GetMemtype:

; 554  : #ifdef DEBUG_OUT /* v2.11: obsolete */
; 555  :     case MT_PROC:
; 556  :         printf("GetMemtypeString: found mem_type=MT_PROC for sym=%s\n", sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11554
	call	printf
$LN2@GetMemtype:

; 557  :         break;
; 558  : #endif
; 559  :     }
; 560  :     return("?");

	lea	rax, OFFSET FLAT:$SG11555
$LN1@GetMemtype:

; 561  : }

	add	rsp, 72					; 00000048H
	ret	0
	npad	2
$LN29@GetMemtype:
	DD	$LN26@GetMemtype
	DD	$LN21@GetMemtype
	DD	$LN19@GetMemtype
	DD	$LN25@GetMemtype
	DD	$LN9@GetMemtype
	DD	$LN23@GetMemtype
	DD	$LN2@GetMemtype
$LN28@GetMemtype:
	DB	0
	DB	1
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	6
	DB	6
	DB	4
	DB	5
GetMemtypeString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
tv66 = 0
size$ = 4
mem_type$ = 32
SimpleTypeString PROC

; 474  : {

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 475  :     int size = ( mem_type & MT_SIZE_MASK ) + 1;

	mov	eax, DWORD PTR mem_type$[rsp]
	and	eax, 31
	inc	eax
	mov	DWORD PTR size$[rsp], eax

; 476  :     switch ( size ) {

	mov	eax, DWORD PTR size$[rsp]
	mov	DWORD PTR tv66[rsp], eax
	mov	eax, DWORD PTR tv66[rsp]
	dec	eax
	mov	DWORD PTR tv66[rsp], eax
	cmp	DWORD PTR tv66[rsp], 15
	ja	$LN2@SimpleType
	movsxd	rax, DWORD PTR tv66[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN12@SimpleType[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@SimpleType:

; 477  :     case 1: return( strings[LS_BYTE] );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	$LN1@SimpleType
$LN5@SimpleType:

; 478  :     case 2: return( strings[LS_WORD] );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@SimpleType
$LN6@SimpleType:

; 479  :     case 4: return( strings[LS_DWORD] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@SimpleType
$LN7@SimpleType:

; 480  :     case 6: return( strings[LS_FWORD] );

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@SimpleType
$LN8@SimpleType:

; 481  :     case 8: return( strings[LS_QWORD] );

	mov	eax, 8
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@SimpleType
$LN9@SimpleType:

; 482  :     case 10:return( strings[LS_TBYTE] );

	mov	eax, 8
	imul	rax, rax, 5
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@SimpleType
$LN10@SimpleType:

; 483  :     case 16:return( strings[LS_OWORD] );

	mov	eax, 8
	imul	rax, rax, 7
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@SimpleType
$LN2@SimpleType:

; 484  :     }
; 485  :     return( "" );

	lea	rax, OFFSET FLAT:$SG11517
$LN1@SimpleType:

; 486  : }

	add	rsp, 24
	ret	0
	npad	2
$LN12@SimpleType:
	DD	$LN4@SimpleType
	DD	$LN5@SimpleType
	DD	$LN2@SimpleType
	DD	$LN6@SimpleType
	DD	$LN2@SimpleType
	DD	$LN7@SimpleType
	DD	$LN2@SimpleType
	DD	$LN8@SimpleType
	DD	$LN2@SimpleType
	DD	$LN9@SimpleType
	DD	$LN2@SimpleType
	DD	$LN2@SimpleType
	DD	$LN2@SimpleType
	DD	$LN2@SimpleType
	DD	$LN2@SimpleType
	DD	$LN10@SimpleType
SimpleTypeString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
tv67 = 0
seg$ = 32
get_seg_combine PROC

; 445  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 446  :     switch( seg->combine ) {

	mov	rax, QWORD PTR seg$[rsp]
	movzx	eax, BYTE PTR [rax+108]
	and	al, 7
	mov	BYTE PTR tv67[rsp], al
	cmp	BYTE PTR tv67[rsp], 0
	je	SHORT $LN4@get_seg_co
	cmp	BYTE PTR tv67[rsp], 2
	je	SHORT $LN6@get_seg_co
	cmp	BYTE PTR tv67[rsp], 5
	je	SHORT $LN5@get_seg_co
	cmp	BYTE PTR tv67[rsp], 6
	je	SHORT $LN7@get_seg_co
	jmp	SHORT $LN2@get_seg_co
$LN4@get_seg_co:

; 447  :     case COMB_INVALID:    return( strings[LS_PRIVATE] );

	mov	eax, 8
	imul	rax, rax, 29
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@get_seg_co
$LN5@get_seg_co:

; 448  :     case COMB_STACK:      return( strings[LS_STACK]   );

	mov	eax, 8
	imul	rax, rax, 30
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@get_seg_co
$LN6@get_seg_co:

; 449  :     case COMB_ADDOFF:     return( strings[LS_PUBLIC]  );

	mov	eax, 8
	imul	rax, rax, 31
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@get_seg_co
$LN7@get_seg_co:

; 450  :     /* v2.06: added */
; 451  :     case COMB_COMMON:     return( strings[LS_COMMON]  );

	mov	eax, 8
	imul	rax, rax, 32				; 00000020H
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@get_seg_co
$LN2@get_seg_co:

; 452  :     }
; 453  :     return( "?" );

	lea	rax, OFFSET FLAT:$SG11492
$LN1@get_seg_co:

; 454  : }

	add	rsp, 24
	ret	0
get_seg_combine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
tv66 = 32
tv145 = 36
seg$ = 64
buffer$ = 72
get_seg_align PROC

; 427  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 428  :     switch( seg->alignment ) {

	mov	rax, QWORD PTR seg$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	mov	DWORD PTR tv66[rsp], eax
	cmp	DWORD PTR tv66[rsp], 3
	jg	SHORT $LN13@get_seg_al
	cmp	DWORD PTR tv66[rsp], 3
	je	$LN7@get_seg_al
	cmp	DWORD PTR tv66[rsp], 0
	je	SHORT $LN4@get_seg_al
	cmp	DWORD PTR tv66[rsp], 1
	je	SHORT $LN5@get_seg_al
	cmp	DWORD PTR tv66[rsp], 2
	je	SHORT $LN6@get_seg_al
	jmp	$LN11@get_seg_al
$LN13@get_seg_al:
	cmp	DWORD PTR tv66[rsp], 4
	je	SHORT $LN8@get_seg_al
	cmp	DWORD PTR tv66[rsp], 8
	je	$LN9@get_seg_al
	cmp	DWORD PTR tv66[rsp], 255		; 000000ffH
	je	$LN10@get_seg_al
	jmp	$LN11@get_seg_al
$LN4@get_seg_al:

; 429  :     case 0:    return( strings[LS_BYTE]  );

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	$LN1@get_seg_al
$LN5@get_seg_al:

; 430  :     case 1:    return( strings[LS_WORD]  );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	$LN1@get_seg_al
$LN6@get_seg_al:

; 431  :     case 2:    return( strings[LS_DWORD] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	$LN1@get_seg_al
$LN7@get_seg_al:

; 432  :     case 3:    return( strings[LS_QWORD] );

	mov	eax, 8
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@get_seg_al
$LN8@get_seg_al:

; 433  :     case 4:    return( strings[LS_PARA]  );

	mov	eax, 8
	imul	rax, rax, 6
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@get_seg_al
$LN9@get_seg_al:

; 434  :     case 8:    return( strings[LS_PAGE]  );

	mov	eax, 8
	imul	rax, rax, 8
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@get_seg_al
$LN10@get_seg_al:

; 435  :     case MAX_SEGALIGNMENT:
; 436  :                return( strings[LS_ABS]   );

	mov	eax, 8
	imul	rax, rax, 39				; 00000027H
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	jmp	SHORT $LN1@get_seg_al
$LN11@get_seg_al:

; 437  :     default:
; 438  :         sprintf( buffer, "%u", 1 << seg->alignment );

	mov	rax, QWORD PTR seg$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	mov	ecx, 1
	mov	DWORD PTR tv145[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv145[rsp]
	shl	eax, cl
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG11481
	mov	rcx, QWORD PTR buffer$[rsp]
	call	sprintf

; 439  :         return( buffer );

	mov	rax, QWORD PTR buffer$[rsp]
$LN1@get_seg_al:

; 440  :     }
; 441  : }

	add	rsp, 56					; 00000038H
	ret	0
get_seg_align ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
Ofssize$ = 64
i$ = 68
f$ = 72
l$ = 80
cnt$1 = 88
pdots$ = 96
l2$2 = 104
dir$ = 112
curr$3 = 120
p$ = 128
tv91 = 136
tv95 = 140
tv328 = 144
tv332 = 148
sym2$4 = 152
tv73 = 160
tv159 = 168
tv219 = 176
tv254 = 184
tv271 = 192
tv302 = 200
tv363 = 208
tv76 = 216
tv177 = 224
tv275 = 232
tv366 = 240
buffer$5 = 248
__$ArrayPad$ = 280
sym$ = 304
log_proc PROC

; 797  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 296				; 00000128H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 798  :     struct dsym *f;
; 799  :     struct dsym *l;
; 800  :     const char *p;
; 801  :     struct dsym *dir = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR dir$[rsp], rax

; 802  :     int i = sym->name_size;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	DWORD PTR i$[rsp], eax

; 803  :     char Ofssize = GetSymOfssize( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetSymOfssize
	mov	BYTE PTR Ofssize$[rsp], al

; 804  :     const char *pdots;
; 805  : 
; 806  :     pdots = (( i >= DOTSMAX ) ? "" : dots + i + 1 );

	cmp	DWORD PTR i$[rsp], 32			; 00000020H
	jl	SHORT $LN46@log_proc
	lea	rax, OFFSET FLAT:$SG11761
	mov	QWORD PTR tv73[rsp], rax
	jmp	SHORT $LN47@log_proc
$LN46@log_proc:
	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:dots
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR tv73[rsp], rax
$LN47@log_proc:
	mov	rax, QWORD PTR tv73[rsp]
	mov	QWORD PTR pdots$[rsp], rax

; 807  :     if ( Ofssize )

	movsx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	je	SHORT $LN23@log_proc

; 808  :         p = "%s %s        P %-6s %08" I32_SPEC "X %-8s ";

	lea	rax, OFFSET FLAT:$SG11764
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN24@log_proc
$LN23@log_proc:

; 809  :     else
; 810  :         p = "%s %s        P %-6s %04" I32_SPEC "X     %-8s ";

	lea	rax, OFFSET FLAT:$SG11765
	mov	QWORD PTR p$[rsp], rax
$LN24@log_proc:

; 811  :     LstPrintf( p,

	mov	rcx, QWORD PTR sym$[rsp]
	call	get_sym_seg_name
	mov	QWORD PTR tv76[rsp], rax
	mov	rcx, QWORD PTR sym$[rsp]
	call	get_proc_type
	mov	rcx, QWORD PTR tv76[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9, rax
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR p$[rsp]
	call	LstPrintf

; 812  :               sym->name,
; 813  :               pdots,
; 814  :               get_proc_type( sym ),
; 815  :               sym->offset,
; 816  :               get_sym_seg_name( sym ));
; 817  : 
; 818  :     /* externals (PROTO) don't have a size. Masm always prints 0000 or 00000000 */
; 819  :     LstPrintf( "%0*" I32_SPEC "X ", Ofssize > USE16 ? 8 : 4, sym->state == SYM_INTERNAL ? sym->total_size : 0 );

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN48@log_proc
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR tv91[rsp], eax
	jmp	SHORT $LN49@log_proc
$LN48@log_proc:
	mov	DWORD PTR tv91[rsp], 0
$LN49@log_proc:
	movsx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	jle	SHORT $LN50@log_proc
	mov	DWORD PTR tv95[rsp], 8
	jmp	SHORT $LN51@log_proc
$LN50@log_proc:
	mov	DWORD PTR tv95[rsp], 4
$LN51@log_proc:
	mov	r8d, DWORD PTR tv91[rsp]
	mov	edx, DWORD PTR tv95[rsp]
	lea	rcx, OFFSET FLAT:$SG11766
	call	LstPrintf

; 820  : 
; 821  : #ifdef DEBUG_OUT
; 822  :     if ( sym->fwdref )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN25@log_proc

; 823  :         LstPrintf( "(F) " );

	lea	rcx, OFFSET FLAT:$SG11768
	call	LstPrintf
$LN25@log_proc:

; 824  : #endif
; 825  :     if( sym->ispublic ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN26@log_proc

; 826  :         LstPrintf( "%-9s", strings[LS_PUBLIC] );

	mov	eax, 8
	imul	rax, rax, 31
	lea	rcx, OFFSET FLAT:strings
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG11771
	call	LstPrintf
	jmp	$LN27@log_proc
$LN26@log_proc:

; 827  :     } else if ( sym->state == SYM_INTERNAL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN28@log_proc

; 828  :         LstPrintf( "%-9s", strings[LS_PRIVATE] );

	mov	eax, 8
	imul	rax, rax, 29
	lea	rcx, OFFSET FLAT:strings
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG11774
	call	LstPrintf

; 829  :     } else {

	jmp	$LN29@log_proc
$LN28@log_proc:

; 830  :         LstPrintf( sym->weak ? "*%-8s " : "%-9s ", strings[LS_EXTERNAL] );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN52@log_proc
	lea	rax, OFFSET FLAT:$SG11775
	mov	QWORD PTR tv159[rsp], rax
	jmp	SHORT $LN53@log_proc
$LN52@log_proc:
	lea	rax, OFFSET FLAT:$SG11776
	mov	QWORD PTR tv159[rsp], rax
$LN53@log_proc:
	mov	eax, 8
	imul	rax, rax, 33				; 00000021H
	lea	rcx, OFFSET FLAT:strings
	mov	rdx, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR tv159[rsp]
	call	LstPrintf

; 831  : #if DLLIMPORT
; 832  :         if ( sym->dll )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN30@log_proc

; 833  :             LstPrintf( "(%.8s) ", sym->dll->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+56]
	add	rax, 12
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11778
	call	LstPrintf
$LN30@log_proc:
$LN29@log_proc:
$LN27@log_proc:

; 834  : #endif
; 835  :     }
; 836  : 
; 837  :     LstPrintf( "%s", GetLanguage( sym ) );

	mov	rcx, QWORD PTR sym$[rsp]
	call	GetLanguage
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11779
	call	LstPrintf

; 838  :     LstNL();

	call	LstNL

; 839  :     /* for PROTOs, list optional altname */
; 840  :     if ( sym->state == SYM_EXTERNAL && sym->altname ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	$LN31@log_proc
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+64], 0
	je	$LN31@log_proc

; 841  :         struct asym *sym2 = sym->altname;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR sym2$4[rsp], rax

; 842  :         LstPrintf( "  ");

	lea	rcx, OFFSET FLAT:$SG11781
	call	LstPrintf

; 843  :         LstPrintf( p,

	mov	rcx, QWORD PTR sym2$4[rsp]
	call	get_sym_seg_name
	mov	QWORD PTR tv177[rsp], rax
	mov	rcx, QWORD PTR sym2$4[rsp]
	call	get_proc_type
	mov	rcx, QWORD PTR pdots$[rsp]
	add	rcx, 2
	mov	rdx, QWORD PTR tv177[rsp]
	mov	QWORD PTR [rsp+40], rdx
	mov	rdx, QWORD PTR sym2$4[rsp]
	mov	edx, DWORD PTR [rdx+16]
	mov	DWORD PTR [rsp+32], edx
	mov	r9, rax
	mov	r8, rcx
	mov	rax, QWORD PTR sym2$4[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR p$[rsp]
	call	LstPrintf

; 844  :                   sym2->name,
; 845  :                   pdots+2,
; 846  :                   get_proc_type( sym2 ),
; 847  :                   sym2->offset,
; 848  :                   get_sym_seg_name( sym2 ));
; 849  :         LstNL();

	call	LstNL
$LN31@log_proc:

; 850  :     }
; 851  :     /* for PROCs, list parameters and locals */
; 852  :     if ( sym->state == SYM_INTERNAL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	$LN32@log_proc

; 853  : 
; 854  :         /* print the procedure's parameters */
; 855  :         if ( sym->langtype == LANG_C ||
; 856  :             sym->langtype == LANG_SYSCALL ||
; 857  :             sym->langtype == LANG_STDCALL ||

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+76], 1
	je	SHORT $LN35@log_proc
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+76], 2
	je	SHORT $LN35@log_proc
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+76], 3
	je	SHORT $LN35@log_proc
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+76], 7
	jne	$LN33@log_proc
$LN35@log_proc:

; 858  :             sym->langtype == LANG_FASTCALL ) {
; 859  :             int cnt;
; 860  :             /* position f2 to last param */
; 861  :             for ( cnt = 0, f = dir->e.procinfo->paralist; f; f = f->nextparam )

	mov	DWORD PTR cnt$1[rsp], 0
	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR f$[rsp], rax
	jmp	SHORT $LN4@log_proc
$LN2@log_proc:
	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR f$[rsp], rax
$LN4@log_proc:
	cmp	QWORD PTR f$[rsp], 0
	je	SHORT $LN3@log_proc

; 862  :                 cnt++;

	mov	eax, DWORD PTR cnt$1[rsp]
	inc	eax
	mov	DWORD PTR cnt$1[rsp], eax
	jmp	SHORT $LN2@log_proc
$LN3@log_proc:

; 863  :             for ( ; cnt; cnt-- ) {

	jmp	SHORT $LN7@log_proc
$LN5@log_proc:
	mov	eax, DWORD PTR cnt$1[rsp]
	dec	eax
	mov	DWORD PTR cnt$1[rsp], eax
$LN7@log_proc:
	cmp	DWORD PTR cnt$1[rsp], 0
	je	$LN6@log_proc

; 864  :                 int curr;
; 865  :                 for ( curr = 1,f = dir->e.procinfo->paralist; curr < cnt;f = f->nextparam, curr++ );

	mov	DWORD PTR curr$3[rsp], 1
	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR f$[rsp], rax
	jmp	SHORT $LN10@log_proc
$LN8@log_proc:
	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR f$[rsp], rax
	mov	eax, DWORD PTR curr$3[rsp]
	inc	eax
	mov	DWORD PTR curr$3[rsp], eax
$LN10@log_proc:
	mov	eax, DWORD PTR cnt$1[rsp]
	cmp	DWORD PTR curr$3[rsp], eax
	jge	SHORT $LN9@log_proc
	jmp	SHORT $LN8@log_proc
$LN9@log_proc:

; 866  :                 i = f->sym.name_size;

	mov	rax, QWORD PTR f$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	DWORD PTR i$[rsp], eax

; 867  :                 pdots = (( i >= DOTSMAX-2 ) ? "" : dots + i + 1 + 2 );

	cmp	DWORD PTR i$[rsp], 30
	jl	SHORT $LN54@log_proc
	lea	rax, OFFSET FLAT:$SG11786
	mov	QWORD PTR tv219[rsp], rax
	jmp	SHORT $LN55@log_proc
$LN54@log_proc:
	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:dots
	lea	rax, QWORD PTR [rcx+rax+3]
	mov	QWORD PTR tv219[rsp], rax
$LN55@log_proc:
	mov	rax, QWORD PTR tv219[rsp]
	mov	QWORD PTR pdots$[rsp], rax

; 868  :                 /* FASTCALL: parameter may be a text macro (=register name) */
; 869  :                 if ( f->sym.state == SYM_TMACRO )

	mov	rax, QWORD PTR f$[rsp]
	cmp	DWORD PTR [rax+32], 10
	jne	SHORT $LN36@log_proc

; 870  :                     LstPrintf( "  %s %s        %-17s %s", f->sym.name, pdots, GetMemtypeString( &f->sym, NULL ), f->sym.string_ptr );

	mov	rax, QWORD PTR f$[rsp]
	xor	edx, edx
	mov	rcx, rax
	call	GetMemtypeString
	mov	rcx, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rax
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rax, QWORD PTR f$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11789
	call	LstPrintf
	jmp	$LN37@log_proc
$LN36@log_proc:

; 871  :                 else
; 872  :                     LstPrintf( szFmtProcStk, f->sym.name, pdots,

	mov	rax, QWORD PTR f$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN56@log_proc
	mov	eax, 8
	imul	rax, rax, 41				; 00000029H
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR tv254[rsp], rax
	jmp	SHORT $LN57@log_proc
$LN56@log_proc:
	mov	rax, QWORD PTR f$[rsp]
	xor	edx, edx
	mov	rcx, rax
	call	GetMemtypeString
	mov	QWORD PTR tv254[rsp], rax
$LN57@log_proc:
	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, WORD PTR [rax+130]
	xor	edx, edx
	mov	ecx, eax
	call	GetResWName
	mov	rcx, QWORD PTR f$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rsp+48], ecx
	mov	DWORD PTR [rsp+40], 43			; 0000002bH
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv254[rsp]
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rax, QWORD PTR f$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:szFmtProcStk
	call	LstPrintf
$LN37@log_proc:

; 873  :                             f->sym.is_vararg ? strings[LS_VARARG] : GetMemtypeString( &f->sym, NULL ),
; 874  : #if STACKBASESUPP
; 875  :                               GetResWName( dir->e.procinfo->basereg, NULL ),
; 876  : #else
; 877  :                               GetResWName( basereg[Ofssize], NULL ),
; 878  : #endif
; 879  :                             '+', f->sym.offset );
; 880  :                 LstNL();

	call	LstNL

; 881  :             }

	jmp	$LN5@log_proc
$LN6@log_proc:

; 882  :         } else {

	jmp	$LN34@log_proc
$LN33@log_proc:

; 883  :             for ( f = dir->e.procinfo->paralist; f; f = f->nextparam ) {

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR f$[rsp], rax
	jmp	SHORT $LN13@log_proc
$LN11@log_proc:
	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR f$[rsp], rax
$LN13@log_proc:
	cmp	QWORD PTR f$[rsp], 0
	je	$LN12@log_proc

; 884  :                 i = f->sym.name_size;

	mov	rax, QWORD PTR f$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	DWORD PTR i$[rsp], eax

; 885  :                 pdots = (( i >= DOTSMAX-2 ) ? "" : dots + i + 1 + 2 );

	cmp	DWORD PTR i$[rsp], 30
	jl	SHORT $LN58@log_proc
	lea	rax, OFFSET FLAT:$SG11790
	mov	QWORD PTR tv271[rsp], rax
	jmp	SHORT $LN59@log_proc
$LN58@log_proc:
	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:dots
	lea	rax, QWORD PTR [rcx+rax+3]
	mov	QWORD PTR tv271[rsp], rax
$LN59@log_proc:
	mov	rax, QWORD PTR tv271[rsp]
	mov	QWORD PTR pdots$[rsp], rax

; 886  :                 LstPrintf( szFmtProcStk, f->sym.name, pdots, GetMemtypeString( &f->sym, NULL ),

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, WORD PTR [rax+130]
	xor	edx, edx
	mov	ecx, eax
	call	GetResWName
	mov	QWORD PTR tv275[rsp], rax
	mov	rcx, QWORD PTR f$[rsp]
	xor	edx, edx
	call	GetMemtypeString
	mov	rcx, QWORD PTR f$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rsp+48], ecx
	mov	DWORD PTR [rsp+40], 43			; 0000002bH
	mov	rcx, QWORD PTR tv275[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rax
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rax, QWORD PTR f$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:szFmtProcStk
	call	LstPrintf

; 887  : #if STACKBASESUPP
; 888  :                           GetResWName( dir->e.procinfo->basereg, NULL ),
; 889  : #else
; 890  :                           GetResWName( basereg[Ofssize], NULL ),
; 891  : #endif
; 892  :                           '+', f->sym.offset );
; 893  :                 LstNL();

	call	LstNL

; 894  :             }

	jmp	$LN11@log_proc
$LN12@log_proc:
$LN34@log_proc:

; 895  :         }
; 896  : 
; 897  :         /* print the procedure's locals */
; 898  :         for ( l = dir->e.procinfo->locallist; l; l = l->nextlocal ) {

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR l$[rsp], rax
	jmp	SHORT $LN16@log_proc
$LN14@log_proc:
	mov	rax, QWORD PTR l$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR l$[rsp], rax
$LN16@log_proc:
	cmp	QWORD PTR l$[rsp], 0
	je	$LN15@log_proc

; 899  :             char buffer[32];
; 900  :             i = l->sym.name_size;

	mov	rax, QWORD PTR l$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	DWORD PTR i$[rsp], eax

; 901  :             pdots = (( i >= DOTSMAX-2 ) ? "" : dots + i + 1 + 2);

	cmp	DWORD PTR i$[rsp], 30
	jl	SHORT $LN60@log_proc
	lea	rax, OFFSET FLAT:$SG11791
	mov	QWORD PTR tv302[rsp], rax
	jmp	SHORT $LN61@log_proc
$LN60@log_proc:
	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:dots
	lea	rax, QWORD PTR [rcx+rax+3]
	mov	QWORD PTR tv302[rsp], rax
$LN61@log_proc:
	mov	rax, QWORD PTR tv302[rsp]
	mov	QWORD PTR pdots$[rsp], rax

; 902  :             if ( l->sym.isarray )

	mov	rax, QWORD PTR l$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN38@log_proc

; 903  :                 sprintf( buffer, "%s[%" I32_SPEC "u]", GetMemtypeString(&l->sym, NULL), l->sym.total_length );

	mov	rax, QWORD PTR l$[rsp]
	xor	edx, edx
	mov	rcx, rax
	call	GetMemtypeString
	mov	rcx, QWORD PTR l$[rsp]
	mov	r9d, DWORD PTR [rcx+64]
	mov	r8, rax
	lea	rdx, OFFSET FLAT:$SG11794
	lea	rcx, QWORD PTR buffer$5[rsp]
	call	sprintf
	jmp	SHORT $LN39@log_proc
$LN38@log_proc:

; 904  :             else
; 905  :                 strcpy( buffer, GetMemtypeString( &l->sym, NULL ) );

	mov	rax, QWORD PTR l$[rsp]
	xor	edx, edx
	mov	rcx, rax
	call	GetMemtypeString
	mov	rdx, rax
	lea	rcx, QWORD PTR buffer$5[rsp]
	call	strcpy
$LN39@log_proc:

; 906  :             LstPrintf( szFmtProcStk, l->sym.name, pdots, buffer,

	mov	rax, QWORD PTR l$[rsp]
	cmp	DWORD PTR [rax+16], 0
	jl	SHORT $LN62@log_proc
	mov	rax, QWORD PTR l$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv328[rsp], eax
	jmp	SHORT $LN63@log_proc
$LN62@log_proc:
	mov	rax, QWORD PTR l$[rsp]
	mov	eax, DWORD PTR [rax+16]
	neg	eax
	mov	DWORD PTR tv328[rsp], eax
$LN63@log_proc:
	mov	rax, QWORD PTR l$[rsp]
	cmp	DWORD PTR [rax+16], 0
	jl	SHORT $LN64@log_proc
	mov	DWORD PTR tv332[rsp], 43		; 0000002bH
	jmp	SHORT $LN65@log_proc
$LN64@log_proc:
	mov	DWORD PTR tv332[rsp], 45		; 0000002dH
$LN65@log_proc:
	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, WORD PTR [rax+130]
	xor	edx, edx
	mov	ecx, eax
	call	GetResWName
	mov	ecx, DWORD PTR tv328[rsp]
	mov	DWORD PTR [rsp+48], ecx
	mov	ecx, DWORD PTR tv332[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR buffer$5[rsp]
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rax, QWORD PTR l$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:szFmtProcStk
	call	LstPrintf

; 907  : #if STACKBASESUPP
; 908  :                       GetResWName( dir->e.procinfo->basereg, NULL ),
; 909  :                       l->sym.offset >= 0 ? '+' : '-', l->sym.offset >= 0 ? l->sym.offset : - l->sym.offset );
; 910  : #else
; 911  :                       GetResWName( basereg[Ofssize], NULL ),
; 912  :                       '-', - l->sym.offset );
; 913  : #endif
; 914  :             LstNL();

	call	LstNL

; 915  :         }

	jmp	$LN14@log_proc
$LN15@log_proc:

; 916  : 
; 917  :         for ( l = dir->e.procinfo->labellist; l ; l = l->e.nextll ) {

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR l$[rsp], rax
	jmp	SHORT $LN19@log_proc
$LN17@log_proc:
	mov	rax, QWORD PTR l$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR l$[rsp], rax
$LN19@log_proc:
	cmp	QWORD PTR l$[rsp], 0
	je	$LN18@log_proc

; 918  :             struct dsym *l2;
; 919  :             for ( l2 = l; l2; l2 = (struct dsym *)l2->sym.nextitem ) {

	mov	rax, QWORD PTR l$[rsp]
	mov	QWORD PTR l2$2[rsp], rax
	jmp	SHORT $LN22@log_proc
$LN20@log_proc:
	mov	rax, QWORD PTR l2$2[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR l2$2[rsp], rax
$LN22@log_proc:
	cmp	QWORD PTR l2$2[rsp], 0
	je	$LN21@log_proc

; 920  :                 /* filter params and locals! */
; 921  :                 if ( l2->sym.state == SYM_STACK || l2->sym.state == SYM_TMACRO )

	mov	rax, QWORD PTR l2$2[rsp]
	cmp	DWORD PTR [rax+32], 5
	je	SHORT $LN41@log_proc
	mov	rax, QWORD PTR l2$2[rsp]
	cmp	DWORD PTR [rax+32], 10
	jne	SHORT $LN40@log_proc
$LN41@log_proc:

; 922  :                     continue;

	jmp	SHORT $LN20@log_proc
$LN40@log_proc:

; 923  :                 i = l2->sym.name_size;

	mov	rax, QWORD PTR l2$2[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	DWORD PTR i$[rsp], eax

; 924  :                 pdots = (( i >= DOTSMAX-2 ) ? "" : dots + i + 1 + 2);

	cmp	DWORD PTR i$[rsp], 30
	jl	SHORT $LN66@log_proc
	lea	rax, OFFSET FLAT:$SG11797
	mov	QWORD PTR tv363[rsp], rax
	jmp	SHORT $LN67@log_proc
$LN66@log_proc:
	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:dots
	lea	rax, QWORD PTR [rcx+rax+3]
	mov	QWORD PTR tv363[rsp], rax
$LN67@log_proc:
	mov	rax, QWORD PTR tv363[rsp]
	mov	QWORD PTR pdots$[rsp], rax

; 925  :                 if ( Ofssize )

	movsx	eax, BYTE PTR Ofssize$[rsp]
	test	eax, eax
	je	SHORT $LN42@log_proc

; 926  :                     p = "  %s %s        L %-6s %08" I32_SPEC "X %s";

	lea	rax, OFFSET FLAT:$SG11800
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN43@log_proc
$LN42@log_proc:

; 927  :                 else
; 928  :                     p = "  %s %s        L %-6s %04" I32_SPEC "X     %s";

	lea	rax, OFFSET FLAT:$SG11801
	mov	QWORD PTR p$[rsp], rax
$LN43@log_proc:

; 929  :                 LstPrintf( p,

	mov	rax, QWORD PTR l2$2[rsp]
	mov	rcx, rax
	call	get_sym_seg_name
	mov	QWORD PTR tv366[rsp], rax
	mov	rcx, QWORD PTR l2$2[rsp]
	call	get_proc_type
	mov	rcx, QWORD PTR tv366[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR l2$2[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9, rax
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rax, QWORD PTR l2$2[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR p$[rsp]
	call	LstPrintf

; 930  :                           l2->sym.name,
; 931  :                           pdots,
; 932  :                           get_proc_type( &l2->sym ),
; 933  :                           l2->sym.offset,
; 934  :                           get_sym_seg_name( &l2->sym ));
; 935  : #ifdef DEBUG_OUT
; 936  :                 if ( l2->sym.fwdref )

	mov	rax, QWORD PTR l2$2[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN44@log_proc

; 937  :                     LstPrintf( " (F)" );

	lea	rcx, OFFSET FLAT:$SG11803
	call	LstPrintf
$LN44@log_proc:

; 938  : #endif
; 939  :                 LstNL();

	call	LstNL

; 940  :             }

	jmp	$LN20@log_proc
$LN21@log_proc:

; 941  :         }

	jmp	$LN17@log_proc
$LN18@log_proc:
$LN32@log_proc:

; 942  :     }
; 943  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 296				; 00000128H
	ret	0
log_proc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
i$ = 32
curr$ = 40
tv70 = 48
pdots$ = 56
grp$ = 80
segs$ = 88
log_group PROC

; 742  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 743  :     unsigned i;
; 744  :     const char *pdots;
; 745  :     struct seg_item *curr;
; 746  : 
; 747  :     i = grp->name_size;

	mov	rax, QWORD PTR grp$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	DWORD PTR i$[rsp], eax

; 748  :     pdots = (( i >= DOTSMAX ) ? "" : dots + i + 1);

	cmp	DWORD PTR i$[rsp], 32			; 00000020H
	jb	SHORT $LN11@log_group
	lea	rax, OFFSET FLAT:$SG11692
	mov	QWORD PTR tv70[rsp], rax
	jmp	SHORT $LN12@log_group
$LN11@log_group:
	mov	eax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:dots
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR tv70[rsp], rax
$LN12@log_group:
	mov	rax, QWORD PTR tv70[rsp]
	mov	QWORD PTR pdots$[rsp], rax

; 749  :     LstPrintf( "%s %s        %s", grp->name, pdots, strings[LS_GROUP] );

	mov	eax, 8
	imul	rax, rax, 35				; 00000023H
	lea	rcx, OFFSET FLAT:strings
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rax, QWORD PTR grp$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11693
	call	LstPrintf

; 750  :     LstNL();

	call	LstNL

; 751  : 
; 752  :     /* the FLAT groups is always empty */
; 753  :     if ( grp == (struct asym *)ModuleInfo.flat_grp ) {

	mov	rax, QWORD PTR ModuleInfo+440
	cmp	QWORD PTR grp$[rsp], rax
	jne	SHORT $LN8@log_group

; 754  :         for( ; segs; segs = segs->next ) {

	jmp	SHORT $LN4@log_group
$LN2@log_group:
	mov	rax, QWORD PTR segs$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR segs$[rsp], rax
$LN4@log_group:
	cmp	QWORD PTR segs$[rsp], 0
	je	SHORT $LN3@log_group

; 755  :             log_segment( (struct asym *)segs, grp );

	mov	rdx, QWORD PTR grp$[rsp]
	mov	rcx, QWORD PTR segs$[rsp]
	call	log_segment

; 756  :         }

	jmp	SHORT $LN2@log_group
$LN3@log_group:

; 757  :     } else

	jmp	SHORT $LN9@log_group
$LN8@log_group:

; 758  :         for( curr = ((struct dsym *)grp)->e.grpinfo->seglist; curr; curr = curr->next ) {

	mov	rax, QWORD PTR grp$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN7@log_group
$LN5@log_group:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$[rsp], rax
$LN7@log_group:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN6@log_group

; 759  :             log_segment( (struct asym *)curr->seg, grp );

	mov	rdx, QWORD PTR grp$[rsp]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	log_segment

; 760  :         }

	jmp	SHORT $LN5@log_group
$LN6@log_group:
$LN9@log_group:

; 761  : }

	add	rsp, 72					; 00000048H
	ret	0
log_group ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
seg$ = 32
i$1 = 40
tv73 = 48
tv137 = 56
pdots$2 = 64
tv93 = 72
buffer$ = 80
__$ArrayPad$ = 112
sym$ = 144
group$ = 152
log_segment PROC

; 710  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 711  :     char buffer[32];
; 712  :     struct seg_info *seg = ((struct dsym *)sym)->e.seginfo;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR seg$[rsp], rax

; 713  : 
; 714  :     if( seg->group == group ) {

	mov	rax, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR group$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	$LN2@log_segmen

; 715  :         int i = sym->name_size;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	DWORD PTR i$1[rsp], eax

; 716  :         const char *pdots;
; 717  :         pdots = (( i >= DOTSMAX ) ? "" : dots + i + 1);

	cmp	DWORD PTR i$1[rsp], 32			; 00000020H
	jl	SHORT $LN8@log_segmen
	lea	rax, OFFSET FLAT:$SG11662
	mov	QWORD PTR tv73[rsp], rax
	jmp	SHORT $LN9@log_segmen
$LN8@log_segmen:
	movsxd	rax, DWORD PTR i$1[rsp]
	lea	rcx, OFFSET FLAT:dots
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR tv73[rsp], rax
$LN9@log_segmen:
	mov	rax, QWORD PTR tv73[rsp]
	mov	QWORD PTR pdots$2[rsp], rax

; 718  :         LstPrintf( "%s %s        ", sym->name, pdots );

	mov	r8, QWORD PTR pdots$2[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11663
	call	LstPrintf

; 719  :         if( seg->Ofssize == USE32 ) {

	mov	rax, QWORD PTR seg$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	cmp	eax, 1
	jne	SHORT $LN3@log_segmen

; 720  :             //LstPrintf( "32 Bit   %08" I32_SPEC "X ", seg->current_loc );
; 721  :             LstPrintf( "32 Bit   %08" I32_SPEC "X ", sym->max_offset );

	mov	rax, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR [rax+56]
	lea	rcx, OFFSET FLAT:$SG11666
	call	LstPrintf
	jmp	SHORT $LN4@log_segmen
$LN3@log_segmen:

; 722  : #if AMD64_SUPPORT
; 723  :         } else if( seg->Ofssize == USE64 ) {

	mov	rax, QWORD PTR seg$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	cmp	eax, 2
	jne	SHORT $LN5@log_segmen

; 724  :             LstPrintf( "64 Bit   %08" I32_SPEC "X ", sym->max_offset );

	mov	rax, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR [rax+56]
	lea	rcx, OFFSET FLAT:$SG11669
	call	LstPrintf

; 725  : #endif
; 726  :         } else {

	jmp	SHORT $LN6@log_segmen
$LN5@log_segmen:

; 727  :             //LstPrintf( "16 Bit   %04" I32_SPEC "X     ", seg->current_loc );
; 728  :             LstPrintf( "16 Bit   %04" I32_SPEC "X     ", sym->max_offset );

	mov	rax, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR [rax+56]
	lea	rcx, OFFSET FLAT:$SG11670
	call	LstPrintf
$LN6@log_segmen:
$LN4@log_segmen:

; 729  :         }
; 730  :         LstPrintf( "%-7s %-8s", get_seg_align( seg, buffer ), get_seg_combine( seg ) );

	mov	rcx, QWORD PTR seg$[rsp]
	call	get_seg_combine
	mov	QWORD PTR tv93[rsp], rax
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR seg$[rsp]
	call	get_seg_align
	mov	rcx, QWORD PTR tv93[rsp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11671
	call	LstPrintf

; 731  :         LstPrintf( "'%s'", seg->clsym ? seg->clsym->name : "" );

	mov	rax, QWORD PTR seg$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN10@log_segmen
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv137[rsp], rax
	jmp	SHORT $LN11@log_segmen
$LN10@log_segmen:
	lea	rax, OFFSET FLAT:$SG11672
	mov	QWORD PTR tv137[rsp], rax
$LN11@log_segmen:
	mov	rdx, QWORD PTR tv137[rsp]
	lea	rcx, OFFSET FLAT:$SG11673
	call	LstPrintf

; 732  : #if 0
; 733  :         if ( group != NULL )
; 734  :             LstPrintf( " %s", group->name );
; 735  : #endif
; 736  :         LstNL();

	call	LstNL
$LN2@log_segmen:

; 737  :     }
; 738  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
log_segment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
i$ = 48
tv128 = 52
p$ = 56
tv70 = 64
pdots$ = 72
sym$ = 96
log_typedef PROC

; 676  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 677  :     //struct dsym         *dir = (struct dsym *)sym;
; 678  :     //struct struct_info  *si = dir->e.structinfo;
; 679  :     char *p;
; 680  :     int i = sym->name_size;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	DWORD PTR i$[rsp], eax

; 681  :     const char *pdots;
; 682  :     //char buffer[256];
; 683  : 
; 684  :     pdots = (( i >= DOTSMAX ) ? "" : dots + i + 1 );

	cmp	DWORD PTR i$[rsp], 32			; 00000020H
	jl	SHORT $LN6@log_typede
	lea	rax, OFFSET FLAT:$SG11643
	mov	QWORD PTR tv70[rsp], rax
	jmp	SHORT $LN7@log_typede
$LN6@log_typede:
	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:dots
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR tv70[rsp], rax
$LN7@log_typede:
	mov	rax, QWORD PTR tv70[rsp]
	mov	QWORD PTR pdots$[rsp], rax

; 685  :     p = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR p$[rsp], rax

; 686  :     *p = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 0

; 687  :     if ( sym->mem_type == MT_PROC && sym->target_type ) { /* typedef proto? */

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 128			; 00000080H
	jne	$LN2@log_typede
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	$LN2@log_typede

; 688  :         strcat( p, strings[LS_PROC] );

	mov	eax, 8
	imul	rax, rax, 26
	lea	rcx, OFFSET FLAT:strings
	mov	rdx, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR p$[rsp]
	call	strcat

; 689  :         strcat( p, " " );

	lea	rdx, OFFSET FLAT:$SG11646
	mov	rcx, QWORD PTR p$[rsp]
	call	strcat

; 690  :         if ( *sym->target_type->name ) {  /* the name may be "" */

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN4@log_typede

; 691  :             strcat( p, sym->target_type->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR p$[rsp]
	call	strcat

; 692  :             strcat( p," ");

	lea	rdx, OFFSET FLAT:$SG11648
	mov	rcx, QWORD PTR p$[rsp]
	call	strcat
$LN4@log_typede:

; 693  :         }
; 694  :         /* v2.11: target_type has state SYM_TYPE (since v2.09).
; 695  :          * This state isn't handled properly by GetSymOfsSize(), which is called by GetMemtypeString(),
; 696  :          * so get the strings here.
; 697  :          */
; 698  :         //strcat( p, GetMemtypeString( sym->target_type, NULL ) );
; 699  :         strcat( p, strings[( sym->target_type->mem_type == MT_NEAR ? LS_LNEAR16 : LS_LFAR16 ) + sym->Ofssize ] );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+48]
	cmp	DWORD PTR [rax+36], 129			; 00000081H
	jne	SHORT $LN8@log_typede
	mov	DWORD PTR tv128[rsp], 18
	jmp	SHORT $LN9@log_typede
$LN8@log_typede:
	mov	DWORD PTR tv128[rsp], 22
$LN9@log_typede:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	ecx, DWORD PTR tv128[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	lea	rcx, OFFSET FLAT:strings
	mov	rdx, QWORD PTR [rcx+rax*8]
	mov	rcx, QWORD PTR p$[rsp]
	call	strcat

; 700  :         strcat( p," " );

	lea	rdx, OFFSET FLAT:$SG11649
	mov	rcx, QWORD PTR p$[rsp]
	call	strcat

; 701  :         strcat( p, GetLanguage( sym->target_type ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rax+48]
	call	GetLanguage
	mov	rdx, rax
	mov	rcx, QWORD PTR p$[rsp]
	call	strcat

; 702  :     } else

	jmp	SHORT $LN3@log_typede
$LN2@log_typede:

; 703  :         p = (char *)GetMemtypeString( sym, p );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	GetMemtypeString
	mov	QWORD PTR p$[rsp], rax
$LN3@log_typede:

; 704  :     LstPrintf( "%s %s    %8" I32_SPEC "u  %s", sym->name, pdots, sym->total_size, p );

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+56]
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11650
	call	LstPrintf

; 705  :     LstNL();

	call	LstNL

; 706  : }

	add	rsp, 88					; 00000058H
	ret	0
log_typedef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
i$ = 64
f$ = 72
mask$ = 80
pdots$ = 88
tv71 = 96
si$ = 104
tv94 = 112
tv143 = 120
tv160 = 128
dir$ = 136
tv207 = 144
sym$ = 176
log_record PROC

; 634  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 635  : #if AMD64_SUPPORT
; 636  :     uint_64         mask;
; 637  : #else
; 638  :     uint_32         mask;
; 639  : #endif
; 640  :     struct dsym     *dir = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR dir$[rsp], rax

; 641  :     struct struct_info *si = dir->e.structinfo;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR si$[rsp], rax

; 642  :     struct sfield   *f;
; 643  :     int i = sym->name_size;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	DWORD PTR i$[rsp], eax

; 644  :     const char *pdots;
; 645  : 
; 646  :     pdots = ((i >= DOTSMAX) ? "" : dots + i + 1 );

	cmp	DWORD PTR i$[rsp], 32			; 00000020H
	jl	SHORT $LN14@log_record
	lea	rax, OFFSET FLAT:$SG11627
	mov	QWORD PTR tv71[rsp], rax
	jmp	SHORT $LN15@log_record
$LN14@log_record:
	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:dots
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR tv71[rsp], rax
$LN15@log_record:
	mov	rax, QWORD PTR tv71[rsp]
	mov	QWORD PTR pdots$[rsp], rax

; 647  :     for( i = 0,f = si->head; f; f = f->next,i++ );

	mov	DWORD PTR i$[rsp], 0
	mov	rax, QWORD PTR si$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR f$[rsp], rax
	jmp	SHORT $LN4@log_record
$LN2@log_record:
	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR f$[rsp], rax
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@log_record:
	cmp	QWORD PTR f$[rsp], 0
	je	SHORT $LN3@log_record
	jmp	SHORT $LN2@log_record
$LN3@log_record:

; 648  :     LstPrintf( "%s %s      %6" I32_SPEC "X  %7X", sym->name, pdots, sym->total_size*8, i );

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+56]
	shl	eax, 3
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, eax
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11628
	call	LstPrintf

; 649  :     LstNL();

	call	LstNL

; 650  :     for( f = si->head; f; f = f->next ) {

	mov	rax, QWORD PTR si$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR f$[rsp], rax
	jmp	SHORT $LN7@log_record
$LN5@log_record:
	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR f$[rsp], rax
$LN7@log_record:
	cmp	QWORD PTR f$[rsp], 0
	je	$LN6@log_record

; 651  :         i = f->sym.name_size + 2;

	mov	rax, QWORD PTR f$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	add	eax, 2
	mov	DWORD PTR i$[rsp], eax

; 652  :         pdots = ((i >= DOTSMAX) ? "" : dots + i + 1 );

	cmp	DWORD PTR i$[rsp], 32			; 00000020H
	jl	SHORT $LN16@log_record
	lea	rax, OFFSET FLAT:$SG11629
	mov	QWORD PTR tv94[rsp], rax
	jmp	SHORT $LN17@log_record
$LN16@log_record:
	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:dots
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR tv94[rsp], rax
$LN17@log_record:
	mov	rax, QWORD PTR tv94[rsp]
	mov	QWORD PTR pdots$[rsp], rax

; 653  :         for ( i = f->sym.offset, mask = 0; i < f->sym.offset + f->sym.total_size; i++ )

	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR i$[rsp], eax
	mov	QWORD PTR mask$[rsp], 0
	jmp	SHORT $LN10@log_record
$LN8@log_record:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@log_record:
	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR f$[rsp]
	add	eax, DWORD PTR [rcx+56]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN9@log_record

; 654  : #if AMD64_SUPPORT
; 655  : #if defined(LLONG_MAX) || defined(__GNUC__) || defined(__TINYC__)
; 656  :             mask |= 1ULL << i;

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, 1
	mov	QWORD PTR tv207[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv207[rsp]
	shl	rax, cl
	mov	rcx, QWORD PTR mask$[rsp]
	or	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR mask$[rsp], rax
	jmp	SHORT $LN8@log_record
$LN9@log_record:

; 657  : #else
; 658  :             mask |= 1i64 << i;
; 659  : #endif
; 660  :         if ( sym->total_size > 4 )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+56], 4
	jbe	SHORT $LN11@log_record

; 661  :             LstPrintf( "  %s %s      %6" I32_SPEC "X  %7" I32_SPEC "X  %016" I64_SPEC "X %s", f->sym.name, pdots, f->sym.offset, f->sym.total_size, mask, f->ivalue[0] ? f->ivalue : "?" );

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR f$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+104]
	test	eax, eax
	je	SHORT $LN18@log_record
	mov	rax, QWORD PTR f$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv143[rsp], rax
	jmp	SHORT $LN19@log_record
$LN18@log_record:
	lea	rax, OFFSET FLAT:$SG11632
	mov	QWORD PTR tv143[rsp], rax
$LN19@log_record:
	mov	rax, QWORD PTR tv143[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR mask$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR f$[rsp]
	mov	r9d, DWORD PTR [rax+16]
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rax, QWORD PTR f$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11633
	call	LstPrintf
	jmp	SHORT $LN12@log_record
$LN11@log_record:

; 662  :         else
; 663  :             LstPrintf( "  %s %s      %6" I32_SPEC "X  %7" I32_SPEC "X  %08" I32_SPEC "X %s", f->sym.name, pdots, f->sym.offset, f->sym.total_size, (uint_32)mask, f->ivalue[0] ? f->ivalue : "?" );

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR f$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+104]
	test	eax, eax
	je	SHORT $LN20@log_record
	mov	rax, QWORD PTR f$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv160[rsp], rax
	jmp	SHORT $LN21@log_record
$LN20@log_record:
	lea	rax, OFFSET FLAT:$SG11634
	mov	QWORD PTR tv160[rsp], rax
$LN21@log_record:
	mov	rax, QWORD PTR tv160[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR mask$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR f$[rsp]
	mov	r9d, DWORD PTR [rax+16]
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rax, QWORD PTR f$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11635
	call	LstPrintf
$LN12@log_record:

; 664  : #else
; 665  :             mask |= 1 << i;
; 666  :         LstPrintf( "  %s %s      %6" I32_SPEC "X  %7" I32_SPEC "X  %08" I32_SPEC "X %s", f->sym.name, pdots, f->sym.offset, f->sym.total_size, mask, f->ivalue[0] ? f->ivalue : "?" );
; 667  : #endif
; 668  :         LstNL();

	call	LstNL

; 669  :     }

	jmp	$LN5@log_record
$LN6@log_record:

; 670  : }

	add	rsp, 168				; 000000a8H
	ret	0
log_record ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
i$ = 48
f$ = 56
pdots$ = 64
tv77 = 72
dir$ = 80
si$ = 88
tv168 = 96
sym$ = 128
name$ = 136
ofs$ = 144
log_struct PROC

; 575  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 576  :     unsigned      i;
; 577  :     struct dsym   *dir;
; 578  :     const char    *pdots;
; 579  :     struct struct_info *si;
; 580  :     struct sfield *f;
; 581  :     static int    prefix = 0;
; 582  : 
; 583  :     dir = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR dir$[rsp], rax

; 584  : 
; 585  :     /* filter typedefs and records */
; 586  :     //if ( dir->sym.typekind != TYPE_STRUCT &&
; 587  :     //     dir->sym.typekind != TYPE_UNION )
; 588  :     //    return;
; 589  : 
; 590  :     si = dir->e.structinfo;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR si$[rsp], rax

; 591  : 
; 592  :     if ( !name )

	cmp	QWORD PTR name$[rsp], 0
	jne	SHORT $LN11@log_struct

; 593  :         name = sym->name;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR name$[rsp], rax
$LN11@log_struct:

; 594  :     i = strlen ( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax

; 595  :     pdots = (( (i+prefix) >= DOTSMAX) ? "" : dots + i + prefix + 1 );

	mov	eax, DWORD PTR ?prefix@?1??log_struct@@9@9
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, 32					; 00000020H
	jb	SHORT $LN22@log_struct
	lea	rax, OFFSET FLAT:$SG11588
	mov	QWORD PTR tv77[rsp], rax
	jmp	SHORT $LN23@log_struct
$LN22@log_struct:
	mov	eax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:dots
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR ?prefix@?1??log_struct@@9@9
	lea	rax, QWORD PTR [rax+rcx+1]
	mov	QWORD PTR tv77[rsp], rax
$LN23@log_struct:
	mov	rax, QWORD PTR tv77[rsp]
	mov	QWORD PTR pdots$[rsp], rax

; 596  :     for ( i = 0; i < prefix; i++ )

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@log_struct
$LN2@log_struct:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@log_struct:
	mov	eax, DWORD PTR ?prefix@?1??log_struct@@9@9
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN3@log_struct

; 597  :         LstPrintf(" ");

	lea	rcx, OFFSET FLAT:$SG11589
	call	LstPrintf
	jmp	SHORT $LN2@log_struct
$LN3@log_struct:

; 598  :     if ( prefix == 0 )

	cmp	DWORD PTR ?prefix@?1??log_struct@@9@9, 0
	jne	SHORT $LN12@log_struct

; 599  :         if ( dir->e.structinfo->alignment > 1)

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+28]
	cmp	eax, 1
	jle	SHORT $LN14@log_struct

; 600  :             LstPrintf( "%s %s        %8" I32_SPEC "X (%u)", name, pdots, sym->total_size, si->alignment );

	mov	rax, QWORD PTR si$[rsp]
	movzx	eax, BYTE PTR [rax+28]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+56]
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11594
	call	LstPrintf
	jmp	SHORT $LN15@log_struct
$LN14@log_struct:

; 601  :         else
; 602  :             LstPrintf( "%s %s        %8" I32_SPEC "X", name, pdots, sym->total_size );

	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+56]
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11595
	call	LstPrintf
$LN15@log_struct:
	jmp	SHORT $LN13@log_struct
$LN12@log_struct:

; 603  :     else
; 604  :         LstPrintf( "%s %s        %8" I32_SPEC "X", name, pdots, sym->offset + ofs);

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	add	eax, DWORD PTR ofs$[rsp]
	mov	r9d, eax
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11596
	call	LstPrintf
$LN13@log_struct:

; 605  :     LstNL();

	call	LstNL

; 606  :     prefix += 2;

	mov	eax, DWORD PTR ?prefix@?1??log_struct@@9@9
	add	eax, 2
	mov	DWORD PTR ?prefix@?1??log_struct@@9@9, eax

; 607  :     for( f = si->head; f; f = f->next ) {

	mov	rax, QWORD PTR si$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR f$[rsp], rax
	jmp	SHORT $LN7@log_struct
$LN5@log_struct:
	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR f$[rsp], rax
$LN7@log_struct:
	cmp	QWORD PTR f$[rsp], 0
	je	$LN6@log_struct

; 608  :         /* recursion if an embedded struct occurs */
; 609  :         /* v2.09: field init_dir removed */
; 610  :         //if ( f->sym->mem_type == MT_TYPE && f->init_dir == NULL ) {
; 611  :         if ( f->sym.mem_type == MT_TYPE && f->ivalue[0] == NULLC ) {

	mov	rax, QWORD PTR f$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN16@log_struct
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR f$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+104]
	test	eax, eax
	jne	SHORT $LN16@log_struct

; 612  :             log_struct( f->sym.type, f->sym.name, f->sym.offset + ofs );

	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+16]
	add	eax, DWORD PTR ofs$[rsp]
	mov	r8d, eax
	mov	rax, QWORD PTR f$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	log_struct

; 613  :         } else {

	jmp	$LN17@log_struct
$LN16@log_struct:

; 614  :             /* don't list unstructured fields without name */
; 615  :             /* but do list them if they are structured */
; 616  :             if (*(f->sym.name) || (f->sym.mem_type == MT_TYPE)) {

	mov	rax, QWORD PTR f$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN19@log_struct
	mov	rax, QWORD PTR f$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	$LN18@log_struct
$LN19@log_struct:

; 617  :                 i = f->sym.name_size + prefix;

	mov	rax, QWORD PTR f$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	add	eax, DWORD PTR ?prefix@?1??log_struct@@9@9
	mov	DWORD PTR i$[rsp], eax

; 618  :                 pdots = ((i >= DOTSMAX) ? "" : dots + i + 1 );

	cmp	DWORD PTR i$[rsp], 32			; 00000020H
	jb	SHORT $LN24@log_struct
	lea	rax, OFFSET FLAT:$SG11601
	mov	QWORD PTR tv168[rsp], rax
	jmp	SHORT $LN25@log_struct
$LN24@log_struct:
	mov	eax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:dots
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR tv168[rsp], rax
$LN25@log_struct:
	mov	rax, QWORD PTR tv168[rsp]
	mov	QWORD PTR pdots$[rsp], rax

; 619  :                 for ( i = 0; i < prefix; i++ )

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN10@log_struct
$LN8@log_struct:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@log_struct:
	mov	eax, DWORD PTR ?prefix@?1??log_struct@@9@9
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN9@log_struct

; 620  :                     LstPrintf(" ");

	lea	rcx, OFFSET FLAT:$SG11602
	call	LstPrintf
	jmp	SHORT $LN8@log_struct
$LN9@log_struct:

; 621  :                 LstPrintf( "%s %s        %8" I32_SPEC "X   ", f->sym.name, pdots, f->sym.offset + sym->offset + ofs);

	mov	rax, QWORD PTR f$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR sym$[rsp]
	add	eax, DWORD PTR [rcx+16]
	add	eax, DWORD PTR ofs$[rsp]
	mov	r9d, eax
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rax, QWORD PTR f$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11603
	call	LstPrintf

; 622  :                 LstPrintf( "%s", GetMemtypeString( &f->sym, NULL ) );

	mov	rax, QWORD PTR f$[rsp]
	xor	edx, edx
	mov	rcx, rax
	call	GetMemtypeString
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11604
	call	LstPrintf

; 623  :                 if ( f->sym.isarray )

	mov	rax, QWORD PTR f$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@log_struct

; 624  :                     LstPrintf( "[%u]",f->sym.total_length );

	mov	rax, QWORD PTR f$[rsp]
	mov	edx, DWORD PTR [rax+64]
	lea	rcx, OFFSET FLAT:$SG11606
	call	LstPrintf
$LN20@log_struct:

; 625  :                 LstNL();

	call	LstNL
$LN18@log_struct:
$LN17@log_struct:

; 626  :             }
; 627  :         }
; 628  :     }

	jmp	$LN5@log_struct
$LN6@log_struct:

; 629  :     prefix -= 2;

	mov	eax, DWORD PTR ?prefix@?1??log_struct@@9@9
	sub	eax, 2
	mov	DWORD PTR ?prefix@?1??log_struct@@9@9, eax

; 630  : }

	add	rsp, 120				; 00000078H
	ret	0
log_struct ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
i$ = 32
tv75 = 40
tv80 = 48
type$ = 56
pdots$ = 64
sym$ = 96
log_macro PROC

; 458  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 459  :     int i = sym->name_size;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	DWORD PTR i$[rsp], eax

; 460  :     const char *pdots;
; 461  :     const char *type = (sym->isfunc) ? strings[LS_FUNC] : strings[LS_PROC];

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@log_macro
	mov	eax, 8
	imul	rax, rax, 27
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR tv75[rsp], rax
	jmp	SHORT $LN4@log_macro
$LN3@log_macro:
	mov	eax, 8
	imul	rax, rax, 26
	lea	rcx, OFFSET FLAT:strings
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR tv75[rsp], rax
$LN4@log_macro:
	mov	rax, QWORD PTR tv75[rsp]
	mov	QWORD PTR type$[rsp], rax

; 462  : 
; 463  :     pdots = ((i >= DOTSMAX) ? "" : dots + i + 1 );

	cmp	DWORD PTR i$[rsp], 32			; 00000020H
	jl	SHORT $LN5@log_macro
	lea	rax, OFFSET FLAT:$SG11500
	mov	QWORD PTR tv80[rsp], rax
	jmp	SHORT $LN6@log_macro
$LN5@log_macro:
	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:dots
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR tv80[rsp], rax
$LN6@log_macro:
	mov	rax, QWORD PTR tv80[rsp]
	mov	QWORD PTR pdots$[rsp], rax

; 464  :     LstPrintf( "%s %s        %s", sym->name, pdots ,type );

	mov	r9, QWORD PTR type$[rsp]
	mov	r8, QWORD PTR pdots$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11501
	call	LstPrintf

; 465  : #ifdef DEBUG_OUT
; 466  :     LstPrintf( " %5lu", ((struct dsym *)sym)->e.macroinfo->count );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	edx, DWORD PTR [rax+24]
	lea	rcx, OFFSET FLAT:$SG11502
	call	LstPrintf

; 467  : #endif
; 468  :     LstNL();

	call	LstNL

; 469  :     return;
; 470  : }

	add	rsp, 88					; 00000058H
	ret	0
log_macro ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
LstSetPosition PROC

; 416  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 417  :     if( CurrFile[LST] && ( Parse_Pass > PASS_1 ) && UseSavedState && ModuleInfo.GeneratedCode == 0 ) {

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN2@LstSetPosi
	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN2@LstSetPosi
	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	je	SHORT $LN2@LstSetPosi
	cmp	DWORD PTR ModuleInfo+456, 0
	jne	SHORT $LN2@LstSetPosi

; 418  :         list_pos = LineStoreCurr->list_pos;

	mov	rax, QWORD PTR LineStoreCurr
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR list_pos, eax

; 419  :         fseek( CurrFile[LST], list_pos, SEEK_SET );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	xor	r8d, r8d
	mov	edx, DWORD PTR list_pos
	mov	rcx, QWORD PTR [rcx+rax]
	call	fseek

; 420  :         ModuleInfo.line_flags |= LOF_SKIPPOS;

	movzx	eax, BYTE PTR ModuleInfo+398
	or	eax, 2
	mov	BYTE PTR ModuleInfo+398, al
$LN2@LstSetPosi:

; 421  :     }
; 422  : }

	add	rsp, 40					; 00000028H
	ret	0
LstSetPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
LstNL	PROC

; 401  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 402  :     if( CurrFile[LST] ) {

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN2@LstNL

; 403  :         fwrite( NLSTR, 1, NLSIZ, CurrFile[LST] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 2
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11461
	call	fwrite

; 404  :         list_pos += NLSIZ;

	mov	eax, DWORD PTR list_pos
	add	eax, 2
	mov	DWORD PTR list_pos, eax
$LN2@LstNL:

; 405  :     }
; 406  : }

	add	rsp, 40					; 00000028H
	ret	0
LstNL	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
args$ = 32
format$ = 64
LstPrintf PROC

; 389  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 390  :     va_list     args;
; 391  : 
; 392  :     if( CurrFile[LST] ) {

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN2@LstPrintf

; 393  :         va_start( args, format );

	lea	rax, QWORD PTR format$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 394  :         list_pos += vfprintf( CurrFile[LST], format, args );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r8, QWORD PTR args$[rsp]
	mov	rdx, QWORD PTR format$[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	vfprintf
	mov	ecx, DWORD PTR list_pos
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR list_pos, eax

; 395  :         va_end( args );

	mov	QWORD PTR args$[rsp], 0
$LN2@LstPrintf:

; 396  :     }
; 397  : }

	add	rsp, 56					; 00000038H
	ret	0
LstPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
i$ = 32
idx$ = 36
syms$ = 40
tv134 = 48
tv144 = 52
SymCount$ = 56
tv212 = 60
ps$1 = 64
q$2 = 72
dir$ = 80
tv243 = 88
tv299 = 96
tv229 = 104
si$ = 112
queues$ = 128
__$ArrayPad$ = 256
LstWriteCRef PROC

; 1044 : {

$LN47:
	sub	rsp, 280				; 00000118H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1045 :     struct asym     **syms;
; 1046 :     struct dsym     *dir;
; 1047 :     struct struct_info *si;
; 1048 :     int             idx;
; 1049 :     uint_32         i;
; 1050 :     uint_32         SymCount;
; 1051 :     struct qdesc    queues[LQ_LAST];
; 1052 : 
; 1053 :     /* no point going through the motions if lst file isn't open */
; 1054 :     if( CurrFile[LST] == NULL || Options.no_symbol_listing == TRUE ) {

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN22@LstWriteCR
	movzx	eax, BYTE PTR Options+152
	cmp	eax, 1
	jne	SHORT $LN21@LstWriteCR
$LN22@LstWriteCR:

; 1055 :         return;

	jmp	$LN1@LstWriteCR
$LN21@LstWriteCR:

; 1056 :     }
; 1057 : 
; 1058 :     /* go to EOF */
; 1059 :     fseek( CurrFile[LST], 0, SEEK_END );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r8d, 2
	xor	edx, edx
	mov	rcx, QWORD PTR [rcx+rax]
	call	fseek

; 1060 : 
; 1061 :     SymCount = SymGetCount();

	call	SymGetCount
	mov	DWORD PTR SymCount$[rsp], eax

; 1062 :     syms = MemAlloc( SymCount * sizeof( struct asym * ) );

	mov	eax, DWORD PTR SymCount$[rsp]
	shl	rax, 3
	mov	rcx, rax
	call	MemAlloc
	mov	QWORD PTR syms$[rsp], rax

; 1063 :     SymGetAll( syms );

	mov	rcx, QWORD PTR syms$[rsp]
	call	SymGetAll

; 1064 : 
; 1065 :     DebugMsg(("LstWriteCRef: calling qsort\n"));

	lea	rcx, OFFSET FLAT:$SG11916
	call	DoDebugMsg

; 1066 :     /* sort 'em */
; 1067 :     qsort( syms, SymCount, sizeof( struct asym * ), compare_syms );

	mov	eax, DWORD PTR SymCount$[rsp]
	lea	r9, OFFSET FLAT:compare_syms
	mov	r8d, 8
	mov	edx, eax
	mov	rcx, QWORD PTR syms$[rsp]
	call	qsort

; 1068 : 
; 1069 :     memset( queues, 0, sizeof( queues ) );

	mov	r8d, 128				; 00000080H
	xor	edx, edx
	lea	rcx, QWORD PTR queues$[rsp]
	call	memset

; 1070 :     for( i = 0; i < SymCount; ++i ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@LstWriteCR
$LN2@LstWriteCR:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@LstWriteCR:
	mov	eax, DWORD PTR SymCount$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	$LN3@LstWriteCR

; 1071 :         struct qdesc *q;
; 1072 :         if ( syms[i]->list == FALSE )

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR syms$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	eax, BYTE PTR [rax+41]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN23@LstWriteCR

; 1073 :             continue;

	jmp	SHORT $LN2@LstWriteCR
$LN23@LstWriteCR:

; 1074 :         switch (syms[i]->state) {

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR syms$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv134[rsp], eax
	mov	eax, DWORD PTR tv134[rsp]
	dec	eax
	mov	DWORD PTR tv134[rsp], eax
	cmp	DWORD PTR tv134[rsp], 8
	ja	$LN34@LstWriteCR
	movsxd	rax, DWORD PTR tv134[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN46@LstWriteCR[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN24@LstWriteCR:

; 1075 :         case SYM_TYPE:
; 1076 :             si = ((struct dsym *)syms[i])->e.structinfo;

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR syms$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR si$[rsp], rax

; 1077 :             switch ( syms[i]->typekind ) {

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR syms$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	eax, BYTE PTR [rax+66]
	mov	BYTE PTR tv144[rsp], al
	cmp	BYTE PTR tv144[rsp], 0
	jbe	SHORT $LN28@LstWriteCR
	cmp	BYTE PTR tv144[rsp], 2
	jbe	SHORT $LN27@LstWriteCR
	cmp	BYTE PTR tv144[rsp], 3
	je	SHORT $LN26@LstWriteCR
	cmp	BYTE PTR tv144[rsp], 4
	je	SHORT $LN25@LstWriteCR
	jmp	SHORT $LN28@LstWriteCR
$LN25@LstWriteCR:

; 1078 :             case TYPE_RECORD:  idx = LQ_RECORDS; break;

	mov	DWORD PTR idx$[rsp], 3
	jmp	SHORT $LN7@LstWriteCR
$LN26@LstWriteCR:

; 1079 :             case TYPE_TYPEDEF: idx = LQ_TYPEDEFS;break;

	mov	DWORD PTR idx$[rsp], 4
	jmp	SHORT $LN7@LstWriteCR
$LN27@LstWriteCR:

; 1080 :             case TYPE_STRUCT:
; 1081 :             case TYPE_UNION:   idx = LQ_STRUCTS ;break;

	mov	DWORD PTR idx$[rsp], 1
	jmp	SHORT $LN7@LstWriteCR
$LN28@LstWriteCR:

; 1082 : #ifdef DEBUG_OUT
; 1083 :             default:           idx = LQ_UNDEF_TYPES ;break;

	mov	DWORD PTR idx$[rsp], 2
$LN7@LstWriteCR:

; 1084 : #else
; 1085 :             default: continue; /* skip "undefined" types */
; 1086 : #endif
; 1087 :             }
; 1088 :             break;

	jmp	SHORT $LN5@LstWriteCR
$LN29@LstWriteCR:

; 1089 :         case SYM_MACRO:
; 1090 :             idx = LQ_MACROS;

	mov	DWORD PTR idx$[rsp], 0

; 1091 :             break;

	jmp	SHORT $LN5@LstWriteCR
$LN30@LstWriteCR:

; 1092 :         case SYM_SEG:
; 1093 :             idx = LQ_SEGS;

	mov	DWORD PTR idx$[rsp], 5

; 1094 :             break;

	jmp	SHORT $LN5@LstWriteCR
$LN31@LstWriteCR:

; 1095 :         case SYM_GRP:
; 1096 :             idx = LQ_GRPS;

	mov	DWORD PTR idx$[rsp], 6

; 1097 :             break;

	jmp	SHORT $LN5@LstWriteCR
$LN32@LstWriteCR:

; 1098 :         case SYM_INTERNAL:
; 1099 :         case SYM_EXTERNAL: /* v2.04: added, since PROTOs are now externals */
; 1100 :             if ( syms[i]->isproc ) {

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR syms$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN33@LstWriteCR

; 1101 :                 idx = LQ_PROCS;

	mov	DWORD PTR idx$[rsp], 7

; 1102 :                 break;

	jmp	SHORT $LN5@LstWriteCR
$LN33@LstWriteCR:
$LN34@LstWriteCR:

; 1103 :             }
; 1104 :             /* no break */
; 1105 :         default:
; 1106 :             continue;

	jmp	$LN2@LstWriteCR
$LN5@LstWriteCR:

; 1107 :         }
; 1108 :         q = &queues[idx];

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 16
	lea	rax, QWORD PTR queues$[rsp+rax]
	mov	QWORD PTR q$2[rsp], rax

; 1109 :         if( q->head == NULL ) {

	mov	rax, QWORD PTR q$2[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN35@LstWriteCR

; 1110 :             q->head = syms[i];

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR q$2[rsp]
	mov	rdx, QWORD PTR syms$[rsp]
	mov	rax, QWORD PTR [rdx+rax*8]
	mov	QWORD PTR [rcx], rax

; 1111 :         } else {

	jmp	SHORT $LN36@LstWriteCR
$LN35@LstWriteCR:

; 1112 :             ((struct dsym *)q->tail)->next = (struct dsym *)syms[i];

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR q$2[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rdx, QWORD PTR syms$[rsp]
	mov	rax, QWORD PTR [rdx+rax*8]
	mov	QWORD PTR [rcx+104], rax
$LN36@LstWriteCR:

; 1113 :         }
; 1114 :         q->tail = syms[i];

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR q$2[rsp]
	mov	rdx, QWORD PTR syms$[rsp]
	mov	rax, QWORD PTR [rdx+rax*8]
	mov	QWORD PTR [rcx+8], rax

; 1115 :         ((struct dsym *)syms[i])->next = NULL;

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR syms$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR [rax+104], 0

; 1116 :     }

	jmp	$LN2@LstWriteCR
$LN3@LstWriteCR:

; 1117 :     for ( idx = 0; idx < ( sizeof( cr ) / sizeof(cr[0] ) ); idx++ ) {

	mov	DWORD PTR idx$[rsp], 0
	jmp	SHORT $LN11@LstWriteCR
$LN9@LstWriteCR:
	mov	eax, DWORD PTR idx$[rsp]
	inc	eax
	mov	DWORD PTR idx$[rsp], eax
$LN11@LstWriteCR:
	movsxd	rax, DWORD PTR idx$[rsp]
	cmp	rax, 8
	jae	$LN10@LstWriteCR

; 1118 :         if ( queues[cr[idx].type].head ) {

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cr
	movsx	rax, WORD PTR [rcx+rax]
	imul	rax, rax, 16
	cmp	QWORD PTR queues$[rsp+rax], 0
	je	$LN37@LstWriteCR

; 1119 :             if ( cr[idx].capitems ) {

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cr
	cmp	QWORD PTR [rcx+rax+8], 0
	je	$LN38@LstWriteCR

; 1120 :                 const short *ps;
; 1121 :                 for ( ps = cr[idx].capitems; *ps; ps++ ) {

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cr
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR ps$1[rsp], rax
	jmp	SHORT $LN14@LstWriteCR
$LN12@LstWriteCR:
	mov	rax, QWORD PTR ps$1[rsp]
	add	rax, 2
	mov	QWORD PTR ps$1[rsp], rax
$LN14@LstWriteCR:
	mov	rax, QWORD PTR ps$1[rsp]
	movsx	eax, WORD PTR [rax]
	test	eax, eax
	je	SHORT $LN13@LstWriteCR

; 1122 :                     //if ( *ps == -1 )
; 1123 :                     //    LstNL();
; 1124 :                     //else
; 1125 :                         LstCaption( strings[ *ps ], ps == cr[idx].capitems ? 2 : 0 );

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cr
	mov	rax, QWORD PTR [rcx+rax+8]
	cmp	QWORD PTR ps$1[rsp], rax
	jne	SHORT $LN42@LstWriteCR
	mov	DWORD PTR tv212[rsp], 2
	jmp	SHORT $LN43@LstWriteCR
$LN42@LstWriteCR:
	mov	DWORD PTR tv212[rsp], 0
$LN43@LstWriteCR:
	mov	rax, QWORD PTR ps$1[rsp]
	movsx	rax, WORD PTR [rax]
	lea	rcx, OFFSET FLAT:strings
	mov	edx, DWORD PTR tv212[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	LstCaption

; 1126 :                 }

	jmp	SHORT $LN12@LstWriteCR
$LN13@LstWriteCR:
$LN38@LstWriteCR:

; 1127 :             }
; 1128 :             for( dir = queues[cr[idx].type].head; dir ; dir = dir->next ) {

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cr
	movsx	rax, WORD PTR [rcx+rax]
	imul	rax, rax, 16
	mov	rax, QWORD PTR queues$[rsp+rax]
	mov	QWORD PTR dir$[rsp], rax
	jmp	SHORT $LN17@LstWriteCR
$LN15@LstWriteCR:
	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR dir$[rsp], rax
$LN17@LstWriteCR:
	cmp	QWORD PTR dir$[rsp], 0
	je	SHORT $LN16@LstWriteCR

; 1129 :                 cr[idx].function( &dir->sym, ( cr[idx].flags & PRF_ADDSEG ) ? queues[LQ_SEGS].head : NULL, 0 );

	movsxd	rax, DWORD PTR idx$[rsp]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:cr
	movsx	eax, WORD PTR [rcx+rax+2]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN44@LstWriteCR
	mov	eax, 16
	imul	rax, rax, 5
	mov	rax, QWORD PTR queues$[rsp+rax]
	mov	QWORD PTR tv243[rsp], rax
	jmp	SHORT $LN45@LstWriteCR
$LN44@LstWriteCR:
	mov	QWORD PTR tv243[rsp], 0
$LN45@LstWriteCR:
	mov	rax, QWORD PTR dir$[rsp]
	movsxd	rcx, DWORD PTR idx$[rsp]
	imul	rcx, rcx, 24
	mov	QWORD PTR tv229[rsp], rcx
	lea	rdx, OFFSET FLAT:cr
	mov	QWORD PTR tv299[rsp], rdx
	xor	r8d, r8d
	mov	rdx, QWORD PTR tv243[rsp]
	mov	rcx, rax
	mov	r9, QWORD PTR tv299[rsp]
	mov	rax, QWORD PTR tv229[rsp]
	call	QWORD PTR [r9+rax+16]

; 1130 :             }

	jmp	$LN15@LstWriteCR
$LN16@LstWriteCR:
$LN37@LstWriteCR:

; 1131 :         }
; 1132 :     }

	jmp	$LN9@LstWriteCR
$LN10@LstWriteCR:

; 1133 : 
; 1134 :     /* write out symbols */
; 1135 :     LstCaption( strings[ LS_TXT_SYMBOLS ], 2 );

	mov	eax, 8
	imul	rax, rax, 62				; 0000003eH
	lea	rcx, OFFSET FLAT:strings
	mov	edx, 2
	mov	rcx, QWORD PTR [rcx+rax]
	call	LstCaption

; 1136 :     LstCaption( strings[ LS_TXT_SYMCAP ], 0 );

	mov	eax, 8
	imul	rax, rax, 63				; 0000003fH
	lea	rcx, OFFSET FLAT:strings
	xor	edx, edx
	mov	rcx, QWORD PTR [rcx+rax]
	call	LstCaption

; 1137 :     for( i = 0; i < SymCount; ++i ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN20@LstWriteCR
$LN18@LstWriteCR:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN20@LstWriteCR:
	mov	eax, DWORD PTR SymCount$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	$LN19@LstWriteCR

; 1138 :         if ( syms[i]->list == TRUE && syms[i]->isproc == FALSE ) {

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR syms$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	eax, BYTE PTR [rax+41]
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN39@LstWriteCR
	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR syms$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN39@LstWriteCR

; 1139 :             DebugMsg(("LstWriteCRef: log_symbol( %s )\n", syms[i]->name ));

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR syms$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11935
	call	DoDebugMsg

; 1140 :             log_symbol( syms[i] );

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR syms$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	log_symbol

; 1141 :         }

	jmp	SHORT $LN40@LstWriteCR
$LN39@LstWriteCR:

; 1142 : #ifdef DEBUG_OUT
; 1143 :         else
; 1144 :             DebugMsg(("LstWriteCRef: %s suppressed\n", syms[i]->name ));

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR syms$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11936
	call	DoDebugMsg
$LN40@LstWriteCR:

; 1145 : #endif
; 1146 :     }

	jmp	$LN18@LstWriteCR
$LN19@LstWriteCR:

; 1147 :     LstNL();

	call	LstNL

; 1148 : 
; 1149 :     /* free the sorted symbols */
; 1150 :     DebugMsg(("LstWriteCRef: free sorted symbols\n"));

	lea	rcx, OFFSET FLAT:$SG11937
	call	DoDebugMsg

; 1151 :     MemFree( syms );

	mov	rcx, QWORD PTR syms$[rsp]
	call	MemFree
$LN1@LstWriteCR:

; 1152 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 280				; 00000118H
	ret	0
	npad	3
$LN46@LstWriteCR:
	DD	$LN32@LstWriteCR
	DD	$LN32@LstWriteCR
	DD	$LN30@LstWriteCR
	DD	$LN31@LstWriteCR
	DD	$LN34@LstWriteCR
	DD	$LN34@LstWriteCR
	DD	$LN24@LstWriteCR
	DD	$LN34@LstWriteCR
	DD	$LN29@LstWriteCR
LstWriteCRef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
LstWriteSrcLine PROC

; 383  : {

$LN3:
	sub	rsp, 40					; 00000028H

; 384  :     LstWrite( LSTTYPE_MACRO, 0, NULL );

	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, 5
	call	LstWrite

; 385  : }

	add	rsp, 40					; 00000028H
	ret	0
LstWriteSrcLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
idx$ = 0
len$ = 4
p2$ = 8
pll$ = 16
len2$ = 24
sym$ = 32
newofs$ = 40
pSrcline$ = 48
tv151 = 56
srcfile$ = 60
p1$ = 64
tv79 = 72
next$1 = 80
tv391 = 88
tv450 = 96
ll$ = 104
__$ArrayPad$ = 152
type$ = 176
oldofs$ = 184
value$ = 192
LstWrite PROC

; 141  : {

$LN74:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 208				; 000000d0H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax

; 142  :     uint_32 newofs;
; 143  :     struct asym *sym = value;

	mov	rax, QWORD PTR value$[rbp]
	mov	QWORD PTR sym$[rbp], rax

; 144  :     int     len;
; 145  :     int     len2;
; 146  :     int     idx;
; 147  :     int     srcfile;
; 148  :     char    *p1;
; 149  :     char    *p2;
; 150  :     char    *pSrcline;
; 151  :     struct lstleft *pll;
; 152  :     struct lstleft ll;
; 153  :     //char    buffer2[MAX_LINE_LEN]; /* stores text macro value */
; 154  : 
; 155  :     if ( ModuleInfo.list == FALSE || CurrFile[LST] == NULL || ( ModuleInfo.line_flags & LOF_LISTED ) )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN19@LstWrite
	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN19@LstWrite
	movzx	eax, BYTE PTR ModuleInfo+398
	and	eax, 1
	test	eax, eax
	je	SHORT $LN18@LstWrite
$LN19@LstWrite:

; 156  :         return;

	jmp	$LN1@LstWrite
$LN18@LstWrite:

; 157  :     if ( ModuleInfo.GeneratedCode && ( ModuleInfo.list_generated_code == FALSE ) )

	cmp	DWORD PTR ModuleInfo+456, 0
	je	SHORT $LN20@LstWrite
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 14
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN20@LstWrite

; 158  :         return;

	jmp	$LN1@LstWrite
$LN20@LstWrite:

; 159  :     if ( MacroLevel ) {

	movzx	eax, BYTE PTR MacroLevel
	test	eax, eax
	je	SHORT $LN21@LstWrite

; 160  :         switch ( ModuleInfo.list_macro ) {

	mov	eax, DWORD PTR ModuleInfo+400
	mov	DWORD PTR tv79[rbp], eax
	cmp	DWORD PTR tv79[rbp], 0
	je	SHORT $LN22@LstWrite
	jmp	SHORT $LN2@LstWrite
$LN22@LstWrite:

; 161  :         case LM_NOLISTMACRO:
; 162  :             return;

	jmp	$LN1@LstWrite
$LN2@LstWrite:
$LN21@LstWrite:

; 163  :         case LM_LISTMACRO:
; 164  :             /* todo: filter certain macro lines */
; 165  :             break;
; 166  :         }
; 167  :     }
; 168  : 
; 169  :     ModuleInfo.line_flags |= LOF_LISTED;

	movzx	eax, BYTE PTR ModuleInfo+398
	or	eax, 1
	mov	BYTE PTR ModuleInfo+398, al

; 170  : 
; 171  :     DebugMsg1(("LstWrite( %u, %" I32_SPEC "u ): enter [ pos=%" I32_SPEC "u, GeneratedCode=%u, MacroLevel=%u ]\n", type, oldofs, list_pos, ModuleInfo.GeneratedCode, MacroLevel ));

	movzx	eax, BYTE PTR MacroLevel
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR ModuleInfo+456
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR list_pos
	mov	r8d, DWORD PTR oldofs$[rbp]
	mov	edx, DWORD PTR type$[rbp]
	lea	rcx, OFFSET FLAT:$SG11382
	call	DoDebugMsg1

; 172  :     pSrcline = CurrSource;

	mov	rax, QWORD PTR ModuleInfo+464
	mov	QWORD PTR pSrcline$[rbp], rax

; 173  : #if FASTPASS
; 174  :     if ( ( Parse_Pass > PASS_1 ) && UseSavedState ) {

	cmp	DWORD PTR Parse_Pass, 0
	jbe	$LN24@LstWrite
	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	je	$LN24@LstWrite

; 175  :         if ( ModuleInfo.GeneratedCode == 0 ) {

	cmp	DWORD PTR ModuleInfo+456, 0
	jne	SHORT $LN25@LstWrite

; 176  :             if ( !( ModuleInfo.line_flags & LOF_SKIPPOS ) )

	movzx	eax, BYTE PTR ModuleInfo+398
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN26@LstWrite

; 177  :                 list_pos = LineStoreCurr->list_pos;

	mov	rax, QWORD PTR LineStoreCurr
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR list_pos, eax
$LN26@LstWrite:

; 178  : #if USELSLINE /* either use CurrSource + CurrComment or LineStoreCurr->line (see assemble.c, OnePass() */
; 179  :             pSrcline = LineStoreCurr->line;

	mov	rax, QWORD PTR LineStoreCurr
	add	rax, 16
	mov	QWORD PTR pSrcline$[rbp], rax

; 180  :             if ( ModuleInfo.CurrComment ) { /* if comment was removed, readd it! */

	cmp	QWORD PTR ModuleInfo+472, 0
	je	SHORT $LN27@LstWrite

; 181  :                 *( LineStoreCurr->line + strlen( LineStoreCurr->line ) ) = ';';

	mov	rax, QWORD PTR LineStoreCurr
	add	rax, 16
	mov	rcx, rax
	call	strlen
	mov	rcx, QWORD PTR LineStoreCurr
	mov	BYTE PTR [rcx+rax+16], 59		; 0000003bH

; 182  :                 ModuleInfo.CurrComment = NULL;

	mov	QWORD PTR ModuleInfo+472, 0
$LN27@LstWrite:

; 183  :             }
; 184  : #endif
; 185  :             DebugMsg1(("LstWrite: Pass=%u, stored pos=%" I32_SPEC "u\n", Parse_Pass+1, list_pos ));

	mov	eax, DWORD PTR Parse_Pass
	inc	eax
	mov	r8d, DWORD PTR list_pos
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11387
	call	DoDebugMsg1
$LN25@LstWrite:

; 186  :         }
; 187  :         fseek( CurrFile[LST], list_pos, SEEK_SET );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	xor	r8d, r8d
	mov	edx, DWORD PTR list_pos
	mov	rcx, QWORD PTR [rcx+rax]
	call	fseek
$LN24@LstWrite:

; 188  :     }
; 189  : #endif
; 190  : 
; 191  :     ll.next = NULL;

	mov	QWORD PTR ll$[rbp], 0

; 192  :     memset( ll.buffer, ' ', sizeof( ll.buffer ) );

	mov	r8d, 32					; 00000020H
	mov	edx, 32					; 00000020H
	lea	rcx, QWORD PTR ll$[rbp+8]
	call	memset

; 193  :     srcfile = get_curr_srcfile();

	call	get_curr_srcfile
	mov	DWORD PTR srcfile$[rbp], eax

; 194  : 
; 195  :     switch ( type ) {

	mov	eax, DWORD PTR type$[rbp]
	mov	DWORD PTR tv151[rbp], eax
	cmp	DWORD PTR tv151[rbp], 8
	ja	$LN57@LstWrite
	movsxd	rax, DWORD PTR tv151[rbp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN73@LstWrite[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN28@LstWrite:

; 196  :     case LSTTYPE_DATA:
; 197  :         if ( Parse_Pass == PASS_1 && Options.first_pass_listing == FALSE ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN29@LstWrite
	movzx	eax, BYTE PTR Options+153
	test	eax, eax
	jne	SHORT $LN29@LstWrite

; 198  :             break;

	jmp	$LN4@LstWrite
$LN29@LstWrite:
$LN30@LstWrite:

; 199  :         }
; 200  :         /* no break */
; 201  :     case LSTTYPE_CODE:
; 202  :         newofs = GetCurrOffset();

	call	GetCurrOffset
	mov	DWORD PTR newofs$[rbp], eax

; 203  :         sprintf( ll.buffer, "%08" I32_SPEC "X", oldofs );

	mov	r8d, DWORD PTR oldofs$[rbp]
	lea	rdx, OFFSET FLAT:$SG11391
	lea	rcx, QWORD PTR ll$[rbp+8]
	call	sprintf

; 204  :         ll.buffer[OFSSIZE] = ' ';

	mov	eax, 1
	imul	rax, rax, 8
	mov	BYTE PTR ll$[rbp+rax+8], 32		; 00000020H

; 205  : 
; 206  :         if ( CurrSeg == NULL )

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN31@LstWrite

; 207  :             break;

	jmp	$LN4@LstWrite
$LN31@LstWrite:

; 208  :         //if ( write_to_file == FALSE )
; 209  :         if ( Options.first_pass_listing ) {

	movzx	eax, BYTE PTR Options+153
	test	eax, eax
	je	SHORT $LN32@LstWrite

; 210  :             if ( Parse_Pass > PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN34@LstWrite

; 211  :                 break;

	jmp	$LN4@LstWrite
$LN34@LstWrite:

; 212  : #ifdef DEBUG_OUT
; 213  :         } else if ( Options.max_passes == 1 ) {

	jmp	SHORT $LN33@LstWrite
$LN32@LstWrite:
	movzx	eax, WORD PTR Options+20
	cmp	eax, 1
	jne	SHORT $LN35@LstWrite
	jmp	SHORT $LN36@LstWrite
$LN35@LstWrite:

; 214  :             ; /* write a listing in pass 1 */
; 215  : #endif
; 216  :         } else if ( Parse_Pass == PASS_1 )  /* changed v1.96 */

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN37@LstWrite

; 217  :             break;

	jmp	$LN4@LstWrite
$LN37@LstWrite:
$LN36@LstWrite:
$LN33@LstWrite:

; 218  : 
; 219  :         len = CODEBYTES;

	mov	DWORD PTR len$[rbp], 9

; 220  :         p2 = ll.buffer + OFSSIZE + 2;

	lea	rax, QWORD PTR ll$[rbp+18]
	mov	QWORD PTR p2$[rbp], rax

; 221  : 
; 222  :         if ( CurrSeg->e.seginfo->CodeBuffer == NULL ||

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN39@LstWrite
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+107]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN38@LstWrite
$LN39@LstWrite:
$LN6@LstWrite:

; 223  :             CurrSeg->e.seginfo->written == FALSE ) {
; 224  :             while ( oldofs < newofs && len ) {

	mov	eax, DWORD PTR newofs$[rbp]
	cmp	DWORD PTR oldofs$[rbp], eax
	jae	SHORT $LN7@LstWrite
	cmp	DWORD PTR len$[rbp], 0
	je	SHORT $LN7@LstWrite

; 225  :                 *p2++ = '0';

	mov	rax, QWORD PTR p2$[rbp]
	mov	BYTE PTR [rax], 48			; 00000030H
	mov	rax, QWORD PTR p2$[rbp]
	inc	rax
	mov	QWORD PTR p2$[rbp], rax

; 226  :                 *p2++ = '0';

	mov	rax, QWORD PTR p2$[rbp]
	mov	BYTE PTR [rax], 48			; 00000030H
	mov	rax, QWORD PTR p2$[rbp]
	inc	rax
	mov	QWORD PTR p2$[rbp], rax

; 227  :                 oldofs++;

	mov	eax, DWORD PTR oldofs$[rbp]
	inc	eax
	mov	DWORD PTR oldofs$[rbp], eax

; 228  :                 len--;

	mov	eax, DWORD PTR len$[rbp]
	dec	eax
	mov	DWORD PTR len$[rbp], eax

; 229  :             }

	jmp	SHORT $LN6@LstWrite
$LN7@LstWrite:

; 230  :             break;

	jmp	$LN4@LstWrite
$LN38@LstWrite:

; 231  :         }
; 232  : 
; 233  :         /* OMF hold just a small buffer for one LEDATA record */
; 234  :         /* if it has been flushed, use LastCodeBufSize */
; 235  :         idx = (CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc)

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	ecx, DWORD PTR oldofs$[rbp]
	mov	edx, DWORD PTR newofs$[rbp]
	sub	edx, ecx
	mov	ecx, edx
	sub	eax, ecx
	mov	DWORD PTR idx$[rbp], eax

; 236  :             - (newofs - oldofs);
; 237  :         if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+160, 1
	jne	$LN40@LstWrite

; 238  :             /* v2.11: additional check to make the hack more robust [ test case:  db 800000h dup (0) ] */
; 239  :             if ( ( idx+LastCodeBufSize ) < 0 )

	mov	eax, DWORD PTR LastCodeBufSize
	mov	ecx, DWORD PTR idx$[rbp]
	add	ecx, eax
	mov	eax, ecx
	test	eax, eax
	jge	SHORT $LN42@LstWrite

; 240  :                 break; /* just exit. The code bytes area will remain empty */

	jmp	$LN4@LstWrite
$LN42@LstWrite:
$LN8@LstWrite:

; 241  :             while ( idx < 0 && len ) {

	cmp	DWORD PTR idx$[rbp], 0
	jge	SHORT $LN9@LstWrite
	cmp	DWORD PTR len$[rbp], 0
	je	SHORT $LN9@LstWrite

; 242  :                 sprintf( p2, "%02X", CurrSeg->e.seginfo->CodeBuffer[idx+LastCodeBufSize] );

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, DWORD PTR LastCodeBufSize
	mov	edx, DWORD PTR idx$[rbp]
	add	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax+rcx]
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG11404
	mov	rcx, QWORD PTR p2$[rbp]
	call	sprintf

; 243  :                 p2 += 2;

	mov	rax, QWORD PTR p2$[rbp]
	add	rax, 2
	mov	QWORD PTR p2$[rbp], rax

; 244  :                 idx++;

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax

; 245  :                 oldofs++;

	mov	eax, DWORD PTR oldofs$[rbp]
	inc	eax
	mov	DWORD PTR oldofs$[rbp], eax

; 246  :                 len--;

	mov	eax, DWORD PTR len$[rbp]
	dec	eax
	mov	DWORD PTR len$[rbp], eax

; 247  :             }

	jmp	SHORT $LN8@LstWrite
$LN9@LstWrite:

; 248  :         } else if (idx < 0)

	jmp	SHORT $LN41@LstWrite
$LN40@LstWrite:
	cmp	DWORD PTR idx$[rbp], 0
	jge	SHORT $LN43@LstWrite

; 249  :             idx = 0;

	mov	DWORD PTR idx$[rbp], 0
$LN43@LstWrite:
$LN41@LstWrite:
$LN10@LstWrite:

; 250  : 
; 251  :         while ( oldofs < newofs && len ) {

	mov	eax, DWORD PTR newofs$[rbp]
	cmp	DWORD PTR oldofs$[rbp], eax
	jae	SHORT $LN11@LstWrite
	cmp	DWORD PTR len$[rbp], 0
	je	SHORT $LN11@LstWrite

; 252  :             sprintf( p2, "%02X", CurrSeg->e.seginfo->CodeBuffer[idx] );

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+96]
	movsxd	rcx, DWORD PTR idx$[rbp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax+rcx]
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG11406
	mov	rcx, QWORD PTR p2$[rbp]
	call	sprintf

; 253  :             p2 += 2;

	mov	rax, QWORD PTR p2$[rbp]
	add	rax, 2
	mov	QWORD PTR p2$[rbp], rax

; 254  :             idx++;

	mov	eax, DWORD PTR idx$[rbp]
	inc	eax
	mov	DWORD PTR idx$[rbp], eax

; 255  :             oldofs++;

	mov	eax, DWORD PTR oldofs$[rbp]
	inc	eax
	mov	DWORD PTR oldofs$[rbp], eax

; 256  :             len--;

	mov	eax, DWORD PTR len$[rbp]
	dec	eax
	mov	DWORD PTR len$[rbp], eax

; 257  :         }

	jmp	SHORT $LN10@LstWrite
$LN11@LstWrite:

; 258  :         *p2 = ' ';

	mov	rax, QWORD PTR p2$[rbp]
	mov	BYTE PTR [rax], 32			; 00000020H

; 259  :         break;

	jmp	$LN4@LstWrite
$LN44@LstWrite:

; 260  :     case LSTTYPE_EQUATE:
; 261  :         /* v2.10: display current offset if equate is an alias for a label in this segment */
; 262  :         idx = 1;

	mov	DWORD PTR idx$[rbp], 1

; 263  :         if ( sym->segment && sym->segment == &CurrSeg->sym ) {

	mov	rax, QWORD PTR sym$[rbp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN45@LstWrite
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR sym$[rbp]
	cmp	QWORD PTR [rcx+24], rax
	jne	SHORT $LN45@LstWrite

; 264  :             sprintf( ll.buffer, "%08" I32_SPEC "X", GetCurrOffset() );

	call	GetCurrOffset
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG11409
	lea	rcx, QWORD PTR ll$[rbp+8]
	call	sprintf

; 265  :             idx = 10;

	mov	DWORD PTR idx$[rbp], 10
$LN45@LstWrite:

; 266  :         }
; 267  :         ll.buffer[idx] = '=';

	movsxd	rax, DWORD PTR idx$[rbp]
	mov	BYTE PTR ll$[rbp+rax+8], 61		; 0000003dH

; 268  : #if AMD64_SUPPORT
; 269  :         if ( sym->value3264 != 0 && ( sym->value3264 != -1 || sym->value >= 0 ) )

	mov	rax, QWORD PTR sym$[rbp]
	cmp	DWORD PTR [rax+56], 0
	je	SHORT $LN46@LstWrite
	mov	rax, QWORD PTR sym$[rbp]
	cmp	DWORD PTR [rax+56], -1
	jne	SHORT $LN48@LstWrite
	mov	rax, QWORD PTR sym$[rbp]
	cmp	DWORD PTR [rax+16], 0
	jl	SHORT $LN46@LstWrite
$LN48@LstWrite:

; 270  :             sprintf( &ll.buffer[idx+2], "%-" PREFFMTSTR I64_SPEC "X", (uint_64)sym->value + ( (uint_64)sym->value3264 << 32 ) );

	mov	rax, QWORD PTR sym$[rbp]
	movsxd	rax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR sym$[rbp]
	movsxd	rcx, DWORD PTR [rcx+56]
	shl	rcx, 32					; 00000020H
	add	rax, rcx
	mov	ecx, DWORD PTR idx$[rbp]
	add	ecx, 2
	movsxd	rcx, ecx
	lea	rcx, QWORD PTR ll$[rbp+rcx+8]
	mov	r8, rax
	lea	rdx, OFFSET FLAT:$SG11413
	call	sprintf
	jmp	SHORT $LN47@LstWrite
$LN46@LstWrite:

; 271  :         else
; 272  : #endif
; 273  :             sprintf( &ll.buffer[idx+2], "%-" PREFFMTSTR I32_SPEC "X", sym->value );

	mov	eax, DWORD PTR idx$[rbp]
	add	eax, 2
	cdqe
	lea	rax, QWORD PTR ll$[rbp+rax+8]
	mov	rcx, QWORD PTR sym$[rbp]
	mov	r8d, DWORD PTR [rcx+16]
	lea	rdx, OFFSET FLAT:$SG11414
	mov	rcx, rax
	call	sprintf
$LN47@LstWrite:

; 274  :         ll.buffer[28] = ' ';

	mov	eax, 1
	imul	rax, rax, 28
	mov	BYTE PTR ll$[rbp+rax+8], 32		; 00000020H

; 275  :         break;

	jmp	$LN4@LstWrite
$LN49@LstWrite:

; 276  :     case LSTTYPE_TMACRO:
; 277  :         ll.buffer[1] = '=';

	mov	eax, 1
	imul	rax, rax, 1
	mov	BYTE PTR ll$[rbp+rax+8], 61		; 0000003dH

; 278  :         //GetLiteralValue( buffer2, sym->string_ptr );
; 279  :         //strcpy( buffer2, sym->string_ptr );
; 280  :         for ( p1 = sym->string_ptr, p2 = &ll.buffer[3], pll = &ll; *p1; ) {

	mov	rax, QWORD PTR sym$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR p1$[rbp], rax
	mov	eax, 1
	imul	rax, rax, 3
	lea	rax, QWORD PTR ll$[rbp+rax+8]
	mov	QWORD PTR p2$[rbp], rax
	lea	rax, QWORD PTR ll$[rbp]
	mov	QWORD PTR pll$[rbp], rax
$LN12@LstWrite:
	mov	rax, QWORD PTR p1$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN13@LstWrite

; 281  :             if ( p2 >= &pll->buffer[28] ) {

	mov	eax, 1
	imul	rax, rax, 28
	mov	rcx, QWORD PTR pll$[rbp]
	lea	rax, QWORD PTR [rcx+rax+8]
	cmp	QWORD PTR p2$[rbp], rax
	jb	SHORT $LN50@LstWrite

; 282  :                 struct lstleft *next = myalloca( sizeof( struct lstleft ) );

	mov	eax, DWORD PTR [rsp]
	mov	eax, 48					; 00000030H
	sub	rsp, rax
	lea	rax, QWORD PTR [rsp+48]
	mov	ecx, DWORD PTR [rax]
	mov	QWORD PTR next$1[rbp], rax

; 283  :                 pll->next = next;

	mov	rax, QWORD PTR pll$[rbp]
	mov	rcx, QWORD PTR next$1[rbp]
	mov	QWORD PTR [rax], rcx

; 284  :                 pll = next;

	mov	rax, QWORD PTR next$1[rbp]
	mov	QWORD PTR pll$[rbp], rax

; 285  :                 pll->next = NULL;

	mov	rax, QWORD PTR pll$[rbp]
	mov	QWORD PTR [rax], 0

; 286  :                 memset( pll->buffer, ' ', sizeof( pll->buffer) );

	mov	rax, QWORD PTR pll$[rbp]
	add	rax, 8
	mov	r8d, 32					; 00000020H
	mov	edx, 32					; 00000020H
	mov	rcx, rax
	call	memset

; 287  :                 p2 = &pll->buffer[3];

	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR pll$[rbp]
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR p2$[rbp], rax
$LN50@LstWrite:

; 288  :             }
; 289  :             *p2++ = *p1++;

	mov	rax, QWORD PTR p2$[rbp]
	mov	rcx, QWORD PTR p1$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR p2$[rbp]
	inc	rax
	mov	QWORD PTR p2$[rbp], rax
	mov	rax, QWORD PTR p1$[rbp]
	inc	rax
	mov	QWORD PTR p1$[rbp], rax

; 290  :         }

	jmp	$LN12@LstWrite
$LN13@LstWrite:

; 291  :         break;

	jmp	$LN4@LstWrite
$LN51@LstWrite:

; 292  :     case LSTTYPE_MACROLINE:
; 293  :         ll.buffer[1] = '>';

	mov	eax, 1
	imul	rax, rax, 1
	mov	BYTE PTR ll$[rbp+rax+8], 62		; 0000003eH

; 294  :         pSrcline = value;

	mov	rax, QWORD PTR value$[rbp]
	mov	QWORD PTR pSrcline$[rbp], rax

; 295  :         break;

	jmp	$LN4@LstWrite
$LN52@LstWrite:

; 296  :     case LSTTYPE_LABEL:
; 297  :         oldofs = GetCurrOffset();

	call	GetCurrOffset
	mov	DWORD PTR oldofs$[rbp], eax
$LN53@LstWrite:

; 298  :         /* no break */
; 299  :     case LSTTYPE_STRUCT:
; 300  :         sprintf( ll.buffer, "%08" I32_SPEC "X", oldofs );

	mov	r8d, DWORD PTR oldofs$[rbp]
	lea	rdx, OFFSET FLAT:$SG11420
	lea	rcx, QWORD PTR ll$[rbp+8]
	call	sprintf

; 301  :         ll.buffer[8] = ' ';

	mov	eax, 1
	imul	rax, rax, 8
	mov	BYTE PTR ll$[rbp+rax+8], 32		; 00000020H

; 302  :         break;

	jmp	$LN4@LstWrite
$LN54@LstWrite:

; 303  :     case LSTTYPE_DIRECTIVE:
; 304  :         if ( CurrSeg || value ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN56@LstWrite
	cmp	QWORD PTR value$[rbp], 0
	je	SHORT $LN55@LstWrite
$LN56@LstWrite:

; 305  :             sprintf( ll.buffer, "%08" I32_SPEC "X", oldofs );

	mov	r8d, DWORD PTR oldofs$[rbp]
	lea	rdx, OFFSET FLAT:$SG11424
	lea	rcx, QWORD PTR ll$[rbp+8]
	call	sprintf

; 306  :             ll.buffer[8] = ' ';

	mov	eax, 1
	imul	rax, rax, 8
	mov	BYTE PTR ll$[rbp+rax+8], 32		; 00000020H
$LN55@LstWrite:

; 307  :         }
; 308  :         break;

	jmp	SHORT $LN4@LstWrite
$LN57@LstWrite:

; 309  :     default: /* LSTTYPE_MACRO */
; 310  :         if ( *pSrcline == NULLC && ModuleInfo.CurrComment == NULL && srcfile == ModuleInfo.srcfile ) {

	mov	rax, QWORD PTR pSrcline$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN58@LstWrite
	cmp	QWORD PTR ModuleInfo+472, 0
	jne	SHORT $LN58@LstWrite
	mov	eax, DWORD PTR ModuleInfo+428
	cmp	DWORD PTR srcfile$[rbp], eax
	jne	SHORT $LN58@LstWrite

; 311  :             DebugMsg1(("LstWrite: type=%u, writing CRLF\n", type ));

	mov	edx, DWORD PTR type$[rbp]
	lea	rcx, OFFSET FLAT:$SG11427
	call	DoDebugMsg1

; 312  :             fwrite( NLSTR, 1, NLSIZ, CurrFile[LST] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 2
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11428
	call	fwrite

; 313  :             list_pos += NLSIZ;

	mov	eax, DWORD PTR list_pos
	add	eax, 2
	mov	DWORD PTR list_pos, eax

; 314  :             return;

	jmp	$LN1@LstWrite
$LN58@LstWrite:
$LN4@LstWrite:

; 315  :         }
; 316  :         break;
; 317  :     }
; 318  : 
; 319  : #if FASTPASS
; 320  :     if ( Parse_Pass == PASS_1 || UseSavedState == FALSE ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN61@LstWrite
	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	jne	SHORT $LN59@LstWrite
$LN61@LstWrite:

; 321  : #endif
; 322  :         idx = sizeof( ll.buffer );

	mov	DWORD PTR idx$[rbp], 32			; 00000020H

; 323  :         if ( ModuleInfo.GeneratedCode )

	cmp	DWORD PTR ModuleInfo+456, 0
	je	SHORT $LN62@LstWrite

; 324  :             ll.buffer[28] = '*';

	mov	eax, 1
	imul	rax, rax, 28
	mov	BYTE PTR ll$[rbp+rax+8], 42		; 0000002aH
$LN62@LstWrite:

; 325  :         if ( MacroLevel ) {

	movzx	eax, BYTE PTR MacroLevel
	test	eax, eax
	je	SHORT $LN63@LstWrite

; 326  :             len = sprintf( &ll.buffer[29], "%u", MacroLevel );

	movzx	eax, BYTE PTR MacroLevel
	mov	ecx, 1
	imul	rcx, rcx, 29
	lea	rcx, QWORD PTR ll$[rbp+rcx+8]
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG11434
	call	sprintf
	mov	DWORD PTR len$[rbp], eax

; 327  :             ll.buffer[29+len] = ' ';

	mov	eax, DWORD PTR len$[rbp]
	add	eax, 29
	cdqe
	mov	BYTE PTR ll$[rbp+rax+8], 32		; 00000020H
$LN63@LstWrite:

; 328  :         }
; 329  :         if ( srcfile != ModuleInfo.srcfile ) {

	mov	eax, DWORD PTR ModuleInfo+428
	cmp	DWORD PTR srcfile$[rbp], eax
	je	SHORT $LN64@LstWrite

; 330  :             ll.buffer[30] = 'C';

	mov	eax, 1
	imul	rax, rax, 30
	mov	BYTE PTR ll$[rbp+rax+8], 67		; 00000043H
$LN64@LstWrite:

; 331  :         }
; 332  : #ifdef DEBUG_OUT
; 333  :         ll.last = NULLC;

	mov	BYTE PTR ll$[rbp+40], 0

; 334  : #endif
; 335  : #if FASTPASS
; 336  :     } else {

	jmp	SHORT $LN60@LstWrite
$LN59@LstWrite:

; 337  :         idx = OFSSIZE + 2 + 2 * CODEBYTES;

	mov	DWORD PTR idx$[rbp], 28

; 338  : #ifdef DEBUG_OUT
; 339  :         ll.buffer[idx] = NULLC;

	movsxd	rax, DWORD PTR idx$[rbp]
	mov	BYTE PTR ll$[rbp+rax+8], 0
$LN60@LstWrite:

; 340  : #endif
; 341  :     }
; 342  : #endif
; 343  :     fwrite( ll.buffer, 1, idx, CurrFile[LST] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	movsxd	rdx, DWORD PTR idx$[rbp]
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8, rdx
	mov	edx, 1
	lea	rcx, QWORD PTR ll$[rbp+8]
	call	fwrite

; 344  : 
; 345  :     len = strlen( pSrcline );

	mov	rcx, QWORD PTR pSrcline$[rbp]
	call	strlen
	mov	DWORD PTR len$[rbp], eax

; 346  :     len2 = ( ModuleInfo.CurrComment ? strlen( ModuleInfo.CurrComment ) : 0 );

	cmp	QWORD PTR ModuleInfo+472, 0
	je	SHORT $LN71@LstWrite
	mov	rcx, QWORD PTR ModuleInfo+472
	call	strlen
	mov	QWORD PTR tv391[rbp], rax
	jmp	SHORT $LN72@LstWrite
$LN71@LstWrite:
	mov	QWORD PTR tv391[rbp], 0
$LN72@LstWrite:
	mov	eax, DWORD PTR tv391[rbp]
	mov	DWORD PTR len2$[rbp], eax

; 347  : 
; 348  :     list_pos += sizeof( ll.buffer ) + len + len2 + NLSIZ;

	movsxd	rax, DWORD PTR len$[rbp]
	movsxd	rcx, DWORD PTR len2$[rbp]
	lea	rax, QWORD PTR [rax+rcx+32]
	mov	ecx, DWORD PTR list_pos
	lea	rax, QWORD PTR [rcx+rax+2]
	mov	DWORD PTR list_pos, eax

; 349  :     DebugMsg1(("LstWrite: writing (%u b) >%s< [%u/%u], new pos=%" I32_SPEC "u\n", idx, ll.buffer, len, len2, list_pos ));

	mov	eax, DWORD PTR list_pos
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR len2$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR len$[rbp]
	lea	r8, QWORD PTR ll$[rbp+8]
	mov	edx, DWORD PTR idx$[rbp]
	lea	rcx, OFFSET FLAT:$SG11436
	call	DoDebugMsg1

; 350  : 
; 351  :     /* write source and comment part */
; 352  : #if FASTPASS
; 353  :     if ( Parse_Pass == PASS_1 || UseSavedState == FALSE ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN66@LstWrite
	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	jne	$LN65@LstWrite
$LN66@LstWrite:

; 354  : #endif
; 355  :         if ( len )

	cmp	DWORD PTR len$[rbp], 0
	je	SHORT $LN67@LstWrite

; 356  :             fwrite( pSrcline, 1, len, CurrFile[LST] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	movsxd	rdx, DWORD PTR len$[rbp]
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8, rdx
	mov	edx, 1
	mov	rcx, QWORD PTR pSrcline$[rbp]
	call	fwrite
$LN67@LstWrite:

; 357  :         if ( len2 ) {

	cmp	DWORD PTR len2$[rbp], 0
	je	SHORT $LN68@LstWrite

; 358  :             fwrite( ModuleInfo.CurrComment, 1, len2, CurrFile[LST] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	movsxd	rdx, DWORD PTR len2$[rbp]
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8, rdx
	mov	edx, 1
	mov	rcx, QWORD PTR ModuleInfo+472
	call	fwrite

; 359  :             DebugMsg1(("LstWrite: writing (%u b) >%s%s<\n", len + len2 + NLSIZ, pSrcline, ModuleInfo.CurrComment ));

	mov	eax, DWORD PTR len$[rbp]
	mov	ecx, DWORD PTR len2$[rbp]
	lea	eax, DWORD PTR [rax+rcx+2]
	mov	r9, QWORD PTR ModuleInfo+472
	mov	r8, QWORD PTR pSrcline$[rbp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11442
	call	DoDebugMsg1

; 360  :         }

	jmp	SHORT $LN69@LstWrite
$LN68@LstWrite:

; 361  : #ifdef DEBUG_OUT
; 362  :         else DebugMsg1(("LstWrite: writing (%u b) >%s<\n", len + NLSIZ, pSrcline ));

	mov	eax, DWORD PTR len$[rbp]
	add	eax, 2
	mov	r8, QWORD PTR pSrcline$[rbp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11443
	call	DoDebugMsg1
$LN69@LstWrite:

; 363  : #endif
; 364  :         fwrite( NLSTR, 1, NLSIZ, CurrFile[LST] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 2
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11444
	call	fwrite
$LN65@LstWrite:

; 365  : #if FASTPASS
; 366  :     }
; 367  : #endif
; 368  : 
; 369  :     /* write optional additional lines.
; 370  :      * currently works in pass one only.
; 371  :      */
; 372  :     for ( pll = ll.next; pll; pll = pll->next ) {

	mov	rax, QWORD PTR ll$[rbp]
	mov	QWORD PTR pll$[rbp], rax
	jmp	SHORT $LN17@LstWrite
$LN15@LstWrite:
	mov	rax, QWORD PTR pll$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pll$[rbp], rax
$LN17@LstWrite:
	cmp	QWORD PTR pll$[rbp], 0
	je	$LN16@LstWrite

; 373  :         fwrite( pll->buffer, 1, 32, CurrFile[LST] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rdx, QWORD PTR pll$[rbp]
	add	rdx, 8
	mov	QWORD PTR tv450[rbp], rdx
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 32					; 00000020H
	mov	edx, 1
	mov	rax, QWORD PTR tv450[rbp]
	mov	rcx, rax
	call	fwrite

; 374  :         fwrite( NLSTR, 1, NLSIZ, CurrFile[LST] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, 2
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG11445
	call	fwrite

; 375  :         list_pos += 32 + NLSIZ;

	mov	eax, DWORD PTR list_pos
	add	eax, 34					; 00000022H
	mov	DWORD PTR list_pos, eax

; 376  :         DebugMsg1(("LstWrite: additional line >%s<, new pos=%" I32_SPEC "u\n", pll->buffer, list_pos ));

	mov	rax, QWORD PTR pll$[rbp]
	add	rax, 8
	mov	r8d, DWORD PTR list_pos
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11446
	call	DoDebugMsg1

; 377  :     }

	jmp	$LN15@LstWrite
$LN16@LstWrite:
$LN1@LstWrite:

; 378  :     return;
; 379  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+160]
	pop	rbp
	ret	0
	npad	2
$LN73@LstWrite:
	DD	$LN28@LstWrite
	DD	$LN30@LstWrite
	DD	$LN44@LstWrite
	DD	$LN49@LstWrite
	DD	$LN54@LstWrite
	DD	$LN57@LstWrite
	DD	$LN53@LstWrite
	DD	$LN52@LstWrite
	DD	$LN51@LstWrite
LstWrite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
_TEXT	SEGMENT
namelen$1 = 32
buffer$ = 40
fn$ = 48
LstInit	PROC

; 1260 : {

$LN4:
	sub	rsp, 72					; 00000048H

; 1261 :     const struct fname_item *fn;
; 1262 :     const char *buffer;
; 1263 : 
; 1264 :     list_pos = 0;

	mov	DWORD PTR list_pos, 0

; 1265 :     if( Options.write_listing ) {

	movzx	eax, BYTE PTR Options+137
	test	eax, eax
	je	$LN2@LstInit

; 1266 :         int namelen;
; 1267 :         buffer = MsgGetEx( MSG_HJWASM );

	mov	ecx, 2
	call	MsgGetEx
	mov	QWORD PTR buffer$[rsp], rax

; 1268 :         list_pos = strlen( buffer );

	mov	rcx, QWORD PTR buffer$[rsp]
	call	strlen
	mov	DWORD PTR list_pos, eax

; 1269 :         fwrite( buffer, 1, list_pos, CurrFile[LST] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	edx, DWORD PTR list_pos
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8d, edx
	mov	edx, 1
	mov	rcx, QWORD PTR buffer$[rsp]
	call	fwrite

; 1270 :         LstNL();

	call	LstNL

; 1271 :         fn = GetFName( ModuleInfo.srcfile );

	mov	ecx, DWORD PTR ModuleInfo+428
	call	GetFName
	mov	QWORD PTR fn$[rsp], rax

; 1272 :         namelen = strlen( fn->fname );

	mov	rax, QWORD PTR fn$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	strlen
	mov	DWORD PTR namelen$1[rsp], eax

; 1273 :         fwrite( fn->fname, 1, namelen, CurrFile[LST] );

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	movsxd	rdx, DWORD PTR namelen$1[rsp]
	mov	r9, QWORD PTR [rcx+rax]
	mov	r8, rdx
	mov	edx, 1
	mov	rax, QWORD PTR fn$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	fwrite

; 1274 :         list_pos += namelen;

	mov	eax, DWORD PTR namelen$1[rsp]
	mov	ecx, DWORD PTR list_pos
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR list_pos, eax

; 1275 :         LstNL();

	call	LstNL
$LN2@LstInit:

; 1276 :     }
; 1277 : 
; 1278 : }

	add	rsp, 72					; 00000048H
	ret	0
LstInit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1788 : }

	add	rsp, 56					; 00000038H
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

	add	rsp, 56					; 00000038H
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	__stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1391 : }

	add	rsp, 72					; 00000048H
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 950  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 957  : }

	add	rsp, 56					; 00000038H
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT vfprintf
_TEXT	SEGMENT
_Stream$ = 48
_Format$ = 56
_ArgList$ = 64
vfprintf PROC						; COMDAT

; 652  : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 653  :     return _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Stream$[rsp]
	call	_vfprintf_l

; 654  : }

	add	rsp, 40					; 00000028H
	ret	0
vfprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 640  : }

	add	rsp, 56					; 00000038H
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
