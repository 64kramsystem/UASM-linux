; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	szNull
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
CONST	SEGMENT
szNull	DB	'<NULL>', 00H
	ORG $+1
sr_prefix DB	026H
	DB	02eH
	DB	036H
	DB	03eH
	DB	064H
	DB	065H
CONST	ENDS
_DATA	SEGMENT
$SG11280 DB	'output_data: size=%u cont=%I64X', 0aH, 00H
	ORG $+7
$SG11283 DB	'output_data: size=%u cont=%X', 0aH, 00H
	ORG $+2
$SG11284 DB	'output_data: size=0', 0aH, 00H
	ORG $+3
$SG11300 DB	'check_3rd_operand: tab=%X <-> codeinfo=%X', 0aH, 00H
	ORG $+5
$SG11330 DB	'output_3rd_operand, expected I8, op3=%X', 0aH, 00H
	ORG $+7
$SG11335 DB	'output_3rd_operand, expected OP3_HID, op3=%X', 0aH, 00H
	ORG $+2
$SG11382 DB	'match_phase_3 enter, opnd1=%X, searching op2=%X', 0aH, 00H
	ORG $+7
$SG11397 DB	'match_phase_3: instr table op2=%X', 0aH, 00H
	ORG $+5
$SG11400 DB	'match_phase_3: matched OP_I', 0aH, 00H
	ORG $+3
$SG11416 DB	'match_phase_3: matched OP_I8_U', 0aH, 00H
$SG11431 DB	'match_phase_3: matched OP_I8', 0aH, 00H
	ORG $+2
$SG11435 DB	'match_phase_3: matched OP_I_1', 0aH, 00H
	ORG $+1
$SG11443 DB	'match_phase_3: matched opnd2', 0aH, 00H
	ORG $+2
$SG11449 DB	'match_phase_3: returns EMPTY', 0aH, 00H
	ORG $+2
$SG11468 DB	'NULL', 00H
	ORG $+3
$SG11469 DB	'NULL', 00H
	ORG $+3
$SG11470 DB	'check_operand_2: error: undef_sym=%u Fixup[0]=%X [%s]', 0aH
	DB	00H
	ORG $+1
$SG11524 DB	'codegen: no matching format found', 0aH, 00H
	ORG $+5
$SG11511 DB	'codegen(ofs=%X): %s opnd1=%X codeinfo: ofssize=%u wide=%'
	DB	'u rm=%Xh sib=%Xh rex=%Xh opsiz=%u', 0aH, 00H
	ORG $+5
$SG10677 DB	'output_opc enter, ins.opc/rm=%X/%X, byte1_info=%X CodeIn'
	DB	'fo->rm=%X opsiz=%u', 0aH, 00H
	ORG $+4
$SG10687 DB	'output_opc: wrong cpu setting: instr.cpu=%X, ModuleInfo.'
	DB	'cpu=%X', 0aH, 00H
$SG10726 DB	'output_opc: ERROR: FP emulation byte sequence destroyed '
	DB	'by 32-bit address prefix!', 0aH, 00H
	ORG $+5
$SG10729 DB	'output_opc: instruction form requires 386', 0aH, 00H
	ORG $+13
$SG11247 DB	'output_data(idx=%u, op=%X [data=%X fixup=%p typ=%u] ) en'
	DB	'ter [rm=%X]', 0aH, 00H
	ORG $+11
$SG11248 DB	'output_data(idx=%u, op=%X [data=%X fixup=NULL] ) enter ['
	DB	'rm=%X]', 0aH, 00H
_DATA	ENDS
PUBLIC	codegen
PUBLIC	GetByteDisp
PUBLIC	Check4CompDisp8
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	OutputByte:PROC
EXTRN	OutputBytes:PROC
EXTRN	AddLinnumDataRef:PROC
EXTRN	OperandSize:PROC
EXTRN	AddFloatingPointEmulationFixup:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	GetLineNumber:PROC
EXTRN	get_curr_srcfile:PROC
EXTRN	LstWrite:PROC
EXTRN	GetResWName:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	write_to_file:BYTE
EXTRN	InstrTable:BYTE
EXTRN	optable_idx:BYTE
EXTRN	opnd_clstab:BYTE
EXTRN	ResWordTable:BYTE
EXTRN	vex_flags:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$codegen DD imagerel $LN39
	DD	imagerel $LN39+1399
	DD	imagerel $unwind$codegen
$pdata$GetByteDisp DD imagerel $LN23
	DD	imagerel $LN23+704
	DD	imagerel $unwind$GetByteDisp
$pdata$Check4CompDisp8 DD imagerel $LN5
	DD	imagerel $LN5+155
	DD	imagerel $unwind$Check4CompDisp8
$pdata$output_opc DD imagerel output_opc
	DD	imagerel output_opc+20012
	DD	imagerel $unwind$output_opc
$pdata$output_data DD imagerel output_data
	DD	imagerel output_data+1782
	DD	imagerel $unwind$output_data
$pdata$check_3rd_operand DD imagerel check_3rd_operand
	DD	imagerel check_3rd_operand+553
	DD	imagerel $unwind$check_3rd_operand
$pdata$output_3rd_operand DD imagerel output_3rd_operand
	DD	imagerel output_3rd_operand+1266
	DD	imagerel $unwind$output_3rd_operand
$pdata$match_phase_3 DD imagerel match_phase_3
	DD	imagerel match_phase_3+2299
	DD	imagerel $unwind$match_phase_3
$pdata$check_operand_2 DD imagerel check_operand_2
	DD	imagerel check_operand_2+907
	DD	imagerel $unwind$check_operand_2
pdata	ENDS
xdata	SEGMENT
$unwind$codegen DD 021001H
	DD	0110110H
$unwind$GetByteDisp DD 011819H
	DD	0a209H
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$Check4CompDisp8 DD 011801H
	DD	06218H
$unwind$output_opc DD 020c01H
	DD	017010cH
$unwind$output_data DD 011201H
	DD	0c212H
$unwind$check_3rd_operand DD 010901H
	DD	06209H
$unwind$output_3rd_operand DD 010901H
	DD	04209H
$unwind$match_phase_3 DD 010d01H
	DD	0820dH
$unwind$check_operand_2 DD 010d01H
	DD	0820dH
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\codegen.c
_TEXT	SEGMENT
next$1 = 32
tv168 = 40
tv170 = 48
CodeInfo$ = 80
opnd1$ = 88
check_operand_2 PROC

; 1831 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1832 :     if( CodeInfo->opnd[OPND2].type == OP_NONE ) {

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 0
	jne	$LN2@check_oper

; 1833 :       if (opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[OPND2] != OP_NONE){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	cmp	DWORD PTR [rax+rcx], 0
	je	SHORT $LN3@check_oper

; 1834 :         if (CodeInfo->token == T_VGETEXPPD || CodeInfo->token == T_VGETEXPPS)

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1428		; 00000594H
	je	SHORT $LN6@check_oper
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1429		; 00000595H
	jne	SHORT $LN4@check_oper
$LN6@check_oper:

; 1835 :           ;

	jmp	SHORT $LN5@check_oper
$LN4@check_oper:

; 1836 :         else
; 1837 :         return(ERROR); /* doesn't match */

	mov	eax, -1
	jmp	$LN1@check_oper
$LN5@check_oper:
$LN3@check_oper:

; 1838 :       }
; 1839 :         /* 1 opnd instruction found */
; 1840 : 
; 1841 :         /* v2.06: added check for unspecified size of mem op */
; 1842 :         if ( opnd1 == OP_M ) {

	cmp	DWORD PTR opnd1$[rsp], -1887436800	; ffffffff8f800000H
	jne	$LN7@check_oper

; 1843 :             const struct instr_item *next = CodeInfo->pinstr+1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	add	rax, 14
	mov	QWORD PTR next$1[rsp], rax

; 1844 :             if ( ( opnd_clstab[next->opclsidx].opnd_type[OPND1] & OP_M ) &&

	mov	rax, QWORD PTR next$1[rsp]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	eax, DWORD PTR [rax+rcx]
	and	eax, -1887436800			; ffffffff8f800000H
	test	eax, eax
	je	$LN8@check_oper
	mov	rax, QWORD PTR next$1[rsp]
	movzx	eax, BYTE PTR [rax+4]
	test	eax, eax
	jne	$LN8@check_oper

; 1845 :                 next->first == FALSE )
; 1846 :                 /* skip error if mem op is a forward reference */
; 1847 :                 /* v2.06b: added "undefined" check */
; 1848 :                 if ( CodeInfo->undef_sym == FALSE &&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	$LN9@check_oper
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	je	SHORT $LN10@check_oper
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN10@check_oper
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	mov	rax, QWORD PTR [rax+56]
	cmp	DWORD PTR [rax+32], 0
	je	$LN9@check_oper
$LN10@check_oper:

; 1849 :                     ( CodeInfo->opnd[OPND1].InsFixup == NULL ||
; 1850 :                      CodeInfo->opnd[OPND1].InsFixup->sym == NULL ||
; 1851 :                      CodeInfo->opnd[OPND1].InsFixup->sym->state != SYM_UNDEFINED ) ) {
; 1852 :                     DebugMsg(("check_operand_2: error: undef_sym=%u Fixup[0]=%X [%s]\n",

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	je	SHORT $LN19@check_oper
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN17@check_oper
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	mov	rax, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv168[rsp], rax
	jmp	SHORT $LN18@check_oper
$LN17@check_oper:
	lea	rax, OFFSET FLAT:$SG11468
	mov	QWORD PTR tv168[rsp], rax
$LN18@check_oper:
	mov	rax, QWORD PTR tv168[rsp]
	mov	QWORD PTR tv170[rsp], rax
	jmp	SHORT $LN20@check_oper
$LN19@check_oper:
	lea	rax, OFFSET FLAT:$SG11469
	mov	QWORD PTR tv170[rsp], rax
$LN20@check_oper:
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+142]
	shr	cl, 6
	and	cl, 1
	movzx	ecx, cl
	mov	r9, QWORD PTR tv170[rsp]
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	r8, QWORD PTR [rdx+rax+48]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG11470
	call	DoDebugMsg

; 1853 :                               CodeInfo->undef_sym, CodeInfo->opnd[OPND1].InsFixup,
; 1854 :                               CodeInfo->opnd[OPND1].InsFixup ? CodeInfo->opnd[OPND1].InsFixup->sym ? CodeInfo->opnd[OPND1].InsFixup->sym->name : "NULL" : "NULL" ));
; 1855 :                     EmitErr( INSTRUCTION_OPERAND_MUST_HAVE_SIZE );

	mov	ecx, 182				; 000000b6H
	call	EmitErr
$LN9@check_oper:
$LN8@check_oper:
$LN7@check_oper:

; 1856 :                 }
; 1857 :         }
; 1858 : 
; 1859 :         output_opc( CodeInfo );

	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_opc

; 1860 :         output_data( CodeInfo, opnd1, OPND1 );

	xor	r8d, r8d
	mov	edx, DWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_data

; 1861 : #if AMD64_SUPPORT
; 1862 :         if ( CodeInfo->Ofssize == USE64 && CodeInfo->opnd[OPND1].InsFixup && CodeInfo->opnd[OPND1].InsFixup->type == FIX_RELOFF32 )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	jne	SHORT $LN11@check_oper
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	je	SHORT $LN11@check_oper
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	cmp	DWORD PTR [rax+24], 3
	jne	SHORT $LN11@check_oper

; 1863 :             CodeInfo->opnd[OPND1].InsFixup->addbytes = GetCurrOffset() - CodeInfo->opnd[OPND1].InsFixup->locofs;

	call	GetCurrOffset
	mov	ecx, 24
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+48]
	sub	eax, DWORD PTR [rcx+20]
	mov	ecx, 24
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+48]
	mov	BYTE PTR [rcx+32], al
$LN11@check_oper:

; 1864 : #endif
; 1865 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@check_oper
$LN2@check_oper:

; 1866 :     }
; 1867 : 
; 1868 :     /* check second operand */
; 1869 :     if ( match_phase_3( CodeInfo, opnd1 ) == NOT_ERROR ) {

	mov	edx, DWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	match_phase_3
	test	eax, eax
	jne	$LN12@check_oper

; 1870 : #if AMD64_SUPPORT
; 1871 :         /* for rip-relative fixups, the instruction end is needed */
; 1872 :         if ( CodeInfo->Ofssize == USE64 ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	jne	$LN13@check_oper

; 1873 :             if ( CodeInfo->opnd[OPND1].InsFixup && CodeInfo->opnd[OPND1].InsFixup->type == FIX_RELOFF32 )

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	je	SHORT $LN14@check_oper
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	cmp	DWORD PTR [rax+24], 3
	jne	SHORT $LN14@check_oper

; 1874 :                 CodeInfo->opnd[OPND1].InsFixup->addbytes = GetCurrOffset() - CodeInfo->opnd[OPND1].InsFixup->locofs;

	call	GetCurrOffset
	mov	ecx, 24
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+48]
	sub	eax, DWORD PTR [rcx+20]
	mov	ecx, 24
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+48]
	mov	BYTE PTR [rcx+32], al
$LN14@check_oper:

; 1875 :             if ( CodeInfo->opnd[OPND2].InsFixup && CodeInfo->opnd[OPND2].InsFixup->type == FIX_RELOFF32 )

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	je	SHORT $LN15@check_oper
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	cmp	DWORD PTR [rax+24], 3
	jne	SHORT $LN15@check_oper

; 1876 :                 CodeInfo->opnd[OPND2].InsFixup->addbytes = GetCurrOffset() - CodeInfo->opnd[OPND2].InsFixup->locofs;

	call	GetCurrOffset
	mov	ecx, 24
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+48]
	sub	eax, DWORD PTR [rcx+20]
	mov	ecx, 24
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+48]
	mov	BYTE PTR [rcx+32], al
$LN15@check_oper:
$LN13@check_oper:

; 1877 :         }
; 1878 : #endif
; 1879 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@check_oper
$LN12@check_oper:

; 1880 :     }
; 1881 :     return( ERROR );

	mov	eax, -1
$LN1@check_oper:

; 1882 : }

	add	rsp, 72					; 00000048H
	ret	0
check_operand_2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\codegen.c
_TEXT	SEGMENT
opnd2$ = 32
tbl_op2$ = 36
tv171 = 40
tv216 = 44
tv204 = 48
tv224 = 52
tv235 = 56
determinant$ = 60
CodeInfo$ = 80
opnd1$ = 88
match_phase_3 PROC

; 1624 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1625 :     enum operand_type    determinant = opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[OPND1]; /* remember first op type */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	eax, DWORD PTR [rax+rcx]
	mov	DWORD PTR determinant$[rsp], eax

; 1626 :     enum operand_type    opnd2 = CodeInfo->opnd[OPND2].type;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	mov	DWORD PTR opnd2$[rsp], eax

; 1627 :     enum operand_type    tbl_op2;
; 1628 : 
; 1629 :     DebugMsg1(("match_phase_3 enter, opnd1=%" I32_SPEC "X, searching op2=%" I32_SPEC "X\n", opnd1, opnd2 ));

	mov	r8d, DWORD PTR opnd2$[rsp]
	mov	edx, DWORD PTR opnd1$[rsp]
	lea	rcx, OFFSET FLAT:$SG11382
	call	DoDebugMsg1

; 1630 :     
; 1631 : #if AVXSUPP 
; 1632 :                                
; 1633 :     if ( CodeInfo->token >= VEX_START && ( vex_flags[ CodeInfo->token - VEX_START ] & VX_L ) ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1296		; 00000510H
	jl	$LN9@match_phas
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 1296				; 00000510H
	cdqe
	lea	rcx, OFFSET FLAT:vex_flags
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 1
	test	eax, eax
	je	$LN9@match_phas

; 1634 :         if ( CodeInfo->opnd[OPND1].type & (OP_K | OP_YMM | OP_ZMM | OP_M256) ) {

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 268435904				; 100001c0H
	test	eax, eax
	je	$LN10@match_phas

; 1635 :             if ( opnd2 & OP_ZMM || opnd2 & OP_YMM || opnd2 & OP_K)

	mov	eax, DWORD PTR opnd2$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	jne	SHORT $LN14@match_phas
	mov	eax, DWORD PTR opnd2$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN14@match_phas
	mov	eax, DWORD PTR opnd2$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN12@match_phas
$LN14@match_phas:

; 1636 :                 opnd2 |= OP_XMM;

	mov	eax, DWORD PTR opnd2$[rsp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR opnd2$[rsp], eax
	jmp	SHORT $LN13@match_phas
$LN12@match_phas:

; 1637 :             else if ( opnd2 & OP_M256 )

	mov	eax, DWORD PTR opnd2$[rsp]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	SHORT $LN15@match_phas

; 1638 :                 opnd2 |= OP_M128;

	mov	eax, DWORD PTR opnd2$[rsp]
	bts	eax, 27
	mov	DWORD PTR opnd2$[rsp], eax
	jmp	SHORT $LN16@match_phas
$LN15@match_phas:

; 1639 :             else if ( opnd2 & OP_M128 )

	mov	eax, DWORD PTR opnd2$[rsp]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	je	SHORT $LN17@match_phas

; 1640 :                 opnd2 |= OP_M64;               //should be: ins->prefix & VX_HALF)

	mov	eax, DWORD PTR opnd2$[rsp]
	bts	eax, 26
	mov	DWORD PTR opnd2$[rsp], eax
	jmp	SHORT $LN18@match_phas
$LN17@match_phas:

; 1641 :             else if ( ( opnd2 & OP_XMM ) && !( vex_flags[ CodeInfo->token - VEX_START ] & VX_HALF ) ) {

	mov	eax, DWORD PTR opnd2$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN19@match_phas
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 1296				; 00000510H
	cdqe
	lea	rcx, OFFSET FLAT:vex_flags
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN19@match_phas

; 1642 :                 EmitError( INSTRUCTION_OR_REGISTER_NOT_ACCEPTED_IN_CURRENT_CPU_MODE );

	mov	ecx, 30
	call	EmitError

; 1643 :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@match_phas
$LN19@match_phas:
$LN18@match_phas:
$LN16@match_phas:
$LN13@match_phas:

; 1644 :             }
; 1645 :         }

	jmp	SHORT $LN11@match_phas
$LN10@match_phas:

; 1646 : #if 1
; 1647 :         /* may be necessary to cover the cases where the first operand is a memory operand
; 1648 :          * "without size" and the second operand is a ymm register
; 1649 :          */
; 1650 :         else if ( CodeInfo->opnd[OPND1].type == OP_M ) {

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], -1887436800	; ffffffff8f800000H
	jne	SHORT $LN20@match_phas

; 1651 :             if ( opnd2 & OP_YMM || opnd2 & OP_ZMM)

	mov	eax, DWORD PTR opnd2$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN22@match_phas
	mov	eax, DWORD PTR opnd2$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN21@match_phas
$LN22@match_phas:

; 1652 :                 opnd2 |= OP_XMM;

	mov	eax, DWORD PTR opnd2$[rsp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR opnd2$[rsp], eax
$LN21@match_phas:
$LN20@match_phas:
$LN11@match_phas:
$LN9@match_phas:
$LN4@match_phas:

; 1653 :         }
; 1654 : #endif
; 1655 :     }
; 1656 : #endif
; 1657 :     do  {
; 1658 :         tbl_op2 = opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[OPND2];

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	eax, DWORD PTR [rax+rcx]
	mov	DWORD PTR tbl_op2$[rsp], eax

; 1659 :         DebugMsg1(("match_phase_3: instr table op2=%" I32_SPEC "X\n", tbl_op2 ));

	mov	edx, DWORD PTR tbl_op2$[rsp]
	lea	rcx, OFFSET FLAT:$SG11397
	call	DoDebugMsg1

; 1660 :         switch( tbl_op2 ) {

	mov	eax, DWORD PTR tbl_op2$[rsp]
	mov	DWORD PTR tv171[rsp], eax
	cmp	DWORD PTR tv171[rsp], 131072		; 00020000H
	je	$LN45@match_phas
	cmp	DWORD PTR tv171[rsp], 917504		; 000e0000H
	je	SHORT $LN23@match_phas
	cmp	DWORD PTR tv171[rsp], 4325376		; 00420000H
	je	$LN54@match_phas
	cmp	DWORD PTR tv171[rsp], 5111808		; 004e0000H
	je	$LN38@match_phas
	jmp	$LN57@match_phas
$LN23@match_phas:

; 1661 :         case OP_I: /* arith, MOV, IMUL, TEST */
; 1662 :             if( opnd2 & tbl_op2 ) {

	mov	eax, DWORD PTR tbl_op2$[rsp]
	mov	ecx, DWORD PTR opnd2$[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	$LN24@match_phas

; 1663 :                 DebugMsg1(("match_phase_3: matched OP_I\n"));

	lea	rcx, OFFSET FLAT:$SG11400
	call	DoDebugMsg1

; 1664 :                 /* This branch exits with either ERROR or NOT_ERROR.
; 1665 :                  * So it can modify the CodeInfo fields without harm.
; 1666 :                  */
; 1667 :                 if( opnd1 & OP_R8 ) {

	mov	eax, DWORD PTR opnd1$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN25@match_phas

; 1668 :                     /* 8-bit register, so output 8-bit data */
; 1669 :                     /* v2.04: the check has already happened in check_size() or idata_xxx() */
; 1670 :                     //if( Parse_Pass == PASS_1 && !InRange( operand, 1 ) ) {
; 1671 :                     //    DebugMsg(("imm const too large (08): %X\n", operand));
; 1672 :                     //    EmitWarn( 1, IMMEDIATE_CONSTANT_TOO_LARGE );
; 1673 :                     //}
; 1674 :                     CodeInfo->prefix.opsiz = FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 1675 :                     opnd2 = OP_I8;

	mov	DWORD PTR opnd2$[rsp], 131072		; 00020000H

; 1676 :                     if( CodeInfo->opnd[OPND2].InsFixup != NULL ) {

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	je	SHORT $LN27@match_phas

; 1677 :                     /* v1.96: make sure FIX_HIBYTE isn't overwritten! */
; 1678 :                         if ( CodeInfo->opnd[OPND2].InsFixup->type != FIX_HIBYTE )

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	cmp	DWORD PTR [rax+24], 11
	je	SHORT $LN28@match_phas

; 1679 :                             CodeInfo->opnd[OPND2].InsFixup->type = FIX_OFF8;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	mov	DWORD PTR [rax+24], 4
$LN28@match_phas:
$LN27@match_phas:

; 1680 :                     }

	jmp	$LN26@match_phas
$LN25@match_phas:

; 1681 :                 } else if( opnd1 & OP_R16 ) {

	mov	eax, DWORD PTR opnd1$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN29@match_phas

; 1682 :                     /* v2.04: the check has already happened in check_size() or idata_xxx() */
; 1683 :                     //if( Parse_Pass == PASS_1 && !InRange( operand, 2 ) ) {
; 1684 :                     //    DebugMsg(("imm const too large (16): %X\n", operand));
; 1685 :                     //    EmitWarn( 1, IMMEDIATE_CONSTANT_TOO_LARGE );
; 1686 :                     //}
; 1687 :                     /* 16-bit register, so output 16-bit data */
; 1688 :                     opnd2 = OP_I16;

	mov	DWORD PTR opnd2$[rsp], 262144		; 00040000H
	jmp	$LN30@match_phas
$LN29@match_phas:

; 1689 : #if AMD64_SUPPORT
; 1690 :                 } else if( opnd1 & (OP_R32 | OP_R64 ) ) {

	mov	eax, DWORD PTR opnd1$[rsp]
	and	eax, 12
	test	eax, eax
	je	SHORT $LN31@match_phas

; 1691 : #else
; 1692 :                 } else if( opnd1 & OP_R32 ) {
; 1693 : #endif
; 1694 :                     /* 32- or 64-bit register, so output 32-bit data */
; 1695 :                     CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? 0 : 1;/* 12-feb-92 */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN70@match_phas
	mov	DWORD PTR tv204[rsp], 0
	jmp	SHORT $LN71@match_phas
$LN70@match_phas:
	mov	DWORD PTR tv204[rsp], 1
$LN71@match_phas:
	movzx	eax, BYTE PTR tv204[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 1696 :                     opnd2 = OP_I32;

	mov	DWORD PTR opnd2$[rsp], 524288		; 00080000H
	jmp	$LN32@match_phas
$LN31@match_phas:

; 1697 :                 } else if( opnd1 & OP_M ) {

	mov	eax, DWORD PTR opnd1$[rsp]
	and	eax, -1887436800			; ffffffff8f800000H
	test	eax, eax
	je	$LN33@match_phas

; 1698 :                     /* there is no reason this should be only for T_MOV */
; 1699 :                     switch( OperandSize( opnd1, CodeInfo ) ) {

	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR opnd1$[rsp]
	call	OperandSize
	mov	DWORD PTR tv216[rsp], eax
	cmp	DWORD PTR tv216[rsp], 1
	je	SHORT $LN34@match_phas
	cmp	DWORD PTR tv216[rsp], 2
	je	SHORT $LN35@match_phas
	cmp	DWORD PTR tv216[rsp], 4
	je	SHORT $LN36@match_phas
	cmp	DWORD PTR tv216[rsp], 8
	je	SHORT $LN36@match_phas
	jmp	$LN37@match_phas
$LN34@match_phas:

; 1700 :                     case 1:
; 1701 :                         opnd2 = OP_I8;

	mov	DWORD PTR opnd2$[rsp], 131072		; 00020000H

; 1702 :                         CodeInfo->prefix.opsiz = FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 1703 :                         break;

	jmp	$LN7@match_phas
$LN35@match_phas:

; 1704 :                     case 2:
; 1705 :                         opnd2 = OP_I16;

	mov	DWORD PTR opnd2$[rsp], 262144		; 00040000H

; 1706 :                         CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? 1 : 0;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN72@match_phas
	mov	DWORD PTR tv224[rsp], 1
	jmp	SHORT $LN73@match_phas
$LN72@match_phas:
	mov	DWORD PTR tv224[rsp], 0
$LN73@match_phas:
	movzx	eax, BYTE PTR tv224[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 1707 :                         break;

	jmp	SHORT $LN7@match_phas
$LN36@match_phas:

; 1708 : #if AMD64_SUPPORT
; 1709 :                         /* mov [mem], imm64 doesn't exist. It's ensured that
; 1710 :                          * immediate data is 32bit only
; 1711 :                          */
; 1712 :                     case 8:
; 1713 : #endif
; 1714 :                     case 4:
; 1715 :                         opnd2 = OP_I32;

	mov	DWORD PTR opnd2$[rsp], 524288		; 00080000H

; 1716 :                         CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? 0 : 1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	je	SHORT $LN74@match_phas
	mov	DWORD PTR tv235[rsp], 0
	jmp	SHORT $LN75@match_phas
$LN74@match_phas:
	mov	DWORD PTR tv235[rsp], 1
$LN75@match_phas:
	movzx	eax, BYTE PTR tv235[rsp]
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+9]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 1717 :                         break;

	jmp	SHORT $LN7@match_phas
$LN37@match_phas:

; 1718 :                     default:
; 1719 :                         EmitError( INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS );

	mov	ecx, 14
	call	EmitError
$LN7@match_phas:
$LN33@match_phas:
$LN32@match_phas:
$LN30@match_phas:
$LN26@match_phas:

; 1720 :                         //return( ERROR ); /* v2.06: don't exit */
; 1721 :                     }
; 1722 :                 }
; 1723 :                 output_opc( CodeInfo );

	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_opc

; 1724 :                 output_data( CodeInfo, opnd1, OPND1 );

	xor	r8d, r8d
	mov	edx, DWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_data

; 1725 :                 output_data( CodeInfo, opnd2, OPND2 );

	mov	r8d, 1
	mov	edx, DWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_data

; 1726 :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@match_phas
$LN24@match_phas:

; 1727 :             }
; 1728 :             break;

	jmp	$LN5@match_phas
$LN38@match_phas:

; 1729 :         case OP_I8_U: /* shift+rotate, ENTER, BTx, IN, PSxx[D|Q|W] */
; 1730 :             if( opnd2 & tbl_op2 ) {

	mov	eax, DWORD PTR tbl_op2$[rsp]
	mov	ecx, DWORD PTR opnd2$[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	$LN39@match_phas

; 1731 :                 DebugMsg1(("match_phase_3: matched OP_I8_U\n"));

	lea	rcx, OFFSET FLAT:$SG11416
	call	DoDebugMsg1

; 1732 :                 if ( CodeInfo->const_size_fixed && opnd2 != OP_I8 )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN40@match_phas
	cmp	DWORD PTR opnd2$[rsp], 131072		; 00020000H
	je	SHORT $LN40@match_phas

; 1733 :                     break;

	jmp	$LN5@match_phas
$LN40@match_phas:

; 1734 :                 /* v2.03: lower bound wasn't checked */
; 1735 :                 /* range of unsigned 8-bit is -128 - +255 */
; 1736 :                 if( CodeInfo->opnd[OPND2].data32l <= UCHAR_MAX && CodeInfo->opnd[OPND2].data32l >= SCHAR_MIN ) {

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 255		; 000000ffH
	jg	$LN41@match_phas
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], -128		; ffffffffffffff80H
	jl	$LN41@match_phas

; 1737 :                     /* v2.06: if there's an external, adjust the fixup if it is > 8-bit */
; 1738 :                     if ( CodeInfo->opnd[OPND2].InsFixup != NULL ) {

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	je	SHORT $LN42@match_phas

; 1739 :                         if ( CodeInfo->opnd[OPND2].InsFixup->type == FIX_OFF16 ||

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	cmp	DWORD PTR [rax+24], 5
	je	SHORT $LN44@match_phas
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	cmp	DWORD PTR [rax+24], 6
	jne	SHORT $LN43@match_phas
$LN44@match_phas:

; 1740 :                             CodeInfo->opnd[OPND2].InsFixup->type == FIX_OFF32 )
; 1741 :                             CodeInfo->opnd[OPND2].InsFixup->type = FIX_OFF8;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	mov	DWORD PTR [rax+24], 4
$LN43@match_phas:
$LN42@match_phas:

; 1742 :                     }
; 1743 :                     /* the SSE4A EXTRQ instruction will need this! */
; 1744 :                     //if( check_3rd_operand( CodeInfo ) == ERROR )
; 1745 :                     //  break;
; 1746 :                     output_opc( CodeInfo );

	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_opc

; 1747 :                     output_data( CodeInfo, opnd1, OPND1 );

	xor	r8d, r8d
	mov	edx, DWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_data

; 1748 :                     output_data( CodeInfo, OP_I8, OPND2 );

	mov	r8d, 1
	mov	edx, 131072				; 00020000H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_data

; 1749 :                     //if( CodeInfo->pinstr->opnd_type_3rd != OP3_NONE )
; 1750 :                     //output_3rd_operand( CodeInfo );
; 1751 :                     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@match_phas
$LN41@match_phas:
$LN39@match_phas:

; 1752 :                 }
; 1753 :             }
; 1754 :             break;

	jmp	$LN5@match_phas
$LN45@match_phas:

; 1755 :         case OP_I8: /* arith, IMUL */
; 1756 :             /* v2.06: this case has been rewritten */
; 1757 : 
; 1758 :             /* v2.04: added */
; 1759 :             if( ModuleInfo.NoSignExtend &&

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 18
	and	eax, 1
	test	eax, eax
	je	SHORT $LN46@match_phas
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 509			; 000001fdH
	je	SHORT $LN47@match_phas
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 506			; 000001faH
	je	SHORT $LN47@match_phas
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 511			; 000001ffH
	jne	SHORT $LN46@match_phas
$LN47@match_phas:

; 1760 :                ( CodeInfo->token == T_AND ||
; 1761 :                 CodeInfo->token == T_OR ||
; 1762 :                 CodeInfo->token == T_XOR ) )
; 1763 :                 break;

	jmp	$LN5@match_phas
$LN46@match_phas:

; 1764 : 
; 1765 :             /* v2.11: skip externals - but don't skip undefines; forward8.asm */
; 1766 :             //if ( CodeInfo->opnd[OPND2].InsFixup != NULL ) /* external? then skip */
; 1767 :             if ( CodeInfo->opnd[OPND2].InsFixup != NULL && CodeInfo->opnd[OPND2].InsFixup->sym->state != SYM_UNDEFINED ) /* external? then skip */

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	je	SHORT $LN48@match_phas
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	mov	rax, QWORD PTR [rax+56]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN48@match_phas

; 1768 :                 break;

	jmp	$LN5@match_phas
$LN48@match_phas:

; 1769 : 
; 1770 :             if ( CodeInfo->const_size_fixed == FALSE )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	$LN49@match_phas

; 1771 :                 if ( ( opnd1 & ( OP_R16 | OP_M16 ) ) && (int_8)CodeInfo->opnd[OPND2].data32l == (int_16)CodeInfo->opnd[OPND2].data32l )

	mov	eax, DWORD PTR opnd1$[rsp]
	and	eax, 16777218				; 01000002H
	test	eax, eax
	je	SHORT $LN50@match_phas
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+40]
	mov	ecx, 24
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	movsx	ecx, WORD PTR [rdx+rcx+40]
	cmp	eax, ecx
	jne	SHORT $LN50@match_phas

; 1772 :                     tbl_op2 |= OP_I16;

	mov	eax, DWORD PTR tbl_op2$[rsp]
	bts	eax, 18
	mov	DWORD PTR tbl_op2$[rsp], eax
	jmp	SHORT $LN51@match_phas
$LN50@match_phas:

; 1773 :                 else if ( ( opnd1 & ( OP_RGT16 | OP_MGT16 ) ) && (int_8)CodeInfo->opnd[OPND2].data32l == (int_32)CodeInfo->opnd[OPND2].data32l )

	mov	eax, DWORD PTR opnd1$[rsp]
	and	eax, 100663308				; 0600000cH
	test	eax, eax
	je	SHORT $LN52@match_phas
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+40]
	mov	ecx, 24
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	cmp	eax, DWORD PTR [rdx+rcx+40]
	jne	SHORT $LN52@match_phas

; 1774 :                     tbl_op2 |= OP_I32;

	mov	eax, DWORD PTR tbl_op2$[rsp]
	bts	eax, 19
	mov	DWORD PTR tbl_op2$[rsp], eax
$LN52@match_phas:
$LN51@match_phas:
$LN49@match_phas:

; 1775 : 
; 1776 :             if( opnd2 & tbl_op2 ) {

	mov	eax, DWORD PTR tbl_op2$[rsp]
	mov	ecx, DWORD PTR opnd2$[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	SHORT $LN53@match_phas

; 1777 :                 DebugMsg1(("match_phase_3: matched OP_I8\n"));

	lea	rcx, OFFSET FLAT:$SG11431
	call	DoDebugMsg1

; 1778 :                 output_opc( CodeInfo );

	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_opc

; 1779 :                 output_data( CodeInfo, opnd1, OPND1 );

	xor	r8d, r8d
	mov	edx, DWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_data

; 1780 :                 output_data( CodeInfo, OP_I8, OPND2 );

	mov	r8d, 1
	mov	edx, 131072				; 00020000H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_data

; 1781 :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@match_phas
$LN53@match_phas:

; 1782 :             }
; 1783 :             break;

	jmp	$LN5@match_phas
$LN54@match_phas:

; 1784 :         case OP_I_1: /* shift ops */
; 1785 :             if( opnd2 & tbl_op2 ) {

	mov	eax, DWORD PTR tbl_op2$[rsp]
	mov	ecx, DWORD PTR opnd2$[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	SHORT $LN55@match_phas

; 1786 :                if ( CodeInfo->opnd[OPND2].data32l == 1 ) {

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 1
	jne	SHORT $LN56@match_phas

; 1787 :                    DebugMsg1(("match_phase_3: matched OP_I_1\n"));

	lea	rcx, OFFSET FLAT:$SG11435
	call	DoDebugMsg1

; 1788 :                    output_opc( CodeInfo );

	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_opc

; 1789 :                    output_data( CodeInfo, opnd1, OPND1 );

	xor	r8d, r8d
	mov	edx, DWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_data

; 1790 :                    /* the immediate is "implicite" */
; 1791 :                    return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@match_phas
$LN56@match_phas:
$LN55@match_phas:

; 1792 :                }
; 1793 :             }
; 1794 :             break;

	jmp	$LN5@match_phas
$LN57@match_phas:

; 1795 :         default:
; 1796 :             /* v2.06: condition made more restrictive */
; 1797 :             if (CodeInfo->token < T_VBROADCASTSS)(CodeInfo->evex_flag = 0);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1296		; 00000510H
	jge	SHORT $LN58@match_phas
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+136], 0
$LN58@match_phas:

; 1798 :             //if( ( opnd2 & tbl_op2 ) || (CodeInfo->mem_type == MT_EMPTY && (opnd2 & OP_M_ANY) && (tbl_op2 & OP_M_ANY) )) {
; 1799 :               if ((opnd2 & tbl_op2) || ((CodeInfo->evex_flag)&&(CodeInfo->token < T_VPBROADCASTB) || (CodeInfo->token > T_VPBROADCASTQ))) {     // 

	mov	eax, DWORD PTR tbl_op2$[rsp]
	mov	ecx, DWORD PTR opnd2$[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN60@match_phas
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	je	SHORT $LN62@match_phas
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1299		; 00000513H
	jl	SHORT $LN61@match_phas
$LN62@match_phas:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1302		; 00000516H
	jle	$LN59@match_phas
$LN61@match_phas:
$LN60@match_phas:

; 1800 :                 if( check_3rd_operand( CodeInfo ) == ERROR )

	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	check_3rd_operand
	cmp	eax, -1
	jne	SHORT $LN63@match_phas

; 1801 :                     break;

	jmp	$LN5@match_phas
$LN63@match_phas:

; 1802 :                 DebugMsg1(("match_phase_3: matched opnd2\n" ));

	lea	rcx, OFFSET FLAT:$SG11443
	call	DoDebugMsg1

; 1803 :                 output_opc( CodeInfo );

	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_opc

; 1804 :                 if ( opnd1 & (OP_I_ANY | OP_M_ANY ) )

	mov	eax, DWORD PTR opnd1$[rsp]
	and	eax, -4325376				; ffffffffffbe0000H
	test	eax, eax
	je	SHORT $LN64@match_phas

; 1805 :                     output_data( CodeInfo, opnd1, OPND1 );

	xor	r8d, r8d
	mov	edx, DWORD PTR opnd1$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_data
$LN64@match_phas:

; 1806 :                 if ( opnd2 & (OP_I_ANY | OP_M_ANY ) )

	mov	eax, DWORD PTR opnd2$[rsp]
	and	eax, -4325376				; ffffffffffbe0000H
	test	eax, eax
	je	SHORT $LN65@match_phas

; 1807 :                     output_data( CodeInfo, opnd2, OPND2 );

	mov	r8d, 1
	mov	edx, DWORD PTR opnd2$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_data
$LN65@match_phas:

; 1808 :                 //if( CodeInfo->pinstr->opnd_type_3rd != OP3_NONE )
; 1809 :                 if( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd != OP3_NONE )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	movzx	eax, BYTE PTR [rcx+rax+8]
	test	eax, eax
	je	SHORT $LN66@match_phas

; 1810 :                     output_3rd_operand( CodeInfo );

	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_3rd_operand
$LN66@match_phas:

; 1811 :                 if( CodeInfo->pinstr->byte1_info == F_0F0F ) /* output 3dNow opcode? */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 17
	jne	SHORT $LN67@match_phas

; 1812 :                     OutputCodeByte( CodeInfo->pinstr->opcode | CodeInfo->iswide );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax+12]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+142]
	and	cl, 1
	movzx	ecx, cl
	or	eax, ecx
	movzx	ecx, al
	call	OutputByte
$LN67@match_phas:

; 1813 :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@match_phas
$LN59@match_phas:
$LN5@match_phas:

; 1814 :             }
; 1815 :             break;
; 1816 :         }
; 1817 :         CodeInfo->pinstr++;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	add	rax, 14
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1818 :     } while ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[OPND1] == determinant && CodeInfo->pinstr->first == FALSE );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, DWORD PTR determinant$[rsp]
	cmp	DWORD PTR [rax+rcx], edx
	jne	SHORT $LN68@match_phas
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax+4]
	test	eax, eax
	je	$LN4@match_phas
$LN68@match_phas:

; 1819 :     CodeInfo->pinstr--; /* pointer will be increased in codegen() */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, 14
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1820 :     DebugMsg(("match_phase_3: returns EMPTY\n"));

	lea	rcx, OFFSET FLAT:$SG11449
	call	DoDebugMsg

; 1821 :     return( ERROR );

	mov	eax, -1
$LN1@match_phas:

; 1822 : }

	add	rsp, 72					; 00000048H
	ret	0
match_phase_3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\codegen.c
_TEXT	SEGMENT
CodeInfo$ = 48
output_3rd_operand PROC

; 1528 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1529 :     if( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd == OP3_I8_U ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	movzx	eax, BYTE PTR [rcx+rax+8]
	cmp	eax, 2
	jne	SHORT $LN2@output_3rd

; 1530 :         DebugMsg1(("output_3rd_operand, expected I8, op3=%" I32_SPEC "X\n", CodeInfo->opnd[OPND3].type ));

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rcx+rax+32]
	lea	rcx, OFFSET FLAT:$SG11330
	call	DoDebugMsg1

; 1531 :         /* v2.06: the type has been checked already! */
; 1532 :         //if( CodeInfo->opnd_type[OPND3] & OP_I ) {
; 1533 :         output_data( CodeInfo, OP_I8, OPND3 );

	mov	r8d, 2
	mov	edx, 131072				; 00020000H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_data
	jmp	$LN3@output_3rd
$LN2@output_3rd:

; 1534 :         //} else {
; 1535 :         //    EmitError( INVALID_INSTRUCTION_OPERANDS );
; 1536 :         //    return;
; 1537 :         //}
; 1538 :     } else if( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd == OP3_I ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	movzx	eax, BYTE PTR [rcx+rax+8]
	cmp	eax, 4
	jne	SHORT $LN4@output_3rd

; 1539 :         output_data( CodeInfo, CodeInfo->opnd[OPND3].type, OPND3 );

	mov	eax, 24
	imul	rax, rax, 2
	mov	r8d, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rcx+rax+32]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_data

; 1540 :     }

	jmp	$LN5@output_3rd
$LN4@output_3rd:

; 1541 :     else if (opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd == OP3_HID) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	movzx	eax, BYTE PTR [rcx+rax+8]
	cmp	eax, 5
	jne	$LN6@output_3rd

; 1542 :       DebugMsg1(("output_3rd_operand, expected OP3_HID, op3=%" I32_SPEC "X\n", CodeInfo->opnd[OPND3].type));

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rcx+rax+32]
	lea	rcx, OFFSET FLAT:$SG11335
	call	DoDebugMsg1

; 1543 :       /* v2.06: to avoid having to add 3*8 operand categories there's a
; 1544 :        * hard-wired peculiarity for the "hidden" 3rd operand: it's calculated
; 1545 :        * directly from the instruction token. in instruct.h, CMPEQPD must
; 1546 :        * be first and the order of the following CMP entries must not be
; 1547 :        * changed.
; 1548 :        */
; 1549 :       //CodeInfo->data[OPND3] = opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd & ~OP3_HID;
; 1550 : #if AVXSUPP
; 1551 :       if (CodeInfo->token >= VEX_START){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1296		; 00000510H
	jl	$LN8@output_3rd

; 1552 :         if (CodeInfo->token >= T_VCMPEQPD && CodeInfo->token <= T_VCMPTRUE_USSS){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1766		; 000006e6H
	jl	SHORT $LN10@output_3rd
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1893		; 00000765H
	jg	SHORT $LN10@output_3rd

; 1553 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rcx+rax+48], 0

; 1554 :           OutputCodeByte((CodeInfo->token - T_VCMPEQPD) & 0x1F);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 1766				; 000006e6H
	and	eax, 31
	movzx	ecx, al
	call	OutputByte

; 1555 :           return;

	jmp	$LN1@output_3rd

; 1556 :         }

	jmp	$LN11@output_3rd
$LN10@output_3rd:

; 1557 :         else if (CodeInfo->token >= T_VPCMPEQD && CodeInfo->token <= T_VPCMPTRUED){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1459		; 000005b3H
	jl	SHORT $LN12@output_3rd
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1466		; 000005baH
	jg	SHORT $LN12@output_3rd

; 1558 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rcx+rax+48], 0

; 1559 :           OutputCodeByte((CodeInfo->token - T_VPCMPEQD) & 0x07);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 1459				; 000005b3H
	and	eax, 7
	movzx	ecx, al
	call	OutputByte

; 1560 :           return;

	jmp	$LN1@output_3rd

; 1561 :         }

	jmp	$LN13@output_3rd
$LN12@output_3rd:

; 1562 :         else if (CodeInfo->token >= T_VPCMPEQUD && CodeInfo->token <= T_VPCMPTRUEUD){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1467		; 000005bbH
	jl	SHORT $LN14@output_3rd
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1474		; 000005c2H
	jg	SHORT $LN14@output_3rd

; 1563 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rcx+rax+48], 0

; 1564 :           OutputCodeByte((CodeInfo->token - T_VPCMPEQUD) & 0x07);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 1467				; 000005bbH
	and	eax, 7
	movzx	ecx, al
	call	OutputByte

; 1565 :           return;

	jmp	$LN1@output_3rd

; 1566 :         }

	jmp	$LN15@output_3rd
$LN14@output_3rd:

; 1567 :         else if (CodeInfo->token >= T_VPCMPEQQ && CodeInfo->token <= T_VPCMPTRUEQ){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1475		; 000005c3H
	jl	SHORT $LN16@output_3rd
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1482		; 000005caH
	jg	SHORT $LN16@output_3rd

; 1568 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rcx+rax+48], 0

; 1569 :           OutputCodeByte((CodeInfo->token - T_VPCMPEQQ) & 0x07);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 1475				; 000005c3H
	and	eax, 7
	movzx	ecx, al
	call	OutputByte

; 1570 :           return;

	jmp	$LN1@output_3rd

; 1571 :         }

	jmp	$LN17@output_3rd
$LN16@output_3rd:

; 1572 :         else if (CodeInfo->token >= T_VPCMPEQUQ && CodeInfo->token <= T_VPCMPTRUEUQ){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1483		; 000005cbH
	jl	SHORT $LN18@output_3rd
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1490		; 000005d2H
	jg	SHORT $LN18@output_3rd

; 1573 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rcx+rax+48], 0

; 1574 :           OutputCodeByte((CodeInfo->token - T_VPCMPEQUQ) & 0x07);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 1483				; 000005cbH
	and	eax, 7
	movzx	ecx, al
	call	OutputByte

; 1575 :           return;

	jmp	$LN1@output_3rd

; 1576 :         }

	jmp	$LN19@output_3rd
$LN18@output_3rd:

; 1577 :         else if (CodeInfo->token >= T_VPCMPEQW && CodeInfo->token <= T_VPCMPTRUEW){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1491		; 000005d3H
	jl	SHORT $LN20@output_3rd
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1498		; 000005daH
	jg	SHORT $LN20@output_3rd

; 1578 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rcx+rax+48], 0

; 1579 :           OutputCodeByte((CodeInfo->token - T_VPCMPEQW) & 0x07);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 1491				; 000005d3H
	and	eax, 7
	movzx	ecx, al
	call	OutputByte

; 1580 :           return;

	jmp	$LN1@output_3rd

; 1581 :         }

	jmp	$LN21@output_3rd
$LN20@output_3rd:

; 1582 :         else if (CodeInfo->token >= T_VPCMPEQUW && CodeInfo->token <= T_VPCMPTRUEUW){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1499		; 000005dbH
	jl	SHORT $LN22@output_3rd
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1506		; 000005e2H
	jg	SHORT $LN22@output_3rd

; 1583 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rcx+rax+48], 0

; 1584 :           OutputCodeByte((CodeInfo->token - T_VPCMPEQUW) & 0x07);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 1499				; 000005dbH
	and	eax, 7
	movzx	ecx, al
	call	OutputByte

; 1585 :           return;

	jmp	$LN1@output_3rd

; 1586 :         }

	jmp	$LN23@output_3rd
$LN22@output_3rd:

; 1587 :         else if (CodeInfo->token >= T_VPCMPEQB && CodeInfo->token <= T_VPCMPTRUEB){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1507		; 000005e3H
	jl	SHORT $LN24@output_3rd
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1514		; 000005eaH
	jg	SHORT $LN24@output_3rd

; 1588 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rcx+rax+48], 0

; 1589 :           OutputCodeByte((CodeInfo->token - T_VPCMPEQB) & 0x07);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 1507				; 000005e3H
	and	eax, 7
	movzx	ecx, al
	call	OutputByte

; 1590 :           return;

	jmp	$LN1@output_3rd

; 1591 :         }

	jmp	SHORT $LN25@output_3rd
$LN24@output_3rd:

; 1592 :         else if (CodeInfo->token >= T_VPCMPEQUB && CodeInfo->token <= T_VPCMPTRUEUB){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1515		; 000005ebH
	jl	SHORT $LN26@output_3rd
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1522		; 000005f2H
	jg	SHORT $LN26@output_3rd

; 1593 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rcx+rax+48], 0

; 1594 :           OutputCodeByte((CodeInfo->token - T_VPCMPEQUB) & 0x07);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 1515				; 000005ebH
	and	eax, 7
	movzx	ecx, al
	call	OutputByte

; 1595 :           return;

	jmp	$LN1@output_3rd
$LN26@output_3rd:
$LN25@output_3rd:
$LN23@output_3rd:
$LN21@output_3rd:
$LN19@output_3rd:
$LN17@output_3rd:
$LN15@output_3rd:
$LN13@output_3rd:
$LN11@output_3rd:

; 1596 :       }
; 1597 :     }

	jmp	SHORT $LN9@output_3rd
$LN8@output_3rd:

; 1598 :     else
; 1599 : #endif
; 1600 :           CodeInfo->opnd[OPND3].data32l = ( CodeInfo->token - T_CMPEQPD ) % 8;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 884				; 00000374H
	cdq
	and	edx, 7
	add	eax, edx
	and	eax, 7
	sub	eax, edx
	mov	ecx, 24
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rdx+rcx+40], eax
$LN9@output_3rd:

; 1601 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rcx+rax+48], 0

; 1602 :           output_data( CodeInfo, OP_I8, OPND3 );

	mov	r8d, 2
	mov	edx, 131072				; 00020000H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_data

; 1603 :     }

	jmp	$LN7@output_3rd
$LN6@output_3rd:

; 1604 : #if AVXSUPP
; 1605 :     else if( ((CodeInfo->token >= VEX_START) && (CodeInfo->token < T_VPGATHERDD)|| 
; 1606 :       (CodeInfo->token > T_VGATHERQPS))&&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1296		; 00000510H
	jl	SHORT $LN29@output_3rd
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1345		; 00000541H
	jl	SHORT $LN28@output_3rd
$LN29@output_3rd:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1352		; 00000548H
	jle	SHORT $LN27@output_3rd
$LN28@output_3rd:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	movzx	eax, BYTE PTR [rcx+rax+8]
	cmp	eax, 3
	jne	SHORT $LN27@output_3rd

; 1607 :        opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd == OP3_XMM0 ) {
; 1608 :         CodeInfo->opnd[OPND3].data32l = ( CodeInfo->opnd[OPND3].data32l << 4 );

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+40]
	shl	eax, 4
	mov	ecx, 24
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rdx+rcx+40], eax

; 1609 :         if (CodeInfo->opnd[OPND3].type != OP_K)

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 64		; 00000040H
	je	SHORT $LN30@output_3rd

; 1610 :         output_data( CodeInfo, OP_I8, OPND3 );

	mov	r8d, 2
	mov	edx, 131072				; 00020000H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_data
$LN30@output_3rd:
$LN27@output_3rd:
$LN7@output_3rd:
$LN5@output_3rd:
$LN3@output_3rd:
$LN1@output_3rd:

; 1611 :     }
; 1612 : #endif
; 1613 :     return;
; 1614 : }

	add	rsp, 40					; 00000028H
	ret	0
output_3rd_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\codegen.c
_TEXT	SEGMENT
tv139 = 32
tv85 = 36
CodeInfo$ = 64
check_3rd_operand PROC

; 1484 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1485 :     if( ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd == OP3_NONE ) ||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	movzx	eax, BYTE PTR [rcx+rax+8]
	test	eax, eax
	je	SHORT $LN5@check_3rd_
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	movzx	eax, BYTE PTR [rcx+rax+8]
	cmp	eax, 5
	jne	SHORT $LN4@check_3rd_
$LN5@check_3rd_:

; 1486 :        ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd == OP3_HID ) )
; 1487 :         return( ( CodeInfo->opnd[OPND3].type == OP_NONE ) ? NOT_ERROR : ERROR );

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 0
	jne	SHORT $LN20@check_3rd_
	mov	DWORD PTR tv85[rsp], 0
	jmp	SHORT $LN21@check_3rd_
$LN20@check_3rd_:
	mov	DWORD PTR tv85[rsp], -1
$LN21@check_3rd_:
	mov	eax, DWORD PTR tv85[rsp]
	jmp	$LN1@check_3rd_
$LN4@check_3rd_:

; 1488 :     
; 1489 :     /* current variant needs a 3rd operand */
; 1490 :     DebugMsg1(("check_3rd_operand: tab=%X <-> codeinfo=%X\n", opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd, CodeInfo->opnd[OPND3].type ));

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	movzx	ecx, BYTE PTR [rcx]
	imul	rcx, rcx, 12
	lea	rdx, OFFSET FLAT:opnd_clstab
	movzx	ecx, BYTE PTR [rdx+rcx+8]
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	r8d, DWORD PTR [rdx+rax+32]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG11300
	call	DoDebugMsg1

; 1491 : 
; 1492 :     switch ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	movzx	eax, BYTE PTR [rcx+rax+8]
	mov	BYTE PTR tv139[rsp], al
	cmp	BYTE PTR tv139[rsp], 1
	je	SHORT $LN6@check_3rd_
	cmp	BYTE PTR tv139[rsp], 2
	je	SHORT $LN8@check_3rd_
	cmp	BYTE PTR tv139[rsp], 3
	je	$LN15@check_3rd_
	cmp	BYTE PTR tv139[rsp], 4
	je	$LN13@check_3rd_
	jmp	$LN2@check_3rd_
$LN6@check_3rd_:

; 1493 :     case OP3_CL:
; 1494 :         if ( CodeInfo->opnd[OPND3].type == OP_CL )

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 1025		; 00000401H
	jne	SHORT $LN7@check_3rd_

; 1495 :             return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@check_3rd_
$LN7@check_3rd_:

; 1496 :         break;

	jmp	$LN2@check_3rd_
$LN8@check_3rd_:

; 1497 :     case OP3_I8_U: /* IMUL, SHxD, a few MMX/SSE */
; 1498 :         /* for IMUL, the operand is signed! */
; 1499 :         if ( ( CodeInfo->opnd[OPND3].type & OP_I ) && CodeInfo->opnd[OPND3].data32l >= -128 ) {

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 917504				; 000e0000H
	test	eax, eax
	je	SHORT $LN9@check_3rd_
	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], -128		; ffffffffffffff80H
	jl	SHORT $LN9@check_3rd_

; 1500 :             if ( ( CodeInfo->token == T_IMUL && CodeInfo->opnd[OPND3].data32l < 128 ) ||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 621			; 0000026dH
	jne	SHORT $LN12@check_3rd_
	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 128		; 00000080H
	jl	SHORT $LN11@check_3rd_
$LN12@check_3rd_:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 621			; 0000026dH
	je	SHORT $LN10@check_3rd_
	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 256		; 00000100H
	jge	SHORT $LN10@check_3rd_
$LN11@check_3rd_:

; 1501 :                 ( CodeInfo->token != T_IMUL && CodeInfo->opnd[OPND3].data32l < 256 ) ) {
; 1502 :                 CodeInfo->opnd[OPND3].type = OP_I8;

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rcx+rax+32], 131072		; 00020000H

; 1503 :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@check_3rd_
$LN10@check_3rd_:
$LN9@check_3rd_:

; 1504 :             }
; 1505 :         }
; 1506 :         break;

	jmp	SHORT $LN2@check_3rd_
$LN13@check_3rd_:

; 1507 :     case OP3_I: /* IMUL */
; 1508 :         if ( CodeInfo->opnd[OPND3].type & OP_I )

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 917504				; 000e0000H
	test	eax, eax
	je	SHORT $LN14@check_3rd_

; 1509 :             return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@check_3rd_
$LN14@check_3rd_:

; 1510 :         break;

	jmp	SHORT $LN2@check_3rd_
$LN15@check_3rd_:

; 1511 :     case OP3_XMM0:
; 1512 : #if AVXSUPP
; 1513 :         /* for VEX encoding, XMM0 has the meaning: any K/XMM/YMM/ZMM register */
; 1514 :         if ( CodeInfo->token >= VEX_START ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1296		; 00000510H
	jl	SHORT $LN16@check_3rd_

; 1515 :                return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@check_3rd_

; 1516 :         } else

	jmp	SHORT $LN17@check_3rd_
$LN16@check_3rd_:

; 1517 : #endif
; 1518 :         if ( CodeInfo->opnd[OPND3].type == OP_XMM &&

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 32		; 00000020H
	jne	SHORT $LN18@check_3rd_
	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 0
	jne	SHORT $LN18@check_3rd_

; 1519 :             CodeInfo->opnd[OPND3].data32l == 0 )
; 1520 :             return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@check_3rd_
$LN18@check_3rd_:
$LN17@check_3rd_:
$LN2@check_3rd_:

; 1521 :         break;
; 1522 :     }
; 1523 :     return( ERROR );

	mov	eax, -1
$LN1@check_3rd_:

; 1524 : }

	add	rsp, 56					; 00000038H
	ret	0
check_3rd_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\codegen.c
_TEXT	SEGMENT
size$ = 64
tv223 = 68
tv257 = 72
tv483 = 76
tv350 = 80
CodeInfo$ = 112
determinant$ = 120
index$ = 128
output_data PROC

; 1343 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 1344 :   int       size = 0;

	mov	DWORD PTR size$[rsp], 0

; 1345 : #if AVXSUPP
; 1346 :     if (CodeInfo->token >= VEX_START){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1296		; 00000510H
	jl	$LN6@output_dat

; 1347 :       if ((CodeInfo->token == T_ANDN) || (CodeInfo->token == T_MULX) ||
; 1348 :         (CodeInfo->token == T_PDEP) || (CodeInfo->token == T_PEXT)){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1674		; 0000068aH
	je	SHORT $LN9@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1675		; 0000068bH
	je	SHORT $LN9@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1684		; 00000694H
	je	SHORT $LN9@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1685		; 00000695H
	jne	SHORT $LN8@output_dat
$LN9@output_dat:

; 1349 :         if ((CodeInfo->opnd[OPND2].data32l == 0) || (index == 2))

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 0
	je	SHORT $LN11@output_dat
	cmp	DWORD PTR index$[rsp], 2
	jne	SHORT $LN10@output_dat
$LN11@output_dat:

; 1350 :           return;

	jmp	$LN1@output_dat
$LN10@output_dat:
$LN8@output_dat:

; 1351 :       }
; 1352 :       if ((CodeInfo->token >= T_BEXTR) && (CodeInfo->token <= T_SHRX) || (CodeInfo->token == T_BZHI)) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1676		; 0000068cH
	jl	SHORT $LN14@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1679		; 0000068fH
	jle	SHORT $LN13@output_dat
$LN14@output_dat:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1683		; 00000693H
	jne	SHORT $LN12@output_dat
$LN13@output_dat:

; 1353 :         if (CodeInfo->opnd[OPND2].data32l == 0) return;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 0
	jne	SHORT $LN15@output_dat
	jmp	$LN1@output_dat
$LN15@output_dat:

; 1354 :         if ((index == 0) || (index == 2))

	cmp	DWORD PTR index$[rsp], 0
	je	SHORT $LN17@output_dat
	cmp	DWORD PTR index$[rsp], 2
	jne	SHORT $LN16@output_dat
$LN17@output_dat:

; 1355 :           return;

	jmp	$LN1@output_dat
$LN16@output_dat:
$LN12@output_dat:

; 1356 :       }
; 1357 :       if (CodeInfo->opnd[OPND2].type == OP_I8 && CodeInfo->evex_flag){

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 131072		; 00020000H
	jne	$LN18@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	je	$LN18@output_dat

; 1358 :         if ((CodeInfo->token >= T_VPSLLW) && (CodeInfo->token <= T_VPSRLQ) ||
; 1359 :           (CodeInfo->token >= T_VPSLLVD) && (CodeInfo->token <= T_VPSRLVW) ||
; 1360 :           (CodeInfo->token == T_VRNDSCALEPD) || (CodeInfo->token == T_VRNDSCALEPS))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2044		; 000007fcH
	jl	SHORT $LN21@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2051		; 00000803H
	jle	SHORT $LN20@output_dat
$LN21@output_dat:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1534		; 000005feH
	jl	SHORT $LN22@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1551		; 0000060fH
	jle	SHORT $LN20@output_dat
$LN22@output_dat:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1615		; 0000064fH
	je	SHORT $LN20@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1616		; 00000650H
	jne	SHORT $LN19@output_dat
$LN20@output_dat:

; 1361 :         {
; 1362 :           if (((CodeInfo->rm_byte) >> 6) == 2)size = 4;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	sar	eax, 6
	cmp	eax, 2
	jne	SHORT $LN23@output_dat
	mov	DWORD PTR size$[rsp], 4
	jmp	SHORT $LN24@output_dat
$LN23@output_dat:

; 1363 :           else if (((CodeInfo->rm_byte) >> 6) == 1)size = 2;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	sar	eax, 6
	cmp	eax, 1
	jne	SHORT $LN25@output_dat
	mov	DWORD PTR size$[rsp], 2
$LN25@output_dat:
$LN24@output_dat:
$LN19@output_dat:
$LN18@output_dat:

; 1364 :         }
; 1365 :       }
; 1366 :     } 

	jmp	SHORT $LN7@output_dat
$LN6@output_dat:

; 1367 :     else
; 1368 : #endif
; 1369 :     /* skip the memory operand for XLAT/XLATB and string instructions! */
; 1370 :     if ( CodeInfo->token == T_XLAT || CodeInfo->token == T_XLATB ||
; 1371 :         CodeInfo->pinstr->allowed_prefix == AP_REP ||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 667			; 0000029bH
	je	SHORT $LN27@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 668			; 0000029cH
	je	SHORT $LN27@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+2]
	cmp	eax, 2
	je	SHORT $LN27@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+2]
$LN27@output_dat:
$LN7@output_dat:

; 1372 :         CodeInfo->pinstr->allowed_prefix == AP_REPxx ) {
; 1373 :         /* v2.06: no need anymore to modify the fixup field, it's
; 1374 :          * used inside OutputBytes() only.
; 1375 :          */
; 1376 :         //CodeInfo->InsFixup[index] = NULL;
; 1377 : 
; 1378 :         ;//return;
; 1379 :     }
; 1380 : #ifdef DEBUG_OUT
; 1381 :     if ( CodeInfo->opnd[index].InsFixup )

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	je	SHORT $LN28@output_dat

; 1382 :         DebugMsg1(("output_data(idx=%u, op=%" I32_SPEC "X [data=%" I32_SPEC "X fixup=%p typ=%u] ) enter [rm=%X]\n", index, determinant, CodeInfo->opnd[index].data32l, CodeInfo->opnd[index].InsFixup, CodeInfo->opnd[index].InsFixup->type ,CodeInfo->rm_byte ));

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	movsxd	rcx, DWORD PTR index$[rsp]
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+48]
	movsxd	rdx, DWORD PTR index$[rsp]
	imul	rdx, rdx, 24
	movsxd	r8, DWORD PTR index$[rsp]
	imul	r8, r8, 24
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR [rcx+24]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+rdx+48]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	r9d, DWORD PTR [rax+r8+40]
	mov	r8d, DWORD PTR determinant$[rsp]
	mov	edx, DWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:$SG11247
	call	DoDebugMsg1
	jmp	SHORT $LN29@output_dat
$LN28@output_dat:

; 1383 :     else
; 1384 :         DebugMsg1(("output_data(idx=%u, op=%" I32_SPEC "X [data=%" I32_SPEC "X fixup=NULL] ) enter [rm=%X]\n", index, determinant, CodeInfo->opnd[index].data32l, CodeInfo->rm_byte ));

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	movsxd	rcx, DWORD PTR index$[rsp]
	imul	rcx, rcx, 24
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	r9d, DWORD PTR [rax+rcx+40]
	mov	r8d, DWORD PTR determinant$[rsp]
	mov	edx, DWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:$SG11248
	call	DoDebugMsg1
$LN29@output_dat:

; 1385 : #endif
; 1386 : 
; 1387 :     /* determine size */
; 1388 : 
; 1389 :     if( determinant & OP_I8 ) {

	mov	eax, DWORD PTR determinant$[rsp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $LN30@output_dat

; 1390 :         size = 1;

	mov	DWORD PTR size$[rsp], 1
	jmp	$LN31@output_dat
$LN30@output_dat:

; 1391 :     } else if( determinant & OP_I16 ) {

	mov	eax, DWORD PTR determinant$[rsp]
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	SHORT $LN32@output_dat

; 1392 :         size = 2;

	mov	DWORD PTR size$[rsp], 2
	jmp	$LN33@output_dat
$LN32@output_dat:

; 1393 :     } else if( determinant & OP_I32 ) {

	mov	eax, DWORD PTR determinant$[rsp]
	and	eax, 524288				; 00080000H
	test	eax, eax
	je	SHORT $LN34@output_dat

; 1394 :         size = 4;

	mov	DWORD PTR size$[rsp], 4
	jmp	$LN35@output_dat
$LN34@output_dat:

; 1395 :     } else if( determinant & OP_I48 ) {

	mov	eax, DWORD PTR determinant$[rsp]
	and	eax, 2097152				; 00200000H
	test	eax, eax
	je	SHORT $LN36@output_dat

; 1396 :         size = 6;

	mov	DWORD PTR size$[rsp], 6
	jmp	$LN37@output_dat
$LN36@output_dat:

; 1397 : #if AMD64_SUPPORT
; 1398 :     } else if( determinant & OP_I64 ) {

	mov	eax, DWORD PTR determinant$[rsp]
	and	eax, 1048576				; 00100000H
	test	eax, eax
	je	SHORT $LN38@output_dat

; 1399 :         size = 8;

	mov	DWORD PTR size$[rsp], 8
	jmp	$LN39@output_dat
$LN38@output_dat:

; 1400 : #endif
; 1401 :     } else if( determinant & OP_M_ANY ) {

	mov	eax, DWORD PTR determinant$[rsp]
	and	eax, -8388608				; ffffffffff800000H
	test	eax, eax
	je	$LN40@output_dat

; 1402 :         /* switch on the mode ( the leftmost 2 bits ) */
; 1403 :         switch( CodeInfo->rm_byte & BIT_67 ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	and	eax, 192				; 000000c0H
	mov	DWORD PTR tv223[rsp], eax
	cmp	DWORD PTR tv223[rsp], 0
	je	SHORT $LN42@output_dat
	cmp	DWORD PTR tv223[rsp], 64		; 00000040H
	je	SHORT $LN41@output_dat
	cmp	DWORD PTR tv223[rsp], 128		; 00000080H
	je	$LN54@output_dat
	jmp	$LN2@output_dat
$LN41@output_dat:

; 1404 :         case MOD_01:  /* 8-bit displacement */
; 1405 :             size = 1;

	mov	DWORD PTR size$[rsp], 1

; 1406 :             break;

	jmp	$LN2@output_dat
$LN42@output_dat:

; 1407 :         case MOD_00: /* direct; base and/or index with no disp */
; 1408 :             if( ( CodeInfo->Ofssize == USE16 && CodeInfo->prefix.adrsiz == 0 ) ||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jne	SHORT $LN46@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN45@output_dat
$LN46@output_dat:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 1
	jne	SHORT $LN43@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN43@output_dat
$LN45@output_dat:

; 1409 :                ( CodeInfo->Ofssize == USE32 && CodeInfo->prefix.adrsiz == 1 ) ) {
; 1410 :                 if( ( CodeInfo->rm_byte & BIT_012 ) == RM_D16 ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	and	eax, 7
	cmp	eax, 6
	jne	SHORT $LN47@output_dat

; 1411 :                      size = 2; /* = size of displacement */

	mov	DWORD PTR size$[rsp], 2
$LN47@output_dat:

; 1412 :                 }
; 1413 :             } else {

	jmp	$LN44@output_dat
$LN43@output_dat:

; 1414 : #if AMD64_SUPPORT
; 1415 :                 /* v2.11: special case, 64-bit direct memory addressing, opcodes 0xA0 - 0xA3 */
; 1416 :                 if( CodeInfo->Ofssize == USE64 && ( CodeInfo->pinstr->opcode & 0xFC ) == 0xA0 && CodeInfo->pinstr->byte1_info == 0 )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	jne	SHORT $LN48@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax+12]
	and	eax, 252				; 000000fcH
	cmp	eax, 160				; 000000a0H
	jne	SHORT $LN48@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax+1]
	test	eax, eax
	jne	SHORT $LN48@output_dat

; 1417 :                     size = 8;

	mov	DWORD PTR size$[rsp], 8
	jmp	$LN49@output_dat
$LN48@output_dat:

; 1418 :                 else
; 1419 : #endif
; 1420 :                 switch( CodeInfo->rm_byte & BIT_012 ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	and	eax, 7
	mov	DWORD PTR tv257[rsp], eax
	cmp	DWORD PTR tv257[rsp], 4
	je	SHORT $LN50@output_dat
	cmp	DWORD PTR tv257[rsp], 5
	je	SHORT $LN52@output_dat
	jmp	SHORT $LN4@output_dat
$LN50@output_dat:

; 1421 :                 case RM_SIB: /* 0x04 (equals register # for ESP) */
; 1422 :                     if( ( CodeInfo->sib & BIT_012 ) != RM_D32 ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+105]
	and	eax, 7
	cmp	eax, 5
	je	SHORT $LN51@output_dat

; 1423 :                         break;  /* size = 0 */

	jmp	SHORT $LN4@output_dat
$LN51@output_dat:
$LN52@output_dat:

; 1424 :                     }
; 1425 :                     /* no break */
; 1426 :                 case RM_D32: /* 0x05 (equals register # for EBP) */
; 1427 :                     size = 4; /* = size of displacement */

	mov	DWORD PTR size$[rsp], 4

; 1428 : #if AMD64_SUPPORT
; 1429 :                     /* v2.11: overflow check for 64-bit added */
; 1430 :                       if ( CodeInfo->Ofssize == USE64 && CodeInfo->opnd[index].data64 >= 0x80000000 && CodeInfo->opnd[index].data64 < 0xffffffff80000000 )

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	jne	SHORT $LN53@output_dat
	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, -2147483648			; 80000000H
	cmp	QWORD PTR [rcx+rax+40], rdx
	jb	SHORT $LN53@output_dat
	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+40], -2147483648	; ffffffff80000000H
	jae	SHORT $LN53@output_dat

; 1431 :                         EmitErr( INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS );  // proveri

	mov	ecx, 14
	call	EmitErr
$LN53@output_dat:
$LN4@output_dat:
$LN49@output_dat:
$LN44@output_dat:

; 1432 : 
; 1433 : #endif
; 1434 :                 }
; 1435 :             }
; 1436 :             break;

	jmp	SHORT $LN2@output_dat
$LN54@output_dat:

; 1437 :         case MOD_10:  /* 16- or 32-bit displacement */
; 1438 :             if( ( CodeInfo->Ofssize == USE16 && CodeInfo->prefix.adrsiz == 0 ) ||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jne	SHORT $LN58@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN57@output_dat
$LN58@output_dat:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 1
	jne	SHORT $LN55@output_dat
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN55@output_dat
$LN57@output_dat:

; 1439 :                ( CodeInfo->Ofssize == USE32 && CodeInfo->prefix.adrsiz == 1 ) ) {
; 1440 :                 size = 2;

	mov	DWORD PTR size$[rsp], 2

; 1441 :             } else {

	jmp	SHORT $LN56@output_dat
$LN55@output_dat:

; 1442 :                 size = 4;

	mov	DWORD PTR size$[rsp], 4
$LN56@output_dat:
$LN2@output_dat:
$LN40@output_dat:
$LN39@output_dat:
$LN37@output_dat:
$LN35@output_dat:
$LN33@output_dat:
$LN31@output_dat:

; 1443 :             }
; 1444 :         }
; 1445 :     }
; 1446 : #ifdef DEBUG_OUT
; 1447 :     if ( size > 4 )

	cmp	DWORD PTR size$[rsp], 4
	jle	SHORT $LN59@output_dat

; 1448 :         DebugMsg1(( "output_data: size=%u cont=%" I64_SPEC "X\n", size, CodeInfo->opnd[index].data64 ));

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	r8, QWORD PTR [rcx+rax+40]
	mov	edx, DWORD PTR size$[rsp]
	lea	rcx, OFFSET FLAT:$SG11280
	call	DoDebugMsg1
	jmp	SHORT $LN60@output_dat
$LN59@output_dat:

; 1449 :     else if ( size )

	cmp	DWORD PTR size$[rsp], 0
	je	SHORT $LN61@output_dat

; 1450 :         DebugMsg1(( "output_data: size=%u cont=%" I32_SPEC "X\n", size, CodeInfo->opnd[index].data32l ));

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	r8d, DWORD PTR [rcx+rax+40]
	mov	edx, DWORD PTR size$[rsp]
	lea	rcx, OFFSET FLAT:$SG11283
	call	DoDebugMsg1
	jmp	SHORT $LN62@output_dat
$LN61@output_dat:

; 1451 :     else
; 1452 :         DebugMsg1(( "output_data: size=0\n" ));

	lea	rcx, OFFSET FLAT:$SG11284
	call	DoDebugMsg1
$LN62@output_dat:
$LN60@output_dat:

; 1453 : #endif
; 1454 :     if (size) {

	cmp	DWORD PTR size$[rsp], 0
	je	$LN63@output_dat

; 1455 :       if (CodeInfo->opnd[index].InsFixup) {

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	QWORD PTR [rcx+rax+48], 0
	je	$LN64@output_dat

; 1456 :         /* v2.07: fixup type check moved here */
; 1457 :         if (Parse_Pass > PASS_1)

	cmp	DWORD PTR Parse_Pass, 0
	jbe	$LN65@output_dat

; 1458 :           if ((1 << CodeInfo->opnd[index].InsFixup->type) & ModuleInfo.fmtopt->invalid_fixup_type) {

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	mov	eax, DWORD PTR [rax+24]
	mov	ecx, 1
	mov	DWORD PTR tv483[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv483[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR ModuleInfo+344
	movsx	ecx, WORD PTR [rcx+8]
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN66@output_dat

; 1459 :             EmitErr(UNSUPPORTED_FIXUP_TYPE,

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN71@output_dat
	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rcx+rax+48]
	mov	rax, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv350[rsp], rax
	jmp	SHORT $LN72@output_dat
$LN71@output_dat:
	lea	rax, OFFSET FLAT:szNull
	mov	QWORD PTR tv350[rsp], rax
$LN72@output_dat:
	mov	rax, QWORD PTR ModuleInfo+344
	add	rax, 10
	mov	r8, QWORD PTR tv350[rsp]
	mov	rdx, rax
	mov	ecx, 197				; 000000c5H
	call	EmitErr
$LN66@output_dat:
$LN65@output_dat:

; 1460 :               ModuleInfo.fmtopt->formatname,
; 1461 :               CodeInfo->opnd[index].InsFixup->sym ? CodeInfo->opnd[index].InsFixup->sym->name : szNull);
; 1462 :             /* don't exit! */
; 1463 :           }
; 1464 :         if (write_to_file) {

	movzx	eax, BYTE PTR write_to_file
	test	eax, eax
	je	SHORT $LN67@output_dat

; 1465 :           CodeInfo->opnd[index].InsFixup->locofs = GetCurrOffset();

	call	GetCurrOffset
	movsxd	rcx, DWORD PTR index$[rsp]
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	rcx, QWORD PTR [rdx+rcx+48]
	mov	DWORD PTR [rcx+20], eax

; 1466 :           OutputBytes((unsigned char *)&CodeInfo->opnd[index].data32l,

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 24
	movsxd	rcx, DWORD PTR index$[rsp]
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx+40]
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	r8, QWORD PTR [rdx+rax+48]
	mov	edx, DWORD PTR size$[rsp]
	call	OutputBytes

; 1467 :             size, CodeInfo->opnd[index].InsFixup);
; 1468 :           return;

	jmp	SHORT $LN1@output_dat
$LN67@output_dat:
$LN64@output_dat:
$LN63@output_dat:

; 1469 :         }
; 1470 :       }
; 1471 :     }
; 1472 :         /* if the TypleType is present output only 1 byte for the multiplier */
; 1473 :         if (CodeInfo->tuple){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+140]
	test	eax, eax
	je	SHORT $LN68@output_dat

; 1474 :           OutputByte(CodeInfo->opnd[index].data32l);

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+rax+40]
	call	OutputByte

; 1475 :         }

	jmp	SHORT $LN69@output_dat
$LN68@output_dat:

; 1476 :         else
; 1477 :           OutputBytes( (unsigned char *)&CodeInfo->opnd[index].data32l, size, NULL );

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	lea	rax, QWORD PTR [rcx+rax+40]
	xor	r8d, r8d
	mov	edx, DWORD PTR size$[rsp]
	mov	rcx, rax
	call	OutputBytes
$LN69@output_dat:
$LN1@output_dat:

; 1478 :        
; 1479 :     return;
; 1480 : }

	add	rsp, 104				; 00000068H
	ret	0
output_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\codegen.c
_TEXT	SEGMENT
lbyte$1 = 48
c$ = 49
byte1$2 = 50
tmp$ = 51
comprdsp$ = 52
ins$ = 56
fpfix$ = 64
rn$ = 68
tv1759 = 72
index$3 = 76
tv261 = 80
tv330 = 84
tv412 = 88
tv527 = 92
tv2660 = 96
cnt$4 = 100
tv2668 = 104
tv3208 = 108
tv546 = 112
tv554 = 116
tv562 = 120
tv885 = 124
tv889 = 128
tv1050 = 132
tv1683 = 136
type1$5 = 140
type2$6 = 144
p$7 = 152
tv80 = 160
tv85 = 164
d$8 = 168
CodeInfo$ = 192
output_opc PROC

; 168  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 169  :   const struct instr_item *ins = CodeInfo->pinstr;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR ins$[rsp], rax

; 170  :   uint_8           tmp;
; 171  :   uint_8           fpfix = FALSE;

	mov	BYTE PTR fpfix$[rsp], 0

; 172  :   int              rn;
; 173  :   unsigned char    c;
; 174  :   int_8            comprdsp = 0;

	mov	BYTE PTR comprdsp$[rsp], 0

; 175  : 
; 176  :   DebugMsg1(("output_opc enter, ins.opc/rm=%X/%X, byte1_info=%X CodeInfo->rm=%X opsiz=%u\n", ins->opcode, ins->rm_byte, ins->byte1_info, CodeInfo->rm_byte, CodeInfo->prefix.opsiz));

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+104]
	mov	rdx, QWORD PTR ins$[rsp]
	movzx	edx, BYTE PTR [rdx+1]
	mov	r8, QWORD PTR ins$[rsp]
	movzx	r8d, BYTE PTR [r8+13]
	mov	r9, QWORD PTR ins$[rsp]
	movzx	r9d, BYTE PTR [r9+12]
	mov	DWORD PTR tv80[rsp], r9d
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, edx
	mov	eax, DWORD PTR tv80[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG10677
	call	DoDebugMsg1

; 177  :   /*
; 178  :    * Output debug info - line numbers
; 179  :    */
; 180  :   if (Options.line_numbers)

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	SHORT $LN21@output_opc

; 181  :     AddLinnumDataRef(get_curr_srcfile(), GetLineNumber());

	call	GetLineNumber
	mov	DWORD PTR tv85[rsp], eax
	call	get_curr_srcfile
	mov	ecx, DWORD PTR tv85[rsp]
	mov	edx, ecx
	mov	ecx, eax
	call	AddLinnumDataRef
$LN21@output_opc:

; 182  :   /* if it's a FPU instr, reset opsiz */
; 183  :   //if( ins->cpu & P_FPU_MASK ) {
; 184  :   /* v2.02: if it's a FPU or MMX/SSE instr, reset opsiz!
; 185  :    * [this code has been moved here from codegen()]
; 186  :    */
; 187  :   if (ins->cpu & (P_FPU_MASK | P_MMX | P_SSEALL)) {

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, WORD PTR [rax+10]
	and	eax, 64775				; 0000fd07H
	test	eax, eax
	je	SHORT $LN22@output_opc

; 188  : #if SSE4SUPP
; 189  :     /* there are 2 exceptions. how to avoid this ugly hack? */
; 190  :     if (CodeInfo->token != T_CRC32 &&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1267		; 000004f3H
	je	SHORT $LN23@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1273		; 000004f9H
	je	SHORT $LN23@output_opc

; 191  :       CodeInfo->token != T_POPCNT)
; 192  : #endif
; 193  :       CodeInfo->prefix.opsiz = FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN23@output_opc:
$LN22@output_opc:

; 194  :   }
; 195  :   if ((CodeInfo->token == T_RDRAND) || (CodeInfo->token == T_RDSEED)){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1274		; 000004faH
	je	SHORT $LN25@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1275		; 000004fbH
	jne	SHORT $LN24@output_opc
$LN25@output_opc:

; 196  :     if ((CodeInfo->opnd[OPND1].type == OP_R16) || (CodeInfo->opnd[OPND1].type == OP_AX))

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 2
	je	SHORT $LN27@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 514		; 00000202H
	jne	SHORT $LN26@output_opc
$LN27@output_opc:

; 197  :       CodeInfo->prefix.opsiz = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	or	al, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN26@output_opc:
$LN24@output_opc:

; 198  :   } 
; 199  :   /*
; 200  :    * Check if CPU, FPU and extensions are within the limits
; 201  :    */
; 202  :   if ((ins->cpu & P_CPU_MASK) > (ModuleInfo.curr_cpu & P_CPU_MASK)
; 203  :     || (ins->cpu & P_FPU_MASK) > (ModuleInfo.curr_cpu & P_FPU_MASK)
; 204  :     || (ins->cpu & P_EXT_MASK) > (ModuleInfo.curr_cpu & P_EXT_MASK)) {

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, WORD PTR [rax+10]
	and	eax, 240				; 000000f0H
	mov	ecx, DWORD PTR ModuleInfo+392
	and	ecx, 240				; 000000f0H
	cmp	eax, ecx
	jg	SHORT $LN29@output_opc
	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, WORD PTR [rax+10]
	and	eax, 7
	mov	ecx, DWORD PTR ModuleInfo+392
	and	ecx, 7
	cmp	eax, ecx
	jg	SHORT $LN29@output_opc
	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, WORD PTR [rax+10]
	and	eax, 65280				; 0000ff00H
	mov	ecx, DWORD PTR ModuleInfo+392
	and	ecx, 65280				; 0000ff00H
	cmp	eax, ecx
	jle	SHORT $LN28@output_opc
$LN29@output_opc:

; 205  :     DebugMsg(("output_opc: wrong cpu setting: instr.cpu=%X, ModuleInfo.cpu=%X\n",

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, WORD PTR [rax+10]
	mov	r8d, DWORD PTR ModuleInfo+392
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG10687
	call	DoDebugMsg

; 206  :       ins->cpu, ModuleInfo.curr_cpu));
; 207  :     /* if instruction is valid for 16bit cpu, but operands aren't,
; 208  :      then display a more specific error message! */
; 209  :     if (ins->cpu == P_386 &&

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, WORD PTR [rax+10]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN30@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 455				; 000001c7H
	cdqe
	lea	rcx, OFFSET FLAT:optable_idx
	movzx	eax, WORD PTR [rcx+rax*2]
	imul	rax, rax, 14
	lea	rcx, OFFSET FLAT:InstrTable
	movzx	eax, WORD PTR [rcx+rax+10]
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jg	SHORT $LN30@output_opc

; 210  :       ((InstrTable[IndexFromToken(CodeInfo->token)].cpu & P_CPU_MASK) <= P_386))
; 211  :       EmitError(INSTRUCTION_FORM_REQUIRES_80386);

	mov	ecx, 238				; 000000eeH
	call	EmitError
	jmp	SHORT $LN31@output_opc
$LN30@output_opc:

; 212  :     else
; 213  :       EmitError(INSTRUCTION_OR_REGISTER_NOT_ACCEPTED_IN_CURRENT_CPU_MODE);

	mov	ecx, 30
	call	EmitError
$LN31@output_opc:
$LN28@output_opc:

; 214  :     //return( ERROR );
; 215  :   }
; 216  : 
; 217  :   /*
; 218  :    * Output FP fixup if required
; 219  :    * the OPs with NOWAIT are the instructions beginning with
; 220  :    * FN, except FNOP.
; 221  :    * the OPs with WAIT are the instructions:
; 222  :    * FCLEX, FDISI, FENI, FINIT, FSAVEx, FSTCW, FSTENVx, FSTSW
; 223  :    */
; 224  :   if ((ModuleInfo.emulator == TRUE) &&
; 225  :     (CodeInfo->Ofssize == USE16) &&
; 226  :     (ins->cpu & P_FPU_MASK) &&

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 9
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN32@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jne	SHORT $LN32@output_opc
	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, WORD PTR [rax+10]
	and	eax, 7
	test	eax, eax
	je	SHORT $LN32@output_opc
	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, WORD PTR [rax+2]
	cmp	eax, 5
	je	SHORT $LN32@output_opc

; 227  :     (ins->allowed_prefix != AP_NO_FWAIT)) {
; 228  :     fpfix = TRUE;

	mov	BYTE PTR fpfix$[rsp], 1

; 229  :     /* v2.04: no error is returned */
; 230  :     AddFloatingPointEmulationFixup(CodeInfo);

	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	AddFloatingPointEmulationFixup
$LN32@output_opc:

; 231  :   }
; 232  : 
; 233  :   /*
; 234  :    * Output instruction prefix LOCK, REP or REP[N]E|Z
; 235  :    */
; 236  :   if (CodeInfo->prefix.ins != EMPTY && (CodeInfo->token < T_VPGATHERDD || CodeInfo->token > T_VGATHERQPS)) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax], -2
	je	$LN33@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1345		; 00000541H
	jl	SHORT $LN34@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1352		; 00000548H
	jle	$LN33@output_opc
$LN34@output_opc:

; 237  :     tmp = InstrTable[IndexFromToken(CodeInfo->prefix.ins)].allowed_prefix;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax]
	sub	eax, 455				; 000001c7H
	cdqe
	lea	rcx, OFFSET FLAT:optable_idx
	movzx	eax, WORD PTR [rcx+rax*2]
	imul	rax, rax, 14
	lea	rcx, OFFSET FLAT:InstrTable
	movzx	eax, BYTE PTR [rcx+rax+2]
	mov	BYTE PTR tmp$[rsp], al

; 238  :     /* instruction prefix must be ok. However, with -Zm, the plain REP
; 239  :      * is also ok for instructions which expect REPxx.
; 240  :      */
; 241  :     if (ModuleInfo.m510 == TRUE &&
; 242  :       tmp == AP_REP &&

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 6
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN35@output_opc
	movzx	eax, BYTE PTR tmp$[rsp]
	cmp	eax, 2
	jne	SHORT $LN35@output_opc
	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, WORD PTR [rax+2]
	cmp	eax, 3
	jne	SHORT $LN35@output_opc

; 243  :       ins->allowed_prefix == AP_REPxx)
; 244  :       tmp = AP_REPxx;

	mov	BYTE PTR tmp$[rsp], 3
$LN35@output_opc:

; 245  : 
; 246  :     if (ins->allowed_prefix != tmp) {

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, WORD PTR [rax+2]
	movzx	ecx, BYTE PTR tmp$[rsp]
	cmp	eax, ecx
	je	SHORT $LN36@output_opc

; 247  :       EmitError(INSTRUCTION_PREFIX_NOT_ALLOWED);

	mov	ecx, 28
	call	EmitError

; 248  :     }

	jmp	SHORT $LN37@output_opc
$LN36@output_opc:

; 249  :     else
; 250  :       OutputCodeByte(InstrTable[IndexFromToken(CodeInfo->prefix.ins)].opcode);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax]
	sub	eax, 455				; 000001c7H
	cdqe
	lea	rcx, OFFSET FLAT:optable_idx
	movzx	eax, WORD PTR [rcx+rax*2]
	imul	rax, rax, 14
	lea	rcx, OFFSET FLAT:InstrTable
	movzx	ecx, BYTE PTR [rcx+rax+12]
	call	OutputByte
$LN37@output_opc:
$LN33@output_opc:

; 251  :   }
; 252  :   /*
; 253  :    * Output FP FWAIT if required
; 254  :    */
; 255  :   if (ins->cpu & P_FPU_MASK) {

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, WORD PTR [rax+10]
	and	eax, 7
	test	eax, eax
	je	SHORT $LN38@output_opc

; 256  :     if (CodeInfo->token == T_FWAIT) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 833			; 00000341H
	jne	SHORT $LN39@output_opc

; 257  :       /* v2.04: Masm will always insert a NOP if emulation is active,
; 258  :        * no matter what the current cpu is. The reason is simple: the
; 259  :        * nop is needed because of the fixup which was inserted.
; 260  :        */
; 261  :       //if(( ModuleInfo.curr_cpu & P_CPU_MASK ) < P_386 ) {
; 262  :       //    if(( ModuleInfo.emulator == TRUE ) && ( CodeInfo->Ofssize == USE16 )) {
; 263  :       if (fpfix) {

	movzx	eax, BYTE PTR fpfix$[rsp]
	test	eax, eax
	je	SHORT $LN41@output_opc

; 264  :         OutputCodeByte(OP_NOP);

	mov	cl, 144					; 00000090H
	call	OutputByte
$LN41@output_opc:

; 265  :       }
; 266  :     }

	jmp	SHORT $LN40@output_opc
$LN39@output_opc:

; 267  :     else if (fpfix || ins->allowed_prefix == AP_FWAIT) {

	movzx	eax, BYTE PTR fpfix$[rsp]
	test	eax, eax
	jne	SHORT $LN44@output_opc
	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, WORD PTR [rax+2]
	cmp	eax, 4
	jne	SHORT $LN42@output_opc
$LN44@output_opc:

; 268  :       OutputCodeByte(OP_WAIT);

	mov	cl, 155					; 0000009bH
	call	OutputByte

; 269  :     }

	jmp	SHORT $LN43@output_opc
$LN42@output_opc:

; 270  :     else if (ins->allowed_prefix != AP_NO_FWAIT) {

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, WORD PTR [rax+2]
	cmp	eax, 5
	je	SHORT $LN45@output_opc

; 271  :       /* implicit FWAIT synchronization for 8087 (CPU 8086/80186) */
; 272  :       if ((ModuleInfo.curr_cpu & P_CPU_MASK) < P_286)

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 32					; 00000020H
	jge	SHORT $LN46@output_opc

; 273  :         OutputCodeByte(OP_WAIT);

	mov	cl, 155					; 0000009bH
	call	OutputByte
$LN46@output_opc:
$LN45@output_opc:
$LN43@output_opc:
$LN40@output_opc:
$LN38@output_opc:

; 274  :     }
; 275  :   }
; 276  :   /*
; 277  :    * check if address/operand size prefix is to be set
; 278  :    */
; 279  :   switch (ins->byte1_info) {

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	DWORD PTR tv261[rsp], eax
	mov	eax, DWORD PTR tv261[rsp]
	dec	eax
	mov	DWORD PTR tv261[rsp], eax
	cmp	DWORD PTR tv261[rsp], 21
	ja	$LN2@output_opc
	movsxd	rax, DWORD PTR tv261[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN563@output_opc[rcx+rax]
	mov	eax, DWORD PTR $LN564@output_opc[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN47@output_opc:

; 280  :   case F_16:
; 281  :     if (CodeInfo->Ofssize >= USE32) CodeInfo->prefix.opsiz = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 1
	jl	SHORT $LN48@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	or	al, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN48@output_opc:

; 282  :     break;

	jmp	$LN2@output_opc
$LN49@output_opc:

; 283  :   case F_32:
; 284  :     if (CodeInfo->Ofssize == USE16) CodeInfo->prefix.opsiz = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jne	SHORT $LN50@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	or	al, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN50@output_opc:

; 285  :     break;

	jmp	$LN2@output_opc
$LN51@output_opc:

; 286  :   case F_16A: /* 16-bit JCXZ and LOOPcc */
; 287  :     /* doesnt exist for IA32+ */
; 288  :     if (CodeInfo->Ofssize == USE32) CodeInfo->prefix.adrsiz = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 1
	jne	SHORT $LN52@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	or	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN52@output_opc:

; 289  :     break;

	jmp	SHORT $LN2@output_opc
$LN53@output_opc:

; 290  :   case F_32A: /* 32-bit JECXZ and LOOPcc */
; 291  : #if AMD64_SUPPORT
; 292  :     /* in IA32+, the 32bit version gets an 0x67 prefix */
; 293  :     if (CodeInfo->Ofssize != USE32)  CodeInfo->prefix.adrsiz = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 1
	je	SHORT $LN54@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	or	al, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al
$LN54@output_opc:

; 294  : #else
; 295  :     if( CodeInfo->Ofssize == USE16 ) CodeInfo->prefix.adrsiz = TRUE;
; 296  : #endif
; 297  :     break;

	jmp	SHORT $LN2@output_opc
$LN55@output_opc:

; 298  :   case F_0FNO66:
; 299  :     CodeInfo->prefix.opsiz = FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 300  :     break;

	jmp	SHORT $LN2@output_opc
$LN56@output_opc:

; 301  : #if AMD64_SUPPORT
; 302  :   case F_48:
; 303  :   case F_480F:
; 304  :     CodeInfo->prefix.rex |= REX_W;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	or	eax, 8
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+8], al
$LN2@output_opc:

; 305  :     break;
; 306  : #endif
; 307  :   }
; 308  : 
; 309  : 
; 310  : #if AVXSUPP   
; 311  :   if (ResWordTable[CodeInfo->token].flags & RWF_EVEX)

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movsxd	rax, DWORD PTR [rax+24]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:ResWordTable
	movzx	eax, BYTE PTR [rcx+rax+3]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN57@output_opc

; 312  : 	  CodeInfo->evex_flag = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+136], 1
$LN57@output_opc:

; 313  :   if (!evex)

	movzx	eax, BYTE PTR evex
	test	eax, eax
	jne	SHORT $LN58@output_opc

; 314  : 	  CodeInfo->evex_flag = FALSE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+136], 0
$LN58@output_opc:

; 315  :   if (CodeInfo->evex_flag == TRUE) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	cmp	eax, 1
	jne	SHORT $LN59@output_opc

; 316  : 	  if (!(vex_flags[CodeInfo->token - VEX_START] & VX_LL))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 1296				; 00000510H
	cdqe
	lea	rcx, OFFSET FLAT:vex_flags
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	SHORT $LN60@output_opc

; 317  : 		  EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN60@output_opc:
$LN59@output_opc:

; 318  :   }
; 319  : 
; 320  :   if (!(ResWordTable[CodeInfo->token].flags & RWF_VEX)) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movsxd	rax, DWORD PTR [rax+24]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:ResWordTable
	movzx	eax, BYTE PTR [rcx+rax+3]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN61@output_opc

; 321  : #endif
; 322  : 
; 323  : 	switch (ins->byte1_info) {

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	DWORD PTR tv330[rsp], eax
	mov	eax, DWORD PTR tv330[rsp]
	sub	eax, 5
	mov	DWORD PTR tv330[rsp], eax
	cmp	DWORD PTR tv330[rsp], 22
	ja	SHORT $LN4@output_opc
	movsxd	rax, DWORD PTR tv330[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN561@output_opc[rcx+rax]
	mov	eax, DWORD PTR $LN562@output_opc[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN62@output_opc:

; 324  :     case F_660F:
; 325  :     case F_660F38:
; 326  :     case F_660F3A:
; 327  :       CodeInfo->prefix.opsiz = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	or	al, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+9], al

; 328  :       break;

	jmp	SHORT $LN4@output_opc
$LN63@output_opc:

; 329  :     case F_F20F:
; 330  :     case F_F20F38: OutputCodeByte(0xF2); break;

	mov	cl, 242					; 000000f2H
	call	OutputByte
	jmp	SHORT $LN4@output_opc
$LN64@output_opc:

; 331  :     case F_F3: /* PAUSE instruction */
; 332  :     case F_F30F:   OutputCodeByte(0xF3); break;

	mov	cl, 243					; 000000f3H
	call	OutputByte
$LN4@output_opc:
$LN61@output_opc:

; 333  :     }
; 334  : #if AVXSUPP
; 335  :   }
; 336  : #endif
; 337  :   /*
; 338  :    * Output address and operand size prefixes.
; 339  :    * These bytes are NOT compatible with FP emulation fixups,
; 340  :    * which expect that the FWAIT/NOP first "prefix" byte is followed
; 341  :    * by either a segment prefix or the opcode byte.
; 342  :    * Neither Masm nor HJWasm emit a warning, though.
; 343  :    */
; 344  :   if (CodeInfo->prefix.adrsiz == TRUE && (CodeInfo->token < T_VPGATHERDD || CodeInfo->token > T_VSCATTERQPD)) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN65@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1345		; 00000541H
	jl	SHORT $LN66@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1360		; 00000550H
	jle	SHORT $LN65@output_opc
$LN66@output_opc:

; 345  :     OutputCodeByte(ADRSIZ);

	mov	cl, 103					; 00000067H
	call	OutputByte

; 346  : #ifdef DEBUG_OUT
; 347  :     if (fpfix)

	movzx	eax, BYTE PTR fpfix$[rsp]
	test	eax, eax
	je	SHORT $LN67@output_opc

; 348  :       DebugMsg(("output_opc: ERROR: FP emulation byte sequence destroyed by 32-bit address prefix!\n"));

	lea	rcx, OFFSET FLAT:$SG10726
	call	DoDebugMsg
$LN67@output_opc:
$LN65@output_opc:

; 349  : #endif
; 350  :   }
; 351  :   if (CodeInfo->prefix.opsiz == TRUE) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN68@output_opc

; 352  : #if 1
; 353  :     if ((ModuleInfo.curr_cpu & P_CPU_MASK) < P_386) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jge	SHORT $LN69@output_opc

; 354  :       DebugMsg(("output_opc: instruction form requires 386\n"));

	lea	rcx, OFFSET FLAT:$SG10729
	call	DoDebugMsg

; 355  :       EmitError(INSTRUCTION_FORM_REQUIRES_80386);

	mov	ecx, 238				; 000000eeH
	call	EmitError
$LN69@output_opc:

; 356  :       //return( ERROR ); /* v2.06: don't skip instruction */
; 357  :     }
; 358  : #endif
; 359  :     OutputCodeByte(OPSIZ);

	mov	cl, 102					; 00000066H
	call	OutputByte
$LN68@output_opc:

; 360  :   }
; 361  :   /*
; 362  :    * Output segment prefix
; 363  :    */
; 364  :   if (CodeInfo->prefix.RegOverride != EMPTY) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+4], -2
	je	SHORT $LN70@output_opc

; 365  :     OutputCodeByte(sr_prefix[CodeInfo->prefix.RegOverride]);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movsxd	rax, DWORD PTR [rax+4]
	lea	rcx, OFFSET FLAT:sr_prefix
	movzx	ecx, BYTE PTR [rcx+rax]
	call	OutputByte
$LN70@output_opc:

; 366  :   }
; 367  :   if (ins->opnd_dir) {

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+6]
	test	eax, eax
	je	SHORT $LN71@output_opc

; 368  :     /* The reg and r/m fields are backwards */
; 369  :     tmp = CodeInfo->rm_byte;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+104]
	mov	BYTE PTR tmp$[rsp], al

; 370  :     CodeInfo->rm_byte = (tmp & 0xc0) | ((tmp >> 3) & 0x7) | ((tmp << 3) & 0x38);

	movzx	eax, BYTE PTR tmp$[rsp]
	and	eax, 192				; 000000c0H
	movzx	ecx, BYTE PTR tmp$[rsp]
	sar	ecx, 3
	and	ecx, 7
	or	eax, ecx
	movzx	ecx, BYTE PTR tmp$[rsp]
	shl	ecx, 3
	and	ecx, 56					; 00000038H
	or	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+104], al

; 371  : #if AMD64_SUPPORT
; 372  :     tmp = CodeInfo->prefix.rex;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	mov	BYTE PTR tmp$[rsp], al

; 373  :     CodeInfo->prefix.rex = (tmp & 0xFA) | ((tmp & REX_R) >> 2) | ((tmp & REX_B) << 2);

	movzx	eax, BYTE PTR tmp$[rsp]
	and	eax, 250				; 000000faH
	movzx	ecx, BYTE PTR tmp$[rsp]
	and	ecx, 4
	sar	ecx, 2
	or	eax, ecx
	movzx	ecx, BYTE PTR tmp$[rsp]
	and	ecx, 1
	shl	ecx, 2
	or	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+8], al
$LN71@output_opc:

; 374  : #endif
; 375  :   }
; 376  : #if AVXSUPP
; 377  :   if (ResWordTable[CodeInfo->token].flags & RWF_VEX) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movsxd	rax, DWORD PTR [rax+24]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:ResWordTable
	movzx	eax, BYTE PTR [rcx+rax+3]
	and	eax, 8
	test	eax, eax
	je	$LN72@output_opc

; 378  :     uint_8 lbyte = 0;

	mov	BYTE PTR lbyte$1[rsp], 0

; 379  :     if (CodeInfo->evex_flag){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	je	SHORT $LN74@output_opc

; 380  :       lbyte |= 0x4;              //bite 3 must be set in P2 WVVVV1PP 

	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 4
	mov	BYTE PTR lbyte$1[rsp], al
$LN74@output_opc:

; 381  :     }
; 382  :     switch (ins->byte1_info) {

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	DWORD PTR tv412[rsp], eax
	mov	eax, DWORD PTR tv412[rsp]
	sub	eax, 18
	mov	DWORD PTR tv412[rsp], eax
	cmp	DWORD PTR tv412[rsp], 10
	ja	SHORT $LN6@output_opc
	movsxd	rax, DWORD PTR tv412[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN560@output_opc[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN75@output_opc:

; 383  :     case F_660F:
; 384  :     case F_660F38:
; 385  :     case F_660F3A:
; 386  :       lbyte |= 0x01;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 1
	mov	BYTE PTR lbyte$1[rsp], al

; 387  :       break;

	jmp	SHORT $LN6@output_opc
$LN76@output_opc:

; 388  :     case F_F30F:
; 389  :     case F_F30F38:
; 390  :       lbyte |= 0x02;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 2
	mov	BYTE PTR lbyte$1[rsp], al

; 391  :       break;

	jmp	SHORT $LN6@output_opc
$LN77@output_opc:

; 392  :     case F_F20F:
; 393  :     case F_F20F38:
; 394  :       lbyte |= 0x03;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 3
	mov	BYTE PTR lbyte$1[rsp], al
$LN6@output_opc:

; 395  :       break;
; 396  :     }
; 397  :     if ((CodeInfo->token >= T_VSHUFF32X4) && (CodeInfo->token <= T_VSHUFI64X2) &&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1594		; 0000063aH
	jl	SHORT $LN78@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1597		; 0000063dH
	jg	SHORT $LN78@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN79@output_opc
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN78@output_opc
$LN79@output_opc:

; 398  :       ((CodeInfo->opnd[OPND1].type & OP_XMM) || (CodeInfo->opnd[OPND2].type & OP_XMM)))
; 399  :       EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS); //Only YMM and ZMM alowed    

	mov	ecx, 14
	call	EmitError
$LN78@output_opc:

; 400  :     if (CodeInfo->vexregop)

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	test	eax, eax
	je	SHORT $LN80@output_opc

; 401  :       lbyte |= ((16 - CodeInfo->vexregop) << 3);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	mov	ecx, 16
	sub	ecx, eax
	mov	eax, ecx
	shl	eax, 3
	movzx	ecx, BYTE PTR lbyte$1[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR lbyte$1[rsp], al
	jmp	SHORT $LN81@output_opc
$LN80@output_opc:

; 402  :     else {
; 403  :       lbyte |= EVEX_P1VVVV;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 120				; 00000078H
	mov	BYTE PTR lbyte$1[rsp], al

; 404  :       CodeInfo->evex_p2 |= EVEX_P2VMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 8
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN81@output_opc:

; 405  :     }
; 406  : 	if ((CodeInfo->token >= T_VBROADCASTF128) && (CodeInfo->token <= T_VPBROADCASTQ)) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1298		; 00000512H
	jl	SHORT $LN82@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1302		; 00000516H
	jg	SHORT $LN82@output_opc

; 407  : 		if (!decoflags)CodeInfo->evex_flag = 0;

	movzx	eax, BYTE PTR decoflags
	test	eax, eax
	jne	SHORT $LN83@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+136], 0
$LN83@output_opc:
$LN82@output_opc:

; 408  : 	}
; 409  :         /* emit 4 byte (0x62), 3 (0xC4) or 2 (0xC5) byte VEX prefix */
; 410  :         if ((CodeInfo->token ==  T_VMOVMSKPD )||(CodeInfo->token ==  T_VMOVMSKPS )) 

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1946		; 0000079aH
	je	SHORT $LN85@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1947		; 0000079bH
	jne	SHORT $LN84@output_opc
$LN85@output_opc:

; 411  :           CodeInfo->prefix.rex &= ~REX_W;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	and	eax, -9
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+8], al
$LN84@output_opc:

; 412  :         if (( ins->byte1_info >= F_0F38) || ( CodeInfo->prefix.rex & ( REX_B | REX_X | REX_W ) )|| 
; 413  :           (( ins->byte1_info == F_0F) && (CodeInfo->token ==  T_KMOVQ )) || (ins->byte1_info == F_660F) && 

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 23
	jge	SHORT $LN88@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	and	eax, 11
	test	eax, eax
	jne	SHORT $LN88@output_opc
	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 16
	jne	SHORT $LN89@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1732		; 000006c4H
	je	SHORT $LN88@output_opc
$LN89@output_opc:
	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 18
	jne	$LN86@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1731		; 000006c3H
	jne	$LN86@output_opc
$LN88@output_opc:

; 414  :            (CodeInfo->token ==  T_KMOVD )){
; 415  :             uint_8 byte1 = 0;      //RXBR00MM

	mov	BYTE PTR byte1$2[rsp], 0

; 416  :             /* first byte is 0xC4  in 3 byte VEX prefix */  
; 417  :             if (CodeInfo->evex_flag) 

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	je	SHORT $LN90@output_opc

; 418  :               OutputCodeByte( 0x62 ); //AVX512 EVEX first byte

	mov	cl, 98					; 00000062H
	call	OutputByte
	jmp	$LN91@output_opc
$LN90@output_opc:

; 419  :             else{
; 420  :               OutputCodeByte(0xC4);

	mov	cl, 196					; 000000c4H
	call	OutputByte

; 421  :               if (CodeInfo->opnd[OPND1].type == OP_YMM || CodeInfo->opnd[OPND2].type == OP_YMM)

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 128		; 00000080H
	je	SHORT $LN94@output_opc
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 128		; 00000080H
	jne	SHORT $LN92@output_opc
$LN94@output_opc:

; 422  :                  lbyte |= 0x04;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 4
	mov	BYTE PTR lbyte$1[rsp], al
	jmp	SHORT $LN93@output_opc
$LN92@output_opc:

; 423  :               else
; 424  :                 lbyte &= ~0x04;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	and	eax, -5
	mov	BYTE PTR lbyte$1[rsp], al
$LN93@output_opc:

; 425  :               CodeInfo->tuple = 0;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 0

; 426  :               /* This fixes AVX  REX_W wide 32 <-> 64 instructions third byte bit W*/
; 427  :               lbyte &= ~EVEX_P1WMASK;        //make sure it is not set if not 64 bit

	movzx	eax, BYTE PTR lbyte$1[rsp]
	btr	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al

; 428  :               lbyte |= ((CodeInfo->pinstr->prefix) >> 8 & 0x80); // set only W bit if 64 bit

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+8]
	sar	eax, 8
	and	eax, 128				; 00000080H
	movzx	ecx, BYTE PTR lbyte$1[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR lbyte$1[rsp], al
$LN91@output_opc:

; 429  :             }
; 430  :             switch ( ins->byte1_info ) {                     

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	DWORD PTR tv527[rsp], eax
	mov	eax, DWORD PTR tv527[rsp]
	sub	eax, 23
	mov	DWORD PTR tv527[rsp], eax
	cmp	DWORD PTR tv527[rsp], 6
	ja	SHORT $LN97@output_opc
	movsxd	rax, DWORD PTR tv527[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN559@output_opc[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN95@output_opc:

; 431  :             case F_0F38:                                     
; 432  :             case F_660F38:                                   
; 433  :             case F_F20F38:
; 434  :             case F_F30F38:
; 435  :                 byte1 |= 0x02;

	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 2
	mov	BYTE PTR byte1$2[rsp], al

; 436  :                 break;

	jmp	SHORT $LN8@output_opc
$LN96@output_opc:

; 437  :             case F_0F3A:
; 438  :             case F_660F3A:
; 439  :             case F_F20F3A:
; 440  :                 byte1 |= 0x03;

	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 3
	mov	BYTE PTR byte1$2[rsp], al

; 441  :                 break;

	jmp	SHORT $LN8@output_opc
$LN97@output_opc:

; 442  :             default:
; 443  :                 if ( ins->byte1_info >= F_0F )

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 16
	jl	SHORT $LN98@output_opc

; 444  :                     byte1 |= 0x01;

	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 1
	mov	BYTE PTR byte1$2[rsp], al
$LN98@output_opc:
$LN8@output_opc:

; 445  :             }
; 446  :               byte1 |= ((CodeInfo->prefix.rex & REX_B) ? 0 : 0x20);/*  REX_B regno 0-7 <-> 8-15 of ModR/M or SIB base */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN548@output_opc
	mov	DWORD PTR tv546[rsp], 0
	jmp	SHORT $LN549@output_opc
$LN548@output_opc:
	mov	DWORD PTR tv546[rsp], 32		; 00000020H
$LN549@output_opc:
	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, DWORD PTR tv546[rsp]
	mov	BYTE PTR byte1$2[rsp], al

; 447  :               byte1 |= ((CodeInfo->prefix.rex & REX_X) ? 0 : 0x40);/*  REX_X regno 0-7 <-> 8-15 of SIB index */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN550@output_opc
	mov	DWORD PTR tv554[rsp], 0
	jmp	SHORT $LN551@output_opc
$LN550@output_opc:
	mov	DWORD PTR tv554[rsp], 64		; 00000040H
$LN551@output_opc:
	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, DWORD PTR tv554[rsp]
	mov	BYTE PTR byte1$2[rsp], al

; 448  :               byte1 |= ((CodeInfo->prefix.rex & REX_R) ? 0 : 0x80);/*  REX_R regno 0-7 <-> 8-15 of ModR/M REG */

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN552@output_opc
	mov	DWORD PTR tv562[rsp], 0
	jmp	SHORT $LN553@output_opc
$LN552@output_opc:
	mov	DWORD PTR tv562[rsp], 128		; 00000080H
$LN553@output_opc:
	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, DWORD PTR tv562[rsp]
	mov	BYTE PTR byte1$2[rsp], al

; 449  :               //this still needs to be checked
; 450  :               if ((CodeInfo->evex_flag)&& (CodeInfo->reg2 <= 15))byte1 |= EVEX_P0R1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	je	SHORT $LN99@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 15
	jg	SHORT $LN99@output_opc
	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 16
	mov	BYTE PTR byte1$2[rsp], al
$LN99@output_opc:

; 451  :             /* second byte is RXBm mmmm of 3 byte  VEX prefix */    /*  REX_W wide 32 <-> 64 */
; 452  :                if ((CodeInfo->evex_flag) && (CodeInfo->token != T_VEXTRACTPS)){ 

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	je	$LN100@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1922		; 00000782H
	je	$LN100@output_opc

; 453  :                  if ((CodeInfo->opnd[OPND1].type & OP_M_ANY) || (CodeInfo->opnd[OPND2].type & OP_M_ANY) ||

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, -8388608				; ffffffffff800000H
	test	eax, eax
	jne	SHORT $LN102@output_opc
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, -8388608				; ffffffffff800000H
	test	eax, eax
	jne	SHORT $LN102@output_opc
	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, -8388608				; ffffffffff800000H
	test	eax, eax
	je	SHORT $LN101@output_opc
$LN102@output_opc:

; 454  :                    (CodeInfo->opnd[OPND3].type & OP_M_ANY)) CodeInfo->tuple = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 1
$LN101@output_opc:

; 455  :                  lbyte &= ~EVEX_P1WMASK;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	btr	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al

; 456  :                  lbyte |= ((CodeInfo->pinstr->prefix) >> 8 & 0x80);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+8]
	sar	eax, 8
	and	eax, 128				; 00000080H
	movzx	ecx, BYTE PTR lbyte$1[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR lbyte$1[rsp], al

; 457  :                  if ((CodeInfo->opnd[OPND2].type == OP_M64)||(CodeInfo->opnd[OPND1].type == OP_M64)) 

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 67108864	; 04000000H
	je	SHORT $LN104@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 67108864	; 04000000H
	jne	SHORT $LN103@output_opc
$LN104@output_opc:

; 458  :                    lbyte |= EVEX_P1WMASK;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	bts	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN103@output_opc:

; 459  :                  if ((CodeInfo->opnd[OPND2].type == OP_R32) || (CodeInfo->opnd[OPND2].type == OP_EAX)||
; 460  :                     (CodeInfo->opnd[OPND1].type == OP_R32) || (CodeInfo->opnd[OPND1].type == OP_EAX)){

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 4
	je	SHORT $LN106@output_opc
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 516		; 00000204H
	je	SHORT $LN106@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 4
	je	SHORT $LN106@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 516		; 00000204H
	jne	SHORT $LN105@output_opc
$LN106@output_opc:

; 461  :                    lbyte &= ~EVEX_P1WMASK;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	btr	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN105@output_opc:

; 462  :                  }
; 463  :                  if (((CodeInfo->opnd[OPND1].type & OP_M_ANY) == 0)&&

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, -8388608				; ffffffffff800000H
	test	eax, eax
	jne	$LN107@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1433		; 00000599H
	je	$LN107@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1576		; 00000628H
	je	$LN107@output_opc

; 464  :                    ((CodeInfo->token != T_VCVTPS2PH) && CodeInfo->token != T_VPMOVQB)) {
; 465  :                    if (CodeInfo->reg1 <= 15)

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 15
	jg	SHORT $LN108@output_opc

; 466  :                      byte1 |= EVEX_P0R1MASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 16
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN109@output_opc
$LN108@output_opc:

; 467  :                    else
; 468  :                      byte1 &= ~EVEX_P0R1MASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	and	eax, -17
	mov	BYTE PTR byte1$2[rsp], al
$LN109@output_opc:

; 469  :                    if ((CodeInfo->reg1 <= 7) || (CodeInfo->reg1 >= 16 && CodeInfo->reg1 <= 23))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 7
	jle	SHORT $LN112@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 16
	jl	SHORT $LN110@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 23
	jg	SHORT $LN110@output_opc
$LN112@output_opc:

; 470  :                      byte1 |= EVEX_P0RMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	bts	eax, 7
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN111@output_opc
$LN110@output_opc:

; 471  :                    else
; 472  :                      byte1 &= ~EVEX_P0RMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	btr	eax, 7
	mov	BYTE PTR byte1$2[rsp], al
$LN111@output_opc:

; 473  :                    if (CodeInfo->reg3 != 0xff)     

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+111]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN113@output_opc

; 474  :                      rn = CodeInfo->reg3;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+111]
	mov	DWORD PTR rn$[rsp], eax
	jmp	SHORT $LN114@output_opc
$LN113@output_opc:

; 475  :                    else if (CodeInfo->basereg != 0xff)

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN115@output_opc

; 476  :                      rn = CodeInfo->basereg;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	mov	DWORD PTR rn$[rsp], eax
	jmp	SHORT $LN116@output_opc
$LN115@output_opc:

; 477  :                    else rn = CodeInfo->reg2;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	mov	DWORD PTR rn$[rsp], eax
$LN116@output_opc:
$LN114@output_opc:

; 478  :                    if (rn > 15){

	cmp	DWORD PTR rn$[rsp], 15
	jle	SHORT $LN117@output_opc

; 479  :                      rn -= 15;

	mov	eax, DWORD PTR rn$[rsp]
	sub	eax, 15
	mov	DWORD PTR rn$[rsp], eax

; 480  :                      byte1 &= ~EVEX_P0XMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	and	eax, -65				; ffffffffffffffbfH
	mov	BYTE PTR byte1$2[rsp], al
$LN117@output_opc:

; 481  :                    }
; 482  :                    if (rn <= 7)byte1 |= EVEX_P0BMASK;

	cmp	DWORD PTR rn$[rsp], 7
	jg	SHORT $LN118@output_opc
	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 32					; 00000020H
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN119@output_opc
$LN118@output_opc:

; 483  :                    else byte1 &= ~EVEX_P0BMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	and	eax, -33				; ffffffffffffffdfH
	mov	BYTE PTR byte1$2[rsp], al
$LN119@output_opc:
$LN107@output_opc:
$LN100@output_opc:

; 484  :                  }
; 485  :                }
; 486  :             if (CodeInfo->token >= T_VPSCATTERDD && CodeInfo->token <= T_VSCATTERQPD){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1353		; 00000549H
	jl	$LN120@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1360		; 00000550H
	jg	$LN120@output_opc

; 487  :               if (CodeInfo->reg2 <= 15) byte1 |= EVEX_P0R1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 15
	jg	SHORT $LN121@output_opc
	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 16
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN122@output_opc
$LN121@output_opc:

; 488  :               else byte1 &= ~EVEX_P0R1MASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	and	eax, -17
	mov	BYTE PTR byte1$2[rsp], al
$LN122@output_opc:

; 489  :               if (CodeInfo->reg2 <= 7 )  byte1 |= EVEX_P0RMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 7
	jg	SHORT $LN123@output_opc
	movzx	eax, BYTE PTR byte1$2[rsp]
	bts	eax, 7
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN124@output_opc
$LN123@output_opc:

; 490  :               else if (CodeInfo->reg2 >= 16 && CodeInfo->reg2 <= 23) byte1 |= EVEX_P0RMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 16
	jl	SHORT $LN125@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 23
	jg	SHORT $LN125@output_opc
	movzx	eax, BYTE PTR byte1$2[rsp]
	bts	eax, 7
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN126@output_opc
$LN125@output_opc:

; 491  :               else byte1 &= ~EVEX_P0RMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	btr	eax, 7
	mov	BYTE PTR byte1$2[rsp], al
$LN126@output_opc:
$LN124@output_opc:
$LN120@output_opc:

; 492  :             }
; 493  :               if (((CodeInfo->token == T_VMOVHPS)||(CodeInfo->token == T_VMOVLPS)) && (CodeInfo->opnd[OPND2].type & OP_XMM)){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1941		; 00000795H
	je	SHORT $LN128@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1943		; 00000797H
	jne	SHORT $LN127@output_opc
$LN128@output_opc:
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN127@output_opc

; 494  :                 if ((CodeInfo->reg2 > 7))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 7
	jle	SHORT $LN129@output_opc

; 495  :                     byte1 &= ~EVEX_P0RMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	btr	eax, 7
	mov	BYTE PTR byte1$2[rsp], al
$LN129@output_opc:

; 496  :                     lbyte &= ~EVEX_P1WMASK;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	btr	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN127@output_opc:

; 497  :               }
; 498  :               if ((CodeInfo->token == T_VMOVNTPD)||(CodeInfo->token == T_VMOVNTPS)||                                

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1950		; 0000079eH
	je	SHORT $LN131@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1951		; 0000079fH
	je	SHORT $LN131@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1576		; 00000628H
	jl	$LN130@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1590		; 00000636H
	jg	$LN130@output_opc
$LN131@output_opc:

; 499  :                 (CodeInfo->token >= T_VPMOVQB)&&(CodeInfo->token <= T_VPMOVUSDW)){
; 500  :                 if (CodeInfo->reg2 <= 15) byte1 |= EVEX_P0R1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 15
	jg	SHORT $LN132@output_opc
	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 16
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN133@output_opc
$LN132@output_opc:

; 501  :                 else byte1 &= ~EVEX_P0R1MASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	and	eax, -17
	mov	BYTE PTR byte1$2[rsp], al
$LN133@output_opc:

; 502  :                 if ((CodeInfo->reg2 <= 7) || (CodeInfo->reg2 >= 16 && CodeInfo->reg2 <= 23))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 7
	jle	SHORT $LN136@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 16
	jl	SHORT $LN134@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 23
	jg	SHORT $LN134@output_opc
$LN136@output_opc:

; 503  :                   byte1 |= EVEX_P0RMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	bts	eax, 7
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN135@output_opc
$LN134@output_opc:

; 504  :                 else byte1 &= ~EVEX_P0RMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	btr	eax, 7
	mov	BYTE PTR byte1$2[rsp], al
$LN135@output_opc:

; 505  :                 if (CodeInfo->reg1 <= 15) byte1 |= EVEX_P0XMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 15
	jg	SHORT $LN137@output_opc
	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 64					; 00000040H
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN138@output_opc
$LN137@output_opc:

; 506  :                 else byte1 &= ~EVEX_P0XMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	and	eax, -65				; ffffffffffffffbfH
	mov	BYTE PTR byte1$2[rsp], al
$LN138@output_opc:

; 507  :                 if ((CodeInfo->reg1 <= 7) || (CodeInfo->reg1 >= 16 && CodeInfo->reg1 <= 23))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 7
	jle	SHORT $LN141@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 16
	jl	SHORT $LN139@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 23
	jg	SHORT $LN139@output_opc
$LN141@output_opc:

; 508  :                   byte1 |= EVEX_P0BMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 32					; 00000020H
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN140@output_opc
$LN139@output_opc:

; 509  :                 else byte1 &= ~EVEX_P0BMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	and	eax, -33				; ffffffffffffffdfH
	mov	BYTE PTR byte1$2[rsp], al
$LN140@output_opc:
$LN130@output_opc:

; 510  :               }
; 511  :               if (CodeInfo->opnd[OPND2].type == OP_I8){

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 131072		; 00020000H
	jne	$LN142@output_opc

; 512  :                 if ((CodeInfo->token >= T_VPSLLW) && (CodeInfo->token <= T_VPSRLQ) ||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2044		; 000007fcH
	jl	SHORT $LN145@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2051		; 00000803H
	jle	SHORT $LN144@output_opc
$LN145@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1534		; 000005feH
	jl	$LN143@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1551		; 0000060fH
	jg	$LN143@output_opc
$LN144@output_opc:

; 513  :                   (CodeInfo->token >= T_VPSLLVD) && (CodeInfo->token <= T_VPSRLVW)){
; 514  :                   //__debugbreak();
; 515  :                   byte1 |= EVEX_P0R1MASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 16
	mov	BYTE PTR byte1$2[rsp], al

; 516  :                   byte1 |= EVEX_P0RMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	bts	eax, 7
	mov	BYTE PTR byte1$2[rsp], al

; 517  :                   if ((CodeInfo->opnd[OPND1].type == OP_R64) || (CodeInfo->opnd[OPND1].type == OP_RAX) ||
; 518  :                     (CodeInfo->opnd[OPND1].type == OP_R32) || (CodeInfo->opnd[OPND1].type == OP_EAX)){

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 8
	je	SHORT $LN148@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 520		; 00000208H
	je	SHORT $LN148@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 4
	je	SHORT $LN148@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 516		; 00000204H
	jne	SHORT $LN146@output_opc
$LN148@output_opc:

; 519  :                       if (CodeInfo->basereg != 0xFF){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN149@output_opc

; 520  :                         if (CodeInfo->basereg <= 7)   

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	cmp	eax, 7
	jg	SHORT $LN150@output_opc

; 521  :                           byte1 |= EVEX_P0BMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 32					; 00000020H
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN151@output_opc
$LN150@output_opc:

; 522  :                         else
; 523  :                           byte1 &= ~EVEX_P0BMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	and	eax, -33				; ffffffffffffffdfH
	mov	BYTE PTR byte1$2[rsp], al
$LN151@output_opc:
$LN149@output_opc:

; 524  :                       }
; 525  :                     if (CodeInfo->indexreg != 0xFF){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+112]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN152@output_opc

; 526  :                       if (CodeInfo->indexreg <= 7)   

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+112]
	cmp	eax, 7
	jg	SHORT $LN153@output_opc

; 527  :                         byte1 |= EVEX_P0XMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 64					; 00000040H
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN154@output_opc
$LN153@output_opc:

; 528  :                       else
; 529  :                         byte1 &= ~EVEX_P0XMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	and	eax, -65				; ffffffffffffffbfH
	mov	BYTE PTR byte1$2[rsp], al
$LN154@output_opc:
$LN152@output_opc:

; 530  :                     }
; 531  :                   }

	jmp	SHORT $LN147@output_opc
$LN146@output_opc:

; 532  :                   else if (!CodeInfo->evex_flag)

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	jne	SHORT $LN155@output_opc

; 533  :                     byte1 &= ~EVEX_P0R1MASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	and	eax, -17
	mov	BYTE PTR byte1$2[rsp], al
$LN155@output_opc:
$LN147@output_opc:
$LN143@output_opc:
$LN142@output_opc:

; 534  :                 }
; 535  :               }
; 536  :               if ((CodeInfo->token == T_VRNDSCALEPD) || (CodeInfo->token == T_VRNDSCALEPS)){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1615		; 0000064fH
	je	SHORT $LN157@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1616		; 00000650H
	jne	$LN156@output_opc
$LN157@output_opc:

; 537  :                 if (((CodeInfo->r2type &= OP_R64)||(CodeInfo->r2type &= OP_R32))&&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+120]
	and	eax, 8
	mov	DWORD PTR tv885[rsp], eax
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR tv885[rsp]
	mov	DWORD PTR [rax+120], ecx
	cmp	DWORD PTR tv885[rsp], 0
	jne	SHORT $LN159@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+120]
	and	eax, 4
	mov	DWORD PTR tv889[rsp], eax
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR tv889[rsp]
	mov	DWORD PTR [rax+120], ecx
	cmp	DWORD PTR tv889[rsp], 0
	je	SHORT $LN158@output_opc
$LN159@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+124], 0
	je	SHORT $LN158@output_opc

; 538  :                   (CodeInfo->vexconst)) { 
; 539  :                   if (CodeInfo->indexreg != 0xff){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+112]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN160@output_opc

; 540  :                     if (CodeInfo->reg1 <= 7)

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 7
	jg	SHORT $LN161@output_opc

; 541  :                       byte1 |= EVEX_P0XMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 64					; 00000040H
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN162@output_opc
$LN161@output_opc:

; 542  :                     else
; 543  :                       byte1 &= ~EVEX_P0XMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	and	eax, -65				; ffffffffffffffbfH
	mov	BYTE PTR byte1$2[rsp], al
$LN162@output_opc:
$LN160@output_opc:
$LN158@output_opc:
$LN156@output_opc:

; 544  :                   }
; 545  :                 }
; 546  :               }
; 547  :               if (((CodeInfo->token == T_VEXTRACTF32x8)||(CodeInfo->token == T_VEXTRACTF64x4))
; 548  :                 && !(CodeInfo->opnd[OPND1].type & OP_M_ANY)) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1319		; 00000527H
	je	SHORT $LN164@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1320		; 00000528H
	jne	$LN163@output_opc
$LN164@output_opc:
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, -8388608				; ffffffffff800000H
	test	eax, eax
	jne	$LN163@output_opc

; 549  :                 if (CodeInfo->reg2 <= 15) byte1 |= EVEX_P0R1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 15
	jg	SHORT $LN165@output_opc
	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 16
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN166@output_opc
$LN165@output_opc:

; 550  :                 else byte1 &= ~EVEX_P0R1MASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	and	eax, -17
	mov	BYTE PTR byte1$2[rsp], al
$LN166@output_opc:

; 551  :                 if ((CodeInfo->reg2 <= 7) || (CodeInfo->reg2 >= 16 && CodeInfo->reg2 <= 23))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 7
	jle	SHORT $LN169@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 16
	jl	SHORT $LN167@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 23
	jg	SHORT $LN167@output_opc
$LN169@output_opc:

; 552  :                   byte1 |= EVEX_P0RMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	bts	eax, 7
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN168@output_opc
$LN167@output_opc:

; 553  :                 else
; 554  :                   byte1 &= ~EVEX_P0RMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	btr	eax, 7
	mov	BYTE PTR byte1$2[rsp], al
$LN168@output_opc:

; 555  :                 if (CodeInfo->reg1 <= 15) byte1 |= EVEX_P0XMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 15
	jg	SHORT $LN170@output_opc
	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 64					; 00000040H
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN171@output_opc
$LN170@output_opc:

; 556  :                 else byte1 &= ~EVEX_P0XMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	and	eax, -65				; ffffffffffffffbfH
	mov	BYTE PTR byte1$2[rsp], al
$LN171@output_opc:
$LN163@output_opc:

; 557  :               }
; 558  :               if (((CodeInfo->token >= T_BEXTR)&&(CodeInfo->token <= T_SHRX)||(CodeInfo->token == T_BZHI)&&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1676		; 0000068cH
	jl	SHORT $LN174@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1679		; 0000068fH
	jle	SHORT $LN173@output_opc
$LN174@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1683		; 00000693H
	jne	SHORT $LN172@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+112]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN172@output_opc
$LN173@output_opc:

; 559  :                 (CodeInfo->indexreg != 0xFF))){
; 560  :                 byte1 &= 0xE3;

	movzx	eax, BYTE PTR byte1$2[rsp]
	and	eax, 227				; 000000e3H
	mov	BYTE PTR byte1$2[rsp], al

; 561  :                 if (CodeInfo->indexreg > 0x07)byte1 &= ~0x10;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+112]
	cmp	eax, 7
	jle	SHORT $LN175@output_opc
	movzx	eax, BYTE PTR byte1$2[rsp]
	and	eax, -17
	mov	BYTE PTR byte1$2[rsp], al
$LN175@output_opc:
$LN172@output_opc:

; 562  :               }
; 563  :               if (CodeInfo->token == T_VCVTPH2PS || CodeInfo->token == T_VCVTPD2UDQ||
; 564  :                 CodeInfo->token == T_VCVTPD2DQ || CodeInfo->token == T_VCVTDQ2PD){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1432		; 00000598H
	je	SHORT $LN177@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1340		; 0000053cH
	je	SHORT $LN177@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1339		; 0000053bH
	je	SHORT $LN177@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1904		; 00000770H
	jne	$LN176@output_opc
$LN177@output_opc:

; 565  :                 if ((CodeInfo->reg1 <= 7) || (CodeInfo->reg1 >= 16 && CodeInfo->reg1 <= 23))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 7
	jle	SHORT $LN180@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 16
	jl	SHORT $LN178@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 23
	jg	SHORT $LN178@output_opc
$LN180@output_opc:

; 566  :                   byte1 |= EVEX_P0RMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	bts	eax, 7
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN179@output_opc
$LN178@output_opc:

; 567  :                 else
; 568  :                   byte1 &= ~EVEX_P0RMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	btr	eax, 7
	mov	BYTE PTR byte1$2[rsp], al
$LN179@output_opc:

; 569  :                 if (CodeInfo->reg2 <= 15) byte1 |= EVEX_P0XMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 15
	jg	SHORT $LN181@output_opc
	movzx	eax, BYTE PTR byte1$2[rsp]
	or	eax, 64					; 00000040H
	mov	BYTE PTR byte1$2[rsp], al
	jmp	SHORT $LN182@output_opc
$LN181@output_opc:

; 570  :                 else byte1 &= ~EVEX_P0XMASK;

	movzx	eax, BYTE PTR byte1$2[rsp]
	and	eax, -65				; ffffffffffffffbfH
	mov	BYTE PTR byte1$2[rsp], al
$LN182@output_opc:

; 571  :                 if (CodeInfo->token == T_VCVTDQ2PD)

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1904		; 00000770H
	jne	SHORT $LN183@output_opc

; 572  :                 CodeInfo->evex_p2 &= ~EVEX_P2L1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -65				; ffffffffffffffbfH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN183@output_opc:
$LN176@output_opc:

; 573  :               }
; 574  :               OutputCodeByte( byte1 );

	movzx	ecx, BYTE PTR byte1$2[rsp]
	call	OutputByte

; 575  :               //ovde treba proveriti sada je 91 a treba biti D1
; 576  :               if (CodeInfo->opnd[OPND2].type == OP_I8){

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 131072		; 00020000H
	jne	$LN184@output_opc

; 577  :                 //__debugbreak();
; 578  :                 if ((CodeInfo->token >= T_VPSLLW) && (CodeInfo->token <= T_VPSRLQ) ||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2044		; 000007fcH
	jl	SHORT $LN188@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2051		; 00000803H
	jle	SHORT $LN187@output_opc
$LN188@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1534		; 000005feH
	jl	$LN186@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1551		; 0000060fH
	jg	$LN186@output_opc
$LN187@output_opc:

; 579  :                   (CodeInfo->token >= T_VPSLLVD) && (CodeInfo->token <= T_VPSRLVW)) {
; 580  :                   c = CodeInfo->reg1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	mov	BYTE PTR c$[rsp], al

; 581  :                   lbyte &= 0x0f;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	and	eax, 15
	mov	BYTE PTR lbyte$1[rsp], al

; 582  :                   c = (c << 3);

	movzx	eax, BYTE PTR c$[rsp]
	shl	eax, 3
	mov	BYTE PTR c$[rsp], al

; 583  :                   c = ~c;

	movzx	eax, BYTE PTR c$[rsp]
	not	eax
	mov	BYTE PTR c$[rsp], al

; 584  :                   c &= EVEX_P1VVVV;

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 120				; 00000078H
	mov	BYTE PTR c$[rsp], al

; 585  :                   lbyte |= c;

	movzx	eax, BYTE PTR c$[rsp]
	movzx	ecx, BYTE PTR lbyte$1[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR lbyte$1[rsp], al

; 586  :                   lbyte |= 4;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 4
	mov	BYTE PTR lbyte$1[rsp], al

; 587  :                   if (ins->byte1_info == F_660F) lbyte |= 0x1;

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 18
	jne	SHORT $LN189@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 1
	mov	BYTE PTR lbyte$1[rsp], al
$LN189@output_opc:

; 588  :                   CodeInfo->tuple = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 1
$LN186@output_opc:

; 589  :                 }
; 590  :               }

	jmp	SHORT $LN185@output_opc
$LN184@output_opc:

; 591  :             else
; 592  :             lbyte |= ( ( CodeInfo->prefix.rex & REX_W ) ? 0x80 : 0 );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN554@output_opc
	mov	DWORD PTR tv1050[rsp], 128		; 00000080H
	jmp	SHORT $LN555@output_opc
$LN554@output_opc:
	mov	DWORD PTR tv1050[rsp], 0
$LN555@output_opc:
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, DWORD PTR tv1050[rsp]
	mov	BYTE PTR lbyte$1[rsp], al
$LN185@output_opc:

; 593  :             /* KSHIFTLW KSHIFTLQ KSHIFTRW KSHIFTRQ */
; 594  :             if ((CodeInfo->token == T_KSHIFTLW) || (CodeInfo->token == T_KSHIFTLQ)||
; 595  :               (CodeInfo->token == T_KSHIFTRW) || (CodeInfo->token == T_KSHIFTRQ)){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1723		; 000006bbH
	je	SHORT $LN191@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1725		; 000006bdH
	je	SHORT $LN191@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1727		; 000006bfH
	je	SHORT $LN191@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1729		; 000006c1H
	jne	SHORT $LN190@output_opc
$LN191@output_opc:

; 596  :               lbyte |= 0x80;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	bts	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN190@output_opc:

; 597  :             }
; 598  :             //HJWasm13.1 VPGATHERDD, VPGATHERQD, VPGATHERDQ, VPGATHERQQ
; 599  :             if (CodeInfo->token >= T_VPGATHERDD && CodeInfo->token <= T_VGATHERQPS){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1345		; 00000541H
	jl	$LN192@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1352		; 00000548H
	jg	$LN192@output_opc

; 600  :               if ((CodeInfo->opnd[OPND3].type != CodeInfo->opnd[OPND1].type)&& 

	mov	eax, 24
	imul	rax, rax, 2
	mov	ecx, 24
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	r8, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR [r8+rcx+32]
	cmp	DWORD PTR [rdx+rax+32], ecx
	je	SHORT $LN193@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	jne	SHORT $LN193@output_opc

; 601  :                 (CodeInfo->evex_flag == 0))
; 602  :                 EmitError( INVALID_USE_OF_REGISTER );

	mov	ecx, 170				; 000000aaH
	call	EmitError
$LN193@output_opc:

; 603  :               CodeInfo->tuple = TRUE;       

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 1

; 604  :               lbyte &= ~EVEX_P1VVVV;      // clear EVEX_P1VVVV

	movzx	eax, BYTE PTR lbyte$1[rsp]
	and	eax, -121				; ffffffffffffff87H
	mov	BYTE PTR lbyte$1[rsp], al

; 605  :               if (CodeInfo->evex_flag){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	je	SHORT $LN194@output_opc

; 606  :                 c = EVEX_P1VVVV;          // set all to ones : VVVV = 1111, we are not using it

	mov	BYTE PTR c$[rsp], 120			; 00000078H

; 607  :               }

	jmp	SHORT $LN195@output_opc
$LN194@output_opc:

; 608  :               else {
; 609  :                 c = CodeInfo->reg3 + 1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+111]
	inc	eax
	mov	BYTE PTR c$[rsp], al

; 610  :                 c = ((16 - c) << 3);

	movzx	eax, BYTE PTR c$[rsp]
	mov	ecx, 16
	sub	ecx, eax
	mov	eax, ecx
	shl	eax, 3
	mov	BYTE PTR c$[rsp], al
$LN195@output_opc:

; 611  :                 //c = ~c;
; 612  :               }
; 613  :               c &= EVEX_P1VVVV;

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 120				; 00000078H
	mov	BYTE PTR c$[rsp], al

; 614  :               lbyte |= c;  

	movzx	eax, BYTE PTR c$[rsp]
	movzx	ecx, BYTE PTR lbyte$1[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR lbyte$1[rsp], al

; 615  :               if (CodeInfo->indextype == OP_YMM)    lbyte |= 4;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+132], 128		; 00000080H
	jne	SHORT $LN196@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 4
	mov	BYTE PTR lbyte$1[rsp], al
$LN196@output_opc:

; 616  :               if (( CodeInfo->prefix.rex & REX_W )) lbyte |= 8;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN197@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 8
	mov	BYTE PTR lbyte$1[rsp], al
$LN197@output_opc:
$LN192@output_opc:

; 617  :             }
; 618  :             if ((CodeInfo->token >= T_KADDB) && (CodeInfo->token <= T_KUNPCKDQ)) {       //here pay atention

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1687		; 00000697H
	jl	$LN198@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1713		; 000006b1H
	jg	SHORT $LN198@output_opc

; 619  :               /* third byte W vvvv Lpp   */
; 620  :               c = CodeInfo->reg2;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	mov	BYTE PTR c$[rsp], al

; 621  :               lbyte &= 0xc0;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	and	eax, 192				; 000000c0H
	mov	BYTE PTR lbyte$1[rsp], al

; 622  :               c = (c << 3);

	movzx	eax, BYTE PTR c$[rsp]
	shl	eax, 3
	mov	BYTE PTR c$[rsp], al

; 623  :               c = ~c;

	movzx	eax, BYTE PTR c$[rsp]
	not	eax
	mov	BYTE PTR c$[rsp], al

; 624  :               c &= EVEX_P1VVVV;

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 120				; 00000078H
	mov	BYTE PTR c$[rsp], al

; 625  :               lbyte |= c;

	movzx	eax, BYTE PTR c$[rsp]
	movzx	ecx, BYTE PTR lbyte$1[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR lbyte$1[rsp], al

; 626  :               lbyte |= 4;    

	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 4
	mov	BYTE PTR lbyte$1[rsp], al

; 627  :                if (ins->byte1_info == F_660F) lbyte |= 0x1;

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 18
	jne	SHORT $LN200@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 1
	mov	BYTE PTR lbyte$1[rsp], al
$LN200@output_opc:

; 628  :             }

	jmp	$LN199@output_opc
$LN198@output_opc:

; 629  :             else if ((CodeInfo->token >= T_KNOTB) && (CodeInfo->token <= T_KORTESTQ)) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1714		; 000006b2H
	jl	SHORT $LN201@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1721		; 000006b9H
	jg	SHORT $LN201@output_opc

; 630  :               /*  1 1111 0pp */
; 631  :               /*  R vvvv Lpp */
; 632  :               lbyte = 0xF8;

	mov	BYTE PTR lbyte$1[rsp], 248		; 000000f8H

; 633  :               if (ins->byte1_info == F_660F) lbyte |= 0x01;

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 18
	jne	SHORT $LN203@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 1
	mov	BYTE PTR lbyte$1[rsp], al
$LN203@output_opc:

; 634  :             }

	jmp	SHORT $LN202@output_opc
$LN201@output_opc:

; 635  :             else if ((CodeInfo->token >= T_KMOVB) && (CodeInfo->token <= T_KMOVW)) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1730		; 000006c2H
	jl	SHORT $LN204@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1733		; 000006c5H
	jg	SHORT $LN204@output_opc

; 636  :               /*  1 1111 0pp */
; 637  :               /*  R vvvv Lpp */
; 638  :               lbyte = 0xF8;

	mov	BYTE PTR lbyte$1[rsp], 248		; 000000f8H

; 639  :               if (ins->byte1_info == F_660F) lbyte |= 0x01;

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 18
	jne	SHORT $LN205@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 1
	mov	BYTE PTR lbyte$1[rsp], al
	jmp	SHORT $LN206@output_opc
$LN205@output_opc:

; 640  :               else  lbyte |= 0x3;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 3
	mov	BYTE PTR lbyte$1[rsp], al
$LN206@output_opc:
$LN204@output_opc:
$LN202@output_opc:
$LN199@output_opc:

; 641  :             }
; 642  :             if (CodeInfo->token < T_VCVTDQ2PD && CodeInfo->token > T_VCVTTSS2SI){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1904		; 00000770H
	jge	SHORT $LN207@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1915		; 0000077bH
	jle	SHORT $LN207@output_opc

; 643  :               if (CodeInfo->reg2 > 15)lbyte |= EVEX_P1WMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 15
	jle	SHORT $LN208@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	bts	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN208@output_opc:
$LN207@output_opc:

; 644  :             }
; 645  :             if (CodeInfo->token == T_VPSCATTERDQ || CodeInfo->token == T_VPSCATTERQQ ||
; 646  :               CodeInfo->token == T_VSCATTERDPD || CodeInfo->token == T_VSCATTERQPD){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1354		; 0000054aH
	je	SHORT $LN210@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1356		; 0000054cH
	je	SHORT $LN210@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1358		; 0000054eH
	je	SHORT $LN210@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1360		; 00000550H
	jne	SHORT $LN209@output_opc
$LN210@output_opc:

; 647  :               lbyte |= 0x80;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	bts	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN209@output_opc:

; 648  :             }
; 649  :             /* if broadflags are prezent W = 0  in WVVVV1PP */
; 650  :               if (CodeInfo->token == T_VPGATHERDQ || CodeInfo->token == T_VPGATHERQQ ||
; 651  :                 CodeInfo->token == T_VGATHERDPD || CodeInfo->token == T_VGATHERQPD){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1347		; 00000543H
	je	SHORT $LN212@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1348		; 00000544H
	je	SHORT $LN212@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1349		; 00000545H
	je	SHORT $LN212@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1350		; 00000546H
	jne	SHORT $LN211@output_opc
$LN212@output_opc:

; 652  :                   lbyte |= 0x80;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	bts	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN211@output_opc:

; 653  :                 }
; 654  :             if (CodeInfo->token == T_VGATHERDPS)lbyte &= ~0x80;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1351		; 00000547H
	jne	SHORT $LN213@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	btr	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN213@output_opc:

; 655  :             if (((CodeInfo->token <= T_VCOMPRESSPS))||((CodeInfo->token >= T_VCVTDQ2PD) &&
; 656  :               (CodeInfo->token <= T_VCVTTSS2SI))|| (CodeInfo->token == T_VCVTPD2DQ)) 

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1443		; 000005a3H
	jle	SHORT $LN215@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1904		; 00000770H
	jl	SHORT $LN216@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1915		; 0000077bH
	jle	SHORT $LN215@output_opc
$LN216@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1339		; 0000053bH
	jne	SHORT $LN214@output_opc
$LN215@output_opc:

; 657  :               CodeInfo->evex_p2 &= ~EVEX_P1PPMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -4
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN214@output_opc:

; 658  :             if ((CodeInfo->token == T_VPCMPB) || (CodeInfo->token == T_VPCMPUB ))lbyte &= ~EVEX_P1WMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1457		; 000005b1H
	je	SHORT $LN218@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1458		; 000005b2H
	jne	SHORT $LN217@output_opc
$LN218@output_opc:
	movzx	eax, BYTE PTR lbyte$1[rsp]
	btr	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN217@output_opc:

; 659  :             if (CodeInfo->evex_flag){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	je	$LN219@output_opc

; 660  :               if ((CodeInfo->opnd[OPND2].type == OP_M64) || (CodeInfo->opnd[OPND1].type == OP_M64))

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 67108864	; 04000000H
	je	SHORT $LN221@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 67108864	; 04000000H
	jne	SHORT $LN220@output_opc
$LN221@output_opc:

; 661  :                 lbyte |= EVEX_P1WMASK;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	bts	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN220@output_opc:

; 662  :                if ((CodeInfo->opnd[OPND2].type == OP_R32) || (CodeInfo->opnd[OPND2].type == OP_EAX) ||
; 663  :                  (CodeInfo->opnd[OPND1].type == OP_R32) || (CodeInfo->opnd[OPND1].type == OP_EAX)){

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 4
	je	SHORT $LN223@output_opc
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 516		; 00000204H
	je	SHORT $LN223@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 4
	je	SHORT $LN223@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 516		; 00000204H
	jne	SHORT $LN222@output_opc
$LN223@output_opc:

; 664  :                  lbyte &= ~EVEX_P1WMASK;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	btr	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN222@output_opc:
$LN219@output_opc:

; 665  :                }
; 666  :              }
; 667  :             if ((CodeInfo->token == T_VMOVHPS)||(CodeInfo->token == T_VMOVLPS)||
; 668  :               (CodeInfo->token == T_VPMOVQB)||(CodeInfo->token == T_VPMOVSQB)||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1941		; 00000795H
	je	SHORT $LN225@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1943		; 00000797H
	je	SHORT $LN225@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1576		; 00000628H
	je	SHORT $LN225@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1577		; 00000629H
	je	SHORT $LN225@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1578		; 0000062aH
	jne	SHORT $LN224@output_opc
$LN225@output_opc:

; 669  :               (CodeInfo->token == T_VPMOVUSQB)){  
; 670  :                   lbyte &= ~EVEX_P1WMASK;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	btr	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN224@output_opc:

; 671  :             }
; 672  :              if ((CodeInfo->token == T_VPSLLQ)||(CodeInfo->token == T_VPSRLQ)||
; 673  :                (CodeInfo->token == T_VPSRAQ)|| (CodeInfo->token == T_VPROLQ)||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2046		; 000007feH
	je	SHORT $LN227@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2051		; 00000803H
	je	SHORT $LN227@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1545		; 00000609H
	je	SHORT $LN227@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1539		; 00000603H
	je	SHORT $LN227@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1543		; 00000607H
	jne	SHORT $LN226@output_opc
$LN227@output_opc:

; 674  :                (CodeInfo->token == T_VPRORQ))
; 675  :                lbyte |= EVEX_P1WMASK;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	bts	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN226@output_opc:

; 676  :              if ((CodeInfo->token >= T_BEXTR)&&(CodeInfo->token <= T_SHRX)||(CodeInfo->token == T_BZHI)){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1676		; 0000068cH
	jl	SHORT $LN230@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1679		; 0000068fH
	jle	SHORT $LN229@output_opc
$LN230@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1683		; 00000693H
	jne	$LN228@output_opc
$LN229@output_opc:

; 677  :               c = CodeInfo->reg3;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+111]
	mov	BYTE PTR c$[rsp], al

; 678  :               lbyte &= 0x80;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	and	eax, 128				; 00000080H
	mov	BYTE PTR lbyte$1[rsp], al

; 679  :               c = (c << 3);

	movzx	eax, BYTE PTR c$[rsp]
	shl	eax, 3
	mov	BYTE PTR c$[rsp], al

; 680  :               c = ~c;

	movzx	eax, BYTE PTR c$[rsp]
	not	eax
	mov	BYTE PTR c$[rsp], al

; 681  :               c &= EVEX_P1VVVV;

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 120				; 00000078H
	mov	BYTE PTR c$[rsp], al

; 682  :               lbyte |= c;

	movzx	eax, BYTE PTR c$[rsp]
	movzx	ecx, BYTE PTR lbyte$1[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR lbyte$1[rsp], al

; 683  : #if AMD64_SUPPORT
; 684  :               lbyte |=0x80;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	bts	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al

; 685  : #endif
; 686  :                if (ins->byte1_info == F_660F) lbyte |= 0x1;

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 18
	jne	SHORT $LN231@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 1
	mov	BYTE PTR lbyte$1[rsp], al
	jmp	SHORT $LN232@output_opc
$LN231@output_opc:

; 687  :                else if (ins->byte1_info == F_F30F38) lbyte |= 0x02;//SARX

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 28
	jne	SHORT $LN233@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 2
	mov	BYTE PTR lbyte$1[rsp], al
	jmp	SHORT $LN234@output_opc
$LN233@output_opc:

; 688  :                else if (ins->byte1_info == F_660F38) lbyte |= 0x01;//SHLX

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 25
	jne	SHORT $LN235@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 1
	mov	BYTE PTR lbyte$1[rsp], al
	jmp	SHORT $LN236@output_opc
$LN235@output_opc:

; 689  :                else if (ins->byte1_info == F_F20F38) lbyte |= 0x03;//SHRX

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 27
	jne	SHORT $LN237@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 3
	mov	BYTE PTR lbyte$1[rsp], al
$LN237@output_opc:
$LN236@output_opc:
$LN234@output_opc:
$LN232@output_opc:
$LN228@output_opc:

; 690  :              }
; 691  :              if ((CodeInfo->token == T_BLSMSK)||(CodeInfo->token == T_BLSI)||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1681		; 00000691H
	je	SHORT $LN239@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1680		; 00000690H
	je	SHORT $LN239@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1682		; 00000692H
	jne	$LN238@output_opc
$LN239@output_opc:

; 692  :                (CodeInfo->token == T_BLSR)){
; 693  :               c = CodeInfo->reg1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	mov	BYTE PTR c$[rsp], al

; 694  :               lbyte &= 0x80;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	and	eax, 128				; 00000080H
	mov	BYTE PTR lbyte$1[rsp], al

; 695  :               c = (c << 3);

	movzx	eax, BYTE PTR c$[rsp]
	shl	eax, 3
	mov	BYTE PTR c$[rsp], al

; 696  :               c = ~c;

	movzx	eax, BYTE PTR c$[rsp]
	not	eax
	mov	BYTE PTR c$[rsp], al

; 697  :               c &= EVEX_P1VVVV;

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 120				; 00000078H
	mov	BYTE PTR c$[rsp], al

; 698  :               lbyte |= c;

	movzx	eax, BYTE PTR c$[rsp]
	movzx	ecx, BYTE PTR lbyte$1[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR lbyte$1[rsp], al

; 699  :                if (ins->byte1_info == F_660F) lbyte |= 0x1;

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 18
	jne	SHORT $LN240@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 1
	mov	BYTE PTR lbyte$1[rsp], al
	jmp	SHORT $LN241@output_opc
$LN240@output_opc:

; 700  :                else if (ins->byte1_info == F_F20F38) lbyte |= 0x3;

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 27
	jne	SHORT $LN242@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 3
	mov	BYTE PTR lbyte$1[rsp], al
$LN242@output_opc:
$LN241@output_opc:
$LN238@output_opc:

; 701  :              }
; 702  :              if ((CodeInfo->token == T_PDEP)||(CodeInfo->token == T_PEXT)){ 

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1684		; 00000694H
	je	SHORT $LN244@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1685		; 00000695H
	jne	$LN243@output_opc
$LN244@output_opc:

; 703  :               c = CodeInfo->reg2;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	mov	BYTE PTR c$[rsp], al

; 704  :               lbyte &= 0x80;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	and	eax, 128				; 00000080H
	mov	BYTE PTR lbyte$1[rsp], al

; 705  :               c = (c << 3);

	movzx	eax, BYTE PTR c$[rsp]
	shl	eax, 3
	mov	BYTE PTR c$[rsp], al

; 706  :               c = ~c;

	movzx	eax, BYTE PTR c$[rsp]
	not	eax
	mov	BYTE PTR c$[rsp], al

; 707  :               c &= EVEX_P1VVVV;

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 120				; 00000078H
	mov	BYTE PTR c$[rsp], al

; 708  :               lbyte |= c;

	movzx	eax, BYTE PTR c$[rsp]
	movzx	ecx, BYTE PTR lbyte$1[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR lbyte$1[rsp], al

; 709  :                if (ins->byte1_info == F_F20F38) lbyte |= 0x3;

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 27
	jne	SHORT $LN245@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 3
	mov	BYTE PTR lbyte$1[rsp], al
	jmp	SHORT $LN246@output_opc
$LN245@output_opc:

; 710  :                else if (ins->byte1_info == F_F30F38)

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 28
	jne	SHORT $LN247@output_opc

; 711  :                  lbyte |= 0x2;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 2
	mov	BYTE PTR lbyte$1[rsp], al
$LN247@output_opc:
$LN246@output_opc:
$LN243@output_opc:

; 712  :              }
; 713  :             if (CodeInfo->token == T_RORX)lbyte |= 0x3;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1686		; 00000696H
	jne	SHORT $LN248@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 3
	mov	BYTE PTR lbyte$1[rsp], al
$LN248@output_opc:

; 714  :             if (CodeInfo->token == T_VEXTRACTF128){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1316		; 00000524H
	jne	SHORT $LN249@output_opc

; 715  :               if (CodeInfo->r2type == OP_YMM)

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+120], 128		; 00000080H
	jne	SHORT $LN250@output_opc

; 716  :                 lbyte |= 0x04;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 4
	mov	BYTE PTR lbyte$1[rsp], al
$LN250@output_opc:
$LN249@output_opc:

; 717  :             }
; 718  :             CodeInfo->evex_p1 = lbyte;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR lbyte$1[rsp]
	mov	BYTE PTR [rax+138], cl

; 719  :             OutputCodeByte( lbyte );

	movzx	ecx, BYTE PTR lbyte$1[rsp]
	call	OutputByte

; 720  :             if (CodeInfo->evex_flag  ){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	je	$LN251@output_opc

; 721  :               CodeInfo->evex_p2 |= decoflags;

	movzx	eax, BYTE PTR decoflags
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+139]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 722  :             if ((CodeInfo->opnd[OPND1].type  & OP_ZMM)|| (CodeInfo->r2type & OP_ZMM))

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 256				; 00000100H
	test	eax, eax
	jne	SHORT $LN254@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+120]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN252@output_opc
$LN254@output_opc:

; 723  :               CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
	jmp	SHORT $LN253@output_opc
$LN252@output_opc:

; 724  :             else if ((CodeInfo->opnd[OPND1].type & OP_YMM) || (CodeInfo->r2type & OP_YMM)) 

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN256@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+120]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN255@output_opc
$LN256@output_opc:

; 725  :               CodeInfo->evex_p2 |= EVEX_P2LMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 32					; 00000020H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN255@output_opc:
$LN253@output_opc:

; 726  :               /* here is Static Rounding Mode inserted */
; 727  :             if (CodeInfo->evex_sae){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+141]
	test	eax, eax
	je	SHORT $LN257@output_opc

; 728  :                 CodeInfo->evex_p2 &= ~0x70;     //clear bites 6,5,4

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -113				; ffffffffffffff8fH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 729  :                 c = CodeInfo->evex_sae - 0x10;  //subtract SAE to get a proper decorator

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+141]
	sub	eax, 16
	mov	BYTE PTR c$[rsp], al

; 730  :                 /* here we need to test for corect use of decorators  
; 731  :                  * if it is {sae} c will be zero, in that case we need to add 0x10 to c
; 732  :                  * if we need {sae}
; 733  :                 */   
; 734  :                 if (c == 0) c += 0x10;

	movzx	eax, BYTE PTR c$[rsp]
	test	eax, eax
	jne	SHORT $LN258@output_opc
	movzx	eax, BYTE PTR c$[rsp]
	add	eax, 16
	mov	BYTE PTR c$[rsp], al
$LN258@output_opc:

; 735  :                 CodeInfo->evex_p2 |= c;

	movzx	eax, BYTE PTR c$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+139]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN257@output_opc:

; 736  :               }
; 737  :               if (broadflags >= 0x10 && broadflags <= 0x47) CodeInfo->evex_p2 |= 0x10;

	movzx	eax, BYTE PTR broadflags
	cmp	eax, 16
	jl	SHORT $LN259@output_opc
	movzx	eax, BYTE PTR broadflags
	cmp	eax, 71					; 00000047H
	jg	SHORT $LN259@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 16
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN259@output_opc:

; 738  :                 if ((CodeInfo->token >= T_VCVTDQ2PD && CodeInfo->token <= T_VCVTTSS2SI)||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1904		; 00000770H
	jl	SHORT $LN262@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1915		; 0000077bH
	jle	SHORT $LN261@output_opc
$LN262@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1911		; 00000777H
	jne	$LN260@output_opc
$LN261@output_opc:

; 739  :                 (CodeInfo->token == T_VCVTSD2SS)){
; 740  :                   if (!CodeInfo->evex_sae)

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+141]
	test	eax, eax
	jne	SHORT $LN263@output_opc

; 741  :                   CodeInfo->evex_p2 &= ~0x60;   //clear bits 6 and 5

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -97				; ffffffffffffff9fH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN263@output_opc:

; 742  :                   if (CodeInfo->opnd[OPND1].type & OP_XMM){

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN264@output_opc

; 743  :                     if (CodeInfo->r2type & (OP_XMM | OP_M64 | OP_M))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+120]
	and	eax, -1887436768			; 8f800020H
	test	eax, eax
	je	SHORT $LN266@output_opc

; 744  :                       ;

	jmp	SHORT $LN267@output_opc
$LN266@output_opc:

; 745  :                     else EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN267@output_opc:

; 746  :                   }

	jmp	$LN265@output_opc
$LN264@output_opc:

; 747  :                   else if (CodeInfo->opnd[OPND1].type & OP_YMM){

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN268@output_opc

; 748  :                     if (CodeInfo->r2type & (OP_XMM | OP_M128 | OP_M))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+120]
	and	eax, -1887436768			; 8f800020H
	test	eax, eax
	je	SHORT $LN270@output_opc

; 749  :                       CodeInfo->evex_p2 |= EVEX_P2LMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 32					; 00000020H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
	jmp	SHORT $LN271@output_opc
$LN270@output_opc:

; 750  :                     else EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN271@output_opc:

; 751  :                   }

	jmp	SHORT $LN269@output_opc
$LN268@output_opc:

; 752  :                   else if (CodeInfo->opnd[OPND1].type & OP_ZMM){

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN272@output_opc

; 753  :                     if (CodeInfo->r2type & OP_YMM | OP_M256 | OP_M)

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+120]
	and	eax, 128				; 00000080H
	bts	eax, 28
	or	eax, -1887436800			; 8f800000H
	test	eax, eax
	je	SHORT $LN273@output_opc

; 754  :                       CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
	jmp	SHORT $LN274@output_opc
$LN273@output_opc:

; 755  :                     else EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN274@output_opc:
$LN272@output_opc:
$LN269@output_opc:
$LN265@output_opc:
$LN260@output_opc:

; 756  :                   }
; 757  :                 }
; 758  :                 if (CodeInfo->token >= T_VPGATHERDD && CodeInfo->token <= T_VGATHERQPS){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1345		; 00000541H
	jl	SHORT $LN275@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1352		; 00000548H
	jg	SHORT $LN275@output_opc

; 759  :                   CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 760  :                   CodeInfo->tuple = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 1
$LN275@output_opc:

; 761  :                 }
; 762  :                 if (CodeInfo->token >= T_VPSCATTERDD && CodeInfo->token <= T_VSCATTERQPD){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1353		; 00000549H
	jl	SHORT $LN276@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1360		; 00000550H
	jg	SHORT $LN276@output_opc

; 763  :                   CodeInfo->evex_p2 &= ~EVEX_P2LMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -33				; ffffffffffffffdfH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 764  :                   CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 765  :                 CodeInfo->tuple = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 1
$LN276@output_opc:

; 766  :                 }
; 767  :                 if ((CodeInfo->token == T_VEXTRACTPS)||(CodeInfo->token == T_VCVTSD2USI)||
; 768  :                   (CodeInfo->token == T_VCVTSS2USI)||(CodeInfo->token == T_VCVTTSD2USI))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1922		; 00000782H
	je	SHORT $LN278@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1603		; 00000643H
	je	SHORT $LN278@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1604		; 00000644H
	je	SHORT $LN278@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1623		; 00000657H
	jne	SHORT $LN277@output_opc
$LN278@output_opc:

; 769  :                   CodeInfo->evex_p2 &= ~EVEX_P2L1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -65				; ffffffffffffffbfH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN277@output_opc:

; 770  :                   if ((CodeInfo->token == T_VEXTRACTF32x4) || (CodeInfo->token == T_VEXTRACTF64x2)||
; 771  :                     (CodeInfo->token == T_VEXTRACTF64x4)|| (CodeInfo->token == T_VEXTRACTF32x8)||
; 772  :                     (CodeInfo->token == T_VEXTRACTI32x4)||(CodeInfo->token == T_VEXTRACTI64x4)||
; 773  :                     (CodeInfo->token == T_VEXTRACTI64x2)|| (CodeInfo->token == T_VEXTRACTI32x8)||
; 774  :                   (CodeInfo->token == T_VEXTRACTPS)|| (CodeInfo->token == T_VEXTRACTPS)){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1317		; 00000525H
	je	$LN280@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1318		; 00000526H
	je	$LN280@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1320		; 00000528H
	je	SHORT $LN280@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1319		; 00000527H
	je	SHORT $LN280@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1322		; 0000052aH
	je	SHORT $LN280@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1325		; 0000052dH
	je	SHORT $LN280@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1323		; 0000052bH
	je	SHORT $LN280@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1324		; 0000052cH
	je	SHORT $LN280@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1922		; 00000782H
	je	SHORT $LN280@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1922		; 00000782H
	jne	SHORT $LN279@output_opc
$LN280@output_opc:

; 775  :                     CodeInfo->evex_p2 &= ~EVEX_P2BMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -17
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 776  :                     CodeInfo->evex_p2 &= ~EVEX_P2LMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -33				; ffffffffffffffdfH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN279@output_opc:

; 777  :                   }
; 778  :                 if (CodeInfo->evex_flag){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	je	$LN281@output_opc

; 779  :                   if (CodeInfo->vexregop){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	test	eax, eax
	je	SHORT $LN282@output_opc

; 780  :                     if (CodeInfo->reg2 <= 15) CodeInfo->evex_p2 |= EVEX_P2VMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 15
	jg	SHORT $LN284@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 8
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
	jmp	SHORT $LN285@output_opc
$LN284@output_opc:

; 781  :                     else CodeInfo->evex_p2 &= ~EVEX_P2VMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -9
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN285@output_opc:

; 782  :                   }

	jmp	SHORT $LN283@output_opc
$LN282@output_opc:

; 783  :                   else CodeInfo->evex_p2 |= EVEX_P2VMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 8
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN283@output_opc:

; 784  :               if ((CodeInfo->token == T_VRNDSCALEPD) || (CodeInfo->token == T_VRNDSCALEPS)||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1615		; 0000064fH
	je	SHORT $LN287@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1616		; 00000650H
	je	SHORT $LN287@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1433		; 00000599H
	jne	SHORT $LN286@output_opc
$LN287@output_opc:

; 785  :                    (CodeInfo->token ==  T_VCVTPS2PH))
; 786  :                     CodeInfo->evex_p2 |= EVEX_P2VMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 8
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN286@output_opc:

; 787  :                 CodeInfo->evex_p2 |= decoflags;

	movzx	eax, BYTE PTR decoflags
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+139]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 788  :               if (CodeInfo->token == T_VCVTDQ2PD)

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1904		; 00000770H
	jne	SHORT $LN288@output_opc

; 789  :                 CodeInfo->evex_p2 &= ~EVEX_P2L1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -65				; ffffffffffffffbfH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN288@output_opc:

; 790  :               if ((CodeInfo->token >= T_VPSLLW) && (CodeInfo->token <= T_VPSRLQ) ||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2044		; 000007fcH
	jl	SHORT $LN291@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2051		; 00000803H
	jle	SHORT $LN290@output_opc
$LN291@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1534		; 000005feH
	jl	SHORT $LN289@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1551		; 0000060fH
	jg	SHORT $LN289@output_opc
$LN290@output_opc:

; 791  :                 (CodeInfo->token >= T_VPSLLVD) && (CodeInfo->token <= T_VPSRLVW)) 
; 792  :                 CodeInfo->evex_p2 &= ~EVEX_P2VMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -9
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN289@output_opc:

; 793  :                 OutputCodeByte(CodeInfo->evex_p2);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rax+139]
	call	OutputByte
$LN281@output_opc:
$LN251@output_opc:

; 794  :                 }
; 795  :             }
; 796  :         } else {

	jmp	$LN87@output_opc
$LN86@output_opc:

; 797  :             lbyte |= ( ( CodeInfo->prefix.rex & REX_R ) ? 0 : EVEX_P1WMASK );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN556@output_opc
	mov	DWORD PTR tv1683[rsp], 0
	jmp	SHORT $LN557@output_opc
$LN556@output_opc:
	mov	DWORD PTR tv1683[rsp], 128		; 00000080H
$LN557@output_opc:
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, DWORD PTR tv1683[rsp]
	mov	BYTE PTR lbyte$1[rsp], al

; 798  :             /* first byte is 0xC5  in 2 byte version  */
; 799  :             if (CodeInfo->evex_flag) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	je	$LN292@output_opc

; 800  :               OutputCodeByte(0x62);

	mov	cl, 98					; 00000062H
	call	OutputByte

; 801  :               if ((CodeInfo->opnd[OPND1].type & OP_M_ANY)|| (CodeInfo->opnd[OPND2].type & OP_M_ANY)||

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, -8388608				; ffffffffff800000H
	test	eax, eax
	jne	SHORT $LN295@output_opc
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, -8388608				; ffffffffff800000H
	test	eax, eax
	jne	SHORT $LN295@output_opc
	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, -8388608				; ffffffffff800000H
	test	eax, eax
	je	SHORT $LN294@output_opc
$LN295@output_opc:

; 802  :                 (CodeInfo->opnd[OPND3].type & OP_M_ANY)) CodeInfo->tuple = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 1
$LN294@output_opc:

; 803  :               lbyte &= ~EVEX_P1WMASK;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	btr	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al

; 804  :               lbyte |=  ((CodeInfo->pinstr->prefix)>>8 & EVEX_P1WMASK);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+8]
	sar	eax, 8
	and	eax, 128				; 00000080H
	movzx	ecx, BYTE PTR lbyte$1[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR lbyte$1[rsp], al

; 805  :               if ((CodeInfo->opnd[OPND2].type == OP_M64)||(CodeInfo->opnd[OPND1].type == OP_M64)) 

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 67108864	; 04000000H
	je	SHORT $LN297@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 67108864	; 04000000H
	jne	SHORT $LN296@output_opc
$LN297@output_opc:

; 806  :                 lbyte |= EVEX_P1WMASK;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	bts	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN296@output_opc:

; 807  :               if ((CodeInfo->opnd[OPND2].type == OP_R32) || (CodeInfo->opnd[OPND2].type == OP_EAX)||
; 808  :                 (CodeInfo->opnd[OPND1].type == OP_R32) || (CodeInfo->opnd[OPND1].type == OP_EAX)){

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 4
	je	SHORT $LN299@output_opc
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 516		; 00000204H
	je	SHORT $LN299@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 4
	je	SHORT $LN299@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 516		; 00000204H
	jne	SHORT $LN298@output_opc
$LN299@output_opc:

; 809  :                 lbyte &= ~EVEX_P1WMASK;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	btr	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN298@output_opc:

; 810  :               }
; 811  :               switch ( ins->byte1_info ) {                     

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR tv1759[rsp], al
	cmp	BYTE PTR tv1759[rsp], 23
	je	SHORT $LN300@output_opc
	cmp	BYTE PTR tv1759[rsp], 24
	je	SHORT $LN301@output_opc
	cmp	BYTE PTR tv1759[rsp], 25
	je	SHORT $LN300@output_opc
	cmp	BYTE PTR tv1759[rsp], 26
	je	SHORT $LN301@output_opc
	cmp	BYTE PTR tv1759[rsp], 27
	je	SHORT $LN300@output_opc
	jmp	SHORT $LN302@output_opc
$LN300@output_opc:

; 812  :               case F_0F38:                                     
; 813  :               case F_660F38:                                   
; 814  :               case F_F20F38:                                   
; 815  :                   CodeInfo->evex_p0 |= 0x02;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	or	eax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al

; 816  :                   break;

	jmp	SHORT $LN10@output_opc
$LN301@output_opc:

; 817  :               case F_0F3A:
; 818  :               case F_660F3A:
; 819  :                   CodeInfo->evex_p0 |= 0x03;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	or	eax, 3
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al

; 820  :                   break;

	jmp	SHORT $LN10@output_opc
$LN302@output_opc:

; 821  :               default:
; 822  :                 if (ins->byte1_info >= F_0F){

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 16
	jl	SHORT $LN303@output_opc

; 823  :                   CodeInfo->evex_p0 |= 0x01;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	or	eax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
$LN303@output_opc:
$LN10@output_opc:

; 824  :                 }
; 825  :               }
; 826  :               CodeInfo->evex_p0 |= EVEX_P0XMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al

; 827  :               CodeInfo->evex_p0 |= EVEX_P0BMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	or	eax, 32					; 00000020H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al

; 828  :                if ((CodeInfo->token >= T_VMOVLHPS)&&(CodeInfo->token <= T_VMOVLPS)||         
; 829  :                  (CodeInfo->token == T_VMOVNTDQ)||                                           
; 830  :                (CodeInfo->token == T_VMOVUPD)||(CodeInfo->token == T_VMOVAPD)||              
; 831  :                (CodeInfo->token >= T_VMOVDQA32)&&(CodeInfo->token <= T_VMOVDQU64)||          
; 832  :                (CodeInfo->token == T_VMOVAPS)||(CodeInfo->token == T_VMOVUPS)){              

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1939		; 00000793H
	jl	SHORT $LN307@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1943		; 00000797H
	jle	SHORT $LN306@output_opc
$LN307@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1948		; 0000079cH
	je	SHORT $LN306@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1954		; 000007a2H
	je	SHORT $LN306@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1932		; 0000078cH
	je	SHORT $LN306@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1643		; 0000066bH
	jl	SHORT $LN308@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1646		; 0000066eH
	jle	SHORT $LN306@output_opc
$LN308@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1933		; 0000078dH
	je	SHORT $LN306@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1955		; 000007a3H
	jne	$LN304@output_opc
$LN306@output_opc:

; 833  :                 if ((CodeInfo->opnd[OPND1].type & OP_XMM)||(CodeInfo->opnd[OPND1].type & OP_YMM)||

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN311@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN311@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	$LN309@output_opc
$LN311@output_opc:

; 834  :                 (CodeInfo->opnd[OPND1].type & OP_ZMM)){
; 835  :                   if ((CodeInfo->reg1 <= 7) || (CodeInfo->reg1 >= 16 && CodeInfo->reg1 <= 23))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 7
	jle	SHORT $LN314@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 16
	jl	SHORT $LN312@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 23
	jg	SHORT $LN312@output_opc
$LN314@output_opc:

; 836  :                     CodeInfo->evex_p0 |= EVEX_P0RMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	bts	eax, 7
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
	jmp	SHORT $LN313@output_opc
$LN312@output_opc:

; 837  :                   else CodeInfo->evex_p0 &= ~EVEX_P0RMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	btr	eax, 7
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
$LN313@output_opc:

; 838  :                   if (CodeInfo->reg1 <= 15) CodeInfo->evex_p0 |= EVEX_P0R1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 15
	jg	SHORT $LN315@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	or	eax, 16
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
	jmp	SHORT $LN316@output_opc
$LN315@output_opc:

; 839  :                   else CodeInfo->evex_p0 &= ~EVEX_P0R1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	and	eax, -17
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
$LN316@output_opc:

; 840  :                   if (CodeInfo->opnd[OPND1].type & OP_YMM) CodeInfo->evex_p2 |= EVEX_P2LMASK;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN317@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 32					; 00000020H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN317@output_opc:

; 841  :                   if (CodeInfo->opnd[OPND1].type & OP_ZMM) CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN318@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN318@output_opc:

; 842  :                 }

	jmp	$LN310@output_opc
$LN309@output_opc:

; 843  :               else if ((CodeInfo->opnd[OPND2].type & OP_XMM)||(CodeInfo->opnd[OPND2].type & OP_YMM)||

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN320@output_opc
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN320@output_opc
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	$LN319@output_opc
$LN320@output_opc:

; 844  :                 (CodeInfo->opnd[OPND2].type & OP_ZMM)){
; 845  :                   if ((CodeInfo->reg2 <= 7) || (CodeInfo->reg2 >= 16 && CodeInfo->reg2 <= 23))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 7
	jle	SHORT $LN323@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 16
	jl	SHORT $LN321@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 23
	jg	SHORT $LN321@output_opc
$LN323@output_opc:

; 846  :                     CodeInfo->evex_p0 |= EVEX_P0RMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	bts	eax, 7
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
	jmp	SHORT $LN322@output_opc
$LN321@output_opc:

; 847  :                   else CodeInfo->evex_p0 &= ~EVEX_P0RMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	btr	eax, 7
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
$LN322@output_opc:

; 848  :                   if (CodeInfo->reg1 > 0x07)

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 7
	jle	SHORT $LN324@output_opc

; 849  :                     CodeInfo->evex_p0 &= ~EVEX_P0R1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	and	eax, -17
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
	jmp	SHORT $LN325@output_opc
$LN324@output_opc:

; 850  :                   else CodeInfo->evex_p0 &= ~EVEX_P0R1MASK;  

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	and	eax, -17
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
$LN325@output_opc:

; 851  :                   if (CodeInfo->opnd[OPND2].type & OP_YMM) CodeInfo->evex_p2 |= EVEX_P2LMASK;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN326@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 32					; 00000020H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN326@output_opc:

; 852  :                   if (CodeInfo->opnd[OPND2].type & OP_ZMM) CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN327@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN327@output_opc:
$LN319@output_opc:
$LN310@output_opc:

; 853  :                 } 
; 854  :               }

	jmp	$LN305@output_opc
$LN304@output_opc:

; 855  :               else{
; 856  :                 if (CodeInfo->reg1 <= 15) CodeInfo->evex_p0 |= EVEX_P0R1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 15
	jg	SHORT $LN328@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	or	eax, 16
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
	jmp	SHORT $LN329@output_opc
$LN328@output_opc:

; 857  :                 else CodeInfo->evex_p0 &= ~EVEX_P0R1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	and	eax, -17
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
$LN329@output_opc:

; 858  :                 if ((CodeInfo->reg1 <= 7) || (CodeInfo->reg1 >= 16 && CodeInfo->reg1 <= 23))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 7
	jle	SHORT $LN332@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 16
	jl	SHORT $LN330@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	cmp	eax, 23
	jg	SHORT $LN330@output_opc
$LN332@output_opc:

; 859  :                   CodeInfo->evex_p0 |= EVEX_P0RMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	bts	eax, 7
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
	jmp	SHORT $LN331@output_opc
$LN330@output_opc:

; 860  :                 else CodeInfo->evex_p0 &= ~EVEX_P0RMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	btr	eax, 7
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
$LN331@output_opc:
$LN305@output_opc:

; 861  :               }
; 862  :               if ((CodeInfo->token == T_VMOVNTPD)||(CodeInfo->token == T_VMOVNTPS)){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1950		; 0000079eH
	je	SHORT $LN334@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1951		; 0000079fH
	jne	$LN333@output_opc
$LN334@output_opc:

; 863  :                 if (CodeInfo->reg2 <= 15) CodeInfo->evex_p0 |= EVEX_P0R1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 15
	jg	SHORT $LN335@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	or	eax, 16
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
	jmp	SHORT $LN336@output_opc
$LN335@output_opc:

; 864  :                 else CodeInfo->evex_p0 &= ~EVEX_P0R1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	and	eax, -17
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
$LN336@output_opc:

; 865  :                 if ((CodeInfo->reg2 <= 7) || (CodeInfo->reg2 >= 16 && CodeInfo->reg2 <= 23))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 7
	jle	SHORT $LN339@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 16
	jl	SHORT $LN337@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 23
	jg	SHORT $LN337@output_opc
$LN339@output_opc:

; 866  :                   CodeInfo->evex_p0 |= EVEX_P0RMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	bts	eax, 7
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
	jmp	SHORT $LN338@output_opc
$LN337@output_opc:

; 867  :                 else CodeInfo->evex_p0 &= ~EVEX_P0RMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	btr	eax, 7
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+137], al
$LN338@output_opc:
$LN333@output_opc:

; 868  :               }
; 869  :               if ((CodeInfo->token >= T_VMOVLHPS)&&(CodeInfo->token <= T_VMOVLPS)){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1939		; 00000793H
	jl	$LN340@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1943		; 00000797H
	jg	SHORT $LN340@output_opc

; 870  :                 if ((CodeInfo->opnd[OPND1].type == OP_YMM)||(CodeInfo->opnd[OPND2].type == OP_YMM)||
; 871  :                 (CodeInfo->opnd[OPND1].type == OP_ZMM)||(CodeInfo->opnd[OPND2].type == OP_ZMM))

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 128		; 00000080H
	je	SHORT $LN342@output_opc
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 128		; 00000080H
	je	SHORT $LN342@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 256		; 00000100H
	je	SHORT $LN342@output_opc
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 256		; 00000100H
	jne	SHORT $LN341@output_opc
$LN342@output_opc:

; 872  :                 EmitError( INVALID_INSTRUCTION_OPERANDS );

	mov	ecx, 49					; 00000031H
	call	EmitError
$LN341@output_opc:
$LN340@output_opc:

; 873  :               }
; 874  :               OutputCodeByte( CodeInfo->evex_p0 );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rax+137]
	call	OutputByte

; 875  :             }

	jmp	SHORT $LN293@output_opc
$LN292@output_opc:

; 876  :             else{
; 877  :               OutputCodeByte(0xC5);

	mov	cl, 197					; 000000c5H
	call	OutputByte

; 878  :               if (CodeInfo->opnd[OPND1].type == OP_YMM || CodeInfo->opnd[OPND2].type == OP_YMM || CodeInfo->token == T_VZEROALL) /* VZEROALL is 256 bits VZEROUPPER is 128 bits */

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 128		; 00000080H
	je	SHORT $LN345@output_opc
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 128		; 00000080H
	je	SHORT $LN345@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1337		; 00000539H
	jne	SHORT $LN343@output_opc
$LN345@output_opc:

; 879  :                  lbyte |= 0x04;  /* set L: Vector Length */

	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 4
	mov	BYTE PTR lbyte$1[rsp], al
	jmp	SHORT $LN344@output_opc
$LN343@output_opc:

; 880  :               else
; 881  :                 lbyte &= ~0x04;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	and	eax, -5
	mov	BYTE PTR lbyte$1[rsp], al
$LN344@output_opc:

; 882  :               CodeInfo->tuple = 0;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 0
$LN293@output_opc:

; 883  :             }
; 884  :             /* second byte R vvvv Lpp   */
; 885  :             if ((CodeInfo->token == T_LZCNT) || (CodeInfo->token == T_TZCNT))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1276		; 000004fcH
	je	SHORT $LN347@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1277		; 000004fdH
	jne	SHORT $LN346@output_opc
$LN347@output_opc:

; 886  :                lbyte |= 0x80;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	bts	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN346@output_opc:

; 887  :             if (CodeInfo->token == T_VMASKMOVDQU) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1931		; 0000078bH
	jne	SHORT $LN348@output_opc

; 888  :               /*  1 1111 0pp */
; 889  :               /*  R vvvv Lpp */
; 890  :               lbyte |= 0xF8;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 248				; 000000f8H
	mov	BYTE PTR lbyte$1[rsp], al

; 891  :               if (ins->byte1_info == F_660F) lbyte |= 0x01;

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 18
	jne	SHORT $LN349@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 1
	mov	BYTE PTR lbyte$1[rsp], al
	jmp	SHORT $LN350@output_opc
$LN349@output_opc:

; 892  :               else if (ins->byte1_info == F_0F) lbyte |= 0x3;

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 16
	jne	SHORT $LN351@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 3
	mov	BYTE PTR lbyte$1[rsp], al
$LN351@output_opc:
$LN350@output_opc:
$LN348@output_opc:

; 893  :             }  //WVVVV1PP
; 894  :             /* if broadflags are prezent W = 0  in WVVVV1PP */
; 895  :               if (CodeInfo->token == T_VPGATHERDQ || CodeInfo->token == T_VPGATHERQQ ||
; 896  :                 CodeInfo->token == T_VGATHERDPD || CodeInfo->token == T_VGATHERQPD){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1347		; 00000543H
	je	SHORT $LN353@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1348		; 00000544H
	je	SHORT $LN353@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1349		; 00000545H
	je	SHORT $LN353@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1350		; 00000546H
	jne	SHORT $LN352@output_opc
$LN353@output_opc:

; 897  :                   lbyte |= 0x80;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	bts	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN352@output_opc:

; 898  :                 }
; 899  :               if (CodeInfo->token == T_VGATHERDPS)lbyte &= ~0x80;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1351		; 00000547H
	jne	SHORT $LN354@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	btr	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN354@output_opc:

; 900  :               if (CodeInfo->evex_flag){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	je	SHORT $LN355@output_opc

; 901  :                 if ((CodeInfo->opnd[OPND2].type == OP_R32) || (CodeInfo->opnd[OPND2].type == OP_EAX))

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 4
	je	SHORT $LN357@output_opc
	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 516		; 00000204H
	jne	SHORT $LN356@output_opc
$LN357@output_opc:

; 902  :                   lbyte &= ~EVEX_P1WMASK;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	btr	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN356@output_opc:
$LN355@output_opc:

; 903  :               }
; 904  :             if ((CodeInfo->token >= T_KADDB) && (CodeInfo->token <= T_KUNPCKDQ)) {       //here pay atention

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1687		; 00000697H
	jl	$LN358@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1713		; 000006b1H
	jg	$LN358@output_opc

; 905  :               c = CodeInfo->reg2;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	mov	BYTE PTR c$[rsp], al

; 906  :               lbyte &= 0x83;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	and	eax, 131				; 00000083H
	mov	BYTE PTR lbyte$1[rsp], al

; 907  :               c = (c << 3);

	movzx	eax, BYTE PTR c$[rsp]
	shl	eax, 3
	mov	BYTE PTR c$[rsp], al

; 908  :               c = ~c;

	movzx	eax, BYTE PTR c$[rsp]
	not	eax
	mov	BYTE PTR c$[rsp], al

; 909  :               c &= EVEX_P1VVVV;

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 120				; 00000078H
	mov	BYTE PTR c$[rsp], al

; 910  :               lbyte |= c;

	movzx	eax, BYTE PTR c$[rsp]
	movzx	ecx, BYTE PTR lbyte$1[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR lbyte$1[rsp], al

; 911  :               if (vex_flags[ CodeInfo->token - VEX_START ] & VX_L ) lbyte |= c;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 1296				; 00000510H
	cdqe
	lea	rcx, OFFSET FLAT:vex_flags
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN360@output_opc
	movzx	eax, BYTE PTR c$[rsp]
	movzx	ecx, BYTE PTR lbyte$1[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR lbyte$1[rsp], al
$LN360@output_opc:

; 912  :             }

	jmp	$LN359@output_opc
$LN358@output_opc:

; 913  :             else if ((CodeInfo->token >= T_KNOTB) && (CodeInfo->token <= T_KORTESTQ)) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1714		; 000006b2H
	jl	SHORT $LN361@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1721		; 000006b9H
	jg	SHORT $LN361@output_opc

; 914  :               /*  1 1111 0pp */
; 915  :               /*  R vvvv Lpp */
; 916  :               lbyte = 0xF8;

	mov	BYTE PTR lbyte$1[rsp], 248		; 000000f8H

; 917  :               if (ins->byte1_info == F_660F) lbyte |= 0x01;

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 18
	jne	SHORT $LN363@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 1
	mov	BYTE PTR lbyte$1[rsp], al
$LN363@output_opc:

; 918  :             }

	jmp	SHORT $LN362@output_opc
$LN361@output_opc:

; 919  :             else if ((CodeInfo->token >= T_KMOVB) && (CodeInfo->token <= T_KMOVW)) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1730		; 000006c2H
	jl	SHORT $LN364@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1733		; 000006c5H
	jg	SHORT $LN364@output_opc

; 920  :               /*  1 1111 0pp */
; 921  :               /*  R vvvv Lpp */
; 922  :               lbyte = 0xF8;

	mov	BYTE PTR lbyte$1[rsp], 248		; 000000f8H

; 923  :               if (ins->byte1_info == F_660F) lbyte |= 0x01;

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 18
	jne	SHORT $LN365@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 1
	mov	BYTE PTR lbyte$1[rsp], al
	jmp	SHORT $LN366@output_opc
$LN365@output_opc:

; 924  :               else if (ins->byte1_info == F_F20F) lbyte |= 0x3;

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 19
	jne	SHORT $LN367@output_opc
	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 3
	mov	BYTE PTR lbyte$1[rsp], al
$LN367@output_opc:
$LN366@output_opc:
$LN364@output_opc:
$LN362@output_opc:
$LN359@output_opc:

; 925  :             }  //WVVVV1PP
; 926  :               if ((CodeInfo->token == T_VMOVHPD)||(CodeInfo->token == T_VMOVNTDQ)||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1940		; 00000794H
	je	SHORT $LN369@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1948		; 0000079cH
	je	SHORT $LN369@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1648		; 00000670H
	jl	SHORT $LN368@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1651		; 00000673H
	jg	SHORT $LN368@output_opc
$LN369@output_opc:

; 927  :                 (CodeInfo->token >= T_VFPCLASSPD)&&(CodeInfo->token <= T_VFPCLASSSS)){
; 928  :                 if (CodeInfo->vexregop){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	test	eax, eax
	je	SHORT $LN370@output_opc

; 929  :                   lbyte &= ~0x78;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	and	eax, -121				; ffffffffffffff87H
	mov	BYTE PTR lbyte$1[rsp], al

; 930  :                   lbyte |= ((16 - CodeInfo->vexregop) << 3);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	mov	ecx, 16
	sub	ecx, eax
	mov	eax, ecx
	shl	eax, 3
	movzx	ecx, BYTE PTR lbyte$1[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR lbyte$1[rsp], al

; 931  :                 }

	jmp	SHORT $LN371@output_opc
$LN370@output_opc:

; 932  :                 else lbyte |= 0x78;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 120				; 00000078H
	mov	BYTE PTR lbyte$1[rsp], al
$LN371@output_opc:
$LN368@output_opc:

; 933  :               }
; 934  :               if (CodeInfo->evex_flag){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	je	SHORT $LN372@output_opc

; 935  :                 if ((CodeInfo->token == T_VMOVHPS) || (CodeInfo->token == T_VMOVLPS))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1941		; 00000795H
	je	SHORT $LN374@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1943		; 00000797H
	jne	SHORT $LN373@output_opc
$LN374@output_opc:

; 936  :                   lbyte &= ~EVEX_P1WMASK;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	btr	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN373@output_opc:
$LN372@output_opc:

; 937  :               }
; 938  :              if ((CodeInfo->token == T_VPSLLQ)||(CodeInfo->token == T_VPSRLQ)||
; 939  :                (CodeInfo->token == T_VPSRAQ)|| (CodeInfo->token == T_VPROLQ)||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2046		; 000007feH
	je	SHORT $LN376@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2051		; 00000803H
	je	SHORT $LN376@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1545		; 00000609H
	je	SHORT $LN376@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1539		; 00000603H
	je	SHORT $LN376@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1543		; 00000607H
	jne	SHORT $LN375@output_opc
$LN376@output_opc:

; 940  :                (CodeInfo->token == T_VPRORQ))
; 941  :                lbyte |= EVEX_P1WMASK;

	movzx	eax, BYTE PTR lbyte$1[rsp]
	bts	eax, 7
	mov	BYTE PTR lbyte$1[rsp], al
$LN375@output_opc:

; 942  :             //if first byte is VEX 0xC5 then there is two byte folowing 
; 943  :             if ((CodeInfo->token == T_KUNPCKBW)||(CodeInfo->token == T_KUNPCKWD)||(CodeInfo->token == T_KUNPCKDQ))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1699		; 000006a3H
	je	SHORT $LN378@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1700		; 000006a4H
	je	SHORT $LN378@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1713		; 000006b1H
	jne	SHORT $LN377@output_opc
$LN378@output_opc:

; 944  :                   lbyte |=  0x04; 

	movzx	eax, BYTE PTR lbyte$1[rsp]
	or	eax, 4
	mov	BYTE PTR lbyte$1[rsp], al
$LN377@output_opc:

; 945  :             CodeInfo->evex_p1 = lbyte;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR lbyte$1[rsp]
	mov	BYTE PTR [rax+138], cl

; 946  :             OutputCodeByte( lbyte );

	movzx	ecx, BYTE PTR lbyte$1[rsp]
	call	OutputByte

; 947  :             if (CodeInfo->evex_flag) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	je	$LN379@output_opc

; 948  :               if (broadflags >= 0x10 && broadflags <= 0x47){         

	movzx	eax, BYTE PTR broadflags
	cmp	eax, 16
	jl	$LN380@output_opc
	movzx	eax, BYTE PTR broadflags
	cmp	eax, 71					; 00000047H
	jg	$LN380@output_opc

; 949  :                 CodeInfo->evex_p2 |= 0x10;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 16
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 950  :                 if (CodeInfo->vexregop){                 

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	test	eax, eax
	je	SHORT $LN382@output_opc

; 951  :                   if (CodeInfo->reg2 <= 15) CodeInfo->evex_p2 |= EVEX_P2VMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 15
	jg	SHORT $LN384@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 8
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
	jmp	SHORT $LN385@output_opc
$LN384@output_opc:

; 952  :                   else CodeInfo->evex_p2 &= ~EVEX_P2VMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -9
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN385@output_opc:

; 953  :                 }

	jmp	SHORT $LN383@output_opc
$LN382@output_opc:

; 954  :                 else CodeInfo->evex_p2 |= EVEX_P2VMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 8
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN383@output_opc:

; 955  :                 if (CodeInfo->r2type == OP_XMM && (broadflags & ~EVEX_P2AAAMASK) == 0x10){   //{1to2}

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+120], 32			; 00000020H
	jne	SHORT $LN386@output_opc
	movzx	eax, BYTE PTR broadflags
	and	eax, -8
	cmp	eax, 16
	jne	SHORT $LN386@output_opc

; 956  :                    if ((CodeInfo->mem_type != MT_QWORD) && (CodeInfo->mem_type != MT_EMPTY))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 7
	je	SHORT $LN388@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	je	SHORT $LN388@output_opc

; 957  :                      EmitError( INVALID_OPERAND_SIZE );

	mov	ecx, 71					; 00000047H
	call	EmitError
$LN388@output_opc:

; 958  :                    if ((CodeInfo->pinstr->prefix & 0xE0) == QSIZE)

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+8]
	and	eax, 224				; 000000e0H
	cmp	eax, 96					; 00000060H
	jne	SHORT $LN389@output_opc

; 959  :                      CodeInfo->mem_type = MT_QWORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 7
	jmp	SHORT $LN390@output_opc
$LN389@output_opc:

; 960  :                    else
; 961  :                      EmitError( MISMATCH_IN_THE_NUMBER_OF_BROADCASTING_ELEMENTS );

	mov	ecx, 18
	call	EmitError
$LN390@output_opc:

; 962  :                 }

	jmp	$LN387@output_opc
$LN386@output_opc:

; 963  :                 else if (CodeInfo->r2type == OP_XMM && (broadflags & ~EVEX_P2AAAMASK) == 0x20){ //{1to4} 

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+120], 32			; 00000020H
	jne	SHORT $LN391@output_opc
	movzx	eax, BYTE PTR broadflags
	and	eax, -8
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN391@output_opc

; 964  :                    if ((CodeInfo->mem_type != MT_DWORD) && (CodeInfo->mem_type != MT_EMPTY))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 3
	je	SHORT $LN393@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	je	SHORT $LN393@output_opc

; 965  :                      EmitError( INVALID_OPERAND_SIZE );

	mov	ecx, 71					; 00000047H
	call	EmitError
$LN393@output_opc:

; 966  :                    if ((CodeInfo->pinstr->prefix & 0xE0) == DSIZE)

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+8]
	and	eax, 224				; 000000e0H
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN394@output_opc

; 967  :                      CodeInfo->mem_type = MT_DWORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 3
	jmp	SHORT $LN395@output_opc
$LN394@output_opc:

; 968  :                    else
; 969  :                      EmitError( MISMATCH_IN_THE_NUMBER_OF_BROADCASTING_ELEMENTS );

	mov	ecx, 18
	call	EmitError
$LN395@output_opc:

; 970  :                 }

	jmp	$LN392@output_opc
$LN391@output_opc:

; 971  :                 else if (CodeInfo->r2type == OP_YMM && (broadflags & ~EVEX_P2AAAMASK) == 0x20){ //{1to4}

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+120], 128		; 00000080H
	jne	$LN396@output_opc
	movzx	eax, BYTE PTR broadflags
	and	eax, -8
	cmp	eax, 32					; 00000020H
	jne	$LN396@output_opc

; 972  :                    if ((CodeInfo->mem_type != MT_QWORD) && (CodeInfo->mem_type != MT_EMPTY))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 7
	je	SHORT $LN398@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	je	SHORT $LN398@output_opc

; 973  :                      EmitError( INVALID_OPERAND_SIZE );

	mov	ecx, 71					; 00000047H
	call	EmitError
$LN398@output_opc:

; 974  :                    if ((CodeInfo->pinstr->prefix & 0xE0) == QSIZE){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+8]
	and	eax, 224				; 000000e0H
	cmp	eax, 96					; 00000060H
	jne	SHORT $LN399@output_opc

; 975  :                      CodeInfo->mem_type = MT_QWORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 7

; 976  :                      CodeInfo->evex_p2 |= 0x20;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 32					; 00000020H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 977  :                    }

	jmp	SHORT $LN400@output_opc
$LN399@output_opc:

; 978  :                    else 
; 979  :                      EmitError( MISMATCH_IN_THE_NUMBER_OF_BROADCASTING_ELEMENTS );

	mov	ecx, 18
	call	EmitError
$LN400@output_opc:

; 980  :                 }

	jmp	$LN397@output_opc
$LN396@output_opc:

; 981  :                 else if (CodeInfo->r2type == OP_YMM && (broadflags & ~EVEX_P2AAAMASK) == 0x30){ //{1to8}

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+120], 128		; 00000080H
	jne	$LN401@output_opc
	movzx	eax, BYTE PTR broadflags
	and	eax, -8
	cmp	eax, 48					; 00000030H
	jne	$LN401@output_opc

; 982  :                    if ((CodeInfo->mem_type != MT_DWORD) && (CodeInfo->mem_type != MT_EMPTY)||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 3
	je	SHORT $LN405@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	SHORT $LN404@output_opc
$LN405@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 15
	je	SHORT $LN403@output_opc
$LN404@output_opc:

; 983  :                      (CodeInfo->mem_type != MT_OWORD))
; 984  :                      EmitError( INVALID_OPERAND_SIZE );

	mov	ecx, 71					; 00000047H
	call	EmitError
$LN403@output_opc:

; 985  :                    if ((CodeInfo->pinstr->prefix & 0xE0) == DSIZE){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+8]
	and	eax, 224				; 000000e0H
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN406@output_opc

; 986  :                      CodeInfo->mem_type = MT_DWORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 3

; 987  :                      CodeInfo->evex_p2 |= 0x20;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 32					; 00000020H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 988  :                    }

	jmp	SHORT $LN407@output_opc
$LN406@output_opc:

; 989  :                    else 
; 990  :                      EmitError( MISMATCH_IN_THE_NUMBER_OF_BROADCASTING_ELEMENTS );

	mov	ecx, 18
	call	EmitError
$LN407@output_opc:

; 991  :                 }

	jmp	$LN402@output_opc
$LN401@output_opc:

; 992  :                 else if ( CodeInfo->r2type == OP_ZMM && (broadflags & ~EVEX_P2AAAMASK) == 0x30){ //{1to8}

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+120], 256		; 00000100H
	jne	SHORT $LN408@output_opc
	movzx	eax, BYTE PTR broadflags
	and	eax, -8
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN408@output_opc

; 993  :                    if ((CodeInfo->pinstr->prefix & 0xE0) == QSIZE){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+8]
	and	eax, 224				; 000000e0H
	cmp	eax, 96					; 00000060H
	jne	SHORT $LN410@output_opc

; 994  :                      CodeInfo->mem_type = MT_QWORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 7

; 995  :                      CodeInfo->evex_p2 |= 0x40;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 996  :                    }

	jmp	SHORT $LN411@output_opc
$LN410@output_opc:

; 997  :                    else 
; 998  :                      EmitError( MISMATCH_IN_THE_NUMBER_OF_BROADCASTING_ELEMENTS );

	mov	ecx, 18
	call	EmitError
$LN411@output_opc:

; 999  :                 }

	jmp	SHORT $LN409@output_opc
$LN408@output_opc:

; 1000 :                 else if (CodeInfo->r2type == OP_ZMM && (broadflags & ~EVEX_P2AAAMASK) == 0x40){ //{1to16}

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+120], 256		; 00000100H
	jne	SHORT $LN412@output_opc
	movzx	eax, BYTE PTR broadflags
	and	eax, -8
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN412@output_opc

; 1001 :                    if ((CodeInfo->pinstr->prefix & 0xE0) == DSIZE){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+8]
	and	eax, 224				; 000000e0H
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN413@output_opc

; 1002 :                      CodeInfo->mem_type = MT_DWORD;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rax+28], 3

; 1003 :                      CodeInfo->evex_p2 |= 0x40;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 1004 :                    }

	jmp	SHORT $LN414@output_opc
$LN413@output_opc:

; 1005 :                    else 
; 1006 :                      EmitError(MISMATCH_IN_THE_NUMBER_OF_BROADCASTING_ELEMENTS);

	mov	ecx, 18
	call	EmitError
$LN414@output_opc:
$LN412@output_opc:
$LN409@output_opc:
$LN402@output_opc:
$LN397@output_opc:
$LN392@output_opc:
$LN387@output_opc:

; 1007 :                 }
; 1008 :               }

	jmp	$LN381@output_opc
$LN380@output_opc:

; 1009 :               else{   //check all for size
; 1010 :                 if (CodeInfo->r2type == OP_YMM){              

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+120], 128		; 00000080H
	jne	$LN415@output_opc

; 1011 :                   if (CodeInfo->mem_type == MT_YMMWORD || (CodeInfo->mem_type == MT_EMPTY)){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 31
	je	SHORT $LN419@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	SHORT $LN417@output_opc
$LN419@output_opc:

; 1012 :                     CodeInfo->evex_p2 |= 0x20;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 32					; 00000020H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 1013 :                     if ((CodeInfo->opnd[OPND3].data32h > 0x20)||(CodeInfo->opnd[OPND3].data32h > ~0x20)) 

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+44], 32		; 00000020H
	jg	SHORT $LN421@output_opc
	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+44], -33		; ffffffffffffffdfH
	jle	SHORT $LN420@output_opc
$LN421@output_opc:

; 1014 :                       CodeInfo->tuple = TRUE;  

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 1
$LN420@output_opc:

; 1015 :                   }

	jmp	SHORT $LN418@output_opc
$LN417@output_opc:

; 1016 :                   else EmitError(INVALID_OPERAND_SIZE);

	mov	ecx, 71					; 00000047H
	call	EmitError
$LN418@output_opc:

; 1017 :                 }

	jmp	$LN416@output_opc
$LN415@output_opc:

; 1018 :                 else if (CodeInfo->r2type == OP_XMM){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+120], 32			; 00000020H
	jne	$LN422@output_opc

; 1019 :                   if ((CodeInfo->mem_type == MT_OWORD || CodeInfo->mem_type == MT_EMPTY)){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 15
	je	SHORT $LN426@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	SHORT $LN424@output_opc
$LN426@output_opc:

; 1020 :                     if ((CodeInfo->opnd[OPND3].data32h > 0x10)||(CodeInfo->opnd[OPND3].data32h > ~0x10))

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+44], 16
	jg	SHORT $LN428@output_opc
	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+44], -17
	jle	SHORT $LN427@output_opc
$LN428@output_opc:

; 1021 :                       CodeInfo->tuple = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 1
$LN427@output_opc:

; 1022 :                   }

	jmp	$LN425@output_opc
$LN424@output_opc:

; 1023 :                   else if ((CodeInfo->token >= T_VCMPEQSD || CodeInfo->token <= T_VCMPTRUE_USSD) &&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1830		; 00000726H
	jge	SHORT $LN431@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1861		; 00000745H
	jg	SHORT $LN429@output_opc
$LN431@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 7
	jne	SHORT $LN429@output_opc

; 1024 :                     (CodeInfo->mem_type == MT_QWORD)){
; 1025 :                       if ((CodeInfo->opnd[OPND3].data32h > 8)||(CodeInfo->opnd[OPND3].data32h > ~8))

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+44], 8
	jg	SHORT $LN433@output_opc
	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+44], -9
	jle	SHORT $LN432@output_opc
$LN433@output_opc:

; 1026 :                       CodeInfo->tuple = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 1
$LN432@output_opc:

; 1027 :                   }

	jmp	SHORT $LN430@output_opc
$LN429@output_opc:

; 1028 :                   else if ((CodeInfo->token >= T_VCMPEQSS || CodeInfo->token <= T_VCMPTRUE_USSS) &&

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1862		; 00000746H
	jge	SHORT $LN436@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1893		; 00000765H
	jg	SHORT $LN434@output_opc
$LN436@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 3
	jne	SHORT $LN434@output_opc

; 1029 :                     (CodeInfo->mem_type == MT_DWORD)){
; 1030 :                       if ((CodeInfo->opnd[OPND3].data32h > 4)||(CodeInfo->opnd[OPND3].data32h > ~4))

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+44], 4
	jg	SHORT $LN438@output_opc
	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+44], -5
	jle	SHORT $LN437@output_opc
$LN438@output_opc:

; 1031 :                       CodeInfo->tuple = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 1
$LN437@output_opc:

; 1032 :                   }

	jmp	SHORT $LN435@output_opc
$LN434@output_opc:

; 1033 :                   else EmitError(INVALID_OPERAND_SIZE);

	mov	ecx, 71					; 00000047H
	call	EmitError
$LN435@output_opc:
$LN430@output_opc:
$LN425@output_opc:

; 1034 :                 }

	jmp	$LN423@output_opc
$LN422@output_opc:

; 1035 :                 else if (CodeInfo->r2type == OP_ZMM){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+120], 256		; 00000100H
	jne	SHORT $LN439@output_opc

; 1036 :                   if (CodeInfo->mem_type == MT_ZMMWORD || (CodeInfo->mem_type == MT_EMPTY)){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 63			; 0000003fH
	je	SHORT $LN441@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+28], 192			; 000000c0H
	jne	SHORT $LN440@output_opc
$LN441@output_opc:

; 1037 :                     CodeInfo->evex_p2 |= 0x40;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 1038 :                     if ((CodeInfo->opnd[OPND3].data32h > 0x40)||(CodeInfo->opnd[OPND3].data32h > ~0x40))

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+44], 64		; 00000040H
	jg	SHORT $LN443@output_opc
	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+44], -65		; ffffffffffffffbfH
	jle	SHORT $LN442@output_opc
$LN443@output_opc:

; 1039 :                       CodeInfo->tuple = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 1
$LN442@output_opc:
$LN440@output_opc:
$LN439@output_opc:
$LN423@output_opc:
$LN416@output_opc:

; 1040 :                   }
; 1041 :                 }
; 1042 :                 if (CodeInfo->opnd[OPND3].data32l != -1){

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], -1
	je	$LN444@output_opc

; 1043 :                   if ((CodeInfo->r2type == OP_YMM) && (CodeInfo->opnd[OPND3].type != OP_ZMM)){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+120], 128		; 00000080H
	jne	$LN445@output_opc
	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 256		; 00000100H
	je	SHORT $LN445@output_opc

; 1044 :                     if ((CodeInfo->token >= T_VCMPEQPD) && (CodeInfo->token <= T_VCMPTRUE_USSS))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1766		; 000006e6H
	jl	SHORT $LN446@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1893		; 00000765H
	jg	SHORT $LN446@output_opc

; 1045 :                       CodeInfo->evex_p2 |= 0x40;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN446@output_opc:

; 1046 :                     if (CodeInfo->opnd[OPND3].data32l >= 0x20)

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 32		; 00000020H
	jl	SHORT $LN447@output_opc

; 1047 :                       CodeInfo->tuple = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 1
$LN447@output_opc:
$LN445@output_opc:
$LN444@output_opc:
$LN381@output_opc:

; 1048 :                   }
; 1049 :                 }
; 1050 :               }
; 1051 :               if (CodeInfo->evex_sae){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+141]
	test	eax, eax
	je	SHORT $LN448@output_opc

; 1052 :                 CodeInfo->evex_p2 &= ~0x70;     //clear bites 6,5,4

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -113				; ffffffffffffff8fH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 1053 :                 c = CodeInfo->evex_sae - 0x10;  //subtract SAE to get a proper decorator

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+141]
	sub	eax, 16
	mov	BYTE PTR c$[rsp], al

; 1054 :                 /* here we need to test for corect use of decorators  
; 1055 :                  * if it is {sae} c will be zero, in that case we need to add 0x10 to c
; 1056 :                  * if we need {sae}
; 1057 :                 */  
; 1058 :                 if (c == 0) c = 0x10;

	movzx	eax, BYTE PTR c$[rsp]
	test	eax, eax
	jne	SHORT $LN449@output_opc
	mov	BYTE PTR c$[rsp], 16
$LN449@output_opc:

; 1059 :                 CodeInfo->evex_p2 |= c;

	movzx	eax, BYTE PTR c$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+139]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN448@output_opc:

; 1060 :               }
; 1061 :                 if (CodeInfo->r2type == OP_YMM) CodeInfo->evex_p2 |= EVEX_P2LMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+120], 128		; 00000080H
	jne	SHORT $LN450@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 32					; 00000020H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
	jmp	SHORT $LN451@output_opc
$LN450@output_opc:

; 1062 :                 else if (CodeInfo->opnd[OPND3].type == OP_ZMM)CodeInfo->evex_p2 |= EVEX_P2L1MASK; 

	mov	eax, 24
	imul	rax, rax, 2
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 256		; 00000100H
	jne	SHORT $LN452@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN452@output_opc:
$LN451@output_opc:

; 1063 :                 if ((CodeInfo->token >= T_VPGATHERDD && CodeInfo->token <= T_VGATHERQPS )||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1345		; 00000541H
	jl	SHORT $LN455@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1352		; 00000548H
	jle	SHORT $LN454@output_opc
$LN455@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1339		; 0000053bH
	jne	SHORT $LN453@output_opc
$LN454@output_opc:

; 1064 :                   CodeInfo->token == T_VCVTPD2DQ)
; 1065 :                   CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN453@output_opc:

; 1066 :                   if ((CodeInfo->token == T_VEXTRACTPS)||      // 1914    1932
; 1067 :                     //(CodeInfo->token == T_VMOVHPS)||(CodeInfo->token == T_VMOVLPS)||           // 1933    1935  
; 1068 :                     (CodeInfo->token == T_VCVTSD2USI)||(CodeInfo->token == T_VCVTSS2USI)||     // 1598    1599

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1922		; 00000782H
	je	SHORT $LN457@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1603		; 00000643H
	je	SHORT $LN457@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1604		; 00000644H
	je	SHORT $LN457@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1940		; 00000794H
	jl	SHORT $LN456@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1945		; 00000799H
	jg	SHORT $LN456@output_opc
$LN457@output_opc:

; 1069 :                     (CodeInfo->token >= T_VMOVHPD)&&(CodeInfo->token <= T_VMOVSS))              // 1936    1937
; 1070 :                     CodeInfo->evex_p2 &= ~EVEX_P2L1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -65				; ffffffffffffffbfH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN456@output_opc:

; 1071 :                 if (CodeInfo->evex_flag){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	test	eax, eax
	je	$LN458@output_opc

; 1072 :                   if (CodeInfo->vexregop){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+128]
	test	eax, eax
	je	SHORT $LN459@output_opc

; 1073 :                     if (CodeInfo->reg2 <= 15) CodeInfo->evex_p2 |= EVEX_P2VMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	cmp	eax, 15
	jg	SHORT $LN461@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 8
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
	jmp	SHORT $LN462@output_opc
$LN461@output_opc:

; 1074 :                     else CodeInfo->evex_p2 &= ~EVEX_P2VMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -9
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN462@output_opc:

; 1075 :                   }

	jmp	SHORT $LN460@output_opc
$LN459@output_opc:

; 1076 :                   else CodeInfo->evex_p2 |= EVEX_P2VMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 8
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN460@output_opc:

; 1077 :                   CodeInfo->tuple = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 1

; 1078 :                   CodeInfo->evex_p2 |= decoflags;

	movzx	eax, BYTE PTR decoflags
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+139]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 1079 :                   if (CodeInfo->token == T_VCVTDQ2PD || CodeInfo->token == T_VCVTPS2PD ||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1904		; 00000770H
	je	SHORT $LN464@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1908		; 00000774H
	je	SHORT $LN464@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1447		; 000005a7H
	jne	$LN463@output_opc
$LN464@output_opc:

; 1080 :                     CodeInfo->token == T_VCVTUDQ2PD){       
; 1081 :                      CodeInfo->evex_p2 &= ~EVEX_P2LMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -33				; ffffffffffffffdfH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 1082 :                      CodeInfo->evex_p2 &= ~EVEX_P2L1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, -65				; ffffffffffffffbfH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al

; 1083 :                     if (CodeInfo->r1type == OP_YMM)CodeInfo->evex_p2 |= EVEX_P2LMASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+116], 128		; 00000080H
	jne	SHORT $LN465@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 32					; 00000020H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
	jmp	SHORT $LN466@output_opc
$LN465@output_opc:

; 1084 :                     else if (CodeInfo->r1type == OP_ZMM)CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+116], 256		; 00000100H
	jne	SHORT $LN467@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+139], al
$LN467@output_opc:
$LN466@output_opc:
$LN463@output_opc:

; 1085 :                   }
; 1086 :                   OutputCodeByte(CodeInfo->evex_p2);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rax+139]
	call	OutputByte
$LN458@output_opc:
$LN379@output_opc:
$LN87@output_opc:

; 1087 :                 }
; 1088 :             }
; 1089 :         }
; 1090 :     } else {

	jmp	$LN73@output_opc
$LN72@output_opc:

; 1091 : #endif
; 1092 : 
; 1093 : #if AMD64_SUPPORT
; 1094 :     /* the REX prefix must be located after the other prefixes */
; 1095 :     if( CodeInfo->prefix.rex != 0 ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	test	eax, eax
	je	SHORT $LN468@output_opc

; 1096 :         if ( CodeInfo->Ofssize != USE64 ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 2
	je	SHORT $LN469@output_opc

; 1097 :             EmitError( INVALID_OPERAND_SIZE );

	mov	ecx, 71					; 00000047H
	call	EmitError
$LN469@output_opc:

; 1098 :         }
; 1099 :         OutputCodeByte( CodeInfo->prefix.rex | 0x40 );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	or	eax, 64					; 00000040H
	movzx	ecx, al
	call	OutputByte
$LN468@output_opc:

; 1100 :     }
; 1101 : #endif
; 1102 : 
; 1103 :     /*
; 1104 :      * Output extended opcode
; 1105 :      * special case for some 286 and 386 instructions
; 1106 :      * or 3DNow!, MMX and SSEx instructions
; 1107 :      */
; 1108 :     if ( ins->byte1_info >= F_0F ) {

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 16
	jl	SHORT $LN470@output_opc

; 1109 :         OutputCodeByte( EXTENDED_OPCODE );

	mov	cl, 15
	call	OutputByte

; 1110 :         switch ( ins->byte1_info ) {

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	DWORD PTR tv2660[rsp], eax
	mov	eax, DWORD PTR tv2660[rsp]
	sub	eax, 17
	mov	DWORD PTR tv2660[rsp], eax
	cmp	DWORD PTR tv2660[rsp], 10
	ja	SHORT $LN12@output_opc
	movsxd	rax, DWORD PTR tv2660[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN558@output_opc[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN471@output_opc:

; 1111 :         case F_0F0F:   OutputCodeByte( EXTENDED_OPCODE ); break;

	mov	cl, 15
	call	OutputByte
	jmp	SHORT $LN12@output_opc
$LN472@output_opc:

; 1112 :         case F_0F38:
; 1113 :         case F_F20F38:
; 1114 :         case F_660F38: OutputCodeByte( 0x38 );            break;

	mov	cl, 56					; 00000038H
	call	OutputByte
	jmp	SHORT $LN12@output_opc
$LN473@output_opc:

; 1115 :         case F_0F3A:
; 1116 :         case F_660F3A: OutputCodeByte( 0x3A );            break;

	mov	cl, 58					; 0000003aH
	call	OutputByte
$LN12@output_opc:
$LN470@output_opc:
$LN73@output_opc:

; 1117 :         }
; 1118 :     }
; 1119 : 
; 1120 : #if AVXSUPP
; 1121 :     }
; 1122 : #endif
; 1123 : 
; 1124 :     switch( ins->rm_info) {

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+5]
	mov	BYTE PTR tv2668[rsp], al
	cmp	BYTE PTR tv2668[rsp], 1
	je	SHORT $LN475@output_opc
	cmp	BYTE PTR tv2668[rsp], 2
	je	SHORT $LN476@output_opc
	cmp	BYTE PTR tv2668[rsp], 3
	je	SHORT $LN474@output_opc
	jmp	SHORT $LN477@output_opc
$LN474@output_opc:

; 1125 :     case R_in_OP:
; 1126 :         OutputCodeByte( ins->opcode | ( CodeInfo->rm_byte & NOT_BIT_67 ) );

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+12]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+104]
	and	ecx, 63					; 0000003fH
	or	eax, ecx
	movzx	ecx, al
	call	OutputByte

; 1127 :         break;

	jmp	$LN14@output_opc
$LN475@output_opc:

; 1128 :     case no_RM:
; 1129 :         OutputCodeByte( ins->opcode | CodeInfo->iswide );

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+12]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+142]
	and	cl, 1
	movzx	ecx, cl
	or	eax, ecx
	movzx	ecx, al
	call	OutputByte

; 1130 :         break;

	jmp	$LN14@output_opc
$LN476@output_opc:

; 1131 :     case no_WDS:
; 1132 :         CodeInfo->iswide = 0;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+142]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+142], al
$LN477@output_opc:

; 1133 :         /* no break */
; 1134 :     default: /* opcode (with w d s bits), rm-byte */
; 1135 :            if( ins->byte1_info != F_0F0F ) {

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	cmp	eax, 17
	je	$LN478@output_opc

; 1136 :              if ((CodeInfo->token >= T_KADDB) && (CodeInfo->token <= T_KMOVW)){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1687		; 00000697H
	jl	$LN479@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1733		; 000006c5H
	jg	$LN479@output_opc

; 1137 :                if ((CodeInfo->token >= T_KMOVB) && (CodeInfo->token <= T_KMOVW)){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1730		; 000006c2H
	jl	$LN481@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1733		; 000006c5H
	jg	$LN481@output_opc

; 1138 :                 const  struct instr_item *p = CodeInfo->pinstr;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR p$7[rsp], rax

; 1139 :                  int cnt;
; 1140 :                  int type1 = CodeInfo->opnd[OPND1].type;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	mov	DWORD PTR type1$5[rsp], eax

; 1141 :                  int type2 = CodeInfo->opnd[OPND2].type;

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	mov	DWORD PTR type2$6[rsp], eax

; 1142 :                  CodeInfo->tuple = 0;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 0

; 1143 :                  /* at least one operand must be K register */
; 1144 :                  if (type1 == OP_K || type2 == OP_K)

	cmp	DWORD PTR type1$5[rsp], 64		; 00000040H
	je	SHORT $LN485@output_opc
	cmp	DWORD PTR type2$6[rsp], 64		; 00000040H
	jne	SHORT $LN483@output_opc
$LN485@output_opc:

; 1145 :                    ;    //OK

	jmp	SHORT $LN484@output_opc
$LN483@output_opc:

; 1146 :                  else
; 1147 :                  EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN484@output_opc:

; 1148 :                  /* find the proper opcode for the command movw KREG,GP_REG */
; 1149 :                  for (cnt = 0; cnt < 5; cnt++,p++){

	mov	DWORD PTR cnt$4[rsp], 0
	jmp	SHORT $LN18@output_opc
$LN16@output_opc:
	mov	eax, DWORD PTR cnt$4[rsp]
	inc	eax
	mov	DWORD PTR cnt$4[rsp], eax
	mov	rax, QWORD PTR p$7[rsp]
	add	rax, 14
	mov	QWORD PTR p$7[rsp], rax
$LN18@output_opc:
	cmp	DWORD PTR cnt$4[rsp], 5
	jge	SHORT $LN17@output_opc

; 1150 :                    if ((opnd_clstab[p->opclsidx].opnd_type[OPND1] == type1) && 

	mov	rax, QWORD PTR p$7[rsp]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, DWORD PTR type1$5[rsp]
	cmp	DWORD PTR [rax+rcx], edx
	jne	SHORT $LN486@output_opc
	mov	rax, QWORD PTR p$7[rsp]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, DWORD PTR type2$6[rsp]
	cmp	DWORD PTR [rax+rcx], edx
	jne	SHORT $LN486@output_opc

; 1151 :                      (opnd_clstab[p->opclsidx].opnd_type[OPND2] == type2))
; 1152 :                      break;

	jmp	SHORT $LN17@output_opc
$LN486@output_opc:

; 1153 :                  }

	jmp	$LN16@output_opc
$LN17@output_opc:

; 1154 :                  if (cnt < 5) {   //there are 5 combinations

	cmp	DWORD PTR cnt$4[rsp], 5
	jge	SHORT $LN487@output_opc

; 1155 :                    OutputCodeByte(p->opcode);

	mov	rax, QWORD PTR p$7[rsp]
	movzx	ecx, BYTE PTR [rax+12]
	call	OutputByte

; 1156 :                  }

	jmp	SHORT $LN488@output_opc
$LN487@output_opc:

; 1157 :                  else
; 1158 :                    OutputCodeByte(ins->opcode);

	mov	rax, QWORD PTR ins$[rsp]
	movzx	ecx, BYTE PTR [rax+12]
	call	OutputByte
$LN488@output_opc:

; 1159 :               }else

	jmp	SHORT $LN482@output_opc
$LN481@output_opc:

; 1160 :                 OutputCodeByte(ins->opcode);

	mov	rax, QWORD PTR ins$[rsp]
	movzx	ecx, BYTE PTR [rax+12]
	call	OutputByte
$LN482@output_opc:

; 1161 :              }

	jmp	SHORT $LN480@output_opc
$LN479@output_opc:

; 1162 :              else{
; 1163 :                OutputCodeByte(ins->opcode | CodeInfo->iswide | CodeInfo->opc_or);

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+12]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+142]
	and	cl, 1
	movzx	ecx, cl
	or	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+107]
	or	eax, ecx
	movzx	ecx, al
	call	OutputByte
$LN480@output_opc:
$LN478@output_opc:

; 1164 :              }
; 1165 :         }
; 1166 : 
; 1167 :         /* emit ModRM byte; bits 7-6 = Mod, bits 5-3 = Reg, bits 2-0 = R/M */
; 1168 :            if ((CodeInfo->token == T_VRNDSCALEPD) || (CodeInfo->token == T_VRNDSCALEPS))CodeInfo->tuple = TRUE;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1615		; 0000064fH
	je	SHORT $LN490@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1616		; 00000650H
	jne	SHORT $LN489@output_opc
$LN490@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 1
$LN489@output_opc:

; 1169 :             if ((CodeInfo->token >= T_KADDB) && (CodeInfo->token <= T_KUNPCKDQ)) {       //here pay atention

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1687		; 00000697H
	jl	SHORT $LN491@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1713		; 000006b1H
	jg	SHORT $LN491@output_opc

; 1170 :               c = CodeInfo->reg1;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	mov	BYTE PTR c$[rsp], al

; 1171 :               tmp = MOD_11;           //bits 7-6 = Mod

	mov	BYTE PTR tmp$[rsp], 192			; 000000c0H

; 1172 :               c = (c << 3);           //bits 5-3 = Reg,

	movzx	eax, BYTE PTR c$[rsp]
	shl	eax, 3
	mov	BYTE PTR c$[rsp], al

; 1173 :               tmp |= c;            

	movzx	eax, BYTE PTR c$[rsp]
	movzx	ecx, BYTE PTR tmp$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR tmp$[rsp], al

; 1174 :               tmp |= CodeInfo->reg3;  //bits 2-0 = R/M

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+111]
	movzx	ecx, BYTE PTR tmp$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR tmp$[rsp], al

; 1175 :             }

	jmp	SHORT $LN492@output_opc
$LN491@output_opc:

; 1176 :             else if ((CodeInfo->token >= T_KNOTB) && (CodeInfo->token <= T_KORTESTQ)) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1714		; 000006b2H
	jl	SHORT $LN493@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1721		; 000006b9H
	jg	SHORT $LN493@output_opc

; 1177 :                 tmp = MOD_11;                 //bits 7-6 = Mod

	mov	BYTE PTR tmp$[rsp], 192			; 000000c0H

; 1178 :                 tmp |= (CodeInfo->reg1 << 3); //bits 5-3 = Reg,

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+109]
	shl	eax, 3
	movzx	ecx, BYTE PTR tmp$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR tmp$[rsp], al

; 1179 :                 tmp |= CodeInfo->reg2;        //bits 2-0 = R/M

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	movzx	ecx, BYTE PTR tmp$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR tmp$[rsp], al

; 1180 :             }

	jmp	SHORT $LN494@output_opc
$LN493@output_opc:

; 1181 :         else
; 1182 :         tmp = ins->rm_byte | CodeInfo->rm_byte;

	mov	rax, QWORD PTR ins$[rsp]
	movzx	eax, BYTE PTR [rax+13]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+104]
	or	eax, ecx
	mov	BYTE PTR tmp$[rsp], al
$LN494@output_opc:
$LN492@output_opc:

; 1183 :             if (CodeInfo->token == T_VCVTPS2PH){//(!CodeInfo->evex_flag) && 

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1433		; 00000599H
	jne	SHORT $LN495@output_opc

; 1184 :               //tmp &= 0xC0;
; 1185 :               c = CodeInfo->reg2;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	mov	BYTE PTR c$[rsp], al

; 1186 :               if (c > 15)c -= 16 ;

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 15
	jle	SHORT $LN496@output_opc
	movzx	eax, BYTE PTR c$[rsp]
	sub	eax, 16
	mov	BYTE PTR c$[rsp], al
$LN496@output_opc:

; 1187 :               if (c > 7)c -= 8;

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 7
	jle	SHORT $LN497@output_opc
	movzx	eax, BYTE PTR c$[rsp]
	sub	eax, 8
	mov	BYTE PTR c$[rsp], al
$LN497@output_opc:

; 1188 :               c = (c << 3);

	movzx	eax, BYTE PTR c$[rsp]
	shl	eax, 3
	mov	BYTE PTR c$[rsp], al

; 1189 :               tmp |= c;

	movzx	eax, BYTE PTR c$[rsp]
	movzx	ecx, BYTE PTR tmp$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR tmp$[rsp], al
$LN495@output_opc:

; 1190 :             }
; 1191 :         if (CodeInfo->basetype == T_RIP) tmp &= ~MOD_10;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+108]
	cmp	eax, 131				; 00000083H
	jne	SHORT $LN498@output_opc
	movzx	eax, BYTE PTR tmp$[rsp]
	btr	eax, 7
	mov	BYTE PTR tmp$[rsp], al
$LN498@output_opc:

; 1192 :         /* use only if TypleType is present  */
; 1193 :         if (CodeInfo->tuple){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+140]
	test	eax, eax
	je	$LN499@output_opc

; 1194 :           int index = -1;

	mov	DWORD PTR index$3[rsp], -1

; 1195 :           int d;
; 1196 :           if ((CodeInfo->opnd[OPND1].type & OP_M_ANY) &&

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, -8388608				; ffffffffff800000H
	test	eax, eax
	je	SHORT $LN500@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], -1
	je	SHORT $LN500@output_opc

; 1197 :             (CodeInfo->opnd[OPND1].data32l != -1))  index = OPND1;

	mov	DWORD PTR index$3[rsp], 0
	jmp	SHORT $LN501@output_opc
$LN500@output_opc:

; 1198 :           else if ((CodeInfo->opnd[OPND2].type & OP_M_ANY) &&

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, -8388608				; ffffffffff800000H
	test	eax, eax
	je	SHORT $LN502@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], -1
	je	SHORT $LN502@output_opc

; 1199 :             (CodeInfo->opnd[OPND1].data32l != -1))
; 1200 :             index = OPND2;

	mov	DWORD PTR index$3[rsp], 1
$LN502@output_opc:
$LN501@output_opc:

; 1201 :           if ((index != -1) && ((Check4CompDisp8(CodeInfo, &comprdsp, &d, CodeInfo->opnd[index].data32l)) && comprdsp)){

	cmp	DWORD PTR index$3[rsp], -1
	je	SHORT $LN503@output_opc
	movsxd	rax, DWORD PTR index$3[rsp]
	imul	rax, rax, 24
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	r9d, DWORD PTR [rcx+rax+40]
	lea	r8, QWORD PTR d$8[rsp]
	lea	rdx, QWORD PTR comprdsp$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	Check4CompDisp8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN503@output_opc
	movsx	eax, BYTE PTR comprdsp$[rsp]
	test	eax, eax
	je	SHORT $LN503@output_opc

; 1202 :             CodeInfo->opnd[index].data32l = comprdsp;

	movsxd	rax, DWORD PTR index$3[rsp]
	imul	rax, rax, 24
	movsx	ecx, BYTE PTR comprdsp$[rsp]
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rdx+rax+40], ecx

; 1203 :             tmp &= ~MOD_10;     /* if        mod = 10, r/m = 100, s-i-b is present */

	movzx	eax, BYTE PTR tmp$[rsp]
	btr	eax, 7
	mov	BYTE PTR tmp$[rsp], al

; 1204 :             tmp |= MOD_01;      /* change to mod = 01, r/m = 100, s-i-b is present */

	movzx	eax, BYTE PTR tmp$[rsp]
	or	eax, 64					; 00000040H
	mov	BYTE PTR tmp$[rsp], al

; 1205 :           }

	jmp	$LN504@output_opc
$LN503@output_opc:

; 1206 :           else if (CodeInfo->opnd[OPND2].type == OP_I8 ){

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 131072		; 00020000H
	jne	$LN505@output_opc

; 1207 :             if ((CodeInfo->token >= T_VPSLLW) && (CodeInfo->token <= T_VPSRLQ) ||
; 1208 :               (CodeInfo->token == T_VRNDSCALEPD) || (CodeInfo->token == T_VRNDSCALEPS)||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2044		; 000007fcH
	jl	SHORT $LN509@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2051		; 00000803H
	jle	SHORT $LN508@output_opc
$LN509@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1615		; 0000064fH
	je	SHORT $LN508@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1616		; 00000650H
	je	SHORT $LN508@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1534		; 000005feH
	jl	$LN507@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1551		; 0000060fH
	jg	$LN507@output_opc
$LN508@output_opc:

; 1209 :               (CodeInfo->token >= T_VPSLLVD) && (CodeInfo->token <= T_VPSRLVW)){
; 1210 :               if ((CodeInfo->vexconst) && ((Check4CompDisp8(CodeInfo, &comprdsp, &d, CodeInfo->vexconst)) && comprdsp)){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+124], 0
	je	$LN510@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	r9d, DWORD PTR [rax+124]
	lea	r8, QWORD PTR d$8[rsp]
	lea	rdx, QWORD PTR comprdsp$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	Check4CompDisp8
	movzx	eax, al
	test	eax, eax
	je	$LN510@output_opc
	movsx	eax, BYTE PTR comprdsp$[rsp]
	test	eax, eax
	je	$LN510@output_opc

; 1211 :                 CodeInfo->opnd[OPND1].data32l = comprdsp;                

	mov	eax, 24
	imul	rax, rax, 0
	movsx	ecx, BYTE PTR comprdsp$[rsp]
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	DWORD PTR [rdx+rax+40], ecx

; 1212 :                 tmp &= ~MOD_10;     /* if        mod = 10, r/m = 100, s-i-b is present */

	movzx	eax, BYTE PTR tmp$[rsp]
	btr	eax, 7
	mov	BYTE PTR tmp$[rsp], al

; 1213 :                 tmp |= MOD_01;      /* change to mod = 01, r/m = 100, s-i-b is present */

	movzx	eax, BYTE PTR tmp$[rsp]
	or	eax, 64					; 00000040H
	mov	BYTE PTR tmp$[rsp], al

; 1214 :                 if ((CodeInfo->token == T_VRNDSCALEPD) || (CodeInfo->token == T_VRNDSCALEPS)){                   

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1615		; 0000064fH
	je	SHORT $LN513@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1616		; 00000650H
	jne	SHORT $LN512@output_opc
$LN513@output_opc:

; 1215 :                      c = CodeInfo->reg2;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	mov	BYTE PTR c$[rsp], al

; 1216 :                      if (c > 15) c -= 16;

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 15
	jle	SHORT $LN514@output_opc
	movzx	eax, BYTE PTR c$[rsp]
	sub	eax, 16
	mov	BYTE PTR c$[rsp], al
$LN514@output_opc:

; 1217 :                      if (c > 7) c -= 8;

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 7
	jle	SHORT $LN515@output_opc
	movzx	eax, BYTE PTR c$[rsp]
	sub	eax, 8
	mov	BYTE PTR c$[rsp], al
$LN515@output_opc:

; 1218 :                      tmp |= c;

	movzx	eax, BYTE PTR c$[rsp]
	movzx	ecx, BYTE PTR tmp$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR tmp$[rsp], al
$LN512@output_opc:

; 1219 :                  }
; 1220 :               }

	jmp	$LN511@output_opc
$LN510@output_opc:

; 1221 :               else{
; 1222 :                 CodeInfo->tuple = 0;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 0

; 1223 :                 if (CodeInfo->indexreg != 0xff){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+112]
	cmp	eax, 255				; 000000ffH
	je	$LN516@output_opc

; 1224 :                   tmp &= ~NOT_BIT_345;

	movzx	eax, BYTE PTR tmp$[rsp]
	and	eax, -200				; ffffffffffffff38H
	mov	BYTE PTR tmp$[rsp], al

; 1225 :                   tmp &= ~BIT_012;

	movzx	eax, BYTE PTR tmp$[rsp]
	and	eax, -8
	mov	BYTE PTR tmp$[rsp], al

; 1226 :                   tmp |= MOD_10;

	movzx	eax, BYTE PTR tmp$[rsp]
	bts	eax, 7
	mov	BYTE PTR tmp$[rsp], al

; 1227 :                   tmp |= RM_SIB;

	movzx	eax, BYTE PTR tmp$[rsp]
	or	eax, 4
	mov	BYTE PTR tmp$[rsp], al

; 1228 :                   c = CodeInfo->indexreg;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+112]
	mov	BYTE PTR c$[rsp], al

; 1229 :                   c = (c &= 0x7) << 3;

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 7
	mov	BYTE PTR c$[rsp], al
	movzx	eax, BYTE PTR c$[rsp]
	shl	eax, 3
	mov	BYTE PTR c$[rsp], al

; 1230 :                   CodeInfo->sib |= c;

	movzx	eax, BYTE PTR c$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+105]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+105], al

; 1231 :                   c = CodeInfo->basereg;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	mov	BYTE PTR c$[rsp], al

; 1232 :                   c &= 0x7;

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 7
	mov	BYTE PTR c$[rsp], al

; 1233 :                   CodeInfo->sib |= c;

	movzx	eax, BYTE PTR c$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+105]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+105], al

; 1234 :                   CodeInfo->rm_byte = tmp;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR tmp$[rsp]
	mov	BYTE PTR [rax+104], cl

; 1235 :                   CodeInfo->sib |= MOD_11;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+105]
	or	eax, 192				; 000000c0H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+105], al

; 1236 :                   CodeInfo->opnd[OPND1].data32l = CodeInfo->vexconst;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rdx+124]
	mov	DWORD PTR [rcx+rax+40], edx

; 1237 :                 }

	jmp	$LN517@output_opc
$LN516@output_opc:

; 1238 :                 else {
; 1239 :                   if ((CodeInfo->opnd[OPND1].type == OP_R64) || (CodeInfo->opnd[OPND1].type == OP_RAX) ||
; 1240 :                     (CodeInfo->opnd[OPND1].type == OP_R32) || (CodeInfo->opnd[OPND1].type == OP_EAX)){

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 8
	je	SHORT $LN520@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 520		; 00000208H
	je	SHORT $LN520@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 4
	je	SHORT $LN520@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 516		; 00000204H
	jne	SHORT $LN518@output_opc
$LN520@output_opc:

; 1241 :                     tmp &= ~MOD_11;

	movzx	eax, BYTE PTR tmp$[rsp]
	and	eax, -193				; ffffffffffffff3fH
	mov	BYTE PTR tmp$[rsp], al

; 1242 :                     if (CodeInfo->vexconst){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+124], 0
	je	SHORT $LN521@output_opc

; 1243 :                       tmp |= MOD_10;

	movzx	eax, BYTE PTR tmp$[rsp]
	bts	eax, 7
	mov	BYTE PTR tmp$[rsp], al

; 1244 :                       CodeInfo->rm_byte = tmp;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR tmp$[rsp]
	mov	BYTE PTR [rax+104], cl

; 1245 :                       CodeInfo->opnd[OPND1].data32l = CodeInfo->vexconst;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rdx+124]
	mov	DWORD PTR [rcx+rax+40], edx
$LN521@output_opc:

; 1246 :                     }
; 1247 :                   }

	jmp	$LN519@output_opc
$LN518@output_opc:

; 1248 :                   else if ((CodeInfo->opnd[OPND1].type == OP_XMM) || (CodeInfo->opnd[OPND1].type == OP_YMM) ||

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 32		; 00000020H
	je	SHORT $LN523@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 128		; 00000080H
	je	SHORT $LN523@output_opc
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+32], 256		; 00000100H
	jne	$LN522@output_opc
$LN523@output_opc:

; 1249 :                     (CodeInfo->opnd[OPND1].type == OP_ZMM)){
; 1250 :                 CodeInfo->tuple = 0;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 0

; 1251 :                 if (CodeInfo->vexconst){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+124], 0
	je	$LN524@output_opc

; 1252 :                   tmp &= ~NOT_BIT_345;

	movzx	eax, BYTE PTR tmp$[rsp]
	and	eax, -200				; ffffffffffffff38H
	mov	BYTE PTR tmp$[rsp], al

; 1253 :                   tmp &= ~BIT_012;

	movzx	eax, BYTE PTR tmp$[rsp]
	and	eax, -8
	mov	BYTE PTR tmp$[rsp], al

; 1254 :                   tmp |= MOD_10;

	movzx	eax, BYTE PTR tmp$[rsp]
	bts	eax, 7
	mov	BYTE PTR tmp$[rsp], al

; 1255 :                   tmp |= RM_SIB;

	movzx	eax, BYTE PTR tmp$[rsp]
	or	eax, 4
	mov	BYTE PTR tmp$[rsp], al

; 1256 :                   if (CodeInfo->indexreg != 0xFF){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+112]
	cmp	eax, 255				; 000000ffH
	je	$LN526@output_opc

; 1257 :                     c = CodeInfo->indexreg;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+112]
	mov	BYTE PTR c$[rsp], al

; 1258 :                     c = (c &= 0x07) << 3;

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 7
	mov	BYTE PTR c$[rsp], al
	movzx	eax, BYTE PTR c$[rsp]
	shl	eax, 3
	mov	BYTE PTR c$[rsp], al

; 1259 :                     CodeInfo->sib |= c;

	movzx	eax, BYTE PTR c$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+105]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+105], al

; 1260 :                     c = CodeInfo->basereg;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	mov	BYTE PTR c$[rsp], al

; 1261 :                     c &= 0x7;

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 7
	mov	BYTE PTR c$[rsp], al

; 1262 :                     CodeInfo->sib |= c;

	movzx	eax, BYTE PTR c$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+105]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+105], al

; 1263 :                     CodeInfo->sib = 0xf0;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+105], 240			; 000000f0H

; 1264 :                   }

	jmp	SHORT $LN527@output_opc
$LN526@output_opc:

; 1265 :                   else{
; 1266 :                     tmp &= ~0x07;

	movzx	eax, BYTE PTR tmp$[rsp]
	and	eax, -8
	mov	BYTE PTR tmp$[rsp], al

; 1267 :                     tmp |= (CodeInfo->reg2 & 0x07);

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	and	eax, 7
	movzx	ecx, BYTE PTR tmp$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR tmp$[rsp], al
$LN527@output_opc:

; 1268 :                   }
; 1269 :                   CodeInfo->rm_byte = tmp;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR tmp$[rsp]
	mov	BYTE PTR [rax+104], cl

; 1270 :                   CodeInfo->opnd[OPND1].data32l = CodeInfo->vexconst;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rdx+124]
	mov	DWORD PTR [rcx+rax+40], edx

; 1271 :                 }

	jmp	$LN525@output_opc
$LN524@output_opc:

; 1272 :                    else {
; 1273 :                      if ((CodeInfo->r2type)&&((CodeInfo->token == T_VRNDSCALEPD) || (CodeInfo->token == T_VRNDSCALEPS)))

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+120], 0
	je	SHORT $LN528@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1615		; 0000064fH
	je	SHORT $LN529@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1616		; 00000650H
	jne	SHORT $LN528@output_opc
$LN529@output_opc:

; 1274 :                        tmp &= ~0xc0;

	movzx	eax, BYTE PTR tmp$[rsp]
	and	eax, -193				; ffffffffffffff3fH
	mov	BYTE PTR tmp$[rsp], al
$LN528@output_opc:

; 1275 :                      if ((CodeInfo->token >= T_VPSLLW) && (CodeInfo->token <= T_VPSRLQ) ||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2044		; 000007fcH
	jl	SHORT $LN532@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2051		; 00000803H
	jle	SHORT $LN531@output_opc
$LN532@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1534		; 000005feH
	jl	SHORT $LN530@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1551		; 0000060fH
	jg	SHORT $LN530@output_opc
$LN531@output_opc:

; 1276 :                        (CodeInfo->token >= T_VPSLLVD) && (CodeInfo->token <= T_VPSRLVW)) {
; 1277 :                        tmp &= ~7;

	movzx	eax, BYTE PTR tmp$[rsp]
	and	eax, -8
	mov	BYTE PTR tmp$[rsp], al

; 1278 : 					   if ((CodeInfo->r2type == OP_R64) || (CodeInfo->r2type == OP_R32)) tmp &= ~0xc0;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+120], 8
	je	SHORT $LN534@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+120], 4
	jne	SHORT $LN533@output_opc
$LN534@output_opc:
	movzx	eax, BYTE PTR tmp$[rsp]
	and	eax, -193				; ffffffffffffff3fH
	mov	BYTE PTR tmp$[rsp], al
$LN533@output_opc:
$LN530@output_opc:

; 1279 :                      }
; 1280 :                        c = CodeInfo->reg2;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+110]
	mov	BYTE PTR c$[rsp], al

; 1281 :                        if (c > 15) c -= 16;

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 15
	jle	SHORT $LN535@output_opc
	movzx	eax, BYTE PTR c$[rsp]
	sub	eax, 16
	mov	BYTE PTR c$[rsp], al
$LN535@output_opc:

; 1282 :                        if (c > 7) c -= 8;

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 7
	jle	SHORT $LN536@output_opc
	movzx	eax, BYTE PTR c$[rsp]
	sub	eax, 8
	mov	BYTE PTR c$[rsp], al
$LN536@output_opc:

; 1283 :                        tmp |= c;

	movzx	eax, BYTE PTR c$[rsp]
	movzx	ecx, BYTE PTR tmp$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR tmp$[rsp], al
$LN525@output_opc:
$LN522@output_opc:
$LN519@output_opc:
$LN517@output_opc:
$LN511@output_opc:
$LN507@output_opc:

; 1284 :                     }
; 1285 :                   }
; 1286 :                 }
; 1287 :               }
; 1288 :             }
; 1289 :           }

	jmp	SHORT $LN506@output_opc
$LN505@output_opc:

; 1290 :           else{
; 1291 :             CodeInfo->tuple = 0;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 0

; 1292 :            if (CodeInfo->token >= T_VPGATHERDD && CodeInfo->token <= T_VSCATTERQPD){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1345		; 00000541H
	jl	SHORT $LN537@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1360		; 00000550H
	jg	SHORT $LN537@output_opc

; 1293 :               tmp &= ~0xc0;

	movzx	eax, BYTE PTR tmp$[rsp]
	and	eax, -193				; ffffffffffffff3fH
	mov	BYTE PTR tmp$[rsp], al

; 1294 :               tmp |= MOD_10;

	movzx	eax, BYTE PTR tmp$[rsp]
	bts	eax, 7
	mov	BYTE PTR tmp$[rsp], al

; 1295 :               CodeInfo->rm_byte = tmp;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR tmp$[rsp]
	mov	BYTE PTR [rax+104], cl
$LN537@output_opc:
$LN506@output_opc:
$LN504@output_opc:
$LN499@output_opc:

; 1296 :             }
; 1297 :           }
; 1298 :         }
; 1299 :         if (CodeInfo->token == T_VCVTPS2PH){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1433		; 00000599H
	jne	$LN538@output_opc

; 1300 :           if (!comprdsp) CodeInfo->tuple = 0;

	movsx	eax, BYTE PTR comprdsp$[rsp]
	test	eax, eax
	jne	SHORT $LN539@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+140], 0
$LN539@output_opc:

; 1301 :           if (CodeInfo->indexreg != 0xFF){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+112]
	cmp	eax, 255				; 000000ffH
	je	$LN540@output_opc

; 1302 :             c = CodeInfo->indexreg;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+112]
	mov	BYTE PTR c$[rsp], al

; 1303 :             c = (c &= 0x07) << 3;

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 7
	mov	BYTE PTR c$[rsp], al
	movzx	eax, BYTE PTR c$[rsp]
	shl	eax, 3
	mov	BYTE PTR c$[rsp], al

; 1304 :             CodeInfo->sib |= c;

	movzx	eax, BYTE PTR c$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+105]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+105], al

; 1305 :             c = CodeInfo->basereg;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	mov	BYTE PTR c$[rsp], al

; 1306 :             c &= 0x7;

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 7
	mov	BYTE PTR c$[rsp], al

; 1307 :             CodeInfo->sib |= c;

	movzx	eax, BYTE PTR c$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+105]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rcx+105], al

; 1308 :             CodeInfo->sib = 0xf0;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	BYTE PTR [rax+105], 240			; 000000f0H

; 1309 :             tmp |= RM_SIB;

	movzx	eax, BYTE PTR tmp$[rsp]
	or	eax, 4
	mov	BYTE PTR tmp$[rsp], al
$LN540@output_opc:

; 1310 :           }
; 1311 :           CodeInfo->rm_byte = tmp;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR tmp$[rsp]
	mov	BYTE PTR [rax+104], cl
$LN538@output_opc:

; 1312 :         }
; 1313 :         if (CodeInfo->token == T_BLSMSK){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1681		; 00000691H
	jne	SHORT $LN541@output_opc

; 1314 :               tmp &= ~0x38;

	movzx	eax, BYTE PTR tmp$[rsp]
	and	eax, -57				; ffffffffffffffc7H
	mov	BYTE PTR tmp$[rsp], al

; 1315 :               tmp |= 0x10;

	movzx	eax, BYTE PTR tmp$[rsp]
	or	eax, 16
	mov	BYTE PTR tmp$[rsp], al
$LN541@output_opc:

; 1316 :             }
; 1317 :         if (CodeInfo->token == T_BLSR){

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1682		; 00000692H
	jne	SHORT $LN542@output_opc

; 1318 :               tmp &= ~0x38;

	movzx	eax, BYTE PTR tmp$[rsp]
	and	eax, -57				; ffffffffffffffc7H
	mov	BYTE PTR tmp$[rsp], al

; 1319 :               tmp |= 0x08;

	movzx	eax, BYTE PTR tmp$[rsp]
	or	eax, 8
	mov	BYTE PTR tmp$[rsp], al
$LN542@output_opc:

; 1320 :             }
; 1321 :         OutputCodeByte( tmp );

	movzx	ecx, BYTE PTR tmp$[rsp]
	call	OutputByte

; 1322 :         if( ( CodeInfo->Ofssize == USE16 && CodeInfo->prefix.adrsiz == 0 ) ||

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	test	eax, eax
	jne	SHORT $LN545@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN544@output_opc
$LN545@output_opc:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+106]
	cmp	eax, 1
	jne	SHORT $LN543@output_opc
	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN543@output_opc
$LN544@output_opc:

; 1323 :            ( CodeInfo->Ofssize == USE32 && CodeInfo->prefix.adrsiz == 1 ) )
; 1324 :             return; /* no SIB for 16bit */

	jmp	SHORT $LN1@output_opc
$LN543@output_opc:

; 1325 : 
; 1326 :         switch ( tmp & NOT_BIT_345 ) {

	movzx	eax, BYTE PTR tmp$[rsp]
	and	eax, 199				; 000000c7H
	mov	DWORD PTR tv3208[rsp], eax
	cmp	DWORD PTR tv3208[rsp], 4
	je	SHORT $LN546@output_opc
	cmp	DWORD PTR tv3208[rsp], 68		; 00000044H
	je	SHORT $LN546@output_opc
	cmp	DWORD PTR tv3208[rsp], 132		; 00000084H
	je	SHORT $LN546@output_opc
	jmp	SHORT $LN19@output_opc
$LN546@output_opc:

; 1327 :         case 0x04: /* mod = 00, r/m = 100, s-i-b is present */
; 1328 :         case 0x44: /* mod = 01, r/m = 100, s-i-b is present */
; 1329 :         case 0x84: /* mod = 10, r/m = 100, s-i-b is present */
; 1330 :             /* emit SIB byte; bits 7-6 = Scale, bits 5-3 = Index, bits 2-0 = Base */
; 1331 :           OutputCodeByte( CodeInfo->sib );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rax+105]
	call	OutputByte
$LN19@output_opc:
$LN14@output_opc:
$LN1@output_opc:

; 1332 :         }
; 1333 :     }
; 1334 : 
; 1335 :     return;
; 1336 : }

	add	rsp, 184				; 000000b8H
	ret	0
	npad	1
$LN564@output_opc:
	DD	$LN47@output_opc
	DD	$LN49@output_opc
	DD	$LN51@output_opc
	DD	$LN53@output_opc
	DD	$LN56@output_opc
	DD	$LN55@output_opc
	DD	$LN2@output_opc
$LN563@output_opc:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	4
	npad	2
$LN562@output_opc:
	DD	$LN64@output_opc
	DD	$LN62@output_opc
	DD	$LN63@output_opc
	DD	$LN4@output_opc
$LN561@output_opc:
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	2
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	1
	DB	2
	npad	1
$LN560@output_opc:
	DD	$LN75@output_opc
	DD	$LN77@output_opc
	DD	$LN76@output_opc
	DD	$LN6@output_opc
	DD	$LN6@output_opc
	DD	$LN6@output_opc
	DD	$LN6@output_opc
	DD	$LN75@output_opc
	DD	$LN75@output_opc
	DD	$LN77@output_opc
	DD	$LN76@output_opc
$LN559@output_opc:
	DD	$LN95@output_opc
	DD	$LN96@output_opc
	DD	$LN95@output_opc
	DD	$LN96@output_opc
	DD	$LN95@output_opc
	DD	$LN95@output_opc
	DD	$LN96@output_opc
$LN558@output_opc:
	DD	$LN471@output_opc
	DD	$LN12@output_opc
	DD	$LN12@output_opc
	DD	$LN12@output_opc
	DD	$LN12@output_opc
	DD	$LN12@output_opc
	DD	$LN472@output_opc
	DD	$LN473@output_opc
	DD	$LN472@output_opc
	DD	$LN473@output_opc
	DD	$LN472@output_opc
output_opc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\codegen.c
_TEXT	SEGMENT
n$ = 32
disp8$ = 36
disp32$ = 40
tv73 = 44
CodeInfo$ = 64
comprdsp$ = 72
d$ = 80
disp$ = 88
Check4CompDisp8 PROC

; 129  : {

$LN5:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 130  :     int_32 disp32           = disp;

	mov	eax, DWORD PTR disp$[rsp]
	mov	DWORD PTR disp32$[rsp], eax

; 131  :     uint_8 n;
; 132  :     int_32 disp8;
; 133  : 
; 134  :     n = GetByteDisp(CodeInfo);

	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	GetByteDisp
	mov	BYTE PTR n$[rsp], al

; 135  :     *d = n;

	movzx	eax, BYTE PTR n$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	mov	DWORD PTR [rcx], eax

; 136  :     if (n && !(disp32 & (n - 1))) {

	movzx	eax, BYTE PTR n$[rsp]
	test	eax, eax
	je	SHORT $LN2@Check4Comp
	movzx	eax, BYTE PTR n$[rsp]
	dec	eax
	mov	ecx, DWORD PTR disp32$[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN2@Check4Comp

; 137  :         disp8 = disp32 / n;

	movzx	eax, BYTE PTR n$[rsp]
	mov	DWORD PTR tv73[rsp], eax
	mov	eax, DWORD PTR disp32$[rsp]
	cdq
	mov	ecx, DWORD PTR tv73[rsp]
	idiv	ecx
	mov	DWORD PTR disp8$[rsp], eax

; 138  :         /* if it fits in Disp8 */
; 139  :         if (disp8 >= -128 && disp8 <= 127) {

	cmp	DWORD PTR disp8$[rsp], -128		; ffffffffffffff80H
	jl	SHORT $LN3@Check4Comp
	cmp	DWORD PTR disp8$[rsp], 127		; 0000007fH
	jg	SHORT $LN3@Check4Comp

; 140  :             *comprdsp = disp8;

	mov	rax, QWORD PTR comprdsp$[rsp]
	movzx	ecx, BYTE PTR disp8$[rsp]
	mov	BYTE PTR [rax], cl

; 141  :             return TRUE;

	mov	al, 1
	jmp	SHORT $LN1@Check4Comp
$LN3@Check4Comp:
$LN2@Check4Comp:

; 142  :         }
; 143  :     }
; 144  :     *comprdsp = 0;

	mov	rax, QWORD PTR comprdsp$[rsp]
	mov	BYTE PTR [rax], 0

; 145  :     return FALSE;

	xor	al, al
$LN1@Check4Comp:

; 146  : }

	add	rsp, 56					; 00000038H
	ret	0
Check4CompDisp8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\codegen.c
_TEXT	SEGMENT
n$ = 0
vctln$ = 1
evexW$ = 2
evexB$ = 3
tuple$ = 4
duparr$ = 8
tv83 = 12
tv172 = 16
tv175 = 20
tv229 = 24
tv238 = 28
tv243 = 32
hvarr$ = 36
fvarr$ = 48
__$ArrayPad$ = 64
CodeInfo$ = 96
GetByteDisp PROC

; 67   : {

$LN23:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 68   :     const uint_8 fvarr[2][2][3] = {{{16, 32, 64}, {4, 4, 4}},    // Full Vector (FV)

	mov	BYTE PTR fvarr$[rsp], 16
	mov	BYTE PTR fvarr$[rsp+1], 32		; 00000020H
	mov	BYTE PTR fvarr$[rsp+2], 64		; 00000040H
	mov	BYTE PTR fvarr$[rsp+3], 4
	mov	BYTE PTR fvarr$[rsp+4], 4
	mov	BYTE PTR fvarr$[rsp+5], 4
	mov	BYTE PTR fvarr$[rsp+6], 16
	mov	BYTE PTR fvarr$[rsp+7], 32		; 00000020H
	mov	BYTE PTR fvarr$[rsp+8], 64		; 00000040H
	mov	BYTE PTR fvarr$[rsp+9], 8
	mov	BYTE PTR fvarr$[rsp+10], 8
	mov	BYTE PTR fvarr$[rsp+11], 8

; 69   :                                   {{16, 32, 64}, {8, 8, 8}}};
; 70   :     const uint_8 hvarr[2][3]    =  {{8, 16, 32}, {4, 4, 4}};     // Half Vector (HV) 

	mov	BYTE PTR hvarr$[rsp], 8
	mov	BYTE PTR hvarr$[rsp+1], 16
	mov	BYTE PTR hvarr$[rsp+2], 32		; 00000020H
	mov	BYTE PTR hvarr$[rsp+3], 4
	mov	BYTE PTR hvarr$[rsp+4], 4
	mov	BYTE PTR hvarr$[rsp+5], 4

; 71   :     const uint_8 duparr[3]      =   {8, 32, 64};                 // VMOVDDUP    (DUP)

	mov	BYTE PTR duparr$[rsp], 8
	mov	BYTE PTR duparr$[rsp+1], 32		; 00000020H
	mov	BYTE PTR duparr$[rsp+2], 64		; 00000040H

; 72   :                                                   //RXBR00MM
; 73   :     uint_8 n = 0;

	mov	BYTE PTR n$[rsp], 0

; 74   :     bool evexW            = (CodeInfo->evex_p1 & EVEX_P1WMASK) >> 7;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+138]
	and	eax, 128				; 00000080H
	sar	eax, 7
	mov	BYTE PTR evexW$[rsp], al

; 75   :     enum ttypes   tuple   = CodeInfo->pinstr->prefix & 0x1F;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+8]
	and	eax, 31
	mov	DWORD PTR tuple$[rsp], eax

; 76   :     bool evexB            = (CodeInfo->evex_p2 & EVEX_P2BMASK) >> 4;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, 16
	sar	eax, 4
	mov	BYTE PTR evexB$[rsp], al

; 77   :     uint_8  vctln         = (CodeInfo->evex_p2 & EVEX_P2LLMASK) >> 5;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	and	eax, 96					; 00000060H
	sar	eax, 5
	mov	BYTE PTR vctln$[rsp], al

; 78   :     
; 79   : 
; 80   :     switch(tuple) {

	mov	eax, DWORD PTR tuple$[rsp]
	mov	DWORD PTR tv83[rsp], eax
	mov	eax, DWORD PTR tv83[rsp]
	dec	eax
	mov	DWORD PTR tv83[rsp], eax
	cmp	DWORD PTR tv83[rsp], 19
	ja	$LN16@GetByteDis
	movsxd	rax, DWORD PTR tv83[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN22@GetByteDis[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@GetByteDis:

; 81   :     case FV:         // Full Vector 
; 82   :         n = fvarr[evexW][evexB][vctln];

	movzx	eax, BYTE PTR evexW$[rsp]
	imul	rax, rax, 6
	lea	rax, QWORD PTR fvarr$[rsp+rax]
	movzx	ecx, BYTE PTR evexB$[rsp]
	imul	rcx, rcx, 3
	add	rax, rcx
	movzx	ecx, BYTE PTR vctln$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	mov	BYTE PTR n$[rsp], al

; 83   :         break;

	jmp	$LN2@GetByteDis
$LN5@GetByteDis:

; 84   :     case HV:        // Half Vector 
; 85   :         n = hvarr[evexB][vctln];

	movzx	eax, BYTE PTR evexB$[rsp]
	imul	rax, rax, 3
	lea	rax, QWORD PTR hvarr$[rsp+rax]
	movzx	ecx, BYTE PTR vctln$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	mov	BYTE PTR n$[rsp], al

; 86   :         break;

	jmp	$LN2@GetByteDis
$LN6@GetByteDis:

; 87   :     case FVM:       // Full Vector Mem
; 88   :         n = 1 << (vctln + 4);

	movzx	eax, BYTE PTR vctln$[rsp]
	add	eax, 4
	mov	ecx, 1
	mov	DWORD PTR tv229[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv229[rsp]
	shl	eax, cl
	mov	BYTE PTR n$[rsp], al

; 89   :         break;

	jmp	$LN2@GetByteDis
$LN7@GetByteDis:

; 90   :     case T1S8:      // Tuple1 Scalar
; 91   :     case T1S16: 
; 92   :         n = tuple - T1S8 + 1;

	mov	eax, DWORD PTR tuple$[rsp]
	sub	eax, 3
	mov	BYTE PTR n$[rsp], al

; 93   :         break;

	jmp	$LN2@GetByteDis
$LN8@GetByteDis:

; 94   :     case T1S:
; 95   :         n = evexW ? 8 : 4;

	movzx	eax, BYTE PTR evexW$[rsp]
	test	eax, eax
	je	SHORT $LN18@GetByteDis
	mov	DWORD PTR tv172[rsp], 8
	jmp	SHORT $LN19@GetByteDis
$LN18@GetByteDis:
	mov	DWORD PTR tv172[rsp], 4
$LN19@GetByteDis:
	movzx	eax, BYTE PTR tv172[rsp]
	mov	BYTE PTR n$[rsp], al

; 96   :         break;

	jmp	$LN2@GetByteDis
$LN9@GetByteDis:

; 97   :     case T1F32:    // Tuple1 Fixed
; 98   :     case T1F64:
; 99   :         n = (tuple == T1F32 ? 4 : 8);

	cmp	DWORD PTR tuple$[rsp], 7
	jne	SHORT $LN20@GetByteDis
	mov	DWORD PTR tv175[rsp], 4
	jmp	SHORT $LN21@GetByteDis
$LN20@GetByteDis:
	mov	DWORD PTR tv175[rsp], 8
$LN21@GetByteDis:
	movzx	eax, BYTE PTR tv175[rsp]
	mov	BYTE PTR n$[rsp], al

; 100  :         break;

	jmp	SHORT $LN2@GetByteDis
$LN10@GetByteDis:

; 101  :     case T2:       // Tuple2
; 102  :     case T4:       // Tuple4
; 103  :     case T8:       // Tuple8
; 104  :         if (vctln + 7 <= (evexW + 5) + (tuple - T2 + 1))

	movzx	eax, BYTE PTR vctln$[rsp]
	add	eax, 7
	movzx	ecx, BYTE PTR evexW$[rsp]
	mov	edx, DWORD PTR tuple$[rsp]
	lea	ecx, DWORD PTR [rcx+rdx-5]
	cmp	eax, ecx
	jg	SHORT $LN11@GetByteDis

; 105  :             n = 0;

	mov	BYTE PTR n$[rsp], 0
	jmp	SHORT $LN12@GetByteDis
$LN11@GetByteDis:

; 106  :         else
; 107  :             n = 1 << (tuple - T2 + evexW + 3);

	movzx	eax, BYTE PTR evexW$[rsp]
	mov	ecx, DWORD PTR tuple$[rsp]
	lea	eax, DWORD PTR [rcx+rax-8]
	mov	ecx, 1
	mov	DWORD PTR tv238[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv238[rsp]
	shl	eax, cl
	mov	BYTE PTR n$[rsp], al
$LN12@GetByteDis:

; 108  :         break;

	jmp	SHORT $LN2@GetByteDis
$LN13@GetByteDis:

; 109  :     case HVM:      // Half Mem
; 110  :     case QVM:      // QuarterMem
; 111  :     case OVM:      // OctMem
; 112  :         n = 1 << (OVM - tuple + vctln + 1);

	mov	eax, 16
	sub	eax, DWORD PTR tuple$[rsp]
	movzx	ecx, BYTE PTR vctln$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	ecx, 1
	mov	DWORD PTR tv243[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv243[rsp]
	shl	eax, cl
	mov	BYTE PTR n$[rsp], al

; 113  :         break;

	jmp	SHORT $LN2@GetByteDis
$LN14@GetByteDis:

; 114  :     case T128:     // Mem128
; 115  :         n = 16;

	mov	BYTE PTR n$[rsp], 16

; 116  :         break;

	jmp	SHORT $LN2@GetByteDis
$LN15@GetByteDis:

; 117  :     case DUP:      // MOVDDUP
; 118  :         n = duparr[vctln];

	movzx	eax, BYTE PTR vctln$[rsp]
	movzx	eax, BYTE PTR duparr$[rsp+rax]
	mov	BYTE PTR n$[rsp], al
$LN16@GetByteDis:
$LN2@GetByteDis:

; 119  :         break;
; 120  : 
; 121  :     default:
; 122  :         break;
; 123  :     }
; 124  :     return n;

	movzx	eax, BYTE PTR n$[rsp]

; 125  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 88					; 00000058H
	ret	0
	npad	3
$LN22@GetByteDis:
	DD	$LN4@GetByteDis
	DD	$LN5@GetByteDis
	DD	$LN6@GetByteDis
	DD	$LN7@GetByteDis
	DD	$LN7@GetByteDis
	DD	$LN8@GetByteDis
	DD	$LN9@GetByteDis
	DD	$LN16@GetByteDis
	DD	$LN16@GetByteDis
	DD	$LN9@GetByteDis
	DD	$LN10@GetByteDis
	DD	$LN10@GetByteDis
	DD	$LN10@GetByteDis
	DD	$LN13@GetByteDis
	DD	$LN13@GetByteDis
	DD	$LN13@GetByteDis
	DD	$LN14@GetByteDis
	DD	$LN16@GetByteDis
	DD	$LN16@GetByteDis
	DD	$LN15@GetByteDis
GetByteDisp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\codegen.c
_TEXT	SEGMENT
opnd1$ = 80
retcode$ = 84
tv226 = 88
tbl_op1$ = 92
tv180 = 96
tv183 = 100
tv186 = 104
tv189 = 108
tv193 = 112
tv196 = 116
CodeInfo$ = 144
oldofs$ = 152
codegen	PROC

; 1891 : {

$LN39:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 1892 :     ret_code           retcode = ERROR;

	mov	DWORD PTR retcode$[rsp], -1

; 1893 :     enum operand_type  opnd1;
; 1894 :     enum operand_type  tbl_op1;
; 1895 :     /* privileged instructions ok? */
; 1896 :     if( ( CodeInfo->pinstr->cpu & P_PM ) > ( ModuleInfo.curr_cpu & P_PM ) ) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax+10]
	and	eax, 8
	mov	ecx, DWORD PTR ModuleInfo+392
	and	ecx, 8
	cmp	eax, ecx
	jle	SHORT $LN7@codegen

; 1897 :         EmitError( INSTRUCTION_OR_REGISTER_NOT_ACCEPTED_IN_CURRENT_CPU_MODE );

	mov	ecx, 30
	call	EmitError

; 1898 :         return( ERROR );

	mov	eax, -1
	jmp	$LN1@codegen
$LN7@codegen:

; 1899 :     }
; 1900 :     opnd1 = CodeInfo->opnd[OPND1].type;

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	mov	DWORD PTR opnd1$[rsp], eax

; 1901 :     /* if first operand is immediate data, set compatible flags */
; 1902 :     if( opnd1 & OP_I ) {

	mov	eax, DWORD PTR opnd1$[rsp]
	and	eax, 917504				; 000e0000H
	test	eax, eax
	je	SHORT $LN8@codegen

; 1903 :         if( opnd1 == OP_I8 ) {

	cmp	DWORD PTR opnd1$[rsp], 131072		; 00020000H
	jne	SHORT $LN9@codegen

; 1904 :             opnd1 = OP_IGE8;

	mov	DWORD PTR opnd1$[rsp], 917504		; 000e0000H
	jmp	SHORT $LN10@codegen
$LN9@codegen:

; 1905 :         } else if( opnd1 == OP_I16 ) {

	cmp	DWORD PTR opnd1$[rsp], 262144		; 00040000H
	jne	SHORT $LN11@codegen

; 1906 :             opnd1 = OP_IGE16;

	mov	DWORD PTR opnd1$[rsp], 786432		; 000c0000H
$LN11@codegen:
$LN10@codegen:
$LN8@codegen:

; 1907 :         }
; 1908 :     }
; 1909 : 
; 1910 : #if AVXSUPP 
; 1911 : 	if (CodeInfo->token >= VEX_START) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1296		; 00000510H
	jl	$LN12@codegen

; 1912 : 		if (vex_flags[CodeInfo->token - VEX_START] & VX_L) {

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 1296				; 00000510H
	cdqe
	lea	rcx, OFFSET FLAT:vex_flags
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 1
	test	eax, eax
	je	$LN13@codegen

; 1913 : 			if (opnd1 & (OP_K | OP_ZMM | OP_YMM | OP_M256 | OP_M512)) {

	mov	eax, DWORD PTR opnd1$[rsp]
	and	eax, 805306816				; 300001c0H
	test	eax, eax
	je	$LN14@codegen

; 1914 : 				if (CodeInfo->opnd[OPND2].type & OP_XMM && !(vex_flags[CodeInfo->token - VEX_START] & VX_HALF)) {

	mov	eax, 24
	imul	rax, rax, 1
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax+32]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN15@codegen
	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	eax, DWORD PTR [rax+24]
	sub	eax, 1296				; 00000510H
	cdqe
	lea	rcx, OFFSET FLAT:vex_flags
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN15@codegen

; 1915 : 					EmitErr(INVALID_INSTRUCTION_OPERANDS);

	mov	ecx, 49					; 00000031H
	call	EmitErr

; 1916 : 					return(ERROR);

	mov	eax, -1
	jmp	$LN1@codegen
$LN15@codegen:

; 1917 : 				}
; 1918 : 				if (opnd1 & OP_YMM || opnd1 & OP_K || opnd1 & OP_ZMM)

	mov	eax, DWORD PTR opnd1$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN18@codegen
	mov	eax, DWORD PTR opnd1$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	SHORT $LN18@codegen
	mov	eax, DWORD PTR opnd1$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN16@codegen
$LN18@codegen:

; 1919 : 					opnd1 |= OP_XMM;

	mov	eax, DWORD PTR opnd1$[rsp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR opnd1$[rsp], eax
	jmp	SHORT $LN17@codegen
$LN16@codegen:

; 1920 : 				else
; 1921 : 					opnd1 |= OP_M128;

	mov	eax, DWORD PTR opnd1$[rsp]
	bts	eax, 27
	mov	DWORD PTR opnd1$[rsp], eax
$LN17@codegen:
$LN14@codegen:
$LN13@codegen:

; 1922 : 			}
; 1923 : 		}
; 1924 : 		/* Here is probably possible to find better solution     */
; 1925 : 
; 1926 :       if ((CodeInfo->token >= T_VCMPPD && CodeInfo->token <= T_VCMPTRUE_USSS) ||     //1754        1885                  
; 1927 :         (CodeInfo->token >= T_VPCMPD) && (CodeInfo->token <= T_VINSERTI64x4) ||          //1446        1635         
; 1928 :         (CodeInfo->token >= T_VPMOVSXBD) && (CodeInfo->token <= T_VUNPCKLPS) ||        //2007        2077            
; 1929 :         (CodeInfo->token >= T_VPBROADCASTB && CodeInfo->token <= T_VBROADCASTF64x4) || //1294        1306
; 1930 :         (CodeInfo->token == T_VCVTPS2PH) || (CodeInfo->token == T_VCVTPH2PS) ||          //1428        1427
; 1931 :         (CodeInfo->token == T_VMOVDDUP) ||                                             //1339        
; 1932 :         (CodeInfo->token >= T_VDBPSADBW) && (CodeInfo->token <= T_VFPCLASSSS) ||         //1642        1646

	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1762		; 000006e2H
	jl	SHORT $LN21@codegen
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1893		; 00000765H
	jle	$LN20@codegen
$LN21@codegen:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1451		; 000005abH
	jl	SHORT $LN22@codegen
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1640		; 00000668H
	jle	$LN20@codegen
$LN22@codegen:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2015		; 000007dfH
	jl	SHORT $LN23@codegen
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 2085		; 00000825H
	jle	$LN20@codegen
$LN23@codegen:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1299		; 00000513H
	jl	SHORT $LN24@codegen
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1311		; 0000051fH
	jle	SHORT $LN20@codegen
$LN24@codegen:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1433		; 00000599H
	je	SHORT $LN20@codegen
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1432		; 00000598H
	je	SHORT $LN20@codegen
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1344		; 00000540H
	je	SHORT $LN20@codegen
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1647		; 0000066fH
	jl	SHORT $LN25@codegen
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1651		; 00000673H
	jle	SHORT $LN20@codegen
$LN25@codegen:
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1339		; 0000053bH
	jl	SHORT $LN19@codegen
	mov	rax, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rax+24], 1344		; 00000540H
	jg	SHORT $LN19@codegen
$LN20@codegen:

; 1933 :         (CodeInfo->token >= T_VCVTPD2DQ) && (CodeInfo->token <= T_VMOVDDUP))            //1334        1339 
; 1934 :         opnd1 |= OP_XMM;

	mov	eax, DWORD PTR opnd1$[rsp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR opnd1$[rsp], eax
$LN19@codegen:
$LN12@codegen:

; 1935 :     }
; 1936 : #endif
; 1937 : 
; 1938 : #if AMD64_SUPPORT
; 1939 :     DebugMsg1(("codegen(ofs=%X): %s opnd1=%X codeinfo: ofssize=%u wide=%u rm=%Xh sib=%Xh rex=%Xh opsiz=%u\n",

	mov	rax, QWORD PTR CodeInfo$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	mov	DWORD PTR tv180[rsp], eax
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	movzx	ecx, BYTE PTR [rcx+8]
	mov	DWORD PTR tv183[rsp], ecx
	mov	rdx, QWORD PTR CodeInfo$[rsp]
	movzx	edx, BYTE PTR [rdx+105]
	mov	DWORD PTR tv186[rsp], edx
	mov	r8, QWORD PTR CodeInfo$[rsp]
	movzx	r8d, BYTE PTR [r8+104]
	mov	DWORD PTR tv189[rsp], r8d
	mov	r9, QWORD PTR CodeInfo$[rsp]
	movzx	r9d, BYTE PTR [r9+142]
	and	r9b, 1
	movzx	r9d, r9b
	mov	DWORD PTR tv193[rsp], r9d
	mov	r10, QWORD PTR CodeInfo$[rsp]
	movzx	r10d, BYTE PTR [r10+106]
	mov	DWORD PTR tv196[rsp], r10d
	xor	edx, edx
	mov	r11, QWORD PTR CodeInfo$[rsp]
	mov	ecx, DWORD PTR [r11+24]
	call	GetResWName
	mov	ecx, DWORD PTR tv180[rsp]
	mov	DWORD PTR [rsp+72], ecx
	mov	ecx, DWORD PTR tv183[rsp]
	mov	DWORD PTR [rsp+64], ecx
	mov	ecx, DWORD PTR tv186[rsp]
	mov	DWORD PTR [rsp+56], ecx
	mov	ecx, DWORD PTR tv189[rsp]
	mov	DWORD PTR [rsp+48], ecx
	mov	ecx, DWORD PTR tv193[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	ecx, DWORD PTR tv196[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR opnd1$[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR ModuleInfo+432
	mov	edx, DWORD PTR [rax+16]
	lea	rcx, OFFSET FLAT:$SG11511
	call	DoDebugMsg1
$LN4@codegen:

; 1940 :                CurrSeg->sym.offset, GetResWName( CodeInfo->token, NULL ),
; 1941 :                opnd1, CodeInfo->Ofssize, CodeInfo->iswide,
; 1942 :                CodeInfo->rm_byte, CodeInfo->sib,
; 1943 :                CodeInfo->prefix.rex, CodeInfo->prefix.opsiz ));
; 1944 : #endif
; 1945 :     /* scan the instruction table for a matching first operand */
; 1946 :     do  {
; 1947 :         tbl_op1 = opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[OPND1];

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:opnd_clstab
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	eax, DWORD PTR [rax+rcx]
	mov	DWORD PTR tbl_op1$[rsp], eax

; 1948 : 
; 1949 :         //DebugMsg1(("codegen: table.op1=%X\n", tbl_op1 ));
; 1950 :         /* v2.06: simplified */
; 1951 :         if ( tbl_op1 == OP_NONE && opnd1 == OP_NONE ) {

	cmp	DWORD PTR tbl_op1$[rsp], 0
	jne	SHORT $LN26@codegen
	cmp	DWORD PTR opnd1$[rsp], 0
	jne	SHORT $LN26@codegen

; 1952 :             output_opc( CodeInfo );

	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	output_opc

; 1953 :             if ( CurrFile[LST] )

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN28@codegen

; 1954 :                 LstWrite( LSTTYPE_CODE, oldofs, NULL );

	xor	r8d, r8d
	mov	edx, DWORD PTR oldofs$[rsp]
	mov	ecx, 1
	call	LstWrite
$LN28@codegen:

; 1955 :             return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@codegen
	jmp	$LN27@codegen
$LN26@codegen:

; 1956 :         } else if ( opnd1 & tbl_op1 ) {

	mov	eax, DWORD PTR tbl_op1$[rsp]
	mov	ecx, DWORD PTR opnd1$[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	$LN29@codegen

; 1957 :             /* for immediate operands, the idata type has sometimes
; 1958 :              * to be modified in opnd_type[OPND1], to make output_data()
; 1959 :              * emit the correct number of bytes. */
; 1960 :             switch( tbl_op1 ) {

	mov	eax, DWORD PTR tbl_op1$[rsp]
	mov	DWORD PTR tv226[rsp], eax
	cmp	DWORD PTR tv226[rsp], 262144		; 00040000H
	je	SHORT $LN30@codegen
	cmp	DWORD PTR tv226[rsp], 524288		; 00080000H
	je	SHORT $LN30@codegen
	cmp	DWORD PTR tv226[rsp], 4325377		; 00420001H
	je	SHORT $LN33@codegen
	cmp	DWORD PTR tv226[rsp], 5111808		; 004e0000H
	je	SHORT $LN31@codegen
	jmp	$LN35@codegen
$LN30@codegen:

; 1961 :             case OP_I32: /* CALL, JMP, PUSHD */
; 1962 :             case OP_I16: /* CALL, JMP, RETx, ENTER, PUSHW */
; 1963 :                 retcode = check_operand_2( CodeInfo, tbl_op1 );

	mov	edx, DWORD PTR tbl_op1$[rsp]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	check_operand_2
	mov	DWORD PTR retcode$[rsp], eax

; 1964 :                 break;

	jmp	$LN5@codegen
$LN31@codegen:

; 1965 :             case OP_I8_U: /* INT xx; OUT xx, AL */
; 1966 :                 if( CodeInfo->opnd[OPND1].data32l <= UCHAR_MAX && CodeInfo->opnd[OPND1].data32l >= SCHAR_MIN ) {

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 255		; 000000ffH
	jg	SHORT $LN32@codegen
	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], -128		; ffffffffffffff80H
	jl	SHORT $LN32@codegen

; 1967 :                     retcode = check_operand_2( CodeInfo, OP_I8 );

	mov	edx, 131072				; 00020000H
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	check_operand_2
	mov	DWORD PTR retcode$[rsp], eax
$LN32@codegen:

; 1968 :                 }
; 1969 :                 break;

	jmp	SHORT $LN5@codegen
$LN33@codegen:

; 1970 :             case OP_I_3: /* INT 3 */
; 1971 :                 if ( CodeInfo->opnd[OPND1].data32l == 3 ) {

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	cmp	DWORD PTR [rcx+rax+40], 3
	jne	SHORT $LN34@codegen

; 1972 :                     retcode = check_operand_2( CodeInfo, OP_NONE );

	xor	edx, edx
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	check_operand_2
	mov	DWORD PTR retcode$[rsp], eax
$LN34@codegen:

; 1973 :                 }
; 1974 :                 break;

	jmp	SHORT $LN5@codegen
$LN35@codegen:

; 1975 :             default:
; 1976 :                 retcode = check_operand_2( CodeInfo, CodeInfo->opnd[OPND1].type );

	mov	eax, 24
	imul	rax, rax, 0
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, DWORD PTR [rcx+rax+32]
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	call	check_operand_2
	mov	DWORD PTR retcode$[rsp], eax
$LN5@codegen:

; 1977 :                 break;
; 1978 :             }
; 1979 :             if( retcode == NOT_ERROR) {

	cmp	DWORD PTR retcode$[rsp], 0
	jne	SHORT $LN36@codegen

; 1980 :                 if ( CurrFile[LST] )

	mov	eax, 8
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	cmp	QWORD PTR [rcx+rax], 0
	je	SHORT $LN37@codegen

; 1981 :                     LstWrite( LSTTYPE_CODE, oldofs, NULL );

	xor	r8d, r8d
	mov	edx, DWORD PTR oldofs$[rsp]
	mov	ecx, 1
	call	LstWrite
$LN37@codegen:

; 1982 :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@codegen
$LN36@codegen:
$LN29@codegen:
$LN27@codegen:

; 1983 :             }
; 1984 :         }
; 1985 :         CodeInfo->pinstr++;

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	add	rax, 14
	mov	rcx, QWORD PTR CodeInfo$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1986 :     } while ( CodeInfo->pinstr->first == FALSE );

	mov	rax, QWORD PTR CodeInfo$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax+4]
	test	eax, eax
	je	$LN4@codegen

; 1987 : 
; 1988 :     DebugMsg(("codegen: no matching format found\n"));

	lea	rcx, OFFSET FLAT:$SG11524
	call	DoDebugMsg

; 1989 :     EmitError( INVALID_INSTRUCTION_OPERANDS );

	mov	ecx, 49					; 00000031H
	call	EmitError

; 1990 :     return( ERROR );

	mov	eax, -1
$LN1@codegen:

; 1991 : }

	add	rsp, 136				; 00000088H
	ret	0
codegen	ENDP
_TEXT	ENDS
END
