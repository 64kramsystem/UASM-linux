; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG11656 DB	01H DUP (?)
	ALIGN	4

$SG11664 DB	01H DUP (?)
	ALIGN	4

$SG11667 DB	02H DUP (?)
	ALIGN	4

$SG11672 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
CONST	SEGMENT
reax	DB	'rax', 00H, 00H
	ORG $+3
recx	DB	'rcx', 00H, 00H
	ORG $+3
redx	DB	'rdx', 00H, 00H
	ORG $+3
flaginstr DB	07aH
	DB	063H
	DB	073H
	DB	070H
	DB	06fH
	DB	06cH
	DB	067H
	DB	061H
	DB	065H
	DB	062H
	ORG $+2
unsigned_cjmptype DB 07aH
	DB	07aH
	DB	061H
	DB	062H
	DB	062H
	DB	061H
	ORG $+2
signed_cjmptype DB 07aH
	DB	07aH
	DB	067H
	DB	06cH
	DB	06cH
	DB	067H
	ORG $+2
neg_cjmptype DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
CONST	ENDS
_DATA	SEGMENT
$SG11269 DB	'%u GetExpression(>%.32s< buf=>%s<) enter', 0aH, 00H
	ORG $+6
$SG11271 DB	'%u GetExpression exit, error', 0aH, 00H
	ORG $+2
$SG11272 DB	'NULL', 00H
	ORG $+3
$SG11273 DB	'%u GetExpression: ||-operator found, is_true=%u, lastjmp'
	DB	'=%s', 0aH, 00H
	ORG $+3
$SG11278 DB	'^', 00H
	ORG $+2
$SG11291 DB	':^', 00H
	ORG $+1
$SG11280 DB	'%u GetExpression: jmp inverted, dest changed >%s<', 0aH, 00H
	ORG $+1
$SG11283 DB	'%s:^', 00H
	ORG $+3
$SG11284 DB	'%s:^', 00H
	ORG $+3
$SG11348 DB	'loope', 00H
	ORG $+2
$SG11366 DB	', ', 00H
	ORG $+1
$SG11285 DB	'%u GetExpression: dest changed, label added >%s<', 0aH, 00H
	ORG $+2
$SG11439 DB	' mov  ', 00H
	ORG $+1
$SG11673 DB	'%s:', 00H
$SG11287 DB	'%u GetExpression exit, error', 0aH, 00H
	ORG $+2
$SG11290 DB	'%u GetExpression: suppressed ReplaceLabel %u -> %u, last'
	DB	'jmp=%s', 0aH, 00H
$SG11292 DB	'%u GetExpression: label added >%s<', 0aH, 00H
$SG11681 DB	'jmp', 00H
$SG11293 DB	'%u GetExpression exit', 0aH, 00H
	ORG $+1
$SG11301 DB	'NULL', 00H
	ORG $+3
$SG11302 DB	'QueueTestLines("%s") enter', 0aH, 00H
$SG11683 DB	'%s:', 00H
$SG11305 DB	'QueueTestLines exit', 0aH, 00H
	ORG $+3
$SG11322 DB	'EvaluateHllExpression enter', 0aH, 00H
	ORG $+3
$SG11325 DB	'EvaluateHllExpression: unexpected tokens >%s<', 0aH, 00H
	ORG $+1
$SG11341 DB	'CheckCXZLines enter, p=>%s<', 0aH, 00H
	ORG $+3
$SG11352 DB	'loop', 00H
	ORG $+3
$SG11411 DB	'=!<>&|-+*^%/', 00H
	ORG $+3
$SG11419 DB	' inc ', 00H
	ORG $+2
$SG11421 DB	' dec ', 00H
	ORG $+2
$SG11442 DB	' cdq ', 00H
	ORG $+2
$SG11445 DB	' mov  ', 00H
	ORG $+1
$SG11449 DB	' idiv ', 00H
	ORG $+1
$SG11450 DB	' imul ', 00H
	ORG $+1
$SG11454 DB	' idiv ', 00H
	ORG $+1
$SG11455 DB	' imul ', 00H
	ORG $+1
$SG11457 DB	' mov  ', 00H
	ORG $+1
$SG11458 DB	' mov  ', 00H
	ORG $+1
$SG11462 DB	' cdq ', 00H
	ORG $+2
$SG11463 DB	' idiv ', 00H
	ORG $+1
$SG11464 DB	' imul ', 00H
	ORG $+1
$SG11467 DB	' mov  ', 00H
	ORG $+1
$SG11468 DB	' mov  ', 00H
	ORG $+1
$SG11474 DB	' cdq ', 00H
	ORG $+2
$SG11475 DB	' idiv ', 00H
	ORG $+1
$SG11476 DB	' imul ', 00H
	ORG $+1
$SG11478 DB	' mov  ', 00H
	ORG $+1
$SG11484 DB	' cdq ', 00H
	ORG $+2
$SG11485 DB	' idiv ', 00H
	ORG $+1
$SG11486 DB	' imul ', 00H
	ORG $+1
$SG11488 DB	' mov  ', 00H
	ORG $+1
$SG11491 DB	' mov  ', 00H
	ORG $+1
$SG11495 DB	' cdq ', 00H
	ORG $+2
$SG11496 DB	' idiv ', 00H
	ORG $+1
$SG11497 DB	' imul ', 00H
	ORG $+1
$SG11499 DB	' mov  ', 00H
	ORG $+1
$SG11502 DB	' sub ', 00H
	ORG $+2
$SG11505 DB	' add ', 00H
	ORG $+2
$SG11508 DB	' and ', 00H
	ORG $+2
$SG11511 DB	' or ', 00H
	ORG $+3
$SG11514 DB	' xor ', 00H
	ORG $+2
$SG11517 DB	' shl ', 00H
	ORG $+2
$SG11519 DB	' shr ', 00H
	ORG $+2
$SG11526 DB	' xor  ', 00H
	ORG $+1
$SG11533 DB	'BYTE PTR', 00H
	ORG $+3
$SG11534 DB	'BPTR', 00H
	ORG $+3
$SG11535 DB	'WPTR', 00H
	ORG $+3
$SG11541 DB	' lea  ', 00H
	ORG $+1
$SG11715 DB	'%s:', 00H
$SG11536 DB	'WORD PTR', 00H
	ORG $+3
$SG11542 DB	' mov  ', 00H
	ORG $+1
$SG11720 DB	'%s:', 00H
$SG11537 DB	' movzx  ', 00H
	ORG $+3
$SG11540 DB	'ADDR', 00H
	ORG $+3
$SG11548 DB	'OFFSET', 00H
	ORG $+1
$SG11549 DB	' lea  ', 00H
	ORG $+1
$SG11550 DB	' mov  ', 00H
	ORG $+1
$SG11726 DB	'%s:', 00H
$SG11557 DB	'DWORD PTR', 00H
	ORG $+2
$SG11558 DB	'DPTR', 00H
	ORG $+3
$SG11561 DB	' mov  ', 00H
	ORG $+1
$SG11728 DB	'%s:', 00H
$SG11560 DB	' movsxd  ', 00H
	ORG $+2
$SG11568 DB	' mov  ', 00H
	ORG $+1
$SG11736 DB	'%s:', 00H
$SG11567 DB	' invoke  ', 00H
	ORG $+2
$SG11571 DB	' mov  ', 00H
	ORG $+1
$SG11741 DB	'%s:', 00H
$SG11574 DB	' mov  byte ptr ', 00H
$SG11575 DB	' mov  ', 00H
	ORG $+1
$SG11635 DB	'HllStartDir(%s) enter', 0aH, 00H
	ORG $+1
$SG11648 DB	'(::)', 00H
	ORG $+3
$SG11663 DB	' jmp %s', 00H
$SG11666 DB	'.for ', 00H
	ORG $+2
$SG11668 DB	'.for', 00H, 00H
	ORG $+2
$SG11682 DB	'jmp %s', 00H
	ORG $+1
$SG11685 DB	'hll.c', 00H
	ORG $+2
$SG11687 DB	'HllStartDir: unexpected token [%s]', 0aH, 00H
$SG11752 DB	'%s:', 00H
$SG11708 DB	'HllEndDir(%s) enter', 0aH, 00H
	ORG $+3
$SG11710 DB	'HllEndDir: hll stack is empty', 0aH, 00H
	ORG $+1
$SG11713 DB	'HllEndDir: no .IF on the hll stack', 0aH, 00H
$SG11758 DB	'%s:', 00H
$SG11718 DB	'HllEndDir: no .FOR on the hll stack', 0aH, 00H
	ORG $+3
$SG11729 DB	' jmp %s', 00H
$SG11731 DB	' jmp %s', 00H
$SG11734 DB	'HllEndDir: no .WHILE on the hll stack', 0aH, 00H
	ORG $+1
$SG11739 DB	'HllEndDir: no .REPEAT on the hll stack', 0aH, 00H
$SG11747 DB	'loop %s', 00H
$SG11750 DB	'HllEndDir: no .REPEAT on the hll stack', 0aH, 00H
$SG11756 DB	'hll.c', 00H
	ORG $+2
$SG11784 DB	'HllExitDir(%s) enter', 0aH, 00H
	ORG $+2
$SG11786 DB	'HllExitDir stack error', 0aH, 00H
$SG11789 DB	'HllExitDir(%s): labels[LTEST]=%X', 0aH, 00H
	ORG $+2
$SG11792 DB	'jmp %s', 00H
	ORG $+1
$SG11794 DB	'%s:', 00H
$SG11811 DB	'jmp %s', 00H
	ORG $+1
$SG11813 DB	'hll.c', 00H
	ORG $+2
$SG11820 DB	'.if-.repeat-.while', 00H
	ORG $+1
$SG10981 DB	'ZERO', 00H
	ORG $+7
$SG11821 DB	'HllCheckOpen: allocated items:%u, reused items:%u, .whil'
	DB	'e cond-blocks/bytes:%u/%u', 0aH, 00H
	ORG $+1
$SG10984 DB	'CARRY', 00H
	ORG $+2
$SG10987 DB	'SIGN', 00H
	ORG $+3
$SG10990 DB	'PARITY', 00H
	ORG $+1
$SG11147 DB	'cmp', 00H
$SG10993 DB	'OVERFLOW', 00H
	ORG $+3
$SG10996 DB	'LESS', 00H
	ORG $+3
$SG11002 DB	'ABOVE', 00H
	ORG $+2
$SG11038 DB	'@C%04X', 00H
	ORG $+1
$SG11169 DB	'or', 00H
	ORG $+1
$SG10999 DB	'GREATER', 00H
$SG11005 DB	'EQUAL', 00H
	ORG $+2
$SG11008 DB	'BELOW', 00H
	ORG $+2
$SG11030 DB	', %d', 00H
	ORG $+3
$SG11031 DB	'%u RenderInstr(%s)=>%s<', 0aH, 00H
	ORG $+3
$SG11077 DB	'hll.c', 00H
	ORG $+2
$SG11170 DB	'cmp', 00H
$SG11052 DB	'%u RenderJcc()=>%s<', 0aH, 00H
	ORG $+3
$SG11116 DB	'%u GetSimpleExpression(>%.32s< buf=>%s<) enter', 0aH, 00H
$SG11125 DB	'%u GetSimpleExpression: calling GetExpression, i=%u', 0aH
	DB	00H
	ORG $+3
$SG11128 DB	'GetSimpleExpression: expected '')'', found: %s', 0aH, 00H
	ORG $+2
$SG11134 DB	'%u GetSimpleExpression: EvalOperand ok, kind=%X, i=%u [%'
	DB	's]', 0aH, 00H
$SG11239 DB	'^', 00H
	ORG $+2
$SG11137 DB	'GetSimpleExpression: non-empty expression rejected: %s', 0aH
	DB	00H
$SG11139 DB	'GetSimpleExpression: empty expression rejected', 0aH, 00H
$SG11141 DB	'GetSimpleExpression: float expression rejected: %s', 0aH
	DB	00H
$SG11145 DB	'test', 00H
	ORG $+3
$SG11156 DB	'hll.c', 00H
	ORG $+2
$SG11243 DB	':^', 00H
	ORG $+1
$SG11154 DB	'jmp @C%04X^', 00H
	ORG $+4
$SG11158 DB	'%u GetSimpleExpression: EvalOperand 2 ok, type=%X, i=%u '
	DB	'[%s]', 0aH, 00H
	ORG $+2
$SG11160 DB	'GetSimpleExpression: syntax error, op2.kind=%u', 0aH, 00H
$SG11163 DB	'test', 00H
	ORG $+3
$SG11171 DB	'GetSimpleExpression: unexpected operator %s', 0aH, 00H
	ORG $+3
$SG11177 DB	'jmp ', 00H
	ORG $+3
$SG11207 DB	'%u ReplaceLabel(%s->%s, >%s<)', 0aH, 00H
	ORG $+1
$SG11231 DB	'%u GetAndExpression(>%.32s< buf=>%s<) enter', 0aH, 00H
	ORG $+3
$SG11233 DB	'NULL', 00H
	ORG $+3
$SG11240 DB	'%u GetAndExpression: jmp inverted >%s<', 0aH, 00H
$SG11234 DB	'%u GetAndExpression: &&-operator found, is_true=%u, last'
	DB	'jmp=%s', 0aH, 00H
$SG11244 DB	'%u GetAndExpression: label added >%s<', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	HllInit
PUBLIC	HllCheckOpen
PUBLIC	HllStartDir
PUBLIC	HllEndDir
PUBLIC	HllExitDir
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_tolower:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	memcpy:PROC
EXTRN	__imp_strchr:PROC
EXTRN	__imp_strstr:PROC
EXTRN	__imp__memicmp:PROC
EXTRN	strcat:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strcmpi:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	LclAlloc:PROC
EXTRN	EvalOperand:PROC
EXTRN	EmitConstError:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	LstWrite:PROC
EXTRN	AddLineQueue:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	RunLineQueue:PROC
EXTRN	InternalError:PROC
EXTRN	Tokenize:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

evallvl	DD	01H DUP (?)
cntAlloc DD	01H DUP (?)
cntReused DD	01H DUP (?)
cntCond	DD	01H DUP (?)
cntCondBytes DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$HllInit DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$HllInit
$pdata$HllCheckOpen DD imagerel $LN4
	DD	imagerel $LN4+96
	DD	imagerel $unwind$HllCheckOpen
$pdata$GetToken DD imagerel GetToken
	DD	imagerel GetToken+220
	DD	imagerel $unwind$GetToken
$pdata$GetExpression DD imagerel GetExpression
	DD	imagerel GetExpression+1442
	DD	imagerel $unwind$GetExpression
$pdata$GetHllLabel DD imagerel GetHllLabel
	DD	imagerel GetHllLabel+24
	DD	imagerel $unwind$GetHllLabel
$pdata$GetCOp DD imagerel GetCOp
	DD	imagerel GetCOp+903
	DD	imagerel $unwind$GetCOp
$pdata$RenderInstr DD imagerel RenderInstr
	DD	imagerel RenderInstr+510
	DD	imagerel $unwind$RenderInstr
$pdata$GetLabelStr DD imagerel GetLabelStr
	DD	imagerel GetLabelStr+66
	DD	imagerel $unwind$GetLabelStr
$pdata$RenderJcc DD imagerel RenderJcc
	DD	imagerel RenderJcc+280
	DD	imagerel $unwind$RenderJcc
$pdata$GetLabel DD imagerel GetLabel
	DD	imagerel GetLabel+102
	DD	imagerel $unwind$GetLabel
$pdata$GetSimpleExpression DD imagerel GetSimpleExpression
	DD	imagerel GetSimpleExpression+2686
	DD	imagerel $unwind$GetSimpleExpression
$pdata$InvertJump DD imagerel InvertJump
	DD	imagerel InvertJump+457
	DD	imagerel $unwind$InvertJump
$pdata$ReplaceLabel DD imagerel ReplaceLabel
	DD	imagerel ReplaceLabel+294
	DD	imagerel $unwind$ReplaceLabel
$pdata$GetAndExpression DD imagerel GetAndExpression
	DD	imagerel GetAndExpression+783
	DD	imagerel $unwind$GetAndExpression
$pdata$QueueTestLines DD imagerel QueueTestLines
	DD	imagerel QueueTestLines+191
	DD	imagerel $unwind$QueueTestLines
$pdata$EvaluateHllExpression DD imagerel EvaluateHllExpression
	DD	imagerel EvaluateHllExpression+284
	DD	imagerel $unwind$EvaluateHllExpression
$pdata$CheckCXZLines DD imagerel CheckCXZLines
	DD	imagerel CheckCXZLines+435
	DD	imagerel $unwind$CheckCXZLines
$pdata$WriteAsmLine DD imagerel WriteAsmLine
	DD	imagerel WriteAsmLine+185
	DD	imagerel $unwind$WriteAsmLine
$pdata$ForInitAndNext DD imagerel ForInitAndNext
	DD	imagerel ForInitAndNext+5315
	DD	imagerel $unwind$ForInitAndNext
$pdata$HllStartDir DD imagerel $LN76
	DD	imagerel $LN76+3858
	DD	imagerel $unwind$HllStartDir
$pdata$HllEndDir DD imagerel $LN40
	DD	imagerel $LN40+1958
	DD	imagerel $unwind$HllEndDir
$pdata$HllExitDir DD imagerel $LN38
	DD	imagerel $LN38+1548
	DD	imagerel $unwind$HllExitDir
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
	ORG $+2
GetExpression$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
	ORG $+7
GetExpression$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:GetExpression$rtcVarDesc
GetSimpleExpression$rtcName$0 DB 06fH
	DB	070H
	DB	031H
	DB	00H
	ORG $+4
GetExpression$rtcVarDesc DD 068H
	DD	010H
	DQ	FLAT:GetExpression$rtcName$0
	ORG $+48
GetSimpleExpression$rtcName$1 DB 06fH
	DB	070H
	DB	032H
	DB	00H
ReplaceLabel$rtcName$0 DB 06fH
	DB	06cH
	DB	064H
	DB	06cH
	DB	062H
	DB	06cH
	DB	00H
	ORG $+5
GetSimpleExpression$rtcVarDesc DD 0100H
	DD	068H
	DQ	FLAT:GetSimpleExpression$rtcName$1
	DD	070H
	DD	068H
	DQ	FLAT:GetSimpleExpression$rtcName$0
	ORG $+96
GetSimpleExpression$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:GetSimpleExpression$rtcVarDesc
ReplaceLabel$rtcName$1 DB 06eH
	DB	065H
	DB	077H
	DB	06cH
	DB	062H
	DB	06cH
	DB	00H
	ORG $+1
ReplaceLabel$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:ReplaceLabel$rtcVarDesc
EvaluateHllExpression$rtcName$0 DB 068H
	DB	06cH
	DB	06cH
	DB	06fH
	DB	070H
	DB	00H
	ORG $+2
ReplaceLabel$rtcVarDesc DD 068H
	DD	010H
	DQ	FLAT:ReplaceLabel$rtcName$1
	DD	038H
	DD	010H
	DQ	FLAT:ReplaceLabel$rtcName$0
	ORG $+96
EvaluateHllExpression$rtcVarDesc DD 048H
	DD	010H
	DQ	FLAT:EvaluateHllExpression$rtcName$0
	ORG $+48
EvaluateHllExpression$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:EvaluateHllExpression$rtcVarDesc
WriteAsmLine$rtcName$0 DB 063H
	DB	06fH
	DB	064H
	DB	065H
	DB	062H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
	ORG $+7
WriteAsmLine$rtcVarDesc DD 030H
	DD	0100H
	DQ	FLAT:WriteAsmLine$rtcName$0
	ORG $+48
WriteAsmLine$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:WriteAsmLine$rtcVarDesc
ForInitAndNext$rtcName$0 DB 063H
	DB	06fH
	DB	064H
	DB	065H
	DB	062H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
	ORG $+3
ForInitAndNext$rtcName$1 DB 070H
	DB	061H
	DB	072H
	DB	061H
	DB	06dH
	DB	00H
	ORG $+2
ForInitAndNext$rtcName$2 DB 069H
	DB	06eH
	DB	069H
	DB	074H
	DB	00H
	ORG $+3
ForInitAndNext$rtcName$3 DB 06fH
	DB	070H
	DB	00H
	ORG $+1
ForInitAndNext$rtcVarDesc DD 0394H
	DD	04H
	DQ	FLAT:ForInitAndNext$rtcName$3
	DD	0280H
	DD	0100H
	DQ	FLAT:ForInitAndNext$rtcName$2
	DD	0160H
	DD	0100H
	DQ	FLAT:ForInitAndNext$rtcName$1
	DD	040H
	DD	0100H
	DQ	FLAT:ForInitAndNext$rtcName$0
	ORG $+192
ForInitAndNext$rtcFrameData DD 04H
	DD	00H
	DQ	FLAT:ForInitAndNext$rtcVarDesc
HllStartDir$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
	ORG $+3
HllStartDir$rtcName$1 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
HllStartDir$rtcName$2 DB 063H
	DB	06fH
	DB	064H
	DB	065H
	DB	062H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
	ORG $+3
HllStartDir$rtcName$3 DB 070H
	DB	061H
	DB	072H
	DB	061H
	DB	06dH
	DB	00H
	ORG $+2
HllStartDir$rtcName$4 DB 069H
	DB	06eH
	DB	069H
	DB	074H
	DB	00H
	ORG $+3
HllStartDir$rtcName$5 DB 06cH
	DB	069H
	DB	06dH
	DB	069H
	DB	074H
	DB	00H
	ORG $+2
HllStartDir$rtcName$6 DB 06fH
	DB	070H
	DB	00H
	ORG $+1
HllStartDir$rtcName$7 DB 066H
	DB	06fH
	DB	072H
	DB	062H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
HllStartDir$rtcName$8 DB 066H
	DB	06fH
	DB	072H
	DB	062H
	DB	075H
	DB	066H
	DB	066H
	DB	069H
	DB	06eH
	DB	069H
	DB	074H
	DB	00H
	ORG $+4
HllStartDir$rtcName$9 DB 066H
	DB	06fH
	DB	072H
	DB	062H
	DB	075H
	DB	066H
	DB	066H
	DB	063H
	DB	06fH
	DB	06eH
	DB	064H
	DB	00H
	ORG $+4
HllStartDir$rtcName$10 DB 066H
	DB	06fH
	DB	072H
	DB	062H
	DB	075H
	DB	066H
	DB	066H
	DB	063H
	DB	06eH
	DB	074H
	DB	00H
	ORG $+5
HllStartDir$rtcName$11 DB 074H
	DB	072H
	DB	061H
	DB	06eH
	DB	073H
	DB	066H
	DB	06fH
	DB	072H
	DB	06dH
	DB	065H
	DB	064H
	DB	00H
	ORG $+4
HllStartDir$rtcVarDesc DD 01550H
	DD	0258H
	DQ	FLAT:HllStartDir$rtcName$11
	DD	012d0H
	DD	0258H
	DQ	FLAT:HllStartDir$rtcName$10
	DD	01050H
	DD	0258H
	DQ	FLAT:HllStartDir$rtcName$9
	DD	0dd0H
	DD	0258H
	DQ	FLAT:HllStartDir$rtcName$8
	DD	0b50H
	DD	0258H
	DQ	FLAT:HllStartDir$rtcName$7
	DD	0b24H
	DD	04H
	DQ	FLAT:HllStartDir$rtcName$6
	DD	08b0H
	DD	0258H
	DQ	FLAT:HllStartDir$rtcName$5
	DD	0790H
	DD	0100H
	DQ	FLAT:HllStartDir$rtcName$4
	DD	0670H
	DD	0100H
	DQ	FLAT:HllStartDir$rtcName$3
	DD	0550H
	DD	0100H
	DQ	FLAT:HllStartDir$rtcName$2
	DD	080H
	DD	04b0H
	DQ	FLAT:HllStartDir$rtcName$1
	DD	048H
	DD	010H
	DQ	FLAT:HllStartDir$rtcName$0
	ORG $+576
HllStartDir$rtcFrameData DD 0cH
	DD	00H
	DQ	FLAT:HllStartDir$rtcVarDesc
HllEndDir$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
	ORG $+3
HllEndDir$rtcName$1 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
HllEndDir$rtcVarDesc DD 080H
	DD	04b0H
	DQ	FLAT:HllEndDir$rtcName$1
	DD	048H
	DD	010H
	DQ	FLAT:HllEndDir$rtcName$0
	ORG $+96
HllEndDir$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:HllEndDir$rtcVarDesc
HllExitDir$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
	ORG $+3
HllExitDir$rtcName$1 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
HllExitDir$rtcVarDesc DD 090H
	DD	04b0H
	DQ	FLAT:HllExitDir$rtcName$1
	DD	058H
	DD	010H
	DQ	FLAT:HllExitDir$rtcName$0
	ORG $+96
HllExitDir$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:HllExitDir$rtcVarDesc
CONST	ENDS
xdata	SEGMENT
$unwind$HllInit DD 010501H
	DD	07005H
$unwind$HllCheckOpen DD 021501H
	DD	070025206H
$unwind$GetToken DD 022d01H
	DD	070157219H
$unwind$GetExpression DD 034519H
	DD	01a011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$GetHllLabel DD 010201H
	DD	07002H
$unwind$GetCOp DD 021e01H
	DD	07006720aH
$unwind$RenderInstr DD 022d01H
	DD	070155219H
$unwind$GetLabelStr DD 022101H
	DD	0700a320eH
$unwind$RenderJcc DD 022c01H
	DD	070145218H
$unwind$GetLabel DD 022201H
	DD	0700a520eH
$unwind$GetSimpleExpression DD 033301H
	DD	034011cH
	DD	07015H
$unwind$InvertJump DD 021e01H
	DD	07006320aH
$unwind$ReplaceLabel DD 033f19H
	DD	0140116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$GetAndExpression DD 022d01H
	DD	07015b219H
$unwind$QueueTestLines DD 021e01H
	DD	07006520aH
$unwind$EvaluateHllExpression DD 023001H
	DD	07015d219H
$unwind$CheckCXZLines DD 021e01H
	DD	07006720aH
$unwind$WriteAsmLine DD 034019H
	DD	02a0117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$ForInitAndNext DD 033f19H
	DD	0800116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	03f0H
$unwind$HllStartDir DD 033f19H
	DD	03080117H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	01838H
$unwind$HllEndDir DD 033919H
	DD	0aa0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0548H
$unwind$HllExitDir DD 033919H
	DD	0ae0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0560H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
hll$ = 48
rc$ = 56
idx$ = 60
cmd$ = 64
buff$ = 88
buffer$ = 144
savedcmd$5 = 1348
tv78 = 1360
tv214 = 1364
tv229 = 1368
__$ArrayPad$ = 1376
i$ = 1408
tokenarray$ = 1416
HllExitDir PROC

; 1589 : {

$LN38:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 1392				; 00000570H
	mov	rdi, rsp
	mov	ecx, 348				; 0000015cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+1408]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1590 :   //int               level;
; 1591 :   //struct asym       *sym;
; 1592 :   struct hll_item     *hll;
; 1593 :   ret_code            rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 1594 :   int                 idx;
; 1595 :   int                 cmd = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR cmd$[rsp], eax

; 1596 :   char buff[16];
; 1597 :   char buffer[MAX_LINE_LEN * 2];
; 1598 : 
; 1599 :   DebugMsg1(("HllExitDir(%s) enter\n", tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11784
	call	DoDebugMsg1

; 1600 : 
; 1601 :   hll = HllStack;

	mov	rax, QWORD PTR ModuleInfo+224
	mov	QWORD PTR hll$[rsp], rax

; 1602 : 
; 1603 :   if (hll == NULL) {

	cmp	QWORD PTR hll$[rsp], 0
	jne	SHORT $LN7@HllExitDir

; 1604 :     DebugMsg(("HllExitDir stack error\n"));

	lea	rcx, OFFSET FLAT:$SG11786
	call	DoDebugMsg

; 1605 :     return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError
	jmp	$LN1@HllExitDir
$LN7@HllExitDir:

; 1606 :   }
; 1607 : 
; 1608 :   switch (cmd) {

	mov	eax, DWORD PTR cmd$[rsp]
	mov	DWORD PTR tv78[rsp], eax
	cmp	DWORD PTR tv78[rsp], 331		; 0000014bH
	jl	$LN29@HllExitDir
	cmp	DWORD PTR tv78[rsp], 332		; 0000014cH
	jle	$LN16@HllExitDir
	cmp	DWORD PTR tv78[rsp], 332		; 0000014cH
	jle	$LN29@HllExitDir
	cmp	DWORD PTR tv78[rsp], 334		; 0000014eH
	jle	SHORT $LN8@HllExitDir
	jmp	$LN29@HllExitDir
$LN8@HllExitDir:

; 1609 :   case T_DOT_ELSE:
; 1610 :   case T_DOT_ELSEIF:
; 1611 :     if (hll->cmd != HLL_IF) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+52], 0
	je	SHORT $LN9@HllExitDir

; 1612 :       DebugMsg(("HllExitDir(%s): labels[LTEST]=%X\n", tokenarray[i].string_ptr, hll->labels[LTEST]));

	mov	eax, 4
	imul	rax, rax, 0
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR hll$[rsp]
	mov	r8d, DWORD PTR [rdx+rax+8]
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	lea	rcx, OFFSET FLAT:$SG11789
	call	DoDebugMsg

; 1613 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 80					; 00000050H
	call	EmitErr
	jmp	$LN1@HllExitDir
$LN9@HllExitDir:

; 1614 :     }
; 1615 :     /* v2.08: check for multiple ELSE clauses */
; 1616 :     if (hll->flags & HLLF_ELSEOCCURED) {

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+60]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN10@HllExitDir

; 1617 :       return(EmitError(DOT_ELSE_CLAUSE_ALREADY_OCCURED_IN_THIS_DOT_IF_BLOCK));

	mov	ecx, 67					; 00000043H
	call	EmitError
	jmp	$LN1@HllExitDir
$LN10@HllExitDir:

; 1618 :     }
; 1619 : 
; 1620 :     /* the 'exit'-label is only needed if an .ELSE branch exists.
; 1621 :     * That's why it is created delayed.
; 1622 :     */
; 1623 :     if (hll->labels[LEXIT] == 0)

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	jne	SHORT $LN11@HllExitDir

; 1624 :       hll->labels[LEXIT] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax
$LN11@HllExitDir:

; 1625 :     AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11792
	call	AddLineQueueX

; 1626 : 
; 1627 :     if (hll->labels[LTEST] > 0) {

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	jbe	SHORT $LN12@HllExitDir

; 1628 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	mov	eax, 4
	imul	rax, rax, 0
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11794
	call	AddLineQueueX

; 1629 :       hll->labels[LTEST] = 0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0
$LN12@HllExitDir:

; 1630 :     }
; 1631 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1632 :     if (cmd == T_DOT_ELSEIF) {

	cmp	DWORD PTR cmd$[rsp], 334		; 0000014eH
	jne	SHORT $LN13@HllExitDir

; 1633 :       /* create new labels[LTEST] label */
; 1634 :       hll->labels[LTEST] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1635 :       rc = EvaluateHllExpression(hll, &i, tokenarray, LTEST, FALSE, buffer);

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	EvaluateHllExpression
	mov	DWORD PTR rc$[rsp], eax

; 1636 :       if (rc == NOT_ERROR)

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN15@HllExitDir

; 1637 :         QueueTestLines(buffer);

	lea	rcx, QWORD PTR buffer$[rsp]
	call	QueueTestLines
$LN15@HllExitDir:

; 1638 :     }

	jmp	SHORT $LN14@HllExitDir
$LN13@HllExitDir:

; 1639 :     else
; 1640 :       hll->flags |= HLLF_ELSEOCCURED;

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+60]
	or	eax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+60], eax
$LN14@HllExitDir:

; 1641 : 
; 1642 :     break;

	jmp	$LN2@HllExitDir
$LN16@HllExitDir:

; 1643 :   case T_DOT_BREAK:
; 1644 :   case T_DOT_CONTINUE:
; 1645 :     for (; hll && hll->cmd == HLL_IF; hll = hll->next);

	jmp	SHORT $LN6@HllExitDir
$LN4@HllExitDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR hll$[rsp], rax
$LN6@HllExitDir:
	cmp	QWORD PTR hll$[rsp], 0
	je	SHORT $LN5@HllExitDir
	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+52], 0
	jne	SHORT $LN5@HllExitDir
	jmp	SHORT $LN4@HllExitDir
$LN5@HllExitDir:

; 1646 :     if (hll == NULL) {

	cmp	QWORD PTR hll$[rsp], 0
	jne	SHORT $LN17@HllExitDir

; 1647 :       return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError
	jmp	$LN1@HllExitDir
$LN17@HllExitDir:

; 1648 :     }
; 1649 :     /* v2.11: create 'exit' and 'test' labels delayed.
; 1650 :     */
; 1651 :     if (cmd == T_DOT_BREAK) {

	cmp	DWORD PTR cmd$[rsp], 331		; 0000014bH
	jne	SHORT $LN18@HllExitDir

; 1652 :       if (hll->labels[LEXIT] == 0)

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	jne	SHORT $LN20@HllExitDir

; 1653 :         hll->labels[LEXIT] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax
$LN20@HllExitDir:

; 1654 :       idx = LEXIT;

	mov	DWORD PTR idx$[rsp], 1

; 1655 :     }

	jmp	$LN19@HllExitDir
$LN18@HllExitDir:

; 1656 :     else if (hll->cmd == HLL_FOR) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+52], 4
	jne	SHORT $LN21@HllExitDir

; 1657 :       /* added by habran 
; 1658 :          .CONTINUE label is created here for .FOR loops only if it exists.
; 1659 :          It is different than .WHILE because it has to first alter counters
; 1660 :       */
; 1661 :         if (hll->labels[LCONT] == 0) hll->labels[LCONT] = GetHllLabel();

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	jne	SHORT $LN23@HllExitDir
	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax
$LN23@HllExitDir:

; 1662 :         idx = (hll->labels[LCONT] ? LCONT : LSTART);

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN34@HllExitDir
	mov	DWORD PTR tv214[rsp], 4
	jmp	SHORT $LN35@HllExitDir
$LN34@HllExitDir:
	mov	DWORD PTR tv214[rsp], 2
$LN35@HllExitDir:
	mov	eax, DWORD PTR tv214[rsp]
	mov	DWORD PTR idx$[rsp], eax

; 1663 :       }else {

	jmp	SHORT $LN22@HllExitDir
$LN21@HllExitDir:

; 1664 :             /* 'test' is not created for .WHILE loops here; because
; 1665 :              * if it doesn't exist, there's no condition to test.
; 1666 :              */
; 1667 :             if ( hll->cmd == HLL_REPEAT && hll->labels[LTEST] == 0 )

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+52], 2
	jne	SHORT $LN24@HllExitDir
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	jne	SHORT $LN24@HllExitDir

; 1668 :                 hll->labels[LTEST] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax
$LN24@HllExitDir:

; 1669 :             idx = ( hll->labels[LTEST] ? LTEST : LSTART );

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN36@HllExitDir
	mov	DWORD PTR tv229[rsp], 0
	jmp	SHORT $LN37@HllExitDir
$LN36@HllExitDir:
	mov	DWORD PTR tv229[rsp], 2
$LN37@HllExitDir:
	mov	eax, DWORD PTR tv229[rsp]
	mov	DWORD PTR idx$[rsp], eax
$LN22@HllExitDir:
$LN19@HllExitDir:

; 1670 :         }
; 1671 : 
; 1672 :     /* .BREAK .IF ... or .CONTINUE .IF ? */
; 1673 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1674 :     if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN25@HllExitDir

; 1675 :       if (tokenarray[i].token == T_DIRECTIVE && tokenarray[i].tokval == T_DOT_IF) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	$LN27@HllExitDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 327		; 00000147H
	jne	$LN27@HllExitDir

; 1676 :         enum hll_cmd savedcmd = hll->cmd;

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+52]
	mov	DWORD PTR savedcmd$5[rsp], eax

; 1677 :         hll->cmd = HLL_BREAK;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+52], 3

; 1678 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1679 :         /* v2.11: set rc and don't exit if an error occurs; see hll3.aso */
; 1680 :         rc = EvaluateHllExpression(hll, &i, tokenarray, idx, TRUE, buffer);

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], 1
	mov	r9d, DWORD PTR idx$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	EvaluateHllExpression
	mov	DWORD PTR rc$[rsp], eax

; 1681 :         if (rc == NOT_ERROR)

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN28@HllExitDir

; 1682 :           QueueTestLines(buffer);

	lea	rcx, QWORD PTR buffer$[rsp]
	call	QueueTestLines
$LN28@HllExitDir:

; 1683 :         hll->cmd = savedcmd;

	mov	rax, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR savedcmd$5[rsp]
	mov	DWORD PTR [rax+52], ecx
$LN27@HllExitDir:

; 1684 :       }
; 1685 :     }

	jmp	SHORT $LN26@HllExitDir
$LN25@HllExitDir:

; 1686 :     else {
; 1687 :       AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[idx], buff));

	movsxd	rax, DWORD PTR idx$[rsp]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax*4+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11811
	call	AddLineQueueX
$LN26@HllExitDir:

; 1688 :     }
; 1689 :     break;

	jmp	SHORT $LN2@HllExitDir
$LN29@HllExitDir:

; 1690 : #ifdef DEBUG_OUT
; 1691 :   default: /**/myassert(0); break;

	mov	edx, 1691				; 0000069bH
	lea	rcx, OFFSET FLAT:$SG11813
	call	InternalError
$LN2@HllExitDir:

; 1692 : #endif
; 1693 :   }
; 1694 :   if (tokenarray[i].token != T_FINAL && rc == NOT_ERROR) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN30@HllExitDir
	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN30@HllExitDir

; 1695 :     EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1696 :     rc = ERROR;

	mov	DWORD PTR rc$[rsp], -1
$LN30@HllExitDir:

; 1697 :   }
; 1698 : 
; 1699 :   if (ModuleInfo.list)

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN31@HllExitDir

; 1700 :     LstWrite(LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL);

	call	GetCurrOffset
	xor	r8d, r8d
	mov	edx, eax
	mov	ecx, 4
	call	LstWrite
$LN31@HllExitDir:

; 1701 : 
; 1702 :   /* v2.11: always run line-queue if it's not empty. */
; 1703 :   if (is_linequeue_populated())

	cmp	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN32@HllExitDir

; 1704 :     RunLineQueue();

	call	RunLineQueue
$LN32@HllExitDir:

; 1705 : 
; 1706 :   return(rc);

	mov	eax, DWORD PTR rc$[rsp]
$LN1@HllExitDir:

; 1707 : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:HllExitDir$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1392				; 00000570H
	pop	rdi
	ret	0
HllExitDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
hll$ = 48
rc$ = 56
cmd$ = 60
buff$ = 72
buffer$ = 128
tv80 = 1344
__$ArrayPad$ = 1352
i$ = 1376
tokenarray$ = 1384
HllEndDir PROC

; 1427 : {

$LN40:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 1360				; 00000550H
	mov	rdi, rsp
	mov	ecx, 340				; 00000154H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+1376]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1428 :   //struct asym       *sym;
; 1429 :   struct hll_item     *hll;
; 1430 :   ret_code            rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 1431 :   int                 cmd = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR cmd$[rsp], eax

; 1432 :   char buff[16];
; 1433 :   //char buffer[MAX_LINE_LEN*2];
; 1434 : 
; 1435 : 
; 1436 :   char buffer[MAX_LINE_LEN * 2];
; 1437 : 
; 1438 :   DebugMsg1(("HllEndDir(%s) enter\n", tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11708
	call	DoDebugMsg1

; 1439 : 
; 1440 :   if (HllStack == NULL) {

	cmp	QWORD PTR ModuleInfo+224, 0
	jne	SHORT $LN4@HllEndDir

; 1441 :     DebugMsg(("HllEndDir: hll stack is empty\n"));

	lea	rcx, OFFSET FLAT:$SG11710
	call	DoDebugMsg

; 1442 :     return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError
	jmp	$LN1@HllEndDir
$LN4@HllEndDir:

; 1443 :   }
; 1444 : 
; 1445 :   hll = HllStack;

	mov	rax, QWORD PTR ModuleInfo+224
	mov	QWORD PTR hll$[rsp], rax

; 1446 :   HllStack = hll->next;

	mov	rax, QWORD PTR hll$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ModuleInfo+224, rax

; 1447 :   /* v2.06: move the item to the free stack */
; 1448 :   hll->next = HllFree;

	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+232
	mov	QWORD PTR [rax], rcx

; 1449 :   HllFree = hll;

	mov	rax, QWORD PTR hll$[rsp]
	mov	QWORD PTR ModuleInfo+232, rax

; 1450 : 
; 1451 :   switch (cmd) {

	mov	eax, DWORD PTR cmd$[rsp]
	mov	DWORD PTR tv80[rsp], eax
	cmp	DWORD PTR tv80[rsp], 335		; 0000014fH
	je	SHORT $LN5@HllEndDir
	cmp	DWORD PTR tv80[rsp], 336		; 00000150H
	je	$LN18@HllEndDir
	cmp	DWORD PTR tv80[rsp], 337		; 00000151H
	je	$LN29@HllEndDir
	cmp	DWORD PTR tv80[rsp], 338		; 00000152H
	je	$LN21@HllEndDir
	cmp	DWORD PTR tv80[rsp], 339		; 00000153H
	je	$LN8@HllEndDir
	jmp	$LN34@HllEndDir
$LN5@HllEndDir:

; 1452 :   case T_DOT_ENDIF:
; 1453 :     if (hll->cmd != HLL_IF) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+52], 0
	je	SHORT $LN6@HllEndDir

; 1454 :       DebugMsg(("HllEndDir: no .IF on the hll stack\n"));

	lea	rcx, OFFSET FLAT:$SG11713
	call	DoDebugMsg

; 1455 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 80					; 00000050H
	call	EmitErr
	jmp	$LN1@HllEndDir
$LN6@HllEndDir:

; 1456 :     }
; 1457 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1458 :     /* if a test label isn't created yet, create it */
; 1459 :     if (hll->labels[LTEST]) {

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN7@HllEndDir

; 1460 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	mov	eax, 4
	imul	rax, rax, 0
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11715
	call	AddLineQueueX
$LN7@HllEndDir:

; 1461 :     }
; 1462 :     break;

	jmp	$LN2@HllEndDir
$LN8@HllEndDir:

; 1463 :     // added by habran
; 1464 :   case T_DOT_ENDFOR:
; 1465 :     if (hll->cmd != HLL_FOR) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+52], 4
	je	SHORT $LN9@HllEndDir

; 1466 :       DebugMsg(("HllEndDir: no .FOR on the hll stack\n"));

	lea	rcx, OFFSET FLAT:$SG11718
	call	DoDebugMsg

; 1467 :       EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 80					; 00000050H
	call	EmitErr

; 1468 :       return(ERROR);

	mov	eax, -1
	jmp	$LN1@HllEndDir
$LN9@HllEndDir:

; 1469 :     }
; 1470 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1471 :     //Insert .CONTINUE label here if there is any 
; 1472 :     if (hll->labels[LCONT])

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN10@HllEndDir

; 1473 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LCONT], buff));

	mov	eax, 4
	imul	rax, rax, 4
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11720
	call	AddLineQueueX
$LN10@HllEndDir:

; 1474 :     //forever loop '.for (::)'
; 1475 :     if (hll->cmcnt == 0) goto adlabel;

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+48], 0
	jne	SHORT $LN11@HllEndDir
	jmp	$adlabel$41
	jmp	$LN12@HllEndDir
$LN11@HllEndDir:

; 1476 :     //If counters exist  
; 1477 :     else if (hll->counterlines[0]){

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN13@HllEndDir

; 1478 :       //here we write counters
; 1479 :       if (hll->counterlines) {      //if there is something after second ':' expand it here

	mov	rax, QWORD PTR hll$[rsp]
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN15@HllEndDir

; 1480 :         ForInitAndNext(tokenarray, hll->cmcnt, hll->counterlines);

	mov	rax, QWORD PTR hll$[rsp]
	mov	r8, QWORD PTR [rax+40]
	mov	rax, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rax+48]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	ForInitAndNext
$LN15@HllEndDir:

; 1481 :         LclFree(hll->counterlines);
; 1482 :       } 
; 1483 :       //first jump from the top happens here after the counters
; 1484 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSKIP], buff));

	mov	eax, 4
	imul	rax, rax, 3
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11726
	call	AddLineQueueX

; 1485 :       /* create test label */
; 1486 :       if (hll->labels[LTEST]) {

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN16@HllEndDir

; 1487 :         AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	mov	eax, 4
	imul	rax, rax, 0
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11728
	call	AddLineQueueX
$LN16@HllEndDir:

; 1488 :       }
; 1489 :       QueueTestLines(hll->condlines);

	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rax+32]
	call	QueueTestLines

; 1490 :       LclFree(hll->condlines);
; 1491 :     }

	jmp	SHORT $LN14@HllEndDir
$LN13@HllEndDir:

; 1492 :     else
; 1493 :       AddLineQueueX(" jmp %s", GetLabelStr(hll->labels[LSTART], buff));

	mov	eax, 4
	imul	rax, rax, 2
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11729
	call	AddLineQueueX
$LN14@HllEndDir:
$LN12@HllEndDir:

; 1494 :     if (!hll->cond)

	mov	rax, QWORD PTR hll$[rsp]
	movzx	eax, BYTE PTR [rax+56]
	test	eax, eax
	jne	SHORT $LN17@HllEndDir
$adlabel$41:

; 1495 :  adlabel:
; 1496 :       AddLineQueueX(" jmp %s", GetLabelStr(hll->labels[LSTART], buff));

	mov	eax, 4
	imul	rax, rax, 2
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11731
	call	AddLineQueueX
$LN17@HllEndDir:

; 1497 :     tokenarray[i].token = T_FINAL;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 1498 :     break;

	jmp	$LN2@HllEndDir
$LN18@HllEndDir:

; 1499 :     //end of .ENDFOR
; 1500 :   case T_DOT_ENDW:
; 1501 :     if (hll->cmd != HLL_WHILE) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+52], 1
	je	SHORT $LN19@HllEndDir

; 1502 :       DebugMsg(("HllEndDir: no .WHILE on the hll stack\n"));

	lea	rcx, OFFSET FLAT:$SG11734
	call	DoDebugMsg

; 1503 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 80					; 00000050H
	call	EmitErr
	jmp	$LN1@HllEndDir
$LN19@HllEndDir:

; 1504 :     }
; 1505 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1506 :     /* create test label */
; 1507 :     if (hll->labels[LTEST]) {

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN20@HllEndDir

; 1508 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	mov	eax, 4
	imul	rax, rax, 0
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11736
	call	AddLineQueueX
$LN20@HllEndDir:

; 1509 :     }
; 1510 :     QueueTestLines(hll->condlines);

	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rax+32]
	call	QueueTestLines

; 1511 :     LclFree(hll->condlines);
; 1512 :     break;

	jmp	$LN2@HllEndDir
$LN21@HllEndDir:

; 1513 :   case T_DOT_UNTILCXZ:
; 1514 :     if (hll->cmd != HLL_REPEAT) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+52], 2
	je	SHORT $LN22@HllEndDir

; 1515 :       DebugMsg(("HllEndDir: no .REPEAT on the hll stack\n"));

	lea	rcx, OFFSET FLAT:$SG11739
	call	DoDebugMsg

; 1516 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 80					; 00000050H
	call	EmitErr
	jmp	$LN1@HllEndDir
$LN22@HllEndDir:

; 1517 :     }
; 1518 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1519 :     if (hll->labels[LTEST]) /* v2.11: LTEST only needed if .CONTINUE has occured */

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN23@HllEndDir

; 1520 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	mov	eax, 4
	imul	rax, rax, 0
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11741
	call	AddLineQueueX
$LN23@HllEndDir:

; 1521 : 
; 1522 :     /* read in optional (simple) expression */
; 1523 :     if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN24@HllEndDir

; 1524 :       rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, FALSE, buffer);

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], 0
	mov	r9d, 2
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	EvaluateHllExpression
	mov	DWORD PTR rc$[rsp], eax

; 1525 :       if (rc == NOT_ERROR) {

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN26@HllEndDir

; 1526 :         rc = CheckCXZLines(buffer);

	lea	rcx, QWORD PTR buffer$[rsp]
	call	CheckCXZLines
	mov	DWORD PTR rc$[rsp], eax

; 1527 :         if (rc == NOT_ERROR)

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN27@HllEndDir

; 1528 :           QueueTestLines(buffer); /* write condition lines */

	lea	rcx, QWORD PTR buffer$[rsp]
	call	QueueTestLines
	jmp	SHORT $LN28@HllEndDir
$LN27@HllEndDir:

; 1529 :         else
; 1530 :           EmitError(EXPR_TOO_COMPLEX_FOR_UNTILCXZ);

	mov	ecx, 191				; 000000bfH
	call	EmitError
$LN28@HllEndDir:
$LN26@HllEndDir:

; 1531 :       }
; 1532 :     }

	jmp	SHORT $LN25@HllEndDir
$LN24@HllEndDir:

; 1533 :     else {
; 1534 :       AddLineQueueX(JMPPREFIX "loop %s", GetLabelStr(hll->labels[LSTART], buff));

	mov	eax, 4
	imul	rax, rax, 2
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11747
	call	AddLineQueueX
$LN25@HllEndDir:

; 1535 :     }
; 1536 :     break;

	jmp	$LN2@HllEndDir
$LN29@HllEndDir:

; 1537 :   case T_DOT_UNTIL:
; 1538 :     if (hll->cmd != HLL_REPEAT) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+52], 2
	je	SHORT $LN30@HllEndDir

; 1539 :       DebugMsg(("HllEndDir: no .REPEAT on the hll stack\n"));

	lea	rcx, OFFSET FLAT:$SG11750
	call	DoDebugMsg

; 1540 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 80					; 00000050H
	call	EmitErr
	jmp	$LN1@HllEndDir
$LN30@HllEndDir:

; 1541 :     }
; 1542 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1543 :     if (hll->labels[LTEST]) /* v2.11: LTEST only needed if .CONTINUE has occured */

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN31@HllEndDir

; 1544 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	mov	eax, 4
	imul	rax, rax, 0
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11752
	call	AddLineQueueX
$LN31@HllEndDir:

; 1545 : 
; 1546 :     /* read in (optional) expression */
; 1547 :     /* if expression is missing, just generate nothing */
; 1548 :     if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN32@HllEndDir

; 1549 :       rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, FALSE, buffer);

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], 0
	mov	r9d, 2
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	EvaluateHllExpression
	mov	DWORD PTR rc$[rsp], eax

; 1550 :       if (rc == NOT_ERROR)

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN33@HllEndDir

; 1551 :         QueueTestLines(buffer); /* write condition lines */

	lea	rcx, QWORD PTR buffer$[rsp]
	call	QueueTestLines
$LN33@HllEndDir:
$LN32@HllEndDir:

; 1552 :     }
; 1553 :     break;

	jmp	SHORT $LN2@HllEndDir
$LN34@HllEndDir:

; 1554 : #ifdef DEBUG_OUT
; 1555 :   default: /**/myassert(0); break;

	mov	edx, 1555				; 00000613H
	lea	rcx, OFFSET FLAT:$SG11756
	call	InternalError
$LN2@HllEndDir:

; 1556 : #endif
; 1557 :   }
; 1558 : 
; 1559 :   /* create the exit label if it has been referenced */
; 1560 :   if (hll->labels[LEXIT])

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN35@HllEndDir

; 1561 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11758
	call	AddLineQueueX
$LN35@HllEndDir:

; 1562 : 
; 1563 :   if (tokenarray[i].token != T_FINAL && rc == NOT_ERROR) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN36@HllEndDir
	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN36@HllEndDir

; 1564 :     EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1565 :     rc = ERROR;

	mov	DWORD PTR rc$[rsp], -1
$LN36@HllEndDir:

; 1566 :   }
; 1567 :   if (ModuleInfo.list)

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN37@HllEndDir

; 1568 :     LstWrite(LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL);

	call	GetCurrOffset
	xor	r8d, r8d
	mov	edx, eax
	mov	ecx, 4
	call	LstWrite
$LN37@HllEndDir:

; 1569 : 
; 1570 :   /* v2.11: always run line-queue if it's not empty. */
; 1571 :   if (is_linequeue_populated())

	cmp	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN38@HllEndDir

; 1572 :     RunLineQueue();

	call	RunLineQueue
$LN38@HllEndDir:

; 1573 : 
; 1574 :   return(rc);

	mov	eax, DWORD PTR rc$[rsp]
$LN1@HllEndDir:

; 1575 : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:HllEndDir$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1360				; 00000550H
	pop	rdi
	ret	0
HllEndDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
hll$ = 48
rc$ = 56
cmd$ = 60
buff$ = 72
buffer$ = 128
forbuff$ = 2896
forbuffinit$ = 3536
forbuffcond$ = 4176
forbuffcnt$ = 4816
transformed$ = 5456
j$ = 6072
b$ = 6076
size$ = 6084
eqcnt$ = 6088
cmcnt$ = 6092
p$ = 6096
c$ = 6104
size$15 = 6108
$T16 = 6120
$T17 = 6128
$T18 = 6136
$T19 = 6144
$T20 = 6152
$T21 = 6160
$T22 = 6168
$T23 = 6176
$T24 = 6184
tv83 = 6192
__$ArrayPad$ = 6200
i$ = 6224
tokenarray$ = 6232
HllStartDir PROC

; 1157 : {

$LN76:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	mov	eax, 6208				; 00001840H
	call	__chkstk
	sub	rsp, rax
	mov	rdi, rsp
	mov	ecx, 1552				; 00000610H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+6224]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1158 :   struct hll_item      *hll;
; 1159 :   ret_code             rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 1160 :   int                  cmd = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR cmd$[rsp], eax

; 1161 :   char buff[16];
; 1162 :   char buffer[MAX_LINE_LEN * 2];
; 1163 :   char codebuff[256];
; 1164 :   char param[256];
; 1165 :   char init[256];
; 1166 :   char limit[MAX_LINE_LEN];
; 1167 :   char op[4];
; 1168 :   char forbuff[MAX_LINE_LEN];
; 1169 :   char forbuffinit[MAX_LINE_LEN];
; 1170 :   char forbuffcond[MAX_LINE_LEN];
; 1171 :   char forbuffcnt[MAX_LINE_LEN];
; 1172 :   char transformed[MAX_LINE_LEN];
; 1173 :   int a;
; 1174 :   int j;
; 1175 :   int b;
; 1176 :   int e;
; 1177 :   int size;
; 1178 :   int eqcnt;
; 1179 :   int cmcnt;
; 1180 :   char *p;
; 1181 :   char c;
; 1182 : 
; 1183 :   DebugMsg1(("HllStartDir(%s) enter\n", tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11635
	call	DoDebugMsg1

; 1184 : 
; 1185 :   i++; /* skip directive */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1186 : 
; 1187 :   /* v2.06: is there an item on the free stack? */
; 1188 :   if (HllFree) {

	cmp	QWORD PTR ModuleInfo+232, 0
	je	SHORT $LN16@HllStartDi

; 1189 :     hll = HllFree;

	mov	rax, QWORD PTR ModuleInfo+232
	mov	QWORD PTR hll$[rsp], rax

; 1190 :     DebugCmd(cntReused++);

	mov	eax, DWORD PTR cntReused
	inc	eax
	mov	DWORD PTR cntReused, eax

; 1191 :   }

	jmp	SHORT $LN17@HllStartDi
$LN16@HllStartDi:

; 1192 :   else {
; 1193 :     hll = LclAlloc(sizeof(struct hll_item));

	mov	ecx, 64					; 00000040H
	call	LclAlloc
	mov	QWORD PTR hll$[rsp], rax

; 1194 :     DebugCmd(cntAlloc++);

	mov	eax, DWORD PTR cntAlloc
	inc	eax
	mov	DWORD PTR cntAlloc, eax
$LN17@HllStartDi:

; 1195 :   }
; 1196 : 
; 1197 :   /* structure for .IF .ELSE .ENDIF
; 1198 :   *    cond jump to LTEST-label
; 1199 :   *    ...
; 1200 :   *    jmp LEXIT
; 1201 :   *  LTEST:
; 1202 :   *    ...
; 1203 :   *  LEXIT:
; 1204 : 
; 1205 :   * structure for .IF .ELSEIF
; 1206 :   *    cond jump to LTEST
; 1207 :   *    ...
; 1208 :   *    jmp LEXIT
; 1209 :   *  LTEST:
; 1210 :   *    cond jump to (new) LTEST
; 1211 :   *    ...
; 1212 :   *    jmp LEXIT
; 1213 :   *  LTEST:
; 1214 :   *    ...
; 1215 : 
; 1216 :   * structure for .WHILE and .REPEAT:
; 1217 :   *   jmp LTEST (for .WHILE only)
; 1218 :   * LSTART:
; 1219 :   *   ...
; 1220 :   * LTEST: (jumped to by .continue)
; 1221 :   *   a) test end condition, cond jump to LSTART label
; 1222 :   *   b) unconditional jump to LSTART label
; 1223 :   * LEXIT: (jumped to by .BREAK)
; 1224 :   */
; 1225 : 
; 1226 :   hll->labels[LEXIT] = 0;

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0

; 1227 : 
; 1228 :   switch (cmd) {

	mov	eax, DWORD PTR cmd$[rsp]
	mov	DWORD PTR tv83[rsp], eax
	cmp	DWORD PTR tv83[rsp], 327		; 00000147H
	je	SHORT $LN18@HllStartDi
	cmp	DWORD PTR tv83[rsp], 327		; 00000147H
	jle	$LN52@HllStartDi
	cmp	DWORD PTR tv83[rsp], 329		; 00000149H
	jle	$LN45@HllStartDi
	cmp	DWORD PTR tv83[rsp], 330		; 0000014aH
	je	$LN21@HllStartDi
	jmp	$LN52@HllStartDi
$LN18@HllStartDi:

; 1229 :   case T_DOT_IF:
; 1230 :     hll->labels[LSTART] = 0; /* not used by .IF */

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0

; 1231 :     hll->labels[LTEST] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1232 :     hll->cmd = HLL_IF;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+52], 0

; 1233 :     hll->flags = 0;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+60], 0

; 1234 :     /* get the C-style expression, convert to ASM code lines */
; 1235 :     rc = EvaluateHllExpression(hll, &i, tokenarray, LTEST, FALSE, buffer);

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	EvaluateHllExpression
	mov	DWORD PTR rc$[rsp], eax

; 1236 :     if (rc == NOT_ERROR) {

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN19@HllStartDi

; 1237 :       QueueTestLines(buffer);

	lea	rcx, QWORD PTR buffer$[rsp]
	call	QueueTestLines

; 1238 :       /* if no lines have been created, the LTEST label isn't needed */
; 1239 :       //if ( !is_linequeue_populated() ) {
; 1240 :       if (buffer[0] == NULLC) {

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR buffer$[rsp+rax]
	test	eax, eax
	jne	SHORT $LN20@HllStartDi

; 1241 :         hll->labels[LTEST] = 0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0
$LN20@HllStartDi:
$LN19@HllStartDi:

; 1242 :       }
; 1243 :     }
; 1244 :     break;

	jmp	$LN2@HllStartDi
$LN21@HllStartDi:

; 1245 :     // added by habran
; 1246 :   case T_DOT_FOR:
; 1247 :     /* create the label to loop start */
; 1248 :     hll->labels[LEXIT] = 0; //this is needed for .FOR loop

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0

; 1249 :     hll->labels[LSTART] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1250 :     hll->labels[LSKIP] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1251 :     hll->labels[LCONT] = 0;

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0

; 1252 :     hll->labels[LTEST] = 0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0

; 1253 :     hll->flags = 0;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+60], 0

; 1254 :     hll->cmd = HLL_FOR;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+52], 4

; 1255 :     //copy string to the buffer and get read of spaces
; 1256 :     p = tokenarray[i].tokpos;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR p$[rsp], rax

; 1257 :     for (b = 0; *p; p++)

	mov	DWORD PTR b$[rsp], 0
	jmp	SHORT $LN6@HllStartDi
$LN4@HllStartDi:
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN6@HllStartDi:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN5@HllStartDi

; 1258 :     {
; 1259 :       if ((*p == ' ') || (*p == '\t')) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN24@HllStartDi
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 9
	jne	SHORT $LN22@HllStartDi
$LN24@HllStartDi:

; 1260 :         //if there is QWORD PTR, DWORD PTR, WORD PTR, BYTE PTR, OFFSET or ADDR leave a space between
; 1261 :         c = tolower(*(p + 1));

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	mov	ecx, eax
	call	QWORD PTR __imp_tolower
	mov	BYTE PTR c$[rsp], al

; 1262 :         if ((c >= 'a') && (c <= 'z')){

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN25@HllStartDi
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 122				; 0000007aH
	jg	SHORT $LN25@HllStartDi

; 1263 :           forbuff[b] = *p;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR forbuff$[rsp+rax], cl

; 1264 :           b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax
$LN25@HllStartDi:

; 1265 :         }
; 1266 :       }

	jmp	SHORT $LN23@HllStartDi
$LN22@HllStartDi:

; 1267 :       else {
; 1268 :         forbuff[b] = *p;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR forbuff$[rsp+rax], cl

; 1269 :         b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax
$LN23@HllStartDi:

; 1270 :       }
; 1271 :     }

	jmp	$LN4@HllStartDi
$LN5@HllStartDi:

; 1272 :     forbuff[b] = NULLC;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	QWORD PTR $T16[rsp], rax
	cmp	QWORD PTR $T16[rsp], 600		; 00000258H
	jae	SHORT $LN58@HllStartDi
	jmp	SHORT $LN59@HllStartDi
$LN58@HllStartDi:
	call	__report_rangecheckfailure
$LN59@HllStartDi:
	mov	rax, QWORD PTR $T16[rsp]
	mov	BYTE PTR forbuff$[rsp+rax], 0

; 1273 :     if (0 == _memicmp(forbuff, "(::)", 4)){

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11648
	lea	rcx, QWORD PTR forbuff$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN26@HllStartDi

; 1274 :       hll->cmcnt = 0;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+48], 0

; 1275 :     }

	jmp	$LN27@HllStartDi
$LN26@HllStartDi:

; 1276 :     else {
; 1277 :       //count initializers
; 1278 :       eqcnt = 1;

	mov	DWORD PTR eqcnt$[rsp], 1

; 1279 :       forbuffinit[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	QWORD PTR $T17[rsp], rax
	cmp	QWORD PTR $T17[rsp], 600		; 00000258H
	jae	SHORT $LN60@HllStartDi
	jmp	SHORT $LN61@HllStartDi
$LN60@HllStartDi:
	call	__report_rangecheckfailure
$LN61@HllStartDi:
	mov	rax, QWORD PTR $T17[rsp]
	mov	BYTE PTR forbuffinit$[rsp+rax], 0

; 1280 :       for (j = 1, b = 0; forbuff[j];){

	mov	DWORD PTR j$[rsp], 1
	mov	DWORD PTR b$[rsp], 0
$LN7@HllStartDi:
	movsxd	rax, DWORD PTR j$[rsp]
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	test	eax, eax
	je	$LN8@HllStartDi

; 1281 :         c = forbuff[j];

	movsxd	rax, DWORD PTR j$[rsp]
	movzx	eax, BYTE PTR forbuff$[rsp+rax]
	mov	BYTE PTR c$[rsp], al

; 1282 :         if (c == ':') {

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN28@HllStartDi

; 1283 :           if (forbuff[j - 1] != 39 && forbuff[j + 1] != 39) break;

	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	cdqe
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN29@HllStartDi
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	cdqe
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN29@HllStartDi
	jmp	$LN8@HllStartDi
$LN29@HllStartDi:
$LN28@HllStartDi:

; 1284 :         }
; 1285 :         if (c == ',' && forbuff[j - 1] != 39 && forbuff[j + 1] != 39) eqcnt++;

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN30@HllStartDi
	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	cdqe
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN30@HllStartDi
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	cdqe
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN30@HllStartDi
	mov	eax, DWORD PTR eqcnt$[rsp]
	inc	eax
	mov	DWORD PTR eqcnt$[rsp], eax
$LN30@HllStartDi:

; 1286 :         forbuffinit[b] = c;

	movsxd	rax, DWORD PTR b$[rsp]
	movzx	ecx, BYTE PTR c$[rsp]
	mov	BYTE PTR forbuffinit$[rsp+rax], cl

; 1287 :         if (c == 39 && forbuffinit[b - 2] == 39){

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN31@HllStartDi
	mov	eax, DWORD PTR b$[rsp]
	sub	eax, 2
	cdqe
	movsx	eax, BYTE PTR forbuffinit$[rsp+rax]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN31@HllStartDi

; 1288 :           b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 1289 :           forbuffinit[b] = ' ';

	movsxd	rax, DWORD PTR b$[rsp]
	mov	BYTE PTR forbuffinit$[rsp+rax], 32	; 00000020H
$LN31@HllStartDi:

; 1290 :         }
; 1291 :         j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax

; 1292 :         b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 1293 :       }

	jmp	$LN7@HllStartDi
$LN8@HllStartDi:

; 1294 :       forbuffinit[b] = NULLC;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	QWORD PTR $T18[rsp], rax
	cmp	QWORD PTR $T18[rsp], 600		; 00000258H
	jae	SHORT $LN62@HllStartDi
	jmp	SHORT $LN63@HllStartDi
$LN62@HllStartDi:
	call	__report_rangecheckfailure
$LN63@HllStartDi:
	mov	rax, QWORD PTR $T18[rsp]
	mov	BYTE PTR forbuffinit$[rsp+rax], 0

; 1295 :       j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax

; 1296 :       //coppy the condition to the buffer
; 1297 :       forbuffcond[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	QWORD PTR $T19[rsp], rax
	cmp	QWORD PTR $T19[rsp], 600		; 00000258H
	jae	SHORT $LN64@HllStartDi
	jmp	SHORT $LN65@HllStartDi
$LN64@HllStartDi:
	call	__report_rangecheckfailure
$LN65@HllStartDi:
	mov	rax, QWORD PTR $T19[rsp]
	mov	BYTE PTR forbuffcond$[rsp+rax], 0

; 1298 :       hll->labels[LTEST] = 0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0

; 1299 :       for (b = 0; forbuff[j] && forbuff[j] != ':'; forbuffcond[b] = forbuff[j], j++, b++);

	mov	DWORD PTR b$[rsp], 0
	jmp	SHORT $LN12@HllStartDi
$LN10@HllStartDi:
	movsxd	rax, DWORD PTR j$[rsp]
	movsxd	rcx, DWORD PTR b$[rsp]
	movzx	eax, BYTE PTR forbuff$[rsp+rax]
	mov	BYTE PTR forbuffcond$[rsp+rcx], al
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax
$LN12@HllStartDi:
	movsxd	rax, DWORD PTR j$[rsp]
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	test	eax, eax
	je	SHORT $LN11@HllStartDi
	movsxd	rax, DWORD PTR j$[rsp]
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN11@HllStartDi
	jmp	SHORT $LN10@HllStartDi
$LN11@HllStartDi:

; 1300 :       if (forbuffcond[b - 2] == '>' && forbuffcond[b - 1] == '0') forbuffcond[b - 2] = NULLC;

	mov	eax, DWORD PTR b$[rsp]
	sub	eax, 2
	cdqe
	movsx	eax, BYTE PTR forbuffcond$[rsp+rax]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN32@HllStartDi
	mov	eax, DWORD PTR b$[rsp]
	dec	eax
	cdqe
	movsx	eax, BYTE PTR forbuffcond$[rsp+rax]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN32@HllStartDi
	mov	eax, DWORD PTR b$[rsp]
	sub	eax, 2
	cdqe
	mov	QWORD PTR $T20[rsp], rax
	cmp	QWORD PTR $T20[rsp], 600		; 00000258H
	jae	SHORT $LN66@HllStartDi
	jmp	SHORT $LN67@HllStartDi
$LN66@HllStartDi:
	call	__report_rangecheckfailure
$LN67@HllStartDi:
	mov	rax, QWORD PTR $T20[rsp]
	mov	BYTE PTR forbuffcond$[rsp+rax], 0
$LN32@HllStartDi:

; 1301 :       forbuffcond[b] = NULLC;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	QWORD PTR $T21[rsp], rax
	cmp	QWORD PTR $T21[rsp], 600		; 00000258H
	jae	SHORT $LN68@HllStartDi
	jmp	SHORT $LN69@HllStartDi
$LN68@HllStartDi:
	call	__report_rangecheckfailure
$LN69@HllStartDi:
	mov	rax, QWORD PTR $T21[rsp]
	mov	BYTE PTR forbuffcond$[rsp+rax], 0

; 1302 :       if (!b) hll->cond = FALSE;

	cmp	DWORD PTR b$[rsp], 0
	jne	SHORT $LN33@HllStartDi
	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+56], 0
	jmp	SHORT $LN34@HllStartDi
$LN33@HllStartDi:

; 1303 :       else    hll->cond = TRUE;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+56], 1
$LN34@HllStartDi:

; 1304 :       j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax

; 1305 :       //copy the counter to the buffer
; 1306 :       cmcnt = 0;

	mov	DWORD PTR cmcnt$[rsp], 0

; 1307 :       forbuffcnt[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	QWORD PTR $T22[rsp], rax
	cmp	QWORD PTR $T22[rsp], 600		; 00000258H
	jae	SHORT $LN70@HllStartDi
	jmp	SHORT $LN71@HllStartDi
$LN70@HllStartDi:
	call	__report_rangecheckfailure
$LN71@HllStartDi:
	mov	rax, QWORD PTR $T22[rsp]
	mov	BYTE PTR forbuffcnt$[rsp+rax], 0

; 1308 :       hll->condlines = "";

	mov	rax, QWORD PTR hll$[rsp]
	lea	rcx, OFFSET FLAT:$SG11656
	mov	QWORD PTR [rax+32], rcx

; 1309 :       for (b = 0; forbuff[j] != ')';b++,j++){

	mov	DWORD PTR b$[rsp], 0
	jmp	SHORT $LN15@HllStartDi
$LN13@HllStartDi:
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN15@HllStartDi:
	movsxd	rax, DWORD PTR j$[rsp]
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	cmp	eax, 41					; 00000029H
	je	$LN14@HllStartDi

; 1310 :         forbuffcnt[b] = forbuff[j];

	movsxd	rax, DWORD PTR j$[rsp]
	movsxd	rcx, DWORD PTR b$[rsp]
	movzx	eax, BYTE PTR forbuff$[rsp+rax]
	mov	BYTE PTR forbuffcnt$[rsp+rcx], al

; 1311 :         if (forbuffcnt[b] == ',' && forbuff[j - 1] != 39 && forbuff[j + 1] != 39) ++cmcnt;

	movsxd	rax, DWORD PTR b$[rsp]
	movsx	eax, BYTE PTR forbuffcnt$[rsp+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN35@HllStartDi
	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	cdqe
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN35@HllStartDi
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	cdqe
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN35@HllStartDi
	mov	eax, DWORD PTR cmcnt$[rsp]
	inc	eax
	mov	DWORD PTR cmcnt$[rsp], eax
$LN35@HllStartDi:

; 1312 :         if (forbuffcnt[b] == 39 && forbuffcnt[b - 2] == 39){

	movsxd	rax, DWORD PTR b$[rsp]
	movsx	eax, BYTE PTR forbuffcnt$[rsp+rax]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN36@HllStartDi
	mov	eax, DWORD PTR b$[rsp]
	sub	eax, 2
	cdqe
	movsx	eax, BYTE PTR forbuffcnt$[rsp+rax]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN36@HllStartDi

; 1313 :           b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 1314 :           forbuffcnt[b] = ' ';

	movsxd	rax, DWORD PTR b$[rsp]
	mov	BYTE PTR forbuffcnt$[rsp+rax], 32	; 00000020H
$LN36@HllStartDi:

; 1315 :         }
; 1316 :       }

	jmp	$LN13@HllStartDi
$LN14@HllStartDi:

; 1317 :       if (forbuffcnt[b - 1] == ')') b--;

	mov	eax, DWORD PTR b$[rsp]
	dec	eax
	cdqe
	movsx	eax, BYTE PTR forbuffcnt$[rsp+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN37@HllStartDi
	mov	eax, DWORD PTR b$[rsp]
	dec	eax
	mov	DWORD PTR b$[rsp], eax
$LN37@HllStartDi:

; 1318 :       forbuffcnt[b] = NULLC;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	QWORD PTR $T23[rsp], rax
	cmp	QWORD PTR $T23[rsp], 600		; 00000258H
	jae	SHORT $LN72@HllStartDi
	jmp	SHORT $LN73@HllStartDi
$LN72@HllStartDi:
	call	__report_rangecheckfailure
$LN73@HllStartDi:
	mov	rax, QWORD PTR $T23[rsp]
	mov	BYTE PTR forbuffcnt$[rsp+rax], 0

; 1319 :       //create valid command and add to LineQueue to initiate .for loop vars
; 1320 :       //anything that is before the first ':'
; 1321 :       if (forbuffinit[0]) ForInitAndNext(tokenarray, eqcnt, forbuffinit);

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR forbuffinit$[rsp+rax]
	test	eax, eax
	je	SHORT $LN38@HllStartDi
	lea	r8, QWORD PTR forbuffinit$[rsp]
	mov	edx, DWORD PTR eqcnt$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	ForInitAndNext
$LN38@HllStartDi:

; 1322 :       //note hll->counterlines is new var in the struct hll_item for store of forbuffcnt used in .ENDFOR
; 1323 :       //hll->cmcnt is also new var in the struct hll_item for commas counter used in .ENDFOR
; 1324 :       //copy forbuffcnt context to hll->counterlines 
; 1325 :       //forbuffcnt contains anything that is written after the second ':'
; 1326 :       hll->cmcnt = 0;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+48], 0

; 1327 :       if (forbuffcnt[0])

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR forbuffcnt$[rsp+rax]
	test	eax, eax
	je	$LN39@HllStartDi

; 1328 :       {
; 1329 :       //skip altering conditions the first time
; 1330 :         AddLineQueueX(" jmp %s", GetLabelStr(hll->labels[LSKIP], buff));

	mov	eax, 4
	imul	rax, rax, 3
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11663
	call	AddLineQueueX

; 1331 :         size = strlen(forbuffcnt) + 1;

	lea	rcx, QWORD PTR forbuffcnt$[rsp]
	call	strlen
	inc	rax
	mov	DWORD PTR size$[rsp], eax

; 1332 :         hll->counterlines = LclAlloc(size);

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR hll$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 1333 :         memcpy(hll->counterlines, forbuffcnt, size);

	movsxd	rax, DWORD PTR size$[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR forbuffcnt$[rsp]
	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rax+40]
	call	memcpy

; 1334 :         hll->cmcnt = cmcnt + 1;

	mov	eax, DWORD PTR cmcnt$[rsp]
	inc	eax
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+48], eax

; 1335 :       }

	jmp	SHORT $LN40@HllStartDi
$LN39@HllStartDi:

; 1336 :       else hll->counterlines = "";    //there is nothing after the second ':'

	mov	rax, QWORD PTR hll$[rsp]
	lea	rcx, OFFSET FLAT:$SG11664
	mov	QWORD PTR [rax+40], rcx
$LN40@HllStartDi:

; 1337 :       if (forbuffcond[0]){

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR forbuffcond$[rsp+rax]
	test	eax, eax
	je	$LN41@HllStartDi

; 1338 :         strcpy(transformed, ".for ");

	lea	rdx, OFFSET FLAT:$SG11666
	lea	rcx, QWORD PTR transformed$[rsp]
	call	strcpy

; 1339 :         strcat(transformed, forbuffcond);

	lea	rdx, QWORD PTR forbuffcond$[rsp]
	lea	rcx, QWORD PTR transformed$[rsp]
	call	strcat

; 1340 :         strcat(transformed, "\0");

	lea	rdx, OFFSET FLAT:$SG11667
	lea	rcx, QWORD PTR transformed$[rsp]
	call	strcat

; 1341 :         tokenarray[0].string_ptr = ".for\0";

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	lea	rdx, OFFSET FLAT:$SG11668
	mov	QWORD PTR [rcx+rax+8], rdx

; 1342 :         tokenarray[0].tokpos = transformed;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR transformed$[rsp]
	mov	QWORD PTR [rcx+rax+24], rdx

; 1343 :         Token_Count = Tokenize(tokenarray[0].tokpos, 0, tokenarray, 0);

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+24]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 1344 :         if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN42@HllStartDi

; 1345 :           rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, TRUE, buffer);

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], 1
	mov	r9d, 2
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	EvaluateHllExpression
	mov	DWORD PTR rc$[rsp], eax

; 1346 :           if (rc == NOT_ERROR) {

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN44@HllStartDi

; 1347 :             size = strlen(buffer) + 1;

	lea	rcx, QWORD PTR buffer$[rsp]
	call	strlen
	inc	rax
	mov	DWORD PTR size$[rsp], eax

; 1348 :             hll->condlines = LclAlloc(size);

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR hll$[rsp]
	mov	QWORD PTR [rcx+32], rax

; 1349 :             memcpy(hll->condlines, buffer, size);

	movsxd	rax, DWORD PTR size$[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rax+32]
	call	memcpy

; 1350 :             DebugCmd(cntCond++); DebugCmd(cntCondBytes += size);

	mov	eax, DWORD PTR cntCond
	inc	eax
	mov	DWORD PTR cntCond, eax
	mov	eax, DWORD PTR size$[rsp]
	mov	ecx, DWORD PTR cntCondBytes
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR cntCondBytes, eax
$LN44@HllStartDi:

; 1351 :           }
; 1352 :         }

	jmp	SHORT $LN43@HllStartDi
$LN42@HllStartDi:

; 1353 :         else
; 1354 :           hll->condlines = "";

	mov	rax, QWORD PTR hll$[rsp]
	lea	rcx, OFFSET FLAT:$SG11672
	mov	QWORD PTR [rax+32], rcx
$LN43@HllStartDi:
$LN41@HllStartDi:
$LN27@HllStartDi:

; 1355 :       }
; 1356 :     }
; 1357 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSTART], buff));

	mov	eax, 4
	imul	rax, rax, 2
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11673
	call	AddLineQueueX

; 1358 :     tokenarray[i].token = T_FINAL;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 1359 :     break;

	jmp	$LN2@HllStartDi
$LN45@HllStartDi:

; 1360 :     //end of .FOR
; 1361 :   case T_DOT_WHILE:
; 1362 :   case T_DOT_REPEAT:
; 1363 :     /* create the label to start of loop */
; 1364 :     hll->labels[LSTART] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1365 :     hll->labels[LTEST] = 0; /* v2.11: test label is created only if needed */

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0

; 1366 :     //hll->labels[LEXIT] = GetHllLabel(); /* v2.11: LEXIT is only needed for .BREAK */
; 1367 :     if (cmd == T_DOT_WHILE) {

	cmp	DWORD PTR cmd$[rsp], 329		; 00000149H
	jne	$LN46@HllStartDi

; 1368 :       hll->cmd = HLL_WHILE;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+52], 1

; 1369 :       hll->condlines = NULL;

	mov	rax, QWORD PTR hll$[rsp]
	mov	QWORD PTR [rax+32], 0

; 1370 :       if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN48@HllStartDi

; 1371 :         rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, TRUE, buffer);

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], 1
	mov	r9d, 2
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	EvaluateHllExpression
	mov	DWORD PTR rc$[rsp], eax

; 1372 :         if (rc == NOT_ERROR) {

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN50@HllStartDi

; 1373 :           int size;
; 1374 :           size = strlen(buffer) + 1;

	lea	rcx, QWORD PTR buffer$[rsp]
	call	strlen
	inc	rax
	mov	DWORD PTR size$15[rsp], eax

; 1375 :           hll->condlines = LclAlloc(size);

	movsxd	rax, DWORD PTR size$15[rsp]
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR hll$[rsp]
	mov	QWORD PTR [rcx+32], rax

; 1376 :           memcpy(hll->condlines, buffer, size);

	movsxd	rax, DWORD PTR size$15[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rax+32]
	call	memcpy

; 1377 :           DebugCmd(cntCond++); DebugCmd(cntCondBytes += size);

	mov	eax, DWORD PTR cntCond
	inc	eax
	mov	DWORD PTR cntCond, eax
	mov	eax, DWORD PTR size$15[rsp]
	mov	ecx, DWORD PTR cntCondBytes
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR cntCondBytes, eax
$LN50@HllStartDi:

; 1378 :         }
; 1379 :       }

	jmp	SHORT $LN49@HllStartDi
$LN48@HllStartDi:

; 1380 :       else
; 1381 :         buffer[0] = NULLC;  /* just ".while" without expression is accepted */

	mov	eax, 1
	imul	rax, rax, 0
	mov	QWORD PTR $T24[rsp], rax
	cmp	QWORD PTR $T24[rsp], 1200		; 000004b0H
	jae	SHORT $LN74@HllStartDi
	jmp	SHORT $LN75@HllStartDi
$LN74@HllStartDi:
	call	__report_rangecheckfailure
$LN75@HllStartDi:
	mov	rax, QWORD PTR $T24[rsp]
	mov	BYTE PTR buffer$[rsp+rax], 0
$LN49@HllStartDi:

; 1382 : 
; 1383 :       /* create a jump to test label */
; 1384 :       /* optimisation: if line at 'test' label is just a jump, dont create label and don't jump! */
; 1385 :       if (_memicmp(buffer, "jmp", 3)) {

	mov	r8d, 3
	lea	rdx, OFFSET FLAT:$SG11681
	lea	rcx, QWORD PTR buffer$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	je	SHORT $LN51@HllStartDi

; 1386 :         hll->labels[LTEST] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1387 :         AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[LTEST], buff));

	mov	eax, 4
	imul	rax, rax, 0
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11682
	call	AddLineQueueX
$LN51@HllStartDi:

; 1388 :       }
; 1389 :     }

	jmp	SHORT $LN47@HllStartDi
$LN46@HllStartDi:

; 1390 :     else {
; 1391 :       hll->cmd = HLL_REPEAT;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+52], 2
$LN47@HllStartDi:

; 1392 :     }
; 1393 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSTART], buff));

	mov	eax, 4
	imul	rax, rax, 2
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11683
	call	AddLineQueueX

; 1394 :     break;

	jmp	SHORT $LN2@HllStartDi
$LN52@HllStartDi:

; 1395 : #ifdef DEBUG_OUT
; 1396 :   default: /**/myassert(0); break;

	mov	edx, 1396				; 00000574H
	lea	rcx, OFFSET FLAT:$SG11685
	call	InternalError
$LN2@HllStartDi:

; 1397 : #endif
; 1398 :   }
; 1399 : 
; 1400 :   if (tokenarray[i].token != T_FINAL && rc == NOT_ERROR) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN53@HllStartDi
	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN53@HllStartDi

; 1401 :     DebugMsg(("HllStartDir: unexpected token [%s]\n", tokenarray[i].tokpos));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11687
	call	DoDebugMsg

; 1402 :     EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1403 :     rc = ERROR;

	mov	DWORD PTR rc$[rsp], -1
$LN53@HllStartDi:

; 1404 :     //return( ERROR ); /* v2.08: continue and parse the line queue */
; 1405 :   }
; 1406 :   /* v2.06: remove the item from the free stack */
; 1407 :   if (hll == HllFree)

	mov	rax, QWORD PTR ModuleInfo+232
	cmp	QWORD PTR hll$[rsp], rax
	jne	SHORT $LN54@HllStartDi

; 1408 :     HllFree = hll->next;

	mov	rax, QWORD PTR hll$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ModuleInfo+232, rax
$LN54@HllStartDi:

; 1409 :   hll->next = HllStack;

	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+224
	mov	QWORD PTR [rax], rcx

; 1410 :   HllStack = hll;

	mov	rax, QWORD PTR hll$[rsp]
	mov	QWORD PTR ModuleInfo+224, rax

; 1411 : 
; 1412 :   if (ModuleInfo.list)

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN55@HllStartDi

; 1413 :     LstWrite(LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL);

	call	GetCurrOffset
	xor	r8d, r8d
	mov	edx, eax
	mov	ecx, 4
	call	LstWrite
$LN55@HllStartDi:

; 1414 : 
; 1415 :   if (is_linequeue_populated()) /* might be NULL! (".if 1") */

	cmp	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN56@HllStartDi

; 1416 :     RunLineQueue();

	call	RunLineQueue
$LN56@HllStartDi:

; 1417 : 
; 1418 :   return(rc);

	mov	eax, DWORD PTR rc$[rsp]
$LN57@HllStartDi:

; 1419 : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:HllStartDir$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 6208				; 00001840H
	pop	rdi
	ret	0
HllStartDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
a$ = 32
j$ = 36
b$ = 40
brct$ = 44
codebuff$ = 64
param$ = 352
init$ = 640
op$ = 916
p$ = 936
$T7 = 952
$T8 = 960
$T9 = 968
$T10 = 976
$T11 = 984
$T12 = 992
$T13 = 1000
__$ArrayPad$ = 1008
tokenarray$ = 1040
cnt$ = 1048
buff$ = 1056
ForInitAndNext PROC

; 906  : static ret_code ForInitAndNext(struct asm_tok tokenarray[], int cnt, char *buff){

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 1024				; 00000400H
	mov	rdi, rsp
	mov	ecx, 256				; 00000100H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+1040]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 907  :   int a;
; 908  :   int j;
; 909  :   int	b = 0;

	mov	DWORD PTR b$[rsp], 0

; 910  :   bool brct = 0;

	mov	BYTE PTR brct$[rsp], 0
$LN4@ForInitAnd:

; 911  :   char codebuff[256];
; 912  :   char param[256];
; 913  :   char init[256];
; 914  :   char op[4];
; 915  :   char *p;
; 916  :   //create valid command and add to LineQueue
; 917  :   do {
; 918  :     //extracting the first parameter "param" before the operator
; 919  :     a = 0;

	mov	DWORD PTR a$[rsp], 0
$LN5@ForInitAnd:

; 920  :     while (buff[b] && !strchr("=!<>&|-+*^%/", buff[b]))

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN6@ForInitAnd
	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11411
	call	QWORD PTR __imp_strchr
	test	rax, rax
	jne	SHORT $LN6@ForInitAnd

; 921  :     {
; 922  :       if (buff[b] == '-' || buff[b] == '+') break;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN20@ForInitAnd
	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN19@ForInitAnd
$LN20@ForInitAnd:
	jmp	SHORT $LN6@ForInitAnd
$LN19@ForInitAnd:

; 923  :       param[a] = buff[b];

	movsxd	rax, DWORD PTR b$[rsp]
	movsxd	rcx, DWORD PTR a$[rsp]
	mov	rdx, QWORD PTR buff$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR param$[rsp+rcx], al

; 924  :       b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 925  :       a++;

	mov	eax, DWORD PTR a$[rsp]
	inc	eax
	mov	DWORD PTR a$[rsp], eax

; 926  :     }

	jmp	$LN5@ForInitAnd
$LN6@ForInitAnd:

; 927  :     param[a] = '\0';

	movsxd	rax, DWORD PTR a$[rsp]
	mov	QWORD PTR $T7[rsp], rax
	cmp	QWORD PTR $T7[rsp], 256			; 00000100H
	jae	SHORT $LN128@ForInitAnd
	jmp	SHORT $LN129@ForInitAnd
$LN128@ForInitAnd:
	call	__report_rangecheckfailure
$LN129@ForInitAnd:
	mov	rax, QWORD PTR $T7[rsp]
	mov	BYTE PTR param$[rsp+rax], 0

; 928  :     //end of param
; 929  :     //is it simple operator
; 930  :     if ((buff[b + 1] == '+') || (buff[b + 1] == '-')){            //if ++ or -- finish it here

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN23@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 45					; 0000002dH
	jne	$LN21@ForInitAnd
$LN23@ForInitAnd:

; 931  :       param[a] = '\0';

	movsxd	rax, DWORD PTR a$[rsp]
	mov	QWORD PTR $T8[rsp], rax
	cmp	QWORD PTR $T8[rsp], 256			; 00000100H
	jae	SHORT $LN130@ForInitAnd
	jmp	SHORT $LN131@ForInitAnd
$LN130@ForInitAnd:
	call	__report_rangecheckfailure
$LN131@ForInitAnd:
	mov	rax, QWORD PTR $T8[rsp]
	mov	BYTE PTR param$[rsp+rax], 0

; 932  :       if ((buff[b] == '+') && (buff[b + 1] == '+')) strcpy(codebuff, " inc ");

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN24@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN24@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11419
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	SHORT $LN25@ForInitAnd
$LN24@ForInitAnd:

; 933  :       else if ((buff[b] == '-') && (buff[b + 1] == '-')) strcpy(codebuff, " dec ");

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN26@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN26@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11421
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
$LN26@ForInitAnd:
$LN25@ForInitAnd:

; 934  :       strcat(codebuff, param);

	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 935  :       AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 936  :       b += 3;

	mov	eax, DWORD PTR b$[rsp]
	add	eax, 3
	mov	DWORD PTR b$[rsp], eax

; 937  :     }

	jmp	$LN22@ForInitAnd
$LN21@ForInitAnd:

; 938  : 
; 939  :     //we finis here "inc REX" or  "dec REX" or "inc mem" or "dec mem"
; 940  :     else						//if not ++ or -- 
; 941  :     {							//extracting the operator
; 942  :       op[0] = buff[b];

	movsxd	rax, DWORD PTR b$[rsp]
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR buff$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR op$[rsp+rcx], al

; 943  :       b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 944  :       if (op[0] == '='){     //if operator is only '='

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 61					; 0000003dH
	jne	SHORT $LN27@ForInitAnd

; 945  :         op[1] = '\0';       //finish here

	mov	QWORD PTR $T9[rsp], 1
	cmp	QWORD PTR $T9[rsp], 4
	jae	SHORT $LN132@ForInitAnd
	jmp	SHORT $LN133@ForInitAnd
$LN132@ForInitAnd:
	call	__report_rangecheckfailure
$LN133@ForInitAnd:
	mov	rax, QWORD PTR $T9[rsp]
	mov	BYTE PTR op$[rsp+rax], 0

; 946  :       }

	jmp	$LN28@ForInitAnd
$LN27@ForInitAnd:

; 947  :       else {                 //extract next operator
; 948  :         op[1] = buff[b];

	movsxd	rax, DWORD PTR b$[rsp]
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR buff$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR op$[rsp+rcx], al

; 949  :         b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 950  :         if ((op[1] == '<' || op[1] == '>') && (buff[b] == '=')){

	mov	eax, 1
	imul	rax, rax, 1
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN31@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 1
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN29@ForInitAnd
$LN31@ForInitAnd:
	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 61					; 0000003dH
	jne	SHORT $LN29@ForInitAnd

; 951  :           op[2] = buff[b]; //if a second operator is shift sign "<<=" or ">>="

	movsxd	rax, DWORD PTR b$[rsp]
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR buff$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR op$[rsp+rcx], al

; 952  :           op[3] = NULLC;

	mov	eax, 1
	imul	rax, rax, 3
	mov	QWORD PTR $T10[rsp], rax
	cmp	QWORD PTR $T10[rsp], 4
	jae	SHORT $LN134@ForInitAnd
	jmp	SHORT $LN135@ForInitAnd
$LN134@ForInitAnd:
	call	__report_rangecheckfailure
$LN135@ForInitAnd:
	mov	rax, QWORD PTR $T10[rsp]
	mov	BYTE PTR op$[rsp+rax], 0

; 953  :           b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 954  :         }

	jmp	SHORT $LN30@ForInitAnd
$LN29@ForInitAnd:

; 955  :         else op[2] = NULLC; //not shift so we have two operands

	mov	eax, 1
	imul	rax, rax, 2
	mov	QWORD PTR $T11[rsp], rax
	cmp	QWORD PTR $T11[rsp], 4
	jae	SHORT $LN136@ForInitAnd
	jmp	SHORT $LN137@ForInitAnd
$LN136@ForInitAnd:
	call	__report_rangecheckfailure
$LN137@ForInitAnd:
	mov	rax, QWORD PTR $T11[rsp]
	mov	BYTE PTR op$[rsp+rax], 0
$LN30@ForInitAnd:
$LN28@ForInitAnd:

; 956  : 
; 957  :       }
; 958  :       //we finished with param and op
; 959  :       //now extracting the second parameter "init" after the operator
; 960  :       for (a = 0; buff[b];){ //checking if we have a char in a single ' '

	mov	DWORD PTR a$[rsp], 0
$LN7@ForInitAnd:
	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN8@ForInitAnd

; 961  :         if (buff[b] == '(' && buff[b - 1] != 39 && buff[b + 1] != 39 && b) break;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN32@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN32@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN32@ForInitAnd
	cmp	DWORD PTR b$[rsp], 0
	je	SHORT $LN32@ForInitAnd
	jmp	$LN8@ForInitAnd
$LN32@ForInitAnd:

; 962  :         if (buff[b] == ',' && buff[b - 1] != 39 && buff[b + 1] != 39 && b) break;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN33@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN33@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN33@ForInitAnd
	cmp	DWORD PTR b$[rsp], 0
	je	SHORT $LN33@ForInitAnd
	jmp	SHORT $LN8@ForInitAnd
$LN33@ForInitAnd:

; 963  :         init[a] = buff[b];

	movsxd	rax, DWORD PTR b$[rsp]
	movsxd	rcx, DWORD PTR a$[rsp]
	mov	rdx, QWORD PTR buff$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR init$[rsp+rcx], al

; 964  :         b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 965  :         a++;

	mov	eax, DWORD PTR a$[rsp]
	inc	eax
	mov	DWORD PTR a$[rsp], eax

; 966  :       }

	jmp	$LN7@ForInitAnd
$LN8@ForInitAnd:

; 967  :       if (buff[b] == '(' && buff[b - 1] != 39 && buff[b + 1] != 39 && b){

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	$LN34@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 39					; 00000027H
	je	$LN34@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 39					; 00000027H
	je	$LN34@ForInitAnd
	cmp	DWORD PTR b$[rsp], 0
	je	$LN34@ForInitAnd

; 968  :         for (; buff[b] && buff[b] != ')'; b++, a++){

	jmp	SHORT $LN12@ForInitAnd
$LN10@ForInitAnd:
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax
	mov	eax, DWORD PTR a$[rsp]
	inc	eax
	mov	DWORD PTR a$[rsp], eax
$LN12@ForInitAnd:
	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN11@ForInitAnd
	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN11@ForInitAnd

; 969  :           init[a] = buff[b];

	movsxd	rax, DWORD PTR b$[rsp]
	movsxd	rcx, DWORD PTR a$[rsp]
	mov	rdx, QWORD PTR buff$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR init$[rsp+rcx], al

; 970  :         }

	jmp	SHORT $LN10@ForInitAnd
$LN11@ForInitAnd:

; 971  :         if (buff[b] == ')' && buff[b - 1] != 39 && buff[b + 1] != 39){

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN35@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN35@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN35@ForInitAnd

; 972  :           init[a] = buff[b];

	movsxd	rax, DWORD PTR b$[rsp]
	movsxd	rcx, DWORD PTR a$[rsp]
	mov	rdx, QWORD PTR buff$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR init$[rsp+rcx], al

; 973  :           b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 974  :           a++;

	mov	eax, DWORD PTR a$[rsp]
	inc	eax
	mov	DWORD PTR a$[rsp], eax
$LN35@ForInitAnd:

; 975  :         }
; 976  :         brct = TRUE;

	mov	BYTE PTR brct$[rsp], 1
$LN34@ForInitAnd:

; 977  :       }
; 978  :       init[a] = NULLC;

	movsxd	rax, DWORD PTR a$[rsp]
	mov	QWORD PTR $T12[rsp], rax
	cmp	QWORD PTR $T12[rsp], 256		; 00000100H
	jae	SHORT $LN138@ForInitAnd
	jmp	SHORT $LN139@ForInitAnd
$LN138@ForInitAnd:
	call	__report_rangecheckfailure
$LN139@ForInitAnd:
	mov	rax, QWORD PTR $T12[rsp]
	mov	BYTE PTR init$[rsp+rax], 0

; 979  :       b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 980  :       //we finished with init
; 981  :       //is operator devision, multiplication or mod
; 982  :       if (op[0] == '/' || op[0] == '*' || op[0] == '%') {

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN38@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN38@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	$LN36@ForInitAnd
$LN38@ForInitAnd:

; 983  :         Tokenize(param, 0, tokenarray, 0);

	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR param$[rsp]
	call	Tokenize

; 984  :         if (strcmpi(param, reax) && strcmpi(init, reax)){ //param not rax init not rax?    

	lea	rdx, OFFSET FLAT:reax
	lea	rcx, QWORD PTR param$[rsp]
	call	QWORD PTR __imp_strcmpi
	test	eax, eax
	je	$LN39@ForInitAnd
	lea	rdx, OFFSET FLAT:reax
	lea	rcx, QWORD PTR init$[rsp]
	call	QWORD PTR __imp_strcmpi
	test	eax, eax
	je	$LN39@ForInitAnd

; 985  :           if (tokenarray[0].token == T_REG){			//is param register              

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	jne	$LN41@ForInitAnd

; 986  :             if (strcmpi(param, recx)){				//make sure that param is not rcx

	lea	rdx, OFFSET FLAT:recx
	lea	rcx, QWORD PTR param$[rsp]
	call	QWORD PTR __imp_strcmpi
	test	eax, eax
	je	SHORT $LN43@ForInitAnd

; 987  :               WriteAsmLine(" mov  ", reax, param);				// MOV RAX,param

	lea	r8, QWORD PTR param$[rsp]
	lea	rdx, OFFSET FLAT:reax
	lea	rcx, OFFSET FLAT:$SG11439
	call	WriteAsmLine
$LN43@ForInitAnd:

; 988  :             }						if (op[0] == '/' || op[0] == '%'){

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN45@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN44@ForInitAnd
$LN45@ForInitAnd:

; 989  :               strcpy(codebuff, " cdq ");			//extend to RDX if division	

	lea	rdx, OFFSET FLAT:$SG11442
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 990  :               AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue
$LN44@ForInitAnd:

; 991  :             }
; 992  :             Tokenize(init, 0, tokenarray, 0);

	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR init$[rsp]
	call	Tokenize

; 993  :             if (tokenarray[0].token == T_NUM){      //is init number? 

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 10
	jne	$LN46@ForInitAnd

; 994  :               WriteAsmLine(" mov  ", recx, init);        //MOV RCX,init

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, OFFSET FLAT:recx
	lea	rcx, OFFSET FLAT:$SG11445
	call	WriteAsmLine

; 995  :               if (op[0] == '/' || op[0] == '%')

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN50@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN48@ForInitAnd
$LN50@ForInitAnd:

; 996  :                 strcpy(codebuff, " idiv ");		//IDIV RCX        

	lea	rdx, OFFSET FLAT:$SG11449
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	SHORT $LN49@ForInitAnd
$LN48@ForInitAnd:

; 997  :               else strcpy(codebuff, " imul ");		//IMUL RCX        

	lea	rdx, OFFSET FLAT:$SG11450
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
$LN49@ForInitAnd:

; 998  :               strcat(codebuff, recx);

	lea	rdx, OFFSET FLAT:recx
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 999  :               AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1000 :               goto cont;

	jmp	$cont$142

; 1001 :             }

	jmp	SHORT $LN47@ForInitAnd
$LN46@ForInitAnd:

; 1002 :             else {
; 1003 :               if (op[0] == '/' || op[0] == '%') //it is a variable

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN53@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN51@ForInitAnd
$LN53@ForInitAnd:

; 1004 :                 strcpy(codebuff, " idiv ");

	lea	rdx, OFFSET FLAT:$SG11454
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	SHORT $LN52@ForInitAnd
$LN51@ForInitAnd:

; 1005 :               else strcpy(codebuff, " imul ");

	lea	rdx, OFFSET FLAT:$SG11455
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
$LN52@ForInitAnd:

; 1006 :               strcat(codebuff, init);

	lea	rdx, QWORD PTR init$[rsp]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 1007 :               AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1008 :               goto cont;

	jmp	$cont$142
$LN47@ForInitAnd:

; 1009 :             }
; 1010 :           }

	jmp	$LN42@ForInitAnd
$LN41@ForInitAnd:

; 1011 :           //if param is a variable
; 1012 :           else if (tokenarray[0].token == T_ID){		 //YES             

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN54@ForInitAnd

; 1013 :             WriteAsmLine(" mov  ", recx, init);        //MOV RCX,init

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, OFFSET FLAT:recx
	lea	rcx, OFFSET FLAT:$SG11457
	call	WriteAsmLine

; 1014 :             WriteAsmLine(" mov  ", reax, param);		// MOV RAX,param

	lea	r8, QWORD PTR param$[rsp]
	lea	rdx, OFFSET FLAT:reax
	lea	rcx, OFFSET FLAT:$SG11458
	call	WriteAsmLine

; 1015 :             if (op[0] == '/' || op[0] == '%'){

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN57@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN55@ForInitAnd
$LN57@ForInitAnd:

; 1016 :               strcpy(codebuff, " cdq ");

	lea	rdx, OFFSET FLAT:$SG11462
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1017 :               AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1018 :               strcpy(codebuff, " idiv ");

	lea	rdx, OFFSET FLAT:$SG11463
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1019 :             }

	jmp	SHORT $LN56@ForInitAnd
$LN55@ForInitAnd:

; 1020 :             else strcpy(codebuff, " imul ");

	lea	rdx, OFFSET FLAT:$SG11464
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
$LN56@ForInitAnd:

; 1021 :             strcat(codebuff, recx);

	lea	rdx, OFFSET FLAT:recx
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 1022 :             AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue
$cont$142:

; 1023 :           cont:
; 1024 :             if (op[0] == '%') {

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN58@ForInitAnd

; 1025 :               WriteAsmLine(" mov  ", param, redx);

	lea	r8, OFFSET FLAT:redx
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11467
	call	WriteAsmLine

; 1026 :               goto skip;

	jmp	$skip$143

; 1027 :             }

	jmp	SHORT $LN59@ForInitAnd
$LN58@ForInitAnd:

; 1028 :             else {
; 1029 :               WriteAsmLine(" mov  ", param, reax);

	lea	r8, OFFSET FLAT:reax
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11468
	call	WriteAsmLine

; 1030 :               goto skip;

	jmp	$skip$143
$LN59@ForInitAnd:
$LN54@ForInitAnd:
$LN42@ForInitAnd:

; 1031 :             }
; 1032 :           }
; 1033 :         }

	jmp	$LN40@ForInitAnd
$LN39@ForInitAnd:

; 1034 :         // if param is not RAX and init is RCX
; 1035 :         else if ((strcmpi(param, reax) && !(strcmpi(init, recx)))){

	lea	rdx, OFFSET FLAT:reax
	lea	rcx, QWORD PTR param$[rsp]
	call	QWORD PTR __imp_strcmpi
	test	eax, eax
	je	$LN60@ForInitAnd
	lea	rdx, OFFSET FLAT:recx
	lea	rcx, QWORD PTR init$[rsp]
	call	QWORD PTR __imp_strcmpi
	test	eax, eax
	jne	$LN60@ForInitAnd

; 1036 :           if (op[0] == '/' || op[0] == '%'){

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN64@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN62@ForInitAnd
$LN64@ForInitAnd:

; 1037 :             strcpy(codebuff, " cdq ");

	lea	rdx, OFFSET FLAT:$SG11474
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1038 :             AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1039 :             strcpy(codebuff, " idiv ");

	lea	rdx, OFFSET FLAT:$SG11475
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1040 :           }

	jmp	SHORT $LN63@ForInitAnd
$LN62@ForInitAnd:

; 1041 :           else strcpy(codebuff, " imul ");

	lea	rdx, OFFSET FLAT:$SG11476
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
$LN63@ForInitAnd:

; 1042 :           strcat(codebuff, recx);

	lea	rdx, OFFSET FLAT:recx
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 1043 :           AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1044 :           if (op[0] == '%') WriteAsmLine(" mov  ", param, redx);

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN65@ForInitAnd
	lea	r8, OFFSET FLAT:redx
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11478
	call	WriteAsmLine
$LN65@ForInitAnd:

; 1045 :           goto skip;

	jmp	$skip$143

; 1046 :         }

	jmp	$LN61@ForInitAnd
$LN60@ForInitAnd:

; 1047 :         // if param is RAX and init is RCX
; 1048 :         else if ((!(strcmpi(param, reax)) && (!(strcmp(init, recx))))){

	lea	rdx, OFFSET FLAT:reax
	lea	rcx, QWORD PTR param$[rsp]
	call	QWORD PTR __imp_strcmpi
	test	eax, eax
	jne	$LN66@ForInitAnd
	lea	rdx, OFFSET FLAT:recx
	lea	rcx, QWORD PTR init$[rsp]
	call	strcmp
	test	eax, eax
	jne	$LN66@ForInitAnd

; 1049 :           if (op[0] == '/' || op[0] == '%'){

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN70@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN68@ForInitAnd
$LN70@ForInitAnd:

; 1050 :             strcpy(codebuff, " cdq ");

	lea	rdx, OFFSET FLAT:$SG11484
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1051 :             AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1052 :             strcpy(codebuff, " idiv ");

	lea	rdx, OFFSET FLAT:$SG11485
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1053 :           }

	jmp	SHORT $LN69@ForInitAnd
$LN68@ForInitAnd:

; 1054 :           else strcpy(codebuff, " imul ");

	lea	rdx, OFFSET FLAT:$SG11486
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
$LN69@ForInitAnd:

; 1055 :           strcat(codebuff, recx);

	lea	rdx, OFFSET FLAT:recx
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 1056 :           AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1057 :           if (op[0] == '%') WriteAsmLine(" mov  ", param, redx);

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN71@ForInitAnd
	lea	r8, OFFSET FLAT:redx
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11488
	call	WriteAsmLine
$LN71@ForInitAnd:

; 1058 :           goto skip;

	jmp	$skip$143

; 1059 :         }

	jmp	$LN67@ForInitAnd
$LN66@ForInitAnd:

; 1060 :         // if param is RAX and init is not RCX
; 1061 :         else if (!(strcmpi(param, reax) && (strcmpi(init, recx)))){

	lea	rdx, OFFSET FLAT:reax
	lea	rcx, QWORD PTR param$[rsp]
	call	QWORD PTR __imp_strcmpi
	test	eax, eax
	je	SHORT $LN73@ForInitAnd
	lea	rdx, OFFSET FLAT:recx
	lea	rcx, QWORD PTR init$[rsp]
	call	QWORD PTR __imp_strcmpi
	test	eax, eax
	jne	$LN72@ForInitAnd
$LN73@ForInitAnd:

; 1062 :           WriteAsmLine(" mov  ", recx, init);        //MOV RCX,init

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, OFFSET FLAT:recx
	lea	rcx, OFFSET FLAT:$SG11491
	call	WriteAsmLine

; 1063 :           if (op[0] == '/' || op[0] == '%'){

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN76@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN74@ForInitAnd
$LN76@ForInitAnd:

; 1064 :             strcpy(codebuff, " cdq ");

	lea	rdx, OFFSET FLAT:$SG11495
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1065 :             AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1066 :             strcpy(codebuff, " idiv ");

	lea	rdx, OFFSET FLAT:$SG11496
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1067 :           }

	jmp	SHORT $LN75@ForInitAnd
$LN74@ForInitAnd:

; 1068 :           else strcpy(codebuff, " imul ");

	lea	rdx, OFFSET FLAT:$SG11497
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
$LN75@ForInitAnd:

; 1069 :           strcat(codebuff, recx);

	lea	rdx, OFFSET FLAT:recx
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 1070 :           AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1071 :           if (op[0] == '%') WriteAsmLine(" mov  ", param, redx);

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN77@ForInitAnd
	lea	r8, OFFSET FLAT:redx
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11499
	call	WriteAsmLine
$LN77@ForInitAnd:

; 1072 :           goto skip;

	jmp	$skip$143
$LN72@ForInitAnd:
$LN67@ForInitAnd:
$LN61@ForInitAnd:
$LN40@ForInitAnd:

; 1073 :         }
; 1074 :       }

	jmp	$LN37@ForInitAnd
$LN36@ForInitAnd:

; 1075 :       //if operator not devision, multiplication or mod
; 1076 :       else if (op[0] == '-') strcpy(codebuff, " sub ");

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN78@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11502
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	$LN79@ForInitAnd
$LN78@ForInitAnd:

; 1077 :       else if (op[0] == '+') strcpy(codebuff, " add ");

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN80@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11505
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	$LN81@ForInitAnd
$LN80@ForInitAnd:

; 1078 :       else if (op[0] == '&') strcpy(codebuff, " and ");

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN82@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11508
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	$LN83@ForInitAnd
$LN82@ForInitAnd:

; 1079 :       else if (op[0] == '|') strcpy(codebuff, " or ");

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 124				; 0000007cH
	jne	SHORT $LN84@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11511
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	$LN85@ForInitAnd
$LN84@ForInitAnd:

; 1080 :       else if (op[0] == '^') strcpy(codebuff, " xor ");

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 94					; 0000005eH
	jne	SHORT $LN86@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11514
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	SHORT $LN87@ForInitAnd
$LN86@ForInitAnd:

; 1081 :       else if (op[0] == '<' && op[1] == '<') strcpy(codebuff, " shl ");

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN88@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 1
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN88@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11517
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	SHORT $LN89@ForInitAnd
$LN88@ForInitAnd:

; 1082 :       else if (op[0] == '>' && op[1] == '>') strcpy(codebuff, " shr ");

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN90@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 1
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN90@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11519
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
$LN90@ForInitAnd:
$LN89@ForInitAnd:
$LN87@ForInitAnd:
$LN85@ForInitAnd:
$LN83@ForInitAnd:
$LN81@ForInitAnd:
$LN79@ForInitAnd:
$LN37@ForInitAnd:

; 1083 :       Tokenize(init, 0, tokenarray, 0);

	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR init$[rsp]
	call	Tokenize

; 1084 :       if (tokenarray[0].token == T_REG || tokenarray[0].token == T_NUM || tokenarray[0].token == T_FLOAT || tokenarray[0].token == T_DIRECTIVE)

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	je	SHORT $LN92@ForInitAnd
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 10
	je	SHORT $LN92@ForInitAnd
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 11
	je	SHORT $LN92@ForInitAnd
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	SHORT $LN91@ForInitAnd
$LN92@ForInitAnd:

; 1085 :         goto simple;

	jmp	SHORT $simple$144
$LN91@ForInitAnd:

; 1086 :       Tokenize(param, 0, tokenarray, 0);

	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR param$[rsp]
	call	Tokenize

; 1087 :       if (tokenarray[0].token == T_REG){

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	jne	$LN93@ForInitAnd
$simple$144:

; 1088 :       simple:			Tokenize(param, 0, tokenarray, 0);

	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR param$[rsp]
	call	Tokenize

; 1089 : 
; 1090 :         if (strlen(init) == 1 && init[0] == '0')                        //REX=0?

	lea	rcx, QWORD PTR init$[rsp]
	call	strlen
	cmp	rax, 1
	jne	SHORT $LN95@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN95@ForInitAnd

; 1091 :           WriteAsmLine(" xor  ", param, param);							            //XOR REX,REX //instead MOV REX,0				

	lea	r8, QWORD PTR param$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11526
	call	WriteAsmLine
	jmp	$LN96@ForInitAnd
$LN95@ForInitAnd:

; 1092 :         else if ((strlen(op) == 1) && ((init[4] == ' ') || (init[4] == '\t'))){  //op is '='

	lea	rcx, QWORD PTR op$[rsp]
	call	strlen
	cmp	rax, 1
	jne	$LN97@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 4
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN99@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 4
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 9
	jne	$LN97@ForInitAnd
$LN99@ForInitAnd:

; 1093 :           if ((0 == _memicmp(init, "BYTE PTR", 8)) ||                   //reax=BYTE PTR al 
; 1094 :             (0 == _memicmp(init, "BPTR", 4)) ||
; 1095 :             (0 == _memicmp(init, "WPTR", 4)) ||

	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG11533
	lea	rcx, QWORD PTR init$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	je	SHORT $LN102@ForInitAnd
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11534
	lea	rcx, QWORD PTR init$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	je	SHORT $LN102@ForInitAnd
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11535
	lea	rcx, QWORD PTR init$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	je	SHORT $LN102@ForInitAnd
	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG11536
	lea	rcx, QWORD PTR init$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN100@ForInitAnd
$LN102@ForInitAnd:

; 1096 :             (0 == _memicmp(init, "WORD PTR", 8)))                     //reax=WORD PTR ax 
; 1097 : 
; 1098 :             WriteAsmLine(" movzx  ", param, init);                      //movzx reax,ax					    

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11537
	call	WriteAsmLine
	jmp	SHORT $LN101@ForInitAnd
$LN100@ForInitAnd:

; 1099 :           else if (0 == _memicmp(init, "ADDR", 4))

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11540
	lea	rcx, QWORD PTR init$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN103@ForInitAnd

; 1100 :             WriteAsmLine(" lea  ", param, init + 5);

	lea	rax, QWORD PTR init$[rsp+5]
	mov	r8, rax
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11541
	call	WriteAsmLine
	jmp	SHORT $LN104@ForInitAnd
$LN103@ForInitAnd:

; 1101 :           else WriteAsmLine(" mov  ", param, init);

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11542
	call	WriteAsmLine
$LN104@ForInitAnd:
$LN101@ForInitAnd:

; 1102 :         }

	jmp	$LN98@ForInitAnd
$LN97@ForInitAnd:

; 1103 :         else if ((strlen(op) == 1) && ((init[6] == ' ') || (init[6] == '\t'))){

	lea	rcx, QWORD PTR op$[rsp]
	call	strlen
	cmp	rax, 1
	jne	$LN105@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 6
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN107@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 6
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 9
	jne	SHORT $LN105@ForInitAnd
$LN107@ForInitAnd:

; 1104 :           if (0 == _memicmp(init, "OFFSET", 6))

	mov	r8d, 6
	lea	rdx, OFFSET FLAT:$SG11548
	lea	rcx, QWORD PTR init$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN108@ForInitAnd

; 1105 :             WriteAsmLine(" lea  ", param, init + 7);

	lea	rax, QWORD PTR init$[rsp+7]
	mov	r8, rax
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11549
	call	WriteAsmLine
	jmp	SHORT $LN109@ForInitAnd
$LN108@ForInitAnd:

; 1106 :           else WriteAsmLine(" mov  ", param, init);

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11550
	call	WriteAsmLine
$LN109@ForInitAnd:

; 1107 :         }

	jmp	$LN106@ForInitAnd
$LN105@ForInitAnd:

; 1108 :         else if ((strlen(op) == 1) && ((init[5] == ' ') || (init[5] == '\t'))){            //op is '='

	lea	rcx, QWORD PTR op$[rsp]
	call	strlen
	cmp	rax, 1
	jne	$LN110@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 5
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN112@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 5
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 9
	jne	$LN110@ForInitAnd
$LN112@ForInitAnd:

; 1109 :           if ((0 == _memicmp(init, "DWORD PTR", 9) || 0 == _memicmp(init, "DPTR", 4)

	mov	r8d, 9
	lea	rdx, OFFSET FLAT:$SG11557
	lea	rcx, QWORD PTR init$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	je	SHORT $LN115@ForInitAnd
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11558
	lea	rcx, QWORD PTR init$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN113@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR param$[rsp+rax]
	cmp	eax, 114				; 00000072H
	je	SHORT $LN116@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR param$[rsp+rax]
	cmp	eax, 82					; 00000052H
	jne	SHORT $LN113@ForInitAnd
$LN116@ForInitAnd:
$LN115@ForInitAnd:

; 1110 :             && (param[0] == 'r' || param[0] == 'R'))) 							   //rax=DWORD PTR eax
; 1111 :             WriteAsmLine(" movsxd  ", param, init);								     //movsxd rax,eax

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11560
	call	WriteAsmLine
	jmp	SHORT $LN114@ForInitAnd
$LN113@ForInitAnd:

; 1112 :           else WriteAsmLine(" mov  ", param, init);

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11561
	call	WriteAsmLine
$LN114@ForInitAnd:

; 1113 :         }

	jmp	$LN111@ForInitAnd
$LN110@ForInitAnd:

; 1114 :         else if ((strlen(op) == 1) && brct){											    //op is '='

	lea	rcx, QWORD PTR op$[rsp]
	call	strlen
	cmp	rax, 1
	jne	$LN117@ForInitAnd
	movzx	eax, BYTE PTR brct$[rsp]
	test	eax, eax
	je	$LN117@ForInitAnd

; 1115 :           for (j = strlen(init); j; j--){

	lea	rcx, QWORD PTR init$[rsp]
	call	strlen
	mov	DWORD PTR j$[rsp], eax
	jmp	SHORT $LN15@ForInitAnd
$LN13@ForInitAnd:
	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	mov	DWORD PTR j$[rsp], eax
$LN15@ForInitAnd:
	cmp	DWORD PTR j$[rsp], 0
	je	$LN14@ForInitAnd

; 1116 :             if (init[j] == ')') init[j] = NULLC;

	movsxd	rax, DWORD PTR j$[rsp]
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN119@ForInitAnd
	movsxd	rax, DWORD PTR j$[rsp]
	mov	QWORD PTR $T13[rsp], rax
	cmp	QWORD PTR $T13[rsp], 256		; 00000100H
	jae	SHORT $LN140@ForInitAnd
	jmp	SHORT $LN141@ForInitAnd
$LN140@ForInitAnd:
	call	__report_rangecheckfailure
$LN141@ForInitAnd:
	mov	rax, QWORD PTR $T13[rsp]
	mov	BYTE PTR init$[rsp+rax], 0
$LN119@ForInitAnd:

; 1117 :             if (init[j] == '('){

	movsxd	rax, DWORD PTR j$[rsp]
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 40					; 00000028H
	jne	$LN120@ForInitAnd

; 1118 :               for (p = init, p += j; *p; p++){

	lea	rax, QWORD PTR init$[rsp]
	mov	QWORD PTR p$[rsp], rax
	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN18@ForInitAnd
$LN16@ForInitAnd:
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN18@ForInitAnd:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN17@ForInitAnd

; 1119 :                 if (*p == ',' && cnt) --cnt;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN121@ForInitAnd
	cmp	DWORD PTR cnt$[rsp], 0
	je	SHORT $LN121@ForInitAnd
	mov	eax, DWORD PTR cnt$[rsp]
	dec	eax
	mov	DWORD PTR cnt$[rsp], eax
$LN121@ForInitAnd:

; 1120 :               }

	jmp	SHORT $LN16@ForInitAnd
$LN17@ForInitAnd:

; 1121 :               init[j] = ',';

	movsxd	rax, DWORD PTR j$[rsp]
	mov	BYTE PTR init$[rsp+rax], 44		; 0000002cH
$LN120@ForInitAnd:

; 1122 :             }
; 1123 :           }

	jmp	$LN13@ForInitAnd
$LN14@ForInitAnd:

; 1124 :           strcpy(codebuff, " invoke  ");

	lea	rdx, OFFSET FLAT:$SG11567
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1125 :           strcat(codebuff, init);

	lea	rdx, QWORD PTR init$[rsp]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 1126 :           AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1127 :           WriteAsmLine(" mov  ", param, reax);

	lea	r8, OFFSET FLAT:reax
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11568
	call	WriteAsmLine

; 1128 :           brct = FALSE;

	mov	BYTE PTR brct$[rsp], 0

; 1129 :         }

	jmp	SHORT $LN118@ForInitAnd
$LN117@ForInitAnd:

; 1130 :         else {
; 1131 :           if (strlen(op) == 1)

	lea	rcx, QWORD PTR op$[rsp]
	call	strlen
	cmp	rax, 1
	jne	SHORT $LN122@ForInitAnd

; 1132 :             WriteAsmLine(" mov  ", param, init);

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11571
	call	WriteAsmLine
	jmp	SHORT $LN123@ForInitAnd
$LN122@ForInitAnd:

; 1133 :           else
; 1134 :             WriteAsmLine(codebuff, param, init);

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	WriteAsmLine
$LN123@ForInitAnd:
$LN118@ForInitAnd:
$LN111@ForInitAnd:
$LN106@ForInitAnd:
$LN98@ForInitAnd:
$LN96@ForInitAnd:

; 1135 :         }
; 1136 :       }

	jmp	SHORT $LN94@ForInitAnd
$LN93@ForInitAnd:

; 1137 :       else
; 1138 :       {
; 1139 :         if (init[0] == 39 && init[2] == 39)

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN124@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 2
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN124@ForInitAnd

; 1140 :           WriteAsmLine(" mov  byte ptr ", param, init);

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11574
	call	WriteAsmLine
	jmp	SHORT $LN125@ForInitAnd
$LN124@ForInitAnd:

; 1141 :         else {
; 1142 :           WriteAsmLine(" mov  ", reax, init);

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, OFFSET FLAT:reax
	lea	rcx, OFFSET FLAT:$SG11575
	call	WriteAsmLine

; 1143 :           WriteAsmLine(codebuff, param, reax);

	lea	r8, OFFSET FLAT:reax
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	WriteAsmLine
$LN125@ForInitAnd:
$LN94@ForInitAnd:
$LN22@ForInitAnd:
$skip$143:

; 1144 :         }
; 1145 :       }
; 1146 :     }
; 1147 :   skip:
; 1148 :     if (cnt) cnt--;

	cmp	DWORD PTR cnt$[rsp], 0
	je	SHORT $LN126@ForInitAnd
	mov	eax, DWORD PTR cnt$[rsp]
	dec	eax
	mov	DWORD PTR cnt$[rsp], eax
$LN126@ForInitAnd:

; 1149 :   } while (cnt);

	cmp	DWORD PTR cnt$[rsp], 0
	jne	$LN4@ForInitAnd

; 1150 :   return(NOT_ERROR);

	xor	eax, eax
$LN127@ForInitAnd:

; 1151 : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:ForInitAndNext$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1024				; 00000400H
	pop	rdi
	ret	0
ForInitAndNext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
codebuff$ = 48
__$ArrayPad$ = 320
cmd$ = 352
s1$ = 360
s2$ = 368
WriteAsmLine PROC

; 897  : static void WriteAsmLine(const char *cmd, const char *s1, const char *s2){

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 336				; 00000150H
	mov	rdi, rsp
	mov	ecx, 84					; 00000054H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+352]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 898  :   char codebuff[256];
; 899  :   strcpy(codebuff, cmd);

	mov	rdx, QWORD PTR cmd$[rsp]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 900  :   strcat(codebuff, s1);

	mov	rdx, QWORD PTR s1$[rsp]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 901  :   strcat(codebuff, ", ");

	lea	rdx, OFFSET FLAT:$SG11366
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 902  :   strcat(codebuff, s2);

	mov	rdx, QWORD PTR s2$[rsp]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 903  :   AddLineQueue(codebuff);				// MOV RAX,param

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 904  :   return;
; 905  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:WriteAsmLine$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 336				; 00000150H
	pop	rdi
	ret	0
WriteAsmLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
lines$ = 32
i$ = 36
addchars$ = 40
px$ = 48
NL$ = 56
p$ = 80
CheckCXZLines PROC

; 835  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 836  :   int lines = 0;

	mov	DWORD PTR lines$[rsp], 0

; 837  :   int i;
; 838  :   int addchars;
; 839  :   char *px;
; 840  :   bool NL = TRUE;

	mov	BYTE PTR NL$[rsp], 1

; 841  : 
; 842  :   DebugMsg1(("CheckCXZLines enter, p=>%s<\n", p));

	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, OFFSET FLAT:$SG11341
	call	DoDebugMsg1

; 843  :   /* syntax ".untilcxz 1" has a problem: there's no "jmp" generated at all.
; 844  :   * if this syntax is to be supported, activate the #if below.
; 845  :   */
; 846  :   for (; *p; p++) {

	jmp	SHORT $LN4@CheckCXZLi
$LN2@CheckCXZLi:
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN4@CheckCXZLi:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@CheckCXZLi

; 847  :     if (*p == EOLCHAR) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 94					; 0000005eH
	jne	SHORT $LN8@CheckCXZLi

; 848  :       NL = TRUE;

	mov	BYTE PTR NL$[rsp], 1

; 849  :       lines++;

	mov	eax, DWORD PTR lines$[rsp]
	inc	eax
	mov	DWORD PTR lines$[rsp], eax

; 850  :     }

	jmp	$LN9@CheckCXZLi
$LN8@CheckCXZLi:

; 851  :     else if (NL) {

	movzx	eax, BYTE PTR NL$[rsp]
	test	eax, eax
	je	$LN10@CheckCXZLi

; 852  :       NL = FALSE;

	mov	BYTE PTR NL$[rsp], 0

; 853  :       if (*p == 'j') {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 106				; 0000006aH
	jne	$LN11@CheckCXZLi

; 854  :         p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 855  :         /* v2.06: rewritten */
; 856  :         if (*p == 'm' && lines == 0) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 109				; 0000006dH
	jne	SHORT $LN12@CheckCXZLi
	cmp	DWORD PTR lines$[rsp], 0
	jne	SHORT $LN12@CheckCXZLi

; 857  :           addchars = 2; /* make room for 2 chars, to replace "jmp" by "loope" */

	mov	DWORD PTR addchars$[rsp], 2

; 858  :           px = "loope";

	lea	rax, OFFSET FLAT:$SG11348
	mov	QWORD PTR px$[rsp], rax

; 859  :         }

	jmp	SHORT $LN13@CheckCXZLi
$LN12@CheckCXZLi:

; 860  :         else if (lines == 1 && (*p == 'z' || (*p == 'n' && *(p + 1) == 'z'))) {

	cmp	DWORD PTR lines$[rsp], 1
	jne	SHORT $LN14@CheckCXZLi
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 122				; 0000007aH
	je	SHORT $LN16@CheckCXZLi
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 110				; 0000006eH
	jne	SHORT $LN14@CheckCXZLi
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 122				; 0000007aH
	jne	SHORT $LN14@CheckCXZLi
$LN16@CheckCXZLi:

; 861  :           addchars = 3; /* make room for 3 chars, to replace "jz"/"jnz" by "loopz"/"loopnz" */

	mov	DWORD PTR addchars$[rsp], 3

; 862  :           px = "loop";

	lea	rax, OFFSET FLAT:$SG11352
	mov	QWORD PTR px$[rsp], rax

; 863  :         }

	jmp	SHORT $LN15@CheckCXZLi
$LN14@CheckCXZLi:

; 864  :         else
; 865  :           return(ERROR); /* anything else is "too complex" */

	mov	eax, -1
	jmp	$LN1@CheckCXZLi
$LN15@CheckCXZLi:
$LN13@CheckCXZLi:

; 866  :         //replace_instr:
; 867  :         for (p--, i = strlen(p); i >= 0; i--) {

	mov	rax, QWORD PTR p$[rsp]
	dec	rax
	mov	QWORD PTR p$[rsp], rax
	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN7@CheckCXZLi
$LN5@CheckCXZLi:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@CheckCXZLi:
	cmp	DWORD PTR i$[rsp], 0
	jl	SHORT $LN6@CheckCXZLi

; 868  :           *(p + addchars + i) = *(p + i);

	movsxd	rax, DWORD PTR i$[rsp]
	movsxd	rcx, DWORD PTR addchars$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movsxd	rdx, DWORD PTR i$[rsp]
	mov	r8, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rcx+rdx], al

; 869  :         }

	jmp	SHORT $LN5@CheckCXZLi
$LN6@CheckCXZLi:

; 870  :         memcpy(p, px, strlen(px));

	mov	rcx, QWORD PTR px$[rsp]
	call	strlen
	mov	r8, rax
	mov	rdx, QWORD PTR px$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	memcpy
$LN11@CheckCXZLi:
$LN10@CheckCXZLi:
$LN9@CheckCXZLi:

; 871  :       }
; 872  : #if 0 /* handle ".untilcxz 1" like masm does */
; 873  :       else if (*p == ' ' && *(p + 1) == EOLCHAR && lines == 0) {
; 874  :         p++;
; 875  :         GetLabelStr(hll->labels[LSTART], p);
; 876  :         strcat(p, EOLSTR);
; 877  :         addchars = 5;
; 878  :         px = "loope";
; 879  :         goto replace_instr;
; 880  :       }
; 881  : #endif
; 882  :     }
; 883  :   }

	jmp	$LN2@CheckCXZLi
$LN3@CheckCXZLi:

; 884  :   if (lines > 2)

	cmp	DWORD PTR lines$[rsp], 2
	jle	SHORT $LN17@CheckCXZLi

; 885  :     return(ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@CheckCXZLi
$LN17@CheckCXZLi:

; 886  :   return(NOT_ERROR);

	xor	eax, eax
$LN1@CheckCXZLi:

; 887  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
CheckCXZLines ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
hllop$ = 72
hll$ = 128
i$ = 136
tokenarray$ = 144
ilabel$ = 152
is_true$ = 160
buffer$ = 168
EvaluateHllExpression PROC

; 810  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+128]

; 811  :   struct hll_opnd hllop = { NULL, 0 };

	mov	QWORD PTR hllop$[rsp], 0
	mov	DWORD PTR hllop$[rsp+8], 0

; 812  : 
; 813  :   DebugMsg1(("EvaluateHllExpression enter\n"));

	lea	rcx, OFFSET FLAT:$SG11322
	call	DoDebugMsg1

; 814  : 
; 815  :   *buffer = NULLC;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rax], 0

; 816  :   if (ERROR == GetExpression(hll, i, tokenarray, ilabel, is_true, buffer, &hllop))

	lea	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR ilabel$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetExpression
	cmp	eax, -1
	jne	SHORT $LN2@EvaluateHl

; 817  :     return(ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@EvaluateHl
$LN2@EvaluateHl:

; 818  :   /* v2.11: changed */
; 819  :   //if ( *buffer == EOLCHAR ) {
; 820  :   //DebugMsg(( "EvaluateHllExpression: EOL at pos 0 in line buffer\n" ));
; 821  :   if (tokenarray[*i].token != T_FINAL) {

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN3@EvaluateHl

; 822  :     DebugMsg(("EvaluateHllExpression: unexpected tokens >%s<\n", tokenarray[*i].tokpos));

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11325
	call	DoDebugMsg

; 823  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, 199				; 000000c7H
	call	EmitError
	jmp	SHORT $LN1@EvaluateHl
$LN3@EvaluateHl:

; 824  :   }
; 825  :   return(NOT_ERROR);

	xor	eax, eax
$LN1@EvaluateHl:

; 826  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:EvaluateHllExpression$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
EvaluateHllExpression ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
start$ = 32
tv65 = 40
src$ = 64
QueueTestLines PROC

; 773  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 774  :   char *start;
; 775  : 
; 776  :   DebugMsg1(("QueueTestLines(\"%s\") enter\n", src ? src : "NULL"));

	cmp	QWORD PTR src$[rsp], 0
	je	SHORT $LN7@QueueTestL
	mov	rax, QWORD PTR src$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN8@QueueTestL
$LN7@QueueTestL:
	lea	rax, OFFSET FLAT:$SG11301
	mov	QWORD PTR tv65[rsp], rax
$LN8@QueueTestL:
	mov	rdx, QWORD PTR tv65[rsp]
	lea	rcx, OFFSET FLAT:$SG11302
	call	DoDebugMsg1
$LN2@QueueTestL:

; 777  :   while (src) {

	cmp	QWORD PTR src$[rsp], 0
	je	SHORT $LN3@QueueTestL

; 778  :     //if (*src == ' ') src++; /* v2.11: obsolete */
; 779  :     start = src;

	mov	rax, QWORD PTR src$[rsp]
	mov	QWORD PTR start$[rsp], rax

; 780  :     if (src = strchr(src, EOLCHAR))

	mov	edx, 94					; 0000005eH
	mov	rcx, QWORD PTR src$[rsp]
	call	QWORD PTR __imp_strchr
	mov	QWORD PTR src$[rsp], rax
	cmp	QWORD PTR src$[rsp], 0
	je	SHORT $LN4@QueueTestL

; 781  :       *src++ = NULLC;

	mov	rax, QWORD PTR src$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN4@QueueTestL:

; 782  :     if (*start)

	mov	rax, QWORD PTR start$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN5@QueueTestL

; 783  :       AddLineQueue(start);

	mov	rcx, QWORD PTR start$[rsp]
	call	AddLineQueue
$LN5@QueueTestL:

; 784  :   }

	jmp	SHORT $LN2@QueueTestL
$LN3@QueueTestL:

; 785  : 
; 786  :   DebugMsg1(("QueueTestLines exit\n"));

	lea	rcx, OFFSET FLAT:$SG11305
	call	DoDebugMsg1

; 787  :   return(NOT_ERROR);

	xor	eax, eax

; 788  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
QueueTestLines ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
ptr$ = 64
truelabel$ = 72
p$1 = 80
tv91 = 88
hll$ = 112
i$ = 120
tokenarray$ = 128
ilabel$ = 136
is_true$ = 144
buffer$ = 152
hllop$ = 160
GetAndExpression PROC

; 621  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rdi, rsp
	mov	ecx, 24
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+112]

; 622  :   char *ptr = buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR ptr$[rsp], rax

; 623  :   uint_32 truelabel = 0;

	mov	DWORD PTR truelabel$[rsp], 0

; 624  :   //char buff[16];
; 625  :   //char *nlabel;
; 626  :   //char *olabel;
; 627  : 
; 628  :   DebugMsg1(("%u GetAndExpression(>%.32s< buf=>%s<) enter\n", evallvl, tokenarray[*i].tokpos, buffer));

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	r9, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11231
	call	DoDebugMsg1

; 629  : 
; 630  :   if (ERROR == GetSimpleExpression(hll, i, tokenarray, ilabel, is_true, ptr, hllop))

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR ilabel$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetSimpleExpression
	cmp	eax, -1
	jne	SHORT $LN4@GetAndExpr

; 631  :     return(ERROR);

	mov	eax, -1
	jmp	$LN1@GetAndExpr
$LN4@GetAndExpr:
$LN2@GetAndExpr:

; 632  :   while (COP_AND == GetCOp(&tokenarray[*i])) {

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	GetCOp
	cmp	eax, 7
	jne	$LN3@GetAndExpr

; 633  : 
; 634  :     (*i)++;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax

; 635  :     DebugMsg1(("%u GetAndExpression: &&-operator found, is_true=%u, lastjmp=%s\n", evallvl, is_true, hllop->lastjmp ? hllop->lastjmp : "NULL"));

	mov	rax, QWORD PTR hllop$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN12@GetAndExpr
	mov	rax, QWORD PTR hllop$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv91[rsp], rax
	jmp	SHORT $LN13@GetAndExpr
$LN12@GetAndExpr:
	lea	rax, OFFSET FLAT:$SG11233
	mov	QWORD PTR tv91[rsp], rax
$LN13@GetAndExpr:
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	r9, QWORD PTR tv91[rsp]
	mov	r8d, eax
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11234
	call	DoDebugMsg1

; 636  : 
; 637  :     if (is_true) {

	movzx	eax, BYTE PTR is_true$[rsp]
	test	eax, eax
	je	$LN5@GetAndExpr

; 638  :       /* todo: please describe what's done here and why! */
; 639  :       if (hllop->lastjmp) {

	mov	rax, QWORD PTR hllop$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN6@GetAndExpr

; 640  :         char *p = hllop->lastjmp;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$1[rsp], rax

; 641  :         InvertJump(p);          /* step 1 */

	mov	rcx, QWORD PTR p$1[rsp]
	call	InvertJump

; 642  :         if (truelabel == 0)     /* step 2 */

	cmp	DWORD PTR truelabel$[rsp], 0
	jne	SHORT $LN7@GetAndExpr

; 643  :           truelabel = GetHllLabel();

	call	GetHllLabel
	mov	DWORD PTR truelabel$[rsp], eax
$LN7@GetAndExpr:

; 644  : 
; 645  :         if (*p) {               /* v2.11: there might be a 0 at lastjmp */

	mov	rax, QWORD PTR p$1[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN8@GetAndExpr

; 646  :           p += 4;               /* skip 'jcc ' or 'jmp ' */

	mov	rax, QWORD PTR p$1[rsp]
	add	rax, 4
	mov	QWORD PTR p$1[rsp], rax

; 647  :           GetLabelStr(truelabel, p);

	mov	rdx, QWORD PTR p$1[rsp]
	mov	ecx, DWORD PTR truelabel$[rsp]
	call	GetLabelStr

; 648  :           strcat(p, EOLSTR);

	lea	rdx, OFFSET FLAT:$SG11239
	mov	rcx, QWORD PTR p$1[rsp]
	call	strcat
$LN8@GetAndExpr:

; 649  :         }
; 650  : 
; 651  :         DebugMsg1(("%u GetAndExpression: jmp inverted >%s<\n", evallvl, hllop->lastjmp));

	mov	rax, QWORD PTR hllop$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11240
	call	DoDebugMsg1

; 652  :         ReplaceLabel(buffer, GetLabel(hll, ilabel), truelabel);

	mov	edx, DWORD PTR ilabel$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetLabel
	mov	r8d, DWORD PTR truelabel$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR buffer$[rsp]
	call	ReplaceLabel

; 653  :         hllop->lastjmp = NULL;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rax], 0
$LN6@GetAndExpr:
$LN5@GetAndExpr:

; 654  :       }
; 655  :     }
; 656  :     ptr += strlen(ptr);

	mov	rcx, QWORD PTR ptr$[rsp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rsp], rax

; 657  :     hllop->lasttruelabel = 0; /* v2.08 */

	mov	rax, QWORD PTR hllop$[rsp]
	mov	DWORD PTR [rax+8], 0

; 658  :     if (ERROR == GetSimpleExpression(hll, i, tokenarray, ilabel, is_true, ptr, hllop))

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR ilabel$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetSimpleExpression
	cmp	eax, -1
	jne	SHORT $LN9@GetAndExpr

; 659  :       return(ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@GetAndExpr
$LN9@GetAndExpr:

; 660  :   };

	jmp	$LN2@GetAndExpr
$LN3@GetAndExpr:

; 661  : 
; 662  :   if (truelabel > 0) {

	cmp	DWORD PTR truelabel$[rsp], 0
	jbe	SHORT $LN10@GetAndExpr

; 663  :     ptr += strlen(ptr);

	mov	rcx, QWORD PTR ptr$[rsp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rsp], rax

; 664  :     GetLabelStr(truelabel, ptr);

	mov	rdx, QWORD PTR ptr$[rsp]
	mov	ecx, DWORD PTR truelabel$[rsp]
	call	GetLabelStr

; 665  :     strcat(ptr, LABELQUAL EOLSTR);

	lea	rdx, OFFSET FLAT:$SG11243
	mov	rcx, QWORD PTR ptr$[rsp]
	call	strcat

; 666  :     DebugMsg1(("%u GetAndExpression: label added >%s<\n", evallvl, ptr));

	mov	r8, QWORD PTR ptr$[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11244
	call	DoDebugMsg1

; 667  :     hllop->lastjmp = NULL;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rax], 0
$LN10@GetAndExpr:

; 668  :   }
; 669  :   return(NOT_ERROR);

	xor	eax, eax
$LN1@GetAndExpr:

; 670  : }

	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
GetAndExpression ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
oldlbl$ = 56
newlbl$ = 104
i$ = 132
__$ArrayPad$ = 144
p$ = 176
olabel$ = 184
nlabel$ = 192
ReplaceLabel PROC

; 600  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 160				; 000000a0H
	mov	rdi, rsp
	mov	ecx, 40					; 00000028H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+176]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 601  :   char oldlbl[16];
; 602  :   char newlbl[16];
; 603  :   int i;
; 604  : 
; 605  :   GetLabelStr(olabel, oldlbl);

	lea	rdx, QWORD PTR oldlbl$[rsp]
	mov	ecx, DWORD PTR olabel$[rsp]
	call	GetLabelStr

; 606  :   GetLabelStr(nlabel, newlbl);

	lea	rdx, QWORD PTR newlbl$[rsp]
	mov	ecx, DWORD PTR nlabel$[rsp]
	call	GetLabelStr

; 607  : 
; 608  :   i = strlen(newlbl);

	lea	rcx, QWORD PTR newlbl$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax

; 609  : 
; 610  :   DebugMsg1(("%u ReplaceLabel(%s->%s, >%s<)\n", evallvl, oldlbl, newlbl, p));

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR newlbl$[rsp]
	lea	r8, QWORD PTR oldlbl$[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11207
	call	DoDebugMsg1
$LN2@ReplaceLab:

; 611  :   while (p = strstr(p, oldlbl)) {

	lea	rdx, QWORD PTR oldlbl$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp_strstr
	mov	QWORD PTR p$[rsp], rax
	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN3@ReplaceLab

; 612  :     memcpy(p, newlbl, i);

	movsxd	rax, DWORD PTR i$[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR newlbl$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	memcpy

; 613  :     p += i;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 614  :   }

	jmp	SHORT $LN2@ReplaceLab
$LN3@ReplaceLab:

; 615  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:ReplaceLabel$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
ReplaceLabel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
p$ = 48
InvertJump PROC

; 548  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 549  :   if (*p == NULLC) { /* v2.11: convert 0 to "jmp" */

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN2@InvertJump

; 550  :     strcpy(p, "jmp ");

	lea	rdx, OFFSET FLAT:$SG11177
	mov	rcx, QWORD PTR p$[rsp]
	call	strcpy

; 551  :     return;

	jmp	$LN1@InvertJump
$LN2@InvertJump:

; 552  :   }
; 553  : 
; 554  :   p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 555  :   if (*p == 'e' || *p == 'z' || *p == 'c' || *p == 's' || *p == 'p' || *p == 'o') {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 101				; 00000065H
	je	SHORT $LN5@InvertJump
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 122				; 0000007aH
	je	SHORT $LN5@InvertJump
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 99					; 00000063H
	je	SHORT $LN5@InvertJump
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 115				; 00000073H
	je	SHORT $LN5@InvertJump
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 112				; 00000070H
	je	SHORT $LN5@InvertJump
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 111				; 0000006fH
	jne	SHORT $LN3@InvertJump
$LN5@InvertJump:

; 556  :     *(p + 1) = *p;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax+1], cl

; 557  :     *p = 'n';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 110			; 0000006eH

; 558  :     return;

	jmp	$LN1@InvertJump

; 559  :   }

	jmp	$LN4@InvertJump
$LN3@InvertJump:

; 560  :   else if (*p == 'n') {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 110				; 0000006eH
	jne	SHORT $LN6@InvertJump

; 561  :     *p = *(p + 1);

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx+1]
	mov	BYTE PTR [rax], cl

; 562  :     *(p + 1) = ' ';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax+1], 32			; 00000020H

; 563  :     return;

	jmp	$LN1@InvertJump

; 564  :   }

	jmp	$LN7@InvertJump
$LN6@InvertJump:

; 565  :   else if (*p == 'a') {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 97					; 00000061H
	jne	SHORT $LN8@InvertJump

; 566  :     *p++ = 'b';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 98			; 00000062H
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 567  :   }

	jmp	$LN9@InvertJump
$LN8@InvertJump:

; 568  :   else if (*p == 'b') {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 98					; 00000062H
	jne	SHORT $LN10@InvertJump

; 569  :     *p++ = 'a';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 97			; 00000061H
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 570  :   }

	jmp	SHORT $LN11@InvertJump
$LN10@InvertJump:

; 571  :   else if (*p == 'g') {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 103				; 00000067H
	jne	SHORT $LN12@InvertJump

; 572  :     *p++ = 'l';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 108			; 0000006cH
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 573  :   }

	jmp	SHORT $LN13@InvertJump
$LN12@InvertJump:

; 574  :   else if (*p == 'l') {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 108				; 0000006cH
	jne	SHORT $LN14@InvertJump

; 575  :     *p++ = 'g';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 103			; 00000067H
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 576  :   }

	jmp	SHORT $LN15@InvertJump
$LN14@InvertJump:

; 577  :   else {
; 578  :     /* v2.11: convert "jmp" to 0 */
; 579  :     if (*p == 'm') {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 109				; 0000006dH
	jne	SHORT $LN16@InvertJump

; 580  :       p--;

	mov	rax, QWORD PTR p$[rsp]
	dec	rax
	mov	QWORD PTR p$[rsp], rax

; 581  :       *p = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 0
$LN16@InvertJump:

; 582  :     }
; 583  :     return;

	jmp	SHORT $LN1@InvertJump
$LN15@InvertJump:
$LN13@InvertJump:
$LN11@InvertJump:
$LN9@InvertJump:
$LN7@InvertJump:
$LN4@InvertJump:

; 584  :   }
; 585  :   if (*p == 'e')

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 101				; 00000065H
	jne	SHORT $LN17@InvertJump

; 586  :     *p = ' ';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
	jmp	SHORT $LN18@InvertJump
$LN17@InvertJump:

; 587  :   else
; 588  :     *p = 'e';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 101			; 00000065H
$LN18@InvertJump:
$LN1@InvertJump:

; 589  :   return;
; 590  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
InvertJump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
op$ = 64
instr$ = 68
op1_pos$ = 72
op1_end$ = 76
op2_pos$ = 80
op2_end$ = 84
p$ = 88
op1$ = 112
op2$ = 256
label$ = 372
brcnt$5 = 376
j$6 = 380
tv230 = 384
tv226 = 388
tv252 = 392
tv379 = 396
tv426 = 400
tv424 = 404
hll$ = 432
i$ = 440
tokenarray$ = 448
ilabel$ = 456
is_true$ = 464
buffer$ = 472
hllop$ = 480
GetSimpleExpression PROC

; 347  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 416				; 000001a0H
	mov	rdi, rsp
	mov	ecx, 104				; 00000068H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+432]

; 348  :   enum c_bop op;
; 349  :   char instr;
; 350  :   int op1_pos;
; 351  :   int op1_end;
; 352  :   int op2_pos;
; 353  :   int op2_end;
; 354  :   char *p;
; 355  :   struct expr op1;
; 356  :   struct expr op2;
; 357  :   uint_32 label;
; 358  : 
; 359  :   DebugMsg1(("%u GetSimpleExpression(>%.32s< buf=>%s<) enter\n", evallvl, tokenarray[*i].tokpos, buffer));

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	r9, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11116
	call	DoDebugMsg1
$LN2@GetSimpleE:

; 360  : 
; 361  :   while (tokenarray[*i].string_ptr[0] == '!' && tokenarray[*i].string_ptr[1] == '\0') {

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rdx+rax+8]
	movsx	eax, BYTE PTR [rax+rcx]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN3@GetSimpleE
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rdx+rax+8]
	movsx	eax, BYTE PTR [rax+rcx]
	test	eax, eax
	jne	SHORT $LN3@GetSimpleE

; 362  :     (*i)++; //GetCOp( i );

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax

; 363  :     is_true = 1 - is_true;

	movzx	eax, BYTE PTR is_true$[rsp]
	mov	ecx, 1
	sub	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR is_true$[rsp], al

; 364  :   }

	jmp	$LN2@GetSimpleE
$LN3@GetSimpleE:

; 365  : 
; 366  :   /* the problem with '()' is that is might enclose just a standard Masm
; 367  :   * expression or a "hll" expression. The first case is to be handled
; 368  :   * entirely by the expression evaluator, while the latter case is to be
; 369  :   * handled HERE!
; 370  :   */
; 371  :   if (tokenarray[*i].token == T_OP_BRACKET) {

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	$LN11@GetSimpleE

; 372  :     int brcnt;
; 373  :     int j;
; 374  :     for (brcnt = 1, j = *i + 1; tokenarray[j].token != T_FINAL; j++) {

	mov	DWORD PTR brcnt$5[rsp], 1
	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	DWORD PTR j$6[rsp], eax
	jmp	SHORT $LN6@GetSimpleE
$LN4@GetSimpleE:
	mov	eax, DWORD PTR j$6[rsp]
	inc	eax
	mov	DWORD PTR j$6[rsp], eax
$LN6@GetSimpleE:
	movsxd	rax, DWORD PTR j$6[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN5@GetSimpleE

; 375  :       if (tokenarray[j].token == T_OP_BRACKET)

	movsxd	rax, DWORD PTR j$6[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN12@GetSimpleE

; 376  :         brcnt++;

	mov	eax, DWORD PTR brcnt$5[rsp]
	inc	eax
	mov	DWORD PTR brcnt$5[rsp], eax
	jmp	SHORT $LN13@GetSimpleE
$LN12@GetSimpleE:

; 377  :       else if (tokenarray[j].token == T_CL_BRACKET) {

	movsxd	rax, DWORD PTR j$6[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN14@GetSimpleE

; 378  :         brcnt--;

	mov	eax, DWORD PTR brcnt$5[rsp]
	dec	eax
	mov	DWORD PTR brcnt$5[rsp], eax

; 379  :         if (brcnt == 0) /* a standard Masm expression? */

	cmp	DWORD PTR brcnt$5[rsp], 0
	jne	SHORT $LN16@GetSimpleE

; 380  :           break;

	jmp	SHORT $LN5@GetSimpleE
$LN16@GetSimpleE:

; 381  :       }

	jmp	SHORT $LN15@GetSimpleE
$LN14@GetSimpleE:

; 382  :       else if ((GetCOp(&tokenarray[j])) != COP_NONE)

	movsxd	rax, DWORD PTR j$6[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	GetCOp
	test	eax, eax
	je	SHORT $LN17@GetSimpleE

; 383  :         break;

	jmp	SHORT $LN5@GetSimpleE
$LN17@GetSimpleE:
$LN15@GetSimpleE:
$LN13@GetSimpleE:

; 384  :     }

	jmp	$LN4@GetSimpleE
$LN5@GetSimpleE:

; 385  :     if (brcnt) {

	cmp	DWORD PTR brcnt$5[rsp], 0
	je	$LN18@GetSimpleE

; 386  :       (*i)++;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax

; 387  :       DebugMsg1(("%u GetSimpleExpression: calling GetExpression, i=%u\n", evallvl, *i));

	mov	rax, QWORD PTR i$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11125
	call	DoDebugMsg1

; 388  :       if (ERROR == GetExpression(hll, i, tokenarray, ilabel, is_true, buffer, hllop))

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR ilabel$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetExpression
	cmp	eax, -1
	jne	SHORT $LN19@GetSimpleE

; 389  :         return(ERROR);

	mov	eax, -1
	jmp	$LN1@GetSimpleE
$LN19@GetSimpleE:

; 390  : 
; 391  :       if (tokenarray[*i].token != T_CL_BRACKET) {

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN20@GetSimpleE

; 392  :         //if (( tokenarray[*i].token == T_FINAL ) || ( tokenarray[*i].token == T_CL_BRACKET ))
; 393  :         DebugMsg(("GetSimpleExpression: expected ')', found: %s\n", tokenarray[*i].string_ptr));

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11128
	call	DoDebugMsg

; 394  :         return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, 199				; 000000c7H
	call	EmitError
	jmp	$LN1@GetSimpleE
$LN20@GetSimpleE:

; 395  :       }
; 396  :       (*i)++;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax

; 397  :       return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@GetSimpleE
$LN18@GetSimpleE:
$LN11@GetSimpleE:

; 398  :     }
; 399  :   }
; 400  : 
; 401  :   /* get (first) operand */
; 402  :   op1_pos = *i;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR op1_pos$[rsp], eax

; 403  :   if (ERROR == GetToken(hll, i, tokenarray, &op1))

	lea	r9, QWORD PTR op1$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetToken
	cmp	eax, -1
	jne	SHORT $LN21@GetSimpleE

; 404  :     return (ERROR);

	mov	eax, -1
	jmp	$LN1@GetSimpleE
$LN21@GetSimpleE:

; 405  :   op1_end = *i;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR op1_end$[rsp], eax

; 406  : 
; 407  :   op = GetCOp(&tokenarray[*i]); /* get operator */

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	GetCOp
	mov	DWORD PTR op$[rsp], eax

; 408  : 
; 409  :   /* lower precedence operator ( && or || ) detected? */
; 410  :   if (op == COP_AND || op == COP_OR) {

	cmp	DWORD PTR op$[rsp], 7
	je	SHORT $LN24@GetSimpleE
	cmp	DWORD PTR op$[rsp], 8
	jne	SHORT $LN22@GetSimpleE
$LN24@GetSimpleE:

; 411  :     /* v2.11: next 2 lines removed - && and || operators need a valid first operand */
; 412  :     //if ( op1.kind == EXPR_EMPTY )
; 413  :     //    return( NOT_ERROR );
; 414  :     op = COP_NONE;

	mov	DWORD PTR op$[rsp], 0

; 415  :   }

	jmp	SHORT $LN23@GetSimpleE
$LN22@GetSimpleE:

; 416  :   else if (op != COP_NONE)

	cmp	DWORD PTR op$[rsp], 0
	je	SHORT $LN25@GetSimpleE

; 417  :     (*i)++;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax
$LN25@GetSimpleE:
$LN23@GetSimpleE:

; 418  : 
; 419  :   label = GetLabel(hll, ilabel);

	mov	edx, DWORD PTR ilabel$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetLabel
	mov	DWORD PTR label$[rsp], eax

; 420  : 
; 421  :   DebugMsg1(("%u GetSimpleExpression: EvalOperand ok, kind=%X, i=%u [%s]\n", evallvl, op1.kind, *i, tokenarray[*i].tokpos));

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR i$[rsp]
	mov	r9d, DWORD PTR [rax]
	mov	r8d, DWORD PTR op1$[rsp+60]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11134
	call	DoDebugMsg1

; 422  : 
; 423  :   /* check for special operators with implicite operand:
; 424  :   * COP_ZERO, COP_CARRY, COP_SIGN, COP_PARITY, COP_OVERFLOW
; 425  :   */
; 426  :   if (op >= COP_ZERO) {

	cmp	DWORD PTR op$[rsp], 11
	jl	$LN26@GetSimpleE

; 427  :     if (op1.kind != EXPR_EMPTY) {

	cmp	DWORD PTR op1$[rsp+60], -2
	je	SHORT $LN27@GetSimpleE

; 428  :       DebugMsg(("GetSimpleExpression: non-empty expression rejected: %s\n", tokenarray[op1_pos].tokpos));

	movsxd	rax, DWORD PTR op1_pos$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11137
	call	DoDebugMsg

; 429  :       return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, 199				; 000000c7H
	call	EmitError
	jmp	$LN1@GetSimpleE
$LN27@GetSimpleE:

; 430  :     }
; 431  :     p = buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 432  :     hllop->lastjmp = p;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 433  :        RenderJcc(p, flaginstr[op - COP_ZERO], !is_true, label);

	movzx	eax, BYTE PTR is_true$[rsp]
	test	eax, eax
	jne	SHORT $LN51@GetSimpleE
	mov	DWORD PTR tv230[rsp], 1
	jmp	SHORT $LN52@GetSimpleE
$LN51@GetSimpleE:
	mov	DWORD PTR tv230[rsp], 0
$LN52@GetSimpleE:
	mov	eax, DWORD PTR op$[rsp]
	sub	eax, 11
	cdqe
	lea	rcx, OFFSET FLAT:flaginstr
	mov	r9d, DWORD PTR label$[rsp]
	mov	r8d, DWORD PTR tv230[rsp]
	movzx	edx, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR p$[rsp]
	call	RenderJcc

; 434  :     return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@GetSimpleE
$LN26@GetSimpleE:

; 435  :   }
; 436  : 
; 437  :   switch (op1.kind) {

	mov	eax, DWORD PTR op1$[rsp+60]
	mov	DWORD PTR tv226[rsp], eax
	cmp	DWORD PTR tv226[rsp], -2
	je	SHORT $LN28@GetSimpleE
	cmp	DWORD PTR tv226[rsp], 3
	je	SHORT $LN29@GetSimpleE
	jmp	SHORT $LN7@GetSimpleE
$LN28@GetSimpleE:

; 438  :   case EXPR_EMPTY:
; 439  :     DebugMsg(("GetSimpleExpression: empty expression rejected\n"));

	lea	rcx, OFFSET FLAT:$SG11139
	call	DoDebugMsg

; 440  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE)); /* v2.09: changed from NOT_ERROR to ERROR */

	mov	ecx, 199				; 000000c7H
	call	EmitError
	jmp	$LN1@GetSimpleE
$LN29@GetSimpleE:

; 441  :   case EXPR_FLOAT:
; 442  :     DebugMsg(("GetSimpleExpression: float expression rejected: %s\n", tokenarray[op1_pos].tokpos));

	movsxd	rax, DWORD PTR op1_pos$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11141
	call	DoDebugMsg

; 443  :     return(EmitError(REAL_OR_BCD_NUMBER_NOT_ALLOWED)); /* v2.10: added */

	mov	ecx, 270				; 0000010eH
	call	EmitError
	jmp	$LN1@GetSimpleE
$LN7@GetSimpleE:

; 444  :   }
; 445  : 
; 446  :   if (op == COP_NONE) {

	cmp	DWORD PTR op$[rsp], 0
	jne	$LN30@GetSimpleE

; 447  :     switch (op1.kind) {

	mov	eax, DWORD PTR op1$[rsp+60]
	mov	DWORD PTR tv252[rsp], eax
	cmp	DWORD PTR tv252[rsp], 0
	je	$LN34@GetSimpleE
	cmp	DWORD PTR tv252[rsp], 1
	je	$LN33@GetSimpleE
	cmp	DWORD PTR tv252[rsp], 2
	je	SHORT $LN31@GetSimpleE
	jmp	$LN40@GetSimpleE
$LN31@GetSimpleE:

; 448  :     case EXPR_REG:
; 449  :       if (op1.indirect == FALSE) {

	mov	eax, DWORD PTR op1$[rsp+76]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN32@GetSimpleE

; 450  :         p = RenderInstr(buffer, "test", op1_pos, op1_end, op1_pos, op1_end, tokenarray);

	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR op1_end$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR op1_pos$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR op1_end$[rsp]
	mov	r8d, DWORD PTR op1_pos$[rsp]
	lea	rdx, OFFSET FLAT:$SG11145
	mov	rcx, QWORD PTR buffer$[rsp]
	call	RenderInstr
	mov	QWORD PTR p$[rsp], rax

; 451  :         hllop->lastjmp = p;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 452  :         RenderJcc(p, 'z', is_true, label);

	movzx	eax, BYTE PTR is_true$[rsp]
	mov	r9d, DWORD PTR label$[rsp]
	mov	r8d, eax
	mov	dl, 122					; 0000007aH
	mov	rcx, QWORD PTR p$[rsp]
	call	RenderJcc

; 453  :         break;

	jmp	$LN9@GetSimpleE
$LN32@GetSimpleE:
$LN33@GetSimpleE:

; 454  :       }
; 455  :       /* no break */
; 456  :     case EXPR_ADDR:
; 457  :       p = RenderInstr(buffer, "cmp", op1_pos, op1_end, EMPTY, 0, tokenarray);

	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], -2
	mov	r9d, DWORD PTR op1_end$[rsp]
	mov	r8d, DWORD PTR op1_pos$[rsp]
	lea	rdx, OFFSET FLAT:$SG11147
	mov	rcx, QWORD PTR buffer$[rsp]
	call	RenderInstr
	mov	QWORD PTR p$[rsp], rax

; 458  :       hllop->lastjmp = p;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 459  :       RenderJcc(p, 'z', is_true, label);

	movzx	eax, BYTE PTR is_true$[rsp]
	mov	r9d, DWORD PTR label$[rsp]
	mov	r8d, eax
	mov	dl, 122					; 0000007aH
	mov	rcx, QWORD PTR p$[rsp]
	call	RenderJcc

; 460  :       break;

	jmp	$LN9@GetSimpleE
$LN34@GetSimpleE:

; 461  :     case EXPR_CONST:
; 462  : #if 0
; 463  :       /* v2.05: string constant is allowed! */
; 464  :       if (op1.string != NULL) {
; 465  :         return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));
; 466  :       }
; 467  : #endif
; 468  :       /* v2.11: error if constant doesn't fit in 32-bits */
; 469  :       if (op1.hvalue != 0 && op1.hvalue != -1)

	cmp	DWORD PTR op1$[rsp+4], 0
	je	SHORT $LN35@GetSimpleE
	cmp	DWORD PTR op1$[rsp+4], -1
	je	SHORT $LN35@GetSimpleE

; 470  :         return(EmitConstError(&op1));

	lea	rcx, QWORD PTR op1$[rsp]
	call	EmitConstError
	jmp	$LN1@GetSimpleE
$LN35@GetSimpleE:

; 471  : 
; 472  :       hllop->lastjmp = buffer;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rax], rcx

; 473  : 
; 474  :       if ((is_true == TRUE && op1.value) ||

	movzx	eax, BYTE PTR is_true$[rsp]
	cmp	eax, 1
	jne	SHORT $LN39@GetSimpleE
	cmp	DWORD PTR op1$[rsp], 0
	jne	SHORT $LN38@GetSimpleE
$LN39@GetSimpleE:
	movzx	eax, BYTE PTR is_true$[rsp]
	test	eax, eax
	jne	SHORT $LN36@GetSimpleE
	cmp	DWORD PTR op1$[rsp], 0
	jne	SHORT $LN36@GetSimpleE
$LN38@GetSimpleE:

; 475  :         (is_true == FALSE && op1.value == 0)) {
; 476  :         sprintf(buffer, "jmp " LABELFMT EOLSTR, label);

	mov	r8d, DWORD PTR label$[rsp]
	lea	rdx, OFFSET FLAT:$SG11154
	mov	rcx, QWORD PTR buffer$[rsp]
	call	sprintf

; 477  :       }

	jmp	SHORT $LN37@GetSimpleE
$LN36@GetSimpleE:

; 478  :       else {
; 479  :         //strcpy( buffer, " " EOLSTR ); /* v2.11: obsolete */
; 480  :         *buffer = NULLC;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rax], 0
$LN37@GetSimpleE:

; 481  :       }
; 482  :       break;

	jmp	SHORT $LN9@GetSimpleE
$LN40@GetSimpleE:

; 483  : #ifdef DEBUG_OUT
; 484  :     default: /**/myassert(0); break;

	mov	edx, 484				; 000001e4H
	lea	rcx, OFFSET FLAT:$SG11156
	call	InternalError
$LN9@GetSimpleE:

; 485  : #endif
; 486  :     }
; 487  :     return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@GetSimpleE
$LN30@GetSimpleE:

; 488  :   }
; 489  : 
; 490  :   /* get second operand for binary operator */
; 491  :   op2_pos = *i;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR op2_pos$[rsp], eax

; 492  :   if (ERROR == GetToken(hll, i, tokenarray, &op2)) {

	lea	r9, QWORD PTR op2$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetToken
	cmp	eax, -1
	jne	SHORT $LN41@GetSimpleE

; 493  :     return(ERROR);

	mov	eax, -1
	jmp	$LN1@GetSimpleE
$LN41@GetSimpleE:

; 494  :   }
; 495  :   DebugMsg1(("%u GetSimpleExpression: EvalOperand 2 ok, type=%X, i=%u [%s]\n", evallvl, op2.type, *i, tokenarray[*i].tokpos));

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR i$[rsp]
	mov	r9d, DWORD PTR [rax]
	mov	r8, QWORD PTR op2$[rsp+96]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11158
	call	DoDebugMsg1

; 496  :   if (op2.kind != EXPR_CONST && op2.kind != EXPR_ADDR && op2.kind != EXPR_REG) {

	cmp	DWORD PTR op2$[rsp+60], 0
	je	SHORT $LN42@GetSimpleE
	cmp	DWORD PTR op2$[rsp+60], 1
	je	SHORT $LN42@GetSimpleE
	cmp	DWORD PTR op2$[rsp+60], 2
	je	SHORT $LN42@GetSimpleE

; 497  :     DebugMsg(("GetSimpleExpression: syntax error, op2.kind=%u\n", op2.kind));

	mov	edx, DWORD PTR op2$[rsp+60]
	lea	rcx, OFFSET FLAT:$SG11160
	call	DoDebugMsg

; 498  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, 199				; 000000c7H
	call	EmitError
	jmp	$LN1@GetSimpleE
$LN42@GetSimpleE:

; 499  :   }
; 500  :   op2_end = *i;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR op2_end$[rsp], eax

; 501  : 
; 502  :   /* now generate ASM code for expression */
; 503  : 
; 504  :   if (op == COP_ANDB) {

	cmp	DWORD PTR op$[rsp], 9
	jne	SHORT $LN43@GetSimpleE

; 505  :     p = RenderInstr(buffer, "test", op1_pos, op1_end, op2_pos, op2_end, tokenarray);

	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR op2_end$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR op2_pos$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR op1_end$[rsp]
	mov	r8d, DWORD PTR op1_pos$[rsp]
	lea	rdx, OFFSET FLAT:$SG11163
	mov	rcx, QWORD PTR buffer$[rsp]
	call	RenderInstr
	mov	QWORD PTR p$[rsp], rax

; 506  :     hllop->lastjmp = p;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 507  :     RenderJcc(p, 'e', is_true, label);

	movzx	eax, BYTE PTR is_true$[rsp]
	mov	r9d, DWORD PTR label$[rsp]
	mov	r8d, eax
	mov	dl, 101					; 00000065H
	mov	rcx, QWORD PTR p$[rsp]
	call	RenderJcc

; 508  :   }

	jmp	$LN44@GetSimpleE
$LN43@GetSimpleE:

; 509  :   else if (op <= COP_LE) { /* ==, !=, >, <, >= or <= operator */

	cmp	DWORD PTR op$[rsp], 6
	jg	$LN45@GetSimpleE

; 510  :     /*
; 511  :     * optimisation: generate 'or EAX,EAX' instead of 'cmp EAX,0'.
; 512  :     * v2.11: use op2.value64 instead of op2.value
; 513  :     */
; 514  :     if (Options.masm_compat_gencode &&
; 515  :       (op == COP_EQ || op == COP_NE) &&
; 516  :       op1.kind == EXPR_REG && op1.indirect == FALSE &&
; 517  :       op2.kind == EXPR_CONST && op2.value64 == 0) {

	movzx	eax, BYTE PTR Options+144
	test	eax, eax
	je	SHORT $LN47@GetSimpleE
	cmp	DWORD PTR op$[rsp], 1
	je	SHORT $LN49@GetSimpleE
	cmp	DWORD PTR op$[rsp], 2
	jne	SHORT $LN47@GetSimpleE
$LN49@GetSimpleE:
	cmp	DWORD PTR op1$[rsp+60], 2
	jne	SHORT $LN47@GetSimpleE
	mov	eax, DWORD PTR op1$[rsp+76]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN47@GetSimpleE
	cmp	DWORD PTR op2$[rsp+60], 0
	jne	SHORT $LN47@GetSimpleE
	cmp	QWORD PTR op2$[rsp], 0
	jne	SHORT $LN47@GetSimpleE

; 518  :       p = RenderInstr(buffer, "or", op1_pos, op1_end, op1_pos, op1_end, tokenarray);

	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR op1_end$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR op1_pos$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR op1_end$[rsp]
	mov	r8d, DWORD PTR op1_pos$[rsp]
	lea	rdx, OFFSET FLAT:$SG11169
	mov	rcx, QWORD PTR buffer$[rsp]
	call	RenderInstr
	mov	QWORD PTR p$[rsp], rax

; 519  :     }

	jmp	SHORT $LN48@GetSimpleE
$LN47@GetSimpleE:

; 520  :     else {
; 521  :       p = RenderInstr(buffer, "cmp", op1_pos, op1_end, op2_pos, op2_end, tokenarray);

	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR op2_end$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR op2_pos$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR op1_end$[rsp]
	mov	r8d, DWORD PTR op1_pos$[rsp]
	lea	rdx, OFFSET FLAT:$SG11170
	mov	rcx, QWORD PTR buffer$[rsp]
	call	RenderInstr
	mov	QWORD PTR p$[rsp], rax
$LN48@GetSimpleE:

; 522  :     }
; 523  : 
; 524  :     instr = ((IS_SIGNED(op1.mem_type) || IS_SIGNED(op2.mem_type)) ? signed_cjmptype[op - COP_EQ] : unsigned_cjmptype[op - COP_EQ]);

	mov	eax, DWORD PTR op1$[rsp+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN53@GetSimpleE
	mov	eax, DWORD PTR op2$[rsp+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN53@GetSimpleE
	mov	eax, DWORD PTR op$[rsp]
	dec	eax
	cdqe
	lea	rcx, OFFSET FLAT:unsigned_cjmptype
	movsx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv379[rsp], eax
	jmp	SHORT $LN54@GetSimpleE
$LN53@GetSimpleE:
	mov	eax, DWORD PTR op$[rsp]
	dec	eax
	cdqe
	lea	rcx, OFFSET FLAT:signed_cjmptype
	movsx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv379[rsp], eax
$LN54@GetSimpleE:
	movzx	eax, BYTE PTR tv379[rsp]
	mov	BYTE PTR instr$[rsp], al

; 525  :     hllop->lastjmp = p;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 526  :     RenderJcc(p, instr, neg_cjmptype[op - COP_EQ] ? is_true : !is_true, label);

	mov	eax, DWORD PTR op$[rsp]
	dec	eax
	cdqe
	lea	rcx, OFFSET FLAT:neg_cjmptype
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN57@GetSimpleE
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	DWORD PTR tv426[rsp], eax
	jmp	SHORT $LN58@GetSimpleE
$LN57@GetSimpleE:
	movzx	eax, BYTE PTR is_true$[rsp]
	test	eax, eax
	jne	SHORT $LN55@GetSimpleE
	mov	DWORD PTR tv424[rsp], 1
	jmp	SHORT $LN56@GetSimpleE
$LN55@GetSimpleE:
	mov	DWORD PTR tv424[rsp], 0
$LN56@GetSimpleE:
	mov	eax, DWORD PTR tv424[rsp]
	mov	DWORD PTR tv426[rsp], eax
$LN58@GetSimpleE:
	mov	r9d, DWORD PTR label$[rsp]
	mov	r8d, DWORD PTR tv426[rsp]
	movzx	edx, BYTE PTR instr$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	RenderJcc

; 527  :   }

	jmp	SHORT $LN46@GetSimpleE
$LN45@GetSimpleE:

; 528  :   else {
; 529  :     DebugMsg(("GetSimpleExpression: unexpected operator %s\n", tokenarray[op1_pos].tokpos));

	movsxd	rax, DWORD PTR op1_pos$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11171
	call	DoDebugMsg

; 530  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, 199				; 000000c7H
	call	EmitError
	jmp	SHORT $LN1@GetSimpleE
$LN46@GetSimpleE:
$LN44@GetSimpleE:

; 531  :   }
; 532  :   return(NOT_ERROR);

	xor	eax, eax
$LN1@GetSimpleE:

; 533  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:GetSimpleExpression$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 416				; 000001a0H
	pop	rdi
	ret	0
GetSimpleExpression ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
tv72 = 32
hll$ = 64
index$ = 72
GetLabel PROC

; 334  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 335  :   /**/myassert(hll->labels[index]);

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax*4+8], 0
	je	SHORT $LN3@GetLabel
	mov	DWORD PTR tv72[rsp], 0
	jmp	SHORT $LN4@GetLabel
$LN3@GetLabel:
	mov	edx, 335				; 0000014fH
	lea	rcx, OFFSET FLAT:$SG11077
	call	InternalError
	mov	DWORD PTR tv72[rsp], eax
$LN4@GetLabel:

; 336  :   return(hll->labels[index]);

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4+8]

; 337  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
GetLabel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
old$ = 32
dst$ = 64
cc$ = 72
neg$ = 80
label$ = 88
RenderJcc PROC

; 279  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 280  : #ifdef DEBUG_OUT
; 281  :   char *old = dst;

	mov	rax, QWORD PTR dst$[rsp]
	mov	QWORD PTR old$[rsp], rax

; 282  : #endif
; 283  :   /* create the jump opcode: j[n]cc */
; 284  :   *dst++ = 'j';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 106			; 0000006aH
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 285  :   if (neg)

	cmp	DWORD PTR neg$[rsp], 0
	je	SHORT $LN2@RenderJcc

; 286  :     *dst++ = 'n';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 110			; 0000006eH
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
$LN2@RenderJcc:

; 287  :   *dst++ = cc;

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR cc$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 288  :   if (neg == FALSE)

	cmp	DWORD PTR neg$[rsp], 0
	jne	SHORT $LN3@RenderJcc

; 289  :     *dst++ = ' '; /* make sure there's room for the inverse jmp */

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
$LN3@RenderJcc:

; 290  : 
; 291  :   *dst++ = ' ';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 292  :   GetLabelStr(label, dst);

	mov	rdx, QWORD PTR dst$[rsp]
	mov	ecx, DWORD PTR label$[rsp]
	call	GetLabelStr

; 293  :   dst += strlen(dst);

	mov	rcx, QWORD PTR dst$[rsp]
	call	strlen
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dst$[rsp], rax

; 294  :   *dst++ = EOLCHAR;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 94			; 0000005eH
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 295  :   *dst = NULLC;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 0

; 296  :   DebugMsg1(("%u RenderJcc()=>%s<\n", evallvl, old));

	mov	r8, QWORD PTR old$[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11052
	call	DoDebugMsg1

; 297  :   return(dst);

	mov	rax, QWORD PTR dst$[rsp]

; 298  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
RenderJcc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
label$ = 48
buff$ = 56
GetLabelStr PROC

; 270  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 271  :   sprintf(buff, LABELFMT, label);

	mov	r8d, DWORD PTR label$[rsp]
	lea	rdx, OFFSET FLAT:$SG11038
	mov	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 272  :   return(buff);

	mov	rax, QWORD PTR buff$[rsp]

; 273  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
GetLabelStr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
i$ = 32
old$ = 40
dst$ = 64
instr$ = 72
start1$ = 80
end1$ = 88
start2$ = 96
end2$ = 104
tokenarray$ = 112
RenderInstr PROC

; 237  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 238  :   int i;
; 239  : #ifdef DEBUG_OUT
; 240  :   char *old = dst;

	mov	rax, QWORD PTR dst$[rsp]
	mov	QWORD PTR old$[rsp], rax

; 241  : #endif
; 242  :   i = strlen(instr);

	mov	rcx, QWORD PTR instr$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax

; 243  :   /* copy the instruction */
; 244  :   memcpy(dst, instr, i);

	movsxd	rax, DWORD PTR i$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR instr$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	call	memcpy

; 245  :   dst += i;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dst$[rsp], rax

; 246  :   /* copy the first operand's tokens */
; 247  :   *dst++ = ' ';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 248  :   i = tokenarray[end1].tokpos - tokenarray[start1].tokpos;

	movsxd	rax, DWORD PTR end1$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR start1$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR i$[rsp], eax

; 249  :   memcpy(dst, tokenarray[start1].tokpos, i);

	movsxd	rax, DWORD PTR i$[rsp]
	movsxd	rcx, DWORD PTR start1$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+24]
	mov	rcx, QWORD PTR dst$[rsp]
	call	memcpy

; 250  :   dst += i;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dst$[rsp], rax

; 251  :   if (start2 != EMPTY) {

	cmp	DWORD PTR start2$[rsp], -2
	je	$LN2@RenderInst

; 252  :     *dst++ = ',';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 44			; 0000002cH
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 253  :     /* copy the second operand's tokens */
; 254  :     *dst++ = ' ';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 255  :     i = tokenarray[end2].tokpos - tokenarray[start2].tokpos;

	movsxd	rax, DWORD PTR end2$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR start2$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR i$[rsp], eax

; 256  :     memcpy(dst, tokenarray[start2].tokpos, i);

	movsxd	rax, DWORD PTR i$[rsp]
	movsxd	rcx, DWORD PTR start2$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+24]
	mov	rcx, QWORD PTR dst$[rsp]
	call	memcpy

; 257  :     dst += i; 

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dst$[rsp], rax

; 258  :   }

	jmp	SHORT $LN3@RenderInst
$LN2@RenderInst:

; 259  :   else if (end2 != EMPTY) {

	cmp	DWORD PTR end2$[rsp], -2
	je	SHORT $LN4@RenderInst

; 260  :     dst += sprintf(dst, ", %d", end2);

	mov	r8d, DWORD PTR end2$[rsp]
	lea	rdx, OFFSET FLAT:$SG11030
	mov	rcx, QWORD PTR dst$[rsp]
	call	sprintf
	cdqe
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dst$[rsp], rax
$LN4@RenderInst:
$LN3@RenderInst:

; 261  :   }
; 262  :   *dst++ = EOLCHAR;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 94			; 0000005eH
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 263  :   *dst = NULLC;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 0

; 264  :   DebugMsg1(("%u RenderInstr(%s)=>%s<\n", evallvl, instr, old));

	mov	r9, QWORD PTR old$[rsp]
	mov	r8, QWORD PTR instr$[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11031
	call	DoDebugMsg1

; 265  :   return(dst);

	mov	rax, QWORD PTR dst$[rsp]

; 266  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
RenderInstr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
size$ = 32
rc$ = 36
p$ = 40
tv69 = 48
tv72 = 52
tv82 = 56
item$ = 80
GetCOp	PROC

; 172  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 173  :   int size;
; 174  :   enum c_bop rc;
; 175  :   char *p = item->string_ptr;

	mov	rax, QWORD PTR item$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR p$[rsp], rax

; 176  : 
; 177  :   size = (item->token == T_STRING ? item->stringlen : 0);

	mov	rax, QWORD PTR item$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 9
	jne	SHORT $LN45@GetCOp
	mov	rax, QWORD PTR item$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN46@GetCOp
$LN45@GetCOp:
	mov	DWORD PTR tv69[rsp], 0
$LN46@GetCOp:
	mov	eax, DWORD PTR tv69[rsp]
	mov	DWORD PTR size$[rsp], eax

; 178  : 
; 179  :   if (size == 2) {

	cmp	DWORD PTR size$[rsp], 2
	jne	$LN6@GetCOp

; 180  :     switch (*(uint_16 *)p) {

	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR tv72[rsp], eax
	cmp	DWORD PTR tv72[rsp], 15677		; 00003d3dH
	jg	SHORT $LN47@GetCOp
	cmp	DWORD PTR tv72[rsp], 15677		; 00003d3dH
	je	SHORT $LN8@GetCOp
	cmp	DWORD PTR tv72[rsp], 9766		; 00002626H
	je	SHORT $LN12@GetCOp
	cmp	DWORD PTR tv72[rsp], 15649		; 00003d21H
	je	SHORT $LN9@GetCOp
	cmp	DWORD PTR tv72[rsp], 15676		; 00003d3cH
	je	SHORT $LN11@GetCOp
	jmp	SHORT $LN14@GetCOp
$LN47@GetCOp:
	cmp	DWORD PTR tv72[rsp], 15678		; 00003d3eH
	je	SHORT $LN10@GetCOp
	cmp	DWORD PTR tv72[rsp], 31868		; 00007c7cH
	je	SHORT $LN13@GetCOp
	jmp	SHORT $LN14@GetCOp
$LN8@GetCOp:

; 181  :     case CHARS_EQ:  rc = COP_EQ;  break;

	mov	DWORD PTR rc$[rsp], 1
	jmp	SHORT $LN2@GetCOp
$LN9@GetCOp:

; 182  :     case CHARS_NE:  rc = COP_NE;  break;

	mov	DWORD PTR rc$[rsp], 2
	jmp	SHORT $LN2@GetCOp
$LN10@GetCOp:

; 183  :     case CHARS_GE:  rc = COP_GE;  break;

	mov	DWORD PTR rc$[rsp], 5
	jmp	SHORT $LN2@GetCOp
$LN11@GetCOp:

; 184  :     case CHARS_LE:  rc = COP_LE;  break;

	mov	DWORD PTR rc$[rsp], 6
	jmp	SHORT $LN2@GetCOp
$LN12@GetCOp:

; 185  :     case CHARS_AND: rc = COP_AND; break;

	mov	DWORD PTR rc$[rsp], 7
	jmp	SHORT $LN2@GetCOp
$LN13@GetCOp:

; 186  :     case CHARS_OR:  rc = COP_OR;  break;

	mov	DWORD PTR rc$[rsp], 8
	jmp	SHORT $LN2@GetCOp
$LN14@GetCOp:

; 187  :     default: return(COP_NONE);

	xor	eax, eax
	jmp	$LN1@GetCOp
$LN2@GetCOp:

; 188  :     }
; 189  :   }

	jmp	$LN7@GetCOp
$LN6@GetCOp:

; 190  :   else if (size == 1) {

	cmp	DWORD PTR size$[rsp], 1
	jne	SHORT $LN15@GetCOp

; 191  :     switch (*p) {

	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv82[rsp], al
	cmp	BYTE PTR tv82[rsp], 33			; 00000021H
	je	SHORT $LN20@GetCOp
	cmp	BYTE PTR tv82[rsp], 38			; 00000026H
	je	SHORT $LN19@GetCOp
	cmp	BYTE PTR tv82[rsp], 60			; 0000003cH
	je	SHORT $LN18@GetCOp
	cmp	BYTE PTR tv82[rsp], 62			; 0000003eH
	je	SHORT $LN17@GetCOp
	jmp	SHORT $LN21@GetCOp
$LN17@GetCOp:

; 192  :     case '>': rc = COP_GT;   break;

	mov	DWORD PTR rc$[rsp], 3
	jmp	SHORT $LN4@GetCOp
$LN18@GetCOp:

; 193  :     case '<': rc = COP_LT;   break;

	mov	DWORD PTR rc$[rsp], 4
	jmp	SHORT $LN4@GetCOp
$LN19@GetCOp:

; 194  :     case '&': rc = COP_ANDB; break;

	mov	DWORD PTR rc$[rsp], 9
	jmp	SHORT $LN4@GetCOp
$LN20@GetCOp:

; 195  :     case '!': rc = COP_NEG;  break;

	mov	DWORD PTR rc$[rsp], 10
	jmp	SHORT $LN4@GetCOp
$LN21@GetCOp:

; 196  :     default: return(COP_NONE);

	xor	eax, eax
	jmp	$LN1@GetCOp
$LN4@GetCOp:

; 197  :     }
; 198  :   }

	jmp	$LN16@GetCOp
$LN15@GetCOp:

; 199  :   else {
; 200  :     if (item->token != T_ID)

	mov	rax, QWORD PTR item$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 8
	je	SHORT $LN22@GetCOp

; 201  :       return(COP_NONE);

	xor	eax, eax
	jmp	$LN1@GetCOp
$LN22@GetCOp:

; 202  :     /* a valid "flag" string must end with a question mark */
; 203  :     size = strlen(p);

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	DWORD PTR size$[rsp], eax

; 204  :     if (*(p + size - 1) != '?')

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax-1]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN23@GetCOp

; 205  :       return(COP_NONE);

	xor	eax, eax
	jmp	$LN1@GetCOp
$LN23@GetCOp:

; 206  :     if (size == 5 && (0 == _memicmp(p, "ZERO", 4)))

	cmp	DWORD PTR size$[rsp], 5
	jne	SHORT $LN24@GetCOp
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG10981
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN24@GetCOp

; 207  :       rc = COP_ZERO;

	mov	DWORD PTR rc$[rsp], 11
	jmp	$LN25@GetCOp
$LN24@GetCOp:

; 208  :     else if (size == 6 && (0 == _memicmp(p, "CARRY", 5)))

	cmp	DWORD PTR size$[rsp], 6
	jne	SHORT $LN26@GetCOp
	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG10984
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN26@GetCOp

; 209  :       rc = COP_CARRY;

	mov	DWORD PTR rc$[rsp], 12
	jmp	$LN27@GetCOp
$LN26@GetCOp:

; 210  :     else if (size == 5 && (0 == _memicmp(p, "SIGN", 4)))

	cmp	DWORD PTR size$[rsp], 5
	jne	SHORT $LN28@GetCOp
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG10987
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN28@GetCOp

; 211  :       rc = COP_SIGN;

	mov	DWORD PTR rc$[rsp], 13
	jmp	$LN29@GetCOp
$LN28@GetCOp:

; 212  :     else if (size == 7 && (0 == _memicmp(p, "PARITY", 6)))

	cmp	DWORD PTR size$[rsp], 7
	jne	SHORT $LN30@GetCOp
	mov	r8d, 6
	lea	rdx, OFFSET FLAT:$SG10990
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN30@GetCOp

; 213  :       rc = COP_PARITY;

	mov	DWORD PTR rc$[rsp], 14
	jmp	$LN31@GetCOp
$LN30@GetCOp:

; 214  :     else if (size == 9 && (0 == _memicmp(p, "OVERFLOW", 8)))

	cmp	DWORD PTR size$[rsp], 9
	jne	SHORT $LN32@GetCOp
	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG10993
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN32@GetCOp

; 215  :       rc = COP_OVERFLOW;

	mov	DWORD PTR rc$[rsp], 15
	jmp	$LN33@GetCOp
$LN32@GetCOp:

; 216  :     //added by habran
; 217  :     else if (size == 5 && (0 == _memicmp(p, "LESS", 4)))

	cmp	DWORD PTR size$[rsp], 5
	jne	SHORT $LN34@GetCOp
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG10996
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN34@GetCOp

; 218  :       rc = COP_LESS;

	mov	DWORD PTR rc$[rsp], 16
	jmp	$LN35@GetCOp
$LN34@GetCOp:

; 219  :     else if (size == 8 && (0 == _memicmp(p, "GREATER", 7)))

	cmp	DWORD PTR size$[rsp], 8
	jne	SHORT $LN36@GetCOp
	mov	r8d, 7
	lea	rdx, OFFSET FLAT:$SG10999
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN36@GetCOp

; 220  :       rc = COP_GREATER;

	mov	DWORD PTR rc$[rsp], 17
	jmp	$LN37@GetCOp
$LN36@GetCOp:

; 221  :     else if (size == 6 && (0 == _memicmp(p, "ABOVE", 5)))

	cmp	DWORD PTR size$[rsp], 6
	jne	SHORT $LN38@GetCOp
	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG11002
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN38@GetCOp

; 222  :       rc = COP_ABOVE;

	mov	DWORD PTR rc$[rsp], 18
	jmp	SHORT $LN39@GetCOp
$LN38@GetCOp:

; 223  :     else if (size == 6 && (0 == _memicmp(p, "EQUAL", 5)))

	cmp	DWORD PTR size$[rsp], 6
	jne	SHORT $LN40@GetCOp
	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG11005
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN40@GetCOp

; 224  :       rc = COP_EQUAL;

	mov	DWORD PTR rc$[rsp], 19
	jmp	SHORT $LN41@GetCOp
$LN40@GetCOp:

; 225  :     else if (size == 6 && (0 == _memicmp(p, "BELOW", 5)))

	cmp	DWORD PTR size$[rsp], 6
	jne	SHORT $LN42@GetCOp
	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG11008
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN42@GetCOp

; 226  :       rc = COP_BELOW;

	mov	DWORD PTR rc$[rsp], 20
	jmp	SHORT $LN43@GetCOp
$LN42@GetCOp:

; 227  :     else
; 228  :       return(COP_NONE);

	xor	eax, eax
	jmp	SHORT $LN1@GetCOp
$LN43@GetCOp:
$LN41@GetCOp:
$LN39@GetCOp:
$LN37@GetCOp:
$LN35@GetCOp:
$LN33@GetCOp:
$LN31@GetCOp:
$LN29@GetCOp:
$LN27@GetCOp:
$LN25@GetCOp:
$LN16@GetCOp:
$LN7@GetCOp:

; 229  :   }
; 230  :   return(rc);

	mov	eax, DWORD PTR rc$[rsp]
$LN1@GetCOp:

; 231  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
GetCOp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
GetHllLabel PROC

; 151  : {

	push	rdi

; 152  :   return (++ModuleInfo.hll_label);

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	eax, DWORD PTR ModuleInfo+352

; 153  : }

	pop	rdi
	ret	0
GetHllLabel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
ptr$ = 64
truelabel$ = 72
nlabel$4 = 76
olabel$5 = 80
buff$6 = 104
p$7 = 136
tv83 = 152
tv128 = 160
tv169 = 168
tv178 = 176
tv206 = 184
tv242 = 188
__$ArrayPad$ = 192
hll$ = 224
i$ = 232
tokenarray$ = 240
ilabel$ = 248
is_true$ = 256
buffer$ = 264
hllop$ = 272
GetExpression PROC

; 676  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 208				; 000000d0H
	mov	rdi, rsp
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+224]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 677  :   char *ptr = buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR ptr$[rsp], rax

; 678  :   uint_32 truelabel = 0;

	mov	DWORD PTR truelabel$[rsp], 0

; 679  : 
; 680  :   DebugMsg1(("%u GetExpression(>%.32s< buf=>%s<) enter\n", ++evallvl, tokenarray[*i].tokpos, buffer));

	mov	eax, DWORD PTR evallvl
	inc	eax
	mov	DWORD PTR evallvl, eax
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	r9, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11269
	call	DoDebugMsg1

; 681  : 
; 682  :   /* v2.08: structure changed from for(;;) to while() to increase
; 683  :   * readability and - optionally - handle the second operand differently
; 684  :   * than the first.
; 685  :   */
; 686  : 
; 687  :   if (ERROR == GetAndExpression(hll, i, tokenarray, ilabel, is_true, ptr, hllop)) {

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR ilabel$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetAndExpression
	cmp	eax, -1
	jne	SHORT $LN4@GetExpress

; 688  :     DebugMsg1(("%u GetExpression exit, error\n", evallvl--));

	mov	eax, DWORD PTR evallvl
	mov	DWORD PTR tv83[rsp], eax
	mov	eax, DWORD PTR evallvl
	dec	eax
	mov	DWORD PTR evallvl, eax
	mov	edx, DWORD PTR tv83[rsp]
	lea	rcx, OFFSET FLAT:$SG11271
	call	DoDebugMsg1

; 689  :     return(ERROR);

	mov	eax, -1
	jmp	$LN1@GetExpress
$LN4@GetExpress:
$LN2@GetExpress:

; 690  :   }
; 691  :   while (COP_OR == GetCOp(&tokenarray[*i])) {

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	GetCOp
	cmp	eax, 8
	jne	$LN3@GetExpress

; 692  : 
; 693  :     uint_32 nlabel;
; 694  :     uint_32 olabel;
; 695  :     char buff[16];
; 696  : 
; 697  :     /* the generated code of last simple expression has to be modified
; 698  :     1. the last jump must be inverted
; 699  :     2. a "is_true" label must be created (it's used to jump "behind" the expr)
; 700  :     3. create a new label
; 701  :     4. the current "false" label must be generated
; 702  : 
; 703  :     if it is a .REPEAT, step 4 is slightly more difficult, since the "false"
; 704  :     label is already "gone":
; 705  :     4a. create a new label
; 706  :     4b. replace the "false" label in the generated code by the new label
; 707  :     */
; 708  : 
; 709  :     (*i)++;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax

; 710  :     DebugMsg1(("%u GetExpression: ||-operator found, is_true=%u, lastjmp=%s\n", evallvl, is_true, hllop->lastjmp ? hllop->lastjmp : "NULL"));

	mov	rax, QWORD PTR hllop$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN16@GetExpress
	mov	rax, QWORD PTR hllop$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv128[rsp], rax
	jmp	SHORT $LN17@GetExpress
$LN16@GetExpress:
	lea	rax, OFFSET FLAT:$SG11272
	mov	QWORD PTR tv128[rsp], rax
$LN17@GetExpress:
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	r9, QWORD PTR tv128[rsp]
	mov	r8d, eax
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11273
	call	DoDebugMsg1

; 711  : 
; 712  :     if (is_true == FALSE) {

	movzx	eax, BYTE PTR is_true$[rsp]
	test	eax, eax
	jne	$LN5@GetExpress

; 713  :       if (hllop->lastjmp) {

	mov	rax, QWORD PTR hllop$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN6@GetExpress

; 714  :         char *p = hllop->lastjmp;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$7[rsp], rax

; 715  :         InvertJump(p);           /* step 1 */

	mov	rcx, QWORD PTR p$7[rsp]
	call	InvertJump

; 716  :         if (truelabel == 0)      /* step 2 */

	cmp	DWORD PTR truelabel$[rsp], 0
	jne	SHORT $LN7@GetExpress

; 717  :           truelabel = GetHllLabel();

	call	GetHllLabel
	mov	DWORD PTR truelabel$[rsp], eax
$LN7@GetExpress:

; 718  :         if (*p) { /* v2.11: there might be a 0 at lastjmp */

	mov	rax, QWORD PTR p$7[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN8@GetExpress

; 719  :           p += 4;                /* skip 'jcc ' or 'jmp ' */

	mov	rax, QWORD PTR p$7[rsp]
	add	rax, 4
	mov	QWORD PTR p$7[rsp], rax

; 720  :           GetLabelStr(truelabel, p);

	mov	rdx, QWORD PTR p$7[rsp]
	mov	ecx, DWORD PTR truelabel$[rsp]
	call	GetLabelStr

; 721  :           strcat(p, EOLSTR);

	lea	rdx, OFFSET FLAT:$SG11278
	mov	rcx, QWORD PTR p$7[rsp]
	call	strcat
$LN8@GetExpress:

; 722  :         }
; 723  :         /* v2.08: if-block added */
; 724  :         if (hllop->lasttruelabel)

	mov	rax, QWORD PTR hllop$[rsp]
	cmp	DWORD PTR [rax+8], 0
	je	SHORT $LN9@GetExpress

; 725  :           ReplaceLabel(ptr, hllop->lasttruelabel, truelabel);

	mov	r8d, DWORD PTR truelabel$[rsp]
	mov	rax, QWORD PTR hllop$[rsp]
	mov	edx, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR ptr$[rsp]
	call	ReplaceLabel
$LN9@GetExpress:

; 726  :         DebugMsg1(("%u GetExpression: jmp inverted, dest changed >%s<\n", evallvl, ptr));

	mov	r8, QWORD PTR ptr$[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11280
	call	DoDebugMsg1

; 727  :         hllop->lastjmp = NULL;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rax], 0

; 728  : 
; 729  :         nlabel = GetHllLabel();  /* step 3 */

	call	GetHllLabel
	mov	DWORD PTR nlabel$4[rsp], eax

; 730  :         olabel = GetLabel(hll, ilabel);

	mov	edx, DWORD PTR ilabel$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetLabel
	mov	DWORD PTR olabel$5[rsp], eax

; 731  :         if (hll->cmd == HLL_REPEAT) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+52], 2
	jne	SHORT $LN10@GetExpress

; 732  :           ReplaceLabel(buffer, olabel, nlabel);

	mov	r8d, DWORD PTR nlabel$4[rsp]
	mov	edx, DWORD PTR olabel$5[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	ReplaceLabel

; 733  :           sprintf(ptr + strlen(ptr), "%s" LABELQUAL EOLSTR, GetLabelStr(nlabel, buff));

	lea	rdx, QWORD PTR buff$6[rsp]
	mov	ecx, DWORD PTR nlabel$4[rsp]
	call	GetLabelStr
	mov	QWORD PTR tv169[rsp], rax
	mov	rcx, QWORD PTR ptr$[rsp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR tv169[rsp]
	mov	r8, rcx
	lea	rdx, OFFSET FLAT:$SG11283
	mov	rcx, rax
	call	sprintf

; 734  :         }

	jmp	SHORT $LN11@GetExpress
$LN10@GetExpress:

; 735  :         else {
; 736  :           sprintf(ptr + strlen(ptr), "%s" LABELQUAL EOLSTR, GetLabelStr(olabel, buff));

	lea	rdx, QWORD PTR buff$6[rsp]
	mov	ecx, DWORD PTR olabel$5[rsp]
	call	GetLabelStr
	mov	QWORD PTR tv178[rsp], rax
	mov	rcx, QWORD PTR ptr$[rsp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR tv178[rsp]
	mov	r8, rcx
	lea	rdx, OFFSET FLAT:$SG11284
	mov	rcx, rax
	call	sprintf

; 737  :           ReplaceLabel(buffer, olabel, nlabel);

	mov	r8d, DWORD PTR nlabel$4[rsp]
	mov	edx, DWORD PTR olabel$5[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	ReplaceLabel
$LN11@GetExpress:

; 738  :         }
; 739  :         DebugMsg1(("%u GetExpression: dest changed, label added >%s<\n", evallvl, ptr));

	mov	r8, QWORD PTR ptr$[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11285
	call	DoDebugMsg1
$LN6@GetExpress:
$LN5@GetExpress:

; 740  :       }
; 741  :     }
; 742  :     ptr += strlen(ptr);

	mov	rcx, QWORD PTR ptr$[rsp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rsp], rax

; 743  :     hllop->lasttruelabel = 0; /* v2.08 */

	mov	rax, QWORD PTR hllop$[rsp]
	mov	DWORD PTR [rax+8], 0

; 744  :     if (ERROR == GetAndExpression(hll, i, tokenarray, ilabel, is_true, ptr, hllop)) {

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR ilabel$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetAndExpression
	cmp	eax, -1
	jne	SHORT $LN12@GetExpress

; 745  :       DebugMsg1(("%u GetExpression exit, error\n", evallvl--));

	mov	eax, DWORD PTR evallvl
	mov	DWORD PTR tv206[rsp], eax
	mov	eax, DWORD PTR evallvl
	dec	eax
	mov	DWORD PTR evallvl, eax
	mov	edx, DWORD PTR tv206[rsp]
	lea	rcx, OFFSET FLAT:$SG11287
	call	DoDebugMsg1

; 746  :       return(ERROR);

	mov	eax, -1
	jmp	$LN1@GetExpress
$LN12@GetExpress:

; 747  :     }
; 748  :   }

	jmp	$LN2@GetExpress
$LN3@GetExpress:

; 749  :   if (truelabel > 0) {

	cmp	DWORD PTR truelabel$[rsp], 0
	jbe	$LN13@GetExpress

; 750  :     /* v2.08: this is needed, but ober-hackish. to be improved... */
; 751  :     if (hllop->lastjmp && hllop->lasttruelabel) {

	mov	rax, QWORD PTR hllop$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN14@GetExpress
	mov	rax, QWORD PTR hllop$[rsp]
	cmp	DWORD PTR [rax+8], 0
	je	SHORT $LN14@GetExpress

; 752  :       DebugMsg1(("%u GetExpression: suppressed ReplaceLabel %u -> %u, lastjmp=%s\n", evallvl, hllop->lasttruelabel, truelabel, hllop->lastjmp));

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR truelabel$[rsp]
	mov	rax, QWORD PTR hllop$[rsp]
	mov	r8d, DWORD PTR [rax+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11290
	call	DoDebugMsg1

; 753  :       ReplaceLabel(ptr, hllop->lasttruelabel, truelabel);

	mov	r8d, DWORD PTR truelabel$[rsp]
	mov	rax, QWORD PTR hllop$[rsp]
	mov	edx, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR ptr$[rsp]
	call	ReplaceLabel

; 754  :       *(strchr(hllop->lastjmp, EOLCHAR) + 1) = NULLC;

	mov	edx, 94					; 0000005eH
	mov	rax, QWORD PTR hllop$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp_strchr
	mov	BYTE PTR [rax+1], 0
$LN14@GetExpress:

; 755  :     }
; 756  :     ptr += strlen(ptr);

	mov	rcx, QWORD PTR ptr$[rsp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rsp], rax

; 757  :     GetLabelStr(truelabel, ptr);

	mov	rdx, QWORD PTR ptr$[rsp]
	mov	ecx, DWORD PTR truelabel$[rsp]
	call	GetLabelStr

; 758  :     strcat(ptr, LABELQUAL EOLSTR);

	lea	rdx, OFFSET FLAT:$SG11291
	mov	rcx, QWORD PTR ptr$[rsp]
	call	strcat

; 759  :     DebugMsg1(("%u GetExpression: label added >%s<\n", evallvl, ptr));

	mov	r8, QWORD PTR ptr$[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11292
	call	DoDebugMsg1

; 760  :     hllop->lasttruelabel = truelabel; /* v2.08 */

	mov	rax, QWORD PTR hllop$[rsp]
	mov	ecx, DWORD PTR truelabel$[rsp]
	mov	DWORD PTR [rax+8], ecx
$LN13@GetExpress:

; 761  :   }
; 762  :   DebugMsg1(("%u GetExpression exit\n", evallvl--));

	mov	eax, DWORD PTR evallvl
	mov	DWORD PTR tv242[rsp], eax
	mov	eax, DWORD PTR evallvl
	dec	eax
	mov	DWORD PTR evallvl, eax
	mov	edx, DWORD PTR tv242[rsp]
	lea	rcx, OFFSET FLAT:$SG11293
	call	DoDebugMsg1

; 763  :   return(NOT_ERROR);

	xor	eax, eax
$LN1@GetExpress:

; 764  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:GetExpression$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 208				; 000000d0H
	pop	rdi
	ret	0
GetExpression ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
end_tok$ = 48
hll$ = 80
i$ = 88
tokenarray$ = 96
opnd$ = 104
GetToken PROC

; 304  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 305  :   int end_tok;
; 306  : 
; 307  :   /* scan for the next C operator in the token array.
; 308  :   * because the ASM evaluator may report an error if such a thing
; 309  :   * is found ( CARRY?, ZERO? and alikes will be regarded as - not yet defined - labels )
; 310  :   */
; 311  :   for (end_tok = *i; end_tok < Token_Count; end_tok++) {

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR end_tok$[rsp], eax
	jmp	SHORT $LN4@GetToken
$LN2@GetToken:
	mov	eax, DWORD PTR end_tok$[rsp]
	inc	eax
	mov	DWORD PTR end_tok$[rsp], eax
$LN4@GetToken:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR end_tok$[rsp], eax
	jge	SHORT $LN3@GetToken

; 312  :     if ((GetCOp(&tokenarray[end_tok])) != COP_NONE)

	movsxd	rax, DWORD PTR end_tok$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	GetCOp
	test	eax, eax
	je	SHORT $LN5@GetToken

; 313  :       break;

	jmp	SHORT $LN3@GetToken
$LN5@GetToken:

; 314  :   }

	jmp	SHORT $LN2@GetToken
$LN3@GetToken:

; 315  :   if (end_tok == *i) {

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR end_tok$[rsp], eax
	jne	SHORT $LN6@GetToken

; 316  :     opnd->kind = EXPR_EMPTY;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], -2

; 317  :     return(NOT_ERROR);

	xor	eax, eax
	jmp	SHORT $LN1@GetToken
$LN6@GetToken:

; 318  :   }
; 319  :   if (ERROR == EvalOperand(i, tokenarray, end_tok, opnd, 0))

	mov	BYTE PTR [rsp+32], 0
	mov	r9, QWORD PTR opnd$[rsp]
	mov	r8d, DWORD PTR end_tok$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN7@GetToken

; 320  :     return(ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@GetToken
$LN7@GetToken:

; 321  : 
; 322  :   /* v2.11: emit error 'syntax error in control flow directive'.
; 323  :   * May happen for expressions like ".if 1 + CARRY?"
; 324  :   */
; 325  :   if (*i > end_tok) {

	mov	rax, QWORD PTR i$[rsp]
	mov	ecx, DWORD PTR end_tok$[rsp]
	cmp	DWORD PTR [rax], ecx
	jle	SHORT $LN8@GetToken

; 326  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, 199				; 000000c7H
	call	EmitError
	jmp	SHORT $LN1@GetToken
$LN8@GetToken:

; 327  :   }
; 328  : 
; 329  :   return(NOT_ERROR);

	xor	eax, eax
$LN1@GetToken:

; 330  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
GetToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
HllCheckOpen PROC

; 1713 : {

$LN4:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1714 :   if (HllStack) {

	cmp	QWORD PTR ModuleInfo+224, 0
	je	SHORT $LN2@HllCheckOp

; 1715 :     //EmitErr( BLOCK_NESTING_ERROR, ".if-.repeat-.while" );
; 1716 :     EmitErr(UNMATCHED_BLOCK_NESTING, ".if-.repeat-.while");

	lea	rdx, OFFSET FLAT:$SG11820
	mov	ecx, 142				; 0000008eH
	call	EmitErr
$LN2@HllCheckOp:

; 1717 :   }
; 1718 :   DebugMsg(("HllCheckOpen: allocated items:%u, reused items:%u, .while cond-blocks/bytes:%u/%u\n", cntAlloc, cntReused, cntCond, cntCondBytes));

	mov	eax, DWORD PTR cntCondBytes
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR cntCond
	mov	r8d, DWORD PTR cntReused
	mov	edx, DWORD PTR cntAlloc
	lea	rcx, OFFSET FLAT:$SG11821
	call	DoDebugMsg

; 1719 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
HllCheckOpen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
pass$ = 16
HllInit	PROC

; 1741 : {

$LN4:
	mov	DWORD PTR [rsp+8], ecx
	push	rdi

; 1742 :   //if ( pass == PASS_1 )
; 1743 :   //    HllFree = NULL;
; 1744 : 
; 1745 :   //HllStack = NULL; /* empty stack of open hll directives */
; 1746 :   ModuleInfo.hll_label = 0; /* init hll label counter */

	mov	DWORD PTR ModuleInfo+352, 0

; 1747 : #ifdef DEBUG_OUT
; 1748 :   evallvl = 0;

	mov	DWORD PTR evallvl, 0

; 1749 :   if (pass == PASS_1) {

	cmp	DWORD PTR pass$[rsp], 0
	jne	SHORT $LN2@HllInit

; 1750 :     cntAlloc = 0;

	mov	DWORD PTR cntAlloc, 0

; 1751 :     cntReused = 0;

	mov	DWORD PTR cntReused, 0

; 1752 :     cntCond = 0;

	mov	DWORD PTR cntCond, 0

; 1753 :     cntCondBytes = 0;

	mov	DWORD PTR cntCondBytes, 0
$LN2@HllInit:

; 1754 :   }
; 1755 : #endif
; 1756 :   return;
; 1757 : }

	pop	rdi
	ret	0
HllInit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Buffer$ = 96
_Format$ = 104
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1788 : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:sprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp___stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1391 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
	push	rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	rdi
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
