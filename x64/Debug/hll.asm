; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG11823 DB	01H DUP (?)
	ALIGN	4

$SG11831 DB	01H DUP (?)
	ALIGN	4

$SG11834 DB	02H DUP (?)
	ALIGN	4

$SG11839 DB	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
flaginstr DB	07aH
	DB	063H
	DB	073H
	DB	070H
	DB	06fH
	DB	06cH
	DB	067H
	DB	061H
	DB	065H
	DB	062H
	ORG $+2
unsigned_cjmptype DB 07aH
	DB	07aH
	DB	061H
	DB	062H
	DB	062H
	DB	061H
	ORG $+2
signed_cjmptype DB 07aH
	DB	07aH
	DB	067H
	DB	06cH
	DB	06cH
	DB	067H
	ORG $+2
neg_cjmptype DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
CONST	ENDS
_DATA	SEGMENT
$SG12288 DB	'jmp %s', 00H
	ORG $+1
$SG12289 DB	'%s:', 00H
$SG11281 DB	'or', 00H
	ORG $+1
$SG11266 DB	'jmp @C%04X^', 00H
$SG11268 DB	'hll.c', 00H
	ORG $+2
$SG11282 DB	'cmp', 00H
$SG12294 DB	'pop', 09H, 'edi', 00H
$SG11270 DB	'%u GetSimpleExpression: EvalOperand 2 ok, type=%X, i=%u '
	DB	'[%s]', 0aH, 00H
	ORG $+2
$SG12295 DB	'pop', 09H, 'esi', 00H
$SG12296 DB	'pop', 09H, 'ebx', 00H
$SG11272 DB	'GetSimpleExpression: syntax error, op2.kind=%u', 0aH, 00H
$SG12297 DB	'pop', 09H, 'ecx', 00H
$SG12298 DB	'pop', 09H, 'edx', 00H
$SG12299 DB	'mov  eax,%s[%r*4]', 00H
	ORG $+2
$SG11275 DB	'test', 00H
	ORG $+3
$SG12311 DB	'%s:', 00H
$SG12300 DB	'xchg', 09H, ' eax,[esp]', 00H
$SG12301 DB	'retn', 00H
	ORG $+3
$SG12302 DB	'pop', 09H, 'rdi', 00H
$SG12303 DB	'pop', 09H, 'rsi', 00H
$SG12304 DB	'pop', 09H, 'rbx', 00H
$SG12305 DB	'pop', 09H, 'rcx', 00H
$SG12306 DB	'lea   rdx,%s', 00H
	ORG $+3
$SG12307 DB	'mov   rax, qword ptr[rdx+rax*8]', 00H
$SG11283 DB	'GetSimpleExpression: unexpected operator %s', 0aH, 00H
	ORG $+3
$SG12308 DB	'pop   rdx', 00H
	ORG $+2
$SG12321 DB	'%s:', 00H
$SG12309 DB	'xchg', 09H, ' rax,[rsp]', 00H
$SG12310 DB	'retn', 00H
	ORG $+3
$SG11289 DB	'jmp ', 00H
	ORG $+3
$SG12316 DB	'lea     ebx,[eax-1]', 00H
$SG12354 DB	'%s:', 00H
$SG12319 DB	'lea     ebx,[rax-1]', 00H
$SG11351 DB	'^', 00H
	ORG $+2
$SG12320 DB	'lea     rbx,[rax-1]', 00H
$SG11355 DB	':^', 00H
	ORG $+1
$SG12326 DB	'cmp  ecx,ebx', 00H
	ORG $+3
$SG12327 DB	'jle %s', 00H
	ORG $+1
$SG12328 DB	'pop', 09H, 'edi', 00H
$SG12329 DB	'pop', 09H, 'esi', 00H
$SG12330 DB	'pop', 09H, 'ebx', 00H
$SG12331 DB	'pop', 09H, 'ecx', 00H
$SG12332 DB	'pop', 09H, 'edx', 00H
$SG12333 DB	'pop', 09H, 'eax', 00H
$SG12336 DB	'jmp  %s', 00H
$SG12337 DB	'jmp  %s', 00H
$SG12340 DB	'cmp  ecx,ebx', 00H
	ORG $+3
$SG12341 DB	'cmp  rcx,rbx', 00H
	ORG $+3
$SG12342 DB	'jle  %s', 00H
$SG12343 DB	'pop', 09H, 'rdi', 00H
$SG11319 DB	'%u ReplaceLabel(%s->%s, >%s<)', 0aH, 00H
	ORG $+1
$SG12344 DB	'pop', 09H, 'rsi', 00H
$SG12345 DB	'pop', 09H, 'rbx', 00H
$SG12346 DB	'pop', 09H, 'rcx', 00H
$SG12347 DB	'pop', 09H, 'rdx', 00H
$SG12348 DB	'pop', 09H, 'rax', 00H
$SG12351 DB	'jmp  %s', 00H
$SG12352 DB	'jmp  %s', 00H
$SG12353 DB	'ALIGN %d', 00H
	ORG $+3
$SG12360 DB	' dd %s', 00H
	ORG $+1
$SG12364 DB	' dd %s', 00H
	ORG $+1
$SG12367 DB	' dd %s', 00H
	ORG $+1
$SG12398 DB	'%s:', 00H
$SG11343 DB	'%u GetAndExpression(>%.32s< buf=>%s<) enter', 0aH, 00H
	ORG $+3
$SG11345 DB	'NULL', 00H
	ORG $+3
$SG11346 DB	'%u GetAndExpression: &&-operator found, is_true=%u, last'
	DB	'jmp=%s', 0aH, 00H
$SG12371 DB	' dd %s', 00H
	ORG $+1
$SG12372 DB	' dd %s', 00H
	ORG $+1
$SG12373 DB	' dd %s', 00H
	ORG $+1
$SG12376 DB	' dd %s', 00H
	ORG $+1
$SG11352 DB	'%u GetAndExpression: jmp inverted >%s<', 0aH, 00H
$SG12377 DB	' dd %s', 00H
	ORG $+1
$SG11356 DB	'%u GetAndExpression: label added >%s<', 0aH, 00H
	ORG $+1
$SG12382 DB	' dq %s', 00H
	ORG $+1
$SG12385 DB	' dq %s', 00H
	ORG $+1
$SG12391 DB	' dq %s', 00H
	ORG $+1
$SG12392 DB	' dq %s', 00H
	ORG $+1
$SG12393 DB	' dq %s', 00H
	ORG $+1
$SG12396 DB	' dq %s', 00H
	ORG $+1
$SG12397 DB	' dq %s', 00H
	ORG $+1
$SG12402 DB	' db %d', 00H
	ORG $+1
$SG12403 DB	' db %d', 00H
	ORG $+1
$SG12405 DB	' db %d', 00H
	ORG $+1
$SG11381 DB	'%u GetExpression(>%.32s< buf=>%s<) enter', 0aH, 00H
	ORG $+2
$SG12406 DB	' db %d', 00H
	ORG $+1
$SG11390 DB	'^', 00H
	ORG $+2
$SG11383 DB	'%u GetExpression exit, error', 0aH, 00H
	ORG $+2
$SG11384 DB	'NULL', 00H
	ORG $+3
$SG11385 DB	'%u GetExpression: ||-operator found, is_true=%u, lastjmp'
	DB	'=%s', 0aH, 00H
	ORG $+3
$SG12411 DB	' dw %d', 00H
	ORG $+1
$SG12412 DB	' dw %d', 00H
	ORG $+1
$SG12414 DB	' dw %d', 00H
	ORG $+1
$SG12415 DB	' dw %d', 00H
	ORG $+1
$SG11392 DB	'%u GetExpression: jmp inverted, dest changed >%s<', 0aH, 00H
	ORG $+1
$SG11395 DB	'%s:^', 00H
	ORG $+3
$SG12420 DB	' dd %d', 00H
	ORG $+1
$SG11396 DB	'%s:^', 00H
	ORG $+3
$SG12421 DB	' dq %q', 00H
	ORG $+1
$SG11403 DB	':^', 00H
	ORG $+1
$SG11397 DB	'%u GetExpression: dest changed, label added >%s<', 0aH, 00H
	ORG $+2
$SG12428 DB	'%s:', 00H
$SG11399 DB	'%u GetExpression exit, error', 0aH, 00H
	ORG $+2
$SG12426 DB	'HllEndDir: no .FOR on the hll stack', 0aH, 00H
	ORG $+3
$SG11402 DB	'%u GetExpression: suppressed ReplaceLabel %u -> %u, last'
	DB	'jmp=%s', 0aH, 00H
$SG11404 DB	'%u GetExpression: label added >%s<', 0aH, 00H
$SG12434 DB	'%s:', 00H
$SG11405 DB	'%u GetExpression exit', 0aH, 00H
	ORG $+1
$SG12436 DB	'%s:', 00H
$SG12444 DB	'%s:', 00H
$SG12437 DB	' jmp %s', 00H
$SG11413 DB	'NULL', 00H
	ORG $+3
$SG11414 DB	'QueueTestLines("%s") enter', 0aH, 00H
$SG12449 DB	'%s:', 00H
$SG12439 DB	' jmp %s', 00H
$SG11417 DB	'QueueTestLines exit', 0aH, 00H
	ORG $+3
$SG12442 DB	'HllEndDir: no .WHILE on the hll stack', 0aH, 00H
	ORG $+1
$SG12447 DB	'HllEndDir: no .REPEAT on the hll stack', 0aH, 00H
$SG12455 DB	'loop %s', 00H
$SG12458 DB	'HllEndDir: no .REPEAT on the hll stack', 0aH, 00H
$SG11434 DB	'EvaluateHllExpression enter', 0aH, 00H
	ORG $+3
$SG12460 DB	'%s:', 00H
$SG12466 DB	'%s:', 00H
$SG11437 DB	'EvaluateHllExpression: unexpected tokens >%s<', 0aH, 00H
	ORG $+1
$SG12464 DB	'hll.c', 00H
	ORG $+2
$SG11453 DB	'CheckCXZLines enter, p=>%s<', 0aH, 00H
	ORG $+3
$SG11460 DB	'loope', 00H
	ORG $+2
$SG11464 DB	'loop', 00H
	ORG $+3
reax	DQ	FLAT:$SG11467
	DQ	FLAT:$SG11468
	DQ	FLAT:$SG11469
$SG11467 DB	'ax', 00H
	ORG $+1
$SG11468 DB	'eax', 00H
$SG11469 DB	'rax', 00H
$SG11471 DB	'dx', 00H
	ORG $+1
redx	DQ	FLAT:$SG11471
	DQ	FLAT:$SG11472
	DQ	FLAT:$SG11473
$SG11472 DB	'edx', 00H
$SG11473 DB	'rdx', 00H
recx	DQ	FLAT:$SG11475
	DQ	FLAT:$SG11476
	DQ	FLAT:$SG11477
$SG11475 DB	'cx', 00H
	ORG $+1
$SG11476 DB	'ecx', 00H
$SG11477 DB	'rcx', 00H
$SG11487 DB	', ', 00H
	ORG $+1
$SG12516 DB	'HllExitDir(%s) enter', 0aH, 00H
	ORG $+2
$SG12518 DB	'HllExitDir stack error', 0aH, 00H
$SG12521 DB	'HllExitDir stack error', 0aH, 00H
$SG12525 DB	'jmp %s', 00H
	ORG $+1
$SG12527 DB	'%s:', 00H
$SG12536 DB	'%s:', 00H
$SG12530 DB	'HllExitDir stack error', 0aH, 00H
$SG12534 DB	'jmp %s', 00H
	ORG $+1
$SG12539 DB	'HllExitDir(%s): calling EvalOperand, i=%u', 0aH, 00H
	ORG $+1
$SG12565 DB	'%s:', 00H
$SG12541 DB	'HllExitDir(%s): EvalOperand() failed', 0aH, 00H
	ORG $+2
$SG12545 DB	'HllExitDir stack error', 0aH, 00H
$SG11532 DB	'=!<>&|-+*^%/', 00H
	ORG $+3
$SG12560 DB	'HllExitDir(%s): labels[LTEST]=%X', 0aH, 00H
	ORG $+2
$SG12563 DB	'jmp %s', 00H
	ORG $+1
$SG11540 DB	' inc ', 00H
	ORG $+2
$SG11542 DB	' dec ', 00H
	ORG $+2
$SG12582 DB	'jmp %s', 00H
	ORG $+1
$SG12584 DB	'hll.c', 00H
	ORG $+2
$SG11560 DB	' mov  ', 00H
	ORG $+1
$SG11563 DB	' cdq ', 00H
	ORG $+2
$SG11566 DB	' mov  ', 00H
	ORG $+1
$SG11840 DB	'%s:', 00H
$SG12591 DB	'.if-.repeat-.while', 00H
	ORG $+5
$SG12592 DB	'HllCheckOpen: allocated items:%u, reused items:%u, .whil'
	DB	'e cond-blocks/bytes:%u/%u', 0aH, 00H
	ORG $+1
$SG11570 DB	' idiv ', 00H
	ORG $+1
$SG11571 DB	' imul ', 00H
	ORG $+1
$SG11575 DB	' idiv ', 00H
	ORG $+1
$SG11576 DB	' imul ', 00H
	ORG $+1
$SG11578 DB	' mov  ', 00H
	ORG $+1
$SG11579 DB	' mov  ', 00H
	ORG $+1
$SG11583 DB	' cdq ', 00H
	ORG $+2
$SG11584 DB	' idiv ', 00H
	ORG $+1
$SG11585 DB	' imul ', 00H
	ORG $+1
$SG11588 DB	' mov  ', 00H
	ORG $+1
$SG11589 DB	' mov  ', 00H
	ORG $+1
$SG11595 DB	' cdq ', 00H
	ORG $+2
$SG11596 DB	' idiv ', 00H
	ORG $+1
$SG11597 DB	' imul ', 00H
	ORG $+1
$SG11599 DB	' mov  ', 00H
	ORG $+1
$SG11605 DB	' cdq ', 00H
	ORG $+2
$SG11606 DB	' idiv ', 00H
	ORG $+1
$SG11607 DB	' imul ', 00H
	ORG $+1
$SG11609 DB	' mov  ', 00H
	ORG $+1
$SG11612 DB	' mov  ', 00H
	ORG $+1
$SG11616 DB	' cdq ', 00H
	ORG $+2
$SG11617 DB	' idiv ', 00H
	ORG $+1
$SG11618 DB	' imul ', 00H
	ORG $+1
$SG11620 DB	' mov  ', 00H
	ORG $+1
$SG11623 DB	' sub ', 00H
	ORG $+2
$SG11626 DB	' add ', 00H
	ORG $+2
$SG11629 DB	' and ', 00H
	ORG $+2
$SG11632 DB	' or ', 00H
	ORG $+3
$SG11635 DB	' xor ', 00H
	ORG $+2
$SG11638 DB	' shl ', 00H
	ORG $+2
$SG11640 DB	' shr ', 00H
	ORG $+2
$SG11647 DB	' xor  ', 00H
	ORG $+1
$SG11848 DB	'jmp', 00H
$SG11654 DB	'BYTE PTR', 00H
	ORG $+3
$SG11655 DB	'BPTR', 00H
	ORG $+3
$SG11656 DB	'WPTR', 00H
	ORG $+3
$SG11662 DB	' lea  ', 00H
	ORG $+1
$SG11850 DB	'%s:', 00H
$SG11657 DB	'WORD PTR', 00H
	ORG $+3
$SG11663 DB	' mov  ', 00H
	ORG $+1
$SG11950 DB	'%s:', 00H
$SG11658 DB	' movzx  ', 00H
	ORG $+3
$SG11661 DB	'ADDR', 00H
	ORG $+3
$SG11669 DB	'OFFSET', 00H
	ORG $+1
$SG11670 DB	' lea  ', 00H
	ORG $+1
$SG11671 DB	' mov  ', 00H
	ORG $+1
$SG11960 DB	'%s:', 00H
$SG11678 DB	'DWORD PTR', 00H
	ORG $+2
$SG11679 DB	'DPTR', 00H
	ORG $+3
$SG11682 DB	' mov  ', 00H
	ORG $+1
$SG11962 DB	'%s:', 00H
$SG11681 DB	' movsxd  ', 00H
	ORG $+2
$SG11689 DB	' mov  ', 00H
	ORG $+1
$SG12255 DB	'%s:', 00H
$SG11688 DB	' invoke  ', 00H
	ORG $+2
$SG11692 DB	' mov  ', 00H
	ORG $+1
$SG12261 DB	'cdq', 00H
$SG11695 DB	' mov  byte ptr ', 00H
$SG11696 DB	' mov  ', 00H
	ORG $+1
$SG11760 DB	'HllStartDir(%s) enter', 0aH, 00H
	ORG $+1
$SG11769 DB	'HllStartDir(%s): calling EvalOperand, i=%u', 0aH, 00H
$SG12272 DB	'cdq', 00H
$SG11771 DB	'HllStartDir(%s): EvalOperand() failed', 0aH, 00H
	ORG $+1
$SG11777 DB	' movzx eax, %s', 00H
	ORG $+1
$SG11779 DB	' mov eax, %s', 00H
	ORG $+3
$SG11784 DB	' movzx eax, %s', 00H
	ORG $+1
$SG11787 DB	' mov eax, %s', 00H
	ORG $+3
$SG11789 DB	' mov rax, %s', 00H
	ORG $+3
$SG11796 DB	' movzx eax, %s', 00H
	ORG $+1
$SG11797 DB	' mov eax, %s', 00H
	ORG $+3
$SG11801 DB	' movzx eax, %s', 00H
	ORG $+1
$SG11804 DB	' mov eax, %s', 00H
	ORG $+3
$SG11805 DB	' mov rax, %s', 00H
	ORG $+3
$SG11806 DB	'HllExitDir stack error', 0aH, 00H
$SG11807 DB	'jmp %s', 00H
	ORG $+1
$SG11815 DB	'(::)', 00H
	ORG $+3
$SG11830 DB	' jmp %s', 00H
$SG11833 DB	'.for ', 00H
	ORG $+2
$SG11835 DB	'.for', 00H, 00H
	ORG $+2
$SG11849 DB	'jmp %s', 00H
	ORG $+1
$SG11852 DB	'hll.c', 00H
	ORG $+2
$SG11854 DB	'HllStartDir: unexpected token [%s]', 0aH, 00H
$SG12281 DB	'cdq', 00H
$SG11943 DB	'HllEndDir(%s) enter', 0aH, 00H
	ORG $+3
$SG11945 DB	'HllEndDir: hll stack is empty', 0aH, 00H
	ORG $+1
$SG11948 DB	'HllEndDir: no .IF on the hll stack', 0aH, 00H
$SG11259 DB	'cmp', 00H
$SG11953 DB	'HllExitDir stack error', 0aH, 00H
$SG11958 DB	'jmp %s', 00H
	ORG $+1
$SG11961 DB	'ALIGN %d', 00H
	ORG $+3
$SG11999 DB	'je  %s', 00H
	ORG $+5
$SG11998 DB	'cmp  eax,%d', 00H
	ORG $+4
$SG12002 DB	'jmp  %s', 00H
$SG12003 DB	'jmp  %s', 00H
$SG12004 DB	'push rdx', 00H
	ORG $+7
$SG12005 DB	'mov rdx, %q', 00H
	ORG $+4
$SG12006 DB	'cmp rax, rdx', 00H
	ORG $+3
$SG12007 DB	'pop rdx', 00H
$SG12008 DB	'je  %s', 00H
	ORG $+1
$SG12011 DB	'jmp  %s', 00H
$SG12012 DB	'jmp  %s', 00H
$SG12018 DB	'cmp  eax,%d', 00H
$SG12019 DB	'je  %s', 00H
	ORG $+5
$SG12020 DB	'cmp  eax,%d', 00H
$SG12021 DB	'je  %s', 00H
	ORG $+5
$SG12024 DB	'jmp  %s', 00H
$SG12025 DB	'jmp  %s', 00H
$SG12026 DB	'push rdx', 00H
	ORG $+7
$SG12027 DB	'mov rdx, %q', 00H
	ORG $+4
$SG12028 DB	'cmp rax, rdx', 00H
	ORG $+3
$SG12029 DB	'pop rdx', 00H
$SG12030 DB	'je  %s', 00H
	ORG $+1
$SG12031 DB	'push rdx', 00H
	ORG $+7
$SG12032 DB	'mov rdx, %q', 00H
	ORG $+4
$SG12033 DB	'cmp rax, rdx', 00H
	ORG $+3
$SG12034 DB	'pop rdx', 00H
$SG12035 DB	'je  %s', 00H
	ORG $+1
$SG12038 DB	'jmp  %s', 00H
$SG12039 DB	'jmp  %s', 00H
$SG12045 DB	'cmp  eax,%d', 00H
$SG12046 DB	'je  %s', 00H
	ORG $+5
$SG12047 DB	'cmp  eax,%d', 00H
$SG12048 DB	'je  %s', 00H
	ORG $+5
$SG12049 DB	'cmp  eax,%d', 00H
$SG12050 DB	'je  %s', 00H
	ORG $+5
$SG12053 DB	'jmp  %s', 00H
$SG12054 DB	'jmp  %s', 00H
$SG12055 DB	'push rdx', 00H
	ORG $+7
$SG12056 DB	'mov rdx, %q', 00H
	ORG $+4
$SG12057 DB	'cmp rax, rdx', 00H
	ORG $+3
$SG12058 DB	'pop rdx', 00H
$SG12059 DB	'je  %s', 00H
	ORG $+1
$SG12060 DB	'push rdx', 00H
	ORG $+7
$SG12061 DB	'mov rdx, %q', 00H
$SG11037 DB	'ZERO', 00H
	ORG $+7
$SG12062 DB	'cmp rax, rdx', 00H
	ORG $+3
$SG12063 DB	'pop rdx', 00H
$SG12064 DB	'je  %s', 00H
	ORG $+1
$SG11040 DB	'CARRY', 00H
	ORG $+2
$SG12065 DB	'push rdx', 00H
	ORG $+7
$SG12066 DB	'mov rdx, %q', 00H
	ORG $+4
$SG12067 DB	'cmp rax, rdx', 00H
	ORG $+3
$SG11043 DB	'SIGN', 00H
	ORG $+3
$SG12068 DB	'pop rdx', 00H
$SG12069 DB	'je  %s', 00H
	ORG $+1
$SG11046 DB	'PARITY', 00H
	ORG $+1
$SG12072 DB	'jmp  %s', 00H
$SG12073 DB	'jmp  %s', 00H
$SG11049 DB	'OVERFLOW', 00H
	ORG $+3
$SG11052 DB	'LESS', 00H
	ORG $+7
$SG11055 DB	'GREATER', 00H
$SG12080 DB	'cmp eax,%d', 00H
	ORG $+1
$SG12081 DB	'jl  %s', 00H
	ORG $+5
$SG12082 DB	'cmp eax,%d', 00H
	ORG $+1
$SG11058 DB	'ABOVE', 00H
	ORG $+2
$SG12083 DB	'ja  %s', 00H
	ORG $+5
$SG12084 DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG12085 DB	'push', 09H, 'rdx', 00H
	ORG $+3
$SG11061 DB	'EQUAL', 00H
	ORG $+6
$SG12086 DB	'mov rdx, %q', 00H
	ORG $+4
$SG12087 DB	'cmp rax, rdx', 00H
	ORG $+3
$SG12088 DB	'pop', 09H, 'rdx', 00H
$SG11064 DB	'BELOW', 00H
	ORG $+2
$SG12089 DB	'pop', 09H, 'rax', 00H
$SG12090 DB	'jl  %s', 00H
	ORG $+1
$SG12091 DB	'mov rdx, %q', 00H
	ORG $+4
$SG12092 DB	'cmp rax, rdx', 00H
	ORG $+3
$SG12093 DB	'pop', 09H, 'rdx', 00H
$SG12094 DB	'pop', 09H, 'rax', 00H
$SG12095 DB	'ja  %s', 00H
	ORG $+1
$SG12098 DB	'push', 09H, ' eax', 00H
	ORG $+6
$SG12099 DB	'movzx eax,byte ptr %s[%r - %d]', 00H
	ORG $+1
$SG12100 DB	'mov   eax,%s[%r*4]', 00H
	ORG $+5
$SG12101 DB	'xchg', 09H, ' eax,[esp]', 00H
$SG12102 DB	'retn', 00H
	ORG $+3
$SG12105 DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG12106 DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG12107 DB	'lea   rdx,%s', 00H
	ORG $+3
$SG12108 DB	'movzx edx,byte ptr[rdx+rax-%u]', 00H
	ORG $+1
$SG12109 DB	'lea   rax,%s', 00H
	ORG $+3
$SG12110 DB	'mov   rax, qword ptr[rax+rdx*8]', 00H
$SG12111 DB	'pop   rdx', 00H
	ORG $+6
$SG12112 DB	'xchg', 09H, ' rax,[rsp]', 00H
$SG12113 DB	'retn', 00H
	ORG $+3
$SG12114 DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG12115 DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG12116 DB	'lea   rdx,%s', 00H
	ORG $+3
$SG12117 DB	'movzx rdx,byte ptr[rdx+rax-%q]', 00H
	ORG $+1
$SG12118 DB	'lea   rax,%s', 00H
	ORG $+3
$SG12119 DB	'mov   rax, qword ptr[rax+rdx*8]', 00H
$SG12120 DB	'pop   rdx', 00H
	ORG $+6
$SG12121 DB	'xchg', 09H, ' rax,[rsp]', 00H
$SG12122 DB	'retn', 00H
	ORG $+3
$SG12129 DB	'cmp eax,%d', 00H
	ORG $+1
$SG12130 DB	'jl  %s', 00H
	ORG $+5
$SG12131 DB	'cmp eax,%d', 00H
	ORG $+1
$SG12132 DB	'ja  %s', 00H
	ORG $+5
$SG12133 DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG12134 DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG12135 DB	'mov rdx, %q', 00H
	ORG $+4
$SG12136 DB	'cmp rax, rdx', 00H
	ORG $+3
$SG12137 DB	'pop', 09H, 'rdx', 00H
$SG12138 DB	'pop', 09H, 'rax', 00H
$SG12139 DB	'jl  %s', 00H
	ORG $+1
$SG12140 DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG12141 DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG12142 DB	'mov rdx, %q', 00H
	ORG $+4
$SG12143 DB	'cmp rax, rdx', 00H
	ORG $+3
$SG12144 DB	'pop', 09H, 'rdx', 00H
$SG12145 DB	'pop', 09H, 'rax', 00H
$SG12146 DB	'ja  %s', 00H
	ORG $+1
$SG12149 DB	'push', 09H, ' eax', 00H
	ORG $+6
$SG12150 DB	'sub   eax,%u', 00H
	ORG $+3
$SG12151 DB	'movzx eax,word ptr %s[%r*2]', 00H
	ORG $+4
$SG12152 DB	'mov   eax,%s[%r*4]', 00H
	ORG $+5
$SG12153 DB	'xchg', 09H, ' eax,[esp]', 00H
$SG12154 DB	'retn', 00H
	ORG $+3
$SG12155 DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG12156 DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG12159 DB	'lea   rdx,%s', 00H
	ORG $+3
$SG12160 DB	'sub   eax,%u', 00H
	ORG $+3
$SG12161 DB	'movzx rdx,word ptr[rdx+rax*2]', 00H
	ORG $+2
$SG12162 DB	'lea   rax,%s', 00H
	ORG $+3
$SG12163 DB	'mov   rax, qword ptr[rax+rdx*8]', 00H
$SG12164 DB	'pop   rdx', 00H
	ORG $+6
$SG12165 DB	'xchg', 09H, ' rax,[rsp]', 00H
$SG11141 DB	', %d', 00H
	ORG $+3
$SG12166 DB	'retn', 00H
	ORG $+3
$SG11142 DB	'%u RenderInstr(%s)=>%s<', 0aH, 00H
	ORG $+7
$SG12167 DB	'lea   rdx,%s', 00H
	ORG $+3
$SG12168 DB	'sub   rax,%u', 00H
	ORG $+3
$SG12169 DB	'movzx rdx,word ptr[rdx+rax*2]', 00H
	ORG $+2
$SG12170 DB	'lea   rax,%s', 00H
	ORG $+3
$SG12171 DB	'mov   rax, qword ptr[rax+rdx*8]', 00H
$SG12172 DB	'pop   rdx', 00H
	ORG $+6
$SG12173 DB	'xchg', 09H, ' rax,[rsp]', 00H
$SG11149 DB	'@C%04X', 00H
	ORG $+1
$SG12174 DB	'retn', 00H
	ORG $+3
$SG12181 DB	'cmp eax,%d', 00H
	ORG $+1
$SG12182 DB	'jl  %s', 00H
	ORG $+5
$SG12183 DB	'cmp eax,%d', 00H
	ORG $+1
$SG12184 DB	'ja  %s', 00H
	ORG $+5
$SG12185 DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG12186 DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG12187 DB	'mov rdx, %q', 00H
	ORG $+4
$SG11163 DB	'%u RenderJcc()=>%s<', 0aH, 00H
	ORG $+3
$SG12188 DB	'cmp rax, rdx', 00H
	ORG $+3
$SG12189 DB	'pop', 09H, 'rdx', 00H
$SG12190 DB	'pop', 09H, 'rax', 00H
$SG12191 DB	'jl  %s', 00H
	ORG $+1
$SG12192 DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG12193 DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG12194 DB	'mov rdx, %q', 00H
	ORG $+4
$SG12195 DB	'cmp rax, rdx', 00H
	ORG $+3
$SG12196 DB	'pop', 09H, 'rdx', 00H
$SG12197 DB	'pop', 09H, 'rax', 00H
$SG12198 DB	'ja  %s', 00H
	ORG $+1
$SG12201 DB	'push', 09H, ' eax', 00H
	ORG $+6
$SG12202 DB	'sub eax,%d', 00H
	ORG $+5
$SG12203 DB	'mov   eax,%s[%r*4]', 00H
	ORG $+5
$SG12204 DB	'xchg', 09H, ' eax,[esp]', 00H
$SG12205 DB	'retn', 00H
	ORG $+3
$SG12206 DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG12207 DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG12210 DB	'sub   eax,%d', 00H
	ORG $+3
$SG12211 DB	'mov rdx,%q', 00H
	ORG $+5
$SG12212 DB	'sub rax,rdx', 00H
	ORG $+4
$SG12213 DB	'lea   rdx,%s', 00H
	ORG $+3
$SG11189 DB	'hll.c', 00H
	ORG $+2
$SG12214 DB	'mov   rax, qword ptr[rdx+rax*8]', 00H
$SG12215 DB	'pop   rdx', 00H
	ORG $+6
$SG12216 DB	'xchg', 09H, ' rax,[rsp]', 00H
$SG12217 DB	'retn', 00H
	ORG $+3
$SG12221 DB	'push', 09H, 'eax', 00H
	ORG $+7
$SG12222 DB	'push', 09H, 'edx', 00H
	ORG $+7
$SG12223 DB	'push', 09H, 'ecx', 00H
	ORG $+7
$SG12224 DB	'push', 09H, 'ebx', 00H
	ORG $+7
$SG12225 DB	'push', 09H, 'esi', 00H
	ORG $+7
$SG12226 DB	'push', 09H, 'edi', 00H
	ORG $+7
$SG12227 DB	'mov  esi,eax', 00H
	ORG $+3
$SG12228 DB	'mov  ebx,%d', 00H
	ORG $+4
$SG12229 DB	'xor  ecx,ecx', 00H
	ORG $+3
$SG12230 DB	'lea  edi,%s', 00H
$SG12233 DB	'js  %s', 00H
	ORG $+1
$SG12234 DB	'js  %s', 00H
	ORG $+5
$SG12235 DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG12236 DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG12237 DB	'push', 09H, 'rcx', 00H
	ORG $+7
$SG12238 DB	'push', 09H, 'rbx', 00H
	ORG $+7
$SG12239 DB	'push', 09H, 'rsi', 00H
	ORG $+7
$SG12240 DB	'push', 09H, 'rdi', 00H
	ORG $+7
$SG12243 DB	'mov  esi,eax', 00H
	ORG $+3
$SG12244 DB	'mov  ebx,%d', 00H
	ORG $+4
$SG12245 DB	'xor  ecx,ecx', 00H
	ORG $+3
$SG12246 DB	'lea  rdi,%s', 00H
	ORG $+4
$SG12247 DB	'mov  rsi,rax', 00H
	ORG $+3
$SG12248 DB	'mov  rbx,%q', 00H
	ORG $+4
$SG12249 DB	'xor  ecx,ecx', 00H
	ORG $+3
$SG12250 DB	'lea  rdi,%s', 00H
	ORG $+4
$SG11228 DB	'%u GetSimpleExpression(>%.32s< buf=>%s<) enter', 0aH, 00H
$SG12253 DB	'js  %s', 00H
	ORG $+1
$SG12254 DB	'js  %s', 00H
	ORG $+1
$SG12260 DB	'lea     eax,[ecx + ebx]', 00H
$SG11237 DB	'%u GetSimpleExpression: calling GetExpression, i=%u', 0aH
	DB	00H
	ORG $+3
$SG12262 DB	'sub     eax,edx', 00H
$SG12263 DB	'sar     eax,1', 00H
	ORG $+2
$SG12264 DB	'cmp     [edi+eax*4],esi', 00H
$SG11240 DB	'GetSimpleExpression: expected '')'', found: %s', 0aH, 00H
	ORG $+2
$SG12265 DB	'je  %s', 00H
	ORG $+1
$SG12266 DB	'jge %s', 00H
	ORG $+1
$SG12267 DB	'lea     ecx,[eax+1]', 00H
$SG12268 DB	'jmp %s', 00H
	ORG $+5
$SG11246 DB	'%u GetSimpleExpression: EvalOperand ok, kind=%X, i=%u [%'
	DB	's]', 0aH, 00H
	ORG $+4
$SG12271 DB	'lea     eax,[rcx + rbx]', 00H
$SG12273 DB	'sub     eax,edx', 00H
$SG11249 DB	'GetSimpleExpression: non-empty expression rejected: %s', 0aH
	DB	00H
$SG12274 DB	'sar     rax,1', 00H
	ORG $+2
$SG12275 DB	'cmp     [rdi+rax*8],esi', 00H
$SG11251 DB	'GetSimpleExpression: empty expression rejected', 0aH, 00H
$SG12276 DB	'je  %s', 00H
	ORG $+1
$SG12277 DB	'jge %s', 00H
	ORG $+1
$SG11253 DB	'GetSimpleExpression: float expression rejected: %s', 0aH
	DB	00H
	ORG $+4
$SG12278 DB	'lea     ecx,[rax+1]', 00H
$SG12279 DB	'jmp %s', 00H
	ORG $+5
$SG12280 DB	'lea     rax,[rcx + rbx]', 00H
$SG11257 DB	'test', 00H
	ORG $+3
$SG12282 DB	'sub     rax,rdx', 00H
$SG12283 DB	'sar     rax,1', 00H
	ORG $+2
$SG12284 DB	'cmp     [rdi+rax*8],rsi', 00H
$SG12285 DB	'je  %s', 00H
	ORG $+1
$SG12286 DB	'jge %s', 00H
	ORG $+1
$SG12287 DB	'lea     rcx,[rax+1]', 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	HllInit
PUBLIC	HllCheckOpen
PUBLIC	hex2dec
PUBLIC	HllStartDir
PUBLIC	HllEndDir
PUBLIC	HllExitDir
EXTRN	__report_rangecheckfailure:PROC
EXTRN	tolower:PROC
EXTRN	memcpy:PROC
EXTRN	strchr:PROC
EXTRN	strstr:PROC
EXTRN	_memicmp:PROC
EXTRN	strcat:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	_stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	LclAlloc:PROC
EXTRN	EvalOperand:PROC
EXTRN	EmitConstError:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	LstWrite:PROC
EXTRN	AddLineQueue:PROC
EXTRN	AddLineQueueX:PROC
EXTRN	RunLineQueue:PROC
EXTRN	InternalError:PROC
EXTRN	Tokenize:PROC
EXTRN	atofloat:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

evallvl	DD	01H DUP (?)
cntAlloc DD	01H DUP (?)
cntReused DD	01H DUP (?)
cntCond	DD	01H DUP (?)
cntCondBytes DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$HllCheckOpen DD imagerel $LN4
	DD	imagerel $LN4+78
	DD	imagerel $unwind$HllCheckOpen
$pdata$GetExpression DD imagerel GetExpression
	DD	imagerel GetExpression+1347
	DD	imagerel $unwind$GetExpression
$pdata$GetCOp DD imagerel GetCOp
	DD	imagerel GetCOp+871
	DD	imagerel $unwind$GetCOp
$pdata$hex2dec DD imagerel $LN10
	DD	imagerel $LN10+139
	DD	imagerel $unwind$hex2dec
$pdata$bubblesort DD imagerel bubblesort
	DD	imagerel bubblesort+339
	DD	imagerel $unwind$bubblesort
$pdata$bubblesort64 DD imagerel bubblesort64
	DD	imagerel bubblesort64+372
	DD	imagerel $unwind$bubblesort64
$pdata$RenderInstr DD imagerel RenderInstr
	DD	imagerel RenderInstr+488
	DD	imagerel $unwind$RenderInstr
$pdata$GetLabelStr DD imagerel GetLabelStr
	DD	imagerel GetLabelStr+45
	DD	imagerel $unwind$GetLabelStr
$pdata$RenderJcc DD imagerel RenderJcc
	DD	imagerel RenderJcc+258
	DD	imagerel $unwind$RenderJcc
$pdata$GetToken DD imagerel GetToken
	DD	imagerel GetToken+198
	DD	imagerel $unwind$GetToken
$pdata$GetLabel DD imagerel GetLabel
	DD	imagerel GetLabel+80
	DD	imagerel $unwind$GetLabel
$pdata$GetSimpleExpression DD imagerel GetSimpleExpression
	DD	imagerel GetSimpleExpression+2543
	DD	imagerel $unwind$GetSimpleExpression
$pdata$InvertJump DD imagerel InvertJump
	DD	imagerel InvertJump+435
	DD	imagerel $unwind$InvertJump
$pdata$ReplaceLabel DD imagerel ReplaceLabel
	DD	imagerel ReplaceLabel+208
	DD	imagerel $unwind$ReplaceLabel
$pdata$GetAndExpression DD imagerel GetAndExpression
	DD	imagerel GetAndExpression+777
	DD	imagerel $unwind$GetAndExpression
$pdata$QueueTestLines DD imagerel QueueTestLines
	DD	imagerel QueueTestLines+168
	DD	imagerel $unwind$QueueTestLines
$pdata$EvaluateHllExpression DD imagerel EvaluateHllExpression
	DD	imagerel EvaluateHllExpression+214
	DD	imagerel $unwind$EvaluateHllExpression
$pdata$CheckCXZLines DD imagerel CheckCXZLines
	DD	imagerel CheckCXZLines+413
	DD	imagerel $unwind$CheckCXZLines
$pdata$WriteAsmLine DD imagerel WriteAsmLine
	DD	imagerel WriteAsmLine+145
	DD	imagerel $unwind$WriteAsmLine
$pdata$ForInitAndNext DD imagerel ForInitAndNext
	DD	imagerel ForInitAndNext+5482
	DD	imagerel $unwind$ForInitAndNext
$pdata$HllStartDir DD imagerel $LN106
	DD	imagerel $LN106+4682
	DD	imagerel $unwind$HllStartDir
$pdata$HllEndDir DD imagerel $LN264
	DD	imagerel $LN264+12724
	DD	imagerel $unwind$HllEndDir
$pdata$HllExitDir DD imagerel $LN82
	DD	imagerel $LN82+3432
	DD	imagerel $unwind$HllExitDir
pdata	ENDS
xdata	SEGMENT
$unwind$HllCheckOpen DD 010401H
	DD	06204H
$unwind$GetExpression DD 022d19H
	DD	015011bH
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$GetCOp DD 010901H
	DD	08209H
$unwind$hex2dec DD 010901H
	DD	02209H
$unwind$bubblesort DD 011801H
	DD	02218H
$unwind$bubblesort64 DD 011801H
	DD	04218H
$unwind$RenderInstr DD 011801H
	DD	06218H
$unwind$GetLabelStr DD 010d01H
	DD	0420dH
$unwind$RenderJcc DD 011701H
	DD	06217H
$unwind$GetToken DD 011801H
	DD	08218H
$unwind$GetLabel DD 010d01H
	DD	0620dH
$unwind$GetSimpleExpression DD 021b01H
	DD	02f011bH
$unwind$InvertJump DD 010901H
	DD	04209H
$unwind$ReplaceLabel DD 012119H
	DD	0c212H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$GetAndExpression DD 011801H
	DD	0c218H
$unwind$QueueTestLines DD 010901H
	DD	06209H
$unwind$EvaluateHllExpression DD 011801H
	DD	0a218H
$unwind$CheckCXZLines DD 010901H
	DD	08209H
$unwind$WriteAsmLine DD 022819H
	DD	0270116H
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$ForInitAndNext DD 022719H
	DD	0730115H
	DD	imagerel __GSHandlerCheck
	DD	0380H
$unwind$HllStartDir DD 022819H
	DD	03ad0116H
	DD	imagerel __GSHandlerCheck
	DD	01d50H
$unwind$HllEndDir DD 022219H
	DD	01110110H
	DD	imagerel __GSHandlerCheck
	DD	0870H
$unwind$HllExitDir DD 022219H
	DD	0a30110H
	DD	imagerel __GSHandlerCheck
	DD	0500H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
hll$ = 48
j$ = 56
rc$ = 60
tv78 = 64
idx$ = 68
cmd$ = 72
tv255 = 76
tv519 = 80
tv534 = 84
newlp$ = 88
tv244 = 96
savedcmd$1 = 100
newcp$ = 104
newcp64$ = 112
p$ = 120
opndx$ = 128
buff$ = 240
buffer$ = 256
__$ArrayPad$ = 1280
i$ = 1312
tokenarray$ = 1320
HllExitDir PROC

; 2489 : {

$LN82:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 1304				; 00000518H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2490 :   struct expr         opndx;
; 2491 :   struct hll_item     *hll;
; 2492 :   ret_code            rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 2493 :   int                 j;
; 2494 :   int                 idx;
; 2495 :   int                 cmd = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR cmd$[rsp], eax

; 2496 :   int                 *newcp;
; 2497 :   uint_16             *newlp;
; 2498 :   char buff[16];
; 2499 :   char                *p;
; 2500 :   char buffer[MAX_LINE_LEN];
; 2501 : #if AMD64_SUPPORT
; 2502 :   int_64              *newcp64;
; 2503 : #endif
; 2504 : 
; 2505 : 
; 2506 :   DebugMsg1(("HllExitDir(%s) enter\n", tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG12516
	call	DoDebugMsg1

; 2507 : 
; 2508 :   hll = HllStack;

	mov	rax, QWORD PTR ModuleInfo+224
	mov	QWORD PTR hll$[rsp], rax

; 2509 : 
; 2510 :   if (hll == NULL) {

	cmp	QWORD PTR hll$[rsp], 0
	jne	SHORT $LN18@HllExitDir

; 2511 :     DebugMsg(("HllExitDir stack error\n"));

	lea	rcx, OFFSET FLAT:$SG12518
	call	DoDebugMsg

; 2512 :     return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError
	jmp	$LN1@HllExitDir
$LN18@HllExitDir:

; 2513 :   }
; 2514 :   switch (cmd) {

	mov	eax, DWORD PTR cmd$[rsp]
	mov	DWORD PTR tv78[rsp], eax
	mov	eax, DWORD PTR tv78[rsp]
	sub	eax, 332				; 0000014cH
	mov	DWORD PTR tv78[rsp], eax
	cmp	DWORD PTR tv78[rsp], 11
	ja	$LN70@HllExitDir
	movsxd	rax, DWORD PTR tv78[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN81@HllExitDir[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN19@HllExitDir:

; 2515 :   case T_DOT_DEFAULT:
; 2516 :     if (hll->flags & HLLF_DEFAULTOCCURED) {

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN20@HllExitDir

; 2517 :       DebugMsg(("HllExitDir stack error\n"));

	lea	rcx, OFFSET FLAT:$SG12521
	call	DoDebugMsg

; 2518 :       return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError
	jmp	$LN1@HllExitDir
$LN20@HllExitDir:

; 2519 :     }
; 2520 :     if (ModuleInfo.switch_style == ASMSWITCH) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 19
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN21@HllExitDir

; 2521 :       if (hll->casecnt) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+80], 0
	je	SHORT $LN22@HllExitDir

; 2522 :         if (hll->labels[LEXIT] == 0)

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	jne	SHORT $LN23@HllExitDir

; 2523 :           hll->labels[LEXIT] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax
$LN23@HllExitDir:

; 2524 :         AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12525
	call	AddLineQueueX

; 2525 :         hll->breakoccured = TRUE;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+122], 1
$LN22@HllExitDir:
$LN21@HllExitDir:

; 2526 :       }
; 2527 :     }
; 2528 :     if (hll->labels[LDEF] == 0)

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	jne	SHORT $LN24@HllExitDir

; 2529 :       hll->labels[LDEF] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax
$LN24@HllExitDir:

; 2530 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LDEF], buff));

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12527
	call	AddLineQueueX

; 2531 :     hll->flags |= HLLF_DEFAULTOCCURED;

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	or	eax, 2
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+76], eax

; 2532 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 2533 :     break;

	jmp	$LN2@HllExitDir
$LN25@HllExitDir:

; 2534 :   case T_DOT_CASE:
; 2535 :     if (hll->cmd != HLL_SWITCH) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+68], 5
	je	SHORT $LN26@HllExitDir

; 2536 :       DebugMsg(("HllExitDir stack error\n"));

	lea	rcx, OFFSET FLAT:$SG12530
	call	DoDebugMsg

; 2537 :       return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError
	jmp	$LN1@HllExitDir
$LN26@HllExitDir:

; 2538 :     }
; 2539 :     if (ModuleInfo.switch_style == ASMSWITCH) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 19
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN27@HllExitDir

; 2540 :       if (hll->casecnt) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+80], 0
	je	SHORT $LN28@HllExitDir

; 2541 :         if (hll->labels[LEXIT] == 0)

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	jne	SHORT $LN29@HllExitDir

; 2542 :           hll->labels[LEXIT] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax
$LN29@HllExitDir:

; 2543 :         AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12534
	call	AddLineQueueX

; 2544 :         hll->breakoccured = TRUE;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+122], 1
$LN28@HllExitDir:
$LN27@HllExitDir:
$LN4@HllExitDir:

; 2545 :       }
; 2546 :     }
; 2547 :     for (;;) {
; 2548 :       if (hll->breakoccured) {

	mov	rax, QWORD PTR hll$[rsp]
	movzx	eax, BYTE PTR [rax+122]
	test	eax, eax
	je	SHORT $LN30@HllExitDir

; 2549 :         hll->labels[LTEST] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 2550 :         hll->breakoccured = FALSE;  // if .break did not occure label will not be increased

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+122], 0

; 2551 :         AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	mov	eax, 4
	imul	rax, rax, 0
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12536
	call	AddLineQueueX

; 2552 :         hll->savedlab = hex2dec(buff + 2);

	lea	rax, QWORD PTR buff$[rsp+2]
	mov	rcx, rax
	call	hex2dec
	mov	rcx, QWORD PTR hll$[rsp]
	mov	WORD PTR [rcx+120], ax
$LN30@HllExitDir:

; 2553 :       }
; 2554 :       i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 2555 :       if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN31@HllExitDir

; 2556 :         strcpy(buffer, tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	strcpy

; 2557 :         DebugMsg1(("HllExitDir(%s): calling EvalOperand, i=%u\n", tokenarray[i].string_ptr, i));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r8d, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG12539
	call	DoDebugMsg1

; 2558 :         if (EvalOperand(&i, tokenarray, Token_Count, &opndx, 0) == ERROR) {

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN33@HllExitDir

; 2559 :           DebugMsg(("HllExitDir(%s): EvalOperand() failed\n", tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG12541
	call	DoDebugMsg

; 2560 :           return(ERROR);

	mov	eax, -1
	jmp	$LN1@HllExitDir
$LN33@HllExitDir:

; 2561 :         }
; 2562 :         p = tokenarray[i].tokpos;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR p$[rsp], rax

; 2563 :         switch (opndx.kind) {

	mov	eax, DWORD PTR opndx$[rsp+60]
	mov	DWORD PTR tv244[rsp], eax
	cmp	DWORD PTR tv244[rsp], 3
	je	SHORT $LN35@HllExitDir
	jmp	SHORT $LN7@HllExitDir

; 2564 :         case EXPR_CONST:
; 2565 :           break;

	jmp	SHORT $LN7@HllExitDir
$LN35@HllExitDir:

; 2566 :         case EXPR_FLOAT:
; 2567 : #if FPIMMEDIATE
; 2568 :           if (Options.strict_masm_compat == FALSE) {

	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	jne	SHORT $LN36@HllExitDir

; 2569 :             /* convert to REAL4, unless REAL8 coercion is requested */
; 2570 :             atofloat(&opndx.fvalue, opndx.float_tok->string_ptr, opndx.mem_type == MT_REAL8 ? 8 : 4, opndx.negative, opndx.float_tok->floattype);

	cmp	DWORD PTR opndx$[rsp+64], 39		; 00000027H
	jne	SHORT $LN75@HllExitDir
	mov	DWORD PTR tv255[rsp], 8
	jmp	SHORT $LN76@HllExitDir
$LN75@HllExitDir:
	mov	DWORD PTR tv255[rsp], 4
$LN76@HllExitDir:
	mov	rax, QWORD PTR opndx$[rsp+16]
	movsx	eax, BYTE PTR [rax+1]
	mov	ecx, DWORD PTR opndx$[rsp+72]
	shr	ecx, 5
	and	ecx, 1
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, DWORD PTR tv255[rsp]
	mov	rax, QWORD PTR opndx$[rsp+16]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, QWORD PTR opndx$[rsp]
	call	atofloat
$LN36@HllExitDir:
$LN7@HllExitDir:

; 2571 :             break;
; 2572 :           }
; 2573 : #endif
; 2574 :         }
; 2575 :       }

	jmp	SHORT $LN32@HllExitDir
$LN31@HllExitDir:

; 2576 :       else {
; 2577 :         DebugMsg(("HllExitDir stack error\n"));

	lea	rcx, OFFSET FLAT:$SG12545
	call	DoDebugMsg

; 2578 :         return(EmitError(MISSING_OPERATOR_IN_EXPRESSION));

	mov	ecx, 150				; 00000096H
	call	EmitError
	jmp	$LN1@HllExitDir
$LN32@HllExitDir:

; 2579 :       }
; 2580 :       if (hll->csize == 4) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	$LN37@HllExitDir

; 2581 :         if (!hll->maxalloccasen) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+100], 0
	jne	SHORT $LN39@HllExitDir

; 2582 :           hll->pcases = LclAlloc(hll->csize * 50);

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	imul	eax, eax, 50				; 00000032H
	cdqe
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR hll$[rsp]
	mov	QWORD PTR [rcx+104], rax

; 2583 :           hll->plabels = LclAlloc(sizeof(uint_16) * 50);

	mov	ecx, 100				; 00000064H
	call	LclAlloc
	mov	rcx, QWORD PTR hll$[rsp]
	mov	QWORD PTR [rcx+112], rax

; 2584 :           hll->maxalloccasen = 50;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+100], 50			; 00000032H
$LN39@HllExitDir:

; 2585 :         }
; 2586 :         if (hll->casecnt >= hll->maxalloccasen) {

	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+100]
	cmp	DWORD PTR [rax+80], ecx
	jb	$LN40@HllExitDir

; 2587 :           hll->maxalloccasen += 50;

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+100]
	add	eax, 50					; 00000032H
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+100], eax

; 2588 :           newcp = LclAlloc(hll->csize * hll->maxalloccasen);

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	mov	rcx, QWORD PTR hll$[rsp]
	imul	eax, DWORD PTR [rcx+100]
	cdqe
	mov	rcx, rax
	call	LclAlloc
	mov	QWORD PTR newcp$[rsp], rax

; 2589 :           memcpy(newcp, hll->pcases, hll->casecnt * hll->csize);

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+80]
	imul	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	r8d, eax
	mov	rax, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR newcp$[rsp]
	call	memcpy

; 2590 :           LclFree(hll->pcases);
; 2591 :           hll->pcases = newcp;

	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR newcp$[rsp]
	mov	QWORD PTR [rax+104], rcx

; 2592 : 
; 2593 :           newlp = LclAlloc(sizeof(uint_16) * hll->maxalloccasen);

	mov	rax, QWORD PTR hll$[rsp]
	movsxd	rax, DWORD PTR [rax+100]
	shl	rax, 1
	mov	rcx, rax
	call	LclAlloc
	mov	QWORD PTR newlp$[rsp], rax

; 2594 :           memcpy(newlp, hll->plabels, hll->casecnt * sizeof(uint_16));

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	shl	rax, 1
	mov	r8, rax
	mov	rax, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rax+112]
	mov	rcx, QWORD PTR newlp$[rsp]
	call	memcpy

; 2595 :           LclFree(hll->plabels);
; 2596 :           hll->plabels = newlp;

	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR newlp$[rsp]
	mov	QWORD PTR [rax+112], rcx
$LN40@HllExitDir:

; 2597 :         }
; 2598 :       }

	jmp	$LN38@HllExitDir
$LN37@HllExitDir:

; 2599 : #if AMD64_SUPPORT
; 2600 :       else {
; 2601 :         if (!hll->maxalloccasen) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+100], 0
	jne	SHORT $LN41@HllExitDir

; 2602 :           hll->pcases64 = LclAlloc(hll->csize * 50);

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	imul	eax, eax, 50				; 00000032H
	cdqe
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR hll$[rsp]
	mov	QWORD PTR [rcx+152], rax

; 2603 :           hll->plabels = LclAlloc(sizeof(uint_16) * 50);

	mov	ecx, 100				; 00000064H
	call	LclAlloc
	mov	rcx, QWORD PTR hll$[rsp]
	mov	QWORD PTR [rcx+112], rax

; 2604 :           hll->maxalloccasen = 50;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+100], 50			; 00000032H
$LN41@HllExitDir:

; 2605 :         }
; 2606 :         if (hll->casecnt >= hll->maxalloccasen) {

	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+100]
	cmp	DWORD PTR [rax+80], ecx
	jb	$LN42@HllExitDir

; 2607 :           hll->maxalloccasen += 50;

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+100]
	add	eax, 50					; 00000032H
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+100], eax

; 2608 :           newcp64 = LclAlloc(hll->csize * hll->maxalloccasen);

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	mov	rcx, QWORD PTR hll$[rsp]
	imul	eax, DWORD PTR [rcx+100]
	cdqe
	mov	rcx, rax
	call	LclAlloc
	mov	QWORD PTR newcp64$[rsp], rax

; 2609 :           memcpy(newcp64, hll->pcases64, hll->casecnt * hll->csize);

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+80]
	imul	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	r8d, eax
	mov	rax, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rax+152]
	mov	rcx, QWORD PTR newcp64$[rsp]
	call	memcpy

; 2610 :           LclFree(hll->pcases64);
; 2611 :           hll->pcases64 = newcp64;

	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR newcp64$[rsp]
	mov	QWORD PTR [rax+152], rcx

; 2612 : 
; 2613 :           newlp = LclAlloc(sizeof(uint_16) * hll->maxalloccasen);

	mov	rax, QWORD PTR hll$[rsp]
	movsxd	rax, DWORD PTR [rax+100]
	shl	rax, 1
	mov	rcx, rax
	call	LclAlloc
	mov	QWORD PTR newlp$[rsp], rax

; 2614 :           memcpy(newlp, hll->plabels, hll->casecnt * sizeof(uint_16));

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	shl	rax, 1
	mov	r8, rax
	mov	rax, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rax+112]
	mov	rcx, QWORD PTR newlp$[rsp]
	call	memcpy

; 2615 :           LclFree(hll->plabels);
; 2616 :           hll->plabels = newlp;

	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR newlp$[rsp]
	mov	QWORD PTR [rax+112], rcx
$LN42@HllExitDir:
$LN38@HllExitDir:

; 2617 :         }
; 2618 :       }
; 2619 : #endif
; 2620 :       if ((ModuleInfo.Ofssize == USE32) || (hll->csize == 4)) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	je	SHORT $LN45@HllExitDir
	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	SHORT $LN43@HllExitDir
$LN45@HllExitDir:

; 2621 :         for (j = 0; j < hll->casecnt; j++) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN11@HllExitDir
$LN9@HllExitDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN11@HllExitDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	cmp	DWORD PTR j$[rsp], eax
	jae	SHORT $LN10@HllExitDir

; 2622 :           if (hll->pcases[j] == opndx.value)

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	edx, DWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rcx+rax*4], edx
	jne	SHORT $LN46@HllExitDir

; 2623 :             EmitErr(CASE_ALREADY_OCCURED_IN_THIS_SWITCH_BLOCK, buffer);

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	ecx, 253				; 000000fdH
	call	EmitErr
$LN46@HllExitDir:

; 2624 :         }

	jmp	SHORT $LN9@HllExitDir
$LN10@HllExitDir:

; 2625 :         hll->pcases[hll->casecnt] = opndx.value;

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	edx, DWORD PTR opndx$[rsp]
	mov	DWORD PTR [rcx+rax*4], edx

; 2626 :       }

	jmp	SHORT $LN44@HllExitDir
$LN43@HllExitDir:

; 2627 : #if AMD64_SUPPORT
; 2628 :       else {
; 2629 :         for (j = 0; j < hll->casecnt; j++) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN14@HllExitDir
$LN12@HllExitDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN14@HllExitDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	cmp	DWORD PTR j$[rsp], eax
	jae	SHORT $LN13@HllExitDir

; 2630 :           if (hll->pcases64[j] == opndx.value64)

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+152]
	mov	rdx, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rcx+rax*8], rdx
	jne	SHORT $LN47@HllExitDir

; 2631 :             EmitErr(CASE_ALREADY_OCCURED_IN_THIS_SWITCH_BLOCK, buffer);

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	ecx, 253				; 000000fdH
	call	EmitErr
$LN47@HllExitDir:

; 2632 :         }

	jmp	SHORT $LN12@HllExitDir
$LN13@HllExitDir:

; 2633 :         hll->pcases64[hll->casecnt] = opndx.value64;

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+152]
	mov	rdx, QWORD PTR opndx$[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx
$LN44@HllExitDir:

; 2634 :       }
; 2635 : #endif
; 2636 :       hll->plabels[hll->casecnt] = hll->savedlab;

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	mov	rdx, QWORD PTR hll$[rsp]
	movzx	edx, WORD PTR [rdx+120]
	mov	WORD PTR [rcx+rax*2], dx

; 2637 :       hll->casecnt++;

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	inc	eax
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+80], eax

; 2638 :       if (tokenarray[i].token != T_COMMA)

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN48@HllExitDir

; 2639 :         break;

	jmp	SHORT $LN5@HllExitDir
$LN48@HllExitDir:

; 2640 :     }

	jmp	$LN4@HllExitDir
$LN5@HllExitDir:

; 2641 :     break;

	jmp	$LN2@HllExitDir
$LN49@HllExitDir:

; 2642 :   case T_DOT_ELSE:
; 2643 :   case T_DOT_ELSEIF:
; 2644 :     if (hll->cmd != HLL_IF) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+68], 0
	je	SHORT $LN50@HllExitDir

; 2645 :       DebugMsg(("HllExitDir(%s): labels[LTEST]=%X\n", tokenarray[i].string_ptr, hll->labels[LTEST]));

	mov	eax, 4
	imul	rax, rax, 0
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR hll$[rsp]
	mov	r8d, DWORD PTR [rdx+rax+8]
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	lea	rcx, OFFSET FLAT:$SG12560
	call	DoDebugMsg

; 2646 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 80					; 00000050H
	call	EmitErr
	jmp	$LN1@HllExitDir
$LN50@HllExitDir:

; 2647 :     }
; 2648 :     /* v2.08: check for multiple ELSE clauses */
; 2649 :     if (hll->flags & HLLF_ELSEOCCURED) {

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN51@HllExitDir

; 2650 :       return(EmitError(DOT_ELSE_CLAUSE_ALREADY_OCCURED_IN_THIS_DOT_IF_BLOCK));

	mov	ecx, 67					; 00000043H
	call	EmitError
	jmp	$LN1@HllExitDir
$LN51@HllExitDir:

; 2651 :     }
; 2652 : 
; 2653 :     /* the 'exit'-label is only needed if an .ELSE branch exists.
; 2654 :     * That's why it is created delayed.
; 2655 :     */
; 2656 :     if (hll->labels[LEXIT] == 0)

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	jne	SHORT $LN52@HllExitDir

; 2657 :       hll->labels[LEXIT] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax
$LN52@HllExitDir:

; 2658 :     AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12563
	call	AddLineQueueX

; 2659 : 
; 2660 :     if (hll->labels[LTEST] > 0) {

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	jbe	SHORT $LN53@HllExitDir

; 2661 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	mov	eax, 4
	imul	rax, rax, 0
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12565
	call	AddLineQueueX

; 2662 :       hll->labels[LTEST] = 0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0
$LN53@HllExitDir:

; 2663 :     }
; 2664 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 2665 :     if (cmd == T_DOT_ELSEIF) {

	cmp	DWORD PTR cmd$[rsp], 335		; 0000014fH
	jne	SHORT $LN54@HllExitDir

; 2666 :       /* create new labels[LTEST] label */
; 2667 :       hll->labels[LTEST] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 2668 :       rc = EvaluateHllExpression(hll, &i, tokenarray, LTEST, FALSE, buffer);

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	EvaluateHllExpression
	mov	DWORD PTR rc$[rsp], eax

; 2669 :       if (rc == NOT_ERROR)

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN56@HllExitDir

; 2670 :         QueueTestLines(buffer);

	lea	rcx, QWORD PTR buffer$[rsp]
	call	QueueTestLines
$LN56@HllExitDir:

; 2671 :     }

	jmp	SHORT $LN55@HllExitDir
$LN54@HllExitDir:

; 2672 :     else
; 2673 :       hll->flags |= HLLF_ELSEOCCURED;

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	or	eax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+76], eax
$LN55@HllExitDir:

; 2674 : 
; 2675 :     break;

	jmp	$LN2@HllExitDir
$LN57@HllExitDir:

; 2676 :   case T_DOT_BREAK:
; 2677 :   case T_DOT_CONTINUE:
; 2678 :     for (; hll && hll->cmd == HLL_IF; hll = hll->next);

	jmp	SHORT $LN17@HllExitDir
$LN15@HllExitDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR hll$[rsp], rax
$LN17@HllExitDir:
	cmp	QWORD PTR hll$[rsp], 0
	je	SHORT $LN16@HllExitDir
	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+68], 0
	jne	SHORT $LN16@HllExitDir
	jmp	SHORT $LN15@HllExitDir
$LN16@HllExitDir:

; 2679 :     if (hll == NULL) {

	cmp	QWORD PTR hll$[rsp], 0
	jne	SHORT $LN58@HllExitDir

; 2680 :       return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError
	jmp	$LN1@HllExitDir
$LN58@HllExitDir:

; 2681 :     }
; 2682 :     /* v2.11: create 'exit' and 'test' labels delayed.
; 2683 :     */
; 2684 :     if (cmd == T_DOT_BREAK) {

	cmp	DWORD PTR cmd$[rsp], 332		; 0000014cH
	jne	SHORT $LN59@HllExitDir

; 2685 :       hll->breakoccured = TRUE;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+122], 1

; 2686 :       if (hll->labels[LEXIT] == 0)

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	jne	SHORT $LN61@HllExitDir

; 2687 :         hll->labels[LEXIT] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax
$LN61@HllExitDir:

; 2688 :       idx = LEXIT;

	mov	DWORD PTR idx$[rsp], 1

; 2689 :     }

	jmp	$LN60@HllExitDir
$LN59@HllExitDir:

; 2690 :     else if (hll->cmd == HLL_FOR) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+68], 4
	jne	SHORT $LN62@HllExitDir

; 2691 :       /* added by habran
; 2692 :       .CONTINUE label is created here for .FOR loops only if it exists.
; 2693 :       It is different than .WHILE because it has to first alter counters
; 2694 :       */
; 2695 :       if (hll->labels[LCONT] == 0) hll->labels[LCONT] = GetHllLabel();

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	jne	SHORT $LN64@HllExitDir
	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax
$LN64@HllExitDir:

; 2696 :       idx = (hll->labels[LCONT] ? LCONT : LSTART);

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN77@HllExitDir
	mov	DWORD PTR tv519[rsp], 4
	jmp	SHORT $LN78@HllExitDir
$LN77@HllExitDir:
	mov	DWORD PTR tv519[rsp], 2
$LN78@HllExitDir:
	mov	eax, DWORD PTR tv519[rsp]
	mov	DWORD PTR idx$[rsp], eax

; 2697 :     }

	jmp	SHORT $LN63@HllExitDir
$LN62@HllExitDir:

; 2698 :     else {
; 2699 :       /* 'test' is not created for .WHILE loops here; because
; 2700 :       * if it doesn't exist, there's no condition to test.
; 2701 :       */
; 2702 :       if (hll->cmd == HLL_REPEAT && hll->labels[LTEST] == 0)

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+68], 2
	jne	SHORT $LN65@HllExitDir
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	jne	SHORT $LN65@HllExitDir

; 2703 :         hll->labels[LTEST] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax
$LN65@HllExitDir:

; 2704 :       idx = (hll->labels[LTEST] ? LTEST : LSTART);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN79@HllExitDir
	mov	DWORD PTR tv534[rsp], 0
	jmp	SHORT $LN80@HllExitDir
$LN79@HllExitDir:
	mov	DWORD PTR tv534[rsp], 2
$LN80@HllExitDir:
	mov	eax, DWORD PTR tv534[rsp]
	mov	DWORD PTR idx$[rsp], eax
$LN63@HllExitDir:
$LN60@HllExitDir:

; 2705 :     }
; 2706 : 
; 2707 :     /* .BREAK .IF ... or .CONTINUE .IF ? */
; 2708 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 2709 :     if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN66@HllExitDir

; 2710 :       if (tokenarray[i].token == T_DIRECTIVE && tokenarray[i].tokval == T_DOT_IF) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	$LN68@HllExitDir
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 328		; 00000148H
	jne	SHORT $LN68@HllExitDir

; 2711 :         enum hll_cmd savedcmd = hll->cmd;

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+68]
	mov	DWORD PTR savedcmd$1[rsp], eax

; 2712 :         hll->cmd = HLL_BREAK;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+68], 3

; 2713 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 2714 :         /* v2.11: set rc and don't exit if an error occurs; see hll3.aso */
; 2715 :         rc = EvaluateHllExpression(hll, &i, tokenarray, idx, TRUE, buffer);

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], 1
	mov	r9d, DWORD PTR idx$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	EvaluateHllExpression
	mov	DWORD PTR rc$[rsp], eax

; 2716 :         if (rc == NOT_ERROR)

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN69@HllExitDir

; 2717 :           QueueTestLines(buffer);

	lea	rcx, QWORD PTR buffer$[rsp]
	call	QueueTestLines
$LN69@HllExitDir:

; 2718 :         hll->cmd = savedcmd;

	mov	rax, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR savedcmd$1[rsp]
	mov	DWORD PTR [rax+68], ecx
$LN68@HllExitDir:

; 2719 :       }
; 2720 :     }

	jmp	SHORT $LN67@HllExitDir
$LN66@HllExitDir:

; 2721 :     else {
; 2722 :       AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[idx], buff));

	movsxd	rax, DWORD PTR idx$[rsp]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax*4+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12582
	call	AddLineQueueX
$LN67@HllExitDir:

; 2723 :     }
; 2724 :     break;

	jmp	SHORT $LN2@HllExitDir
$LN70@HllExitDir:

; 2725 : #ifdef DEBUG_OUT
; 2726 :   default: /**/myassert(0); break;

	mov	edx, 2726				; 00000aa6H
	lea	rcx, OFFSET FLAT:$SG12584
	call	InternalError
$LN2@HllExitDir:

; 2727 : #endif
; 2728 :   }
; 2729 :   if (tokenarray[i].token != T_FINAL && rc == NOT_ERROR) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN71@HllExitDir
	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN71@HllExitDir

; 2730 :     EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 2731 :     rc = ERROR;

	mov	DWORD PTR rc$[rsp], -1
$LN71@HllExitDir:

; 2732 :   }
; 2733 : 
; 2734 :   if (ModuleInfo.list)

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN72@HllExitDir

; 2735 :     LstWrite(LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL);

	call	GetCurrOffset
	xor	r8d, r8d
	mov	edx, eax
	mov	ecx, 4
	call	LstWrite
$LN72@HllExitDir:

; 2736 : 
; 2737 :   /* v2.11: always run line-queue if it's not empty. */
; 2738 :   if (is_linequeue_populated())

	cmp	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN73@HllExitDir

; 2739 :     RunLineQueue();

	call	RunLineQueue
$LN73@HllExitDir:

; 2740 : 
; 2741 :   return(rc);

	mov	eax, DWORD PTR rc$[rsp]
$LN1@HllExitDir:

; 2742 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1304				; 00000518H
	ret	0
$LN81@HllExitDir:
	DD	$LN57@HllExitDir
	DD	$LN57@HllExitDir
	DD	$LN49@HllExitDir
	DD	$LN49@HllExitDir
	DD	$LN70@HllExitDir
	DD	$LN70@HllExitDir
	DD	$LN70@HllExitDir
	DD	$LN70@HllExitDir
	DD	$LN70@HllExitDir
	DD	$LN70@HllExitDir
	DD	$LN25@HllExitDir
	DD	$LN19@HllExitDir
HllExitDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
hll$ = 48
j$ = 56
n$ = 60
lbl$ = 64
temp$ = 68
bcnt$ = 72
acnt$ = 76
rc$ = 80
tv80 = 84
dsize$ = 88
cmd$ = 92
buff$ = 96
buffer$ = 112
__$ArrayPad$ = 2160
i$ = 2192
tokenarray$ = 2200
HllEndDir PROC

; 1608 : {

$LN264:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 2184				; 00000888H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1609 :   //struct asym       *sym;
; 1610 :   struct hll_item     *hll;
; 1611 :   ret_code            rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 1612 :   int                 cmd = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR cmd$[rsp], eax

; 1613 :   int                 j, n;
; 1614 :   int                 temp;
; 1615 :   int                 acnt = 0;

	mov	DWORD PTR acnt$[rsp], 0

; 1616 :   int                 bcnt = 0;

	mov	DWORD PTR bcnt$[rsp], 0

; 1617 :   int                 dsize;
; 1618 :   uint_16             lbl;
; 1619 : 
; 1620 :   char buff[16];
; 1621 :   //char buffer[MAX_LINE_LEN*2];
; 1622 : 
; 1623 : 
; 1624 :   char buffer[MAX_LINE_LEN * 2];
; 1625 : 
; 1626 :   DebugMsg1(("HllEndDir(%s) enter\n", tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11943
	call	DoDebugMsg1

; 1627 : 
; 1628 :   if (HllStack == NULL) {

	cmp	QWORD PTR ModuleInfo+224, 0
	jne	SHORT $LN55@HllEndDir

; 1629 :     DebugMsg(("HllEndDir: hll stack is empty\n"));

	lea	rcx, OFFSET FLAT:$SG11945
	call	DoDebugMsg

; 1630 :     return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError
	jmp	$LN1@HllEndDir
$LN55@HllEndDir:

; 1631 :   }
; 1632 : 
; 1633 :   hll = HllStack;

	mov	rax, QWORD PTR ModuleInfo+224
	mov	QWORD PTR hll$[rsp], rax

; 1634 :   HllStack = hll->next;

	mov	rax, QWORD PTR hll$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ModuleInfo+224, rax

; 1635 :   /* v2.06: move the item to the free stack */
; 1636 :   hll->next = HllFree;

	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+232
	mov	QWORD PTR [rax], rcx

; 1637 :   HllFree = hll;

	mov	rax, QWORD PTR hll$[rsp]
	mov	QWORD PTR ModuleInfo+232, rax

; 1638 : 
; 1639 :   switch (cmd) {

	mov	eax, DWORD PTR cmd$[rsp]
	mov	DWORD PTR tv80[rsp], eax
	mov	eax, DWORD PTR tv80[rsp]
	sub	eax, 336				; 00000150H
	mov	DWORD PTR tv80[rsp], eax
	cmp	DWORD PTR tv80[rsp], 8
	ja	$LN257@HllEndDir
	movsxd	rax, DWORD PTR tv80[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN263@HllEndDir[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN56@HllEndDir:

; 1640 :   case T_DOT_ENDIF:
; 1641 :     if (hll->cmd != HLL_IF) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+68], 0
	je	SHORT $LN57@HllEndDir

; 1642 :       DebugMsg(("HllEndDir: no .IF on the hll stack\n"));

	lea	rcx, OFFSET FLAT:$SG11948
	call	DoDebugMsg

; 1643 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 80					; 00000050H
	call	EmitErr
	jmp	$LN1@HllEndDir
$LN57@HllEndDir:

; 1644 :     }
; 1645 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1646 :     /* if a test label isn't created yet, create it */
; 1647 :     if (hll->labels[LTEST]) {

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN58@HllEndDir

; 1648 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	mov	eax, 4
	imul	rax, rax, 0
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11950
	call	AddLineQueueX
$LN58@HllEndDir:

; 1649 :     }
; 1650 :     break;

	jmp	$LN2@HllEndDir
$LN59@HllEndDir:

; 1651 :     // added by habran
; 1652 :   case T_DOT_ENDSWITCH:
; 1653 :     if (hll->cmd != HLL_SWITCH) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+68], 5
	je	SHORT $LN60@HllEndDir

; 1654 :       DebugMsg(("HllExitDir stack error\n"));

	lea	rcx, OFFSET FLAT:$SG11953
	call	DoDebugMsg

; 1655 :       return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError
	jmp	$LN1@HllEndDir
$LN60@HllEndDir:

; 1656 :     }
; 1657 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1658 :     if (ModuleInfo.Ofssize == USE32) dsize = 4;

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jne	SHORT $LN61@HllEndDir
	mov	DWORD PTR dsize$[rsp], 4
	jmp	SHORT $LN62@HllEndDir
$LN61@HllEndDir:

; 1659 : #if AMD64_SUPPORT
; 1660 :     else dsize = 8;

	mov	DWORD PTR dsize$[rsp], 8
$LN62@HllEndDir:

; 1661 : #endif
; 1662 :     if (ModuleInfo.switch_style == ASMSWITCH) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 19
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN63@HllEndDir

; 1663 :       if (hll->labels[LEXIT] == 0)

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	jne	SHORT $LN64@HllEndDir

; 1664 :         hll->labels[LEXIT] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax
$LN64@HllEndDir:

; 1665 :       AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11958
	call	AddLineQueueX
$LN63@HllEndDir:

; 1666 :     }
; 1667 :     if (hll->labels[LDEF] == 0) {

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	jne	SHORT $LN65@HllEndDir

; 1668 :       hll->labels[LDEF] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1669 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LDEF], buff));

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11960
	call	AddLineQueueX
$LN65@HllEndDir:

; 1670 :     }
; 1671 :     AddLineQueueX("ALIGN %d", dsize);

	mov	edx, DWORD PTR dsize$[rsp]
	lea	rcx, OFFSET FLAT:$SG11961
	call	AddLineQueueX

; 1672 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSTART], buff));

	mov	eax, 4
	imul	rax, rax, 2
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11962
	call	AddLineQueueX

; 1673 :     if (Parse_Pass) {

	cmp	DWORD PTR Parse_Pass, 0
	je	$LN66@HllEndDir

; 1674 :       if (hll->casecnt == 1)

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+80], 1
	jne	SHORT $LN67@HllEndDir

; 1675 :         hll->cflag = 1;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+85], 1
	jmp	$LN68@HllEndDir
$LN67@HllEndDir:

; 1676 :       else if (hll->casecnt == 2)

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+80], 2
	jne	SHORT $LN69@HllEndDir

; 1677 :         hll->cflag = 2;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+85], 2
	jmp	$LN70@HllEndDir
$LN69@HllEndDir:

; 1678 :       else if (hll->casecnt == 3)

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+80], 3
	jne	SHORT $LN71@HllEndDir

; 1679 :         hll->cflag = 3;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+85], 3
	jmp	$LN72@HllEndDir
$LN71@HllEndDir:

; 1680 :       else
; 1681 :       {
; 1682 :         if (hll->plabels) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	QWORD PTR [rax+112], 0
	je	$LN73@HllEndDir

; 1683 :           if (ModuleInfo.Ofssize == USE32) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jne	$LN74@HllEndDir

; 1684 :             bubblesort(hll, hll->plabels, hll->pcases, hll->casecnt);

	mov	rax, QWORD PTR hll$[rsp]
	mov	r9d, DWORD PTR [rax+80]
	mov	rax, QWORD PTR hll$[rsp]
	mov	r8, QWORD PTR [rax+104]
	mov	rax, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rax+112]
	mov	rcx, QWORD PTR hll$[rsp]
	call	bubblesort

; 1685 :             if ((hll->delta * 4) <= (hll->casecnt * 4 + hll->casecnt * 2))

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+96]
	shl	eax, 2
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+80]
	mov	rdx, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rdx+80]
	shl	edx, 1
	lea	ecx, DWORD PTR [rdx+rcx*4]
	cmp	eax, ecx
	ja	SHORT $LN76@HllEndDir

; 1686 :               hll->cflag = 6;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+85], 6
	jmp	SHORT $LN77@HllEndDir
$LN76@HllEndDir:

; 1687 :             else if (hll->delta < 256)

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+96], 256			; 00000100H
	jge	SHORT $LN78@HllEndDir

; 1688 :               hll->cflag = 4;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+85], 4
	jmp	SHORT $LN79@HllEndDir
$LN78@HllEndDir:

; 1689 :             else if (hll->delta < 512)

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+96], 512			; 00000200H
	jge	SHORT $LN80@HllEndDir

; 1690 :               hll->cflag = 7;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+85], 7
	jmp	SHORT $LN81@HllEndDir
$LN80@HllEndDir:

; 1691 :             else
; 1692 :               hll->cflag = 5;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+85], 5
$LN81@HllEndDir:
$LN79@HllEndDir:
$LN77@HllEndDir:

; 1693 :           }

	jmp	$LN75@HllEndDir
$LN74@HllEndDir:

; 1694 : #if AMD64_SUPPORT
; 1695 :           else {     //USE64
; 1696 :             if (hll->csize == 4) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	$LN82@HllEndDir

; 1697 :               bubblesort(hll, hll->plabels, hll->pcases, hll->casecnt);

	mov	rax, QWORD PTR hll$[rsp]
	mov	r9d, DWORD PTR [rax+80]
	mov	rax, QWORD PTR hll$[rsp]
	mov	r8, QWORD PTR [rax+104]
	mov	rax, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rax+112]
	mov	rcx, QWORD PTR hll$[rsp]
	call	bubblesort

; 1698 :               if ((hll->delta * 8) <= (hll->casecnt * 8 + hll->casecnt * 2))

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+96]
	shl	eax, 3
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+80]
	mov	rdx, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rdx+80]
	shl	edx, 1
	lea	ecx, DWORD PTR [rdx+rcx*8]
	cmp	eax, ecx
	ja	SHORT $LN84@HllEndDir

; 1699 :                 hll->cflag = 6;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+85], 6
	jmp	SHORT $LN85@HllEndDir
$LN84@HllEndDir:

; 1700 :               else if (hll->delta < 256)

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+96], 256			; 00000100H
	jge	SHORT $LN86@HllEndDir

; 1701 :                 hll->cflag = 4;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+85], 4
	jmp	SHORT $LN87@HllEndDir
$LN86@HllEndDir:

; 1702 :               else if (hll->delta < 512)

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+96], 512			; 00000200H
	jge	SHORT $LN88@HllEndDir

; 1703 :                 hll->cflag = 7;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+85], 7
	jmp	SHORT $LN89@HllEndDir
$LN88@HllEndDir:

; 1704 :               else
; 1705 :                 hll->cflag = 5;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+85], 5
$LN89@HllEndDir:
$LN87@HllEndDir:
$LN85@HllEndDir:

; 1706 :             }

	jmp	$LN83@HllEndDir
$LN82@HllEndDir:

; 1707 :             else {
; 1708 :               bubblesort64(hll, hll->plabels, hll->pcases64, hll->casecnt);

	mov	rax, QWORD PTR hll$[rsp]
	mov	r9d, DWORD PTR [rax+80]
	mov	rax, QWORD PTR hll$[rsp]
	mov	r8, QWORD PTR [rax+152]
	mov	rax, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rax+112]
	mov	rcx, QWORD PTR hll$[rsp]
	call	bubblesort64

; 1709 :               if ((hll->delta64 * 8) <= (hll->casecnt * 8 + hll->casecnt * 2))

	mov	rax, QWORD PTR hll$[rsp]
	mov	rax, QWORD PTR [rax+144]
	shl	rax, 3
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+80]
	mov	rdx, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rdx+80]
	shl	edx, 1
	lea	ecx, DWORD PTR [rdx+rcx*8]
	mov	ecx, ecx
	cmp	rax, rcx
	ja	SHORT $LN90@HllEndDir

; 1710 :                 hll->cflag = 6;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+85], 6
	jmp	SHORT $LN91@HllEndDir
$LN90@HllEndDir:

; 1711 :               else if (hll->delta64 < 256)

	mov	rax, QWORD PTR hll$[rsp]
	cmp	QWORD PTR [rax+144], 256		; 00000100H
	jae	SHORT $LN92@HllEndDir

; 1712 :                 hll->cflag = 4;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+85], 4
	jmp	SHORT $LN93@HllEndDir
$LN92@HllEndDir:

; 1713 :               else if (hll->delta64 < 512)

	mov	rax, QWORD PTR hll$[rsp]
	cmp	QWORD PTR [rax+144], 512		; 00000200H
	jae	SHORT $LN94@HllEndDir

; 1714 :                 hll->cflag = 7;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+85], 7
	jmp	SHORT $LN95@HllEndDir
$LN94@HllEndDir:

; 1715 :               else
; 1716 :                 hll->cflag = 5;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+85], 5
$LN95@HllEndDir:
$LN93@HllEndDir:
$LN91@HllEndDir:
$LN83@HllEndDir:
$LN75@HllEndDir:
$LN73@HllEndDir:
$LN72@HllEndDir:
$LN70@HllEndDir:
$LN68@HllEndDir:

; 1717 :             }
; 1718 :           }
; 1719 : #endif
; 1720 :         }
; 1721 :       }
; 1722 :       if (hll->cflag == 1) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 1
	jne	$LN96@HllEndDir

; 1723 :         if ((ModuleInfo.Ofssize == USE32) || (hll->csize == 4)) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	je	SHORT $LN100@HllEndDir
	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	$LN98@HllEndDir
$LN100@HllEndDir:

; 1724 :           AddLineQueueX("cmp  eax,%d", hll->pcases[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	edx, DWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG11998
	call	AddLineQueueX

; 1725 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11999
	call	AddLineQueueX

; 1726 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN101@HllEndDir

; 1727 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12002
	call	AddLineQueueX
	jmp	SHORT $LN102@HllEndDir
$LN101@HllEndDir:

; 1728 :           else
; 1729 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12003
	call	AddLineQueueX
$LN102@HllEndDir:

; 1730 :         }

	jmp	$LN99@HllEndDir
$LN98@HllEndDir:

; 1731 : #if AMD64_SUPPORT
; 1732 :         else
; 1733 :         {
; 1734 :           AddLineQueueX("push rdx");

	lea	rcx, OFFSET FLAT:$SG12004
	call	AddLineQueueX

; 1735 :           AddLineQueueX("mov rdx, %q", hll->pcases64[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+152]
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12005
	call	AddLineQueueX

; 1736 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG12006
	call	AddLineQueueX

; 1737 :           AddLineQueueX("pop rdx");

	lea	rcx, OFFSET FLAT:$SG12007
	call	AddLineQueueX

; 1738 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12008
	call	AddLineQueueX

; 1739 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN103@HllEndDir

; 1740 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12011
	call	AddLineQueueX
	jmp	SHORT $LN104@HllEndDir
$LN103@HllEndDir:

; 1741 :           else
; 1742 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12012
	call	AddLineQueueX
$LN104@HllEndDir:
$LN99@HllEndDir:

; 1743 :         }
; 1744 : #endif
; 1745 :       }

	jmp	$LN97@HllEndDir
$LN96@HllEndDir:

; 1746 :       else if (hll->cflag == 2) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 2
	jne	$LN105@HllEndDir

; 1747 :         if ((ModuleInfo.Ofssize == USE32) || (hll->csize == 4)) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	je	SHORT $LN109@HllEndDir
	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	$LN107@HllEndDir
$LN109@HllEndDir:

; 1748 :           AddLineQueueX("cmp  eax,%d", hll->pcases[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	edx, DWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12018
	call	AddLineQueueX

; 1749 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12019
	call	AddLineQueueX

; 1750 :           AddLineQueueX("cmp  eax,%d", hll->pcases[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	edx, DWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12020
	call	AddLineQueueX

; 1751 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[1], buff));

	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12021
	call	AddLineQueueX

; 1752 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN110@HllEndDir

; 1753 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12024
	call	AddLineQueueX
	jmp	SHORT $LN111@HllEndDir
$LN110@HllEndDir:

; 1754 :           else
; 1755 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12025
	call	AddLineQueueX
$LN111@HllEndDir:

; 1756 :         }

	jmp	$LN108@HllEndDir
$LN107@HllEndDir:

; 1757 : #if AMD64_SUPPORT
; 1758 :         else
; 1759 :         {
; 1760 :           AddLineQueueX("push rdx");

	lea	rcx, OFFSET FLAT:$SG12026
	call	AddLineQueueX

; 1761 :           AddLineQueueX("mov rdx, %q", hll->pcases64[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+152]
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12027
	call	AddLineQueueX

; 1762 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG12028
	call	AddLineQueueX

; 1763 :           AddLineQueueX("pop rdx");

	lea	rcx, OFFSET FLAT:$SG12029
	call	AddLineQueueX

; 1764 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12030
	call	AddLineQueueX

; 1765 :           AddLineQueueX("push rdx");

	lea	rcx, OFFSET FLAT:$SG12031
	call	AddLineQueueX

; 1766 :           AddLineQueueX("mov rdx, %q", hll->pcases64[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+152]
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12032
	call	AddLineQueueX

; 1767 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG12033
	call	AddLineQueueX

; 1768 :           AddLineQueueX("pop rdx");

	lea	rcx, OFFSET FLAT:$SG12034
	call	AddLineQueueX

; 1769 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[1], buff));

	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12035
	call	AddLineQueueX

; 1770 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN112@HllEndDir

; 1771 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12038
	call	AddLineQueueX
	jmp	SHORT $LN113@HllEndDir
$LN112@HllEndDir:

; 1772 :           else
; 1773 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12039
	call	AddLineQueueX
$LN113@HllEndDir:
$LN108@HllEndDir:

; 1774 :         }
; 1775 : #endif
; 1776 :       }

	jmp	$LN106@HllEndDir
$LN105@HllEndDir:

; 1777 :       else if (hll->cflag == 3) { 

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 3
	jne	$LN114@HllEndDir

; 1778 :         if ((ModuleInfo.Ofssize == USE32) || (hll->csize == 4)) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	je	SHORT $LN118@HllEndDir
	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	$LN116@HllEndDir
$LN118@HllEndDir:

; 1779 :           AddLineQueueX("cmp  eax,%d", hll->pcases[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	edx, DWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12045
	call	AddLineQueueX

; 1780 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12046
	call	AddLineQueueX

; 1781 :           AddLineQueueX("cmp  eax,%d", hll->pcases[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	edx, DWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12047
	call	AddLineQueueX

; 1782 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[1], buff));

	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12048
	call	AddLineQueueX

; 1783 :           AddLineQueueX("cmp  eax,%d", hll->pcases[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	edx, DWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12049
	call	AddLineQueueX

; 1784 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[2], buff));

	mov	eax, 2
	imul	rax, rax, 2
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12050
	call	AddLineQueueX

; 1785 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN119@HllEndDir

; 1786 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12053
	call	AddLineQueueX
	jmp	SHORT $LN120@HllEndDir
$LN119@HllEndDir:

; 1787 :           else
; 1788 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12054
	call	AddLineQueueX
$LN120@HllEndDir:

; 1789 :         }

	jmp	$LN117@HllEndDir
$LN116@HllEndDir:

; 1790 : #if AMD64_SUPPORT
; 1791 :         else
; 1792 :         {
; 1793 :           AddLineQueueX("push rdx");

	lea	rcx, OFFSET FLAT:$SG12055
	call	AddLineQueueX

; 1794 :           AddLineQueueX("mov rdx, %q", hll->pcases64[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+152]
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12056
	call	AddLineQueueX

; 1795 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG12057
	call	AddLineQueueX

; 1796 :           AddLineQueueX("pop rdx");

	lea	rcx, OFFSET FLAT:$SG12058
	call	AddLineQueueX

; 1797 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12059
	call	AddLineQueueX

; 1798 :           AddLineQueueX("push rdx");

	lea	rcx, OFFSET FLAT:$SG12060
	call	AddLineQueueX

; 1799 :           AddLineQueueX("mov rdx, %q", hll->pcases64[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+152]
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12061
	call	AddLineQueueX

; 1800 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG12062
	call	AddLineQueueX

; 1801 :           AddLineQueueX("pop rdx");

	lea	rcx, OFFSET FLAT:$SG12063
	call	AddLineQueueX

; 1802 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[1], buff));

	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12064
	call	AddLineQueueX

; 1803 :           AddLineQueueX("push rdx");

	lea	rcx, OFFSET FLAT:$SG12065
	call	AddLineQueueX

; 1804 :           AddLineQueueX("mov rdx, %q", hll->pcases64[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+152]
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG12066
	call	AddLineQueueX

; 1805 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG12067
	call	AddLineQueueX

; 1806 :           AddLineQueueX("pop rdx");

	lea	rcx, OFFSET FLAT:$SG12068
	call	AddLineQueueX

; 1807 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[2], buff));

	mov	eax, 2
	imul	rax, rax, 2
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12069
	call	AddLineQueueX

; 1808 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN121@HllEndDir

; 1809 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12072
	call	AddLineQueueX
	jmp	SHORT $LN122@HllEndDir
$LN121@HllEndDir:

; 1810 :           else
; 1811 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12073
	call	AddLineQueueX
$LN122@HllEndDir:
$LN117@HllEndDir:

; 1812 :         }
; 1813 : #endif
; 1814 :       }

	jmp	$LN115@HllEndDir
$LN114@HllEndDir:

; 1815 :       else if (hll->cflag == 4) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 4
	jne	$LN123@HllEndDir

; 1816 :         if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN125@HllEndDir

; 1817 :           GetLabelStr(hll->labels[LDEF], buff);

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	jmp	SHORT $LN126@HllEndDir
$LN125@HllEndDir:

; 1818 :         else {
; 1819 :           GetLabelStr(hll->labels[LEXIT], buff);

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
$LN126@HllEndDir:

; 1820 :         }
; 1821 :         if (hll->csize == 4) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	SHORT $LN127@HllEndDir

; 1822 :           AddLineQueueX("cmp eax,%d", hll->mincase);

	mov	rax, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rax+92]
	lea	rcx, OFFSET FLAT:$SG12080
	call	AddLineQueueX

; 1823 :           AddLineQueueX("jl  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12081
	call	AddLineQueueX

; 1824 :           AddLineQueueX("cmp eax,%d", hll->maxcase);

	mov	rax, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rax+88]
	lea	rcx, OFFSET FLAT:$SG12082
	call	AddLineQueueX

; 1825 :           AddLineQueueX("ja  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12083
	call	AddLineQueueX

; 1826 :         }

	jmp	$LN128@HllEndDir
$LN127@HllEndDir:

; 1827 : #if AMD64_SUPPORT
; 1828 :         else {
; 1829 :           AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG12084
	call	AddLineQueueX

; 1830 :           AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG12085
	call	AddLineQueueX

; 1831 :           AddLineQueueX("mov rdx, %q", hll->mincase64);

	mov	rax, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rax+136]
	lea	rcx, OFFSET FLAT:$SG12086
	call	AddLineQueueX

; 1832 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG12087
	call	AddLineQueueX

; 1833 :           AddLineQueueX("pop	rdx");

	lea	rcx, OFFSET FLAT:$SG12088
	call	AddLineQueueX

; 1834 :           AddLineQueueX("pop	rax");

	lea	rcx, OFFSET FLAT:$SG12089
	call	AddLineQueueX

; 1835 :           AddLineQueueX("jl  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12090
	call	AddLineQueueX

; 1836 :           AddLineQueueX("mov rdx, %q", hll->maxcase64);

	mov	rax, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rax+128]
	lea	rcx, OFFSET FLAT:$SG12091
	call	AddLineQueueX

; 1837 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG12092
	call	AddLineQueueX

; 1838 :           AddLineQueueX("pop	rdx");

	lea	rcx, OFFSET FLAT:$SG12093
	call	AddLineQueueX

; 1839 :           AddLineQueueX("pop	rax");

	lea	rcx, OFFSET FLAT:$SG12094
	call	AddLineQueueX

; 1840 :           AddLineQueueX("ja  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12095
	call	AddLineQueueX
$LN128@HllEndDir:

; 1841 :         }
; 1842 : #endif
; 1843 :         if (ModuleInfo.Ofssize == USE32) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jne	$LN129@HllEndDir

; 1844 :           GetLabelStr(hll->labels[LDATA2], buff);

	mov	eax, 4
	imul	rax, rax, 7
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr

; 1845 :           AddLineQueueX("push	 eax");

	lea	rcx, OFFSET FLAT:$SG12098
	call	AddLineQueueX

; 1846 :           AddLineQueueX("movzx eax,byte ptr %s[%r - %d]", buff, T_EAX, hll->mincase);

	mov	rax, QWORD PTR hll$[rsp]
	mov	r9d, DWORD PTR [rax+92]
	mov	r8d, 17
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12099
	call	AddLineQueueX

; 1847 :           GetLabelStr(hll->labels[LDATA1], buff);

	mov	eax, 4
	imul	rax, rax, 6
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr

; 1848 :           AddLineQueueX("mov   eax,%s[%r*4]", buff, T_EAX);

	mov	r8d, 17
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12100
	call	AddLineQueueX

; 1849 :           AddLineQueueX("xchg	 eax,[esp]");

	lea	rcx, OFFSET FLAT:$SG12101
	call	AddLineQueueX

; 1850 :           AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG12102
	call	AddLineQueueX

; 1851 :         }

	jmp	$LN130@HllEndDir
$LN129@HllEndDir:

; 1852 : #if AMD64_SUPPORT
; 1853 :         else {
; 1854 :           if (hll->csize == 4) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	$LN131@HllEndDir

; 1855 :             GetLabelStr(hll->labels[LDATA2], buff);

	mov	eax, 4
	imul	rax, rax, 7
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr

; 1856 :             AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG12105
	call	AddLineQueueX

; 1857 :             AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG12106
	call	AddLineQueueX

; 1858 :             AddLineQueueX("lea   rdx,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12107
	call	AddLineQueueX

; 1859 :             AddLineQueueX("movzx edx,byte ptr[rdx+rax-%u]", hll->mincase);

	mov	rax, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rax+92]
	lea	rcx, OFFSET FLAT:$SG12108
	call	AddLineQueueX

; 1860 :             GetLabelStr(hll->labels[LDATA1], buff);

	mov	eax, 4
	imul	rax, rax, 6
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr

; 1861 :             AddLineQueueX("lea   rax,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12109
	call	AddLineQueueX

; 1862 :             AddLineQueueX("mov   rax, qword ptr[rax+rdx*8]");

	lea	rcx, OFFSET FLAT:$SG12110
	call	AddLineQueueX

; 1863 :             AddLineQueueX("pop   rdx");

	lea	rcx, OFFSET FLAT:$SG12111
	call	AddLineQueueX

; 1864 :             AddLineQueueX("xchg	 rax,[rsp]");

	lea	rcx, OFFSET FLAT:$SG12112
	call	AddLineQueueX

; 1865 :             AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG12113
	call	AddLineQueueX

; 1866 :           }

	jmp	$LN132@HllEndDir
$LN131@HllEndDir:

; 1867 :           else {
; 1868 :             GetLabelStr(hll->labels[LDATA2], buff);

	mov	eax, 4
	imul	rax, rax, 7
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr

; 1869 :             AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG12114
	call	AddLineQueueX

; 1870 :             AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG12115
	call	AddLineQueueX

; 1871 :             AddLineQueueX("lea   rdx,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12116
	call	AddLineQueueX

; 1872 :             AddLineQueueX("movzx rdx,byte ptr[rdx+rax-%q]", hll->mincase64);

	mov	rax, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rax+136]
	lea	rcx, OFFSET FLAT:$SG12117
	call	AddLineQueueX

; 1873 :             GetLabelStr(hll->labels[LDATA1], buff);

	mov	eax, 4
	imul	rax, rax, 6
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr

; 1874 :             AddLineQueueX("lea   rax,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12118
	call	AddLineQueueX

; 1875 :             AddLineQueueX("mov   rax, qword ptr[rax+rdx*8]");

	lea	rcx, OFFSET FLAT:$SG12119
	call	AddLineQueueX

; 1876 :             AddLineQueueX("pop   rdx");

	lea	rcx, OFFSET FLAT:$SG12120
	call	AddLineQueueX

; 1877 :             AddLineQueueX("xchg	 rax,[rsp]");

	lea	rcx, OFFSET FLAT:$SG12121
	call	AddLineQueueX

; 1878 :             AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG12122
	call	AddLineQueueX
$LN132@HllEndDir:
$LN130@HllEndDir:

; 1879 :           }
; 1880 :         }
; 1881 : #endif
; 1882 :       }

	jmp	$LN124@HllEndDir
$LN123@HllEndDir:

; 1883 :       else if (hll->cflag == 7) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 7
	jne	$LN133@HllEndDir

; 1884 :         if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN135@HllEndDir

; 1885 :           GetLabelStr(hll->labels[LDEF], buff);

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	jmp	SHORT $LN136@HllEndDir
$LN135@HllEndDir:

; 1886 :         else {
; 1887 :           GetLabelStr(hll->labels[LEXIT], buff);

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
$LN136@HllEndDir:

; 1888 :         }
; 1889 :         if (hll->csize == 4) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	SHORT $LN137@HllEndDir

; 1890 :           AddLineQueueX("cmp eax,%d", hll->mincase);

	mov	rax, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rax+92]
	lea	rcx, OFFSET FLAT:$SG12129
	call	AddLineQueueX

; 1891 :           AddLineQueueX("jl  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12130
	call	AddLineQueueX

; 1892 :           AddLineQueueX("cmp eax,%d", hll->maxcase);

	mov	rax, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rax+88]
	lea	rcx, OFFSET FLAT:$SG12131
	call	AddLineQueueX

; 1893 :           AddLineQueueX("ja  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12132
	call	AddLineQueueX

; 1894 :         }

	jmp	$LN138@HllEndDir
$LN137@HllEndDir:

; 1895 : #if AMD64_SUPPORT
; 1896 :         else {
; 1897 :           AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG12133
	call	AddLineQueueX

; 1898 :           AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG12134
	call	AddLineQueueX

; 1899 :           AddLineQueueX("mov rdx, %q", hll->mincase64);

	mov	rax, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rax+136]
	lea	rcx, OFFSET FLAT:$SG12135
	call	AddLineQueueX

; 1900 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG12136
	call	AddLineQueueX

; 1901 :           AddLineQueueX("pop	rdx");

	lea	rcx, OFFSET FLAT:$SG12137
	call	AddLineQueueX

; 1902 :           AddLineQueueX("pop	rax");

	lea	rcx, OFFSET FLAT:$SG12138
	call	AddLineQueueX

; 1903 :           AddLineQueueX("jl  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12139
	call	AddLineQueueX

; 1904 :           AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG12140
	call	AddLineQueueX

; 1905 :           AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG12141
	call	AddLineQueueX

; 1906 :           AddLineQueueX("mov rdx, %q", hll->maxcase64);

	mov	rax, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rax+128]
	lea	rcx, OFFSET FLAT:$SG12142
	call	AddLineQueueX

; 1907 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG12143
	call	AddLineQueueX

; 1908 :           AddLineQueueX("pop	rdx");

	lea	rcx, OFFSET FLAT:$SG12144
	call	AddLineQueueX

; 1909 :           AddLineQueueX("pop	rax");

	lea	rcx, OFFSET FLAT:$SG12145
	call	AddLineQueueX

; 1910 :           AddLineQueueX("ja  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12146
	call	AddLineQueueX
$LN138@HllEndDir:

; 1911 :         }
; 1912 : #endif
; 1913 :         if (ModuleInfo.Ofssize == USE32) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jne	$LN139@HllEndDir

; 1914 :           GetLabelStr(hll->labels[LDATA2], buff);

	mov	eax, 4
	imul	rax, rax, 7
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr

; 1915 :           AddLineQueueX("push	 eax");

	lea	rcx, OFFSET FLAT:$SG12149
	call	AddLineQueueX

; 1916 :           AddLineQueueX("sub   eax,%u", hll->mincase);

	mov	rax, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rax+92]
	lea	rcx, OFFSET FLAT:$SG12150
	call	AddLineQueueX

; 1917 :           AddLineQueueX("movzx eax,word ptr %s[%r*2]", buff, T_EAX);

	mov	r8d, 17
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12151
	call	AddLineQueueX

; 1918 :           GetLabelStr(hll->labels[LDATA1], buff);

	mov	eax, 4
	imul	rax, rax, 6
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr

; 1919 :           AddLineQueueX("mov   eax,%s[%r*4]", buff, T_EAX);

	mov	r8d, 17
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12152
	call	AddLineQueueX

; 1920 :           AddLineQueueX("xchg	 eax,[esp]");

	lea	rcx, OFFSET FLAT:$SG12153
	call	AddLineQueueX

; 1921 :           AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG12154
	call	AddLineQueueX

; 1922 :         }

	jmp	$LN140@HllEndDir
$LN139@HllEndDir:

; 1923 : #if AMD64_SUPPORT
; 1924 :         else {
; 1925 :           AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG12155
	call	AddLineQueueX

; 1926 :           AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG12156
	call	AddLineQueueX

; 1927 :           if (hll->csize == 4) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	$LN141@HllEndDir

; 1928 :             GetLabelStr(hll->labels[LDATA2], buff);

	mov	eax, 4
	imul	rax, rax, 7
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr

; 1929 :             AddLineQueueX("lea   rdx,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12159
	call	AddLineQueueX

; 1930 :             AddLineQueueX("sub   eax,%u", hll->mincase);

	mov	rax, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rax+92]
	lea	rcx, OFFSET FLAT:$SG12160
	call	AddLineQueueX

; 1931 :             AddLineQueueX("movzx rdx,word ptr[rdx+rax*2]");

	lea	rcx, OFFSET FLAT:$SG12161
	call	AddLineQueueX

; 1932 :             GetLabelStr(hll->labels[LDATA1], buff);

	mov	eax, 4
	imul	rax, rax, 6
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr

; 1933 :             AddLineQueueX("lea   rax,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12162
	call	AddLineQueueX

; 1934 :             AddLineQueueX("mov   rax, qword ptr[rax+rdx*8]");

	lea	rcx, OFFSET FLAT:$SG12163
	call	AddLineQueueX

; 1935 :             AddLineQueueX("pop   rdx");

	lea	rcx, OFFSET FLAT:$SG12164
	call	AddLineQueueX

; 1936 :             AddLineQueueX("xchg	 rax,[rsp]");

	lea	rcx, OFFSET FLAT:$SG12165
	call	AddLineQueueX

; 1937 :             AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG12166
	call	AddLineQueueX

; 1938 :           }

	jmp	$LN142@HllEndDir
$LN141@HllEndDir:

; 1939 :           else {
; 1940 :             GetLabelStr(hll->labels[LDATA2], buff);

	mov	eax, 4
	imul	rax, rax, 7
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr

; 1941 :             AddLineQueueX("lea   rdx,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12167
	call	AddLineQueueX

; 1942 :             AddLineQueueX("sub   rax,%u", hll->mincase64);

	mov	rax, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rax+136]
	lea	rcx, OFFSET FLAT:$SG12168
	call	AddLineQueueX

; 1943 :             AddLineQueueX("movzx rdx,word ptr[rdx+rax*2]");

	lea	rcx, OFFSET FLAT:$SG12169
	call	AddLineQueueX

; 1944 :             GetLabelStr(hll->labels[LDATA1], buff);

	mov	eax, 4
	imul	rax, rax, 6
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr

; 1945 :             AddLineQueueX("lea   rax,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12170
	call	AddLineQueueX

; 1946 :             AddLineQueueX("mov   rax, qword ptr[rax+rdx*8]");

	lea	rcx, OFFSET FLAT:$SG12171
	call	AddLineQueueX

; 1947 :             AddLineQueueX("pop   rdx");

	lea	rcx, OFFSET FLAT:$SG12172
	call	AddLineQueueX

; 1948 :             AddLineQueueX("xchg	 rax,[rsp]");

	lea	rcx, OFFSET FLAT:$SG12173
	call	AddLineQueueX

; 1949 :             AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG12174
	call	AddLineQueueX
$LN142@HllEndDir:
$LN140@HllEndDir:

; 1950 :           }
; 1951 :         }
; 1952 : #endif
; 1953 :       }

	jmp	$LN134@HllEndDir
$LN133@HllEndDir:

; 1954 :       else if (hll->cflag == 6) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 6
	jne	$LN143@HllEndDir

; 1955 :         if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN145@HllEndDir

; 1956 :           GetLabelStr(hll->labels[LDEF], buff);

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	jmp	SHORT $LN146@HllEndDir
$LN145@HllEndDir:

; 1957 :         else {
; 1958 :           GetLabelStr(hll->labels[LEXIT], buff);

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
$LN146@HllEndDir:

; 1959 :         }
; 1960 :         if (hll->csize == 4) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	SHORT $LN147@HllEndDir

; 1961 :           AddLineQueueX("cmp eax,%d", hll->mincase);

	mov	rax, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rax+92]
	lea	rcx, OFFSET FLAT:$SG12181
	call	AddLineQueueX

; 1962 :           AddLineQueueX("jl  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12182
	call	AddLineQueueX

; 1963 :           AddLineQueueX("cmp eax,%d", hll->maxcase);

	mov	rax, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rax+88]
	lea	rcx, OFFSET FLAT:$SG12183
	call	AddLineQueueX

; 1964 :           AddLineQueueX("ja  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12184
	call	AddLineQueueX

; 1965 :         }

	jmp	$LN148@HllEndDir
$LN147@HllEndDir:

; 1966 : #if AMD64_SUPPORT
; 1967 :         else {
; 1968 :           AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG12185
	call	AddLineQueueX

; 1969 :           AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG12186
	call	AddLineQueueX

; 1970 :           AddLineQueueX("mov rdx, %q", hll->mincase64);

	mov	rax, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rax+136]
	lea	rcx, OFFSET FLAT:$SG12187
	call	AddLineQueueX

; 1971 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG12188
	call	AddLineQueueX

; 1972 :           AddLineQueueX("pop	rdx");

	lea	rcx, OFFSET FLAT:$SG12189
	call	AddLineQueueX

; 1973 :           AddLineQueueX("pop	rax");

	lea	rcx, OFFSET FLAT:$SG12190
	call	AddLineQueueX

; 1974 :           AddLineQueueX("jl  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12191
	call	AddLineQueueX

; 1975 :           AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG12192
	call	AddLineQueueX

; 1976 :           AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG12193
	call	AddLineQueueX

; 1977 :           AddLineQueueX("mov rdx, %q", hll->maxcase64);

	mov	rax, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rax+128]
	lea	rcx, OFFSET FLAT:$SG12194
	call	AddLineQueueX

; 1978 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG12195
	call	AddLineQueueX

; 1979 :           AddLineQueueX("pop	rdx");

	lea	rcx, OFFSET FLAT:$SG12196
	call	AddLineQueueX

; 1980 :           AddLineQueueX("pop	rax");

	lea	rcx, OFFSET FLAT:$SG12197
	call	AddLineQueueX

; 1981 :           AddLineQueueX("ja  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12198
	call	AddLineQueueX
$LN148@HllEndDir:

; 1982 :         }
; 1983 : #endif 
; 1984 : 
; 1985 :         if (ModuleInfo.Ofssize == USE32) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jne	SHORT $LN149@HllEndDir

; 1986 :           AddLineQueueX("push	 eax");

	lea	rcx, OFFSET FLAT:$SG12201
	call	AddLineQueueX

; 1987 :           AddLineQueueX("sub eax,%d", hll->mincase);

	mov	rax, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rax+92]
	lea	rcx, OFFSET FLAT:$SG12202
	call	AddLineQueueX

; 1988 :           AddLineQueueX("mov   eax,%s[%r*4]", GetLabelStr(hll->labels[LDATA1], buff), T_EAX);

	mov	eax, 4
	imul	rax, rax, 6
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	r8d, 17
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12203
	call	AddLineQueueX

; 1989 :           AddLineQueueX("xchg	 eax,[esp]");

	lea	rcx, OFFSET FLAT:$SG12204
	call	AddLineQueueX

; 1990 :           AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG12205
	call	AddLineQueueX

; 1991 :         }

	jmp	$LN150@HllEndDir
$LN149@HllEndDir:

; 1992 : #if AMD64_SUPPORT
; 1993 :         else {
; 1994 :           AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG12206
	call	AddLineQueueX

; 1995 :           AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG12207
	call	AddLineQueueX

; 1996 :           if (hll->csize == 4)

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	SHORT $LN151@HllEndDir

; 1997 :             AddLineQueueX("sub   eax,%d", hll->mincase);

	mov	rax, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rax+92]
	lea	rcx, OFFSET FLAT:$SG12210
	call	AddLineQueueX
	jmp	SHORT $LN152@HllEndDir
$LN151@HllEndDir:

; 1998 :           else{
; 1999 :             AddLineQueueX("mov rdx,%q", hll->mincase64);

	mov	rax, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rax+136]
	lea	rcx, OFFSET FLAT:$SG12211
	call	AddLineQueueX

; 2000 :             AddLineQueueX("sub rax,rdx");

	lea	rcx, OFFSET FLAT:$SG12212
	call	AddLineQueueX
$LN152@HllEndDir:

; 2001 :           }
; 2002 :           AddLineQueueX("lea   rdx,%s", GetLabelStr(hll->labels[LDATA1], buff));

	mov	eax, 4
	imul	rax, rax, 6
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12213
	call	AddLineQueueX

; 2003 :           AddLineQueueX("mov   rax, qword ptr[rdx+rax*8]");

	lea	rcx, OFFSET FLAT:$SG12214
	call	AddLineQueueX

; 2004 :           AddLineQueueX("pop   rdx");

	lea	rcx, OFFSET FLAT:$SG12215
	call	AddLineQueueX

; 2005 :           AddLineQueueX("xchg	 rax,[rsp]");

	lea	rcx, OFFSET FLAT:$SG12216
	call	AddLineQueueX

; 2006 :           AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG12217
	call	AddLineQueueX
$LN150@HllEndDir:

; 2007 :         }
; 2008 : #endif
; 2009 :       }

	jmp	$LN144@HllEndDir
$LN143@HllEndDir:

; 2010 :       /* simple binary tree
; 2011 :       while (low <= high) {
; 2012 :       int mid = (low + high) / 2;
; 2013 :       if (hll->pcases[mid] == hll->casecnt)
; 2014 :       return mid;
; 2015 :       else if (hll->pcases[mid] < x)
; 2016 :       low = mid + 1;
; 2017 :       else high = mid - 1;
; 2018 :       }*/
; 2019 :       else if (hll->cflag == 5) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 5
	jne	$LN153@HllEndDir

; 2020 :         if (ModuleInfo.Ofssize == USE32) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jne	$LN154@HllEndDir

; 2021 :           AddLineQueueX("push	eax");

	lea	rcx, OFFSET FLAT:$SG12221
	call	AddLineQueueX

; 2022 :           AddLineQueueX("push	edx");

	lea	rcx, OFFSET FLAT:$SG12222
	call	AddLineQueueX

; 2023 :           AddLineQueueX("push	ecx");

	lea	rcx, OFFSET FLAT:$SG12223
	call	AddLineQueueX

; 2024 :           AddLineQueueX("push	ebx");

	lea	rcx, OFFSET FLAT:$SG12224
	call	AddLineQueueX

; 2025 :           AddLineQueueX("push	esi");

	lea	rcx, OFFSET FLAT:$SG12225
	call	AddLineQueueX

; 2026 :           AddLineQueueX("push	edi");

	lea	rcx, OFFSET FLAT:$SG12226
	call	AddLineQueueX

; 2027 :           AddLineQueueX("mov  esi,eax");

	lea	rcx, OFFSET FLAT:$SG12227
	call	AddLineQueueX

; 2028 :           AddLineQueueX("mov  ebx,%d", hll->casecnt - 1);//int high = len - 1;

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	dec	eax
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12228
	call	AddLineQueueX

; 2029 :           AddLineQueueX("xor  ecx,ecx");//int low = 0;

	lea	rcx, OFFSET FLAT:$SG12229
	call	AddLineQueueX

; 2030 :           AddLineQueueX("lea  edi,%s", GetLabelStr(hll->labels[LDATA2], buff));//int hll->pcases

	mov	eax, 4
	imul	rax, rax, 7
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12230
	call	AddLineQueueX

; 2031 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN156@HllEndDir

; 2032 :             AddLineQueueX("js  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12233
	call	AddLineQueueX
	jmp	SHORT $LN157@HllEndDir
$LN156@HllEndDir:

; 2033 :           else
; 2034 :             AddLineQueueX("js  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12234
	call	AddLineQueueX
$LN157@HllEndDir:

; 2035 : 
; 2036 :         }

	jmp	$LN155@HllEndDir
$LN154@HllEndDir:

; 2037 : #if AMD64_SUPPORT
; 2038 :         else {
; 2039 :           AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG12235
	call	AddLineQueueX

; 2040 :           AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG12236
	call	AddLineQueueX

; 2041 :           AddLineQueueX("push	rcx");

	lea	rcx, OFFSET FLAT:$SG12237
	call	AddLineQueueX

; 2042 :           AddLineQueueX("push	rbx");

	lea	rcx, OFFSET FLAT:$SG12238
	call	AddLineQueueX

; 2043 :           AddLineQueueX("push	rsi");

	lea	rcx, OFFSET FLAT:$SG12239
	call	AddLineQueueX

; 2044 :           AddLineQueueX("push	rdi");

	lea	rcx, OFFSET FLAT:$SG12240
	call	AddLineQueueX

; 2045 :           if (hll->csize == 4) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	SHORT $LN158@HllEndDir

; 2046 :             AddLineQueueX("mov  esi,eax");

	lea	rcx, OFFSET FLAT:$SG12243
	call	AddLineQueueX

; 2047 :             AddLineQueueX("mov  ebx,%d", hll->casecnt - 1);//int high = len - 1;

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	dec	eax
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12244
	call	AddLineQueueX

; 2048 :             AddLineQueueX("xor  ecx,ecx");//int low = 0;

	lea	rcx, OFFSET FLAT:$SG12245
	call	AddLineQueueX

; 2049 :             AddLineQueueX("lea  rdi,%s", GetLabelStr(hll->labels[LDATA2], buff));//int hll->pcases

	mov	eax, 4
	imul	rax, rax, 7
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12246
	call	AddLineQueueX

; 2050 :           }

	jmp	SHORT $LN159@HllEndDir
$LN158@HllEndDir:

; 2051 :           else {
; 2052 :             AddLineQueueX("mov  rsi,rax");

	lea	rcx, OFFSET FLAT:$SG12247
	call	AddLineQueueX

; 2053 :             AddLineQueueX("mov  rbx,%q", hll->casecnt - 1);//int high = len - 1;

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	dec	eax
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12248
	call	AddLineQueueX

; 2054 :             AddLineQueueX("xor  ecx,ecx");//int low = 0;

	lea	rcx, OFFSET FLAT:$SG12249
	call	AddLineQueueX

; 2055 :             AddLineQueueX("lea  rdi,%s", GetLabelStr(hll->labels[LDATA2], buff));//int hll->pcases

	mov	eax, 4
	imul	rax, rax, 7
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12250
	call	AddLineQueueX
$LN159@HllEndDir:

; 2056 :           }
; 2057 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN160@HllEndDir

; 2058 :             AddLineQueueX("js  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12253
	call	AddLineQueueX
	jmp	SHORT $LN161@HllEndDir
$LN160@HllEndDir:

; 2059 :           else
; 2060 :             AddLineQueueX("js  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12254
	call	AddLineQueueX
$LN161@HllEndDir:
$LN155@HllEndDir:
$LN153@HllEndDir:
$LN144@HllEndDir:
$LN134@HllEndDir:
$LN124@HllEndDir:
$LN115@HllEndDir:
$LN106@HllEndDir:
$LN97@HllEndDir:
$LN66@HllEndDir:

; 2061 :         }
; 2062 : #endif
; 2063 :       }
; 2064 :     } //end if Parse_Pass
; 2065 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTOP], buff));

	mov	eax, 4
	imul	rax, rax, 8
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12255
	call	AddLineQueueX

; 2066 :     if (Parse_Pass) {

	cmp	DWORD PTR Parse_Pass, 0
	je	$LN162@HllEndDir

; 2067 :       if (hll->cflag == 5) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 5
	jne	$LN163@HllEndDir

; 2068 :         if (ModuleInfo.Ofssize == USE32) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jne	$LN164@HllEndDir

; 2069 :           AddLineQueueX("lea     eax,[ecx + ebx]");//int eax = (ecx + ebx) / 2;

	lea	rcx, OFFSET FLAT:$SG12260
	call	AddLineQueueX

; 2070 :           AddLineQueueX("cdq");

	lea	rcx, OFFSET FLAT:$SG12261
	call	AddLineQueueX

; 2071 :           AddLineQueueX("sub     eax,edx");

	lea	rcx, OFFSET FLAT:$SG12262
	call	AddLineQueueX

; 2072 :           AddLineQueueX("sar     eax,1");

	lea	rcx, OFFSET FLAT:$SG12263
	call	AddLineQueueX

; 2073 :           AddLineQueueX("cmp     [edi+eax*4],esi");

	lea	rcx, OFFSET FLAT:$SG12264
	call	AddLineQueueX

; 2074 :           AddLineQueueX("je  %s", GetLabelStr(hll->labels[LJUMP], buff));//got it, jump to the case

	mov	eax, 4
	imul	rax, rax, 9
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12265
	call	AddLineQueueX

; 2075 :           AddLineQueueX("jge %s", GetLabelStr(hll->labels[LSKIP], buff));//else if (hll->pcases[mid] < hll->casecnt)

	mov	eax, 4
	imul	rax, rax, 3
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12266
	call	AddLineQueueX

; 2076 :           AddLineQueueX("lea     ecx,[eax+1]");                          //low = mid + 1

	lea	rcx, OFFSET FLAT:$SG12267
	call	AddLineQueueX

; 2077 :           AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LCONT], buff));//not found yet, continue search

	mov	eax, 4
	imul	rax, rax, 4
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12268
	call	AddLineQueueX

; 2078 :         }

	jmp	$LN165@HllEndDir
$LN164@HllEndDir:

; 2079 : #if AMD64_SUPPORT
; 2080 :         else {
; 2081 :           if (hll->csize == 4) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	$LN166@HllEndDir

; 2082 :             AddLineQueueX("lea     eax,[rcx + rbx]");//int eax = (ecx + ebx) / 2;

	lea	rcx, OFFSET FLAT:$SG12271
	call	AddLineQueueX

; 2083 :             AddLineQueueX("cdq");

	lea	rcx, OFFSET FLAT:$SG12272
	call	AddLineQueueX

; 2084 :             AddLineQueueX("sub     eax,edx");

	lea	rcx, OFFSET FLAT:$SG12273
	call	AddLineQueueX

; 2085 :             AddLineQueueX("sar     rax,1");

	lea	rcx, OFFSET FLAT:$SG12274
	call	AddLineQueueX

; 2086 :             AddLineQueueX("cmp     [rdi+rax*8],esi");

	lea	rcx, OFFSET FLAT:$SG12275
	call	AddLineQueueX

; 2087 :             AddLineQueueX("je  %s", GetLabelStr(hll->labels[LJUMP], buff));//got it, jump to the case

	mov	eax, 4
	imul	rax, rax, 9
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12276
	call	AddLineQueueX

; 2088 :             AddLineQueueX("jge %s", GetLabelStr(hll->labels[LSKIP], buff));//else if (hll->pcases[mid] < hll->casecnt)

	mov	eax, 4
	imul	rax, rax, 3
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12277
	call	AddLineQueueX

; 2089 :             AddLineQueueX("lea     ecx,[rax+1]");                          //low = mid + 1

	lea	rcx, OFFSET FLAT:$SG12278
	call	AddLineQueueX

; 2090 :             AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LCONT], buff));//not found yet, continue search

	mov	eax, 4
	imul	rax, rax, 4
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12279
	call	AddLineQueueX

; 2091 :           }

	jmp	$LN167@HllEndDir
$LN166@HllEndDir:

; 2092 :           else {
; 2093 :             AddLineQueueX("lea     rax,[rcx + rbx]");//int eax = (ecx + ebx) / 2;

	lea	rcx, OFFSET FLAT:$SG12280
	call	AddLineQueueX

; 2094 :             AddLineQueueX("cdq");

	lea	rcx, OFFSET FLAT:$SG12281
	call	AddLineQueueX

; 2095 :             AddLineQueueX("sub     rax,rdx");

	lea	rcx, OFFSET FLAT:$SG12282
	call	AddLineQueueX

; 2096 :             AddLineQueueX("sar     rax,1");

	lea	rcx, OFFSET FLAT:$SG12283
	call	AddLineQueueX

; 2097 :             AddLineQueueX("cmp     [rdi+rax*8],rsi");

	lea	rcx, OFFSET FLAT:$SG12284
	call	AddLineQueueX

; 2098 :             AddLineQueueX("je  %s", GetLabelStr(hll->labels[LJUMP], buff));//got it, jump to the case

	mov	eax, 4
	imul	rax, rax, 9
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12285
	call	AddLineQueueX

; 2099 :             AddLineQueueX("jge %s", GetLabelStr(hll->labels[LSKIP], buff));//else if (hll->pcases[mid] < hll->casecnt)

	mov	eax, 4
	imul	rax, rax, 3
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12286
	call	AddLineQueueX

; 2100 :             AddLineQueueX("lea     rcx,[rax+1]");                          //low = mid + 1

	lea	rcx, OFFSET FLAT:$SG12287
	call	AddLineQueueX

; 2101 :             AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LCONT], buff));//not found yet, continue search

	mov	eax, 4
	imul	rax, rax, 4
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12288
	call	AddLineQueueX
$LN167@HllEndDir:
$LN165@HllEndDir:
$LN163@HllEndDir:
$LN162@HllEndDir:

; 2102 :           }
; 2103 :         }
; 2104 : #endif
; 2105 :       }
; 2106 :     }
; 2107 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LJUMP], buff));

	mov	eax, 4
	imul	rax, rax, 9
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12289
	call	AddLineQueueX

; 2108 :     if (Parse_Pass) {

	cmp	DWORD PTR Parse_Pass, 0
	je	$LN168@HllEndDir

; 2109 :       if (hll->cflag == 5) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 5
	jne	$LN169@HllEndDir

; 2110 :         if (ModuleInfo.Ofssize == USE32) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jne	$LN170@HllEndDir

; 2111 :           GetLabelStr(hll->labels[LDATA1], buff);

	mov	eax, 4
	imul	rax, rax, 6
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr

; 2112 :           AddLineQueueX("pop	edi");

	lea	rcx, OFFSET FLAT:$SG12294
	call	AddLineQueueX

; 2113 :           AddLineQueueX("pop	esi");

	lea	rcx, OFFSET FLAT:$SG12295
	call	AddLineQueueX

; 2114 :           AddLineQueueX("pop	ebx");

	lea	rcx, OFFSET FLAT:$SG12296
	call	AddLineQueueX

; 2115 :           AddLineQueueX("pop	ecx");

	lea	rcx, OFFSET FLAT:$SG12297
	call	AddLineQueueX

; 2116 :           AddLineQueueX("pop	edx");

	lea	rcx, OFFSET FLAT:$SG12298
	call	AddLineQueueX

; 2117 :           AddLineQueueX("mov  eax,%s[%r*4]", buff, T_EAX);

	mov	r8d, 17
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12299
	call	AddLineQueueX

; 2118 :           AddLineQueueX("xchg	 eax,[esp]");

	lea	rcx, OFFSET FLAT:$SG12300
	call	AddLineQueueX

; 2119 :           AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG12301
	call	AddLineQueueX

; 2120 :         }

	jmp	$LN171@HllEndDir
$LN170@HllEndDir:

; 2121 : #if AMD64_SUPPORT
; 2122 :         else {
; 2123 :           AddLineQueueX("pop	rdi");

	lea	rcx, OFFSET FLAT:$SG12302
	call	AddLineQueueX

; 2124 :           AddLineQueueX("pop	rsi");

	lea	rcx, OFFSET FLAT:$SG12303
	call	AddLineQueueX

; 2125 :           AddLineQueueX("pop	rbx");

	lea	rcx, OFFSET FLAT:$SG12304
	call	AddLineQueueX

; 2126 :           AddLineQueueX("pop	rcx");

	lea	rcx, OFFSET FLAT:$SG12305
	call	AddLineQueueX

; 2127 :           GetLabelStr(hll->labels[LDATA1], buff);

	mov	eax, 4
	imul	rax, rax, 6
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr

; 2128 :           AddLineQueueX("lea   rdx,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG12306
	call	AddLineQueueX

; 2129 :           AddLineQueueX("mov   rax, qword ptr[rdx+rax*8]");

	lea	rcx, OFFSET FLAT:$SG12307
	call	AddLineQueueX

; 2130 :           AddLineQueueX("pop   rdx");

	lea	rcx, OFFSET FLAT:$SG12308
	call	AddLineQueueX

; 2131 :           AddLineQueueX("xchg	 rax,[rsp]");

	lea	rcx, OFFSET FLAT:$SG12309
	call	AddLineQueueX

; 2132 :           AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG12310
	call	AddLineQueueX
$LN171@HllEndDir:
$LN169@HllEndDir:
$LN168@HllEndDir:

; 2133 :         }
; 2134 : #endif
; 2135 :       }
; 2136 :     }
; 2137 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSKIP], buff));

	mov	eax, 4
	imul	rax, rax, 3
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12311
	call	AddLineQueueX

; 2138 :     if (Parse_Pass) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN172@HllEndDir

; 2139 :       if (hll->cflag == 5) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 5
	jne	SHORT $LN173@HllEndDir

; 2140 :         if (ModuleInfo.Ofssize == USE32)

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jne	SHORT $LN174@HllEndDir

; 2141 :           AddLineQueueX("lea     ebx,[eax-1]");//else high = mid - 1;

	lea	rcx, OFFSET FLAT:$SG12316
	call	AddLineQueueX
	jmp	SHORT $LN175@HllEndDir
$LN174@HllEndDir:

; 2142 : #if AMD64_SUPPORT
; 2143 :         else {
; 2144 :           if (hll->csize == 4)

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	SHORT $LN176@HllEndDir

; 2145 :             AddLineQueueX("lea     ebx,[rax-1]");//else high = mid - 1;

	lea	rcx, OFFSET FLAT:$SG12319
	call	AddLineQueueX
	jmp	SHORT $LN177@HllEndDir
$LN176@HllEndDir:

; 2146 :           else
; 2147 :             AddLineQueueX("lea     rbx,[rax-1]");//else high = mid - 1;

	lea	rcx, OFFSET FLAT:$SG12320
	call	AddLineQueueX
$LN177@HllEndDir:
$LN175@HllEndDir:
$LN173@HllEndDir:
$LN172@HllEndDir:

; 2148 :         }
; 2149 : #endif
; 2150 :       }
; 2151 :     }
; 2152 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LCONT], buff));

	mov	eax, 4
	imul	rax, rax, 4
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12321
	call	AddLineQueueX

; 2153 :     if (Parse_Pass) {

	cmp	DWORD PTR Parse_Pass, 0
	je	$LN178@HllEndDir

; 2154 :       if (hll->cflag == 5) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 5
	jne	$LN179@HllEndDir

; 2155 :         if (ModuleInfo.Ofssize == USE32) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jne	$LN180@HllEndDir

; 2156 :           AddLineQueueX("cmp  ecx,ebx");

	lea	rcx, OFFSET FLAT:$SG12326
	call	AddLineQueueX

; 2157 :           AddLineQueueX("jle %s", GetLabelStr(hll->labels[LTOP], buff));

	mov	eax, 4
	imul	rax, rax, 8
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12327
	call	AddLineQueueX

; 2158 :           AddLineQueueX("pop	edi");

	lea	rcx, OFFSET FLAT:$SG12328
	call	AddLineQueueX

; 2159 :           AddLineQueueX("pop	esi");

	lea	rcx, OFFSET FLAT:$SG12329
	call	AddLineQueueX

; 2160 :           AddLineQueueX("pop	ebx");

	lea	rcx, OFFSET FLAT:$SG12330
	call	AddLineQueueX

; 2161 :           AddLineQueueX("pop	ecx");

	lea	rcx, OFFSET FLAT:$SG12331
	call	AddLineQueueX

; 2162 :           AddLineQueueX("pop	edx");

	lea	rcx, OFFSET FLAT:$SG12332
	call	AddLineQueueX

; 2163 :           AddLineQueueX("pop	eax");

	lea	rcx, OFFSET FLAT:$SG12333
	call	AddLineQueueX

; 2164 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN182@HllEndDir

; 2165 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12336
	call	AddLineQueueX
	jmp	SHORT $LN183@HllEndDir
$LN182@HllEndDir:

; 2166 :           else
; 2167 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12337
	call	AddLineQueueX
$LN183@HllEndDir:

; 2168 :         }

	jmp	$LN181@HllEndDir
$LN180@HllEndDir:

; 2169 : #if AMD64_SUPPORT
; 2170 :         else
; 2171 :         {
; 2172 :           if (hll->csize == 4)

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	SHORT $LN184@HllEndDir

; 2173 :             AddLineQueueX("cmp  ecx,ebx");

	lea	rcx, OFFSET FLAT:$SG12340
	call	AddLineQueueX
	jmp	SHORT $LN185@HllEndDir
$LN184@HllEndDir:

; 2174 :           else
; 2175 :             AddLineQueueX("cmp  rcx,rbx");

	lea	rcx, OFFSET FLAT:$SG12341
	call	AddLineQueueX
$LN185@HllEndDir:

; 2176 :           AddLineQueueX("jle  %s", GetLabelStr(hll->labels[LTOP], buff));

	mov	eax, 4
	imul	rax, rax, 8
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12342
	call	AddLineQueueX

; 2177 :           AddLineQueueX("pop	rdi");

	lea	rcx, OFFSET FLAT:$SG12343
	call	AddLineQueueX

; 2178 :           AddLineQueueX("pop	rsi");

	lea	rcx, OFFSET FLAT:$SG12344
	call	AddLineQueueX

; 2179 :           AddLineQueueX("pop	rbx");

	lea	rcx, OFFSET FLAT:$SG12345
	call	AddLineQueueX

; 2180 :           AddLineQueueX("pop	rcx");

	lea	rcx, OFFSET FLAT:$SG12346
	call	AddLineQueueX

; 2181 :           AddLineQueueX("pop	rdx");

	lea	rcx, OFFSET FLAT:$SG12347
	call	AddLineQueueX

; 2182 :           AddLineQueueX("pop	rax");

	lea	rcx, OFFSET FLAT:$SG12348
	call	AddLineQueueX

; 2183 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN186@HllEndDir

; 2184 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12351
	call	AddLineQueueX
	jmp	SHORT $LN187@HllEndDir
$LN186@HllEndDir:

; 2185 :           else
; 2186 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12352
	call	AddLineQueueX
$LN187@HllEndDir:
$LN181@HllEndDir:
$LN179@HllEndDir:
$LN178@HllEndDir:

; 2187 :         }
; 2188 : #endif
; 2189 :       }
; 2190 :     }
; 2191 : 
; 2192 :     AddLineQueueX("ALIGN %d", dsize);

	mov	edx, DWORD PTR dsize$[rsp]
	lea	rcx, OFFSET FLAT:$SG12353
	call	AddLineQueueX

; 2193 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LDATA1], buff));

	mov	eax, 4
	imul	rax, rax, 6
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12354
	call	AddLineQueueX

; 2194 :     if (hll->cflag > 3) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 3
	jle	$LN188@HllEndDir

; 2195 :       if (ModuleInfo.Ofssize == USE32) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jne	$LN189@HllEndDir

; 2196 :         lbl = 0;

	xor	eax, eax
	mov	WORD PTR lbl$[rsp], ax

; 2197 :         if (hll->cflag == 4) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 4
	jne	$LN191@HllEndDir

; 2198 :           for (j = 0; j < hll->casecnt; j++) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN6@HllEndDir
$LN4@HllEndDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN6@HllEndDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	cmp	DWORD PTR j$[rsp], eax
	jae	SHORT $LN5@HllEndDir

; 2199 :             if (hll->plabels[j] != lbl) {

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	movzx	ecx, WORD PTR lbl$[rsp]
	cmp	eax, ecx
	je	SHORT $LN192@HllEndDir

; 2200 :               AddLineQueueX(" dd %s", GetLabelStr(hll->plabels[j], buff));

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12360
	call	AddLineQueueX

; 2201 :               acnt++;

	mov	eax, DWORD PTR acnt$[rsp]
	inc	eax
	mov	DWORD PTR acnt$[rsp], eax
$LN192@HllEndDir:

; 2202 :             }
; 2203 :             lbl = hll->plabels[j];

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	WORD PTR lbl$[rsp], ax

; 2204 :           }

	jmp	$LN4@HllEndDir
$LN5@HllEndDir:
$LN191@HllEndDir:

; 2205 :         }
; 2206 :         if (hll->cflag == 7) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 7
	jne	$LN193@HllEndDir

; 2207 :           for (j = 0; j < hll->casecnt; j++) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN9@HllEndDir
$LN7@HllEndDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN9@HllEndDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	cmp	DWORD PTR j$[rsp], eax
	jae	SHORT $LN8@HllEndDir

; 2208 :             if (hll->plabels[j] != lbl) {

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	movzx	ecx, WORD PTR lbl$[rsp]
	cmp	eax, ecx
	je	SHORT $LN195@HllEndDir

; 2209 :               AddLineQueueX(" dd %s", GetLabelStr(hll->plabels[j], buff));

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12364
	call	AddLineQueueX

; 2210 :               acnt++;

	mov	eax, DWORD PTR acnt$[rsp]
	inc	eax
	mov	DWORD PTR acnt$[rsp], eax
$LN195@HllEndDir:

; 2211 :             }
; 2212 :             lbl = hll->plabels[j];

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	WORD PTR lbl$[rsp], ax

; 2213 :           }

	jmp	$LN7@HllEndDir
$LN8@HllEndDir:

; 2214 :         }

	jmp	$LN194@HllEndDir
$LN193@HllEndDir:

; 2215 :         else if (hll->cflag == 5) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 5
	jne	SHORT $LN196@HllEndDir

; 2216 :           for (j = 0; j < hll->casecnt; j++)

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN12@HllEndDir
$LN10@HllEndDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN12@HllEndDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	cmp	DWORD PTR j$[rsp], eax
	jae	SHORT $LN11@HllEndDir

; 2217 :             AddLineQueueX(" dd %s", GetLabelStr(hll->plabels[j], buff));

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12367
	call	AddLineQueueX
	jmp	SHORT $LN10@HllEndDir
$LN11@HllEndDir:

; 2218 :         }

	jmp	$LN197@HllEndDir
$LN196@HllEndDir:

; 2219 :         else if (hll->cflag == 6) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 6
	jne	$LN198@HllEndDir

; 2220 :           for (j = 0, n = 0; j < hll->casecnt; j++) {

	mov	DWORD PTR j$[rsp], 0
	mov	DWORD PTR n$[rsp], 0
	jmp	SHORT $LN15@HllEndDir
$LN13@HllEndDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN15@HllEndDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	cmp	DWORD PTR j$[rsp], eax
	jae	$LN14@HllEndDir

; 2221 :             temp = hll->pcases[j] - hll->mincase;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	rdx, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rdx+92]
	mov	eax, DWORD PTR [rcx+rax*4]
	sub	eax, edx
	mov	DWORD PTR temp$[rsp], eax
$LN16@HllEndDir:

; 2222 :             while (n < temp) {

	mov	eax, DWORD PTR temp$[rsp]
	cmp	DWORD PTR n$[rsp], eax
	jge	SHORT $LN17@HllEndDir

; 2223 :               if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN199@HllEndDir

; 2224 :                 AddLineQueueX(" dd %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12371
	call	AddLineQueueX
	jmp	SHORT $LN200@HllEndDir
$LN199@HllEndDir:

; 2225 :               else
; 2226 :                 AddLineQueueX(" dd %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12372
	call	AddLineQueueX
$LN200@HllEndDir:

; 2227 :               n++;

	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax

; 2228 :             }

	jmp	SHORT $LN16@HllEndDir
$LN17@HllEndDir:

; 2229 :             AddLineQueueX(" dd %s", GetLabelStr(hll->plabels[j], buff));

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12373
	call	AddLineQueueX

; 2230 :             n++;

	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax

; 2231 :           }

	jmp	$LN13@HllEndDir
$LN14@HllEndDir:
$LN198@HllEndDir:
$LN197@HllEndDir:
$LN194@HllEndDir:

; 2232 :         }
; 2233 :         if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN201@HllEndDir

; 2234 :           AddLineQueueX(" dd %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12376
	call	AddLineQueueX
	jmp	SHORT $LN202@HllEndDir
$LN201@HllEndDir:

; 2235 :         else
; 2236 :           AddLineQueueX(" dd %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12377
	call	AddLineQueueX
$LN202@HllEndDir:

; 2237 :       }

	jmp	$LN190@HllEndDir
$LN189@HllEndDir:

; 2238 : #if AMD64_SUPPORT
; 2239 :       else {
; 2240 :         lbl = 0;

	xor	eax, eax
	mov	WORD PTR lbl$[rsp], ax

; 2241 :         if ((hll->cflag == 4)||(hll->cflag == 7)) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 4
	je	SHORT $LN205@HllEndDir
	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 7
	jne	$LN203@HllEndDir
$LN205@HllEndDir:

; 2242 :           for (j = 0; j < hll->casecnt; j++) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN20@HllEndDir
$LN18@HllEndDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN20@HllEndDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	cmp	DWORD PTR j$[rsp], eax
	jae	SHORT $LN19@HllEndDir

; 2243 :             if (hll->plabels[j] != lbl) {

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	movzx	ecx, WORD PTR lbl$[rsp]
	cmp	eax, ecx
	je	SHORT $LN206@HllEndDir

; 2244 :               AddLineQueueX(" dq %s", GetLabelStr(hll->plabels[j], buff));

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12382
	call	AddLineQueueX

; 2245 :               acnt++;

	mov	eax, DWORD PTR acnt$[rsp]
	inc	eax
	mov	DWORD PTR acnt$[rsp], eax
$LN206@HllEndDir:

; 2246 :             }
; 2247 :             lbl = hll->plabels[j];

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	WORD PTR lbl$[rsp], ax

; 2248 :           }

	jmp	$LN18@HllEndDir
$LN19@HllEndDir:

; 2249 :         }

	jmp	$LN204@HllEndDir
$LN203@HllEndDir:

; 2250 :         else if (hll->cflag == 5) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 5
	jne	SHORT $LN207@HllEndDir

; 2251 :           for (j = 0; j < hll->casecnt; j++)

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN23@HllEndDir
$LN21@HllEndDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN23@HllEndDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	cmp	DWORD PTR j$[rsp], eax
	jae	SHORT $LN22@HllEndDir

; 2252 :             AddLineQueueX(" dq %s", GetLabelStr(hll->plabels[j], buff));

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12385
	call	AddLineQueueX
	jmp	SHORT $LN21@HllEndDir
$LN22@HllEndDir:

; 2253 :         }

	jmp	$LN208@HllEndDir
$LN207@HllEndDir:

; 2254 :         else if (hll->cflag == 6) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 6
	jne	$LN209@HllEndDir

; 2255 :           for (j = 0, n = 0; j < hll->casecnt; j++) {

	mov	DWORD PTR j$[rsp], 0
	mov	DWORD PTR n$[rsp], 0
	jmp	SHORT $LN26@HllEndDir
$LN24@HllEndDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN26@HllEndDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	cmp	DWORD PTR j$[rsp], eax
	jae	$LN25@HllEndDir

; 2256 :             if (hll->csize == 4)

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	SHORT $LN210@HllEndDir

; 2257 :               temp = hll->pcases[j] - hll->mincase;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	rdx, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rdx+92]
	mov	eax, DWORD PTR [rcx+rax*4]
	sub	eax, edx
	mov	DWORD PTR temp$[rsp], eax
	jmp	SHORT $LN211@HllEndDir
$LN210@HllEndDir:

; 2258 :             else
; 2259 :               temp = hll->pcases64[j] - hll->mincase64;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+152]
	mov	rdx, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rdx+136]
	mov	rax, QWORD PTR [rcx+rax*8]
	sub	rax, rdx
	mov	DWORD PTR temp$[rsp], eax
$LN211@HllEndDir:
$LN27@HllEndDir:

; 2260 :             while (n < temp) {

	mov	eax, DWORD PTR temp$[rsp]
	cmp	DWORD PTR n$[rsp], eax
	jge	SHORT $LN28@HllEndDir

; 2261 :               if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN212@HllEndDir

; 2262 :                 AddLineQueueX(" dq %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12391
	call	AddLineQueueX
	jmp	SHORT $LN213@HllEndDir
$LN212@HllEndDir:

; 2263 :               else
; 2264 :                 AddLineQueueX(" dq %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12392
	call	AddLineQueueX
$LN213@HllEndDir:

; 2265 :               n++;

	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax

; 2266 :             }

	jmp	SHORT $LN27@HllEndDir
$LN28@HllEndDir:

; 2267 :             AddLineQueueX(" dq %s", GetLabelStr(hll->plabels[j], buff));

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	lea	rdx, QWORD PTR buff$[rsp]
	mov	ecx, eax
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12393
	call	AddLineQueueX

; 2268 :             n++;

	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax

; 2269 :           }

	jmp	$LN24@HllEndDir
$LN25@HllEndDir:
$LN209@HllEndDir:
$LN208@HllEndDir:
$LN204@HllEndDir:

; 2270 :         }
; 2271 :         if (hll->flags & HLLF_DEFAULTOCCURED)

	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+76]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN214@HllEndDir

; 2272 :           AddLineQueueX(" dq %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	eax, 4
	imul	rax, rax, 5
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12396
	call	AddLineQueueX
	jmp	SHORT $LN215@HllEndDir
$LN214@HllEndDir:

; 2273 :         else
; 2274 :           AddLineQueueX(" dq %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12397
	call	AddLineQueueX
$LN215@HllEndDir:
$LN190@HllEndDir:
$LN188@HllEndDir:

; 2275 :       }
; 2276 : #endif
; 2277 :     }
; 2278 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LDATA2], buff));

	mov	eax, 4
	imul	rax, rax, 7
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12398
	call	AddLineQueueX

; 2279 :     if (hll->cflag == 4) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 4
	jne	$LN216@HllEndDir

; 2280 :       n = 0;

	mov	DWORD PTR n$[rsp], 0

; 2281 :       if (hll->csize == 4) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	$LN217@HllEndDir

; 2282 :         for (j = 0; j < hll->casecnt; j++) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN31@HllEndDir
$LN29@HllEndDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN31@HllEndDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	cmp	DWORD PTR j$[rsp], eax
	jae	$LN30@HllEndDir

; 2283 :           temp = hll->pcases[j] - hll->mincase;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	rdx, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rdx+92]
	mov	eax, DWORD PTR [rcx+rax*4]
	sub	eax, edx
	mov	DWORD PTR temp$[rsp], eax
$LN32@HllEndDir:

; 2284 :           while (n < temp) {

	mov	eax, DWORD PTR temp$[rsp]
	cmp	DWORD PTR n$[rsp], eax
	jge	SHORT $LN33@HllEndDir

; 2285 :             AddLineQueueX(" db %d", (int_8)acnt);

	movsx	eax, BYTE PTR acnt$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12402
	call	AddLineQueueX

; 2286 :             n++;

	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax

; 2287 :           }

	jmp	SHORT $LN32@HllEndDir
$LN33@HllEndDir:

; 2288 :           AddLineQueueX(" db %d", (int_8)bcnt);

	movsx	eax, BYTE PTR bcnt$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12403
	call	AddLineQueueX

; 2289 :           n++;

	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax

; 2290 :           if (hll->plabels[j] != hll->plabels[j + 1])

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	ecx, DWORD PTR j$[rsp]
	inc	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rdx+112]
	movzx	ecx, WORD PTR [rdx+rcx*2]
	cmp	eax, ecx
	je	SHORT $LN219@HllEndDir

; 2291 :             bcnt++;

	mov	eax, DWORD PTR bcnt$[rsp]
	inc	eax
	mov	DWORD PTR bcnt$[rsp], eax
$LN219@HllEndDir:

; 2292 :         }

	jmp	$LN29@HllEndDir
$LN30@HllEndDir:

; 2293 :       }

	jmp	$LN218@HllEndDir
$LN217@HllEndDir:

; 2294 : #if AMD64_SUPPORT
; 2295 :       else {
; 2296 :         n = 0;

	mov	DWORD PTR n$[rsp], 0

; 2297 :         for (j = 0; j < hll->casecnt; j++) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN36@HllEndDir
$LN34@HllEndDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN36@HllEndDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	cmp	DWORD PTR j$[rsp], eax
	jae	$LN35@HllEndDir

; 2298 :           temp = (int)hll->pcases64[j] - hll->mincase64;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+152]
	movsxd	rax, DWORD PTR [rcx+rax*8]
	mov	rcx, QWORD PTR hll$[rsp]
	sub	rax, QWORD PTR [rcx+136]
	mov	DWORD PTR temp$[rsp], eax
$LN37@HllEndDir:

; 2299 :           while (n < temp) {

	mov	eax, DWORD PTR temp$[rsp]
	cmp	DWORD PTR n$[rsp], eax
	jge	SHORT $LN38@HllEndDir

; 2300 :             AddLineQueueX(" db %d", (int_8)acnt);

	movsx	eax, BYTE PTR acnt$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12405
	call	AddLineQueueX

; 2301 :             n++;

	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax

; 2302 :           }

	jmp	SHORT $LN37@HllEndDir
$LN38@HllEndDir:

; 2303 :           AddLineQueueX(" db %d", (int_8)bcnt);

	movsx	eax, BYTE PTR bcnt$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12406
	call	AddLineQueueX

; 2304 :           n++;

	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax

; 2305 :           if (hll->plabels[j] != hll->plabels[j + 1]) bcnt++;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	ecx, DWORD PTR j$[rsp]
	inc	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rdx+112]
	movzx	ecx, WORD PTR [rdx+rcx*2]
	cmp	eax, ecx
	je	SHORT $LN220@HllEndDir
	mov	eax, DWORD PTR bcnt$[rsp]
	inc	eax
	mov	DWORD PTR bcnt$[rsp], eax
$LN220@HllEndDir:

; 2306 :         }

	jmp	$LN34@HllEndDir
$LN35@HllEndDir:
$LN218@HllEndDir:
$LN216@HllEndDir:

; 2307 :       }
; 2308 : #endif
; 2309 :     }
; 2310 : 
; 2311 :     if (hll->cflag == 7) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 7
	jne	$LN221@HllEndDir

; 2312 :       n = 0;

	mov	DWORD PTR n$[rsp], 0

; 2313 :       if (hll->csize == 4) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	$LN222@HllEndDir

; 2314 :         for (j = 0; j < hll->casecnt; j++) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN41@HllEndDir
$LN39@HllEndDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN41@HllEndDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	cmp	DWORD PTR j$[rsp], eax
	jae	$LN40@HllEndDir

; 2315 :           temp = hll->pcases[j] - hll->mincase;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	rdx, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rdx+92]
	mov	eax, DWORD PTR [rcx+rax*4]
	sub	eax, edx
	mov	DWORD PTR temp$[rsp], eax
$LN42@HllEndDir:

; 2316 :           while (n < (temp * 2)) {

	mov	eax, DWORD PTR temp$[rsp]
	shl	eax, 1
	cmp	DWORD PTR n$[rsp], eax
	jge	SHORT $LN43@HllEndDir

; 2317 :             AddLineQueueX(" dw %d", (int_16)acnt);

	movsx	eax, WORD PTR acnt$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12411
	call	AddLineQueueX

; 2318 :             n += 2;

	mov	eax, DWORD PTR n$[rsp]
	add	eax, 2
	mov	DWORD PTR n$[rsp], eax

; 2319 :           }

	jmp	SHORT $LN42@HllEndDir
$LN43@HllEndDir:

; 2320 :           AddLineQueueX(" dw %d", (int_16)bcnt);

	movsx	eax, WORD PTR bcnt$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12412
	call	AddLineQueueX

; 2321 :           n += 2;

	mov	eax, DWORD PTR n$[rsp]
	add	eax, 2
	mov	DWORD PTR n$[rsp], eax

; 2322 :           if (hll->plabels[j] != hll->plabels[j + 1])

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	ecx, DWORD PTR j$[rsp]
	inc	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rdx+112]
	movzx	ecx, WORD PTR [rdx+rcx*2]
	cmp	eax, ecx
	je	SHORT $LN224@HllEndDir

; 2323 :             bcnt++;

	mov	eax, DWORD PTR bcnt$[rsp]
	inc	eax
	mov	DWORD PTR bcnt$[rsp], eax
$LN224@HllEndDir:

; 2324 :         }

	jmp	$LN39@HllEndDir
$LN40@HllEndDir:

; 2325 :       }

	jmp	$LN223@HllEndDir
$LN222@HllEndDir:

; 2326 : #if AMD64_SUPPORT
; 2327 :       else {
; 2328 :         n = 0;

	mov	DWORD PTR n$[rsp], 0

; 2329 :         for (j = 0; j < hll->casecnt; j++) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN46@HllEndDir
$LN44@HllEndDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN46@HllEndDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	cmp	DWORD PTR j$[rsp], eax
	jae	$LN45@HllEndDir

; 2330 :           temp = (int)hll->pcases64[j] - hll->mincase64;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+152]
	movsxd	rax, DWORD PTR [rcx+rax*8]
	mov	rcx, QWORD PTR hll$[rsp]
	sub	rax, QWORD PTR [rcx+136]
	mov	DWORD PTR temp$[rsp], eax
$LN47@HllEndDir:

; 2331 :           while (n < (temp * 2)) {

	mov	eax, DWORD PTR temp$[rsp]
	shl	eax, 1
	cmp	DWORD PTR n$[rsp], eax
	jge	SHORT $LN48@HllEndDir

; 2332 :             AddLineQueueX(" dw %d", (int_16)acnt);

	movsx	eax, WORD PTR acnt$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12414
	call	AddLineQueueX

; 2333 :             n += 2;

	mov	eax, DWORD PTR n$[rsp]
	add	eax, 2
	mov	DWORD PTR n$[rsp], eax

; 2334 :           }

	jmp	SHORT $LN47@HllEndDir
$LN48@HllEndDir:

; 2335 :           AddLineQueueX(" dw %d", (int_16)bcnt);

	movsx	eax, WORD PTR bcnt$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12415
	call	AddLineQueueX

; 2336 :           n += 2;

	mov	eax, DWORD PTR n$[rsp]
	add	eax, 2
	mov	DWORD PTR n$[rsp], eax

; 2337 :           if (hll->plabels[j] != hll->plabels[j + 1]) bcnt++;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	ecx, DWORD PTR j$[rsp]
	inc	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR [rdx+112]
	movzx	ecx, WORD PTR [rdx+rcx*2]
	cmp	eax, ecx
	je	SHORT $LN225@HllEndDir
	mov	eax, DWORD PTR bcnt$[rsp]
	inc	eax
	mov	DWORD PTR bcnt$[rsp], eax
$LN225@HllEndDir:

; 2338 :         }

	jmp	$LN44@HllEndDir
$LN45@HllEndDir:
$LN223@HllEndDir:
$LN221@HllEndDir:

; 2339 :       }
; 2340 : #endif
; 2341 :     }
; 2342 : 
; 2343 :     if (hll->cflag == 5) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+85]
	cmp	eax, 5
	jne	$LN226@HllEndDir

; 2344 :       if (hll->csize == 4) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]
	cmp	eax, 4
	jne	SHORT $LN227@HllEndDir

; 2345 :         for (j = 0; j < hll->casecnt; j++)

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN51@HllEndDir
$LN49@HllEndDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN51@HllEndDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	cmp	DWORD PTR j$[rsp], eax
	jae	SHORT $LN50@HllEndDir

; 2346 :           AddLineQueueX(" dd %d", hll->pcases[j]);

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG12420
	call	AddLineQueueX
	jmp	SHORT $LN49@HllEndDir
$LN50@HllEndDir:

; 2347 :       }

	jmp	SHORT $LN228@HllEndDir
$LN227@HllEndDir:

; 2348 : #if AMD64_SUPPORT
; 2349 :       else {
; 2350 :         for (j = 0; j < hll->casecnt; j++)

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN54@HllEndDir
$LN52@HllEndDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN54@HllEndDir:
	mov	rax, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rax+80]
	cmp	DWORD PTR j$[rsp], eax
	jae	SHORT $LN53@HllEndDir

; 2351 :           AddLineQueueX(" dq %q", hll->pcases64[j]);

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+152]
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, OFFSET FLAT:$SG12421
	call	AddLineQueueX
	jmp	SHORT $LN52@HllEndDir
$LN53@HllEndDir:
$LN228@HllEndDir:
$LN226@HllEndDir:

; 2352 :       }
; 2353 : #endif
; 2354 :     }
; 2355 :     if (hll->csize == 4) {

	mov	rax, QWORD PTR hll$[rsp]
	movsx	eax, BYTE PTR [rax+84]

; 2356 :       LclFree(hll->pcases);
; 2357 :     }
; 2358 : #if AMD64_SUPPORT
; 2359 :     else
; 2360 :       LclFree(hll->pcases64);
; 2361 : #endif
; 2362 :     LclFree(hll->plabels);
; 2363 :     break;

	jmp	$LN2@HllEndDir
$LN231@HllEndDir:

; 2364 :   case T_DOT_ENDFOR:
; 2365 :     if (hll->cmd != HLL_FOR) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+68], 4
	je	SHORT $LN232@HllEndDir

; 2366 :       DebugMsg(("HllEndDir: no .FOR on the hll stack\n"));

	lea	rcx, OFFSET FLAT:$SG12426
	call	DoDebugMsg

; 2367 :       EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 80					; 00000050H
	call	EmitErr

; 2368 :       return(ERROR);

	mov	eax, -1
	jmp	$LN1@HllEndDir
$LN232@HllEndDir:

; 2369 :     }
; 2370 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 2371 :     //Insert .CONTINUE label here if there is any
; 2372 :     if (hll->labels[LCONT])

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN233@HllEndDir

; 2373 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LCONT], buff));

	mov	eax, 4
	imul	rax, rax, 4
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12428
	call	AddLineQueueX
$LN233@HllEndDir:

; 2374 :     //forever loop '.for (::)'
; 2375 :     if (hll->cmcnt == 0) goto adlabel;

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+64], 0
	jne	SHORT $LN234@HllEndDir
	jmp	$adlabel$265
	jmp	$LN235@HllEndDir
$LN234@HllEndDir:

; 2376 :     //If counters exist
; 2377 :     else if (hll->counterlines[0]) {

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN236@HllEndDir

; 2378 :       //here we write counters
; 2379 :       if (hll->counterlines) {      //if there is something after second ':' expand it here

	mov	rax, QWORD PTR hll$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN238@HllEndDir

; 2380 :         ForInitAndNext(tokenarray, hll->cmcnt, hll->counterlines);

	mov	rax, QWORD PTR hll$[rsp]
	mov	r8, QWORD PTR [rax+56]
	mov	rax, QWORD PTR hll$[rsp]
	mov	edx, DWORD PTR [rax+64]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	ForInitAndNext
$LN238@HllEndDir:

; 2381 :         LclFree(hll->counterlines);
; 2382 :       }
; 2383 :       //first jump from the top happens here after the counters
; 2384 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSKIP], buff));

	mov	eax, 4
	imul	rax, rax, 3
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12434
	call	AddLineQueueX

; 2385 :       /* create test label */
; 2386 :       if (hll->labels[LTEST]) {

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN239@HllEndDir

; 2387 :         AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	mov	eax, 4
	imul	rax, rax, 0
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12436
	call	AddLineQueueX
$LN239@HllEndDir:

; 2388 :       }
; 2389 :       QueueTestLines(hll->condlines);

	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rax+48]
	call	QueueTestLines

; 2390 :       LclFree(hll->condlines);
; 2391 :     }

	jmp	SHORT $LN237@HllEndDir
$LN236@HllEndDir:

; 2392 :     else
; 2393 :       AddLineQueueX(" jmp %s", GetLabelStr(hll->labels[LSTART], buff));

	mov	eax, 4
	imul	rax, rax, 2
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12437
	call	AddLineQueueX
$LN237@HllEndDir:
$LN235@HllEndDir:

; 2394 :     if (!hll->cond)

	mov	rax, QWORD PTR hll$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	test	eax, eax
	jne	SHORT $LN240@HllEndDir
$adlabel$265:

; 2395 :       adlabel:
; 2396 :     AddLineQueueX(" jmp %s", GetLabelStr(hll->labels[LSTART], buff));

	mov	eax, 4
	imul	rax, rax, 2
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12439
	call	AddLineQueueX
$LN240@HllEndDir:

; 2397 :     tokenarray[i].token = T_FINAL;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 2398 :     break;

	jmp	$LN2@HllEndDir
$LN241@HllEndDir:

; 2399 :     //end of .ENDFOR
; 2400 :   case T_DOT_ENDW:
; 2401 :     if (hll->cmd != HLL_WHILE) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+68], 1
	je	SHORT $LN242@HllEndDir

; 2402 :       DebugMsg(("HllEndDir: no .WHILE on the hll stack\n"));

	lea	rcx, OFFSET FLAT:$SG12442
	call	DoDebugMsg

; 2403 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 80					; 00000050H
	call	EmitErr
	jmp	$LN1@HllEndDir
$LN242@HllEndDir:

; 2404 :     }
; 2405 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 2406 :     /* create test label */
; 2407 :     if (hll->labels[LTEST]) {

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN243@HllEndDir

; 2408 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	mov	eax, 4
	imul	rax, rax, 0
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12444
	call	AddLineQueueX
$LN243@HllEndDir:

; 2409 :     }
; 2410 :     QueueTestLines(hll->condlines);

	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rax+48]
	call	QueueTestLines

; 2411 :     LclFree(hll->condlines);
; 2412 :     break;

	jmp	$LN2@HllEndDir
$LN244@HllEndDir:

; 2413 :   case T_DOT_UNTILCXZ:
; 2414 :     if (hll->cmd != HLL_REPEAT) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+68], 2
	je	SHORT $LN245@HllEndDir

; 2415 :       DebugMsg(("HllEndDir: no .REPEAT on the hll stack\n"));

	lea	rcx, OFFSET FLAT:$SG12447
	call	DoDebugMsg

; 2416 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 80					; 00000050H
	call	EmitErr
	jmp	$LN1@HllEndDir
$LN245@HllEndDir:

; 2417 :     }
; 2418 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 2419 :     if (hll->labels[LTEST]) /* v2.11: LTEST only needed if .CONTINUE has occured */

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN246@HllEndDir

; 2420 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	mov	eax, 4
	imul	rax, rax, 0
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12449
	call	AddLineQueueX
$LN246@HllEndDir:

; 2421 : 
; 2422 :     /* read in optional (simple) expression */
; 2423 :     if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN247@HllEndDir

; 2424 :       rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, FALSE, buffer);

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], 0
	mov	r9d, 2
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	EvaluateHllExpression
	mov	DWORD PTR rc$[rsp], eax

; 2425 :       if (rc == NOT_ERROR) {

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN249@HllEndDir

; 2426 :         rc = CheckCXZLines(buffer);

	lea	rcx, QWORD PTR buffer$[rsp]
	call	CheckCXZLines
	mov	DWORD PTR rc$[rsp], eax

; 2427 :         if (rc == NOT_ERROR)

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN250@HllEndDir

; 2428 :           QueueTestLines(buffer); /* write condition lines */

	lea	rcx, QWORD PTR buffer$[rsp]
	call	QueueTestLines
	jmp	SHORT $LN251@HllEndDir
$LN250@HllEndDir:

; 2429 :         else
; 2430 :           EmitError(EXPR_TOO_COMPLEX_FOR_UNTILCXZ);

	mov	ecx, 191				; 000000bfH
	call	EmitError
$LN251@HllEndDir:
$LN249@HllEndDir:

; 2431 :       }
; 2432 :     }

	jmp	SHORT $LN248@HllEndDir
$LN247@HllEndDir:

; 2433 :     else {
; 2434 :       AddLineQueueX(JMPPREFIX "loop %s", GetLabelStr(hll->labels[LSTART], buff));

	mov	eax, 4
	imul	rax, rax, 2
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12455
	call	AddLineQueueX
$LN248@HllEndDir:

; 2435 :     }
; 2436 :     break;

	jmp	$LN2@HllEndDir
$LN252@HllEndDir:

; 2437 :   case T_DOT_UNTIL:
; 2438 :     if (hll->cmd != HLL_REPEAT) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+68], 2
	je	SHORT $LN253@HllEndDir

; 2439 :       DebugMsg(("HllEndDir: no .REPEAT on the hll stack\n"));

	lea	rcx, OFFSET FLAT:$SG12458
	call	DoDebugMsg

; 2440 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 80					; 00000050H
	call	EmitErr
	jmp	$LN1@HllEndDir
$LN253@HllEndDir:

; 2441 :     }
; 2442 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 2443 :     if (hll->labels[LTEST]) /* v2.11: LTEST only needed if .CONTINUE has occured */

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN254@HllEndDir

; 2444 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	mov	eax, 4
	imul	rax, rax, 0
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12460
	call	AddLineQueueX
$LN254@HllEndDir:

; 2445 : 
; 2446 :     /* read in (optional) expression */
; 2447 :     /* if expression is missing, just generate nothing */
; 2448 :     if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN255@HllEndDir

; 2449 :       rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, FALSE, buffer);

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], 0
	mov	r9d, 2
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	EvaluateHllExpression
	mov	DWORD PTR rc$[rsp], eax

; 2450 :       if (rc == NOT_ERROR)

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN256@HllEndDir

; 2451 :         QueueTestLines(buffer); /* write condition lines */

	lea	rcx, QWORD PTR buffer$[rsp]
	call	QueueTestLines
$LN256@HllEndDir:
$LN255@HllEndDir:

; 2452 :     }
; 2453 :     break;

	jmp	SHORT $LN2@HllEndDir
$LN257@HllEndDir:

; 2454 : #ifdef DEBUG_OUT
; 2455 :   default: /**/myassert(0); break;

	mov	edx, 2455				; 00000997H
	lea	rcx, OFFSET FLAT:$SG12464
	call	InternalError
$LN2@HllEndDir:

; 2456 : #endif
; 2457 :   }
; 2458 : 
; 2459 :   /* create the exit label if it has been referenced */
; 2460 :   if (hll->labels[LEXIT])

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax+8], 0
	je	SHORT $LN258@HllEndDir

; 2461 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LEXIT], buff));

	mov	eax, 4
	imul	rax, rax, 1
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG12466
	call	AddLineQueueX
$LN258@HllEndDir:

; 2462 : 
; 2463 :   if (tokenarray[i].token != T_FINAL && rc == NOT_ERROR) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN259@HllEndDir
	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN259@HllEndDir

; 2464 :     EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 2465 :     rc = ERROR;

	mov	DWORD PTR rc$[rsp], -1
$LN259@HllEndDir:

; 2466 :   }
; 2467 :   if (ModuleInfo.list)

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN260@HllEndDir

; 2468 :     LstWrite(LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL);

	call	GetCurrOffset
	xor	r8d, r8d
	mov	edx, eax
	mov	ecx, 4
	call	LstWrite
$LN260@HllEndDir:

; 2469 : 
; 2470 :   /* v2.11: always run line-queue if it's not empty. */
; 2471 :   if (is_linequeue_populated())

	cmp	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN261@HllEndDir

; 2472 :     RunLineQueue();

	call	RunLineQueue
$LN261@HllEndDir:

; 2473 : 
; 2474 :   return(rc);

	mov	eax, DWORD PTR rc$[rsp]
$LN1@HllEndDir:

; 2475 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 2184				; 00000888H
	ret	0
	npad	3
$LN263@HllEndDir:
	DD	$LN56@HllEndDir
	DD	$LN241@HllEndDir
	DD	$LN252@HllEndDir
	DD	$LN244@HllEndDir
	DD	$LN231@HllEndDir
	DD	$LN257@HllEndDir
	DD	$LN257@HllEndDir
	DD	$LN257@HllEndDir
	DD	$LN59@HllEndDir
HllEndDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
b$ = 48
hll$ = 56
c$ = 64
j$ = 68
rc$ = 72
size$ = 76
tv83 = 80
p$ = 88
eqcnt$ = 96
cmcnt$ = 100
size$1 = 104
t$ = 112
tv212 = 120
cmd$ = 124
$T2 = 128
$T3 = 136
$T4 = 144
$T5 = 152
$T6 = 160
$T7 = 168
$T8 = 176
$T9 = 184
$T10 = 192
opndx$ = 208
buff$ = 320
forbuff$ = 336
forbuffcnt$ = 1360
forbuffcond$ = 2384
forbuffinit$ = 3408
buffer$ = 4432
transformed$ = 6480
__$ArrayPad$ = 7504
i$ = 7536
tokenarray$ = 7544
HllStartDir PROC

; 1255 : {

$LN106:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	mov	eax, 7528				; 00001d68H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1256 :   struct hll_item      *hll;
; 1257 :   ret_code             rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 1258 :   int                  cmd = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR cmd$[rsp], eax

; 1259 :   char buff[16];
; 1260 :   char buffer[MAX_LINE_LEN * 2];
; 1261 :   char codebuff[256];
; 1262 :   char param[256];
; 1263 :   char init[256];
; 1264 :   char limit[MAX_LINE_LEN];
; 1265 :   char op[4];
; 1266 :   char forbuff[MAX_LINE_LEN];
; 1267 :   char forbuffinit[MAX_LINE_LEN];
; 1268 :   char forbuffcond[MAX_LINE_LEN];
; 1269 :   char forbuffcnt[MAX_LINE_LEN];
; 1270 :   char transformed[MAX_LINE_LEN];
; 1271 :   int a;
; 1272 :   int j;
; 1273 :   int b;
; 1274 :   int e;
; 1275 :   int size;
; 1276 :   int eqcnt;
; 1277 :   int cmcnt;
; 1278 :   char *p;
; 1279 :   char c;
; 1280 :   struct expr         opndx;
; 1281 :   struct asm_tok      *t;
; 1282 :   DebugMsg1(("HllStartDir(%s) enter\n", tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11760
	call	DoDebugMsg1

; 1283 : 
; 1284 :   i++; /* skip directive */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1285 : 
; 1286 :        /* v2.06: is there an item on the free stack? */
; 1287 :   if (HllFree) {

	cmp	QWORD PTR ModuleInfo+232, 0
	je	SHORT $LN18@HllStartDi

; 1288 :     hll = HllFree;

	mov	rax, QWORD PTR ModuleInfo+232
	mov	QWORD PTR hll$[rsp], rax

; 1289 :     DebugCmd(cntReused++);

	mov	eax, DWORD PTR cntReused
	inc	eax
	mov	DWORD PTR cntReused, eax

; 1290 :   }

	jmp	SHORT $LN19@HllStartDi
$LN18@HllStartDi:

; 1291 :   else {
; 1292 :     hll = LclAlloc(sizeof(struct hll_item));

	mov	ecx, 160				; 000000a0H
	call	LclAlloc
	mov	QWORD PTR hll$[rsp], rax

; 1293 :     DebugCmd(cntAlloc++);

	mov	eax, DWORD PTR cntAlloc
	inc	eax
	mov	DWORD PTR cntAlloc, eax
$LN19@HllStartDi:

; 1294 :   }
; 1295 : 
; 1296 :   /* structure for .IF .ELSE .ENDIF
; 1297 :   *    cond jump to LTEST-label
; 1298 :   *    ...
; 1299 :   *    jmp LEXIT
; 1300 :   *  LTEST:
; 1301 :   *    ...
; 1302 :   *  LEXIT:
; 1303 : 
; 1304 :   * structure for .IF .ELSEIF
; 1305 :   *    cond jump to LTEST
; 1306 :   *    ...
; 1307 :   *    jmp LEXIT
; 1308 :   *  LTEST:
; 1309 :   *    cond jump to (new) LTEST
; 1310 :   *    ...
; 1311 :   *    jmp LEXIT
; 1312 :   *  LTEST:
; 1313 :   *    ...
; 1314 : 
; 1315 :   * structure for .WHILE and .REPEAT:
; 1316 :   *   jmp LTEST (for .WHILE only)
; 1317 :   * LSTART:
; 1318 :   *   ...
; 1319 :   * LTEST: (jumped to by .continue)
; 1320 :   *   a) test end condition, cond jump to LSTART label
; 1321 :   *   b) unconditional jump to LSTART label
; 1322 :   * LEXIT: (jumped to by .BREAK)
; 1323 :   */
; 1324 : 
; 1325 :   hll->labels[LEXIT] = 0;

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0

; 1326 : 
; 1327 :   switch (cmd) {

	mov	eax, DWORD PTR cmd$[rsp]
	mov	DWORD PTR tv83[rsp], eax
	cmp	DWORD PTR tv83[rsp], 328		; 00000148H
	je	SHORT $LN20@HllStartDi
	cmp	DWORD PTR tv83[rsp], 328		; 00000148H
	jle	$LN82@HllStartDi
	cmp	DWORD PTR tv83[rsp], 330		; 0000014aH
	jle	$LN75@HllStartDi
	cmp	DWORD PTR tv83[rsp], 331		; 0000014bH
	je	$LN51@HllStartDi
	cmp	DWORD PTR tv83[rsp], 341		; 00000155H
	je	$LN23@HllStartDi
	jmp	$LN82@HllStartDi
$LN20@HllStartDi:

; 1328 :   case T_DOT_IF:
; 1329 :     hll->labels[LSTART] = 0; /* not used by .IF */

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0

; 1330 :     hll->labels[LTEST] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1331 :     hll->cmd = HLL_IF;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+68], 0

; 1332 :     hll->flags = 0;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+76], 0

; 1333 :     /* get the C-style expression, convert to ASM code lines */
; 1334 :     rc = EvaluateHllExpression(hll, &i, tokenarray, LTEST, FALSE, buffer);

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	EvaluateHllExpression
	mov	DWORD PTR rc$[rsp], eax

; 1335 :     if (rc == NOT_ERROR) {

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN21@HllStartDi

; 1336 :       QueueTestLines(buffer);

	lea	rcx, QWORD PTR buffer$[rsp]
	call	QueueTestLines

; 1337 :       /* if no lines have been created, the LTEST label isn't needed */
; 1338 :       //if ( !is_linequeue_populated() ) {
; 1339 :       if (buffer[0] == NULLC) {

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR buffer$[rsp+rax]
	test	eax, eax
	jne	SHORT $LN22@HllStartDi

; 1340 :         hll->labels[LTEST] = 0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0
$LN22@HllStartDi:
$LN21@HllStartDi:

; 1341 :       }
; 1342 :     }
; 1343 :     break;

	jmp	$LN2@HllStartDi
$LN23@HllStartDi:

; 1344 :     // added by habran
; 1345 :   case T_DOT_SWITCH:
; 1346 :     hll->cmd = HLL_SWITCH;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+68], 5

; 1347 :     hll->flags = HLLF_WHILE;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+76], 4

; 1348 :     hll->labels[LSKIP] = GetHllLabel();   /* used by .ENDSWITCH */

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1349 :     hll->labels[LJUMP] = GetHllLabel();   /* used by .ENDSWITCH */

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1350 :     hll->labels[LEXIT] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1351 :     hll->labels[LDATA1] = GetHllLabel();   /* used by .ENDSWITCH */

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1352 :     hll->labels[LSTART] = GetHllLabel();   /* used by .CASE      */

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1353 :     hll->labels[LTEST] = 0;               /* used by .CASE      */

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0

; 1354 :     hll->labels[LDEF] = 0;   /* used by .DEFAULT   */

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0

; 1355 :     hll->labels[LDATA2] = GetHllLabel();   /* used by .ENDSWITCH */

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1356 :     hll->labels[LTOP] = GetHllLabel();   /* used by .ENDSWITCH */

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1357 :     hll->labels[LCONT] = GetHllLabel();   /* used by .ENDSWITCH */

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1358 :     hll->maxalloccasen = 0;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+100], 0

; 1359 :     hll->casecnt = 0;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+80], 0

; 1360 :     hll->csize = 4;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+84], 4

; 1361 :     hll->breakoccured = TRUE; //first label for .CASE hast to be set

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+122], 1

; 1362 : 
; 1363 :     if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN24@HllStartDi

; 1364 :       DebugMsg1(("HllStartDir(%s): calling EvalOperand, i=%u\n", tokenarray[i].string_ptr, i));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	r8d, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11769
	call	DoDebugMsg1

; 1365 :       if (EvalOperand(&i, tokenarray, Token_Count, &opndx, 0) == ERROR) {

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN26@HllStartDi

; 1366 :         DebugMsg(("HllStartDir(%s): EvalOperand() failed\n", tokenarray[i].string_ptr));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11771
	call	DoDebugMsg

; 1367 :         return(ERROR);

	mov	eax, -1
	jmp	$LN1@HllStartDi
$LN26@HllStartDi:

; 1368 :       }
; 1369 :       i--; //EvalOperand increases i, decrease it to point to proper tokenarray[i].tokpos

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax

; 1370 :       switch (opndx.kind) {

	mov	eax, DWORD PTR opndx$[rsp+60]
	mov	DWORD PTR tv212[rsp], eax
	cmp	DWORD PTR tv212[rsp], 1
	je	$LN40@HllStartDi
	cmp	DWORD PTR tv212[rsp], 2
	je	SHORT $LN27@HllStartDi
	jmp	$LN4@HllStartDi
$LN27@HllStartDi:

; 1371 :       case EXPR_REG:
; 1372 :         t = opndx.base_reg;

	mov	rax, QWORD PTR opndx$[rsp+24]
	mov	QWORD PTR t$[rsp], rax

; 1373 :         if (ModuleInfo.Ofssize == USE32) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jne	SHORT $LN28@HllStartDi

; 1374 :           if (t->tokval <= T_BX)   // AL, CL, DL, BL, AH, CH, DH, BH, AX, CX, DX, BX

	mov	rax, QWORD PTR t$[rsp]
	cmp	DWORD PTR [rax+16], 12
	ja	SHORT $LN30@HllStartDi

; 1375 :             AddLineQueueX(" movzx eax, %s", tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11777
	call	AddLineQueueX
	jmp	SHORT $LN31@HllStartDi
$LN30@HllStartDi:

; 1376 :           else {
; 1377 :             if (t->tokval != T_EAX) //skip it, no need to write MOV EAX,EAX

	mov	rax, QWORD PTR t$[rsp]
	cmp	DWORD PTR [rax+16], 17
	je	SHORT $LN32@HllStartDi

; 1378 :               AddLineQueueX(" mov eax, %s", tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11779
	call	AddLineQueueX
$LN32@HllStartDi:
$LN31@HllStartDi:

; 1379 :           }
; 1380 :         }

	jmp	$LN29@HllStartDi
$LN28@HllStartDi:

; 1381 : #if AMD64_SUPPORT
; 1382 :         else             //USE64
; 1383 :         {
; 1384 :           if ((t->tokval <= T_EAX))

	mov	rax, QWORD PTR t$[rsp]
	cmp	DWORD PTR [rax+16], 17
	ja	SHORT $LN33@HllStartDi

; 1385 :             ; //skip it, no need to write MOV EAX,EAX

	jmp	$LN34@HllStartDi
$LN33@HllStartDi:

; 1386 :           else if (t->tokval <= T_BX) // AL, CL, DL, BL, AH, CH, DH, BH, AX, CX, DX, BX

	mov	rax, QWORD PTR t$[rsp]
	cmp	DWORD PTR [rax+16], 12
	ja	SHORT $LN35@HllStartDi

; 1387 :             AddLineQueueX(" movzx eax, %s", tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11784
	call	AddLineQueueX
	jmp	SHORT $LN36@HllStartDi
$LN35@HllStartDi:

; 1388 :           else if (t->tokval <= T_EDI) //EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI

	mov	rax, QWORD PTR t$[rsp]
	cmp	DWORD PTR [rax+16], 24
	ja	SHORT $LN37@HllStartDi

; 1389 :             AddLineQueueX(" mov eax, %s", tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11787
	call	AddLineQueueX
	jmp	SHORT $LN38@HllStartDi
$LN37@HllStartDi:

; 1390 :           else {
; 1391 :             if (t->tokval != T_RAX) //skip it, no need to write MOV RAX,RAX

	mov	rax, QWORD PTR t$[rsp]
	cmp	DWORD PTR [rax+16], 115			; 00000073H
	je	SHORT $LN39@HllStartDi

; 1392 :               AddLineQueueX(" mov rax, %s", tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11789
	call	AddLineQueueX
$LN39@HllStartDi:

; 1393 :             hll->csize = 8;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+84], 8
$LN38@HllStartDi:
$LN36@HllStartDi:
$LN34@HllStartDi:
$LN29@HllStartDi:

; 1394 :           }
; 1395 :         }               //end USE64
; 1396 : #endif
; 1397 :         break;

	jmp	$LN4@HllStartDi
$LN40@HllStartDi:

; 1398 :       case EXPR_ADDR:
; 1399 :         if (ModuleInfo.Ofssize == USE32) {

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	eax, 1
	jne	SHORT $LN41@HllStartDi

; 1400 :           if (opndx.mem_type == MT_BYTE || opndx.mem_type == MT_WORD)

	cmp	DWORD PTR opndx$[rsp+64], 0
	je	SHORT $LN45@HllStartDi
	cmp	DWORD PTR opndx$[rsp+64], 1
	jne	SHORT $LN43@HllStartDi
$LN45@HllStartDi:

; 1401 :             AddLineQueueX(" movzx eax, %s", tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11796
	call	AddLineQueueX
	jmp	SHORT $LN44@HllStartDi
$LN43@HllStartDi:

; 1402 :           else
; 1403 :             AddLineQueueX(" mov eax, %s", tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11797
	call	AddLineQueueX
$LN44@HllStartDi:

; 1404 :         }

	jmp	$LN42@HllStartDi
$LN41@HllStartDi:

; 1405 : #if AMD64_SUPPORT
; 1406 :         else             //USE64
; 1407 :         {
; 1408 :           if (opndx.mem_type == MT_BYTE || opndx.mem_type == MT_WORD)

	cmp	DWORD PTR opndx$[rsp+64], 0
	je	SHORT $LN48@HllStartDi
	cmp	DWORD PTR opndx$[rsp+64], 1
	jne	SHORT $LN46@HllStartDi
$LN48@HllStartDi:

; 1409 :             AddLineQueueX(" movzx eax, %s", tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11801
	call	AddLineQueueX
	jmp	SHORT $LN47@HllStartDi
$LN46@HllStartDi:

; 1410 :           else if (opndx.mem_type == MT_DWORD)

	cmp	DWORD PTR opndx$[rsp+64], 3
	jne	SHORT $LN49@HllStartDi

; 1411 :             AddLineQueueX(" mov eax, %s", tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11804
	call	AddLineQueueX
	jmp	SHORT $LN50@HllStartDi
$LN49@HllStartDi:

; 1412 :           else {
; 1413 :             AddLineQueueX(" mov rax, %s", tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11805
	call	AddLineQueueX

; 1414 :             hll->csize = 8;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+84], 8
$LN50@HllStartDi:
$LN47@HllStartDi:
$LN42@HllStartDi:
$LN4@HllStartDi:

; 1415 :           }
; 1416 :         }                //end USE64
; 1417 : #endif
; 1418 :         break;
; 1419 :       }
; 1420 :     }

	jmp	SHORT $LN25@HllStartDi
$LN24@HllStartDi:

; 1421 :     else {
; 1422 :       DebugMsg(("HllExitDir stack error\n"));

	lea	rcx, OFFSET FLAT:$SG11806
	call	DoDebugMsg

; 1423 :       return(EmitError(MISSING_OPERATOR_IN_EXPRESSION));

	mov	ecx, 150				; 00000096H
	call	EmitError
	jmp	$LN1@HllStartDi
$LN25@HllStartDi:

; 1424 :     }
; 1425 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1426 :     AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[LSTART], buff));

	mov	eax, 4
	imul	rax, rax, 2
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11807
	call	AddLineQueueX

; 1427 :     break;

	jmp	$LN2@HllStartDi
$LN51@HllStartDi:

; 1428 :   case T_DOT_FOR:
; 1429 :     /* create the label to loop start */
; 1430 :     hll->labels[LSTART] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1431 :     hll->labels[LSKIP] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1432 :     hll->labels[LCONT] = 0;

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0

; 1433 :     hll->labels[LTEST] = 0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0

; 1434 :     hll->flags = 0;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+76], 0

; 1435 :     hll->cmd = HLL_FOR;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+68], 4

; 1436 :     //copy string to the buffer and get read of spaces
; 1437 :     p = tokenarray[i].tokpos;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR p$[rsp], rax

; 1438 :     for (b = 0; *p; p++)

	mov	DWORD PTR b$[rsp], 0
	jmp	SHORT $LN8@HllStartDi
$LN6@HllStartDi:
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN8@HllStartDi:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN7@HllStartDi

; 1439 :     {
; 1440 :       if ((*p == ' ') || (*p == '\t')) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN54@HllStartDi
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 9
	jne	SHORT $LN52@HllStartDi
$LN54@HllStartDi:

; 1441 :         //if there is QWORD PTR, DWORD PTR, WORD PTR, BYTE PTR, OFFSET or ADDR leave a space between
; 1442 :         c = tolower(*(p + 1));

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	mov	ecx, eax
	call	tolower
	mov	BYTE PTR c$[rsp], al

; 1443 :         if ((c >= 'a') && (c <= 'z')) {

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN55@HllStartDi
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 122				; 0000007aH
	jg	SHORT $LN55@HllStartDi

; 1444 :           forbuff[b] = *p;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR forbuff$[rsp+rax], cl

; 1445 :           b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax
$LN55@HllStartDi:

; 1446 :         }
; 1447 :       }

	jmp	SHORT $LN53@HllStartDi
$LN52@HllStartDi:

; 1448 :       else {
; 1449 :         forbuff[b] = *p;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR forbuff$[rsp+rax], cl

; 1450 :         b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax
$LN53@HllStartDi:

; 1451 :       }
; 1452 :     }

	jmp	$LN6@HllStartDi
$LN7@HllStartDi:

; 1453 :     forbuff[b] = NULLC;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 1024		; 00000400H
	jae	SHORT $LN88@HllStartDi
	jmp	SHORT $LN89@HllStartDi
$LN88@HllStartDi:
	call	__report_rangecheckfailure
$LN89@HllStartDi:
	mov	rax, QWORD PTR $T2[rsp]
	mov	BYTE PTR forbuff$[rsp+rax], 0

; 1454 :     if (0 == _memicmp(forbuff, "(::)", 4)) {

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11815
	lea	rcx, QWORD PTR forbuff$[rsp]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN56@HllStartDi

; 1455 :       hll->cmcnt = 0;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+64], 0

; 1456 :     }

	jmp	$LN57@HllStartDi
$LN56@HllStartDi:

; 1457 :     else {
; 1458 :       //count initializers
; 1459 :       eqcnt = 1;

	mov	DWORD PTR eqcnt$[rsp], 1

; 1460 :       forbuffinit[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	QWORD PTR $T3[rsp], rax
	cmp	QWORD PTR $T3[rsp], 1024		; 00000400H
	jae	SHORT $LN90@HllStartDi
	jmp	SHORT $LN91@HllStartDi
$LN90@HllStartDi:
	call	__report_rangecheckfailure
$LN91@HllStartDi:
	mov	rax, QWORD PTR $T3[rsp]
	mov	BYTE PTR forbuffinit$[rsp+rax], 0

; 1461 :       for (j = 1, b = 0; forbuff[j];) {

	mov	DWORD PTR j$[rsp], 1
	mov	DWORD PTR b$[rsp], 0
$LN9@HllStartDi:
	movsxd	rax, DWORD PTR j$[rsp]
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	test	eax, eax
	je	$LN10@HllStartDi

; 1462 :         c = forbuff[j];

	movsxd	rax, DWORD PTR j$[rsp]
	movzx	eax, BYTE PTR forbuff$[rsp+rax]
	mov	BYTE PTR c$[rsp], al

; 1463 :         if (c == ':') {

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN58@HllStartDi

; 1464 :           if (forbuff[j - 1] != 39 && forbuff[j + 1] != 39) break;

	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	cdqe
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN59@HllStartDi
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	cdqe
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN59@HllStartDi
	jmp	$LN10@HllStartDi
$LN59@HllStartDi:
$LN58@HllStartDi:

; 1465 :         }
; 1466 :         if (c == ',' && forbuff[j - 1] != 39 && forbuff[j + 1] != 39) eqcnt++;

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN60@HllStartDi
	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	cdqe
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN60@HllStartDi
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	cdqe
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN60@HllStartDi
	mov	eax, DWORD PTR eqcnt$[rsp]
	inc	eax
	mov	DWORD PTR eqcnt$[rsp], eax
$LN60@HllStartDi:

; 1467 :         forbuffinit[b] = c;

	movsxd	rax, DWORD PTR b$[rsp]
	movzx	ecx, BYTE PTR c$[rsp]
	mov	BYTE PTR forbuffinit$[rsp+rax], cl

; 1468 :         if (c == 39 && forbuffinit[b - 2] == 39) {

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN61@HllStartDi
	mov	eax, DWORD PTR b$[rsp]
	sub	eax, 2
	cdqe
	movsx	eax, BYTE PTR forbuffinit$[rsp+rax]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN61@HllStartDi

; 1469 :           b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 1470 :           forbuffinit[b] = ' ';

	movsxd	rax, DWORD PTR b$[rsp]
	mov	BYTE PTR forbuffinit$[rsp+rax], 32	; 00000020H
$LN61@HllStartDi:

; 1471 :         }
; 1472 :         j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax

; 1473 :         b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 1474 :       }

	jmp	$LN9@HllStartDi
$LN10@HllStartDi:

; 1475 :       forbuffinit[b] = NULLC;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	QWORD PTR $T4[rsp], rax
	cmp	QWORD PTR $T4[rsp], 1024		; 00000400H
	jae	SHORT $LN92@HllStartDi
	jmp	SHORT $LN93@HllStartDi
$LN92@HllStartDi:
	call	__report_rangecheckfailure
$LN93@HllStartDi:
	mov	rax, QWORD PTR $T4[rsp]
	mov	BYTE PTR forbuffinit$[rsp+rax], 0

; 1476 :       j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax

; 1477 :       //coppy the condition to the buffer
; 1478 :       forbuffcond[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	QWORD PTR $T5[rsp], rax
	cmp	QWORD PTR $T5[rsp], 1024		; 00000400H
	jae	SHORT $LN94@HllStartDi
	jmp	SHORT $LN95@HllStartDi
$LN94@HllStartDi:
	call	__report_rangecheckfailure
$LN95@HllStartDi:
	mov	rax, QWORD PTR $T5[rsp]
	mov	BYTE PTR forbuffcond$[rsp+rax], 0

; 1479 :       hll->labels[LTEST] = 0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0

; 1480 :       for (b = 0; forbuff[j] && forbuff[j] != ':'; forbuffcond[b] = forbuff[j], j++, b++);

	mov	DWORD PTR b$[rsp], 0
	jmp	SHORT $LN14@HllStartDi
$LN12@HllStartDi:
	movsxd	rax, DWORD PTR j$[rsp]
	movsxd	rcx, DWORD PTR b$[rsp]
	movzx	eax, BYTE PTR forbuff$[rsp+rax]
	mov	BYTE PTR forbuffcond$[rsp+rcx], al
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax
$LN14@HllStartDi:
	movsxd	rax, DWORD PTR j$[rsp]
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	test	eax, eax
	je	SHORT $LN13@HllStartDi
	movsxd	rax, DWORD PTR j$[rsp]
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN13@HllStartDi
	jmp	SHORT $LN12@HllStartDi
$LN13@HllStartDi:

; 1481 :       if (forbuffcond[b - 2] == '>' && forbuffcond[b - 1] == '0') forbuffcond[b - 2] = NULLC;

	mov	eax, DWORD PTR b$[rsp]
	sub	eax, 2
	cdqe
	movsx	eax, BYTE PTR forbuffcond$[rsp+rax]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN62@HllStartDi
	mov	eax, DWORD PTR b$[rsp]
	dec	eax
	cdqe
	movsx	eax, BYTE PTR forbuffcond$[rsp+rax]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN62@HllStartDi
	mov	eax, DWORD PTR b$[rsp]
	sub	eax, 2
	cdqe
	mov	QWORD PTR $T6[rsp], rax
	cmp	QWORD PTR $T6[rsp], 1024		; 00000400H
	jae	SHORT $LN96@HllStartDi
	jmp	SHORT $LN97@HllStartDi
$LN96@HllStartDi:
	call	__report_rangecheckfailure
$LN97@HllStartDi:
	mov	rax, QWORD PTR $T6[rsp]
	mov	BYTE PTR forbuffcond$[rsp+rax], 0
$LN62@HllStartDi:

; 1482 :       forbuffcond[b] = NULLC;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	QWORD PTR $T7[rsp], rax
	cmp	QWORD PTR $T7[rsp], 1024		; 00000400H
	jae	SHORT $LN98@HllStartDi
	jmp	SHORT $LN99@HllStartDi
$LN98@HllStartDi:
	call	__report_rangecheckfailure
$LN99@HllStartDi:
	mov	rax, QWORD PTR $T7[rsp]
	mov	BYTE PTR forbuffcond$[rsp+rax], 0

; 1483 :       if (!b) hll->cond = FALSE;

	cmp	DWORD PTR b$[rsp], 0
	jne	SHORT $LN63@HllStartDi
	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+72], 0
	jmp	SHORT $LN64@HllStartDi
$LN63@HllStartDi:

; 1484 :       else    hll->cond = TRUE;

	mov	rax, QWORD PTR hll$[rsp]
	mov	BYTE PTR [rax+72], 1
$LN64@HllStartDi:

; 1485 :       j++;

	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax

; 1486 :       //copy the counter to the buffer
; 1487 :       cmcnt = 0;

	mov	DWORD PTR cmcnt$[rsp], 0

; 1488 :       forbuffcnt[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	QWORD PTR $T8[rsp], rax
	cmp	QWORD PTR $T8[rsp], 1024		; 00000400H
	jae	SHORT $LN100@HllStartDi
	jmp	SHORT $LN101@HllStartDi
$LN100@HllStartDi:
	call	__report_rangecheckfailure
$LN101@HllStartDi:
	mov	rax, QWORD PTR $T8[rsp]
	mov	BYTE PTR forbuffcnt$[rsp+rax], 0

; 1489 :       hll->condlines = "";

	mov	rax, QWORD PTR hll$[rsp]
	lea	rcx, OFFSET FLAT:$SG11823
	mov	QWORD PTR [rax+48], rcx

; 1490 :       for (b = 0; forbuff[j] != ')'; b++, j++) {

	mov	DWORD PTR b$[rsp], 0
	jmp	SHORT $LN17@HllStartDi
$LN15@HllStartDi:
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN17@HllStartDi:
	movsxd	rax, DWORD PTR j$[rsp]
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	cmp	eax, 41					; 00000029H
	je	$LN16@HllStartDi

; 1491 :         forbuffcnt[b] = forbuff[j];

	movsxd	rax, DWORD PTR j$[rsp]
	movsxd	rcx, DWORD PTR b$[rsp]
	movzx	eax, BYTE PTR forbuff$[rsp+rax]
	mov	BYTE PTR forbuffcnt$[rsp+rcx], al

; 1492 :         if (forbuffcnt[b] == ',' && forbuff[j - 1] != 39 && forbuff[j + 1] != 39) ++cmcnt;

	movsxd	rax, DWORD PTR b$[rsp]
	movsx	eax, BYTE PTR forbuffcnt$[rsp+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN65@HllStartDi
	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	cdqe
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN65@HllStartDi
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	cdqe
	movsx	eax, BYTE PTR forbuff$[rsp+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN65@HllStartDi
	mov	eax, DWORD PTR cmcnt$[rsp]
	inc	eax
	mov	DWORD PTR cmcnt$[rsp], eax
$LN65@HllStartDi:

; 1493 :         if (forbuffcnt[b] == 39 && forbuffcnt[b - 2] == 39) {

	movsxd	rax, DWORD PTR b$[rsp]
	movsx	eax, BYTE PTR forbuffcnt$[rsp+rax]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN66@HllStartDi
	mov	eax, DWORD PTR b$[rsp]
	sub	eax, 2
	cdqe
	movsx	eax, BYTE PTR forbuffcnt$[rsp+rax]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN66@HllStartDi

; 1494 :           b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 1495 :           forbuffcnt[b] = ' ';

	movsxd	rax, DWORD PTR b$[rsp]
	mov	BYTE PTR forbuffcnt$[rsp+rax], 32	; 00000020H
$LN66@HllStartDi:

; 1496 :         }
; 1497 :       }

	jmp	$LN15@HllStartDi
$LN16@HllStartDi:

; 1498 :       if (forbuffcnt[b - 1] == ')') b--;

	mov	eax, DWORD PTR b$[rsp]
	dec	eax
	cdqe
	movsx	eax, BYTE PTR forbuffcnt$[rsp+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN67@HllStartDi
	mov	eax, DWORD PTR b$[rsp]
	dec	eax
	mov	DWORD PTR b$[rsp], eax
$LN67@HllStartDi:

; 1499 :       forbuffcnt[b] = NULLC;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	QWORD PTR $T9[rsp], rax
	cmp	QWORD PTR $T9[rsp], 1024		; 00000400H
	jae	SHORT $LN102@HllStartDi
	jmp	SHORT $LN103@HllStartDi
$LN102@HllStartDi:
	call	__report_rangecheckfailure
$LN103@HllStartDi:
	mov	rax, QWORD PTR $T9[rsp]
	mov	BYTE PTR forbuffcnt$[rsp+rax], 0

; 1500 :       //create valid command and add to LineQueue to initiate .for loop vars
; 1501 :       //anything that is before the first ':'
; 1502 :       if (forbuffinit[0]) ForInitAndNext(tokenarray, eqcnt, forbuffinit);

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR forbuffinit$[rsp+rax]
	test	eax, eax
	je	SHORT $LN68@HllStartDi
	lea	r8, QWORD PTR forbuffinit$[rsp]
	mov	edx, DWORD PTR eqcnt$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	ForInitAndNext
$LN68@HllStartDi:

; 1503 :       //note hll->counterlines is new var in the struct hll_item for store of forbuffcnt used in .ENDFOR
; 1504 :       //hll->cmcnt is also new var in the struct hll_item for commas counter used in .ENDFOR
; 1505 :       //copy forbuffcnt context to hll->counterlines
; 1506 :       //forbuffcnt contains anything that is written after the second ':'
; 1507 :       hll->cmcnt = 0;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+64], 0

; 1508 :       if (forbuffcnt[0])

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR forbuffcnt$[rsp+rax]
	test	eax, eax
	je	$LN69@HllStartDi

; 1509 :       {
; 1510 :         //skip altering conditions the first time
; 1511 :         AddLineQueueX(" jmp %s", GetLabelStr(hll->labels[LSKIP], buff));

	mov	eax, 4
	imul	rax, rax, 3
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11830
	call	AddLineQueueX

; 1512 :         size = strlen(forbuffcnt) + 1;

	lea	rcx, QWORD PTR forbuffcnt$[rsp]
	call	strlen
	inc	rax
	mov	DWORD PTR size$[rsp], eax

; 1513 :         hll->counterlines = LclAlloc(size);

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR hll$[rsp]
	mov	QWORD PTR [rcx+56], rax

; 1514 :         memcpy(hll->counterlines, forbuffcnt, size);

	movsxd	rax, DWORD PTR size$[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR forbuffcnt$[rsp]
	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rax+56]
	call	memcpy

; 1515 :         hll->cmcnt = cmcnt + 1;

	mov	eax, DWORD PTR cmcnt$[rsp]
	inc	eax
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+64], eax

; 1516 :       }

	jmp	SHORT $LN70@HllStartDi
$LN69@HllStartDi:

; 1517 :       else hll->counterlines = "";    //there is nothing after the second ':'

	mov	rax, QWORD PTR hll$[rsp]
	lea	rcx, OFFSET FLAT:$SG11831
	mov	QWORD PTR [rax+56], rcx
$LN70@HllStartDi:

; 1518 :       if (forbuffcond[0]) {

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR forbuffcond$[rsp+rax]
	test	eax, eax
	je	$LN71@HllStartDi

; 1519 :         strcpy(transformed, ".for ");

	lea	rdx, OFFSET FLAT:$SG11833
	lea	rcx, QWORD PTR transformed$[rsp]
	call	strcpy

; 1520 :         strcat(transformed, forbuffcond);

	lea	rdx, QWORD PTR forbuffcond$[rsp]
	lea	rcx, QWORD PTR transformed$[rsp]
	call	strcat

; 1521 :         strcat(transformed, "\0");

	lea	rdx, OFFSET FLAT:$SG11834
	lea	rcx, QWORD PTR transformed$[rsp]
	call	strcat

; 1522 :         tokenarray[0].string_ptr = ".for\0";

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	lea	rdx, OFFSET FLAT:$SG11835
	mov	QWORD PTR [rcx+rax+8], rdx

; 1523 :         tokenarray[0].tokpos = transformed;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR transformed$[rsp]
	mov	QWORD PTR [rcx+rax+24], rdx

; 1524 :         Token_Count = Tokenize(tokenarray[0].tokpos, 0, tokenarray, 0);

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+24]
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 1525 :         if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN72@HllStartDi

; 1526 :           rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, TRUE, buffer);

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], 1
	mov	r9d, 2
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	EvaluateHllExpression
	mov	DWORD PTR rc$[rsp], eax

; 1527 :           if (rc == NOT_ERROR) {

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN74@HllStartDi

; 1528 :             size = strlen(buffer) + 1;

	lea	rcx, QWORD PTR buffer$[rsp]
	call	strlen
	inc	rax
	mov	DWORD PTR size$[rsp], eax

; 1529 :             hll->condlines = LclAlloc(size);

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR hll$[rsp]
	mov	QWORD PTR [rcx+48], rax

; 1530 :             memcpy(hll->condlines, buffer, size);

	movsxd	rax, DWORD PTR size$[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rax+48]
	call	memcpy

; 1531 :             DebugCmd(cntCond++); DebugCmd(cntCondBytes += size);

	mov	eax, DWORD PTR cntCond
	inc	eax
	mov	DWORD PTR cntCond, eax
	mov	eax, DWORD PTR size$[rsp]
	mov	ecx, DWORD PTR cntCondBytes
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR cntCondBytes, eax
$LN74@HllStartDi:

; 1532 :           }
; 1533 :         }

	jmp	SHORT $LN73@HllStartDi
$LN72@HllStartDi:

; 1534 :         else
; 1535 :           hll->condlines = "";

	mov	rax, QWORD PTR hll$[rsp]
	lea	rcx, OFFSET FLAT:$SG11839
	mov	QWORD PTR [rax+48], rcx
$LN73@HllStartDi:
$LN71@HllStartDi:
$LN57@HllStartDi:

; 1536 :       }
; 1537 :     }
; 1538 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSTART], buff));

	mov	eax, 4
	imul	rax, rax, 2
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11840
	call	AddLineQueueX

; 1539 :     tokenarray[i].token = T_FINAL;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 1540 :     break;

	jmp	$LN2@HllStartDi
$LN75@HllStartDi:

; 1541 :     //end of .FOR
; 1542 :   case T_DOT_WHILE:
; 1543 :   case T_DOT_REPEAT:
; 1544 :     /* create the label to start of loop */
; 1545 :     hll->labels[LSTART] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1546 :     hll->labels[LTEST] = 0; /* v2.11: test label is created only if needed */

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+rax+8], 0

; 1547 :                             //hll->labels[LEXIT] = GetHllLabel(); /* v2.11: LEXIT is only needed for .BREAK */
; 1548 :     if (cmd == T_DOT_WHILE) {

	cmp	DWORD PTR cmd$[rsp], 330		; 0000014aH
	jne	$LN76@HllStartDi

; 1549 :       hll->cmd = HLL_WHILE;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+68], 1

; 1550 :       hll->condlines = NULL;

	mov	rax, QWORD PTR hll$[rsp]
	mov	QWORD PTR [rax+48], 0

; 1551 :       if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN78@HllStartDi

; 1552 :         rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, TRUE, buffer);

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], 1
	mov	r9d, 2
	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	EvaluateHllExpression
	mov	DWORD PTR rc$[rsp], eax

; 1553 :         if (rc == NOT_ERROR) {

	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN80@HllStartDi

; 1554 :           int size;
; 1555 :           size = strlen(buffer) + 1;

	lea	rcx, QWORD PTR buffer$[rsp]
	call	strlen
	inc	rax
	mov	DWORD PTR size$1[rsp], eax

; 1556 :           hll->condlines = LclAlloc(size);

	movsxd	rax, DWORD PTR size$1[rsp]
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR hll$[rsp]
	mov	QWORD PTR [rcx+48], rax

; 1557 :           memcpy(hll->condlines, buffer, size);

	movsxd	rax, DWORD PTR size$1[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rax+48]
	call	memcpy

; 1558 :           DebugCmd(cntCond++); DebugCmd(cntCondBytes += size);

	mov	eax, DWORD PTR cntCond
	inc	eax
	mov	DWORD PTR cntCond, eax
	mov	eax, DWORD PTR size$1[rsp]
	mov	ecx, DWORD PTR cntCondBytes
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR cntCondBytes, eax
$LN80@HllStartDi:

; 1559 :         }
; 1560 :       }

	jmp	SHORT $LN79@HllStartDi
$LN78@HllStartDi:

; 1561 :       else
; 1562 :         buffer[0] = NULLC;  /* just ".while" without expression is accepted */

	mov	eax, 1
	imul	rax, rax, 0
	mov	QWORD PTR $T10[rsp], rax
	cmp	QWORD PTR $T10[rsp], 2048		; 00000800H
	jae	SHORT $LN104@HllStartDi
	jmp	SHORT $LN105@HllStartDi
$LN104@HllStartDi:
	call	__report_rangecheckfailure
$LN105@HllStartDi:
	mov	rax, QWORD PTR $T10[rsp]
	mov	BYTE PTR buffer$[rsp+rax], 0
$LN79@HllStartDi:

; 1563 : 
; 1564 :                             /* create a jump to test label */
; 1565 :                             /* optimisation: if line at 'test' label is just a jump, dont create label and don't jump! */
; 1566 :       if (_memicmp(buffer, "jmp", 3)) {

	mov	r8d, 3
	lea	rdx, OFFSET FLAT:$SG11848
	lea	rcx, QWORD PTR buffer$[rsp]
	call	_memicmp
	test	eax, eax
	je	SHORT $LN81@HllStartDi

; 1567 :         hll->labels[LTEST] = GetHllLabel();

	call	GetHllLabel
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 1568 :         AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[LTEST], buff));

	mov	eax, 4
	imul	rax, rax, 0
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11849
	call	AddLineQueueX
$LN81@HllStartDi:

; 1569 :       }
; 1570 :     }

	jmp	SHORT $LN77@HllStartDi
$LN76@HllStartDi:

; 1571 :     else {
; 1572 :       hll->cmd = HLL_REPEAT;

	mov	rax, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rax+68], 2
$LN77@HllStartDi:

; 1573 :     }
; 1574 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSTART], buff));

	mov	eax, 4
	imul	rax, rax, 2
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+8]
	call	GetLabelStr
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG11850
	call	AddLineQueueX

; 1575 :     break;

	jmp	SHORT $LN2@HllStartDi
$LN82@HllStartDi:

; 1576 : #ifdef DEBUG_OUT
; 1577 :   default: /**/myassert(0); break;

	mov	edx, 1577				; 00000629H
	lea	rcx, OFFSET FLAT:$SG11852
	call	InternalError
$LN2@HllStartDi:

; 1578 : #endif
; 1579 :   }
; 1580 : 
; 1581 :   if (tokenarray[i].token != T_FINAL && rc == NOT_ERROR) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN83@HllStartDi
	cmp	DWORD PTR rc$[rsp], 0
	jne	SHORT $LN83@HllStartDi

; 1582 :     DebugMsg(("HllStartDir: unexpected token [%s]\n", tokenarray[i].tokpos));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11854
	call	DoDebugMsg

; 1583 :     EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1584 :     rc = ERROR;

	mov	DWORD PTR rc$[rsp], -1
$LN83@HllStartDi:

; 1585 :     //return( ERROR ); /* v2.08: continue and parse the line queue */
; 1586 :   }
; 1587 :   /* v2.06: remove the item from the free stack */
; 1588 :   if (hll == HllFree)

	mov	rax, QWORD PTR ModuleInfo+232
	cmp	QWORD PTR hll$[rsp], rax
	jne	SHORT $LN84@HllStartDi

; 1589 :     HllFree = hll->next;

	mov	rax, QWORD PTR hll$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ModuleInfo+232, rax
$LN84@HllStartDi:

; 1590 :   hll->next = HllStack;

	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+224
	mov	QWORD PTR [rax], rcx

; 1591 :   HllStack = hll;

	mov	rax, QWORD PTR hll$[rsp]
	mov	QWORD PTR ModuleInfo+224, rax

; 1592 : 
; 1593 :   if (ModuleInfo.list)

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN85@HllStartDi

; 1594 :     LstWrite(LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL);

	call	GetCurrOffset
	xor	r8d, r8d
	mov	edx, eax
	mov	ecx, 4
	call	LstWrite
$LN85@HllStartDi:

; 1595 : 
; 1596 :   if (is_linequeue_populated()) /* might be NULL! (".if 1") */

	cmp	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN86@HllStartDi

; 1597 :     RunLineQueue();

	call	RunLineQueue
$LN86@HllStartDi:

; 1598 : 
; 1599 :   return(rc);

	mov	eax, DWORD PTR rc$[rsp]
$LN1@HllStartDi:
$LN87@HllStartDi:

; 1600 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 7528				; 00001d68H
	ret	0
HllStartDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
b$ = 32
op$ = 36
a$ = 40
brct$ = 44
j$ = 48
p$ = 56
$T1 = 64
$T2 = 72
$T3 = 80
$T4 = 88
$T5 = 96
$T6 = 104
$T7 = 112
init$ = 128
codebuff$ = 384
param$ = 640
__$ArrayPad$ = 896
tokenarray$ = 928
cnt$ = 936
buff$ = 944
ForInitAndNext PROC

; 1004 : static ret_code ForInitAndNext(struct asm_tok tokenarray[], int cnt, char *buff) {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 920				; 00000398H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1005 :   int a;
; 1006 :   int j;
; 1007 :   int	b = 0;

	mov	DWORD PTR b$[rsp], 0

; 1008 :   bool brct = 0;

	mov	BYTE PTR brct$[rsp], 0
$LN4@ForInitAnd:

; 1009 :   char codebuff[256];
; 1010 :   char param[256];
; 1011 :   char init[256];
; 1012 :   char op[4];
; 1013 :   char *p;
; 1014 :   //create valid command and add to LineQueue
; 1015 :   do {
; 1016 :     //extracting the first parameter "param" before the operator
; 1017 :     a = 0;

	mov	DWORD PTR a$[rsp], 0
$LN5@ForInitAnd:

; 1018 :     while (buff[b] && !strchr("=!<>&|-+*^%/", buff[b]))

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN6@ForInitAnd
	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11532
	call	strchr
	test	rax, rax
	jne	SHORT $LN6@ForInitAnd

; 1019 :     {
; 1020 :       if (buff[b] == '-' || buff[b] == '+') break;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN20@ForInitAnd
	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN19@ForInitAnd
$LN20@ForInitAnd:
	jmp	SHORT $LN6@ForInitAnd
$LN19@ForInitAnd:

; 1021 :       param[a] = buff[b];

	movsxd	rax, DWORD PTR b$[rsp]
	movsxd	rcx, DWORD PTR a$[rsp]
	mov	rdx, QWORD PTR buff$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR param$[rsp+rcx], al

; 1022 :       b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 1023 :       a++;

	mov	eax, DWORD PTR a$[rsp]
	inc	eax
	mov	DWORD PTR a$[rsp], eax

; 1024 :     }

	jmp	$LN5@ForInitAnd
$LN6@ForInitAnd:

; 1025 :     param[a] = '\0';

	movsxd	rax, DWORD PTR a$[rsp]
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 256			; 00000100H
	jae	SHORT $LN128@ForInitAnd
	jmp	SHORT $LN129@ForInitAnd
$LN128@ForInitAnd:
	call	__report_rangecheckfailure
$LN129@ForInitAnd:
	mov	rax, QWORD PTR $T1[rsp]
	mov	BYTE PTR param$[rsp+rax], 0

; 1026 :     //end of param
; 1027 :     //is it simple operator
; 1028 :     if ((buff[b + 1] == '+') || (buff[b + 1] == '-')) {            //if ++ or -- finish it here

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN23@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 45					; 0000002dH
	jne	$LN21@ForInitAnd
$LN23@ForInitAnd:

; 1029 :       param[a] = '\0';

	movsxd	rax, DWORD PTR a$[rsp]
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 256			; 00000100H
	jae	SHORT $LN130@ForInitAnd
	jmp	SHORT $LN131@ForInitAnd
$LN130@ForInitAnd:
	call	__report_rangecheckfailure
$LN131@ForInitAnd:
	mov	rax, QWORD PTR $T2[rsp]
	mov	BYTE PTR param$[rsp+rax], 0

; 1030 :       if ((buff[b] == '+') && (buff[b + 1] == '+')) strcpy(codebuff, " inc ");

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN24@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN24@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11540
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	SHORT $LN25@ForInitAnd
$LN24@ForInitAnd:

; 1031 :       else if ((buff[b] == '-') && (buff[b + 1] == '-')) strcpy(codebuff, " dec ");

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN26@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN26@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11542
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
$LN26@ForInitAnd:
$LN25@ForInitAnd:

; 1032 :       strcat(codebuff, param);

	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 1033 :       AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1034 :       b += 3;

	mov	eax, DWORD PTR b$[rsp]
	add	eax, 3
	mov	DWORD PTR b$[rsp], eax

; 1035 :     }

	jmp	$LN22@ForInitAnd
$LN21@ForInitAnd:

; 1036 : 
; 1037 :     //we finis here "inc REX" or  "dec REX" or "inc mem" or "dec mem"
; 1038 :     else						//if not ++ or --
; 1039 :     {							//extracting the operator
; 1040 :       op[0] = buff[b];

	movsxd	rax, DWORD PTR b$[rsp]
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR buff$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR op$[rsp+rcx], al

; 1041 :       b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 1042 :       if (op[0] == '=') {     //if operator is only '='

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 61					; 0000003dH
	jne	SHORT $LN27@ForInitAnd

; 1043 :         op[1] = '\0';       //finish here

	mov	QWORD PTR $T3[rsp], 1
	cmp	QWORD PTR $T3[rsp], 4
	jae	SHORT $LN132@ForInitAnd
	jmp	SHORT $LN133@ForInitAnd
$LN132@ForInitAnd:
	call	__report_rangecheckfailure
$LN133@ForInitAnd:
	mov	rax, QWORD PTR $T3[rsp]
	mov	BYTE PTR op$[rsp+rax], 0

; 1044 :       }

	jmp	$LN28@ForInitAnd
$LN27@ForInitAnd:

; 1045 :       else {                 //extract next operator
; 1046 :         op[1] = buff[b];

	movsxd	rax, DWORD PTR b$[rsp]
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR buff$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR op$[rsp+rcx], al

; 1047 :         b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 1048 :         if ((op[1] == '<' || op[1] == '>') && (buff[b] == '=')) {

	mov	eax, 1
	imul	rax, rax, 1
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN31@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 1
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN29@ForInitAnd
$LN31@ForInitAnd:
	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 61					; 0000003dH
	jne	SHORT $LN29@ForInitAnd

; 1049 :           op[2] = buff[b]; //if a second operator is shift sign "<<=" or ">>="

	movsxd	rax, DWORD PTR b$[rsp]
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR buff$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR op$[rsp+rcx], al

; 1050 :           op[3] = NULLC;

	mov	eax, 1
	imul	rax, rax, 3
	mov	QWORD PTR $T4[rsp], rax
	cmp	QWORD PTR $T4[rsp], 4
	jae	SHORT $LN134@ForInitAnd
	jmp	SHORT $LN135@ForInitAnd
$LN134@ForInitAnd:
	call	__report_rangecheckfailure
$LN135@ForInitAnd:
	mov	rax, QWORD PTR $T4[rsp]
	mov	BYTE PTR op$[rsp+rax], 0

; 1051 :           b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 1052 :         }

	jmp	SHORT $LN30@ForInitAnd
$LN29@ForInitAnd:

; 1053 :         else op[2] = NULLC; //not shift so we have two operands

	mov	eax, 1
	imul	rax, rax, 2
	mov	QWORD PTR $T5[rsp], rax
	cmp	QWORD PTR $T5[rsp], 4
	jae	SHORT $LN136@ForInitAnd
	jmp	SHORT $LN137@ForInitAnd
$LN136@ForInitAnd:
	call	__report_rangecheckfailure
$LN137@ForInitAnd:
	mov	rax, QWORD PTR $T5[rsp]
	mov	BYTE PTR op$[rsp+rax], 0
$LN30@ForInitAnd:
$LN28@ForInitAnd:

; 1054 : 
; 1055 :       }
; 1056 :       //we finished with param and op
; 1057 :       //now extracting the second parameter "init" after the operator
; 1058 :       for (a = 0; buff[b];) { //checking if we have a char in a single ' '

	mov	DWORD PTR a$[rsp], 0
$LN7@ForInitAnd:
	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN8@ForInitAnd

; 1059 :         if (buff[b] == '(' && buff[b - 1] != 39 && buff[b + 1] != 39 && b) break;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN32@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN32@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN32@ForInitAnd
	cmp	DWORD PTR b$[rsp], 0
	je	SHORT $LN32@ForInitAnd
	jmp	$LN8@ForInitAnd
$LN32@ForInitAnd:

; 1060 :         if (buff[b] == ',' && buff[b - 1] != 39 && buff[b + 1] != 39 && b) break;

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN33@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN33@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN33@ForInitAnd
	cmp	DWORD PTR b$[rsp], 0
	je	SHORT $LN33@ForInitAnd
	jmp	SHORT $LN8@ForInitAnd
$LN33@ForInitAnd:

; 1061 :         init[a] = buff[b];

	movsxd	rax, DWORD PTR b$[rsp]
	movsxd	rcx, DWORD PTR a$[rsp]
	mov	rdx, QWORD PTR buff$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR init$[rsp+rcx], al

; 1062 :         b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 1063 :         a++;

	mov	eax, DWORD PTR a$[rsp]
	inc	eax
	mov	DWORD PTR a$[rsp], eax

; 1064 :       }

	jmp	$LN7@ForInitAnd
$LN8@ForInitAnd:

; 1065 :       if (buff[b] == '(' && buff[b - 1] != 39 && buff[b + 1] != 39 && b) {

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	$LN34@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 39					; 00000027H
	je	$LN34@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 39					; 00000027H
	je	$LN34@ForInitAnd
	cmp	DWORD PTR b$[rsp], 0
	je	$LN34@ForInitAnd

; 1066 :         for (; buff[b] && buff[b] != ')'; b++, a++) {

	jmp	SHORT $LN12@ForInitAnd
$LN10@ForInitAnd:
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax
	mov	eax, DWORD PTR a$[rsp]
	inc	eax
	mov	DWORD PTR a$[rsp], eax
$LN12@ForInitAnd:
	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN11@ForInitAnd
	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN11@ForInitAnd

; 1067 :           init[a] = buff[b];

	movsxd	rax, DWORD PTR b$[rsp]
	movsxd	rcx, DWORD PTR a$[rsp]
	mov	rdx, QWORD PTR buff$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR init$[rsp+rcx], al

; 1068 :         }

	jmp	SHORT $LN10@ForInitAnd
$LN11@ForInitAnd:

; 1069 :         if (buff[b] == ')' && buff[b - 1] != 39 && buff[b + 1] != 39) {

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN35@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN35@ForInitAnd
	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR buff$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN35@ForInitAnd

; 1070 :           init[a] = buff[b];

	movsxd	rax, DWORD PTR b$[rsp]
	movsxd	rcx, DWORD PTR a$[rsp]
	mov	rdx, QWORD PTR buff$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR init$[rsp+rcx], al

; 1071 :           b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 1072 :           a++;

	mov	eax, DWORD PTR a$[rsp]
	inc	eax
	mov	DWORD PTR a$[rsp], eax
$LN35@ForInitAnd:

; 1073 :         }
; 1074 :         brct = TRUE;

	mov	BYTE PTR brct$[rsp], 1
$LN34@ForInitAnd:

; 1075 :       }
; 1076 :       init[a] = NULLC;

	movsxd	rax, DWORD PTR a$[rsp]
	mov	QWORD PTR $T6[rsp], rax
	cmp	QWORD PTR $T6[rsp], 256			; 00000100H
	jae	SHORT $LN138@ForInitAnd
	jmp	SHORT $LN139@ForInitAnd
$LN138@ForInitAnd:
	call	__report_rangecheckfailure
$LN139@ForInitAnd:
	mov	rax, QWORD PTR $T6[rsp]
	mov	BYTE PTR init$[rsp+rax], 0

; 1077 :       b++;

	mov	eax, DWORD PTR b$[rsp]
	inc	eax
	mov	DWORD PTR b$[rsp], eax

; 1078 :       //we finished with init
; 1079 :       //is operator devision, multiplication or mod
; 1080 :       if (op[0] == '/' || op[0] == '*' || op[0] == '%') {

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN38@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN38@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	$LN36@ForInitAnd
$LN38@ForInitAnd:

; 1081 :         Tokenize(param, 0, tokenarray, 0);

	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR param$[rsp]
	call	Tokenize

; 1082 :         if (strcasecmp(param, reax[ModuleInfo.Ofssize]) && strcasecmp(init, reax[ModuleInfo.Ofssize])) { //param not rax init not rax?

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:reax
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR param$[rsp]
	call	_stricmp
	test	eax, eax
	je	$LN39@ForInitAnd
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:reax
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR init$[rsp]
	call	_stricmp
	test	eax, eax
	je	$LN39@ForInitAnd

; 1083 :           if (tokenarray[0].token == T_REG) {			//is param register

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	jne	$LN41@ForInitAnd

; 1084 :             if (strcasecmp(param, recx[ModuleInfo.Ofssize])) {				//make sure that param is not rcx

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:recx
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR param$[rsp]
	call	_stricmp
	test	eax, eax
	je	SHORT $LN43@ForInitAnd

; 1085 :               WriteAsmLine(" mov  ", reax[ModuleInfo.Ofssize], param);				// MOV RAX,param

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:reax
	lea	r8, QWORD PTR param$[rsp]
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, OFFSET FLAT:$SG11560
	call	WriteAsmLine
$LN43@ForInitAnd:

; 1086 :             }						if (op[0] == '/' || op[0] == '%') {

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN45@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN44@ForInitAnd
$LN45@ForInitAnd:

; 1087 :               strcpy(codebuff, " cdq ");			//extend to RDX if division

	lea	rdx, OFFSET FLAT:$SG11563
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1088 :               AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue
$LN44@ForInitAnd:

; 1089 :             }
; 1090 :             Tokenize(init, 0, tokenarray, 0);

	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR init$[rsp]
	call	Tokenize

; 1091 :             if (tokenarray[0].token == T_NUM) {      //is init number?

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 10
	jne	$LN46@ForInitAnd

; 1092 :               WriteAsmLine(" mov  ", recx[ModuleInfo.Ofssize], init);        //MOV RCX,init

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:recx
	lea	r8, QWORD PTR init$[rsp]
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, OFFSET FLAT:$SG11566
	call	WriteAsmLine

; 1093 :               if (op[0] == '/' || op[0] == '%')

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN50@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN48@ForInitAnd
$LN50@ForInitAnd:

; 1094 :                 strcpy(codebuff, " idiv ");		//IDIV RCX

	lea	rdx, OFFSET FLAT:$SG11570
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	SHORT $LN49@ForInitAnd
$LN48@ForInitAnd:

; 1095 :               else strcpy(codebuff, " imul ");		//IMUL RCX

	lea	rdx, OFFSET FLAT:$SG11571
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
$LN49@ForInitAnd:

; 1096 :               strcat(codebuff, recx[ModuleInfo.Ofssize]);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:recx
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 1097 :               AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1098 :               goto cont;

	jmp	$cont$142

; 1099 :             }

	jmp	SHORT $LN47@ForInitAnd
$LN46@ForInitAnd:

; 1100 :             else {
; 1101 :               if (op[0] == '/' || op[0] == '%') //it is a variable

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN53@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN51@ForInitAnd
$LN53@ForInitAnd:

; 1102 :                 strcpy(codebuff, " idiv ");

	lea	rdx, OFFSET FLAT:$SG11575
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	SHORT $LN52@ForInitAnd
$LN51@ForInitAnd:

; 1103 :               else strcpy(codebuff, " imul ");

	lea	rdx, OFFSET FLAT:$SG11576
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
$LN52@ForInitAnd:

; 1104 :               strcat(codebuff, init);

	lea	rdx, QWORD PTR init$[rsp]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 1105 :               AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1106 :               goto cont;

	jmp	$cont$142
$LN47@ForInitAnd:

; 1107 :             }
; 1108 :           }

	jmp	$LN42@ForInitAnd
$LN41@ForInitAnd:

; 1109 :           //if param is a variable
; 1110 :           else if (tokenarray[0].token == T_ID) {		 //YES

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN54@ForInitAnd

; 1111 :             WriteAsmLine(" mov  ", recx[ModuleInfo.Ofssize], init);        //MOV RCX,init

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:recx
	lea	r8, QWORD PTR init$[rsp]
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, OFFSET FLAT:$SG11578
	call	WriteAsmLine

; 1112 :             WriteAsmLine(" mov  ", reax[ModuleInfo.Ofssize], param);		// MOV RAX,param

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:reax
	lea	r8, QWORD PTR param$[rsp]
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, OFFSET FLAT:$SG11579
	call	WriteAsmLine

; 1113 :             if (op[0] == '/' || op[0] == '%') {

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN57@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN55@ForInitAnd
$LN57@ForInitAnd:

; 1114 :               strcpy(codebuff, " cdq ");

	lea	rdx, OFFSET FLAT:$SG11583
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1115 :               AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1116 :               strcpy(codebuff, " idiv ");

	lea	rdx, OFFSET FLAT:$SG11584
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1117 :             }

	jmp	SHORT $LN56@ForInitAnd
$LN55@ForInitAnd:

; 1118 :             else strcpy(codebuff, " imul ");

	lea	rdx, OFFSET FLAT:$SG11585
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
$LN56@ForInitAnd:

; 1119 :             strcat(codebuff, recx[ModuleInfo.Ofssize]);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:recx
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 1120 :             AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue
$cont$142:

; 1121 :           cont:
; 1122 :             if (op[0] == '%') {

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN58@ForInitAnd

; 1123 :               WriteAsmLine(" mov  ", param, redx[ModuleInfo.Ofssize]);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:redx
	mov	r8, QWORD PTR [rcx+rax*8]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11588
	call	WriteAsmLine

; 1124 :               goto skip;

	jmp	$skip$143

; 1125 :             }

	jmp	SHORT $LN59@ForInitAnd
$LN58@ForInitAnd:

; 1126 :             else {
; 1127 :               WriteAsmLine(" mov  ", param, reax[ModuleInfo.Ofssize]);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:reax
	mov	r8, QWORD PTR [rcx+rax*8]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11589
	call	WriteAsmLine

; 1128 :               goto skip;

	jmp	$skip$143
$LN59@ForInitAnd:
$LN54@ForInitAnd:
$LN42@ForInitAnd:

; 1129 :             }
; 1130 :           }
; 1131 :         }

	jmp	$LN40@ForInitAnd
$LN39@ForInitAnd:

; 1132 :         // if param is not RAX and init is RCX
; 1133 :         else if ((strcasecmp(param, reax[ModuleInfo.Ofssize]) && !(strcasecmp(init, recx[ModuleInfo.Ofssize])))) {

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:reax
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR param$[rsp]
	call	_stricmp
	test	eax, eax
	je	$LN60@ForInitAnd
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:recx
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR init$[rsp]
	call	_stricmp
	test	eax, eax
	jne	$LN60@ForInitAnd

; 1134 :           if (op[0] == '/' || op[0] == '%') {

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN64@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN62@ForInitAnd
$LN64@ForInitAnd:

; 1135 :             strcpy(codebuff, " cdq ");

	lea	rdx, OFFSET FLAT:$SG11595
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1136 :             AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1137 :             strcpy(codebuff, " idiv ");

	lea	rdx, OFFSET FLAT:$SG11596
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1138 :           }

	jmp	SHORT $LN63@ForInitAnd
$LN62@ForInitAnd:

; 1139 :           else strcpy(codebuff, " imul ");

	lea	rdx, OFFSET FLAT:$SG11597
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
$LN63@ForInitAnd:

; 1140 :           strcat(codebuff, recx[ModuleInfo.Ofssize]);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:recx
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 1141 :           AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1142 :           if (op[0] == '%') WriteAsmLine(" mov  ", param, redx[ModuleInfo.Ofssize]);

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN65@ForInitAnd
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:redx
	mov	r8, QWORD PTR [rcx+rax*8]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11599
	call	WriteAsmLine
$LN65@ForInitAnd:

; 1143 :           goto skip;

	jmp	$skip$143

; 1144 :         }

	jmp	$LN61@ForInitAnd
$LN60@ForInitAnd:

; 1145 :         // if param is RAX and init is RCX
; 1146 :         else if ((!(strcasecmp(param, reax[ModuleInfo.Ofssize])) && (!(strcmp(init, recx[ModuleInfo.Ofssize]))))) {

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:reax
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR param$[rsp]
	call	_stricmp
	test	eax, eax
	jne	$LN66@ForInitAnd
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:recx
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR init$[rsp]
	call	strcmp
	test	eax, eax
	jne	$LN66@ForInitAnd

; 1147 :           if (op[0] == '/' || op[0] == '%') {

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN70@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN68@ForInitAnd
$LN70@ForInitAnd:

; 1148 :             strcpy(codebuff, " cdq ");

	lea	rdx, OFFSET FLAT:$SG11605
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1149 :             AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1150 :             strcpy(codebuff, " idiv ");

	lea	rdx, OFFSET FLAT:$SG11606
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1151 :           }

	jmp	SHORT $LN69@ForInitAnd
$LN68@ForInitAnd:

; 1152 :           else strcpy(codebuff, " imul ");

	lea	rdx, OFFSET FLAT:$SG11607
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
$LN69@ForInitAnd:

; 1153 :           strcat(codebuff, recx[ModuleInfo.Ofssize]);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:recx
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 1154 :           AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1155 :           if (op[0] == '%') WriteAsmLine(" mov  ", param, redx[ModuleInfo.Ofssize]);

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN71@ForInitAnd
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:redx
	mov	r8, QWORD PTR [rcx+rax*8]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11609
	call	WriteAsmLine
$LN71@ForInitAnd:

; 1156 :           goto skip;

	jmp	$skip$143

; 1157 :         }

	jmp	$LN67@ForInitAnd
$LN66@ForInitAnd:

; 1158 :         // if param is RAX and init is not RCX
; 1159 :         else if (!(strcasecmp(param, reax[ModuleInfo.Ofssize]) && (strcasecmp(init, recx[ModuleInfo.Ofssize])))) {

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:reax
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR param$[rsp]
	call	_stricmp
	test	eax, eax
	je	SHORT $LN73@ForInitAnd
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:recx
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR init$[rsp]
	call	_stricmp
	test	eax, eax
	jne	$LN72@ForInitAnd
$LN73@ForInitAnd:

; 1160 :           WriteAsmLine(" mov  ", recx[ModuleInfo.Ofssize], init);        //MOV RCX,init

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:recx
	lea	r8, QWORD PTR init$[rsp]
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, OFFSET FLAT:$SG11612
	call	WriteAsmLine

; 1161 :           if (op[0] == '/' || op[0] == '%') {

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN76@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN74@ForInitAnd
$LN76@ForInitAnd:

; 1162 :             strcpy(codebuff, " cdq ");

	lea	rdx, OFFSET FLAT:$SG11616
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1163 :             AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1164 :             strcpy(codebuff, " idiv ");

	lea	rdx, OFFSET FLAT:$SG11617
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1165 :           }

	jmp	SHORT $LN75@ForInitAnd
$LN74@ForInitAnd:

; 1166 :           else strcpy(codebuff, " imul ");

	lea	rdx, OFFSET FLAT:$SG11618
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
$LN75@ForInitAnd:

; 1167 :           strcat(codebuff, recx[ModuleInfo.Ofssize]);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:recx
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 1168 :           AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1169 :           if (op[0] == '%') WriteAsmLine(" mov  ", param, redx[ModuleInfo.Ofssize]);

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN77@ForInitAnd
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:redx
	mov	r8, QWORD PTR [rcx+rax*8]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11620
	call	WriteAsmLine
$LN77@ForInitAnd:

; 1170 :           goto skip;

	jmp	$skip$143
$LN72@ForInitAnd:
$LN67@ForInitAnd:
$LN61@ForInitAnd:
$LN40@ForInitAnd:

; 1171 :         }
; 1172 :       }

	jmp	$LN37@ForInitAnd
$LN36@ForInitAnd:

; 1173 :       //if operator not devision, multiplication or mod
; 1174 :       else if (op[0] == '-') strcpy(codebuff, " sub ");

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN78@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11623
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	$LN79@ForInitAnd
$LN78@ForInitAnd:

; 1175 :       else if (op[0] == '+') strcpy(codebuff, " add ");

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN80@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11626
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	$LN81@ForInitAnd
$LN80@ForInitAnd:

; 1176 :       else if (op[0] == '&') strcpy(codebuff, " and ");

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN82@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11629
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	$LN83@ForInitAnd
$LN82@ForInitAnd:

; 1177 :       else if (op[0] == '|') strcpy(codebuff, " or ");

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 124				; 0000007cH
	jne	SHORT $LN84@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11632
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	$LN85@ForInitAnd
$LN84@ForInitAnd:

; 1178 :       else if (op[0] == '^') strcpy(codebuff, " xor ");

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 94					; 0000005eH
	jne	SHORT $LN86@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11635
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	SHORT $LN87@ForInitAnd
$LN86@ForInitAnd:

; 1179 :       else if (op[0] == '<' && op[1] == '<') strcpy(codebuff, " shl ");

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN88@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 1
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN88@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11638
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
	jmp	SHORT $LN89@ForInitAnd
$LN88@ForInitAnd:

; 1180 :       else if (op[0] == '>' && op[1] == '>') strcpy(codebuff, " shr ");

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN90@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 1
	movsx	eax, BYTE PTR op$[rsp+rax]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN90@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG11640
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy
$LN90@ForInitAnd:
$LN89@ForInitAnd:
$LN87@ForInitAnd:
$LN85@ForInitAnd:
$LN83@ForInitAnd:
$LN81@ForInitAnd:
$LN79@ForInitAnd:
$LN37@ForInitAnd:

; 1181 :       Tokenize(init, 0, tokenarray, 0);

	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR init$[rsp]
	call	Tokenize

; 1182 :       if (tokenarray[0].token == T_REG || tokenarray[0].token == T_NUM || tokenarray[0].token == T_FLOAT || tokenarray[0].token == T_DIRECTIVE)

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	je	SHORT $LN92@ForInitAnd
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 10
	je	SHORT $LN92@ForInitAnd
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 11
	je	SHORT $LN92@ForInitAnd
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	SHORT $LN91@ForInitAnd
$LN92@ForInitAnd:

; 1183 :         goto simple;

	jmp	SHORT $simple$144
$LN91@ForInitAnd:

; 1184 :       Tokenize(param, 0, tokenarray, 0);

	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR param$[rsp]
	call	Tokenize

; 1185 :       if (tokenarray[0].token == T_REG) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	jne	$LN93@ForInitAnd
$simple$144:

; 1186 :       simple:			Tokenize(param, 0, tokenarray, 0);

	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR param$[rsp]
	call	Tokenize

; 1187 : 
; 1188 :         if (strlen(init) == 1 && init[0] == '0')                        //REX=0?

	lea	rcx, QWORD PTR init$[rsp]
	call	strlen
	cmp	rax, 1
	jne	SHORT $LN95@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN95@ForInitAnd

; 1189 :           WriteAsmLine(" xor  ", param, param);							            //XOR REX,REX //instead MOV REX,0

	lea	r8, QWORD PTR param$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11647
	call	WriteAsmLine
	jmp	$LN96@ForInitAnd
$LN95@ForInitAnd:

; 1190 :         else if ((strlen(op) == 1) && ((init[4] == ' ') || (init[4] == '\t'))) {  //op is '='

	lea	rcx, QWORD PTR op$[rsp]
	call	strlen
	cmp	rax, 1
	jne	$LN97@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 4
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN99@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 4
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 9
	jne	$LN97@ForInitAnd
$LN99@ForInitAnd:

; 1191 :           if ((0 == _memicmp(init, "BYTE PTR", 8)) ||                   //reax=BYTE PTR al
; 1192 :             (0 == _memicmp(init, "BPTR", 4)) ||
; 1193 :             (0 == _memicmp(init, "WPTR", 4)) ||

	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG11654
	lea	rcx, QWORD PTR init$[rsp]
	call	_memicmp
	test	eax, eax
	je	SHORT $LN102@ForInitAnd
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11655
	lea	rcx, QWORD PTR init$[rsp]
	call	_memicmp
	test	eax, eax
	je	SHORT $LN102@ForInitAnd
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11656
	lea	rcx, QWORD PTR init$[rsp]
	call	_memicmp
	test	eax, eax
	je	SHORT $LN102@ForInitAnd
	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG11657
	lea	rcx, QWORD PTR init$[rsp]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN100@ForInitAnd
$LN102@ForInitAnd:

; 1194 :             (0 == _memicmp(init, "WORD PTR", 8)))                     //reax=WORD PTR ax
; 1195 : 
; 1196 :             WriteAsmLine(" movzx  ", param, init);                      //movzx reax,ax

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11658
	call	WriteAsmLine
	jmp	SHORT $LN101@ForInitAnd
$LN100@ForInitAnd:

; 1197 :           else if (0 == _memicmp(init, "ADDR", 4))

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11661
	lea	rcx, QWORD PTR init$[rsp]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN103@ForInitAnd

; 1198 :             WriteAsmLine(" lea  ", param, init + 5);

	lea	rax, QWORD PTR init$[rsp+5]
	mov	r8, rax
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11662
	call	WriteAsmLine
	jmp	SHORT $LN104@ForInitAnd
$LN103@ForInitAnd:

; 1199 :           else WriteAsmLine(" mov  ", param, init);

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11663
	call	WriteAsmLine
$LN104@ForInitAnd:
$LN101@ForInitAnd:

; 1200 :         }

	jmp	$LN98@ForInitAnd
$LN97@ForInitAnd:

; 1201 :         else if ((strlen(op) == 1) && ((init[6] == ' ') || (init[6] == '\t'))) {

	lea	rcx, QWORD PTR op$[rsp]
	call	strlen
	cmp	rax, 1
	jne	$LN105@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 6
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN107@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 6
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 9
	jne	SHORT $LN105@ForInitAnd
$LN107@ForInitAnd:

; 1202 :           if (0 == _memicmp(init, "OFFSET", 6))

	mov	r8d, 6
	lea	rdx, OFFSET FLAT:$SG11669
	lea	rcx, QWORD PTR init$[rsp]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN108@ForInitAnd

; 1203 :             WriteAsmLine(" lea  ", param, init + 7);

	lea	rax, QWORD PTR init$[rsp+7]
	mov	r8, rax
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11670
	call	WriteAsmLine
	jmp	SHORT $LN109@ForInitAnd
$LN108@ForInitAnd:

; 1204 :           else WriteAsmLine(" mov  ", param, init);

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11671
	call	WriteAsmLine
$LN109@ForInitAnd:

; 1205 :         }

	jmp	$LN106@ForInitAnd
$LN105@ForInitAnd:

; 1206 :         else if ((strlen(op) == 1) && ((init[5] == ' ') || (init[5] == '\t'))) {            //op is '='

	lea	rcx, QWORD PTR op$[rsp]
	call	strlen
	cmp	rax, 1
	jne	$LN110@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 5
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN112@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 5
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 9
	jne	$LN110@ForInitAnd
$LN112@ForInitAnd:

; 1207 :           if ((0 == _memicmp(init, "DWORD PTR", 9) || 0 == _memicmp(init, "DPTR", 4)

	mov	r8d, 9
	lea	rdx, OFFSET FLAT:$SG11678
	lea	rcx, QWORD PTR init$[rsp]
	call	_memicmp
	test	eax, eax
	je	SHORT $LN115@ForInitAnd
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11679
	lea	rcx, QWORD PTR init$[rsp]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN113@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR param$[rsp+rax]
	cmp	eax, 114				; 00000072H
	je	SHORT $LN116@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR param$[rsp+rax]
	cmp	eax, 82					; 00000052H
	jne	SHORT $LN113@ForInitAnd
$LN116@ForInitAnd:
$LN115@ForInitAnd:

; 1208 :             && (param[0] == 'r' || param[0] == 'R'))) 							   //rax=DWORD PTR eax
; 1209 :             WriteAsmLine(" movsxd  ", param, init);								     //movsxd rax,eax

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11681
	call	WriteAsmLine
	jmp	SHORT $LN114@ForInitAnd
$LN113@ForInitAnd:

; 1210 :           else WriteAsmLine(" mov  ", param, init);

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11682
	call	WriteAsmLine
$LN114@ForInitAnd:

; 1211 :         }

	jmp	$LN111@ForInitAnd
$LN110@ForInitAnd:

; 1212 :         else if ((strlen(op) == 1) && brct) {											    //op is '='

	lea	rcx, QWORD PTR op$[rsp]
	call	strlen
	cmp	rax, 1
	jne	$LN117@ForInitAnd
	movzx	eax, BYTE PTR brct$[rsp]
	test	eax, eax
	je	$LN117@ForInitAnd

; 1213 :           for (j = strlen(init); j; j--) {

	lea	rcx, QWORD PTR init$[rsp]
	call	strlen
	mov	DWORD PTR j$[rsp], eax
	jmp	SHORT $LN15@ForInitAnd
$LN13@ForInitAnd:
	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	mov	DWORD PTR j$[rsp], eax
$LN15@ForInitAnd:
	cmp	DWORD PTR j$[rsp], 0
	je	$LN14@ForInitAnd

; 1214 :             if (init[j] == ')') init[j] = NULLC;

	movsxd	rax, DWORD PTR j$[rsp]
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN119@ForInitAnd
	movsxd	rax, DWORD PTR j$[rsp]
	mov	QWORD PTR $T7[rsp], rax
	cmp	QWORD PTR $T7[rsp], 256			; 00000100H
	jae	SHORT $LN140@ForInitAnd
	jmp	SHORT $LN141@ForInitAnd
$LN140@ForInitAnd:
	call	__report_rangecheckfailure
$LN141@ForInitAnd:
	mov	rax, QWORD PTR $T7[rsp]
	mov	BYTE PTR init$[rsp+rax], 0
$LN119@ForInitAnd:

; 1215 :             if (init[j] == '(') {

	movsxd	rax, DWORD PTR j$[rsp]
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN120@ForInitAnd

; 1216 :               for (p = init, p += j; *p; p++) {

	lea	rax, QWORD PTR init$[rsp]
	mov	QWORD PTR p$[rsp], rax
	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN18@ForInitAnd
$LN16@ForInitAnd:
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN18@ForInitAnd:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN17@ForInitAnd

; 1217 :                 if (*p == ',' && cnt) --cnt;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN121@ForInitAnd
	cmp	DWORD PTR cnt$[rsp], 0
	je	SHORT $LN121@ForInitAnd
	mov	eax, DWORD PTR cnt$[rsp]
	dec	eax
	mov	DWORD PTR cnt$[rsp], eax
$LN121@ForInitAnd:

; 1218 :               }

	jmp	SHORT $LN16@ForInitAnd
$LN17@ForInitAnd:

; 1219 :               init[j] = ',';

	movsxd	rax, DWORD PTR j$[rsp]
	mov	BYTE PTR init$[rsp+rax], 44		; 0000002cH
$LN120@ForInitAnd:

; 1220 :             }
; 1221 :           }

	jmp	$LN13@ForInitAnd
$LN14@ForInitAnd:

; 1222 :           strcpy(codebuff, " invoke  ");

	lea	rdx, OFFSET FLAT:$SG11688
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 1223 :           strcat(codebuff, init);

	lea	rdx, QWORD PTR init$[rsp]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 1224 :           AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1225 :           WriteAsmLine(" mov  ", param, reax[ModuleInfo.Ofssize]);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:reax
	mov	r8, QWORD PTR [rcx+rax*8]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11689
	call	WriteAsmLine

; 1226 :           brct = FALSE;

	mov	BYTE PTR brct$[rsp], 0

; 1227 :         }

	jmp	SHORT $LN118@ForInitAnd
$LN117@ForInitAnd:

; 1228 :         else {
; 1229 :           if (strlen(op) == 1)

	lea	rcx, QWORD PTR op$[rsp]
	call	strlen
	cmp	rax, 1
	jne	SHORT $LN122@ForInitAnd

; 1230 :             WriteAsmLine(" mov  ", param, init);

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11692
	call	WriteAsmLine
	jmp	SHORT $LN123@ForInitAnd
$LN122@ForInitAnd:

; 1231 :           else
; 1232 :             WriteAsmLine(codebuff, param, init);

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	WriteAsmLine
$LN123@ForInitAnd:
$LN118@ForInitAnd:
$LN111@ForInitAnd:
$LN106@ForInitAnd:
$LN98@ForInitAnd:
$LN96@ForInitAnd:

; 1233 :         }
; 1234 :       }

	jmp	$LN94@ForInitAnd
$LN93@ForInitAnd:

; 1235 :       else
; 1236 :       {
; 1237 :         if (init[0] == 39 && init[2] == 39)

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN124@ForInitAnd
	mov	eax, 1
	imul	rax, rax, 2
	movsx	eax, BYTE PTR init$[rsp+rax]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN124@ForInitAnd

; 1238 :           WriteAsmLine(" mov  byte ptr ", param, init);

	lea	r8, QWORD PTR init$[rsp]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG11695
	call	WriteAsmLine
	jmp	SHORT $LN125@ForInitAnd
$LN124@ForInitAnd:

; 1239 :         else {
; 1240 :           WriteAsmLine(" mov  ", reax[ModuleInfo.Ofssize], init);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:reax
	lea	r8, QWORD PTR init$[rsp]
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, OFFSET FLAT:$SG11696
	call	WriteAsmLine

; 1241 :           WriteAsmLine(codebuff, param, reax[ModuleInfo.Ofssize]);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:reax
	mov	r8, QWORD PTR [rcx+rax*8]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	WriteAsmLine
$LN125@ForInitAnd:
$LN94@ForInitAnd:
$LN22@ForInitAnd:
$skip$143:

; 1242 :         }
; 1243 :       }
; 1244 :     }
; 1245 :   skip:
; 1246 :     if (cnt) cnt--;

	cmp	DWORD PTR cnt$[rsp], 0
	je	SHORT $LN126@ForInitAnd
	mov	eax, DWORD PTR cnt$[rsp]
	dec	eax
	mov	DWORD PTR cnt$[rsp], eax
$LN126@ForInitAnd:

; 1247 :   } while (cnt);

	cmp	DWORD PTR cnt$[rsp], 0
	jne	$LN4@ForInitAnd

; 1248 :   return(NOT_ERROR);

	xor	eax, eax
$LN127@ForInitAnd:

; 1249 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 920				; 00000398H
	ret	0
ForInitAndNext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
codebuff$ = 32
__$ArrayPad$ = 288
cmd$ = 320
s1$ = 328
s2$ = 336
WriteAsmLine PROC

; 995  : static void WriteAsmLine(const char *cmd, const char *s1, const char *s2) {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 312				; 00000138H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 996  :   char codebuff[256];
; 997  :   strcpy(codebuff, cmd);

	mov	rdx, QWORD PTR cmd$[rsp]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcpy

; 998  :   strcat(codebuff, s1);

	mov	rdx, QWORD PTR s1$[rsp]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 999  :   strcat(codebuff, ", ");

	lea	rdx, OFFSET FLAT:$SG11487
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 1000 :   strcat(codebuff, s2);

	mov	rdx, QWORD PTR s2$[rsp]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	strcat

; 1001 :   AddLineQueue(codebuff);				// MOV RAX,param

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1002 :   return;
; 1003 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 312				; 00000138H
	ret	0
WriteAsmLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
NL$ = 32
i$ = 36
lines$ = 40
addchars$ = 44
px$ = 48
p$ = 80
CheckCXZLines PROC

; 938  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 939  :   int lines = 0;

	mov	DWORD PTR lines$[rsp], 0

; 940  :   int i;
; 941  :   int addchars;
; 942  :   char *px;
; 943  :   bool NL = TRUE;

	mov	BYTE PTR NL$[rsp], 1

; 944  : 
; 945  :   DebugMsg1(("CheckCXZLines enter, p=>%s<\n", p));

	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, OFFSET FLAT:$SG11453
	call	DoDebugMsg1

; 946  :   /* syntax ".untilcxz 1" has a problem: there's no "jmp" generated at all.
; 947  :   * if this syntax is to be supported, activate the #if below.
; 948  :   */
; 949  :   for (; *p; p++) {

	jmp	SHORT $LN4@CheckCXZLi
$LN2@CheckCXZLi:
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN4@CheckCXZLi:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@CheckCXZLi

; 950  :     if (*p == EOLCHAR) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 94					; 0000005eH
	jne	SHORT $LN8@CheckCXZLi

; 951  :       NL = TRUE;

	mov	BYTE PTR NL$[rsp], 1

; 952  :       lines++;

	mov	eax, DWORD PTR lines$[rsp]
	inc	eax
	mov	DWORD PTR lines$[rsp], eax

; 953  :     }

	jmp	$LN9@CheckCXZLi
$LN8@CheckCXZLi:

; 954  :     else if (NL) {

	movzx	eax, BYTE PTR NL$[rsp]
	test	eax, eax
	je	$LN10@CheckCXZLi

; 955  :       NL = FALSE;

	mov	BYTE PTR NL$[rsp], 0

; 956  :       if (*p == 'j') {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 106				; 0000006aH
	jne	$LN11@CheckCXZLi

; 957  :         p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 958  :         /* v2.06: rewritten */
; 959  :         if (*p == 'm' && lines == 0) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 109				; 0000006dH
	jne	SHORT $LN12@CheckCXZLi
	cmp	DWORD PTR lines$[rsp], 0
	jne	SHORT $LN12@CheckCXZLi

; 960  :           addchars = 2; /* make room for 2 chars, to replace "jmp" by "loope" */

	mov	DWORD PTR addchars$[rsp], 2

; 961  :           px = "loope";

	lea	rax, OFFSET FLAT:$SG11460
	mov	QWORD PTR px$[rsp], rax

; 962  :         }

	jmp	SHORT $LN13@CheckCXZLi
$LN12@CheckCXZLi:

; 963  :         else if (lines == 1 && (*p == 'z' || (*p == 'n' && *(p + 1) == 'z'))) {

	cmp	DWORD PTR lines$[rsp], 1
	jne	SHORT $LN14@CheckCXZLi
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 122				; 0000007aH
	je	SHORT $LN16@CheckCXZLi
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 110				; 0000006eH
	jne	SHORT $LN14@CheckCXZLi
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 122				; 0000007aH
	jne	SHORT $LN14@CheckCXZLi
$LN16@CheckCXZLi:

; 964  :           addchars = 3; /* make room for 3 chars, to replace "jz"/"jnz" by "loopz"/"loopnz" */

	mov	DWORD PTR addchars$[rsp], 3

; 965  :           px = "loop";

	lea	rax, OFFSET FLAT:$SG11464
	mov	QWORD PTR px$[rsp], rax

; 966  :         }

	jmp	SHORT $LN15@CheckCXZLi
$LN14@CheckCXZLi:

; 967  :         else
; 968  :           return(ERROR); /* anything else is "too complex" */

	mov	eax, -1
	jmp	$LN1@CheckCXZLi
$LN15@CheckCXZLi:
$LN13@CheckCXZLi:

; 969  :                          //replace_instr:
; 970  :         for (p--, i = strlen(p); i >= 0; i--) {

	mov	rax, QWORD PTR p$[rsp]
	dec	rax
	mov	QWORD PTR p$[rsp], rax
	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN7@CheckCXZLi
$LN5@CheckCXZLi:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@CheckCXZLi:
	cmp	DWORD PTR i$[rsp], 0
	jl	SHORT $LN6@CheckCXZLi

; 971  :           *(p + addchars + i) = *(p + i);

	movsxd	rax, DWORD PTR i$[rsp]
	movsxd	rcx, DWORD PTR addchars$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movsxd	rdx, DWORD PTR i$[rsp]
	mov	r8, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rcx+rdx], al

; 972  :         }

	jmp	SHORT $LN5@CheckCXZLi
$LN6@CheckCXZLi:

; 973  :         memcpy(p, px, strlen(px));

	mov	rcx, QWORD PTR px$[rsp]
	call	strlen
	mov	r8, rax
	mov	rdx, QWORD PTR px$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	memcpy
$LN11@CheckCXZLi:
$LN10@CheckCXZLi:
$LN9@CheckCXZLi:

; 974  :       }
; 975  : #if 0 /* handle ".untilcxz 1" like masm does */
; 976  :       else if (*p == ' ' && *(p + 1) == EOLCHAR && lines == 0) {
; 977  :         p++;
; 978  :         GetLabelStr(hll->labels[LSTART], p);
; 979  :         strcat(p, EOLSTR);
; 980  :         addchars = 5;
; 981  :         px = "loope";
; 982  :         goto replace_instr;
; 983  :       }
; 984  : #endif
; 985  :     }
; 986  :   }

	jmp	$LN2@CheckCXZLi
$LN3@CheckCXZLi:

; 987  :   if (lines > 2)

	cmp	DWORD PTR lines$[rsp], 2
	jle	SHORT $LN17@CheckCXZLi

; 988  :     return(ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@CheckCXZLi
$LN17@CheckCXZLi:

; 989  :   return(NOT_ERROR);

	xor	eax, eax
$LN1@CheckCXZLi:

; 990  : }

	add	rsp, 72					; 00000048H
	ret	0
CheckCXZLines ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
hllop$ = 64
hll$ = 96
i$ = 104
tokenarray$ = 112
ilabel$ = 120
is_true$ = 128
buffer$ = 136
EvaluateHllExpression PROC

; 913  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 914  :   struct hll_opnd hllop = { NULL, 0 };

	mov	QWORD PTR hllop$[rsp], 0
	mov	DWORD PTR hllop$[rsp+8], 0

; 915  : 
; 916  :   DebugMsg1(("EvaluateHllExpression enter\n"));

	lea	rcx, OFFSET FLAT:$SG11434
	call	DoDebugMsg1

; 917  : 
; 918  :   *buffer = NULLC;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rax], 0

; 919  :   if (ERROR == GetExpression(hll, i, tokenarray, ilabel, is_true, buffer, &hllop))

	lea	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR ilabel$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetExpression
	cmp	eax, -1
	jne	SHORT $LN2@EvaluateHl

; 920  :     return(ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@EvaluateHl
$LN2@EvaluateHl:

; 921  :   /* v2.11: changed */
; 922  :   //if ( *buffer == EOLCHAR ) {
; 923  :   //DebugMsg(( "EvaluateHllExpression: EOL at pos 0 in line buffer\n" ));
; 924  :   if (tokenarray[*i].token != T_FINAL) {

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN3@EvaluateHl

; 925  :     DebugMsg(("EvaluateHllExpression: unexpected tokens >%s<\n", tokenarray[*i].tokpos));

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11437
	call	DoDebugMsg

; 926  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, 199				; 000000c7H
	call	EmitError
	jmp	SHORT $LN1@EvaluateHl
$LN3@EvaluateHl:

; 927  :   }
; 928  :   return(NOT_ERROR);

	xor	eax, eax
$LN1@EvaluateHl:

; 929  : }

	add	rsp, 88					; 00000058H
	ret	0
EvaluateHllExpression ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
tv65 = 32
start$ = 40
src$ = 64
QueueTestLines PROC

; 876  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 877  :   char *start;
; 878  : 
; 879  :   DebugMsg1(("QueueTestLines(\"%s\") enter\n", src ? src : "NULL"));

	cmp	QWORD PTR src$[rsp], 0
	je	SHORT $LN7@QueueTestL
	mov	rax, QWORD PTR src$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN8@QueueTestL
$LN7@QueueTestL:
	lea	rax, OFFSET FLAT:$SG11413
	mov	QWORD PTR tv65[rsp], rax
$LN8@QueueTestL:
	mov	rdx, QWORD PTR tv65[rsp]
	lea	rcx, OFFSET FLAT:$SG11414
	call	DoDebugMsg1
$LN2@QueueTestL:

; 880  :   while (src) {

	cmp	QWORD PTR src$[rsp], 0
	je	SHORT $LN3@QueueTestL

; 881  :     //if (*src == ' ') src++; /* v2.11: obsolete */
; 882  :     start = src;

	mov	rax, QWORD PTR src$[rsp]
	mov	QWORD PTR start$[rsp], rax

; 883  :     if (src = strchr(src, EOLCHAR))

	mov	edx, 94					; 0000005eH
	mov	rcx, QWORD PTR src$[rsp]
	call	strchr
	mov	QWORD PTR src$[rsp], rax
	cmp	QWORD PTR src$[rsp], 0
	je	SHORT $LN4@QueueTestL

; 884  :       *src++ = NULLC;

	mov	rax, QWORD PTR src$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN4@QueueTestL:

; 885  :     if (*start)

	mov	rax, QWORD PTR start$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN5@QueueTestL

; 886  :       AddLineQueue(start);

	mov	rcx, QWORD PTR start$[rsp]
	call	AddLineQueue
$LN5@QueueTestL:

; 887  :   }

	jmp	SHORT $LN2@QueueTestL
$LN3@QueueTestL:

; 888  : 
; 889  :   DebugMsg1(("QueueTestLines exit\n"));

	lea	rcx, OFFSET FLAT:$SG11417
	call	DoDebugMsg1

; 890  :   return(NOT_ERROR);

	xor	eax, eax

; 891  : }

	add	rsp, 56					; 00000038H
	ret	0
QueueTestLines ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
truelabel$ = 64
ptr$ = 72
p$1 = 80
tv91 = 88
hll$ = 112
i$ = 120
tokenarray$ = 128
ilabel$ = 136
is_true$ = 144
buffer$ = 152
hllop$ = 160
GetAndExpression PROC

; 724  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 725  :   char *ptr = buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR ptr$[rsp], rax

; 726  :   uint_32 truelabel = 0;

	mov	DWORD PTR truelabel$[rsp], 0

; 727  :   //char buff[16];
; 728  :   //char *nlabel;
; 729  :   //char *olabel;
; 730  : 
; 731  :   DebugMsg1(("%u GetAndExpression(>%.32s< buf=>%s<) enter\n", evallvl, tokenarray[*i].tokpos, buffer));

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	r9, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11343
	call	DoDebugMsg1

; 732  : 
; 733  :   if (ERROR == GetSimpleExpression(hll, i, tokenarray, ilabel, is_true, ptr, hllop))

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR ilabel$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetSimpleExpression
	cmp	eax, -1
	jne	SHORT $LN4@GetAndExpr

; 734  :     return(ERROR);

	mov	eax, -1
	jmp	$LN1@GetAndExpr
$LN4@GetAndExpr:
$LN2@GetAndExpr:

; 735  :   while (COP_AND == GetCOp(&tokenarray[*i])) {

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	GetCOp
	cmp	eax, 7
	jne	$LN3@GetAndExpr

; 736  : 
; 737  :     (*i)++;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax

; 738  :     DebugMsg1(("%u GetAndExpression: &&-operator found, is_true=%u, lastjmp=%s\n", evallvl, is_true, hllop->lastjmp ? hllop->lastjmp : "NULL"));

	mov	rax, QWORD PTR hllop$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN12@GetAndExpr
	mov	rax, QWORD PTR hllop$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv91[rsp], rax
	jmp	SHORT $LN13@GetAndExpr
$LN12@GetAndExpr:
	lea	rax, OFFSET FLAT:$SG11345
	mov	QWORD PTR tv91[rsp], rax
$LN13@GetAndExpr:
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	r9, QWORD PTR tv91[rsp]
	mov	r8d, eax
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11346
	call	DoDebugMsg1

; 739  : 
; 740  :     if (is_true) {

	movzx	eax, BYTE PTR is_true$[rsp]
	test	eax, eax
	je	$LN5@GetAndExpr

; 741  :       /* todo: please describe what's done here and why! */
; 742  :       if (hllop->lastjmp) {

	mov	rax, QWORD PTR hllop$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN6@GetAndExpr

; 743  :         char *p = hllop->lastjmp;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$1[rsp], rax

; 744  :         InvertJump(p);          /* step 1 */

	mov	rcx, QWORD PTR p$1[rsp]
	call	InvertJump

; 745  :         if (truelabel == 0)     /* step 2 */

	cmp	DWORD PTR truelabel$[rsp], 0
	jne	SHORT $LN7@GetAndExpr

; 746  :           truelabel = GetHllLabel();

	call	GetHllLabel
	mov	DWORD PTR truelabel$[rsp], eax
$LN7@GetAndExpr:

; 747  : 
; 748  :         if (*p && strlen(p) < 11) {/* v2.11: there might be a 0 at lastjmp */

	mov	rax, QWORD PTR p$1[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN8@GetAndExpr
	mov	rcx, QWORD PTR p$1[rsp]
	call	strlen
	cmp	rax, 11
	jae	SHORT $LN8@GetAndExpr

; 749  :           p += 4;               /* skip 'jcc ' or 'jmp ' */

	mov	rax, QWORD PTR p$1[rsp]
	add	rax, 4
	mov	QWORD PTR p$1[rsp], rax

; 750  :           GetLabelStr(truelabel, p);

	mov	rdx, QWORD PTR p$1[rsp]
	mov	ecx, DWORD PTR truelabel$[rsp]
	call	GetLabelStr

; 751  :           strcat(p, EOLSTR);

	lea	rdx, OFFSET FLAT:$SG11351
	mov	rcx, QWORD PTR p$1[rsp]
	call	strcat
$LN8@GetAndExpr:

; 752  :         }
; 753  : 
; 754  :         DebugMsg1(("%u GetAndExpression: jmp inverted >%s<\n", evallvl, hllop->lastjmp));

	mov	rax, QWORD PTR hllop$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11352
	call	DoDebugMsg1

; 755  :         ReplaceLabel(buffer, GetLabel(hll, ilabel), truelabel);

	mov	edx, DWORD PTR ilabel$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetLabel
	mov	r8d, DWORD PTR truelabel$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR buffer$[rsp]
	call	ReplaceLabel

; 756  :         hllop->lastjmp = NULL;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rax], 0
$LN6@GetAndExpr:
$LN5@GetAndExpr:

; 757  :       }
; 758  :     }
; 759  :     ptr += strlen(ptr);

	mov	rcx, QWORD PTR ptr$[rsp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rsp], rax

; 760  :     hllop->lasttruelabel = 0; /* v2.08 */

	mov	rax, QWORD PTR hllop$[rsp]
	mov	DWORD PTR [rax+8], 0

; 761  :     if (ERROR == GetSimpleExpression(hll, i, tokenarray, ilabel, is_true, ptr, hllop))

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR ilabel$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetSimpleExpression
	cmp	eax, -1
	jne	SHORT $LN9@GetAndExpr

; 762  :       return(ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@GetAndExpr
$LN9@GetAndExpr:

; 763  :   };

	jmp	$LN2@GetAndExpr
$LN3@GetAndExpr:

; 764  : 
; 765  :   if (truelabel > 0) {

	cmp	DWORD PTR truelabel$[rsp], 0
	jbe	SHORT $LN10@GetAndExpr

; 766  :     ptr += strlen(ptr);

	mov	rcx, QWORD PTR ptr$[rsp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rsp], rax

; 767  :     GetLabelStr(truelabel, ptr);

	mov	rdx, QWORD PTR ptr$[rsp]
	mov	ecx, DWORD PTR truelabel$[rsp]
	call	GetLabelStr

; 768  :     strcat(ptr, LABELQUAL EOLSTR);

	lea	rdx, OFFSET FLAT:$SG11355
	mov	rcx, QWORD PTR ptr$[rsp]
	call	strcat

; 769  :     DebugMsg1(("%u GetAndExpression: label added >%s<\n", evallvl, ptr));

	mov	r8, QWORD PTR ptr$[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11356
	call	DoDebugMsg1

; 770  :     hllop->lastjmp = NULL;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rax], 0
$LN10@GetAndExpr:

; 771  :   }
; 772  :   return(NOT_ERROR);

	xor	eax, eax
$LN1@GetAndExpr:

; 773  : }

	add	rsp, 104				; 00000068H
	ret	0
GetAndExpression ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
i$ = 48
newlbl$ = 56
oldlbl$ = 72
__$ArrayPad$ = 88
p$ = 112
olabel$ = 120
nlabel$ = 128
ReplaceLabel PROC

; 703  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 704  :   char oldlbl[16];
; 705  :   char newlbl[16];
; 706  :   int i;
; 707  : 
; 708  :   GetLabelStr(olabel, oldlbl);

	lea	rdx, QWORD PTR oldlbl$[rsp]
	mov	ecx, DWORD PTR olabel$[rsp]
	call	GetLabelStr

; 709  :   GetLabelStr(nlabel, newlbl);

	lea	rdx, QWORD PTR newlbl$[rsp]
	mov	ecx, DWORD PTR nlabel$[rsp]
	call	GetLabelStr

; 710  : 
; 711  :   i = strlen(newlbl);

	lea	rcx, QWORD PTR newlbl$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax

; 712  : 
; 713  :   DebugMsg1(("%u ReplaceLabel(%s->%s, >%s<)\n", evallvl, oldlbl, newlbl, p));

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR newlbl$[rsp]
	lea	r8, QWORD PTR oldlbl$[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11319
	call	DoDebugMsg1
$LN2@ReplaceLab:

; 714  :   while (p = strstr(p, oldlbl)) {

	lea	rdx, QWORD PTR oldlbl$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	strstr
	mov	QWORD PTR p$[rsp], rax
	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN3@ReplaceLab

; 715  :     memcpy(p, newlbl, i);

	movsxd	rax, DWORD PTR i$[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR newlbl$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	memcpy

; 716  :     p += i;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 717  :   }

	jmp	SHORT $LN2@ReplaceLab
$LN3@ReplaceLab:

; 718  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
ReplaceLabel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
p$ = 48
InvertJump PROC

; 651  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 652  :   if (*p == NULLC) { /* v2.11: convert 0 to "jmp" */

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN2@InvertJump

; 653  :     strcpy(p, "jmp ");

	lea	rdx, OFFSET FLAT:$SG11289
	mov	rcx, QWORD PTR p$[rsp]
	call	strcpy

; 654  :     return;

	jmp	$LN1@InvertJump
$LN2@InvertJump:

; 655  :   }
; 656  : 
; 657  :   p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 658  :   if (*p == 'e' || *p == 'z' || *p == 'c' || *p == 's' || *p == 'p' || *p == 'o') {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 101				; 00000065H
	je	SHORT $LN5@InvertJump
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 122				; 0000007aH
	je	SHORT $LN5@InvertJump
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 99					; 00000063H
	je	SHORT $LN5@InvertJump
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 115				; 00000073H
	je	SHORT $LN5@InvertJump
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 112				; 00000070H
	je	SHORT $LN5@InvertJump
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 111				; 0000006fH
	jne	SHORT $LN3@InvertJump
$LN5@InvertJump:

; 659  :     *(p + 1) = *p;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax+1], cl

; 660  :     *p = 'n';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 110			; 0000006eH

; 661  :     return;

	jmp	$LN1@InvertJump

; 662  :   }

	jmp	$LN4@InvertJump
$LN3@InvertJump:

; 663  :   else if (*p == 'n') {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 110				; 0000006eH
	jne	SHORT $LN6@InvertJump

; 664  :     *p = *(p + 1);

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx+1]
	mov	BYTE PTR [rax], cl

; 665  :     *(p + 1) = ' ';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax+1], 32			; 00000020H

; 666  :     return;

	jmp	$LN1@InvertJump

; 667  :   }

	jmp	$LN7@InvertJump
$LN6@InvertJump:

; 668  :   else if (*p == 'a') {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 97					; 00000061H
	jne	SHORT $LN8@InvertJump

; 669  :     *p++ = 'b';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 98			; 00000062H
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 670  :   }

	jmp	$LN9@InvertJump
$LN8@InvertJump:

; 671  :   else if (*p == 'b') {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 98					; 00000062H
	jne	SHORT $LN10@InvertJump

; 672  :     *p++ = 'a';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 97			; 00000061H
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 673  :   }

	jmp	SHORT $LN11@InvertJump
$LN10@InvertJump:

; 674  :   else if (*p == 'g') {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 103				; 00000067H
	jne	SHORT $LN12@InvertJump

; 675  :     *p++ = 'l';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 108			; 0000006cH
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 676  :   }

	jmp	SHORT $LN13@InvertJump
$LN12@InvertJump:

; 677  :   else if (*p == 'l') {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 108				; 0000006cH
	jne	SHORT $LN14@InvertJump

; 678  :     *p++ = 'g';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 103			; 00000067H
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 679  :   }

	jmp	SHORT $LN15@InvertJump
$LN14@InvertJump:

; 680  :   else {
; 681  :     /* v2.11: convert "jmp" to 0 */
; 682  :     if (*p == 'm') {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 109				; 0000006dH
	jne	SHORT $LN16@InvertJump

; 683  :       p--;

	mov	rax, QWORD PTR p$[rsp]
	dec	rax
	mov	QWORD PTR p$[rsp], rax

; 684  :       *p = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 0
$LN16@InvertJump:

; 685  :     }
; 686  :     return;

	jmp	SHORT $LN1@InvertJump
$LN15@InvertJump:
$LN13@InvertJump:
$LN11@InvertJump:
$LN9@InvertJump:
$LN7@InvertJump:
$LN4@InvertJump:

; 687  :   }
; 688  :   if (*p == 'e')

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 101				; 00000065H
	jne	SHORT $LN17@InvertJump

; 689  :     *p = ' ';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
	jmp	SHORT $LN18@InvertJump
$LN17@InvertJump:

; 690  :   else
; 691  :     *p = 'e';

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 101			; 00000065H
$LN18@InvertJump:
$LN1@InvertJump:

; 692  :   return;
; 693  : }

	add	rsp, 40					; 00000028H
	ret	0
InvertJump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
op$ = 64
op1_pos$ = 68
instr$ = 72
op1_end$ = 76
p$ = 80
j$1 = 88
brcnt$2 = 92
label$ = 96
tv252 = 100
tv230 = 104
tv226 = 108
op2_end$ = 112
op2_pos$ = 116
tv379 = 120
tv424 = 124
tv426 = 128
op1$ = 144
op2$ = 256
hll$ = 384
i$ = 392
tokenarray$ = 400
ilabel$ = 408
is_true$ = 416
buffer$ = 424
hllop$ = 432
GetSimpleExpression PROC

; 450  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 376				; 00000178H

; 451  :   enum c_bop op;
; 452  :   char instr;
; 453  :   int op1_pos;
; 454  :   int op1_end;
; 455  :   int op2_pos;
; 456  :   int op2_end;
; 457  :   char *p;
; 458  :   struct expr op1;
; 459  :   struct expr op2;
; 460  :   uint_32 label;
; 461  : 
; 462  :   DebugMsg1(("%u GetSimpleExpression(>%.32s< buf=>%s<) enter\n", evallvl, tokenarray[*i].tokpos, buffer));

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	r9, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11228
	call	DoDebugMsg1
$LN2@GetSimpleE:

; 463  : 
; 464  :   while (tokenarray[*i].string_ptr[0] == '!' && tokenarray[*i].string_ptr[1] == '\0') {

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rdx+rax+8]
	movsx	eax, BYTE PTR [rax+rcx]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN3@GetSimpleE
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rdx+rax+8]
	movsx	eax, BYTE PTR [rax+rcx]
	test	eax, eax
	jne	SHORT $LN3@GetSimpleE

; 465  :     (*i)++; //GetCOp( i );

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax

; 466  :     is_true = 1 - is_true;

	movzx	eax, BYTE PTR is_true$[rsp]
	mov	ecx, 1
	sub	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR is_true$[rsp], al

; 467  :   }

	jmp	$LN2@GetSimpleE
$LN3@GetSimpleE:

; 468  : 
; 469  :   /* the problem with '()' is that is might enclose just a standard Masm
; 470  :   * expression or a "hll" expression. The first case is to be handled
; 471  :   * entirely by the expression evaluator, while the latter case is to be
; 472  :   * handled HERE!
; 473  :   */
; 474  :   if (tokenarray[*i].token == T_OP_BRACKET) {

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	$LN11@GetSimpleE

; 475  :     int brcnt;
; 476  :     int j;
; 477  :     for (brcnt = 1, j = *i + 1; tokenarray[j].token != T_FINAL; j++) {

	mov	DWORD PTR brcnt$2[rsp], 1
	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	DWORD PTR j$1[rsp], eax
	jmp	SHORT $LN6@GetSimpleE
$LN4@GetSimpleE:
	mov	eax, DWORD PTR j$1[rsp]
	inc	eax
	mov	DWORD PTR j$1[rsp], eax
$LN6@GetSimpleE:
	movsxd	rax, DWORD PTR j$1[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN5@GetSimpleE

; 478  :       if (tokenarray[j].token == T_OP_BRACKET)

	movsxd	rax, DWORD PTR j$1[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN12@GetSimpleE

; 479  :         brcnt++;

	mov	eax, DWORD PTR brcnt$2[rsp]
	inc	eax
	mov	DWORD PTR brcnt$2[rsp], eax
	jmp	SHORT $LN13@GetSimpleE
$LN12@GetSimpleE:

; 480  :       else if (tokenarray[j].token == T_CL_BRACKET) {

	movsxd	rax, DWORD PTR j$1[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN14@GetSimpleE

; 481  :         brcnt--;

	mov	eax, DWORD PTR brcnt$2[rsp]
	dec	eax
	mov	DWORD PTR brcnt$2[rsp], eax

; 482  :         if (brcnt == 0) /* a standard Masm expression? */

	cmp	DWORD PTR brcnt$2[rsp], 0
	jne	SHORT $LN16@GetSimpleE

; 483  :           break;

	jmp	SHORT $LN5@GetSimpleE
$LN16@GetSimpleE:

; 484  :       }

	jmp	SHORT $LN15@GetSimpleE
$LN14@GetSimpleE:

; 485  :       else if ((GetCOp(&tokenarray[j])) != COP_NONE)

	movsxd	rax, DWORD PTR j$1[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	GetCOp
	test	eax, eax
	je	SHORT $LN17@GetSimpleE

; 486  :         break;

	jmp	SHORT $LN5@GetSimpleE
$LN17@GetSimpleE:
$LN15@GetSimpleE:
$LN13@GetSimpleE:

; 487  :     }

	jmp	$LN4@GetSimpleE
$LN5@GetSimpleE:

; 488  :     if (brcnt) {

	cmp	DWORD PTR brcnt$2[rsp], 0
	je	$LN18@GetSimpleE

; 489  :       (*i)++;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax

; 490  :       DebugMsg1(("%u GetSimpleExpression: calling GetExpression, i=%u\n", evallvl, *i));

	mov	rax, QWORD PTR i$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11237
	call	DoDebugMsg1

; 491  :       if (ERROR == GetExpression(hll, i, tokenarray, ilabel, is_true, buffer, hllop))

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR ilabel$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetExpression
	cmp	eax, -1
	jne	SHORT $LN19@GetSimpleE

; 492  :         return(ERROR);

	mov	eax, -1
	jmp	$LN1@GetSimpleE
$LN19@GetSimpleE:

; 493  : 
; 494  :       if (tokenarray[*i].token != T_CL_BRACKET) {

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN20@GetSimpleE

; 495  :         //if (( tokenarray[*i].token == T_FINAL ) || ( tokenarray[*i].token == T_CL_BRACKET ))
; 496  :         DebugMsg(("GetSimpleExpression: expected ')', found: %s\n", tokenarray[*i].string_ptr));

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11240
	call	DoDebugMsg

; 497  :         return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, 199				; 000000c7H
	call	EmitError
	jmp	$LN1@GetSimpleE
$LN20@GetSimpleE:

; 498  :       }
; 499  :       (*i)++;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax

; 500  :       return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@GetSimpleE
$LN18@GetSimpleE:
$LN11@GetSimpleE:

; 501  :     }
; 502  :   }
; 503  : 
; 504  :   /* get (first) operand */
; 505  :   op1_pos = *i;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR op1_pos$[rsp], eax

; 506  :   if (ERROR == GetToken(hll, i, tokenarray, &op1))

	lea	r9, QWORD PTR op1$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetToken
	cmp	eax, -1
	jne	SHORT $LN21@GetSimpleE

; 507  :     return (ERROR);

	mov	eax, -1
	jmp	$LN1@GetSimpleE
$LN21@GetSimpleE:

; 508  :   op1_end = *i;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR op1_end$[rsp], eax

; 509  : 
; 510  :   op = GetCOp(&tokenarray[*i]); /* get operator */

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	GetCOp
	mov	DWORD PTR op$[rsp], eax

; 511  : 
; 512  :                                 /* lower precedence operator ( && or || ) detected? */
; 513  :   if (op == COP_AND || op == COP_OR) {

	cmp	DWORD PTR op$[rsp], 7
	je	SHORT $LN24@GetSimpleE
	cmp	DWORD PTR op$[rsp], 8
	jne	SHORT $LN22@GetSimpleE
$LN24@GetSimpleE:

; 514  :     /* v2.11: next 2 lines removed - && and || operators need a valid first operand */
; 515  :     //if ( op1.kind == EXPR_EMPTY )
; 516  :     //    return( NOT_ERROR );
; 517  :     op = COP_NONE;

	mov	DWORD PTR op$[rsp], 0

; 518  :   }

	jmp	SHORT $LN23@GetSimpleE
$LN22@GetSimpleE:

; 519  :   else if (op != COP_NONE)

	cmp	DWORD PTR op$[rsp], 0
	je	SHORT $LN25@GetSimpleE

; 520  :     (*i)++;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax
$LN25@GetSimpleE:
$LN23@GetSimpleE:

; 521  : 
; 522  :   label = GetLabel(hll, ilabel);

	mov	edx, DWORD PTR ilabel$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetLabel
	mov	DWORD PTR label$[rsp], eax

; 523  : 
; 524  :   DebugMsg1(("%u GetSimpleExpression: EvalOperand ok, kind=%X, i=%u [%s]\n", evallvl, op1.kind, *i, tokenarray[*i].tokpos));

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR i$[rsp]
	mov	r9d, DWORD PTR [rax]
	mov	r8d, DWORD PTR op1$[rsp+60]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11246
	call	DoDebugMsg1

; 525  : 
; 526  :   /* check for special operators with implicite operand:
; 527  :   * COP_ZERO, COP_CARRY, COP_SIGN, COP_PARITY, COP_OVERFLOW
; 528  :   */
; 529  :   if (op >= COP_ZERO) {

	cmp	DWORD PTR op$[rsp], 11
	jl	$LN26@GetSimpleE

; 530  :     if (op1.kind != EXPR_EMPTY) {

	cmp	DWORD PTR op1$[rsp+60], -2
	je	SHORT $LN27@GetSimpleE

; 531  :       DebugMsg(("GetSimpleExpression: non-empty expression rejected: %s\n", tokenarray[op1_pos].tokpos));

	movsxd	rax, DWORD PTR op1_pos$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11249
	call	DoDebugMsg

; 532  :       return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, 199				; 000000c7H
	call	EmitError
	jmp	$LN1@GetSimpleE
$LN27@GetSimpleE:

; 533  :     }
; 534  :     p = buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 535  :     hllop->lastjmp = p;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 536  :     RenderJcc(p, flaginstr[op - COP_ZERO], !is_true, label);

	movzx	eax, BYTE PTR is_true$[rsp]
	test	eax, eax
	jne	SHORT $LN51@GetSimpleE
	mov	DWORD PTR tv230[rsp], 1
	jmp	SHORT $LN52@GetSimpleE
$LN51@GetSimpleE:
	mov	DWORD PTR tv230[rsp], 0
$LN52@GetSimpleE:
	mov	eax, DWORD PTR op$[rsp]
	sub	eax, 11
	cdqe
	lea	rcx, OFFSET FLAT:flaginstr
	mov	r9d, DWORD PTR label$[rsp]
	mov	r8d, DWORD PTR tv230[rsp]
	movzx	edx, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR p$[rsp]
	call	RenderJcc

; 537  :     return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@GetSimpleE
$LN26@GetSimpleE:

; 538  :   }
; 539  : 
; 540  :   switch (op1.kind) {

	mov	eax, DWORD PTR op1$[rsp+60]
	mov	DWORD PTR tv226[rsp], eax
	cmp	DWORD PTR tv226[rsp], -2
	je	SHORT $LN28@GetSimpleE
	cmp	DWORD PTR tv226[rsp], 3
	je	SHORT $LN29@GetSimpleE
	jmp	SHORT $LN7@GetSimpleE
$LN28@GetSimpleE:

; 541  :   case EXPR_EMPTY:
; 542  :     DebugMsg(("GetSimpleExpression: empty expression rejected\n"));

	lea	rcx, OFFSET FLAT:$SG11251
	call	DoDebugMsg

; 543  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE)); /* v2.09: changed from NOT_ERROR to ERROR */

	mov	ecx, 199				; 000000c7H
	call	EmitError
	jmp	$LN1@GetSimpleE
$LN29@GetSimpleE:

; 544  :   case EXPR_FLOAT:
; 545  :     DebugMsg(("GetSimpleExpression: float expression rejected: %s\n", tokenarray[op1_pos].tokpos));

	movsxd	rax, DWORD PTR op1_pos$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11253
	call	DoDebugMsg

; 546  :     return(EmitError(REAL_OR_BCD_NUMBER_NOT_ALLOWED)); /* v2.10: added */

	mov	ecx, 271				; 0000010fH
	call	EmitError
	jmp	$LN1@GetSimpleE
$LN7@GetSimpleE:

; 547  :   }
; 548  : 
; 549  :   if (op == COP_NONE) {

	cmp	DWORD PTR op$[rsp], 0
	jne	$LN30@GetSimpleE

; 550  :     switch (op1.kind) {

	mov	eax, DWORD PTR op1$[rsp+60]
	mov	DWORD PTR tv252[rsp], eax
	cmp	DWORD PTR tv252[rsp], 0
	je	$LN34@GetSimpleE
	cmp	DWORD PTR tv252[rsp], 1
	je	$LN33@GetSimpleE
	cmp	DWORD PTR tv252[rsp], 2
	je	SHORT $LN31@GetSimpleE
	jmp	$LN40@GetSimpleE
$LN31@GetSimpleE:

; 551  :     case EXPR_REG:
; 552  :       if (op1.indirect == FALSE) {

	mov	eax, DWORD PTR op1$[rsp+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN32@GetSimpleE

; 553  :         p = RenderInstr(buffer, "test", op1_pos, op1_end, op1_pos, op1_end, tokenarray);

	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR op1_end$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR op1_pos$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR op1_end$[rsp]
	mov	r8d, DWORD PTR op1_pos$[rsp]
	lea	rdx, OFFSET FLAT:$SG11257
	mov	rcx, QWORD PTR buffer$[rsp]
	call	RenderInstr
	mov	QWORD PTR p$[rsp], rax

; 554  :         hllop->lastjmp = p;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 555  :         RenderJcc(p, 'z', is_true, label);

	movzx	eax, BYTE PTR is_true$[rsp]
	mov	r9d, DWORD PTR label$[rsp]
	mov	r8d, eax
	mov	dl, 122					; 0000007aH
	mov	rcx, QWORD PTR p$[rsp]
	call	RenderJcc

; 556  :         break;

	jmp	$LN9@GetSimpleE
$LN32@GetSimpleE:
$LN33@GetSimpleE:

; 557  :       }
; 558  :       /* no break */
; 559  :     case EXPR_ADDR:
; 560  :       p = RenderInstr(buffer, "cmp", op1_pos, op1_end, EMPTY, 0, tokenarray);

	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], -2
	mov	r9d, DWORD PTR op1_end$[rsp]
	mov	r8d, DWORD PTR op1_pos$[rsp]
	lea	rdx, OFFSET FLAT:$SG11259
	mov	rcx, QWORD PTR buffer$[rsp]
	call	RenderInstr
	mov	QWORD PTR p$[rsp], rax

; 561  :       hllop->lastjmp = p;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 562  :       RenderJcc(p, 'z', is_true, label);

	movzx	eax, BYTE PTR is_true$[rsp]
	mov	r9d, DWORD PTR label$[rsp]
	mov	r8d, eax
	mov	dl, 122					; 0000007aH
	mov	rcx, QWORD PTR p$[rsp]
	call	RenderJcc

; 563  :       break;

	jmp	$LN9@GetSimpleE
$LN34@GetSimpleE:

; 564  :     case EXPR_CONST:
; 565  : #if 0
; 566  :       /* v2.05: string constant is allowed! */
; 567  :       if (op1.string != NULL) {
; 568  :         return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));
; 569  :       }
; 570  : #endif
; 571  :       /* v2.11: error if constant doesn't fit in 32-bits */
; 572  :       if (op1.hvalue != 0 && op1.hvalue != -1)

	cmp	DWORD PTR op1$[rsp+4], 0
	je	SHORT $LN35@GetSimpleE
	cmp	DWORD PTR op1$[rsp+4], -1
	je	SHORT $LN35@GetSimpleE

; 573  :         return(EmitConstError(&op1));

	lea	rcx, QWORD PTR op1$[rsp]
	call	EmitConstError
	jmp	$LN1@GetSimpleE
$LN35@GetSimpleE:

; 574  : 
; 575  :       hllop->lastjmp = buffer;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rax], rcx

; 576  : 
; 577  :       if ((is_true == TRUE && op1.value) ||

	movzx	eax, BYTE PTR is_true$[rsp]
	cmp	eax, 1
	jne	SHORT $LN39@GetSimpleE
	cmp	DWORD PTR op1$[rsp], 0
	jne	SHORT $LN38@GetSimpleE
$LN39@GetSimpleE:
	movzx	eax, BYTE PTR is_true$[rsp]
	test	eax, eax
	jne	SHORT $LN36@GetSimpleE
	cmp	DWORD PTR op1$[rsp], 0
	jne	SHORT $LN36@GetSimpleE
$LN38@GetSimpleE:

; 578  :         (is_true == FALSE && op1.value == 0)) {
; 579  :         sprintf(buffer, "jmp " LABELFMT EOLSTR, label);

	mov	r8d, DWORD PTR label$[rsp]
	lea	rdx, OFFSET FLAT:$SG11266
	mov	rcx, QWORD PTR buffer$[rsp]
	call	sprintf

; 580  :       }

	jmp	SHORT $LN37@GetSimpleE
$LN36@GetSimpleE:

; 581  :       else {
; 582  :         //strcpy( buffer, " " EOLSTR ); /* v2.11: obsolete */
; 583  :         *buffer = NULLC;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rax], 0
$LN37@GetSimpleE:

; 584  :       }
; 585  :       break;

	jmp	SHORT $LN9@GetSimpleE
$LN40@GetSimpleE:

; 586  : #ifdef DEBUG_OUT
; 587  :     default: /**/myassert(0); break;

	mov	edx, 587				; 0000024bH
	lea	rcx, OFFSET FLAT:$SG11268
	call	InternalError
$LN9@GetSimpleE:

; 588  : #endif
; 589  :     }
; 590  :     return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN1@GetSimpleE
$LN30@GetSimpleE:

; 591  :   }
; 592  : 
; 593  :   /* get second operand for binary operator */
; 594  :   op2_pos = *i;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR op2_pos$[rsp], eax

; 595  :   if (ERROR == GetToken(hll, i, tokenarray, &op2)) {

	lea	r9, QWORD PTR op2$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetToken
	cmp	eax, -1
	jne	SHORT $LN41@GetSimpleE

; 596  :     return(ERROR);

	mov	eax, -1
	jmp	$LN1@GetSimpleE
$LN41@GetSimpleE:

; 597  :   }
; 598  :   DebugMsg1(("%u GetSimpleExpression: EvalOperand 2 ok, type=%X, i=%u [%s]\n", evallvl, op2.type, *i, tokenarray[*i].tokpos));

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR i$[rsp]
	mov	r9d, DWORD PTR [rax]
	mov	r8, QWORD PTR op2$[rsp+96]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11270
	call	DoDebugMsg1

; 599  :   if (op2.kind != EXPR_CONST && op2.kind != EXPR_ADDR && op2.kind != EXPR_REG) {

	cmp	DWORD PTR op2$[rsp+60], 0
	je	SHORT $LN42@GetSimpleE
	cmp	DWORD PTR op2$[rsp+60], 1
	je	SHORT $LN42@GetSimpleE
	cmp	DWORD PTR op2$[rsp+60], 2
	je	SHORT $LN42@GetSimpleE

; 600  :     DebugMsg(("GetSimpleExpression: syntax error, op2.kind=%u\n", op2.kind));

	mov	edx, DWORD PTR op2$[rsp+60]
	lea	rcx, OFFSET FLAT:$SG11272
	call	DoDebugMsg

; 601  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, 199				; 000000c7H
	call	EmitError
	jmp	$LN1@GetSimpleE
$LN42@GetSimpleE:

; 602  :   }
; 603  :   op2_end = *i;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR op2_end$[rsp], eax

; 604  : 
; 605  :   /* now generate ASM code for expression */
; 606  : 
; 607  :   if (op == COP_ANDB) {

	cmp	DWORD PTR op$[rsp], 9
	jne	SHORT $LN43@GetSimpleE

; 608  :     p = RenderInstr(buffer, "test", op1_pos, op1_end, op2_pos, op2_end, tokenarray);

	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR op2_end$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR op2_pos$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR op1_end$[rsp]
	mov	r8d, DWORD PTR op1_pos$[rsp]
	lea	rdx, OFFSET FLAT:$SG11275
	mov	rcx, QWORD PTR buffer$[rsp]
	call	RenderInstr
	mov	QWORD PTR p$[rsp], rax

; 609  :     hllop->lastjmp = p;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 610  :     RenderJcc(p, 'e', is_true, label);

	movzx	eax, BYTE PTR is_true$[rsp]
	mov	r9d, DWORD PTR label$[rsp]
	mov	r8d, eax
	mov	dl, 101					; 00000065H
	mov	rcx, QWORD PTR p$[rsp]
	call	RenderJcc

; 611  :   }

	jmp	$LN44@GetSimpleE
$LN43@GetSimpleE:

; 612  :   else if (op <= COP_LE) { /* ==, !=, >, <, >= or <= operator */

	cmp	DWORD PTR op$[rsp], 6
	jg	$LN45@GetSimpleE

; 613  :                            /*
; 614  :                            * optimisation: generate 'or EAX,EAX' instead of 'cmp EAX,0'.
; 615  :                            * v2.11: use op2.value64 instead of op2.value
; 616  :                            */
; 617  :     if (Options.masm_compat_gencode &&
; 618  :       (op == COP_EQ || op == COP_NE) &&
; 619  :       op1.kind == EXPR_REG && op1.indirect == FALSE &&
; 620  :       op2.kind == EXPR_CONST && op2.value64 == 0) {

	movzx	eax, BYTE PTR Options+144
	test	eax, eax
	je	SHORT $LN47@GetSimpleE
	cmp	DWORD PTR op$[rsp], 1
	je	SHORT $LN49@GetSimpleE
	cmp	DWORD PTR op$[rsp], 2
	jne	SHORT $LN47@GetSimpleE
$LN49@GetSimpleE:
	cmp	DWORD PTR op1$[rsp+60], 2
	jne	SHORT $LN47@GetSimpleE
	mov	eax, DWORD PTR op1$[rsp+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN47@GetSimpleE
	cmp	DWORD PTR op2$[rsp+60], 0
	jne	SHORT $LN47@GetSimpleE
	cmp	QWORD PTR op2$[rsp], 0
	jne	SHORT $LN47@GetSimpleE

; 621  :       p = RenderInstr(buffer, "or", op1_pos, op1_end, op1_pos, op1_end, tokenarray);

	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR op1_end$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR op1_pos$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR op1_end$[rsp]
	mov	r8d, DWORD PTR op1_pos$[rsp]
	lea	rdx, OFFSET FLAT:$SG11281
	mov	rcx, QWORD PTR buffer$[rsp]
	call	RenderInstr
	mov	QWORD PTR p$[rsp], rax

; 622  :     }

	jmp	SHORT $LN48@GetSimpleE
$LN47@GetSimpleE:

; 623  :     else {
; 624  :       p = RenderInstr(buffer, "cmp", op1_pos, op1_end, op2_pos, op2_end, tokenarray);

	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR op2_end$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR op2_pos$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR op1_end$[rsp]
	mov	r8d, DWORD PTR op1_pos$[rsp]
	lea	rdx, OFFSET FLAT:$SG11282
	mov	rcx, QWORD PTR buffer$[rsp]
	call	RenderInstr
	mov	QWORD PTR p$[rsp], rax
$LN48@GetSimpleE:

; 625  :     }
; 626  : 
; 627  :     instr = ((IS_SIGNED(op1.mem_type) || IS_SIGNED(op2.mem_type)) ? signed_cjmptype[op - COP_EQ] : unsigned_cjmptype[op - COP_EQ]);

	mov	eax, DWORD PTR op1$[rsp+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN53@GetSimpleE
	mov	eax, DWORD PTR op2$[rsp+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN53@GetSimpleE
	mov	eax, DWORD PTR op$[rsp]
	dec	eax
	cdqe
	lea	rcx, OFFSET FLAT:unsigned_cjmptype
	movsx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv379[rsp], eax
	jmp	SHORT $LN54@GetSimpleE
$LN53@GetSimpleE:
	mov	eax, DWORD PTR op$[rsp]
	dec	eax
	cdqe
	lea	rcx, OFFSET FLAT:signed_cjmptype
	movsx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv379[rsp], eax
$LN54@GetSimpleE:
	movzx	eax, BYTE PTR tv379[rsp]
	mov	BYTE PTR instr$[rsp], al

; 628  :     hllop->lastjmp = p;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx

; 629  :     RenderJcc(p, instr, neg_cjmptype[op - COP_EQ] ? is_true : !is_true, label);

	mov	eax, DWORD PTR op$[rsp]
	dec	eax
	cdqe
	lea	rcx, OFFSET FLAT:neg_cjmptype
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN57@GetSimpleE
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	DWORD PTR tv426[rsp], eax
	jmp	SHORT $LN58@GetSimpleE
$LN57@GetSimpleE:
	movzx	eax, BYTE PTR is_true$[rsp]
	test	eax, eax
	jne	SHORT $LN55@GetSimpleE
	mov	DWORD PTR tv424[rsp], 1
	jmp	SHORT $LN56@GetSimpleE
$LN55@GetSimpleE:
	mov	DWORD PTR tv424[rsp], 0
$LN56@GetSimpleE:
	mov	eax, DWORD PTR tv424[rsp]
	mov	DWORD PTR tv426[rsp], eax
$LN58@GetSimpleE:
	mov	r9d, DWORD PTR label$[rsp]
	mov	r8d, DWORD PTR tv426[rsp]
	movzx	edx, BYTE PTR instr$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	RenderJcc

; 630  :   }

	jmp	SHORT $LN46@GetSimpleE
$LN45@GetSimpleE:

; 631  :   else {
; 632  :     DebugMsg(("GetSimpleExpression: unexpected operator %s\n", tokenarray[op1_pos].tokpos));

	movsxd	rax, DWORD PTR op1_pos$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	lea	rcx, OFFSET FLAT:$SG11283
	call	DoDebugMsg

; 633  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, 199				; 000000c7H
	call	EmitError
	jmp	SHORT $LN1@GetSimpleE
$LN46@GetSimpleE:
$LN44@GetSimpleE:

; 634  :   }
; 635  :   return(NOT_ERROR);

	xor	eax, eax
$LN1@GetSimpleE:

; 636  : }

	add	rsp, 376				; 00000178H
	ret	0
GetSimpleExpression ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
tv72 = 32
hll$ = 64
index$ = 72
GetLabel PROC

; 437  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 438  :   /**/myassert(hll->labels[index]);

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rcx+rax*4+8], 0
	je	SHORT $LN3@GetLabel
	mov	DWORD PTR tv72[rsp], 0
	jmp	SHORT $LN4@GetLabel
$LN3@GetLabel:
	mov	edx, 438				; 000001b6H
	lea	rcx, OFFSET FLAT:$SG11189
	call	InternalError
	mov	DWORD PTR tv72[rsp], eax
$LN4@GetLabel:

; 439  :   return(hll->labels[index]);

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4+8]

; 440  : }

	add	rsp, 56					; 00000038H
	ret	0
GetLabel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
end_tok$ = 48
hll$ = 80
i$ = 88
tokenarray$ = 96
opnd$ = 104
GetToken PROC

; 407  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 408  :   int end_tok;
; 409  : 
; 410  :   /* scan for the next C operator in the token array.
; 411  :   * because the ASM evaluator may report an error if such a thing
; 412  :   * is found ( CARRY?, ZERO? and alikes will be regarded as - not yet defined - labels )
; 413  :   */
; 414  :   for (end_tok = *i; end_tok < Token_Count; end_tok++) {

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR end_tok$[rsp], eax
	jmp	SHORT $LN4@GetToken
$LN2@GetToken:
	mov	eax, DWORD PTR end_tok$[rsp]
	inc	eax
	mov	DWORD PTR end_tok$[rsp], eax
$LN4@GetToken:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR end_tok$[rsp], eax
	jge	SHORT $LN3@GetToken

; 415  :     if ((GetCOp(&tokenarray[end_tok])) != COP_NONE)

	movsxd	rax, DWORD PTR end_tok$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	GetCOp
	test	eax, eax
	je	SHORT $LN5@GetToken

; 416  :       break;

	jmp	SHORT $LN3@GetToken
$LN5@GetToken:

; 417  :   }

	jmp	SHORT $LN2@GetToken
$LN3@GetToken:

; 418  :   if (end_tok == *i) {

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR end_tok$[rsp], eax
	jne	SHORT $LN6@GetToken

; 419  :     opnd->kind = EXPR_EMPTY;

	mov	rax, QWORD PTR opnd$[rsp]
	mov	DWORD PTR [rax+60], -2

; 420  :     return(NOT_ERROR);

	xor	eax, eax
	jmp	SHORT $LN1@GetToken
$LN6@GetToken:

; 421  :   }
; 422  :   if (ERROR == EvalOperand(i, tokenarray, end_tok, opnd, 0))

	mov	BYTE PTR [rsp+32], 0
	mov	r9, QWORD PTR opnd$[rsp]
	mov	r8d, DWORD PTR end_tok$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN7@GetToken

; 423  :     return(ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@GetToken
$LN7@GetToken:

; 424  : 
; 425  :   /* v2.11: emit error 'syntax error in control flow directive'.
; 426  :   * May happen for expressions like ".if 1 + CARRY?"
; 427  :   */
; 428  :   if (*i > end_tok) {

	mov	rax, QWORD PTR i$[rsp]
	mov	ecx, DWORD PTR end_tok$[rsp]
	cmp	DWORD PTR [rax], ecx
	jle	SHORT $LN8@GetToken

; 429  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, 199				; 000000c7H
	call	EmitError
	jmp	SHORT $LN1@GetToken
$LN8@GetToken:

; 430  :   }
; 431  : 
; 432  :   return(NOT_ERROR);

	xor	eax, eax
$LN1@GetToken:

; 433  : }

	add	rsp, 72					; 00000048H
	ret	0
GetToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
old$ = 32
dst$ = 64
cc$ = 72
neg$ = 80
label$ = 88
RenderJcc PROC

; 382  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 383  : #ifdef DEBUG_OUT
; 384  :   char *old = dst;

	mov	rax, QWORD PTR dst$[rsp]
	mov	QWORD PTR old$[rsp], rax

; 385  : #endif
; 386  :   /* create the jump opcode: j[n]cc */
; 387  :   *dst++ = 'j';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 106			; 0000006aH
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 388  :   if (neg)

	cmp	DWORD PTR neg$[rsp], 0
	je	SHORT $LN2@RenderJcc

; 389  :     *dst++ = 'n';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 110			; 0000006eH
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
$LN2@RenderJcc:

; 390  :   *dst++ = cc;

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR cc$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 391  :   if (neg == FALSE)

	cmp	DWORD PTR neg$[rsp], 0
	jne	SHORT $LN3@RenderJcc

; 392  :     *dst++ = ' '; /* make sure there's room for the inverse jmp */

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
$LN3@RenderJcc:

; 393  : 
; 394  :   *dst++ = ' ';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 395  :   GetLabelStr(label, dst);

	mov	rdx, QWORD PTR dst$[rsp]
	mov	ecx, DWORD PTR label$[rsp]
	call	GetLabelStr

; 396  :   dst += strlen(dst);

	mov	rcx, QWORD PTR dst$[rsp]
	call	strlen
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dst$[rsp], rax

; 397  :   *dst++ = EOLCHAR;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 94			; 0000005eH
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 398  :   *dst = NULLC;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 0

; 399  :   DebugMsg1(("%u RenderJcc()=>%s<\n", evallvl, old));

	mov	r8, QWORD PTR old$[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11163
	call	DoDebugMsg1

; 400  :   return(dst);

	mov	rax, QWORD PTR dst$[rsp]

; 401  : }

	add	rsp, 56					; 00000038H
	ret	0
RenderJcc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
label$ = 48
buff$ = 56
GetLabelStr PROC

; 373  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 374  :   sprintf(buff, LABELFMT, label);

	mov	r8d, DWORD PTR label$[rsp]
	lea	rdx, OFFSET FLAT:$SG11149
	mov	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 375  :   return(buff);

	mov	rax, QWORD PTR buff$[rsp]

; 376  : }

	add	rsp, 40					; 00000028H
	ret	0
GetLabelStr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
i$ = 32
old$ = 40
dst$ = 64
instr$ = 72
start1$ = 80
end1$ = 88
start2$ = 96
end2$ = 104
tokenarray$ = 112
RenderInstr PROC

; 340  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 341  :   int i;
; 342  : #ifdef DEBUG_OUT
; 343  :   char *old = dst;

	mov	rax, QWORD PTR dst$[rsp]
	mov	QWORD PTR old$[rsp], rax

; 344  : #endif
; 345  :   i = strlen(instr);

	mov	rcx, QWORD PTR instr$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax

; 346  :   /* copy the instruction */
; 347  :   memcpy(dst, instr, i);

	movsxd	rax, DWORD PTR i$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR instr$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	call	memcpy

; 348  :   dst += i;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dst$[rsp], rax

; 349  :   /* copy the first operand's tokens */
; 350  :   *dst++ = ' ';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 351  :   i = tokenarray[end1].tokpos - tokenarray[start1].tokpos;

	movsxd	rax, DWORD PTR end1$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR start1$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR i$[rsp], eax

; 352  :   memcpy(dst, tokenarray[start1].tokpos, i);

	movsxd	rax, DWORD PTR i$[rsp]
	movsxd	rcx, DWORD PTR start1$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+24]
	mov	rcx, QWORD PTR dst$[rsp]
	call	memcpy

; 353  :   dst += i;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dst$[rsp], rax

; 354  :   if (start2 != EMPTY) {

	cmp	DWORD PTR start2$[rsp], -2
	je	$LN2@RenderInst

; 355  :     *dst++ = ',';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 44			; 0000002cH
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 356  :     /* copy the second operand's tokens */
; 357  :     *dst++ = ' ';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 358  :     i = tokenarray[end2].tokpos - tokenarray[start2].tokpos;

	movsxd	rax, DWORD PTR end2$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR start2$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+24]
	mov	rax, QWORD PTR [rdx+rax+24]
	sub	rax, rcx
	mov	DWORD PTR i$[rsp], eax

; 359  :     memcpy(dst, tokenarray[start2].tokpos, i);

	movsxd	rax, DWORD PTR i$[rsp]
	movsxd	rcx, DWORD PTR start2$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rax+rcx+24]
	mov	rcx, QWORD PTR dst$[rsp]
	call	memcpy

; 360  :     dst += i;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dst$[rsp], rax

; 361  :   }

	jmp	SHORT $LN3@RenderInst
$LN2@RenderInst:

; 362  :   else if (end2 != EMPTY) {

	cmp	DWORD PTR end2$[rsp], -2
	je	SHORT $LN4@RenderInst

; 363  :     dst += sprintf(dst, ", %d", end2);

	mov	r8d, DWORD PTR end2$[rsp]
	lea	rdx, OFFSET FLAT:$SG11141
	mov	rcx, QWORD PTR dst$[rsp]
	call	sprintf
	cdqe
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dst$[rsp], rax
$LN4@RenderInst:
$LN3@RenderInst:

; 364  :   }
; 365  :   *dst++ = EOLCHAR;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 94			; 0000005eH
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 366  :   *dst = NULLC;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 0

; 367  :   DebugMsg1(("%u RenderInstr(%s)=>%s<\n", evallvl, instr, old));

	mov	r9, QWORD PTR old$[rsp]
	mov	r8, QWORD PTR instr$[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11142
	call	DoDebugMsg1

; 368  :   return(dst);

	mov	rax, QWORD PTR dst$[rsp]

; 369  : }

	add	rsp, 56					; 00000038H
	ret	0
RenderInstr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
temp2$ = 0
i$ = 4
j$ = 8
temp1$ = 16
hll$ = 48
lbl$ = 56
src$ = 64
n$ = 72
bubblesort64 PROC

; 310  : static void bubblesort64(struct hll_item *hll, uint_16 *lbl, int_64 *src, int n) {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 311  :   /*******************************************************************************************************************************/
; 312  :   int i;
; 313  :   int j;
; 314  :   int_64 temp1;
; 315  :   uint_16 temp2;
; 316  :   for (i = 0; i < n; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@bubblesort
$LN2@bubblesort:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@bubblesort:
	mov	eax, DWORD PTR n$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@bubblesort

; 317  :   {
; 318  :     for (j = i + 1; j < n; ++j)

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
	jmp	SHORT $LN7@bubblesort
$LN5@bubblesort:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN7@bubblesort:
	mov	eax, DWORD PTR n$[rsp]
	cmp	DWORD PTR j$[rsp], eax
	jge	$LN6@bubblesort

; 319  :     {
; 320  :       if (src[i] > src[j])

	movsxd	rax, DWORD PTR i$[rsp]
	movsxd	rcx, DWORD PTR j$[rsp]
	mov	rdx, QWORD PTR src$[rsp]
	mov	r8, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [r8+rcx*8]
	cmp	QWORD PTR [rdx+rax*8], rcx
	jle	$LN8@bubblesort

; 321  :       {
; 322  :         temp1 = src[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR temp1$[rsp], rax

; 323  :         src[i] = src[j];

	movsxd	rax, DWORD PTR j$[rsp]
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR src$[rsp]
	mov	r8, QWORD PTR src$[rsp]
	mov	rax, QWORD PTR [r8+rax*8]
	mov	QWORD PTR [rdx+rcx*8], rax

; 324  :         src[j] = temp1;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rdx, QWORD PTR temp1$[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 325  :         temp2 = lbl[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR lbl$[rsp]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	WORD PTR temp2$[rsp], ax

; 326  :         lbl[i] = lbl[j];

	movsxd	rax, DWORD PTR j$[rsp]
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR lbl$[rsp]
	mov	r8, QWORD PTR lbl$[rsp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx*2], ax

; 327  :         lbl[j] = temp2;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR lbl$[rsp]
	movzx	edx, WORD PTR temp2$[rsp]
	mov	WORD PTR [rcx+rax*2], dx
$LN8@bubblesort:

; 328  :       }
; 329  :     }

	jmp	$LN5@bubblesort
$LN6@bubblesort:

; 330  :   }

	jmp	$LN2@bubblesort
$LN3@bubblesort:

; 331  : 
; 332  :   hll->mincase64 = src[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR src$[rsp]
	mov	rax, QWORD PTR [rdx+rax]
	mov	QWORD PTR [rcx+136], rax

; 333  :   hll->maxcase64 = src[n - 1];

	mov	eax, DWORD PTR n$[rsp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR src$[rsp]
	mov	rax, QWORD PTR [rdx+rax*8]
	mov	QWORD PTR [rcx+128], rax

; 334  :   hll->delta64 = hll->maxcase64 - hll->mincase64;

	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR [rcx+136]
	mov	rax, QWORD PTR [rax+128]
	sub	rax, rcx
	mov	rcx, QWORD PTR hll$[rsp]
	mov	QWORD PTR [rcx+144], rax

; 335  : }

	add	rsp, 40					; 00000028H
	ret	0
bubblesort64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
temp2$ = 0
i$ = 4
j$ = 8
temp1$ = 12
hll$ = 32
lbl$ = 40
src$ = 48
n$ = 56
bubblesort PROC

; 282  : static void bubblesort(struct hll_item *hll, uint_16 *lbl, int *src, int n) {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 283  :   /*******************************************************************************************************************************/
; 284  :   int i;
; 285  :   int j;
; 286  :   int temp1;
; 287  :   uint_16 temp2;
; 288  : 
; 289  :   for (i = 0; i < n; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@bubblesort
$LN2@bubblesort:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@bubblesort:
	mov	eax, DWORD PTR n$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@bubblesort

; 290  :   {
; 291  :     for (j = i + 1; j < n; ++j)

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
	jmp	SHORT $LN7@bubblesort
$LN5@bubblesort:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN7@bubblesort:
	mov	eax, DWORD PTR n$[rsp]
	cmp	DWORD PTR j$[rsp], eax
	jge	$LN6@bubblesort

; 292  :     {
; 293  :       if (src[i] > src[j])

	movsxd	rax, DWORD PTR i$[rsp]
	movsxd	rcx, DWORD PTR j$[rsp]
	mov	rdx, QWORD PTR src$[rsp]
	mov	r8, QWORD PTR src$[rsp]
	mov	ecx, DWORD PTR [r8+rcx*4]
	cmp	DWORD PTR [rdx+rax*4], ecx
	jle	SHORT $LN8@bubblesort

; 294  :       {
; 295  :         temp1 = src[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR temp1$[rsp], eax

; 296  :         src[i] = src[j];

	movsxd	rax, DWORD PTR j$[rsp]
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR src$[rsp]
	mov	r8, QWORD PTR src$[rsp]
	mov	eax, DWORD PTR [r8+rax*4]
	mov	DWORD PTR [rdx+rcx*4], eax

; 297  :         src[j] = temp1;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	edx, DWORD PTR temp1$[rsp]
	mov	DWORD PTR [rcx+rax*4], edx

; 298  :         temp2 = lbl[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR lbl$[rsp]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	WORD PTR temp2$[rsp], ax

; 299  :         lbl[i] = lbl[j];

	movsxd	rax, DWORD PTR j$[rsp]
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR lbl$[rsp]
	mov	r8, QWORD PTR lbl$[rsp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx*2], ax

; 300  :         lbl[j] = temp2;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR lbl$[rsp]
	movzx	edx, WORD PTR temp2$[rsp]
	mov	WORD PTR [rcx+rax*2], dx
$LN8@bubblesort:

; 301  :       }
; 302  :     }

	jmp	$LN5@bubblesort
$LN6@bubblesort:

; 303  :   }

	jmp	$LN2@bubblesort
$LN3@bubblesort:

; 304  : 
; 305  :   hll->mincase = src[0];

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR src$[rsp]
	mov	eax, DWORD PTR [rdx+rax]
	mov	DWORD PTR [rcx+92], eax

; 306  :   hll->maxcase = src[n - 1];

	mov	eax, DWORD PTR n$[rsp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR hll$[rsp]
	mov	rdx, QWORD PTR src$[rsp]
	mov	eax, DWORD PTR [rdx+rax*4]
	mov	DWORD PTR [rcx+88], eax

; 307  :   hll->delta = hll->maxcase - hll->mincase;

	mov	rax, QWORD PTR hll$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	ecx, DWORD PTR [rcx+92]
	mov	eax, DWORD PTR [rax+88]
	sub	eax, ecx
	mov	rcx, QWORD PTR hll$[rsp]
	mov	DWORD PTR [rcx+96], eax

; 308  : }

	add	rsp, 24
	ret	0
bubblesort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
a$ = 0
b$ = 4
src$ = 32
hex2dec	PROC

; 263  : {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 264  :   uint_32 a;
; 265  :   uint_32 b = 0;

	mov	DWORD PTR b$[rsp], 0
$LN2@hex2dec:

; 266  :   for (;;)
; 267  :   {
; 268  :     a = *src;

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR a$[rsp], eax

; 269  :     if (!a) break;

	cmp	DWORD PTR a$[rsp], 0
	jne	SHORT $LN5@hex2dec
	jmp	SHORT $LN3@hex2dec
$LN5@hex2dec:

; 270  :     b = (b << 4);

	mov	eax, DWORD PTR b$[rsp]
	shl	eax, 4
	mov	DWORD PTR b$[rsp], eax

; 271  :     if (a >= '0' && a <= '9') a -= '0';

	cmp	DWORD PTR a$[rsp], 48			; 00000030H
	jb	SHORT $LN6@hex2dec
	cmp	DWORD PTR a$[rsp], 57			; 00000039H
	ja	SHORT $LN6@hex2dec
	mov	eax, DWORD PTR a$[rsp]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR a$[rsp], eax
	jmp	SHORT $LN7@hex2dec
$LN6@hex2dec:

; 272  :     else {
; 273  :       a |= 0x20;

	mov	eax, DWORD PTR a$[rsp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR a$[rsp], eax

; 274  :       if (a >= 'a' && a <= 'f') a -= 'a' - 10;

	cmp	DWORD PTR a$[rsp], 97			; 00000061H
	jb	SHORT $LN8@hex2dec
	cmp	DWORD PTR a$[rsp], 102			; 00000066H
	ja	SHORT $LN8@hex2dec
	mov	eax, DWORD PTR a$[rsp]
	sub	eax, 87					; 00000057H
	mov	DWORD PTR a$[rsp], eax
$LN8@hex2dec:
$LN7@hex2dec:

; 275  :     }
; 276  :     b = b + a;

	mov	eax, DWORD PTR a$[rsp]
	mov	ecx, DWORD PTR b$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR b$[rsp], eax

; 277  :     src++;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 278  :   }

	jmp	SHORT $LN2@hex2dec
$LN3@hex2dec:

; 279  :   return (b);

	mov	eax, DWORD PTR b$[rsp]

; 280  : }

	add	rsp, 24
	ret	0
hex2dec	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
rc$ = 32
size$ = 36
tv72 = 40
tv82 = 44
tv69 = 48
p$ = 56
item$ = 80
GetCOp	PROC

; 200  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 201  :   int size;
; 202  :   enum c_bop rc;
; 203  :   char *p = item->string_ptr;

	mov	rax, QWORD PTR item$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR p$[rsp], rax

; 204  : 
; 205  :   size = (item->token == T_STRING ? item->stringlen : 0);

	mov	rax, QWORD PTR item$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 9
	jne	SHORT $LN45@GetCOp
	mov	rax, QWORD PTR item$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN46@GetCOp
$LN45@GetCOp:
	mov	DWORD PTR tv69[rsp], 0
$LN46@GetCOp:
	mov	eax, DWORD PTR tv69[rsp]
	mov	DWORD PTR size$[rsp], eax

; 206  : 
; 207  :   if (size == 2) {

	cmp	DWORD PTR size$[rsp], 2
	jne	$LN6@GetCOp

; 208  :     switch (*(uint_16 *)p) {

	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR tv72[rsp], eax
	cmp	DWORD PTR tv72[rsp], 15677		; 00003d3dH
	jg	SHORT $LN47@GetCOp
	cmp	DWORD PTR tv72[rsp], 15677		; 00003d3dH
	je	SHORT $LN8@GetCOp
	cmp	DWORD PTR tv72[rsp], 9766		; 00002626H
	je	SHORT $LN12@GetCOp
	cmp	DWORD PTR tv72[rsp], 15649		; 00003d21H
	je	SHORT $LN9@GetCOp
	cmp	DWORD PTR tv72[rsp], 15676		; 00003d3cH
	je	SHORT $LN11@GetCOp
	jmp	SHORT $LN14@GetCOp
$LN47@GetCOp:
	cmp	DWORD PTR tv72[rsp], 15678		; 00003d3eH
	je	SHORT $LN10@GetCOp
	cmp	DWORD PTR tv72[rsp], 31868		; 00007c7cH
	je	SHORT $LN13@GetCOp
	jmp	SHORT $LN14@GetCOp
$LN8@GetCOp:

; 209  :     case CHARS_EQ:  rc = COP_EQ;  break;

	mov	DWORD PTR rc$[rsp], 1
	jmp	SHORT $LN2@GetCOp
$LN9@GetCOp:

; 210  :     case CHARS_NE:  rc = COP_NE;  break;

	mov	DWORD PTR rc$[rsp], 2
	jmp	SHORT $LN2@GetCOp
$LN10@GetCOp:

; 211  :     case CHARS_GE:  rc = COP_GE;  break;

	mov	DWORD PTR rc$[rsp], 5
	jmp	SHORT $LN2@GetCOp
$LN11@GetCOp:

; 212  :     case CHARS_LE:  rc = COP_LE;  break;

	mov	DWORD PTR rc$[rsp], 6
	jmp	SHORT $LN2@GetCOp
$LN12@GetCOp:

; 213  :     case CHARS_AND: rc = COP_AND; break;

	mov	DWORD PTR rc$[rsp], 7
	jmp	SHORT $LN2@GetCOp
$LN13@GetCOp:

; 214  :     case CHARS_OR:  rc = COP_OR;  break;

	mov	DWORD PTR rc$[rsp], 8
	jmp	SHORT $LN2@GetCOp
$LN14@GetCOp:

; 215  :     default: return(COP_NONE);

	xor	eax, eax
	jmp	$LN1@GetCOp
$LN2@GetCOp:

; 216  :     }
; 217  :   }

	jmp	$LN7@GetCOp
$LN6@GetCOp:

; 218  :   else if (size == 1) {

	cmp	DWORD PTR size$[rsp], 1
	jne	SHORT $LN15@GetCOp

; 219  :     switch (*p) {

	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv82[rsp], al
	cmp	BYTE PTR tv82[rsp], 33			; 00000021H
	je	SHORT $LN20@GetCOp
	cmp	BYTE PTR tv82[rsp], 38			; 00000026H
	je	SHORT $LN19@GetCOp
	cmp	BYTE PTR tv82[rsp], 60			; 0000003cH
	je	SHORT $LN18@GetCOp
	cmp	BYTE PTR tv82[rsp], 62			; 0000003eH
	je	SHORT $LN17@GetCOp
	jmp	SHORT $LN21@GetCOp
$LN17@GetCOp:

; 220  :     case '>': rc = COP_GT;   break;

	mov	DWORD PTR rc$[rsp], 3
	jmp	SHORT $LN4@GetCOp
$LN18@GetCOp:

; 221  :     case '<': rc = COP_LT;   break;

	mov	DWORD PTR rc$[rsp], 4
	jmp	SHORT $LN4@GetCOp
$LN19@GetCOp:

; 222  :     case '&': rc = COP_ANDB; break;

	mov	DWORD PTR rc$[rsp], 9
	jmp	SHORT $LN4@GetCOp
$LN20@GetCOp:

; 223  :     case '!': rc = COP_NEG;  break;

	mov	DWORD PTR rc$[rsp], 10
	jmp	SHORT $LN4@GetCOp
$LN21@GetCOp:

; 224  :     default: return(COP_NONE);

	xor	eax, eax
	jmp	$LN1@GetCOp
$LN4@GetCOp:

; 225  :     }
; 226  :   }

	jmp	$LN16@GetCOp
$LN15@GetCOp:

; 227  :   else {
; 228  :     if (item->token != T_ID)

	mov	rax, QWORD PTR item$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 8
	je	SHORT $LN22@GetCOp

; 229  :       return(COP_NONE);

	xor	eax, eax
	jmp	$LN1@GetCOp
$LN22@GetCOp:

; 230  :     /* a valid "flag" string must end with a question mark */
; 231  :     size = strlen(p);

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	DWORD PTR size$[rsp], eax

; 232  :     if (*(p + size - 1) != '?')

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax-1]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN23@GetCOp

; 233  :       return(COP_NONE);

	xor	eax, eax
	jmp	$LN1@GetCOp
$LN23@GetCOp:

; 234  :     if (size == 5 && (0 == _memicmp(p, "ZERO", 4)))

	cmp	DWORD PTR size$[rsp], 5
	jne	SHORT $LN24@GetCOp
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11037
	mov	rcx, QWORD PTR p$[rsp]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN24@GetCOp

; 235  :       rc = COP_ZERO;

	mov	DWORD PTR rc$[rsp], 11
	jmp	$LN25@GetCOp
$LN24@GetCOp:

; 236  :     else if (size == 6 && (0 == _memicmp(p, "CARRY", 5)))

	cmp	DWORD PTR size$[rsp], 6
	jne	SHORT $LN26@GetCOp
	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG11040
	mov	rcx, QWORD PTR p$[rsp]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN26@GetCOp

; 237  :       rc = COP_CARRY;

	mov	DWORD PTR rc$[rsp], 12
	jmp	$LN27@GetCOp
$LN26@GetCOp:

; 238  :     else if (size == 5 && (0 == _memicmp(p, "SIGN", 4)))

	cmp	DWORD PTR size$[rsp], 5
	jne	SHORT $LN28@GetCOp
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11043
	mov	rcx, QWORD PTR p$[rsp]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN28@GetCOp

; 239  :       rc = COP_SIGN;

	mov	DWORD PTR rc$[rsp], 13
	jmp	$LN29@GetCOp
$LN28@GetCOp:

; 240  :     else if (size == 7 && (0 == _memicmp(p, "PARITY", 6)))

	cmp	DWORD PTR size$[rsp], 7
	jne	SHORT $LN30@GetCOp
	mov	r8d, 6
	lea	rdx, OFFSET FLAT:$SG11046
	mov	rcx, QWORD PTR p$[rsp]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN30@GetCOp

; 241  :       rc = COP_PARITY;

	mov	DWORD PTR rc$[rsp], 14
	jmp	$LN31@GetCOp
$LN30@GetCOp:

; 242  :     else if (size == 9 && (0 == _memicmp(p, "OVERFLOW", 8)))

	cmp	DWORD PTR size$[rsp], 9
	jne	SHORT $LN32@GetCOp
	mov	r8d, 8
	lea	rdx, OFFSET FLAT:$SG11049
	mov	rcx, QWORD PTR p$[rsp]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN32@GetCOp

; 243  :       rc = COP_OVERFLOW;

	mov	DWORD PTR rc$[rsp], 15
	jmp	$LN33@GetCOp
$LN32@GetCOp:

; 244  :     //added by habran
; 245  :     else if (size == 5 && (0 == _memicmp(p, "LESS", 4)))

	cmp	DWORD PTR size$[rsp], 5
	jne	SHORT $LN34@GetCOp
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG11052
	mov	rcx, QWORD PTR p$[rsp]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN34@GetCOp

; 246  :       rc = COP_LESS;

	mov	DWORD PTR rc$[rsp], 16
	jmp	$LN35@GetCOp
$LN34@GetCOp:

; 247  :     else if (size == 8 && (0 == _memicmp(p, "GREATER", 7)))

	cmp	DWORD PTR size$[rsp], 8
	jne	SHORT $LN36@GetCOp
	mov	r8d, 7
	lea	rdx, OFFSET FLAT:$SG11055
	mov	rcx, QWORD PTR p$[rsp]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN36@GetCOp

; 248  :       rc = COP_GREATER;

	mov	DWORD PTR rc$[rsp], 17
	jmp	$LN37@GetCOp
$LN36@GetCOp:

; 249  :     else if (size == 6 && (0 == _memicmp(p, "ABOVE", 5)))

	cmp	DWORD PTR size$[rsp], 6
	jne	SHORT $LN38@GetCOp
	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG11058
	mov	rcx, QWORD PTR p$[rsp]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN38@GetCOp

; 250  :       rc = COP_ABOVE;

	mov	DWORD PTR rc$[rsp], 18
	jmp	SHORT $LN39@GetCOp
$LN38@GetCOp:

; 251  :     else if (size == 6 && (0 == _memicmp(p, "EQUAL", 5)))

	cmp	DWORD PTR size$[rsp], 6
	jne	SHORT $LN40@GetCOp
	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG11061
	mov	rcx, QWORD PTR p$[rsp]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN40@GetCOp

; 252  :       rc = COP_EQUAL;

	mov	DWORD PTR rc$[rsp], 19
	jmp	SHORT $LN41@GetCOp
$LN40@GetCOp:

; 253  :     else if (size == 6 && (0 == _memicmp(p, "BELOW", 5)))

	cmp	DWORD PTR size$[rsp], 6
	jne	SHORT $LN42@GetCOp
	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG11064
	mov	rcx, QWORD PTR p$[rsp]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN42@GetCOp

; 254  :       rc = COP_BELOW;

	mov	DWORD PTR rc$[rsp], 20
	jmp	SHORT $LN43@GetCOp
$LN42@GetCOp:

; 255  :     else
; 256  :       return(COP_NONE);

	xor	eax, eax
	jmp	SHORT $LN1@GetCOp
$LN43@GetCOp:
$LN41@GetCOp:
$LN39@GetCOp:
$LN37@GetCOp:
$LN35@GetCOp:
$LN33@GetCOp:
$LN31@GetCOp:
$LN29@GetCOp:
$LN27@GetCOp:
$LN25@GetCOp:
$LN16@GetCOp:
$LN7@GetCOp:

; 257  :   }
; 258  :   return(rc);

	mov	eax, DWORD PTR rc$[rsp]
$LN1@GetCOp:

; 259  : }

	add	rsp, 72					; 00000048H
	ret	0
GetCOp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
GetHllLabel PROC

; 180  :   return (++ModuleInfo.hll_label);

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	eax, DWORD PTR ModuleInfo+352

; 181  : }

	ret	0
GetHllLabel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
truelabel$ = 64
ptr$ = 72
nlabel$1 = 80
olabel$2 = 84
p$3 = 88
tv83 = 96
tv206 = 100
tv242 = 104
tv128 = 112
tv169 = 120
tv178 = 128
buff$4 = 136
__$ArrayPad$ = 152
hll$ = 176
i$ = 184
tokenarray$ = 192
ilabel$ = 200
is_true$ = 208
buffer$ = 216
hllop$ = 224
GetExpression PROC

; 779  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 780  :   char *ptr = buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR ptr$[rsp], rax

; 781  :   uint_32 truelabel = 0;

	mov	DWORD PTR truelabel$[rsp], 0

; 782  : 
; 783  :   DebugMsg1(("%u GetExpression(>%.32s< buf=>%s<) enter\n", ++evallvl, tokenarray[*i].tokpos, buffer));

	mov	eax, DWORD PTR evallvl
	inc	eax
	mov	DWORD PTR evallvl, eax
	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	r9, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+24]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11381
	call	DoDebugMsg1

; 784  : 
; 785  :   /* v2.08: structure changed from for(;;) to while() to increase
; 786  :   * readability and - optionally - handle the second operand differently
; 787  :   * than the first.
; 788  :   */
; 789  : 
; 790  :   if (ERROR == GetAndExpression(hll, i, tokenarray, ilabel, is_true, ptr, hllop)) {

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR ilabel$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetAndExpression
	cmp	eax, -1
	jne	SHORT $LN4@GetExpress

; 791  :     DebugMsg1(("%u GetExpression exit, error\n", evallvl--));

	mov	eax, DWORD PTR evallvl
	mov	DWORD PTR tv83[rsp], eax
	mov	eax, DWORD PTR evallvl
	dec	eax
	mov	DWORD PTR evallvl, eax
	mov	edx, DWORD PTR tv83[rsp]
	lea	rcx, OFFSET FLAT:$SG11383
	call	DoDebugMsg1

; 792  :     return(ERROR);

	mov	eax, -1
	jmp	$LN1@GetExpress
$LN4@GetExpress:
$LN2@GetExpress:

; 793  :   }
; 794  :   while (COP_OR == GetCOp(&tokenarray[*i])) {

	mov	rax, QWORD PTR i$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	GetCOp
	cmp	eax, 8
	jne	$LN3@GetExpress

; 795  : 
; 796  :     uint_32 nlabel;
; 797  :     uint_32 olabel;
; 798  :     char buff[16];
; 799  : 
; 800  :     /* the generated code of last simple expression has to be modified
; 801  :     1. the last jump must be inverted
; 802  :     2. a "is_true" label must be created (it's used to jump "behind" the expr)
; 803  :     3. create a new label
; 804  :     4. the current "false" label must be generated
; 805  : 
; 806  :     if it is a .REPEAT, step 4 is slightly more difficult, since the "false"
; 807  :     label is already "gone":
; 808  :     4a. create a new label
; 809  :     4b. replace the "false" label in the generated code by the new label
; 810  :     */
; 811  : 
; 812  :     (*i)++;

	mov	rax, QWORD PTR i$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax

; 813  :     DebugMsg1(("%u GetExpression: ||-operator found, is_true=%u, lastjmp=%s\n", evallvl, is_true, hllop->lastjmp ? hllop->lastjmp : "NULL"));

	mov	rax, QWORD PTR hllop$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN16@GetExpress
	mov	rax, QWORD PTR hllop$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv128[rsp], rax
	jmp	SHORT $LN17@GetExpress
$LN16@GetExpress:
	lea	rax, OFFSET FLAT:$SG11384
	mov	QWORD PTR tv128[rsp], rax
$LN17@GetExpress:
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	r9, QWORD PTR tv128[rsp]
	mov	r8d, eax
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11385
	call	DoDebugMsg1

; 814  : 
; 815  :     if (is_true == FALSE) {

	movzx	eax, BYTE PTR is_true$[rsp]
	test	eax, eax
	jne	$LN5@GetExpress

; 816  :       if (hllop->lastjmp) {

	mov	rax, QWORD PTR hllop$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN6@GetExpress

; 817  :         char *p = hllop->lastjmp;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$3[rsp], rax

; 818  :         InvertJump(p);           /* step 1 */

	mov	rcx, QWORD PTR p$3[rsp]
	call	InvertJump

; 819  :         if (truelabel == 0)      /* step 2 */

	cmp	DWORD PTR truelabel$[rsp], 0
	jne	SHORT $LN7@GetExpress

; 820  :           truelabel = GetHllLabel();

	call	GetHllLabel
	mov	DWORD PTR truelabel$[rsp], eax
$LN7@GetExpress:

; 821  :         if (*p) { /* v2.11: there might be a 0 at lastjmp */

	mov	rax, QWORD PTR p$3[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN8@GetExpress

; 822  :           p += 4;                /* skip 'jcc ' or 'jmp ' */

	mov	rax, QWORD PTR p$3[rsp]
	add	rax, 4
	mov	QWORD PTR p$3[rsp], rax

; 823  :           GetLabelStr(truelabel, p);

	mov	rdx, QWORD PTR p$3[rsp]
	mov	ecx, DWORD PTR truelabel$[rsp]
	call	GetLabelStr

; 824  :           strcat(p, EOLSTR);

	lea	rdx, OFFSET FLAT:$SG11390
	mov	rcx, QWORD PTR p$3[rsp]
	call	strcat
$LN8@GetExpress:

; 825  :         }
; 826  :         /* v2.08: if-block added */
; 827  :         if (hllop->lasttruelabel)

	mov	rax, QWORD PTR hllop$[rsp]
	cmp	DWORD PTR [rax+8], 0
	je	SHORT $LN9@GetExpress

; 828  :           ReplaceLabel(ptr, hllop->lasttruelabel, truelabel);

	mov	r8d, DWORD PTR truelabel$[rsp]
	mov	rax, QWORD PTR hllop$[rsp]
	mov	edx, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR ptr$[rsp]
	call	ReplaceLabel
$LN9@GetExpress:

; 829  :         DebugMsg1(("%u GetExpression: jmp inverted, dest changed >%s<\n", evallvl, ptr));

	mov	r8, QWORD PTR ptr$[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11392
	call	DoDebugMsg1

; 830  :         hllop->lastjmp = NULL;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rax], 0

; 831  : 
; 832  :         nlabel = GetHllLabel();  /* step 3 */

	call	GetHllLabel
	mov	DWORD PTR nlabel$1[rsp], eax

; 833  :         olabel = GetLabel(hll, ilabel);

	mov	edx, DWORD PTR ilabel$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetLabel
	mov	DWORD PTR olabel$2[rsp], eax

; 834  :         if (hll->cmd == HLL_REPEAT) {

	mov	rax, QWORD PTR hll$[rsp]
	cmp	DWORD PTR [rax+68], 2
	jne	SHORT $LN10@GetExpress

; 835  :           ReplaceLabel(buffer, olabel, nlabel);

	mov	r8d, DWORD PTR nlabel$1[rsp]
	mov	edx, DWORD PTR olabel$2[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	ReplaceLabel

; 836  :           sprintf(ptr + strlen(ptr), "%s" LABELQUAL EOLSTR, GetLabelStr(nlabel, buff));

	lea	rdx, QWORD PTR buff$4[rsp]
	mov	ecx, DWORD PTR nlabel$1[rsp]
	call	GetLabelStr
	mov	QWORD PTR tv169[rsp], rax
	mov	rcx, QWORD PTR ptr$[rsp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR tv169[rsp]
	mov	r8, rcx
	lea	rdx, OFFSET FLAT:$SG11395
	mov	rcx, rax
	call	sprintf

; 837  :         }

	jmp	SHORT $LN11@GetExpress
$LN10@GetExpress:

; 838  :         else {
; 839  :           sprintf(ptr + strlen(ptr), "%s" LABELQUAL EOLSTR, GetLabelStr(olabel, buff));

	lea	rdx, QWORD PTR buff$4[rsp]
	mov	ecx, DWORD PTR olabel$2[rsp]
	call	GetLabelStr
	mov	QWORD PTR tv178[rsp], rax
	mov	rcx, QWORD PTR ptr$[rsp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR tv178[rsp]
	mov	r8, rcx
	lea	rdx, OFFSET FLAT:$SG11396
	mov	rcx, rax
	call	sprintf

; 840  :           ReplaceLabel(buffer, olabel, nlabel);

	mov	r8d, DWORD PTR nlabel$1[rsp]
	mov	edx, DWORD PTR olabel$2[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	ReplaceLabel
$LN11@GetExpress:

; 841  :         }
; 842  :         DebugMsg1(("%u GetExpression: dest changed, label added >%s<\n", evallvl, ptr));

	mov	r8, QWORD PTR ptr$[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11397
	call	DoDebugMsg1
$LN6@GetExpress:
$LN5@GetExpress:

; 843  :       }
; 844  :     }
; 845  :     ptr += strlen(ptr);

	mov	rcx, QWORD PTR ptr$[rsp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rsp], rax

; 846  :     hllop->lasttruelabel = 0; /* v2.08 */

	mov	rax, QWORD PTR hllop$[rsp]
	mov	DWORD PTR [rax+8], 0

; 847  :     if (ERROR == GetAndExpression(hll, i, tokenarray, ilabel, is_true, ptr, hllop)) {

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR ilabel$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	call	GetAndExpression
	cmp	eax, -1
	jne	SHORT $LN12@GetExpress

; 848  :       DebugMsg1(("%u GetExpression exit, error\n", evallvl--));

	mov	eax, DWORD PTR evallvl
	mov	DWORD PTR tv206[rsp], eax
	mov	eax, DWORD PTR evallvl
	dec	eax
	mov	DWORD PTR evallvl, eax
	mov	edx, DWORD PTR tv206[rsp]
	lea	rcx, OFFSET FLAT:$SG11399
	call	DoDebugMsg1

; 849  :       return(ERROR);

	mov	eax, -1
	jmp	$LN1@GetExpress
$LN12@GetExpress:

; 850  :     }
; 851  :   }

	jmp	$LN2@GetExpress
$LN3@GetExpress:

; 852  :   if (truelabel > 0) {

	cmp	DWORD PTR truelabel$[rsp], 0
	jbe	$LN13@GetExpress

; 853  :     /* v2.08: this is needed, but ober-hackish. to be improved... */
; 854  :     if (hllop->lastjmp && hllop->lasttruelabel) {

	mov	rax, QWORD PTR hllop$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN14@GetExpress
	mov	rax, QWORD PTR hllop$[rsp]
	cmp	DWORD PTR [rax+8], 0
	je	SHORT $LN14@GetExpress

; 855  :       DebugMsg1(("%u GetExpression: suppressed ReplaceLabel %u -> %u, lastjmp=%s\n", evallvl, hllop->lasttruelabel, truelabel, hllop->lastjmp));

	mov	rax, QWORD PTR hllop$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR truelabel$[rsp]
	mov	rax, QWORD PTR hllop$[rsp]
	mov	r8d, DWORD PTR [rax+8]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11402
	call	DoDebugMsg1

; 856  :       ReplaceLabel(ptr, hllop->lasttruelabel, truelabel);

	mov	r8d, DWORD PTR truelabel$[rsp]
	mov	rax, QWORD PTR hllop$[rsp]
	mov	edx, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR ptr$[rsp]
	call	ReplaceLabel

; 857  :       *(strchr(hllop->lastjmp, EOLCHAR) + 1) = NULLC;

	mov	edx, 94					; 0000005eH
	mov	rax, QWORD PTR hllop$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	strchr
	mov	BYTE PTR [rax+1], 0
$LN14@GetExpress:

; 858  :     }
; 859  :     ptr += strlen(ptr);

	mov	rcx, QWORD PTR ptr$[rsp]
	call	strlen
	mov	rcx, QWORD PTR ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$[rsp], rax

; 860  :     GetLabelStr(truelabel, ptr);

	mov	rdx, QWORD PTR ptr$[rsp]
	mov	ecx, DWORD PTR truelabel$[rsp]
	call	GetLabelStr

; 861  :     strcat(ptr, LABELQUAL EOLSTR);

	lea	rdx, OFFSET FLAT:$SG11403
	mov	rcx, QWORD PTR ptr$[rsp]
	call	strcat

; 862  :     DebugMsg1(("%u GetExpression: label added >%s<\n", evallvl, ptr));

	mov	r8, QWORD PTR ptr$[rsp]
	mov	edx, DWORD PTR evallvl
	lea	rcx, OFFSET FLAT:$SG11404
	call	DoDebugMsg1

; 863  :     hllop->lasttruelabel = truelabel; /* v2.08 */

	mov	rax, QWORD PTR hllop$[rsp]
	mov	ecx, DWORD PTR truelabel$[rsp]
	mov	DWORD PTR [rax+8], ecx
$LN13@GetExpress:

; 864  :   }
; 865  :   DebugMsg1(("%u GetExpression exit\n", evallvl--));

	mov	eax, DWORD PTR evallvl
	mov	DWORD PTR tv242[rsp], eax
	mov	eax, DWORD PTR evallvl
	dec	eax
	mov	DWORD PTR evallvl, eax
	mov	edx, DWORD PTR tv242[rsp]
	lea	rcx, OFFSET FLAT:$SG11405
	call	DoDebugMsg1

; 866  :   return(NOT_ERROR);

	xor	eax, eax
$LN1@GetExpress:

; 867  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 168				; 000000a8H
	ret	0
GetExpression ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
HllCheckOpen PROC

; 2748 : {

$LN4:
	sub	rsp, 56					; 00000038H

; 2749 :   if (HllStack) {

	cmp	QWORD PTR ModuleInfo+224, 0
	je	SHORT $LN2@HllCheckOp

; 2750 :     //EmitErr( BLOCK_NESTING_ERROR, ".if-.repeat-.while" );
; 2751 :     EmitErr(UNMATCHED_BLOCK_NESTING, ".if-.repeat-.while");

	lea	rdx, OFFSET FLAT:$SG12591
	mov	ecx, 142				; 0000008eH
	call	EmitErr
$LN2@HllCheckOp:

; 2752 :   }
; 2753 :   DebugMsg(("HllCheckOpen: allocated items:%u, reused items:%u, .while cond-blocks/bytes:%u/%u\n", cntAlloc, cntReused, cntCond, cntCondBytes));

	mov	eax, DWORD PTR cntCondBytes
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR cntCond
	mov	r8d, DWORD PTR cntReused
	mov	edx, DWORD PTR cntAlloc
	lea	rcx, OFFSET FLAT:$SG12592
	call	DoDebugMsg

; 2754 : }

	add	rsp, 56					; 00000038H
	ret	0
HllCheckOpen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
pass$ = 8
HllInit	PROC

; 2776 : {

	mov	DWORD PTR [rsp+8], ecx

; 2777 :   //if ( pass == PASS_1 )
; 2778 :   //    HllFree = NULL;
; 2779 : 
; 2780 :   //HllStack = NULL; /* empty stack of open hll directives */
; 2781 :   ModuleInfo.hll_label = 0; /* init hll label counter */

	mov	DWORD PTR ModuleInfo+352, 0

; 2782 : #ifdef DEBUG_OUT
; 2783 :   evallvl = 0;

	mov	DWORD PTR evallvl, 0

; 2784 :   if (pass == PASS_1) {

	cmp	DWORD PTR pass$[rsp], 0
	jne	SHORT $LN2@HllInit

; 2785 :     cntAlloc = 0;

	mov	DWORD PTR cntAlloc, 0

; 2786 :     cntReused = 0;

	mov	DWORD PTR cntReused, 0

; 2787 :     cntCond = 0;

	mov	DWORD PTR cntCond, 0

; 2788 :     cntCondBytes = 0;

	mov	DWORD PTR cntCondBytes, 0
$LN2@HllInit:

; 2789 :   }
; 2790 : #endif
; 2791 :   return;
; 2792 : }

	ret	0
HllInit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1788 : }

	add	rsp, 56					; 00000038H
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

	add	rsp, 56					; 00000038H
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	__stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1391 : }

	add	rsp, 72					; 00000048H
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
