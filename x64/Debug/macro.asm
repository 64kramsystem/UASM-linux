; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG10851 DB	'%X', 00H
	ORG $+5
$SG10908 DB	'store_placeholders: found ID: %s', 0aH, 00H
	ORG $+2
$SG10915 DB	'<>"''', 00H
	ORG $+3
$SG11023 DB	'REQ', 00H
$SG11006 DB	'StoreMacro(%s, i=%u, store_data=%u) enter, params=>%s<', 0aH
	DB	00H
$SG11032 DB	'VARARGML', 00H
	ORG $+7
$SG11034 DB	'StoreMacro(%s): param=>%s< found', 0aH, 00H
	ORG $+6
$SG11036 DB	'StoreMacro(%s): macro parameters done', 0aH, 00H
	ORG $+1
$SG11046 DB	'StoreMacro(%s): no token', 0aH, 00H
	ORG $+6
$SG11056 DB	'StoreMacro(%s, %u): local=>%s< added, rest=%s', 0aH, 00H
	ORG $+1
$SG11067 DB	'StoreMacro(%s): exitm found, lvl=%u, >%s<', 0aH, 00H
	ORG $+5
$SG11072 DB	'StoreMacro(%s): endm found, lvl=%u', 0aH, 00H
	ORG $+4
$SG11088 DB	'StoreMacro(%s, %u): cnt=%u, %u. line >%s<', 0aH, 00H
	ORG $+5
$SG11089 DB	'StoreMacro(%s): exit, no error, isfunc=%u', 0aH, 00H
	ORG $+5
$SG11113 DB	'ReleaseMacroData(%s) enter', 0aH, 00H
	ORG $+4
$SG11129 DB	'MacroDir(%s) enter, i=%u', 0aH, 00H
	ORG $+6
$SG11138 DB	'MacroDir(%s): macro already defined', 0aH, 00H
	ORG $+3
$SG11155 DB	'macro name', 00H
	ORG $+5
$SG11177 DB	'MacroInit(%u)', 0aH, 00H
	ORG $+1
$SG11179 DB	'@Environ', 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	CreateMacro
PUBLIC	ReleaseMacroData
PUBLIC	fill_placeholders
PUBLIC	StoreMacro
PUBLIC	MacroInit
PUBLIC	MacroFini
PUBLIC	RenderMacroLine
PUBLIC	MacroDir
PUBLIC	PurgeDirective
EXTRN	__imp_isalpha:PROC
EXTRN	__imp_isdigit:PROC
EXTRN	__imp_isspace:PROC
EXTRN	__imp_isalnum:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp_getenv:PROC
EXTRN	memcpy:PROC
EXTRN	__imp_memmove:PROC
EXTRN	memset:PROC
EXTRN	__imp_strchr:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	Fatal:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	LclAlloc:PROC
EXTRN	SymCreate:PROC
EXTRN	SymFind:PROC
EXTRN	sym_remove_table:PROC
EXTRN	GetTextLine:PROC
EXTRN	get_curr_srcfile:PROC
EXTRN	GetToken:PROC
EXTRN	StringInit:PROC
EXTRN	StringFini:PROC
EXTRN	LstWrite:PROC
EXTRN	LstWriteSrcLine:PROC
EXTRN	_RTC_AllocaHelper:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_CheckStackVars2:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	MacroLevel:BYTE
EXTRN	SymCmpFunc:QWORD
EXTRN	SymTables:BYTE
EXTRN	MacroLocals:DWORD
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
?buffer@?1??RenderMacroLine@@9@9 DB 0258H DUP (?)	; `RenderMacroLine'::`2'::buffer
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$CreateMacro DD imagerel $LN4
	DD	imagerel $LN4+232
	DD	imagerel $unwind$CreateMacro
$pdata$ReleaseMacroData DD imagerel $LN10
	DD	imagerel $LN10+262
	DD	imagerel $unwind$ReleaseMacroData
$pdata$fill_placeholders DD imagerel $LN13
	DD	imagerel $LN13+552
	DD	imagerel $unwind$fill_placeholders
$pdata$StoreMacro DD imagerel $LN106
	DD	imagerel $LN106+4308
	DD	imagerel $unwind$StoreMacro
$pdata$MacroInit DD imagerel $LN4
	DD	imagerel $LN4+270
	DD	imagerel $unwind$MacroInit
$pdata$MacroFini DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$MacroFini
$pdata$HexDigit DD imagerel HexDigit
	DD	imagerel HexDigit+85
	DD	imagerel $unwind$HexDigit
$pdata$replace_parm DD imagerel replace_parm
	DD	imagerel replace_parm+477
	DD	imagerel $unwind$replace_parm
$pdata$store_placeholders DD imagerel store_placeholders
	DD	imagerel store_placeholders+987
	DD	imagerel $unwind$store_placeholders
$pdata$RenderMacroLine DD imagerel $LN10
	DD	imagerel $LN10+293
	DD	imagerel $unwind$RenderMacroLine
$pdata$MacroDir DD imagerel $LN12
	DD	imagerel $LN12+454
	DD	imagerel $unwind$MacroDir
$pdata$PurgeDirective DD imagerel $LN12
	DD	imagerel $LN12+387
	DD	imagerel $unwind$PurgeDirective
$pdata$EnvironFunc DD imagerel EnvironFunc
	DD	imagerel EnvironFunc+176
	DD	imagerel $unwind$EnvironFunc
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
StoreMacro$rtcName$0 DB 06cH
	DB	073H
	DB	00H
	ORG $+1
StoreMacro$rtcName$1 DB 074H
	DB	06fH
	DB	06bH
	DB	00H
StoreMacro$rtcName$2 DB 06dH
	DB	06eH
	DB	061H
	DB	06dH
	DB	065H
	DB	073H
	DB	00H
	ORG $+1
StoreMacro$rtcName$3 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
StoreMacro$rtcName$4 DB 05fH
	DB	05fH
	DB	024H
	DB	041H
	DB	06cH
	DB	06cH
	DB	06fH
	DB	063H
	DB	061H
	DB	050H
	DB	061H
	DB	064H
	DB	024H
	DB	00H
	ORG $+2
StoreMacro$rtcFrameData DD 05H
	DD	00H
	DQ	FLAT:StoreMacro$rtcVarDesc
	ORG $+8
StoreMacro$rtcVarDesc DD 013d8H
	DD	08H
	DQ	FLAT:StoreMacro$rtcName$4
	DD	01140H
	DD	0258H
	DQ	FLAT:StoreMacro$rtcName$3
	DD	0120H
	DD	01000H
	DQ	FLAT:StoreMacro$rtcName$2
	DD	0c0H
	DD	040H
	DQ	FLAT:StoreMacro$rtcName$1
	DD	078H
	DD	020H
	DQ	FLAT:StoreMacro$rtcName$0
CONST	ENDS
xdata	SEGMENT
$unwind$CreateMacro DD 021e01H
	DD	07006520aH
$unwind$ReleaseMacroData DD 021e01H
	DD	07006720aH
$unwind$fill_placeholders DD 022d01H
	DD	070157219H
$unwind$StoreMacro DD 035054f19H
	DD	01223327H
	DD	070150281H
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	013f8H
$unwind$MacroInit DD 021c01H
	DD	070055209H
$unwind$MacroFini DD 021501H
	DD	070023206H
$unwind$HexDigit DD 021d01H
	DD	070051209H
$unwind$replace_parm DD 022d01H
	DD	070157219H
$unwind$store_placeholders DD 022301H
	DD	0700b920fH
$unwind$RenderMacroLine DD 021e01H
	DD	07006120aH
$unwind$MacroDir DD 022101H
	DD	0700a720eH
$unwind$PurgeDirective DD 022101H
	DD	0700a520eH
$unwind$EnvironFunc DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
p$ = 32
i$ = 40
mi$ = 64
buffer$ = 72
tokenarray$ = 80
EnvironFunc PROC

; 782  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 783  :     char *p = getenv( mi->parm_array[0] );

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR mi$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR [rcx+rax]
	call	QWORD PTR __imp_getenv
	mov	QWORD PTR p$[rsp], rax

; 784  :     int i;
; 785  : 
; 786  :     buffer[0] = NULLC;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 787  :     if ( p ) {

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN2@EnvironFun

; 788  :         i = strlen( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax

; 789  :         if ( i >= MAX_LINE_LEN )

	cmp	DWORD PTR i$[rsp], 600			; 00000258H
	jl	SHORT $LN3@EnvironFun

; 790  :             i = MAX_LINE_LEN - 1;

	mov	DWORD PTR i$[rsp], 599			; 00000257H
$LN3@EnvironFun:

; 791  :         memcpy( buffer, p, i );

	movsxd	rax, DWORD PTR i$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memcpy

; 792  :         buffer[i] = NULLC;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rcx+rax], 0
$LN2@EnvironFun:

; 793  :     }
; 794  :     return( NOT_ERROR );

	xor	eax, eax

; 795  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
EnvironFunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
sym$ = 32
i$ = 64
tokenarray$ = 72
PurgeDirective PROC

; 736  : {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+64]

; 737  :     struct asym *sym;
; 738  : 
; 739  :     i++; /* skip directive */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@PurgeDirec:

; 740  :     do {
; 741  :         if ( tokenarray[i].token != T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN5@PurgeDirec

; 742  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@PurgeDirec
$LN5@PurgeDirec:

; 743  :         }
; 744  :         sym = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 745  :         if ( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN6@PurgeDirec

; 746  :             return( EmitErr( SYMBOL_NOT_DEFINED, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr
	jmp	$LN1@PurgeDirec
$LN6@PurgeDirec:

; 747  :         }
; 748  :         if ( sym->state != SYM_MACRO ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	je	SHORT $LN7@PurgeDirec

; 749  :             return( EmitErr( EXPECTED, "macro name" ) );

	lea	rdx, OFFSET FLAT:$SG11155
	mov	ecx, 230				; 000000e6H
	call	EmitErr
	jmp	$LN1@PurgeDirec
$LN7@PurgeDirec:

; 750  :         }
; 751  : #if TRUEPURGE
; 752  :         sym->defined = FALSE;
; 753  : #else
; 754  : #if FASTMEM==0
; 755  :         /* don't free memory of macro data lines if macro is in use */
; 756  :         if ( MacroInUse( (struct dsym *)sym ) ) {
; 757  :             DebugMsg1(("PurgeDirective(%s): macro is in use\n", sym->name ));
; 758  :             ((struct dsym *)sym)->e.macroinfo->data = NULL;
; 759  :         }
; 760  : #endif
; 761  :         ReleaseMacroData( (struct dsym *)sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	ReleaseMacroData

; 762  :         sym->variable = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 763  :         sym->purged = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	or	al, 16
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+44], al

; 764  : #endif
; 765  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 766  :         if ( i < Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN8@PurgeDirec

; 767  :             if ( tokenarray[i].token != T_COMMA || tokenarray[i+1].token == T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN10@PurgeDirec
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN9@PurgeDirec
$LN10@PurgeDirec:

; 768  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@PurgeDirec
$LN9@PurgeDirec:

; 769  :             }
; 770  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN8@PurgeDirec:

; 771  :         }
; 772  :     } while ( i < Token_Count );

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jl	$LN4@PurgeDirec

; 773  : 
; 774  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@PurgeDirec:

; 775  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
PurgeDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
name$ = 32
store_data$ = 40
macro$ = 48
i$ = 80
tokenarray$ = 88
MacroDir PROC

; 675  : {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+80]

; 676  :     char                *name;
; 677  :     bool                store_data;
; 678  :     struct dsym         *macro;
; 679  : 
; 680  :     name = tokenarray[0].string_ptr;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR name$[rsp], rax

; 681  :     DebugMsg1(("MacroDir(%s) enter, i=%u\n", name, i ));

	mov	r8d, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11129
	call	DoDebugMsg1

; 682  : 
; 683  :     macro = (struct dsym *)SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR macro$[rsp], rax

; 684  :     if( macro == NULL ) {

	cmp	QWORD PTR macro$[rsp], 0
	jne	SHORT $LN2@MacroDir

; 685  :         macro = CreateMacro( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	CreateMacro
	mov	QWORD PTR macro$[rsp], rax
	jmp	$LN3@MacroDir
$LN2@MacroDir:

; 686  :     } else if( macro->sym.state != SYM_MACRO ) {

	mov	rax, QWORD PTR macro$[rsp]
	cmp	DWORD PTR [rax+32], 9
	je	SHORT $LN4@MacroDir

; 687  :         if ( macro->sym.state != SYM_UNDEFINED ) {

	mov	rax, QWORD PTR macro$[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN5@MacroDir

; 688  :             return( EmitErr( SYMBOL_REDEFINITION, name ) );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@MacroDir
$LN5@MacroDir:

; 689  :         }
; 690  :         /* the macro was used before it's defined. That's
; 691  :          * a severe error. Nevertheless define the macro now,
; 692  :          * error msg 'invalid symbol type in expression' will
; 693  :          * be displayed in second pass when the (unexpanded)
; 694  :          * macro name is found by the expression evaluator.
; 695  :          */
; 696  :         sym_remove_table( &SymTables[TAB_UNDEF], macro );

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR macro$[rsp]
	mov	rcx, rax
	call	sym_remove_table

; 697  :         macro->sym.state = SYM_MACRO;

	mov	rax, QWORD PTR macro$[rsp]
	mov	DWORD PTR [rax+32], 9

; 698  :         macro->e.macroinfo = LclAlloc( sizeof( struct macro_info ) );

	mov	ecx, 32					; 00000020H
	call	LclAlloc
	mov	rcx, QWORD PTR macro$[rsp]
	mov	QWORD PTR [rcx+96], rax

; 699  :         memset( macro->e.macroinfo, 0, sizeof( struct macro_info ) );

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rax, QWORD PTR macro$[rsp]
	mov	rcx, QWORD PTR [rax+96]
	call	memset
$LN4@MacroDir:
$LN3@MacroDir:

; 700  :     }
; 701  :     macro->e.macroinfo->srcfile = get_curr_srcfile();

	call	get_curr_srcfile
	mov	rcx, QWORD PTR macro$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	DWORD PTR [rcx+28], eax

; 702  : 
; 703  :     if ( ( Parse_Pass == PASS_1 ) || ( macro->sym.variable ) ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN8@MacroDir
	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@MacroDir
$LN8@MacroDir:

; 704  :         /* is the macro redefined? */
; 705  :         if ( macro->e.macroinfo->data != NULL ) {

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN9@MacroDir

; 706  :             DebugMsg(("MacroDir(%s): macro already defined\n", name));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11138
	call	DoDebugMsg

; 707  : #if FASTMEM==0
; 708  :             /* don't free memory of macro data lines if macro is in use */
; 709  :             if ( MacroInUse( macro ) )
; 710  :                 macro->e.macroinfo->data = NULL;
; 711  : #endif
; 712  :             ReleaseMacroData( macro );

	mov	rcx, QWORD PTR macro$[rsp]
	call	ReleaseMacroData

; 713  :             /* v2.07: isfunc isn't reset anymore in ReleaseMacroData() */
; 714  :             macro->sym.isfunc = FALSE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+44], al

; 715  :             macro->sym.variable = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+40], al
$LN9@MacroDir:

; 716  :         }
; 717  :         store_data = TRUE;

	mov	BYTE PTR store_data$[rsp], 1

; 718  :     } else

	jmp	SHORT $LN7@MacroDir
$LN6@MacroDir:

; 719  :         store_data = FALSE;

	mov	BYTE PTR store_data$[rsp], 0
$LN7@MacroDir:

; 720  : 
; 721  :     if ( ModuleInfo.list )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN10@MacroDir

; 722  :         LstWriteSrcLine();

	call	LstWriteSrcLine
$LN10@MacroDir:

; 723  : 
; 724  :     return( StoreMacro( macro, ++i, tokenarray, store_data ) );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	movzx	r9d, BYTE PTR store_data$[rsp]
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR macro$[rsp]
	call	StoreMacro
$LN1@MacroDir:

; 725  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
MacroDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
dst$ = 0
src$ = 32
RenderMacroLine PROC

; 254  : {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 255  :     /* a macro line cannot be displayed directly due to the format of
; 256  :      * the index field. for debug log, convert it to a readable format.
; 257  :      */
; 258  :     char *dst;
; 259  :     static char buffer[MAX_LINE_LEN]; /* debug only */
; 260  : 
; 261  :     for ( dst = buffer; *src; src++, dst++ ) {

	lea	rax, OFFSET FLAT:?buffer@?1??RenderMacroLine@@9@9
	mov	QWORD PTR dst$[rsp], rax
	jmp	SHORT $LN4@RenderMacr
$LN2@RenderMacr:
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
$LN4@RenderMacr:
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@RenderMacr

; 262  :         if (*src == PLACEHOLDER_CHAR ) {

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 10
	jne	$LN5@RenderMacr

; 263  :             *dst++ = '#';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 35			; 00000023H
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 264  :             src++;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 265  :             *dst = *src / 16 + '0';

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	add	eax, 48					; 00000030H
	mov	rcx, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rcx], al

; 266  :             if (*dst > '9')

	mov	rax, QWORD PTR dst$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN7@RenderMacr

; 267  :                 *dst += 7;

	mov	rax, QWORD PTR dst$[rsp]
	movsx	eax, BYTE PTR [rax]
	add	eax, 7
	mov	rcx, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rcx], al
$LN7@RenderMacr:

; 268  :             dst++;

	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 269  :             *dst = *src % 16 + '0';

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	add	eax, 48					; 00000030H
	mov	rcx, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rcx], al

; 270  :             if (*dst > '9')

	mov	rax, QWORD PTR dst$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN8@RenderMacr

; 271  :                 *dst += 7;

	mov	rax, QWORD PTR dst$[rsp]
	movsx	eax, BYTE PTR [rax]
	add	eax, 7
	mov	rcx, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rcx], al
$LN8@RenderMacr:

; 272  :         } else

	jmp	SHORT $LN6@RenderMacr
$LN5@RenderMacr:

; 273  :             *dst = *src;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
$LN6@RenderMacr:

; 274  :     }

	jmp	$LN2@RenderMacr
$LN3@RenderMacr:

; 275  :     *dst = NULLC;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 0

; 276  :     return( buffer );

	lea	rax, OFFSET FLAT:?buffer@?1??RenderMacroLine@@9@9

; 277  : }

	add	rsp, 16
	pop	rdi
	ret	0
RenderMacroLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
p$ = 32
start$ = 40
quote$ = 48
brlevel$ = 52
params$ = 56
qlevel$ = 60
substprf$ = 64
tv153 = 68
tv177 = 72
tv193 = 76
line$ = 96
mnames$ = 104
store_placeholders PROC

; 178  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 179  :     /* scan a macro source line for parameter and local names.
; 180  :      * - line: the source line
; 181  :      * - mnames: list of macro params + locals
; 182  :      * if a param/local is found, replace the name by a 2-byte placeholder.
; 183  :      */
; 184  :     char *p;
; 185  :     char *start;
; 186  :     char quote = NULLC;

	mov	BYTE PTR quote$[rsp], 0

; 187  :     int brlevel = 0;

	mov	DWORD PTR brlevel$[rsp], 0

; 188  :     int params = 0; /* number of replacements in this line */

	mov	DWORD PTR params$[rsp], 0

; 189  :     int qlevel = 0;

	mov	DWORD PTR qlevel$[rsp], 0

; 190  :     bool substprf;  /* substitution character before ID? */
; 191  : 
; 192  :     for( p = line; *p != NULLC; ) {

	mov	rax, QWORD PTR line$[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN2@store_plac:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@store_plac

; 193  :         if ( isdigit( *p) ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isdigit
	test	eax, eax
	je	SHORT $LN11@store_plac
$LN5@store_plac:

; 194  :             /* skip numbers (they may contain alphas)
; 195  :              * this is not exactly what masm does. Masm
; 196  :              * stops at the first non-digit.
; 197  :              */
; 198  :             while ( is_valid_id_char( *p )) p++;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	SHORT $LN13@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN13@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN13@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN13@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN6@store_plac
$LN13@store_plac:
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN5@store_plac
$LN6@store_plac:

; 199  :         } else if ( ( is_valid_id_char( *p ) ) ||

	jmp	$LN12@store_plac
$LN11@store_plac:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	$LN16@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	$LN16@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	$LN16@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	$LN16@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	$LN16@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	jne	$LN14@store_plac
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	je	$LN14@store_plac
	mov	rax, QWORD PTR line$[rsp]
	cmp	QWORD PTR p$[rsp], rax
	je	SHORT $LN17@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 93					; 0000005dH
	je	$LN14@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	SHORT $LN33@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN33@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN33@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN33@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN33@store_plac
	mov	DWORD PTR tv153[rsp], 0
	jmp	SHORT $LN34@store_plac
$LN33@store_plac:
	mov	DWORD PTR tv153[rsp], 1
$LN34@store_plac:
	cmp	DWORD PTR tv153[rsp], 0
	jne	$LN14@store_plac
$LN17@store_plac:
$LN16@store_plac:

; 200  :                    ( *p == '.' &&
; 201  :                     ModuleInfo.dotname &&
; 202  :                     //is_valid_id_char(*(p+1)) && /* v2.05: masm allows a single dot as param/local name */
; 203  :                     ( p == line ||
; 204  :                      ( *(p-1) != ']' && ( is_valid_id_char( *(p-1) ) == FALSE ) ) ) ) ) {
; 205  :             DebugMsg1(("store_placeholders: found ID: %s\n", p));

	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, OFFSET FLAT:$SG10908
	call	DoDebugMsg1

; 206  :             start = p++;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR start$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN7@store_plac:

; 207  :             while ( is_valid_id_char( *p )) p++;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	SHORT $LN18@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN18@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN18@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN18@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN8@store_plac
$LN18@store_plac:
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN7@store_plac
$LN8@store_plac:

; 208  :             /* v2.08: both a '&' before AND after the name trigger substitution (and disappear) */
; 209  :             substprf = ( ( start > line && *(start-1) == '&') || *p == '&' );

	mov	rax, QWORD PTR line$[rsp]
	cmp	QWORD PTR start$[rsp], rax
	jbe	SHORT $LN35@store_plac
	mov	rax, QWORD PTR start$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN36@store_plac
$LN35@store_plac:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN36@store_plac
	mov	DWORD PTR tv177[rsp], 0
	jmp	SHORT $LN37@store_plac
$LN36@store_plac:
	mov	DWORD PTR tv177[rsp], 1
$LN37@store_plac:
	movzx	eax, BYTE PTR tv177[rsp]
	mov	BYTE PTR substprf$[rsp], al

; 210  :             if ( quote == NULLC || substprf ) {

	movsx	eax, BYTE PTR quote$[rsp]
	test	eax, eax
	je	SHORT $LN20@store_plac
	movzx	eax, BYTE PTR substprf$[rsp]
	test	eax, eax
	je	SHORT $LN19@store_plac
$LN20@store_plac:

; 211  :                 /* look for this word in the macro parms, and replace it if it is */
; 212  :                 if ( start = replace_parm( line, start, p - start, mnames ) ) {

	mov	rax, QWORD PTR start$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r9, QWORD PTR mnames$[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR start$[rsp]
	mov	rcx, QWORD PTR line$[rsp]
	call	replace_parm
	mov	QWORD PTR start$[rsp], rax
	cmp	QWORD PTR start$[rsp], 0
	je	SHORT $LN21@store_plac

; 213  :                     params++;

	mov	eax, DWORD PTR params$[rsp]
	inc	eax
	mov	DWORD PTR params$[rsp], eax

; 214  :                     p = start;

	mov	rax, QWORD PTR start$[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN21@store_plac:
$LN19@store_plac:

; 215  :                 }
; 216  :             }
; 217  :         } else {

	jmp	$LN15@store_plac
$LN14@store_plac:

; 218  :             switch (*p) {

	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv193[rsp], al
	cmp	BYTE PTR tv193[rsp], 33			; 00000021H
	je	SHORT $LN22@store_plac
	cmp	BYTE PTR tv193[rsp], 34			; 00000022H
	je	SHORT $LN28@store_plac
	cmp	BYTE PTR tv193[rsp], 39			; 00000027H
	je	SHORT $LN28@store_plac
	cmp	BYTE PTR tv193[rsp], 60			; 0000003cH
	je	SHORT $LN24@store_plac
	cmp	BYTE PTR tv193[rsp], 62			; 0000003eH
	je	SHORT $LN25@store_plac
	jmp	$LN9@store_plac
$LN22@store_plac:

; 219  :             case '!':
; 220  :                 /* v2.11: skip next char only if it is a "special" one; see expans40.asm */
; 221  :                 //if ( quote == NULLC && *(p+1) != NULLC )
; 222  :                 if ( quote == NULLC && strchr( "<>\"'", *(p+1) ) )

	movsx	eax, BYTE PTR quote$[rsp]
	test	eax, eax
	jne	SHORT $LN23@store_plac
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG10915
	call	QWORD PTR __imp_strchr
	test	rax, rax
	je	SHORT $LN23@store_plac

; 223  :                     p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN23@store_plac:

; 224  :                 break;

	jmp	SHORT $LN9@store_plac
$LN24@store_plac:

; 225  :             case '<':
; 226  :                 brlevel++;

	mov	eax, DWORD PTR brlevel$[rsp]
	inc	eax
	mov	DWORD PTR brlevel$[rsp], eax

; 227  :                 break;

	jmp	SHORT $LN9@store_plac
$LN25@store_plac:

; 228  :             case '>':
; 229  :                 if (brlevel) {

	cmp	DWORD PTR brlevel$[rsp], 0
	je	SHORT $LN26@store_plac

; 230  :                     if (qlevel == brlevel)

	mov	eax, DWORD PTR brlevel$[rsp]
	cmp	DWORD PTR qlevel$[rsp], eax
	jne	SHORT $LN27@store_plac

; 231  :                         quote = NULLC;

	mov	BYTE PTR quote$[rsp], 0
$LN27@store_plac:

; 232  :                     brlevel--;

	mov	eax, DWORD PTR brlevel$[rsp]
	dec	eax
	mov	DWORD PTR brlevel$[rsp], eax
$LN26@store_plac:

; 233  :                 }
; 234  :                 break;

	jmp	SHORT $LN9@store_plac
$LN28@store_plac:

; 235  :             case '"':
; 236  :             case '\'':
; 237  :                 if ( quote ) {

	movsx	eax, BYTE PTR quote$[rsp]
	test	eax, eax
	je	SHORT $LN29@store_plac

; 238  :                     if ( quote == *p )

	movsx	eax, BYTE PTR quote$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	ecx, BYTE PTR [rcx]
	cmp	eax, ecx
	jne	SHORT $LN31@store_plac

; 239  :                         quote = NULLC;

	mov	BYTE PTR quote$[rsp], 0
$LN31@store_plac:

; 240  :                 } else {

	jmp	SHORT $LN30@store_plac
$LN29@store_plac:

; 241  :                     quote = *p;

	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR quote$[rsp], al

; 242  :                     qlevel = brlevel;

	mov	eax, DWORD PTR brlevel$[rsp]
	mov	DWORD PTR qlevel$[rsp], eax
$LN30@store_plac:
$LN9@store_plac:

; 243  :                 }
; 244  :             }
; 245  :             p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN15@store_plac:
$LN12@store_plac:

; 246  :         }
; 247  :     }

	jmp	$LN2@store_plac
$LN3@store_plac:

; 248  :     return( params );

	mov	eax, DWORD PTR params$[rsp]

; 249  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
store_placeholders ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
rest$ = 32
count$ = 40
end$1 = 48
dst$2 = 56
line$ = 80
start$ = 88
len$ = 96
mnames$ = 104
replace_parm PROC

; 120  : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 121  :     /* scan list of macro paras/locals if current word is found.
; 122  :      * - line: current line
; 123  :      * - start: start 'current word' in line
; 124  :      * - len: size current word
; 125  :      * - mnames: list of macro params+locals
; 126  :      * if found, the 'current word' is replaced by a placeholder.
; 127  :      * format of placeholders is <placeholder_char><index>
; 128  :      * <placeholder_char> is an escape character whose hex-code is
; 129  :      * "impossible" to occur in a source line, <index> has type uint_8,
; 130  :      * value 00 isn't used - this restricts the total of parameters
; 131  :      * and locals for a macro to 255.
; 132  :      */
; 133  :     char       *rest;
; 134  :     unsigned   count;
; 135  : 
; 136  : //  DebugMsg(("replace_parm(%s) enter, len=%u\n", start, len ));
; 137  : 
; 138  :     for( count = 1; mnames->label; count++, mnames++ ) {

	mov	DWORD PTR count$[rsp], 1
	jmp	SHORT $LN4@replace_pa
$LN2@replace_pa:
	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax
	mov	rax, QWORD PTR mnames$[rsp]
	add	rax, 16
	mov	QWORD PTR mnames$[rsp], rax
$LN4@replace_pa:
	mov	rax, QWORD PTR mnames$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN3@replace_pa

; 139  :         if( mnames->len == len && SymCmpFunc( start, mnames->label, len ) == 0 ) {

	mov	rax, QWORD PTR mnames$[rsp]
	movzx	eax, WORD PTR [rax+8]
	cmp	eax, DWORD PTR len$[rsp]
	jne	$LN7@replace_pa
	movsxd	rax, DWORD PTR len$[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR mnames$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR start$[rsp]
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	jne	$LN7@replace_pa

; 140  : 
; 141  :             /* found a macro parameter/local! */
; 142  : 
; 143  :             if ( count >= MAX_PLACEHOLDERS ) {

	cmp	DWORD PTR count$[rsp], 256		; 00000100H
	jb	SHORT $LN8@replace_pa

; 144  :                 EmitError( TOO_MANY_MACRO_PLACEHOLDERS );

	mov	ecx, 219				; 000000dbH
	call	EmitError

; 145  :                 break;

	jmp	$LN3@replace_pa
$LN8@replace_pa:

; 146  :             }
; 147  : 
; 148  :             /* handle substitution operator '&' */
; 149  :             rest = start + len;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR start$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR rest$[rsp], rax

; 150  :             if ( start != line && *(start-1) == '&' )

	mov	rax, QWORD PTR line$[rsp]
	cmp	QWORD PTR start$[rsp], rax
	je	SHORT $LN9@replace_pa
	mov	rax, QWORD PTR start$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN9@replace_pa

; 151  :                 start--;

	mov	rax, QWORD PTR start$[rsp]
	dec	rax
	mov	QWORD PTR start$[rsp], rax
$LN9@replace_pa:

; 152  :             if (*rest == '&')

	mov	rax, QWORD PTR rest$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN10@replace_pa

; 153  :                 rest++;

	mov	rax, QWORD PTR rest$[rsp]
	inc	rax
	mov	QWORD PTR rest$[rsp], rax
$LN10@replace_pa:

; 154  : 
; 155  :             *start++ = PLACEHOLDER_CHAR;

	mov	rax, QWORD PTR start$[rsp]
	mov	BYTE PTR [rax], 10
	mov	rax, QWORD PTR start$[rsp]
	inc	rax
	mov	QWORD PTR start$[rsp], rax

; 156  : 
; 157  :             /* additional space needed for the placeholder? */
; 158  :             if ( start >= rest ) {

	mov	rax, QWORD PTR rest$[rsp]
	cmp	QWORD PTR start$[rsp], rax
	jb	SHORT $LN11@replace_pa

; 159  :                 char *end = rest + strlen(rest);

	mov	rcx, QWORD PTR rest$[rsp]
	call	strlen
	mov	rcx, QWORD PTR rest$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR end$1[rsp], rax

; 160  :                 char *dst = end + 1;

	mov	rax, QWORD PTR end$1[rsp]
	inc	rax
	mov	QWORD PTR dst$2[rsp], rax
$LN5@replace_pa:

; 161  :                 while ( end >= rest )

	mov	rax, QWORD PTR rest$[rsp]
	cmp	QWORD PTR end$1[rsp], rax
	jb	SHORT $LN6@replace_pa

; 162  :                     *dst-- = *end--;

	mov	rax, QWORD PTR dst$2[rsp]
	mov	rcx, QWORD PTR end$1[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$2[rsp]
	dec	rax
	mov	QWORD PTR dst$2[rsp], rax
	mov	rax, QWORD PTR end$1[rsp]
	dec	rax
	mov	QWORD PTR end$1[rsp], rax
	jmp	SHORT $LN5@replace_pa
$LN6@replace_pa:

; 163  :                 *start = count;

	mov	rax, QWORD PTR start$[rsp]
	movzx	ecx, BYTE PTR count$[rsp]
	mov	BYTE PTR [rax], cl

; 164  :             } else {

	jmp	SHORT $LN12@replace_pa
$LN11@replace_pa:

; 165  :                 *start++ = count;

	mov	rax, QWORD PTR start$[rsp]
	movzx	ecx, BYTE PTR count$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR start$[rsp]
	inc	rax
	mov	QWORD PTR start$[rsp], rax

; 166  :                 /* v2.10: strcpy should not be used if strings overlap */
; 167  :                 //strcpy( start, rest );
; 168  :                 memmove( start, rest, strlen( rest) + 1 );

	mov	rcx, QWORD PTR rest$[rsp]
	call	strlen
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR rest$[rsp]
	mov	rcx, QWORD PTR start$[rsp]
	call	QWORD PTR __imp_memmove
$LN12@replace_pa:

; 169  :             }
; 170  :             return( start ); /* word has been replaced */

	mov	rax, QWORD PTR start$[rsp]
	jmp	SHORT $LN1@replace_pa
$LN7@replace_pa:

; 171  :         }
; 172  :     }

	jmp	$LN2@replace_pa
$LN3@replace_pa:

; 173  :     return( NULL );

	xor	eax, eax
$LN1@replace_pa:

; 174  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
replace_parm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
tv74 = 0
x$ = 32
HexDigit PROC

; 68   : {

	mov	BYTE PTR [rsp+8], cl
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+32]

; 69   :     x &= 0xF;

	movsx	eax, BYTE PTR x$[rsp]
	and	eax, 15
	mov	BYTE PTR x$[rsp], al

; 70   :     return((x > 9) ? (x - 10 + 'A') : (x + '0'));

	movsx	eax, BYTE PTR x$[rsp]
	cmp	eax, 9
	jle	SHORT $LN3@HexDigit
	movsx	eax, BYTE PTR x$[rsp]
	add	eax, 55					; 00000037H
	mov	DWORD PTR tv74[rsp], eax
	jmp	SHORT $LN4@HexDigit
$LN3@HexDigit:
	movsx	eax, BYTE PTR x$[rsp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR tv74[rsp], eax
$LN4@HexDigit:
	movzx	eax, BYTE PTR tv74[rsp]

; 71   : }

	add	rsp, 16
	pop	rdi
	ret	0
HexDigit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
MacroFini PROC

; 830  : {

$LN3:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 831  :     StringFini();

	call	StringFini

; 832  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
MacroFini ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
macro$ = 32
pass$ = 64
MacroInit PROC

; 802  : {

$LN4:
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+64]

; 803  :     struct dsym *macro;
; 804  : 
; 805  :     DebugMsg(( "MacroInit(%u)\n", pass ));

	mov	edx, DWORD PTR pass$[rsp]
	lea	rcx, OFFSET FLAT:$SG11177
	call	DoDebugMsg

; 806  : 
; 807  :     MacroLevel = 0;

	mov	BYTE PTR MacroLevel, 0

; 808  :     MacroLocals = 0;

	mov	DWORD PTR MacroLocals, 0

; 809  :     if (pass == PASS_1) {

	cmp	DWORD PTR pass$[rsp], 0
	jne	$LN2@MacroInit

; 810  : 
; 811  :         StringInit();

	call	StringInit

; 812  : 
; 813  :         /* add @Environ() macro func */
; 814  : 
; 815  :         macro = CreateMacro( "@Environ" );

	lea	rcx, OFFSET FLAT:$SG11179
	call	CreateMacro
	mov	QWORD PTR macro$[rsp], rax

; 816  :         macro->sym.isdefined = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+40], al

; 817  :         macro->sym.predefined = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+40], al

; 818  :         macro->sym.func_ptr = EnvironFunc;

	mov	rax, QWORD PTR macro$[rsp]
	lea	rcx, OFFSET FLAT:EnvironFunc
	mov	QWORD PTR [rax+16], rcx

; 819  :         macro->sym.isfunc = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	or	al, 2
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+44], al

; 820  :         macro->e.macroinfo->parmcnt = 1;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	ecx, 1
	mov	WORD PTR [rax], cx

; 821  :         macro->e.macroinfo->parmlist = LclAlloc(sizeof(struct mparm_list));

	mov	ecx, 16
	call	LclAlloc
	mov	rcx, QWORD PTR macro$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rcx+8], rax

; 822  :         macro->e.macroinfo->parmlist->deflt = NULL;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0

; 823  :         macro->e.macroinfo->parmlist->required = TRUE;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+8]
	or	al, 1
	mov	rcx, QWORD PTR macro$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	rcx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rcx+8], al
$LN2@MacroInit:

; 824  :     }
; 825  :     return( NOT_ERROR );

	xor	eax, eax

; 826  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
MacroInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
info$ = 0
src$ = 8
token$ = 16
mindex$ = 24
paranode$ = 32
nextline$ = 40
lineno$ = 48
nesting_depth$ = 52
locals_done$ = 56
ls$ = 72
tok$ = 144
mnames$ = 240
buffer$ = 4368
j$8 = 4980
ptr$9 = 4984
size$10 = 4992
oldc$11 = 4996
j$12 = 5000
phs$13 = 5004
__$AllocaPad$$ = 5032
tv750 = 5048
tv537 = 5056
__$ArrayPad$ = 5064
macro$ = 5104
i$ = 5112
tokenarray$ = 5120
store_data$ = 5128
StoreMacro PROC

; 287  : {

$LN106:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	mov	eax, 5128				; 00001408H
	call	__chkstk
	sub	rsp, rax
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 1282				; 00000502H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+5160]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	mov	QWORD PTR __$AllocaPad$$[rbp], 0

; 288  :     struct macro_info   *info;
; 289  :     char                *src;
; 290  :     char                *token;
; 291  :     int                 mindex;
; 292  :     struct mparm_list   *paranode;
; 293  :     struct srcline      **nextline;
; 294  : #ifdef DEBUG_OUT
; 295  :     int lineno = 0;

	mov	DWORD PTR lineno$[rbp], 0

; 296  : #endif
; 297  :     unsigned            nesting_depth = 0;

	mov	DWORD PTR nesting_depth$[rbp], 0

; 298  :     bool                locals_done;
; 299  :     struct line_status  ls;
; 300  :     struct asm_tok      tok[2];
; 301  :     struct mname_list   mnames[MAX_PLACEHOLDERS]; /* there are max 255 placeholders */
; 302  :     char                buffer[MAX_LINE_LEN];
; 303  : 
; 304  :     DebugMsg1(("StoreMacro(%s, i=%u, store_data=%u) enter, params=>%s<\n", macro->sym.name, i, store_data, tokenarray[i].tokpos ));

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	movzx	ecx, BYTE PTR store_data$[rbp]
	mov	rdx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rdx+rax+24]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, ecx
	mov	r8d, DWORD PTR i$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11006
	call	DoDebugMsg1

; 305  :     info = macro->e.macroinfo;

	mov	rax, QWORD PTR macro$[rbp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR info$[rbp], rax

; 306  : 
; 307  :     if( store_data ) {

	movzx	eax, BYTE PTR store_data$[rbp]
	test	eax, eax
	je	$LN31@StoreMacro

; 308  :         int j;
; 309  : 
; 310  :         if ( i < Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rbp], eax
	jge	$LN32@StoreMacro

; 311  :             for ( j = i, info->parmcnt = 1; j < Token_Count; j++ )

	mov	eax, DWORD PTR i$[rbp]
	mov	DWORD PTR j$8[rbp], eax
	mov	eax, 1
	mov	rcx, QWORD PTR info$[rbp]
	mov	WORD PTR [rcx], ax
	jmp	SHORT $LN4@StoreMacro
$LN2@StoreMacro:
	mov	eax, DWORD PTR j$8[rbp]
	inc	eax
	mov	DWORD PTR j$8[rbp], eax
$LN4@StoreMacro:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR j$8[rbp], eax
	jge	SHORT $LN3@StoreMacro

; 312  :                 if ( tokenarray[j].token == T_COMMA )

	movsxd	rax, DWORD PTR j$8[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN34@StoreMacro

; 313  :                     info->parmcnt++;

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax]
	inc	ax
	mov	rcx, QWORD PTR info$[rbp]
	mov	WORD PTR [rcx], ax
$LN34@StoreMacro:
	jmp	SHORT $LN2@StoreMacro
$LN3@StoreMacro:

; 314  :             info->parmlist = LclAlloc( info->parmcnt * sizeof(struct mparm_list));

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax]
	imul	rax, rax, 16
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR info$[rbp]
	mov	QWORD PTR [rcx+8], rax

; 315  :         } else {

	jmp	SHORT $LN33@StoreMacro
$LN32@StoreMacro:

; 316  :             info->parmcnt = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR info$[rbp]
	mov	WORD PTR [rcx], ax

; 317  :             info->parmlist = NULL;

	mov	rax, QWORD PTR info$[rbp]
	mov	QWORD PTR [rax+8], 0
$LN33@StoreMacro:

; 318  :         }
; 319  : 
; 320  :         for( paranode = info->parmlist, mindex = 0; i < Token_Count ; paranode++ ) {

	mov	rax, QWORD PTR info$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR paranode$[rbp], rax
	mov	DWORD PTR mindex$[rbp], 0
	jmp	SHORT $LN7@StoreMacro
$LN5@StoreMacro:
	mov	rax, QWORD PTR paranode$[rbp]
	add	rax, 16
	mov	QWORD PTR paranode$[rbp], rax
$LN7@StoreMacro:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rbp], eax
	jge	$LN6@StoreMacro

; 321  : 
; 322  :             token = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR token$[rbp], rax

; 323  :             /* Masm accepts reserved words and instructions as parameter
; 324  :              * names! So just check that the token is a valid id.
; 325  :              */
; 326  :             if ( !is_valid_id_first_char( *token ) || tokenarray[i].token == T_STRING ) {

	mov	rax, QWORD PTR token$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalpha
	test	eax, eax
	jne	SHORT $LN38@StoreMacro
	mov	rax, QWORD PTR token$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN38@StoreMacro
	mov	rax, QWORD PTR token$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN38@StoreMacro
	mov	rax, QWORD PTR token$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN38@StoreMacro
	mov	rax, QWORD PTR token$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN38@StoreMacro
	mov	rax, QWORD PTR token$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN37@StoreMacro
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 4
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN37@StoreMacro
$LN38@StoreMacro:
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN35@StoreMacro
$LN37@StoreMacro:

; 327  :                 EmitErr( SYNTAX_ERROR_EX, token );

	mov	rdx, QWORD PTR token$[rbp]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 328  :                 break;

	jmp	$LN6@StoreMacro
	jmp	SHORT $LN36@StoreMacro
$LN35@StoreMacro:

; 329  :             } else if ( tokenarray[i].token != T_ID )

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN39@StoreMacro

; 330  :                 EmitWarn( 4, PARAM_IS_RESERVED_WORD, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	r8, QWORD PTR [rcx+rax+8]
	mov	edx, 269				; 0000010dH
	mov	ecx, 4
	call	EmitWarn
$LN39@StoreMacro:
$LN36@StoreMacro:

; 331  : 
; 332  :             paranode->deflt = NULL;

	mov	rax, QWORD PTR paranode$[rbp]
	mov	QWORD PTR [rax], 0

; 333  :             paranode->required = FALSE;

	mov	rax, QWORD PTR paranode$[rbp]
	movzx	eax, BYTE PTR [rax+8]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR paranode$[rbp]
	mov	BYTE PTR [rcx+8], al

; 334  : 
; 335  :             /* first get the parm. name */
; 336  :             j = strlen( token );

	mov	rcx, QWORD PTR token$[rbp]
	call	strlen
	mov	DWORD PTR j$8[rbp], eax

; 337  :             mnames[mindex].label = token;

	movsxd	rax, DWORD PTR mindex$[rbp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR token$[rbp]
	mov	QWORD PTR mnames$[rbp+rax], rcx

; 338  :             mnames[mindex].len = j;

	movsxd	rax, DWORD PTR mindex$[rbp]
	imul	rax, rax, 16
	movzx	ecx, WORD PTR j$8[rbp]
	mov	WORD PTR mnames$[rbp+rax+8], cx

; 339  :             mindex++;

	mov	eax, DWORD PTR mindex$[rbp]
	inc	eax
	mov	DWORD PTR mindex$[rbp], eax

; 340  :             mnames[mindex].label = NULL; /* init next entry */

	movsxd	rax, DWORD PTR mindex$[rbp]
	imul	rax, rax, 16
	mov	QWORD PTR mnames$[rbp+rax], 0

; 341  :             i++;

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax

; 342  : 
; 343  :             /* now see if it has a default value or is required */
; 344  :             if( tokenarray[i].token == T_COLON ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	$LN40@StoreMacro

; 345  :                 i++;

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax

; 346  :                 if( tokenarray[i].token == T_DIRECTIVE && tokenarray[i].dirtype == DRT_EQUALSGN ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	$LN41@StoreMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 48					; 00000030H
	jne	$LN41@StoreMacro

; 347  :                     i++;

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax

; 348  :                     /* allowed syntax is parm:=<literal> */
; 349  :                     if( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN44@StoreMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN43@StoreMacro
$LN44@StoreMacro:

; 350  :                         EmitError( LITERAL_EXPECTED_AFTER_EQ );

	mov	ecx, 185				; 000000b9H
	call	EmitError

; 351  :                         break; // return( ERROR );

	jmp	$LN6@StoreMacro
$LN43@StoreMacro:

; 352  :                     }
; 353  :                     paranode->deflt = LclAlloc( tokenarray[i].stringlen + 1 );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	eax, DWORD PTR [rcx+rax+16]
	inc	eax
	mov	eax, eax
	mov	ecx, eax
	call	LclAlloc
	mov	rcx, QWORD PTR paranode$[rbp]
	mov	QWORD PTR [rcx], rax

; 354  :                     memcpy( paranode->deflt, tokenarray[i].string_ptr, tokenarray[i].stringlen + 1 );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	eax, DWORD PTR [rcx+rax+16]
	inc	eax
	mov	eax, eax
	movsxd	rcx, DWORD PTR i$[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	r8d, eax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rax+rcx+8]
	mov	rax, QWORD PTR paranode$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	memcpy

; 355  :                     i++;

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
	jmp	$LN42@StoreMacro
$LN41@StoreMacro:

; 356  :                 } else if( _stricmp( tokenarray[i].string_ptr, "REQ" ) == 0 ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG11023
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN45@StoreMacro

; 357  :                     /* required parameter */
; 358  :                     paranode->required = TRUE;

	mov	rax, QWORD PTR paranode$[rbp]
	movzx	eax, BYTE PTR [rax+8]
	or	al, 1
	mov	rcx, QWORD PTR paranode$[rbp]
	mov	BYTE PTR [rcx+8], al

; 359  :                     i++;

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
	jmp	$LN46@StoreMacro
$LN45@StoreMacro:

; 360  :                 } else if( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_VARARG ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 7
	jne	SHORT $LN47@StoreMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	cmp	DWORD PTR [rcx+rax+16], 262		; 00000106H
	jne	SHORT $LN47@StoreMacro

; 361  :                     /* more parameters can follow */
; 362  :                     macro->sym.mac_vararg = TRUE;

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	or	al, 1
	mov	rcx, QWORD PTR macro$[rbp]
	mov	BYTE PTR [rcx+44], al

; 363  :                     if ( tokenarray[i+1].token != T_FINAL ) {

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN49@StoreMacro

; 364  :                         EmitError( VARARG_PARAMETER_MUST_BE_LAST );

	mov	ecx, 147				; 00000093H
	call	EmitError

; 365  :                         break;

	jmp	$LN6@StoreMacro
$LN49@StoreMacro:

; 366  :                     }
; 367  :                     i++;

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax

; 368  : #if MACROLABEL
; 369  :                 } else if( tokenarray[i].token == T_DIRECTIVE &&

	jmp	$LN48@StoreMacro
$LN47@StoreMacro:

; 370  :                           tokenarray[i].tokval == T_LABEL &&

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	SHORT $LN50@StoreMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	cmp	DWORD PTR [rcx+rax+16], 431		; 000001afH
	jne	SHORT $LN50@StoreMacro
	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	jne	SHORT $LN50@StoreMacro

; 371  :                           Options.strict_masm_compat == FALSE ) { /* parm:LABEL? */
; 372  :                     /* LABEL attribute for first param only! */
; 373  :                     if ( paranode != info->parmlist ) {

	mov	rax, QWORD PTR info$[rbp]
	mov	rax, QWORD PTR [rax+8]
	cmp	QWORD PTR paranode$[rbp], rax
	je	SHORT $LN52@StoreMacro

; 374  :                         EmitError( LABEL_PARAMETER_MUST_BE_FIRST );

	mov	ecx, 148				; 00000094H
	call	EmitError

; 375  :                         break;

	jmp	$LN6@StoreMacro
$LN52@StoreMacro:

; 376  :                     }
; 377  :                     macro->sym.label = TRUE;

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	or	al, 4
	mov	rcx, QWORD PTR macro$[rbp]
	mov	BYTE PTR [rcx+44], al

; 378  :                     i++;

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
	jmp	$LN51@StoreMacro
$LN50@StoreMacro:

; 379  : #endif
; 380  : #if VARARGML
; 381  :                 } else if( _stricmp( tokenarray[i].string_ptr, "VARARGML" ) == 0 ) {

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG11032
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN53@StoreMacro

; 382  :                     /* more parameters can follow, multi lines possible */
; 383  :                     macro->sym.mac_vararg = TRUE;

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	or	al, 1
	mov	rcx, QWORD PTR macro$[rbp]
	mov	BYTE PTR [rcx+44], al

; 384  :                     macro->sym.mac_multiline = TRUE;

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	or	al, 8
	mov	rcx, QWORD PTR macro$[rbp]
	mov	BYTE PTR [rcx+44], al

; 385  :                     if ( tokenarray[i+1].token != T_FINAL ) {

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN55@StoreMacro

; 386  :                         EmitError( VARARG_PARAMETER_MUST_BE_LAST );

	mov	ecx, 147				; 00000093H
	call	EmitError

; 387  :                         break;

	jmp	$LN6@StoreMacro
$LN55@StoreMacro:

; 388  :                     }
; 389  :                     i++;

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax

; 390  : #endif
; 391  :                 } else {

	jmp	SHORT $LN54@StoreMacro
$LN53@StoreMacro:

; 392  :                     EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 393  :                     break;

	jmp	$LN6@StoreMacro
$LN54@StoreMacro:
$LN51@StoreMacro:
$LN48@StoreMacro:
$LN46@StoreMacro:
$LN42@StoreMacro:
$LN40@StoreMacro:

; 394  :                 }
; 395  :             }
; 396  :             DebugMsg1(("StoreMacro(%s): param=>%s< found\n", macro->sym.name, mnames[mindex].label));

	movsxd	rax, DWORD PTR mindex$[rbp]
	imul	rax, rax, 16
	mov	r8, QWORD PTR mnames$[rbp+rax]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11034
	call	DoDebugMsg1

; 397  :             if( i < Token_Count && tokenarray[i].token != T_COMMA ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rbp], eax
	jge	SHORT $LN56@StoreMacro
	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN56@StoreMacro

; 398  :                 EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 399  :                 break; // return( ERROR );

	jmp	SHORT $LN6@StoreMacro
$LN56@StoreMacro:

; 400  :             }
; 401  :             /* go past comma */
; 402  :             i++;

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax

; 403  : 
; 404  :         } /* end for() */

	jmp	$LN5@StoreMacro
$LN6@StoreMacro:

; 405  :         DebugMsg1(("StoreMacro(%s): macro parameters done\n", macro->sym.name));

	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11036
	call	DoDebugMsg1
$LN31@StoreMacro:

; 406  :     }
; 407  : 
; 408  :     locals_done = FALSE;

	mov	BYTE PTR locals_done$[rbp], 0

; 409  :     nextline = &info->data;

	mov	rax, QWORD PTR info$[rbp]
	add	rax, 16
	mov	QWORD PTR nextline$[rbp], rax
$LN8@StoreMacro:

; 410  : 
; 411  :     /* now read in the lines of the macro, and store them if store_data is TRUE */
; 412  :     for( ; ; ) {
; 413  :         char *ptr;
; 414  : 
; 415  :         src = GetTextLine( buffer );

	lea	rcx, QWORD PTR buffer$[rbp]
	call	GetTextLine
	mov	QWORD PTR src$[rbp], rax

; 416  :         if( src == NULL ) {

	cmp	QWORD PTR src$[rbp], 0
	jne	SHORT $LN57@StoreMacro

; 417  :             /* v2.11: fatal error if source ends without an ENDM found */
; 418  :             //EmitError( UNMATCHED_MACRO_NESTING );
; 419  :             //ModuleInfo.EndDirFound = TRUE; /* avoid error "END not found" */
; 420  :             //return( ERROR );
; 421  :             Fatal( UNMATCHED_MACRO_NESTING );

	mov	ecx, 162				; 000000a2H
	call	Fatal
$LN57@StoreMacro:

; 422  :         }
; 423  : 
; 424  :         /* add the macro line to the listing file */
; 425  :         /* v2.09: don't make listing depend on store_data */
; 426  :         //if ( ModuleInfo.list && store_data ) {
; 427  :         if ( ModuleInfo.list ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN58@StoreMacro

; 428  :             ModuleInfo.line_flags &= ~LOF_LISTED;

	movzx	eax, BYTE PTR ModuleInfo+398
	and	eax, -2
	mov	BYTE PTR ModuleInfo+398, al

; 429  :             LstWrite( LSTTYPE_MACROLINE, 0, buffer );

	lea	r8, QWORD PTR buffer$[rbp]
	xor	edx, edx
	mov	ecx, 8
	call	LstWrite
$LN58@StoreMacro:

; 430  :         }
; 431  :         ls.input = src;

	mov	rax, QWORD PTR src$[rbp]
	mov	QWORD PTR ls$[rbp], rax

; 432  :         ls.start = src;

	mov	rax, QWORD PTR src$[rbp]
	mov	QWORD PTR ls$[rbp+16], rax

; 433  :         ls.index = 0;

	mov	DWORD PTR ls$[rbp+24], 0
$continue_scan$107:
$LN11@StoreMacro:

; 434  :     continue_scan:
; 435  :         while ( isspace(*ls.input) ) ls.input++;

	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN12@StoreMacro
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	jmp	SHORT $LN11@StoreMacro
$LN12@StoreMacro:

; 436  : 
; 437  :         /* skip empty lines! */
; 438  :         if ( *ls.input == NULLC || *ls.input == ';' ) {

	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN60@StoreMacro
	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN59@StoreMacro
$LN60@StoreMacro:

; 439  : #if STORE_EMPTY_LINES
; 440  :             if( store_data ) {

	movzx	eax, BYTE PTR store_data$[rbp]
	test	eax, eax
	je	SHORT $LN61@StoreMacro

; 441  :                 *nextline = LclAlloc( sizeof( struct srcline ) );

	mov	ecx, 16
	call	LclAlloc
	mov	rcx, QWORD PTR nextline$[rbp]
	mov	QWORD PTR [rcx], rax

; 442  :                 (*nextline)->next = NULL;

	mov	rax, QWORD PTR nextline$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rax], 0

; 443  :                 (*nextline)->ph_count = 0;

	mov	rax, QWORD PTR nextline$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	BYTE PTR [rax+8], 0

; 444  :                 (*nextline)->line[0] = NULLC;

	mov	rax, QWORD PTR nextline$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	BYTE PTR [rax+rcx+9], 0

; 445  :                 nextline = &(*nextline)->next;

	mov	rax, QWORD PTR nextline$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR nextline$[rbp], rax
$LN61@StoreMacro:

; 446  :             }
; 447  : #endif
; 448  :             continue;

	jmp	$LN8@StoreMacro
$LN59@StoreMacro:

; 449  :         }
; 450  : 
; 451  :         /* get first token */
; 452  :         ls.output = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR ls$[rbp+8], rax

; 453  :         //ls.last_token = T_FINAL;
; 454  :         ls.flags = TOK_DEFAULT;

	mov	BYTE PTR ls$[rbp+28], 0

; 455  :         ls.flags2 = 0;

	mov	BYTE PTR ls$[rbp+29], 0

; 456  :         tok[0].token = T_FINAL;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	BYTE PTR tok$[rbp+rax], 0

; 457  :         if ( GetToken( &tok[0], &ls ) == ERROR )

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	lea	rax, QWORD PTR tok$[rbp+rax]
	lea	rdx, QWORD PTR ls$[rbp]
	mov	rcx, rax
	call	GetToken
	cmp	eax, -1
	jne	SHORT $LN62@StoreMacro

; 458  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@StoreMacro
$LN62@StoreMacro:

; 459  : 
; 460  :         /* v2.05: GetTextLine() doesn't concat lines anymore.
; 461  :          * So if a backslash is found in the current source line,
; 462  :          * tokenize it to get possible concatenated lines.
; 463  :          */
; 464  :         if ( strchr( ls.input, '\\' ) ) {

	mov	edx, 92					; 0000005cH
	mov	rcx, QWORD PTR ls$[rbp]
	call	QWORD PTR __imp_strchr
	test	rax, rax
	je	$LN63@StoreMacro

; 465  :             ptr = ls.input;

	mov	rax, QWORD PTR ls$[rbp]
	mov	QWORD PTR ptr$9[rbp], rax
$LN13@StoreMacro:

; 466  :             while ( *ls.input && *ls.input != ';' ) {

	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN14@StoreMacro
	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 59					; 0000003bH
	je	$LN14@StoreMacro

; 467  :                 ls.flags3 = 0;

	mov	BYTE PTR ls$[rbp+30], 0

; 468  :                 GetToken( &tok[1], &ls );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	lea	rax, QWORD PTR tok$[rbp+rax]
	lea	rdx, QWORD PTR ls$[rbp]
	mov	rcx, rax
	call	GetToken

; 469  :                 /* v2.09: don't query store_data */
; 470  :                 //if ( ( ls.flags3 & TF3_ISCONCAT ) && ModuleInfo.list && store_data ) {
; 471  :                 if ( ( ls.flags3 & TF3_ISCONCAT ) && ModuleInfo.list ) {

	movsx	eax, BYTE PTR ls$[rbp+30]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN64@StoreMacro
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	test	eax, eax
	je	SHORT $LN64@StoreMacro

; 472  :                     ModuleInfo.line_flags &= ~LOF_LISTED;

	movzx	eax, BYTE PTR ModuleInfo+398
	and	eax, -2
	mov	BYTE PTR ModuleInfo+398, al

; 473  :                     LstWrite( LSTTYPE_MACROLINE, 0, ls.input );

	mov	r8, QWORD PTR ls$[rbp]
	xor	edx, edx
	mov	ecx, 8
	call	LstWrite
$LN64@StoreMacro:
$LN15@StoreMacro:

; 474  :                 }
; 475  :                 while( isspace( *ls.input ) ) ls.input++;

	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN16@StoreMacro
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	jmp	SHORT $LN15@StoreMacro
$LN16@StoreMacro:

; 476  :             }

	jmp	$LN13@StoreMacro
$LN14@StoreMacro:

; 477  :             ls.input = ptr;

	mov	rax, QWORD PTR ptr$9[rbp]
	mov	QWORD PTR ls$[rbp], rax
$LN63@StoreMacro:

; 478  :         }
; 479  :         if ( tok[0].token == T_FINAL ) {/* did GetToken() return EMPTY? */

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	movzx	eax, BYTE PTR tok$[rbp+rax]
	test	eax, eax
	jne	SHORT $LN65@StoreMacro

; 480  :             DebugMsg1(("StoreMacro(%s): no token\n", macro->sym.name));

	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11046
	call	DoDebugMsg1

; 481  :             goto continue_scan;

	jmp	$continue_scan$107
$LN65@StoreMacro:

; 482  :         }
; 483  :         /* handle LOCAL directive(s) */
; 484  :         if( locals_done == FALSE && tok[0].token == T_DIRECTIVE && tok[0].tokval == T_LOCAL ) {

	movzx	eax, BYTE PTR locals_done$[rbp]
	test	eax, eax
	jne	$LN66@StoreMacro
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	movzx	eax, BYTE PTR tok$[rbp+rax]
	cmp	eax, 3
	jne	$LN66@StoreMacro
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	cmp	DWORD PTR tok$[rbp+rax+16], 430		; 000001aeH
	jne	$LN66@StoreMacro

; 485  :             if( !store_data )

	movzx	eax, BYTE PTR store_data$[rbp]
	test	eax, eax
	jne	SHORT $LN67@StoreMacro

; 486  :                 continue;

	jmp	$LN8@StoreMacro
$LN67@StoreMacro:
$LN17@StoreMacro:
$LN20@StoreMacro:

; 487  :             for ( ;; ) {
; 488  :                 int size;
; 489  :                 while( isspace( *ls.input ) ) ls.input++;

	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN21@StoreMacro
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	jmp	SHORT $LN20@StoreMacro
$LN21@StoreMacro:

; 490  :                 if ( *ls.input == NULLC || *ls.input == ';' ) /* 0 locals are ok */

	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN69@StoreMacro
	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN68@StoreMacro
$LN69@StoreMacro:

; 491  :                     break;

	jmp	$LN18@StoreMacro
$LN68@StoreMacro:

; 492  :                 ls.output = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR ls$[rbp+8], rax

; 493  :                 GetToken( &tok[0], &ls );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	lea	rax, QWORD PTR tok$[rbp+rax]
	lea	rdx, QWORD PTR ls$[rbp]
	mov	rcx, rax
	call	GetToken

; 494  :                 if ( !is_valid_id_first_char( *StringBufferEnd ) ) {

	mov	rax, QWORD PTR ModuleInfo+488
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalpha
	test	eax, eax
	jne	SHORT $LN70@StoreMacro
	mov	rax, QWORD PTR ModuleInfo+488
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN70@StoreMacro
	mov	rax, QWORD PTR ModuleInfo+488
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN70@StoreMacro
	mov	rax, QWORD PTR ModuleInfo+488
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN70@StoreMacro
	mov	rax, QWORD PTR ModuleInfo+488
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN70@StoreMacro
	mov	rax, QWORD PTR ModuleInfo+488
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN72@StoreMacro
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 4
	and	eax, 1
	cmp	eax, 1
	je	SHORT $LN70@StoreMacro
$LN72@StoreMacro:

; 495  :                     EmitErr( SYNTAX_ERROR_EX, StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 496  :                     break;

	jmp	$LN18@StoreMacro
	jmp	SHORT $LN71@StoreMacro
$LN70@StoreMacro:

; 497  :                 } else if ( tok[0].token != T_ID )

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	movzx	eax, BYTE PTR tok$[rbp+rax]
	cmp	eax, 8
	je	SHORT $LN73@StoreMacro

; 498  :                     EmitWarn( 4, PARAM_IS_RESERVED_WORD, StringBufferEnd );

	mov	r8, QWORD PTR ModuleInfo+488
	mov	edx, 269				; 0000010dH
	mov	ecx, 4
	call	EmitWarn
$LN73@StoreMacro:
$LN71@StoreMacro:

; 499  : 
; 500  :                 if ( mindex == ( MAX_PLACEHOLDERS - 1 ) ) {

	cmp	DWORD PTR mindex$[rbp], 255		; 000000ffH
	jne	SHORT $LN74@StoreMacro

; 501  :                     EmitError( TOO_MANY_MACRO_PLACEHOLDERS );

	mov	ecx, 219				; 000000dbH
	call	EmitError

; 502  :                     break;

	jmp	$LN18@StoreMacro
$LN74@StoreMacro:

; 503  :                 }
; 504  :                 size = strlen( StringBufferEnd );

	mov	rcx, QWORD PTR ModuleInfo+488
	call	strlen
	mov	DWORD PTR size$10[rbp], eax

; 505  :                 mnames[mindex].label = myalloca( size );

	movsxd	rax, DWORD PTR size$10[rbp]
	add	rax, 36					; 00000024H
	mov	QWORD PTR tv750[rbp], rax
	mov	rax, QWORD PTR tv750[rbp]
	add	rax, 15
	cmp	rax, QWORD PTR tv750[rbp]
	ja	SHORT $LN105@StoreMacro
	mov	rax, 1152921504606846960		; 0ffffffffffffff0H
$LN105@StoreMacro:
	and	rax, -16
	call	__chkstk
	sub	rsp, rax
	lea	rax, QWORD PTR [rsp+48]
	mov	QWORD PTR tv537[rbp], rax
	lea	r8, QWORD PTR __$AllocaPad$$[rbp]
	mov	rdx, QWORD PTR tv750[rbp]
	mov	rcx, QWORD PTR tv537[rbp]
	call	_RTC_AllocaHelper
	add	QWORD PTR tv537[rbp], 32		; 00000020H
	movsxd	rax, DWORD PTR mindex$[rbp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR tv537[rbp]
	mov	QWORD PTR mnames$[rbp+rax], rcx

; 506  :                 memcpy( mnames[mindex].label, StringBufferEnd, size );

	movsxd	rax, DWORD PTR size$10[rbp]
	movsxd	rcx, DWORD PTR mindex$[rbp]
	imul	rcx, rcx, 16
	mov	r8, rax
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR mnames$[rbp+rcx]
	call	memcpy

; 507  :                 mnames[mindex].len = size;

	movsxd	rax, DWORD PTR mindex$[rbp]
	imul	rax, rax, 16
	movzx	ecx, WORD PTR size$10[rbp]
	mov	WORD PTR mnames$[rbp+rax+8], cx

; 508  :                 mindex++;

	mov	eax, DWORD PTR mindex$[rbp]
	inc	eax
	mov	DWORD PTR mindex$[rbp], eax

; 509  :                 mnames[mindex].label = NULL; /* mark end of placeholder array */

	movsxd	rax, DWORD PTR mindex$[rbp]
	imul	rax, rax, 16
	mov	QWORD PTR mnames$[rbp+rax], 0

; 510  :                 info->localcnt++;

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax+2]
	inc	ax
	mov	rcx, QWORD PTR info$[rbp]
	mov	WORD PTR [rcx+2], ax

; 511  :                 DebugMsg1(("StoreMacro(%s, %u): local=>%s< added, rest=%s\n", macro->sym.name, nesting_depth, mnames[mindex].label, ls.input ));

	movsxd	rax, DWORD PTR mindex$[rbp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR ls$[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR mnames$[rbp+rax]
	mov	r8d, DWORD PTR nesting_depth$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11056
	call	DoDebugMsg1
$LN22@StoreMacro:

; 512  :                 while( isspace( *ls.input ) ) ls.input++;

	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN23@StoreMacro
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	jmp	SHORT $LN22@StoreMacro
$LN23@StoreMacro:

; 513  :                 if ( *ls.input == ',' ) {

	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN75@StoreMacro

; 514  :                     ls.input++;

	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	jmp	SHORT $LN76@StoreMacro
$LN75@StoreMacro:

; 515  :                 } else if ( is_valid_id_first_char( *ls.input ) ) {

	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalpha
	test	eax, eax
	jne	SHORT $LN78@StoreMacro
	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN78@StoreMacro
	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN78@StoreMacro
	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN78@StoreMacro
	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN78@StoreMacro
	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN77@StoreMacro
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 4
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN77@StoreMacro
$LN78@StoreMacro:

; 516  :                     EmitErr( SYNTAX_ERROR_EX, ls.input );

	mov	rdx, QWORD PTR ls$[rbp]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 517  :                     break;

	jmp	SHORT $LN18@StoreMacro
$LN77@StoreMacro:
$LN76@StoreMacro:

; 518  :                 }
; 519  :             }

	jmp	$LN17@StoreMacro
$LN18@StoreMacro:

; 520  :             continue;

	jmp	$LN8@StoreMacro
$LN66@StoreMacro:

; 521  :         }
; 522  :         locals_done = TRUE;

	mov	BYTE PTR locals_done$[rbp], 1

; 523  : 
; 524  :         /* handle macro labels, EXITM, ENDM and macro loop directives.
; 525  :          * this must be done always, even if store_data is false,
; 526  :          * to find the matching ENDM that terminates the macro.
; 527  :          */
; 528  :         if ( tok[0].token == T_COLON ) { /* macro label? */

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	movzx	eax, BYTE PTR tok$[rbp+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN79@StoreMacro

; 529  :             /* skip leading spaces for macro labels! In RunMacro(),
; 530  :              * the label search routine expects no spaces before ':'.
; 531  :              */
; 532  :             src = ls.input - 1;

	mov	rax, QWORD PTR ls$[rbp]
	dec	rax
	mov	QWORD PTR src$[rbp], rax
	jmp	$LN80@StoreMacro
$LN79@StoreMacro:

; 533  :         } else if( tok[0].token == T_DIRECTIVE ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	movzx	eax, BYTE PTR tok$[rbp+rax]
	cmp	eax, 3
	jne	$LN81@StoreMacro

; 534  :             if ( tok[0].tokval == T_EXITM ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	cmp	DWORD PTR tok$[rbp+rax+16], 393		; 00000189H
	jne	$LN83@StoreMacro

; 535  :                 DebugMsg1(("StoreMacro(%s): exitm found, lvl=%u, >%s<\n", macro->sym.name, nesting_depth, ls.input ));

	mov	r9, QWORD PTR ls$[rbp]
	mov	r8d, DWORD PTR nesting_depth$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11067
	call	DoDebugMsg1

; 536  :                 if ( nesting_depth == 0 ) {

	cmp	DWORD PTR nesting_depth$[rbp], 0
	jne	SHORT $LN85@StoreMacro

; 537  :                     ptr = ls.input;

	mov	rax, QWORD PTR ls$[rbp]
	mov	QWORD PTR ptr$9[rbp], rax
$LN24@StoreMacro:

; 538  :                     while( isspace( *ptr ) ) ptr++;

	mov	rax, QWORD PTR ptr$9[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN25@StoreMacro
	mov	rax, QWORD PTR ptr$9[rbp]
	inc	rax
	mov	QWORD PTR ptr$9[rbp], rax
	jmp	SHORT $LN24@StoreMacro
$LN25@StoreMacro:

; 539  :                     if ( *ptr && *ptr != ';' )

	mov	rax, QWORD PTR ptr$9[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN86@StoreMacro
	mov	rax, QWORD PTR ptr$9[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 59					; 0000003bH
	je	SHORT $LN86@StoreMacro

; 540  :                         macro->sym.isfunc = TRUE;

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	or	al, 2
	mov	rcx, QWORD PTR macro$[rbp]
	mov	BYTE PTR [rcx+44], al
$LN86@StoreMacro:
$LN85@StoreMacro:

; 541  :                     //macro->sym.runsync = TRUE;
; 542  :                 }

	jmp	SHORT $LN84@StoreMacro
$LN83@StoreMacro:

; 543  :             } else if( tok[0].tokval == T_ENDM ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	cmp	DWORD PTR tok$[rbp+rax+16], 394		; 0000018aH
	jne	SHORT $LN87@StoreMacro

; 544  :                 DebugMsg1(("StoreMacro(%s): endm found, lvl=%u\n", macro->sym.name, nesting_depth ));

	mov	r8d, DWORD PTR nesting_depth$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11072
	call	DoDebugMsg1

; 545  :                 if( nesting_depth ) {

	cmp	DWORD PTR nesting_depth$[rbp], 0
	je	SHORT $LN89@StoreMacro

; 546  :                     nesting_depth--;

	mov	eax, DWORD PTR nesting_depth$[rbp]
	dec	eax
	mov	DWORD PTR nesting_depth$[rbp], eax

; 547  :                 } else {

	jmp	SHORT $LN90@StoreMacro
$LN89@StoreMacro:

; 548  :                     break; /* exit the for() loop */

	jmp	$LN9@StoreMacro
$LN90@StoreMacro:

; 549  :                 }

	jmp	SHORT $LN88@StoreMacro
$LN87@StoreMacro:

; 550  :             } else if( tok[0].dirtype == DRT_LOOPDIR ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	movzx	eax, BYTE PTR tok$[rbp+rax+1]
	cmp	eax, 1
	jne	SHORT $LN91@StoreMacro

; 551  :                 nesting_depth++; /* FOR[C], IRP[C], REP[EA]T, WHILE */

	mov	eax, DWORD PTR nesting_depth$[rbp]
	inc	eax
	mov	DWORD PTR nesting_depth$[rbp], eax
$LN91@StoreMacro:
$LN88@StoreMacro:
$LN84@StoreMacro:

; 552  :             }

	jmp	$LN82@StoreMacro
$LN81@StoreMacro:

; 553  :         } else if ( tok[0].token != T_INSTRUCTION || *ls.input == '&' ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	movzx	eax, BYTE PTR tok$[rbp+rax]
	cmp	eax, 1
	jne	SHORT $LN93@StoreMacro
	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 38					; 00000026H
	jne	$LN92@StoreMacro
$LN93@StoreMacro:
$LN26@StoreMacro:

; 554  :             /* Skip any token != directive or instruction (and no '&' attached)
; 555  :              * might be text macro ids, macro function calls,
; 556  :              * code labels, ...
; 557  :              */
; 558  :             for (;;) {
; 559  :                 char oldc;
; 560  :                 tok[0].token = T_FINAL;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	BYTE PTR tok$[rbp+rax], 0
$LN29@StoreMacro:

; 561  :                 while ( isspace( *ls.input ) ) ls.input++;

	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN30@StoreMacro
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	jmp	SHORT $LN29@StoreMacro
$LN30@StoreMacro:

; 562  :                 if ( *ls.input == NULLC || *ls.input == ';' )

	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN95@StoreMacro
	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN94@StoreMacro
$LN95@StoreMacro:

; 563  :                     break;

	jmp	SHORT $LN27@StoreMacro
$LN94@StoreMacro:

; 564  :                 oldc = *(ls.input-1);

	mov	rax, QWORD PTR ls$[rbp]
	movzx	eax, BYTE PTR [rax-1]
	mov	BYTE PTR oldc$11[rbp], al

; 565  :                 if ( GetToken( &tok[0], &ls ) == ERROR )

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	lea	rax, QWORD PTR tok$[rbp+rax]
	lea	rdx, QWORD PTR ls$[rbp]
	mov	rcx, rax
	call	GetToken
	cmp	eax, -1
	jne	SHORT $LN96@StoreMacro

; 566  :                     break;

	jmp	SHORT $LN27@StoreMacro
$LN96@StoreMacro:

; 567  :                 if ( ( tok[0].token == T_INSTRUCTION || tok[0].token == T_DIRECTIVE ) &&
; 568  :                     oldc != '&' && *ls.input != '&' )

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	movzx	eax, BYTE PTR tok$[rbp+rax]
	cmp	eax, 1
	je	SHORT $LN98@StoreMacro
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	movzx	eax, BYTE PTR tok$[rbp+rax]
	cmp	eax, 3
	jne	SHORT $LN97@StoreMacro
$LN98@StoreMacro:
	movsx	eax, BYTE PTR oldc$11[rbp]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN97@StoreMacro
	mov	rax, QWORD PTR ls$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN97@StoreMacro

; 569  :                     break;

	jmp	SHORT $LN27@StoreMacro
$LN97@StoreMacro:

; 570  :             }

	jmp	$LN26@StoreMacro
$LN27@StoreMacro:

; 571  :             if ( tok[0].token == T_DIRECTIVE ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	movzx	eax, BYTE PTR tok$[rbp+rax]
	cmp	eax, 3
	jne	SHORT $LN99@StoreMacro

; 572  :                 /* MACRO or loop directive? */
; 573  :                 if ( tok[0].tokval == T_MACRO || tok[0].dirtype == DRT_LOOPDIR )

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	cmp	DWORD PTR tok$[rbp+rax+16], 392		; 00000188H
	je	SHORT $LN101@StoreMacro
	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	movzx	eax, BYTE PTR tok$[rbp+rax+1]
	cmp	eax, 1
	jne	SHORT $LN100@StoreMacro
$LN101@StoreMacro:

; 574  :                     nesting_depth++;

	mov	eax, DWORD PTR nesting_depth$[rbp]
	inc	eax
	mov	DWORD PTR nesting_depth$[rbp], eax
$LN100@StoreMacro:
$LN99@StoreMacro:
$LN92@StoreMacro:
$LN82@StoreMacro:
$LN80@StoreMacro:

; 575  :             }
; 576  :         }
; 577  : 
; 578  :         /* store the line, but first check for placeholders!
; 579  :          * this is to be improved. store_placeholders() is too
; 580  :          * primitive. It's necessary to use the tokenizer.
; 581  :          */
; 582  :         if( store_data ) {

	movzx	eax, BYTE PTR store_data$[rbp]
	test	eax, eax
	je	$LN102@StoreMacro

; 583  :             int j;
; 584  :             uint_8 phs = 0;

	mov	BYTE PTR phs$13[rbp], 0

; 585  :             if ( mindex )

	cmp	DWORD PTR mindex$[rbp], 0
	je	SHORT $LN103@StoreMacro

; 586  :                 phs = store_placeholders( src, mnames );

	lea	rdx, QWORD PTR mnames$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	call	store_placeholders
	mov	BYTE PTR phs$13[rbp], al
$LN103@StoreMacro:

; 587  :             j = strlen( src );

	mov	rcx, QWORD PTR src$[rbp]
	call	strlen
	mov	DWORD PTR j$12[rbp], eax

; 588  :             *nextline = LclAlloc( sizeof( struct srcline ) + j );

	movsxd	rax, DWORD PTR j$12[rbp]
	add	rax, 16
	mov	rcx, rax
	call	LclAlloc
	mov	rcx, QWORD PTR nextline$[rbp]
	mov	QWORD PTR [rcx], rax

; 589  :             (*nextline)->next = NULL;

	mov	rax, QWORD PTR nextline$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rax], 0

; 590  :             (*nextline)->ph_count = phs;

	mov	rax, QWORD PTR nextline$[rbp]
	mov	rax, QWORD PTR [rax]
	movzx	ecx, BYTE PTR phs$13[rbp]
	mov	BYTE PTR [rax+8], cl

; 591  :             memcpy( (*nextline)->line, src, j + 1 );

	mov	eax, DWORD PTR j$12[rbp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR nextline$[rbp]
	mov	rcx, QWORD PTR [rcx]
	add	rcx, 9
	mov	r8, rax
	mov	rdx, QWORD PTR src$[rbp]
	call	memcpy

; 592  :             nextline = &(*nextline)->next;

	mov	rax, QWORD PTR nextline$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR nextline$[rbp], rax

; 593  :             DebugMsg1(("StoreMacro(%s, %u): cnt=%u, %u. line >%s<\n", macro->sym.name, nesting_depth, phs, ++lineno, RenderMacroLine( src ) ));

	mov	eax, DWORD PTR lineno$[rbp]
	inc	eax
	mov	DWORD PTR lineno$[rbp], eax
	mov	rcx, QWORD PTR src$[rbp]
	call	RenderMacroLine
	movzx	ecx, BYTE PTR phs$13[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR lineno$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, DWORD PTR nesting_depth$[rbp]
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11088
	call	DoDebugMsg1
$LN102@StoreMacro:

; 594  :         }
; 595  :     } /* end for */

	jmp	$LN8@StoreMacro
$LN9@StoreMacro:

; 596  :     macro->sym.isdefined = TRUE;

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR macro$[rbp]
	mov	BYTE PTR [rcx+40], al

; 597  :     macro->sym.purged = FALSE;

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	and	al, 239					; 000000efH
	mov	rcx, QWORD PTR macro$[rbp]
	mov	BYTE PTR [rcx+44], al

; 598  :     DebugMsg1(("StoreMacro(%s): exit, no error, isfunc=%u\n", macro->sym.name, macro->sym.isfunc));

	mov	rax, QWORD PTR macro$[rbp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	mov	r8d, eax
	mov	rax, QWORD PTR macro$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11089
	call	DoDebugMsg1

; 599  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@StoreMacro:

; 600  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:StoreMacro$rtcFrameData
	mov	r8, QWORD PTR __$AllocaPad$$[rbp]
	call	_RTC_CheckStackVars2
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+5080]
	pop	rdi
	pop	rbp
	ret	0
StoreMacro ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
i$ = 32
p$ = 40
parmno$ = 48
dst$ = 80
src$ = 88
argc$ = 96
localstart$ = 104
argv$ = 112
fill_placeholders PROC

; 79   : {

$LN13:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 80   :     uint_32 i;
; 81   :     const char *p;
; 82   :     unsigned parmno;
; 83   : 
; 84   :     /* scan the string, replace the placeholders #nn */
; 85   :     for( p = src ;*p != NULLC; ) {

	mov	rax, QWORD PTR src$[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN2@fill_place:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@fill_place

; 86   :         if (*p == PLACEHOLDER_CHAR ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 10
	jne	$LN5@fill_place

; 87   :             p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 88   :             /* we found a placeholder, get the index part! */
; 89   :             parmno = *(unsigned char *)p - 1; /* index is one-based! */

	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rax]
	dec	eax
	mov	DWORD PTR parmno$[rsp], eax

; 90   :             p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 91   :             /* if parmno > argc, then it's a macro local */
; 92   :             if ( parmno >= argc ) {

	mov	eax, DWORD PTR argc$[rsp]
	cmp	DWORD PTR parmno$[rsp], eax
	jb	$LN7@fill_place

; 93   :                 *dst++ = '?';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 63			; 0000003fH
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 94   :                 *dst++ = '?';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 63			; 0000003fH
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 95   :                 i = localstart + parmno - argc;

	mov	eax, DWORD PTR parmno$[rsp]
	mov	ecx, DWORD PTR localstart$[rsp]
	add	ecx, eax
	mov	eax, ecx
	sub	eax, DWORD PTR argc$[rsp]
	mov	DWORD PTR i$[rsp], eax

; 96   :                 if ( i > 0xFFFF ) {

	cmp	DWORD PTR i$[rsp], 65535		; 0000ffffH
	jbe	SHORT $LN9@fill_place

; 97   :                     i = sprintf( dst, "%X", i );

	mov	r8d, DWORD PTR i$[rsp]
	lea	rdx, OFFSET FLAT:$SG10851
	mov	rcx, QWORD PTR dst$[rsp]
	call	sprintf
	mov	DWORD PTR i$[rsp], eax

; 98   :                     dst += i;

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dst$[rsp], rax

; 99   :                 } else {

	jmp	$LN10@fill_place
$LN9@fill_place:

; 100  :                     *dst++ = HexDigit( i >> 12 );

	mov	eax, DWORD PTR i$[rsp]
	shr	eax, 12
	movzx	ecx, al
	call	HexDigit
	mov	rcx, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 101  :                     *dst++ = HexDigit( i >> 8 );

	mov	eax, DWORD PTR i$[rsp]
	shr	eax, 8
	movzx	ecx, al
	call	HexDigit
	mov	rcx, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 102  :                     *dst++ = HexDigit( i >> 4 );

	mov	eax, DWORD PTR i$[rsp]
	shr	eax, 4
	movzx	ecx, al
	call	HexDigit
	mov	rcx, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 103  :                     *dst++ = HexDigit( i );

	movzx	ecx, BYTE PTR i$[rsp]
	call	HexDigit
	mov	rcx, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
$LN10@fill_place:

; 104  :                 }

	jmp	SHORT $LN8@fill_place
$LN7@fill_place:

; 105  :             } else if ( argv[parmno] ) {  /* actual parameter might be empty (=NULL) */

	mov	eax, DWORD PTR parmno$[rsp]
	mov	rcx, QWORD PTR argv$[rsp]
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN11@fill_place

; 106  :                 i = strlen( argv[parmno] );

	mov	eax, DWORD PTR parmno$[rsp]
	mov	rcx, QWORD PTR argv$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	strlen
	mov	DWORD PTR i$[rsp], eax

; 107  :                 memcpy( dst, argv[parmno], i );

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR parmno$[rsp]
	mov	r8d, eax
	mov	rax, QWORD PTR argv$[rsp]
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	rcx, QWORD PTR dst$[rsp]
	call	memcpy

; 108  :                 dst += i;

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dst$[rsp], rax
$LN11@fill_place:
$LN8@fill_place:

; 109  :             }
; 110  :         } else {

	jmp	SHORT $LN6@fill_place
$LN5@fill_place:

; 111  :             *dst++ = *p++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN6@fill_place:

; 112  :         }
; 113  :     }

	jmp	$LN2@fill_place
$LN3@fill_place:

; 114  :     *dst = NULLC;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 0

; 115  :     return;
; 116  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
fill_placeholders ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
i$ = 32
datacurr$ = 40
datanext$ = 48
macro$ = 80
ReleaseMacroData PROC

; 629  : {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 630  :     int             i;
; 631  :     struct srcline  *datacurr;
; 632  :     struct srcline  *datanext;
; 633  : 
; 634  :     DebugMsg1(("ReleaseMacroData(%s) enter\n", macro->sym.name));

	mov	rax, QWORD PTR macro$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11113
	call	DoDebugMsg1

; 635  :     /* free the parm list */
; 636  :     for( i = 0 ; i < macro->e.macroinfo->parmcnt; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@ReleaseMac
$LN2@ReleaseMac:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@ReleaseMac:
	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, WORD PTR [rax]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@ReleaseMac

; 637  :         /*
; 638  :          for predefined macros, don't free the param labels,
; 639  :          the items are stored in static memory
; 640  :          */
; 641  :         //if ( macro->sym.predefined == FALSE )
; 642  :         //    LclFree( (void *)macro->e.macroinfo->parmlist[i].label );
; 643  :         LclFree( macro->e.macroinfo->parmlist[i].deflt );
; 644  :     }

	jmp	SHORT $LN2@ReleaseMac
$LN3@ReleaseMac:

; 645  : 
; 646  :     macro->e.macroinfo->parmcnt = 0;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	xor	ecx, ecx
	mov	WORD PTR [rax], cx

; 647  :     macro->e.macroinfo->localcnt = 0;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	xor	ecx, ecx
	mov	WORD PTR [rax+2], cx

; 648  : 
; 649  :     if( macro->e.macroinfo->parmlist ) {

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN8@ReleaseMac

; 650  :         LclFree( macro->e.macroinfo->parmlist );
; 651  :         macro->e.macroinfo->parmlist = NULL;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rax+8], 0
$LN8@ReleaseMac:

; 652  :     }
; 653  : 
; 654  :     /* free the lines list */
; 655  :     for( datacurr = macro->e.macroinfo->data ;datacurr; ) {

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR datacurr$[rsp], rax
$LN5@ReleaseMac:
	cmp	QWORD PTR datacurr$[rsp], 0
	je	SHORT $LN6@ReleaseMac

; 656  :         datanext = datacurr->next;

	mov	rax, QWORD PTR datacurr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR datanext$[rsp], rax

; 657  :         LclFree( datacurr );
; 658  :         datacurr = datanext;

	mov	rax, QWORD PTR datanext$[rsp]
	mov	QWORD PTR datacurr$[rsp], rax

; 659  :     }

	jmp	SHORT $LN5@ReleaseMac
$LN6@ReleaseMac:

; 660  :     macro->e.macroinfo->data = NULL;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rax+16], 0

; 661  :     macro->e.macroinfo->srcfile = 0;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+28], 0

; 662  :     macro->sym.mac_vararg = FALSE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+44], al

; 663  :     /* v2.07: the macro type should not change if a macro is
; 664  :      * PURGEd.
; 665  :      */
; 666  :     //macro->sym.isfunc = FALSE;
; 667  :     return;
; 668  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ReleaseMacroData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_TEXT	SEGMENT
macro$ = 32
name$ = 64
CreateMacro PROC

; 606  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 607  :     struct dsym *macro;
; 608  :     if ( macro = (struct dsym *)SymCreate( name ) ) {

	mov	rcx, QWORD PTR name$[rsp]
	call	SymCreate
	mov	QWORD PTR macro$[rsp], rax
	cmp	QWORD PTR macro$[rsp], 0
	je	$LN2@CreateMacr

; 609  :         macro->sym.state = SYM_MACRO;

	mov	rax, QWORD PTR macro$[rsp]
	mov	DWORD PTR [rax+32], 9

; 610  :         macro->e.macroinfo = LclAlloc( sizeof( struct macro_info ) );

	mov	ecx, 32					; 00000020H
	call	LclAlloc
	mov	rcx, QWORD PTR macro$[rsp]
	mov	QWORD PTR [rcx+96], rax

; 611  :         macro->e.macroinfo->parmcnt  = 0;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	xor	ecx, ecx
	mov	WORD PTR [rax], cx

; 612  :         macro->e.macroinfo->localcnt = 0;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	xor	ecx, ecx
	mov	WORD PTR [rax+2], cx

; 613  :         macro->e.macroinfo->parmlist = NULL;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rax+8], 0

; 614  :         macro->e.macroinfo->data     = NULL;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rax+16], 0

; 615  : #ifdef DEBUG_OUT
; 616  :         macro->e.macroinfo->count = 0;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+24], 0

; 617  : #endif
; 618  :         macro->e.macroinfo->srcfile  = 0;

	mov	rax, QWORD PTR macro$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	DWORD PTR [rax+28], 0

; 619  :         macro->sym.mac_vararg = FALSE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	and	al, 254					; 000000feH
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+44], al

; 620  :         macro->sym.isfunc = FALSE;

	mov	rax, QWORD PTR macro$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	and	al, 253					; 000000fdH
	mov	rcx, QWORD PTR macro$[rsp]
	mov	BYTE PTR [rcx+44], al
$LN2@CreateMacr:

; 621  :     }
; 622  :     return( macro );

	mov	rax, QWORD PTR macro$[rsp]

; 623  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
CreateMacro ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Buffer$ = 96
_Format$ = 104
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1788 : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:sprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 1386 :     int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp___stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1391 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
	push	rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	rdi
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
