; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG10396 DB	'AddLineQueue(%p): #=%u >%s<', 0aH, 00H
	ORG $+3
$SG10468 DB	'RunLineQueue() enter', 0aH, 00H
	ORG $+10
$SG10471 DB	'!!!!! Warning: End directive found in generated-code par'
	DB	'ser loop!', 0aH, 00H
	ORG $+5
$SG10472 DB	'RunLineQueue() exit', 0aH, 00H
_DATA	ENDS
PUBLIC	GetLqLine
PUBLIC	DeleteLineQueue
PUBLIC	AddLineQueue
PUBLIC	AddLineQueueX
PUBLIC	RunLineQueue
EXTRN	memcpy:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	myltoa:PROC
EXTRN	MemAlloc:PROC
EXTRN	MemFree:PROC
EXTRN	GetResWName:PROC
EXTRN	PushInputStatus:PROC
EXTRN	PopInputStatus:PROC
EXTRN	ParseLine:PROC
EXTRN	PreprocessLine:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	ResWordTable:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
lqlines_written DD 01H DUP (?)
lqlines_read DD	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$GetLqLine DD imagerel $LN3
	DD	imagerel $LN3+10
	DD	imagerel $unwind$GetLqLine
$pdata$DeleteLineQueue DD imagerel $LN6
	DD	imagerel $LN6+95
	DD	imagerel $unwind$DeleteLineQueue
$pdata$AddLineQueue DD imagerel $LN5
	DD	imagerel $LN5+222
	DD	imagerel $unwind$AddLineQueue
$pdata$AddLineQueueX DD imagerel $LN19
	DD	imagerel $LN19+786
	DD	imagerel $unwind$AddLineQueueX
$pdata$RunLineQueue DD imagerel $LN8
	DD	imagerel $LN8+303
	DD	imagerel $unwind$RunLineQueue
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
AddLineQueueX$rtcName$0 DB 061H
	DB	072H
	DB	067H
	DB	073H
	DB	00H
	ORG $+3
AddLineQueueX$rtcName$1 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
AddLineQueueX$rtcVarDesc DD 080H
	DD	0258H
	DQ	FLAT:AddLineQueueX$rtcName$1
	DD	038H
	DD	08H
	DQ	FLAT:AddLineQueueX$rtcName$0
	ORG $+96
AddLineQueueX$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:AddLineQueueX$rtcVarDesc
RunLineQueue$rtcName$0 DB 06fH
	DB	06cH
	DB	064H
	DB	073H
	DB	074H
	DB	061H
	DB	074H
	DB	00H
	ORG $+8
RunLineQueue$rtcVarDesc DD 028H
	DD	020H
	DQ	FLAT:RunLineQueue$rtcName$0
	ORG $+48
RunLineQueue$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:RunLineQueue$rtcVarDesc
CONST	ENDS
xdata	SEGMENT
$unwind$GetLqLine DD 010201H
	DD	07002H
$unwind$DeleteLineQueue DD 021501H
	DD	070025206H
$unwind$AddLineQueue DD 021e01H
	DD	07006520aH
$unwind$AddLineQueueX DD 034519H
	DD	060011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	02f8H
$unwind$RunLineQueue DD 021501H
	DD	07002d206H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\lqueue.c
_TEXT	SEGMENT
oldstat$ = 40
tokenarray$ = 88
currline$ = 96
nextline$4 = 104
RunLineQueue PROC

; 168  : {

$LN8:
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 169  :     struct input_status oldstat;
; 170  :     struct asm_tok *tokenarray;
; 171  :     struct lq_line *currline = line_queue.head;

	mov	rax, QWORD PTR ModuleInfo+184
	mov	QWORD PTR currline$[rsp], rax

; 172  : 
; 173  :     DebugMsg1(( "RunLineQueue() enter\n" ));

	lea	rcx, OFFSET FLAT:$SG10468
	call	DoDebugMsg1

; 174  : 
; 175  :     /* v2.03: ensure the current source buffer is still aligned */
; 176  :     tokenarray = PushInputStatus( &oldstat );

	lea	rcx, QWORD PTR oldstat$[rsp]
	call	PushInputStatus
	mov	QWORD PTR tokenarray$[rsp], rax

; 177  :     ModuleInfo.GeneratedCode++;

	mov	eax, DWORD PTR ModuleInfo+456
	inc	eax
	mov	DWORD PTR ModuleInfo+456, eax

; 178  : 
; 179  :     /* v2.11: line queues are no longer pushed onto the file stack.
; 180  :      * Instead, the queue is processed directly here.
; 181  :      */
; 182  :     line_queue.head = NULL;

	mov	QWORD PTR ModuleInfo+184, 0

; 183  :     DebugCmd( lqlines_written = 0 ); /* reset counter for AddLineQueue() */

	mov	DWORD PTR lqlines_written, 0

; 184  :     DebugCmd( lqlines_read = 0 ); /* reset counter for line-queue reads below */

	mov	DWORD PTR lqlines_read, 0
$LN2@RunLineQue:

; 185  : 
; 186  :     for ( ; currline; ) {

	cmp	QWORD PTR currline$[rsp], 0
	je	SHORT $LN3@RunLineQue

; 187  :         struct lq_line *nextline = currline->next;

	mov	rax, QWORD PTR currline$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR nextline$4[rsp], rax

; 188  :         strcpy( CurrSource, currline->line );

	mov	rax, QWORD PTR currline$[rsp]
	add	rax, 9
	mov	rdx, rax
	mov	rcx, QWORD PTR ModuleInfo+464
	call	strcpy

; 189  :         DebugCmd ( lqlines_read++ );

	mov	eax, DWORD PTR lqlines_read
	inc	eax
	mov	DWORD PTR lqlines_read, eax

; 190  :         MemFree( currline );

	mov	rcx, QWORD PTR currline$[rsp]
	call	MemFree

; 191  :         if ( PreprocessLine( CurrSource, tokenarray ) )

	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+464
	call	PreprocessLine
	test	eax, eax
	je	SHORT $LN5@RunLineQue

; 192  :             ParseLine( tokenarray );

	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	ParseLine
$LN5@RunLineQue:

; 193  :         currline = nextline;

	mov	rax, QWORD PTR nextline$4[rsp]
	mov	QWORD PTR currline$[rsp], rax

; 194  :     }

	jmp	SHORT $LN2@RunLineQue
$LN3@RunLineQue:

; 195  : 
; 196  : #ifdef DEBUG_OUT
; 197  :     if ( ModuleInfo.EndDirFound == TRUE ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 16
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN6@RunLineQue

; 198  :         DebugMsg(("!!!!! Warning: End directive found in generated-code parser loop!\n"));

	lea	rcx, OFFSET FLAT:$SG10471
	call	DoDebugMsg
$LN6@RunLineQue:

; 199  :     }
; 200  : #endif
; 201  :     ModuleInfo.GeneratedCode--;

	mov	eax, DWORD PTR ModuleInfo+456
	dec	eax
	mov	DWORD PTR ModuleInfo+456, eax

; 202  :     PopInputStatus( &oldstat );

	lea	rcx, QWORD PTR oldstat$[rsp]
	call	PopInputStatus

; 203  : 
; 204  :     DebugMsg1(( "RunLineQueue() exit\n" ));

	lea	rcx, OFFSET FLAT:$SG10472
	call	DoDebugMsg1

; 205  :     return;
; 206  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:RunLineQueue$rtcFrameData
	call	_RTC_CheckStackVars
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
RunLineQueue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\lqueue.c
_TEXT	SEGMENT
args$ = 56
d$ = 72
i$ = 80
l$ = 84
s$ = 88
p$ = 96
buffer$ = 128
tv74 = 752
tv143 = 756
__$ArrayPad$ = 760
fmt$ = 784
AddLineQueueX PROC

; 98   : {

$LN19:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 768				; 00000300H
	mov	rdi, rsp
	mov	ecx, 192				; 000000c0H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+784]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 99   :     va_list args;
; 100  :     char *d;
; 101  :     int i;
; 102  :     int_32 l;
; 103  :     const char *s;
; 104  :     const char *p;
; 105  :     char buffer[MAX_LINE_LEN];
; 106  : 
; 107  :     //DebugMsg(("AddlineQueueX(%s) enter\n", fmt ));
; 108  :     va_start( args, fmt );

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 109  :     for ( s = fmt, d = buffer; *s; s++ ) {

	mov	rax, QWORD PTR fmt$[rsp]
	mov	QWORD PTR s$[rsp], rax
	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR d$[rsp], rax
	jmp	SHORT $LN4@AddLineQue
$LN2@AddLineQue:
	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR s$[rsp], rax
$LN4@AddLineQue:
	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@AddLineQue

; 110  :         if ( *s == '%' ) {

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	$LN7@AddLineQue

; 111  :             s++;

	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR s$[rsp], rax

; 112  :             switch ( *s ) {

	mov	rax, QWORD PTR s$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv74[rsp], al
	cmp	BYTE PTR tv74[rsp], 100			; 00000064H
	je	$LN11@AddLineQue
	cmp	BYTE PTR tv74[rsp], 114			; 00000072H
	je	SHORT $LN9@AddLineQue
	cmp	BYTE PTR tv74[rsp], 115			; 00000073H
	je	SHORT $LN10@AddLineQue
	cmp	BYTE PTR tv74[rsp], 117			; 00000075H
	je	$LN11@AddLineQue
	cmp	BYTE PTR tv74[rsp], 120			; 00000078H
	je	$LN11@AddLineQue
	jmp	$LN15@AddLineQue
$LN9@AddLineQue:

; 113  :             case 'r':
; 114  :                 i = va_arg( args, int );

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	eax, DWORD PTR [rax-8]
	mov	DWORD PTR i$[rsp], eax

; 115  :                 GetResWName( i , d );

	mov	rdx, QWORD PTR d$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	GetResWName

; 116  :                 /* v2.06: the name is already copied */
; 117  :                 //memcpy( d, ResWordTable[i].name, ResWordTable[i].len );
; 118  :                 d += ResWordTable[i].len;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:ResWordTable
	movzx	eax, BYTE PTR [rcx+rax+2]
	mov	rcx, QWORD PTR d$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR d$[rsp], rax

; 119  :                 break;

	jmp	$LN5@AddLineQue
$LN10@AddLineQue:

; 120  :             case 's':
; 121  :                 p = va_arg( args, char * );

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR p$[rsp], rax

; 122  :                 i = strlen( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax

; 123  :                 memcpy( d, p, i );

	movsxd	rax, DWORD PTR i$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	call	memcpy

; 124  :                 d += i;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR d$[rsp], rax

; 125  :                 *d = NULLC;

	mov	rax, QWORD PTR d$[rsp]
	mov	BYTE PTR [rax], 0

; 126  :                 break;

	jmp	$LN5@AddLineQue
$LN11@AddLineQue:

; 127  :             case 'd':
; 128  :             case 'u':
; 129  :             case 'x':
; 130  : #ifdef __I86__ /* v2.08: use long only if size(int) is 16-bit */
; 131  :                 l = va_arg( args, long );
; 132  : #else
; 133  :                 l = va_arg( args, int );

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	eax, DWORD PTR [rax-8]
	mov	DWORD PTR l$[rsp], eax

; 134  : #endif
; 135  :                 if ( *s == 'x' ) {

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 120				; 00000078H
	jne	SHORT $LN12@AddLineQue

; 136  :                     myltoa( l, d, 16, FALSE, FALSE );

	mov	BYTE PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8d, 16
	mov	rdx, QWORD PTR d$[rsp]
	mov	ecx, DWORD PTR l$[rsp]
	call	myltoa

; 137  :                     d += strlen( d );

	mov	rcx, QWORD PTR d$[rsp]
	call	strlen
	mov	rcx, QWORD PTR d$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR d$[rsp], rax

; 138  :                 } else {

	jmp	SHORT $LN13@AddLineQue
$LN12@AddLineQue:

; 139  :                     myltoa( l, d, 10, l < 0, FALSE );

	cmp	DWORD PTR l$[rsp], 0
	jge	SHORT $LN17@AddLineQue
	mov	DWORD PTR tv143[rsp], 1
	jmp	SHORT $LN18@AddLineQue
$LN17@AddLineQue:
	mov	DWORD PTR tv143[rsp], 0
$LN18@AddLineQue:
	mov	BYTE PTR [rsp+32], 0
	movzx	r9d, BYTE PTR tv143[rsp]
	mov	r8d, 10
	mov	rdx, QWORD PTR d$[rsp]
	mov	ecx, DWORD PTR l$[rsp]
	call	myltoa

; 140  :                     d += strlen( d );

	mov	rcx, QWORD PTR d$[rsp]
	call	strlen
	mov	rcx, QWORD PTR d$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR d$[rsp], rax

; 141  :                     /* v2.07: add a 't' suffix if radix is != 10 */
; 142  :                     if ( ModuleInfo.radix != 10 )

	movzx	eax, BYTE PTR ModuleInfo+396
	cmp	eax, 10
	je	SHORT $LN14@AddLineQue

; 143  :                         *d++ = 't';

	mov	rax, QWORD PTR d$[rsp]
	mov	BYTE PTR [rax], 116			; 00000074H
	mov	rax, QWORD PTR d$[rsp]
	inc	rax
	mov	QWORD PTR d$[rsp], rax
$LN14@AddLineQue:
$LN13@AddLineQue:

; 144  :                 }
; 145  :                 break;

	jmp	SHORT $LN5@AddLineQue
$LN15@AddLineQue:

; 146  :             default:
; 147  :                 *d++ = *s;

	mov	rax, QWORD PTR d$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR d$[rsp]
	inc	rax
	mov	QWORD PTR d$[rsp], rax
$LN5@AddLineQue:

; 148  :             }
; 149  :         } else

	jmp	SHORT $LN8@AddLineQue
$LN7@AddLineQue:

; 150  :             *d++ = *s;

	mov	rax, QWORD PTR d$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR d$[rsp]
	inc	rax
	mov	QWORD PTR d$[rsp], rax
$LN8@AddLineQue:

; 151  :     }

	jmp	$LN2@AddLineQue
$LN3@AddLineQue:

; 152  :     *d = NULLC;

	mov	rax, QWORD PTR d$[rsp]
	mov	BYTE PTR [rax], 0

; 153  :     va_end( args );

	mov	QWORD PTR args$[rsp], 0

; 154  :     //DebugMsg(("AddlineQueueX() done\n" ));
; 155  :     AddLineQueue( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	AddLineQueue

; 156  :     return;
; 157  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:AddLineQueueX$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 768				; 00000300H
	pop	rdi
	ret	0
AddLineQueueX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\lqueue.c
_TEXT	SEGMENT
i$ = 32
new$ = 40
line$ = 64
AddLineQueue PROC

; 68   : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 69   :     unsigned i = strlen( line );

	mov	rcx, QWORD PTR line$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax

; 70   :     struct lq_line   *new;
; 71   : 
; 72   :     DebugMsg1(( "AddLineQueue(%p): #=%u >%s<\n", line, ++lqlines_written, line ));

	mov	eax, DWORD PTR lqlines_written
	inc	eax
	mov	DWORD PTR lqlines_written, eax
	mov	r9, QWORD PTR line$[rsp]
	mov	r8d, DWORD PTR lqlines_written
	mov	rdx, QWORD PTR line$[rsp]
	lea	rcx, OFFSET FLAT:$SG10396
	call	DoDebugMsg1

; 73   : 
; 74   :     /* v2.11: line queue has become static. */
; 75   :     //if ( line_queue == NULL ) {
; 76   :     //    line_queue = MemAlloc( sizeof( struct input_queue ) );
; 77   :     //    line_queue->tail = NULL;
; 78   :     //}
; 79   :     new = MemAlloc( sizeof( struct lq_line ) + i );

	mov	eax, DWORD PTR i$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	MemAlloc
	mov	QWORD PTR new$[rsp], rax

; 80   :     new->next = NULL;

	mov	rax, QWORD PTR new$[rsp]
	mov	QWORD PTR [rax], 0

; 81   :     DebugCmd( new->lineno = lqlines_written );

	mov	rax, QWORD PTR new$[rsp]
	movzx	ecx, BYTE PTR lqlines_written
	mov	BYTE PTR [rax+8], cl

; 82   :     memcpy( new->line, line, i + 1 );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	eax, eax
	mov	rcx, QWORD PTR new$[rsp]
	add	rcx, 9
	mov	r8d, eax
	mov	rdx, QWORD PTR line$[rsp]
	call	memcpy

; 83   : 
; 84   :     if( line_queue.head == NULL ) {

	cmp	QWORD PTR ModuleInfo+184, 0
	jne	SHORT $LN2@AddLineQue

; 85   :         line_queue.head = new;

	mov	rax, QWORD PTR new$[rsp]
	mov	QWORD PTR ModuleInfo+184, rax

; 86   :     } else {

	jmp	SHORT $LN3@AddLineQue
$LN2@AddLineQue:

; 87   :         /* insert at the tail */
; 88   :         ((struct qnode *)line_queue.tail)->next = new;

	mov	rax, QWORD PTR ModuleInfo+192
	mov	rcx, QWORD PTR new$[rsp]
	mov	QWORD PTR [rax], rcx
$LN3@AddLineQue:

; 89   :     }
; 90   :     line_queue.tail = new;

	mov	rax, QWORD PTR new$[rsp]
	mov	QWORD PTR ModuleInfo+192, rax

; 91   :     return;
; 92   : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
AddLineQueue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\lqueue.c
_TEXT	SEGMENT
curr$ = 32
next$ = 40
DeleteLineQueue PROC

; 45   : {

$LN6:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 46   :     struct qitem *curr;
; 47   :     struct qitem *next;
; 48   :     for( curr = line_queue.head; curr; curr = next ) {

	mov	rax, QWORD PTR ModuleInfo+184
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@DeleteLine
$LN2@DeleteLine:
	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR curr$[rsp], rax
$LN4@DeleteLine:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@DeleteLine

; 49   :         next = curr->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR next$[rsp], rax

; 50   :         MemFree( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	MemFree

; 51   :     }

	jmp	SHORT $LN2@DeleteLine
$LN3@DeleteLine:

; 52   :     line_queue.head = NULL;

	mov	QWORD PTR ModuleInfo+184, 0

; 53   : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
DeleteLineQueue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\lqueue.c
_TEXT	SEGMENT
GetLqLine PROC

; 38   : unsigned GetLqLine( void ) { return( lqlines_read ); }

$LN3:
	push	rdi
	mov	eax, DWORD PTR lqlines_read
	pop	rdi
	ret	0
GetLqLine ENDP
_TEXT	ENDS
END
