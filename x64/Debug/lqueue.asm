; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG10435 DB	'AddLineQueue(%p): #=%u >%s<', 0aH, 00H
	ORG $+3
$SG10520 DB	'RunLineQueue() enter', 0aH, 00H
	ORG $+10
$SG10523 DB	'!!!!! Warning: End directive found in generated-code par'
	DB	'ser loop!', 0aH, 00H
	ORG $+5
$SG10524 DB	'RunLineQueue() exit', 0aH, 00H
_DATA	ENDS
PUBLIC	GetLqLine
PUBLIC	DeleteLineQueue
PUBLIC	AddLineQueue
PUBLIC	AddLineQueueX
PUBLIC	RunLineQueue
EXTRN	memcpy:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	myltoa:PROC
EXTRN	myqtoa:PROC
EXTRN	MemAlloc:PROC
EXTRN	MemFree:PROC
EXTRN	GetResWName:PROC
EXTRN	PushInputStatus:PROC
EXTRN	PopInputStatus:PROC
EXTRN	ParseLine:PROC
EXTRN	PreprocessLine:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	ResWordTable:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
lqlines_written DD 01H DUP (?)
lqlines_read DD	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$DeleteLineQueue DD imagerel $LN6
	DD	imagerel $LN6+77
	DD	imagerel $unwind$DeleteLineQueue
$pdata$AddLineQueue DD imagerel $LN5
	DD	imagerel $LN5+200
	DD	imagerel $unwind$AddLineQueue
$pdata$AddLineQueueX DD imagerel $LN25
	DD	imagerel $LN25+909
	DD	imagerel $unwind$AddLineQueueX
$pdata$RunLineQueue DD imagerel $LN8
	DD	imagerel $LN8+270
	DD	imagerel $unwind$RunLineQueue
pdata	ENDS
xdata	SEGMENT
$unwind$DeleteLineQueue DD 010401H
	DD	06204H
$unwind$AddLineQueue DD 010901H
	DD	06209H
$unwind$AddLineQueueX DD 022d19H
	DD	091011bH
	DD	imagerel __GSHandlerCheck
	DD	0470H
$unwind$RunLineQueue DD 010401H
	DD	0c204H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\lqueue.c
_TEXT	SEGMENT
currline$ = 32
tokenarray$ = 40
nextline$1 = 48
oldstat$ = 56
RunLineQueue PROC

; 179  : {

$LN8:
	sub	rsp, 104				; 00000068H

; 180  :     struct input_status oldstat;
; 181  :     struct asm_tok *tokenarray;
; 182  :     struct lq_line *currline = line_queue.head;

	mov	rax, QWORD PTR ModuleInfo+184
	mov	QWORD PTR currline$[rsp], rax

; 183  : 
; 184  :     DebugMsg1(( "RunLineQueue() enter\n" ));

	lea	rcx, OFFSET FLAT:$SG10520
	call	DoDebugMsg1

; 185  : 
; 186  :     /* v2.03: ensure the current source buffer is still aligned */
; 187  :     tokenarray = PushInputStatus( &oldstat );

	lea	rcx, QWORD PTR oldstat$[rsp]
	call	PushInputStatus
	mov	QWORD PTR tokenarray$[rsp], rax

; 188  :     ModuleInfo.GeneratedCode++;

	mov	eax, DWORD PTR ModuleInfo+456
	inc	eax
	mov	DWORD PTR ModuleInfo+456, eax

; 189  : 
; 190  :     /* v2.11: line queues are no longer pushed onto the file stack.
; 191  :      * Instead, the queue is processed directly here.
; 192  :      */
; 193  :     line_queue.head = NULL;

	mov	QWORD PTR ModuleInfo+184, 0

; 194  :     DebugCmd( lqlines_written = 0 ); /* reset counter for AddLineQueue() */

	mov	DWORD PTR lqlines_written, 0

; 195  :     DebugCmd( lqlines_read = 0 ); /* reset counter for line-queue reads below */

	mov	DWORD PTR lqlines_read, 0
$LN2@RunLineQue:

; 196  : 
; 197  :     for ( ; currline; ) {

	cmp	QWORD PTR currline$[rsp], 0
	je	SHORT $LN3@RunLineQue

; 198  :         struct lq_line *nextline = currline->next;

	mov	rax, QWORD PTR currline$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR nextline$1[rsp], rax

; 199  :         strcpy( CurrSource, currline->line );

	mov	rax, QWORD PTR currline$[rsp]
	add	rax, 9
	mov	rdx, rax
	mov	rcx, QWORD PTR ModuleInfo+464
	call	strcpy

; 200  :         DebugCmd ( lqlines_read++ );

	mov	eax, DWORD PTR lqlines_read
	inc	eax
	mov	DWORD PTR lqlines_read, eax

; 201  :         MemFree( currline );

	mov	rcx, QWORD PTR currline$[rsp]
	call	MemFree

; 202  :         if ( PreprocessLine( CurrSource, tokenarray ) )

	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+464
	call	PreprocessLine
	test	eax, eax
	je	SHORT $LN5@RunLineQue

; 203  :             ParseLine( tokenarray );

	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	ParseLine
$LN5@RunLineQue:

; 204  :         currline = nextline;

	mov	rax, QWORD PTR nextline$1[rsp]
	mov	QWORD PTR currline$[rsp], rax

; 205  :     }

	jmp	SHORT $LN2@RunLineQue
$LN3@RunLineQue:

; 206  : 
; 207  : #ifdef DEBUG_OUT
; 208  :     if ( ModuleInfo.EndDirFound == TRUE ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 16
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN6@RunLineQue

; 209  :         DebugMsg(("!!!!! Warning: End directive found in generated-code parser loop!\n"));

	lea	rcx, OFFSET FLAT:$SG10523
	call	DoDebugMsg
$LN6@RunLineQue:

; 210  :     }
; 211  : #endif
; 212  :     ModuleInfo.GeneratedCode--;

	mov	eax, DWORD PTR ModuleInfo+456
	dec	eax
	mov	DWORD PTR ModuleInfo+456, eax

; 213  :     PopInputStatus( &oldstat );

	lea	rcx, QWORD PTR oldstat$[rsp]
	call	PopInputStatus

; 214  : 
; 215  :     DebugMsg1(( "RunLineQueue() exit\n" ));

	lea	rcx, OFFSET FLAT:$SG10524
	call	DoDebugMsg1

; 216  :     return;
; 217  : }

	add	rsp, 104				; 00000068H
	ret	0
RunLineQueue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\lqueue.c
_TEXT	SEGMENT
d$ = 48
args$ = 56
i$ = 64
s$ = 72
tv74 = 80
l$ = 84
tv133 = 88
tv159 = 92
p$ = 96
q$ = 104
buffer$ = 112
__$ArrayPad$ = 1136
fmt$ = 1168
AddLineQueueX PROC

; 98   : {

$LN25:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 1160				; 00000488H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 99   :     va_list args;
; 100  :     char *d;
; 101  :     int i;
; 102  :     int_32 l;
; 103  :     int_64 q;
; 104  :     const char *s;
; 105  :     const char *p;
; 106  :     char buffer[MAX_LINE_LEN];
; 107  : 
; 108  :     //DebugMsg(("AddlineQueueX(%s) enter\n", fmt ));
; 109  :     va_start( args, fmt );

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 110  :     for ( s = fmt, d = buffer; *s; s++ ) {

	mov	rax, QWORD PTR fmt$[rsp]
	mov	QWORD PTR s$[rsp], rax
	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR d$[rsp], rax
	jmp	SHORT $LN4@AddLineQue
$LN2@AddLineQue:
	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR s$[rsp], rax
$LN4@AddLineQue:
	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@AddLineQue

; 111  :         if ( *s == '%' ) {

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	$LN7@AddLineQue

; 112  :             s++;

	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR s$[rsp], rax

; 113  :             switch ( *s ) {

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv74[rsp], eax
	mov	eax, DWORD PTR tv74[rsp]
	sub	eax, 100				; 00000064H
	mov	DWORD PTR tv74[rsp], eax
	cmp	DWORD PTR tv74[rsp], 20
	ja	$LN17@AddLineQue
	movsxd	rax, DWORD PTR tv74[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN23@AddLineQue[rcx+rax]
	mov	eax, DWORD PTR $LN24@AddLineQue[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN9@AddLineQue:

; 114  :             case 'r':
; 115  :                 i = va_arg( args, int );

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	eax, DWORD PTR [rax-8]
	mov	DWORD PTR i$[rsp], eax

; 116  :                 GetResWName( i , d );

	mov	rdx, QWORD PTR d$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	GetResWName

; 117  :                 /* v2.06: the name is already copied */
; 118  :                 //memcpy( d, ResWordTable[i].name, ResWordTable[i].len );
; 119  :                 d += ResWordTable[i].len;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:ResWordTable
	movzx	eax, BYTE PTR [rcx+rax+2]
	mov	rcx, QWORD PTR d$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR d$[rsp], rax

; 120  :                 break;

	jmp	$LN5@AddLineQue
$LN10@AddLineQue:

; 121  :             case 's':
; 122  :                 p = va_arg( args, char * );

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR p$[rsp], rax

; 123  :                 i = strlen( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax

; 124  :                 memcpy( d, p, i );

	movsxd	rax, DWORD PTR i$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	call	memcpy

; 125  :                 d += i;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR d$[rsp], rax

; 126  :                 *d = NULLC;

	mov	rax, QWORD PTR d$[rsp]
	mov	BYTE PTR [rax], 0

; 127  :                 break;

	jmp	$LN5@AddLineQue
$LN11@AddLineQue:

; 128  : #if AMD64_SUPPORT
; 129  :             case 'q':
; 130  :               q = va_arg(args, int_64);

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR q$[rsp], rax

; 131  :               myqtoa(q, d, 10, q < 0, FALSE);

	cmp	QWORD PTR q$[rsp], 0
	jge	SHORT $LN19@AddLineQue
	mov	DWORD PTR tv133[rsp], 1
	jmp	SHORT $LN20@AddLineQue
$LN19@AddLineQue:
	mov	DWORD PTR tv133[rsp], 0
$LN20@AddLineQue:
	mov	BYTE PTR [rsp+32], 0
	movzx	r9d, BYTE PTR tv133[rsp]
	mov	r8d, 10
	mov	rdx, QWORD PTR d$[rsp]
	mov	rcx, QWORD PTR q$[rsp]
	call	myqtoa

; 132  :               d += strlen(d);

	mov	rcx, QWORD PTR d$[rsp]
	call	strlen
	mov	rcx, QWORD PTR d$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR d$[rsp], rax

; 133  :               /* v2.07: add a 't' suffix if radix is != 10 */
; 134  :               if (ModuleInfo.radix != 10)

	movzx	eax, BYTE PTR ModuleInfo+396
	cmp	eax, 10
	je	SHORT $LN12@AddLineQue

; 135  :                 *d++ = 't';

	mov	rax, QWORD PTR d$[rsp]
	mov	BYTE PTR [rax], 116			; 00000074H
	mov	rax, QWORD PTR d$[rsp]
	inc	rax
	mov	QWORD PTR d$[rsp], rax
$LN12@AddLineQue:

; 136  :               break;

	jmp	$LN5@AddLineQue
$LN13@AddLineQue:

; 137  : #endif
; 138  :             case 'd':
; 139  :             case 'u':
; 140  :             case 'x':
; 141  : #ifdef __I86__ /* v2.08: use long only if size(int) is 16-bit */
; 142  :                 l = va_arg( args, long );
; 143  : #else
; 144  :                 l = va_arg( args, int );

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	eax, DWORD PTR [rax-8]
	mov	DWORD PTR l$[rsp], eax

; 145  : #endif
; 146  :                 if ( *s == 'x' ) {

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 120				; 00000078H
	jne	SHORT $LN14@AddLineQue

; 147  :                     myltoa( l, d, 16, FALSE, FALSE );

	mov	BYTE PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8d, 16
	mov	rdx, QWORD PTR d$[rsp]
	mov	ecx, DWORD PTR l$[rsp]
	call	myltoa

; 148  :                     d += strlen( d );

	mov	rcx, QWORD PTR d$[rsp]
	call	strlen
	mov	rcx, QWORD PTR d$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR d$[rsp], rax

; 149  :                 } else {

	jmp	SHORT $LN15@AddLineQue
$LN14@AddLineQue:

; 150  :                     myltoa( l, d, 10, l < 0, FALSE );

	cmp	DWORD PTR l$[rsp], 0
	jge	SHORT $LN21@AddLineQue
	mov	DWORD PTR tv159[rsp], 1
	jmp	SHORT $LN22@AddLineQue
$LN21@AddLineQue:
	mov	DWORD PTR tv159[rsp], 0
$LN22@AddLineQue:
	mov	BYTE PTR [rsp+32], 0
	movzx	r9d, BYTE PTR tv159[rsp]
	mov	r8d, 10
	mov	rdx, QWORD PTR d$[rsp]
	mov	ecx, DWORD PTR l$[rsp]
	call	myltoa

; 151  :                     d += strlen( d );

	mov	rcx, QWORD PTR d$[rsp]
	call	strlen
	mov	rcx, QWORD PTR d$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR d$[rsp], rax

; 152  :                     /* v2.07: add a 't' suffix if radix is != 10 */
; 153  :                     if ( ModuleInfo.radix != 10 )

	movzx	eax, BYTE PTR ModuleInfo+396
	cmp	eax, 10
	je	SHORT $LN16@AddLineQue

; 154  :                         *d++ = 't';

	mov	rax, QWORD PTR d$[rsp]
	mov	BYTE PTR [rax], 116			; 00000074H
	mov	rax, QWORD PTR d$[rsp]
	inc	rax
	mov	QWORD PTR d$[rsp], rax
$LN16@AddLineQue:
$LN15@AddLineQue:

; 155  :                 }
; 156  :                 break;

	jmp	SHORT $LN5@AddLineQue
$LN17@AddLineQue:

; 157  :             default:
; 158  :                 *d++ = *s;

	mov	rax, QWORD PTR d$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR d$[rsp]
	inc	rax
	mov	QWORD PTR d$[rsp], rax
$LN5@AddLineQue:

; 159  :             }
; 160  :         } else

	jmp	SHORT $LN8@AddLineQue
$LN7@AddLineQue:

; 161  :             *d++ = *s;

	mov	rax, QWORD PTR d$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR d$[rsp]
	inc	rax
	mov	QWORD PTR d$[rsp], rax
$LN8@AddLineQue:

; 162  :     }

	jmp	$LN2@AddLineQue
$LN3@AddLineQue:

; 163  :     *d = NULLC;

	mov	rax, QWORD PTR d$[rsp]
	mov	BYTE PTR [rax], 0

; 164  :     va_end( args );

	mov	QWORD PTR args$[rsp], 0

; 165  :     //DebugMsg(("AddlineQueueX() done\n" ));
; 166  :     AddLineQueue( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	AddLineQueue

; 167  :     return;
; 168  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1160				; 00000488H
	ret	0
	npad	3
$LN24@AddLineQue:
	DD	$LN13@AddLineQue
	DD	$LN11@AddLineQue
	DD	$LN9@AddLineQue
	DD	$LN10@AddLineQue
	DD	$LN17@AddLineQue
$LN23@AddLineQue:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	3
	DB	4
	DB	0
	DB	4
	DB	4
	DB	0
AddLineQueueX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\lqueue.c
_TEXT	SEGMENT
i$ = 32
new$ = 40
line$ = 64
AddLineQueue PROC

; 68   : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 69   :     unsigned i = strlen( line );

	mov	rcx, QWORD PTR line$[rsp]
	call	strlen
	mov	DWORD PTR i$[rsp], eax

; 70   :     struct lq_line   *new;
; 71   : 
; 72   :     DebugMsg1(( "AddLineQueue(%p): #=%u >%s<\n", line, ++lqlines_written, line ));

	mov	eax, DWORD PTR lqlines_written
	inc	eax
	mov	DWORD PTR lqlines_written, eax
	mov	r9, QWORD PTR line$[rsp]
	mov	r8d, DWORD PTR lqlines_written
	mov	rdx, QWORD PTR line$[rsp]
	lea	rcx, OFFSET FLAT:$SG10435
	call	DoDebugMsg1

; 73   : 
; 74   :     /* v2.11: line queue has become static. */
; 75   :     //if ( line_queue == NULL ) {
; 76   :     //    line_queue = MemAlloc( sizeof( struct input_queue ) );
; 77   :     //    line_queue->tail = NULL;
; 78   :     //}
; 79   :     new = MemAlloc( sizeof( struct lq_line ) + i );

	mov	eax, DWORD PTR i$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	MemAlloc
	mov	QWORD PTR new$[rsp], rax

; 80   :     new->next = NULL;

	mov	rax, QWORD PTR new$[rsp]
	mov	QWORD PTR [rax], 0

; 81   :     DebugCmd( new->lineno = lqlines_written );

	mov	rax, QWORD PTR new$[rsp]
	movzx	ecx, BYTE PTR lqlines_written
	mov	BYTE PTR [rax+8], cl

; 82   :     memcpy( new->line, line, i + 1 );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	eax, eax
	mov	rcx, QWORD PTR new$[rsp]
	add	rcx, 9
	mov	r8d, eax
	mov	rdx, QWORD PTR line$[rsp]
	call	memcpy

; 83   : 
; 84   :     if( line_queue.head == NULL ) {

	cmp	QWORD PTR ModuleInfo+184, 0
	jne	SHORT $LN2@AddLineQue

; 85   :         line_queue.head = new;

	mov	rax, QWORD PTR new$[rsp]
	mov	QWORD PTR ModuleInfo+184, rax

; 86   :     } else {

	jmp	SHORT $LN3@AddLineQue
$LN2@AddLineQue:

; 87   :         /* insert at the tail */
; 88   :         ((struct qnode *)line_queue.tail)->next = new;

	mov	rax, QWORD PTR ModuleInfo+192
	mov	rcx, QWORD PTR new$[rsp]
	mov	QWORD PTR [rax], rcx
$LN3@AddLineQue:

; 89   :     }
; 90   :     line_queue.tail = new;

	mov	rax, QWORD PTR new$[rsp]
	mov	QWORD PTR ModuleInfo+192, rax

; 91   :     return;
; 92   : }

	add	rsp, 56					; 00000038H
	ret	0
AddLineQueue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\lqueue.c
_TEXT	SEGMENT
curr$ = 32
next$ = 40
DeleteLineQueue PROC

; 45   : {

$LN6:
	sub	rsp, 56					; 00000038H

; 46   :     struct qitem *curr;
; 47   :     struct qitem *next;
; 48   :     for( curr = line_queue.head; curr; curr = next ) {

	mov	rax, QWORD PTR ModuleInfo+184
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@DeleteLine
$LN2@DeleteLine:
	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR curr$[rsp], rax
$LN4@DeleteLine:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@DeleteLine

; 49   :         next = curr->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR next$[rsp], rax

; 50   :         MemFree( curr );

	mov	rcx, QWORD PTR curr$[rsp]
	call	MemFree

; 51   :     }

	jmp	SHORT $LN2@DeleteLine
$LN3@DeleteLine:

; 52   :     line_queue.head = NULL;

	mov	QWORD PTR ModuleInfo+184, 0

; 53   : }

	add	rsp, 56					; 00000038H
	ret	0
DeleteLineQueue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\lqueue.c
_TEXT	SEGMENT
GetLqLine PROC

; 38   : unsigned GetLqLine( void ) { return( lqlines_read ); }

	mov	eax, DWORD PTR lqlines_read
	ret	0
GetLqLine ENDP
_TEXT	ENDS
END
