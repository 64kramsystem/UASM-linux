; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG10825 DB	'ASSUMES', 00H
$SG10826 DB	'RADIX', 00H
	ORG $+2
$SG10827 DB	'LISTING', 00H
$SG10828 DB	'CPU', 00H
$SG10830 DB	'ALL', 00H
$SG10829 DB	'ALIGNMENT', 00H
	ORG $+6
$SG10889 DB	'%s directive enter', 0aH, 00H
	ORG $+4
$SG10897 DB	'POPCONTEXT type=%X', 0aH, 00H
	ORG $+4
$SG10898 DB	'POPCONTEXT: found item with type=%X', 0aH, 00H
	ORG $+3
$SG10909 DB	'POPCONTEXT error, remaining type flags=%X', 0aH, 00H
	ORG $+5
$SG10910 DB	'PUSHCONTEXT type=%X', 0aH, 00H
	ORG $+3
$SG10936 DB	'ContextSaveState: SavedContexts=%X', 0aH, 00H
_DATA	ENDS
CONST	SEGMENT
typetab	DD	01H
	DD	02H
	DD	04H
	DD	08H
	DD	010H
	DD	0fH
contextnames DQ	FLAT:$SG10825
	DQ	FLAT:$SG10826
	DQ	FLAT:$SG10827
	DQ	FLAT:$SG10828
	DQ	FLAT:$SG10829
	DQ	FLAT:$SG10830
CONST	ENDS
PUBLIC	ContextSaveState
PUBLIC	ContextDirective
PUBLIC	ContextInit
EXTRN	memcpy:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	EmitErr:PROC
EXTRN	LclAlloc:PROC
EXTRN	SetSegAssumeTable:PROC
EXTRN	GetSegAssumeTable:PROC
EXTRN	SetStdAssumeTable:PROC
EXTRN	GetStdAssumeTable:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	_RTC_UninitUse:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	sym_Cpu:QWORD
pdata	SEGMENT
$pdata$ContextSaveState DD imagerel $LN10
	DD	imagerel $LN10+235
	DD	imagerel $unwind$ContextSaveState
$pdata$ContextDirective DD imagerel $LN60
	DD	imagerel $LN60+2057
	DD	imagerel $unwind$ContextDirective
$pdata$ContextRestoreState DD imagerel ContextRestoreState
	DD	imagerel ContextRestoreState+193
	DD	imagerel $unwind$ContextRestoreState
$pdata$ContextInit DD imagerel $LN4
	DD	imagerel $LN4+46
	DD	imagerel $unwind$ContextInit
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
ContextDirective$rtcName$0 DB 074H
	DB	079H
	DB	070H
	DB	065H
	DB	00H
CONST	ENDS
xdata	SEGMENT
$unwind$ContextSaveState DD 021501H
	DD	070027206H
$unwind$ContextDirective DD 022101H
	DD	0700ab20eH
$unwind$ContextRestoreState DD 021501H
	DD	070025206H
$unwind$ContextInit DD 021c01H
	DD	070053209H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\context.c
_TEXT	SEGMENT
pass$ = 48
ContextInit PROC

; 298  : {

$LN4:
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+48]

; 299  :     /* if ContextStack isn't NULL, then at least one PUSHCONTEXT
; 300  :      * didn't have a matching POPCONTEXT. No need to reset it to NULL -
; 301  :      * but might be ok to move the items to the ContextFree heap.
; 302  :      */
; 303  :     //ContextStack = NULL;
; 304  : #if FASTPASS
; 305  :     if ( pass > PASS_1 ) {

	cmp	DWORD PTR pass$[rsp], 0
	jle	SHORT $LN2@ContextIni

; 306  :         ContextRestoreState();

	call	ContextRestoreState
$LN2@ContextIni:

; 307  :     }
; 308  : #endif
; 309  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ContextInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\context.c
_TEXT	SEGMENT
i$ = 32
dst$ = 40
ContextRestoreState PROC

; 276  : {

	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 277  :     int i;
; 278  :     struct context *dst;
; 279  : 
; 280  :     for ( i = cntSavedContexts ; i ; i-- ) {

	mov	eax, DWORD PTR ModuleInfo+264
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN4@ContextRes
$LN2@ContextRes:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@ContextRes:
	cmp	DWORD PTR i$[rsp], 0
	je	$LN3@ContextRes

; 281  :         if ( ContextFree ) {

	cmp	QWORD PTR ModuleInfo+248, 0
	je	SHORT $LN5@ContextRes

; 282  :             dst = ContextFree;

	mov	rax, QWORD PTR ModuleInfo+248
	mov	QWORD PTR dst$[rsp], rax

; 283  :             ContextFree = dst->next;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ModuleInfo+248, rax

; 284  :         } else

	jmp	SHORT $LN6@ContextRes
$LN5@ContextRes:

; 285  :             dst = LclAlloc( sizeof( struct context ) );

	mov	ecx, 752				; 000002f0H
	call	LclAlloc
	mov	QWORD PTR dst$[rsp], rax
$LN6@ContextRes:

; 286  :         memcpy( dst, &SavedContexts[i-1], sizeof( struct context ) );

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	imul	rax, rax, 752				; 000002f0H
	mov	rcx, QWORD PTR ModuleInfo+256
	add	rcx, rax
	mov	rax, rcx
	mov	r8d, 752				; 000002f0H
	mov	rdx, rax
	mov	rcx, QWORD PTR dst$[rsp]
	call	memcpy

; 287  :         dst->next = ContextStack;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+240
	mov	QWORD PTR [rax], rcx

; 288  :         ContextStack = dst;

	mov	rax, QWORD PTR dst$[rsp]
	mov	QWORD PTR ModuleInfo+240, rax

; 289  :     }

	jmp	$LN2@ContextRes
$LN3@ContextRes:

; 290  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
ContextRestoreState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\context.c
_TEXT	SEGMENT
start$ = 32
directive$ = 36
type$ = 40
j$ = 44
curr$ = 48
prev$2 = 56
next$3 = 64
$T4 = 72
tv355 = 80
tv154 = 88
tv245 = 92
i$ = 112
tokenarray$ = 120
ContextDirective PROC

; 107  : {

$LN60:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rdi, rsp
	mov	ecx, 24
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+112]
	mov	BYTE PTR $T4[rsp], 0

; 108  :     int start = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR start$[rsp], eax

; 109  :     int directive = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR directive$[rsp], eax

; 110  :     enum context_type type;
; 111  :     int j;
; 112  :     struct context *curr;
; 113  : 
; 114  :     DebugMsg(( "%s directive enter\n", tokenarray[i].string_ptr ));

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG10889
	call	DoDebugMsg

; 115  : 
; 116  :     i++; /* skip CONTEXT keyword */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN2@ContextDir:

; 117  : 
; 118  :     while ( tokenarray[i].token == T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN3@ContextDir

; 119  :         for ( j = 0, type = -1; j < ( sizeof(typetab) / sizeof(typetab[0]) ); j++ ) {

	mov	DWORD PTR j$[rsp], 0
	mov	BYTE PTR $T4[rsp], 1
	mov	DWORD PTR type$[rsp], -1
	jmp	SHORT $LN6@ContextDir
$LN4@ContextDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN6@ContextDir:
	movsxd	rax, DWORD PTR j$[rsp]
	cmp	rax, 6
	jae	SHORT $LN5@ContextDir

; 120  :             if ( _stricmp( contextnames[j], tokenarray[i].string_ptr ) == 0 ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR j$[rsp]
	lea	rdx, OFFSET FLAT:contextnames
	mov	QWORD PTR tv355[rsp], rdx
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [r8+rax+8]
	mov	rax, QWORD PTR tv355[rsp]
	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN17@ContextDir

; 121  :                 type = typetab[j];

	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:typetab
	mov	BYTE PTR $T4[rsp], 1
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR type$[rsp], eax

; 122  :                 break;

	jmp	SHORT $LN5@ContextDir
$LN17@ContextDir:

; 123  :             }
; 124  :         }

	jmp	SHORT $LN4@ContextDir
$LN5@ContextDir:

; 125  : 
; 126  :         if ( type == -1 )

	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN46@ContextDir
	lea	rcx, OFFSET FLAT:ContextDirective$rtcName$0
	call	_RTC_UninitUse
$LN46@ContextDir:
	cmp	DWORD PTR type$[rsp], -1
	jne	SHORT $LN18@ContextDir

; 127  :             break;

	jmp	$LN3@ContextDir
$LN18@ContextDir:

; 128  : 
; 129  :         /* reject ALIGNMENT if strict masm compat is on */
; 130  :         if ( Options.strict_masm_compat ) {

	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	je	SHORT $LN19@ContextDir

; 131  :             if ( type == CONT_ALIGNMENT )

	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN47@ContextDir
	lea	rcx, OFFSET FLAT:ContextDirective$rtcName$0
	call	_RTC_UninitUse
$LN47@ContextDir:
	cmp	DWORD PTR type$[rsp], 16
	jne	SHORT $LN20@ContextDir

; 132  :                 break;

	jmp	$LN3@ContextDir
	jmp	SHORT $LN21@ContextDir
$LN20@ContextDir:

; 133  :             else
; 134  :                 type &= ~CONT_ALIGNMENT; /* in case ALIGNMENT is again included in ALL */

	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN48@ContextDir
	lea	rcx, OFFSET FLAT:ContextDirective$rtcName$0
	call	_RTC_UninitUse
$LN48@ContextDir:
	mov	eax, DWORD PTR type$[rsp]
	and	eax, -17
	mov	BYTE PTR $T4[rsp], 1
	mov	DWORD PTR type$[rsp], eax
$LN21@ContextDir:
$LN19@ContextDir:

; 135  :         }
; 136  : 
; 137  :         if ( directive == T_POPCONTEXT ) {

	cmp	DWORD PTR directive$[rsp], 448		; 000001c0H
	jne	$LN22@ContextDir

; 138  :             struct context *prev;
; 139  :             struct context *next;
; 140  :             DebugMsg(( "POPCONTEXT type=%X\n", type ));

	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN49@ContextDir
	lea	rcx, OFFSET FLAT:ContextDirective$rtcName$0
	call	_RTC_UninitUse
$LN49@ContextDir:
	mov	edx, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:$SG10897
	call	DoDebugMsg

; 141  :             /* for POPCONTEXT, check if appropriate items are on the stack */
; 142  :             for ( prev = NULL, curr = ContextStack; curr && type; curr = next ) {

	mov	QWORD PTR prev$2[rsp], 0
	mov	rax, QWORD PTR ModuleInfo+240
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN9@ContextDir
$LN7@ContextDir:
	mov	rax, QWORD PTR next$3[rsp]
	mov	QWORD PTR curr$[rsp], rax
$LN9@ContextDir:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN8@ContextDir
	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN50@ContextDir
	lea	rcx, OFFSET FLAT:ContextDirective$rtcName$0
	call	_RTC_UninitUse
$LN50@ContextDir:
	cmp	DWORD PTR type$[rsp], 0
	je	$LN8@ContextDir

; 143  : 
; 144  :                 DebugMsg(( "POPCONTEXT: found item with type=%X\n", curr->type ));

	mov	rax, QWORD PTR curr$[rsp]
	mov	edx, DWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10898
	call	DoDebugMsg

; 145  :                 next = curr->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR next$3[rsp], rax

; 146  :                 /* matching item on the stack? */
; 147  :                 if ( !( curr->type & type ) ) {

	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN51@ContextDir
	lea	rcx, OFFSET FLAT:ContextDirective$rtcName$0
	call	_RTC_UninitUse
$LN51@ContextDir:
	mov	rax, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR type$[rsp]
	mov	eax, DWORD PTR [rax+8]
	and	eax, ecx
	test	eax, eax
	jne	SHORT $LN24@ContextDir

; 148  :                     prev = curr;

	mov	rax, QWORD PTR curr$[rsp]
	mov	QWORD PTR prev$2[rsp], rax

; 149  :                     continue;

	jmp	$LN7@ContextDir
$LN24@ContextDir:

; 150  :                 }
; 151  : 
; 152  :                 type &= ~curr->type;

	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN52@ContextDir
	lea	rcx, OFFSET FLAT:ContextDirective$rtcName$0
	call	_RTC_UninitUse
$LN52@ContextDir:
	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+8]
	not	eax
	mov	ecx, DWORD PTR type$[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR $T4[rsp], 1
	mov	DWORD PTR type$[rsp], eax

; 153  :                 if ( prev )

	cmp	QWORD PTR prev$2[rsp], 0
	je	SHORT $LN25@ContextDir

; 154  :                     prev->next = next;

	mov	rax, QWORD PTR prev$2[rsp]
	mov	rcx, QWORD PTR next$3[rsp]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN26@ContextDir
$LN25@ContextDir:

; 155  :                 else
; 156  :                     ContextStack = next;

	mov	rax, QWORD PTR next$3[rsp]
	mov	QWORD PTR ModuleInfo+240, rax
$LN26@ContextDir:

; 157  : 
; 158  :                 curr->next = ContextFree;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+248
	mov	QWORD PTR [rax], rcx

; 159  :                 ContextFree = curr;

	mov	rax, QWORD PTR curr$[rsp]
	mov	QWORD PTR ModuleInfo+248, rax

; 160  : 
; 161  :                 /* restore the values */
; 162  :                 switch ( curr->type ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR tv154[rsp], eax
	cmp	DWORD PTR tv154[rsp], 1
	je	SHORT $LN27@ContextDir
	cmp	DWORD PTR tv154[rsp], 2
	je	SHORT $LN28@ContextDir
	cmp	DWORD PTR tv154[rsp], 4
	je	$LN30@ContextDir
	cmp	DWORD PTR tv154[rsp], 8
	je	$LN31@ContextDir
	cmp	DWORD PTR tv154[rsp], 16
	je	SHORT $LN29@ContextDir
	jmp	$LN10@ContextDir
$LN27@ContextDir:

; 163  :                 case CONT_ASSUMES:
; 164  :                     SetSegAssumeTable( curr->ac.SegAssumeTable );

	mov	rax, QWORD PTR curr$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	SetSegAssumeTable

; 165  :                     SetStdAssumeTable( curr->ac.StdAssumeTable, curr->ac.type_content );

	mov	rax, QWORD PTR curr$[rsp]
	add	rax, 368				; 00000170H
	mov	rcx, QWORD PTR curr$[rsp]
	add	rcx, 112				; 00000070H
	mov	rdx, rax
	call	SetStdAssumeTable

; 166  :                     break;

	jmp	$LN10@ContextDir
$LN28@ContextDir:

; 167  :                 case CONT_RADIX:
; 168  :                     ModuleInfo.radix = curr->rc.radix;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	mov	BYTE PTR ModuleInfo+396, al

; 169  :                     break;

	jmp	$LN10@ContextDir
$LN29@ContextDir:

; 170  :                 case CONT_ALIGNMENT:
; 171  :                     ModuleInfo.fieldalign = curr->alc.fieldalign;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	mov	BYTE PTR ModuleInfo+397, al

; 172  :                     ModuleInfo.procalign  = curr->alc.procalign;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+17]
	mov	BYTE PTR ModuleInfo+399, al

; 173  :                     break;

	jmp	$LN10@ContextDir
$LN30@ContextDir:

; 174  :                 case CONT_LISTING:
; 175  :                     ModuleInfo.list_macro = curr->lc.list_macro;

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR ModuleInfo+400, eax

; 176  :                     ModuleInfo.list       = curr->lc.list;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+20]
	and	al, 1
	movzx	eax, al
	and	eax, 1
	shl	eax, 11
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 11
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 177  :                     ModuleInfo.cref       = curr->lc.cref;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+20]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	and	eax, 1
	shl	eax, 12
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 12
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 178  :                     ModuleInfo.listif     = curr->lc.listif;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+20]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	and	eax, 1
	shl	eax, 13
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 13
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 179  :                     ModuleInfo.list_generated_code = curr->lc.list_generated_code;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+20]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	and	eax, 1
	shl	eax, 14
	mov	ecx, DWORD PTR ModuleInfo+408
	btr	ecx, 14
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 180  :                     break;

	jmp	SHORT $LN10@ContextDir
$LN31@ContextDir:

; 181  :                 case CONT_CPU:
; 182  :                     ModuleInfo.cpu      = curr->cc.cpu;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, WORD PTR [rax+16]
	mov	WORD PTR ModuleInfo+388, ax

; 183  :                     if ( sym_Cpu )

	cmp	QWORD PTR sym_Cpu, 0
	je	SHORT $LN32@ContextDir

; 184  :                         sym_Cpu->value  = curr->cc.cpu;

	mov	rax, QWORD PTR curr$[rsp]
	movsx	eax, WORD PTR [rax+16]
	mov	rcx, QWORD PTR sym_Cpu
	mov	DWORD PTR [rcx+16], eax
$LN32@ContextDir:

; 185  :                     ModuleInfo.curr_cpu = curr->cc.curr_cpu;

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+20]
	mov	DWORD PTR ModuleInfo+392, eax
$LN10@ContextDir:

; 186  :                 }
; 187  :             }

	jmp	$LN7@ContextDir
$LN8@ContextDir:

; 188  :             if ( type ) {

	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN53@ContextDir
	lea	rcx, OFFSET FLAT:ContextDirective$rtcName$0
	call	_RTC_UninitUse
$LN53@ContextDir:
	cmp	DWORD PTR type$[rsp], 0
	je	SHORT $LN33@ContextDir

; 189  :                 DebugMsg(( "POPCONTEXT error, remaining type flags=%X\n", type ));

	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN54@ContextDir
	lea	rcx, OFFSET FLAT:ContextDirective$rtcName$0
	call	_RTC_UninitUse
$LN54@ContextDir:
	mov	edx, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:$SG10909
	call	DoDebugMsg

; 190  :                 return( EmitErr( UNMATCHED_BLOCK_NESTING, tokenarray[start].tokpos ) );

	movsxd	rax, DWORD PTR start$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 142				; 0000008eH
	call	EmitErr
	jmp	$LN1@ContextDir
$LN33@ContextDir:

; 191  :             }
; 192  :         } else {

	jmp	$LN23@ContextDir
$LN22@ContextDir:

; 193  :             DebugMsg(( "PUSHCONTEXT type=%X\n", type ));

	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN55@ContextDir
	lea	rcx, OFFSET FLAT:ContextDirective$rtcName$0
	call	_RTC_UninitUse
$LN55@ContextDir:
	mov	edx, DWORD PTR type$[rsp]
	lea	rcx, OFFSET FLAT:$SG10910
	call	DoDebugMsg

; 194  :             for ( j = 0; j < ( sizeof(typetab) / sizeof(typetab[0] ) ) && type; j++ ) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN14@ContextDir
$LN12@ContextDir:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN14@ContextDir:
	movsxd	rax, DWORD PTR j$[rsp]
	cmp	rax, 6
	jae	$LN13@ContextDir
	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN56@ContextDir
	lea	rcx, OFFSET FLAT:ContextDirective$rtcName$0
	call	_RTC_UninitUse
$LN56@ContextDir:
	cmp	DWORD PTR type$[rsp], 0
	je	$LN13@ContextDir

; 195  :                 if ( type & typetab[j] ) {

	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN57@ContextDir
	lea	rcx, OFFSET FLAT:ContextDirective$rtcName$0
	call	_RTC_UninitUse
$LN57@ContextDir:
	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:typetab
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	ecx, DWORD PTR type$[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	$LN34@ContextDir

; 196  : 
; 197  :                     type &= ~typetab[j];

	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN58@ContextDir
	lea	rcx, OFFSET FLAT:ContextDirective$rtcName$0
	call	_RTC_UninitUse
$LN58@ContextDir:
	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:typetab
	mov	eax, DWORD PTR [rcx+rax*4]
	not	eax
	mov	ecx, DWORD PTR type$[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR $T4[rsp], 1
	mov	DWORD PTR type$[rsp], eax

; 198  : 
; 199  :                     if ( ContextFree ) {

	cmp	QWORD PTR ModuleInfo+248, 0
	je	SHORT $LN35@ContextDir

; 200  :                         curr = ContextFree;

	mov	rax, QWORD PTR ModuleInfo+248
	mov	QWORD PTR curr$[rsp], rax

; 201  :                         ContextFree = curr->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ModuleInfo+248, rax

; 202  :                     } else

	jmp	SHORT $LN36@ContextDir
$LN35@ContextDir:

; 203  :                         curr = LclAlloc( sizeof( struct context ) );

	mov	ecx, 752				; 000002f0H
	call	LclAlloc
	mov	QWORD PTR curr$[rsp], rax
$LN36@ContextDir:

; 204  : 
; 205  :                     curr->type = typetab[j];

	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:typetab
	mov	rdx, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR [rdx+8], eax

; 206  :                     curr->next = ContextStack;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+240
	mov	QWORD PTR [rax], rcx

; 207  :                     ContextStack = curr;

	mov	rax, QWORD PTR curr$[rsp]
	mov	QWORD PTR ModuleInfo+240, rax

; 208  : 
; 209  :                     switch ( typetab[j] ) {

	movsxd	rax, DWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:typetab
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR tv245[rsp], eax
	cmp	DWORD PTR tv245[rsp], 1
	je	SHORT $LN37@ContextDir
	cmp	DWORD PTR tv245[rsp], 2
	je	SHORT $LN38@ContextDir
	cmp	DWORD PTR tv245[rsp], 4
	je	$LN40@ContextDir
	cmp	DWORD PTR tv245[rsp], 8
	je	$LN41@ContextDir
	cmp	DWORD PTR tv245[rsp], 16
	je	SHORT $LN39@ContextDir
	jmp	$LN15@ContextDir
$LN37@ContextDir:

; 210  :                     case CONT_ASSUMES:
; 211  :                         GetSegAssumeTable( curr->ac.SegAssumeTable );

	mov	rax, QWORD PTR curr$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	GetSegAssumeTable

; 212  :                         GetStdAssumeTable( curr->ac.StdAssumeTable, curr->ac.type_content );

	mov	rax, QWORD PTR curr$[rsp]
	add	rax, 368				; 00000170H
	mov	rcx, QWORD PTR curr$[rsp]
	add	rcx, 112				; 00000070H
	mov	rdx, rax
	call	GetStdAssumeTable

; 213  :                         break;

	jmp	$LN15@ContextDir
$LN38@ContextDir:

; 214  :                     case CONT_RADIX:
; 215  :                         curr->rc.radix = ModuleInfo.radix;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	ecx, BYTE PTR ModuleInfo+396
	mov	BYTE PTR [rax+16], cl

; 216  :                         break;

	jmp	$LN15@ContextDir
$LN39@ContextDir:

; 217  :                     case CONT_ALIGNMENT:
; 218  :                         curr->alc.fieldalign = ModuleInfo.fieldalign;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	ecx, BYTE PTR ModuleInfo+397
	mov	BYTE PTR [rax+16], cl

; 219  :                         curr->alc.procalign  = ModuleInfo.procalign;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	ecx, BYTE PTR ModuleInfo+399
	mov	BYTE PTR [rax+17], cl

; 220  :                         break;

	jmp	$LN15@ContextDir
$LN40@ContextDir:

; 221  :                     case CONT_LISTING:
; 222  :                         curr->lc.list_macro = ModuleInfo.list_macro;

	mov	rax, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR ModuleInfo+400
	mov	DWORD PTR [rax+16], ecx

; 223  :                         curr->lc.list       = ModuleInfo.list;

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	and	al, 1
	mov	rcx, QWORD PTR curr$[rsp]
	movzx	ecx, BYTE PTR [rcx+20]
	and	cl, 254					; 000000feH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR curr$[rsp]
	mov	BYTE PTR [rcx+20], al

; 224  :                         curr->lc.cref       = ModuleInfo.cref;

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 12
	and	eax, 1
	and	al, 1
	shl	al, 1
	mov	rcx, QWORD PTR curr$[rsp]
	movzx	ecx, BYTE PTR [rcx+20]
	and	cl, 253					; 000000fdH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR curr$[rsp]
	mov	BYTE PTR [rcx+20], al

; 225  :                         curr->lc.listif     = ModuleInfo.listif;

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 13
	and	eax, 1
	and	al, 1
	shl	al, 2
	mov	rcx, QWORD PTR curr$[rsp]
	movzx	ecx, BYTE PTR [rcx+20]
	and	cl, 251					; 000000fbH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR curr$[rsp]
	mov	BYTE PTR [rcx+20], al

; 226  :                         curr->lc.list_generated_code = ModuleInfo.list_generated_code;

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 14
	and	eax, 1
	and	al, 1
	shl	al, 3
	mov	rcx, QWORD PTR curr$[rsp]
	movzx	ecx, BYTE PTR [rcx+20]
	and	cl, 247					; 000000f7H
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR curr$[rsp]
	mov	BYTE PTR [rcx+20], al

; 227  :                         break;

	jmp	SHORT $LN15@ContextDir
$LN41@ContextDir:

; 228  :                     case CONT_CPU:
; 229  :                         curr->cc.cpu      = ModuleInfo.cpu;

	mov	rax, QWORD PTR curr$[rsp]
	movzx	ecx, WORD PTR ModuleInfo+388
	mov	WORD PTR [rax+16], cx

; 230  :                         curr->cc.curr_cpu = ModuleInfo.curr_cpu;

	mov	rax, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR ModuleInfo+392
	mov	DWORD PTR [rax+20], ecx
$LN15@ContextDir:
$LN34@ContextDir:

; 231  :                         break;
; 232  :                     }
; 233  :                 }
; 234  :             }

	jmp	$LN12@ContextDir
$LN13@ContextDir:
$LN23@ContextDir:

; 235  :         }
; 236  : 
; 237  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 238  :         if ( tokenarray[i].token == T_COMMA && tokenarray[i+1].token != T_FINAL )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN42@ContextDir
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN42@ContextDir

; 239  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN42@ContextDir:

; 240  :     }

	jmp	$LN2@ContextDir
$LN3@ContextDir:

; 241  : 
; 242  :     if ( tokenarray[i].token != T_FINAL || type == -1 ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN44@ContextDir
	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN59@ContextDir
	lea	rcx, OFFSET FLAT:ContextDirective$rtcName$0
	call	_RTC_UninitUse
$LN59@ContextDir:
	cmp	DWORD PTR type$[rsp], -1
	jne	SHORT $LN43@ContextDir
$LN44@ContextDir:

; 243  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@ContextDir
$LN43@ContextDir:

; 244  :     }
; 245  : 
; 246  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@ContextDir:

; 247  : }

	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
ContextDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\context.c
_TEXT	SEGMENT
i$ = 32
src$ = 40
dst$ = 48
ContextSaveState PROC

; 255  : {

$LN10:
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 256  :     int i;
; 257  :     struct context *src;
; 258  :     struct context *dst;
; 259  : 
; 260  :     for ( i = 0, src = ContextStack ; src ; i++, src = src->next );

	mov	DWORD PTR i$[rsp], 0
	mov	rax, QWORD PTR ModuleInfo+240
	mov	QWORD PTR src$[rsp], rax
	jmp	SHORT $LN4@ContextSav
$LN2@ContextSav:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR src$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR src$[rsp], rax
$LN4@ContextSav:
	cmp	QWORD PTR src$[rsp], 0
	je	SHORT $LN3@ContextSav
	jmp	SHORT $LN2@ContextSav
$LN3@ContextSav:

; 261  : 
; 262  :     if ( i ) {

	cmp	DWORD PTR i$[rsp], 0
	je	$LN8@ContextSav

; 263  :         cntSavedContexts = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR ModuleInfo+264, eax

; 264  :         SavedContexts = LclAlloc( i * sizeof( struct context ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 752				; 000002f0H
	mov	rcx, rax
	call	LclAlloc
	mov	QWORD PTR ModuleInfo+256, rax

; 265  :         DebugMsg(( "ContextSaveState: SavedContexts=%X\n", SavedContexts ));

	mov	rdx, QWORD PTR ModuleInfo+256
	lea	rcx, OFFSET FLAT:$SG10936
	call	DoDebugMsg

; 266  :         for ( src = ContextStack, dst = SavedContexts ; src ; src = src->next, dst++ ) {

	mov	rax, QWORD PTR ModuleInfo+240
	mov	QWORD PTR src$[rsp], rax
	mov	rax, QWORD PTR ModuleInfo+256
	mov	QWORD PTR dst$[rsp], rax
	jmp	SHORT $LN7@ContextSav
$LN5@ContextSav:
	mov	rax, QWORD PTR src$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR src$[rsp], rax
	mov	rax, QWORD PTR dst$[rsp]
	add	rax, 752				; 000002f0H
	mov	QWORD PTR dst$[rsp], rax
$LN7@ContextSav:
	cmp	QWORD PTR src$[rsp], 0
	je	SHORT $LN6@ContextSav

; 267  :             memcpy( dst, src, sizeof( struct context ) );

	mov	r8d, 752				; 000002f0H
	mov	rdx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	call	memcpy

; 268  :         }

	jmp	SHORT $LN5@ContextSav
$LN6@ContextSav:
$LN8@ContextSav:

; 269  :     }
; 270  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ContextSaveState ENDP
_TEXT	ENDS
END
