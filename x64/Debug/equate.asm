; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	maxintvalues
PUBLIC	minintvalues
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG11065 DB	'SetValue(%s): Phase error, enforced by alias equate', 0aH
	DB	00H
	ORG $+3
$SG11068 DB	'SetValue(%s): Phase error, enforced by alias equate %X !'
	DB	'= %X', 0aH, 00H
	ORG $+2
$SG11088 DB	'CreateAssemblyTimeVariable(%s) enter', 0aH, 00H
	ORG $+2
$SG11098 DB	'CreateAssemblyTimeVariable(%s) kind=%u sym=%p state=%u', 0aH
	DB	00H
$SG11125 DB	'CreateAssemblyTimeVariable(%s) memtype=%Xh value=%d', 0aH
	DB	00H
	ORG $+3
$SG11120 DB	'CreateAssemblyTimeVariable(%s): kind=%u, value changed ('
	DB	' %d -> %d )', 0aH, 00H
	ORG $+3
$SG11145 DB	'CreateVariable(%s, %d ) enter', 0aH, 00H
	ORG $+1
$SG11189 DB	'CreateConstant(%s): simple numeric value=%I64d', 0aH, 00H
$SG11191 DB	'CreateConstant(%s): before ExpandLineItems: >%s<', 0aH, 00H
	ORG $+6
$SG11122 DB	'CreateAssemblyTimeVariable(%s): kind=%u, value changed ('
	DB	' %d -> %d )', 0aH, 00H
	ORG $+3
$SG11174 DB	'CreateConstant(%s) enter', 0aH, 00H
	ORG $+6
$SG11194 DB	'CreateConstant(%s): after ExpandLineItems: >%s<', 0aH, 00H
	ORG $+7
$SG11183 DB	'CreateConstant(%s) state=%u, mem_type=%Xh, value=%X, sym'
	DB	'bol redefinition', 0aH, 00H
	ORG $+6
$SG11210 DB	'CreateConstant(%s), CONST value changed: old=%X, new=%X', 0aH
	DB	00H
	ORG $+7
$SG11214 DB	'CreateConstant(%s), ADDR value changed: old=%X, new ofs+'
	DB	'val=%X+%X', 0aH, 00H
	ORG $+1
$SG11215 DB	'NULL', 00H
	ORG $+7
$SG11216 DB	'CreateConstant(%s): memtype=%Xh value=%I64X isproc=%u va'
	DB	'riable=%u type=%s', 0aH, 00H
	ORG $+5
$SG11217 DB	'CreateConstant(%s): calling SetTextMacro() [MI.Ofssize=%'
	DB	'u]', 0aH, 00H
	ORG $+4
$SG11227 DB	'EquDirective(%s): calling CreateConstant', 0aH, 00H
	ORG $+6
$SG11229 DB	'equate.c', 00H
_DATA	ENDS
CONST	SEGMENT
maxintvalues DQ	00000000ffffffffH
	DQ	00000000ffffffffH
	DQ	7fffffffffffffffH
minintvalues DQ	ffffffff00000000H
	DQ	ffffffff00000000H
	DQ	8000000000000000H
CONST	ENDS
PUBLIC	CreateConstant
PUBLIC	CreateVariable
PUBLIC	EqualSgnDirective
PUBLIC	EquDirective
EXTRN	strcpy:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	SymCreate:PROC
EXTRN	SymFind:PROC
EXTRN	sym_remove_table:PROC
EXTRN	sym_ext2int:PROC
EXTRN	EvalOperand:PROC
EXTRN	EmitConstError:PROC
EXTRN	ExpandLineItems:PROC
EXTRN	SetTextMacro:PROC
EXTRN	StoreLine:PROC
EXTRN	SaveVariableState:PROC
EXTRN	LstWrite:PROC
EXTRN	BackPatch:PROC
EXTRN	InternalError:PROC
EXTRN	myatoi128:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SymTables:BYTE
EXTRN	StoreState:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$CreateConstant DD imagerel $LN39
	DD	imagerel $LN39+1903
	DD	imagerel $unwind$CreateConstant
$pdata$CreateVariable DD imagerel $LN9
	DD	imagerel $LN9+419
	DD	imagerel $unwind$CreateVariable
$pdata$SetValue DD imagerel SetValue
	DD	imagerel SetValue+659
	DD	imagerel $unwind$SetValue
$pdata$CreateAssemblyTimeVariable DD imagerel CreateAssemblyTimeVariable
	DD	imagerel CreateAssemblyTimeVariable+1403
	DD	imagerel $unwind$CreateAssemblyTimeVariable
$pdata$EqualSgnDirective DD imagerel $LN6
	DD	imagerel $LN6+138
	DD	imagerel $unwind$EqualSgnDirective
$pdata$EquDirective DD imagerel $LN8
	DD	imagerel $LN8+214
	DD	imagerel $unwind$EquDirective
pdata	ENDS
xdata	SEGMENT
$unwind$CreateConstant DD 021e19H
	DD	0a3010cH
	DD	imagerel __GSHandlerCheck
	DD	0500H
$unwind$CreateVariable DD 010d01H
	DD	0620dH
$unwind$SetValue DD 010e01H
	DD	0620eH
$unwind$CreateAssemblyTimeVariable DD 020c01H
	DD	01b010cH
$unwind$EqualSgnDirective DD 010d01H
	DD	0620dH
$unwind$EquDirective DD 010d01H
	DD	0620dH
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\equate.c
_TEXT	SEGMENT
tv88 = 32
sym$ = 40
i$ = 64
tokenarray$ = 72
EquDirective PROC

; 513  : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 514  :     struct asym *sym;
; 515  : 
; 516  :     if( tokenarray[0].token != T_ID ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN2@EquDirecti

; 517  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@EquDirecti
$LN2@EquDirecti:

; 518  :     }
; 519  :     DebugMsg1(("EquDirective(%s): calling CreateConstant\n", tokenarray[0].string_ptr ));

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	lea	rcx, OFFSET FLAT:$SG11227
	call	DoDebugMsg1

; 520  :     if ( sym = CreateConstant( tokenarray ) ) {

	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	CreateConstant
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN3@EquDirecti

; 521  :         /**/myassert( sym->state == SYM_INTERNAL ); /* must not be a text macro */

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 1
	jne	SHORT $LN6@EquDirecti
	mov	DWORD PTR tv88[rsp], 0
	jmp	SHORT $LN7@EquDirecti
$LN6@EquDirecti:
	mov	edx, 521				; 00000209H
	lea	rcx, OFFSET FLAT:$SG11229
	call	InternalError
	mov	DWORD PTR tv88[rsp], eax
$LN7@EquDirecti:

; 522  :         if ( ModuleInfo.list == TRUE ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN4@EquDirecti

; 523  :             LstWrite( LSTTYPE_EQUATE, 0, sym );

	mov	r8, QWORD PTR sym$[rsp]
	xor	edx, edx
	mov	ecx, 2
	call	LstWrite
$LN4@EquDirecti:

; 524  :         }
; 525  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@EquDirecti
$LN3@EquDirecti:

; 526  :     }
; 527  :     return( ERROR );

	mov	eax, -1
$LN1@EquDirecti:

; 528  : }

	add	rsp, 56					; 00000038H
	ret	0
EquDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\equate.c
_TEXT	SEGMENT
sym$ = 32
i$ = 64
tokenarray$ = 72
EqualSgnDirective PROC

; 258  : {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 259  :     struct asym *sym;
; 260  : 
; 261  :     if( tokenarray[0].token != T_ID ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN2@EqualSgnDi

; 262  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@EqualSgnDi
$LN2@EqualSgnDi:

; 263  :     }
; 264  :     if ( sym = CreateAssemblyTimeVariable( tokenarray ) ) {

	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	CreateAssemblyTimeVariable
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN3@EqualSgnDi

; 265  :         if ( ModuleInfo.list == TRUE ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 11
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN4@EqualSgnDi

; 266  :             LstWrite( LSTTYPE_EQUATE, 0, sym );

	mov	r8, QWORD PTR sym$[rsp]
	xor	edx, edx
	mov	ecx, 2
	call	LstWrite
$LN4@EqualSgnDi:

; 267  :         }
; 268  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@EqualSgnDi
$LN3@EqualSgnDi:

; 269  :     }
; 270  :     return( ERROR );

	mov	eax, -1
$LN1@EqualSgnDi:

; 271  : }

	add	rsp, 56					; 00000038H
	ret	0
EqualSgnDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\equate.c
_TEXT	SEGMENT
sym$ = 48
i$ = 56
name$ = 64
tv166 = 72
opnd$ = 80
tv92 = 192
tokenarray$ = 224
CreateAssemblyTimeVariable PROC

; 128  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 216				; 000000d8H

; 129  :     struct asym         *sym;
; 130  :     const char          *name = tokenarray[0].string_ptr;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR name$[rsp], rax

; 131  :     int                 i = 2;

	mov	DWORD PTR i$[rsp], 2

; 132  :     struct expr         opnd;
; 133  : 
; 134  :     DebugMsg1(( "CreateAssemblyTimeVariable(%s) enter\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11088
	call	DoDebugMsg1

; 135  : 
; 136  :     /* v2.08: for plain numbers ALWAYS avoid to call evaluator */
; 137  :     if ( tokenarray[2].token == T_NUM &&

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 10
	jne	$LN2@CreateAsse
	mov	eax, 32					; 00000020H
	imul	rax, rax, 3
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	$LN2@CreateAsse

; 138  :         //tokenarray[3].token == T_FINAL &&
; 139  :         //tokenarray[2].itemlen <= 8 ) {
; 140  :         tokenarray[3].token == T_FINAL ) {
; 141  :         //opnd.llvalue = tokenarray[2].value64;
; 142  :         //opnd.llvalue = *(uint_64 *)(tokenarray[2].string_ptr - sizeof(uint_64) );
; 143  :         myatoi128( tokenarray[i].string_ptr, &opnd.llvalue, tokenarray[i].numbase, tokenarray[i].itemlen );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR tokenarray$[rsp]
	movsx	ecx, BYTE PTR [rdx+rcx+1]
	movsxd	rdx, DWORD PTR i$[rsp]
	imul	rdx, rdx, 32				; 00000020H
	mov	QWORD PTR tv92[rsp], rdx
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	r9d, DWORD PTR [r8+rax+16]
	mov	r8d, ecx
	lea	rdx, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR tv92[rsp]
	mov	rcx, QWORD PTR [rax+rcx+8]
	call	myatoi128
$check_number$38:

; 144  :     check_number:
; 145  :         opnd.kind = EXPR_CONST;

	mov	DWORD PTR opnd$[rsp+60], 0

; 146  :         opnd.mem_type = MT_EMPTY; /* v2.07: added */

	mov	DWORD PTR opnd$[rsp+64], 192		; 000000c0H

; 147  :         /* v2.08: check added. the number must be 32-bit */
; 148  :         if ( opnd.hlvalue != 0 ||
; 149  :             opnd.value64 < minintvalues[ModuleInfo.Ofssize] ||

	cmp	QWORD PTR opnd$[rsp+8], 0
	jne	SHORT $LN5@CreateAsse
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:minintvalues
	mov	rax, QWORD PTR [rcx+rax*8]
	cmp	QWORD PTR opnd$[rsp], rax
	jl	SHORT $LN5@CreateAsse
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:maxintvalues
	mov	rax, QWORD PTR [rcx+rax*8]
	cmp	QWORD PTR opnd$[rsp], rax
	jle	SHORT $LN4@CreateAsse
$LN5@CreateAsse:

; 150  :             opnd.value64 > maxintvalues[ModuleInfo.Ofssize] ) {
; 151  :             EmitConstError( &opnd );

	lea	rcx, QWORD PTR opnd$[rsp]
	call	EmitConstError

; 152  :             return( NULL );

	xor	eax, eax
	jmp	$LN1@CreateAsse
$LN4@CreateAsse:

; 153  :         }
; 154  :     } else {

	jmp	$LN3@CreateAsse
$LN2@CreateAsse:

; 155  :         /* v2.09: don't create not-(yet)-defined symbols. Example:
; 156  :          * E1 = E1 or 1
; 157  :          * must NOT create E1.
; 158  :          */
; 159  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opnd, 0 ) == ERROR )

	mov	BYTE PTR [rsp+32], 0
	lea	r9, QWORD PTR opnd$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN6@CreateAsse

; 160  :             return( NULL );

	xor	eax, eax
	jmp	$LN1@CreateAsse
$LN6@CreateAsse:

; 161  :         if( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN7@CreateAsse

; 162  :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 163  :             return( NULL );

	xor	eax, eax
	jmp	$LN1@CreateAsse
$LN7@CreateAsse:

; 164  :         }
; 165  : 
; 166  :         /* expression may be a constant or a relocatable item.
; 167  :          * v2.09: kind may be EXPR_CONST and still include an undefined symbol.
; 168  :          * This is caused by MakeConst() in expreval.c. Brackets changed so
; 169  :          * opnd.sym is also checked for opnd.kind == EXPR_CONST.
; 170  :          */
; 171  :         if( opnd.kind != EXPR_CONST &&
; 172  :            ( opnd.kind != EXPR_ADDR || opnd.indirect == TRUE ) ||

	cmp	DWORD PTR opnd$[rsp+60], 0
	je	SHORT $LN10@CreateAsse
	cmp	DWORD PTR opnd$[rsp+60], 1
	jne	SHORT $LN9@CreateAsse
	mov	eax, DWORD PTR opnd$[rsp+72]
	and	eax, 1
	cmp	eax, 1
	je	SHORT $LN9@CreateAsse
$LN10@CreateAsse:
	cmp	QWORD PTR opnd$[rsp+80], 0
	je	$LN8@CreateAsse
	mov	rax, QWORD PTR opnd$[rsp+80]
	cmp	DWORD PTR [rax+40], 1
	je	$LN8@CreateAsse
$LN9@CreateAsse:

; 173  :             ( opnd.sym != NULL && opnd.sym->state != SYM_INTERNAL ) ) {
; 174  :             DebugMsg(( "CreateAssemblyTimeVariable(%s) kind=%u sym=%p state=%u\n", name, opnd.kind, opnd.sym, opnd.sym ? opnd.sym->state : 0 ));

	cmp	QWORD PTR opnd$[rsp+80], 0
	je	SHORT $LN36@CreateAsse
	mov	rax, QWORD PTR opnd$[rsp+80]
	mov	eax, DWORD PTR [rax+40]
	mov	DWORD PTR tv166[rsp], eax
	jmp	SHORT $LN37@CreateAsse
$LN36@CreateAsse:
	mov	DWORD PTR tv166[rsp], 0
$LN37@CreateAsse:
	mov	eax, DWORD PTR tv166[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR opnd$[rsp+80]
	mov	r8d, DWORD PTR opnd$[rsp+60]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11098
	call	DoDebugMsg

; 175  :             /* v2.09: no error if argument is a forward reference,
; 176  :              * but don't create the variable either. Will enforce an
; 177  :              * error if referenced symbol is still undefined in pass 2.
; 178  :              */
; 179  :             if( opnd.sym && opnd.sym->state == SYM_UNDEFINED && opnd.indirect == FALSE ) {

	cmp	QWORD PTR opnd$[rsp+80], 0
	je	SHORT $LN11@CreateAsse
	mov	rax, QWORD PTR opnd$[rsp+80]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN11@CreateAsse
	mov	eax, DWORD PTR opnd$[rsp+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN11@CreateAsse

; 180  : #if FASTPASS
; 181  :                 if ( StoreState == FALSE ) FStoreLine(0); /* make sure this line is evaluated in pass two */

	movzx	eax, BYTE PTR StoreState
	test	eax, eax
	jne	SHORT $LN13@CreateAsse
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN14@CreateAsse
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR ModuleInfo+464
	call	StoreLine
$LN14@CreateAsse:
$LN13@CreateAsse:

; 182  : #endif
; 183  :             } else

	jmp	SHORT $LN12@CreateAsse
$LN11@CreateAsse:

; 184  :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError
$LN12@CreateAsse:

; 185  :             return( NULL );

	xor	eax, eax
	jmp	$LN1@CreateAsse
$LN8@CreateAsse:

; 186  :         }
; 187  : 
; 188  :         /* v2.08: accept any result that fits in 64-bits from expression evaluator */
; 189  :         if ( opnd.hlvalue != 0 ) {

	cmp	QWORD PTR opnd$[rsp+8], 0
	je	SHORT $LN16@CreateAsse

; 190  :             EmitConstError( &opnd );

	lea	rcx, QWORD PTR opnd$[rsp]
	call	EmitConstError

; 191  :             return( NULL );

	xor	eax, eax
	jmp	$LN1@CreateAsse
$LN16@CreateAsse:

; 192  :         }
; 193  :         /* for quoted strings, the same restrictions as for plain numbers apply */
; 194  :         if ( opnd.quoted_string )

	cmp	QWORD PTR opnd$[rsp+16], 0
	je	SHORT $LN17@CreateAsse

; 195  :             goto check_number;

	jmp	$check_number$38
$LN17@CreateAsse:
$LN3@CreateAsse:

; 196  :     }
; 197  : 
; 198  :     sym = SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 199  :     if( sym == NULL || sym->state == SYM_UNDEFINED ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN20@CreateAsse
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN18@CreateAsse
$LN20@CreateAsse:

; 200  :         if( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN21@CreateAsse

; 201  :             sym = SymCreate( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymCreate
	mov	QWORD PTR sym$[rsp], rax

; 202  :         } else {

	jmp	SHORT $LN22@CreateAsse
$LN21@CreateAsse:

; 203  :             sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_remove_table

; 204  :             sym->fwdref = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+49]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+49], al
$LN22@CreateAsse:

; 205  :         }
; 206  :         //sym->variable  = TRUE;
; 207  : #if FASTPASS
; 208  :         sym->issaved = StoreState; /* v2.10: added */

	movzx	eax, BYTE PTR StoreState
	and	al, 1
	shl	al, 4
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+49]
	and	cl, 239					; 000000efH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+49], al
	jmp	$LN19@CreateAsse
$LN18@CreateAsse:

; 209  : #endif
; 210  :     //} else if ( sym->state == SYM_EXTERNAL && sym->weak == TRUE && sym->mem_type == MT_ABS ) {
; 211  :     } else if ( sym->state == SYM_EXTERNAL && sym->weak == TRUE && sym->mem_type == MT_EMPTY ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 2
	jne	SHORT $LN23@CreateAsse
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN23@CreateAsse
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+44], 192			; 000000c0H
	jne	SHORT $LN23@CreateAsse

; 212  :         sym_ext2int( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	sym_ext2int

; 213  :         //sym->variable  = TRUE;
; 214  : #if FASTPASS
; 215  :         sym->issaved = StoreState; /* v2.10: added */

	movzx	eax, BYTE PTR StoreState
	and	al, 1
	shl	al, 4
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+49]
	and	cl, 239					; 000000efH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+49], al

; 216  : #endif
; 217  :     } else {

	jmp	$LN24@CreateAsse
$LN23@CreateAsse:

; 218  :         if ( sym->state != SYM_INTERNAL ||

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 1
	jne	SHORT $LN26@CreateAsse
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN25@CreateAsse
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR opnd$[rsp], eax
	jne	SHORT $LN27@CreateAsse
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+64]
	cmp	DWORD PTR opnd$[rsp+4], eax
	je	SHORT $LN25@CreateAsse
$LN27@CreateAsse:
$LN26@CreateAsse:

; 219  :             ( sym->variable == FALSE &&
; 220  :              ( opnd.uvalue != sym->uvalue || opnd.hvalue != sym->value3264 ) ) ) {
; 221  :             EmitErr( SYMBOL_REDEFINITION, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 222  :             return( NULL );

	xor	eax, eax
	jmp	$LN1@CreateAsse
$LN25@CreateAsse:

; 223  :         }
; 224  : #if FASTPASS
; 225  :         /* v2.04a regression in v2.04. Do not save the variable when it
; 226  :          * is defined the first time
; 227  :          * v2.10: store state only when variable is changed and has been
; 228  :          * defined BEFORE SaveState() has been called.
; 229  :          */
; 230  :         //if ( StoreState && sym->issaved == FALSE && sym->isdefined == TRUE ) {
; 231  :         if ( StoreState && sym->issaved == FALSE ) {

	movzx	eax, BYTE PTR StoreState
	test	eax, eax
	je	SHORT $LN28@CreateAsse
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+49]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN28@CreateAsse

; 232  :             SaveVariableState( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	SaveVariableState
$LN28@CreateAsse:
$LN24@CreateAsse:
$LN19@CreateAsse:

; 233  :         }
; 234  : #endif
; 235  :     }
; 236  :     sym->variable = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+48], al

; 237  : #ifdef DEBUG_OUT
; 238  :     if ( Parse_Pass > PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jbe	$LN29@CreateAsse

; 239  :         if ( opnd.kind == EXPR_CONST && sym->uvalue != opnd.uvalue )

	cmp	DWORD PTR opnd$[rsp+60], 0
	jne	SHORT $LN30@CreateAsse
	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+16], ecx
	je	SHORT $LN30@CreateAsse

; 240  :             DebugMsg1(( "CreateAssemblyTimeVariable(%s): kind=%u, value changed ( %d -> %d )\n", name, opnd.kind, sym->uvalue, opnd.uvalue ) );

	mov	eax, DWORD PTR opnd$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+16]
	mov	r8d, DWORD PTR opnd$[rsp+60]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11120
	call	DoDebugMsg1
	jmp	SHORT $LN31@CreateAsse
$LN30@CreateAsse:

; 241  :         else if ( opnd.kind == EXPR_ADDR && sym->uvalue != ( opnd.uvalue + opnd.sym->uvalue ) )

	cmp	DWORD PTR opnd$[rsp+60], 1
	jne	SHORT $LN32@CreateAsse
	mov	rax, QWORD PTR opnd$[rsp+80]
	mov	eax, DWORD PTR [rax+16]
	mov	ecx, DWORD PTR opnd$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rcx+16], eax
	je	SHORT $LN32@CreateAsse

; 242  :             DebugMsg1(( "CreateAssemblyTimeVariable(%s): kind=%u, value changed ( %d -> %d )\n", name, opnd.kind, sym->uvalue, opnd.uvalue + opnd.sym->uvalue ) );

	mov	rax, QWORD PTR opnd$[rsp+80]
	mov	eax, DWORD PTR [rax+16]
	mov	ecx, DWORD PTR opnd$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+16]
	mov	r8d, DWORD PTR opnd$[rsp+60]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11122
	call	DoDebugMsg1
$LN32@CreateAsse:
$LN31@CreateAsse:
$LN29@CreateAsse:

; 243  :     }
; 244  : #endif
; 245  :     /* v2.09: allow internal variables to be set */
; 246  :     if ( sym->predefined && sym->sfunc_ptr )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN33@CreateAsse
	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+72], 0
	je	SHORT $LN33@CreateAsse

; 247  :         sym->sfunc_ptr( sym, &opnd );

	lea	rdx, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	call	QWORD PTR [rax+72]
	jmp	SHORT $LN34@CreateAsse
$LN33@CreateAsse:

; 248  :     else
; 249  :         SetValue( sym, &opnd );

	lea	rdx, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	SetValue
$LN34@CreateAsse:

; 250  :     DebugMsg1(( "CreateAssemblyTimeVariable(%s) memtype=%Xh value=%d\n", name, sym->mem_type, sym->value ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+16]
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+44]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11125
	call	DoDebugMsg1

; 251  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]
$LN1@CreateAsse:

; 252  : }

	add	rsp, 216				; 000000d8H
	ret	0
CreateAssemblyTimeVariable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\equate.c
_TEXT	SEGMENT
dir$1 = 32
sym$ = 64
opndx$ = 72
SetValue PROC

; 58   : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 59   : 
; 60   :     sym->isequate = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	or	al, 16
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+48], al

; 61   :     sym->state = SYM_INTERNAL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+40], 1

; 62   :     sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+48], al

; 63   :     if ( opndx->kind == EXPR_CONST ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rax+60], 0
	jne	SHORT $LN2@SetValue

; 64   :         /* v2.07: use expression's memtype */
; 65   :         //sym->mem_type = MT_ABS;
; 66   :         sym->mem_type = opndx->mem_type;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+44], ecx

; 67   :         sym->uvalue = opndx->uvalue;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+16], ecx

; 68   :         sym->value3264 = opndx->hvalue;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	mov	DWORD PTR [rax+64], ecx

; 69   :         sym->segment = NULL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+32], 0

; 70   :         sym->isproc = FALSE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+49]
	and	al, 247					; 000000f7H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+49], al

; 71   :     } else {

	jmp	$LN3@SetValue
$LN2@SetValue:

; 72   :         sym->isproc = opndx->sym->isproc;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	movzx	eax, BYTE PTR [rax+49]
	shr	al, 3
	and	al, 1
	and	al, 1
	shl	al, 3
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+49]
	and	cl, 247					; 000000f7H
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+49], al

; 73   :         /* for a PROC alias, copy the procinfo extension! */
; 74   :         if ( sym->isproc ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+49]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@SetValue

; 75   :             struct dsym *dir = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR dir$1[rsp], rax

; 76   :             dir->e.procinfo = ((struct dsym *)opndx->sym)->e.procinfo;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR dir$1[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR [rcx+104], rax
$LN4@SetValue:

; 77   :         }
; 78   :         sym->mem_type = opndx->mem_type;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rcx+64]
	mov	DWORD PTR [rax+44], ecx

; 79   :         /* v2.01: allow equates of variables with arbitrary type.
; 80   :          * Currently the expression evaluator sets opndx.mem_type
; 81   :          * to the mem_type of the type (i.e. QWORD for a struct with size 8),
; 82   :          * which is a bad idea in this case. So the original mem_type of the
; 83   :          * label is used instead.
; 84   :          */
; 85   :         if ( opndx->sym->mem_type == MT_TYPE && opndx->explicit == FALSE ) {

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	cmp	DWORD PTR [rax+44], 196			; 000000c4H
	jne	SHORT $LN5@SetValue
	mov	rax, QWORD PTR opndx$[rsp]
	mov	eax, DWORD PTR [rax+72]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN5@SetValue

; 86   :             sym->mem_type = opndx->sym->mem_type;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+44]
	mov	DWORD PTR [rcx+44], eax

; 87   :             sym->type = opndx->sym->type;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR [rcx+88], rax
$LN5@SetValue:

; 88   :         }
; 89   :         sym->value3264 = 0; /* v2.09: added */

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+64], 0

; 90   :         sym->segment = opndx->sym->segment;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR [rcx+32], rax

; 91   : #if 1 /* v2.10: added */
; 92   :         /* labels are supposed to be added to the current segment's label_list chain.
; 93   :          * this isn't done for alias equates, for various reasons.
; 94   :          * consequently, if the alias was forward referenced, ensure that a third pass
; 95   :          * will be done! regression test forward5.asm.
; 96   :          */
; 97   :         if ( sym->variable ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@SetValue

; 98   :             sym->offset = opndx->sym->offset + opndx->value;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR opndx$[rsp]
	add	eax, DWORD PTR [rcx]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 99   :             if ( Parse_Pass == PASS_2 && sym->fwdref ) {

	cmp	DWORD PTR Parse_Pass, 1
	jne	SHORT $LN8@SetValue
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+49]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@SetValue

; 100  : #ifdef DEBUG_OUT
; 101  :                 if ( !ModuleInfo.PhaseError )

	movzx	eax, BYTE PTR ModuleInfo+422
	test	eax, eax
	jne	SHORT $LN9@SetValue

; 102  :                     DebugMsg(("SetValue(%s): Phase error, enforced by alias equate\n", sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11065
	call	DoDebugMsg
$LN9@SetValue:

; 103  : #endif
; 104  :                 ModuleInfo.PhaseError = TRUE;

	mov	BYTE PTR ModuleInfo+422, 1
$LN8@SetValue:

; 105  :             }
; 106  :         } else {

	jmp	$LN7@SetValue
$LN6@SetValue:

; 107  :             if( Parse_Pass != PASS_1 && sym->offset != ( opndx->sym->offset + opndx->value ) ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN10@SetValue
	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR opndx$[rsp]
	add	eax, DWORD PTR [rcx]
	mov	rcx, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rcx+16], eax
	je	SHORT $LN10@SetValue

; 108  : #ifdef DEBUG_OUT
; 109  :                 if ( !ModuleInfo.PhaseError )

	movzx	eax, BYTE PTR ModuleInfo+422
	test	eax, eax
	jne	SHORT $LN11@SetValue

; 110  :                     DebugMsg1(("SetValue(%s): Phase error, enforced by alias equate %" I32_SPEC "X != %" I32_SPEC "X\n", sym->name, sym->offset, opndx->sym->offset + opndx->value ));

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR opndx$[rsp]
	add	eax, DWORD PTR [rcx]
	mov	r9d, eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+16]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11068
	call	DoDebugMsg1
$LN11@SetValue:

; 111  : #endif
; 112  :                 ModuleInfo.PhaseError = TRUE;

	mov	BYTE PTR ModuleInfo+422, 1
$LN10@SetValue:

; 113  :             }
; 114  :             sym->offset = opndx->sym->offset + opndx->value;

	mov	rax, QWORD PTR opndx$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	eax, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR opndx$[rsp]
	add	eax, DWORD PTR [rcx]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 115  :             BackPatch( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	BackPatch
$LN7@SetValue:
$LN3@SetValue:

; 116  :         }
; 117  : #endif
; 118  :     }
; 119  :     return;
; 120  : }

	add	rsp, 56					; 00000038H
	ret	0
SetValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\equate.c
_TEXT	SEGMENT
sym$ = 32
name$ = 64
value$ = 72
CreateVariable PROC

; 280  : {

$LN9:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 281  : 	struct asym      *sym;
; 282  : 
; 283  : 	DebugMsg1(("CreateVariable(%s, %d ) enter\n", name, value));

	mov	r8d, DWORD PTR value$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11145
	call	DoDebugMsg1

; 284  : 
; 285  : 	sym = SymSearch(name);

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 286  : 	if (sym == NULL) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN2@CreateVari

; 287  : 		sym = SymCreate(name);

	mov	rcx, QWORD PTR name$[rsp]
	call	SymCreate
	mov	QWORD PTR sym$[rsp], rax

; 288  : #if FASTPASS
; 289  : 		//sym->issaved = FALSE;
; 290  : 		sym->issaved = StoreState; /* v2.10 */

	movzx	eax, BYTE PTR StoreState
	and	al, 1
	shl	al, 4
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+49]
	and	cl, 239					; 000000efH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+49], al

; 291  : #endif
; 292  : 	}

	jmp	$LN3@CreateVari
$LN2@CreateVari:

; 293  : 	else if (sym->state == SYM_UNDEFINED) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN4@CreateVari

; 294  : 		sym->value3264 = 0;   //fixed by HSE on qWord indication

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+64], 0

; 295  : 		sym_remove_table(&SymTables[TAB_UNDEF], (struct dsym *)sym);

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_remove_table

; 296  : 		sym->fwdref = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+49]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+49], al

; 297  : #if FASTPASS
; 298  : 		sym->issaved = StoreState; /* v2.10 */

	movzx	eax, BYTE PTR StoreState
	and	al, 1
	shl	al, 4
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+49]
	and	cl, 239					; 000000efH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+49], al

; 299  : #endif
; 300  : 	}

	jmp	SHORT $LN5@CreateVari
$LN4@CreateVari:

; 301  : 	else {
; 302  : 		sym->value3264 = 0;  //fixed by HSE on qWord indication

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+64], 0

; 303  : 		if (sym->isequate == FALSE) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@CreateVari

; 304  : 			EmitErr(SYMBOL_REDEFINITION, name);

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 305  : 			return(NULL);

	xor	eax, eax
	jmp	$LN1@CreateVari
$LN6@CreateVari:

; 306  : 		}
; 307  : #if FASTPASS
; 308  : 		/*
; 309  : 		* v2.09: don't save variable when it is defined the first time
; 310  : 		* v2.10: store state only when variable is changed and has been
; 311  : 		* defined BEFORE SaveState() has been called.
; 312  : 		*/
; 313  : 		//if ( StoreState && sym->issaved == FALSE && sym->isdefined == TRUE ) {
; 314  : 		if (StoreState && sym->issaved == FALSE) {

	movzx	eax, BYTE PTR StoreState
	test	eax, eax
	je	SHORT $LN7@CreateVari
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+49]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@CreateVari

; 315  : 			SaveVariableState(sym);

	mov	rcx, QWORD PTR sym$[rsp]
	call	SaveVariableState
$LN7@CreateVari:
$LN5@CreateVari:
$LN3@CreateVari:

; 316  : 		}
; 317  : #endif
; 318  : 	}
; 319  : 	sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+48], al

; 320  : 	sym->state = SYM_INTERNAL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+40], 1

; 321  : 	//sym->mem_type = MT_ABS;
; 322  : 	sym->variable = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+48], al

; 323  : 	sym->value = value;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 324  : 	sym->isequate = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	or	al, 16
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+48], al

; 325  : 	return(sym);

	mov	rax, QWORD PTR sym$[rsp]
$LN1@CreateVari:

; 326  : }

	add	rsp, 56					; 00000038H
	ret	0
CreateVariable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\equate.c
_TEXT	SEGMENT
sym$ = 64
cmpvalue$ = 72
name$ = 80
i$ = 88
p$ = 96
rc$ = 104
tv310 = 112
opnd$ = 128
tv182 = 240
argbuffer$ = 256
__$ArrayPad$ = 1280
tokenarray$ = 1312
CreateConstant PROC

; 344  : {

$LN39:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1304				; 00000518H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 345  :     struct asym         *sym;
; 346  :     const char          *name = tokenarray[0].string_ptr;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR name$[rsp], rax

; 347  :     int                 i = 2;

	mov	DWORD PTR i$[rsp], 2

; 348  :     ret_code            rc;
; 349  :     char                *p;
; 350  :     bool                cmpvalue = FALSE;

	mov	BYTE PTR cmpvalue$[rsp], 0

; 351  :     struct expr         opnd;
; 352  :     char                argbuffer[MAX_LINE_LEN];
; 353  : 
; 354  :     DebugMsg1(( "CreateConstant(%s) enter\n", name ));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11174
	call	DoDebugMsg1

; 355  : 
; 356  :     sym = SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 357  : 
; 358  :     /* if a literal follows, the equate MUST be(come) a text macro */
; 359  :     if ( tokenarray[2].token == T_STRING && tokenarray[2].string_delim == '<' )

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 9
	jne	SHORT $LN2@CreateCons
	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+1]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN2@CreateCons

; 360  :         return ( SetTextMacro( tokenarray, sym, name, NULL ) );

	xor	r9d, r9d
	mov	r8, QWORD PTR name$[rsp]
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	SetTextMacro
	jmp	$LN1@CreateCons
$LN2@CreateCons:

; 361  : 
; 362  :     if( sym == NULL ||
; 363  :        sym->state == SYM_UNDEFINED ||

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN5@CreateCons
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 0
	je	SHORT $LN5@CreateCons
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 2
	jne	SHORT $LN3@CreateCons
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN3@CreateCons
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+49]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@CreateCons
$LN5@CreateCons:

; 364  :        ( sym->state == SYM_EXTERNAL && sym->weak == TRUE && sym->isproc == FALSE ) ) {
; 365  :         /* It's a "new" equate.
; 366  :          * wait with definition until type of equate is clear
; 367  :          */
; 368  :     } else if( sym->state == SYM_TMACRO ) {

	jmp	$LN4@CreateCons
$LN3@CreateCons:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 10
	jne	SHORT $LN6@CreateCons

; 369  : 
; 370  :         return ( SetTextMacro( tokenarray, sym, name, tokenarray[2].tokpos ) );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r9, QWORD PTR [rcx+rax+24]
	mov	r8, QWORD PTR name$[rsp]
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	SetTextMacro
	jmp	$LN1@CreateCons
	jmp	$LN7@CreateCons
$LN6@CreateCons:

; 371  : 
; 372  :     } else if( sym->isequate == FALSE ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@CreateCons

; 373  : 
; 374  :         DebugMsg1(( "CreateConstant(%s) state=%u, mem_type=%Xh, value=%" I32_SPEC "X, symbol redefinition\n", name, sym->state, sym->mem_type, sym->value));

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR sym$[rsp]
	mov	r9d, DWORD PTR [rax+44]
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+40]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11183
	call	DoDebugMsg1

; 375  :         EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 376  :         return( NULL );

	xor	eax, eax
	jmp	$LN1@CreateCons

; 377  : 
; 378  :     } else {

	jmp	SHORT $LN9@CreateCons
$LN8@CreateCons:

; 379  :         if ( sym->asmpass == ( Parse_Pass & 0xFF ) )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+54]
	mov	ecx, DWORD PTR Parse_Pass
	and	ecx, 255				; 000000ffH
	cmp	eax, ecx
	jne	SHORT $LN10@CreateCons

; 380  :             cmpvalue = TRUE;

	mov	BYTE PTR cmpvalue$[rsp], 1
$LN10@CreateCons:

; 381  :         sym->asmpass = Parse_Pass;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR Parse_Pass
	mov	BYTE PTR [rax+54], cl
$LN9@CreateCons:
$LN7@CreateCons:
$LN4@CreateCons:

; 382  :     }
; 383  : 
; 384  :     /* try to evaluate the expression */
; 385  : 
; 386  :     if ( tokenarray[2].token == T_NUM && Token_Count == 3 ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 10
	jne	$LN11@CreateCons
	cmp	DWORD PTR ModuleInfo+496, 3
	jne	$LN11@CreateCons

; 387  : 
; 388  :         p = tokenarray[2].string_ptr;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR p$[rsp], rax
$do_single_number$40:

; 389  :     do_single_number:
; 390  :         /* value is a plain number. it will be accepted only if it fits into 32-bits.
; 391  :          * Else a text macro is created.
; 392  :          */
; 393  :         myatoi128( tokenarray[2].string_ptr, &opnd.llvalue, tokenarray[2].numbase, tokenarray[2].itemlen );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	ecx, 32					; 00000020H
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR tokenarray$[rsp]
	movsx	ecx, BYTE PTR [rdx+rcx+1]
	mov	edx, 32					; 00000020H
	imul	rdx, rdx, 2
	mov	QWORD PTR tv182[rsp], rdx
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	r9d, DWORD PTR [r8+rax+16]
	mov	r8d, ecx
	lea	rdx, QWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR tv182[rsp]
	mov	rcx, QWORD PTR [rax+rcx+8]
	call	myatoi128
$check_single_number$41:

; 394  :     check_single_number:
; 395  :         opnd.instr = EMPTY;

	mov	DWORD PTR opnd$[rsp+56], -2

; 396  :         opnd.kind = EXPR_CONST;

	mov	DWORD PTR opnd$[rsp+60], 0

; 397  :         opnd.mem_type = MT_EMPTY; /* v2.07: added */

	mov	DWORD PTR opnd$[rsp+64], 192		; 000000c0H

; 398  :         opnd.flags1 = 0;

	mov	BYTE PTR opnd$[rsp+72], 0

; 399  :         /* v2.08: does it fit in 32-bits */
; 400  :         if ( opnd.hlvalue == 0 && opnd.value64 >= minintvalues[ModuleInfo.Ofssize] &&

	cmp	QWORD PTR opnd$[rsp+8], 0
	jne	SHORT $LN13@CreateCons
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:minintvalues
	mov	rax, QWORD PTR [rcx+rax*8]
	cmp	QWORD PTR opnd$[rsp], rax
	jl	SHORT $LN13@CreateCons
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:maxintvalues
	mov	rax, QWORD PTR [rcx+rax*8]
	cmp	QWORD PTR opnd$[rsp], rax
	jg	SHORT $LN13@CreateCons

; 401  :             opnd.value64 <= maxintvalues[ModuleInfo.Ofssize] ) {
; 402  :             rc = NOT_ERROR;

	mov	DWORD PTR rc$[rsp], 0

; 403  :             DebugMsg1(( "CreateConstant(%s): simple numeric value=%" I64_SPEC "d\n", name, opnd.value64 ));

	mov	r8, QWORD PTR opnd$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11189
	call	DoDebugMsg1

; 404  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 405  :         } else

	jmp	SHORT $LN14@CreateCons
$LN13@CreateCons:

; 406  :             return ( SetTextMacro( tokenarray, sym, name, p ) );

	mov	r9, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR name$[rsp]
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	SetTextMacro
	jmp	$LN1@CreateCons
$LN14@CreateCons:

; 407  : 
; 408  :     } else {

	jmp	$LN12@CreateCons
$LN11@CreateCons:

; 409  :         p = tokenarray[2].tokpos;

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR p$[rsp], rax

; 410  :         if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN15@CreateCons

; 411  :             /* if the expression cannot be evaluated to a numeric value,
; 412  :              * it's to become a text macro. The value of this macro will be
; 413  :              * the original (unexpanded!) line - that's why it has to be
; 414  :              * saved here to argbuffer[].
; 415  :              */
; 416  :             strcpy( argbuffer, p );

	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, QWORD PTR argbuffer$[rsp]
	call	strcpy

; 417  :             DebugMsg1(("CreateConstant(%s): before ExpandLineItems: >%s<\n", name, p ));

	mov	r8, QWORD PTR p$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11191
	call	DoDebugMsg1

; 418  :             /* expand EQU argument (macro functions won't be expanded!) */
; 419  :             if ( ExpandLineItems( p, 2, tokenarray, FALSE, TRUE ) )

	mov	DWORD PTR [rsp+32], 1
	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, 2
	mov	rcx, QWORD PTR p$[rsp]
	call	ExpandLineItems
	test	eax, eax
	je	SHORT $LN16@CreateCons

; 420  :                 /* v2.08: if expansion result is a plain number, handle is specifically.
; 421  :                  * this is necessary because values of expressions may be 64-bit now.
; 422  :                  */
; 423  :                 p = argbuffer; /* ensure that p points to unexpanded source */

	lea	rax, QWORD PTR argbuffer$[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN16@CreateCons:

; 424  :                 if ( tokenarray[2].token == T_NUM && Token_Count == 3 ) {

	mov	eax, 32					; 00000020H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 10
	jne	SHORT $LN17@CreateCons
	cmp	DWORD PTR ModuleInfo+496, 3
	jne	SHORT $LN17@CreateCons

; 425  :                     goto do_single_number;

	jmp	$do_single_number$40
$LN17@CreateCons:

; 426  :                 }
; 427  :             DebugMsg1(("CreateConstant(%s): after ExpandLineItems: >%s<\n", name, p ));

	mov	r8, QWORD PTR p$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11194
	call	DoDebugMsg1
$LN15@CreateCons:

; 428  :         }
; 429  :         rc = EvalOperand( &i, tokenarray, Token_Count, &opnd, EXPF_NOERRMSG | EXPF_NOUNDEF );

	mov	BYTE PTR [rsp+32], 3
	lea	r9, QWORD PTR opnd$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	mov	DWORD PTR rc$[rsp], eax

; 430  : 
; 431  :         /* v2.08: if it's a quoted string, handle it like a plain number */
; 432  :         /* v2.10: quoted_string field is != 0 if kind == EXPR_FLOAT,
; 433  :          * so this is a regression in v2.08-2.09.
; 434  :          */
; 435  :         if ( opnd.quoted_string && opnd.kind == EXPR_CONST ) {

	cmp	QWORD PTR opnd$[rsp+16], 0
	je	SHORT $LN18@CreateCons
	cmp	DWORD PTR opnd$[rsp+60], 0
	jne	SHORT $LN18@CreateCons

; 436  :             i--; /* v2.09: added; regression in v2.08 and v2.08a */

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax

; 437  :             goto check_single_number;

	jmp	$check_single_number$41
$LN18@CreateCons:
$LN12@CreateCons:

; 438  :         }
; 439  : 
; 440  :         /* check here if last token has been reached? */
; 441  :     }
; 442  :     /* what is an acceptable 'number' for EQU?
; 443  :      * 1. a numeric value - if magnitude is <= 64 (or 32, if it's a plain number)
; 444  :      *    This includes struct fields.
; 445  :      * 2. an address - if it is direct, has a label and is of type SYM_INTERNAL -
; 446  :      *    that is, no forward references, no seg, groups, externals;
; 447  :      *    Anything else will be stored as a text macro.
; 448  :      * v2.04: large parts rewritten.
; 449  :      */
; 450  :     if ( rc != ERROR &&
; 451  :         tokenarray[i].token == T_FINAL &&
; 452  :         ( ( opnd.kind == EXPR_CONST && opnd.hlvalue == 0 ) || /* magnitude <= 64 bits? */
; 453  :          ( opnd.kind == EXPR_ADDR && opnd.indirect == FALSE &&
; 454  :           opnd.sym != NULL &&
; 455  :           //opnd.sym->state != SYM_EXTERNAL ) ) && /* SYM_SEG, SYM_GROUP are also not ok */
; 456  :           opnd.sym->state == SYM_INTERNAL ) ) &&

	cmp	DWORD PTR rc$[rsp], -1
	je	$LN19@CreateCons
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	$LN19@CreateCons
	cmp	DWORD PTR opnd$[rsp+60], 0
	jne	SHORT $LN21@CreateCons
	cmp	QWORD PTR opnd$[rsp+8], 0
	je	SHORT $LN20@CreateCons
$LN21@CreateCons:
	cmp	DWORD PTR opnd$[rsp+60], 1
	jne	$LN19@CreateCons
	mov	eax, DWORD PTR opnd$[rsp+72]
	and	eax, 1
	test	eax, eax
	jne	$LN19@CreateCons
	cmp	QWORD PTR opnd$[rsp+80], 0
	je	$LN19@CreateCons
	mov	rax, QWORD PTR opnd$[rsp+80]
	cmp	DWORD PTR [rax+40], 1
	jne	$LN19@CreateCons
$LN20@CreateCons:
	cmp	DWORD PTR opnd$[rsp+56], -2
	jne	$LN19@CreateCons

; 457  :         ( opnd.instr == EMPTY ) ) {
; 458  : 
; 459  :         if ( !sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN22@CreateCons

; 460  :             sym = SymCreate( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymCreate
	mov	QWORD PTR sym$[rsp], rax

; 461  :             sym->asmpass = Parse_Pass;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR Parse_Pass
	mov	BYTE PTR [rax+54], cl
	jmp	$LN23@CreateCons
$LN22@CreateCons:

; 462  :         } else if ( sym->state == SYM_UNDEFINED ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN24@CreateCons

; 463  :             sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_remove_table

; 464  :             sym->fwdref = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+49]
	or	al, 32					; 00000020H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+49], al
	jmp	$LN25@CreateCons
$LN24@CreateCons:

; 465  :         } else if ( sym->state == SYM_EXTERNAL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+40], 2
	jne	SHORT $LN26@CreateCons

; 466  :             sym_ext2int( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	sym_ext2int
	jmp	$LN27@CreateCons
$LN26@CreateCons:

; 467  :         } else if ( cmpvalue ) {

	movzx	eax, BYTE PTR cmpvalue$[rsp]
	test	eax, eax
	je	$LN28@CreateCons

; 468  :             if ( opnd.kind == EXPR_CONST ) {

	cmp	DWORD PTR opnd$[rsp+60], 0
	jne	SHORT $LN29@CreateCons

; 469  :                 /* for 64bit, it may be necessary to check 64bit value! */
; 470  :                 /* v2.08: always compare 64-bit values */
; 471  :                 //if ( sym->value != opnd.value ) {
; 472  :                 if ( sym->value != opnd.value || sym->value3264 != opnd.hvalue ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rax+16], ecx
	jne	SHORT $LN32@CreateCons
	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR opnd$[rsp+4]
	cmp	DWORD PTR [rax+64], ecx
	je	SHORT $LN31@CreateCons
$LN32@CreateCons:

; 473  :                     DebugMsg(("CreateConstant(%s), CONST value changed: old=%X, new=%X\n", name, sym->offset, opnd.value ));

	mov	r9d, DWORD PTR opnd$[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+16]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11210
	call	DoDebugMsg

; 474  :                     EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 475  :                     return( NULL );

	xor	eax, eax
	jmp	$LN1@CreateCons
$LN31@CreateCons:

; 476  :                 }

	jmp	$LN30@CreateCons
$LN29@CreateCons:

; 477  :             } else if ( opnd.kind == EXPR_ADDR ) {

	cmp	DWORD PTR opnd$[rsp+60], 1
	jne	SHORT $LN33@CreateCons

; 478  :                 if ( ( sym->offset != ( opnd.sym->offset + opnd.value ) ) || ( sym->segment != opnd.sym->segment ) ) {

	mov	rax, QWORD PTR opnd$[rsp+80]
	mov	eax, DWORD PTR [rax+16]
	add	eax, DWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rcx+16], eax
	jne	SHORT $LN35@CreateCons
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR opnd$[rsp+80]
	mov	rcx, QWORD PTR [rcx+32]
	cmp	QWORD PTR [rax+32], rcx
	je	SHORT $LN34@CreateCons
$LN35@CreateCons:

; 479  :                     DebugMsg(("CreateConstant(%s), ADDR value changed: old=%X, new ofs+val=%X+%X\n", name, sym->offset, opnd.sym->offset, opnd.value));

	mov	eax, DWORD PTR opnd$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR opnd$[rsp+80]
	mov	r9d, DWORD PTR [rax+16]
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+16]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11214
	call	DoDebugMsg

; 480  :                     EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 481  :                     return( NULL );

	xor	eax, eax
	jmp	$LN1@CreateCons
$LN34@CreateCons:
$LN33@CreateCons:
$LN30@CreateCons:
$LN28@CreateCons:
$LN27@CreateCons:
$LN25@CreateCons:
$LN23@CreateCons:

; 482  :                 }
; 483  :             }
; 484  :         }
; 485  :         /* change from alias to number is ok if value (=offset) won't change!
; 486  :          * memtype must not be checked!
; 487  :          */
; 488  :         //if ( opnd.kind == EXPR_CONST ) {
; 489  :         //    if ( sym->mem_type != MT_ABS && sym->mem_type != MT_EMPTY ) {
; 490  :         //        EmitErr( SYMBOL_REDEFINITION, name );
; 491  :         //        return( NULL );
; 492  :         //    }
; 493  :         //}
; 494  :         sym->variable = FALSE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	and	al, 191					; 000000bfH
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+48], al

; 495  :         SetValue( sym, &opnd );

	lea	rdx, QWORD PTR opnd$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	SetValue

; 496  :         DebugMsg1(("CreateConstant(%s): memtype=%Xh value=%" I64_SPEC "X isproc=%u variable=%u type=%s\n",

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN37@CreateCons
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv310[rsp], rax
	jmp	SHORT $LN38@CreateCons
$LN37@CreateCons:
	lea	rax, OFFSET FLAT:$SG11215
	mov	QWORD PTR tv310[rsp], rax
$LN38@CreateCons:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+49]
	shr	cl, 3
	and	cl, 1
	movzx	ecx, cl
	mov	rdx, QWORD PTR sym$[rsp]
	movsxd	rdx, DWORD PTR [rdx+16]
	mov	r8, QWORD PTR sym$[rsp]
	movsxd	r8, DWORD PTR [r8+64]
	shl	r8, 32					; 00000020H
	add	rdx, r8
	mov	r8, QWORD PTR tv310[rsp]
	mov	QWORD PTR [rsp+48], r8
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], ecx
	mov	r9, rdx
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+44]
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11216
	call	DoDebugMsg1

; 497  :             name, sym->mem_type, (uint_64)sym->value + ( (uint_64)sym->value3264 << 32), sym->isproc, sym->variable, sym->type ? sym->type->name : "NULL" ));
; 498  :         return( sym );

	mov	rax, QWORD PTR sym$[rsp]
	jmp	SHORT $LN1@CreateCons
$LN19@CreateCons:

; 499  :     }
; 500  :     DebugMsg1(("CreateConstant(%s): calling SetTextMacro() [MI.Ofssize=%u]\n", name, ModuleInfo.Ofssize ));

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	r8d, eax
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG11217
	call	DoDebugMsg1

; 501  :     return ( SetTextMacro( tokenarray, sym, name, argbuffer ) );

	lea	r9, QWORD PTR argbuffer$[rsp]
	mov	r8, QWORD PTR name$[rsp]
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	SetTextMacro
$LN1@CreateCons:

; 502  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1304				; 00000518H
	ret	0
CreateConstant ENDP
_TEXT	ENDS
END
