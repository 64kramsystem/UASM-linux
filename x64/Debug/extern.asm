; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG10803 DB	'NULL', 00H
	ORG $+3
$SG10804 DB	'CreateProto( i=%u, name=%s, lang=%u )', 0aH, 00H
	ORG $+1
$SG10847 DB	'ExterndefDirective(%u) enter', 0aH, 00H
	ORG $+2
$SG10852 DB	'ABS', 00H
$SG10974 DB	')', 00H
	ORG $+2
$SG10861 DB	'ExterndefDirective(%s): memtype=%X set, ofssize=%X', 0aH
	DB	00H
	ORG $+4
$SG10875 DB	'ExterndefDirective: type conflict for %s. mem_types old-'
	DB	'new: %X-%X', 0aH, 00H
$SG10978 DB	'ABS', 00H
$SG10877 DB	'ExterndefDirective(%s): types differ: %X (%s) - %X (%s)', 0aH
	DB	00H
	ORG $+7
$SG10937 DB	'HandleAltname: symbol ''%s'' found, state=%u', 0aH, 00H
	ORG $+12
$SG10879 DB	'ExterndefDirective(%s): type conflict old-new: %X (%s) -'
	DB	' %X (%s)', 0aH, 00H
	ORG $+6
$SG10969 DB	'ExternDirective(%u) enter', 0aH, 00H
	ORG $+5
$SG10981 DB	'ExternDirective(%s): CreateProto()=%X', 0aH, 00H
	ORG $+1
$SG10987 DB	'ExternDirective(%s): mem_type=%Xh', 0aH, 00H
	ORG $+5
$SG10993 DB	'ExternDirective(%s): prototype copied, memtype=%X', 0aH, 00H
	ORG $+5
$SG10997 DB	'ExternDirective: symbol %s redefinition, state=%u', 0aH, 00H
	ORG $+13
$SG11002 DB	'ExternDirective: memtype:%X-%X ptr=%X-%X far=%X-%X ptr_m'
	DB	'emtype=%X-%X lang=%u-%u', 0aH, 00H
	ORG $+7
$SG11054 DB	'CommDirective(%u) enter', 0aH, 00H
	ORG $+7
$SG11091 DB	'AddPublicData(%s)', 0aH, 00H
	ORG $+5
$SG11114 DB	'PublicDirective(%u) enter', 0aH, 00H
	ORG $+5
$SG11116 DB	'PublicDirective: sym=%s', 0aH, 00H
	ORG $+7
$SG11122 DB	'PublicDirective(%s): new symbol', 0aH, 00H
_DATA	ENDS
CONST	SEGMENT
szCOMM	DB	'COMM', 00H
CONST	ENDS
PUBLIC	MakeExtern
PUBLIC	AddPublicData
PUBLIC	FreePubQueue
PUBLIC	ExterndefDirective
PUBLIC	ProtoDirective
PUBLIC	ExternDirective
PUBLIC	CommDirective
PUBLIC	PublicDirective
EXTRN	__imp__stricmp:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	EmitWarn:PROC
EXTRN	QAddItem:PROC
EXTRN	SymCreate:PROC
EXTRN	SymFind:PROC
EXTRN	MemtypeFromSize:PROC
EXTRN	GetLangType:PROC
EXTRN	sym_add_table:PROC
EXTRN	sym_remove_table:PROC
EXTRN	SetMangler:PROC
EXTRN	EvalOperand:PROC
EXTRN	EmitConstError:PROC
EXTRN	GetQualifiedType:PROC
EXTRN	ParseProc:PROC
EXTRN	CreateProc:PROC
EXTRN	CopyPrototype:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	_RTC_UninitUse:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	SymTables:BYTE
EXTRN	__ImageBase:BYTE
pdata	SEGMENT
$pdata$MakeExtern DD imagerel $LN8
	DD	imagerel $LN8+219
	DD	imagerel $unwind$MakeExtern
$pdata$AddPublicData DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$AddPublicData
$pdata$FreePubQueue DD imagerel $LN3
	DD	imagerel $LN3+15
	DD	imagerel $unwind$FreePubQueue
$pdata$CreateExternal DD imagerel CreateExternal
	DD	imagerel CreateExternal+258
	DD	imagerel $unwind$CreateExternal
$pdata$CreateComm DD imagerel CreateComm
	DD	imagerel CreateComm+256
	DD	imagerel $unwind$CreateComm
$pdata$CreateProto DD imagerel CreateProto
	DD	imagerel CreateProto+565
	DD	imagerel $unwind$CreateProto
$pdata$ExterndefDirective DD imagerel $LN47
	DD	imagerel $LN47+1970
	DD	imagerel $unwind$ExterndefDirective
$pdata$ProtoDirective DD imagerel $LN8
	DD	imagerel $LN8+236
	DD	imagerel $unwind$ProtoDirective
$pdata$HandleAltname DD imagerel HandleAltname
	DD	imagerel HandleAltname+513
	DD	imagerel $unwind$HandleAltname
$pdata$ExternDirective DD imagerel $LN45
	DD	imagerel $LN45+2469
	DD	imagerel $unwind$ExternDirective
$pdata$MakeComm DD imagerel MakeComm
	DD	imagerel MakeComm+263
	DD	imagerel $unwind$MakeComm
$pdata$CommDirective DD imagerel $LN45
	DD	imagerel $LN45+1356
	DD	imagerel $unwind$CommDirective
$pdata$PublicDirective DD imagerel $LN32
	DD	imagerel $LN32+867
	DD	imagerel $unwind$PublicDirective
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
	ORG $+3
ExterndefDirective$rtcName$0 DB 06cH
	DB	061H
	DB	06eH
	DB	067H
	DB	074H
	DB	079H
	DB	070H
	DB	065H
	DB	00H
	ORG $+3
ExterndefDirective$rtcName$1 DB 074H
	DB	069H
	DB	00H
	ORG $+1
ExterndefDirective$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:ExterndefDirective$rtcVarDesc
ExternDirective$rtcName$1 DB 074H
	DB	069H
	DB	00H
	ORG $+5
ExterndefDirective$rtcVarDesc DD 068H
	DD	020H
	DQ	FLAT:ExterndefDirective$rtcName$1
	DD	044H
	DD	04H
	DQ	FLAT:ExterndefDirective$rtcName$0
	ORG $+96
ExternDirective$rtcName$0 DB 06cH
	DB	061H
	DB	06eH
	DB	067H
	DB	074H
	DB	079H
	DB	070H
	DB	065H
	DB	00H
	ORG $+7
ExternDirective$rtcVarDesc DD 0a8H
	DD	020H
	DQ	FLAT:ExternDirective$rtcName$1
	DD	084H
	DD	04H
	DQ	FLAT:ExternDirective$rtcName$0
	ORG $+96
ExternDirective$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:ExternDirective$rtcVarDesc
CommDirective$rtcName$0 DB 06fH
	DB	070H
	DB	06eH
	DB	064H
	DB	078H
	DB	00H
	ORG $+2
CommDirective$rtcName$1 DB 06cH
	DB	061H
	DB	06eH
	DB	067H
	DB	074H
	DB	079H
	DB	070H
	DB	065H
	DB	00H
	ORG $+7
CommDirective$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:CommDirective$rtcVarDesc
	ORG $+8
CommDirective$rtcVarDesc DD 0e4H
	DD	04H
	DQ	FLAT:CommDirective$rtcName$1
	DD	060H
	DD	068H
	DQ	FLAT:CommDirective$rtcName$0
	ORG $+96
PublicDirective$rtcName$0 DB 073H
	DB	06bH
	DB	069H
	DB	070H
	DB	069H
	DB	074H
	DB	065H
	DB	06dH
	DB	00H
	ORG $+7
PublicDirective$rtcName$1 DB 06cH
	DB	061H
	DB	06eH
	DB	067H
	DB	074H
	DB	079H
	DB	070H
	DB	065H
	DB	00H
	ORG $+7
PublicDirective$rtcVarDesc DD 044H
	DD	04H
	DQ	FLAT:PublicDirective$rtcName$1
	ORG $+48
PublicDirective$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:PublicDirective$rtcVarDesc
CONST	ENDS
xdata	SEGMENT
$unwind$MakeExtern DD 022c01H
	DD	070143218H
$unwind$AddPublicData DD 021e01H
	DD	07006320aH
$unwind$FreePubQueue DD 010201H
	DD	07002H
$unwind$CreateExternal DD 022801H
	DD	070103214H
$unwind$CreateComm DD 022301H
	DD	0700b320fH
$unwind$CreateProto DD 022b01H
	DD	070149218H
$unwind$ExterndefDirective DD 032701H
	DD	0160111H
	DD	0700aH
$unwind$ProtoDirective DD 022101H
	DD	0700a520eH
$unwind$HandleAltname DD 022301H
	DD	0700b520fH
$unwind$ExternDirective DD 032701H
	DD	01e0111H
	DD	0700aH
$unwind$MakeComm DD 022d01H
	DD	070153219H
$unwind$CommDirective DD 032701H
	DD	0200111H
	DD	0700aH
$unwind$PublicDirective DD 022101H
	DD	0700ab20eH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
token$ = 32
sym$ = 40
skipitem$ = 48
langtype$ = 68
$T5 = 84
tv143 = 88
i$ = 112
tokenarray$ = 120
PublicDirective PROC

; 888  : {

$LN32:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rdi, rsp
	mov	ecx, 24
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+112]
	mov	BYTE PTR $T5[rsp], 0

; 889  : #if MANGLERSUPP
; 890  :     char                *mangle_type = NULL;
; 891  : #endif
; 892  :     char                *token;
; 893  :     struct asym         *sym;
; 894  :     //struct dsym       *dir;
; 895  :     char                skipitem;
; 896  :     enum lang_type      langtype;
; 897  : 
; 898  :     DebugMsg1(("PublicDirective(%u) enter\n", i));

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11114
	call	DoDebugMsg1

; 899  :     i++; /* skip PUBLIC directive */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@PublicDire:

; 900  : #if MANGLERSUPP
; 901  :     mangle_type = Check4Mangler( &i, tokenarray );
; 902  : #endif
; 903  :     do {
; 904  : 
; 905  :         /* read the optional language type */
; 906  :         langtype = ModuleInfo.langtype;

	mov	eax, DWORD PTR ModuleInfo+364
	mov	DWORD PTR langtype$[rsp], eax

; 907  :         GetLangType( &i, tokenarray, &langtype );

	lea	r8, QWORD PTR langtype$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	GetLangType

; 908  : 
; 909  :         if ( tokenarray[i].token != T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN7@PublicDire

; 910  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@PublicDire
$LN7@PublicDire:

; 911  :         }
; 912  :         /* get the symbol name */
; 913  :         token = tokenarray[i++].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR token$[rsp], rax
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 914  : 
; 915  :         DebugMsg1(("PublicDirective: sym=%s\n", token ));

	mov	rdx, QWORD PTR token$[rsp]
	lea	rcx, OFFSET FLAT:$SG11116
	call	DoDebugMsg1

; 916  : 
; 917  :         /* Add the public name */
; 918  :         sym = SymSearch( token );

	mov	rcx, QWORD PTR token$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 919  :         if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN8@PublicDire

; 920  :             if ( sym == NULL ) {

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN10@PublicDire

; 921  :                 if ( sym = SymCreate( token ) ) {

	mov	rcx, QWORD PTR token$[rsp]
	call	SymCreate
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN11@PublicDire

; 922  :                     sym_add_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_add_table

; 923  :                     DebugMsg1(("PublicDirective(%s): new symbol\n", sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11122
	call	DoDebugMsg1

; 924  :                 } else

	jmp	SHORT $LN12@PublicDire
$LN11@PublicDire:

; 925  :                     return( ERROR ); /* name was too long */

	mov	eax, -1
	jmp	$LN1@PublicDire
$LN12@PublicDire:
$LN10@PublicDire:

; 926  :             }
; 927  :             skipitem = FALSE;

	mov	BYTE PTR $T5[rsp], 1
	mov	BYTE PTR skipitem$[rsp], 0

; 928  :         } else {

	jmp	SHORT $LN9@PublicDire
$LN8@PublicDire:

; 929  :             if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN14@PublicDire
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN13@PublicDire
$LN14@PublicDire:

; 930  :                 EmitErr( SYMBOL_NOT_DEFINED, token );

	mov	rdx, QWORD PTR token$[rsp]
	mov	ecx, 102				; 00000066H
	call	EmitErr
$LN13@PublicDire:
$LN9@PublicDire:

; 931  :                 //return( ERROR ); /* v2.04: dont exit */
; 932  :             }
; 933  :         }
; 934  :         if ( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN15@PublicDire

; 935  :             switch ( sym->state ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv143[rsp], eax
	cmp	DWORD PTR tv143[rsp], 0
	je	SHORT $LN16@PublicDire
	cmp	DWORD PTR tv143[rsp], 1
	je	SHORT $LN17@PublicDire
	cmp	DWORD PTR tv143[rsp], 2
	je	SHORT $LN19@PublicDire
	jmp	$LN23@PublicDire
$LN16@PublicDire:

; 936  :             case SYM_UNDEFINED:
; 937  :                 break;

	jmp	$LN5@PublicDire
$LN17@PublicDire:

; 938  :             case SYM_INTERNAL:
; 939  :                 if ( sym->scoped == TRUE ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN18@PublicDire

; 940  :                     EmitErr( CANNOT_DECLARE_SCOPED_CODE_LABEL_AS_PUBLIC, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 180				; 000000b4H
	call	EmitErr

; 941  :                     skipitem = TRUE;

	mov	BYTE PTR $T5[rsp], 1
	mov	BYTE PTR skipitem$[rsp], 1
$LN18@PublicDire:

; 942  :                     //return( ERROR );
; 943  :                 }
; 944  :                 break;

	jmp	$LN5@PublicDire
$LN19@PublicDire:

; 945  :             case SYM_EXTERNAL:
; 946  :                 if ( sym->iscomm == TRUE ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN20@PublicDire

; 947  :                     EmitErr( CANNOT_DEFINE_AS_PUBLIC_OR_EXTERNAL, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 174				; 000000aeH
	call	EmitErr

; 948  :                     skipitem = TRUE;

	mov	BYTE PTR $T5[rsp], 1
	mov	BYTE PTR skipitem$[rsp], 1
	jmp	SHORT $LN21@PublicDire
$LN20@PublicDire:

; 949  :                     //return( ERROR );
; 950  :                 } else if ( sym->weak == FALSE ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN22@PublicDire

; 951  :                     /* for EXTERNs, emit a different error msg */
; 952  :                     EmitErr( SYMBOL_REDEFINITION, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 953  :                     skipitem = TRUE;

	mov	BYTE PTR $T5[rsp], 1
	mov	BYTE PTR skipitem$[rsp], 1
$LN22@PublicDire:
$LN21@PublicDire:

; 954  :                     //return( ERROR );
; 955  :                 }
; 956  :                 break;

	jmp	SHORT $LN5@PublicDire
$LN23@PublicDire:

; 957  :             default:
; 958  :                 EmitErr( CANNOT_DEFINE_AS_PUBLIC_OR_EXTERNAL, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 174				; 000000aeH
	call	EmitErr

; 959  :                 skipitem = TRUE;

	mov	BYTE PTR $T5[rsp], 1
	mov	BYTE PTR skipitem$[rsp], 1
$LN5@PublicDire:

; 960  :                 //return( ERROR );
; 961  :             }
; 962  :             if( Parse_Pass == PASS_1 && skipitem == FALSE ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN24@PublicDire
	cmp	BYTE PTR $T5[rsp], 0
	jne	SHORT $LN31@PublicDire
	lea	rcx, OFFSET FLAT:PublicDirective$rtcName$0
	call	_RTC_UninitUse
$LN31@PublicDire:
	movsx	eax, BYTE PTR skipitem$[rsp]
	test	eax, eax
	jne	SHORT $LN24@PublicDire

; 963  :                 if ( sym->ispublic == FALSE ) {

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN25@PublicDire

; 964  :                     sym->ispublic = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 965  :                     AddPublicData( sym ); /* put it into the public table */

	mov	rcx, QWORD PTR sym$[rsp]
	call	AddPublicData
$LN25@PublicDire:

; 966  :                 }
; 967  :                 SetMangler( sym, langtype, mangle_type );

	xor	r8d, r8d
	mov	edx, DWORD PTR langtype$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	SetMangler
$LN24@PublicDire:
$LN15@PublicDire:

; 968  :             }
; 969  :         }
; 970  : 
; 971  :         if ( tokenarray[i].token != T_FINAL )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN26@PublicDire

; 972  :             if ( tokenarray[i].token == T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN27@PublicDire

; 973  :                 if ( (i + 1) < Token_Count )

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cmp	eax, DWORD PTR ModuleInfo+496
	jge	SHORT $LN29@PublicDire

; 974  :                     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN29@PublicDire:

; 975  :             } else {

	jmp	SHORT $LN28@PublicDire
$LN27@PublicDire:

; 976  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@PublicDire
$LN28@PublicDire:
$LN26@PublicDire:

; 977  :             }
; 978  : 
; 979  :     } while ( i < Token_Count );

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jl	$LN4@PublicDire

; 980  : 
; 981  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@PublicDire:

; 982  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:PublicDirective$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
PublicDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
token$ = 48
isfar$ = 56
tmp$ = 60
size$ = 64
count$ = 68
sym$ = 72
opndx$ = 96
langtype$ = 228
tv82 = 244
i$ = 272
tokenarray$ = 280
CommDirective PROC

; 707  : {

$LN45:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 256				; 00000100H
	mov	rdi, rsp
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+272]

; 708  :     char            *token;
; 709  : #if MANGLERSUPP
; 710  :     char            *mangle_type = NULL;
; 711  : #endif
; 712  :     bool            isfar;
; 713  :     //int             distance;
; 714  :     int             tmp;
; 715  :     uint_32         size;  /* v2.12: changed from 'int' to 'uint_32' */
; 716  :     uint_32         count; /* v2.12: changed from 'int' to 'uint_32' */
; 717  :     struct asym     *sym;
; 718  :     struct expr     opndx;
; 719  :     enum lang_type  langtype;
; 720  : 
; 721  :     DebugMsg1(("CommDirective(%u) enter\n", i));

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG11054
	call	DoDebugMsg1

; 722  :     i++; /* skip COMM token */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 723  :     for( ; i < Token_Count; i++ ) {

	jmp	SHORT $LN4@CommDirect
$LN2@CommDirect:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@CommDirect:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@CommDirect

; 724  : #if MANGLERSUPP
; 725  :         mangle_type = Check4Mangler( &i, tokenarray );
; 726  : #endif
; 727  :         /* get the symbol language type if present */
; 728  :         langtype = ModuleInfo.langtype;

	mov	eax, DWORD PTR ModuleInfo+364
	mov	DWORD PTR langtype$[rsp], eax

; 729  :         GetLangType( &i, tokenarray, &langtype );

	lea	r8, QWORD PTR langtype$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	GetLangType

; 730  : 
; 731  :         /* get the -optional- distance ( near or far ) */
; 732  :         isfar = FALSE;

	mov	BYTE PTR isfar$[rsp], 0

; 733  :         if ( tokenarray[i].token == T_STYPE )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 6
	jne	$LN10@CommDirect

; 734  :             switch ( tokenarray[i].tokval ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	DWORD PTR tv82[rsp], eax
	mov	eax, DWORD PTR tv82[rsp]
	sub	eax, 221				; 000000ddH
	mov	DWORD PTR tv82[rsp], eax
	cmp	DWORD PTR tv82[rsp], 5
	ja	SHORT $LN5@CommDirect
	mov	eax, DWORD PTR tv82[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN44@CommDirect[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN11@CommDirect:

; 735  :             case T_FAR:
; 736  :             case T_FAR16:
; 737  :             case T_FAR32:
; 738  :                 if ( ModuleInfo.model == MODEL_FLAT ) {

	cmp	DWORD PTR ModuleInfo+360, 7
	jne	SHORT $LN12@CommDirect

; 739  :                     EmitError( FAR_NOT_ALLOWED_IN_FLAT_MODEL_COMM_VARIABLES );

	mov	ecx, 176				; 000000b0H
	call	EmitError

; 740  :                 } else

	jmp	SHORT $LN13@CommDirect
$LN12@CommDirect:

; 741  :                     isfar = TRUE;

	mov	BYTE PTR isfar$[rsp], 1
$LN13@CommDirect:
$LN14@CommDirect:

; 742  :                 /* no break */
; 743  :             case T_NEAR:
; 744  :             case T_NEAR16:
; 745  :             case T_NEAR32:
; 746  :                 i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN5@CommDirect:
$LN10@CommDirect:

; 747  :             }
; 748  : 
; 749  :         /* v2.08: ensure token is a valid id */
; 750  :         if( tokenarray[i].token != T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN15@CommDirect

; 751  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@CommDirect
$LN15@CommDirect:

; 752  :         }
; 753  :         /* get the symbol name */
; 754  :         token = tokenarray[i++].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR token$[rsp], rax
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 755  : 
; 756  :         /* go past the colon */
; 757  :         if( tokenarray[i].token != T_COLON ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN16@CommDirect

; 758  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@CommDirect
$LN16@CommDirect:

; 759  :         }
; 760  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 761  :         /* the evaluator cannot handle a ':' so scan for one first */
; 762  :         for ( tmp = i; tmp < Token_Count;tmp++ )

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR tmp$[rsp], eax
	jmp	SHORT $LN9@CommDirect
$LN7@CommDirect:
	mov	eax, DWORD PTR tmp$[rsp]
	inc	eax
	mov	DWORD PTR tmp$[rsp], eax
$LN9@CommDirect:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR tmp$[rsp], eax
	jge	SHORT $LN8@CommDirect

; 763  :             if ( tokenarray[tmp].token == T_COLON )

	movsxd	rax, DWORD PTR tmp$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN17@CommDirect

; 764  :                 break;

	jmp	SHORT $LN8@CommDirect
$LN17@CommDirect:
	jmp	SHORT $LN7@CommDirect
$LN8@CommDirect:

; 765  :         /* v2.10: expression evaluator isn't to accept forward references */
; 766  :         //if ( EvalOperand( &i, tokenarray, tmp, &opndx, 0 ) == ERROR )
; 767  :         if ( EvalOperand( &i, tokenarray, tmp, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	BYTE PTR [rsp+32], 2
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR tmp$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN18@CommDirect

; 768  :             return( ERROR );

	mov	eax, -1
	jmp	$LN1@CommDirect
$LN18@CommDirect:

; 769  : 
; 770  :         /* v2.03: a string constant is accepted by Masm */
; 771  :         /* v2.11: don't accept NEAR or FAR */
; 772  :         /* v2.12: check for too large value added */
; 773  :         //if ( opndx.kind != EXPR_CONST || opndx.string != NULL ) {
; 774  :         if ( opndx.kind != EXPR_CONST )

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN19@CommDirect

; 775  :             EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	SHORT $LN20@CommDirect
$LN19@CommDirect:

; 776  :         else if ( ( opndx.mem_type & MT_SPECIAL_MASK) == MT_ADDRESS )

	mov	eax, DWORD PTR opndx$[rsp+64]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN21@CommDirect

; 777  :             EmitErr( INVALID_TYPE_FOR_DATA_DECLARATION, token );

	mov	rdx, QWORD PTR token$[rsp]
	mov	ecx, 160				; 000000a0H
	call	EmitErr
	jmp	SHORT $LN22@CommDirect
$LN21@CommDirect:

; 778  :         else if ( opndx.hvalue != 0 && opndx.hvalue != -1 )

	cmp	DWORD PTR opndx$[rsp+4], 0
	je	SHORT $LN23@CommDirect
	cmp	DWORD PTR opndx$[rsp+4], -1
	je	SHORT $LN23@CommDirect

; 779  :             EmitConstError( &opndx );

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	SHORT $LN24@CommDirect
$LN23@CommDirect:

; 780  :         else if ( opndx.uvalue == 0 )

	cmp	DWORD PTR opndx$[rsp], 0
	jne	SHORT $LN25@CommDirect

; 781  :             EmitError( POSITIVE_VALUE_EXPECTED );

	mov	ecx, 175				; 000000afH
	call	EmitError
$LN25@CommDirect:
$LN24@CommDirect:
$LN22@CommDirect:
$LN20@CommDirect:

; 782  : 
; 783  :         size = opndx.uvalue;

	mov	eax, DWORD PTR opndx$[rsp]
	mov	DWORD PTR size$[rsp], eax

; 784  : 
; 785  :         count = 1;

	mov	DWORD PTR count$[rsp], 1

; 786  :         if( tokenarray[i].token == T_COLON ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	$LN26@CommDirect

; 787  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 788  :             /* get optional count argument */
; 789  :             /* v2.10: expression evaluator isn't to accept forward references */
; 790  :             //if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )
; 791  :             if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	BYTE PTR [rsp+32], 2
	lea	r9, QWORD PTR opndx$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN27@CommDirect

; 792  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@CommDirect
$LN27@CommDirect:

; 793  : 
; 794  :             /* v2.03: a string constant is acceptable! */
; 795  :             /* v2.12: check for too large value added */
; 796  :             //if ( opndx.kind != EXPR_CONST || opndx.string != NULL ) {
; 797  :             if ( opndx.kind != EXPR_CONST )

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN28@CommDirect

; 798  :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	SHORT $LN29@CommDirect
$LN28@CommDirect:

; 799  :             else if ( opndx.hvalue != 0 && opndx.hvalue != -1 )

	cmp	DWORD PTR opndx$[rsp+4], 0
	je	SHORT $LN30@CommDirect
	cmp	DWORD PTR opndx$[rsp+4], -1
	je	SHORT $LN30@CommDirect

; 800  :                 EmitConstError( &opndx );

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	SHORT $LN31@CommDirect
$LN30@CommDirect:

; 801  :             else if ( opndx.uvalue == 0 )

	cmp	DWORD PTR opndx$[rsp], 0
	jne	SHORT $LN32@CommDirect

; 802  :                 EmitError( POSITIVE_VALUE_EXPECTED );

	mov	ecx, 175				; 000000afH
	call	EmitError
$LN32@CommDirect:
$LN31@CommDirect:
$LN29@CommDirect:

; 803  : 
; 804  :             count = opndx.uvalue;

	mov	eax, DWORD PTR opndx$[rsp]
	mov	DWORD PTR count$[rsp], eax
$LN26@CommDirect:

; 805  :         }
; 806  : 
; 807  :         sym = SymSearch( token );

	mov	rcx, QWORD PTR token$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 808  :         if( sym == NULL || sym->state == SYM_UNDEFINED ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN35@CommDirect
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN33@CommDirect
$LN35@CommDirect:

; 809  :             sym = MakeComm( token, sym, size, count, isfar );

	movzx	eax, BYTE PTR isfar$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR count$[rsp]
	mov	r8d, DWORD PTR size$[rsp]
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR token$[rsp]
	call	MakeComm
	mov	QWORD PTR sym$[rsp], rax

; 810  :             if ( sym == NULL )

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN36@CommDirect

; 811  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@CommDirect
$LN36@CommDirect:

; 812  :         } else if ( sym->state != SYM_EXTERNAL || sym->iscomm != TRUE ) {

	jmp	$LN34@CommDirect
$LN33@CommDirect:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN39@CommDirect
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	je	SHORT $LN37@CommDirect
$LN39@CommDirect:

; 813  :             return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@CommDirect

; 814  :         } else {

	jmp	SHORT $LN38@CommDirect
$LN37@CommDirect:

; 815  :             tmp = sym->total_size / sym->total_length;

	xor	edx, edx
	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	rcx, QWORD PTR sym$[rsp]
	div	DWORD PTR [rcx+64]
	mov	DWORD PTR tmp$[rsp], eax

; 816  :             if( count != sym->total_length || size != tmp ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+64]
	cmp	DWORD PTR count$[rsp], eax
	jne	SHORT $LN41@CommDirect
	mov	eax, DWORD PTR tmp$[rsp]
	cmp	DWORD PTR size$[rsp], eax
	je	SHORT $LN40@CommDirect
$LN41@CommDirect:

; 817  :                 return( EmitErr( NON_BENIGN_XXX_REDEFINITION, szCOMM, sym->name ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	lea	rdx, OFFSET FLAT:szCOMM
	mov	ecx, 139				; 0000008bH
	call	EmitErr
	jmp	$LN1@CommDirect
$LN40@CommDirect:
$LN38@CommDirect:
$LN34@CommDirect:

; 818  :             }
; 819  :         }
; 820  :         sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 821  :         SetMangler( sym, langtype, mangle_type );

	xor	r8d, r8d
	mov	edx, DWORD PTR langtype$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	SetMangler

; 822  : 
; 823  :         if ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN42@CommDirect
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN42@CommDirect

; 824  :             return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	SHORT $LN1@CommDirect
$LN42@CommDirect:

; 825  :         }
; 826  :     }

	jmp	$LN2@CommDirect
$LN3@CommDirect:

; 827  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@CommDirect:

; 828  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:CommDirective$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 256				; 00000100H
	pop	rdi
	ret	0
	npad	3
$LN44@CommDirect:
	DD	$LN14@CommDirect
	DD	$LN11@CommDirect
	DD	$LN14@CommDirect
	DD	$LN14@CommDirect
	DD	$LN11@CommDirect
	DD	$LN11@CommDirect
CommDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
name$ = 48
sym$ = 56
size$ = 64
count$ = 72
isfar$ = 80
MakeComm PROC

; 674  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 675  :     sym = CreateComm( sym, name );

	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateComm
	mov	QWORD PTR sym$[rsp], rax

; 676  :     if( sym == NULL )

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN2@MakeComm

; 677  :         return( NULL );

	xor	eax, eax
	jmp	$LN1@MakeComm
$LN2@MakeComm:

; 678  : 
; 679  :     sym->total_length = count;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR count$[rsp]
	mov	DWORD PTR [rax+64], ecx

; 680  :     sym->isfar = isfar;

	movzx	eax, BYTE PTR isfar$[rsp]
	and	al, 1
	shl	al, 4
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 239					; 000000efH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 681  : 
; 682  :     /* v2.04: don't set segment if communal is far and -Zg is set */
; 683  :     if ( Options.masm_compat_gencode == FALSE || isfar == FALSE )

	movzx	eax, BYTE PTR Options+144
	test	eax, eax
	je	SHORT $LN4@MakeComm
	movzx	eax, BYTE PTR isfar$[rsp]
	test	eax, eax
	jne	SHORT $LN3@MakeComm
$LN4@MakeComm:

; 684  :         sym->segment = &CurrSeg->sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+24], rax
$LN3@MakeComm:

; 685  : 
; 686  :     MemtypeFromSize( size, &sym->mem_type );

	mov	rax, QWORD PTR sym$[rsp]
	add	rax, 36					; 00000024H
	mov	rdx, rax
	mov	ecx, DWORD PTR size$[rsp]
	call	MemtypeFromSize

; 687  : 
; 688  :     /* v2.04: warning added ( Masm emits an error ) */
; 689  :     /* v2.05: code active for 16-bit only */
; 690  :     if ( ModuleInfo.Ofssize == USE16 )

	movzx	eax, BYTE PTR ModuleInfo+404
	test	eax, eax
	jne	SHORT $LN5@MakeComm

; 691  :         if ( ( count * size ) > 0x10000UL )

	mov	eax, DWORD PTR count$[rsp]
	imul	eax, DWORD PTR size$[rsp]
	cmp	eax, 65536				; 00010000H
	jbe	SHORT $LN6@MakeComm

; 692  :             EmitWarn( 2, COMM_VAR_EXCEEDS_64K, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 267				; 0000010bH
	mov	ecx, 2
	call	EmitWarn
$LN6@MakeComm:
$LN5@MakeComm:

; 693  : 
; 694  :     sym->total_size = count * size;

	mov	eax, DWORD PTR count$[rsp]
	imul	eax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rcx+56], eax

; 695  : 
; 696  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]
$LN1@MakeComm:

; 697  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
MakeComm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
token$ = 96
altname$ = 104
sym$ = 112
langtype$ = 132
ti$ = 168
tv242 = 212
tv247 = 216
tv316 = 224
i$ = 256
tokenarray$ = 264
ExternDirective PROC

; 499  : {

$LN45:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 240				; 000000f0H
	mov	rdi, rsp
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+256]

; 500  :     char                *token;
; 501  : #if MANGLERSUPP
; 502  :     char                *mangle_type = NULL;
; 503  : #endif
; 504  :     char                *altname;
; 505  :     struct asym         *sym;
; 506  :     enum lang_type      langtype;
; 507  :     struct qualified_type ti;
; 508  : 
; 509  :     DebugMsg1(("ExternDirective(%u) enter\n", i));

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG10969
	call	DoDebugMsg1

; 510  :     i++; /* skip EXT[E]RN token */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@ExternDire:

; 511  : #if MANGLERSUPP
; 512  :     mangle_type = Check4Mangler( &i, tokenarray );
; 513  : #endif
; 514  :     do {
; 515  : 
; 516  :         altname = NULL;

	mov	QWORD PTR altname$[rsp], 0

; 517  : 
; 518  :         /* get the symbol language type if present */
; 519  :         langtype = ModuleInfo.langtype;

	mov	eax, DWORD PTR ModuleInfo+364
	mov	DWORD PTR langtype$[rsp], eax

; 520  :         GetLangType( &i, tokenarray, &langtype );

	lea	r8, QWORD PTR langtype$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	GetLangType

; 521  : 
; 522  :         /* get the symbol name */
; 523  :         if( tokenarray[i].token != T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN5@ExternDire

; 524  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ExternDire
$LN5@ExternDire:

; 525  :         }
; 526  :         token = tokenarray[i++].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR token$[rsp], rax
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 527  : 
; 528  :         /* go past the optional alternative name (weak ext, default resolution) */
; 529  :         if( tokenarray[i].token == T_OP_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 40					; 00000028H
	jne	$LN6@ExternDire

; 530  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 531  :             if ( tokenarray[i].token != T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN7@ExternDire

; 532  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ExternDire
$LN7@ExternDire:

; 533  :             }
; 534  :             altname = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR altname$[rsp], rax

; 535  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 536  :             if( tokenarray[i].token != T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN8@ExternDire

; 537  :                 return( EmitErr( EXPECTED, ")" ) );

	lea	rdx, OFFSET FLAT:$SG10974
	mov	ecx, 230				; 000000e6H
	call	EmitErr
	jmp	$LN1@ExternDire
$LN8@ExternDire:

; 538  :             }
; 539  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN6@ExternDire:

; 540  :         }
; 541  : 
; 542  :         /* go past the colon */
; 543  :         if( tokenarray[i].token != T_COLON ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN9@ExternDire

; 544  :             return( EmitError( COLON_EXPECTED ) );

	mov	ecx, 84					; 00000054H
	call	EmitError
	jmp	$LN1@ExternDire
$LN9@ExternDire:

; 545  :         }
; 546  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 547  :         sym = SymSearch( token );

	mov	rcx, QWORD PTR token$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 548  : 
; 549  :         ti.mem_type = MT_EMPTY;

	mov	DWORD PTR ti$[rsp+16], 192		; 000000c0H

; 550  :         ti.size = 0;

	mov	DWORD PTR ti$[rsp], 0

; 551  :         ti.is_ptr = 0;

	mov	BYTE PTR ti$[rsp+20], 0

; 552  :         ti.is_far = FALSE;

	mov	BYTE PTR ti$[rsp+21], 0

; 553  :         ti.ptr_memtype = MT_EMPTY;

	mov	DWORD PTR ti$[rsp+24], 192		; 000000c0H

; 554  :         ti.symtype = NULL;

	mov	QWORD PTR ti$[rsp+8], 0

; 555  :         ti.Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	BYTE PTR ti$[rsp+22], al

; 556  : 
; 557  :         if ( tokenarray[i].token == T_ID && ( 0 == _stricmp( tokenarray[i].string_ptr, "ABS" ) ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN10@ExternDire
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG10978
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN10@ExternDire

; 558  :             //ti.mem_type = MT_ABS;
; 559  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	$LN11@ExternDire
$LN10@ExternDire:

; 560  :         } else if ( tokenarray[i].token == T_DIRECTIVE && tokenarray[i].tokval == T_PROTO ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	$LN12@ExternDire
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 427		; 000001abH
	jne	$LN12@ExternDire

; 561  :             /* dont scan this line further */
; 562  :             /* CreateProto() will define a SYM_EXTERNAL */
; 563  :             sym = CreateProto( i + 1, tokenarray, token, langtype );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	r9d, DWORD PTR langtype$[rsp]
	mov	r8, QWORD PTR token$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, eax
	call	CreateProto
	mov	QWORD PTR sym$[rsp], rax

; 564  :             DebugMsg1(("ExternDirective(%s): CreateProto()=%X\n", token, sym));

	mov	r8, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR token$[rsp]
	lea	rcx, OFFSET FLAT:$SG10981
	call	DoDebugMsg1

; 565  :             if ( sym == NULL )

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN14@ExternDire

; 566  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExternDire
$LN14@ExternDire:

; 567  :             if ( sym->state == SYM_EXTERNAL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN15@ExternDire

; 568  :                 sym->weak = FALSE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	and	al, 247					; 000000f7H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 569  :                 return( HandleAltname( altname, sym ) );

	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR altname$[rsp]
	call	HandleAltname
	jmp	$LN1@ExternDire

; 570  :             } else {

	jmp	SHORT $LN16@ExternDire
$LN15@ExternDire:

; 571  :                 /* unlike EXTERNDEF, EXTERN doesn't allow a PROC for the same name */
; 572  :                 return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@ExternDire
$LN16@ExternDire:

; 573  :             }

	jmp	SHORT $LN13@ExternDire
$LN12@ExternDire:

; 574  :         } else if ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN17@ExternDire
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN17@ExternDire

; 575  :             if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	GetQualifiedType
	cmp	eax, -1
	jne	SHORT $LN18@ExternDire

; 576  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExternDire
$LN18@ExternDire:
$LN17@ExternDire:
$LN13@ExternDire:
$LN11@ExternDire:

; 577  :         }
; 578  : 
; 579  :         DebugMsg1(("ExternDirective(%s): mem_type=%Xh\n", token, ti.mem_type ));

	mov	r8d, DWORD PTR ti$[rsp+16]
	mov	rdx, QWORD PTR token$[rsp]
	lea	rcx, OFFSET FLAT:$SG10987
	call	DoDebugMsg1

; 580  : 
; 581  :         if( sym == NULL || sym->state == SYM_UNDEFINED ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN21@ExternDire
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	$LN19@ExternDire
$LN21@ExternDire:

; 582  :             /* v2.04: emit the error at the PUBLIC directive */
; 583  :             //if ( sym && sym->public == TRUE ) {
; 584  :             //    EmitErr( CANNOT_DEFINE_AS_PUBLIC_OR_EXTERNAL, sym->name );
; 585  :             //    return( ERROR );
; 586  :             //}
; 587  :             if(( sym = MakeExtern( token, ti.mem_type,
; 588  :                                   ti.mem_type == MT_TYPE ? ti.symtype : NULL, sym,
; 589  :                                   ti.is_ptr ? ModuleInfo.Ofssize : ti.Ofssize )) == NULL )

	movzx	eax, BYTE PTR ti$[rsp+20]
	test	eax, eax
	je	SHORT $LN39@ExternDire
	movzx	eax, BYTE PTR ModuleInfo+404
	mov	DWORD PTR tv242[rsp], eax
	jmp	SHORT $LN40@ExternDire
$LN39@ExternDire:
	movzx	eax, BYTE PTR ti$[rsp+22]
	mov	DWORD PTR tv242[rsp], eax
$LN40@ExternDire:
	cmp	DWORD PTR ti$[rsp+16], 196		; 000000c4H
	jne	SHORT $LN41@ExternDire
	mov	rax, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR tv247[rsp], rax
	jmp	SHORT $LN42@ExternDire
$LN41@ExternDire:
	mov	QWORD PTR tv247[rsp], 0
$LN42@ExternDire:
	movzx	eax, BYTE PTR tv242[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR tv247[rsp]
	mov	edx, DWORD PTR ti$[rsp+16]
	mov	rcx, QWORD PTR token$[rsp]
	call	MakeExtern
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN22@ExternDire

; 590  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExternDire
$LN22@ExternDire:

; 591  : 
; 592  :             /* v2.05: added to accept type prototypes */
; 593  :             if ( ti.is_ptr == 0 && ti.symtype && ti.symtype->isproc ) {

	movzx	eax, BYTE PTR ti$[rsp+20]
	test	eax, eax
	jne	$LN23@ExternDire
	cmp	QWORD PTR ti$[rsp+8], 0
	je	$LN23@ExternDire
	mov	rax, QWORD PTR ti$[rsp+8]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@ExternDire

; 594  :                 CreateProc( sym, NULL, SYM_EXTERNAL );

	mov	r8d, 2
	xor	edx, edx
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateProc

; 595  :                 sym->weak = FALSE; /* v2.09: reset the weak bit that has been set inside CreateProc() */

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	and	al, 247					; 000000f7H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 596  :                 CopyPrototype( (struct dsym *)sym, (struct dsym *)ti.symtype );

	mov	rdx, QWORD PTR ti$[rsp+8]
	mov	rcx, QWORD PTR sym$[rsp]
	call	CopyPrototype

; 597  :                 ti.mem_type = ti.symtype->mem_type;

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR ti$[rsp+16], eax

; 598  :                 ti.symtype = NULL;

	mov	QWORD PTR ti$[rsp+8], 0

; 599  :                 DebugMsg1(("ExternDirective(%s): prototype copied, memtype=%X\n", token, ti.mem_type ));

	mov	r8d, DWORD PTR ti$[rsp+16]
	mov	rdx, QWORD PTR token$[rsp]
	lea	rcx, OFFSET FLAT:$SG10993
	call	DoDebugMsg1
$LN23@ExternDire:

; 600  :             }
; 601  : 
; 602  :         } else {

	jmp	$LN20@ExternDire
$LN19@ExternDire:

; 603  : #if MASM_EXTCOND
; 604  :             /* allow internal AND external definitions for equates */
; 605  :             //if ( sym->state == SYM_INTERNAL && sym->mem_type == MT_ABS )
; 606  :             if ( sym->state == SYM_INTERNAL && sym->mem_type == MT_EMPTY )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN24@ExternDire
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 192			; 000000c0H
	jne	SHORT $LN24@ExternDire

; 607  :                 ;

	jmp	SHORT $LN25@ExternDire
$LN24@ExternDire:

; 608  :             else
; 609  : #endif
; 610  :             if ( sym->state != SYM_EXTERNAL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	je	SHORT $LN26@ExternDire

; 611  :                 DebugMsg(("ExternDirective: symbol %s redefinition, state=%u\n", token, sym->state ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+32]
	mov	rdx, QWORD PTR token$[rsp]
	lea	rcx, OFFSET FLAT:$SG10997
	call	DoDebugMsg

; 612  :                 return( EmitErr( SYMBOL_REDEFINITION, token ) );

	mov	rdx, QWORD PTR token$[rsp]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@ExternDire
$LN26@ExternDire:
$LN25@ExternDire:

; 613  :             }
; 614  :             /* v2.05: added to accept type prototypes */
; 615  :             if ( ti.is_ptr == 0 && ti.symtype && ti.symtype->isproc ) {

	movzx	eax, BYTE PTR ti$[rsp+20]
	test	eax, eax
	jne	SHORT $LN27@ExternDire
	cmp	QWORD PTR ti$[rsp+8], 0
	je	SHORT $LN27@ExternDire
	mov	rax, QWORD PTR ti$[rsp+8]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN27@ExternDire

; 616  :                 ti.mem_type = ti.symtype->mem_type;

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR ti$[rsp+16], eax

; 617  :                 ti.symtype = NULL;

	mov	QWORD PTR ti$[rsp+8], 0
$LN27@ExternDire:

; 618  :             }
; 619  : 
; 620  :             if( sym->mem_type != ti.mem_type ||
; 621  :                sym->is_ptr != ti.is_ptr ||
; 622  :                sym->isfar != ti.is_far ||
; 623  :                ( sym->is_ptr && sym->ptr_memtype != ti.ptr_memtype ) ||
; 624  :                ((sym->mem_type == MT_TYPE) ? sym->type : sym->target_type) != ti.symtype ||

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR ti$[rsp+16]
	cmp	DWORD PTR [rax+36], ecx
	jne	$LN29@ExternDire
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+45]
	movzx	ecx, BYTE PTR ti$[rsp+20]
	cmp	eax, ecx
	jne	$LN29@ExternDire
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	movzx	ecx, BYTE PTR ti$[rsp+21]
	cmp	eax, ecx
	jne	$LN29@ExternDire
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+45]
	test	eax, eax
	je	SHORT $LN30@ExternDire
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	cmp	eax, DWORD PTR ti$[rsp+24]
	jne	SHORT $LN29@ExternDire
$LN30@ExternDire:
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	SHORT $LN43@ExternDire
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR tv316[rsp], rax
	jmp	SHORT $LN44@ExternDire
$LN43@ExternDire:
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv316[rsp], rax
$LN44@ExternDire:
	mov	rax, QWORD PTR ti$[rsp+8]
	cmp	QWORD PTR tv316[rsp], rax
	jne	SHORT $LN29@ExternDire
	cmp	DWORD PTR langtype$[rsp], 0
	je	$LN28@ExternDire
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+76], 0
	je	$LN28@ExternDire
	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR langtype$[rsp]
	cmp	DWORD PTR [rax+76], ecx
	je	$LN28@ExternDire
$LN29@ExternDire:

; 625  :                ( langtype != LANG_NONE && sym->langtype != LANG_NONE && sym->langtype != langtype )) {
; 626  :                 DebugMsg(("ExternDirective: memtype:%X-%X ptr=%X-%X far=%X-%X ptr_memtype=%X-%X lang=%u-%u\n",

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	movzx	ecx, BYTE PTR ti$[rsp+21]
	mov	rdx, QWORD PTR sym$[rsp]
	movzx	edx, BYTE PTR [rdx+47]
	shr	dl, 4
	and	dl, 1
	movzx	edx, dl
	movzx	r8d, BYTE PTR ti$[rsp+20]
	mov	r9, QWORD PTR sym$[rsp]
	movzx	r9d, BYTE PTR [r9+45]
	mov	r10d, DWORD PTR langtype$[rsp]
	mov	DWORD PTR [rsp+80], r10d
	mov	r10, QWORD PTR sym$[rsp]
	mov	r10d, DWORD PTR [r10+76]
	mov	DWORD PTR [rsp+72], r10d
	mov	r10d, DWORD PTR ti$[rsp+24]
	mov	DWORD PTR [rsp+64], r10d
	mov	DWORD PTR [rsp+56], eax
	mov	DWORD PTR [rsp+48], ecx
	mov	DWORD PTR [rsp+40], edx
	mov	DWORD PTR [rsp+32], r8d
	mov	r8d, DWORD PTR ti$[rsp+16]
	mov	rax, QWORD PTR sym$[rsp]
	mov	edx, DWORD PTR [rax+36]
	lea	rcx, OFFSET FLAT:$SG11002
	call	DoDebugMsg

; 627  :                           sym->mem_type, ti.mem_type,
; 628  :                           sym->is_ptr, ti.is_ptr,
; 629  :                           sym->isfar, ti.is_far,
; 630  :                           sym->ptr_memtype, ti.ptr_memtype,
; 631  :                           sym->langtype, langtype
; 632  :                          ));
; 633  :                 return( EmitErr( SYMBOL_TYPE_CONFLICT, token ) );

	mov	rdx, QWORD PTR token$[rsp]
	mov	ecx, 136				; 00000088H
	call	EmitErr
	jmp	$LN1@ExternDire
$LN28@ExternDire:
$LN20@ExternDire:

; 634  :             }
; 635  :         }
; 636  : 
; 637  :         sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 638  :         sym->Ofssize = ti.Ofssize;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR ti$[rsp+22]
	mov	BYTE PTR [rax+44], cl

; 639  : 
; 640  :         if ( ti.is_ptr == 0 && ti.Ofssize != ModuleInfo.Ofssize ) {

	movzx	eax, BYTE PTR ti$[rsp+20]
	test	eax, eax
	jne	SHORT $LN31@ExternDire
	movzx	eax, BYTE PTR ti$[rsp+22]
	movzx	ecx, BYTE PTR ModuleInfo+404
	cmp	eax, ecx
	je	SHORT $LN31@ExternDire

; 641  :             sym->seg_ofssize = ti.Ofssize;

	movzx	eax, BYTE PTR ti$[rsp+22]
	and	al, 3
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 252					; 000000fcH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 642  :             if ( sym->segment && ((struct dsym *)sym->segment)->e.seginfo->Ofssize != sym->seg_ofssize )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN32@ExternDire
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+104]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 3
	movzx	ecx, cl
	cmp	eax, ecx
	je	SHORT $LN32@ExternDire

; 643  :                 sym->segment = NULL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+24], 0
$LN32@ExternDire:
$LN31@ExternDire:

; 644  :         }
; 645  : 
; 646  :         sym->mem_type = ti.mem_type;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR ti$[rsp+16]
	mov	DWORD PTR [rax+36], ecx

; 647  :         sym->is_ptr = ti.is_ptr;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR ti$[rsp+20]
	mov	BYTE PTR [rax+45], cl

; 648  :         sym->isfar = ti.is_far;

	movzx	eax, BYTE PTR ti$[rsp+21]
	and	al, 1
	shl	al, 4
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 239					; 000000efH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 649  :         sym->ptr_memtype = ti.ptr_memtype;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR ti$[rsp+24]
	mov	BYTE PTR [rax+46], cl

; 650  :         if ( ti.mem_type == MT_TYPE )

	cmp	DWORD PTR ti$[rsp+16], 196		; 000000c4H
	jne	SHORT $LN33@ExternDire

; 651  :             sym->type = ti.symtype;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rax+80], rcx
	jmp	SHORT $LN34@ExternDire
$LN33@ExternDire:

; 652  :         else
; 653  :             sym->target_type = ti.symtype;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rax+48], rcx
$LN34@ExternDire:

; 654  : 
; 655  :         HandleAltname( altname, sym );

	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR altname$[rsp]
	call	HandleAltname

; 656  : 
; 657  :         SetMangler( sym, langtype, mangle_type );

	xor	r8d, r8d
	mov	edx, DWORD PTR langtype$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	SetMangler

; 658  : 
; 659  :         if ( tokenarray[i].token != T_FINAL )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN35@ExternDire

; 660  :             if ( tokenarray[i].token == T_COMMA &&  ( (i + 1) < Token_Count ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN36@ExternDire
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cmp	eax, DWORD PTR ModuleInfo+496
	jge	SHORT $LN36@ExternDire

; 661  :                 i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 662  :             } else {

	jmp	SHORT $LN37@ExternDire
$LN36@ExternDire:

; 663  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@ExternDire
$LN37@ExternDire:
$LN35@ExternDire:

; 664  :             }
; 665  :     }  while ( i < Token_Count );

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jl	$LN4@ExternDire

; 666  : 
; 667  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@ExternDire:

; 668  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:ExternDirective$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 240				; 000000f0H
	pop	rdi
	ret	0
ExternDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
symalt$ = 32
altname$ = 64
sym$ = 72
HandleAltname PROC

; 425  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 426  :     struct asym *symalt;
; 427  : 
; 428  :     if ( altname && sym->state == SYM_EXTERNAL ) {

	cmp	QWORD PTR altname$[rsp], 0
	je	$LN2@HandleAltn
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	$LN2@HandleAltn

; 429  : 
; 430  :         symalt = SymSearch( altname );

	mov	rcx, QWORD PTR altname$[rsp]
	call	SymFind
	mov	QWORD PTR symalt$[rsp], rax

; 431  : 
; 432  :         /* altname symbol changed? */
; 433  :         if ( sym->altname && sym->altname != symalt ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+64], 0
	je	SHORT $LN3@HandleAltn
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR symalt$[rsp]
	cmp	QWORD PTR [rax+64], rcx
	je	SHORT $LN3@HandleAltn

; 434  :             return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN1@HandleAltn
$LN3@HandleAltn:

; 435  :         }
; 436  : 
; 437  :         if ( Parse_Pass > PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jbe	$LN4@HandleAltn

; 438  :             if ( symalt->state == SYM_UNDEFINED ) {

	mov	rax, QWORD PTR symalt$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN6@HandleAltn

; 439  :                 EmitErr( SYMBOL_NOT_DEFINED, altname );

	mov	rdx, QWORD PTR altname$[rsp]
	mov	ecx, 102				; 00000066H
	call	EmitErr
	jmp	$LN7@HandleAltn
$LN6@HandleAltn:

; 440  :             } else if (symalt->state != SYM_INTERNAL && symalt->state != SYM_EXTERNAL ) {

	mov	rax, QWORD PTR symalt$[rsp]
	cmp	DWORD PTR [rax+32], 1
	je	SHORT $LN8@HandleAltn
	mov	rax, QWORD PTR symalt$[rsp]
	cmp	DWORD PTR [rax+32], 2
	je	SHORT $LN8@HandleAltn

; 441  :                 EmitErr( SYMBOL_TYPE_CONFLICT, altname );

	mov	rdx, QWORD PTR altname$[rsp]
	mov	ecx, 136				; 00000088H
	call	EmitErr

; 442  :             } else {

	jmp	SHORT $LN9@HandleAltn
$LN8@HandleAltn:

; 443  : #if COFF_SUPPORT || ELF_SUPPORT
; 444  :                 if ( symalt->state == SYM_INTERNAL && symalt->ispublic == FALSE )

	mov	rax, QWORD PTR symalt$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN10@HandleAltn
	mov	rax, QWORD PTR symalt$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@HandleAltn

; 445  :                     if ( Options.output_format == OFORMAT_COFF
; 446  : #if ELF_SUPPORT
; 447  :                         || Options.output_format == OFORMAT_ELF

	cmp	DWORD PTR Options+160, 2
	je	SHORT $LN12@HandleAltn
	cmp	DWORD PTR Options+160, 3
	jne	SHORT $LN11@HandleAltn
$LN12@HandleAltn:

; 448  : #endif
; 449  :                        ) {
; 450  :                         EmitErr( MUST_BE_PUBLIC_OR_EXTERNAL, altname );

	mov	rdx, QWORD PTR altname$[rsp]
	mov	ecx, 268				; 0000010cH
	call	EmitErr
$LN11@HandleAltn:
$LN10@HandleAltn:

; 451  :                     }
; 452  : #endif
; 453  :                 if ( sym->mem_type != symalt->mem_type )

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR symalt$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	cmp	DWORD PTR [rax+36], ecx
	je	SHORT $LN13@HandleAltn

; 454  :                     EmitErr( SYMBOL_TYPE_CONFLICT, altname );

	mov	rdx, QWORD PTR altname$[rsp]
	mov	ecx, 136				; 00000088H
	call	EmitErr
$LN13@HandleAltn:
$LN9@HandleAltn:
$LN7@HandleAltn:

; 455  :             }
; 456  :         } else {

	jmp	$LN5@HandleAltn
$LN4@HandleAltn:

; 457  : 
; 458  :             if ( symalt ) {

	cmp	QWORD PTR symalt$[rsp], 0
	je	SHORT $LN14@HandleAltn

; 459  :                 DebugMsg(("HandleAltname: symbol '%s' found, state=%u\n", altname, symalt->state ));

	mov	rax, QWORD PTR symalt$[rsp]
	mov	r8d, DWORD PTR [rax+32]
	mov	rdx, QWORD PTR altname$[rsp]
	lea	rcx, OFFSET FLAT:$SG10937
	call	DoDebugMsg

; 460  :                 if ( symalt->state != SYM_INTERNAL &&
; 461  :                     symalt->state != SYM_EXTERNAL &&

	mov	rax, QWORD PTR symalt$[rsp]
	cmp	DWORD PTR [rax+32], 1
	je	SHORT $LN16@HandleAltn
	mov	rax, QWORD PTR symalt$[rsp]
	cmp	DWORD PTR [rax+32], 2
	je	SHORT $LN16@HandleAltn
	mov	rax, QWORD PTR symalt$[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN16@HandleAltn

; 462  :                     symalt->state != SYM_UNDEFINED ) {
; 463  :                     return( EmitErr( SYMBOL_TYPE_CONFLICT, altname ) );

	mov	rdx, QWORD PTR altname$[rsp]
	mov	ecx, 136				; 00000088H
	call	EmitErr
	jmp	SHORT $LN1@HandleAltn
$LN16@HandleAltn:

; 464  :                 }
; 465  :             } else {

	jmp	SHORT $LN15@HandleAltn
$LN14@HandleAltn:

; 466  :                 symalt = SymCreate( altname );

	mov	rcx, QWORD PTR altname$[rsp]
	call	SymCreate
	mov	QWORD PTR symalt$[rsp], rax

; 467  :                 sym_add_table( &SymTables[TAB_UNDEF], (struct dsym *)symalt );

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR symalt$[rsp]
	mov	rcx, rax
	call	sym_add_table
$LN15@HandleAltn:

; 468  :             }
; 469  :             /* make sure the alt symbol becomes strong if it is an external
; 470  :              * v2.11: don't do this for OMF ( maybe neither for COFF/ELF? )
; 471  :              */
; 472  :             if ( Options.output_format != OFORMAT_OMF )

	cmp	DWORD PTR Options+160, 1
	je	SHORT $LN17@HandleAltn

; 473  :                 symalt->used = TRUE;

	mov	rax, QWORD PTR symalt$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 1
	mov	rcx, QWORD PTR symalt$[rsp]
	mov	BYTE PTR [rcx+40], al
$LN17@HandleAltn:

; 474  :             /* symbol inserted in the "weak external" queue?
; 475  :              * currently needed for OMF only.
; 476  :              */
; 477  :             if ( sym->altname == NULL ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+64], 0
	jne	SHORT $LN18@HandleAltn

; 478  :                 sym->altname = symalt;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR symalt$[rsp]
	mov	QWORD PTR [rax+64], rcx
$LN18@HandleAltn:
$LN5@HandleAltn:
$LN2@HandleAltn:

; 479  : #if 0 /* v2.11: removed. Member nextext wasn't free to use */
; 480  :                 DebugMsg1(("HandleAltname: symbol '%s' added to AltQueue\n", sym->name ));
; 481  :                 ((struct dsym *)sym)->nextext = NULL;
; 482  :                 if ( ModuleInfo.g.AltQueue.head == NULL )
; 483  :                     ModuleInfo.g.AltQueue.head = ModuleInfo.g.AltQueue.tail = (struct dsym *)sym;
; 484  :                 else {
; 485  :                     ((struct dsym *)ModuleInfo.g.AltQueue.tail)->nextext = (struct dsym *)sym;
; 486  :                     ModuleInfo.g.AltQueue.tail = (struct dsym *)sym;
; 487  :                 }
; 488  : #endif
; 489  :             }
; 490  :         }
; 491  :     }
; 492  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@HandleAltn:

; 493  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
HandleAltname ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
sym$1 = 32
tv128 = 40
i$ = 64
tokenarray$ = 72
ProtoDirective PROC

; 380  : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+64]

; 381  :     if( Parse_Pass != PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN2@ProtoDirec

; 382  :         struct asym *sym;
; 383  :         /* v2.04: set the "defined" flag */
; 384  :         if ( ( sym = SymSearch( tokenarray[0].string_ptr ) ) && sym->isproc == TRUE )

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$1[rsp], rax
	cmp	QWORD PTR sym$1[rsp], 0
	je	SHORT $LN3@ProtoDirec
	mov	rax, QWORD PTR sym$1[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN3@ProtoDirec

; 385  :             sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$1[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$1[rsp]
	mov	BYTE PTR [rcx+40], al
$LN3@ProtoDirec:

; 386  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@ProtoDirec
$LN2@ProtoDirec:

; 387  :     }
; 388  :     if( i != 1 ) {

	cmp	DWORD PTR i$[rsp], 1
	je	SHORT $LN4@ProtoDirec

; 389  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN1@ProtoDirec
$LN4@ProtoDirec:

; 390  :     }
; 391  : 
; 392  :     return( CreateProto( 2, tokenarray, tokenarray[0].string_ptr, ModuleInfo.langtype ) ? NOT_ERROR : ERROR );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 0
	mov	r9d, DWORD PTR ModuleInfo+364
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	r8, QWORD PTR [rcx+rax+8]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, 2
	call	CreateProto
	test	rax, rax
	je	SHORT $LN6@ProtoDirec
	mov	DWORD PTR tv128[rsp], 0
	jmp	SHORT $LN7@ProtoDirec
$LN6@ProtoDirec:
	mov	DWORD PTR tv128[rsp], -1
$LN7@ProtoDirec:
	mov	eax, DWORD PTR tv128[rsp]
$LN1@ProtoDirec:

; 393  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
ProtoDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
token$ = 48
sym$ = 56
langtype$ = 68
isnew$ = 84
ti$ = 104
sym2$5 = 152
tv164 = 160
tv210 = 164
i$ = 192
tokenarray$ = 200
ExterndefDirective PROC

; 183  : {

$LN47:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 176				; 000000b0H
	mov	rdi, rsp
	mov	ecx, 44					; 0000002cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+192]

; 184  :     char                *token;
; 185  : #if MANGLERSUPP
; 186  :     char                *mangle_type = NULL;
; 187  : #endif
; 188  :     struct asym         *sym;
; 189  :     enum lang_type      langtype;
; 190  :     char isnew;
; 191  :     struct qualified_type ti;
; 192  : 
; 193  :     DebugMsg1(("ExterndefDirective(%u) enter\n", i));

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG10847
	call	DoDebugMsg1

; 194  : 
; 195  :     i++; /* skip EXTERNDEF token */

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@ExterndefD:

; 196  : #if MANGLERSUPP
; 197  :     mangle_type = Check4Mangler( &i, tokenarray );
; 198  : #endif
; 199  :     do {
; 200  : 
; 201  :         ti.Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	BYTE PTR ti$[rsp+22], al

; 202  : 
; 203  :         /* get the symbol language type if present */
; 204  :         langtype = ModuleInfo.langtype;

	mov	eax, DWORD PTR ModuleInfo+364
	mov	DWORD PTR langtype$[rsp], eax

; 205  :         GetLangType( &i, tokenarray, &langtype );

	lea	r8, QWORD PTR langtype$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	GetLangType

; 206  : 
; 207  :         /* get the symbol name */
; 208  :         if( tokenarray[i].token != T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN11@ExterndefD

; 209  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN1@ExterndefD
$LN11@ExterndefD:

; 210  :         }
; 211  :         token = tokenarray[i++].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	mov	QWORD PTR token$[rsp], rax
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 212  : 
; 213  :         /* go past the colon */
; 214  :         if( tokenarray[i].token != T_COLON ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN12@ExterndefD

; 215  :             return( EmitError( COLON_EXPECTED ) );

	mov	ecx, 84					; 00000054H
	call	EmitError
	jmp	$LN1@ExterndefD
$LN12@ExterndefD:

; 216  :         }
; 217  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 218  :         sym = SymSearch( token );

	mov	rcx, QWORD PTR token$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 219  : 
; 220  :         //typetoken = tokenarray[i].string_ptr;
; 221  :         ti.mem_type = MT_EMPTY;

	mov	DWORD PTR ti$[rsp+16], 192		; 000000c0H

; 222  :         ti.size = 0;

	mov	DWORD PTR ti$[rsp], 0

; 223  :         ti.is_ptr = 0;

	mov	BYTE PTR ti$[rsp+20], 0

; 224  :         ti.is_far = FALSE;

	mov	BYTE PTR ti$[rsp+21], 0

; 225  :         ti.ptr_memtype = MT_EMPTY;

	mov	DWORD PTR ti$[rsp+24], 192		; 000000c0H

; 226  :         ti.symtype = NULL;

	mov	QWORD PTR ti$[rsp+8], 0

; 227  :         ti.Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	BYTE PTR ti$[rsp+22], al

; 228  : 
; 229  :         if ( tokenarray[i].token == T_ID && ( 0 == _stricmp( tokenarray[i].string_ptr, "ABS" ) ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN13@ExterndefD
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rdx, OFFSET FLAT:$SG10852
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN13@ExterndefD

; 230  :             /* v2.07: MT_ABS is obsolete */
; 231  :             //ti.mem_type = MT_ABS;
; 232  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	$LN14@ExterndefD
$LN13@ExterndefD:

; 233  :         } else if ( tokenarray[i].token == T_DIRECTIVE && tokenarray[i].tokval == T_PROTO ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	SHORT $LN15@ExterndefD
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 427		; 000001abH
	jne	SHORT $LN15@ExterndefD

; 234  :             /* dont scan this line further!
; 235  :              * CreateProto() will either define a SYM_EXTERNAL or fail
; 236  :              * if there's a syntax error or symbol redefinition.
; 237  :              */
; 238  :             sym = CreateProto( i + 1, tokenarray, token, langtype );

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	r9d, DWORD PTR langtype$[rsp]
	mov	r8, QWORD PTR token$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, eax
	call	CreateProto
	mov	QWORD PTR sym$[rsp], rax

; 239  : #if 0 /* global queue is obsolete */
; 240  :             if ( sym && sym->isglobal == FALSE ) {
; 241  :                 sym->isglobal = TRUE;
; 242  :                 QAddItem( &ModuleInfo.g.GlobalQueue, sym );
; 243  :             }
; 244  : #endif
; 245  :             return( sym ? NOT_ERROR : ERROR );

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN45@ExterndefD
	mov	DWORD PTR tv164[rsp], 0
	jmp	SHORT $LN46@ExterndefD
$LN45@ExterndefD:
	mov	DWORD PTR tv164[rsp], -1
$LN46@ExterndefD:
	mov	eax, DWORD PTR tv164[rsp]
	jmp	$LN1@ExterndefD
	jmp	SHORT $LN16@ExterndefD
$LN15@ExterndefD:

; 246  :         } else if ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN17@ExterndefD
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN17@ExterndefD

; 247  :             if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	GetQualifiedType
	cmp	eax, -1
	jne	SHORT $LN18@ExterndefD

; 248  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@ExterndefD
$LN18@ExterndefD:
$LN17@ExterndefD:
$LN16@ExterndefD:
$LN14@ExterndefD:

; 249  :         }
; 250  : 
; 251  :         isnew = FALSE;

	mov	BYTE PTR isnew$[rsp], 0

; 252  :         if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN20@ExterndefD
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN19@ExterndefD
$LN20@ExterndefD:

; 253  :             sym = CreateExternal( sym, token, TRUE );

	mov	r8b, 1
	mov	rdx, QWORD PTR token$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateExternal
	mov	QWORD PTR sym$[rsp], rax

; 254  :             isnew = TRUE;

	mov	BYTE PTR isnew$[rsp], 1
$LN19@ExterndefD:

; 255  :         }
; 256  : 
; 257  :         /* new symbol? */
; 258  : 
; 259  :         if ( isnew ) {

	movsx	eax, BYTE PTR isnew$[rsp]
	test	eax, eax
	je	$LN21@ExterndefD

; 260  :             DebugMsg1(("ExterndefDirective(%s): memtype=%X set, ofssize=%X\n", token, ti.mem_type, ti.Ofssize ));

	movzx	eax, BYTE PTR ti$[rsp+22]
	mov	r9d, eax
	mov	r8d, DWORD PTR ti$[rsp+16]
	mov	rdx, QWORD PTR token$[rsp]
	lea	rcx, OFFSET FLAT:$SG10861
	call	DoDebugMsg1

; 261  : 
; 262  :             /* v2.05: added to accept type prototypes */
; 263  :             if ( ti.is_ptr == 0 && ti.symtype && ti.symtype->isproc ) {

	movzx	eax, BYTE PTR ti$[rsp+20]
	test	eax, eax
	jne	SHORT $LN23@ExterndefD
	cmp	QWORD PTR ti$[rsp+8], 0
	je	SHORT $LN23@ExterndefD
	mov	rax, QWORD PTR ti$[rsp+8]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@ExterndefD

; 264  :                 CreateProc( sym, NULL, SYM_EXTERNAL );

	mov	r8d, 2
	xor	edx, edx
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateProc

; 265  :                 CopyPrototype( (struct dsym *)sym, (struct dsym *)ti.symtype );

	mov	rdx, QWORD PTR ti$[rsp+8]
	mov	rcx, QWORD PTR sym$[rsp]
	call	CopyPrototype

; 266  :                 ti.mem_type = ti.symtype->mem_type;

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR ti$[rsp+16], eax

; 267  :                 ti.symtype = NULL;

	mov	QWORD PTR ti$[rsp+8], 0
$LN23@ExterndefD:

; 268  :             }
; 269  :             switch ( ti.mem_type ) {

	mov	eax, DWORD PTR ti$[rsp+16]
	mov	DWORD PTR tv210[rsp], eax
	cmp	DWORD PTR tv210[rsp], 130		; 00000082H
	je	SHORT $LN25@ExterndefD
	cmp	DWORD PTR tv210[rsp], 192		; 000000c0H
	je	SHORT $LN24@ExterndefD
	jmp	SHORT $LN27@ExterndefD
$LN24@ExterndefD:

; 270  :             //case MT_ABS:
; 271  :             case MT_EMPTY:
; 272  :                 /* v2.04: hack no longer necessary */
; 273  :                 //if ( sym->weak == TRUE )
; 274  :                 //    sym->equate = TRUE; /* allow redefinition by EQU, = */
; 275  :                 break;

	jmp	SHORT $LN5@ExterndefD
$LN25@ExterndefD:

; 276  :             case MT_FAR:
; 277  :                 /* v2.04: don't inherit current segment for FAR externals
; 278  :                  * if -Zg is set.
; 279  :                  */
; 280  :                 if ( Options.masm_compat_gencode )

	movzx	eax, BYTE PTR Options+144
	test	eax, eax
	je	SHORT $LN26@ExterndefD

; 281  :                     break; 

	jmp	SHORT $LN5@ExterndefD
$LN26@ExterndefD:
$LN27@ExterndefD:

; 282  :                 /* fall through */
; 283  :             default:
; 284  :                 //SetSymSegOfs( sym );
; 285  :                 sym->segment = &CurrSeg->sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+24], rax
$LN5@ExterndefD:

; 286  :             }
; 287  :             sym->Ofssize = ti.Ofssize;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR ti$[rsp+22]
	mov	BYTE PTR [rax+44], cl

; 288  : 
; 289  :             if ( ti.is_ptr == 0 && ti.Ofssize != ModuleInfo.Ofssize ) {

	movzx	eax, BYTE PTR ti$[rsp+20]
	test	eax, eax
	jne	SHORT $LN28@ExterndefD
	movzx	eax, BYTE PTR ti$[rsp+22]
	movzx	ecx, BYTE PTR ModuleInfo+404
	cmp	eax, ecx
	je	SHORT $LN28@ExterndefD

; 290  :                 sym->seg_ofssize = ti.Ofssize;

	movzx	eax, BYTE PTR ti$[rsp+22]
	and	al, 3
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 252					; 000000fcH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 291  :                 if ( sym->segment && ((struct dsym *)sym->segment)->e.seginfo->Ofssize != sym->seg_ofssize )

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN29@ExterndefD
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax+96]
	movzx	eax, BYTE PTR [rax+104]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 3
	movzx	ecx, cl
	cmp	eax, ecx
	je	SHORT $LN29@ExterndefD

; 292  :                     sym->segment = NULL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rax+24], 0
$LN29@ExterndefD:
$LN28@ExterndefD:

; 293  :             }
; 294  : 
; 295  :             sym->mem_type = ti.mem_type;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR ti$[rsp+16]
	mov	DWORD PTR [rax+36], ecx

; 296  :             sym->is_ptr = ti.is_ptr;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR ti$[rsp+20]
	mov	BYTE PTR [rax+45], cl

; 297  :             sym->isfar = ti.is_far;

	movzx	eax, BYTE PTR ti$[rsp+21]
	and	al, 1
	shl	al, 4
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 239					; 000000efH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 298  :             sym->ptr_memtype = ti.ptr_memtype;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR ti$[rsp+24]
	mov	BYTE PTR [rax+46], cl

; 299  :             if ( ti.mem_type == MT_TYPE )

	cmp	DWORD PTR ti$[rsp+16], 196		; 000000c4H
	jne	SHORT $LN30@ExterndefD

; 300  :                 sym->type = ti.symtype;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rax+80], rcx
	jmp	SHORT $LN31@ExterndefD
$LN30@ExterndefD:

; 301  :             else
; 302  :                 sym->target_type = ti.symtype;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rax+48], rcx
$LN31@ExterndefD:

; 303  : 
; 304  :             /* v2.04: only set language if there was no previous definition */
; 305  :             SetMangler( sym, langtype, mangle_type );

	xor	r8d, r8d
	mov	edx, DWORD PTR langtype$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	SetMangler
	jmp	$LN22@ExterndefD
$LN21@ExterndefD:

; 306  : 
; 307  :         } else if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN32@ExterndefD

; 308  : 
; 309  :             /* v2.05: added to accept type prototypes */
; 310  :             if ( ti.is_ptr == 0 && ti.symtype && ti.symtype->isproc ) {

	movzx	eax, BYTE PTR ti$[rsp+20]
	test	eax, eax
	jne	SHORT $LN33@ExterndefD
	cmp	QWORD PTR ti$[rsp+8], 0
	je	SHORT $LN33@ExterndefD
	mov	rax, QWORD PTR ti$[rsp+8]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN33@ExterndefD

; 311  :                 ti.mem_type = ti.symtype->mem_type;

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR ti$[rsp+16], eax

; 312  :                 ti.symtype = NULL;

	mov	QWORD PTR ti$[rsp+8], 0
$LN33@ExterndefD:

; 313  :             }
; 314  :             /* ensure that the type of the symbol won't change */
; 315  : 
; 316  :             if ( sym->mem_type != ti.mem_type ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR ti$[rsp+16]
	cmp	DWORD PTR [rax+36], ecx
	je	SHORT $LN34@ExterndefD

; 317  :                 /* if the symbol is already defined (as SYM_INTERNAL), Masm
; 318  :                  won't display an error. The other way, first externdef and
; 319  :                  then the definition, will make Masm complain, however */
; 320  :                 DebugMsg(("ExterndefDirective: type conflict for %s. mem_types old-new: %X-%X\n", sym->name, sym->mem_type, ti.mem_type));

	mov	r9d, DWORD PTR ti$[rsp+16]
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8d, DWORD PTR [rax+36]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10875
	call	DoDebugMsg

; 321  :                 EmitWarn( 1, SYMBOL_TYPE_CONFLICT, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 136				; 00000088H
	mov	ecx, 1
	call	EmitWarn
	jmp	$LN35@ExterndefD
$LN34@ExterndefD:

; 322  :             } else if ( sym->mem_type == MT_TYPE && sym->type != ti.symtype ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+36], 196			; 000000c4H
	jne	$LN36@ExterndefD
	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR ti$[rsp+8]
	cmp	QWORD PTR [rax+80], rcx
	je	$LN36@ExterndefD

; 323  :                 struct asym *sym2 = sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR sym2$5[rsp], rax

; 324  :                 /* skip alias types and compare the base types */
; 325  :                 DebugMsg(("ExterndefDirective(%s): types differ: %X (%s) - %X (%s)\n", sym->name, sym->type, sym->type->name, ti.symtype, ti.symtype->name));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR [rax+8]
	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+80]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10877
	call	DoDebugMsg
$LN7@ExterndefD:

; 326  :                 while ( sym2->type )

	mov	rax, QWORD PTR sym2$5[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN8@ExterndefD

; 327  :                     sym2 = sym2->type;

	mov	rax, QWORD PTR sym2$5[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR sym2$5[rsp], rax
	jmp	SHORT $LN7@ExterndefD
$LN8@ExterndefD:
$LN9@ExterndefD:

; 328  :                 while ( ti.symtype->type )

	mov	rax, QWORD PTR ti$[rsp+8]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN10@ExterndefD

; 329  :                     ti.symtype = ti.symtype->type;

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR ti$[rsp+8], rax
	jmp	SHORT $LN9@ExterndefD
$LN10@ExterndefD:

; 330  :                 if ( sym2 != ti.symtype ) {

	mov	rax, QWORD PTR ti$[rsp+8]
	cmp	QWORD PTR sym2$5[rsp], rax
	je	SHORT $LN37@ExterndefD

; 331  :                     DebugMsg(("ExterndefDirective(%s): type conflict old-new: %X (%s) - %X (%s)\n", sym->name, sym2, sym2->name, ti.symtype, ti.symtype->name));

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR sym2$5[rsp]
	mov	r9, QWORD PTR [rax+8]
	mov	r8, QWORD PTR sym2$5[rsp]
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG10879
	call	DoDebugMsg

; 332  :                     EmitWarn( 1, SYMBOL_TYPE_CONFLICT, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 136				; 00000088H
	mov	ecx, 1
	call	EmitWarn
$LN37@ExterndefD:
$LN36@ExterndefD:
$LN35@ExterndefD:

; 333  :                 }
; 334  :             }
; 335  : 
; 336  :             /* v2.04: emit a - weak - warning if language differs.
; 337  :              * Masm doesn't warn.
; 338  :              */
; 339  :             if ( langtype != LANG_NONE && sym->langtype != langtype )

	cmp	DWORD PTR langtype$[rsp], 0
	je	SHORT $LN38@ExterndefD
	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR langtype$[rsp]
	cmp	DWORD PTR [rax+76], ecx
	je	SHORT $LN38@ExterndefD

; 340  :                 EmitWarn( 3, LANGUAGE_ATTRIBUTE_CONFLICT, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 103				; 00000067H
	mov	ecx, 3
	call	EmitWarn
$LN38@ExterndefD:
$LN32@ExterndefD:
$LN22@ExterndefD:

; 341  :         }
; 342  :         sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 343  : 
; 344  : #if 0
; 345  :         /* write a global entry if none has been written yet */
; 346  :         if ( sym->state == SYM_EXTERNAL && sym->weak == FALSE )
; 347  :             ;/* skip EXTERNDEF if a real EXTERN/COMM was done */
; 348  :         else if ( sym->isglobal == FALSE ) {
; 349  :             sym->isglobal = TRUE;
; 350  :             DebugMsg1(("ExterndefDirective(%s): writing a global entry\n", sym->name));
; 351  :             QAddItem( &ModuleInfo.g.GlobalQueue, sym );
; 352  :         }
; 353  : #else
; 354  :         if ( sym->state == SYM_INTERNAL && sym->ispublic == FALSE ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 1
	jne	SHORT $LN39@ExterndefD
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN39@ExterndefD

; 355  :             sym->ispublic = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 356  :             AddPublicData( sym );

	mov	rcx, QWORD PTR sym$[rsp]
	call	AddPublicData
$LN39@ExterndefD:

; 357  :         }
; 358  : #endif
; 359  : 
; 360  :         if ( tokenarray[i].token != T_FINAL )

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN40@ExterndefD

; 361  :             if ( tokenarray[i].token == T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN41@ExterndefD

; 362  :                 if ( (i + 1) < Token_Count )

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cmp	eax, DWORD PTR ModuleInfo+496
	jge	SHORT $LN43@ExterndefD

; 363  :                     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN43@ExterndefD:

; 364  :             } else {

	jmp	SHORT $LN42@ExterndefD
$LN41@ExterndefD:

; 365  :                 return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	SHORT $LN1@ExterndefD
$LN42@ExterndefD:
$LN40@ExterndefD:

; 366  :             }
; 367  : 
; 368  :     } while ( i < Token_Count );

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jl	$LN4@ExterndefD

; 369  : 
; 370  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@ExterndefD:

; 371  : }

	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:ExterndefDirective$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 176				; 000000b0H
	pop	rdi
	ret	0
ExterndefDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
sym$ = 48
dir$ = 56
sym2$1 = 64
tv66 = 72
i$ = 96
tokenarray$ = 104
name$ = 112
langtype$ = 120
CreateProto PROC

; 126  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+96]

; 127  :     struct asym      *sym;
; 128  :     struct dsym      *dir;
; 129  : 
; 130  :     DebugMsg1(("CreateProto( i=%u, name=%s, lang=%u )\n", i, name ? name : "NULL", langtype ));

	cmp	QWORD PTR name$[rsp], 0
	je	SHORT $LN14@CreateProt
	mov	rax, QWORD PTR name$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN15@CreateProt
$LN14@CreateProt:
	lea	rax, OFFSET FLAT:$SG10803
	mov	QWORD PTR tv66[rsp], rax
$LN15@CreateProt:
	mov	r9d, DWORD PTR langtype$[rsp]
	mov	r8, QWORD PTR tv66[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG10804
	call	DoDebugMsg1

; 131  :     sym = SymSearch( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 132  : 
; 133  :     /* the symbol must be either NULL or state
; 134  :      * - SYM_UNDEFINED
; 135  :      * - SYM_EXTERNAL + isproc == FALSE ( previous EXTERNDEF )
; 136  :      * - SYM_EXTERNAL + isproc == TRUE ( previous PROTO )
; 137  :      * - SYM_INTERNAL + isproc == TRUE ( previous PROC )
; 138  :      */
; 139  :     if( sym == NULL ||
; 140  :        sym->state == SYM_UNDEFINED ||

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN4@CreateProt
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN4@CreateProt
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 2
	jne	SHORT $LN2@CreateProt
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN2@CreateProt
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@CreateProt
$LN4@CreateProt:

; 141  :        ( sym->state == SYM_EXTERNAL && sym->weak == TRUE && sym->isproc == FALSE )) {
; 142  :         if ( NULL == ( sym = CreateProc( sym, name, SYM_EXTERNAL ) ) )

	mov	r8d, 2
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateProc
	mov	QWORD PTR sym$[rsp], rax
	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN5@CreateProt

; 143  :             return( NULL ); /* name was probably invalid */

	xor	eax, eax
	jmp	$LN1@CreateProt
$LN5@CreateProt:

; 144  :     } else if ( sym->isproc == FALSE ) {

	jmp	SHORT $LN3@CreateProt
$LN2@CreateProt:
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@CreateProt

; 145  :         EmitErr( SYMBOL_REDEFINITION, sym->name );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 146  :         return( NULL );

	xor	eax, eax
	jmp	$LN1@CreateProt
$LN6@CreateProt:
$LN3@CreateProt:

; 147  :     }
; 148  :     dir = (struct dsym *)sym;

	mov	rax, QWORD PTR sym$[rsp]
	mov	QWORD PTR dir$[rsp], rax

; 149  : 
; 150  :     /* a PROTO typedef may be used */
; 151  :     if ( tokenarray[i].token == T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	$LN7@CreateProt

; 152  :         struct asym * sym2;
; 153  :         sym2 = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym2$1[rsp], rax

; 154  :         if ( sym2 && sym2->state == SYM_TYPE && sym2->mem_type == MT_PROC ) {

	cmp	QWORD PTR sym2$1[rsp], 0
	je	SHORT $LN8@CreateProt
	mov	rax, QWORD PTR sym2$1[rsp]
	cmp	DWORD PTR [rax+32], 7
	jne	SHORT $LN8@CreateProt
	mov	rax, QWORD PTR sym2$1[rsp]
	cmp	DWORD PTR [rax+36], 128			; 00000080H
	jne	SHORT $LN8@CreateProt

; 155  :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 156  :             if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN9@CreateProt

; 157  :                 EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 158  :                 return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@CreateProt
$LN9@CreateProt:

; 159  :             }
; 160  :             CopyPrototype( dir, (struct dsym *)sym2->target_type );

	mov	rax, QWORD PTR sym2$1[rsp]
	mov	rdx, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR dir$[rsp]
	call	CopyPrototype

; 161  :             return( sym );

	mov	rax, QWORD PTR sym$[rsp]
	jmp	SHORT $LN1@CreateProt
$LN8@CreateProt:
$LN7@CreateProt:

; 162  :         }
; 163  :     }
; 164  :     /* sym->isproc is set inside ParseProc() */
; 165  :     //sym->isproc = TRUE;
; 166  : 
; 167  :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN10@CreateProt

; 168  :         if ( ParseProc( dir, i, tokenarray, FALSE, langtype ) == ERROR )

	mov	eax, DWORD PTR langtype$[rsp]
	mov	DWORD PTR [rsp+32], eax
	xor	r9d, r9d
	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	call	ParseProc
	cmp	eax, -1
	jne	SHORT $LN12@CreateProt

; 169  :             return( NULL );

	xor	eax, eax
	jmp	SHORT $LN1@CreateProt
$LN12@CreateProt:

; 170  : #if DLLIMPORT
; 171  :         sym->dll = ModuleInfo.CurrDll;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+336
	mov	QWORD PTR [rax+56], rcx

; 172  : #endif
; 173  :     } else {

	jmp	SHORT $LN11@CreateProt
$LN10@CreateProt:

; 174  :         sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al
$LN11@CreateProt:

; 175  :     }
; 176  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]
$LN1@CreateProt:

; 177  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
CreateProto ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
sym$ = 48
name$ = 56
CreateComm PROC

; 103  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 104  :     if ( sym == NULL )

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN2@CreateComm

; 105  :         sym = SymCreate( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymCreate
	mov	QWORD PTR sym$[rsp], rax
	jmp	SHORT $LN3@CreateComm
$LN2@CreateComm:

; 106  :     else
; 107  :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_remove_table
$LN3@CreateComm:

; 108  : 
; 109  :     if ( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN4@CreateComm

; 110  :         sym->state = SYM_EXTERNAL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+32], 2

; 111  :         sym->seg_ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	and	al, 3
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 252					; 000000fcH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 112  :         sym->iscomm = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	or	al, 4
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 113  :         sym->weak = FALSE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	and	al, 247					; 000000f7H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 114  :         sym->isfar = FALSE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	and	al, 239					; 000000efH
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 115  :         sym_add_table( &SymTables[TAB_EXT], (struct dsym *)sym ); /* add EXTERNAL */

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_add_table
$LN4@CreateComm:

; 116  :     }
; 117  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]

; 118  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CreateComm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
sym$ = 48
name$ = 56
weak$ = 64
CreateExternal PROC

; 82   : {

	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 83   :     if ( sym == NULL )

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN2@CreateExte

; 84   :         sym = SymCreate( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	SymCreate
	mov	QWORD PTR sym$[rsp], rax
	jmp	SHORT $LN3@CreateExte
$LN2@CreateExte:

; 85   :     else
; 86   :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_remove_table
$LN3@CreateExte:

; 87   : 
; 88   :     if ( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN4@CreateExte

; 89   :         sym->state = SYM_EXTERNAL;

	mov	rax, QWORD PTR sym$[rsp]
	mov	DWORD PTR [rax+32], 2

; 90   :         sym->seg_ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	and	al, 3
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 252					; 000000fcH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 91   :         sym->iscomm = FALSE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	and	al, 251					; 000000fbH
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 92   :         sym->weak = weak;

	movzx	eax, BYTE PTR weak$[rsp]
	and	al, 1
	shl	al, 3
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 247					; 000000f7H
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 93   :         sym_add_table( &SymTables[TAB_EXT], (struct dsym *)sym ); /* add EXTERNAL */

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR sym$[rsp]
	mov	rcx, rax
	call	sym_add_table
$LN4@CreateExte:

; 94   :     }
; 95   :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]

; 96   : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CreateExternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
FreePubQueue PROC

; 872  : {

$LN3:
	push	rdi

; 873  : #if FASTMEM==0
; 874  :     struct qnode *curr;
; 875  :     struct qnode *next;
; 876  :     for( curr = ModuleInfo.g.PubQueue.head; curr; curr = next ) {
; 877  :         next = curr->next;
; 878  :         LclFree( curr );
; 879  :     }
; 880  : #endif
; 881  :     ModuleInfo.g.PubQueue.head = NULL;

	mov	QWORD PTR ModuleInfo+16, 0

; 882  : }

	pop	rdi
	ret	0
FreePubQueue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
sym$ = 48
AddPublicData PROC

; 832  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 833  :     DebugMsg1(("AddPublicData(%s)\n", sym->name ));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG11091
	call	DoDebugMsg1

; 834  :     QAddItem( &ModuleInfo.g.PubQueue, sym );

	mov	rdx, QWORD PTR sym$[rsp]
	lea	rcx, OFFSET FLAT:ModuleInfo+16
	call	QAddItem

; 835  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
AddPublicData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
_TEXT	SEGMENT
name$ = 48
mem_type$ = 56
vartype$ = 64
sym$ = 72
Ofssize$ = 80
MakeExtern PROC

; 402  : {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 403  :     sym = CreateExternal( sym, name, FALSE );

	xor	r8d, r8d
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	CreateExternal
	mov	QWORD PTR sym$[rsp], rax

; 404  :     if ( sym == NULL )

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN2@MakeExtern

; 405  :         return( NULL );

	xor	eax, eax
	jmp	$LN1@MakeExtern
$LN2@MakeExtern:

; 406  : 
; 407  :     //if ( mem_type == MT_ABS )
; 408  :     if ( mem_type == MT_EMPTY )

	cmp	DWORD PTR mem_type$[rsp], 192		; 000000c0H
	jne	SHORT $LN3@MakeExtern

; 409  :         ;

	jmp	SHORT $LN4@MakeExtern
$LN3@MakeExtern:

; 410  :     else if ( Options.masm_compat_gencode == FALSE || mem_type != MT_FAR )

	movzx	eax, BYTE PTR Options+144
	test	eax, eax
	je	SHORT $LN6@MakeExtern
	cmp	DWORD PTR mem_type$[rsp], 130		; 00000082H
	je	SHORT $LN5@MakeExtern
$LN6@MakeExtern:

; 411  :         sym->segment = &CurrSeg->sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR sym$[rsp]
	mov	QWORD PTR [rcx+24], rax
$LN5@MakeExtern:
$LN4@MakeExtern:

; 412  : 
; 413  :     sym->isdefined = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	or	al, 2
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+40], al

; 414  :     sym->mem_type = mem_type;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR mem_type$[rsp]
	mov	DWORD PTR [rax+36], ecx

; 415  :     sym->seg_ofssize = Ofssize;

	movzx	eax, BYTE PTR Ofssize$[rsp]
	and	al, 3
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	and	cl, 252					; 000000fcH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR sym$[rsp]
	mov	BYTE PTR [rcx+47], al

; 416  :     sym->type = vartype;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR vartype$[rsp]
	mov	QWORD PTR [rax+80], rcx

; 417  :     return( sym );

	mov	rax, QWORD PTR sym$[rsp]
$LN1@MakeExtern:

; 418  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
MakeExtern ENDP
_TEXT	ENDS
END
